{"buggy_code": ["/*\n * apply.c\n *\n * Copyright (C) Linus Torvalds, 2005\n *\n * This applies patches on top of some (arbitrary) version of the SCM.\n *\n */\n\n#include \"cache.h\"\n#include \"config.h\"\n#include \"object-store.h\"\n#include \"blob.h\"\n#include \"delta.h\"\n#include \"diff.h\"\n#include \"dir.h\"\n#include \"xdiff-interface.h\"\n#include \"ll-merge.h\"\n#include \"lockfile.h\"\n#include \"parse-options.h\"\n#include \"quote.h\"\n#include \"rerere.h\"\n#include \"apply.h\"\n\nstruct gitdiff_data {\n\tstruct strbuf *root;\n\tint linenr;\n\tint p_value;\n};\n\nstatic void git_apply_config(void)\n{\n\tgit_config_get_string(\"apply.whitespace\", &apply_default_whitespace);\n\tgit_config_get_string(\"apply.ignorewhitespace\", &apply_default_ignorewhitespace);\n\tgit_config(git_xmerge_config, NULL);\n}\n\nstatic int parse_whitespace_option(struct apply_state *state, const char *option)\n{\n\tif (!option) {\n\t\tstate->ws_error_action = warn_on_ws_error;\n\t\treturn 0;\n\t}\n\tif (!strcmp(option, \"warn\")) {\n\t\tstate->ws_error_action = warn_on_ws_error;\n\t\treturn 0;\n\t}\n\tif (!strcmp(option, \"nowarn\")) {\n\t\tstate->ws_error_action = nowarn_ws_error;\n\t\treturn 0;\n\t}\n\tif (!strcmp(option, \"error\")) {\n\t\tstate->ws_error_action = die_on_ws_error;\n\t\treturn 0;\n\t}\n\tif (!strcmp(option, \"error-all\")) {\n\t\tstate->ws_error_action = die_on_ws_error;\n\t\tstate->squelch_whitespace_errors = 0;\n\t\treturn 0;\n\t}\n\tif (!strcmp(option, \"strip\") || !strcmp(option, \"fix\")) {\n\t\tstate->ws_error_action = correct_ws_error;\n\t\treturn 0;\n\t}\n\t/*\n\t * Please update $__git_whitespacelist in git-completion.bash\n\t * when you add new options.\n\t */\n\treturn error(_(\"unrecognized whitespace option '%s'\"), option);\n}\n\nstatic int parse_ignorewhitespace_option(struct apply_state *state,\n\t\t\t\t\t\t const char *option)\n{\n\tif (!option || !strcmp(option, \"no\") ||\n\t    !strcmp(option, \"false\") || !strcmp(option, \"never\") ||\n\t    !strcmp(option, \"none\")) {\n\t\tstate->ws_ignore_action = ignore_ws_none;\n\t\treturn 0;\n\t}\n\tif (!strcmp(option, \"change\")) {\n\t\tstate->ws_ignore_action = ignore_ws_change;\n\t\treturn 0;\n\t}\n\treturn error(_(\"unrecognized whitespace ignore option '%s'\"), option);\n}\n\nint init_apply_state(struct apply_state *state,\n\t\t     struct repository *repo,\n\t\t     const char *prefix)\n{\n\tmemset(state, 0, sizeof(*state));\n\tstate->prefix = prefix;\n\tstate->repo = repo;\n\tstate->apply = 1;\n\tstate->line_termination = '\\n';\n\tstate->p_value = 1;\n\tstate->p_context = UINT_MAX;\n\tstate->squelch_whitespace_errors = 5;\n\tstate->ws_error_action = warn_on_ws_error;\n\tstate->ws_ignore_action = ignore_ws_none;\n\tstate->linenr = 1;\n\tstring_list_init(&state->fn_table, 0);\n\tstring_list_init(&state->limit_by_name, 0);\n\tstring_list_init(&state->symlink_changes, 0);\n\tstrbuf_init(&state->root, 0);\n\n\tgit_apply_config();\n\tif (apply_default_whitespace && parse_whitespace_option(state, apply_default_whitespace))\n\t\treturn -1;\n\tif (apply_default_ignorewhitespace && parse_ignorewhitespace_option(state, apply_default_ignorewhitespace))\n\t\treturn -1;\n\treturn 0;\n}\n\nvoid clear_apply_state(struct apply_state *state)\n{\n\tstring_list_clear(&state->limit_by_name, 0);\n\tstring_list_clear(&state->symlink_changes, 0);\n\tstrbuf_release(&state->root);\n\n\t/* &state->fn_table is cleared at the end of apply_patch() */\n}\n\nstatic void mute_routine(const char *msg, va_list params)\n{\n\t/* do nothing */\n}\n\nint check_apply_state(struct apply_state *state, int force_apply)\n{\n\tint is_not_gitdir = !startup_info->have_repository;\n\n\tif (state->apply_with_reject && state->threeway)\n\t\treturn error(_(\"--reject and --3way cannot be used together.\"));\n\tif (state->cached && state->threeway)\n\t\treturn error(_(\"--cached and --3way cannot be used together.\"));\n\tif (state->threeway) {\n\t\tif (is_not_gitdir)\n\t\t\treturn error(_(\"--3way outside a repository\"));\n\t\tstate->check_index = 1;\n\t}\n\tif (state->apply_with_reject) {\n\t\tstate->apply = 1;\n\t\tif (state->apply_verbosity == verbosity_normal)\n\t\t\tstate->apply_verbosity = verbosity_verbose;\n\t}\n\tif (!force_apply && (state->diffstat || state->numstat || state->summary || state->check || state->fake_ancestor))\n\t\tstate->apply = 0;\n\tif (state->check_index && is_not_gitdir)\n\t\treturn error(_(\"--index outside a repository\"));\n\tif (state->cached) {\n\t\tif (is_not_gitdir)\n\t\t\treturn error(_(\"--cached outside a repository\"));\n\t\tstate->check_index = 1;\n\t}\n\tif (state->ita_only && (state->check_index || is_not_gitdir))\n\t\tstate->ita_only = 0;\n\tif (state->check_index)\n\t\tstate->unsafe_paths = 0;\n\n\tif (state->apply_verbosity <= verbosity_silent) {\n\t\tstate->saved_error_routine = get_error_routine();\n\t\tstate->saved_warn_routine = get_warn_routine();\n\t\tset_error_routine(mute_routine);\n\t\tset_warn_routine(mute_routine);\n\t}\n\n\treturn 0;\n}\n\nstatic void set_default_whitespace_mode(struct apply_state *state)\n{\n\tif (!state->whitespace_option && !apply_default_whitespace)\n\t\tstate->ws_error_action = (state->apply ? warn_on_ws_error : nowarn_ws_error);\n}\n\n/*\n * This represents one \"hunk\" from a patch, starting with\n * \"@@ -oldpos,oldlines +newpos,newlines @@\" marker.  The\n * patch text is pointed at by patch, and its byte length\n * is stored in size.  leading and trailing are the number\n * of context lines.\n */\nstruct fragment {\n\tunsigned long leading, trailing;\n\tunsigned long oldpos, oldlines;\n\tunsigned long newpos, newlines;\n\t/*\n\t * 'patch' is usually borrowed from buf in apply_patch(),\n\t * but some codepaths store an allocated buffer.\n\t */\n\tconst char *patch;\n\tunsigned free_patch:1,\n\t\trejected:1;\n\tint size;\n\tint linenr;\n\tstruct fragment *next;\n};\n\n/*\n * When dealing with a binary patch, we reuse \"leading\" field\n * to store the type of the binary hunk, either deflated \"delta\"\n * or deflated \"literal\".\n */\n#define binary_patch_method leading\n#define BINARY_DELTA_DEFLATED\t1\n#define BINARY_LITERAL_DEFLATED 2\n\nstatic void free_fragment_list(struct fragment *list)\n{\n\twhile (list) {\n\t\tstruct fragment *next = list->next;\n\t\tif (list->free_patch)\n\t\t\tfree((char *)list->patch);\n\t\tfree(list);\n\t\tlist = next;\n\t}\n}\n\nstatic void free_patch(struct patch *patch)\n{\n\tfree_fragment_list(patch->fragments);\n\tfree(patch->def_name);\n\tfree(patch->old_name);\n\tfree(patch->new_name);\n\tfree(patch->result);\n\tfree(patch);\n}\n\nstatic void free_patch_list(struct patch *list)\n{\n\twhile (list) {\n\t\tstruct patch *next = list->next;\n\t\tfree_patch(list);\n\t\tlist = next;\n\t}\n}\n\n/*\n * A line in a file, len-bytes long (includes the terminating LF,\n * except for an incomplete line at the end if the file ends with\n * one), and its contents hashes to 'hash'.\n */\nstruct line {\n\tsize_t len;\n\tunsigned hash : 24;\n\tunsigned flag : 8;\n#define LINE_COMMON     1\n#define LINE_PATCHED\t2\n};\n\n/*\n * This represents a \"file\", which is an array of \"lines\".\n */\nstruct image {\n\tchar *buf;\n\tsize_t len;\n\tsize_t nr;\n\tsize_t alloc;\n\tstruct line *line_allocated;\n\tstruct line *line;\n};\n\nstatic uint32_t hash_line(const char *cp, size_t len)\n{\n\tsize_t i;\n\tuint32_t h;\n\tfor (i = 0, h = 0; i < len; i++) {\n\t\tif (!isspace(cp[i])) {\n\t\t\th = h * 3 + (cp[i] & 0xff);\n\t\t}\n\t}\n\treturn h;\n}\n\n/*\n * Compare lines s1 of length n1 and s2 of length n2, ignoring\n * whitespace difference. Returns 1 if they match, 0 otherwise\n */\nstatic int fuzzy_matchlines(const char *s1, size_t n1,\n\t\t\t    const char *s2, size_t n2)\n{\n\tconst char *end1 = s1 + n1;\n\tconst char *end2 = s2 + n2;\n\n\t/* ignore line endings */\n\twhile (s1 < end1 && (end1[-1] == '\\r' || end1[-1] == '\\n'))\n\t\tend1--;\n\twhile (s2 < end2 && (end2[-1] == '\\r' || end2[-1] == '\\n'))\n\t\tend2--;\n\n\twhile (s1 < end1 && s2 < end2) {\n\t\tif (isspace(*s1)) {\n\t\t\t/*\n\t\t\t * Skip whitespace. We check on both buffers\n\t\t\t * because we don't want \"a b\" to match \"ab\".\n\t\t\t */\n\t\t\tif (!isspace(*s2))\n\t\t\t\treturn 0;\n\t\t\twhile (s1 < end1 && isspace(*s1))\n\t\t\t\ts1++;\n\t\t\twhile (s2 < end2 && isspace(*s2))\n\t\t\t\ts2++;\n\t\t} else if (*s1++ != *s2++)\n\t\t\treturn 0;\n\t}\n\n\t/* If we reached the end on one side only, lines don't match. */\n\treturn s1 == end1 && s2 == end2;\n}\n\nstatic void add_line_info(struct image *img, const char *bol, size_t len, unsigned flag)\n{\n\tALLOC_GROW(img->line_allocated, img->nr + 1, img->alloc);\n\timg->line_allocated[img->nr].len = len;\n\timg->line_allocated[img->nr].hash = hash_line(bol, len);\n\timg->line_allocated[img->nr].flag = flag;\n\timg->nr++;\n}\n\n/*\n * \"buf\" has the file contents to be patched (read from various sources).\n * attach it to \"image\" and add line-based index to it.\n * \"image\" now owns the \"buf\".\n */\nstatic void prepare_image(struct image *image, char *buf, size_t len,\n\t\t\t  int prepare_linetable)\n{\n\tconst char *cp, *ep;\n\n\tmemset(image, 0, sizeof(*image));\n\timage->buf = buf;\n\timage->len = len;\n\n\tif (!prepare_linetable)\n\t\treturn;\n\n\tep = image->buf + image->len;\n\tcp = image->buf;\n\twhile (cp < ep) {\n\t\tconst char *next;\n\t\tfor (next = cp; next < ep && *next != '\\n'; next++)\n\t\t\t;\n\t\tif (next < ep)\n\t\t\tnext++;\n\t\tadd_line_info(image, cp, next - cp, 0);\n\t\tcp = next;\n\t}\n\timage->line = image->line_allocated;\n}\n\nstatic void clear_image(struct image *image)\n{\n\tfree(image->buf);\n\tfree(image->line_allocated);\n\tmemset(image, 0, sizeof(*image));\n}\n\n/* fmt must contain _one_ %s and no other substitution */\nstatic void say_patch_name(FILE *output, const char *fmt, struct patch *patch)\n{\n\tstruct strbuf sb = STRBUF_INIT;\n\n\tif (patch->old_name && patch->new_name &&\n\t    strcmp(patch->old_name, patch->new_name)) {\n\t\tquote_c_style(patch->old_name, &sb, NULL, 0);\n\t\tstrbuf_addstr(&sb, \" => \");\n\t\tquote_c_style(patch->new_name, &sb, NULL, 0);\n\t} else {\n\t\tconst char *n = patch->new_name;\n\t\tif (!n)\n\t\t\tn = patch->old_name;\n\t\tquote_c_style(n, &sb, NULL, 0);\n\t}\n\tfprintf(output, fmt, sb.buf);\n\tfputc('\\n', output);\n\tstrbuf_release(&sb);\n}\n\n#define SLOP (16)\n\nstatic int read_patch_file(struct strbuf *sb, int fd)\n{\n\tif (strbuf_read(sb, fd, 0) < 0)\n\t\treturn error_errno(\"git apply: failed to read\");\n\n\t/*\n\t * Make sure that we have some slop in the buffer\n\t * so that we can do speculative \"memcmp\" etc, and\n\t * see to it that it is NUL-filled.\n\t */\n\tstrbuf_grow(sb, SLOP);\n\tmemset(sb->buf + sb->len, 0, SLOP);\n\treturn 0;\n}\n\nstatic unsigned long linelen(const char *buffer, unsigned long size)\n{\n\tunsigned long len = 0;\n\twhile (size--) {\n\t\tlen++;\n\t\tif (*buffer++ == '\\n')\n\t\t\tbreak;\n\t}\n\treturn len;\n}\n\nstatic int is_dev_null(const char *str)\n{\n\treturn skip_prefix(str, \"/dev/null\", &str) && isspace(*str);\n}\n\n#define TERM_SPACE\t1\n#define TERM_TAB\t2\n\nstatic int name_terminate(int c, int terminate)\n{\n\tif (c == ' ' && !(terminate & TERM_SPACE))\n\t\treturn 0;\n\tif (c == '\\t' && !(terminate & TERM_TAB))\n\t\treturn 0;\n\n\treturn 1;\n}\n\n/* remove double slashes to make --index work with such filenames */\nstatic char *squash_slash(char *name)\n{\n\tint i = 0, j = 0;\n\n\tif (!name)\n\t\treturn NULL;\n\n\twhile (name[i]) {\n\t\tif ((name[j++] = name[i++]) == '/')\n\t\t\twhile (name[i] == '/')\n\t\t\t\ti++;\n\t}\n\tname[j] = '\\0';\n\treturn name;\n}\n\nstatic char *find_name_gnu(struct strbuf *root,\n\t\t\t   const char *line,\n\t\t\t   int p_value)\n{\n\tstruct strbuf name = STRBUF_INIT;\n\tchar *cp;\n\n\t/*\n\t * Proposed \"new-style\" GNU patch/diff format; see\n\t * https://lore.kernel.org/git/7vll0wvb2a.fsf@assigned-by-dhcp.cox.net/\n\t */\n\tif (unquote_c_style(&name, line, NULL)) {\n\t\tstrbuf_release(&name);\n\t\treturn NULL;\n\t}\n\n\tfor (cp = name.buf; p_value; p_value--) {\n\t\tcp = strchr(cp, '/');\n\t\tif (!cp) {\n\t\t\tstrbuf_release(&name);\n\t\t\treturn NULL;\n\t\t}\n\t\tcp++;\n\t}\n\n\tstrbuf_remove(&name, 0, cp - name.buf);\n\tif (root->len)\n\t\tstrbuf_insert(&name, 0, root->buf, root->len);\n\treturn squash_slash(strbuf_detach(&name, NULL));\n}\n\nstatic size_t sane_tz_len(const char *line, size_t len)\n{\n\tconst char *tz, *p;\n\n\tif (len < strlen(\" +0500\") || line[len-strlen(\" +0500\")] != ' ')\n\t\treturn 0;\n\ttz = line + len - strlen(\" +0500\");\n\n\tif (tz[1] != '+' && tz[1] != '-')\n\t\treturn 0;\n\n\tfor (p = tz + 2; p != line + len; p++)\n\t\tif (!isdigit(*p))\n\t\t\treturn 0;\n\n\treturn line + len - tz;\n}\n\nstatic size_t tz_with_colon_len(const char *line, size_t len)\n{\n\tconst char *tz, *p;\n\n\tif (len < strlen(\" +08:00\") || line[len - strlen(\":00\")] != ':')\n\t\treturn 0;\n\ttz = line + len - strlen(\" +08:00\");\n\n\tif (tz[0] != ' ' || (tz[1] != '+' && tz[1] != '-'))\n\t\treturn 0;\n\tp = tz + 2;\n\tif (!isdigit(*p++) || !isdigit(*p++) || *p++ != ':' ||\n\t    !isdigit(*p++) || !isdigit(*p++))\n\t\treturn 0;\n\n\treturn line + len - tz;\n}\n\nstatic size_t date_len(const char *line, size_t len)\n{\n\tconst char *date, *p;\n\n\tif (len < strlen(\"72-02-05\") || line[len-strlen(\"-05\")] != '-')\n\t\treturn 0;\n\tp = date = line + len - strlen(\"72-02-05\");\n\n\tif (!isdigit(*p++) || !isdigit(*p++) || *p++ != '-' ||\n\t    !isdigit(*p++) || !isdigit(*p++) || *p++ != '-' ||\n\t    !isdigit(*p++) || !isdigit(*p++))\t/* Not a date. */\n\t\treturn 0;\n\n\tif (date - line >= strlen(\"19\") &&\n\t    isdigit(date[-1]) && isdigit(date[-2]))\t/* 4-digit year */\n\t\tdate -= strlen(\"19\");\n\n\treturn line + len - date;\n}\n\nstatic size_t short_time_len(const char *line, size_t len)\n{\n\tconst char *time, *p;\n\n\tif (len < strlen(\" 07:01:32\") || line[len-strlen(\":32\")] != ':')\n\t\treturn 0;\n\tp = time = line + len - strlen(\" 07:01:32\");\n\n\t/* Permit 1-digit hours? */\n\tif (*p++ != ' ' ||\n\t    !isdigit(*p++) || !isdigit(*p++) || *p++ != ':' ||\n\t    !isdigit(*p++) || !isdigit(*p++) || *p++ != ':' ||\n\t    !isdigit(*p++) || !isdigit(*p++))\t/* Not a time. */\n\t\treturn 0;\n\n\treturn line + len - time;\n}\n\nstatic size_t fractional_time_len(const char *line, size_t len)\n{\n\tconst char *p;\n\tsize_t n;\n\n\t/* Expected format: 19:41:17.620000023 */\n\tif (!len || !isdigit(line[len - 1]))\n\t\treturn 0;\n\tp = line + len - 1;\n\n\t/* Fractional seconds. */\n\twhile (p > line && isdigit(*p))\n\t\tp--;\n\tif (*p != '.')\n\t\treturn 0;\n\n\t/* Hours, minutes, and whole seconds. */\n\tn = short_time_len(line, p - line);\n\tif (!n)\n\t\treturn 0;\n\n\treturn line + len - p + n;\n}\n\nstatic size_t trailing_spaces_len(const char *line, size_t len)\n{\n\tconst char *p;\n\n\t/* Expected format: ' ' x (1 or more)  */\n\tif (!len || line[len - 1] != ' ')\n\t\treturn 0;\n\n\tp = line + len;\n\twhile (p != line) {\n\t\tp--;\n\t\tif (*p != ' ')\n\t\t\treturn line + len - (p + 1);\n\t}\n\n\t/* All spaces! */\n\treturn len;\n}\n\nstatic size_t diff_timestamp_len(const char *line, size_t len)\n{\n\tconst char *end = line + len;\n\tsize_t n;\n\n\t/*\n\t * Posix: 2010-07-05 19:41:17\n\t * GNU: 2010-07-05 19:41:17.620000023 -0500\n\t */\n\n\tif (!isdigit(end[-1]))\n\t\treturn 0;\n\n\tn = sane_tz_len(line, end - line);\n\tif (!n)\n\t\tn = tz_with_colon_len(line, end - line);\n\tend -= n;\n\n\tn = short_time_len(line, end - line);\n\tif (!n)\n\t\tn = fractional_time_len(line, end - line);\n\tend -= n;\n\n\tn = date_len(line, end - line);\n\tif (!n)\t/* No date.  Too bad. */\n\t\treturn 0;\n\tend -= n;\n\n\tif (end == line)\t/* No space before date. */\n\t\treturn 0;\n\tif (end[-1] == '\\t') {\t/* Success! */\n\t\tend--;\n\t\treturn line + len - end;\n\t}\n\tif (end[-1] != ' ')\t/* No space before date. */\n\t\treturn 0;\n\n\t/* Whitespace damage. */\n\tend -= trailing_spaces_len(line, end - line);\n\treturn line + len - end;\n}\n\nstatic char *find_name_common(struct strbuf *root,\n\t\t\t      const char *line,\n\t\t\t      const char *def,\n\t\t\t      int p_value,\n\t\t\t      const char *end,\n\t\t\t      int terminate)\n{\n\tint len;\n\tconst char *start = NULL;\n\n\tif (p_value == 0)\n\t\tstart = line;\n\twhile (line != end) {\n\t\tchar c = *line;\n\n\t\tif (!end && isspace(c)) {\n\t\t\tif (c == '\\n')\n\t\t\t\tbreak;\n\t\t\tif (name_terminate(c, terminate))\n\t\t\t\tbreak;\n\t\t}\n\t\tline++;\n\t\tif (c == '/' && !--p_value)\n\t\t\tstart = line;\n\t}\n\tif (!start)\n\t\treturn squash_slash(xstrdup_or_null(def));\n\tlen = line - start;\n\tif (!len)\n\t\treturn squash_slash(xstrdup_or_null(def));\n\n\t/*\n\t * Generally we prefer the shorter name, especially\n\t * if the other one is just a variation of that with\n\t * something else tacked on to the end (ie \"file.orig\"\n\t * or \"file~\").\n\t */\n\tif (def) {\n\t\tint deflen = strlen(def);\n\t\tif (deflen < len && !strncmp(start, def, deflen))\n\t\t\treturn squash_slash(xstrdup(def));\n\t}\n\n\tif (root->len) {\n\t\tchar *ret = xstrfmt(\"%s%.*s\", root->buf, len, start);\n\t\treturn squash_slash(ret);\n\t}\n\n\treturn squash_slash(xmemdupz(start, len));\n}\n\nstatic char *find_name(struct strbuf *root,\n\t\t       const char *line,\n\t\t       char *def,\n\t\t       int p_value,\n\t\t       int terminate)\n{\n\tif (*line == '\"') {\n\t\tchar *name = find_name_gnu(root, line, p_value);\n\t\tif (name)\n\t\t\treturn name;\n\t}\n\n\treturn find_name_common(root, line, def, p_value, NULL, terminate);\n}\n\nstatic char *find_name_traditional(struct strbuf *root,\n\t\t\t\t   const char *line,\n\t\t\t\t   char *def,\n\t\t\t\t   int p_value)\n{\n\tsize_t len;\n\tsize_t date_len;\n\n\tif (*line == '\"') {\n\t\tchar *name = find_name_gnu(root, line, p_value);\n\t\tif (name)\n\t\t\treturn name;\n\t}\n\n\tlen = strchrnul(line, '\\n') - line;\n\tdate_len = diff_timestamp_len(line, len);\n\tif (!date_len)\n\t\treturn find_name_common(root, line, def, p_value, NULL, TERM_TAB);\n\tlen -= date_len;\n\n\treturn find_name_common(root, line, def, p_value, line + len, 0);\n}\n\n/*\n * Given the string after \"--- \" or \"+++ \", guess the appropriate\n * p_value for the given patch.\n */\nstatic int guess_p_value(struct apply_state *state, const char *nameline)\n{\n\tchar *name, *cp;\n\tint val = -1;\n\n\tif (is_dev_null(nameline))\n\t\treturn -1;\n\tname = find_name_traditional(&state->root, nameline, NULL, 0);\n\tif (!name)\n\t\treturn -1;\n\tcp = strchr(name, '/');\n\tif (!cp)\n\t\tval = 0;\n\telse if (state->prefix) {\n\t\t/*\n\t\t * Does it begin with \"a/$our-prefix\" and such?  Then this is\n\t\t * very likely to apply to our directory.\n\t\t */\n\t\tif (starts_with(name, state->prefix))\n\t\t\tval = count_slashes(state->prefix);\n\t\telse {\n\t\t\tcp++;\n\t\t\tif (starts_with(cp, state->prefix))\n\t\t\t\tval = count_slashes(state->prefix) + 1;\n\t\t}\n\t}\n\tfree(name);\n\treturn val;\n}\n\n/*\n * Does the ---/+++ line have the POSIX timestamp after the last HT?\n * GNU diff puts epoch there to signal a creation/deletion event.  Is\n * this such a timestamp?\n */\nstatic int has_epoch_timestamp(const char *nameline)\n{\n\t/*\n\t * We are only interested in epoch timestamp; any non-zero\n\t * fraction cannot be one, hence \"(\\.0+)?\" in the regexp below.\n\t * For the same reason, the date must be either 1969-12-31 or\n\t * 1970-01-01, and the seconds part must be \"00\".\n\t */\n\tconst char stamp_regexp[] =\n\t\t\"^[0-2][0-9]:([0-5][0-9]):00(\\\\.0+)?\"\n\t\t\" \"\n\t\t\"([-+][0-2][0-9]:?[0-5][0-9])\\n\";\n\tconst char *timestamp = NULL, *cp, *colon;\n\tstatic regex_t *stamp;\n\tregmatch_t m[10];\n\tint zoneoffset, epoch_hour, hour, minute;\n\tint status;\n\n\tfor (cp = nameline; *cp != '\\n'; cp++) {\n\t\tif (*cp == '\\t')\n\t\t\ttimestamp = cp + 1;\n\t}\n\tif (!timestamp)\n\t\treturn 0;\n\n\t/*\n\t * YYYY-MM-DD hh:mm:ss must be from either 1969-12-31\n\t * (west of GMT) or 1970-01-01 (east of GMT)\n\t */\n\tif (skip_prefix(timestamp, \"1969-12-31 \", &timestamp))\n\t\tepoch_hour = 24;\n\telse if (skip_prefix(timestamp, \"1970-01-01 \", &timestamp))\n\t\tepoch_hour = 0;\n\telse\n\t\treturn 0;\n\n\tif (!stamp) {\n\t\tstamp = xmalloc(sizeof(*stamp));\n\t\tif (regcomp(stamp, stamp_regexp, REG_EXTENDED)) {\n\t\t\twarning(_(\"Cannot prepare timestamp regexp %s\"),\n\t\t\t\tstamp_regexp);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tstatus = regexec(stamp, timestamp, ARRAY_SIZE(m), m, 0);\n\tif (status) {\n\t\tif (status != REG_NOMATCH)\n\t\t\twarning(_(\"regexec returned %d for input: %s\"),\n\t\t\t\tstatus, timestamp);\n\t\treturn 0;\n\t}\n\n\thour = strtol(timestamp, NULL, 10);\n\tminute = strtol(timestamp + m[1].rm_so, NULL, 10);\n\n\tzoneoffset = strtol(timestamp + m[3].rm_so + 1, (char **) &colon, 10);\n\tif (*colon == ':')\n\t\tzoneoffset = zoneoffset * 60 + strtol(colon + 1, NULL, 10);\n\telse\n\t\tzoneoffset = (zoneoffset / 100) * 60 + (zoneoffset % 100);\n\tif (timestamp[m[3].rm_so] == '-')\n\t\tzoneoffset = -zoneoffset;\n\n\treturn hour * 60 + minute - zoneoffset == epoch_hour * 60;\n}\n\n/*\n * Get the name etc info from the ---/+++ lines of a traditional patch header\n *\n * FIXME! The end-of-filename heuristics are kind of screwy. For existing\n * files, we can happily check the index for a match, but for creating a\n * new file we should try to match whatever \"patch\" does. I have no idea.\n */\nstatic int parse_traditional_patch(struct apply_state *state,\n\t\t\t\t   const char *first,\n\t\t\t\t   const char *second,\n\t\t\t\t   struct patch *patch)\n{\n\tchar *name;\n\n\tfirst += 4;\t/* skip \"--- \" */\n\tsecond += 4;\t/* skip \"+++ \" */\n\tif (!state->p_value_known) {\n\t\tint p, q;\n\t\tp = guess_p_value(state, first);\n\t\tq = guess_p_value(state, second);\n\t\tif (p < 0) p = q;\n\t\tif (0 <= p && p == q) {\n\t\t\tstate->p_value = p;\n\t\t\tstate->p_value_known = 1;\n\t\t}\n\t}\n\tif (is_dev_null(first)) {\n\t\tpatch->is_new = 1;\n\t\tpatch->is_delete = 0;\n\t\tname = find_name_traditional(&state->root, second, NULL, state->p_value);\n\t\tpatch->new_name = name;\n\t} else if (is_dev_null(second)) {\n\t\tpatch->is_new = 0;\n\t\tpatch->is_delete = 1;\n\t\tname = find_name_traditional(&state->root, first, NULL, state->p_value);\n\t\tpatch->old_name = name;\n\t} else {\n\t\tchar *first_name;\n\t\tfirst_name = find_name_traditional(&state->root, first, NULL, state->p_value);\n\t\tname = find_name_traditional(&state->root, second, first_name, state->p_value);\n\t\tfree(first_name);\n\t\tif (has_epoch_timestamp(first)) {\n\t\t\tpatch->is_new = 1;\n\t\t\tpatch->is_delete = 0;\n\t\t\tpatch->new_name = name;\n\t\t} else if (has_epoch_timestamp(second)) {\n\t\t\tpatch->is_new = 0;\n\t\t\tpatch->is_delete = 1;\n\t\t\tpatch->old_name = name;\n\t\t} else {\n\t\t\tpatch->old_name = name;\n\t\t\tpatch->new_name = xstrdup_or_null(name);\n\t\t}\n\t}\n\tif (!name)\n\t\treturn error(_(\"unable to find filename in patch at line %d\"), state->linenr);\n\n\treturn 0;\n}\n\nstatic int gitdiff_hdrend(struct gitdiff_data *state,\n\t\t\t  const char *line,\n\t\t\t  struct patch *patch)\n{\n\treturn 1;\n}\n\n/*\n * We're anal about diff header consistency, to make\n * sure that we don't end up having strange ambiguous\n * patches floating around.\n *\n * As a result, gitdiff_{old|new}name() will check\n * their names against any previous information, just\n * to make sure..\n */\n#define DIFF_OLD_NAME 0\n#define DIFF_NEW_NAME 1\n\nstatic int gitdiff_verify_name(struct gitdiff_data *state,\n\t\t\t       const char *line,\n\t\t\t       int isnull,\n\t\t\t       char **name,\n\t\t\t       int side)\n{\n\tif (!*name && !isnull) {\n\t\t*name = find_name(state->root, line, NULL, state->p_value, TERM_TAB);\n\t\treturn 0;\n\t}\n\n\tif (*name) {\n\t\tchar *another;\n\t\tif (isnull)\n\t\t\treturn error(_(\"git apply: bad git-diff - expected /dev/null, got %s on line %d\"),\n\t\t\t\t     *name, state->linenr);\n\t\tanother = find_name(state->root, line, NULL, state->p_value, TERM_TAB);\n\t\tif (!another || strcmp(another, *name)) {\n\t\t\tfree(another);\n\t\t\treturn error((side == DIFF_NEW_NAME) ?\n\t\t\t    _(\"git apply: bad git-diff - inconsistent new filename on line %d\") :\n\t\t\t    _(\"git apply: bad git-diff - inconsistent old filename on line %d\"), state->linenr);\n\t\t}\n\t\tfree(another);\n\t} else {\n\t\tif (!is_dev_null(line))\n\t\t\treturn error(_(\"git apply: bad git-diff - expected /dev/null on line %d\"), state->linenr);\n\t}\n\n\treturn 0;\n}\n\nstatic int gitdiff_oldname(struct gitdiff_data *state,\n\t\t\t   const char *line,\n\t\t\t   struct patch *patch)\n{\n\treturn gitdiff_verify_name(state, line,\n\t\t\t\t   patch->is_new, &patch->old_name,\n\t\t\t\t   DIFF_OLD_NAME);\n}\n\nstatic int gitdiff_newname(struct gitdiff_data *state,\n\t\t\t   const char *line,\n\t\t\t   struct patch *patch)\n{\n\treturn gitdiff_verify_name(state, line,\n\t\t\t\t   patch->is_delete, &patch->new_name,\n\t\t\t\t   DIFF_NEW_NAME);\n}\n\nstatic int parse_mode_line(const char *line, int linenr, unsigned int *mode)\n{\n\tchar *end;\n\t*mode = strtoul(line, &end, 8);\n\tif (end == line || !isspace(*end))\n\t\treturn error(_(\"invalid mode on line %d: %s\"), linenr, line);\n\treturn 0;\n}\n\nstatic int gitdiff_oldmode(struct gitdiff_data *state,\n\t\t\t   const char *line,\n\t\t\t   struct patch *patch)\n{\n\treturn parse_mode_line(line, state->linenr, &patch->old_mode);\n}\n\nstatic int gitdiff_newmode(struct gitdiff_data *state,\n\t\t\t   const char *line,\n\t\t\t   struct patch *patch)\n{\n\treturn parse_mode_line(line, state->linenr, &patch->new_mode);\n}\n\nstatic int gitdiff_delete(struct gitdiff_data *state,\n\t\t\t  const char *line,\n\t\t\t  struct patch *patch)\n{\n\tpatch->is_delete = 1;\n\tfree(patch->old_name);\n\tpatch->old_name = xstrdup_or_null(patch->def_name);\n\treturn gitdiff_oldmode(state, line, patch);\n}\n\nstatic int gitdiff_newfile(struct gitdiff_data *state,\n\t\t\t   const char *line,\n\t\t\t   struct patch *patch)\n{\n\tpatch->is_new = 1;\n\tfree(patch->new_name);\n\tpatch->new_name = xstrdup_or_null(patch->def_name);\n\treturn gitdiff_newmode(state, line, patch);\n}\n\nstatic int gitdiff_copysrc(struct gitdiff_data *state,\n\t\t\t   const char *line,\n\t\t\t   struct patch *patch)\n{\n\tpatch->is_copy = 1;\n\tfree(patch->old_name);\n\tpatch->old_name = find_name(state->root, line, NULL, state->p_value ? state->p_value - 1 : 0, 0);\n\treturn 0;\n}\n\nstatic int gitdiff_copydst(struct gitdiff_data *state,\n\t\t\t   const char *line,\n\t\t\t   struct patch *patch)\n{\n\tpatch->is_copy = 1;\n\tfree(patch->new_name);\n\tpatch->new_name = find_name(state->root, line, NULL, state->p_value ? state->p_value - 1 : 0, 0);\n\treturn 0;\n}\n\nstatic int gitdiff_renamesrc(struct gitdiff_data *state,\n\t\t\t     const char *line,\n\t\t\t     struct patch *patch)\n{\n\tpatch->is_rename = 1;\n\tfree(patch->old_name);\n\tpatch->old_name = find_name(state->root, line, NULL, state->p_value ? state->p_value - 1 : 0, 0);\n\treturn 0;\n}\n\nstatic int gitdiff_renamedst(struct gitdiff_data *state,\n\t\t\t     const char *line,\n\t\t\t     struct patch *patch)\n{\n\tpatch->is_rename = 1;\n\tfree(patch->new_name);\n\tpatch->new_name = find_name(state->root, line, NULL, state->p_value ? state->p_value - 1 : 0, 0);\n\treturn 0;\n}\n\nstatic int gitdiff_similarity(struct gitdiff_data *state,\n\t\t\t      const char *line,\n\t\t\t      struct patch *patch)\n{\n\tunsigned long val = strtoul(line, NULL, 10);\n\tif (val <= 100)\n\t\tpatch->score = val;\n\treturn 0;\n}\n\nstatic int gitdiff_dissimilarity(struct gitdiff_data *state,\n\t\t\t\t const char *line,\n\t\t\t\t struct patch *patch)\n{\n\tunsigned long val = strtoul(line, NULL, 10);\n\tif (val <= 100)\n\t\tpatch->score = val;\n\treturn 0;\n}\n\nstatic int gitdiff_index(struct gitdiff_data *state,\n\t\t\t const char *line,\n\t\t\t struct patch *patch)\n{\n\t/*\n\t * index line is N hexadecimal, \"..\", N hexadecimal,\n\t * and optional space with octal mode.\n\t */\n\tconst char *ptr, *eol;\n\tint len;\n\tconst unsigned hexsz = the_hash_algo->hexsz;\n\n\tptr = strchr(line, '.');\n\tif (!ptr || ptr[1] != '.' || hexsz < ptr - line)\n\t\treturn 0;\n\tlen = ptr - line;\n\tmemcpy(patch->old_oid_prefix, line, len);\n\tpatch->old_oid_prefix[len] = 0;\n\n\tline = ptr + 2;\n\tptr = strchr(line, ' ');\n\teol = strchrnul(line, '\\n');\n\n\tif (!ptr || eol < ptr)\n\t\tptr = eol;\n\tlen = ptr - line;\n\n\tif (hexsz < len)\n\t\treturn 0;\n\tmemcpy(patch->new_oid_prefix, line, len);\n\tpatch->new_oid_prefix[len] = 0;\n\tif (*ptr == ' ')\n\t\treturn gitdiff_oldmode(state, ptr + 1, patch);\n\treturn 0;\n}\n\n/*\n * This is normal for a diff that doesn't change anything: we'll fall through\n * into the next diff. Tell the parser to break out.\n */\nstatic int gitdiff_unrecognized(struct gitdiff_data *state,\n\t\t\t\tconst char *line,\n\t\t\t\tstruct patch *patch)\n{\n\treturn 1;\n}\n\n/*\n * Skip p_value leading components from \"line\"; as we do not accept\n * absolute paths, return NULL in that case.\n */\nstatic const char *skip_tree_prefix(int p_value,\n\t\t\t\t    const char *line,\n\t\t\t\t    int llen)\n{\n\tint nslash;\n\tint i;\n\n\tif (!p_value)\n\t\treturn (llen && line[0] == '/') ? NULL : line;\n\n\tnslash = p_value;\n\tfor (i = 0; i < llen; i++) {\n\t\tint ch = line[i];\n\t\tif (ch == '/' && --nslash <= 0)\n\t\t\treturn (i == 0) ? NULL : &line[i + 1];\n\t}\n\treturn NULL;\n}\n\n/*\n * This is to extract the same name that appears on \"diff --git\"\n * line.  We do not find and return anything if it is a rename\n * patch, and it is OK because we will find the name elsewhere.\n * We need to reliably find name only when it is mode-change only,\n * creation or deletion of an empty file.  In any of these cases,\n * both sides are the same name under a/ and b/ respectively.\n */\nstatic char *git_header_name(int p_value,\n\t\t\t     const char *line,\n\t\t\t     int llen)\n{\n\tconst char *name;\n\tconst char *second = NULL;\n\tsize_t len, line_len;\n\n\tline += strlen(\"diff --git \");\n\tllen -= strlen(\"diff --git \");\n\n\tif (*line == '\"') {\n\t\tconst char *cp;\n\t\tstruct strbuf first = STRBUF_INIT;\n\t\tstruct strbuf sp = STRBUF_INIT;\n\n\t\tif (unquote_c_style(&first, line, &second))\n\t\t\tgoto free_and_fail1;\n\n\t\t/* strip the a/b prefix including trailing slash */\n\t\tcp = skip_tree_prefix(p_value, first.buf, first.len);\n\t\tif (!cp)\n\t\t\tgoto free_and_fail1;\n\t\tstrbuf_remove(&first, 0, cp - first.buf);\n\n\t\t/*\n\t\t * second points at one past closing dq of name.\n\t\t * find the second name.\n\t\t */\n\t\twhile ((second < line + llen) && isspace(*second))\n\t\t\tsecond++;\n\n\t\tif (line + llen <= second)\n\t\t\tgoto free_and_fail1;\n\t\tif (*second == '\"') {\n\t\t\tif (unquote_c_style(&sp, second, NULL))\n\t\t\t\tgoto free_and_fail1;\n\t\t\tcp = skip_tree_prefix(p_value, sp.buf, sp.len);\n\t\t\tif (!cp)\n\t\t\t\tgoto free_and_fail1;\n\t\t\t/* They must match, otherwise ignore */\n\t\t\tif (strcmp(cp, first.buf))\n\t\t\t\tgoto free_and_fail1;\n\t\t\tstrbuf_release(&sp);\n\t\t\treturn strbuf_detach(&first, NULL);\n\t\t}\n\n\t\t/* unquoted second */\n\t\tcp = skip_tree_prefix(p_value, second, line + llen - second);\n\t\tif (!cp)\n\t\t\tgoto free_and_fail1;\n\t\tif (line + llen - cp != first.len ||\n\t\t    memcmp(first.buf, cp, first.len))\n\t\t\tgoto free_and_fail1;\n\t\treturn strbuf_detach(&first, NULL);\n\n\tfree_and_fail1:\n\t\tstrbuf_release(&first);\n\t\tstrbuf_release(&sp);\n\t\treturn NULL;\n\t}\n\n\t/* unquoted first name */\n\tname = skip_tree_prefix(p_value, line, llen);\n\tif (!name)\n\t\treturn NULL;\n\n\t/*\n\t * since the first name is unquoted, a dq if exists must be\n\t * the beginning of the second name.\n\t */\n\tfor (second = name; second < line + llen; second++) {\n\t\tif (*second == '\"') {\n\t\t\tstruct strbuf sp = STRBUF_INIT;\n\t\t\tconst char *np;\n\n\t\t\tif (unquote_c_style(&sp, second, NULL))\n\t\t\t\tgoto free_and_fail2;\n\n\t\t\tnp = skip_tree_prefix(p_value, sp.buf, sp.len);\n\t\t\tif (!np)\n\t\t\t\tgoto free_and_fail2;\n\n\t\t\tlen = sp.buf + sp.len - np;\n\t\t\tif (len < second - name &&\n\t\t\t    !strncmp(np, name, len) &&\n\t\t\t    isspace(name[len])) {\n\t\t\t\t/* Good */\n\t\t\t\tstrbuf_remove(&sp, 0, np - sp.buf);\n\t\t\t\treturn strbuf_detach(&sp, NULL);\n\t\t\t}\n\n\t\tfree_and_fail2:\n\t\t\tstrbuf_release(&sp);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t/*\n\t * Accept a name only if it shows up twice, exactly the same\n\t * form.\n\t */\n\tsecond = strchr(name, '\\n');\n\tif (!second)\n\t\treturn NULL;\n\tline_len = second - name;\n\tfor (len = 0 ; ; len++) {\n\t\tswitch (name[len]) {\n\t\tdefault:\n\t\t\tcontinue;\n\t\tcase '\\n':\n\t\t\treturn NULL;\n\t\tcase '\\t': case ' ':\n\t\t\t/*\n\t\t\t * Is this the separator between the preimage\n\t\t\t * and the postimage pathname?  Again, we are\n\t\t\t * only interested in the case where there is\n\t\t\t * no rename, as this is only to set def_name\n\t\t\t * and a rename patch has the names elsewhere\n\t\t\t * in an unambiguous form.\n\t\t\t */\n\t\t\tif (!name[len + 1])\n\t\t\t\treturn NULL; /* no postimage name */\n\t\t\tsecond = skip_tree_prefix(p_value, name + len + 1,\n\t\t\t\t\t\t  line_len - (len + 1));\n\t\t\tif (!second)\n\t\t\t\treturn NULL;\n\t\t\t/*\n\t\t\t * Does len bytes starting at \"name\" and \"second\"\n\t\t\t * (that are separated by one HT or SP we just\n\t\t\t * found) exactly match?\n\t\t\t */\n\t\t\tif (second[len] == '\\n' && !strncmp(name, second, len))\n\t\t\t\treturn xmemdupz(name, len);\n\t\t}\n\t}\n}\n\nstatic int check_header_line(int linenr, struct patch *patch)\n{\n\tint extensions = (patch->is_delete == 1) + (patch->is_new == 1) +\n\t\t\t (patch->is_rename == 1) + (patch->is_copy == 1);\n\tif (extensions > 1)\n\t\treturn error(_(\"inconsistent header lines %d and %d\"),\n\t\t\t     patch->extension_linenr, linenr);\n\tif (extensions && !patch->extension_linenr)\n\t\tpatch->extension_linenr = linenr;\n\treturn 0;\n}\n\nint parse_git_diff_header(struct strbuf *root,\n\t\t\t  int *linenr,\n\t\t\t  int p_value,\n\t\t\t  const char *line,\n\t\t\t  int len,\n\t\t\t  unsigned int size,\n\t\t\t  struct patch *patch)\n{\n\tunsigned long offset;\n\tstruct gitdiff_data parse_hdr_state;\n\n\t/* A git diff has explicit new/delete information, so we don't guess */\n\tpatch->is_new = 0;\n\tpatch->is_delete = 0;\n\n\t/*\n\t * Some things may not have the old name in the\n\t * rest of the headers anywhere (pure mode changes,\n\t * or removing or adding empty files), so we get\n\t * the default name from the header.\n\t */\n\tpatch->def_name = git_header_name(p_value, line, len);\n\tif (patch->def_name && root->len) {\n\t\tchar *s = xstrfmt(\"%s%s\", root->buf, patch->def_name);\n\t\tfree(patch->def_name);\n\t\tpatch->def_name = s;\n\t}\n\n\tline += len;\n\tsize -= len;\n\t(*linenr)++;\n\tparse_hdr_state.root = root;\n\tparse_hdr_state.linenr = *linenr;\n\tparse_hdr_state.p_value = p_value;\n\n\tfor (offset = len ; size > 0 ; offset += len, size -= len, line += len, (*linenr)++) {\n\t\tstatic const struct opentry {\n\t\t\tconst char *str;\n\t\t\tint (*fn)(struct gitdiff_data *, const char *, struct patch *);\n\t\t} optable[] = {\n\t\t\t{ \"@@ -\", gitdiff_hdrend },\n\t\t\t{ \"--- \", gitdiff_oldname },\n\t\t\t{ \"+++ \", gitdiff_newname },\n\t\t\t{ \"old mode \", gitdiff_oldmode },\n\t\t\t{ \"new mode \", gitdiff_newmode },\n\t\t\t{ \"deleted file mode \", gitdiff_delete },\n\t\t\t{ \"new file mode \", gitdiff_newfile },\n\t\t\t{ \"copy from \", gitdiff_copysrc },\n\t\t\t{ \"copy to \", gitdiff_copydst },\n\t\t\t{ \"rename old \", gitdiff_renamesrc },\n\t\t\t{ \"rename new \", gitdiff_renamedst },\n\t\t\t{ \"rename from \", gitdiff_renamesrc },\n\t\t\t{ \"rename to \", gitdiff_renamedst },\n\t\t\t{ \"similarity index \", gitdiff_similarity },\n\t\t\t{ \"dissimilarity index \", gitdiff_dissimilarity },\n\t\t\t{ \"index \", gitdiff_index },\n\t\t\t{ \"\", gitdiff_unrecognized },\n\t\t};\n\t\tint i;\n\n\t\tlen = linelen(line, size);\n\t\tif (!len || line[len-1] != '\\n')\n\t\t\tbreak;\n\t\tfor (i = 0; i < ARRAY_SIZE(optable); i++) {\n\t\t\tconst struct opentry *p = optable + i;\n\t\t\tint oplen = strlen(p->str);\n\t\t\tint res;\n\t\t\tif (len < oplen || memcmp(p->str, line, oplen))\n\t\t\t\tcontinue;\n\t\t\tres = p->fn(&parse_hdr_state, line + oplen, patch);\n\t\t\tif (res < 0)\n\t\t\t\treturn -1;\n\t\t\tif (check_header_line(*linenr, patch))\n\t\t\t\treturn -1;\n\t\t\tif (res > 0)\n\t\t\t\tgoto done;\n\t\t\tbreak;\n\t\t}\n\t}\n\ndone:\n\tif (!patch->old_name && !patch->new_name) {\n\t\tif (!patch->def_name) {\n\t\t\terror(Q_(\"git diff header lacks filename information when removing \"\n\t\t\t\t \"%d leading pathname component (line %d)\",\n\t\t\t\t \"git diff header lacks filename information when removing \"\n\t\t\t\t \"%d leading pathname components (line %d)\",\n\t\t\t\t parse_hdr_state.p_value),\n\t\t\t      parse_hdr_state.p_value, *linenr);\n\t\t\treturn -128;\n\t\t}\n\t\tpatch->old_name = xstrdup(patch->def_name);\n\t\tpatch->new_name = xstrdup(patch->def_name);\n\t}\n\tif ((!patch->new_name && !patch->is_delete) ||\n\t    (!patch->old_name && !patch->is_new)) {\n\t\terror(_(\"git diff header lacks filename information \"\n\t\t\t\"(line %d)\"), *linenr);\n\t\treturn -128;\n\t}\n\tpatch->is_toplevel_relative = 1;\n\treturn offset;\n}\n\nstatic int parse_num(const char *line, unsigned long *p)\n{\n\tchar *ptr;\n\n\tif (!isdigit(*line))\n\t\treturn 0;\n\t*p = strtoul(line, &ptr, 10);\n\treturn ptr - line;\n}\n\nstatic int parse_range(const char *line, int len, int offset, const char *expect,\n\t\t       unsigned long *p1, unsigned long *p2)\n{\n\tint digits, ex;\n\n\tif (offset < 0 || offset >= len)\n\t\treturn -1;\n\tline += offset;\n\tlen -= offset;\n\n\tdigits = parse_num(line, p1);\n\tif (!digits)\n\t\treturn -1;\n\n\toffset += digits;\n\tline += digits;\n\tlen -= digits;\n\n\t*p2 = 1;\n\tif (*line == ',') {\n\t\tdigits = parse_num(line+1, p2);\n\t\tif (!digits)\n\t\t\treturn -1;\n\n\t\toffset += digits+1;\n\t\tline += digits+1;\n\t\tlen -= digits+1;\n\t}\n\n\tex = strlen(expect);\n\tif (ex > len)\n\t\treturn -1;\n\tif (memcmp(line, expect, ex))\n\t\treturn -1;\n\n\treturn offset + ex;\n}\n\nstatic void recount_diff(const char *line, int size, struct fragment *fragment)\n{\n\tint oldlines = 0, newlines = 0, ret = 0;\n\n\tif (size < 1) {\n\t\twarning(\"recount: ignore empty hunk\");\n\t\treturn;\n\t}\n\n\tfor (;;) {\n\t\tint len = linelen(line, size);\n\t\tsize -= len;\n\t\tline += len;\n\n\t\tif (size < 1)\n\t\t\tbreak;\n\n\t\tswitch (*line) {\n\t\tcase ' ': case '\\n':\n\t\t\tnewlines++;\n\t\t\t/* fall through */\n\t\tcase '-':\n\t\t\toldlines++;\n\t\t\tcontinue;\n\t\tcase '+':\n\t\t\tnewlines++;\n\t\t\tcontinue;\n\t\tcase '\\\\':\n\t\t\tcontinue;\n\t\tcase '@':\n\t\t\tret = size < 3 || !starts_with(line, \"@@ \");\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tret = size < 5 || !starts_with(line, \"diff \");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\t\tif (ret) {\n\t\t\twarning(_(\"recount: unexpected line: %.*s\"),\n\t\t\t\t(int)linelen(line, size), line);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\t}\n\tfragment->oldlines = oldlines;\n\tfragment->newlines = newlines;\n}\n\n/*\n * Parse a unified diff fragment header of the\n * form \"@@ -a,b +c,d @@\"\n */\nstatic int parse_fragment_header(const char *line, int len, struct fragment *fragment)\n{\n\tint offset;\n\n\tif (!len || line[len-1] != '\\n')\n\t\treturn -1;\n\n\t/* Figure out the number of lines in a fragment */\n\toffset = parse_range(line, len, 4, \" +\", &fragment->oldpos, &fragment->oldlines);\n\toffset = parse_range(line, len, offset, \" @@\", &fragment->newpos, &fragment->newlines);\n\n\treturn offset;\n}\n\n/*\n * Find file diff header\n *\n * Returns:\n *  -1 if no header was found\n *  -128 in case of error\n *   the size of the header in bytes (called \"offset\") otherwise\n */\nstatic int find_header(struct apply_state *state,\n\t\t       const char *line,\n\t\t       unsigned long size,\n\t\t       int *hdrsize,\n\t\t       struct patch *patch)\n{\n\tunsigned long offset, len;\n\n\tpatch->is_toplevel_relative = 0;\n\tpatch->is_rename = patch->is_copy = 0;\n\tpatch->is_new = patch->is_delete = -1;\n\tpatch->old_mode = patch->new_mode = 0;\n\tpatch->old_name = patch->new_name = NULL;\n\tfor (offset = 0; size > 0; offset += len, size -= len, line += len, state->linenr++) {\n\t\tunsigned long nextlen;\n\n\t\tlen = linelen(line, size);\n\t\tif (!len)\n\t\t\tbreak;\n\n\t\t/* Testing this early allows us to take a few shortcuts.. */\n\t\tif (len < 6)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Make sure we don't find any unconnected patch fragments.\n\t\t * That's a sign that we didn't find a header, and that a\n\t\t * patch has become corrupted/broken up.\n\t\t */\n\t\tif (!memcmp(\"@@ -\", line, 4)) {\n\t\t\tstruct fragment dummy;\n\t\t\tif (parse_fragment_header(line, len, &dummy) < 0)\n\t\t\t\tcontinue;\n\t\t\terror(_(\"patch fragment without header at line %d: %.*s\"),\n\t\t\t\t     state->linenr, (int)len-1, line);\n\t\t\treturn -128;\n\t\t}\n\n\t\tif (size < len + 6)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Git patch? It might not have a real patch, just a rename\n\t\t * or mode change, so we handle that specially\n\t\t */\n\t\tif (!memcmp(\"diff --git \", line, 11)) {\n\t\t\tint git_hdr_len = parse_git_diff_header(&state->root, &state->linenr,\n\t\t\t\t\t\t\t\tstate->p_value, line, len,\n\t\t\t\t\t\t\t\tsize, patch);\n\t\t\tif (git_hdr_len < 0)\n\t\t\t\treturn -128;\n\t\t\tif (git_hdr_len <= len)\n\t\t\t\tcontinue;\n\t\t\t*hdrsize = git_hdr_len;\n\t\t\treturn offset;\n\t\t}\n\n\t\t/* --- followed by +++ ? */\n\t\tif (memcmp(\"--- \", line,  4) || memcmp(\"+++ \", line + len, 4))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We only accept unified patches, so we want it to\n\t\t * at least have \"@@ -a,b +c,d @@\\n\", which is 14 chars\n\t\t * minimum (\"@@ -0,0 +1 @@\\n\" is the shortest).\n\t\t */\n\t\tnextlen = linelen(line + len, size - len);\n\t\tif (size < nextlen + 14 || memcmp(\"@@ -\", line + len + nextlen, 4))\n\t\t\tcontinue;\n\n\t\t/* Ok, we'll consider it a patch */\n\t\tif (parse_traditional_patch(state, line, line+len, patch))\n\t\t\treturn -128;\n\t\t*hdrsize = len + nextlen;\n\t\tstate->linenr += 2;\n\t\treturn offset;\n\t}\n\treturn -1;\n}\n\nstatic void record_ws_error(struct apply_state *state,\n\t\t\t    unsigned result,\n\t\t\t    const char *line,\n\t\t\t    int len,\n\t\t\t    int linenr)\n{\n\tchar *err;\n\n\tif (!result)\n\t\treturn;\n\n\tstate->whitespace_error++;\n\tif (state->squelch_whitespace_errors &&\n\t    state->squelch_whitespace_errors < state->whitespace_error)\n\t\treturn;\n\n\terr = whitespace_error_string(result);\n\tif (state->apply_verbosity > verbosity_silent)\n\t\tfprintf(stderr, \"%s:%d: %s.\\n%.*s\\n\",\n\t\t\tstate->patch_input_file, linenr, err, len, line);\n\tfree(err);\n}\n\nstatic void check_whitespace(struct apply_state *state,\n\t\t\t     const char *line,\n\t\t\t     int len,\n\t\t\t     unsigned ws_rule)\n{\n\tunsigned result = ws_check(line + 1, len - 1, ws_rule);\n\n\trecord_ws_error(state, result, line + 1, len - 2, state->linenr);\n}\n\n/*\n * Check if the patch has context lines with CRLF or\n * the patch wants to remove lines with CRLF.\n */\nstatic void check_old_for_crlf(struct patch *patch, const char *line, int len)\n{\n\tif (len >= 2 && line[len-1] == '\\n' && line[len-2] == '\\r') {\n\t\tpatch->ws_rule |= WS_CR_AT_EOL;\n\t\tpatch->crlf_in_old = 1;\n\t}\n}\n\n\n/*\n * Parse a unified diff. Note that this really needs to parse each\n * fragment separately, since the only way to know the difference\n * between a \"---\" that is part of a patch, and a \"---\" that starts\n * the next patch is to look at the line counts..\n */\nstatic int parse_fragment(struct apply_state *state,\n\t\t\t  const char *line,\n\t\t\t  unsigned long size,\n\t\t\t  struct patch *patch,\n\t\t\t  struct fragment *fragment)\n{\n\tint added, deleted;\n\tint len = linelen(line, size), offset;\n\tunsigned long oldlines, newlines;\n\tunsigned long leading, trailing;\n\n\toffset = parse_fragment_header(line, len, fragment);\n\tif (offset < 0)\n\t\treturn -1;\n\tif (offset > 0 && patch->recount)\n\t\trecount_diff(line + offset, size - offset, fragment);\n\toldlines = fragment->oldlines;\n\tnewlines = fragment->newlines;\n\tleading = 0;\n\ttrailing = 0;\n\n\t/* Parse the thing.. */\n\tline += len;\n\tsize -= len;\n\tstate->linenr++;\n\tadded = deleted = 0;\n\tfor (offset = len;\n\t     0 < size;\n\t     offset += len, size -= len, line += len, state->linenr++) {\n\t\tif (!oldlines && !newlines)\n\t\t\tbreak;\n\t\tlen = linelen(line, size);\n\t\tif (!len || line[len-1] != '\\n')\n\t\t\treturn -1;\n\t\tswitch (*line) {\n\t\tdefault:\n\t\t\treturn -1;\n\t\tcase '\\n': /* newer GNU diff, an empty context line */\n\t\tcase ' ':\n\t\t\toldlines--;\n\t\t\tnewlines--;\n\t\t\tif (!deleted && !added)\n\t\t\t\tleading++;\n\t\t\ttrailing++;\n\t\t\tcheck_old_for_crlf(patch, line, len);\n\t\t\tif (!state->apply_in_reverse &&\n\t\t\t    state->ws_error_action == correct_ws_error)\n\t\t\t\tcheck_whitespace(state, line, len, patch->ws_rule);\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\tif (!state->apply_in_reverse)\n\t\t\t\tcheck_old_for_crlf(patch, line, len);\n\t\t\tif (state->apply_in_reverse &&\n\t\t\t    state->ws_error_action != nowarn_ws_error)\n\t\t\t\tcheck_whitespace(state, line, len, patch->ws_rule);\n\t\t\tdeleted++;\n\t\t\toldlines--;\n\t\t\ttrailing = 0;\n\t\t\tbreak;\n\t\tcase '+':\n\t\t\tif (state->apply_in_reverse)\n\t\t\t\tcheck_old_for_crlf(patch, line, len);\n\t\t\tif (!state->apply_in_reverse &&\n\t\t\t    state->ws_error_action != nowarn_ws_error)\n\t\t\t\tcheck_whitespace(state, line, len, patch->ws_rule);\n\t\t\tadded++;\n\t\t\tnewlines--;\n\t\t\ttrailing = 0;\n\t\t\tbreak;\n\n\t\t/*\n\t\t * We allow \"\\ No newline at end of file\". Depending\n\t\t * on locale settings when the patch was produced we\n\t\t * don't know what this line looks like. The only\n\t\t * thing we do know is that it begins with \"\\ \".\n\t\t * Checking for 12 is just for sanity check -- any\n\t\t * l10n of \"\\ No newline...\" is at least that long.\n\t\t */\n\t\tcase '\\\\':\n\t\t\tif (len < 12 || memcmp(line, \"\\\\ \", 2))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (oldlines || newlines)\n\t\treturn -1;\n\tif (!patch->recount && !deleted && !added)\n\t\treturn -1;\n\n\tfragment->leading = leading;\n\tfragment->trailing = trailing;\n\n\t/*\n\t * If a fragment ends with an incomplete line, we failed to include\n\t * it in the above loop because we hit oldlines == newlines == 0\n\t * before seeing it.\n\t */\n\tif (12 < size && !memcmp(line, \"\\\\ \", 2))\n\t\toffset += linelen(line, size);\n\n\tpatch->lines_added += added;\n\tpatch->lines_deleted += deleted;\n\n\tif (0 < patch->is_new && oldlines)\n\t\treturn error(_(\"new file depends on old contents\"));\n\tif (0 < patch->is_delete && newlines)\n\t\treturn error(_(\"deleted file still has contents\"));\n\treturn offset;\n}\n\n/*\n * We have seen \"diff --git a/... b/...\" header (or a traditional patch\n * header).  Read hunks that belong to this patch into fragments and hang\n * them to the given patch structure.\n *\n * The (fragment->patch, fragment->size) pair points into the memory given\n * by the caller, not a copy, when we return.\n *\n * Returns:\n *   -1 in case of error,\n *   the number of bytes in the patch otherwise.\n */\nstatic int parse_single_patch(struct apply_state *state,\n\t\t\t      const char *line,\n\t\t\t      unsigned long size,\n\t\t\t      struct patch *patch)\n{\n\tunsigned long offset = 0;\n\tunsigned long oldlines = 0, newlines = 0, context = 0;\n\tstruct fragment **fragp = &patch->fragments;\n\n\twhile (size > 4 && !memcmp(line, \"@@ -\", 4)) {\n\t\tstruct fragment *fragment;\n\t\tint len;\n\n\t\tfragment = xcalloc(1, sizeof(*fragment));\n\t\tfragment->linenr = state->linenr;\n\t\tlen = parse_fragment(state, line, size, patch, fragment);\n\t\tif (len <= 0) {\n\t\t\tfree(fragment);\n\t\t\treturn error(_(\"corrupt patch at line %d\"), state->linenr);\n\t\t}\n\t\tfragment->patch = line;\n\t\tfragment->size = len;\n\t\toldlines += fragment->oldlines;\n\t\tnewlines += fragment->newlines;\n\t\tcontext += fragment->leading + fragment->trailing;\n\n\t\t*fragp = fragment;\n\t\tfragp = &fragment->next;\n\n\t\toffset += len;\n\t\tline += len;\n\t\tsize -= len;\n\t}\n\n\t/*\n\t * If something was removed (i.e. we have old-lines) it cannot\n\t * be creation, and if something was added it cannot be\n\t * deletion.  However, the reverse is not true; --unified=0\n\t * patches that only add are not necessarily creation even\n\t * though they do not have any old lines, and ones that only\n\t * delete are not necessarily deletion.\n\t *\n\t * Unfortunately, a real creation/deletion patch do _not_ have\n\t * any context line by definition, so we cannot safely tell it\n\t * apart with --unified=0 insanity.  At least if the patch has\n\t * more than one hunk it is not creation or deletion.\n\t */\n\tif (patch->is_new < 0 &&\n\t    (oldlines || (patch->fragments && patch->fragments->next)))\n\t\tpatch->is_new = 0;\n\tif (patch->is_delete < 0 &&\n\t    (newlines || (patch->fragments && patch->fragments->next)))\n\t\tpatch->is_delete = 0;\n\n\tif (0 < patch->is_new && oldlines)\n\t\treturn error(_(\"new file %s depends on old contents\"), patch->new_name);\n\tif (0 < patch->is_delete && newlines)\n\t\treturn error(_(\"deleted file %s still has contents\"), patch->old_name);\n\tif (!patch->is_delete && !newlines && context && state->apply_verbosity > verbosity_silent)\n\t\tfprintf_ln(stderr,\n\t\t\t   _(\"** warning: \"\n\t\t\t     \"file %s becomes empty but is not deleted\"),\n\t\t\t   patch->new_name);\n\n\treturn offset;\n}\n\nstatic inline int metadata_changes(struct patch *patch)\n{\n\treturn\tpatch->is_rename > 0 ||\n\t\tpatch->is_copy > 0 ||\n\t\tpatch->is_new > 0 ||\n\t\tpatch->is_delete ||\n\t\t(patch->old_mode && patch->new_mode &&\n\t\t patch->old_mode != patch->new_mode);\n}\n\nstatic char *inflate_it(const void *data, unsigned long size,\n\t\t\tunsigned long inflated_size)\n{\n\tgit_zstream stream;\n\tvoid *out;\n\tint st;\n\n\tmemset(&stream, 0, sizeof(stream));\n\n\tstream.next_in = (unsigned char *)data;\n\tstream.avail_in = size;\n\tstream.next_out = out = xmalloc(inflated_size);\n\tstream.avail_out = inflated_size;\n\tgit_inflate_init(&stream);\n\tst = git_inflate(&stream, Z_FINISH);\n\tgit_inflate_end(&stream);\n\tif ((st != Z_STREAM_END) || stream.total_out != inflated_size) {\n\t\tfree(out);\n\t\treturn NULL;\n\t}\n\treturn out;\n}\n\n/*\n * Read a binary hunk and return a new fragment; fragment->patch\n * points at an allocated memory that the caller must free, so\n * it is marked as \"->free_patch = 1\".\n */\nstatic struct fragment *parse_binary_hunk(struct apply_state *state,\n\t\t\t\t\t  char **buf_p,\n\t\t\t\t\t  unsigned long *sz_p,\n\t\t\t\t\t  int *status_p,\n\t\t\t\t\t  int *used_p)\n{\n\t/*\n\t * Expect a line that begins with binary patch method (\"literal\"\n\t * or \"delta\"), followed by the length of data before deflating.\n\t * a sequence of 'length-byte' followed by base-85 encoded data\n\t * should follow, terminated by a newline.\n\t *\n\t * Each 5-byte sequence of base-85 encodes up to 4 bytes,\n\t * and we would limit the patch line to 66 characters,\n\t * so one line can fit up to 13 groups that would decode\n\t * to 52 bytes max.  The length byte 'A'-'Z' corresponds\n\t * to 1-26 bytes, and 'a'-'z' corresponds to 27-52 bytes.\n\t */\n\tint llen, used;\n\tunsigned long size = *sz_p;\n\tchar *buffer = *buf_p;\n\tint patch_method;\n\tunsigned long origlen;\n\tchar *data = NULL;\n\tint hunk_size = 0;\n\tstruct fragment *frag;\n\n\tllen = linelen(buffer, size);\n\tused = llen;\n\n\t*status_p = 0;\n\n\tif (starts_with(buffer, \"delta \")) {\n\t\tpatch_method = BINARY_DELTA_DEFLATED;\n\t\toriglen = strtoul(buffer + 6, NULL, 10);\n\t}\n\telse if (starts_with(buffer, \"literal \")) {\n\t\tpatch_method = BINARY_LITERAL_DEFLATED;\n\t\toriglen = strtoul(buffer + 8, NULL, 10);\n\t}\n\telse\n\t\treturn NULL;\n\n\tstate->linenr++;\n\tbuffer += llen;\n\twhile (1) {\n\t\tint byte_length, max_byte_length, newsize;\n\t\tllen = linelen(buffer, size);\n\t\tused += llen;\n\t\tstate->linenr++;\n\t\tif (llen == 1) {\n\t\t\t/* consume the blank line */\n\t\t\tbuffer++;\n\t\t\tsize--;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Minimum line is \"A00000\\n\" which is 7-byte long,\n\t\t * and the line length must be multiple of 5 plus 2.\n\t\t */\n\t\tif ((llen < 7) || (llen-2) % 5)\n\t\t\tgoto corrupt;\n\t\tmax_byte_length = (llen - 2) / 5 * 4;\n\t\tbyte_length = *buffer;\n\t\tif ('A' <= byte_length && byte_length <= 'Z')\n\t\t\tbyte_length = byte_length - 'A' + 1;\n\t\telse if ('a' <= byte_length && byte_length <= 'z')\n\t\t\tbyte_length = byte_length - 'a' + 27;\n\t\telse\n\t\t\tgoto corrupt;\n\t\t/* if the input length was not multiple of 4, we would\n\t\t * have filler at the end but the filler should never\n\t\t * exceed 3 bytes\n\t\t */\n\t\tif (max_byte_length < byte_length ||\n\t\t    byte_length <= max_byte_length - 4)\n\t\t\tgoto corrupt;\n\t\tnewsize = hunk_size + byte_length;\n\t\tdata = xrealloc(data, newsize);\n\t\tif (decode_85(data + hunk_size, buffer + 1, byte_length))\n\t\t\tgoto corrupt;\n\t\thunk_size = newsize;\n\t\tbuffer += llen;\n\t\tsize -= llen;\n\t}\n\n\tfrag = xcalloc(1, sizeof(*frag));\n\tfrag->patch = inflate_it(data, hunk_size, origlen);\n\tfrag->free_patch = 1;\n\tif (!frag->patch)\n\t\tgoto corrupt;\n\tfree(data);\n\tfrag->size = origlen;\n\t*buf_p = buffer;\n\t*sz_p = size;\n\t*used_p = used;\n\tfrag->binary_patch_method = patch_method;\n\treturn frag;\n\n corrupt:\n\tfree(data);\n\t*status_p = -1;\n\terror(_(\"corrupt binary patch at line %d: %.*s\"),\n\t      state->linenr-1, llen-1, buffer);\n\treturn NULL;\n}\n\n/*\n * Returns:\n *   -1 in case of error,\n *   the length of the parsed binary patch otherwise\n */\nstatic int parse_binary(struct apply_state *state,\n\t\t\tchar *buffer,\n\t\t\tunsigned long size,\n\t\t\tstruct patch *patch)\n{\n\t/*\n\t * We have read \"GIT binary patch\\n\"; what follows is a line\n\t * that says the patch method (currently, either \"literal\" or\n\t * \"delta\") and the length of data before deflating; a\n\t * sequence of 'length-byte' followed by base-85 encoded data\n\t * follows.\n\t *\n\t * When a binary patch is reversible, there is another binary\n\t * hunk in the same format, starting with patch method (either\n\t * \"literal\" or \"delta\") with the length of data, and a sequence\n\t * of length-byte + base-85 encoded data, terminated with another\n\t * empty line.  This data, when applied to the postimage, produces\n\t * the preimage.\n\t */\n\tstruct fragment *forward;\n\tstruct fragment *reverse;\n\tint status;\n\tint used, used_1;\n\n\tforward = parse_binary_hunk(state, &buffer, &size, &status, &used);\n\tif (!forward && !status)\n\t\t/* there has to be one hunk (forward hunk) */\n\t\treturn error(_(\"unrecognized binary patch at line %d\"), state->linenr-1);\n\tif (status)\n\t\t/* otherwise we already gave an error message */\n\t\treturn status;\n\n\treverse = parse_binary_hunk(state, &buffer, &size, &status, &used_1);\n\tif (reverse)\n\t\tused += used_1;\n\telse if (status) {\n\t\t/*\n\t\t * Not having reverse hunk is not an error, but having\n\t\t * a corrupt reverse hunk is.\n\t\t */\n\t\tfree((void*) forward->patch);\n\t\tfree(forward);\n\t\treturn status;\n\t}\n\tforward->next = reverse;\n\tpatch->fragments = forward;\n\tpatch->is_binary = 1;\n\treturn used;\n}\n\nstatic void prefix_one(struct apply_state *state, char **name)\n{\n\tchar *old_name = *name;\n\tif (!old_name)\n\t\treturn;\n\t*name = prefix_filename(state->prefix, *name);\n\tfree(old_name);\n}\n\nstatic void prefix_patch(struct apply_state *state, struct patch *p)\n{\n\tif (!state->prefix || p->is_toplevel_relative)\n\t\treturn;\n\tprefix_one(state, &p->new_name);\n\tprefix_one(state, &p->old_name);\n}\n\n/*\n * include/exclude\n */\n\nstatic void add_name_limit(struct apply_state *state,\n\t\t\t   const char *name,\n\t\t\t   int exclude)\n{\n\tstruct string_list_item *it;\n\n\tit = string_list_append(&state->limit_by_name, name);\n\tit->util = exclude ? NULL : (void *) 1;\n}\n\nstatic int use_patch(struct apply_state *state, struct patch *p)\n{\n\tconst char *pathname = p->new_name ? p->new_name : p->old_name;\n\tint i;\n\n\t/* Paths outside are not touched regardless of \"--include\" */\n\tif (state->prefix && *state->prefix) {\n\t\tconst char *rest;\n\t\tif (!skip_prefix(pathname, state->prefix, &rest) || !*rest)\n\t\t\treturn 0;\n\t}\n\n\t/* See if it matches any of exclude/include rule */\n\tfor (i = 0; i < state->limit_by_name.nr; i++) {\n\t\tstruct string_list_item *it = &state->limit_by_name.items[i];\n\t\tif (!wildmatch(it->string, pathname, 0))\n\t\t\treturn (it->util != NULL);\n\t}\n\n\t/*\n\t * If we had any include, a path that does not match any rule is\n\t * not used.  Otherwise, we saw bunch of exclude rules (or none)\n\t * and such a path is used.\n\t */\n\treturn !state->has_include;\n}\n\n/*\n * Read the patch text in \"buffer\" that extends for \"size\" bytes; stop\n * reading after seeing a single patch (i.e. changes to a single file).\n * Create fragments (i.e. patch hunks) and hang them to the given patch.\n *\n * Returns:\n *   -1 if no header was found or parse_binary() failed,\n *   -128 on another error,\n *   the number of bytes consumed otherwise,\n *     so that the caller can call us again for the next patch.\n */\nstatic int parse_chunk(struct apply_state *state, char *buffer, unsigned long size, struct patch *patch)\n{\n\tint hdrsize, patchsize;\n\tint offset = find_header(state, buffer, size, &hdrsize, patch);\n\n\tif (offset < 0)\n\t\treturn offset;\n\n\tprefix_patch(state, patch);\n\n\tif (!use_patch(state, patch))\n\t\tpatch->ws_rule = 0;\n\telse if (patch->new_name)\n\t\tpatch->ws_rule = whitespace_rule(state->repo->index,\n\t\t\t\t\t\t patch->new_name);\n\telse\n\t\tpatch->ws_rule = whitespace_rule(state->repo->index,\n\t\t\t\t\t\t patch->old_name);\n\n\tpatchsize = parse_single_patch(state,\n\t\t\t\t       buffer + offset + hdrsize,\n\t\t\t\t       size - offset - hdrsize,\n\t\t\t\t       patch);\n\n\tif (patchsize < 0)\n\t\treturn -128;\n\n\tif (!patchsize) {\n\t\tstatic const char git_binary[] = \"GIT binary patch\\n\";\n\t\tint hd = hdrsize + offset;\n\t\tunsigned long llen = linelen(buffer + hd, size - hd);\n\n\t\tif (llen == sizeof(git_binary) - 1 &&\n\t\t    !memcmp(git_binary, buffer + hd, llen)) {\n\t\t\tint used;\n\t\t\tstate->linenr++;\n\t\t\tused = parse_binary(state, buffer + hd + llen,\n\t\t\t\t\t    size - hd - llen, patch);\n\t\t\tif (used < 0)\n\t\t\t\treturn -1;\n\t\t\tif (used)\n\t\t\t\tpatchsize = used + llen;\n\t\t\telse\n\t\t\t\tpatchsize = 0;\n\t\t}\n\t\telse if (!memcmp(\" differ\\n\", buffer + hd + llen - 8, 8)) {\n\t\t\tstatic const char *binhdr[] = {\n\t\t\t\t\"Binary files \",\n\t\t\t\t\"Files \",\n\t\t\t\tNULL,\n\t\t\t};\n\t\t\tint i;\n\t\t\tfor (i = 0; binhdr[i]; i++) {\n\t\t\t\tint len = strlen(binhdr[i]);\n\t\t\t\tif (len < size - hd &&\n\t\t\t\t    !memcmp(binhdr[i], buffer + hd, len)) {\n\t\t\t\t\tstate->linenr++;\n\t\t\t\t\tpatch->is_binary = 1;\n\t\t\t\t\tpatchsize = llen;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Empty patch cannot be applied if it is a text patch\n\t\t * without metadata change.  A binary patch appears\n\t\t * empty to us here.\n\t\t */\n\t\tif ((state->apply || state->check) &&\n\t\t    (!patch->is_binary && !metadata_changes(patch))) {\n\t\t\terror(_(\"patch with only garbage at line %d\"), state->linenr);\n\t\t\treturn -128;\n\t\t}\n\t}\n\n\treturn offset + hdrsize + patchsize;\n}\n\nstatic void reverse_patches(struct patch *p)\n{\n\tfor (; p; p = p->next) {\n\t\tstruct fragment *frag = p->fragments;\n\n\t\tSWAP(p->new_name, p->old_name);\n\t\tSWAP(p->new_mode, p->old_mode);\n\t\tSWAP(p->is_new, p->is_delete);\n\t\tSWAP(p->lines_added, p->lines_deleted);\n\t\tSWAP(p->old_oid_prefix, p->new_oid_prefix);\n\n\t\tfor (; frag; frag = frag->next) {\n\t\t\tSWAP(frag->newpos, frag->oldpos);\n\t\t\tSWAP(frag->newlines, frag->oldlines);\n\t\t}\n\t}\n}\n\nstatic const char pluses[] =\n\"++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\";\nstatic const char minuses[]=\n\"----------------------------------------------------------------------\";\n\nstatic void show_stats(struct apply_state *state, struct patch *patch)\n{\n\tstruct strbuf qname = STRBUF_INIT;\n\tchar *cp = patch->new_name ? patch->new_name : patch->old_name;\n\tint max, add, del;\n\n\tquote_c_style(cp, &qname, NULL, 0);\n\n\t/*\n\t * \"scale\" the filename\n\t */\n\tmax = state->max_len;\n\tif (max > 50)\n\t\tmax = 50;\n\n\tif (qname.len > max) {\n\t\tcp = strchr(qname.buf + qname.len + 3 - max, '/');\n\t\tif (!cp)\n\t\t\tcp = qname.buf + qname.len + 3 - max;\n\t\tstrbuf_splice(&qname, 0, cp - qname.buf, \"...\", 3);\n\t}\n\n\tif (patch->is_binary) {\n\t\tprintf(\" %-*s |  Bin\\n\", max, qname.buf);\n\t\tstrbuf_release(&qname);\n\t\treturn;\n\t}\n\n\tprintf(\" %-*s |\", max, qname.buf);\n\tstrbuf_release(&qname);\n\n\t/*\n\t * scale the add/delete\n\t */\n\tmax = max + state->max_change > 70 ? 70 - max : state->max_change;\n\tadd = patch->lines_added;\n\tdel = patch->lines_deleted;\n\n\tif (state->max_change > 0) {\n\t\tint total = ((add + del) * max + state->max_change / 2) / state->max_change;\n\t\tadd = (add * max + state->max_change / 2) / state->max_change;\n\t\tdel = total - add;\n\t}\n\tprintf(\"%5d %.*s%.*s\\n\", patch->lines_added + patch->lines_deleted,\n\t\tadd, pluses, del, minuses);\n}\n\nstatic int read_old_data(struct stat *st, struct patch *patch,\n\t\t\t const char *path, struct strbuf *buf)\n{\n\tint conv_flags = patch->crlf_in_old ?\n\t\tCONV_EOL_KEEP_CRLF : CONV_EOL_RENORMALIZE;\n\tswitch (st->st_mode & S_IFMT) {\n\tcase S_IFLNK:\n\t\tif (strbuf_readlink(buf, path, st->st_size) < 0)\n\t\t\treturn error(_(\"unable to read symlink %s\"), path);\n\t\treturn 0;\n\tcase S_IFREG:\n\t\tif (strbuf_read_file(buf, path, st->st_size) != st->st_size)\n\t\t\treturn error(_(\"unable to open or read %s\"), path);\n\t\t/*\n\t\t * \"git apply\" without \"--index/--cached\" should never look\n\t\t * at the index; the target file may not have been added to\n\t\t * the index yet, and we may not even be in any Git repository.\n\t\t * Pass NULL to convert_to_git() to stress this; the function\n\t\t * should never look at the index when explicit crlf option\n\t\t * is given.\n\t\t */\n\t\tconvert_to_git(NULL, path, buf->buf, buf->len, buf, conv_flags);\n\t\treturn 0;\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\n/*\n * Update the preimage, and the common lines in postimage,\n * from buffer buf of length len. If postlen is 0 the postimage\n * is updated in place, otherwise it's updated on a new buffer\n * of length postlen\n */\n\nstatic void update_pre_post_images(struct image *preimage,\n\t\t\t\t   struct image *postimage,\n\t\t\t\t   char *buf,\n\t\t\t\t   size_t len, size_t postlen)\n{\n\tint i, ctx, reduced;\n\tchar *new_buf, *old_buf, *fixed;\n\tstruct image fixed_preimage;\n\n\t/*\n\t * Update the preimage with whitespace fixes.  Note that we\n\t * are not losing preimage->buf -- apply_one_fragment() will\n\t * free \"oldlines\".\n\t */\n\tprepare_image(&fixed_preimage, buf, len, 1);\n\tassert(postlen\n\t       ? fixed_preimage.nr == preimage->nr\n\t       : fixed_preimage.nr <= preimage->nr);\n\tfor (i = 0; i < fixed_preimage.nr; i++)\n\t\tfixed_preimage.line[i].flag = preimage->line[i].flag;\n\tfree(preimage->line_allocated);\n\t*preimage = fixed_preimage;\n\n\t/*\n\t * Adjust the common context lines in postimage. This can be\n\t * done in-place when we are shrinking it with whitespace\n\t * fixing, but needs a new buffer when ignoring whitespace or\n\t * expanding leading tabs to spaces.\n\t *\n\t * We trust the caller to tell us if the update can be done\n\t * in place (postlen==0) or not.\n\t */\n\told_buf = postimage->buf;\n\tif (postlen)\n\t\tnew_buf = postimage->buf = xmalloc(postlen);\n\telse\n\t\tnew_buf = old_buf;\n\tfixed = preimage->buf;\n\n\tfor (i = reduced = ctx = 0; i < postimage->nr; i++) {\n\t\tsize_t l_len = postimage->line[i].len;\n\t\tif (!(postimage->line[i].flag & LINE_COMMON)) {\n\t\t\t/* an added line -- no counterparts in preimage */\n\t\t\tmemmove(new_buf, old_buf, l_len);\n\t\t\told_buf += l_len;\n\t\t\tnew_buf += l_len;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* a common context -- skip it in the original postimage */\n\t\told_buf += l_len;\n\n\t\t/* and find the corresponding one in the fixed preimage */\n\t\twhile (ctx < preimage->nr &&\n\t\t       !(preimage->line[ctx].flag & LINE_COMMON)) {\n\t\t\tfixed += preimage->line[ctx].len;\n\t\t\tctx++;\n\t\t}\n\n\t\t/*\n\t\t * preimage is expected to run out, if the caller\n\t\t * fixed addition of trailing blank lines.\n\t\t */\n\t\tif (preimage->nr <= ctx) {\n\t\t\treduced++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* and copy it in, while fixing the line length */\n\t\tl_len = preimage->line[ctx].len;\n\t\tmemcpy(new_buf, fixed, l_len);\n\t\tnew_buf += l_len;\n\t\tfixed += l_len;\n\t\tpostimage->line[i].len = l_len;\n\t\tctx++;\n\t}\n\n\tif (postlen\n\t    ? postlen < new_buf - postimage->buf\n\t    : postimage->len < new_buf - postimage->buf)\n\t\tBUG(\"caller miscounted postlen: asked %d, orig = %d, used = %d\",\n\t\t    (int)postlen, (int) postimage->len, (int)(new_buf - postimage->buf));\n\n\t/* Fix the length of the whole thing */\n\tpostimage->len = new_buf - postimage->buf;\n\tpostimage->nr -= reduced;\n}\n\nstatic int line_by_line_fuzzy_match(struct image *img,\n\t\t\t\t    struct image *preimage,\n\t\t\t\t    struct image *postimage,\n\t\t\t\t    unsigned long current,\n\t\t\t\t    int current_lno,\n\t\t\t\t    int preimage_limit)\n{\n\tint i;\n\tsize_t imgoff = 0;\n\tsize_t preoff = 0;\n\tsize_t postlen = postimage->len;\n\tsize_t extra_chars;\n\tchar *buf;\n\tchar *preimage_eof;\n\tchar *preimage_end;\n\tstruct strbuf fixed;\n\tchar *fixed_buf;\n\tsize_t fixed_len;\n\n\tfor (i = 0; i < preimage_limit; i++) {\n\t\tsize_t prelen = preimage->line[i].len;\n\t\tsize_t imglen = img->line[current_lno+i].len;\n\n\t\tif (!fuzzy_matchlines(img->buf + current + imgoff, imglen,\n\t\t\t\t      preimage->buf + preoff, prelen))\n\t\t\treturn 0;\n\t\tif (preimage->line[i].flag & LINE_COMMON)\n\t\t\tpostlen += imglen - prelen;\n\t\timgoff += imglen;\n\t\tpreoff += prelen;\n\t}\n\n\t/*\n\t * Ok, the preimage matches with whitespace fuzz.\n\t *\n\t * imgoff now holds the true length of the target that\n\t * matches the preimage before the end of the file.\n\t *\n\t * Count the number of characters in the preimage that fall\n\t * beyond the end of the file and make sure that all of them\n\t * are whitespace characters. (This can only happen if\n\t * we are removing blank lines at the end of the file.)\n\t */\n\tbuf = preimage_eof = preimage->buf + preoff;\n\tfor ( ; i < preimage->nr; i++)\n\t\tpreoff += preimage->line[i].len;\n\tpreimage_end = preimage->buf + preoff;\n\tfor ( ; buf < preimage_end; buf++)\n\t\tif (!isspace(*buf))\n\t\t\treturn 0;\n\n\t/*\n\t * Update the preimage and the common postimage context\n\t * lines to use the same whitespace as the target.\n\t * If whitespace is missing in the target (i.e.\n\t * if the preimage extends beyond the end of the file),\n\t * use the whitespace from the preimage.\n\t */\n\textra_chars = preimage_end - preimage_eof;\n\tstrbuf_init(&fixed, imgoff + extra_chars);\n\tstrbuf_add(&fixed, img->buf + current, imgoff);\n\tstrbuf_add(&fixed, preimage_eof, extra_chars);\n\tfixed_buf = strbuf_detach(&fixed, &fixed_len);\n\tupdate_pre_post_images(preimage, postimage,\n\t\t\t       fixed_buf, fixed_len, postlen);\n\treturn 1;\n}\n\nstatic int match_fragment(struct apply_state *state,\n\t\t\t  struct image *img,\n\t\t\t  struct image *preimage,\n\t\t\t  struct image *postimage,\n\t\t\t  unsigned long current,\n\t\t\t  int current_lno,\n\t\t\t  unsigned ws_rule,\n\t\t\t  int match_beginning, int match_end)\n{\n\tint i;\n\tchar *fixed_buf, *buf, *orig, *target;\n\tstruct strbuf fixed;\n\tsize_t fixed_len, postlen;\n\tint preimage_limit;\n\n\tif (preimage->nr + current_lno <= img->nr) {\n\t\t/*\n\t\t * The hunk falls within the boundaries of img.\n\t\t */\n\t\tpreimage_limit = preimage->nr;\n\t\tif (match_end && (preimage->nr + current_lno != img->nr))\n\t\t\treturn 0;\n\t} else if (state->ws_error_action == correct_ws_error &&\n\t\t   (ws_rule & WS_BLANK_AT_EOF)) {\n\t\t/*\n\t\t * This hunk extends beyond the end of img, and we are\n\t\t * removing blank lines at the end of the file.  This\n\t\t * many lines from the beginning of the preimage must\n\t\t * match with img, and the remainder of the preimage\n\t\t * must be blank.\n\t\t */\n\t\tpreimage_limit = img->nr - current_lno;\n\t} else {\n\t\t/*\n\t\t * The hunk extends beyond the end of the img and\n\t\t * we are not removing blanks at the end, so we\n\t\t * should reject the hunk at this position.\n\t\t */\n\t\treturn 0;\n\t}\n\n\tif (match_beginning && current_lno)\n\t\treturn 0;\n\n\t/* Quick hash check */\n\tfor (i = 0; i < preimage_limit; i++)\n\t\tif ((img->line[current_lno + i].flag & LINE_PATCHED) ||\n\t\t    (preimage->line[i].hash != img->line[current_lno + i].hash))\n\t\t\treturn 0;\n\n\tif (preimage_limit == preimage->nr) {\n\t\t/*\n\t\t * Do we have an exact match?  If we were told to match\n\t\t * at the end, size must be exactly at current+fragsize,\n\t\t * otherwise current+fragsize must be still within the preimage,\n\t\t * and either case, the old piece should match the preimage\n\t\t * exactly.\n\t\t */\n\t\tif ((match_end\n\t\t     ? (current + preimage->len == img->len)\n\t\t     : (current + preimage->len <= img->len)) &&\n\t\t    !memcmp(img->buf + current, preimage->buf, preimage->len))\n\t\t\treturn 1;\n\t} else {\n\t\t/*\n\t\t * The preimage extends beyond the end of img, so\n\t\t * there cannot be an exact match.\n\t\t *\n\t\t * There must be one non-blank context line that match\n\t\t * a line before the end of img.\n\t\t */\n\t\tchar *buf_end;\n\n\t\tbuf = preimage->buf;\n\t\tbuf_end = buf;\n\t\tfor (i = 0; i < preimage_limit; i++)\n\t\t\tbuf_end += preimage->line[i].len;\n\n\t\tfor ( ; buf < buf_end; buf++)\n\t\t\tif (!isspace(*buf))\n\t\t\t\tbreak;\n\t\tif (buf == buf_end)\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * No exact match. If we are ignoring whitespace, run a line-by-line\n\t * fuzzy matching. We collect all the line length information because\n\t * we need it to adjust whitespace if we match.\n\t */\n\tif (state->ws_ignore_action == ignore_ws_change)\n\t\treturn line_by_line_fuzzy_match(img, preimage, postimage,\n\t\t\t\t\t\tcurrent, current_lno, preimage_limit);\n\n\tif (state->ws_error_action != correct_ws_error)\n\t\treturn 0;\n\n\t/*\n\t * The hunk does not apply byte-by-byte, but the hash says\n\t * it might with whitespace fuzz. We weren't asked to\n\t * ignore whitespace, we were asked to correct whitespace\n\t * errors, so let's try matching after whitespace correction.\n\t *\n\t * While checking the preimage against the target, whitespace\n\t * errors in both fixed, we count how large the corresponding\n\t * postimage needs to be.  The postimage prepared by\n\t * apply_one_fragment() has whitespace errors fixed on added\n\t * lines already, but the common lines were propagated as-is,\n\t * which may become longer when their whitespace errors are\n\t * fixed.\n\t */\n\n\t/* First count added lines in postimage */\n\tpostlen = 0;\n\tfor (i = 0; i < postimage->nr; i++) {\n\t\tif (!(postimage->line[i].flag & LINE_COMMON))\n\t\t\tpostlen += postimage->line[i].len;\n\t}\n\n\t/*\n\t * The preimage may extend beyond the end of the file,\n\t * but in this loop we will only handle the part of the\n\t * preimage that falls within the file.\n\t */\n\tstrbuf_init(&fixed, preimage->len + 1);\n\torig = preimage->buf;\n\ttarget = img->buf + current;\n\tfor (i = 0; i < preimage_limit; i++) {\n\t\tsize_t oldlen = preimage->line[i].len;\n\t\tsize_t tgtlen = img->line[current_lno + i].len;\n\t\tsize_t fixstart = fixed.len;\n\t\tstruct strbuf tgtfix;\n\t\tint match;\n\n\t\t/* Try fixing the line in the preimage */\n\t\tws_fix_copy(&fixed, orig, oldlen, ws_rule, NULL);\n\n\t\t/* Try fixing the line in the target */\n\t\tstrbuf_init(&tgtfix, tgtlen);\n\t\tws_fix_copy(&tgtfix, target, tgtlen, ws_rule, NULL);\n\n\t\t/*\n\t\t * If they match, either the preimage was based on\n\t\t * a version before our tree fixed whitespace breakage,\n\t\t * or we are lacking a whitespace-fix patch the tree\n\t\t * the preimage was based on already had (i.e. target\n\t\t * has whitespace breakage, the preimage doesn't).\n\t\t * In either case, we are fixing the whitespace breakages\n\t\t * so we might as well take the fix together with their\n\t\t * real change.\n\t\t */\n\t\tmatch = (tgtfix.len == fixed.len - fixstart &&\n\t\t\t !memcmp(tgtfix.buf, fixed.buf + fixstart,\n\t\t\t\t\t     fixed.len - fixstart));\n\n\t\t/* Add the length if this is common with the postimage */\n\t\tif (preimage->line[i].flag & LINE_COMMON)\n\t\t\tpostlen += tgtfix.len;\n\n\t\tstrbuf_release(&tgtfix);\n\t\tif (!match)\n\t\t\tgoto unmatch_exit;\n\n\t\torig += oldlen;\n\t\ttarget += tgtlen;\n\t}\n\n\n\t/*\n\t * Now handle the lines in the preimage that falls beyond the\n\t * end of the file (if any). They will only match if they are\n\t * empty or only contain whitespace (if WS_BLANK_AT_EOL is\n\t * false).\n\t */\n\tfor ( ; i < preimage->nr; i++) {\n\t\tsize_t fixstart = fixed.len; /* start of the fixed preimage */\n\t\tsize_t oldlen = preimage->line[i].len;\n\t\tint j;\n\n\t\t/* Try fixing the line in the preimage */\n\t\tws_fix_copy(&fixed, orig, oldlen, ws_rule, NULL);\n\n\t\tfor (j = fixstart; j < fixed.len; j++)\n\t\t\tif (!isspace(fixed.buf[j]))\n\t\t\t\tgoto unmatch_exit;\n\n\t\torig += oldlen;\n\t}\n\n\t/*\n\t * Yes, the preimage is based on an older version that still\n\t * has whitespace breakages unfixed, and fixing them makes the\n\t * hunk match.  Update the context lines in the postimage.\n\t */\n\tfixed_buf = strbuf_detach(&fixed, &fixed_len);\n\tif (postlen < postimage->len)\n\t\tpostlen = 0;\n\tupdate_pre_post_images(preimage, postimage,\n\t\t\t       fixed_buf, fixed_len, postlen);\n\treturn 1;\n\n unmatch_exit:\n\tstrbuf_release(&fixed);\n\treturn 0;\n}\n\nstatic int find_pos(struct apply_state *state,\n\t\t    struct image *img,\n\t\t    struct image *preimage,\n\t\t    struct image *postimage,\n\t\t    int line,\n\t\t    unsigned ws_rule,\n\t\t    int match_beginning, int match_end)\n{\n\tint i;\n\tunsigned long backwards, forwards, current;\n\tint backwards_lno, forwards_lno, current_lno;\n\n\t/*\n\t * When running with --allow-overlap, it is possible that a hunk is\n\t * seen that pretends to start at the beginning (but no longer does),\n\t * and that *still* needs to match the end. So trust `match_end` more\n\t * than `match_beginning`.\n\t */\n\tif (state->allow_overlap && match_beginning && match_end &&\n\t    img->nr - preimage->nr != 0)\n\t\tmatch_beginning = 0;\n\n\t/*\n\t * If match_beginning or match_end is specified, there is no\n\t * point starting from a wrong line that will never match and\n\t * wander around and wait for a match at the specified end.\n\t */\n\tif (match_beginning)\n\t\tline = 0;\n\telse if (match_end)\n\t\tline = img->nr - preimage->nr;\n\n\t/*\n\t * Because the comparison is unsigned, the following test\n\t * will also take care of a negative line number that can\n\t * result when match_end and preimage is larger than the target.\n\t */\n\tif ((size_t) line > img->nr)\n\t\tline = img->nr;\n\n\tcurrent = 0;\n\tfor (i = 0; i < line; i++)\n\t\tcurrent += img->line[i].len;\n\n\t/*\n\t * There's probably some smart way to do this, but I'll leave\n\t * that to the smart and beautiful people. I'm simple and stupid.\n\t */\n\tbackwards = current;\n\tbackwards_lno = line;\n\tforwards = current;\n\tforwards_lno = line;\n\tcurrent_lno = line;\n\n\tfor (i = 0; ; i++) {\n\t\tif (match_fragment(state, img, preimage, postimage,\n\t\t\t\t   current, current_lno, ws_rule,\n\t\t\t\t   match_beginning, match_end))\n\t\t\treturn current_lno;\n\n\tagain:\n\t\tif (backwards_lno == 0 && forwards_lno == img->nr)\n\t\t\tbreak;\n\n\t\tif (i & 1) {\n\t\t\tif (backwards_lno == 0) {\n\t\t\t\ti++;\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tbackwards_lno--;\n\t\t\tbackwards -= img->line[backwards_lno].len;\n\t\t\tcurrent = backwards;\n\t\t\tcurrent_lno = backwards_lno;\n\t\t} else {\n\t\t\tif (forwards_lno == img->nr) {\n\t\t\t\ti++;\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tforwards += img->line[forwards_lno].len;\n\t\t\tforwards_lno++;\n\t\t\tcurrent = forwards;\n\t\t\tcurrent_lno = forwards_lno;\n\t\t}\n\n\t}\n\treturn -1;\n}\n\nstatic void remove_first_line(struct image *img)\n{\n\timg->buf += img->line[0].len;\n\timg->len -= img->line[0].len;\n\timg->line++;\n\timg->nr--;\n}\n\nstatic void remove_last_line(struct image *img)\n{\n\timg->len -= img->line[--img->nr].len;\n}\n\n/*\n * The change from \"preimage\" and \"postimage\" has been found to\n * apply at applied_pos (counts in line numbers) in \"img\".\n * Update \"img\" to remove \"preimage\" and replace it with \"postimage\".\n */\nstatic void update_image(struct apply_state *state,\n\t\t\t struct image *img,\n\t\t\t int applied_pos,\n\t\t\t struct image *preimage,\n\t\t\t struct image *postimage)\n{\n\t/*\n\t * remove the copy of preimage at offset in img\n\t * and replace it with postimage\n\t */\n\tint i, nr;\n\tsize_t remove_count, insert_count, applied_at = 0;\n\tchar *result;\n\tint preimage_limit;\n\n\t/*\n\t * If we are removing blank lines at the end of img,\n\t * the preimage may extend beyond the end.\n\t * If that is the case, we must be careful only to\n\t * remove the part of the preimage that falls within\n\t * the boundaries of img. Initialize preimage_limit\n\t * to the number of lines in the preimage that falls\n\t * within the boundaries.\n\t */\n\tpreimage_limit = preimage->nr;\n\tif (preimage_limit > img->nr - applied_pos)\n\t\tpreimage_limit = img->nr - applied_pos;\n\n\tfor (i = 0; i < applied_pos; i++)\n\t\tapplied_at += img->line[i].len;\n\n\tremove_count = 0;\n\tfor (i = 0; i < preimage_limit; i++)\n\t\tremove_count += img->line[applied_pos + i].len;\n\tinsert_count = postimage->len;\n\n\t/* Adjust the contents */\n\tresult = xmalloc(st_add3(st_sub(img->len, remove_count), insert_count, 1));\n\tmemcpy(result, img->buf, applied_at);\n\tmemcpy(result + applied_at, postimage->buf, postimage->len);\n\tmemcpy(result + applied_at + postimage->len,\n\t       img->buf + (applied_at + remove_count),\n\t       img->len - (applied_at + remove_count));\n\tfree(img->buf);\n\timg->buf = result;\n\timg->len += insert_count - remove_count;\n\tresult[img->len] = '\\0';\n\n\t/* Adjust the line table */\n\tnr = img->nr + postimage->nr - preimage_limit;\n\tif (preimage_limit < postimage->nr) {\n\t\t/*\n\t\t * NOTE: this knows that we never call remove_first_line()\n\t\t * on anything other than pre/post image.\n\t\t */\n\t\tREALLOC_ARRAY(img->line, nr);\n\t\timg->line_allocated = img->line;\n\t}\n\tif (preimage_limit != postimage->nr)\n\t\tMOVE_ARRAY(img->line + applied_pos + postimage->nr,\n\t\t\t   img->line + applied_pos + preimage_limit,\n\t\t\t   img->nr - (applied_pos + preimage_limit));\n\tCOPY_ARRAY(img->line + applied_pos, postimage->line, postimage->nr);\n\tif (!state->allow_overlap)\n\t\tfor (i = 0; i < postimage->nr; i++)\n\t\t\timg->line[applied_pos + i].flag |= LINE_PATCHED;\n\timg->nr = nr;\n}\n\n/*\n * Use the patch-hunk text in \"frag\" to prepare two images (preimage and\n * postimage) for the hunk.  Find lines that match \"preimage\" in \"img\" and\n * replace the part of \"img\" with \"postimage\" text.\n */\nstatic int apply_one_fragment(struct apply_state *state,\n\t\t\t      struct image *img, struct fragment *frag,\n\t\t\t      int inaccurate_eof, unsigned ws_rule,\n\t\t\t      int nth_fragment)\n{\n\tint match_beginning, match_end;\n\tconst char *patch = frag->patch;\n\tint size = frag->size;\n\tchar *old, *oldlines;\n\tstruct strbuf newlines;\n\tint new_blank_lines_at_end = 0;\n\tint found_new_blank_lines_at_end = 0;\n\tint hunk_linenr = frag->linenr;\n\tunsigned long leading, trailing;\n\tint pos, applied_pos;\n\tstruct image preimage;\n\tstruct image postimage;\n\n\tmemset(&preimage, 0, sizeof(preimage));\n\tmemset(&postimage, 0, sizeof(postimage));\n\toldlines = xmalloc(size);\n\tstrbuf_init(&newlines, size);\n\n\told = oldlines;\n\twhile (size > 0) {\n\t\tchar first;\n\t\tint len = linelen(patch, size);\n\t\tint plen;\n\t\tint added_blank_line = 0;\n\t\tint is_blank_context = 0;\n\t\tsize_t start;\n\n\t\tif (!len)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * \"plen\" is how much of the line we should use for\n\t\t * the actual patch data. Normally we just remove the\n\t\t * first character on the line, but if the line is\n\t\t * followed by \"\\ No newline\", then we also remove the\n\t\t * last one (which is the newline, of course).\n\t\t */\n\t\tplen = len - 1;\n\t\tif (len < size && patch[len] == '\\\\')\n\t\t\tplen--;\n\t\tfirst = *patch;\n\t\tif (state->apply_in_reverse) {\n\t\t\tif (first == '-')\n\t\t\t\tfirst = '+';\n\t\t\telse if (first == '+')\n\t\t\t\tfirst = '-';\n\t\t}\n\n\t\tswitch (first) {\n\t\tcase '\\n':\n\t\t\t/* Newer GNU diff, empty context line */\n\t\t\tif (plen < 0)\n\t\t\t\t/* ... followed by '\\No newline'; nothing */\n\t\t\t\tbreak;\n\t\t\t*old++ = '\\n';\n\t\t\tstrbuf_addch(&newlines, '\\n');\n\t\t\tadd_line_info(&preimage, \"\\n\", 1, LINE_COMMON);\n\t\t\tadd_line_info(&postimage, \"\\n\", 1, LINE_COMMON);\n\t\t\tis_blank_context = 1;\n\t\t\tbreak;\n\t\tcase ' ':\n\t\t\tif (plen && (ws_rule & WS_BLANK_AT_EOF) &&\n\t\t\t    ws_blank_line(patch + 1, plen, ws_rule))\n\t\t\t\tis_blank_context = 1;\n\t\t\t/* fallthrough */\n\t\tcase '-':\n\t\t\tmemcpy(old, patch + 1, plen);\n\t\t\tadd_line_info(&preimage, old, plen,\n\t\t\t\t      (first == ' ' ? LINE_COMMON : 0));\n\t\t\told += plen;\n\t\t\tif (first == '-')\n\t\t\t\tbreak;\n\t\t\t/* fallthrough */\n\t\tcase '+':\n\t\t\t/* --no-add does not add new lines */\n\t\t\tif (first == '+' && state->no_add)\n\t\t\t\tbreak;\n\n\t\t\tstart = newlines.len;\n\t\t\tif (first != '+' ||\n\t\t\t    !state->whitespace_error ||\n\t\t\t    state->ws_error_action != correct_ws_error) {\n\t\t\t\tstrbuf_add(&newlines, patch + 1, plen);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tws_fix_copy(&newlines, patch + 1, plen, ws_rule, &state->applied_after_fixing_ws);\n\t\t\t}\n\t\t\tadd_line_info(&postimage, newlines.buf + start, newlines.len - start,\n\t\t\t\t      (first == '+' ? 0 : LINE_COMMON));\n\t\t\tif (first == '+' &&\n\t\t\t    (ws_rule & WS_BLANK_AT_EOF) &&\n\t\t\t    ws_blank_line(patch + 1, plen, ws_rule))\n\t\t\t\tadded_blank_line = 1;\n\t\t\tbreak;\n\t\tcase '@': case '\\\\':\n\t\t\t/* Ignore it, we already handled it */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (state->apply_verbosity > verbosity_normal)\n\t\t\t\terror(_(\"invalid start of line: '%c'\"), first);\n\t\t\tapplied_pos = -1;\n\t\t\tgoto out;\n\t\t}\n\t\tif (added_blank_line) {\n\t\t\tif (!new_blank_lines_at_end)\n\t\t\t\tfound_new_blank_lines_at_end = hunk_linenr;\n\t\t\tnew_blank_lines_at_end++;\n\t\t}\n\t\telse if (is_blank_context)\n\t\t\t;\n\t\telse\n\t\t\tnew_blank_lines_at_end = 0;\n\t\tpatch += len;\n\t\tsize -= len;\n\t\thunk_linenr++;\n\t}\n\tif (inaccurate_eof &&\n\t    old > oldlines && old[-1] == '\\n' &&\n\t    newlines.len > 0 && newlines.buf[newlines.len - 1] == '\\n') {\n\t\told--;\n\t\tstrbuf_setlen(&newlines, newlines.len - 1);\n\t\tpreimage.line_allocated[preimage.nr - 1].len--;\n\t\tpostimage.line_allocated[postimage.nr - 1].len--;\n\t}\n\n\tleading = frag->leading;\n\ttrailing = frag->trailing;\n\n\t/*\n\t * A hunk to change lines at the beginning would begin with\n\t * @@ -1,L +N,M @@\n\t * but we need to be careful.  -U0 that inserts before the second\n\t * line also has this pattern.\n\t *\n\t * And a hunk to add to an empty file would begin with\n\t * @@ -0,0 +N,M @@\n\t *\n\t * In other words, a hunk that is (frag->oldpos <= 1) with or\n\t * without leading context must match at the beginning.\n\t */\n\tmatch_beginning = (!frag->oldpos ||\n\t\t\t   (frag->oldpos == 1 && !state->unidiff_zero));\n\n\t/*\n\t * A hunk without trailing lines must match at the end.\n\t * However, we simply cannot tell if a hunk must match end\n\t * from the lack of trailing lines if the patch was generated\n\t * with unidiff without any context.\n\t */\n\tmatch_end = !state->unidiff_zero && !trailing;\n\n\tpos = frag->newpos ? (frag->newpos - 1) : 0;\n\tpreimage.buf = oldlines;\n\tpreimage.len = old - oldlines;\n\tpostimage.buf = newlines.buf;\n\tpostimage.len = newlines.len;\n\tpreimage.line = preimage.line_allocated;\n\tpostimage.line = postimage.line_allocated;\n\n\tfor (;;) {\n\n\t\tapplied_pos = find_pos(state, img, &preimage, &postimage, pos,\n\t\t\t\t       ws_rule, match_beginning, match_end);\n\n\t\tif (applied_pos >= 0)\n\t\t\tbreak;\n\n\t\t/* Am I at my context limits? */\n\t\tif ((leading <= state->p_context) && (trailing <= state->p_context))\n\t\t\tbreak;\n\t\tif (match_beginning || match_end) {\n\t\t\tmatch_beginning = match_end = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Reduce the number of context lines; reduce both\n\t\t * leading and trailing if they are equal otherwise\n\t\t * just reduce the larger context.\n\t\t */\n\t\tif (leading >= trailing) {\n\t\t\tremove_first_line(&preimage);\n\t\t\tremove_first_line(&postimage);\n\t\t\tpos--;\n\t\t\tleading--;\n\t\t}\n\t\tif (trailing > leading) {\n\t\t\tremove_last_line(&preimage);\n\t\t\tremove_last_line(&postimage);\n\t\t\ttrailing--;\n\t\t}\n\t}\n\n\tif (applied_pos >= 0) {\n\t\tif (new_blank_lines_at_end &&\n\t\t    preimage.nr + applied_pos >= img->nr &&\n\t\t    (ws_rule & WS_BLANK_AT_EOF) &&\n\t\t    state->ws_error_action != nowarn_ws_error) {\n\t\t\trecord_ws_error(state, WS_BLANK_AT_EOF, \"+\", 1,\n\t\t\t\t\tfound_new_blank_lines_at_end);\n\t\t\tif (state->ws_error_action == correct_ws_error) {\n\t\t\t\twhile (new_blank_lines_at_end--)\n\t\t\t\t\tremove_last_line(&postimage);\n\t\t\t}\n\t\t\t/*\n\t\t\t * We would want to prevent write_out_results()\n\t\t\t * from taking place in apply_patch() that follows\n\t\t\t * the callchain led us here, which is:\n\t\t\t * apply_patch->check_patch_list->check_patch->\n\t\t\t * apply_data->apply_fragments->apply_one_fragment\n\t\t\t */\n\t\t\tif (state->ws_error_action == die_on_ws_error)\n\t\t\t\tstate->apply = 0;\n\t\t}\n\n\t\tif (state->apply_verbosity > verbosity_normal && applied_pos != pos) {\n\t\t\tint offset = applied_pos - pos;\n\t\t\tif (state->apply_in_reverse)\n\t\t\t\toffset = 0 - offset;\n\t\t\tfprintf_ln(stderr,\n\t\t\t\t   Q_(\"Hunk #%d succeeded at %d (offset %d line).\",\n\t\t\t\t      \"Hunk #%d succeeded at %d (offset %d lines).\",\n\t\t\t\t      offset),\n\t\t\t\t   nth_fragment, applied_pos + 1, offset);\n\t\t}\n\n\t\t/*\n\t\t * Warn if it was necessary to reduce the number\n\t\t * of context lines.\n\t\t */\n\t\tif ((leading != frag->leading ||\n\t\t     trailing != frag->trailing) && state->apply_verbosity > verbosity_silent)\n\t\t\tfprintf_ln(stderr, _(\"Context reduced to (%ld/%ld)\"\n\t\t\t\t\t     \" to apply fragment at %d\"),\n\t\t\t\t   leading, trailing, applied_pos+1);\n\t\tupdate_image(state, img, applied_pos, &preimage, &postimage);\n\t} else {\n\t\tif (state->apply_verbosity > verbosity_normal)\n\t\t\terror(_(\"while searching for:\\n%.*s\"),\n\t\t\t      (int)(old - oldlines), oldlines);\n\t}\n\nout:\n\tfree(oldlines);\n\tstrbuf_release(&newlines);\n\tfree(preimage.line_allocated);\n\tfree(postimage.line_allocated);\n\n\treturn (applied_pos < 0);\n}\n\nstatic int apply_binary_fragment(struct apply_state *state,\n\t\t\t\t struct image *img,\n\t\t\t\t struct patch *patch)\n{\n\tstruct fragment *fragment = patch->fragments;\n\tunsigned long len;\n\tvoid *dst;\n\n\tif (!fragment)\n\t\treturn error(_(\"missing binary patch data for '%s'\"),\n\t\t\t     patch->new_name ?\n\t\t\t     patch->new_name :\n\t\t\t     patch->old_name);\n\n\t/* Binary patch is irreversible without the optional second hunk */\n\tif (state->apply_in_reverse) {\n\t\tif (!fragment->next)\n\t\t\treturn error(_(\"cannot reverse-apply a binary patch \"\n\t\t\t\t       \"without the reverse hunk to '%s'\"),\n\t\t\t\t     patch->new_name\n\t\t\t\t     ? patch->new_name : patch->old_name);\n\t\tfragment = fragment->next;\n\t}\n\tswitch (fragment->binary_patch_method) {\n\tcase BINARY_DELTA_DEFLATED:\n\t\tdst = patch_delta(img->buf, img->len, fragment->patch,\n\t\t\t\t  fragment->size, &len);\n\t\tif (!dst)\n\t\t\treturn -1;\n\t\tclear_image(img);\n\t\timg->buf = dst;\n\t\timg->len = len;\n\t\treturn 0;\n\tcase BINARY_LITERAL_DEFLATED:\n\t\tclear_image(img);\n\t\timg->len = fragment->size;\n\t\timg->buf = xmemdupz(fragment->patch, img->len);\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\n/*\n * Replace \"img\" with the result of applying the binary patch.\n * The binary patch data itself in patch->fragment is still kept\n * but the preimage prepared by the caller in \"img\" is freed here\n * or in the helper function apply_binary_fragment() this calls.\n */\nstatic int apply_binary(struct apply_state *state,\n\t\t\tstruct image *img,\n\t\t\tstruct patch *patch)\n{\n\tconst char *name = patch->old_name ? patch->old_name : patch->new_name;\n\tstruct object_id oid;\n\tconst unsigned hexsz = the_hash_algo->hexsz;\n\n\t/*\n\t * For safety, we require patch index line to contain\n\t * full hex textual object ID for old and new, at least for now.\n\t */\n\tif (strlen(patch->old_oid_prefix) != hexsz ||\n\t    strlen(patch->new_oid_prefix) != hexsz ||\n\t    get_oid_hex(patch->old_oid_prefix, &oid) ||\n\t    get_oid_hex(patch->new_oid_prefix, &oid))\n\t\treturn error(_(\"cannot apply binary patch to '%s' \"\n\t\t\t       \"without full index line\"), name);\n\n\tif (patch->old_name) {\n\t\t/*\n\t\t * See if the old one matches what the patch\n\t\t * applies to.\n\t\t */\n\t\thash_object_file(the_hash_algo, img->buf, img->len, blob_type,\n\t\t\t\t &oid);\n\t\tif (strcmp(oid_to_hex(&oid), patch->old_oid_prefix))\n\t\t\treturn error(_(\"the patch applies to '%s' (%s), \"\n\t\t\t\t       \"which does not match the \"\n\t\t\t\t       \"current contents.\"),\n\t\t\t\t     name, oid_to_hex(&oid));\n\t}\n\telse {\n\t\t/* Otherwise, the old one must be empty. */\n\t\tif (img->len)\n\t\t\treturn error(_(\"the patch applies to an empty \"\n\t\t\t\t       \"'%s' but it is not empty\"), name);\n\t}\n\n\tget_oid_hex(patch->new_oid_prefix, &oid);\n\tif (is_null_oid(&oid)) {\n\t\tclear_image(img);\n\t\treturn 0; /* deletion patch */\n\t}\n\n\tif (has_object(the_repository, &oid, 0)) {\n\t\t/* We already have the postimage */\n\t\tenum object_type type;\n\t\tunsigned long size;\n\t\tchar *result;\n\n\t\tresult = read_object_file(&oid, &type, &size);\n\t\tif (!result)\n\t\t\treturn error(_(\"the necessary postimage %s for \"\n\t\t\t\t       \"'%s' cannot be read\"),\n\t\t\t\t     patch->new_oid_prefix, name);\n\t\tclear_image(img);\n\t\timg->buf = result;\n\t\timg->len = size;\n\t} else {\n\t\t/*\n\t\t * We have verified buf matches the preimage;\n\t\t * apply the patch data to it, which is stored\n\t\t * in the patch->fragments->{patch,size}.\n\t\t */\n\t\tif (apply_binary_fragment(state, img, patch))\n\t\t\treturn error(_(\"binary patch does not apply to '%s'\"),\n\t\t\t\t     name);\n\n\t\t/* verify that the result matches */\n\t\thash_object_file(the_hash_algo, img->buf, img->len, blob_type,\n\t\t\t\t &oid);\n\t\tif (strcmp(oid_to_hex(&oid), patch->new_oid_prefix))\n\t\t\treturn error(_(\"binary patch to '%s' creates incorrect result (expecting %s, got %s)\"),\n\t\t\t\tname, patch->new_oid_prefix, oid_to_hex(&oid));\n\t}\n\n\treturn 0;\n}\n\nstatic int apply_fragments(struct apply_state *state, struct image *img, struct patch *patch)\n{\n\tstruct fragment *frag = patch->fragments;\n\tconst char *name = patch->old_name ? patch->old_name : patch->new_name;\n\tunsigned ws_rule = patch->ws_rule;\n\tunsigned inaccurate_eof = patch->inaccurate_eof;\n\tint nth = 0;\n\n\tif (patch->is_binary)\n\t\treturn apply_binary(state, img, patch);\n\n\twhile (frag) {\n\t\tnth++;\n\t\tif (apply_one_fragment(state, img, frag, inaccurate_eof, ws_rule, nth)) {\n\t\t\terror(_(\"patch failed: %s:%ld\"), name, frag->oldpos);\n\t\t\tif (!state->apply_with_reject)\n\t\t\t\treturn -1;\n\t\t\tfrag->rejected = 1;\n\t\t}\n\t\tfrag = frag->next;\n\t}\n\treturn 0;\n}\n\nstatic int read_blob_object(struct strbuf *buf, const struct object_id *oid, unsigned mode)\n{\n\tif (S_ISGITLINK(mode)) {\n\t\tstrbuf_grow(buf, 100);\n\t\tstrbuf_addf(buf, \"Subproject commit %s\\n\", oid_to_hex(oid));\n\t} else {\n\t\tenum object_type type;\n\t\tunsigned long sz;\n\t\tchar *result;\n\n\t\tresult = read_object_file(oid, &type, &sz);\n\t\tif (!result)\n\t\t\treturn -1;\n\t\t/* XXX read_sha1_file NUL-terminates */\n\t\tstrbuf_attach(buf, result, sz, sz + 1);\n\t}\n\treturn 0;\n}\n\nstatic int read_file_or_gitlink(const struct cache_entry *ce, struct strbuf *buf)\n{\n\tif (!ce)\n\t\treturn 0;\n\treturn read_blob_object(buf, &ce->oid, ce->ce_mode);\n}\n\nstatic struct patch *in_fn_table(struct apply_state *state, const char *name)\n{\n\tstruct string_list_item *item;\n\n\tif (name == NULL)\n\t\treturn NULL;\n\n\titem = string_list_lookup(&state->fn_table, name);\n\tif (item != NULL)\n\t\treturn (struct patch *)item->util;\n\n\treturn NULL;\n}\n\n/*\n * item->util in the filename table records the status of the path.\n * Usually it points at a patch (whose result records the contents\n * of it after applying it), but it could be PATH_WAS_DELETED for a\n * path that a previously applied patch has already removed, or\n * PATH_TO_BE_DELETED for a path that a later patch would remove.\n *\n * The latter is needed to deal with a case where two paths A and B\n * are swapped by first renaming A to B and then renaming B to A;\n * moving A to B should not be prevented due to presence of B as we\n * will remove it in a later patch.\n */\n#define PATH_TO_BE_DELETED ((struct patch *) -2)\n#define PATH_WAS_DELETED ((struct patch *) -1)\n\nstatic int to_be_deleted(struct patch *patch)\n{\n\treturn patch == PATH_TO_BE_DELETED;\n}\n\nstatic int was_deleted(struct patch *patch)\n{\n\treturn patch == PATH_WAS_DELETED;\n}\n\nstatic void add_to_fn_table(struct apply_state *state, struct patch *patch)\n{\n\tstruct string_list_item *item;\n\n\t/*\n\t * Always add new_name unless patch is a deletion\n\t * This should cover the cases for normal diffs,\n\t * file creations and copies\n\t */\n\tif (patch->new_name != NULL) {\n\t\titem = string_list_insert(&state->fn_table, patch->new_name);\n\t\titem->util = patch;\n\t}\n\n\t/*\n\t * store a failure on rename/deletion cases because\n\t * later chunks shouldn't patch old names\n\t */\n\tif ((patch->new_name == NULL) || (patch->is_rename)) {\n\t\titem = string_list_insert(&state->fn_table, patch->old_name);\n\t\titem->util = PATH_WAS_DELETED;\n\t}\n}\n\nstatic void prepare_fn_table(struct apply_state *state, struct patch *patch)\n{\n\t/*\n\t * store information about incoming file deletion\n\t */\n\twhile (patch) {\n\t\tif ((patch->new_name == NULL) || (patch->is_rename)) {\n\t\t\tstruct string_list_item *item;\n\t\t\titem = string_list_insert(&state->fn_table, patch->old_name);\n\t\t\titem->util = PATH_TO_BE_DELETED;\n\t\t}\n\t\tpatch = patch->next;\n\t}\n}\n\nstatic int checkout_target(struct index_state *istate,\n\t\t\t   struct cache_entry *ce, struct stat *st)\n{\n\tstruct checkout costate = CHECKOUT_INIT;\n\n\tcostate.refresh_cache = 1;\n\tcostate.istate = istate;\n\tif (checkout_entry(ce, &costate, NULL, NULL) ||\n\t    lstat(ce->name, st))\n\t\treturn error(_(\"cannot checkout %s\"), ce->name);\n\treturn 0;\n}\n\nstatic struct patch *previous_patch(struct apply_state *state,\n\t\t\t\t    struct patch *patch,\n\t\t\t\t    int *gone)\n{\n\tstruct patch *previous;\n\n\t*gone = 0;\n\tif (patch->is_copy || patch->is_rename)\n\t\treturn NULL; /* \"git\" patches do not depend on the order */\n\n\tprevious = in_fn_table(state, patch->old_name);\n\tif (!previous)\n\t\treturn NULL;\n\n\tif (to_be_deleted(previous))\n\t\treturn NULL; /* the deletion hasn't happened yet */\n\n\tif (was_deleted(previous))\n\t\t*gone = 1;\n\n\treturn previous;\n}\n\nstatic int verify_index_match(struct apply_state *state,\n\t\t\t      const struct cache_entry *ce,\n\t\t\t      struct stat *st)\n{\n\tif (S_ISGITLINK(ce->ce_mode)) {\n\t\tif (!S_ISDIR(st->st_mode))\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\treturn ie_match_stat(state->repo->index, ce, st,\n\t\t\t     CE_MATCH_IGNORE_VALID | CE_MATCH_IGNORE_SKIP_WORKTREE);\n}\n\n#define SUBMODULE_PATCH_WITHOUT_INDEX 1\n\nstatic int load_patch_target(struct apply_state *state,\n\t\t\t     struct strbuf *buf,\n\t\t\t     const struct cache_entry *ce,\n\t\t\t     struct stat *st,\n\t\t\t     struct patch *patch,\n\t\t\t     const char *name,\n\t\t\t     unsigned expected_mode)\n{\n\tif (state->cached || state->check_index) {\n\t\tif (read_file_or_gitlink(ce, buf))\n\t\t\treturn error(_(\"failed to read %s\"), name);\n\t} else if (name) {\n\t\tif (S_ISGITLINK(expected_mode)) {\n\t\t\tif (ce)\n\t\t\t\treturn read_file_or_gitlink(ce, buf);\n\t\t\telse\n\t\t\t\treturn SUBMODULE_PATCH_WITHOUT_INDEX;\n\t\t} else if (has_symlink_leading_path(name, strlen(name))) {\n\t\t\treturn error(_(\"reading from '%s' beyond a symbolic link\"), name);\n\t\t} else {\n\t\t\tif (read_old_data(st, patch, name, buf))\n\t\t\t\treturn error(_(\"failed to read %s\"), name);\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*\n * We are about to apply \"patch\"; populate the \"image\" with the\n * current version we have, from the working tree or from the index,\n * depending on the situation e.g. --cached/--index.  If we are\n * applying a non-git patch that incrementally updates the tree,\n * we read from the result of a previous diff.\n */\nstatic int load_preimage(struct apply_state *state,\n\t\t\t struct image *image,\n\t\t\t struct patch *patch, struct stat *st,\n\t\t\t const struct cache_entry *ce)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tsize_t len;\n\tchar *img;\n\tstruct patch *previous;\n\tint status;\n\n\tprevious = previous_patch(state, patch, &status);\n\tif (status)\n\t\treturn error(_(\"path %s has been renamed/deleted\"),\n\t\t\t     patch->old_name);\n\tif (previous) {\n\t\t/* We have a patched copy in memory; use that. */\n\t\tstrbuf_add(&buf, previous->result, previous->resultsize);\n\t} else {\n\t\tstatus = load_patch_target(state, &buf, ce, st, patch,\n\t\t\t\t\t   patch->old_name, patch->old_mode);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t\telse if (status == SUBMODULE_PATCH_WITHOUT_INDEX) {\n\t\t\t/*\n\t\t\t * There is no way to apply subproject\n\t\t\t * patch without looking at the index.\n\t\t\t * NEEDSWORK: shouldn't this be flagged\n\t\t\t * as an error???\n\t\t\t */\n\t\t\tfree_fragment_list(patch->fragments);\n\t\t\tpatch->fragments = NULL;\n\t\t} else if (status) {\n\t\t\treturn error(_(\"failed to read %s\"), patch->old_name);\n\t\t}\n\t}\n\n\timg = strbuf_detach(&buf, &len);\n\tprepare_image(image, img, len, !patch->is_binary);\n\treturn 0;\n}\n\nstatic int three_way_merge(struct apply_state *state,\n\t\t\t   struct image *image,\n\t\t\t   char *path,\n\t\t\t   const struct object_id *base,\n\t\t\t   const struct object_id *ours,\n\t\t\t   const struct object_id *theirs)\n{\n\tmmfile_t base_file, our_file, their_file;\n\tmmbuffer_t result = { NULL };\n\tint status;\n\n\tread_mmblob(&base_file, base);\n\tread_mmblob(&our_file, ours);\n\tread_mmblob(&their_file, theirs);\n\tstatus = ll_merge(&result, path,\n\t\t\t  &base_file, \"base\",\n\t\t\t  &our_file, \"ours\",\n\t\t\t  &their_file, \"theirs\",\n\t\t\t  state->repo->index,\n\t\t\t  NULL);\n\tfree(base_file.ptr);\n\tfree(our_file.ptr);\n\tfree(their_file.ptr);\n\tif (status < 0 || !result.ptr) {\n\t\tfree(result.ptr);\n\t\treturn -1;\n\t}\n\tclear_image(image);\n\timage->buf = result.ptr;\n\timage->len = result.size;\n\n\treturn status;\n}\n\n/*\n * When directly falling back to add/add three-way merge, we read from\n * the current contents of the new_name.  In no cases other than that\n * this function will be called.\n */\nstatic int load_current(struct apply_state *state,\n\t\t\tstruct image *image,\n\t\t\tstruct patch *patch)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tint status, pos;\n\tsize_t len;\n\tchar *img;\n\tstruct stat st;\n\tstruct cache_entry *ce;\n\tchar *name = patch->new_name;\n\tunsigned mode = patch->new_mode;\n\n\tif (!patch->is_new)\n\t\tBUG(\"patch to %s is not a creation\", patch->old_name);\n\n\tpos = index_name_pos(state->repo->index, name, strlen(name));\n\tif (pos < 0)\n\t\treturn error(_(\"%s: does not exist in index\"), name);\n\tce = state->repo->index->cache[pos];\n\tif (lstat(name, &st)) {\n\t\tif (errno != ENOENT)\n\t\t\treturn error_errno(\"%s\", name);\n\t\tif (checkout_target(state->repo->index, ce, &st))\n\t\t\treturn -1;\n\t}\n\tif (verify_index_match(state, ce, &st))\n\t\treturn error(_(\"%s: does not match index\"), name);\n\n\tstatus = load_patch_target(state, &buf, ce, &st, patch, name, mode);\n\tif (status < 0)\n\t\treturn status;\n\telse if (status)\n\t\treturn -1;\n\timg = strbuf_detach(&buf, &len);\n\tprepare_image(image, img, len, !patch->is_binary);\n\treturn 0;\n}\n\nstatic int try_threeway(struct apply_state *state,\n\t\t\tstruct image *image,\n\t\t\tstruct patch *patch,\n\t\t\tstruct stat *st,\n\t\t\tconst struct cache_entry *ce)\n{\n\tstruct object_id pre_oid, post_oid, our_oid;\n\tstruct strbuf buf = STRBUF_INIT;\n\tsize_t len;\n\tint status;\n\tchar *img;\n\tstruct image tmp_image;\n\n\t/* No point falling back to 3-way merge in these cases */\n\tif (patch->is_delete ||\n\t    S_ISGITLINK(patch->old_mode) || S_ISGITLINK(patch->new_mode))\n\t\treturn -1;\n\n\t/* Preimage the patch was prepared for */\n\tif (patch->is_new)\n\t\twrite_object_file(\"\", 0, blob_type, &pre_oid);\n\telse if (get_oid(patch->old_oid_prefix, &pre_oid) ||\n\t\t read_blob_object(&buf, &pre_oid, patch->old_mode))\n\t\treturn error(_(\"repository lacks the necessary blob to fall back on 3-way merge.\"));\n\n\tif (state->apply_verbosity > verbosity_silent)\n\t\tfprintf(stderr, _(\"Falling back to three-way merge...\\n\"));\n\n\timg = strbuf_detach(&buf, &len);\n\tprepare_image(&tmp_image, img, len, 1);\n\t/* Apply the patch to get the post image */\n\tif (apply_fragments(state, &tmp_image, patch) < 0) {\n\t\tclear_image(&tmp_image);\n\t\treturn -1;\n\t}\n\t/* post_oid is theirs */\n\twrite_object_file(tmp_image.buf, tmp_image.len, blob_type, &post_oid);\n\tclear_image(&tmp_image);\n\n\t/* our_oid is ours */\n\tif (patch->is_new) {\n\t\tif (load_current(state, &tmp_image, patch))\n\t\t\treturn error(_(\"cannot read the current contents of '%s'\"),\n\t\t\t\t     patch->new_name);\n\t} else {\n\t\tif (load_preimage(state, &tmp_image, patch, st, ce))\n\t\t\treturn error(_(\"cannot read the current contents of '%s'\"),\n\t\t\t\t     patch->old_name);\n\t}\n\twrite_object_file(tmp_image.buf, tmp_image.len, blob_type, &our_oid);\n\tclear_image(&tmp_image);\n\n\t/* in-core three-way merge between post and our using pre as base */\n\tstatus = three_way_merge(state, image, patch->new_name,\n\t\t\t\t &pre_oid, &our_oid, &post_oid);\n\tif (status < 0) {\n\t\tif (state->apply_verbosity > verbosity_silent)\n\t\t\tfprintf(stderr,\n\t\t\t\t_(\"Failed to fall back on three-way merge...\\n\"));\n\t\treturn status;\n\t}\n\n\tif (status) {\n\t\tpatch->conflicted_threeway = 1;\n\t\tif (patch->is_new)\n\t\t\toidclr(&patch->threeway_stage[0]);\n\t\telse\n\t\t\toidcpy(&patch->threeway_stage[0], &pre_oid);\n\t\toidcpy(&patch->threeway_stage[1], &our_oid);\n\t\toidcpy(&patch->threeway_stage[2], &post_oid);\n\t\tif (state->apply_verbosity > verbosity_silent)\n\t\t\tfprintf(stderr,\n\t\t\t\t_(\"Applied patch to '%s' with conflicts.\\n\"),\n\t\t\t\tpatch->new_name);\n\t} else {\n\t\tif (state->apply_verbosity > verbosity_silent)\n\t\t\tfprintf(stderr,\n\t\t\t\t_(\"Applied patch to '%s' cleanly.\\n\"),\n\t\t\t\tpatch->new_name);\n\t}\n\treturn 0;\n}\n\nstatic int apply_data(struct apply_state *state, struct patch *patch,\n\t\t      struct stat *st, const struct cache_entry *ce)\n{\n\tstruct image image;\n\n\tif (load_preimage(state, &image, patch, st, ce) < 0)\n\t\treturn -1;\n\n\tif (patch->direct_to_threeway ||\n\t    apply_fragments(state, &image, patch) < 0) {\n\t\t/* Note: with --reject, apply_fragments() returns 0 */\n\t\tif (!state->threeway || try_threeway(state, &image, patch, st, ce) < 0)\n\t\t\treturn -1;\n\t}\n\tpatch->result = image.buf;\n\tpatch->resultsize = image.len;\n\tadd_to_fn_table(state, patch);\n\tfree(image.line_allocated);\n\n\tif (0 < patch->is_delete && patch->resultsize)\n\t\treturn error(_(\"removal patch leaves file contents\"));\n\n\treturn 0;\n}\n\n/*\n * If \"patch\" that we are looking at modifies or deletes what we have,\n * we would want it not to lose any local modification we have, either\n * in the working tree or in the index.\n *\n * This also decides if a non-git patch is a creation patch or a\n * modification to an existing empty file.  We do not check the state\n * of the current tree for a creation patch in this function; the caller\n * check_patch() separately makes sure (and errors out otherwise) that\n * the path the patch creates does not exist in the current tree.\n */\nstatic int check_preimage(struct apply_state *state,\n\t\t\t  struct patch *patch,\n\t\t\t  struct cache_entry **ce,\n\t\t\t  struct stat *st)\n{\n\tconst char *old_name = patch->old_name;\n\tstruct patch *previous = NULL;\n\tint stat_ret = 0, status;\n\tunsigned st_mode = 0;\n\n\tif (!old_name)\n\t\treturn 0;\n\n\tassert(patch->is_new <= 0);\n\tprevious = previous_patch(state, patch, &status);\n\n\tif (status)\n\t\treturn error(_(\"path %s has been renamed/deleted\"), old_name);\n\tif (previous) {\n\t\tst_mode = previous->new_mode;\n\t} else if (!state->cached) {\n\t\tstat_ret = lstat(old_name, st);\n\t\tif (stat_ret && errno != ENOENT)\n\t\t\treturn error_errno(\"%s\", old_name);\n\t}\n\n\tif (state->check_index && !previous) {\n\t\tint pos = index_name_pos(state->repo->index, old_name,\n\t\t\t\t\t strlen(old_name));\n\t\tif (pos < 0) {\n\t\t\tif (patch->is_new < 0)\n\t\t\t\tgoto is_new;\n\t\t\treturn error(_(\"%s: does not exist in index\"), old_name);\n\t\t}\n\t\t*ce = state->repo->index->cache[pos];\n\t\tif (stat_ret < 0) {\n\t\t\tif (checkout_target(state->repo->index, *ce, st))\n\t\t\t\treturn -1;\n\t\t}\n\t\tif (!state->cached && verify_index_match(state, *ce, st))\n\t\t\treturn error(_(\"%s: does not match index\"), old_name);\n\t\tif (state->cached)\n\t\t\tst_mode = (*ce)->ce_mode;\n\t} else if (stat_ret < 0) {\n\t\tif (patch->is_new < 0)\n\t\t\tgoto is_new;\n\t\treturn error_errno(\"%s\", old_name);\n\t}\n\n\tif (!state->cached && !previous)\n\t\tst_mode = ce_mode_from_stat(*ce, st->st_mode);\n\n\tif (patch->is_new < 0)\n\t\tpatch->is_new = 0;\n\tif (!patch->old_mode)\n\t\tpatch->old_mode = st_mode;\n\tif ((st_mode ^ patch->old_mode) & S_IFMT)\n\t\treturn error(_(\"%s: wrong type\"), old_name);\n\tif (st_mode != patch->old_mode)\n\t\twarning(_(\"%s has type %o, expected %o\"),\n\t\t\told_name, st_mode, patch->old_mode);\n\tif (!patch->new_mode && !patch->is_delete)\n\t\tpatch->new_mode = st_mode;\n\treturn 0;\n\n is_new:\n\tpatch->is_new = 1;\n\tpatch->is_delete = 0;\n\tFREE_AND_NULL(patch->old_name);\n\treturn 0;\n}\n\n\n#define EXISTS_IN_INDEX 1\n#define EXISTS_IN_WORKTREE 2\n#define EXISTS_IN_INDEX_AS_ITA 3\n\nstatic int check_to_create(struct apply_state *state,\n\t\t\t   const char *new_name,\n\t\t\t   int ok_if_exists)\n{\n\tstruct stat nst;\n\n\tif (state->check_index && (!ok_if_exists || !state->cached)) {\n\t\tint pos;\n\n\t\tpos = index_name_pos(state->repo->index, new_name, strlen(new_name));\n\t\tif (pos >= 0) {\n\t\t\tstruct cache_entry *ce = state->repo->index->cache[pos];\n\n\t\t\t/* allow ITA, as they do not yet exist in the index */\n\t\t\tif (!ok_if_exists && !(ce->ce_flags & CE_INTENT_TO_ADD))\n\t\t\t\treturn EXISTS_IN_INDEX;\n\n\t\t\t/* ITA entries can never match working tree files */\n\t\t\tif (!state->cached && (ce->ce_flags & CE_INTENT_TO_ADD))\n\t\t\t\treturn EXISTS_IN_INDEX_AS_ITA;\n\t\t}\n\t}\n\n\tif (state->cached)\n\t\treturn 0;\n\n\tif (!lstat(new_name, &nst)) {\n\t\tif (S_ISDIR(nst.st_mode) || ok_if_exists)\n\t\t\treturn 0;\n\t\t/*\n\t\t * A leading component of new_name might be a symlink\n\t\t * that is going to be removed with this patch, but\n\t\t * still pointing at somewhere that has the path.\n\t\t * In such a case, path \"new_name\" does not exist as\n\t\t * far as git is concerned.\n\t\t */\n\t\tif (has_symlink_leading_path(new_name, strlen(new_name)))\n\t\t\treturn 0;\n\n\t\treturn EXISTS_IN_WORKTREE;\n\t} else if (!is_missing_file_error(errno)) {\n\t\treturn error_errno(\"%s\", new_name);\n\t}\n\treturn 0;\n}\n\nstatic uintptr_t register_symlink_changes(struct apply_state *state,\n\t\t\t\t\t  const char *path,\n\t\t\t\t\t  uintptr_t what)\n{\n\tstruct string_list_item *ent;\n\n\tent = string_list_lookup(&state->symlink_changes, path);\n\tif (!ent) {\n\t\tent = string_list_insert(&state->symlink_changes, path);\n\t\tent->util = (void *)0;\n\t}\n\tent->util = (void *)(what | ((uintptr_t)ent->util));\n\treturn (uintptr_t)ent->util;\n}\n\nstatic uintptr_t check_symlink_changes(struct apply_state *state, const char *path)\n{\n\tstruct string_list_item *ent;\n\n\tent = string_list_lookup(&state->symlink_changes, path);\n\tif (!ent)\n\t\treturn 0;\n\treturn (uintptr_t)ent->util;\n}\n\nstatic void prepare_symlink_changes(struct apply_state *state, struct patch *patch)\n{\n\tfor ( ; patch; patch = patch->next) {\n\t\tif ((patch->old_name && S_ISLNK(patch->old_mode)) &&\n\t\t    (patch->is_rename || patch->is_delete))\n\t\t\t/* the symlink at patch->old_name is removed */\n\t\t\tregister_symlink_changes(state, patch->old_name, APPLY_SYMLINK_GOES_AWAY);\n\n\t\tif (patch->new_name && S_ISLNK(patch->new_mode))\n\t\t\t/* the symlink at patch->new_name is created or remains */\n\t\t\tregister_symlink_changes(state, patch->new_name, APPLY_SYMLINK_IN_RESULT);\n\t}\n}\n\nstatic int path_is_beyond_symlink_1(struct apply_state *state, struct strbuf *name)\n{\n\tdo {\n\t\tunsigned int change;\n\n\t\twhile (--name->len && name->buf[name->len] != '/')\n\t\t\t; /* scan backwards */\n\t\tif (!name->len)\n\t\t\tbreak;\n\t\tname->buf[name->len] = '\\0';\n\t\tchange = check_symlink_changes(state, name->buf);\n\t\tif (change & APPLY_SYMLINK_IN_RESULT)\n\t\t\treturn 1;\n\t\tif (change & APPLY_SYMLINK_GOES_AWAY)\n\t\t\t/*\n\t\t\t * This cannot be \"return 0\", because we may\n\t\t\t * see a new one created at a higher level.\n\t\t\t */\n\t\t\tcontinue;\n\n\t\t/* otherwise, check the preimage */\n\t\tif (state->check_index) {\n\t\t\tstruct cache_entry *ce;\n\n\t\t\tce = index_file_exists(state->repo->index, name->buf,\n\t\t\t\t\t       name->len, ignore_case);\n\t\t\tif (ce && S_ISLNK(ce->ce_mode))\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\tstruct stat st;\n\t\t\tif (!lstat(name->buf, &st) && S_ISLNK(st.st_mode))\n\t\t\t\treturn 1;\n\t\t}\n\t} while (1);\n\treturn 0;\n}\n\nstatic int path_is_beyond_symlink(struct apply_state *state, const char *name_)\n{\n\tint ret;\n\tstruct strbuf name = STRBUF_INIT;\n\n\tassert(*name_ != '\\0');\n\tstrbuf_addstr(&name, name_);\n\tret = path_is_beyond_symlink_1(state, &name);\n\tstrbuf_release(&name);\n\n\treturn ret;\n}\n\nstatic int check_unsafe_path(struct patch *patch)\n{\n\tconst char *old_name = NULL;\n\tconst char *new_name = NULL;\n\tif (patch->is_delete)\n\t\told_name = patch->old_name;\n\telse if (!patch->is_new && !patch->is_copy)\n\t\told_name = patch->old_name;\n\tif (!patch->is_delete)\n\t\tnew_name = patch->new_name;\n\n\tif (old_name && !verify_path(old_name, patch->old_mode))\n\t\treturn error(_(\"invalid path '%s'\"), old_name);\n\tif (new_name && !verify_path(new_name, patch->new_mode))\n\t\treturn error(_(\"invalid path '%s'\"), new_name);\n\treturn 0;\n}\n\n/*\n * Check and apply the patch in-core; leave the result in patch->result\n * for the caller to write it out to the final destination.\n */\nstatic int check_patch(struct apply_state *state, struct patch *patch)\n{\n\tstruct stat st;\n\tconst char *old_name = patch->old_name;\n\tconst char *new_name = patch->new_name;\n\tconst char *name = old_name ? old_name : new_name;\n\tstruct cache_entry *ce = NULL;\n\tstruct patch *tpatch;\n\tint ok_if_exists;\n\tint status;\n\n\tpatch->rejected = 1; /* we will drop this after we succeed */\n\n\tstatus = check_preimage(state, patch, &ce, &st);\n\tif (status)\n\t\treturn status;\n\told_name = patch->old_name;\n\n\t/*\n\t * A type-change diff is always split into a patch to delete\n\t * old, immediately followed by a patch to create new (see\n\t * diff.c::run_diff()); in such a case it is Ok that the entry\n\t * to be deleted by the previous patch is still in the working\n\t * tree and in the index.\n\t *\n\t * A patch to swap-rename between A and B would first rename A\n\t * to B and then rename B to A.  While applying the first one,\n\t * the presence of B should not stop A from getting renamed to\n\t * B; ask to_be_deleted() about the later rename.  Removal of\n\t * B and rename from A to B is handled the same way by asking\n\t * was_deleted().\n\t */\n\tif ((tpatch = in_fn_table(state, new_name)) &&\n\t    (was_deleted(tpatch) || to_be_deleted(tpatch)))\n\t\tok_if_exists = 1;\n\telse\n\t\tok_if_exists = 0;\n\n\tif (new_name &&\n\t    ((0 < patch->is_new) || patch->is_rename || patch->is_copy)) {\n\t\tint err = check_to_create(state, new_name, ok_if_exists);\n\n\t\tif (err && state->threeway) {\n\t\t\tpatch->direct_to_threeway = 1;\n\t\t} else switch (err) {\n\t\tcase 0:\n\t\t\tbreak; /* happy */\n\t\tcase EXISTS_IN_INDEX:\n\t\t\treturn error(_(\"%s: already exists in index\"), new_name);\n\t\tcase EXISTS_IN_INDEX_AS_ITA:\n\t\t\treturn error(_(\"%s: does not match index\"), new_name);\n\t\tcase EXISTS_IN_WORKTREE:\n\t\t\treturn error(_(\"%s: already exists in working directory\"),\n\t\t\t\t     new_name);\n\t\tdefault:\n\t\t\treturn err;\n\t\t}\n\n\t\tif (!patch->new_mode) {\n\t\t\tif (0 < patch->is_new)\n\t\t\t\tpatch->new_mode = S_IFREG | 0644;\n\t\t\telse\n\t\t\t\tpatch->new_mode = patch->old_mode;\n\t\t}\n\t}\n\n\tif (new_name && old_name) {\n\t\tint same = !strcmp(old_name, new_name);\n\t\tif (!patch->new_mode)\n\t\t\tpatch->new_mode = patch->old_mode;\n\t\tif ((patch->old_mode ^ patch->new_mode) & S_IFMT) {\n\t\t\tif (same)\n\t\t\t\treturn error(_(\"new mode (%o) of %s does not \"\n\t\t\t\t\t       \"match old mode (%o)\"),\n\t\t\t\t\tpatch->new_mode, new_name,\n\t\t\t\t\tpatch->old_mode);\n\t\t\telse\n\t\t\t\treturn error(_(\"new mode (%o) of %s does not \"\n\t\t\t\t\t       \"match old mode (%o) of %s\"),\n\t\t\t\t\tpatch->new_mode, new_name,\n\t\t\t\t\tpatch->old_mode, old_name);\n\t\t}\n\t}\n\n\tif (!state->unsafe_paths && check_unsafe_path(patch))\n\t\treturn -128;\n\n\t/*\n\t * An attempt to read from or delete a path that is beyond a\n\t * symbolic link will be prevented by load_patch_target() that\n\t * is called at the beginning of apply_data() so we do not\n\t * have to worry about a patch marked with \"is_delete\" bit\n\t * here.  We however need to make sure that the patch result\n\t * is not deposited to a path that is beyond a symbolic link\n\t * here.\n\t */\n\tif (!patch->is_delete && path_is_beyond_symlink(state, patch->new_name))\n\t\treturn error(_(\"affected file '%s' is beyond a symbolic link\"),\n\t\t\t     patch->new_name);\n\n\tif (apply_data(state, patch, &st, ce) < 0)\n\t\treturn error(_(\"%s: patch does not apply\"), name);\n\tpatch->rejected = 0;\n\treturn 0;\n}\n\nstatic int check_patch_list(struct apply_state *state, struct patch *patch)\n{\n\tint err = 0;\n\n\tprepare_symlink_changes(state, patch);\n\tprepare_fn_table(state, patch);\n\twhile (patch) {\n\t\tint res;\n\t\tif (state->apply_verbosity > verbosity_normal)\n\t\t\tsay_patch_name(stderr,\n\t\t\t\t       _(\"Checking patch %s...\"), patch);\n\t\tres = check_patch(state, patch);\n\t\tif (res == -128)\n\t\t\treturn -128;\n\t\terr |= res;\n\t\tpatch = patch->next;\n\t}\n\treturn err;\n}\n\nstatic int read_apply_cache(struct apply_state *state)\n{\n\tif (state->index_file)\n\t\treturn read_index_from(state->repo->index, state->index_file,\n\t\t\t\t       get_git_dir());\n\telse\n\t\treturn repo_read_index(state->repo);\n}\n\n/* This function tries to read the object name from the current index */\nstatic int get_current_oid(struct apply_state *state, const char *path,\n\t\t\t   struct object_id *oid)\n{\n\tint pos;\n\n\tif (read_apply_cache(state) < 0)\n\t\treturn -1;\n\tpos = index_name_pos(state->repo->index, path, strlen(path));\n\tif (pos < 0)\n\t\treturn -1;\n\toidcpy(oid, &state->repo->index->cache[pos]->oid);\n\treturn 0;\n}\n\nstatic int preimage_oid_in_gitlink_patch(struct patch *p, struct object_id *oid)\n{\n\t/*\n\t * A usable gitlink patch has only one fragment (hunk) that looks like:\n\t * @@ -1 +1 @@\n\t * -Subproject commit <old sha1>\n\t * +Subproject commit <new sha1>\n\t * or\n\t * @@ -1 +0,0 @@\n\t * -Subproject commit <old sha1>\n\t * for a removal patch.\n\t */\n\tstruct fragment *hunk = p->fragments;\n\tstatic const char heading[] = \"-Subproject commit \";\n\tchar *preimage;\n\n\tif (/* does the patch have only one hunk? */\n\t    hunk && !hunk->next &&\n\t    /* is its preimage one line? */\n\t    hunk->oldpos == 1 && hunk->oldlines == 1 &&\n\t    /* does preimage begin with the heading? */\n\t    (preimage = memchr(hunk->patch, '\\n', hunk->size)) != NULL &&\n\t    starts_with(++preimage, heading) &&\n\t    /* does it record full SHA-1? */\n\t    !get_oid_hex(preimage + sizeof(heading) - 1, oid) &&\n\t    preimage[sizeof(heading) + the_hash_algo->hexsz - 1] == '\\n' &&\n\t    /* does the abbreviated name on the index line agree with it? */\n\t    starts_with(preimage + sizeof(heading) - 1, p->old_oid_prefix))\n\t\treturn 0; /* it all looks fine */\n\n\t/* we may have full object name on the index line */\n\treturn get_oid_hex(p->old_oid_prefix, oid);\n}\n\n/* Build an index that contains just the files needed for a 3way merge */\nstatic int build_fake_ancestor(struct apply_state *state, struct patch *list)\n{\n\tstruct patch *patch;\n\tstruct index_state result = { NULL };\n\tstruct lock_file lock = LOCK_INIT;\n\tint res;\n\n\t/* Once we start supporting the reverse patch, it may be\n\t * worth showing the new sha1 prefix, but until then...\n\t */\n\tfor (patch = list; patch; patch = patch->next) {\n\t\tstruct object_id oid;\n\t\tstruct cache_entry *ce;\n\t\tconst char *name;\n\n\t\tname = patch->old_name ? patch->old_name : patch->new_name;\n\t\tif (0 < patch->is_new)\n\t\t\tcontinue;\n\n\t\tif (S_ISGITLINK(patch->old_mode)) {\n\t\t\tif (!preimage_oid_in_gitlink_patch(patch, &oid))\n\t\t\t\t; /* ok, the textual part looks sane */\n\t\t\telse\n\t\t\t\treturn error(_(\"sha1 information is lacking or \"\n\t\t\t\t\t       \"useless for submodule %s\"), name);\n\t\t} else if (!get_oid_blob(patch->old_oid_prefix, &oid)) {\n\t\t\t; /* ok */\n\t\t} else if (!patch->lines_added && !patch->lines_deleted) {\n\t\t\t/* mode-only change: update the current */\n\t\t\tif (get_current_oid(state, patch->old_name, &oid))\n\t\t\t\treturn error(_(\"mode change for %s, which is not \"\n\t\t\t\t\t       \"in current HEAD\"), name);\n\t\t} else\n\t\t\treturn error(_(\"sha1 information is lacking or useless \"\n\t\t\t\t       \"(%s).\"), name);\n\n\t\tce = make_cache_entry(&result, patch->old_mode, &oid, name, 0, 0);\n\t\tif (!ce)\n\t\t\treturn error(_(\"make_cache_entry failed for path '%s'\"),\n\t\t\t\t     name);\n\t\tif (add_index_entry(&result, ce, ADD_CACHE_OK_TO_ADD)) {\n\t\t\tdiscard_cache_entry(ce);\n\t\t\treturn error(_(\"could not add %s to temporary index\"),\n\t\t\t\t     name);\n\t\t}\n\t}\n\n\thold_lock_file_for_update(&lock, state->fake_ancestor, LOCK_DIE_ON_ERROR);\n\tres = write_locked_index(&result, &lock, COMMIT_LOCK);\n\tdiscard_index(&result);\n\n\tif (res)\n\t\treturn error(_(\"could not write temporary index to %s\"),\n\t\t\t     state->fake_ancestor);\n\n\treturn 0;\n}\n\nstatic void stat_patch_list(struct apply_state *state, struct patch *patch)\n{\n\tint files, adds, dels;\n\n\tfor (files = adds = dels = 0 ; patch ; patch = patch->next) {\n\t\tfiles++;\n\t\tadds += patch->lines_added;\n\t\tdels += patch->lines_deleted;\n\t\tshow_stats(state, patch);\n\t}\n\n\tprint_stat_summary(stdout, files, adds, dels);\n}\n\nstatic void numstat_patch_list(struct apply_state *state,\n\t\t\t       struct patch *patch)\n{\n\tfor ( ; patch; patch = patch->next) {\n\t\tconst char *name;\n\t\tname = patch->new_name ? patch->new_name : patch->old_name;\n\t\tif (patch->is_binary)\n\t\t\tprintf(\"-\\t-\\t\");\n\t\telse\n\t\t\tprintf(\"%d\\t%d\\t\", patch->lines_added, patch->lines_deleted);\n\t\twrite_name_quoted(name, stdout, state->line_termination);\n\t}\n}\n\nstatic void show_file_mode_name(const char *newdelete, unsigned int mode, const char *name)\n{\n\tif (mode)\n\t\tprintf(\" %s mode %06o %s\\n\", newdelete, mode, name);\n\telse\n\t\tprintf(\" %s %s\\n\", newdelete, name);\n}\n\nstatic void show_mode_change(struct patch *p, int show_name)\n{\n\tif (p->old_mode && p->new_mode && p->old_mode != p->new_mode) {\n\t\tif (show_name)\n\t\t\tprintf(\" mode change %06o => %06o %s\\n\",\n\t\t\t       p->old_mode, p->new_mode, p->new_name);\n\t\telse\n\t\t\tprintf(\" mode change %06o => %06o\\n\",\n\t\t\t       p->old_mode, p->new_mode);\n\t}\n}\n\nstatic void show_rename_copy(struct patch *p)\n{\n\tconst char *renamecopy = p->is_rename ? \"rename\" : \"copy\";\n\tconst char *old_name, *new_name;\n\n\t/* Find common prefix */\n\told_name = p->old_name;\n\tnew_name = p->new_name;\n\twhile (1) {\n\t\tconst char *slash_old, *slash_new;\n\t\tslash_old = strchr(old_name, '/');\n\t\tslash_new = strchr(new_name, '/');\n\t\tif (!slash_old ||\n\t\t    !slash_new ||\n\t\t    slash_old - old_name != slash_new - new_name ||\n\t\t    memcmp(old_name, new_name, slash_new - new_name))\n\t\t\tbreak;\n\t\told_name = slash_old + 1;\n\t\tnew_name = slash_new + 1;\n\t}\n\t/* p->old_name through old_name is the common prefix, and old_name and\n\t * new_name through the end of names are renames\n\t */\n\tif (old_name != p->old_name)\n\t\tprintf(\" %s %.*s{%s => %s} (%d%%)\\n\", renamecopy,\n\t\t       (int)(old_name - p->old_name), p->old_name,\n\t\t       old_name, new_name, p->score);\n\telse\n\t\tprintf(\" %s %s => %s (%d%%)\\n\", renamecopy,\n\t\t       p->old_name, p->new_name, p->score);\n\tshow_mode_change(p, 0);\n}\n\nstatic void summary_patch_list(struct patch *patch)\n{\n\tstruct patch *p;\n\n\tfor (p = patch; p; p = p->next) {\n\t\tif (p->is_new)\n\t\t\tshow_file_mode_name(\"create\", p->new_mode, p->new_name);\n\t\telse if (p->is_delete)\n\t\t\tshow_file_mode_name(\"delete\", p->old_mode, p->old_name);\n\t\telse {\n\t\t\tif (p->is_rename || p->is_copy)\n\t\t\t\tshow_rename_copy(p);\n\t\t\telse {\n\t\t\t\tif (p->score) {\n\t\t\t\t\tprintf(\" rewrite %s (%d%%)\\n\",\n\t\t\t\t\t       p->new_name, p->score);\n\t\t\t\t\tshow_mode_change(p, 0);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tshow_mode_change(p, 1);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void patch_stats(struct apply_state *state, struct patch *patch)\n{\n\tint lines = patch->lines_added + patch->lines_deleted;\n\n\tif (lines > state->max_change)\n\t\tstate->max_change = lines;\n\tif (patch->old_name) {\n\t\tint len = quote_c_style(patch->old_name, NULL, NULL, 0);\n\t\tif (!len)\n\t\t\tlen = strlen(patch->old_name);\n\t\tif (len > state->max_len)\n\t\t\tstate->max_len = len;\n\t}\n\tif (patch->new_name) {\n\t\tint len = quote_c_style(patch->new_name, NULL, NULL, 0);\n\t\tif (!len)\n\t\t\tlen = strlen(patch->new_name);\n\t\tif (len > state->max_len)\n\t\t\tstate->max_len = len;\n\t}\n}\n\nstatic int remove_file(struct apply_state *state, struct patch *patch, int rmdir_empty)\n{\n\tif (state->update_index && !state->ita_only) {\n\t\tif (remove_file_from_index(state->repo->index, patch->old_name) < 0)\n\t\t\treturn error(_(\"unable to remove %s from index\"), patch->old_name);\n\t}\n\tif (!state->cached) {\n\t\tif (!remove_or_warn(patch->old_mode, patch->old_name) && rmdir_empty) {\n\t\t\tremove_path(patch->old_name);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int add_index_file(struct apply_state *state,\n\t\t\t  const char *path,\n\t\t\t  unsigned mode,\n\t\t\t  void *buf,\n\t\t\t  unsigned long size)\n{\n\tstruct stat st;\n\tstruct cache_entry *ce;\n\tint namelen = strlen(path);\n\n\tce = make_empty_cache_entry(state->repo->index, namelen);\n\tmemcpy(ce->name, path, namelen);\n\tce->ce_mode = create_ce_mode(mode);\n\tce->ce_flags = create_ce_flags(0);\n\tce->ce_namelen = namelen;\n\tif (state->ita_only) {\n\t\tce->ce_flags |= CE_INTENT_TO_ADD;\n\t\tset_object_name_for_intent_to_add_entry(ce);\n\t} else if (S_ISGITLINK(mode)) {\n\t\tconst char *s;\n\n\t\tif (!skip_prefix(buf, \"Subproject commit \", &s) ||\n\t\t    get_oid_hex(s, &ce->oid)) {\n\t\t\tdiscard_cache_entry(ce);\n\t\t\treturn error(_(\"corrupt patch for submodule %s\"), path);\n\t\t}\n\t} else {\n\t\tif (!state->cached) {\n\t\t\tif (lstat(path, &st) < 0) {\n\t\t\t\tdiscard_cache_entry(ce);\n\t\t\t\treturn error_errno(_(\"unable to stat newly \"\n\t\t\t\t\t\t     \"created file '%s'\"),\n\t\t\t\t\t\t   path);\n\t\t\t}\n\t\t\tfill_stat_cache_info(state->repo->index, ce, &st);\n\t\t}\n\t\tif (write_object_file(buf, size, blob_type, &ce->oid) < 0) {\n\t\t\tdiscard_cache_entry(ce);\n\t\t\treturn error(_(\"unable to create backing store \"\n\t\t\t\t       \"for newly created file %s\"), path);\n\t\t}\n\t}\n\tif (add_index_entry(state->repo->index, ce, ADD_CACHE_OK_TO_ADD) < 0) {\n\t\tdiscard_cache_entry(ce);\n\t\treturn error(_(\"unable to add cache entry for %s\"), path);\n\t}\n\n\treturn 0;\n}\n\n/*\n * Returns:\n *  -1 if an unrecoverable error happened\n *   0 if everything went well\n *   1 if a recoverable error happened\n */\nstatic int try_create_file(struct apply_state *state, const char *path,\n\t\t\t   unsigned int mode, const char *buf,\n\t\t\t   unsigned long size)\n{\n\tint fd, res;\n\tstruct strbuf nbuf = STRBUF_INIT;\n\n\tif (S_ISGITLINK(mode)) {\n\t\tstruct stat st;\n\t\tif (!lstat(path, &st) && S_ISDIR(st.st_mode))\n\t\t\treturn 0;\n\t\treturn !!mkdir(path, 0777);\n\t}\n\n\tif (has_symlinks && S_ISLNK(mode))\n\t\t/* Although buf:size is counted string, it also is NUL\n\t\t * terminated.\n\t\t */\n\t\treturn !!symlink(buf, path);\n\n\tfd = open(path, O_CREAT | O_EXCL | O_WRONLY, (mode & 0100) ? 0777 : 0666);\n\tif (fd < 0)\n\t\treturn 1;\n\n\tif (convert_to_working_tree(state->repo->index, path, buf, size, &nbuf, NULL)) {\n\t\tsize = nbuf.len;\n\t\tbuf  = nbuf.buf;\n\t}\n\n\tres = write_in_full(fd, buf, size) < 0;\n\tif (res)\n\t\terror_errno(_(\"failed to write to '%s'\"), path);\n\tstrbuf_release(&nbuf);\n\n\tif (close(fd) < 0 && !res)\n\t\treturn error_errno(_(\"closing file '%s'\"), path);\n\n\treturn res ? -1 : 0;\n}\n\n/*\n * We optimistically assume that the directories exist,\n * which is true 99% of the time anyway. If they don't,\n * we create them and try again.\n *\n * Returns:\n *   -1 on error\n *   0 otherwise\n */\nstatic int create_one_file(struct apply_state *state,\n\t\t\t   char *path,\n\t\t\t   unsigned mode,\n\t\t\t   const char *buf,\n\t\t\t   unsigned long size)\n{\n\tint res;\n\n\tif (state->cached)\n\t\treturn 0;\n\n\t/*\n\t * We already try to detect whether files are beyond a symlink in our\n\t * up-front checks. But in the case where symlinks are created by any\n\t * of the intermediate hunks it can happen that our up-front checks\n\t * didn't yet see the symlink, but at the point of arriving here there\n\t * in fact is one. We thus repeat the check for symlinks here.\n\t *\n\t * Note that this does not make the up-front check obsolete as the\n\t * failure mode is different:\n\t *\n\t * - The up-front checks cause us to abort before we have written\n\t *   anything into the working directory. So when we exit this way the\n\t *   working directory remains clean.\n\t *\n\t * - The checks here happen in the middle of the action where we have\n\t *   already started to apply the patch. The end result will be a dirty\n\t *   working directory.\n\t *\n\t * Ideally, we should update the up-front checks to catch what would\n\t * happen when we apply the patch before we damage the working tree.\n\t * We have all the information necessary to do so.  But for now, as a\n\t * part of embargoed security work, having this check would serve as a\n\t * reasonable first step.\n\t */\n\tif (path_is_beyond_symlink(state, path))\n\t\treturn error(_(\"affected file '%s' is beyond a symbolic link\"), path);\n\n\tres = try_create_file(state, path, mode, buf, size);\n\tif (res < 0)\n\t\treturn -1;\n\tif (!res)\n\t\treturn 0;\n\n\tif (errno == ENOENT) {\n\t\tif (safe_create_leading_directories_no_share(path))\n\t\t\treturn 0;\n\t\tres = try_create_file(state, path, mode, buf, size);\n\t\tif (res < 0)\n\t\t\treturn -1;\n\t\tif (!res)\n\t\t\treturn 0;\n\t}\n\n\tif (errno == EEXIST || errno == EACCES) {\n\t\t/* We may be trying to create a file where a directory\n\t\t * used to be.\n\t\t */\n\t\tstruct stat st;\n\t\tif (!lstat(path, &st) && (!S_ISDIR(st.st_mode) || !rmdir(path)))\n\t\t\terrno = EEXIST;\n\t}\n\n\tif (errno == EEXIST) {\n\t\tunsigned int nr = getpid();\n\n\t\tfor (;;) {\n\t\t\tchar newpath[PATH_MAX];\n\t\t\tmksnpath(newpath, sizeof(newpath), \"%s~%u\", path, nr);\n\t\t\tres = try_create_file(state, newpath, mode, buf, size);\n\t\t\tif (res < 0)\n\t\t\t\treturn -1;\n\t\t\tif (!res) {\n\t\t\t\tif (!rename(newpath, path))\n\t\t\t\t\treturn 0;\n\t\t\t\tunlink_or_warn(newpath);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (errno != EEXIST)\n\t\t\t\tbreak;\n\t\t\t++nr;\n\t\t}\n\t}\n\treturn error_errno(_(\"unable to write file '%s' mode %o\"),\n\t\t\t   path, mode);\n}\n\nstatic int add_conflicted_stages_file(struct apply_state *state,\n\t\t\t\t       struct patch *patch)\n{\n\tint stage, namelen;\n\tunsigned mode;\n\tstruct cache_entry *ce;\n\n\tif (!state->update_index)\n\t\treturn 0;\n\tnamelen = strlen(patch->new_name);\n\tmode = patch->new_mode ? patch->new_mode : (S_IFREG | 0644);\n\n\tremove_file_from_index(state->repo->index, patch->new_name);\n\tfor (stage = 1; stage < 4; stage++) {\n\t\tif (is_null_oid(&patch->threeway_stage[stage - 1]))\n\t\t\tcontinue;\n\t\tce = make_empty_cache_entry(state->repo->index, namelen);\n\t\tmemcpy(ce->name, patch->new_name, namelen);\n\t\tce->ce_mode = create_ce_mode(mode);\n\t\tce->ce_flags = create_ce_flags(stage);\n\t\tce->ce_namelen = namelen;\n\t\toidcpy(&ce->oid, &patch->threeway_stage[stage - 1]);\n\t\tif (add_index_entry(state->repo->index, ce, ADD_CACHE_OK_TO_ADD) < 0) {\n\t\t\tdiscard_cache_entry(ce);\n\t\t\treturn error(_(\"unable to add cache entry for %s\"),\n\t\t\t\t     patch->new_name);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int create_file(struct apply_state *state, struct patch *patch)\n{\n\tchar *path = patch->new_name;\n\tunsigned mode = patch->new_mode;\n\tunsigned long size = patch->resultsize;\n\tchar *buf = patch->result;\n\n\tif (!mode)\n\t\tmode = S_IFREG | 0644;\n\tif (create_one_file(state, path, mode, buf, size))\n\t\treturn -1;\n\n\tif (patch->conflicted_threeway)\n\t\treturn add_conflicted_stages_file(state, patch);\n\telse if (state->update_index)\n\t\treturn add_index_file(state, path, mode, buf, size);\n\treturn 0;\n}\n\n/* phase zero is to remove, phase one is to create */\nstatic int write_out_one_result(struct apply_state *state,\n\t\t\t\tstruct patch *patch,\n\t\t\t\tint phase)\n{\n\tif (patch->is_delete > 0) {\n\t\tif (phase == 0)\n\t\t\treturn remove_file(state, patch, 1);\n\t\treturn 0;\n\t}\n\tif (patch->is_new > 0 || patch->is_copy) {\n\t\tif (phase == 1)\n\t\t\treturn create_file(state, patch);\n\t\treturn 0;\n\t}\n\t/*\n\t * Rename or modification boils down to the same\n\t * thing: remove the old, write the new\n\t */\n\tif (phase == 0)\n\t\treturn remove_file(state, patch, patch->is_rename);\n\tif (phase == 1)\n\t\treturn create_file(state, patch);\n\treturn 0;\n}\n\nstatic int write_out_one_reject(struct apply_state *state, struct patch *patch)\n{\n\tFILE *rej;\n\tchar namebuf[PATH_MAX];\n\tstruct fragment *frag;\n\tint cnt = 0;\n\tstruct strbuf sb = STRBUF_INIT;\n\n\tfor (cnt = 0, frag = patch->fragments; frag; frag = frag->next) {\n\t\tif (!frag->rejected)\n\t\t\tcontinue;\n\t\tcnt++;\n\t}\n\n\tif (!cnt) {\n\t\tif (state->apply_verbosity > verbosity_normal)\n\t\t\tsay_patch_name(stderr,\n\t\t\t\t       _(\"Applied patch %s cleanly.\"), patch);\n\t\treturn 0;\n\t}\n\n\t/* This should not happen, because a removal patch that leaves\n\t * contents are marked \"rejected\" at the patch level.\n\t */\n\tif (!patch->new_name)\n\t\tdie(_(\"internal error\"));\n\n\t/* Say this even without --verbose */\n\tstrbuf_addf(&sb, Q_(\"Applying patch %%s with %d reject...\",\n\t\t\t    \"Applying patch %%s with %d rejects...\",\n\t\t\t    cnt),\n\t\t    cnt);\n\tif (state->apply_verbosity > verbosity_silent)\n\t\tsay_patch_name(stderr, sb.buf, patch);\n\tstrbuf_release(&sb);\n\n\tcnt = strlen(patch->new_name);\n\tif (ARRAY_SIZE(namebuf) <= cnt + 5) {\n\t\tcnt = ARRAY_SIZE(namebuf) - 5;\n\t\twarning(_(\"truncating .rej filename to %.*s.rej\"),\n\t\t\tcnt - 1, patch->new_name);\n\t}\n\tmemcpy(namebuf, patch->new_name, cnt);\n\tmemcpy(namebuf + cnt, \".rej\", 5);\n\n\trej = fopen(namebuf, \"w\");\n\tif (!rej)\n\t\treturn error_errno(_(\"cannot open %s\"), namebuf);\n\n\t/* Normal git tools never deal with .rej, so do not pretend\n\t * this is a git patch by saying --git or giving extended\n\t * headers.  While at it, maybe please \"kompare\" that wants\n\t * the trailing TAB and some garbage at the end of line ;-).\n\t */\n\tfprintf(rej, \"diff a/%s b/%s\\t(rejected hunks)\\n\",\n\t\tpatch->new_name, patch->new_name);\n\tfor (cnt = 1, frag = patch->fragments;\n\t     frag;\n\t     cnt++, frag = frag->next) {\n\t\tif (!frag->rejected) {\n\t\t\tif (state->apply_verbosity > verbosity_silent)\n\t\t\t\tfprintf_ln(stderr, _(\"Hunk #%d applied cleanly.\"), cnt);\n\t\t\tcontinue;\n\t\t}\n\t\tif (state->apply_verbosity > verbosity_silent)\n\t\t\tfprintf_ln(stderr, _(\"Rejected hunk #%d.\"), cnt);\n\t\tfprintf(rej, \"%.*s\", frag->size, frag->patch);\n\t\tif (frag->patch[frag->size-1] != '\\n')\n\t\t\tfputc('\\n', rej);\n\t}\n\tfclose(rej);\n\treturn -1;\n}\n\n/*\n * Returns:\n *  -1 if an error happened\n *   0 if the patch applied cleanly\n *   1 if the patch did not apply cleanly\n */\nstatic int write_out_results(struct apply_state *state, struct patch *list)\n{\n\tint phase;\n\tint errs = 0;\n\tstruct patch *l;\n\tstruct string_list cpath = STRING_LIST_INIT_DUP;\n\n\tfor (phase = 0; phase < 2; phase++) {\n\t\tl = list;\n\t\twhile (l) {\n\t\t\tif (l->rejected)\n\t\t\t\terrs = 1;\n\t\t\telse {\n\t\t\t\tif (write_out_one_result(state, l, phase)) {\n\t\t\t\t\tstring_list_clear(&cpath, 0);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (phase == 1) {\n\t\t\t\t\tif (write_out_one_reject(state, l))\n\t\t\t\t\t\terrs = 1;\n\t\t\t\t\tif (l->conflicted_threeway) {\n\t\t\t\t\t\tstring_list_append(&cpath, l->new_name);\n\t\t\t\t\t\terrs = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tl = l->next;\n\t\t}\n\t}\n\n\tif (cpath.nr) {\n\t\tstruct string_list_item *item;\n\n\t\tstring_list_sort(&cpath);\n\t\tif (state->apply_verbosity > verbosity_silent) {\n\t\t\tfor_each_string_list_item(item, &cpath)\n\t\t\t\tfprintf(stderr, \"U %s\\n\", item->string);\n\t\t}\n\t\tstring_list_clear(&cpath, 0);\n\n\t\trepo_rerere(state->repo, 0);\n\t}\n\n\treturn errs;\n}\n\n/*\n * Try to apply a patch.\n *\n * Returns:\n *  -128 if a bad error happened (like patch unreadable)\n *  -1 if patch did not apply and user cannot deal with it\n *   0 if the patch applied\n *   1 if the patch did not apply but user might fix it\n */\nstatic int apply_patch(struct apply_state *state,\n\t\t       int fd,\n\t\t       const char *filename,\n\t\t       int options)\n{\n\tsize_t offset;\n\tstruct strbuf buf = STRBUF_INIT; /* owns the patch text */\n\tstruct patch *list = NULL, **listp = &list;\n\tint skipped_patch = 0;\n\tint res = 0;\n\tint flush_attributes = 0;\n\n\tstate->patch_input_file = filename;\n\tif (read_patch_file(&buf, fd) < 0)\n\t\treturn -128;\n\toffset = 0;\n\twhile (offset < buf.len) {\n\t\tstruct patch *patch;\n\t\tint nr;\n\n\t\tpatch = xcalloc(1, sizeof(*patch));\n\t\tpatch->inaccurate_eof = !!(options & APPLY_OPT_INACCURATE_EOF);\n\t\tpatch->recount =  !!(options & APPLY_OPT_RECOUNT);\n\t\tnr = parse_chunk(state, buf.buf + offset, buf.len - offset, patch);\n\t\tif (nr < 0) {\n\t\t\tfree_patch(patch);\n\t\t\tif (nr == -128) {\n\t\t\t\tres = -128;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (state->apply_in_reverse)\n\t\t\treverse_patches(patch);\n\t\tif (use_patch(state, patch)) {\n\t\t\tpatch_stats(state, patch);\n\t\t\tif (!list || !state->apply_in_reverse) {\n\t\t\t\t*listp = patch;\n\t\t\t\tlistp = &patch->next;\n\t\t\t} else {\n\t\t\t\tpatch->next = list;\n\t\t\t\tlist = patch;\n\t\t\t}\n\n\t\t\tif ((patch->new_name &&\n\t\t\t     ends_with_path_components(patch->new_name,\n\t\t\t\t\t\t       GITATTRIBUTES_FILE)) ||\n\t\t\t    (patch->old_name &&\n\t\t\t     ends_with_path_components(patch->old_name,\n\t\t\t\t\t\t       GITATTRIBUTES_FILE)))\n\t\t\t\tflush_attributes = 1;\n\t\t}\n\t\telse {\n\t\t\tif (state->apply_verbosity > verbosity_normal)\n\t\t\t\tsay_patch_name(stderr, _(\"Skipped patch '%s'.\"), patch);\n\t\t\tfree_patch(patch);\n\t\t\tskipped_patch++;\n\t\t}\n\t\toffset += nr;\n\t}\n\n\tif (!list && !skipped_patch) {\n\t\terror(_(\"unrecognized input\"));\n\t\tres = -128;\n\t\tgoto end;\n\t}\n\n\tif (state->whitespace_error && (state->ws_error_action == die_on_ws_error))\n\t\tstate->apply = 0;\n\n\tstate->update_index = (state->check_index || state->ita_only) && state->apply;\n\tif (state->update_index && !is_lock_file_locked(&state->lock_file)) {\n\t\tif (state->index_file)\n\t\t\thold_lock_file_for_update(&state->lock_file,\n\t\t\t\t\t\t  state->index_file,\n\t\t\t\t\t\t  LOCK_DIE_ON_ERROR);\n\t\telse\n\t\t\trepo_hold_locked_index(state->repo, &state->lock_file,\n\t\t\t\t\t       LOCK_DIE_ON_ERROR);\n\t}\n\n\tif (state->check_index && read_apply_cache(state) < 0) {\n\t\terror(_(\"unable to read index file\"));\n\t\tres = -128;\n\t\tgoto end;\n\t}\n\n\tif (state->check || state->apply) {\n\t\tint r = check_patch_list(state, list);\n\t\tif (r == -128) {\n\t\t\tres = -128;\n\t\t\tgoto end;\n\t\t}\n\t\tif (r < 0 && !state->apply_with_reject) {\n\t\t\tres = -1;\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\tif (state->apply) {\n\t\tint write_res = write_out_results(state, list);\n\t\tif (write_res < 0) {\n\t\t\tres = -128;\n\t\t\tgoto end;\n\t\t}\n\t\tif (write_res > 0) {\n\t\t\t/* with --3way, we still need to write the index out */\n\t\t\tres = state->apply_with_reject ? -1 : 1;\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\tif (state->fake_ancestor &&\n\t    build_fake_ancestor(state, list)) {\n\t\tres = -128;\n\t\tgoto end;\n\t}\n\n\tif (state->diffstat && state->apply_verbosity > verbosity_silent)\n\t\tstat_patch_list(state, list);\n\n\tif (state->numstat && state->apply_verbosity > verbosity_silent)\n\t\tnumstat_patch_list(state, list);\n\n\tif (state->summary && state->apply_verbosity > verbosity_silent)\n\t\tsummary_patch_list(list);\n\n\tif (flush_attributes)\n\t\treset_parsed_attributes();\nend:\n\tfree_patch_list(list);\n\tstrbuf_release(&buf);\n\tstring_list_clear(&state->fn_table, 0);\n\treturn res;\n}\n\nstatic int apply_option_parse_exclude(const struct option *opt,\n\t\t\t\t      const char *arg, int unset)\n{\n\tstruct apply_state *state = opt->value;\n\n\tBUG_ON_OPT_NEG(unset);\n\n\tadd_name_limit(state, arg, 1);\n\treturn 0;\n}\n\nstatic int apply_option_parse_include(const struct option *opt,\n\t\t\t\t      const char *arg, int unset)\n{\n\tstruct apply_state *state = opt->value;\n\n\tBUG_ON_OPT_NEG(unset);\n\n\tadd_name_limit(state, arg, 0);\n\tstate->has_include = 1;\n\treturn 0;\n}\n\nstatic int apply_option_parse_p(const struct option *opt,\n\t\t\t\tconst char *arg,\n\t\t\t\tint unset)\n{\n\tstruct apply_state *state = opt->value;\n\n\tBUG_ON_OPT_NEG(unset);\n\n\tstate->p_value = atoi(arg);\n\tstate->p_value_known = 1;\n\treturn 0;\n}\n\nstatic int apply_option_parse_space_change(const struct option *opt,\n\t\t\t\t\t   const char *arg, int unset)\n{\n\tstruct apply_state *state = opt->value;\n\n\tBUG_ON_OPT_ARG(arg);\n\n\tif (unset)\n\t\tstate->ws_ignore_action = ignore_ws_none;\n\telse\n\t\tstate->ws_ignore_action = ignore_ws_change;\n\treturn 0;\n}\n\nstatic int apply_option_parse_whitespace(const struct option *opt,\n\t\t\t\t\t const char *arg, int unset)\n{\n\tstruct apply_state *state = opt->value;\n\n\tBUG_ON_OPT_NEG(unset);\n\n\tstate->whitespace_option = arg;\n\tif (parse_whitespace_option(state, arg))\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int apply_option_parse_directory(const struct option *opt,\n\t\t\t\t\tconst char *arg, int unset)\n{\n\tstruct apply_state *state = opt->value;\n\n\tBUG_ON_OPT_NEG(unset);\n\n\tstrbuf_reset(&state->root);\n\tstrbuf_addstr(&state->root, arg);\n\tstrbuf_complete(&state->root, '/');\n\treturn 0;\n}\n\nint apply_all_patches(struct apply_state *state,\n\t\t      int argc,\n\t\t      const char **argv,\n\t\t      int options)\n{\n\tint i;\n\tint res;\n\tint errs = 0;\n\tint read_stdin = 1;\n\n\tfor (i = 0; i < argc; i++) {\n\t\tconst char *arg = argv[i];\n\t\tchar *to_free = NULL;\n\t\tint fd;\n\n\t\tif (!strcmp(arg, \"-\")) {\n\t\t\tres = apply_patch(state, 0, \"<stdin>\", options);\n\t\t\tif (res < 0)\n\t\t\t\tgoto end;\n\t\t\terrs |= res;\n\t\t\tread_stdin = 0;\n\t\t\tcontinue;\n\t\t} else\n\t\t\targ = to_free = prefix_filename(state->prefix, arg);\n\n\t\tfd = open(arg, O_RDONLY);\n\t\tif (fd < 0) {\n\t\t\terror(_(\"can't open patch '%s': %s\"), arg, strerror(errno));\n\t\t\tres = -128;\n\t\t\tfree(to_free);\n\t\t\tgoto end;\n\t\t}\n\t\tread_stdin = 0;\n\t\tset_default_whitespace_mode(state);\n\t\tres = apply_patch(state, fd, arg, options);\n\t\tclose(fd);\n\t\tfree(to_free);\n\t\tif (res < 0)\n\t\t\tgoto end;\n\t\terrs |= res;\n\t}\n\tset_default_whitespace_mode(state);\n\tif (read_stdin) {\n\t\tres = apply_patch(state, 0, \"<stdin>\", options);\n\t\tif (res < 0)\n\t\t\tgoto end;\n\t\terrs |= res;\n\t}\n\n\tif (state->whitespace_error) {\n\t\tif (state->squelch_whitespace_errors &&\n\t\t    state->squelch_whitespace_errors < state->whitespace_error) {\n\t\t\tint squelched =\n\t\t\t\tstate->whitespace_error - state->squelch_whitespace_errors;\n\t\t\twarning(Q_(\"squelched %d whitespace error\",\n\t\t\t\t   \"squelched %d whitespace errors\",\n\t\t\t\t   squelched),\n\t\t\t\tsquelched);\n\t\t}\n\t\tif (state->ws_error_action == die_on_ws_error) {\n\t\t\terror(Q_(\"%d line adds whitespace errors.\",\n\t\t\t\t \"%d lines add whitespace errors.\",\n\t\t\t\t state->whitespace_error),\n\t\t\t      state->whitespace_error);\n\t\t\tres = -128;\n\t\t\tgoto end;\n\t\t}\n\t\tif (state->applied_after_fixing_ws && state->apply)\n\t\t\twarning(Q_(\"%d line applied after\"\n\t\t\t\t   \" fixing whitespace errors.\",\n\t\t\t\t   \"%d lines applied after\"\n\t\t\t\t   \" fixing whitespace errors.\",\n\t\t\t\t   state->applied_after_fixing_ws),\n\t\t\t\tstate->applied_after_fixing_ws);\n\t\telse if (state->whitespace_error)\n\t\t\twarning(Q_(\"%d line adds whitespace errors.\",\n\t\t\t\t   \"%d lines add whitespace errors.\",\n\t\t\t\t   state->whitespace_error),\n\t\t\t\tstate->whitespace_error);\n\t}\n\n\tif (state->update_index) {\n\t\tres = write_locked_index(state->repo->index, &state->lock_file, COMMIT_LOCK);\n\t\tif (res) {\n\t\t\terror(_(\"Unable to write new index file\"));\n\t\t\tres = -128;\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\tres = !!errs;\n\nend:\n\trollback_lock_file(&state->lock_file);\n\n\tif (state->apply_verbosity <= verbosity_silent) {\n\t\tset_error_routine(state->saved_error_routine);\n\t\tset_warn_routine(state->saved_warn_routine);\n\t}\n\n\tif (res > -1)\n\t\treturn res;\n\treturn (res == -1 ? 1 : 128);\n}\n\nint apply_parse_options(int argc, const char **argv,\n\t\t\tstruct apply_state *state,\n\t\t\tint *force_apply, int *options,\n\t\t\tconst char * const *apply_usage)\n{\n\tstruct option builtin_apply_options[] = {\n\t\tOPT_CALLBACK_F(0, \"exclude\", state, N_(\"path\"),\n\t\t\tN_(\"don't apply changes matching the given path\"),\n\t\t\tPARSE_OPT_NONEG, apply_option_parse_exclude),\n\t\tOPT_CALLBACK_F(0, \"include\", state, N_(\"path\"),\n\t\t\tN_(\"apply changes matching the given path\"),\n\t\t\tPARSE_OPT_NONEG, apply_option_parse_include),\n\t\tOPT_CALLBACK('p', NULL, state, N_(\"num\"),\n\t\t\tN_(\"remove <num> leading slashes from traditional diff paths\"),\n\t\t\tapply_option_parse_p),\n\t\tOPT_BOOL(0, \"no-add\", &state->no_add,\n\t\t\tN_(\"ignore additions made by the patch\")),\n\t\tOPT_BOOL(0, \"stat\", &state->diffstat,\n\t\t\tN_(\"instead of applying the patch, output diffstat for the input\")),\n\t\tOPT_NOOP_NOARG(0, \"allow-binary-replacement\"),\n\t\tOPT_NOOP_NOARG(0, \"binary\"),\n\t\tOPT_BOOL(0, \"numstat\", &state->numstat,\n\t\t\tN_(\"show number of added and deleted lines in decimal notation\")),\n\t\tOPT_BOOL(0, \"summary\", &state->summary,\n\t\t\tN_(\"instead of applying the patch, output a summary for the input\")),\n\t\tOPT_BOOL(0, \"check\", &state->check,\n\t\t\tN_(\"instead of applying the patch, see if the patch is applicable\")),\n\t\tOPT_BOOL(0, \"index\", &state->check_index,\n\t\t\tN_(\"make sure the patch is applicable to the current index\")),\n\t\tOPT_BOOL('N', \"intent-to-add\", &state->ita_only,\n\t\t\tN_(\"mark new files with `git add --intent-to-add`\")),\n\t\tOPT_BOOL(0, \"cached\", &state->cached,\n\t\t\tN_(\"apply a patch without touching the working tree\")),\n\t\tOPT_BOOL_F(0, \"unsafe-paths\", &state->unsafe_paths,\n\t\t\t   N_(\"accept a patch that touches outside the working area\"),\n\t\t\t   PARSE_OPT_NOCOMPLETE),\n\t\tOPT_BOOL(0, \"apply\", force_apply,\n\t\t\tN_(\"also apply the patch (use with --stat/--summary/--check)\")),\n\t\tOPT_BOOL('3', \"3way\", &state->threeway,\n\t\t\t N_( \"attempt three-way merge if a patch does not apply\")),\n\t\tOPT_FILENAME(0, \"build-fake-ancestor\", &state->fake_ancestor,\n\t\t\tN_(\"build a temporary index based on embedded index information\")),\n\t\t/* Think twice before adding \"--nul\" synonym to this */\n\t\tOPT_SET_INT('z', NULL, &state->line_termination,\n\t\t\tN_(\"paths are separated with NUL character\"), '\\0'),\n\t\tOPT_INTEGER('C', NULL, &state->p_context,\n\t\t\t\tN_(\"ensure at least <n> lines of context match\")),\n\t\tOPT_CALLBACK(0, \"whitespace\", state, N_(\"action\"),\n\t\t\tN_(\"detect new or modified lines that have whitespace errors\"),\n\t\t\tapply_option_parse_whitespace),\n\t\tOPT_CALLBACK_F(0, \"ignore-space-change\", state, NULL,\n\t\t\tN_(\"ignore changes in whitespace when finding context\"),\n\t\t\tPARSE_OPT_NOARG, apply_option_parse_space_change),\n\t\tOPT_CALLBACK_F(0, \"ignore-whitespace\", state, NULL,\n\t\t\tN_(\"ignore changes in whitespace when finding context\"),\n\t\t\tPARSE_OPT_NOARG, apply_option_parse_space_change),\n\t\tOPT_BOOL('R', \"reverse\", &state->apply_in_reverse,\n\t\t\tN_(\"apply the patch in reverse\")),\n\t\tOPT_BOOL(0, \"unidiff-zero\", &state->unidiff_zero,\n\t\t\tN_(\"don't expect at least one line of context\")),\n\t\tOPT_BOOL(0, \"reject\", &state->apply_with_reject,\n\t\t\tN_(\"leave the rejected hunks in corresponding *.rej files\")),\n\t\tOPT_BOOL(0, \"allow-overlap\", &state->allow_overlap,\n\t\t\tN_(\"allow overlapping hunks\")),\n\t\tOPT__VERBOSE(&state->apply_verbosity, N_(\"be verbose\")),\n\t\tOPT_BIT(0, \"inaccurate-eof\", options,\n\t\t\tN_(\"tolerate incorrectly detected missing new-line at the end of file\"),\n\t\t\tAPPLY_OPT_INACCURATE_EOF),\n\t\tOPT_BIT(0, \"recount\", options,\n\t\t\tN_(\"do not trust the line counts in the hunk headers\"),\n\t\t\tAPPLY_OPT_RECOUNT),\n\t\tOPT_CALLBACK(0, \"directory\", state, N_(\"root\"),\n\t\t\tN_(\"prepend <root> to all filenames\"),\n\t\t\tapply_option_parse_directory),\n\t\tOPT_END()\n\t};\n\n\treturn parse_options(argc, argv, state->prefix, builtin_apply_options, apply_usage, 0);\n}\n", "#!/bin/sh\n#\n# Copyright (c) 2005 Junio C Hamano\n#\n\ntest_description='git apply symlinks and partial files\n\n'\n\n. ./test-lib.sh\n\ntest_expect_success setup '\n\n\ttest_ln_s_add path1/path2/path3/path4/path5 link1 &&\n\tgit commit -m initial &&\n\n\tgit branch side &&\n\n\trm -f link? &&\n\n\ttest_ln_s_add htap6 link1 &&\n\tgit commit -m second &&\n\n\tgit diff-tree -p HEAD^ HEAD >patch  &&\n\tgit apply --stat --summary patch\n\n'\n\ntest_expect_success SYMLINKS 'apply symlink patch' '\n\n\tgit checkout side &&\n\tgit apply patch &&\n\tgit diff-files -p >patched &&\n\ttest_cmp patch patched\n\n'\n\ntest_expect_success 'apply --index symlink patch' '\n\n\tgit checkout -f side &&\n\tgit apply --index patch &&\n\tgit diff-index --cached -p HEAD >patched &&\n\ttest_cmp patch patched\n\n'\n\ntest_expect_success 'symlink setup' '\n\tln -s .git symlink &&\n\tgit add symlink &&\n\tgit commit -m \"add symlink\"\n'\n\ntest_expect_success SYMLINKS 'symlink escape when creating new files' '\n\ttest_when_finished \"git reset --hard && git clean -dfx\" &&\n\n\tcat >patch <<-EOF &&\n\tdiff --git a/symlink b/renamed-symlink\n\tsimilarity index 100%\n\trename from symlink\n\trename to renamed-symlink\n\t--\n\tdiff --git /dev/null b/renamed-symlink/create-me\n\tnew file mode 100644\n\tindex 0000000..039727e\n\t--- /dev/null\n\t+++ b/renamed-symlink/create-me\n\t@@ -0,0 +1,1 @@\n\t+busted\n\tEOF\n\n\ttest_must_fail git apply patch 2>stderr &&\n\tcat >expected_stderr <<-EOF &&\n\terror: affected file ${SQ}renamed-symlink/create-me${SQ} is beyond a symbolic link\n\tEOF\n\ttest_i18ncmp expected_stderr stderr &&\n\t! test_path_exists .git/create-me\n'\n\ntest_expect_success SYMLINKS 'symlink escape when modifying file' '\n\ttest_when_finished \"git reset --hard && git clean -dfx\" &&\n\ttouch .git/modify-me &&\n\n\tcat >patch <<-EOF &&\n\tdiff --git a/symlink b/renamed-symlink\n\tsimilarity index 100%\n\trename from symlink\n\trename to renamed-symlink\n\t--\n\tdiff --git a/renamed-symlink/modify-me b/renamed-symlink/modify-me\n\tindex 1111111..2222222 100644\n\t--- a/renamed-symlink/modify-me\n\t+++ b/renamed-symlink/modify-me\n\t@@ -0,0 +1,1 @@\n\t+busted\n\tEOF\n\n\ttest_must_fail git apply patch 2>stderr &&\n\tcat >expected_stderr <<-EOF &&\n\terror: renamed-symlink/modify-me: No such file or directory\n\tEOF\n\ttest_cmp expected_stderr stderr &&\n\ttest_must_be_empty .git/modify-me\n'\n\ntest_expect_success SYMLINKS 'symlink escape when deleting file' '\n\ttest_when_finished \"git reset --hard && git clean -dfx && rm .git/delete-me\" &&\n\ttouch .git/delete-me &&\n\n\tcat >patch <<-EOF &&\n\tdiff --git a/symlink b/renamed-symlink\n\tsimilarity index 100%\n\trename from symlink\n\trename to renamed-symlink\n\t--\n\tdiff --git a/renamed-symlink/delete-me b/renamed-symlink/delete-me\n\tdeleted file mode 100644\n\tindex 1111111..0000000 100644\n\tEOF\n\n\ttest_must_fail git apply patch 2>stderr &&\n\tcat >expected_stderr <<-EOF &&\n\terror: renamed-symlink/delete-me: No such file or directory\n\tEOF\n\ttest_cmp expected_stderr stderr &&\n\ttest_path_is_file .git/delete-me\n'\n\ntest_done\n"], "fixing_code": ["/*\n * apply.c\n *\n * Copyright (C) Linus Torvalds, 2005\n *\n * This applies patches on top of some (arbitrary) version of the SCM.\n *\n */\n\n#include \"cache.h\"\n#include \"config.h\"\n#include \"object-store.h\"\n#include \"blob.h\"\n#include \"delta.h\"\n#include \"diff.h\"\n#include \"dir.h\"\n#include \"xdiff-interface.h\"\n#include \"ll-merge.h\"\n#include \"lockfile.h\"\n#include \"parse-options.h\"\n#include \"quote.h\"\n#include \"rerere.h\"\n#include \"apply.h\"\n\nstruct gitdiff_data {\n\tstruct strbuf *root;\n\tint linenr;\n\tint p_value;\n};\n\nstatic void git_apply_config(void)\n{\n\tgit_config_get_string(\"apply.whitespace\", &apply_default_whitespace);\n\tgit_config_get_string(\"apply.ignorewhitespace\", &apply_default_ignorewhitespace);\n\tgit_config(git_xmerge_config, NULL);\n}\n\nstatic int parse_whitespace_option(struct apply_state *state, const char *option)\n{\n\tif (!option) {\n\t\tstate->ws_error_action = warn_on_ws_error;\n\t\treturn 0;\n\t}\n\tif (!strcmp(option, \"warn\")) {\n\t\tstate->ws_error_action = warn_on_ws_error;\n\t\treturn 0;\n\t}\n\tif (!strcmp(option, \"nowarn\")) {\n\t\tstate->ws_error_action = nowarn_ws_error;\n\t\treturn 0;\n\t}\n\tif (!strcmp(option, \"error\")) {\n\t\tstate->ws_error_action = die_on_ws_error;\n\t\treturn 0;\n\t}\n\tif (!strcmp(option, \"error-all\")) {\n\t\tstate->ws_error_action = die_on_ws_error;\n\t\tstate->squelch_whitespace_errors = 0;\n\t\treturn 0;\n\t}\n\tif (!strcmp(option, \"strip\") || !strcmp(option, \"fix\")) {\n\t\tstate->ws_error_action = correct_ws_error;\n\t\treturn 0;\n\t}\n\t/*\n\t * Please update $__git_whitespacelist in git-completion.bash\n\t * when you add new options.\n\t */\n\treturn error(_(\"unrecognized whitespace option '%s'\"), option);\n}\n\nstatic int parse_ignorewhitespace_option(struct apply_state *state,\n\t\t\t\t\t\t const char *option)\n{\n\tif (!option || !strcmp(option, \"no\") ||\n\t    !strcmp(option, \"false\") || !strcmp(option, \"never\") ||\n\t    !strcmp(option, \"none\")) {\n\t\tstate->ws_ignore_action = ignore_ws_none;\n\t\treturn 0;\n\t}\n\tif (!strcmp(option, \"change\")) {\n\t\tstate->ws_ignore_action = ignore_ws_change;\n\t\treturn 0;\n\t}\n\treturn error(_(\"unrecognized whitespace ignore option '%s'\"), option);\n}\n\nint init_apply_state(struct apply_state *state,\n\t\t     struct repository *repo,\n\t\t     const char *prefix)\n{\n\tmemset(state, 0, sizeof(*state));\n\tstate->prefix = prefix;\n\tstate->repo = repo;\n\tstate->apply = 1;\n\tstate->line_termination = '\\n';\n\tstate->p_value = 1;\n\tstate->p_context = UINT_MAX;\n\tstate->squelch_whitespace_errors = 5;\n\tstate->ws_error_action = warn_on_ws_error;\n\tstate->ws_ignore_action = ignore_ws_none;\n\tstate->linenr = 1;\n\tstring_list_init(&state->fn_table, 0);\n\tstring_list_init(&state->limit_by_name, 0);\n\tstring_list_init(&state->symlink_changes, 0);\n\tstrbuf_init(&state->root, 0);\n\n\tgit_apply_config();\n\tif (apply_default_whitespace && parse_whitespace_option(state, apply_default_whitespace))\n\t\treturn -1;\n\tif (apply_default_ignorewhitespace && parse_ignorewhitespace_option(state, apply_default_ignorewhitespace))\n\t\treturn -1;\n\treturn 0;\n}\n\nvoid clear_apply_state(struct apply_state *state)\n{\n\tstring_list_clear(&state->limit_by_name, 0);\n\tstring_list_clear(&state->symlink_changes, 0);\n\tstrbuf_release(&state->root);\n\n\t/* &state->fn_table is cleared at the end of apply_patch() */\n}\n\nstatic void mute_routine(const char *msg, va_list params)\n{\n\t/* do nothing */\n}\n\nint check_apply_state(struct apply_state *state, int force_apply)\n{\n\tint is_not_gitdir = !startup_info->have_repository;\n\n\tif (state->apply_with_reject && state->threeway)\n\t\treturn error(_(\"--reject and --3way cannot be used together.\"));\n\tif (state->cached && state->threeway)\n\t\treturn error(_(\"--cached and --3way cannot be used together.\"));\n\tif (state->threeway) {\n\t\tif (is_not_gitdir)\n\t\t\treturn error(_(\"--3way outside a repository\"));\n\t\tstate->check_index = 1;\n\t}\n\tif (state->apply_with_reject) {\n\t\tstate->apply = 1;\n\t\tif (state->apply_verbosity == verbosity_normal)\n\t\t\tstate->apply_verbosity = verbosity_verbose;\n\t}\n\tif (!force_apply && (state->diffstat || state->numstat || state->summary || state->check || state->fake_ancestor))\n\t\tstate->apply = 0;\n\tif (state->check_index && is_not_gitdir)\n\t\treturn error(_(\"--index outside a repository\"));\n\tif (state->cached) {\n\t\tif (is_not_gitdir)\n\t\t\treturn error(_(\"--cached outside a repository\"));\n\t\tstate->check_index = 1;\n\t}\n\tif (state->ita_only && (state->check_index || is_not_gitdir))\n\t\tstate->ita_only = 0;\n\tif (state->check_index)\n\t\tstate->unsafe_paths = 0;\n\n\tif (state->apply_verbosity <= verbosity_silent) {\n\t\tstate->saved_error_routine = get_error_routine();\n\t\tstate->saved_warn_routine = get_warn_routine();\n\t\tset_error_routine(mute_routine);\n\t\tset_warn_routine(mute_routine);\n\t}\n\n\treturn 0;\n}\n\nstatic void set_default_whitespace_mode(struct apply_state *state)\n{\n\tif (!state->whitespace_option && !apply_default_whitespace)\n\t\tstate->ws_error_action = (state->apply ? warn_on_ws_error : nowarn_ws_error);\n}\n\n/*\n * This represents one \"hunk\" from a patch, starting with\n * \"@@ -oldpos,oldlines +newpos,newlines @@\" marker.  The\n * patch text is pointed at by patch, and its byte length\n * is stored in size.  leading and trailing are the number\n * of context lines.\n */\nstruct fragment {\n\tunsigned long leading, trailing;\n\tunsigned long oldpos, oldlines;\n\tunsigned long newpos, newlines;\n\t/*\n\t * 'patch' is usually borrowed from buf in apply_patch(),\n\t * but some codepaths store an allocated buffer.\n\t */\n\tconst char *patch;\n\tunsigned free_patch:1,\n\t\trejected:1;\n\tint size;\n\tint linenr;\n\tstruct fragment *next;\n};\n\n/*\n * When dealing with a binary patch, we reuse \"leading\" field\n * to store the type of the binary hunk, either deflated \"delta\"\n * or deflated \"literal\".\n */\n#define binary_patch_method leading\n#define BINARY_DELTA_DEFLATED\t1\n#define BINARY_LITERAL_DEFLATED 2\n\nstatic void free_fragment_list(struct fragment *list)\n{\n\twhile (list) {\n\t\tstruct fragment *next = list->next;\n\t\tif (list->free_patch)\n\t\t\tfree((char *)list->patch);\n\t\tfree(list);\n\t\tlist = next;\n\t}\n}\n\nstatic void free_patch(struct patch *patch)\n{\n\tfree_fragment_list(patch->fragments);\n\tfree(patch->def_name);\n\tfree(patch->old_name);\n\tfree(patch->new_name);\n\tfree(patch->result);\n\tfree(patch);\n}\n\nstatic void free_patch_list(struct patch *list)\n{\n\twhile (list) {\n\t\tstruct patch *next = list->next;\n\t\tfree_patch(list);\n\t\tlist = next;\n\t}\n}\n\n/*\n * A line in a file, len-bytes long (includes the terminating LF,\n * except for an incomplete line at the end if the file ends with\n * one), and its contents hashes to 'hash'.\n */\nstruct line {\n\tsize_t len;\n\tunsigned hash : 24;\n\tunsigned flag : 8;\n#define LINE_COMMON     1\n#define LINE_PATCHED\t2\n};\n\n/*\n * This represents a \"file\", which is an array of \"lines\".\n */\nstruct image {\n\tchar *buf;\n\tsize_t len;\n\tsize_t nr;\n\tsize_t alloc;\n\tstruct line *line_allocated;\n\tstruct line *line;\n};\n\nstatic uint32_t hash_line(const char *cp, size_t len)\n{\n\tsize_t i;\n\tuint32_t h;\n\tfor (i = 0, h = 0; i < len; i++) {\n\t\tif (!isspace(cp[i])) {\n\t\t\th = h * 3 + (cp[i] & 0xff);\n\t\t}\n\t}\n\treturn h;\n}\n\n/*\n * Compare lines s1 of length n1 and s2 of length n2, ignoring\n * whitespace difference. Returns 1 if they match, 0 otherwise\n */\nstatic int fuzzy_matchlines(const char *s1, size_t n1,\n\t\t\t    const char *s2, size_t n2)\n{\n\tconst char *end1 = s1 + n1;\n\tconst char *end2 = s2 + n2;\n\n\t/* ignore line endings */\n\twhile (s1 < end1 && (end1[-1] == '\\r' || end1[-1] == '\\n'))\n\t\tend1--;\n\twhile (s2 < end2 && (end2[-1] == '\\r' || end2[-1] == '\\n'))\n\t\tend2--;\n\n\twhile (s1 < end1 && s2 < end2) {\n\t\tif (isspace(*s1)) {\n\t\t\t/*\n\t\t\t * Skip whitespace. We check on both buffers\n\t\t\t * because we don't want \"a b\" to match \"ab\".\n\t\t\t */\n\t\t\tif (!isspace(*s2))\n\t\t\t\treturn 0;\n\t\t\twhile (s1 < end1 && isspace(*s1))\n\t\t\t\ts1++;\n\t\t\twhile (s2 < end2 && isspace(*s2))\n\t\t\t\ts2++;\n\t\t} else if (*s1++ != *s2++)\n\t\t\treturn 0;\n\t}\n\n\t/* If we reached the end on one side only, lines don't match. */\n\treturn s1 == end1 && s2 == end2;\n}\n\nstatic void add_line_info(struct image *img, const char *bol, size_t len, unsigned flag)\n{\n\tALLOC_GROW(img->line_allocated, img->nr + 1, img->alloc);\n\timg->line_allocated[img->nr].len = len;\n\timg->line_allocated[img->nr].hash = hash_line(bol, len);\n\timg->line_allocated[img->nr].flag = flag;\n\timg->nr++;\n}\n\n/*\n * \"buf\" has the file contents to be patched (read from various sources).\n * attach it to \"image\" and add line-based index to it.\n * \"image\" now owns the \"buf\".\n */\nstatic void prepare_image(struct image *image, char *buf, size_t len,\n\t\t\t  int prepare_linetable)\n{\n\tconst char *cp, *ep;\n\n\tmemset(image, 0, sizeof(*image));\n\timage->buf = buf;\n\timage->len = len;\n\n\tif (!prepare_linetable)\n\t\treturn;\n\n\tep = image->buf + image->len;\n\tcp = image->buf;\n\twhile (cp < ep) {\n\t\tconst char *next;\n\t\tfor (next = cp; next < ep && *next != '\\n'; next++)\n\t\t\t;\n\t\tif (next < ep)\n\t\t\tnext++;\n\t\tadd_line_info(image, cp, next - cp, 0);\n\t\tcp = next;\n\t}\n\timage->line = image->line_allocated;\n}\n\nstatic void clear_image(struct image *image)\n{\n\tfree(image->buf);\n\tfree(image->line_allocated);\n\tmemset(image, 0, sizeof(*image));\n}\n\n/* fmt must contain _one_ %s and no other substitution */\nstatic void say_patch_name(FILE *output, const char *fmt, struct patch *patch)\n{\n\tstruct strbuf sb = STRBUF_INIT;\n\n\tif (patch->old_name && patch->new_name &&\n\t    strcmp(patch->old_name, patch->new_name)) {\n\t\tquote_c_style(patch->old_name, &sb, NULL, 0);\n\t\tstrbuf_addstr(&sb, \" => \");\n\t\tquote_c_style(patch->new_name, &sb, NULL, 0);\n\t} else {\n\t\tconst char *n = patch->new_name;\n\t\tif (!n)\n\t\t\tn = patch->old_name;\n\t\tquote_c_style(n, &sb, NULL, 0);\n\t}\n\tfprintf(output, fmt, sb.buf);\n\tfputc('\\n', output);\n\tstrbuf_release(&sb);\n}\n\n#define SLOP (16)\n\nstatic int read_patch_file(struct strbuf *sb, int fd)\n{\n\tif (strbuf_read(sb, fd, 0) < 0)\n\t\treturn error_errno(\"git apply: failed to read\");\n\n\t/*\n\t * Make sure that we have some slop in the buffer\n\t * so that we can do speculative \"memcmp\" etc, and\n\t * see to it that it is NUL-filled.\n\t */\n\tstrbuf_grow(sb, SLOP);\n\tmemset(sb->buf + sb->len, 0, SLOP);\n\treturn 0;\n}\n\nstatic unsigned long linelen(const char *buffer, unsigned long size)\n{\n\tunsigned long len = 0;\n\twhile (size--) {\n\t\tlen++;\n\t\tif (*buffer++ == '\\n')\n\t\t\tbreak;\n\t}\n\treturn len;\n}\n\nstatic int is_dev_null(const char *str)\n{\n\treturn skip_prefix(str, \"/dev/null\", &str) && isspace(*str);\n}\n\n#define TERM_SPACE\t1\n#define TERM_TAB\t2\n\nstatic int name_terminate(int c, int terminate)\n{\n\tif (c == ' ' && !(terminate & TERM_SPACE))\n\t\treturn 0;\n\tif (c == '\\t' && !(terminate & TERM_TAB))\n\t\treturn 0;\n\n\treturn 1;\n}\n\n/* remove double slashes to make --index work with such filenames */\nstatic char *squash_slash(char *name)\n{\n\tint i = 0, j = 0;\n\n\tif (!name)\n\t\treturn NULL;\n\n\twhile (name[i]) {\n\t\tif ((name[j++] = name[i++]) == '/')\n\t\t\twhile (name[i] == '/')\n\t\t\t\ti++;\n\t}\n\tname[j] = '\\0';\n\treturn name;\n}\n\nstatic char *find_name_gnu(struct strbuf *root,\n\t\t\t   const char *line,\n\t\t\t   int p_value)\n{\n\tstruct strbuf name = STRBUF_INIT;\n\tchar *cp;\n\n\t/*\n\t * Proposed \"new-style\" GNU patch/diff format; see\n\t * https://lore.kernel.org/git/7vll0wvb2a.fsf@assigned-by-dhcp.cox.net/\n\t */\n\tif (unquote_c_style(&name, line, NULL)) {\n\t\tstrbuf_release(&name);\n\t\treturn NULL;\n\t}\n\n\tfor (cp = name.buf; p_value; p_value--) {\n\t\tcp = strchr(cp, '/');\n\t\tif (!cp) {\n\t\t\tstrbuf_release(&name);\n\t\t\treturn NULL;\n\t\t}\n\t\tcp++;\n\t}\n\n\tstrbuf_remove(&name, 0, cp - name.buf);\n\tif (root->len)\n\t\tstrbuf_insert(&name, 0, root->buf, root->len);\n\treturn squash_slash(strbuf_detach(&name, NULL));\n}\n\nstatic size_t sane_tz_len(const char *line, size_t len)\n{\n\tconst char *tz, *p;\n\n\tif (len < strlen(\" +0500\") || line[len-strlen(\" +0500\")] != ' ')\n\t\treturn 0;\n\ttz = line + len - strlen(\" +0500\");\n\n\tif (tz[1] != '+' && tz[1] != '-')\n\t\treturn 0;\n\n\tfor (p = tz + 2; p != line + len; p++)\n\t\tif (!isdigit(*p))\n\t\t\treturn 0;\n\n\treturn line + len - tz;\n}\n\nstatic size_t tz_with_colon_len(const char *line, size_t len)\n{\n\tconst char *tz, *p;\n\n\tif (len < strlen(\" +08:00\") || line[len - strlen(\":00\")] != ':')\n\t\treturn 0;\n\ttz = line + len - strlen(\" +08:00\");\n\n\tif (tz[0] != ' ' || (tz[1] != '+' && tz[1] != '-'))\n\t\treturn 0;\n\tp = tz + 2;\n\tif (!isdigit(*p++) || !isdigit(*p++) || *p++ != ':' ||\n\t    !isdigit(*p++) || !isdigit(*p++))\n\t\treturn 0;\n\n\treturn line + len - tz;\n}\n\nstatic size_t date_len(const char *line, size_t len)\n{\n\tconst char *date, *p;\n\n\tif (len < strlen(\"72-02-05\") || line[len-strlen(\"-05\")] != '-')\n\t\treturn 0;\n\tp = date = line + len - strlen(\"72-02-05\");\n\n\tif (!isdigit(*p++) || !isdigit(*p++) || *p++ != '-' ||\n\t    !isdigit(*p++) || !isdigit(*p++) || *p++ != '-' ||\n\t    !isdigit(*p++) || !isdigit(*p++))\t/* Not a date. */\n\t\treturn 0;\n\n\tif (date - line >= strlen(\"19\") &&\n\t    isdigit(date[-1]) && isdigit(date[-2]))\t/* 4-digit year */\n\t\tdate -= strlen(\"19\");\n\n\treturn line + len - date;\n}\n\nstatic size_t short_time_len(const char *line, size_t len)\n{\n\tconst char *time, *p;\n\n\tif (len < strlen(\" 07:01:32\") || line[len-strlen(\":32\")] != ':')\n\t\treturn 0;\n\tp = time = line + len - strlen(\" 07:01:32\");\n\n\t/* Permit 1-digit hours? */\n\tif (*p++ != ' ' ||\n\t    !isdigit(*p++) || !isdigit(*p++) || *p++ != ':' ||\n\t    !isdigit(*p++) || !isdigit(*p++) || *p++ != ':' ||\n\t    !isdigit(*p++) || !isdigit(*p++))\t/* Not a time. */\n\t\treturn 0;\n\n\treturn line + len - time;\n}\n\nstatic size_t fractional_time_len(const char *line, size_t len)\n{\n\tconst char *p;\n\tsize_t n;\n\n\t/* Expected format: 19:41:17.620000023 */\n\tif (!len || !isdigit(line[len - 1]))\n\t\treturn 0;\n\tp = line + len - 1;\n\n\t/* Fractional seconds. */\n\twhile (p > line && isdigit(*p))\n\t\tp--;\n\tif (*p != '.')\n\t\treturn 0;\n\n\t/* Hours, minutes, and whole seconds. */\n\tn = short_time_len(line, p - line);\n\tif (!n)\n\t\treturn 0;\n\n\treturn line + len - p + n;\n}\n\nstatic size_t trailing_spaces_len(const char *line, size_t len)\n{\n\tconst char *p;\n\n\t/* Expected format: ' ' x (1 or more)  */\n\tif (!len || line[len - 1] != ' ')\n\t\treturn 0;\n\n\tp = line + len;\n\twhile (p != line) {\n\t\tp--;\n\t\tif (*p != ' ')\n\t\t\treturn line + len - (p + 1);\n\t}\n\n\t/* All spaces! */\n\treturn len;\n}\n\nstatic size_t diff_timestamp_len(const char *line, size_t len)\n{\n\tconst char *end = line + len;\n\tsize_t n;\n\n\t/*\n\t * Posix: 2010-07-05 19:41:17\n\t * GNU: 2010-07-05 19:41:17.620000023 -0500\n\t */\n\n\tif (!isdigit(end[-1]))\n\t\treturn 0;\n\n\tn = sane_tz_len(line, end - line);\n\tif (!n)\n\t\tn = tz_with_colon_len(line, end - line);\n\tend -= n;\n\n\tn = short_time_len(line, end - line);\n\tif (!n)\n\t\tn = fractional_time_len(line, end - line);\n\tend -= n;\n\n\tn = date_len(line, end - line);\n\tif (!n)\t/* No date.  Too bad. */\n\t\treturn 0;\n\tend -= n;\n\n\tif (end == line)\t/* No space before date. */\n\t\treturn 0;\n\tif (end[-1] == '\\t') {\t/* Success! */\n\t\tend--;\n\t\treturn line + len - end;\n\t}\n\tif (end[-1] != ' ')\t/* No space before date. */\n\t\treturn 0;\n\n\t/* Whitespace damage. */\n\tend -= trailing_spaces_len(line, end - line);\n\treturn line + len - end;\n}\n\nstatic char *find_name_common(struct strbuf *root,\n\t\t\t      const char *line,\n\t\t\t      const char *def,\n\t\t\t      int p_value,\n\t\t\t      const char *end,\n\t\t\t      int terminate)\n{\n\tint len;\n\tconst char *start = NULL;\n\n\tif (p_value == 0)\n\t\tstart = line;\n\twhile (line != end) {\n\t\tchar c = *line;\n\n\t\tif (!end && isspace(c)) {\n\t\t\tif (c == '\\n')\n\t\t\t\tbreak;\n\t\t\tif (name_terminate(c, terminate))\n\t\t\t\tbreak;\n\t\t}\n\t\tline++;\n\t\tif (c == '/' && !--p_value)\n\t\t\tstart = line;\n\t}\n\tif (!start)\n\t\treturn squash_slash(xstrdup_or_null(def));\n\tlen = line - start;\n\tif (!len)\n\t\treturn squash_slash(xstrdup_or_null(def));\n\n\t/*\n\t * Generally we prefer the shorter name, especially\n\t * if the other one is just a variation of that with\n\t * something else tacked on to the end (ie \"file.orig\"\n\t * or \"file~\").\n\t */\n\tif (def) {\n\t\tint deflen = strlen(def);\n\t\tif (deflen < len && !strncmp(start, def, deflen))\n\t\t\treturn squash_slash(xstrdup(def));\n\t}\n\n\tif (root->len) {\n\t\tchar *ret = xstrfmt(\"%s%.*s\", root->buf, len, start);\n\t\treturn squash_slash(ret);\n\t}\n\n\treturn squash_slash(xmemdupz(start, len));\n}\n\nstatic char *find_name(struct strbuf *root,\n\t\t       const char *line,\n\t\t       char *def,\n\t\t       int p_value,\n\t\t       int terminate)\n{\n\tif (*line == '\"') {\n\t\tchar *name = find_name_gnu(root, line, p_value);\n\t\tif (name)\n\t\t\treturn name;\n\t}\n\n\treturn find_name_common(root, line, def, p_value, NULL, terminate);\n}\n\nstatic char *find_name_traditional(struct strbuf *root,\n\t\t\t\t   const char *line,\n\t\t\t\t   char *def,\n\t\t\t\t   int p_value)\n{\n\tsize_t len;\n\tsize_t date_len;\n\n\tif (*line == '\"') {\n\t\tchar *name = find_name_gnu(root, line, p_value);\n\t\tif (name)\n\t\t\treturn name;\n\t}\n\n\tlen = strchrnul(line, '\\n') - line;\n\tdate_len = diff_timestamp_len(line, len);\n\tif (!date_len)\n\t\treturn find_name_common(root, line, def, p_value, NULL, TERM_TAB);\n\tlen -= date_len;\n\n\treturn find_name_common(root, line, def, p_value, line + len, 0);\n}\n\n/*\n * Given the string after \"--- \" or \"+++ \", guess the appropriate\n * p_value for the given patch.\n */\nstatic int guess_p_value(struct apply_state *state, const char *nameline)\n{\n\tchar *name, *cp;\n\tint val = -1;\n\n\tif (is_dev_null(nameline))\n\t\treturn -1;\n\tname = find_name_traditional(&state->root, nameline, NULL, 0);\n\tif (!name)\n\t\treturn -1;\n\tcp = strchr(name, '/');\n\tif (!cp)\n\t\tval = 0;\n\telse if (state->prefix) {\n\t\t/*\n\t\t * Does it begin with \"a/$our-prefix\" and such?  Then this is\n\t\t * very likely to apply to our directory.\n\t\t */\n\t\tif (starts_with(name, state->prefix))\n\t\t\tval = count_slashes(state->prefix);\n\t\telse {\n\t\t\tcp++;\n\t\t\tif (starts_with(cp, state->prefix))\n\t\t\t\tval = count_slashes(state->prefix) + 1;\n\t\t}\n\t}\n\tfree(name);\n\treturn val;\n}\n\n/*\n * Does the ---/+++ line have the POSIX timestamp after the last HT?\n * GNU diff puts epoch there to signal a creation/deletion event.  Is\n * this such a timestamp?\n */\nstatic int has_epoch_timestamp(const char *nameline)\n{\n\t/*\n\t * We are only interested in epoch timestamp; any non-zero\n\t * fraction cannot be one, hence \"(\\.0+)?\" in the regexp below.\n\t * For the same reason, the date must be either 1969-12-31 or\n\t * 1970-01-01, and the seconds part must be \"00\".\n\t */\n\tconst char stamp_regexp[] =\n\t\t\"^[0-2][0-9]:([0-5][0-9]):00(\\\\.0+)?\"\n\t\t\" \"\n\t\t\"([-+][0-2][0-9]:?[0-5][0-9])\\n\";\n\tconst char *timestamp = NULL, *cp, *colon;\n\tstatic regex_t *stamp;\n\tregmatch_t m[10];\n\tint zoneoffset, epoch_hour, hour, minute;\n\tint status;\n\n\tfor (cp = nameline; *cp != '\\n'; cp++) {\n\t\tif (*cp == '\\t')\n\t\t\ttimestamp = cp + 1;\n\t}\n\tif (!timestamp)\n\t\treturn 0;\n\n\t/*\n\t * YYYY-MM-DD hh:mm:ss must be from either 1969-12-31\n\t * (west of GMT) or 1970-01-01 (east of GMT)\n\t */\n\tif (skip_prefix(timestamp, \"1969-12-31 \", &timestamp))\n\t\tepoch_hour = 24;\n\telse if (skip_prefix(timestamp, \"1970-01-01 \", &timestamp))\n\t\tepoch_hour = 0;\n\telse\n\t\treturn 0;\n\n\tif (!stamp) {\n\t\tstamp = xmalloc(sizeof(*stamp));\n\t\tif (regcomp(stamp, stamp_regexp, REG_EXTENDED)) {\n\t\t\twarning(_(\"Cannot prepare timestamp regexp %s\"),\n\t\t\t\tstamp_regexp);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tstatus = regexec(stamp, timestamp, ARRAY_SIZE(m), m, 0);\n\tif (status) {\n\t\tif (status != REG_NOMATCH)\n\t\t\twarning(_(\"regexec returned %d for input: %s\"),\n\t\t\t\tstatus, timestamp);\n\t\treturn 0;\n\t}\n\n\thour = strtol(timestamp, NULL, 10);\n\tminute = strtol(timestamp + m[1].rm_so, NULL, 10);\n\n\tzoneoffset = strtol(timestamp + m[3].rm_so + 1, (char **) &colon, 10);\n\tif (*colon == ':')\n\t\tzoneoffset = zoneoffset * 60 + strtol(colon + 1, NULL, 10);\n\telse\n\t\tzoneoffset = (zoneoffset / 100) * 60 + (zoneoffset % 100);\n\tif (timestamp[m[3].rm_so] == '-')\n\t\tzoneoffset = -zoneoffset;\n\n\treturn hour * 60 + minute - zoneoffset == epoch_hour * 60;\n}\n\n/*\n * Get the name etc info from the ---/+++ lines of a traditional patch header\n *\n * FIXME! The end-of-filename heuristics are kind of screwy. For existing\n * files, we can happily check the index for a match, but for creating a\n * new file we should try to match whatever \"patch\" does. I have no idea.\n */\nstatic int parse_traditional_patch(struct apply_state *state,\n\t\t\t\t   const char *first,\n\t\t\t\t   const char *second,\n\t\t\t\t   struct patch *patch)\n{\n\tchar *name;\n\n\tfirst += 4;\t/* skip \"--- \" */\n\tsecond += 4;\t/* skip \"+++ \" */\n\tif (!state->p_value_known) {\n\t\tint p, q;\n\t\tp = guess_p_value(state, first);\n\t\tq = guess_p_value(state, second);\n\t\tif (p < 0) p = q;\n\t\tif (0 <= p && p == q) {\n\t\t\tstate->p_value = p;\n\t\t\tstate->p_value_known = 1;\n\t\t}\n\t}\n\tif (is_dev_null(first)) {\n\t\tpatch->is_new = 1;\n\t\tpatch->is_delete = 0;\n\t\tname = find_name_traditional(&state->root, second, NULL, state->p_value);\n\t\tpatch->new_name = name;\n\t} else if (is_dev_null(second)) {\n\t\tpatch->is_new = 0;\n\t\tpatch->is_delete = 1;\n\t\tname = find_name_traditional(&state->root, first, NULL, state->p_value);\n\t\tpatch->old_name = name;\n\t} else {\n\t\tchar *first_name;\n\t\tfirst_name = find_name_traditional(&state->root, first, NULL, state->p_value);\n\t\tname = find_name_traditional(&state->root, second, first_name, state->p_value);\n\t\tfree(first_name);\n\t\tif (has_epoch_timestamp(first)) {\n\t\t\tpatch->is_new = 1;\n\t\t\tpatch->is_delete = 0;\n\t\t\tpatch->new_name = name;\n\t\t} else if (has_epoch_timestamp(second)) {\n\t\t\tpatch->is_new = 0;\n\t\t\tpatch->is_delete = 1;\n\t\t\tpatch->old_name = name;\n\t\t} else {\n\t\t\tpatch->old_name = name;\n\t\t\tpatch->new_name = xstrdup_or_null(name);\n\t\t}\n\t}\n\tif (!name)\n\t\treturn error(_(\"unable to find filename in patch at line %d\"), state->linenr);\n\n\treturn 0;\n}\n\nstatic int gitdiff_hdrend(struct gitdiff_data *state,\n\t\t\t  const char *line,\n\t\t\t  struct patch *patch)\n{\n\treturn 1;\n}\n\n/*\n * We're anal about diff header consistency, to make\n * sure that we don't end up having strange ambiguous\n * patches floating around.\n *\n * As a result, gitdiff_{old|new}name() will check\n * their names against any previous information, just\n * to make sure..\n */\n#define DIFF_OLD_NAME 0\n#define DIFF_NEW_NAME 1\n\nstatic int gitdiff_verify_name(struct gitdiff_data *state,\n\t\t\t       const char *line,\n\t\t\t       int isnull,\n\t\t\t       char **name,\n\t\t\t       int side)\n{\n\tif (!*name && !isnull) {\n\t\t*name = find_name(state->root, line, NULL, state->p_value, TERM_TAB);\n\t\treturn 0;\n\t}\n\n\tif (*name) {\n\t\tchar *another;\n\t\tif (isnull)\n\t\t\treturn error(_(\"git apply: bad git-diff - expected /dev/null, got %s on line %d\"),\n\t\t\t\t     *name, state->linenr);\n\t\tanother = find_name(state->root, line, NULL, state->p_value, TERM_TAB);\n\t\tif (!another || strcmp(another, *name)) {\n\t\t\tfree(another);\n\t\t\treturn error((side == DIFF_NEW_NAME) ?\n\t\t\t    _(\"git apply: bad git-diff - inconsistent new filename on line %d\") :\n\t\t\t    _(\"git apply: bad git-diff - inconsistent old filename on line %d\"), state->linenr);\n\t\t}\n\t\tfree(another);\n\t} else {\n\t\tif (!is_dev_null(line))\n\t\t\treturn error(_(\"git apply: bad git-diff - expected /dev/null on line %d\"), state->linenr);\n\t}\n\n\treturn 0;\n}\n\nstatic int gitdiff_oldname(struct gitdiff_data *state,\n\t\t\t   const char *line,\n\t\t\t   struct patch *patch)\n{\n\treturn gitdiff_verify_name(state, line,\n\t\t\t\t   patch->is_new, &patch->old_name,\n\t\t\t\t   DIFF_OLD_NAME);\n}\n\nstatic int gitdiff_newname(struct gitdiff_data *state,\n\t\t\t   const char *line,\n\t\t\t   struct patch *patch)\n{\n\treturn gitdiff_verify_name(state, line,\n\t\t\t\t   patch->is_delete, &patch->new_name,\n\t\t\t\t   DIFF_NEW_NAME);\n}\n\nstatic int parse_mode_line(const char *line, int linenr, unsigned int *mode)\n{\n\tchar *end;\n\t*mode = strtoul(line, &end, 8);\n\tif (end == line || !isspace(*end))\n\t\treturn error(_(\"invalid mode on line %d: %s\"), linenr, line);\n\treturn 0;\n}\n\nstatic int gitdiff_oldmode(struct gitdiff_data *state,\n\t\t\t   const char *line,\n\t\t\t   struct patch *patch)\n{\n\treturn parse_mode_line(line, state->linenr, &patch->old_mode);\n}\n\nstatic int gitdiff_newmode(struct gitdiff_data *state,\n\t\t\t   const char *line,\n\t\t\t   struct patch *patch)\n{\n\treturn parse_mode_line(line, state->linenr, &patch->new_mode);\n}\n\nstatic int gitdiff_delete(struct gitdiff_data *state,\n\t\t\t  const char *line,\n\t\t\t  struct patch *patch)\n{\n\tpatch->is_delete = 1;\n\tfree(patch->old_name);\n\tpatch->old_name = xstrdup_or_null(patch->def_name);\n\treturn gitdiff_oldmode(state, line, patch);\n}\n\nstatic int gitdiff_newfile(struct gitdiff_data *state,\n\t\t\t   const char *line,\n\t\t\t   struct patch *patch)\n{\n\tpatch->is_new = 1;\n\tfree(patch->new_name);\n\tpatch->new_name = xstrdup_or_null(patch->def_name);\n\treturn gitdiff_newmode(state, line, patch);\n}\n\nstatic int gitdiff_copysrc(struct gitdiff_data *state,\n\t\t\t   const char *line,\n\t\t\t   struct patch *patch)\n{\n\tpatch->is_copy = 1;\n\tfree(patch->old_name);\n\tpatch->old_name = find_name(state->root, line, NULL, state->p_value ? state->p_value - 1 : 0, 0);\n\treturn 0;\n}\n\nstatic int gitdiff_copydst(struct gitdiff_data *state,\n\t\t\t   const char *line,\n\t\t\t   struct patch *patch)\n{\n\tpatch->is_copy = 1;\n\tfree(patch->new_name);\n\tpatch->new_name = find_name(state->root, line, NULL, state->p_value ? state->p_value - 1 : 0, 0);\n\treturn 0;\n}\n\nstatic int gitdiff_renamesrc(struct gitdiff_data *state,\n\t\t\t     const char *line,\n\t\t\t     struct patch *patch)\n{\n\tpatch->is_rename = 1;\n\tfree(patch->old_name);\n\tpatch->old_name = find_name(state->root, line, NULL, state->p_value ? state->p_value - 1 : 0, 0);\n\treturn 0;\n}\n\nstatic int gitdiff_renamedst(struct gitdiff_data *state,\n\t\t\t     const char *line,\n\t\t\t     struct patch *patch)\n{\n\tpatch->is_rename = 1;\n\tfree(patch->new_name);\n\tpatch->new_name = find_name(state->root, line, NULL, state->p_value ? state->p_value - 1 : 0, 0);\n\treturn 0;\n}\n\nstatic int gitdiff_similarity(struct gitdiff_data *state,\n\t\t\t      const char *line,\n\t\t\t      struct patch *patch)\n{\n\tunsigned long val = strtoul(line, NULL, 10);\n\tif (val <= 100)\n\t\tpatch->score = val;\n\treturn 0;\n}\n\nstatic int gitdiff_dissimilarity(struct gitdiff_data *state,\n\t\t\t\t const char *line,\n\t\t\t\t struct patch *patch)\n{\n\tunsigned long val = strtoul(line, NULL, 10);\n\tif (val <= 100)\n\t\tpatch->score = val;\n\treturn 0;\n}\n\nstatic int gitdiff_index(struct gitdiff_data *state,\n\t\t\t const char *line,\n\t\t\t struct patch *patch)\n{\n\t/*\n\t * index line is N hexadecimal, \"..\", N hexadecimal,\n\t * and optional space with octal mode.\n\t */\n\tconst char *ptr, *eol;\n\tint len;\n\tconst unsigned hexsz = the_hash_algo->hexsz;\n\n\tptr = strchr(line, '.');\n\tif (!ptr || ptr[1] != '.' || hexsz < ptr - line)\n\t\treturn 0;\n\tlen = ptr - line;\n\tmemcpy(patch->old_oid_prefix, line, len);\n\tpatch->old_oid_prefix[len] = 0;\n\n\tline = ptr + 2;\n\tptr = strchr(line, ' ');\n\teol = strchrnul(line, '\\n');\n\n\tif (!ptr || eol < ptr)\n\t\tptr = eol;\n\tlen = ptr - line;\n\n\tif (hexsz < len)\n\t\treturn 0;\n\tmemcpy(patch->new_oid_prefix, line, len);\n\tpatch->new_oid_prefix[len] = 0;\n\tif (*ptr == ' ')\n\t\treturn gitdiff_oldmode(state, ptr + 1, patch);\n\treturn 0;\n}\n\n/*\n * This is normal for a diff that doesn't change anything: we'll fall through\n * into the next diff. Tell the parser to break out.\n */\nstatic int gitdiff_unrecognized(struct gitdiff_data *state,\n\t\t\t\tconst char *line,\n\t\t\t\tstruct patch *patch)\n{\n\treturn 1;\n}\n\n/*\n * Skip p_value leading components from \"line\"; as we do not accept\n * absolute paths, return NULL in that case.\n */\nstatic const char *skip_tree_prefix(int p_value,\n\t\t\t\t    const char *line,\n\t\t\t\t    int llen)\n{\n\tint nslash;\n\tint i;\n\n\tif (!p_value)\n\t\treturn (llen && line[0] == '/') ? NULL : line;\n\n\tnslash = p_value;\n\tfor (i = 0; i < llen; i++) {\n\t\tint ch = line[i];\n\t\tif (ch == '/' && --nslash <= 0)\n\t\t\treturn (i == 0) ? NULL : &line[i + 1];\n\t}\n\treturn NULL;\n}\n\n/*\n * This is to extract the same name that appears on \"diff --git\"\n * line.  We do not find and return anything if it is a rename\n * patch, and it is OK because we will find the name elsewhere.\n * We need to reliably find name only when it is mode-change only,\n * creation or deletion of an empty file.  In any of these cases,\n * both sides are the same name under a/ and b/ respectively.\n */\nstatic char *git_header_name(int p_value,\n\t\t\t     const char *line,\n\t\t\t     int llen)\n{\n\tconst char *name;\n\tconst char *second = NULL;\n\tsize_t len, line_len;\n\n\tline += strlen(\"diff --git \");\n\tllen -= strlen(\"diff --git \");\n\n\tif (*line == '\"') {\n\t\tconst char *cp;\n\t\tstruct strbuf first = STRBUF_INIT;\n\t\tstruct strbuf sp = STRBUF_INIT;\n\n\t\tif (unquote_c_style(&first, line, &second))\n\t\t\tgoto free_and_fail1;\n\n\t\t/* strip the a/b prefix including trailing slash */\n\t\tcp = skip_tree_prefix(p_value, first.buf, first.len);\n\t\tif (!cp)\n\t\t\tgoto free_and_fail1;\n\t\tstrbuf_remove(&first, 0, cp - first.buf);\n\n\t\t/*\n\t\t * second points at one past closing dq of name.\n\t\t * find the second name.\n\t\t */\n\t\twhile ((second < line + llen) && isspace(*second))\n\t\t\tsecond++;\n\n\t\tif (line + llen <= second)\n\t\t\tgoto free_and_fail1;\n\t\tif (*second == '\"') {\n\t\t\tif (unquote_c_style(&sp, second, NULL))\n\t\t\t\tgoto free_and_fail1;\n\t\t\tcp = skip_tree_prefix(p_value, sp.buf, sp.len);\n\t\t\tif (!cp)\n\t\t\t\tgoto free_and_fail1;\n\t\t\t/* They must match, otherwise ignore */\n\t\t\tif (strcmp(cp, first.buf))\n\t\t\t\tgoto free_and_fail1;\n\t\t\tstrbuf_release(&sp);\n\t\t\treturn strbuf_detach(&first, NULL);\n\t\t}\n\n\t\t/* unquoted second */\n\t\tcp = skip_tree_prefix(p_value, second, line + llen - second);\n\t\tif (!cp)\n\t\t\tgoto free_and_fail1;\n\t\tif (line + llen - cp != first.len ||\n\t\t    memcmp(first.buf, cp, first.len))\n\t\t\tgoto free_and_fail1;\n\t\treturn strbuf_detach(&first, NULL);\n\n\tfree_and_fail1:\n\t\tstrbuf_release(&first);\n\t\tstrbuf_release(&sp);\n\t\treturn NULL;\n\t}\n\n\t/* unquoted first name */\n\tname = skip_tree_prefix(p_value, line, llen);\n\tif (!name)\n\t\treturn NULL;\n\n\t/*\n\t * since the first name is unquoted, a dq if exists must be\n\t * the beginning of the second name.\n\t */\n\tfor (second = name; second < line + llen; second++) {\n\t\tif (*second == '\"') {\n\t\t\tstruct strbuf sp = STRBUF_INIT;\n\t\t\tconst char *np;\n\n\t\t\tif (unquote_c_style(&sp, second, NULL))\n\t\t\t\tgoto free_and_fail2;\n\n\t\t\tnp = skip_tree_prefix(p_value, sp.buf, sp.len);\n\t\t\tif (!np)\n\t\t\t\tgoto free_and_fail2;\n\n\t\t\tlen = sp.buf + sp.len - np;\n\t\t\tif (len < second - name &&\n\t\t\t    !strncmp(np, name, len) &&\n\t\t\t    isspace(name[len])) {\n\t\t\t\t/* Good */\n\t\t\t\tstrbuf_remove(&sp, 0, np - sp.buf);\n\t\t\t\treturn strbuf_detach(&sp, NULL);\n\t\t\t}\n\n\t\tfree_and_fail2:\n\t\t\tstrbuf_release(&sp);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t/*\n\t * Accept a name only if it shows up twice, exactly the same\n\t * form.\n\t */\n\tsecond = strchr(name, '\\n');\n\tif (!second)\n\t\treturn NULL;\n\tline_len = second - name;\n\tfor (len = 0 ; ; len++) {\n\t\tswitch (name[len]) {\n\t\tdefault:\n\t\t\tcontinue;\n\t\tcase '\\n':\n\t\t\treturn NULL;\n\t\tcase '\\t': case ' ':\n\t\t\t/*\n\t\t\t * Is this the separator between the preimage\n\t\t\t * and the postimage pathname?  Again, we are\n\t\t\t * only interested in the case where there is\n\t\t\t * no rename, as this is only to set def_name\n\t\t\t * and a rename patch has the names elsewhere\n\t\t\t * in an unambiguous form.\n\t\t\t */\n\t\t\tif (!name[len + 1])\n\t\t\t\treturn NULL; /* no postimage name */\n\t\t\tsecond = skip_tree_prefix(p_value, name + len + 1,\n\t\t\t\t\t\t  line_len - (len + 1));\n\t\t\tif (!second)\n\t\t\t\treturn NULL;\n\t\t\t/*\n\t\t\t * Does len bytes starting at \"name\" and \"second\"\n\t\t\t * (that are separated by one HT or SP we just\n\t\t\t * found) exactly match?\n\t\t\t */\n\t\t\tif (second[len] == '\\n' && !strncmp(name, second, len))\n\t\t\t\treturn xmemdupz(name, len);\n\t\t}\n\t}\n}\n\nstatic int check_header_line(int linenr, struct patch *patch)\n{\n\tint extensions = (patch->is_delete == 1) + (patch->is_new == 1) +\n\t\t\t (patch->is_rename == 1) + (patch->is_copy == 1);\n\tif (extensions > 1)\n\t\treturn error(_(\"inconsistent header lines %d and %d\"),\n\t\t\t     patch->extension_linenr, linenr);\n\tif (extensions && !patch->extension_linenr)\n\t\tpatch->extension_linenr = linenr;\n\treturn 0;\n}\n\nint parse_git_diff_header(struct strbuf *root,\n\t\t\t  int *linenr,\n\t\t\t  int p_value,\n\t\t\t  const char *line,\n\t\t\t  int len,\n\t\t\t  unsigned int size,\n\t\t\t  struct patch *patch)\n{\n\tunsigned long offset;\n\tstruct gitdiff_data parse_hdr_state;\n\n\t/* A git diff has explicit new/delete information, so we don't guess */\n\tpatch->is_new = 0;\n\tpatch->is_delete = 0;\n\n\t/*\n\t * Some things may not have the old name in the\n\t * rest of the headers anywhere (pure mode changes,\n\t * or removing or adding empty files), so we get\n\t * the default name from the header.\n\t */\n\tpatch->def_name = git_header_name(p_value, line, len);\n\tif (patch->def_name && root->len) {\n\t\tchar *s = xstrfmt(\"%s%s\", root->buf, patch->def_name);\n\t\tfree(patch->def_name);\n\t\tpatch->def_name = s;\n\t}\n\n\tline += len;\n\tsize -= len;\n\t(*linenr)++;\n\tparse_hdr_state.root = root;\n\tparse_hdr_state.linenr = *linenr;\n\tparse_hdr_state.p_value = p_value;\n\n\tfor (offset = len ; size > 0 ; offset += len, size -= len, line += len, (*linenr)++) {\n\t\tstatic const struct opentry {\n\t\t\tconst char *str;\n\t\t\tint (*fn)(struct gitdiff_data *, const char *, struct patch *);\n\t\t} optable[] = {\n\t\t\t{ \"@@ -\", gitdiff_hdrend },\n\t\t\t{ \"--- \", gitdiff_oldname },\n\t\t\t{ \"+++ \", gitdiff_newname },\n\t\t\t{ \"old mode \", gitdiff_oldmode },\n\t\t\t{ \"new mode \", gitdiff_newmode },\n\t\t\t{ \"deleted file mode \", gitdiff_delete },\n\t\t\t{ \"new file mode \", gitdiff_newfile },\n\t\t\t{ \"copy from \", gitdiff_copysrc },\n\t\t\t{ \"copy to \", gitdiff_copydst },\n\t\t\t{ \"rename old \", gitdiff_renamesrc },\n\t\t\t{ \"rename new \", gitdiff_renamedst },\n\t\t\t{ \"rename from \", gitdiff_renamesrc },\n\t\t\t{ \"rename to \", gitdiff_renamedst },\n\t\t\t{ \"similarity index \", gitdiff_similarity },\n\t\t\t{ \"dissimilarity index \", gitdiff_dissimilarity },\n\t\t\t{ \"index \", gitdiff_index },\n\t\t\t{ \"\", gitdiff_unrecognized },\n\t\t};\n\t\tint i;\n\n\t\tlen = linelen(line, size);\n\t\tif (!len || line[len-1] != '\\n')\n\t\t\tbreak;\n\t\tfor (i = 0; i < ARRAY_SIZE(optable); i++) {\n\t\t\tconst struct opentry *p = optable + i;\n\t\t\tint oplen = strlen(p->str);\n\t\t\tint res;\n\t\t\tif (len < oplen || memcmp(p->str, line, oplen))\n\t\t\t\tcontinue;\n\t\t\tres = p->fn(&parse_hdr_state, line + oplen, patch);\n\t\t\tif (res < 0)\n\t\t\t\treturn -1;\n\t\t\tif (check_header_line(*linenr, patch))\n\t\t\t\treturn -1;\n\t\t\tif (res > 0)\n\t\t\t\tgoto done;\n\t\t\tbreak;\n\t\t}\n\t}\n\ndone:\n\tif (!patch->old_name && !patch->new_name) {\n\t\tif (!patch->def_name) {\n\t\t\terror(Q_(\"git diff header lacks filename information when removing \"\n\t\t\t\t \"%d leading pathname component (line %d)\",\n\t\t\t\t \"git diff header lacks filename information when removing \"\n\t\t\t\t \"%d leading pathname components (line %d)\",\n\t\t\t\t parse_hdr_state.p_value),\n\t\t\t      parse_hdr_state.p_value, *linenr);\n\t\t\treturn -128;\n\t\t}\n\t\tpatch->old_name = xstrdup(patch->def_name);\n\t\tpatch->new_name = xstrdup(patch->def_name);\n\t}\n\tif ((!patch->new_name && !patch->is_delete) ||\n\t    (!patch->old_name && !patch->is_new)) {\n\t\terror(_(\"git diff header lacks filename information \"\n\t\t\t\"(line %d)\"), *linenr);\n\t\treturn -128;\n\t}\n\tpatch->is_toplevel_relative = 1;\n\treturn offset;\n}\n\nstatic int parse_num(const char *line, unsigned long *p)\n{\n\tchar *ptr;\n\n\tif (!isdigit(*line))\n\t\treturn 0;\n\t*p = strtoul(line, &ptr, 10);\n\treturn ptr - line;\n}\n\nstatic int parse_range(const char *line, int len, int offset, const char *expect,\n\t\t       unsigned long *p1, unsigned long *p2)\n{\n\tint digits, ex;\n\n\tif (offset < 0 || offset >= len)\n\t\treturn -1;\n\tline += offset;\n\tlen -= offset;\n\n\tdigits = parse_num(line, p1);\n\tif (!digits)\n\t\treturn -1;\n\n\toffset += digits;\n\tline += digits;\n\tlen -= digits;\n\n\t*p2 = 1;\n\tif (*line == ',') {\n\t\tdigits = parse_num(line+1, p2);\n\t\tif (!digits)\n\t\t\treturn -1;\n\n\t\toffset += digits+1;\n\t\tline += digits+1;\n\t\tlen -= digits+1;\n\t}\n\n\tex = strlen(expect);\n\tif (ex > len)\n\t\treturn -1;\n\tif (memcmp(line, expect, ex))\n\t\treturn -1;\n\n\treturn offset + ex;\n}\n\nstatic void recount_diff(const char *line, int size, struct fragment *fragment)\n{\n\tint oldlines = 0, newlines = 0, ret = 0;\n\n\tif (size < 1) {\n\t\twarning(\"recount: ignore empty hunk\");\n\t\treturn;\n\t}\n\n\tfor (;;) {\n\t\tint len = linelen(line, size);\n\t\tsize -= len;\n\t\tline += len;\n\n\t\tif (size < 1)\n\t\t\tbreak;\n\n\t\tswitch (*line) {\n\t\tcase ' ': case '\\n':\n\t\t\tnewlines++;\n\t\t\t/* fall through */\n\t\tcase '-':\n\t\t\toldlines++;\n\t\t\tcontinue;\n\t\tcase '+':\n\t\t\tnewlines++;\n\t\t\tcontinue;\n\t\tcase '\\\\':\n\t\t\tcontinue;\n\t\tcase '@':\n\t\t\tret = size < 3 || !starts_with(line, \"@@ \");\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tret = size < 5 || !starts_with(line, \"diff \");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\t\tif (ret) {\n\t\t\twarning(_(\"recount: unexpected line: %.*s\"),\n\t\t\t\t(int)linelen(line, size), line);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\t}\n\tfragment->oldlines = oldlines;\n\tfragment->newlines = newlines;\n}\n\n/*\n * Parse a unified diff fragment header of the\n * form \"@@ -a,b +c,d @@\"\n */\nstatic int parse_fragment_header(const char *line, int len, struct fragment *fragment)\n{\n\tint offset;\n\n\tif (!len || line[len-1] != '\\n')\n\t\treturn -1;\n\n\t/* Figure out the number of lines in a fragment */\n\toffset = parse_range(line, len, 4, \" +\", &fragment->oldpos, &fragment->oldlines);\n\toffset = parse_range(line, len, offset, \" @@\", &fragment->newpos, &fragment->newlines);\n\n\treturn offset;\n}\n\n/*\n * Find file diff header\n *\n * Returns:\n *  -1 if no header was found\n *  -128 in case of error\n *   the size of the header in bytes (called \"offset\") otherwise\n */\nstatic int find_header(struct apply_state *state,\n\t\t       const char *line,\n\t\t       unsigned long size,\n\t\t       int *hdrsize,\n\t\t       struct patch *patch)\n{\n\tunsigned long offset, len;\n\n\tpatch->is_toplevel_relative = 0;\n\tpatch->is_rename = patch->is_copy = 0;\n\tpatch->is_new = patch->is_delete = -1;\n\tpatch->old_mode = patch->new_mode = 0;\n\tpatch->old_name = patch->new_name = NULL;\n\tfor (offset = 0; size > 0; offset += len, size -= len, line += len, state->linenr++) {\n\t\tunsigned long nextlen;\n\n\t\tlen = linelen(line, size);\n\t\tif (!len)\n\t\t\tbreak;\n\n\t\t/* Testing this early allows us to take a few shortcuts.. */\n\t\tif (len < 6)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Make sure we don't find any unconnected patch fragments.\n\t\t * That's a sign that we didn't find a header, and that a\n\t\t * patch has become corrupted/broken up.\n\t\t */\n\t\tif (!memcmp(\"@@ -\", line, 4)) {\n\t\t\tstruct fragment dummy;\n\t\t\tif (parse_fragment_header(line, len, &dummy) < 0)\n\t\t\t\tcontinue;\n\t\t\terror(_(\"patch fragment without header at line %d: %.*s\"),\n\t\t\t\t     state->linenr, (int)len-1, line);\n\t\t\treturn -128;\n\t\t}\n\n\t\tif (size < len + 6)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Git patch? It might not have a real patch, just a rename\n\t\t * or mode change, so we handle that specially\n\t\t */\n\t\tif (!memcmp(\"diff --git \", line, 11)) {\n\t\t\tint git_hdr_len = parse_git_diff_header(&state->root, &state->linenr,\n\t\t\t\t\t\t\t\tstate->p_value, line, len,\n\t\t\t\t\t\t\t\tsize, patch);\n\t\t\tif (git_hdr_len < 0)\n\t\t\t\treturn -128;\n\t\t\tif (git_hdr_len <= len)\n\t\t\t\tcontinue;\n\t\t\t*hdrsize = git_hdr_len;\n\t\t\treturn offset;\n\t\t}\n\n\t\t/* --- followed by +++ ? */\n\t\tif (memcmp(\"--- \", line,  4) || memcmp(\"+++ \", line + len, 4))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We only accept unified patches, so we want it to\n\t\t * at least have \"@@ -a,b +c,d @@\\n\", which is 14 chars\n\t\t * minimum (\"@@ -0,0 +1 @@\\n\" is the shortest).\n\t\t */\n\t\tnextlen = linelen(line + len, size - len);\n\t\tif (size < nextlen + 14 || memcmp(\"@@ -\", line + len + nextlen, 4))\n\t\t\tcontinue;\n\n\t\t/* Ok, we'll consider it a patch */\n\t\tif (parse_traditional_patch(state, line, line+len, patch))\n\t\t\treturn -128;\n\t\t*hdrsize = len + nextlen;\n\t\tstate->linenr += 2;\n\t\treturn offset;\n\t}\n\treturn -1;\n}\n\nstatic void record_ws_error(struct apply_state *state,\n\t\t\t    unsigned result,\n\t\t\t    const char *line,\n\t\t\t    int len,\n\t\t\t    int linenr)\n{\n\tchar *err;\n\n\tif (!result)\n\t\treturn;\n\n\tstate->whitespace_error++;\n\tif (state->squelch_whitespace_errors &&\n\t    state->squelch_whitespace_errors < state->whitespace_error)\n\t\treturn;\n\n\terr = whitespace_error_string(result);\n\tif (state->apply_verbosity > verbosity_silent)\n\t\tfprintf(stderr, \"%s:%d: %s.\\n%.*s\\n\",\n\t\t\tstate->patch_input_file, linenr, err, len, line);\n\tfree(err);\n}\n\nstatic void check_whitespace(struct apply_state *state,\n\t\t\t     const char *line,\n\t\t\t     int len,\n\t\t\t     unsigned ws_rule)\n{\n\tunsigned result = ws_check(line + 1, len - 1, ws_rule);\n\n\trecord_ws_error(state, result, line + 1, len - 2, state->linenr);\n}\n\n/*\n * Check if the patch has context lines with CRLF or\n * the patch wants to remove lines with CRLF.\n */\nstatic void check_old_for_crlf(struct patch *patch, const char *line, int len)\n{\n\tif (len >= 2 && line[len-1] == '\\n' && line[len-2] == '\\r') {\n\t\tpatch->ws_rule |= WS_CR_AT_EOL;\n\t\tpatch->crlf_in_old = 1;\n\t}\n}\n\n\n/*\n * Parse a unified diff. Note that this really needs to parse each\n * fragment separately, since the only way to know the difference\n * between a \"---\" that is part of a patch, and a \"---\" that starts\n * the next patch is to look at the line counts..\n */\nstatic int parse_fragment(struct apply_state *state,\n\t\t\t  const char *line,\n\t\t\t  unsigned long size,\n\t\t\t  struct patch *patch,\n\t\t\t  struct fragment *fragment)\n{\n\tint added, deleted;\n\tint len = linelen(line, size), offset;\n\tunsigned long oldlines, newlines;\n\tunsigned long leading, trailing;\n\n\toffset = parse_fragment_header(line, len, fragment);\n\tif (offset < 0)\n\t\treturn -1;\n\tif (offset > 0 && patch->recount)\n\t\trecount_diff(line + offset, size - offset, fragment);\n\toldlines = fragment->oldlines;\n\tnewlines = fragment->newlines;\n\tleading = 0;\n\ttrailing = 0;\n\n\t/* Parse the thing.. */\n\tline += len;\n\tsize -= len;\n\tstate->linenr++;\n\tadded = deleted = 0;\n\tfor (offset = len;\n\t     0 < size;\n\t     offset += len, size -= len, line += len, state->linenr++) {\n\t\tif (!oldlines && !newlines)\n\t\t\tbreak;\n\t\tlen = linelen(line, size);\n\t\tif (!len || line[len-1] != '\\n')\n\t\t\treturn -1;\n\t\tswitch (*line) {\n\t\tdefault:\n\t\t\treturn -1;\n\t\tcase '\\n': /* newer GNU diff, an empty context line */\n\t\tcase ' ':\n\t\t\toldlines--;\n\t\t\tnewlines--;\n\t\t\tif (!deleted && !added)\n\t\t\t\tleading++;\n\t\t\ttrailing++;\n\t\t\tcheck_old_for_crlf(patch, line, len);\n\t\t\tif (!state->apply_in_reverse &&\n\t\t\t    state->ws_error_action == correct_ws_error)\n\t\t\t\tcheck_whitespace(state, line, len, patch->ws_rule);\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\tif (!state->apply_in_reverse)\n\t\t\t\tcheck_old_for_crlf(patch, line, len);\n\t\t\tif (state->apply_in_reverse &&\n\t\t\t    state->ws_error_action != nowarn_ws_error)\n\t\t\t\tcheck_whitespace(state, line, len, patch->ws_rule);\n\t\t\tdeleted++;\n\t\t\toldlines--;\n\t\t\ttrailing = 0;\n\t\t\tbreak;\n\t\tcase '+':\n\t\t\tif (state->apply_in_reverse)\n\t\t\t\tcheck_old_for_crlf(patch, line, len);\n\t\t\tif (!state->apply_in_reverse &&\n\t\t\t    state->ws_error_action != nowarn_ws_error)\n\t\t\t\tcheck_whitespace(state, line, len, patch->ws_rule);\n\t\t\tadded++;\n\t\t\tnewlines--;\n\t\t\ttrailing = 0;\n\t\t\tbreak;\n\n\t\t/*\n\t\t * We allow \"\\ No newline at end of file\". Depending\n\t\t * on locale settings when the patch was produced we\n\t\t * don't know what this line looks like. The only\n\t\t * thing we do know is that it begins with \"\\ \".\n\t\t * Checking for 12 is just for sanity check -- any\n\t\t * l10n of \"\\ No newline...\" is at least that long.\n\t\t */\n\t\tcase '\\\\':\n\t\t\tif (len < 12 || memcmp(line, \"\\\\ \", 2))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (oldlines || newlines)\n\t\treturn -1;\n\tif (!patch->recount && !deleted && !added)\n\t\treturn -1;\n\n\tfragment->leading = leading;\n\tfragment->trailing = trailing;\n\n\t/*\n\t * If a fragment ends with an incomplete line, we failed to include\n\t * it in the above loop because we hit oldlines == newlines == 0\n\t * before seeing it.\n\t */\n\tif (12 < size && !memcmp(line, \"\\\\ \", 2))\n\t\toffset += linelen(line, size);\n\n\tpatch->lines_added += added;\n\tpatch->lines_deleted += deleted;\n\n\tif (0 < patch->is_new && oldlines)\n\t\treturn error(_(\"new file depends on old contents\"));\n\tif (0 < patch->is_delete && newlines)\n\t\treturn error(_(\"deleted file still has contents\"));\n\treturn offset;\n}\n\n/*\n * We have seen \"diff --git a/... b/...\" header (or a traditional patch\n * header).  Read hunks that belong to this patch into fragments and hang\n * them to the given patch structure.\n *\n * The (fragment->patch, fragment->size) pair points into the memory given\n * by the caller, not a copy, when we return.\n *\n * Returns:\n *   -1 in case of error,\n *   the number of bytes in the patch otherwise.\n */\nstatic int parse_single_patch(struct apply_state *state,\n\t\t\t      const char *line,\n\t\t\t      unsigned long size,\n\t\t\t      struct patch *patch)\n{\n\tunsigned long offset = 0;\n\tunsigned long oldlines = 0, newlines = 0, context = 0;\n\tstruct fragment **fragp = &patch->fragments;\n\n\twhile (size > 4 && !memcmp(line, \"@@ -\", 4)) {\n\t\tstruct fragment *fragment;\n\t\tint len;\n\n\t\tfragment = xcalloc(1, sizeof(*fragment));\n\t\tfragment->linenr = state->linenr;\n\t\tlen = parse_fragment(state, line, size, patch, fragment);\n\t\tif (len <= 0) {\n\t\t\tfree(fragment);\n\t\t\treturn error(_(\"corrupt patch at line %d\"), state->linenr);\n\t\t}\n\t\tfragment->patch = line;\n\t\tfragment->size = len;\n\t\toldlines += fragment->oldlines;\n\t\tnewlines += fragment->newlines;\n\t\tcontext += fragment->leading + fragment->trailing;\n\n\t\t*fragp = fragment;\n\t\tfragp = &fragment->next;\n\n\t\toffset += len;\n\t\tline += len;\n\t\tsize -= len;\n\t}\n\n\t/*\n\t * If something was removed (i.e. we have old-lines) it cannot\n\t * be creation, and if something was added it cannot be\n\t * deletion.  However, the reverse is not true; --unified=0\n\t * patches that only add are not necessarily creation even\n\t * though they do not have any old lines, and ones that only\n\t * delete are not necessarily deletion.\n\t *\n\t * Unfortunately, a real creation/deletion patch do _not_ have\n\t * any context line by definition, so we cannot safely tell it\n\t * apart with --unified=0 insanity.  At least if the patch has\n\t * more than one hunk it is not creation or deletion.\n\t */\n\tif (patch->is_new < 0 &&\n\t    (oldlines || (patch->fragments && patch->fragments->next)))\n\t\tpatch->is_new = 0;\n\tif (patch->is_delete < 0 &&\n\t    (newlines || (patch->fragments && patch->fragments->next)))\n\t\tpatch->is_delete = 0;\n\n\tif (0 < patch->is_new && oldlines)\n\t\treturn error(_(\"new file %s depends on old contents\"), patch->new_name);\n\tif (0 < patch->is_delete && newlines)\n\t\treturn error(_(\"deleted file %s still has contents\"), patch->old_name);\n\tif (!patch->is_delete && !newlines && context && state->apply_verbosity > verbosity_silent)\n\t\tfprintf_ln(stderr,\n\t\t\t   _(\"** warning: \"\n\t\t\t     \"file %s becomes empty but is not deleted\"),\n\t\t\t   patch->new_name);\n\n\treturn offset;\n}\n\nstatic inline int metadata_changes(struct patch *patch)\n{\n\treturn\tpatch->is_rename > 0 ||\n\t\tpatch->is_copy > 0 ||\n\t\tpatch->is_new > 0 ||\n\t\tpatch->is_delete ||\n\t\t(patch->old_mode && patch->new_mode &&\n\t\t patch->old_mode != patch->new_mode);\n}\n\nstatic char *inflate_it(const void *data, unsigned long size,\n\t\t\tunsigned long inflated_size)\n{\n\tgit_zstream stream;\n\tvoid *out;\n\tint st;\n\n\tmemset(&stream, 0, sizeof(stream));\n\n\tstream.next_in = (unsigned char *)data;\n\tstream.avail_in = size;\n\tstream.next_out = out = xmalloc(inflated_size);\n\tstream.avail_out = inflated_size;\n\tgit_inflate_init(&stream);\n\tst = git_inflate(&stream, Z_FINISH);\n\tgit_inflate_end(&stream);\n\tif ((st != Z_STREAM_END) || stream.total_out != inflated_size) {\n\t\tfree(out);\n\t\treturn NULL;\n\t}\n\treturn out;\n}\n\n/*\n * Read a binary hunk and return a new fragment; fragment->patch\n * points at an allocated memory that the caller must free, so\n * it is marked as \"->free_patch = 1\".\n */\nstatic struct fragment *parse_binary_hunk(struct apply_state *state,\n\t\t\t\t\t  char **buf_p,\n\t\t\t\t\t  unsigned long *sz_p,\n\t\t\t\t\t  int *status_p,\n\t\t\t\t\t  int *used_p)\n{\n\t/*\n\t * Expect a line that begins with binary patch method (\"literal\"\n\t * or \"delta\"), followed by the length of data before deflating.\n\t * a sequence of 'length-byte' followed by base-85 encoded data\n\t * should follow, terminated by a newline.\n\t *\n\t * Each 5-byte sequence of base-85 encodes up to 4 bytes,\n\t * and we would limit the patch line to 66 characters,\n\t * so one line can fit up to 13 groups that would decode\n\t * to 52 bytes max.  The length byte 'A'-'Z' corresponds\n\t * to 1-26 bytes, and 'a'-'z' corresponds to 27-52 bytes.\n\t */\n\tint llen, used;\n\tunsigned long size = *sz_p;\n\tchar *buffer = *buf_p;\n\tint patch_method;\n\tunsigned long origlen;\n\tchar *data = NULL;\n\tint hunk_size = 0;\n\tstruct fragment *frag;\n\n\tllen = linelen(buffer, size);\n\tused = llen;\n\n\t*status_p = 0;\n\n\tif (starts_with(buffer, \"delta \")) {\n\t\tpatch_method = BINARY_DELTA_DEFLATED;\n\t\toriglen = strtoul(buffer + 6, NULL, 10);\n\t}\n\telse if (starts_with(buffer, \"literal \")) {\n\t\tpatch_method = BINARY_LITERAL_DEFLATED;\n\t\toriglen = strtoul(buffer + 8, NULL, 10);\n\t}\n\telse\n\t\treturn NULL;\n\n\tstate->linenr++;\n\tbuffer += llen;\n\twhile (1) {\n\t\tint byte_length, max_byte_length, newsize;\n\t\tllen = linelen(buffer, size);\n\t\tused += llen;\n\t\tstate->linenr++;\n\t\tif (llen == 1) {\n\t\t\t/* consume the blank line */\n\t\t\tbuffer++;\n\t\t\tsize--;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Minimum line is \"A00000\\n\" which is 7-byte long,\n\t\t * and the line length must be multiple of 5 plus 2.\n\t\t */\n\t\tif ((llen < 7) || (llen-2) % 5)\n\t\t\tgoto corrupt;\n\t\tmax_byte_length = (llen - 2) / 5 * 4;\n\t\tbyte_length = *buffer;\n\t\tif ('A' <= byte_length && byte_length <= 'Z')\n\t\t\tbyte_length = byte_length - 'A' + 1;\n\t\telse if ('a' <= byte_length && byte_length <= 'z')\n\t\t\tbyte_length = byte_length - 'a' + 27;\n\t\telse\n\t\t\tgoto corrupt;\n\t\t/* if the input length was not multiple of 4, we would\n\t\t * have filler at the end but the filler should never\n\t\t * exceed 3 bytes\n\t\t */\n\t\tif (max_byte_length < byte_length ||\n\t\t    byte_length <= max_byte_length - 4)\n\t\t\tgoto corrupt;\n\t\tnewsize = hunk_size + byte_length;\n\t\tdata = xrealloc(data, newsize);\n\t\tif (decode_85(data + hunk_size, buffer + 1, byte_length))\n\t\t\tgoto corrupt;\n\t\thunk_size = newsize;\n\t\tbuffer += llen;\n\t\tsize -= llen;\n\t}\n\n\tfrag = xcalloc(1, sizeof(*frag));\n\tfrag->patch = inflate_it(data, hunk_size, origlen);\n\tfrag->free_patch = 1;\n\tif (!frag->patch)\n\t\tgoto corrupt;\n\tfree(data);\n\tfrag->size = origlen;\n\t*buf_p = buffer;\n\t*sz_p = size;\n\t*used_p = used;\n\tfrag->binary_patch_method = patch_method;\n\treturn frag;\n\n corrupt:\n\tfree(data);\n\t*status_p = -1;\n\terror(_(\"corrupt binary patch at line %d: %.*s\"),\n\t      state->linenr-1, llen-1, buffer);\n\treturn NULL;\n}\n\n/*\n * Returns:\n *   -1 in case of error,\n *   the length of the parsed binary patch otherwise\n */\nstatic int parse_binary(struct apply_state *state,\n\t\t\tchar *buffer,\n\t\t\tunsigned long size,\n\t\t\tstruct patch *patch)\n{\n\t/*\n\t * We have read \"GIT binary patch\\n\"; what follows is a line\n\t * that says the patch method (currently, either \"literal\" or\n\t * \"delta\") and the length of data before deflating; a\n\t * sequence of 'length-byte' followed by base-85 encoded data\n\t * follows.\n\t *\n\t * When a binary patch is reversible, there is another binary\n\t * hunk in the same format, starting with patch method (either\n\t * \"literal\" or \"delta\") with the length of data, and a sequence\n\t * of length-byte + base-85 encoded data, terminated with another\n\t * empty line.  This data, when applied to the postimage, produces\n\t * the preimage.\n\t */\n\tstruct fragment *forward;\n\tstruct fragment *reverse;\n\tint status;\n\tint used, used_1;\n\n\tforward = parse_binary_hunk(state, &buffer, &size, &status, &used);\n\tif (!forward && !status)\n\t\t/* there has to be one hunk (forward hunk) */\n\t\treturn error(_(\"unrecognized binary patch at line %d\"), state->linenr-1);\n\tif (status)\n\t\t/* otherwise we already gave an error message */\n\t\treturn status;\n\n\treverse = parse_binary_hunk(state, &buffer, &size, &status, &used_1);\n\tif (reverse)\n\t\tused += used_1;\n\telse if (status) {\n\t\t/*\n\t\t * Not having reverse hunk is not an error, but having\n\t\t * a corrupt reverse hunk is.\n\t\t */\n\t\tfree((void*) forward->patch);\n\t\tfree(forward);\n\t\treturn status;\n\t}\n\tforward->next = reverse;\n\tpatch->fragments = forward;\n\tpatch->is_binary = 1;\n\treturn used;\n}\n\nstatic void prefix_one(struct apply_state *state, char **name)\n{\n\tchar *old_name = *name;\n\tif (!old_name)\n\t\treturn;\n\t*name = prefix_filename(state->prefix, *name);\n\tfree(old_name);\n}\n\nstatic void prefix_patch(struct apply_state *state, struct patch *p)\n{\n\tif (!state->prefix || p->is_toplevel_relative)\n\t\treturn;\n\tprefix_one(state, &p->new_name);\n\tprefix_one(state, &p->old_name);\n}\n\n/*\n * include/exclude\n */\n\nstatic void add_name_limit(struct apply_state *state,\n\t\t\t   const char *name,\n\t\t\t   int exclude)\n{\n\tstruct string_list_item *it;\n\n\tit = string_list_append(&state->limit_by_name, name);\n\tit->util = exclude ? NULL : (void *) 1;\n}\n\nstatic int use_patch(struct apply_state *state, struct patch *p)\n{\n\tconst char *pathname = p->new_name ? p->new_name : p->old_name;\n\tint i;\n\n\t/* Paths outside are not touched regardless of \"--include\" */\n\tif (state->prefix && *state->prefix) {\n\t\tconst char *rest;\n\t\tif (!skip_prefix(pathname, state->prefix, &rest) || !*rest)\n\t\t\treturn 0;\n\t}\n\n\t/* See if it matches any of exclude/include rule */\n\tfor (i = 0; i < state->limit_by_name.nr; i++) {\n\t\tstruct string_list_item *it = &state->limit_by_name.items[i];\n\t\tif (!wildmatch(it->string, pathname, 0))\n\t\t\treturn (it->util != NULL);\n\t}\n\n\t/*\n\t * If we had any include, a path that does not match any rule is\n\t * not used.  Otherwise, we saw bunch of exclude rules (or none)\n\t * and such a path is used.\n\t */\n\treturn !state->has_include;\n}\n\n/*\n * Read the patch text in \"buffer\" that extends for \"size\" bytes; stop\n * reading after seeing a single patch (i.e. changes to a single file).\n * Create fragments (i.e. patch hunks) and hang them to the given patch.\n *\n * Returns:\n *   -1 if no header was found or parse_binary() failed,\n *   -128 on another error,\n *   the number of bytes consumed otherwise,\n *     so that the caller can call us again for the next patch.\n */\nstatic int parse_chunk(struct apply_state *state, char *buffer, unsigned long size, struct patch *patch)\n{\n\tint hdrsize, patchsize;\n\tint offset = find_header(state, buffer, size, &hdrsize, patch);\n\n\tif (offset < 0)\n\t\treturn offset;\n\n\tprefix_patch(state, patch);\n\n\tif (!use_patch(state, patch))\n\t\tpatch->ws_rule = 0;\n\telse if (patch->new_name)\n\t\tpatch->ws_rule = whitespace_rule(state->repo->index,\n\t\t\t\t\t\t patch->new_name);\n\telse\n\t\tpatch->ws_rule = whitespace_rule(state->repo->index,\n\t\t\t\t\t\t patch->old_name);\n\n\tpatchsize = parse_single_patch(state,\n\t\t\t\t       buffer + offset + hdrsize,\n\t\t\t\t       size - offset - hdrsize,\n\t\t\t\t       patch);\n\n\tif (patchsize < 0)\n\t\treturn -128;\n\n\tif (!patchsize) {\n\t\tstatic const char git_binary[] = \"GIT binary patch\\n\";\n\t\tint hd = hdrsize + offset;\n\t\tunsigned long llen = linelen(buffer + hd, size - hd);\n\n\t\tif (llen == sizeof(git_binary) - 1 &&\n\t\t    !memcmp(git_binary, buffer + hd, llen)) {\n\t\t\tint used;\n\t\t\tstate->linenr++;\n\t\t\tused = parse_binary(state, buffer + hd + llen,\n\t\t\t\t\t    size - hd - llen, patch);\n\t\t\tif (used < 0)\n\t\t\t\treturn -1;\n\t\t\tif (used)\n\t\t\t\tpatchsize = used + llen;\n\t\t\telse\n\t\t\t\tpatchsize = 0;\n\t\t}\n\t\telse if (!memcmp(\" differ\\n\", buffer + hd + llen - 8, 8)) {\n\t\t\tstatic const char *binhdr[] = {\n\t\t\t\t\"Binary files \",\n\t\t\t\t\"Files \",\n\t\t\t\tNULL,\n\t\t\t};\n\t\t\tint i;\n\t\t\tfor (i = 0; binhdr[i]; i++) {\n\t\t\t\tint len = strlen(binhdr[i]);\n\t\t\t\tif (len < size - hd &&\n\t\t\t\t    !memcmp(binhdr[i], buffer + hd, len)) {\n\t\t\t\t\tstate->linenr++;\n\t\t\t\t\tpatch->is_binary = 1;\n\t\t\t\t\tpatchsize = llen;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Empty patch cannot be applied if it is a text patch\n\t\t * without metadata change.  A binary patch appears\n\t\t * empty to us here.\n\t\t */\n\t\tif ((state->apply || state->check) &&\n\t\t    (!patch->is_binary && !metadata_changes(patch))) {\n\t\t\terror(_(\"patch with only garbage at line %d\"), state->linenr);\n\t\t\treturn -128;\n\t\t}\n\t}\n\n\treturn offset + hdrsize + patchsize;\n}\n\nstatic void reverse_patches(struct patch *p)\n{\n\tfor (; p; p = p->next) {\n\t\tstruct fragment *frag = p->fragments;\n\n\t\tSWAP(p->new_name, p->old_name);\n\t\tSWAP(p->new_mode, p->old_mode);\n\t\tSWAP(p->is_new, p->is_delete);\n\t\tSWAP(p->lines_added, p->lines_deleted);\n\t\tSWAP(p->old_oid_prefix, p->new_oid_prefix);\n\n\t\tfor (; frag; frag = frag->next) {\n\t\t\tSWAP(frag->newpos, frag->oldpos);\n\t\t\tSWAP(frag->newlines, frag->oldlines);\n\t\t}\n\t}\n}\n\nstatic const char pluses[] =\n\"++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\";\nstatic const char minuses[]=\n\"----------------------------------------------------------------------\";\n\nstatic void show_stats(struct apply_state *state, struct patch *patch)\n{\n\tstruct strbuf qname = STRBUF_INIT;\n\tchar *cp = patch->new_name ? patch->new_name : patch->old_name;\n\tint max, add, del;\n\n\tquote_c_style(cp, &qname, NULL, 0);\n\n\t/*\n\t * \"scale\" the filename\n\t */\n\tmax = state->max_len;\n\tif (max > 50)\n\t\tmax = 50;\n\n\tif (qname.len > max) {\n\t\tcp = strchr(qname.buf + qname.len + 3 - max, '/');\n\t\tif (!cp)\n\t\t\tcp = qname.buf + qname.len + 3 - max;\n\t\tstrbuf_splice(&qname, 0, cp - qname.buf, \"...\", 3);\n\t}\n\n\tif (patch->is_binary) {\n\t\tprintf(\" %-*s |  Bin\\n\", max, qname.buf);\n\t\tstrbuf_release(&qname);\n\t\treturn;\n\t}\n\n\tprintf(\" %-*s |\", max, qname.buf);\n\tstrbuf_release(&qname);\n\n\t/*\n\t * scale the add/delete\n\t */\n\tmax = max + state->max_change > 70 ? 70 - max : state->max_change;\n\tadd = patch->lines_added;\n\tdel = patch->lines_deleted;\n\n\tif (state->max_change > 0) {\n\t\tint total = ((add + del) * max + state->max_change / 2) / state->max_change;\n\t\tadd = (add * max + state->max_change / 2) / state->max_change;\n\t\tdel = total - add;\n\t}\n\tprintf(\"%5d %.*s%.*s\\n\", patch->lines_added + patch->lines_deleted,\n\t\tadd, pluses, del, minuses);\n}\n\nstatic int read_old_data(struct stat *st, struct patch *patch,\n\t\t\t const char *path, struct strbuf *buf)\n{\n\tint conv_flags = patch->crlf_in_old ?\n\t\tCONV_EOL_KEEP_CRLF : CONV_EOL_RENORMALIZE;\n\tswitch (st->st_mode & S_IFMT) {\n\tcase S_IFLNK:\n\t\tif (strbuf_readlink(buf, path, st->st_size) < 0)\n\t\t\treturn error(_(\"unable to read symlink %s\"), path);\n\t\treturn 0;\n\tcase S_IFREG:\n\t\tif (strbuf_read_file(buf, path, st->st_size) != st->st_size)\n\t\t\treturn error(_(\"unable to open or read %s\"), path);\n\t\t/*\n\t\t * \"git apply\" without \"--index/--cached\" should never look\n\t\t * at the index; the target file may not have been added to\n\t\t * the index yet, and we may not even be in any Git repository.\n\t\t * Pass NULL to convert_to_git() to stress this; the function\n\t\t * should never look at the index when explicit crlf option\n\t\t * is given.\n\t\t */\n\t\tconvert_to_git(NULL, path, buf->buf, buf->len, buf, conv_flags);\n\t\treturn 0;\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\n/*\n * Update the preimage, and the common lines in postimage,\n * from buffer buf of length len. If postlen is 0 the postimage\n * is updated in place, otherwise it's updated on a new buffer\n * of length postlen\n */\n\nstatic void update_pre_post_images(struct image *preimage,\n\t\t\t\t   struct image *postimage,\n\t\t\t\t   char *buf,\n\t\t\t\t   size_t len, size_t postlen)\n{\n\tint i, ctx, reduced;\n\tchar *new_buf, *old_buf, *fixed;\n\tstruct image fixed_preimage;\n\n\t/*\n\t * Update the preimage with whitespace fixes.  Note that we\n\t * are not losing preimage->buf -- apply_one_fragment() will\n\t * free \"oldlines\".\n\t */\n\tprepare_image(&fixed_preimage, buf, len, 1);\n\tassert(postlen\n\t       ? fixed_preimage.nr == preimage->nr\n\t       : fixed_preimage.nr <= preimage->nr);\n\tfor (i = 0; i < fixed_preimage.nr; i++)\n\t\tfixed_preimage.line[i].flag = preimage->line[i].flag;\n\tfree(preimage->line_allocated);\n\t*preimage = fixed_preimage;\n\n\t/*\n\t * Adjust the common context lines in postimage. This can be\n\t * done in-place when we are shrinking it with whitespace\n\t * fixing, but needs a new buffer when ignoring whitespace or\n\t * expanding leading tabs to spaces.\n\t *\n\t * We trust the caller to tell us if the update can be done\n\t * in place (postlen==0) or not.\n\t */\n\told_buf = postimage->buf;\n\tif (postlen)\n\t\tnew_buf = postimage->buf = xmalloc(postlen);\n\telse\n\t\tnew_buf = old_buf;\n\tfixed = preimage->buf;\n\n\tfor (i = reduced = ctx = 0; i < postimage->nr; i++) {\n\t\tsize_t l_len = postimage->line[i].len;\n\t\tif (!(postimage->line[i].flag & LINE_COMMON)) {\n\t\t\t/* an added line -- no counterparts in preimage */\n\t\t\tmemmove(new_buf, old_buf, l_len);\n\t\t\told_buf += l_len;\n\t\t\tnew_buf += l_len;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* a common context -- skip it in the original postimage */\n\t\told_buf += l_len;\n\n\t\t/* and find the corresponding one in the fixed preimage */\n\t\twhile (ctx < preimage->nr &&\n\t\t       !(preimage->line[ctx].flag & LINE_COMMON)) {\n\t\t\tfixed += preimage->line[ctx].len;\n\t\t\tctx++;\n\t\t}\n\n\t\t/*\n\t\t * preimage is expected to run out, if the caller\n\t\t * fixed addition of trailing blank lines.\n\t\t */\n\t\tif (preimage->nr <= ctx) {\n\t\t\treduced++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* and copy it in, while fixing the line length */\n\t\tl_len = preimage->line[ctx].len;\n\t\tmemcpy(new_buf, fixed, l_len);\n\t\tnew_buf += l_len;\n\t\tfixed += l_len;\n\t\tpostimage->line[i].len = l_len;\n\t\tctx++;\n\t}\n\n\tif (postlen\n\t    ? postlen < new_buf - postimage->buf\n\t    : postimage->len < new_buf - postimage->buf)\n\t\tBUG(\"caller miscounted postlen: asked %d, orig = %d, used = %d\",\n\t\t    (int)postlen, (int) postimage->len, (int)(new_buf - postimage->buf));\n\n\t/* Fix the length of the whole thing */\n\tpostimage->len = new_buf - postimage->buf;\n\tpostimage->nr -= reduced;\n}\n\nstatic int line_by_line_fuzzy_match(struct image *img,\n\t\t\t\t    struct image *preimage,\n\t\t\t\t    struct image *postimage,\n\t\t\t\t    unsigned long current,\n\t\t\t\t    int current_lno,\n\t\t\t\t    int preimage_limit)\n{\n\tint i;\n\tsize_t imgoff = 0;\n\tsize_t preoff = 0;\n\tsize_t postlen = postimage->len;\n\tsize_t extra_chars;\n\tchar *buf;\n\tchar *preimage_eof;\n\tchar *preimage_end;\n\tstruct strbuf fixed;\n\tchar *fixed_buf;\n\tsize_t fixed_len;\n\n\tfor (i = 0; i < preimage_limit; i++) {\n\t\tsize_t prelen = preimage->line[i].len;\n\t\tsize_t imglen = img->line[current_lno+i].len;\n\n\t\tif (!fuzzy_matchlines(img->buf + current + imgoff, imglen,\n\t\t\t\t      preimage->buf + preoff, prelen))\n\t\t\treturn 0;\n\t\tif (preimage->line[i].flag & LINE_COMMON)\n\t\t\tpostlen += imglen - prelen;\n\t\timgoff += imglen;\n\t\tpreoff += prelen;\n\t}\n\n\t/*\n\t * Ok, the preimage matches with whitespace fuzz.\n\t *\n\t * imgoff now holds the true length of the target that\n\t * matches the preimage before the end of the file.\n\t *\n\t * Count the number of characters in the preimage that fall\n\t * beyond the end of the file and make sure that all of them\n\t * are whitespace characters. (This can only happen if\n\t * we are removing blank lines at the end of the file.)\n\t */\n\tbuf = preimage_eof = preimage->buf + preoff;\n\tfor ( ; i < preimage->nr; i++)\n\t\tpreoff += preimage->line[i].len;\n\tpreimage_end = preimage->buf + preoff;\n\tfor ( ; buf < preimage_end; buf++)\n\t\tif (!isspace(*buf))\n\t\t\treturn 0;\n\n\t/*\n\t * Update the preimage and the common postimage context\n\t * lines to use the same whitespace as the target.\n\t * If whitespace is missing in the target (i.e.\n\t * if the preimage extends beyond the end of the file),\n\t * use the whitespace from the preimage.\n\t */\n\textra_chars = preimage_end - preimage_eof;\n\tstrbuf_init(&fixed, imgoff + extra_chars);\n\tstrbuf_add(&fixed, img->buf + current, imgoff);\n\tstrbuf_add(&fixed, preimage_eof, extra_chars);\n\tfixed_buf = strbuf_detach(&fixed, &fixed_len);\n\tupdate_pre_post_images(preimage, postimage,\n\t\t\t       fixed_buf, fixed_len, postlen);\n\treturn 1;\n}\n\nstatic int match_fragment(struct apply_state *state,\n\t\t\t  struct image *img,\n\t\t\t  struct image *preimage,\n\t\t\t  struct image *postimage,\n\t\t\t  unsigned long current,\n\t\t\t  int current_lno,\n\t\t\t  unsigned ws_rule,\n\t\t\t  int match_beginning, int match_end)\n{\n\tint i;\n\tchar *fixed_buf, *buf, *orig, *target;\n\tstruct strbuf fixed;\n\tsize_t fixed_len, postlen;\n\tint preimage_limit;\n\n\tif (preimage->nr + current_lno <= img->nr) {\n\t\t/*\n\t\t * The hunk falls within the boundaries of img.\n\t\t */\n\t\tpreimage_limit = preimage->nr;\n\t\tif (match_end && (preimage->nr + current_lno != img->nr))\n\t\t\treturn 0;\n\t} else if (state->ws_error_action == correct_ws_error &&\n\t\t   (ws_rule & WS_BLANK_AT_EOF)) {\n\t\t/*\n\t\t * This hunk extends beyond the end of img, and we are\n\t\t * removing blank lines at the end of the file.  This\n\t\t * many lines from the beginning of the preimage must\n\t\t * match with img, and the remainder of the preimage\n\t\t * must be blank.\n\t\t */\n\t\tpreimage_limit = img->nr - current_lno;\n\t} else {\n\t\t/*\n\t\t * The hunk extends beyond the end of the img and\n\t\t * we are not removing blanks at the end, so we\n\t\t * should reject the hunk at this position.\n\t\t */\n\t\treturn 0;\n\t}\n\n\tif (match_beginning && current_lno)\n\t\treturn 0;\n\n\t/* Quick hash check */\n\tfor (i = 0; i < preimage_limit; i++)\n\t\tif ((img->line[current_lno + i].flag & LINE_PATCHED) ||\n\t\t    (preimage->line[i].hash != img->line[current_lno + i].hash))\n\t\t\treturn 0;\n\n\tif (preimage_limit == preimage->nr) {\n\t\t/*\n\t\t * Do we have an exact match?  If we were told to match\n\t\t * at the end, size must be exactly at current+fragsize,\n\t\t * otherwise current+fragsize must be still within the preimage,\n\t\t * and either case, the old piece should match the preimage\n\t\t * exactly.\n\t\t */\n\t\tif ((match_end\n\t\t     ? (current + preimage->len == img->len)\n\t\t     : (current + preimage->len <= img->len)) &&\n\t\t    !memcmp(img->buf + current, preimage->buf, preimage->len))\n\t\t\treturn 1;\n\t} else {\n\t\t/*\n\t\t * The preimage extends beyond the end of img, so\n\t\t * there cannot be an exact match.\n\t\t *\n\t\t * There must be one non-blank context line that match\n\t\t * a line before the end of img.\n\t\t */\n\t\tchar *buf_end;\n\n\t\tbuf = preimage->buf;\n\t\tbuf_end = buf;\n\t\tfor (i = 0; i < preimage_limit; i++)\n\t\t\tbuf_end += preimage->line[i].len;\n\n\t\tfor ( ; buf < buf_end; buf++)\n\t\t\tif (!isspace(*buf))\n\t\t\t\tbreak;\n\t\tif (buf == buf_end)\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * No exact match. If we are ignoring whitespace, run a line-by-line\n\t * fuzzy matching. We collect all the line length information because\n\t * we need it to adjust whitespace if we match.\n\t */\n\tif (state->ws_ignore_action == ignore_ws_change)\n\t\treturn line_by_line_fuzzy_match(img, preimage, postimage,\n\t\t\t\t\t\tcurrent, current_lno, preimage_limit);\n\n\tif (state->ws_error_action != correct_ws_error)\n\t\treturn 0;\n\n\t/*\n\t * The hunk does not apply byte-by-byte, but the hash says\n\t * it might with whitespace fuzz. We weren't asked to\n\t * ignore whitespace, we were asked to correct whitespace\n\t * errors, so let's try matching after whitespace correction.\n\t *\n\t * While checking the preimage against the target, whitespace\n\t * errors in both fixed, we count how large the corresponding\n\t * postimage needs to be.  The postimage prepared by\n\t * apply_one_fragment() has whitespace errors fixed on added\n\t * lines already, but the common lines were propagated as-is,\n\t * which may become longer when their whitespace errors are\n\t * fixed.\n\t */\n\n\t/* First count added lines in postimage */\n\tpostlen = 0;\n\tfor (i = 0; i < postimage->nr; i++) {\n\t\tif (!(postimage->line[i].flag & LINE_COMMON))\n\t\t\tpostlen += postimage->line[i].len;\n\t}\n\n\t/*\n\t * The preimage may extend beyond the end of the file,\n\t * but in this loop we will only handle the part of the\n\t * preimage that falls within the file.\n\t */\n\tstrbuf_init(&fixed, preimage->len + 1);\n\torig = preimage->buf;\n\ttarget = img->buf + current;\n\tfor (i = 0; i < preimage_limit; i++) {\n\t\tsize_t oldlen = preimage->line[i].len;\n\t\tsize_t tgtlen = img->line[current_lno + i].len;\n\t\tsize_t fixstart = fixed.len;\n\t\tstruct strbuf tgtfix;\n\t\tint match;\n\n\t\t/* Try fixing the line in the preimage */\n\t\tws_fix_copy(&fixed, orig, oldlen, ws_rule, NULL);\n\n\t\t/* Try fixing the line in the target */\n\t\tstrbuf_init(&tgtfix, tgtlen);\n\t\tws_fix_copy(&tgtfix, target, tgtlen, ws_rule, NULL);\n\n\t\t/*\n\t\t * If they match, either the preimage was based on\n\t\t * a version before our tree fixed whitespace breakage,\n\t\t * or we are lacking a whitespace-fix patch the tree\n\t\t * the preimage was based on already had (i.e. target\n\t\t * has whitespace breakage, the preimage doesn't).\n\t\t * In either case, we are fixing the whitespace breakages\n\t\t * so we might as well take the fix together with their\n\t\t * real change.\n\t\t */\n\t\tmatch = (tgtfix.len == fixed.len - fixstart &&\n\t\t\t !memcmp(tgtfix.buf, fixed.buf + fixstart,\n\t\t\t\t\t     fixed.len - fixstart));\n\n\t\t/* Add the length if this is common with the postimage */\n\t\tif (preimage->line[i].flag & LINE_COMMON)\n\t\t\tpostlen += tgtfix.len;\n\n\t\tstrbuf_release(&tgtfix);\n\t\tif (!match)\n\t\t\tgoto unmatch_exit;\n\n\t\torig += oldlen;\n\t\ttarget += tgtlen;\n\t}\n\n\n\t/*\n\t * Now handle the lines in the preimage that falls beyond the\n\t * end of the file (if any). They will only match if they are\n\t * empty or only contain whitespace (if WS_BLANK_AT_EOL is\n\t * false).\n\t */\n\tfor ( ; i < preimage->nr; i++) {\n\t\tsize_t fixstart = fixed.len; /* start of the fixed preimage */\n\t\tsize_t oldlen = preimage->line[i].len;\n\t\tint j;\n\n\t\t/* Try fixing the line in the preimage */\n\t\tws_fix_copy(&fixed, orig, oldlen, ws_rule, NULL);\n\n\t\tfor (j = fixstart; j < fixed.len; j++)\n\t\t\tif (!isspace(fixed.buf[j]))\n\t\t\t\tgoto unmatch_exit;\n\n\t\torig += oldlen;\n\t}\n\n\t/*\n\t * Yes, the preimage is based on an older version that still\n\t * has whitespace breakages unfixed, and fixing them makes the\n\t * hunk match.  Update the context lines in the postimage.\n\t */\n\tfixed_buf = strbuf_detach(&fixed, &fixed_len);\n\tif (postlen < postimage->len)\n\t\tpostlen = 0;\n\tupdate_pre_post_images(preimage, postimage,\n\t\t\t       fixed_buf, fixed_len, postlen);\n\treturn 1;\n\n unmatch_exit:\n\tstrbuf_release(&fixed);\n\treturn 0;\n}\n\nstatic int find_pos(struct apply_state *state,\n\t\t    struct image *img,\n\t\t    struct image *preimage,\n\t\t    struct image *postimage,\n\t\t    int line,\n\t\t    unsigned ws_rule,\n\t\t    int match_beginning, int match_end)\n{\n\tint i;\n\tunsigned long backwards, forwards, current;\n\tint backwards_lno, forwards_lno, current_lno;\n\n\t/*\n\t * When running with --allow-overlap, it is possible that a hunk is\n\t * seen that pretends to start at the beginning (but no longer does),\n\t * and that *still* needs to match the end. So trust `match_end` more\n\t * than `match_beginning`.\n\t */\n\tif (state->allow_overlap && match_beginning && match_end &&\n\t    img->nr - preimage->nr != 0)\n\t\tmatch_beginning = 0;\n\n\t/*\n\t * If match_beginning or match_end is specified, there is no\n\t * point starting from a wrong line that will never match and\n\t * wander around and wait for a match at the specified end.\n\t */\n\tif (match_beginning)\n\t\tline = 0;\n\telse if (match_end)\n\t\tline = img->nr - preimage->nr;\n\n\t/*\n\t * Because the comparison is unsigned, the following test\n\t * will also take care of a negative line number that can\n\t * result when match_end and preimage is larger than the target.\n\t */\n\tif ((size_t) line > img->nr)\n\t\tline = img->nr;\n\n\tcurrent = 0;\n\tfor (i = 0; i < line; i++)\n\t\tcurrent += img->line[i].len;\n\n\t/*\n\t * There's probably some smart way to do this, but I'll leave\n\t * that to the smart and beautiful people. I'm simple and stupid.\n\t */\n\tbackwards = current;\n\tbackwards_lno = line;\n\tforwards = current;\n\tforwards_lno = line;\n\tcurrent_lno = line;\n\n\tfor (i = 0; ; i++) {\n\t\tif (match_fragment(state, img, preimage, postimage,\n\t\t\t\t   current, current_lno, ws_rule,\n\t\t\t\t   match_beginning, match_end))\n\t\t\treturn current_lno;\n\n\tagain:\n\t\tif (backwards_lno == 0 && forwards_lno == img->nr)\n\t\t\tbreak;\n\n\t\tif (i & 1) {\n\t\t\tif (backwards_lno == 0) {\n\t\t\t\ti++;\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tbackwards_lno--;\n\t\t\tbackwards -= img->line[backwards_lno].len;\n\t\t\tcurrent = backwards;\n\t\t\tcurrent_lno = backwards_lno;\n\t\t} else {\n\t\t\tif (forwards_lno == img->nr) {\n\t\t\t\ti++;\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tforwards += img->line[forwards_lno].len;\n\t\t\tforwards_lno++;\n\t\t\tcurrent = forwards;\n\t\t\tcurrent_lno = forwards_lno;\n\t\t}\n\n\t}\n\treturn -1;\n}\n\nstatic void remove_first_line(struct image *img)\n{\n\timg->buf += img->line[0].len;\n\timg->len -= img->line[0].len;\n\timg->line++;\n\timg->nr--;\n}\n\nstatic void remove_last_line(struct image *img)\n{\n\timg->len -= img->line[--img->nr].len;\n}\n\n/*\n * The change from \"preimage\" and \"postimage\" has been found to\n * apply at applied_pos (counts in line numbers) in \"img\".\n * Update \"img\" to remove \"preimage\" and replace it with \"postimage\".\n */\nstatic void update_image(struct apply_state *state,\n\t\t\t struct image *img,\n\t\t\t int applied_pos,\n\t\t\t struct image *preimage,\n\t\t\t struct image *postimage)\n{\n\t/*\n\t * remove the copy of preimage at offset in img\n\t * and replace it with postimage\n\t */\n\tint i, nr;\n\tsize_t remove_count, insert_count, applied_at = 0;\n\tchar *result;\n\tint preimage_limit;\n\n\t/*\n\t * If we are removing blank lines at the end of img,\n\t * the preimage may extend beyond the end.\n\t * If that is the case, we must be careful only to\n\t * remove the part of the preimage that falls within\n\t * the boundaries of img. Initialize preimage_limit\n\t * to the number of lines in the preimage that falls\n\t * within the boundaries.\n\t */\n\tpreimage_limit = preimage->nr;\n\tif (preimage_limit > img->nr - applied_pos)\n\t\tpreimage_limit = img->nr - applied_pos;\n\n\tfor (i = 0; i < applied_pos; i++)\n\t\tapplied_at += img->line[i].len;\n\n\tremove_count = 0;\n\tfor (i = 0; i < preimage_limit; i++)\n\t\tremove_count += img->line[applied_pos + i].len;\n\tinsert_count = postimage->len;\n\n\t/* Adjust the contents */\n\tresult = xmalloc(st_add3(st_sub(img->len, remove_count), insert_count, 1));\n\tmemcpy(result, img->buf, applied_at);\n\tmemcpy(result + applied_at, postimage->buf, postimage->len);\n\tmemcpy(result + applied_at + postimage->len,\n\t       img->buf + (applied_at + remove_count),\n\t       img->len - (applied_at + remove_count));\n\tfree(img->buf);\n\timg->buf = result;\n\timg->len += insert_count - remove_count;\n\tresult[img->len] = '\\0';\n\n\t/* Adjust the line table */\n\tnr = img->nr + postimage->nr - preimage_limit;\n\tif (preimage_limit < postimage->nr) {\n\t\t/*\n\t\t * NOTE: this knows that we never call remove_first_line()\n\t\t * on anything other than pre/post image.\n\t\t */\n\t\tREALLOC_ARRAY(img->line, nr);\n\t\timg->line_allocated = img->line;\n\t}\n\tif (preimage_limit != postimage->nr)\n\t\tMOVE_ARRAY(img->line + applied_pos + postimage->nr,\n\t\t\t   img->line + applied_pos + preimage_limit,\n\t\t\t   img->nr - (applied_pos + preimage_limit));\n\tCOPY_ARRAY(img->line + applied_pos, postimage->line, postimage->nr);\n\tif (!state->allow_overlap)\n\t\tfor (i = 0; i < postimage->nr; i++)\n\t\t\timg->line[applied_pos + i].flag |= LINE_PATCHED;\n\timg->nr = nr;\n}\n\n/*\n * Use the patch-hunk text in \"frag\" to prepare two images (preimage and\n * postimage) for the hunk.  Find lines that match \"preimage\" in \"img\" and\n * replace the part of \"img\" with \"postimage\" text.\n */\nstatic int apply_one_fragment(struct apply_state *state,\n\t\t\t      struct image *img, struct fragment *frag,\n\t\t\t      int inaccurate_eof, unsigned ws_rule,\n\t\t\t      int nth_fragment)\n{\n\tint match_beginning, match_end;\n\tconst char *patch = frag->patch;\n\tint size = frag->size;\n\tchar *old, *oldlines;\n\tstruct strbuf newlines;\n\tint new_blank_lines_at_end = 0;\n\tint found_new_blank_lines_at_end = 0;\n\tint hunk_linenr = frag->linenr;\n\tunsigned long leading, trailing;\n\tint pos, applied_pos;\n\tstruct image preimage;\n\tstruct image postimage;\n\n\tmemset(&preimage, 0, sizeof(preimage));\n\tmemset(&postimage, 0, sizeof(postimage));\n\toldlines = xmalloc(size);\n\tstrbuf_init(&newlines, size);\n\n\told = oldlines;\n\twhile (size > 0) {\n\t\tchar first;\n\t\tint len = linelen(patch, size);\n\t\tint plen;\n\t\tint added_blank_line = 0;\n\t\tint is_blank_context = 0;\n\t\tsize_t start;\n\n\t\tif (!len)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * \"plen\" is how much of the line we should use for\n\t\t * the actual patch data. Normally we just remove the\n\t\t * first character on the line, but if the line is\n\t\t * followed by \"\\ No newline\", then we also remove the\n\t\t * last one (which is the newline, of course).\n\t\t */\n\t\tplen = len - 1;\n\t\tif (len < size && patch[len] == '\\\\')\n\t\t\tplen--;\n\t\tfirst = *patch;\n\t\tif (state->apply_in_reverse) {\n\t\t\tif (first == '-')\n\t\t\t\tfirst = '+';\n\t\t\telse if (first == '+')\n\t\t\t\tfirst = '-';\n\t\t}\n\n\t\tswitch (first) {\n\t\tcase '\\n':\n\t\t\t/* Newer GNU diff, empty context line */\n\t\t\tif (plen < 0)\n\t\t\t\t/* ... followed by '\\No newline'; nothing */\n\t\t\t\tbreak;\n\t\t\t*old++ = '\\n';\n\t\t\tstrbuf_addch(&newlines, '\\n');\n\t\t\tadd_line_info(&preimage, \"\\n\", 1, LINE_COMMON);\n\t\t\tadd_line_info(&postimage, \"\\n\", 1, LINE_COMMON);\n\t\t\tis_blank_context = 1;\n\t\t\tbreak;\n\t\tcase ' ':\n\t\t\tif (plen && (ws_rule & WS_BLANK_AT_EOF) &&\n\t\t\t    ws_blank_line(patch + 1, plen, ws_rule))\n\t\t\t\tis_blank_context = 1;\n\t\t\t/* fallthrough */\n\t\tcase '-':\n\t\t\tmemcpy(old, patch + 1, plen);\n\t\t\tadd_line_info(&preimage, old, plen,\n\t\t\t\t      (first == ' ' ? LINE_COMMON : 0));\n\t\t\told += plen;\n\t\t\tif (first == '-')\n\t\t\t\tbreak;\n\t\t\t/* fallthrough */\n\t\tcase '+':\n\t\t\t/* --no-add does not add new lines */\n\t\t\tif (first == '+' && state->no_add)\n\t\t\t\tbreak;\n\n\t\t\tstart = newlines.len;\n\t\t\tif (first != '+' ||\n\t\t\t    !state->whitespace_error ||\n\t\t\t    state->ws_error_action != correct_ws_error) {\n\t\t\t\tstrbuf_add(&newlines, patch + 1, plen);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tws_fix_copy(&newlines, patch + 1, plen, ws_rule, &state->applied_after_fixing_ws);\n\t\t\t}\n\t\t\tadd_line_info(&postimage, newlines.buf + start, newlines.len - start,\n\t\t\t\t      (first == '+' ? 0 : LINE_COMMON));\n\t\t\tif (first == '+' &&\n\t\t\t    (ws_rule & WS_BLANK_AT_EOF) &&\n\t\t\t    ws_blank_line(patch + 1, plen, ws_rule))\n\t\t\t\tadded_blank_line = 1;\n\t\t\tbreak;\n\t\tcase '@': case '\\\\':\n\t\t\t/* Ignore it, we already handled it */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (state->apply_verbosity > verbosity_normal)\n\t\t\t\terror(_(\"invalid start of line: '%c'\"), first);\n\t\t\tapplied_pos = -1;\n\t\t\tgoto out;\n\t\t}\n\t\tif (added_blank_line) {\n\t\t\tif (!new_blank_lines_at_end)\n\t\t\t\tfound_new_blank_lines_at_end = hunk_linenr;\n\t\t\tnew_blank_lines_at_end++;\n\t\t}\n\t\telse if (is_blank_context)\n\t\t\t;\n\t\telse\n\t\t\tnew_blank_lines_at_end = 0;\n\t\tpatch += len;\n\t\tsize -= len;\n\t\thunk_linenr++;\n\t}\n\tif (inaccurate_eof &&\n\t    old > oldlines && old[-1] == '\\n' &&\n\t    newlines.len > 0 && newlines.buf[newlines.len - 1] == '\\n') {\n\t\told--;\n\t\tstrbuf_setlen(&newlines, newlines.len - 1);\n\t\tpreimage.line_allocated[preimage.nr - 1].len--;\n\t\tpostimage.line_allocated[postimage.nr - 1].len--;\n\t}\n\n\tleading = frag->leading;\n\ttrailing = frag->trailing;\n\n\t/*\n\t * A hunk to change lines at the beginning would begin with\n\t * @@ -1,L +N,M @@\n\t * but we need to be careful.  -U0 that inserts before the second\n\t * line also has this pattern.\n\t *\n\t * And a hunk to add to an empty file would begin with\n\t * @@ -0,0 +N,M @@\n\t *\n\t * In other words, a hunk that is (frag->oldpos <= 1) with or\n\t * without leading context must match at the beginning.\n\t */\n\tmatch_beginning = (!frag->oldpos ||\n\t\t\t   (frag->oldpos == 1 && !state->unidiff_zero));\n\n\t/*\n\t * A hunk without trailing lines must match at the end.\n\t * However, we simply cannot tell if a hunk must match end\n\t * from the lack of trailing lines if the patch was generated\n\t * with unidiff without any context.\n\t */\n\tmatch_end = !state->unidiff_zero && !trailing;\n\n\tpos = frag->newpos ? (frag->newpos - 1) : 0;\n\tpreimage.buf = oldlines;\n\tpreimage.len = old - oldlines;\n\tpostimage.buf = newlines.buf;\n\tpostimage.len = newlines.len;\n\tpreimage.line = preimage.line_allocated;\n\tpostimage.line = postimage.line_allocated;\n\n\tfor (;;) {\n\n\t\tapplied_pos = find_pos(state, img, &preimage, &postimage, pos,\n\t\t\t\t       ws_rule, match_beginning, match_end);\n\n\t\tif (applied_pos >= 0)\n\t\t\tbreak;\n\n\t\t/* Am I at my context limits? */\n\t\tif ((leading <= state->p_context) && (trailing <= state->p_context))\n\t\t\tbreak;\n\t\tif (match_beginning || match_end) {\n\t\t\tmatch_beginning = match_end = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Reduce the number of context lines; reduce both\n\t\t * leading and trailing if they are equal otherwise\n\t\t * just reduce the larger context.\n\t\t */\n\t\tif (leading >= trailing) {\n\t\t\tremove_first_line(&preimage);\n\t\t\tremove_first_line(&postimage);\n\t\t\tpos--;\n\t\t\tleading--;\n\t\t}\n\t\tif (trailing > leading) {\n\t\t\tremove_last_line(&preimage);\n\t\t\tremove_last_line(&postimage);\n\t\t\ttrailing--;\n\t\t}\n\t}\n\n\tif (applied_pos >= 0) {\n\t\tif (new_blank_lines_at_end &&\n\t\t    preimage.nr + applied_pos >= img->nr &&\n\t\t    (ws_rule & WS_BLANK_AT_EOF) &&\n\t\t    state->ws_error_action != nowarn_ws_error) {\n\t\t\trecord_ws_error(state, WS_BLANK_AT_EOF, \"+\", 1,\n\t\t\t\t\tfound_new_blank_lines_at_end);\n\t\t\tif (state->ws_error_action == correct_ws_error) {\n\t\t\t\twhile (new_blank_lines_at_end--)\n\t\t\t\t\tremove_last_line(&postimage);\n\t\t\t}\n\t\t\t/*\n\t\t\t * We would want to prevent write_out_results()\n\t\t\t * from taking place in apply_patch() that follows\n\t\t\t * the callchain led us here, which is:\n\t\t\t * apply_patch->check_patch_list->check_patch->\n\t\t\t * apply_data->apply_fragments->apply_one_fragment\n\t\t\t */\n\t\t\tif (state->ws_error_action == die_on_ws_error)\n\t\t\t\tstate->apply = 0;\n\t\t}\n\n\t\tif (state->apply_verbosity > verbosity_normal && applied_pos != pos) {\n\t\t\tint offset = applied_pos - pos;\n\t\t\tif (state->apply_in_reverse)\n\t\t\t\toffset = 0 - offset;\n\t\t\tfprintf_ln(stderr,\n\t\t\t\t   Q_(\"Hunk #%d succeeded at %d (offset %d line).\",\n\t\t\t\t      \"Hunk #%d succeeded at %d (offset %d lines).\",\n\t\t\t\t      offset),\n\t\t\t\t   nth_fragment, applied_pos + 1, offset);\n\t\t}\n\n\t\t/*\n\t\t * Warn if it was necessary to reduce the number\n\t\t * of context lines.\n\t\t */\n\t\tif ((leading != frag->leading ||\n\t\t     trailing != frag->trailing) && state->apply_verbosity > verbosity_silent)\n\t\t\tfprintf_ln(stderr, _(\"Context reduced to (%ld/%ld)\"\n\t\t\t\t\t     \" to apply fragment at %d\"),\n\t\t\t\t   leading, trailing, applied_pos+1);\n\t\tupdate_image(state, img, applied_pos, &preimage, &postimage);\n\t} else {\n\t\tif (state->apply_verbosity > verbosity_normal)\n\t\t\terror(_(\"while searching for:\\n%.*s\"),\n\t\t\t      (int)(old - oldlines), oldlines);\n\t}\n\nout:\n\tfree(oldlines);\n\tstrbuf_release(&newlines);\n\tfree(preimage.line_allocated);\n\tfree(postimage.line_allocated);\n\n\treturn (applied_pos < 0);\n}\n\nstatic int apply_binary_fragment(struct apply_state *state,\n\t\t\t\t struct image *img,\n\t\t\t\t struct patch *patch)\n{\n\tstruct fragment *fragment = patch->fragments;\n\tunsigned long len;\n\tvoid *dst;\n\n\tif (!fragment)\n\t\treturn error(_(\"missing binary patch data for '%s'\"),\n\t\t\t     patch->new_name ?\n\t\t\t     patch->new_name :\n\t\t\t     patch->old_name);\n\n\t/* Binary patch is irreversible without the optional second hunk */\n\tif (state->apply_in_reverse) {\n\t\tif (!fragment->next)\n\t\t\treturn error(_(\"cannot reverse-apply a binary patch \"\n\t\t\t\t       \"without the reverse hunk to '%s'\"),\n\t\t\t\t     patch->new_name\n\t\t\t\t     ? patch->new_name : patch->old_name);\n\t\tfragment = fragment->next;\n\t}\n\tswitch (fragment->binary_patch_method) {\n\tcase BINARY_DELTA_DEFLATED:\n\t\tdst = patch_delta(img->buf, img->len, fragment->patch,\n\t\t\t\t  fragment->size, &len);\n\t\tif (!dst)\n\t\t\treturn -1;\n\t\tclear_image(img);\n\t\timg->buf = dst;\n\t\timg->len = len;\n\t\treturn 0;\n\tcase BINARY_LITERAL_DEFLATED:\n\t\tclear_image(img);\n\t\timg->len = fragment->size;\n\t\timg->buf = xmemdupz(fragment->patch, img->len);\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\n/*\n * Replace \"img\" with the result of applying the binary patch.\n * The binary patch data itself in patch->fragment is still kept\n * but the preimage prepared by the caller in \"img\" is freed here\n * or in the helper function apply_binary_fragment() this calls.\n */\nstatic int apply_binary(struct apply_state *state,\n\t\t\tstruct image *img,\n\t\t\tstruct patch *patch)\n{\n\tconst char *name = patch->old_name ? patch->old_name : patch->new_name;\n\tstruct object_id oid;\n\tconst unsigned hexsz = the_hash_algo->hexsz;\n\n\t/*\n\t * For safety, we require patch index line to contain\n\t * full hex textual object ID for old and new, at least for now.\n\t */\n\tif (strlen(patch->old_oid_prefix) != hexsz ||\n\t    strlen(patch->new_oid_prefix) != hexsz ||\n\t    get_oid_hex(patch->old_oid_prefix, &oid) ||\n\t    get_oid_hex(patch->new_oid_prefix, &oid))\n\t\treturn error(_(\"cannot apply binary patch to '%s' \"\n\t\t\t       \"without full index line\"), name);\n\n\tif (patch->old_name) {\n\t\t/*\n\t\t * See if the old one matches what the patch\n\t\t * applies to.\n\t\t */\n\t\thash_object_file(the_hash_algo, img->buf, img->len, blob_type,\n\t\t\t\t &oid);\n\t\tif (strcmp(oid_to_hex(&oid), patch->old_oid_prefix))\n\t\t\treturn error(_(\"the patch applies to '%s' (%s), \"\n\t\t\t\t       \"which does not match the \"\n\t\t\t\t       \"current contents.\"),\n\t\t\t\t     name, oid_to_hex(&oid));\n\t}\n\telse {\n\t\t/* Otherwise, the old one must be empty. */\n\t\tif (img->len)\n\t\t\treturn error(_(\"the patch applies to an empty \"\n\t\t\t\t       \"'%s' but it is not empty\"), name);\n\t}\n\n\tget_oid_hex(patch->new_oid_prefix, &oid);\n\tif (is_null_oid(&oid)) {\n\t\tclear_image(img);\n\t\treturn 0; /* deletion patch */\n\t}\n\n\tif (has_object(the_repository, &oid, 0)) {\n\t\t/* We already have the postimage */\n\t\tenum object_type type;\n\t\tunsigned long size;\n\t\tchar *result;\n\n\t\tresult = read_object_file(&oid, &type, &size);\n\t\tif (!result)\n\t\t\treturn error(_(\"the necessary postimage %s for \"\n\t\t\t\t       \"'%s' cannot be read\"),\n\t\t\t\t     patch->new_oid_prefix, name);\n\t\tclear_image(img);\n\t\timg->buf = result;\n\t\timg->len = size;\n\t} else {\n\t\t/*\n\t\t * We have verified buf matches the preimage;\n\t\t * apply the patch data to it, which is stored\n\t\t * in the patch->fragments->{patch,size}.\n\t\t */\n\t\tif (apply_binary_fragment(state, img, patch))\n\t\t\treturn error(_(\"binary patch does not apply to '%s'\"),\n\t\t\t\t     name);\n\n\t\t/* verify that the result matches */\n\t\thash_object_file(the_hash_algo, img->buf, img->len, blob_type,\n\t\t\t\t &oid);\n\t\tif (strcmp(oid_to_hex(&oid), patch->new_oid_prefix))\n\t\t\treturn error(_(\"binary patch to '%s' creates incorrect result (expecting %s, got %s)\"),\n\t\t\t\tname, patch->new_oid_prefix, oid_to_hex(&oid));\n\t}\n\n\treturn 0;\n}\n\nstatic int apply_fragments(struct apply_state *state, struct image *img, struct patch *patch)\n{\n\tstruct fragment *frag = patch->fragments;\n\tconst char *name = patch->old_name ? patch->old_name : patch->new_name;\n\tunsigned ws_rule = patch->ws_rule;\n\tunsigned inaccurate_eof = patch->inaccurate_eof;\n\tint nth = 0;\n\n\tif (patch->is_binary)\n\t\treturn apply_binary(state, img, patch);\n\n\twhile (frag) {\n\t\tnth++;\n\t\tif (apply_one_fragment(state, img, frag, inaccurate_eof, ws_rule, nth)) {\n\t\t\terror(_(\"patch failed: %s:%ld\"), name, frag->oldpos);\n\t\t\tif (!state->apply_with_reject)\n\t\t\t\treturn -1;\n\t\t\tfrag->rejected = 1;\n\t\t}\n\t\tfrag = frag->next;\n\t}\n\treturn 0;\n}\n\nstatic int read_blob_object(struct strbuf *buf, const struct object_id *oid, unsigned mode)\n{\n\tif (S_ISGITLINK(mode)) {\n\t\tstrbuf_grow(buf, 100);\n\t\tstrbuf_addf(buf, \"Subproject commit %s\\n\", oid_to_hex(oid));\n\t} else {\n\t\tenum object_type type;\n\t\tunsigned long sz;\n\t\tchar *result;\n\n\t\tresult = read_object_file(oid, &type, &sz);\n\t\tif (!result)\n\t\t\treturn -1;\n\t\t/* XXX read_sha1_file NUL-terminates */\n\t\tstrbuf_attach(buf, result, sz, sz + 1);\n\t}\n\treturn 0;\n}\n\nstatic int read_file_or_gitlink(const struct cache_entry *ce, struct strbuf *buf)\n{\n\tif (!ce)\n\t\treturn 0;\n\treturn read_blob_object(buf, &ce->oid, ce->ce_mode);\n}\n\nstatic struct patch *in_fn_table(struct apply_state *state, const char *name)\n{\n\tstruct string_list_item *item;\n\n\tif (name == NULL)\n\t\treturn NULL;\n\n\titem = string_list_lookup(&state->fn_table, name);\n\tif (item != NULL)\n\t\treturn (struct patch *)item->util;\n\n\treturn NULL;\n}\n\n/*\n * item->util in the filename table records the status of the path.\n * Usually it points at a patch (whose result records the contents\n * of it after applying it), but it could be PATH_WAS_DELETED for a\n * path that a previously applied patch has already removed, or\n * PATH_TO_BE_DELETED for a path that a later patch would remove.\n *\n * The latter is needed to deal with a case where two paths A and B\n * are swapped by first renaming A to B and then renaming B to A;\n * moving A to B should not be prevented due to presence of B as we\n * will remove it in a later patch.\n */\n#define PATH_TO_BE_DELETED ((struct patch *) -2)\n#define PATH_WAS_DELETED ((struct patch *) -1)\n\nstatic int to_be_deleted(struct patch *patch)\n{\n\treturn patch == PATH_TO_BE_DELETED;\n}\n\nstatic int was_deleted(struct patch *patch)\n{\n\treturn patch == PATH_WAS_DELETED;\n}\n\nstatic void add_to_fn_table(struct apply_state *state, struct patch *patch)\n{\n\tstruct string_list_item *item;\n\n\t/*\n\t * Always add new_name unless patch is a deletion\n\t * This should cover the cases for normal diffs,\n\t * file creations and copies\n\t */\n\tif (patch->new_name != NULL) {\n\t\titem = string_list_insert(&state->fn_table, patch->new_name);\n\t\titem->util = patch;\n\t}\n\n\t/*\n\t * store a failure on rename/deletion cases because\n\t * later chunks shouldn't patch old names\n\t */\n\tif ((patch->new_name == NULL) || (patch->is_rename)) {\n\t\titem = string_list_insert(&state->fn_table, patch->old_name);\n\t\titem->util = PATH_WAS_DELETED;\n\t}\n}\n\nstatic void prepare_fn_table(struct apply_state *state, struct patch *patch)\n{\n\t/*\n\t * store information about incoming file deletion\n\t */\n\twhile (patch) {\n\t\tif ((patch->new_name == NULL) || (patch->is_rename)) {\n\t\t\tstruct string_list_item *item;\n\t\t\titem = string_list_insert(&state->fn_table, patch->old_name);\n\t\t\titem->util = PATH_TO_BE_DELETED;\n\t\t}\n\t\tpatch = patch->next;\n\t}\n}\n\nstatic int checkout_target(struct index_state *istate,\n\t\t\t   struct cache_entry *ce, struct stat *st)\n{\n\tstruct checkout costate = CHECKOUT_INIT;\n\n\tcostate.refresh_cache = 1;\n\tcostate.istate = istate;\n\tif (checkout_entry(ce, &costate, NULL, NULL) ||\n\t    lstat(ce->name, st))\n\t\treturn error(_(\"cannot checkout %s\"), ce->name);\n\treturn 0;\n}\n\nstatic struct patch *previous_patch(struct apply_state *state,\n\t\t\t\t    struct patch *patch,\n\t\t\t\t    int *gone)\n{\n\tstruct patch *previous;\n\n\t*gone = 0;\n\tif (patch->is_copy || patch->is_rename)\n\t\treturn NULL; /* \"git\" patches do not depend on the order */\n\n\tprevious = in_fn_table(state, patch->old_name);\n\tif (!previous)\n\t\treturn NULL;\n\n\tif (to_be_deleted(previous))\n\t\treturn NULL; /* the deletion hasn't happened yet */\n\n\tif (was_deleted(previous))\n\t\t*gone = 1;\n\n\treturn previous;\n}\n\nstatic int verify_index_match(struct apply_state *state,\n\t\t\t      const struct cache_entry *ce,\n\t\t\t      struct stat *st)\n{\n\tif (S_ISGITLINK(ce->ce_mode)) {\n\t\tif (!S_ISDIR(st->st_mode))\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\treturn ie_match_stat(state->repo->index, ce, st,\n\t\t\t     CE_MATCH_IGNORE_VALID | CE_MATCH_IGNORE_SKIP_WORKTREE);\n}\n\n#define SUBMODULE_PATCH_WITHOUT_INDEX 1\n\nstatic int load_patch_target(struct apply_state *state,\n\t\t\t     struct strbuf *buf,\n\t\t\t     const struct cache_entry *ce,\n\t\t\t     struct stat *st,\n\t\t\t     struct patch *patch,\n\t\t\t     const char *name,\n\t\t\t     unsigned expected_mode)\n{\n\tif (state->cached || state->check_index) {\n\t\tif (read_file_or_gitlink(ce, buf))\n\t\t\treturn error(_(\"failed to read %s\"), name);\n\t} else if (name) {\n\t\tif (S_ISGITLINK(expected_mode)) {\n\t\t\tif (ce)\n\t\t\t\treturn read_file_or_gitlink(ce, buf);\n\t\t\telse\n\t\t\t\treturn SUBMODULE_PATCH_WITHOUT_INDEX;\n\t\t} else if (has_symlink_leading_path(name, strlen(name))) {\n\t\t\treturn error(_(\"reading from '%s' beyond a symbolic link\"), name);\n\t\t} else {\n\t\t\tif (read_old_data(st, patch, name, buf))\n\t\t\t\treturn error(_(\"failed to read %s\"), name);\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*\n * We are about to apply \"patch\"; populate the \"image\" with the\n * current version we have, from the working tree or from the index,\n * depending on the situation e.g. --cached/--index.  If we are\n * applying a non-git patch that incrementally updates the tree,\n * we read from the result of a previous diff.\n */\nstatic int load_preimage(struct apply_state *state,\n\t\t\t struct image *image,\n\t\t\t struct patch *patch, struct stat *st,\n\t\t\t const struct cache_entry *ce)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tsize_t len;\n\tchar *img;\n\tstruct patch *previous;\n\tint status;\n\n\tprevious = previous_patch(state, patch, &status);\n\tif (status)\n\t\treturn error(_(\"path %s has been renamed/deleted\"),\n\t\t\t     patch->old_name);\n\tif (previous) {\n\t\t/* We have a patched copy in memory; use that. */\n\t\tstrbuf_add(&buf, previous->result, previous->resultsize);\n\t} else {\n\t\tstatus = load_patch_target(state, &buf, ce, st, patch,\n\t\t\t\t\t   patch->old_name, patch->old_mode);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t\telse if (status == SUBMODULE_PATCH_WITHOUT_INDEX) {\n\t\t\t/*\n\t\t\t * There is no way to apply subproject\n\t\t\t * patch without looking at the index.\n\t\t\t * NEEDSWORK: shouldn't this be flagged\n\t\t\t * as an error???\n\t\t\t */\n\t\t\tfree_fragment_list(patch->fragments);\n\t\t\tpatch->fragments = NULL;\n\t\t} else if (status) {\n\t\t\treturn error(_(\"failed to read %s\"), patch->old_name);\n\t\t}\n\t}\n\n\timg = strbuf_detach(&buf, &len);\n\tprepare_image(image, img, len, !patch->is_binary);\n\treturn 0;\n}\n\nstatic int three_way_merge(struct apply_state *state,\n\t\t\t   struct image *image,\n\t\t\t   char *path,\n\t\t\t   const struct object_id *base,\n\t\t\t   const struct object_id *ours,\n\t\t\t   const struct object_id *theirs)\n{\n\tmmfile_t base_file, our_file, their_file;\n\tmmbuffer_t result = { NULL };\n\tint status;\n\n\tread_mmblob(&base_file, base);\n\tread_mmblob(&our_file, ours);\n\tread_mmblob(&their_file, theirs);\n\tstatus = ll_merge(&result, path,\n\t\t\t  &base_file, \"base\",\n\t\t\t  &our_file, \"ours\",\n\t\t\t  &their_file, \"theirs\",\n\t\t\t  state->repo->index,\n\t\t\t  NULL);\n\tfree(base_file.ptr);\n\tfree(our_file.ptr);\n\tfree(their_file.ptr);\n\tif (status < 0 || !result.ptr) {\n\t\tfree(result.ptr);\n\t\treturn -1;\n\t}\n\tclear_image(image);\n\timage->buf = result.ptr;\n\timage->len = result.size;\n\n\treturn status;\n}\n\n/*\n * When directly falling back to add/add three-way merge, we read from\n * the current contents of the new_name.  In no cases other than that\n * this function will be called.\n */\nstatic int load_current(struct apply_state *state,\n\t\t\tstruct image *image,\n\t\t\tstruct patch *patch)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tint status, pos;\n\tsize_t len;\n\tchar *img;\n\tstruct stat st;\n\tstruct cache_entry *ce;\n\tchar *name = patch->new_name;\n\tunsigned mode = patch->new_mode;\n\n\tif (!patch->is_new)\n\t\tBUG(\"patch to %s is not a creation\", patch->old_name);\n\n\tpos = index_name_pos(state->repo->index, name, strlen(name));\n\tif (pos < 0)\n\t\treturn error(_(\"%s: does not exist in index\"), name);\n\tce = state->repo->index->cache[pos];\n\tif (lstat(name, &st)) {\n\t\tif (errno != ENOENT)\n\t\t\treturn error_errno(\"%s\", name);\n\t\tif (checkout_target(state->repo->index, ce, &st))\n\t\t\treturn -1;\n\t}\n\tif (verify_index_match(state, ce, &st))\n\t\treturn error(_(\"%s: does not match index\"), name);\n\n\tstatus = load_patch_target(state, &buf, ce, &st, patch, name, mode);\n\tif (status < 0)\n\t\treturn status;\n\telse if (status)\n\t\treturn -1;\n\timg = strbuf_detach(&buf, &len);\n\tprepare_image(image, img, len, !patch->is_binary);\n\treturn 0;\n}\n\nstatic int try_threeway(struct apply_state *state,\n\t\t\tstruct image *image,\n\t\t\tstruct patch *patch,\n\t\t\tstruct stat *st,\n\t\t\tconst struct cache_entry *ce)\n{\n\tstruct object_id pre_oid, post_oid, our_oid;\n\tstruct strbuf buf = STRBUF_INIT;\n\tsize_t len;\n\tint status;\n\tchar *img;\n\tstruct image tmp_image;\n\n\t/* No point falling back to 3-way merge in these cases */\n\tif (patch->is_delete ||\n\t    S_ISGITLINK(patch->old_mode) || S_ISGITLINK(patch->new_mode))\n\t\treturn -1;\n\n\t/* Preimage the patch was prepared for */\n\tif (patch->is_new)\n\t\twrite_object_file(\"\", 0, blob_type, &pre_oid);\n\telse if (get_oid(patch->old_oid_prefix, &pre_oid) ||\n\t\t read_blob_object(&buf, &pre_oid, patch->old_mode))\n\t\treturn error(_(\"repository lacks the necessary blob to fall back on 3-way merge.\"));\n\n\tif (state->apply_verbosity > verbosity_silent)\n\t\tfprintf(stderr, _(\"Falling back to three-way merge...\\n\"));\n\n\timg = strbuf_detach(&buf, &len);\n\tprepare_image(&tmp_image, img, len, 1);\n\t/* Apply the patch to get the post image */\n\tif (apply_fragments(state, &tmp_image, patch) < 0) {\n\t\tclear_image(&tmp_image);\n\t\treturn -1;\n\t}\n\t/* post_oid is theirs */\n\twrite_object_file(tmp_image.buf, tmp_image.len, blob_type, &post_oid);\n\tclear_image(&tmp_image);\n\n\t/* our_oid is ours */\n\tif (patch->is_new) {\n\t\tif (load_current(state, &tmp_image, patch))\n\t\t\treturn error(_(\"cannot read the current contents of '%s'\"),\n\t\t\t\t     patch->new_name);\n\t} else {\n\t\tif (load_preimage(state, &tmp_image, patch, st, ce))\n\t\t\treturn error(_(\"cannot read the current contents of '%s'\"),\n\t\t\t\t     patch->old_name);\n\t}\n\twrite_object_file(tmp_image.buf, tmp_image.len, blob_type, &our_oid);\n\tclear_image(&tmp_image);\n\n\t/* in-core three-way merge between post and our using pre as base */\n\tstatus = three_way_merge(state, image, patch->new_name,\n\t\t\t\t &pre_oid, &our_oid, &post_oid);\n\tif (status < 0) {\n\t\tif (state->apply_verbosity > verbosity_silent)\n\t\t\tfprintf(stderr,\n\t\t\t\t_(\"Failed to fall back on three-way merge...\\n\"));\n\t\treturn status;\n\t}\n\n\tif (status) {\n\t\tpatch->conflicted_threeway = 1;\n\t\tif (patch->is_new)\n\t\t\toidclr(&patch->threeway_stage[0]);\n\t\telse\n\t\t\toidcpy(&patch->threeway_stage[0], &pre_oid);\n\t\toidcpy(&patch->threeway_stage[1], &our_oid);\n\t\toidcpy(&patch->threeway_stage[2], &post_oid);\n\t\tif (state->apply_verbosity > verbosity_silent)\n\t\t\tfprintf(stderr,\n\t\t\t\t_(\"Applied patch to '%s' with conflicts.\\n\"),\n\t\t\t\tpatch->new_name);\n\t} else {\n\t\tif (state->apply_verbosity > verbosity_silent)\n\t\t\tfprintf(stderr,\n\t\t\t\t_(\"Applied patch to '%s' cleanly.\\n\"),\n\t\t\t\tpatch->new_name);\n\t}\n\treturn 0;\n}\n\nstatic int apply_data(struct apply_state *state, struct patch *patch,\n\t\t      struct stat *st, const struct cache_entry *ce)\n{\n\tstruct image image;\n\n\tif (load_preimage(state, &image, patch, st, ce) < 0)\n\t\treturn -1;\n\n\tif (patch->direct_to_threeway ||\n\t    apply_fragments(state, &image, patch) < 0) {\n\t\t/* Note: with --reject, apply_fragments() returns 0 */\n\t\tif (!state->threeway || try_threeway(state, &image, patch, st, ce) < 0)\n\t\t\treturn -1;\n\t}\n\tpatch->result = image.buf;\n\tpatch->resultsize = image.len;\n\tadd_to_fn_table(state, patch);\n\tfree(image.line_allocated);\n\n\tif (0 < patch->is_delete && patch->resultsize)\n\t\treturn error(_(\"removal patch leaves file contents\"));\n\n\treturn 0;\n}\n\n/*\n * If \"patch\" that we are looking at modifies or deletes what we have,\n * we would want it not to lose any local modification we have, either\n * in the working tree or in the index.\n *\n * This also decides if a non-git patch is a creation patch or a\n * modification to an existing empty file.  We do not check the state\n * of the current tree for a creation patch in this function; the caller\n * check_patch() separately makes sure (and errors out otherwise) that\n * the path the patch creates does not exist in the current tree.\n */\nstatic int check_preimage(struct apply_state *state,\n\t\t\t  struct patch *patch,\n\t\t\t  struct cache_entry **ce,\n\t\t\t  struct stat *st)\n{\n\tconst char *old_name = patch->old_name;\n\tstruct patch *previous = NULL;\n\tint stat_ret = 0, status;\n\tunsigned st_mode = 0;\n\n\tif (!old_name)\n\t\treturn 0;\n\n\tassert(patch->is_new <= 0);\n\tprevious = previous_patch(state, patch, &status);\n\n\tif (status)\n\t\treturn error(_(\"path %s has been renamed/deleted\"), old_name);\n\tif (previous) {\n\t\tst_mode = previous->new_mode;\n\t} else if (!state->cached) {\n\t\tstat_ret = lstat(old_name, st);\n\t\tif (stat_ret && errno != ENOENT)\n\t\t\treturn error_errno(\"%s\", old_name);\n\t}\n\n\tif (state->check_index && !previous) {\n\t\tint pos = index_name_pos(state->repo->index, old_name,\n\t\t\t\t\t strlen(old_name));\n\t\tif (pos < 0) {\n\t\t\tif (patch->is_new < 0)\n\t\t\t\tgoto is_new;\n\t\t\treturn error(_(\"%s: does not exist in index\"), old_name);\n\t\t}\n\t\t*ce = state->repo->index->cache[pos];\n\t\tif (stat_ret < 0) {\n\t\t\tif (checkout_target(state->repo->index, *ce, st))\n\t\t\t\treturn -1;\n\t\t}\n\t\tif (!state->cached && verify_index_match(state, *ce, st))\n\t\t\treturn error(_(\"%s: does not match index\"), old_name);\n\t\tif (state->cached)\n\t\t\tst_mode = (*ce)->ce_mode;\n\t} else if (stat_ret < 0) {\n\t\tif (patch->is_new < 0)\n\t\t\tgoto is_new;\n\t\treturn error_errno(\"%s\", old_name);\n\t}\n\n\tif (!state->cached && !previous)\n\t\tst_mode = ce_mode_from_stat(*ce, st->st_mode);\n\n\tif (patch->is_new < 0)\n\t\tpatch->is_new = 0;\n\tif (!patch->old_mode)\n\t\tpatch->old_mode = st_mode;\n\tif ((st_mode ^ patch->old_mode) & S_IFMT)\n\t\treturn error(_(\"%s: wrong type\"), old_name);\n\tif (st_mode != patch->old_mode)\n\t\twarning(_(\"%s has type %o, expected %o\"),\n\t\t\told_name, st_mode, patch->old_mode);\n\tif (!patch->new_mode && !patch->is_delete)\n\t\tpatch->new_mode = st_mode;\n\treturn 0;\n\n is_new:\n\tpatch->is_new = 1;\n\tpatch->is_delete = 0;\n\tFREE_AND_NULL(patch->old_name);\n\treturn 0;\n}\n\n\n#define EXISTS_IN_INDEX 1\n#define EXISTS_IN_WORKTREE 2\n#define EXISTS_IN_INDEX_AS_ITA 3\n\nstatic int check_to_create(struct apply_state *state,\n\t\t\t   const char *new_name,\n\t\t\t   int ok_if_exists)\n{\n\tstruct stat nst;\n\n\tif (state->check_index && (!ok_if_exists || !state->cached)) {\n\t\tint pos;\n\n\t\tpos = index_name_pos(state->repo->index, new_name, strlen(new_name));\n\t\tif (pos >= 0) {\n\t\t\tstruct cache_entry *ce = state->repo->index->cache[pos];\n\n\t\t\t/* allow ITA, as they do not yet exist in the index */\n\t\t\tif (!ok_if_exists && !(ce->ce_flags & CE_INTENT_TO_ADD))\n\t\t\t\treturn EXISTS_IN_INDEX;\n\n\t\t\t/* ITA entries can never match working tree files */\n\t\t\tif (!state->cached && (ce->ce_flags & CE_INTENT_TO_ADD))\n\t\t\t\treturn EXISTS_IN_INDEX_AS_ITA;\n\t\t}\n\t}\n\n\tif (state->cached)\n\t\treturn 0;\n\n\tif (!lstat(new_name, &nst)) {\n\t\tif (S_ISDIR(nst.st_mode) || ok_if_exists)\n\t\t\treturn 0;\n\t\t/*\n\t\t * A leading component of new_name might be a symlink\n\t\t * that is going to be removed with this patch, but\n\t\t * still pointing at somewhere that has the path.\n\t\t * In such a case, path \"new_name\" does not exist as\n\t\t * far as git is concerned.\n\t\t */\n\t\tif (has_symlink_leading_path(new_name, strlen(new_name)))\n\t\t\treturn 0;\n\n\t\treturn EXISTS_IN_WORKTREE;\n\t} else if (!is_missing_file_error(errno)) {\n\t\treturn error_errno(\"%s\", new_name);\n\t}\n\treturn 0;\n}\n\nstatic uintptr_t register_symlink_changes(struct apply_state *state,\n\t\t\t\t\t  const char *path,\n\t\t\t\t\t  uintptr_t what)\n{\n\tstruct string_list_item *ent;\n\n\tent = string_list_lookup(&state->symlink_changes, path);\n\tif (!ent) {\n\t\tent = string_list_insert(&state->symlink_changes, path);\n\t\tent->util = (void *)0;\n\t}\n\tent->util = (void *)(what | ((uintptr_t)ent->util));\n\treturn (uintptr_t)ent->util;\n}\n\nstatic uintptr_t check_symlink_changes(struct apply_state *state, const char *path)\n{\n\tstruct string_list_item *ent;\n\n\tent = string_list_lookup(&state->symlink_changes, path);\n\tif (!ent)\n\t\treturn 0;\n\treturn (uintptr_t)ent->util;\n}\n\nstatic void prepare_symlink_changes(struct apply_state *state, struct patch *patch)\n{\n\tfor ( ; patch; patch = patch->next) {\n\t\tif ((patch->old_name && S_ISLNK(patch->old_mode)) &&\n\t\t    (patch->is_rename || patch->is_delete))\n\t\t\t/* the symlink at patch->old_name is removed */\n\t\t\tregister_symlink_changes(state, patch->old_name, APPLY_SYMLINK_GOES_AWAY);\n\n\t\tif (patch->new_name && S_ISLNK(patch->new_mode))\n\t\t\t/* the symlink at patch->new_name is created or remains */\n\t\t\tregister_symlink_changes(state, patch->new_name, APPLY_SYMLINK_IN_RESULT);\n\t}\n}\n\nstatic int path_is_beyond_symlink_1(struct apply_state *state, struct strbuf *name)\n{\n\tdo {\n\t\tunsigned int change;\n\n\t\twhile (--name->len && name->buf[name->len] != '/')\n\t\t\t; /* scan backwards */\n\t\tif (!name->len)\n\t\t\tbreak;\n\t\tname->buf[name->len] = '\\0';\n\t\tchange = check_symlink_changes(state, name->buf);\n\t\tif (change & APPLY_SYMLINK_IN_RESULT)\n\t\t\treturn 1;\n\t\tif (change & APPLY_SYMLINK_GOES_AWAY)\n\t\t\t/*\n\t\t\t * This cannot be \"return 0\", because we may\n\t\t\t * see a new one created at a higher level.\n\t\t\t */\n\t\t\tcontinue;\n\n\t\t/* otherwise, check the preimage */\n\t\tif (state->check_index) {\n\t\t\tstruct cache_entry *ce;\n\n\t\t\tce = index_file_exists(state->repo->index, name->buf,\n\t\t\t\t\t       name->len, ignore_case);\n\t\t\tif (ce && S_ISLNK(ce->ce_mode))\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\tstruct stat st;\n\t\t\tif (!lstat(name->buf, &st) && S_ISLNK(st.st_mode))\n\t\t\t\treturn 1;\n\t\t}\n\t} while (1);\n\treturn 0;\n}\n\nstatic int path_is_beyond_symlink(struct apply_state *state, const char *name_)\n{\n\tint ret;\n\tstruct strbuf name = STRBUF_INIT;\n\n\tassert(*name_ != '\\0');\n\tstrbuf_addstr(&name, name_);\n\tret = path_is_beyond_symlink_1(state, &name);\n\tstrbuf_release(&name);\n\n\treturn ret;\n}\n\nstatic int check_unsafe_path(struct patch *patch)\n{\n\tconst char *old_name = NULL;\n\tconst char *new_name = NULL;\n\tif (patch->is_delete)\n\t\told_name = patch->old_name;\n\telse if (!patch->is_new && !patch->is_copy)\n\t\told_name = patch->old_name;\n\tif (!patch->is_delete)\n\t\tnew_name = patch->new_name;\n\n\tif (old_name && !verify_path(old_name, patch->old_mode))\n\t\treturn error(_(\"invalid path '%s'\"), old_name);\n\tif (new_name && !verify_path(new_name, patch->new_mode))\n\t\treturn error(_(\"invalid path '%s'\"), new_name);\n\treturn 0;\n}\n\n/*\n * Check and apply the patch in-core; leave the result in patch->result\n * for the caller to write it out to the final destination.\n */\nstatic int check_patch(struct apply_state *state, struct patch *patch)\n{\n\tstruct stat st;\n\tconst char *old_name = patch->old_name;\n\tconst char *new_name = patch->new_name;\n\tconst char *name = old_name ? old_name : new_name;\n\tstruct cache_entry *ce = NULL;\n\tstruct patch *tpatch;\n\tint ok_if_exists;\n\tint status;\n\n\tpatch->rejected = 1; /* we will drop this after we succeed */\n\n\tstatus = check_preimage(state, patch, &ce, &st);\n\tif (status)\n\t\treturn status;\n\told_name = patch->old_name;\n\n\t/*\n\t * A type-change diff is always split into a patch to delete\n\t * old, immediately followed by a patch to create new (see\n\t * diff.c::run_diff()); in such a case it is Ok that the entry\n\t * to be deleted by the previous patch is still in the working\n\t * tree and in the index.\n\t *\n\t * A patch to swap-rename between A and B would first rename A\n\t * to B and then rename B to A.  While applying the first one,\n\t * the presence of B should not stop A from getting renamed to\n\t * B; ask to_be_deleted() about the later rename.  Removal of\n\t * B and rename from A to B is handled the same way by asking\n\t * was_deleted().\n\t */\n\tif ((tpatch = in_fn_table(state, new_name)) &&\n\t    (was_deleted(tpatch) || to_be_deleted(tpatch)))\n\t\tok_if_exists = 1;\n\telse\n\t\tok_if_exists = 0;\n\n\tif (new_name &&\n\t    ((0 < patch->is_new) || patch->is_rename || patch->is_copy)) {\n\t\tint err = check_to_create(state, new_name, ok_if_exists);\n\n\t\tif (err && state->threeway) {\n\t\t\tpatch->direct_to_threeway = 1;\n\t\t} else switch (err) {\n\t\tcase 0:\n\t\t\tbreak; /* happy */\n\t\tcase EXISTS_IN_INDEX:\n\t\t\treturn error(_(\"%s: already exists in index\"), new_name);\n\t\tcase EXISTS_IN_INDEX_AS_ITA:\n\t\t\treturn error(_(\"%s: does not match index\"), new_name);\n\t\tcase EXISTS_IN_WORKTREE:\n\t\t\treturn error(_(\"%s: already exists in working directory\"),\n\t\t\t\t     new_name);\n\t\tdefault:\n\t\t\treturn err;\n\t\t}\n\n\t\tif (!patch->new_mode) {\n\t\t\tif (0 < patch->is_new)\n\t\t\t\tpatch->new_mode = S_IFREG | 0644;\n\t\t\telse\n\t\t\t\tpatch->new_mode = patch->old_mode;\n\t\t}\n\t}\n\n\tif (new_name && old_name) {\n\t\tint same = !strcmp(old_name, new_name);\n\t\tif (!patch->new_mode)\n\t\t\tpatch->new_mode = patch->old_mode;\n\t\tif ((patch->old_mode ^ patch->new_mode) & S_IFMT) {\n\t\t\tif (same)\n\t\t\t\treturn error(_(\"new mode (%o) of %s does not \"\n\t\t\t\t\t       \"match old mode (%o)\"),\n\t\t\t\t\tpatch->new_mode, new_name,\n\t\t\t\t\tpatch->old_mode);\n\t\t\telse\n\t\t\t\treturn error(_(\"new mode (%o) of %s does not \"\n\t\t\t\t\t       \"match old mode (%o) of %s\"),\n\t\t\t\t\tpatch->new_mode, new_name,\n\t\t\t\t\tpatch->old_mode, old_name);\n\t\t}\n\t}\n\n\tif (!state->unsafe_paths && check_unsafe_path(patch))\n\t\treturn -128;\n\n\t/*\n\t * An attempt to read from or delete a path that is beyond a\n\t * symbolic link will be prevented by load_patch_target() that\n\t * is called at the beginning of apply_data() so we do not\n\t * have to worry about a patch marked with \"is_delete\" bit\n\t * here.  We however need to make sure that the patch result\n\t * is not deposited to a path that is beyond a symbolic link\n\t * here.\n\t */\n\tif (!patch->is_delete && path_is_beyond_symlink(state, patch->new_name))\n\t\treturn error(_(\"affected file '%s' is beyond a symbolic link\"),\n\t\t\t     patch->new_name);\n\n\tif (apply_data(state, patch, &st, ce) < 0)\n\t\treturn error(_(\"%s: patch does not apply\"), name);\n\tpatch->rejected = 0;\n\treturn 0;\n}\n\nstatic int check_patch_list(struct apply_state *state, struct patch *patch)\n{\n\tint err = 0;\n\n\tprepare_symlink_changes(state, patch);\n\tprepare_fn_table(state, patch);\n\twhile (patch) {\n\t\tint res;\n\t\tif (state->apply_verbosity > verbosity_normal)\n\t\t\tsay_patch_name(stderr,\n\t\t\t\t       _(\"Checking patch %s...\"), patch);\n\t\tres = check_patch(state, patch);\n\t\tif (res == -128)\n\t\t\treturn -128;\n\t\terr |= res;\n\t\tpatch = patch->next;\n\t}\n\treturn err;\n}\n\nstatic int read_apply_cache(struct apply_state *state)\n{\n\tif (state->index_file)\n\t\treturn read_index_from(state->repo->index, state->index_file,\n\t\t\t\t       get_git_dir());\n\telse\n\t\treturn repo_read_index(state->repo);\n}\n\n/* This function tries to read the object name from the current index */\nstatic int get_current_oid(struct apply_state *state, const char *path,\n\t\t\t   struct object_id *oid)\n{\n\tint pos;\n\n\tif (read_apply_cache(state) < 0)\n\t\treturn -1;\n\tpos = index_name_pos(state->repo->index, path, strlen(path));\n\tif (pos < 0)\n\t\treturn -1;\n\toidcpy(oid, &state->repo->index->cache[pos]->oid);\n\treturn 0;\n}\n\nstatic int preimage_oid_in_gitlink_patch(struct patch *p, struct object_id *oid)\n{\n\t/*\n\t * A usable gitlink patch has only one fragment (hunk) that looks like:\n\t * @@ -1 +1 @@\n\t * -Subproject commit <old sha1>\n\t * +Subproject commit <new sha1>\n\t * or\n\t * @@ -1 +0,0 @@\n\t * -Subproject commit <old sha1>\n\t * for a removal patch.\n\t */\n\tstruct fragment *hunk = p->fragments;\n\tstatic const char heading[] = \"-Subproject commit \";\n\tchar *preimage;\n\n\tif (/* does the patch have only one hunk? */\n\t    hunk && !hunk->next &&\n\t    /* is its preimage one line? */\n\t    hunk->oldpos == 1 && hunk->oldlines == 1 &&\n\t    /* does preimage begin with the heading? */\n\t    (preimage = memchr(hunk->patch, '\\n', hunk->size)) != NULL &&\n\t    starts_with(++preimage, heading) &&\n\t    /* does it record full SHA-1? */\n\t    !get_oid_hex(preimage + sizeof(heading) - 1, oid) &&\n\t    preimage[sizeof(heading) + the_hash_algo->hexsz - 1] == '\\n' &&\n\t    /* does the abbreviated name on the index line agree with it? */\n\t    starts_with(preimage + sizeof(heading) - 1, p->old_oid_prefix))\n\t\treturn 0; /* it all looks fine */\n\n\t/* we may have full object name on the index line */\n\treturn get_oid_hex(p->old_oid_prefix, oid);\n}\n\n/* Build an index that contains just the files needed for a 3way merge */\nstatic int build_fake_ancestor(struct apply_state *state, struct patch *list)\n{\n\tstruct patch *patch;\n\tstruct index_state result = { NULL };\n\tstruct lock_file lock = LOCK_INIT;\n\tint res;\n\n\t/* Once we start supporting the reverse patch, it may be\n\t * worth showing the new sha1 prefix, but until then...\n\t */\n\tfor (patch = list; patch; patch = patch->next) {\n\t\tstruct object_id oid;\n\t\tstruct cache_entry *ce;\n\t\tconst char *name;\n\n\t\tname = patch->old_name ? patch->old_name : patch->new_name;\n\t\tif (0 < patch->is_new)\n\t\t\tcontinue;\n\n\t\tif (S_ISGITLINK(patch->old_mode)) {\n\t\t\tif (!preimage_oid_in_gitlink_patch(patch, &oid))\n\t\t\t\t; /* ok, the textual part looks sane */\n\t\t\telse\n\t\t\t\treturn error(_(\"sha1 information is lacking or \"\n\t\t\t\t\t       \"useless for submodule %s\"), name);\n\t\t} else if (!get_oid_blob(patch->old_oid_prefix, &oid)) {\n\t\t\t; /* ok */\n\t\t} else if (!patch->lines_added && !patch->lines_deleted) {\n\t\t\t/* mode-only change: update the current */\n\t\t\tif (get_current_oid(state, patch->old_name, &oid))\n\t\t\t\treturn error(_(\"mode change for %s, which is not \"\n\t\t\t\t\t       \"in current HEAD\"), name);\n\t\t} else\n\t\t\treturn error(_(\"sha1 information is lacking or useless \"\n\t\t\t\t       \"(%s).\"), name);\n\n\t\tce = make_cache_entry(&result, patch->old_mode, &oid, name, 0, 0);\n\t\tif (!ce)\n\t\t\treturn error(_(\"make_cache_entry failed for path '%s'\"),\n\t\t\t\t     name);\n\t\tif (add_index_entry(&result, ce, ADD_CACHE_OK_TO_ADD)) {\n\t\t\tdiscard_cache_entry(ce);\n\t\t\treturn error(_(\"could not add %s to temporary index\"),\n\t\t\t\t     name);\n\t\t}\n\t}\n\n\thold_lock_file_for_update(&lock, state->fake_ancestor, LOCK_DIE_ON_ERROR);\n\tres = write_locked_index(&result, &lock, COMMIT_LOCK);\n\tdiscard_index(&result);\n\n\tif (res)\n\t\treturn error(_(\"could not write temporary index to %s\"),\n\t\t\t     state->fake_ancestor);\n\n\treturn 0;\n}\n\nstatic void stat_patch_list(struct apply_state *state, struct patch *patch)\n{\n\tint files, adds, dels;\n\n\tfor (files = adds = dels = 0 ; patch ; patch = patch->next) {\n\t\tfiles++;\n\t\tadds += patch->lines_added;\n\t\tdels += patch->lines_deleted;\n\t\tshow_stats(state, patch);\n\t}\n\n\tprint_stat_summary(stdout, files, adds, dels);\n}\n\nstatic void numstat_patch_list(struct apply_state *state,\n\t\t\t       struct patch *patch)\n{\n\tfor ( ; patch; patch = patch->next) {\n\t\tconst char *name;\n\t\tname = patch->new_name ? patch->new_name : patch->old_name;\n\t\tif (patch->is_binary)\n\t\t\tprintf(\"-\\t-\\t\");\n\t\telse\n\t\t\tprintf(\"%d\\t%d\\t\", patch->lines_added, patch->lines_deleted);\n\t\twrite_name_quoted(name, stdout, state->line_termination);\n\t}\n}\n\nstatic void show_file_mode_name(const char *newdelete, unsigned int mode, const char *name)\n{\n\tif (mode)\n\t\tprintf(\" %s mode %06o %s\\n\", newdelete, mode, name);\n\telse\n\t\tprintf(\" %s %s\\n\", newdelete, name);\n}\n\nstatic void show_mode_change(struct patch *p, int show_name)\n{\n\tif (p->old_mode && p->new_mode && p->old_mode != p->new_mode) {\n\t\tif (show_name)\n\t\t\tprintf(\" mode change %06o => %06o %s\\n\",\n\t\t\t       p->old_mode, p->new_mode, p->new_name);\n\t\telse\n\t\t\tprintf(\" mode change %06o => %06o\\n\",\n\t\t\t       p->old_mode, p->new_mode);\n\t}\n}\n\nstatic void show_rename_copy(struct patch *p)\n{\n\tconst char *renamecopy = p->is_rename ? \"rename\" : \"copy\";\n\tconst char *old_name, *new_name;\n\n\t/* Find common prefix */\n\told_name = p->old_name;\n\tnew_name = p->new_name;\n\twhile (1) {\n\t\tconst char *slash_old, *slash_new;\n\t\tslash_old = strchr(old_name, '/');\n\t\tslash_new = strchr(new_name, '/');\n\t\tif (!slash_old ||\n\t\t    !slash_new ||\n\t\t    slash_old - old_name != slash_new - new_name ||\n\t\t    memcmp(old_name, new_name, slash_new - new_name))\n\t\t\tbreak;\n\t\told_name = slash_old + 1;\n\t\tnew_name = slash_new + 1;\n\t}\n\t/* p->old_name through old_name is the common prefix, and old_name and\n\t * new_name through the end of names are renames\n\t */\n\tif (old_name != p->old_name)\n\t\tprintf(\" %s %.*s{%s => %s} (%d%%)\\n\", renamecopy,\n\t\t       (int)(old_name - p->old_name), p->old_name,\n\t\t       old_name, new_name, p->score);\n\telse\n\t\tprintf(\" %s %s => %s (%d%%)\\n\", renamecopy,\n\t\t       p->old_name, p->new_name, p->score);\n\tshow_mode_change(p, 0);\n}\n\nstatic void summary_patch_list(struct patch *patch)\n{\n\tstruct patch *p;\n\n\tfor (p = patch; p; p = p->next) {\n\t\tif (p->is_new)\n\t\t\tshow_file_mode_name(\"create\", p->new_mode, p->new_name);\n\t\telse if (p->is_delete)\n\t\t\tshow_file_mode_name(\"delete\", p->old_mode, p->old_name);\n\t\telse {\n\t\t\tif (p->is_rename || p->is_copy)\n\t\t\t\tshow_rename_copy(p);\n\t\t\telse {\n\t\t\t\tif (p->score) {\n\t\t\t\t\tprintf(\" rewrite %s (%d%%)\\n\",\n\t\t\t\t\t       p->new_name, p->score);\n\t\t\t\t\tshow_mode_change(p, 0);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tshow_mode_change(p, 1);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void patch_stats(struct apply_state *state, struct patch *patch)\n{\n\tint lines = patch->lines_added + patch->lines_deleted;\n\n\tif (lines > state->max_change)\n\t\tstate->max_change = lines;\n\tif (patch->old_name) {\n\t\tint len = quote_c_style(patch->old_name, NULL, NULL, 0);\n\t\tif (!len)\n\t\t\tlen = strlen(patch->old_name);\n\t\tif (len > state->max_len)\n\t\t\tstate->max_len = len;\n\t}\n\tif (patch->new_name) {\n\t\tint len = quote_c_style(patch->new_name, NULL, NULL, 0);\n\t\tif (!len)\n\t\t\tlen = strlen(patch->new_name);\n\t\tif (len > state->max_len)\n\t\t\tstate->max_len = len;\n\t}\n}\n\nstatic int remove_file(struct apply_state *state, struct patch *patch, int rmdir_empty)\n{\n\tif (state->update_index && !state->ita_only) {\n\t\tif (remove_file_from_index(state->repo->index, patch->old_name) < 0)\n\t\t\treturn error(_(\"unable to remove %s from index\"), patch->old_name);\n\t}\n\tif (!state->cached) {\n\t\tif (!remove_or_warn(patch->old_mode, patch->old_name) && rmdir_empty) {\n\t\t\tremove_path(patch->old_name);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int add_index_file(struct apply_state *state,\n\t\t\t  const char *path,\n\t\t\t  unsigned mode,\n\t\t\t  void *buf,\n\t\t\t  unsigned long size)\n{\n\tstruct stat st;\n\tstruct cache_entry *ce;\n\tint namelen = strlen(path);\n\n\tce = make_empty_cache_entry(state->repo->index, namelen);\n\tmemcpy(ce->name, path, namelen);\n\tce->ce_mode = create_ce_mode(mode);\n\tce->ce_flags = create_ce_flags(0);\n\tce->ce_namelen = namelen;\n\tif (state->ita_only) {\n\t\tce->ce_flags |= CE_INTENT_TO_ADD;\n\t\tset_object_name_for_intent_to_add_entry(ce);\n\t} else if (S_ISGITLINK(mode)) {\n\t\tconst char *s;\n\n\t\tif (!skip_prefix(buf, \"Subproject commit \", &s) ||\n\t\t    get_oid_hex(s, &ce->oid)) {\n\t\t\tdiscard_cache_entry(ce);\n\t\t\treturn error(_(\"corrupt patch for submodule %s\"), path);\n\t\t}\n\t} else {\n\t\tif (!state->cached) {\n\t\t\tif (lstat(path, &st) < 0) {\n\t\t\t\tdiscard_cache_entry(ce);\n\t\t\t\treturn error_errno(_(\"unable to stat newly \"\n\t\t\t\t\t\t     \"created file '%s'\"),\n\t\t\t\t\t\t   path);\n\t\t\t}\n\t\t\tfill_stat_cache_info(state->repo->index, ce, &st);\n\t\t}\n\t\tif (write_object_file(buf, size, blob_type, &ce->oid) < 0) {\n\t\t\tdiscard_cache_entry(ce);\n\t\t\treturn error(_(\"unable to create backing store \"\n\t\t\t\t       \"for newly created file %s\"), path);\n\t\t}\n\t}\n\tif (add_index_entry(state->repo->index, ce, ADD_CACHE_OK_TO_ADD) < 0) {\n\t\tdiscard_cache_entry(ce);\n\t\treturn error(_(\"unable to add cache entry for %s\"), path);\n\t}\n\n\treturn 0;\n}\n\n/*\n * Returns:\n *  -1 if an unrecoverable error happened\n *   0 if everything went well\n *   1 if a recoverable error happened\n */\nstatic int try_create_file(struct apply_state *state, const char *path,\n\t\t\t   unsigned int mode, const char *buf,\n\t\t\t   unsigned long size)\n{\n\tint fd, res;\n\tstruct strbuf nbuf = STRBUF_INIT;\n\n\tif (S_ISGITLINK(mode)) {\n\t\tstruct stat st;\n\t\tif (!lstat(path, &st) && S_ISDIR(st.st_mode))\n\t\t\treturn 0;\n\t\treturn !!mkdir(path, 0777);\n\t}\n\n\tif (has_symlinks && S_ISLNK(mode))\n\t\t/* Although buf:size is counted string, it also is NUL\n\t\t * terminated.\n\t\t */\n\t\treturn !!symlink(buf, path);\n\n\tfd = open(path, O_CREAT | O_EXCL | O_WRONLY, (mode & 0100) ? 0777 : 0666);\n\tif (fd < 0)\n\t\treturn 1;\n\n\tif (convert_to_working_tree(state->repo->index, path, buf, size, &nbuf, NULL)) {\n\t\tsize = nbuf.len;\n\t\tbuf  = nbuf.buf;\n\t}\n\n\tres = write_in_full(fd, buf, size) < 0;\n\tif (res)\n\t\terror_errno(_(\"failed to write to '%s'\"), path);\n\tstrbuf_release(&nbuf);\n\n\tif (close(fd) < 0 && !res)\n\t\treturn error_errno(_(\"closing file '%s'\"), path);\n\n\treturn res ? -1 : 0;\n}\n\n/*\n * We optimistically assume that the directories exist,\n * which is true 99% of the time anyway. If they don't,\n * we create them and try again.\n *\n * Returns:\n *   -1 on error\n *   0 otherwise\n */\nstatic int create_one_file(struct apply_state *state,\n\t\t\t   char *path,\n\t\t\t   unsigned mode,\n\t\t\t   const char *buf,\n\t\t\t   unsigned long size)\n{\n\tint res;\n\n\tif (state->cached)\n\t\treturn 0;\n\n\t/*\n\t * We already try to detect whether files are beyond a symlink in our\n\t * up-front checks. But in the case where symlinks are created by any\n\t * of the intermediate hunks it can happen that our up-front checks\n\t * didn't yet see the symlink, but at the point of arriving here there\n\t * in fact is one. We thus repeat the check for symlinks here.\n\t *\n\t * Note that this does not make the up-front check obsolete as the\n\t * failure mode is different:\n\t *\n\t * - The up-front checks cause us to abort before we have written\n\t *   anything into the working directory. So when we exit this way the\n\t *   working directory remains clean.\n\t *\n\t * - The checks here happen in the middle of the action where we have\n\t *   already started to apply the patch. The end result will be a dirty\n\t *   working directory.\n\t *\n\t * Ideally, we should update the up-front checks to catch what would\n\t * happen when we apply the patch before we damage the working tree.\n\t * We have all the information necessary to do so.  But for now, as a\n\t * part of embargoed security work, having this check would serve as a\n\t * reasonable first step.\n\t */\n\tif (path_is_beyond_symlink(state, path))\n\t\treturn error(_(\"affected file '%s' is beyond a symbolic link\"), path);\n\n\tres = try_create_file(state, path, mode, buf, size);\n\tif (res < 0)\n\t\treturn -1;\n\tif (!res)\n\t\treturn 0;\n\n\tif (errno == ENOENT) {\n\t\tif (safe_create_leading_directories_no_share(path))\n\t\t\treturn 0;\n\t\tres = try_create_file(state, path, mode, buf, size);\n\t\tif (res < 0)\n\t\t\treturn -1;\n\t\tif (!res)\n\t\t\treturn 0;\n\t}\n\n\tif (errno == EEXIST || errno == EACCES) {\n\t\t/* We may be trying to create a file where a directory\n\t\t * used to be.\n\t\t */\n\t\tstruct stat st;\n\t\tif (!lstat(path, &st) && (!S_ISDIR(st.st_mode) || !rmdir(path)))\n\t\t\terrno = EEXIST;\n\t}\n\n\tif (errno == EEXIST) {\n\t\tunsigned int nr = getpid();\n\n\t\tfor (;;) {\n\t\t\tchar newpath[PATH_MAX];\n\t\t\tmksnpath(newpath, sizeof(newpath), \"%s~%u\", path, nr);\n\t\t\tres = try_create_file(state, newpath, mode, buf, size);\n\t\t\tif (res < 0)\n\t\t\t\treturn -1;\n\t\t\tif (!res) {\n\t\t\t\tif (!rename(newpath, path))\n\t\t\t\t\treturn 0;\n\t\t\t\tunlink_or_warn(newpath);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (errno != EEXIST)\n\t\t\t\tbreak;\n\t\t\t++nr;\n\t\t}\n\t}\n\treturn error_errno(_(\"unable to write file '%s' mode %o\"),\n\t\t\t   path, mode);\n}\n\nstatic int add_conflicted_stages_file(struct apply_state *state,\n\t\t\t\t       struct patch *patch)\n{\n\tint stage, namelen;\n\tunsigned mode;\n\tstruct cache_entry *ce;\n\n\tif (!state->update_index)\n\t\treturn 0;\n\tnamelen = strlen(patch->new_name);\n\tmode = patch->new_mode ? patch->new_mode : (S_IFREG | 0644);\n\n\tremove_file_from_index(state->repo->index, patch->new_name);\n\tfor (stage = 1; stage < 4; stage++) {\n\t\tif (is_null_oid(&patch->threeway_stage[stage - 1]))\n\t\t\tcontinue;\n\t\tce = make_empty_cache_entry(state->repo->index, namelen);\n\t\tmemcpy(ce->name, patch->new_name, namelen);\n\t\tce->ce_mode = create_ce_mode(mode);\n\t\tce->ce_flags = create_ce_flags(stage);\n\t\tce->ce_namelen = namelen;\n\t\toidcpy(&ce->oid, &patch->threeway_stage[stage - 1]);\n\t\tif (add_index_entry(state->repo->index, ce, ADD_CACHE_OK_TO_ADD) < 0) {\n\t\t\tdiscard_cache_entry(ce);\n\t\t\treturn error(_(\"unable to add cache entry for %s\"),\n\t\t\t\t     patch->new_name);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int create_file(struct apply_state *state, struct patch *patch)\n{\n\tchar *path = patch->new_name;\n\tunsigned mode = patch->new_mode;\n\tunsigned long size = patch->resultsize;\n\tchar *buf = patch->result;\n\n\tif (!mode)\n\t\tmode = S_IFREG | 0644;\n\tif (create_one_file(state, path, mode, buf, size))\n\t\treturn -1;\n\n\tif (patch->conflicted_threeway)\n\t\treturn add_conflicted_stages_file(state, patch);\n\telse if (state->update_index)\n\t\treturn add_index_file(state, path, mode, buf, size);\n\treturn 0;\n}\n\n/* phase zero is to remove, phase one is to create */\nstatic int write_out_one_result(struct apply_state *state,\n\t\t\t\tstruct patch *patch,\n\t\t\t\tint phase)\n{\n\tif (patch->is_delete > 0) {\n\t\tif (phase == 0)\n\t\t\treturn remove_file(state, patch, 1);\n\t\treturn 0;\n\t}\n\tif (patch->is_new > 0 || patch->is_copy) {\n\t\tif (phase == 1)\n\t\t\treturn create_file(state, patch);\n\t\treturn 0;\n\t}\n\t/*\n\t * Rename or modification boils down to the same\n\t * thing: remove the old, write the new\n\t */\n\tif (phase == 0)\n\t\treturn remove_file(state, patch, patch->is_rename);\n\tif (phase == 1)\n\t\treturn create_file(state, patch);\n\treturn 0;\n}\n\nstatic int write_out_one_reject(struct apply_state *state, struct patch *patch)\n{\n\tFILE *rej;\n\tchar namebuf[PATH_MAX];\n\tstruct fragment *frag;\n\tint fd, cnt = 0;\n\tstruct strbuf sb = STRBUF_INIT;\n\n\tfor (cnt = 0, frag = patch->fragments; frag; frag = frag->next) {\n\t\tif (!frag->rejected)\n\t\t\tcontinue;\n\t\tcnt++;\n\t}\n\n\tif (!cnt) {\n\t\tif (state->apply_verbosity > verbosity_normal)\n\t\t\tsay_patch_name(stderr,\n\t\t\t\t       _(\"Applied patch %s cleanly.\"), patch);\n\t\treturn 0;\n\t}\n\n\t/* This should not happen, because a removal patch that leaves\n\t * contents are marked \"rejected\" at the patch level.\n\t */\n\tif (!patch->new_name)\n\t\tdie(_(\"internal error\"));\n\n\t/* Say this even without --verbose */\n\tstrbuf_addf(&sb, Q_(\"Applying patch %%s with %d reject...\",\n\t\t\t    \"Applying patch %%s with %d rejects...\",\n\t\t\t    cnt),\n\t\t    cnt);\n\tif (state->apply_verbosity > verbosity_silent)\n\t\tsay_patch_name(stderr, sb.buf, patch);\n\tstrbuf_release(&sb);\n\n\tcnt = strlen(patch->new_name);\n\tif (ARRAY_SIZE(namebuf) <= cnt + 5) {\n\t\tcnt = ARRAY_SIZE(namebuf) - 5;\n\t\twarning(_(\"truncating .rej filename to %.*s.rej\"),\n\t\t\tcnt - 1, patch->new_name);\n\t}\n\tmemcpy(namebuf, patch->new_name, cnt);\n\tmemcpy(namebuf + cnt, \".rej\", 5);\n\n\tfd = open(namebuf, O_CREAT | O_EXCL | O_WRONLY, 0666);\n\tif (fd < 0) {\n\t\tif (errno != EEXIST)\n\t\t\treturn error_errno(_(\"cannot open %s\"), namebuf);\n\t\tif (unlink(namebuf))\n\t\t\treturn error_errno(_(\"cannot unlink '%s'\"), namebuf);\n\t\tfd = open(namebuf, O_CREAT | O_EXCL | O_WRONLY, 0666);\n\t\tif (fd < 0)\n\t\t\treturn error_errno(_(\"cannot open %s\"), namebuf);\n\t}\n\trej = fdopen(fd, \"w\");\n\tif (!rej)\n\t\treturn error_errno(_(\"cannot open %s\"), namebuf);\n\n\t/* Normal git tools never deal with .rej, so do not pretend\n\t * this is a git patch by saying --git or giving extended\n\t * headers.  While at it, maybe please \"kompare\" that wants\n\t * the trailing TAB and some garbage at the end of line ;-).\n\t */\n\tfprintf(rej, \"diff a/%s b/%s\\t(rejected hunks)\\n\",\n\t\tpatch->new_name, patch->new_name);\n\tfor (cnt = 1, frag = patch->fragments;\n\t     frag;\n\t     cnt++, frag = frag->next) {\n\t\tif (!frag->rejected) {\n\t\t\tif (state->apply_verbosity > verbosity_silent)\n\t\t\t\tfprintf_ln(stderr, _(\"Hunk #%d applied cleanly.\"), cnt);\n\t\t\tcontinue;\n\t\t}\n\t\tif (state->apply_verbosity > verbosity_silent)\n\t\t\tfprintf_ln(stderr, _(\"Rejected hunk #%d.\"), cnt);\n\t\tfprintf(rej, \"%.*s\", frag->size, frag->patch);\n\t\tif (frag->patch[frag->size-1] != '\\n')\n\t\t\tfputc('\\n', rej);\n\t}\n\tfclose(rej);\n\treturn -1;\n}\n\n/*\n * Returns:\n *  -1 if an error happened\n *   0 if the patch applied cleanly\n *   1 if the patch did not apply cleanly\n */\nstatic int write_out_results(struct apply_state *state, struct patch *list)\n{\n\tint phase;\n\tint errs = 0;\n\tstruct patch *l;\n\tstruct string_list cpath = STRING_LIST_INIT_DUP;\n\n\tfor (phase = 0; phase < 2; phase++) {\n\t\tl = list;\n\t\twhile (l) {\n\t\t\tif (l->rejected)\n\t\t\t\terrs = 1;\n\t\t\telse {\n\t\t\t\tif (write_out_one_result(state, l, phase)) {\n\t\t\t\t\tstring_list_clear(&cpath, 0);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (phase == 1) {\n\t\t\t\t\tif (write_out_one_reject(state, l))\n\t\t\t\t\t\terrs = 1;\n\t\t\t\t\tif (l->conflicted_threeway) {\n\t\t\t\t\t\tstring_list_append(&cpath, l->new_name);\n\t\t\t\t\t\terrs = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tl = l->next;\n\t\t}\n\t}\n\n\tif (cpath.nr) {\n\t\tstruct string_list_item *item;\n\n\t\tstring_list_sort(&cpath);\n\t\tif (state->apply_verbosity > verbosity_silent) {\n\t\t\tfor_each_string_list_item(item, &cpath)\n\t\t\t\tfprintf(stderr, \"U %s\\n\", item->string);\n\t\t}\n\t\tstring_list_clear(&cpath, 0);\n\n\t\trepo_rerere(state->repo, 0);\n\t}\n\n\treturn errs;\n}\n\n/*\n * Try to apply a patch.\n *\n * Returns:\n *  -128 if a bad error happened (like patch unreadable)\n *  -1 if patch did not apply and user cannot deal with it\n *   0 if the patch applied\n *   1 if the patch did not apply but user might fix it\n */\nstatic int apply_patch(struct apply_state *state,\n\t\t       int fd,\n\t\t       const char *filename,\n\t\t       int options)\n{\n\tsize_t offset;\n\tstruct strbuf buf = STRBUF_INIT; /* owns the patch text */\n\tstruct patch *list = NULL, **listp = &list;\n\tint skipped_patch = 0;\n\tint res = 0;\n\tint flush_attributes = 0;\n\n\tstate->patch_input_file = filename;\n\tif (read_patch_file(&buf, fd) < 0)\n\t\treturn -128;\n\toffset = 0;\n\twhile (offset < buf.len) {\n\t\tstruct patch *patch;\n\t\tint nr;\n\n\t\tpatch = xcalloc(1, sizeof(*patch));\n\t\tpatch->inaccurate_eof = !!(options & APPLY_OPT_INACCURATE_EOF);\n\t\tpatch->recount =  !!(options & APPLY_OPT_RECOUNT);\n\t\tnr = parse_chunk(state, buf.buf + offset, buf.len - offset, patch);\n\t\tif (nr < 0) {\n\t\t\tfree_patch(patch);\n\t\t\tif (nr == -128) {\n\t\t\t\tres = -128;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (state->apply_in_reverse)\n\t\t\treverse_patches(patch);\n\t\tif (use_patch(state, patch)) {\n\t\t\tpatch_stats(state, patch);\n\t\t\tif (!list || !state->apply_in_reverse) {\n\t\t\t\t*listp = patch;\n\t\t\t\tlistp = &patch->next;\n\t\t\t} else {\n\t\t\t\tpatch->next = list;\n\t\t\t\tlist = patch;\n\t\t\t}\n\n\t\t\tif ((patch->new_name &&\n\t\t\t     ends_with_path_components(patch->new_name,\n\t\t\t\t\t\t       GITATTRIBUTES_FILE)) ||\n\t\t\t    (patch->old_name &&\n\t\t\t     ends_with_path_components(patch->old_name,\n\t\t\t\t\t\t       GITATTRIBUTES_FILE)))\n\t\t\t\tflush_attributes = 1;\n\t\t}\n\t\telse {\n\t\t\tif (state->apply_verbosity > verbosity_normal)\n\t\t\t\tsay_patch_name(stderr, _(\"Skipped patch '%s'.\"), patch);\n\t\t\tfree_patch(patch);\n\t\t\tskipped_patch++;\n\t\t}\n\t\toffset += nr;\n\t}\n\n\tif (!list && !skipped_patch) {\n\t\terror(_(\"unrecognized input\"));\n\t\tres = -128;\n\t\tgoto end;\n\t}\n\n\tif (state->whitespace_error && (state->ws_error_action == die_on_ws_error))\n\t\tstate->apply = 0;\n\n\tstate->update_index = (state->check_index || state->ita_only) && state->apply;\n\tif (state->update_index && !is_lock_file_locked(&state->lock_file)) {\n\t\tif (state->index_file)\n\t\t\thold_lock_file_for_update(&state->lock_file,\n\t\t\t\t\t\t  state->index_file,\n\t\t\t\t\t\t  LOCK_DIE_ON_ERROR);\n\t\telse\n\t\t\trepo_hold_locked_index(state->repo, &state->lock_file,\n\t\t\t\t\t       LOCK_DIE_ON_ERROR);\n\t}\n\n\tif (state->check_index && read_apply_cache(state) < 0) {\n\t\terror(_(\"unable to read index file\"));\n\t\tres = -128;\n\t\tgoto end;\n\t}\n\n\tif (state->check || state->apply) {\n\t\tint r = check_patch_list(state, list);\n\t\tif (r == -128) {\n\t\t\tres = -128;\n\t\t\tgoto end;\n\t\t}\n\t\tif (r < 0 && !state->apply_with_reject) {\n\t\t\tres = -1;\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\tif (state->apply) {\n\t\tint write_res = write_out_results(state, list);\n\t\tif (write_res < 0) {\n\t\t\tres = -128;\n\t\t\tgoto end;\n\t\t}\n\t\tif (write_res > 0) {\n\t\t\t/* with --3way, we still need to write the index out */\n\t\t\tres = state->apply_with_reject ? -1 : 1;\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\tif (state->fake_ancestor &&\n\t    build_fake_ancestor(state, list)) {\n\t\tres = -128;\n\t\tgoto end;\n\t}\n\n\tif (state->diffstat && state->apply_verbosity > verbosity_silent)\n\t\tstat_patch_list(state, list);\n\n\tif (state->numstat && state->apply_verbosity > verbosity_silent)\n\t\tnumstat_patch_list(state, list);\n\n\tif (state->summary && state->apply_verbosity > verbosity_silent)\n\t\tsummary_patch_list(list);\n\n\tif (flush_attributes)\n\t\treset_parsed_attributes();\nend:\n\tfree_patch_list(list);\n\tstrbuf_release(&buf);\n\tstring_list_clear(&state->fn_table, 0);\n\treturn res;\n}\n\nstatic int apply_option_parse_exclude(const struct option *opt,\n\t\t\t\t      const char *arg, int unset)\n{\n\tstruct apply_state *state = opt->value;\n\n\tBUG_ON_OPT_NEG(unset);\n\n\tadd_name_limit(state, arg, 1);\n\treturn 0;\n}\n\nstatic int apply_option_parse_include(const struct option *opt,\n\t\t\t\t      const char *arg, int unset)\n{\n\tstruct apply_state *state = opt->value;\n\n\tBUG_ON_OPT_NEG(unset);\n\n\tadd_name_limit(state, arg, 0);\n\tstate->has_include = 1;\n\treturn 0;\n}\n\nstatic int apply_option_parse_p(const struct option *opt,\n\t\t\t\tconst char *arg,\n\t\t\t\tint unset)\n{\n\tstruct apply_state *state = opt->value;\n\n\tBUG_ON_OPT_NEG(unset);\n\n\tstate->p_value = atoi(arg);\n\tstate->p_value_known = 1;\n\treturn 0;\n}\n\nstatic int apply_option_parse_space_change(const struct option *opt,\n\t\t\t\t\t   const char *arg, int unset)\n{\n\tstruct apply_state *state = opt->value;\n\n\tBUG_ON_OPT_ARG(arg);\n\n\tif (unset)\n\t\tstate->ws_ignore_action = ignore_ws_none;\n\telse\n\t\tstate->ws_ignore_action = ignore_ws_change;\n\treturn 0;\n}\n\nstatic int apply_option_parse_whitespace(const struct option *opt,\n\t\t\t\t\t const char *arg, int unset)\n{\n\tstruct apply_state *state = opt->value;\n\n\tBUG_ON_OPT_NEG(unset);\n\n\tstate->whitespace_option = arg;\n\tif (parse_whitespace_option(state, arg))\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int apply_option_parse_directory(const struct option *opt,\n\t\t\t\t\tconst char *arg, int unset)\n{\n\tstruct apply_state *state = opt->value;\n\n\tBUG_ON_OPT_NEG(unset);\n\n\tstrbuf_reset(&state->root);\n\tstrbuf_addstr(&state->root, arg);\n\tstrbuf_complete(&state->root, '/');\n\treturn 0;\n}\n\nint apply_all_patches(struct apply_state *state,\n\t\t      int argc,\n\t\t      const char **argv,\n\t\t      int options)\n{\n\tint i;\n\tint res;\n\tint errs = 0;\n\tint read_stdin = 1;\n\n\tfor (i = 0; i < argc; i++) {\n\t\tconst char *arg = argv[i];\n\t\tchar *to_free = NULL;\n\t\tint fd;\n\n\t\tif (!strcmp(arg, \"-\")) {\n\t\t\tres = apply_patch(state, 0, \"<stdin>\", options);\n\t\t\tif (res < 0)\n\t\t\t\tgoto end;\n\t\t\terrs |= res;\n\t\t\tread_stdin = 0;\n\t\t\tcontinue;\n\t\t} else\n\t\t\targ = to_free = prefix_filename(state->prefix, arg);\n\n\t\tfd = open(arg, O_RDONLY);\n\t\tif (fd < 0) {\n\t\t\terror(_(\"can't open patch '%s': %s\"), arg, strerror(errno));\n\t\t\tres = -128;\n\t\t\tfree(to_free);\n\t\t\tgoto end;\n\t\t}\n\t\tread_stdin = 0;\n\t\tset_default_whitespace_mode(state);\n\t\tres = apply_patch(state, fd, arg, options);\n\t\tclose(fd);\n\t\tfree(to_free);\n\t\tif (res < 0)\n\t\t\tgoto end;\n\t\terrs |= res;\n\t}\n\tset_default_whitespace_mode(state);\n\tif (read_stdin) {\n\t\tres = apply_patch(state, 0, \"<stdin>\", options);\n\t\tif (res < 0)\n\t\t\tgoto end;\n\t\terrs |= res;\n\t}\n\n\tif (state->whitespace_error) {\n\t\tif (state->squelch_whitespace_errors &&\n\t\t    state->squelch_whitespace_errors < state->whitespace_error) {\n\t\t\tint squelched =\n\t\t\t\tstate->whitespace_error - state->squelch_whitespace_errors;\n\t\t\twarning(Q_(\"squelched %d whitespace error\",\n\t\t\t\t   \"squelched %d whitespace errors\",\n\t\t\t\t   squelched),\n\t\t\t\tsquelched);\n\t\t}\n\t\tif (state->ws_error_action == die_on_ws_error) {\n\t\t\terror(Q_(\"%d line adds whitespace errors.\",\n\t\t\t\t \"%d lines add whitespace errors.\",\n\t\t\t\t state->whitespace_error),\n\t\t\t      state->whitespace_error);\n\t\t\tres = -128;\n\t\t\tgoto end;\n\t\t}\n\t\tif (state->applied_after_fixing_ws && state->apply)\n\t\t\twarning(Q_(\"%d line applied after\"\n\t\t\t\t   \" fixing whitespace errors.\",\n\t\t\t\t   \"%d lines applied after\"\n\t\t\t\t   \" fixing whitespace errors.\",\n\t\t\t\t   state->applied_after_fixing_ws),\n\t\t\t\tstate->applied_after_fixing_ws);\n\t\telse if (state->whitespace_error)\n\t\t\twarning(Q_(\"%d line adds whitespace errors.\",\n\t\t\t\t   \"%d lines add whitespace errors.\",\n\t\t\t\t   state->whitespace_error),\n\t\t\t\tstate->whitespace_error);\n\t}\n\n\tif (state->update_index) {\n\t\tres = write_locked_index(state->repo->index, &state->lock_file, COMMIT_LOCK);\n\t\tif (res) {\n\t\t\terror(_(\"Unable to write new index file\"));\n\t\t\tres = -128;\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\tres = !!errs;\n\nend:\n\trollback_lock_file(&state->lock_file);\n\n\tif (state->apply_verbosity <= verbosity_silent) {\n\t\tset_error_routine(state->saved_error_routine);\n\t\tset_warn_routine(state->saved_warn_routine);\n\t}\n\n\tif (res > -1)\n\t\treturn res;\n\treturn (res == -1 ? 1 : 128);\n}\n\nint apply_parse_options(int argc, const char **argv,\n\t\t\tstruct apply_state *state,\n\t\t\tint *force_apply, int *options,\n\t\t\tconst char * const *apply_usage)\n{\n\tstruct option builtin_apply_options[] = {\n\t\tOPT_CALLBACK_F(0, \"exclude\", state, N_(\"path\"),\n\t\t\tN_(\"don't apply changes matching the given path\"),\n\t\t\tPARSE_OPT_NONEG, apply_option_parse_exclude),\n\t\tOPT_CALLBACK_F(0, \"include\", state, N_(\"path\"),\n\t\t\tN_(\"apply changes matching the given path\"),\n\t\t\tPARSE_OPT_NONEG, apply_option_parse_include),\n\t\tOPT_CALLBACK('p', NULL, state, N_(\"num\"),\n\t\t\tN_(\"remove <num> leading slashes from traditional diff paths\"),\n\t\t\tapply_option_parse_p),\n\t\tOPT_BOOL(0, \"no-add\", &state->no_add,\n\t\t\tN_(\"ignore additions made by the patch\")),\n\t\tOPT_BOOL(0, \"stat\", &state->diffstat,\n\t\t\tN_(\"instead of applying the patch, output diffstat for the input\")),\n\t\tOPT_NOOP_NOARG(0, \"allow-binary-replacement\"),\n\t\tOPT_NOOP_NOARG(0, \"binary\"),\n\t\tOPT_BOOL(0, \"numstat\", &state->numstat,\n\t\t\tN_(\"show number of added and deleted lines in decimal notation\")),\n\t\tOPT_BOOL(0, \"summary\", &state->summary,\n\t\t\tN_(\"instead of applying the patch, output a summary for the input\")),\n\t\tOPT_BOOL(0, \"check\", &state->check,\n\t\t\tN_(\"instead of applying the patch, see if the patch is applicable\")),\n\t\tOPT_BOOL(0, \"index\", &state->check_index,\n\t\t\tN_(\"make sure the patch is applicable to the current index\")),\n\t\tOPT_BOOL('N', \"intent-to-add\", &state->ita_only,\n\t\t\tN_(\"mark new files with `git add --intent-to-add`\")),\n\t\tOPT_BOOL(0, \"cached\", &state->cached,\n\t\t\tN_(\"apply a patch without touching the working tree\")),\n\t\tOPT_BOOL_F(0, \"unsafe-paths\", &state->unsafe_paths,\n\t\t\t   N_(\"accept a patch that touches outside the working area\"),\n\t\t\t   PARSE_OPT_NOCOMPLETE),\n\t\tOPT_BOOL(0, \"apply\", force_apply,\n\t\t\tN_(\"also apply the patch (use with --stat/--summary/--check)\")),\n\t\tOPT_BOOL('3', \"3way\", &state->threeway,\n\t\t\t N_( \"attempt three-way merge if a patch does not apply\")),\n\t\tOPT_FILENAME(0, \"build-fake-ancestor\", &state->fake_ancestor,\n\t\t\tN_(\"build a temporary index based on embedded index information\")),\n\t\t/* Think twice before adding \"--nul\" synonym to this */\n\t\tOPT_SET_INT('z', NULL, &state->line_termination,\n\t\t\tN_(\"paths are separated with NUL character\"), '\\0'),\n\t\tOPT_INTEGER('C', NULL, &state->p_context,\n\t\t\t\tN_(\"ensure at least <n> lines of context match\")),\n\t\tOPT_CALLBACK(0, \"whitespace\", state, N_(\"action\"),\n\t\t\tN_(\"detect new or modified lines that have whitespace errors\"),\n\t\t\tapply_option_parse_whitespace),\n\t\tOPT_CALLBACK_F(0, \"ignore-space-change\", state, NULL,\n\t\t\tN_(\"ignore changes in whitespace when finding context\"),\n\t\t\tPARSE_OPT_NOARG, apply_option_parse_space_change),\n\t\tOPT_CALLBACK_F(0, \"ignore-whitespace\", state, NULL,\n\t\t\tN_(\"ignore changes in whitespace when finding context\"),\n\t\t\tPARSE_OPT_NOARG, apply_option_parse_space_change),\n\t\tOPT_BOOL('R', \"reverse\", &state->apply_in_reverse,\n\t\t\tN_(\"apply the patch in reverse\")),\n\t\tOPT_BOOL(0, \"unidiff-zero\", &state->unidiff_zero,\n\t\t\tN_(\"don't expect at least one line of context\")),\n\t\tOPT_BOOL(0, \"reject\", &state->apply_with_reject,\n\t\t\tN_(\"leave the rejected hunks in corresponding *.rej files\")),\n\t\tOPT_BOOL(0, \"allow-overlap\", &state->allow_overlap,\n\t\t\tN_(\"allow overlapping hunks\")),\n\t\tOPT__VERBOSE(&state->apply_verbosity, N_(\"be verbose\")),\n\t\tOPT_BIT(0, \"inaccurate-eof\", options,\n\t\t\tN_(\"tolerate incorrectly detected missing new-line at the end of file\"),\n\t\t\tAPPLY_OPT_INACCURATE_EOF),\n\t\tOPT_BIT(0, \"recount\", options,\n\t\t\tN_(\"do not trust the line counts in the hunk headers\"),\n\t\t\tAPPLY_OPT_RECOUNT),\n\t\tOPT_CALLBACK(0, \"directory\", state, N_(\"root\"),\n\t\t\tN_(\"prepend <root> to all filenames\"),\n\t\t\tapply_option_parse_directory),\n\t\tOPT_END()\n\t};\n\n\treturn parse_options(argc, argv, state->prefix, builtin_apply_options, apply_usage, 0);\n}\n", "#!/bin/sh\n#\n# Copyright (c) 2005 Junio C Hamano\n#\n\ntest_description='git apply symlinks and partial files\n\n'\n\n. ./test-lib.sh\n\ntest_expect_success setup '\n\n\ttest_ln_s_add path1/path2/path3/path4/path5 link1 &&\n\tgit commit -m initial &&\n\n\tgit branch side &&\n\n\trm -f link? &&\n\n\ttest_ln_s_add htap6 link1 &&\n\tgit commit -m second &&\n\n\tgit diff-tree -p HEAD^ HEAD >patch  &&\n\tgit apply --stat --summary patch\n\n'\n\ntest_expect_success SYMLINKS 'apply symlink patch' '\n\n\tgit checkout side &&\n\tgit apply patch &&\n\tgit diff-files -p >patched &&\n\ttest_cmp patch patched\n\n'\n\ntest_expect_success 'apply --index symlink patch' '\n\n\tgit checkout -f side &&\n\tgit apply --index patch &&\n\tgit diff-index --cached -p HEAD >patched &&\n\ttest_cmp patch patched\n\n'\n\ntest_expect_success 'symlink setup' '\n\tln -s .git symlink &&\n\tgit add symlink &&\n\tgit commit -m \"add symlink\"\n'\n\ntest_expect_success SYMLINKS 'symlink escape when creating new files' '\n\ttest_when_finished \"git reset --hard && git clean -dfx\" &&\n\n\tcat >patch <<-EOF &&\n\tdiff --git a/symlink b/renamed-symlink\n\tsimilarity index 100%\n\trename from symlink\n\trename to renamed-symlink\n\t--\n\tdiff --git /dev/null b/renamed-symlink/create-me\n\tnew file mode 100644\n\tindex 0000000..039727e\n\t--- /dev/null\n\t+++ b/renamed-symlink/create-me\n\t@@ -0,0 +1,1 @@\n\t+busted\n\tEOF\n\n\ttest_must_fail git apply patch 2>stderr &&\n\tcat >expected_stderr <<-EOF &&\n\terror: affected file ${SQ}renamed-symlink/create-me${SQ} is beyond a symbolic link\n\tEOF\n\ttest_i18ncmp expected_stderr stderr &&\n\t! test_path_exists .git/create-me\n'\n\ntest_expect_success SYMLINKS 'symlink escape when modifying file' '\n\ttest_when_finished \"git reset --hard && git clean -dfx\" &&\n\ttouch .git/modify-me &&\n\n\tcat >patch <<-EOF &&\n\tdiff --git a/symlink b/renamed-symlink\n\tsimilarity index 100%\n\trename from symlink\n\trename to renamed-symlink\n\t--\n\tdiff --git a/renamed-symlink/modify-me b/renamed-symlink/modify-me\n\tindex 1111111..2222222 100644\n\t--- a/renamed-symlink/modify-me\n\t+++ b/renamed-symlink/modify-me\n\t@@ -0,0 +1,1 @@\n\t+busted\n\tEOF\n\n\ttest_must_fail git apply patch 2>stderr &&\n\tcat >expected_stderr <<-EOF &&\n\terror: renamed-symlink/modify-me: No such file or directory\n\tEOF\n\ttest_cmp expected_stderr stderr &&\n\ttest_must_be_empty .git/modify-me\n'\n\ntest_expect_success SYMLINKS 'symlink escape when deleting file' '\n\ttest_when_finished \"git reset --hard && git clean -dfx && rm .git/delete-me\" &&\n\ttouch .git/delete-me &&\n\n\tcat >patch <<-EOF &&\n\tdiff --git a/symlink b/renamed-symlink\n\tsimilarity index 100%\n\trename from symlink\n\trename to renamed-symlink\n\t--\n\tdiff --git a/renamed-symlink/delete-me b/renamed-symlink/delete-me\n\tdeleted file mode 100644\n\tindex 1111111..0000000 100644\n\tEOF\n\n\ttest_must_fail git apply patch 2>stderr &&\n\tcat >expected_stderr <<-EOF &&\n\terror: renamed-symlink/delete-me: No such file or directory\n\tEOF\n\ttest_cmp expected_stderr stderr &&\n\ttest_path_is_file .git/delete-me\n'\n\ntest_expect_success SYMLINKS '--reject removes .rej symlink if it exists' '\n\ttest_when_finished \"git reset --hard && git clean -dfx\" &&\n\n\ttest_commit file &&\n\techo modified >file.t &&\n\tgit diff -- file.t >patch &&\n\techo modified-again >file.t &&\n\n\tln -s foo file.t.rej &&\n\ttest_must_fail git apply patch --reject 2>err &&\n\ttest_i18ngrep \"Rejected hunk\" err &&\n\ttest_path_is_missing foo &&\n\ttest_path_is_file file.t.rej\n'\n\ntest_done\n"], "filenames": ["apply.c", "t/t4115-apply-symlink.sh"], "buggy_code_start_loc": [4561, 127], "buggy_code_end_loc": [4602, 127], "fixing_code_start_loc": [4561, 128], "fixing_code_end_loc": [4612, 143], "type": "CWE-22", "message": "Git is a revision control system. Prior to versions 2.30.9, 2.31.8, 2.32.7, 2.33.8, 2.34.8, 2.35.8, 2.36.6, 2.37.7, 2.38.5, 2.39.3, and 2.40.1, by feeding specially crafted input to `git apply --reject`, a path outside the working tree can be overwritten with partially controlled contents (corresponding to the rejected hunk(s) from the given patch). A fix is available in versions 2.30.9, 2.31.8, 2.32.7, 2.33.8, 2.34.8, 2.35.8, 2.36.6, 2.37.7, 2.38.5, 2.39.3, and 2.40.1. As a workaround, avoid using `git apply` with `--reject` when applying patches from an untrusted source. Use `git apply --stat` to inspect a patch before applying; avoid applying one that create a conflict where a link corresponding to the `*.rej` file exists.", "other": {"cve": {"id": "CVE-2023-25652", "sourceIdentifier": "security-advisories@github.com", "published": "2023-04-25T20:15:09.933", "lastModified": "2023-05-12T05:15:17.097", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Git is a revision control system. Prior to versions 2.30.9, 2.31.8, 2.32.7, 2.33.8, 2.34.8, 2.35.8, 2.36.6, 2.37.7, 2.38.5, 2.39.3, and 2.40.1, by feeding specially crafted input to `git apply --reject`, a path outside the working tree can be overwritten with partially controlled contents (corresponding to the rejected hunk(s) from the given patch). A fix is available in versions 2.30.9, 2.31.8, 2.32.7, 2.33.8, 2.34.8, 2.35.8, 2.36.6, 2.37.7, 2.38.5, 2.39.3, and 2.40.1. As a workaround, avoid using `git apply` with `--reject` when applying patches from an untrusted source. Use `git apply --stat` to inspect a patch before applying; avoid applying one that create a conflict where a link corresponding to the `*.rej` file exists."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.30.9", "matchCriteriaId": "A2E4BF99-17B8-4424-B97E-DDB8A4793DAF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.31.0", "versionEndExcluding": "2.31.8", "matchCriteriaId": "2A1D7F29-E06F-4277-8713-1C19DE714300"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.32.0", "versionEndExcluding": "2.32.7", "matchCriteriaId": "0B69F022-B29E-4D9A-B4FC-78430AFF0C9C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.33.0", "versionEndExcluding": "2.33.8", "matchCriteriaId": "8A2B603F-B8E2-4123-80A4-64E983FF1F86"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.34.0", "versionEndExcluding": "2.34.8", "matchCriteriaId": "26D3ED4E-246E-4D4D-9E2D-7890E93ECED8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.35.0", "versionEndExcluding": "2.35.8", "matchCriteriaId": "D3988013-1332-49F8-85E7-7EB59BE36A63"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.36.0", "versionEndExcluding": "2.36.6", "matchCriteriaId": "CB966EF2-F4F8-4462-AA73-5B452538E756"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.37.0", "versionEndExcluding": "2.37.7", "matchCriteriaId": "030542CA-76BF-4252-9E03-D7E44D3DEE19"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.38.0", "versionEndExcluding": "2.38.5", "matchCriteriaId": "6EAEE109-8AD8-4383-AAC3-E9D2A4794F8B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.39.0", "versionEndExcluding": "2.39.3", "matchCriteriaId": "BE329F8E-076F-4895-A2A2-A1C0330C1F6F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:2.40.0:*:*:*:*:*:*:*", "matchCriteriaId": "89633B46-319A-499C-9848-2EA60AC030EB"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:38:*:*:*:*:*:*:*", "matchCriteriaId": "CC559B26-5DFC-4B7A-A27C-B77DE755DFF9"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2023/04/25/2", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/git/git/commit/18e2b1cfc80990719275d7b08e6e50f3e8cbc902", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/git/git/commit/668f2d53613ac8fd373926ebe219f2c29112d93e", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/git/git/security/advisories/GHSA-2hvf-7c8p-28fx", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PI7FZ4NNR5S5J5K6AMVQBH2JFP6NE4L7/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/RKOXOAZ42HLXHXTW6JZI4L5DAIYDTYCU/", "source": "security-advisories@github.com"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/YFZWGQKB6MM5MNF2DLFTD7KS2KWPICKL/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/git/git/commit/18e2b1cfc80990719275d7b08e6e50f3e8cbc902"}}