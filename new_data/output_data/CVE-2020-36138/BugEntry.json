{"buggy_code": ["/*\n * Copyright (c) 2006 Konstantin Shishkov\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * TIFF image decoder\n * @author Konstantin Shishkov\n */\n\n#include \"config.h\"\n#if CONFIG_ZLIB\n#include <zlib.h>\n#endif\n#if CONFIG_LZMA\n#define LZMA_API_STATIC\n#include <lzma.h>\n#endif\n\n#include \"libavutil/attributes.h\"\n#include \"libavutil/avstring.h\"\n#include \"libavutil/error.h\"\n#include \"libavutil/intreadwrite.h\"\n#include \"libavutil/imgutils.h\"\n#include \"libavutil/opt.h\"\n#include \"avcodec.h\"\n#include \"bytestream.h\"\n#include \"faxcompr.h\"\n#include \"internal.h\"\n#include \"lzw.h\"\n#include \"mathops.h\"\n#include \"tiff.h\"\n#include \"tiff_data.h\"\n#include \"mjpegdec.h\"\n#include \"thread.h\"\n#include \"get_bits.h\"\n\ntypedef struct TiffContext {\n    AVClass *class;\n    AVCodecContext *avctx;\n    GetByteContext gb;\n\n    /* JPEG decoding for DNG */\n    AVCodecContext *avctx_mjpeg; // wrapper context for MJPEG\n    AVFrame *jpgframe;           // decoded JPEG tile\n\n    int get_subimage;\n    uint16_t get_page;\n    int get_thumbnail;\n\n    enum TiffType tiff_type;\n    int width, height;\n    unsigned int bpp, bppcount;\n    uint32_t palette[256];\n    int palette_is_set;\n    int le;\n    enum TiffCompr compr;\n    enum TiffPhotometric photometric;\n    int planar;\n    int subsampling[2];\n    int fax_opts;\n    int predictor;\n    int fill_order;\n    uint32_t res[4];\n    int is_thumbnail;\n    unsigned last_tag;\n\n    int is_bayer;\n    uint8_t pattern[4];\n    unsigned black_level;\n    unsigned white_level;\n    uint16_t dng_lut[65536];\n\n    uint32_t sub_ifd;\n    uint16_t cur_page;\n\n    int strips, rps, sstype;\n    int sot;\n    int stripsizesoff, stripsize, stripoff, strippos;\n    LZWState *lzw;\n\n    /* Tile support */\n    int is_tiled;\n    int tile_byte_counts_offset, tile_offsets_offset;\n    int tile_width, tile_length;\n    int tile_count;\n\n    int is_jpeg;\n\n    uint8_t *deinvert_buf;\n    int deinvert_buf_size;\n    uint8_t *yuv_line;\n    unsigned int yuv_line_size;\n    uint8_t *fax_buffer;\n    unsigned int fax_buffer_size;\n\n    int geotag_count;\n    TiffGeoTag *geotags;\n} TiffContext;\n\nstatic void tiff_set_type(TiffContext *s, enum TiffType tiff_type) {\n    if (s->tiff_type < tiff_type) // Prioritize higher-valued entries\n        s->tiff_type = tiff_type;\n}\n\nstatic void free_geotags(TiffContext *const s)\n{\n    int i;\n    for (i = 0; i < s->geotag_count; i++) {\n        if (s->geotags[i].val)\n            av_freep(&s->geotags[i].val);\n    }\n    av_freep(&s->geotags);\n    s->geotag_count = 0;\n}\n\n#define RET_GEOKEY(TYPE, array, element)\\\n    if (key >= TIFF_##TYPE##_KEY_ID_OFFSET &&\\\n        key - TIFF_##TYPE##_KEY_ID_OFFSET < FF_ARRAY_ELEMS(ff_tiff_##array##_name_type_map))\\\n        return ff_tiff_##array##_name_type_map[key - TIFF_##TYPE##_KEY_ID_OFFSET].element;\n\nstatic const char *get_geokey_name(int key)\n{\n    RET_GEOKEY(VERT, vert, name);\n    RET_GEOKEY(PROJ, proj, name);\n    RET_GEOKEY(GEOG, geog, name);\n    RET_GEOKEY(CONF, conf, name);\n\n    return NULL;\n}\n\nstatic int get_geokey_type(int key)\n{\n    RET_GEOKEY(VERT, vert, type);\n    RET_GEOKEY(PROJ, proj, type);\n    RET_GEOKEY(GEOG, geog, type);\n    RET_GEOKEY(CONF, conf, type);\n\n    return AVERROR_INVALIDDATA;\n}\n\nstatic int cmp_id_key(const void *id, const void *k)\n{\n    return *(const int*)id - ((const TiffGeoTagKeyName*)k)->key;\n}\n\nstatic const char *search_keyval(const TiffGeoTagKeyName *keys, int n, int id)\n{\n    TiffGeoTagKeyName *r = bsearch(&id, keys, n, sizeof(keys[0]), cmp_id_key);\n    if(r)\n        return r->name;\n\n    return NULL;\n}\n\nstatic char *get_geokey_val(int key, int val)\n{\n    char *ap;\n\n    if (val == TIFF_GEO_KEY_UNDEFINED)\n        return av_strdup(\"undefined\");\n    if (val == TIFF_GEO_KEY_USER_DEFINED)\n        return av_strdup(\"User-Defined\");\n\n#define RET_GEOKEY_VAL(TYPE, array)\\\n    if (val >= TIFF_##TYPE##_OFFSET &&\\\n        val - TIFF_##TYPE##_OFFSET < FF_ARRAY_ELEMS(ff_tiff_##array##_codes))\\\n        return av_strdup(ff_tiff_##array##_codes[val - TIFF_##TYPE##_OFFSET]);\n\n    switch (key) {\n    case TIFF_GT_MODEL_TYPE_GEOKEY:\n        RET_GEOKEY_VAL(GT_MODEL_TYPE, gt_model_type);\n        break;\n    case TIFF_GT_RASTER_TYPE_GEOKEY:\n        RET_GEOKEY_VAL(GT_RASTER_TYPE, gt_raster_type);\n        break;\n    case TIFF_GEOG_LINEAR_UNITS_GEOKEY:\n    case TIFF_PROJ_LINEAR_UNITS_GEOKEY:\n    case TIFF_VERTICAL_UNITS_GEOKEY:\n        RET_GEOKEY_VAL(LINEAR_UNIT, linear_unit);\n        break;\n    case TIFF_GEOG_ANGULAR_UNITS_GEOKEY:\n    case TIFF_GEOG_AZIMUTH_UNITS_GEOKEY:\n        RET_GEOKEY_VAL(ANGULAR_UNIT, angular_unit);\n        break;\n    case TIFF_GEOGRAPHIC_TYPE_GEOKEY:\n        RET_GEOKEY_VAL(GCS_TYPE, gcs_type);\n        RET_GEOKEY_VAL(GCSE_TYPE, gcse_type);\n        break;\n    case TIFF_GEOG_GEODETIC_DATUM_GEOKEY:\n        RET_GEOKEY_VAL(GEODETIC_DATUM, geodetic_datum);\n        RET_GEOKEY_VAL(GEODETIC_DATUM_E, geodetic_datum_e);\n        break;\n    case TIFF_GEOG_ELLIPSOID_GEOKEY:\n        RET_GEOKEY_VAL(ELLIPSOID, ellipsoid);\n        break;\n    case TIFF_GEOG_PRIME_MERIDIAN_GEOKEY:\n        RET_GEOKEY_VAL(PRIME_MERIDIAN, prime_meridian);\n        break;\n    case TIFF_PROJECTED_CS_TYPE_GEOKEY:\n        ap = av_strdup(search_keyval(ff_tiff_proj_cs_type_codes, FF_ARRAY_ELEMS(ff_tiff_proj_cs_type_codes), val));\n        if(ap) return ap;\n        break;\n    case TIFF_PROJECTION_GEOKEY:\n        ap = av_strdup(search_keyval(ff_tiff_projection_codes, FF_ARRAY_ELEMS(ff_tiff_projection_codes), val));\n        if(ap) return ap;\n        break;\n    case TIFF_PROJ_COORD_TRANS_GEOKEY:\n        RET_GEOKEY_VAL(COORD_TRANS, coord_trans);\n        break;\n    case TIFF_VERTICAL_CS_TYPE_GEOKEY:\n        RET_GEOKEY_VAL(VERT_CS, vert_cs);\n        RET_GEOKEY_VAL(ORTHO_VERT_CS, ortho_vert_cs);\n        break;\n\n    }\n\n    ap = av_malloc(14);\n    if (ap)\n        snprintf(ap, 14, \"Unknown-%d\", val);\n    return ap;\n}\n\nstatic char *doubles2str(double *dp, int count, const char *sep)\n{\n    int i;\n    char *ap, *ap0;\n    uint64_t component_len;\n    if (!sep) sep = \", \";\n    component_len = 24LL + strlen(sep);\n    if (count >= (INT_MAX - 1)/component_len)\n        return NULL;\n    ap = av_malloc(component_len * count + 1);\n    if (!ap)\n        return NULL;\n    ap0   = ap;\n    ap[0] = '\\0';\n    for (i = 0; i < count; i++) {\n        unsigned l = snprintf(ap, component_len, \"%.15g%s\", dp[i], sep);\n        if(l >= component_len) {\n            av_free(ap0);\n            return NULL;\n        }\n        ap += l;\n    }\n    ap0[strlen(ap0) - strlen(sep)] = '\\0';\n    return ap0;\n}\n\nstatic int add_metadata(int count, int type,\n                        const char *name, const char *sep, TiffContext *s, AVFrame *frame)\n{\n    switch(type) {\n    case TIFF_DOUBLE: return ff_tadd_doubles_metadata(count, name, sep, &s->gb, s->le, &frame->metadata);\n    case TIFF_SHORT : return ff_tadd_shorts_metadata(count, name, sep, &s->gb, s->le, 0, &frame->metadata);\n    case TIFF_STRING: return ff_tadd_string_metadata(count, name, &s->gb, s->le, &frame->metadata);\n    default         : return AVERROR_INVALIDDATA;\n    };\n}\n\nstatic void av_always_inline dng_blit(TiffContext *s, uint8_t *dst, int dst_stride,\n                                      const uint8_t *src, int src_stride, int width, int height,\n                                      int is_single_comp, int is_u16);\n\nstatic void av_always_inline horizontal_fill(TiffContext *s,\n                                             unsigned int bpp, uint8_t* dst,\n                                             int usePtr, const uint8_t *src,\n                                             uint8_t c, int width, int offset)\n{\n    switch (bpp) {\n    case 1:\n        while (--width >= 0) {\n            dst[(width+offset)*8+7] = (usePtr ? src[width] : c)      & 0x1;\n            dst[(width+offset)*8+6] = (usePtr ? src[width] : c) >> 1 & 0x1;\n            dst[(width+offset)*8+5] = (usePtr ? src[width] : c) >> 2 & 0x1;\n            dst[(width+offset)*8+4] = (usePtr ? src[width] : c) >> 3 & 0x1;\n            dst[(width+offset)*8+3] = (usePtr ? src[width] : c) >> 4 & 0x1;\n            dst[(width+offset)*8+2] = (usePtr ? src[width] : c) >> 5 & 0x1;\n            dst[(width+offset)*8+1] = (usePtr ? src[width] : c) >> 6 & 0x1;\n            dst[(width+offset)*8+0] = (usePtr ? src[width] : c) >> 7;\n        }\n        break;\n    case 2:\n        while (--width >= 0) {\n            dst[(width+offset)*4+3] = (usePtr ? src[width] : c) & 0x3;\n            dst[(width+offset)*4+2] = (usePtr ? src[width] : c) >> 2 & 0x3;\n            dst[(width+offset)*4+1] = (usePtr ? src[width] : c) >> 4 & 0x3;\n            dst[(width+offset)*4+0] = (usePtr ? src[width] : c) >> 6;\n        }\n        break;\n    case 4:\n        while (--width >= 0) {\n            dst[(width+offset)*2+1] = (usePtr ? src[width] : c) & 0xF;\n            dst[(width+offset)*2+0] = (usePtr ? src[width] : c) >> 4;\n        }\n        break;\n    case 10:\n    case 12:\n    case 14: {\n            uint16_t *dst16 = (uint16_t *)dst;\n            int is_dng = (s->tiff_type == TIFF_TYPE_DNG || s->tiff_type == TIFF_TYPE_CINEMADNG);\n            uint8_t shift = is_dng ? 0 : 16 - bpp;\n            GetBitContext gb;\n\n            init_get_bits8(&gb, src, width);\n            for (int i = 0; i < s->width; i++) {\n                dst16[i] = get_bits(&gb, bpp) << shift;\n            }\n        }\n        break;\n    default:\n        if (usePtr) {\n            memcpy(dst + offset, src, width);\n        } else {\n            memset(dst + offset, c, width);\n        }\n    }\n}\n\nstatic int deinvert_buffer(TiffContext *s, const uint8_t *src, int size)\n{\n    int i;\n\n    av_fast_padded_malloc(&s->deinvert_buf, &s->deinvert_buf_size, size);\n    if (!s->deinvert_buf)\n        return AVERROR(ENOMEM);\n    for (i = 0; i < size; i++)\n        s->deinvert_buf[i] = ff_reverse[src[i]];\n\n    return 0;\n}\n\nstatic void unpack_gray(TiffContext *s, AVFrame *p,\n                       const uint8_t *src, int lnum, int width, int bpp)\n{\n    GetBitContext gb;\n    uint16_t *dst = (uint16_t *)(p->data[0] + lnum * p->linesize[0]);\n\n    init_get_bits8(&gb, src, width);\n\n    for (int i = 0; i < s->width; i++) {\n        dst[i] = get_bits(&gb, bpp);\n    }\n}\n\nstatic void unpack_yuv(TiffContext *s, AVFrame *p,\n                       const uint8_t *src, int lnum)\n{\n    int i, j, k;\n    int w       = (s->width - 1) / s->subsampling[0] + 1;\n    uint8_t *pu = &p->data[1][lnum / s->subsampling[1] * p->linesize[1]];\n    uint8_t *pv = &p->data[2][lnum / s->subsampling[1] * p->linesize[2]];\n    if (s->width % s->subsampling[0] || s->height % s->subsampling[1]) {\n        for (i = 0; i < w; i++) {\n            for (j = 0; j < s->subsampling[1]; j++)\n                for (k = 0; k < s->subsampling[0]; k++)\n                    p->data[0][FFMIN(lnum + j, s->height-1) * p->linesize[0] +\n                               FFMIN(i * s->subsampling[0] + k, s->width-1)] = *src++;\n            *pu++ = *src++;\n            *pv++ = *src++;\n        }\n    }else{\n        for (i = 0; i < w; i++) {\n            for (j = 0; j < s->subsampling[1]; j++)\n                for (k = 0; k < s->subsampling[0]; k++)\n                    p->data[0][(lnum + j) * p->linesize[0] +\n                               i * s->subsampling[0] + k] = *src++;\n            *pu++ = *src++;\n            *pv++ = *src++;\n        }\n    }\n}\n\n#if CONFIG_ZLIB\nstatic int tiff_uncompress(uint8_t *dst, unsigned long *len, const uint8_t *src,\n                           int size)\n{\n    z_stream zstream = { 0 };\n    int zret;\n\n    zstream.next_in   = src;\n    zstream.avail_in  = size;\n    zstream.next_out  = dst;\n    zstream.avail_out = *len;\n    zret              = inflateInit(&zstream);\n    if (zret != Z_OK) {\n        av_log(NULL, AV_LOG_ERROR, \"Inflate init error: %d\\n\", zret);\n        return zret;\n    }\n    zret = inflate(&zstream, Z_SYNC_FLUSH);\n    inflateEnd(&zstream);\n    *len = zstream.total_out;\n    return zret == Z_STREAM_END ? Z_OK : zret;\n}\n\nstatic int tiff_unpack_zlib(TiffContext *s, AVFrame *p, uint8_t *dst, int stride,\n                            const uint8_t *src, int size, int width, int lines,\n                            int strip_start, int is_yuv)\n{\n    uint8_t *zbuf;\n    unsigned long outlen;\n    int ret, line;\n    outlen = width * lines;\n    zbuf   = av_malloc(outlen);\n    if (!zbuf)\n        return AVERROR(ENOMEM);\n    if (s->fill_order) {\n        if ((ret = deinvert_buffer(s, src, size)) < 0) {\n            av_free(zbuf);\n            return ret;\n        }\n        src = s->deinvert_buf;\n    }\n    ret = tiff_uncompress(zbuf, &outlen, src, size);\n    if (ret != Z_OK) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"Uncompressing failed (%lu of %lu) with error %d\\n\", outlen,\n               (unsigned long)width * lines, ret);\n        av_free(zbuf);\n        return AVERROR_UNKNOWN;\n    }\n    src = zbuf;\n    for (line = 0; line < lines; line++) {\n        if (s->bpp < 8 && s->avctx->pix_fmt == AV_PIX_FMT_PAL8) {\n            horizontal_fill(s, s->bpp, dst, 1, src, 0, width, 0);\n        } else {\n            memcpy(dst, src, width);\n        }\n        if (is_yuv) {\n            unpack_yuv(s, p, dst, strip_start + line);\n            line += s->subsampling[1] - 1;\n        }\n        dst += stride;\n        src += width;\n    }\n    av_free(zbuf);\n    return 0;\n}\n#endif\n\n#if CONFIG_LZMA\nstatic int tiff_uncompress_lzma(uint8_t *dst, uint64_t *len, const uint8_t *src,\n                                int size)\n{\n    lzma_stream stream = LZMA_STREAM_INIT;\n    lzma_ret ret;\n\n    stream.next_in   = (uint8_t *)src;\n    stream.avail_in  = size;\n    stream.next_out  = dst;\n    stream.avail_out = *len;\n    ret              = lzma_stream_decoder(&stream, UINT64_MAX, 0);\n    if (ret != LZMA_OK) {\n        av_log(NULL, AV_LOG_ERROR, \"LZMA init error: %d\\n\", ret);\n        return ret;\n    }\n    ret = lzma_code(&stream, LZMA_RUN);\n    lzma_end(&stream);\n    *len = stream.total_out;\n    return ret == LZMA_STREAM_END ? LZMA_OK : ret;\n}\n\nstatic int tiff_unpack_lzma(TiffContext *s, AVFrame *p, uint8_t *dst, int stride,\n                            const uint8_t *src, int size, int width, int lines,\n                            int strip_start, int is_yuv)\n{\n    uint64_t outlen = width * (uint64_t)lines;\n    int ret, line;\n    uint8_t *buf = av_malloc(outlen);\n    if (!buf)\n        return AVERROR(ENOMEM);\n    if (s->fill_order) {\n        if ((ret = deinvert_buffer(s, src, size)) < 0) {\n            av_free(buf);\n            return ret;\n        }\n        src = s->deinvert_buf;\n    }\n    ret = tiff_uncompress_lzma(buf, &outlen, src, size);\n    if (ret != LZMA_OK) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"Uncompressing failed (%\"PRIu64\" of %\"PRIu64\") with error %d\\n\", outlen,\n               (uint64_t)width * lines, ret);\n        av_free(buf);\n        return AVERROR_UNKNOWN;\n    }\n    src = buf;\n    for (line = 0; line < lines; line++) {\n        if (s->bpp < 8 && s->avctx->pix_fmt == AV_PIX_FMT_PAL8) {\n            horizontal_fill(s, s->bpp, dst, 1, src, 0, width, 0);\n        } else {\n            memcpy(dst, src, width);\n        }\n        if (is_yuv) {\n            unpack_yuv(s, p, dst, strip_start + line);\n            line += s->subsampling[1] - 1;\n        }\n        dst += stride;\n        src += width;\n    }\n    av_free(buf);\n    return 0;\n}\n#endif\n\nstatic int tiff_unpack_fax(TiffContext *s, uint8_t *dst, int stride,\n                           const uint8_t *src, int size, int width, int lines)\n{\n    int i, ret = 0;\n    int line;\n    uint8_t *src2;\n\n    av_fast_padded_malloc(&s->fax_buffer, &s->fax_buffer_size, size);\n    src2 = s->fax_buffer;\n\n    if (!src2) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"Error allocating temporary buffer\\n\");\n        return AVERROR(ENOMEM);\n    }\n\n    if (!s->fill_order) {\n        memcpy(src2, src, size);\n    } else {\n        for (i = 0; i < size; i++)\n            src2[i] = ff_reverse[src[i]];\n    }\n    memset(src2 + size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n    ret = ff_ccitt_unpack(s->avctx, src2, size, dst, lines, stride,\n                          s->compr, s->fax_opts);\n    if (s->bpp < 8 && s->avctx->pix_fmt == AV_PIX_FMT_PAL8)\n        for (line = 0; line < lines; line++) {\n            horizontal_fill(s, s->bpp, dst, 1, dst, 0, width, 0);\n            dst += stride;\n        }\n    return ret;\n}\n\nstatic int dng_decode_strip(AVCodecContext *avctx, AVFrame *frame);\n\nstatic int tiff_unpack_strip(TiffContext *s, AVFrame *p, uint8_t *dst, int stride,\n                             const uint8_t *src, int size, int strip_start, int lines)\n{\n    PutByteContext pb;\n    int c, line, pixels, code, ret;\n    const uint8_t *ssrc = src;\n    int width = ((s->width * s->bpp) + 7) >> 3;\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(p->format);\n    int is_yuv = !(desc->flags & AV_PIX_FMT_FLAG_RGB) &&\n                 (desc->flags & AV_PIX_FMT_FLAG_PLANAR) &&\n                 desc->nb_components >= 3;\n    int is_dng;\n\n    if (s->planar)\n        width /= s->bppcount;\n\n    if (size <= 0)\n        return AVERROR_INVALIDDATA;\n\n    if (is_yuv) {\n        int bytes_per_row = (((s->width - 1) / s->subsampling[0] + 1) * s->bpp *\n                            s->subsampling[0] * s->subsampling[1] + 7) >> 3;\n        av_fast_padded_malloc(&s->yuv_line, &s->yuv_line_size, bytes_per_row);\n        if (s->yuv_line == NULL) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Not enough memory\\n\");\n            return AVERROR(ENOMEM);\n        }\n        dst = s->yuv_line;\n        stride = 0;\n\n        width = (s->width - 1) / s->subsampling[0] + 1;\n        width = width * s->subsampling[0] * s->subsampling[1] + 2*width;\n        av_assert0(width <= bytes_per_row);\n        av_assert0(s->bpp == 24);\n    }\n    if (s->is_bayer) {\n        av_assert0(width == (s->bpp * s->width + 7) >> 3);\n    }\n    if (p->format == AV_PIX_FMT_GRAY12) {\n        av_fast_padded_malloc(&s->yuv_line, &s->yuv_line_size, width);\n        if (s->yuv_line == NULL) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Not enough memory\\n\");\n            return AVERROR(ENOMEM);\n        }\n        dst = s->yuv_line;\n        stride = 0;\n    }\n\n    if (s->compr == TIFF_DEFLATE || s->compr == TIFF_ADOBE_DEFLATE) {\n#if CONFIG_ZLIB\n        return tiff_unpack_zlib(s, p, dst, stride, src, size, width, lines,\n                                strip_start, is_yuv);\n#else\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"zlib support not enabled, \"\n               \"deflate compression not supported\\n\");\n        return AVERROR(ENOSYS);\n#endif\n    }\n    if (s->compr == TIFF_LZMA) {\n#if CONFIG_LZMA\n        return tiff_unpack_lzma(s, p, dst, stride, src, size, width, lines,\n                                strip_start, is_yuv);\n#else\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"LZMA support not enabled\\n\");\n        return AVERROR(ENOSYS);\n#endif\n    }\n    if (s->compr == TIFF_LZW) {\n        if (s->fill_order) {\n            if ((ret = deinvert_buffer(s, src, size)) < 0)\n                return ret;\n            ssrc = src = s->deinvert_buf;\n        }\n        if (size > 1 && !src[0] && (src[1]&1)) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Old style LZW is unsupported\\n\");\n        }\n        if ((ret = ff_lzw_decode_init(s->lzw, 8, src, size, FF_LZW_TIFF)) < 0) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Error initializing LZW decoder\\n\");\n            return ret;\n        }\n        for (line = 0; line < lines; line++) {\n            pixels = ff_lzw_decode(s->lzw, dst, width);\n            if (pixels < width) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Decoded only %i bytes of %i\\n\",\n                       pixels, width);\n                return AVERROR_INVALIDDATA;\n            }\n            if (s->bpp < 8 && s->avctx->pix_fmt == AV_PIX_FMT_PAL8)\n                horizontal_fill(s, s->bpp, dst, 1, dst, 0, width, 0);\n            if (is_yuv) {\n                unpack_yuv(s, p, dst, strip_start + line);\n                line += s->subsampling[1] - 1;\n            } else if (p->format == AV_PIX_FMT_GRAY12) {\n                unpack_gray(s, p, dst, strip_start + line, width, s->bpp);\n            }\n            dst += stride;\n        }\n        return 0;\n    }\n    if (s->compr == TIFF_CCITT_RLE ||\n        s->compr == TIFF_G3        ||\n        s->compr == TIFF_G4) {\n        if (is_yuv || p->format == AV_PIX_FMT_GRAY12)\n            return AVERROR_INVALIDDATA;\n\n        return tiff_unpack_fax(s, dst, stride, src, size, width, lines);\n    }\n\n    bytestream2_init(&s->gb, src, size);\n    bytestream2_init_writer(&pb, dst, is_yuv ? s->yuv_line_size : (stride * lines));\n\n    is_dng = (s->tiff_type == TIFF_TYPE_DNG || s->tiff_type == TIFF_TYPE_CINEMADNG);\n\n    /* Decode JPEG-encoded DNGs with strips */\n    if (s->compr == TIFF_NEWJPEG && is_dng) {\n        if (s->strips > 1) {\n            av_log(s->avctx, AV_LOG_ERROR, \"More than one DNG JPEG strips unsupported\\n\");\n            return AVERROR_PATCHWELCOME;\n        }\n        if ((ret = dng_decode_strip(s->avctx, p)) < 0)\n            return ret;\n        return 0;\n    }\n\n    if (is_dng && stride == 0)\n        return AVERROR_INVALIDDATA;\n\n    for (line = 0; line < lines; line++) {\n        if (src - ssrc > size) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Source data overread\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (bytestream2_get_bytes_left(&s->gb) == 0 || bytestream2_get_eof(&pb))\n            break;\n        bytestream2_seek_p(&pb, stride * line, SEEK_SET);\n        switch (s->compr) {\n        case TIFF_RAW:\n            if (ssrc + size - src < width)\n                return AVERROR_INVALIDDATA;\n\n            if (!s->fill_order) {\n                horizontal_fill(s, s->bpp * (s->avctx->pix_fmt == AV_PIX_FMT_PAL8 || s->is_bayer),\n                                dst, 1, src, 0, width, 0);\n            } else {\n                int i;\n                for (i = 0; i < width; i++)\n                    dst[i] = ff_reverse[src[i]];\n            }\n\n            /* Color processing for DNG images with uncompressed strips (non-tiled) */\n            if (is_dng) {\n                int is_u16, pixel_size_bytes, pixel_size_bits, elements;\n\n                is_u16 = (s->bpp / s->bppcount > 8);\n                pixel_size_bits = (is_u16 ? 16 : 8);\n                pixel_size_bytes = (is_u16 ? sizeof(uint16_t) : sizeof(uint8_t));\n\n                elements = width / pixel_size_bytes * pixel_size_bits / s->bpp * s->bppcount; // need to account for [1, 16] bpp\n                av_assert0 (elements * pixel_size_bytes <= FFABS(stride));\n                dng_blit(s,\n                         dst,\n                         0, // no stride, only 1 line\n                         dst,\n                         0, // no stride, only 1 line\n                         elements,\n                         1,\n                         0, // single-component variation is only preset in JPEG-encoded DNGs\n                         is_u16);\n            }\n\n            src += width;\n            break;\n        case TIFF_PACKBITS:\n            for (pixels = 0; pixels < width;) {\n                if (ssrc + size - src < 2) {\n                    av_log(s->avctx, AV_LOG_ERROR, \"Read went out of bounds\\n\");\n                    return AVERROR_INVALIDDATA;\n                }\n                code = s->fill_order ? (int8_t) ff_reverse[*src++]: (int8_t) *src++;\n                if (code >= 0) {\n                    code++;\n                    if (pixels + code > width ||\n                        ssrc + size - src < code) {\n                        av_log(s->avctx, AV_LOG_ERROR,\n                               \"Copy went out of bounds\\n\");\n                        return AVERROR_INVALIDDATA;\n                    }\n                    horizontal_fill(s, s->bpp * (s->avctx->pix_fmt == AV_PIX_FMT_PAL8),\n                                    dst, 1, src, 0, code, pixels);\n                    src    += code;\n                    pixels += code;\n                } else if (code != -128) { // -127..-1\n                    code = (-code) + 1;\n                    if (pixels + code > width) {\n                        av_log(s->avctx, AV_LOG_ERROR,\n                               \"Run went out of bounds\\n\");\n                        return AVERROR_INVALIDDATA;\n                    }\n                    c = *src++;\n                    horizontal_fill(s, s->bpp * (s->avctx->pix_fmt == AV_PIX_FMT_PAL8),\n                                    dst, 0, NULL, c, code, pixels);\n                    pixels += code;\n                }\n            }\n            if (s->fill_order) {\n                int i;\n                for (i = 0; i < width; i++)\n                    dst[i] = ff_reverse[dst[i]];\n            }\n            break;\n        }\n        if (is_yuv) {\n            unpack_yuv(s, p, dst, strip_start + line);\n            line += s->subsampling[1] - 1;\n        } else if (p->format == AV_PIX_FMT_GRAY12) {\n            unpack_gray(s, p, dst, strip_start + line, width, s->bpp);\n        }\n        dst += stride;\n    }\n    return 0;\n}\n\n/**\n * Map stored raw sensor values into linear reference values (see: DNG Specification - Chapter 5)\n */\nstatic uint16_t av_always_inline dng_process_color16(uint16_t value,\n                                                     const uint16_t *lut,\n                                                     uint16_t black_level,\n                                                     float scale_factor) {\n    float value_norm;\n\n    // Lookup table lookup\n    if (lut)\n        value = lut[value];\n\n    // Black level subtraction\n    value = av_clip_uint16_c((unsigned)value - black_level);\n\n    // Color scaling\n    value_norm = (float)value * scale_factor;\n\n    value = av_clip_uint16_c(value_norm * 65535);\n\n    return value;\n}\n\nstatic uint16_t av_always_inline dng_process_color8(uint16_t value,\n                                                    const uint16_t *lut,\n                                                    uint16_t black_level,\n                                                    float scale_factor) {\n    return dng_process_color16(value, lut, black_level, scale_factor) >> 8;\n}\n\nstatic void dng_blit(TiffContext *s, uint8_t *dst, int dst_stride,\n                     const uint8_t *src, int src_stride,\n                     int width, int height, int is_single_comp, int is_u16)\n{\n    int line, col;\n    float scale_factor;\n\n    scale_factor = 1.0f / (s->white_level - s->black_level);\n\n    if (is_single_comp) {\n        if (!is_u16)\n            return; /* <= 8bpp unsupported */\n\n        /* Image is double the width and half the height we need, each row comprises 2 rows of the output\n           (split vertically in the middle). */\n        for (line = 0; line < height / 2; line++) {\n            uint16_t *dst_u16 = (uint16_t *)dst;\n            uint16_t *src_u16 = (uint16_t *)src;\n\n            /* Blit first half of input row row to initial row of output */\n            for (col = 0; col < width; col++)\n                *dst_u16++ = dng_process_color16(*src_u16++, s->dng_lut, s->black_level, scale_factor);\n\n            /* Advance the destination pointer by a row (source pointer remains in the same place) */\n            dst += dst_stride * sizeof(uint16_t);\n            dst_u16 = (uint16_t *)dst;\n\n            /* Blit second half of input row row to next row of output */\n            for (col = 0; col < width; col++)\n                *dst_u16++ = dng_process_color16(*src_u16++, s->dng_lut, s->black_level, scale_factor);\n\n            dst += dst_stride * sizeof(uint16_t);\n            src += src_stride * sizeof(uint16_t);\n        }\n    } else {\n        /* Input and output image are the same size and the MJpeg decoder has done per-component\n           deinterleaving, so blitting here is straightforward. */\n        if (is_u16) {\n            for (line = 0; line < height; line++) {\n                uint16_t *dst_u16 = (uint16_t *)dst;\n                uint16_t *src_u16 = (uint16_t *)src;\n\n                for (col = 0; col < width; col++)\n                    *dst_u16++ = dng_process_color16(*src_u16++, s->dng_lut, s->black_level, scale_factor);\n\n                dst += dst_stride * sizeof(uint16_t);\n                src += src_stride * sizeof(uint16_t);\n            }\n        } else {\n            for (line = 0; line < height; line++) {\n                uint8_t *dst_u8 = dst;\n                const uint8_t *src_u8 = src;\n\n                for (col = 0; col < width; col++)\n                    *dst_u8++ = dng_process_color8(*src_u8++, s->dng_lut, s->black_level, scale_factor);\n\n                dst += dst_stride;\n                src += src_stride;\n            }\n        }\n    }\n}\n\nstatic int dng_decode_jpeg(AVCodecContext *avctx, AVFrame *frame,\n                           int tile_byte_count, int dst_x, int dst_y, int w, int h)\n{\n    TiffContext *s = avctx->priv_data;\n    AVPacket jpkt;\n    uint8_t *dst_data, *src_data;\n    uint32_t dst_offset; /* offset from dst buffer in pixels */\n    int is_single_comp, is_u16, pixel_size;\n    int ret;\n\n    if (tile_byte_count < 0 || tile_byte_count > bytestream2_get_bytes_left(&s->gb))\n        return AVERROR_INVALIDDATA;\n\n    /* Prepare a packet and send to the MJPEG decoder */\n    av_init_packet(&jpkt);\n    jpkt.data = (uint8_t*)s->gb.buffer;\n    jpkt.size = tile_byte_count;\n\n    if (s->is_bayer) {\n        MJpegDecodeContext *mjpegdecctx = s->avctx_mjpeg->priv_data;\n        /* We have to set this information here, there is no way to know if a given JPEG is a DNG-embedded\n           image or not from its own data (and we need that information when decoding it). */\n        mjpegdecctx->bayer = 1;\n    }\n\n    ret = avcodec_send_packet(s->avctx_mjpeg, &jpkt);\n    if (ret < 0) {\n        av_log(avctx, AV_LOG_ERROR, \"Error submitting a packet for decoding\\n\");\n        return ret;\n    }\n\n    ret = avcodec_receive_frame(s->avctx_mjpeg, s->jpgframe);\n    if (ret < 0) {\n        av_log(avctx, AV_LOG_ERROR, \"JPEG decoding error: %s.\\n\", av_err2str(ret));\n\n        /* Normally skip, error if explode */\n        if (avctx->err_recognition & AV_EF_EXPLODE)\n            return AVERROR_INVALIDDATA;\n        else\n            return 0;\n    }\n\n    is_u16 = (s->bpp > 8);\n\n    /* Copy the outputted tile's pixels from 'jpgframe' to 'frame' (final buffer) */\n\n    if (s->jpgframe->width  != s->avctx_mjpeg->width  ||\n        s->jpgframe->height != s->avctx_mjpeg->height ||\n        s->jpgframe->format != s->avctx_mjpeg->pix_fmt)\n        return AVERROR_INVALIDDATA;\n\n    /* See dng_blit for explanation */\n    if (s->avctx_mjpeg->width  == w * 2 &&\n        s->avctx_mjpeg->height == h / 2 &&\n        s->avctx_mjpeg->pix_fmt == AV_PIX_FMT_GRAY16LE) {\n        is_single_comp = 1;\n    } else if (s->avctx_mjpeg->width  >= w &&\n               s->avctx_mjpeg->height >= h &&\n               s->avctx_mjpeg->pix_fmt == (is_u16 ? AV_PIX_FMT_GRAY16 : AV_PIX_FMT_GRAY8)\n              ) {\n        is_single_comp = 0;\n    } else\n        return AVERROR_INVALIDDATA;\n\n    pixel_size = (is_u16 ? sizeof(uint16_t) : sizeof(uint8_t));\n\n    if (is_single_comp && !is_u16) {\n        av_log(s->avctx, AV_LOG_ERROR, \"DNGs with bpp <= 8 and 1 component are unsupported\\n\");\n        av_frame_unref(s->jpgframe);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    dst_offset = dst_x + frame->linesize[0] * dst_y / pixel_size;\n    dst_data = frame->data[0] + dst_offset * pixel_size;\n    src_data = s->jpgframe->data[0];\n\n    dng_blit(s,\n             dst_data,\n             frame->linesize[0] / pixel_size,\n             src_data,\n             s->jpgframe->linesize[0] / pixel_size,\n             w,\n             h,\n             is_single_comp,\n             is_u16);\n\n    av_frame_unref(s->jpgframe);\n\n    return 0;\n}\n\nstatic int dng_decode_tiles(AVCodecContext *avctx, AVFrame *frame, AVPacket *avpkt)\n{\n    TiffContext *s = avctx->priv_data;\n    int tile_idx;\n    int tile_offset_offset, tile_offset;\n    int tile_byte_count_offset, tile_byte_count;\n    int tile_count_x, tile_count_y;\n    int tile_width, tile_length;\n    int has_width_leftover, has_height_leftover;\n    int tile_x = 0, tile_y = 0;\n    int pos_x = 0, pos_y = 0;\n    int ret;\n\n    s->jpgframe->width  = s->tile_width;\n    s->jpgframe->height = s->tile_length;\n\n    s->avctx_mjpeg->width = s->tile_width;\n    s->avctx_mjpeg->height = s->tile_length;\n\n    has_width_leftover = (s->width % s->tile_width != 0);\n    has_height_leftover = (s->height % s->tile_length != 0);\n\n    /* Calculate tile counts (round up) */\n    tile_count_x = (s->width + s->tile_width - 1) / s->tile_width;\n    tile_count_y = (s->height + s->tile_length - 1) / s->tile_length;\n\n    /* Iterate over the number of tiles */\n    for (tile_idx = 0; tile_idx < s->tile_count; tile_idx++) {\n        tile_x = tile_idx % tile_count_x;\n        tile_y = tile_idx / tile_count_x;\n\n        if (has_width_leftover && tile_x == tile_count_x - 1) // If on the right-most tile\n            tile_width = s->width % s->tile_width;\n        else\n            tile_width = s->tile_width;\n\n        if (has_height_leftover && tile_y == tile_count_y - 1) // If on the bottom-most tile\n            tile_length = s->height % s->tile_length;\n        else\n            tile_length = s->tile_length;\n\n        /* Read tile offset */\n        tile_offset_offset = s->tile_offsets_offset + tile_idx * sizeof(int);\n        bytestream2_seek(&s->gb, tile_offset_offset, SEEK_SET);\n        tile_offset = ff_tget_long(&s->gb, s->le);\n\n        /* Read tile byte size */\n        tile_byte_count_offset = s->tile_byte_counts_offset + tile_idx * sizeof(int);\n        bytestream2_seek(&s->gb, tile_byte_count_offset, SEEK_SET);\n        tile_byte_count = ff_tget_long(&s->gb, s->le);\n\n        /* Seek to tile data */\n        bytestream2_seek(&s->gb, tile_offset, SEEK_SET);\n\n        /* Decode JPEG tile and copy it in the reference frame */\n        ret = dng_decode_jpeg(avctx, frame, tile_byte_count, pos_x, pos_y, tile_width, tile_length);\n\n        if (ret < 0)\n            return ret;\n\n        /* Advance current positions */\n        pos_x += tile_width;\n        if (tile_x == tile_count_x - 1) { // If on the right edge\n            pos_x = 0;\n            pos_y += tile_length;\n        }\n    }\n\n    /* Frame is ready to be output */\n    frame->pict_type = AV_PICTURE_TYPE_I;\n    frame->key_frame = 1;\n\n    return avpkt->size;\n}\n\nstatic int dng_decode_strip(AVCodecContext *avctx, AVFrame *frame)\n{\n    TiffContext *s = avctx->priv_data;\n\n    s->jpgframe->width  = s->width;\n    s->jpgframe->height = s->height;\n\n    s->avctx_mjpeg->width = s->width;\n    s->avctx_mjpeg->height = s->height;\n\n    return dng_decode_jpeg(avctx, frame, s->stripsize, 0, 0, s->width, s->height);\n}\n\nstatic int init_image(TiffContext *s, ThreadFrame *frame)\n{\n    int ret;\n    int create_gray_palette = 0;\n\n    // make sure there is no aliasing in the following switch\n    if (s->bpp >= 100 || s->bppcount >= 10) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"Unsupported image parameters: bpp=%d, bppcount=%d\\n\",\n               s->bpp, s->bppcount);\n        return AVERROR_INVALIDDATA;\n    }\n\n    switch (s->planar * 1000 + s->bpp * 10 + s->bppcount + s->is_bayer * 10000) {\n    case 11:\n        if (!s->palette_is_set) {\n            s->avctx->pix_fmt = AV_PIX_FMT_MONOBLACK;\n            break;\n        }\n    case 21:\n    case 41:\n        s->avctx->pix_fmt = AV_PIX_FMT_PAL8;\n        if (!s->palette_is_set) {\n            create_gray_palette = 1;\n        }\n        break;\n    case 81:\n        s->avctx->pix_fmt = s->palette_is_set ? AV_PIX_FMT_PAL8 : AV_PIX_FMT_GRAY8;\n        break;\n    case 121:\n        s->avctx->pix_fmt = AV_PIX_FMT_GRAY12;\n        break;\n    case 10081:\n        switch (AV_RL32(s->pattern)) {\n        case 0x02010100:\n            s->avctx->pix_fmt = AV_PIX_FMT_BAYER_RGGB8;\n            break;\n        case 0x00010102:\n            s->avctx->pix_fmt = AV_PIX_FMT_BAYER_BGGR8;\n            break;\n        case 0x01000201:\n            s->avctx->pix_fmt = AV_PIX_FMT_BAYER_GBRG8;\n            break;\n        case 0x01020001:\n            s->avctx->pix_fmt = AV_PIX_FMT_BAYER_GRBG8;\n            break;\n        default:\n            av_log(s->avctx, AV_LOG_ERROR, \"Unsupported Bayer pattern: 0x%X\\n\",\n                   AV_RL32(s->pattern));\n            return AVERROR_PATCHWELCOME;\n        }\n        break;\n    case 10101:\n    case 10121:\n    case 10141:\n    case 10161:\n        switch (AV_RL32(s->pattern)) {\n        case 0x02010100:\n            s->avctx->pix_fmt = AV_PIX_FMT_BAYER_RGGB16;\n            break;\n        case 0x00010102:\n            s->avctx->pix_fmt = AV_PIX_FMT_BAYER_BGGR16;\n            break;\n        case 0x01000201:\n            s->avctx->pix_fmt = AV_PIX_FMT_BAYER_GBRG16;\n            break;\n        case 0x01020001:\n            s->avctx->pix_fmt = AV_PIX_FMT_BAYER_GRBG16;\n            break;\n        default:\n            av_log(s->avctx, AV_LOG_ERROR, \"Unsupported Bayer pattern: 0x%X\\n\",\n                   AV_RL32(s->pattern));\n            return AVERROR_PATCHWELCOME;\n        }\n        break;\n    case 243:\n        if (s->photometric == TIFF_PHOTOMETRIC_YCBCR) {\n            if (s->subsampling[0] == 1 && s->subsampling[1] == 1) {\n                s->avctx->pix_fmt = AV_PIX_FMT_YUV444P;\n            } else if (s->subsampling[0] == 2 && s->subsampling[1] == 1) {\n                s->avctx->pix_fmt = AV_PIX_FMT_YUV422P;\n            } else if (s->subsampling[0] == 4 && s->subsampling[1] == 1) {\n                s->avctx->pix_fmt = AV_PIX_FMT_YUV411P;\n            } else if (s->subsampling[0] == 1 && s->subsampling[1] == 2) {\n                s->avctx->pix_fmt = AV_PIX_FMT_YUV440P;\n            } else if (s->subsampling[0] == 2 && s->subsampling[1] == 2) {\n                s->avctx->pix_fmt = AV_PIX_FMT_YUV420P;\n            } else if (s->subsampling[0] == 4 && s->subsampling[1] == 4) {\n                s->avctx->pix_fmt = AV_PIX_FMT_YUV410P;\n            } else {\n                av_log(s->avctx, AV_LOG_ERROR, \"Unsupported YCbCr subsampling\\n\");\n                return AVERROR_PATCHWELCOME;\n            }\n        } else\n            s->avctx->pix_fmt = AV_PIX_FMT_RGB24;\n        break;\n    case 161:\n        s->avctx->pix_fmt = s->le ? AV_PIX_FMT_GRAY16LE : AV_PIX_FMT_GRAY16BE;\n        break;\n    case 162:\n        s->avctx->pix_fmt = AV_PIX_FMT_YA8;\n        break;\n    case 322:\n        s->avctx->pix_fmt = s->le ? AV_PIX_FMT_YA16LE : AV_PIX_FMT_YA16BE;\n        break;\n    case 324:\n        s->avctx->pix_fmt = s->photometric == TIFF_PHOTOMETRIC_SEPARATED ? AV_PIX_FMT_RGB0 : AV_PIX_FMT_RGBA;\n        break;\n    case 405:\n        if (s->photometric == TIFF_PHOTOMETRIC_SEPARATED)\n            s->avctx->pix_fmt = AV_PIX_FMT_RGBA;\n        else {\n            av_log(s->avctx, AV_LOG_ERROR,\n                \"bpp=40 without PHOTOMETRIC_SEPARATED is unsupported\\n\");\n            return AVERROR_PATCHWELCOME;\n        }\n        break;\n    case 483:\n        s->avctx->pix_fmt = s->le ? AV_PIX_FMT_RGB48LE  : AV_PIX_FMT_RGB48BE;\n        break;\n    case 644:\n        s->avctx->pix_fmt = s->le ? AV_PIX_FMT_RGBA64LE  : AV_PIX_FMT_RGBA64BE;\n        break;\n    case 1243:\n        s->avctx->pix_fmt = AV_PIX_FMT_GBRP;\n        break;\n    case 1324:\n        s->avctx->pix_fmt = AV_PIX_FMT_GBRAP;\n        break;\n    case 1483:\n        s->avctx->pix_fmt = s->le ? AV_PIX_FMT_GBRP16LE : AV_PIX_FMT_GBRP16BE;\n        break;\n    case 1644:\n        s->avctx->pix_fmt = s->le ? AV_PIX_FMT_GBRAP16LE : AV_PIX_FMT_GBRAP16BE;\n        break;\n    default:\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"This format is not supported (bpp=%d, bppcount=%d)\\n\",\n               s->bpp, s->bppcount);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (s->photometric == TIFF_PHOTOMETRIC_YCBCR) {\n        const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s->avctx->pix_fmt);\n        if((desc->flags & AV_PIX_FMT_FLAG_RGB) ||\n           !(desc->flags & AV_PIX_FMT_FLAG_PLANAR) ||\n           desc->nb_components < 3) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Unsupported YCbCr variant\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n    }\n\n    if (s->width != s->avctx->width || s->height != s->avctx->height) {\n        ret = ff_set_dimensions(s->avctx, s->width, s->height);\n        if (ret < 0)\n            return ret;\n    }\n    if ((ret = ff_thread_get_buffer(s->avctx, frame, 0)) < 0)\n        return ret;\n    if (s->avctx->pix_fmt == AV_PIX_FMT_PAL8) {\n        if (!create_gray_palette)\n            memcpy(frame->f->data[1], s->palette, sizeof(s->palette));\n        else {\n            /* make default grayscale pal */\n            int i;\n            uint32_t *pal = (uint32_t *)frame->f->data[1];\n            for (i = 0; i < 1<<s->bpp; i++)\n                pal[i] = 0xFFU << 24 | i * 255 / ((1<<s->bpp) - 1) * 0x010101;\n        }\n    }\n    return 0;\n}\n\nstatic void set_sar(TiffContext *s, unsigned tag, unsigned num, unsigned den)\n{\n    int offset = tag == TIFF_YRES ? 2 : 0;\n    s->res[offset++] = num;\n    s->res[offset]   = den;\n    if (s->res[0] && s->res[1] && s->res[2] && s->res[3]) {\n        uint64_t num = s->res[2] * (uint64_t)s->res[1];\n        uint64_t den = s->res[0] * (uint64_t)s->res[3];\n        if (num > INT64_MAX || den > INT64_MAX) {\n            num = num >> 1;\n            den = den >> 1;\n        }\n        av_reduce(&s->avctx->sample_aspect_ratio.num, &s->avctx->sample_aspect_ratio.den,\n                  num, den, INT32_MAX);\n        if (!s->avctx->sample_aspect_ratio.den)\n            s->avctx->sample_aspect_ratio = (AVRational) {0, 1};\n    }\n}\n\nstatic int tiff_decode_tag(TiffContext *s, AVFrame *frame)\n{\n    AVFrameSideData *sd;\n    GetByteContext gb_temp;\n    unsigned tag, type, count, off, value = 0, value2 = 1; // value2 is a denominator so init. to 1\n    int i, start;\n    int pos;\n    int ret;\n    double *dp;\n\n    ret = ff_tread_tag(&s->gb, s->le, &tag, &type, &count, &start);\n    if (ret < 0) {\n        goto end;\n    }\n    if (tag <= s->last_tag)\n        return AVERROR_INVALIDDATA;\n\n    // We ignore TIFF_STRIP_SIZE as it is sometimes in the logic but wrong order around TIFF_STRIP_OFFS\n    if (tag != TIFF_STRIP_SIZE)\n        s->last_tag = tag;\n\n    off = bytestream2_tell(&s->gb);\n    if (count == 1) {\n        switch (type) {\n        case TIFF_BYTE:\n        case TIFF_SHORT:\n        case TIFF_LONG:\n            value = ff_tget(&s->gb, type, s->le);\n            break;\n        case TIFF_RATIONAL:\n            value  = ff_tget(&s->gb, TIFF_LONG, s->le);\n            value2 = ff_tget(&s->gb, TIFF_LONG, s->le);\n            if (!value2) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Invalid denominator in rational\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n\n            break;\n        case TIFF_STRING:\n            if (count <= 4) {\n                break;\n            }\n        default:\n            value = UINT_MAX;\n        }\n    }\n\n    switch (tag) {\n    case TIFF_SUBFILE:\n        s->is_thumbnail = (value != 0);\n        break;\n    case TIFF_WIDTH:\n        s->width = value;\n        break;\n    case TIFF_HEIGHT:\n        s->height = value;\n        break;\n    case TIFF_BPP:\n        if (count > 5 || count <= 0) {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"This format is not supported (bpp=%d, %d components)\\n\",\n                   value, count);\n            return AVERROR_INVALIDDATA;\n        }\n        s->bppcount = count;\n        if (count == 1)\n            s->bpp = value;\n        else {\n            switch (type) {\n            case TIFF_BYTE:\n            case TIFF_SHORT:\n            case TIFF_LONG:\n                s->bpp = 0;\n                if (bytestream2_get_bytes_left(&s->gb) < type_sizes[type] * count)\n                    return AVERROR_INVALIDDATA;\n                for (i = 0; i < count; i++)\n                    s->bpp += ff_tget(&s->gb, type, s->le);\n                break;\n            default:\n                s->bpp = -1;\n            }\n        }\n        break;\n    case TIFF_SAMPLES_PER_PIXEL:\n        if (count != 1) {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"Samples per pixel requires a single value, many provided\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        if (value > 5 || value <= 0) {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"Invalid samples per pixel %d\\n\", value);\n            return AVERROR_INVALIDDATA;\n        }\n        if (s->bppcount == 1)\n            s->bpp *= value;\n        s->bppcount = value;\n        break;\n    case TIFF_COMPR:\n        s->compr     = value;\n        av_log(s->avctx, AV_LOG_DEBUG, \"compression: %d\\n\", s->compr);\n        s->predictor = 0;\n        switch (s->compr) {\n        case TIFF_RAW:\n        case TIFF_PACKBITS:\n        case TIFF_LZW:\n        case TIFF_CCITT_RLE:\n            break;\n        case TIFF_G3:\n        case TIFF_G4:\n            s->fax_opts = 0;\n            break;\n        case TIFF_DEFLATE:\n        case TIFF_ADOBE_DEFLATE:\n#if CONFIG_ZLIB\n            break;\n#else\n            av_log(s->avctx, AV_LOG_ERROR, \"Deflate: ZLib not compiled in\\n\");\n            return AVERROR(ENOSYS);\n#endif\n        case TIFF_JPEG:\n        case TIFF_NEWJPEG:\n            s->is_jpeg = 1;\n            break;\n        case TIFF_LZMA:\n#if CONFIG_LZMA\n            break;\n#else\n            av_log(s->avctx, AV_LOG_ERROR, \"LZMA not compiled in\\n\");\n            return AVERROR(ENOSYS);\n#endif\n        default:\n            av_log(s->avctx, AV_LOG_ERROR, \"Unknown compression method %i\\n\",\n                   s->compr);\n            return AVERROR_INVALIDDATA;\n        }\n        break;\n    case TIFF_ROWSPERSTRIP:\n        if (!value || (type == TIFF_LONG && value == UINT_MAX))\n            value = s->height;\n        s->rps = FFMIN(value, s->height);\n        break;\n    case TIFF_STRIP_OFFS:\n        if (count == 1) {\n            if (value > INT_MAX) {\n                av_log(s->avctx, AV_LOG_ERROR,\n                    \"strippos %u too large\\n\", value);\n                return AVERROR_INVALIDDATA;\n            }\n            s->strippos = 0;\n            s->stripoff = value;\n        } else\n            s->strippos = off;\n        s->strips = count;\n        if (s->strips == 1)\n            s->rps = s->height;\n        s->sot = type;\n        break;\n    case TIFF_STRIP_SIZE:\n        if (count == 1) {\n            if (value > INT_MAX) {\n                av_log(s->avctx, AV_LOG_ERROR,\n                    \"stripsize %u too large\\n\", value);\n                return AVERROR_INVALIDDATA;\n            }\n            s->stripsizesoff = 0;\n            s->stripsize     = value;\n            s->strips        = 1;\n        } else {\n            s->stripsizesoff = off;\n        }\n        s->strips = count;\n        s->sstype = type;\n        break;\n    case TIFF_XRES:\n    case TIFF_YRES:\n        set_sar(s, tag, value, value2);\n        break;\n    case TIFF_TILE_OFFSETS:\n        s->tile_offsets_offset = off;\n        s->tile_count = count;\n        s->is_tiled = 1;\n        break;\n    case TIFF_TILE_BYTE_COUNTS:\n        s->tile_byte_counts_offset = off;\n        break;\n    case TIFF_TILE_LENGTH:\n        s->tile_length = value;\n        break;\n    case TIFF_TILE_WIDTH:\n        s->tile_width = value;\n        break;\n    case TIFF_PREDICTOR:\n        s->predictor = value;\n        break;\n    case TIFF_SUB_IFDS:\n        if (count == 1)\n            s->sub_ifd = value;\n        else if (count > 1)\n            s->sub_ifd = ff_tget(&s->gb, TIFF_LONG, s->le); /** Only get the first SubIFD */\n        break;\n    case DNG_LINEARIZATION_TABLE:\n        if (count > FF_ARRAY_ELEMS(s->dng_lut))\n            return AVERROR_INVALIDDATA;\n        for (int i = 0; i < count; i++)\n            s->dng_lut[i] = ff_tget(&s->gb, type, s->le);\n        break;\n    case DNG_BLACK_LEVEL:\n        if (count > 1) {    /* Use the first value in the pattern (assume they're all the same) */\n            if (type == TIFF_RATIONAL) {\n                value  = ff_tget(&s->gb, TIFF_LONG, s->le);\n                value2 = ff_tget(&s->gb, TIFF_LONG, s->le);\n                if (!value2) {\n                    av_log(s->avctx, AV_LOG_ERROR, \"Invalid black level denominator\\n\");\n                    return AVERROR_INVALIDDATA;\n                }\n\n                s->black_level = value / value2;\n            } else\n                s->black_level = ff_tget(&s->gb, type, s->le);\n            av_log(s->avctx, AV_LOG_WARNING, \"Assuming black level pattern values are identical\\n\");\n        } else {\n            s->black_level = value / value2;\n        }\n        break;\n    case DNG_WHITE_LEVEL:\n        s->white_level = value;\n        break;\n    case TIFF_CFA_PATTERN_DIM:\n        if (count != 2 || (ff_tget(&s->gb, type, s->le) != 2 &&\n                           ff_tget(&s->gb, type, s->le) != 2)) {\n            av_log(s->avctx, AV_LOG_ERROR, \"CFA Pattern dimensions are not 2x2\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        break;\n    case TIFF_CFA_PATTERN:\n        s->is_bayer = 1;\n        s->pattern[0] = ff_tget(&s->gb, type, s->le);\n        s->pattern[1] = ff_tget(&s->gb, type, s->le);\n        s->pattern[2] = ff_tget(&s->gb, type, s->le);\n        s->pattern[3] = ff_tget(&s->gb, type, s->le);\n        break;\n    case TIFF_PHOTOMETRIC:\n        switch (value) {\n        case TIFF_PHOTOMETRIC_WHITE_IS_ZERO:\n        case TIFF_PHOTOMETRIC_BLACK_IS_ZERO:\n        case TIFF_PHOTOMETRIC_RGB:\n        case TIFF_PHOTOMETRIC_PALETTE:\n        case TIFF_PHOTOMETRIC_SEPARATED:\n        case TIFF_PHOTOMETRIC_YCBCR:\n        case TIFF_PHOTOMETRIC_CFA:\n        case TIFF_PHOTOMETRIC_LINEAR_RAW: // Used by DNG images\n            s->photometric = value;\n            break;\n        case TIFF_PHOTOMETRIC_ALPHA_MASK:\n        case TIFF_PHOTOMETRIC_CIE_LAB:\n        case TIFF_PHOTOMETRIC_ICC_LAB:\n        case TIFF_PHOTOMETRIC_ITU_LAB:\n        case TIFF_PHOTOMETRIC_LOG_L:\n        case TIFF_PHOTOMETRIC_LOG_LUV:\n            avpriv_report_missing_feature(s->avctx,\n                                          \"PhotometricInterpretation 0x%04X\",\n                                          value);\n            return AVERROR_PATCHWELCOME;\n        default:\n            av_log(s->avctx, AV_LOG_ERROR, \"PhotometricInterpretation %u is \"\n                   \"unknown\\n\", value);\n            return AVERROR_INVALIDDATA;\n        }\n        break;\n    case TIFF_FILL_ORDER:\n        if (value < 1 || value > 2) {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"Unknown FillOrder value %d, trying default one\\n\", value);\n            value = 1;\n        }\n        s->fill_order = value - 1;\n        break;\n    case TIFF_PAL: {\n        GetByteContext pal_gb[3];\n        off = type_sizes[type];\n        if (count / 3 > 256 ||\n            bytestream2_get_bytes_left(&s->gb) < count / 3 * off * 3)\n            return AVERROR_INVALIDDATA;\n\n        pal_gb[0] = pal_gb[1] = pal_gb[2] = s->gb;\n        bytestream2_skip(&pal_gb[1], count / 3 * off);\n        bytestream2_skip(&pal_gb[2], count / 3 * off * 2);\n\n        off = (type_sizes[type] - 1) << 3;\n        if (off > 31U) {\n            av_log(s->avctx, AV_LOG_ERROR, \"palette shift %d is out of range\\n\", off);\n            return AVERROR_INVALIDDATA;\n        }\n\n        for (i = 0; i < count / 3; i++) {\n            uint32_t p = 0xFF000000;\n            p |= (ff_tget(&pal_gb[0], type, s->le) >> off) << 16;\n            p |= (ff_tget(&pal_gb[1], type, s->le) >> off) << 8;\n            p |=  ff_tget(&pal_gb[2], type, s->le) >> off;\n            s->palette[i] = p;\n        }\n        s->palette_is_set = 1;\n        break;\n    }\n    case TIFF_PLANAR:\n        s->planar = value == 2;\n        break;\n    case TIFF_YCBCR_SUBSAMPLING:\n        if (count != 2) {\n            av_log(s->avctx, AV_LOG_ERROR, \"subsample count invalid\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        for (i = 0; i < count; i++) {\n            s->subsampling[i] = ff_tget(&s->gb, type, s->le);\n            if (s->subsampling[i] <= 0) {\n                av_log(s->avctx, AV_LOG_ERROR, \"subsampling %d is invalid\\n\", s->subsampling[i]);\n                s->subsampling[i] = 1;\n                return AVERROR_INVALIDDATA;\n            }\n        }\n        break;\n    case TIFF_T4OPTIONS:\n        if (s->compr == TIFF_G3)\n            s->fax_opts = value;\n        break;\n    case TIFF_T6OPTIONS:\n        if (s->compr == TIFF_G4)\n            s->fax_opts = value;\n        break;\n#define ADD_METADATA(count, name, sep)\\\n    if ((ret = add_metadata(count, type, name, sep, s, frame)) < 0) {\\\n        av_log(s->avctx, AV_LOG_ERROR, \"Error allocating temporary buffer\\n\");\\\n        goto end;\\\n    }\n    case TIFF_MODEL_PIXEL_SCALE:\n        ADD_METADATA(count, \"ModelPixelScaleTag\", NULL);\n        break;\n    case TIFF_MODEL_TRANSFORMATION:\n        ADD_METADATA(count, \"ModelTransformationTag\", NULL);\n        break;\n    case TIFF_MODEL_TIEPOINT:\n        ADD_METADATA(count, \"ModelTiepointTag\", NULL);\n        break;\n    case TIFF_GEO_KEY_DIRECTORY:\n        if (s->geotag_count) {\n            avpriv_request_sample(s->avctx, \"Multiple geo key directories\");\n            return AVERROR_INVALIDDATA;\n        }\n        ADD_METADATA(1, \"GeoTIFF_Version\", NULL);\n        ADD_METADATA(2, \"GeoTIFF_Key_Revision\", \".\");\n        s->geotag_count   = ff_tget_short(&s->gb, s->le);\n        if (s->geotag_count > count / 4 - 1) {\n            s->geotag_count = count / 4 - 1;\n            av_log(s->avctx, AV_LOG_WARNING, \"GeoTIFF key directory buffer shorter than specified\\n\");\n        }\n        if (   bytestream2_get_bytes_left(&s->gb) < s->geotag_count * sizeof(int16_t) * 4\n            || s->geotag_count == 0) {\n            s->geotag_count = 0;\n            return -1;\n        }\n        s->geotags = av_mallocz_array(s->geotag_count, sizeof(TiffGeoTag));\n        if (!s->geotags) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Error allocating temporary buffer\\n\");\n            s->geotag_count = 0;\n            goto end;\n        }\n        for (i = 0; i < s->geotag_count; i++) {\n            s->geotags[i].key    = ff_tget_short(&s->gb, s->le);\n            s->geotags[i].type   = ff_tget_short(&s->gb, s->le);\n            s->geotags[i].count  = ff_tget_short(&s->gb, s->le);\n\n            if (!s->geotags[i].type)\n                s->geotags[i].val  = get_geokey_val(s->geotags[i].key, ff_tget_short(&s->gb, s->le));\n            else\n                s->geotags[i].offset = ff_tget_short(&s->gb, s->le);\n        }\n        break;\n    case TIFF_GEO_DOUBLE_PARAMS:\n        if (count >= INT_MAX / sizeof(int64_t))\n            return AVERROR_INVALIDDATA;\n        if (bytestream2_get_bytes_left(&s->gb) < count * sizeof(int64_t))\n            return AVERROR_INVALIDDATA;\n        dp = av_malloc_array(count, sizeof(double));\n        if (!dp) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Error allocating temporary buffer\\n\");\n            goto end;\n        }\n        for (i = 0; i < count; i++)\n            dp[i] = ff_tget_double(&s->gb, s->le);\n        for (i = 0; i < s->geotag_count; i++) {\n            if (s->geotags[i].type == TIFF_GEO_DOUBLE_PARAMS) {\n                if (s->geotags[i].count == 0\n                    || s->geotags[i].offset + s->geotags[i].count > count) {\n                    av_log(s->avctx, AV_LOG_WARNING, \"Invalid GeoTIFF key %d\\n\", s->geotags[i].key);\n                } else if (s->geotags[i].val) {\n                    av_log(s->avctx, AV_LOG_WARNING, \"Duplicate GeoTIFF key %d\\n\", s->geotags[i].key);\n                } else {\n                    char *ap = doubles2str(&dp[s->geotags[i].offset], s->geotags[i].count, \", \");\n                    if (!ap) {\n                        av_log(s->avctx, AV_LOG_ERROR, \"Error allocating temporary buffer\\n\");\n                        av_freep(&dp);\n                        return AVERROR(ENOMEM);\n                    }\n                    s->geotags[i].val = ap;\n                }\n            }\n        }\n        av_freep(&dp);\n        break;\n    case TIFF_GEO_ASCII_PARAMS:\n        pos = bytestream2_tell(&s->gb);\n        for (i = 0; i < s->geotag_count; i++) {\n            if (s->geotags[i].type == TIFF_GEO_ASCII_PARAMS) {\n                if (s->geotags[i].count == 0\n                    || s->geotags[i].offset +  s->geotags[i].count > count) {\n                    av_log(s->avctx, AV_LOG_WARNING, \"Invalid GeoTIFF key %d\\n\", s->geotags[i].key);\n                } else {\n                    char *ap;\n\n                    bytestream2_seek(&s->gb, pos + s->geotags[i].offset, SEEK_SET);\n                    if (bytestream2_get_bytes_left(&s->gb) < s->geotags[i].count)\n                        return AVERROR_INVALIDDATA;\n                    if (s->geotags[i].val)\n                        return AVERROR_INVALIDDATA;\n                    ap = av_malloc(s->geotags[i].count);\n                    if (!ap) {\n                        av_log(s->avctx, AV_LOG_ERROR, \"Error allocating temporary buffer\\n\");\n                        return AVERROR(ENOMEM);\n                    }\n                    bytestream2_get_bufferu(&s->gb, ap, s->geotags[i].count);\n                    ap[s->geotags[i].count - 1] = '\\0'; //replace the \"|\" delimiter with a 0 byte\n                    s->geotags[i].val = ap;\n                }\n            }\n        }\n        break;\n    case TIFF_ICC_PROFILE:\n        gb_temp = s->gb;\n        bytestream2_seek(&gb_temp, SEEK_SET, off);\n\n        if (bytestream2_get_bytes_left(&gb_temp) < count)\n            return AVERROR_INVALIDDATA;\n\n        sd = av_frame_new_side_data(frame, AV_FRAME_DATA_ICC_PROFILE, count);\n        if (!sd)\n            return AVERROR(ENOMEM);\n\n        bytestream2_get_bufferu(&gb_temp, sd->data, count);\n        break;\n    case TIFF_ARTIST:\n        ADD_METADATA(count, \"artist\", NULL);\n        break;\n    case TIFF_COPYRIGHT:\n        ADD_METADATA(count, \"copyright\", NULL);\n        break;\n    case TIFF_DATE:\n        ADD_METADATA(count, \"date\", NULL);\n        break;\n    case TIFF_DOCUMENT_NAME:\n        ADD_METADATA(count, \"document_name\", NULL);\n        break;\n    case TIFF_HOST_COMPUTER:\n        ADD_METADATA(count, \"computer\", NULL);\n        break;\n    case TIFF_IMAGE_DESCRIPTION:\n        ADD_METADATA(count, \"description\", NULL);\n        break;\n    case TIFF_MAKE:\n        ADD_METADATA(count, \"make\", NULL);\n        break;\n    case TIFF_MODEL:\n        ADD_METADATA(count, \"model\", NULL);\n        break;\n    case TIFF_PAGE_NAME:\n        ADD_METADATA(count, \"page_name\", NULL);\n        break;\n    case TIFF_PAGE_NUMBER:\n        ADD_METADATA(count, \"page_number\", \" / \");\n        // need to seek back to re-read the page number\n        bytestream2_seek(&s->gb, -count * sizeof(uint16_t), SEEK_CUR);\n        // read the page number\n        s->cur_page = ff_tget(&s->gb, TIFF_SHORT, s->le);\n        // get back to where we were before the previous seek\n        bytestream2_seek(&s->gb, count * sizeof(uint16_t) - sizeof(uint16_t), SEEK_CUR);\n        break;\n    case TIFF_SOFTWARE_NAME:\n        ADD_METADATA(count, \"software\", NULL);\n        break;\n    case DNG_VERSION:\n        if (count == 4) {\n            unsigned int ver[4];\n            ver[0] = ff_tget(&s->gb, type, s->le);\n            ver[1] = ff_tget(&s->gb, type, s->le);\n            ver[2] = ff_tget(&s->gb, type, s->le);\n            ver[3] = ff_tget(&s->gb, type, s->le);\n\n            av_log(s->avctx, AV_LOG_DEBUG, \"DNG file, version %u.%u.%u.%u\\n\",\n                ver[0], ver[1], ver[2], ver[3]);\n\n            tiff_set_type(s, TIFF_TYPE_DNG);\n        }\n        break;\n    case CINEMADNG_TIME_CODES:\n    case CINEMADNG_FRAME_RATE:\n    case CINEMADNG_T_STOP:\n    case CINEMADNG_REEL_NAME:\n    case CINEMADNG_CAMERA_LABEL:\n        tiff_set_type(s, TIFF_TYPE_CINEMADNG);\n        break;\n    default:\n        if (s->avctx->err_recognition & AV_EF_EXPLODE) {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"Unknown or unsupported tag %d/0x%0X\\n\",\n                   tag, tag);\n            return AVERROR_INVALIDDATA;\n        }\n    }\nend:\n    if (s->bpp > 64U) {\n        av_log(s->avctx, AV_LOG_ERROR,\n                \"This format is not supported (bpp=%d, %d components)\\n\",\n                s->bpp, count);\n        s->bpp = 0;\n        return AVERROR_INVALIDDATA;\n    }\n    bytestream2_seek(&s->gb, start, SEEK_SET);\n    return 0;\n}\n\nstatic int decode_frame(AVCodecContext *avctx,\n                        void *data, int *got_frame, AVPacket *avpkt)\n{\n    TiffContext *const s = avctx->priv_data;\n    AVFrame *const p = data;\n    ThreadFrame frame = { .f = data };\n    unsigned off, last_off;\n    int le, ret, plane, planes;\n    int i, j, entries, stride;\n    unsigned soff, ssize;\n    uint8_t *dst;\n    GetByteContext stripsizes;\n    GetByteContext stripdata;\n    int retry_for_subifd, retry_for_page;\n    int is_dng;\n    int has_tile_bits, has_strip_bits;\n\n    bytestream2_init(&s->gb, avpkt->data, avpkt->size);\n\n    // parse image header\n    if ((ret = ff_tdecode_header(&s->gb, &le, &off))) {\n        av_log(avctx, AV_LOG_ERROR, \"Invalid TIFF header\\n\");\n        return ret;\n    } else if (off >= UINT_MAX - 14 || avpkt->size < off + 14) {\n        av_log(avctx, AV_LOG_ERROR, \"IFD offset is greater than image size\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    s->le          = le;\n    // TIFF_BPP is not a required tag and defaults to 1\n\n    s->tiff_type   = TIFF_TYPE_TIFF;\nagain:\n    s->is_thumbnail = 0;\n    s->bppcount    = s->bpp = 1;\n    s->photometric = TIFF_PHOTOMETRIC_NONE;\n    s->compr       = TIFF_RAW;\n    s->fill_order  = 0;\n    s->white_level = 0;\n    s->is_bayer    = 0;\n    s->is_tiled    = 0;\n    s->is_jpeg     = 0;\n    s->cur_page    = 0;\n    s->last_tag    = 0;\n\n    for (i = 0; i < 65536; i++)\n        s->dng_lut[i] = i;\n\n    free_geotags(s);\n\n    // Reset these offsets so we can tell if they were set this frame\n    s->stripsizesoff = s->strippos = 0;\n    /* parse image file directory */\n    bytestream2_seek(&s->gb, off, SEEK_SET);\n    entries = ff_tget_short(&s->gb, le);\n    if (bytestream2_get_bytes_left(&s->gb) < entries * 12)\n        return AVERROR_INVALIDDATA;\n    for (i = 0; i < entries; i++) {\n        if ((ret = tiff_decode_tag(s, p)) < 0)\n            return ret;\n    }\n\n    if (s->get_thumbnail && !s->is_thumbnail) {\n        av_log(avctx, AV_LOG_INFO, \"No embedded thumbnail present\\n\");\n        return AVERROR_EOF;\n    }\n\n    /** whether we should process this IFD's SubIFD */\n    retry_for_subifd = s->sub_ifd && (s->get_subimage || (!s->get_thumbnail && s->is_thumbnail));\n    /** whether we should process this multi-page IFD's next page */\n    retry_for_page = s->get_page && s->cur_page + 1 < s->get_page;  // get_page is 1-indexed\n\n    last_off = off;\n    if (retry_for_page) {\n        // set offset to the next IFD\n        off = ff_tget_long(&s->gb, le);\n    } else if (retry_for_subifd) {\n        // set offset to the SubIFD\n        off = s->sub_ifd;\n    }\n\n    if (retry_for_subifd || retry_for_page) {\n        if (!off) {\n            av_log(avctx, AV_LOG_ERROR, \"Requested entry not found\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        if (off <= last_off) {\n            avpriv_request_sample(s->avctx, \"non increasing IFD offset\");\n            return AVERROR_INVALIDDATA;\n        }\n        if (off >= UINT_MAX - 14 || avpkt->size < off + 14) {\n            av_log(avctx, AV_LOG_ERROR, \"IFD offset is greater than image size\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        s->sub_ifd = 0;\n        goto again;\n    }\n\n    /* At this point we've decided on which (Sub)IFD to process */\n\n    is_dng = (s->tiff_type == TIFF_TYPE_DNG || s->tiff_type == TIFF_TYPE_CINEMADNG);\n\n    for (i = 0; i<s->geotag_count; i++) {\n        const char *keyname = get_geokey_name(s->geotags[i].key);\n        if (!keyname) {\n            av_log(avctx, AV_LOG_WARNING, \"Unknown or unsupported GeoTIFF key %d\\n\", s->geotags[i].key);\n            continue;\n        }\n        if (get_geokey_type(s->geotags[i].key) != s->geotags[i].type) {\n            av_log(avctx, AV_LOG_WARNING, \"Type of GeoTIFF key %d is wrong\\n\", s->geotags[i].key);\n            continue;\n        }\n        ret = av_dict_set(&p->metadata, keyname, s->geotags[i].val, 0);\n        if (ret<0) {\n            av_log(avctx, AV_LOG_ERROR, \"Writing metadata with key '%s' failed\\n\", keyname);\n            return ret;\n        }\n    }\n\n    if (is_dng) {\n        int bps;\n\n        if (s->bpp % s->bppcount)\n            return AVERROR_INVALIDDATA;\n        bps = s->bpp / s->bppcount;\n        if (bps < 8 || bps > 32)\n            return AVERROR_INVALIDDATA;\n\n        if (s->white_level == 0)\n            s->white_level = (1LL << bps) - 1; /* Default value as per the spec */\n\n        if (s->white_level <= s->black_level) {\n            av_log(avctx, AV_LOG_ERROR, \"BlackLevel (%\"PRId32\") must be less than WhiteLevel (%\"PRId32\")\\n\",\n                s->black_level, s->white_level);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (s->planar)\n            return AVERROR_PATCHWELCOME;\n    }\n\n    if (!s->is_tiled && !s->strippos && !s->stripoff) {\n        av_log(avctx, AV_LOG_ERROR, \"Image data is missing\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    has_tile_bits  = s->is_tiled || s->tile_byte_counts_offset || s->tile_offsets_offset || s->tile_width || s->tile_length || s->tile_count;\n    has_strip_bits = s->strippos || s->strips || s->stripoff || s->rps || s->sot || s->sstype || s->stripsize || s->stripsizesoff;\n\n    if (has_tile_bits && has_strip_bits) {\n        av_log(avctx, AV_LOG_WARNING, \"Tiled TIFF is not allowed to strip\\n\");\n    }\n\n    /* now we have the data and may start decoding */\n    if ((ret = init_image(s, &frame)) < 0)\n        return ret;\n\n    if (!s->is_tiled) {\n        if (s->strips == 1 && !s->stripsize) {\n            av_log(avctx, AV_LOG_WARNING, \"Image data size missing\\n\");\n            s->stripsize = avpkt->size - s->stripoff;\n        }\n\n        if (s->stripsizesoff) {\n            if (s->stripsizesoff >= (unsigned)avpkt->size)\n                return AVERROR_INVALIDDATA;\n            bytestream2_init(&stripsizes, avpkt->data + s->stripsizesoff,\n                            avpkt->size - s->stripsizesoff);\n        }\n        if (s->strippos) {\n            if (s->strippos >= (unsigned)avpkt->size)\n                return AVERROR_INVALIDDATA;\n            bytestream2_init(&stripdata, avpkt->data + s->strippos,\n                            avpkt->size - s->strippos);\n        }\n\n        if (s->rps <= 0 || s->rps % s->subsampling[1]) {\n            av_log(avctx, AV_LOG_ERROR, \"rps %d invalid\\n\", s->rps);\n            return AVERROR_INVALIDDATA;\n        }\n    }\n\n    if (s->photometric == TIFF_PHOTOMETRIC_LINEAR_RAW ||\n        s->photometric == TIFF_PHOTOMETRIC_CFA) {\n        p->color_trc = AVCOL_TRC_LINEAR;\n    } else if (s->photometric == TIFF_PHOTOMETRIC_BLACK_IS_ZERO) {\n        p->color_trc = AVCOL_TRC_GAMMA22;\n    }\n\n    /* Handle DNG images with JPEG-compressed tiles */\n\n    if (is_dng && s->is_tiled) {\n        if (!s->is_jpeg) {\n            avpriv_report_missing_feature(avctx, \"DNG uncompressed tiled images\");\n            return AVERROR_PATCHWELCOME;\n        } else if (!s->is_bayer) {\n            avpriv_report_missing_feature(avctx, \"DNG JPG-compressed tiled non-bayer-encoded images\");\n            return AVERROR_PATCHWELCOME;\n        } else {\n            if ((ret = dng_decode_tiles(avctx, (AVFrame*)data, avpkt)) > 0)\n                *got_frame = 1;\n            return ret;\n        }\n    }\n\n    /* Handle TIFF images and DNG images with uncompressed strips (non-tiled) */\n\n    planes = s->planar ? s->bppcount : 1;\n    for (plane = 0; plane < planes; plane++) {\n        uint8_t *five_planes = NULL;\n        int remaining = avpkt->size;\n        int decoded_height;\n        stride = p->linesize[plane];\n        dst = p->data[plane];\n        if (s->photometric == TIFF_PHOTOMETRIC_SEPARATED &&\n            s->avctx->pix_fmt == AV_PIX_FMT_RGBA) {\n            stride = stride * 5 / 4;\n            five_planes =\n            dst = av_malloc(stride * s->height);\n            if (!dst)\n                return AVERROR(ENOMEM);\n        }\n        for (i = 0; i < s->height; i += s->rps) {\n            if (i)\n                dst += s->rps * stride;\n            if (s->stripsizesoff)\n                ssize = ff_tget(&stripsizes, s->sstype, le);\n            else\n                ssize = s->stripsize;\n\n            if (s->strippos)\n                soff = ff_tget(&stripdata, s->sot, le);\n            else\n                soff = s->stripoff;\n\n            if (soff > avpkt->size || ssize > avpkt->size - soff || ssize > remaining) {\n                av_log(avctx, AV_LOG_ERROR, \"Invalid strip size/offset\\n\");\n                av_freep(&five_planes);\n                return AVERROR_INVALIDDATA;\n            }\n            remaining -= ssize;\n            if ((ret = tiff_unpack_strip(s, p, dst, stride, avpkt->data + soff, ssize, i,\n                                         FFMIN(s->rps, s->height - i))) < 0) {\n                if (avctx->err_recognition & AV_EF_EXPLODE) {\n                    av_freep(&five_planes);\n                    return ret;\n                }\n                break;\n            }\n        }\n        decoded_height = FFMIN(i, s->height);\n\n        if (s->predictor == 2) {\n            if (s->photometric == TIFF_PHOTOMETRIC_YCBCR) {\n                av_log(s->avctx, AV_LOG_ERROR, \"predictor == 2 with YUV is unsupported\");\n                return AVERROR_PATCHWELCOME;\n            }\n            dst   = five_planes ? five_planes : p->data[plane];\n            soff  = s->bpp >> 3;\n            if (s->planar)\n                soff  = FFMAX(soff / s->bppcount, 1);\n            ssize = s->width * soff;\n            if (s->avctx->pix_fmt == AV_PIX_FMT_RGB48LE ||\n                s->avctx->pix_fmt == AV_PIX_FMT_RGBA64LE ||\n                s->avctx->pix_fmt == AV_PIX_FMT_GRAY16LE ||\n                s->avctx->pix_fmt == AV_PIX_FMT_YA16LE ||\n                s->avctx->pix_fmt == AV_PIX_FMT_GBRP16LE ||\n                s->avctx->pix_fmt == AV_PIX_FMT_GBRAP16LE) {\n                for (i = 0; i < decoded_height; i++) {\n                    for (j = soff; j < ssize; j += 2)\n                        AV_WL16(dst + j, AV_RL16(dst + j) + AV_RL16(dst + j - soff));\n                    dst += stride;\n                }\n            } else if (s->avctx->pix_fmt == AV_PIX_FMT_RGB48BE ||\n                       s->avctx->pix_fmt == AV_PIX_FMT_RGBA64BE ||\n                       s->avctx->pix_fmt == AV_PIX_FMT_GRAY16BE ||\n                       s->avctx->pix_fmt == AV_PIX_FMT_YA16BE ||\n                       s->avctx->pix_fmt == AV_PIX_FMT_GBRP16BE ||\n                       s->avctx->pix_fmt == AV_PIX_FMT_GBRAP16BE) {\n                for (i = 0; i < decoded_height; i++) {\n                    for (j = soff; j < ssize; j += 2)\n                        AV_WB16(dst + j, AV_RB16(dst + j) + AV_RB16(dst + j - soff));\n                    dst += stride;\n                }\n            } else {\n                for (i = 0; i < decoded_height; i++) {\n                    for (j = soff; j < ssize; j++)\n                        dst[j] += dst[j - soff];\n                    dst += stride;\n                }\n            }\n        }\n\n        if (s->photometric == TIFF_PHOTOMETRIC_WHITE_IS_ZERO) {\n            int c = (s->avctx->pix_fmt == AV_PIX_FMT_PAL8 ? (1<<s->bpp) - 1 : 255);\n            dst = p->data[plane];\n            for (i = 0; i < s->height; i++) {\n                for (j = 0; j < stride; j++)\n                    dst[j] = c - dst[j];\n                dst += stride;\n            }\n        }\n\n        if (s->photometric == TIFF_PHOTOMETRIC_SEPARATED &&\n            (s->avctx->pix_fmt == AV_PIX_FMT_RGB0 || s->avctx->pix_fmt == AV_PIX_FMT_RGBA)) {\n            int x = s->avctx->pix_fmt == AV_PIX_FMT_RGB0 ? 4 : 5;\n            uint8_t *src = five_planes ? five_planes : p->data[plane];\n            dst = p->data[plane];\n            for (i = 0; i < s->height; i++) {\n                for (j = 0; j < s->width; j++) {\n                    int k =  255 - src[x * j + 3];\n                    int r = (255 - src[x * j    ]) * k;\n                    int g = (255 - src[x * j + 1]) * k;\n                    int b = (255 - src[x * j + 2]) * k;\n                    dst[4 * j    ] = r * 257 >> 16;\n                    dst[4 * j + 1] = g * 257 >> 16;\n                    dst[4 * j + 2] = b * 257 >> 16;\n                    dst[4 * j + 3] = s->avctx->pix_fmt == AV_PIX_FMT_RGBA ? src[x * j + 4] : 255;\n                }\n                src += stride;\n                dst += p->linesize[plane];\n            }\n            av_freep(&five_planes);\n        } else if (s->photometric == TIFF_PHOTOMETRIC_SEPARATED &&\n            s->avctx->pix_fmt == AV_PIX_FMT_RGBA64BE) {\n            dst = p->data[plane];\n            for (i = 0; i < s->height; i++) {\n                for (j = 0; j < s->width; j++) {\n                    uint64_t k =  65535 - AV_RB16(dst + 8 * j + 6);\n                    uint64_t r = (65535 - AV_RB16(dst + 8 * j    )) * k;\n                    uint64_t g = (65535 - AV_RB16(dst + 8 * j + 2)) * k;\n                    uint64_t b = (65535 - AV_RB16(dst + 8 * j + 4)) * k;\n                    AV_WB16(dst + 8 * j    , r * 65537 >> 32);\n                    AV_WB16(dst + 8 * j + 2, g * 65537 >> 32);\n                    AV_WB16(dst + 8 * j + 4, b * 65537 >> 32);\n                    AV_WB16(dst + 8 * j + 6, 65535);\n                }\n                dst += p->linesize[plane];\n            }\n        }\n    }\n\n    if (s->planar && s->bppcount > 2) {\n        FFSWAP(uint8_t*, p->data[0],     p->data[2]);\n        FFSWAP(int,      p->linesize[0], p->linesize[2]);\n        FFSWAP(uint8_t*, p->data[0],     p->data[1]);\n        FFSWAP(int,      p->linesize[0], p->linesize[1]);\n    }\n\n    if (s->is_bayer && s->white_level && s->bpp == 16 && !is_dng) {\n        uint16_t *dst = (uint16_t *)p->data[0];\n        for (i = 0; i < s->height; i++) {\n            for (j = 0; j < s->width; j++)\n                dst[j] = FFMIN((dst[j] / (float)s->white_level) * 65535, 65535);\n            dst += stride / 2;\n        }\n    }\n\n    *got_frame = 1;\n\n    return avpkt->size;\n}\n\nstatic av_cold int tiff_init(AVCodecContext *avctx)\n{\n    TiffContext *s = avctx->priv_data;\n    const AVCodec *codec;\n    int ret;\n\n    s->width  = 0;\n    s->height = 0;\n    s->subsampling[0] =\n    s->subsampling[1] = 1;\n    s->avctx  = avctx;\n    ff_lzw_decode_open(&s->lzw);\n    if (!s->lzw)\n        return AVERROR(ENOMEM);\n    ff_ccitt_unpack_init();\n\n    /* Allocate JPEG frame */\n    s->jpgframe = av_frame_alloc();\n    if (!s->jpgframe)\n        return AVERROR(ENOMEM);\n\n    /* Prepare everything needed for JPEG decoding */\n    codec = avcodec_find_decoder(AV_CODEC_ID_MJPEG);\n    if (!codec)\n        return AVERROR_BUG;\n    s->avctx_mjpeg = avcodec_alloc_context3(codec);\n    if (!s->avctx_mjpeg)\n        return AVERROR(ENOMEM);\n    s->avctx_mjpeg->flags = avctx->flags;\n    s->avctx_mjpeg->flags2 = avctx->flags2;\n    s->avctx_mjpeg->dct_algo = avctx->dct_algo;\n    s->avctx_mjpeg->idct_algo = avctx->idct_algo;\n    ret = avcodec_open2(s->avctx_mjpeg, codec, NULL);\n    if (ret < 0) {\n        return ret;\n    }\n\n    return 0;\n}\n\nstatic av_cold int tiff_end(AVCodecContext *avctx)\n{\n    TiffContext *const s = avctx->priv_data;\n\n    free_geotags(s);\n\n    ff_lzw_decode_close(&s->lzw);\n    av_freep(&s->deinvert_buf);\n    s->deinvert_buf_size = 0;\n    av_freep(&s->yuv_line);\n    s->yuv_line_size = 0;\n    av_freep(&s->fax_buffer);\n    s->fax_buffer_size = 0;\n    av_frame_free(&s->jpgframe);\n    avcodec_free_context(&s->avctx_mjpeg);\n    return 0;\n}\n\n#define OFFSET(x) offsetof(TiffContext, x)\nstatic const AVOption tiff_options[] = {\n    { \"subimage\", \"decode subimage instead if available\", OFFSET(get_subimage), AV_OPT_TYPE_BOOL, {.i64=0},  0, 1, AV_OPT_FLAG_DECODING_PARAM | AV_OPT_FLAG_VIDEO_PARAM },\n    { \"thumbnail\", \"decode embedded thumbnail subimage instead if available\", OFFSET(get_thumbnail), AV_OPT_TYPE_BOOL, {.i64=0},  0, 1, AV_OPT_FLAG_DECODING_PARAM | AV_OPT_FLAG_VIDEO_PARAM },\n    { \"page\", \"page number of multi-page image to decode (starting from 1)\", OFFSET(get_page), AV_OPT_TYPE_INT, {.i64=0}, 0, UINT16_MAX, AV_OPT_FLAG_DECODING_PARAM | AV_OPT_FLAG_VIDEO_PARAM },\n    { NULL },\n};\n\nstatic const AVClass tiff_decoder_class = {\n    .class_name = \"TIFF decoder\",\n    .item_name  = av_default_item_name,\n    .option     = tiff_options,\n    .version    = LIBAVUTIL_VERSION_INT,\n};\n\nAVCodec ff_tiff_decoder = {\n    .name           = \"tiff\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"TIFF image\"),\n    .type           = AVMEDIA_TYPE_VIDEO,\n    .id             = AV_CODEC_ID_TIFF,\n    .priv_data_size = sizeof(TiffContext),\n    .init           = tiff_init,\n    .close          = tiff_end,\n    .decode         = decode_frame,\n    .capabilities   = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS,\n    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,\n    .priv_class     = &tiff_decoder_class,\n};\n"], "fixing_code": ["/*\n * Copyright (c) 2006 Konstantin Shishkov\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * TIFF image decoder\n * @author Konstantin Shishkov\n */\n\n#include \"config.h\"\n#if CONFIG_ZLIB\n#include <zlib.h>\n#endif\n#if CONFIG_LZMA\n#define LZMA_API_STATIC\n#include <lzma.h>\n#endif\n\n#include \"libavutil/attributes.h\"\n#include \"libavutil/avstring.h\"\n#include \"libavutil/error.h\"\n#include \"libavutil/intreadwrite.h\"\n#include \"libavutil/imgutils.h\"\n#include \"libavutil/opt.h\"\n#include \"avcodec.h\"\n#include \"bytestream.h\"\n#include \"faxcompr.h\"\n#include \"internal.h\"\n#include \"lzw.h\"\n#include \"mathops.h\"\n#include \"tiff.h\"\n#include \"tiff_data.h\"\n#include \"mjpegdec.h\"\n#include \"thread.h\"\n#include \"get_bits.h\"\n\ntypedef struct TiffContext {\n    AVClass *class;\n    AVCodecContext *avctx;\n    GetByteContext gb;\n\n    /* JPEG decoding for DNG */\n    AVCodecContext *avctx_mjpeg; // wrapper context for MJPEG\n    AVFrame *jpgframe;           // decoded JPEG tile\n\n    int get_subimage;\n    uint16_t get_page;\n    int get_thumbnail;\n\n    enum TiffType tiff_type;\n    int width, height;\n    unsigned int bpp, bppcount;\n    uint32_t palette[256];\n    int palette_is_set;\n    int le;\n    enum TiffCompr compr;\n    enum TiffPhotometric photometric;\n    int planar;\n    int subsampling[2];\n    int fax_opts;\n    int predictor;\n    int fill_order;\n    uint32_t res[4];\n    int is_thumbnail;\n    unsigned last_tag;\n\n    int is_bayer;\n    uint8_t pattern[4];\n    unsigned black_level;\n    unsigned white_level;\n    uint16_t dng_lut[65536];\n\n    uint32_t sub_ifd;\n    uint16_t cur_page;\n\n    int strips, rps, sstype;\n    int sot;\n    int stripsizesoff, stripsize, stripoff, strippos;\n    LZWState *lzw;\n\n    /* Tile support */\n    int is_tiled;\n    int tile_byte_counts_offset, tile_offsets_offset;\n    int tile_width, tile_length;\n    int tile_count;\n\n    int is_jpeg;\n\n    uint8_t *deinvert_buf;\n    int deinvert_buf_size;\n    uint8_t *yuv_line;\n    unsigned int yuv_line_size;\n    uint8_t *fax_buffer;\n    unsigned int fax_buffer_size;\n\n    int geotag_count;\n    TiffGeoTag *geotags;\n} TiffContext;\n\nstatic void tiff_set_type(TiffContext *s, enum TiffType tiff_type) {\n    if (s->tiff_type < tiff_type) // Prioritize higher-valued entries\n        s->tiff_type = tiff_type;\n}\n\nstatic void free_geotags(TiffContext *const s)\n{\n    int i;\n    for (i = 0; i < s->geotag_count; i++) {\n        if (s->geotags[i].val)\n            av_freep(&s->geotags[i].val);\n    }\n    av_freep(&s->geotags);\n    s->geotag_count = 0;\n}\n\n#define RET_GEOKEY(TYPE, array, element)\\\n    if (key >= TIFF_##TYPE##_KEY_ID_OFFSET &&\\\n        key - TIFF_##TYPE##_KEY_ID_OFFSET < FF_ARRAY_ELEMS(ff_tiff_##array##_name_type_map))\\\n        return ff_tiff_##array##_name_type_map[key - TIFF_##TYPE##_KEY_ID_OFFSET].element;\n\nstatic const char *get_geokey_name(int key)\n{\n    RET_GEOKEY(VERT, vert, name);\n    RET_GEOKEY(PROJ, proj, name);\n    RET_GEOKEY(GEOG, geog, name);\n    RET_GEOKEY(CONF, conf, name);\n\n    return NULL;\n}\n\nstatic int get_geokey_type(int key)\n{\n    RET_GEOKEY(VERT, vert, type);\n    RET_GEOKEY(PROJ, proj, type);\n    RET_GEOKEY(GEOG, geog, type);\n    RET_GEOKEY(CONF, conf, type);\n\n    return AVERROR_INVALIDDATA;\n}\n\nstatic int cmp_id_key(const void *id, const void *k)\n{\n    return *(const int*)id - ((const TiffGeoTagKeyName*)k)->key;\n}\n\nstatic const char *search_keyval(const TiffGeoTagKeyName *keys, int n, int id)\n{\n    TiffGeoTagKeyName *r = bsearch(&id, keys, n, sizeof(keys[0]), cmp_id_key);\n    if(r)\n        return r->name;\n\n    return NULL;\n}\n\nstatic char *get_geokey_val(int key, int val)\n{\n    char *ap;\n\n    if (val == TIFF_GEO_KEY_UNDEFINED)\n        return av_strdup(\"undefined\");\n    if (val == TIFF_GEO_KEY_USER_DEFINED)\n        return av_strdup(\"User-Defined\");\n\n#define RET_GEOKEY_VAL(TYPE, array)\\\n    if (val >= TIFF_##TYPE##_OFFSET &&\\\n        val - TIFF_##TYPE##_OFFSET < FF_ARRAY_ELEMS(ff_tiff_##array##_codes))\\\n        return av_strdup(ff_tiff_##array##_codes[val - TIFF_##TYPE##_OFFSET]);\n\n    switch (key) {\n    case TIFF_GT_MODEL_TYPE_GEOKEY:\n        RET_GEOKEY_VAL(GT_MODEL_TYPE, gt_model_type);\n        break;\n    case TIFF_GT_RASTER_TYPE_GEOKEY:\n        RET_GEOKEY_VAL(GT_RASTER_TYPE, gt_raster_type);\n        break;\n    case TIFF_GEOG_LINEAR_UNITS_GEOKEY:\n    case TIFF_PROJ_LINEAR_UNITS_GEOKEY:\n    case TIFF_VERTICAL_UNITS_GEOKEY:\n        RET_GEOKEY_VAL(LINEAR_UNIT, linear_unit);\n        break;\n    case TIFF_GEOG_ANGULAR_UNITS_GEOKEY:\n    case TIFF_GEOG_AZIMUTH_UNITS_GEOKEY:\n        RET_GEOKEY_VAL(ANGULAR_UNIT, angular_unit);\n        break;\n    case TIFF_GEOGRAPHIC_TYPE_GEOKEY:\n        RET_GEOKEY_VAL(GCS_TYPE, gcs_type);\n        RET_GEOKEY_VAL(GCSE_TYPE, gcse_type);\n        break;\n    case TIFF_GEOG_GEODETIC_DATUM_GEOKEY:\n        RET_GEOKEY_VAL(GEODETIC_DATUM, geodetic_datum);\n        RET_GEOKEY_VAL(GEODETIC_DATUM_E, geodetic_datum_e);\n        break;\n    case TIFF_GEOG_ELLIPSOID_GEOKEY:\n        RET_GEOKEY_VAL(ELLIPSOID, ellipsoid);\n        break;\n    case TIFF_GEOG_PRIME_MERIDIAN_GEOKEY:\n        RET_GEOKEY_VAL(PRIME_MERIDIAN, prime_meridian);\n        break;\n    case TIFF_PROJECTED_CS_TYPE_GEOKEY:\n        ap = av_strdup(search_keyval(ff_tiff_proj_cs_type_codes, FF_ARRAY_ELEMS(ff_tiff_proj_cs_type_codes), val));\n        if(ap) return ap;\n        break;\n    case TIFF_PROJECTION_GEOKEY:\n        ap = av_strdup(search_keyval(ff_tiff_projection_codes, FF_ARRAY_ELEMS(ff_tiff_projection_codes), val));\n        if(ap) return ap;\n        break;\n    case TIFF_PROJ_COORD_TRANS_GEOKEY:\n        RET_GEOKEY_VAL(COORD_TRANS, coord_trans);\n        break;\n    case TIFF_VERTICAL_CS_TYPE_GEOKEY:\n        RET_GEOKEY_VAL(VERT_CS, vert_cs);\n        RET_GEOKEY_VAL(ORTHO_VERT_CS, ortho_vert_cs);\n        break;\n\n    }\n\n    ap = av_malloc(14);\n    if (ap)\n        snprintf(ap, 14, \"Unknown-%d\", val);\n    return ap;\n}\n\nstatic char *doubles2str(double *dp, int count, const char *sep)\n{\n    int i;\n    char *ap, *ap0;\n    uint64_t component_len;\n    if (!sep) sep = \", \";\n    component_len = 24LL + strlen(sep);\n    if (count >= (INT_MAX - 1)/component_len)\n        return NULL;\n    ap = av_malloc(component_len * count + 1);\n    if (!ap)\n        return NULL;\n    ap0   = ap;\n    ap[0] = '\\0';\n    for (i = 0; i < count; i++) {\n        unsigned l = snprintf(ap, component_len, \"%.15g%s\", dp[i], sep);\n        if(l >= component_len) {\n            av_free(ap0);\n            return NULL;\n        }\n        ap += l;\n    }\n    ap0[strlen(ap0) - strlen(sep)] = '\\0';\n    return ap0;\n}\n\nstatic int add_metadata(int count, int type,\n                        const char *name, const char *sep, TiffContext *s, AVFrame *frame)\n{\n    switch(type) {\n    case TIFF_DOUBLE: return ff_tadd_doubles_metadata(count, name, sep, &s->gb, s->le, &frame->metadata);\n    case TIFF_SHORT : return ff_tadd_shorts_metadata(count, name, sep, &s->gb, s->le, 0, &frame->metadata);\n    case TIFF_STRING: return ff_tadd_string_metadata(count, name, &s->gb, s->le, &frame->metadata);\n    default         : return AVERROR_INVALIDDATA;\n    };\n}\n\nstatic void av_always_inline dng_blit(TiffContext *s, uint8_t *dst, int dst_stride,\n                                      const uint8_t *src, int src_stride, int width, int height,\n                                      int is_single_comp, int is_u16);\n\nstatic void av_always_inline horizontal_fill(TiffContext *s,\n                                             unsigned int bpp, uint8_t* dst,\n                                             int usePtr, const uint8_t *src,\n                                             uint8_t c, int width, int offset)\n{\n    switch (bpp) {\n    case 1:\n        while (--width >= 0) {\n            dst[(width+offset)*8+7] = (usePtr ? src[width] : c)      & 0x1;\n            dst[(width+offset)*8+6] = (usePtr ? src[width] : c) >> 1 & 0x1;\n            dst[(width+offset)*8+5] = (usePtr ? src[width] : c) >> 2 & 0x1;\n            dst[(width+offset)*8+4] = (usePtr ? src[width] : c) >> 3 & 0x1;\n            dst[(width+offset)*8+3] = (usePtr ? src[width] : c) >> 4 & 0x1;\n            dst[(width+offset)*8+2] = (usePtr ? src[width] : c) >> 5 & 0x1;\n            dst[(width+offset)*8+1] = (usePtr ? src[width] : c) >> 6 & 0x1;\n            dst[(width+offset)*8+0] = (usePtr ? src[width] : c) >> 7;\n        }\n        break;\n    case 2:\n        while (--width >= 0) {\n            dst[(width+offset)*4+3] = (usePtr ? src[width] : c) & 0x3;\n            dst[(width+offset)*4+2] = (usePtr ? src[width] : c) >> 2 & 0x3;\n            dst[(width+offset)*4+1] = (usePtr ? src[width] : c) >> 4 & 0x3;\n            dst[(width+offset)*4+0] = (usePtr ? src[width] : c) >> 6;\n        }\n        break;\n    case 4:\n        while (--width >= 0) {\n            dst[(width+offset)*2+1] = (usePtr ? src[width] : c) & 0xF;\n            dst[(width+offset)*2+0] = (usePtr ? src[width] : c) >> 4;\n        }\n        break;\n    case 10:\n    case 12:\n    case 14: {\n            uint16_t *dst16 = (uint16_t *)dst;\n            int is_dng = (s->tiff_type == TIFF_TYPE_DNG || s->tiff_type == TIFF_TYPE_CINEMADNG);\n            uint8_t shift = is_dng ? 0 : 16 - bpp;\n            GetBitContext gb;\n\n            init_get_bits8(&gb, src, width);\n            for (int i = 0; i < s->width; i++) {\n                dst16[i] = get_bits(&gb, bpp) << shift;\n            }\n        }\n        break;\n    default:\n        if (usePtr) {\n            memcpy(dst + offset, src, width);\n        } else {\n            memset(dst + offset, c, width);\n        }\n    }\n}\n\nstatic int deinvert_buffer(TiffContext *s, const uint8_t *src, int size)\n{\n    int i;\n\n    av_fast_padded_malloc(&s->deinvert_buf, &s->deinvert_buf_size, size);\n    if (!s->deinvert_buf)\n        return AVERROR(ENOMEM);\n    for (i = 0; i < size; i++)\n        s->deinvert_buf[i] = ff_reverse[src[i]];\n\n    return 0;\n}\n\nstatic void unpack_gray(TiffContext *s, AVFrame *p,\n                       const uint8_t *src, int lnum, int width, int bpp)\n{\n    GetBitContext gb;\n    uint16_t *dst = (uint16_t *)(p->data[0] + lnum * p->linesize[0]);\n\n    init_get_bits8(&gb, src, width);\n\n    for (int i = 0; i < s->width; i++) {\n        dst[i] = get_bits(&gb, bpp);\n    }\n}\n\nstatic void unpack_yuv(TiffContext *s, AVFrame *p,\n                       const uint8_t *src, int lnum)\n{\n    int i, j, k;\n    int w       = (s->width - 1) / s->subsampling[0] + 1;\n    uint8_t *pu = &p->data[1][lnum / s->subsampling[1] * p->linesize[1]];\n    uint8_t *pv = &p->data[2][lnum / s->subsampling[1] * p->linesize[2]];\n    if (s->width % s->subsampling[0] || s->height % s->subsampling[1]) {\n        for (i = 0; i < w; i++) {\n            for (j = 0; j < s->subsampling[1]; j++)\n                for (k = 0; k < s->subsampling[0]; k++)\n                    p->data[0][FFMIN(lnum + j, s->height-1) * p->linesize[0] +\n                               FFMIN(i * s->subsampling[0] + k, s->width-1)] = *src++;\n            *pu++ = *src++;\n            *pv++ = *src++;\n        }\n    }else{\n        for (i = 0; i < w; i++) {\n            for (j = 0; j < s->subsampling[1]; j++)\n                for (k = 0; k < s->subsampling[0]; k++)\n                    p->data[0][(lnum + j) * p->linesize[0] +\n                               i * s->subsampling[0] + k] = *src++;\n            *pu++ = *src++;\n            *pv++ = *src++;\n        }\n    }\n}\n\n#if CONFIG_ZLIB\nstatic int tiff_uncompress(uint8_t *dst, unsigned long *len, const uint8_t *src,\n                           int size)\n{\n    z_stream zstream = { 0 };\n    int zret;\n\n    zstream.next_in   = src;\n    zstream.avail_in  = size;\n    zstream.next_out  = dst;\n    zstream.avail_out = *len;\n    zret              = inflateInit(&zstream);\n    if (zret != Z_OK) {\n        av_log(NULL, AV_LOG_ERROR, \"Inflate init error: %d\\n\", zret);\n        return zret;\n    }\n    zret = inflate(&zstream, Z_SYNC_FLUSH);\n    inflateEnd(&zstream);\n    *len = zstream.total_out;\n    return zret == Z_STREAM_END ? Z_OK : zret;\n}\n\nstatic int tiff_unpack_zlib(TiffContext *s, AVFrame *p, uint8_t *dst, int stride,\n                            const uint8_t *src, int size, int width, int lines,\n                            int strip_start, int is_yuv)\n{\n    uint8_t *zbuf;\n    unsigned long outlen;\n    int ret, line;\n    outlen = width * lines;\n    zbuf   = av_malloc(outlen);\n    if (!zbuf)\n        return AVERROR(ENOMEM);\n    if (s->fill_order) {\n        if ((ret = deinvert_buffer(s, src, size)) < 0) {\n            av_free(zbuf);\n            return ret;\n        }\n        src = s->deinvert_buf;\n    }\n    ret = tiff_uncompress(zbuf, &outlen, src, size);\n    if (ret != Z_OK) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"Uncompressing failed (%lu of %lu) with error %d\\n\", outlen,\n               (unsigned long)width * lines, ret);\n        av_free(zbuf);\n        return AVERROR_UNKNOWN;\n    }\n    src = zbuf;\n    for (line = 0; line < lines; line++) {\n        if (s->bpp < 8 && s->avctx->pix_fmt == AV_PIX_FMT_PAL8) {\n            horizontal_fill(s, s->bpp, dst, 1, src, 0, width, 0);\n        } else {\n            memcpy(dst, src, width);\n        }\n        if (is_yuv) {\n            unpack_yuv(s, p, dst, strip_start + line);\n            line += s->subsampling[1] - 1;\n        }\n        dst += stride;\n        src += width;\n    }\n    av_free(zbuf);\n    return 0;\n}\n#endif\n\n#if CONFIG_LZMA\nstatic int tiff_uncompress_lzma(uint8_t *dst, uint64_t *len, const uint8_t *src,\n                                int size)\n{\n    lzma_stream stream = LZMA_STREAM_INIT;\n    lzma_ret ret;\n\n    stream.next_in   = (uint8_t *)src;\n    stream.avail_in  = size;\n    stream.next_out  = dst;\n    stream.avail_out = *len;\n    ret              = lzma_stream_decoder(&stream, UINT64_MAX, 0);\n    if (ret != LZMA_OK) {\n        av_log(NULL, AV_LOG_ERROR, \"LZMA init error: %d\\n\", ret);\n        return ret;\n    }\n    ret = lzma_code(&stream, LZMA_RUN);\n    lzma_end(&stream);\n    *len = stream.total_out;\n    return ret == LZMA_STREAM_END ? LZMA_OK : ret;\n}\n\nstatic int tiff_unpack_lzma(TiffContext *s, AVFrame *p, uint8_t *dst, int stride,\n                            const uint8_t *src, int size, int width, int lines,\n                            int strip_start, int is_yuv)\n{\n    uint64_t outlen = width * (uint64_t)lines;\n    int ret, line;\n    uint8_t *buf = av_malloc(outlen);\n    if (!buf)\n        return AVERROR(ENOMEM);\n    if (s->fill_order) {\n        if ((ret = deinvert_buffer(s, src, size)) < 0) {\n            av_free(buf);\n            return ret;\n        }\n        src = s->deinvert_buf;\n    }\n    ret = tiff_uncompress_lzma(buf, &outlen, src, size);\n    if (ret != LZMA_OK) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"Uncompressing failed (%\"PRIu64\" of %\"PRIu64\") with error %d\\n\", outlen,\n               (uint64_t)width * lines, ret);\n        av_free(buf);\n        return AVERROR_UNKNOWN;\n    }\n    src = buf;\n    for (line = 0; line < lines; line++) {\n        if (s->bpp < 8 && s->avctx->pix_fmt == AV_PIX_FMT_PAL8) {\n            horizontal_fill(s, s->bpp, dst, 1, src, 0, width, 0);\n        } else {\n            memcpy(dst, src, width);\n        }\n        if (is_yuv) {\n            unpack_yuv(s, p, dst, strip_start + line);\n            line += s->subsampling[1] - 1;\n        }\n        dst += stride;\n        src += width;\n    }\n    av_free(buf);\n    return 0;\n}\n#endif\n\nstatic int tiff_unpack_fax(TiffContext *s, uint8_t *dst, int stride,\n                           const uint8_t *src, int size, int width, int lines)\n{\n    int i, ret = 0;\n    int line;\n    uint8_t *src2;\n\n    av_fast_padded_malloc(&s->fax_buffer, &s->fax_buffer_size, size);\n    src2 = s->fax_buffer;\n\n    if (!src2) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"Error allocating temporary buffer\\n\");\n        return AVERROR(ENOMEM);\n    }\n\n    if (!s->fill_order) {\n        memcpy(src2, src, size);\n    } else {\n        for (i = 0; i < size; i++)\n            src2[i] = ff_reverse[src[i]];\n    }\n    memset(src2 + size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n    ret = ff_ccitt_unpack(s->avctx, src2, size, dst, lines, stride,\n                          s->compr, s->fax_opts);\n    if (s->bpp < 8 && s->avctx->pix_fmt == AV_PIX_FMT_PAL8)\n        for (line = 0; line < lines; line++) {\n            horizontal_fill(s, s->bpp, dst, 1, dst, 0, width, 0);\n            dst += stride;\n        }\n    return ret;\n}\n\nstatic int dng_decode_strip(AVCodecContext *avctx, AVFrame *frame);\n\nstatic int tiff_unpack_strip(TiffContext *s, AVFrame *p, uint8_t *dst, int stride,\n                             const uint8_t *src, int size, int strip_start, int lines)\n{\n    PutByteContext pb;\n    int c, line, pixels, code, ret;\n    const uint8_t *ssrc = src;\n    int width = ((s->width * s->bpp) + 7) >> 3;\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(p->format);\n    int is_yuv = !(desc->flags & AV_PIX_FMT_FLAG_RGB) &&\n                 (desc->flags & AV_PIX_FMT_FLAG_PLANAR) &&\n                 desc->nb_components >= 3;\n    int is_dng;\n\n    if (s->planar)\n        width /= s->bppcount;\n\n    if (size <= 0)\n        return AVERROR_INVALIDDATA;\n\n    if (is_yuv) {\n        int bytes_per_row = (((s->width - 1) / s->subsampling[0] + 1) * s->bpp *\n                            s->subsampling[0] * s->subsampling[1] + 7) >> 3;\n        av_fast_padded_malloc(&s->yuv_line, &s->yuv_line_size, bytes_per_row);\n        if (s->yuv_line == NULL) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Not enough memory\\n\");\n            return AVERROR(ENOMEM);\n        }\n        dst = s->yuv_line;\n        stride = 0;\n\n        width = (s->width - 1) / s->subsampling[0] + 1;\n        width = width * s->subsampling[0] * s->subsampling[1] + 2*width;\n        av_assert0(width <= bytes_per_row);\n        av_assert0(s->bpp == 24);\n    }\n    if (s->is_bayer) {\n        av_assert0(width == (s->bpp * s->width + 7) >> 3);\n    }\n    if (p->format == AV_PIX_FMT_GRAY12) {\n        av_fast_padded_malloc(&s->yuv_line, &s->yuv_line_size, width);\n        if (s->yuv_line == NULL) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Not enough memory\\n\");\n            return AVERROR(ENOMEM);\n        }\n        dst = s->yuv_line;\n        stride = 0;\n    }\n\n    if (s->compr == TIFF_DEFLATE || s->compr == TIFF_ADOBE_DEFLATE) {\n#if CONFIG_ZLIB\n        return tiff_unpack_zlib(s, p, dst, stride, src, size, width, lines,\n                                strip_start, is_yuv);\n#else\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"zlib support not enabled, \"\n               \"deflate compression not supported\\n\");\n        return AVERROR(ENOSYS);\n#endif\n    }\n    if (s->compr == TIFF_LZMA) {\n#if CONFIG_LZMA\n        return tiff_unpack_lzma(s, p, dst, stride, src, size, width, lines,\n                                strip_start, is_yuv);\n#else\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"LZMA support not enabled\\n\");\n        return AVERROR(ENOSYS);\n#endif\n    }\n    if (s->compr == TIFF_LZW) {\n        if (s->fill_order) {\n            if ((ret = deinvert_buffer(s, src, size)) < 0)\n                return ret;\n            ssrc = src = s->deinvert_buf;\n        }\n        if (size > 1 && !src[0] && (src[1]&1)) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Old style LZW is unsupported\\n\");\n        }\n        if ((ret = ff_lzw_decode_init(s->lzw, 8, src, size, FF_LZW_TIFF)) < 0) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Error initializing LZW decoder\\n\");\n            return ret;\n        }\n        for (line = 0; line < lines; line++) {\n            pixels = ff_lzw_decode(s->lzw, dst, width);\n            if (pixels < width) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Decoded only %i bytes of %i\\n\",\n                       pixels, width);\n                return AVERROR_INVALIDDATA;\n            }\n            if (s->bpp < 8 && s->avctx->pix_fmt == AV_PIX_FMT_PAL8)\n                horizontal_fill(s, s->bpp, dst, 1, dst, 0, width, 0);\n            if (is_yuv) {\n                unpack_yuv(s, p, dst, strip_start + line);\n                line += s->subsampling[1] - 1;\n            } else if (p->format == AV_PIX_FMT_GRAY12) {\n                unpack_gray(s, p, dst, strip_start + line, width, s->bpp);\n            }\n            dst += stride;\n        }\n        return 0;\n    }\n    if (s->compr == TIFF_CCITT_RLE ||\n        s->compr == TIFF_G3        ||\n        s->compr == TIFF_G4) {\n        if (is_yuv || p->format == AV_PIX_FMT_GRAY12)\n            return AVERROR_INVALIDDATA;\n\n        return tiff_unpack_fax(s, dst, stride, src, size, width, lines);\n    }\n\n    bytestream2_init(&s->gb, src, size);\n    bytestream2_init_writer(&pb, dst, is_yuv ? s->yuv_line_size : (stride * lines));\n\n    is_dng = (s->tiff_type == TIFF_TYPE_DNG || s->tiff_type == TIFF_TYPE_CINEMADNG);\n\n    /* Decode JPEG-encoded DNGs with strips */\n    if (s->compr == TIFF_NEWJPEG && is_dng) {\n        if (s->strips > 1) {\n            av_log(s->avctx, AV_LOG_ERROR, \"More than one DNG JPEG strips unsupported\\n\");\n            return AVERROR_PATCHWELCOME;\n        }\n        if ((ret = dng_decode_strip(s->avctx, p)) < 0)\n            return ret;\n        return 0;\n    }\n\n    if (is_dng && stride == 0)\n        return AVERROR_INVALIDDATA;\n\n    for (line = 0; line < lines; line++) {\n        if (src - ssrc > size) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Source data overread\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (bytestream2_get_bytes_left(&s->gb) == 0 || bytestream2_get_eof(&pb))\n            break;\n        bytestream2_seek_p(&pb, stride * line, SEEK_SET);\n        switch (s->compr) {\n        case TIFF_RAW:\n            if (ssrc + size - src < width)\n                return AVERROR_INVALIDDATA;\n\n            if (!s->fill_order) {\n                horizontal_fill(s, s->bpp * (s->avctx->pix_fmt == AV_PIX_FMT_PAL8 || s->is_bayer),\n                                dst, 1, src, 0, width, 0);\n            } else {\n                int i;\n                for (i = 0; i < width; i++)\n                    dst[i] = ff_reverse[src[i]];\n            }\n\n            /* Color processing for DNG images with uncompressed strips (non-tiled) */\n            if (is_dng) {\n                int is_u16, pixel_size_bytes, pixel_size_bits, elements;\n\n                is_u16 = (s->bpp / s->bppcount > 8);\n                pixel_size_bits = (is_u16 ? 16 : 8);\n                pixel_size_bytes = (is_u16 ? sizeof(uint16_t) : sizeof(uint8_t));\n\n                elements = width / pixel_size_bytes * pixel_size_bits / s->bpp * s->bppcount; // need to account for [1, 16] bpp\n                av_assert0 (elements * pixel_size_bytes <= FFABS(stride));\n                dng_blit(s,\n                         dst,\n                         0, // no stride, only 1 line\n                         dst,\n                         0, // no stride, only 1 line\n                         elements,\n                         1,\n                         0, // single-component variation is only preset in JPEG-encoded DNGs\n                         is_u16);\n            }\n\n            src += width;\n            break;\n        case TIFF_PACKBITS:\n            for (pixels = 0; pixels < width;) {\n                if (ssrc + size - src < 2) {\n                    av_log(s->avctx, AV_LOG_ERROR, \"Read went out of bounds\\n\");\n                    return AVERROR_INVALIDDATA;\n                }\n                code = s->fill_order ? (int8_t) ff_reverse[*src++]: (int8_t) *src++;\n                if (code >= 0) {\n                    code++;\n                    if (pixels + code > width ||\n                        ssrc + size - src < code) {\n                        av_log(s->avctx, AV_LOG_ERROR,\n                               \"Copy went out of bounds\\n\");\n                        return AVERROR_INVALIDDATA;\n                    }\n                    horizontal_fill(s, s->bpp * (s->avctx->pix_fmt == AV_PIX_FMT_PAL8),\n                                    dst, 1, src, 0, code, pixels);\n                    src    += code;\n                    pixels += code;\n                } else if (code != -128) { // -127..-1\n                    code = (-code) + 1;\n                    if (pixels + code > width) {\n                        av_log(s->avctx, AV_LOG_ERROR,\n                               \"Run went out of bounds\\n\");\n                        return AVERROR_INVALIDDATA;\n                    }\n                    c = *src++;\n                    horizontal_fill(s, s->bpp * (s->avctx->pix_fmt == AV_PIX_FMT_PAL8),\n                                    dst, 0, NULL, c, code, pixels);\n                    pixels += code;\n                }\n            }\n            if (s->fill_order) {\n                int i;\n                for (i = 0; i < width; i++)\n                    dst[i] = ff_reverse[dst[i]];\n            }\n            break;\n        }\n        if (is_yuv) {\n            unpack_yuv(s, p, dst, strip_start + line);\n            line += s->subsampling[1] - 1;\n        } else if (p->format == AV_PIX_FMT_GRAY12) {\n            unpack_gray(s, p, dst, strip_start + line, width, s->bpp);\n        }\n        dst += stride;\n    }\n    return 0;\n}\n\n/**\n * Map stored raw sensor values into linear reference values (see: DNG Specification - Chapter 5)\n */\nstatic uint16_t av_always_inline dng_process_color16(uint16_t value,\n                                                     const uint16_t *lut,\n                                                     uint16_t black_level,\n                                                     float scale_factor) {\n    float value_norm;\n\n    // Lookup table lookup\n    if (lut)\n        value = lut[value];\n\n    // Black level subtraction\n    value = av_clip_uint16_c((unsigned)value - black_level);\n\n    // Color scaling\n    value_norm = (float)value * scale_factor;\n\n    value = av_clip_uint16_c(value_norm * 65535);\n\n    return value;\n}\n\nstatic uint16_t av_always_inline dng_process_color8(uint16_t value,\n                                                    const uint16_t *lut,\n                                                    uint16_t black_level,\n                                                    float scale_factor) {\n    return dng_process_color16(value, lut, black_level, scale_factor) >> 8;\n}\n\nstatic void dng_blit(TiffContext *s, uint8_t *dst, int dst_stride,\n                     const uint8_t *src, int src_stride,\n                     int width, int height, int is_single_comp, int is_u16)\n{\n    int line, col;\n    float scale_factor;\n\n    scale_factor = 1.0f / (s->white_level - s->black_level);\n\n    if (is_single_comp) {\n        if (!is_u16)\n            return; /* <= 8bpp unsupported */\n\n        /* Image is double the width and half the height we need, each row comprises 2 rows of the output\n           (split vertically in the middle). */\n        for (line = 0; line < height / 2; line++) {\n            uint16_t *dst_u16 = (uint16_t *)dst;\n            uint16_t *src_u16 = (uint16_t *)src;\n\n            /* Blit first half of input row row to initial row of output */\n            for (col = 0; col < width; col++)\n                *dst_u16++ = dng_process_color16(*src_u16++, s->dng_lut, s->black_level, scale_factor);\n\n            /* Advance the destination pointer by a row (source pointer remains in the same place) */\n            dst += dst_stride * sizeof(uint16_t);\n            dst_u16 = (uint16_t *)dst;\n\n            /* Blit second half of input row row to next row of output */\n            for (col = 0; col < width; col++)\n                *dst_u16++ = dng_process_color16(*src_u16++, s->dng_lut, s->black_level, scale_factor);\n\n            dst += dst_stride * sizeof(uint16_t);\n            src += src_stride * sizeof(uint16_t);\n        }\n    } else {\n        /* Input and output image are the same size and the MJpeg decoder has done per-component\n           deinterleaving, so blitting here is straightforward. */\n        if (is_u16) {\n            for (line = 0; line < height; line++) {\n                uint16_t *dst_u16 = (uint16_t *)dst;\n                uint16_t *src_u16 = (uint16_t *)src;\n\n                for (col = 0; col < width; col++)\n                    *dst_u16++ = dng_process_color16(*src_u16++, s->dng_lut, s->black_level, scale_factor);\n\n                dst += dst_stride * sizeof(uint16_t);\n                src += src_stride * sizeof(uint16_t);\n            }\n        } else {\n            for (line = 0; line < height; line++) {\n                uint8_t *dst_u8 = dst;\n                const uint8_t *src_u8 = src;\n\n                for (col = 0; col < width; col++)\n                    *dst_u8++ = dng_process_color8(*src_u8++, s->dng_lut, s->black_level, scale_factor);\n\n                dst += dst_stride;\n                src += src_stride;\n            }\n        }\n    }\n}\n\nstatic int dng_decode_jpeg(AVCodecContext *avctx, AVFrame *frame,\n                           int tile_byte_count, int dst_x, int dst_y, int w, int h)\n{\n    TiffContext *s = avctx->priv_data;\n    AVPacket jpkt;\n    uint8_t *dst_data, *src_data;\n    uint32_t dst_offset; /* offset from dst buffer in pixels */\n    int is_single_comp, is_u16, pixel_size;\n    int ret;\n\n    if (tile_byte_count < 0 || tile_byte_count > bytestream2_get_bytes_left(&s->gb))\n        return AVERROR_INVALIDDATA;\n\n    /* Prepare a packet and send to the MJPEG decoder */\n    av_init_packet(&jpkt);\n    jpkt.data = (uint8_t*)s->gb.buffer;\n    jpkt.size = tile_byte_count;\n\n    if (s->is_bayer) {\n        MJpegDecodeContext *mjpegdecctx = s->avctx_mjpeg->priv_data;\n        /* We have to set this information here, there is no way to know if a given JPEG is a DNG-embedded\n           image or not from its own data (and we need that information when decoding it). */\n        mjpegdecctx->bayer = 1;\n    }\n\n    ret = avcodec_send_packet(s->avctx_mjpeg, &jpkt);\n    if (ret < 0) {\n        av_log(avctx, AV_LOG_ERROR, \"Error submitting a packet for decoding\\n\");\n        return ret;\n    }\n\n    ret = avcodec_receive_frame(s->avctx_mjpeg, s->jpgframe);\n    if (ret < 0) {\n        av_log(avctx, AV_LOG_ERROR, \"JPEG decoding error: %s.\\n\", av_err2str(ret));\n\n        /* Normally skip, error if explode */\n        if (avctx->err_recognition & AV_EF_EXPLODE)\n            return AVERROR_INVALIDDATA;\n        else\n            return 0;\n    }\n\n    is_u16 = (s->bpp > 8);\n\n    /* Copy the outputted tile's pixels from 'jpgframe' to 'frame' (final buffer) */\n\n    if (s->jpgframe->width  != s->avctx_mjpeg->width  ||\n        s->jpgframe->height != s->avctx_mjpeg->height ||\n        s->jpgframe->format != s->avctx_mjpeg->pix_fmt)\n        return AVERROR_INVALIDDATA;\n\n    /* See dng_blit for explanation */\n    if (s->avctx_mjpeg->width  == w * 2 &&\n        s->avctx_mjpeg->height == h / 2 &&\n        s->avctx_mjpeg->pix_fmt == AV_PIX_FMT_GRAY16LE) {\n        is_single_comp = 1;\n    } else if (s->avctx_mjpeg->width  >= w &&\n               s->avctx_mjpeg->height >= h &&\n               s->avctx_mjpeg->pix_fmt == (is_u16 ? AV_PIX_FMT_GRAY16 : AV_PIX_FMT_GRAY8)\n              ) {\n        is_single_comp = 0;\n    } else\n        return AVERROR_INVALIDDATA;\n\n    pixel_size = (is_u16 ? sizeof(uint16_t) : sizeof(uint8_t));\n\n    if (is_single_comp && !is_u16) {\n        av_log(s->avctx, AV_LOG_ERROR, \"DNGs with bpp <= 8 and 1 component are unsupported\\n\");\n        av_frame_unref(s->jpgframe);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    dst_offset = dst_x + frame->linesize[0] * dst_y / pixel_size;\n    dst_data = frame->data[0] + dst_offset * pixel_size;\n    src_data = s->jpgframe->data[0];\n\n    dng_blit(s,\n             dst_data,\n             frame->linesize[0] / pixel_size,\n             src_data,\n             s->jpgframe->linesize[0] / pixel_size,\n             w,\n             h,\n             is_single_comp,\n             is_u16);\n\n    av_frame_unref(s->jpgframe);\n\n    return 0;\n}\n\nstatic int dng_decode_tiles(AVCodecContext *avctx, AVFrame *frame, AVPacket *avpkt)\n{\n    TiffContext *s = avctx->priv_data;\n    int tile_idx;\n    int tile_offset_offset, tile_offset;\n    int tile_byte_count_offset, tile_byte_count;\n    int tile_count_x, tile_count_y;\n    int tile_width, tile_length;\n    int has_width_leftover, has_height_leftover;\n    int tile_x = 0, tile_y = 0;\n    int pos_x = 0, pos_y = 0;\n    int ret;\n\n    s->jpgframe->width  = s->tile_width;\n    s->jpgframe->height = s->tile_length;\n\n    s->avctx_mjpeg->width = s->tile_width;\n    s->avctx_mjpeg->height = s->tile_length;\n\n    has_width_leftover = (s->width % s->tile_width != 0);\n    has_height_leftover = (s->height % s->tile_length != 0);\n\n    /* Calculate tile counts (round up) */\n    tile_count_x = (s->width + s->tile_width - 1) / s->tile_width;\n    tile_count_y = (s->height + s->tile_length - 1) / s->tile_length;\n\n    /* Iterate over the number of tiles */\n    for (tile_idx = 0; tile_idx < s->tile_count; tile_idx++) {\n        tile_x = tile_idx % tile_count_x;\n        tile_y = tile_idx / tile_count_x;\n\n        if (has_width_leftover && tile_x == tile_count_x - 1) // If on the right-most tile\n            tile_width = s->width % s->tile_width;\n        else\n            tile_width = s->tile_width;\n\n        if (has_height_leftover && tile_y == tile_count_y - 1) // If on the bottom-most tile\n            tile_length = s->height % s->tile_length;\n        else\n            tile_length = s->tile_length;\n\n        /* Read tile offset */\n        tile_offset_offset = s->tile_offsets_offset + tile_idx * sizeof(int);\n        bytestream2_seek(&s->gb, tile_offset_offset, SEEK_SET);\n        tile_offset = ff_tget_long(&s->gb, s->le);\n\n        /* Read tile byte size */\n        tile_byte_count_offset = s->tile_byte_counts_offset + tile_idx * sizeof(int);\n        bytestream2_seek(&s->gb, tile_byte_count_offset, SEEK_SET);\n        tile_byte_count = ff_tget_long(&s->gb, s->le);\n\n        /* Seek to tile data */\n        bytestream2_seek(&s->gb, tile_offset, SEEK_SET);\n\n        /* Decode JPEG tile and copy it in the reference frame */\n        ret = dng_decode_jpeg(avctx, frame, tile_byte_count, pos_x, pos_y, tile_width, tile_length);\n\n        if (ret < 0)\n            return ret;\n\n        /* Advance current positions */\n        pos_x += tile_width;\n        if (tile_x == tile_count_x - 1) { // If on the right edge\n            pos_x = 0;\n            pos_y += tile_length;\n        }\n    }\n\n    /* Frame is ready to be output */\n    frame->pict_type = AV_PICTURE_TYPE_I;\n    frame->key_frame = 1;\n\n    return avpkt->size;\n}\n\nstatic int dng_decode_strip(AVCodecContext *avctx, AVFrame *frame)\n{\n    TiffContext *s = avctx->priv_data;\n\n    s->jpgframe->width  = s->width;\n    s->jpgframe->height = s->height;\n\n    s->avctx_mjpeg->width = s->width;\n    s->avctx_mjpeg->height = s->height;\n\n    return dng_decode_jpeg(avctx, frame, s->stripsize, 0, 0, s->width, s->height);\n}\n\nstatic int init_image(TiffContext *s, ThreadFrame *frame)\n{\n    int ret;\n    int create_gray_palette = 0;\n\n    // make sure there is no aliasing in the following switch\n    if (s->bpp >= 100 || s->bppcount >= 10) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"Unsupported image parameters: bpp=%d, bppcount=%d\\n\",\n               s->bpp, s->bppcount);\n        return AVERROR_INVALIDDATA;\n    }\n\n    switch (s->planar * 1000 + s->bpp * 10 + s->bppcount + s->is_bayer * 10000) {\n    case 11:\n        if (!s->palette_is_set) {\n            s->avctx->pix_fmt = AV_PIX_FMT_MONOBLACK;\n            break;\n        }\n    case 21:\n    case 41:\n        s->avctx->pix_fmt = AV_PIX_FMT_PAL8;\n        if (!s->palette_is_set) {\n            create_gray_palette = 1;\n        }\n        break;\n    case 81:\n        s->avctx->pix_fmt = s->palette_is_set ? AV_PIX_FMT_PAL8 : AV_PIX_FMT_GRAY8;\n        break;\n    case 121:\n        s->avctx->pix_fmt = AV_PIX_FMT_GRAY12;\n        break;\n    case 10081:\n        switch (AV_RL32(s->pattern)) {\n        case 0x02010100:\n            s->avctx->pix_fmt = AV_PIX_FMT_BAYER_RGGB8;\n            break;\n        case 0x00010102:\n            s->avctx->pix_fmt = AV_PIX_FMT_BAYER_BGGR8;\n            break;\n        case 0x01000201:\n            s->avctx->pix_fmt = AV_PIX_FMT_BAYER_GBRG8;\n            break;\n        case 0x01020001:\n            s->avctx->pix_fmt = AV_PIX_FMT_BAYER_GRBG8;\n            break;\n        default:\n            av_log(s->avctx, AV_LOG_ERROR, \"Unsupported Bayer pattern: 0x%X\\n\",\n                   AV_RL32(s->pattern));\n            return AVERROR_PATCHWELCOME;\n        }\n        break;\n    case 10101:\n    case 10121:\n    case 10141:\n    case 10161:\n        switch (AV_RL32(s->pattern)) {\n        case 0x02010100:\n            s->avctx->pix_fmt = AV_PIX_FMT_BAYER_RGGB16;\n            break;\n        case 0x00010102:\n            s->avctx->pix_fmt = AV_PIX_FMT_BAYER_BGGR16;\n            break;\n        case 0x01000201:\n            s->avctx->pix_fmt = AV_PIX_FMT_BAYER_GBRG16;\n            break;\n        case 0x01020001:\n            s->avctx->pix_fmt = AV_PIX_FMT_BAYER_GRBG16;\n            break;\n        default:\n            av_log(s->avctx, AV_LOG_ERROR, \"Unsupported Bayer pattern: 0x%X\\n\",\n                   AV_RL32(s->pattern));\n            return AVERROR_PATCHWELCOME;\n        }\n        break;\n    case 243:\n        if (s->photometric == TIFF_PHOTOMETRIC_YCBCR) {\n            if (s->subsampling[0] == 1 && s->subsampling[1] == 1) {\n                s->avctx->pix_fmt = AV_PIX_FMT_YUV444P;\n            } else if (s->subsampling[0] == 2 && s->subsampling[1] == 1) {\n                s->avctx->pix_fmt = AV_PIX_FMT_YUV422P;\n            } else if (s->subsampling[0] == 4 && s->subsampling[1] == 1) {\n                s->avctx->pix_fmt = AV_PIX_FMT_YUV411P;\n            } else if (s->subsampling[0] == 1 && s->subsampling[1] == 2) {\n                s->avctx->pix_fmt = AV_PIX_FMT_YUV440P;\n            } else if (s->subsampling[0] == 2 && s->subsampling[1] == 2) {\n                s->avctx->pix_fmt = AV_PIX_FMT_YUV420P;\n            } else if (s->subsampling[0] == 4 && s->subsampling[1] == 4) {\n                s->avctx->pix_fmt = AV_PIX_FMT_YUV410P;\n            } else {\n                av_log(s->avctx, AV_LOG_ERROR, \"Unsupported YCbCr subsampling\\n\");\n                return AVERROR_PATCHWELCOME;\n            }\n        } else\n            s->avctx->pix_fmt = AV_PIX_FMT_RGB24;\n        break;\n    case 161:\n        s->avctx->pix_fmt = s->le ? AV_PIX_FMT_GRAY16LE : AV_PIX_FMT_GRAY16BE;\n        break;\n    case 162:\n        s->avctx->pix_fmt = AV_PIX_FMT_YA8;\n        break;\n    case 322:\n        s->avctx->pix_fmt = s->le ? AV_PIX_FMT_YA16LE : AV_PIX_FMT_YA16BE;\n        break;\n    case 324:\n        s->avctx->pix_fmt = s->photometric == TIFF_PHOTOMETRIC_SEPARATED ? AV_PIX_FMT_RGB0 : AV_PIX_FMT_RGBA;\n        break;\n    case 405:\n        if (s->photometric == TIFF_PHOTOMETRIC_SEPARATED)\n            s->avctx->pix_fmt = AV_PIX_FMT_RGBA;\n        else {\n            av_log(s->avctx, AV_LOG_ERROR,\n                \"bpp=40 without PHOTOMETRIC_SEPARATED is unsupported\\n\");\n            return AVERROR_PATCHWELCOME;\n        }\n        break;\n    case 483:\n        s->avctx->pix_fmt = s->le ? AV_PIX_FMT_RGB48LE  : AV_PIX_FMT_RGB48BE;\n        break;\n    case 644:\n        s->avctx->pix_fmt = s->le ? AV_PIX_FMT_RGBA64LE  : AV_PIX_FMT_RGBA64BE;\n        break;\n    case 1243:\n        s->avctx->pix_fmt = AV_PIX_FMT_GBRP;\n        break;\n    case 1324:\n        s->avctx->pix_fmt = AV_PIX_FMT_GBRAP;\n        break;\n    case 1483:\n        s->avctx->pix_fmt = s->le ? AV_PIX_FMT_GBRP16LE : AV_PIX_FMT_GBRP16BE;\n        break;\n    case 1644:\n        s->avctx->pix_fmt = s->le ? AV_PIX_FMT_GBRAP16LE : AV_PIX_FMT_GBRAP16BE;\n        break;\n    default:\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"This format is not supported (bpp=%d, bppcount=%d)\\n\",\n               s->bpp, s->bppcount);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (s->photometric == TIFF_PHOTOMETRIC_YCBCR) {\n        const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s->avctx->pix_fmt);\n        if((desc->flags & AV_PIX_FMT_FLAG_RGB) ||\n           !(desc->flags & AV_PIX_FMT_FLAG_PLANAR) ||\n           desc->nb_components < 3) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Unsupported YCbCr variant\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n    }\n\n    if (s->width != s->avctx->width || s->height != s->avctx->height) {\n        ret = ff_set_dimensions(s->avctx, s->width, s->height);\n        if (ret < 0)\n            return ret;\n    }\n    if ((ret = ff_thread_get_buffer(s->avctx, frame, 0)) < 0)\n        return ret;\n    if (s->avctx->pix_fmt == AV_PIX_FMT_PAL8) {\n        if (!create_gray_palette)\n            memcpy(frame->f->data[1], s->palette, sizeof(s->palette));\n        else {\n            /* make default grayscale pal */\n            int i;\n            uint32_t *pal = (uint32_t *)frame->f->data[1];\n            for (i = 0; i < 1<<s->bpp; i++)\n                pal[i] = 0xFFU << 24 | i * 255 / ((1<<s->bpp) - 1) * 0x010101;\n        }\n    }\n    return 0;\n}\n\nstatic void set_sar(TiffContext *s, unsigned tag, unsigned num, unsigned den)\n{\n    int offset = tag == TIFF_YRES ? 2 : 0;\n    s->res[offset++] = num;\n    s->res[offset]   = den;\n    if (s->res[0] && s->res[1] && s->res[2] && s->res[3]) {\n        uint64_t num = s->res[2] * (uint64_t)s->res[1];\n        uint64_t den = s->res[0] * (uint64_t)s->res[3];\n        if (num > INT64_MAX || den > INT64_MAX) {\n            num = num >> 1;\n            den = den >> 1;\n        }\n        av_reduce(&s->avctx->sample_aspect_ratio.num, &s->avctx->sample_aspect_ratio.den,\n                  num, den, INT32_MAX);\n        if (!s->avctx->sample_aspect_ratio.den)\n            s->avctx->sample_aspect_ratio = (AVRational) {0, 1};\n    }\n}\n\nstatic int tiff_decode_tag(TiffContext *s, AVFrame *frame)\n{\n    AVFrameSideData *sd;\n    GetByteContext gb_temp;\n    unsigned tag, type, count, off, value = 0, value2 = 1; // value2 is a denominator so init. to 1\n    int i, start;\n    int pos;\n    int ret;\n    double *dp;\n\n    ret = ff_tread_tag(&s->gb, s->le, &tag, &type, &count, &start);\n    if (ret < 0) {\n        goto end;\n    }\n    if (tag <= s->last_tag)\n        return AVERROR_INVALIDDATA;\n\n    // We ignore TIFF_STRIP_SIZE as it is sometimes in the logic but wrong order around TIFF_STRIP_OFFS\n    if (tag != TIFF_STRIP_SIZE)\n        s->last_tag = tag;\n\n    off = bytestream2_tell(&s->gb);\n    if (count == 1) {\n        switch (type) {\n        case TIFF_BYTE:\n        case TIFF_SHORT:\n        case TIFF_LONG:\n            value = ff_tget(&s->gb, type, s->le);\n            break;\n        case TIFF_RATIONAL:\n            value  = ff_tget(&s->gb, TIFF_LONG, s->le);\n            value2 = ff_tget(&s->gb, TIFF_LONG, s->le);\n            if (!value2) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Invalid denominator in rational\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n\n            break;\n        case TIFF_STRING:\n            if (count <= 4) {\n                break;\n            }\n        default:\n            value = UINT_MAX;\n        }\n    }\n\n    switch (tag) {\n    case TIFF_SUBFILE:\n        s->is_thumbnail = (value != 0);\n        break;\n    case TIFF_WIDTH:\n        s->width = value;\n        break;\n    case TIFF_HEIGHT:\n        s->height = value;\n        break;\n    case TIFF_BPP:\n        if (count > 5 || count <= 0) {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"This format is not supported (bpp=%d, %d components)\\n\",\n                   value, count);\n            return AVERROR_INVALIDDATA;\n        }\n        s->bppcount = count;\n        if (count == 1)\n            s->bpp = value;\n        else {\n            switch (type) {\n            case TIFF_BYTE:\n            case TIFF_SHORT:\n            case TIFF_LONG:\n                s->bpp = 0;\n                if (bytestream2_get_bytes_left(&s->gb) < type_sizes[type] * count)\n                    return AVERROR_INVALIDDATA;\n                for (i = 0; i < count; i++)\n                    s->bpp += ff_tget(&s->gb, type, s->le);\n                break;\n            default:\n                s->bpp = -1;\n            }\n        }\n        break;\n    case TIFF_SAMPLES_PER_PIXEL:\n        if (count != 1) {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"Samples per pixel requires a single value, many provided\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        if (value > 5 || value <= 0) {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"Invalid samples per pixel %d\\n\", value);\n            return AVERROR_INVALIDDATA;\n        }\n        if (s->bppcount == 1)\n            s->bpp *= value;\n        s->bppcount = value;\n        break;\n    case TIFF_COMPR:\n        s->compr     = value;\n        av_log(s->avctx, AV_LOG_DEBUG, \"compression: %d\\n\", s->compr);\n        s->predictor = 0;\n        switch (s->compr) {\n        case TIFF_RAW:\n        case TIFF_PACKBITS:\n        case TIFF_LZW:\n        case TIFF_CCITT_RLE:\n            break;\n        case TIFF_G3:\n        case TIFF_G4:\n            s->fax_opts = 0;\n            break;\n        case TIFF_DEFLATE:\n        case TIFF_ADOBE_DEFLATE:\n#if CONFIG_ZLIB\n            break;\n#else\n            av_log(s->avctx, AV_LOG_ERROR, \"Deflate: ZLib not compiled in\\n\");\n            return AVERROR(ENOSYS);\n#endif\n        case TIFF_JPEG:\n        case TIFF_NEWJPEG:\n            s->is_jpeg = 1;\n            break;\n        case TIFF_LZMA:\n#if CONFIG_LZMA\n            break;\n#else\n            av_log(s->avctx, AV_LOG_ERROR, \"LZMA not compiled in\\n\");\n            return AVERROR(ENOSYS);\n#endif\n        default:\n            av_log(s->avctx, AV_LOG_ERROR, \"Unknown compression method %i\\n\",\n                   s->compr);\n            return AVERROR_INVALIDDATA;\n        }\n        break;\n    case TIFF_ROWSPERSTRIP:\n        if (!value || (type == TIFF_LONG && value == UINT_MAX))\n            value = s->height;\n        s->rps = FFMIN(value, s->height);\n        break;\n    case TIFF_STRIP_OFFS:\n        if (count == 1) {\n            if (value > INT_MAX) {\n                av_log(s->avctx, AV_LOG_ERROR,\n                    \"strippos %u too large\\n\", value);\n                return AVERROR_INVALIDDATA;\n            }\n            s->strippos = 0;\n            s->stripoff = value;\n        } else\n            s->strippos = off;\n        s->strips = count;\n        if (s->strips == 1)\n            s->rps = s->height;\n        s->sot = type;\n        break;\n    case TIFF_STRIP_SIZE:\n        if (count == 1) {\n            if (value > INT_MAX) {\n                av_log(s->avctx, AV_LOG_ERROR,\n                    \"stripsize %u too large\\n\", value);\n                return AVERROR_INVALIDDATA;\n            }\n            s->stripsizesoff = 0;\n            s->stripsize     = value;\n            s->strips        = 1;\n        } else {\n            s->stripsizesoff = off;\n        }\n        s->strips = count;\n        s->sstype = type;\n        break;\n    case TIFF_XRES:\n    case TIFF_YRES:\n        set_sar(s, tag, value, value2);\n        break;\n    case TIFF_TILE_OFFSETS:\n        s->tile_offsets_offset = off;\n        s->tile_count = count;\n        s->is_tiled = 1;\n        break;\n    case TIFF_TILE_BYTE_COUNTS:\n        s->tile_byte_counts_offset = off;\n        break;\n    case TIFF_TILE_LENGTH:\n        s->tile_length = value;\n        break;\n    case TIFF_TILE_WIDTH:\n        s->tile_width = value;\n        break;\n    case TIFF_PREDICTOR:\n        s->predictor = value;\n        break;\n    case TIFF_SUB_IFDS:\n        if (count == 1)\n            s->sub_ifd = value;\n        else if (count > 1)\n            s->sub_ifd = ff_tget(&s->gb, TIFF_LONG, s->le); /** Only get the first SubIFD */\n        break;\n    case DNG_LINEARIZATION_TABLE:\n        if (count > FF_ARRAY_ELEMS(s->dng_lut))\n            return AVERROR_INVALIDDATA;\n        for (int i = 0; i < count; i++)\n            s->dng_lut[i] = ff_tget(&s->gb, type, s->le);\n        break;\n    case DNG_BLACK_LEVEL:\n        if (count > 1) {    /* Use the first value in the pattern (assume they're all the same) */\n            if (type == TIFF_RATIONAL) {\n                value  = ff_tget(&s->gb, TIFF_LONG, s->le);\n                value2 = ff_tget(&s->gb, TIFF_LONG, s->le);\n                if (!value2) {\n                    av_log(s->avctx, AV_LOG_ERROR, \"Invalid black level denominator\\n\");\n                    return AVERROR_INVALIDDATA;\n                }\n\n                s->black_level = value / value2;\n            } else\n                s->black_level = ff_tget(&s->gb, type, s->le);\n            av_log(s->avctx, AV_LOG_WARNING, \"Assuming black level pattern values are identical\\n\");\n        } else {\n            s->black_level = value / value2;\n        }\n        break;\n    case DNG_WHITE_LEVEL:\n        s->white_level = value;\n        break;\n    case TIFF_CFA_PATTERN_DIM:\n        if (count != 2 || (ff_tget(&s->gb, type, s->le) != 2 &&\n                           ff_tget(&s->gb, type, s->le) != 2)) {\n            av_log(s->avctx, AV_LOG_ERROR, \"CFA Pattern dimensions are not 2x2\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        break;\n    case TIFF_CFA_PATTERN:\n        s->is_bayer = 1;\n        s->pattern[0] = ff_tget(&s->gb, type, s->le);\n        s->pattern[1] = ff_tget(&s->gb, type, s->le);\n        s->pattern[2] = ff_tget(&s->gb, type, s->le);\n        s->pattern[3] = ff_tget(&s->gb, type, s->le);\n        break;\n    case TIFF_PHOTOMETRIC:\n        switch (value) {\n        case TIFF_PHOTOMETRIC_WHITE_IS_ZERO:\n        case TIFF_PHOTOMETRIC_BLACK_IS_ZERO:\n        case TIFF_PHOTOMETRIC_RGB:\n        case TIFF_PHOTOMETRIC_PALETTE:\n        case TIFF_PHOTOMETRIC_SEPARATED:\n        case TIFF_PHOTOMETRIC_YCBCR:\n        case TIFF_PHOTOMETRIC_CFA:\n        case TIFF_PHOTOMETRIC_LINEAR_RAW: // Used by DNG images\n            s->photometric = value;\n            break;\n        case TIFF_PHOTOMETRIC_ALPHA_MASK:\n        case TIFF_PHOTOMETRIC_CIE_LAB:\n        case TIFF_PHOTOMETRIC_ICC_LAB:\n        case TIFF_PHOTOMETRIC_ITU_LAB:\n        case TIFF_PHOTOMETRIC_LOG_L:\n        case TIFF_PHOTOMETRIC_LOG_LUV:\n            avpriv_report_missing_feature(s->avctx,\n                                          \"PhotometricInterpretation 0x%04X\",\n                                          value);\n            return AVERROR_PATCHWELCOME;\n        default:\n            av_log(s->avctx, AV_LOG_ERROR, \"PhotometricInterpretation %u is \"\n                   \"unknown\\n\", value);\n            return AVERROR_INVALIDDATA;\n        }\n        break;\n    case TIFF_FILL_ORDER:\n        if (value < 1 || value > 2) {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"Unknown FillOrder value %d, trying default one\\n\", value);\n            value = 1;\n        }\n        s->fill_order = value - 1;\n        break;\n    case TIFF_PAL: {\n        GetByteContext pal_gb[3];\n        off = type_sizes[type];\n        if (count / 3 > 256 ||\n            bytestream2_get_bytes_left(&s->gb) < count / 3 * off * 3)\n            return AVERROR_INVALIDDATA;\n\n        pal_gb[0] = pal_gb[1] = pal_gb[2] = s->gb;\n        bytestream2_skip(&pal_gb[1], count / 3 * off);\n        bytestream2_skip(&pal_gb[2], count / 3 * off * 2);\n\n        off = (type_sizes[type] - 1) << 3;\n        if (off > 31U) {\n            av_log(s->avctx, AV_LOG_ERROR, \"palette shift %d is out of range\\n\", off);\n            return AVERROR_INVALIDDATA;\n        }\n\n        for (i = 0; i < count / 3; i++) {\n            uint32_t p = 0xFF000000;\n            p |= (ff_tget(&pal_gb[0], type, s->le) >> off) << 16;\n            p |= (ff_tget(&pal_gb[1], type, s->le) >> off) << 8;\n            p |=  ff_tget(&pal_gb[2], type, s->le) >> off;\n            s->palette[i] = p;\n        }\n        s->palette_is_set = 1;\n        break;\n    }\n    case TIFF_PLANAR:\n        s->planar = value == 2;\n        break;\n    case TIFF_YCBCR_SUBSAMPLING:\n        if (count != 2) {\n            av_log(s->avctx, AV_LOG_ERROR, \"subsample count invalid\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        for (i = 0; i < count; i++) {\n            s->subsampling[i] = ff_tget(&s->gb, type, s->le);\n            if (s->subsampling[i] <= 0) {\n                av_log(s->avctx, AV_LOG_ERROR, \"subsampling %d is invalid\\n\", s->subsampling[i]);\n                s->subsampling[i] = 1;\n                return AVERROR_INVALIDDATA;\n            }\n        }\n        break;\n    case TIFF_T4OPTIONS:\n        if (s->compr == TIFF_G3)\n            s->fax_opts = value;\n        break;\n    case TIFF_T6OPTIONS:\n        if (s->compr == TIFF_G4)\n            s->fax_opts = value;\n        break;\n#define ADD_METADATA(count, name, sep)\\\n    if ((ret = add_metadata(count, type, name, sep, s, frame)) < 0) {\\\n        av_log(s->avctx, AV_LOG_ERROR, \"Error allocating temporary buffer\\n\");\\\n        goto end;\\\n    }\n    case TIFF_MODEL_PIXEL_SCALE:\n        ADD_METADATA(count, \"ModelPixelScaleTag\", NULL);\n        break;\n    case TIFF_MODEL_TRANSFORMATION:\n        ADD_METADATA(count, \"ModelTransformationTag\", NULL);\n        break;\n    case TIFF_MODEL_TIEPOINT:\n        ADD_METADATA(count, \"ModelTiepointTag\", NULL);\n        break;\n    case TIFF_GEO_KEY_DIRECTORY:\n        if (s->geotag_count) {\n            avpriv_request_sample(s->avctx, \"Multiple geo key directories\");\n            return AVERROR_INVALIDDATA;\n        }\n        ADD_METADATA(1, \"GeoTIFF_Version\", NULL);\n        ADD_METADATA(2, \"GeoTIFF_Key_Revision\", \".\");\n        s->geotag_count   = ff_tget_short(&s->gb, s->le);\n        if (s->geotag_count > count / 4 - 1) {\n            s->geotag_count = count / 4 - 1;\n            av_log(s->avctx, AV_LOG_WARNING, \"GeoTIFF key directory buffer shorter than specified\\n\");\n        }\n        if (   bytestream2_get_bytes_left(&s->gb) < s->geotag_count * sizeof(int16_t) * 4\n            || s->geotag_count == 0) {\n            s->geotag_count = 0;\n            return -1;\n        }\n        s->geotags = av_mallocz_array(s->geotag_count, sizeof(TiffGeoTag));\n        if (!s->geotags) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Error allocating temporary buffer\\n\");\n            s->geotag_count = 0;\n            goto end;\n        }\n        for (i = 0; i < s->geotag_count; i++) {\n            s->geotags[i].key    = ff_tget_short(&s->gb, s->le);\n            s->geotags[i].type   = ff_tget_short(&s->gb, s->le);\n            s->geotags[i].count  = ff_tget_short(&s->gb, s->le);\n\n            if (!s->geotags[i].type)\n                s->geotags[i].val  = get_geokey_val(s->geotags[i].key, ff_tget_short(&s->gb, s->le));\n            else\n                s->geotags[i].offset = ff_tget_short(&s->gb, s->le);\n        }\n        break;\n    case TIFF_GEO_DOUBLE_PARAMS:\n        if (count >= INT_MAX / sizeof(int64_t))\n            return AVERROR_INVALIDDATA;\n        if (bytestream2_get_bytes_left(&s->gb) < count * sizeof(int64_t))\n            return AVERROR_INVALIDDATA;\n        dp = av_malloc_array(count, sizeof(double));\n        if (!dp) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Error allocating temporary buffer\\n\");\n            goto end;\n        }\n        for (i = 0; i < count; i++)\n            dp[i] = ff_tget_double(&s->gb, s->le);\n        for (i = 0; i < s->geotag_count; i++) {\n            if (s->geotags[i].type == TIFF_GEO_DOUBLE_PARAMS) {\n                if (s->geotags[i].count == 0\n                    || s->geotags[i].offset + s->geotags[i].count > count) {\n                    av_log(s->avctx, AV_LOG_WARNING, \"Invalid GeoTIFF key %d\\n\", s->geotags[i].key);\n                } else if (s->geotags[i].val) {\n                    av_log(s->avctx, AV_LOG_WARNING, \"Duplicate GeoTIFF key %d\\n\", s->geotags[i].key);\n                } else {\n                    char *ap = doubles2str(&dp[s->geotags[i].offset], s->geotags[i].count, \", \");\n                    if (!ap) {\n                        av_log(s->avctx, AV_LOG_ERROR, \"Error allocating temporary buffer\\n\");\n                        av_freep(&dp);\n                        return AVERROR(ENOMEM);\n                    }\n                    s->geotags[i].val = ap;\n                }\n            }\n        }\n        av_freep(&dp);\n        break;\n    case TIFF_GEO_ASCII_PARAMS:\n        pos = bytestream2_tell(&s->gb);\n        for (i = 0; i < s->geotag_count; i++) {\n            if (s->geotags[i].type == TIFF_GEO_ASCII_PARAMS) {\n                if (s->geotags[i].count == 0\n                    || s->geotags[i].offset +  s->geotags[i].count > count) {\n                    av_log(s->avctx, AV_LOG_WARNING, \"Invalid GeoTIFF key %d\\n\", s->geotags[i].key);\n                } else {\n                    char *ap;\n\n                    bytestream2_seek(&s->gb, pos + s->geotags[i].offset, SEEK_SET);\n                    if (bytestream2_get_bytes_left(&s->gb) < s->geotags[i].count)\n                        return AVERROR_INVALIDDATA;\n                    if (s->geotags[i].val)\n                        return AVERROR_INVALIDDATA;\n                    ap = av_malloc(s->geotags[i].count);\n                    if (!ap) {\n                        av_log(s->avctx, AV_LOG_ERROR, \"Error allocating temporary buffer\\n\");\n                        return AVERROR(ENOMEM);\n                    }\n                    bytestream2_get_bufferu(&s->gb, ap, s->geotags[i].count);\n                    ap[s->geotags[i].count - 1] = '\\0'; //replace the \"|\" delimiter with a 0 byte\n                    s->geotags[i].val = ap;\n                }\n            }\n        }\n        break;\n    case TIFF_ICC_PROFILE:\n        gb_temp = s->gb;\n        bytestream2_seek(&gb_temp, SEEK_SET, off);\n\n        if (bytestream2_get_bytes_left(&gb_temp) < count)\n            return AVERROR_INVALIDDATA;\n\n        sd = av_frame_new_side_data(frame, AV_FRAME_DATA_ICC_PROFILE, count);\n        if (!sd)\n            return AVERROR(ENOMEM);\n\n        bytestream2_get_bufferu(&gb_temp, sd->data, count);\n        break;\n    case TIFF_ARTIST:\n        ADD_METADATA(count, \"artist\", NULL);\n        break;\n    case TIFF_COPYRIGHT:\n        ADD_METADATA(count, \"copyright\", NULL);\n        break;\n    case TIFF_DATE:\n        ADD_METADATA(count, \"date\", NULL);\n        break;\n    case TIFF_DOCUMENT_NAME:\n        ADD_METADATA(count, \"document_name\", NULL);\n        break;\n    case TIFF_HOST_COMPUTER:\n        ADD_METADATA(count, \"computer\", NULL);\n        break;\n    case TIFF_IMAGE_DESCRIPTION:\n        ADD_METADATA(count, \"description\", NULL);\n        break;\n    case TIFF_MAKE:\n        ADD_METADATA(count, \"make\", NULL);\n        break;\n    case TIFF_MODEL:\n        ADD_METADATA(count, \"model\", NULL);\n        break;\n    case TIFF_PAGE_NAME:\n        ADD_METADATA(count, \"page_name\", NULL);\n        break;\n    case TIFF_PAGE_NUMBER:\n        ADD_METADATA(count, \"page_number\", \" / \");\n        // need to seek back to re-read the page number\n        bytestream2_seek(&s->gb, -count * sizeof(uint16_t), SEEK_CUR);\n        // read the page number\n        s->cur_page = ff_tget(&s->gb, TIFF_SHORT, s->le);\n        // get back to where we were before the previous seek\n        bytestream2_seek(&s->gb, count * sizeof(uint16_t) - sizeof(uint16_t), SEEK_CUR);\n        break;\n    case TIFF_SOFTWARE_NAME:\n        ADD_METADATA(count, \"software\", NULL);\n        break;\n    case DNG_VERSION:\n        if (count == 4) {\n            unsigned int ver[4];\n            ver[0] = ff_tget(&s->gb, type, s->le);\n            ver[1] = ff_tget(&s->gb, type, s->le);\n            ver[2] = ff_tget(&s->gb, type, s->le);\n            ver[3] = ff_tget(&s->gb, type, s->le);\n\n            av_log(s->avctx, AV_LOG_DEBUG, \"DNG file, version %u.%u.%u.%u\\n\",\n                ver[0], ver[1], ver[2], ver[3]);\n\n            tiff_set_type(s, TIFF_TYPE_DNG);\n        }\n        break;\n    case CINEMADNG_TIME_CODES:\n    case CINEMADNG_FRAME_RATE:\n    case CINEMADNG_T_STOP:\n    case CINEMADNG_REEL_NAME:\n    case CINEMADNG_CAMERA_LABEL:\n        tiff_set_type(s, TIFF_TYPE_CINEMADNG);\n        break;\n    default:\n        if (s->avctx->err_recognition & AV_EF_EXPLODE) {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"Unknown or unsupported tag %d/0x%0X\\n\",\n                   tag, tag);\n            return AVERROR_INVALIDDATA;\n        }\n    }\nend:\n    if (s->bpp > 64U) {\n        av_log(s->avctx, AV_LOG_ERROR,\n                \"This format is not supported (bpp=%d, %d components)\\n\",\n                s->bpp, count);\n        s->bpp = 0;\n        return AVERROR_INVALIDDATA;\n    }\n    bytestream2_seek(&s->gb, start, SEEK_SET);\n    return 0;\n}\n\nstatic int decode_frame(AVCodecContext *avctx,\n                        void *data, int *got_frame, AVPacket *avpkt)\n{\n    TiffContext *const s = avctx->priv_data;\n    AVFrame *const p = data;\n    ThreadFrame frame = { .f = data };\n    unsigned off, last_off;\n    int le, ret, plane, planes;\n    int i, j, entries, stride;\n    unsigned soff, ssize;\n    uint8_t *dst;\n    GetByteContext stripsizes;\n    GetByteContext stripdata;\n    int retry_for_subifd, retry_for_page;\n    int is_dng;\n    int has_tile_bits, has_strip_bits;\n\n    bytestream2_init(&s->gb, avpkt->data, avpkt->size);\n\n    // parse image header\n    if ((ret = ff_tdecode_header(&s->gb, &le, &off))) {\n        av_log(avctx, AV_LOG_ERROR, \"Invalid TIFF header\\n\");\n        return ret;\n    } else if (off >= UINT_MAX - 14 || avpkt->size < off + 14) {\n        av_log(avctx, AV_LOG_ERROR, \"IFD offset is greater than image size\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    s->le          = le;\n    // TIFF_BPP is not a required tag and defaults to 1\n\n    s->tiff_type   = TIFF_TYPE_TIFF;\nagain:\n    s->is_thumbnail = 0;\n    s->bppcount    = s->bpp = 1;\n    s->photometric = TIFF_PHOTOMETRIC_NONE;\n    s->compr       = TIFF_RAW;\n    s->fill_order  = 0;\n    s->white_level = 0;\n    s->is_bayer    = 0;\n    s->is_tiled    = 0;\n    s->is_jpeg     = 0;\n    s->cur_page    = 0;\n    s->last_tag    = 0;\n\n    for (i = 0; i < 65536; i++)\n        s->dng_lut[i] = i;\n\n    free_geotags(s);\n\n    // Reset these offsets so we can tell if they were set this frame\n    s->stripsizesoff = s->strippos = 0;\n    /* parse image file directory */\n    bytestream2_seek(&s->gb, off, SEEK_SET);\n    entries = ff_tget_short(&s->gb, le);\n    if (bytestream2_get_bytes_left(&s->gb) < entries * 12)\n        return AVERROR_INVALIDDATA;\n    for (i = 0; i < entries; i++) {\n        if ((ret = tiff_decode_tag(s, p)) < 0)\n            return ret;\n    }\n\n    if (s->get_thumbnail && !s->is_thumbnail) {\n        av_log(avctx, AV_LOG_INFO, \"No embedded thumbnail present\\n\");\n        return AVERROR_EOF;\n    }\n\n    /** whether we should process this IFD's SubIFD */\n    retry_for_subifd = s->sub_ifd && (s->get_subimage || (!s->get_thumbnail && s->is_thumbnail));\n    /** whether we should process this multi-page IFD's next page */\n    retry_for_page = s->get_page && s->cur_page + 1 < s->get_page;  // get_page is 1-indexed\n\n    last_off = off;\n    if (retry_for_page) {\n        // set offset to the next IFD\n        off = ff_tget_long(&s->gb, le);\n    } else if (retry_for_subifd) {\n        // set offset to the SubIFD\n        off = s->sub_ifd;\n    }\n\n    if (retry_for_subifd || retry_for_page) {\n        if (!off) {\n            av_log(avctx, AV_LOG_ERROR, \"Requested entry not found\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        if (off <= last_off) {\n            avpriv_request_sample(s->avctx, \"non increasing IFD offset\");\n            return AVERROR_INVALIDDATA;\n        }\n        if (off >= UINT_MAX - 14 || avpkt->size < off + 14) {\n            av_log(avctx, AV_LOG_ERROR, \"IFD offset is greater than image size\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        s->sub_ifd = 0;\n        goto again;\n    }\n\n    /* At this point we've decided on which (Sub)IFD to process */\n\n    is_dng = (s->tiff_type == TIFF_TYPE_DNG || s->tiff_type == TIFF_TYPE_CINEMADNG);\n\n    for (i = 0; i<s->geotag_count; i++) {\n        const char *keyname = get_geokey_name(s->geotags[i].key);\n        if (!keyname) {\n            av_log(avctx, AV_LOG_WARNING, \"Unknown or unsupported GeoTIFF key %d\\n\", s->geotags[i].key);\n            continue;\n        }\n        if (get_geokey_type(s->geotags[i].key) != s->geotags[i].type) {\n            av_log(avctx, AV_LOG_WARNING, \"Type of GeoTIFF key %d is wrong\\n\", s->geotags[i].key);\n            continue;\n        }\n        ret = av_dict_set(&p->metadata, keyname, s->geotags[i].val, 0);\n        if (ret<0) {\n            av_log(avctx, AV_LOG_ERROR, \"Writing metadata with key '%s' failed\\n\", keyname);\n            return ret;\n        }\n    }\n\n    if (is_dng) {\n        int bps;\n\n        if (s->bpp % s->bppcount)\n            return AVERROR_INVALIDDATA;\n        bps = s->bpp / s->bppcount;\n        if (bps < 8 || bps > 32)\n            return AVERROR_INVALIDDATA;\n\n        if (s->white_level == 0)\n            s->white_level = (1LL << bps) - 1; /* Default value as per the spec */\n\n        if (s->white_level <= s->black_level) {\n            av_log(avctx, AV_LOG_ERROR, \"BlackLevel (%\"PRId32\") must be less than WhiteLevel (%\"PRId32\")\\n\",\n                s->black_level, s->white_level);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (s->planar)\n            return AVERROR_PATCHWELCOME;\n    }\n\n    if (!s->is_tiled && !s->strippos && !s->stripoff) {\n        av_log(avctx, AV_LOG_ERROR, \"Image data is missing\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    has_tile_bits  = s->is_tiled || s->tile_byte_counts_offset || s->tile_offsets_offset || s->tile_width || s->tile_length || s->tile_count;\n    has_strip_bits = s->strippos || s->strips || s->stripoff || s->rps || s->sot || s->sstype || s->stripsize || s->stripsizesoff;\n\n    if (has_tile_bits && has_strip_bits) {\n        int tiled_dng = s->is_tiled && is_dng;\n        av_log(avctx, tiled_dng ? AV_LOG_WARNING : AV_LOG_ERROR, \"Tiled TIFF is not allowed to strip\\n\");\n        if (!tiled_dng)\n            return AVERROR_INVALIDDATA;\n    }\n\n    /* now we have the data and may start decoding */\n    if ((ret = init_image(s, &frame)) < 0)\n        return ret;\n\n    if (!s->is_tiled || has_strip_bits) {\n        if (s->strips == 1 && !s->stripsize) {\n            av_log(avctx, AV_LOG_WARNING, \"Image data size missing\\n\");\n            s->stripsize = avpkt->size - s->stripoff;\n        }\n\n        if (s->stripsizesoff) {\n            if (s->stripsizesoff >= (unsigned)avpkt->size)\n                return AVERROR_INVALIDDATA;\n            bytestream2_init(&stripsizes, avpkt->data + s->stripsizesoff,\n                            avpkt->size - s->stripsizesoff);\n        }\n        if (s->strippos) {\n            if (s->strippos >= (unsigned)avpkt->size)\n                return AVERROR_INVALIDDATA;\n            bytestream2_init(&stripdata, avpkt->data + s->strippos,\n                            avpkt->size - s->strippos);\n        }\n\n        if (s->rps <= 0 || s->rps % s->subsampling[1]) {\n            av_log(avctx, AV_LOG_ERROR, \"rps %d invalid\\n\", s->rps);\n            return AVERROR_INVALIDDATA;\n        }\n    }\n\n    if (s->photometric == TIFF_PHOTOMETRIC_LINEAR_RAW ||\n        s->photometric == TIFF_PHOTOMETRIC_CFA) {\n        p->color_trc = AVCOL_TRC_LINEAR;\n    } else if (s->photometric == TIFF_PHOTOMETRIC_BLACK_IS_ZERO) {\n        p->color_trc = AVCOL_TRC_GAMMA22;\n    }\n\n    /* Handle DNG images with JPEG-compressed tiles */\n\n    if (is_dng && s->is_tiled) {\n        if (!s->is_jpeg) {\n            avpriv_report_missing_feature(avctx, \"DNG uncompressed tiled images\");\n            return AVERROR_PATCHWELCOME;\n        } else if (!s->is_bayer) {\n            avpriv_report_missing_feature(avctx, \"DNG JPG-compressed tiled non-bayer-encoded images\");\n            return AVERROR_PATCHWELCOME;\n        } else {\n            if ((ret = dng_decode_tiles(avctx, (AVFrame*)data, avpkt)) > 0)\n                *got_frame = 1;\n            return ret;\n        }\n    }\n\n    /* Handle TIFF images and DNG images with uncompressed strips (non-tiled) */\n\n    planes = s->planar ? s->bppcount : 1;\n    for (plane = 0; plane < planes; plane++) {\n        uint8_t *five_planes = NULL;\n        int remaining = avpkt->size;\n        int decoded_height;\n        stride = p->linesize[plane];\n        dst = p->data[plane];\n        if (s->photometric == TIFF_PHOTOMETRIC_SEPARATED &&\n            s->avctx->pix_fmt == AV_PIX_FMT_RGBA) {\n            stride = stride * 5 / 4;\n            five_planes =\n            dst = av_malloc(stride * s->height);\n            if (!dst)\n                return AVERROR(ENOMEM);\n        }\n        for (i = 0; i < s->height; i += s->rps) {\n            if (i)\n                dst += s->rps * stride;\n            if (s->stripsizesoff)\n                ssize = ff_tget(&stripsizes, s->sstype, le);\n            else\n                ssize = s->stripsize;\n\n            if (s->strippos)\n                soff = ff_tget(&stripdata, s->sot, le);\n            else\n                soff = s->stripoff;\n\n            if (soff > avpkt->size || ssize > avpkt->size - soff || ssize > remaining) {\n                av_log(avctx, AV_LOG_ERROR, \"Invalid strip size/offset\\n\");\n                av_freep(&five_planes);\n                return AVERROR_INVALIDDATA;\n            }\n            remaining -= ssize;\n            if ((ret = tiff_unpack_strip(s, p, dst, stride, avpkt->data + soff, ssize, i,\n                                         FFMIN(s->rps, s->height - i))) < 0) {\n                if (avctx->err_recognition & AV_EF_EXPLODE) {\n                    av_freep(&five_planes);\n                    return ret;\n                }\n                break;\n            }\n        }\n        decoded_height = FFMIN(i, s->height);\n\n        if (s->predictor == 2) {\n            if (s->photometric == TIFF_PHOTOMETRIC_YCBCR) {\n                av_log(s->avctx, AV_LOG_ERROR, \"predictor == 2 with YUV is unsupported\");\n                return AVERROR_PATCHWELCOME;\n            }\n            dst   = five_planes ? five_planes : p->data[plane];\n            soff  = s->bpp >> 3;\n            if (s->planar)\n                soff  = FFMAX(soff / s->bppcount, 1);\n            ssize = s->width * soff;\n            if (s->avctx->pix_fmt == AV_PIX_FMT_RGB48LE ||\n                s->avctx->pix_fmt == AV_PIX_FMT_RGBA64LE ||\n                s->avctx->pix_fmt == AV_PIX_FMT_GRAY16LE ||\n                s->avctx->pix_fmt == AV_PIX_FMT_YA16LE ||\n                s->avctx->pix_fmt == AV_PIX_FMT_GBRP16LE ||\n                s->avctx->pix_fmt == AV_PIX_FMT_GBRAP16LE) {\n                for (i = 0; i < decoded_height; i++) {\n                    for (j = soff; j < ssize; j += 2)\n                        AV_WL16(dst + j, AV_RL16(dst + j) + AV_RL16(dst + j - soff));\n                    dst += stride;\n                }\n            } else if (s->avctx->pix_fmt == AV_PIX_FMT_RGB48BE ||\n                       s->avctx->pix_fmt == AV_PIX_FMT_RGBA64BE ||\n                       s->avctx->pix_fmt == AV_PIX_FMT_GRAY16BE ||\n                       s->avctx->pix_fmt == AV_PIX_FMT_YA16BE ||\n                       s->avctx->pix_fmt == AV_PIX_FMT_GBRP16BE ||\n                       s->avctx->pix_fmt == AV_PIX_FMT_GBRAP16BE) {\n                for (i = 0; i < decoded_height; i++) {\n                    for (j = soff; j < ssize; j += 2)\n                        AV_WB16(dst + j, AV_RB16(dst + j) + AV_RB16(dst + j - soff));\n                    dst += stride;\n                }\n            } else {\n                for (i = 0; i < decoded_height; i++) {\n                    for (j = soff; j < ssize; j++)\n                        dst[j] += dst[j - soff];\n                    dst += stride;\n                }\n            }\n        }\n\n        if (s->photometric == TIFF_PHOTOMETRIC_WHITE_IS_ZERO) {\n            int c = (s->avctx->pix_fmt == AV_PIX_FMT_PAL8 ? (1<<s->bpp) - 1 : 255);\n            dst = p->data[plane];\n            for (i = 0; i < s->height; i++) {\n                for (j = 0; j < stride; j++)\n                    dst[j] = c - dst[j];\n                dst += stride;\n            }\n        }\n\n        if (s->photometric == TIFF_PHOTOMETRIC_SEPARATED &&\n            (s->avctx->pix_fmt == AV_PIX_FMT_RGB0 || s->avctx->pix_fmt == AV_PIX_FMT_RGBA)) {\n            int x = s->avctx->pix_fmt == AV_PIX_FMT_RGB0 ? 4 : 5;\n            uint8_t *src = five_planes ? five_planes : p->data[plane];\n            dst = p->data[plane];\n            for (i = 0; i < s->height; i++) {\n                for (j = 0; j < s->width; j++) {\n                    int k =  255 - src[x * j + 3];\n                    int r = (255 - src[x * j    ]) * k;\n                    int g = (255 - src[x * j + 1]) * k;\n                    int b = (255 - src[x * j + 2]) * k;\n                    dst[4 * j    ] = r * 257 >> 16;\n                    dst[4 * j + 1] = g * 257 >> 16;\n                    dst[4 * j + 2] = b * 257 >> 16;\n                    dst[4 * j + 3] = s->avctx->pix_fmt == AV_PIX_FMT_RGBA ? src[x * j + 4] : 255;\n                }\n                src += stride;\n                dst += p->linesize[plane];\n            }\n            av_freep(&five_planes);\n        } else if (s->photometric == TIFF_PHOTOMETRIC_SEPARATED &&\n            s->avctx->pix_fmt == AV_PIX_FMT_RGBA64BE) {\n            dst = p->data[plane];\n            for (i = 0; i < s->height; i++) {\n                for (j = 0; j < s->width; j++) {\n                    uint64_t k =  65535 - AV_RB16(dst + 8 * j + 6);\n                    uint64_t r = (65535 - AV_RB16(dst + 8 * j    )) * k;\n                    uint64_t g = (65535 - AV_RB16(dst + 8 * j + 2)) * k;\n                    uint64_t b = (65535 - AV_RB16(dst + 8 * j + 4)) * k;\n                    AV_WB16(dst + 8 * j    , r * 65537 >> 32);\n                    AV_WB16(dst + 8 * j + 2, g * 65537 >> 32);\n                    AV_WB16(dst + 8 * j + 4, b * 65537 >> 32);\n                    AV_WB16(dst + 8 * j + 6, 65535);\n                }\n                dst += p->linesize[plane];\n            }\n        }\n    }\n\n    if (s->planar && s->bppcount > 2) {\n        FFSWAP(uint8_t*, p->data[0],     p->data[2]);\n        FFSWAP(int,      p->linesize[0], p->linesize[2]);\n        FFSWAP(uint8_t*, p->data[0],     p->data[1]);\n        FFSWAP(int,      p->linesize[0], p->linesize[1]);\n    }\n\n    if (s->is_bayer && s->white_level && s->bpp == 16 && !is_dng) {\n        uint16_t *dst = (uint16_t *)p->data[0];\n        for (i = 0; i < s->height; i++) {\n            for (j = 0; j < s->width; j++)\n                dst[j] = FFMIN((dst[j] / (float)s->white_level) * 65535, 65535);\n            dst += stride / 2;\n        }\n    }\n\n    *got_frame = 1;\n\n    return avpkt->size;\n}\n\nstatic av_cold int tiff_init(AVCodecContext *avctx)\n{\n    TiffContext *s = avctx->priv_data;\n    const AVCodec *codec;\n    int ret;\n\n    s->width  = 0;\n    s->height = 0;\n    s->subsampling[0] =\n    s->subsampling[1] = 1;\n    s->avctx  = avctx;\n    ff_lzw_decode_open(&s->lzw);\n    if (!s->lzw)\n        return AVERROR(ENOMEM);\n    ff_ccitt_unpack_init();\n\n    /* Allocate JPEG frame */\n    s->jpgframe = av_frame_alloc();\n    if (!s->jpgframe)\n        return AVERROR(ENOMEM);\n\n    /* Prepare everything needed for JPEG decoding */\n    codec = avcodec_find_decoder(AV_CODEC_ID_MJPEG);\n    if (!codec)\n        return AVERROR_BUG;\n    s->avctx_mjpeg = avcodec_alloc_context3(codec);\n    if (!s->avctx_mjpeg)\n        return AVERROR(ENOMEM);\n    s->avctx_mjpeg->flags = avctx->flags;\n    s->avctx_mjpeg->flags2 = avctx->flags2;\n    s->avctx_mjpeg->dct_algo = avctx->dct_algo;\n    s->avctx_mjpeg->idct_algo = avctx->idct_algo;\n    ret = avcodec_open2(s->avctx_mjpeg, codec, NULL);\n    if (ret < 0) {\n        return ret;\n    }\n\n    return 0;\n}\n\nstatic av_cold int tiff_end(AVCodecContext *avctx)\n{\n    TiffContext *const s = avctx->priv_data;\n\n    free_geotags(s);\n\n    ff_lzw_decode_close(&s->lzw);\n    av_freep(&s->deinvert_buf);\n    s->deinvert_buf_size = 0;\n    av_freep(&s->yuv_line);\n    s->yuv_line_size = 0;\n    av_freep(&s->fax_buffer);\n    s->fax_buffer_size = 0;\n    av_frame_free(&s->jpgframe);\n    avcodec_free_context(&s->avctx_mjpeg);\n    return 0;\n}\n\n#define OFFSET(x) offsetof(TiffContext, x)\nstatic const AVOption tiff_options[] = {\n    { \"subimage\", \"decode subimage instead if available\", OFFSET(get_subimage), AV_OPT_TYPE_BOOL, {.i64=0},  0, 1, AV_OPT_FLAG_DECODING_PARAM | AV_OPT_FLAG_VIDEO_PARAM },\n    { \"thumbnail\", \"decode embedded thumbnail subimage instead if available\", OFFSET(get_thumbnail), AV_OPT_TYPE_BOOL, {.i64=0},  0, 1, AV_OPT_FLAG_DECODING_PARAM | AV_OPT_FLAG_VIDEO_PARAM },\n    { \"page\", \"page number of multi-page image to decode (starting from 1)\", OFFSET(get_page), AV_OPT_TYPE_INT, {.i64=0}, 0, UINT16_MAX, AV_OPT_FLAG_DECODING_PARAM | AV_OPT_FLAG_VIDEO_PARAM },\n    { NULL },\n};\n\nstatic const AVClass tiff_decoder_class = {\n    .class_name = \"TIFF decoder\",\n    .item_name  = av_default_item_name,\n    .option     = tiff_options,\n    .version    = LIBAVUTIL_VERSION_INT,\n};\n\nAVCodec ff_tiff_decoder = {\n    .name           = \"tiff\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"TIFF image\"),\n    .type           = AVMEDIA_TYPE_VIDEO,\n    .id             = AV_CODEC_ID_TIFF,\n    .priv_data_size = sizeof(TiffContext),\n    .init           = tiff_init,\n    .close          = tiff_end,\n    .decode         = decode_frame,\n    .capabilities   = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS,\n    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,\n    .priv_class     = &tiff_decoder_class,\n};\n"], "filenames": ["libavcodec/tiff.c"], "buggy_code_start_loc": [1926], "buggy_code_end_loc": [1934], "fixing_code_start_loc": [1926], "fixing_code_end_loc": [1937], "type": "CWE-476", "message": "An issue was discovered in decode_frame in libavcodec/tiff.c in FFmpeg version 4.3, allows remote attackers to cause a denial of service (DoS).", "other": {"cve": {"id": "CVE-2020-36138", "sourceIdentifier": "cve@mitre.org", "published": "2023-08-11T14:15:11.910", "lastModified": "2023-08-16T15:20:17.433", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in decode_frame in libavcodec/tiff.c in FFmpeg version 4.3, allows remote attackers to cause a denial of service (DoS)."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:4.3:*:*:*:*:*:*:*", "matchCriteriaId": "11B518F8-B4A9-44CC-A440-EB95E41C4B2A"}]}]}], "references": [{"url": "https://github.com/FFmpeg/FFmpeg/commit/292e41ce650a7b5ca5de4ae87fff0d6a90d9fc97", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://lists.ffmpeg.org/pipermail/ffmpeg-devel/2020-November/272001.html", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://trac.ffmpeg.org/ticket/8960", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/292e41ce650a7b5ca5de4ae87fff0d6a90d9fc97"}}