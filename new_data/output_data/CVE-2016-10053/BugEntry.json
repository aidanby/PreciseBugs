{"buggy_code": ["2016-08-15  7.0.2-10 Cristy  <quetzlzacatenango@image...>\n  * Prevent buffer overflow in BMP & SGI coders (bug report from\n    pwchen&rayzhong of tencent).\n  * Prevent buffer overflow in SIXEL, PDB, MAP, and CALS coders (bug report\n    from Donghai Zhu).\n\n2016-08-14  7.0.2-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-9, GIT revision 18707:2c02f09:20160814.\n\n2016-08-14  7.0.2-9 Cristy  <quetzlzacatenango@image...>\n  * Fix compile error in opencl.c (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=30289).\n  * Eliminate compiler warning.\n\n2016-08-14  7.0.2-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-8, GIT revision 18698:74b1d5d:20160814.\n\n2016-08-07  7.0.2-8 Cristy  <quetzlzacatenango@image...>\n  * Prevent spurious removal of MPC cache files (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=30256).\n  * Note alpha channel when combining 4 or more images (reference\n    https://github.com/ImageMagick/ImageMagick/issues/250).\n\n2016-08-06  7.0.2-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-7, GIT revision 10980:ecc03a2:20160806.\n\n2016-08-01  7.0.2-7 Cristy  <quetzlzacatenango@image...>\n  * Evaluate lazy pixel cache morphology to prevent buffer overflow (bug report\n    from Ibrahim M. El-Sayed).\n  * Prevent buffer overflow (bug report from Max Thrane).\n  * Prevent memory use after free (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=30245).\n\n2016-07-30  7.0.2-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-6, GIT revision 18651:df24175:20160729.\n\n2016-07-29  7.0.2-6 Cristy  <quetzlzacatenango@image...>\n  * Support -region option (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=1&t=29692).\n\n2016-07-21  7.0.2-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-5, GIT revision 18627:2b5ddbd:20160721.\n\n2016-07-13  7.0.2-5 Cristy  <quetzlzacatenango@image...>\n  * Fix MVG stroke-opacity (reference\n    https://github.com/ImageMagick/ImageMagick/issues/229).\n  * Prevent possible buffer overflow when reading TIFF images (bug report from\n    Shi Pu of MS509 Team).\n  * Initialize index channel to get expected results from the stegano coder.\n\n2016-07-11  7.0.2-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-4, GIT revision 18591:50debe5:20160710.\n\n2016-07-10  7.0.2-4 Cristy  <quetzlzacatenango@image...>\n  * To comply with the SVG standard, use stroke-opacity for transparent strokes.\n  * Define CompositeChannels mask to Red, Green, Blue, Alpha, and Black.\n\n2016-07-09  7.0.2-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-3, GIT revision 18572:28560fc:20160709.\n\n2016-07-01  7.0.2-3 Cristy  <quetzlzacatenango@image...>\n  * Patch so -kuwahara option can preserve colormapped edges.\n  * The histogram coder now returns the correct extent.\n  * Use CopyMagickString() rather than CopyMagickMemory() for strings.\n\n2016-06-26  7.0.2-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-2, GIT revision 18514:a7b5b46:20160626.\n\n2016-06-23  7.0.2-2 Cristy  <quetzlzacatenango@image...>\n  * Correct for numerical instability (reference\n    https://github.com/ImageMagick/ImageMagick/issues/218).\n\t\t\t \n2016-06-21  7.0.2-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-1, GIT revision 18479:931319b:20160622.\n\n2016-06-17  7.0.2-1 Dirk Lemstra <dirk@lem.....org>\n  * Added support for GROUP4 compression to the FAX coder.\n\n2016-06-12  7.0.2-1 Cristy  <quetzlzacatenango@image...>\n  * Distort no longer converts grayscale image to sRGB (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=1&t=29895).\n  * Don't return a zero bounding box for QueryMultilineFontMetrics() (reference\n    https://github.com/ImageMagick/ImageMagick/issues/222).\n\n2016-06-12  7.0.2-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-0, GIT revision 10884:f0e15e8:20160612.\n\n2016-06-09  7.0.2-0 Cristy  <quetzlzacatenango@image...>\n  * Backoff finite precision epsilon (reference\n    https://github.com/ImageMagick/ImageMagick/issues/215).\n  * Fix drawing glitch for stroke widths greater than 2 (reference\n    https://github.com/ImageMagick/ImageMagick/issues/218).\n\n2016-06-05  7.0.1-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-10, GIT revision 18406:ba4ad2d:20160607.\n\n2016-06-04  7.0.1-10 Cristy  <quetzlzacatenango@image...>\n  * Deny indirect reads by policy, remove policy to permit, e.g.,\n    convert caption:@mytext.txt ...\n  * RLE check for pixel offset less than 0 (heap overflow report from Craig\n    Young).\n  * Properly initialze PES blocks (reference\n    https://github.com/ImageMagick/ImageMagick/issues/213).\n\n2016-06-03  7.0.1-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-9, GIT revision 10847:339f803:20160602.\n\n2016-06-02  7.0.1-9 Cristy  <quetzlzacatenango@image...>\n  * Fix small memory leak (patch provided by \u0410\u043d\u0434\u0440\u0435\u0439 \u0427\u0435\u0440\u043d\u044b\u0439).\n  * Coder path traversal is not authorized (bug report provided by\n    Masaaki Chida).\n  * Turn off alpha channel for the compare difference image (reference\n    http://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=29828).\n\n2016-05-31  7.0.1-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-8, GIT revision 18334:97775b5:20160531.\n\n2016-05-31  7.0.1-8 Cristy  <quetzlzacatenango@image...>\n  * Support configure script --enable-pipes option to enable pipes (|) in\n    filenames.\n  * Support configure script --enable-indirect-reads option to enable\n    indirect reads (@) in filenames.\n\n2016-05-30  7.0.1-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-7, GIT revision 18321:5511ef5:20160530.\n\n2016-05-25  7.0.1-7 Cristy  <quetzlzacatenango@image...>\n  * Security improvements to TEXT coder broke it (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=29754).\n  * Fix stroke offset problem for -annotate (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=29626).\n  * Don't interpret -fx option arguments (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=29774);\n  * Add additional checks to DCM reader to prevent data-driven faults (bug\n    report from Hanno B\u00f6ck).\n\n2016-05-21  7.0.1-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-6, GIT revision 18241:d4f277c:20160521.\n\n2016-05-20  7.0.1-6 Cristy  <quetzlzacatenango@image...>\n  * Fixed proper placement of text annotation for east / west gravity.\n\n2016-05-18  7.0.1-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-5, GIT revision 10789:f7c2e89:20160518,\n\n2016-05-18  7.0.1-5 Cristy  <quetzlzacatenango@image...>\n  * Process channels independently for -channel -equalize (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=29708).\n  * Fix pixel cache on disk regression (reference\n    https://github.com/ImageMagick/ImageMagick/issues/202).\n\n2016-05-15  7.0.1-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-4, GIT revision 10778:52dae14:20160516.\n\n2016-05-10  7.0.1-4 Cristy  <quetzlzacatenango@image...>\n  * Prevent possible shell command injection vulnerability through the\n    authenticate parameter of the PDF, PCL and XPS coders (report from\n    Erez Turjeman).\n  * Quote passwords when passed to a delegate program.\n  * Iterate channels over source image rather than destination (bug report\n    from Hanno B\u00f6ck).\n  * Can read geo-related EXIF metdata once-again (reference\n    https://github.com/ImageMagick/ImageMagick/issues/198).\n  * Sanitize all delegate emedded formatting characters.\n  * Don't sync pixel cache in AcquireAuthenticCacheView() (bug report from\n    Hanno B\u00f6ck).\n\n2016-05-09  7.0.1-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-3, GIT revision 10755:d540dda:20160509.\n\n2016-05-07  7.0.1-3 Cristy  <quetzlzacatenango@image...>\n  * Remove https delegate.\n\n2016-05-06  7.0.1-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-2, GIT revision 10741:5746147:20160507.\n\n2016-05-04  7.0.1-2 Cristy  <quetzlzacatenango@image...>\n  * Check for buffer overflow in magick/draw.c/DrawStrokePolygon().\n  * Replace show delegate title with image filename rather than label.\n  * Fix GetNextToken() off by one error.\n  * Remove support for internal ephemeral coder.\n\n2016-05-03  7.0.1-1 Cristy  <quetzlzacatenango@image...>\n  * New version 7.0.1-1, GIT revision 10723:9fc8a0c:20160503.\n\n2016-05-03  7.0.1-1 Cristy  <quetzlzacatenango@image...>\n  * Sanitize input filename for http / https delegates (improved patch).\n  * Fix for possible security vulnerabilities (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=4&t=29588).\n\n2016-04-30  7.0.1-0 Cristy  <quetzlzacatenango@image...>\n  * New version 7.0.1-0, GIT revision 10716:b527bce:20160430.\n\n2016-01-30  7.0.0-0 \tFahad-Alsaidi & ShamsaHamed\n  * Add support for languages that require complex text layout (reference\n    https://github.com/ImageMagick/ImageMagick/pull/88).\n\n2012-04-27  7.0.0-0 Anthony thyssen <A.Thyssen@griffith...>\n  * Allow the use of set and escapes when no images in memory\n    (unless you attempt to access per-image meta-data)\n    Currently does not include %[fx:...] and %[pixel:...]\n\n2012-10-05  7.0.0-0 Anthony thyssen <A.Thyssen@griffith...>\n  * Rather than replicate 'options' into 'artifacts' make a link\n    from image to image_info and lookup a global option if no artifact\n    is defined.\n\n2012-09-11  7.0.0-0 Nicolas Robidoux <nicolas.robidoux@gmail...>\n  * sigmoidal-contrast:\n  * Remove unnecessary initial ClampToQuantum.\n\n2012-09-10  7.0.0-0 Nicolas Robidoux <nicolas.robidoux@gmail...>\n  * sigmoidal-contrast:\n  * Direct computation, without LUT;\n  * Fix re-declaration of i (at the top, and inside a conditional).\n\n2012-09-04  7.0.0-0 Nicolas Robidoux <nicolas.robidoux@gmail...>\n  * Add tanh/atanh clone of legacy sigmoidal map (faster & more accurate).\n\n2012-08-08  7.0.0-0 Nicolas Robidoux <nicolas.robidoux@gmail...>\n  * Add final ClampToQuantum in sigmoidal colormap loop.\n  * Remove OpenMP calls from colormap update loops.\n\n2011-08-01  7.0.0-0 Cristy  <quetzlzacatenango@image...>\n  * New version 7.0.0-0.\n\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                        TTTTT  IIIII  FFFFF  FFFFF                           %\n%                          T      I    F      F                               %\n%                          T      I    FFF    FFF                             %\n%                          T      I    F      F                               %\n%                          T    IIIII  F      F                               %\n%                                                                             %\n%                                                                             %\n%                        Read/Write TIFF Image Format                         %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n#ifdef __VMS\n#define JPEG_SUPPORT 1\n#endif\n\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/enhance.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/memory-private.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/pixel-private.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/resize.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/splay-tree.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/thread_.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/utility.h\"\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n# if defined(MAGICKCORE_HAVE_TIFFCONF_H)\n#  include \"tiffconf.h\"\n# endif\n# include \"tiff.h\"\n# include \"tiffio.h\"\n# if !defined(COMPRESSION_ADOBE_DEFLATE)\n#  define COMPRESSION_ADOBE_DEFLATE  8\n# endif\n# if !defined(PREDICTOR_HORIZONTAL)\n# define PREDICTOR_HORIZONTAL  2\n# endif\n# if !defined(TIFFTAG_COPYRIGHT)\n#  define TIFFTAG_COPYRIGHT  33432\n# endif\n# if !defined(TIFFTAG_OPIIMAGEID)\n#  define TIFFTAG_OPIIMAGEID  32781\n# endif\n#include \"psd-private.h\"\n\n/*\n  Typedef declarations.\n*/\ntypedef enum\n{\n  ReadSingleSampleMethod,\n  ReadRGBAMethod,\n  ReadCMYKAMethod,\n  ReadYCCKMethod,\n  ReadStripMethod,\n  ReadTileMethod,\n  ReadGenericMethod\n} TIFFMethodType;\n\n#if defined(MAGICKCORE_HAVE_TIFFREADEXIFDIRECTORY)\ntypedef struct _ExifInfo\n{\n  unsigned int\n    tag,\n    type,\n    variable_length;\n\n  const char\n    *property;\n} ExifInfo;\n\nstatic const ExifInfo\n  exif_info[] = {\n    { EXIFTAG_EXPOSURETIME, TIFF_RATIONAL, 0, \"exif:ExposureTime\" },\n    { EXIFTAG_FNUMBER, TIFF_RATIONAL, 0, \"exif:FNumber\" },\n    { EXIFTAG_EXPOSUREPROGRAM, TIFF_SHORT, 0, \"exif:ExposureProgram\" },\n    { EXIFTAG_SPECTRALSENSITIVITY, TIFF_ASCII, 0, \"exif:SpectralSensitivity\" },\n    { EXIFTAG_ISOSPEEDRATINGS, TIFF_SHORT, 1, \"exif:ISOSpeedRatings\" },\n    { EXIFTAG_OECF, TIFF_NOTYPE, 0, \"exif:OptoelectricConversionFactor\" },\n    { EXIFTAG_EXIFVERSION, TIFF_NOTYPE, 0, \"exif:ExifVersion\" },\n    { EXIFTAG_DATETIMEORIGINAL, TIFF_ASCII, 0, \"exif:DateTimeOriginal\" },\n    { EXIFTAG_DATETIMEDIGITIZED, TIFF_ASCII, 0, \"exif:DateTimeDigitized\" },\n    { EXIFTAG_COMPONENTSCONFIGURATION, TIFF_NOTYPE, 0, \"exif:ComponentsConfiguration\" },\n    { EXIFTAG_COMPRESSEDBITSPERPIXEL, TIFF_RATIONAL, 0, \"exif:CompressedBitsPerPixel\" },\n    { EXIFTAG_SHUTTERSPEEDVALUE, TIFF_SRATIONAL, 0, \"exif:ShutterSpeedValue\" },\n    { EXIFTAG_APERTUREVALUE, TIFF_RATIONAL, 0, \"exif:ApertureValue\" },\n    { EXIFTAG_BRIGHTNESSVALUE, TIFF_SRATIONAL, 0, \"exif:BrightnessValue\" },\n    { EXIFTAG_EXPOSUREBIASVALUE, TIFF_SRATIONAL, 0, \"exif:ExposureBiasValue\" },\n    { EXIFTAG_MAXAPERTUREVALUE, TIFF_RATIONAL, 0, \"exif:MaxApertureValue\" },\n    { EXIFTAG_SUBJECTDISTANCE, TIFF_RATIONAL, 0, \"exif:SubjectDistance\" },\n    { EXIFTAG_METERINGMODE, TIFF_SHORT, 0, \"exif:MeteringMode\" },\n    { EXIFTAG_LIGHTSOURCE, TIFF_SHORT, 0, \"exif:LightSource\" },\n    { EXIFTAG_FLASH, TIFF_SHORT, 0, \"exif:Flash\" },\n    { EXIFTAG_FOCALLENGTH, TIFF_RATIONAL, 0, \"exif:FocalLength\" },\n    { EXIFTAG_SUBJECTAREA, TIFF_NOTYPE, 0, \"exif:SubjectArea\" },\n    { EXIFTAG_MAKERNOTE, TIFF_NOTYPE, 0, \"exif:MakerNote\" },\n    { EXIFTAG_USERCOMMENT, TIFF_NOTYPE, 0, \"exif:UserComment\" },\n    { EXIFTAG_SUBSECTIME, TIFF_ASCII, 0, \"exif:SubSecTime\" },\n    { EXIFTAG_SUBSECTIMEORIGINAL, TIFF_ASCII, 0, \"exif:SubSecTimeOriginal\" },\n    { EXIFTAG_SUBSECTIMEDIGITIZED, TIFF_ASCII, 0, \"exif:SubSecTimeDigitized\" },\n    { EXIFTAG_FLASHPIXVERSION, TIFF_NOTYPE, 0, \"exif:FlashpixVersion\" },\n    { EXIFTAG_PIXELXDIMENSION, TIFF_LONG, 0, \"exif:PixelXDimension\" },\n    { EXIFTAG_PIXELYDIMENSION, TIFF_LONG, 0, \"exif:PixelYDimension\" },\n    { EXIFTAG_RELATEDSOUNDFILE, TIFF_ASCII, 0, \"exif:RelatedSoundFile\" },\n    { EXIFTAG_FLASHENERGY, TIFF_RATIONAL, 0, \"exif:FlashEnergy\" },\n    { EXIFTAG_SPATIALFREQUENCYRESPONSE, TIFF_NOTYPE, 0, \"exif:SpatialFrequencyResponse\" },\n    { EXIFTAG_FOCALPLANEXRESOLUTION, TIFF_RATIONAL, 0, \"exif:FocalPlaneXResolution\" },\n    { EXIFTAG_FOCALPLANEYRESOLUTION, TIFF_RATIONAL, 0, \"exif:FocalPlaneYResolution\" },\n    { EXIFTAG_FOCALPLANERESOLUTIONUNIT, TIFF_SHORT, 0, \"exif:FocalPlaneResolutionUnit\" },\n    { EXIFTAG_SUBJECTLOCATION, TIFF_SHORT, 0, \"exif:SubjectLocation\" },\n    { EXIFTAG_EXPOSUREINDEX, TIFF_RATIONAL, 0, \"exif:ExposureIndex\" },\n    { EXIFTAG_SENSINGMETHOD, TIFF_SHORT, 0, \"exif:SensingMethod\" },\n    { EXIFTAG_FILESOURCE, TIFF_NOTYPE, 0, \"exif:FileSource\" },\n    { EXIFTAG_SCENETYPE, TIFF_NOTYPE, 0, \"exif:SceneType\" },\n    { EXIFTAG_CFAPATTERN, TIFF_NOTYPE, 0, \"exif:CFAPattern\" },\n    { EXIFTAG_CUSTOMRENDERED, TIFF_SHORT, 0, \"exif:CustomRendered\" },\n    { EXIFTAG_EXPOSUREMODE, TIFF_SHORT, 0, \"exif:ExposureMode\" },\n    { EXIFTAG_WHITEBALANCE, TIFF_SHORT, 0, \"exif:WhiteBalance\" },\n    { EXIFTAG_DIGITALZOOMRATIO, TIFF_RATIONAL, 0, \"exif:DigitalZoomRatio\" },\n    { EXIFTAG_FOCALLENGTHIN35MMFILM, TIFF_SHORT, 0, \"exif:FocalLengthIn35mmFilm\" },\n    { EXIFTAG_SCENECAPTURETYPE, TIFF_SHORT, 0, \"exif:SceneCaptureType\" },\n    { EXIFTAG_GAINCONTROL, TIFF_RATIONAL, 0, \"exif:GainControl\" },\n    { EXIFTAG_CONTRAST, TIFF_SHORT, 0, \"exif:Contrast\" },\n    { EXIFTAG_SATURATION, TIFF_SHORT, 0, \"exif:Saturation\" },\n    { EXIFTAG_SHARPNESS, TIFF_SHORT, 0, \"exif:Sharpness\" },\n    { EXIFTAG_DEVICESETTINGDESCRIPTION, TIFF_NOTYPE, 0, \"exif:DeviceSettingDescription\" },\n    { EXIFTAG_SUBJECTDISTANCERANGE, TIFF_SHORT, 0, \"exif:SubjectDistanceRange\" },\n    { EXIFTAG_IMAGEUNIQUEID, TIFF_ASCII, 0, \"exif:ImageUniqueID\" },\n    { 0, 0, 0, (char *) NULL }\n};\n#endif\n#endif  /* MAGICKCORE_TIFF_DELEGATE */\n\f\n/*\n  Global declarations.\n*/\nstatic MagickThreadKey\n  tiff_exception;\n\nstatic SemaphoreInfo\n  *tiff_semaphore = (SemaphoreInfo *) NULL;\n\nstatic TIFFErrorHandler\n  error_handler,\n  warning_handler;\n\nstatic volatile MagickBooleanType\n  instantiate_key = MagickFalse;\n\f\n/*\n  Forward declarations.\n*/\n#if defined(MAGICKCORE_TIFF_DELEGATE)\nstatic Image *\n  ReadTIFFImage(const ImageInfo *,ExceptionInfo *);\n\nstatic MagickBooleanType\n  WriteGROUP4Image(const ImageInfo *,Image *,ExceptionInfo *),\n  WritePTIFImage(const ImageInfo *,Image *,ExceptionInfo *),\n  WriteTIFFImage(const ImageInfo *,Image *,ExceptionInfo *);\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s T I F F                                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsTIFF() returns MagickTrue if the image format type, identified by the\n%  magick string, is TIFF.\n%\n%  The format of the IsTIFF method is:\n%\n%      MagickBooleanType IsTIFF(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsTIFF(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\115\\115\\000\\052\",4) == 0)\n    return(MagickTrue);\n  if (memcmp(magick,\"\\111\\111\\052\\000\",4) == 0)\n    return(MagickTrue);\n#if defined(TIFF_VERSION_BIG)\n  if (length < 8)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\115\\115\\000\\053\\000\\010\\000\\000\",8) == 0)\n    return(MagickTrue);\n  if (memcmp(magick,\"\\111\\111\\053\\000\\010\\000\\000\\000\",8) == 0)\n    return(MagickTrue);\n#endif\n  return(MagickFalse);\n}\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d G R O U P 4 I m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadGROUP4Image() reads a raw CCITT Group 4 image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadGROUP4Image method is:\n%\n%      Image *ReadGROUP4Image(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline size_t WriteLSBLong(FILE *file,const size_t value)\n{\n  unsigned char\n    buffer[4];\n\n  buffer[0]=(unsigned char) value;\n  buffer[1]=(unsigned char) (value >> 8);\n  buffer[2]=(unsigned char) (value >> 16);\n  buffer[3]=(unsigned char) (value >> 24);\n  return(fwrite(buffer,1,4,file));\n}\n\nstatic Image *ReadGROUP4Image(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n\n  FILE\n    *file;\n\n  Image\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    length;\n\n  ssize_t\n    offset,\n    strip_offset;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Write raw CCITT Group 4 wrapped as a TIFF image file.\n  */\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"wb\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    ThrowImageException(FileOpenError,\"UnableToCreateTemporaryFile\");\n  length=fwrite(\"\\111\\111\\052\\000\\010\\000\\000\\000\\016\\000\",1,10,file);\n  length=fwrite(\"\\376\\000\\003\\000\\001\\000\\000\\000\\000\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\000\\001\\004\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,image->columns);\n  length=fwrite(\"\\001\\001\\004\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,image->rows);\n  length=fwrite(\"\\002\\001\\003\\000\\001\\000\\000\\000\\001\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\003\\001\\003\\000\\001\\000\\000\\000\\004\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\006\\001\\003\\000\\001\\000\\000\\000\\000\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\021\\001\\003\\000\\001\\000\\000\\000\",1,8,file);\n  strip_offset=10+(12*14)+4+8;\n  length=WriteLSBLong(file,(size_t) strip_offset);\n  length=fwrite(\"\\022\\001\\003\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(size_t) image_info->orientation);\n  length=fwrite(\"\\025\\001\\003\\000\\001\\000\\000\\000\\001\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\026\\001\\004\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,image->rows);\n  length=fwrite(\"\\027\\001\\004\\000\\001\\000\\000\\000\\000\\000\\000\\000\",1,12,file);\n  offset=(ssize_t) ftell(file)-4;\n  length=fwrite(\"\\032\\001\\005\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(size_t) (strip_offset-8));\n  length=fwrite(\"\\033\\001\\005\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(size_t) (strip_offset-8));\n  length=fwrite(\"\\050\\001\\003\\000\\001\\000\\000\\000\\002\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\000\\000\\000\\000\",1,4,file);\n  length=WriteLSBLong(file,(long) image->resolution.x);\n  length=WriteLSBLong(file,1);\n  status=MagickTrue;\n  for (length=0; (c=ReadBlobByte(image)) != EOF; length++)\n    if (fputc(c,file) != c)\n      status=MagickFalse;\n  offset=(ssize_t) fseek(file,(ssize_t) offset,SEEK_SET);\n  length=WriteLSBLong(file,(unsigned int) length);\n  (void) fclose(file);\n  (void) CloseBlob(image);\n  image=DestroyImage(image);\n  /*\n    Read TIFF image.\n  */\n  read_info=CloneImageInfo((ImageInfo *) NULL);\n  (void) FormatLocaleString(read_info->filename,MagickPathExtent,\"%s\",filename);\n  image=ReadTIFFImage(read_info,exception);\n  read_info=DestroyImageInfo(read_info);\n  if (image != (Image *) NULL)\n    {\n      (void) CopyMagickString(image->filename,image_info->filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image->magick_filename,image_info->filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image->magick,\"GROUP4\",MagickPathExtent);\n    }\n  (void) RelinquishUniqueFileResource(filename);\n  if (status == MagickFalse)\n    image=DestroyImage(image);\n  return(image);\n}\n#endif\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d T I F F I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadTIFFImage() reads a Tagged image file and returns it.  It allocates the\n%  memory necessary for the new Image structure and returns a pointer to the\n%  new image.\n%\n%  The format of the ReadTIFFImage method is:\n%\n%      Image *ReadTIFFImage(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline unsigned char ClampYCC(double value)\n{\n  value=255.0-value;\n  if (value < 0.0)\n    return((unsigned char)0);\n  if (value > 255.0)\n    return((unsigned char)255);\n  return((unsigned char)(value));\n}\n\nstatic MagickBooleanType DecodeLabImage(Image *image,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        a,\n        b;\n\n      a=QuantumScale*GetPixela(image,q)+0.5;\n      if (a > 1.0)\n        a-=1.0;\n      b=QuantumScale*GetPixelb(image,q)+0.5;\n      if (b > 1.0)\n        b-=1.0;\n      SetPixela(image,QuantumRange*a,q);\n      SetPixelb(image,QuantumRange*b,q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\nstatic MagickBooleanType ReadProfile(Image *image,const char *name,\n  const unsigned char *datum,ssize_t length,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  StringInfo\n    *profile;\n\n  if (length < 4)\n    return(MagickFalse);\n  profile=BlobToStringInfo(datum,(size_t) length);\n  if (profile == (StringInfo *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  status=SetImageProfile(image,name,profile,exception);\n  profile=DestroyStringInfo(profile);\n  if (status == MagickFalse)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  return(MagickTrue);\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\nstatic int TIFFCloseBlob(thandle_t image)\n{\n  (void) CloseBlob((Image *) image);\n  return(0);\n}\n\nstatic void TIFFErrors(const char *module,const char *format,va_list error)\n{\n  char\n    message[MagickPathExtent];\n\n  ExceptionInfo\n    *exception;\n\n#if defined(MAGICKCORE_HAVE_VSNPRINTF)\n  (void) vsnprintf(message,MagickPathExtent,format,error);\n#else\n  (void) vsprintf(message,format,error);\n#endif\n  (void) ConcatenateMagickString(message,\".\",MagickPathExtent);\n  exception=(ExceptionInfo *) GetMagickThreadValue(tiff_exception);\n  if (exception != (ExceptionInfo *) NULL)\n    (void) ThrowMagickException(exception,GetMagickModule(),CoderError,message,\n      \"`%s'\",module);\n}\n\nstatic toff_t TIFFGetBlobSize(thandle_t image)\n{\n  return((toff_t) GetBlobSize((Image *) image));\n}\n\nstatic void TIFFGetProfiles(TIFF *tiff,Image *image,MagickBooleanType ping,\n  ExceptionInfo *exception)\n{\n  uint32\n    length;\n\n  unsigned char\n    *profile;\n\n  length=0;\n  if (ping == MagickFalse)\n    {\n#if defined(TIFFTAG_ICCPROFILE)\n      if ((TIFFGetField(tiff,TIFFTAG_ICCPROFILE,&length,&profile) == 1) &&\n          (profile != (unsigned char *) NULL))\n        (void) ReadProfile(image,\"icc\",profile,(ssize_t) length,exception);\n#endif\n#if defined(TIFFTAG_PHOTOSHOP)\n      if ((TIFFGetField(tiff,TIFFTAG_PHOTOSHOP,&length,&profile) == 1) &&\n          (profile != (unsigned char *) NULL))\n        (void) ReadProfile(image,\"8bim\",profile,(ssize_t) length,exception);\n#endif\n#if defined(TIFFTAG_RICHTIFFIPTC)\n      if ((TIFFGetField(tiff,TIFFTAG_RICHTIFFIPTC,&length,&profile) == 1) &&\n          (profile != (unsigned char *) NULL))\n        {\n          if (TIFFIsByteSwapped(tiff) != 0)\n            TIFFSwabArrayOfLong((uint32 *) profile,(size_t) length);\n          (void) ReadProfile(image,\"iptc\",profile,4L*length,exception);\n        }\n#endif\n#if defined(TIFFTAG_XMLPACKET)\n      if ((TIFFGetField(tiff,TIFFTAG_XMLPACKET,&length,&profile) == 1) &&\n          (profile != (unsigned char *) NULL))\n        (void) ReadProfile(image,\"xmp\",profile,(ssize_t) length,exception);\n#endif\n      if ((TIFFGetField(tiff,34118,&length,&profile) == 1) &&\n          (profile != (unsigned char *) NULL))\n        (void) ReadProfile(image,\"tiff:34118\",profile,(ssize_t) length,\n          exception);\n    }\n  if ((TIFFGetField(tiff,37724,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    (void) ReadProfile(image,\"tiff:37724\",profile,(ssize_t) length,exception);\n}\n\nstatic void TIFFGetProperties(TIFF *tiff,Image *image,ExceptionInfo *exception)\n{\n  char\n    message[MagickPathExtent],\n    *text;\n\n  uint32\n    count,\n    length,\n    type;\n\n  unsigned long\n    *tietz;\n\n\n  if (TIFFGetField(tiff,TIFFTAG_ARTIST,&text) == 1)\n    (void) SetImageProperty(image,\"tiff:artist\",text,exception);\n  if (TIFFGetField(tiff,TIFFTAG_COPYRIGHT,&text) == 1)\n    (void) SetImageProperty(image,\"tiff:copyright\",text,exception);\n  if (TIFFGetField(tiff,TIFFTAG_DATETIME,&text) == 1)\n    (void) SetImageProperty(image,\"tiff:timestamp\",text,exception);\n  if (TIFFGetField(tiff,TIFFTAG_DOCUMENTNAME,&text) == 1)\n    (void) SetImageProperty(image,\"tiff:document\",text,exception);\n  if (TIFFGetField(tiff,TIFFTAG_HOSTCOMPUTER,&text) == 1)\n    (void) SetImageProperty(image,\"tiff:hostcomputer\",text,exception);\n  if (TIFFGetField(tiff,TIFFTAG_IMAGEDESCRIPTION,&text) == 1)\n    (void) SetImageProperty(image,\"comment\",text,exception);\n  if (TIFFGetField(tiff,TIFFTAG_MAKE,&text) == 1)\n    (void) SetImageProperty(image,\"tiff:make\",text,exception);\n  if (TIFFGetField(tiff,TIFFTAG_MODEL,&text) == 1)\n    (void) SetImageProperty(image,\"tiff:model\",text,exception);\n  if (TIFFGetField(tiff,TIFFTAG_OPIIMAGEID,&count,&text) == 1)\n    {\n      if (count >= MagickPathExtent)\n        count=MagickPathExtent-1;\n      (void) CopyMagickString(message,text,count+1);\n      (void) SetImageProperty(image,\"tiff:image-id\",message,exception);\n    }\n  if (TIFFGetField(tiff,TIFFTAG_PAGENAME,&text) == 1)\n    (void) SetImageProperty(image,\"label\",text,exception);\n  if (TIFFGetField(tiff,TIFFTAG_SOFTWARE,&text) == 1)\n    (void) SetImageProperty(image,\"tiff:software\",text,exception);\n  if (TIFFGetField(tiff,33423,&count,&text) == 1)\n    {\n      if (count >= MagickPathExtent)\n        count=MagickPathExtent-1;\n      (void) CopyMagickString(message,text,count+1);\n      (void) SetImageProperty(image,\"tiff:kodak-33423\",message,exception);\n    }\n  if (TIFFGetField(tiff,36867,&count,&text) == 1)\n    {\n      if (count >= MagickPathExtent)\n        count=MagickPathExtent-1;\n      (void) CopyMagickString(message,text,count+1);\n      (void) SetImageProperty(image,\"tiff:kodak-36867\",message,exception);\n    }\n  if (TIFFGetField(tiff,TIFFTAG_SUBFILETYPE,&type) == 1)\n    switch (type)\n    {\n      case 0x01:\n      {\n        (void) SetImageProperty(image,\"tiff:subfiletype\",\"REDUCEDIMAGE\",\n          exception);\n        break;\n      }\n      case 0x02:\n      {\n        (void) SetImageProperty(image,\"tiff:subfiletype\",\"PAGE\",exception);\n        break;\n      }\n      case 0x04:\n      {\n        (void) SetImageProperty(image,\"tiff:subfiletype\",\"MASK\",exception);\n        break;\n      }\n      default:\n        break;\n    }\n  if (TIFFGetField(tiff,37706,&length,&tietz) == 1)\n    {\n      (void) FormatLocaleString(message,MagickPathExtent,\"%lu\",tietz[0]);\n      (void) SetImageProperty(image,\"tiff:tietz_offset\",message,exception);\n    }\n}\n\nstatic void TIFFGetEXIFProperties(TIFF *tiff,Image *image,\n  ExceptionInfo *exception)\n{\n#if defined(MAGICKCORE_HAVE_TIFFREADEXIFDIRECTORY)\n  char\n    value[MagickPathExtent];\n\n  register ssize_t\n    i;\n\n  tdir_t\n    directory;\n\n#if defined(TIFF_VERSION_BIG)\n  uint64\n#else\n  uint32\n#endif\n    offset;\n\n  void\n    *sans;\n\n  /*\n    Read EXIF properties.\n  */\n  offset=0;\n  if (TIFFGetField(tiff,TIFFTAG_EXIFIFD,&offset) != 1)\n    return;\n  directory=TIFFCurrentDirectory(tiff);\n  if (TIFFReadEXIFDirectory(tiff,offset) != 1)\n    {\n      TIFFSetDirectory(tiff,directory);\n      return;\n    }\n  sans=NULL;\n  for (i=0; exif_info[i].tag != 0; i++)\n  {\n    *value='\\0';\n    switch (exif_info[i].type)\n    {\n      case TIFF_ASCII:\n      {\n        char\n          *ascii;\n\n        ascii=(char *) NULL;\n        if ((TIFFGetField(tiff,exif_info[i].tag,&ascii,&sans,&sans) == 1) &&\n            (ascii != (char *) NULL) && (*ascii != '\\0'))\n          (void) CopyMagickString(value,ascii,MagickPathExtent);\n        break;\n      }\n      case TIFF_SHORT:\n      {\n        if (exif_info[i].variable_length == 0)\n          {\n            uint16\n              shorty;\n\n            shorty=0;\n            if (TIFFGetField(tiff,exif_info[i].tag,&shorty,&sans,&sans) == 1)\n              (void) FormatLocaleString(value,MagickPathExtent,\"%d\",shorty);\n          }\n        else\n          {\n            int\n              tiff_status;\n\n            uint16\n              *shorty;\n\n            uint16\n              shorty_num;\n\n            tiff_status=TIFFGetField(tiff,exif_info[i].tag,&shorty_num,&shorty,\n              &sans,&sans);\n            if (tiff_status == 1)\n              (void) FormatLocaleString(value,MagickPathExtent,\"%d\",\n                shorty_num != 0 ? shorty[0] : 0);\n          }\n        break;\n      }\n      case TIFF_LONG:\n      {\n        uint32\n          longy;\n\n        longy=0;\n        if (TIFFGetField(tiff,exif_info[i].tag,&longy,&sans,&sans) == 1)\n          (void) FormatLocaleString(value,MagickPathExtent,\"%d\",longy);\n        break;\n      }\n#if defined(TIFF_VERSION_BIG)\n      case TIFF_LONG8:\n      {\n        uint64\n          long8y;\n\n        long8y=0;\n        if (TIFFGetField(tiff,exif_info[i].tag,&long8y,&sans,&sans) == 1)\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n            ((MagickOffsetType) long8y));\n        break;\n      }\n#endif\n      case TIFF_RATIONAL:\n      case TIFF_SRATIONAL:\n      case TIFF_FLOAT:\n      {\n        float\n          floaty;\n\n        floaty=0.0;\n        if (TIFFGetField(tiff,exif_info[i].tag,&floaty,&sans,&sans) == 1)\n          (void) FormatLocaleString(value,MagickPathExtent,\"%g\",(double)\n            floaty);\n        break;\n      }\n      case TIFF_DOUBLE:\n      {\n        double\n          doubley;\n\n        doubley=0.0;\n        if (TIFFGetField(tiff,exif_info[i].tag,&doubley,&sans,&sans) == 1)\n          (void) FormatLocaleString(value,MagickPathExtent,\"%g\",doubley);\n        break;\n      }\n      default:\n        break;\n    }\n    if (*value != '\\0')\n      (void) SetImageProperty(image,exif_info[i].property,value,exception);\n  }\n  TIFFSetDirectory(tiff,directory);\n#else\n  (void) tiff;\n  (void) image;\n#endif\n}\n\nstatic int TIFFMapBlob(thandle_t image,tdata_t *base,toff_t *size)\n{\n  *base=(tdata_t *) GetBlobStreamData((Image *) image);\n  if (*base != (tdata_t *) NULL)\n    *size=(toff_t) GetBlobSize((Image *) image);\n  if (*base != (tdata_t *) NULL)\n    return(1);\n  return(0);\n}\n\nstatic tsize_t TIFFReadBlob(thandle_t image,tdata_t data,tsize_t size)\n{\n  tsize_t\n    count;\n\n  count=(tsize_t) ReadBlob((Image *) image,(size_t) size,\n    (unsigned char *) data);\n  return(count);\n}\n\nstatic int32 TIFFReadPixels(TIFF *tiff,size_t bits_per_sample,\n  tsample_t sample,ssize_t row,tdata_t scanline)\n{\n  int32\n    status;\n\n  (void) bits_per_sample;\n  status=TIFFReadScanline(tiff,scanline,(uint32) row,sample);\n  return(status);\n}\n\nstatic toff_t TIFFSeekBlob(thandle_t image,toff_t offset,int whence)\n{\n  return((toff_t) SeekBlob((Image *) image,(MagickOffsetType) offset,whence));\n}\n\nstatic void TIFFUnmapBlob(thandle_t image,tdata_t base,toff_t size)\n{\n  (void) image;\n  (void) base;\n  (void) size;\n}\n\nstatic void TIFFWarnings(const char *module,const char *format,va_list warning)\n{\n  char\n    message[MagickPathExtent];\n\n  ExceptionInfo\n    *exception;\n\n#if defined(MAGICKCORE_HAVE_VSNPRINTF)\n  (void) vsnprintf(message,MagickPathExtent,format,warning);\n#else\n  (void) vsprintf(message,format,warning);\n#endif\n  (void) ConcatenateMagickString(message,\".\",MagickPathExtent);\n  exception=(ExceptionInfo *) GetMagickThreadValue(tiff_exception);\n  if (exception != (ExceptionInfo *) NULL)\n    (void) ThrowMagickException(exception,GetMagickModule(),CoderWarning,\n      message,\"`%s'\",module);\n}\n\nstatic tsize_t TIFFWriteBlob(thandle_t image,tdata_t data,tsize_t size)\n{\n  tsize_t\n    count;\n\n  count=(tsize_t) WriteBlob((Image *) image,(size_t) size,\n    (unsigned char *) data);\n  return(count);\n}\n\nstatic TIFFMethodType GetJPEGMethod(Image* image,TIFF *tiff,uint16 photometric,\n  uint16 bits_per_sample,uint16 samples_per_pixel)\n{\n#define BUFFER_SIZE 2048\n\n  MagickOffsetType\n    position,\n    offset;\n\n  register size_t\n    i;\n\n  TIFFMethodType\n    method;\n\n#if defined(TIFF_VERSION_BIG)\n  uint64\n#else\n  uint32\n#endif\n    **value;\n\n  unsigned char\n    buffer[BUFFER_SIZE+32];\n\n  unsigned short\n    length;\n\n  /* only support 8 bit for now */\n  if ((photometric != PHOTOMETRIC_SEPARATED) || (bits_per_sample != 8) ||\n      (samples_per_pixel != 4))\n    return(ReadGenericMethod);\n  /* Search for Adobe APP14 JPEG Marker */\n  if (!TIFFGetField(tiff,TIFFTAG_STRIPOFFSETS,&value))\n    return(ReadRGBAMethod);\n  position=TellBlob(image);\n  offset=(MagickOffsetType) (value[0]);\n  if (SeekBlob(image,offset,SEEK_SET) != offset)\n    return(ReadRGBAMethod);\n  method=ReadRGBAMethod;\n  if (ReadBlob(image,BUFFER_SIZE,buffer) == BUFFER_SIZE)\n    {\n      for (i=0; i < BUFFER_SIZE; i++)\n      {\n        while (i < BUFFER_SIZE)\n        {\n          if (buffer[i++] == 255)\n           break;\n        }\n        while (i < BUFFER_SIZE)\n        {\n          if (buffer[++i] != 255)\n           break;\n        }\n        if (buffer[i++] == 216) /* JPEG_MARKER_SOI */\n          continue;\n        length=(unsigned short) (((unsigned int) (buffer[i] << 8) |\n          (unsigned int) buffer[i+1]) & 0xffff);\n        if (i+(size_t) length >= BUFFER_SIZE)\n          break;\n        if (buffer[i-1] == 238) /* JPEG_MARKER_APP0+14 */\n          {\n            if (length != 14)\n              break;\n            /* 0 == CMYK, 1 == YCbCr, 2 = YCCK */\n            if (buffer[i+13] == 2)\n              method=ReadYCCKMethod;\n            break;\n          }\n        i+=(size_t) length;\n      }\n    }\n  (void) SeekBlob(image,position,SEEK_SET);\n  return(method);\n}\n\nstatic void TIFFReadPhotoshopLayers(Image* image,const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  const char\n    *option;\n\n  const StringInfo\n    *layer_info;\n\n  Image\n    *layers;\n\n  PSDInfo\n    info;\n\n  register ssize_t\n    i;\n\n  if (GetImageListLength(image) != 1)\n    return;\n  if ((image_info->number_scenes == 1) && (image_info->scene == 0))\n    return;\n  option=GetImageOption(image_info,\"tiff:ignore-layers\");\n  if (option != (const char * ) NULL)\n    return;\n  layer_info=GetImageProfile(image,\"tiff:37724\");\n  if (layer_info == (const StringInfo *) NULL)\n    return;\n  for (i=0; i < (ssize_t) layer_info->length-8; i++)\n  {\n    if (LocaleNCompare((const char *) (layer_info->datum+i),\n        image->endian == MSBEndian ? \"8BIM\" : \"MIB8\",4) != 0)\n      continue;\n    i+=4;\n    if ((LocaleNCompare((const char *) (layer_info->datum+i),\n         image->endian == MSBEndian ? \"Layr\" : \"ryaL\",4) == 0) ||\n        (LocaleNCompare((const char *) (layer_info->datum+i),\n         image->endian == MSBEndian ? \"LMsk\" : \"ksML\",4) == 0) ||\n        (LocaleNCompare((const char *) (layer_info->datum+i),\n         image->endian == MSBEndian ? \"Lr16\" : \"61rL\",4) == 0) ||\n        (LocaleNCompare((const char *) (layer_info->datum+i),\n         image->endian == MSBEndian ? \"Lr32\" : \"23rL\",4) == 0))\n      break;\n  }\n  i+=4;\n  if (i >= (ssize_t) (layer_info->length-8))\n    return;\n  layers=CloneImage(image,image->columns,image->rows,MagickTrue,exception);\n  (void) DeleteImageProfile(layers,\"tiff:37724\");\n  AttachBlob(layers->blob,layer_info->datum,layer_info->length);\n  SeekBlob(layers,(MagickOffsetType) i,SEEK_SET);\n  info.version=1;\n  info.columns=layers->columns;\n  info.rows=layers->rows;\n  info.channels=(unsigned short) layers->number_channels;\n  /* Setting the mode to a value that won't change the colorspace */\n  info.mode=10;\n  ReadPSDLayers(layers,image_info,&info,MagickFalse,exception);\n  DeleteImageFromList(&layers);\n  if (layers != (Image *) NULL)\n    {\n      SetImageArtifact(image,\"tiff:has-layers\",\"true\");\n      AppendImageToList(&image,layers);\n      while (layers != (Image *) NULL)\n      {\n        SetImageArtifact(layers,\"tiff:has-layers\",\"true\");\n        DetachBlob(layers->blob);\n        layers=GetNextImageInList(layers);\n      }\n    }\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\nstatic Image *ReadTIFFImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  const char\n    *option;\n\n  float\n    *chromaticity,\n    x_position,\n    y_position,\n    x_resolution,\n    y_resolution;\n\n  Image\n    *image;\n\n  int\n    tiff_status;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  register ssize_t\n    i;\n\n  size_t\n    pad;\n\n  ssize_t\n    y;\n\n  TIFF\n    *tiff;\n\n  TIFFMethodType\n    method;\n\n  uint16\n    compress_tag,\n    bits_per_sample,\n    endian,\n    extra_samples,\n    interlace,\n    max_sample_value,\n    min_sample_value,\n    orientation,\n    pages,\n    photometric,\n    *sample_info,\n    sample_format,\n    samples_per_pixel,\n    units,\n    value;\n\n  uint32\n    height,\n    rows_per_strip,\n    width;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open image.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) SetMagickThreadValue(tiff_exception,exception);\n  tiff=TIFFClientOpen(image->filename,\"rb\",(thandle_t) image,TIFFReadBlob,\n    TIFFWriteBlob,TIFFSeekBlob,TIFFCloseBlob,TIFFGetBlobSize,TIFFMapBlob,\n    TIFFUnmapBlob);\n  if (tiff == (TIFF *) NULL)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (image_info->number_scenes != 0)\n    {\n      /*\n        Generate blank images for subimage specification (e.g. image.tif[4].\n        We need to check the number of directores because it is possible that\n        the subimage(s) are stored in the photoshop profile.\n      */\n      if (image_info->scene < (size_t) TIFFNumberOfDirectories(tiff))\n        {\n          for (i=0; i < (ssize_t) image_info->scene; i++)\n          {\n            status=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;\n            if (status == MagickFalse)\n              {\n                TIFFClose(tiff);\n                image=DestroyImageList(image);\n                return((Image *) NULL);\n              }\n            AcquireNextImage(image_info,image,exception);\n            if (GetNextImageInList(image) == (Image *) NULL)\n              {\n                TIFFClose(tiff);\n                image=DestroyImageList(image);\n                return((Image *) NULL);\n              }\n            image=SyncNextImageInList(image);\n          }\n      }\n  }\n  do\n  {\nDisableMSCWarning(4127)\n    if (0 && (image_info->verbose != MagickFalse))\n      TIFFPrintDirectory(tiff,stdout,MagickFalse);\nRestoreMSCWarning\n    if ((TIFFGetField(tiff,TIFFTAG_IMAGEWIDTH,&width) != 1) ||\n        (TIFFGetField(tiff,TIFFTAG_IMAGELENGTH,&height) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_COMPRESSION,&compress_tag) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_PLANARCONFIG,&interlace) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,&samples_per_pixel) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,&bits_per_sample) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLEFORMAT,&sample_format) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_MINSAMPLEVALUE,&min_sample_value) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_MAXSAMPLEVALUE,&max_sample_value) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_PHOTOMETRIC,&photometric) != 1))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    if (sample_format == SAMPLEFORMAT_IEEEFP)\n      (void) SetImageProperty(image,\"quantum:format\",\"floating-point\",\n        exception);\n    switch (photometric)\n    {\n      case PHOTOMETRIC_MINISBLACK:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-black\",\n          exception);\n        break;\n      }\n      case PHOTOMETRIC_MINISWHITE:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-white\",\n          exception);\n        break;\n      }\n      case PHOTOMETRIC_PALETTE:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"palette\",exception);\n        break;\n      }\n      case PHOTOMETRIC_RGB:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"RGB\",exception);\n        break;\n      }\n      case PHOTOMETRIC_CIELAB:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"CIELAB\",exception);\n        break;\n      }\n      case PHOTOMETRIC_LOGL:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"CIE Log2(L)\",\n          exception);\n        break;\n      }\n      case PHOTOMETRIC_LOGLUV:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"LOGLUV\",exception);\n        break;\n      }\n#if defined(PHOTOMETRIC_MASK)\n      case PHOTOMETRIC_MASK:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"MASK\",exception);\n        break;\n      }\n#endif\n      case PHOTOMETRIC_SEPARATED:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"separated\",exception);\n        break;\n      }\n      case PHOTOMETRIC_YCBCR:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"YCBCR\",exception);\n        break;\n      }\n      default:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"unknown\",exception);\n        break;\n      }\n    }\n    if (image->debug != MagickFalse)\n      {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Geometry: %ux%u\",\n          (unsigned int) width,(unsigned int) height);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Interlace: %u\",\n          interlace);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Bits per sample: %u\",bits_per_sample);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Min sample value: %u\",min_sample_value);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Max sample value: %u\",max_sample_value);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Photometric \"\n          \"interpretation: %s\",GetImageProperty(image,\"tiff:photometric\",\n          exception));\n      }\n    image->columns=(size_t) width;\n    image->rows=(size_t) height;\n    image->depth=(size_t) bits_per_sample;\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Image depth: %.20g\",\n        (double) image->depth);\n    image->endian=MSBEndian;\n    if (endian == FILLORDER_LSB2MSB)\n      image->endian=LSBEndian;\n#if defined(MAGICKCORE_HAVE_TIFFISBIGENDIAN)\n    if (TIFFIsBigEndian(tiff) == 0)\n      {\n        (void) SetImageProperty(image,\"tiff:endian\",\"lsb\",exception);\n        image->endian=LSBEndian;\n      }\n    else\n      {\n        (void) SetImageProperty(image,\"tiff:endian\",\"msb\",exception);\n        image->endian=MSBEndian;\n      }\n#endif\n    if ((photometric == PHOTOMETRIC_MINISBLACK) ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      SetImageColorspace(image,GRAYColorspace,exception);\n    if (photometric == PHOTOMETRIC_SEPARATED)\n      SetImageColorspace(image,CMYKColorspace,exception);\n    if (photometric == PHOTOMETRIC_CIELAB)\n      SetImageColorspace(image,LabColorspace,exception);\n    TIFFGetProfiles(tiff,image,image_info->ping,exception);\n    TIFFGetProperties(tiff,image,exception);\n    option=GetImageOption(image_info,\"tiff:exif-properties\");\n    if (IsStringFalse(option) == MagickFalse) /* enabled by default */\n      TIFFGetEXIFProperties(tiff,image,exception);\n    (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,\n      &samples_per_pixel);\n    if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XRESOLUTION,&x_resolution) == 1) &&\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_YRESOLUTION,&y_resolution) == 1))\n      {\n        image->resolution.x=x_resolution;\n        image->resolution.y=y_resolution;\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_RESOLUTIONUNIT,&units) == 1)\n      {\n        if (units == RESUNIT_INCH)\n          image->units=PixelsPerInchResolution;\n        if (units == RESUNIT_CENTIMETER)\n          image->units=PixelsPerCentimeterResolution;\n      }\n    if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XPOSITION,&x_position) == 1) &&\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_YPOSITION,&y_position) == 1))\n      {\n        image->page.x=(ssize_t) ceil(x_position*image->resolution.x-0.5);\n        image->page.y=(ssize_t) ceil(y_position*image->resolution.y-0.5);\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_ORIENTATION,&orientation) == 1)\n      image->orientation=(OrientationType) orientation;\n    if (TIFFGetField(tiff,TIFFTAG_WHITEPOINT,&chromaticity) == 1)\n      {\n        if (chromaticity != (float *) NULL)\n          {\n            image->chromaticity.white_point.x=chromaticity[0];\n            image->chromaticity.white_point.y=chromaticity[1];\n          }\n      }\n    if (TIFFGetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,&chromaticity) == 1)\n      {\n        if (chromaticity != (float *) NULL)\n          {\n            image->chromaticity.red_primary.x=chromaticity[0];\n            image->chromaticity.red_primary.y=chromaticity[1];\n            image->chromaticity.green_primary.x=chromaticity[2];\n            image->chromaticity.green_primary.y=chromaticity[3];\n            image->chromaticity.blue_primary.x=chromaticity[4];\n            image->chromaticity.blue_primary.y=chromaticity[5];\n          }\n      }\n#if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION > 20040919)\n    if ((compress_tag != COMPRESSION_NONE) &&\n        (TIFFIsCODECConfigured(compress_tag) == 0))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CoderError,\"CompressNotSupported\");\n      }\n#endif\n    switch (compress_tag)\n    {\n      case COMPRESSION_NONE: image->compression=NoCompression; break;\n      case COMPRESSION_CCITTFAX3: image->compression=FaxCompression; break;\n      case COMPRESSION_CCITTFAX4: image->compression=Group4Compression; break;\n      case COMPRESSION_JPEG:\n      {\n         image->compression=JPEGCompression;\n#if defined(JPEG_SUPPORT)\n         {\n           char\n             sampling_factor[MagickPathExtent];\n\n           int\n             tiff_status;\n\n           uint16\n             horizontal,\n             vertical;\n\n           tiff_status=TIFFGetFieldDefaulted(tiff,TIFFTAG_YCBCRSUBSAMPLING,\n             &horizontal,&vertical);\n           if (tiff_status == 1)\n             {\n               (void) FormatLocaleString(sampling_factor,MagickPathExtent,\n                 \"%dx%d\",horizontal,vertical);\n               (void) SetImageProperty(image,\"jpeg:sampling-factor\",\n                 sampling_factor,exception);\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"Sampling Factors: %s\",sampling_factor);\n             }\n         }\n#endif\n        break;\n      }\n      case COMPRESSION_OJPEG: image->compression=JPEGCompression; break;\n#if defined(COMPRESSION_LZMA)\n      case COMPRESSION_LZMA: image->compression=LZMACompression; break;\n#endif\n      case COMPRESSION_LZW: image->compression=LZWCompression; break;\n      case COMPRESSION_DEFLATE: image->compression=ZipCompression; break;\n      case COMPRESSION_ADOBE_DEFLATE: image->compression=ZipCompression; break;\n      default: image->compression=RLECompression; break;\n    }\n    /*\n      Allocate memory for the image and pixel buffer.\n    */\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    if (sample_format == SAMPLEFORMAT_UINT)\n      status=SetQuantumFormat(image,quantum_info,UnsignedQuantumFormat);\n    if (sample_format == SAMPLEFORMAT_INT)\n      status=SetQuantumFormat(image,quantum_info,SignedQuantumFormat);\n    if (sample_format == SAMPLEFORMAT_IEEEFP)\n      status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    status=MagickTrue;\n    switch (photometric)\n    {\n      case PHOTOMETRIC_MINISBLACK:\n      {\n        quantum_info->min_is_white=MagickFalse;\n        break;\n      }\n      case PHOTOMETRIC_MINISWHITE:\n      {\n        quantum_info->min_is_white=MagickTrue;\n        break;\n      }\n      default:\n        break;\n    }\n    tiff_status=TIFFGetFieldDefaulted(tiff,TIFFTAG_EXTRASAMPLES,&extra_samples,\n      &sample_info);\n    if (tiff_status == 1)\n      {\n        (void) SetImageProperty(image,\"tiff:alpha\",\"unspecified\",exception);\n        if (extra_samples == 0)\n          {\n            if ((samples_per_pixel == 4) && (photometric == PHOTOMETRIC_RGB))\n              image->alpha_trait=BlendPixelTrait;\n          }\n        else\n          for (i=0; i < extra_samples; i++)\n          {\n            image->alpha_trait=BlendPixelTrait;\n            if (sample_info[i] == EXTRASAMPLE_ASSOCALPHA)\n              {\n                SetQuantumAlphaType(quantum_info,DisassociatedQuantumAlpha);\n                (void) SetImageProperty(image,\"tiff:alpha\",\"associated\",\n                  exception);\n              }\n            else\n              if (sample_info[i] == EXTRASAMPLE_UNASSALPHA)\n                (void) SetImageProperty(image,\"tiff:alpha\",\"unassociated\",\n                  exception);\n          }\n      }\n    if ((photometric == PHOTOMETRIC_PALETTE) &&\n        (pow(2.0,1.0*bits_per_sample) <= MaxColormapSize))\n      {\n        size_t\n          colors;\n\n        colors=(size_t) GetQuantumRange(bits_per_sample)+1;\n        if (AcquireImageColormap(image,colors,exception) == MagickFalse)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n      }\n    value=(unsigned short) image->scene;\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_PAGENUMBER,&value,&pages) == 1)\n      image->scene=value;\n    if (image->storage_class == PseudoClass)\n      {\n        int\n          tiff_status;\n\n        size_t\n          range;\n\n        uint16\n          *blue_colormap,\n          *green_colormap,\n          *red_colormap;\n\n        /*\n          Initialize colormap.\n        */\n        tiff_status=TIFFGetField(tiff,TIFFTAG_COLORMAP,&red_colormap,\n          &green_colormap,&blue_colormap);\n        if (tiff_status == 1)\n          {\n            if ((red_colormap != (uint16 *) NULL) &&\n                (green_colormap != (uint16 *) NULL) &&\n                (blue_colormap != (uint16 *) NULL))\n              {\n                range=255;  /* might be old style 8-bit colormap */\n                for (i=0; i < (ssize_t) image->colors; i++)\n                  if ((red_colormap[i] >= 256) || (green_colormap[i] >= 256) ||\n                      (blue_colormap[i] >= 256))\n                    {\n                      range=65535;\n                      break;\n                    }\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  image->colormap[i].red=ClampToQuantum(((double)\n                    QuantumRange*red_colormap[i])/range);\n                  image->colormap[i].green=ClampToQuantum(((double)\n                    QuantumRange*green_colormap[i])/range);\n                  image->colormap[i].blue=ClampToQuantum(((double)\n                    QuantumRange*blue_colormap[i])/range);\n                }\n              }\n          }\n        if (image->alpha_trait == UndefinedPixelTrait)\n          image->depth=GetImageDepth(image,exception);\n      }\n    if (image_info->ping != MagickFalse)\n      {\n        if (image_info->number_scenes != 0)\n          if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n            {\n              quantum_info=DestroyQuantumInfo(quantum_info);\n              break;\n            }\n        goto next_tiff_frame;\n      }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    method=ReadGenericMethod;\n    if (TIFFGetField(tiff,TIFFTAG_ROWSPERSTRIP,&rows_per_strip) == 1)\n      {\n        char\n          value[MagickPathExtent];\n\n        method=ReadStripMethod;\n        (void) FormatLocaleString(value,MagickPathExtent,\"%u\",\n          (unsigned int) rows_per_strip);\n        (void) SetImageProperty(image,\"tiff:rows-per-strip\",value,exception);\n      }\n    if ((samples_per_pixel >= 2) && (interlace == PLANARCONFIG_CONTIG))\n      method=ReadRGBAMethod;\n    if ((samples_per_pixel >= 2) && (interlace == PLANARCONFIG_SEPARATE))\n      method=ReadCMYKAMethod;\n    if ((photometric != PHOTOMETRIC_RGB) &&\n        (photometric != PHOTOMETRIC_CIELAB) &&\n        (photometric != PHOTOMETRIC_SEPARATED))\n      method=ReadGenericMethod;\n    if (image->storage_class == PseudoClass)\n      method=ReadSingleSampleMethod;\n    if ((photometric == PHOTOMETRIC_MINISBLACK) ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      method=ReadSingleSampleMethod;\n    if ((photometric != PHOTOMETRIC_SEPARATED) &&\n        (interlace == PLANARCONFIG_SEPARATE) && (bits_per_sample < 64))\n      method=ReadGenericMethod;\n    if (image->compression == JPEGCompression)\n      method=GetJPEGMethod(image,tiff,photometric,bits_per_sample,\n        samples_per_pixel);\n    if (compress_tag == COMPRESSION_JBIG)\n      method=ReadStripMethod;\n    if (TIFFIsTiled(tiff) != MagickFalse)\n      method=ReadTileMethod;\n    quantum_info->endian=LSBEndian;\n    quantum_type=RGBQuantum;\n    pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n    switch (method)\n    {\n      case ReadSingleSampleMethod:\n      {\n        /*\n          Convert TIFF image to PseudoClass MIFF image.\n        */\n        quantum_type=IndexQuantum;\n        pad=(size_t) MagickMax((size_t) samples_per_pixel-1,0);\n        if (image->alpha_trait != UndefinedPixelTrait)\n          {\n            if (image->storage_class != PseudoClass)\n              {\n                quantum_type=samples_per_pixel == 1 ? AlphaQuantum :\n                  GrayAlphaQuantum;\n                pad=(size_t) MagickMax((size_t) samples_per_pixel-2,0);\n              }\n            else\n              {\n                quantum_type=IndexAlphaQuantum;\n                pad=(size_t) MagickMax((size_t) samples_per_pixel-2,0);\n              }\n          }\n        else\n          if (image->storage_class != PseudoClass)\n            {\n              quantum_type=GrayQuantum;\n              pad=(size_t) MagickMax((size_t) samples_per_pixel-1,0);\n            }\n        status=SetQuantumPad(image,quantum_info,pad*pow(2,ceil(log(\n          bits_per_sample)/log(2))));\n        if (status == MagickFalse)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          int\n            status;\n\n          register Quantum\n            *magick_restrict q;\n\n          status=TIFFReadPixels(tiff,bits_per_sample,0,y,(char *) pixels);\n          if (status == -1)\n            break;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case ReadRGBAMethod:\n      {\n        /*\n          Convert TIFF image to DirectClass MIFF image.\n        */\n        pad=(size_t) MagickMax((size_t) samples_per_pixel-3,0);\n        quantum_type=RGBQuantum;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          {\n            quantum_type=RGBAQuantum;\n            pad=(size_t) MagickMax((size_t) samples_per_pixel-4,0);\n          }\n        if (image->colorspace == CMYKColorspace)\n          {\n            pad=(size_t) MagickMax((size_t) samples_per_pixel-4,0);\n            quantum_type=CMYKQuantum;\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                quantum_type=CMYKAQuantum;\n                pad=(size_t) MagickMax((size_t) samples_per_pixel-5,0);\n              }\n          }\n        status=SetQuantumPad(image,quantum_info,pad*((bits_per_sample+7) >> 3));\n        if (status == MagickFalse)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          int\n            status;\n\n          register Quantum\n            *magick_restrict q;\n\n          status=TIFFReadPixels(tiff,bits_per_sample,0,y,(char *) pixels);\n          if (status == -1)\n            break;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case ReadCMYKAMethod:\n      {\n        /*\n          Convert TIFF image to DirectClass MIFF image.\n        */\n        for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            register Quantum\n              *magick_restrict q;\n\n            int\n              status;\n\n            status=TIFFReadPixels(tiff,bits_per_sample,(tsample_t) i,y,(char *)\n              pixels);\n            if (status == -1)\n              break;\n            q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            if (image->colorspace != CMYKColorspace)\n              switch (i)\n              {\n                case 0: quantum_type=RedQuantum; break;\n                case 1: quantum_type=GreenQuantum; break;\n                case 2: quantum_type=BlueQuantum; break;\n                case 3: quantum_type=AlphaQuantum; break;\n                default: quantum_type=UndefinedQuantum; break;\n              }\n            else\n              switch (i)\n              {\n                case 0: quantum_type=CyanQuantum; break;\n                case 1: quantum_type=MagentaQuantum; break;\n                case 2: quantum_type=YellowQuantum; break;\n                case 3: quantum_type=BlackQuantum; break;\n                case 4: quantum_type=AlphaQuantum; break;\n                default: quantum_type=UndefinedQuantum; break;\n              }\n            (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n              quantum_type,pixels,exception);\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n          }\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case ReadYCCKMethod:\n      {\n        pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          int\n            status;\n\n          register Quantum\n            *magick_restrict q;\n\n          register ssize_t\n            x;\n\n          unsigned char\n            *p;\n\n          status=TIFFReadPixels(tiff,bits_per_sample,0,y,(char *) pixels);\n          if (status == -1)\n            break;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          p=pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelCyan(image,ScaleCharToQuantum(ClampYCC((double) *p+\n              (1.402*(double) *(p+2))-179.456)),q);\n            SetPixelMagenta(image,ScaleCharToQuantum(ClampYCC((double) *p-\n              (0.34414*(double) *(p+1))-(0.71414*(double ) *(p+2))+\n              135.45984)),q);\n            SetPixelYellow(image,ScaleCharToQuantum(ClampYCC((double) *p+\n              (1.772*(double) *(p+1))-226.816)),q);\n            SetPixelBlack(image,ScaleCharToQuantum((unsigned char) *(p+3)),q);\n            q+=GetPixelChannels(image);\n            p+=4;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case ReadStripMethod:\n      {\n        register uint32\n          *p;\n\n        /*\n          Convert stripped TIFF image to DirectClass MIFF image.\n        */\n        i=0;\n        p=(uint32 *) NULL;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register ssize_t\n            x;\n\n          register Quantum\n            *magick_restrict q;\n\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          if (i == 0)\n            {\n              if (TIFFReadRGBAStrip(tiff,(tstrip_t) y,(uint32 *) pixels) == 0)\n                break;\n              i=(ssize_t) MagickMin((ssize_t) rows_per_strip,(ssize_t)\n                image->rows-y);\n            }\n          i--;\n          p=((uint32 *) pixels)+image->columns*i;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n              (TIFFGetR(*p))),q);\n            SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n              (TIFFGetG(*p))),q);\n            SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n              (TIFFGetB(*p))),q);\n            if (image->alpha_trait != UndefinedPixelTrait)\n              SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)\n                (TIFFGetA(*p))),q);\n            p++;\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case ReadTileMethod:\n      {\n        register uint32\n          *p;\n\n        uint32\n          *tile_pixels,\n          columns,\n          rows;\n\n        /*\n          Convert tiled TIFF image to DirectClass MIFF image.\n        */\n        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||\n            (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(CoderError,\"ImageIsNotTiled\");\n          }\n        (void) SetImageStorageClass(image,DirectClass,exception);\n        number_pixels=(MagickSizeType) columns*rows;\n        if (HeapOverflowSanityCheck(rows,sizeof(*tile_pixels)) != MagickFalse)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        tile_pixels=(uint32 *) AcquireQuantumMemory(columns,rows*\n          sizeof(*tile_pixels));\n        if (tile_pixels == (uint32 *) NULL)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        for (y=0; y < (ssize_t) image->rows; y+=rows)\n        {\n          register ssize_t\n            x;\n\n          register Quantum\n            *magick_restrict q,\n            *magick_restrict tile;\n\n          size_t\n            columns_remaining,\n            rows_remaining;\n\n          rows_remaining=image->rows-y;\n          if ((ssize_t) (y+rows) < (ssize_t) image->rows)\n            rows_remaining=rows;\n          tile=QueueAuthenticPixels(image,0,y,image->columns,rows_remaining,\n            exception);\n          if (tile == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x+=columns)\n          {\n            size_t\n              column,\n              row;\n\n            if (TIFFReadRGBATile(tiff,(uint32) x,(uint32) y,tile_pixels) == 0)\n              break;\n            columns_remaining=image->columns-x;\n            if ((ssize_t) (x+columns) < (ssize_t) image->columns)\n              columns_remaining=columns;\n            p=tile_pixels+(rows-rows_remaining)*columns;\n            q=tile+GetPixelChannels(image)*(image->columns*(rows_remaining-1)+\n              x);\n            for (row=rows_remaining; row > 0; row--)\n            {\n              if (image->alpha_trait != UndefinedPixelTrait)\n                for (column=columns_remaining; column > 0; column--)\n                {\n                  SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n                    TIFFGetR(*p)),q);\n                  SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n                    TIFFGetG(*p)),q);\n                  SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n                    TIFFGetB(*p)),q);\n                  SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)\n                    TIFFGetA(*p)),q);\n                  p++;\n                  q+=GetPixelChannels(image);\n                }\n              else\n                for (column=columns_remaining; column > 0; column--)\n                {\n                  SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n                    TIFFGetR(*p)),q);\n                  SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n                    TIFFGetG(*p)),q);\n                  SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n                    TIFFGetB(*p)),q);\n                  p++;\n                  q+=GetPixelChannels(image);\n                }\n              p+=columns-columns_remaining;\n              q-=GetPixelChannels(image)*(image->columns+columns_remaining);\n            }\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        tile_pixels=(uint32 *) RelinquishMagickMemory(tile_pixels);\n        break;\n      }\n      case ReadGenericMethod:\n      default:\n      {\n        MemoryInfo\n          *pixel_info;\n\n        register uint32\n          *p;\n\n        uint32\n          *pixels;\n\n        /*\n          Convert TIFF image to DirectClass MIFF image.\n        */\n        number_pixels=(MagickSizeType) image->columns*image->rows;\n        if (HeapOverflowSanityCheck(image->rows,sizeof(*pixels)) != MagickFalse)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        pixel_info=AcquireVirtualMemory(image->columns,image->rows*\n          sizeof(uint32));\n        if (pixel_info == (MemoryInfo *) NULL)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        pixels=(uint32 *) GetVirtualMemoryBlob(pixel_info);\n        (void) TIFFReadRGBAImage(tiff,(uint32) image->columns,(uint32)\n          image->rows,(uint32 *) pixels,0);\n        /*\n          Convert image to DirectClass pixel packets.\n        */\n        p=pixels+number_pixels-1;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register ssize_t\n            x;\n\n          register Quantum\n            *magick_restrict q;\n\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          q+=GetPixelChannels(image)*(image->columns-1);\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n              TIFFGetR(*p)),q);\n            SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n              TIFFGetG(*p)),q);\n            SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n              TIFFGetB(*p)),q);\n            if (image->alpha_trait != UndefinedPixelTrait)\n              SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)\n                TIFFGetA(*p)),q);\n            p--;\n            q-=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        pixel_info=RelinquishVirtualMemory(pixel_info);\n        break;\n      }\n    }\n    SetQuantumImageType(image,quantum_type);\n  next_tiff_frame:\n    quantum_info=DestroyQuantumInfo(quantum_info);\n    if (photometric == PHOTOMETRIC_CIELAB)\n      DecodeLabImage(image,exception);\n    if ((photometric == PHOTOMETRIC_LOGL) ||\n        (photometric == PHOTOMETRIC_MINISBLACK) ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      {\n        image->type=GrayscaleType;\n        if (bits_per_sample == 1)\n          image->type=BilevelType;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;\n    if (status != MagickFalse)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,image->scene-1,\n          image->scene);\n        if (status == MagickFalse)\n          break;\n      }\n  } while (status != MagickFalse);\n  TIFFClose(tiff);\n  TIFFReadPhotoshopLayers(image,image_info,exception);\n  if (image_info->number_scenes != 0)\n    {\n      if (image_info->scene >= GetImageListLength(image))\n        {\n          /* Subimage was not found in the Photoshop layer */\n          image=DestroyImageList(image);\n          return((Image *)NULL);\n        }\n    }\n  return(GetFirstImageInList(image));\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r T I F F I m a g e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterTIFFImage() adds properties for the TIFF image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterTIFFImage method is:\n%\n%      size_t RegisterTIFFImage(void)\n%\n*/\n\n#if defined(MAGICKCORE_HAVE_TIFFMERGEFIELDINFO) && defined(MAGICKCORE_HAVE_TIFFSETTAGEXTENDER)\nstatic TIFFExtendProc\n  tag_extender = (TIFFExtendProc) NULL;\n\nstatic void TIFFIgnoreTags(TIFF *tiff)\n{\n  char\n    *q;\n\n  const char\n    *p,\n    *tags;\n\n  Image\n   *image;\n\n  register ssize_t\n    i;\n\n  size_t\n    count;\n\n  TIFFFieldInfo\n    *ignore;\n\n  if (TIFFGetReadProc(tiff) != TIFFReadBlob)\n    return;\n  image=(Image *)TIFFClientdata(tiff);\n  tags=GetImageArtifact(image,\"tiff:ignore-tags\");\n  if (tags == (const char *) NULL)\n    return;\n  count=0;\n  p=tags;\n  while (*p != '\\0')\n  {\n    while ((isspace((int) ((unsigned char) *p)) != 0))\n      p++;\n\n    (void) strtol(p,&q,10);\n    if (p == q)\n      return;\n\n    p=q;\n    count++;\n\n    while ((isspace((int) ((unsigned char) *p)) != 0) || (*p == ','))\n      p++;\n  }\n  if (count == 0)\n    return;\n  i=0;\n  p=tags;\n  ignore=(TIFFFieldInfo *) AcquireQuantumMemory(count,sizeof(*ignore));\n  /* This also sets field_bit to 0 (FIELD_IGNORE) */\n  ResetMagickMemory(ignore,0,count*sizeof(*ignore));\n  while (*p != '\\0')\n  {\n    while ((isspace((int) ((unsigned char) *p)) != 0))\n      p++;\n\n    ignore[i].field_tag=(ttag_t) strtol(p,&q,10);\n\n    p=q;\n    i++;\n\n    while ((isspace((int) ((unsigned char) *p)) != 0) || (*p == ','))\n      p++;\n  }\n  (void) TIFFMergeFieldInfo(tiff,ignore,(uint32) count);\n  ignore=(TIFFFieldInfo *) RelinquishMagickMemory(ignore);\n}\n\nstatic void TIFFTagExtender(TIFF *tiff)\n{\n  static const TIFFFieldInfo\n    TIFFExtensions[] =\n    {\n      { 37724, -3, -3, TIFF_UNDEFINED, FIELD_CUSTOM, 1, 1,\n        (char *) \"PhotoshopLayerData\" },\n      { 34118, -3, -3, TIFF_UNDEFINED, FIELD_CUSTOM, 1, 1,\n        (char *) \"Microscope\" }\n    };\n\n  TIFFMergeFieldInfo(tiff,TIFFExtensions,sizeof(TIFFExtensions)/\n    sizeof(*TIFFExtensions));\n  if (tag_extender != (TIFFExtendProc) NULL)\n    (*tag_extender)(tiff);\n  TIFFIgnoreTags(tiff);\n}\n#endif\n\nModuleExport size_t RegisterTIFFImage(void)\n{\n#define TIFFDescription  \"Tagged Image File Format\"\n\n  char\n    version[MagickPathExtent];\n\n  MagickInfo\n    *entry;\n\n  if (tiff_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&tiff_semaphore);\n  LockSemaphoreInfo(tiff_semaphore);\n  if (instantiate_key == MagickFalse)\n    {\n      if (CreateMagickThreadKey(&tiff_exception,NULL) == MagickFalse)\n        ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n      error_handler=TIFFSetErrorHandler(TIFFErrors);\n      warning_handler=TIFFSetWarningHandler(TIFFWarnings);\n#if defined(MAGICKCORE_HAVE_TIFFMERGEFIELDINFO) && defined(MAGICKCORE_HAVE_TIFFSETTAGEXTENDER)\n      if (tag_extender == (TIFFExtendProc) NULL)\n        tag_extender=TIFFSetTagExtender(TIFFTagExtender);\n#endif\n      instantiate_key=MagickTrue;\n    }\n  UnlockSemaphoreInfo(tiff_semaphore);\n  *version='\\0';\n#if defined(TIFF_VERSION)\n  (void) FormatLocaleString(version,MagickPathExtent,\"%d\",TIFF_VERSION);\n#endif\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  {\n    const char\n      *p;\n\n    register ssize_t\n      i;\n\n    p=TIFFGetVersion();\n    for (i=0; (i < (MagickPathExtent-1)) && (*p != 0) && (*p != '\\n'); i++)\n      version[i]=(*p++);\n    version[i]='\\0';\n  }\n#endif\n\n  entry=AcquireMagickInfo(\"TIFF\",\"GROUP4\",\"Raw CCITT Group4\");\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadGROUP4Image;\n  entry->encoder=(EncodeImageHandler *) WriteGROUP4Image;\n#endif\n  entry->flags|=CoderRawSupportFlag;\n  entry->flags|=CoderEndianSupportFlag;\n  entry->flags|=CoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  entry->format_type=ImplicitFormatType;\n  entry->mime_type=ConstantString(\"image/tiff\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TIFF\",\"PTIF\",\"Pyramid encoded TIFF\");\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadTIFFImage;\n  entry->encoder=(EncodeImageHandler *) WritePTIFImage;\n#endif\n  entry->flags|=CoderEndianSupportFlag;\n  entry->flags|=CoderSeekableStreamFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  entry->mime_type=ConstantString(\"image/tiff\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TIFF\",\"TIF\",TIFFDescription);\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadTIFFImage;\n  entry->encoder=(EncodeImageHandler *) WriteTIFFImage;\n#endif\n  entry->flags|=CoderEndianSupportFlag;\n  entry->flags|=CoderSeekableStreamFlag;\n  entry->flags|=CoderStealthFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/tiff\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TIFF\",\"TIFF\",TIFFDescription);\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadTIFFImage;\n  entry->encoder=(EncodeImageHandler *) WriteTIFFImage;\n#endif\n  entry->magick=(IsImageFormatHandler *) IsTIFF;\n  entry->flags|=CoderEndianSupportFlag;\n  entry->flags|=CoderSeekableStreamFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/tiff\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TIFF\",\"TIFF64\",\"Tagged Image File Format (64-bit)\");\n#if defined(TIFF_VERSION_BIG)\n  entry->decoder=(DecodeImageHandler *) ReadTIFFImage;\n  entry->encoder=(EncodeImageHandler *) WriteTIFFImage;\n#endif\n  entry->flags|=CoderEndianSupportFlag;\n  entry->flags|=CoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/tiff\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r T I F F I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterTIFFImage() removes format registrations made by the TIFF module\n%  from the list of supported formats.\n%\n%  The format of the UnregisterTIFFImage method is:\n%\n%      UnregisterTIFFImage(void)\n%\n*/\nModuleExport void UnregisterTIFFImage(void)\n{\n  (void) UnregisterMagickInfo(\"TIFF64\");\n  (void) UnregisterMagickInfo(\"TIFF\");\n  (void) UnregisterMagickInfo(\"TIF\");\n  (void) UnregisterMagickInfo(\"PTIF\");\n  if (tiff_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&tiff_semaphore);\n  LockSemaphoreInfo(tiff_semaphore);\n  if (instantiate_key != MagickFalse)\n    {\n#if defined(MAGICKCORE_HAVE_TIFFMERGEFIELDINFO) && defined(MAGICKCORE_HAVE_TIFFSETTAGEXTENDER)\n      if (tag_extender == (TIFFExtendProc) NULL)\n        (void) TIFFSetTagExtender(tag_extender);\n#endif\n      if (DeleteMagickThreadKey(tiff_exception) == MagickFalse)\n        ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n      (void) TIFFSetWarningHandler(warning_handler);\n      (void) TIFFSetErrorHandler(error_handler);\n      instantiate_key=MagickFalse;\n    }\n  UnlockSemaphoreInfo(tiff_semaphore);\n  RelinquishSemaphoreInfo(&tiff_semaphore);\n}\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e G R O U P 4 I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteGROUP4Image() writes an image in the raw CCITT Group 4 image format.\n%\n%  The format of the WriteGROUP4Image method is:\n%\n%      MagickBooleanType WriteGROUP4Image(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteGROUP4Image(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n\n  FILE\n    *file;\n\n  Image\n    *huffman_image;\n\n  ImageInfo\n    *write_info;\n\n  int\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count;\n\n  TIFF\n    *tiff;\n\n  toff_t\n    *byte_count,\n    strip_size;\n\n  unsigned char\n    *buffer;\n\n  /*\n    Write image as CCITT Group4 TIFF image to a temporary file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  huffman_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (huffman_image == (Image *) NULL)\n    {\n      (void) CloseBlob(image);\n      return(MagickFalse);\n    }\n  huffman_image->endian=MSBEndian;\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"wb\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        filename);\n      return(MagickFalse);\n    }\n  (void) FormatLocaleString(huffman_image->filename,MagickPathExtent,\"tiff:%s\",\n    filename);\n  (void) SetImageType(huffman_image,BilevelType,exception);\n  write_info=CloneImageInfo((ImageInfo *) NULL);\n  SetImageInfoFile(write_info,file);\n  (void) SetImageDepth(image,1,exception);\n  (void) SetImageType(image,BilevelType,exception);\n  write_info->compression=Group4Compression;\n  write_info->type=BilevelType;\n  (void) SetImageOption(write_info,\"quantum:polarity\",\"min-is-white\");\n  status=WriteTIFFImage(write_info,huffman_image,exception);\n  (void) fflush(file);\n  write_info=DestroyImageInfo(write_info);\n  if (status == MagickFalse)\n    {\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      return(MagickFalse);\n    }\n  tiff=TIFFOpen(filename,\"rb\");\n  if (tiff == (TIFF *) NULL)\n    {\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n        image_info->filename);\n      return(MagickFalse);\n    }\n  /*\n    Allocate raw strip buffer.\n  */\n  if (TIFFGetField(tiff,TIFFTAG_STRIPBYTECOUNTS,&byte_count) != 1)\n    {\n      TIFFClose(tiff);\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      return(MagickFalse);\n    }\n  strip_size=byte_count[0];\n  for (i=1; i < (ssize_t) TIFFNumberOfStrips(tiff); i++)\n    if (byte_count[i] > strip_size)\n      strip_size=byte_count[i];\n  buffer=(unsigned char *) AcquireQuantumMemory((size_t) strip_size,\n    sizeof(*buffer));\n  if (buffer == (unsigned char *) NULL)\n    {\n      TIFFClose(tiff);\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image_info->filename);\n    }\n  /*\n    Compress runlength encoded to 2D Huffman pixels.\n  */\n  for (i=0; i < (ssize_t) TIFFNumberOfStrips(tiff); i++)\n  {\n    count=(ssize_t) TIFFReadRawStrip(tiff,(uint32) i,buffer,strip_size);\n    if (WriteBlob(image,(size_t) count,buffer) != count)\n      status=MagickFalse;\n  }\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  TIFFClose(tiff);\n  huffman_image=DestroyImage(huffman_image);\n  (void) fclose(file);\n  (void) RelinquishUniqueFileResource(filename);\n  (void) CloseBlob(image);\n  return(status);\n}\n#endif\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e P T I F I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WritePTIFImage() writes an image in the pyrimid-encoded Tagged image file\n%  format.\n%\n%  The format of the WritePTIFImage method is:\n%\n%      MagickBooleanType WritePTIFImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WritePTIFImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  Image\n    *images,\n    *next,\n    *pyramid_image;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    status;\n\n  PointInfo\n    resolution;\n\n  size_t\n    columns,\n    rows;\n\n  /*\n    Create pyramid-encoded TIFF image.\n  */\n  images=NewImageList();\n  for (next=image; next != (Image *) NULL; next=GetNextImageInList(next))\n  {\n    Image\n      *clone_image;\n\n    clone_image=CloneImage(next,0,0,MagickFalse,exception);\n    if (clone_image == (Image *) NULL)\n      break;\n    clone_image->previous=NewImageList();\n    clone_image->next=NewImageList();\n    (void) SetImageProperty(clone_image,\"tiff:subfiletype\",\"none\",exception);\n    AppendImageToList(&images,clone_image);\n    columns=next->columns;\n    rows=next->rows;\n    resolution=next->resolution;\n    while ((columns > 64) && (rows > 64))\n    {\n      columns/=2;\n      rows/=2;\n      resolution.x/=2;\n      resolution.y/=2;\n      pyramid_image=ResizeImage(next,columns,rows,image->filter,exception);\n      if (pyramid_image == (Image *) NULL)\n        break;\n      pyramid_image->resolution=resolution;\n      (void) SetImageProperty(pyramid_image,\"tiff:subfiletype\",\"REDUCEDIMAGE\",\n        exception);\n      AppendImageToList(&images,pyramid_image);\n    }\n  }\n  images=GetFirstImageInList(images);\n  /*\n    Write pyramid-encoded TIFF image.\n  */\n  write_info=CloneImageInfo(image_info);\n  write_info->adjoin=MagickTrue;\n  (void) CopyMagickString(write_info->magick,\"TIFF\",MagickPathExtent);\n  (void) CopyMagickString(images->magick,\"TIFF\",MagickPathExtent);\n  status=WriteTIFFImage(write_info,images,exception);\n  images=DestroyImageList(images);\n  write_info=DestroyImageInfo(write_info);\n  return(status);\n}\n#endif\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%   W r i t e T I F F I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteTIFFImage() writes an image in the Tagged image file format.\n%\n%  The format of the WriteTIFFImage method is:\n%\n%      MagickBooleanType WriteTIFFImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\ntypedef struct _TIFFInfo\n{\n  RectangleInfo\n    tile_geometry;\n\n  unsigned char\n    *scanline,\n    *scanlines,\n    *pixels;\n} TIFFInfo;\n\nstatic void DestroyTIFFInfo(TIFFInfo *tiff_info)\n{\n  assert(tiff_info != (TIFFInfo *) NULL);\n  if (tiff_info->scanlines != (unsigned char *) NULL)\n    tiff_info->scanlines=(unsigned char *) RelinquishMagickMemory(\n      tiff_info->scanlines);\n  if (tiff_info->pixels != (unsigned char *) NULL)\n    tiff_info->pixels=(unsigned char *) RelinquishMagickMemory(\n      tiff_info->pixels);\n}\n\nstatic MagickBooleanType EncodeLabImage(Image *image,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        a,\n        b;\n\n      a=QuantumScale*GetPixela(image,q)-0.5;\n      if (a < 0.0)\n        a+=1.0;\n      b=QuantumScale*GetPixelb(image,q)-0.5;\n      if (b < 0.0)\n        b+=1.0;\n      SetPixela(image,QuantumRange*a,q);\n      SetPixelb(image,QuantumRange*b,q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\nstatic MagickBooleanType GetTIFFInfo(const ImageInfo *image_info,\n  TIFF *tiff,TIFFInfo *tiff_info)\n{\n  const char\n    *option;\n\n  MagickStatusType\n    flags;\n\n  uint32\n    tile_columns,\n    tile_rows;\n\n  assert(tiff_info != (TIFFInfo *) NULL);\n  (void) ResetMagickMemory(tiff_info,0,sizeof(*tiff_info));\n  option=GetImageOption(image_info,\"tiff:tile-geometry\");\n  if (option == (const char *) NULL)\n    return(MagickTrue);\n  flags=ParseAbsoluteGeometry(option,&tiff_info->tile_geometry);\n  if ((flags & HeightValue) == 0)\n    tiff_info->tile_geometry.height=tiff_info->tile_geometry.width;\n  tile_columns=(uint32) tiff_info->tile_geometry.width;\n  tile_rows=(uint32) tiff_info->tile_geometry.height;\n  TIFFDefaultTileSize(tiff,&tile_columns,&tile_rows);\n  (void) TIFFSetField(tiff,TIFFTAG_TILEWIDTH,tile_columns);\n  (void) TIFFSetField(tiff,TIFFTAG_TILELENGTH,tile_rows);\n  tiff_info->tile_geometry.width=tile_columns;\n  tiff_info->tile_geometry.height=tile_rows;\n  tiff_info->scanlines=(unsigned char *) AcquireQuantumMemory((size_t)\n    tile_rows*TIFFScanlineSize(tiff),sizeof(*tiff_info->scanlines));\n  tiff_info->pixels=(unsigned char *) AcquireQuantumMemory((size_t)\n    tile_rows*TIFFTileSize(tiff),sizeof(*tiff_info->scanlines));\n  if ((tiff_info->scanlines == (unsigned char *) NULL) ||\n      (tiff_info->pixels == (unsigned char *) NULL))\n    {\n      DestroyTIFFInfo(tiff_info);\n      return(MagickFalse);\n    }\n  return(MagickTrue);\n}\n\nstatic int32 TIFFWritePixels(TIFF *tiff,TIFFInfo *tiff_info,ssize_t row,\n  tsample_t sample,Image *image)\n{\n  int32\n    status;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p,\n    *q;\n\n  size_t\n    number_tiles,\n    tile_width;\n\n  ssize_t\n    bytes_per_pixel,\n    j,\n    k,\n    l;\n\n  if (TIFFIsTiled(tiff) == 0)\n    return(TIFFWriteScanline(tiff,tiff_info->scanline,(uint32) row,sample));\n  /*\n    Fill scanlines to tile height.\n  */\n  i=(ssize_t) (row % tiff_info->tile_geometry.height)*TIFFScanlineSize(tiff);\n  (void) CopyMagickMemory(tiff_info->scanlines+i,(char *) tiff_info->scanline,\n    (size_t) TIFFScanlineSize(tiff));\n  if (((size_t) (row % tiff_info->tile_geometry.height) !=\n      (tiff_info->tile_geometry.height-1)) &&\n      (row != (ssize_t) (image->rows-1)))\n    return(0);\n  /*\n    Write tile to TIFF image.\n  */\n  status=0;\n  bytes_per_pixel=TIFFTileSize(tiff)/(ssize_t) (\n    tiff_info->tile_geometry.height*tiff_info->tile_geometry.width);\n  number_tiles=(image->columns+tiff_info->tile_geometry.width)/\n    tiff_info->tile_geometry.width;\n  for (i=0; i < (ssize_t) number_tiles; i++)\n  {\n    tile_width=(i == (ssize_t) (number_tiles-1)) ? image->columns-(i*\n      tiff_info->tile_geometry.width) : tiff_info->tile_geometry.width;\n    for (j=0; j < (ssize_t) ((row % tiff_info->tile_geometry.height)+1); j++)\n      for (k=0; k < (ssize_t) tile_width; k++)\n      {\n        if (bytes_per_pixel == 0)\n          {\n            p=tiff_info->scanlines+(j*TIFFScanlineSize(tiff)+(i*\n              tiff_info->tile_geometry.width+k)/8);\n            q=tiff_info->pixels+(j*TIFFTileRowSize(tiff)+k/8);\n            *q++=(*p++);\n            continue;\n          }\n        p=tiff_info->scanlines+(j*TIFFScanlineSize(tiff)+(i*\n          tiff_info->tile_geometry.width+k)*bytes_per_pixel);\n        q=tiff_info->pixels+(j*TIFFTileRowSize(tiff)+k*bytes_per_pixel);\n        for (l=0; l < bytes_per_pixel; l++)\n          *q++=(*p++);\n      }\n    if ((i*tiff_info->tile_geometry.width) != image->columns)\n      status=TIFFWriteTile(tiff,tiff_info->pixels,(uint32) (i*\n        tiff_info->tile_geometry.width),(uint32) ((row/\n        tiff_info->tile_geometry.height)*tiff_info->tile_geometry.height),0,\n        sample);\n    if (status < 0)\n      break;\n  }\n  return(status);\n}\n\nstatic void TIFFSetProfiles(TIFF *tiff,Image *image)\n{\n  const char\n    *name;\n\n  const StringInfo\n    *profile;\n\n  if (image->profiles == (void *) NULL)\n    return;\n  ResetImageProfileIterator(image);\n  for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n  {\n    profile=GetImageProfile(image,name);\n    if (GetStringInfoLength(profile) == 0)\n      {\n        name=GetNextImageProfile(image);\n        continue;\n      }\n#if defined(TIFFTAG_XMLPACKET)\n    if (LocaleCompare(name,\"xmp\") == 0)\n      (void) TIFFSetField(tiff,TIFFTAG_XMLPACKET,(uint32) GetStringInfoLength(\n        profile),GetStringInfoDatum(profile));\n#endif\n#if defined(TIFFTAG_ICCPROFILE)\n    if (LocaleCompare(name,\"icc\") == 0)\n      (void) TIFFSetField(tiff,TIFFTAG_ICCPROFILE,(uint32) GetStringInfoLength(\n        profile),GetStringInfoDatum(profile));\n#endif\n    if (LocaleCompare(name,\"iptc\") == 0)\n      {\n        size_t\n          length;\n\n        StringInfo\n          *iptc_profile;\n\n        iptc_profile=CloneStringInfo(profile);\n        length=GetStringInfoLength(profile)+4-(GetStringInfoLength(profile) &\n          0x03);\n        SetStringInfoLength(iptc_profile,length);\n        if (TIFFIsByteSwapped(tiff))\n          TIFFSwabArrayOfLong((uint32 *) GetStringInfoDatum(iptc_profile),\n            (unsigned long) (length/4));\n        (void) TIFFSetField(tiff,TIFFTAG_RICHTIFFIPTC,(uint32)\n          GetStringInfoLength(iptc_profile)/4,GetStringInfoDatum(iptc_profile));\n        iptc_profile=DestroyStringInfo(iptc_profile);\n      }\n#if defined(TIFFTAG_PHOTOSHOP)\n    if (LocaleCompare(name,\"8bim\") == 0)\n      (void) TIFFSetField(tiff,TIFFTAG_PHOTOSHOP,(uint32)\n        GetStringInfoLength(profile),GetStringInfoDatum(profile));\n#endif\n    if (LocaleCompare(name,\"tiff:37724\") == 0)\n      (void) TIFFSetField(tiff,37724,(uint32) GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n    if (LocaleCompare(name,\"tiff:34118\") == 0)\n      (void) TIFFSetField(tiff,34118,(uint32) GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n    name=GetNextImageProfile(image);\n  }\n}\n\nstatic void TIFFSetProperties(TIFF *tiff,const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  const char\n    *value;\n\n  value=GetImageArtifact(image,\"tiff:document\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_DOCUMENTNAME,value);\n  value=GetImageArtifact(image,\"tiff:hostcomputer\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_HOSTCOMPUTER,value);\n  value=GetImageArtifact(image,\"tiff:artist\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_ARTIST,value);\n  value=GetImageArtifact(image,\"tiff:timestamp\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_DATETIME,value);\n  value=GetImageArtifact(image,\"tiff:make\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_MAKE,value);\n  value=GetImageArtifact(image,\"tiff:model\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_MODEL,value);\n  value=GetImageArtifact(image,\"tiff:software\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_SOFTWARE,value);\n  value=GetImageArtifact(image,\"tiff:copyright\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_COPYRIGHT,value);\n  value=GetImageArtifact(image,\"kodak-33423\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,33423,value);\n  value=GetImageArtifact(image,\"kodak-36867\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,36867,value);\n  value=GetImageProperty(image,\"label\",exception);\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_PAGENAME,value);\n  value=GetImageProperty(image,\"comment\",exception);\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_IMAGEDESCRIPTION,value);\n  value=GetImageArtifact(image,\"tiff:subfiletype\");\n  if (value != (const char *) NULL)\n    {\n      if (LocaleCompare(value,\"REDUCEDIMAGE\") == 0)\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_REDUCEDIMAGE);\n      else\n        if (LocaleCompare(value,\"PAGE\") == 0)\n          (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n        else\n          if (LocaleCompare(value,\"MASK\") == 0)\n            (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_MASK);\n    }\n  else\n    {\n      uint16\n        page,\n        pages;\n      \n      page=(uint16) image->scene;\n      pages=(uint16) GetImageListLength(image);\n      if ((image_info->adjoin != MagickFalse) && (pages > 1))\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n      (void) TIFFSetField(tiff,TIFFTAG_PAGENUMBER,page,pages);\n    }\n}\n\nstatic void TIFFSetEXIFProperties(TIFF *tiff,Image *image,\n  ExceptionInfo *exception)\n{\n#if defined(MAGICKCORE_HAVE_TIFFREADEXIFDIRECTORY)\n  const char\n    *value;\n\n  register ssize_t\n    i;\n\n  uint32\n    offset;\n\n  /*\n    Write EXIF properties.\n  */\n  offset=0;\n  (void) TIFFSetField(tiff,TIFFTAG_SUBIFD,1,&offset);\n  for (i=0; exif_info[i].tag != 0; i++)\n  {\n    value=GetImageProperty(image,exif_info[i].property,exception);\n    if (value == (const char *) NULL)\n      continue;\n    switch (exif_info[i].type)\n    {\n      case TIFF_ASCII:\n      {\n        (void) TIFFSetField(tiff,exif_info[i].tag,value);\n        break;\n      }\n      case TIFF_SHORT:\n      {\n        uint16\n          field;\n\n        field=(uint16) StringToLong(value);\n        (void) TIFFSetField(tiff,exif_info[i].tag,field);\n        break;\n      }\n      case TIFF_LONG:\n      {\n        uint16\n          field;\n\n        field=(uint16) StringToLong(value);\n        (void) TIFFSetField(tiff,exif_info[i].tag,field);\n        break;\n      }\n      case TIFF_RATIONAL:\n      case TIFF_SRATIONAL:\n      {\n        float\n          field;\n\n        field=StringToDouble(value,(char **) NULL);\n        (void) TIFFSetField(tiff,exif_info[i].tag,field);\n        break;\n      }\n      default:\n        break;\n    }\n  }\n  /* (void) TIFFSetField(tiff,TIFFTAG_EXIFIFD,offset); */\n#else\n  (void) tiff;\n  (void) image;\n#endif\n}\n\nstatic MagickBooleanType WriteTIFFImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n#if !defined(TIFFDefaultStripSize)\n#define TIFFDefaultStripSize(tiff,request)  (8192UL/TIFFScanlineSize(tiff))\n#endif\n\n  const char\n    *mode,\n    *option;\n\n  CompressionType\n    compression;\n\n  EndianType\n    endian_type;\n\n  MagickBooleanType\n    debug,\n    status;\n\n  MagickOffsetType\n    scene;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  register ssize_t\n    i;\n\n  size_t\n    length;\n\n  ssize_t\n    y;\n\n  TIFF\n    *tiff;\n\n  TIFFInfo\n    tiff_info;\n\n  uint16\n    bits_per_sample,\n    compress_tag,\n    endian,\n    photometric;\n\n  uint32\n    rows_per_strip;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open TIFF file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) SetMagickThreadValue(tiff_exception,exception);\n  endian_type=UndefinedEndian;\n  option=GetImageOption(image_info,\"tiff:endian\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleNCompare(option,\"msb\",3) == 0)\n        endian_type=MSBEndian;\n      if (LocaleNCompare(option,\"lsb\",3) == 0)\n        endian_type=LSBEndian;;\n    }\n  switch (endian_type)\n  {\n    case LSBEndian: mode=\"wl\"; break;\n    case MSBEndian: mode=\"wb\"; break;\n    default: mode=\"w\"; break;\n  }\n#if defined(TIFF_VERSION_BIG)\n  if (LocaleCompare(image_info->magick,\"TIFF64\") == 0)\n    switch (endian_type)\n    {\n      case LSBEndian: mode=\"wl8\"; break;\n      case MSBEndian: mode=\"wb8\"; break;\n      default: mode=\"w8\"; break;\n    }\n#endif\n  tiff=TIFFClientOpen(image->filename,mode,(thandle_t) image,TIFFReadBlob,\n    TIFFWriteBlob,TIFFSeekBlob,TIFFCloseBlob,TIFFGetBlobSize,TIFFMapBlob,\n    TIFFUnmapBlob);\n  if (tiff == (TIFF *) NULL)\n    return(MagickFalse);\n  scene=0;\n  debug=IsEventLogging();\n  (void) debug;\n  do\n  {\n    /*\n      Initialize TIFF fields.\n    */\n    if ((image_info->type != UndefinedType) &&\n        (image_info->type != OptimizeType))\n      (void) SetImageType(image,image_info->type,exception);\n    compression=UndefinedCompression;\n    if (image->compression != JPEGCompression)\n      compression=image->compression;\n    if (image_info->compression != UndefinedCompression)\n      compression=image_info->compression;\n    switch (compression)\n    {\n      case FaxCompression:\n      case Group4Compression:\n      {\n        (void) SetImageType(image,BilevelType,exception);\n        (void) SetImageDepth(image,1,exception);\n        break;\n      }\n      case JPEGCompression:\n      {\n        (void) SetImageStorageClass(image,DirectClass,exception);\n        (void) SetImageDepth(image,8,exception);\n        break;\n      }\n      default:\n        break;\n    }\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if ((image->storage_class != PseudoClass) && (image->depth >= 32) &&\n        (quantum_info->format == UndefinedQuantumFormat) &&\n        (IsHighDynamicRangeImage(image,exception) != MagickFalse))\n      {\n        status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n        if (status == MagickFalse)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    if ((LocaleCompare(image_info->magick,\"PTIF\") == 0) &&\n        (GetPreviousImageInList(image) != (Image *) NULL))\n      (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_REDUCEDIMAGE);\n    if ((image->columns != (uint32) image->columns) ||\n        (image->rows != (uint32) image->rows))\n      ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n    (void) TIFFSetField(tiff,TIFFTAG_IMAGELENGTH,(uint32) image->rows);\n    (void) TIFFSetField(tiff,TIFFTAG_IMAGEWIDTH,(uint32) image->columns);\n    switch (compression)\n    {\n      case FaxCompression:\n      {\n        compress_tag=COMPRESSION_CCITTFAX3;\n        SetQuantumMinIsWhite(quantum_info,MagickTrue);\n        break;\n      }\n      case Group4Compression:\n      {\n        compress_tag=COMPRESSION_CCITTFAX4;\n        SetQuantumMinIsWhite(quantum_info,MagickTrue);\n        break;\n      }\n#if defined(COMPRESSION_JBIG)\n      case JBIG1Compression:\n      {\n        compress_tag=COMPRESSION_JBIG;\n        break;\n      }\n#endif\n      case JPEGCompression:\n      {\n        compress_tag=COMPRESSION_JPEG;\n        break;\n      }\n#if defined(COMPRESSION_LZMA)\n      case LZMACompression:\n      {\n        compress_tag=COMPRESSION_LZMA;\n        break;\n      }\n#endif\n      case LZWCompression:\n      {\n        compress_tag=COMPRESSION_LZW;\n        break;\n      }\n      case RLECompression:\n      {\n        compress_tag=COMPRESSION_PACKBITS;\n        break;\n      }\n      case ZipCompression:\n      {\n        compress_tag=COMPRESSION_ADOBE_DEFLATE;\n        break;\n      }\n      case NoCompression:\n      default:\n      {\n        compress_tag=COMPRESSION_NONE;\n        break;\n      }\n    }\n#if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION > 20040919)\n    if ((compress_tag != COMPRESSION_NONE) &&\n        (TIFFIsCODECConfigured(compress_tag) == 0))\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n          \"CompressionNotSupported\",\"`%s'\",CommandOptionToMnemonic(\n          MagickCompressOptions,(ssize_t) compression));\n        compress_tag=COMPRESSION_NONE;\n        compression=NoCompression;\n      }\n#else\n      switch (compress_tag)\n      {\n#if defined(CCITT_SUPPORT)\n        case COMPRESSION_CCITTFAX3:\n        case COMPRESSION_CCITTFAX4:\n#endif\n#if defined(YCBCR_SUPPORT) && defined(JPEG_SUPPORT)\n        case COMPRESSION_JPEG:\n#endif\n#if defined(LZMA_SUPPORT) && defined(COMPRESSION_LZMA)\n        case COMPRESSION_LZMA:\n#endif\n#if defined(LZW_SUPPORT)\n        case COMPRESSION_LZW:\n#endif\n#if defined(PACKBITS_SUPPORT)\n        case COMPRESSION_PACKBITS:\n#endif\n#if defined(ZIP_SUPPORT)\n        case COMPRESSION_ADOBE_DEFLATE:\n#endif\n        case COMPRESSION_NONE:\n          break;\n        default:\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n            \"CompressionNotSupported\",\"`%s'\",CommandOptionToMnemonic(\n              MagickCompressOptions,(ssize_t) compression));\n          compress_tag=COMPRESSION_NONE;\n          compression=NoCompression;\n          break;\n        }\n      }\n#endif\n    if (image->colorspace == CMYKColorspace)\n      {\n        photometric=PHOTOMETRIC_SEPARATED;\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,4);\n        (void) TIFFSetField(tiff,TIFFTAG_INKSET,INKSET_CMYK);\n      }\n    else\n      {\n        /*\n          Full color TIFF raster.\n        */\n        if (image->colorspace == LabColorspace)\n          {\n            photometric=PHOTOMETRIC_CIELAB;\n            EncodeLabImage(image,exception);\n          }\n        else\n          if (image->colorspace == YCbCrColorspace)\n            {\n              photometric=PHOTOMETRIC_YCBCR;\n              (void) TIFFSetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,1,1);\n              (void) SetImageStorageClass(image,DirectClass,exception);\n              (void) SetImageDepth(image,8,exception);\n            }\n          else\n            photometric=PHOTOMETRIC_RGB;\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,3);\n        if ((image_info->type != TrueColorType) &&\n            (image_info->type != TrueColorAlphaType))\n          {\n            if ((image_info->type != PaletteType) &&\n                (SetImageGray(image,exception) != MagickFalse))\n              {\n                photometric=(uint16) (quantum_info->min_is_white !=\n                  MagickFalse ? PHOTOMETRIC_MINISWHITE :\n                  PHOTOMETRIC_MINISBLACK);\n                (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,1);\n                if ((image->depth == 1) &&\n                    (image->alpha_trait == UndefinedPixelTrait))\n                  SetImageMonochrome(image,exception);\n              }\n            else\n              if (image->storage_class == PseudoClass)\n                {\n                  size_t\n                    depth;\n\n                  /*\n                    Colormapped TIFF raster.\n                  */\n                  (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,1);\n                  photometric=PHOTOMETRIC_PALETTE;\n                  depth=1;\n                  while ((GetQuantumRange(depth)+1) < image->colors)\n                    depth<<=1;\n                  status=SetQuantumDepth(image,quantum_info,depth);\n                  if (status == MagickFalse)\n                    ThrowWriterException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                }\n          }\n      }\n    (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian);\n    if ((compress_tag == COMPRESSION_CCITTFAX3) &&\n        (photometric != PHOTOMETRIC_MINISWHITE))\n      {\n        compress_tag=COMPRESSION_NONE;\n        endian=FILLORDER_MSB2LSB;\n      }\n    else\n      if ((compress_tag == COMPRESSION_CCITTFAX4) &&\n         (photometric != PHOTOMETRIC_MINISWHITE))\n       {\n         compress_tag=COMPRESSION_NONE;\n         endian=FILLORDER_MSB2LSB;\n       }\n    option=GetImageOption(image_info,\"tiff:fill-order\");\n    if (option != (const char *) NULL)\n      {\n        if (LocaleNCompare(option,\"msb\",3) == 0)\n          endian=FILLORDER_MSB2LSB;\n        if (LocaleNCompare(option,\"lsb\",3) == 0)\n          endian=FILLORDER_LSB2MSB;\n      }\n    (void) TIFFSetField(tiff,TIFFTAG_COMPRESSION,compress_tag);\n    (void) TIFFSetField(tiff,TIFFTAG_FILLORDER,endian);\n    (void) TIFFSetField(tiff,TIFFTAG_BITSPERSAMPLE,quantum_info->depth);\n    if (image->alpha_trait != UndefinedPixelTrait)\n      {\n        uint16\n          extra_samples,\n          sample_info[1],\n          samples_per_pixel;\n\n        /*\n          TIFF has a matte channel.\n        */\n        extra_samples=1;\n        sample_info[0]=EXTRASAMPLE_UNASSALPHA;\n        option=GetImageOption(image_info,\"tiff:alpha\");\n        if (option != (const char *) NULL)\n          {\n            if (LocaleCompare(option,\"associated\") == 0)\n              sample_info[0]=EXTRASAMPLE_ASSOCALPHA;\n            else\n              if (LocaleCompare(option,\"unspecified\") == 0)\n                sample_info[0]=EXTRASAMPLE_UNSPECIFIED;\n          }\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,\n          &samples_per_pixel);\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,samples_per_pixel+1);\n        (void) TIFFSetField(tiff,TIFFTAG_EXTRASAMPLES,extra_samples,\n          &sample_info);\n        if (sample_info[0] == EXTRASAMPLE_ASSOCALPHA)\n          SetQuantumAlphaType(quantum_info,AssociatedQuantumAlpha);\n      }\n    (void) TIFFSetField(tiff,TIFFTAG_PHOTOMETRIC,photometric);\n    switch (quantum_info->format)\n    {\n      case FloatingPointQuantumFormat:\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_IEEEFP);\n        (void) TIFFSetField(tiff,TIFFTAG_SMINSAMPLEVALUE,quantum_info->minimum);\n        (void) TIFFSetField(tiff,TIFFTAG_SMAXSAMPLEVALUE,quantum_info->maximum);\n        break;\n      }\n      case SignedQuantumFormat:\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_INT);\n        break;\n      }\n      case UnsignedQuantumFormat:\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_UINT);\n        break;\n      }\n      default:\n        break;\n    }\n    (void) TIFFSetField(tiff,TIFFTAG_ORIENTATION,ORIENTATION_TOPLEFT);\n    (void) TIFFSetField(tiff,TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\n    if (photometric == PHOTOMETRIC_RGB)\n      if ((image_info->interlace == PlaneInterlace) ||\n          (image_info->interlace == PartitionInterlace))\n        (void) TIFFSetField(tiff,TIFFTAG_PLANARCONFIG,PLANARCONFIG_SEPARATE);\n     rows_per_strip=TIFFDefaultStripSize(tiff,0);\n    option=GetImageOption(image_info,\"tiff:rows-per-strip\");\n    if (option != (const char *) NULL)\n      rows_per_strip=(size_t) strtol(option,(char **) NULL,10);\n    switch (compress_tag)\n    {\n      case COMPRESSION_JPEG:\n      {\n#if defined(JPEG_SUPPORT)\n        const char\n          *sampling_factor;\n\n        GeometryInfo\n          geometry_info;\n\n        MagickStatusType\n          flags;\n\n        rows_per_strip+=(16-(rows_per_strip % 16));\n        if (image_info->quality != UndefinedCompressionQuality)\n          (void) TIFFSetField(tiff,TIFFTAG_JPEGQUALITY,image_info->quality);\n        (void) TIFFSetField(tiff,TIFFTAG_JPEGCOLORMODE,JPEGCOLORMODE_RAW);\n        if (IssRGBCompatibleColorspace(image->colorspace) != MagickFalse)\n          {\n            const char\n              *value;\n\n            (void) TIFFSetField(tiff,TIFFTAG_JPEGCOLORMODE,JPEGCOLORMODE_RGB);\n            sampling_factor=(const char *) NULL;\n            value=GetImageProperty(image,\"jpeg:sampling-factor\",exception);\n            if (value != (char *) NULL)\n              {\n                sampling_factor=value;\n                if (image->debug != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Input sampling-factors=%s\",sampling_factor);\n              }\n            if (image_info->sampling_factor != (char *) NULL)\n              sampling_factor=image_info->sampling_factor;\n            if (sampling_factor != (const char *) NULL)\n              {\n                flags=ParseGeometry(sampling_factor,&geometry_info);\n                if ((flags & SigmaValue) == 0)\n                  geometry_info.sigma=geometry_info.rho;\n                if (image->colorspace == YCbCrColorspace)\n                  (void) TIFFSetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,(uint16)\n                    geometry_info.rho,(uint16) geometry_info.sigma);\n              }\n          }\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample);\n        if (bits_per_sample == 12)\n          (void) TIFFSetField(tiff,TIFFTAG_JPEGTABLESMODE,JPEGTABLESMODE_QUANT);\n#endif\n        break;\n      }\n      case COMPRESSION_ADOBE_DEFLATE:\n      {\n        rows_per_strip=(uint32) image->rows;\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample);\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          (void) TIFFSetField(tiff,TIFFTAG_PREDICTOR,PREDICTOR_HORIZONTAL);\n        (void) TIFFSetField(tiff,TIFFTAG_ZIPQUALITY,(long) (\n          image_info->quality == UndefinedCompressionQuality ? 7 :\n          MagickMin((ssize_t) image_info->quality/10,9)));\n        break;\n      }\n      case COMPRESSION_CCITTFAX3:\n      {\n        /*\n          Byte-aligned EOL.\n        */\n        rows_per_strip=(uint32) image->rows;\n        (void) TIFFSetField(tiff,TIFFTAG_GROUP3OPTIONS,4);\n        break;\n      }\n      case COMPRESSION_CCITTFAX4:\n      {\n        rows_per_strip=(uint32) image->rows;\n        break;\n      }\n#if defined(LZMA_SUPPORT) && defined(COMPRESSION_LZMA)\n      case COMPRESSION_LZMA:\n      {\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          (void) TIFFSetField(tiff,TIFFTAG_PREDICTOR,PREDICTOR_HORIZONTAL);\n        (void) TIFFSetField(tiff,TIFFTAG_LZMAPRESET,(long) (\n          image_info->quality == UndefinedCompressionQuality ? 7 :\n          MagickMin((ssize_t) image_info->quality/10,9)));\n        break;\n      }\n#endif\n      case COMPRESSION_LZW:\n      {\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample);\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          (void) TIFFSetField(tiff,TIFFTAG_PREDICTOR,PREDICTOR_HORIZONTAL);\n        break;\n      }\n      default:\n        break;\n    }\n    if (rows_per_strip < 1)\n      rows_per_strip=1;\n    if ((image->rows/rows_per_strip) >= (1UL << 15))\n      rows_per_strip=(uint32) (image->rows >> 15);\n    (void) TIFFSetField(tiff,TIFFTAG_ROWSPERSTRIP,rows_per_strip);\n    if ((image->resolution.x != 0.0) && (image->resolution.y != 0.0))\n      {\n        unsigned short\n          units;\n\n        /*\n          Set image resolution.\n        */\n        units=RESUNIT_NONE;\n        if (image->units == PixelsPerInchResolution)\n          units=RESUNIT_INCH;\n        if (image->units == PixelsPerCentimeterResolution)\n          units=RESUNIT_CENTIMETER;\n        (void) TIFFSetField(tiff,TIFFTAG_RESOLUTIONUNIT,(uint16) units);\n        (void) TIFFSetField(tiff,TIFFTAG_XRESOLUTION,image->resolution.x);\n        (void) TIFFSetField(tiff,TIFFTAG_YRESOLUTION,image->resolution.y);\n        if ((image->page.x < 0) || (image->page.y < 0))\n          (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n            \"TIFF: negative image positions unsupported\",\"%s\",image->filename);\n        if ((image->page.x > 0) && (image->resolution.x > 0.0))\n          {\n            /*\n              Set horizontal image position.\n            */\n            (void) TIFFSetField(tiff,TIFFTAG_XPOSITION,(float) image->page.x/\n              image->resolution.x);\n          }\n        if ((image->page.y > 0) && (image->resolution.y > 0.0))\n          {\n            /*\n              Set vertical image position.\n            */\n            (void) TIFFSetField(tiff,TIFFTAG_YPOSITION,(float) image->page.y/\n              image->resolution.y);\n          }\n      }\n    if (image->chromaticity.white_point.x != 0.0)\n      {\n        float\n          chromaticity[6];\n\n        /*\n          Set image chromaticity.\n        */\n        chromaticity[0]=(float) image->chromaticity.red_primary.x;\n        chromaticity[1]=(float) image->chromaticity.red_primary.y;\n        chromaticity[2]=(float) image->chromaticity.green_primary.x;\n        chromaticity[3]=(float) image->chromaticity.green_primary.y;\n        chromaticity[4]=(float) image->chromaticity.blue_primary.x;\n        chromaticity[5]=(float) image->chromaticity.blue_primary.y;\n        (void) TIFFSetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,chromaticity);\n        chromaticity[0]=(float) image->chromaticity.white_point.x;\n        chromaticity[1]=(float) image->chromaticity.white_point.y;\n        (void) TIFFSetField(tiff,TIFFTAG_WHITEPOINT,chromaticity);\n      }\n    if ((LocaleCompare(image_info->magick,\"PTIF\") != 0) &&\n        (image_info->adjoin != MagickFalse) && (GetImageListLength(image) > 1))\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n        if (image->scene != 0)\n          (void) TIFFSetField(tiff,TIFFTAG_PAGENUMBER,(uint16) image->scene,\n            GetImageListLength(image));\n      }\n    if (image->orientation != UndefinedOrientation)\n      (void) TIFFSetField(tiff,TIFFTAG_ORIENTATION,(uint16) image->orientation);\n    (void) TIFFSetProfiles(tiff,image);\n    {\n      uint16\n        page,\n        pages;\n\n      page=(uint16) scene;\n      pages=(uint16) GetImageListLength(image);\n      if ((LocaleCompare(image_info->magick,\"PTIF\") != 0) &&\n          (image_info->adjoin != MagickFalse) && (pages > 1))\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n      (void) TIFFSetField(tiff,TIFFTAG_PAGENUMBER,page,pages);\n    }\n    (void) TIFFSetProperties(tiff,image_info,image,exception);\nDisableMSCWarning(4127)\n    if (0)\nRestoreMSCWarning\n      (void) TIFFSetEXIFProperties(tiff,image,exception);\n    /*\n      Write image scanlines.\n    */\n    if (GetTIFFInfo(image_info,tiff,&tiff_info) == MagickFalse)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    quantum_info->endian=LSBEndian;\n    pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n    tiff_info.scanline=(unsigned char *) GetQuantumPixels(quantum_info);\n    switch (photometric)\n    {\n      case PHOTOMETRIC_CIELAB:\n      case PHOTOMETRIC_YCBCR:\n      case PHOTOMETRIC_RGB:\n      {\n        /*\n          RGB TIFF image.\n        */\n        switch (image_info->interlace)\n        {\n          case NoInterlace:\n          default:\n          {\n            quantum_type=RGBQuantum;\n            if (image->alpha_trait != UndefinedPixelTrait)\n              quantum_type=RGBAQuantum;\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const Quantum\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                quantum_type,pixels,exception);\n              (void) length;\n              if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          case PlaneInterlace:\n          case PartitionInterlace:\n          {\n            /*\n              Plane interlacing:  RRRRRR...GGGGGG...BBBBBB...\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const Quantum\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                RedQuantum,pixels,exception);\n              if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n                break;\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,100,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const Quantum\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                GreenQuantum,pixels,exception);\n              if (TIFFWritePixels(tiff,&tiff_info,y,1,image) == -1)\n                break;\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,200,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const Quantum\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                BlueQuantum,pixels,exception);\n              if (TIFFWritePixels(tiff,&tiff_info,y,2,image) == -1)\n                break;\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,300,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            if (image->alpha_trait != UndefinedPixelTrait)\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                register const Quantum\n                  *magick_restrict p;\n\n                p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n                if (p == (const Quantum *) NULL)\n                  break;\n                length=ExportQuantumPixels(image,(CacheView *) NULL,\n                  quantum_info,AlphaQuantum,pixels,exception);\n                if (TIFFWritePixels(tiff,&tiff_info,y,3,image) == -1)\n                  break;\n              }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,400,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            break;\n          }\n        }\n        break;\n      }\n      case PHOTOMETRIC_SEPARATED:\n      {\n        /*\n          CMYK TIFF image.\n        */\n        quantum_type=CMYKQuantum;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          quantum_type=CMYKAQuantum;\n        if (image->colorspace != CMYKColorspace)\n          (void) TransformImageColorspace(image,CMYKColorspace,exception);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case PHOTOMETRIC_PALETTE:\n      {\n        uint16\n          *blue,\n          *green,\n          *red;\n\n        /*\n          Colormapped TIFF image.\n        */\n        red=(uint16 *) AcquireQuantumMemory(65536,sizeof(*red));\n        green=(uint16 *) AcquireQuantumMemory(65536,sizeof(*green));\n        blue=(uint16 *) AcquireQuantumMemory(65536,sizeof(*blue));\n        if ((red == (uint16 *) NULL) || (green == (uint16 *) NULL) ||\n            (blue == (uint16 *) NULL))\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        /*\n          Initialize TIFF colormap.\n        */\n        (void) ResetMagickMemory(red,0,65536*sizeof(*red));\n        (void) ResetMagickMemory(green,0,65536*sizeof(*green));\n        (void) ResetMagickMemory(blue,0,65536*sizeof(*blue));\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          red[i]=ScaleQuantumToShort(image->colormap[i].red);\n          green[i]=ScaleQuantumToShort(image->colormap[i].green);\n          blue[i]=ScaleQuantumToShort(image->colormap[i].blue);\n        }\n        (void) TIFFSetField(tiff,TIFFTAG_COLORMAP,red,green,blue);\n        red=(uint16 *) RelinquishMagickMemory(red);\n        green=(uint16 *) RelinquishMagickMemory(green);\n        blue=(uint16 *) RelinquishMagickMemory(blue);\n      }\n      default:\n      {\n        /*\n          Convert PseudoClass packets to contiguous grayscale scanlines.\n        */\n        quantum_type=IndexQuantum;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          {\n            if (photometric != PHOTOMETRIC_PALETTE)\n              quantum_type=GrayAlphaQuantum;\n            else\n              quantum_type=IndexAlphaQuantum;\n           }\n         else\n           if (photometric != PHOTOMETRIC_PALETTE)\n             quantum_type=GrayQuantum;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n    }\n    quantum_info=DestroyQuantumInfo(quantum_info);\n    if (image->colorspace == LabColorspace)\n      DecodeLabImage(image,exception);\n    DestroyTIFFInfo(&tiff_info);\nDisableMSCWarning(4127)\n    if (0 && (image_info->verbose != MagickFalse))\nRestoreMSCWarning\n      TIFFPrintDirectory(tiff,stdout,MagickFalse);\n    (void) TIFFWriteDirectory(tiff);\n    image=SyncNextImageInList(image);\n    if (image == (Image *) NULL)\n      break;\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  TIFFClose(tiff);\n  return(MagickTrue);\n}\n#endif\n"], "fixing_code": ["2016-08-15  7.0.2-10 Cristy  <quetzlzacatenango@image...>\n  * Prevent buffer overflow in BMP & SGI coders (bug report from\n    pwchen&rayzhong of tencent).\n  * Prevent buffer overflow and other problems in SIXEL, PDB, MAP, TIFF and\n    CALS coders (bug report from Donghai Zhu).\n\n2016-08-14  7.0.2-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-9, GIT revision 18707:2c02f09:20160814.\n\n2016-08-14  7.0.2-9 Cristy  <quetzlzacatenango@image...>\n  * Fix compile error in opencl.c (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=30289).\n  * Eliminate compiler warning.\n\n2016-08-14  7.0.2-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-8, GIT revision 18698:74b1d5d:20160814.\n\n2016-08-07  7.0.2-8 Cristy  <quetzlzacatenango@image...>\n  * Prevent spurious removal of MPC cache files (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=30256).\n  * Note alpha channel when combining 4 or more images (reference\n    https://github.com/ImageMagick/ImageMagick/issues/250).\n\n2016-08-06  7.0.2-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-7, GIT revision 10980:ecc03a2:20160806.\n\n2016-08-01  7.0.2-7 Cristy  <quetzlzacatenango@image...>\n  * Evaluate lazy pixel cache morphology to prevent buffer overflow (bug report\n    from Ibrahim M. El-Sayed).\n  * Prevent buffer overflow (bug report from Max Thrane).\n  * Prevent memory use after free (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=30245).\n\n2016-07-30  7.0.2-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-6, GIT revision 18651:df24175:20160729.\n\n2016-07-29  7.0.2-6 Cristy  <quetzlzacatenango@image...>\n  * Support -region option (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=1&t=29692).\n\n2016-07-21  7.0.2-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-5, GIT revision 18627:2b5ddbd:20160721.\n\n2016-07-13  7.0.2-5 Cristy  <quetzlzacatenango@image...>\n  * Fix MVG stroke-opacity (reference\n    https://github.com/ImageMagick/ImageMagick/issues/229).\n  * Prevent possible buffer overflow when reading TIFF images (bug report from\n    Shi Pu of MS509 Team).\n  * Initialize index channel to get expected results from the stegano coder.\n\n2016-07-11  7.0.2-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-4, GIT revision 18591:50debe5:20160710.\n\n2016-07-10  7.0.2-4 Cristy  <quetzlzacatenango@image...>\n  * To comply with the SVG standard, use stroke-opacity for transparent strokes.\n  * Define CompositeChannels mask to Red, Green, Blue, Alpha, and Black.\n\n2016-07-09  7.0.2-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-3, GIT revision 18572:28560fc:20160709.\n\n2016-07-01  7.0.2-3 Cristy  <quetzlzacatenango@image...>\n  * Patch so -kuwahara option can preserve colormapped edges.\n  * The histogram coder now returns the correct extent.\n  * Use CopyMagickString() rather than CopyMagickMemory() for strings.\n\n2016-06-26  7.0.2-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-2, GIT revision 18514:a7b5b46:20160626.\n\n2016-06-23  7.0.2-2 Cristy  <quetzlzacatenango@image...>\n  * Correct for numerical instability (reference\n    https://github.com/ImageMagick/ImageMagick/issues/218).\n\t\t\t \n2016-06-21  7.0.2-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-1, GIT revision 18479:931319b:20160622.\n\n2016-06-17  7.0.2-1 Dirk Lemstra <dirk@lem.....org>\n  * Added support for GROUP4 compression to the FAX coder.\n\n2016-06-12  7.0.2-1 Cristy  <quetzlzacatenango@image...>\n  * Distort no longer converts grayscale image to sRGB (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=1&t=29895).\n  * Don't return a zero bounding box for QueryMultilineFontMetrics() (reference\n    https://github.com/ImageMagick/ImageMagick/issues/222).\n\n2016-06-12  7.0.2-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-0, GIT revision 10884:f0e15e8:20160612.\n\n2016-06-09  7.0.2-0 Cristy  <quetzlzacatenango@image...>\n  * Backoff finite precision epsilon (reference\n    https://github.com/ImageMagick/ImageMagick/issues/215).\n  * Fix drawing glitch for stroke widths greater than 2 (reference\n    https://github.com/ImageMagick/ImageMagick/issues/218).\n\n2016-06-05  7.0.1-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-10, GIT revision 18406:ba4ad2d:20160607.\n\n2016-06-04  7.0.1-10 Cristy  <quetzlzacatenango@image...>\n  * Deny indirect reads by policy, remove policy to permit, e.g.,\n    convert caption:@mytext.txt ...\n  * RLE check for pixel offset less than 0 (heap overflow report from Craig\n    Young).\n  * Properly initialze PES blocks (reference\n    https://github.com/ImageMagick/ImageMagick/issues/213).\n\n2016-06-03  7.0.1-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-9, GIT revision 10847:339f803:20160602.\n\n2016-06-02  7.0.1-9 Cristy  <quetzlzacatenango@image...>\n  * Fix small memory leak (patch provided by \u0410\u043d\u0434\u0440\u0435\u0439 \u0427\u0435\u0440\u043d\u044b\u0439).\n  * Coder path traversal is not authorized (bug report provided by\n    Masaaki Chida).\n  * Turn off alpha channel for the compare difference image (reference\n    http://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=29828).\n\n2016-05-31  7.0.1-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-8, GIT revision 18334:97775b5:20160531.\n\n2016-05-31  7.0.1-8 Cristy  <quetzlzacatenango@image...>\n  * Support configure script --enable-pipes option to enable pipes (|) in\n    filenames.\n  * Support configure script --enable-indirect-reads option to enable\n    indirect reads (@) in filenames.\n\n2016-05-30  7.0.1-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-7, GIT revision 18321:5511ef5:20160530.\n\n2016-05-25  7.0.1-7 Cristy  <quetzlzacatenango@image...>\n  * Security improvements to TEXT coder broke it (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=29754).\n  * Fix stroke offset problem for -annotate (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=29626).\n  * Don't interpret -fx option arguments (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=29774);\n  * Add additional checks to DCM reader to prevent data-driven faults (bug\n    report from Hanno B\u00f6ck).\n\n2016-05-21  7.0.1-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-6, GIT revision 18241:d4f277c:20160521.\n\n2016-05-20  7.0.1-6 Cristy  <quetzlzacatenango@image...>\n  * Fixed proper placement of text annotation for east / west gravity.\n\n2016-05-18  7.0.1-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-5, GIT revision 10789:f7c2e89:20160518,\n\n2016-05-18  7.0.1-5 Cristy  <quetzlzacatenango@image...>\n  * Process channels independently for -channel -equalize (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=29708).\n  * Fix pixel cache on disk regression (reference\n    https://github.com/ImageMagick/ImageMagick/issues/202).\n\n2016-05-15  7.0.1-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-4, GIT revision 10778:52dae14:20160516.\n\n2016-05-10  7.0.1-4 Cristy  <quetzlzacatenango@image...>\n  * Prevent possible shell command injection vulnerability through the\n    authenticate parameter of the PDF, PCL and XPS coders (report from\n    Erez Turjeman).\n  * Quote passwords when passed to a delegate program.\n  * Iterate channels over source image rather than destination (bug report\n    from Hanno B\u00f6ck).\n  * Can read geo-related EXIF metdata once-again (reference\n    https://github.com/ImageMagick/ImageMagick/issues/198).\n  * Sanitize all delegate emedded formatting characters.\n  * Don't sync pixel cache in AcquireAuthenticCacheView() (bug report from\n    Hanno B\u00f6ck).\n\n2016-05-09  7.0.1-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-3, GIT revision 10755:d540dda:20160509.\n\n2016-05-07  7.0.1-3 Cristy  <quetzlzacatenango@image...>\n  * Remove https delegate.\n\n2016-05-06  7.0.1-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-2, GIT revision 10741:5746147:20160507.\n\n2016-05-04  7.0.1-2 Cristy  <quetzlzacatenango@image...>\n  * Check for buffer overflow in magick/draw.c/DrawStrokePolygon().\n  * Replace show delegate title with image filename rather than label.\n  * Fix GetNextToken() off by one error.\n  * Remove support for internal ephemeral coder.\n\n2016-05-03  7.0.1-1 Cristy  <quetzlzacatenango@image...>\n  * New version 7.0.1-1, GIT revision 10723:9fc8a0c:20160503.\n\n2016-05-03  7.0.1-1 Cristy  <quetzlzacatenango@image...>\n  * Sanitize input filename for http / https delegates (improved patch).\n  * Fix for possible security vulnerabilities (reference\n    https://www.imagemagick.org/discourse-server/viewtopic.php?f=4&t=29588).\n\n2016-04-30  7.0.1-0 Cristy  <quetzlzacatenango@image...>\n  * New version 7.0.1-0, GIT revision 10716:b527bce:20160430.\n\n2016-01-30  7.0.0-0 \tFahad-Alsaidi & ShamsaHamed\n  * Add support for languages that require complex text layout (reference\n    https://github.com/ImageMagick/ImageMagick/pull/88).\n\n2012-04-27  7.0.0-0 Anthony thyssen <A.Thyssen@griffith...>\n  * Allow the use of set and escapes when no images in memory\n    (unless you attempt to access per-image meta-data)\n    Currently does not include %[fx:...] and %[pixel:...]\n\n2012-10-05  7.0.0-0 Anthony thyssen <A.Thyssen@griffith...>\n  * Rather than replicate 'options' into 'artifacts' make a link\n    from image to image_info and lookup a global option if no artifact\n    is defined.\n\n2012-09-11  7.0.0-0 Nicolas Robidoux <nicolas.robidoux@gmail...>\n  * sigmoidal-contrast:\n  * Remove unnecessary initial ClampToQuantum.\n\n2012-09-10  7.0.0-0 Nicolas Robidoux <nicolas.robidoux@gmail...>\n  * sigmoidal-contrast:\n  * Direct computation, without LUT;\n  * Fix re-declaration of i (at the top, and inside a conditional).\n\n2012-09-04  7.0.0-0 Nicolas Robidoux <nicolas.robidoux@gmail...>\n  * Add tanh/atanh clone of legacy sigmoidal map (faster & more accurate).\n\n2012-08-08  7.0.0-0 Nicolas Robidoux <nicolas.robidoux@gmail...>\n  * Add final ClampToQuantum in sigmoidal colormap loop.\n  * Remove OpenMP calls from colormap update loops.\n\n2011-08-01  7.0.0-0 Cristy  <quetzlzacatenango@image...>\n  * New version 7.0.0-0.\n\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                        TTTTT  IIIII  FFFFF  FFFFF                           %\n%                          T      I    F      F                               %\n%                          T      I    FFF    FFF                             %\n%                          T      I    F      F                               %\n%                          T    IIIII  F      F                               %\n%                                                                             %\n%                                                                             %\n%                        Read/Write TIFF Image Format                         %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n#ifdef __VMS\n#define JPEG_SUPPORT 1\n#endif\n\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/enhance.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/memory-private.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/pixel-private.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/resize.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/splay-tree.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/thread_.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/utility.h\"\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n# if defined(MAGICKCORE_HAVE_TIFFCONF_H)\n#  include \"tiffconf.h\"\n# endif\n# include \"tiff.h\"\n# include \"tiffio.h\"\n# if !defined(COMPRESSION_ADOBE_DEFLATE)\n#  define COMPRESSION_ADOBE_DEFLATE  8\n# endif\n# if !defined(PREDICTOR_HORIZONTAL)\n# define PREDICTOR_HORIZONTAL  2\n# endif\n# if !defined(TIFFTAG_COPYRIGHT)\n#  define TIFFTAG_COPYRIGHT  33432\n# endif\n# if !defined(TIFFTAG_OPIIMAGEID)\n#  define TIFFTAG_OPIIMAGEID  32781\n# endif\n#include \"psd-private.h\"\n\n/*\n  Typedef declarations.\n*/\ntypedef enum\n{\n  ReadSingleSampleMethod,\n  ReadRGBAMethod,\n  ReadCMYKAMethod,\n  ReadYCCKMethod,\n  ReadStripMethod,\n  ReadTileMethod,\n  ReadGenericMethod\n} TIFFMethodType;\n\n#if defined(MAGICKCORE_HAVE_TIFFREADEXIFDIRECTORY)\ntypedef struct _ExifInfo\n{\n  unsigned int\n    tag,\n    type,\n    variable_length;\n\n  const char\n    *property;\n} ExifInfo;\n\nstatic const ExifInfo\n  exif_info[] = {\n    { EXIFTAG_EXPOSURETIME, TIFF_RATIONAL, 0, \"exif:ExposureTime\" },\n    { EXIFTAG_FNUMBER, TIFF_RATIONAL, 0, \"exif:FNumber\" },\n    { EXIFTAG_EXPOSUREPROGRAM, TIFF_SHORT, 0, \"exif:ExposureProgram\" },\n    { EXIFTAG_SPECTRALSENSITIVITY, TIFF_ASCII, 0, \"exif:SpectralSensitivity\" },\n    { EXIFTAG_ISOSPEEDRATINGS, TIFF_SHORT, 1, \"exif:ISOSpeedRatings\" },\n    { EXIFTAG_OECF, TIFF_NOTYPE, 0, \"exif:OptoelectricConversionFactor\" },\n    { EXIFTAG_EXIFVERSION, TIFF_NOTYPE, 0, \"exif:ExifVersion\" },\n    { EXIFTAG_DATETIMEORIGINAL, TIFF_ASCII, 0, \"exif:DateTimeOriginal\" },\n    { EXIFTAG_DATETIMEDIGITIZED, TIFF_ASCII, 0, \"exif:DateTimeDigitized\" },\n    { EXIFTAG_COMPONENTSCONFIGURATION, TIFF_NOTYPE, 0, \"exif:ComponentsConfiguration\" },\n    { EXIFTAG_COMPRESSEDBITSPERPIXEL, TIFF_RATIONAL, 0, \"exif:CompressedBitsPerPixel\" },\n    { EXIFTAG_SHUTTERSPEEDVALUE, TIFF_SRATIONAL, 0, \"exif:ShutterSpeedValue\" },\n    { EXIFTAG_APERTUREVALUE, TIFF_RATIONAL, 0, \"exif:ApertureValue\" },\n    { EXIFTAG_BRIGHTNESSVALUE, TIFF_SRATIONAL, 0, \"exif:BrightnessValue\" },\n    { EXIFTAG_EXPOSUREBIASVALUE, TIFF_SRATIONAL, 0, \"exif:ExposureBiasValue\" },\n    { EXIFTAG_MAXAPERTUREVALUE, TIFF_RATIONAL, 0, \"exif:MaxApertureValue\" },\n    { EXIFTAG_SUBJECTDISTANCE, TIFF_RATIONAL, 0, \"exif:SubjectDistance\" },\n    { EXIFTAG_METERINGMODE, TIFF_SHORT, 0, \"exif:MeteringMode\" },\n    { EXIFTAG_LIGHTSOURCE, TIFF_SHORT, 0, \"exif:LightSource\" },\n    { EXIFTAG_FLASH, TIFF_SHORT, 0, \"exif:Flash\" },\n    { EXIFTAG_FOCALLENGTH, TIFF_RATIONAL, 0, \"exif:FocalLength\" },\n    { EXIFTAG_SUBJECTAREA, TIFF_NOTYPE, 0, \"exif:SubjectArea\" },\n    { EXIFTAG_MAKERNOTE, TIFF_NOTYPE, 0, \"exif:MakerNote\" },\n    { EXIFTAG_USERCOMMENT, TIFF_NOTYPE, 0, \"exif:UserComment\" },\n    { EXIFTAG_SUBSECTIME, TIFF_ASCII, 0, \"exif:SubSecTime\" },\n    { EXIFTAG_SUBSECTIMEORIGINAL, TIFF_ASCII, 0, \"exif:SubSecTimeOriginal\" },\n    { EXIFTAG_SUBSECTIMEDIGITIZED, TIFF_ASCII, 0, \"exif:SubSecTimeDigitized\" },\n    { EXIFTAG_FLASHPIXVERSION, TIFF_NOTYPE, 0, \"exif:FlashpixVersion\" },\n    { EXIFTAG_PIXELXDIMENSION, TIFF_LONG, 0, \"exif:PixelXDimension\" },\n    { EXIFTAG_PIXELYDIMENSION, TIFF_LONG, 0, \"exif:PixelYDimension\" },\n    { EXIFTAG_RELATEDSOUNDFILE, TIFF_ASCII, 0, \"exif:RelatedSoundFile\" },\n    { EXIFTAG_FLASHENERGY, TIFF_RATIONAL, 0, \"exif:FlashEnergy\" },\n    { EXIFTAG_SPATIALFREQUENCYRESPONSE, TIFF_NOTYPE, 0, \"exif:SpatialFrequencyResponse\" },\n    { EXIFTAG_FOCALPLANEXRESOLUTION, TIFF_RATIONAL, 0, \"exif:FocalPlaneXResolution\" },\n    { EXIFTAG_FOCALPLANEYRESOLUTION, TIFF_RATIONAL, 0, \"exif:FocalPlaneYResolution\" },\n    { EXIFTAG_FOCALPLANERESOLUTIONUNIT, TIFF_SHORT, 0, \"exif:FocalPlaneResolutionUnit\" },\n    { EXIFTAG_SUBJECTLOCATION, TIFF_SHORT, 0, \"exif:SubjectLocation\" },\n    { EXIFTAG_EXPOSUREINDEX, TIFF_RATIONAL, 0, \"exif:ExposureIndex\" },\n    { EXIFTAG_SENSINGMETHOD, TIFF_SHORT, 0, \"exif:SensingMethod\" },\n    { EXIFTAG_FILESOURCE, TIFF_NOTYPE, 0, \"exif:FileSource\" },\n    { EXIFTAG_SCENETYPE, TIFF_NOTYPE, 0, \"exif:SceneType\" },\n    { EXIFTAG_CFAPATTERN, TIFF_NOTYPE, 0, \"exif:CFAPattern\" },\n    { EXIFTAG_CUSTOMRENDERED, TIFF_SHORT, 0, \"exif:CustomRendered\" },\n    { EXIFTAG_EXPOSUREMODE, TIFF_SHORT, 0, \"exif:ExposureMode\" },\n    { EXIFTAG_WHITEBALANCE, TIFF_SHORT, 0, \"exif:WhiteBalance\" },\n    { EXIFTAG_DIGITALZOOMRATIO, TIFF_RATIONAL, 0, \"exif:DigitalZoomRatio\" },\n    { EXIFTAG_FOCALLENGTHIN35MMFILM, TIFF_SHORT, 0, \"exif:FocalLengthIn35mmFilm\" },\n    { EXIFTAG_SCENECAPTURETYPE, TIFF_SHORT, 0, \"exif:SceneCaptureType\" },\n    { EXIFTAG_GAINCONTROL, TIFF_RATIONAL, 0, \"exif:GainControl\" },\n    { EXIFTAG_CONTRAST, TIFF_SHORT, 0, \"exif:Contrast\" },\n    { EXIFTAG_SATURATION, TIFF_SHORT, 0, \"exif:Saturation\" },\n    { EXIFTAG_SHARPNESS, TIFF_SHORT, 0, \"exif:Sharpness\" },\n    { EXIFTAG_DEVICESETTINGDESCRIPTION, TIFF_NOTYPE, 0, \"exif:DeviceSettingDescription\" },\n    { EXIFTAG_SUBJECTDISTANCERANGE, TIFF_SHORT, 0, \"exif:SubjectDistanceRange\" },\n    { EXIFTAG_IMAGEUNIQUEID, TIFF_ASCII, 0, \"exif:ImageUniqueID\" },\n    { 0, 0, 0, (char *) NULL }\n};\n#endif\n#endif  /* MAGICKCORE_TIFF_DELEGATE */\n\f\n/*\n  Global declarations.\n*/\nstatic MagickThreadKey\n  tiff_exception;\n\nstatic SemaphoreInfo\n  *tiff_semaphore = (SemaphoreInfo *) NULL;\n\nstatic TIFFErrorHandler\n  error_handler,\n  warning_handler;\n\nstatic volatile MagickBooleanType\n  instantiate_key = MagickFalse;\n\f\n/*\n  Forward declarations.\n*/\n#if defined(MAGICKCORE_TIFF_DELEGATE)\nstatic Image *\n  ReadTIFFImage(const ImageInfo *,ExceptionInfo *);\n\nstatic MagickBooleanType\n  WriteGROUP4Image(const ImageInfo *,Image *,ExceptionInfo *),\n  WritePTIFImage(const ImageInfo *,Image *,ExceptionInfo *),\n  WriteTIFFImage(const ImageInfo *,Image *,ExceptionInfo *);\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s T I F F                                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsTIFF() returns MagickTrue if the image format type, identified by the\n%  magick string, is TIFF.\n%\n%  The format of the IsTIFF method is:\n%\n%      MagickBooleanType IsTIFF(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsTIFF(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\115\\115\\000\\052\",4) == 0)\n    return(MagickTrue);\n  if (memcmp(magick,\"\\111\\111\\052\\000\",4) == 0)\n    return(MagickTrue);\n#if defined(TIFF_VERSION_BIG)\n  if (length < 8)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\115\\115\\000\\053\\000\\010\\000\\000\",8) == 0)\n    return(MagickTrue);\n  if (memcmp(magick,\"\\111\\111\\053\\000\\010\\000\\000\\000\",8) == 0)\n    return(MagickTrue);\n#endif\n  return(MagickFalse);\n}\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d G R O U P 4 I m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadGROUP4Image() reads a raw CCITT Group 4 image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadGROUP4Image method is:\n%\n%      Image *ReadGROUP4Image(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline size_t WriteLSBLong(FILE *file,const size_t value)\n{\n  unsigned char\n    buffer[4];\n\n  buffer[0]=(unsigned char) value;\n  buffer[1]=(unsigned char) (value >> 8);\n  buffer[2]=(unsigned char) (value >> 16);\n  buffer[3]=(unsigned char) (value >> 24);\n  return(fwrite(buffer,1,4,file));\n}\n\nstatic Image *ReadGROUP4Image(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n\n  FILE\n    *file;\n\n  Image\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    length;\n\n  ssize_t\n    offset,\n    strip_offset;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Write raw CCITT Group 4 wrapped as a TIFF image file.\n  */\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"wb\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    ThrowImageException(FileOpenError,\"UnableToCreateTemporaryFile\");\n  length=fwrite(\"\\111\\111\\052\\000\\010\\000\\000\\000\\016\\000\",1,10,file);\n  length=fwrite(\"\\376\\000\\003\\000\\001\\000\\000\\000\\000\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\000\\001\\004\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,image->columns);\n  length=fwrite(\"\\001\\001\\004\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,image->rows);\n  length=fwrite(\"\\002\\001\\003\\000\\001\\000\\000\\000\\001\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\003\\001\\003\\000\\001\\000\\000\\000\\004\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\006\\001\\003\\000\\001\\000\\000\\000\\000\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\021\\001\\003\\000\\001\\000\\000\\000\",1,8,file);\n  strip_offset=10+(12*14)+4+8;\n  length=WriteLSBLong(file,(size_t) strip_offset);\n  length=fwrite(\"\\022\\001\\003\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(size_t) image_info->orientation);\n  length=fwrite(\"\\025\\001\\003\\000\\001\\000\\000\\000\\001\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\026\\001\\004\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,image->rows);\n  length=fwrite(\"\\027\\001\\004\\000\\001\\000\\000\\000\\000\\000\\000\\000\",1,12,file);\n  offset=(ssize_t) ftell(file)-4;\n  length=fwrite(\"\\032\\001\\005\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(size_t) (strip_offset-8));\n  length=fwrite(\"\\033\\001\\005\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(size_t) (strip_offset-8));\n  length=fwrite(\"\\050\\001\\003\\000\\001\\000\\000\\000\\002\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\000\\000\\000\\000\",1,4,file);\n  length=WriteLSBLong(file,(long) image->resolution.x);\n  length=WriteLSBLong(file,1);\n  status=MagickTrue;\n  for (length=0; (c=ReadBlobByte(image)) != EOF; length++)\n    if (fputc(c,file) != c)\n      status=MagickFalse;\n  offset=(ssize_t) fseek(file,(ssize_t) offset,SEEK_SET);\n  length=WriteLSBLong(file,(unsigned int) length);\n  (void) fclose(file);\n  (void) CloseBlob(image);\n  image=DestroyImage(image);\n  /*\n    Read TIFF image.\n  */\n  read_info=CloneImageInfo((ImageInfo *) NULL);\n  (void) FormatLocaleString(read_info->filename,MagickPathExtent,\"%s\",filename);\n  image=ReadTIFFImage(read_info,exception);\n  read_info=DestroyImageInfo(read_info);\n  if (image != (Image *) NULL)\n    {\n      (void) CopyMagickString(image->filename,image_info->filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image->magick_filename,image_info->filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image->magick,\"GROUP4\",MagickPathExtent);\n    }\n  (void) RelinquishUniqueFileResource(filename);\n  if (status == MagickFalse)\n    image=DestroyImage(image);\n  return(image);\n}\n#endif\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d T I F F I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadTIFFImage() reads a Tagged image file and returns it.  It allocates the\n%  memory necessary for the new Image structure and returns a pointer to the\n%  new image.\n%\n%  The format of the ReadTIFFImage method is:\n%\n%      Image *ReadTIFFImage(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline unsigned char ClampYCC(double value)\n{\n  value=255.0-value;\n  if (value < 0.0)\n    return((unsigned char)0);\n  if (value > 255.0)\n    return((unsigned char)255);\n  return((unsigned char)(value));\n}\n\nstatic MagickBooleanType DecodeLabImage(Image *image,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        a,\n        b;\n\n      a=QuantumScale*GetPixela(image,q)+0.5;\n      if (a > 1.0)\n        a-=1.0;\n      b=QuantumScale*GetPixelb(image,q)+0.5;\n      if (b > 1.0)\n        b-=1.0;\n      SetPixela(image,QuantumRange*a,q);\n      SetPixelb(image,QuantumRange*b,q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\nstatic MagickBooleanType ReadProfile(Image *image,const char *name,\n  const unsigned char *datum,ssize_t length,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  StringInfo\n    *profile;\n\n  if (length < 4)\n    return(MagickFalse);\n  profile=BlobToStringInfo(datum,(size_t) length);\n  if (profile == (StringInfo *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  status=SetImageProfile(image,name,profile,exception);\n  profile=DestroyStringInfo(profile);\n  if (status == MagickFalse)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  return(MagickTrue);\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\nstatic int TIFFCloseBlob(thandle_t image)\n{\n  (void) CloseBlob((Image *) image);\n  return(0);\n}\n\nstatic void TIFFErrors(const char *module,const char *format,va_list error)\n{\n  char\n    message[MagickPathExtent];\n\n  ExceptionInfo\n    *exception;\n\n#if defined(MAGICKCORE_HAVE_VSNPRINTF)\n  (void) vsnprintf(message,MagickPathExtent,format,error);\n#else\n  (void) vsprintf(message,format,error);\n#endif\n  (void) ConcatenateMagickString(message,\".\",MagickPathExtent);\n  exception=(ExceptionInfo *) GetMagickThreadValue(tiff_exception);\n  if (exception != (ExceptionInfo *) NULL)\n    (void) ThrowMagickException(exception,GetMagickModule(),CoderError,message,\n      \"`%s'\",module);\n}\n\nstatic toff_t TIFFGetBlobSize(thandle_t image)\n{\n  return((toff_t) GetBlobSize((Image *) image));\n}\n\nstatic void TIFFGetProfiles(TIFF *tiff,Image *image,MagickBooleanType ping,\n  ExceptionInfo *exception)\n{\n  uint32\n    length;\n\n  unsigned char\n    *profile;\n\n  length=0;\n  if (ping == MagickFalse)\n    {\n#if defined(TIFFTAG_ICCPROFILE)\n      if ((TIFFGetField(tiff,TIFFTAG_ICCPROFILE,&length,&profile) == 1) &&\n          (profile != (unsigned char *) NULL))\n        (void) ReadProfile(image,\"icc\",profile,(ssize_t) length,exception);\n#endif\n#if defined(TIFFTAG_PHOTOSHOP)\n      if ((TIFFGetField(tiff,TIFFTAG_PHOTOSHOP,&length,&profile) == 1) &&\n          (profile != (unsigned char *) NULL))\n        (void) ReadProfile(image,\"8bim\",profile,(ssize_t) length,exception);\n#endif\n#if defined(TIFFTAG_RICHTIFFIPTC)\n      if ((TIFFGetField(tiff,TIFFTAG_RICHTIFFIPTC,&length,&profile) == 1) &&\n          (profile != (unsigned char *) NULL))\n        {\n          if (TIFFIsByteSwapped(tiff) != 0)\n            TIFFSwabArrayOfLong((uint32 *) profile,(size_t) length);\n          (void) ReadProfile(image,\"iptc\",profile,4L*length,exception);\n        }\n#endif\n#if defined(TIFFTAG_XMLPACKET)\n      if ((TIFFGetField(tiff,TIFFTAG_XMLPACKET,&length,&profile) == 1) &&\n          (profile != (unsigned char *) NULL))\n        (void) ReadProfile(image,\"xmp\",profile,(ssize_t) length,exception);\n#endif\n      if ((TIFFGetField(tiff,34118,&length,&profile) == 1) &&\n          (profile != (unsigned char *) NULL))\n        (void) ReadProfile(image,\"tiff:34118\",profile,(ssize_t) length,\n          exception);\n    }\n  if ((TIFFGetField(tiff,37724,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    (void) ReadProfile(image,\"tiff:37724\",profile,(ssize_t) length,exception);\n}\n\nstatic void TIFFGetProperties(TIFF *tiff,Image *image,ExceptionInfo *exception)\n{\n  char\n    message[MagickPathExtent],\n    *text;\n\n  uint32\n    count,\n    length,\n    type;\n\n  unsigned long\n    *tietz;\n\n\n  if (TIFFGetField(tiff,TIFFTAG_ARTIST,&text) == 1)\n    (void) SetImageProperty(image,\"tiff:artist\",text,exception);\n  if (TIFFGetField(tiff,TIFFTAG_COPYRIGHT,&text) == 1)\n    (void) SetImageProperty(image,\"tiff:copyright\",text,exception);\n  if (TIFFGetField(tiff,TIFFTAG_DATETIME,&text) == 1)\n    (void) SetImageProperty(image,\"tiff:timestamp\",text,exception);\n  if (TIFFGetField(tiff,TIFFTAG_DOCUMENTNAME,&text) == 1)\n    (void) SetImageProperty(image,\"tiff:document\",text,exception);\n  if (TIFFGetField(tiff,TIFFTAG_HOSTCOMPUTER,&text) == 1)\n    (void) SetImageProperty(image,\"tiff:hostcomputer\",text,exception);\n  if (TIFFGetField(tiff,TIFFTAG_IMAGEDESCRIPTION,&text) == 1)\n    (void) SetImageProperty(image,\"comment\",text,exception);\n  if (TIFFGetField(tiff,TIFFTAG_MAKE,&text) == 1)\n    (void) SetImageProperty(image,\"tiff:make\",text,exception);\n  if (TIFFGetField(tiff,TIFFTAG_MODEL,&text) == 1)\n    (void) SetImageProperty(image,\"tiff:model\",text,exception);\n  if (TIFFGetField(tiff,TIFFTAG_OPIIMAGEID,&count,&text) == 1)\n    {\n      if (count >= MagickPathExtent)\n        count=MagickPathExtent-1;\n      (void) CopyMagickString(message,text,count+1);\n      (void) SetImageProperty(image,\"tiff:image-id\",message,exception);\n    }\n  if (TIFFGetField(tiff,TIFFTAG_PAGENAME,&text) == 1)\n    (void) SetImageProperty(image,\"label\",text,exception);\n  if (TIFFGetField(tiff,TIFFTAG_SOFTWARE,&text) == 1)\n    (void) SetImageProperty(image,\"tiff:software\",text,exception);\n  if (TIFFGetField(tiff,33423,&count,&text) == 1)\n    {\n      if (count >= MagickPathExtent)\n        count=MagickPathExtent-1;\n      (void) CopyMagickString(message,text,count+1);\n      (void) SetImageProperty(image,\"tiff:kodak-33423\",message,exception);\n    }\n  if (TIFFGetField(tiff,36867,&count,&text) == 1)\n    {\n      if (count >= MagickPathExtent)\n        count=MagickPathExtent-1;\n      (void) CopyMagickString(message,text,count+1);\n      (void) SetImageProperty(image,\"tiff:kodak-36867\",message,exception);\n    }\n  if (TIFFGetField(tiff,TIFFTAG_SUBFILETYPE,&type) == 1)\n    switch (type)\n    {\n      case 0x01:\n      {\n        (void) SetImageProperty(image,\"tiff:subfiletype\",\"REDUCEDIMAGE\",\n          exception);\n        break;\n      }\n      case 0x02:\n      {\n        (void) SetImageProperty(image,\"tiff:subfiletype\",\"PAGE\",exception);\n        break;\n      }\n      case 0x04:\n      {\n        (void) SetImageProperty(image,\"tiff:subfiletype\",\"MASK\",exception);\n        break;\n      }\n      default:\n        break;\n    }\n  if (TIFFGetField(tiff,37706,&length,&tietz) == 1)\n    {\n      (void) FormatLocaleString(message,MagickPathExtent,\"%lu\",tietz[0]);\n      (void) SetImageProperty(image,\"tiff:tietz_offset\",message,exception);\n    }\n}\n\nstatic void TIFFGetEXIFProperties(TIFF *tiff,Image *image,\n  ExceptionInfo *exception)\n{\n#if defined(MAGICKCORE_HAVE_TIFFREADEXIFDIRECTORY)\n  char\n    value[MagickPathExtent];\n\n  register ssize_t\n    i;\n\n  tdir_t\n    directory;\n\n#if defined(TIFF_VERSION_BIG)\n  uint64\n#else\n  uint32\n#endif\n    offset;\n\n  void\n    *sans;\n\n  /*\n    Read EXIF properties.\n  */\n  offset=0;\n  if (TIFFGetField(tiff,TIFFTAG_EXIFIFD,&offset) != 1)\n    return;\n  directory=TIFFCurrentDirectory(tiff);\n  if (TIFFReadEXIFDirectory(tiff,offset) != 1)\n    {\n      TIFFSetDirectory(tiff,directory);\n      return;\n    }\n  sans=NULL;\n  for (i=0; exif_info[i].tag != 0; i++)\n  {\n    *value='\\0';\n    switch (exif_info[i].type)\n    {\n      case TIFF_ASCII:\n      {\n        char\n          *ascii;\n\n        ascii=(char *) NULL;\n        if ((TIFFGetField(tiff,exif_info[i].tag,&ascii,&sans,&sans) == 1) &&\n            (ascii != (char *) NULL) && (*ascii != '\\0'))\n          (void) CopyMagickString(value,ascii,MagickPathExtent);\n        break;\n      }\n      case TIFF_SHORT:\n      {\n        if (exif_info[i].variable_length == 0)\n          {\n            uint16\n              shorty;\n\n            shorty=0;\n            if (TIFFGetField(tiff,exif_info[i].tag,&shorty,&sans,&sans) == 1)\n              (void) FormatLocaleString(value,MagickPathExtent,\"%d\",shorty);\n          }\n        else\n          {\n            int\n              tiff_status;\n\n            uint16\n              *shorty;\n\n            uint16\n              shorty_num;\n\n            tiff_status=TIFFGetField(tiff,exif_info[i].tag,&shorty_num,&shorty,\n              &sans,&sans);\n            if (tiff_status == 1)\n              (void) FormatLocaleString(value,MagickPathExtent,\"%d\",\n                shorty_num != 0 ? shorty[0] : 0);\n          }\n        break;\n      }\n      case TIFF_LONG:\n      {\n        uint32\n          longy;\n\n        longy=0;\n        if (TIFFGetField(tiff,exif_info[i].tag,&longy,&sans,&sans) == 1)\n          (void) FormatLocaleString(value,MagickPathExtent,\"%d\",longy);\n        break;\n      }\n#if defined(TIFF_VERSION_BIG)\n      case TIFF_LONG8:\n      {\n        uint64\n          long8y;\n\n        long8y=0;\n        if (TIFFGetField(tiff,exif_info[i].tag,&long8y,&sans,&sans) == 1)\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n            ((MagickOffsetType) long8y));\n        break;\n      }\n#endif\n      case TIFF_RATIONAL:\n      case TIFF_SRATIONAL:\n      case TIFF_FLOAT:\n      {\n        float\n          floaty;\n\n        floaty=0.0;\n        if (TIFFGetField(tiff,exif_info[i].tag,&floaty,&sans,&sans) == 1)\n          (void) FormatLocaleString(value,MagickPathExtent,\"%g\",(double)\n            floaty);\n        break;\n      }\n      case TIFF_DOUBLE:\n      {\n        double\n          doubley;\n\n        doubley=0.0;\n        if (TIFFGetField(tiff,exif_info[i].tag,&doubley,&sans,&sans) == 1)\n          (void) FormatLocaleString(value,MagickPathExtent,\"%g\",doubley);\n        break;\n      }\n      default:\n        break;\n    }\n    if (*value != '\\0')\n      (void) SetImageProperty(image,exif_info[i].property,value,exception);\n  }\n  TIFFSetDirectory(tiff,directory);\n#else\n  (void) tiff;\n  (void) image;\n#endif\n}\n\nstatic int TIFFMapBlob(thandle_t image,tdata_t *base,toff_t *size)\n{\n  *base=(tdata_t *) GetBlobStreamData((Image *) image);\n  if (*base != (tdata_t *) NULL)\n    *size=(toff_t) GetBlobSize((Image *) image);\n  if (*base != (tdata_t *) NULL)\n    return(1);\n  return(0);\n}\n\nstatic tsize_t TIFFReadBlob(thandle_t image,tdata_t data,tsize_t size)\n{\n  tsize_t\n    count;\n\n  count=(tsize_t) ReadBlob((Image *) image,(size_t) size,\n    (unsigned char *) data);\n  return(count);\n}\n\nstatic int32 TIFFReadPixels(TIFF *tiff,size_t bits_per_sample,\n  tsample_t sample,ssize_t row,tdata_t scanline)\n{\n  int32\n    status;\n\n  (void) bits_per_sample;\n  status=TIFFReadScanline(tiff,scanline,(uint32) row,sample);\n  return(status);\n}\n\nstatic toff_t TIFFSeekBlob(thandle_t image,toff_t offset,int whence)\n{\n  return((toff_t) SeekBlob((Image *) image,(MagickOffsetType) offset,whence));\n}\n\nstatic void TIFFUnmapBlob(thandle_t image,tdata_t base,toff_t size)\n{\n  (void) image;\n  (void) base;\n  (void) size;\n}\n\nstatic void TIFFWarnings(const char *module,const char *format,va_list warning)\n{\n  char\n    message[MagickPathExtent];\n\n  ExceptionInfo\n    *exception;\n\n#if defined(MAGICKCORE_HAVE_VSNPRINTF)\n  (void) vsnprintf(message,MagickPathExtent,format,warning);\n#else\n  (void) vsprintf(message,format,warning);\n#endif\n  (void) ConcatenateMagickString(message,\".\",MagickPathExtent);\n  exception=(ExceptionInfo *) GetMagickThreadValue(tiff_exception);\n  if (exception != (ExceptionInfo *) NULL)\n    (void) ThrowMagickException(exception,GetMagickModule(),CoderWarning,\n      message,\"`%s'\",module);\n}\n\nstatic tsize_t TIFFWriteBlob(thandle_t image,tdata_t data,tsize_t size)\n{\n  tsize_t\n    count;\n\n  count=(tsize_t) WriteBlob((Image *) image,(size_t) size,\n    (unsigned char *) data);\n  return(count);\n}\n\nstatic TIFFMethodType GetJPEGMethod(Image* image,TIFF *tiff,uint16 photometric,\n  uint16 bits_per_sample,uint16 samples_per_pixel)\n{\n#define BUFFER_SIZE 2048\n\n  MagickOffsetType\n    position,\n    offset;\n\n  register size_t\n    i;\n\n  TIFFMethodType\n    method;\n\n#if defined(TIFF_VERSION_BIG)\n  uint64\n#else\n  uint32\n#endif\n    **value;\n\n  unsigned char\n    buffer[BUFFER_SIZE+32];\n\n  unsigned short\n    length;\n\n  /* only support 8 bit for now */\n  if ((photometric != PHOTOMETRIC_SEPARATED) || (bits_per_sample != 8) ||\n      (samples_per_pixel != 4))\n    return(ReadGenericMethod);\n  /* Search for Adobe APP14 JPEG Marker */\n  if (!TIFFGetField(tiff,TIFFTAG_STRIPOFFSETS,&value))\n    return(ReadRGBAMethod);\n  position=TellBlob(image);\n  offset=(MagickOffsetType) (value[0]);\n  if (SeekBlob(image,offset,SEEK_SET) != offset)\n    return(ReadRGBAMethod);\n  method=ReadRGBAMethod;\n  if (ReadBlob(image,BUFFER_SIZE,buffer) == BUFFER_SIZE)\n    {\n      for (i=0; i < BUFFER_SIZE; i++)\n      {\n        while (i < BUFFER_SIZE)\n        {\n          if (buffer[i++] == 255)\n           break;\n        }\n        while (i < BUFFER_SIZE)\n        {\n          if (buffer[++i] != 255)\n           break;\n        }\n        if (buffer[i++] == 216) /* JPEG_MARKER_SOI */\n          continue;\n        length=(unsigned short) (((unsigned int) (buffer[i] << 8) |\n          (unsigned int) buffer[i+1]) & 0xffff);\n        if (i+(size_t) length >= BUFFER_SIZE)\n          break;\n        if (buffer[i-1] == 238) /* JPEG_MARKER_APP0+14 */\n          {\n            if (length != 14)\n              break;\n            /* 0 == CMYK, 1 == YCbCr, 2 = YCCK */\n            if (buffer[i+13] == 2)\n              method=ReadYCCKMethod;\n            break;\n          }\n        i+=(size_t) length;\n      }\n    }\n  (void) SeekBlob(image,position,SEEK_SET);\n  return(method);\n}\n\nstatic void TIFFReadPhotoshopLayers(Image* image,const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  const char\n    *option;\n\n  const StringInfo\n    *layer_info;\n\n  Image\n    *layers;\n\n  PSDInfo\n    info;\n\n  register ssize_t\n    i;\n\n  if (GetImageListLength(image) != 1)\n    return;\n  if ((image_info->number_scenes == 1) && (image_info->scene == 0))\n    return;\n  option=GetImageOption(image_info,\"tiff:ignore-layers\");\n  if (option != (const char * ) NULL)\n    return;\n  layer_info=GetImageProfile(image,\"tiff:37724\");\n  if (layer_info == (const StringInfo *) NULL)\n    return;\n  for (i=0; i < (ssize_t) layer_info->length-8; i++)\n  {\n    if (LocaleNCompare((const char *) (layer_info->datum+i),\n        image->endian == MSBEndian ? \"8BIM\" : \"MIB8\",4) != 0)\n      continue;\n    i+=4;\n    if ((LocaleNCompare((const char *) (layer_info->datum+i),\n         image->endian == MSBEndian ? \"Layr\" : \"ryaL\",4) == 0) ||\n        (LocaleNCompare((const char *) (layer_info->datum+i),\n         image->endian == MSBEndian ? \"LMsk\" : \"ksML\",4) == 0) ||\n        (LocaleNCompare((const char *) (layer_info->datum+i),\n         image->endian == MSBEndian ? \"Lr16\" : \"61rL\",4) == 0) ||\n        (LocaleNCompare((const char *) (layer_info->datum+i),\n         image->endian == MSBEndian ? \"Lr32\" : \"23rL\",4) == 0))\n      break;\n  }\n  i+=4;\n  if (i >= (ssize_t) (layer_info->length-8))\n    return;\n  layers=CloneImage(image,image->columns,image->rows,MagickTrue,exception);\n  (void) DeleteImageProfile(layers,\"tiff:37724\");\n  AttachBlob(layers->blob,layer_info->datum,layer_info->length);\n  SeekBlob(layers,(MagickOffsetType) i,SEEK_SET);\n  info.version=1;\n  info.columns=layers->columns;\n  info.rows=layers->rows;\n  info.channels=(unsigned short) layers->number_channels;\n  /* Setting the mode to a value that won't change the colorspace */\n  info.mode=10;\n  ReadPSDLayers(layers,image_info,&info,MagickFalse,exception);\n  DeleteImageFromList(&layers);\n  if (layers != (Image *) NULL)\n    {\n      SetImageArtifact(image,\"tiff:has-layers\",\"true\");\n      AppendImageToList(&image,layers);\n      while (layers != (Image *) NULL)\n      {\n        SetImageArtifact(layers,\"tiff:has-layers\",\"true\");\n        DetachBlob(layers->blob);\n        layers=GetNextImageInList(layers);\n      }\n    }\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\nstatic Image *ReadTIFFImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  const char\n    *option;\n\n  float\n    *chromaticity,\n    x_position,\n    y_position,\n    x_resolution,\n    y_resolution;\n\n  Image\n    *image;\n\n  int\n    tiff_status;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  register ssize_t\n    i;\n\n  size_t\n    pad;\n\n  ssize_t\n    y;\n\n  TIFF\n    *tiff;\n\n  TIFFMethodType\n    method;\n\n  uint16\n    compress_tag,\n    bits_per_sample,\n    endian,\n    extra_samples,\n    interlace,\n    max_sample_value,\n    min_sample_value,\n    orientation,\n    pages,\n    photometric,\n    *sample_info,\n    sample_format,\n    samples_per_pixel,\n    units,\n    value;\n\n  uint32\n    height,\n    rows_per_strip,\n    width;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open image.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) SetMagickThreadValue(tiff_exception,exception);\n  tiff=TIFFClientOpen(image->filename,\"rb\",(thandle_t) image,TIFFReadBlob,\n    TIFFWriteBlob,TIFFSeekBlob,TIFFCloseBlob,TIFFGetBlobSize,TIFFMapBlob,\n    TIFFUnmapBlob);\n  if (tiff == (TIFF *) NULL)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (image_info->number_scenes != 0)\n    {\n      /*\n        Generate blank images for subimage specification (e.g. image.tif[4].\n        We need to check the number of directores because it is possible that\n        the subimage(s) are stored in the photoshop profile.\n      */\n      if (image_info->scene < (size_t) TIFFNumberOfDirectories(tiff))\n        {\n          for (i=0; i < (ssize_t) image_info->scene; i++)\n          {\n            status=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;\n            if (status == MagickFalse)\n              {\n                TIFFClose(tiff);\n                image=DestroyImageList(image);\n                return((Image *) NULL);\n              }\n            AcquireNextImage(image_info,image,exception);\n            if (GetNextImageInList(image) == (Image *) NULL)\n              {\n                TIFFClose(tiff);\n                image=DestroyImageList(image);\n                return((Image *) NULL);\n              }\n            image=SyncNextImageInList(image);\n          }\n      }\n  }\n  do\n  {\nDisableMSCWarning(4127)\n    if (0 && (image_info->verbose != MagickFalse))\n      TIFFPrintDirectory(tiff,stdout,MagickFalse);\nRestoreMSCWarning\n    if ((TIFFGetField(tiff,TIFFTAG_IMAGEWIDTH,&width) != 1) ||\n        (TIFFGetField(tiff,TIFFTAG_IMAGELENGTH,&height) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_COMPRESSION,&compress_tag) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_PLANARCONFIG,&interlace) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,&samples_per_pixel) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,&bits_per_sample) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLEFORMAT,&sample_format) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_MINSAMPLEVALUE,&min_sample_value) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_MAXSAMPLEVALUE,&max_sample_value) != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_PHOTOMETRIC,&photometric) != 1))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    if (sample_format == SAMPLEFORMAT_IEEEFP)\n      (void) SetImageProperty(image,\"quantum:format\",\"floating-point\",\n        exception);\n    switch (photometric)\n    {\n      case PHOTOMETRIC_MINISBLACK:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-black\",\n          exception);\n        break;\n      }\n      case PHOTOMETRIC_MINISWHITE:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-white\",\n          exception);\n        break;\n      }\n      case PHOTOMETRIC_PALETTE:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"palette\",exception);\n        break;\n      }\n      case PHOTOMETRIC_RGB:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"RGB\",exception);\n        break;\n      }\n      case PHOTOMETRIC_CIELAB:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"CIELAB\",exception);\n        break;\n      }\n      case PHOTOMETRIC_LOGL:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"CIE Log2(L)\",\n          exception);\n        break;\n      }\n      case PHOTOMETRIC_LOGLUV:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"LOGLUV\",exception);\n        break;\n      }\n#if defined(PHOTOMETRIC_MASK)\n      case PHOTOMETRIC_MASK:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"MASK\",exception);\n        break;\n      }\n#endif\n      case PHOTOMETRIC_SEPARATED:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"separated\",exception);\n        break;\n      }\n      case PHOTOMETRIC_YCBCR:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"YCBCR\",exception);\n        break;\n      }\n      default:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"unknown\",exception);\n        break;\n      }\n    }\n    if (image->debug != MagickFalse)\n      {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Geometry: %ux%u\",\n          (unsigned int) width,(unsigned int) height);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Interlace: %u\",\n          interlace);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Bits per sample: %u\",bits_per_sample);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Min sample value: %u\",min_sample_value);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Max sample value: %u\",max_sample_value);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Photometric \"\n          \"interpretation: %s\",GetImageProperty(image,\"tiff:photometric\",\n          exception));\n      }\n    image->columns=(size_t) width;\n    image->rows=(size_t) height;\n    image->depth=(size_t) bits_per_sample;\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Image depth: %.20g\",\n        (double) image->depth);\n    image->endian=MSBEndian;\n    if (endian == FILLORDER_LSB2MSB)\n      image->endian=LSBEndian;\n#if defined(MAGICKCORE_HAVE_TIFFISBIGENDIAN)\n    if (TIFFIsBigEndian(tiff) == 0)\n      {\n        (void) SetImageProperty(image,\"tiff:endian\",\"lsb\",exception);\n        image->endian=LSBEndian;\n      }\n    else\n      {\n        (void) SetImageProperty(image,\"tiff:endian\",\"msb\",exception);\n        image->endian=MSBEndian;\n      }\n#endif\n    if ((photometric == PHOTOMETRIC_MINISBLACK) ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      SetImageColorspace(image,GRAYColorspace,exception);\n    if (photometric == PHOTOMETRIC_SEPARATED)\n      SetImageColorspace(image,CMYKColorspace,exception);\n    if (photometric == PHOTOMETRIC_CIELAB)\n      SetImageColorspace(image,LabColorspace,exception);\n    TIFFGetProfiles(tiff,image,image_info->ping,exception);\n    TIFFGetProperties(tiff,image,exception);\n    option=GetImageOption(image_info,\"tiff:exif-properties\");\n    if (IsStringFalse(option) == MagickFalse) /* enabled by default */\n      TIFFGetEXIFProperties(tiff,image,exception);\n    (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,\n      &samples_per_pixel);\n    if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XRESOLUTION,&x_resolution) == 1) &&\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_YRESOLUTION,&y_resolution) == 1))\n      {\n        image->resolution.x=x_resolution;\n        image->resolution.y=y_resolution;\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_RESOLUTIONUNIT,&units) == 1)\n      {\n        if (units == RESUNIT_INCH)\n          image->units=PixelsPerInchResolution;\n        if (units == RESUNIT_CENTIMETER)\n          image->units=PixelsPerCentimeterResolution;\n      }\n    if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XPOSITION,&x_position) == 1) &&\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_YPOSITION,&y_position) == 1))\n      {\n        image->page.x=(ssize_t) ceil(x_position*image->resolution.x-0.5);\n        image->page.y=(ssize_t) ceil(y_position*image->resolution.y-0.5);\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_ORIENTATION,&orientation) == 1)\n      image->orientation=(OrientationType) orientation;\n    if (TIFFGetField(tiff,TIFFTAG_WHITEPOINT,&chromaticity) == 1)\n      {\n        if (chromaticity != (float *) NULL)\n          {\n            image->chromaticity.white_point.x=chromaticity[0];\n            image->chromaticity.white_point.y=chromaticity[1];\n          }\n      }\n    if (TIFFGetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,&chromaticity) == 1)\n      {\n        if (chromaticity != (float *) NULL)\n          {\n            image->chromaticity.red_primary.x=chromaticity[0];\n            image->chromaticity.red_primary.y=chromaticity[1];\n            image->chromaticity.green_primary.x=chromaticity[2];\n            image->chromaticity.green_primary.y=chromaticity[3];\n            image->chromaticity.blue_primary.x=chromaticity[4];\n            image->chromaticity.blue_primary.y=chromaticity[5];\n          }\n      }\n#if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION > 20040919)\n    if ((compress_tag != COMPRESSION_NONE) &&\n        (TIFFIsCODECConfigured(compress_tag) == 0))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CoderError,\"CompressNotSupported\");\n      }\n#endif\n    switch (compress_tag)\n    {\n      case COMPRESSION_NONE: image->compression=NoCompression; break;\n      case COMPRESSION_CCITTFAX3: image->compression=FaxCompression; break;\n      case COMPRESSION_CCITTFAX4: image->compression=Group4Compression; break;\n      case COMPRESSION_JPEG:\n      {\n         image->compression=JPEGCompression;\n#if defined(JPEG_SUPPORT)\n         {\n           char\n             sampling_factor[MagickPathExtent];\n\n           int\n             tiff_status;\n\n           uint16\n             horizontal,\n             vertical;\n\n           tiff_status=TIFFGetFieldDefaulted(tiff,TIFFTAG_YCBCRSUBSAMPLING,\n             &horizontal,&vertical);\n           if (tiff_status == 1)\n             {\n               (void) FormatLocaleString(sampling_factor,MagickPathExtent,\n                 \"%dx%d\",horizontal,vertical);\n               (void) SetImageProperty(image,\"jpeg:sampling-factor\",\n                 sampling_factor,exception);\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"Sampling Factors: %s\",sampling_factor);\n             }\n         }\n#endif\n        break;\n      }\n      case COMPRESSION_OJPEG: image->compression=JPEGCompression; break;\n#if defined(COMPRESSION_LZMA)\n      case COMPRESSION_LZMA: image->compression=LZMACompression; break;\n#endif\n      case COMPRESSION_LZW: image->compression=LZWCompression; break;\n      case COMPRESSION_DEFLATE: image->compression=ZipCompression; break;\n      case COMPRESSION_ADOBE_DEFLATE: image->compression=ZipCompression; break;\n      default: image->compression=RLECompression; break;\n    }\n    /*\n      Allocate memory for the image and pixel buffer.\n    */\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    if (sample_format == SAMPLEFORMAT_UINT)\n      status=SetQuantumFormat(image,quantum_info,UnsignedQuantumFormat);\n    if (sample_format == SAMPLEFORMAT_INT)\n      status=SetQuantumFormat(image,quantum_info,SignedQuantumFormat);\n    if (sample_format == SAMPLEFORMAT_IEEEFP)\n      status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    status=MagickTrue;\n    switch (photometric)\n    {\n      case PHOTOMETRIC_MINISBLACK:\n      {\n        quantum_info->min_is_white=MagickFalse;\n        break;\n      }\n      case PHOTOMETRIC_MINISWHITE:\n      {\n        quantum_info->min_is_white=MagickTrue;\n        break;\n      }\n      default:\n        break;\n    }\n    tiff_status=TIFFGetFieldDefaulted(tiff,TIFFTAG_EXTRASAMPLES,&extra_samples,\n      &sample_info);\n    if (tiff_status == 1)\n      {\n        (void) SetImageProperty(image,\"tiff:alpha\",\"unspecified\",exception);\n        if (extra_samples == 0)\n          {\n            if ((samples_per_pixel == 4) && (photometric == PHOTOMETRIC_RGB))\n              image->alpha_trait=BlendPixelTrait;\n          }\n        else\n          for (i=0; i < extra_samples; i++)\n          {\n            image->alpha_trait=BlendPixelTrait;\n            if (sample_info[i] == EXTRASAMPLE_ASSOCALPHA)\n              {\n                SetQuantumAlphaType(quantum_info,DisassociatedQuantumAlpha);\n                (void) SetImageProperty(image,\"tiff:alpha\",\"associated\",\n                  exception);\n              }\n            else\n              if (sample_info[i] == EXTRASAMPLE_UNASSALPHA)\n                (void) SetImageProperty(image,\"tiff:alpha\",\"unassociated\",\n                  exception);\n          }\n      }\n    if ((photometric == PHOTOMETRIC_PALETTE) &&\n        (pow(2.0,1.0*bits_per_sample) <= MaxColormapSize))\n      {\n        size_t\n          colors;\n\n        colors=(size_t) GetQuantumRange(bits_per_sample)+1;\n        if (AcquireImageColormap(image,colors,exception) == MagickFalse)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n      }\n    value=(unsigned short) image->scene;\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_PAGENUMBER,&value,&pages) == 1)\n      image->scene=value;\n    if (image->storage_class == PseudoClass)\n      {\n        int\n          tiff_status;\n\n        size_t\n          range;\n\n        uint16\n          *blue_colormap,\n          *green_colormap,\n          *red_colormap;\n\n        /*\n          Initialize colormap.\n        */\n        tiff_status=TIFFGetField(tiff,TIFFTAG_COLORMAP,&red_colormap,\n          &green_colormap,&blue_colormap);\n        if (tiff_status == 1)\n          {\n            if ((red_colormap != (uint16 *) NULL) &&\n                (green_colormap != (uint16 *) NULL) &&\n                (blue_colormap != (uint16 *) NULL))\n              {\n                range=255;  /* might be old style 8-bit colormap */\n                for (i=0; i < (ssize_t) image->colors; i++)\n                  if ((red_colormap[i] >= 256) || (green_colormap[i] >= 256) ||\n                      (blue_colormap[i] >= 256))\n                    {\n                      range=65535;\n                      break;\n                    }\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  image->colormap[i].red=ClampToQuantum(((double)\n                    QuantumRange*red_colormap[i])/range);\n                  image->colormap[i].green=ClampToQuantum(((double)\n                    QuantumRange*green_colormap[i])/range);\n                  image->colormap[i].blue=ClampToQuantum(((double)\n                    QuantumRange*blue_colormap[i])/range);\n                }\n              }\n          }\n        if (image->alpha_trait == UndefinedPixelTrait)\n          image->depth=GetImageDepth(image,exception);\n      }\n    if (image_info->ping != MagickFalse)\n      {\n        if (image_info->number_scenes != 0)\n          if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n            {\n              quantum_info=DestroyQuantumInfo(quantum_info);\n              break;\n            }\n        goto next_tiff_frame;\n      }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    method=ReadGenericMethod;\n    if (TIFFGetField(tiff,TIFFTAG_ROWSPERSTRIP,&rows_per_strip) == 1)\n      {\n        char\n          value[MagickPathExtent];\n\n        method=ReadStripMethod;\n        (void) FormatLocaleString(value,MagickPathExtent,\"%u\",\n          (unsigned int) rows_per_strip);\n        (void) SetImageProperty(image,\"tiff:rows-per-strip\",value,exception);\n      }\n    if ((samples_per_pixel >= 2) && (interlace == PLANARCONFIG_CONTIG))\n      method=ReadRGBAMethod;\n    if ((samples_per_pixel >= 2) && (interlace == PLANARCONFIG_SEPARATE))\n      method=ReadCMYKAMethod;\n    if ((photometric != PHOTOMETRIC_RGB) &&\n        (photometric != PHOTOMETRIC_CIELAB) &&\n        (photometric != PHOTOMETRIC_SEPARATED))\n      method=ReadGenericMethod;\n    if (image->storage_class == PseudoClass)\n      method=ReadSingleSampleMethod;\n    if ((photometric == PHOTOMETRIC_MINISBLACK) ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      method=ReadSingleSampleMethod;\n    if ((photometric != PHOTOMETRIC_SEPARATED) &&\n        (interlace == PLANARCONFIG_SEPARATE) && (bits_per_sample < 64))\n      method=ReadGenericMethod;\n    if (image->compression == JPEGCompression)\n      method=GetJPEGMethod(image,tiff,photometric,bits_per_sample,\n        samples_per_pixel);\n    if (compress_tag == COMPRESSION_JBIG)\n      method=ReadStripMethod;\n    if (TIFFIsTiled(tiff) != MagickFalse)\n      method=ReadTileMethod;\n    quantum_info->endian=LSBEndian;\n    quantum_type=RGBQuantum;\n    pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n    switch (method)\n    {\n      case ReadSingleSampleMethod:\n      {\n        /*\n          Convert TIFF image to PseudoClass MIFF image.\n        */\n        quantum_type=IndexQuantum;\n        pad=(size_t) MagickMax((size_t) samples_per_pixel-1,0);\n        if (image->alpha_trait != UndefinedPixelTrait)\n          {\n            if (image->storage_class != PseudoClass)\n              {\n                quantum_type=samples_per_pixel == 1 ? AlphaQuantum :\n                  GrayAlphaQuantum;\n                pad=(size_t) MagickMax((size_t) samples_per_pixel-2,0);\n              }\n            else\n              {\n                quantum_type=IndexAlphaQuantum;\n                pad=(size_t) MagickMax((size_t) samples_per_pixel-2,0);\n              }\n          }\n        else\n          if (image->storage_class != PseudoClass)\n            {\n              quantum_type=GrayQuantum;\n              pad=(size_t) MagickMax((size_t) samples_per_pixel-1,0);\n            }\n        status=SetQuantumPad(image,quantum_info,pad*pow(2,ceil(log(\n          bits_per_sample)/log(2))));\n        if (status == MagickFalse)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          int\n            status;\n\n          register Quantum\n            *magick_restrict q;\n\n          status=TIFFReadPixels(tiff,bits_per_sample,0,y,(char *) pixels);\n          if (status == -1)\n            break;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case ReadRGBAMethod:\n      {\n        /*\n          Convert TIFF image to DirectClass MIFF image.\n        */\n        pad=(size_t) MagickMax((size_t) samples_per_pixel-3,0);\n        quantum_type=RGBQuantum;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          {\n            quantum_type=RGBAQuantum;\n            pad=(size_t) MagickMax((size_t) samples_per_pixel-4,0);\n          }\n        if (image->colorspace == CMYKColorspace)\n          {\n            pad=(size_t) MagickMax((size_t) samples_per_pixel-4,0);\n            quantum_type=CMYKQuantum;\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                quantum_type=CMYKAQuantum;\n                pad=(size_t) MagickMax((size_t) samples_per_pixel-5,0);\n              }\n          }\n        status=SetQuantumPad(image,quantum_info,pad*((bits_per_sample+7) >> 3));\n        if (status == MagickFalse)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          int\n            status;\n\n          register Quantum\n            *magick_restrict q;\n\n          status=TIFFReadPixels(tiff,bits_per_sample,0,y,(char *) pixels);\n          if (status == -1)\n            break;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case ReadCMYKAMethod:\n      {\n        /*\n          Convert TIFF image to DirectClass MIFF image.\n        */\n        for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            register Quantum\n              *magick_restrict q;\n\n            int\n              status;\n\n            status=TIFFReadPixels(tiff,bits_per_sample,(tsample_t) i,y,(char *)\n              pixels);\n            if (status == -1)\n              break;\n            q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            if (image->colorspace != CMYKColorspace)\n              switch (i)\n              {\n                case 0: quantum_type=RedQuantum; break;\n                case 1: quantum_type=GreenQuantum; break;\n                case 2: quantum_type=BlueQuantum; break;\n                case 3: quantum_type=AlphaQuantum; break;\n                default: quantum_type=UndefinedQuantum; break;\n              }\n            else\n              switch (i)\n              {\n                case 0: quantum_type=CyanQuantum; break;\n                case 1: quantum_type=MagentaQuantum; break;\n                case 2: quantum_type=YellowQuantum; break;\n                case 3: quantum_type=BlackQuantum; break;\n                case 4: quantum_type=AlphaQuantum; break;\n                default: quantum_type=UndefinedQuantum; break;\n              }\n            (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n              quantum_type,pixels,exception);\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n          }\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case ReadYCCKMethod:\n      {\n        pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          int\n            status;\n\n          register Quantum\n            *magick_restrict q;\n\n          register ssize_t\n            x;\n\n          unsigned char\n            *p;\n\n          status=TIFFReadPixels(tiff,bits_per_sample,0,y,(char *) pixels);\n          if (status == -1)\n            break;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          p=pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelCyan(image,ScaleCharToQuantum(ClampYCC((double) *p+\n              (1.402*(double) *(p+2))-179.456)),q);\n            SetPixelMagenta(image,ScaleCharToQuantum(ClampYCC((double) *p-\n              (0.34414*(double) *(p+1))-(0.71414*(double ) *(p+2))+\n              135.45984)),q);\n            SetPixelYellow(image,ScaleCharToQuantum(ClampYCC((double) *p+\n              (1.772*(double) *(p+1))-226.816)),q);\n            SetPixelBlack(image,ScaleCharToQuantum((unsigned char) *(p+3)),q);\n            q+=GetPixelChannels(image);\n            p+=4;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case ReadStripMethod:\n      {\n        register uint32\n          *p;\n\n        /*\n          Convert stripped TIFF image to DirectClass MIFF image.\n        */\n        i=0;\n        p=(uint32 *) NULL;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register ssize_t\n            x;\n\n          register Quantum\n            *magick_restrict q;\n\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          if (i == 0)\n            {\n              if (TIFFReadRGBAStrip(tiff,(tstrip_t) y,(uint32 *) pixels) == 0)\n                break;\n              i=(ssize_t) MagickMin((ssize_t) rows_per_strip,(ssize_t)\n                image->rows-y);\n            }\n          i--;\n          p=((uint32 *) pixels)+image->columns*i;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n              (TIFFGetR(*p))),q);\n            SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n              (TIFFGetG(*p))),q);\n            SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n              (TIFFGetB(*p))),q);\n            if (image->alpha_trait != UndefinedPixelTrait)\n              SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)\n                (TIFFGetA(*p))),q);\n            p++;\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case ReadTileMethod:\n      {\n        register uint32\n          *p;\n\n        uint32\n          *tile_pixels,\n          columns,\n          rows;\n\n        /*\n          Convert tiled TIFF image to DirectClass MIFF image.\n        */\n        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||\n            (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(CoderError,\"ImageIsNotTiled\");\n          }\n        (void) SetImageStorageClass(image,DirectClass,exception);\n        number_pixels=(MagickSizeType) columns*rows;\n        if (HeapOverflowSanityCheck(rows,sizeof(*tile_pixels)) != MagickFalse)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        tile_pixels=(uint32 *) AcquireQuantumMemory(columns,rows*\n          sizeof(*tile_pixels));\n        if (tile_pixels == (uint32 *) NULL)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        for (y=0; y < (ssize_t) image->rows; y+=rows)\n        {\n          register ssize_t\n            x;\n\n          register Quantum\n            *magick_restrict q,\n            *magick_restrict tile;\n\n          size_t\n            columns_remaining,\n            rows_remaining;\n\n          rows_remaining=image->rows-y;\n          if ((ssize_t) (y+rows) < (ssize_t) image->rows)\n            rows_remaining=rows;\n          tile=QueueAuthenticPixels(image,0,y,image->columns,rows_remaining,\n            exception);\n          if (tile == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x+=columns)\n          {\n            size_t\n              column,\n              row;\n\n            if (TIFFReadRGBATile(tiff,(uint32) x,(uint32) y,tile_pixels) == 0)\n              break;\n            columns_remaining=image->columns-x;\n            if ((ssize_t) (x+columns) < (ssize_t) image->columns)\n              columns_remaining=columns;\n            p=tile_pixels+(rows-rows_remaining)*columns;\n            q=tile+GetPixelChannels(image)*(image->columns*(rows_remaining-1)+\n              x);\n            for (row=rows_remaining; row > 0; row--)\n            {\n              if (image->alpha_trait != UndefinedPixelTrait)\n                for (column=columns_remaining; column > 0; column--)\n                {\n                  SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n                    TIFFGetR(*p)),q);\n                  SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n                    TIFFGetG(*p)),q);\n                  SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n                    TIFFGetB(*p)),q);\n                  SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)\n                    TIFFGetA(*p)),q);\n                  p++;\n                  q+=GetPixelChannels(image);\n                }\n              else\n                for (column=columns_remaining; column > 0; column--)\n                {\n                  SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n                    TIFFGetR(*p)),q);\n                  SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n                    TIFFGetG(*p)),q);\n                  SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n                    TIFFGetB(*p)),q);\n                  p++;\n                  q+=GetPixelChannels(image);\n                }\n              p+=columns-columns_remaining;\n              q-=GetPixelChannels(image)*(image->columns+columns_remaining);\n            }\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        tile_pixels=(uint32 *) RelinquishMagickMemory(tile_pixels);\n        break;\n      }\n      case ReadGenericMethod:\n      default:\n      {\n        MemoryInfo\n          *pixel_info;\n\n        register uint32\n          *p;\n\n        uint32\n          *pixels;\n\n        /*\n          Convert TIFF image to DirectClass MIFF image.\n        */\n        number_pixels=(MagickSizeType) image->columns*image->rows;\n        if (HeapOverflowSanityCheck(image->rows,sizeof(*pixels)) != MagickFalse)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        pixel_info=AcquireVirtualMemory(image->columns,image->rows*\n          sizeof(uint32));\n        if (pixel_info == (MemoryInfo *) NULL)\n          {\n            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        pixels=(uint32 *) GetVirtualMemoryBlob(pixel_info);\n        (void) TIFFReadRGBAImage(tiff,(uint32) image->columns,(uint32)\n          image->rows,(uint32 *) pixels,0);\n        /*\n          Convert image to DirectClass pixel packets.\n        */\n        p=pixels+number_pixels-1;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register ssize_t\n            x;\n\n          register Quantum\n            *magick_restrict q;\n\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          q+=GetPixelChannels(image)*(image->columns-1);\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n              TIFFGetR(*p)),q);\n            SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n              TIFFGetG(*p)),q);\n            SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n              TIFFGetB(*p)),q);\n            if (image->alpha_trait != UndefinedPixelTrait)\n              SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)\n                TIFFGetA(*p)),q);\n            p--;\n            q-=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        pixel_info=RelinquishVirtualMemory(pixel_info);\n        break;\n      }\n    }\n    SetQuantumImageType(image,quantum_type);\n  next_tiff_frame:\n    quantum_info=DestroyQuantumInfo(quantum_info);\n    if (photometric == PHOTOMETRIC_CIELAB)\n      DecodeLabImage(image,exception);\n    if ((photometric == PHOTOMETRIC_LOGL) ||\n        (photometric == PHOTOMETRIC_MINISBLACK) ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      {\n        image->type=GrayscaleType;\n        if (bits_per_sample == 1)\n          image->type=BilevelType;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;\n    if (status != MagickFalse)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,image->scene-1,\n          image->scene);\n        if (status == MagickFalse)\n          break;\n      }\n  } while (status != MagickFalse);\n  TIFFClose(tiff);\n  TIFFReadPhotoshopLayers(image,image_info,exception);\n  if (image_info->number_scenes != 0)\n    {\n      if (image_info->scene >= GetImageListLength(image))\n        {\n          /* Subimage was not found in the Photoshop layer */\n          image=DestroyImageList(image);\n          return((Image *)NULL);\n        }\n    }\n  return(GetFirstImageInList(image));\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r T I F F I m a g e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterTIFFImage() adds properties for the TIFF image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterTIFFImage method is:\n%\n%      size_t RegisterTIFFImage(void)\n%\n*/\n\n#if defined(MAGICKCORE_HAVE_TIFFMERGEFIELDINFO) && defined(MAGICKCORE_HAVE_TIFFSETTAGEXTENDER)\nstatic TIFFExtendProc\n  tag_extender = (TIFFExtendProc) NULL;\n\nstatic void TIFFIgnoreTags(TIFF *tiff)\n{\n  char\n    *q;\n\n  const char\n    *p,\n    *tags;\n\n  Image\n   *image;\n\n  register ssize_t\n    i;\n\n  size_t\n    count;\n\n  TIFFFieldInfo\n    *ignore;\n\n  if (TIFFGetReadProc(tiff) != TIFFReadBlob)\n    return;\n  image=(Image *)TIFFClientdata(tiff);\n  tags=GetImageArtifact(image,\"tiff:ignore-tags\");\n  if (tags == (const char *) NULL)\n    return;\n  count=0;\n  p=tags;\n  while (*p != '\\0')\n  {\n    while ((isspace((int) ((unsigned char) *p)) != 0))\n      p++;\n\n    (void) strtol(p,&q,10);\n    if (p == q)\n      return;\n\n    p=q;\n    count++;\n\n    while ((isspace((int) ((unsigned char) *p)) != 0) || (*p == ','))\n      p++;\n  }\n  if (count == 0)\n    return;\n  i=0;\n  p=tags;\n  ignore=(TIFFFieldInfo *) AcquireQuantumMemory(count,sizeof(*ignore));\n  /* This also sets field_bit to 0 (FIELD_IGNORE) */\n  ResetMagickMemory(ignore,0,count*sizeof(*ignore));\n  while (*p != '\\0')\n  {\n    while ((isspace((int) ((unsigned char) *p)) != 0))\n      p++;\n\n    ignore[i].field_tag=(ttag_t) strtol(p,&q,10);\n\n    p=q;\n    i++;\n\n    while ((isspace((int) ((unsigned char) *p)) != 0) || (*p == ','))\n      p++;\n  }\n  (void) TIFFMergeFieldInfo(tiff,ignore,(uint32) count);\n  ignore=(TIFFFieldInfo *) RelinquishMagickMemory(ignore);\n}\n\nstatic void TIFFTagExtender(TIFF *tiff)\n{\n  static const TIFFFieldInfo\n    TIFFExtensions[] =\n    {\n      { 37724, -3, -3, TIFF_UNDEFINED, FIELD_CUSTOM, 1, 1,\n        (char *) \"PhotoshopLayerData\" },\n      { 34118, -3, -3, TIFF_UNDEFINED, FIELD_CUSTOM, 1, 1,\n        (char *) \"Microscope\" }\n    };\n\n  TIFFMergeFieldInfo(tiff,TIFFExtensions,sizeof(TIFFExtensions)/\n    sizeof(*TIFFExtensions));\n  if (tag_extender != (TIFFExtendProc) NULL)\n    (*tag_extender)(tiff);\n  TIFFIgnoreTags(tiff);\n}\n#endif\n\nModuleExport size_t RegisterTIFFImage(void)\n{\n#define TIFFDescription  \"Tagged Image File Format\"\n\n  char\n    version[MagickPathExtent];\n\n  MagickInfo\n    *entry;\n\n  if (tiff_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&tiff_semaphore);\n  LockSemaphoreInfo(tiff_semaphore);\n  if (instantiate_key == MagickFalse)\n    {\n      if (CreateMagickThreadKey(&tiff_exception,NULL) == MagickFalse)\n        ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n      error_handler=TIFFSetErrorHandler(TIFFErrors);\n      warning_handler=TIFFSetWarningHandler(TIFFWarnings);\n#if defined(MAGICKCORE_HAVE_TIFFMERGEFIELDINFO) && defined(MAGICKCORE_HAVE_TIFFSETTAGEXTENDER)\n      if (tag_extender == (TIFFExtendProc) NULL)\n        tag_extender=TIFFSetTagExtender(TIFFTagExtender);\n#endif\n      instantiate_key=MagickTrue;\n    }\n  UnlockSemaphoreInfo(tiff_semaphore);\n  *version='\\0';\n#if defined(TIFF_VERSION)\n  (void) FormatLocaleString(version,MagickPathExtent,\"%d\",TIFF_VERSION);\n#endif\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  {\n    const char\n      *p;\n\n    register ssize_t\n      i;\n\n    p=TIFFGetVersion();\n    for (i=0; (i < (MagickPathExtent-1)) && (*p != 0) && (*p != '\\n'); i++)\n      version[i]=(*p++);\n    version[i]='\\0';\n  }\n#endif\n\n  entry=AcquireMagickInfo(\"TIFF\",\"GROUP4\",\"Raw CCITT Group4\");\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadGROUP4Image;\n  entry->encoder=(EncodeImageHandler *) WriteGROUP4Image;\n#endif\n  entry->flags|=CoderRawSupportFlag;\n  entry->flags|=CoderEndianSupportFlag;\n  entry->flags|=CoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  entry->format_type=ImplicitFormatType;\n  entry->mime_type=ConstantString(\"image/tiff\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TIFF\",\"PTIF\",\"Pyramid encoded TIFF\");\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadTIFFImage;\n  entry->encoder=(EncodeImageHandler *) WritePTIFImage;\n#endif\n  entry->flags|=CoderEndianSupportFlag;\n  entry->flags|=CoderSeekableStreamFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  entry->mime_type=ConstantString(\"image/tiff\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TIFF\",\"TIF\",TIFFDescription);\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadTIFFImage;\n  entry->encoder=(EncodeImageHandler *) WriteTIFFImage;\n#endif\n  entry->flags|=CoderEndianSupportFlag;\n  entry->flags|=CoderSeekableStreamFlag;\n  entry->flags|=CoderStealthFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/tiff\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TIFF\",\"TIFF\",TIFFDescription);\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadTIFFImage;\n  entry->encoder=(EncodeImageHandler *) WriteTIFFImage;\n#endif\n  entry->magick=(IsImageFormatHandler *) IsTIFF;\n  entry->flags|=CoderEndianSupportFlag;\n  entry->flags|=CoderSeekableStreamFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/tiff\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TIFF\",\"TIFF64\",\"Tagged Image File Format (64-bit)\");\n#if defined(TIFF_VERSION_BIG)\n  entry->decoder=(DecodeImageHandler *) ReadTIFFImage;\n  entry->encoder=(EncodeImageHandler *) WriteTIFFImage;\n#endif\n  entry->flags|=CoderEndianSupportFlag;\n  entry->flags|=CoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/tiff\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r T I F F I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterTIFFImage() removes format registrations made by the TIFF module\n%  from the list of supported formats.\n%\n%  The format of the UnregisterTIFFImage method is:\n%\n%      UnregisterTIFFImage(void)\n%\n*/\nModuleExport void UnregisterTIFFImage(void)\n{\n  (void) UnregisterMagickInfo(\"TIFF64\");\n  (void) UnregisterMagickInfo(\"TIFF\");\n  (void) UnregisterMagickInfo(\"TIF\");\n  (void) UnregisterMagickInfo(\"PTIF\");\n  if (tiff_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&tiff_semaphore);\n  LockSemaphoreInfo(tiff_semaphore);\n  if (instantiate_key != MagickFalse)\n    {\n#if defined(MAGICKCORE_HAVE_TIFFMERGEFIELDINFO) && defined(MAGICKCORE_HAVE_TIFFSETTAGEXTENDER)\n      if (tag_extender == (TIFFExtendProc) NULL)\n        (void) TIFFSetTagExtender(tag_extender);\n#endif\n      if (DeleteMagickThreadKey(tiff_exception) == MagickFalse)\n        ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n      (void) TIFFSetWarningHandler(warning_handler);\n      (void) TIFFSetErrorHandler(error_handler);\n      instantiate_key=MagickFalse;\n    }\n  UnlockSemaphoreInfo(tiff_semaphore);\n  RelinquishSemaphoreInfo(&tiff_semaphore);\n}\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e G R O U P 4 I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteGROUP4Image() writes an image in the raw CCITT Group 4 image format.\n%\n%  The format of the WriteGROUP4Image method is:\n%\n%      MagickBooleanType WriteGROUP4Image(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteGROUP4Image(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n\n  FILE\n    *file;\n\n  Image\n    *huffman_image;\n\n  ImageInfo\n    *write_info;\n\n  int\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count;\n\n  TIFF\n    *tiff;\n\n  toff_t\n    *byte_count,\n    strip_size;\n\n  unsigned char\n    *buffer;\n\n  /*\n    Write image as CCITT Group4 TIFF image to a temporary file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  huffman_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (huffman_image == (Image *) NULL)\n    {\n      (void) CloseBlob(image);\n      return(MagickFalse);\n    }\n  huffman_image->endian=MSBEndian;\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"wb\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        filename);\n      return(MagickFalse);\n    }\n  (void) FormatLocaleString(huffman_image->filename,MagickPathExtent,\"tiff:%s\",\n    filename);\n  (void) SetImageType(huffman_image,BilevelType,exception);\n  write_info=CloneImageInfo((ImageInfo *) NULL);\n  SetImageInfoFile(write_info,file);\n  (void) SetImageDepth(image,1,exception);\n  (void) SetImageType(image,BilevelType,exception);\n  write_info->compression=Group4Compression;\n  write_info->type=BilevelType;\n  (void) SetImageOption(write_info,\"quantum:polarity\",\"min-is-white\");\n  status=WriteTIFFImage(write_info,huffman_image,exception);\n  (void) fflush(file);\n  write_info=DestroyImageInfo(write_info);\n  if (status == MagickFalse)\n    {\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      return(MagickFalse);\n    }\n  tiff=TIFFOpen(filename,\"rb\");\n  if (tiff == (TIFF *) NULL)\n    {\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n        image_info->filename);\n      return(MagickFalse);\n    }\n  /*\n    Allocate raw strip buffer.\n  */\n  if (TIFFGetField(tiff,TIFFTAG_STRIPBYTECOUNTS,&byte_count) != 1)\n    {\n      TIFFClose(tiff);\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      return(MagickFalse);\n    }\n  strip_size=byte_count[0];\n  for (i=1; i < (ssize_t) TIFFNumberOfStrips(tiff); i++)\n    if (byte_count[i] > strip_size)\n      strip_size=byte_count[i];\n  buffer=(unsigned char *) AcquireQuantumMemory((size_t) strip_size,\n    sizeof(*buffer));\n  if (buffer == (unsigned char *) NULL)\n    {\n      TIFFClose(tiff);\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);\n      (void) RelinquishUniqueFileResource(filename);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image_info->filename);\n    }\n  /*\n    Compress runlength encoded to 2D Huffman pixels.\n  */\n  for (i=0; i < (ssize_t) TIFFNumberOfStrips(tiff); i++)\n  {\n    count=(ssize_t) TIFFReadRawStrip(tiff,(uint32) i,buffer,strip_size);\n    if (WriteBlob(image,(size_t) count,buffer) != count)\n      status=MagickFalse;\n  }\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  TIFFClose(tiff);\n  huffman_image=DestroyImage(huffman_image);\n  (void) fclose(file);\n  (void) RelinquishUniqueFileResource(filename);\n  (void) CloseBlob(image);\n  return(status);\n}\n#endif\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e P T I F I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WritePTIFImage() writes an image in the pyrimid-encoded Tagged image file\n%  format.\n%\n%  The format of the WritePTIFImage method is:\n%\n%      MagickBooleanType WritePTIFImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WritePTIFImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  Image\n    *images,\n    *next,\n    *pyramid_image;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    status;\n\n  PointInfo\n    resolution;\n\n  size_t\n    columns,\n    rows;\n\n  /*\n    Create pyramid-encoded TIFF image.\n  */\n  images=NewImageList();\n  for (next=image; next != (Image *) NULL; next=GetNextImageInList(next))\n  {\n    Image\n      *clone_image;\n\n    clone_image=CloneImage(next,0,0,MagickFalse,exception);\n    if (clone_image == (Image *) NULL)\n      break;\n    clone_image->previous=NewImageList();\n    clone_image->next=NewImageList();\n    (void) SetImageProperty(clone_image,\"tiff:subfiletype\",\"none\",exception);\n    AppendImageToList(&images,clone_image);\n    columns=next->columns;\n    rows=next->rows;\n    resolution=next->resolution;\n    while ((columns > 64) && (rows > 64))\n    {\n      columns/=2;\n      rows/=2;\n      resolution.x/=2;\n      resolution.y/=2;\n      pyramid_image=ResizeImage(next,columns,rows,image->filter,exception);\n      if (pyramid_image == (Image *) NULL)\n        break;\n      pyramid_image->resolution=resolution;\n      (void) SetImageProperty(pyramid_image,\"tiff:subfiletype\",\"REDUCEDIMAGE\",\n        exception);\n      AppendImageToList(&images,pyramid_image);\n    }\n  }\n  images=GetFirstImageInList(images);\n  /*\n    Write pyramid-encoded TIFF image.\n  */\n  write_info=CloneImageInfo(image_info);\n  write_info->adjoin=MagickTrue;\n  (void) CopyMagickString(write_info->magick,\"TIFF\",MagickPathExtent);\n  (void) CopyMagickString(images->magick,\"TIFF\",MagickPathExtent);\n  status=WriteTIFFImage(write_info,images,exception);\n  images=DestroyImageList(images);\n  write_info=DestroyImageInfo(write_info);\n  return(status);\n}\n#endif\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%   W r i t e T I F F I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteTIFFImage() writes an image in the Tagged image file format.\n%\n%  The format of the WriteTIFFImage method is:\n%\n%      MagickBooleanType WriteTIFFImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\ntypedef struct _TIFFInfo\n{\n  RectangleInfo\n    tile_geometry;\n\n  unsigned char\n    *scanline,\n    *scanlines,\n    *pixels;\n} TIFFInfo;\n\nstatic void DestroyTIFFInfo(TIFFInfo *tiff_info)\n{\n  assert(tiff_info != (TIFFInfo *) NULL);\n  if (tiff_info->scanlines != (unsigned char *) NULL)\n    tiff_info->scanlines=(unsigned char *) RelinquishMagickMemory(\n      tiff_info->scanlines);\n  if (tiff_info->pixels != (unsigned char *) NULL)\n    tiff_info->pixels=(unsigned char *) RelinquishMagickMemory(\n      tiff_info->pixels);\n}\n\nstatic MagickBooleanType EncodeLabImage(Image *image,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        a,\n        b;\n\n      a=QuantumScale*GetPixela(image,q)-0.5;\n      if (a < 0.0)\n        a+=1.0;\n      b=QuantumScale*GetPixelb(image,q)-0.5;\n      if (b < 0.0)\n        b+=1.0;\n      SetPixela(image,QuantumRange*a,q);\n      SetPixelb(image,QuantumRange*b,q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\nstatic MagickBooleanType GetTIFFInfo(const ImageInfo *image_info,\n  TIFF *tiff,TIFFInfo *tiff_info)\n{\n  const char\n    *option;\n\n  MagickStatusType\n    flags;\n\n  uint32\n    tile_columns,\n    tile_rows;\n\n  assert(tiff_info != (TIFFInfo *) NULL);\n  (void) ResetMagickMemory(tiff_info,0,sizeof(*tiff_info));\n  option=GetImageOption(image_info,\"tiff:tile-geometry\");\n  if (option == (const char *) NULL)\n    return(MagickTrue);\n  flags=ParseAbsoluteGeometry(option,&tiff_info->tile_geometry);\n  if ((flags & HeightValue) == 0)\n    tiff_info->tile_geometry.height=tiff_info->tile_geometry.width;\n  tile_columns=(uint32) tiff_info->tile_geometry.width;\n  tile_rows=(uint32) tiff_info->tile_geometry.height;\n  TIFFDefaultTileSize(tiff,&tile_columns,&tile_rows);\n  (void) TIFFSetField(tiff,TIFFTAG_TILEWIDTH,tile_columns);\n  (void) TIFFSetField(tiff,TIFFTAG_TILELENGTH,tile_rows);\n  tiff_info->tile_geometry.width=tile_columns;\n  tiff_info->tile_geometry.height=tile_rows;\n  tiff_info->scanlines=(unsigned char *) AcquireQuantumMemory((size_t)\n    tile_rows*TIFFScanlineSize(tiff),sizeof(*tiff_info->scanlines));\n  tiff_info->pixels=(unsigned char *) AcquireQuantumMemory((size_t)\n    tile_rows*TIFFTileSize(tiff),sizeof(*tiff_info->scanlines));\n  if ((tiff_info->scanlines == (unsigned char *) NULL) ||\n      (tiff_info->pixels == (unsigned char *) NULL))\n    {\n      DestroyTIFFInfo(tiff_info);\n      return(MagickFalse);\n    }\n  return(MagickTrue);\n}\n\nstatic int32 TIFFWritePixels(TIFF *tiff,TIFFInfo *tiff_info,ssize_t row,\n  tsample_t sample,Image *image)\n{\n  int32\n    status;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p,\n    *q;\n\n  size_t\n    number_tiles,\n    tile_width;\n\n  ssize_t\n    bytes_per_pixel,\n    j,\n    k,\n    l;\n\n  if (TIFFIsTiled(tiff) == 0)\n    return(TIFFWriteScanline(tiff,tiff_info->scanline,(uint32) row,sample));\n  /*\n    Fill scanlines to tile height.\n  */\n  i=(ssize_t) (row % tiff_info->tile_geometry.height)*TIFFScanlineSize(tiff);\n  (void) CopyMagickMemory(tiff_info->scanlines+i,(char *) tiff_info->scanline,\n    (size_t) TIFFScanlineSize(tiff));\n  if (((size_t) (row % tiff_info->tile_geometry.height) !=\n      (tiff_info->tile_geometry.height-1)) &&\n      (row != (ssize_t) (image->rows-1)))\n    return(0);\n  /*\n    Write tile to TIFF image.\n  */\n  status=0;\n  bytes_per_pixel=TIFFTileSize(tiff)/(ssize_t) (\n    tiff_info->tile_geometry.height*tiff_info->tile_geometry.width);\n  number_tiles=(image->columns+tiff_info->tile_geometry.width)/\n    tiff_info->tile_geometry.width;\n  for (i=0; i < (ssize_t) number_tiles; i++)\n  {\n    tile_width=(i == (ssize_t) (number_tiles-1)) ? image->columns-(i*\n      tiff_info->tile_geometry.width) : tiff_info->tile_geometry.width;\n    for (j=0; j < (ssize_t) ((row % tiff_info->tile_geometry.height)+1); j++)\n      for (k=0; k < (ssize_t) tile_width; k++)\n      {\n        if (bytes_per_pixel == 0)\n          {\n            p=tiff_info->scanlines+(j*TIFFScanlineSize(tiff)+(i*\n              tiff_info->tile_geometry.width+k)/8);\n            q=tiff_info->pixels+(j*TIFFTileRowSize(tiff)+k/8);\n            *q++=(*p++);\n            continue;\n          }\n        p=tiff_info->scanlines+(j*TIFFScanlineSize(tiff)+(i*\n          tiff_info->tile_geometry.width+k)*bytes_per_pixel);\n        q=tiff_info->pixels+(j*TIFFTileRowSize(tiff)+k*bytes_per_pixel);\n        for (l=0; l < bytes_per_pixel; l++)\n          *q++=(*p++);\n      }\n    if ((i*tiff_info->tile_geometry.width) != image->columns)\n      status=TIFFWriteTile(tiff,tiff_info->pixels,(uint32) (i*\n        tiff_info->tile_geometry.width),(uint32) ((row/\n        tiff_info->tile_geometry.height)*tiff_info->tile_geometry.height),0,\n        sample);\n    if (status < 0)\n      break;\n  }\n  return(status);\n}\n\nstatic void TIFFSetProfiles(TIFF *tiff,Image *image)\n{\n  const char\n    *name;\n\n  const StringInfo\n    *profile;\n\n  if (image->profiles == (void *) NULL)\n    return;\n  ResetImageProfileIterator(image);\n  for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n  {\n    profile=GetImageProfile(image,name);\n    if (GetStringInfoLength(profile) == 0)\n      {\n        name=GetNextImageProfile(image);\n        continue;\n      }\n#if defined(TIFFTAG_XMLPACKET)\n    if (LocaleCompare(name,\"xmp\") == 0)\n      (void) TIFFSetField(tiff,TIFFTAG_XMLPACKET,(uint32) GetStringInfoLength(\n        profile),GetStringInfoDatum(profile));\n#endif\n#if defined(TIFFTAG_ICCPROFILE)\n    if (LocaleCompare(name,\"icc\") == 0)\n      (void) TIFFSetField(tiff,TIFFTAG_ICCPROFILE,(uint32) GetStringInfoLength(\n        profile),GetStringInfoDatum(profile));\n#endif\n    if (LocaleCompare(name,\"iptc\") == 0)\n      {\n        size_t\n          length;\n\n        StringInfo\n          *iptc_profile;\n\n        iptc_profile=CloneStringInfo(profile);\n        length=GetStringInfoLength(profile)+4-(GetStringInfoLength(profile) &\n          0x03);\n        SetStringInfoLength(iptc_profile,length);\n        if (TIFFIsByteSwapped(tiff))\n          TIFFSwabArrayOfLong((uint32 *) GetStringInfoDatum(iptc_profile),\n            (unsigned long) (length/4));\n        (void) TIFFSetField(tiff,TIFFTAG_RICHTIFFIPTC,(uint32)\n          GetStringInfoLength(iptc_profile)/4,GetStringInfoDatum(iptc_profile));\n        iptc_profile=DestroyStringInfo(iptc_profile);\n      }\n#if defined(TIFFTAG_PHOTOSHOP)\n    if (LocaleCompare(name,\"8bim\") == 0)\n      (void) TIFFSetField(tiff,TIFFTAG_PHOTOSHOP,(uint32)\n        GetStringInfoLength(profile),GetStringInfoDatum(profile));\n#endif\n    if (LocaleCompare(name,\"tiff:37724\") == 0)\n      (void) TIFFSetField(tiff,37724,(uint32) GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n    if (LocaleCompare(name,\"tiff:34118\") == 0)\n      (void) TIFFSetField(tiff,34118,(uint32) GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n    name=GetNextImageProfile(image);\n  }\n}\n\nstatic void TIFFSetProperties(TIFF *tiff,const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  const char\n    *value;\n\n  value=GetImageArtifact(image,\"tiff:document\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_DOCUMENTNAME,value);\n  value=GetImageArtifact(image,\"tiff:hostcomputer\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_HOSTCOMPUTER,value);\n  value=GetImageArtifact(image,\"tiff:artist\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_ARTIST,value);\n  value=GetImageArtifact(image,\"tiff:timestamp\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_DATETIME,value);\n  value=GetImageArtifact(image,\"tiff:make\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_MAKE,value);\n  value=GetImageArtifact(image,\"tiff:model\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_MODEL,value);\n  value=GetImageArtifact(image,\"tiff:software\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_SOFTWARE,value);\n  value=GetImageArtifact(image,\"tiff:copyright\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_COPYRIGHT,value);\n  value=GetImageArtifact(image,\"kodak-33423\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,33423,value);\n  value=GetImageArtifact(image,\"kodak-36867\");\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,36867,value);\n  value=GetImageProperty(image,\"label\",exception);\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_PAGENAME,value);\n  value=GetImageProperty(image,\"comment\",exception);\n  if (value != (const char *) NULL)\n    (void) TIFFSetField(tiff,TIFFTAG_IMAGEDESCRIPTION,value);\n  value=GetImageArtifact(image,\"tiff:subfiletype\");\n  if (value != (const char *) NULL)\n    {\n      if (LocaleCompare(value,\"REDUCEDIMAGE\") == 0)\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_REDUCEDIMAGE);\n      else\n        if (LocaleCompare(value,\"PAGE\") == 0)\n          (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n        else\n          if (LocaleCompare(value,\"MASK\") == 0)\n            (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_MASK);\n    }\n  else\n    {\n      uint16\n        page,\n        pages;\n      \n      page=(uint16) image->scene;\n      pages=(uint16) GetImageListLength(image);\n      if ((image_info->adjoin != MagickFalse) && (pages > 1))\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n      (void) TIFFSetField(tiff,TIFFTAG_PAGENUMBER,page,pages);\n    }\n}\n\nstatic void TIFFSetEXIFProperties(TIFF *tiff,Image *image,\n  ExceptionInfo *exception)\n{\n#if defined(MAGICKCORE_HAVE_TIFFREADEXIFDIRECTORY)\n  const char\n    *value;\n\n  register ssize_t\n    i;\n\n  uint32\n    offset;\n\n  /*\n    Write EXIF properties.\n  */\n  offset=0;\n  (void) TIFFSetField(tiff,TIFFTAG_SUBIFD,1,&offset);\n  for (i=0; exif_info[i].tag != 0; i++)\n  {\n    value=GetImageProperty(image,exif_info[i].property,exception);\n    if (value == (const char *) NULL)\n      continue;\n    switch (exif_info[i].type)\n    {\n      case TIFF_ASCII:\n      {\n        (void) TIFFSetField(tiff,exif_info[i].tag,value);\n        break;\n      }\n      case TIFF_SHORT:\n      {\n        uint16\n          field;\n\n        field=(uint16) StringToLong(value);\n        (void) TIFFSetField(tiff,exif_info[i].tag,field);\n        break;\n      }\n      case TIFF_LONG:\n      {\n        uint16\n          field;\n\n        field=(uint16) StringToLong(value);\n        (void) TIFFSetField(tiff,exif_info[i].tag,field);\n        break;\n      }\n      case TIFF_RATIONAL:\n      case TIFF_SRATIONAL:\n      {\n        float\n          field;\n\n        field=StringToDouble(value,(char **) NULL);\n        (void) TIFFSetField(tiff,exif_info[i].tag,field);\n        break;\n      }\n      default:\n        break;\n    }\n  }\n  /* (void) TIFFSetField(tiff,TIFFTAG_EXIFIFD,offset); */\n#else\n  (void) tiff;\n  (void) image;\n#endif\n}\n\nstatic MagickBooleanType WriteTIFFImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n#if !defined(TIFFDefaultStripSize)\n#define TIFFDefaultStripSize(tiff,request)  (8192UL/TIFFScanlineSize(tiff))\n#endif\n\n  const char\n    *mode,\n    *option;\n\n  CompressionType\n    compression;\n\n  EndianType\n    endian_type;\n\n  MagickBooleanType\n    debug,\n    status;\n\n  MagickOffsetType\n    scene;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  register ssize_t\n    i;\n\n  size_t\n    length;\n\n  ssize_t\n    y;\n\n  TIFF\n    *tiff;\n\n  TIFFInfo\n    tiff_info;\n\n  uint16\n    bits_per_sample,\n    compress_tag,\n    endian,\n    photometric;\n\n  uint32\n    rows_per_strip;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open TIFF file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) SetMagickThreadValue(tiff_exception,exception);\n  endian_type=UndefinedEndian;\n  option=GetImageOption(image_info,\"tiff:endian\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleNCompare(option,\"msb\",3) == 0)\n        endian_type=MSBEndian;\n      if (LocaleNCompare(option,\"lsb\",3) == 0)\n        endian_type=LSBEndian;;\n    }\n  switch (endian_type)\n  {\n    case LSBEndian: mode=\"wl\"; break;\n    case MSBEndian: mode=\"wb\"; break;\n    default: mode=\"w\"; break;\n  }\n#if defined(TIFF_VERSION_BIG)\n  if (LocaleCompare(image_info->magick,\"TIFF64\") == 0)\n    switch (endian_type)\n    {\n      case LSBEndian: mode=\"wl8\"; break;\n      case MSBEndian: mode=\"wb8\"; break;\n      default: mode=\"w8\"; break;\n    }\n#endif\n  tiff=TIFFClientOpen(image->filename,mode,(thandle_t) image,TIFFReadBlob,\n    TIFFWriteBlob,TIFFSeekBlob,TIFFCloseBlob,TIFFGetBlobSize,TIFFMapBlob,\n    TIFFUnmapBlob);\n  if (tiff == (TIFF *) NULL)\n    return(MagickFalse);\n  scene=0;\n  debug=IsEventLogging();\n  (void) debug;\n  do\n  {\n    /*\n      Initialize TIFF fields.\n    */\n    if ((image_info->type != UndefinedType) &&\n        (image_info->type != OptimizeType))\n      (void) SetImageType(image,image_info->type,exception);\n    compression=UndefinedCompression;\n    if (image->compression != JPEGCompression)\n      compression=image->compression;\n    if (image_info->compression != UndefinedCompression)\n      compression=image_info->compression;\n    switch (compression)\n    {\n      case FaxCompression:\n      case Group4Compression:\n      {\n        (void) SetImageType(image,BilevelType,exception);\n        (void) SetImageDepth(image,1,exception);\n        break;\n      }\n      case JPEGCompression:\n      {\n        (void) SetImageStorageClass(image,DirectClass,exception);\n        (void) SetImageDepth(image,8,exception);\n        break;\n      }\n      default:\n        break;\n    }\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if ((image->storage_class != PseudoClass) && (image->depth >= 32) &&\n        (quantum_info->format == UndefinedQuantumFormat) &&\n        (IsHighDynamicRangeImage(image,exception) != MagickFalse))\n      {\n        status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n        if (status == MagickFalse)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    if ((LocaleCompare(image_info->magick,\"PTIF\") == 0) &&\n        (GetPreviousImageInList(image) != (Image *) NULL))\n      (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_REDUCEDIMAGE);\n    if ((image->columns != (uint32) image->columns) ||\n        (image->rows != (uint32) image->rows))\n      ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n    (void) TIFFSetField(tiff,TIFFTAG_IMAGELENGTH,(uint32) image->rows);\n    (void) TIFFSetField(tiff,TIFFTAG_IMAGEWIDTH,(uint32) image->columns);\n    switch (compression)\n    {\n      case FaxCompression:\n      {\n        compress_tag=COMPRESSION_CCITTFAX3;\n        SetQuantumMinIsWhite(quantum_info,MagickTrue);\n        break;\n      }\n      case Group4Compression:\n      {\n        compress_tag=COMPRESSION_CCITTFAX4;\n        SetQuantumMinIsWhite(quantum_info,MagickTrue);\n        break;\n      }\n#if defined(COMPRESSION_JBIG)\n      case JBIG1Compression:\n      {\n        compress_tag=COMPRESSION_JBIG;\n        break;\n      }\n#endif\n      case JPEGCompression:\n      {\n        compress_tag=COMPRESSION_JPEG;\n        break;\n      }\n#if defined(COMPRESSION_LZMA)\n      case LZMACompression:\n      {\n        compress_tag=COMPRESSION_LZMA;\n        break;\n      }\n#endif\n      case LZWCompression:\n      {\n        compress_tag=COMPRESSION_LZW;\n        break;\n      }\n      case RLECompression:\n      {\n        compress_tag=COMPRESSION_PACKBITS;\n        break;\n      }\n      case ZipCompression:\n      {\n        compress_tag=COMPRESSION_ADOBE_DEFLATE;\n        break;\n      }\n      case NoCompression:\n      default:\n      {\n        compress_tag=COMPRESSION_NONE;\n        break;\n      }\n    }\n#if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION > 20040919)\n    if ((compress_tag != COMPRESSION_NONE) &&\n        (TIFFIsCODECConfigured(compress_tag) == 0))\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n          \"CompressionNotSupported\",\"`%s'\",CommandOptionToMnemonic(\n          MagickCompressOptions,(ssize_t) compression));\n        compress_tag=COMPRESSION_NONE;\n        compression=NoCompression;\n      }\n#else\n      switch (compress_tag)\n      {\n#if defined(CCITT_SUPPORT)\n        case COMPRESSION_CCITTFAX3:\n        case COMPRESSION_CCITTFAX4:\n#endif\n#if defined(YCBCR_SUPPORT) && defined(JPEG_SUPPORT)\n        case COMPRESSION_JPEG:\n#endif\n#if defined(LZMA_SUPPORT) && defined(COMPRESSION_LZMA)\n        case COMPRESSION_LZMA:\n#endif\n#if defined(LZW_SUPPORT)\n        case COMPRESSION_LZW:\n#endif\n#if defined(PACKBITS_SUPPORT)\n        case COMPRESSION_PACKBITS:\n#endif\n#if defined(ZIP_SUPPORT)\n        case COMPRESSION_ADOBE_DEFLATE:\n#endif\n        case COMPRESSION_NONE:\n          break;\n        default:\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n            \"CompressionNotSupported\",\"`%s'\",CommandOptionToMnemonic(\n              MagickCompressOptions,(ssize_t) compression));\n          compress_tag=COMPRESSION_NONE;\n          compression=NoCompression;\n          break;\n        }\n      }\n#endif\n    if (image->colorspace == CMYKColorspace)\n      {\n        photometric=PHOTOMETRIC_SEPARATED;\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,4);\n        (void) TIFFSetField(tiff,TIFFTAG_INKSET,INKSET_CMYK);\n      }\n    else\n      {\n        /*\n          Full color TIFF raster.\n        */\n        if (image->colorspace == LabColorspace)\n          {\n            photometric=PHOTOMETRIC_CIELAB;\n            EncodeLabImage(image,exception);\n          }\n        else\n          if (image->colorspace == YCbCrColorspace)\n            {\n              photometric=PHOTOMETRIC_YCBCR;\n              (void) TIFFSetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,1,1);\n              (void) SetImageStorageClass(image,DirectClass,exception);\n              (void) SetImageDepth(image,8,exception);\n            }\n          else\n            photometric=PHOTOMETRIC_RGB;\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,3);\n        if ((image_info->type != TrueColorType) &&\n            (image_info->type != TrueColorAlphaType))\n          {\n            if ((image_info->type != PaletteType) &&\n                (SetImageGray(image,exception) != MagickFalse))\n              {\n                photometric=(uint16) (quantum_info->min_is_white !=\n                  MagickFalse ? PHOTOMETRIC_MINISWHITE :\n                  PHOTOMETRIC_MINISBLACK);\n                (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,1);\n                if ((image->depth == 1) &&\n                    (image->alpha_trait == UndefinedPixelTrait))\n                  SetImageMonochrome(image,exception);\n              }\n            else\n              if (image->storage_class == PseudoClass)\n                {\n                  size_t\n                    depth;\n\n                  /*\n                    Colormapped TIFF raster.\n                  */\n                  (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,1);\n                  photometric=PHOTOMETRIC_PALETTE;\n                  depth=1;\n                  while ((GetQuantumRange(depth)+1) < image->colors)\n                    depth<<=1;\n                  status=SetQuantumDepth(image,quantum_info,depth);\n                  if (status == MagickFalse)\n                    ThrowWriterException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                }\n          }\n      }\n    (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian);\n    if ((compress_tag == COMPRESSION_CCITTFAX3) &&\n        (photometric != PHOTOMETRIC_MINISWHITE))\n      {\n        compress_tag=COMPRESSION_NONE;\n        endian=FILLORDER_MSB2LSB;\n      }\n    else\n      if ((compress_tag == COMPRESSION_CCITTFAX4) &&\n         (photometric != PHOTOMETRIC_MINISWHITE))\n       {\n         compress_tag=COMPRESSION_NONE;\n         endian=FILLORDER_MSB2LSB;\n       }\n    option=GetImageOption(image_info,\"tiff:fill-order\");\n    if (option != (const char *) NULL)\n      {\n        if (LocaleNCompare(option,\"msb\",3) == 0)\n          endian=FILLORDER_MSB2LSB;\n        if (LocaleNCompare(option,\"lsb\",3) == 0)\n          endian=FILLORDER_LSB2MSB;\n      }\n    (void) TIFFSetField(tiff,TIFFTAG_COMPRESSION,compress_tag);\n    (void) TIFFSetField(tiff,TIFFTAG_FILLORDER,endian);\n    (void) TIFFSetField(tiff,TIFFTAG_BITSPERSAMPLE,quantum_info->depth);\n    if (image->alpha_trait != UndefinedPixelTrait)\n      {\n        uint16\n          extra_samples,\n          sample_info[1],\n          samples_per_pixel;\n\n        /*\n          TIFF has a matte channel.\n        */\n        extra_samples=1;\n        sample_info[0]=EXTRASAMPLE_UNASSALPHA;\n        option=GetImageOption(image_info,\"tiff:alpha\");\n        if (option != (const char *) NULL)\n          {\n            if (LocaleCompare(option,\"associated\") == 0)\n              sample_info[0]=EXTRASAMPLE_ASSOCALPHA;\n            else\n              if (LocaleCompare(option,\"unspecified\") == 0)\n                sample_info[0]=EXTRASAMPLE_UNSPECIFIED;\n          }\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,\n          &samples_per_pixel);\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,samples_per_pixel+1);\n        (void) TIFFSetField(tiff,TIFFTAG_EXTRASAMPLES,extra_samples,\n          &sample_info);\n        if (sample_info[0] == EXTRASAMPLE_ASSOCALPHA)\n          SetQuantumAlphaType(quantum_info,AssociatedQuantumAlpha);\n      }\n    (void) TIFFSetField(tiff,TIFFTAG_PHOTOMETRIC,photometric);\n    switch (quantum_info->format)\n    {\n      case FloatingPointQuantumFormat:\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_IEEEFP);\n        (void) TIFFSetField(tiff,TIFFTAG_SMINSAMPLEVALUE,quantum_info->minimum);\n        (void) TIFFSetField(tiff,TIFFTAG_SMAXSAMPLEVALUE,quantum_info->maximum);\n        break;\n      }\n      case SignedQuantumFormat:\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_INT);\n        break;\n      }\n      case UnsignedQuantumFormat:\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_UINT);\n        break;\n      }\n      default:\n        break;\n    }\n    (void) TIFFSetField(tiff,TIFFTAG_ORIENTATION,ORIENTATION_TOPLEFT);\n    (void) TIFFSetField(tiff,TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\n    if (photometric == PHOTOMETRIC_RGB)\n      if ((image_info->interlace == PlaneInterlace) ||\n          (image_info->interlace == PartitionInterlace))\n        (void) TIFFSetField(tiff,TIFFTAG_PLANARCONFIG,PLANARCONFIG_SEPARATE);\n    rows_per_strip=1;\n    if (TIFFScanlineSize(tiff) != 0)\n      rows_per_strip=TIFFDefaultStripSize(tiff,0);\n    option=GetImageOption(image_info,\"tiff:rows-per-strip\");\n    if (option != (const char *) NULL)\n      rows_per_strip=(size_t) strtol(option,(char **) NULL,10);\n    switch (compress_tag)\n    {\n      case COMPRESSION_JPEG:\n      {\n#if defined(JPEG_SUPPORT)\n        const char\n          *sampling_factor;\n\n        GeometryInfo\n          geometry_info;\n\n        MagickStatusType\n          flags;\n\n        rows_per_strip+=(16-(rows_per_strip % 16));\n        if (image_info->quality != UndefinedCompressionQuality)\n          (void) TIFFSetField(tiff,TIFFTAG_JPEGQUALITY,image_info->quality);\n        (void) TIFFSetField(tiff,TIFFTAG_JPEGCOLORMODE,JPEGCOLORMODE_RAW);\n        if (IssRGBCompatibleColorspace(image->colorspace) != MagickFalse)\n          {\n            const char\n              *value;\n\n            (void) TIFFSetField(tiff,TIFFTAG_JPEGCOLORMODE,JPEGCOLORMODE_RGB);\n            sampling_factor=(const char *) NULL;\n            value=GetImageProperty(image,\"jpeg:sampling-factor\",exception);\n            if (value != (char *) NULL)\n              {\n                sampling_factor=value;\n                if (image->debug != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Input sampling-factors=%s\",sampling_factor);\n              }\n            if (image_info->sampling_factor != (char *) NULL)\n              sampling_factor=image_info->sampling_factor;\n            if (sampling_factor != (const char *) NULL)\n              {\n                flags=ParseGeometry(sampling_factor,&geometry_info);\n                if ((flags & SigmaValue) == 0)\n                  geometry_info.sigma=geometry_info.rho;\n                if (image->colorspace == YCbCrColorspace)\n                  (void) TIFFSetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,(uint16)\n                    geometry_info.rho,(uint16) geometry_info.sigma);\n              }\n          }\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample);\n        if (bits_per_sample == 12)\n          (void) TIFFSetField(tiff,TIFFTAG_JPEGTABLESMODE,JPEGTABLESMODE_QUANT);\n#endif\n        break;\n      }\n      case COMPRESSION_ADOBE_DEFLATE:\n      {\n        rows_per_strip=(uint32) image->rows;\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample);\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          (void) TIFFSetField(tiff,TIFFTAG_PREDICTOR,PREDICTOR_HORIZONTAL);\n        (void) TIFFSetField(tiff,TIFFTAG_ZIPQUALITY,(long) (\n          image_info->quality == UndefinedCompressionQuality ? 7 :\n          MagickMin((ssize_t) image_info->quality/10,9)));\n        break;\n      }\n      case COMPRESSION_CCITTFAX3:\n      {\n        /*\n          Byte-aligned EOL.\n        */\n        rows_per_strip=(uint32) image->rows;\n        (void) TIFFSetField(tiff,TIFFTAG_GROUP3OPTIONS,4);\n        break;\n      }\n      case COMPRESSION_CCITTFAX4:\n      {\n        rows_per_strip=(uint32) image->rows;\n        break;\n      }\n#if defined(LZMA_SUPPORT) && defined(COMPRESSION_LZMA)\n      case COMPRESSION_LZMA:\n      {\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          (void) TIFFSetField(tiff,TIFFTAG_PREDICTOR,PREDICTOR_HORIZONTAL);\n        (void) TIFFSetField(tiff,TIFFTAG_LZMAPRESET,(long) (\n          image_info->quality == UndefinedCompressionQuality ? 7 :\n          MagickMin((ssize_t) image_info->quality/10,9)));\n        break;\n      }\n#endif\n      case COMPRESSION_LZW:\n      {\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample);\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          (void) TIFFSetField(tiff,TIFFTAG_PREDICTOR,PREDICTOR_HORIZONTAL);\n        break;\n      }\n      default:\n        break;\n    }\n    if (rows_per_strip < 1)\n      rows_per_strip=1;\n    if ((image->rows/rows_per_strip) >= (1UL << 15))\n      rows_per_strip=(uint32) (image->rows >> 15);\n    (void) TIFFSetField(tiff,TIFFTAG_ROWSPERSTRIP,rows_per_strip);\n    if ((image->resolution.x != 0.0) && (image->resolution.y != 0.0))\n      {\n        unsigned short\n          units;\n\n        /*\n          Set image resolution.\n        */\n        units=RESUNIT_NONE;\n        if (image->units == PixelsPerInchResolution)\n          units=RESUNIT_INCH;\n        if (image->units == PixelsPerCentimeterResolution)\n          units=RESUNIT_CENTIMETER;\n        (void) TIFFSetField(tiff,TIFFTAG_RESOLUTIONUNIT,(uint16) units);\n        (void) TIFFSetField(tiff,TIFFTAG_XRESOLUTION,image->resolution.x);\n        (void) TIFFSetField(tiff,TIFFTAG_YRESOLUTION,image->resolution.y);\n        if ((image->page.x < 0) || (image->page.y < 0))\n          (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n            \"TIFF: negative image positions unsupported\",\"%s\",image->filename);\n        if ((image->page.x > 0) && (image->resolution.x > 0.0))\n          {\n            /*\n              Set horizontal image position.\n            */\n            (void) TIFFSetField(tiff,TIFFTAG_XPOSITION,(float) image->page.x/\n              image->resolution.x);\n          }\n        if ((image->page.y > 0) && (image->resolution.y > 0.0))\n          {\n            /*\n              Set vertical image position.\n            */\n            (void) TIFFSetField(tiff,TIFFTAG_YPOSITION,(float) image->page.y/\n              image->resolution.y);\n          }\n      }\n    if (image->chromaticity.white_point.x != 0.0)\n      {\n        float\n          chromaticity[6];\n\n        /*\n          Set image chromaticity.\n        */\n        chromaticity[0]=(float) image->chromaticity.red_primary.x;\n        chromaticity[1]=(float) image->chromaticity.red_primary.y;\n        chromaticity[2]=(float) image->chromaticity.green_primary.x;\n        chromaticity[3]=(float) image->chromaticity.green_primary.y;\n        chromaticity[4]=(float) image->chromaticity.blue_primary.x;\n        chromaticity[5]=(float) image->chromaticity.blue_primary.y;\n        (void) TIFFSetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,chromaticity);\n        chromaticity[0]=(float) image->chromaticity.white_point.x;\n        chromaticity[1]=(float) image->chromaticity.white_point.y;\n        (void) TIFFSetField(tiff,TIFFTAG_WHITEPOINT,chromaticity);\n      }\n    if ((LocaleCompare(image_info->magick,\"PTIF\") != 0) &&\n        (image_info->adjoin != MagickFalse) && (GetImageListLength(image) > 1))\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n        if (image->scene != 0)\n          (void) TIFFSetField(tiff,TIFFTAG_PAGENUMBER,(uint16) image->scene,\n            GetImageListLength(image));\n      }\n    if (image->orientation != UndefinedOrientation)\n      (void) TIFFSetField(tiff,TIFFTAG_ORIENTATION,(uint16) image->orientation);\n    (void) TIFFSetProfiles(tiff,image);\n    {\n      uint16\n        page,\n        pages;\n\n      page=(uint16) scene;\n      pages=(uint16) GetImageListLength(image);\n      if ((LocaleCompare(image_info->magick,\"PTIF\") != 0) &&\n          (image_info->adjoin != MagickFalse) && (pages > 1))\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n      (void) TIFFSetField(tiff,TIFFTAG_PAGENUMBER,page,pages);\n    }\n    (void) TIFFSetProperties(tiff,image_info,image,exception);\nDisableMSCWarning(4127)\n    if (0)\nRestoreMSCWarning\n      (void) TIFFSetEXIFProperties(tiff,image,exception);\n    /*\n      Write image scanlines.\n    */\n    if (GetTIFFInfo(image_info,tiff,&tiff_info) == MagickFalse)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    quantum_info->endian=LSBEndian;\n    pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n    tiff_info.scanline=(unsigned char *) GetQuantumPixels(quantum_info);\n    switch (photometric)\n    {\n      case PHOTOMETRIC_CIELAB:\n      case PHOTOMETRIC_YCBCR:\n      case PHOTOMETRIC_RGB:\n      {\n        /*\n          RGB TIFF image.\n        */\n        switch (image_info->interlace)\n        {\n          case NoInterlace:\n          default:\n          {\n            quantum_type=RGBQuantum;\n            if (image->alpha_trait != UndefinedPixelTrait)\n              quantum_type=RGBAQuantum;\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const Quantum\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                quantum_type,pixels,exception);\n              (void) length;\n              if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          case PlaneInterlace:\n          case PartitionInterlace:\n          {\n            /*\n              Plane interlacing:  RRRRRR...GGGGGG...BBBBBB...\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const Quantum\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                RedQuantum,pixels,exception);\n              if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n                break;\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,100,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const Quantum\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                GreenQuantum,pixels,exception);\n              if (TIFFWritePixels(tiff,&tiff_info,y,1,image) == -1)\n                break;\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,200,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const Quantum\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                BlueQuantum,pixels,exception);\n              if (TIFFWritePixels(tiff,&tiff_info,y,2,image) == -1)\n                break;\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,300,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            if (image->alpha_trait != UndefinedPixelTrait)\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                register const Quantum\n                  *magick_restrict p;\n\n                p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n                if (p == (const Quantum *) NULL)\n                  break;\n                length=ExportQuantumPixels(image,(CacheView *) NULL,\n                  quantum_info,AlphaQuantum,pixels,exception);\n                if (TIFFWritePixels(tiff,&tiff_info,y,3,image) == -1)\n                  break;\n              }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,400,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            break;\n          }\n        }\n        break;\n      }\n      case PHOTOMETRIC_SEPARATED:\n      {\n        /*\n          CMYK TIFF image.\n        */\n        quantum_type=CMYKQuantum;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          quantum_type=CMYKAQuantum;\n        if (image->colorspace != CMYKColorspace)\n          (void) TransformImageColorspace(image,CMYKColorspace,exception);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case PHOTOMETRIC_PALETTE:\n      {\n        uint16\n          *blue,\n          *green,\n          *red;\n\n        /*\n          Colormapped TIFF image.\n        */\n        red=(uint16 *) AcquireQuantumMemory(65536,sizeof(*red));\n        green=(uint16 *) AcquireQuantumMemory(65536,sizeof(*green));\n        blue=(uint16 *) AcquireQuantumMemory(65536,sizeof(*blue));\n        if ((red == (uint16 *) NULL) || (green == (uint16 *) NULL) ||\n            (blue == (uint16 *) NULL))\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        /*\n          Initialize TIFF colormap.\n        */\n        (void) ResetMagickMemory(red,0,65536*sizeof(*red));\n        (void) ResetMagickMemory(green,0,65536*sizeof(*green));\n        (void) ResetMagickMemory(blue,0,65536*sizeof(*blue));\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          red[i]=ScaleQuantumToShort(image->colormap[i].red);\n          green[i]=ScaleQuantumToShort(image->colormap[i].green);\n          blue[i]=ScaleQuantumToShort(image->colormap[i].blue);\n        }\n        (void) TIFFSetField(tiff,TIFFTAG_COLORMAP,red,green,blue);\n        red=(uint16 *) RelinquishMagickMemory(red);\n        green=(uint16 *) RelinquishMagickMemory(green);\n        blue=(uint16 *) RelinquishMagickMemory(blue);\n      }\n      default:\n      {\n        /*\n          Convert PseudoClass packets to contiguous grayscale scanlines.\n        */\n        quantum_type=IndexQuantum;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          {\n            if (photometric != PHOTOMETRIC_PALETTE)\n              quantum_type=GrayAlphaQuantum;\n            else\n              quantum_type=IndexAlphaQuantum;\n           }\n         else\n           if (photometric != PHOTOMETRIC_PALETTE)\n             quantum_type=GrayQuantum;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n    }\n    quantum_info=DestroyQuantumInfo(quantum_info);\n    if (image->colorspace == LabColorspace)\n      DecodeLabImage(image,exception);\n    DestroyTIFFInfo(&tiff_info);\nDisableMSCWarning(4127)\n    if (0 && (image_info->verbose != MagickFalse))\nRestoreMSCWarning\n      TIFFPrintDirectory(tiff,stdout,MagickFalse);\n    (void) TIFFWriteDirectory(tiff);\n    image=SyncNextImageInList(image);\n    if (image == (Image *) NULL)\n      break;\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  TIFFClose(tiff);\n  return(MagickTrue);\n}\n#endif\n"], "filenames": ["ChangeLog", "coders/tiff.c"], "buggy_code_start_loc": [4, 3493], "buggy_code_end_loc": [6, 3494], "fixing_code_start_loc": [4, 3493], "fixing_code_end_loc": [6, 3496], "type": "CWE-369", "message": "The WriteTIFFImage function in coders/tiff.c in ImageMagick before 6.9.5-8 allows remote attackers to cause a denial of service (divide-by-zero error and application crash) via a crafted file.", "other": {"cve": {"id": "CVE-2016-10053", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-23T17:59:00.563", "lastModified": "2020-11-16T19:56:14.167", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The WriteTIFFImage function in coders/tiff.c in ImageMagick before 6.9.5-8 allows remote attackers to cause a denial of service (divide-by-zero error and application crash) via a crafted file."}, {"lang": "es", "value": "La funci\u00f3n WriteTIFFImage en coders/tiff.c en ImageMagick en versiones anteriores a 6.9.5-8 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (error de divisi\u00f3n por cero y ca\u00edda de la aplicaci\u00f3n) a trav\u00e9s de un archivo manipulado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-369"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionEndIncluding": "6.9.5-7", "matchCriteriaId": "0FABE1A3-A5DE-432B-A105-692E02AD1C23"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2016/12/26/9", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/95179", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1410461", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/728dc6a600cf4cbdac846964c85cc04339db8ac1", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/f983dcdf9c178e0cbc49608a78713c5669aa1bb5", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/728dc6a600cf4cbdac846964c85cc04339db8ac1"}}