{"buggy_code": ["<?php\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\Bundle\\AdminBundle\\Controller\\Admin\\Asset;\n\nuse Pimcore\\Bundle\\AdminBundle\\Controller\\Admin\\ElementControllerBase;\nuse Pimcore\\Bundle\\AdminBundle\\Controller\\Traits\\AdminStyleTrait;\nuse Pimcore\\Bundle\\AdminBundle\\Controller\\Traits\\ApplySchedulerDataTrait;\nuse Pimcore\\Bundle\\AdminBundle\\Helper\\GridHelperService;\nuse Pimcore\\Bundle\\AdminBundle\\Security\\CsrfProtectionHandler;\nuse Pimcore\\Config;\nuse Pimcore\\Controller\\KernelControllerEventInterface;\nuse Pimcore\\Controller\\Traits\\ElementEditLockHelperTrait;\nuse Pimcore\\Db\\Helper;\nuse Pimcore\\Event\\Admin\\ElementAdminStyleEvent;\nuse Pimcore\\Event\\AdminEvents;\nuse Pimcore\\Event\\AssetEvents;\nuse Pimcore\\Event\\Model\\Asset\\ResolveUploadTargetEvent;\nuse Pimcore\\File;\nuse Pimcore\\Loader\\ImplementationLoader\\Exception\\UnsupportedException;\nuse Pimcore\\Logger;\nuse Pimcore\\Messenger\\AssetPreviewImageMessage;\nuse Pimcore\\Model;\nuse Pimcore\\Model\\Asset;\nuse Pimcore\\Model\\DataObject\\ClassDefinition\\Data\\ManyToManyRelation;\nuse Pimcore\\Model\\DataObject\\Concrete;\nuse Pimcore\\Model\\Element;\nuse Pimcore\\Model\\Element\\ValidationException;\nuse Pimcore\\Model\\Metadata;\nuse Pimcore\\Model\\Schedule\\Task;\nuse Pimcore\\Tool;\nuse Symfony\\Component\\EventDispatcher\\GenericEvent;\nuse Symfony\\Component\\HttpFoundation\\BinaryFileResponse;\nuse Symfony\\Component\\HttpFoundation\\JsonResponse;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpFoundation\\ResponseHeaderBag;\nuse Symfony\\Component\\HttpFoundation\\Session\\Attribute\\AttributeBagInterface;\nuse Symfony\\Component\\HttpFoundation\\StreamedResponse;\nuse Symfony\\Component\\HttpKernel\\Event\\ControllerEvent;\nuse Symfony\\Component\\Mime\\MimeTypes;\nuse Symfony\\Component\\Process\\Process;\nuse Symfony\\Component\\Routing\\Annotation\\Route;\nuse Symfony\\Contracts\\EventDispatcher\\EventDispatcherInterface;\n\n/**\n * @Route(\"/asset\")\n *\n * @internal\n */\nclass AssetController extends ElementControllerBase implements KernelControllerEventInterface\n{\n    use AdminStyleTrait;\n    use ElementEditLockHelperTrait;\n    use ApplySchedulerDataTrait;\n\n    /**\n     * @var Asset\\Service\n     */\n    protected $_assetService;\n\n    /**\n     * @Route(\"/tree-get-root\", name=\"pimcore_admin_asset_treegetroot\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function treeGetRootAction(Request $request)\n    {\n        return parent::treeGetRootAction($request);\n    }\n\n    /**\n     * @Route(\"/delete-info\", name=\"pimcore_admin_asset_deleteinfo\", methods={\"GET\"})\n     *\n     * @param Request $request\n     * @param EventDispatcherInterface $eventDispatcher\n     *\n     * @return JsonResponse\n     */\n    public function deleteInfoAction(Request $request, EventDispatcherInterface $eventDispatcher)\n    {\n        return parent::deleteInfoAction($request, $eventDispatcher);\n    }\n\n    /**\n     * @Route(\"/get-data-by-id\", name=\"pimcore_admin_asset_getdatabyid\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getDataByIdAction(Request $request, EventDispatcherInterface $eventDispatcher)\n    {\n        $assetId = (int)$request->get('id');\n        $type = (string)$request->get('type');\n\n        $asset = Asset::getById($assetId);\n        if (!$asset instanceof Asset) {\n            return $this->adminJson(['success' => false, 'message' => \"asset doesn't exist\"]);\n        }\n\n        // check for lock on non-folder items only.\n        if ($type !== 'folder' && ($asset->isAllowed('publish') || $asset->isAllowed('delete'))) {\n            if (Element\\Editlock::isLocked($assetId, 'asset')) {\n                return $this->getEditLockResponse($assetId, 'asset');\n            }\n\n            Element\\Editlock::lock($request->get('id'), 'asset');\n        }\n\n        $asset = clone $asset;\n        $asset->setParent(null);\n\n        $asset->setStream(null);\n        $data = $asset->getObjectVars();\n        $data['locked'] = $asset->isLocked();\n\n        if ($asset instanceof Asset\\Text) {\n            if ($asset->getFileSize() < 2000000) {\n                // it doesn't make sense to show a preview for files bigger than 2MB\n                $data['data'] = \\ForceUTF8\\Encoding::toUTF8($asset->getData());\n            } else {\n                $data['data'] = false;\n            }\n        } elseif ($asset instanceof Asset\\Document) {\n            $data['pdfPreviewAvailable'] = (bool)$this->getDocumentPreviewPdf($asset);\n        } elseif ($asset instanceof Asset\\Video) {\n            $videoInfo = [];\n\n            if (\\Pimcore\\Video::isAvailable()) {\n                $config = Asset\\Video\\Thumbnail\\Config::getPreviewConfig();\n                $thumbnail = $asset->getThumbnail($config, ['mp4']);\n                if ($thumbnail) {\n                    if ($thumbnail['status'] == 'finished') {\n                        $videoInfo['previewUrl'] = $thumbnail['formats']['mp4'];\n                        $videoInfo['width'] = $asset->getWidth();\n                        $videoInfo['height'] = $asset->getHeight();\n\n                        $metaData = $asset->getSphericalMetaData();\n                        if (isset($metaData['ProjectionType']) && strtolower($metaData['ProjectionType']) == 'equirectangular') {\n                            $videoInfo['isVrVideo'] = true;\n                        }\n                    }\n                }\n            }\n\n            $data['videoInfo'] = $videoInfo;\n        } elseif ($asset instanceof Asset\\Image) {\n            $imageInfo = [];\n\n            $previewUrl = $this->generateUrl('pimcore_admin_asset_getimagethumbnail', [\n                'id' => $asset->getId(),\n                'treepreview' => true,\n                '_dc' => time(),\n            ]);\n\n            if ($asset->isAnimated()) {\n                $previewUrl = $this->generateUrl('pimcore_admin_asset_getasset', [\n                    'id' => $asset->getId(),\n                    '_dc' => time(),\n                ]);\n            }\n\n            $imageInfo['previewUrl'] = $previewUrl;\n\n            if ($asset->getWidth() && $asset->getHeight()) {\n                $imageInfo['dimensions'] = [];\n                $imageInfo['dimensions']['width'] = $asset->getWidth();\n                $imageInfo['dimensions']['height'] = $asset->getHeight();\n            }\n\n            $imageInfo['exiftoolAvailable'] = (bool)\\Pimcore\\Tool\\Console::getExecutable('exiftool');\n\n            if (!$asset->getEmbeddedMetaData(false)) {\n                $asset->getEmbeddedMetaData(true, false); // read Exif, IPTC and XPM like in the old days ...\n            }\n\n            $data['imageInfo'] = $imageInfo;\n        }\n\n        $predefinedMetaData = Metadata\\Predefined\\Listing::getByTargetType('asset', [$asset->getType()]);\n        $predefinedMetaDataGroups = [];\n        /** @var Metadata\\Predefined $item */\n        foreach ($predefinedMetaData as $item) {\n            if ($item->getGroup()) {\n                $predefinedMetaDataGroups[$item->getGroup()] = true;\n            }\n        }\n        $data['predefinedMetaDataGroups'] = array_keys($predefinedMetaDataGroups);\n        $data['properties'] = Element\\Service::minimizePropertiesForEditmode($asset->getProperties());\n        $data['metadata'] = Asset\\Service::expandMetadataForEditmode($asset->getMetadata());\n        $data['versionDate'] = $asset->getModificationDate();\n        $data['filesizeFormatted'] = $asset->getFileSize(true);\n        $data['filesize'] = $asset->getFileSize();\n        $data['fileExtension'] = File::getFileExtension($asset->getFilename());\n        $data['idPath'] = Element\\Service::getIdPath($asset);\n        $data['userPermissions'] = $asset->getUserPermissions($this->getAdminUser());\n        $frontendPath = $asset->getFrontendFullPath();\n        $data['url'] = preg_match('/^http(s)?:\\\\/\\\\/.+/', $frontendPath) ?\n            $frontendPath :\n            $request->getSchemeAndHttpHost() . $frontendPath;\n\n        $data['scheduledTasks'] = array_map(\n            static function (Task $task) {\n                return $task->getObjectVars();\n            },\n            $asset->getScheduledTasks()\n        );\n\n        $this->addAdminStyle($asset, ElementAdminStyleEvent::CONTEXT_EDITOR, $data);\n\n        $data['php'] = [\n            'classes' => array_merge([get_class($asset)], array_values(class_parents($asset))),\n            'interfaces' => array_values(class_implements($asset)),\n        ];\n\n        $event = new GenericEvent($this, [\n            'data' => $data,\n            'asset' => $asset,\n        ]);\n        $eventDispatcher->dispatch($event, AdminEvents::ASSET_GET_PRE_SEND_DATA);\n        $data = $event->getArgument('data');\n\n        if ($asset->isAllowed('view')) {\n            return $this->adminJson($data);\n        }\n\n        throw $this->createAccessDeniedHttpException();\n    }\n\n    /**\n     * @Route(\"/tree-get-childs-by-id\", name=\"pimcore_admin_asset_treegetchildsbyid\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function treeGetChildsByIdAction(Request $request, EventDispatcherInterface $eventDispatcher)\n    {\n        $allParams = array_merge($request->request->all(), $request->query->all());\n\n        $assets = [];\n        $cv = false;\n        $asset = Asset::getById($allParams['node']);\n\n        $filter = $request->get('filter');\n        $limit = (int)$allParams['limit'];\n        if (!is_null($filter)) {\n            if (substr($filter, -1) != '*') {\n                $filter .= '*';\n            }\n            $filter = str_replace('*', '%', $filter);\n\n            $limit = 100;\n            $offset = 0;\n        } elseif (!$allParams['limit']) {\n            $limit = 100000000;\n        }\n\n        $offset = isset($allParams['start']) ? (int)$allParams['start'] : 0;\n\n        $filteredTotalCount = 0;\n\n        if ($asset->hasChildren()) {\n            if ($allParams['view']) {\n                $cv = \\Pimcore\\Model\\Element\\Service::getCustomViewById($allParams['view']);\n            }\n\n            // get assets\n            $childrenList = new Asset\\Listing();\n            $childrenList->addConditionParam('parentId = ?', [$asset->getId()]);\n            $childrenList->filterAccessibleByUser($this->getAdminUser(), $asset);\n\n            if (!is_null($filter)) {\n                $childrenList->addConditionParam('CAST(assets.filename AS CHAR CHARACTER SET utf8) COLLATE utf8_general_ci LIKE ?', [$filter]);\n            }\n\n            $childrenList->setLimit($limit);\n            $childrenList->setOffset($offset);\n            $childrenList->setOrderKey(\"FIELD(assets.type, 'folder') DESC, CAST(assets.filename AS CHAR CHARACTER SET utf8) COLLATE utf8_general_ci ASC\", false);\n\n            \\Pimcore\\Model\\Element\\Service::addTreeFilterJoins($cv, $childrenList);\n\n            $beforeListLoadEvent = new GenericEvent($this, [\n                'list' => $childrenList,\n                'context' => $allParams,\n            ]);\n            $eventDispatcher->dispatch($beforeListLoadEvent, AdminEvents::ASSET_LIST_BEFORE_LIST_LOAD);\n            /** @var Asset\\Listing $childrenList */\n            $childrenList = $beforeListLoadEvent->getArgument('list');\n\n            $children = $childrenList->load();\n\n            $filteredTotalCount = $childrenList->getTotalCount();\n\n            foreach ($children as $childAsset) {\n                $assetTreeNode = $this->getTreeNodeConfig($childAsset);\n                if ($assetTreeNode['permissions']['list'] == 1) {\n                    $assets[] = $assetTreeNode;\n                }\n            }\n        }\n\n        //Hook for modifying return value - e.g. for changing permissions based on asset data\n        $event = new GenericEvent($this, [\n            'assets' => $assets,\n        ]);\n        $eventDispatcher->dispatch($event, AdminEvents::ASSET_TREE_GET_CHILDREN_BY_ID_PRE_SEND_DATA);\n        $assets = $event->getArgument('assets');\n\n        if ($allParams['limit']) {\n            return $this->adminJson([\n                'offset' => $offset,\n                'limit' => $limit,\n                'total' => $asset->getChildAmount($this->getAdminUser()),\n                'overflow' => !is_null($filter) && ($filteredTotalCount > $limit),\n                'nodes' => $assets,\n                'filter' => $request->get('filter') ? $request->get('filter') : '',\n                'inSearch' => (int)$request->get('inSearch'),\n            ]);\n        } else {\n            return $this->adminJson($assets);\n        }\n    }\n\n    /**\n     * @Route(\"/add-asset\", name=\"pimcore_admin_asset_addasset\", methods={\"POST\"})\n     *\n     * @param Request $request\n     * @param Config $config\n     *\n     * @return JsonResponse\n     */\n    public function addAssetAction(Request $request, Config $config)\n    {\n        try {\n            $res = $this->addAsset($request, $config);\n\n            $response = [\n                'success' => $res['success'],\n            ];\n\n            if ($res['success']) {\n                $response['asset'] = [\n                    'id' => $res['asset']->getId(),\n                    'path' => $res['asset']->getFullPath(),\n                    'type' => $res['asset']->getType(),\n                ];\n            }\n\n            return $this->adminJson($response);\n        } catch (\\Exception $e) {\n            return $this->adminJson([\n                'success' => false,\n                'message' => $e->getMessage(),\n            ]);\n        }\n    }\n\n    /**\n     * @Route(\"/add-asset-compatibility\", name=\"pimcore_admin_asset_addassetcompatibility\", methods={\"POST\"})\n     *\n     * @param Request $request\n     * @param Config $config\n     *\n     * @return JsonResponse\n     */\n    public function addAssetCompatibilityAction(Request $request, Config $config)\n    {\n        try {\n            // this is a special action for the compatibility mode upload (without flash)\n            $res = $this->addAsset($request, $config);\n\n            $response = $this->adminJson([\n                'success' => $res['success'],\n                'msg' => $res['success'] ? 'Success' : 'Error',\n                'id' => $res['asset'] ? $res['asset']->getId() : null,\n                'fullpath' => $res['asset'] ? $res['asset']->getRealFullPath() : null,\n                'type' => $res['asset'] ? $res['asset']->getType() : null,\n            ]);\n            $response->headers->set('Content-Type', 'text/html');\n\n            return $response;\n        } catch (\\Exception $e) {\n            return $this->adminJson([\n                'success' => false,\n                'message' => $e->getMessage(),\n            ]);\n        }\n    }\n\n    /**\n     * @Route(\"/exists\", name=\"pimcore_admin_asset_exists\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     *\n     * @throws \\Exception\n     */\n    public function existsAction(Request $request)\n    {\n        $parentAsset = \\Pimcore\\Model\\Asset::getById((int)$request->get('parentId'));\n\n        return new JsonResponse([\n            'exists' => Asset\\Service::pathExists($parentAsset->getRealFullPath().'/'.$request->get('filename')),\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param Config $config\n     *\n     * @return array\n     *\n     * @throws \\Exception\n     */\n    protected function addAsset(Request $request, Config $config)\n    {\n        $defaultUploadPath = $config['assets']['default_upload_path'] ?? '/';\n\n        if (array_key_exists('Filedata', $_FILES)) {\n            $filename = $_FILES['Filedata']['name'];\n            $sourcePath = $_FILES['Filedata']['tmp_name'];\n        } elseif ($request->get('type') == 'base64') {\n            $filename = $request->get('filename');\n            $sourcePath = PIMCORE_SYSTEM_TEMP_DIRECTORY . '/upload-base64' . uniqid() . '.tmp';\n            $data = preg_replace('@^data:[^,]+;base64,@', '', $request->get('data'));\n            File::put($sourcePath, base64_decode($data));\n        } else {\n            throw new \\Exception('The filename of the asset is empty');\n        }\n\n        $parentId = $request->get('parentId');\n        $parentPath = $request->get('parentPath');\n\n        if ($request->get('dir') && $request->get('parentId')) {\n            // this is for uploading folders with Drag&Drop\n            // param \"dir\" contains the relative path of the file\n            $parent = Asset::getById((int) $request->get('parentId'));\n            $dir = $request->get('dir');\n            if (strpos($dir, '..') !== false) {\n                throw new \\Exception('not allowed');\n            }\n\n            $newPath = $parent->getRealFullPath() . '/' . trim($dir, '/ ');\n\n            $maxRetries = 5;\n            $newParent = null;\n            for ($retries = 0; $retries < $maxRetries; $retries++) {\n                try {\n                    $newParent = Asset\\Service::createFolderByPath($newPath);\n\n                    break;\n                } catch (\\Exception $e) {\n                    if ($retries < ($maxRetries - 1)) {\n                        $waitTime = rand(100000, 900000); // microseconds\n                        usleep($waitTime); // wait specified time until we restart the transaction\n                    } else {\n                        // if the transaction still fail after $maxRetries retries, we throw out the exception\n                        throw $e;\n                    }\n                }\n            }\n            if ($newParent) {\n                $parentId = $newParent->getId();\n            }\n        } elseif (!$request->get('parentId') && $parentPath) {\n            $parent = Asset::getByPath($parentPath);\n            if ($parent instanceof Asset\\Folder) {\n                $parentId = $parent->getId();\n            }\n        }\n\n        $filename = Element\\Service::getValidKey($filename, 'asset');\n        if (empty($filename)) {\n            throw new \\Exception('The filename of the asset is empty');\n        }\n\n        $context = $request->get('context');\n        if ($context) {\n            $context = json_decode($context, true);\n            $context = $context ?: [];\n\n            $this->validateManyToManyRelationAssetType($context, $filename, $sourcePath);\n\n            $event = new ResolveUploadTargetEvent($parentId, $filename, $context);\n            \\Pimcore::getEventDispatcher()->dispatch($event, AssetEvents::RESOLVE_UPLOAD_TARGET);\n            $filename = Element\\Service::getValidKey($event->getFilename(), 'asset');\n            $parentId = $event->getParentId();\n        }\n\n        if (!$parentId) {\n            $parentId = Asset\\Service::createFolderByPath($defaultUploadPath)->getId();\n        }\n\n        $parentAsset = Asset::getById((int)$parentId);\n\n        if (!$request->get('allowOverwrite')) {\n            // check for duplicate filename\n            $filename = $this->getSafeFilename($parentAsset->getRealFullPath(), $filename);\n        }\n\n        if (!$parentAsset->isAllowed('create')) {\n            throw $this->createAccessDeniedHttpException(\n                'Missing the permission to create new assets in the folder: ' . $parentAsset->getRealFullPath()\n            );\n        }\n\n        if (is_file($sourcePath) && filesize($sourcePath) < 1) {\n            throw new \\Exception('File is empty!');\n        } elseif (!is_file($sourcePath)) {\n            throw new \\Exception('Something went wrong, please check upload_max_filesize and post_max_size in your php.ini as well as the write permissions of your temporary directories.');\n        }\n\n        // check if there is a requested type and if matches the asset type of the uploaded file\n        $uploadAssetType = $request->get('uploadAssetType');\n        if ($uploadAssetType) {\n            $mimetype = MimeTypes::getDefault()->guessMimeType($sourcePath);\n            $assetType = Asset::getTypeFromMimeMapping($mimetype, $filename);\n\n            if ($uploadAssetType !== $assetType) {\n                throw new \\Exception(\"Mime type $mimetype does not match with asset type: $uploadAssetType\");\n            }\n        }\n\n        if ($request->get('allowOverwrite') && Asset\\Service::pathExists($parentAsset->getRealFullPath().'/'.$filename)) {\n            $asset = Asset::getByPath($parentAsset->getRealFullPath().'/'.$filename);\n            $asset->setStream(fopen($sourcePath, 'rb', false, File::getContext()));\n            $asset->save();\n        } else {\n            $asset = Asset::create($parentId, [\n                'filename' => $filename,\n                'sourcePath' => $sourcePath,\n                'userOwner' => $this->getAdminUser()->getId(),\n                'userModification' => $this->getAdminUser()->getId(),\n            ]);\n        }\n\n        @unlink($sourcePath);\n\n        return [\n            'success' => true,\n            'asset' => $asset,\n        ];\n    }\n\n    /**\n     * @param string $targetPath\n     * @param string $filename\n     *\n     * @return string\n     */\n    protected function getSafeFilename($targetPath, $filename)\n    {\n        $pathinfo = pathinfo($filename);\n        $originalFilename = $pathinfo['filename'];\n        $originalFileextension = empty($pathinfo['extension']) ? '' : '.' . $pathinfo['extension'];\n        $count = 1;\n\n        if ($targetPath == '/') {\n            $targetPath = '';\n        }\n\n        while (true) {\n            if (Asset\\Service::pathExists($targetPath . '/' . $filename)) {\n                $filename = $originalFilename . '_' . $count . $originalFileextension;\n                $count++;\n            } else {\n                return $filename;\n            }\n        }\n    }\n\n    /**\n     * @Route(\"/replace-asset\", name=\"pimcore_admin_asset_replaceasset\", methods={\"POST\", \"PUT\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     *\n     * @throws \\Exception\n     */\n    public function replaceAssetAction(Request $request)\n    {\n        $asset = Asset::getById((int) $request->get('id'));\n\n        $newFilename = Element\\Service::getValidKey($_FILES['Filedata']['name'], 'asset');\n        $mimetype = MimeTypes::getDefault()->guessMimeType($_FILES['Filedata']['tmp_name']);\n        $newType = Asset::getTypeFromMimeMapping($mimetype, $newFilename);\n\n        if ($newType != $asset->getType()) {\n            return $this->adminJson([\n                'success' => false,\n                'message' => sprintf($this->trans('asset_type_change_not_allowed', [], 'admin'), $asset->getType(), $newType),\n            ]);\n        }\n\n        $stream = fopen($_FILES['Filedata']['tmp_name'], 'r+');\n        $asset->setStream($stream);\n        $asset->setCustomSetting('thumbnails', null);\n        $asset->setUserModification($this->getAdminUser()->getId());\n\n        $newFileExt = File::getFileExtension($newFilename);\n        $currentFileExt = File::getFileExtension($asset->getFilename());\n        if ($newFileExt != $currentFileExt) {\n            $newFilename = preg_replace('/\\.' . $currentFileExt . '$/i', '.' . $newFileExt, $asset->getFilename());\n            $newFilename = Element\\Service::getSafeCopyName($newFilename, $asset->getParent());\n            $asset->setFilename($newFilename);\n        }\n\n        if ($asset->isAllowed('publish')) {\n            $asset->save();\n\n            $response = $this->adminJson([\n                'id' => $asset->getId(),\n                'path' => $asset->getRealFullPath(),\n                'success' => true,\n            ]);\n\n            // set content-type to text/html, otherwise (when application/json is sent) chrome will complain in\n            // Ext.form.Action.Submit and mark the submission as failed\n            $response->headers->set('Content-Type', 'text/html');\n\n            return $response;\n        } else {\n            throw new \\Exception('missing permission');\n        }\n    }\n\n    /**\n     * @Route(\"/add-folder\", name=\"pimcore_admin_asset_addfolder\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function addFolderAction(Request $request)\n    {\n        $success = false;\n        $parentAsset = Asset::getById((int)$request->get('parentId'));\n        $equalAsset = Asset::getByPath($parentAsset->getRealFullPath() . '/' . $request->get('name'));\n\n        if ($parentAsset->isAllowed('create')) {\n            if (!$equalAsset) {\n                $asset = Asset::create($request->get('parentId'), [\n                    'filename' => $request->get('name'),\n                    'type' => 'folder',\n                    'userOwner' => $this->getAdminUser()->getId(),\n                    'userModification' => $this->getAdminUser()->getId(),\n                ]);\n                $success = true;\n            }\n        } else {\n            Logger::debug('prevented creating asset because of missing permissions');\n        }\n\n        return $this->adminJson(['success' => $success]);\n    }\n\n    /**\n     * @Route(\"/delete\", name=\"pimcore_admin_asset_delete\", methods={\"DELETE\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function deleteAction(Request $request)\n    {\n        $type = $request->get('type');\n\n        if ($type === 'childs') {\n            trigger_deprecation(\n                'pimcore/pimcore',\n                '10.4',\n                'Type childs is deprecated. Use children instead'\n            );\n            $type = 'children';\n        }\n        if ($type === 'children') {\n            $parentAsset = Asset::getById((int) $request->get('id'));\n\n            $list = new Asset\\Listing();\n            $list->setCondition('path LIKE ?', [Helper::escapeLike($parentAsset->getRealFullPath()) . '/%']);\n            $list->setLimit((int)$request->get('amount'));\n            $list->setOrderKey('LENGTH(path)', false);\n            $list->setOrder('DESC');\n\n            $deletedItems = [];\n            foreach ($list as $asset) {\n                $deletedItems[$asset->getId()] = $asset->getRealFullPath();\n                if ($asset->isAllowed('delete') && !$asset->isLocked()) {\n                    $asset->delete();\n                }\n            }\n\n            return $this->adminJson(['success' => true, 'deleted' => $deletedItems]);\n        }\n        if ($request->get('id')) {\n            $asset = Asset::getById((int) $request->get('id'));\n            if ($asset && $asset->isAllowed('delete')) {\n                if ($asset->isLocked()) {\n                    return $this->adminJson([\n                        'success' => false,\n                        'message' => 'prevented deleting asset, because it is locked: ID: ' . $asset->getId(),\n                    ]);\n                }\n\n                $asset->delete();\n\n                return $this->adminJson(['success' => true]);\n            }\n        }\n\n        throw $this->createAccessDeniedHttpException();\n    }\n\n    /**\n     * @param Asset $element\n     *\n     * @return array\n     */\n    protected function getTreeNodeConfig($element)\n    {\n        $asset = $element;\n\n        $permissions =  $asset->getUserPermissions($this->getAdminUser());\n\n        $tmpAsset = [\n            'id' => $asset->getId(),\n            'key' => $element->getKey(),\n            'text' => htmlspecialchars($asset->getFilename()),\n            'type' => $asset->getType(),\n            'path' => $asset->getRealFullPath(),\n            'basePath' => $asset->getRealPath(),\n            'locked' => $asset->isLocked(),\n            'lockOwner' => $asset->getLocked() ? true : false,\n            'elementType' => 'asset',\n            'permissions' => [\n                'remove' => $permissions['delete'],\n                'settings' => $permissions['settings'],\n                'rename' => $permissions['rename'],\n                'publish' => $permissions['publish'],\n                'view' => $permissions['view'],\n                'list' => $permissions['list'],\n            ],\n        ];\n\n        $hasChildren = $asset->getDao()->hasChildren($this->getAdminUser());\n\n        // set type specific settings\n        if ($asset instanceof Asset\\Folder) {\n            $tmpAsset['leaf'] = false;\n            $tmpAsset['expanded'] = !$hasChildren;\n            $tmpAsset['loaded'] = !$hasChildren;\n            $tmpAsset['permissions']['create'] = $permissions['create'];\n            $tmpAsset['thumbnail'] = $this->getThumbnailUrl($asset, ['origin' => 'treeNode']);\n        } else {\n            $tmpAsset['leaf'] = true;\n            $tmpAsset['expandable'] = false;\n            $tmpAsset['expanded'] = false;\n        }\n\n        $this->addAdminStyle($asset, ElementAdminStyleEvent::CONTEXT_TREE, $tmpAsset);\n\n        if ($asset instanceof Asset\\Image) {\n            try {\n                $tmpAsset['thumbnail'] = $this->getThumbnailUrl($asset, ['origin' => 'treeNode']);\n\n                // we need the dimensions for the wysiwyg editors, so that they can resize the image immediately\n                if ($asset->getCustomSetting('imageDimensionsCalculated')) {\n                    $tmpAsset['imageWidth'] = $asset->getCustomSetting('imageWidth');\n                    $tmpAsset['imageHeight'] = $asset->getCustomSetting('imageHeight');\n                }\n            } catch (\\Exception $e) {\n                Logger::debug('Cannot get dimensions of image, seems to be broken.');\n            }\n        } elseif ($asset->getType() == 'video') {\n            try {\n                if (\\Pimcore\\Video::isAvailable()) {\n                    $tmpAsset['thumbnail'] = $this->getThumbnailUrl($asset, ['origin' => 'treeNode']);\n                }\n            } catch (\\Exception $e) {\n                Logger::debug('Cannot get dimensions of video, seems to be broken.');\n            }\n        } elseif ($asset->getType() == 'document') {\n            try {\n                // add the PDF check here, otherwise the preview layer in admin is shown without content\n                if (\\Pimcore\\Document::isAvailable() && \\Pimcore\\Document::isFileTypeSupported($asset->getFilename())) {\n                    $tmpAsset['thumbnail'] = $this->getThumbnailUrl($asset, ['origin' => 'treeNode']);\n                }\n            } catch (\\Exception $e) {\n                Logger::debug('Cannot get dimensions of video, seems to be broken.');\n            }\n        }\n\n        $tmpAsset['cls'] = '';\n        if ($asset->isLocked()) {\n            $tmpAsset['cls'] .= 'pimcore_treenode_locked ';\n        }\n        if ($asset->getLocked()) {\n            $tmpAsset['cls'] .= 'pimcore_treenode_lockOwner ';\n        }\n\n        return $tmpAsset;\n    }\n\n    /**\n     * @param Asset $asset\n     * @param array $params\n     *\n     * @return null|string\n     */\n    protected function getThumbnailUrl(Asset $asset, array $params = [])\n    {\n        $defaults = [\n            'id' => $asset->getId(),\n            'treepreview' => true,\n            '_dc' => $asset->getModificationDate(),\n        ];\n\n        $params = array_merge($defaults, $params);\n\n        if ($asset instanceof Asset\\Image) {\n            return $this->generateUrl('pimcore_admin_asset_getimagethumbnail', $params);\n        }\n\n        if ($asset instanceof Asset\\Folder) {\n            return $this->generateUrl('pimcore_admin_asset_getfolderthumbnail', $params);\n        }\n\n        if ($asset instanceof Asset\\Video && \\Pimcore\\Video::isAvailable()) {\n            return $this->generateUrl('pimcore_admin_asset_getvideothumbnail', $params);\n        }\n\n        if ($asset instanceof Asset\\Document && \\Pimcore\\Document::isAvailable() && $asset->getPageCount()) {\n            return $this->generateUrl('pimcore_admin_asset_getdocumentthumbnail', $params);\n        }\n\n        if ($asset instanceof Asset\\Audio) {\n            return '/bundles/pimcoreadmin/img/flat-color-icons/speaker.svg';\n        }\n\n        if ($asset instanceof Asset) {\n            return '/bundles/pimcoreadmin/img/filetype-not-supported.svg';\n        }\n    }\n\n    /**\n     * @Route(\"/update\", name=\"pimcore_admin_asset_update\", methods={\"PUT\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     *\n     * @throws \\Exception\n     */\n    public function updateAction(Request $request)\n    {\n        $success = false;\n        $allowUpdate = true;\n\n        $updateData = array_merge($request->request->all(), $request->query->all());\n\n        $asset = Asset::getById((int) $request->get('id'));\n        if ($asset->isAllowed('settings')) {\n            $asset->setUserModification($this->getAdminUser()->getId());\n\n            // if the position is changed the path must be changed || also from the children\n            if ($parentId = $request->get('parentId')) {\n                $parentAsset = Asset::getById((int) $parentId);\n\n                //check if parent is changed i.e. asset is moved\n                if ($asset->getParentId() != $parentAsset->getId()) {\n                    if (!$parentAsset->isAllowed('create')) {\n                        throw new \\Exception('Prevented moving asset - no create permission on new parent ');\n                    }\n\n                    $intendedPath = $parentAsset->getRealPath();\n                    $pKey = $parentAsset->getKey();\n                    if (!empty($pKey)) {\n                        $intendedPath .= $parentAsset->getKey() . '/';\n                    }\n\n                    $assetWithSamePath = Asset::getByPath($intendedPath . $asset->getKey());\n\n                    if ($assetWithSamePath != null) {\n                        $allowUpdate = false;\n                    }\n\n                    if ($asset->isLocked()) {\n                        $allowUpdate = false;\n                    }\n                }\n            }\n\n            if ($allowUpdate) {\n                if ($request->get('filename') != $asset->getFilename() && !$asset->isAllowed('rename')) {\n                    unset($updateData['filename']);\n                    Logger::debug('prevented renaming asset because of missing permissions ');\n                }\n\n                $asset->setValues($updateData);\n\n                try {\n                    $asset->save();\n                    $success = true;\n                } catch (\\Exception $e) {\n                    return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n                }\n            } else {\n                $msg = 'prevented moving asset, asset with same path+key already exists at target location or the asset is locked. ID: ' . $asset->getId();\n                Logger::debug($msg);\n\n                return $this->adminJson(['success' => $success, 'message' => $msg]);\n            }\n        } elseif ($asset->isAllowed('rename') && $request->get('filename')) {\n            //just rename\n            try {\n                $asset->setFilename($request->get('filename'));\n                $asset->save();\n                $success = true;\n            } catch (\\Exception $e) {\n                return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n            }\n        } else {\n            Logger::debug('prevented update asset because of missing permissions ');\n        }\n\n        return $this->adminJson(['success' => $success]);\n    }\n\n    /**\n     * @Route(\"/webdav{path}\", name=\"pimcore_admin_webdav\", requirements={\"path\"=\".*\"})\n     */\n    public function webdavAction()\n    {\n        $homeDir = Asset::getById(1);\n\n        try {\n            $publicDir = new Asset\\WebDAV\\Folder($homeDir);\n            $objectTree = new Asset\\WebDAV\\Tree($publicDir);\n            $server = new \\Sabre\\DAV\\Server($objectTree);\n            $server->setBaseUri($this->generateUrl('pimcore_admin_webdav', ['path' => '/']));\n\n            // lock plugin\n            /** @var \\Doctrine\\DBAL\\Driver\\PDOConnection $pdo */\n            $pdo = \\Pimcore\\Db::get()->getWrappedConnection();\n            $lockBackend = new \\Sabre\\DAV\\Locks\\Backend\\PDO($pdo);\n            $lockBackend->tableName = 'webdav_locks';\n\n            $lockPlugin = new \\Sabre\\DAV\\Locks\\Plugin($lockBackend);\n            $server->addPlugin($lockPlugin);\n\n            // browser plugin\n            $server->addPlugin(new \\Sabre\\DAV\\Browser\\Plugin());\n\n            $server->start();\n        } catch (\\Exception $e) {\n            Logger::error((string) $e);\n        }\n\n        exit;\n    }\n\n    /**\n     * @Route(\"/save\", name=\"pimcore_admin_asset_save\", methods={\"PUT\",\"POST\"})\n     *\n     * @param Request $request\n     * @param EventDispatcherInterface $eventDispatcher\n     *\n     * @return JsonResponse\n     *\n     * @throws \\Exception\n     */\n    public function saveAction(Request $request, EventDispatcherInterface $eventDispatcher)\n    {\n        $asset = Asset::getById((int) $request->get('id'));\n\n        if (!$asset) {\n            throw $this->createNotFoundException('Asset not found');\n        }\n\n        if ($asset->isAllowed('publish')) {\n            // metadata\n            if ($request->get('metadata')) {\n                $metadata = $this->decodeJson($request->get('metadata'));\n\n                $metadataEvent = new GenericEvent($this, [\n                    'id' => $asset->getId(),\n                    'metadata' => $metadata,\n                ]);\n                $eventDispatcher->dispatch($metadataEvent, AdminEvents::ASSET_METADATA_PRE_SET);\n\n                $metadata = $metadataEvent->getArgument('metadata');\n                $metadataValues = $metadata['values'];\n\n                $metadataValues = Asset\\Service::minimizeMetadata($metadataValues, 'editor');\n                $asset->setMetadataRaw($metadataValues);\n            }\n\n            // properties\n            if ($request->get('properties')) {\n                $properties = [];\n                $propertiesData = $this->decodeJson($request->get('properties'));\n\n                if (is_array($propertiesData)) {\n                    foreach ($propertiesData as $propertyName => $propertyData) {\n                        $value = $propertyData['data'];\n\n                        try {\n                            $property = new Model\\Property();\n                            $property->setType($propertyData['type']);\n                            $property->setName($propertyName);\n                            $property->setCtype('asset');\n                            $property->setDataFromEditmode($value);\n                            $property->setInheritable($propertyData['inheritable']);\n\n                            $properties[$propertyName] = $property;\n                        } catch (\\Exception $e) {\n                            Logger::err(\"Can't add \" . $propertyName . ' to asset ' . $asset->getRealFullPath());\n                        }\n                    }\n\n                    $asset->setProperties($properties);\n                }\n            }\n\n            $this->applySchedulerDataToElement($request, $asset);\n\n            if ($request->get('data')) {\n                $asset->setData($request->get('data'));\n            }\n\n            // image specific data\n            if ($asset instanceof Asset\\Image) {\n                if ($request->get('image')) {\n                    $imageData = $this->decodeJson($request->get('image'));\n                    if (isset($imageData['focalPoint'])) {\n                        $asset->setCustomSetting('focalPointX', $imageData['focalPoint']['x']);\n                        $asset->setCustomSetting('focalPointY', $imageData['focalPoint']['y']);\n                        $asset->removeCustomSetting('disableFocalPointDetection');\n                    }\n                } else {\n                    // wipe all data\n                    $asset->removeCustomSetting('focalPointX');\n                    $asset->removeCustomSetting('focalPointY');\n                    $asset->setCustomSetting('disableFocalPointDetection', true);\n                }\n            }\n\n            $asset->setUserModification($this->getAdminUser()->getId());\n            if ($request->get('task') === 'session') {\n                // save to session only\n                Asset\\Service::saveElementToSession($asset);\n            } else {\n                $asset->save();\n            }\n\n            $treeData = $this->getTreeNodeConfig($asset);\n\n            return $this->adminJson([\n                'success' => true,\n                'data' => [\n                    'versionDate' => $asset->getModificationDate(),\n                    'versionCount' => $asset->getVersionCount(),\n                ],\n                'treeData' => $treeData,\n            ]);\n        } else {\n            throw $this->createAccessDeniedHttpException();\n        }\n    }\n\n    /**\n     * @Route(\"/publish-version\", name=\"pimcore_admin_asset_publishversion\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function publishVersionAction(Request $request)\n    {\n        $id = (int)$request->get('id');\n        $version = Model\\Version::getById($id);\n        $asset = $version?->loadData();\n\n        if (!$asset) {\n            throw $this->createNotFoundException('Version with id [' . $id . \"] doesn't exist\");\n        }\n\n        $currentAsset = Asset::getById($asset->getId());\n        if ($currentAsset->isAllowed('publish')) {\n            try {\n                $asset->setUserModification($this->getAdminUser()->getId());\n                $asset->save();\n\n                $treeData = $this->getTreeNodeConfig($asset);\n\n                return $this->adminJson(['success' => true, 'treeData' => $treeData]);\n            } catch (\\Exception $e) {\n                return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n            }\n        }\n\n        throw $this->createAccessDeniedHttpException();\n    }\n\n    /**\n     * @Route(\"/show-version\", name=\"pimcore_admin_asset_showversion\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function showVersionAction(Request $request)\n    {\n        $id = (int)$request->get('id');\n        $version = Model\\Version::getById($id);\n        $asset = $version?->loadData();\n        if (!$asset) {\n            throw $this->createNotFoundException('Version with id [' . $id . \"] doesn't exist\");\n        }\n\n        if (!$asset->isAllowed('versions')) {\n            throw $this->createAccessDeniedHttpException('Permission denied, version id [' . $id . ']');\n        }\n\n        $loader = \\Pimcore::getContainer()->get('pimcore.implementation_loader.asset.metadata.data');\n\n        return $this->render(\n            '@PimcoreAdmin/Admin/Asset/showVersion' . ucfirst($asset->getType()) . '.html.twig',\n            [\n                'asset' => $asset,\n                'loader' => $loader,\n            ]\n        );\n    }\n\n    /**\n     * @Route(\"/download\", name=\"pimcore_admin_asset_download\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return StreamedResponse\n     */\n    public function downloadAction(Request $request)\n    {\n        $asset = Asset::getById((int) $request->get('id'));\n\n        if (!$asset) {\n            throw $this->createNotFoundException('Asset not found');\n        }\n\n        if (!$asset->isAllowed('view')) {\n            throw $this->createAccessDeniedException('not allowed to view asset');\n        }\n\n        $stream = $asset->getStream();\n\n        if (!is_resource($stream)) {\n            throw $this->createNotFoundException('Unable to get resource for asset ' . $asset->getId());\n        }\n\n        return new StreamedResponse(function () use ($stream) {\n            fpassthru($stream);\n        }, 200, [\n            'Content-Type' => $asset->getMimeType(),\n            'Content-Disposition' => sprintf('attachment; filename=\"%s\"', $asset->getFilename()),\n            'Content-Length' => $asset->getFileSize(),\n        ]);\n    }\n\n    /**\n     * @Route(\"/download-image-thumbnail\", name=\"pimcore_admin_asset_downloadimagethumbnail\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return BinaryFileResponse\n     */\n    public function downloadImageThumbnailAction(Request $request)\n    {\n        $image = Asset\\Image::getById((int) $request->get('id'));\n\n        if (!$image) {\n            throw $this->createNotFoundException('Asset not found');\n        }\n\n        if (!$image->isAllowed('view')) {\n            throw $this->createAccessDeniedException('not allowed to view thumbnail');\n        }\n\n        $config = null;\n        $thumbnail = null;\n        $thumbnailName = $request->get('thumbnail');\n        $thumbnailFile = null;\n        $deleteThumbnail = true;\n\n        if ($request->get('config')) {\n            $config = $this->decodeJson($request->get('config'));\n        } elseif ($request->get('type')) {\n            $predefined = [\n                'web' => [\n                    'resize_mode' => 'scaleByWidth',\n                    'width' => 3500,\n                    'dpi' => 72,\n                    'format' => 'JPEG',\n                    'quality' => 85,\n                ],\n                'print' => [\n                    'resize_mode' => 'scaleByWidth',\n                    'width' => 6000,\n                    'dpi' => 300,\n                    'format' => 'JPEG',\n                    'quality' => 95,\n                ],\n                'office' => [\n                    'resize_mode' => 'scaleByWidth',\n                    'width' => 1190,\n                    'dpi' => 144,\n                    'format' => 'JPEG',\n                    'quality' => 90,\n                ],\n            ];\n\n            $config = $predefined[$request->get('type')];\n        } elseif ($thumbnailName) {\n            $thumbnail = $image->getThumbnail($thumbnailName);\n            $deleteThumbnail = false;\n        }\n\n        if ($config) {\n            $thumbnailConfig = new Asset\\Image\\Thumbnail\\Config();\n            $thumbnailConfig->setName('pimcore-download-' . $image->getId() . '-' . md5($request->get('config')));\n\n            if ($config['resize_mode'] == 'scaleByWidth') {\n                $thumbnailConfig->addItem('scaleByWidth', [\n                    'width' => $config['width'],\n                ]);\n            } elseif ($config['resize_mode'] == 'scaleByHeight') {\n                $thumbnailConfig->addItem('scaleByHeight', [\n                    'height' => $config['height'],\n                ]);\n            } else {\n                $thumbnailConfig->addItem('resize', [\n                    'width' => $config['width'],\n                    'height' => $config['height'],\n                ]);\n            }\n\n            $thumbnailConfig->setQuality($config['quality']);\n            $thumbnailConfig->setFormat($config['format']);\n            $thumbnailConfig->setRasterizeSVG(true);\n\n            if ($thumbnailConfig->getFormat() == 'JPEG') {\n                $thumbnailConfig->setPreserveMetaData(true);\n\n                if (empty($config['quality'])) {\n                    $thumbnailConfig->setPreserveColor(true);\n                }\n            }\n\n            $thumbnail = $image->getThumbnail($thumbnailConfig);\n            $thumbnailFile = $thumbnail->getLocalFile();\n\n            $exiftool = \\Pimcore\\Tool\\Console::getExecutable('exiftool');\n            if ($thumbnailConfig->getFormat() == 'JPEG' && $exiftool && isset($config['dpi']) && $config['dpi']) {\n                $process = new Process([$exiftool, '-overwrite_original', '-xresolution=' . (int)$config['dpi'], '-yresolution=' . (int)$config['dpi'], '-resolutionunit=inches', $thumbnailFile]);\n                $process->run();\n            }\n        }\n\n        if ($thumbnail) {\n            $thumbnailFile = $thumbnailFile ?: $thumbnail->getLocalFile();\n\n            $downloadFilename = preg_replace(\n                '/\\.' . preg_quote(File::getFileExtension($image->getFilename())) . '$/i',\n                '.' . $thumbnail->getFileExtension(),\n                $image->getFilename()\n            );\n            $downloadFilename = strtolower($downloadFilename);\n\n            clearstatcache();\n\n            $response = new BinaryFileResponse($thumbnailFile);\n            $response->headers->set('Content-Type', $thumbnail->getMimeType());\n            $response->setContentDisposition(ResponseHeaderBag::DISPOSITION_ATTACHMENT, $downloadFilename);\n            $this->addThumbnailCacheHeaders($response);\n            $response->deleteFileAfterSend($deleteThumbnail);\n\n            return $response;\n        }\n\n        throw $this->createNotFoundException('Thumbnail not found');\n    }\n\n    /**\n     * @Route(\"/get-asset\", name=\"pimcore_admin_asset_getasset\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return StreamedResponse\n     */\n    public function getAssetAction(Request $request)\n    {\n        $image = Asset::getById((int)$request->get('id'));\n\n        if (!$image) {\n            throw $this->createNotFoundException('Asset not found');\n        }\n\n        if (!$image->isAllowed('view')) {\n            throw $this->createAccessDeniedException('not allowed to view asset');\n        }\n\n        $stream = $image->getStream();\n\n        if (!is_resource($stream)) {\n            throw $this->createNotFoundException('Unable to get resource for asset ' . $image->getId());\n        }\n\n        $response = new StreamedResponse(function () use ($stream) {\n            fpassthru($stream);\n        }, 200, [\n            'Content-Type' => $image->getMimeType(),\n            'Access-Control-Allow-Origin' => '*',\n        ]);\n        $this->addThumbnailCacheHeaders($response);\n\n        return $response;\n    }\n\n    /**\n     * @Route(\"/get-image-thumbnail\", name=\"pimcore_admin_asset_getimagethumbnail\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return StreamedResponse|JsonResponse|BinaryFileResponse\n     */\n    public function getImageThumbnailAction(Request $request)\n    {\n        $fileinfo = $request->get('fileinfo');\n        $image = Asset\\Image::getById((int)$request->get('id'));\n\n        if (!$image) {\n            throw $this->createNotFoundException('Asset not found');\n        }\n\n        if (!$image->isAllowed('view')) {\n            throw $this->createAccessDeniedException('not allowed to view thumbnail');\n        }\n\n        $thumbnailConfig = null;\n\n        if ($request->get('thumbnail')) {\n            $thumbnailConfig = $image->getThumbnailConfig($request->get('thumbnail'));\n        }\n        if (!$thumbnailConfig) {\n            if ($request->get('config')) {\n                $thumbnailConfig = $image->getThumbnailConfig($this->decodeJson($request->get('config')));\n            } else {\n                $thumbnailConfig = $image->getThumbnailConfig(array_merge($request->request->all(), $request->query->all()));\n            }\n        } else {\n            // no high-res images in admin mode (editmode)\n            // this is mostly because of the document's image editable, which doesn't know anything about the thumbnail\n            // configuration, so the dimensions would be incorrect (double the size)\n            $thumbnailConfig->setHighResolution(1);\n        }\n\n        $format = strtolower($thumbnailConfig->getFormat());\n        if ($format == 'source' || $format == 'print') {\n            $thumbnailConfig->setFormat('PNG');\n            $thumbnailConfig->setRasterizeSVG(true);\n        }\n\n        if ($request->get('treepreview')) {\n            $thumbnailConfig = Asset\\Image\\Thumbnail\\Config::getPreviewConfig();\n            if ($request->get('origin') === 'treeNode' && !$image->getThumbnail($thumbnailConfig)->exists()) {\n                \\Pimcore::getContainer()->get('messenger.bus.pimcore-core')->dispatch(\n                    new AssetPreviewImageMessage($image->getId())\n                );\n\n                throw $this->createNotFoundException(sprintf('Tree preview thumbnail not available for asset %s', $image->getId()));\n            }\n        }\n\n        $cropPercent = $request->get('cropPercent');\n        if ($cropPercent && filter_var($cropPercent, FILTER_VALIDATE_BOOLEAN)) {\n            $thumbnailConfig->addItemAt(0, 'cropPercent', [\n                'width' => $request->get('cropWidth'),\n                'height' => $request->get('cropHeight'),\n                'y' => $request->get('cropTop'),\n                'x' => $request->get('cropLeft'),\n            ]);\n\n            $hash = md5(Tool\\Serialize::serialize(array_merge($request->request->all(), $request->query->all())));\n            $thumbnailConfig->setName($thumbnailConfig->getName() . '_auto_' . $hash);\n        }\n\n        $thumbnail = $image->getThumbnail($thumbnailConfig);\n\n        if ($fileinfo) {\n            return $this->adminJson([\n                'width' => $thumbnail->getWidth(),\n                'height' => $thumbnail->getHeight(), ]);\n        }\n\n        $stream = $thumbnail->getStream();\n\n        if (!$stream) {\n            return new BinaryFileResponse(PIMCORE_PATH . '/bundles/AdminBundle/Resources/public/img/filetype-not-supported.svg');\n        }\n\n        $response = new StreamedResponse(function () use ($stream) {\n            fpassthru($stream);\n        }, 200, [\n            'Content-Type' => $thumbnail->getMimeType(),\n            'Access-Control-Allow-Origin', '*',\n        ]);\n\n        $this->addThumbnailCacheHeaders($response);\n\n        return $response;\n    }\n\n    /**\n     * @Route(\"/get-folder-thumbnail\", name=\"pimcore_admin_asset_getfolderthumbnail\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return StreamedResponse\n     */\n    public function getFolderThumbnailAction(Request $request)\n    {\n        $folder = null;\n\n        if ($request->get('id')) {\n            $folder = Asset\\Folder::getById((int)$request->get('id'));\n            if ($folder instanceof  Asset\\Folder) {\n                if (!$folder->isAllowed('view')) {\n                    throw $this->createAccessDeniedException('not allowed to view thumbnail');\n                }\n\n                $stream = $folder->getPreviewImage();\n                if (!$stream) {\n                    throw $this->createNotFoundException(sprintf('Tree preview thumbnail not available for asset %s', $folder->getId()));\n                } else {\n                    $response = new StreamedResponse(function () use ($stream) {\n                        fpassthru($stream);\n                    }, 200, [\n                        'Content-Type' => 'image/jpg',\n                    ]);\n                }\n\n                $this->addThumbnailCacheHeaders($response);\n\n                return $response;\n            }\n        }\n\n        throw $this->createNotFoundException('could not load asset folder');\n    }\n\n    /**\n     * @Route(\"/get-video-thumbnail\", name=\"pimcore_admin_asset_getvideothumbnail\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return StreamedResponse\n     */\n    public function getVideoThumbnailAction(Request $request)\n    {\n        $video = null;\n\n        if ($request->get('id')) {\n            $video = Asset\\Video::getById((int)$request->get('id'));\n        } elseif ($request->get('path')) {\n            $video = Asset\\Video::getByPath($request->get('path'));\n        }\n\n        if (!$video) {\n            throw $this->createNotFoundException('could not load video asset');\n        }\n\n        if (!$video->isAllowed('view')) {\n            throw $this->createAccessDeniedException('not allowed to view thumbnail');\n        }\n\n        $thumbnail = array_merge($request->request->all(), $request->query->all());\n\n        if ($request->get('treepreview')) {\n            $thumbnail = Asset\\Image\\Thumbnail\\Config::getPreviewConfig();\n        }\n\n        $time = null;\n        if (is_numeric($request->get('time'))) {\n            $time = (int)$request->get('time');\n        }\n\n        if ($request->get('settime')) {\n            $video->removeCustomSetting('image_thumbnail_asset');\n            $video->setCustomSetting('image_thumbnail_time', $time);\n            $video->save();\n        }\n\n        $image = null;\n        if ($request->get('image')) {\n            $image = Asset\\Image::getById((int)$request->get('image'));\n        }\n\n        if ($request->get('setimage') && $image) {\n            $video->removeCustomSetting('image_thumbnail_time');\n            $video->setCustomSetting('image_thumbnail_asset', $image->getId());\n            $video->save();\n        }\n\n        $thumb = $video->getImageThumbnail($thumbnail, $time, $image);\n\n        if ($request->get('origin') === 'treeNode' && !$thumb->exists()) {\n            \\Pimcore::getContainer()->get('messenger.bus.pimcore-core')->dispatch(\n                new AssetPreviewImageMessage($video->getId())\n            );\n\n            throw $this->createNotFoundException(sprintf('Tree preview thumbnail not available for asset %s', $video->getId()));\n        }\n\n        $stream = $thumb->getStream();\n        if (!$stream) {\n            throw $this->createNotFoundException('Unable to get video thumbnail for video ' . $video->getId());\n        }\n\n        $response = new StreamedResponse(function () use ($stream) {\n            fpassthru($stream);\n        }, 200, [\n            'Content-Type' => 'image/' . $thumb->getFileExtension(),\n        ]);\n\n        $this->addThumbnailCacheHeaders($response);\n\n        return $response;\n    }\n\n    /**\n     * @Route(\"/get-document-thumbnail\", name=\"pimcore_admin_asset_getdocumentthumbnail\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return StreamedResponse|BinaryFileResponse\n     */\n    public function getDocumentThumbnailAction(Request $request)\n    {\n        $document = Asset\\Document::getById((int)$request->get('id'));\n\n        if (!$document) {\n            throw $this->createNotFoundException('could not load document asset');\n        }\n\n        if (!$document->isAllowed('view')) {\n            throw $this->createAccessDeniedException('not allowed to view thumbnail');\n        }\n\n        $thumbnail = Asset\\Image\\Thumbnail\\Config::getByAutoDetect(array_merge($request->request->all(), $request->query->all()));\n\n        $format = strtolower($thumbnail->getFormat());\n        if ($format == 'source') {\n            $thumbnail->setFormat('jpeg'); // default format for documents is JPEG not PNG (=too big)\n        }\n\n        if ($request->get('treepreview')) {\n            $thumbnail = Asset\\Image\\Thumbnail\\Config::getPreviewConfig();\n        }\n\n        $page = 1;\n        if (is_numeric($request->get('page'))) {\n            $page = (int)$request->get('page');\n        }\n\n        $thumb = $document->getImageThumbnail($thumbnail, $page);\n\n        if ($request->get('origin') === 'treeNode' && !$thumb->exists()) {\n            \\Pimcore::getContainer()->get('messenger.bus.pimcore-core')->dispatch(\n                new AssetPreviewImageMessage($document->getId())\n            );\n\n            throw $this->createNotFoundException(sprintf('Tree preview thumbnail not available for asset %s', $document->getId()));\n        }\n\n        $stream = $thumb->getStream();\n        if ($stream) {\n            $response = new StreamedResponse(function () use ($stream) {\n                fpassthru($stream);\n            }, 200, [\n                'Content-Type' => 'image/' . $thumb->getFileExtension(),\n            ]);\n        } else {\n            $response = new BinaryFileResponse(PIMCORE_PATH . '/bundles/AdminBundle/Resources/public/img/filetype-not-supported.svg');\n        }\n\n        $this->addThumbnailCacheHeaders($response);\n\n        return $response;\n    }\n\n    /**\n     * @param Response $response\n     */\n    protected function addThumbnailCacheHeaders(Response $response)\n    {\n        $lifetime = 300;\n        $date = new \\DateTime('now');\n        $date->add(new \\DateInterval('PT' . $lifetime . 'S'));\n\n        $response->setMaxAge($lifetime);\n        $response->setPublic();\n        $response->setExpires($date);\n        $response->headers->set('Pragma', '');\n    }\n\n    /**\n     * @Route(\"/get-preview-document\", name=\"pimcore_admin_asset_getpreviewdocument\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return StreamedResponse\n     */\n    public function getPreviewDocumentAction(Request $request)\n    {\n        $asset = Asset\\Document::getById((int) $request->get('id'));\n\n        if (!$asset) {\n            throw $this->createNotFoundException('could not load document asset');\n        }\n\n        if ($asset->isAllowed('view')) {\n            $stream = $this->getDocumentPreviewPdf($asset);\n            if ($stream) {\n                return new StreamedResponse(function () use ($stream) {\n                    fpassthru($stream);\n                }, 200, [\n                    'Content-Type' => 'application/pdf',\n                ]);\n            } else {\n                throw $this->createNotFoundException('Unable to get preview for asset ' . $asset->getId());\n            }\n        } else {\n            throw $this->createAccessDeniedException('Access to asset ' . $asset->getId() . ' denied');\n        }\n    }\n\n    /**\n     * @param Asset\\Document $asset\n     *\n     * @return resource|null\n     */\n    protected function getDocumentPreviewPdf(Asset\\Document $asset)\n    {\n        $stream = null;\n\n        if ($asset->getMimeType() == 'application/pdf') {\n            $stream = $asset->getStream();\n        }\n\n        if (!$stream && $asset->getPageCount() && \\Pimcore\\Document::isAvailable() && \\Pimcore\\Document::isFileTypeSupported($asset->getFilename())) {\n            try {\n                $document = \\Pimcore\\Document::getInstance();\n                $stream = $document->getPdf($asset);\n            } catch (\\Exception $e) {\n                // nothing to do\n            }\n        }\n\n        return $stream;\n    }\n\n    /**\n     * @Route(\"/get-preview-video\", name=\"pimcore_admin_asset_getpreviewvideo\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function getPreviewVideoAction(Request $request)\n    {\n        $asset = Asset\\Video::getById((int) $request->get('id'));\n\n        if (!$asset) {\n            throw $this->createNotFoundException('could not load video asset');\n        }\n\n        if (!$asset->isAllowed('view')) {\n            throw $this->createAccessDeniedException('not allowed to preview');\n        }\n\n        $previewData = ['asset' => $asset];\n        $config = Asset\\Video\\Thumbnail\\Config::getPreviewConfig();\n        $thumbnail = $asset->getThumbnail($config, ['mp4']);\n\n        if ($thumbnail) {\n            $previewData['asset'] = $asset;\n            $previewData['thumbnail'] = $thumbnail;\n\n            if ($thumbnail['status'] == 'finished') {\n                return $this->render(\n                    '@PimcoreAdmin/Admin/Asset/getPreviewVideoDisplay.html.twig',\n                    $previewData\n                );\n            } else {\n                return $this->render(\n                    '@PimcoreAdmin/Admin/Asset/getPreviewVideoError.html.twig',\n                    $previewData\n                );\n            }\n        } else {\n            return $this->render(\n                '@PimcoreAdmin/Admin/Asset/getPreviewVideoError.html.twig',\n                $previewData\n            );\n        }\n    }\n\n    /**\n     * @Route(\"/serve-video-preview\", name=\"pimcore_admin_asset_servevideopreview\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return StreamedResponse\n     */\n    public function serveVideoPreviewAction(Request $request)\n    {\n        $asset = Asset\\Video::getById((int) $request->get('id'));\n\n        if (!$asset) {\n            throw $this->createNotFoundException('could not load video asset');\n        }\n\n        if (!$asset->isAllowed('view')) {\n            throw $this->createAccessDeniedException('not allowed to preview');\n        }\n\n        $config = Asset\\Video\\Thumbnail\\Config::getPreviewConfig();\n        $thumbnail = $asset->getThumbnail($config, ['mp4']);\n        $storagePath = $asset->getRealPath() . '/' . preg_replace('@^' . preg_quote($asset->getPath(), '@') . '@', '', urldecode($thumbnail['formats']['mp4']));\n\n        $storage = Tool\\Storage::get('thumbnail');\n        if ($storage->fileExists($storagePath)) {\n            $fs = $storage->fileSize($storagePath);\n            $stream = $storage->readStream($storagePath);\n\n            return new StreamedResponse(function () use ($stream) {\n                fpassthru($stream);\n            }, 200, [\n                'Content-Type' => 'video/mp4',\n                'Content-Length' => $fs,\n                'Accept-Ranges' => 'bytes',\n            ]);\n        } else {\n            throw $this->createNotFoundException('Video thumbnail not found');\n        }\n    }\n\n    /**\n     * @Route(\"/image-editor\", name=\"pimcore_admin_asset_imageeditor\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function imageEditorAction(Request $request)\n    {\n        $asset = Asset::getById((int) $request->get('id'));\n\n        if (!$asset->isAllowed('view')) {\n            throw $this->createAccessDeniedException('Not allowed to preview');\n        }\n\n        return $this->render(\n            '@PimcoreAdmin/Admin/Asset/imageEditor.html.twig',\n            ['asset' => $asset]\n        );\n    }\n\n    /**\n     * @Route(\"/image-editor-save\", name=\"pimcore_admin_asset_imageeditorsave\", methods={\"PUT\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function imageEditorSaveAction(Request $request)\n    {\n        $asset = Asset::getById((int) $request->get('id'));\n\n        if (!$asset) {\n            throw $this->createNotFoundException('Asset not found');\n        }\n\n        if (!$asset->isAllowed('publish')) {\n            throw $this->createAccessDeniedException('not allowed to publish');\n        }\n\n        $data = $request->get('dataUri');\n        $data = substr($data, strpos($data, ','));\n        $data = base64_decode($data);\n        $asset->setData($data);\n        $asset->setUserModification($this->getAdminUser()->getId());\n        $asset->save();\n\n        return $this->adminJson(['success' => true]);\n    }\n\n    /**\n     * @Route(\"/get-folder-content-preview\", name=\"pimcore_admin_asset_getfoldercontentpreview\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getFolderContentPreviewAction(Request $request, EventDispatcherInterface $eventDispatcher)\n    {\n        $allParams = array_merge($request->request->all(), $request->query->all());\n\n        $filterPrepareEvent = new GenericEvent($this, [\n            'requestParams' => $allParams,\n        ]);\n        $eventDispatcher->dispatch($filterPrepareEvent, AdminEvents::ASSET_LIST_BEFORE_FILTER_PREPARE);\n\n        $allParams = $filterPrepareEvent->getArgument('requestParams');\n\n        $folder = Asset::getById($allParams['id']);\n\n        $start = 0;\n        $limit = 10;\n\n        if ($allParams['limit']) {\n            $limit = $allParams['limit'];\n        }\n        if ($allParams['start']) {\n            $start = $allParams['start'];\n        }\n\n        $conditionFilters = [];\n        $list = new Asset\\Listing();\n        $conditionFilters[] = 'path LIKE ' . ($folder->getRealFullPath() == '/' ? \"'/%'\" : $list->quote(Helper::escapeLike($folder->getRealFullPath()) . '/%')) . \" AND type != 'folder'\";\n\n        if (!$this->getAdminUser()->isAdmin()) {\n            $userIds = $this->getAdminUser()->getRoles();\n            $userIds[] = $this->getAdminUser()->getId();\n            $conditionFilters[] = ' (\n                                                    (select list from users_workspaces_asset where userId in (' . implode(',', $userIds) . ') and LOCATE(CONCAT(path, filename),cpath)=1  ORDER BY LENGTH(cpath) DESC LIMIT 1)=1\n                                                    OR\n                                                    (select list from users_workspaces_asset where userId in (' . implode(',', $userIds) . ') and LOCATE(cpath,CONCAT(path, filename))=1  ORDER BY LENGTH(cpath) DESC LIMIT 1)=1\n                                                 )';\n        }\n\n        $condition = implode(' AND ', $conditionFilters);\n\n        $list->setCondition($condition);\n        $list->setLimit($limit);\n        $list->setOffset($start);\n        $list->setOrderKey('CAST(filename AS CHAR CHARACTER SET utf8) COLLATE utf8_general_ci ASC', false);\n\n        $beforeListLoadEvent = new GenericEvent($this, [\n            'list' => $list,\n            'context' => $allParams,\n        ]);\n        $eventDispatcher->dispatch($beforeListLoadEvent, AdminEvents::ASSET_LIST_BEFORE_LIST_LOAD);\n        /** @var Asset\\Listing $list */\n        $list = $beforeListLoadEvent->getArgument('list');\n\n        $list->load();\n\n        $assets = [];\n\n        foreach ($list as $asset) {\n            $filenameDisplay = $asset->getFilename();\n            if (strlen($filenameDisplay) > 32) {\n                $filenameDisplay = substr($filenameDisplay, 0, 25) . '...' . \\Pimcore\\File::getFileExtension($filenameDisplay);\n            }\n\n            // Like for treeGetChildsByIdAction, so we respect isAllowed method which can be extended (object DI) for custom permissions, so relying only users_workspaces_asset is insufficient and could lead security breach\n            if ($asset->isAllowed('list')) {\n                $assets[] = [\n                    'id' => $asset->getId(),\n                    'type' => $asset->getType(),\n                    'filename' => $asset->getFilename(),\n                    'filenameDisplay' => htmlspecialchars($filenameDisplay),\n                    'url' => $this->getThumbnailUrl($asset),\n                    'idPath' => $data['idPath'] = Element\\Service::getIdPath($asset),\n                ];\n            }\n        }\n\n        // We need to temporary use data key to be compatible with the ASSET_LIST_AFTER_LIST_LOAD global event\n        $result = ['data' => $assets, 'success' => true, 'total' => $list->getTotalCount()];\n\n        $afterListLoadEvent = new GenericEvent($this, [\n            'list' => $result,\n            'context' => $allParams,\n        ]);\n        $eventDispatcher->dispatch($afterListLoadEvent, AdminEvents::ASSET_LIST_AFTER_LIST_LOAD);\n        $result = $afterListLoadEvent->getArgument('list');\n\n        // Here we revert to assets key\n        return $this->adminJson(['assets' => $result['data'], 'success' => $result['success'], 'total' => $result['total']]);\n    }\n\n    /**\n     * @Route(\"/copy-info\", name=\"pimcore_admin_asset_copyinfo\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function copyInfoAction(Request $request)\n    {\n        $transactionId = time();\n        $pasteJobs = [];\n\n        Tool\\Session::useSession(function (AttributeBagInterface $session) use ($transactionId) {\n            $session->set((string) $transactionId, []);\n        }, 'pimcore_copy');\n\n        if ($request->get('type') == 'recursive') {\n            $asset = Asset::getById((int) $request->get('sourceId'));\n\n            if (!$asset) {\n                throw $this->createNotFoundException('Source not found');\n            }\n\n            // first of all the new parent\n            $pasteJobs[] = [[\n                'url' => $this->generateUrl('pimcore_admin_asset_copy'),\n                'method' => 'POST',\n                'params' => [\n                    'sourceId' => $request->get('sourceId'),\n                    'targetId' => $request->get('targetId'),\n                    'type' => 'child',\n                    'transactionId' => $transactionId,\n                    'saveParentId' => true,\n                ],\n            ]];\n\n            if ($asset->hasChildren()) {\n                // get amount of children\n                $list = new Asset\\Listing();\n                $list->setCondition('path LIKE ?', [$list->escapeLike($asset->getRealFullPath()) . '/%']);\n                $list->setOrderKey('LENGTH(path)', false);\n                $list->setOrder('ASC');\n                $childIds = $list->loadIdList();\n\n                if (count($childIds) > 0) {\n                    foreach ($childIds as $id) {\n                        $pasteJobs[] = [[\n                            'url' => $this->generateUrl('pimcore_admin_asset_copy'),\n                            'method' => 'POST',\n                            'params' => [\n                                'sourceId' => $id,\n                                'targetParentId' => $request->get('targetId'),\n                                'sourceParentId' => $request->get('sourceId'),\n                                'type' => 'child',\n                                'transactionId' => $transactionId,\n                            ],\n                        ]];\n                    }\n                }\n            }\n        } elseif ($request->get('type') == 'child' || $request->get('type') == 'replace') {\n            // the object itself is the last one\n            $pasteJobs[] = [[\n                'url' => $this->generateUrl('pimcore_admin_asset_copy'),\n                'method' => 'POST',\n                'params' => [\n                    'sourceId' => $request->get('sourceId'),\n                    'targetId' => $request->get('targetId'),\n                    'type' => $request->get('type'),\n                    'transactionId' => $transactionId,\n                ],\n            ]];\n        }\n\n        return $this->adminJson([\n            'pastejobs' => $pasteJobs,\n        ]);\n    }\n\n    /**\n     * @Route(\"/copy\", name=\"pimcore_admin_asset_copy\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function copyAction(Request $request)\n    {\n        $success = false;\n        $sourceId = (int)$request->get('sourceId');\n        $source = Asset::getById($sourceId);\n\n        $session = Tool\\Session::get('pimcore_copy');\n        $sessionBag = $session->get($request->get('transactionId'));\n\n        $targetId = (int)$request->get('targetId');\n        if ($request->get('targetParentId')) {\n            $sourceParent = Asset::getById((int) $request->get('sourceParentId'));\n\n            // this is because the key can get the prefix \"_copy\" if the target does already exists\n            if ($sessionBag['parentId']) {\n                $targetParent = Asset::getById($sessionBag['parentId']);\n            } else {\n                $targetParent = Asset::getById((int) $request->get('targetParentId'));\n            }\n\n            $targetPath = preg_replace('@^' . $sourceParent->getRealFullPath() . '@', $targetParent . '/', $source->getRealPath());\n            $target = Asset::getByPath($targetPath);\n        } else {\n            $target = Asset::getById($targetId);\n        }\n\n        if (!$target) {\n            throw $this->createNotFoundException('Target not found');\n        }\n\n        if ($target->isAllowed('create')) {\n            $source = Asset::getById($sourceId);\n            if ($source != null) {\n                if ($request->get('type') == 'child') {\n                    $newAsset = $this->_assetService->copyAsChild($target, $source);\n\n                    // this is because the key can get the prefix \"_copy\" if the target does already exists\n                    if ($request->get('saveParentId')) {\n                        $sessionBag['parentId'] = $newAsset->getId();\n                    }\n                } elseif ($request->get('type') == 'replace') {\n                    $this->_assetService->copyContents($target, $source);\n                }\n\n                $session->set($request->get('transactionId'), $sessionBag);\n                Tool\\Session::writeClose();\n\n                $success = true;\n            } else {\n                Logger::debug('prevended copy/paste because asset with same path+key already exists in this location');\n            }\n        } else {\n            Logger::error('could not execute copy/paste because of missing permissions on target [ ' . $targetId . ' ]');\n\n            throw $this->createAccessDeniedHttpException();\n        }\n\n        Tool\\Session::writeClose();\n\n        return $this->adminJson(['success' => $success]);\n    }\n\n    /**\n     * @Route(\"/download-as-zip-jobs\", name=\"pimcore_admin_asset_downloadaszipjobs\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function downloadAsZipJobsAction(Request $request)\n    {\n        $jobId = uniqid();\n        $filesPerJob = 5;\n        $jobs = [];\n        $asset = Asset::getById((int) $request->get('id'));\n\n        if (!$asset) {\n            throw $this->createNotFoundException('Asset not found');\n        }\n\n        if ($asset->isAllowed('view')) {\n            $parentPath = $asset->getRealFullPath();\n            if ($asset->getId() == 1) {\n                $parentPath = '';\n            }\n\n            $db = \\Pimcore\\Db::get();\n            $conditionFilters = [];\n            $selectedIds = explode(',', $request->get('selectedIds', ''));\n            $quotedSelectedIds = [];\n            foreach ($selectedIds as $selectedId) {\n                if ($selectedId) {\n                    $quotedSelectedIds[] = $db->quote($selectedId);\n                }\n            }\n            if (!empty($quotedSelectedIds)) {\n                //add a condition if id numbers are specified\n                $conditionFilters[] = 'id IN (' . implode(',', $quotedSelectedIds) . ')';\n            }\n            $conditionFilters[] = 'path LIKE ' . $db->quote(Helper::escapeLike($parentPath) . '/%') . ' AND type != ' . $db->quote('folder');\n            if (!$this->getAdminUser()->isAdmin()) {\n                $userIds = $this->getAdminUser()->getRoles();\n                $userIds[] = $this->getAdminUser()->getId();\n                $conditionFilters[] = ' (\n                    (select list from users_workspaces_asset where userId in (' . implode(',', $userIds) . ') and LOCATE(CONCAT(path, filename),cpath)=1  ORDER BY LENGTH(cpath) DESC LIMIT 1)=1\n                    OR\n                    (select list from users_workspaces_asset where userId in (' . implode(',', $userIds) . ') and LOCATE(cpath,CONCAT(path, filename))=1  ORDER BY LENGTH(cpath) DESC LIMIT 1)=1\n                )';\n            }\n\n            $condition = implode(' AND ', $conditionFilters);\n\n            $assetList = new Asset\\Listing();\n            $assetList->setCondition($condition);\n            $assetList->setOrderKey('LENGTH(path)', false);\n            $assetList->setOrder('ASC');\n\n            for ($i = 0; $i < ceil($assetList->getTotalCount() / $filesPerJob); $i++) {\n                $jobs[] = [[\n                    'url' => $this->generateUrl('pimcore_admin_asset_downloadaszipaddfiles'),\n                    'method' => 'GET',\n                    'params' => [\n                        'id' => $asset->getId(),\n                        'selectedIds' => implode(',', $selectedIds),\n                        'offset' => $i * $filesPerJob,\n                        'limit' => $filesPerJob,\n                        'jobId' => $jobId,\n                    ],\n                ]];\n            }\n        }\n\n        return $this->adminJson([\n            'success' => true,\n            'jobs' => $jobs,\n            'jobId' => $jobId,\n        ]);\n    }\n\n    /**\n     * @Route(\"/download-as-zip-add-files\", name=\"pimcore_admin_asset_downloadaszipaddfiles\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function downloadAsZipAddFilesAction(Request $request)\n    {\n        $zipFile = PIMCORE_SYSTEM_TEMP_DIRECTORY . '/download-zip-' . $request->get('jobId') . '.zip';\n        $asset = Asset::getById((int) $request->get('id'));\n        $success = false;\n\n        if (!$asset) {\n            throw $this->createNotFoundException('Asset not found');\n        }\n\n        if ($asset->isAllowed('view')) {\n            $zip = new \\ZipArchive();\n            if (!is_file($zipFile)) {\n                $zipState = $zip->open($zipFile, \\ZipArchive::CREATE);\n            } else {\n                $zipState = $zip->open($zipFile);\n            }\n\n            if ($zipState === true) {\n                $parentPath = $asset->getRealFullPath();\n                if ($asset->getId() == 1) {\n                    $parentPath = '';\n                }\n\n                $db = \\Pimcore\\Db::get();\n                $conditionFilters = [];\n                $selectedIds = $request->get('selectedIds', []);\n\n                if (!empty($selectedIds)) {\n                    $selectedIds = explode(',', $selectedIds);\n\n                    $quotedSelectedIds = [];\n                    foreach ($selectedIds as $selectedId) {\n                        if ($selectedId) {\n                            $quotedSelectedIds[] = $db->quote($selectedId);\n                        }\n                    }\n\n                    //add a condition if id numbers are specified\n                    $conditionFilters[] = 'id IN (' . implode(',', $quotedSelectedIds) . ')';\n                }\n                $conditionFilters[] = \"type != 'folder' AND path LIKE \" . $db->quote(Helper::escapeLike($parentPath) . '/%');\n                if (!$this->getAdminUser()->isAdmin()) {\n                    $userIds = $this->getAdminUser()->getRoles();\n                    $userIds[] = $this->getAdminUser()->getId();\n                    $conditionFilters[] = ' (\n                        (select list from users_workspaces_asset where userId in (' . implode(',', $userIds) . ') and LOCATE(CONCAT(path, filename),cpath)=1  ORDER BY LENGTH(cpath) DESC LIMIT 1)=1\n                        OR\n                        (select list from users_workspaces_asset where userId in (' . implode(',', $userIds) . ') and LOCATE(cpath,CONCAT(path, filename))=1  ORDER BY LENGTH(cpath) DESC LIMIT 1)=1\n                    )';\n                }\n\n                $condition = implode(' AND ', $conditionFilters);\n\n                $assetList = new Asset\\Listing();\n                $assetList->setCondition($condition);\n                $assetList->setOrderKey('LENGTH(path) ASC, id ASC', false);\n                $assetList->setOffset((int)$request->get('offset'));\n                $assetList->setLimit((int)$request->get('limit'));\n\n                foreach ($assetList as $a) {\n                    if ($a->isAllowed('view')) {\n                        if (!$a instanceof Asset\\Folder) {\n                            // add the file with the relative path to the parent directory\n                            $zip->addFile($a->getLocalFile(), preg_replace('@^' . preg_quote($asset->getRealPath(), '@') . '@i', '', $a->getRealFullPath()));\n                        }\n                    }\n                }\n\n                $zip->close();\n                $success = true;\n            }\n        }\n\n        return $this->adminJson([\n            'success' => $success,\n        ]);\n    }\n\n    /**\n     * @Route(\"/download-as-zip\", name=\"pimcore_admin_asset_downloadaszip\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return BinaryFileResponse\n     * Download all assets contained in the folder with parameter id as ZIP file.\n     * The suggested filename is either [folder name].zip or assets.zip for the root folder.\n     */\n    public function downloadAsZipAction(Request $request)\n    {\n        $asset = Asset::getById((int) $request->get('id'));\n        if (!$asset) {\n            throw $this->createNotFoundException('Asset not found');\n        }\n        $zipFile = PIMCORE_SYSTEM_TEMP_DIRECTORY . '/download-zip-' . $request->get('jobId') . '.zip';\n        $suggestedFilename = $asset->getFilename();\n        if (empty($suggestedFilename)) {\n            $suggestedFilename = 'assets';\n        }\n\n        $response = new BinaryFileResponse($zipFile);\n        $response->headers->set('Content-Type', 'application/zip');\n        $response->setContentDisposition(ResponseHeaderBag::DISPOSITION_ATTACHMENT, $suggestedFilename . '.zip');\n        $response->deleteFileAfterSend(true);\n\n        return $response;\n    }\n\n    /**\n     * @Route(\"/import-zip\", name=\"pimcore_admin_asset_importzip\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function importZipAction(Request $request)\n    {\n        $jobId = uniqid();\n        $filesPerJob = 5;\n        $jobs = [];\n        $asset = Asset::getById((int) $request->get('parentId'));\n\n        if (!is_file($_FILES['Filedata']['tmp_name'])) {\n            return $this->adminJson([\n                'success' => false,\n                'message' => 'Something went wrong, please check upload_max_filesize and post_max_size in your php.ini as well as the write permissions on the file system',\n            ]);\n        }\n\n        if (!$asset) {\n            throw $this->createNotFoundException('Parent asset not found');\n        }\n\n        if (!$asset->isAllowed('create')) {\n            throw $this->createAccessDeniedException('not allowed to create');\n        }\n\n        $zipFile = PIMCORE_SYSTEM_TEMP_DIRECTORY . '/' . $jobId . '.zip';\n\n        copy($_FILES['Filedata']['tmp_name'], $zipFile);\n\n        $zip = new \\ZipArchive;\n        $retCode = $zip->open($zipFile);\n        if ($retCode === true) {\n            $jobAmount = ceil($zip->numFiles / $filesPerJob);\n            for ($i = 0; $i < $jobAmount; $i++) {\n                $jobs[] = [[\n                    'url' => $this->generateUrl('pimcore_admin_asset_importzipfiles'),\n                    'method' => 'POST',\n                    'params' => [\n                        'parentId' => $asset->getId(),\n                        'offset' => $i * $filesPerJob,\n                        'limit' => $filesPerJob,\n                        'jobId' => $jobId,\n                        'last' => (($i + 1) >= $jobAmount) ? 'true' : '',\n                    ],\n                ]];\n            }\n            $zip->close();\n\n            // here we have to use this method and not the JSON action helper ($this->_helper->json()) because this will add\n            // Content-Type: application/json which fires a download window in most browsers, because this is a normal POST\n            // request and not XHR where the content-type doesn't matter\n            $responseJson = $this->encodeJson([\n                'success' => true,\n                'jobs' => $jobs,\n                'jobId' => $jobId,\n            ]);\n\n            return new Response($responseJson);\n        } else {\n            return $this->adminJson([\n                'success' => false,\n                'message' => $this->trans('could_not_open_zip_file'),\n            ]);\n        }\n    }\n\n    /**\n     * @Route(\"/import-zip-files\", name=\"pimcore_admin_asset_importzipfiles\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function importZipFilesAction(Request $request)\n    {\n        $jobId = $request->get('jobId');\n        $limit = (int)$request->get('limit');\n        $offset = (int)$request->get('offset');\n        $importAsset = Asset::getById((int) $request->get('parentId'));\n        $zipFile = PIMCORE_SYSTEM_TEMP_DIRECTORY . '/' . $jobId . '.zip';\n        $tmpDir = PIMCORE_SYSTEM_TEMP_DIRECTORY . '/zip-import';\n\n        if (!is_dir($tmpDir)) {\n            File::mkdir($tmpDir, 0777, true);\n        }\n\n        $zip = new \\ZipArchive;\n        if ($zip->open($zipFile) === true) {\n            for ($i = $offset; $i < ($offset + $limit); $i++) {\n                $path = $zip->getNameIndex($i);\n\n                if (str_starts_with($path, '__MACOSX/') || str_ends_with($path, '/Thumbs.db')) {\n                    continue;\n                }\n\n                if ($path !== false) {\n                    if ($zip->extractTo($tmpDir . '/', $path)) {\n                        $tmpFile = $tmpDir . '/' . preg_replace('@^/@', '', $path);\n\n                        $filename = Element\\Service::getValidKey(basename($path), 'asset');\n\n                        $relativePath = '';\n                        if (dirname($path) != '.') {\n                            $relativePath = dirname($path);\n                        }\n\n                        $parentPath = $importAsset->getRealFullPath() . '/' . preg_replace('@^/@', '', $relativePath);\n                        $parent = Asset\\Service::createFolderByPath($parentPath);\n\n                        // check for duplicate filename\n                        $filename = $this->getSafeFilename($parent->getRealFullPath(), $filename);\n\n                        if ($parent->isAllowed('create')) {\n                            $asset = Asset::create($parent->getId(), [\n                                'filename' => $filename,\n                                'sourcePath' => $tmpFile,\n                                'userOwner' => $this->getAdminUser()->getId(),\n                                'userModification' => $this->getAdminUser()->getId(),\n                            ]);\n\n                            @unlink($tmpFile);\n                        } else {\n                            Logger::debug('prevented creating asset because of missing permissions');\n                        }\n                    }\n                }\n            }\n            $zip->close();\n        }\n\n        if ($request->get('last')) {\n            unlink($zipFile);\n        }\n\n        return $this->adminJson([\n            'success' => true,\n        ]);\n    }\n\n    /**\n     * @Route(\"/import-server\", name=\"pimcore_admin_asset_importserver\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function importServerAction(Request $request)\n    {\n        $success = true;\n        $filesPerJob = 5;\n        $jobs = [];\n        $importDirectory = str_replace('/fileexplorer', PIMCORE_PROJECT_ROOT, $request->get('serverPath'));\n        if (preg_match('@^' . preg_quote(PIMCORE_PROJECT_ROOT, '@') . '@', $importDirectory) && is_dir($importDirectory)) {\n            $this->checkForPharStreamWrapper($importDirectory);\n            $files = rscandir($importDirectory . '/');\n            $count = count($files);\n            $jobFiles = [];\n\n            for ($i = 0; $i < $count; $i++) {\n                if (is_dir($files[$i])) {\n                    continue;\n                }\n\n                $jobFiles[] = preg_replace('@^' . preg_quote($importDirectory, '@') . '@', '', $files[$i]);\n\n                if (count($jobFiles) >= $filesPerJob || $i >= ($count - 1)) {\n                    $relativeImportDirectory = preg_replace('@^' . preg_quote(PIMCORE_PROJECT_ROOT, '@') . '@', '', $importDirectory);\n                    $jobs[] = [[\n                        'url' => $this->generateUrl('pimcore_admin_asset_importserverfiles'),\n                        'method' => 'POST',\n                        'params' => [\n                            'parentId' => $request->get('parentId'),\n                            'serverPath' => $relativeImportDirectory,\n                            'files' => implode('::', $jobFiles),\n                        ],\n                    ]];\n                    $jobFiles = [];\n                }\n            }\n        }\n\n        return $this->adminJson([\n            'success' => $success,\n            'jobs' => $jobs,\n        ]);\n    }\n\n    /**\n     * @Route(\"/import-server-files\", name=\"pimcore_admin_asset_importserverfiles\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function importServerFilesAction(Request $request)\n    {\n        $assetFolder = Asset::getById((int) $request->get('parentId'));\n        if (!$assetFolder) {\n            throw $this->createNotFoundException('Parent asset not found');\n        }\n\n        $serverPath = realpath(PIMCORE_PROJECT_ROOT . $request->get('serverPath'));\n        if(!str_starts_with($serverPath, rtrim(str_replace('../', '', PIMCORE_PROJECT_ROOT), './'))) {\n            throw $this->createAccessDeniedException('Please do not navigate out of the web root directory!');\n        }\n\n        $files = explode('::', $request->get('files'));\n\n        foreach ($files as $file) {\n            $absolutePath = $serverPath . $file;\n            $this->checkForPharStreamWrapper($absolutePath);\n            if (is_file($absolutePath)) {\n                $relFolderPath = str_replace('\\\\', '/', dirname($file));\n                $folder = Asset\\Service::createFolderByPath($assetFolder->getRealFullPath() . $relFolderPath);\n                $filename = basename($file);\n\n                // check for duplicate filename\n                $filename = Element\\Service::getValidKey($filename, 'asset');\n                $filename = $this->getSafeFilename($folder->getRealFullPath(), $filename);\n\n                if ($assetFolder->isAllowed('create')) {\n                    $asset = Asset::create($folder->getId(), [\n                        'filename' => $filename,\n                        'sourcePath' => $absolutePath,\n                        'userOwner' => $this->getAdminUser()->getId(),\n                        'userModification' => $this->getAdminUser()->getId(),\n                    ]);\n                } else {\n                    Logger::debug('prevented creating asset because of missing permissions ');\n                }\n            }\n        }\n\n        return $this->adminJson([\n            'success' => true,\n        ]);\n    }\n\n    protected function checkForPharStreamWrapper($path)\n    {\n        if (stripos($path, 'phar://') !== false) {\n            throw $this->createAccessDeniedException('Using PHAR files is not allowed!');\n        }\n    }\n\n    /**\n     * @Route(\"/import-url\", name=\"pimcore_admin_asset_importurl\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     *\n     * @throws \\Exception\n     */\n    public function importUrlAction(Request $request)\n    {\n        $success = true;\n\n        $data = Tool::getHttpData($request->get('url'));\n        $filename = basename($request->get('url'));\n        $parentId = $request->get('id');\n        $parentAsset = Asset::getById((int)$parentId);\n\n        if (!$parentAsset) {\n            throw $this->createNotFoundException('Parent asset not found');\n        }\n\n        $filename = Element\\Service::getValidKey($filename, 'asset');\n        $filename = $this->getSafeFilename($parentAsset->getRealFullPath(), $filename);\n\n        if (empty($filename)) {\n            throw new \\Exception('The filename of the asset is empty');\n        }\n\n        // check for duplicate filename\n        $filename = $this->getSafeFilename($parentAsset->getRealFullPath(), $filename);\n\n        if ($parentAsset->isAllowed('create')) {\n            $asset = Asset::create($parentId, [\n                'filename' => $filename,\n                'data' => $data,\n                'userOwner' => $this->getAdminUser()->getId(),\n                'userModification' => $this->getAdminUser()->getId(),\n            ]);\n            $success = true;\n        } else {\n            Logger::debug('prevented creating asset because of missing permissions');\n        }\n\n        return $this->adminJson(['success' => $success]);\n    }\n\n    /**\n     * @Route(\"/clear-thumbnail\", name=\"pimcore_admin_asset_clearthumbnail\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function clearThumbnailAction(Request $request)\n    {\n        $success = false;\n\n        if ($asset = Asset::getById((int) $request->get('id'))) {\n            if (method_exists($asset, 'clearThumbnails')) {\n                if (!$asset->isAllowed('publish')) {\n                    throw $this->createAccessDeniedException('not allowed to publish');\n                }\n\n                $asset->clearThumbnails(true); // force clear\n                $asset->save();\n\n                $success = true;\n            }\n        }\n\n        return $this->adminJson(['success' => $success]);\n    }\n\n    /**\n     * @Route(\"/grid-proxy\", name=\"pimcore_admin_asset_gridproxy\", methods={\"GET\", \"POST\", \"PUT\"})\n     *\n     * @param Request $request\n     * @param EventDispatcherInterface $eventDispatcher\n     * @param GridHelperService $gridHelperService\n     * @param CsrfProtectionHandler $csrfProtection\n     *\n     * @return JsonResponse\n     */\n    public function gridProxyAction(Request $request, EventDispatcherInterface $eventDispatcher, GridHelperService $gridHelperService, CsrfProtectionHandler $csrfProtection)\n    {\n        $allParams = array_merge($request->request->all(), $request->query->all());\n\n        $filterPrepareEvent = new GenericEvent($this, [\n            'requestParams' => $allParams,\n        ]);\n        $language = $request->get('language') != 'default' ? $request->get('language') : null;\n\n        $eventDispatcher->dispatch($filterPrepareEvent, AdminEvents::ASSET_LIST_BEFORE_FILTER_PREPARE);\n\n        $allParams = $filterPrepareEvent->getArgument('requestParams');\n\n        $loader = \\Pimcore::getContainer()->get('pimcore.implementation_loader.asset.metadata.data');\n\n        if (isset($allParams['data']) && $allParams['data']) {\n            $csrfProtection->checkCsrfToken($request);\n            if ($allParams['xaction'] == 'update') {\n                try {\n                    $data = $this->decodeJson($allParams['data']);\n\n                    $updateEvent = new GenericEvent($this, [\n                        'data' => $data,\n                        'processed' => false,\n                    ]);\n\n                    $eventDispatcher->dispatch($updateEvent, AdminEvents::ASSET_LIST_BEFORE_UPDATE);\n\n                    $processed = $updateEvent->getArgument('processed');\n\n                    if ($processed) {\n                        // update already processed by event handler\n                        return $this->adminJson(['success' => true]);\n                    }\n\n                    $data = $updateEvent->getArgument('data');\n\n                    // save\n                    $asset = Asset::getById($data['id']);\n\n                    if (!$asset) {\n                        throw $this->createNotFoundException('Asset not found');\n                    }\n\n                    if (!$asset->isAllowed('publish')) {\n                        throw $this->createAccessDeniedException(\"Permission denied. You don't have the rights to save this asset.\");\n                    }\n\n                    $metadata = $asset->getMetadata(null, null, false, true);\n                    $dirty = false;\n\n                    unset($data['id']);\n                    foreach ($data as $key => $value) {\n                        $fieldDef = explode('~', $key);\n                        $key = $fieldDef[0];\n                        if (isset($fieldDef[1])) {\n                            $language = ($fieldDef[1] == 'none' ? '' : $fieldDef[1]);\n                        }\n\n                        foreach ($metadata as $idx => &$em) {\n                            if ($em['name'] == $key && $em['language'] == $language) {\n                                try {\n                                    $dataImpl = $loader->build($em['type']);\n                                    $value = $dataImpl->getDataFromListfolderGrid($value, $em);\n                                } catch (UnsupportedException $le) {\n                                    Logger::error('could not resolve metadata implementation for ' . $em['type']);\n                                }\n\n                                $em['data'] = $value;\n                                $dirty = true;\n\n                                break;\n                            }\n                        }\n\n                        if (!$dirty) {\n                            $defaulMetadata = ['title', 'alt', 'copyright'];\n                            if (in_array($key, $defaulMetadata)) {\n                                $newEm = [\n                                    'name' => $key,\n                                    'language' => $language,\n                                    'type' => 'input',\n                                    'data' => $value,\n                                ];\n\n                                try {\n                                    $dataImpl = $loader->build($newEm['type']);\n                                    $newEm['data'] = $dataImpl->getDataFromListfolderGrid($value, $newEm);\n                                } catch (UnsupportedException $le) {\n                                    Logger::error('could not resolve metadata implementation for ' . $newEm['type']);\n                                }\n\n                                $metadata[] = $newEm;\n\n                                $dirty = true;\n                            } else {\n                                $predefined = Model\\Metadata\\Predefined::getByName($key);\n                                if ($predefined && (empty($predefined->getTargetSubtype())\n                                        || $predefined->getTargetSubtype() == $asset->getType())) {\n                                    $newEm = [\n                                        'name' => $key,\n                                        'language' => $language,\n                                        'type' => $predefined->getType(),\n                                        'data' => $value,\n                                    ];\n\n                                    try {\n                                        $dataImpl = $loader->build($newEm['type']);\n                                        $newEm['data'] = $dataImpl->getDataFromListfolderGrid($value, $newEm);\n                                    } catch (UnsupportedException $le) {\n                                        Logger::error('could not resolve metadata implementation for ' . $newEm['type']);\n                                    }\n\n                                    $metadata[] = $newEm;\n                                    $dirty = true;\n                                }\n                            }\n                        }\n                    }\n\n                    if ($dirty) {\n                        // $metadata = Asset\\Service::minimizeMetadata($metadata, \"grid\");\n                        $asset->setMetadataRaw($metadata);\n                        $asset->save();\n\n                        return $this->adminJson(['success' => true]);\n                    }\n\n                    return $this->adminJson(['success' => false, 'message' => 'something went wrong.']);\n                } catch (\\Exception $e) {\n                    return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n                }\n            }\n        } else {\n            $list = $gridHelperService->prepareAssetListingForGrid($allParams, $this->getAdminUser());\n\n            $beforeListLoadEvent = new GenericEvent($this, [\n                'list' => $list,\n                'context' => $allParams,\n            ]);\n            $eventDispatcher->dispatch($beforeListLoadEvent, AdminEvents::ASSET_LIST_BEFORE_LIST_LOAD);\n            /** @var Asset\\Listing $list */\n            $list = $beforeListLoadEvent->getArgument('list');\n\n            $list->load();\n\n            $assets = [];\n            foreach ($list->getAssets() as $index => $asset) {\n                // Like for treeGetChildsByIdAction, so we respect isAllowed method which can be extended (object DI) for custom permissions, so relying only users_workspaces_asset is insufficient and could lead security breach\n                if ($asset->isAllowed('list')) {\n                    $a = Asset\\Service::gridAssetData($asset, $allParams['fields'], $allParams['language'] ?? '');\n                    $assets[] = $a;\n                }\n            }\n\n            $result = ['data' => $assets, 'success' => true, 'total' => $list->getTotalCount()];\n\n            $afterListLoadEvent = new GenericEvent($this, [\n                'list' => $result,\n                'context' => $allParams,\n            ]);\n            $eventDispatcher->dispatch($afterListLoadEvent, AdminEvents::ASSET_LIST_AFTER_LIST_LOAD);\n            $result = $afterListLoadEvent->getArgument('list');\n\n            return $this->adminJson($result);\n        }\n\n        return $this->adminJson(['success' => false]);\n    }\n\n    /**\n     * @Route(\"/get-text\", name=\"pimcore_admin_asset_gettext\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getTextAction(Request $request)\n    {\n        $asset = Asset::getById((int) $request->get('id'));\n\n        if (!$asset) {\n            throw $this->createNotFoundException('Asset not found');\n        }\n\n        if (!$asset->isAllowed('view')) {\n            throw $this->createAccessDeniedException('not allowed to view');\n        }\n\n        $page = $request->get('page');\n        $text = null;\n        if ($asset instanceof Asset\\Document) {\n            $text = $asset->getText($page);\n        }\n\n        return $this->adminJson(['success' => 'true', 'text' => $text]);\n    }\n\n    /**\n     * @Route(\"/detect-image-features\", name=\"pimcore_admin_asset_detectimagefeatures\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function detectImageFeaturesAction(Request $request)\n    {\n        $asset = Asset\\Image::getById((int)$request->get('id'));\n        if (!$asset instanceof Asset) {\n            return $this->adminJson(['success' => false, 'message' => \"asset doesn't exist\"]);\n        }\n\n        if ($asset->isAllowed('publish')) {\n            $asset->detectFaces();\n            $asset->removeCustomSetting('disableImageFeatureAutoDetection');\n            $asset->save();\n\n            return $this->adminJson(['success' => true]);\n        }\n\n        throw $this->createAccessDeniedHttpException();\n    }\n\n    /**\n     * @Route(\"/delete-image-features\", name=\"pimcore_admin_asset_deleteimagefeatures\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function deleteImageFeaturesAction(Request $request)\n    {\n        $asset = Asset::getById((int)$request->get('id'));\n        if (!$asset instanceof Asset) {\n            return $this->adminJson(['success' => false, 'message' => \"asset doesn't exist\"]);\n        }\n\n        if ($asset->isAllowed('publish')) {\n            $asset->removeCustomSetting('faceCoordinates');\n            $asset->setCustomSetting('disableImageFeatureAutoDetection', true);\n            $asset->save();\n\n            return $this->adminJson(['success' => true]);\n        }\n\n        throw $this->createAccessDeniedHttpException();\n    }\n\n    /**\n     * @param ControllerEvent $event\n     */\n    public function onKernelControllerEvent(ControllerEvent $event)\n    {\n        if (!$event->isMainRequest()) {\n            return;\n        }\n\n        $this->checkActionPermission($event, 'assets', [\n            'getImageThumbnailAction', 'getVideoThumbnailAction', 'getDocumentThumbnailAction',\n        ]);\n\n        $this->_assetService = new Asset\\Service($this->getAdminUser());\n    }\n\n    /**\n     * @throws ValidationException\n     */\n    private function validateManyToManyRelationAssetType(array $context, string $filename, string $sourcePath): void\n    {\n        if (isset($context['containerType'], $context['objectId'], $context['fieldname'])\n            && 'object' === $context['containerType']\n            && $object = Concrete::getById($context['objectId'])\n        ) {\n            $fieldDefinition = $object->getClass()?->getFieldDefinition($context['fieldname']);\n            if (!$fieldDefinition instanceof ManyToManyRelation) {\n                return;\n            }\n\n            $mimeType = MimeTypes::getDefault()->guessMimeType($sourcePath);\n            $type = Asset::getTypeFromMimeMapping($mimeType, $filename);\n\n            $allowedAssetTypes = $fieldDefinition->getAssetTypes();\n            $allowedAssetTypes = array_column($allowedAssetTypes, 'assetTypes');\n\n            if (\n                !(\n                    $fieldDefinition->getAssetsAllowed()\n                    && ($allowedAssetTypes === [] || in_array($type, $allowedAssetTypes, true))\n                )\n            ) {\n                throw new ValidationException(sprintf('Invalid relation in field `%s` [type: %s]', $context['fieldname'], $type));\n            }\n        }\n    }\n}\n", "/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n * @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n * @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\npimcore.registerNS(\"pimcore.asset.tree\");\npimcore.asset.tree = Class.create({\n\n    treeDataUrl: null,\n\n    initialize: function(config, perspectiveCfg) {\n        this.treeDataUrl = Routing.generate('pimcore_admin_asset_treegetchildsbyid');\n        this.perspectiveCfg = perspectiveCfg;\n        if (!perspectiveCfg) {\n            this.perspectiveCfg = {\n                position: \"left\"\n            };\n        }\n\n        this.perspectiveCfg = new pimcore.perspective(this.perspectiveCfg);\n        this.position = this.perspectiveCfg.position ? this.perspectiveCfg.position : \"left\";\n\n        if (!config) {\n            this.config = {\n                rootId: 1,\n                rootVisible: true,\n                loaderBaseParams: {},\n                treeId: \"pimcore_panel_tree_assets\",\n                treeIconCls: \"pimcore_icon_main_tree_asset pimcore_icon_material\",\n                treeTitle: t('assets'),\n                parentPanel: Ext.getCmp(\"pimcore_panel_tree_\" + this.position),\n            };\n        }\n        else {\n            this.config = config;\n        }\n\n        pimcore.layout.treepanelmanager.register(this.config.treeId);\n\n        // get root node config\n        Ext.Ajax.request({\n            url: Routing.generate('pimcore_admin_asset_treegetroot'),\n            params: {\n                id: this.config.rootId,\n                view: this.config.customViewId,\n                elementType: \"asset\"\n            },\n            success: function (response) {\n                var res = Ext.decode(response.responseText);\n                var callback = function () {};\n                if(res[\"id\"]) {\n                    callback = this.init.bind(this, res);\n                }\n                pimcore.layout.treepanelmanager.initPanel(this.config.treeId, callback);\n            }.bind(this)\n        });\n    },\n\n    init: function(rootNodeConfig) {\n\n        var itemsPerPage = pimcore.settings['asset_tree_paging_limit'];\n\n        let rootNodeConfigText = t('home');\n        let rootNodeConfigIconCls = \"pimcore_icon_home\";\n        if(this.config.customViewId !== undefined && rootNodeConfig.id !== 1) {\n            rootNodeConfigText = rootNodeConfig.key;\n            rootNodeConfigIconCls = rootNodeConfig.iconCls;\n        }\n\n        rootNodeConfig.text = rootNodeConfigText;\n        rootNodeConfig.allowDrag = true;\n        rootNodeConfig.id = \"\" + rootNodeConfig.id;\n        rootNodeConfig.iconCls = rootNodeConfigIconCls;\n        rootNodeConfig.cls = \"pimcore_tree_node_root\";\n        rootNodeConfig.expanded = true;\n\n        var store = Ext.create('pimcore.data.PagingTreeStore', {\n            autoLoad: false,\n            autoSync: false,\n            proxy: {\n                type: 'ajax',\n                url: this.treeDataUrl,\n                reader: {\n                    type: 'json',\n                    totalProperty : 'total',\n                    rootProperty: 'nodes'\n\n                },\n                extraParams: {\n                    limit: itemsPerPage,\n                    view: this.config.customViewId\n                },\n                timeout: 60000\n            },\n            pageSize: itemsPerPage,\n            root: rootNodeConfig\n        });\n\n        // assets\n        this.tree = Ext.create('pimcore.tree.Panel', {\n            selModel : {\n                mode : 'MULTI'\n            },\n            store: store,\n            autoLoad: false,\n            id: this.config.treeId,\n            title: this.config.treeTitle,\n            iconCls: this.config.treeIconCls,\n            cls: this.config['rootVisible'] ? '' : 'pimcore_tree_no_root_node',\n            autoScroll:true,\n            animate:false,\n            containerScroll: true,\n            ddAppendOnly: true,\n            rootVisible: this.config.rootVisible,\n            forceLayout: true,\n            bufferedRenderer: false,\n            border: false,\n            viewConfig: {\n                plugins: {\n                    ptype: 'treeviewdragdrop',\n                    appendOnly: true,\n                    ddGroup: \"element\"\n                },\n                listeners: {\n                    beforedrop: function (node, data) {\n                    },\n                    nodedragover: this.onTreeNodeOver.bind(this),\n                    startdrag: function() {\n                    }\n                },\n                xtype: 'pimcoretreeview'\n\n            },\n            tools: [{\n                type: \"right\",\n                handler: pimcore.layout.treepanelmanager.toRight.bind(this),\n                hidden: this.position == \"right\"\n            },{\n                type: \"left\",\n                handler: pimcore.layout.treepanelmanager.toLeft.bind(this),\n                hidden: this.position == \"left\"\n            }],\n            // root: rootNodeConfig,\n            listeners: this.getTreeNodeListeners()\n        });\n\n        //TODO\n        this.tree.getView().on(\"itemafterrender\",this.enableHtml5Upload.bind(this));\n        this.tree.on(\"render\", function () {\n            this.getRootNode().expand();\n        });\n        this.tree.on(\"afterrender\", function () {\n            try {\n                this.tree.loadMask = new Ext.LoadMask({\n                    target: this.tree,\n                    msg: t(\"please_wait\"),\n                    hidden: true\n                });\n\n                // add listener to root node -> other nodes are added om the \"append\" event -> see this.enableHtml5Upload()\n                this.addHtml5DragListener(this.tree.getRootNode());\n\n                // html5 upload\n                if (window[\"FileList\"]) {\n                    this.tree.getEl().dom.addEventListener(\"drop\", function (e) {\n\n                        e.stopPropagation();\n                        e.preventDefault();\n\n                        pimcore.helpers.treeNodeThumbnailPreviewHide();\n\n                        try {\n                            var selection = this.tree.getSelection();\n                            if (!selection) {\n                                return true;\n                            }\n                            if (selection.length < 1) {\n                                return true;\n                            }\n                        } catch (e2) {\n                            return true;\n                        }\n\n                        var node = selection[0];\n                        this.uploadFileList(e.dataTransfer, node);\n\n                    }.bind(this), true);\n                }\n            } catch (e) {\n                console.log(e);\n            }\n        }.bind(this));\n\n        if(!pimcore.settings.asset_disable_tree_preview) {\n            this.tree.on(\"itemmouseenter\", pimcore.helpers.treeNodeThumbnailPreview.bind(this));\n            this.tree.on(\"itemmouseleave\", pimcore.helpers.treeNodeThumbnailPreviewHide.bind(this));\n        }\n\n        store.on(\"nodebeforeexpand\", function (node) {\n            pimcore.helpers.addTreeNodeLoadingIndicator(\"asset\", node.data.id, false);\n        });\n\n        store.on(\"nodeexpand\", function (node, index, item, eOpts) {\n            pimcore.helpers.removeTreeNodeLoadingIndicator(\"asset\", node.data.id);\n        });\n\n        this.config.parentPanel.insert(this.config.index, this.tree);\n        this.config.parentPanel.updateLayout();\n\n        if (!this.config.parentPanel.alreadyExpanded && this.perspectiveCfg.expanded) {\n            this.config.parentPanel.alreadyExpanded = true;\n            this.tree.expand();\n        }\n    },\n\n    uploadFileList: function (dataTransfer, parentNode) {\n\n        var file;\n        this.activeUploads = 0;\n        var overwriteConfirmMessageBoxes = [];\n\n        var win = new Ext.Window({\n            items: [],\n            modal: true,\n            closable: false,\n            bodyStyle: \"padding:10px;\",\n            width: 500,\n            autoHeight: true,\n            autoScroll: true\n        });\n        win.show();\n\n        var doFileUpload = function (file, path) {\n\n            if(typeof path == \"undefined\") {\n                path = \"\";\n            }\n\n            this.activeUploads++;\n\n            var pbar = new Ext.ProgressBar({\n                width:465,\n                text: file.name,\n                style: \"margin-bottom: 5px\"\n            });\n\n            win.add(pbar);\n            win.updateLayout();\n\n            var finishedErrorHandler = function (e) {\n                this.activeUploads--;\n                win.remove(pbar);\n\n                if(this.activeUploads < 1) {\n                    win.close();\n                    pimcore.elementservice.refreshNodeAllTrees(\"asset\", parentNode.get(\"id\"));\n                }\n            }.bind(this);\n\n            var errorHandler = function (e) {\n                var res = Ext.decode(e[\"responseText\"]);\n                pimcore.helpers.showNotification(t(\"error\"), res.message ? res.message : t(\"error\"), \"error\", e[\"responseText\"]);\n                finishedErrorHandler();\n            }.bind(this);\n\n            Ext.Ajax.request({\n                url: Routing.generate('pimcore_admin_asset_exists'),\n                params: {\n                    parentId: parentNode.id,\n                    filename: file.name\n                },\n                async: false,\n                success: function (response) {\n                    var res = Ext.decode(response.responseText);\n\n                    var uploadFunction = function(allowOverwrite) {\n                        pimcore.helpers.uploadAssetFromFileObject(file,\n                            Routing.generate('pimcore_admin_asset_addasset', { parentId: parentNode.id, dir: path, allowOverwrite: allowOverwrite ? 1 : 0 }),\n                            finishedErrorHandler,\n                            function (evt) {\n                                //progress\n                                if (evt.lengthComputable) {\n                                    var percentComplete = evt.loaded / evt.total;\n                                    var progressText = file.name + \" ( \" + Math.floor(percentComplete * 100) + \"% )\";\n                                    if (percentComplete == 1) {\n                                        progressText = file.name + \" \" + t(\"please_wait\");\n                                    }\n\n                                    pbar.updateProgress(percentComplete, progressText);\n                                }\n                            },\n                            errorHandler\n                        );\n                    };\n\n                    if (res.exists) {\n                        var messageBox = new Ext.window.MessageBox();\n                        overwriteConfirmMessageBoxes.push(messageBox);\n                        messageBox.show({\n                            title: t('file_exists'),\n                            msg: t('asset_upload_want_to_overwrite').replace('%s', file.name),\n                            buttons: Ext.Msg.OK & Ext.Msg.YES & Ext.Msg.NO,\n                            buttonText: { ok: t('asset_upload_overwrite'), yes: t('asset_upload_keep_both'), no: t('asset_upload_overwrite_all') },\n                            prompt: false,\n                            icon: Ext.MessageBox.QUESTION,\n                            fn: function (action) {\n                                if (action === 'ok') {\n                                    uploadFunction(true);\n                                } else if (action === 'yes') {\n                                    uploadFunction(false);\n                                } else if (action === 'no') {\n                                    Ext.each(overwriteConfirmMessageBoxes, function(messageBox) {\n                                        if (messageBox) {\n                                            messageBox.down('button[itemId=ok]').fireHandler();\n                                        }\n                                    });\n                                } else if (action === 'cancel') {\n                                    finishedErrorHandler();\n                                }\n                            }\n                        });\n                    } else {\n                        uploadFunction();\n                    }\n                }\n            });\n        }.bind(this);\n\n        if(dataTransfer[\"items\"] && dataTransfer.items[0] && dataTransfer.items[0].webkitGetAsEntry) {\n            // chrome\n            var traverseFileTree = function (item, path) {\n                path = path || \"\";\n                if (item.isFile) {\n                    // Get file\n                    item.file(function (file) {\n                        doFileUpload(file, path);\n                    }.bind(this));\n                } else if (item.isDirectory) {\n                    // Get folder contents\n                    var dirReader = item.createReader();\n                    dirReader.readEntries(function (entries) {\n                        for (var i = 0; i < entries.length; i++) {\n                            traverseFileTree(entries[i], path + item.name + \"/\");\n                        }\n                    });\n                }\n            }.bind(this);\n\n            for (var i = 0; i < dataTransfer.items.length; i++) {\n                // webkitGetAsEntry is where the magic happens\n                var item = dataTransfer.items[i].webkitGetAsEntry();\n                if (item) {\n                    traverseFileTree(item);\n                }\n            }\n        } else if(dataTransfer[\"files\"]) {\n            // default filelist upload\n            for (var i=0; i<dataTransfer[\"files\"].length; i++) {\n                file = dataTransfer[\"files\"][i];\n\n                if (window.FileList && file.name && file.size) { // check for size (folder has size=0)\n                    doFileUpload(file);\n                } else if (!empty(file.type) && file.size < 1) { //throw error for 0 byte file\n                    Ext.MessageBox.alert(t('error'), t('error_empty_file_upload'));\n                    win.close();\n                }\n            }\n\n            // if no files are uploaded (doesn't match criteria, ...) close the progress win immediately\n            if(!this.activeUploads) {\n                win.close();\n            }\n        }\n\n        // check in 5 sec. if there're active uploads\n        // if not, close the progressbar\n        // this is necessary since the folder upload is async, so we don't know if the progress is\n        // necessary or not, not really perfect solution, but works as it should\n        window.setTimeout(function () {\n            if(!this.activeUploads) {\n                win.close();\n            }\n        }.bind(this), 5000);\n    },\n\n    getTreeNodeListeners: function () {\n        var treeNodeListeners = {\n            'itemclick' : this.onTreeNodeClick,\n            \"itemcontextmenu\": this.onTreeNodeContextmenu.bind(this),\n            \"itemmove\": this.onTreeNodeMove.bind(this),\n            \"beforeitemmove\": this.onTreeNodeBeforeMove.bind(this),\n            \"itemmouseenter\": function (el, record, item, index, e, eOpts) {\n                pimcore.helpers.treeToolTipShow(el, record, item);\n            },\n            \"itemmouseleave\": function () {\n                pimcore.helpers.treeToolTipHide();\n            }\n        };\n\n        return treeNodeListeners;\n    },\n\n    onTreeNodeClick: function (tree, record, item, index, event, eOpts ) {\n        if (event.ctrlKey === false && event.shiftKey === false && event.altKey === false) {\n            if (record.data.permissions.view) {\n                pimcore.helpers.treeNodeThumbnailPreviewHide();\n                pimcore.helpers.openAsset(record.data.id, record.data.type);\n            }\n        }\n    },\n\n\n    onTreeNodeOver: function (targetNode, position, dragData, e, eOpts ) {\n        var node = dragData.records[0];\n        if (node.getOwnerTree() != targetNode.getOwnerTree()) {\n            return false;\n        }\n        // check for permission\n        try {\n            if (node.data.permissions.settings) {\n                return true;\n            }\n        }\n        catch (e) {\n            console.log(e);\n        }\n\n        return false;\n    },\n\n    onTreeNodeMove: function (node, oldParent, newParent, index, eOpts ) {\n\n        var tree = node.getOwnerTree();\n\n        pimcore.elementservice.updateAsset(node.data.id, {\n            parentId: newParent.data.id\n        }, function (newParent, oldParent, tree, response) {\n            try{\n                var rdata = Ext.decode(response.responseText);\n                if (rdata && rdata.success) {\n                    // set new pathes\n                    var newBasePath = newParent.data.path;\n                    if (newBasePath == \"/\") {\n                        newBasePath = \"\";\n                    }\n                    node.data.basePath = newBasePath;\n                    node.data.path = node.data.basePath + \"/\" + node.data.text;\n                    pimcore.elementservice.nodeMoved(\"asset\", oldParent, newParent);\n                }\n                else {\n                    this.tree.loadMask.hide();\n                    pimcore.helpers.showNotification(t(\"error\"), t(\"cant_move_node_to_target\"),\n                        \"error\",t(rdata.message));\n                    // we have to delay refresh between two nodes,\n                    // as there could be parent child relationship leading to race condition\n                    window.setTimeout(function () {\n                        pimcore.elementservice.refreshNode(oldParent);\n                    }, 500);\n                    pimcore.elementservice.refreshNode(newParent);\n                }\n            } catch(e){\n                this.tree.loadMask.hide();\n                pimcore.helpers.showNotification(t(\"error\"), t(\"cant_move_node_to_target\"), \"error\");\n                // we have to delay refresh between two nodes,\n                // as there could be parent child relationship leading to race condition\n                window.setTimeout(function () {\n                    pimcore.elementservice.refreshNode(oldParent);\n                }, 500);\n                pimcore.elementservice.refreshNode(newParent);\n            }\n            this.tree.loadMask.hide();\n\n        }.bind(this, newParent, oldParent, tree));\n    },\n\n    onTreeNodeBeforeMove: function (node, oldParent, newParent, index, eOpts ) {\n        if (oldParent.getOwnerTree().getId() != newParent.getOwnerTree().getId()) {\n            Ext.MessageBox.alert(t('error'), t('cross_tree_moves_not_supported'));\n            return false;\n        }\n\n        // check for locks\n        if (node.data.locked) {\n            Ext.MessageBox.alert(t('locked'), t('element_cannot_be_move_because_it_is_locked'));\n            return false;\n        }\n\n        // check new parent's permission\n        if(!newParent.data.permissions.create){\n            Ext.MessageBox.alert(' ', t('element_cannot_be_moved'));\n            return false;\n        }\n\n        // check for permission\n        if (node.data.permissions.settings) {\n            this.tree.loadMask.show();\n            return true;\n        }\n        return false;\n    },\n\n    onTreeNodeContextmenu: function (tree, record, item, index, e, eOpts ) {\n        e.stopEvent();\n\n        if(pimcore.helpers.hasTreeNodeLoadingIndicator(\"asset\", record.id)) {\n            return;\n        }\n\n        var menu = new Ext.menu.Menu();\n        var perspectiveCfg = this.perspectiveCfg;\n\n        if(tree.getSelectionModel().getSelected().length > 1) {\n            var selectedIds = [];\n            tree.getSelectionModel().getSelected().each(function (item) {\n                selectedIds.push(item.id);\n            });\n\n            if (record.data.permissions.remove && record.data.id != 1 && !record.data.locked && perspectiveCfg.inTreeContextMenu(\"asset.delete\")) {\n                menu.add(new Ext.menu.Item({\n                    text: t('delete'),\n                    iconCls: \"pimcore_icon_delete\",\n                    handler: this.deleteAsset.bind(this, selectedIds.join(','))\n                }));\n            }\n        } else {\n            if (record.data.type == \"folder\") {\n                if (record.data.permissions.create) {\n\n                    var menuItems = [];\n\n                    if (perspectiveCfg.inTreeContextMenu(\"asset.add\")) {\n                        if (perspectiveCfg.inTreeContextMenu(\"asset.add.upload\")) {\n                            menuItems.push({\n                                text: t(\"upload_files\"),\n                                iconCls: \"pimcore_icon_upload\",\n                                listeners: {\n                                    \"afterrender\": function (el, eOpts) {\n                                        // we need to do this vanilla javascript and directly after finishing rendering\n                                        // otherwise this will cause issues when used with hybrid touch devices, see also:\n                                        // https://github.com/pimcore/pimcore/issues/1836\n                                        var fileElemId = 'assetMultiUploadField';\n                                        if (!document.getElementById(fileElemId)) {\n                                            document.body.insertAdjacentHTML('beforeend', '<input type=\"file\" id=\"' + fileElemId + '\" multiple>');\n                                        }\n\n                                        var fileSelect = el.getEl().down('a', true),\n                                            fileElem = document.getElementById(fileElemId);\n\n                                        if (fileElem['onChangeListener']) {\n                                            fileElem.removeEventListener('change', fileElem['onChangeListener']);\n                                        }\n\n                                        fileElem['onChangeListener'] = function (e) {\n                                            if (e.target.files.length) {\n                                                this.uploadFileList(e.target, record);\n                                            }\n                                        }.bind(this);\n\n                                        fileElem.addEventListener(\"change\", fileElem['onChangeListener']);\n\n                                        fileSelect.addEventListener(\"click\", function (e) {\n                                            if (fileElem) {\n                                                fileElem.value = fileElem.defaultValue;\n                                                fileElem.click();\n                                            }\n                                            e.preventDefault();\n                                        }, false);\n                                    }.bind(this)\n                                }\n                            });\n                        }\n\n                        if (perspectiveCfg.inTreeContextMenu(\"asset.add.uploadCompatibility\")) {\n                            menuItems.push({\n                                text: t(\"upload_compatibility_mode\"),\n                                handler: this.addSingleAsset.bind(this, tree, record),\n                                iconCls: \"pimcore_icon_upload\"\n                            });\n                        }\n\n                        if (perspectiveCfg.inTreeContextMenu(\"asset.add.uploadZip\")) {\n                            menuItems.push({\n                                text: t(\"upload_zip\"),\n                                handler: this.uploadZip.bind(this, tree, record),\n                                iconCls: \"pimcore_icon_zip pimcore_icon_overlay_upload\"\n                            });\n                        }\n\n                        if (perspectiveCfg.inTreeContextMenu(\"asset.add.importFromServer\")) {\n                            menuItems.push({\n                                text: t(\"import_from_server\"),\n                                handler: this.importFromServer.bind(this, tree, record),\n                                iconCls: \"pimcore_icon_import_server\"\n                            });\n                        }\n\n                        if (perspectiveCfg.inTreeContextMenu(\"asset.add.uploadFromUrl\")) {\n                            menuItems.push({\n                                text: t(\"import_from_url\"),\n                                handler: this.importFromUrl.bind(this, tree, record),\n                                iconCls: \"pimcore_icon_world pimcore_icon_overlay_add\"\n                            });\n                        }\n\n                        if (menuItems.length > 0) {\n                            menu.add(new Ext.menu.Item({\n                                text: t('add_assets'),\n                                iconCls: \"pimcore_icon_asset pimcore_icon_overlay_add\",\n                                hideOnClick: false,\n                                menu: menuItems\n                            }));\n                        }\n                    }\n\n                    if (perspectiveCfg.inTreeContextMenu(\"asset.addFolder\")) {\n                        menu.add(new Ext.menu.Item({\n                            text: t('create_folder'),\n                            iconCls: \"pimcore_icon_folder pimcore_icon_overlay_add\",\n                            handler: this.addFolder.bind(this, tree, record)\n                        }));\n                    }\n\n                    menu.add(\"-\");\n\n                }\n            }\n\n            if (record.data.permissions.rename && record.data.id != 1 && !record.data.locked) {\n                if (perspectiveCfg.inTreeContextMenu(\"asset.rename\")) {\n                    menu.add(new Ext.menu.Item({\n                        text: t('rename'),\n                        iconCls: \"pimcore_icon_key pimcore_icon_overlay_go\",\n                        handler: this.editAssetKey.bind(this, tree, record)\n                    }));\n                }\n            }\n\n            if (this.id != 1 && record.data.permissions.view) {\n                if (perspectiveCfg.inTreeContextMenu(\"asset.copy\")) {\n                    menu.add(new Ext.menu.Item({\n                        text: t('copy'),\n                        iconCls: \"pimcore_icon_copy\",\n                        handler: this.copy.bind(this, tree, record)\n                    }));\n                }\n            }\n\n            //cut\n            if (record.data.id != 1 && !record.data.locked && record.data.permissions.rename) {\n                if (perspectiveCfg.inTreeContextMenu(\"asset.cut\")) {\n                    menu.add(new Ext.menu.Item({\n                        text: t('cut'),\n                        iconCls: \"pimcore_icon_cut\",\n                        handler: this.cut.bind(this, tree, record)\n                    }));\n                }\n            }\n\n\n            //paste\n            if (pimcore.cachedAssetId\n                && (record.data.permissions.create || record.data.permissions.publish)\n                && perspectiveCfg.inTreeContextMenu(\"asset.paste\")) {\n\n                if (record.data.type == \"folder\") {\n                    menu.add(new Ext.menu.Item({\n                        text: t('paste'),\n                        iconCls: \"pimcore_icon_paste\",\n                        handler: this.pasteInfo.bind(this, tree, record, \"recursive\")\n                    }));\n                } else {\n                    menu.add(new Ext.menu.Item({\n                        text: t('paste'),\n                        iconCls: \"pimcore_icon_paste\",\n                        handler: this.pasteInfo.bind(this, tree, record, \"replace\")\n                    }));\n                }\n            }\n\n            if (record.data.type == \"folder\" && pimcore.cutAsset\n                && (record.data.permissions.create || record.data.permissions.publish)\n                && perspectiveCfg.inTreeContextMenu(\"asset.pasteCut\")) {\n                menu.add(new Ext.menu.Item({\n                    text: t('paste_cut_element'),\n                    iconCls: \"pimcore_icon_paste\",\n                    handler: function () {\n                        this.pasteCutAsset(pimcore.cutAsset,\n                            pimcore.cutAssetParentNode, record, this.tree);\n                        pimcore.cutAssetParentNode = null;\n                        pimcore.cutAsset = null;\n                    }.bind(this)\n                }));\n            }\n\n            if (record.data.permissions.remove && record.data.id != 1 && !record.data.locked && perspectiveCfg.inTreeContextMenu(\"asset.delete\")) {\n                menu.add(new Ext.menu.Item({\n                    text: t('delete'),\n                    iconCls: \"pimcore_icon_delete\",\n                    handler: this.deleteAsset.bind(this, record.data.id)\n                }));\n            }\n\n            // upload & download\n            if (record.data.permissions.view) {\n                menu.add(\"-\");\n\n                if (record.data.type == \"folder\") {\n                    menu.add({\n                        text: t(\"download_as_zip\"),\n                        iconCls: \"pimcore_icon_zip pimcore_icon_overlay_download\",\n                        handler: function () {\n                            pimcore.elementservice.downloadAssetFolderAsZip(record.data.id)\n                        }\n                    });\n                } else {\n                    if (record.data.permissions.publish) {\n                        menu.add(new Ext.menu.Item({\n                            text: t('upload_new_version'),\n                            iconCls: \"pimcore_icon_upload\",\n                            handler: function () {\n                                pimcore.elementservice.replaceAsset(record.data.id, function () {\n                                    pimcore.elementservice.refreshNodeAllTrees(\"asset\", record.parentNode.id);\n                                });\n                            }\n                        }));\n                    }\n\n                    menu.add(new Ext.menu.Item({\n                        text: t('download'),\n                        iconCls: \"pimcore_icon_download\",\n                        handler: function () {\n                            pimcore.helpers.download(Routing.generate('pimcore_admin_asset_download', {id: record.data.id}));\n                        }\n                    }));\n                }\n            }\n\n            // advanced menu\n            var advancedMenuItems = [];\n            var user = pimcore.globalmanager.get(\"user\");\n\n            if (record.data.permissions.create && !record.data.locked && perspectiveCfg.inTreeContextMenu(\"asset.searchAndMove\")) {\n                advancedMenuItems.push({\n                    text: t('search_and_move'),\n                    iconCls: \"pimcore_icon_search pimcore_icon_overlay_go\",\n                    handler: this.searchAndMove.bind(this, tree, record)\n                });\n            }\n\n            if (record.data.id != 1 && user.admin) {\n                var lockMenu = [];\n                if (record.data.lockOwner && perspectiveCfg.inTreeContextMenu(\"asset.unlock\")) { // add unlock\n                    lockMenu.push({\n                        text: t('unlock'),\n                        iconCls: \"pimcore_icon_lock pimcore_icon_overlay_delete\",\n                        handler: function () {\n                            pimcore.elementservice.lockElement({\n                                elementType: \"asset\",\n                                id: record.data.id,\n                                mode: null\n                            });\n                        }.bind(this)\n                    });\n                } else if (perspectiveCfg.inTreeContextMenu(\"asset.lock\")) {\n                    lockMenu.push({\n                        text: t('lock'),\n                        iconCls: \"pimcore_icon_lock pimcore_icon_overlay_add\",\n                        handler: function () {\n                            pimcore.elementservice.lockElement({\n                                elementType: \"asset\",\n                                id: record.data.id,\n                                mode: \"self\"\n                            });\n                        }.bind(this)\n                    });\n\n                    if (record.data.type == \"folder\" && perspectiveCfg.inTreeContextMenu(\"asset.lockAndPropagate\")) {\n                        lockMenu.push({\n                            text: t('lock_and_propagate_to_childs'),\n                            iconCls: \"pimcore_icon_lock pimcore_icon_overlay_go\",\n                            handler: function () {\n                                pimcore.elementservice.lockElement({\n                                    elementType: \"asset\",\n                                    id: record.data.id,\n                                    mode: \"propagate\"\n                                });\n                            }.bind(this)\n                        });\n                    }\n                }\n\n                if (record.data.locked && perspectiveCfg.inTreeContextMenu(\"asset.unlockAndPropagate\")) {\n                    // add unlock and propagate to children functionality\n                    lockMenu.push({\n                        text: t('unlock_and_propagate_to_children'),\n                        iconCls: \"pimcore_icon_lock pimcore_icon_overlay_delete\",\n                        handler: function () {\n                            pimcore.elementservice.unlockElement({\n                                elementType: \"asset\",\n                                id: record.data.id\n                            });\n                        }.bind(this)\n                    });\n                }\n\n                if (lockMenu.length > 0) {\n                    advancedMenuItems.push({\n                        text: t('lock'),\n                        iconCls: \"pimcore_icon_lock\",\n                        hideOnClick: false,\n                        menu: lockMenu\n                    });\n                }\n            }\n\n            // expand and collapse complete tree\n            if (!record.data.leaf) {\n                if (record.data.expanded) {\n                    advancedMenuItems.push({\n                        text: t('collapse_children'),\n                        iconCls: \"pimcore_icon_collapse_children\",\n                        handler: function () {\n                            record.collapse(true);\n                        }.bind(this, record)\n                    });\n                } else {\n                    advancedMenuItems.push({\n                        text: t('expand_children'),\n                        iconCls: \"pimcore_icon_expand_children\",\n                        handler: function () {\n                            record.expand(true);\n                        }.bind(this, record)\n                    });\n                }\n            }\n\n            menu.add(\"-\");\n\n            if (advancedMenuItems.length) {\n                menu.add({\n                    text: t('advanced'),\n                    iconCls: \"pimcore_icon_more\",\n                    hideOnClick: false,\n                    menu: advancedMenuItems\n                });\n            }\n\n            if (record.data.type == \"folder\" && perspectiveCfg.inTreeContextMenu(\"asset.reload\")) {\n                menu.add(new Ext.menu.Item({\n                    text: t('refresh'),\n                    iconCls: \"pimcore_icon_reload\",\n                    handler: pimcore.elementservice.refreshNode.bind(this, record)\n                }));\n            }\n        }\n\n        pimcore.helpers.hideRedundantSeparators(menu);\n\n        const prepareAssetTreeContextMenu = new CustomEvent(pimcore.events.prepareAssetTreeContextMenu, {\n            detail: {\n                menu: menu,\n                tree: this,\n                asset: record\n            }\n        });\n\n        document.dispatchEvent(prepareAssetTreeContextMenu);\n\n        menu.showAt(e.pageX+1, e.pageY+1);\n    },\n\n\n    copy: function (tree, record) {\n        pimcore.cachedAssetId = record.id;\n    },\n\n    cut: function (tree, record) {\n        pimcore.cutAsset = record;\n        pimcore.cutAssetParentNode = record.parentNode;\n    },\n\n    pasteCutAsset: function(asset, oldParent, newParent, tree) {\n        pimcore.elementservice.updateAsset(asset.id, {\n            parentId: newParent.id\n        }, function (asset, newParent, oldParent, tree, response) {\n            try{\n                var rdata = Ext.decode(response.responseText);\n                if (rdata && rdata.success) {\n                    // set new pathes\n                    var newBasePath = newParent.data.path;\n                    if (newBasePath == \"/\") {\n                        newBasePath = \"\";\n                    }\n                    asset.data.basePath = newBasePath;\n                    asset.data.path = asset.data.basePath + \"/\" + asset.data.text;\n                }\n                else {\n                    this.tree.loadMask.hide();\n                    pimcore.helpers.showNotification(t(\"error\"), t(\"cant_move_node_to_target\"),\n                        \"error\",t(rdata.message));\n                }\n            } catch(e){\n                this.tree.loadMask.hide();\n                pimcore.helpers.showNotification(t(\"error\"), t(\"cant_move_node_to_target\"), \"error\");\n            }\n            this.tree.loadMask.hide();\n            pimcore.elementservice.refreshNodeAllTrees(\"asset\", oldParent.id);\n            pimcore.elementservice.refreshNodeAllTrees(\"asset\", newParent.id);\n            newParent.expand();\n        }.bind(this, asset, newParent, oldParent, tree));\n\n    },\n\n    pasteInfo: function (tree, record, type) {\n        pimcore.helpers.addTreeNodeLoadingIndicator(\"asset\", record.id);\n\n        Ext.Ajax.request({\n            url: Routing.generate('pimcore_admin_asset_copyinfo'),\n            params: {\n                targetId: record.id,\n                sourceId: pimcore.cachedAssetId,\n                type: type\n            },\n            success: this.paste.bind(this, tree, record)\n        });\n    },\n\n    paste: function (tree, record, response) {\n\n        try {\n            var res = Ext.decode(response.responseText);\n\n            if (res.pastejobs) {\n\n                record.pasteProgressBar = new Ext.ProgressBar({\n                    text: t('initializing')\n                });\n\n                record.pasteWindow = new Ext.Window({\n                    title: t(\"paste\"),\n                    layout:'fit',\n                    width:200,\n                    bodyStyle: \"padding: 10px;\",\n                    closable:false,\n                    plain: true,\n                    items: [record.pasteProgressBar],\n                    listeners: pimcore.helpers.getProgressWindowListeners()\n                });\n\n                record.pasteWindow.show();\n\n                var pj = new pimcore.tool.paralleljobs({\n                    success: function () {\n\n                        try {\n                            this.pasteComplete(tree, record);\n                        } catch(e) {\n                            console.log(e);\n                            pimcore.helpers.showNotification(t(\"error\"), t(\"error_pasting_item\"), \"error\");\n                            pimcore.elementservice.refreshNodeAllTrees(\"asset\", record.parentNode.id);\n                        }\n                    }.bind(this),\n                    update: function (currentStep, steps, percent) {\n                        if(record.pasteProgressBar) {\n                            var status = currentStep / steps;\n                            record.pasteProgressBar.updateProgress(status, percent + \"%\");\n                        }\n                    }.bind(this),\n                    failure: function (message) {\n                        this.pasteWindow.close();\n                        record.pasteProgressBar = null;\n\n                        pimcore.helpers.showNotification(t(\"error\"), t(\"error_pasting_item\"), \"error\", t(message));\n                        pimcore.elementservice.refreshNodeAllTrees(\"asset\", record.parentNode.id);\n                    }.bind(this),\n                    jobs: res.pastejobs\n                });\n            } else {\n                throw \"There are no pasting jobs\";\n            }\n        } catch (e) {\n            console.log(e);\n            Ext.MessageBox.alert(t('error'), e);\n            this.pasteComplete(this, tree, record);\n        }\n    },\n\n    pasteComplete: function (tree, record) {\n        if(record.pasteWindow) {\n            record.pasteWindow.close();\n        }\n\n        record.pasteProgressBar = null;\n        record.pasteWindow = null;\n\n        pimcore.elementservice.refreshNodeAllTrees(\"asset\", record.id);\n    },\n\n    addFolder : function (tree, record) {\n        Ext.MessageBox.prompt(t('create_folder'), t('enter_the_name_of_the_new_item'),\n            this.addFolderCreate.bind(this, tree, record));\n    },\n\n    addFolderCreate: function (tree, record, button, value, object) {\n\n        if (button == \"ok\") {\n\n            // check for identical folder name in current level\n            if (pimcore.elementservice.isKeyExistingInLevel(record, value)) {\n                return;\n            }\n\n            Ext.Ajax.request({\n                url: Routing.generate('pimcore_admin_asset_addfolder'),\n                method: \"POST\",\n                params: {\n                    parentId: record.data.id,\n                    name: pimcore.helpers.getValidFilename(value, \"asset\")\n                },\n                success: this.addFolderComplete.bind(this, tree, record)\n            });\n        }\n    },\n\n    addFolderComplete: function (tree, record, response) {\n        try{\n            var rdata = Ext.decode(response.responseText);\n            if (rdata && rdata.success) {\n                record.data.leaf = false;\n                //this.renderIndent();\n                record.expand();\n            }\n            else {\n                pimcore.helpers.showNotification(t(\"error\"), t(\"failed_to_create_new_item\"),\n                    \"error\",t(rdata.message));\n            }\n        } catch(e){\n            pimcore.helpers.showNotification(t(\"error\"), t(\"failed_to_create_new_item\"), \"error\");\n        }\n        pimcore.elementservice.refreshNodeAllTrees(\"asset\", record.get(\"id\"));\n    },\n\n    addSingleAsset: function (tree, record) {\n        pimcore.helpers.assetSingleUploadDialog(record.data.id, \"id\", function (res) {\n            var f = this.addAssetComplete.bind(this, tree, record);\n            f();\n        }.bind(this), function (res) {\n            var response = Ext.decode(res.response.responseText);\n            if(response.success === false) {\n                pimcore.helpers.showNotification(t(\"error\"), response.message, \"error\",\n                    res.response.responseText);\n            }\n            var f = this.addAssetComplete.bind(this, tree, record);\n            f();\n        }.bind(this));\n    },\n\n    uploadZip: function (tree, record) {\n\n        pimcore.helpers.uploadDialog(Routing.generate('pimcore_admin_asset_importzip', {parentId: record.id}), \"Filedata\", function (response) {\n            // this.attributes.reference\n            var res = Ext.decode(response.response.responseText);\n            pimcore.helpers.addTreeNodeLoadingIndicator(\"asset\", record.get(\"id\"));\n\n            this.downloadProgressBar = new Ext.ProgressBar({\n                text: t('initializing')\n            });\n\n            this.downloadProgressWin = new Ext.Window({\n                title: t(\"upload_zip\"),\n                layout:'fit',\n                width:200,\n                bodyStyle: \"padding: 10px;\",\n                closable:false,\n                plain: true,\n                items: [this.downloadProgressBar],\n                listeners: pimcore.helpers.getProgressWindowListeners()\n            });\n\n            this.downloadProgressWin.show();\n\n            var pj = new pimcore.tool.paralleljobs({\n                success: function (jobId) {\n                    if(this.downloadProgressWin) {\n                        this.downloadProgressWin.close();\n                    }\n\n                    this.downloadProgressBar = null;\n                    this.downloadProgressWin = null;\n\n                    pimcore.elementservice.refreshNodeAllTrees(\"asset\", record.get(\"id\"));\n                }.bind(this, res.jobId),\n                update: function (currentStep, steps, percent) {\n                    if(this.downloadProgressBar) {\n                        var status = currentStep / steps;\n                        this.downloadProgressBar.updateProgress(status, percent + \"%\");\n                    }\n                }.bind(this),\n                failure: function (message) {\n                    this.downloadProgressWin.close();\n                    pimcore.elementservice.refreshNodeAllTrees(\"asset\", record.get(\"id\"));\n                    pimcore.helpers.showNotification(t(\"error\"), t(\"error\"),\n                        \"error\", t(message));\n                }.bind(this),\n                jobs: res.jobs\n            });\n        }.bind(this), function (res) {\n            var response = Ext.decode(res.response.responseText);\n            if (response && response.success === false) {\n                pimcore.helpers.showNotification(t(\"error\"), response.message, \"error\",\n                    res.response.responseText);\n            } else {\n                pimcore.helpers.showNotification(t(\"error\"), res, \"error\",\n                    res.response.responseText);\n            }\n\n            pimcore.elementservice.refreshNodeAllTrees(\"asset\", record.parentNode.get(\"id\"));\n        }.bind(this));\n    },\n\n    enableHtml5Upload: function (node, rowIdx, out) {\n\n        if (!window[\"FileList\"]) {\n            return;\n        }\n\n        // only for folders\n        if (node.data.type != \"folder\") {\n            return;\n        }\n\n        // timeout because there is no afterrender function\n        window.setTimeout(this.addHtml5DragListener.bind(this, node), 2000);\n    },\n\n    addHtml5DragListener: function (node) {\n\n        try {\n            var tree = this.tree;\n            var el = Ext.fly(tree.getView().getNodeByRecord(node));\n            if(el) {\n                el = el.dom;\n                var fn = function (e) {\n                    //e.stopPropagation();\n                    e.preventDefault();\n                    tree.setSelection(node);\n\n                    e.dataTransfer.dropEffect = 'copy';\n\n                    return false;\n                };\n\n                el.addEventListener(\"dragenter\", fn, true);\n                el.addEventListener(\"dragover\", fn, true);\n            }\n        }\n        catch (e) {\n            console.log(e);\n        }\n    },\n\n    importFromServer: function (tree, record) {\n\n        var store = Ext.create('Ext.data.TreeStore', {\n            proxy: {\n                type: 'ajax',\n                url: Routing.generate('pimcore_admin_misc_fileexplorertree')\n            },\n            folderSort: true,\n            sorters: [{\n                property: 'text',\n                direction: 'ASC'\n            }]\n        });\n\n        this.treePanel = new Ext.tree.TreePanel({\n            region: \"west\",\n            width: 300,\n            rootVisible: true,\n            enableDD: false,\n            autoScroll: true,\n            store: store,\n            root: {\n                nodeType: 'async',\n                text: t(\"document_root\"),\n                id: '/fileexplorer/',\n                iconCls: \"pimcore_icon_home\",\n                expanded: true,\n                type: \"folder\"\n            },\n            listeners: {\n                itemclick: function(tree, record, item, index, e, eOpts ) {\n                    Ext.getCmp(\"pimcore_asset_server_import_button\").setDisabled(record.data.type != \"folder\");\n                }.bind(this)\n            }\n        });\n\n        this.uploadWindow = new Ext.Window({\n            layout: 'fit',\n            title: t('add_assets'),\n            closeAction: 'destroy',\n            width:400,\n            height:400,\n            modal: true,\n            items: [this.treePanel],\n            buttons: [{\n                text: t(\"import\"),\n                disabled: true,\n                id: \"pimcore_asset_server_import_button\",\n                handler: function (tree, record) {\n\n                    try {\n                        Ext.getCmp(\"pimcore_asset_server_import_button\").disable();\n                        var selModel =  this.treePanel.getSelectionModel();\n                        var selectedNode = selModel.getSelected().getAt(0);\n                        this.uploadWindow.removeAll();\n\n                        this.uploadWindow.add({\n                            xtype: \"panel\",\n                            html: t(\"please_wait\"),\n                            bodyStyle: \"padding:10px;\"\n                        });\n                        this.uploadWindow.updateLayout();\n\n                        Ext.Ajax.request({\n                            url: Routing.generate('pimcore_admin_asset_importserver'),\n                            method: 'POST',\n                            params: {\n                                parentId: record.id,\n                                serverPath: selectedNode.id\n                            },\n                            success: function (tree, record, response) {\n                                this.uploadWindow.close();\n                                this.uploadWindow = null;\n\n                                pimcore.helpers.addTreeNodeLoadingIndicator(\"asset\", record.get(\"id\"));\n\n                                var res = Ext.decode(response.responseText);\n\n                                this.downloadProgressBar = new Ext.ProgressBar({\n                                    text: t('initializing')\n                                });\n\n                                this.downloadProgressWin = new Ext.Window({\n                                    title: t(\"import_from_server\"),\n                                    layout:'fit',\n                                    width:200,\n                                    bodyStyle: \"padding: 10px;\",\n                                    closable:false,\n                                    plain: true,\n                                    items: [this.downloadProgressBar],\n                                    listeners: pimcore.helpers.getProgressWindowListeners()\n                                });\n\n                                this.downloadProgressWin.show();\n\n                                var pj = new pimcore.tool.paralleljobs({\n                                    success: function () {\n                                        if(this.downloadProgressWin) {\n                                            this.downloadProgressWin.close();\n                                        }\n\n                                        this.downloadProgressBar = null;\n                                        this.downloadProgressWin = null;\n\n                                        pimcore.elementservice.refreshNodeAllTrees(\"asset\", record.get(\"id\"));\n                                    }.bind(this),\n                                    update: function (currentStep, steps, percent) {\n                                        if(this.downloadProgressBar) {\n                                            var status = currentStep / steps;\n                                            this.downloadProgressBar.updateProgress(status, percent + \"%\");\n                                        }\n                                    }.bind(this),\n                                    failure: function (message) {\n                                        this.downloadProgressWin.close();\n                                        pimcore.elementservice.refreshNodeAllTrees(\"asset\", record.get(\"id\"));\n\n                                        pimcore.helpers.showNotification(t(\"error\"), t(\"error\"),\n                                            \"error\", t(message));\n                                    }.bind(this),\n                                    jobs: res.jobs\n                                });\n                            }.bind(this, tree, record)\n                        });\n\n\n                    } catch (e) {\n                        console.log(e)\n                    }\n                }.bind(this, tree, record)\n            }]\n        });\n\n        this.uploadWindow.show();\n    },\n\n    importFromUrl: function (tree, record) {\n\n        Ext.MessageBox.prompt(t(\"import_from_url\"), ' ', function (button, value, object) {\n            if (button == \"ok\") {\n                var win = new Ext.Window({\n                    html: t(\"please_wait\"),\n                    closable: false,\n                    bodyStyle: \"padding: 10px;\",\n                    modal: true\n                });\n                win.show();\n\n                Ext.Ajax.request({\n                    url: Routing.generate('pimcore_admin_asset_importurl'),\n                    method: 'POST',\n                    params: {\n                        id: record.data.id,\n                        url: value\n                    },\n                    success: function () {\n                        win.close();\n                        pimcore.elementservice.refreshNodeAllTrees(\"asset\", record.get(\"id\"));\n\n                    }.bind(this),\n                    failure: function() {\n                        win.close();\n                        pimcore.elementservice.refreshNodeAllTrees(\"asset\", record.get(\"id\"));\n                    }\n                });\n            }\n        }.bind(this), null, false, 'https://');\n    },\n\n    addAssetComplete: function (tree, record, config, file, response) {\n\n        record.data.leaf = false;\n        record.expand();\n        pimcore.elementservice.refreshNodeAllTrees(\"asset\", record.get(\"id\"));\n    },\n\n    editAssetKey: function (tree, record) {\n        var options = {\n            sourceTree: tree,\n            elementType: \"asset\",\n            elementSubType: record.data.type,\n            id: record.data.id,\n            default: Ext.util.Format.htmlDecode(record.data.text)\n        };\n        pimcore.elementservice.editElementKey(options);\n    },\n\n\n    searchAndMove: function(tree, record) {\n        pimcore.helpers.searchAndMove(record.data.id, function() {\n            pimcore.elementservice.refreshNode(record);\n        }.bind(this), \"asset\");\n    },\n\n\n\n    deleteAsset : function (ids) {\n        var options = {\n            \"elementType\" : \"asset\",\n            \"id\": ids\n        };\n\n        pimcore.elementservice.deleteElement(options);\n    }\n});\n", "# Upgrade Notes\n\n## 10.5.13\n- [Web2Print] Print document twig expressions are now executed in a sandbox with restrictive security policies (just like Sending mails and Dataobject Text Layouts introduced in 10.5.9).\n\n## 10.5.10\n- [DataObject] Deprecated: Loading non-Concrete objects with the Concrete class will not be possible in Pimcore 11.\n\n## 10.5.9\n- [Twig] Sending mails and Dataobject Text Layouts, which allow rendering user controlled twig templates are now executed in a sandbox with restrictive security policies for tags, filters, functions.\n         Please use following configuration to allow more in template rendering:\n  ```yaml\n  pimcore:\n        templating_engine:\n            twig:\n              sandbox_security_policy:\n                tags: ['if']\n                filters: ['upper']\n                functions: ['include', 'path', 'range']\n  ```\n\n## 10.5.8\n- [Nginx] Static pages nginx config has been updated to fix the issue for home static page generation. please adapt the following configuration:\n```nginx\nmap $args $static_page_root {\n    default                                 /var/tmp/pages;\n    \"~*(^|&)pimcore_editmode=true(&|$)\"     /var/nonexistent;\n    \"~*(^|&)pimcore_preview=true(&|$)\"      /var/nonexistent;\n    \"~*(^|&)pimcore_version=[^&]+(&|$)\"     /var/nonexistent;\n}\n\nmap $uri $static_page_uri {\n    default                                 $uri;\n    \"/\"                                     /%home;\n}\n\n.....\n\nlocation / {\n    error_page 404 /meta/404;\n\n    try_files $static_page_root$static_page_uri.html $uri /index.php$is_args$args;\n}\n```\n\n## 10.5.0\n- [Class Definitions] Resolving classes or services will no longer catch exceptions in Pimcore 11. Remove invalid references from class definitions.\n- [Sessions] Changed default value for `symfony.session.cookie_secure` to `auto`\n- [Listings] `JsonListing` class is deprecated. Please use `CallableFilterListingInterface`, `FilterListingTrait` and `CallableOrderListingInterface`, `OrderListingTrait` instead.\n  For examples please see existing classes, e.g. `Pimcore\\Model\\Document\\DocType\\Listing`.\n\n- [Security] It is recommended to use new [Authenticator based system](https://pimcore.com/docs/pimcore/current/Development_Documentation/Development_Tools_and_Details/Security_Authentication/Authenticator_Based_Security.html) for authentication/authorization.\n  To use new authenticator, add following symfony config in `security.yaml`:\n    ```yaml\n    security:\n        enable_authenticator_manager: true\n    ```\n  `[Authentication] PreAuthenticatedAdminSessionListener` has been deprecated and will be removed in Pimcore 11.\n- [Elements] Calling the methods `getById` and `getByPath` on `Asset`,`Document`,`DataObject` with second boolean parameter `$force` and `Element\\Service::getElementById` with third boolean  parameter `$force` is deprecated and will throw exception in Pimcore 11. Instead pass the parameter as associative array with `$force` value.\n  e.g. Before \n   ```php\n    Asset::getById($id, true);\n    Document::getById($id, true);\n    DataObject::getById($id, true);\n  \n    Asset::getByPath($path, true);\n    Document::getByPath($path, true);\n    DataObject::getByPath($path, true);\n  \n    Element\\Service::getElementById::getElementById($type, $id, $true);\n   ```\n    After\n   ```php\n    Asset::getById($id, ['force' => true]);\n    Document::getById($id, ['force' => true]);\n    DataObject::getById($id, ['force' => true]);\n  \n    Asset::getByPath($path, ['force' => true]);\n    Document::getByPath($path, ['force' => true]);\n    DataObject::getByPath($path, ['force' => true]);\n  \n    Element\\Service::getElementById($type, $id, ['force' => true]);\n   ```\n- [Navigation Builder] Calling the method `Pimcore\\Navigation\\Builder::getNavigation()` using extra arguments is deprecated and will be removed in Pimcore 11. Instead of using the extra arguments, it is recommended to call the method using the params array. eg: Currently, the `getNavigation()` method can be called by passing the config params `activeDocument`, `navigationRootDocument`, `htmlMenuIdPrefix`, `pageCallback`, `cache`, `maxDepth`, `cacheLifetime` and `markActiveTrail` as the arguments i.e `getNavigation($activeDocument, $navigationRootDocument, $htmlMenuIdPrefix, $pageCallback, $cache, $maxDepth, $cacheLifetime, $markActiveTrail)`. According to the new implementation you should call the method like `getNavigation($params)` where `$params` should be an associative array with the keys `active`, `root`, `htmlMenuPrefix`, `pageCallback`, `cache`, `maxDepth`, `cacheLifetime` and `markActiveTrail`.\n  \n- [Runtime Cache] The trait `\\Pimcore\\Cache\\RuntimeCacheTrait` has been deprecated because of its ambiguous naming and usage of persisted cache along with the runtime object cache.\n  It is recommended to use `\\Pimcore\\Cache\\RuntimeCache` instead of this trait. For persisted cache, please use `\\Pimcore\\Cache` instead.\n- [Sitemap] Pimcore is now also supporting Presta/Sitemap `^3.2` (which supports Symfony 6 and uses max level of PHPStan).\n  Please note, if the routing import config is in use, it is recommended to correct the config path (by removing `/Resources`) to follow the [new folder tree structure](https://github.com/prestaconcept/PrestaSitemapBundle/releases/tag/v3.0.0),\n  eg. \"@PrestaSitemapBundle/~~Resources/~~config/routing.yaml\", to ensure a smoother upgrade to upcoming major release.\n- [Backend search] `key` and `index` columns have been added to the search index. Run `./bin/console pimcore:search-backend-reindex` to reindex.\n- [Cache] Pimcore use DoctrineDbalAdapter instead of PdoAdapter by default now.\n- Removed `ocramius/package-versions` dependency. If you rely on it, please add it to your own `composer.json`.\n- [Permissions] Added an extra check about [system permission](https://pimcore.com/docs/pimcore/current/Development_Documentation/Administration_of_Pimcore/Users_and_Roles.html#page_System-Permissions) in element `isAllowed()` method, please make sure your custom implementations are not affected by this change. \n  Listing, grid, tree view are not severely affected as the main permission is checked on a Kernel event level that prevents the page to be shown and prevents any process that iterate isAllowed() calls. \n  The only cases could be affected are those where the workspace are set but master permissions are disallowed, before this change, it could lead to (not intended) false positive.\n- [Security/User] `UsernameNotFoundException` (deprecated since Symfony 5.3) occurences have been replaced with `UserNotFoundException`.\n- [Deprecated] Generate type declarations option in class definition is deprecated, because type declarations will always be added with Pimcore 11\n- [Application Logger] File Objects are now stored in the flysystem. Due some incompatibilities of checking files by modification date (cloud storages) and for performance issues (scan folders/file), the cleanup task now do not run in time range from [midnight and 4 a.m.](https://github.com/pimcore/pimcore/pull/7164) anymore, but it deletes the file matching the column in the database as soon as the database entries are archived.\n- [Session] Implementing Session Configurator with tag `pimcore.session.configurator` to register session bags, is deprecated and will be removed in Pimcore 11.\n  Implement an [EventListener](https://github.com/pimcore/pimcore/blob/10.5/bundles/EcommerceFrameworkBundle/EventListener/SessionBagListener.php) to register a session bag before the session is started.\n- [Ecommerce][PricingManager] Token condition is deprecated and will be removed in Pimcore 11.\n- Parameter `pimcore.admin.session.attribute_bags` is deprecated and will be removed in Pimcore 11.\n- [JS Events/Disabled] The plugin broker for fire events has been disabled. \nThe plugins are still supported, but they are deprecated and will be removed in Pimcore 11   \nPlease use [event listener](../../20_Extending_Pimcore/13_Bundle_Developers_Guide/06_Event_Listener_UI.md) instead of plugins for JS events.\n- Extension Manager - Registering or managing bundles/areabricks through `Tools -> Bundles & Bricks` or manually through `var/config/extensions.php` is deprecated and will not work on Pimcore 11.\n  Please use `config/bundles.php` to register/manage bundles instead.\n- [Web2Print] Wkhtmltopdf Processor has been deprecated and will be removed in Pimcore 11. Please use HeadlessChrome or PDFreactor instead.\n- [Config] `Pimcore\\Config\\Config` has been deprecated and will be removed in Pimcore 11.\n- The recommended nginx config for static pages has been updated (the old one still works!) from\n  ```nginx\n  server {\n      ...\n\n      location @staticpage{\n          try_files /var/tmp/pages$uri.html $uri /index.php$is_args$args;\n      }\n\n      location / {\n          error_page 404 /meta/404;\n          error_page 418 = @staticpage;\n          if ($args ~* ^(?!pimcore_editmode=true|pimcore_preview|pimcore_version)(.*)$){\n              return 418;\n          }\n          try_files $uri /index.php$is_args$args;\n      }\n\n      ...\n  }\n  ```\n  to\n  ```nginx\n  map $args $static_page_root {\n      default                                 /var/tmp/pages;\n      \"~*(^|&)pimcore_editmode=true(&|$)\"     /var/nonexistent;\n      \"~*(^|&)pimcore_preview=true(&|$)\"      /var/nonexistent;\n      \"~*(^|&)pimcore_version=[^&]+(&|$)\"     /var/nonexistent;\n  }\n\n  server {\n      ... \n\n      location / {\n          error_page 404 /meta/404;\n          try_files $static_page_root$uri.html $uri /index.php$is_args$args;\n      }\n\n      ...\n  }\n  ```\n- [Elements] Deprecated setting the parent id to 1 (root node), when an element with a non-existing parent id gets created.\n- [Custom Layouts] Deprecated Class `ClassLayoutDefinitionManager` and constant `PIMCORE_CUSTOMLAYOUT_DIRECTORY`.\n- [Workflows] Deprecated classes Pimcore\\Model\\Workflow, Pimcore\\Model\\Workflow\\Dao, Pimcore\\Model\\Workflow\\Listing\\Dao and Pimcore\\Model\\Workflow\\Listing. \nPlease check the documentation on how to work with workflows: [Workflow Management](../../07_Workflow_Management/README.md).\n- [Maintenance] Deprecated passing `--force` option to maintenance command.\n- [Exception] `MissingDependencyException` has been deprecated and will be removed in Pimcore 11.\n\n## 10.4.2\n- When maintenance mode is active, all commands are prevented from starting (not just commands inheriting from `AbstractCommand`).\n  Until now, some commands (e.g. `messenger:consume`) could be executed even if the system was in maintenance mode.\n  To circumvent, use `--ignore-maintenance-mode` option, which is available to all commands.\n\n## 10.4.0\n- **Important**: The folder structure for storing thumbnails changed, please run `bin/console pimcore:migrate:thumbnails-folder-structure` after the update to copy existing thumbnails to new folder structure. If you're dealing with a huge amount of thumbnails you should consider that this change might increase the load on your system as well as page-loading times during the migration command is executed, as non-existing thumbnails are then generated on demand. \n- [Image Optimizer] Optimize Image messages are now routed to different queue\n  instead of `pimcore_core`. If you want to handle image optimize messages, then it is required to add specific option `pimcore_image_optimize` to the command `bin/console messenger:consume pimcore_core pimcore_maintenance pimcore_image_optimize`. Also run command `bin/console messenger:consume pimcore_core` before the upgrade, so that ImageOptimize messages on the queue gets consumed.\n- **Important**: [Object bricks] A call to the object brick\u00b4s getter method no longer returns object bricks marked for deletion. \n  To restore the original behavior pass \"true\" to the getter method\u00b4s `$includeDeletedBricks` argument. \n- [Image Optimizer] Image Optimizer services (e.g. PngCrushOptimizer, JpegoptimOptimizer etc.) are deprecated and will be\n  removed in Pimcore 11. Use Pimcore\\Image\\Optimizer\\SpatieImageOptimizer service instead.\n  Currently, the existing optimizers are disabled. If you still want to use them, please re-enable them by tagging the services accordingly (in your `services.yaml`):\n```yaml\n    Pimcore\\Image\\Optimizer\\CjpegOptimizer:\n        tags:\n            - { name: pimcore.image.optimizer }\n\n    Pimcore\\Image\\Optimizer\\JpegoptimOptimizer:\n        tags:\n            - { name: pimcore.image.optimizer }\n\n    Pimcore\\Image\\Optimizer\\PngCrushOptimizer:\n        tags:\n            - { name: pimcore.image.optimizer }\n```\n\n- [Elements] Fixed the behavior of `setId()` method, so not to cast null Id to 0 as explained below:\n```php\n$object = new \\Pimcore\\Model\\DataObject();\n$object->setId(null);\n\n//before:\n$oldId = $object->getId(); //returns 0\n\n//after:\n$newId = $object->getId(); //returns null\n```\n- [Asset] Deprectaed the `marshal()/unmarshal()` methods for metadata, use `normalize()/denormalize()` methods instead.\n\n## 10.3.0\n- **Important**: [Symfony Messenger] Pimcore Core & Maintenance messages are now routed to different queues instead of default. It is\n  required to run command `bin/console messenger:consume pimcore_core pimcore_maintenance` before the upgrade, so that\n  the messages on default queue gets consumed.\n- **Important**: In preparation of upgrade to Symfony 6, return types must be added to methods which are extended from Symfony. In Pimcore, following changes are applied:\n    - Return type added to safe methods, which are `final` & marked as `internal`.\n    - Return type hints are added as comments on the methods which are extendable and phpdocs are updated. These return types will be introduced in Pimcore 11. You must add return types, if you're extending any of these Pimcore classes. Please check changes [here](https://github.com/pimcore/pimcore/pull/10846/files)\n- [Documents] Introduced additional interfaces for editable methods `getDataEditmode()`, `rewriteIds()` & `load()`. Existing `method_exists` calls are deprecated and will be removed in Pimcore 11.\n- [Data objects] Default values now get saved to versions -> Restoring a version also restores the default values (before those fields were null after restoring)\n- Method `create()` from `Pimcore\\Model\\DataObject\\Classificationstore\\CollectionGroupRelation` and `Pimcore\\Model\\DataObject\\Classificationstore\\KeyGroupRelation` no longer saves the new object, but just returns the instance. Related changes can be found here: https://github.com/pimcore/pimcore/pull/11326/files \n- Method `Kernel::getRootDir()` is deprecated, use `Kernel::getProjectDir()` instead. For more details, please check [10923](https://github.com/pimcore/pimcore/pull/10923).\n\n## 10.2.0\n- [Maintenance] Maintenance tasks are now handled with Symfony Messenger. The `pimcore:maintenance` command will add the maintenance messages to the bus and runs them afterwards immediately from the queue. However it's recommended to setup independent workers that process the queues, by running `bin/console messenger:consume pimcore_core pimcore_maintenance` (using e.g. Supervisor) and adding `--async` option to the `pimcore:maintenance` command that stops the maintenance command to process the queue directly. Details about setting it up for production environments, please check [Symfony Messenger Component docs](https://symfony.com/doc/current/messenger.html#deploying-to-production).\n- [Maintenance] Image Optimizer maintenance task moved to Messages which are consumed by Symfony Messenger. If you want to disable the image optimization, please add config to avoid dispatching the messages on messenger bus:\n```yaml\npimcore:\n    assets:\n        image:\n            thumbnails:\n                image_optimizers:\n                    enabled: false\n```\n- [Configs] The default storage for configurations is now `yaml` files in the `var/config` directory and are loaded as Symfony Config. The old `php` config-files continue to work, however, changes on existing configurations as well as new configurations are written to `yaml`.  \n**Important notice**: writing configs to `yaml` is only supported if the kernel is in debug mode, because changes of the config need a rebuild of the container configuration.  \nIf you require to change the config on production environments we recommend to change the storage to `settings-store` as described [here](../../21_Deployment/03_Configuration_Environments.md). \n- [Asset] Pimcore now automatically supports AVIF image format for thumbnails using `auto` format (only `Imagick`). To disable AVIF please [follow this instructions](../../04_Assets/03_Working_with_Thumbnails/01_Image_Thumbnails.md).  \n- [DataObject API] There is change in behavior when validating the inherited dataobjects & variants. As before, the inherited object gets saved with invalid attribute value, if the parent object has a valid value for the same attribute. Now, the API will throw validation exception, if the inherited object has an invalid value. please see https://github.com/pimcore/pimcore/pull/10529 \n\n## 10.1.0\n- [Core] Additional interfaces for data-types introduced. Existing `method_exists` calls are deprecated and will\n  be removed in Pimcore 11.\n- [InstallBundle] Installer preconfiguration path changed from `app/config/installer.yml` to `config/installer.yaml`.\n- [Core] composer.json: `symfony/symfony` package requirement has been replaced by `symfony/*` individual bundles. **Note for Bundles**: if you are using `symfony/symfony` dependency, it will now conflict with package `pimcore/pimcore`. Please move your bundle requirements to Symfony individual component packages.\n- [[Ecommerce][TrackingManager] event name in method `trackCheckoutComplete()` changed from `checkout` to `purchase` for `GoogleTagManager` implementation](https://github.com/pimcore/pimcore/pull/9366/files).\n- [Glossary] `pimcoreglossary()` tag has been deprecated in favor of `pimcore_glossary` Twig filter and will be removed in Pimcore 11.\n- Bumped `google/apiclient` to 2.10 version - Use proper namespaces for API references.\n- Bumped `endroid/qr-code` to version 4.\n- The `\\Pimcore\\Routing\\Dynamic\\DocumentRouteHandler::addDirectRouteDocumentType()` method is deprecated, use `pimcore.routing.direct_route_document_types` config instead.\n- [[Ecommerce][TrackingManager] event name in method `trackCheckoutComplete()` changed from `checkout` to `purchase` for `GoogleTagManager` implementation](https://github.com/pimcore/pimcore/pull/9366/files)\n- [Password encoding] Pimcore Password Encoder factory has been deprecated in favor of new Password Hasher factory, to align with Symfony authentication system. The default factory is used as default and to switch to new Password hasher factory, please enable through config `factory_type` as follows:\n```yaml\npimcore:\n    security:\n        factory_type: password_hasher\n\n        # the password hasher factory as defined in services.yml\n        password_hasher_factories:\n            App\\Model\\DataObject\\User: website_demo.security.password_hasher_factory\n```\nand use new service handler:\n```yaml\nservices:\n    website_demo.security.password_hasher_factory:\n        class: Pimcore\\Security\\Hasher\\Factory\\UserAwarePasswordHasherFactory\n        arguments:\n            - Pimcore\\Security\\Hasher\\PasswordFieldHasher\n            - ['password']\n```\n- [Session] Default setting for `framework.session.cookie_samesite` changed to `strict`. \n  For more information about the possible impact on your project, please have a look at the [docs of set-cookie](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite). \n  If you prefer to stay on the old session cookie behavior, please add the following to your project configuration: \n```yaml\nframework:\n    session:\n        cookie_samesite: 'lax'\n```  \n\n## 10.0.0\n\n### System Requirements\n     - PHP >= 8.0\n     - Apache >= 2.4\n\n### Database\n    - MariaDB >= 10.3\n    - MySQL >= 8.0\n    - Percona Server (supported versions see MySQL)\n### Changes\n- Bumped `symfony/symfony` to \"^5.2.0\". Pimcore X will only support Symfony 5.\n- ExtJS bumped to version 7.\n- Bumped:\n    - `guzzlehttp/guzzle` to \"^7.2\"\n    - `sensio/framework-extra-bundle` to \"^6.1\"\n    - `twig/twig` to \"^3.0\"\n    - `egulias/email-validator` to \"^3.0.0\"\n    - `onnov/detect-encoding` to \"^2.0\"\n    - `mjaschen/phpgeo` to \"^3.0\"\n    - `matomo/device-detector` to \"^4.0\"\n    - `ext-imagick` to \"^3.4.0\" (suggest)\n    - `lcobucci/jwt` to \"^4.0\"\n\n- `Pimcore\\Model\\DataObject\\ClassDefinition\\Data::isEqual()` has been removed. For custom data types, implement `\\Pimcore\\Model\\DataObject\\ClassDefinition\\Data\\EqualComparisonInterface` instead.\n- `Pimcore\\Model\\Document\\Editable`(former. `Tags`) properties visibility changed from `protected` to `private`.\n- [Templating]\n    - PHP templating engine (including templating helpers & vars) has been removed to support Symfony 5. Use Twig or Php Templating Engine Bundle(enterprise) instead.\n    - Removed ViewModel.\n    - Removed Auto view rendering.\n    - Removed Placeholder support. Use Twig Parameters instead.\n\n- `Pimcore\\Model\\Tool\\Tracking\\Event` has been removed.\n- `Pimcore\\Tool\\Archive` has been removed.\n- The object query table will now consider the fallback language. If you want to keep the old behavior set `pimcore.objects.ignore_localized_query_fallback` in your configuration.\n- Removed QR Codes.\n- Remove Linfo Integration.\n- [Ecommerce][IndexService] Removed FactFinder integration.\n- Removed `Pimcore\\Model\\Tool\\Lock`.\n- Removed HybridAuth integration.\n- Removed `Pimcore\\Model\\Document\\Tag\\*` classes. Use `Pimcore\\Model\\Document\\Editable\\*` classes instead.\n- Removed `pimcore_tag_` css classes, use `pimcore_editable_` css instead.\n- Removed REST Webservice API.\n- Removed Legacy [Service aliases](https://github.com/pimcore/pimcore/pull/7281/files).\n- [Document] Removed support for edit.php on Area-Bricks. Use new feature: Editable Dialog Box instead.\n- [Glossary] Removed support for `Acronym`. Use `Abbr` instead.\n- [Element] Added `setProperties()` and `setProperty()` methods to `Pimcore\\Model\\Element\\ElementInterface`.\n- [Element] `setProperty()` method param `$inheritable` defaults to false. Adding a new property will create a non-inheritable property for documents.\n- [Document] Removed Editable Naming Strategy Support.\n- Removed Cookie Policy Info Bar Integration.\n- Removed `\\Pimcore\\Browser` class. Use `\\Browser` instead.\n- Method signature `PageSnippet::setEditable(string $name, Editable $data)` has been changed to `PageSnippet::setEditable(Editable $editable)`.\n- Removed Tag & Snippet Management.\n- Removed `Pimcore\\Controller\\EventedControllerInterface`. Use `Pimcore\\Controller\\KernelControllerEventInterface` and `Pimcore\\Controller\\KernelResponseEventInterface` instead.\n- Doctrine dependencies bumped to latest major version:\n    - \"doctrine/common\": \"^3.0.0\"\n    - \"doctrine/inflector\": \"^2.0.0\"\n- Removed service `pimcore.implementation_loader.document.tag`. Use `Pimcore\\Model\\Document\\Editable\\Loader\\EditableLoader` instead.\n- Removed Pimcore Bundles generator and command `pimcore:generate:bundle`.\n- `Pimcore\\Controller\\Controller` abstract class now extends `Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController` instead of `Symfony\\Bundle\\FrameworkBundle\\Controller\\Controller`.\n- `Pimcore\\Translation\\Translator::transChoice()` & `Pimcore\\Bundle\\AdminBundle\\Translation\\AdminUserTranslator::transChoice()` methods have been removed. Use `trans()` method with `%count%` parameter.\n- Removed `pimcore.documents.create_redirect_when_moved` config. Please remove from System.yml.\n- Removed `pimcore.workflows.initial_place` config. Use `pimcore.workflows.initial_markings` instead.\n- `WebDebugToolbarListenerPass` has been removed and `WebDebugToolbarListener` has been marked as final & internal.\n- Bumped `sabre/dav` to ^4.1.1\n- Removed `Pimcore\\Model\\Element\\Reference\\Placeholder` class.\n- Removed `pimcore.routing.defaults`. Use `pimcore.documents.default_controller` instead.\n- Removed `\\Pimcore\\Tool::getRoutingDefaults()`, `PageSnippet::$module|$action|get/setAction()|get/setModule()`, `DocType::$module|$action|get/setAction()|get/setModule()`, `Staticroute::$module|$action|get/setAction()|get/setModule()`.\n- Removed `\\Pimcore\\Tool::getValidCacheKey/()`, use `preg_replace('/[^a-zA-Z0-9]/', '_', $key)` instead.\n- Removed `\\Pimcore\\Tool::isValidPath/()`, use `\\Pimcore\\Model\\Element\\Service::isValidPath()` instead.\n- Deprecated `\\Pimcore\\Model\\Element\\Service::getSaveCopyName()`, use `getSafeCopyName()` instead.\n- Deprecated methods `getObject()` and `setObject()` on the classes `\\Pimcore\\Model\\Document\\Link` and `\\Pimcore\\Model\\DataObject\\Data\\Link`, use `getElement()` and `setElement()` instead.\n- Using dynamic modules, controllers and actions in static routes (e.g. `%controller`) does not work anymore.\n- Removed `\\Pimcore\\Controller\\Config\\ConfigNormalizer`.\n- Removed `pimcore_action()` Twig extension. Use Twig `render()` instead.\n- Removed `\\Pimcore\\Console\\Log\\Formatter\\ConsoleColorFormatter`\n- Removed `\\Pimcore\\Console\\CliTrait`, use `php_sapi_name() === 'cli'` instead.\n- Removed `\\Pimcore\\Console\\Dumper`, use Symfony's `VarDumper` instead.\n- Removed `\\Pimcore\\Google\\Webmastertools`, use `\\Pimcore\\Config::getReportConfig()->get('webmastertools'')` instead.\n- Removed `\\Pimcore\\Helper\\JsonFormatter`, use `json_encode($data, JSON_PRETTY_PRINT)` instead.\n- Removed `\\Pimcore\\Log\\Handler\\Mail`, there's no replacement for this internal class.\n- Removed `\\Pimcore\\File::isIncludeable()` method, there's no replacement.\n- Removed `\\Pimcore\\DataObject\\GridColumnConfig\\AbstractConfigElement` just implement `\\Pimcore\\DataObject\\GridColumnConfig\\ConfigElementInterface` instead.\n- [Documents] Renderlet Editable: removed `action` & `bundle` config. Specify controller reference, e.g. `App\\Controller\\FooController::myAction`\n- Bumped `codeception/codeception` to \"^4.1.12\".\n- Pimcore Bundle Migrations: Extending the functionality of `DoctrineMigrationsBundle` is not any longer possible the way we did it in the past. Therefore we're switching to standard Doctrine migrations, this means also that migration sets are not supported anymore and that the available migrations have to be configured manually or by using flex.\n    ```yaml\n      doctrine_migrations:\n          migrations_paths:\n              'Pimcore\\Bundle\\DataHubBundle\\Migrations': '@PimcoreDataHubBundle/Migrations'\n              'CustomerManagementFrameworkBundle\\Migrations': '@PimcoreCustomerManagementFrameworkBundle/Migrations'\n    ```\n  However, we've extended the doctrine commands to accept an optional `--prefix` option, which let's you filter configured migration classes. This is in a way an adequate replacement for the `-s` (sets) option.\n\n  `./bin/console doctrine:migrations:list --prefix=Pimcore\\\\Bundle\\\\CoreBundle`\n\n- [Ecommerce] Added `setItems($items)` method `CartInterface`, `getRule()` to `ModificatedPriceInterface` & `getId()` method to `ProductInterface`.\n- [Data Objects] Relation Data-Types: throws exception if object without an ID was assigned. e.g.\n    ```php\n    $newObject = new MyDataObject();\n    $existingObject->setMyRelations([$newObject]);\n    $existingObject->save(); //validation error\n    ```\n- [Data Objects] ManyToMany Relation Types: throws exception if multiple assignments passed without enabling Multiple assignments on class definition.\n- [Data Objects] ReverseManyToManyObjectRelation - now supports reverse relations from ManyToOneRelation field and has been renamed to ReverseObjectRelation with BC layer.\n- [Data Object] Table Data-Type always return an array.\n- [Data Object] `Model::getById()` & `Model::getByPath()` do not catch exceptions anymore.\n- Added methods `getArgument($key)`, `setArgument($key, $value)`, `getArguments()`, `setArguments(array $args = [])`, `hasArgument($key)` to `Pimcore\\Model\\Element\\ElementInterface\\ElementEventInterface`.\n- [Ecommerce] Changed name of interfaces from I* to *Interface .e.g. `Pimcore\\Bundle\\EcommerceFrameworkBundle\\Model\\ICheckoutable` => `Pimcore\\Bundle\\EcommerceFrameworkBundle\\Model\\CheckoutableInterface`\n- Removed `cache/tag-interop`dependency.\n- [Cache] `Pimcore\\Cache` is directly based on Symfony/Cache. If you have custom cache pool configured under `pimcore.cache.pools` then change it to Symfony Config `framework.cache.pools`. [Read more](https://pimcore.com/docs/pimcore/master/Development_Documentation/Development_Tools_and_Details/Cache/index.html#page_Configuring-the-cache)\n- Methods `checkCsrfToken()`, `getCsrfToken()`, `regenerateCsrfToken()` methdos have been removed from `Pimcore\\Bundle\\AdminBundle\\EventListener\\CsrfProtectionListener`. Use `Pimcore\\Bundle\\AdminBundle\\Security\\CsrfProtectionHandler` instead.\n- Bumped `phpunit/phpunit` & `codeception/phpunit-wrapper` to \"^9\"\n- Replaced `html2text/html2text` with `soundasleep/html2text`. Removed methods from `Pimcore\\Mail`: `determineHtml2TextIsInstalled()`, `setHtml2TextOptions($options = [])`, `getHtml2TextBinaryEnabled()`, `enableHtml2textBinary()`, `getHtml2textInstalled()`.\n- Replaced `doctrine/common` with `doctrine/persistence`.\n- [Asset] Image thumbnails: Using getHtml() will return `<picture>` tag instead of `<img>` tag.\n- [Asset] Config option `pimcore.assets.image.thumbnails.webp_auto_support` was removed, since the browser detection is not needed anymore using the `<picture>` tags for thumbnails. \n- [Ecommerce] Marked `AbstractOrder` & `AbstractOrderItem` classes as abstract.\n    Changes on `AbstractOrder` class:\n    - Added: `getCartHash()`, `getComment()`, `setComment()`\n    - Removed: `getDeliveryEMail()`, `setDeliveryEMail()`, `getCartModificationTimestamp()`\n- [Data Objects] Data-Types: Removed getPhpdocType() BC layer\n- [Ecommerce][FilterService] Added method `getFilterValues()` to `Pimcore\\Bundle\\EcommerceFrameworkBundle\\FilterService\\FilterType\\AbstractFilterType`\n- [Data Objects] OwnerAwareFieldInterface: added methods `_setOwner($owner)`, `_setOwnerFieldname(?string $fieldname)`, `_setOwnerLanguage(?string $language)`, `_getOwner()`, `_getOwnerFieldname()`, _getOwnerLanguage() and removed method `setOwner($owner, string $fieldname, $language = null)`.\n- [Translations] Remove `pimcore.translations.case_insensitive` support.\n- [Core] Folder structure updated to support Symfony Flex. Changes as per [Symfony Docs](https://symfony.com/doc/5.2/setup/flex.html)\n- [Translations] `Pimcore\\Model\\Translation\\AbstractTranslation`, `Pimcore\\Model\\Translation\\Admin` and `Pimcore\\Model\\Translation\\Website` with corresponding listing classes have been removed. Use new class `Pimcore\\Model\\Translation` with domain support (`Translation::DOMAIN_DEFAULT` or `Translation::DOMAIN_ADMIN`).\n- Replaced `scheb/two-factor-bundle` with `scheb/2fa-bundle`, `scheb/2fa-google-authenticator` & `scheb/2fa-qr-code`.\n- Removed Laminas Packages.\n- Removed Zend Compatibility Query Builder.\n- [Ecommerce] Payment Providers: Removed `WirecardSeamless`, `Qpay`, `Paypal` integration and moved to a separate bundle:\n    - `Datatrans` => https://github.com/pimcore/payment-provider-datatrans\n    - `Heidelpay` => https://github.com/pimcore/payment-provider-unzer\n    - `Hobex` => https://github.com/pimcore/payment-provider-hobex\n    - `Klarna` => https://github.com/pimcore/payment-provider-klarna\n    - `Mpay24Seamless` => https://github.com/pimcore/payment-provider-mpay24-seamless\n    - `OGone` => https://github.com/pimcore/payment-provider-ogone\n    - `PayPalSmartPaymentButton` => https://github.com/pimcore/payment-provider-paypal-smart-payment-button\n    - `PayU` => https://github.com/pimcore/payment-provider-payu\n\n- [Core] Security configurations not merged anymore from custom bundles.\n- `twig/extensions` dependency has been removed.\n- Removed legacy transliterator (changes related to `\\Pimcore\\Tool\\Transliteration::_transliterationProcess`).\n- Config: Invalid pimcore configurations will result in compile error:\n    ```yaml\n      pimcore:\n         xyz:\n            xyz:\n    ```\n- [Data Objects] Removed `getFromCsvImport()` method from data-types.\n- Replaced `Ramsey/Uuid` with `Symfony/Uuid`.\n- Matomo Integration has been removed.\n- `Pimcore\\Tool\\Console::exec()` method has been removed. Use Symfony\\Component\\Process\\Process instead.\n- `\\Pimcore\\Tool\\Console::getOptions()` method has been removed.\n- `\\Pimcore\\Tool\\Console::getOptionString()` method has been removed.\n- `\\Pimcore\\Tool\\Console::checkCliExecution()` method has been removed.\n- `Pimcore\\Twig\\Extension\\Templating\\Navigation::buildNavigation()` method has been removed.\n- `Pimcore\\Tool\\Mime` class has been removed. Use `Symfony\\Component\\Mime\\MimeTypes` instead.\n- [Documents] Areabricks: location changed from `Areas` to `areas` with BC layer.\n- [Documents] Areablocks: Adding a brick to areablocks will not trigger reload by default anymore and should be configured per Brick.\n- SQIP support has been removed.\n- `Thumbnail::getHtml()` doesn't accept direct pass of HTML attributes such as `class` or `title` anymore, use `imageAttributes` or `pictureAttributes` instead.\n- Removed methods `getForcePictureTag()` and `setForcePictureTag()` from `\\Pimcore\\Model\\Asset\\Image\\Thumbnail\\Config`\n- `\\Pimcore\\Model\\Document\\Editable\\Block\\AbstractBlockItem::getElement()` has been removed, use `getEditable()` instead.\n- `\\Pimcore\\Model\\DataObject\\Service::removeObjectFromSession()` has been removed, use `removeElementFromSession()` instead.\n- `\\Pimcore\\Model\\DataObject\\Service::getObjectFromSession()` has been removed, use `getElementFromSession()` instead.\n- `\\Pimcore\\Model\\Asset\\Image\\Thumbnail\\Config::setColorspace()` has been removed\n- `\\Pimcore\\Model\\Asset\\Image\\Thumbnail\\Config::getColorspace()` has been removed\n- `\\Pimcore\\Model\\DataObject\\ClassDefinition\\Data\\DataInterface` has been removed\n- `\\Pimcore\\Model\\Asset\\Listing::getPaginatorAdapter` has been removed, use `knplabs/knp-paginator-bundle` instead.\n- `\\Pimcore\\Model\\Document\\Listing::getPaginatorAdapter` has been removed, use `knplabs/knp-paginator-bundle` instead.\n- `\\Pimcore\\Model\\DataObject\\Listing::getPaginatorAdapter` has been removed, use `knplabs/knp-paginator-bundle` instead.\n- `\\Pimcore\\Google\\Cse::getPaginatorAdapter` has been removed, use `knplabs/knp-paginator-bundle` instead.\n- `\\Pimcore\\Helper\\RobotsTxt` has been removed\n- `\\Pimcore\\Tool\\Frontend::getSiteKey()` method has been removed.\n- `\\Pimcore\\Model\\User::getUsername()` has been removed, use `User::getName()` instead.\n- `\\Pimcore\\Cache\\Runtime::get('pimcore_editmode')` isn't supported anymore, use `EditmodeResolver` service instead.\n- [Documents] `Editable::factory()` was removed, use `EditableLoader` service instead.\n- [Data Objects] Removed CSV import feature. Use https://github.com/pimcore/data-importer or https://github.com/w-vision/DataDefinitions instead.\n- [DataObjects] marked `Pimcore\\DataObject\\GridColumnConfig\\Operator` operator classes as final and internal\n- [DataObjects] Calculator classes of Calculated Values must implement the `Pimcore\\Model\\DataObject\\ClassDefinition\\CalculatorClassInterface` now.\n- [DataObjects] PHP Class `Pimcore\\Model\\DataObject\\Data\\Geopoint` has been replaced with `GeoCoordinates`. Changed the signature of `__construct`.\n- Added `Pimcore\\Bundle\\EcommerceFrameworkBundle\\FilterService\\FilterType\\AbstractFilterType::getFilterValues()` with the same signature as `getFilterFrontend()`. To upgrade, rename `getFilterFrontend()` to `getFilterValues()` and remove the rendering stuff to just return the data array.\n\n    Before:\n    ```php\n    public function getFilterFrontend(AbstractFilterDefinitionType $filterDefinition, ProductListInterface $productList, $currentFilter)\n    {\n        // ...\n        return $this->render($this->getTemplate($filterDefinition), [\n            //...\n        ]);\n    }\n    ```\n    After:\n    ```php\n    public function getFilterValues(AbstractFilterDefinitionType $filterDefinition, ProductListInterface $productList, array $currentFilter): array\n    {\n        // ...\n        return [\n            //...\n        ];\n    }\n    ```\n- Added Validation for Geo datatypes\n    - for Geopolyline and Geopolygon invalid data doesn't get serialized 1:1 anymore\n    - for Geobounds and Geopoint invalid data doesn't get dropped silently anymore\n- Calling `$imageAsset->getThumbnail('non-existing-thumbnail-definition)` with a non-existing thumbnail definition will now throw an exception. Same goes for video assets and video image thumbnails.\n- Removed grid column operator `ObjectBrickGetter` since it is obsolete\n- Grid operator `AnyGetter` available only for admin users from now on\n- [Ecommerce] Added `getAttributeConfig` method to `Pimcore\\Bundle\\EcommerceFrameworkBundle\\IndexService\\Config\\ConfigInterface` interface\n- [Ecommerce] Added `getClientConfig` method to `Pimcore\\Bundle\\EcommerceFrameworkBundle\\IndexService\\Config\\ElasticSearchConfigInterface`\n- [Ecommerce] Added abstract method `setSuccessorOrder` to `Pimcore\\Bundle\\EcommerceFrameworkBundle\\Model\\AbstractOrder`\n- [Ecommerce] Indexing doesn't catch any exceptions that occur during preprocessing of attributes in BatchProcessing workers (e.g. elasticsearch).\n  You can change that behavior with event listeners.\n- [Ecommerce] Added abstract method `setCartHash` to `Pimcore\\Bundle\\EcommerceFrameworkBundle\\Model\\AbstractOrder`\n- [Ecommerce] Added `getFieldNameMapped` to ` Pimcore\\Bundle\\EcommerceFrameworkBundle\\IndexService\\Config\\ElasticSearchConfigInterface`\n- [Ecommerce] Added `getReverseMappedFieldName` to ` Pimcore\\Bundle\\EcommerceFrameworkBundle\\IndexService\\Config\\ElasticSearchConfigInterface`\n- [Ecommerce] Changed tenant config type hint to `FindologicConfigInterface` in `Pimcore\\Bundle\\EcommerceFrameworkBundle\\IndexService\\ProductList\\DefaultFindologic::__construct`\n- [Ecommerce] Changed price fields `totalNetPrice` and `totalPrice` of `OnlineShopOrderItem` to decimal.\n- [Ecommerce] Removed deprecated configuration options `enabled`, `pricing_manager_id` and `pricing_manager_options` for pricing_manager.\n  Use tenant specific options.\n- [Ecommerce] Removed deprecated functions `get/setCurrentTenant` and `get/setCurrentSubTenant`\n  of `EnvironmentInterface`\n- [Ecommerce] Removed deprecated service alias for `Pimcore\\Bundle\\EcommerceFrameworkBundle\\IEnvironment`\n- [Ecommerce] Removed deprecated functions `getGeneralSearchColumns`, `createOrUpdateTable`, `getIndexColumns` and `getIndexColumnsByFilterGroup`\n  of `IndexService`\n- [Ecommerce] Removed deprecated function `getPaginatorAdapter` from\n  `ProductList\\MySql`, `ProductList\\DefaultFindologic`, `ProductList\\ElasticSearch\\AbstractElasticSearch`, `Token\\Listing` and `AbstractOrderList`\n- [Ecommerce] Removed deprecated functions `getCalculatedPrice` and `getCalculatedPriceInfo` from `AbstractSetProduct`\n- [Ecommerce] Removed deprecated protected function `getAvailableFilterValues` from `Order\\Listing`\n- [Ecommerce] Activated `generateTypeDeclarations` for all generated data object classes and field collections. For migration\n  activate `generateTypeDeclarations` to all Ecommerce Framework data object classes and update your source code accordingly.\n- [Ecommerce] Made methods abstract instead of throwing `UnsupportedException` where easily possible for model classes (`AbstractProduct`, `AbstractSetProduct`, `AbstractOfferToolProduct`, `AbstractOfferItem`, `AbstractOffer`).\n- [Ecommerce] Added type declarations to Ecommerce Framework product interfaces (`ProductInterface`, `IndexableInterface`, `CheckoutableInterface`).\n- [Ecommerce] Removed Elasticsearch 5 and 6 support\n- [Ecommerce] `getItemAmount` and `getItemCount` of `Carts` now require string parameter (instead of boolean). Use one of\n`CartInterface::COUNT_MAIN_ITEMS_ONLY`, `CartInterface::COUNT_MAIN_AND_SUB_ITEMS`, `CartInterface::COUNT_MAIN_OR_SUB_ITEMS`.\n- [Ecommerce] Removed legacy CheckoutManager architecture, migrate your project to V7 if not already\n  - `CancelPaymentOrRecreateOrderStrategy` is now default strategy for handling active payments\n  - Removed method `isCartReadOnly` from cart and `cart_readonly_mode` configuration option as readonly mode\n    does not exist anymore.\n  - Removed deprecated method `initPayment` from `PaymentInterface`\n- [Ecommerce] Removed deprecated `ecommerce:indexservice:process-queue` command,\n  use `ecommerce:indexservice:process-preparation-queue` or `ecommerce:indexservice:process-update-queue` instead\n- [Ecommerce] Removed deprecated `mapping` option in index attributes configuration (never worked properly anyway)\n- [Ecommerce] Removed deprecated `IndexUpdater` tool\n- [Ecommerce] Removed legacy BatchProcessing worker mode, product centric batch processing is now standard\n  - Removed abstract class `AbstractBatchProcessingWorker`, use `ProductCentricBatchProcessing` instead\n  - Removed methods from interface `BatchProcessingWorkerInterface` and its implementations:\n     - `BatchProcessingWorkerInterface::processPreparationQueue`\n     - `BatchProcessingWorkerInterface::processUpdateIndexQueue`\n  - Added methods to interface `BatchProcessingWorkerInterface`\n    - `BatchProcessingWorkerInterface::prepareDataForIndex`\n    - `BatchProcessingWorkerInterface::resetPreparationQueue`\n    - `BatchProcessingWorkerInterface::resetIndexingQueue`\n  - Removed constants\n     - `ProductCentricBatchProcessingWorker::WORKER_MODE_LEGACY`\n     - `ProductCentricBatchProcessingWorker::WORKER_MODE_PRODUCT_CENTRIC`\n  - Removed configuration node `worker_mode` in `index_service` configuration\n- [Ecommerce] Moved method `getIdColumnType` from `MysqlConfigInterface` to `ConfigInterface`. Since it was and still is\n  implemented in `AbstractConfig` this should not have any consequences.\n- [Ecommerce] Timestamp of CartItems is now in mirco seconds (existing data will be migrated).\n- [Ecommerce][PricingManager] Added two new interfaces `ProductActionInterface` and `CartActionInterface`. All actions\n  need to implement either of it - otherwise they will not be considered anymore in price calculation.\n- [Web2Print]\n   - Removed `PdfReactor8`, use `PdfReactor` instead.\n   - Removed PDFreactor version selection in web2print settings, since most current PDFreactor client lib\n     should be backwards compatible to older versions.\n- [Email & Newsletter] Swiftmailer has been replaced with Symfony Mailer. `\\Pimcore\\Mail` class now extends from `Symfony\\Component\\Mime\\Email` and new mailer service `Pimcore\\Mail\\Mailer` has been introduced, which decorates `Symfony\\Component\\Mailer\\Mailer`, for sending mails.\n\n    Email method and transport setting has been removed from System settings. Cleanup Swiftmailer config and setup mailer transports \"main\" & \"newsletter\" in config.yaml:\n    ```yaml\n    framework:\n        mailer:\n            transports:\n                main: smtp://user:pass@smtp.example.com:port\n                pimcore_newsletter: smtp://user:pass@smtp.example.com:port\n    ```\n    please see [Symfony Transport Setup](https://symfony.com/doc/5.2/mailer.html#transport-setup) for more information.\n\n    API changes:\n\n    Before:\n    ```php\n        $mail = new \\Pimcore\\Mail($subject = null, $body = null, $contentType = null, $charset = null);\n        $mail->setBodyText(\"This is just plain text\");\n        $mail->setBodyHtml(\"<b>some</b> rich text: {{ myParam }}\");\n        ...\n    ```\n    After:\n    ```php\n        $mail= new \\Pimcore\\Mail($headers = null, $body = null, $contentType = null);\n        $mail->text(\"This is just plain text\");\n        $mail->html(\"<b>some</b> rich text: {{ myParam }}\");\n        ...\n    ```\n\n    Before:\n    ```php\n      $mail->setFrom($emailAddress, $name);\n      $mail->setTo($emailAddress, $name);\n      ...\n    ```\n\n    After:\n    ```php\n      $mail->from(new \\Symfony\\Component\\Mime\\Address($emailAddress, $name));\n      $mail->to(new \\Symfony\\Component\\Mime\\Address($emailAddress, $name));\n      ...\n    ```\n- [Email & Newsletter] `\\Pimcore\\Mail::setEnableLayoutOnRendering/getEnableLayoutOnRendering()` methods have been removed, with Twig they are just not necessary anymore.\n- [Email & Newsletter] `\\Pimcore\\Mail::isValidEmailAddress()` method has been removed, use `EmailValidator` instead.\n- [Security] BruteforceProtectionHandler & BruteforceProtectionListener has been made final and marked as internal.\n- [JWTCookieSaveHandler] `Pimcore\\Targeting\\Storage\\Cookie\\JWT\\Decoder` has been removed in favor of `Lcobucci\\JWT\\Encoding\\JoseDecoder`.\n- `simple_html_dom` library has been removed. Use `Symfony\\Component\\DomCrawler\\Crawler` instead.\n- Removed deprecated Twig extension `pimcore_action()`.\n- Removed method `getFlag()` from `Pimcore\\Config`.\n- Removed `Pimcore\\Report` class.\n- [Versioning] Default behavior has been changed to following:\n    - Empty values for `steps` & `days` => unlimited versions.\n    - Value 0 for `steps` or `days` => no version will be saved at all & existing will be cleaned up.\n\n  please update your system settings as per the requirements.\n- Removed deprecated `marshal()` and `unmarshal()` methods from object data-types.\n- `DynamicTextLabelInterface::renderLayoutText()` must handle nullable object param.\n- [AdminBundle] Marked classes and controllers as @internal/final - please see all changes here: https://github.com/pimcore/pimcore/pull/8453/files & https://github.com/pimcore/pimcore/pull/8988/files\n"], "fixing_code": ["<?php\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\Bundle\\AdminBundle\\Controller\\Admin\\Asset;\n\nuse Pimcore\\Bundle\\AdminBundle\\Controller\\Admin\\ElementControllerBase;\nuse Pimcore\\Bundle\\AdminBundle\\Controller\\Traits\\AdminStyleTrait;\nuse Pimcore\\Bundle\\AdminBundle\\Controller\\Traits\\ApplySchedulerDataTrait;\nuse Pimcore\\Bundle\\AdminBundle\\Helper\\GridHelperService;\nuse Pimcore\\Bundle\\AdminBundle\\Security\\CsrfProtectionHandler;\nuse Pimcore\\Config;\nuse Pimcore\\Controller\\KernelControllerEventInterface;\nuse Pimcore\\Controller\\Traits\\ElementEditLockHelperTrait;\nuse Pimcore\\Db\\Helper;\nuse Pimcore\\Event\\Admin\\ElementAdminStyleEvent;\nuse Pimcore\\Event\\AdminEvents;\nuse Pimcore\\Event\\AssetEvents;\nuse Pimcore\\Event\\Model\\Asset\\ResolveUploadTargetEvent;\nuse Pimcore\\File;\nuse Pimcore\\Loader\\ImplementationLoader\\Exception\\UnsupportedException;\nuse Pimcore\\Logger;\nuse Pimcore\\Messenger\\AssetPreviewImageMessage;\nuse Pimcore\\Model;\nuse Pimcore\\Model\\Asset;\nuse Pimcore\\Model\\DataObject\\ClassDefinition\\Data\\ManyToManyRelation;\nuse Pimcore\\Model\\DataObject\\Concrete;\nuse Pimcore\\Model\\Element;\nuse Pimcore\\Model\\Element\\ValidationException;\nuse Pimcore\\Model\\Metadata;\nuse Pimcore\\Model\\Schedule\\Task;\nuse Pimcore\\Tool;\nuse Symfony\\Component\\EventDispatcher\\GenericEvent;\nuse Symfony\\Component\\HttpFoundation\\BinaryFileResponse;\nuse Symfony\\Component\\HttpFoundation\\JsonResponse;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpFoundation\\ResponseHeaderBag;\nuse Symfony\\Component\\HttpFoundation\\Session\\Attribute\\AttributeBagInterface;\nuse Symfony\\Component\\HttpFoundation\\StreamedResponse;\nuse Symfony\\Component\\HttpKernel\\Event\\ControllerEvent;\nuse Symfony\\Component\\Mime\\MimeTypes;\nuse Symfony\\Component\\Process\\Process;\nuse Symfony\\Component\\Routing\\Annotation\\Route;\nuse Symfony\\Contracts\\EventDispatcher\\EventDispatcherInterface;\n\n/**\n * @Route(\"/asset\")\n *\n * @internal\n */\nclass AssetController extends ElementControllerBase implements KernelControllerEventInterface\n{\n    use AdminStyleTrait;\n    use ElementEditLockHelperTrait;\n    use ApplySchedulerDataTrait;\n\n    /**\n     * @var Asset\\Service\n     */\n    protected $_assetService;\n\n    /**\n     * @Route(\"/tree-get-root\", name=\"pimcore_admin_asset_treegetroot\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function treeGetRootAction(Request $request)\n    {\n        return parent::treeGetRootAction($request);\n    }\n\n    /**\n     * @Route(\"/delete-info\", name=\"pimcore_admin_asset_deleteinfo\", methods={\"GET\"})\n     *\n     * @param Request $request\n     * @param EventDispatcherInterface $eventDispatcher\n     *\n     * @return JsonResponse\n     */\n    public function deleteInfoAction(Request $request, EventDispatcherInterface $eventDispatcher)\n    {\n        return parent::deleteInfoAction($request, $eventDispatcher);\n    }\n\n    /**\n     * @Route(\"/get-data-by-id\", name=\"pimcore_admin_asset_getdatabyid\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getDataByIdAction(Request $request, EventDispatcherInterface $eventDispatcher)\n    {\n        $assetId = (int)$request->get('id');\n        $type = (string)$request->get('type');\n\n        $asset = Asset::getById($assetId);\n        if (!$asset instanceof Asset) {\n            return $this->adminJson(['success' => false, 'message' => \"asset doesn't exist\"]);\n        }\n\n        // check for lock on non-folder items only.\n        if ($type !== 'folder' && ($asset->isAllowed('publish') || $asset->isAllowed('delete'))) {\n            if (Element\\Editlock::isLocked($assetId, 'asset')) {\n                return $this->getEditLockResponse($assetId, 'asset');\n            }\n\n            Element\\Editlock::lock($request->get('id'), 'asset');\n        }\n\n        $asset = clone $asset;\n        $asset->setParent(null);\n\n        $asset->setStream(null);\n        $data = $asset->getObjectVars();\n        $data['locked'] = $asset->isLocked();\n\n        if ($asset instanceof Asset\\Text) {\n            if ($asset->getFileSize() < 2000000) {\n                // it doesn't make sense to show a preview for files bigger than 2MB\n                $data['data'] = \\ForceUTF8\\Encoding::toUTF8($asset->getData());\n            } else {\n                $data['data'] = false;\n            }\n        } elseif ($asset instanceof Asset\\Document) {\n            $data['pdfPreviewAvailable'] = (bool)$this->getDocumentPreviewPdf($asset);\n        } elseif ($asset instanceof Asset\\Video) {\n            $videoInfo = [];\n\n            if (\\Pimcore\\Video::isAvailable()) {\n                $config = Asset\\Video\\Thumbnail\\Config::getPreviewConfig();\n                $thumbnail = $asset->getThumbnail($config, ['mp4']);\n                if ($thumbnail) {\n                    if ($thumbnail['status'] == 'finished') {\n                        $videoInfo['previewUrl'] = $thumbnail['formats']['mp4'];\n                        $videoInfo['width'] = $asset->getWidth();\n                        $videoInfo['height'] = $asset->getHeight();\n\n                        $metaData = $asset->getSphericalMetaData();\n                        if (isset($metaData['ProjectionType']) && strtolower($metaData['ProjectionType']) == 'equirectangular') {\n                            $videoInfo['isVrVideo'] = true;\n                        }\n                    }\n                }\n            }\n\n            $data['videoInfo'] = $videoInfo;\n        } elseif ($asset instanceof Asset\\Image) {\n            $imageInfo = [];\n\n            $previewUrl = $this->generateUrl('pimcore_admin_asset_getimagethumbnail', [\n                'id' => $asset->getId(),\n                'treepreview' => true,\n                '_dc' => time(),\n            ]);\n\n            if ($asset->isAnimated()) {\n                $previewUrl = $this->generateUrl('pimcore_admin_asset_getasset', [\n                    'id' => $asset->getId(),\n                    '_dc' => time(),\n                ]);\n            }\n\n            $imageInfo['previewUrl'] = $previewUrl;\n\n            if ($asset->getWidth() && $asset->getHeight()) {\n                $imageInfo['dimensions'] = [];\n                $imageInfo['dimensions']['width'] = $asset->getWidth();\n                $imageInfo['dimensions']['height'] = $asset->getHeight();\n            }\n\n            $imageInfo['exiftoolAvailable'] = (bool)\\Pimcore\\Tool\\Console::getExecutable('exiftool');\n\n            if (!$asset->getEmbeddedMetaData(false)) {\n                $asset->getEmbeddedMetaData(true, false); // read Exif, IPTC and XPM like in the old days ...\n            }\n\n            $data['imageInfo'] = $imageInfo;\n        }\n\n        $predefinedMetaData = Metadata\\Predefined\\Listing::getByTargetType('asset', [$asset->getType()]);\n        $predefinedMetaDataGroups = [];\n        /** @var Metadata\\Predefined $item */\n        foreach ($predefinedMetaData as $item) {\n            if ($item->getGroup()) {\n                $predefinedMetaDataGroups[$item->getGroup()] = true;\n            }\n        }\n        $data['predefinedMetaDataGroups'] = array_keys($predefinedMetaDataGroups);\n        $data['properties'] = Element\\Service::minimizePropertiesForEditmode($asset->getProperties());\n        $data['metadata'] = Asset\\Service::expandMetadataForEditmode($asset->getMetadata());\n        $data['versionDate'] = $asset->getModificationDate();\n        $data['filesizeFormatted'] = $asset->getFileSize(true);\n        $data['filesize'] = $asset->getFileSize();\n        $data['fileExtension'] = File::getFileExtension($asset->getFilename());\n        $data['idPath'] = Element\\Service::getIdPath($asset);\n        $data['userPermissions'] = $asset->getUserPermissions($this->getAdminUser());\n        $frontendPath = $asset->getFrontendFullPath();\n        $data['url'] = preg_match('/^http(s)?:\\\\/\\\\/.+/', $frontendPath) ?\n            $frontendPath :\n            $request->getSchemeAndHttpHost() . $frontendPath;\n\n        $data['scheduledTasks'] = array_map(\n            static function (Task $task) {\n                return $task->getObjectVars();\n            },\n            $asset->getScheduledTasks()\n        );\n\n        $this->addAdminStyle($asset, ElementAdminStyleEvent::CONTEXT_EDITOR, $data);\n\n        $data['php'] = [\n            'classes' => array_merge([get_class($asset)], array_values(class_parents($asset))),\n            'interfaces' => array_values(class_implements($asset)),\n        ];\n\n        $event = new GenericEvent($this, [\n            'data' => $data,\n            'asset' => $asset,\n        ]);\n        $eventDispatcher->dispatch($event, AdminEvents::ASSET_GET_PRE_SEND_DATA);\n        $data = $event->getArgument('data');\n\n        if ($asset->isAllowed('view')) {\n            return $this->adminJson($data);\n        }\n\n        throw $this->createAccessDeniedHttpException();\n    }\n\n    /**\n     * @Route(\"/tree-get-childs-by-id\", name=\"pimcore_admin_asset_treegetchildsbyid\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function treeGetChildsByIdAction(Request $request, EventDispatcherInterface $eventDispatcher)\n    {\n        $allParams = array_merge($request->request->all(), $request->query->all());\n\n        $assets = [];\n        $cv = false;\n        $asset = Asset::getById($allParams['node']);\n\n        $filter = $request->get('filter');\n        $limit = (int)$allParams['limit'];\n        if (!is_null($filter)) {\n            if (substr($filter, -1) != '*') {\n                $filter .= '*';\n            }\n            $filter = str_replace('*', '%', $filter);\n\n            $limit = 100;\n            $offset = 0;\n        } elseif (!$allParams['limit']) {\n            $limit = 100000000;\n        }\n\n        $offset = isset($allParams['start']) ? (int)$allParams['start'] : 0;\n\n        $filteredTotalCount = 0;\n\n        if ($asset->hasChildren()) {\n            if ($allParams['view']) {\n                $cv = \\Pimcore\\Model\\Element\\Service::getCustomViewById($allParams['view']);\n            }\n\n            // get assets\n            $childrenList = new Asset\\Listing();\n            $childrenList->addConditionParam('parentId = ?', [$asset->getId()]);\n            $childrenList->filterAccessibleByUser($this->getAdminUser(), $asset);\n\n            if (!is_null($filter)) {\n                $childrenList->addConditionParam('CAST(assets.filename AS CHAR CHARACTER SET utf8) COLLATE utf8_general_ci LIKE ?', [$filter]);\n            }\n\n            $childrenList->setLimit($limit);\n            $childrenList->setOffset($offset);\n            $childrenList->setOrderKey(\"FIELD(assets.type, 'folder') DESC, CAST(assets.filename AS CHAR CHARACTER SET utf8) COLLATE utf8_general_ci ASC\", false);\n\n            \\Pimcore\\Model\\Element\\Service::addTreeFilterJoins($cv, $childrenList);\n\n            $beforeListLoadEvent = new GenericEvent($this, [\n                'list' => $childrenList,\n                'context' => $allParams,\n            ]);\n            $eventDispatcher->dispatch($beforeListLoadEvent, AdminEvents::ASSET_LIST_BEFORE_LIST_LOAD);\n            /** @var Asset\\Listing $childrenList */\n            $childrenList = $beforeListLoadEvent->getArgument('list');\n\n            $children = $childrenList->load();\n\n            $filteredTotalCount = $childrenList->getTotalCount();\n\n            foreach ($children as $childAsset) {\n                $assetTreeNode = $this->getTreeNodeConfig($childAsset);\n                if ($assetTreeNode['permissions']['list'] == 1) {\n                    $assets[] = $assetTreeNode;\n                }\n            }\n        }\n\n        //Hook for modifying return value - e.g. for changing permissions based on asset data\n        $event = new GenericEvent($this, [\n            'assets' => $assets,\n        ]);\n        $eventDispatcher->dispatch($event, AdminEvents::ASSET_TREE_GET_CHILDREN_BY_ID_PRE_SEND_DATA);\n        $assets = $event->getArgument('assets');\n\n        if ($allParams['limit']) {\n            return $this->adminJson([\n                'offset' => $offset,\n                'limit' => $limit,\n                'total' => $asset->getChildAmount($this->getAdminUser()),\n                'overflow' => !is_null($filter) && ($filteredTotalCount > $limit),\n                'nodes' => $assets,\n                'filter' => $request->get('filter') ? $request->get('filter') : '',\n                'inSearch' => (int)$request->get('inSearch'),\n            ]);\n        } else {\n            return $this->adminJson($assets);\n        }\n    }\n\n    /**\n     * @Route(\"/add-asset\", name=\"pimcore_admin_asset_addasset\", methods={\"POST\"})\n     *\n     * @param Request $request\n     * @param Config $config\n     *\n     * @return JsonResponse\n     */\n    public function addAssetAction(Request $request, Config $config)\n    {\n        try {\n            $res = $this->addAsset($request, $config);\n\n            $response = [\n                'success' => $res['success'],\n            ];\n\n            if ($res['success']) {\n                $response['asset'] = [\n                    'id' => $res['asset']->getId(),\n                    'path' => $res['asset']->getFullPath(),\n                    'type' => $res['asset']->getType(),\n                ];\n            }\n\n            return $this->adminJson($response);\n        } catch (\\Exception $e) {\n            return $this->adminJson([\n                'success' => false,\n                'message' => $e->getMessage(),\n            ]);\n        }\n    }\n\n    /**\n     * @Route(\"/add-asset-compatibility\", name=\"pimcore_admin_asset_addassetcompatibility\", methods={\"POST\"})\n     *\n     * @param Request $request\n     * @param Config $config\n     *\n     * @return JsonResponse\n     */\n    public function addAssetCompatibilityAction(Request $request, Config $config)\n    {\n        try {\n            // this is a special action for the compatibility mode upload (without flash)\n            $res = $this->addAsset($request, $config);\n\n            $response = $this->adminJson([\n                'success' => $res['success'],\n                'msg' => $res['success'] ? 'Success' : 'Error',\n                'id' => $res['asset'] ? $res['asset']->getId() : null,\n                'fullpath' => $res['asset'] ? $res['asset']->getRealFullPath() : null,\n                'type' => $res['asset'] ? $res['asset']->getType() : null,\n            ]);\n            $response->headers->set('Content-Type', 'text/html');\n\n            return $response;\n        } catch (\\Exception $e) {\n            return $this->adminJson([\n                'success' => false,\n                'message' => $e->getMessage(),\n            ]);\n        }\n    }\n\n    /**\n     * @Route(\"/exists\", name=\"pimcore_admin_asset_exists\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     *\n     * @throws \\Exception\n     */\n    public function existsAction(Request $request)\n    {\n        $parentAsset = \\Pimcore\\Model\\Asset::getById((int)$request->get('parentId'));\n\n        return new JsonResponse([\n            'exists' => Asset\\Service::pathExists($parentAsset->getRealFullPath().'/'.$request->get('filename')),\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param Config $config\n     *\n     * @return array\n     *\n     * @throws \\Exception\n     */\n    protected function addAsset(Request $request, Config $config)\n    {\n        $defaultUploadPath = $config['assets']['default_upload_path'] ?? '/';\n\n        if (array_key_exists('Filedata', $_FILES)) {\n            $filename = $_FILES['Filedata']['name'];\n            $sourcePath = $_FILES['Filedata']['tmp_name'];\n        } elseif ($request->get('type') == 'base64') {\n            $filename = $request->get('filename');\n            $sourcePath = PIMCORE_SYSTEM_TEMP_DIRECTORY . '/upload-base64' . uniqid() . '.tmp';\n            $data = preg_replace('@^data:[^,]+;base64,@', '', $request->get('data'));\n            File::put($sourcePath, base64_decode($data));\n        } else {\n            throw new \\Exception('The filename of the asset is empty');\n        }\n\n        $parentId = $request->get('parentId');\n        $parentPath = $request->get('parentPath');\n\n        if ($request->get('dir') && $request->get('parentId')) {\n            // this is for uploading folders with Drag&Drop\n            // param \"dir\" contains the relative path of the file\n            $parent = Asset::getById((int) $request->get('parentId'));\n            $dir = $request->get('dir');\n            if (strpos($dir, '..') !== false) {\n                throw new \\Exception('not allowed');\n            }\n\n            $newPath = $parent->getRealFullPath() . '/' . trim($dir, '/ ');\n\n            $maxRetries = 5;\n            $newParent = null;\n            for ($retries = 0; $retries < $maxRetries; $retries++) {\n                try {\n                    $newParent = Asset\\Service::createFolderByPath($newPath);\n\n                    break;\n                } catch (\\Exception $e) {\n                    if ($retries < ($maxRetries - 1)) {\n                        $waitTime = rand(100000, 900000); // microseconds\n                        usleep($waitTime); // wait specified time until we restart the transaction\n                    } else {\n                        // if the transaction still fail after $maxRetries retries, we throw out the exception\n                        throw $e;\n                    }\n                }\n            }\n            if ($newParent) {\n                $parentId = $newParent->getId();\n            }\n        } elseif (!$request->get('parentId') && $parentPath) {\n            $parent = Asset::getByPath($parentPath);\n            if ($parent instanceof Asset\\Folder) {\n                $parentId = $parent->getId();\n            }\n        }\n\n        $filename = Element\\Service::getValidKey($filename, 'asset');\n        if (empty($filename)) {\n            throw new \\Exception('The filename of the asset is empty');\n        }\n\n        $context = $request->get('context');\n        if ($context) {\n            $context = json_decode($context, true);\n            $context = $context ?: [];\n\n            $this->validateManyToManyRelationAssetType($context, $filename, $sourcePath);\n\n            $event = new ResolveUploadTargetEvent($parentId, $filename, $context);\n            \\Pimcore::getEventDispatcher()->dispatch($event, AssetEvents::RESOLVE_UPLOAD_TARGET);\n            $filename = Element\\Service::getValidKey($event->getFilename(), 'asset');\n            $parentId = $event->getParentId();\n        }\n\n        if (!$parentId) {\n            $parentId = Asset\\Service::createFolderByPath($defaultUploadPath)->getId();\n        }\n\n        $parentAsset = Asset::getById((int)$parentId);\n\n        if (!$request->get('allowOverwrite')) {\n            // check for duplicate filename\n            $filename = $this->getSafeFilename($parentAsset->getRealFullPath(), $filename);\n        }\n\n        if (!$parentAsset->isAllowed('create')) {\n            throw $this->createAccessDeniedHttpException(\n                'Missing the permission to create new assets in the folder: ' . $parentAsset->getRealFullPath()\n            );\n        }\n\n        if (is_file($sourcePath) && filesize($sourcePath) < 1) {\n            throw new \\Exception('File is empty!');\n        } elseif (!is_file($sourcePath)) {\n            throw new \\Exception('Something went wrong, please check upload_max_filesize and post_max_size in your php.ini as well as the write permissions of your temporary directories.');\n        }\n\n        // check if there is a requested type and if matches the asset type of the uploaded file\n        $uploadAssetType = $request->get('uploadAssetType');\n        if ($uploadAssetType) {\n            $mimetype = MimeTypes::getDefault()->guessMimeType($sourcePath);\n            $assetType = Asset::getTypeFromMimeMapping($mimetype, $filename);\n\n            if ($uploadAssetType !== $assetType) {\n                throw new \\Exception(\"Mime type $mimetype does not match with asset type: $uploadAssetType\");\n            }\n        }\n\n        if ($request->get('allowOverwrite') && Asset\\Service::pathExists($parentAsset->getRealFullPath().'/'.$filename)) {\n            $asset = Asset::getByPath($parentAsset->getRealFullPath().'/'.$filename);\n            $asset->setStream(fopen($sourcePath, 'rb', false, File::getContext()));\n            $asset->save();\n        } else {\n            $asset = Asset::create($parentId, [\n                'filename' => $filename,\n                'sourcePath' => $sourcePath,\n                'userOwner' => $this->getAdminUser()->getId(),\n                'userModification' => $this->getAdminUser()->getId(),\n            ]);\n        }\n\n        @unlink($sourcePath);\n\n        return [\n            'success' => true,\n            'asset' => $asset,\n        ];\n    }\n\n    /**\n     * @param string $targetPath\n     * @param string $filename\n     *\n     * @return string\n     */\n    protected function getSafeFilename($targetPath, $filename)\n    {\n        $pathinfo = pathinfo($filename);\n        $originalFilename = $pathinfo['filename'];\n        $originalFileextension = empty($pathinfo['extension']) ? '' : '.' . $pathinfo['extension'];\n        $count = 1;\n\n        if ($targetPath == '/') {\n            $targetPath = '';\n        }\n\n        while (true) {\n            if (Asset\\Service::pathExists($targetPath . '/' . $filename)) {\n                $filename = $originalFilename . '_' . $count . $originalFileextension;\n                $count++;\n            } else {\n                return $filename;\n            }\n        }\n    }\n\n    /**\n     * @Route(\"/replace-asset\", name=\"pimcore_admin_asset_replaceasset\", methods={\"POST\", \"PUT\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     *\n     * @throws \\Exception\n     */\n    public function replaceAssetAction(Request $request)\n    {\n        $asset = Asset::getById((int) $request->get('id'));\n\n        $newFilename = Element\\Service::getValidKey($_FILES['Filedata']['name'], 'asset');\n        $mimetype = MimeTypes::getDefault()->guessMimeType($_FILES['Filedata']['tmp_name']);\n        $newType = Asset::getTypeFromMimeMapping($mimetype, $newFilename);\n\n        if ($newType != $asset->getType()) {\n            return $this->adminJson([\n                'success' => false,\n                'message' => sprintf($this->trans('asset_type_change_not_allowed', [], 'admin'), $asset->getType(), $newType),\n            ]);\n        }\n\n        $stream = fopen($_FILES['Filedata']['tmp_name'], 'r+');\n        $asset->setStream($stream);\n        $asset->setCustomSetting('thumbnails', null);\n        $asset->setUserModification($this->getAdminUser()->getId());\n\n        $newFileExt = File::getFileExtension($newFilename);\n        $currentFileExt = File::getFileExtension($asset->getFilename());\n        if ($newFileExt != $currentFileExt) {\n            $newFilename = preg_replace('/\\.' . $currentFileExt . '$/i', '.' . $newFileExt, $asset->getFilename());\n            $newFilename = Element\\Service::getSafeCopyName($newFilename, $asset->getParent());\n            $asset->setFilename($newFilename);\n        }\n\n        if ($asset->isAllowed('publish')) {\n            $asset->save();\n\n            $response = $this->adminJson([\n                'id' => $asset->getId(),\n                'path' => $asset->getRealFullPath(),\n                'success' => true,\n            ]);\n\n            // set content-type to text/html, otherwise (when application/json is sent) chrome will complain in\n            // Ext.form.Action.Submit and mark the submission as failed\n            $response->headers->set('Content-Type', 'text/html');\n\n            return $response;\n        } else {\n            throw new \\Exception('missing permission');\n        }\n    }\n\n    /**\n     * @Route(\"/add-folder\", name=\"pimcore_admin_asset_addfolder\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function addFolderAction(Request $request)\n    {\n        $success = false;\n        $parentAsset = Asset::getById((int)$request->get('parentId'));\n        $equalAsset = Asset::getByPath($parentAsset->getRealFullPath() . '/' . $request->get('name'));\n\n        if ($parentAsset->isAllowed('create')) {\n            if (!$equalAsset) {\n                $asset = Asset::create($request->get('parentId'), [\n                    'filename' => $request->get('name'),\n                    'type' => 'folder',\n                    'userOwner' => $this->getAdminUser()->getId(),\n                    'userModification' => $this->getAdminUser()->getId(),\n                ]);\n                $success = true;\n            }\n        } else {\n            Logger::debug('prevented creating asset because of missing permissions');\n        }\n\n        return $this->adminJson(['success' => $success]);\n    }\n\n    /**\n     * @Route(\"/delete\", name=\"pimcore_admin_asset_delete\", methods={\"DELETE\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function deleteAction(Request $request)\n    {\n        $type = $request->get('type');\n\n        if ($type === 'childs') {\n            trigger_deprecation(\n                'pimcore/pimcore',\n                '10.4',\n                'Type childs is deprecated. Use children instead'\n            );\n            $type = 'children';\n        }\n        if ($type === 'children') {\n            $parentAsset = Asset::getById((int) $request->get('id'));\n\n            $list = new Asset\\Listing();\n            $list->setCondition('path LIKE ?', [Helper::escapeLike($parentAsset->getRealFullPath()) . '/%']);\n            $list->setLimit((int)$request->get('amount'));\n            $list->setOrderKey('LENGTH(path)', false);\n            $list->setOrder('DESC');\n\n            $deletedItems = [];\n            foreach ($list as $asset) {\n                $deletedItems[$asset->getId()] = $asset->getRealFullPath();\n                if ($asset->isAllowed('delete') && !$asset->isLocked()) {\n                    $asset->delete();\n                }\n            }\n\n            return $this->adminJson(['success' => true, 'deleted' => $deletedItems]);\n        }\n        if ($request->get('id')) {\n            $asset = Asset::getById((int) $request->get('id'));\n            if ($asset && $asset->isAllowed('delete')) {\n                if ($asset->isLocked()) {\n                    return $this->adminJson([\n                        'success' => false,\n                        'message' => 'prevented deleting asset, because it is locked: ID: ' . $asset->getId(),\n                    ]);\n                }\n\n                $asset->delete();\n\n                return $this->adminJson(['success' => true]);\n            }\n        }\n\n        throw $this->createAccessDeniedHttpException();\n    }\n\n    /**\n     * @param Asset $element\n     *\n     * @return array\n     */\n    protected function getTreeNodeConfig($element)\n    {\n        $asset = $element;\n\n        $permissions =  $asset->getUserPermissions($this->getAdminUser());\n\n        $tmpAsset = [\n            'id' => $asset->getId(),\n            'key' => $element->getKey(),\n            'text' => htmlspecialchars($asset->getFilename()),\n            'type' => $asset->getType(),\n            'path' => $asset->getRealFullPath(),\n            'basePath' => $asset->getRealPath(),\n            'locked' => $asset->isLocked(),\n            'lockOwner' => $asset->getLocked() ? true : false,\n            'elementType' => 'asset',\n            'permissions' => [\n                'remove' => $permissions['delete'],\n                'settings' => $permissions['settings'],\n                'rename' => $permissions['rename'],\n                'publish' => $permissions['publish'],\n                'view' => $permissions['view'],\n                'list' => $permissions['list'],\n            ],\n        ];\n\n        $hasChildren = $asset->getDao()->hasChildren($this->getAdminUser());\n\n        // set type specific settings\n        if ($asset instanceof Asset\\Folder) {\n            $tmpAsset['leaf'] = false;\n            $tmpAsset['expanded'] = !$hasChildren;\n            $tmpAsset['loaded'] = !$hasChildren;\n            $tmpAsset['permissions']['create'] = $permissions['create'];\n            $tmpAsset['thumbnail'] = $this->getThumbnailUrl($asset, ['origin' => 'treeNode']);\n        } else {\n            $tmpAsset['leaf'] = true;\n            $tmpAsset['expandable'] = false;\n            $tmpAsset['expanded'] = false;\n        }\n\n        $this->addAdminStyle($asset, ElementAdminStyleEvent::CONTEXT_TREE, $tmpAsset);\n\n        if ($asset instanceof Asset\\Image) {\n            try {\n                $tmpAsset['thumbnail'] = $this->getThumbnailUrl($asset, ['origin' => 'treeNode']);\n\n                // we need the dimensions for the wysiwyg editors, so that they can resize the image immediately\n                if ($asset->getCustomSetting('imageDimensionsCalculated')) {\n                    $tmpAsset['imageWidth'] = $asset->getCustomSetting('imageWidth');\n                    $tmpAsset['imageHeight'] = $asset->getCustomSetting('imageHeight');\n                }\n            } catch (\\Exception $e) {\n                Logger::debug('Cannot get dimensions of image, seems to be broken.');\n            }\n        } elseif ($asset->getType() == 'video') {\n            try {\n                if (\\Pimcore\\Video::isAvailable()) {\n                    $tmpAsset['thumbnail'] = $this->getThumbnailUrl($asset, ['origin' => 'treeNode']);\n                }\n            } catch (\\Exception $e) {\n                Logger::debug('Cannot get dimensions of video, seems to be broken.');\n            }\n        } elseif ($asset->getType() == 'document') {\n            try {\n                // add the PDF check here, otherwise the preview layer in admin is shown without content\n                if (\\Pimcore\\Document::isAvailable() && \\Pimcore\\Document::isFileTypeSupported($asset->getFilename())) {\n                    $tmpAsset['thumbnail'] = $this->getThumbnailUrl($asset, ['origin' => 'treeNode']);\n                }\n            } catch (\\Exception $e) {\n                Logger::debug('Cannot get dimensions of video, seems to be broken.');\n            }\n        }\n\n        $tmpAsset['cls'] = '';\n        if ($asset->isLocked()) {\n            $tmpAsset['cls'] .= 'pimcore_treenode_locked ';\n        }\n        if ($asset->getLocked()) {\n            $tmpAsset['cls'] .= 'pimcore_treenode_lockOwner ';\n        }\n\n        return $tmpAsset;\n    }\n\n    /**\n     * @param Asset $asset\n     * @param array $params\n     *\n     * @return null|string\n     */\n    protected function getThumbnailUrl(Asset $asset, array $params = [])\n    {\n        $defaults = [\n            'id' => $asset->getId(),\n            'treepreview' => true,\n            '_dc' => $asset->getModificationDate(),\n        ];\n\n        $params = array_merge($defaults, $params);\n\n        if ($asset instanceof Asset\\Image) {\n            return $this->generateUrl('pimcore_admin_asset_getimagethumbnail', $params);\n        }\n\n        if ($asset instanceof Asset\\Folder) {\n            return $this->generateUrl('pimcore_admin_asset_getfolderthumbnail', $params);\n        }\n\n        if ($asset instanceof Asset\\Video && \\Pimcore\\Video::isAvailable()) {\n            return $this->generateUrl('pimcore_admin_asset_getvideothumbnail', $params);\n        }\n\n        if ($asset instanceof Asset\\Document && \\Pimcore\\Document::isAvailable() && $asset->getPageCount()) {\n            return $this->generateUrl('pimcore_admin_asset_getdocumentthumbnail', $params);\n        }\n\n        if ($asset instanceof Asset\\Audio) {\n            return '/bundles/pimcoreadmin/img/flat-color-icons/speaker.svg';\n        }\n\n        if ($asset instanceof Asset) {\n            return '/bundles/pimcoreadmin/img/filetype-not-supported.svg';\n        }\n    }\n\n    /**\n     * @Route(\"/update\", name=\"pimcore_admin_asset_update\", methods={\"PUT\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     *\n     * @throws \\Exception\n     */\n    public function updateAction(Request $request)\n    {\n        $success = false;\n        $allowUpdate = true;\n\n        $updateData = array_merge($request->request->all(), $request->query->all());\n\n        $asset = Asset::getById((int) $request->get('id'));\n        if ($asset->isAllowed('settings')) {\n            $asset->setUserModification($this->getAdminUser()->getId());\n\n            // if the position is changed the path must be changed || also from the children\n            if ($parentId = $request->get('parentId')) {\n                $parentAsset = Asset::getById((int) $parentId);\n\n                //check if parent is changed i.e. asset is moved\n                if ($asset->getParentId() != $parentAsset->getId()) {\n                    if (!$parentAsset->isAllowed('create')) {\n                        throw new \\Exception('Prevented moving asset - no create permission on new parent ');\n                    }\n\n                    $intendedPath = $parentAsset->getRealPath();\n                    $pKey = $parentAsset->getKey();\n                    if (!empty($pKey)) {\n                        $intendedPath .= $parentAsset->getKey() . '/';\n                    }\n\n                    $assetWithSamePath = Asset::getByPath($intendedPath . $asset->getKey());\n\n                    if ($assetWithSamePath != null) {\n                        $allowUpdate = false;\n                    }\n\n                    if ($asset->isLocked()) {\n                        $allowUpdate = false;\n                    }\n                }\n            }\n\n            if ($allowUpdate) {\n                if ($request->get('filename') != $asset->getFilename() && !$asset->isAllowed('rename')) {\n                    unset($updateData['filename']);\n                    Logger::debug('prevented renaming asset because of missing permissions ');\n                }\n\n                $asset->setValues($updateData);\n\n                try {\n                    $asset->save();\n                    $success = true;\n                } catch (\\Exception $e) {\n                    return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n                }\n            } else {\n                $msg = 'prevented moving asset, asset with same path+key already exists at target location or the asset is locked. ID: ' . $asset->getId();\n                Logger::debug($msg);\n\n                return $this->adminJson(['success' => $success, 'message' => $msg]);\n            }\n        } elseif ($asset->isAllowed('rename') && $request->get('filename')) {\n            //just rename\n            try {\n                $asset->setFilename($request->get('filename'));\n                $asset->save();\n                $success = true;\n            } catch (\\Exception $e) {\n                return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n            }\n        } else {\n            Logger::debug('prevented update asset because of missing permissions ');\n        }\n\n        return $this->adminJson(['success' => $success]);\n    }\n\n    /**\n     * @Route(\"/webdav{path}\", name=\"pimcore_admin_webdav\", requirements={\"path\"=\".*\"})\n     */\n    public function webdavAction()\n    {\n        $homeDir = Asset::getById(1);\n\n        try {\n            $publicDir = new Asset\\WebDAV\\Folder($homeDir);\n            $objectTree = new Asset\\WebDAV\\Tree($publicDir);\n            $server = new \\Sabre\\DAV\\Server($objectTree);\n            $server->setBaseUri($this->generateUrl('pimcore_admin_webdav', ['path' => '/']));\n\n            // lock plugin\n            /** @var \\Doctrine\\DBAL\\Driver\\PDOConnection $pdo */\n            $pdo = \\Pimcore\\Db::get()->getWrappedConnection();\n            $lockBackend = new \\Sabre\\DAV\\Locks\\Backend\\PDO($pdo);\n            $lockBackend->tableName = 'webdav_locks';\n\n            $lockPlugin = new \\Sabre\\DAV\\Locks\\Plugin($lockBackend);\n            $server->addPlugin($lockPlugin);\n\n            // browser plugin\n            $server->addPlugin(new \\Sabre\\DAV\\Browser\\Plugin());\n\n            $server->start();\n        } catch (\\Exception $e) {\n            Logger::error((string) $e);\n        }\n\n        exit;\n    }\n\n    /**\n     * @Route(\"/save\", name=\"pimcore_admin_asset_save\", methods={\"PUT\",\"POST\"})\n     *\n     * @param Request $request\n     * @param EventDispatcherInterface $eventDispatcher\n     *\n     * @return JsonResponse\n     *\n     * @throws \\Exception\n     */\n    public function saveAction(Request $request, EventDispatcherInterface $eventDispatcher)\n    {\n        $asset = Asset::getById((int) $request->get('id'));\n\n        if (!$asset) {\n            throw $this->createNotFoundException('Asset not found');\n        }\n\n        if ($asset->isAllowed('publish')) {\n            // metadata\n            if ($request->get('metadata')) {\n                $metadata = $this->decodeJson($request->get('metadata'));\n\n                $metadataEvent = new GenericEvent($this, [\n                    'id' => $asset->getId(),\n                    'metadata' => $metadata,\n                ]);\n                $eventDispatcher->dispatch($metadataEvent, AdminEvents::ASSET_METADATA_PRE_SET);\n\n                $metadata = $metadataEvent->getArgument('metadata');\n                $metadataValues = $metadata['values'];\n\n                $metadataValues = Asset\\Service::minimizeMetadata($metadataValues, 'editor');\n                $asset->setMetadataRaw($metadataValues);\n            }\n\n            // properties\n            if ($request->get('properties')) {\n                $properties = [];\n                $propertiesData = $this->decodeJson($request->get('properties'));\n\n                if (is_array($propertiesData)) {\n                    foreach ($propertiesData as $propertyName => $propertyData) {\n                        $value = $propertyData['data'];\n\n                        try {\n                            $property = new Model\\Property();\n                            $property->setType($propertyData['type']);\n                            $property->setName($propertyName);\n                            $property->setCtype('asset');\n                            $property->setDataFromEditmode($value);\n                            $property->setInheritable($propertyData['inheritable']);\n\n                            $properties[$propertyName] = $property;\n                        } catch (\\Exception $e) {\n                            Logger::err(\"Can't add \" . $propertyName . ' to asset ' . $asset->getRealFullPath());\n                        }\n                    }\n\n                    $asset->setProperties($properties);\n                }\n            }\n\n            $this->applySchedulerDataToElement($request, $asset);\n\n            if ($request->get('data')) {\n                $asset->setData($request->get('data'));\n            }\n\n            // image specific data\n            if ($asset instanceof Asset\\Image) {\n                if ($request->get('image')) {\n                    $imageData = $this->decodeJson($request->get('image'));\n                    if (isset($imageData['focalPoint'])) {\n                        $asset->setCustomSetting('focalPointX', $imageData['focalPoint']['x']);\n                        $asset->setCustomSetting('focalPointY', $imageData['focalPoint']['y']);\n                        $asset->removeCustomSetting('disableFocalPointDetection');\n                    }\n                } else {\n                    // wipe all data\n                    $asset->removeCustomSetting('focalPointX');\n                    $asset->removeCustomSetting('focalPointY');\n                    $asset->setCustomSetting('disableFocalPointDetection', true);\n                }\n            }\n\n            $asset->setUserModification($this->getAdminUser()->getId());\n            if ($request->get('task') === 'session') {\n                // save to session only\n                Asset\\Service::saveElementToSession($asset);\n            } else {\n                $asset->save();\n            }\n\n            $treeData = $this->getTreeNodeConfig($asset);\n\n            return $this->adminJson([\n                'success' => true,\n                'data' => [\n                    'versionDate' => $asset->getModificationDate(),\n                    'versionCount' => $asset->getVersionCount(),\n                ],\n                'treeData' => $treeData,\n            ]);\n        } else {\n            throw $this->createAccessDeniedHttpException();\n        }\n    }\n\n    /**\n     * @Route(\"/publish-version\", name=\"pimcore_admin_asset_publishversion\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function publishVersionAction(Request $request)\n    {\n        $id = (int)$request->get('id');\n        $version = Model\\Version::getById($id);\n        $asset = $version?->loadData();\n\n        if (!$asset) {\n            throw $this->createNotFoundException('Version with id [' . $id . \"] doesn't exist\");\n        }\n\n        $currentAsset = Asset::getById($asset->getId());\n        if ($currentAsset->isAllowed('publish')) {\n            try {\n                $asset->setUserModification($this->getAdminUser()->getId());\n                $asset->save();\n\n                $treeData = $this->getTreeNodeConfig($asset);\n\n                return $this->adminJson(['success' => true, 'treeData' => $treeData]);\n            } catch (\\Exception $e) {\n                return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n            }\n        }\n\n        throw $this->createAccessDeniedHttpException();\n    }\n\n    /**\n     * @Route(\"/show-version\", name=\"pimcore_admin_asset_showversion\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function showVersionAction(Request $request)\n    {\n        $id = (int)$request->get('id');\n        $version = Model\\Version::getById($id);\n        $asset = $version?->loadData();\n        if (!$asset) {\n            throw $this->createNotFoundException('Version with id [' . $id . \"] doesn't exist\");\n        }\n\n        if (!$asset->isAllowed('versions')) {\n            throw $this->createAccessDeniedHttpException('Permission denied, version id [' . $id . ']');\n        }\n\n        $loader = \\Pimcore::getContainer()->get('pimcore.implementation_loader.asset.metadata.data');\n\n        return $this->render(\n            '@PimcoreAdmin/Admin/Asset/showVersion' . ucfirst($asset->getType()) . '.html.twig',\n            [\n                'asset' => $asset,\n                'loader' => $loader,\n            ]\n        );\n    }\n\n    /**\n     * @Route(\"/download\", name=\"pimcore_admin_asset_download\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return StreamedResponse\n     */\n    public function downloadAction(Request $request)\n    {\n        $asset = Asset::getById((int) $request->get('id'));\n\n        if (!$asset) {\n            throw $this->createNotFoundException('Asset not found');\n        }\n\n        if (!$asset->isAllowed('view')) {\n            throw $this->createAccessDeniedException('not allowed to view asset');\n        }\n\n        $stream = $asset->getStream();\n\n        if (!is_resource($stream)) {\n            throw $this->createNotFoundException('Unable to get resource for asset ' . $asset->getId());\n        }\n\n        return new StreamedResponse(function () use ($stream) {\n            fpassthru($stream);\n        }, 200, [\n            'Content-Type' => $asset->getMimeType(),\n            'Content-Disposition' => sprintf('attachment; filename=\"%s\"', $asset->getFilename()),\n            'Content-Length' => $asset->getFileSize(),\n        ]);\n    }\n\n    /**\n     * @Route(\"/download-image-thumbnail\", name=\"pimcore_admin_asset_downloadimagethumbnail\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return BinaryFileResponse\n     */\n    public function downloadImageThumbnailAction(Request $request)\n    {\n        $image = Asset\\Image::getById((int) $request->get('id'));\n\n        if (!$image) {\n            throw $this->createNotFoundException('Asset not found');\n        }\n\n        if (!$image->isAllowed('view')) {\n            throw $this->createAccessDeniedException('not allowed to view thumbnail');\n        }\n\n        $config = null;\n        $thumbnail = null;\n        $thumbnailName = $request->get('thumbnail');\n        $thumbnailFile = null;\n        $deleteThumbnail = true;\n\n        if ($request->get('config')) {\n            $config = $this->decodeJson($request->get('config'));\n        } elseif ($request->get('type')) {\n            $predefined = [\n                'web' => [\n                    'resize_mode' => 'scaleByWidth',\n                    'width' => 3500,\n                    'dpi' => 72,\n                    'format' => 'JPEG',\n                    'quality' => 85,\n                ],\n                'print' => [\n                    'resize_mode' => 'scaleByWidth',\n                    'width' => 6000,\n                    'dpi' => 300,\n                    'format' => 'JPEG',\n                    'quality' => 95,\n                ],\n                'office' => [\n                    'resize_mode' => 'scaleByWidth',\n                    'width' => 1190,\n                    'dpi' => 144,\n                    'format' => 'JPEG',\n                    'quality' => 90,\n                ],\n            ];\n\n            $config = $predefined[$request->get('type')];\n        } elseif ($thumbnailName) {\n            $thumbnail = $image->getThumbnail($thumbnailName);\n            $deleteThumbnail = false;\n        }\n\n        if ($config) {\n            $thumbnailConfig = new Asset\\Image\\Thumbnail\\Config();\n            $thumbnailConfig->setName('pimcore-download-' . $image->getId() . '-' . md5($request->get('config')));\n\n            if ($config['resize_mode'] == 'scaleByWidth') {\n                $thumbnailConfig->addItem('scaleByWidth', [\n                    'width' => $config['width'],\n                ]);\n            } elseif ($config['resize_mode'] == 'scaleByHeight') {\n                $thumbnailConfig->addItem('scaleByHeight', [\n                    'height' => $config['height'],\n                ]);\n            } else {\n                $thumbnailConfig->addItem('resize', [\n                    'width' => $config['width'],\n                    'height' => $config['height'],\n                ]);\n            }\n\n            $thumbnailConfig->setQuality($config['quality']);\n            $thumbnailConfig->setFormat($config['format']);\n            $thumbnailConfig->setRasterizeSVG(true);\n\n            if ($thumbnailConfig->getFormat() == 'JPEG') {\n                $thumbnailConfig->setPreserveMetaData(true);\n\n                if (empty($config['quality'])) {\n                    $thumbnailConfig->setPreserveColor(true);\n                }\n            }\n\n            $thumbnail = $image->getThumbnail($thumbnailConfig);\n            $thumbnailFile = $thumbnail->getLocalFile();\n\n            $exiftool = \\Pimcore\\Tool\\Console::getExecutable('exiftool');\n            if ($thumbnailConfig->getFormat() == 'JPEG' && $exiftool && isset($config['dpi']) && $config['dpi']) {\n                $process = new Process([$exiftool, '-overwrite_original', '-xresolution=' . (int)$config['dpi'], '-yresolution=' . (int)$config['dpi'], '-resolutionunit=inches', $thumbnailFile]);\n                $process->run();\n            }\n        }\n\n        if ($thumbnail) {\n            $thumbnailFile = $thumbnailFile ?: $thumbnail->getLocalFile();\n\n            $downloadFilename = preg_replace(\n                '/\\.' . preg_quote(File::getFileExtension($image->getFilename())) . '$/i',\n                '.' . $thumbnail->getFileExtension(),\n                $image->getFilename()\n            );\n            $downloadFilename = strtolower($downloadFilename);\n\n            clearstatcache();\n\n            $response = new BinaryFileResponse($thumbnailFile);\n            $response->headers->set('Content-Type', $thumbnail->getMimeType());\n            $response->setContentDisposition(ResponseHeaderBag::DISPOSITION_ATTACHMENT, $downloadFilename);\n            $this->addThumbnailCacheHeaders($response);\n            $response->deleteFileAfterSend($deleteThumbnail);\n\n            return $response;\n        }\n\n        throw $this->createNotFoundException('Thumbnail not found');\n    }\n\n    /**\n     * @Route(\"/get-asset\", name=\"pimcore_admin_asset_getasset\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return StreamedResponse\n     */\n    public function getAssetAction(Request $request)\n    {\n        $image = Asset::getById((int)$request->get('id'));\n\n        if (!$image) {\n            throw $this->createNotFoundException('Asset not found');\n        }\n\n        if (!$image->isAllowed('view')) {\n            throw $this->createAccessDeniedException('not allowed to view asset');\n        }\n\n        $stream = $image->getStream();\n\n        if (!is_resource($stream)) {\n            throw $this->createNotFoundException('Unable to get resource for asset ' . $image->getId());\n        }\n\n        $response = new StreamedResponse(function () use ($stream) {\n            fpassthru($stream);\n        }, 200, [\n            'Content-Type' => $image->getMimeType(),\n            'Access-Control-Allow-Origin' => '*',\n        ]);\n        $this->addThumbnailCacheHeaders($response);\n\n        return $response;\n    }\n\n    /**\n     * @Route(\"/get-image-thumbnail\", name=\"pimcore_admin_asset_getimagethumbnail\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return StreamedResponse|JsonResponse|BinaryFileResponse\n     */\n    public function getImageThumbnailAction(Request $request)\n    {\n        $fileinfo = $request->get('fileinfo');\n        $image = Asset\\Image::getById((int)$request->get('id'));\n\n        if (!$image) {\n            throw $this->createNotFoundException('Asset not found');\n        }\n\n        if (!$image->isAllowed('view')) {\n            throw $this->createAccessDeniedException('not allowed to view thumbnail');\n        }\n\n        $thumbnailConfig = null;\n\n        if ($request->get('thumbnail')) {\n            $thumbnailConfig = $image->getThumbnailConfig($request->get('thumbnail'));\n        }\n        if (!$thumbnailConfig) {\n            if ($request->get('config')) {\n                $thumbnailConfig = $image->getThumbnailConfig($this->decodeJson($request->get('config')));\n            } else {\n                $thumbnailConfig = $image->getThumbnailConfig(array_merge($request->request->all(), $request->query->all()));\n            }\n        } else {\n            // no high-res images in admin mode (editmode)\n            // this is mostly because of the document's image editable, which doesn't know anything about the thumbnail\n            // configuration, so the dimensions would be incorrect (double the size)\n            $thumbnailConfig->setHighResolution(1);\n        }\n\n        $format = strtolower($thumbnailConfig->getFormat());\n        if ($format == 'source' || $format == 'print') {\n            $thumbnailConfig->setFormat('PNG');\n            $thumbnailConfig->setRasterizeSVG(true);\n        }\n\n        if ($request->get('treepreview')) {\n            $thumbnailConfig = Asset\\Image\\Thumbnail\\Config::getPreviewConfig();\n            if ($request->get('origin') === 'treeNode' && !$image->getThumbnail($thumbnailConfig)->exists()) {\n                \\Pimcore::getContainer()->get('messenger.bus.pimcore-core')->dispatch(\n                    new AssetPreviewImageMessage($image->getId())\n                );\n\n                throw $this->createNotFoundException(sprintf('Tree preview thumbnail not available for asset %s', $image->getId()));\n            }\n        }\n\n        $cropPercent = $request->get('cropPercent');\n        if ($cropPercent && filter_var($cropPercent, FILTER_VALIDATE_BOOLEAN)) {\n            $thumbnailConfig->addItemAt(0, 'cropPercent', [\n                'width' => $request->get('cropWidth'),\n                'height' => $request->get('cropHeight'),\n                'y' => $request->get('cropTop'),\n                'x' => $request->get('cropLeft'),\n            ]);\n\n            $hash = md5(Tool\\Serialize::serialize(array_merge($request->request->all(), $request->query->all())));\n            $thumbnailConfig->setName($thumbnailConfig->getName() . '_auto_' . $hash);\n        }\n\n        $thumbnail = $image->getThumbnail($thumbnailConfig);\n\n        if ($fileinfo) {\n            return $this->adminJson([\n                'width' => $thumbnail->getWidth(),\n                'height' => $thumbnail->getHeight(), ]);\n        }\n\n        $stream = $thumbnail->getStream();\n\n        if (!$stream) {\n            return new BinaryFileResponse(PIMCORE_PATH . '/bundles/AdminBundle/Resources/public/img/filetype-not-supported.svg');\n        }\n\n        $response = new StreamedResponse(function () use ($stream) {\n            fpassthru($stream);\n        }, 200, [\n            'Content-Type' => $thumbnail->getMimeType(),\n            'Access-Control-Allow-Origin', '*',\n        ]);\n\n        $this->addThumbnailCacheHeaders($response);\n\n        return $response;\n    }\n\n    /**\n     * @Route(\"/get-folder-thumbnail\", name=\"pimcore_admin_asset_getfolderthumbnail\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return StreamedResponse\n     */\n    public function getFolderThumbnailAction(Request $request)\n    {\n        $folder = null;\n\n        if ($request->get('id')) {\n            $folder = Asset\\Folder::getById((int)$request->get('id'));\n            if ($folder instanceof  Asset\\Folder) {\n                if (!$folder->isAllowed('view')) {\n                    throw $this->createAccessDeniedException('not allowed to view thumbnail');\n                }\n\n                $stream = $folder->getPreviewImage();\n                if (!$stream) {\n                    throw $this->createNotFoundException(sprintf('Tree preview thumbnail not available for asset %s', $folder->getId()));\n                } else {\n                    $response = new StreamedResponse(function () use ($stream) {\n                        fpassthru($stream);\n                    }, 200, [\n                        'Content-Type' => 'image/jpg',\n                    ]);\n                }\n\n                $this->addThumbnailCacheHeaders($response);\n\n                return $response;\n            }\n        }\n\n        throw $this->createNotFoundException('could not load asset folder');\n    }\n\n    /**\n     * @Route(\"/get-video-thumbnail\", name=\"pimcore_admin_asset_getvideothumbnail\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return StreamedResponse\n     */\n    public function getVideoThumbnailAction(Request $request)\n    {\n        $video = null;\n\n        if ($request->get('id')) {\n            $video = Asset\\Video::getById((int)$request->get('id'));\n        } elseif ($request->get('path')) {\n            $video = Asset\\Video::getByPath($request->get('path'));\n        }\n\n        if (!$video) {\n            throw $this->createNotFoundException('could not load video asset');\n        }\n\n        if (!$video->isAllowed('view')) {\n            throw $this->createAccessDeniedException('not allowed to view thumbnail');\n        }\n\n        $thumbnail = array_merge($request->request->all(), $request->query->all());\n\n        if ($request->get('treepreview')) {\n            $thumbnail = Asset\\Image\\Thumbnail\\Config::getPreviewConfig();\n        }\n\n        $time = null;\n        if (is_numeric($request->get('time'))) {\n            $time = (int)$request->get('time');\n        }\n\n        if ($request->get('settime')) {\n            $video->removeCustomSetting('image_thumbnail_asset');\n            $video->setCustomSetting('image_thumbnail_time', $time);\n            $video->save();\n        }\n\n        $image = null;\n        if ($request->get('image')) {\n            $image = Asset\\Image::getById((int)$request->get('image'));\n        }\n\n        if ($request->get('setimage') && $image) {\n            $video->removeCustomSetting('image_thumbnail_time');\n            $video->setCustomSetting('image_thumbnail_asset', $image->getId());\n            $video->save();\n        }\n\n        $thumb = $video->getImageThumbnail($thumbnail, $time, $image);\n\n        if ($request->get('origin') === 'treeNode' && !$thumb->exists()) {\n            \\Pimcore::getContainer()->get('messenger.bus.pimcore-core')->dispatch(\n                new AssetPreviewImageMessage($video->getId())\n            );\n\n            throw $this->createNotFoundException(sprintf('Tree preview thumbnail not available for asset %s', $video->getId()));\n        }\n\n        $stream = $thumb->getStream();\n        if (!$stream) {\n            throw $this->createNotFoundException('Unable to get video thumbnail for video ' . $video->getId());\n        }\n\n        $response = new StreamedResponse(function () use ($stream) {\n            fpassthru($stream);\n        }, 200, [\n            'Content-Type' => 'image/' . $thumb->getFileExtension(),\n        ]);\n\n        $this->addThumbnailCacheHeaders($response);\n\n        return $response;\n    }\n\n    /**\n     * @Route(\"/get-document-thumbnail\", name=\"pimcore_admin_asset_getdocumentthumbnail\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return StreamedResponse|BinaryFileResponse\n     */\n    public function getDocumentThumbnailAction(Request $request)\n    {\n        $document = Asset\\Document::getById((int)$request->get('id'));\n\n        if (!$document) {\n            throw $this->createNotFoundException('could not load document asset');\n        }\n\n        if (!$document->isAllowed('view')) {\n            throw $this->createAccessDeniedException('not allowed to view thumbnail');\n        }\n\n        $thumbnail = Asset\\Image\\Thumbnail\\Config::getByAutoDetect(array_merge($request->request->all(), $request->query->all()));\n\n        $format = strtolower($thumbnail->getFormat());\n        if ($format == 'source') {\n            $thumbnail->setFormat('jpeg'); // default format for documents is JPEG not PNG (=too big)\n        }\n\n        if ($request->get('treepreview')) {\n            $thumbnail = Asset\\Image\\Thumbnail\\Config::getPreviewConfig();\n        }\n\n        $page = 1;\n        if (is_numeric($request->get('page'))) {\n            $page = (int)$request->get('page');\n        }\n\n        $thumb = $document->getImageThumbnail($thumbnail, $page);\n\n        if ($request->get('origin') === 'treeNode' && !$thumb->exists()) {\n            \\Pimcore::getContainer()->get('messenger.bus.pimcore-core')->dispatch(\n                new AssetPreviewImageMessage($document->getId())\n            );\n\n            throw $this->createNotFoundException(sprintf('Tree preview thumbnail not available for asset %s', $document->getId()));\n        }\n\n        $stream = $thumb->getStream();\n        if ($stream) {\n            $response = new StreamedResponse(function () use ($stream) {\n                fpassthru($stream);\n            }, 200, [\n                'Content-Type' => 'image/' . $thumb->getFileExtension(),\n            ]);\n        } else {\n            $response = new BinaryFileResponse(PIMCORE_PATH . '/bundles/AdminBundle/Resources/public/img/filetype-not-supported.svg');\n        }\n\n        $this->addThumbnailCacheHeaders($response);\n\n        return $response;\n    }\n\n    /**\n     * @param Response $response\n     */\n    protected function addThumbnailCacheHeaders(Response $response)\n    {\n        $lifetime = 300;\n        $date = new \\DateTime('now');\n        $date->add(new \\DateInterval('PT' . $lifetime . 'S'));\n\n        $response->setMaxAge($lifetime);\n        $response->setPublic();\n        $response->setExpires($date);\n        $response->headers->set('Pragma', '');\n    }\n\n    /**\n     * @Route(\"/get-preview-document\", name=\"pimcore_admin_asset_getpreviewdocument\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return StreamedResponse\n     */\n    public function getPreviewDocumentAction(Request $request)\n    {\n        $asset = Asset\\Document::getById((int) $request->get('id'));\n\n        if (!$asset) {\n            throw $this->createNotFoundException('could not load document asset');\n        }\n\n        if ($asset->isAllowed('view')) {\n            $stream = $this->getDocumentPreviewPdf($asset);\n            if ($stream) {\n                return new StreamedResponse(function () use ($stream) {\n                    fpassthru($stream);\n                }, 200, [\n                    'Content-Type' => 'application/pdf',\n                ]);\n            } else {\n                throw $this->createNotFoundException('Unable to get preview for asset ' . $asset->getId());\n            }\n        } else {\n            throw $this->createAccessDeniedException('Access to asset ' . $asset->getId() . ' denied');\n        }\n    }\n\n    /**\n     * @param Asset\\Document $asset\n     *\n     * @return resource|null\n     */\n    protected function getDocumentPreviewPdf(Asset\\Document $asset)\n    {\n        $stream = null;\n\n        if ($asset->getMimeType() == 'application/pdf') {\n            $stream = $asset->getStream();\n        }\n\n        if (!$stream && $asset->getPageCount() && \\Pimcore\\Document::isAvailable() && \\Pimcore\\Document::isFileTypeSupported($asset->getFilename())) {\n            try {\n                $document = \\Pimcore\\Document::getInstance();\n                $stream = $document->getPdf($asset);\n            } catch (\\Exception $e) {\n                // nothing to do\n            }\n        }\n\n        return $stream;\n    }\n\n    /**\n     * @Route(\"/get-preview-video\", name=\"pimcore_admin_asset_getpreviewvideo\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function getPreviewVideoAction(Request $request)\n    {\n        $asset = Asset\\Video::getById((int) $request->get('id'));\n\n        if (!$asset) {\n            throw $this->createNotFoundException('could not load video asset');\n        }\n\n        if (!$asset->isAllowed('view')) {\n            throw $this->createAccessDeniedException('not allowed to preview');\n        }\n\n        $previewData = ['asset' => $asset];\n        $config = Asset\\Video\\Thumbnail\\Config::getPreviewConfig();\n        $thumbnail = $asset->getThumbnail($config, ['mp4']);\n\n        if ($thumbnail) {\n            $previewData['asset'] = $asset;\n            $previewData['thumbnail'] = $thumbnail;\n\n            if ($thumbnail['status'] == 'finished') {\n                return $this->render(\n                    '@PimcoreAdmin/Admin/Asset/getPreviewVideoDisplay.html.twig',\n                    $previewData\n                );\n            } else {\n                return $this->render(\n                    '@PimcoreAdmin/Admin/Asset/getPreviewVideoError.html.twig',\n                    $previewData\n                );\n            }\n        } else {\n            return $this->render(\n                '@PimcoreAdmin/Admin/Asset/getPreviewVideoError.html.twig',\n                $previewData\n            );\n        }\n    }\n\n    /**\n     * @Route(\"/serve-video-preview\", name=\"pimcore_admin_asset_servevideopreview\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return StreamedResponse\n     */\n    public function serveVideoPreviewAction(Request $request)\n    {\n        $asset = Asset\\Video::getById((int) $request->get('id'));\n\n        if (!$asset) {\n            throw $this->createNotFoundException('could not load video asset');\n        }\n\n        if (!$asset->isAllowed('view')) {\n            throw $this->createAccessDeniedException('not allowed to preview');\n        }\n\n        $config = Asset\\Video\\Thumbnail\\Config::getPreviewConfig();\n        $thumbnail = $asset->getThumbnail($config, ['mp4']);\n        $storagePath = $asset->getRealPath() . '/' . preg_replace('@^' . preg_quote($asset->getPath(), '@') . '@', '', urldecode($thumbnail['formats']['mp4']));\n\n        $storage = Tool\\Storage::get('thumbnail');\n        if ($storage->fileExists($storagePath)) {\n            $fs = $storage->fileSize($storagePath);\n            $stream = $storage->readStream($storagePath);\n\n            return new StreamedResponse(function () use ($stream) {\n                fpassthru($stream);\n            }, 200, [\n                'Content-Type' => 'video/mp4',\n                'Content-Length' => $fs,\n                'Accept-Ranges' => 'bytes',\n            ]);\n        } else {\n            throw $this->createNotFoundException('Video thumbnail not found');\n        }\n    }\n\n    /**\n     * @Route(\"/image-editor\", name=\"pimcore_admin_asset_imageeditor\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function imageEditorAction(Request $request)\n    {\n        $asset = Asset::getById((int) $request->get('id'));\n\n        if (!$asset->isAllowed('view')) {\n            throw $this->createAccessDeniedException('Not allowed to preview');\n        }\n\n        return $this->render(\n            '@PimcoreAdmin/Admin/Asset/imageEditor.html.twig',\n            ['asset' => $asset]\n        );\n    }\n\n    /**\n     * @Route(\"/image-editor-save\", name=\"pimcore_admin_asset_imageeditorsave\", methods={\"PUT\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function imageEditorSaveAction(Request $request)\n    {\n        $asset = Asset::getById((int) $request->get('id'));\n\n        if (!$asset) {\n            throw $this->createNotFoundException('Asset not found');\n        }\n\n        if (!$asset->isAllowed('publish')) {\n            throw $this->createAccessDeniedException('not allowed to publish');\n        }\n\n        $data = $request->get('dataUri');\n        $data = substr($data, strpos($data, ','));\n        $data = base64_decode($data);\n        $asset->setData($data);\n        $asset->setUserModification($this->getAdminUser()->getId());\n        $asset->save();\n\n        return $this->adminJson(['success' => true]);\n    }\n\n    /**\n     * @Route(\"/get-folder-content-preview\", name=\"pimcore_admin_asset_getfoldercontentpreview\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getFolderContentPreviewAction(Request $request, EventDispatcherInterface $eventDispatcher)\n    {\n        $allParams = array_merge($request->request->all(), $request->query->all());\n\n        $filterPrepareEvent = new GenericEvent($this, [\n            'requestParams' => $allParams,\n        ]);\n        $eventDispatcher->dispatch($filterPrepareEvent, AdminEvents::ASSET_LIST_BEFORE_FILTER_PREPARE);\n\n        $allParams = $filterPrepareEvent->getArgument('requestParams');\n\n        $folder = Asset::getById($allParams['id']);\n\n        $start = 0;\n        $limit = 10;\n\n        if ($allParams['limit']) {\n            $limit = $allParams['limit'];\n        }\n        if ($allParams['start']) {\n            $start = $allParams['start'];\n        }\n\n        $conditionFilters = [];\n        $list = new Asset\\Listing();\n        $conditionFilters[] = 'path LIKE ' . ($folder->getRealFullPath() == '/' ? \"'/%'\" : $list->quote(Helper::escapeLike($folder->getRealFullPath()) . '/%')) . \" AND type != 'folder'\";\n\n        if (!$this->getAdminUser()->isAdmin()) {\n            $userIds = $this->getAdminUser()->getRoles();\n            $userIds[] = $this->getAdminUser()->getId();\n            $conditionFilters[] = ' (\n                                                    (select list from users_workspaces_asset where userId in (' . implode(',', $userIds) . ') and LOCATE(CONCAT(path, filename),cpath)=1  ORDER BY LENGTH(cpath) DESC LIMIT 1)=1\n                                                    OR\n                                                    (select list from users_workspaces_asset where userId in (' . implode(',', $userIds) . ') and LOCATE(cpath,CONCAT(path, filename))=1  ORDER BY LENGTH(cpath) DESC LIMIT 1)=1\n                                                 )';\n        }\n\n        $condition = implode(' AND ', $conditionFilters);\n\n        $list->setCondition($condition);\n        $list->setLimit($limit);\n        $list->setOffset($start);\n        $list->setOrderKey('CAST(filename AS CHAR CHARACTER SET utf8) COLLATE utf8_general_ci ASC', false);\n\n        $beforeListLoadEvent = new GenericEvent($this, [\n            'list' => $list,\n            'context' => $allParams,\n        ]);\n        $eventDispatcher->dispatch($beforeListLoadEvent, AdminEvents::ASSET_LIST_BEFORE_LIST_LOAD);\n        /** @var Asset\\Listing $list */\n        $list = $beforeListLoadEvent->getArgument('list');\n\n        $list->load();\n\n        $assets = [];\n\n        foreach ($list as $asset) {\n            $filenameDisplay = $asset->getFilename();\n            if (strlen($filenameDisplay) > 32) {\n                $filenameDisplay = substr($filenameDisplay, 0, 25) . '...' . \\Pimcore\\File::getFileExtension($filenameDisplay);\n            }\n\n            // Like for treeGetChildsByIdAction, so we respect isAllowed method which can be extended (object DI) for custom permissions, so relying only users_workspaces_asset is insufficient and could lead security breach\n            if ($asset->isAllowed('list')) {\n                $assets[] = [\n                    'id' => $asset->getId(),\n                    'type' => $asset->getType(),\n                    'filename' => $asset->getFilename(),\n                    'filenameDisplay' => htmlspecialchars($filenameDisplay),\n                    'url' => $this->getThumbnailUrl($asset),\n                    'idPath' => $data['idPath'] = Element\\Service::getIdPath($asset),\n                ];\n            }\n        }\n\n        // We need to temporary use data key to be compatible with the ASSET_LIST_AFTER_LIST_LOAD global event\n        $result = ['data' => $assets, 'success' => true, 'total' => $list->getTotalCount()];\n\n        $afterListLoadEvent = new GenericEvent($this, [\n            'list' => $result,\n            'context' => $allParams,\n        ]);\n        $eventDispatcher->dispatch($afterListLoadEvent, AdminEvents::ASSET_LIST_AFTER_LIST_LOAD);\n        $result = $afterListLoadEvent->getArgument('list');\n\n        // Here we revert to assets key\n        return $this->adminJson(['assets' => $result['data'], 'success' => $result['success'], 'total' => $result['total']]);\n    }\n\n    /**\n     * @Route(\"/copy-info\", name=\"pimcore_admin_asset_copyinfo\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function copyInfoAction(Request $request)\n    {\n        $transactionId = time();\n        $pasteJobs = [];\n\n        Tool\\Session::useSession(function (AttributeBagInterface $session) use ($transactionId) {\n            $session->set((string) $transactionId, []);\n        }, 'pimcore_copy');\n\n        if ($request->get('type') == 'recursive') {\n            $asset = Asset::getById((int) $request->get('sourceId'));\n\n            if (!$asset) {\n                throw $this->createNotFoundException('Source not found');\n            }\n\n            // first of all the new parent\n            $pasteJobs[] = [[\n                'url' => $this->generateUrl('pimcore_admin_asset_copy'),\n                'method' => 'POST',\n                'params' => [\n                    'sourceId' => $request->get('sourceId'),\n                    'targetId' => $request->get('targetId'),\n                    'type' => 'child',\n                    'transactionId' => $transactionId,\n                    'saveParentId' => true,\n                ],\n            ]];\n\n            if ($asset->hasChildren()) {\n                // get amount of children\n                $list = new Asset\\Listing();\n                $list->setCondition('path LIKE ?', [$list->escapeLike($asset->getRealFullPath()) . '/%']);\n                $list->setOrderKey('LENGTH(path)', false);\n                $list->setOrder('ASC');\n                $childIds = $list->loadIdList();\n\n                if (count($childIds) > 0) {\n                    foreach ($childIds as $id) {\n                        $pasteJobs[] = [[\n                            'url' => $this->generateUrl('pimcore_admin_asset_copy'),\n                            'method' => 'POST',\n                            'params' => [\n                                'sourceId' => $id,\n                                'targetParentId' => $request->get('targetId'),\n                                'sourceParentId' => $request->get('sourceId'),\n                                'type' => 'child',\n                                'transactionId' => $transactionId,\n                            ],\n                        ]];\n                    }\n                }\n            }\n        } elseif ($request->get('type') == 'child' || $request->get('type') == 'replace') {\n            // the object itself is the last one\n            $pasteJobs[] = [[\n                'url' => $this->generateUrl('pimcore_admin_asset_copy'),\n                'method' => 'POST',\n                'params' => [\n                    'sourceId' => $request->get('sourceId'),\n                    'targetId' => $request->get('targetId'),\n                    'type' => $request->get('type'),\n                    'transactionId' => $transactionId,\n                ],\n            ]];\n        }\n\n        return $this->adminJson([\n            'pastejobs' => $pasteJobs,\n        ]);\n    }\n\n    /**\n     * @Route(\"/copy\", name=\"pimcore_admin_asset_copy\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function copyAction(Request $request)\n    {\n        $success = false;\n        $sourceId = (int)$request->get('sourceId');\n        $source = Asset::getById($sourceId);\n\n        $session = Tool\\Session::get('pimcore_copy');\n        $sessionBag = $session->get($request->get('transactionId'));\n\n        $targetId = (int)$request->get('targetId');\n        if ($request->get('targetParentId')) {\n            $sourceParent = Asset::getById((int) $request->get('sourceParentId'));\n\n            // this is because the key can get the prefix \"_copy\" if the target does already exists\n            if ($sessionBag['parentId']) {\n                $targetParent = Asset::getById($sessionBag['parentId']);\n            } else {\n                $targetParent = Asset::getById((int) $request->get('targetParentId'));\n            }\n\n            $targetPath = preg_replace('@^' . $sourceParent->getRealFullPath() . '@', $targetParent . '/', $source->getRealPath());\n            $target = Asset::getByPath($targetPath);\n        } else {\n            $target = Asset::getById($targetId);\n        }\n\n        if (!$target) {\n            throw $this->createNotFoundException('Target not found');\n        }\n\n        if ($target->isAllowed('create')) {\n            $source = Asset::getById($sourceId);\n            if ($source != null) {\n                if ($request->get('type') == 'child') {\n                    $newAsset = $this->_assetService->copyAsChild($target, $source);\n\n                    // this is because the key can get the prefix \"_copy\" if the target does already exists\n                    if ($request->get('saveParentId')) {\n                        $sessionBag['parentId'] = $newAsset->getId();\n                    }\n                } elseif ($request->get('type') == 'replace') {\n                    $this->_assetService->copyContents($target, $source);\n                }\n\n                $session->set($request->get('transactionId'), $sessionBag);\n                Tool\\Session::writeClose();\n\n                $success = true;\n            } else {\n                Logger::debug('prevended copy/paste because asset with same path+key already exists in this location');\n            }\n        } else {\n            Logger::error('could not execute copy/paste because of missing permissions on target [ ' . $targetId . ' ]');\n\n            throw $this->createAccessDeniedHttpException();\n        }\n\n        Tool\\Session::writeClose();\n\n        return $this->adminJson(['success' => $success]);\n    }\n\n    /**\n     * @Route(\"/download-as-zip-jobs\", name=\"pimcore_admin_asset_downloadaszipjobs\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function downloadAsZipJobsAction(Request $request)\n    {\n        $jobId = uniqid();\n        $filesPerJob = 5;\n        $jobs = [];\n        $asset = Asset::getById((int) $request->get('id'));\n\n        if (!$asset) {\n            throw $this->createNotFoundException('Asset not found');\n        }\n\n        if ($asset->isAllowed('view')) {\n            $parentPath = $asset->getRealFullPath();\n            if ($asset->getId() == 1) {\n                $parentPath = '';\n            }\n\n            $db = \\Pimcore\\Db::get();\n            $conditionFilters = [];\n            $selectedIds = explode(',', $request->get('selectedIds', ''));\n            $quotedSelectedIds = [];\n            foreach ($selectedIds as $selectedId) {\n                if ($selectedId) {\n                    $quotedSelectedIds[] = $db->quote($selectedId);\n                }\n            }\n            if (!empty($quotedSelectedIds)) {\n                //add a condition if id numbers are specified\n                $conditionFilters[] = 'id IN (' . implode(',', $quotedSelectedIds) . ')';\n            }\n            $conditionFilters[] = 'path LIKE ' . $db->quote(Helper::escapeLike($parentPath) . '/%') . ' AND type != ' . $db->quote('folder');\n            if (!$this->getAdminUser()->isAdmin()) {\n                $userIds = $this->getAdminUser()->getRoles();\n                $userIds[] = $this->getAdminUser()->getId();\n                $conditionFilters[] = ' (\n                    (select list from users_workspaces_asset where userId in (' . implode(',', $userIds) . ') and LOCATE(CONCAT(path, filename),cpath)=1  ORDER BY LENGTH(cpath) DESC LIMIT 1)=1\n                    OR\n                    (select list from users_workspaces_asset where userId in (' . implode(',', $userIds) . ') and LOCATE(cpath,CONCAT(path, filename))=1  ORDER BY LENGTH(cpath) DESC LIMIT 1)=1\n                )';\n            }\n\n            $condition = implode(' AND ', $conditionFilters);\n\n            $assetList = new Asset\\Listing();\n            $assetList->setCondition($condition);\n            $assetList->setOrderKey('LENGTH(path)', false);\n            $assetList->setOrder('ASC');\n\n            for ($i = 0; $i < ceil($assetList->getTotalCount() / $filesPerJob); $i++) {\n                $jobs[] = [[\n                    'url' => $this->generateUrl('pimcore_admin_asset_downloadaszipaddfiles'),\n                    'method' => 'GET',\n                    'params' => [\n                        'id' => $asset->getId(),\n                        'selectedIds' => implode(',', $selectedIds),\n                        'offset' => $i * $filesPerJob,\n                        'limit' => $filesPerJob,\n                        'jobId' => $jobId,\n                    ],\n                ]];\n            }\n        }\n\n        return $this->adminJson([\n            'success' => true,\n            'jobs' => $jobs,\n            'jobId' => $jobId,\n        ]);\n    }\n\n    /**\n     * @Route(\"/download-as-zip-add-files\", name=\"pimcore_admin_asset_downloadaszipaddfiles\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function downloadAsZipAddFilesAction(Request $request)\n    {\n        $zipFile = PIMCORE_SYSTEM_TEMP_DIRECTORY . '/download-zip-' . $request->get('jobId') . '.zip';\n        $asset = Asset::getById((int) $request->get('id'));\n        $success = false;\n\n        if (!$asset) {\n            throw $this->createNotFoundException('Asset not found');\n        }\n\n        if ($asset->isAllowed('view')) {\n            $zip = new \\ZipArchive();\n            if (!is_file($zipFile)) {\n                $zipState = $zip->open($zipFile, \\ZipArchive::CREATE);\n            } else {\n                $zipState = $zip->open($zipFile);\n            }\n\n            if ($zipState === true) {\n                $parentPath = $asset->getRealFullPath();\n                if ($asset->getId() == 1) {\n                    $parentPath = '';\n                }\n\n                $db = \\Pimcore\\Db::get();\n                $conditionFilters = [];\n                $selectedIds = $request->get('selectedIds', []);\n\n                if (!empty($selectedIds)) {\n                    $selectedIds = explode(',', $selectedIds);\n\n                    $quotedSelectedIds = [];\n                    foreach ($selectedIds as $selectedId) {\n                        if ($selectedId) {\n                            $quotedSelectedIds[] = $db->quote($selectedId);\n                        }\n                    }\n\n                    //add a condition if id numbers are specified\n                    $conditionFilters[] = 'id IN (' . implode(',', $quotedSelectedIds) . ')';\n                }\n                $conditionFilters[] = \"type != 'folder' AND path LIKE \" . $db->quote(Helper::escapeLike($parentPath) . '/%');\n                if (!$this->getAdminUser()->isAdmin()) {\n                    $userIds = $this->getAdminUser()->getRoles();\n                    $userIds[] = $this->getAdminUser()->getId();\n                    $conditionFilters[] = ' (\n                        (select list from users_workspaces_asset where userId in (' . implode(',', $userIds) . ') and LOCATE(CONCAT(path, filename),cpath)=1  ORDER BY LENGTH(cpath) DESC LIMIT 1)=1\n                        OR\n                        (select list from users_workspaces_asset where userId in (' . implode(',', $userIds) . ') and LOCATE(cpath,CONCAT(path, filename))=1  ORDER BY LENGTH(cpath) DESC LIMIT 1)=1\n                    )';\n                }\n\n                $condition = implode(' AND ', $conditionFilters);\n\n                $assetList = new Asset\\Listing();\n                $assetList->setCondition($condition);\n                $assetList->setOrderKey('LENGTH(path) ASC, id ASC', false);\n                $assetList->setOffset((int)$request->get('offset'));\n                $assetList->setLimit((int)$request->get('limit'));\n\n                foreach ($assetList as $a) {\n                    if ($a->isAllowed('view')) {\n                        if (!$a instanceof Asset\\Folder) {\n                            // add the file with the relative path to the parent directory\n                            $zip->addFile($a->getLocalFile(), preg_replace('@^' . preg_quote($asset->getRealPath(), '@') . '@i', '', $a->getRealFullPath()));\n                        }\n                    }\n                }\n\n                $zip->close();\n                $success = true;\n            }\n        }\n\n        return $this->adminJson([\n            'success' => $success,\n        ]);\n    }\n\n    /**\n     * @Route(\"/download-as-zip\", name=\"pimcore_admin_asset_downloadaszip\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return BinaryFileResponse\n     * Download all assets contained in the folder with parameter id as ZIP file.\n     * The suggested filename is either [folder name].zip or assets.zip for the root folder.\n     */\n    public function downloadAsZipAction(Request $request)\n    {\n        $asset = Asset::getById((int) $request->get('id'));\n        if (!$asset) {\n            throw $this->createNotFoundException('Asset not found');\n        }\n        $zipFile = PIMCORE_SYSTEM_TEMP_DIRECTORY . '/download-zip-' . $request->get('jobId') . '.zip';\n        $suggestedFilename = $asset->getFilename();\n        if (empty($suggestedFilename)) {\n            $suggestedFilename = 'assets';\n        }\n\n        $response = new BinaryFileResponse($zipFile);\n        $response->headers->set('Content-Type', 'application/zip');\n        $response->setContentDisposition(ResponseHeaderBag::DISPOSITION_ATTACHMENT, $suggestedFilename . '.zip');\n        $response->deleteFileAfterSend(true);\n\n        return $response;\n    }\n\n    /**\n     * @Route(\"/import-zip\", name=\"pimcore_admin_asset_importzip\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function importZipAction(Request $request)\n    {\n        $jobId = uniqid();\n        $filesPerJob = 5;\n        $jobs = [];\n        $asset = Asset::getById((int) $request->get('parentId'));\n\n        if (!is_file($_FILES['Filedata']['tmp_name'])) {\n            return $this->adminJson([\n                'success' => false,\n                'message' => 'Something went wrong, please check upload_max_filesize and post_max_size in your php.ini as well as the write permissions on the file system',\n            ]);\n        }\n\n        if (!$asset) {\n            throw $this->createNotFoundException('Parent asset not found');\n        }\n\n        if (!$asset->isAllowed('create')) {\n            throw $this->createAccessDeniedException('not allowed to create');\n        }\n\n        $zipFile = PIMCORE_SYSTEM_TEMP_DIRECTORY . '/' . $jobId . '.zip';\n\n        copy($_FILES['Filedata']['tmp_name'], $zipFile);\n\n        $zip = new \\ZipArchive;\n        $retCode = $zip->open($zipFile);\n        if ($retCode === true) {\n            $jobAmount = ceil($zip->numFiles / $filesPerJob);\n            for ($i = 0; $i < $jobAmount; $i++) {\n                $jobs[] = [[\n                    'url' => $this->generateUrl('pimcore_admin_asset_importzipfiles'),\n                    'method' => 'POST',\n                    'params' => [\n                        'parentId' => $asset->getId(),\n                        'offset' => $i * $filesPerJob,\n                        'limit' => $filesPerJob,\n                        'jobId' => $jobId,\n                        'last' => (($i + 1) >= $jobAmount) ? 'true' : '',\n                    ],\n                ]];\n            }\n            $zip->close();\n\n            // here we have to use this method and not the JSON action helper ($this->_helper->json()) because this will add\n            // Content-Type: application/json which fires a download window in most browsers, because this is a normal POST\n            // request and not XHR where the content-type doesn't matter\n            $responseJson = $this->encodeJson([\n                'success' => true,\n                'jobs' => $jobs,\n                'jobId' => $jobId,\n            ]);\n\n            return new Response($responseJson);\n        } else {\n            return $this->adminJson([\n                'success' => false,\n                'message' => $this->trans('could_not_open_zip_file'),\n            ]);\n        }\n    }\n\n    /**\n     * @Route(\"/import-zip-files\", name=\"pimcore_admin_asset_importzipfiles\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function importZipFilesAction(Request $request)\n    {\n        $jobId = $request->get('jobId');\n        $limit = (int)$request->get('limit');\n        $offset = (int)$request->get('offset');\n        $importAsset = Asset::getById((int) $request->get('parentId'));\n        $zipFile = PIMCORE_SYSTEM_TEMP_DIRECTORY . '/' . $jobId . '.zip';\n        $tmpDir = PIMCORE_SYSTEM_TEMP_DIRECTORY . '/zip-import';\n\n        if (!is_dir($tmpDir)) {\n            File::mkdir($tmpDir, 0777, true);\n        }\n\n        $zip = new \\ZipArchive;\n        if ($zip->open($zipFile) === true) {\n            for ($i = $offset; $i < ($offset + $limit); $i++) {\n                $path = $zip->getNameIndex($i);\n\n                if (str_starts_with($path, '__MACOSX/') || str_ends_with($path, '/Thumbs.db')) {\n                    continue;\n                }\n\n                if ($path !== false) {\n                    if ($zip->extractTo($tmpDir . '/', $path)) {\n                        $tmpFile = $tmpDir . '/' . preg_replace('@^/@', '', $path);\n\n                        $filename = Element\\Service::getValidKey(basename($path), 'asset');\n\n                        $relativePath = '';\n                        if (dirname($path) != '.') {\n                            $relativePath = dirname($path);\n                        }\n\n                        $parentPath = $importAsset->getRealFullPath() . '/' . preg_replace('@^/@', '', $relativePath);\n                        $parent = Asset\\Service::createFolderByPath($parentPath);\n\n                        // check for duplicate filename\n                        $filename = $this->getSafeFilename($parent->getRealFullPath(), $filename);\n\n                        if ($parent->isAllowed('create')) {\n                            $asset = Asset::create($parent->getId(), [\n                                'filename' => $filename,\n                                'sourcePath' => $tmpFile,\n                                'userOwner' => $this->getAdminUser()->getId(),\n                                'userModification' => $this->getAdminUser()->getId(),\n                            ]);\n\n                            @unlink($tmpFile);\n                        } else {\n                            Logger::debug('prevented creating asset because of missing permissions');\n                        }\n                    }\n                }\n            }\n            $zip->close();\n        }\n\n        if ($request->get('last')) {\n            unlink($zipFile);\n        }\n\n        return $this->adminJson([\n            'success' => true,\n        ]);\n    }\n\n    /**\n     * @Route(\"/import-server\", name=\"pimcore_admin_asset_importserver\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function importServerAction(Request $request)\n    {\n        $success = true;\n        $filesPerJob = 5;\n        $jobs = [];\n        $importDirectory = str_replace('/fileexplorer', PIMCORE_PROJECT_ROOT, $request->get('serverPath'));\n        if (preg_match('@^' . preg_quote(PIMCORE_PROJECT_ROOT, '@') . '@', $importDirectory) && is_dir($importDirectory)) {\n            $this->checkForPharStreamWrapper($importDirectory);\n            $files = rscandir($importDirectory . '/');\n            $count = count($files);\n            $jobFiles = [];\n\n            for ($i = 0; $i < $count; $i++) {\n                if (is_dir($files[$i])) {\n                    continue;\n                }\n\n                $jobFiles[] = preg_replace('@^' . preg_quote($importDirectory, '@') . '@', '', $files[$i]);\n\n                if (count($jobFiles) >= $filesPerJob || $i >= ($count - 1)) {\n                    $relativeImportDirectory = preg_replace('@^' . preg_quote(PIMCORE_PROJECT_ROOT, '@') . '@', '', $importDirectory);\n                    $jobs[] = [[\n                        'url' => $this->generateUrl('pimcore_admin_asset_importserverfiles'),\n                        'method' => 'POST',\n                        'params' => [\n                            'parentId' => $request->get('parentId'),\n                            'serverPath' => $relativeImportDirectory,\n                            'files' => implode('::', $jobFiles),\n                        ],\n                    ]];\n                    $jobFiles = [];\n                }\n            }\n        }\n\n        return $this->adminJson([\n            'success' => $success,\n            'jobs' => $jobs,\n        ]);\n    }\n\n    /**\n     * @Route(\"/import-server-files\", name=\"pimcore_admin_asset_importserverfiles\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function importServerFilesAction(Request $request)\n    {\n        if(!Tool\\Admin::getCurrentUser()->isAdmin()) {\n            throw $this->createAccessDeniedException('Permission denied. You don\\'t have the rights to import files from the server!');\n        }\n\n        $assetFolder = Asset::getById((int) $request->get('parentId'));\n        if (!$assetFolder) {\n            throw $this->createNotFoundException('Parent asset not found');\n        }\n\n        $serverPath = realpath(PIMCORE_PROJECT_ROOT . $request->get('serverPath'));\n        if(!str_starts_with($serverPath, rtrim(str_replace('../', '', PIMCORE_PROJECT_ROOT), './'))) {\n            throw $this->createAccessDeniedException('Please do not navigate out of the web root directory!');\n        }\n\n        $files = explode('::', $request->get('files'));\n\n        foreach ($files as $file) {\n            $absolutePath = $serverPath . $file;\n            $this->checkForPharStreamWrapper($absolutePath);\n            if (is_file($absolutePath)) {\n                $relFolderPath = str_replace('\\\\', '/', dirname($file));\n                $folder = Asset\\Service::createFolderByPath($assetFolder->getRealFullPath() . $relFolderPath);\n                $filename = basename($file);\n\n                // check for duplicate filename\n                $filename = Element\\Service::getValidKey($filename, 'asset');\n                $filename = $this->getSafeFilename($folder->getRealFullPath(), $filename);\n\n                if ($assetFolder->isAllowed('create')) {\n                    $asset = Asset::create($folder->getId(), [\n                        'filename' => $filename,\n                        'sourcePath' => $absolutePath,\n                        'userOwner' => $this->getAdminUser()->getId(),\n                        'userModification' => $this->getAdminUser()->getId(),\n                    ]);\n                } else {\n                    Logger::debug('prevented creating asset because of missing permissions ');\n                }\n            }\n        }\n\n        return $this->adminJson([\n            'success' => true,\n        ]);\n    }\n\n    protected function checkForPharStreamWrapper($path)\n    {\n        if (stripos($path, 'phar://') !== false) {\n            throw $this->createAccessDeniedException('Using PHAR files is not allowed!');\n        }\n    }\n\n    /**\n     * @Route(\"/import-url\", name=\"pimcore_admin_asset_importurl\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     *\n     * @throws \\Exception\n     */\n    public function importUrlAction(Request $request)\n    {\n        $success = true;\n\n        $data = Tool::getHttpData($request->get('url'));\n        $filename = basename($request->get('url'));\n        $parentId = $request->get('id');\n        $parentAsset = Asset::getById((int)$parentId);\n\n        if (!$parentAsset) {\n            throw $this->createNotFoundException('Parent asset not found');\n        }\n\n        $filename = Element\\Service::getValidKey($filename, 'asset');\n        $filename = $this->getSafeFilename($parentAsset->getRealFullPath(), $filename);\n\n        if (empty($filename)) {\n            throw new \\Exception('The filename of the asset is empty');\n        }\n\n        // check for duplicate filename\n        $filename = $this->getSafeFilename($parentAsset->getRealFullPath(), $filename);\n\n        if ($parentAsset->isAllowed('create')) {\n            $asset = Asset::create($parentId, [\n                'filename' => $filename,\n                'data' => $data,\n                'userOwner' => $this->getAdminUser()->getId(),\n                'userModification' => $this->getAdminUser()->getId(),\n            ]);\n            $success = true;\n        } else {\n            Logger::debug('prevented creating asset because of missing permissions');\n        }\n\n        return $this->adminJson(['success' => $success]);\n    }\n\n    /**\n     * @Route(\"/clear-thumbnail\", name=\"pimcore_admin_asset_clearthumbnail\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function clearThumbnailAction(Request $request)\n    {\n        $success = false;\n\n        if ($asset = Asset::getById((int) $request->get('id'))) {\n            if (method_exists($asset, 'clearThumbnails')) {\n                if (!$asset->isAllowed('publish')) {\n                    throw $this->createAccessDeniedException('not allowed to publish');\n                }\n\n                $asset->clearThumbnails(true); // force clear\n                $asset->save();\n\n                $success = true;\n            }\n        }\n\n        return $this->adminJson(['success' => $success]);\n    }\n\n    /**\n     * @Route(\"/grid-proxy\", name=\"pimcore_admin_asset_gridproxy\", methods={\"GET\", \"POST\", \"PUT\"})\n     *\n     * @param Request $request\n     * @param EventDispatcherInterface $eventDispatcher\n     * @param GridHelperService $gridHelperService\n     * @param CsrfProtectionHandler $csrfProtection\n     *\n     * @return JsonResponse\n     */\n    public function gridProxyAction(Request $request, EventDispatcherInterface $eventDispatcher, GridHelperService $gridHelperService, CsrfProtectionHandler $csrfProtection)\n    {\n        $allParams = array_merge($request->request->all(), $request->query->all());\n\n        $filterPrepareEvent = new GenericEvent($this, [\n            'requestParams' => $allParams,\n        ]);\n        $language = $request->get('language') != 'default' ? $request->get('language') : null;\n\n        $eventDispatcher->dispatch($filterPrepareEvent, AdminEvents::ASSET_LIST_BEFORE_FILTER_PREPARE);\n\n        $allParams = $filterPrepareEvent->getArgument('requestParams');\n\n        $loader = \\Pimcore::getContainer()->get('pimcore.implementation_loader.asset.metadata.data');\n\n        if (isset($allParams['data']) && $allParams['data']) {\n            $csrfProtection->checkCsrfToken($request);\n            if ($allParams['xaction'] == 'update') {\n                try {\n                    $data = $this->decodeJson($allParams['data']);\n\n                    $updateEvent = new GenericEvent($this, [\n                        'data' => $data,\n                        'processed' => false,\n                    ]);\n\n                    $eventDispatcher->dispatch($updateEvent, AdminEvents::ASSET_LIST_BEFORE_UPDATE);\n\n                    $processed = $updateEvent->getArgument('processed');\n\n                    if ($processed) {\n                        // update already processed by event handler\n                        return $this->adminJson(['success' => true]);\n                    }\n\n                    $data = $updateEvent->getArgument('data');\n\n                    // save\n                    $asset = Asset::getById($data['id']);\n\n                    if (!$asset) {\n                        throw $this->createNotFoundException('Asset not found');\n                    }\n\n                    if (!$asset->isAllowed('publish')) {\n                        throw $this->createAccessDeniedException(\"Permission denied. You don't have the rights to save this asset.\");\n                    }\n\n                    $metadata = $asset->getMetadata(null, null, false, true);\n                    $dirty = false;\n\n                    unset($data['id']);\n                    foreach ($data as $key => $value) {\n                        $fieldDef = explode('~', $key);\n                        $key = $fieldDef[0];\n                        if (isset($fieldDef[1])) {\n                            $language = ($fieldDef[1] == 'none' ? '' : $fieldDef[1]);\n                        }\n\n                        foreach ($metadata as $idx => &$em) {\n                            if ($em['name'] == $key && $em['language'] == $language) {\n                                try {\n                                    $dataImpl = $loader->build($em['type']);\n                                    $value = $dataImpl->getDataFromListfolderGrid($value, $em);\n                                } catch (UnsupportedException $le) {\n                                    Logger::error('could not resolve metadata implementation for ' . $em['type']);\n                                }\n\n                                $em['data'] = $value;\n                                $dirty = true;\n\n                                break;\n                            }\n                        }\n\n                        if (!$dirty) {\n                            $defaulMetadata = ['title', 'alt', 'copyright'];\n                            if (in_array($key, $defaulMetadata)) {\n                                $newEm = [\n                                    'name' => $key,\n                                    'language' => $language,\n                                    'type' => 'input',\n                                    'data' => $value,\n                                ];\n\n                                try {\n                                    $dataImpl = $loader->build($newEm['type']);\n                                    $newEm['data'] = $dataImpl->getDataFromListfolderGrid($value, $newEm);\n                                } catch (UnsupportedException $le) {\n                                    Logger::error('could not resolve metadata implementation for ' . $newEm['type']);\n                                }\n\n                                $metadata[] = $newEm;\n\n                                $dirty = true;\n                            } else {\n                                $predefined = Model\\Metadata\\Predefined::getByName($key);\n                                if ($predefined && (empty($predefined->getTargetSubtype())\n                                        || $predefined->getTargetSubtype() == $asset->getType())) {\n                                    $newEm = [\n                                        'name' => $key,\n                                        'language' => $language,\n                                        'type' => $predefined->getType(),\n                                        'data' => $value,\n                                    ];\n\n                                    try {\n                                        $dataImpl = $loader->build($newEm['type']);\n                                        $newEm['data'] = $dataImpl->getDataFromListfolderGrid($value, $newEm);\n                                    } catch (UnsupportedException $le) {\n                                        Logger::error('could not resolve metadata implementation for ' . $newEm['type']);\n                                    }\n\n                                    $metadata[] = $newEm;\n                                    $dirty = true;\n                                }\n                            }\n                        }\n                    }\n\n                    if ($dirty) {\n                        // $metadata = Asset\\Service::minimizeMetadata($metadata, \"grid\");\n                        $asset->setMetadataRaw($metadata);\n                        $asset->save();\n\n                        return $this->adminJson(['success' => true]);\n                    }\n\n                    return $this->adminJson(['success' => false, 'message' => 'something went wrong.']);\n                } catch (\\Exception $e) {\n                    return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n                }\n            }\n        } else {\n            $list = $gridHelperService->prepareAssetListingForGrid($allParams, $this->getAdminUser());\n\n            $beforeListLoadEvent = new GenericEvent($this, [\n                'list' => $list,\n                'context' => $allParams,\n            ]);\n            $eventDispatcher->dispatch($beforeListLoadEvent, AdminEvents::ASSET_LIST_BEFORE_LIST_LOAD);\n            /** @var Asset\\Listing $list */\n            $list = $beforeListLoadEvent->getArgument('list');\n\n            $list->load();\n\n            $assets = [];\n            foreach ($list->getAssets() as $index => $asset) {\n                // Like for treeGetChildsByIdAction, so we respect isAllowed method which can be extended (object DI) for custom permissions, so relying only users_workspaces_asset is insufficient and could lead security breach\n                if ($asset->isAllowed('list')) {\n                    $a = Asset\\Service::gridAssetData($asset, $allParams['fields'], $allParams['language'] ?? '');\n                    $assets[] = $a;\n                }\n            }\n\n            $result = ['data' => $assets, 'success' => true, 'total' => $list->getTotalCount()];\n\n            $afterListLoadEvent = new GenericEvent($this, [\n                'list' => $result,\n                'context' => $allParams,\n            ]);\n            $eventDispatcher->dispatch($afterListLoadEvent, AdminEvents::ASSET_LIST_AFTER_LIST_LOAD);\n            $result = $afterListLoadEvent->getArgument('list');\n\n            return $this->adminJson($result);\n        }\n\n        return $this->adminJson(['success' => false]);\n    }\n\n    /**\n     * @Route(\"/get-text\", name=\"pimcore_admin_asset_gettext\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getTextAction(Request $request)\n    {\n        $asset = Asset::getById((int) $request->get('id'));\n\n        if (!$asset) {\n            throw $this->createNotFoundException('Asset not found');\n        }\n\n        if (!$asset->isAllowed('view')) {\n            throw $this->createAccessDeniedException('not allowed to view');\n        }\n\n        $page = $request->get('page');\n        $text = null;\n        if ($asset instanceof Asset\\Document) {\n            $text = $asset->getText($page);\n        }\n\n        return $this->adminJson(['success' => 'true', 'text' => $text]);\n    }\n\n    /**\n     * @Route(\"/detect-image-features\", name=\"pimcore_admin_asset_detectimagefeatures\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function detectImageFeaturesAction(Request $request)\n    {\n        $asset = Asset\\Image::getById((int)$request->get('id'));\n        if (!$asset instanceof Asset) {\n            return $this->adminJson(['success' => false, 'message' => \"asset doesn't exist\"]);\n        }\n\n        if ($asset->isAllowed('publish')) {\n            $asset->detectFaces();\n            $asset->removeCustomSetting('disableImageFeatureAutoDetection');\n            $asset->save();\n\n            return $this->adminJson(['success' => true]);\n        }\n\n        throw $this->createAccessDeniedHttpException();\n    }\n\n    /**\n     * @Route(\"/delete-image-features\", name=\"pimcore_admin_asset_deleteimagefeatures\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function deleteImageFeaturesAction(Request $request)\n    {\n        $asset = Asset::getById((int)$request->get('id'));\n        if (!$asset instanceof Asset) {\n            return $this->adminJson(['success' => false, 'message' => \"asset doesn't exist\"]);\n        }\n\n        if ($asset->isAllowed('publish')) {\n            $asset->removeCustomSetting('faceCoordinates');\n            $asset->setCustomSetting('disableImageFeatureAutoDetection', true);\n            $asset->save();\n\n            return $this->adminJson(['success' => true]);\n        }\n\n        throw $this->createAccessDeniedHttpException();\n    }\n\n    /**\n     * @param ControllerEvent $event\n     */\n    public function onKernelControllerEvent(ControllerEvent $event)\n    {\n        if (!$event->isMainRequest()) {\n            return;\n        }\n\n        $this->checkActionPermission($event, 'assets', [\n            'getImageThumbnailAction', 'getVideoThumbnailAction', 'getDocumentThumbnailAction',\n        ]);\n\n        $this->_assetService = new Asset\\Service($this->getAdminUser());\n    }\n\n    /**\n     * @throws ValidationException\n     */\n    private function validateManyToManyRelationAssetType(array $context, string $filename, string $sourcePath): void\n    {\n        if (isset($context['containerType'], $context['objectId'], $context['fieldname'])\n            && 'object' === $context['containerType']\n            && $object = Concrete::getById($context['objectId'])\n        ) {\n            $fieldDefinition = $object->getClass()?->getFieldDefinition($context['fieldname']);\n            if (!$fieldDefinition instanceof ManyToManyRelation) {\n                return;\n            }\n\n            $mimeType = MimeTypes::getDefault()->guessMimeType($sourcePath);\n            $type = Asset::getTypeFromMimeMapping($mimeType, $filename);\n\n            $allowedAssetTypes = $fieldDefinition->getAssetTypes();\n            $allowedAssetTypes = array_column($allowedAssetTypes, 'assetTypes');\n\n            if (\n                !(\n                    $fieldDefinition->getAssetsAllowed()\n                    && ($allowedAssetTypes === [] || in_array($type, $allowedAssetTypes, true))\n                )\n            ) {\n                throw new ValidationException(sprintf('Invalid relation in field `%s` [type: %s]', $context['fieldname'], $type));\n            }\n        }\n    }\n}\n", "/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n * @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n * @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\npimcore.registerNS(\"pimcore.asset.tree\");\npimcore.asset.tree = Class.create({\n\n    treeDataUrl: null,\n\n    initialize: function(config, perspectiveCfg) {\n        this.treeDataUrl = Routing.generate('pimcore_admin_asset_treegetchildsbyid');\n        this.perspectiveCfg = perspectiveCfg;\n        if (!perspectiveCfg) {\n            this.perspectiveCfg = {\n                position: \"left\"\n            };\n        }\n\n        this.perspectiveCfg = new pimcore.perspective(this.perspectiveCfg);\n        this.position = this.perspectiveCfg.position ? this.perspectiveCfg.position : \"left\";\n\n        if (!config) {\n            this.config = {\n                rootId: 1,\n                rootVisible: true,\n                loaderBaseParams: {},\n                treeId: \"pimcore_panel_tree_assets\",\n                treeIconCls: \"pimcore_icon_main_tree_asset pimcore_icon_material\",\n                treeTitle: t('assets'),\n                parentPanel: Ext.getCmp(\"pimcore_panel_tree_\" + this.position),\n            };\n        }\n        else {\n            this.config = config;\n        }\n\n        pimcore.layout.treepanelmanager.register(this.config.treeId);\n\n        // get root node config\n        Ext.Ajax.request({\n            url: Routing.generate('pimcore_admin_asset_treegetroot'),\n            params: {\n                id: this.config.rootId,\n                view: this.config.customViewId,\n                elementType: \"asset\"\n            },\n            success: function (response) {\n                var res = Ext.decode(response.responseText);\n                var callback = function () {};\n                if(res[\"id\"]) {\n                    callback = this.init.bind(this, res);\n                }\n                pimcore.layout.treepanelmanager.initPanel(this.config.treeId, callback);\n            }.bind(this)\n        });\n    },\n\n    init: function(rootNodeConfig) {\n\n        var itemsPerPage = pimcore.settings['asset_tree_paging_limit'];\n\n        let rootNodeConfigText = t('home');\n        let rootNodeConfigIconCls = \"pimcore_icon_home\";\n        if(this.config.customViewId !== undefined && rootNodeConfig.id !== 1) {\n            rootNodeConfigText = rootNodeConfig.key;\n            rootNodeConfigIconCls = rootNodeConfig.iconCls;\n        }\n\n        rootNodeConfig.text = rootNodeConfigText;\n        rootNodeConfig.allowDrag = true;\n        rootNodeConfig.id = \"\" + rootNodeConfig.id;\n        rootNodeConfig.iconCls = rootNodeConfigIconCls;\n        rootNodeConfig.cls = \"pimcore_tree_node_root\";\n        rootNodeConfig.expanded = true;\n\n        var store = Ext.create('pimcore.data.PagingTreeStore', {\n            autoLoad: false,\n            autoSync: false,\n            proxy: {\n                type: 'ajax',\n                url: this.treeDataUrl,\n                reader: {\n                    type: 'json',\n                    totalProperty : 'total',\n                    rootProperty: 'nodes'\n\n                },\n                extraParams: {\n                    limit: itemsPerPage,\n                    view: this.config.customViewId\n                },\n                timeout: 60000\n            },\n            pageSize: itemsPerPage,\n            root: rootNodeConfig\n        });\n\n        // assets\n        this.tree = Ext.create('pimcore.tree.Panel', {\n            selModel : {\n                mode : 'MULTI'\n            },\n            store: store,\n            autoLoad: false,\n            id: this.config.treeId,\n            title: this.config.treeTitle,\n            iconCls: this.config.treeIconCls,\n            cls: this.config['rootVisible'] ? '' : 'pimcore_tree_no_root_node',\n            autoScroll:true,\n            animate:false,\n            containerScroll: true,\n            ddAppendOnly: true,\n            rootVisible: this.config.rootVisible,\n            forceLayout: true,\n            bufferedRenderer: false,\n            border: false,\n            viewConfig: {\n                plugins: {\n                    ptype: 'treeviewdragdrop',\n                    appendOnly: true,\n                    ddGroup: \"element\"\n                },\n                listeners: {\n                    beforedrop: function (node, data) {\n                    },\n                    nodedragover: this.onTreeNodeOver.bind(this),\n                    startdrag: function() {\n                    }\n                },\n                xtype: 'pimcoretreeview'\n\n            },\n            tools: [{\n                type: \"right\",\n                handler: pimcore.layout.treepanelmanager.toRight.bind(this),\n                hidden: this.position == \"right\"\n            },{\n                type: \"left\",\n                handler: pimcore.layout.treepanelmanager.toLeft.bind(this),\n                hidden: this.position == \"left\"\n            }],\n            // root: rootNodeConfig,\n            listeners: this.getTreeNodeListeners()\n        });\n\n        //TODO\n        this.tree.getView().on(\"itemafterrender\",this.enableHtml5Upload.bind(this));\n        this.tree.on(\"render\", function () {\n            this.getRootNode().expand();\n        });\n        this.tree.on(\"afterrender\", function () {\n            try {\n                this.tree.loadMask = new Ext.LoadMask({\n                    target: this.tree,\n                    msg: t(\"please_wait\"),\n                    hidden: true\n                });\n\n                // add listener to root node -> other nodes are added om the \"append\" event -> see this.enableHtml5Upload()\n                this.addHtml5DragListener(this.tree.getRootNode());\n\n                // html5 upload\n                if (window[\"FileList\"]) {\n                    this.tree.getEl().dom.addEventListener(\"drop\", function (e) {\n\n                        e.stopPropagation();\n                        e.preventDefault();\n\n                        pimcore.helpers.treeNodeThumbnailPreviewHide();\n\n                        try {\n                            var selection = this.tree.getSelection();\n                            if (!selection) {\n                                return true;\n                            }\n                            if (selection.length < 1) {\n                                return true;\n                            }\n                        } catch (e2) {\n                            return true;\n                        }\n\n                        var node = selection[0];\n                        this.uploadFileList(e.dataTransfer, node);\n\n                    }.bind(this), true);\n                }\n            } catch (e) {\n                console.log(e);\n            }\n        }.bind(this));\n\n        if(!pimcore.settings.asset_disable_tree_preview) {\n            this.tree.on(\"itemmouseenter\", pimcore.helpers.treeNodeThumbnailPreview.bind(this));\n            this.tree.on(\"itemmouseleave\", pimcore.helpers.treeNodeThumbnailPreviewHide.bind(this));\n        }\n\n        store.on(\"nodebeforeexpand\", function (node) {\n            pimcore.helpers.addTreeNodeLoadingIndicator(\"asset\", node.data.id, false);\n        });\n\n        store.on(\"nodeexpand\", function (node, index, item, eOpts) {\n            pimcore.helpers.removeTreeNodeLoadingIndicator(\"asset\", node.data.id);\n        });\n\n        this.config.parentPanel.insert(this.config.index, this.tree);\n        this.config.parentPanel.updateLayout();\n\n        if (!this.config.parentPanel.alreadyExpanded && this.perspectiveCfg.expanded) {\n            this.config.parentPanel.alreadyExpanded = true;\n            this.tree.expand();\n        }\n    },\n\n    uploadFileList: function (dataTransfer, parentNode) {\n\n        var file;\n        this.activeUploads = 0;\n        var overwriteConfirmMessageBoxes = [];\n\n        var win = new Ext.Window({\n            items: [],\n            modal: true,\n            closable: false,\n            bodyStyle: \"padding:10px;\",\n            width: 500,\n            autoHeight: true,\n            autoScroll: true\n        });\n        win.show();\n\n        var doFileUpload = function (file, path) {\n\n            if(typeof path == \"undefined\") {\n                path = \"\";\n            }\n\n            this.activeUploads++;\n\n            var pbar = new Ext.ProgressBar({\n                width:465,\n                text: file.name,\n                style: \"margin-bottom: 5px\"\n            });\n\n            win.add(pbar);\n            win.updateLayout();\n\n            var finishedErrorHandler = function (e) {\n                this.activeUploads--;\n                win.remove(pbar);\n\n                if(this.activeUploads < 1) {\n                    win.close();\n                    pimcore.elementservice.refreshNodeAllTrees(\"asset\", parentNode.get(\"id\"));\n                }\n            }.bind(this);\n\n            var errorHandler = function (e) {\n                var res = Ext.decode(e[\"responseText\"]);\n                pimcore.helpers.showNotification(t(\"error\"), res.message ? res.message : t(\"error\"), \"error\", e[\"responseText\"]);\n                finishedErrorHandler();\n            }.bind(this);\n\n            Ext.Ajax.request({\n                url: Routing.generate('pimcore_admin_asset_exists'),\n                params: {\n                    parentId: parentNode.id,\n                    filename: file.name\n                },\n                async: false,\n                success: function (response) {\n                    var res = Ext.decode(response.responseText);\n\n                    var uploadFunction = function(allowOverwrite) {\n                        pimcore.helpers.uploadAssetFromFileObject(file,\n                            Routing.generate('pimcore_admin_asset_addasset', { parentId: parentNode.id, dir: path, allowOverwrite: allowOverwrite ? 1 : 0 }),\n                            finishedErrorHandler,\n                            function (evt) {\n                                //progress\n                                if (evt.lengthComputable) {\n                                    var percentComplete = evt.loaded / evt.total;\n                                    var progressText = file.name + \" ( \" + Math.floor(percentComplete * 100) + \"% )\";\n                                    if (percentComplete == 1) {\n                                        progressText = file.name + \" \" + t(\"please_wait\");\n                                    }\n\n                                    pbar.updateProgress(percentComplete, progressText);\n                                }\n                            },\n                            errorHandler\n                        );\n                    };\n\n                    if (res.exists) {\n                        var messageBox = new Ext.window.MessageBox();\n                        overwriteConfirmMessageBoxes.push(messageBox);\n                        messageBox.show({\n                            title: t('file_exists'),\n                            msg: t('asset_upload_want_to_overwrite').replace('%s', file.name),\n                            buttons: Ext.Msg.OK & Ext.Msg.YES & Ext.Msg.NO,\n                            buttonText: { ok: t('asset_upload_overwrite'), yes: t('asset_upload_keep_both'), no: t('asset_upload_overwrite_all') },\n                            prompt: false,\n                            icon: Ext.MessageBox.QUESTION,\n                            fn: function (action) {\n                                if (action === 'ok') {\n                                    uploadFunction(true);\n                                } else if (action === 'yes') {\n                                    uploadFunction(false);\n                                } else if (action === 'no') {\n                                    Ext.each(overwriteConfirmMessageBoxes, function(messageBox) {\n                                        if (messageBox) {\n                                            messageBox.down('button[itemId=ok]').fireHandler();\n                                        }\n                                    });\n                                } else if (action === 'cancel') {\n                                    finishedErrorHandler();\n                                }\n                            }\n                        });\n                    } else {\n                        uploadFunction();\n                    }\n                }\n            });\n        }.bind(this);\n\n        if(dataTransfer[\"items\"] && dataTransfer.items[0] && dataTransfer.items[0].webkitGetAsEntry) {\n            // chrome\n            var traverseFileTree = function (item, path) {\n                path = path || \"\";\n                if (item.isFile) {\n                    // Get file\n                    item.file(function (file) {\n                        doFileUpload(file, path);\n                    }.bind(this));\n                } else if (item.isDirectory) {\n                    // Get folder contents\n                    var dirReader = item.createReader();\n                    dirReader.readEntries(function (entries) {\n                        for (var i = 0; i < entries.length; i++) {\n                            traverseFileTree(entries[i], path + item.name + \"/\");\n                        }\n                    });\n                }\n            }.bind(this);\n\n            for (var i = 0; i < dataTransfer.items.length; i++) {\n                // webkitGetAsEntry is where the magic happens\n                var item = dataTransfer.items[i].webkitGetAsEntry();\n                if (item) {\n                    traverseFileTree(item);\n                }\n            }\n        } else if(dataTransfer[\"files\"]) {\n            // default filelist upload\n            for (var i=0; i<dataTransfer[\"files\"].length; i++) {\n                file = dataTransfer[\"files\"][i];\n\n                if (window.FileList && file.name && file.size) { // check for size (folder has size=0)\n                    doFileUpload(file);\n                } else if (!empty(file.type) && file.size < 1) { //throw error for 0 byte file\n                    Ext.MessageBox.alert(t('error'), t('error_empty_file_upload'));\n                    win.close();\n                }\n            }\n\n            // if no files are uploaded (doesn't match criteria, ...) close the progress win immediately\n            if(!this.activeUploads) {\n                win.close();\n            }\n        }\n\n        // check in 5 sec. if there're active uploads\n        // if not, close the progressbar\n        // this is necessary since the folder upload is async, so we don't know if the progress is\n        // necessary or not, not really perfect solution, but works as it should\n        window.setTimeout(function () {\n            if(!this.activeUploads) {\n                win.close();\n            }\n        }.bind(this), 5000);\n    },\n\n    getTreeNodeListeners: function () {\n        var treeNodeListeners = {\n            'itemclick' : this.onTreeNodeClick,\n            \"itemcontextmenu\": this.onTreeNodeContextmenu.bind(this),\n            \"itemmove\": this.onTreeNodeMove.bind(this),\n            \"beforeitemmove\": this.onTreeNodeBeforeMove.bind(this),\n            \"itemmouseenter\": function (el, record, item, index, e, eOpts) {\n                pimcore.helpers.treeToolTipShow(el, record, item);\n            },\n            \"itemmouseleave\": function () {\n                pimcore.helpers.treeToolTipHide();\n            }\n        };\n\n        return treeNodeListeners;\n    },\n\n    onTreeNodeClick: function (tree, record, item, index, event, eOpts ) {\n        if (event.ctrlKey === false && event.shiftKey === false && event.altKey === false) {\n            if (record.data.permissions.view) {\n                pimcore.helpers.treeNodeThumbnailPreviewHide();\n                pimcore.helpers.openAsset(record.data.id, record.data.type);\n            }\n        }\n    },\n\n\n    onTreeNodeOver: function (targetNode, position, dragData, e, eOpts ) {\n        var node = dragData.records[0];\n        if (node.getOwnerTree() != targetNode.getOwnerTree()) {\n            return false;\n        }\n        // check for permission\n        try {\n            if (node.data.permissions.settings) {\n                return true;\n            }\n        }\n        catch (e) {\n            console.log(e);\n        }\n\n        return false;\n    },\n\n    onTreeNodeMove: function (node, oldParent, newParent, index, eOpts ) {\n\n        var tree = node.getOwnerTree();\n\n        pimcore.elementservice.updateAsset(node.data.id, {\n            parentId: newParent.data.id\n        }, function (newParent, oldParent, tree, response) {\n            try{\n                var rdata = Ext.decode(response.responseText);\n                if (rdata && rdata.success) {\n                    // set new pathes\n                    var newBasePath = newParent.data.path;\n                    if (newBasePath == \"/\") {\n                        newBasePath = \"\";\n                    }\n                    node.data.basePath = newBasePath;\n                    node.data.path = node.data.basePath + \"/\" + node.data.text;\n                    pimcore.elementservice.nodeMoved(\"asset\", oldParent, newParent);\n                }\n                else {\n                    this.tree.loadMask.hide();\n                    pimcore.helpers.showNotification(t(\"error\"), t(\"cant_move_node_to_target\"),\n                        \"error\",t(rdata.message));\n                    // we have to delay refresh between two nodes,\n                    // as there could be parent child relationship leading to race condition\n                    window.setTimeout(function () {\n                        pimcore.elementservice.refreshNode(oldParent);\n                    }, 500);\n                    pimcore.elementservice.refreshNode(newParent);\n                }\n            } catch(e){\n                this.tree.loadMask.hide();\n                pimcore.helpers.showNotification(t(\"error\"), t(\"cant_move_node_to_target\"), \"error\");\n                // we have to delay refresh between two nodes,\n                // as there could be parent child relationship leading to race condition\n                window.setTimeout(function () {\n                    pimcore.elementservice.refreshNode(oldParent);\n                }, 500);\n                pimcore.elementservice.refreshNode(newParent);\n            }\n            this.tree.loadMask.hide();\n\n        }.bind(this, newParent, oldParent, tree));\n    },\n\n    onTreeNodeBeforeMove: function (node, oldParent, newParent, index, eOpts ) {\n        if (oldParent.getOwnerTree().getId() != newParent.getOwnerTree().getId()) {\n            Ext.MessageBox.alert(t('error'), t('cross_tree_moves_not_supported'));\n            return false;\n        }\n\n        // check for locks\n        if (node.data.locked) {\n            Ext.MessageBox.alert(t('locked'), t('element_cannot_be_move_because_it_is_locked'));\n            return false;\n        }\n\n        // check new parent's permission\n        if(!newParent.data.permissions.create){\n            Ext.MessageBox.alert(' ', t('element_cannot_be_moved'));\n            return false;\n        }\n\n        // check for permission\n        if (node.data.permissions.settings) {\n            this.tree.loadMask.show();\n            return true;\n        }\n        return false;\n    },\n\n    onTreeNodeContextmenu: function (tree, record, item, index, e, eOpts ) {\n        e.stopEvent();\n\n        if(pimcore.helpers.hasTreeNodeLoadingIndicator(\"asset\", record.id)) {\n            return;\n        }\n\n        var menu = new Ext.menu.Menu();\n        var perspectiveCfg = this.perspectiveCfg;\n\n        if(tree.getSelectionModel().getSelected().length > 1) {\n            var selectedIds = [];\n            tree.getSelectionModel().getSelected().each(function (item) {\n                selectedIds.push(item.id);\n            });\n\n            if (record.data.permissions.remove && record.data.id != 1 && !record.data.locked && perspectiveCfg.inTreeContextMenu(\"asset.delete\")) {\n                menu.add(new Ext.menu.Item({\n                    text: t('delete'),\n                    iconCls: \"pimcore_icon_delete\",\n                    handler: this.deleteAsset.bind(this, selectedIds.join(','))\n                }));\n            }\n        } else {\n            if (record.data.type == \"folder\") {\n                if (record.data.permissions.create) {\n\n                    var menuItems = [];\n\n                    if (perspectiveCfg.inTreeContextMenu(\"asset.add\")) {\n                        if (perspectiveCfg.inTreeContextMenu(\"asset.add.upload\")) {\n                            menuItems.push({\n                                text: t(\"upload_files\"),\n                                iconCls: \"pimcore_icon_upload\",\n                                listeners: {\n                                    \"afterrender\": function (el, eOpts) {\n                                        // we need to do this vanilla javascript and directly after finishing rendering\n                                        // otherwise this will cause issues when used with hybrid touch devices, see also:\n                                        // https://github.com/pimcore/pimcore/issues/1836\n                                        var fileElemId = 'assetMultiUploadField';\n                                        if (!document.getElementById(fileElemId)) {\n                                            document.body.insertAdjacentHTML('beforeend', '<input type=\"file\" id=\"' + fileElemId + '\" multiple>');\n                                        }\n\n                                        var fileSelect = el.getEl().down('a', true),\n                                            fileElem = document.getElementById(fileElemId);\n\n                                        if (fileElem['onChangeListener']) {\n                                            fileElem.removeEventListener('change', fileElem['onChangeListener']);\n                                        }\n\n                                        fileElem['onChangeListener'] = function (e) {\n                                            if (e.target.files.length) {\n                                                this.uploadFileList(e.target, record);\n                                            }\n                                        }.bind(this);\n\n                                        fileElem.addEventListener(\"change\", fileElem['onChangeListener']);\n\n                                        fileSelect.addEventListener(\"click\", function (e) {\n                                            if (fileElem) {\n                                                fileElem.value = fileElem.defaultValue;\n                                                fileElem.click();\n                                            }\n                                            e.preventDefault();\n                                        }, false);\n                                    }.bind(this)\n                                }\n                            });\n                        }\n\n                        if (perspectiveCfg.inTreeContextMenu(\"asset.add.uploadCompatibility\")) {\n                            menuItems.push({\n                                text: t(\"upload_compatibility_mode\"),\n                                handler: this.addSingleAsset.bind(this, tree, record),\n                                iconCls: \"pimcore_icon_upload\"\n                            });\n                        }\n\n                        if (perspectiveCfg.inTreeContextMenu(\"asset.add.uploadZip\")) {\n                            menuItems.push({\n                                text: t(\"upload_zip\"),\n                                handler: this.uploadZip.bind(this, tree, record),\n                                iconCls: \"pimcore_icon_zip pimcore_icon_overlay_upload\"\n                            });\n                        }\n\n                        if (perspectiveCfg.inTreeContextMenu(\"asset.add.importFromServer\") && pimcore.currentuser.admin) {\n                            menuItems.push({\n                                text: t(\"import_from_server\"),\n                                handler: this.importFromServer.bind(this, tree, record),\n                                iconCls: \"pimcore_icon_import_server\"\n                            });\n                        }\n\n                        if (perspectiveCfg.inTreeContextMenu(\"asset.add.uploadFromUrl\")) {\n                            menuItems.push({\n                                text: t(\"import_from_url\"),\n                                handler: this.importFromUrl.bind(this, tree, record),\n                                iconCls: \"pimcore_icon_world pimcore_icon_overlay_add\"\n                            });\n                        }\n\n                        if (menuItems.length > 0) {\n                            menu.add(new Ext.menu.Item({\n                                text: t('add_assets'),\n                                iconCls: \"pimcore_icon_asset pimcore_icon_overlay_add\",\n                                hideOnClick: false,\n                                menu: menuItems\n                            }));\n                        }\n                    }\n\n                    if (perspectiveCfg.inTreeContextMenu(\"asset.addFolder\")) {\n                        menu.add(new Ext.menu.Item({\n                            text: t('create_folder'),\n                            iconCls: \"pimcore_icon_folder pimcore_icon_overlay_add\",\n                            handler: this.addFolder.bind(this, tree, record)\n                        }));\n                    }\n\n                    menu.add(\"-\");\n\n                }\n            }\n\n            if (record.data.permissions.rename && record.data.id != 1 && !record.data.locked) {\n                if (perspectiveCfg.inTreeContextMenu(\"asset.rename\")) {\n                    menu.add(new Ext.menu.Item({\n                        text: t('rename'),\n                        iconCls: \"pimcore_icon_key pimcore_icon_overlay_go\",\n                        handler: this.editAssetKey.bind(this, tree, record)\n                    }));\n                }\n            }\n\n            if (this.id != 1 && record.data.permissions.view) {\n                if (perspectiveCfg.inTreeContextMenu(\"asset.copy\")) {\n                    menu.add(new Ext.menu.Item({\n                        text: t('copy'),\n                        iconCls: \"pimcore_icon_copy\",\n                        handler: this.copy.bind(this, tree, record)\n                    }));\n                }\n            }\n\n            //cut\n            if (record.data.id != 1 && !record.data.locked && record.data.permissions.rename) {\n                if (perspectiveCfg.inTreeContextMenu(\"asset.cut\")) {\n                    menu.add(new Ext.menu.Item({\n                        text: t('cut'),\n                        iconCls: \"pimcore_icon_cut\",\n                        handler: this.cut.bind(this, tree, record)\n                    }));\n                }\n            }\n\n\n            //paste\n            if (pimcore.cachedAssetId\n                && (record.data.permissions.create || record.data.permissions.publish)\n                && perspectiveCfg.inTreeContextMenu(\"asset.paste\")) {\n\n                if (record.data.type == \"folder\") {\n                    menu.add(new Ext.menu.Item({\n                        text: t('paste'),\n                        iconCls: \"pimcore_icon_paste\",\n                        handler: this.pasteInfo.bind(this, tree, record, \"recursive\")\n                    }));\n                } else {\n                    menu.add(new Ext.menu.Item({\n                        text: t('paste'),\n                        iconCls: \"pimcore_icon_paste\",\n                        handler: this.pasteInfo.bind(this, tree, record, \"replace\")\n                    }));\n                }\n            }\n\n            if (record.data.type == \"folder\" && pimcore.cutAsset\n                && (record.data.permissions.create || record.data.permissions.publish)\n                && perspectiveCfg.inTreeContextMenu(\"asset.pasteCut\")) {\n                menu.add(new Ext.menu.Item({\n                    text: t('paste_cut_element'),\n                    iconCls: \"pimcore_icon_paste\",\n                    handler: function () {\n                        this.pasteCutAsset(pimcore.cutAsset,\n                            pimcore.cutAssetParentNode, record, this.tree);\n                        pimcore.cutAssetParentNode = null;\n                        pimcore.cutAsset = null;\n                    }.bind(this)\n                }));\n            }\n\n            if (record.data.permissions.remove && record.data.id != 1 && !record.data.locked && perspectiveCfg.inTreeContextMenu(\"asset.delete\")) {\n                menu.add(new Ext.menu.Item({\n                    text: t('delete'),\n                    iconCls: \"pimcore_icon_delete\",\n                    handler: this.deleteAsset.bind(this, record.data.id)\n                }));\n            }\n\n            // upload & download\n            if (record.data.permissions.view) {\n                menu.add(\"-\");\n\n                if (record.data.type == \"folder\") {\n                    menu.add({\n                        text: t(\"download_as_zip\"),\n                        iconCls: \"pimcore_icon_zip pimcore_icon_overlay_download\",\n                        handler: function () {\n                            pimcore.elementservice.downloadAssetFolderAsZip(record.data.id)\n                        }\n                    });\n                } else {\n                    if (record.data.permissions.publish) {\n                        menu.add(new Ext.menu.Item({\n                            text: t('upload_new_version'),\n                            iconCls: \"pimcore_icon_upload\",\n                            handler: function () {\n                                pimcore.elementservice.replaceAsset(record.data.id, function () {\n                                    pimcore.elementservice.refreshNodeAllTrees(\"asset\", record.parentNode.id);\n                                });\n                            }\n                        }));\n                    }\n\n                    menu.add(new Ext.menu.Item({\n                        text: t('download'),\n                        iconCls: \"pimcore_icon_download\",\n                        handler: function () {\n                            pimcore.helpers.download(Routing.generate('pimcore_admin_asset_download', {id: record.data.id}));\n                        }\n                    }));\n                }\n            }\n\n            // advanced menu\n            var advancedMenuItems = [];\n            var user = pimcore.globalmanager.get(\"user\");\n\n            if (record.data.permissions.create && !record.data.locked && perspectiveCfg.inTreeContextMenu(\"asset.searchAndMove\")) {\n                advancedMenuItems.push({\n                    text: t('search_and_move'),\n                    iconCls: \"pimcore_icon_search pimcore_icon_overlay_go\",\n                    handler: this.searchAndMove.bind(this, tree, record)\n                });\n            }\n\n            if (record.data.id != 1 && user.admin) {\n                var lockMenu = [];\n                if (record.data.lockOwner && perspectiveCfg.inTreeContextMenu(\"asset.unlock\")) { // add unlock\n                    lockMenu.push({\n                        text: t('unlock'),\n                        iconCls: \"pimcore_icon_lock pimcore_icon_overlay_delete\",\n                        handler: function () {\n                            pimcore.elementservice.lockElement({\n                                elementType: \"asset\",\n                                id: record.data.id,\n                                mode: null\n                            });\n                        }.bind(this)\n                    });\n                } else if (perspectiveCfg.inTreeContextMenu(\"asset.lock\")) {\n                    lockMenu.push({\n                        text: t('lock'),\n                        iconCls: \"pimcore_icon_lock pimcore_icon_overlay_add\",\n                        handler: function () {\n                            pimcore.elementservice.lockElement({\n                                elementType: \"asset\",\n                                id: record.data.id,\n                                mode: \"self\"\n                            });\n                        }.bind(this)\n                    });\n\n                    if (record.data.type == \"folder\" && perspectiveCfg.inTreeContextMenu(\"asset.lockAndPropagate\")) {\n                        lockMenu.push({\n                            text: t('lock_and_propagate_to_childs'),\n                            iconCls: \"pimcore_icon_lock pimcore_icon_overlay_go\",\n                            handler: function () {\n                                pimcore.elementservice.lockElement({\n                                    elementType: \"asset\",\n                                    id: record.data.id,\n                                    mode: \"propagate\"\n                                });\n                            }.bind(this)\n                        });\n                    }\n                }\n\n                if (record.data.locked && perspectiveCfg.inTreeContextMenu(\"asset.unlockAndPropagate\")) {\n                    // add unlock and propagate to children functionality\n                    lockMenu.push({\n                        text: t('unlock_and_propagate_to_children'),\n                        iconCls: \"pimcore_icon_lock pimcore_icon_overlay_delete\",\n                        handler: function () {\n                            pimcore.elementservice.unlockElement({\n                                elementType: \"asset\",\n                                id: record.data.id\n                            });\n                        }.bind(this)\n                    });\n                }\n\n                if (lockMenu.length > 0) {\n                    advancedMenuItems.push({\n                        text: t('lock'),\n                        iconCls: \"pimcore_icon_lock\",\n                        hideOnClick: false,\n                        menu: lockMenu\n                    });\n                }\n            }\n\n            // expand and collapse complete tree\n            if (!record.data.leaf) {\n                if (record.data.expanded) {\n                    advancedMenuItems.push({\n                        text: t('collapse_children'),\n                        iconCls: \"pimcore_icon_collapse_children\",\n                        handler: function () {\n                            record.collapse(true);\n                        }.bind(this, record)\n                    });\n                } else {\n                    advancedMenuItems.push({\n                        text: t('expand_children'),\n                        iconCls: \"pimcore_icon_expand_children\",\n                        handler: function () {\n                            record.expand(true);\n                        }.bind(this, record)\n                    });\n                }\n            }\n\n            menu.add(\"-\");\n\n            if (advancedMenuItems.length) {\n                menu.add({\n                    text: t('advanced'),\n                    iconCls: \"pimcore_icon_more\",\n                    hideOnClick: false,\n                    menu: advancedMenuItems\n                });\n            }\n\n            if (record.data.type == \"folder\" && perspectiveCfg.inTreeContextMenu(\"asset.reload\")) {\n                menu.add(new Ext.menu.Item({\n                    text: t('refresh'),\n                    iconCls: \"pimcore_icon_reload\",\n                    handler: pimcore.elementservice.refreshNode.bind(this, record)\n                }));\n            }\n        }\n\n        pimcore.helpers.hideRedundantSeparators(menu);\n\n        const prepareAssetTreeContextMenu = new CustomEvent(pimcore.events.prepareAssetTreeContextMenu, {\n            detail: {\n                menu: menu,\n                tree: this,\n                asset: record\n            }\n        });\n\n        document.dispatchEvent(prepareAssetTreeContextMenu);\n\n        menu.showAt(e.pageX+1, e.pageY+1);\n    },\n\n\n    copy: function (tree, record) {\n        pimcore.cachedAssetId = record.id;\n    },\n\n    cut: function (tree, record) {\n        pimcore.cutAsset = record;\n        pimcore.cutAssetParentNode = record.parentNode;\n    },\n\n    pasteCutAsset: function(asset, oldParent, newParent, tree) {\n        pimcore.elementservice.updateAsset(asset.id, {\n            parentId: newParent.id\n        }, function (asset, newParent, oldParent, tree, response) {\n            try{\n                var rdata = Ext.decode(response.responseText);\n                if (rdata && rdata.success) {\n                    // set new pathes\n                    var newBasePath = newParent.data.path;\n                    if (newBasePath == \"/\") {\n                        newBasePath = \"\";\n                    }\n                    asset.data.basePath = newBasePath;\n                    asset.data.path = asset.data.basePath + \"/\" + asset.data.text;\n                }\n                else {\n                    this.tree.loadMask.hide();\n                    pimcore.helpers.showNotification(t(\"error\"), t(\"cant_move_node_to_target\"),\n                        \"error\",t(rdata.message));\n                }\n            } catch(e){\n                this.tree.loadMask.hide();\n                pimcore.helpers.showNotification(t(\"error\"), t(\"cant_move_node_to_target\"), \"error\");\n            }\n            this.tree.loadMask.hide();\n            pimcore.elementservice.refreshNodeAllTrees(\"asset\", oldParent.id);\n            pimcore.elementservice.refreshNodeAllTrees(\"asset\", newParent.id);\n            newParent.expand();\n        }.bind(this, asset, newParent, oldParent, tree));\n\n    },\n\n    pasteInfo: function (tree, record, type) {\n        pimcore.helpers.addTreeNodeLoadingIndicator(\"asset\", record.id);\n\n        Ext.Ajax.request({\n            url: Routing.generate('pimcore_admin_asset_copyinfo'),\n            params: {\n                targetId: record.id,\n                sourceId: pimcore.cachedAssetId,\n                type: type\n            },\n            success: this.paste.bind(this, tree, record)\n        });\n    },\n\n    paste: function (tree, record, response) {\n\n        try {\n            var res = Ext.decode(response.responseText);\n\n            if (res.pastejobs) {\n\n                record.pasteProgressBar = new Ext.ProgressBar({\n                    text: t('initializing')\n                });\n\n                record.pasteWindow = new Ext.Window({\n                    title: t(\"paste\"),\n                    layout:'fit',\n                    width:200,\n                    bodyStyle: \"padding: 10px;\",\n                    closable:false,\n                    plain: true,\n                    items: [record.pasteProgressBar],\n                    listeners: pimcore.helpers.getProgressWindowListeners()\n                });\n\n                record.pasteWindow.show();\n\n                var pj = new pimcore.tool.paralleljobs({\n                    success: function () {\n\n                        try {\n                            this.pasteComplete(tree, record);\n                        } catch(e) {\n                            console.log(e);\n                            pimcore.helpers.showNotification(t(\"error\"), t(\"error_pasting_item\"), \"error\");\n                            pimcore.elementservice.refreshNodeAllTrees(\"asset\", record.parentNode.id);\n                        }\n                    }.bind(this),\n                    update: function (currentStep, steps, percent) {\n                        if(record.pasteProgressBar) {\n                            var status = currentStep / steps;\n                            record.pasteProgressBar.updateProgress(status, percent + \"%\");\n                        }\n                    }.bind(this),\n                    failure: function (message) {\n                        this.pasteWindow.close();\n                        record.pasteProgressBar = null;\n\n                        pimcore.helpers.showNotification(t(\"error\"), t(\"error_pasting_item\"), \"error\", t(message));\n                        pimcore.elementservice.refreshNodeAllTrees(\"asset\", record.parentNode.id);\n                    }.bind(this),\n                    jobs: res.pastejobs\n                });\n            } else {\n                throw \"There are no pasting jobs\";\n            }\n        } catch (e) {\n            console.log(e);\n            Ext.MessageBox.alert(t('error'), e);\n            this.pasteComplete(this, tree, record);\n        }\n    },\n\n    pasteComplete: function (tree, record) {\n        if(record.pasteWindow) {\n            record.pasteWindow.close();\n        }\n\n        record.pasteProgressBar = null;\n        record.pasteWindow = null;\n\n        pimcore.elementservice.refreshNodeAllTrees(\"asset\", record.id);\n    },\n\n    addFolder : function (tree, record) {\n        Ext.MessageBox.prompt(t('create_folder'), t('enter_the_name_of_the_new_item'),\n            this.addFolderCreate.bind(this, tree, record));\n    },\n\n    addFolderCreate: function (tree, record, button, value, object) {\n\n        if (button == \"ok\") {\n\n            // check for identical folder name in current level\n            if (pimcore.elementservice.isKeyExistingInLevel(record, value)) {\n                return;\n            }\n\n            Ext.Ajax.request({\n                url: Routing.generate('pimcore_admin_asset_addfolder'),\n                method: \"POST\",\n                params: {\n                    parentId: record.data.id,\n                    name: pimcore.helpers.getValidFilename(value, \"asset\")\n                },\n                success: this.addFolderComplete.bind(this, tree, record)\n            });\n        }\n    },\n\n    addFolderComplete: function (tree, record, response) {\n        try{\n            var rdata = Ext.decode(response.responseText);\n            if (rdata && rdata.success) {\n                record.data.leaf = false;\n                //this.renderIndent();\n                record.expand();\n            }\n            else {\n                pimcore.helpers.showNotification(t(\"error\"), t(\"failed_to_create_new_item\"),\n                    \"error\",t(rdata.message));\n            }\n        } catch(e){\n            pimcore.helpers.showNotification(t(\"error\"), t(\"failed_to_create_new_item\"), \"error\");\n        }\n        pimcore.elementservice.refreshNodeAllTrees(\"asset\", record.get(\"id\"));\n    },\n\n    addSingleAsset: function (tree, record) {\n        pimcore.helpers.assetSingleUploadDialog(record.data.id, \"id\", function (res) {\n            var f = this.addAssetComplete.bind(this, tree, record);\n            f();\n        }.bind(this), function (res) {\n            var response = Ext.decode(res.response.responseText);\n            if(response.success === false) {\n                pimcore.helpers.showNotification(t(\"error\"), response.message, \"error\",\n                    res.response.responseText);\n            }\n            var f = this.addAssetComplete.bind(this, tree, record);\n            f();\n        }.bind(this));\n    },\n\n    uploadZip: function (tree, record) {\n\n        pimcore.helpers.uploadDialog(Routing.generate('pimcore_admin_asset_importzip', {parentId: record.id}), \"Filedata\", function (response) {\n            // this.attributes.reference\n            var res = Ext.decode(response.response.responseText);\n            pimcore.helpers.addTreeNodeLoadingIndicator(\"asset\", record.get(\"id\"));\n\n            this.downloadProgressBar = new Ext.ProgressBar({\n                text: t('initializing')\n            });\n\n            this.downloadProgressWin = new Ext.Window({\n                title: t(\"upload_zip\"),\n                layout:'fit',\n                width:200,\n                bodyStyle: \"padding: 10px;\",\n                closable:false,\n                plain: true,\n                items: [this.downloadProgressBar],\n                listeners: pimcore.helpers.getProgressWindowListeners()\n            });\n\n            this.downloadProgressWin.show();\n\n            var pj = new pimcore.tool.paralleljobs({\n                success: function (jobId) {\n                    if(this.downloadProgressWin) {\n                        this.downloadProgressWin.close();\n                    }\n\n                    this.downloadProgressBar = null;\n                    this.downloadProgressWin = null;\n\n                    pimcore.elementservice.refreshNodeAllTrees(\"asset\", record.get(\"id\"));\n                }.bind(this, res.jobId),\n                update: function (currentStep, steps, percent) {\n                    if(this.downloadProgressBar) {\n                        var status = currentStep / steps;\n                        this.downloadProgressBar.updateProgress(status, percent + \"%\");\n                    }\n                }.bind(this),\n                failure: function (message) {\n                    this.downloadProgressWin.close();\n                    pimcore.elementservice.refreshNodeAllTrees(\"asset\", record.get(\"id\"));\n                    pimcore.helpers.showNotification(t(\"error\"), t(\"error\"),\n                        \"error\", t(message));\n                }.bind(this),\n                jobs: res.jobs\n            });\n        }.bind(this), function (res) {\n            var response = Ext.decode(res.response.responseText);\n            if (response && response.success === false) {\n                pimcore.helpers.showNotification(t(\"error\"), response.message, \"error\",\n                    res.response.responseText);\n            } else {\n                pimcore.helpers.showNotification(t(\"error\"), res, \"error\",\n                    res.response.responseText);\n            }\n\n            pimcore.elementservice.refreshNodeAllTrees(\"asset\", record.parentNode.get(\"id\"));\n        }.bind(this));\n    },\n\n    enableHtml5Upload: function (node, rowIdx, out) {\n\n        if (!window[\"FileList\"]) {\n            return;\n        }\n\n        // only for folders\n        if (node.data.type != \"folder\") {\n            return;\n        }\n\n        // timeout because there is no afterrender function\n        window.setTimeout(this.addHtml5DragListener.bind(this, node), 2000);\n    },\n\n    addHtml5DragListener: function (node) {\n\n        try {\n            var tree = this.tree;\n            var el = Ext.fly(tree.getView().getNodeByRecord(node));\n            if(el) {\n                el = el.dom;\n                var fn = function (e) {\n                    //e.stopPropagation();\n                    e.preventDefault();\n                    tree.setSelection(node);\n\n                    e.dataTransfer.dropEffect = 'copy';\n\n                    return false;\n                };\n\n                el.addEventListener(\"dragenter\", fn, true);\n                el.addEventListener(\"dragover\", fn, true);\n            }\n        }\n        catch (e) {\n            console.log(e);\n        }\n    },\n\n    importFromServer: function (tree, record) {\n\n        var store = Ext.create('Ext.data.TreeStore', {\n            proxy: {\n                type: 'ajax',\n                url: Routing.generate('pimcore_admin_misc_fileexplorertree')\n            },\n            folderSort: true,\n            sorters: [{\n                property: 'text',\n                direction: 'ASC'\n            }]\n        });\n\n        this.treePanel = new Ext.tree.TreePanel({\n            region: \"west\",\n            width: 300,\n            rootVisible: true,\n            enableDD: false,\n            autoScroll: true,\n            store: store,\n            root: {\n                nodeType: 'async',\n                text: t(\"document_root\"),\n                id: '/fileexplorer/',\n                iconCls: \"pimcore_icon_home\",\n                expanded: true,\n                type: \"folder\"\n            },\n            listeners: {\n                itemclick: function(tree, record, item, index, e, eOpts ) {\n                    Ext.getCmp(\"pimcore_asset_server_import_button\").setDisabled(record.data.type != \"folder\");\n                }.bind(this)\n            }\n        });\n\n        this.uploadWindow = new Ext.Window({\n            layout: 'fit',\n            title: t('add_assets'),\n            closeAction: 'destroy',\n            width:400,\n            height:400,\n            modal: true,\n            items: [this.treePanel],\n            buttons: [{\n                text: t(\"import\"),\n                disabled: true,\n                id: \"pimcore_asset_server_import_button\",\n                handler: function (tree, record) {\n\n                    try {\n                        Ext.getCmp(\"pimcore_asset_server_import_button\").disable();\n                        var selModel =  this.treePanel.getSelectionModel();\n                        var selectedNode = selModel.getSelected().getAt(0);\n                        this.uploadWindow.removeAll();\n\n                        this.uploadWindow.add({\n                            xtype: \"panel\",\n                            html: t(\"please_wait\"),\n                            bodyStyle: \"padding:10px;\"\n                        });\n                        this.uploadWindow.updateLayout();\n\n                        Ext.Ajax.request({\n                            url: Routing.generate('pimcore_admin_asset_importserver'),\n                            method: 'POST',\n                            params: {\n                                parentId: record.id,\n                                serverPath: selectedNode.id\n                            },\n                            success: function (tree, record, response) {\n                                this.uploadWindow.close();\n                                this.uploadWindow = null;\n\n                                pimcore.helpers.addTreeNodeLoadingIndicator(\"asset\", record.get(\"id\"));\n\n                                var res = Ext.decode(response.responseText);\n\n                                this.downloadProgressBar = new Ext.ProgressBar({\n                                    text: t('initializing')\n                                });\n\n                                this.downloadProgressWin = new Ext.Window({\n                                    title: t(\"import_from_server\"),\n                                    layout:'fit',\n                                    width:200,\n                                    bodyStyle: \"padding: 10px;\",\n                                    closable:false,\n                                    plain: true,\n                                    items: [this.downloadProgressBar],\n                                    listeners: pimcore.helpers.getProgressWindowListeners()\n                                });\n\n                                this.downloadProgressWin.show();\n\n                                var pj = new pimcore.tool.paralleljobs({\n                                    success: function () {\n                                        if(this.downloadProgressWin) {\n                                            this.downloadProgressWin.close();\n                                        }\n\n                                        this.downloadProgressBar = null;\n                                        this.downloadProgressWin = null;\n\n                                        pimcore.elementservice.refreshNodeAllTrees(\"asset\", record.get(\"id\"));\n                                    }.bind(this),\n                                    update: function (currentStep, steps, percent) {\n                                        if(this.downloadProgressBar) {\n                                            var status = currentStep / steps;\n                                            this.downloadProgressBar.updateProgress(status, percent + \"%\");\n                                        }\n                                    }.bind(this),\n                                    failure: function (message) {\n                                        this.downloadProgressWin.close();\n                                        pimcore.elementservice.refreshNodeAllTrees(\"asset\", record.get(\"id\"));\n\n                                        pimcore.helpers.showNotification(t(\"error\"), t(\"error\"),\n                                            \"error\", t(message));\n                                    }.bind(this),\n                                    jobs: res.jobs\n                                });\n                            }.bind(this, tree, record)\n                        });\n\n\n                    } catch (e) {\n                        console.log(e)\n                    }\n                }.bind(this, tree, record)\n            }]\n        });\n\n        this.uploadWindow.show();\n    },\n\n    importFromUrl: function (tree, record) {\n\n        Ext.MessageBox.prompt(t(\"import_from_url\"), ' ', function (button, value, object) {\n            if (button == \"ok\") {\n                var win = new Ext.Window({\n                    html: t(\"please_wait\"),\n                    closable: false,\n                    bodyStyle: \"padding: 10px;\",\n                    modal: true\n                });\n                win.show();\n\n                Ext.Ajax.request({\n                    url: Routing.generate('pimcore_admin_asset_importurl'),\n                    method: 'POST',\n                    params: {\n                        id: record.data.id,\n                        url: value\n                    },\n                    success: function () {\n                        win.close();\n                        pimcore.elementservice.refreshNodeAllTrees(\"asset\", record.get(\"id\"));\n\n                    }.bind(this),\n                    failure: function() {\n                        win.close();\n                        pimcore.elementservice.refreshNodeAllTrees(\"asset\", record.get(\"id\"));\n                    }\n                });\n            }\n        }.bind(this), null, false, 'https://');\n    },\n\n    addAssetComplete: function (tree, record, config, file, response) {\n\n        record.data.leaf = false;\n        record.expand();\n        pimcore.elementservice.refreshNodeAllTrees(\"asset\", record.get(\"id\"));\n    },\n\n    editAssetKey: function (tree, record) {\n        var options = {\n            sourceTree: tree,\n            elementType: \"asset\",\n            elementSubType: record.data.type,\n            id: record.data.id,\n            default: Ext.util.Format.htmlDecode(record.data.text)\n        };\n        pimcore.elementservice.editElementKey(options);\n    },\n\n\n    searchAndMove: function(tree, record) {\n        pimcore.helpers.searchAndMove(record.data.id, function() {\n            pimcore.elementservice.refreshNode(record);\n        }.bind(this), \"asset\");\n    },\n\n\n\n    deleteAsset : function (ids) {\n        var options = {\n            \"elementType\" : \"asset\",\n            \"id\": ids\n        };\n\n        pimcore.elementservice.deleteElement(options);\n    }\n});\n", "# Upgrade Notes\n\n## 10.5.21\n- [Assets] The Asset `Import from Server` feature is now only available for admins. It will be removed in Pimcore 11\n\n## 10.5.13\n- [Web2Print] Print document twig expressions are now executed in a sandbox with restrictive security policies (just like Sending mails and Dataobject Text Layouts introduced in 10.5.9).\n\n\n## 10.5.10\n- [DataObject] Deprecated: Loading non-Concrete objects with the Concrete class will not be possible in Pimcore 11.\n\n## 10.5.9\n- [Twig] Sending mails and Dataobject Text Layouts, which allow rendering user controlled twig templates are now executed in a sandbox with restrictive security policies for tags, filters, functions.\n         Please use following configuration to allow more in template rendering:\n  ```yaml\n  pimcore:\n        templating_engine:\n            twig:\n              sandbox_security_policy:\n                tags: ['if']\n                filters: ['upper']\n                functions: ['include', 'path', 'range']\n  ```\n\n## 10.5.8\n- [Nginx] Static pages nginx config has been updated to fix the issue for home static page generation. please adapt the following configuration:\n```nginx\nmap $args $static_page_root {\n    default                                 /var/tmp/pages;\n    \"~*(^|&)pimcore_editmode=true(&|$)\"     /var/nonexistent;\n    \"~*(^|&)pimcore_preview=true(&|$)\"      /var/nonexistent;\n    \"~*(^|&)pimcore_version=[^&]+(&|$)\"     /var/nonexistent;\n}\n\nmap $uri $static_page_uri {\n    default                                 $uri;\n    \"/\"                                     /%home;\n}\n\n.....\n\nlocation / {\n    error_page 404 /meta/404;\n\n    try_files $static_page_root$static_page_uri.html $uri /index.php$is_args$args;\n}\n```\n\n## 10.5.0\n- [Class Definitions] Resolving classes or services will no longer catch exceptions in Pimcore 11. Remove invalid references from class definitions.\n- [Sessions] Changed default value for `symfony.session.cookie_secure` to `auto`\n- [Listings] `JsonListing` class is deprecated. Please use `CallableFilterListingInterface`, `FilterListingTrait` and `CallableOrderListingInterface`, `OrderListingTrait` instead.\n  For examples please see existing classes, e.g. `Pimcore\\Model\\Document\\DocType\\Listing`.\n\n- [Security] It is recommended to use new [Authenticator based system](https://pimcore.com/docs/pimcore/current/Development_Documentation/Development_Tools_and_Details/Security_Authentication/Authenticator_Based_Security.html) for authentication/authorization.\n  To use new authenticator, add following symfony config in `security.yaml`:\n    ```yaml\n    security:\n        enable_authenticator_manager: true\n    ```\n  `[Authentication] PreAuthenticatedAdminSessionListener` has been deprecated and will be removed in Pimcore 11.\n- [Elements] Calling the methods `getById` and `getByPath` on `Asset`,`Document`,`DataObject` with second boolean parameter `$force` and `Element\\Service::getElementById` with third boolean  parameter `$force` is deprecated and will throw exception in Pimcore 11. Instead pass the parameter as associative array with `$force` value.\n  e.g. Before \n   ```php\n    Asset::getById($id, true);\n    Document::getById($id, true);\n    DataObject::getById($id, true);\n  \n    Asset::getByPath($path, true);\n    Document::getByPath($path, true);\n    DataObject::getByPath($path, true);\n  \n    Element\\Service::getElementById::getElementById($type, $id, $true);\n   ```\n    After\n   ```php\n    Asset::getById($id, ['force' => true]);\n    Document::getById($id, ['force' => true]);\n    DataObject::getById($id, ['force' => true]);\n  \n    Asset::getByPath($path, ['force' => true]);\n    Document::getByPath($path, ['force' => true]);\n    DataObject::getByPath($path, ['force' => true]);\n  \n    Element\\Service::getElementById($type, $id, ['force' => true]);\n   ```\n- [Navigation Builder] Calling the method `Pimcore\\Navigation\\Builder::getNavigation()` using extra arguments is deprecated and will be removed in Pimcore 11. Instead of using the extra arguments, it is recommended to call the method using the params array. eg: Currently, the `getNavigation()` method can be called by passing the config params `activeDocument`, `navigationRootDocument`, `htmlMenuIdPrefix`, `pageCallback`, `cache`, `maxDepth`, `cacheLifetime` and `markActiveTrail` as the arguments i.e `getNavigation($activeDocument, $navigationRootDocument, $htmlMenuIdPrefix, $pageCallback, $cache, $maxDepth, $cacheLifetime, $markActiveTrail)`. According to the new implementation you should call the method like `getNavigation($params)` where `$params` should be an associative array with the keys `active`, `root`, `htmlMenuPrefix`, `pageCallback`, `cache`, `maxDepth`, `cacheLifetime` and `markActiveTrail`.\n  \n- [Runtime Cache] The trait `\\Pimcore\\Cache\\RuntimeCacheTrait` has been deprecated because of its ambiguous naming and usage of persisted cache along with the runtime object cache.\n  It is recommended to use `\\Pimcore\\Cache\\RuntimeCache` instead of this trait. For persisted cache, please use `\\Pimcore\\Cache` instead.\n- [Sitemap] Pimcore is now also supporting Presta/Sitemap `^3.2` (which supports Symfony 6 and uses max level of PHPStan).\n  Please note, if the routing import config is in use, it is recommended to correct the config path (by removing `/Resources`) to follow the [new folder tree structure](https://github.com/prestaconcept/PrestaSitemapBundle/releases/tag/v3.0.0),\n  eg. \"@PrestaSitemapBundle/~~Resources/~~config/routing.yaml\", to ensure a smoother upgrade to upcoming major release.\n- [Backend search] `key` and `index` columns have been added to the search index. Run `./bin/console pimcore:search-backend-reindex` to reindex.\n- [Cache] Pimcore use DoctrineDbalAdapter instead of PdoAdapter by default now.\n- Removed `ocramius/package-versions` dependency. If you rely on it, please add it to your own `composer.json`.\n- [Permissions] Added an extra check about [system permission](https://pimcore.com/docs/pimcore/current/Development_Documentation/Administration_of_Pimcore/Users_and_Roles.html#page_System-Permissions) in element `isAllowed()` method, please make sure your custom implementations are not affected by this change. \n  Listing, grid, tree view are not severely affected as the main permission is checked on a Kernel event level that prevents the page to be shown and prevents any process that iterate isAllowed() calls. \n  The only cases could be affected are those where the workspace are set but master permissions are disallowed, before this change, it could lead to (not intended) false positive.\n- [Security/User] `UsernameNotFoundException` (deprecated since Symfony 5.3) occurences have been replaced with `UserNotFoundException`.\n- [Deprecated] Generate type declarations option in class definition is deprecated, because type declarations will always be added with Pimcore 11\n- [Application Logger] File Objects are now stored in the flysystem. Due some incompatibilities of checking files by modification date (cloud storages) and for performance issues (scan folders/file), the cleanup task now do not run in time range from [midnight and 4 a.m.](https://github.com/pimcore/pimcore/pull/7164) anymore, but it deletes the file matching the column in the database as soon as the database entries are archived.\n- [Session] Implementing Session Configurator with tag `pimcore.session.configurator` to register session bags, is deprecated and will be removed in Pimcore 11.\n  Implement an [EventListener](https://github.com/pimcore/pimcore/blob/10.5/bundles/EcommerceFrameworkBundle/EventListener/SessionBagListener.php) to register a session bag before the session is started.\n- [Ecommerce][PricingManager] Token condition is deprecated and will be removed in Pimcore 11.\n- Parameter `pimcore.admin.session.attribute_bags` is deprecated and will be removed in Pimcore 11.\n- [JS Events/Disabled] The plugin broker for fire events has been disabled. \nThe plugins are still supported, but they are deprecated and will be removed in Pimcore 11   \nPlease use [event listener](../../20_Extending_Pimcore/13_Bundle_Developers_Guide/06_Event_Listener_UI.md) instead of plugins for JS events.\n- Extension Manager - Registering or managing bundles/areabricks through `Tools -> Bundles & Bricks` or manually through `var/config/extensions.php` is deprecated and will not work on Pimcore 11.\n  Please use `config/bundles.php` to register/manage bundles instead.\n- [Web2Print] Wkhtmltopdf Processor has been deprecated and will be removed in Pimcore 11. Please use HeadlessChrome or PDFreactor instead.\n- [Config] `Pimcore\\Config\\Config` has been deprecated and will be removed in Pimcore 11.\n- The recommended nginx config for static pages has been updated (the old one still works!) from\n  ```nginx\n  server {\n      ...\n\n      location @staticpage{\n          try_files /var/tmp/pages$uri.html $uri /index.php$is_args$args;\n      }\n\n      location / {\n          error_page 404 /meta/404;\n          error_page 418 = @staticpage;\n          if ($args ~* ^(?!pimcore_editmode=true|pimcore_preview|pimcore_version)(.*)$){\n              return 418;\n          }\n          try_files $uri /index.php$is_args$args;\n      }\n\n      ...\n  }\n  ```\n  to\n  ```nginx\n  map $args $static_page_root {\n      default                                 /var/tmp/pages;\n      \"~*(^|&)pimcore_editmode=true(&|$)\"     /var/nonexistent;\n      \"~*(^|&)pimcore_preview=true(&|$)\"      /var/nonexistent;\n      \"~*(^|&)pimcore_version=[^&]+(&|$)\"     /var/nonexistent;\n  }\n\n  server {\n      ... \n\n      location / {\n          error_page 404 /meta/404;\n          try_files $static_page_root$uri.html $uri /index.php$is_args$args;\n      }\n\n      ...\n  }\n  ```\n- [Elements] Deprecated setting the parent id to 1 (root node), when an element with a non-existing parent id gets created.\n- [Custom Layouts] Deprecated Class `ClassLayoutDefinitionManager` and constant `PIMCORE_CUSTOMLAYOUT_DIRECTORY`.\n- [Workflows] Deprecated classes Pimcore\\Model\\Workflow, Pimcore\\Model\\Workflow\\Dao, Pimcore\\Model\\Workflow\\Listing\\Dao and Pimcore\\Model\\Workflow\\Listing. \nPlease check the documentation on how to work with workflows: [Workflow Management](../../07_Workflow_Management/README.md).\n- [Maintenance] Deprecated passing `--force` option to maintenance command.\n- [Exception] `MissingDependencyException` has been deprecated and will be removed in Pimcore 11.\n\n## 10.4.2\n- When maintenance mode is active, all commands are prevented from starting (not just commands inheriting from `AbstractCommand`).\n  Until now, some commands (e.g. `messenger:consume`) could be executed even if the system was in maintenance mode.\n  To circumvent, use `--ignore-maintenance-mode` option, which is available to all commands.\n\n## 10.4.0\n- **Important**: The folder structure for storing thumbnails changed, please run `bin/console pimcore:migrate:thumbnails-folder-structure` after the update to copy existing thumbnails to new folder structure. If you're dealing with a huge amount of thumbnails you should consider that this change might increase the load on your system as well as page-loading times during the migration command is executed, as non-existing thumbnails are then generated on demand. \n- [Image Optimizer] Optimize Image messages are now routed to different queue\n  instead of `pimcore_core`. If you want to handle image optimize messages, then it is required to add specific option `pimcore_image_optimize` to the command `bin/console messenger:consume pimcore_core pimcore_maintenance pimcore_image_optimize`. Also run command `bin/console messenger:consume pimcore_core` before the upgrade, so that ImageOptimize messages on the queue gets consumed.\n- **Important**: [Object bricks] A call to the object brick\u00b4s getter method no longer returns object bricks marked for deletion. \n  To restore the original behavior pass \"true\" to the getter method\u00b4s `$includeDeletedBricks` argument. \n- [Image Optimizer] Image Optimizer services (e.g. PngCrushOptimizer, JpegoptimOptimizer etc.) are deprecated and will be\n  removed in Pimcore 11. Use Pimcore\\Image\\Optimizer\\SpatieImageOptimizer service instead.\n  Currently, the existing optimizers are disabled. If you still want to use them, please re-enable them by tagging the services accordingly (in your `services.yaml`):\n```yaml\n    Pimcore\\Image\\Optimizer\\CjpegOptimizer:\n        tags:\n            - { name: pimcore.image.optimizer }\n\n    Pimcore\\Image\\Optimizer\\JpegoptimOptimizer:\n        tags:\n            - { name: pimcore.image.optimizer }\n\n    Pimcore\\Image\\Optimizer\\PngCrushOptimizer:\n        tags:\n            - { name: pimcore.image.optimizer }\n```\n\n- [Elements] Fixed the behavior of `setId()` method, so not to cast null Id to 0 as explained below:\n```php\n$object = new \\Pimcore\\Model\\DataObject();\n$object->setId(null);\n\n//before:\n$oldId = $object->getId(); //returns 0\n\n//after:\n$newId = $object->getId(); //returns null\n```\n- [Asset] Deprectaed the `marshal()/unmarshal()` methods for metadata, use `normalize()/denormalize()` methods instead.\n\n## 10.3.0\n- **Important**: [Symfony Messenger] Pimcore Core & Maintenance messages are now routed to different queues instead of default. It is\n  required to run command `bin/console messenger:consume pimcore_core pimcore_maintenance` before the upgrade, so that\n  the messages on default queue gets consumed.\n- **Important**: In preparation of upgrade to Symfony 6, return types must be added to methods which are extended from Symfony. In Pimcore, following changes are applied:\n    - Return type added to safe methods, which are `final` & marked as `internal`.\n    - Return type hints are added as comments on the methods which are extendable and phpdocs are updated. These return types will be introduced in Pimcore 11. You must add return types, if you're extending any of these Pimcore classes. Please check changes [here](https://github.com/pimcore/pimcore/pull/10846/files)\n- [Documents] Introduced additional interfaces for editable methods `getDataEditmode()`, `rewriteIds()` & `load()`. Existing `method_exists` calls are deprecated and will be removed in Pimcore 11.\n- [Data objects] Default values now get saved to versions -> Restoring a version also restores the default values (before those fields were null after restoring)\n- Method `create()` from `Pimcore\\Model\\DataObject\\Classificationstore\\CollectionGroupRelation` and `Pimcore\\Model\\DataObject\\Classificationstore\\KeyGroupRelation` no longer saves the new object, but just returns the instance. Related changes can be found here: https://github.com/pimcore/pimcore/pull/11326/files \n- Method `Kernel::getRootDir()` is deprecated, use `Kernel::getProjectDir()` instead. For more details, please check [10923](https://github.com/pimcore/pimcore/pull/10923).\n\n## 10.2.0\n- [Maintenance] Maintenance tasks are now handled with Symfony Messenger. The `pimcore:maintenance` command will add the maintenance messages to the bus and runs them afterwards immediately from the queue. However it's recommended to setup independent workers that process the queues, by running `bin/console messenger:consume pimcore_core pimcore_maintenance` (using e.g. Supervisor) and adding `--async` option to the `pimcore:maintenance` command that stops the maintenance command to process the queue directly. Details about setting it up for production environments, please check [Symfony Messenger Component docs](https://symfony.com/doc/current/messenger.html#deploying-to-production).\n- [Maintenance] Image Optimizer maintenance task moved to Messages which are consumed by Symfony Messenger. If you want to disable the image optimization, please add config to avoid dispatching the messages on messenger bus:\n```yaml\npimcore:\n    assets:\n        image:\n            thumbnails:\n                image_optimizers:\n                    enabled: false\n```\n- [Configs] The default storage for configurations is now `yaml` files in the `var/config` directory and are loaded as Symfony Config. The old `php` config-files continue to work, however, changes on existing configurations as well as new configurations are written to `yaml`.  \n**Important notice**: writing configs to `yaml` is only supported if the kernel is in debug mode, because changes of the config need a rebuild of the container configuration.  \nIf you require to change the config on production environments we recommend to change the storage to `settings-store` as described [here](../../21_Deployment/03_Configuration_Environments.md). \n- [Asset] Pimcore now automatically supports AVIF image format for thumbnails using `auto` format (only `Imagick`). To disable AVIF please [follow this instructions](../../04_Assets/03_Working_with_Thumbnails/01_Image_Thumbnails.md).  \n- [DataObject API] There is change in behavior when validating the inherited dataobjects & variants. As before, the inherited object gets saved with invalid attribute value, if the parent object has a valid value for the same attribute. Now, the API will throw validation exception, if the inherited object has an invalid value. please see https://github.com/pimcore/pimcore/pull/10529 \n\n## 10.1.0\n- [Core] Additional interfaces for data-types introduced. Existing `method_exists` calls are deprecated and will\n  be removed in Pimcore 11.\n- [InstallBundle] Installer preconfiguration path changed from `app/config/installer.yml` to `config/installer.yaml`.\n- [Core] composer.json: `symfony/symfony` package requirement has been replaced by `symfony/*` individual bundles. **Note for Bundles**: if you are using `symfony/symfony` dependency, it will now conflict with package `pimcore/pimcore`. Please move your bundle requirements to Symfony individual component packages.\n- [[Ecommerce][TrackingManager] event name in method `trackCheckoutComplete()` changed from `checkout` to `purchase` for `GoogleTagManager` implementation](https://github.com/pimcore/pimcore/pull/9366/files).\n- [Glossary] `pimcoreglossary()` tag has been deprecated in favor of `pimcore_glossary` Twig filter and will be removed in Pimcore 11.\n- Bumped `google/apiclient` to 2.10 version - Use proper namespaces for API references.\n- Bumped `endroid/qr-code` to version 4.\n- The `\\Pimcore\\Routing\\Dynamic\\DocumentRouteHandler::addDirectRouteDocumentType()` method is deprecated, use `pimcore.routing.direct_route_document_types` config instead.\n- [[Ecommerce][TrackingManager] event name in method `trackCheckoutComplete()` changed from `checkout` to `purchase` for `GoogleTagManager` implementation](https://github.com/pimcore/pimcore/pull/9366/files)\n- [Password encoding] Pimcore Password Encoder factory has been deprecated in favor of new Password Hasher factory, to align with Symfony authentication system. The default factory is used as default and to switch to new Password hasher factory, please enable through config `factory_type` as follows:\n```yaml\npimcore:\n    security:\n        factory_type: password_hasher\n\n        # the password hasher factory as defined in services.yml\n        password_hasher_factories:\n            App\\Model\\DataObject\\User: website_demo.security.password_hasher_factory\n```\nand use new service handler:\n```yaml\nservices:\n    website_demo.security.password_hasher_factory:\n        class: Pimcore\\Security\\Hasher\\Factory\\UserAwarePasswordHasherFactory\n        arguments:\n            - Pimcore\\Security\\Hasher\\PasswordFieldHasher\n            - ['password']\n```\n- [Session] Default setting for `framework.session.cookie_samesite` changed to `strict`. \n  For more information about the possible impact on your project, please have a look at the [docs of set-cookie](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite). \n  If you prefer to stay on the old session cookie behavior, please add the following to your project configuration: \n```yaml\nframework:\n    session:\n        cookie_samesite: 'lax'\n```  \n\n## 10.0.0\n\n### System Requirements\n     - PHP >= 8.0\n     - Apache >= 2.4\n\n### Database\n    - MariaDB >= 10.3\n    - MySQL >= 8.0\n    - Percona Server (supported versions see MySQL)\n### Changes\n- Bumped `symfony/symfony` to \"^5.2.0\". Pimcore X will only support Symfony 5.\n- ExtJS bumped to version 7.\n- Bumped:\n    - `guzzlehttp/guzzle` to \"^7.2\"\n    - `sensio/framework-extra-bundle` to \"^6.1\"\n    - `twig/twig` to \"^3.0\"\n    - `egulias/email-validator` to \"^3.0.0\"\n    - `onnov/detect-encoding` to \"^2.0\"\n    - `mjaschen/phpgeo` to \"^3.0\"\n    - `matomo/device-detector` to \"^4.0\"\n    - `ext-imagick` to \"^3.4.0\" (suggest)\n    - `lcobucci/jwt` to \"^4.0\"\n\n- `Pimcore\\Model\\DataObject\\ClassDefinition\\Data::isEqual()` has been removed. For custom data types, implement `\\Pimcore\\Model\\DataObject\\ClassDefinition\\Data\\EqualComparisonInterface` instead.\n- `Pimcore\\Model\\Document\\Editable`(former. `Tags`) properties visibility changed from `protected` to `private`.\n- [Templating]\n    - PHP templating engine (including templating helpers & vars) has been removed to support Symfony 5. Use Twig or Php Templating Engine Bundle(enterprise) instead.\n    - Removed ViewModel.\n    - Removed Auto view rendering.\n    - Removed Placeholder support. Use Twig Parameters instead.\n\n- `Pimcore\\Model\\Tool\\Tracking\\Event` has been removed.\n- `Pimcore\\Tool\\Archive` has been removed.\n- The object query table will now consider the fallback language. If you want to keep the old behavior set `pimcore.objects.ignore_localized_query_fallback` in your configuration.\n- Removed QR Codes.\n- Remove Linfo Integration.\n- [Ecommerce][IndexService] Removed FactFinder integration.\n- Removed `Pimcore\\Model\\Tool\\Lock`.\n- Removed HybridAuth integration.\n- Removed `Pimcore\\Model\\Document\\Tag\\*` classes. Use `Pimcore\\Model\\Document\\Editable\\*` classes instead.\n- Removed `pimcore_tag_` css classes, use `pimcore_editable_` css instead.\n- Removed REST Webservice API.\n- Removed Legacy [Service aliases](https://github.com/pimcore/pimcore/pull/7281/files).\n- [Document] Removed support for edit.php on Area-Bricks. Use new feature: Editable Dialog Box instead.\n- [Glossary] Removed support for `Acronym`. Use `Abbr` instead.\n- [Element] Added `setProperties()` and `setProperty()` methods to `Pimcore\\Model\\Element\\ElementInterface`.\n- [Element] `setProperty()` method param `$inheritable` defaults to false. Adding a new property will create a non-inheritable property for documents.\n- [Document] Removed Editable Naming Strategy Support.\n- Removed Cookie Policy Info Bar Integration.\n- Removed `\\Pimcore\\Browser` class. Use `\\Browser` instead.\n- Method signature `PageSnippet::setEditable(string $name, Editable $data)` has been changed to `PageSnippet::setEditable(Editable $editable)`.\n- Removed Tag & Snippet Management.\n- Removed `Pimcore\\Controller\\EventedControllerInterface`. Use `Pimcore\\Controller\\KernelControllerEventInterface` and `Pimcore\\Controller\\KernelResponseEventInterface` instead.\n- Doctrine dependencies bumped to latest major version:\n    - \"doctrine/common\": \"^3.0.0\"\n    - \"doctrine/inflector\": \"^2.0.0\"\n- Removed service `pimcore.implementation_loader.document.tag`. Use `Pimcore\\Model\\Document\\Editable\\Loader\\EditableLoader` instead.\n- Removed Pimcore Bundles generator and command `pimcore:generate:bundle`.\n- `Pimcore\\Controller\\Controller` abstract class now extends `Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController` instead of `Symfony\\Bundle\\FrameworkBundle\\Controller\\Controller`.\n- `Pimcore\\Translation\\Translator::transChoice()` & `Pimcore\\Bundle\\AdminBundle\\Translation\\AdminUserTranslator::transChoice()` methods have been removed. Use `trans()` method with `%count%` parameter.\n- Removed `pimcore.documents.create_redirect_when_moved` config. Please remove from System.yml.\n- Removed `pimcore.workflows.initial_place` config. Use `pimcore.workflows.initial_markings` instead.\n- `WebDebugToolbarListenerPass` has been removed and `WebDebugToolbarListener` has been marked as final & internal.\n- Bumped `sabre/dav` to ^4.1.1\n- Removed `Pimcore\\Model\\Element\\Reference\\Placeholder` class.\n- Removed `pimcore.routing.defaults`. Use `pimcore.documents.default_controller` instead.\n- Removed `\\Pimcore\\Tool::getRoutingDefaults()`, `PageSnippet::$module|$action|get/setAction()|get/setModule()`, `DocType::$module|$action|get/setAction()|get/setModule()`, `Staticroute::$module|$action|get/setAction()|get/setModule()`.\n- Removed `\\Pimcore\\Tool::getValidCacheKey/()`, use `preg_replace('/[^a-zA-Z0-9]/', '_', $key)` instead.\n- Removed `\\Pimcore\\Tool::isValidPath/()`, use `\\Pimcore\\Model\\Element\\Service::isValidPath()` instead.\n- Deprecated `\\Pimcore\\Model\\Element\\Service::getSaveCopyName()`, use `getSafeCopyName()` instead.\n- Deprecated methods `getObject()` and `setObject()` on the classes `\\Pimcore\\Model\\Document\\Link` and `\\Pimcore\\Model\\DataObject\\Data\\Link`, use `getElement()` and `setElement()` instead.\n- Using dynamic modules, controllers and actions in static routes (e.g. `%controller`) does not work anymore.\n- Removed `\\Pimcore\\Controller\\Config\\ConfigNormalizer`.\n- Removed `pimcore_action()` Twig extension. Use Twig `render()` instead.\n- Removed `\\Pimcore\\Console\\Log\\Formatter\\ConsoleColorFormatter`\n- Removed `\\Pimcore\\Console\\CliTrait`, use `php_sapi_name() === 'cli'` instead.\n- Removed `\\Pimcore\\Console\\Dumper`, use Symfony's `VarDumper` instead.\n- Removed `\\Pimcore\\Google\\Webmastertools`, use `\\Pimcore\\Config::getReportConfig()->get('webmastertools'')` instead.\n- Removed `\\Pimcore\\Helper\\JsonFormatter`, use `json_encode($data, JSON_PRETTY_PRINT)` instead.\n- Removed `\\Pimcore\\Log\\Handler\\Mail`, there's no replacement for this internal class.\n- Removed `\\Pimcore\\File::isIncludeable()` method, there's no replacement.\n- Removed `\\Pimcore\\DataObject\\GridColumnConfig\\AbstractConfigElement` just implement `\\Pimcore\\DataObject\\GridColumnConfig\\ConfigElementInterface` instead.\n- [Documents] Renderlet Editable: removed `action` & `bundle` config. Specify controller reference, e.g. `App\\Controller\\FooController::myAction`\n- Bumped `codeception/codeception` to \"^4.1.12\".\n- Pimcore Bundle Migrations: Extending the functionality of `DoctrineMigrationsBundle` is not any longer possible the way we did it in the past. Therefore we're switching to standard Doctrine migrations, this means also that migration sets are not supported anymore and that the available migrations have to be configured manually or by using flex.\n    ```yaml\n      doctrine_migrations:\n          migrations_paths:\n              'Pimcore\\Bundle\\DataHubBundle\\Migrations': '@PimcoreDataHubBundle/Migrations'\n              'CustomerManagementFrameworkBundle\\Migrations': '@PimcoreCustomerManagementFrameworkBundle/Migrations'\n    ```\n  However, we've extended the doctrine commands to accept an optional `--prefix` option, which let's you filter configured migration classes. This is in a way an adequate replacement for the `-s` (sets) option.\n\n  `./bin/console doctrine:migrations:list --prefix=Pimcore\\\\Bundle\\\\CoreBundle`\n\n- [Ecommerce] Added `setItems($items)` method `CartInterface`, `getRule()` to `ModificatedPriceInterface` & `getId()` method to `ProductInterface`.\n- [Data Objects] Relation Data-Types: throws exception if object without an ID was assigned. e.g.\n    ```php\n    $newObject = new MyDataObject();\n    $existingObject->setMyRelations([$newObject]);\n    $existingObject->save(); //validation error\n    ```\n- [Data Objects] ManyToMany Relation Types: throws exception if multiple assignments passed without enabling Multiple assignments on class definition.\n- [Data Objects] ReverseManyToManyObjectRelation - now supports reverse relations from ManyToOneRelation field and has been renamed to ReverseObjectRelation with BC layer.\n- [Data Object] Table Data-Type always return an array.\n- [Data Object] `Model::getById()` & `Model::getByPath()` do not catch exceptions anymore.\n- Added methods `getArgument($key)`, `setArgument($key, $value)`, `getArguments()`, `setArguments(array $args = [])`, `hasArgument($key)` to `Pimcore\\Model\\Element\\ElementInterface\\ElementEventInterface`.\n- [Ecommerce] Changed name of interfaces from I* to *Interface .e.g. `Pimcore\\Bundle\\EcommerceFrameworkBundle\\Model\\ICheckoutable` => `Pimcore\\Bundle\\EcommerceFrameworkBundle\\Model\\CheckoutableInterface`\n- Removed `cache/tag-interop`dependency.\n- [Cache] `Pimcore\\Cache` is directly based on Symfony/Cache. If you have custom cache pool configured under `pimcore.cache.pools` then change it to Symfony Config `framework.cache.pools`. [Read more](https://pimcore.com/docs/pimcore/master/Development_Documentation/Development_Tools_and_Details/Cache/index.html#page_Configuring-the-cache)\n- Methods `checkCsrfToken()`, `getCsrfToken()`, `regenerateCsrfToken()` methdos have been removed from `Pimcore\\Bundle\\AdminBundle\\EventListener\\CsrfProtectionListener`. Use `Pimcore\\Bundle\\AdminBundle\\Security\\CsrfProtectionHandler` instead.\n- Bumped `phpunit/phpunit` & `codeception/phpunit-wrapper` to \"^9\"\n- Replaced `html2text/html2text` with `soundasleep/html2text`. Removed methods from `Pimcore\\Mail`: `determineHtml2TextIsInstalled()`, `setHtml2TextOptions($options = [])`, `getHtml2TextBinaryEnabled()`, `enableHtml2textBinary()`, `getHtml2textInstalled()`.\n- Replaced `doctrine/common` with `doctrine/persistence`.\n- [Asset] Image thumbnails: Using getHtml() will return `<picture>` tag instead of `<img>` tag.\n- [Asset] Config option `pimcore.assets.image.thumbnails.webp_auto_support` was removed, since the browser detection is not needed anymore using the `<picture>` tags for thumbnails. \n- [Ecommerce] Marked `AbstractOrder` & `AbstractOrderItem` classes as abstract.\n    Changes on `AbstractOrder` class:\n    - Added: `getCartHash()`, `getComment()`, `setComment()`\n    - Removed: `getDeliveryEMail()`, `setDeliveryEMail()`, `getCartModificationTimestamp()`\n- [Data Objects] Data-Types: Removed getPhpdocType() BC layer\n- [Ecommerce][FilterService] Added method `getFilterValues()` to `Pimcore\\Bundle\\EcommerceFrameworkBundle\\FilterService\\FilterType\\AbstractFilterType`\n- [Data Objects] OwnerAwareFieldInterface: added methods `_setOwner($owner)`, `_setOwnerFieldname(?string $fieldname)`, `_setOwnerLanguage(?string $language)`, `_getOwner()`, `_getOwnerFieldname()`, _getOwnerLanguage() and removed method `setOwner($owner, string $fieldname, $language = null)`.\n- [Translations] Remove `pimcore.translations.case_insensitive` support.\n- [Core] Folder structure updated to support Symfony Flex. Changes as per [Symfony Docs](https://symfony.com/doc/5.2/setup/flex.html)\n- [Translations] `Pimcore\\Model\\Translation\\AbstractTranslation`, `Pimcore\\Model\\Translation\\Admin` and `Pimcore\\Model\\Translation\\Website` with corresponding listing classes have been removed. Use new class `Pimcore\\Model\\Translation` with domain support (`Translation::DOMAIN_DEFAULT` or `Translation::DOMAIN_ADMIN`).\n- Replaced `scheb/two-factor-bundle` with `scheb/2fa-bundle`, `scheb/2fa-google-authenticator` & `scheb/2fa-qr-code`.\n- Removed Laminas Packages.\n- Removed Zend Compatibility Query Builder.\n- [Ecommerce] Payment Providers: Removed `WirecardSeamless`, `Qpay`, `Paypal` integration and moved to a separate bundle:\n    - `Datatrans` => https://github.com/pimcore/payment-provider-datatrans\n    - `Heidelpay` => https://github.com/pimcore/payment-provider-unzer\n    - `Hobex` => https://github.com/pimcore/payment-provider-hobex\n    - `Klarna` => https://github.com/pimcore/payment-provider-klarna\n    - `Mpay24Seamless` => https://github.com/pimcore/payment-provider-mpay24-seamless\n    - `OGone` => https://github.com/pimcore/payment-provider-ogone\n    - `PayPalSmartPaymentButton` => https://github.com/pimcore/payment-provider-paypal-smart-payment-button\n    - `PayU` => https://github.com/pimcore/payment-provider-payu\n\n- [Core] Security configurations not merged anymore from custom bundles.\n- `twig/extensions` dependency has been removed.\n- Removed legacy transliterator (changes related to `\\Pimcore\\Tool\\Transliteration::_transliterationProcess`).\n- Config: Invalid pimcore configurations will result in compile error:\n    ```yaml\n      pimcore:\n         xyz:\n            xyz:\n    ```\n- [Data Objects] Removed `getFromCsvImport()` method from data-types.\n- Replaced `Ramsey/Uuid` with `Symfony/Uuid`.\n- Matomo Integration has been removed.\n- `Pimcore\\Tool\\Console::exec()` method has been removed. Use Symfony\\Component\\Process\\Process instead.\n- `\\Pimcore\\Tool\\Console::getOptions()` method has been removed.\n- `\\Pimcore\\Tool\\Console::getOptionString()` method has been removed.\n- `\\Pimcore\\Tool\\Console::checkCliExecution()` method has been removed.\n- `Pimcore\\Twig\\Extension\\Templating\\Navigation::buildNavigation()` method has been removed.\n- `Pimcore\\Tool\\Mime` class has been removed. Use `Symfony\\Component\\Mime\\MimeTypes` instead.\n- [Documents] Areabricks: location changed from `Areas` to `areas` with BC layer.\n- [Documents] Areablocks: Adding a brick to areablocks will not trigger reload by default anymore and should be configured per Brick.\n- SQIP support has been removed.\n- `Thumbnail::getHtml()` doesn't accept direct pass of HTML attributes such as `class` or `title` anymore, use `imageAttributes` or `pictureAttributes` instead.\n- Removed methods `getForcePictureTag()` and `setForcePictureTag()` from `\\Pimcore\\Model\\Asset\\Image\\Thumbnail\\Config`\n- `\\Pimcore\\Model\\Document\\Editable\\Block\\AbstractBlockItem::getElement()` has been removed, use `getEditable()` instead.\n- `\\Pimcore\\Model\\DataObject\\Service::removeObjectFromSession()` has been removed, use `removeElementFromSession()` instead.\n- `\\Pimcore\\Model\\DataObject\\Service::getObjectFromSession()` has been removed, use `getElementFromSession()` instead.\n- `\\Pimcore\\Model\\Asset\\Image\\Thumbnail\\Config::setColorspace()` has been removed\n- `\\Pimcore\\Model\\Asset\\Image\\Thumbnail\\Config::getColorspace()` has been removed\n- `\\Pimcore\\Model\\DataObject\\ClassDefinition\\Data\\DataInterface` has been removed\n- `\\Pimcore\\Model\\Asset\\Listing::getPaginatorAdapter` has been removed, use `knplabs/knp-paginator-bundle` instead.\n- `\\Pimcore\\Model\\Document\\Listing::getPaginatorAdapter` has been removed, use `knplabs/knp-paginator-bundle` instead.\n- `\\Pimcore\\Model\\DataObject\\Listing::getPaginatorAdapter` has been removed, use `knplabs/knp-paginator-bundle` instead.\n- `\\Pimcore\\Google\\Cse::getPaginatorAdapter` has been removed, use `knplabs/knp-paginator-bundle` instead.\n- `\\Pimcore\\Helper\\RobotsTxt` has been removed\n- `\\Pimcore\\Tool\\Frontend::getSiteKey()` method has been removed.\n- `\\Pimcore\\Model\\User::getUsername()` has been removed, use `User::getName()` instead.\n- `\\Pimcore\\Cache\\Runtime::get('pimcore_editmode')` isn't supported anymore, use `EditmodeResolver` service instead.\n- [Documents] `Editable::factory()` was removed, use `EditableLoader` service instead.\n- [Data Objects] Removed CSV import feature. Use https://github.com/pimcore/data-importer or https://github.com/w-vision/DataDefinitions instead.\n- [DataObjects] marked `Pimcore\\DataObject\\GridColumnConfig\\Operator` operator classes as final and internal\n- [DataObjects] Calculator classes of Calculated Values must implement the `Pimcore\\Model\\DataObject\\ClassDefinition\\CalculatorClassInterface` now.\n- [DataObjects] PHP Class `Pimcore\\Model\\DataObject\\Data\\Geopoint` has been replaced with `GeoCoordinates`. Changed the signature of `__construct`.\n- Added `Pimcore\\Bundle\\EcommerceFrameworkBundle\\FilterService\\FilterType\\AbstractFilterType::getFilterValues()` with the same signature as `getFilterFrontend()`. To upgrade, rename `getFilterFrontend()` to `getFilterValues()` and remove the rendering stuff to just return the data array.\n\n    Before:\n    ```php\n    public function getFilterFrontend(AbstractFilterDefinitionType $filterDefinition, ProductListInterface $productList, $currentFilter)\n    {\n        // ...\n        return $this->render($this->getTemplate($filterDefinition), [\n            //...\n        ]);\n    }\n    ```\n    After:\n    ```php\n    public function getFilterValues(AbstractFilterDefinitionType $filterDefinition, ProductListInterface $productList, array $currentFilter): array\n    {\n        // ...\n        return [\n            //...\n        ];\n    }\n    ```\n- Added Validation for Geo datatypes\n    - for Geopolyline and Geopolygon invalid data doesn't get serialized 1:1 anymore\n    - for Geobounds and Geopoint invalid data doesn't get dropped silently anymore\n- Calling `$imageAsset->getThumbnail('non-existing-thumbnail-definition)` with a non-existing thumbnail definition will now throw an exception. Same goes for video assets and video image thumbnails.\n- Removed grid column operator `ObjectBrickGetter` since it is obsolete\n- Grid operator `AnyGetter` available only for admin users from now on\n- [Ecommerce] Added `getAttributeConfig` method to `Pimcore\\Bundle\\EcommerceFrameworkBundle\\IndexService\\Config\\ConfigInterface` interface\n- [Ecommerce] Added `getClientConfig` method to `Pimcore\\Bundle\\EcommerceFrameworkBundle\\IndexService\\Config\\ElasticSearchConfigInterface`\n- [Ecommerce] Added abstract method `setSuccessorOrder` to `Pimcore\\Bundle\\EcommerceFrameworkBundle\\Model\\AbstractOrder`\n- [Ecommerce] Indexing doesn't catch any exceptions that occur during preprocessing of attributes in BatchProcessing workers (e.g. elasticsearch).\n  You can change that behavior with event listeners.\n- [Ecommerce] Added abstract method `setCartHash` to `Pimcore\\Bundle\\EcommerceFrameworkBundle\\Model\\AbstractOrder`\n- [Ecommerce] Added `getFieldNameMapped` to ` Pimcore\\Bundle\\EcommerceFrameworkBundle\\IndexService\\Config\\ElasticSearchConfigInterface`\n- [Ecommerce] Added `getReverseMappedFieldName` to ` Pimcore\\Bundle\\EcommerceFrameworkBundle\\IndexService\\Config\\ElasticSearchConfigInterface`\n- [Ecommerce] Changed tenant config type hint to `FindologicConfigInterface` in `Pimcore\\Bundle\\EcommerceFrameworkBundle\\IndexService\\ProductList\\DefaultFindologic::__construct`\n- [Ecommerce] Changed price fields `totalNetPrice` and `totalPrice` of `OnlineShopOrderItem` to decimal.\n- [Ecommerce] Removed deprecated configuration options `enabled`, `pricing_manager_id` and `pricing_manager_options` for pricing_manager.\n  Use tenant specific options.\n- [Ecommerce] Removed deprecated functions `get/setCurrentTenant` and `get/setCurrentSubTenant`\n  of `EnvironmentInterface`\n- [Ecommerce] Removed deprecated service alias for `Pimcore\\Bundle\\EcommerceFrameworkBundle\\IEnvironment`\n- [Ecommerce] Removed deprecated functions `getGeneralSearchColumns`, `createOrUpdateTable`, `getIndexColumns` and `getIndexColumnsByFilterGroup`\n  of `IndexService`\n- [Ecommerce] Removed deprecated function `getPaginatorAdapter` from\n  `ProductList\\MySql`, `ProductList\\DefaultFindologic`, `ProductList\\ElasticSearch\\AbstractElasticSearch`, `Token\\Listing` and `AbstractOrderList`\n- [Ecommerce] Removed deprecated functions `getCalculatedPrice` and `getCalculatedPriceInfo` from `AbstractSetProduct`\n- [Ecommerce] Removed deprecated protected function `getAvailableFilterValues` from `Order\\Listing`\n- [Ecommerce] Activated `generateTypeDeclarations` for all generated data object classes and field collections. For migration\n  activate `generateTypeDeclarations` to all Ecommerce Framework data object classes and update your source code accordingly.\n- [Ecommerce] Made methods abstract instead of throwing `UnsupportedException` where easily possible for model classes (`AbstractProduct`, `AbstractSetProduct`, `AbstractOfferToolProduct`, `AbstractOfferItem`, `AbstractOffer`).\n- [Ecommerce] Added type declarations to Ecommerce Framework product interfaces (`ProductInterface`, `IndexableInterface`, `CheckoutableInterface`).\n- [Ecommerce] Removed Elasticsearch 5 and 6 support\n- [Ecommerce] `getItemAmount` and `getItemCount` of `Carts` now require string parameter (instead of boolean). Use one of\n`CartInterface::COUNT_MAIN_ITEMS_ONLY`, `CartInterface::COUNT_MAIN_AND_SUB_ITEMS`, `CartInterface::COUNT_MAIN_OR_SUB_ITEMS`.\n- [Ecommerce] Removed legacy CheckoutManager architecture, migrate your project to V7 if not already\n  - `CancelPaymentOrRecreateOrderStrategy` is now default strategy for handling active payments\n  - Removed method `isCartReadOnly` from cart and `cart_readonly_mode` configuration option as readonly mode\n    does not exist anymore.\n  - Removed deprecated method `initPayment` from `PaymentInterface`\n- [Ecommerce] Removed deprecated `ecommerce:indexservice:process-queue` command,\n  use `ecommerce:indexservice:process-preparation-queue` or `ecommerce:indexservice:process-update-queue` instead\n- [Ecommerce] Removed deprecated `mapping` option in index attributes configuration (never worked properly anyway)\n- [Ecommerce] Removed deprecated `IndexUpdater` tool\n- [Ecommerce] Removed legacy BatchProcessing worker mode, product centric batch processing is now standard\n  - Removed abstract class `AbstractBatchProcessingWorker`, use `ProductCentricBatchProcessing` instead\n  - Removed methods from interface `BatchProcessingWorkerInterface` and its implementations:\n     - `BatchProcessingWorkerInterface::processPreparationQueue`\n     - `BatchProcessingWorkerInterface::processUpdateIndexQueue`\n  - Added methods to interface `BatchProcessingWorkerInterface`\n    - `BatchProcessingWorkerInterface::prepareDataForIndex`\n    - `BatchProcessingWorkerInterface::resetPreparationQueue`\n    - `BatchProcessingWorkerInterface::resetIndexingQueue`\n  - Removed constants\n     - `ProductCentricBatchProcessingWorker::WORKER_MODE_LEGACY`\n     - `ProductCentricBatchProcessingWorker::WORKER_MODE_PRODUCT_CENTRIC`\n  - Removed configuration node `worker_mode` in `index_service` configuration\n- [Ecommerce] Moved method `getIdColumnType` from `MysqlConfigInterface` to `ConfigInterface`. Since it was and still is\n  implemented in `AbstractConfig` this should not have any consequences.\n- [Ecommerce] Timestamp of CartItems is now in mirco seconds (existing data will be migrated).\n- [Ecommerce][PricingManager] Added two new interfaces `ProductActionInterface` and `CartActionInterface`. All actions\n  need to implement either of it - otherwise they will not be considered anymore in price calculation.\n- [Web2Print]\n   - Removed `PdfReactor8`, use `PdfReactor` instead.\n   - Removed PDFreactor version selection in web2print settings, since most current PDFreactor client lib\n     should be backwards compatible to older versions.\n- [Email & Newsletter] Swiftmailer has been replaced with Symfony Mailer. `\\Pimcore\\Mail` class now extends from `Symfony\\Component\\Mime\\Email` and new mailer service `Pimcore\\Mail\\Mailer` has been introduced, which decorates `Symfony\\Component\\Mailer\\Mailer`, for sending mails.\n\n    Email method and transport setting has been removed from System settings. Cleanup Swiftmailer config and setup mailer transports \"main\" & \"newsletter\" in config.yaml:\n    ```yaml\n    framework:\n        mailer:\n            transports:\n                main: smtp://user:pass@smtp.example.com:port\n                pimcore_newsletter: smtp://user:pass@smtp.example.com:port\n    ```\n    please see [Symfony Transport Setup](https://symfony.com/doc/5.2/mailer.html#transport-setup) for more information.\n\n    API changes:\n\n    Before:\n    ```php\n        $mail = new \\Pimcore\\Mail($subject = null, $body = null, $contentType = null, $charset = null);\n        $mail->setBodyText(\"This is just plain text\");\n        $mail->setBodyHtml(\"<b>some</b> rich text: {{ myParam }}\");\n        ...\n    ```\n    After:\n    ```php\n        $mail= new \\Pimcore\\Mail($headers = null, $body = null, $contentType = null);\n        $mail->text(\"This is just plain text\");\n        $mail->html(\"<b>some</b> rich text: {{ myParam }}\");\n        ...\n    ```\n\n    Before:\n    ```php\n      $mail->setFrom($emailAddress, $name);\n      $mail->setTo($emailAddress, $name);\n      ...\n    ```\n\n    After:\n    ```php\n      $mail->from(new \\Symfony\\Component\\Mime\\Address($emailAddress, $name));\n      $mail->to(new \\Symfony\\Component\\Mime\\Address($emailAddress, $name));\n      ...\n    ```\n- [Email & Newsletter] `\\Pimcore\\Mail::setEnableLayoutOnRendering/getEnableLayoutOnRendering()` methods have been removed, with Twig they are just not necessary anymore.\n- [Email & Newsletter] `\\Pimcore\\Mail::isValidEmailAddress()` method has been removed, use `EmailValidator` instead.\n- [Security] BruteforceProtectionHandler & BruteforceProtectionListener has been made final and marked as internal.\n- [JWTCookieSaveHandler] `Pimcore\\Targeting\\Storage\\Cookie\\JWT\\Decoder` has been removed in favor of `Lcobucci\\JWT\\Encoding\\JoseDecoder`.\n- `simple_html_dom` library has been removed. Use `Symfony\\Component\\DomCrawler\\Crawler` instead.\n- Removed deprecated Twig extension `pimcore_action()`.\n- Removed method `getFlag()` from `Pimcore\\Config`.\n- Removed `Pimcore\\Report` class.\n- [Versioning] Default behavior has been changed to following:\n    - Empty values for `steps` & `days` => unlimited versions.\n    - Value 0 for `steps` or `days` => no version will be saved at all & existing will be cleaned up.\n\n  please update your system settings as per the requirements.\n- Removed deprecated `marshal()` and `unmarshal()` methods from object data-types.\n- `DynamicTextLabelInterface::renderLayoutText()` must handle nullable object param.\n- [AdminBundle] Marked classes and controllers as @internal/final - please see all changes here: https://github.com/pimcore/pimcore/pull/8453/files & https://github.com/pimcore/pimcore/pull/8988/files\n"], "filenames": ["bundles/AdminBundle/Controller/Admin/Asset/AssetController.php", "bundles/AdminBundle/Resources/public/js/pimcore/asset/tree.js", "doc/Development_Documentation/23_Installation_and_Upgrade/09_Upgrade_Notes/README.md"], "buggy_code_start_loc": [2461, 597, 1], "buggy_code_end_loc": [2461, 598, 4], "fixing_code_start_loc": [2462, 597, 2], "fixing_code_end_loc": [2466, 598, 9], "type": "CWE-22", "message": "Path Traversal in GitHub repository pimcore/pimcore prior to 10.5.21.", "other": {"cve": {"id": "CVE-2023-2336", "sourceIdentifier": "security@huntr.dev", "published": "2023-04-27T12:15:09.173", "lastModified": "2023-05-04T20:03:07.463", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Path Traversal in GitHub repository pimcore/pimcore prior to 10.5.21."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:H/UI:N/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pimcore:pimcore:*:*:*:*:*:*:*:*", "versionEndExcluding": "10.5.21", "matchCriteriaId": "72C537D6-67BA-4562-B853-F99E6C14315C"}]}]}], "references": [{"url": "https://github.com/pimcore/pimcore/commit/498cadec2292f7842fb10612068ac78496e884b4", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/af764624-7746-4f53-8480-85348dbb4f14", "source": "security@huntr.dev", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/pimcore/pimcore/commit/498cadec2292f7842fb10612068ac78496e884b4"}}