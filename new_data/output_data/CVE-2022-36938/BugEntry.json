{"buggy_code": ["/*\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include \"DexLoader.h\"\n\n#include \"AggregateException.h\"\n#include \"DexAccess.h\"\n#include \"DexCallSite.h\"\n#include \"DexDefs.h\"\n#include \"DexMethodHandle.h\"\n#include \"IRCode.h\"\n#include \"Macros.h\"\n#include \"Show.h\"\n#include \"Trace.h\"\n#include \"Walkers.h\"\n#include \"WorkQueue.h\"\n\n#include <exception>\n#include <stdexcept>\n#include <vector>\n\nDexLoader::DexLoader(const DexLocation* location)\n    : m_idx(nullptr),\n      m_file(new boost::iostreams::mapped_file()),\n      m_location(location) {}\n\nstatic void validate_dex_header(const dex_header* dh,\n                                size_t dexsize,\n                                int support_dex_version) {\n  bool supported = false;\n  switch (support_dex_version) {\n  case 38:\n    supported = supported ||\n                !memcmp(dh->magic, DEX_HEADER_DEXMAGIC_V38, sizeof(dh->magic));\n    FALLTHROUGH_INTENDED; /* intentional fallthrough to also check for v37 */\n  case 37:\n    supported = supported ||\n                !memcmp(dh->magic, DEX_HEADER_DEXMAGIC_V37, sizeof(dh->magic));\n    FALLTHROUGH_INTENDED; /* intentional fallthrough to also check for v35 */\n  case 35:\n    supported = supported ||\n                !memcmp(dh->magic, DEX_HEADER_DEXMAGIC_V35, sizeof(dh->magic));\n    break;\n  default:\n    not_reached_log(\"Unrecognized support_dex_version %d\\n\",\n                    support_dex_version);\n  }\n  always_assert_log(supported, \"Bad dex magic %s for support_dex_version %d\\n\",\n                    dh->magic, support_dex_version);\n  always_assert_log(\n      dh->file_size == dexsize,\n      \"Reported size in header (%zu) does not match file size (%u)\\n\",\n      dexsize,\n      dh->file_size);\n  auto off = (uint64_t)dh->class_defs_off;\n  auto limit = off + dh->class_defs_size * sizeof(dex_class_def);\n  always_assert_log(off < dexsize, \"class_defs_off out of range\");\n  always_assert_log(limit <= dexsize, \"invalid class_defs_size\");\n}\n\nvoid DexLoader::gather_input_stats(dex_stats_t* stats, const dex_header* dh) {\n  if (!stats) {\n    return;\n  }\n  stats->num_types += dh->type_ids_size;\n  stats->num_classes += dh->class_defs_size;\n  stats->num_method_refs += dh->method_ids_size;\n  stats->num_field_refs += dh->field_ids_size;\n  stats->num_strings += dh->string_ids_size;\n  stats->num_protos += dh->proto_ids_size;\n  stats->num_bytes += dh->file_size;\n  // T58562665: TODO - actually update states for callsites/methodhandles\n  stats->num_callsites += 0;\n  stats->num_methodhandles += 0;\n\n  std::unordered_set<DexEncodedValueArray, boost::hash<DexEncodedValueArray>>\n      enc_arrays;\n  std::set<DexTypeList*, dextypelists_comparator> type_lists;\n  std::unordered_set<uint32_t> anno_offsets;\n\n  for (uint32_t cidx = 0; cidx < dh->class_defs_size; ++cidx) {\n    auto* clz = m_classes->at(cidx);\n    if (clz == nullptr) {\n      // Skip nulls, they may have been introduced by benign duplicate classes\n      continue;\n    }\n    auto* class_def = &m_class_defs[cidx];\n    auto anno_off = class_def->annotations_off;\n    if (anno_off) {\n      const dex_annotations_directory_item* anno_dir =\n          (const dex_annotations_directory_item*)m_idx->get_uint_data(anno_off);\n      auto class_anno_off = anno_dir->class_annotations_off;\n      if (class_anno_off) {\n        const uint32_t* anno_data = m_idx->get_uint_data(class_anno_off);\n        uint32_t count = *anno_data++;\n        for (uint32_t aidx = 0; aidx < count; ++aidx) {\n          anno_offsets.insert(anno_data[aidx]);\n        }\n      }\n      const uint32_t* anno_data = (uint32_t*)(anno_dir + 1);\n      for (uint32_t fidx = 0; fidx < anno_dir->fields_size; ++fidx) {\n        anno_data++;\n        anno_offsets.insert(*anno_data++);\n      }\n      for (uint32_t midx = 0; midx < anno_dir->methods_size; ++midx) {\n        anno_data++;\n        anno_offsets.insert(*anno_data++);\n      }\n      for (uint32_t pidx = 0; pidx < anno_dir->parameters_size; ++pidx) {\n        anno_data++;\n        uint32_t xrefoff = *anno_data++;\n        if (xrefoff != 0) {\n          const uint32_t* annoxref = m_idx->get_uint_data(xrefoff);\n          uint32_t count = *annoxref++;\n          for (uint32_t j = 0; j < count; j++) {\n            uint32_t off = annoxref[j];\n            anno_offsets.insert(off);\n          }\n        }\n      }\n    }\n    auto* interfaces_type_list = clz->get_interfaces();\n    type_lists.insert(interfaces_type_list);\n    auto deva = clz->get_static_values();\n    if (deva) {\n      if (!enc_arrays.count(*deva)) {\n        enc_arrays.emplace(std::move(*deva));\n        stats->num_static_values++;\n      }\n    }\n    stats->num_fields += clz->get_ifields().size() + clz->get_sfields().size();\n    stats->num_methods +=\n        clz->get_vmethods().size() + clz->get_dmethods().size();\n    for (auto* meth : clz->get_vmethods()) {\n      DexCode* code = meth->get_dex_code();\n      if (code) {\n        stats->num_instructions += code->get_instructions().size();\n      }\n    }\n    for (auto* meth : clz->get_dmethods()) {\n      DexCode* code = meth->get_dex_code();\n      if (code) {\n        stats->num_instructions += code->get_instructions().size();\n      }\n    }\n  }\n  for (uint32_t meth_idx = 0; meth_idx < dh->method_ids_size; ++meth_idx) {\n    auto* meth = m_idx->get_methodidx(meth_idx);\n    DexProto* proto = meth->get_proto();\n    type_lists.insert(proto->get_args());\n  }\n  stats->num_annotations += anno_offsets.size();\n  stats->num_type_lists += type_lists.size();\n\n  for (uint32_t sidx = 0; sidx < dh->string_ids_size; ++sidx) {\n    auto str = m_idx->get_stringidx(sidx);\n    stats->strings_total_size += str->get_entry_size();\n  }\n\n  const dex_map_list* map_list =\n      reinterpret_cast<const dex_map_list*>(m_file->const_data() + dh->map_off);\n  bool header_seen = false;\n  uint32_t header_index = 0;\n  for (uint32_t i = 0; i < map_list->size; i++) {\n    const auto& item = map_list->items[i];\n\n    const uint8_t* encdata = m_idx->get_uleb_data(item.offset);\n    const uint8_t* initial_encdata = encdata;\n\n    switch (item.type) {\n    case TYPE_HEADER_ITEM:\n      always_assert_log(\n          !header_seen,\n          \"Expected header_item to be unique in the map_list, \"\n          \"but encountered one at index i=%u and another at index j=%u.\",\n          header_index,\n          i);\n      header_seen = true;\n      header_index = i;\n      always_assert_log(1 == item.size,\n                        \"Expected count of header_items in the map_list to be \"\n                        \"exactly 1, but got ct=%u.\",\n                        item.size);\n      stats->header_item_count += item.size;\n      stats->header_item_bytes += item.size * sizeof(dex_header);\n      break;\n    case TYPE_STRING_ID_ITEM:\n      stats->string_id_count += item.size;\n      stats->string_id_bytes += item.size * sizeof(dex_string_id);\n      break;\n    case TYPE_TYPE_ID_ITEM:\n      stats->type_id_count += item.size;\n      stats->type_id_bytes += item.size * sizeof(dex_type_id);\n      break;\n    case TYPE_PROTO_ID_ITEM:\n      stats->proto_id_count += item.size;\n      stats->proto_id_bytes += item.size * sizeof(dex_proto_id);\n      break;\n    case TYPE_FIELD_ID_ITEM:\n      stats->field_id_count += item.size;\n      stats->field_id_bytes += item.size * sizeof(dex_field_id);\n      break;\n    case TYPE_METHOD_ID_ITEM:\n      stats->method_id_count += item.size;\n      stats->method_id_bytes += item.size * sizeof(dex_method_id);\n      break;\n    case TYPE_CLASS_DEF_ITEM:\n      stats->class_def_count += item.size;\n      stats->class_def_bytes += item.size * sizeof(dex_class_def);\n      break;\n    case TYPE_CALL_SITE_ID_ITEM:\n      stats->call_site_id_count += item.size;\n      stats->call_site_id_bytes += item.size * sizeof(dex_callsite_id);\n      break;\n    case TYPE_METHOD_HANDLE_ITEM:\n      stats->method_handle_count += item.size;\n      stats->method_handle_bytes += item.size * sizeof(dex_methodhandle_id);\n      break;\n    case TYPE_MAP_LIST:\n      stats->map_list_count += item.size;\n      for (uint32_t j = 0; j < item.size; j++) {\n        encdata = align_ptr(encdata, 4);\n\n        uint32_t map_list_entries = *(uint32_t*)(encdata);\n        stats->map_list_bytes +=\n            sizeof(uint32_t) + map_list_entries * sizeof(dex_map_item);\n      }\n      break;\n    case TYPE_TYPE_LIST:\n      stats->type_list_count += item.size;\n      for (uint32_t j = 0; j < item.size; j++) {\n        encdata = align_ptr(encdata, 4);\n\n        uint32_t type_list_entries = *(uint32_t*)(encdata);\n        stats->type_list_bytes +=\n            sizeof(uint32_t) + type_list_entries * sizeof(dex_type_item);\n      }\n      break;\n    case TYPE_ANNOTATION_SET_REF_LIST:\n      stats->annotation_set_ref_list_count += item.size;\n      for (uint32_t j = 0; j < item.size; j++) {\n        encdata = align_ptr(encdata, 4);\n\n        uint32_t annotation_set_ref_list_entries = *(uint32_t*)(encdata);\n        stats->annotation_set_ref_list_bytes +=\n            sizeof(uint32_t) + annotation_set_ref_list_entries *\n                                   sizeof(dex_annotation_set_ref_item);\n      }\n      break;\n    case TYPE_ANNOTATION_SET_ITEM:\n      stats->annotation_set_count += item.size;\n      for (uint32_t j = 0; j < item.size; j++) {\n        encdata = align_ptr(encdata, 4);\n\n        uint32_t annotation_set_entries = *(uint32_t*)(encdata);\n        stats->annotation_set_bytes +=\n            sizeof(uint32_t) +\n            annotation_set_entries * sizeof(dex_annotation_off_item);\n      }\n      break;\n    case TYPE_CLASS_DATA_ITEM:\n      stats->class_data_count += item.size;\n\n      for (uint32_t j = 0; j < item.size; j++) {\n        // Read in field sizes.\n        uint32_t static_fields_size = read_uleb128(&encdata);\n        uint32_t instance_fields_size = read_uleb128(&encdata);\n        uint32_t direct_methods_size = read_uleb128(&encdata);\n        uint32_t virtual_methods_size = read_uleb128(&encdata);\n\n        for (uint32_t k = 0; k < static_fields_size + instance_fields_size;\n             ++k) {\n          // Read and skip all of the encoded_field data.\n          read_uleb128(&encdata);\n          read_uleb128(&encdata);\n        }\n\n        for (uint32_t k = 0; k < direct_methods_size + virtual_methods_size;\n             ++k) {\n          // Read and skip all of the encoded_method data.\n          read_uleb128(&encdata);\n          read_uleb128(&encdata);\n          read_uleb128(&encdata);\n        }\n      }\n\n      stats->class_data_bytes += encdata - initial_encdata;\n      break;\n    case TYPE_CODE_ITEM:\n      stats->code_count += item.size;\n\n      for (uint32_t j = 0; j < item.size; j++) {\n        encdata = align_ptr(encdata, 4);\n\n        dex_code_item* code_item = (dex_code_item*)encdata;\n\n        encdata += sizeof(dex_code_item);\n        encdata += code_item->insns_size * sizeof(uint16_t);\n\n        if (code_item->tries_size != 0 && code_item->insns_size % 2 == 1) {\n          encdata += sizeof(uint16_t);\n        }\n\n        encdata += code_item->tries_size * sizeof(dex_tries_item);\n\n        if (code_item->tries_size != 0) {\n          uint32_t catch_handler_list_size = read_uleb128(&encdata);\n          for (uint32_t k = 0; k < catch_handler_list_size; ++k) {\n            int32_t catch_handler_size = read_sleb128(&encdata);\n            uint32_t abs_size = (uint32_t)std::abs(catch_handler_size);\n            for (uint32_t l = 0; l < abs_size; ++l) {\n              // Read encoded_type_addr_pair.\n              read_uleb128(&encdata);\n              read_uleb128(&encdata);\n            }\n            // Read catch_all_addr\n            if (catch_handler_size <= 0) {\n              read_uleb128(&encdata);\n            }\n          }\n        }\n      }\n      stats->code_bytes += encdata - initial_encdata;\n      break;\n    case TYPE_STRING_DATA_ITEM:\n      stats->string_data_count += item.size;\n\n      for (uint32_t j = 0; j < item.size; j++) {\n        // Skip data that encodes the number of UTF-16 code units.\n        read_uleb128(&encdata);\n\n        // Read up to and including the NULL-terminating byte.\n        while (true) {\n          const uint8_t byte = *encdata;\n          encdata++;\n          if (byte == 0) break;\n        }\n      }\n\n      stats->string_data_bytes += encdata - initial_encdata;\n      break;\n    case TYPE_DEBUG_INFO_ITEM:\n      stats->num_dbg_items += item.size;\n      for (uint32_t j = 0; j < item.size; j++) {\n        // line_start\n        read_uleb128(&encdata);\n        // param_count\n        uint32_t param_count = read_uleb128(&encdata);\n        while (param_count--) {\n          // Each parameter is one uleb128p1\n          read_uleb128p1(&encdata);\n        }\n        bool running = true;\n        while (running) {\n          uint8_t opcode = *encdata++;\n          switch (opcode) {\n          case DBG_END_SEQUENCE:\n            running = false;\n            break;\n          case DBG_ADVANCE_PC:\n          case DBG_END_LOCAL:\n          case DBG_RESTART_LOCAL:\n            // each of these opcodes has one uleb128 arg:\n            // - addr_diff\n            // - register_num\n            // - register_num\n            read_uleb128(&encdata);\n            break;\n          case DBG_ADVANCE_LINE:\n            // line_diff\n            read_sleb128(&encdata);\n            break;\n          case DBG_START_LOCAL:\n            // register_num\n            read_uleb128(&encdata);\n            // name_idx\n            read_uleb128p1(&encdata);\n            // type_idx\n            read_uleb128p1(&encdata);\n            break;\n          case DBG_START_LOCAL_EXTENDED:\n            // register_num\n            read_uleb128(&encdata);\n            // name_idx\n            read_uleb128p1(&encdata);\n            // type_idx\n            read_uleb128p1(&encdata);\n            // sig_idx\n            read_uleb128p1(&encdata);\n            break;\n          case DBG_SET_FILE:\n            // name_idx\n            read_uleb128p1(&encdata);\n            break;\n          case DBG_SET_PROLOGUE_END:\n          case DBG_SET_EPILOGUE_BEGIN:\n            // These cases have no args\n            break;\n          default:\n            // These are special opcodes. We separate them out to the default\n            // case to show we're properly interpretting this program.\n            break;\n          }\n        }\n      }\n      stats->dbg_total_size += encdata - initial_encdata;\n      break;\n    case TYPE_ANNOTATION_ITEM:\n      // TBD!\n      break;\n    case TYPE_ENCODED_ARRAY_ITEM:\n      // TBD!\n      break;\n    case TYPE_ANNOTATIONS_DIR_ITEM:\n      stats->annotations_directory_count += item.size;\n\n      for (uint32_t j = 0; j < item.size; ++j) {\n        encdata = align_ptr(encdata, 4);\n        dex_annotations_directory_item* annotations_directory_item =\n            (dex_annotations_directory_item*)encdata;\n\n        encdata += sizeof(dex_annotations_directory_item);\n        encdata += sizeof(dex_field_annotation) *\n                   annotations_directory_item->fields_size;\n        encdata += sizeof(dex_method_annotation) *\n                   annotations_directory_item->methods_size;\n        encdata += sizeof(dex_parameter_annotation) *\n                   annotations_directory_item->parameters_size;\n      }\n\n      stats->annotations_directory_bytes += encdata - initial_encdata;\n      break;\n    case TYPE_HIDDENAPI_CLASS_DATA_ITEM:\n      // No stats gathered.\n      break;\n    default:\n      fprintf(\n          stderr,\n          \"warning: map_list item at index i=%u is of unknown type T=0x%04hX\\n\",\n          i,\n          item.type);\n    }\n  }\n}\n\nvoid DexLoader::load_dex_class(int num) {\n  const dex_class_def* cdef = m_class_defs + num;\n  DexClass* dc = DexClass::create(m_idx.get(), cdef, m_location);\n  // We may be inserting a nullptr here. Need to remove them later\n  //\n  // We're inserting nullptr because we can't mess up the indices of the other\n  // classes in the vector. This vector is used via random access.\n  m_classes->at(num) = dc;\n}\n\nconst dex_header* DexLoader::get_dex_header(const char* file_name) {\n  m_file->open(file_name, boost::iostreams::mapped_file::readonly);\n  if (!m_file->is_open()) {\n    fprintf(stderr, \"error: cannot create memory-mapped file: %s\\n\", file_name);\n    exit(EXIT_FAILURE);\n  }\n  return reinterpret_cast<const dex_header*>(m_file->const_data());\n}\n\nDexClasses DexLoader::load_dex(const char* file_name,\n                               dex_stats_t* stats,\n                               int support_dex_version) {\n  const dex_header* dh = get_dex_header(file_name);\n  validate_dex_header(dh, m_file->size(), support_dex_version);\n  return load_dex(dh, stats);\n}\n\nDexClasses DexLoader::load_dex(const dex_header* dh, dex_stats_t* stats) {\n  if (dh->class_defs_size == 0) {\n    return DexClasses(0);\n  }\n  m_idx = std::make_unique<DexIdx>(dh);\n  auto off = (uint64_t)dh->class_defs_off;\n  m_class_defs =\n      reinterpret_cast<const dex_class_def*>((const uint8_t*)dh + off);\n  DexClasses classes(dh->class_defs_size);\n  m_classes = &classes;\n\n  {\n    auto num_threads = redex_parallel::default_num_threads();\n    std::vector<std::exception_ptr> all_exceptions;\n    std::mutex all_exceptions_mutex;\n    workqueue_run_for<size_t>(\n        0, dh->class_defs_size,\n        [&all_exceptions, &all_exceptions_mutex, this](uint32_t num) {\n          try {\n            load_dex_class(num);\n          } catch (const std::exception& exc) {\n            TRACE(MAIN, 1, \"Worker throw the exception:%s\", exc.what());\n            std::lock_guard<std::mutex> lock_guard(all_exceptions_mutex);\n            all_exceptions.emplace_back(std::current_exception());\n          }\n        },\n        num_threads);\n\n    if (!all_exceptions.empty()) {\n      // At least one of the workers raised an exception\n      aggregate_exception ae(all_exceptions);\n      throw ae;\n    }\n  }\n\n  gather_input_stats(stats, dh);\n\n  // Remove nulls from the classes list. They may have been introduced by benign\n  // duplicate classes.\n  classes.erase(std::remove(classes.begin(), classes.end(), nullptr),\n                classes.end());\n\n  return classes;\n}\n\nstatic void balloon_all(const Scope& scope, bool throw_on_error) {\n  ConcurrentMap<DexMethod*, std::string> ir_balloon_errors;\n  walk::parallel::methods(scope, [&](DexMethod* m) {\n    if (m->get_dex_code()) {\n      try {\n        m->balloon();\n      } catch (RedexException& re) {\n        ir_balloon_errors.emplace(m, re.what());\n      }\n    }\n  });\n\n  if (!ir_balloon_errors.empty()) {\n    std::ostringstream oss;\n    oss << \"Error lifting DexCode to IRCode for the following methods:\"\n        << std::endl;\n    for (const auto& [method, msg] : ir_balloon_errors) {\n      oss << show(method) << \": \" << msg << std::endl;\n    }\n\n    always_assert_log(!throw_on_error,\n                      \"%s\" /* format string must be a string literal */,\n                      oss.str().c_str());\n    TRACE(MAIN, 1, \"%s\" /* format string must be a string literal */,\n          oss.str().c_str());\n  }\n}\n\nDexClasses load_classes_from_dex(const DexLocation* location,\n                                 bool balloon,\n                                 bool throw_on_balloon_error,\n                                 int support_dex_version) {\n  dex_stats_t stats;\n  return load_classes_from_dex(location, &stats, balloon,\n                               throw_on_balloon_error, support_dex_version);\n}\n\nDexClasses load_classes_from_dex(const DexLocation* location,\n                                 dex_stats_t* stats,\n                                 bool balloon,\n                                 bool throw_on_balloon_error,\n                                 int support_dex_version) {\n  TRACE(MAIN, 1, \"Loading classes from dex from %s\",\n        location->get_file_name().c_str());\n  DexLoader dl(location);\n  auto classes = dl.load_dex(location->get_file_name().c_str(), stats,\n                             support_dex_version);\n  if (balloon) {\n    balloon_all(classes, throw_on_balloon_error);\n  }\n  return classes;\n}\n\nDexClasses load_classes_from_dex(const dex_header* dh,\n                                 const DexLocation* location,\n                                 bool balloon,\n                                 bool throw_on_balloon_error) {\n  DexLoader dl(location);\n  auto classes = dl.load_dex(dh, nullptr);\n  if (balloon) {\n    balloon_all(classes, throw_on_balloon_error);\n  }\n  return classes;\n}\n\nstd::string load_dex_magic_from_dex(const DexLocation* location) {\n  DexLoader dl(location);\n  auto dh = dl.get_dex_header(location->get_file_name().c_str());\n  return dh->magic;\n}\n\nvoid balloon_for_test(const Scope& scope) { balloon_all(scope, true); }\n"], "fixing_code": ["/*\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include \"DexLoader.h\"\n\n#include \"AggregateException.h\"\n#include \"DexAccess.h\"\n#include \"DexCallSite.h\"\n#include \"DexDefs.h\"\n#include \"DexMethodHandle.h\"\n#include \"IRCode.h\"\n#include \"Macros.h\"\n#include \"Show.h\"\n#include \"Trace.h\"\n#include \"Walkers.h\"\n#include \"WorkQueue.h\"\n\n#include <exception>\n#include <stdexcept>\n#include <vector>\n\nDexLoader::DexLoader(const DexLocation* location)\n    : m_idx(nullptr),\n      m_file(new boost::iostreams::mapped_file()),\n      m_location(location) {}\n\nstatic void validate_dex_header(const dex_header* dh,\n                                size_t dexsize,\n                                int support_dex_version) {\n  always_assert_log(sizeof(dex_header) <= dexsize,\n                    \"Header size (%lu) is larger than file size (%zu)\\n\",\n                    dexsize,\n                    sizeof(dex_header));\n  bool supported = false;\n  switch (support_dex_version) {\n  case 38:\n    supported = supported ||\n                !memcmp(dh->magic, DEX_HEADER_DEXMAGIC_V38, sizeof(dh->magic));\n    FALLTHROUGH_INTENDED; /* intentional fallthrough to also check for v37 */\n  case 37:\n    supported = supported ||\n                !memcmp(dh->magic, DEX_HEADER_DEXMAGIC_V37, sizeof(dh->magic));\n    FALLTHROUGH_INTENDED; /* intentional fallthrough to also check for v35 */\n  case 35:\n    supported = supported ||\n                !memcmp(dh->magic, DEX_HEADER_DEXMAGIC_V35, sizeof(dh->magic));\n    break;\n  default:\n    not_reached_log(\"Unrecognized support_dex_version %d\\n\",\n                    support_dex_version);\n  }\n  always_assert_log(supported, \"Bad dex magic %s for support_dex_version %d\\n\",\n                    dh->magic, support_dex_version);\n  always_assert_log(\n      dh->file_size == dexsize,\n      \"Reported size in header (%zu) does not match file size (%u)\\n\",\n      dexsize,\n      dh->file_size);\n\n  auto str_ids_off = (uint64_t)dh->string_ids_off;\n  auto str_ids_limit =\n      str_ids_off + dh->string_ids_size * sizeof(dex_string_id);\n  always_assert_log(str_ids_off < dexsize, \"string_ids_off out of range\");\n  always_assert_log(str_ids_limit <= dexsize, \"invalid string_ids_size\");\n\n  auto type_ids_off = (uint64_t)dh->type_ids_off;\n  auto type_ids_limit = type_ids_off + dh->type_ids_size * sizeof(dex_type_id);\n  always_assert_log(type_ids_off < dexsize, \"type_ids_off out of range\");\n  always_assert_log(type_ids_limit <= dexsize, \"invalid type_ids_size\");\n\n  auto proto_ids_off = (uint64_t)dh->proto_ids_off;\n  auto proto_ids_limit =\n      proto_ids_off + dh->proto_ids_size * sizeof(dex_proto_id);\n  always_assert_log(proto_ids_off < dexsize, \"proto_ids_off out of range\");\n  always_assert_log(proto_ids_limit <= dexsize, \"invalid proto_ids_size\");\n\n  auto field_ids_off = (uint64_t)dh->field_ids_off;\n  auto field_ids_limit =\n      field_ids_off + dh->field_ids_size * sizeof(dex_field_id);\n  always_assert_log(field_ids_off < dexsize, \"field_ids_off out of range\");\n  always_assert_log(field_ids_limit <= dexsize, \"invalid field_ids_size\");\n\n  auto meth_ids_off = (uint64_t)dh->method_ids_off;\n  auto meth_ids_limit =\n      meth_ids_off + dh->method_ids_size * sizeof(dex_method_id);\n  always_assert_log(meth_ids_off < dexsize, \"method_ids_off out of range\");\n  always_assert_log(meth_ids_limit <= dexsize, \"invalid method_ids_size\");\n\n  auto cls_defs_off = (uint64_t)dh->class_defs_off;\n  auto cls_defs_limit =\n      cls_defs_off + dh->class_defs_size * sizeof(dex_class_def);\n  always_assert_log(cls_defs_off < dexsize, \"class_defs_off out of range\");\n  always_assert_log(cls_defs_limit <= dexsize, \"invalid class_defs_size\");\n}\n\nvoid DexLoader::gather_input_stats(dex_stats_t* stats, const dex_header* dh) {\n  if (!stats) {\n    return;\n  }\n  stats->num_types += dh->type_ids_size;\n  stats->num_classes += dh->class_defs_size;\n  stats->num_method_refs += dh->method_ids_size;\n  stats->num_field_refs += dh->field_ids_size;\n  stats->num_strings += dh->string_ids_size;\n  stats->num_protos += dh->proto_ids_size;\n  stats->num_bytes += dh->file_size;\n  // T58562665: TODO - actually update states for callsites/methodhandles\n  stats->num_callsites += 0;\n  stats->num_methodhandles += 0;\n\n  std::unordered_set<DexEncodedValueArray, boost::hash<DexEncodedValueArray>>\n      enc_arrays;\n  std::set<DexTypeList*, dextypelists_comparator> type_lists;\n  std::unordered_set<uint32_t> anno_offsets;\n\n  for (uint32_t cidx = 0; cidx < dh->class_defs_size; ++cidx) {\n    auto* clz = m_classes->at(cidx);\n    if (clz == nullptr) {\n      // Skip nulls, they may have been introduced by benign duplicate classes\n      continue;\n    }\n    auto* class_def = &m_class_defs[cidx];\n    auto anno_off = class_def->annotations_off;\n    if (anno_off) {\n      const dex_annotations_directory_item* anno_dir =\n          (const dex_annotations_directory_item*)m_idx->get_uint_data(anno_off);\n      auto class_anno_off = anno_dir->class_annotations_off;\n      if (class_anno_off) {\n        const uint32_t* anno_data = m_idx->get_uint_data(class_anno_off);\n        uint32_t count = *anno_data++;\n        for (uint32_t aidx = 0; aidx < count; ++aidx) {\n          anno_offsets.insert(anno_data[aidx]);\n        }\n      }\n      const uint32_t* anno_data = (uint32_t*)(anno_dir + 1);\n      for (uint32_t fidx = 0; fidx < anno_dir->fields_size; ++fidx) {\n        anno_data++;\n        anno_offsets.insert(*anno_data++);\n      }\n      for (uint32_t midx = 0; midx < anno_dir->methods_size; ++midx) {\n        anno_data++;\n        anno_offsets.insert(*anno_data++);\n      }\n      for (uint32_t pidx = 0; pidx < anno_dir->parameters_size; ++pidx) {\n        anno_data++;\n        uint32_t xrefoff = *anno_data++;\n        if (xrefoff != 0) {\n          const uint32_t* annoxref = m_idx->get_uint_data(xrefoff);\n          uint32_t count = *annoxref++;\n          for (uint32_t j = 0; j < count; j++) {\n            uint32_t off = annoxref[j];\n            anno_offsets.insert(off);\n          }\n        }\n      }\n    }\n    auto* interfaces_type_list = clz->get_interfaces();\n    type_lists.insert(interfaces_type_list);\n    auto deva = clz->get_static_values();\n    if (deva) {\n      if (!enc_arrays.count(*deva)) {\n        enc_arrays.emplace(std::move(*deva));\n        stats->num_static_values++;\n      }\n    }\n    stats->num_fields += clz->get_ifields().size() + clz->get_sfields().size();\n    stats->num_methods +=\n        clz->get_vmethods().size() + clz->get_dmethods().size();\n    for (auto* meth : clz->get_vmethods()) {\n      DexCode* code = meth->get_dex_code();\n      if (code) {\n        stats->num_instructions += code->get_instructions().size();\n      }\n    }\n    for (auto* meth : clz->get_dmethods()) {\n      DexCode* code = meth->get_dex_code();\n      if (code) {\n        stats->num_instructions += code->get_instructions().size();\n      }\n    }\n  }\n  for (uint32_t meth_idx = 0; meth_idx < dh->method_ids_size; ++meth_idx) {\n    auto* meth = m_idx->get_methodidx(meth_idx);\n    DexProto* proto = meth->get_proto();\n    type_lists.insert(proto->get_args());\n  }\n  stats->num_annotations += anno_offsets.size();\n  stats->num_type_lists += type_lists.size();\n\n  for (uint32_t sidx = 0; sidx < dh->string_ids_size; ++sidx) {\n    auto str = m_idx->get_stringidx(sidx);\n    stats->strings_total_size += str->get_entry_size();\n  }\n\n  const dex_map_list* map_list =\n      reinterpret_cast<const dex_map_list*>(m_file->const_data() + dh->map_off);\n  bool header_seen = false;\n  uint32_t header_index = 0;\n  for (uint32_t i = 0; i < map_list->size; i++) {\n    const auto& item = map_list->items[i];\n\n    const uint8_t* encdata = m_idx->get_uleb_data(item.offset);\n    const uint8_t* initial_encdata = encdata;\n\n    switch (item.type) {\n    case TYPE_HEADER_ITEM:\n      always_assert_log(\n          !header_seen,\n          \"Expected header_item to be unique in the map_list, \"\n          \"but encountered one at index i=%u and another at index j=%u.\",\n          header_index,\n          i);\n      header_seen = true;\n      header_index = i;\n      always_assert_log(1 == item.size,\n                        \"Expected count of header_items in the map_list to be \"\n                        \"exactly 1, but got ct=%u.\",\n                        item.size);\n      stats->header_item_count += item.size;\n      stats->header_item_bytes += item.size * sizeof(dex_header);\n      break;\n    case TYPE_STRING_ID_ITEM:\n      stats->string_id_count += item.size;\n      stats->string_id_bytes += item.size * sizeof(dex_string_id);\n      break;\n    case TYPE_TYPE_ID_ITEM:\n      stats->type_id_count += item.size;\n      stats->type_id_bytes += item.size * sizeof(dex_type_id);\n      break;\n    case TYPE_PROTO_ID_ITEM:\n      stats->proto_id_count += item.size;\n      stats->proto_id_bytes += item.size * sizeof(dex_proto_id);\n      break;\n    case TYPE_FIELD_ID_ITEM:\n      stats->field_id_count += item.size;\n      stats->field_id_bytes += item.size * sizeof(dex_field_id);\n      break;\n    case TYPE_METHOD_ID_ITEM:\n      stats->method_id_count += item.size;\n      stats->method_id_bytes += item.size * sizeof(dex_method_id);\n      break;\n    case TYPE_CLASS_DEF_ITEM:\n      stats->class_def_count += item.size;\n      stats->class_def_bytes += item.size * sizeof(dex_class_def);\n      break;\n    case TYPE_CALL_SITE_ID_ITEM:\n      stats->call_site_id_count += item.size;\n      stats->call_site_id_bytes += item.size * sizeof(dex_callsite_id);\n      break;\n    case TYPE_METHOD_HANDLE_ITEM:\n      stats->method_handle_count += item.size;\n      stats->method_handle_bytes += item.size * sizeof(dex_methodhandle_id);\n      break;\n    case TYPE_MAP_LIST:\n      stats->map_list_count += item.size;\n      for (uint32_t j = 0; j < item.size; j++) {\n        encdata = align_ptr(encdata, 4);\n\n        uint32_t map_list_entries = *(uint32_t*)(encdata);\n        stats->map_list_bytes +=\n            sizeof(uint32_t) + map_list_entries * sizeof(dex_map_item);\n      }\n      break;\n    case TYPE_TYPE_LIST:\n      stats->type_list_count += item.size;\n      for (uint32_t j = 0; j < item.size; j++) {\n        encdata = align_ptr(encdata, 4);\n\n        uint32_t type_list_entries = *(uint32_t*)(encdata);\n        stats->type_list_bytes +=\n            sizeof(uint32_t) + type_list_entries * sizeof(dex_type_item);\n      }\n      break;\n    case TYPE_ANNOTATION_SET_REF_LIST:\n      stats->annotation_set_ref_list_count += item.size;\n      for (uint32_t j = 0; j < item.size; j++) {\n        encdata = align_ptr(encdata, 4);\n\n        uint32_t annotation_set_ref_list_entries = *(uint32_t*)(encdata);\n        stats->annotation_set_ref_list_bytes +=\n            sizeof(uint32_t) + annotation_set_ref_list_entries *\n                                   sizeof(dex_annotation_set_ref_item);\n      }\n      break;\n    case TYPE_ANNOTATION_SET_ITEM:\n      stats->annotation_set_count += item.size;\n      for (uint32_t j = 0; j < item.size; j++) {\n        encdata = align_ptr(encdata, 4);\n\n        uint32_t annotation_set_entries = *(uint32_t*)(encdata);\n        stats->annotation_set_bytes +=\n            sizeof(uint32_t) +\n            annotation_set_entries * sizeof(dex_annotation_off_item);\n      }\n      break;\n    case TYPE_CLASS_DATA_ITEM:\n      stats->class_data_count += item.size;\n\n      for (uint32_t j = 0; j < item.size; j++) {\n        // Read in field sizes.\n        uint32_t static_fields_size = read_uleb128(&encdata);\n        uint32_t instance_fields_size = read_uleb128(&encdata);\n        uint32_t direct_methods_size = read_uleb128(&encdata);\n        uint32_t virtual_methods_size = read_uleb128(&encdata);\n\n        for (uint32_t k = 0; k < static_fields_size + instance_fields_size;\n             ++k) {\n          // Read and skip all of the encoded_field data.\n          read_uleb128(&encdata);\n          read_uleb128(&encdata);\n        }\n\n        for (uint32_t k = 0; k < direct_methods_size + virtual_methods_size;\n             ++k) {\n          // Read and skip all of the encoded_method data.\n          read_uleb128(&encdata);\n          read_uleb128(&encdata);\n          read_uleb128(&encdata);\n        }\n      }\n\n      stats->class_data_bytes += encdata - initial_encdata;\n      break;\n    case TYPE_CODE_ITEM:\n      stats->code_count += item.size;\n\n      for (uint32_t j = 0; j < item.size; j++) {\n        encdata = align_ptr(encdata, 4);\n\n        dex_code_item* code_item = (dex_code_item*)encdata;\n\n        encdata += sizeof(dex_code_item);\n        encdata += code_item->insns_size * sizeof(uint16_t);\n\n        if (code_item->tries_size != 0 && code_item->insns_size % 2 == 1) {\n          encdata += sizeof(uint16_t);\n        }\n\n        encdata += code_item->tries_size * sizeof(dex_tries_item);\n\n        if (code_item->tries_size != 0) {\n          uint32_t catch_handler_list_size = read_uleb128(&encdata);\n          for (uint32_t k = 0; k < catch_handler_list_size; ++k) {\n            int32_t catch_handler_size = read_sleb128(&encdata);\n            uint32_t abs_size = (uint32_t)std::abs(catch_handler_size);\n            for (uint32_t l = 0; l < abs_size; ++l) {\n              // Read encoded_type_addr_pair.\n              read_uleb128(&encdata);\n              read_uleb128(&encdata);\n            }\n            // Read catch_all_addr\n            if (catch_handler_size <= 0) {\n              read_uleb128(&encdata);\n            }\n          }\n        }\n      }\n      stats->code_bytes += encdata - initial_encdata;\n      break;\n    case TYPE_STRING_DATA_ITEM:\n      stats->string_data_count += item.size;\n\n      for (uint32_t j = 0; j < item.size; j++) {\n        // Skip data that encodes the number of UTF-16 code units.\n        read_uleb128(&encdata);\n\n        // Read up to and including the NULL-terminating byte.\n        while (true) {\n          const uint8_t byte = *encdata;\n          encdata++;\n          if (byte == 0) break;\n        }\n      }\n\n      stats->string_data_bytes += encdata - initial_encdata;\n      break;\n    case TYPE_DEBUG_INFO_ITEM:\n      stats->num_dbg_items += item.size;\n      for (uint32_t j = 0; j < item.size; j++) {\n        // line_start\n        read_uleb128(&encdata);\n        // param_count\n        uint32_t param_count = read_uleb128(&encdata);\n        while (param_count--) {\n          // Each parameter is one uleb128p1\n          read_uleb128p1(&encdata);\n        }\n        bool running = true;\n        while (running) {\n          uint8_t opcode = *encdata++;\n          switch (opcode) {\n          case DBG_END_SEQUENCE:\n            running = false;\n            break;\n          case DBG_ADVANCE_PC:\n          case DBG_END_LOCAL:\n          case DBG_RESTART_LOCAL:\n            // each of these opcodes has one uleb128 arg:\n            // - addr_diff\n            // - register_num\n            // - register_num\n            read_uleb128(&encdata);\n            break;\n          case DBG_ADVANCE_LINE:\n            // line_diff\n            read_sleb128(&encdata);\n            break;\n          case DBG_START_LOCAL:\n            // register_num\n            read_uleb128(&encdata);\n            // name_idx\n            read_uleb128p1(&encdata);\n            // type_idx\n            read_uleb128p1(&encdata);\n            break;\n          case DBG_START_LOCAL_EXTENDED:\n            // register_num\n            read_uleb128(&encdata);\n            // name_idx\n            read_uleb128p1(&encdata);\n            // type_idx\n            read_uleb128p1(&encdata);\n            // sig_idx\n            read_uleb128p1(&encdata);\n            break;\n          case DBG_SET_FILE:\n            // name_idx\n            read_uleb128p1(&encdata);\n            break;\n          case DBG_SET_PROLOGUE_END:\n          case DBG_SET_EPILOGUE_BEGIN:\n            // These cases have no args\n            break;\n          default:\n            // These are special opcodes. We separate them out to the default\n            // case to show we're properly interpretting this program.\n            break;\n          }\n        }\n      }\n      stats->dbg_total_size += encdata - initial_encdata;\n      break;\n    case TYPE_ANNOTATION_ITEM:\n      // TBD!\n      break;\n    case TYPE_ENCODED_ARRAY_ITEM:\n      // TBD!\n      break;\n    case TYPE_ANNOTATIONS_DIR_ITEM:\n      stats->annotations_directory_count += item.size;\n\n      for (uint32_t j = 0; j < item.size; ++j) {\n        encdata = align_ptr(encdata, 4);\n        dex_annotations_directory_item* annotations_directory_item =\n            (dex_annotations_directory_item*)encdata;\n\n        encdata += sizeof(dex_annotations_directory_item);\n        encdata += sizeof(dex_field_annotation) *\n                   annotations_directory_item->fields_size;\n        encdata += sizeof(dex_method_annotation) *\n                   annotations_directory_item->methods_size;\n        encdata += sizeof(dex_parameter_annotation) *\n                   annotations_directory_item->parameters_size;\n      }\n\n      stats->annotations_directory_bytes += encdata - initial_encdata;\n      break;\n    case TYPE_HIDDENAPI_CLASS_DATA_ITEM:\n      // No stats gathered.\n      break;\n    default:\n      fprintf(\n          stderr,\n          \"warning: map_list item at index i=%u is of unknown type T=0x%04hX\\n\",\n          i,\n          item.type);\n    }\n  }\n}\n\nvoid DexLoader::load_dex_class(int num) {\n  const dex_class_def* cdef = m_class_defs + num;\n  DexClass* dc = DexClass::create(m_idx.get(), cdef, m_location);\n  // We may be inserting a nullptr here. Need to remove them later\n  //\n  // We're inserting nullptr because we can't mess up the indices of the other\n  // classes in the vector. This vector is used via random access.\n  m_classes->at(num) = dc;\n}\n\nconst dex_header* DexLoader::get_dex_header(const char* file_name) {\n  m_file->open(file_name, boost::iostreams::mapped_file::readonly);\n  if (!m_file->is_open()) {\n    fprintf(stderr, \"error: cannot create memory-mapped file: %s\\n\", file_name);\n    exit(EXIT_FAILURE);\n  }\n  return reinterpret_cast<const dex_header*>(m_file->const_data());\n}\n\nDexClasses DexLoader::load_dex(const char* file_name,\n                               dex_stats_t* stats,\n                               int support_dex_version) {\n  const dex_header* dh = get_dex_header(file_name);\n  validate_dex_header(dh, m_file->size(), support_dex_version);\n  return load_dex(dh, stats);\n}\n\nDexClasses DexLoader::load_dex(const dex_header* dh, dex_stats_t* stats) {\n  if (dh->class_defs_size == 0) {\n    return DexClasses(0);\n  }\n  m_idx = std::make_unique<DexIdx>(dh);\n  auto off = (uint64_t)dh->class_defs_off;\n  m_class_defs =\n      reinterpret_cast<const dex_class_def*>((const uint8_t*)dh + off);\n  DexClasses classes(dh->class_defs_size);\n  m_classes = &classes;\n\n  {\n    auto num_threads = redex_parallel::default_num_threads();\n    std::vector<std::exception_ptr> all_exceptions;\n    std::mutex all_exceptions_mutex;\n    workqueue_run_for<size_t>(\n        0, dh->class_defs_size,\n        [&all_exceptions, &all_exceptions_mutex, this](uint32_t num) {\n          try {\n            load_dex_class(num);\n          } catch (const std::exception& exc) {\n            TRACE(MAIN, 1, \"Worker throw the exception:%s\", exc.what());\n            std::lock_guard<std::mutex> lock_guard(all_exceptions_mutex);\n            all_exceptions.emplace_back(std::current_exception());\n          }\n        },\n        num_threads);\n\n    if (!all_exceptions.empty()) {\n      // At least one of the workers raised an exception\n      aggregate_exception ae(all_exceptions);\n      throw ae;\n    }\n  }\n\n  gather_input_stats(stats, dh);\n\n  // Remove nulls from the classes list. They may have been introduced by benign\n  // duplicate classes.\n  classes.erase(std::remove(classes.begin(), classes.end(), nullptr),\n                classes.end());\n\n  return classes;\n}\n\nstatic void balloon_all(const Scope& scope, bool throw_on_error) {\n  ConcurrentMap<DexMethod*, std::string> ir_balloon_errors;\n  walk::parallel::methods(scope, [&](DexMethod* m) {\n    if (m->get_dex_code()) {\n      try {\n        m->balloon();\n      } catch (RedexException& re) {\n        ir_balloon_errors.emplace(m, re.what());\n      }\n    }\n  });\n\n  if (!ir_balloon_errors.empty()) {\n    std::ostringstream oss;\n    oss << \"Error lifting DexCode to IRCode for the following methods:\"\n        << std::endl;\n    for (const auto& [method, msg] : ir_balloon_errors) {\n      oss << show(method) << \": \" << msg << std::endl;\n    }\n\n    always_assert_log(!throw_on_error,\n                      \"%s\" /* format string must be a string literal */,\n                      oss.str().c_str());\n    TRACE(MAIN, 1, \"%s\" /* format string must be a string literal */,\n          oss.str().c_str());\n  }\n}\n\nDexClasses load_classes_from_dex(const DexLocation* location,\n                                 bool balloon,\n                                 bool throw_on_balloon_error,\n                                 int support_dex_version) {\n  dex_stats_t stats;\n  return load_classes_from_dex(location, &stats, balloon,\n                               throw_on_balloon_error, support_dex_version);\n}\n\nDexClasses load_classes_from_dex(const DexLocation* location,\n                                 dex_stats_t* stats,\n                                 bool balloon,\n                                 bool throw_on_balloon_error,\n                                 int support_dex_version) {\n  TRACE(MAIN, 1, \"Loading classes from dex from %s\",\n        location->get_file_name().c_str());\n  DexLoader dl(location);\n  auto classes = dl.load_dex(location->get_file_name().c_str(), stats,\n                             support_dex_version);\n  if (balloon) {\n    balloon_all(classes, throw_on_balloon_error);\n  }\n  return classes;\n}\n\nDexClasses load_classes_from_dex(const dex_header* dh,\n                                 const DexLocation* location,\n                                 bool balloon,\n                                 bool throw_on_balloon_error) {\n  DexLoader dl(location);\n  auto classes = dl.load_dex(dh, nullptr);\n  if (balloon) {\n    balloon_all(classes, throw_on_balloon_error);\n  }\n  return classes;\n}\n\nstd::string load_dex_magic_from_dex(const DexLocation* location) {\n  DexLoader dl(location);\n  auto dh = dl.get_dex_header(location->get_file_name().c_str());\n  return dh->magic;\n}\n\nvoid balloon_for_test(const Scope& scope) { balloon_all(scope, true); }\n"], "filenames": ["libredex/DexLoader.cpp"], "buggy_code_start_loc": [33], "buggy_code_end_loc": [63], "fixing_code_start_loc": [34], "fixing_code_end_loc": [98], "type": "CWE-119", "message": "DexLoader function get_stringidx_fromdex() in Redex prior to commit 3b44c64 can load an out of bound address when loading the string index table, potentially allowing remote code execution during processing of a 3rd party Android APK file.", "other": {"cve": {"id": "CVE-2022-36938", "sourceIdentifier": "cve-assign@fb.com", "published": "2022-11-11T00:15:10.193", "lastModified": "2022-11-16T02:44:42.080", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "DexLoader function get_stringidx_fromdex() in Redex prior to commit 3b44c64 can load an out of bound address when loading the string index table, potentially allowing remote code execution during processing of a 3rd party Android APK file."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}, {"source": "cve-assign@fb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-125"}, {"lang": "en", "value": "CWE-822"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:facebook:redex:*:*:*:*:*:*:*:*", "versionEndExcluding": "2022-11-04", "matchCriteriaId": "E83BD5C5-67EF-4EBA-8ADC-9A69E639D817"}]}]}], "references": [{"url": "https://github.com/facebook/redex/commit/3b44c640346b77bfb7ef36e2413688dd460288d2", "source": "cve-assign@fb.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/facebook/redex/commit/3b44c640346b77bfb7ef36e2413688dd460288d2"}}