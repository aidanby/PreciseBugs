{"buggy_code": ["# frozen_string_literal: true\n\nrequire \"digest/sha1\"\n\n# Publify user.\n# TODO: Should belong to a blog\nclass User < ApplicationRecord\n  ADMIN = \"admin\"\n  PUBLISHER = \"publisher\"\n  CONTRIBUTOR = \"contributor\"\n\n  # Include default devise modules. Others available are:\n  # :confirmable, :lockable, :timeoutable and :omniauthable\n  devise :database_authenticatable, :registerable,\n         :recoverable, :rememberable, :trackable, :validatable\n  include ConfigManager\n  include StringLengthLimit\n\n  before_validation :set_default_profile\n\n  validates :login, uniqueness: true\n  validates :email, :login, presence: true\n  validates :login, length: { in: 3..40 }\n  validates_default_string_length :email, :text_filter_name\n  validates :name, length: { maximum: 2048 }\n\n  belongs_to :resource, optional: true\n  has_many :notifications, foreign_key: \"notify_user_id\"\n  has_many :notify_contents, -> { uniq }, through: :notifications,\n                                          source: \"notify_content\"\n\n  has_many :articles\n\n  serialize :settings, Hash\n\n  STATUS = %w(active inactive).freeze\n\n  attr_accessor :filename\n\n  # Settings\n  setting :notify_watch_my_articles, :boolean, true\n  setting :firstname, :string, \"\"\n  setting :lastname, :string, \"\"\n  setting :nickname, :string, \"\"\n  setting :description, :string, \"\"\n  setting :url, :string, \"\"\n  setting :msn, :string, \"\"\n  setting :aim, :string, \"\"\n  setting :yahoo, :string, \"\"\n  setting :twitter, :string, \"\"\n  setting :jabber, :string, \"\"\n  setting :admin_theme, :string, \"blue\"\n  setting :twitter_account, :string, \"\"\n  setting :twitter_oauth_token, :string, \"\"\n  setting :twitter_oauth_token_secret, :string, \"\"\n  setting :twitter_profile_image, :string, \"\"\n\n  # echo \"publify\" | sha1sum -\n  class_attribute :salt\n\n  def self.salt\n    \"20ac4d290c2293702c64b3b287ae5ea79b26a5c1\"\n  end\n\n  def first_and_last_name\n    return \"\" unless firstname.present? && lastname.present?\n\n    \"#{firstname} #{lastname}\"\n  end\n\n  def display_names\n    [:login, :nickname, :firstname, :lastname, :first_and_last_name].\n      map { |f| send(f) }.delete_if(&:empty?)\n  end\n\n  # Authenticate users with old password hashes\n  alias devise_valid_password? valid_password?\n\n  def valid_password?(password)\n    devise_valid_password?(password)\n  rescue BCrypt::Errors::InvalidHash\n    digest = Digest::SHA1.hexdigest(\"#{self.class.salt}--#{password}--\")\n    if digest == encrypted_password\n      # Update old SHA1 password with new Devise ByCrypt password\n      self.encrypted_password = password_digest(password)\n      save\n      true\n    else\n      # If not BCrypt password and not old SHA1 password deny access\n      false\n    end\n  end\n\n  def active_for_authentication?\n    super && state == \"active\"\n  end\n\n  def text_filter\n    TextFilter.make_filter(text_filter_name)\n  end\n\n  def self.to_prefix\n    \"author\"\n  end\n\n  def article_counter\n    articles.size\n  end\n\n  def display_name\n    if nickname.present?\n      nickname\n    elsif name.present?\n      name\n    else\n      login\n    end\n  end\n\n  def permalink\n    login\n  end\n\n  def admin?\n    profile == User::ADMIN\n  end\n\n  def update_twitter_profile_image(img)\n    return if twitter_profile_image == img\n\n    self.twitter_profile_image = img\n    save\n  end\n\n  def has_twitter_configured?\n    twitter_oauth_token.present? && twitter_oauth_token_secret.present?\n  end\n\n  private\n\n  def set_default_profile\n    self.profile ||= User.count.zero? ? \"admin\" : \"contributor\"\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"devise\"\nrequire \"devise-i18n\"\n\nrequire \"publify_core/version\"\nrequire \"publify_core/engine\"\nrequire \"publify_core/lang\"\n\nrequire \"carrierwave\"\nrequire \"dynamic_form\"\nrequire \"jquery-rails\"\nrequire \"jquery-ui-rails\"\nrequire \"kaminari\"\nrequire \"rails_autolink\"\nrequire \"rails-timeago\"\nrequire \"recaptcha/rails\"\nrequire \"sassc-rails\"\n\nrequire \"email_notify\"\nrequire \"publify_guid\"\nrequire \"publify_textfilter_none\"\nrequire \"publify_textfilter_markdown\"\nrequire \"publify_textfilter_smartypants\"\nrequire \"publify_textfilter_textile\"\nrequire \"publify_textfilter_twitterfilter\"\nrequire \"publify_time\"\nrequire \"sidebar_registry\"\nrequire \"spam_protection\"\nrequire \"text_filter_plugin\"\nrequire \"theme\"\nrequire \"transforms\"\n\nmodule PublifyCore\n  Theme.register_themes File.join(Engine.root, \"themes\")\n\n  SidebarRegistry.register_sidebar \"ArchivesSidebar\"\n  SidebarRegistry.register_sidebar \"MetaSidebar\"\n  SidebarRegistry.register_sidebar \"PageSidebar\"\n  SidebarRegistry.register_sidebar \"SearchSidebar\"\n  SidebarRegistry.register_sidebar \"StaticSidebar\"\n  SidebarRegistry.register_sidebar \"TagSidebar\"\n\n  # Mime type is fully determined by url\n  Engine.config.action_dispatch.ignore_accept_header = true\nend\n", "# frozen_string_literal: true\n\nrequire \"publify_core/testing_support/upload_fixtures\"\n\n# Factory definitions\nFactoryBot.define do\n  sequence(:name) { |n| \"name_#{n}\" }\n  sequence(:body) { |n| \"body #{n}\" * (n + 3 % 5) }\n  sequence(:user) { |n| \"user#{n}\" }\n  sequence(:email) { |n| \"user#{n}@example.com\" }\n  sequence(:guid) { |n| \"deadbeef#{n}\" }\n  sequence(:label) { |n| \"lab_#{n}\" }\n  sequence(:file_name) { |f| \"file_name_#{f}\" }\n  sequence(:time) { |n| Time.new(2012, 3, 26, 19, 56).in_time_zone - n }\n\n  factory :user do\n    login { FactoryBot.generate(:user) }\n    email { generate(:email) }\n    name { \"Bond\" }\n    nickname { \"James Bond\" }\n    notify_via_email { false }\n    notify_on_new_articles { false }\n    notify_on_comments { false }\n    password { \"top-secret\" }\n    state { \"active\" }\n    profile { User::CONTRIBUTOR }\n\n    trait :without_twitter do\n      twitter { nil }\n      association :resource, nil\n    end\n\n    trait :with_a_full_profile do\n      description { \"I am a poor lonesone factory generated user\" }\n      url { \"http://myblog.net\" }\n      msn { \"random@mail.com\" }\n      aim { \"randomaccount\" }\n      yahoo { \"anotherrandomaccount\" }\n      twitter { \"@random\" }\n      jabber { \"random@account.com\" }\n    end\n\n    trait :as_admin do\n      profile { User::ADMIN }\n    end\n\n    trait :as_publisher do\n      profile { User::PUBLISHER }\n    end\n\n    trait :as_contributor do\n      profile { User::CONTRIBUTOR }\n    end\n  end\n\n  factory :article do\n    title { \"A big article\" }\n    body { \"A content with several data\" }\n    extended { \"extended content for fun\" }\n    guid\n    published_at { Time.zone.now }\n    user\n    allow_comments { true }\n    state { :published }\n    allow_pings { true }\n    text_filter_name { \"markdown\" }\n\n    after :build do |article|\n      article.blog ||= Blog.first || create(:blog)\n    end\n\n    after :stub do |article|\n      article.blog ||= Blog.first || create(:blog)\n    end\n\n    trait :with_tags do\n      keywords { \"a tag\" }\n    end\n  end\n\n  factory :unpublished_article, parent: :article do\n    published_at { nil }\n    state { :draft }\n  end\n\n  factory :full_article, parent: :article do\n    after :create do |article|\n      article.resources << create(:resource)\n      article.tags << create(:tag)\n    end\n  end\n\n  factory :content do\n    blog { Blog.first || create(:blog) }\n  end\n\n  factory :post_type do\n    name { \"foobar\" }\n    description { \"Some description\" }\n  end\n\n  factory :utf8article, parent: :article do\n    title { \"\u30eb\u30d3\u30fc\" }\n    permalink { \"\u30eb\u30d3\u30fc\" }\n  end\n\n  factory :second_article, parent: :article do\n    title { \"Another big article\" }\n  end\n\n  factory :article_with_accent_in_html, parent: :article do\n    title { \"article with accent\" }\n    body { \"&eacute;coute The future is cool!\" }\n    permalink { \"article-with-accent\" }\n  end\n\n  factory :blog do\n    base_url { \"http://test.host/blog\" }\n    hide_extended_on_rss { true }\n    blog_name { \"test blog\" }\n    limit_article_display { 2 }\n    sp_url_limit { 3 }\n    plugin_avatar { \"\" }\n    blog_subtitle { \"test subtitle\" }\n    limit_rss_display { 10 }\n    geourl_location { \"\" }\n    default_allow_pings { false }\n    send_outbound_pings { false }\n    sp_global { true }\n    default_allow_comments { true }\n    email_from { \"scott@sigkill.org\" }\n    sp_article_auto_close { 0 }\n    permalink_format { \"/%year%/%month%/%day%/%title%\" }\n    rss_description_text { \"rss description text\" }\n    lang { \"en_US\" }\n  end\n\n  factory :tag do |tag|\n    tag.name { FactoryBot.generate(:name) }\n    tag.display_name { |a| a.name } # rubocop:disable Style/SymbolProc\n    blog { Blog.first || create(:blog) }\n  end\n\n  factory :resource do\n    upload { PublifyCore::TestingSupport::UploadFixtures.file_upload }\n    mime { \"image/jpeg\" }\n    size { 110 }\n    blog { Blog.first || create(:blog) }\n  end\n\n  factory :avatar, parent: :resource do\n    upload { \"avatar.jpg\" }\n    mime { \"image/jpeg\" }\n    size { 600 }\n  end\n\n  factory :redirect do\n    from_path { \"foo/bar\" }\n    to_path { \"/someplace/else\" }\n    blog { Blog.first || create(:blog) }\n  end\n\n  factory :comment do\n    article\n    author { \"Bob Foo\" }\n    url { \"http://fakeurl.com\" }\n    body { \"Comment body\" }\n    guid\n    state { \"ham\" }\n\n    factory :unconfirmed_comment do\n      state { \"presumed_ham\" }\n    end\n\n    factory :published_comment do\n      state { \"ham\" }\n    end\n\n    factory :not_published_comment do\n      state { \"spam\" }\n    end\n\n    factory :ham_comment do\n      state { \"ham\" }\n    end\n\n    factory :presumed_ham_comment do\n      state { \"presumed_ham\" }\n    end\n\n    factory :presumed_spam_comment do\n      state { \"presumed_spam\" }\n    end\n\n    factory :spam_comment do\n      state { \"spam\" }\n    end\n  end\n\n  factory :page do\n    name { FactoryBot.generate(:name) }\n    title { \"Page One Title\" }\n    body { FactoryBot.generate(:body) }\n    published_at { Time.zone.now }\n    user\n    blog { Blog.first || create(:blog) }\n    state { \"published\" }\n  end\n\n  factory :note do\n    body { \"this is a note\" }\n    published_at { Time.zone.now }\n    user\n    state { \"published\" }\n    text_filter_name { \"markdown\" }\n    guid\n    blog { Blog.first || create(:blog) }\n  end\n\n  factory :unpublished_note, parent: :note do\n    state { \"draft\" }\n  end\n\n  factory :trackback do\n    state { \"ham\" }\n    article\n    blog_name { \"Trackback Blog\" }\n    title { \"Trackback Entry\" }\n    url { \"http://www.example.com\" }\n    excerpt { \"This is an excerpt\" }\n    guid { \"dsafsadffsdsf\" }\n  end\n\n  factory :sidebar do\n    active_position { 1 }\n    config { { \"title\" => \"Links\", \"body\" => \"some links\" } }\n    type { \"StaticSidebar\" }\n    blog { Blog.first || create(:blog) }\n  end\nend\n", "# frozen_string_literal: true\n\n$LOAD_PATH.push File.expand_path(\"lib\", __dir__)\n\n# Maintain your gem's version:\nrequire \"publify_core/version\"\n\n# Describe your gem and declare its dependencies:\nGem::Specification.new do |s|\n  s.name        = \"publify_core\"\n  s.version     = PublifyCore::VERSION\n  s.authors     = [\"Matijs van Zuijlen\", \"Yannick Fran\u00e7ois\",\n                   \"Thomas Lecavellier\", \"Fr\u00e9d\u00e9ric de Villamil\"]\n  s.email       = [\"matijs@matijs.net\"]\n  s.homepage    = \"https://publify.github.io/\"\n  s.summary     = \"Core engine for the Publify blogging system.\"\n  s.description = \"Core engine for the Publify blogging system, formerly known as Typo.\"\n  s.license     = \"MIT\"\n\n  s.files       = File.open(\"Manifest.txt\").readlines.map(&:chomp)\n\n  s.required_ruby_version = \">= 2.5.0\"\n\n  s.add_dependency \"aasm\", \"~> 5.0\"\n  s.add_dependency \"akismet\", \"~> 3.0\"\n  s.add_dependency \"bluecloth\", \"~> 2.1\"\n  s.add_dependency \"cancancan\", \"~> 3.0\"\n  s.add_dependency \"carrierwave\", \"~> 2.0\"\n  s.add_dependency \"devise\", \"~> 4.7.1\"\n  s.add_dependency \"devise-i18n\", \"~> 1.2\"\n  s.add_dependency \"dynamic_form\", \"~> 1.1.4\"\n  s.add_dependency \"fog-aws\", \"~> 3.2\"\n  s.add_dependency \"fog-core\", \"~> 2.2\"\n  s.add_dependency \"jquery-rails\", \"~> 4.4.0\"\n  s.add_dependency \"jquery-ui-rails\", \"~> 6.0.1\"\n  s.add_dependency \"kaminari\", [\"~> 1.2\", \">= 1.2.1\"]\n  s.add_dependency \"mini_magick\", [\"~> 4.9\", \">= 4.9.4\"]\n  # Force minimum nokogiri version to avoid security issues\n  s.add_dependency \"nokogiri\", \">= 1.12.5\"\n  s.add_dependency \"psych\", \"~> 3.2.0\"\n  s.add_dependency \"rack\", \">= 2.2.3\"\n  s.add_dependency \"rails\", \"~> 5.2.6\"\n  s.add_dependency \"rails_autolink\", \"~> 1.1.0\"\n  s.add_dependency \"rails-timeago\", \"~> 2.0\"\n  s.add_dependency \"recaptcha\", [\"~> 5.0\"]\n  s.add_dependency \"RedCloth\", \"~> 4.3.2\"\n  s.add_dependency \"rubypants\", \"~> 0.7.0\"\n  s.add_dependency \"sassc-rails\", \"~> 2.0\"\n  s.add_dependency \"sprockets\", \"~> 3.0\"\n  s.add_dependency \"twitter\", \"~> 7.0.0\"\n  s.add_dependency \"uuidtools\", \"~> 2.1.1\"\n\n  s.add_development_dependency \"capybara\", \"~> 3.0\"\n  s.add_development_dependency \"factory_bot\", \"~> 6.2\"\n  s.add_development_dependency \"feedjira\", \"~> 3.2\"\n  s.add_development_dependency \"i18n-tasks\", \"~> 0.9.1\"\n  s.add_development_dependency \"pry\"\n  s.add_development_dependency \"rails-controller-testing\", \"~> 1.0.1\"\n  s.add_development_dependency \"rspec-rails\", \"~> 4.0\"\n  s.add_development_dependency \"shoulda-matchers\", \"~> 4.5\"\n  s.add_development_dependency \"simplecov\", \"~> 0.19.0\"\n  s.add_development_dependency \"sqlite3\"\n  s.add_development_dependency \"timecop\", \"~> 0.9.1\"\n  s.add_development_dependency \"webmock\", \"~> 3.3\"\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\ndescribe Admin::UsersController, type: :controller do\n  let!(:blog) { create :blog }\n  let(:admin) { create(:user, :as_admin) }\n  let(:publisher) { create(:user, :as_publisher) }\n  let(:contributor) { create(:user, :as_contributor) }\n\n  render_views\n\n  describe \"#index\" do\n    let(:user) { admin }\n\n    before do\n      sign_in user\n    end\n\n    it \"renders a list of users\" do\n      get :index\n      assert_template \"index\"\n      expect(assigns(:users)).not_to be_nil\n    end\n\n    describe \"when you are not admin\" do\n      let(:user) { publisher }\n\n      it \"don't see the list of user\" do\n        get :index\n        expect(response).to redirect_to(controller: \"/admin/dashboard\", action: \"index\")\n      end\n    end\n  end\n\n  describe \"#new\" do\n    before do\n      sign_in admin\n    end\n\n    it \"renders the new template\" do\n      get :new\n      assert_template \"new\"\n    end\n  end\n\n  describe \"#create\" do\n    before do\n      sign_in admin\n      post :create, params: { user: { login: \"errand\", email: \"corey@test.com\",\n                                      password: \"testpass\",\n                                      password_confirmation: \"testpass\",\n                                      profile: User::CONTRIBUTOR,\n                                      text_filter_name: \"markdown\",\n                                      nickname: \"fooo\", firstname: \"bar\" } }\n    end\n\n    it \"redirects to the index\" do\n      expect(response).to redirect_to(action: \"index\")\n    end\n  end\n\n  describe \"#update\" do\n    let(:user) { admin }\n\n    before do\n      sign_in user\n    end\n\n    it \"redirects to index\" do\n      post :update, params: { id: contributor.id,\n                              user: { login: \"errand\",\n                                      email: \"corey@test.com\", password: \"testpass\",\n                                      password_confirmation: \"testpass\" } }\n      expect(response).to redirect_to(action: \"index\")\n    end\n\n    it \"skips blank passwords\" do\n      post :update, params: { id: contributor.id,\n                              user: { login: \"errand\",\n                                      password: \"\", password_confirmation: \"\" } }\n      contributor.reload\n      aggregate_failures do\n        expect(response).to redirect_to(action: \"index\")\n        expect(contributor).not_to be_valid_password(\"\")\n      end\n    end\n\n    describe \"when you are not admin\" do\n      let(:user) { publisher }\n\n      before do\n        post :update, params: { id: contributor.id, user: { profile: User::PUBLISHER } }\n      end\n\n      it \"redirects to login\" do\n        expect(response).to redirect_to(controller: \"/admin/dashboard\", action: \"index\")\n      end\n\n      it \"does not change user profile\" do\n        u = contributor.reload\n        expect(u.profile).to eq User::CONTRIBUTOR\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\ndescribe SetupController, type: :controller do\n  describe \"#index\" do\n    describe \"when no blog is configured\" do\n      before do\n        # Set up database similar to result of seeding\n        @blog = Blog.create\n        get \"index\"\n      end\n\n      specify { expect(response).to render_template(\"index\") }\n    end\n\n    describe \"when a blog is configured and has some users\" do\n      before do\n        create(:blog)\n        get \"index\"\n      end\n\n      specify { expect(response).to redirect_to(controller: \"articles\", action: \"index\") }\n    end\n  end\n\n  describe \"#create\" do\n    context \"when no blog is configured\" do\n      before do\n        # Set up database similar to result of seeding\n        @blog = Blog.create\n      end\n\n      context \"when passing correct parameters\" do\n        before do\n          ActionMailer::Base.deliveries.clear\n          post :create, params: { setting: { blog_name: \"Foo\", email: \"foo@bar.net\",\n                                             password: \"foo123bar\" } }\n        end\n\n        it \"correctly initializes blog and users\" do\n          expect(Blog.first.blog_name).to eq(\"Foo\")\n          admin = User.find_by(login: \"admin\")\n          expect(admin).not_to be_nil\n          expect(admin.email).to eq(\"foo@bar.net\")\n          expect(Article.first.user).to eq(admin)\n          expect(Page.first.user).to eq(admin)\n        end\n\n        it \"logs in admin user\" do\n          expect(controller.current_user).to eq(User.find_by(login: \"admin\"))\n        end\n\n        it \"redirects to confirm the setup\" do\n          expect(response).to redirect_to(controller: \"accounts\",\n                                          action: \"confirm\")\n        end\n\n        it \"sends a confirmation email\" do\n          expect(ActionMailer::Base.deliveries.size).to eq 1\n        end\n      end\n\n      describe \"when passing incorrect parameters\" do\n        it \"empty blog name should raise an error\" do\n          post :create, params: { setting: { blog_name: \"\", email: \"foo@bar.net\",\n                                             password: \"foobar123\" } }\n          expect(response).to redirect_to(action: \"index\")\n        end\n\n        it \"empty email should raise an error\" do\n          post :create, params: { setting: { blog_name: \"Foo\", email: \"\",\n                                             password: \"foobar123\" } }\n          expect(response).to redirect_to(action: \"index\")\n        end\n\n        it \"empty password should raise an error\" do\n          post :create, params: { setting: { blog_name: \"Foo\", email: \"foo@bar.net\",\n                                             password: \"\" } }\n          expect(response).to redirect_to(action: \"index\")\n        end\n      end\n    end\n\n    describe \"when a blog is configured and has some users\" do\n      before do\n        create(:blog)\n        post :create, params: { setting: { blog_name: \"Foo\", email: \"foo@bar.net\" } }\n      end\n\n      specify { expect(response).to redirect_to(controller: \"articles\", action: \"index\") }\n\n      it \"does not initialize blog and users\" do\n        expect(Blog.first.blog_name).not_to eq(\"Foo\")\n        admin = User.find_by(login: \"admin\")\n        expect(admin).to be_nil\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\nRSpec.feature \"Logging in\", type: :feature do\n  before do\n    stub_request(:get,\n                 \"http://www.google.com/search?output=rss&q=link:www.example.com&tbm=blg\").\n      to_return(status: 200, body: \"\", headers: {})\n    load Rails.root.join(\"db/seeds.rb\")\n    Blog.first.update blog_name: \"Awesome!\", base_url: \"http://www.example.com/\"\n    create :user, :as_admin, login: \"admin\", password: \"a-secret\"\n  end\n\n  scenario \"Admin logs in\" do\n    visit \"/admin\"\n    fill_in :user_login, with: \"admin\"\n    fill_in :user_password, with: \"a-secret\"\n\n    click_button I18n.t(\"devise.sessions.new.sign_in\")\n\n    expect(page).to have_text I18n.t(\"devise.sessions.signed_in\")\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\nRSpec.feature \"Logging in\", type: :feature do\n  before do\n    load Rails.root.join(\"db/seeds.rb\")\n    Blog.first.update blog_name: \"Awesome!\", base_url: \"http://www.example.com/\"\n    create :user, :as_admin, login: \"admin\", password: \"forget-me\"\n  end\n\n  scenario \"Admin resets password\" do\n    visit \"/admin\"\n    click_link I18n.t(\"accounts.lost_my_password\")\n\n    fill_in :user_email, with: User.last.email\n    click_button I18n.t(\"devise.passwords.new.send_me_reset_password_instructions\")\n\n    mail = ActionMailer::Base.deliveries.last\n    html = Nokogiri::HTML.parse mail.body.raw_source\n    link = html.at_css \"a\"\n    url = link.attribute(\"href\").value\n\n    visit url\n\n    fill_in :user_password, with: \"a-secret\"\n    fill_in :user_password_confirmation, with: \"a-secret\"\n\n    click_button I18n.t(\"devise.passwords.edit.change_my_password\")\n    expect(page).to have_text I18n.t(\"devise.passwords.updated\")\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\nRSpec.feature \"Blog setup\", type: :feature do\n  before do\n    stub_request(:get,\n                 \"http://www.google.com/search?output=rss&q=link:www.example.com&tbm=blg\").\n      to_return(status: 200, body: \"\", headers: {})\n    load Rails.root.join(\"db/seeds.rb\")\n  end\n\n  scenario \"User accesses blog for the first time\" do\n    # Go to the blog setup\n    visit \"/\"\n    expect(page).to have_text I18n.t!(\"setup.index.welcome_to_your_blog_setup\")\n\n    # Set up the blog\n    fill_in :setting_blog_name, with: \"Awesome blog\"\n    fill_in :setting_email, with: \"foo@bar.com\"\n    fill_in :setting_password, with: \"test1234\"\n    click_button I18n.t!(\"generic.save\")\n\n    # Confirm set up success\n    expect(page).to have_text I18n.t!(\"accounts.confirm.success\")\n    expect(page).to have_text I18n.t!(\"accounts.confirm.login\", login: \"admin\")\n\n    # Visit the autogenerated article\n    click_link I18n.t!(\"accounts.confirm.admin\")\n    click_link I18n.t!(\"admin.shared.menu.all_articles\")\n    find(\"tbody#articleList td a.published\").click\n\n    expect(page).to have_text I18n.t!(\"setup.article.title\")\n\n    # Confirm ability to log in\n    visit admin_dashboard_path\n    find(\"a[href=\\\"#{destroy_user_session_path}\\\"]\").click\n\n    visit admin_dashboard_path\n    fill_in :user_login, with: \"admin\"\n    fill_in :user_password, with: \"test1234\"\n    find(\"input[type=submit]\").click\n    expect(page).to have_text I18n.t!(\"admin.dashboard.index.welcome_back\",\n                                      user_name: \"admin\")\n\n    # Confirm proper setting fo user properties\n    expect(User.first.email).to eq \"foo@bar.com\"\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\nRSpec.feature \"Signing up\", type: :feature do\n  before do\n    load Rails.root.join(\"db/seeds.rb\")\n    Blog.first.update(blog_name: \"Awesome!\",\n                      base_url: \"http://www.example.com/\",\n                      allow_signup: 1)\n    create :user, :as_admin, login: \"admin\", password: \"a-secret\"\n  end\n\n  scenario \"User signs up for an account\" do\n    visit admin_dashboard_path\n    click_link I18n.t(\"accounts.create_account\")\n\n    # Create account\n    fill_in :user_login, with: \"hello\"\n    fill_in :user_email, with: \"hello@hello.com\"\n    fill_in :user_password, with: \"hush-hush\"\n    fill_in :user_password_confirmation, with: \"hush-hush\"\n    click_button I18n.t!(\"devise.registrations.new.sign_up\")\n\n    # Confirm creation success\n    expect(page).to have_text I18n.t!(\"devise.registrations.signed_up\")\n\n    # Sign out\n    visit admin_dashboard_path\n    find(\"a[href=\\\"#{destroy_user_session_path}\\\"]\").click\n\n    # Confirm ability to sign in\n    visit admin_dashboard_path\n    fill_in :user_login, with: \"hello\"\n    fill_in :user_password, with: \"hush-hush\"\n    find(\"input[type=submit]\").click\n    expect(page).to have_text I18n.t!(\"devise.sessions.signed_in\")\n\n    # Confirm proper setting fo user properties\n    u = User.last\n    expect(u.email).to eq \"hello@hello.com\"\n    expect(u.profile).to eq \"contributor\"\n  end\n\n  scenario \"Disallow account sign-up link with a blog setting\" do\n    Blog.first.update(allow_signup: 0)\n    visit admin_dashboard_path\n    expect(page).not_to have_link I18n.t(\"accounts.create_account\")\n\n    visit new_user_registration_path\n\n    expect(page.status_code).to eq 404\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\ndescribe User, type: :model do\n  describe \"FactoryBot Bot\" do\n    it \"users factory valid\" do\n      expect(create(:user)).to be_valid\n      expect(build(:user)).to be_valid\n    end\n\n    it \"multiples user factory valid\" do\n      expect(create(:user)).to be_valid\n      expect(create(:user)).to be_valid\n    end\n\n    it \"salt should not be nil\" do\n      expect(described_class.salt).to eq(\"20ac4d290c2293702c64b3b287ae5ea79b26a5c1\")\n    end\n  end\n\n  describe \"#active_for_authentication?\" do\n    it \"is true for users in the state 'active'\" do\n      user = build :user, state: \"active\"\n      expect(user).to be_active_for_authentication\n    end\n\n    it \"is false for users in the state 'inactive'\" do\n      user = build :user, state: \"inactive\"\n      expect(user).not_to be_active_for_authentication\n    end\n  end\n\n  context \"With the contents and users fixtures loaded\" do\n    it \"The various article finders work appropriately\" do\n      create(:blog)\n      tobi = create(:user)\n      create_list(:article, 7, user: tobi)\n      create(:article, state: \"draft\", published_at: nil, user: tobi)\n      expect(tobi.articles.size).to eq(8)\n      expect(tobi.articles.published.size).to eq(7)\n    end\n  end\n\n  describe \"validations\" do\n    let(:user) { described_class.new }\n\n    it \"requires email to not be too long\" do\n      expect(user).to validate_length_of(:email).is_at_most(255)\n    end\n\n    it \"requires name to not be too long\" do\n      expect(user).to validate_length_of(:name).is_at_most(2048)\n    end\n\n    it \"requires first name to not be too long\" do\n      expect(user).to validate_length_of(:firstname).is_at_most(256)\n    end\n\n    it \"requires last name to not be too long\" do\n      expect(user).to validate_length_of(:lastname).is_at_most(256)\n    end\n\n    it \"requires the email field to be present\" do\n      expect(user).to validate_presence_of(:email)\n    end\n\n    it \"requires the email field to always be unique\" do\n      expect(user).to validate_uniqueness_of(:email)\n    end\n\n    it \"requires the login field to always be unique\" do\n      expect(user).to validate_uniqueness_of(:login).case_insensitive\n    end\n\n    it \"requires the login field to be of reasonable length\" do\n      expect(user).to validate_length_of(:login).is_at_least(3).is_at_most(40)\n    end\n\n    it \"requires the login field to be present\" do\n      expect(user).to validate_presence_of(:login)\n    end\n\n    it \"requires text_filter_name to not be too long\" do\n      expect(user).to validate_length_of(:text_filter_name).is_at_most(255)\n    end\n\n    it \"does not allow duplicate logins when updating a user\" do\n      create :user, login: \"foo\"\n      bar = create :user, login: \"bar\"\n\n      expect(bar).not_to allow_value(\"foo\").for(:login)\n    end\n\n    it \"does not allow duplicate emails when updating a user\" do\n      create :user, email: \"foo@foo.com\"\n      bar = create :user, email: \"bar@bar.com\"\n\n      expect(bar).not_to allow_value(\"foo@foo.com\").for(:email)\n    end\n  end\n\n  describe \"#initialize\" do\n    it \"accepts a settings field in its parameter hash\" do\n      described_class.new(\"firstname\" => \"foo\")\n    end\n  end\n\n  describe \"#admin?\" do\n    it \"returns true if user is admin\" do\n      admin = build(:user, :as_admin)\n      expect(admin).to be_admin\n    end\n\n    it \"returns false if user is not admin\" do\n      publisher = build(:user, :as_publisher)\n      expect(publisher).not_to be_admin\n    end\n  end\n\n  describe \"#first_and_last_name\" do\n    context \"with first and last name\" do\n      let(:user) { create(:user, firstname: \"Marlon\", lastname: \"Brando\") }\n\n      it { expect(user.first_and_last_name).to eq(\"Marlon Brando\") }\n    end\n\n    context \"with firstname without lastname\" do\n      let(:user) { create(:user, firstname: \"Marlon\", lastname: nil) }\n\n      it { expect(user.first_and_last_name).to eq(\"\") }\n    end\n  end\n\n  describe \"#display_names\" do\n    context \"with user without nickname, firstname, lastname\" do\n      let(:user) { create(:user, nickname: nil, firstname: nil, lastname: nil) }\n\n      it { expect(user.display_names).to eq([user.login]) }\n    end\n\n    context \"with user with nickname without firstname, lastname\" do\n      let(:user) { create(:user, nickname: \"Bob\", firstname: nil, lastname: nil) }\n\n      it { expect(user.display_names).to eq([user.login, user.nickname]) }\n    end\n\n    context \"with user with firstname, without nickname, lastname\" do\n      let(:user) { create(:user, nickname: nil, firstname: \"Robert\", lastname: nil) }\n\n      it { expect(user.display_names).to eq([user.login, user.firstname]) }\n    end\n\n    context \"with user with lastname, without nickname, firstname\" do\n      let(:user) { create(:user, nickname: nil, firstname: nil, lastname: \"Redford\") }\n\n      it { expect(user.display_names).to eq([user.login, user.lastname]) }\n    end\n\n    context \"with user with firstname and lastname, witjout nickname\" do\n      let(:user) { create(:user, nickname: nil, firstname: \"Robert\", lastname: \"Redford\") }\n\n      it {\n        expect(user.display_names).\n          to eq([user.login, user.firstname, user.lastname,\n                 \"#{user.firstname} #{user.lastname}\"])\n      }\n    end\n  end\n\n  describe \"#has_twitter_configured?\" do\n    it \"is false without twitter_oauth_token or twitter_oauth_token_secret\" do\n      user = build(:user, twitter_oauth_token: nil, twitter_oauth_token_secret: nil)\n      expect(user.has_twitter_configured?).to eq(false)\n    end\n\n    it \"is false with an empty twitter_oauth_token and no twitter_oauth_token_secret\" do\n      user = build(:user, twitter_oauth_token: \"\", twitter_oauth_token_secret: nil)\n      expect(user.has_twitter_configured?).to eq(false)\n    end\n\n    it \"is false with empty twitter_oauth_token and twitter_oauth_token_secret\" do\n      user = build(:user, twitter_oauth_token: \"\", twitter_oauth_token_secret: \"\")\n      expect(user.has_twitter_configured?).to eq(false)\n    end\n\n    it \"is false with a twitter_oauth_token and no twitter_oauth_token_secret\" do\n      user = build(:user, twitter_oauth_token: \"12345\", twitter_oauth_token_secret: nil)\n      expect(user.has_twitter_configured?).to eq(false)\n    end\n\n    it \"is false with a twitter_oauth_token and an empty twitter_oauth_token_secret\" do\n      user = build(:user, twitter_oauth_token: \"12345\", twitter_oauth_token_secret: \"\")\n      expect(user.has_twitter_configured?).to eq(false)\n    end\n\n    it \"is false with a twitter_oauth_token_secret and no twitter_oauth_token\" do\n      user = build(:user, twitter_oauth_token: \"\", twitter_oauth_token_secret: \"67890\")\n      expect(user.has_twitter_configured?).to eq(false)\n    end\n\n    it \"is false with a twitter_oauth_token_secret and an empty twitter_oauth_token\" do\n      user = build(:user, twitter_oauth_token_secret: \"67890\", twitter_oauth_token: \"\")\n      expect(user.has_twitter_configured?).to eq(false)\n    end\n\n    it \"is true with a twitter_oauth_token and a twitter_oauth_token_secret\" do\n      user = build(:user, twitter_oauth_token: \"12345\", twitter_oauth_token_secret: \"67890\")\n      expect(user.has_twitter_configured?).to eq(true)\n    end\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\nrequire \"digest/sha1\"\n\n# Publify user.\n# TODO: Should belong to a blog\nclass User < ApplicationRecord\n  ADMIN = \"admin\"\n  PUBLISHER = \"publisher\"\n  CONTRIBUTOR = \"contributor\"\n\n  # Include default devise modules. Others available are:\n  # :confirmable, :lockable, :timeoutable and :omniauthable\n  devise :database_authenticatable, :registerable,\n         :recoverable, :rememberable, :trackable, :validatable, :zxcvbnable\n  include ConfigManager\n  include StringLengthLimit\n\n  before_validation :set_default_profile\n\n  validates :login, uniqueness: true\n  validates :email, :login, presence: true\n  validates :login, length: { in: 3..40 }\n  validates_default_string_length :email, :text_filter_name\n  validates :name, length: { maximum: 2048 }\n\n  belongs_to :resource, optional: true\n  has_many :notifications, foreign_key: \"notify_user_id\"\n  has_many :notify_contents, -> { uniq }, through: :notifications,\n                                          source: \"notify_content\"\n\n  has_many :articles\n\n  serialize :settings, Hash\n\n  STATUS = %w(active inactive).freeze\n\n  attr_accessor :filename\n\n  # Settings\n  setting :notify_watch_my_articles, :boolean, true\n  setting :firstname, :string, \"\"\n  setting :lastname, :string, \"\"\n  setting :nickname, :string, \"\"\n  setting :description, :string, \"\"\n  setting :url, :string, \"\"\n  setting :msn, :string, \"\"\n  setting :aim, :string, \"\"\n  setting :yahoo, :string, \"\"\n  setting :twitter, :string, \"\"\n  setting :jabber, :string, \"\"\n  setting :admin_theme, :string, \"blue\"\n  setting :twitter_account, :string, \"\"\n  setting :twitter_oauth_token, :string, \"\"\n  setting :twitter_oauth_token_secret, :string, \"\"\n  setting :twitter_profile_image, :string, \"\"\n\n  # echo \"publify\" | sha1sum -\n  class_attribute :salt\n\n  def self.salt\n    \"20ac4d290c2293702c64b3b287ae5ea79b26a5c1\"\n  end\n\n  def first_and_last_name\n    return \"\" unless firstname.present? && lastname.present?\n\n    \"#{firstname} #{lastname}\"\n  end\n\n  def display_names\n    [:login, :nickname, :firstname, :lastname, :first_and_last_name].\n      map { |f| send(f) }.delete_if(&:empty?)\n  end\n\n  # Authenticate users with old password hashes\n  alias devise_valid_password? valid_password?\n\n  def valid_password?(password)\n    devise_valid_password?(password)\n  rescue BCrypt::Errors::InvalidHash\n    digest = Digest::SHA1.hexdigest(\"#{self.class.salt}--#{password}--\")\n    if digest == encrypted_password\n      # Update old SHA1 password with new Devise ByCrypt password\n      self.encrypted_password = password_digest(password)\n      save\n      true\n    else\n      # If not BCrypt password and not old SHA1 password deny access\n      false\n    end\n  end\n\n  def active_for_authentication?\n    super && state == \"active\"\n  end\n\n  def text_filter\n    TextFilter.make_filter(text_filter_name)\n  end\n\n  def self.to_prefix\n    \"author\"\n  end\n\n  def article_counter\n    articles.size\n  end\n\n  def display_name\n    if nickname.present?\n      nickname\n    elsif name.present?\n      name\n    else\n      login\n    end\n  end\n\n  def permalink\n    login\n  end\n\n  def admin?\n    profile == User::ADMIN\n  end\n\n  def update_twitter_profile_image(img)\n    return if twitter_profile_image == img\n\n    self.twitter_profile_image = img\n    save\n  end\n\n  def has_twitter_configured?\n    twitter_oauth_token.present? && twitter_oauth_token_secret.present?\n  end\n\n  private\n\n  def set_default_profile\n    self.profile ||= User.count.zero? ? \"admin\" : \"contributor\"\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"devise\"\nrequire \"devise-i18n\"\nrequire \"devise_zxcvbn\"\n\nrequire \"publify_core/version\"\nrequire \"publify_core/engine\"\nrequire \"publify_core/lang\"\n\nrequire \"carrierwave\"\nrequire \"dynamic_form\"\nrequire \"jquery-rails\"\nrequire \"jquery-ui-rails\"\nrequire \"kaminari\"\nrequire \"rails_autolink\"\nrequire \"rails-timeago\"\nrequire \"recaptcha/rails\"\nrequire \"sassc-rails\"\n\nrequire \"email_notify\"\nrequire \"publify_guid\"\nrequire \"publify_textfilter_none\"\nrequire \"publify_textfilter_markdown\"\nrequire \"publify_textfilter_smartypants\"\nrequire \"publify_textfilter_textile\"\nrequire \"publify_textfilter_twitterfilter\"\nrequire \"publify_time\"\nrequire \"sidebar_registry\"\nrequire \"spam_protection\"\nrequire \"text_filter_plugin\"\nrequire \"theme\"\nrequire \"transforms\"\n\nmodule PublifyCore\n  Theme.register_themes File.join(Engine.root, \"themes\")\n\n  SidebarRegistry.register_sidebar \"ArchivesSidebar\"\n  SidebarRegistry.register_sidebar \"MetaSidebar\"\n  SidebarRegistry.register_sidebar \"PageSidebar\"\n  SidebarRegistry.register_sidebar \"SearchSidebar\"\n  SidebarRegistry.register_sidebar \"StaticSidebar\"\n  SidebarRegistry.register_sidebar \"TagSidebar\"\n\n  # Mime type is fully determined by url\n  Engine.config.action_dispatch.ignore_accept_header = true\nend\n", "# frozen_string_literal: true\n\nrequire \"publify_core/testing_support/upload_fixtures\"\n\n# Factory definitions\nFactoryBot.define do\n  sequence(:name) { |n| \"name_#{n}\" }\n  sequence(:body) { |n| \"body #{n}\" * (n + 3 % 5) }\n  sequence(:user) { |n| \"user#{n}\" }\n  sequence(:email) { |n| \"user#{n}@example.com\" }\n  sequence(:guid) { |n| \"deadbeef#{n}\" }\n  sequence(:label) { |n| \"lab_#{n}\" }\n  sequence(:file_name) { |f| \"file_name_#{f}\" }\n  sequence(:time) { |n| Time.new(2012, 3, 26, 19, 56).in_time_zone - n }\n\n  factory :user do\n    login { FactoryBot.generate(:user) }\n    email { generate(:email) }\n    name { \"Bond\" }\n    nickname { \"James Bond\" }\n    notify_via_email { false }\n    notify_on_new_articles { false }\n    notify_on_comments { false }\n    password { \"top-Secret12!$#\" }\n    state { \"active\" }\n    profile { User::CONTRIBUTOR }\n\n    trait :without_twitter do\n      twitter { nil }\n      association :resource, nil\n    end\n\n    trait :with_a_full_profile do\n      description { \"I am a poor lonesone factory generated user\" }\n      url { \"http://myblog.net\" }\n      msn { \"random@mail.com\" }\n      aim { \"randomaccount\" }\n      yahoo { \"anotherrandomaccount\" }\n      twitter { \"@random\" }\n      jabber { \"random@account.com\" }\n    end\n\n    trait :as_admin do\n      profile { User::ADMIN }\n    end\n\n    trait :as_publisher do\n      profile { User::PUBLISHER }\n    end\n\n    trait :as_contributor do\n      profile { User::CONTRIBUTOR }\n    end\n  end\n\n  factory :article do\n    title { \"A big article\" }\n    body { \"A content with several data\" }\n    extended { \"extended content for fun\" }\n    guid\n    published_at { Time.zone.now }\n    user\n    allow_comments { true }\n    state { :published }\n    allow_pings { true }\n    text_filter_name { \"markdown\" }\n\n    after :build do |article|\n      article.blog ||= Blog.first || create(:blog)\n    end\n\n    after :stub do |article|\n      article.blog ||= Blog.first || create(:blog)\n    end\n\n    trait :with_tags do\n      keywords { \"a tag\" }\n    end\n  end\n\n  factory :unpublished_article, parent: :article do\n    published_at { nil }\n    state { :draft }\n  end\n\n  factory :full_article, parent: :article do\n    after :create do |article|\n      article.resources << create(:resource)\n      article.tags << create(:tag)\n    end\n  end\n\n  factory :content do\n    blog { Blog.first || create(:blog) }\n  end\n\n  factory :post_type do\n    name { \"foobar\" }\n    description { \"Some description\" }\n  end\n\n  factory :utf8article, parent: :article do\n    title { \"\u30eb\u30d3\u30fc\" }\n    permalink { \"\u30eb\u30d3\u30fc\" }\n  end\n\n  factory :second_article, parent: :article do\n    title { \"Another big article\" }\n  end\n\n  factory :article_with_accent_in_html, parent: :article do\n    title { \"article with accent\" }\n    body { \"&eacute;coute The future is cool!\" }\n    permalink { \"article-with-accent\" }\n  end\n\n  factory :blog do\n    base_url { \"http://test.host/blog\" }\n    hide_extended_on_rss { true }\n    blog_name { \"test blog\" }\n    limit_article_display { 2 }\n    sp_url_limit { 3 }\n    plugin_avatar { \"\" }\n    blog_subtitle { \"test subtitle\" }\n    limit_rss_display { 10 }\n    geourl_location { \"\" }\n    default_allow_pings { false }\n    send_outbound_pings { false }\n    sp_global { true }\n    default_allow_comments { true }\n    email_from { \"scott@sigkill.org\" }\n    sp_article_auto_close { 0 }\n    permalink_format { \"/%year%/%month%/%day%/%title%\" }\n    rss_description_text { \"rss description text\" }\n    lang { \"en_US\" }\n  end\n\n  factory :tag do |tag|\n    tag.name { FactoryBot.generate(:name) }\n    tag.display_name { |a| a.name } # rubocop:disable Style/SymbolProc\n    blog { Blog.first || create(:blog) }\n  end\n\n  factory :resource do\n    upload { PublifyCore::TestingSupport::UploadFixtures.file_upload }\n    mime { \"image/jpeg\" }\n    size { 110 }\n    blog { Blog.first || create(:blog) }\n  end\n\n  factory :avatar, parent: :resource do\n    upload { \"avatar.jpg\" }\n    mime { \"image/jpeg\" }\n    size { 600 }\n  end\n\n  factory :redirect do\n    from_path { \"foo/bar\" }\n    to_path { \"/someplace/else\" }\n    blog { Blog.first || create(:blog) }\n  end\n\n  factory :comment do\n    article\n    author { \"Bob Foo\" }\n    url { \"http://fakeurl.com\" }\n    body { \"Comment body\" }\n    guid\n    state { \"ham\" }\n\n    factory :unconfirmed_comment do\n      state { \"presumed_ham\" }\n    end\n\n    factory :published_comment do\n      state { \"ham\" }\n    end\n\n    factory :not_published_comment do\n      state { \"spam\" }\n    end\n\n    factory :ham_comment do\n      state { \"ham\" }\n    end\n\n    factory :presumed_ham_comment do\n      state { \"presumed_ham\" }\n    end\n\n    factory :presumed_spam_comment do\n      state { \"presumed_spam\" }\n    end\n\n    factory :spam_comment do\n      state { \"spam\" }\n    end\n  end\n\n  factory :page do\n    name { FactoryBot.generate(:name) }\n    title { \"Page One Title\" }\n    body { FactoryBot.generate(:body) }\n    published_at { Time.zone.now }\n    user\n    blog { Blog.first || create(:blog) }\n    state { \"published\" }\n  end\n\n  factory :note do\n    body { \"this is a note\" }\n    published_at { Time.zone.now }\n    user\n    state { \"published\" }\n    text_filter_name { \"markdown\" }\n    guid\n    blog { Blog.first || create(:blog) }\n  end\n\n  factory :unpublished_note, parent: :note do\n    state { \"draft\" }\n  end\n\n  factory :trackback do\n    state { \"ham\" }\n    article\n    blog_name { \"Trackback Blog\" }\n    title { \"Trackback Entry\" }\n    url { \"http://www.example.com\" }\n    excerpt { \"This is an excerpt\" }\n    guid { \"dsafsadffsdsf\" }\n  end\n\n  factory :sidebar do\n    active_position { 1 }\n    config { { \"title\" => \"Links\", \"body\" => \"some links\" } }\n    type { \"StaticSidebar\" }\n    blog { Blog.first || create(:blog) }\n  end\nend\n", "# frozen_string_literal: true\n\n$LOAD_PATH.push File.expand_path(\"lib\", __dir__)\n\n# Maintain your gem's version:\nrequire \"publify_core/version\"\n\n# Describe your gem and declare its dependencies:\nGem::Specification.new do |s|\n  s.name        = \"publify_core\"\n  s.version     = PublifyCore::VERSION\n  s.authors     = [\"Matijs van Zuijlen\", \"Yannick Fran\u00e7ois\",\n                   \"Thomas Lecavellier\", \"Fr\u00e9d\u00e9ric de Villamil\"]\n  s.email       = [\"matijs@matijs.net\"]\n  s.homepage    = \"https://publify.github.io/\"\n  s.summary     = \"Core engine for the Publify blogging system.\"\n  s.description = \"Core engine for the Publify blogging system, formerly known as Typo.\"\n  s.license     = \"MIT\"\n\n  s.files       = File.open(\"Manifest.txt\").readlines.map(&:chomp)\n\n  s.required_ruby_version = \">= 2.5.0\"\n\n  s.add_dependency \"aasm\", \"~> 5.0\"\n  s.add_dependency \"akismet\", \"~> 3.0\"\n  s.add_dependency \"bluecloth\", \"~> 2.1\"\n  s.add_dependency \"cancancan\", \"~> 3.0\"\n  s.add_dependency \"carrierwave\", \"~> 2.0\"\n  s.add_dependency \"devise\", \"~> 4.7.1\"\n  s.add_dependency \"devise-i18n\", \"~> 1.2\"\n  s.add_dependency \"devise_zxcvbn\", \"~> 6.0\"\n  s.add_dependency \"dynamic_form\", \"~> 1.1.4\"\n  s.add_dependency \"fog-aws\", \"~> 3.2\"\n  s.add_dependency \"fog-core\", \"~> 2.2\"\n  s.add_dependency \"jquery-rails\", \"~> 4.4.0\"\n  s.add_dependency \"jquery-ui-rails\", \"~> 6.0.1\"\n  s.add_dependency \"kaminari\", [\"~> 1.2\", \">= 1.2.1\"]\n  s.add_dependency \"mini_magick\", [\"~> 4.9\", \">= 4.9.4\"]\n  # Force minimum nokogiri version to avoid security issues\n  s.add_dependency \"nokogiri\", \">= 1.12.5\"\n  s.add_dependency \"psych\", \"~> 3.2.0\"\n  s.add_dependency \"rack\", \">= 2.2.3\"\n  s.add_dependency \"rails\", \"~> 5.2.6\"\n  s.add_dependency \"rails_autolink\", \"~> 1.1.0\"\n  s.add_dependency \"rails-timeago\", \"~> 2.0\"\n  s.add_dependency \"recaptcha\", [\"~> 5.0\"]\n  s.add_dependency \"RedCloth\", \"~> 4.3.2\"\n  s.add_dependency \"rubypants\", \"~> 0.7.0\"\n  s.add_dependency \"sassc-rails\", \"~> 2.0\"\n  s.add_dependency \"sprockets\", \"~> 3.0\"\n  s.add_dependency \"twitter\", \"~> 7.0.0\"\n  s.add_dependency \"uuidtools\", \"~> 2.1.1\"\n\n  s.add_development_dependency \"capybara\", \"~> 3.0\"\n  s.add_development_dependency \"factory_bot\", \"~> 6.2\"\n  s.add_development_dependency \"feedjira\", \"~> 3.2\"\n  s.add_development_dependency \"i18n-tasks\", \"~> 0.9.1\"\n  s.add_development_dependency \"pry\"\n  s.add_development_dependency \"rails-controller-testing\", \"~> 1.0.1\"\n  s.add_development_dependency \"rspec-rails\", \"~> 4.0\"\n  s.add_development_dependency \"shoulda-matchers\", \"~> 4.5\"\n  s.add_development_dependency \"simplecov\", \"~> 0.19.0\"\n  s.add_development_dependency \"sqlite3\"\n  s.add_development_dependency \"timecop\", \"~> 0.9.1\"\n  s.add_development_dependency \"webmock\", \"~> 3.3\"\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\ndescribe Admin::UsersController, type: :controller do\n  let!(:blog) { create :blog }\n  let(:admin) { create(:user, :as_admin) }\n  let(:publisher) { create(:user, :as_publisher) }\n  let(:contributor) { create(:user, :as_contributor) }\n  let(:strong_password) { \"fhnehnhfiiuh\" }\n\n  render_views\n\n  describe \"#index\" do\n    let(:user) { admin }\n\n    before do\n      sign_in user\n    end\n\n    it \"renders a list of users\" do\n      get :index\n      assert_template \"index\"\n      expect(assigns(:users)).not_to be_nil\n    end\n\n    describe \"when you are not admin\" do\n      let(:user) { publisher }\n\n      it \"don't see the list of user\" do\n        get :index\n        expect(response).to redirect_to(controller: \"/admin/dashboard\", action: \"index\")\n      end\n    end\n  end\n\n  describe \"#new\" do\n    before do\n      sign_in admin\n    end\n\n    it \"renders the new template\" do\n      get :new\n      assert_template \"new\"\n    end\n  end\n\n  describe \"#create\" do\n    before do\n      sign_in admin\n      post :create, params: { user: { login: \"errand\", email: \"corey@test.com\",\n                                      password: strong_password,\n                                      password_confirmation: strong_password,\n                                      profile: User::CONTRIBUTOR,\n                                      text_filter_name: \"markdown\",\n                                      nickname: \"fooo\", firstname: \"bar\" } }\n    end\n\n    it \"redirects to the index\" do\n      expect(response).to redirect_to(action: \"index\")\n    end\n  end\n\n  describe \"#update\" do\n    let(:user) { admin }\n\n    before do\n      sign_in user\n    end\n\n    it \"redirects to index\" do\n      post :update, params: { id: contributor.id,\n                              user: { login: \"errand\",\n                                      email: \"corey@test.com\",\n                                      password: strong_password,\n                                      password_confirmation: strong_password } }\n      expect(response).to redirect_to(action: \"index\")\n    end\n\n    it \"skips blank passwords\" do\n      post :update, params: { id: contributor.id,\n                              user: { login: \"errand\",\n                                      password: \"\", password_confirmation: \"\" } }\n      contributor.reload\n      aggregate_failures do\n        expect(response).to redirect_to(action: \"index\")\n        expect(contributor).not_to be_valid_password(\"\")\n      end\n    end\n\n    describe \"when you are not admin\" do\n      let(:user) { publisher }\n\n      before do\n        post :update, params: { id: contributor.id, user: { profile: User::PUBLISHER } }\n      end\n\n      it \"redirects to login\" do\n        expect(response).to redirect_to(controller: \"/admin/dashboard\", action: \"index\")\n      end\n\n      it \"does not change user profile\" do\n        u = contributor.reload\n        expect(u.profile).to eq User::CONTRIBUTOR\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\ndescribe SetupController, type: :controller do\n  let(:strong_password) { \"fhnehnhfiiuh\" }\n\n  describe \"#index\" do\n    describe \"when no blog is configured\" do\n      before do\n        # Set up database similar to result of seeding\n        @blog = Blog.create\n        get \"index\"\n      end\n\n      specify { expect(response).to render_template(\"index\") }\n    end\n\n    describe \"when a blog is configured and has some users\" do\n      before do\n        create(:blog)\n        get \"index\"\n      end\n\n      specify { expect(response).to redirect_to(controller: \"articles\", action: \"index\") }\n    end\n  end\n\n  describe \"#create\" do\n    context \"when no blog is configured\" do\n      before do\n        # Set up database similar to result of seeding\n        @blog = Blog.create\n      end\n\n      context \"when passing correct parameters\" do\n        before do\n          ActionMailer::Base.deliveries.clear\n          post :create, params: { setting: { blog_name: \"Foo\", email: \"foo@bar.net\",\n                                             password: strong_password } }\n        end\n\n        it \"correctly initializes blog and users\" do\n          expect(Blog.first.blog_name).to eq(\"Foo\")\n          admin = User.find_by(login: \"admin\")\n          expect(admin).not_to be_nil\n          expect(admin.email).to eq(\"foo@bar.net\")\n          expect(Article.first.user).to eq(admin)\n          expect(Page.first.user).to eq(admin)\n        end\n\n        it \"logs in admin user\" do\n          expect(controller.current_user).to eq(User.find_by(login: \"admin\"))\n        end\n\n        it \"redirects to confirm the setup\" do\n          expect(response).to redirect_to(controller: \"accounts\",\n                                          action: \"confirm\")\n        end\n\n        it \"sends a confirmation email\" do\n          expect(ActionMailer::Base.deliveries.size).to eq 1\n        end\n      end\n\n      describe \"when passing incorrect parameters\" do\n        it \"empty blog name should raise an error\" do\n          post :create, params: { setting: { blog_name: \"\", email: \"foo@bar.net\",\n                                             password: strong_password } }\n          expect(response).to redirect_to(action: \"index\")\n        end\n\n        it \"empty email should raise an error\" do\n          post :create, params: { setting: { blog_name: \"Foo\", email: \"\",\n                                             password: strong_password } }\n          expect(response).to redirect_to(action: \"index\")\n        end\n\n        it \"empty password should raise an error\" do\n          post :create, params: { setting: { blog_name: \"Foo\", email: \"foo@bar.net\",\n                                             password: \"\" } }\n          expect(response).to redirect_to(action: \"index\")\n        end\n\n        it \"weak password should raise an error\" do\n          post :create, params: { setting: { blog_name: \"Foo\", email: \"foo@bar.net\",\n                                             password: \"foo123bar\" } }\n          expect(response).to redirect_to(action: \"index\")\n        end\n      end\n    end\n\n    describe \"when a blog is configured and has some users\" do\n      before do\n        create(:blog)\n        post :create, params: { setting: { blog_name: \"Foo\", email: \"foo@bar.net\" } }\n      end\n\n      specify { expect(response).to redirect_to(controller: \"articles\", action: \"index\") }\n\n      it \"does not initialize blog and users\" do\n        expect(Blog.first.blog_name).not_to eq(\"Foo\")\n        admin = User.find_by(login: \"admin\")\n        expect(admin).to be_nil\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\nRSpec.feature \"Logging in\", type: :feature do\n  let(:strong_password) { \"fhnehnhfiiuh\" }\n\n  before do\n    stub_request(:get,\n                 \"http://www.google.com/search?output=rss&q=link:www.example.com&tbm=blg\").\n      to_return(status: 200, body: \"\", headers: {})\n    load Rails.root.join(\"db/seeds.rb\")\n    Blog.first.update blog_name: \"Awesome!\", base_url: \"http://www.example.com/\"\n    create :user, :as_admin, login: \"admin\", password: strong_password\n  end\n\n  scenario \"Admin logs in\" do\n    visit \"/admin\"\n    fill_in :user_login, with: \"admin\"\n    fill_in :user_password, with: strong_password\n\n    click_button I18n.t(\"devise.sessions.new.sign_in\")\n\n    expect(page).to have_text I18n.t(\"devise.sessions.signed_in\")\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\nRSpec.feature \"Logging in\", type: :feature do\n  before do\n    load Rails.root.join(\"db/seeds.rb\")\n    Blog.first.update blog_name: \"Awesome!\", base_url: \"http://www.example.com/\"\n    create :user, :as_admin, login: \"admin\", password: \"Fo_rgEt-1m5e2\"\n  end\n\n  scenario \"Admin resets password\" do\n    visit \"/admin\"\n    click_link I18n.t(\"accounts.lost_my_password\")\n\n    fill_in :user_email, with: User.last.email\n    click_button I18n.t(\"devise.passwords.new.send_me_reset_password_instructions\")\n\n    mail = ActionMailer::Base.deliveries.last\n    html = Nokogiri::HTML.parse mail.body.raw_source\n    link = html.at_css \"a\"\n    url = link.attribute(\"href\").value\n\n    visit url\n\n    fill_in :user_password, with: \"a5-SeCre1T4\"\n    fill_in :user_password_confirmation, with: \"a5-SeCre1T4\"\n\n    click_button I18n.t(\"devise.passwords.edit.change_my_password\")\n    expect(page).to have_text I18n.t(\"devise.passwords.updated\")\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\nRSpec.feature \"Blog setup\", type: :feature do\n  let(:strong_password) { \"fhnehnhfiiuh\" }\n\n  before do\n    stub_request(:get,\n                 \"http://www.google.com/search?output=rss&q=link:www.example.com&tbm=blg\").\n      to_return(status: 200, body: \"\", headers: {})\n    load Rails.root.join(\"db/seeds.rb\")\n  end\n\n  scenario \"User accesses blog for the first time\" do\n    # Go to the blog setup\n    visit \"/\"\n    expect(page).to have_text I18n.t!(\"setup.index.welcome_to_your_blog_setup\")\n\n    # Set up the blog\n    fill_in :setting_blog_name, with: \"Awesome blog\"\n    fill_in :setting_email, with: \"foo@bar.com\"\n    fill_in :setting_password, with: strong_password\n    click_button I18n.t!(\"generic.save\")\n\n    # Confirm set up success\n    expect(page).to have_text I18n.t!(\"accounts.confirm.success\")\n    expect(page).to have_text I18n.t!(\"accounts.confirm.login\", login: \"admin\")\n\n    # Visit the autogenerated article\n    click_link I18n.t!(\"accounts.confirm.admin\")\n    click_link I18n.t!(\"admin.shared.menu.all_articles\")\n    find(\"tbody#articleList td a.published\").click\n\n    expect(page).to have_text I18n.t!(\"setup.article.title\")\n\n    # Confirm ability to log in\n    visit admin_dashboard_path\n    find(\"a[href=\\\"#{destroy_user_session_path}\\\"]\").click\n\n    visit admin_dashboard_path\n    fill_in :user_login, with: \"admin\"\n    fill_in :user_password, with: strong_password\n    find(\"input[type=submit]\").click\n    expect(page).to have_text I18n.t!(\"admin.dashboard.index.welcome_back\",\n                                      user_name: \"admin\")\n\n    # Confirm proper setting fo user properties\n    expect(User.first.email).to eq \"foo@bar.com\"\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\nRSpec.feature \"Signing up\", type: :feature do\n  let(:strong_password) { \"whhefwhfwefhiu\" }\n\n  before do\n    load Rails.root.join(\"db/seeds.rb\")\n    Blog.first.update(blog_name: \"Awesome!\",\n                      base_url: \"http://www.example.com/\",\n                      allow_signup: 1)\n    create :user, :as_admin, login: \"admin\"\n  end\n\n  scenario \"User signs up for an account\" do\n    visit admin_dashboard_path\n    click_link I18n.t(\"accounts.create_account\")\n\n    # Create account\n    fill_in :user_login, with: \"hello\"\n    fill_in :user_email, with: \"hello@hello.com\"\n    fill_in :user_password, with: strong_password\n    fill_in :user_password_confirmation, with: strong_password\n    click_button I18n.t!(\"devise.registrations.new.sign_up\")\n\n    # Confirm creation success\n    expect(page).to have_text I18n.t!(\"devise.registrations.signed_up\")\n\n    # Sign out\n    visit admin_dashboard_path\n    find(\"a[href=\\\"#{destroy_user_session_path}\\\"]\").click\n\n    # Confirm ability to sign in\n    visit admin_dashboard_path\n    fill_in :user_login, with: \"hello\"\n    fill_in :user_password, with: strong_password\n    find(\"input[type=submit]\").click\n    expect(page).to have_text I18n.t!(\"devise.sessions.signed_in\")\n\n    # Confirm proper setting fo user properties\n    u = User.last\n    expect(u.email).to eq \"hello@hello.com\"\n    expect(u.profile).to eq \"contributor\"\n  end\n\n  scenario \"Disallow account sign-up link with a blog setting\" do\n    Blog.first.update(allow_signup: 0)\n    visit admin_dashboard_path\n    expect(page).not_to have_link I18n.t(\"accounts.create_account\")\n\n    visit new_user_registration_path\n\n    expect(page.status_code).to eq 404\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\ndescribe User, type: :model do\n  describe \"FactoryBot Bot\" do\n    it \"users factory valid\" do\n      expect(create(:user)).to be_valid\n      expect(build(:user)).to be_valid\n    end\n\n    it \"multiples user factory valid\" do\n      expect(create(:user)).to be_valid\n      expect(create(:user)).to be_valid\n    end\n\n    it \"salt should not be nil\" do\n      expect(described_class.salt).to eq(\"20ac4d290c2293702c64b3b287ae5ea79b26a5c1\")\n    end\n  end\n\n  describe \"#active_for_authentication?\" do\n    it \"is true for users in the state 'active'\" do\n      user = build :user, state: \"active\"\n      expect(user).to be_active_for_authentication\n    end\n\n    it \"is false for users in the state 'inactive'\" do\n      user = build :user, state: \"inactive\"\n      expect(user).not_to be_active_for_authentication\n    end\n  end\n\n  context \"With the contents and users fixtures loaded\" do\n    it \"The various article finders work appropriately\" do\n      create(:blog)\n      tobi = create(:user)\n      create_list(:article, 7, user: tobi)\n      create(:article, state: \"draft\", published_at: nil, user: tobi)\n      expect(tobi.articles.size).to eq(8)\n      expect(tobi.articles.published.size).to eq(7)\n    end\n  end\n\n  describe \"validations\" do\n    let(:user) { described_class.new }\n\n    it \"requires email to not be too long\" do\n      expect(user).to validate_length_of(:email).is_at_most(255)\n    end\n\n    it \"requires name to not be too long\" do\n      expect(user).to validate_length_of(:name).is_at_most(2048)\n    end\n\n    it \"requires first name to not be too long\" do\n      expect(user).to validate_length_of(:firstname).is_at_most(256)\n    end\n\n    it \"requires last name to not be too long\" do\n      expect(user).to validate_length_of(:lastname).is_at_most(256)\n    end\n\n    it \"requires the email field to be present\" do\n      expect(user).to validate_presence_of(:email)\n    end\n\n    it \"requires the email field to always be unique\" do\n      expect(user).to validate_uniqueness_of(:email)\n    end\n\n    it \"requires the login field to always be unique\" do\n      expect(user).to validate_uniqueness_of(:login).case_insensitive\n    end\n\n    it \"requires the login field to be of reasonable length\" do\n      expect(user).to validate_length_of(:login).is_at_least(3).is_at_most(40)\n    end\n\n    it \"requires the login field to be present\" do\n      expect(user).to validate_presence_of(:login)\n    end\n\n    it \"requires text_filter_name to not be too long\" do\n      expect(user).to validate_length_of(:text_filter_name).is_at_most(255)\n    end\n\n    it \"does not allow duplicate logins when updating a user\" do\n      create :user, login: \"foo\"\n      bar = create :user, login: \"bar\"\n\n      expect(bar).not_to allow_value(\"foo\").for(:login)\n    end\n\n    it \"does not allow duplicate emails when updating a user\" do\n      create :user, email: \"foo@foo.com\"\n      bar = create :user, email: \"bar@bar.com\"\n\n      expect(bar).not_to allow_value(\"foo@foo.com\").for(:email)\n    end\n\n    it \"requires a strong password\" do\n      nearly_valid_user = build(:user)\n      expect(nearly_valid_user).not_to allow_value(\"password01\").for(:password)\n    end\n  end\n\n  describe \"#initialize\" do\n    it \"accepts a settings field in its parameter hash\" do\n      described_class.new(\"firstname\" => \"foo\")\n    end\n  end\n\n  describe \"#admin?\" do\n    it \"returns true if user is admin\" do\n      admin = build(:user, :as_admin)\n      expect(admin).to be_admin\n    end\n\n    it \"returns false if user is not admin\" do\n      publisher = build(:user, :as_publisher)\n      expect(publisher).not_to be_admin\n    end\n  end\n\n  describe \"#first_and_last_name\" do\n    context \"with first and last name\" do\n      let(:user) { create(:user, firstname: \"Marlon\", lastname: \"Brando\") }\n\n      it { expect(user.first_and_last_name).to eq(\"Marlon Brando\") }\n    end\n\n    context \"with firstname without lastname\" do\n      let(:user) { create(:user, firstname: \"Marlon\", lastname: nil) }\n\n      it { expect(user.first_and_last_name).to eq(\"\") }\n    end\n  end\n\n  describe \"#display_names\" do\n    context \"with user without nickname, firstname, lastname\" do\n      let(:user) { create(:user, nickname: nil, firstname: nil, lastname: nil) }\n\n      it { expect(user.display_names).to eq([user.login]) }\n    end\n\n    context \"with user with nickname without firstname, lastname\" do\n      let(:user) { create(:user, nickname: \"Bob\", firstname: nil, lastname: nil) }\n\n      it { expect(user.display_names).to eq([user.login, user.nickname]) }\n    end\n\n    context \"with user with firstname, without nickname, lastname\" do\n      let(:user) { create(:user, nickname: nil, firstname: \"Robert\", lastname: nil) }\n\n      it { expect(user.display_names).to eq([user.login, user.firstname]) }\n    end\n\n    context \"with user with lastname, without nickname, firstname\" do\n      let(:user) { create(:user, nickname: nil, firstname: nil, lastname: \"Redford\") }\n\n      it { expect(user.display_names).to eq([user.login, user.lastname]) }\n    end\n\n    context \"with user with firstname and lastname, witjout nickname\" do\n      let(:user) { create(:user, nickname: nil, firstname: \"Robert\", lastname: \"Redford\") }\n\n      it {\n        expect(user.display_names).\n          to eq([user.login, user.firstname, user.lastname,\n                 \"#{user.firstname} #{user.lastname}\"])\n      }\n    end\n  end\n\n  describe \"#has_twitter_configured?\" do\n    it \"is false without twitter_oauth_token or twitter_oauth_token_secret\" do\n      user = build(:user, twitter_oauth_token: nil, twitter_oauth_token_secret: nil)\n      expect(user.has_twitter_configured?).to eq(false)\n    end\n\n    it \"is false with an empty twitter_oauth_token and no twitter_oauth_token_secret\" do\n      user = build(:user, twitter_oauth_token: \"\", twitter_oauth_token_secret: nil)\n      expect(user.has_twitter_configured?).to eq(false)\n    end\n\n    it \"is false with empty twitter_oauth_token and twitter_oauth_token_secret\" do\n      user = build(:user, twitter_oauth_token: \"\", twitter_oauth_token_secret: \"\")\n      expect(user.has_twitter_configured?).to eq(false)\n    end\n\n    it \"is false with a twitter_oauth_token and no twitter_oauth_token_secret\" do\n      user = build(:user, twitter_oauth_token: \"12345\", twitter_oauth_token_secret: nil)\n      expect(user.has_twitter_configured?).to eq(false)\n    end\n\n    it \"is false with a twitter_oauth_token and an empty twitter_oauth_token_secret\" do\n      user = build(:user, twitter_oauth_token: \"12345\", twitter_oauth_token_secret: \"\")\n      expect(user.has_twitter_configured?).to eq(false)\n    end\n\n    it \"is false with a twitter_oauth_token_secret and no twitter_oauth_token\" do\n      user = build(:user, twitter_oauth_token: \"\", twitter_oauth_token_secret: \"67890\")\n      expect(user.has_twitter_configured?).to eq(false)\n    end\n\n    it \"is false with a twitter_oauth_token_secret and an empty twitter_oauth_token\" do\n      user = build(:user, twitter_oauth_token_secret: \"67890\", twitter_oauth_token: \"\")\n      expect(user.has_twitter_configured?).to eq(false)\n    end\n\n    it \"is true with a twitter_oauth_token and a twitter_oauth_token_secret\" do\n      user = build(:user, twitter_oauth_token: \"12345\", twitter_oauth_token_secret: \"67890\")\n      expect(user.has_twitter_configured?).to eq(true)\n    end\n  end\nend\n"], "filenames": ["publify_core/app/models/user.rb", "publify_core/lib/publify_core.rb", "publify_core/lib/publify_core/testing_support/factories.rb", "publify_core/publify_core.gemspec", "publify_core/spec/controllers/admin/users_controller_spec.rb", "publify_core/spec/controllers/setup_controller_spec.rb", "publify_core/spec/features/login_spec.rb", "publify_core/spec/features/reset_password_spec.rb", "publify_core/spec/features/setup_spec.rb", "publify_core/spec/features/signup_spec.rb", "publify_core/spec/models/user_spec.rb"], "buggy_code_start_loc": [15, 4, 24, 30, 9, 5, 5, 9, 5, 5, 100], "buggy_code_end_loc": [16, 4, 25, 30, 75, 79, 19, 28, 42, 36, 100], "fixing_code_start_loc": [15, 5, 24, 31, 10, 6, 6, 9, 6, 6, 101], "fixing_code_end_loc": [16, 6, 25, 32, 77, 88, 21, 28, 44, 38, 106], "type": "CWE-521", "message": "Weak Password Requirements in GitHub repository publify/publify prior to 9.2.10.", "other": {"cve": {"id": "CVE-2023-0569", "sourceIdentifier": "security@huntr.dev", "published": "2023-01-29T17:15:08.633", "lastModified": "2023-02-06T18:33:04.097", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Weak Password Requirements in GitHub repository publify/publify prior to 9.2.10."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-521"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:publify_project:publify:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.2.10", "matchCriteriaId": "F96D7B8E-CB71-4E0F-807E-E1BE71D1C939"}]}]}], "references": [{"url": "https://github.com/publify/publify/commit/8905e4e639cf03b758da558568a86c9816253b2d", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/81b1e1da-10dd-435e-94ae-4bdd41df6df9", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/publify/publify/commit/8905e4e639cf03b758da558568a86c9816253b2d"}}