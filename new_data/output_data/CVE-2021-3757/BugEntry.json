{"buggy_code": ["\"use strict\"\nimport produce, {\n\tsetUseProxies,\n\tapplyPatches,\n\tproduceWithPatches,\n\tenableAllPlugins,\n\tisDraft,\n\timmerable,\n\tnothing\n} from \"../src/immer\"\n\nenableAllPlugins()\n\njest.setTimeout(1000)\n\nconst isProd = process.env.NODE_ENV === \"production\"\n\nfunction runPatchTest(base, producer, patches, inversePathes) {\n\tlet resultProxies, resultEs5\n\n\tfunction runPatchTestHelper() {\n\t\tlet recordedPatches\n\t\tlet recordedInversePatches\n\t\tconst res = produce(base, producer, (p, i) => {\n\t\t\trecordedPatches = p\n\t\t\trecordedInversePatches = i\n\t\t})\n\n\t\ttest(\"produces the correct patches\", () => {\n\t\t\texpect(recordedPatches).toEqual(patches)\n\t\t\tif (inversePathes) expect(recordedInversePatches).toEqual(inversePathes)\n\t\t})\n\n\t\ttest(\"patches are replayable\", () => {\n\t\t\texpect(applyPatches(base, recordedPatches)).toEqual(res)\n\t\t})\n\n\t\ttest(\"patches can be reversed\", () => {\n\t\t\texpect(applyPatches(res, recordedInversePatches)).toEqual(base)\n\t\t})\n\n\t\treturn res\n\t}\n\n\tdescribe(`proxy`, () => {\n\t\tsetUseProxies(true)\n\t\tresultProxies = runPatchTestHelper()\n\t})\n\n\tdescribe(`es5`, () => {\n\t\tsetUseProxies(false)\n\t\tresultEs5 = runPatchTestHelper()\n\t\ttest(\"ES5 and Proxy implementation yield same result\", () => {\n\t\t\texpect(resultEs5).toEqual(resultProxies)\n\t\t})\n\t})\n\n\treturn resultProxies\n}\n\ndescribe(\"applyPatches\", () => {\n\tit(\"mutates the base state when it is a draft\", () => {\n\t\tproduce({a: 1}, draft => {\n\t\t\tconst result = applyPatches(draft, [\n\t\t\t\t{op: \"replace\", path: [\"a\"], value: 2}\n\t\t\t])\n\t\t\texpect(result).toBe(draft)\n\t\t\texpect(draft.a).toBe(2)\n\t\t})\n\t})\n\tit(\"produces a copy of the base state when not a draft\", () => {\n\t\tconst base = {a: 1}\n\t\tconst result = applyPatches(base, [{op: \"replace\", path: [\"a\"], value: 2}])\n\t\texpect(result).not.toBe(base)\n\t\texpect(result.a).toBe(2)\n\t\texpect(base.a).toBe(1)\n\t})\n\tit('throws when `op` is not \"add\", \"replace\", nor \"remove\"', () => {\n\t\texpect(() => {\n\t\t\tconst patch = {op: \"copy\", from: [0], path: [1]}\n\t\t\tapplyPatches([2], [patch])\n\t\t}).toThrowErrorMatchingSnapshot()\n\t})\n\tit(\"throws when `path` cannot be resolved\", () => {\n\t\t// missing parent\n\t\texpect(() => {\n\t\t\tconst patch = {op: \"add\", path: [\"a\", \"b\"], value: 1}\n\t\t\tapplyPatches({}, [patch])\n\t\t}).toThrowErrorMatchingSnapshot()\n\n\t\t// missing grand-parent\n\t\texpect(() => {\n\t\t\tconst patch = {op: \"add\", path: [\"a\", \"b\", \"c\"], value: 1}\n\t\t\tapplyPatches({}, [patch])\n\t\t}).toThrowErrorMatchingSnapshot()\n\t})\n\tit(\"applied patches cannot be modified\", () => {\n\t\t// see also: https://github.com/immerjs/immer/issues/411\n\t\tconst s0 = {\n\t\t\titems: [1]\n\t\t}\n\n\t\tconst [s1, p1] = produceWithPatches(s0, draft => {\n\t\t\tdraft.items = []\n\t\t})\n\n\t\tconst replaceValueBefore = p1[0].value.slice()\n\n\t\tconst [s2, p2] = produceWithPatches(s1, draft => {\n\t\t\tdraft.items.push(2)\n\t\t})\n\n\t\tapplyPatches(s0, [...p1, ...p2])\n\n\t\tconst replaceValueAfter = p1[0].value.slice()\n\n\t\texpect(replaceValueAfter).toStrictEqual(replaceValueBefore)\n\t})\n})\n\ndescribe(\"simple assignment - 1\", () => {\n\trunPatchTest(\n\t\t{x: 3},\n\t\td => {\n\t\t\td.x++\n\t\t},\n\t\t[{op: \"replace\", path: [\"x\"], value: 4}]\n\t)\n})\n\ndescribe(\"simple assignment - 2\", () => {\n\trunPatchTest(\n\t\t{x: {y: 4}},\n\t\td => {\n\t\t\td.x.y++\n\t\t},\n\t\t[{op: \"replace\", path: [\"x\", \"y\"], value: 5}]\n\t)\n})\n\ndescribe(\"simple assignment - 3\", () => {\n\trunPatchTest(\n\t\t{x: [{y: 4}]},\n\t\td => {\n\t\t\td.x[0].y++\n\t\t},\n\t\t[{op: \"replace\", path: [\"x\", 0, \"y\"], value: 5}]\n\t)\n})\n\ndescribe(\"simple assignment - 4\", () => {\n\trunPatchTest(\n\t\tnew Map([[\"x\", {y: 4}]]),\n\t\td => {\n\t\t\td.get(\"x\").y++\n\t\t},\n\t\t[{op: \"replace\", path: [\"x\", \"y\"], value: 5}],\n\t\t[{op: \"replace\", path: [\"x\", \"y\"], value: 4}]\n\t)\n})\n\ndescribe(\"simple assignment - 5\", () => {\n\trunPatchTest(\n\t\t{x: new Map([[\"y\", 4]])},\n\t\td => {\n\t\t\td.x.set(\"y\", 5)\n\t\t},\n\t\t[{op: \"replace\", path: [\"x\", \"y\"], value: 5}],\n\t\t[{op: \"replace\", path: [\"x\", \"y\"], value: 4}]\n\t)\n})\n\ndescribe(\"simple assignment - 6\", () => {\n\trunPatchTest(\n\t\tnew Map([[\"x\", 1]]),\n\t\td => {\n\t\t\t// Map.prototype.set should return the Map itself\n\t\t\tconst res = d.set(\"x\", 2)\n\t\t\tres.set(\"y\", 3)\n\t\t},\n\t\t[\n\t\t\t{op: \"replace\", path: [\"x\"], value: 2},\n\t\t\t{op: \"add\", path: [\"y\"], value: 3}\n\t\t],\n\t\t[\n\t\t\t{op: \"replace\", path: [\"x\"], value: 1},\n\t\t\t{op: \"remove\", path: [\"y\"]}\n\t\t]\n\t)\n})\n\ndescribe(\"simple assignment - 7\", () => {\n\tconst key1 = {prop: \"val1\"}\n\tconst key2 = {prop: \"val2\"}\n\trunPatchTest(\n\t\t{x: new Map([[key1, 4]])},\n\t\td => {\n\t\t\td.x.set(key1, 5)\n\t\t\td.x.set(key2, 6)\n\t\t},\n\t\t[\n\t\t\t{op: \"replace\", path: [\"x\", key1], value: 5},\n\t\t\t{op: \"add\", path: [\"x\", key2], value: 6}\n\t\t],\n\t\t[\n\t\t\t{op: \"replace\", path: [\"x\", key1], value: 4},\n\t\t\t{op: \"remove\", path: [\"x\", key2]}\n\t\t]\n\t)\n})\n\ndescribe(\"delete 1\", () => {\n\trunPatchTest(\n\t\t{x: {y: 4}},\n\t\td => {\n\t\t\tdelete d.x\n\t\t},\n\t\t[{op: \"remove\", path: [\"x\"]}]\n\t)\n})\n\ndescribe(\"delete 2\", () => {\n\trunPatchTest(\n\t\tnew Map([[\"x\", 1]]),\n\t\td => {\n\t\t\td.delete(\"x\")\n\t\t},\n\t\t[{op: \"remove\", path: [\"x\"]}],\n\t\t[{op: \"add\", path: [\"x\"], value: 1}]\n\t)\n})\n\ndescribe(\"delete 3\", () => {\n\trunPatchTest(\n\t\t{x: new Map([[\"y\", 1]])},\n\t\td => {\n\t\t\td.x.delete(\"y\")\n\t\t},\n\t\t[{op: \"remove\", path: [\"x\", \"y\"]}],\n\t\t[{op: \"add\", path: [\"x\", \"y\"], value: 1}]\n\t)\n})\n\ndescribe(\"delete 5\", () => {\n\tconst key1 = {prop: \"val1\"}\n\tconst key2 = {prop: \"val2\"}\n\trunPatchTest(\n\t\t{\n\t\t\tx: new Map([\n\t\t\t\t[key1, 1],\n\t\t\t\t[key2, 2]\n\t\t\t])\n\t\t},\n\t\td => {\n\t\t\td.x.delete(key1)\n\t\t\td.x.delete(key2)\n\t\t},\n\t\t[\n\t\t\t{op: \"remove\", path: [\"x\", key1]},\n\t\t\t{op: \"remove\", path: [\"x\", key2]}\n\t\t],\n\t\t[\n\t\t\t{op: \"add\", path: [\"x\", key1], value: 1},\n\t\t\t{op: \"add\", path: [\"x\", key2], value: 2}\n\t\t]\n\t)\n})\n\ndescribe(\"delete 6\", () => {\n\trunPatchTest(\n\t\tnew Set([\"x\", 1]),\n\t\td => {\n\t\t\td.delete(\"x\")\n\t\t},\n\t\t[{op: \"remove\", path: [0], value: \"x\"}],\n\t\t[{op: \"add\", path: [0], value: \"x\"}]\n\t)\n})\n\ndescribe(\"delete 7\", () => {\n\trunPatchTest(\n\t\t{x: new Set([\"y\", 1])},\n\t\td => {\n\t\t\td.x.delete(\"y\")\n\t\t},\n\t\t[{op: \"remove\", path: [\"x\", 0], value: \"y\"}],\n\t\t[{op: \"add\", path: [\"x\", 0], value: \"y\"}]\n\t)\n})\n\ndescribe(\"renaming properties\", () => {\n\tdescribe(\"nested object (no changes)\", () => {\n\t\trunPatchTest(\n\t\t\t{a: {b: 1}},\n\t\t\td => {\n\t\t\t\td.x = d.a\n\t\t\t\tdelete d.a\n\t\t\t},\n\t\t\t[\n\t\t\t\t{op: \"add\", path: [\"x\"], value: {b: 1}},\n\t\t\t\t{op: \"remove\", path: [\"a\"]}\n\t\t\t]\n\t\t)\n\t})\n\n\tdescribe(\"nested change in object\", () => {\n\t\trunPatchTest(\n\t\t\t{\n\t\t\t\ta: {b: 1}\n\t\t\t},\n\t\t\td => {\n\t\t\t\td.a.b++\n\t\t\t},\n\t\t\t[{op: \"replace\", path: [\"a\", \"b\"], value: 2}],\n\t\t\t[{op: \"replace\", path: [\"a\", \"b\"], value: 1}]\n\t\t)\n\t})\n\n\tdescribe(\"nested change in map\", () => {\n\t\trunPatchTest(\n\t\t\tnew Map([[\"a\", new Map([[\"b\", 1]])]]),\n\t\t\td => {\n\t\t\t\td.get(\"a\").set(\"b\", 2)\n\t\t\t},\n\t\t\t[{op: \"replace\", path: [\"a\", \"b\"], value: 2}],\n\t\t\t[{op: \"replace\", path: [\"a\", \"b\"], value: 1}]\n\t\t)\n\t})\n\n\tdescribe(\"nested change in array\", () => {\n\t\trunPatchTest(\n\t\t\t[[{b: 1}]],\n\t\t\td => {\n\t\t\t\td[0][0].b++\n\t\t\t},\n\t\t\t[{op: \"replace\", path: [0, 0, \"b\"], value: 2}],\n\t\t\t[{op: \"replace\", path: [0, 0, \"b\"], value: 1}]\n\t\t)\n\t})\n\n\tdescribe(\"nested map (no changes)\", () => {\n\t\trunPatchTest(\n\t\t\tnew Map([[\"a\", new Map([[\"b\", 1]])]]),\n\t\t\td => {\n\t\t\t\td.set(\"x\", d.get(\"a\"))\n\t\t\t\td.delete(\"a\")\n\t\t\t},\n\t\t\t[\n\t\t\t\t{op: \"add\", path: [\"x\"], value: new Map([[\"b\", 1]])},\n\t\t\t\t{op: \"remove\", path: [\"a\"]}\n\t\t\t],\n\t\t\t[\n\t\t\t\t{op: \"remove\", path: [\"x\"]},\n\t\t\t\t{op: \"add\", path: [\"a\"], value: new Map([[\"b\", 1]])}\n\t\t\t]\n\t\t)\n\t})\n\n\tdescribe(\"nested object (with changes)\", () => {\n\t\trunPatchTest(\n\t\t\t{a: {b: 1, c: 1}},\n\t\t\td => {\n\t\t\t\tlet a = d.a\n\t\t\t\ta.b = 2 // change\n\t\t\t\tdelete a.c // delete\n\t\t\t\ta.y = 2 // add\n\n\t\t\t\t// rename\n\t\t\t\td.x = a\n\t\t\t\tdelete d.a\n\t\t\t},\n\t\t\t[\n\t\t\t\t{op: \"add\", path: [\"x\"], value: {b: 2, y: 2}},\n\t\t\t\t{op: \"remove\", path: [\"a\"]}\n\t\t\t]\n\t\t)\n\t})\n\n\tdescribe(\"nested map (with changes)\", () => {\n\t\trunPatchTest(\n\t\t\tnew Map([\n\t\t\t\t[\n\t\t\t\t\t\"a\",\n\t\t\t\t\tnew Map([\n\t\t\t\t\t\t[\"b\", 1],\n\t\t\t\t\t\t[\"c\", 1]\n\t\t\t\t\t])\n\t\t\t\t]\n\t\t\t]),\n\t\t\td => {\n\t\t\t\tlet a = d.get(\"a\")\n\t\t\t\ta.set(\"b\", 2) // change\n\t\t\t\ta.delete(\"c\") // delete\n\t\t\t\ta.set(\"y\", 2) // add\n\n\t\t\t\t// rename\n\t\t\t\td.set(\"x\", a)\n\t\t\t\td.delete(\"a\")\n\t\t\t},\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\top: \"add\",\n\t\t\t\t\tpath: [\"x\"],\n\t\t\t\t\tvalue: new Map([\n\t\t\t\t\t\t[\"b\", 2],\n\t\t\t\t\t\t[\"y\", 2]\n\t\t\t\t\t])\n\t\t\t\t},\n\t\t\t\t{op: \"remove\", path: [\"a\"]}\n\t\t\t],\n\t\t\t[\n\t\t\t\t{op: \"remove\", path: [\"x\"]},\n\t\t\t\t{\n\t\t\t\t\top: \"add\",\n\t\t\t\t\tpath: [\"a\"],\n\t\t\t\t\tvalue: new Map([\n\t\t\t\t\t\t[\"b\", 1],\n\t\t\t\t\t\t[\"c\", 1]\n\t\t\t\t\t])\n\t\t\t\t}\n\t\t\t]\n\t\t)\n\t})\n\n\tdescribe(\"deeply nested object (with changes)\", () => {\n\t\trunPatchTest(\n\t\t\t{a: {b: {c: 1, d: 1}}},\n\t\t\td => {\n\t\t\t\tlet b = d.a.b\n\t\t\t\tb.c = 2 // change\n\t\t\t\tdelete b.d // delete\n\t\t\t\tb.y = 2 // add\n\n\t\t\t\t// rename\n\t\t\t\td.a.x = b\n\t\t\t\tdelete d.a.b\n\t\t\t},\n\t\t\t[\n\t\t\t\t{op: \"add\", path: [\"a\", \"x\"], value: {c: 2, y: 2}},\n\t\t\t\t{op: \"remove\", path: [\"a\", \"b\"]}\n\t\t\t]\n\t\t)\n\t})\n\n\tdescribe(\"deeply nested map (with changes)\", () => {\n\t\trunPatchTest(\n\t\t\tnew Map([\n\t\t\t\t[\n\t\t\t\t\t\"a\",\n\t\t\t\t\tnew Map([\n\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\"b\",\n\t\t\t\t\t\t\tnew Map([\n\t\t\t\t\t\t\t\t[\"c\", 1],\n\t\t\t\t\t\t\t\t[\"d\", 1]\n\t\t\t\t\t\t\t])\n\t\t\t\t\t\t]\n\t\t\t\t\t])\n\t\t\t\t]\n\t\t\t]),\n\t\t\td => {\n\t\t\t\tlet b = d.get(\"a\").get(\"b\")\n\t\t\t\tb.set(\"c\", 2) // change\n\t\t\t\tb.delete(\"d\") // delete\n\t\t\t\tb.set(\"y\", 2) // add\n\n\t\t\t\t// rename\n\t\t\t\td.get(\"a\").set(\"x\", b)\n\t\t\t\td.get(\"a\").delete(\"b\")\n\t\t\t},\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\top: \"add\",\n\t\t\t\t\tpath: [\"a\", \"x\"],\n\t\t\t\t\tvalue: new Map([\n\t\t\t\t\t\t[\"c\", 2],\n\t\t\t\t\t\t[\"y\", 2]\n\t\t\t\t\t])\n\t\t\t\t},\n\t\t\t\t{op: \"remove\", path: [\"a\", \"b\"]}\n\t\t\t],\n\t\t\t[\n\t\t\t\t{op: \"remove\", path: [\"a\", \"x\"]},\n\t\t\t\t{\n\t\t\t\t\top: \"add\",\n\t\t\t\t\tpath: [\"a\", \"b\"],\n\t\t\t\t\tvalue: new Map([\n\t\t\t\t\t\t[\"c\", 1],\n\t\t\t\t\t\t[\"d\", 1]\n\t\t\t\t\t])\n\t\t\t\t}\n\t\t\t]\n\t\t)\n\t})\n})\n\ndescribe(\"minimum amount of changes\", () => {\n\trunPatchTest(\n\t\t{x: 3, y: {a: 4}, z: 3},\n\t\td => {\n\t\t\td.y.a = 4\n\t\t\td.y.b = 5\n\t\t\tObject.assign(d, {x: 4, y: {a: 2}})\n\t\t},\n\t\t[\n\t\t\t{op: \"replace\", path: [\"x\"], value: 4},\n\t\t\t{op: \"replace\", path: [\"y\"], value: {a: 2}}\n\t\t]\n\t)\n})\n\ndescribe(\"arrays - prepend\", () => {\n\trunPatchTest(\n\t\t{x: [1, 2, 3]},\n\t\td => {\n\t\t\td.x.unshift(4)\n\t\t},\n\t\t[\n\t\t\t{op: \"replace\", path: [\"x\", 0], value: 4},\n\t\t\t{op: \"replace\", path: [\"x\", 1], value: 1},\n\t\t\t{op: \"replace\", path: [\"x\", 2], value: 2},\n\t\t\t{op: \"add\", path: [\"x\", 3], value: 3}\n\t\t]\n\t)\n})\n\ndescribe(\"arrays - multiple prepend\", () => {\n\trunPatchTest(\n\t\t{x: [1, 2, 3]},\n\t\td => {\n\t\t\td.x.unshift(4)\n\t\t\td.x.unshift(5)\n\t\t\t// 4,5,1,2,3\n\t\t},\n\t\t[\n\t\t\t{op: \"replace\", path: [\"x\", 0], value: 5},\n\t\t\t{op: \"replace\", path: [\"x\", 1], value: 4},\n\t\t\t{op: \"replace\", path: [\"x\", 2], value: 1},\n\t\t\t{op: \"add\", path: [\"x\", 3], value: 2},\n\t\t\t{op: \"add\", path: [\"x\", 4], value: 3}\n\t\t]\n\t)\n})\n\ndescribe(\"arrays - splice middle\", () => {\n\trunPatchTest(\n\t\t{x: [1, 2, 3]},\n\t\td => {\n\t\t\td.x.splice(1, 1)\n\t\t},\n\t\t[\n\t\t\t{op: \"replace\", path: [\"x\", 1], value: 3},\n\t\t\t{op: \"replace\", path: [\"x\", \"length\"], value: 2}\n\t\t]\n\t)\n})\n\ndescribe(\"arrays - multiple splice\", () => {\n\trunPatchTest(\n\t\t[0, 1, 2, 3, 4, 5, 0],\n\t\td => {\n\t\t\td.splice(4, 2, 3)\n\t\t\t// [0,1,2,3,3,0]\n\t\t\td.splice(1, 2, 3)\n\t\t\t// [0,3,3,3,0]\n\t\t\texpect(d.slice()).toEqual([0, 3, 3, 3, 0])\n\t\t},\n\t\t[\n\t\t\t{op: \"replace\", path: [1], value: 3},\n\t\t\t{op: \"replace\", path: [2], value: 3},\n\t\t\t{op: \"replace\", path: [4], value: 0},\n\t\t\t{op: \"replace\", path: [\"length\"], value: 5}\n\t\t]\n\t)\n})\n\ndescribe(\"arrays - modify and shrink\", () => {\n\trunPatchTest(\n\t\t{x: [1, 2, 3]},\n\t\td => {\n\t\t\td.x[0] = 4\n\t\t\td.x.length = 2\n\t\t\t// [0, 2]\n\t\t},\n\t\t[\n\t\t\t{op: \"replace\", path: [\"x\", 0], value: 4},\n\t\t\t{op: \"replace\", path: [\"x\", \"length\"], value: 2}\n\t\t],\n\t\t[\n\t\t\t{op: \"replace\", path: [\"x\", 0], value: 1},\n\t\t\t{op: \"add\", path: [\"x\", 2], value: 3}\n\t\t]\n\t)\n})\n\ndescribe(\"arrays - prepend then splice middle\", () => {\n\trunPatchTest(\n\t\t{x: [1, 2, 3]},\n\t\td => {\n\t\t\td.x.unshift(4)\n\t\t\td.x.splice(2, 1)\n\t\t\t// 4, 1, 3\n\t\t},\n\t\t[\n\t\t\t{op: \"replace\", path: [\"x\", 0], value: 4},\n\t\t\t{op: \"replace\", path: [\"x\", 1], value: 1}\n\t\t]\n\t)\n})\n\ndescribe(\"arrays - splice middle then prepend\", () => {\n\trunPatchTest(\n\t\t{x: [1, 2, 3]},\n\t\td => {\n\t\t\td.x.splice(1, 1)\n\t\t\td.x.unshift(4)\n\t\t\t// [4, 1, 3]\n\t\t},\n\t\t[\n\t\t\t{op: \"replace\", path: [\"x\", 0], value: 4},\n\t\t\t{op: \"replace\", path: [\"x\", 1], value: 1}\n\t\t]\n\t)\n})\n\ndescribe(\"arrays - truncate\", () => {\n\trunPatchTest(\n\t\t{x: [1, 2, 3]},\n\t\td => {\n\t\t\td.x.length -= 2\n\t\t},\n\t\t[{op: \"replace\", path: [\"x\", \"length\"], value: 1}],\n\t\t[\n\t\t\t{op: \"add\", path: [\"x\", 1], value: 2},\n\t\t\t{op: \"add\", path: [\"x\", 2], value: 3}\n\t\t]\n\t)\n})\n\ndescribe(\"arrays - pop twice\", () => {\n\trunPatchTest(\n\t\t{x: [1, 2, 3]},\n\t\td => {\n\t\t\td.x.pop()\n\t\t\td.x.pop()\n\t\t},\n\t\t[{op: \"replace\", path: [\"x\", \"length\"], value: 1}]\n\t)\n})\n\ndescribe(\"arrays - push multiple\", () => {\n\t// These patches were more optimal pre immer 7, but not always correct\n\trunPatchTest(\n\t\t{x: [1, 2, 3]},\n\t\td => {\n\t\t\td.x.push(4, 5)\n\t\t},\n\t\t[\n\t\t\t{op: \"add\", path: [\"x\", 3], value: 4},\n\t\t\t{op: \"add\", path: [\"x\", 4], value: 5}\n\t\t],\n\t\t[{op: \"replace\", path: [\"x\", \"length\"], value: 3}]\n\t)\n})\n\ndescribe(\"arrays - splice (expand)\", () => {\n\t// These patches were more optimal pre immer 7, but not always correct\n\trunPatchTest(\n\t\t{x: [1, 2, 3]},\n\t\td => {\n\t\t\td.x.splice(1, 1, 4, 5, 6) // [1,4,5,6,3]\n\t\t},\n\t\t[\n\t\t\t{op: \"replace\", path: [\"x\", 1], value: 4},\n\t\t\t{op: \"replace\", path: [\"x\", 2], value: 5},\n\t\t\t{op: \"add\", path: [\"x\", 3], value: 6},\n\t\t\t{op: \"add\", path: [\"x\", 4], value: 3}\n\t\t],\n\t\t[\n\t\t\t{op: \"replace\", path: [\"x\", 1], value: 2},\n\t\t\t{op: \"replace\", path: [\"x\", 2], value: 3},\n\t\t\t{op: \"replace\", path: [\"x\", \"length\"], value: 3}\n\t\t]\n\t)\n})\n\ndescribe(\"arrays - splice (shrink)\", () => {\n\t// These patches were more optimal pre immer 7, but not always correct\n\trunPatchTest(\n\t\t{x: [1, 2, 3, 4, 5]},\n\t\td => {\n\t\t\td.x.splice(1, 3, 6) // [1, 6, 5]\n\t\t},\n\t\t[\n\t\t\t{op: \"replace\", path: [\"x\", 1], value: 6},\n\t\t\t{op: \"replace\", path: [\"x\", 2], value: 5},\n\t\t\t{op: \"replace\", path: [\"x\", \"length\"], value: 3}\n\t\t],\n\t\t[\n\t\t\t{op: \"replace\", path: [\"x\", 1], value: 2},\n\t\t\t{op: \"replace\", path: [\"x\", 2], value: 3},\n\t\t\t{op: \"add\", path: [\"x\", 3], value: 4},\n\t\t\t{op: \"add\", path: [\"x\", 4], value: 5}\n\t\t]\n\t)\n})\n\ndescribe(\"arrays - delete\", () => {\n\trunPatchTest(\n\t\t{\n\t\t\tx: [\n\t\t\t\t{a: 1, b: 2},\n\t\t\t\t{c: 3, d: 4}\n\t\t\t]\n\t\t},\n\t\td => {\n\t\t\tdelete d.x[1].c\n\t\t},\n\t\t[{op: \"remove\", path: [\"x\", 1, \"c\"]}]\n\t)\n})\n\ndescribe(\"sets - add - 1\", () => {\n\trunPatchTest(\n\t\tnew Set([1]),\n\t\td => {\n\t\t\td.add(2)\n\t\t},\n\t\t[{op: \"add\", path: [1], value: 2}],\n\t\t[{op: \"remove\", path: [1], value: 2}]\n\t)\n})\n\ndescribe(\"sets - add, delete, add - 1\", () => {\n\trunPatchTest(\n\t\tnew Set([1]),\n\t\td => {\n\t\t\td.add(2)\n\t\t\td.delete(2)\n\t\t\td.add(2)\n\t\t},\n\t\t[{op: \"add\", path: [1], value: 2}],\n\t\t[{op: \"remove\", path: [1], value: 2}]\n\t)\n})\n\ndescribe(\"sets - add, delete, add - 2\", () => {\n\trunPatchTest(\n\t\tnew Set([2, 1]),\n\t\td => {\n\t\t\td.add(2)\n\t\t\td.delete(2)\n\t\t\td.add(2)\n\t\t},\n\t\t[],\n\t\t[]\n\t)\n})\n\ndescribe(\"sets - mutate - 1\", () => {\n\tconst findById = (set, id) => {\n\t\tfor (const item of set) {\n\t\t\tif (item.id === id) return item\n\t\t}\n\t}\n\trunPatchTest(\n\t\tnew Set([\n\t\t\t{id: 1, val: \"We\"},\n\t\t\t{id: 2, val: \"will\"}\n\t\t]),\n\t\td => {\n\t\t\tconst obj1 = findById(d, 1)\n\t\t\tconst obj2 = findById(d, 2)\n\t\t\tobj1.val = \"rock\"\n\t\t\tobj2.val = \"you\"\n\t\t},\n\t\t[\n\t\t\t{op: \"remove\", path: [0], value: {id: 1, val: \"We\"}},\n\t\t\t{op: \"remove\", path: [1], value: {id: 2, val: \"will\"}},\n\t\t\t{op: \"add\", path: [0], value: {id: 1, val: \"rock\"}},\n\t\t\t{op: \"add\", path: [1], value: {id: 2, val: \"you\"}}\n\t\t],\n\t\t[\n\t\t\t{op: \"remove\", path: [1], value: {id: 2, val: \"you\"}},\n\t\t\t{op: \"remove\", path: [0], value: {id: 1, val: \"rock\"}},\n\t\t\t{op: \"add\", path: [1], value: {id: 2, val: \"will\"}},\n\t\t\t{op: \"add\", path: [0], value: {id: 1, val: \"We\"}}\n\t\t]\n\t)\n})\n\ndescribe(\"arrays - splice should should result in remove op.\", () => {\n\t// These patches were more optimal pre immer 7, but not always correct\n\trunPatchTest(\n\t\t[1, 2],\n\t\td => {\n\t\t\td.splice(1, 1)\n\t\t},\n\t\t[{op: \"replace\", path: [\"length\"], value: 1}],\n\t\t[{op: \"add\", path: [1], value: 2}]\n\t)\n})\n\ndescribe(\"arrays - NESTED splice should should result in remove op.\", () => {\n\t// These patches were more optimal pre immer 7, but not always correct\n\trunPatchTest(\n\t\t{a: {b: {c: [1, 2]}}},\n\t\td => {\n\t\t\td.a.b.c.splice(1, 1)\n\t\t},\n\t\t[{op: \"replace\", path: [\"a\", \"b\", \"c\", \"length\"], value: 1}],\n\t\t[{op: \"add\", path: [\"a\", \"b\", \"c\", 1], value: 2}]\n\t)\n})\n\ndescribe(\"simple replacement\", () => {\n\trunPatchTest({x: 3}, _d => 4, [{op: \"replace\", path: [], value: 4}])\n})\n\ndescribe(\"same value replacement - 1\", () => {\n\trunPatchTest(\n\t\t{x: {y: 3}},\n\t\td => {\n\t\t\tconst a = d.x\n\t\t\td.x = a\n\t\t},\n\t\t[]\n\t)\n})\n\ndescribe(\"same value replacement - 2\", () => {\n\trunPatchTest(\n\t\t{x: {y: 3}},\n\t\td => {\n\t\t\tconst a = d.x\n\t\t\td.x = 4\n\t\t\td.x = a\n\t\t},\n\t\t[]\n\t)\n})\n\ndescribe(\"same value replacement - 3\", () => {\n\trunPatchTest(\n\t\t{x: 3},\n\t\td => {\n\t\t\td.x = 3\n\t\t},\n\t\t[]\n\t)\n})\n\ndescribe(\"same value replacement - 4\", () => {\n\trunPatchTest(\n\t\t{x: 3},\n\t\td => {\n\t\t\td.x = 4\n\t\t\td.x = 3\n\t\t},\n\t\t[]\n\t)\n})\n\ndescribe(\"same value replacement - 5\", () => {\n\trunPatchTest(\n\t\tnew Map([[\"x\", 3]]),\n\t\td => {\n\t\t\td.set(\"x\", 4)\n\t\t\td.set(\"x\", 3)\n\t\t},\n\t\t[],\n\t\t[]\n\t)\n})\n\ndescribe(\"same value replacement - 6\", () => {\n\trunPatchTest(\n\t\tnew Set([\"x\", 3]),\n\t\td => {\n\t\t\td.delete(\"x\")\n\t\t\td.add(\"x\")\n\t\t},\n\t\t[],\n\t\t[]\n\t)\n})\n\ndescribe(\"simple delete\", () => {\n\trunPatchTest(\n\t\t{x: 2},\n\t\td => {\n\t\t\tdelete d.x\n\t\t},\n\t\t[\n\t\t\t{\n\t\t\t\top: \"remove\",\n\t\t\t\tpath: [\"x\"]\n\t\t\t}\n\t\t]\n\t)\n})\n\ndescribe(\"patch compressions yields correct results\", () => {\n\tlet p1, p2\n\trunPatchTest(\n\t\t{},\n\t\td => {\n\t\t\td.x = {test: true}\n\t\t},\n\t\t(p1 = [\n\t\t\t{\n\t\t\t\top: \"add\",\n\t\t\t\tpath: [\"x\"],\n\t\t\t\tvalue: {\n\t\t\t\t\ttest: true\n\t\t\t\t}\n\t\t\t}\n\t\t])\n\t)\n\trunPatchTest(\n\t\t{x: {test: true}},\n\t\td => {\n\t\t\tdelete d.x\n\t\t},\n\t\t(p2 = [\n\t\t\t{\n\t\t\t\top: \"remove\",\n\t\t\t\tpath: [\"x\"]\n\t\t\t}\n\t\t])\n\t)\n\tconst res = runPatchTest(\n\t\t{},\n\t\td => {\n\t\t\tapplyPatches(d, [...p1, ...p2])\n\t\t},\n\t\t[]\n\t)\n\n\texpect(res).toEqual({})\n})\n\ndescribe(\"change then delete property\", () => {\n\tconst res = runPatchTest(\n\t\t{\n\t\t\tx: 1\n\t\t},\n\t\td => {\n\t\t\td.x = 2\n\t\t\tdelete d.x\n\t\t},\n\t\t[\n\t\t\t{\n\t\t\t\top: \"remove\",\n\t\t\t\tpath: [\"x\"]\n\t\t\t}\n\t\t]\n\t)\n\ttest(\"valid result\", () => {\n\t\texpect(res).toEqual({})\n\t})\n})\n\ntest(\"replaying patches with interweaved replacements should work correctly\", () => {\n\tconst patches = []\n\tconst s0 = {x: 1}\n\n\tconst s1 = produce(\n\t\ts0,\n\t\tdraft => {\n\t\t\tdraft.x = 2\n\t\t},\n\t\tp => {\n\t\t\tpatches.push(...p)\n\t\t}\n\t)\n\n\tconst s2 = produce(\n\t\ts1,\n\t\tdraft => {\n\t\t\treturn {x: 0}\n\t\t},\n\t\tp => {\n\t\t\tpatches.push(...p)\n\t\t}\n\t)\n\n\tconst s3 = produce(\n\t\ts2,\n\t\tdraft => {\n\t\t\tdraft.x--\n\t\t},\n\t\tp => {\n\t\t\tpatches.push(...p)\n\t\t}\n\t)\n\n\texpect(s3).toEqual({x: -1}) // correct result\n\texpect(applyPatches(s0, patches)).toEqual({x: -1}) // correct replay\n\n\t// manual replay on a draft should also be correct\n\texpect(\n\t\tproduce(s0, draft => {\n\t\t\treturn applyPatches(draft, patches)\n\t\t})\n\t).toEqual({x: -1})\n})\n\ndescribe(\"#468\", () => {\n\tfunction run() {\n\t\tconst item = {id: 1}\n\t\tconst state = [item]\n\t\tconst [nextState, patches] = produceWithPatches(state, draft => {\n\t\t\tdraft[0].id = 2\n\t\t\tdraft[1] = item\n\t\t})\n\n\t\texpect(nextState).toEqual([{id: 2}, {id: 1}])\n\t\texpect(patches).toEqual([\n\t\t\t{\n\t\t\t\top: \"replace\",\n\t\t\t\tpath: [0, \"id\"],\n\t\t\t\tvalue: 2\n\t\t\t},\n\t\t\t{\n\t\t\t\top: \"add\",\n\t\t\t\tpath: [1],\n\t\t\t\tvalue: {\n\t\t\t\t\tid: 1\n\t\t\t\t}\n\t\t\t}\n\t\t])\n\n\t\tconst final = applyPatches(state, patches)\n\t\texpect(final).toEqual(nextState)\n\t}\n\n\ttest(\"es5\", () => {\n\t\tsetUseProxies(false)\n\t\trun()\n\t})\n\n\ttest(\"proxy\", () => {\n\t\tsetUseProxies(true)\n\t\trun()\n\t})\n})\n\ntest(\"#521\", () => {\n\tconst state = new Map()\n\n\tconst [nextState, patches] = produceWithPatches(state, draft => {\n\t\tdraft.set(\"hello\", new Set([\"world\"]))\n\t})\n\n\tlet patchedState = applyPatches(state, patches)\n\texpect(patchedState).toEqual(nextState)\n\n\tconst [nextStateV2, patchesV2] = produceWithPatches(nextState, draft => {\n\t\tdraft.get(\"hello\").add(\"immer\")\n\t})\n\n\texpect(applyPatches(nextState, patchesV2)).toEqual(\n\t\tnew Map([[\"hello\", new Set([\"world\", \"immer\"])]])\n\t)\n})\n\ntest(\"#559 patches works in a nested reducer with proxies\", () => {\n\tsetUseProxies(true)\n\n\tconst state = {\n\t\tx: 1,\n\t\tsub: {\n\t\t\ty: [{a: 0}, {a: 1}]\n\t\t}\n\t}\n\n\tconst changes = []\n\tconst inverseChanges = []\n\n\tconst newState = produce(state, draft => {\n\t\tdraft.sub = produce(\n\t\t\tdraft.sub,\n\t\t\tdraft => {\n\t\t\t\tdraft.y.pop()\n\t\t\t},\n\t\t\t(patches, inversePatches) => {\n\t\t\t\texpect(isDraft(inversePatches[0].value)).toBeFalsy()\n\t\t\t\texpect(inversePatches[0].value).toMatchObject({a: 1})\n\t\t\t\tchanges.push(...patches)\n\t\t\t\tinverseChanges.push(...inversePatches)\n\t\t\t}\n\t\t)\n\t})\n\n\tconst reversedSubState = applyPatches(newState.sub, inverseChanges)\n\n\texpect(reversedSubState).toMatchObject(state.sub)\n})\n\ndescribe(\"#588\", () => {\n\tconst reference = {value: {num: 53}}\n\n\tclass Base {\n\t\t[immerable] = true\n\t\tget nested() {\n\t\t\treturn reference.value\n\t\t}\n\t\tset nested(value) {}\n\t}\n\n\tlet base = new Base()\n\n\trunPatchTest(\n\t\tbase,\n\t\tvdraft => {\n\t\t\treference.value = vdraft\n\t\t\tproduce(base, bdraft => {\n\t\t\t\tbdraft.nested.num = 42\n\t\t\t})\n\t\t},\n\t\t[{op: \"add\", path: [\"num\"], value: 42}]\n\t)\n})\n\ntest(\"#676 patching Date objects\", () => {\n\tclass Test {\n\t\tconstructor() {\n\t\t\tthis.test = true\n\t\t}\n\t\tperform() {\n\t\t\treturn \"tested!\"\n\t\t}\n\t}\n\n\tconst [nextState, patches] = produceWithPatches({}, function(draft) {\n\t\tdraft.date = new Date(\"2020-11-10T08:08:08.003Z\")\n\t\tdraft.test = new Test()\n\t})\n\n\texpect(nextState.date.toJSON()).toMatchInlineSnapshot(\n\t\t`\"2020-11-10T08:08:08.003Z\"`\n\t)\n\texpect(nextState.test.perform()).toBe(\"tested!\")\n\n\tconst rebuilt = applyPatches({}, patches)\n\texpect(rebuilt.date).toBeInstanceOf(Date)\n\texpect(rebuilt.date.toJSON()).toMatchInlineSnapshot(\n\t\t`\"2020-11-10T08:08:08.003Z\"`\n\t)\n\texpect(rebuilt.date).toEqual(new Date(\"2020-11-10T08:08:08.003Z\"))\n})\n\ntest(\"do not allow __proto__ polution - 738\", () => {\n\tconst obj = {}\n\n\t// @ts-ignore\n\texpect(obj.polluted).toBe(undefined)\n\texpect(() => {\n\t\tapplyPatches({}, [\n\t\t\t{op: \"add\", path: [\"__proto__\", \"polluted\"], value: \"yes\"}\n\t\t])\n\t}).toThrow(\n\t\tisProd\n\t\t\t? \"24\"\n\t\t\t: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n\t)\n\t// @ts-ignore\n\texpect(obj.polluted).toBe(undefined)\n})\n\ntest(\"do not allow __proto__ polution using arrays - 738\", () => {\n\tconst obj = {}\n\tconst ar = []\n\n\t// @ts-ignore\n\texpect(obj.polluted).toBe(undefined)\n\t// @ts-ignore\n\texpect(ar.polluted).toBe(undefined)\n\texpect(() => {\n\t\tapplyPatches(\n\t\t\t[],\n\t\t\t[{op: \"add\", path: [\"__proto__\", \"polluted\"], value: \"yes\"}]\n\t\t)\n\t}).toThrow(\n\t\tisProd\n\t\t\t? \"24\"\n\t\t\t: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n\t)\n\t// @ts-ignore\n\texpect(obj.polluted).toBe(undefined)\n\t// @ts-ignore\n\texpect(ar.polluted).toBe(undefined)\n})\n\ntest(\"do not allow prototype polution - 738\", () => {\n\tconst obj = {}\n\n\t// @ts-ignore\n\texpect(obj.polluted).toBe(undefined)\n\texpect(() => {\n\t\tapplyPatches(Object, [\n\t\t\t{op: \"add\", path: [\"prototype\", \"polluted\"], value: \"yes\"}\n\t\t])\n\t}).toThrow(\n\t\tisProd\n\t\t\t? \"24\"\n\t\t\t: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n\t)\n\t// @ts-ignore\n\texpect(obj.polluted).toBe(undefined)\n})\n\ntest(\"do not allow constructor polution - 738\", () => {\n\tconst obj = {}\n\n\t// @ts-ignore\n\texpect(obj.polluted).toBe(undefined)\n\tconst t = {}\n\tapplyPatches(t, [{op: \"replace\", path: [\"constructor\"], value: \"yes\"}])\n\texpect(typeof t.constructor).toBe(\"function\")\n\t// @ts-ignore\n\texpect(Object.polluted).toBe(undefined)\n})\n\ntest(\"do not allow constructor.prototype polution - 738\", () => {\n\tconst obj = {}\n\n\t// @ts-ignore\n\texpect(obj.polluted).toBe(undefined)\n\texpect(() => {\n\t\tapplyPatches({}, [\n\t\t\t{op: \"add\", path: [\"constructor\", \"prototype\", \"polluted\"], value: \"yes\"}\n\t\t])\n\t}).toThrow(\n\t\tisProd\n\t\t\t? \"24\"\n\t\t\t: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n\t)\n\t// @ts-ignore\n\texpect(Object.polluted).toBe(undefined)\n})\n\ntest(\"maps can store __proto__, prototype and constructor props\", () => {\n\tconst obj = {}\n\tconst map = new Map()\n\tmap.set(\"__proto__\", {})\n\tmap.set(\"constructor\", {})\n\tmap.set(\"prototype\", {})\n\tconst newMap = applyPatches(map, [\n\t\t{op: \"add\", path: [\"__proto__\", \"polluted\"], value: \"yes\"},\n\t\t{op: \"add\", path: [\"constructor\", \"polluted\"], value: \"yes\"},\n\t\t{op: \"add\", path: [\"prototype\", \"polluted\"], value: \"yes\"}\n\t])\n\texpect(newMap.get(\"__proto__\").polluted).toBe(\"yes\")\n\texpect(newMap.get(\"constructor\").polluted).toBe(\"yes\")\n\texpect(newMap.get(\"prototype\").polluted).toBe(\"yes\")\n\texpect(obj.polluted).toBe(undefined)\n})\n\ntest(\"#648 assigning object to itself should not change patches\", () => {\n\tconst input = {\n\t\tobj: {\n\t\t\tvalue: 200\n\t\t}\n\t}\n\n\tconst [nextState, patches] = produceWithPatches(input, draft => {\n\t\tdraft.obj.value = 1\n\t\tdraft.obj = draft.obj\n\t})\n\n\texpect(patches).toEqual([\n\t\t{\n\t\t\top: \"replace\",\n\t\t\tpath: [\"obj\", \"value\"],\n\t\t\tvalue: 1\n\t\t}\n\t])\n})\n\ntest(\"#791 patch for  nothing is stored as undefined\", () => {\n\tconst [newState, patches] = produceWithPatches({abc: 123}, draft => nothing)\n\texpect(patches).toEqual([{op: \"replace\", path: [], value: undefined}])\n\n\texpect(applyPatches({}, patches)).toEqual(undefined)\n})\n", "import {immerable} from \"../immer\"\nimport {\n\tImmerState,\n\tPatch,\n\tSetState,\n\tES5ArrayState,\n\tProxyArrayState,\n\tMapState,\n\tES5ObjectState,\n\tProxyObjectState,\n\tPatchPath,\n\tget,\n\teach,\n\thas,\n\tgetArchtype,\n\tisSet,\n\tisMap,\n\tloadPlugin,\n\tProxyType,\n\tArchtype,\n\tdie,\n\tisDraft,\n\tisDraftable,\n\tNOTHING\n} from \"../internal\"\n\nexport function enablePatches() {\n\tconst REPLACE = \"replace\"\n\tconst ADD = \"add\"\n\tconst REMOVE = \"remove\"\n\n\tfunction generatePatches_(\n\t\tstate: ImmerState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t): void {\n\t\tswitch (state.type_) {\n\t\t\tcase ProxyType.ProxyObject:\n\t\t\tcase ProxyType.ES5Object:\n\t\t\tcase ProxyType.Map:\n\t\t\t\treturn generatePatchesFromAssigned(\n\t\t\t\t\tstate,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches,\n\t\t\t\t\tinversePatches\n\t\t\t\t)\n\t\t\tcase ProxyType.ES5Array:\n\t\t\tcase ProxyType.ProxyArray:\n\t\t\t\treturn generateArrayPatches(state, basePath, patches, inversePatches)\n\t\t\tcase ProxyType.Set:\n\t\t\t\treturn generateSetPatches(\n\t\t\t\t\t(state as any) as SetState,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches,\n\t\t\t\t\tinversePatches\n\t\t\t\t)\n\t\t}\n\t}\n\n\tfunction generateArrayPatches(\n\t\tstate: ES5ArrayState | ProxyArrayState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, assigned_} = state\n\t\tlet copy_ = state.copy_!\n\n\t\t// Reduce complexity by ensuring `base` is never longer.\n\t\tif (copy_.length < base_.length) {\n\t\t\t// @ts-ignore\n\t\t\t;[base_, copy_] = [copy_, base_]\n\t\t\t;[patches, inversePatches] = [inversePatches, patches]\n\t\t}\n\n\t\t// Process replaced indices.\n\t\tfor (let i = 0; i < base_.length; i++) {\n\t\t\tif (assigned_[i] && copy_[i] !== base_[i]) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t\t})\n\t\t\t\tinversePatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(base_[i])\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\t// Process added indices.\n\t\tfor (let i = base_.length; i < copy_.length; i++) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tpatches.push({\n\t\t\t\top: ADD,\n\t\t\t\tpath,\n\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t})\n\t\t}\n\t\tif (base_.length < copy_.length) {\n\t\t\tinversePatches.push({\n\t\t\t\top: REPLACE,\n\t\t\t\tpath: basePath.concat([\"length\"]),\n\t\t\t\tvalue: base_.length\n\t\t\t})\n\t\t}\n\t}\n\n\t// This is used for both Map objects and normal objects.\n\tfunction generatePatchesFromAssigned(\n\t\tstate: MapState | ES5ObjectState | ProxyObjectState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tconst {base_, copy_} = state\n\t\teach(state.assigned_!, (key, assignedValue) => {\n\t\t\tconst origValue = get(base_, key)\n\t\t\tconst value = get(copy_!, key)\n\t\t\tconst op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD\n\t\t\tif (origValue === value && op === REPLACE) return\n\t\t\tconst path = basePath.concat(key as any)\n\t\t\tpatches.push(op === REMOVE ? {op, path} : {op, path, value})\n\t\t\tinversePatches.push(\n\t\t\t\top === ADD\n\t\t\t\t\t? {op: REMOVE, path}\n\t\t\t\t\t: op === REMOVE\n\t\t\t\t\t? {op: ADD, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t\t\t: {op: REPLACE, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t)\n\t\t})\n\t}\n\n\tfunction generateSetPatches(\n\t\tstate: SetState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, copy_} = state\n\n\t\tlet i = 0\n\t\tbase_.forEach((value: any) => {\n\t\t\tif (!copy_!.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t\ti = 0\n\t\tcopy_!.forEach((value: any) => {\n\t\t\tif (!base_.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t}\n\n\tfunction generateReplacementPatches_(\n\t\trootState: ImmerState,\n\t\treplacement: any,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t): void {\n\t\tpatches.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: replacement === NOTHING ? undefined : replacement\n\t\t})\n\t\tinversePatches.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: rootState.base_\n\t\t})\n\t}\n\n\tfunction applyPatches_<T>(draft: T, patches: Patch[]): T {\n\t\tpatches.forEach(patch => {\n\t\t\tconst {path, op} = patch\n\n\t\t\tlet base: any = draft\n\t\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\t\tconst parentType = getArchtype(base)\n\t\t\t\tconst p = path[i]\n\t\t\t\t// See #738, avoid prototype pollution\n\t\t\t\tif (\n\t\t\t\t\t(parentType === Archtype.Object || parentType === Archtype.Array) &&\n\t\t\t\t\t(p === \"__proto__\" || p === \"constructor\")\n\t\t\t\t)\n\t\t\t\t\tdie(24)\n\t\t\t\tif (typeof base === \"function\" && p === \"prototype\") die(24)\n\t\t\t\tbase = get(base, p)\n\t\t\t\tif (typeof base !== \"object\") die(15, path.join(\"/\"))\n\t\t\t}\n\n\t\t\tconst type = getArchtype(base)\n\t\t\tconst value = deepClonePatchValue(patch.value) // used to clone patch to ensure original patch is not modified, see #411\n\t\t\tconst key = path[path.length - 1]\n\t\t\tswitch (op) {\n\t\t\t\tcase REPLACE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\tdie(16)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// if value is an object, then it's assigned by reference\n\t\t\t\t\t\t\t// in the following add or remove ops, the value field inside the patch will also be modifyed\n\t\t\t\t\t\t\t// so we use value from the cloned patch\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase ADD:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Array:\n\t\t\t\t\t\t\treturn base.splice(key as any, 0, value)\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\treturn base.add(value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase REMOVE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Array:\n\t\t\t\t\t\t\treturn base.splice(key as any, 1)\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.delete(key)\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\treturn base.delete(patch.value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn delete base[key]\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tdie(17, op)\n\t\t\t}\n\t\t})\n\n\t\treturn draft\n\t}\n\n\t// optimize: this is quite a performance hit, can we detect intelligently when it is needed?\n\t// E.g. auto-draft when new objects from outside are assigned and modified?\n\t// (See failing test when deepClone just returns obj)\n\tfunction deepClonePatchValue<T>(obj: T): T\n\tfunction deepClonePatchValue(obj: any) {\n\t\tif (!isDraftable(obj)) return obj\n\t\tif (Array.isArray(obj)) return obj.map(deepClonePatchValue)\n\t\tif (isMap(obj))\n\t\t\treturn new Map(\n\t\t\t\tArray.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])\n\t\t\t)\n\t\tif (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue))\n\t\tconst cloned = Object.create(Object.getPrototypeOf(obj))\n\t\tfor (const key in obj) cloned[key] = deepClonePatchValue(obj[key])\n\t\tif (has(obj, immerable)) cloned[immerable] = obj[immerable]\n\t\treturn cloned\n\t}\n\n\tfunction clonePatchValueIfNeeded<T>(obj: T): T {\n\t\tif (isDraft(obj)) {\n\t\t\treturn deepClonePatchValue(obj)\n\t\t} else return obj\n\t}\n\n\tloadPlugin(\"Patches\", {\n\t\tapplyPatches_,\n\t\tgeneratePatches_,\n\t\tgenerateReplacementPatches_\n\t})\n}\n"], "fixing_code": ["\"use strict\"\nimport produce, {\n\tsetUseProxies,\n\tapplyPatches,\n\tproduceWithPatches,\n\tenableAllPlugins,\n\tisDraft,\n\timmerable,\n\tnothing\n} from \"../src/immer\"\n\nenableAllPlugins()\n\njest.setTimeout(1000)\n\nconst isProd = process.env.NODE_ENV === \"production\"\n\nfunction runPatchTest(base, producer, patches, inversePathes) {\n\tlet resultProxies, resultEs5\n\n\tfunction runPatchTestHelper() {\n\t\tlet recordedPatches\n\t\tlet recordedInversePatches\n\t\tconst res = produce(base, producer, (p, i) => {\n\t\t\trecordedPatches = p\n\t\t\trecordedInversePatches = i\n\t\t})\n\n\t\ttest(\"produces the correct patches\", () => {\n\t\t\texpect(recordedPatches).toEqual(patches)\n\t\t\tif (inversePathes) expect(recordedInversePatches).toEqual(inversePathes)\n\t\t})\n\n\t\ttest(\"patches are replayable\", () => {\n\t\t\texpect(applyPatches(base, recordedPatches)).toEqual(res)\n\t\t})\n\n\t\ttest(\"patches can be reversed\", () => {\n\t\t\texpect(applyPatches(res, recordedInversePatches)).toEqual(base)\n\t\t})\n\n\t\treturn res\n\t}\n\n\tdescribe(`proxy`, () => {\n\t\tsetUseProxies(true)\n\t\tresultProxies = runPatchTestHelper()\n\t})\n\n\tdescribe(`es5`, () => {\n\t\tsetUseProxies(false)\n\t\tresultEs5 = runPatchTestHelper()\n\t\ttest(\"ES5 and Proxy implementation yield same result\", () => {\n\t\t\texpect(resultEs5).toEqual(resultProxies)\n\t\t})\n\t})\n\n\treturn resultProxies\n}\n\ndescribe(\"applyPatches\", () => {\n\tit(\"mutates the base state when it is a draft\", () => {\n\t\tproduce({a: 1}, draft => {\n\t\t\tconst result = applyPatches(draft, [\n\t\t\t\t{op: \"replace\", path: [\"a\"], value: 2}\n\t\t\t])\n\t\t\texpect(result).toBe(draft)\n\t\t\texpect(draft.a).toBe(2)\n\t\t})\n\t})\n\tit(\"produces a copy of the base state when not a draft\", () => {\n\t\tconst base = {a: 1}\n\t\tconst result = applyPatches(base, [{op: \"replace\", path: [\"a\"], value: 2}])\n\t\texpect(result).not.toBe(base)\n\t\texpect(result.a).toBe(2)\n\t\texpect(base.a).toBe(1)\n\t})\n\tit('throws when `op` is not \"add\", \"replace\", nor \"remove\"', () => {\n\t\texpect(() => {\n\t\t\tconst patch = {op: \"copy\", from: [0], path: [1]}\n\t\t\tapplyPatches([2], [patch])\n\t\t}).toThrowErrorMatchingSnapshot()\n\t})\n\tit(\"throws when `path` cannot be resolved\", () => {\n\t\t// missing parent\n\t\texpect(() => {\n\t\t\tconst patch = {op: \"add\", path: [\"a\", \"b\"], value: 1}\n\t\t\tapplyPatches({}, [patch])\n\t\t}).toThrowErrorMatchingSnapshot()\n\n\t\t// missing grand-parent\n\t\texpect(() => {\n\t\t\tconst patch = {op: \"add\", path: [\"a\", \"b\", \"c\"], value: 1}\n\t\t\tapplyPatches({}, [patch])\n\t\t}).toThrowErrorMatchingSnapshot()\n\t})\n\tit(\"applied patches cannot be modified\", () => {\n\t\t// see also: https://github.com/immerjs/immer/issues/411\n\t\tconst s0 = {\n\t\t\titems: [1]\n\t\t}\n\n\t\tconst [s1, p1] = produceWithPatches(s0, draft => {\n\t\t\tdraft.items = []\n\t\t})\n\n\t\tconst replaceValueBefore = p1[0].value.slice()\n\n\t\tconst [s2, p2] = produceWithPatches(s1, draft => {\n\t\t\tdraft.items.push(2)\n\t\t})\n\n\t\tapplyPatches(s0, [...p1, ...p2])\n\n\t\tconst replaceValueAfter = p1[0].value.slice()\n\n\t\texpect(replaceValueAfter).toStrictEqual(replaceValueBefore)\n\t})\n})\n\ndescribe(\"simple assignment - 1\", () => {\n\trunPatchTest(\n\t\t{x: 3},\n\t\td => {\n\t\t\td.x++\n\t\t},\n\t\t[{op: \"replace\", path: [\"x\"], value: 4}]\n\t)\n})\n\ndescribe(\"simple assignment - 2\", () => {\n\trunPatchTest(\n\t\t{x: {y: 4}},\n\t\td => {\n\t\t\td.x.y++\n\t\t},\n\t\t[{op: \"replace\", path: [\"x\", \"y\"], value: 5}]\n\t)\n})\n\ndescribe(\"simple assignment - 3\", () => {\n\trunPatchTest(\n\t\t{x: [{y: 4}]},\n\t\td => {\n\t\t\td.x[0].y++\n\t\t},\n\t\t[{op: \"replace\", path: [\"x\", 0, \"y\"], value: 5}]\n\t)\n})\n\ndescribe(\"simple assignment - 4\", () => {\n\trunPatchTest(\n\t\tnew Map([[\"x\", {y: 4}]]),\n\t\td => {\n\t\t\td.get(\"x\").y++\n\t\t},\n\t\t[{op: \"replace\", path: [\"x\", \"y\"], value: 5}],\n\t\t[{op: \"replace\", path: [\"x\", \"y\"], value: 4}]\n\t)\n})\n\ndescribe(\"simple assignment - 5\", () => {\n\trunPatchTest(\n\t\t{x: new Map([[\"y\", 4]])},\n\t\td => {\n\t\t\td.x.set(\"y\", 5)\n\t\t},\n\t\t[{op: \"replace\", path: [\"x\", \"y\"], value: 5}],\n\t\t[{op: \"replace\", path: [\"x\", \"y\"], value: 4}]\n\t)\n})\n\ndescribe(\"simple assignment - 6\", () => {\n\trunPatchTest(\n\t\tnew Map([[\"x\", 1]]),\n\t\td => {\n\t\t\t// Map.prototype.set should return the Map itself\n\t\t\tconst res = d.set(\"x\", 2)\n\t\t\tres.set(\"y\", 3)\n\t\t},\n\t\t[\n\t\t\t{op: \"replace\", path: [\"x\"], value: 2},\n\t\t\t{op: \"add\", path: [\"y\"], value: 3}\n\t\t],\n\t\t[\n\t\t\t{op: \"replace\", path: [\"x\"], value: 1},\n\t\t\t{op: \"remove\", path: [\"y\"]}\n\t\t]\n\t)\n})\n\ndescribe(\"simple assignment - 7\", () => {\n\tconst key1 = {prop: \"val1\"}\n\tconst key2 = {prop: \"val2\"}\n\trunPatchTest(\n\t\t{x: new Map([[key1, 4]])},\n\t\td => {\n\t\t\td.x.set(key1, 5)\n\t\t\td.x.set(key2, 6)\n\t\t},\n\t\t[\n\t\t\t{op: \"replace\", path: [\"x\", key1], value: 5},\n\t\t\t{op: \"add\", path: [\"x\", key2], value: 6}\n\t\t],\n\t\t[\n\t\t\t{op: \"replace\", path: [\"x\", key1], value: 4},\n\t\t\t{op: \"remove\", path: [\"x\", key2]}\n\t\t]\n\t)\n})\n\ndescribe(\"delete 1\", () => {\n\trunPatchTest(\n\t\t{x: {y: 4}},\n\t\td => {\n\t\t\tdelete d.x\n\t\t},\n\t\t[{op: \"remove\", path: [\"x\"]}]\n\t)\n})\n\ndescribe(\"delete 2\", () => {\n\trunPatchTest(\n\t\tnew Map([[\"x\", 1]]),\n\t\td => {\n\t\t\td.delete(\"x\")\n\t\t},\n\t\t[{op: \"remove\", path: [\"x\"]}],\n\t\t[{op: \"add\", path: [\"x\"], value: 1}]\n\t)\n})\n\ndescribe(\"delete 3\", () => {\n\trunPatchTest(\n\t\t{x: new Map([[\"y\", 1]])},\n\t\td => {\n\t\t\td.x.delete(\"y\")\n\t\t},\n\t\t[{op: \"remove\", path: [\"x\", \"y\"]}],\n\t\t[{op: \"add\", path: [\"x\", \"y\"], value: 1}]\n\t)\n})\n\ndescribe(\"delete 5\", () => {\n\tconst key1 = {prop: \"val1\"}\n\tconst key2 = {prop: \"val2\"}\n\trunPatchTest(\n\t\t{\n\t\t\tx: new Map([\n\t\t\t\t[key1, 1],\n\t\t\t\t[key2, 2]\n\t\t\t])\n\t\t},\n\t\td => {\n\t\t\td.x.delete(key1)\n\t\t\td.x.delete(key2)\n\t\t},\n\t\t[\n\t\t\t{op: \"remove\", path: [\"x\", key1]},\n\t\t\t{op: \"remove\", path: [\"x\", key2]}\n\t\t],\n\t\t[\n\t\t\t{op: \"add\", path: [\"x\", key1], value: 1},\n\t\t\t{op: \"add\", path: [\"x\", key2], value: 2}\n\t\t]\n\t)\n})\n\ndescribe(\"delete 6\", () => {\n\trunPatchTest(\n\t\tnew Set([\"x\", 1]),\n\t\td => {\n\t\t\td.delete(\"x\")\n\t\t},\n\t\t[{op: \"remove\", path: [0], value: \"x\"}],\n\t\t[{op: \"add\", path: [0], value: \"x\"}]\n\t)\n})\n\ndescribe(\"delete 7\", () => {\n\trunPatchTest(\n\t\t{x: new Set([\"y\", 1])},\n\t\td => {\n\t\t\td.x.delete(\"y\")\n\t\t},\n\t\t[{op: \"remove\", path: [\"x\", 0], value: \"y\"}],\n\t\t[{op: \"add\", path: [\"x\", 0], value: \"y\"}]\n\t)\n})\n\ndescribe(\"renaming properties\", () => {\n\tdescribe(\"nested object (no changes)\", () => {\n\t\trunPatchTest(\n\t\t\t{a: {b: 1}},\n\t\t\td => {\n\t\t\t\td.x = d.a\n\t\t\t\tdelete d.a\n\t\t\t},\n\t\t\t[\n\t\t\t\t{op: \"add\", path: [\"x\"], value: {b: 1}},\n\t\t\t\t{op: \"remove\", path: [\"a\"]}\n\t\t\t]\n\t\t)\n\t})\n\n\tdescribe(\"nested change in object\", () => {\n\t\trunPatchTest(\n\t\t\t{\n\t\t\t\ta: {b: 1}\n\t\t\t},\n\t\t\td => {\n\t\t\t\td.a.b++\n\t\t\t},\n\t\t\t[{op: \"replace\", path: [\"a\", \"b\"], value: 2}],\n\t\t\t[{op: \"replace\", path: [\"a\", \"b\"], value: 1}]\n\t\t)\n\t})\n\n\tdescribe(\"nested change in map\", () => {\n\t\trunPatchTest(\n\t\t\tnew Map([[\"a\", new Map([[\"b\", 1]])]]),\n\t\t\td => {\n\t\t\t\td.get(\"a\").set(\"b\", 2)\n\t\t\t},\n\t\t\t[{op: \"replace\", path: [\"a\", \"b\"], value: 2}],\n\t\t\t[{op: \"replace\", path: [\"a\", \"b\"], value: 1}]\n\t\t)\n\t})\n\n\tdescribe(\"nested change in array\", () => {\n\t\trunPatchTest(\n\t\t\t[[{b: 1}]],\n\t\t\td => {\n\t\t\t\td[0][0].b++\n\t\t\t},\n\t\t\t[{op: \"replace\", path: [0, 0, \"b\"], value: 2}],\n\t\t\t[{op: \"replace\", path: [0, 0, \"b\"], value: 1}]\n\t\t)\n\t})\n\n\tdescribe(\"nested map (no changes)\", () => {\n\t\trunPatchTest(\n\t\t\tnew Map([[\"a\", new Map([[\"b\", 1]])]]),\n\t\t\td => {\n\t\t\t\td.set(\"x\", d.get(\"a\"))\n\t\t\t\td.delete(\"a\")\n\t\t\t},\n\t\t\t[\n\t\t\t\t{op: \"add\", path: [\"x\"], value: new Map([[\"b\", 1]])},\n\t\t\t\t{op: \"remove\", path: [\"a\"]}\n\t\t\t],\n\t\t\t[\n\t\t\t\t{op: \"remove\", path: [\"x\"]},\n\t\t\t\t{op: \"add\", path: [\"a\"], value: new Map([[\"b\", 1]])}\n\t\t\t]\n\t\t)\n\t})\n\n\tdescribe(\"nested object (with changes)\", () => {\n\t\trunPatchTest(\n\t\t\t{a: {b: 1, c: 1}},\n\t\t\td => {\n\t\t\t\tlet a = d.a\n\t\t\t\ta.b = 2 // change\n\t\t\t\tdelete a.c // delete\n\t\t\t\ta.y = 2 // add\n\n\t\t\t\t// rename\n\t\t\t\td.x = a\n\t\t\t\tdelete d.a\n\t\t\t},\n\t\t\t[\n\t\t\t\t{op: \"add\", path: [\"x\"], value: {b: 2, y: 2}},\n\t\t\t\t{op: \"remove\", path: [\"a\"]}\n\t\t\t]\n\t\t)\n\t})\n\n\tdescribe(\"nested map (with changes)\", () => {\n\t\trunPatchTest(\n\t\t\tnew Map([\n\t\t\t\t[\n\t\t\t\t\t\"a\",\n\t\t\t\t\tnew Map([\n\t\t\t\t\t\t[\"b\", 1],\n\t\t\t\t\t\t[\"c\", 1]\n\t\t\t\t\t])\n\t\t\t\t]\n\t\t\t]),\n\t\t\td => {\n\t\t\t\tlet a = d.get(\"a\")\n\t\t\t\ta.set(\"b\", 2) // change\n\t\t\t\ta.delete(\"c\") // delete\n\t\t\t\ta.set(\"y\", 2) // add\n\n\t\t\t\t// rename\n\t\t\t\td.set(\"x\", a)\n\t\t\t\td.delete(\"a\")\n\t\t\t},\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\top: \"add\",\n\t\t\t\t\tpath: [\"x\"],\n\t\t\t\t\tvalue: new Map([\n\t\t\t\t\t\t[\"b\", 2],\n\t\t\t\t\t\t[\"y\", 2]\n\t\t\t\t\t])\n\t\t\t\t},\n\t\t\t\t{op: \"remove\", path: [\"a\"]}\n\t\t\t],\n\t\t\t[\n\t\t\t\t{op: \"remove\", path: [\"x\"]},\n\t\t\t\t{\n\t\t\t\t\top: \"add\",\n\t\t\t\t\tpath: [\"a\"],\n\t\t\t\t\tvalue: new Map([\n\t\t\t\t\t\t[\"b\", 1],\n\t\t\t\t\t\t[\"c\", 1]\n\t\t\t\t\t])\n\t\t\t\t}\n\t\t\t]\n\t\t)\n\t})\n\n\tdescribe(\"deeply nested object (with changes)\", () => {\n\t\trunPatchTest(\n\t\t\t{a: {b: {c: 1, d: 1}}},\n\t\t\td => {\n\t\t\t\tlet b = d.a.b\n\t\t\t\tb.c = 2 // change\n\t\t\t\tdelete b.d // delete\n\t\t\t\tb.y = 2 // add\n\n\t\t\t\t// rename\n\t\t\t\td.a.x = b\n\t\t\t\tdelete d.a.b\n\t\t\t},\n\t\t\t[\n\t\t\t\t{op: \"add\", path: [\"a\", \"x\"], value: {c: 2, y: 2}},\n\t\t\t\t{op: \"remove\", path: [\"a\", \"b\"]}\n\t\t\t]\n\t\t)\n\t})\n\n\tdescribe(\"deeply nested map (with changes)\", () => {\n\t\trunPatchTest(\n\t\t\tnew Map([\n\t\t\t\t[\n\t\t\t\t\t\"a\",\n\t\t\t\t\tnew Map([\n\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\"b\",\n\t\t\t\t\t\t\tnew Map([\n\t\t\t\t\t\t\t\t[\"c\", 1],\n\t\t\t\t\t\t\t\t[\"d\", 1]\n\t\t\t\t\t\t\t])\n\t\t\t\t\t\t]\n\t\t\t\t\t])\n\t\t\t\t]\n\t\t\t]),\n\t\t\td => {\n\t\t\t\tlet b = d.get(\"a\").get(\"b\")\n\t\t\t\tb.set(\"c\", 2) // change\n\t\t\t\tb.delete(\"d\") // delete\n\t\t\t\tb.set(\"y\", 2) // add\n\n\t\t\t\t// rename\n\t\t\t\td.get(\"a\").set(\"x\", b)\n\t\t\t\td.get(\"a\").delete(\"b\")\n\t\t\t},\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\top: \"add\",\n\t\t\t\t\tpath: [\"a\", \"x\"],\n\t\t\t\t\tvalue: new Map([\n\t\t\t\t\t\t[\"c\", 2],\n\t\t\t\t\t\t[\"y\", 2]\n\t\t\t\t\t])\n\t\t\t\t},\n\t\t\t\t{op: \"remove\", path: [\"a\", \"b\"]}\n\t\t\t],\n\t\t\t[\n\t\t\t\t{op: \"remove\", path: [\"a\", \"x\"]},\n\t\t\t\t{\n\t\t\t\t\top: \"add\",\n\t\t\t\t\tpath: [\"a\", \"b\"],\n\t\t\t\t\tvalue: new Map([\n\t\t\t\t\t\t[\"c\", 1],\n\t\t\t\t\t\t[\"d\", 1]\n\t\t\t\t\t])\n\t\t\t\t}\n\t\t\t]\n\t\t)\n\t})\n})\n\ndescribe(\"minimum amount of changes\", () => {\n\trunPatchTest(\n\t\t{x: 3, y: {a: 4}, z: 3},\n\t\td => {\n\t\t\td.y.a = 4\n\t\t\td.y.b = 5\n\t\t\tObject.assign(d, {x: 4, y: {a: 2}})\n\t\t},\n\t\t[\n\t\t\t{op: \"replace\", path: [\"x\"], value: 4},\n\t\t\t{op: \"replace\", path: [\"y\"], value: {a: 2}}\n\t\t]\n\t)\n})\n\ndescribe(\"arrays - prepend\", () => {\n\trunPatchTest(\n\t\t{x: [1, 2, 3]},\n\t\td => {\n\t\t\td.x.unshift(4)\n\t\t},\n\t\t[\n\t\t\t{op: \"replace\", path: [\"x\", 0], value: 4},\n\t\t\t{op: \"replace\", path: [\"x\", 1], value: 1},\n\t\t\t{op: \"replace\", path: [\"x\", 2], value: 2},\n\t\t\t{op: \"add\", path: [\"x\", 3], value: 3}\n\t\t]\n\t)\n})\n\ndescribe(\"arrays - multiple prepend\", () => {\n\trunPatchTest(\n\t\t{x: [1, 2, 3]},\n\t\td => {\n\t\t\td.x.unshift(4)\n\t\t\td.x.unshift(5)\n\t\t\t// 4,5,1,2,3\n\t\t},\n\t\t[\n\t\t\t{op: \"replace\", path: [\"x\", 0], value: 5},\n\t\t\t{op: \"replace\", path: [\"x\", 1], value: 4},\n\t\t\t{op: \"replace\", path: [\"x\", 2], value: 1},\n\t\t\t{op: \"add\", path: [\"x\", 3], value: 2},\n\t\t\t{op: \"add\", path: [\"x\", 4], value: 3}\n\t\t]\n\t)\n})\n\ndescribe(\"arrays - splice middle\", () => {\n\trunPatchTest(\n\t\t{x: [1, 2, 3]},\n\t\td => {\n\t\t\td.x.splice(1, 1)\n\t\t},\n\t\t[\n\t\t\t{op: \"replace\", path: [\"x\", 1], value: 3},\n\t\t\t{op: \"replace\", path: [\"x\", \"length\"], value: 2}\n\t\t]\n\t)\n})\n\ndescribe(\"arrays - multiple splice\", () => {\n\trunPatchTest(\n\t\t[0, 1, 2, 3, 4, 5, 0],\n\t\td => {\n\t\t\td.splice(4, 2, 3)\n\t\t\t// [0,1,2,3,3,0]\n\t\t\td.splice(1, 2, 3)\n\t\t\t// [0,3,3,3,0]\n\t\t\texpect(d.slice()).toEqual([0, 3, 3, 3, 0])\n\t\t},\n\t\t[\n\t\t\t{op: \"replace\", path: [1], value: 3},\n\t\t\t{op: \"replace\", path: [2], value: 3},\n\t\t\t{op: \"replace\", path: [4], value: 0},\n\t\t\t{op: \"replace\", path: [\"length\"], value: 5}\n\t\t]\n\t)\n})\n\ndescribe(\"arrays - modify and shrink\", () => {\n\trunPatchTest(\n\t\t{x: [1, 2, 3]},\n\t\td => {\n\t\t\td.x[0] = 4\n\t\t\td.x.length = 2\n\t\t\t// [0, 2]\n\t\t},\n\t\t[\n\t\t\t{op: \"replace\", path: [\"x\", 0], value: 4},\n\t\t\t{op: \"replace\", path: [\"x\", \"length\"], value: 2}\n\t\t],\n\t\t[\n\t\t\t{op: \"replace\", path: [\"x\", 0], value: 1},\n\t\t\t{op: \"add\", path: [\"x\", 2], value: 3}\n\t\t]\n\t)\n})\n\ndescribe(\"arrays - prepend then splice middle\", () => {\n\trunPatchTest(\n\t\t{x: [1, 2, 3]},\n\t\td => {\n\t\t\td.x.unshift(4)\n\t\t\td.x.splice(2, 1)\n\t\t\t// 4, 1, 3\n\t\t},\n\t\t[\n\t\t\t{op: \"replace\", path: [\"x\", 0], value: 4},\n\t\t\t{op: \"replace\", path: [\"x\", 1], value: 1}\n\t\t]\n\t)\n})\n\ndescribe(\"arrays - splice middle then prepend\", () => {\n\trunPatchTest(\n\t\t{x: [1, 2, 3]},\n\t\td => {\n\t\t\td.x.splice(1, 1)\n\t\t\td.x.unshift(4)\n\t\t\t// [4, 1, 3]\n\t\t},\n\t\t[\n\t\t\t{op: \"replace\", path: [\"x\", 0], value: 4},\n\t\t\t{op: \"replace\", path: [\"x\", 1], value: 1}\n\t\t]\n\t)\n})\n\ndescribe(\"arrays - truncate\", () => {\n\trunPatchTest(\n\t\t{x: [1, 2, 3]},\n\t\td => {\n\t\t\td.x.length -= 2\n\t\t},\n\t\t[{op: \"replace\", path: [\"x\", \"length\"], value: 1}],\n\t\t[\n\t\t\t{op: \"add\", path: [\"x\", 1], value: 2},\n\t\t\t{op: \"add\", path: [\"x\", 2], value: 3}\n\t\t]\n\t)\n})\n\ndescribe(\"arrays - pop twice\", () => {\n\trunPatchTest(\n\t\t{x: [1, 2, 3]},\n\t\td => {\n\t\t\td.x.pop()\n\t\t\td.x.pop()\n\t\t},\n\t\t[{op: \"replace\", path: [\"x\", \"length\"], value: 1}]\n\t)\n})\n\ndescribe(\"arrays - push multiple\", () => {\n\t// These patches were more optimal pre immer 7, but not always correct\n\trunPatchTest(\n\t\t{x: [1, 2, 3]},\n\t\td => {\n\t\t\td.x.push(4, 5)\n\t\t},\n\t\t[\n\t\t\t{op: \"add\", path: [\"x\", 3], value: 4},\n\t\t\t{op: \"add\", path: [\"x\", 4], value: 5}\n\t\t],\n\t\t[{op: \"replace\", path: [\"x\", \"length\"], value: 3}]\n\t)\n})\n\ndescribe(\"arrays - splice (expand)\", () => {\n\t// These patches were more optimal pre immer 7, but not always correct\n\trunPatchTest(\n\t\t{x: [1, 2, 3]},\n\t\td => {\n\t\t\td.x.splice(1, 1, 4, 5, 6) // [1,4,5,6,3]\n\t\t},\n\t\t[\n\t\t\t{op: \"replace\", path: [\"x\", 1], value: 4},\n\t\t\t{op: \"replace\", path: [\"x\", 2], value: 5},\n\t\t\t{op: \"add\", path: [\"x\", 3], value: 6},\n\t\t\t{op: \"add\", path: [\"x\", 4], value: 3}\n\t\t],\n\t\t[\n\t\t\t{op: \"replace\", path: [\"x\", 1], value: 2},\n\t\t\t{op: \"replace\", path: [\"x\", 2], value: 3},\n\t\t\t{op: \"replace\", path: [\"x\", \"length\"], value: 3}\n\t\t]\n\t)\n})\n\ndescribe(\"arrays - splice (shrink)\", () => {\n\t// These patches were more optimal pre immer 7, but not always correct\n\trunPatchTest(\n\t\t{x: [1, 2, 3, 4, 5]},\n\t\td => {\n\t\t\td.x.splice(1, 3, 6) // [1, 6, 5]\n\t\t},\n\t\t[\n\t\t\t{op: \"replace\", path: [\"x\", 1], value: 6},\n\t\t\t{op: \"replace\", path: [\"x\", 2], value: 5},\n\t\t\t{op: \"replace\", path: [\"x\", \"length\"], value: 3}\n\t\t],\n\t\t[\n\t\t\t{op: \"replace\", path: [\"x\", 1], value: 2},\n\t\t\t{op: \"replace\", path: [\"x\", 2], value: 3},\n\t\t\t{op: \"add\", path: [\"x\", 3], value: 4},\n\t\t\t{op: \"add\", path: [\"x\", 4], value: 5}\n\t\t]\n\t)\n})\n\ndescribe(\"arrays - delete\", () => {\n\trunPatchTest(\n\t\t{\n\t\t\tx: [\n\t\t\t\t{a: 1, b: 2},\n\t\t\t\t{c: 3, d: 4}\n\t\t\t]\n\t\t},\n\t\td => {\n\t\t\tdelete d.x[1].c\n\t\t},\n\t\t[{op: \"remove\", path: [\"x\", 1, \"c\"]}]\n\t)\n})\n\ndescribe(\"sets - add - 1\", () => {\n\trunPatchTest(\n\t\tnew Set([1]),\n\t\td => {\n\t\t\td.add(2)\n\t\t},\n\t\t[{op: \"add\", path: [1], value: 2}],\n\t\t[{op: \"remove\", path: [1], value: 2}]\n\t)\n})\n\ndescribe(\"sets - add, delete, add - 1\", () => {\n\trunPatchTest(\n\t\tnew Set([1]),\n\t\td => {\n\t\t\td.add(2)\n\t\t\td.delete(2)\n\t\t\td.add(2)\n\t\t},\n\t\t[{op: \"add\", path: [1], value: 2}],\n\t\t[{op: \"remove\", path: [1], value: 2}]\n\t)\n})\n\ndescribe(\"sets - add, delete, add - 2\", () => {\n\trunPatchTest(\n\t\tnew Set([2, 1]),\n\t\td => {\n\t\t\td.add(2)\n\t\t\td.delete(2)\n\t\t\td.add(2)\n\t\t},\n\t\t[],\n\t\t[]\n\t)\n})\n\ndescribe(\"sets - mutate - 1\", () => {\n\tconst findById = (set, id) => {\n\t\tfor (const item of set) {\n\t\t\tif (item.id === id) return item\n\t\t}\n\t}\n\trunPatchTest(\n\t\tnew Set([\n\t\t\t{id: 1, val: \"We\"},\n\t\t\t{id: 2, val: \"will\"}\n\t\t]),\n\t\td => {\n\t\t\tconst obj1 = findById(d, 1)\n\t\t\tconst obj2 = findById(d, 2)\n\t\t\tobj1.val = \"rock\"\n\t\t\tobj2.val = \"you\"\n\t\t},\n\t\t[\n\t\t\t{op: \"remove\", path: [0], value: {id: 1, val: \"We\"}},\n\t\t\t{op: \"remove\", path: [1], value: {id: 2, val: \"will\"}},\n\t\t\t{op: \"add\", path: [0], value: {id: 1, val: \"rock\"}},\n\t\t\t{op: \"add\", path: [1], value: {id: 2, val: \"you\"}}\n\t\t],\n\t\t[\n\t\t\t{op: \"remove\", path: [1], value: {id: 2, val: \"you\"}},\n\t\t\t{op: \"remove\", path: [0], value: {id: 1, val: \"rock\"}},\n\t\t\t{op: \"add\", path: [1], value: {id: 2, val: \"will\"}},\n\t\t\t{op: \"add\", path: [0], value: {id: 1, val: \"We\"}}\n\t\t]\n\t)\n})\n\ndescribe(\"arrays - splice should should result in remove op.\", () => {\n\t// These patches were more optimal pre immer 7, but not always correct\n\trunPatchTest(\n\t\t[1, 2],\n\t\td => {\n\t\t\td.splice(1, 1)\n\t\t},\n\t\t[{op: \"replace\", path: [\"length\"], value: 1}],\n\t\t[{op: \"add\", path: [1], value: 2}]\n\t)\n})\n\ndescribe(\"arrays - NESTED splice should should result in remove op.\", () => {\n\t// These patches were more optimal pre immer 7, but not always correct\n\trunPatchTest(\n\t\t{a: {b: {c: [1, 2]}}},\n\t\td => {\n\t\t\td.a.b.c.splice(1, 1)\n\t\t},\n\t\t[{op: \"replace\", path: [\"a\", \"b\", \"c\", \"length\"], value: 1}],\n\t\t[{op: \"add\", path: [\"a\", \"b\", \"c\", 1], value: 2}]\n\t)\n})\n\ndescribe(\"simple replacement\", () => {\n\trunPatchTest({x: 3}, _d => 4, [{op: \"replace\", path: [], value: 4}])\n})\n\ndescribe(\"same value replacement - 1\", () => {\n\trunPatchTest(\n\t\t{x: {y: 3}},\n\t\td => {\n\t\t\tconst a = d.x\n\t\t\td.x = a\n\t\t},\n\t\t[]\n\t)\n})\n\ndescribe(\"same value replacement - 2\", () => {\n\trunPatchTest(\n\t\t{x: {y: 3}},\n\t\td => {\n\t\t\tconst a = d.x\n\t\t\td.x = 4\n\t\t\td.x = a\n\t\t},\n\t\t[]\n\t)\n})\n\ndescribe(\"same value replacement - 3\", () => {\n\trunPatchTest(\n\t\t{x: 3},\n\t\td => {\n\t\t\td.x = 3\n\t\t},\n\t\t[]\n\t)\n})\n\ndescribe(\"same value replacement - 4\", () => {\n\trunPatchTest(\n\t\t{x: 3},\n\t\td => {\n\t\t\td.x = 4\n\t\t\td.x = 3\n\t\t},\n\t\t[]\n\t)\n})\n\ndescribe(\"same value replacement - 5\", () => {\n\trunPatchTest(\n\t\tnew Map([[\"x\", 3]]),\n\t\td => {\n\t\t\td.set(\"x\", 4)\n\t\t\td.set(\"x\", 3)\n\t\t},\n\t\t[],\n\t\t[]\n\t)\n})\n\ndescribe(\"same value replacement - 6\", () => {\n\trunPatchTest(\n\t\tnew Set([\"x\", 3]),\n\t\td => {\n\t\t\td.delete(\"x\")\n\t\t\td.add(\"x\")\n\t\t},\n\t\t[],\n\t\t[]\n\t)\n})\n\ndescribe(\"simple delete\", () => {\n\trunPatchTest(\n\t\t{x: 2},\n\t\td => {\n\t\t\tdelete d.x\n\t\t},\n\t\t[\n\t\t\t{\n\t\t\t\top: \"remove\",\n\t\t\t\tpath: [\"x\"]\n\t\t\t}\n\t\t]\n\t)\n})\n\ndescribe(\"patch compressions yields correct results\", () => {\n\tlet p1, p2\n\trunPatchTest(\n\t\t{},\n\t\td => {\n\t\t\td.x = {test: true}\n\t\t},\n\t\t(p1 = [\n\t\t\t{\n\t\t\t\top: \"add\",\n\t\t\t\tpath: [\"x\"],\n\t\t\t\tvalue: {\n\t\t\t\t\ttest: true\n\t\t\t\t}\n\t\t\t}\n\t\t])\n\t)\n\trunPatchTest(\n\t\t{x: {test: true}},\n\t\td => {\n\t\t\tdelete d.x\n\t\t},\n\t\t(p2 = [\n\t\t\t{\n\t\t\t\top: \"remove\",\n\t\t\t\tpath: [\"x\"]\n\t\t\t}\n\t\t])\n\t)\n\tconst res = runPatchTest(\n\t\t{},\n\t\td => {\n\t\t\tapplyPatches(d, [...p1, ...p2])\n\t\t},\n\t\t[]\n\t)\n\n\texpect(res).toEqual({})\n})\n\ndescribe(\"change then delete property\", () => {\n\tconst res = runPatchTest(\n\t\t{\n\t\t\tx: 1\n\t\t},\n\t\td => {\n\t\t\td.x = 2\n\t\t\tdelete d.x\n\t\t},\n\t\t[\n\t\t\t{\n\t\t\t\top: \"remove\",\n\t\t\t\tpath: [\"x\"]\n\t\t\t}\n\t\t]\n\t)\n\ttest(\"valid result\", () => {\n\t\texpect(res).toEqual({})\n\t})\n})\n\ntest(\"replaying patches with interweaved replacements should work correctly\", () => {\n\tconst patches = []\n\tconst s0 = {x: 1}\n\n\tconst s1 = produce(\n\t\ts0,\n\t\tdraft => {\n\t\t\tdraft.x = 2\n\t\t},\n\t\tp => {\n\t\t\tpatches.push(...p)\n\t\t}\n\t)\n\n\tconst s2 = produce(\n\t\ts1,\n\t\tdraft => {\n\t\t\treturn {x: 0}\n\t\t},\n\t\tp => {\n\t\t\tpatches.push(...p)\n\t\t}\n\t)\n\n\tconst s3 = produce(\n\t\ts2,\n\t\tdraft => {\n\t\t\tdraft.x--\n\t\t},\n\t\tp => {\n\t\t\tpatches.push(...p)\n\t\t}\n\t)\n\n\texpect(s3).toEqual({x: -1}) // correct result\n\texpect(applyPatches(s0, patches)).toEqual({x: -1}) // correct replay\n\n\t// manual replay on a draft should also be correct\n\texpect(\n\t\tproduce(s0, draft => {\n\t\t\treturn applyPatches(draft, patches)\n\t\t})\n\t).toEqual({x: -1})\n})\n\ndescribe(\"#468\", () => {\n\tfunction run() {\n\t\tconst item = {id: 1}\n\t\tconst state = [item]\n\t\tconst [nextState, patches] = produceWithPatches(state, draft => {\n\t\t\tdraft[0].id = 2\n\t\t\tdraft[1] = item\n\t\t})\n\n\t\texpect(nextState).toEqual([{id: 2}, {id: 1}])\n\t\texpect(patches).toEqual([\n\t\t\t{\n\t\t\t\top: \"replace\",\n\t\t\t\tpath: [0, \"id\"],\n\t\t\t\tvalue: 2\n\t\t\t},\n\t\t\t{\n\t\t\t\top: \"add\",\n\t\t\t\tpath: [1],\n\t\t\t\tvalue: {\n\t\t\t\t\tid: 1\n\t\t\t\t}\n\t\t\t}\n\t\t])\n\n\t\tconst final = applyPatches(state, patches)\n\t\texpect(final).toEqual(nextState)\n\t}\n\n\ttest(\"es5\", () => {\n\t\tsetUseProxies(false)\n\t\trun()\n\t})\n\n\ttest(\"proxy\", () => {\n\t\tsetUseProxies(true)\n\t\trun()\n\t})\n})\n\ntest(\"#521\", () => {\n\tconst state = new Map()\n\n\tconst [nextState, patches] = produceWithPatches(state, draft => {\n\t\tdraft.set(\"hello\", new Set([\"world\"]))\n\t})\n\n\tlet patchedState = applyPatches(state, patches)\n\texpect(patchedState).toEqual(nextState)\n\n\tconst [nextStateV2, patchesV2] = produceWithPatches(nextState, draft => {\n\t\tdraft.get(\"hello\").add(\"immer\")\n\t})\n\n\texpect(applyPatches(nextState, patchesV2)).toEqual(\n\t\tnew Map([[\"hello\", new Set([\"world\", \"immer\"])]])\n\t)\n})\n\ntest(\"#559 patches works in a nested reducer with proxies\", () => {\n\tsetUseProxies(true)\n\n\tconst state = {\n\t\tx: 1,\n\t\tsub: {\n\t\t\ty: [{a: 0}, {a: 1}]\n\t\t}\n\t}\n\n\tconst changes = []\n\tconst inverseChanges = []\n\n\tconst newState = produce(state, draft => {\n\t\tdraft.sub = produce(\n\t\t\tdraft.sub,\n\t\t\tdraft => {\n\t\t\t\tdraft.y.pop()\n\t\t\t},\n\t\t\t(patches, inversePatches) => {\n\t\t\t\texpect(isDraft(inversePatches[0].value)).toBeFalsy()\n\t\t\t\texpect(inversePatches[0].value).toMatchObject({a: 1})\n\t\t\t\tchanges.push(...patches)\n\t\t\t\tinverseChanges.push(...inversePatches)\n\t\t\t}\n\t\t)\n\t})\n\n\tconst reversedSubState = applyPatches(newState.sub, inverseChanges)\n\n\texpect(reversedSubState).toMatchObject(state.sub)\n})\n\ndescribe(\"#588\", () => {\n\tconst reference = {value: {num: 53}}\n\n\tclass Base {\n\t\t[immerable] = true\n\t\tget nested() {\n\t\t\treturn reference.value\n\t\t}\n\t\tset nested(value) {}\n\t}\n\n\tlet base = new Base()\n\n\trunPatchTest(\n\t\tbase,\n\t\tvdraft => {\n\t\t\treference.value = vdraft\n\t\t\tproduce(base, bdraft => {\n\t\t\t\tbdraft.nested.num = 42\n\t\t\t})\n\t\t},\n\t\t[{op: \"add\", path: [\"num\"], value: 42}]\n\t)\n})\n\ntest(\"#676 patching Date objects\", () => {\n\tclass Test {\n\t\tconstructor() {\n\t\t\tthis.test = true\n\t\t}\n\t\tperform() {\n\t\t\treturn \"tested!\"\n\t\t}\n\t}\n\n\tconst [nextState, patches] = produceWithPatches({}, function(draft) {\n\t\tdraft.date = new Date(\"2020-11-10T08:08:08.003Z\")\n\t\tdraft.test = new Test()\n\t})\n\n\texpect(nextState.date.toJSON()).toMatchInlineSnapshot(\n\t\t`\"2020-11-10T08:08:08.003Z\"`\n\t)\n\texpect(nextState.test.perform()).toBe(\"tested!\")\n\n\tconst rebuilt = applyPatches({}, patches)\n\texpect(rebuilt.date).toBeInstanceOf(Date)\n\texpect(rebuilt.date.toJSON()).toMatchInlineSnapshot(\n\t\t`\"2020-11-10T08:08:08.003Z\"`\n\t)\n\texpect(rebuilt.date).toEqual(new Date(\"2020-11-10T08:08:08.003Z\"))\n})\n\ntest(\"do not allow __proto__ polution - 738\", () => {\n\tconst obj = {}\n\n\t// @ts-ignore\n\texpect(obj.polluted).toBe(undefined)\n\texpect(() => {\n\t\tapplyPatches({}, [\n\t\t\t{op: \"add\", path: [\"__proto__\", \"polluted\"], value: \"yes\"}\n\t\t])\n\t}).toThrow(\n\t\tisProd\n\t\t\t? \"24\"\n\t\t\t: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n\t)\n\t// @ts-ignore\n\texpect(obj.polluted).toBe(undefined)\n})\n\ntest(\"do not allow __proto__ polution using arrays - 738\", () => {\n\tconst obj = {}\n\tconst ar = []\n\n\t// @ts-ignore\n\texpect(obj.polluted).toBe(undefined)\n\t// @ts-ignore\n\texpect(ar.polluted).toBe(undefined)\n\texpect(() => {\n\t\tapplyPatches(\n\t\t\t[],\n\t\t\t[{op: \"add\", path: [\"__proto__\", \"polluted\"], value: \"yes\"}]\n\t\t)\n\t}).toThrow(\n\t\tisProd\n\t\t\t? \"24\"\n\t\t\t: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n\t)\n\t// @ts-ignore\n\texpect(obj.polluted).toBe(undefined)\n\t// @ts-ignore\n\texpect(ar.polluted).toBe(undefined)\n})\n\ntest(\"do not allow prototype polution - 738\", () => {\n\tconst obj = {}\n\n\t// @ts-ignore\n\texpect(obj.polluted).toBe(undefined)\n\texpect(() => {\n\t\tapplyPatches(Object, [\n\t\t\t{op: \"add\", path: [\"prototype\", \"polluted\"], value: \"yes\"}\n\t\t])\n\t}).toThrow(\n\t\tisProd\n\t\t\t? \"24\"\n\t\t\t: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n\t)\n\t// @ts-ignore\n\texpect(obj.polluted).toBe(undefined)\n})\n\ntest(\"do not allow constructor polution - 738\", () => {\n\tconst obj = {}\n\n\t// @ts-ignore\n\texpect(obj.polluted).toBe(undefined)\n\tconst t = {}\n\tapplyPatches(t, [{op: \"replace\", path: [\"constructor\"], value: \"yes\"}])\n\texpect(typeof t.constructor).toBe(\"function\")\n\t// @ts-ignore\n\texpect(Object.polluted).toBe(undefined)\n})\n\ntest(\"do not allow constructor.prototype polution - 738\", () => {\n\tconst obj = {}\n\n\t// @ts-ignore\n\texpect(obj.polluted).toBe(undefined)\n\texpect(() => {\n\t\tapplyPatches({}, [\n\t\t\t{op: \"add\", path: [\"constructor\", \"prototype\", \"polluted\"], value: \"yes\"}\n\t\t])\n\t}).toThrow(\n\t\tisProd\n\t\t\t? \"24\"\n\t\t\t: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n\t)\n\t// @ts-ignore\n\texpect(Object.polluted).toBe(undefined)\n})\n\ntest(\"maps can store __proto__, prototype and constructor props\", () => {\n\tconst obj = {}\n\tconst map = new Map()\n\tmap.set(\"__proto__\", {})\n\tmap.set(\"constructor\", {})\n\tmap.set(\"prototype\", {})\n\tconst newMap = applyPatches(map, [\n\t\t{op: \"add\", path: [\"__proto__\", \"polluted\"], value: \"yes\"},\n\t\t{op: \"add\", path: [\"constructor\", \"polluted\"], value: \"yes\"},\n\t\t{op: \"add\", path: [\"prototype\", \"polluted\"], value: \"yes\"}\n\t])\n\texpect(newMap.get(\"__proto__\").polluted).toBe(\"yes\")\n\texpect(newMap.get(\"constructor\").polluted).toBe(\"yes\")\n\texpect(newMap.get(\"prototype\").polluted).toBe(\"yes\")\n\texpect(obj.polluted).toBe(undefined)\n})\n\ntest(\"CVE-2020-28477 (https://snyk.io/vuln/SNYK-JS-IMMER-1019369) follow up\", () => {\n\tconst obj = {}\n\n\t// @ts-ignore\n\texpect(obj.polluted).toBe(undefined)\n\texpect(() => {\n\t\tapplyPatches({}, [\n\t\t\t{op: \"add\", path: [[\"__proto__\"], \"polluted\"], value: \"yes\"}\n\t\t])\n\t}).toThrow(\n\t\tisProd\n\t\t\t? \"24\"\n\t\t\t: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n\t)\n\t// @ts-ignore\n\texpect(obj.polluted).toBe(undefined)\n})\n\ntest(\"#648 assigning object to itself should not change patches\", () => {\n\tconst input = {\n\t\tobj: {\n\t\t\tvalue: 200\n\t\t}\n\t}\n\n\tconst [nextState, patches] = produceWithPatches(input, draft => {\n\t\tdraft.obj.value = 1\n\t\tdraft.obj = draft.obj\n\t})\n\n\texpect(patches).toEqual([\n\t\t{\n\t\t\top: \"replace\",\n\t\t\tpath: [\"obj\", \"value\"],\n\t\t\tvalue: 1\n\t\t}\n\t])\n})\n\ntest(\"#791 patch for  nothing is stored as undefined\", () => {\n\tconst [newState, patches] = produceWithPatches({abc: 123}, draft => nothing)\n\texpect(patches).toEqual([{op: \"replace\", path: [], value: undefined}])\n\n\texpect(applyPatches({}, patches)).toEqual(undefined)\n})\n", "import {immerable} from \"../immer\"\nimport {\n\tImmerState,\n\tPatch,\n\tSetState,\n\tES5ArrayState,\n\tProxyArrayState,\n\tMapState,\n\tES5ObjectState,\n\tProxyObjectState,\n\tPatchPath,\n\tget,\n\teach,\n\thas,\n\tgetArchtype,\n\tisSet,\n\tisMap,\n\tloadPlugin,\n\tProxyType,\n\tArchtype,\n\tdie,\n\tisDraft,\n\tisDraftable,\n\tNOTHING\n} from \"../internal\"\n\nexport function enablePatches() {\n\tconst REPLACE = \"replace\"\n\tconst ADD = \"add\"\n\tconst REMOVE = \"remove\"\n\n\tfunction generatePatches_(\n\t\tstate: ImmerState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t): void {\n\t\tswitch (state.type_) {\n\t\t\tcase ProxyType.ProxyObject:\n\t\t\tcase ProxyType.ES5Object:\n\t\t\tcase ProxyType.Map:\n\t\t\t\treturn generatePatchesFromAssigned(\n\t\t\t\t\tstate,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches,\n\t\t\t\t\tinversePatches\n\t\t\t\t)\n\t\t\tcase ProxyType.ES5Array:\n\t\t\tcase ProxyType.ProxyArray:\n\t\t\t\treturn generateArrayPatches(state, basePath, patches, inversePatches)\n\t\t\tcase ProxyType.Set:\n\t\t\t\treturn generateSetPatches(\n\t\t\t\t\t(state as any) as SetState,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches,\n\t\t\t\t\tinversePatches\n\t\t\t\t)\n\t\t}\n\t}\n\n\tfunction generateArrayPatches(\n\t\tstate: ES5ArrayState | ProxyArrayState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, assigned_} = state\n\t\tlet copy_ = state.copy_!\n\n\t\t// Reduce complexity by ensuring `base` is never longer.\n\t\tif (copy_.length < base_.length) {\n\t\t\t// @ts-ignore\n\t\t\t;[base_, copy_] = [copy_, base_]\n\t\t\t;[patches, inversePatches] = [inversePatches, patches]\n\t\t}\n\n\t\t// Process replaced indices.\n\t\tfor (let i = 0; i < base_.length; i++) {\n\t\t\tif (assigned_[i] && copy_[i] !== base_[i]) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t\t})\n\t\t\t\tinversePatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(base_[i])\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\t// Process added indices.\n\t\tfor (let i = base_.length; i < copy_.length; i++) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tpatches.push({\n\t\t\t\top: ADD,\n\t\t\t\tpath,\n\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t})\n\t\t}\n\t\tif (base_.length < copy_.length) {\n\t\t\tinversePatches.push({\n\t\t\t\top: REPLACE,\n\t\t\t\tpath: basePath.concat([\"length\"]),\n\t\t\t\tvalue: base_.length\n\t\t\t})\n\t\t}\n\t}\n\n\t// This is used for both Map objects and normal objects.\n\tfunction generatePatchesFromAssigned(\n\t\tstate: MapState | ES5ObjectState | ProxyObjectState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tconst {base_, copy_} = state\n\t\teach(state.assigned_!, (key, assignedValue) => {\n\t\t\tconst origValue = get(base_, key)\n\t\t\tconst value = get(copy_!, key)\n\t\t\tconst op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD\n\t\t\tif (origValue === value && op === REPLACE) return\n\t\t\tconst path = basePath.concat(key as any)\n\t\t\tpatches.push(op === REMOVE ? {op, path} : {op, path, value})\n\t\t\tinversePatches.push(\n\t\t\t\top === ADD\n\t\t\t\t\t? {op: REMOVE, path}\n\t\t\t\t\t: op === REMOVE\n\t\t\t\t\t? {op: ADD, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t\t\t: {op: REPLACE, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t)\n\t\t})\n\t}\n\n\tfunction generateSetPatches(\n\t\tstate: SetState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, copy_} = state\n\n\t\tlet i = 0\n\t\tbase_.forEach((value: any) => {\n\t\t\tif (!copy_!.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t\ti = 0\n\t\tcopy_!.forEach((value: any) => {\n\t\t\tif (!base_.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t}\n\n\tfunction generateReplacementPatches_(\n\t\trootState: ImmerState,\n\t\treplacement: any,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t): void {\n\t\tpatches.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: replacement === NOTHING ? undefined : replacement\n\t\t})\n\t\tinversePatches.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: rootState.base_\n\t\t})\n\t}\n\n\tfunction applyPatches_<T>(draft: T, patches: Patch[]): T {\n\t\tpatches.forEach(patch => {\n\t\t\tconst {path, op} = patch\n\n\t\t\tlet base: any = draft\n\t\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\t\tconst parentType = getArchtype(base)\n\t\t\t\tconst p = \"\" + path[i]\n\t\t\t\t// See #738, avoid prototype pollution\n\t\t\t\tif (\n\t\t\t\t\t(parentType === Archtype.Object || parentType === Archtype.Array) &&\n\t\t\t\t\t(p === \"__proto__\" || p === \"constructor\")\n\t\t\t\t)\n\t\t\t\t\tdie(24)\n\t\t\t\tif (typeof base === \"function\" && p === \"prototype\") die(24)\n\t\t\t\tbase = get(base, p)\n\t\t\t\tif (typeof base !== \"object\") die(15, path.join(\"/\"))\n\t\t\t}\n\n\t\t\tconst type = getArchtype(base)\n\t\t\tconst value = deepClonePatchValue(patch.value) // used to clone patch to ensure original patch is not modified, see #411\n\t\t\tconst key = path[path.length - 1]\n\t\t\tswitch (op) {\n\t\t\t\tcase REPLACE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\tdie(16)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// if value is an object, then it's assigned by reference\n\t\t\t\t\t\t\t// in the following add or remove ops, the value field inside the patch will also be modifyed\n\t\t\t\t\t\t\t// so we use value from the cloned patch\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase ADD:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Array:\n\t\t\t\t\t\t\treturn base.splice(key as any, 0, value)\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\treturn base.add(value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase REMOVE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase Archtype.Array:\n\t\t\t\t\t\t\treturn base.splice(key as any, 1)\n\t\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\t\treturn base.delete(key)\n\t\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\t\treturn base.delete(patch.value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn delete base[key]\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tdie(17, op)\n\t\t\t}\n\t\t})\n\n\t\treturn draft\n\t}\n\n\t// optimize: this is quite a performance hit, can we detect intelligently when it is needed?\n\t// E.g. auto-draft when new objects from outside are assigned and modified?\n\t// (See failing test when deepClone just returns obj)\n\tfunction deepClonePatchValue<T>(obj: T): T\n\tfunction deepClonePatchValue(obj: any) {\n\t\tif (!isDraftable(obj)) return obj\n\t\tif (Array.isArray(obj)) return obj.map(deepClonePatchValue)\n\t\tif (isMap(obj))\n\t\t\treturn new Map(\n\t\t\t\tArray.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])\n\t\t\t)\n\t\tif (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue))\n\t\tconst cloned = Object.create(Object.getPrototypeOf(obj))\n\t\tfor (const key in obj) cloned[key] = deepClonePatchValue(obj[key])\n\t\tif (has(obj, immerable)) cloned[immerable] = obj[immerable]\n\t\treturn cloned\n\t}\n\n\tfunction clonePatchValueIfNeeded<T>(obj: T): T {\n\t\tif (isDraft(obj)) {\n\t\t\treturn deepClonePatchValue(obj)\n\t\t} else return obj\n\t}\n\n\tloadPlugin(\"Patches\", {\n\t\tapplyPatches_,\n\t\tgeneratePatches_,\n\t\tgenerateReplacementPatches_\n\t})\n}\n"], "filenames": ["__tests__/patch.js", "src/plugins/patches.ts"], "buggy_code_start_loc": [1260, 210], "buggy_code_end_loc": [1260, 211], "fixing_code_start_loc": [1261, 210], "fixing_code_end_loc": [1279, 211], "type": "CWE-1321", "message": "immer is vulnerable to Improperly Controlled Modification of Object Prototype Attributes ('Prototype Pollution')", "other": {"cve": {"id": "CVE-2021-3757", "sourceIdentifier": "security@huntr.dev", "published": "2021-09-02T12:15:07.617", "lastModified": "2022-09-10T02:46:16.353", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "immer is vulnerable to Improperly Controlled Modification of Object Prototype Attributes ('Prototype Pollution')"}, {"lang": "es", "value": "immer es vulnerable a una Modificaci\u00f3n Controlada Inapropiada de Atributos de Prototipos de Objetos (\"Contaminaci\u00f3n de Prototipos\")"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1321"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-1321"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:immer_project:immer:*:*:*:*:*:node.js:*:*", "versionEndIncluding": "9.0.5", "matchCriteriaId": "FA569641-1319-4F9F-B724-2D8F6C01676F"}]}]}], "references": [{"url": "https://github.com/immerjs/immer/commit/fa671e55ee9bd42ae08cc239102b665a23958237", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/23d38099-71cd-42ed-a77a-71e68094adfa", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/immerjs/immer/commit/fa671e55ee9bd42ae08cc239102b665a23958237"}}