{"buggy_code": ["// Copyright (c) 2010 Satoshi Nakamoto\n// Copyright (c) 2009-2012 The Bitcoin developers\n// Distributed under the MIT/X11 software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n\n#include \"init.h\"\n#include \"util.h\"\n#include \"sync.h\"\n#include \"ui_interface.h\"\n#include \"base58.h\"\n#include \"bitcoinrpc.h\"\n#include \"db.h\"\n\n#include <boost/asio.hpp>\n#include <boost/asio/ip/v6_only.hpp>\n#include <boost/bind.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/foreach.hpp>\n#include <boost/iostreams/concepts.hpp>\n#include <boost/iostreams/stream.hpp>\n#include <boost/algorithm/string.hpp>\n#include <boost/lexical_cast.hpp>\n#include <boost/asio/ssl.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/shared_ptr.hpp>\n#include <list>\n\nusing namespace std;\nusing namespace boost;\nusing namespace boost::asio;\nusing namespace json_spirit;\n\n// Key used by getwork/getblocktemplate miners.\n// Allocated in StartRPCThreads, free'd in StopRPCThreads\nCReserveKey* pMiningKey = NULL;\n\nstatic std::string strRPCUserColonPass;\n\n// These are created by StartRPCThreads, destroyed in StopRPCThreads\nstatic asio::io_service* rpc_io_service = NULL;\nstatic ssl::context* rpc_ssl_context = NULL;\nstatic boost::thread_group* rpc_worker_group = NULL;\n\nstatic inline unsigned short GetDefaultRPCPort()\n{\n    return GetBoolArg(\"-testnet\", false) ? 18332 : 8332;\n}\n\nObject JSONRPCError(int code, const string& message)\n{\n    Object error;\n    error.push_back(Pair(\"code\", code));\n    error.push_back(Pair(\"message\", message));\n    return error;\n}\n\nvoid RPCTypeCheck(const Array& params,\n                  const list<Value_type>& typesExpected,\n                  bool fAllowNull)\n{\n    unsigned int i = 0;\n    BOOST_FOREACH(Value_type t, typesExpected)\n    {\n        if (params.size() <= i)\n            break;\n\n        const Value& v = params[i];\n        if (!((v.type() == t) || (fAllowNull && (v.type() == null_type))))\n        {\n            string err = strprintf(\"Expected type %s, got %s\",\n                                   Value_type_name[t], Value_type_name[v.type()]);\n            throw JSONRPCError(RPC_TYPE_ERROR, err);\n        }\n        i++;\n    }\n}\n\nvoid RPCTypeCheck(const Object& o,\n                  const map<string, Value_type>& typesExpected,\n                  bool fAllowNull)\n{\n    BOOST_FOREACH(const PAIRTYPE(string, Value_type)& t, typesExpected)\n    {\n        const Value& v = find_value(o, t.first);\n        if (!fAllowNull && v.type() == null_type)\n            throw JSONRPCError(RPC_TYPE_ERROR, strprintf(\"Missing %s\", t.first.c_str()));\n\n        if (!((v.type() == t.second) || (fAllowNull && (v.type() == null_type))))\n        {\n            string err = strprintf(\"Expected type %s for %s, got %s\",\n                                   Value_type_name[t.second], t.first.c_str(), Value_type_name[v.type()]);\n            throw JSONRPCError(RPC_TYPE_ERROR, err);\n        }\n    }\n}\n\nint64 AmountFromValue(const Value& value)\n{\n    double dAmount = value.get_real();\n    if (dAmount <= 0.0 || dAmount > 21000000.0)\n        throw JSONRPCError(RPC_TYPE_ERROR, \"Invalid amount\");\n    int64 nAmount = roundint64(dAmount * COIN);\n    if (!MoneyRange(nAmount))\n        throw JSONRPCError(RPC_TYPE_ERROR, \"Invalid amount\");\n    return nAmount;\n}\n\nValue ValueFromAmount(int64 amount)\n{\n    return (double)amount / (double)COIN;\n}\n\nstd::string HexBits(unsigned int nBits)\n{\n    union {\n        int32_t nBits;\n        char cBits[4];\n    } uBits;\n    uBits.nBits = htonl((int32_t)nBits);\n    return HexStr(BEGIN(uBits.cBits), END(uBits.cBits));\n}\n\n\n\n///\n/// Note: This interface may still be subject to change.\n///\n\nstring CRPCTable::help(string strCommand) const\n{\n    string strRet;\n    set<rpcfn_type> setDone;\n    for (map<string, const CRPCCommand*>::const_iterator mi = mapCommands.begin(); mi != mapCommands.end(); ++mi)\n    {\n        const CRPCCommand *pcmd = mi->second;\n        string strMethod = mi->first;\n        // We already filter duplicates, but these deprecated screw up the sort order\n        if (strMethod.find(\"label\") != string::npos)\n            continue;\n        if (strCommand != \"\" && strMethod != strCommand)\n            continue;\n        try\n        {\n            Array params;\n            rpcfn_type pfn = pcmd->actor;\n            if (setDone.insert(pfn).second)\n                (*pfn)(params, true);\n        }\n        catch (std::exception& e)\n        {\n            // Help text is returned in an exception\n            string strHelp = string(e.what());\n            if (strCommand == \"\")\n                if (strHelp.find('\\n') != string::npos)\n                    strHelp = strHelp.substr(0, strHelp.find('\\n'));\n            strRet += strHelp + \"\\n\";\n        }\n    }\n    if (strRet == \"\")\n        strRet = strprintf(\"help: unknown command: %s\\n\", strCommand.c_str());\n    strRet = strRet.substr(0,strRet.size()-1);\n    return strRet;\n}\n\nValue help(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() > 1)\n        throw runtime_error(\n            \"help [command]\\n\"\n            \"List commands, or get help for a command.\");\n\n    string strCommand;\n    if (params.size() > 0)\n        strCommand = params[0].get_str();\n\n    return tableRPC.help(strCommand);\n}\n\n\nValue stop(const Array& params, bool fHelp)\n{\n    // Accept the deprecated and ignored 'detach' boolean argument\n    if (fHelp || params.size() > 1)\n        throw runtime_error(\n            \"stop\\n\"\n            \"Stop Bitcoin server.\");\n    // Shutdown will take long enough that the response should get back\n    StartShutdown();\n    return \"Bitcoin server stopping\";\n}\n\n\n\n//\n// Call Table\n//\n\n\nstatic const CRPCCommand vRPCCommands[] =\n{ //  name                      actor (function)         okSafeMode threadSafe\n  //  ------------------------  -----------------------  ---------- ----------\n    { \"help\",                   &help,                   true,      true },\n    { \"stop\",                   &stop,                   true,      true },\n    { \"getblockcount\",          &getblockcount,          true,      false },\n    { \"getconnectioncount\",     &getconnectioncount,     true,      false },\n    { \"getpeerinfo\",            &getpeerinfo,            true,      false },\n    { \"addnode\",                &addnode,                true,      true },\n    { \"getaddednodeinfo\",       &getaddednodeinfo,       true,      true },\n    { \"getdifficulty\",          &getdifficulty,          true,      false },\n    { \"getgenerate\",            &getgenerate,            true,      false },\n    { \"setgenerate\",            &setgenerate,            true,      false },\n    { \"gethashespersec\",        &gethashespersec,        true,      false },\n    { \"getinfo\",                &getinfo,                true,      false },\n    { \"getmininginfo\",          &getmininginfo,          true,      false },\n    { \"getnewaddress\",          &getnewaddress,          true,      false },\n    { \"getaccountaddress\",      &getaccountaddress,      true,      false },\n    { \"setaccount\",             &setaccount,             true,      false },\n    { \"getaccount\",             &getaccount,             false,     false },\n    { \"getaddressesbyaccount\",  &getaddressesbyaccount,  true,      false },\n    { \"sendtoaddress\",          &sendtoaddress,          false,     false },\n    { \"getreceivedbyaddress\",   &getreceivedbyaddress,   false,     false },\n    { \"getreceivedbyaccount\",   &getreceivedbyaccount,   false,     false },\n    { \"listreceivedbyaddress\",  &listreceivedbyaddress,  false,     false },\n    { \"listreceivedbyaccount\",  &listreceivedbyaccount,  false,     false },\n    { \"backupwallet\",           &backupwallet,           true,      false },\n    { \"keypoolrefill\",          &keypoolrefill,          true,      false },\n    { \"walletpassphrase\",       &walletpassphrase,       true,      false },\n    { \"walletpassphrasechange\", &walletpassphrasechange, false,     false },\n    { \"walletlock\",             &walletlock,             true,      false },\n    { \"encryptwallet\",          &encryptwallet,          false,     false },\n    { \"validateaddress\",        &validateaddress,        true,      false },\n    { \"getbalance\",             &getbalance,             false,     false },\n    { \"move\",                   &movecmd,                false,     false },\n    { \"sendfrom\",               &sendfrom,               false,     false },\n    { \"sendmany\",               &sendmany,               false,     false },\n    { \"addmultisigaddress\",     &addmultisigaddress,     false,     false },\n    { \"createmultisig\",         &createmultisig,         true,      true  },\n    { \"getrawmempool\",          &getrawmempool,          true,      false },\n    { \"getblock\",               &getblock,               false,     false },\n    { \"getblockhash\",           &getblockhash,           false,     false },\n    { \"gettransaction\",         &gettransaction,         false,     false },\n    { \"listtransactions\",       &listtransactions,       false,     false },\n    { \"listaddressgroupings\",   &listaddressgroupings,   false,     false },\n    { \"signmessage\",            &signmessage,            false,     false },\n    { \"verifymessage\",          &verifymessage,          false,     false },\n    { \"getwork\",                &getwork,                true,      false },\n    { \"listaccounts\",           &listaccounts,           false,     false },\n    { \"settxfee\",               &settxfee,               false,     false },\n    { \"getblocktemplate\",       &getblocktemplate,       true,      false },\n    { \"submitblock\",            &submitblock,            false,     false },\n    { \"listsinceblock\",         &listsinceblock,         false,     false },\n    { \"dumpprivkey\",            &dumpprivkey,            true,      false },\n    { \"importprivkey\",          &importprivkey,          false,     false },\n    { \"listunspent\",            &listunspent,            false,     false },\n    { \"getrawtransaction\",      &getrawtransaction,      false,     false },\n    { \"createrawtransaction\",   &createrawtransaction,   false,     false },\n    { \"decoderawtransaction\",   &decoderawtransaction,   false,     false },\n    { \"signrawtransaction\",     &signrawtransaction,     false,     false },\n    { \"sendrawtransaction\",     &sendrawtransaction,     false,     false },\n    { \"gettxoutsetinfo\",        &gettxoutsetinfo,        true,      false },\n    { \"gettxout\",               &gettxout,               true,      false },\n    { \"lockunspent\",            &lockunspent,            false,     false },\n    { \"listlockunspent\",        &listlockunspent,        false,     false },\n};\n\nCRPCTable::CRPCTable()\n{\n    unsigned int vcidx;\n    for (vcidx = 0; vcidx < (sizeof(vRPCCommands) / sizeof(vRPCCommands[0])); vcidx++)\n    {\n        const CRPCCommand *pcmd;\n\n        pcmd = &vRPCCommands[vcidx];\n        mapCommands[pcmd->name] = pcmd;\n    }\n}\n\nconst CRPCCommand *CRPCTable::operator[](string name) const\n{\n    map<string, const CRPCCommand*>::const_iterator it = mapCommands.find(name);\n    if (it == mapCommands.end())\n        return NULL;\n    return (*it).second;\n}\n\n//\n// HTTP protocol\n//\n// This ain't Apache.  We're just using HTTP header for the length field\n// and to be compatible with other JSON-RPC implementations.\n//\n\nstring HTTPPost(const string& strMsg, const map<string,string>& mapRequestHeaders)\n{\n    ostringstream s;\n    s << \"POST / HTTP/1.1\\r\\n\"\n      << \"User-Agent: bitcoin-json-rpc/\" << FormatFullVersion() << \"\\r\\n\"\n      << \"Host: 127.0.0.1\\r\\n\"\n      << \"Content-Type: application/json\\r\\n\"\n      << \"Content-Length: \" << strMsg.size() << \"\\r\\n\"\n      << \"Connection: close\\r\\n\"\n      << \"Accept: application/json\\r\\n\";\n    BOOST_FOREACH(const PAIRTYPE(string, string)& item, mapRequestHeaders)\n        s << item.first << \": \" << item.second << \"\\r\\n\";\n    s << \"\\r\\n\" << strMsg;\n\n    return s.str();\n}\n\nstring rfc1123Time()\n{\n    char buffer[64];\n    time_t now;\n    time(&now);\n    struct tm* now_gmt = gmtime(&now);\n    string locale(setlocale(LC_TIME, NULL));\n    setlocale(LC_TIME, \"C\"); // we want POSIX (aka \"C\") weekday/month strings\n    strftime(buffer, sizeof(buffer), \"%a, %d %b %Y %H:%M:%S +0000\", now_gmt);\n    setlocale(LC_TIME, locale.c_str());\n    return string(buffer);\n}\n\nstatic string HTTPReply(int nStatus, const string& strMsg, bool keepalive)\n{\n    if (nStatus == HTTP_UNAUTHORIZED)\n        return strprintf(\"HTTP/1.0 401 Authorization Required\\r\\n\"\n            \"Date: %s\\r\\n\"\n            \"Server: bitcoin-json-rpc/%s\\r\\n\"\n            \"WWW-Authenticate: Basic realm=\\\"jsonrpc\\\"\\r\\n\"\n            \"Content-Type: text/html\\r\\n\"\n            \"Content-Length: 296\\r\\n\"\n            \"\\r\\n\"\n            \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\"\\r\\n\"\n            \"\\\"http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd\\\">\\r\\n\"\n            \"<HTML>\\r\\n\"\n            \"<HEAD>\\r\\n\"\n            \"<TITLE>Error</TITLE>\\r\\n\"\n            \"<META HTTP-EQUIV='Content-Type' CONTENT='text/html; charset=ISO-8859-1'>\\r\\n\"\n            \"</HEAD>\\r\\n\"\n            \"<BODY><H1>401 Unauthorized.</H1></BODY>\\r\\n\"\n            \"</HTML>\\r\\n\", rfc1123Time().c_str(), FormatFullVersion().c_str());\n    const char *cStatus;\n         if (nStatus == HTTP_OK) cStatus = \"OK\";\n    else if (nStatus == HTTP_BAD_REQUEST) cStatus = \"Bad Request\";\n    else if (nStatus == HTTP_FORBIDDEN) cStatus = \"Forbidden\";\n    else if (nStatus == HTTP_NOT_FOUND) cStatus = \"Not Found\";\n    else if (nStatus == HTTP_INTERNAL_SERVER_ERROR) cStatus = \"Internal Server Error\";\n    else cStatus = \"\";\n    return strprintf(\n            \"HTTP/1.1 %d %s\\r\\n\"\n            \"Date: %s\\r\\n\"\n            \"Connection: %s\\r\\n\"\n            \"Content-Length: %\"PRIszu\"\\r\\n\"\n            \"Content-Type: application/json\\r\\n\"\n            \"Server: bitcoin-json-rpc/%s\\r\\n\"\n            \"\\r\\n\"\n            \"%s\",\n        nStatus,\n        cStatus,\n        rfc1123Time().c_str(),\n        keepalive ? \"keep-alive\" : \"close\",\n        strMsg.size(),\n        FormatFullVersion().c_str(),\n        strMsg.c_str());\n}\n\nbool ReadHTTPRequestLine(std::basic_istream<char>& stream, int &proto,\n                         string& http_method, string& http_uri)\n{\n    string str;\n    getline(stream, str);\n\n    // HTTP request line is space-delimited\n    vector<string> vWords;\n    boost::split(vWords, str, boost::is_any_of(\" \"));\n    if (vWords.size() < 2)\n        return false;\n\n    // HTTP methods permitted: GET, POST\n    http_method = vWords[0];\n    if (http_method != \"GET\" && http_method != \"POST\")\n        return false;\n\n    // HTTP URI must be an absolute path, relative to current host\n    http_uri = vWords[1];\n    if (http_uri.size() == 0 || http_uri[0] != '/')\n        return false;\n\n    // parse proto, if present\n    string strProto = \"\";\n    if (vWords.size() > 2)\n        strProto = vWords[2];\n\n    proto = 0;\n    const char *ver = strstr(strProto.c_str(), \"HTTP/1.\");\n    if (ver != NULL)\n        proto = atoi(ver+7);\n\n    return true;\n}\n\nint ReadHTTPStatus(std::basic_istream<char>& stream, int &proto)\n{\n    string str;\n    getline(stream, str);\n    vector<string> vWords;\n    boost::split(vWords, str, boost::is_any_of(\" \"));\n    if (vWords.size() < 2)\n        return HTTP_INTERNAL_SERVER_ERROR;\n    proto = 0;\n    const char *ver = strstr(str.c_str(), \"HTTP/1.\");\n    if (ver != NULL)\n        proto = atoi(ver+7);\n    return atoi(vWords[1].c_str());\n}\n\nint ReadHTTPHeaders(std::basic_istream<char>& stream, map<string, string>& mapHeadersRet)\n{\n    int nLen = 0;\n    loop\n    {\n        string str;\n        std::getline(stream, str);\n        if (str.empty() || str == \"\\r\")\n            break;\n        string::size_type nColon = str.find(\":\");\n        if (nColon != string::npos)\n        {\n            string strHeader = str.substr(0, nColon);\n            boost::trim(strHeader);\n            boost::to_lower(strHeader);\n            string strValue = str.substr(nColon+1);\n            boost::trim(strValue);\n            mapHeadersRet[strHeader] = strValue;\n            if (strHeader == \"content-length\")\n                nLen = atoi(strValue.c_str());\n        }\n    }\n    return nLen;\n}\n\nint ReadHTTPMessage(std::basic_istream<char>& stream, map<string,\n                    string>& mapHeadersRet, string& strMessageRet,\n                    int nProto)\n{\n    mapHeadersRet.clear();\n    strMessageRet = \"\";\n\n    // Read header\n    int nLen = ReadHTTPHeaders(stream, mapHeadersRet);\n    if (nLen < 0 || nLen > (int)MAX_SIZE)\n        return HTTP_INTERNAL_SERVER_ERROR;\n\n    // Read message\n    if (nLen > 0)\n    {\n        vector<char> vch(nLen);\n        stream.read(&vch[0], nLen);\n        strMessageRet = string(vch.begin(), vch.end());\n    }\n\n    string sConHdr = mapHeadersRet[\"connection\"];\n\n    if ((sConHdr != \"close\") && (sConHdr != \"keep-alive\"))\n    {\n        if (nProto >= 1)\n            mapHeadersRet[\"connection\"] = \"keep-alive\";\n        else\n            mapHeadersRet[\"connection\"] = \"close\";\n    }\n\n    return HTTP_OK;\n}\n\nbool HTTPAuthorized(map<string, string>& mapHeaders)\n{\n    string strAuth = mapHeaders[\"authorization\"];\n    if (strAuth.substr(0,6) != \"Basic \")\n        return false;\n    string strUserPass64 = strAuth.substr(6); boost::trim(strUserPass64);\n    string strUserPass = DecodeBase64(strUserPass64);\n    return strUserPass == strRPCUserColonPass;\n}\n\n//\n// JSON-RPC protocol.  Bitcoin speaks version 1.0 for maximum compatibility,\n// but uses JSON-RPC 1.1/2.0 standards for parts of the 1.0 standard that were\n// unspecified (HTTP errors and contents of 'error').\n//\n// 1.0 spec: http://json-rpc.org/wiki/specification\n// 1.2 spec: http://groups.google.com/group/json-rpc/web/json-rpc-over-http\n// http://www.codeproject.com/KB/recipes/JSON_Spirit.aspx\n//\n\nstring JSONRPCRequest(const string& strMethod, const Array& params, const Value& id)\n{\n    Object request;\n    request.push_back(Pair(\"method\", strMethod));\n    request.push_back(Pair(\"params\", params));\n    request.push_back(Pair(\"id\", id));\n    return write_string(Value(request), false) + \"\\n\";\n}\n\nObject JSONRPCReplyObj(const Value& result, const Value& error, const Value& id)\n{\n    Object reply;\n    if (error.type() != null_type)\n        reply.push_back(Pair(\"result\", Value::null));\n    else\n        reply.push_back(Pair(\"result\", result));\n    reply.push_back(Pair(\"error\", error));\n    reply.push_back(Pair(\"id\", id));\n    return reply;\n}\n\nstring JSONRPCReply(const Value& result, const Value& error, const Value& id)\n{\n    Object reply = JSONRPCReplyObj(result, error, id);\n    return write_string(Value(reply), false) + \"\\n\";\n}\n\nvoid ErrorReply(std::ostream& stream, const Object& objError, const Value& id)\n{\n    // Send error reply from json-rpc error object\n    int nStatus = HTTP_INTERNAL_SERVER_ERROR;\n    int code = find_value(objError, \"code\").get_int();\n    if (code == RPC_INVALID_REQUEST) nStatus = HTTP_BAD_REQUEST;\n    else if (code == RPC_METHOD_NOT_FOUND) nStatus = HTTP_NOT_FOUND;\n    string strReply = JSONRPCReply(Value::null, objError, id);\n    stream << HTTPReply(nStatus, strReply, false) << std::flush;\n}\n\nbool ClientAllowed(const boost::asio::ip::address& address)\n{\n    // Make sure that IPv4-compatible and IPv4-mapped IPv6 addresses are treated as IPv4 addresses\n    if (address.is_v6()\n     && (address.to_v6().is_v4_compatible()\n      || address.to_v6().is_v4_mapped()))\n        return ClientAllowed(address.to_v6().to_v4());\n\n    if (address == asio::ip::address_v4::loopback()\n     || address == asio::ip::address_v6::loopback()\n     || (address.is_v4()\n         // Check whether IPv4 addresses match 127.0.0.0/8 (loopback subnet)\n      && (address.to_v4().to_ulong() & 0xff000000) == 0x7f000000))\n        return true;\n\n    const string strAddress = address.to_string();\n    const vector<string>& vAllow = mapMultiArgs[\"-rpcallowip\"];\n    BOOST_FOREACH(string strAllow, vAllow)\n        if (WildcardMatch(strAddress, strAllow))\n            return true;\n    return false;\n}\n\n//\n// IOStream device that speaks SSL but can also speak non-SSL\n//\ntemplate <typename Protocol>\nclass SSLIOStreamDevice : public iostreams::device<iostreams::bidirectional> {\npublic:\n    SSLIOStreamDevice(asio::ssl::stream<typename Protocol::socket> &streamIn, bool fUseSSLIn) : stream(streamIn)\n    {\n        fUseSSL = fUseSSLIn;\n        fNeedHandshake = fUseSSLIn;\n    }\n\n    void handshake(ssl::stream_base::handshake_type role)\n    {\n        if (!fNeedHandshake) return;\n        fNeedHandshake = false;\n        stream.handshake(role);\n    }\n    std::streamsize read(char* s, std::streamsize n)\n    {\n        handshake(ssl::stream_base::server); // HTTPS servers read first\n        if (fUseSSL) return stream.read_some(asio::buffer(s, n));\n        return stream.next_layer().read_some(asio::buffer(s, n));\n    }\n    std::streamsize write(const char* s, std::streamsize n)\n    {\n        handshake(ssl::stream_base::client); // HTTPS clients write first\n        if (fUseSSL) return asio::write(stream, asio::buffer(s, n));\n        return asio::write(stream.next_layer(), asio::buffer(s, n));\n    }\n    bool connect(const std::string& server, const std::string& port)\n    {\n        ip::tcp::resolver resolver(stream.get_io_service());\n        ip::tcp::resolver::query query(server.c_str(), port.c_str());\n        ip::tcp::resolver::iterator endpoint_iterator = resolver.resolve(query);\n        ip::tcp::resolver::iterator end;\n        boost::system::error_code error = asio::error::host_not_found;\n        while (error && endpoint_iterator != end)\n        {\n            stream.lowest_layer().close();\n            stream.lowest_layer().connect(*endpoint_iterator++, error);\n        }\n        if (error)\n            return false;\n        return true;\n    }\n\nprivate:\n    bool fNeedHandshake;\n    bool fUseSSL;\n    asio::ssl::stream<typename Protocol::socket>& stream;\n};\n\nclass AcceptedConnection\n{\npublic:\n    virtual ~AcceptedConnection() {}\n\n    virtual std::iostream& stream() = 0;\n    virtual std::string peer_address_to_string() const = 0;\n    virtual void close() = 0;\n};\n\ntemplate <typename Protocol>\nclass AcceptedConnectionImpl : public AcceptedConnection\n{\npublic:\n    AcceptedConnectionImpl(\n            asio::io_service& io_service,\n            ssl::context &context,\n            bool fUseSSL) :\n        sslStream(io_service, context),\n        _d(sslStream, fUseSSL),\n        _stream(_d)\n    {\n    }\n\n    virtual std::iostream& stream()\n    {\n        return _stream;\n    }\n\n    virtual std::string peer_address_to_string() const\n    {\n        return peer.address().to_string();\n    }\n\n    virtual void close()\n    {\n        _stream.close();\n    }\n\n    typename Protocol::endpoint peer;\n    asio::ssl::stream<typename Protocol::socket> sslStream;\n\nprivate:\n    SSLIOStreamDevice<Protocol> _d;\n    iostreams::stream< SSLIOStreamDevice<Protocol> > _stream;\n};\n\nvoid ServiceConnection(AcceptedConnection *conn);\n\n// Forward declaration required for RPCListen\ntemplate <typename Protocol, typename SocketAcceptorService>\nstatic void RPCAcceptHandler(boost::shared_ptr< basic_socket_acceptor<Protocol, SocketAcceptorService> > acceptor,\n                             ssl::context& context,\n                             bool fUseSSL,\n                             AcceptedConnection* conn,\n                             const boost::system::error_code& error);\n\n/**\n * Sets up I/O resources to accept and handle a new connection.\n */\ntemplate <typename Protocol, typename SocketAcceptorService>\nstatic void RPCListen(boost::shared_ptr< basic_socket_acceptor<Protocol, SocketAcceptorService> > acceptor,\n                   ssl::context& context,\n                   const bool fUseSSL)\n{\n    // Accept connection\n    AcceptedConnectionImpl<Protocol>* conn = new AcceptedConnectionImpl<Protocol>(acceptor->get_io_service(), context, fUseSSL);\n\n    acceptor->async_accept(\n            conn->sslStream.lowest_layer(),\n            conn->peer,\n            boost::bind(&RPCAcceptHandler<Protocol, SocketAcceptorService>,\n                acceptor,\n                boost::ref(context),\n                fUseSSL,\n                conn,\n                boost::asio::placeholders::error));\n}\n\n/**\n * Accept and handle incoming connection.\n */\ntemplate <typename Protocol, typename SocketAcceptorService>\nstatic void RPCAcceptHandler(boost::shared_ptr< basic_socket_acceptor<Protocol, SocketAcceptorService> > acceptor,\n                             ssl::context& context,\n                             const bool fUseSSL,\n                             AcceptedConnection* conn,\n                             const boost::system::error_code& error)\n{\n    // Immediately start accepting new connections, except when we're cancelled or our socket is closed.\n    if (error != asio::error::operation_aborted && acceptor->is_open())\n        RPCListen(acceptor, context, fUseSSL);\n\n    AcceptedConnectionImpl<ip::tcp>* tcp_conn = dynamic_cast< AcceptedConnectionImpl<ip::tcp>* >(conn);\n\n    // TODO: Actually handle errors\n    if (error)\n    {\n        delete conn;\n    }\n\n    // Restrict callers by IP.  It is important to\n    // do this before starting client thread, to filter out\n    // certain DoS and misbehaving clients.\n    else if (tcp_conn && !ClientAllowed(tcp_conn->peer.address()))\n    {\n        // Only send a 403 if we're not using SSL to prevent a DoS during the SSL handshake.\n        if (!fUseSSL)\n            conn->stream() << HTTPReply(HTTP_FORBIDDEN, \"\", false) << std::flush;\n        delete conn;\n    }\n    else {\n        ServiceConnection(conn);\n        conn->close();\n        delete conn;\n    }\n}\n\nvoid StartRPCThreads()\n{\n    // getwork/getblocktemplate mining rewards paid here:\n    pMiningKey = new CReserveKey(pwalletMain);\n\n    strRPCUserColonPass = mapArgs[\"-rpcuser\"] + \":\" + mapArgs[\"-rpcpassword\"];\n    if ((mapArgs[\"-rpcpassword\"] == \"\") ||\n        (mapArgs[\"-rpcuser\"] == mapArgs[\"-rpcpassword\"]))\n    {\n        unsigned char rand_pwd[32];\n        RAND_bytes(rand_pwd, 32);\n        string strWhatAmI = \"To use bitcoind\";\n        if (mapArgs.count(\"-server\"))\n            strWhatAmI = strprintf(_(\"To use the %s option\"), \"\\\"-server\\\"\");\n        else if (mapArgs.count(\"-daemon\"))\n            strWhatAmI = strprintf(_(\"To use the %s option\"), \"\\\"-daemon\\\"\");\n        uiInterface.ThreadSafeMessageBox(strprintf(\n            _(\"%s, you must set a rpcpassword in the configuration file:\\n\"\n              \"%s\\n\"\n              \"It is recommended you use the following random password:\\n\"\n              \"rpcuser=bitcoinrpc\\n\"\n              \"rpcpassword=%s\\n\"\n              \"(you do not need to remember this password)\\n\"\n              \"The username and password MUST NOT be the same.\\n\"\n              \"If the file does not exist, create it with owner-readable-only file permissions.\\n\"\n              \"It is also recommended to set alertnotify so you are notified of problems;\\n\"\n              \"for example: alertnotify=echo %%s | mail -s \\\"Bitcoin Alert\\\" admin@foo.com\\n\"),\n                strWhatAmI.c_str(),\n                GetConfigFile().string().c_str(),\n                EncodeBase58(&rand_pwd[0],&rand_pwd[0]+32).c_str()),\n                \"\", CClientUIInterface::MSG_ERROR);\n        StartShutdown();\n        return;\n    }\n\n    assert(rpc_io_service == NULL);\n    rpc_io_service = new asio::io_service();\n    rpc_ssl_context = new ssl::context(*rpc_io_service, ssl::context::sslv23);\n\n    const bool fUseSSL = GetBoolArg(\"-rpcssl\");\n\n    if (fUseSSL)\n    {\n        rpc_ssl_context->set_options(ssl::context::no_sslv2);\n\n        filesystem::path pathCertFile(GetArg(\"-rpcsslcertificatechainfile\", \"server.cert\"));\n        if (!pathCertFile.is_complete()) pathCertFile = filesystem::path(GetDataDir()) / pathCertFile;\n        if (filesystem::exists(pathCertFile)) rpc_ssl_context->use_certificate_chain_file(pathCertFile.string());\n        else printf(\"ThreadRPCServer ERROR: missing server certificate file %s\\n\", pathCertFile.string().c_str());\n\n        filesystem::path pathPKFile(GetArg(\"-rpcsslprivatekeyfile\", \"server.pem\"));\n        if (!pathPKFile.is_complete()) pathPKFile = filesystem::path(GetDataDir()) / pathPKFile;\n        if (filesystem::exists(pathPKFile)) rpc_ssl_context->use_private_key_file(pathPKFile.string(), ssl::context::pem);\n        else printf(\"ThreadRPCServer ERROR: missing server private key file %s\\n\", pathPKFile.string().c_str());\n\n        string strCiphers = GetArg(\"-rpcsslciphers\", \"TLSv1+HIGH:!SSLv2:!aNULL:!eNULL:!AH:!3DES:@STRENGTH\");\n        SSL_CTX_set_cipher_list(rpc_ssl_context->impl(), strCiphers.c_str());\n    }\n\n    // Try a dual IPv6/IPv4 socket, falling back to separate IPv4 and IPv6 sockets\n    const bool loopback = !mapArgs.count(\"-rpcallowip\");\n    asio::ip::address bindAddress = loopback ? asio::ip::address_v6::loopback() : asio::ip::address_v6::any();\n    ip::tcp::endpoint endpoint(bindAddress, GetArg(\"-rpcport\", GetDefaultRPCPort()));\n    boost::system::error_code v6_only_error;\n    boost::shared_ptr<ip::tcp::acceptor> acceptor(new ip::tcp::acceptor(*rpc_io_service));\n\n    bool fListening = false;\n    std::string strerr;\n    try\n    {\n        acceptor->open(endpoint.protocol());\n        acceptor->set_option(boost::asio::ip::tcp::acceptor::reuse_address(true));\n\n        // Try making the socket dual IPv6/IPv4 (if listening on the \"any\" address)\n        acceptor->set_option(boost::asio::ip::v6_only(loopback), v6_only_error);\n\n        acceptor->bind(endpoint);\n        acceptor->listen(socket_base::max_connections);\n\n        RPCListen(acceptor, *rpc_ssl_context, fUseSSL);\n\n        fListening = true;\n    }\n    catch(boost::system::system_error &e)\n    {\n        strerr = strprintf(_(\"An error occurred while setting up the RPC port %u for listening on IPv6, falling back to IPv4: %s\"), endpoint.port(), e.what());\n    }\n\n    try {\n        // If dual IPv6/IPv4 failed (or we're opening loopback interfaces only), open IPv4 separately\n        if (!fListening || loopback || v6_only_error)\n        {\n            bindAddress = loopback ? asio::ip::address_v4::loopback() : asio::ip::address_v4::any();\n            endpoint.address(bindAddress);\n\n            acceptor.reset(new ip::tcp::acceptor(*rpc_io_service));\n            acceptor->open(endpoint.protocol());\n            acceptor->set_option(boost::asio::ip::tcp::acceptor::reuse_address(true));\n            acceptor->bind(endpoint);\n            acceptor->listen(socket_base::max_connections);\n\n            RPCListen(acceptor, *rpc_ssl_context, fUseSSL);\n\n            fListening = true;\n        }\n    }\n    catch(boost::system::system_error &e)\n    {\n        strerr = strprintf(_(\"An error occurred while setting up the RPC port %u for listening on IPv4: %s\"), endpoint.port(), e.what());\n    }\n\n    if (!fListening) {\n        uiInterface.ThreadSafeMessageBox(strerr, \"\", CClientUIInterface::MSG_ERROR);\n        StartShutdown();\n        return;\n    }\n\n    rpc_worker_group = new boost::thread_group();\n    for (int i = 0; i < GetArg(\"-rpcthreads\", 4); i++)\n        rpc_worker_group->create_thread(boost::bind(&asio::io_service::run, rpc_io_service));\n}\n\nvoid StopRPCThreads()\n{\n    delete pMiningKey; pMiningKey = NULL;\n\n    if (rpc_io_service == NULL) return;\n\n    rpc_io_service->stop();\n    rpc_worker_group->join_all();\n    delete rpc_worker_group; rpc_worker_group = NULL;\n    delete rpc_ssl_context; rpc_ssl_context = NULL;\n    delete rpc_io_service; rpc_io_service = NULL;\n}\n\nclass JSONRequest\n{\npublic:\n    Value id;\n    string strMethod;\n    Array params;\n\n    JSONRequest() { id = Value::null; }\n    void parse(const Value& valRequest);\n};\n\nvoid JSONRequest::parse(const Value& valRequest)\n{\n    // Parse request\n    if (valRequest.type() != obj_type)\n        throw JSONRPCError(RPC_INVALID_REQUEST, \"Invalid Request object\");\n    const Object& request = valRequest.get_obj();\n\n    // Parse id now so errors from here on will have the id\n    id = find_value(request, \"id\");\n\n    // Parse method\n    Value valMethod = find_value(request, \"method\");\n    if (valMethod.type() == null_type)\n        throw JSONRPCError(RPC_INVALID_REQUEST, \"Missing method\");\n    if (valMethod.type() != str_type)\n        throw JSONRPCError(RPC_INVALID_REQUEST, \"Method must be a string\");\n    strMethod = valMethod.get_str();\n    if (strMethod != \"getwork\" && strMethod != \"getblocktemplate\")\n        printf(\"ThreadRPCServer method=%s\\n\", strMethod.c_str());\n\n    // Parse params\n    Value valParams = find_value(request, \"params\");\n    if (valParams.type() == array_type)\n        params = valParams.get_array();\n    else if (valParams.type() == null_type)\n        params = Array();\n    else\n        throw JSONRPCError(RPC_INVALID_REQUEST, \"Params must be an array\");\n}\n\nstatic Object JSONRPCExecOne(const Value& req)\n{\n    Object rpc_result;\n\n    JSONRequest jreq;\n    try {\n        jreq.parse(req);\n\n        Value result = tableRPC.execute(jreq.strMethod, jreq.params);\n        rpc_result = JSONRPCReplyObj(result, Value::null, jreq.id);\n    }\n    catch (Object& objError)\n    {\n        rpc_result = JSONRPCReplyObj(Value::null, objError, jreq.id);\n    }\n    catch (std::exception& e)\n    {\n        rpc_result = JSONRPCReplyObj(Value::null,\n                                     JSONRPCError(RPC_PARSE_ERROR, e.what()), jreq.id);\n    }\n\n    return rpc_result;\n}\n\nstatic string JSONRPCExecBatch(const Array& vReq)\n{\n    Array ret;\n    for (unsigned int reqIdx = 0; reqIdx < vReq.size(); reqIdx++)\n        ret.push_back(JSONRPCExecOne(vReq[reqIdx]));\n\n    return write_string(Value(ret), false) + \"\\n\";\n}\n\nvoid ServiceConnection(AcceptedConnection *conn)\n{\n    bool fRun = true;\n    while (fRun)\n    {\n        int nProto = 0;\n        map<string, string> mapHeaders;\n        string strRequest, strMethod, strURI;\n\n        // Read HTTP request line\n        if (!ReadHTTPRequestLine(conn->stream(), nProto, strMethod, strURI))\n            break;\n\n        // Read HTTP message headers and body\n        ReadHTTPMessage(conn->stream(), mapHeaders, strRequest, nProto);\n\n        if (strURI != \"/\") {\n            conn->stream() << HTTPReply(HTTP_NOT_FOUND, \"\", false) << std::flush;\n            break;\n        }\n\n        // Check authorization\n        if (mapHeaders.count(\"authorization\") == 0)\n        {\n            conn->stream() << HTTPReply(HTTP_UNAUTHORIZED, \"\", false) << std::flush;\n            break;\n        }\n        if (!HTTPAuthorized(mapHeaders))\n        {\n            printf(\"ThreadRPCServer incorrect password attempt from %s\\n\", conn->peer_address_to_string().c_str());\n            /* Deter brute-forcing short passwords.\n               If this results in a DOS the user really\n               shouldn't have their RPC port exposed.*/\n            if (mapArgs[\"-rpcpassword\"].size() < 20)\n                MilliSleep(250);\n\n            conn->stream() << HTTPReply(HTTP_UNAUTHORIZED, \"\", false) << std::flush;\n            break;\n        }\n        if (mapHeaders[\"connection\"] == \"close\")\n            fRun = false;\n\n        JSONRequest jreq;\n        try\n        {\n            // Parse request\n            Value valRequest;\n            if (!read_string(strRequest, valRequest))\n                throw JSONRPCError(RPC_PARSE_ERROR, \"Parse error\");\n\n            string strReply;\n\n            // singleton request\n            if (valRequest.type() == obj_type) {\n                jreq.parse(valRequest);\n\n                Value result = tableRPC.execute(jreq.strMethod, jreq.params);\n\n                // Send reply\n                strReply = JSONRPCReply(result, Value::null, jreq.id);\n\n            // array of requests\n            } else if (valRequest.type() == array_type)\n                strReply = JSONRPCExecBatch(valRequest.get_array());\n            else\n                throw JSONRPCError(RPC_PARSE_ERROR, \"Top-level object parse error\");\n\n            conn->stream() << HTTPReply(HTTP_OK, strReply, fRun) << std::flush;\n        }\n        catch (Object& objError)\n        {\n            ErrorReply(conn->stream(), objError, jreq.id);\n            break;\n        }\n        catch (std::exception& e)\n        {\n            ErrorReply(conn->stream(), JSONRPCError(RPC_PARSE_ERROR, e.what()), jreq.id);\n            break;\n        }\n    }\n}\n\njson_spirit::Value CRPCTable::execute(const std::string &strMethod, const json_spirit::Array &params) const\n{\n    // Find method\n    const CRPCCommand *pcmd = tableRPC[strMethod];\n    if (!pcmd)\n        throw JSONRPCError(RPC_METHOD_NOT_FOUND, \"Method not found\");\n\n    // Observe safe mode\n    string strWarning = GetWarnings(\"rpc\");\n    if (strWarning != \"\" && !GetBoolArg(\"-disablesafemode\") &&\n        !pcmd->okSafeMode)\n        throw JSONRPCError(RPC_FORBIDDEN_BY_SAFE_MODE, string(\"Safe mode: \") + strWarning);\n\n    try\n    {\n        // Execute\n        Value result;\n        {\n            if (pcmd->threadSafe)\n                result = pcmd->actor(params, false);\n            else {\n                LOCK2(cs_main, pwalletMain->cs_wallet);\n                result = pcmd->actor(params, false);\n            }\n        }\n        return result;\n    }\n    catch (std::exception& e)\n    {\n        throw JSONRPCError(RPC_MISC_ERROR, e.what());\n    }\n}\n\n\nObject CallRPC(const string& strMethod, const Array& params)\n{\n    if (mapArgs[\"-rpcuser\"] == \"\" && mapArgs[\"-rpcpassword\"] == \"\")\n        throw runtime_error(strprintf(\n            _(\"You must set rpcpassword=<password> in the configuration file:\\n%s\\n\"\n              \"If the file does not exist, create it with owner-readable-only file permissions.\"),\n                GetConfigFile().string().c_str()));\n\n    // Connect to localhost\n    bool fUseSSL = GetBoolArg(\"-rpcssl\");\n    asio::io_service io_service;\n    ssl::context context(io_service, ssl::context::sslv23);\n    context.set_options(ssl::context::no_sslv2);\n    asio::ssl::stream<asio::ip::tcp::socket> sslStream(io_service, context);\n    SSLIOStreamDevice<asio::ip::tcp> d(sslStream, fUseSSL);\n    iostreams::stream< SSLIOStreamDevice<asio::ip::tcp> > stream(d);\n    if (!d.connect(GetArg(\"-rpcconnect\", \"127.0.0.1\"), GetArg(\"-rpcport\", itostr(GetDefaultRPCPort()))))\n        throw runtime_error(\"couldn't connect to server\");\n\n    // HTTP basic authentication\n    string strUserPass64 = EncodeBase64(mapArgs[\"-rpcuser\"] + \":\" + mapArgs[\"-rpcpassword\"]);\n    map<string, string> mapRequestHeaders;\n    mapRequestHeaders[\"Authorization\"] = string(\"Basic \") + strUserPass64;\n\n    // Send request\n    string strRequest = JSONRPCRequest(strMethod, params, 1);\n    string strPost = HTTPPost(strRequest, mapRequestHeaders);\n    stream << strPost << std::flush;\n\n    // Receive HTTP reply status\n    int nProto = 0;\n    int nStatus = ReadHTTPStatus(stream, nProto);\n\n    // Receive HTTP reply message headers and body\n    map<string, string> mapHeaders;\n    string strReply;\n    ReadHTTPMessage(stream, mapHeaders, strReply, nProto);\n\n    if (nStatus == HTTP_UNAUTHORIZED)\n        throw runtime_error(\"incorrect rpcuser or rpcpassword (authorization failed)\");\n    else if (nStatus >= 400 && nStatus != HTTP_BAD_REQUEST && nStatus != HTTP_NOT_FOUND && nStatus != HTTP_INTERNAL_SERVER_ERROR)\n        throw runtime_error(strprintf(\"server returned HTTP error %d\", nStatus));\n    else if (strReply.empty())\n        throw runtime_error(\"no response from server\");\n\n    // Parse reply\n    Value valReply;\n    if (!read_string(strReply, valReply))\n        throw runtime_error(\"couldn't parse reply from server\");\n    const Object& reply = valReply.get_obj();\n    if (reply.empty())\n        throw runtime_error(\"expected reply to have result, error and id properties\");\n\n    return reply;\n}\n\n\n\n\ntemplate<typename T>\nvoid ConvertTo(Value& value, bool fAllowNull=false)\n{\n    if (fAllowNull && value.type() == null_type)\n        return;\n    if (value.type() == str_type)\n    {\n        // reinterpret string as unquoted json value\n        Value value2;\n        string strJSON = value.get_str();\n        if (!read_string(strJSON, value2))\n            throw runtime_error(string(\"Error parsing JSON:\")+strJSON);\n        ConvertTo<T>(value2, fAllowNull);\n        value = value2;\n    }\n    else\n    {\n        value = value.get_value<T>();\n    }\n}\n\n// Convert strings to command-specific RPC representation\nArray RPCConvertValues(const std::string &strMethod, const std::vector<std::string> &strParams)\n{\n    Array params;\n    BOOST_FOREACH(const std::string &param, strParams)\n        params.push_back(param);\n\n    int n = params.size();\n\n    //\n    // Special case non-string parameter types\n    //\n    if (strMethod == \"stop\"                   && n > 0) ConvertTo<bool>(params[0]);\n    if (strMethod == \"getaddednodeinfo\"       && n > 0) ConvertTo<bool>(params[0]);\n    if (strMethod == \"setgenerate\"            && n > 0) ConvertTo<bool>(params[0]);\n    if (strMethod == \"setgenerate\"            && n > 1) ConvertTo<boost::int64_t>(params[1]);\n    if (strMethod == \"sendtoaddress\"          && n > 1) ConvertTo<double>(params[1]);\n    if (strMethod == \"settxfee\"               && n > 0) ConvertTo<double>(params[0]);\n    if (strMethod == \"getreceivedbyaddress\"   && n > 1) ConvertTo<boost::int64_t>(params[1]);\n    if (strMethod == \"getreceivedbyaccount\"   && n > 1) ConvertTo<boost::int64_t>(params[1]);\n    if (strMethod == \"listreceivedbyaddress\"  && n > 0) ConvertTo<boost::int64_t>(params[0]);\n    if (strMethod == \"listreceivedbyaddress\"  && n > 1) ConvertTo<bool>(params[1]);\n    if (strMethod == \"listreceivedbyaccount\"  && n > 0) ConvertTo<boost::int64_t>(params[0]);\n    if (strMethod == \"listreceivedbyaccount\"  && n > 1) ConvertTo<bool>(params[1]);\n    if (strMethod == \"getbalance\"             && n > 1) ConvertTo<boost::int64_t>(params[1]);\n    if (strMethod == \"getblockhash\"           && n > 0) ConvertTo<boost::int64_t>(params[0]);\n    if (strMethod == \"move\"                   && n > 2) ConvertTo<double>(params[2]);\n    if (strMethod == \"move\"                   && n > 3) ConvertTo<boost::int64_t>(params[3]);\n    if (strMethod == \"sendfrom\"               && n > 2) ConvertTo<double>(params[2]);\n    if (strMethod == \"sendfrom\"               && n > 3) ConvertTo<boost::int64_t>(params[3]);\n    if (strMethod == \"listtransactions\"       && n > 1) ConvertTo<boost::int64_t>(params[1]);\n    if (strMethod == \"listtransactions\"       && n > 2) ConvertTo<boost::int64_t>(params[2]);\n    if (strMethod == \"listaccounts\"           && n > 0) ConvertTo<boost::int64_t>(params[0]);\n    if (strMethod == \"walletpassphrase\"       && n > 1) ConvertTo<boost::int64_t>(params[1]);\n    if (strMethod == \"getblocktemplate\"       && n > 0) ConvertTo<Object>(params[0]);\n    if (strMethod == \"listsinceblock\"         && n > 1) ConvertTo<boost::int64_t>(params[1]);\n    if (strMethod == \"sendmany\"               && n > 1) ConvertTo<Object>(params[1]);\n    if (strMethod == \"sendmany\"               && n > 2) ConvertTo<boost::int64_t>(params[2]);\n    if (strMethod == \"addmultisigaddress\"     && n > 0) ConvertTo<boost::int64_t>(params[0]);\n    if (strMethod == \"addmultisigaddress\"     && n > 1) ConvertTo<Array>(params[1]);\n    if (strMethod == \"createmultisig\"         && n > 0) ConvertTo<boost::int64_t>(params[0]);\n    if (strMethod == \"createmultisig\"         && n > 1) ConvertTo<Array>(params[1]);\n    if (strMethod == \"listunspent\"            && n > 0) ConvertTo<boost::int64_t>(params[0]);\n    if (strMethod == \"listunspent\"            && n > 1) ConvertTo<boost::int64_t>(params[1]);\n    if (strMethod == \"listunspent\"            && n > 2) ConvertTo<Array>(params[2]);\n    if (strMethod == \"getrawtransaction\"      && n > 1) ConvertTo<boost::int64_t>(params[1]);\n    if (strMethod == \"createrawtransaction\"   && n > 0) ConvertTo<Array>(params[0]);\n    if (strMethod == \"createrawtransaction\"   && n > 1) ConvertTo<Object>(params[1]);\n    if (strMethod == \"signrawtransaction\"     && n > 1) ConvertTo<Array>(params[1], true);\n    if (strMethod == \"signrawtransaction\"     && n > 2) ConvertTo<Array>(params[2], true);\n    if (strMethod == \"gettxout\"               && n > 1) ConvertTo<boost::int64_t>(params[1]);\n    if (strMethod == \"gettxout\"               && n > 2) ConvertTo<bool>(params[2]);\n    if (strMethod == \"lockunspent\"            && n > 0) ConvertTo<bool>(params[0]);\n    if (strMethod == \"lockunspent\"            && n > 1) ConvertTo<Array>(params[1]);\n    if (strMethod == \"importprivkey\"          && n > 2) ConvertTo<bool>(params[2]);\n\n    return params;\n}\n\nint CommandLineRPC(int argc, char *argv[])\n{\n    string strPrint;\n    int nRet = 0;\n    try\n    {\n        // Skip switches\n        while (argc > 1 && IsSwitchChar(argv[1][0]))\n        {\n            argc--;\n            argv++;\n        }\n\n        // Method\n        if (argc < 2)\n            throw runtime_error(\"too few parameters\");\n        string strMethod = argv[1];\n\n        // Parameters default to strings\n        std::vector<std::string> strParams(&argv[2], &argv[argc]);\n        Array params = RPCConvertValues(strMethod, strParams);\n\n        // Execute\n        Object reply = CallRPC(strMethod, params);\n\n        // Parse reply\n        const Value& result = find_value(reply, \"result\");\n        const Value& error  = find_value(reply, \"error\");\n\n        if (error.type() != null_type)\n        {\n            // Error\n            strPrint = \"error: \" + write_string(error, false);\n            int code = find_value(error.get_obj(), \"code\").get_int();\n            nRet = abs(code);\n        }\n        else\n        {\n            // Result\n            if (result.type() == null_type)\n                strPrint = \"\";\n            else if (result.type() == str_type)\n                strPrint = result.get_str();\n            else\n                strPrint = write_string(result, true);\n        }\n    }\n    catch (boost::thread_interrupted) {\n        throw;\n    }\n    catch (std::exception& e) {\n        strPrint = string(\"error: \") + e.what();\n        nRet = 87;\n    }\n    catch (...) {\n        PrintException(NULL, \"CommandLineRPC()\");\n    }\n\n    if (strPrint != \"\")\n    {\n        fprintf((nRet == 0 ? stdout : stderr), \"%s\\n\", strPrint.c_str());\n    }\n    return nRet;\n}\n\n\n\n\n#ifdef TEST\nint main(int argc, char *argv[])\n{\n#ifdef _MSC_VER\n    // Turn off Microsoft heap dump noise\n    _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE);\n    _CrtSetReportFile(_CRT_WARN, CreateFile(\"NUL\", GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, 0));\n#endif\n    setbuf(stdin, NULL);\n    setbuf(stdout, NULL);\n    setbuf(stderr, NULL);\n\n    try\n    {\n        if (argc >= 2 && string(argv[1]) == \"-server\")\n        {\n            printf(\"server ready\\n\");\n            ThreadRPCServer(NULL);\n        }\n        else\n        {\n            return CommandLineRPC(argc, argv);\n        }\n    }\n    catch (boost::thread_interrupted) {\n        throw;\n    }\n    catch (std::exception& e) {\n        PrintException(&e, \"main()\");\n    } catch (...) {\n        PrintException(NULL, \"main()\");\n    }\n    return 0;\n}\n#endif\n\nconst CRPCTable tableRPC;\n", "#include <vector>\n#include <boost/test/unit_test.hpp>\n#include <boost/foreach.hpp>\n\n#include \"main.h\"\n#include \"wallet.h\"\n#include \"util.h\"\n\nusing namespace std;\n\nBOOST_AUTO_TEST_SUITE(util_tests)\n\nBOOST_AUTO_TEST_CASE(util_criticalsection)\n{\n    CCriticalSection cs;\n\n    do {\n        LOCK(cs);\n        break;\n\n        BOOST_ERROR(\"break was swallowed!\");\n    } while(0);\n\n    do {\n        TRY_LOCK(cs, lockTest);\n        if (lockTest)\n            break;\n\n        BOOST_ERROR(\"break was swallowed!\");\n    } while(0);\n}\n\nBOOST_AUTO_TEST_CASE(util_MedianFilter)\n{    \n    CMedianFilter<int> filter(5, 15);\n\n    BOOST_CHECK_EQUAL(filter.median(), 15);\n\n    filter.input(20); // [15 20]\n    BOOST_CHECK_EQUAL(filter.median(), 17);\n\n    filter.input(30); // [15 20 30]\n    BOOST_CHECK_EQUAL(filter.median(), 20);\n\n    filter.input(3); // [3 15 20 30]\n    BOOST_CHECK_EQUAL(filter.median(), 17);\n\n    filter.input(7); // [3 7 15 20 30]\n    BOOST_CHECK_EQUAL(filter.median(), 15);\n\n    filter.input(18); // [3 7 18 20 30]\n    BOOST_CHECK_EQUAL(filter.median(), 18);\n\n    filter.input(0); // [0 3 7 18 30]\n    BOOST_CHECK_EQUAL(filter.median(), 7);\n}\n\nstatic const unsigned char ParseHex_expected[65] = {\n    0x04, 0x67, 0x8a, 0xfd, 0xb0, 0xfe, 0x55, 0x48, 0x27, 0x19, 0x67, 0xf1, 0xa6, 0x71, 0x30, 0xb7, \n    0x10, 0x5c, 0xd6, 0xa8, 0x28, 0xe0, 0x39, 0x09, 0xa6, 0x79, 0x62, 0xe0, 0xea, 0x1f, 0x61, 0xde, \n    0xb6, 0x49, 0xf6, 0xbc, 0x3f, 0x4c, 0xef, 0x38, 0xc4, 0xf3, 0x55, 0x04, 0xe5, 0x1e, 0xc1, 0x12, \n    0xde, 0x5c, 0x38, 0x4d, 0xf7, 0xba, 0x0b, 0x8d, 0x57, 0x8a, 0x4c, 0x70, 0x2b, 0x6b, 0xf1, 0x1d, \n    0x5f\n};\nBOOST_AUTO_TEST_CASE(util_ParseHex)\n{\n    std::vector<unsigned char> result;\n    std::vector<unsigned char> expected(ParseHex_expected, ParseHex_expected + sizeof(ParseHex_expected));\n    // Basic test vector\n    result = ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f\");\n    BOOST_CHECK_EQUAL_COLLECTIONS(result.begin(), result.end(), expected.begin(), expected.end());\n\n    // Spaces between bytes must be supported\n    result = ParseHex(\"12 34 56 78\");\n    BOOST_CHECK(result.size() == 4 && result[0] == 0x12 && result[1] == 0x34 && result[2] == 0x56 && result[3] == 0x78);\n\n    // Stop parsing at invalid value\n    result = ParseHex(\"1234 invalid 1234\");\n    BOOST_CHECK(result.size() == 2 && result[0] == 0x12 && result[1] == 0x34);\n}\n\nBOOST_AUTO_TEST_CASE(util_HexStr)\n{\n    BOOST_CHECK_EQUAL(\n        HexStr(ParseHex_expected, ParseHex_expected + sizeof(ParseHex_expected)),\n        \"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f\");\n\n    BOOST_CHECK_EQUAL(\n        HexStr(ParseHex_expected, ParseHex_expected + 5, true),\n        \"04 67 8a fd b0\");\n\n    BOOST_CHECK_EQUAL(\n        HexStr(ParseHex_expected, ParseHex_expected, true),\n        \"\");\n\n    std::vector<unsigned char> ParseHex_vec(ParseHex_expected, ParseHex_expected + 5);\n\n    BOOST_CHECK_EQUAL(\n        HexStr(ParseHex_vec, true),\n        \"04 67 8a fd b0\");\n}\n\n\nBOOST_AUTO_TEST_CASE(util_DateTimeStrFormat)\n{\n/*These are platform-dependant and thus removed to avoid useless test failures\n    BOOST_CHECK_EQUAL(DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", 0), \"1970-01-01 00:00:00\");\n    BOOST_CHECK_EQUAL(DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", 0x7FFFFFFF), \"2038-01-19 03:14:07\");\n    // Formats used within Bitcoin\n    BOOST_CHECK_EQUAL(DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", 1317425777), \"2011-09-30 23:36:17\");\n    BOOST_CHECK_EQUAL(DateTimeStrFormat(\"%Y-%m-%d %H:%M\", 1317425777), \"2011-09-30 23:36\");\n*/\n}\n\nBOOST_AUTO_TEST_CASE(util_ParseParameters)\n{\n    const char *argv_test[] = {\"-ignored\", \"-a\", \"-b\", \"-ccc=argument\", \"-ccc=multiple\", \"f\", \"-d=e\"};\n\n    ParseParameters(0, (char**)argv_test);\n    BOOST_CHECK(mapArgs.empty() && mapMultiArgs.empty());\n\n    ParseParameters(1, (char**)argv_test);\n    BOOST_CHECK(mapArgs.empty() && mapMultiArgs.empty());\n\n    ParseParameters(5, (char**)argv_test);\n    // expectation: -ignored is ignored (program name argument), \n    // -a, -b and -ccc end up in map, -d ignored because it is after\n    // a non-option argument (non-GNU option parsing)\n    BOOST_CHECK(mapArgs.size() == 3 && mapMultiArgs.size() == 3);\n    BOOST_CHECK(mapArgs.count(\"-a\") && mapArgs.count(\"-b\") && mapArgs.count(\"-ccc\") \n                && !mapArgs.count(\"f\") && !mapArgs.count(\"-d\"));\n    BOOST_CHECK(mapMultiArgs.count(\"-a\") && mapMultiArgs.count(\"-b\") && mapMultiArgs.count(\"-ccc\") \n                && !mapMultiArgs.count(\"f\") && !mapMultiArgs.count(\"-d\"));\n\n    BOOST_CHECK(mapArgs[\"-a\"] == \"\" && mapArgs[\"-ccc\"] == \"multiple\");\n    BOOST_CHECK(mapMultiArgs[\"-ccc\"].size() == 2);\n}\n\nBOOST_AUTO_TEST_CASE(util_GetArg)\n{\n    mapArgs.clear();\n    mapArgs[\"strtest1\"] = \"string...\";\n    // strtest2 undefined on purpose\n    mapArgs[\"inttest1\"] = \"12345\";\n    mapArgs[\"inttest2\"] = \"81985529216486895\";\n    // inttest3 undefined on purpose\n    mapArgs[\"booltest1\"] = \"\";\n    // booltest2 undefined on purpose\n    mapArgs[\"booltest3\"] = \"0\";\n    mapArgs[\"booltest4\"] = \"1\";\n\n    BOOST_CHECK_EQUAL(GetArg(\"strtest1\", \"default\"), \"string...\");\n    BOOST_CHECK_EQUAL(GetArg(\"strtest2\", \"default\"), \"default\");\n    BOOST_CHECK_EQUAL(GetArg(\"inttest1\", -1), 12345);\n    BOOST_CHECK_EQUAL(GetArg(\"inttest2\", -1), 81985529216486895LL);\n    BOOST_CHECK_EQUAL(GetArg(\"inttest3\", -1), -1);\n    BOOST_CHECK_EQUAL(GetBoolArg(\"booltest1\"), true);\n    BOOST_CHECK_EQUAL(GetBoolArg(\"booltest2\"), false);\n    BOOST_CHECK_EQUAL(GetBoolArg(\"booltest3\"), false);\n    BOOST_CHECK_EQUAL(GetBoolArg(\"booltest4\"), true);\n}\n\nBOOST_AUTO_TEST_CASE(util_WildcardMatch)\n{\n    BOOST_CHECK(WildcardMatch(\"127.0.0.1\", \"*\"));\n    BOOST_CHECK(WildcardMatch(\"127.0.0.1\", \"127.*\"));\n    BOOST_CHECK(WildcardMatch(\"abcdef\", \"a?cde?\"));\n    BOOST_CHECK(!WildcardMatch(\"abcdef\", \"a?cde??\"));\n    BOOST_CHECK(WildcardMatch(\"abcdef\", \"a*f\"));\n    BOOST_CHECK(!WildcardMatch(\"abcdef\", \"a*x\"));\n    BOOST_CHECK(WildcardMatch(\"\", \"*\"));\n}\n\nBOOST_AUTO_TEST_CASE(util_FormatMoney)\n{\n    BOOST_CHECK_EQUAL(FormatMoney(0, false), \"0.00\");\n    BOOST_CHECK_EQUAL(FormatMoney((COIN/10000)*123456789, false), \"12345.6789\");\n    BOOST_CHECK_EQUAL(FormatMoney(COIN, true), \"+1.00\");\n    BOOST_CHECK_EQUAL(FormatMoney(-COIN, false), \"-1.00\");\n    BOOST_CHECK_EQUAL(FormatMoney(-COIN, true), \"-1.00\");\n\n    BOOST_CHECK_EQUAL(FormatMoney(COIN*100000000, false), \"100000000.00\");\n    BOOST_CHECK_EQUAL(FormatMoney(COIN*10000000, false), \"10000000.00\");\n    BOOST_CHECK_EQUAL(FormatMoney(COIN*1000000, false), \"1000000.00\");\n    BOOST_CHECK_EQUAL(FormatMoney(COIN*100000, false), \"100000.00\");\n    BOOST_CHECK_EQUAL(FormatMoney(COIN*10000, false), \"10000.00\");\n    BOOST_CHECK_EQUAL(FormatMoney(COIN*1000, false), \"1000.00\");\n    BOOST_CHECK_EQUAL(FormatMoney(COIN*100, false), \"100.00\");\n    BOOST_CHECK_EQUAL(FormatMoney(COIN*10, false), \"10.00\");\n    BOOST_CHECK_EQUAL(FormatMoney(COIN, false), \"1.00\");\n    BOOST_CHECK_EQUAL(FormatMoney(COIN/10, false), \"0.10\");\n    BOOST_CHECK_EQUAL(FormatMoney(COIN/100, false), \"0.01\");\n    BOOST_CHECK_EQUAL(FormatMoney(COIN/1000, false), \"0.001\");\n    BOOST_CHECK_EQUAL(FormatMoney(COIN/10000, false), \"0.0001\");\n    BOOST_CHECK_EQUAL(FormatMoney(COIN/100000, false), \"0.00001\");\n    BOOST_CHECK_EQUAL(FormatMoney(COIN/1000000, false), \"0.000001\");\n    BOOST_CHECK_EQUAL(FormatMoney(COIN/10000000, false), \"0.0000001\");\n    BOOST_CHECK_EQUAL(FormatMoney(COIN/100000000, false), \"0.00000001\");\n}\n\nBOOST_AUTO_TEST_CASE(util_ParseMoney)\n{\n    int64 ret = 0;\n    BOOST_CHECK(ParseMoney(\"0.0\", ret));\n    BOOST_CHECK_EQUAL(ret, 0);\n\n    BOOST_CHECK(ParseMoney(\"12345.6789\", ret));\n    BOOST_CHECK_EQUAL(ret, (COIN/10000)*123456789);\n\n    BOOST_CHECK(ParseMoney(\"100000000.00\", ret));\n    BOOST_CHECK_EQUAL(ret, COIN*100000000);\n    BOOST_CHECK(ParseMoney(\"10000000.00\", ret));\n    BOOST_CHECK_EQUAL(ret, COIN*10000000);\n    BOOST_CHECK(ParseMoney(\"1000000.00\", ret));\n    BOOST_CHECK_EQUAL(ret, COIN*1000000);\n    BOOST_CHECK(ParseMoney(\"100000.00\", ret));\n    BOOST_CHECK_EQUAL(ret, COIN*100000);\n    BOOST_CHECK(ParseMoney(\"10000.00\", ret));\n    BOOST_CHECK_EQUAL(ret, COIN*10000);\n    BOOST_CHECK(ParseMoney(\"1000.00\", ret));\n    BOOST_CHECK_EQUAL(ret, COIN*1000);\n    BOOST_CHECK(ParseMoney(\"100.00\", ret));\n    BOOST_CHECK_EQUAL(ret, COIN*100);\n    BOOST_CHECK(ParseMoney(\"10.00\", ret));\n    BOOST_CHECK_EQUAL(ret, COIN*10);\n    BOOST_CHECK(ParseMoney(\"1.00\", ret));\n    BOOST_CHECK_EQUAL(ret, COIN);\n    BOOST_CHECK(ParseMoney(\"0.1\", ret));\n    BOOST_CHECK_EQUAL(ret, COIN/10);\n    BOOST_CHECK(ParseMoney(\"0.01\", ret));\n    BOOST_CHECK_EQUAL(ret, COIN/100);\n    BOOST_CHECK(ParseMoney(\"0.001\", ret));\n    BOOST_CHECK_EQUAL(ret, COIN/1000);\n    BOOST_CHECK(ParseMoney(\"0.0001\", ret));\n    BOOST_CHECK_EQUAL(ret, COIN/10000);\n    BOOST_CHECK(ParseMoney(\"0.00001\", ret));\n    BOOST_CHECK_EQUAL(ret, COIN/100000);\n    BOOST_CHECK(ParseMoney(\"0.000001\", ret));\n    BOOST_CHECK_EQUAL(ret, COIN/1000000);\n    BOOST_CHECK(ParseMoney(\"0.0000001\", ret));\n    BOOST_CHECK_EQUAL(ret, COIN/10000000);\n    BOOST_CHECK(ParseMoney(\"0.00000001\", ret));\n    BOOST_CHECK_EQUAL(ret, COIN/100000000);\n\n    // Attempted 63 bit overflow should fail\n    BOOST_CHECK(!ParseMoney(\"92233720368.54775808\", ret));\n}\n\nBOOST_AUTO_TEST_CASE(util_IsHex)\n{\n    BOOST_CHECK(IsHex(\"00\"));\n    BOOST_CHECK(IsHex(\"00112233445566778899aabbccddeeffAABBCCDDEEFF\"));\n    BOOST_CHECK(IsHex(\"ff\"));\n    BOOST_CHECK(IsHex(\"FF\"));\n\n    BOOST_CHECK(!IsHex(\"\"));\n    BOOST_CHECK(!IsHex(\"0\"));\n    BOOST_CHECK(!IsHex(\"a\"));\n    BOOST_CHECK(!IsHex(\"eleven\"));\n    BOOST_CHECK(!IsHex(\"00xx00\"));\n    BOOST_CHECK(!IsHex(\"0x0000\"));\n}\n\nBOOST_AUTO_TEST_CASE(util_seed_insecure_rand)\n{\n    // Expected results for the determinstic seed.\n    const uint32_t exp_vals[11] = {  91632771U,1889679809U,3842137544U,3256031132U,\n                                   1761911779U, 489223532U,2692793790U,2737472863U,\n                                   2796262275U,1309899767U,840571781U};\n    // Expected 0s in rand()%(idx+2) for the determinstic seed.\n    const int exp_count[9] = {5013,3346,2415,1972,1644,1386,1176,1096,1009};\n    int i;\n    int count=0;\n\n    seed_insecure_rand();\n\n    //Does the non-determistic rand give us results that look too like the determinstic one?\n    for (i=0;i<10;i++)\n    {\n        int match = 0;\n        uint32_t rval = insecure_rand();\n        for (int j=0;j<11;j++)match |= rval==exp_vals[j];\n        count += match;\n    }\n    // sum(binomial(10,i)*(11/(2^32))^i*(1-(11/(2^32)))^(10-i),i,0,4) ~= 1-1/2^134.73\n    // So _very_ unlikely to throw a false failure here.\n    BOOST_CHECK(count<=4);\n\n    for (int mod=2;mod<11;mod++)\n    {\n        int mask = 1;\n        // Really rough binomal confidence approximation.\n        int err = 30*10000./mod*sqrt((1./mod*(1-1./mod))/10000.);\n        //mask is 2^ceil(log2(mod))-1\n        while(mask<mod-1)mask=(mask<<1)+1;\n\n        count = 0;\n        //How often does it get a zero from the uniform range [0,mod)?\n        for (i=0;i<10000;i++)\n        {\n            uint32_t rval;\n            do{\n                rval=insecure_rand()&mask;\n            }while(rval>=(uint32_t)mod);\n            count += rval==0;\n        }\n        BOOST_CHECK(count<=10000/mod+err);\n        BOOST_CHECK(count>=10000/mod-err);\n    }\n\n    seed_insecure_rand(true);\n\n    for (i=0;i<11;i++)\n    {\n        BOOST_CHECK_EQUAL(insecure_rand(),exp_vals[i]);\n    }\n\n    for (int mod=2;mod<11;mod++)\n    {\n        count = 0;\n        for (i=0;i<10000;i++) count += insecure_rand()%mod==0;\n        BOOST_CHECK_EQUAL(count,exp_count[mod-2]);\n    }\n}\n\nBOOST_AUTO_TEST_SUITE_END()\n", "// Copyright (c) 2009-2010 Satoshi Nakamoto\n// Copyright (c) 2009-2012 The Bitcoin developers\n// Distributed under the MIT/X11 software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n#ifndef BITCOIN_UTIL_H\n#define BITCOIN_UTIL_H\n\n#include \"uint256.h\"\n\n#include <stdarg.h>\n\n#ifndef WIN32\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#else\ntypedef int pid_t; /* define for Windows compatibility */\n#endif\n#include <map>\n#include <list>\n#include <utility>\n#include <vector>\n#include <string>\n\n#include <boost/thread.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n\n#include \"netbase.h\" // for AddTimeData\n\ntypedef long long  int64;\ntypedef unsigned long long  uint64;\n\nstatic const int64 COIN = 100000000;\nstatic const int64 CENT = 1000000;\n\n#define loop                for (;;)\n#define BEGIN(a)            ((char*)&(a))\n#define END(a)              ((char*)&((&(a))[1]))\n#define UBEGIN(a)           ((unsigned char*)&(a))\n#define UEND(a)             ((unsigned char*)&((&(a))[1]))\n#define ARRAYLEN(array)     (sizeof(array)/sizeof((array)[0]))\n\n#ifndef PRI64d\n#if defined(_MSC_VER) || defined(__MSVCRT__)\n#define PRI64d  \"I64d\"\n#define PRI64u  \"I64u\"\n#define PRI64x  \"I64x\"\n#else\n#define PRI64d  \"lld\"\n#define PRI64u  \"llu\"\n#define PRI64x  \"llx\"\n#endif\n#endif\n\n/* Format characters for (s)size_t and ptrdiff_t */\n#if defined(_MSC_VER) || defined(__MSVCRT__)\n  /* (s)size_t and ptrdiff_t have the same size specifier in MSVC:\n     http://msdn.microsoft.com/en-us/library/tcxf1dw6%28v=vs.100%29.aspx\n   */\n  #define PRIszx    \"Ix\"\n  #define PRIszu    \"Iu\"\n  #define PRIszd    \"Id\"\n  #define PRIpdx    \"Ix\"\n  #define PRIpdu    \"Iu\"\n  #define PRIpdd    \"Id\"\n#else /* C99 standard */\n  #define PRIszx    \"zx\"\n  #define PRIszu    \"zu\"\n  #define PRIszd    \"zd\"\n  #define PRIpdx    \"tx\"\n  #define PRIpdu    \"tu\"\n  #define PRIpdd    \"td\"\n#endif\n\n// This is needed because the foreach macro can't get over the comma in pair<t1, t2>\n#define PAIRTYPE(t1, t2)    std::pair<t1, t2>\n\n// Align by increasing pointer, must have extra space at end of buffer\ntemplate <size_t nBytes, typename T>\nT* alignup(T* p)\n{\n    union\n    {\n        T* ptr;\n        size_t n;\n    } u;\n    u.ptr = p;\n    u.n = (u.n + (nBytes-1)) & ~(nBytes-1);\n    return u.ptr;\n}\n\n#ifdef WIN32\n#define MSG_NOSIGNAL        0\n#define MSG_DONTWAIT        0\n\n#ifndef S_IRUSR\n#define S_IRUSR             0400\n#define S_IWUSR             0200\n#endif\n#else\n#define MAX_PATH            1024\n#endif\n\ninline void MilliSleep(int64 n)\n{\n#if BOOST_VERSION >= 105000\n    boost::this_thread::sleep_for(boost::chrono::milliseconds(n));\n#else\n    boost::this_thread::sleep(boost::posix_time::milliseconds(n));\n#endif\n}\n\n/* This GNU C extension enables the compiler to check the format string against the parameters provided.\n * X is the number of the \"format string\" parameter, and Y is the number of the first variadic parameter.\n * Parameters count from 1.\n */\n#ifdef __GNUC__\n#define ATTR_WARN_PRINTF(X,Y) __attribute__((format(printf,X,Y)))\n#else\n#define ATTR_WARN_PRINTF(X,Y)\n#endif\n\n\n\n\n\n\n\n\nextern std::map<std::string, std::string> mapArgs;\nextern std::map<std::string, std::vector<std::string> > mapMultiArgs;\nextern bool fDebug;\nextern bool fDebugNet;\nextern bool fPrintToConsole;\nextern bool fPrintToDebugger;\nextern bool fDaemon;\nextern bool fServer;\nextern bool fCommandLine;\nextern std::string strMiscWarning;\nextern bool fTestNet;\nextern bool fNoListen;\nextern bool fLogTimestamps;\nextern volatile bool fReopenDebugLog;\n\nvoid RandAddSeed();\nvoid RandAddSeedPerfmon();\nint ATTR_WARN_PRINTF(1,2) OutputDebugStringF(const char* pszFormat, ...);\n\n/*\n  Rationale for the real_strprintf / strprintf construction:\n    It is not allowed to use va_start with a pass-by-reference argument.\n    (C++ standard, 18.7, paragraph 3). Use a dummy argument to work around this, and use a\n    macro to keep similar semantics.\n*/\n\n/** Overload strprintf for char*, so that GCC format type warnings can be given */\nstd::string ATTR_WARN_PRINTF(1,3) real_strprintf(const char *format, int dummy, ...);\n/** Overload strprintf for std::string, to be able to use it with _ (translation).\n * This will not support GCC format type warnings (-Wformat) so be careful.\n */\nstd::string real_strprintf(const std::string &format, int dummy, ...);\n#define strprintf(format, ...) real_strprintf(format, 0, __VA_ARGS__)\nstd::string vstrprintf(const char *format, va_list ap);\n\nbool ATTR_WARN_PRINTF(1,2) error(const char *format, ...);\n\n/* Redefine printf so that it directs output to debug.log\n *\n * Do this *after* defining the other printf-like functions, because otherwise the\n * __attribute__((format(printf,X,Y))) gets expanded to __attribute__((format(OutputDebugStringF,X,Y)))\n * which confuses gcc.\n */\n#define printf OutputDebugStringF\n\nvoid LogException(std::exception* pex, const char* pszThread);\nvoid PrintException(std::exception* pex, const char* pszThread);\nvoid PrintExceptionContinue(std::exception* pex, const char* pszThread);\nvoid ParseString(const std::string& str, char c, std::vector<std::string>& v);\nstd::string FormatMoney(int64 n, bool fPlus=false);\nbool ParseMoney(const std::string& str, int64& nRet);\nbool ParseMoney(const char* pszIn, int64& nRet);\nstd::vector<unsigned char> ParseHex(const char* psz);\nstd::vector<unsigned char> ParseHex(const std::string& str);\nbool IsHex(const std::string& str);\nstd::vector<unsigned char> DecodeBase64(const char* p, bool* pfInvalid = NULL);\nstd::string DecodeBase64(const std::string& str);\nstd::string EncodeBase64(const unsigned char* pch, size_t len);\nstd::string EncodeBase64(const std::string& str);\nstd::vector<unsigned char> DecodeBase32(const char* p, bool* pfInvalid = NULL);\nstd::string DecodeBase32(const std::string& str);\nstd::string EncodeBase32(const unsigned char* pch, size_t len);\nstd::string EncodeBase32(const std::string& str);\nvoid ParseParameters(int argc, const char*const argv[]);\nbool WildcardMatch(const char* psz, const char* mask);\nbool WildcardMatch(const std::string& str, const std::string& mask);\nvoid FileCommit(FILE *fileout);\nint GetFilesize(FILE* file);\nbool TruncateFile(FILE *file, unsigned int length);\nint RaiseFileDescriptorLimit(int nMinFD);\nvoid AllocateFileRange(FILE *file, unsigned int offset, unsigned int length);\nbool RenameOver(boost::filesystem::path src, boost::filesystem::path dest);\nboost::filesystem::path GetDefaultDataDir();\nconst boost::filesystem::path &GetDataDir(bool fNetSpecific = true);\nboost::filesystem::path GetConfigFile();\nboost::filesystem::path GetPidFile();\nvoid CreatePidFile(const boost::filesystem::path &path, pid_t pid);\nvoid ReadConfigFile(std::map<std::string, std::string>& mapSettingsRet, std::map<std::string, std::vector<std::string> >& mapMultiSettingsRet);\n#ifdef WIN32\nboost::filesystem::path GetSpecialFolderPath(int nFolder, bool fCreate = true);\n#endif\nboost::filesystem::path GetTempPath();\nvoid ShrinkDebugFile();\nint GetRandInt(int nMax);\nuint64 GetRand(uint64 nMax);\nuint256 GetRandHash();\nint64 GetTime();\nvoid SetMockTime(int64 nMockTimeIn);\nint64 GetAdjustedTime();\nint64 GetTimeOffset();\nstd::string FormatFullVersion();\nstd::string FormatSubVersion(const std::string& name, int nClientVersion, const std::vector<std::string>& comments);\nvoid AddTimeData(const CNetAddr& ip, int64 nTime);\nvoid runCommand(std::string strCommand);\n\n\n\n\n\n\n\n\n\ninline std::string i64tostr(int64 n)\n{\n    return strprintf(\"%\"PRI64d, n);\n}\n\ninline std::string itostr(int n)\n{\n    return strprintf(\"%d\", n);\n}\n\ninline int64 atoi64(const char* psz)\n{\n#ifdef _MSC_VER\n    return _atoi64(psz);\n#else\n    return strtoll(psz, NULL, 10);\n#endif\n}\n\ninline int64 atoi64(const std::string& str)\n{\n#ifdef _MSC_VER\n    return _atoi64(str.c_str());\n#else\n    return strtoll(str.c_str(), NULL, 10);\n#endif\n}\n\ninline int atoi(const std::string& str)\n{\n    return atoi(str.c_str());\n}\n\ninline int roundint(double d)\n{\n    return (int)(d > 0 ? d + 0.5 : d - 0.5);\n}\n\ninline int64 roundint64(double d)\n{\n    return (int64)(d > 0 ? d + 0.5 : d - 0.5);\n}\n\ninline int64 abs64(int64 n)\n{\n    return (n >= 0 ? n : -n);\n}\n\ntemplate<typename T>\nstd::string HexStr(const T itbegin, const T itend, bool fSpaces=false)\n{\n    std::string rv;\n    static const char hexmap[16] = { '0', '1', '2', '3', '4', '5', '6', '7',\n                                     '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n    rv.reserve((itend-itbegin)*3);\n    for(T it = itbegin; it < itend; ++it)\n    {\n        unsigned char val = (unsigned char)(*it);\n        if(fSpaces && it != itbegin)\n            rv.push_back(' ');\n        rv.push_back(hexmap[val>>4]);\n        rv.push_back(hexmap[val&15]);\n    }\n\n    return rv;\n}\n\ninline std::string HexStr(const std::vector<unsigned char>& vch, bool fSpaces=false)\n{\n    return HexStr(vch.begin(), vch.end(), fSpaces);\n}\n\ntemplate<typename T>\nvoid PrintHex(const T pbegin, const T pend, const char* pszFormat=\"%s\", bool fSpaces=true)\n{\n    printf(pszFormat, HexStr(pbegin, pend, fSpaces).c_str());\n}\n\ninline void PrintHex(const std::vector<unsigned char>& vch, const char* pszFormat=\"%s\", bool fSpaces=true)\n{\n    printf(pszFormat, HexStr(vch, fSpaces).c_str());\n}\n\ninline int64 GetPerformanceCounter()\n{\n    int64 nCounter = 0;\n#ifdef WIN32\n    QueryPerformanceCounter((LARGE_INTEGER*)&nCounter);\n#else\n    timeval t;\n    gettimeofday(&t, NULL);\n    nCounter = (int64) t.tv_sec * 1000000 + t.tv_usec;\n#endif\n    return nCounter;\n}\n\ninline int64 GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}\n\ninline int64 GetTimeMicros()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_microseconds();\n}\n\ninline std::string DateTimeStrFormat(const char* pszFormat, int64 nTime)\n{\n    time_t n = nTime;\n    struct tm* ptmTime = gmtime(&n);\n    char pszTime[200];\n    strftime(pszTime, sizeof(pszTime), pszFormat, ptmTime);\n    return pszTime;\n}\n\ntemplate<typename T>\nvoid skipspaces(T& it)\n{\n    while (isspace(*it))\n        ++it;\n}\n\ninline bool IsSwitchChar(char c)\n{\n#ifdef WIN32\n    return c == '-' || c == '/';\n#else\n    return c == '-';\n#endif\n}\n\n/**\n * Return string argument or default value\n *\n * @param strArg Argument to get (e.g. \"-foo\")\n * @param default (e.g. \"1\")\n * @return command-line argument or default value\n */\nstd::string GetArg(const std::string& strArg, const std::string& strDefault);\n\n/**\n * Return integer argument or default value\n *\n * @param strArg Argument to get (e.g. \"-foo\")\n * @param default (e.g. 1)\n * @return command-line argument (0 if invalid number) or default value\n */\nint64 GetArg(const std::string& strArg, int64 nDefault);\n\n/**\n * Return boolean argument or default value\n *\n * @param strArg Argument to get (e.g. \"-foo\")\n * @param default (true or false)\n * @return command-line argument or default value\n */\nbool GetBoolArg(const std::string& strArg, bool fDefault=false);\n\n/**\n * Set an argument if it doesn't already have a value\n *\n * @param strArg Argument to set (e.g. \"-foo\")\n * @param strValue Value (e.g. \"1\")\n * @return true if argument gets set, false if it already had a value\n */\nbool SoftSetArg(const std::string& strArg, const std::string& strValue);\n\n/**\n * Set a boolean argument if it doesn't already have a value\n *\n * @param strArg Argument to set (e.g. \"-foo\")\n * @param fValue Value (e.g. false)\n * @return true if argument gets set, false if it already had a value\n */\nbool SoftSetBoolArg(const std::string& strArg, bool fValue);\n\n/**\n * MWC RNG of George Marsaglia\n * This is intended to be fast. It has a period of 2^59.3, though the\n * least significant 16 bits only have a period of about 2^30.1.\n *\n * @return random value\n */\nextern uint32_t insecure_rand_Rz;\nextern uint32_t insecure_rand_Rw;\nstatic inline uint32_t insecure_rand(void)\n{\n    insecure_rand_Rz = 36969 * (insecure_rand_Rz & 65535) + (insecure_rand_Rz >> 16);\n    insecure_rand_Rw = 18000 * (insecure_rand_Rw & 65535) + (insecure_rand_Rw >> 16);\n    return (insecure_rand_Rw << 16) + insecure_rand_Rz;\n}\n\n/**\n * Seed insecure_rand using the random pool.\n * @param Deterministic Use a determinstic seed\n */\nvoid seed_insecure_rand(bool fDeterministic=false);\n\n/** Median filter over a stream of values.\n * Returns the median of the last N numbers\n */\ntemplate <typename T> class CMedianFilter\n{\nprivate:\n    std::vector<T> vValues;\n    std::vector<T> vSorted;\n    unsigned int nSize;\npublic:\n    CMedianFilter(unsigned int size, T initial_value):\n        nSize(size)\n    {\n        vValues.reserve(size);\n        vValues.push_back(initial_value);\n        vSorted = vValues;\n    }\n\n    void input(T value)\n    {\n        if(vValues.size() == nSize)\n        {\n            vValues.erase(vValues.begin());\n        }\n        vValues.push_back(value);\n\n        vSorted.resize(vValues.size());\n        std::copy(vValues.begin(), vValues.end(), vSorted.begin());\n        std::sort(vSorted.begin(), vSorted.end());\n    }\n\n    T median() const\n    {\n        int size = vSorted.size();\n        assert(size>0);\n        if(size & 1) // Odd number of elements\n        {\n            return vSorted[size/2];\n        }\n        else // Even number of elements\n        {\n            return (vSorted[size/2-1] + vSorted[size/2]) / 2;\n        }\n    }\n\n    int size() const\n    {\n        return vValues.size();\n    }\n\n    std::vector<T> sorted () const\n    {\n        return vSorted;\n    }\n};\n\nbool NewThread(void(*pfn)(void*), void* parg);\n\n#ifdef WIN32\ninline void SetThreadPriority(int nPriority)\n{\n    SetThreadPriority(GetCurrentThread(), nPriority);\n}\n#else\n\n#define THREAD_PRIORITY_LOWEST          PRIO_MAX\n#define THREAD_PRIORITY_BELOW_NORMAL    2\n#define THREAD_PRIORITY_NORMAL          0\n#define THREAD_PRIORITY_ABOVE_NORMAL    0\n\ninline void SetThreadPriority(int nPriority)\n{\n    // It's unclear if it's even possible to change thread priorities on Linux,\n    // but we really and truly need it for the generation threads.\n#ifdef PRIO_THREAD\n    setpriority(PRIO_THREAD, 0, nPriority);\n#else\n    setpriority(PRIO_PROCESS, 0, nPriority);\n#endif\n}\n\ninline void ExitThread(size_t nExitCode)\n{\n    pthread_exit((void*)nExitCode);\n}\n#endif\n\nvoid RenameThread(const char* name);\n\ninline uint32_t ByteReverse(uint32_t value)\n{\n    value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);\n    return (value<<16) | (value>>16);\n}\n\n// Standard wrapper for do-something-forever thread functions.\n// \"Forever\" really means until the thread is interrupted.\n// Use it like:\n//   new boost::thread(boost::bind(&LoopForever<void (*)()>, \"dumpaddr\", &DumpAddresses, 900000));\n// or maybe:\n//    boost::function<void()> f = boost::bind(&FunctionWithArg, argument);\n//    threadGroup.create_thread(boost::bind(&LoopForever<boost::function<void()> >, \"nothing\", f, milliseconds));\ntemplate <typename Callable> void LoopForever(const char* name,  Callable func, int64 msecs)\n{\n    std::string s = strprintf(\"bitcoin-%s\", name);\n    RenameThread(s.c_str());\n    printf(\"%s thread start\\n\", name);\n    try\n    {\n        while (1)\n        {\n            MilliSleep(msecs);\n            func();\n        }\n    }\n    catch (boost::thread_interrupted)\n    {\n        printf(\"%s thread stop\\n\", name);\n        throw;\n    }\n    catch (std::exception& e) {\n        PrintException(&e, name);\n    }\n    catch (...) {\n        PrintException(NULL, name);\n    }\n}\n// .. and a wrapper that just calls func once\ntemplate <typename Callable> void TraceThread(const char* name,  Callable func)\n{\n    std::string s = strprintf(\"bitcoin-%s\", name);\n    RenameThread(s.c_str());\n    try\n    {\n        printf(\"%s thread start\\n\", name);\n        func();\n        printf(\"%s thread exit\\n\", name);\n    }\n    catch (boost::thread_interrupted)\n    {\n        printf(\"%s thread interrupt\\n\", name);\n        throw;\n    }\n    catch (std::exception& e) {\n        PrintException(&e, name);\n    }\n    catch (...) {\n        PrintException(NULL, name);\n    }\n}\n\n#endif\n"], "fixing_code": ["// Copyright (c) 2010 Satoshi Nakamoto\n// Copyright (c) 2009-2012 The Bitcoin developers\n// Distributed under the MIT/X11 software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n\n#include \"init.h\"\n#include \"util.h\"\n#include \"sync.h\"\n#include \"ui_interface.h\"\n#include \"base58.h\"\n#include \"bitcoinrpc.h\"\n#include \"db.h\"\n\n#include <boost/asio.hpp>\n#include <boost/asio/ip/v6_only.hpp>\n#include <boost/bind.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/foreach.hpp>\n#include <boost/iostreams/concepts.hpp>\n#include <boost/iostreams/stream.hpp>\n#include <boost/algorithm/string.hpp>\n#include <boost/lexical_cast.hpp>\n#include <boost/asio/ssl.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/shared_ptr.hpp>\n#include <list>\n\nusing namespace std;\nusing namespace boost;\nusing namespace boost::asio;\nusing namespace json_spirit;\n\n// Key used by getwork/getblocktemplate miners.\n// Allocated in StartRPCThreads, free'd in StopRPCThreads\nCReserveKey* pMiningKey = NULL;\n\nstatic std::string strRPCUserColonPass;\n\n// These are created by StartRPCThreads, destroyed in StopRPCThreads\nstatic asio::io_service* rpc_io_service = NULL;\nstatic ssl::context* rpc_ssl_context = NULL;\nstatic boost::thread_group* rpc_worker_group = NULL;\n\nstatic inline unsigned short GetDefaultRPCPort()\n{\n    return GetBoolArg(\"-testnet\", false) ? 18332 : 8332;\n}\n\nObject JSONRPCError(int code, const string& message)\n{\n    Object error;\n    error.push_back(Pair(\"code\", code));\n    error.push_back(Pair(\"message\", message));\n    return error;\n}\n\nvoid RPCTypeCheck(const Array& params,\n                  const list<Value_type>& typesExpected,\n                  bool fAllowNull)\n{\n    unsigned int i = 0;\n    BOOST_FOREACH(Value_type t, typesExpected)\n    {\n        if (params.size() <= i)\n            break;\n\n        const Value& v = params[i];\n        if (!((v.type() == t) || (fAllowNull && (v.type() == null_type))))\n        {\n            string err = strprintf(\"Expected type %s, got %s\",\n                                   Value_type_name[t], Value_type_name[v.type()]);\n            throw JSONRPCError(RPC_TYPE_ERROR, err);\n        }\n        i++;\n    }\n}\n\nvoid RPCTypeCheck(const Object& o,\n                  const map<string, Value_type>& typesExpected,\n                  bool fAllowNull)\n{\n    BOOST_FOREACH(const PAIRTYPE(string, Value_type)& t, typesExpected)\n    {\n        const Value& v = find_value(o, t.first);\n        if (!fAllowNull && v.type() == null_type)\n            throw JSONRPCError(RPC_TYPE_ERROR, strprintf(\"Missing %s\", t.first.c_str()));\n\n        if (!((v.type() == t.second) || (fAllowNull && (v.type() == null_type))))\n        {\n            string err = strprintf(\"Expected type %s for %s, got %s\",\n                                   Value_type_name[t.second], t.first.c_str(), Value_type_name[v.type()]);\n            throw JSONRPCError(RPC_TYPE_ERROR, err);\n        }\n    }\n}\n\nint64 AmountFromValue(const Value& value)\n{\n    double dAmount = value.get_real();\n    if (dAmount <= 0.0 || dAmount > 21000000.0)\n        throw JSONRPCError(RPC_TYPE_ERROR, \"Invalid amount\");\n    int64 nAmount = roundint64(dAmount * COIN);\n    if (!MoneyRange(nAmount))\n        throw JSONRPCError(RPC_TYPE_ERROR, \"Invalid amount\");\n    return nAmount;\n}\n\nValue ValueFromAmount(int64 amount)\n{\n    return (double)amount / (double)COIN;\n}\n\nstd::string HexBits(unsigned int nBits)\n{\n    union {\n        int32_t nBits;\n        char cBits[4];\n    } uBits;\n    uBits.nBits = htonl((int32_t)nBits);\n    return HexStr(BEGIN(uBits.cBits), END(uBits.cBits));\n}\n\n\n\n///\n/// Note: This interface may still be subject to change.\n///\n\nstring CRPCTable::help(string strCommand) const\n{\n    string strRet;\n    set<rpcfn_type> setDone;\n    for (map<string, const CRPCCommand*>::const_iterator mi = mapCommands.begin(); mi != mapCommands.end(); ++mi)\n    {\n        const CRPCCommand *pcmd = mi->second;\n        string strMethod = mi->first;\n        // We already filter duplicates, but these deprecated screw up the sort order\n        if (strMethod.find(\"label\") != string::npos)\n            continue;\n        if (strCommand != \"\" && strMethod != strCommand)\n            continue;\n        try\n        {\n            Array params;\n            rpcfn_type pfn = pcmd->actor;\n            if (setDone.insert(pfn).second)\n                (*pfn)(params, true);\n        }\n        catch (std::exception& e)\n        {\n            // Help text is returned in an exception\n            string strHelp = string(e.what());\n            if (strCommand == \"\")\n                if (strHelp.find('\\n') != string::npos)\n                    strHelp = strHelp.substr(0, strHelp.find('\\n'));\n            strRet += strHelp + \"\\n\";\n        }\n    }\n    if (strRet == \"\")\n        strRet = strprintf(\"help: unknown command: %s\\n\", strCommand.c_str());\n    strRet = strRet.substr(0,strRet.size()-1);\n    return strRet;\n}\n\nValue help(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() > 1)\n        throw runtime_error(\n            \"help [command]\\n\"\n            \"List commands, or get help for a command.\");\n\n    string strCommand;\n    if (params.size() > 0)\n        strCommand = params[0].get_str();\n\n    return tableRPC.help(strCommand);\n}\n\n\nValue stop(const Array& params, bool fHelp)\n{\n    // Accept the deprecated and ignored 'detach' boolean argument\n    if (fHelp || params.size() > 1)\n        throw runtime_error(\n            \"stop\\n\"\n            \"Stop Bitcoin server.\");\n    // Shutdown will take long enough that the response should get back\n    StartShutdown();\n    return \"Bitcoin server stopping\";\n}\n\n\n\n//\n// Call Table\n//\n\n\nstatic const CRPCCommand vRPCCommands[] =\n{ //  name                      actor (function)         okSafeMode threadSafe\n  //  ------------------------  -----------------------  ---------- ----------\n    { \"help\",                   &help,                   true,      true },\n    { \"stop\",                   &stop,                   true,      true },\n    { \"getblockcount\",          &getblockcount,          true,      false },\n    { \"getconnectioncount\",     &getconnectioncount,     true,      false },\n    { \"getpeerinfo\",            &getpeerinfo,            true,      false },\n    { \"addnode\",                &addnode,                true,      true },\n    { \"getaddednodeinfo\",       &getaddednodeinfo,       true,      true },\n    { \"getdifficulty\",          &getdifficulty,          true,      false },\n    { \"getgenerate\",            &getgenerate,            true,      false },\n    { \"setgenerate\",            &setgenerate,            true,      false },\n    { \"gethashespersec\",        &gethashespersec,        true,      false },\n    { \"getinfo\",                &getinfo,                true,      false },\n    { \"getmininginfo\",          &getmininginfo,          true,      false },\n    { \"getnewaddress\",          &getnewaddress,          true,      false },\n    { \"getaccountaddress\",      &getaccountaddress,      true,      false },\n    { \"setaccount\",             &setaccount,             true,      false },\n    { \"getaccount\",             &getaccount,             false,     false },\n    { \"getaddressesbyaccount\",  &getaddressesbyaccount,  true,      false },\n    { \"sendtoaddress\",          &sendtoaddress,          false,     false },\n    { \"getreceivedbyaddress\",   &getreceivedbyaddress,   false,     false },\n    { \"getreceivedbyaccount\",   &getreceivedbyaccount,   false,     false },\n    { \"listreceivedbyaddress\",  &listreceivedbyaddress,  false,     false },\n    { \"listreceivedbyaccount\",  &listreceivedbyaccount,  false,     false },\n    { \"backupwallet\",           &backupwallet,           true,      false },\n    { \"keypoolrefill\",          &keypoolrefill,          true,      false },\n    { \"walletpassphrase\",       &walletpassphrase,       true,      false },\n    { \"walletpassphrasechange\", &walletpassphrasechange, false,     false },\n    { \"walletlock\",             &walletlock,             true,      false },\n    { \"encryptwallet\",          &encryptwallet,          false,     false },\n    { \"validateaddress\",        &validateaddress,        true,      false },\n    { \"getbalance\",             &getbalance,             false,     false },\n    { \"move\",                   &movecmd,                false,     false },\n    { \"sendfrom\",               &sendfrom,               false,     false },\n    { \"sendmany\",               &sendmany,               false,     false },\n    { \"addmultisigaddress\",     &addmultisigaddress,     false,     false },\n    { \"createmultisig\",         &createmultisig,         true,      true  },\n    { \"getrawmempool\",          &getrawmempool,          true,      false },\n    { \"getblock\",               &getblock,               false,     false },\n    { \"getblockhash\",           &getblockhash,           false,     false },\n    { \"gettransaction\",         &gettransaction,         false,     false },\n    { \"listtransactions\",       &listtransactions,       false,     false },\n    { \"listaddressgroupings\",   &listaddressgroupings,   false,     false },\n    { \"signmessage\",            &signmessage,            false,     false },\n    { \"verifymessage\",          &verifymessage,          false,     false },\n    { \"getwork\",                &getwork,                true,      false },\n    { \"listaccounts\",           &listaccounts,           false,     false },\n    { \"settxfee\",               &settxfee,               false,     false },\n    { \"getblocktemplate\",       &getblocktemplate,       true,      false },\n    { \"submitblock\",            &submitblock,            false,     false },\n    { \"listsinceblock\",         &listsinceblock,         false,     false },\n    { \"dumpprivkey\",            &dumpprivkey,            true,      false },\n    { \"importprivkey\",          &importprivkey,          false,     false },\n    { \"listunspent\",            &listunspent,            false,     false },\n    { \"getrawtransaction\",      &getrawtransaction,      false,     false },\n    { \"createrawtransaction\",   &createrawtransaction,   false,     false },\n    { \"decoderawtransaction\",   &decoderawtransaction,   false,     false },\n    { \"signrawtransaction\",     &signrawtransaction,     false,     false },\n    { \"sendrawtransaction\",     &sendrawtransaction,     false,     false },\n    { \"gettxoutsetinfo\",        &gettxoutsetinfo,        true,      false },\n    { \"gettxout\",               &gettxout,               true,      false },\n    { \"lockunspent\",            &lockunspent,            false,     false },\n    { \"listlockunspent\",        &listlockunspent,        false,     false },\n};\n\nCRPCTable::CRPCTable()\n{\n    unsigned int vcidx;\n    for (vcidx = 0; vcidx < (sizeof(vRPCCommands) / sizeof(vRPCCommands[0])); vcidx++)\n    {\n        const CRPCCommand *pcmd;\n\n        pcmd = &vRPCCommands[vcidx];\n        mapCommands[pcmd->name] = pcmd;\n    }\n}\n\nconst CRPCCommand *CRPCTable::operator[](string name) const\n{\n    map<string, const CRPCCommand*>::const_iterator it = mapCommands.find(name);\n    if (it == mapCommands.end())\n        return NULL;\n    return (*it).second;\n}\n\n//\n// HTTP protocol\n//\n// This ain't Apache.  We're just using HTTP header for the length field\n// and to be compatible with other JSON-RPC implementations.\n//\n\nstring HTTPPost(const string& strMsg, const map<string,string>& mapRequestHeaders)\n{\n    ostringstream s;\n    s << \"POST / HTTP/1.1\\r\\n\"\n      << \"User-Agent: bitcoin-json-rpc/\" << FormatFullVersion() << \"\\r\\n\"\n      << \"Host: 127.0.0.1\\r\\n\"\n      << \"Content-Type: application/json\\r\\n\"\n      << \"Content-Length: \" << strMsg.size() << \"\\r\\n\"\n      << \"Connection: close\\r\\n\"\n      << \"Accept: application/json\\r\\n\";\n    BOOST_FOREACH(const PAIRTYPE(string, string)& item, mapRequestHeaders)\n        s << item.first << \": \" << item.second << \"\\r\\n\";\n    s << \"\\r\\n\" << strMsg;\n\n    return s.str();\n}\n\nstring rfc1123Time()\n{\n    char buffer[64];\n    time_t now;\n    time(&now);\n    struct tm* now_gmt = gmtime(&now);\n    string locale(setlocale(LC_TIME, NULL));\n    setlocale(LC_TIME, \"C\"); // we want POSIX (aka \"C\") weekday/month strings\n    strftime(buffer, sizeof(buffer), \"%a, %d %b %Y %H:%M:%S +0000\", now_gmt);\n    setlocale(LC_TIME, locale.c_str());\n    return string(buffer);\n}\n\nstatic string HTTPReply(int nStatus, const string& strMsg, bool keepalive)\n{\n    if (nStatus == HTTP_UNAUTHORIZED)\n        return strprintf(\"HTTP/1.0 401 Authorization Required\\r\\n\"\n            \"Date: %s\\r\\n\"\n            \"Server: bitcoin-json-rpc/%s\\r\\n\"\n            \"WWW-Authenticate: Basic realm=\\\"jsonrpc\\\"\\r\\n\"\n            \"Content-Type: text/html\\r\\n\"\n            \"Content-Length: 296\\r\\n\"\n            \"\\r\\n\"\n            \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\"\\r\\n\"\n            \"\\\"http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd\\\">\\r\\n\"\n            \"<HTML>\\r\\n\"\n            \"<HEAD>\\r\\n\"\n            \"<TITLE>Error</TITLE>\\r\\n\"\n            \"<META HTTP-EQUIV='Content-Type' CONTENT='text/html; charset=ISO-8859-1'>\\r\\n\"\n            \"</HEAD>\\r\\n\"\n            \"<BODY><H1>401 Unauthorized.</H1></BODY>\\r\\n\"\n            \"</HTML>\\r\\n\", rfc1123Time().c_str(), FormatFullVersion().c_str());\n    const char *cStatus;\n         if (nStatus == HTTP_OK) cStatus = \"OK\";\n    else if (nStatus == HTTP_BAD_REQUEST) cStatus = \"Bad Request\";\n    else if (nStatus == HTTP_FORBIDDEN) cStatus = \"Forbidden\";\n    else if (nStatus == HTTP_NOT_FOUND) cStatus = \"Not Found\";\n    else if (nStatus == HTTP_INTERNAL_SERVER_ERROR) cStatus = \"Internal Server Error\";\n    else cStatus = \"\";\n    return strprintf(\n            \"HTTP/1.1 %d %s\\r\\n\"\n            \"Date: %s\\r\\n\"\n            \"Connection: %s\\r\\n\"\n            \"Content-Length: %\"PRIszu\"\\r\\n\"\n            \"Content-Type: application/json\\r\\n\"\n            \"Server: bitcoin-json-rpc/%s\\r\\n\"\n            \"\\r\\n\"\n            \"%s\",\n        nStatus,\n        cStatus,\n        rfc1123Time().c_str(),\n        keepalive ? \"keep-alive\" : \"close\",\n        strMsg.size(),\n        FormatFullVersion().c_str(),\n        strMsg.c_str());\n}\n\nbool ReadHTTPRequestLine(std::basic_istream<char>& stream, int &proto,\n                         string& http_method, string& http_uri)\n{\n    string str;\n    getline(stream, str);\n\n    // HTTP request line is space-delimited\n    vector<string> vWords;\n    boost::split(vWords, str, boost::is_any_of(\" \"));\n    if (vWords.size() < 2)\n        return false;\n\n    // HTTP methods permitted: GET, POST\n    http_method = vWords[0];\n    if (http_method != \"GET\" && http_method != \"POST\")\n        return false;\n\n    // HTTP URI must be an absolute path, relative to current host\n    http_uri = vWords[1];\n    if (http_uri.size() == 0 || http_uri[0] != '/')\n        return false;\n\n    // parse proto, if present\n    string strProto = \"\";\n    if (vWords.size() > 2)\n        strProto = vWords[2];\n\n    proto = 0;\n    const char *ver = strstr(strProto.c_str(), \"HTTP/1.\");\n    if (ver != NULL)\n        proto = atoi(ver+7);\n\n    return true;\n}\n\nint ReadHTTPStatus(std::basic_istream<char>& stream, int &proto)\n{\n    string str;\n    getline(stream, str);\n    vector<string> vWords;\n    boost::split(vWords, str, boost::is_any_of(\" \"));\n    if (vWords.size() < 2)\n        return HTTP_INTERNAL_SERVER_ERROR;\n    proto = 0;\n    const char *ver = strstr(str.c_str(), \"HTTP/1.\");\n    if (ver != NULL)\n        proto = atoi(ver+7);\n    return atoi(vWords[1].c_str());\n}\n\nint ReadHTTPHeaders(std::basic_istream<char>& stream, map<string, string>& mapHeadersRet)\n{\n    int nLen = 0;\n    loop\n    {\n        string str;\n        std::getline(stream, str);\n        if (str.empty() || str == \"\\r\")\n            break;\n        string::size_type nColon = str.find(\":\");\n        if (nColon != string::npos)\n        {\n            string strHeader = str.substr(0, nColon);\n            boost::trim(strHeader);\n            boost::to_lower(strHeader);\n            string strValue = str.substr(nColon+1);\n            boost::trim(strValue);\n            mapHeadersRet[strHeader] = strValue;\n            if (strHeader == \"content-length\")\n                nLen = atoi(strValue.c_str());\n        }\n    }\n    return nLen;\n}\n\nint ReadHTTPMessage(std::basic_istream<char>& stream, map<string,\n                    string>& mapHeadersRet, string& strMessageRet,\n                    int nProto)\n{\n    mapHeadersRet.clear();\n    strMessageRet = \"\";\n\n    // Read header\n    int nLen = ReadHTTPHeaders(stream, mapHeadersRet);\n    if (nLen < 0 || nLen > (int)MAX_SIZE)\n        return HTTP_INTERNAL_SERVER_ERROR;\n\n    // Read message\n    if (nLen > 0)\n    {\n        vector<char> vch(nLen);\n        stream.read(&vch[0], nLen);\n        strMessageRet = string(vch.begin(), vch.end());\n    }\n\n    string sConHdr = mapHeadersRet[\"connection\"];\n\n    if ((sConHdr != \"close\") && (sConHdr != \"keep-alive\"))\n    {\n        if (nProto >= 1)\n            mapHeadersRet[\"connection\"] = \"keep-alive\";\n        else\n            mapHeadersRet[\"connection\"] = \"close\";\n    }\n\n    return HTTP_OK;\n}\n\nbool HTTPAuthorized(map<string, string>& mapHeaders)\n{\n    string strAuth = mapHeaders[\"authorization\"];\n    if (strAuth.substr(0,6) != \"Basic \")\n        return false;\n    string strUserPass64 = strAuth.substr(6); boost::trim(strUserPass64);\n    string strUserPass = DecodeBase64(strUserPass64);\n    return TimingResistantEqual(strUserPass, strRPCUserColonPass);\n}\n\n//\n// JSON-RPC protocol.  Bitcoin speaks version 1.0 for maximum compatibility,\n// but uses JSON-RPC 1.1/2.0 standards for parts of the 1.0 standard that were\n// unspecified (HTTP errors and contents of 'error').\n//\n// 1.0 spec: http://json-rpc.org/wiki/specification\n// 1.2 spec: http://groups.google.com/group/json-rpc/web/json-rpc-over-http\n// http://www.codeproject.com/KB/recipes/JSON_Spirit.aspx\n//\n\nstring JSONRPCRequest(const string& strMethod, const Array& params, const Value& id)\n{\n    Object request;\n    request.push_back(Pair(\"method\", strMethod));\n    request.push_back(Pair(\"params\", params));\n    request.push_back(Pair(\"id\", id));\n    return write_string(Value(request), false) + \"\\n\";\n}\n\nObject JSONRPCReplyObj(const Value& result, const Value& error, const Value& id)\n{\n    Object reply;\n    if (error.type() != null_type)\n        reply.push_back(Pair(\"result\", Value::null));\n    else\n        reply.push_back(Pair(\"result\", result));\n    reply.push_back(Pair(\"error\", error));\n    reply.push_back(Pair(\"id\", id));\n    return reply;\n}\n\nstring JSONRPCReply(const Value& result, const Value& error, const Value& id)\n{\n    Object reply = JSONRPCReplyObj(result, error, id);\n    return write_string(Value(reply), false) + \"\\n\";\n}\n\nvoid ErrorReply(std::ostream& stream, const Object& objError, const Value& id)\n{\n    // Send error reply from json-rpc error object\n    int nStatus = HTTP_INTERNAL_SERVER_ERROR;\n    int code = find_value(objError, \"code\").get_int();\n    if (code == RPC_INVALID_REQUEST) nStatus = HTTP_BAD_REQUEST;\n    else if (code == RPC_METHOD_NOT_FOUND) nStatus = HTTP_NOT_FOUND;\n    string strReply = JSONRPCReply(Value::null, objError, id);\n    stream << HTTPReply(nStatus, strReply, false) << std::flush;\n}\n\nbool ClientAllowed(const boost::asio::ip::address& address)\n{\n    // Make sure that IPv4-compatible and IPv4-mapped IPv6 addresses are treated as IPv4 addresses\n    if (address.is_v6()\n     && (address.to_v6().is_v4_compatible()\n      || address.to_v6().is_v4_mapped()))\n        return ClientAllowed(address.to_v6().to_v4());\n\n    if (address == asio::ip::address_v4::loopback()\n     || address == asio::ip::address_v6::loopback()\n     || (address.is_v4()\n         // Check whether IPv4 addresses match 127.0.0.0/8 (loopback subnet)\n      && (address.to_v4().to_ulong() & 0xff000000) == 0x7f000000))\n        return true;\n\n    const string strAddress = address.to_string();\n    const vector<string>& vAllow = mapMultiArgs[\"-rpcallowip\"];\n    BOOST_FOREACH(string strAllow, vAllow)\n        if (WildcardMatch(strAddress, strAllow))\n            return true;\n    return false;\n}\n\n//\n// IOStream device that speaks SSL but can also speak non-SSL\n//\ntemplate <typename Protocol>\nclass SSLIOStreamDevice : public iostreams::device<iostreams::bidirectional> {\npublic:\n    SSLIOStreamDevice(asio::ssl::stream<typename Protocol::socket> &streamIn, bool fUseSSLIn) : stream(streamIn)\n    {\n        fUseSSL = fUseSSLIn;\n        fNeedHandshake = fUseSSLIn;\n    }\n\n    void handshake(ssl::stream_base::handshake_type role)\n    {\n        if (!fNeedHandshake) return;\n        fNeedHandshake = false;\n        stream.handshake(role);\n    }\n    std::streamsize read(char* s, std::streamsize n)\n    {\n        handshake(ssl::stream_base::server); // HTTPS servers read first\n        if (fUseSSL) return stream.read_some(asio::buffer(s, n));\n        return stream.next_layer().read_some(asio::buffer(s, n));\n    }\n    std::streamsize write(const char* s, std::streamsize n)\n    {\n        handshake(ssl::stream_base::client); // HTTPS clients write first\n        if (fUseSSL) return asio::write(stream, asio::buffer(s, n));\n        return asio::write(stream.next_layer(), asio::buffer(s, n));\n    }\n    bool connect(const std::string& server, const std::string& port)\n    {\n        ip::tcp::resolver resolver(stream.get_io_service());\n        ip::tcp::resolver::query query(server.c_str(), port.c_str());\n        ip::tcp::resolver::iterator endpoint_iterator = resolver.resolve(query);\n        ip::tcp::resolver::iterator end;\n        boost::system::error_code error = asio::error::host_not_found;\n        while (error && endpoint_iterator != end)\n        {\n            stream.lowest_layer().close();\n            stream.lowest_layer().connect(*endpoint_iterator++, error);\n        }\n        if (error)\n            return false;\n        return true;\n    }\n\nprivate:\n    bool fNeedHandshake;\n    bool fUseSSL;\n    asio::ssl::stream<typename Protocol::socket>& stream;\n};\n\nclass AcceptedConnection\n{\npublic:\n    virtual ~AcceptedConnection() {}\n\n    virtual std::iostream& stream() = 0;\n    virtual std::string peer_address_to_string() const = 0;\n    virtual void close() = 0;\n};\n\ntemplate <typename Protocol>\nclass AcceptedConnectionImpl : public AcceptedConnection\n{\npublic:\n    AcceptedConnectionImpl(\n            asio::io_service& io_service,\n            ssl::context &context,\n            bool fUseSSL) :\n        sslStream(io_service, context),\n        _d(sslStream, fUseSSL),\n        _stream(_d)\n    {\n    }\n\n    virtual std::iostream& stream()\n    {\n        return _stream;\n    }\n\n    virtual std::string peer_address_to_string() const\n    {\n        return peer.address().to_string();\n    }\n\n    virtual void close()\n    {\n        _stream.close();\n    }\n\n    typename Protocol::endpoint peer;\n    asio::ssl::stream<typename Protocol::socket> sslStream;\n\nprivate:\n    SSLIOStreamDevice<Protocol> _d;\n    iostreams::stream< SSLIOStreamDevice<Protocol> > _stream;\n};\n\nvoid ServiceConnection(AcceptedConnection *conn);\n\n// Forward declaration required for RPCListen\ntemplate <typename Protocol, typename SocketAcceptorService>\nstatic void RPCAcceptHandler(boost::shared_ptr< basic_socket_acceptor<Protocol, SocketAcceptorService> > acceptor,\n                             ssl::context& context,\n                             bool fUseSSL,\n                             AcceptedConnection* conn,\n                             const boost::system::error_code& error);\n\n/**\n * Sets up I/O resources to accept and handle a new connection.\n */\ntemplate <typename Protocol, typename SocketAcceptorService>\nstatic void RPCListen(boost::shared_ptr< basic_socket_acceptor<Protocol, SocketAcceptorService> > acceptor,\n                   ssl::context& context,\n                   const bool fUseSSL)\n{\n    // Accept connection\n    AcceptedConnectionImpl<Protocol>* conn = new AcceptedConnectionImpl<Protocol>(acceptor->get_io_service(), context, fUseSSL);\n\n    acceptor->async_accept(\n            conn->sslStream.lowest_layer(),\n            conn->peer,\n            boost::bind(&RPCAcceptHandler<Protocol, SocketAcceptorService>,\n                acceptor,\n                boost::ref(context),\n                fUseSSL,\n                conn,\n                boost::asio::placeholders::error));\n}\n\n/**\n * Accept and handle incoming connection.\n */\ntemplate <typename Protocol, typename SocketAcceptorService>\nstatic void RPCAcceptHandler(boost::shared_ptr< basic_socket_acceptor<Protocol, SocketAcceptorService> > acceptor,\n                             ssl::context& context,\n                             const bool fUseSSL,\n                             AcceptedConnection* conn,\n                             const boost::system::error_code& error)\n{\n    // Immediately start accepting new connections, except when we're cancelled or our socket is closed.\n    if (error != asio::error::operation_aborted && acceptor->is_open())\n        RPCListen(acceptor, context, fUseSSL);\n\n    AcceptedConnectionImpl<ip::tcp>* tcp_conn = dynamic_cast< AcceptedConnectionImpl<ip::tcp>* >(conn);\n\n    // TODO: Actually handle errors\n    if (error)\n    {\n        delete conn;\n    }\n\n    // Restrict callers by IP.  It is important to\n    // do this before starting client thread, to filter out\n    // certain DoS and misbehaving clients.\n    else if (tcp_conn && !ClientAllowed(tcp_conn->peer.address()))\n    {\n        // Only send a 403 if we're not using SSL to prevent a DoS during the SSL handshake.\n        if (!fUseSSL)\n            conn->stream() << HTTPReply(HTTP_FORBIDDEN, \"\", false) << std::flush;\n        delete conn;\n    }\n    else {\n        ServiceConnection(conn);\n        conn->close();\n        delete conn;\n    }\n}\n\nvoid StartRPCThreads()\n{\n    // getwork/getblocktemplate mining rewards paid here:\n    pMiningKey = new CReserveKey(pwalletMain);\n\n    strRPCUserColonPass = mapArgs[\"-rpcuser\"] + \":\" + mapArgs[\"-rpcpassword\"];\n    if ((mapArgs[\"-rpcpassword\"] == \"\") ||\n        (mapArgs[\"-rpcuser\"] == mapArgs[\"-rpcpassword\"]))\n    {\n        unsigned char rand_pwd[32];\n        RAND_bytes(rand_pwd, 32);\n        string strWhatAmI = \"To use bitcoind\";\n        if (mapArgs.count(\"-server\"))\n            strWhatAmI = strprintf(_(\"To use the %s option\"), \"\\\"-server\\\"\");\n        else if (mapArgs.count(\"-daemon\"))\n            strWhatAmI = strprintf(_(\"To use the %s option\"), \"\\\"-daemon\\\"\");\n        uiInterface.ThreadSafeMessageBox(strprintf(\n            _(\"%s, you must set a rpcpassword in the configuration file:\\n\"\n              \"%s\\n\"\n              \"It is recommended you use the following random password:\\n\"\n              \"rpcuser=bitcoinrpc\\n\"\n              \"rpcpassword=%s\\n\"\n              \"(you do not need to remember this password)\\n\"\n              \"The username and password MUST NOT be the same.\\n\"\n              \"If the file does not exist, create it with owner-readable-only file permissions.\\n\"\n              \"It is also recommended to set alertnotify so you are notified of problems;\\n\"\n              \"for example: alertnotify=echo %%s | mail -s \\\"Bitcoin Alert\\\" admin@foo.com\\n\"),\n                strWhatAmI.c_str(),\n                GetConfigFile().string().c_str(),\n                EncodeBase58(&rand_pwd[0],&rand_pwd[0]+32).c_str()),\n                \"\", CClientUIInterface::MSG_ERROR);\n        StartShutdown();\n        return;\n    }\n\n    assert(rpc_io_service == NULL);\n    rpc_io_service = new asio::io_service();\n    rpc_ssl_context = new ssl::context(*rpc_io_service, ssl::context::sslv23);\n\n    const bool fUseSSL = GetBoolArg(\"-rpcssl\");\n\n    if (fUseSSL)\n    {\n        rpc_ssl_context->set_options(ssl::context::no_sslv2);\n\n        filesystem::path pathCertFile(GetArg(\"-rpcsslcertificatechainfile\", \"server.cert\"));\n        if (!pathCertFile.is_complete()) pathCertFile = filesystem::path(GetDataDir()) / pathCertFile;\n        if (filesystem::exists(pathCertFile)) rpc_ssl_context->use_certificate_chain_file(pathCertFile.string());\n        else printf(\"ThreadRPCServer ERROR: missing server certificate file %s\\n\", pathCertFile.string().c_str());\n\n        filesystem::path pathPKFile(GetArg(\"-rpcsslprivatekeyfile\", \"server.pem\"));\n        if (!pathPKFile.is_complete()) pathPKFile = filesystem::path(GetDataDir()) / pathPKFile;\n        if (filesystem::exists(pathPKFile)) rpc_ssl_context->use_private_key_file(pathPKFile.string(), ssl::context::pem);\n        else printf(\"ThreadRPCServer ERROR: missing server private key file %s\\n\", pathPKFile.string().c_str());\n\n        string strCiphers = GetArg(\"-rpcsslciphers\", \"TLSv1+HIGH:!SSLv2:!aNULL:!eNULL:!AH:!3DES:@STRENGTH\");\n        SSL_CTX_set_cipher_list(rpc_ssl_context->impl(), strCiphers.c_str());\n    }\n\n    // Try a dual IPv6/IPv4 socket, falling back to separate IPv4 and IPv6 sockets\n    const bool loopback = !mapArgs.count(\"-rpcallowip\");\n    asio::ip::address bindAddress = loopback ? asio::ip::address_v6::loopback() : asio::ip::address_v6::any();\n    ip::tcp::endpoint endpoint(bindAddress, GetArg(\"-rpcport\", GetDefaultRPCPort()));\n    boost::system::error_code v6_only_error;\n    boost::shared_ptr<ip::tcp::acceptor> acceptor(new ip::tcp::acceptor(*rpc_io_service));\n\n    bool fListening = false;\n    std::string strerr;\n    try\n    {\n        acceptor->open(endpoint.protocol());\n        acceptor->set_option(boost::asio::ip::tcp::acceptor::reuse_address(true));\n\n        // Try making the socket dual IPv6/IPv4 (if listening on the \"any\" address)\n        acceptor->set_option(boost::asio::ip::v6_only(loopback), v6_only_error);\n\n        acceptor->bind(endpoint);\n        acceptor->listen(socket_base::max_connections);\n\n        RPCListen(acceptor, *rpc_ssl_context, fUseSSL);\n\n        fListening = true;\n    }\n    catch(boost::system::system_error &e)\n    {\n        strerr = strprintf(_(\"An error occurred while setting up the RPC port %u for listening on IPv6, falling back to IPv4: %s\"), endpoint.port(), e.what());\n    }\n\n    try {\n        // If dual IPv6/IPv4 failed (or we're opening loopback interfaces only), open IPv4 separately\n        if (!fListening || loopback || v6_only_error)\n        {\n            bindAddress = loopback ? asio::ip::address_v4::loopback() : asio::ip::address_v4::any();\n            endpoint.address(bindAddress);\n\n            acceptor.reset(new ip::tcp::acceptor(*rpc_io_service));\n            acceptor->open(endpoint.protocol());\n            acceptor->set_option(boost::asio::ip::tcp::acceptor::reuse_address(true));\n            acceptor->bind(endpoint);\n            acceptor->listen(socket_base::max_connections);\n\n            RPCListen(acceptor, *rpc_ssl_context, fUseSSL);\n\n            fListening = true;\n        }\n    }\n    catch(boost::system::system_error &e)\n    {\n        strerr = strprintf(_(\"An error occurred while setting up the RPC port %u for listening on IPv4: %s\"), endpoint.port(), e.what());\n    }\n\n    if (!fListening) {\n        uiInterface.ThreadSafeMessageBox(strerr, \"\", CClientUIInterface::MSG_ERROR);\n        StartShutdown();\n        return;\n    }\n\n    rpc_worker_group = new boost::thread_group();\n    for (int i = 0; i < GetArg(\"-rpcthreads\", 4); i++)\n        rpc_worker_group->create_thread(boost::bind(&asio::io_service::run, rpc_io_service));\n}\n\nvoid StopRPCThreads()\n{\n    delete pMiningKey; pMiningKey = NULL;\n\n    if (rpc_io_service == NULL) return;\n\n    rpc_io_service->stop();\n    rpc_worker_group->join_all();\n    delete rpc_worker_group; rpc_worker_group = NULL;\n    delete rpc_ssl_context; rpc_ssl_context = NULL;\n    delete rpc_io_service; rpc_io_service = NULL;\n}\n\nclass JSONRequest\n{\npublic:\n    Value id;\n    string strMethod;\n    Array params;\n\n    JSONRequest() { id = Value::null; }\n    void parse(const Value& valRequest);\n};\n\nvoid JSONRequest::parse(const Value& valRequest)\n{\n    // Parse request\n    if (valRequest.type() != obj_type)\n        throw JSONRPCError(RPC_INVALID_REQUEST, \"Invalid Request object\");\n    const Object& request = valRequest.get_obj();\n\n    // Parse id now so errors from here on will have the id\n    id = find_value(request, \"id\");\n\n    // Parse method\n    Value valMethod = find_value(request, \"method\");\n    if (valMethod.type() == null_type)\n        throw JSONRPCError(RPC_INVALID_REQUEST, \"Missing method\");\n    if (valMethod.type() != str_type)\n        throw JSONRPCError(RPC_INVALID_REQUEST, \"Method must be a string\");\n    strMethod = valMethod.get_str();\n    if (strMethod != \"getwork\" && strMethod != \"getblocktemplate\")\n        printf(\"ThreadRPCServer method=%s\\n\", strMethod.c_str());\n\n    // Parse params\n    Value valParams = find_value(request, \"params\");\n    if (valParams.type() == array_type)\n        params = valParams.get_array();\n    else if (valParams.type() == null_type)\n        params = Array();\n    else\n        throw JSONRPCError(RPC_INVALID_REQUEST, \"Params must be an array\");\n}\n\nstatic Object JSONRPCExecOne(const Value& req)\n{\n    Object rpc_result;\n\n    JSONRequest jreq;\n    try {\n        jreq.parse(req);\n\n        Value result = tableRPC.execute(jreq.strMethod, jreq.params);\n        rpc_result = JSONRPCReplyObj(result, Value::null, jreq.id);\n    }\n    catch (Object& objError)\n    {\n        rpc_result = JSONRPCReplyObj(Value::null, objError, jreq.id);\n    }\n    catch (std::exception& e)\n    {\n        rpc_result = JSONRPCReplyObj(Value::null,\n                                     JSONRPCError(RPC_PARSE_ERROR, e.what()), jreq.id);\n    }\n\n    return rpc_result;\n}\n\nstatic string JSONRPCExecBatch(const Array& vReq)\n{\n    Array ret;\n    for (unsigned int reqIdx = 0; reqIdx < vReq.size(); reqIdx++)\n        ret.push_back(JSONRPCExecOne(vReq[reqIdx]));\n\n    return write_string(Value(ret), false) + \"\\n\";\n}\n\nvoid ServiceConnection(AcceptedConnection *conn)\n{\n    bool fRun = true;\n    while (fRun)\n    {\n        int nProto = 0;\n        map<string, string> mapHeaders;\n        string strRequest, strMethod, strURI;\n\n        // Read HTTP request line\n        if (!ReadHTTPRequestLine(conn->stream(), nProto, strMethod, strURI))\n            break;\n\n        // Read HTTP message headers and body\n        ReadHTTPMessage(conn->stream(), mapHeaders, strRequest, nProto);\n\n        if (strURI != \"/\") {\n            conn->stream() << HTTPReply(HTTP_NOT_FOUND, \"\", false) << std::flush;\n            break;\n        }\n\n        // Check authorization\n        if (mapHeaders.count(\"authorization\") == 0)\n        {\n            conn->stream() << HTTPReply(HTTP_UNAUTHORIZED, \"\", false) << std::flush;\n            break;\n        }\n        if (!HTTPAuthorized(mapHeaders))\n        {\n            printf(\"ThreadRPCServer incorrect password attempt from %s\\n\", conn->peer_address_to_string().c_str());\n            /* Deter brute-forcing short passwords.\n               If this results in a DOS the user really\n               shouldn't have their RPC port exposed.*/\n            if (mapArgs[\"-rpcpassword\"].size() < 20)\n                MilliSleep(250);\n\n            conn->stream() << HTTPReply(HTTP_UNAUTHORIZED, \"\", false) << std::flush;\n            break;\n        }\n        if (mapHeaders[\"connection\"] == \"close\")\n            fRun = false;\n\n        JSONRequest jreq;\n        try\n        {\n            // Parse request\n            Value valRequest;\n            if (!read_string(strRequest, valRequest))\n                throw JSONRPCError(RPC_PARSE_ERROR, \"Parse error\");\n\n            string strReply;\n\n            // singleton request\n            if (valRequest.type() == obj_type) {\n                jreq.parse(valRequest);\n\n                Value result = tableRPC.execute(jreq.strMethod, jreq.params);\n\n                // Send reply\n                strReply = JSONRPCReply(result, Value::null, jreq.id);\n\n            // array of requests\n            } else if (valRequest.type() == array_type)\n                strReply = JSONRPCExecBatch(valRequest.get_array());\n            else\n                throw JSONRPCError(RPC_PARSE_ERROR, \"Top-level object parse error\");\n\n            conn->stream() << HTTPReply(HTTP_OK, strReply, fRun) << std::flush;\n        }\n        catch (Object& objError)\n        {\n            ErrorReply(conn->stream(), objError, jreq.id);\n            break;\n        }\n        catch (std::exception& e)\n        {\n            ErrorReply(conn->stream(), JSONRPCError(RPC_PARSE_ERROR, e.what()), jreq.id);\n            break;\n        }\n    }\n}\n\njson_spirit::Value CRPCTable::execute(const std::string &strMethod, const json_spirit::Array &params) const\n{\n    // Find method\n    const CRPCCommand *pcmd = tableRPC[strMethod];\n    if (!pcmd)\n        throw JSONRPCError(RPC_METHOD_NOT_FOUND, \"Method not found\");\n\n    // Observe safe mode\n    string strWarning = GetWarnings(\"rpc\");\n    if (strWarning != \"\" && !GetBoolArg(\"-disablesafemode\") &&\n        !pcmd->okSafeMode)\n        throw JSONRPCError(RPC_FORBIDDEN_BY_SAFE_MODE, string(\"Safe mode: \") + strWarning);\n\n    try\n    {\n        // Execute\n        Value result;\n        {\n            if (pcmd->threadSafe)\n                result = pcmd->actor(params, false);\n            else {\n                LOCK2(cs_main, pwalletMain->cs_wallet);\n                result = pcmd->actor(params, false);\n            }\n        }\n        return result;\n    }\n    catch (std::exception& e)\n    {\n        throw JSONRPCError(RPC_MISC_ERROR, e.what());\n    }\n}\n\n\nObject CallRPC(const string& strMethod, const Array& params)\n{\n    if (mapArgs[\"-rpcuser\"] == \"\" && mapArgs[\"-rpcpassword\"] == \"\")\n        throw runtime_error(strprintf(\n            _(\"You must set rpcpassword=<password> in the configuration file:\\n%s\\n\"\n              \"If the file does not exist, create it with owner-readable-only file permissions.\"),\n                GetConfigFile().string().c_str()));\n\n    // Connect to localhost\n    bool fUseSSL = GetBoolArg(\"-rpcssl\");\n    asio::io_service io_service;\n    ssl::context context(io_service, ssl::context::sslv23);\n    context.set_options(ssl::context::no_sslv2);\n    asio::ssl::stream<asio::ip::tcp::socket> sslStream(io_service, context);\n    SSLIOStreamDevice<asio::ip::tcp> d(sslStream, fUseSSL);\n    iostreams::stream< SSLIOStreamDevice<asio::ip::tcp> > stream(d);\n    if (!d.connect(GetArg(\"-rpcconnect\", \"127.0.0.1\"), GetArg(\"-rpcport\", itostr(GetDefaultRPCPort()))))\n        throw runtime_error(\"couldn't connect to server\");\n\n    // HTTP basic authentication\n    string strUserPass64 = EncodeBase64(mapArgs[\"-rpcuser\"] + \":\" + mapArgs[\"-rpcpassword\"]);\n    map<string, string> mapRequestHeaders;\n    mapRequestHeaders[\"Authorization\"] = string(\"Basic \") + strUserPass64;\n\n    // Send request\n    string strRequest = JSONRPCRequest(strMethod, params, 1);\n    string strPost = HTTPPost(strRequest, mapRequestHeaders);\n    stream << strPost << std::flush;\n\n    // Receive HTTP reply status\n    int nProto = 0;\n    int nStatus = ReadHTTPStatus(stream, nProto);\n\n    // Receive HTTP reply message headers and body\n    map<string, string> mapHeaders;\n    string strReply;\n    ReadHTTPMessage(stream, mapHeaders, strReply, nProto);\n\n    if (nStatus == HTTP_UNAUTHORIZED)\n        throw runtime_error(\"incorrect rpcuser or rpcpassword (authorization failed)\");\n    else if (nStatus >= 400 && nStatus != HTTP_BAD_REQUEST && nStatus != HTTP_NOT_FOUND && nStatus != HTTP_INTERNAL_SERVER_ERROR)\n        throw runtime_error(strprintf(\"server returned HTTP error %d\", nStatus));\n    else if (strReply.empty())\n        throw runtime_error(\"no response from server\");\n\n    // Parse reply\n    Value valReply;\n    if (!read_string(strReply, valReply))\n        throw runtime_error(\"couldn't parse reply from server\");\n    const Object& reply = valReply.get_obj();\n    if (reply.empty())\n        throw runtime_error(\"expected reply to have result, error and id properties\");\n\n    return reply;\n}\n\n\n\n\ntemplate<typename T>\nvoid ConvertTo(Value& value, bool fAllowNull=false)\n{\n    if (fAllowNull && value.type() == null_type)\n        return;\n    if (value.type() == str_type)\n    {\n        // reinterpret string as unquoted json value\n        Value value2;\n        string strJSON = value.get_str();\n        if (!read_string(strJSON, value2))\n            throw runtime_error(string(\"Error parsing JSON:\")+strJSON);\n        ConvertTo<T>(value2, fAllowNull);\n        value = value2;\n    }\n    else\n    {\n        value = value.get_value<T>();\n    }\n}\n\n// Convert strings to command-specific RPC representation\nArray RPCConvertValues(const std::string &strMethod, const std::vector<std::string> &strParams)\n{\n    Array params;\n    BOOST_FOREACH(const std::string &param, strParams)\n        params.push_back(param);\n\n    int n = params.size();\n\n    //\n    // Special case non-string parameter types\n    //\n    if (strMethod == \"stop\"                   && n > 0) ConvertTo<bool>(params[0]);\n    if (strMethod == \"getaddednodeinfo\"       && n > 0) ConvertTo<bool>(params[0]);\n    if (strMethod == \"setgenerate\"            && n > 0) ConvertTo<bool>(params[0]);\n    if (strMethod == \"setgenerate\"            && n > 1) ConvertTo<boost::int64_t>(params[1]);\n    if (strMethod == \"sendtoaddress\"          && n > 1) ConvertTo<double>(params[1]);\n    if (strMethod == \"settxfee\"               && n > 0) ConvertTo<double>(params[0]);\n    if (strMethod == \"getreceivedbyaddress\"   && n > 1) ConvertTo<boost::int64_t>(params[1]);\n    if (strMethod == \"getreceivedbyaccount\"   && n > 1) ConvertTo<boost::int64_t>(params[1]);\n    if (strMethod == \"listreceivedbyaddress\"  && n > 0) ConvertTo<boost::int64_t>(params[0]);\n    if (strMethod == \"listreceivedbyaddress\"  && n > 1) ConvertTo<bool>(params[1]);\n    if (strMethod == \"listreceivedbyaccount\"  && n > 0) ConvertTo<boost::int64_t>(params[0]);\n    if (strMethod == \"listreceivedbyaccount\"  && n > 1) ConvertTo<bool>(params[1]);\n    if (strMethod == \"getbalance\"             && n > 1) ConvertTo<boost::int64_t>(params[1]);\n    if (strMethod == \"getblockhash\"           && n > 0) ConvertTo<boost::int64_t>(params[0]);\n    if (strMethod == \"move\"                   && n > 2) ConvertTo<double>(params[2]);\n    if (strMethod == \"move\"                   && n > 3) ConvertTo<boost::int64_t>(params[3]);\n    if (strMethod == \"sendfrom\"               && n > 2) ConvertTo<double>(params[2]);\n    if (strMethod == \"sendfrom\"               && n > 3) ConvertTo<boost::int64_t>(params[3]);\n    if (strMethod == \"listtransactions\"       && n > 1) ConvertTo<boost::int64_t>(params[1]);\n    if (strMethod == \"listtransactions\"       && n > 2) ConvertTo<boost::int64_t>(params[2]);\n    if (strMethod == \"listaccounts\"           && n > 0) ConvertTo<boost::int64_t>(params[0]);\n    if (strMethod == \"walletpassphrase\"       && n > 1) ConvertTo<boost::int64_t>(params[1]);\n    if (strMethod == \"getblocktemplate\"       && n > 0) ConvertTo<Object>(params[0]);\n    if (strMethod == \"listsinceblock\"         && n > 1) ConvertTo<boost::int64_t>(params[1]);\n    if (strMethod == \"sendmany\"               && n > 1) ConvertTo<Object>(params[1]);\n    if (strMethod == \"sendmany\"               && n > 2) ConvertTo<boost::int64_t>(params[2]);\n    if (strMethod == \"addmultisigaddress\"     && n > 0) ConvertTo<boost::int64_t>(params[0]);\n    if (strMethod == \"addmultisigaddress\"     && n > 1) ConvertTo<Array>(params[1]);\n    if (strMethod == \"createmultisig\"         && n > 0) ConvertTo<boost::int64_t>(params[0]);\n    if (strMethod == \"createmultisig\"         && n > 1) ConvertTo<Array>(params[1]);\n    if (strMethod == \"listunspent\"            && n > 0) ConvertTo<boost::int64_t>(params[0]);\n    if (strMethod == \"listunspent\"            && n > 1) ConvertTo<boost::int64_t>(params[1]);\n    if (strMethod == \"listunspent\"            && n > 2) ConvertTo<Array>(params[2]);\n    if (strMethod == \"getrawtransaction\"      && n > 1) ConvertTo<boost::int64_t>(params[1]);\n    if (strMethod == \"createrawtransaction\"   && n > 0) ConvertTo<Array>(params[0]);\n    if (strMethod == \"createrawtransaction\"   && n > 1) ConvertTo<Object>(params[1]);\n    if (strMethod == \"signrawtransaction\"     && n > 1) ConvertTo<Array>(params[1], true);\n    if (strMethod == \"signrawtransaction\"     && n > 2) ConvertTo<Array>(params[2], true);\n    if (strMethod == \"gettxout\"               && n > 1) ConvertTo<boost::int64_t>(params[1]);\n    if (strMethod == \"gettxout\"               && n > 2) ConvertTo<bool>(params[2]);\n    if (strMethod == \"lockunspent\"            && n > 0) ConvertTo<bool>(params[0]);\n    if (strMethod == \"lockunspent\"            && n > 1) ConvertTo<Array>(params[1]);\n    if (strMethod == \"importprivkey\"          && n > 2) ConvertTo<bool>(params[2]);\n\n    return params;\n}\n\nint CommandLineRPC(int argc, char *argv[])\n{\n    string strPrint;\n    int nRet = 0;\n    try\n    {\n        // Skip switches\n        while (argc > 1 && IsSwitchChar(argv[1][0]))\n        {\n            argc--;\n            argv++;\n        }\n\n        // Method\n        if (argc < 2)\n            throw runtime_error(\"too few parameters\");\n        string strMethod = argv[1];\n\n        // Parameters default to strings\n        std::vector<std::string> strParams(&argv[2], &argv[argc]);\n        Array params = RPCConvertValues(strMethod, strParams);\n\n        // Execute\n        Object reply = CallRPC(strMethod, params);\n\n        // Parse reply\n        const Value& result = find_value(reply, \"result\");\n        const Value& error  = find_value(reply, \"error\");\n\n        if (error.type() != null_type)\n        {\n            // Error\n            strPrint = \"error: \" + write_string(error, false);\n            int code = find_value(error.get_obj(), \"code\").get_int();\n            nRet = abs(code);\n        }\n        else\n        {\n            // Result\n            if (result.type() == null_type)\n                strPrint = \"\";\n            else if (result.type() == str_type)\n                strPrint = result.get_str();\n            else\n                strPrint = write_string(result, true);\n        }\n    }\n    catch (boost::thread_interrupted) {\n        throw;\n    }\n    catch (std::exception& e) {\n        strPrint = string(\"error: \") + e.what();\n        nRet = 87;\n    }\n    catch (...) {\n        PrintException(NULL, \"CommandLineRPC()\");\n    }\n\n    if (strPrint != \"\")\n    {\n        fprintf((nRet == 0 ? stdout : stderr), \"%s\\n\", strPrint.c_str());\n    }\n    return nRet;\n}\n\n\n\n\n#ifdef TEST\nint main(int argc, char *argv[])\n{\n#ifdef _MSC_VER\n    // Turn off Microsoft heap dump noise\n    _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE);\n    _CrtSetReportFile(_CRT_WARN, CreateFile(\"NUL\", GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, 0));\n#endif\n    setbuf(stdin, NULL);\n    setbuf(stdout, NULL);\n    setbuf(stderr, NULL);\n\n    try\n    {\n        if (argc >= 2 && string(argv[1]) == \"-server\")\n        {\n            printf(\"server ready\\n\");\n            ThreadRPCServer(NULL);\n        }\n        else\n        {\n            return CommandLineRPC(argc, argv);\n        }\n    }\n    catch (boost::thread_interrupted) {\n        throw;\n    }\n    catch (std::exception& e) {\n        PrintException(&e, \"main()\");\n    } catch (...) {\n        PrintException(NULL, \"main()\");\n    }\n    return 0;\n}\n#endif\n\nconst CRPCTable tableRPC;\n", "#include <vector>\n#include <boost/test/unit_test.hpp>\n#include <boost/foreach.hpp>\n\n#include \"main.h\"\n#include \"wallet.h\"\n#include \"util.h\"\n\nusing namespace std;\n\nBOOST_AUTO_TEST_SUITE(util_tests)\n\nBOOST_AUTO_TEST_CASE(util_criticalsection)\n{\n    CCriticalSection cs;\n\n    do {\n        LOCK(cs);\n        break;\n\n        BOOST_ERROR(\"break was swallowed!\");\n    } while(0);\n\n    do {\n        TRY_LOCK(cs, lockTest);\n        if (lockTest)\n            break;\n\n        BOOST_ERROR(\"break was swallowed!\");\n    } while(0);\n}\n\nBOOST_AUTO_TEST_CASE(util_MedianFilter)\n{    \n    CMedianFilter<int> filter(5, 15);\n\n    BOOST_CHECK_EQUAL(filter.median(), 15);\n\n    filter.input(20); // [15 20]\n    BOOST_CHECK_EQUAL(filter.median(), 17);\n\n    filter.input(30); // [15 20 30]\n    BOOST_CHECK_EQUAL(filter.median(), 20);\n\n    filter.input(3); // [3 15 20 30]\n    BOOST_CHECK_EQUAL(filter.median(), 17);\n\n    filter.input(7); // [3 7 15 20 30]\n    BOOST_CHECK_EQUAL(filter.median(), 15);\n\n    filter.input(18); // [3 7 18 20 30]\n    BOOST_CHECK_EQUAL(filter.median(), 18);\n\n    filter.input(0); // [0 3 7 18 30]\n    BOOST_CHECK_EQUAL(filter.median(), 7);\n}\n\nstatic const unsigned char ParseHex_expected[65] = {\n    0x04, 0x67, 0x8a, 0xfd, 0xb0, 0xfe, 0x55, 0x48, 0x27, 0x19, 0x67, 0xf1, 0xa6, 0x71, 0x30, 0xb7, \n    0x10, 0x5c, 0xd6, 0xa8, 0x28, 0xe0, 0x39, 0x09, 0xa6, 0x79, 0x62, 0xe0, 0xea, 0x1f, 0x61, 0xde, \n    0xb6, 0x49, 0xf6, 0xbc, 0x3f, 0x4c, 0xef, 0x38, 0xc4, 0xf3, 0x55, 0x04, 0xe5, 0x1e, 0xc1, 0x12, \n    0xde, 0x5c, 0x38, 0x4d, 0xf7, 0xba, 0x0b, 0x8d, 0x57, 0x8a, 0x4c, 0x70, 0x2b, 0x6b, 0xf1, 0x1d, \n    0x5f\n};\nBOOST_AUTO_TEST_CASE(util_ParseHex)\n{\n    std::vector<unsigned char> result;\n    std::vector<unsigned char> expected(ParseHex_expected, ParseHex_expected + sizeof(ParseHex_expected));\n    // Basic test vector\n    result = ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f\");\n    BOOST_CHECK_EQUAL_COLLECTIONS(result.begin(), result.end(), expected.begin(), expected.end());\n\n    // Spaces between bytes must be supported\n    result = ParseHex(\"12 34 56 78\");\n    BOOST_CHECK(result.size() == 4 && result[0] == 0x12 && result[1] == 0x34 && result[2] == 0x56 && result[3] == 0x78);\n\n    // Stop parsing at invalid value\n    result = ParseHex(\"1234 invalid 1234\");\n    BOOST_CHECK(result.size() == 2 && result[0] == 0x12 && result[1] == 0x34);\n}\n\nBOOST_AUTO_TEST_CASE(util_HexStr)\n{\n    BOOST_CHECK_EQUAL(\n        HexStr(ParseHex_expected, ParseHex_expected + sizeof(ParseHex_expected)),\n        \"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f\");\n\n    BOOST_CHECK_EQUAL(\n        HexStr(ParseHex_expected, ParseHex_expected + 5, true),\n        \"04 67 8a fd b0\");\n\n    BOOST_CHECK_EQUAL(\n        HexStr(ParseHex_expected, ParseHex_expected, true),\n        \"\");\n\n    std::vector<unsigned char> ParseHex_vec(ParseHex_expected, ParseHex_expected + 5);\n\n    BOOST_CHECK_EQUAL(\n        HexStr(ParseHex_vec, true),\n        \"04 67 8a fd b0\");\n}\n\n\nBOOST_AUTO_TEST_CASE(util_DateTimeStrFormat)\n{\n/*These are platform-dependant and thus removed to avoid useless test failures\n    BOOST_CHECK_EQUAL(DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", 0), \"1970-01-01 00:00:00\");\n    BOOST_CHECK_EQUAL(DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", 0x7FFFFFFF), \"2038-01-19 03:14:07\");\n    // Formats used within Bitcoin\n    BOOST_CHECK_EQUAL(DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", 1317425777), \"2011-09-30 23:36:17\");\n    BOOST_CHECK_EQUAL(DateTimeStrFormat(\"%Y-%m-%d %H:%M\", 1317425777), \"2011-09-30 23:36\");\n*/\n}\n\nBOOST_AUTO_TEST_CASE(util_ParseParameters)\n{\n    const char *argv_test[] = {\"-ignored\", \"-a\", \"-b\", \"-ccc=argument\", \"-ccc=multiple\", \"f\", \"-d=e\"};\n\n    ParseParameters(0, (char**)argv_test);\n    BOOST_CHECK(mapArgs.empty() && mapMultiArgs.empty());\n\n    ParseParameters(1, (char**)argv_test);\n    BOOST_CHECK(mapArgs.empty() && mapMultiArgs.empty());\n\n    ParseParameters(5, (char**)argv_test);\n    // expectation: -ignored is ignored (program name argument), \n    // -a, -b and -ccc end up in map, -d ignored because it is after\n    // a non-option argument (non-GNU option parsing)\n    BOOST_CHECK(mapArgs.size() == 3 && mapMultiArgs.size() == 3);\n    BOOST_CHECK(mapArgs.count(\"-a\") && mapArgs.count(\"-b\") && mapArgs.count(\"-ccc\") \n                && !mapArgs.count(\"f\") && !mapArgs.count(\"-d\"));\n    BOOST_CHECK(mapMultiArgs.count(\"-a\") && mapMultiArgs.count(\"-b\") && mapMultiArgs.count(\"-ccc\") \n                && !mapMultiArgs.count(\"f\") && !mapMultiArgs.count(\"-d\"));\n\n    BOOST_CHECK(mapArgs[\"-a\"] == \"\" && mapArgs[\"-ccc\"] == \"multiple\");\n    BOOST_CHECK(mapMultiArgs[\"-ccc\"].size() == 2);\n}\n\nBOOST_AUTO_TEST_CASE(util_GetArg)\n{\n    mapArgs.clear();\n    mapArgs[\"strtest1\"] = \"string...\";\n    // strtest2 undefined on purpose\n    mapArgs[\"inttest1\"] = \"12345\";\n    mapArgs[\"inttest2\"] = \"81985529216486895\";\n    // inttest3 undefined on purpose\n    mapArgs[\"booltest1\"] = \"\";\n    // booltest2 undefined on purpose\n    mapArgs[\"booltest3\"] = \"0\";\n    mapArgs[\"booltest4\"] = \"1\";\n\n    BOOST_CHECK_EQUAL(GetArg(\"strtest1\", \"default\"), \"string...\");\n    BOOST_CHECK_EQUAL(GetArg(\"strtest2\", \"default\"), \"default\");\n    BOOST_CHECK_EQUAL(GetArg(\"inttest1\", -1), 12345);\n    BOOST_CHECK_EQUAL(GetArg(\"inttest2\", -1), 81985529216486895LL);\n    BOOST_CHECK_EQUAL(GetArg(\"inttest3\", -1), -1);\n    BOOST_CHECK_EQUAL(GetBoolArg(\"booltest1\"), true);\n    BOOST_CHECK_EQUAL(GetBoolArg(\"booltest2\"), false);\n    BOOST_CHECK_EQUAL(GetBoolArg(\"booltest3\"), false);\n    BOOST_CHECK_EQUAL(GetBoolArg(\"booltest4\"), true);\n}\n\nBOOST_AUTO_TEST_CASE(util_WildcardMatch)\n{\n    BOOST_CHECK(WildcardMatch(\"127.0.0.1\", \"*\"));\n    BOOST_CHECK(WildcardMatch(\"127.0.0.1\", \"127.*\"));\n    BOOST_CHECK(WildcardMatch(\"abcdef\", \"a?cde?\"));\n    BOOST_CHECK(!WildcardMatch(\"abcdef\", \"a?cde??\"));\n    BOOST_CHECK(WildcardMatch(\"abcdef\", \"a*f\"));\n    BOOST_CHECK(!WildcardMatch(\"abcdef\", \"a*x\"));\n    BOOST_CHECK(WildcardMatch(\"\", \"*\"));\n}\n\nBOOST_AUTO_TEST_CASE(util_FormatMoney)\n{\n    BOOST_CHECK_EQUAL(FormatMoney(0, false), \"0.00\");\n    BOOST_CHECK_EQUAL(FormatMoney((COIN/10000)*123456789, false), \"12345.6789\");\n    BOOST_CHECK_EQUAL(FormatMoney(COIN, true), \"+1.00\");\n    BOOST_CHECK_EQUAL(FormatMoney(-COIN, false), \"-1.00\");\n    BOOST_CHECK_EQUAL(FormatMoney(-COIN, true), \"-1.00\");\n\n    BOOST_CHECK_EQUAL(FormatMoney(COIN*100000000, false), \"100000000.00\");\n    BOOST_CHECK_EQUAL(FormatMoney(COIN*10000000, false), \"10000000.00\");\n    BOOST_CHECK_EQUAL(FormatMoney(COIN*1000000, false), \"1000000.00\");\n    BOOST_CHECK_EQUAL(FormatMoney(COIN*100000, false), \"100000.00\");\n    BOOST_CHECK_EQUAL(FormatMoney(COIN*10000, false), \"10000.00\");\n    BOOST_CHECK_EQUAL(FormatMoney(COIN*1000, false), \"1000.00\");\n    BOOST_CHECK_EQUAL(FormatMoney(COIN*100, false), \"100.00\");\n    BOOST_CHECK_EQUAL(FormatMoney(COIN*10, false), \"10.00\");\n    BOOST_CHECK_EQUAL(FormatMoney(COIN, false), \"1.00\");\n    BOOST_CHECK_EQUAL(FormatMoney(COIN/10, false), \"0.10\");\n    BOOST_CHECK_EQUAL(FormatMoney(COIN/100, false), \"0.01\");\n    BOOST_CHECK_EQUAL(FormatMoney(COIN/1000, false), \"0.001\");\n    BOOST_CHECK_EQUAL(FormatMoney(COIN/10000, false), \"0.0001\");\n    BOOST_CHECK_EQUAL(FormatMoney(COIN/100000, false), \"0.00001\");\n    BOOST_CHECK_EQUAL(FormatMoney(COIN/1000000, false), \"0.000001\");\n    BOOST_CHECK_EQUAL(FormatMoney(COIN/10000000, false), \"0.0000001\");\n    BOOST_CHECK_EQUAL(FormatMoney(COIN/100000000, false), \"0.00000001\");\n}\n\nBOOST_AUTO_TEST_CASE(util_ParseMoney)\n{\n    int64 ret = 0;\n    BOOST_CHECK(ParseMoney(\"0.0\", ret));\n    BOOST_CHECK_EQUAL(ret, 0);\n\n    BOOST_CHECK(ParseMoney(\"12345.6789\", ret));\n    BOOST_CHECK_EQUAL(ret, (COIN/10000)*123456789);\n\n    BOOST_CHECK(ParseMoney(\"100000000.00\", ret));\n    BOOST_CHECK_EQUAL(ret, COIN*100000000);\n    BOOST_CHECK(ParseMoney(\"10000000.00\", ret));\n    BOOST_CHECK_EQUAL(ret, COIN*10000000);\n    BOOST_CHECK(ParseMoney(\"1000000.00\", ret));\n    BOOST_CHECK_EQUAL(ret, COIN*1000000);\n    BOOST_CHECK(ParseMoney(\"100000.00\", ret));\n    BOOST_CHECK_EQUAL(ret, COIN*100000);\n    BOOST_CHECK(ParseMoney(\"10000.00\", ret));\n    BOOST_CHECK_EQUAL(ret, COIN*10000);\n    BOOST_CHECK(ParseMoney(\"1000.00\", ret));\n    BOOST_CHECK_EQUAL(ret, COIN*1000);\n    BOOST_CHECK(ParseMoney(\"100.00\", ret));\n    BOOST_CHECK_EQUAL(ret, COIN*100);\n    BOOST_CHECK(ParseMoney(\"10.00\", ret));\n    BOOST_CHECK_EQUAL(ret, COIN*10);\n    BOOST_CHECK(ParseMoney(\"1.00\", ret));\n    BOOST_CHECK_EQUAL(ret, COIN);\n    BOOST_CHECK(ParseMoney(\"0.1\", ret));\n    BOOST_CHECK_EQUAL(ret, COIN/10);\n    BOOST_CHECK(ParseMoney(\"0.01\", ret));\n    BOOST_CHECK_EQUAL(ret, COIN/100);\n    BOOST_CHECK(ParseMoney(\"0.001\", ret));\n    BOOST_CHECK_EQUAL(ret, COIN/1000);\n    BOOST_CHECK(ParseMoney(\"0.0001\", ret));\n    BOOST_CHECK_EQUAL(ret, COIN/10000);\n    BOOST_CHECK(ParseMoney(\"0.00001\", ret));\n    BOOST_CHECK_EQUAL(ret, COIN/100000);\n    BOOST_CHECK(ParseMoney(\"0.000001\", ret));\n    BOOST_CHECK_EQUAL(ret, COIN/1000000);\n    BOOST_CHECK(ParseMoney(\"0.0000001\", ret));\n    BOOST_CHECK_EQUAL(ret, COIN/10000000);\n    BOOST_CHECK(ParseMoney(\"0.00000001\", ret));\n    BOOST_CHECK_EQUAL(ret, COIN/100000000);\n\n    // Attempted 63 bit overflow should fail\n    BOOST_CHECK(!ParseMoney(\"92233720368.54775808\", ret));\n}\n\nBOOST_AUTO_TEST_CASE(util_IsHex)\n{\n    BOOST_CHECK(IsHex(\"00\"));\n    BOOST_CHECK(IsHex(\"00112233445566778899aabbccddeeffAABBCCDDEEFF\"));\n    BOOST_CHECK(IsHex(\"ff\"));\n    BOOST_CHECK(IsHex(\"FF\"));\n\n    BOOST_CHECK(!IsHex(\"\"));\n    BOOST_CHECK(!IsHex(\"0\"));\n    BOOST_CHECK(!IsHex(\"a\"));\n    BOOST_CHECK(!IsHex(\"eleven\"));\n    BOOST_CHECK(!IsHex(\"00xx00\"));\n    BOOST_CHECK(!IsHex(\"0x0000\"));\n}\n\nBOOST_AUTO_TEST_CASE(util_seed_insecure_rand)\n{\n    // Expected results for the determinstic seed.\n    const uint32_t exp_vals[11] = {  91632771U,1889679809U,3842137544U,3256031132U,\n                                   1761911779U, 489223532U,2692793790U,2737472863U,\n                                   2796262275U,1309899767U,840571781U};\n    // Expected 0s in rand()%(idx+2) for the determinstic seed.\n    const int exp_count[9] = {5013,3346,2415,1972,1644,1386,1176,1096,1009};\n    int i;\n    int count=0;\n\n    seed_insecure_rand();\n\n    //Does the non-determistic rand give us results that look too like the determinstic one?\n    for (i=0;i<10;i++)\n    {\n        int match = 0;\n        uint32_t rval = insecure_rand();\n        for (int j=0;j<11;j++)match |= rval==exp_vals[j];\n        count += match;\n    }\n    // sum(binomial(10,i)*(11/(2^32))^i*(1-(11/(2^32)))^(10-i),i,0,4) ~= 1-1/2^134.73\n    // So _very_ unlikely to throw a false failure here.\n    BOOST_CHECK(count<=4);\n\n    for (int mod=2;mod<11;mod++)\n    {\n        int mask = 1;\n        // Really rough binomal confidence approximation.\n        int err = 30*10000./mod*sqrt((1./mod*(1-1./mod))/10000.);\n        //mask is 2^ceil(log2(mod))-1\n        while(mask<mod-1)mask=(mask<<1)+1;\n\n        count = 0;\n        //How often does it get a zero from the uniform range [0,mod)?\n        for (i=0;i<10000;i++)\n        {\n            uint32_t rval;\n            do{\n                rval=insecure_rand()&mask;\n            }while(rval>=(uint32_t)mod);\n            count += rval==0;\n        }\n        BOOST_CHECK(count<=10000/mod+err);\n        BOOST_CHECK(count>=10000/mod-err);\n    }\n\n    seed_insecure_rand(true);\n\n    for (i=0;i<11;i++)\n    {\n        BOOST_CHECK_EQUAL(insecure_rand(),exp_vals[i]);\n    }\n\n    for (int mod=2;mod<11;mod++)\n    {\n        count = 0;\n        for (i=0;i<10000;i++) count += insecure_rand()%mod==0;\n        BOOST_CHECK_EQUAL(count,exp_count[mod-2]);\n    }\n}\n\nBOOST_AUTO_TEST_CASE(util_TimingResistantEqual)\n{\n    BOOST_CHECK(TimingResistantEqual(std::string(\"\"), std::string(\"\")));\n    BOOST_CHECK(!TimingResistantEqual(std::string(\"abc\"), std::string(\"\")));\n    BOOST_CHECK(!TimingResistantEqual(std::string(\"\"), std::string(\"abc\")));\n    BOOST_CHECK(!TimingResistantEqual(std::string(\"a\"), std::string(\"aa\")));\n    BOOST_CHECK(!TimingResistantEqual(std::string(\"aa\"), std::string(\"a\")));\n    BOOST_CHECK(TimingResistantEqual(std::string(\"abc\"), std::string(\"abc\")));\n    BOOST_CHECK(!TimingResistantEqual(std::string(\"abc\"), std::string(\"aba\")));\n}\n\nBOOST_AUTO_TEST_SUITE_END()\n", "// Copyright (c) 2009-2010 Satoshi Nakamoto\n// Copyright (c) 2009-2012 The Bitcoin developers\n// Distributed under the MIT/X11 software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n#ifndef BITCOIN_UTIL_H\n#define BITCOIN_UTIL_H\n\n#include \"uint256.h\"\n\n#include <stdarg.h>\n\n#ifndef WIN32\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#else\ntypedef int pid_t; /* define for Windows compatibility */\n#endif\n#include <map>\n#include <list>\n#include <utility>\n#include <vector>\n#include <string>\n\n#include <boost/thread.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n\n#include \"netbase.h\" // for AddTimeData\n\ntypedef long long  int64;\ntypedef unsigned long long  uint64;\n\nstatic const int64 COIN = 100000000;\nstatic const int64 CENT = 1000000;\n\n#define loop                for (;;)\n#define BEGIN(a)            ((char*)&(a))\n#define END(a)              ((char*)&((&(a))[1]))\n#define UBEGIN(a)           ((unsigned char*)&(a))\n#define UEND(a)             ((unsigned char*)&((&(a))[1]))\n#define ARRAYLEN(array)     (sizeof(array)/sizeof((array)[0]))\n\n#ifndef PRI64d\n#if defined(_MSC_VER) || defined(__MSVCRT__)\n#define PRI64d  \"I64d\"\n#define PRI64u  \"I64u\"\n#define PRI64x  \"I64x\"\n#else\n#define PRI64d  \"lld\"\n#define PRI64u  \"llu\"\n#define PRI64x  \"llx\"\n#endif\n#endif\n\n/* Format characters for (s)size_t and ptrdiff_t */\n#if defined(_MSC_VER) || defined(__MSVCRT__)\n  /* (s)size_t and ptrdiff_t have the same size specifier in MSVC:\n     http://msdn.microsoft.com/en-us/library/tcxf1dw6%28v=vs.100%29.aspx\n   */\n  #define PRIszx    \"Ix\"\n  #define PRIszu    \"Iu\"\n  #define PRIszd    \"Id\"\n  #define PRIpdx    \"Ix\"\n  #define PRIpdu    \"Iu\"\n  #define PRIpdd    \"Id\"\n#else /* C99 standard */\n  #define PRIszx    \"zx\"\n  #define PRIszu    \"zu\"\n  #define PRIszd    \"zd\"\n  #define PRIpdx    \"tx\"\n  #define PRIpdu    \"tu\"\n  #define PRIpdd    \"td\"\n#endif\n\n// This is needed because the foreach macro can't get over the comma in pair<t1, t2>\n#define PAIRTYPE(t1, t2)    std::pair<t1, t2>\n\n// Align by increasing pointer, must have extra space at end of buffer\ntemplate <size_t nBytes, typename T>\nT* alignup(T* p)\n{\n    union\n    {\n        T* ptr;\n        size_t n;\n    } u;\n    u.ptr = p;\n    u.n = (u.n + (nBytes-1)) & ~(nBytes-1);\n    return u.ptr;\n}\n\n#ifdef WIN32\n#define MSG_NOSIGNAL        0\n#define MSG_DONTWAIT        0\n\n#ifndef S_IRUSR\n#define S_IRUSR             0400\n#define S_IWUSR             0200\n#endif\n#else\n#define MAX_PATH            1024\n#endif\n\ninline void MilliSleep(int64 n)\n{\n#if BOOST_VERSION >= 105000\n    boost::this_thread::sleep_for(boost::chrono::milliseconds(n));\n#else\n    boost::this_thread::sleep(boost::posix_time::milliseconds(n));\n#endif\n}\n\n/* This GNU C extension enables the compiler to check the format string against the parameters provided.\n * X is the number of the \"format string\" parameter, and Y is the number of the first variadic parameter.\n * Parameters count from 1.\n */\n#ifdef __GNUC__\n#define ATTR_WARN_PRINTF(X,Y) __attribute__((format(printf,X,Y)))\n#else\n#define ATTR_WARN_PRINTF(X,Y)\n#endif\n\n\n\n\n\n\n\n\nextern std::map<std::string, std::string> mapArgs;\nextern std::map<std::string, std::vector<std::string> > mapMultiArgs;\nextern bool fDebug;\nextern bool fDebugNet;\nextern bool fPrintToConsole;\nextern bool fPrintToDebugger;\nextern bool fDaemon;\nextern bool fServer;\nextern bool fCommandLine;\nextern std::string strMiscWarning;\nextern bool fTestNet;\nextern bool fNoListen;\nextern bool fLogTimestamps;\nextern volatile bool fReopenDebugLog;\n\nvoid RandAddSeed();\nvoid RandAddSeedPerfmon();\nint ATTR_WARN_PRINTF(1,2) OutputDebugStringF(const char* pszFormat, ...);\n\n/*\n  Rationale for the real_strprintf / strprintf construction:\n    It is not allowed to use va_start with a pass-by-reference argument.\n    (C++ standard, 18.7, paragraph 3). Use a dummy argument to work around this, and use a\n    macro to keep similar semantics.\n*/\n\n/** Overload strprintf for char*, so that GCC format type warnings can be given */\nstd::string ATTR_WARN_PRINTF(1,3) real_strprintf(const char *format, int dummy, ...);\n/** Overload strprintf for std::string, to be able to use it with _ (translation).\n * This will not support GCC format type warnings (-Wformat) so be careful.\n */\nstd::string real_strprintf(const std::string &format, int dummy, ...);\n#define strprintf(format, ...) real_strprintf(format, 0, __VA_ARGS__)\nstd::string vstrprintf(const char *format, va_list ap);\n\nbool ATTR_WARN_PRINTF(1,2) error(const char *format, ...);\n\n/* Redefine printf so that it directs output to debug.log\n *\n * Do this *after* defining the other printf-like functions, because otherwise the\n * __attribute__((format(printf,X,Y))) gets expanded to __attribute__((format(OutputDebugStringF,X,Y)))\n * which confuses gcc.\n */\n#define printf OutputDebugStringF\n\nvoid LogException(std::exception* pex, const char* pszThread);\nvoid PrintException(std::exception* pex, const char* pszThread);\nvoid PrintExceptionContinue(std::exception* pex, const char* pszThread);\nvoid ParseString(const std::string& str, char c, std::vector<std::string>& v);\nstd::string FormatMoney(int64 n, bool fPlus=false);\nbool ParseMoney(const std::string& str, int64& nRet);\nbool ParseMoney(const char* pszIn, int64& nRet);\nstd::vector<unsigned char> ParseHex(const char* psz);\nstd::vector<unsigned char> ParseHex(const std::string& str);\nbool IsHex(const std::string& str);\nstd::vector<unsigned char> DecodeBase64(const char* p, bool* pfInvalid = NULL);\nstd::string DecodeBase64(const std::string& str);\nstd::string EncodeBase64(const unsigned char* pch, size_t len);\nstd::string EncodeBase64(const std::string& str);\nstd::vector<unsigned char> DecodeBase32(const char* p, bool* pfInvalid = NULL);\nstd::string DecodeBase32(const std::string& str);\nstd::string EncodeBase32(const unsigned char* pch, size_t len);\nstd::string EncodeBase32(const std::string& str);\nvoid ParseParameters(int argc, const char*const argv[]);\nbool WildcardMatch(const char* psz, const char* mask);\nbool WildcardMatch(const std::string& str, const std::string& mask);\nvoid FileCommit(FILE *fileout);\nint GetFilesize(FILE* file);\nbool TruncateFile(FILE *file, unsigned int length);\nint RaiseFileDescriptorLimit(int nMinFD);\nvoid AllocateFileRange(FILE *file, unsigned int offset, unsigned int length);\nbool RenameOver(boost::filesystem::path src, boost::filesystem::path dest);\nboost::filesystem::path GetDefaultDataDir();\nconst boost::filesystem::path &GetDataDir(bool fNetSpecific = true);\nboost::filesystem::path GetConfigFile();\nboost::filesystem::path GetPidFile();\nvoid CreatePidFile(const boost::filesystem::path &path, pid_t pid);\nvoid ReadConfigFile(std::map<std::string, std::string>& mapSettingsRet, std::map<std::string, std::vector<std::string> >& mapMultiSettingsRet);\n#ifdef WIN32\nboost::filesystem::path GetSpecialFolderPath(int nFolder, bool fCreate = true);\n#endif\nboost::filesystem::path GetTempPath();\nvoid ShrinkDebugFile();\nint GetRandInt(int nMax);\nuint64 GetRand(uint64 nMax);\nuint256 GetRandHash();\nint64 GetTime();\nvoid SetMockTime(int64 nMockTimeIn);\nint64 GetAdjustedTime();\nint64 GetTimeOffset();\nstd::string FormatFullVersion();\nstd::string FormatSubVersion(const std::string& name, int nClientVersion, const std::vector<std::string>& comments);\nvoid AddTimeData(const CNetAddr& ip, int64 nTime);\nvoid runCommand(std::string strCommand);\n\n\n\n\n\n\n\n\n\ninline std::string i64tostr(int64 n)\n{\n    return strprintf(\"%\"PRI64d, n);\n}\n\ninline std::string itostr(int n)\n{\n    return strprintf(\"%d\", n);\n}\n\ninline int64 atoi64(const char* psz)\n{\n#ifdef _MSC_VER\n    return _atoi64(psz);\n#else\n    return strtoll(psz, NULL, 10);\n#endif\n}\n\ninline int64 atoi64(const std::string& str)\n{\n#ifdef _MSC_VER\n    return _atoi64(str.c_str());\n#else\n    return strtoll(str.c_str(), NULL, 10);\n#endif\n}\n\ninline int atoi(const std::string& str)\n{\n    return atoi(str.c_str());\n}\n\ninline int roundint(double d)\n{\n    return (int)(d > 0 ? d + 0.5 : d - 0.5);\n}\n\ninline int64 roundint64(double d)\n{\n    return (int64)(d > 0 ? d + 0.5 : d - 0.5);\n}\n\ninline int64 abs64(int64 n)\n{\n    return (n >= 0 ? n : -n);\n}\n\ntemplate<typename T>\nstd::string HexStr(const T itbegin, const T itend, bool fSpaces=false)\n{\n    std::string rv;\n    static const char hexmap[16] = { '0', '1', '2', '3', '4', '5', '6', '7',\n                                     '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n    rv.reserve((itend-itbegin)*3);\n    for(T it = itbegin; it < itend; ++it)\n    {\n        unsigned char val = (unsigned char)(*it);\n        if(fSpaces && it != itbegin)\n            rv.push_back(' ');\n        rv.push_back(hexmap[val>>4]);\n        rv.push_back(hexmap[val&15]);\n    }\n\n    return rv;\n}\n\ninline std::string HexStr(const std::vector<unsigned char>& vch, bool fSpaces=false)\n{\n    return HexStr(vch.begin(), vch.end(), fSpaces);\n}\n\ntemplate<typename T>\nvoid PrintHex(const T pbegin, const T pend, const char* pszFormat=\"%s\", bool fSpaces=true)\n{\n    printf(pszFormat, HexStr(pbegin, pend, fSpaces).c_str());\n}\n\ninline void PrintHex(const std::vector<unsigned char>& vch, const char* pszFormat=\"%s\", bool fSpaces=true)\n{\n    printf(pszFormat, HexStr(vch, fSpaces).c_str());\n}\n\ninline int64 GetPerformanceCounter()\n{\n    int64 nCounter = 0;\n#ifdef WIN32\n    QueryPerformanceCounter((LARGE_INTEGER*)&nCounter);\n#else\n    timeval t;\n    gettimeofday(&t, NULL);\n    nCounter = (int64) t.tv_sec * 1000000 + t.tv_usec;\n#endif\n    return nCounter;\n}\n\ninline int64 GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}\n\ninline int64 GetTimeMicros()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_microseconds();\n}\n\ninline std::string DateTimeStrFormat(const char* pszFormat, int64 nTime)\n{\n    time_t n = nTime;\n    struct tm* ptmTime = gmtime(&n);\n    char pszTime[200];\n    strftime(pszTime, sizeof(pszTime), pszFormat, ptmTime);\n    return pszTime;\n}\n\ntemplate<typename T>\nvoid skipspaces(T& it)\n{\n    while (isspace(*it))\n        ++it;\n}\n\ninline bool IsSwitchChar(char c)\n{\n#ifdef WIN32\n    return c == '-' || c == '/';\n#else\n    return c == '-';\n#endif\n}\n\n/**\n * Return string argument or default value\n *\n * @param strArg Argument to get (e.g. \"-foo\")\n * @param default (e.g. \"1\")\n * @return command-line argument or default value\n */\nstd::string GetArg(const std::string& strArg, const std::string& strDefault);\n\n/**\n * Return integer argument or default value\n *\n * @param strArg Argument to get (e.g. \"-foo\")\n * @param default (e.g. 1)\n * @return command-line argument (0 if invalid number) or default value\n */\nint64 GetArg(const std::string& strArg, int64 nDefault);\n\n/**\n * Return boolean argument or default value\n *\n * @param strArg Argument to get (e.g. \"-foo\")\n * @param default (true or false)\n * @return command-line argument or default value\n */\nbool GetBoolArg(const std::string& strArg, bool fDefault=false);\n\n/**\n * Set an argument if it doesn't already have a value\n *\n * @param strArg Argument to set (e.g. \"-foo\")\n * @param strValue Value (e.g. \"1\")\n * @return true if argument gets set, false if it already had a value\n */\nbool SoftSetArg(const std::string& strArg, const std::string& strValue);\n\n/**\n * Set a boolean argument if it doesn't already have a value\n *\n * @param strArg Argument to set (e.g. \"-foo\")\n * @param fValue Value (e.g. false)\n * @return true if argument gets set, false if it already had a value\n */\nbool SoftSetBoolArg(const std::string& strArg, bool fValue);\n\n/**\n * MWC RNG of George Marsaglia\n * This is intended to be fast. It has a period of 2^59.3, though the\n * least significant 16 bits only have a period of about 2^30.1.\n *\n * @return random value\n */\nextern uint32_t insecure_rand_Rz;\nextern uint32_t insecure_rand_Rw;\nstatic inline uint32_t insecure_rand(void)\n{\n    insecure_rand_Rz = 36969 * (insecure_rand_Rz & 65535) + (insecure_rand_Rz >> 16);\n    insecure_rand_Rw = 18000 * (insecure_rand_Rw & 65535) + (insecure_rand_Rw >> 16);\n    return (insecure_rand_Rw << 16) + insecure_rand_Rz;\n}\n\n/**\n * Seed insecure_rand using the random pool.\n * @param Deterministic Use a determinstic seed\n */\nvoid seed_insecure_rand(bool fDeterministic=false);\n\n/**\n * Timing-attack-resistant comparison.\n * Takes time proportional to length\n * of first argument.\n */\ntemplate <typename T>\nbool TimingResistantEqual(const T& a, const T& b)\n{\n    if (b.size() == 0) return a.size() == 0;\n    size_t accumulator = a.size() ^ b.size();\n    for (size_t i = 0; i < a.size(); i++)\n        accumulator |= a[i] ^ b[i%b.size()];\n    return accumulator == 0;\n}\n\n/** Median filter over a stream of values.\n * Returns the median of the last N numbers\n */\ntemplate <typename T> class CMedianFilter\n{\nprivate:\n    std::vector<T> vValues;\n    std::vector<T> vSorted;\n    unsigned int nSize;\npublic:\n    CMedianFilter(unsigned int size, T initial_value):\n        nSize(size)\n    {\n        vValues.reserve(size);\n        vValues.push_back(initial_value);\n        vSorted = vValues;\n    }\n\n    void input(T value)\n    {\n        if(vValues.size() == nSize)\n        {\n            vValues.erase(vValues.begin());\n        }\n        vValues.push_back(value);\n\n        vSorted.resize(vValues.size());\n        std::copy(vValues.begin(), vValues.end(), vSorted.begin());\n        std::sort(vSorted.begin(), vSorted.end());\n    }\n\n    T median() const\n    {\n        int size = vSorted.size();\n        assert(size>0);\n        if(size & 1) // Odd number of elements\n        {\n            return vSorted[size/2];\n        }\n        else // Even number of elements\n        {\n            return (vSorted[size/2-1] + vSorted[size/2]) / 2;\n        }\n    }\n\n    int size() const\n    {\n        return vValues.size();\n    }\n\n    std::vector<T> sorted () const\n    {\n        return vSorted;\n    }\n};\n\nbool NewThread(void(*pfn)(void*), void* parg);\n\n#ifdef WIN32\ninline void SetThreadPriority(int nPriority)\n{\n    SetThreadPriority(GetCurrentThread(), nPriority);\n}\n#else\n\n#define THREAD_PRIORITY_LOWEST          PRIO_MAX\n#define THREAD_PRIORITY_BELOW_NORMAL    2\n#define THREAD_PRIORITY_NORMAL          0\n#define THREAD_PRIORITY_ABOVE_NORMAL    0\n\ninline void SetThreadPriority(int nPriority)\n{\n    // It's unclear if it's even possible to change thread priorities on Linux,\n    // but we really and truly need it for the generation threads.\n#ifdef PRIO_THREAD\n    setpriority(PRIO_THREAD, 0, nPriority);\n#else\n    setpriority(PRIO_PROCESS, 0, nPriority);\n#endif\n}\n\ninline void ExitThread(size_t nExitCode)\n{\n    pthread_exit((void*)nExitCode);\n}\n#endif\n\nvoid RenameThread(const char* name);\n\ninline uint32_t ByteReverse(uint32_t value)\n{\n    value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);\n    return (value<<16) | (value>>16);\n}\n\n// Standard wrapper for do-something-forever thread functions.\n// \"Forever\" really means until the thread is interrupted.\n// Use it like:\n//   new boost::thread(boost::bind(&LoopForever<void (*)()>, \"dumpaddr\", &DumpAddresses, 900000));\n// or maybe:\n//    boost::function<void()> f = boost::bind(&FunctionWithArg, argument);\n//    threadGroup.create_thread(boost::bind(&LoopForever<boost::function<void()> >, \"nothing\", f, milliseconds));\ntemplate <typename Callable> void LoopForever(const char* name,  Callable func, int64 msecs)\n{\n    std::string s = strprintf(\"bitcoin-%s\", name);\n    RenameThread(s.c_str());\n    printf(\"%s thread start\\n\", name);\n    try\n    {\n        while (1)\n        {\n            MilliSleep(msecs);\n            func();\n        }\n    }\n    catch (boost::thread_interrupted)\n    {\n        printf(\"%s thread stop\\n\", name);\n        throw;\n    }\n    catch (std::exception& e) {\n        PrintException(&e, name);\n    }\n    catch (...) {\n        PrintException(NULL, name);\n    }\n}\n// .. and a wrapper that just calls func once\ntemplate <typename Callable> void TraceThread(const char* name,  Callable func)\n{\n    std::string s = strprintf(\"bitcoin-%s\", name);\n    RenameThread(s.c_str());\n    try\n    {\n        printf(\"%s thread start\\n\", name);\n        func();\n        printf(\"%s thread exit\\n\", name);\n    }\n    catch (boost::thread_interrupted)\n    {\n        printf(\"%s thread interrupt\\n\", name);\n        throw;\n    }\n    catch (std::exception& e) {\n        PrintException(&e, name);\n    }\n    catch (...) {\n        PrintException(NULL, name);\n    }\n}\n\n#endif\n"], "filenames": ["src/bitcoinrpc.cpp", "src/test/util_tests.cpp", "src/util.h"], "buggy_code_start_loc": [482, 325, 435], "buggy_code_end_loc": [483, 325, 435], "fixing_code_start_loc": [482, 326, 436], "fixing_code_end_loc": [483, 337, 451], "type": "CWE-203", "message": "A vulnerability classified as problematic was found in Ziftr primecoin up to 0.8.4rc1. Affected by this vulnerability is the function HTTPAuthorized of the file src/bitcoinrpc.cpp. The manipulation of the argument strUserPass/strRPCUserColonPass leads to observable timing discrepancy. Upgrading to version 0.8.4rc2 is able to address this issue. The name of the patch is cdb3441b5cd2c1bae49fae671dc4a496f7c96322. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-217171.", "other": {"cve": {"id": "CVE-2013-10006", "sourceIdentifier": "cna@vuldb.com", "published": "2023-01-01T17:15:10.090", "lastModified": "2023-01-09T17:50:44.820", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability classified as problematic was found in Ziftr primecoin up to 0.8.4rc1. Affected by this vulnerability is the function HTTPAuthorized of the file src/bitcoinrpc.cpp. The manipulation of the argument strUserPass/strRPCUserColonPass leads to observable timing discrepancy. Upgrading to version 0.8.4rc2 is able to address this issue. The name of the patch is cdb3441b5cd2c1bae49fae671dc4a496f7c96322. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-217171."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:H/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.6, "baseSeverity": "LOW"}, "exploitabilityScore": 1.2, "impactScore": 1.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:H/Au:S/C:P/I:N/A:N", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "HIGH", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 1.4}, "baseSeverity": "LOW", "exploitabilityScore": 2.5, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-203"}]}, {"source": "cna@vuldb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-208"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ziftrshop:primecoin:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.8.4", "matchCriteriaId": "86F6B0D7-6BAD-4448-93C0-11DF4FA2D2DA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ziftrshop:primecoin:0.8.4:rc1:*:*:*:*:*:*", "matchCriteriaId": "84DFA9CF-CEC6-4A4E-9C17-1B4881543DA4"}]}]}], "references": [{"url": "https://github.com/Ziftr/primecoin/commit/cdb3441b5cd2c1bae49fae671dc4a496f7c96322", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Ziftr/primecoin/releases/tag/v0.8.4rc2", "source": "cna@vuldb.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.217171", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.217171", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Ziftr/primecoin/commit/cdb3441b5cd2c1bae49fae671dc4a496f7c96322"}}