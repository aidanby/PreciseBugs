{"buggy_code": ["<?php\n\n/**\n * ---------------------------------------------------------------------\n *\n * GLPI - Gestionnaire Libre de Parc Informatique\n *\n * http://glpi-project.org\n *\n * @copyright 2015-2022 Teclib' and contributors.\n * @copyright 2003-2014 by the INDEPNET Development Team.\n * @licence   https://www.gnu.org/licenses/gpl-3.0.html\n *\n * ---------------------------------------------------------------------\n *\n * LICENSE\n *\n * This file is part of GLPI.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n * ---------------------------------------------------------------------\n */\n\nuse Glpi\\Application\\ErrorHandler;\nuse Glpi\\Event;\nuse Glpi\\Plugin\\Hooks;\nuse Glpi\\Toolbox\\Sanitizer;\n\n/**\n *  Identification class used to login\n */\nclass Auth extends CommonGLPI\n{\n    /** @var array Array of errors */\n    private $errors = [];\n    /** @var User User class variable */\n    public $user;\n    /** @var int External authentication variable */\n    public $extauth = 0;\n    /** @var array External authentication methods */\n    public $authtypes;\n    /** @var int Indicates if the user is authenticated or not */\n    public $auth_succeded = 0;\n    /** @var int Indicates if the user is already present in database */\n    public $user_present = 0;\n    /** @var int Indicates if the user password expired */\n    public $password_expired = false;\n\n    /**\n     * Indicated if user was found in the directory.\n     * @var boolean\n     */\n    public $user_found = false;\n\n    /** @var resource|boolean LDAP connection descriptor */\n    public $ldap_connection;\n    /** @var bool Store user LDAP dn */\n    public $user_dn = false;\n\n    const DB_GLPI  = 1;\n    const MAIL     = 2;\n    const LDAP     = 3;\n    const EXTERNAL = 4;\n    const CAS      = 5;\n    const X509     = 6;\n    const API      = 7;\n    const COOKIE   = 8;\n    const NOT_YET_AUTHENTIFIED = 0;\n\n    const USER_DOESNT_EXIST       = 0;\n    const USER_EXISTS_WITH_PWD    = 1;\n    const USER_EXISTS_WITHOUT_PWD = 2;\n\n    /**\n     * Constructor\n     *\n     * @return void\n     */\n    public function __construct()\n    {\n        $this->user = new User();\n    }\n\n\n    public static function getMenuContent()\n    {\n\n        $menu = [];\n        if (Config::canUpdate()) {\n            $menu['title']                              = __('Authentication');\n            $menu['page']                               = '/front/setup.auth.php';\n            $menu['icon']                               = self::getIcon();\n\n            $menu['options']['ldap']['icon']            = AuthLDAP::getIcon();\n            $menu['options']['ldap']['title']           = AuthLDAP::getTypeName(Session::getPluralNumber());\n            $menu['options']['ldap']['page']            = AuthLDAP::getSearchURL(false);\n            $menu['options']['ldap']['links']['search'] = AuthLDAP::getSearchURL(false);\n            $menu['options']['ldap']['links']['add']    = AuthLDAP::getFormURL(false);\n\n            $menu['options']['imap']['icon']            = AuthMail::getIcon();\n            $menu['options']['imap']['title']           = AuthMail::getTypeName(Session::getPluralNumber());\n            $menu['options']['imap']['page']            = AuthMail::getSearchURL(false);\n            $menu['options']['imap']['links']['search'] = AuthMail::getSearchURL(false);\n            $menu['options']['imap']['links']['add']    = AuthMail::getFormURL(false);\n\n            $menu['options']['others']['icon']          = 'ti ti-login';\n            $menu['options']['others']['title']         = __('Others');\n            $menu['options']['others']['page']          = '/front/auth.others.php';\n\n            $menu['options']['settings']['icon']        = 'ti ti-adjustments';\n            $menu['options']['settings']['title']       = __('Setup');\n            $menu['options']['settings']['page']        = '/front/auth.settings.php';\n        }\n        if (count($menu)) {\n            return $menu;\n        }\n        return false;\n    }\n\n    /**\n     * Check user existence in DB\n     *\n     * @global DBmysql $DB\n     * @param  array   $options conditions : array('name'=>'glpi')\n     *                                    or array('email' => 'test at test.com')\n     *\n     * @return integer {@link Auth::USER_DOESNT_EXIST}, {@link Auth::USER_EXISTS_WITHOUT_PWD} or {@link Auth::USER_EXISTS_WITH_PWD}\n     */\n    public function userExists($options = [])\n    {\n        global $DB;\n\n        $result = $DB->request(\n            'glpi_users',\n            ['WHERE'    => $options,\n                'LEFT JOIN' => ['glpi_useremails' => ['FKEY' => ['glpi_users'      => 'id',\n                    'glpi_useremails' => 'users_id'\n                ]\n                ]\n                ]\n            ]\n        );\n       // Check if there is a row\n        if ($result->numrows() == 0) {\n            $this->addToError(__('Incorrect username or password'));\n            return self::USER_DOESNT_EXIST;\n        } else {\n           // Get the first result...\n            $row = $result->current();\n\n           // Check if we have a password...\n            if (empty($row['password'])) {\n                //If the user has an LDAP DN, then store it in the Auth object\n                if ($row['user_dn']) {\n                    $this->user_dn = $row['user_dn'];\n                }\n                return self::USER_EXISTS_WITHOUT_PWD;\n            }\n            return self::USER_EXISTS_WITH_PWD;\n        }\n    }\n\n    /**\n     * Try a IMAP/POP connection\n     *\n     * @param string $host  IMAP/POP host to connect\n     * @param string $login Login to try\n     * @param string $pass  Password to try\n     *\n     * @return boolean connection success\n     */\n    public function connection_imap($host, $login, $pass)\n    {\n\n       // we prevent some delay...\n        if (empty($host)) {\n            return false;\n        }\n\n        $oldlevel = error_reporting(16);\n       // No retry (avoid lock account when password is not correct)\n        try {\n            $config = Toolbox::parseMailServerConnectString($host);\n\n            $ssl = false;\n            if ($config['ssl']) {\n                $ssl = 'SSL';\n            }\n            if ($config['tls']) {\n                $ssl = 'TLS';\n            }\n\n            $protocol = Toolbox::getMailServerProtocolInstance($config['type']);\n            if ($protocol === null) {\n                throw new \\RuntimeException(sprintf(__('Unsupported mail server type:%s.'), $config['type']));\n            }\n            if ($config['validate-cert'] === false) {\n                $protocol->setNoValidateCert(true);\n            }\n            $protocol->connect(\n                $config['address'],\n                $config['port'],\n                $ssl\n            );\n\n            return $protocol->login($login, $pass);\n        } catch (\\Exception $e) {\n            $this->addToError($e->getMessage());\n            return false;\n        } finally {\n            error_reporting($oldlevel);\n        }\n\n        return false;\n    }\n\n    /**\n     * Find a user in a LDAP and return is BaseDN\n     * Based on GRR auth system\n     *\n     * @param string $ldap_method ldap_method array to use\n     * @param string $login       User Login\n     * @param string $password    User Password\n     *\n     * @return string basedn of the user / false if not founded\n     */\n    public function connection_ldap($ldap_method, $login, $password)\n    {\n\n       // we prevent some delay...\n        if (empty($ldap_method['host'])) {\n            return false;\n        }\n\n        $this->ldap_connection   = AuthLDAP::tryToConnectToServer($ldap_method, $login, $password);\n        $this->user_found = false;\n\n        if ($this->ldap_connection) {\n            $params = [\n                'method' => AuthLDAP::IDENTIFIER_LOGIN,\n                'fields' => [\n                    AuthLDAP::IDENTIFIER_LOGIN => $ldap_method['login_field'],\n                ],\n            ];\n            if (!empty($ldap_method['sync_field'])) {\n                $params['fields']['sync_field'] = $ldap_method['sync_field'];\n            }\n            try {\n                $infos = AuthLDAP::searchUserDn($this->ldap_connection, [\n                    'basedn'            => $ldap_method['basedn'],\n                    'login_field'       => $ldap_method['login_field'],\n                    'search_parameters' => $params,\n                    'user_params'       => [\n                        'method' => AuthLDAP::IDENTIFIER_LOGIN,\n                        'value'  => $login\n                    ],\n                    'condition'         => Sanitizer::unsanitize($ldap_method['condition']),\n                    'user_dn'           => $this->user_dn\n                ]);\n            } catch (\\Throwable $e) {\n                ErrorHandler::getInstance()->handleException($e, true);\n                $this->addToError(__('Unable to connect to the LDAP directory'));\n                return false;\n            }\n\n            $dn = $infos['dn'];\n            $this->user_found = $dn != '';\n            if ($this->user_found && @ldap_bind($this->ldap_connection, $dn, $password)) {\n               //Hook to implement to restrict access by checking the ldap directory\n                if (Plugin::doHookFunction(Hooks::RESTRICT_LDAP_AUTH, $infos)) {\n                    return $infos;\n                }\n                $this->addToError(__('User not authorized to connect in GLPI'));\n               //Use is present by has no right to connect because of a plugin\n                return false;\n            } else {\n               // Incorrect login\n                $this->addToError(__('Incorrect username or password'));\n               //Use is not present anymore in the directory!\n                return false;\n            }\n        } else {\n            $this->addToError(__('Unable to connect to the LDAP directory'));\n           //Directory is not available\n            return false;\n        }\n    }\n\n    /**\n     * Check is a password match the stored hash\n     *\n     * @since 0.85\n     *\n     * @param string $pass Password (pain-text)\n     * @param string $hash Hash\n     *\n     * @return boolean\n     */\n    public static function checkPassword($pass, $hash)\n    {\n\n        $tmp = password_get_info($hash);\n\n        if (isset($tmp['algo']) && $tmp['algo']) {\n            $ok = password_verify($pass, $hash);\n        } else if (strlen($hash) == 32) {\n            $ok = md5($pass) === $hash;\n        } else if (strlen($hash) == 40) {\n            $ok = sha1($pass) === $hash;\n        } else {\n            $salt = substr($hash, 0, 8);\n            $ok = ($salt . sha1($salt . $pass) === $hash);\n        }\n\n        return $ok;\n    }\n\n    /**\n     * Is the hash stored need to be regenerated\n     *\n     * @since 0.85\n     *\n     * @param string $hash Hash\n     *\n     * @return boolean\n     */\n    public static function needRehash($hash)\n    {\n\n        return password_needs_rehash($hash, PASSWORD_DEFAULT);\n    }\n\n    /**\n     * Compute the hash for a password\n     *\n     * @since 0.85\n     *\n     * @param string $pass Password\n     *\n     * @return string\n     */\n    public static function getPasswordHash($pass)\n    {\n\n        return password_hash($pass, PASSWORD_DEFAULT);\n    }\n\n    /**\n     * Find a user in the GLPI DB\n     *\n     * try to connect to DB\n     * update the instance variable user with the user who has the name $name\n     * and the password is $password in the DB.\n     * If not found or can't connect to DB updates the instance variable err\n     * with an eventual error message\n     *\n     * @global DBmysql $DB\n     * @param string $name     User Login\n     * @param string $password User Password\n     *\n     * @return boolean user in GLPI DB with the right password\n     */\n    public function connection_db($name, $password)\n    {\n        global $CFG_GLPI, $DB;\n\n        $pass_expiration_delay = (int)$CFG_GLPI['password_expiration_delay'];\n        $lock_delay            = (int)$CFG_GLPI['password_expiration_lock_delay'];\n\n       // SQL query\n        $result = $DB->request(\n            [\n                'SELECT' => [\n                    'id',\n                    'password',\n                    new QueryExpression(\n                        sprintf(\n                            'ADDDATE(%s, INTERVAL %d DAY) AS ' . $DB->quoteName('password_expiration_date'),\n                            $DB->quoteName('password_last_update'),\n                            $pass_expiration_delay\n                        )\n                    ),\n                    new QueryExpression(\n                        sprintf(\n                            'ADDDATE(%s, INTERVAL %d DAY) AS ' . $DB->quoteName('lock_date'),\n                            $DB->quoteName('password_last_update'),\n                            $pass_expiration_delay + $lock_delay\n                        )\n                    )\n                ],\n                'FROM'   => User::getTable(),\n                'WHERE'  =>  [\n                    'name'     => $name,\n                    'authtype' => self::DB_GLPI,\n                    'auths_id' => 0,\n                ]\n            ]\n        );\n\n       // Have we a result ?\n        if ($result->numrows() == 1) {\n            $row = $result->current();\n            $password_db = $row['password'];\n\n            if (self::checkPassword($password, $password_db)) {\n               // Disable account if password expired\n                if (\n                    -1 !== $pass_expiration_delay && -1 !== $lock_delay\n                    && $row['lock_date'] < $_SESSION['glpi_currenttime']\n                ) {\n                    $user = new User();\n                    $user->update(\n                        [\n                            'id'        => $row['id'],\n                            'is_active' => 0,\n                        ]\n                    );\n                }\n                if (\n                    -1 !== $pass_expiration_delay\n                    && $row['password_expiration_date'] < $_SESSION['glpi_currenttime']\n                ) {\n                    $this->password_expired = 1;\n                }\n\n               // Update password if needed\n                if (self::needRehash($password_db)) {\n                    $input = [\n                        'id' => $row['id'],\n                    ];\n                 // Set glpiID to allow password update\n                    $_SESSION['glpiID'] = $input['id'];\n                    $input['password'] = $password;\n                    $input['password2'] = $password;\n                    $user = new User();\n                    $user->update($input);\n                }\n                $this->user->getFromDBByCrit(['id' => $row['id']]);\n                $this->extauth                  = 0;\n                $this->user_present             = 1;\n                $this->user->fields[\"authtype\"] = self::DB_GLPI;\n                $this->user->fields[\"password\"] = $password;\n\n             // apply rule rights on local user\n                $rules  = new RuleRightCollection();\n                $groups = Group_User::getUserGroups($row['id']);\n                $groups_id = array_column($groups, 'id');\n                $result = $rules->processAllRules(\n                    $groups_id,\n                    $this->user->fields,\n                    [\n                        'type'  => Auth::DB_GLPI,\n                        'login' => $this->user->fields['name'],\n                        'email' => UserEmail::getDefaultForUser($row['id'])\n                    ]\n                );\n\n                $this->user->fields = $result + [\n                    '_ruleright_process' => true,\n                ];\n\n                return true;\n            }\n        }\n        $this->addToError(__('Incorrect username or password'));\n        return false;\n    }\n\n    /**\n     * Try to get login of external auth method\n     *\n     * @param integer $authtype external auth type (default 0)\n     *\n     * @return boolean user login success\n     */\n    public function getAlternateAuthSystemsUserLogin($authtype = 0)\n    {\n        global $CFG_GLPI;\n\n        switch ($authtype) {\n            case self::CAS:\n                if (!Toolbox::canUseCAS()) {\n                    trigger_error(\"CAS lib not installed\", E_USER_WARNING);\n                    return false;\n                }\n\n                phpCAS::client(\n                    constant($CFG_GLPI[\"cas_version\"]),\n                    $CFG_GLPI[\"cas_host\"],\n                    intval($CFG_GLPI[\"cas_port\"]),\n                    $CFG_GLPI[\"cas_uri\"],\n                    false\n                );\n\n                // no SSL validation for the CAS server\n                phpCAS::setNoCasServerValidation();\n\n                // force CAS authentication\n                phpCAS::forceAuthentication();\n                $this->user->fields['name'] = phpCAS::getUser();\n\n                // extract e-mail information\n                if (phpCAS::hasAttribute(\"mail\")) {\n                      $this->user->fields['_useremails'] = [phpCAS::getAttribute(\"mail\")];\n                }\n\n                return true;\n\n            case self::EXTERNAL:\n                $ssovariable = Dropdown::getDropdownName(\n                    'glpi_ssovariables',\n                    $CFG_GLPI[\"ssovariables_id\"]\n                );\n                $login_string = '';\n               // MoYo : checking REQUEST create a security hole for me !\n                if (isset($_SERVER[$ssovariable])) {\n                      $login_string = $_SERVER[$ssovariable];\n                }\n               // else {\n               //    $login_string = $_REQUEST[$ssovariable];\n               // }\n                $login        = $login_string;\n                $pos          = stripos($login_string, \"\\\\\");\n                if (!$pos === false) {\n                    $login = substr($login_string, $pos + 1);\n                }\n                if ($CFG_GLPI['existing_auth_server_field_clean_domain']) {\n                    $pos = stripos($login, \"@\");\n                    if (!$pos === false) {\n                        $login = substr($login, 0, $pos);\n                    }\n                }\n                if (self::isValidLogin($login)) {\n                    $this->user->fields['name'] = $login;\n                   // Get data from SSO if defined\n                    $ret = $this->user->getFromSSO();\n                    if (!$ret) {\n                        return false;\n                    }\n                    return true;\n                }\n                break;\n\n            case self::X509:\n               // From eGroupWare  http://www.egroupware.org\n               // an X.509 subject looks like:\n               // CN=john.doe/OU=Department/O=Company/C=xx/Email=john@comapy.tld/L=City/\n                $sslattribs = explode('/', $_SERVER['SSL_CLIENT_S_DN']);\n                $sslattributes = [];\n                while ($sslattrib = next($sslattribs)) {\n                    list($key,$val)      = explode('=', $sslattrib);\n                    $sslattributes[$key] = $val;\n                }\n                if (\n                    isset($sslattributes[$CFG_GLPI[\"x509_email_field\"]])\n                    && NotificationMailing::isUserAddressValid($sslattributes[$CFG_GLPI[\"x509_email_field\"]])\n                    && self::isValidLogin($sslattributes[$CFG_GLPI[\"x509_email_field\"]])\n                ) {\n                    $restrict = false;\n                    $CFG_GLPI[\"x509_ou_restrict\"] = trim($CFG_GLPI[\"x509_ou_restrict\"]);\n                    if (!empty($CFG_GLPI[\"x509_ou_restrict\"])) {\n                        $split = explode('$', $CFG_GLPI[\"x509_ou_restrict\"]);\n\n                        if (!in_array($sslattributes['OU'], $split)) {\n                            $restrict = true;\n                        }\n                    }\n                    $CFG_GLPI[\"x509_o_restrict\"] = trim($CFG_GLPI[\"x509_o_restrict\"]);\n                    if (!empty($CFG_GLPI[\"x509_o_restrict\"])) {\n                        $split = explode('$', $CFG_GLPI[\"x509_o_restrict\"]);\n\n                        if (!in_array($sslattributes['O'], $split)) {\n                            $restrict = true;\n                        }\n                    }\n                    $CFG_GLPI[\"x509_cn_restrict\"] = trim($CFG_GLPI[\"x509_cn_restrict\"]);\n                    if (!empty($CFG_GLPI[\"x509_cn_restrict\"])) {\n                        $split = explode('$', $CFG_GLPI[\"x509_cn_restrict\"]);\n\n                        if (!in_array($sslattributes['CN'], $split)) {\n                            $restrict = true;\n                        }\n                    }\n\n                    if (!$restrict) {\n                        $this->user->fields['name'] = $sslattributes[$CFG_GLPI[\"x509_email_field\"]];\n\n                       // Can do other things if need : only add it here\n                        $this->user->fields['email'] = $this->user->fields['name'];\n                        return true;\n                    }\n                }\n                break;\n\n            case self::API:\n                if ($CFG_GLPI['enable_api_login_external_token']) {\n                    $user = new User();\n                    if ($user->getFromDBbyToken($_REQUEST['user_token'], 'api_token')) {\n                        $this->user->fields['name'] = $user->fields['name'];\n                        return true;\n                    }\n                } else {\n                    $this->addToError(__(\"Login with external token disabled\"));\n                }\n                break;\n            case self::COOKIE:\n                $cookie_name   = session_name() . '_rememberme';\n\n                if ($CFG_GLPI[\"login_remember_time\"]) {\n                    $data = json_decode($_COOKIE[$cookie_name], true);\n                    if (count($data) === 2) {\n                        list ($cookie_id, $cookie_token) = $data;\n\n                        $user = new User();\n                        $user->getFromDB($cookie_id);\n                        $hash = $user->getAuthToken('cookie_token');\n\n                        if (Auth::checkPassword($cookie_token, $hash)) {\n                            $this->user->fields['name'] = $user->fields['name'];\n                            return true;\n                        } else {\n                            $this->addToError(__(\"Invalid cookie data\"));\n                        }\n                    }\n                } else {\n                    $this->addToError(__(\"Auto login disabled\"));\n                }\n\n               //Remove cookie to allow new login\n                Auth::setRememberMeCookie('');\n                break;\n        }\n        return false;\n    }\n\n    /**\n     * Get the current identification error\n     *\n     * @return string current identification error\n     */\n    public function getErr()\n    {\n        return implode(\"<br>\\n\", $this->getErrors());\n    }\n\n    /**\n     * Get errors\n     *\n     * @since 9.4\n     *\n     * @return array\n     */\n    public function getErrors()\n    {\n        return $this->errors;\n    }\n\n    /**\n     * Get the current user object\n     *\n     * @return object current user\n     */\n    public function getUser()\n    {\n        return $this->user;\n    }\n\n    /**\n     * Get all the authentication methods parameters\n     * and return it as an array\n     *\n     * @return void\n     */\n    public function getAuthMethods()\n    {\n\n       //Return all the authentication methods in an array\n        $this->authtypes = [\n            'ldap' => getAllDataFromTable('glpi_authldaps'),\n            'mail' => getAllDataFromTable('glpi_authmails')\n        ];\n    }\n\n    /**\n     * Add a message to the global identification error message\n     *\n     * @param string $message the message to add\n     *\n     * @return void\n     */\n    public function addToError($message)\n    {\n        if (!in_array($message, $this->errors)) {\n            $this->errors[] = $message;\n        }\n    }\n\n    /**\n     * Manage use authentication and initialize the session\n     *\n     * @param string  $login_name      Login\n     * @param string  $login_password  Password\n     * @param boolean $noauto          (false by default)\n     * @param bool    $remember_me\n     * @param string  $login_auth      Type of auth - id of the auth\n     *\n     * @return boolean (success)\n     */\n    public function login($login_name, $login_password, $noauto = false, $remember_me = false, $login_auth = '')\n    {\n        global $DB, $CFG_GLPI;\n\n        $this->getAuthMethods();\n        $this->user_present  = 1;\n        $this->auth_succeded = false;\n       //In case the user was deleted in the LDAP directory\n        $user_deleted_ldap   = false;\n\n       // Trim login_name : avoid LDAP search errors\n        $login_name = trim($login_name);\n\n       // manage the $login_auth (force the auth source of the user account)\n        $this->user->fields[\"auths_id\"] = 0;\n        if ($login_auth == 'local') {\n            $authtype = self::DB_GLPI;\n            $this->user->fields[\"authtype\"] = self::DB_GLPI;\n        } else if (strstr($login_auth, '-')) {\n            $auths = explode('-', $login_auth);\n            $this->user->fields[\"auths_id\"] = $auths[1];\n            if ($auths[0] == 'ldap') {\n                $authtype = self::LDAP;\n                $this->user->fields[\"authtype\"] = self::LDAP;\n            } else if ($auths[0] == 'mail') {\n                $authtype = self::MAIL;\n                $this->user->fields[\"authtype\"] = self::MAIL;\n            } else if ($auths[0] == 'external') {\n                $authtype = self::EXTERNAL;\n                $this->user->fields[\"authtype\"] = self::EXTERNAL;\n            }\n        }\n        if (!$noauto && ($authtype = self::checkAlternateAuthSystems())) {\n            if (\n                $this->getAlternateAuthSystemsUserLogin($authtype)\n                && !empty($this->user->fields['name'])\n            ) {\n               // Used for log when login process failed\n                $login_name                        = $this->user->fields['name'];\n                $this->auth_succeded               = true;\n                $this->user_present                = $this->user->getFromDBbyName(addslashes($login_name));\n                $this->extauth                     = 1;\n                $user_dn                           = false;\n\n                if (array_key_exists('_useremails', $this->user->fields)) {\n                    $email = $this->user->fields['_useremails'];\n                }\n\n                $ldapservers = [];\n               //if LDAP enabled too, get user's infos from LDAP\n                if (Toolbox::canUseLdap()) {\n                   //User has already authenticate, at least once : it's ldap server if filled\n                    if (\n                        isset($this->user->fields[\"auths_id\"])\n                        && ($this->user->fields[\"auths_id\"] > 0)\n                    ) {\n                        $authldap = new AuthLDAP();\n                       //If ldap server is enabled\n                        if (\n                            $authldap->getFromDB($this->user->fields[\"auths_id\"])\n                            && $authldap->fields['is_active']\n                        ) {\n                            $ldapservers[] = $authldap->fields;\n                        }\n                    } else { // User has never been authenticated : try all active ldap server to find the right one\n                        foreach (getAllDataFromTable('glpi_authldaps', ['is_active' => 1]) as $ldap_config) {\n                            $ldapservers[] = $ldap_config;\n                        }\n                    }\n\n                    $ldapservers_status = false;\n                    foreach ($ldapservers as $ldap_method) {\n                        $ds = AuthLDAP::connectToServer(\n                            $ldap_method[\"host\"],\n                            $ldap_method[\"port\"],\n                            $ldap_method[\"rootdn\"],\n                            (new GLPIKey())->decrypt($ldap_method[\"rootdn_passwd\"]),\n                            $ldap_method[\"use_tls\"],\n                            $ldap_method[\"deref_option\"],\n                            $ldap_method[\"tls_certfile\"],\n                            $ldap_method[\"tls_keyfile\"],\n                            $ldap_method[\"use_bind\"],\n                            $ldap_method[\"timeout\"]\n                        );\n\n                        if ($ds) {\n                             $ldapservers_status = true;\n                             $params = [\n                                 'method' => AuthLDAP::IDENTIFIER_LOGIN,\n                                 'fields' => [\n                                     AuthLDAP::IDENTIFIER_LOGIN => $ldap_method[\"login_field\"],\n                                 ],\n                             ];\n                             try {\n                                 $user_dn = AuthLDAP::searchUserDn($ds, [\n                                     'basedn'            => $ldap_method[\"basedn\"],\n                                     'login_field'       => $ldap_method['login_field'],\n                                     'search_parameters' => $params,\n                                     'condition'         => $ldap_method[\"condition\"],\n                                     'user_params'       => [\n                                         'method' => AuthLDAP::IDENTIFIER_LOGIN,\n                                         'value'  => $login_name\n                                     ],\n                                 ]);\n                             } catch (\\RuntimeException $e) {\n                                 ErrorHandler::getInstance()->handleException($e, true);\n                                 $user_dn = false;\n                             }\n                             if ($user_dn) {\n                                 $this->user_found = true;\n                                 $this->user->fields['auths_id'] = $ldap_method['id'];\n                                 $this->user->getFromLDAP(\n                                     $ds,\n                                     $ldap_method,\n                                     $user_dn['dn'],\n                                     $login_name,\n                                     !$this->user_present\n                                 );\n                                 break;\n                             }\n                        }\n                    }\n                }\n                if (\n                    (count($ldapservers) == 0)\n                    && ($authtype == self::EXTERNAL)\n                ) {\n                   // Case of using external auth and no LDAP servers, so get data from external auth\n                    $this->user->getFromSSO();\n                } else {\n                    if ($this->user->fields['authtype'] == self::LDAP) {\n                        if (!$ldapservers_status) {\n                             $this->auth_succeded = false;\n                             $this->addToError(_n(\n                                 'Connection to LDAP directory failed',\n                                 'Connection to LDAP directories failed',\n                                 count($ldapservers)\n                             ));\n                        } else if (!$user_dn && $this->user_present) {\n                           //If user is set as present in GLPI but no LDAP DN found : it means that the user\n                           //is not present in an ldap directory anymore\n                            $user_deleted_ldap = true;\n                            $this->addToError(_n(\n                                'User not found in LDAP directory',\n                                'User not found in LDAP directories',\n                                count($ldapservers)\n                            ));\n                        }\n                    }\n                }\n               // Reset to secure it\n                $this->user->fields['name']       = $login_name;\n                $this->user->fields[\"last_login\"] = $_SESSION[\"glpi_currenttime\"];\n            } else {\n                $this->addToError(__('Empty login or password'));\n            }\n        }\n\n        if (!$this->auth_succeded) {\n            if (\n                empty($login_name) || strstr($login_name, \"\\0\")\n                || empty($login_password) || strstr($login_password, \"\\0\")\n            ) {\n                $this->addToError(__('Empty login or password'));\n            } else {\n               // Try connect local user if not yet authenticated\n                if (\n                    empty($login_auth)\n                    || $this->user->fields[\"authtype\"] == $this::DB_GLPI\n                ) {\n                    $this->auth_succeded = $this->connection_db(\n                        addslashes($login_name),\n                        $login_password\n                    );\n                }\n\n               // Try to connect LDAP user if not yet authenticated\n                if (!$this->auth_succeded) {\n                    if (\n                        empty($login_auth)\n                        || $this->user->fields[\"authtype\"] == $this::CAS\n                        || $this->user->fields[\"authtype\"] == $this::EXTERNAL\n                        || $this->user->fields[\"authtype\"] == $this::LDAP\n                    ) {\n                        if (Toolbox::canUseLdap()) {\n                            AuthLDAP::tryLdapAuth(\n                                $this,\n                                $login_name,\n                                $login_password,\n                                $this->user->fields[\"auths_id\"]\n                            );\n                            if ($this->ldap_connection !== false && (!$this->auth_succeded && !$this->user_found)) {\n                                 $search_params = [\n                                     'name'     => addslashes($login_name),\n                                     'authtype' => $this::LDAP\n                                 ];\n                                 if (!empty($login_auth)) {\n                                     $search_params['auths_id'] = $this->user->fields[\"auths_id\"];\n                                 }\n                                 if ($this->user->getFromDBByCrit($search_params)) {\n                                     $user_deleted_ldap = true;\n                                 };\n                            }\n                        }\n                    }\n                }\n\n               // Try connect MAIL server if not yet authenticated\n                if (!$this->auth_succeded) {\n                    if (\n                        empty($login_auth)\n                        || $this->user->fields[\"authtype\"] == $this::MAIL\n                    ) {\n                        AuthMail::tryMailAuth(\n                            $this,\n                            $login_name,\n                            $login_password,\n                            $this->user->fields[\"auths_id\"]\n                        );\n                    }\n                }\n            }\n        }\n\n        if ($user_deleted_ldap) {\n            User::manageDeletedUserInLdap($this->user->fields[\"id\"]);\n            $this->auth_succeded = false;\n        }\n       // Ok, we have gathered sufficient data, if the first return false the user\n       // is not present on the DB, so we add him.\n       // if not, we update him.\n        if ($this->auth_succeded) {\n           //Set user an not deleted from LDAP\n            $this->user->fields['is_deleted_ldap'] = 0;\n\n           // Prepare data\n            $this->user->fields[\"last_login\"] = $_SESSION[\"glpi_currenttime\"];\n            if ($this->extauth) {\n                $this->user->fields[\"_extauth\"] = 1;\n            }\n\n            if ($DB->isSlave()) {\n                if (!$this->user_present) { // Can't add in slave mode\n                    $this->addToError(__('User not authorized to connect in GLPI'));\n                    $this->auth_succeded = false;\n                }\n            } else {\n                if ($this->user_present) {\n                   // Add the user e-mail if present\n                    if (isset($email)) {\n                         $this->user->fields['_useremails'] = $email;\n                    }\n                    $this->user->update(Sanitizer::sanitize($this->user->fields));\n                } else if ($CFG_GLPI[\"is_users_auto_add\"]) {\n                   // Auto add user\n                    $input = $this->user->fields;\n                    unset($this->user->fields);\n                    if ($authtype == self::EXTERNAL && !isset($input[\"authtype\"])) {\n                        $input[\"authtype\"] = $authtype;\n                    }\n                    $this->user->add(Sanitizer::sanitize($input));\n                } else {\n                   // Auto add not enable so auth failed\n                    $this->addToError(__('User not authorized to connect in GLPI'));\n                    $this->auth_succeded = false;\n                }\n            }\n        }\n\n       // Log Event (if possible)\n        if (!$DB->isSlave()) {\n           // GET THE IP OF THE CLIENT\n            $ip = getenv(\"HTTP_X_FORWARDED_FOR\") ?\n            Sanitizer::encodeHtmlSpecialChars(getenv(\"HTTP_X_FORWARDED_FOR\")) :\n            getenv(\"REMOTE_ADDR\");\n\n            if ($this->auth_succeded) {\n                if (GLPI_DEMO_MODE) {\n                    // not translation in GLPI_DEMO_MODE\n                    Event::log(0, \"system\", 3, \"login\", $login_name . \" log in from \" . $ip);\n                } else {\n                   //TRANS: %1$s is the login of the user and %2$s its IP address\n                    Event::log(0, \"system\", 3, \"login\", sprintf(\n                        __('%1$s log in from IP %2$s'),\n                        $login_name,\n                        $ip\n                    ));\n                }\n            } else {\n                if (GLPI_DEMO_MODE) {\n                    Event::log(\n                        0,\n                        \"system\",\n                        3,\n                        \"login\",\n                        \"login\",\n                        \"Connection failed for \" . $login_name . \" ($ip)\"\n                    );\n                } else {\n                   //TRANS: %1$s is the login of the user and %2$s its IP address\n                    Event::log(0, \"system\", 3, \"login\", sprintf(\n                        __('Failed login for %1$s from IP %2$s'),\n                        $login_name,\n                        $ip\n                    ));\n                }\n            }\n        }\n\n        Session::init($this);\n\n        if ($noauto) {\n            $_SESSION[\"noAUTO\"] = 1;\n        }\n\n        if ($this->auth_succeded && $CFG_GLPI['login_remember_time'] > 0 && $remember_me) {\n            $token = $this->user->getAuthToken('cookie_token', true);\n\n            if ($token) {\n                $data = json_encode([\n                    $this->user->fields['id'],\n                    $token,\n                ]);\n\n               //Send cookie to browser\n                Auth::setRememberMeCookie($data);\n            }\n        }\n\n        if ($this->auth_succeded && !empty($this->user->fields['timezone']) && 'null' !== strtolower($this->user->fields['timezone'])) {\n           //set user timezone, if any\n            $_SESSION['glpi_tz'] = $this->user->fields['timezone'];\n            $DB->setTimezone($this->user->fields['timezone']);\n        }\n\n        return $this->auth_succeded;\n    }\n\n    /**\n     * Print all the authentication methods\n     *\n     * @param array $options Possible options:\n     * - name : Name of the select (default is auths_id)\n     * - value : Selected value (default 0)\n     * - display : If true, the dropdown is displayed instead of returned (default true)\n     * - display_emptychoice : If true, an empty option is added (default true)\n     * - hide_if_no_elements  : boolean / hide dropdown if there is no elements (default false)\n     *\n     * @return void|string (Based on 'display' option)\n     */\n    public static function dropdown($options = [])\n    {\n        global $DB;\n\n        $p = [\n            'name'                => 'auths_id',\n            'value'               => 0,\n            'display'             => true,\n            'display_emptychoice' => true,\n            'hide_if_no_elements' => false,\n        ];\n\n        if (is_array($options) && count($options)) {\n            foreach ($options as $key => $val) {\n                $p[$key] = $val;\n            }\n        }\n\n        $methods = [\n            self::DB_GLPI => __('Authentication on GLPI database'),\n        ];\n\n        $result = $DB->request([\n            'FROM'   => 'glpi_authldaps',\n            'COUNT'  => 'cpt',\n            'WHERE'  => [\n                'is_active' => 1\n            ]\n        ])->current();\n\n        if ($result['cpt'] > 0) {\n            $methods[self::LDAP]     = __('Authentication on a LDAP directory');\n            $methods[self::EXTERNAL] = __('External authentications');\n        }\n\n        $result = $DB->request([\n            'FROM'   => 'glpi_authmails',\n            'COUNT'  => 'cpt',\n            'WHERE'  => [\n                'is_active' => 1\n            ]\n        ])->current();\n\n        if ($result['cpt'] > 0) {\n            $methods[self::MAIL] = __('Authentication on mail server');\n        }\n\n        return Dropdown::showFromArray($p['name'], $methods, $p);\n    }\n\n    /**\n     * Builds CAS versions dropdown\n     * @param string $value (default 'CAS_VERSION_2_0')\n     *\n     * @return string\n     */\n    public static function dropdownCasVersion($value = 'CAS_VERSION_2_0')\n    {\n        $options['CAS_VERSION_1_0'] = __('Version 1');\n        $options['CAS_VERSION_2_0'] = __('Version 2');\n        $options['CAS_VERSION_3_0'] = __('Version 3+');\n        return Dropdown::showFromArray('cas_version', $options, ['value' => $value]);\n    }\n\n    /**\n     * Get name of an authentication method\n     *\n     * @param integer $authtype Authentication method\n     * @param integer $auths_id Authentication method ID\n     * @param integer $link     show links to config page? (default 0)\n     * @param string  $name     override the name if not empty (default '')\n     *\n     * @return string\n     */\n    public static function getMethodName($authtype, $auths_id, $link = 0, $name = '')\n    {\n\n        switch ($authtype) {\n            case self::LDAP:\n                $auth = new AuthLDAP();\n                if ($auth->getFromDB($auths_id)) {\n                   //TRANS: %1$s is the auth method type, %2$s the auth method name or link\n                    return sprintf(__('%1$s: %2$s'), AuthLDAP::getTypeName(1), $auth->getLink());\n                }\n                return sprintf(__('%1$s: %2$s'), AuthLDAP::getTypeName(1), $name);\n\n            case self::MAIL:\n                $auth = new AuthMail();\n                if ($auth->getFromDB($auths_id)) {\n                    //TRANS: %1$s is the auth method type, %2$s the auth method name or link\n                    return sprintf(__('%1$s: %2$s'), AuthLDAP::getTypeName(1), $auth->getLink());\n                }\n                return sprintf(__('%1$s: %2$s'), __('Email server'), $name);\n\n            case self::CAS:\n                if ($auths_id > 0) {\n                    $auth = new AuthLDAP();\n                    if ($auth->getFromDB($auths_id)) {\n                        return sprintf(\n                            __('%1$s: %2$s'),\n                            sprintf(\n                                __('%1$s + %2$s'),\n                                __('CAS'),\n                                AuthLDAP::getTypeName(1)\n                            ),\n                            $auth->getLink()\n                        );\n                    }\n                }\n                return __('CAS');\n\n            case self::X509:\n                if ($auths_id > 0) {\n                    $auth = new AuthLDAP();\n                    if ($auth->getFromDB($auths_id)) {\n                        return sprintf(\n                            __('%1$s: %2$s'),\n                            sprintf(\n                                __('%1$s + %2$s'),\n                                __('x509 certificate authentication'),\n                                AuthLDAP::getTypeName(1)\n                            ),\n                            $auth->getLink()\n                        );\n                    }\n                }\n                return __('x509 certificate authentication');\n\n            case self::EXTERNAL:\n                if ($auths_id > 0) {\n                    $auth = new AuthLDAP();\n                    if ($auth->getFromDB($auths_id)) {\n                        return sprintf(\n                            __('%1$s: %2$s'),\n                            sprintf(\n                                __('%1$s + %2$s'),\n                                __('Other'),\n                                AuthLDAP::getTypeName(1)\n                            ),\n                            $auth->getLink()\n                        );\n                    }\n                }\n                return __('Other');\n\n            case self::DB_GLPI:\n                return __('GLPI internal database');\n\n            case self::API:\n                return __(\"API\");\n\n            case self::NOT_YET_AUTHENTIFIED:\n                return __('Not yet authenticated');\n        }\n        return '';\n    }\n\n    /**\n     * Get all the authentication methods parameters for a specific authtype\n     *  and auths_id and return it as an array\n     *\n     * @param integer $authtype Authentication method\n     * @param integer $auths_id Authentication method ID\n     *\n     * @return mixed\n     */\n    public static function getMethodsByID($authtype, $auths_id)\n    {\n\n        switch ($authtype) {\n            case self::X509:\n            case self::EXTERNAL:\n            case self::CAS:\n            case self::LDAP:\n                $auth = new AuthLDAP();\n                if ($auths_id > 0 && $auth->getFromDB($auths_id)) {\n                    return ($auth->fields);\n                }\n                break;\n\n            case self::MAIL:\n                $auth = new AuthMail();\n                if ($auths_id > 0 && $auth->getFromDB($auths_id)) {\n                    return ($auth->fields);\n                }\n                break;\n        }\n        return [];\n    }\n\n    /**\n     * Is an external authentication used?\n     *\n     * @return boolean\n     */\n    public static function useAuthExt()\n    {\n\n        global $CFG_GLPI;\n\n       //Get all the ldap directories\n        if (AuthLDAP::useAuthLdap()) {\n            return true;\n        }\n\n        if (AuthMail::useAuthMail()) {\n            return true;\n        }\n\n        if (!empty($CFG_GLPI[\"x509_email_field\"])) {\n            return true;\n        }\n\n       // Existing auth method\n        if (!empty($CFG_GLPI[\"ssovariables_id\"])) {\n            return true;\n        }\n\n       // Using CAS server\n        if (!empty($CFG_GLPI[\"cas_host\"])) {\n            return true;\n        }\n\n       // Using API login with personnal token\n        if (!empty($_REQUEST['user_token'])) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Is an alternate auth?\n     *\n     * @param integer $authtype auth type\n     *\n     * @return boolean\n     */\n    public static function isAlternateAuth($authtype)\n    {\n        return in_array($authtype, [self::X509, self::CAS, self::EXTERNAL, self::API, self::COOKIE]);\n    }\n\n    /**\n     * Check alternate authentication systems\n     *\n     * @param boolean $redirect        need to redirect (true) or get type of Auth system which match\n     *                                (false by default)\n     * @param string  $redirect_string redirect string if exists (default '')\n     *\n     * @return void|integer nothing if redirect is true, else Auth system ID\n     */\n    public static function checkAlternateAuthSystems($redirect = false, $redirect_string = '')\n    {\n        global $CFG_GLPI;\n\n        if (isset($_GET[\"noAUTO\"]) || isset($_POST[\"noAUTO\"])) {\n            return false;\n        }\n        $redir_string = \"\";\n        if (!empty($redirect_string)) {\n            $redir_string = \"?redirect=\" . $redirect_string;\n        }\n       // Using x509 server\n        if (\n            !empty($CFG_GLPI[\"x509_email_field\"])\n            && isset($_SERVER['SSL_CLIENT_S_DN'])\n            && strstr($_SERVER['SSL_CLIENT_S_DN'], $CFG_GLPI[\"x509_email_field\"])\n        ) {\n            if ($redirect) {\n                Html::redirect($CFG_GLPI[\"root_doc\"] . \"/front/login.php\" . $redir_string);\n            } else {\n                return self::X509;\n            }\n        }\n       // Existing auth method\n       //Look for the field in $_SERVER AND $_REQUEST\n       // MoYo : checking REQUEST create a security hole for me !\n        $ssovariable = Dropdown::getDropdownName('glpi_ssovariables', $CFG_GLPI[\"ssovariables_id\"]);\n        if (\n            $CFG_GLPI[\"ssovariables_id\"]\n            && ((isset($_SERVER[$ssovariable]) && !empty($_SERVER[$ssovariable]))\n              /*|| (isset($_REQUEST[$ssovariable]) && !empty($_REQUEST[$ssovariable]))*/)\n        ) {\n            if ($redirect) {\n                Html::redirect($CFG_GLPI[\"root_doc\"] . \"/front/login.php\" . $redir_string);\n            } else {\n                return self::EXTERNAL;\n            }\n        }\n\n       // using user token for api login\n        if (!empty($_REQUEST['user_token'])) {\n            return self::API;\n        }\n\n       // Using CAS server\n        if (!empty($CFG_GLPI[\"cas_host\"])) {\n            if ($redirect) {\n                Html::redirect($CFG_GLPI[\"root_doc\"] . \"/front/login.php\" . $redir_string);\n            } else {\n                return self::CAS;\n            }\n        }\n\n        $cookie_name = session_name() . '_rememberme';\n        if ($CFG_GLPI[\"login_remember_time\"] && isset($_COOKIE[$cookie_name])) {\n            if ($redirect) {\n                Html::redirect($CFG_GLPI[\"root_doc\"] . \"/front/login.php\" . $redir_string);\n            } else {\n                return self::COOKIE;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Redirect user to page if authenticated\n     *\n     * @param string $redirect redirect string if exists, if null, check in $_POST or $_GET\n     *\n     * @return void|boolean nothing if redirect is true, else false\n     */\n    public static function redirectIfAuthenticated($redirect = null)\n    {\n        global $CFG_GLPI;\n\n        if (!Session::getLoginUserID()) {\n            return false;\n        }\n\n        if (Session::mustChangePassword()) {\n            Html::redirect($CFG_GLPI['root_doc'] . '/front/updatepassword.php');\n        }\n\n        if (!$redirect) {\n            if (isset($_POST['redirect']) && (strlen($_POST['redirect']) > 0)) {\n                $redirect = $_POST['redirect'];\n            } else if (isset($_GET['redirect']) && strlen($_GET['redirect']) > 0) {\n                $redirect = $_GET['redirect'];\n            }\n        }\n\n       //Direct redirect\n        if ($redirect) {\n            Toolbox::manageRedirect($redirect);\n        }\n\n       // Redirect to Command Central if not post-only\n        if (Session::getCurrentInterface() == \"helpdesk\") {\n            if ($_SESSION['glpiactiveprofile']['create_ticket_on_login']) {\n                Html::redirect($CFG_GLPI['root_doc'] . \"/front/helpdesk.public.php?create_ticket=1\");\n            }\n            Html::redirect($CFG_GLPI['root_doc'] . \"/front/helpdesk.public.php\");\n        } else {\n            if ($_SESSION['glpiactiveprofile']['create_ticket_on_login']) {\n                Html::redirect(Ticket::getFormURL());\n            }\n            Html::redirect($CFG_GLPI['root_doc'] . \"/front/central.php\");\n        }\n    }\n\n    /**\n     * Display refresh button in the user page\n     *\n     * @param User $user User object\n     *\n     * @return void\n     */\n    public static function showSynchronizationForm(User $user)\n    {\n        global $DB, $CFG_GLPI;\n\n        if (Session::haveRight(\"user\", User::UPDATEAUTHENT)) {\n            echo \"<form method='post' action='\" . Toolbox::getItemTypeFormURL('User') . \"'>\";\n            echo \"<div class='firstbloc'>\";\n            echo \"<input type='hidden' name='id' value='\" . $user->getID() . \"'>\";\n\n            switch ($user->getField('authtype')) {\n                case self::CAS:\n                case self::EXTERNAL:\n                case self::X509:\n                case self::LDAP:\n                   //Look it the auth server still exists !\n                   // <- Bad idea : id not exists unable to change anything\n                    $authldap = new AuthLDAP();\n                    if (\n                        $authldap->getFromDBByCrit([\n                            'id'        => $user->getField('auths_id'),\n                            'is_active' => 1,\n                        ])\n                    ) {\n                        echo Html::submit(\"<i class='fas fa-sync-alt'></i><span>\" . __s('Force synchronization') . \"</span>\", [\n                            'name' => 'force_ldap_resynch'\n                        ]);\n\n                        if (strlen($authldap->fields['sync_field']) > 0) {\n                            echo Html::submit(\"<i class='fas fa-broom'></i><span>\" . __s('Clean LDAP fields and force synchronisation') . \"</span>\", [\n                                'name' => 'clean_ldap_fields'\n                            ]);\n                        }\n                    }\n                    break;\n\n                case self::DB_GLPI:\n                case self::MAIL:\n                    break;\n            }\n\n            echo \"</div>\";\n\n            echo \"<div class='spaced'>\";\n            echo \"<h3>\" . __('Change of the authentication method') . \"</h3>\";\n            $rand             = self::dropdown(['name' => 'authtype']);\n            $paramsmassaction = ['authtype' => '__VALUE__',\n                'name'     => 'change_auth_method'\n            ];\n            Ajax::updateItemOnSelectEvent(\n                \"dropdown_authtype$rand\",\n                \"show_massiveaction_field\",\n                $CFG_GLPI[\"root_doc\"] . \"/ajax/dropdownMassiveActionAuthMethods.php\",\n                $paramsmassaction\n            );\n            echo \"<span id='show_massiveaction_field'></span>\";\n            echo \"</div>\";\n            Html::closeForm();\n        }\n    }\n\n    /**\n     * Check if a login is valid\n     *\n     * @param string $login login to check\n     *\n     * @return boolean\n     */\n    public static function isValidLogin($login)\n    {\n        return $login !== null && preg_match(\"/^[[:alnum:]'@.\\-_ ]+$/iu\", $login);\n    }\n\n    public function getTabNameForItem(CommonGLPI $item, $withtemplate = 0)\n    {\n\n        if (!$withtemplate) {\n            switch ($item->getType()) {\n                case 'User':\n                    if (Session::haveRight(\"user\", User::UPDATEAUTHENT)) {\n                        return __('Synchronization');\n                    }\n                    break;\n            }\n        }\n        return '';\n    }\n\n    /**\n     * Show Tab content\n     *\n     * @since 0.83\n     *\n     * @param CommonGLPI $item         Item instance\n     * @param integer    $tabnum       Unused (default 0)\n     * @param integer    $withtemplate Unused (default 0)\n     *\n     * @return boolean\n     */\n    public static function displayTabContentForItem(CommonGLPI $item, $tabnum = 1, $withtemplate = 0)\n    {\n\n        if ($item->getType() == 'User') {\n            self::showSynchronizationForm($item);\n        }\n        return true;\n    }\n\n    /**\n     * Show form for authentication configuration.\n     *\n     * @return void|boolean False if the form is not shown due to right error. Form is directly printed.\n     */\n    public static function showOtherAuthList()\n    {\n        global $CFG_GLPI;\n\n        if (!Config::canUpdate()) {\n            return false;\n        }\n        echo \"<form name=cas action='\" . $CFG_GLPI['root_doc'] . \"/front/auth.others.php' method='post'>\";\n        echo \"<div class='card'>\";\n        echo \"<table class='tab_cadre_fixe'>\";\n\n       // CAS config\n        echo \"<tr><th>\" . __('CAS authentication') . '</th><th>';\n        if (!empty($CFG_GLPI[\"cas_host\"])) {\n            echo _x('authentication', 'Enabled');\n        }\n        echo \"</th></tr>\";\n\n        if (\n            function_exists('curl_init')\n            && Toolbox::canUseCAS()\n        ) {\n           //TRANS: for CAS SSO system\n            echo \"<tr class='tab_bg_2'><td class='center'>\" . __('CAS Host') . \"</td>\";\n            echo \"<td><input type='text' class='form-control' name='cas_host' value=\\\"\" . $CFG_GLPI[\"cas_host\"] . \"\\\"></td></tr>\";\n           //TRANS: for CAS SSO system\n            echo \"<tr class='tab_bg_2'><td class='center'>\" . __('CAS Version') . \"</td>\";\n            echo \"<td>\";\n            Auth::dropdownCasVersion($CFG_GLPI[\"cas_version\"]);\n            echo \"</td>\";\n            echo \"</tr>\";\n           //TRANS: for CAS SSO system\n            echo \"<tr class='tab_bg_2'><td class='center'>\" . _n('Port', 'Ports', 1) . \"</td>\";\n            echo \"<td><input type='text' class='form-control' name='cas_port' value=\\\"\" . $CFG_GLPI[\"cas_port\"] . \"\\\"></td></tr>\";\n           //TRANS: for CAS SSO system\n            echo \"<tr class='tab_bg_2'><td class='center'>\" . __('Root directory (optional)') . \"</td>\";\n            echo \"<td><input type='text' class='form-control' name='cas_uri' value=\\\"\" . $CFG_GLPI[\"cas_uri\"] . \"\\\"></td></tr>\";\n           //TRANS: for CAS SSO system\n            echo \"<tr class='tab_bg_2'><td class='center'>\" . __('Log out fallback URL') . \"</td>\";\n            echo \"<td><input type='text' class='form-control' name='cas_logout' value=\\\"\" . $CFG_GLPI[\"cas_logout\"] . \"\\\"></td>\" .\n              \"</tr>\";\n        } else {\n            echo \"<tr class='tab_bg_2'><td class='center' colspan='2'>\";\n            if (!function_exists('curl_init')) {\n                echo \"<p class='red'>\" . __(\"The CURL extension for your PHP parser isn't installed\");\n                echo \"</p>\";\n            }\n            if (!Toolbox::canUseCAS()) {\n                echo \"<p class='red'>\" . __(\"The CAS lib isn't available, GLPI doesn't package it anymore for license compatibility issue.\");\n                echo \"</p>\";\n            }\n            echo \"<p>\" . __('Impossible to use CAS as external source of connection') . \"</p>\";\n            echo \"<p><strong>\" . GLPINetwork::getSupportPromoteMessage() . \"</strong></p>\";\n\n            echo \"</td></tr>\";\n        }\n       // X509 config\n        echo \"<tr><th>\" . __('x509 certificate authentication') . \"</th><th>\";\n        if (!empty($CFG_GLPI[\"x509_email_field\"])) {\n            echo _x('authentication', 'Enabled');\n        }\n        echo \"</th></tr>\";\n        echo \"<tr class='tab_bg_2'>\";\n        echo \"<td class='center'>\" . __('Email attribute for x509 authentication') . \"</td>\";\n        echo \"<td><input type='text' class='form-control' name='x509_email_field' value=\\\"\" . $CFG_GLPI[\"x509_email_field\"] . \"\\\">\";\n        echo \"</td></tr>\";\n        echo \"<tr class='tab_bg_2'>\";\n        echo \"<td class='center'>\" . sprintf(__('Restrict %s field for x509 authentication (separator $)'), 'OU') . \"</td>\";\n        echo \"<td><input type='text' class='form-control' name='x509_ou_restrict' value=\\\"\" . $CFG_GLPI[\"x509_ou_restrict\"] . \"\\\">\";\n        echo \"</td></tr>\";\n        echo \"<tr class='tab_bg_2'>\";\n        echo \"<td class='center'>\" . sprintf(__('Restrict %s field for x509 authentication (separator $)'), 'CN') . \"</td>\";\n        echo \"<td><input type='text' class='form-control' name='x509_cn_restrict' value=\\\"\" . $CFG_GLPI[\"x509_cn_restrict\"] . \"\\\">\";\n        echo \"</td></tr>\";\n        echo \"<tr class='tab_bg_2'>\";\n        echo \"<td class='center'>\" . sprintf(__('Restrict %s field for x509 authentication (separator $)'), 'O') . \"</td>\";\n        echo \"<td><input type='text' class='form-control' name='x509_o_restrict' value=\\\"\" . $CFG_GLPI[\"x509_o_restrict\"] . \"\\\">\";\n        echo \"</td></tr>\";\n\n       //Other configuration\n        echo \"<tr><th>\" . __('Other authentication sent in the HTTP request') . \"</th><th>\";\n        if (!empty($CFG_GLPI[\"ssovariables_id\"])) {\n            echo _x('authentication', 'Enabled');\n        }\n        echo \"</th></tr>\";\n        echo \"<tr class='tab_bg_2'>\";\n        echo \"<td class='center'>\" . SsoVariable::getTypeName(1) . \"</td>\";\n        echo \"<td>\";\n        SsoVariable::dropdown(['name'  => 'ssovariables_id',\n            'value' => $CFG_GLPI[\"ssovariables_id\"]\n        ]);\n        echo \"</td>\";\n        echo \"</tr>\";\n\n        echo \"<tr class='tab_bg_2'>\";\n        echo \"<td class='center'>\" . __('SSO logout url') . \"</td>\";\n        echo \"<td><input type='text' class='form-control' name='ssologout_url' value='\" .\n                 $CFG_GLPI['ssologout_url'] . \"'></td>\";\n        echo \"</tr>\";\n\n        echo \"<tr class='tab_bg_2'>\";\n        echo \"<td class='center'>\" . __('Remove the domain of logins like login@domain') . \"</td><td>\";\n        Dropdown::showYesNo(\n            'existing_auth_server_field_clean_domain',\n            $CFG_GLPI['existing_auth_server_field_clean_domain']\n        );\n        echo \"</td></tr>\";\n\n        echo \"<tr class='tab_bg_2'>\";\n        echo \"<td class='center'>\" . __('Surname') . \"</td>\";\n        echo \"<td><input type='text' class='form-control' name='realname_ssofield' value='\" .\n                 $CFG_GLPI['realname_ssofield'] . \"'></td>\";\n        echo \"</tr>\";\n\n        echo \"<tr class='tab_bg_2'>\";\n        echo \"<td class='center'>\" . __('First name') . \"</td>\";\n        echo \"<td><input type='text' class='form-control' name='firstname_ssofield' value='\" .\n                 $CFG_GLPI['firstname_ssofield'] . \"'></td>\";\n        echo \"</tr>\";\n\n        echo \"<tr class='tab_bg_2'>\";\n        echo \"<td class='center'>\" . __('Comments') . \"</td>\";\n        echo \"<td><input type='text' class='form-control' name='comment_ssofield' value='\" .\n                 $CFG_GLPI['comment_ssofield'] . \"'>\";\n        echo \"</td>\";\n        echo \"</tr>\";\n\n        echo \"<tr class='tab_bg_2'>\";\n        echo \"<td class='center'>\" . _x('user', 'Administrative number') . \"</td>\";\n        echo \"<td><input type='text' class='form-control' name='registration_number_ssofield' value='\" .\n                  $CFG_GLPI['registration_number_ssofield'] . \"'>\";\n        echo \"</td>\";\n        echo \"</tr>\";\n\n        echo \"<tr class='tab_bg_2'>\";\n        echo \"<td class='center'>\" . _n('Email', 'Emails', 1) . \"</td>\";\n        echo \"<td><input type='text' class='form-control' name='email1_ssofield' value='\" . $CFG_GLPI['email1_ssofield'] . \"'>\";\n        echo \"</td>\";\n        echo \"</tr>\";\n\n        echo \"<tr class='tab_bg_2'>\";\n        echo \"<td class='center'>\" . sprintf(__('%1$s %2$s'), _n('Email', 'Emails', 1), '2') . \"</td>\";\n        echo \"<td><input type='text' class='form-control' name='email2_ssofield' value='\" . $CFG_GLPI['email2_ssofield'] . \"'>\";\n        echo \"</td>\";\n        echo \"</tr>\";\n\n        echo \"<tr class='tab_bg_2'>\";\n        echo \"<td class='center'>\" . sprintf(__('%1$s %2$s'), _n('Email', 'Emails', 1), '3') . \"</td>\";\n        echo \"<td><input type='text' class='form-control' name='email3_ssofield' value='\" . $CFG_GLPI['email3_ssofield'] . \"'>\";\n        echo \"</td>\";\n        echo \"</tr>\";\n\n        echo \"<tr class='tab_bg_2'>\";\n        echo \"<td class='center'>\" . sprintf(__('%1$s %2$s'), _n('Email', 'Emails', 1), '4') . \"</td>\";\n        echo \"<td><input type='text' class='form-control' name='email4_ssofield' value='\" . $CFG_GLPI['email4_ssofield'] . \"'>\";\n        echo \"</td>\";\n        echo \"</tr>\";\n\n        echo \"<tr class='tab_bg_2'>\";\n        echo \"<td class='center'>\" . Phone::getTypeName(1) . \"</td>\";\n        echo \"<td><input type='text' class='form-control' name='phone_ssofield' value='\" . $CFG_GLPI['phone_ssofield'] . \"'>\";\n        echo \"</td>\";\n        echo \"</tr>\";\n\n        echo \"<tr class='tab_bg_2'>\";\n        echo \"<td class='center'>\" .  __('Phone 2') . \"</td>\";\n        echo \"<td><input type='text' class='form-control' name='phone2_ssofield' value='\" . $CFG_GLPI['phone2_ssofield'] . \"'>\";\n        echo \"</td>\";\n        echo \"</tr>\";\n\n        echo \"<tr class='tab_bg_2'>\";\n        echo \"<td class='center'>\" . __('Mobile phone') . \"</td>\";\n        echo \"<td><input type='text' class='form-control' name='mobile_ssofield' value='\" . $CFG_GLPI['mobile_ssofield'] . \"'>\";\n        echo \"</td>\";\n        echo \"</tr>\";\n\n        echo \"<tr class='tab_bg_2'>\";\n        echo \"<td class='center'>\" . _x('person', 'Title') . \"</td>\";\n        echo \"<td><input type='text' class='form-control' name='title_ssofield' value='\" . $CFG_GLPI['title_ssofield'] . \"'>\";\n        echo \"</td>\";\n        echo \"</tr>\";\n\n        echo \"<tr class='tab_bg_2'>\";\n        echo \"<td class='center'>\" . _n('Category', 'Categories', 1) . \"</td>\";\n        echo \"<td><input type='text' class='form-control' name='category_ssofield' value='\" .\n                 $CFG_GLPI['category_ssofield'] . \"'></td>\";\n        echo \"</tr>\";\n\n        echo \"<tr class='tab_bg_2'>\";\n        echo \"<td class='center'>\" . __('Language') . \"</td>\";\n        echo \"<td><input type='text' class='form-control' name='language_ssofield' value='\" .\n                 $CFG_GLPI['language_ssofield'] . \"'></td></tr>\";\n\n        echo \"<tr class='tab_bg_1'><td class='center' colspan='2'>\";\n        echo \"<input type='submit' name='update' class='btn btn-primary' value=\\\"\" . __s('Save') . \"\\\" >\";\n        echo \"</td></tr>\";\n\n        echo \"</table></div>\";\n        Html::closeForm();\n    }\n\n    /**\n     * Get authentication methods available\n     *\n     * @return array\n     */\n    public static function getLoginAuthMethods()\n    {\n        global $DB;\n\n        $elements = [\n            '_default'  => 'local',\n            'local'     => __(\"GLPI internal database\")\n        ];\n\n       // Get LDAP\n        if (Toolbox::canUseLdap()) {\n            $iterator = $DB->request([\n                'FROM'   => 'glpi_authldaps',\n                'WHERE'  => [\n                    'is_active' => 1\n                ],\n                'ORDER'  => ['name']\n            ]);\n            foreach ($iterator as $data) {\n                $elements['ldap-' . $data['id']] = $data['name'];\n                if ($data['is_default'] == 1) {\n                    $elements['_default'] = 'ldap-' . $data['id'];\n                }\n            }\n        }\n\n       // GET Mail servers\n        $iterator = $DB->request([\n            'FROM'   => 'glpi_authmails',\n            'WHERE'  => [\n                'is_active' => 1\n            ],\n            'ORDER'  => ['name']\n        ]);\n        foreach ($iterator as $data) {\n            $elements['mail-' . $data['id']] = $data['name'];\n        }\n\n        return $elements;\n    }\n\n    /**\n     * Display the authentication source dropdown for login form\n     */\n    public static function dropdownLogin(bool $display = true)\n    {\n        $out = \"\";\n        $elements = self::getLoginAuthMethods();\n        $default = $elements['_default'];\n        unset($elements['_default']);\n       // show dropdown of login src only when multiple src\n        $out .= Dropdown::showFromArray('auth', $elements, [\n            'display'   => false,\n            'rand'      => '1',\n            'value'     => $default,\n            'width'     => '100%'\n        ]);\n\n        if ($display) {\n            echo $out;\n            return \"\";\n        }\n\n        return $out;\n    }\n\n\n    public static function getIcon()\n    {\n        return \"ti ti-login\";\n    }\n\n    /**\n     * Defines \"rememberme\" cookie.\n     *\n     * @param string $cookie_value\n     *\n     * @return void\n     */\n    public static function setRememberMeCookie(string $cookie_value): void\n    {\n        global $CFG_GLPI;\n\n        $cookie_name     = session_name() . '_rememberme';\n        $cookie_lifetime = empty($cookie_value) ? time() - 3600 : time() + $CFG_GLPI['login_remember_time'];\n        $cookie_path     = ini_get('session.cookie_path');\n        $cookie_domain   = ini_get('session.cookie_domain');\n        $cookie_secure   = (bool)ini_get('session.cookie_secure');\n\n        if (empty($cookie_value) && !isset($_COOKIE[$cookie_name])) {\n            return;\n        }\n\n        setcookie($cookie_name, $cookie_value, $cookie_lifetime, $cookie_path, $cookie_domain, $cookie_secure, true);\n\n        if (empty($cookie_value)) {\n            unset($_COOKIE[$cookie_name]);\n        } else {\n            $_COOKIE[$cookie_name] = $cookie_value;\n        }\n    }\n}\n"], "fixing_code": ["<?php\n\n/**\n * ---------------------------------------------------------------------\n *\n * GLPI - Gestionnaire Libre de Parc Informatique\n *\n * http://glpi-project.org\n *\n * @copyright 2015-2022 Teclib' and contributors.\n * @copyright 2003-2014 by the INDEPNET Development Team.\n * @licence   https://www.gnu.org/licenses/gpl-3.0.html\n *\n * ---------------------------------------------------------------------\n *\n * LICENSE\n *\n * This file is part of GLPI.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n * ---------------------------------------------------------------------\n */\n\nuse Glpi\\Application\\ErrorHandler;\nuse Glpi\\Event;\nuse Glpi\\Plugin\\Hooks;\nuse Glpi\\Toolbox\\Sanitizer;\n\n/**\n *  Identification class used to login\n */\nclass Auth extends CommonGLPI\n{\n    /** @var array Array of errors */\n    private $errors = [];\n    /** @var User User class variable */\n    public $user;\n    /** @var int External authentication variable */\n    public $extauth = 0;\n    /** @var array External authentication methods */\n    public $authtypes;\n    /** @var int Indicates if the user is authenticated or not */\n    public $auth_succeded = 0;\n    /** @var int Indicates if the user is already present in database */\n    public $user_present = 0;\n    /** @var int Indicates if the user password expired */\n    public $password_expired = false;\n\n    /**\n     * Indicated if user was found in the directory.\n     * @var boolean\n     */\n    public $user_found = false;\n\n    /** @var resource|boolean LDAP connection descriptor */\n    public $ldap_connection;\n    /** @var bool Store user LDAP dn */\n    public $user_dn = false;\n\n    const DB_GLPI  = 1;\n    const MAIL     = 2;\n    const LDAP     = 3;\n    const EXTERNAL = 4;\n    const CAS      = 5;\n    const X509     = 6;\n    const API      = 7;\n    const COOKIE   = 8;\n    const NOT_YET_AUTHENTIFIED = 0;\n\n    const USER_DOESNT_EXIST       = 0;\n    const USER_EXISTS_WITH_PWD    = 1;\n    const USER_EXISTS_WITHOUT_PWD = 2;\n\n    /**\n     * Constructor\n     *\n     * @return void\n     */\n    public function __construct()\n    {\n        $this->user = new User();\n    }\n\n\n    public static function getMenuContent()\n    {\n\n        $menu = [];\n        if (Config::canUpdate()) {\n            $menu['title']                              = __('Authentication');\n            $menu['page']                               = '/front/setup.auth.php';\n            $menu['icon']                               = self::getIcon();\n\n            $menu['options']['ldap']['icon']            = AuthLDAP::getIcon();\n            $menu['options']['ldap']['title']           = AuthLDAP::getTypeName(Session::getPluralNumber());\n            $menu['options']['ldap']['page']            = AuthLDAP::getSearchURL(false);\n            $menu['options']['ldap']['links']['search'] = AuthLDAP::getSearchURL(false);\n            $menu['options']['ldap']['links']['add']    = AuthLDAP::getFormURL(false);\n\n            $menu['options']['imap']['icon']            = AuthMail::getIcon();\n            $menu['options']['imap']['title']           = AuthMail::getTypeName(Session::getPluralNumber());\n            $menu['options']['imap']['page']            = AuthMail::getSearchURL(false);\n            $menu['options']['imap']['links']['search'] = AuthMail::getSearchURL(false);\n            $menu['options']['imap']['links']['add']    = AuthMail::getFormURL(false);\n\n            $menu['options']['others']['icon']          = 'ti ti-login';\n            $menu['options']['others']['title']         = __('Others');\n            $menu['options']['others']['page']          = '/front/auth.others.php';\n\n            $menu['options']['settings']['icon']        = 'ti ti-adjustments';\n            $menu['options']['settings']['title']       = __('Setup');\n            $menu['options']['settings']['page']        = '/front/auth.settings.php';\n        }\n        if (count($menu)) {\n            return $menu;\n        }\n        return false;\n    }\n\n    /**\n     * Check user existence in DB\n     *\n     * @global DBmysql $DB\n     * @param  array   $options conditions : array('name'=>'glpi')\n     *                                    or array('email' => 'test at test.com')\n     *\n     * @return integer {@link Auth::USER_DOESNT_EXIST}, {@link Auth::USER_EXISTS_WITHOUT_PWD} or {@link Auth::USER_EXISTS_WITH_PWD}\n     */\n    public function userExists($options = [])\n    {\n        global $DB;\n\n        $result = $DB->request(\n            'glpi_users',\n            ['WHERE'    => $options,\n                'LEFT JOIN' => ['glpi_useremails' => ['FKEY' => ['glpi_users'      => 'id',\n                    'glpi_useremails' => 'users_id'\n                ]\n                ]\n                ]\n            ]\n        );\n       // Check if there is a row\n        if ($result->numrows() == 0) {\n            $this->addToError(__('Incorrect username or password'));\n            return self::USER_DOESNT_EXIST;\n        } else {\n           // Get the first result...\n            $row = $result->current();\n\n           // Check if we have a password...\n            if (empty($row['password'])) {\n                //If the user has an LDAP DN, then store it in the Auth object\n                if ($row['user_dn']) {\n                    $this->user_dn = $row['user_dn'];\n                }\n                return self::USER_EXISTS_WITHOUT_PWD;\n            }\n            return self::USER_EXISTS_WITH_PWD;\n        }\n    }\n\n    /**\n     * Try a IMAP/POP connection\n     *\n     * @param string $host  IMAP/POP host to connect\n     * @param string $login Login to try\n     * @param string $pass  Password to try\n     *\n     * @return boolean connection success\n     */\n    public function connection_imap($host, $login, $pass)\n    {\n\n       // we prevent some delay...\n        if (empty($host)) {\n            return false;\n        }\n\n        $oldlevel = error_reporting(16);\n       // No retry (avoid lock account when password is not correct)\n        try {\n            $config = Toolbox::parseMailServerConnectString($host);\n\n            $ssl = false;\n            if ($config['ssl']) {\n                $ssl = 'SSL';\n            }\n            if ($config['tls']) {\n                $ssl = 'TLS';\n            }\n\n            $protocol = Toolbox::getMailServerProtocolInstance($config['type']);\n            if ($protocol === null) {\n                throw new \\RuntimeException(sprintf(__('Unsupported mail server type:%s.'), $config['type']));\n            }\n            if ($config['validate-cert'] === false) {\n                $protocol->setNoValidateCert(true);\n            }\n            $protocol->connect(\n                $config['address'],\n                $config['port'],\n                $ssl\n            );\n\n            return $protocol->login($login, $pass);\n        } catch (\\Exception $e) {\n            $this->addToError($e->getMessage());\n            return false;\n        } finally {\n            error_reporting($oldlevel);\n        }\n\n        return false;\n    }\n\n    /**\n     * Find a user in a LDAP and return is BaseDN\n     * Based on GRR auth system\n     *\n     * @param string $ldap_method ldap_method array to use\n     * @param string $login       User Login\n     * @param string $password    User Password\n     *\n     * @return string basedn of the user / false if not founded\n     */\n    public function connection_ldap($ldap_method, $login, $password)\n    {\n\n       // we prevent some delay...\n        if (empty($ldap_method['host'])) {\n            return false;\n        }\n\n        $this->ldap_connection   = AuthLDAP::tryToConnectToServer($ldap_method, $login, $password);\n        $this->user_found = false;\n\n        if ($this->ldap_connection) {\n            $params = [\n                'method' => AuthLDAP::IDENTIFIER_LOGIN,\n                'fields' => [\n                    AuthLDAP::IDENTIFIER_LOGIN => $ldap_method['login_field'],\n                ],\n            ];\n            if (!empty($ldap_method['sync_field'])) {\n                $params['fields']['sync_field'] = $ldap_method['sync_field'];\n            }\n            try {\n                $infos = AuthLDAP::searchUserDn($this->ldap_connection, [\n                    'basedn'            => $ldap_method['basedn'],\n                    'login_field'       => $ldap_method['login_field'],\n                    'search_parameters' => $params,\n                    'user_params'       => [\n                        'method' => AuthLDAP::IDENTIFIER_LOGIN,\n                        'value'  => $login\n                    ],\n                    'condition'         => Sanitizer::unsanitize($ldap_method['condition']),\n                    'user_dn'           => $this->user_dn\n                ]);\n            } catch (\\Throwable $e) {\n                ErrorHandler::getInstance()->handleException($e, true);\n                $this->addToError(__('Unable to connect to the LDAP directory'));\n                return false;\n            }\n\n            $dn = $infos['dn'];\n            $this->user_found = $dn != '';\n            if ($this->user_found && @ldap_bind($this->ldap_connection, $dn, $password)) {\n               //Hook to implement to restrict access by checking the ldap directory\n                if (Plugin::doHookFunction(Hooks::RESTRICT_LDAP_AUTH, $infos)) {\n                    return $infos;\n                }\n                $this->addToError(__('User not authorized to connect in GLPI'));\n               //Use is present by has no right to connect because of a plugin\n                return false;\n            } else {\n               // Incorrect login\n                $this->addToError(__('Incorrect username or password'));\n               //Use is not present anymore in the directory!\n                return false;\n            }\n        } else {\n            $this->addToError(__('Unable to connect to the LDAP directory'));\n           //Directory is not available\n            return false;\n        }\n    }\n\n    /**\n     * Check is a password match the stored hash\n     *\n     * @since 0.85\n     *\n     * @param string $pass Password (pain-text)\n     * @param string $hash Hash\n     *\n     * @return boolean\n     */\n    public static function checkPassword($pass, $hash)\n    {\n\n        $tmp = password_get_info($hash);\n\n        if (isset($tmp['algo']) && $tmp['algo']) {\n            $ok = password_verify($pass, $hash);\n        } else if (strlen($hash) == 32) {\n            $ok = md5($pass) === $hash;\n        } else if (strlen($hash) == 40) {\n            $ok = sha1($pass) === $hash;\n        } else {\n            $salt = substr($hash, 0, 8);\n            $ok = ($salt . sha1($salt . $pass) === $hash);\n        }\n\n        return $ok;\n    }\n\n    /**\n     * Is the hash stored need to be regenerated\n     *\n     * @since 0.85\n     *\n     * @param string $hash Hash\n     *\n     * @return boolean\n     */\n    public static function needRehash($hash)\n    {\n\n        return password_needs_rehash($hash, PASSWORD_DEFAULT);\n    }\n\n    /**\n     * Compute the hash for a password\n     *\n     * @since 0.85\n     *\n     * @param string $pass Password\n     *\n     * @return string\n     */\n    public static function getPasswordHash($pass)\n    {\n\n        return password_hash($pass, PASSWORD_DEFAULT);\n    }\n\n    /**\n     * Find a user in the GLPI DB\n     *\n     * try to connect to DB\n     * update the instance variable user with the user who has the name $name\n     * and the password is $password in the DB.\n     * If not found or can't connect to DB updates the instance variable err\n     * with an eventual error message\n     *\n     * @global DBmysql $DB\n     * @param string $name     User Login\n     * @param string $password User Password\n     *\n     * @return boolean user in GLPI DB with the right password\n     */\n    public function connection_db($name, $password)\n    {\n        global $CFG_GLPI, $DB;\n\n        $pass_expiration_delay = (int)$CFG_GLPI['password_expiration_delay'];\n        $lock_delay            = (int)$CFG_GLPI['password_expiration_lock_delay'];\n\n       // SQL query\n        $result = $DB->request(\n            [\n                'SELECT' => [\n                    'id',\n                    'password',\n                    new QueryExpression(\n                        sprintf(\n                            'ADDDATE(%s, INTERVAL %d DAY) AS ' . $DB->quoteName('password_expiration_date'),\n                            $DB->quoteName('password_last_update'),\n                            $pass_expiration_delay\n                        )\n                    ),\n                    new QueryExpression(\n                        sprintf(\n                            'ADDDATE(%s, INTERVAL %d DAY) AS ' . $DB->quoteName('lock_date'),\n                            $DB->quoteName('password_last_update'),\n                            $pass_expiration_delay + $lock_delay\n                        )\n                    )\n                ],\n                'FROM'   => User::getTable(),\n                'WHERE'  =>  [\n                    'name'     => $name,\n                    'authtype' => self::DB_GLPI,\n                    'auths_id' => 0,\n                ]\n            ]\n        );\n\n       // Have we a result ?\n        if ($result->numrows() == 1) {\n            $row = $result->current();\n            $password_db = $row['password'];\n\n            if (self::checkPassword($password, $password_db)) {\n               // Disable account if password expired\n                if (\n                    -1 !== $pass_expiration_delay && -1 !== $lock_delay\n                    && $row['lock_date'] < $_SESSION['glpi_currenttime']\n                ) {\n                    $user = new User();\n                    $user->update(\n                        [\n                            'id'        => $row['id'],\n                            'is_active' => 0,\n                        ]\n                    );\n                }\n                if (\n                    -1 !== $pass_expiration_delay\n                    && $row['password_expiration_date'] < $_SESSION['glpi_currenttime']\n                ) {\n                    $this->password_expired = 1;\n                }\n\n               // Update password if needed\n                if (self::needRehash($password_db)) {\n                    $input = [\n                        'id' => $row['id'],\n                    ];\n                 // Set glpiID to allow password update\n                    $_SESSION['glpiID'] = $input['id'];\n                    $input['password'] = $password;\n                    $input['password2'] = $password;\n                    $user = new User();\n                    $user->update($input);\n                }\n                $this->user->getFromDBByCrit(['id' => $row['id']]);\n                $this->extauth                  = 0;\n                $this->user_present             = 1;\n                $this->user->fields[\"authtype\"] = self::DB_GLPI;\n                $this->user->fields[\"password\"] = $password;\n\n             // apply rule rights on local user\n                $rules  = new RuleRightCollection();\n                $groups = Group_User::getUserGroups($row['id']);\n                $groups_id = array_column($groups, 'id');\n                $result = $rules->processAllRules(\n                    $groups_id,\n                    $this->user->fields,\n                    [\n                        'type'  => Auth::DB_GLPI,\n                        'login' => $this->user->fields['name'],\n                        'email' => UserEmail::getDefaultForUser($row['id'])\n                    ]\n                );\n\n                $this->user->fields = $result + [\n                    '_ruleright_process' => true,\n                ];\n\n                return true;\n            }\n        }\n        $this->addToError(__('Incorrect username or password'));\n        return false;\n    }\n\n    /**\n     * Try to get login of external auth method\n     *\n     * @param integer $authtype external auth type (default 0)\n     *\n     * @return boolean user login success\n     */\n    public function getAlternateAuthSystemsUserLogin($authtype = 0)\n    {\n        global $CFG_GLPI;\n\n        switch ($authtype) {\n            case self::CAS:\n                if (!Toolbox::canUseCAS()) {\n                    trigger_error(\"CAS lib not installed\", E_USER_WARNING);\n                    return false;\n                }\n\n                phpCAS::client(\n                    constant($CFG_GLPI[\"cas_version\"]),\n                    $CFG_GLPI[\"cas_host\"],\n                    intval($CFG_GLPI[\"cas_port\"]),\n                    $CFG_GLPI[\"cas_uri\"],\n                    false\n                );\n\n                // no SSL validation for the CAS server\n                phpCAS::setNoCasServerValidation();\n\n                // force CAS authentication\n                phpCAS::forceAuthentication();\n                $this->user->fields['name'] = phpCAS::getUser();\n\n                // extract e-mail information\n                if (phpCAS::hasAttribute(\"mail\")) {\n                      $this->user->fields['_useremails'] = [phpCAS::getAttribute(\"mail\")];\n                }\n\n                return true;\n\n            case self::EXTERNAL:\n                $ssovariable = Dropdown::getDropdownName(\n                    'glpi_ssovariables',\n                    $CFG_GLPI[\"ssovariables_id\"]\n                );\n                $login_string = '';\n               // MoYo : checking REQUEST create a security hole for me !\n                if (isset($_SERVER[$ssovariable])) {\n                      $login_string = $_SERVER[$ssovariable];\n                }\n               // else {\n               //    $login_string = $_REQUEST[$ssovariable];\n               // }\n                $login        = $login_string;\n                $pos          = stripos($login_string, \"\\\\\");\n                if (!$pos === false) {\n                    $login = substr($login_string, $pos + 1);\n                }\n                if ($CFG_GLPI['existing_auth_server_field_clean_domain']) {\n                    $pos = stripos($login, \"@\");\n                    if (!$pos === false) {\n                        $login = substr($login, 0, $pos);\n                    }\n                }\n                if (self::isValidLogin($login)) {\n                    $this->user->fields['name'] = $login;\n                   // Get data from SSO if defined\n                    $ret = $this->user->getFromSSO();\n                    if (!$ret) {\n                        return false;\n                    }\n                    return true;\n                }\n                break;\n\n            case self::X509:\n               // From eGroupWare  http://www.egroupware.org\n               // an X.509 subject looks like:\n               // CN=john.doe/OU=Department/O=Company/C=xx/Email=john@comapy.tld/L=City/\n                $sslattribs = explode('/', $_SERVER['SSL_CLIENT_S_DN']);\n                $sslattributes = [];\n                while ($sslattrib = next($sslattribs)) {\n                    list($key,$val)      = explode('=', $sslattrib);\n                    $sslattributes[$key] = $val;\n                }\n                if (\n                    isset($sslattributes[$CFG_GLPI[\"x509_email_field\"]])\n                    && NotificationMailing::isUserAddressValid($sslattributes[$CFG_GLPI[\"x509_email_field\"]])\n                    && self::isValidLogin($sslattributes[$CFG_GLPI[\"x509_email_field\"]])\n                ) {\n                    $restrict = false;\n                    $CFG_GLPI[\"x509_ou_restrict\"] = trim($CFG_GLPI[\"x509_ou_restrict\"]);\n                    if (!empty($CFG_GLPI[\"x509_ou_restrict\"])) {\n                        $split = explode('$', $CFG_GLPI[\"x509_ou_restrict\"]);\n\n                        if (!in_array($sslattributes['OU'], $split)) {\n                            $restrict = true;\n                        }\n                    }\n                    $CFG_GLPI[\"x509_o_restrict\"] = trim($CFG_GLPI[\"x509_o_restrict\"]);\n                    if (!empty($CFG_GLPI[\"x509_o_restrict\"])) {\n                        $split = explode('$', $CFG_GLPI[\"x509_o_restrict\"]);\n\n                        if (!in_array($sslattributes['O'], $split)) {\n                            $restrict = true;\n                        }\n                    }\n                    $CFG_GLPI[\"x509_cn_restrict\"] = trim($CFG_GLPI[\"x509_cn_restrict\"]);\n                    if (!empty($CFG_GLPI[\"x509_cn_restrict\"])) {\n                        $split = explode('$', $CFG_GLPI[\"x509_cn_restrict\"]);\n\n                        if (!in_array($sslattributes['CN'], $split)) {\n                            $restrict = true;\n                        }\n                    }\n\n                    if (!$restrict) {\n                        $this->user->fields['name'] = $sslattributes[$CFG_GLPI[\"x509_email_field\"]];\n\n                       // Can do other things if need : only add it here\n                        $this->user->fields['email'] = $this->user->fields['name'];\n                        return true;\n                    }\n                }\n                break;\n\n            case self::API:\n                if ($CFG_GLPI['enable_api_login_external_token']) {\n                    $user = new User();\n                    if ($user->getFromDBbyToken($_REQUEST['user_token'], 'api_token')) {\n                        $this->user->fields['name'] = $user->fields['name'];\n                        return true;\n                    }\n                } else {\n                    $this->addToError(__(\"Login with external token disabled\"));\n                }\n                break;\n            case self::COOKIE:\n                $cookie_name   = session_name() . '_rememberme';\n\n                if ($CFG_GLPI[\"login_remember_time\"]) {\n                    $data = json_decode($_COOKIE[$cookie_name], true);\n                    if (count($data) === 2) {\n                        list ($cookie_id, $cookie_token) = $data;\n\n                        $user = new User();\n                        $user->getFromDB($cookie_id);\n                        $hash = $user->getAuthToken('cookie_token');\n\n                        if (Auth::checkPassword($cookie_token, $hash)) {\n                            $this->user->fields['name'] = $user->fields['name'];\n                            return true;\n                        } else {\n                            $this->addToError(__(\"Invalid cookie data\"));\n                        }\n                    }\n                } else {\n                    $this->addToError(__(\"Auto login disabled\"));\n                }\n\n               //Remove cookie to allow new login\n                Auth::setRememberMeCookie('');\n                break;\n        }\n        return false;\n    }\n\n    /**\n     * Get the current identification error\n     *\n     * @return string current identification error\n     */\n    public function getErr()\n    {\n        return implode(\"<br>\\n\", $this->getErrors());\n    }\n\n    /**\n     * Get errors\n     *\n     * @since 9.4\n     *\n     * @return array\n     */\n    public function getErrors()\n    {\n        return $this->errors;\n    }\n\n    /**\n     * Get the current user object\n     *\n     * @return object current user\n     */\n    public function getUser()\n    {\n        return $this->user;\n    }\n\n    /**\n     * Get all the authentication methods parameters\n     * and return it as an array\n     *\n     * @return void\n     */\n    public function getAuthMethods()\n    {\n\n       //Return all the authentication methods in an array\n        $this->authtypes = [\n            'ldap' => getAllDataFromTable('glpi_authldaps'),\n            'mail' => getAllDataFromTable('glpi_authmails')\n        ];\n    }\n\n    /**\n     * Add a message to the global identification error message\n     *\n     * @param string $message the message to add\n     *\n     * @return void\n     */\n    public function addToError($message)\n    {\n        if (!in_array($message, $this->errors)) {\n            $this->errors[] = $message;\n        }\n    }\n\n    /**\n     * Manage use authentication and initialize the session\n     *\n     * @param string  $login_name      Login\n     * @param string  $login_password  Password\n     * @param boolean $noauto          (false by default)\n     * @param bool    $remember_me\n     * @param string  $login_auth      Type of auth - id of the auth\n     *\n     * @return boolean (success)\n     */\n    public function login($login_name, $login_password, $noauto = false, $remember_me = false, $login_auth = '')\n    {\n        global $DB, $CFG_GLPI;\n\n        $this->getAuthMethods();\n        $this->user_present  = 1;\n        $this->auth_succeded = false;\n       //In case the user was deleted in the LDAP directory\n        $user_deleted_ldap   = false;\n\n       // Trim login_name : avoid LDAP search errors\n        $login_name = trim($login_name);\n\n       // manage the $login_auth (force the auth source of the user account)\n        $this->user->fields[\"auths_id\"] = 0;\n        if ($login_auth == 'local') {\n            $authtype = self::DB_GLPI;\n            $this->user->fields[\"authtype\"] = self::DB_GLPI;\n        } else if (preg_match('/^(?<type>ldap|mail|external)-(?<id>\\d+)$/', $login_auth, $auth_matches)) {\n            $this->user->fields[\"auths_id\"] = (int)$auth_matches['id'];\n            if ($auth_matches['type'] == 'ldap') {\n                $authtype = self::LDAP;\n            } else if ($auth_matches['type'] == 'mail') {\n                $authtype = self::MAIL;\n            } else if ($auth_matches['type'] == 'external') {\n                $authtype = self::EXTERNAL;\n            }\n            $this->user->fields['authtype'] = $authtype;\n        }\n        if (!$noauto && ($authtype = self::checkAlternateAuthSystems())) {\n            if (\n                $this->getAlternateAuthSystemsUserLogin($authtype)\n                && !empty($this->user->fields['name'])\n            ) {\n               // Used for log when login process failed\n                $login_name                        = $this->user->fields['name'];\n                $this->auth_succeded               = true;\n                $this->user_present                = $this->user->getFromDBbyName(addslashes($login_name));\n                $this->extauth                     = 1;\n                $user_dn                           = false;\n\n                if (array_key_exists('_useremails', $this->user->fields)) {\n                    $email = $this->user->fields['_useremails'];\n                }\n\n                $ldapservers = [];\n               //if LDAP enabled too, get user's infos from LDAP\n                if (Toolbox::canUseLdap()) {\n                   //User has already authenticate, at least once : it's ldap server if filled\n                    if (\n                        isset($this->user->fields[\"auths_id\"])\n                        && ($this->user->fields[\"auths_id\"] > 0)\n                    ) {\n                        $authldap = new AuthLDAP();\n                       //If ldap server is enabled\n                        if (\n                            $authldap->getFromDB($this->user->fields[\"auths_id\"])\n                            && $authldap->fields['is_active']\n                        ) {\n                            $ldapservers[] = $authldap->fields;\n                        }\n                    } else { // User has never been authenticated : try all active ldap server to find the right one\n                        foreach (getAllDataFromTable('glpi_authldaps', ['is_active' => 1]) as $ldap_config) {\n                            $ldapservers[] = $ldap_config;\n                        }\n                    }\n\n                    $ldapservers_status = false;\n                    foreach ($ldapservers as $ldap_method) {\n                        $ds = AuthLDAP::connectToServer(\n                            $ldap_method[\"host\"],\n                            $ldap_method[\"port\"],\n                            $ldap_method[\"rootdn\"],\n                            (new GLPIKey())->decrypt($ldap_method[\"rootdn_passwd\"]),\n                            $ldap_method[\"use_tls\"],\n                            $ldap_method[\"deref_option\"],\n                            $ldap_method[\"tls_certfile\"],\n                            $ldap_method[\"tls_keyfile\"],\n                            $ldap_method[\"use_bind\"],\n                            $ldap_method[\"timeout\"]\n                        );\n\n                        if ($ds) {\n                             $ldapservers_status = true;\n                             $params = [\n                                 'method' => AuthLDAP::IDENTIFIER_LOGIN,\n                                 'fields' => [\n                                     AuthLDAP::IDENTIFIER_LOGIN => $ldap_method[\"login_field\"],\n                                 ],\n                             ];\n                             try {\n                                 $user_dn = AuthLDAP::searchUserDn($ds, [\n                                     'basedn'            => $ldap_method[\"basedn\"],\n                                     'login_field'       => $ldap_method['login_field'],\n                                     'search_parameters' => $params,\n                                     'condition'         => $ldap_method[\"condition\"],\n                                     'user_params'       => [\n                                         'method' => AuthLDAP::IDENTIFIER_LOGIN,\n                                         'value'  => $login_name\n                                     ],\n                                 ]);\n                             } catch (\\RuntimeException $e) {\n                                 ErrorHandler::getInstance()->handleException($e, true);\n                                 $user_dn = false;\n                             }\n                             if ($user_dn) {\n                                 $this->user_found = true;\n                                 $this->user->fields['auths_id'] = $ldap_method['id'];\n                                 $this->user->getFromLDAP(\n                                     $ds,\n                                     $ldap_method,\n                                     $user_dn['dn'],\n                                     $login_name,\n                                     !$this->user_present\n                                 );\n                                 break;\n                             }\n                        }\n                    }\n                }\n                if (\n                    (count($ldapservers) == 0)\n                    && ($authtype == self::EXTERNAL)\n                ) {\n                   // Case of using external auth and no LDAP servers, so get data from external auth\n                    $this->user->getFromSSO();\n                } else {\n                    if ($this->user->fields['authtype'] == self::LDAP) {\n                        if (!$ldapservers_status) {\n                             $this->auth_succeded = false;\n                             $this->addToError(_n(\n                                 'Connection to LDAP directory failed',\n                                 'Connection to LDAP directories failed',\n                                 count($ldapservers)\n                             ));\n                        } else if (!$user_dn && $this->user_present) {\n                           //If user is set as present in GLPI but no LDAP DN found : it means that the user\n                           //is not present in an ldap directory anymore\n                            $user_deleted_ldap = true;\n                            $this->addToError(_n(\n                                'User not found in LDAP directory',\n                                'User not found in LDAP directories',\n                                count($ldapservers)\n                            ));\n                        }\n                    }\n                }\n               // Reset to secure it\n                $this->user->fields['name']       = $login_name;\n                $this->user->fields[\"last_login\"] = $_SESSION[\"glpi_currenttime\"];\n            } else {\n                $this->addToError(__('Empty login or password'));\n            }\n        }\n\n        if (!$this->auth_succeded) {\n            if (\n                empty($login_name) || strstr($login_name, \"\\0\")\n                || empty($login_password) || strstr($login_password, \"\\0\")\n            ) {\n                $this->addToError(__('Empty login or password'));\n            } else {\n               // Try connect local user if not yet authenticated\n                if (\n                    empty($login_auth)\n                    || $this->user->fields[\"authtype\"] == $this::DB_GLPI\n                ) {\n                    $this->auth_succeded = $this->connection_db(\n                        addslashes($login_name),\n                        $login_password\n                    );\n                }\n\n               // Try to connect LDAP user if not yet authenticated\n                if (!$this->auth_succeded) {\n                    if (\n                        empty($login_auth)\n                        || $this->user->fields[\"authtype\"] == $this::CAS\n                        || $this->user->fields[\"authtype\"] == $this::EXTERNAL\n                        || $this->user->fields[\"authtype\"] == $this::LDAP\n                    ) {\n                        if (Toolbox::canUseLdap()) {\n                            AuthLDAP::tryLdapAuth(\n                                $this,\n                                $login_name,\n                                $login_password,\n                                $this->user->fields[\"auths_id\"]\n                            );\n                            if ($this->ldap_connection !== false && (!$this->auth_succeded && !$this->user_found)) {\n                                 $search_params = [\n                                     'name'     => addslashes($login_name),\n                                     'authtype' => $this::LDAP\n                                 ];\n                                 if (!empty($login_auth)) {\n                                     $search_params['auths_id'] = $this->user->fields[\"auths_id\"];\n                                 }\n                                 if ($this->user->getFromDBByCrit($search_params)) {\n                                     $user_deleted_ldap = true;\n                                 };\n                            }\n                        }\n                    }\n                }\n\n               // Try connect MAIL server if not yet authenticated\n                if (!$this->auth_succeded) {\n                    if (\n                        empty($login_auth)\n                        || $this->user->fields[\"authtype\"] == $this::MAIL\n                    ) {\n                        AuthMail::tryMailAuth(\n                            $this,\n                            $login_name,\n                            $login_password,\n                            $this->user->fields[\"auths_id\"]\n                        );\n                    }\n                }\n            }\n        }\n\n        if ($user_deleted_ldap) {\n            User::manageDeletedUserInLdap($this->user->fields[\"id\"]);\n            $this->auth_succeded = false;\n        }\n       // Ok, we have gathered sufficient data, if the first return false the user\n       // is not present on the DB, so we add him.\n       // if not, we update him.\n        if ($this->auth_succeded) {\n           //Set user an not deleted from LDAP\n            $this->user->fields['is_deleted_ldap'] = 0;\n\n           // Prepare data\n            $this->user->fields[\"last_login\"] = $_SESSION[\"glpi_currenttime\"];\n            if ($this->extauth) {\n                $this->user->fields[\"_extauth\"] = 1;\n            }\n\n            if ($DB->isSlave()) {\n                if (!$this->user_present) { // Can't add in slave mode\n                    $this->addToError(__('User not authorized to connect in GLPI'));\n                    $this->auth_succeded = false;\n                }\n            } else {\n                if ($this->user_present) {\n                   // Add the user e-mail if present\n                    if (isset($email)) {\n                         $this->user->fields['_useremails'] = $email;\n                    }\n                    $this->user->update(Sanitizer::sanitize($this->user->fields));\n                } else if ($CFG_GLPI[\"is_users_auto_add\"]) {\n                   // Auto add user\n                    $input = $this->user->fields;\n                    unset($this->user->fields);\n                    if ($authtype == self::EXTERNAL && !isset($input[\"authtype\"])) {\n                        $input[\"authtype\"] = $authtype;\n                    }\n                    $this->user->add(Sanitizer::sanitize($input));\n                } else {\n                   // Auto add not enable so auth failed\n                    $this->addToError(__('User not authorized to connect in GLPI'));\n                    $this->auth_succeded = false;\n                }\n            }\n        }\n\n       // Log Event (if possible)\n        if (!$DB->isSlave()) {\n           // GET THE IP OF THE CLIENT\n            $ip = getenv(\"HTTP_X_FORWARDED_FOR\") ?\n            Sanitizer::encodeHtmlSpecialChars(getenv(\"HTTP_X_FORWARDED_FOR\")) :\n            getenv(\"REMOTE_ADDR\");\n\n            if ($this->auth_succeded) {\n                if (GLPI_DEMO_MODE) {\n                    // not translation in GLPI_DEMO_MODE\n                    Event::log(0, \"system\", 3, \"login\", $login_name . \" log in from \" . $ip);\n                } else {\n                   //TRANS: %1$s is the login of the user and %2$s its IP address\n                    Event::log(0, \"system\", 3, \"login\", sprintf(\n                        __('%1$s log in from IP %2$s'),\n                        $login_name,\n                        $ip\n                    ));\n                }\n            } else {\n                if (GLPI_DEMO_MODE) {\n                    Event::log(\n                        0,\n                        \"system\",\n                        3,\n                        \"login\",\n                        \"login\",\n                        \"Connection failed for \" . $login_name . \" ($ip)\"\n                    );\n                } else {\n                   //TRANS: %1$s is the login of the user and %2$s its IP address\n                    Event::log(0, \"system\", 3, \"login\", sprintf(\n                        __('Failed login for %1$s from IP %2$s'),\n                        $login_name,\n                        $ip\n                    ));\n                }\n            }\n        }\n\n        Session::init($this);\n\n        if ($noauto) {\n            $_SESSION[\"noAUTO\"] = 1;\n        }\n\n        if ($this->auth_succeded && $CFG_GLPI['login_remember_time'] > 0 && $remember_me) {\n            $token = $this->user->getAuthToken('cookie_token', true);\n\n            if ($token) {\n                $data = json_encode([\n                    $this->user->fields['id'],\n                    $token,\n                ]);\n\n               //Send cookie to browser\n                Auth::setRememberMeCookie($data);\n            }\n        }\n\n        if ($this->auth_succeded && !empty($this->user->fields['timezone']) && 'null' !== strtolower($this->user->fields['timezone'])) {\n           //set user timezone, if any\n            $_SESSION['glpi_tz'] = $this->user->fields['timezone'];\n            $DB->setTimezone($this->user->fields['timezone']);\n        }\n\n        return $this->auth_succeded;\n    }\n\n    /**\n     * Print all the authentication methods\n     *\n     * @param array $options Possible options:\n     * - name : Name of the select (default is auths_id)\n     * - value : Selected value (default 0)\n     * - display : If true, the dropdown is displayed instead of returned (default true)\n     * - display_emptychoice : If true, an empty option is added (default true)\n     * - hide_if_no_elements  : boolean / hide dropdown if there is no elements (default false)\n     *\n     * @return void|string (Based on 'display' option)\n     */\n    public static function dropdown($options = [])\n    {\n        global $DB;\n\n        $p = [\n            'name'                => 'auths_id',\n            'value'               => 0,\n            'display'             => true,\n            'display_emptychoice' => true,\n            'hide_if_no_elements' => false,\n        ];\n\n        if (is_array($options) && count($options)) {\n            foreach ($options as $key => $val) {\n                $p[$key] = $val;\n            }\n        }\n\n        $methods = [\n            self::DB_GLPI => __('Authentication on GLPI database'),\n        ];\n\n        $result = $DB->request([\n            'FROM'   => 'glpi_authldaps',\n            'COUNT'  => 'cpt',\n            'WHERE'  => [\n                'is_active' => 1\n            ]\n        ])->current();\n\n        if ($result['cpt'] > 0) {\n            $methods[self::LDAP]     = __('Authentication on a LDAP directory');\n            $methods[self::EXTERNAL] = __('External authentications');\n        }\n\n        $result = $DB->request([\n            'FROM'   => 'glpi_authmails',\n            'COUNT'  => 'cpt',\n            'WHERE'  => [\n                'is_active' => 1\n            ]\n        ])->current();\n\n        if ($result['cpt'] > 0) {\n            $methods[self::MAIL] = __('Authentication on mail server');\n        }\n\n        return Dropdown::showFromArray($p['name'], $methods, $p);\n    }\n\n    /**\n     * Builds CAS versions dropdown\n     * @param string $value (default 'CAS_VERSION_2_0')\n     *\n     * @return string\n     */\n    public static function dropdownCasVersion($value = 'CAS_VERSION_2_0')\n    {\n        $options['CAS_VERSION_1_0'] = __('Version 1');\n        $options['CAS_VERSION_2_0'] = __('Version 2');\n        $options['CAS_VERSION_3_0'] = __('Version 3+');\n        return Dropdown::showFromArray('cas_version', $options, ['value' => $value]);\n    }\n\n    /**\n     * Get name of an authentication method\n     *\n     * @param integer $authtype Authentication method\n     * @param integer $auths_id Authentication method ID\n     * @param integer $link     show links to config page? (default 0)\n     * @param string  $name     override the name if not empty (default '')\n     *\n     * @return string\n     */\n    public static function getMethodName($authtype, $auths_id, $link = 0, $name = '')\n    {\n\n        switch ($authtype) {\n            case self::LDAP:\n                $auth = new AuthLDAP();\n                if ($auth->getFromDB($auths_id)) {\n                   //TRANS: %1$s is the auth method type, %2$s the auth method name or link\n                    return sprintf(__('%1$s: %2$s'), AuthLDAP::getTypeName(1), $auth->getLink());\n                }\n                return sprintf(__('%1$s: %2$s'), AuthLDAP::getTypeName(1), $name);\n\n            case self::MAIL:\n                $auth = new AuthMail();\n                if ($auth->getFromDB($auths_id)) {\n                    //TRANS: %1$s is the auth method type, %2$s the auth method name or link\n                    return sprintf(__('%1$s: %2$s'), AuthLDAP::getTypeName(1), $auth->getLink());\n                }\n                return sprintf(__('%1$s: %2$s'), __('Email server'), $name);\n\n            case self::CAS:\n                if ($auths_id > 0) {\n                    $auth = new AuthLDAP();\n                    if ($auth->getFromDB($auths_id)) {\n                        return sprintf(\n                            __('%1$s: %2$s'),\n                            sprintf(\n                                __('%1$s + %2$s'),\n                                __('CAS'),\n                                AuthLDAP::getTypeName(1)\n                            ),\n                            $auth->getLink()\n                        );\n                    }\n                }\n                return __('CAS');\n\n            case self::X509:\n                if ($auths_id > 0) {\n                    $auth = new AuthLDAP();\n                    if ($auth->getFromDB($auths_id)) {\n                        return sprintf(\n                            __('%1$s: %2$s'),\n                            sprintf(\n                                __('%1$s + %2$s'),\n                                __('x509 certificate authentication'),\n                                AuthLDAP::getTypeName(1)\n                            ),\n                            $auth->getLink()\n                        );\n                    }\n                }\n                return __('x509 certificate authentication');\n\n            case self::EXTERNAL:\n                if ($auths_id > 0) {\n                    $auth = new AuthLDAP();\n                    if ($auth->getFromDB($auths_id)) {\n                        return sprintf(\n                            __('%1$s: %2$s'),\n                            sprintf(\n                                __('%1$s + %2$s'),\n                                __('Other'),\n                                AuthLDAP::getTypeName(1)\n                            ),\n                            $auth->getLink()\n                        );\n                    }\n                }\n                return __('Other');\n\n            case self::DB_GLPI:\n                return __('GLPI internal database');\n\n            case self::API:\n                return __(\"API\");\n\n            case self::NOT_YET_AUTHENTIFIED:\n                return __('Not yet authenticated');\n        }\n        return '';\n    }\n\n    /**\n     * Get all the authentication methods parameters for a specific authtype\n     *  and auths_id and return it as an array\n     *\n     * @param integer $authtype Authentication method\n     * @param integer $auths_id Authentication method ID\n     *\n     * @return mixed\n     */\n    public static function getMethodsByID($authtype, $auths_id)\n    {\n\n        switch ($authtype) {\n            case self::X509:\n            case self::EXTERNAL:\n            case self::CAS:\n            case self::LDAP:\n                $auth = new AuthLDAP();\n                if ($auths_id > 0 && $auth->getFromDB($auths_id)) {\n                    return ($auth->fields);\n                }\n                break;\n\n            case self::MAIL:\n                $auth = new AuthMail();\n                if ($auths_id > 0 && $auth->getFromDB($auths_id)) {\n                    return ($auth->fields);\n                }\n                break;\n        }\n        return [];\n    }\n\n    /**\n     * Is an external authentication used?\n     *\n     * @return boolean\n     */\n    public static function useAuthExt()\n    {\n\n        global $CFG_GLPI;\n\n       //Get all the ldap directories\n        if (AuthLDAP::useAuthLdap()) {\n            return true;\n        }\n\n        if (AuthMail::useAuthMail()) {\n            return true;\n        }\n\n        if (!empty($CFG_GLPI[\"x509_email_field\"])) {\n            return true;\n        }\n\n       // Existing auth method\n        if (!empty($CFG_GLPI[\"ssovariables_id\"])) {\n            return true;\n        }\n\n       // Using CAS server\n        if (!empty($CFG_GLPI[\"cas_host\"])) {\n            return true;\n        }\n\n       // Using API login with personnal token\n        if (!empty($_REQUEST['user_token'])) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Is an alternate auth?\n     *\n     * @param integer $authtype auth type\n     *\n     * @return boolean\n     */\n    public static function isAlternateAuth($authtype)\n    {\n        return in_array($authtype, [self::X509, self::CAS, self::EXTERNAL, self::API, self::COOKIE]);\n    }\n\n    /**\n     * Check alternate authentication systems\n     *\n     * @param boolean $redirect        need to redirect (true) or get type of Auth system which match\n     *                                (false by default)\n     * @param string  $redirect_string redirect string if exists (default '')\n     *\n     * @return void|integer nothing if redirect is true, else Auth system ID\n     */\n    public static function checkAlternateAuthSystems($redirect = false, $redirect_string = '')\n    {\n        global $CFG_GLPI;\n\n        if (isset($_GET[\"noAUTO\"]) || isset($_POST[\"noAUTO\"])) {\n            return false;\n        }\n        $redir_string = \"\";\n        if (!empty($redirect_string)) {\n            $redir_string = \"?redirect=\" . $redirect_string;\n        }\n       // Using x509 server\n        if (\n            !empty($CFG_GLPI[\"x509_email_field\"])\n            && isset($_SERVER['SSL_CLIENT_S_DN'])\n            && strstr($_SERVER['SSL_CLIENT_S_DN'], $CFG_GLPI[\"x509_email_field\"])\n        ) {\n            if ($redirect) {\n                Html::redirect($CFG_GLPI[\"root_doc\"] . \"/front/login.php\" . $redir_string);\n            } else {\n                return self::X509;\n            }\n        }\n       // Existing auth method\n       //Look for the field in $_SERVER AND $_REQUEST\n       // MoYo : checking REQUEST create a security hole for me !\n        $ssovariable = Dropdown::getDropdownName('glpi_ssovariables', $CFG_GLPI[\"ssovariables_id\"]);\n        if (\n            $CFG_GLPI[\"ssovariables_id\"]\n            && ((isset($_SERVER[$ssovariable]) && !empty($_SERVER[$ssovariable]))\n              /*|| (isset($_REQUEST[$ssovariable]) && !empty($_REQUEST[$ssovariable]))*/)\n        ) {\n            if ($redirect) {\n                Html::redirect($CFG_GLPI[\"root_doc\"] . \"/front/login.php\" . $redir_string);\n            } else {\n                return self::EXTERNAL;\n            }\n        }\n\n       // using user token for api login\n        if (!empty($_REQUEST['user_token'])) {\n            return self::API;\n        }\n\n       // Using CAS server\n        if (!empty($CFG_GLPI[\"cas_host\"])) {\n            if ($redirect) {\n                Html::redirect($CFG_GLPI[\"root_doc\"] . \"/front/login.php\" . $redir_string);\n            } else {\n                return self::CAS;\n            }\n        }\n\n        $cookie_name = session_name() . '_rememberme';\n        if ($CFG_GLPI[\"login_remember_time\"] && isset($_COOKIE[$cookie_name])) {\n            if ($redirect) {\n                Html::redirect($CFG_GLPI[\"root_doc\"] . \"/front/login.php\" . $redir_string);\n            } else {\n                return self::COOKIE;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Redirect user to page if authenticated\n     *\n     * @param string $redirect redirect string if exists, if null, check in $_POST or $_GET\n     *\n     * @return void|boolean nothing if redirect is true, else false\n     */\n    public static function redirectIfAuthenticated($redirect = null)\n    {\n        global $CFG_GLPI;\n\n        if (!Session::getLoginUserID()) {\n            return false;\n        }\n\n        if (Session::mustChangePassword()) {\n            Html::redirect($CFG_GLPI['root_doc'] . '/front/updatepassword.php');\n        }\n\n        if (!$redirect) {\n            if (isset($_POST['redirect']) && (strlen($_POST['redirect']) > 0)) {\n                $redirect = $_POST['redirect'];\n            } else if (isset($_GET['redirect']) && strlen($_GET['redirect']) > 0) {\n                $redirect = $_GET['redirect'];\n            }\n        }\n\n       //Direct redirect\n        if ($redirect) {\n            Toolbox::manageRedirect($redirect);\n        }\n\n       // Redirect to Command Central if not post-only\n        if (Session::getCurrentInterface() == \"helpdesk\") {\n            if ($_SESSION['glpiactiveprofile']['create_ticket_on_login']) {\n                Html::redirect($CFG_GLPI['root_doc'] . \"/front/helpdesk.public.php?create_ticket=1\");\n            }\n            Html::redirect($CFG_GLPI['root_doc'] . \"/front/helpdesk.public.php\");\n        } else {\n            if ($_SESSION['glpiactiveprofile']['create_ticket_on_login']) {\n                Html::redirect(Ticket::getFormURL());\n            }\n            Html::redirect($CFG_GLPI['root_doc'] . \"/front/central.php\");\n        }\n    }\n\n    /**\n     * Display refresh button in the user page\n     *\n     * @param User $user User object\n     *\n     * @return void\n     */\n    public static function showSynchronizationForm(User $user)\n    {\n        global $DB, $CFG_GLPI;\n\n        if (Session::haveRight(\"user\", User::UPDATEAUTHENT)) {\n            echo \"<form method='post' action='\" . Toolbox::getItemTypeFormURL('User') . \"'>\";\n            echo \"<div class='firstbloc'>\";\n            echo \"<input type='hidden' name='id' value='\" . $user->getID() . \"'>\";\n\n            switch ($user->getField('authtype')) {\n                case self::CAS:\n                case self::EXTERNAL:\n                case self::X509:\n                case self::LDAP:\n                   //Look it the auth server still exists !\n                   // <- Bad idea : id not exists unable to change anything\n                    $authldap = new AuthLDAP();\n                    if (\n                        $authldap->getFromDBByCrit([\n                            'id'        => $user->getField('auths_id'),\n                            'is_active' => 1,\n                        ])\n                    ) {\n                        echo Html::submit(\"<i class='fas fa-sync-alt'></i><span>\" . __s('Force synchronization') . \"</span>\", [\n                            'name' => 'force_ldap_resynch'\n                        ]);\n\n                        if (strlen($authldap->fields['sync_field']) > 0) {\n                            echo Html::submit(\"<i class='fas fa-broom'></i><span>\" . __s('Clean LDAP fields and force synchronisation') . \"</span>\", [\n                                'name' => 'clean_ldap_fields'\n                            ]);\n                        }\n                    }\n                    break;\n\n                case self::DB_GLPI:\n                case self::MAIL:\n                    break;\n            }\n\n            echo \"</div>\";\n\n            echo \"<div class='spaced'>\";\n            echo \"<h3>\" . __('Change of the authentication method') . \"</h3>\";\n            $rand             = self::dropdown(['name' => 'authtype']);\n            $paramsmassaction = ['authtype' => '__VALUE__',\n                'name'     => 'change_auth_method'\n            ];\n            Ajax::updateItemOnSelectEvent(\n                \"dropdown_authtype$rand\",\n                \"show_massiveaction_field\",\n                $CFG_GLPI[\"root_doc\"] . \"/ajax/dropdownMassiveActionAuthMethods.php\",\n                $paramsmassaction\n            );\n            echo \"<span id='show_massiveaction_field'></span>\";\n            echo \"</div>\";\n            Html::closeForm();\n        }\n    }\n\n    /**\n     * Check if a login is valid\n     *\n     * @param string $login login to check\n     *\n     * @return boolean\n     */\n    public static function isValidLogin($login)\n    {\n        return $login !== null && preg_match(\"/^[[:alnum:]'@.\\-_ ]+$/iu\", $login);\n    }\n\n    public function getTabNameForItem(CommonGLPI $item, $withtemplate = 0)\n    {\n\n        if (!$withtemplate) {\n            switch ($item->getType()) {\n                case 'User':\n                    if (Session::haveRight(\"user\", User::UPDATEAUTHENT)) {\n                        return __('Synchronization');\n                    }\n                    break;\n            }\n        }\n        return '';\n    }\n\n    /**\n     * Show Tab content\n     *\n     * @since 0.83\n     *\n     * @param CommonGLPI $item         Item instance\n     * @param integer    $tabnum       Unused (default 0)\n     * @param integer    $withtemplate Unused (default 0)\n     *\n     * @return boolean\n     */\n    public static function displayTabContentForItem(CommonGLPI $item, $tabnum = 1, $withtemplate = 0)\n    {\n\n        if ($item->getType() == 'User') {\n            self::showSynchronizationForm($item);\n        }\n        return true;\n    }\n\n    /**\n     * Show form for authentication configuration.\n     *\n     * @return void|boolean False if the form is not shown due to right error. Form is directly printed.\n     */\n    public static function showOtherAuthList()\n    {\n        global $CFG_GLPI;\n\n        if (!Config::canUpdate()) {\n            return false;\n        }\n        echo \"<form name=cas action='\" . $CFG_GLPI['root_doc'] . \"/front/auth.others.php' method='post'>\";\n        echo \"<div class='card'>\";\n        echo \"<table class='tab_cadre_fixe'>\";\n\n       // CAS config\n        echo \"<tr><th>\" . __('CAS authentication') . '</th><th>';\n        if (!empty($CFG_GLPI[\"cas_host\"])) {\n            echo _x('authentication', 'Enabled');\n        }\n        echo \"</th></tr>\";\n\n        if (\n            function_exists('curl_init')\n            && Toolbox::canUseCAS()\n        ) {\n           //TRANS: for CAS SSO system\n            echo \"<tr class='tab_bg_2'><td class='center'>\" . __('CAS Host') . \"</td>\";\n            echo \"<td><input type='text' class='form-control' name='cas_host' value=\\\"\" . $CFG_GLPI[\"cas_host\"] . \"\\\"></td></tr>\";\n           //TRANS: for CAS SSO system\n            echo \"<tr class='tab_bg_2'><td class='center'>\" . __('CAS Version') . \"</td>\";\n            echo \"<td>\";\n            Auth::dropdownCasVersion($CFG_GLPI[\"cas_version\"]);\n            echo \"</td>\";\n            echo \"</tr>\";\n           //TRANS: for CAS SSO system\n            echo \"<tr class='tab_bg_2'><td class='center'>\" . _n('Port', 'Ports', 1) . \"</td>\";\n            echo \"<td><input type='text' class='form-control' name='cas_port' value=\\\"\" . $CFG_GLPI[\"cas_port\"] . \"\\\"></td></tr>\";\n           //TRANS: for CAS SSO system\n            echo \"<tr class='tab_bg_2'><td class='center'>\" . __('Root directory (optional)') . \"</td>\";\n            echo \"<td><input type='text' class='form-control' name='cas_uri' value=\\\"\" . $CFG_GLPI[\"cas_uri\"] . \"\\\"></td></tr>\";\n           //TRANS: for CAS SSO system\n            echo \"<tr class='tab_bg_2'><td class='center'>\" . __('Log out fallback URL') . \"</td>\";\n            echo \"<td><input type='text' class='form-control' name='cas_logout' value=\\\"\" . $CFG_GLPI[\"cas_logout\"] . \"\\\"></td>\" .\n              \"</tr>\";\n        } else {\n            echo \"<tr class='tab_bg_2'><td class='center' colspan='2'>\";\n            if (!function_exists('curl_init')) {\n                echo \"<p class='red'>\" . __(\"The CURL extension for your PHP parser isn't installed\");\n                echo \"</p>\";\n            }\n            if (!Toolbox::canUseCAS()) {\n                echo \"<p class='red'>\" . __(\"The CAS lib isn't available, GLPI doesn't package it anymore for license compatibility issue.\");\n                echo \"</p>\";\n            }\n            echo \"<p>\" . __('Impossible to use CAS as external source of connection') . \"</p>\";\n            echo \"<p><strong>\" . GLPINetwork::getSupportPromoteMessage() . \"</strong></p>\";\n\n            echo \"</td></tr>\";\n        }\n       // X509 config\n        echo \"<tr><th>\" . __('x509 certificate authentication') . \"</th><th>\";\n        if (!empty($CFG_GLPI[\"x509_email_field\"])) {\n            echo _x('authentication', 'Enabled');\n        }\n        echo \"</th></tr>\";\n        echo \"<tr class='tab_bg_2'>\";\n        echo \"<td class='center'>\" . __('Email attribute for x509 authentication') . \"</td>\";\n        echo \"<td><input type='text' class='form-control' name='x509_email_field' value=\\\"\" . $CFG_GLPI[\"x509_email_field\"] . \"\\\">\";\n        echo \"</td></tr>\";\n        echo \"<tr class='tab_bg_2'>\";\n        echo \"<td class='center'>\" . sprintf(__('Restrict %s field for x509 authentication (separator $)'), 'OU') . \"</td>\";\n        echo \"<td><input type='text' class='form-control' name='x509_ou_restrict' value=\\\"\" . $CFG_GLPI[\"x509_ou_restrict\"] . \"\\\">\";\n        echo \"</td></tr>\";\n        echo \"<tr class='tab_bg_2'>\";\n        echo \"<td class='center'>\" . sprintf(__('Restrict %s field for x509 authentication (separator $)'), 'CN') . \"</td>\";\n        echo \"<td><input type='text' class='form-control' name='x509_cn_restrict' value=\\\"\" . $CFG_GLPI[\"x509_cn_restrict\"] . \"\\\">\";\n        echo \"</td></tr>\";\n        echo \"<tr class='tab_bg_2'>\";\n        echo \"<td class='center'>\" . sprintf(__('Restrict %s field for x509 authentication (separator $)'), 'O') . \"</td>\";\n        echo \"<td><input type='text' class='form-control' name='x509_o_restrict' value=\\\"\" . $CFG_GLPI[\"x509_o_restrict\"] . \"\\\">\";\n        echo \"</td></tr>\";\n\n       //Other configuration\n        echo \"<tr><th>\" . __('Other authentication sent in the HTTP request') . \"</th><th>\";\n        if (!empty($CFG_GLPI[\"ssovariables_id\"])) {\n            echo _x('authentication', 'Enabled');\n        }\n        echo \"</th></tr>\";\n        echo \"<tr class='tab_bg_2'>\";\n        echo \"<td class='center'>\" . SsoVariable::getTypeName(1) . \"</td>\";\n        echo \"<td>\";\n        SsoVariable::dropdown(['name'  => 'ssovariables_id',\n            'value' => $CFG_GLPI[\"ssovariables_id\"]\n        ]);\n        echo \"</td>\";\n        echo \"</tr>\";\n\n        echo \"<tr class='tab_bg_2'>\";\n        echo \"<td class='center'>\" . __('SSO logout url') . \"</td>\";\n        echo \"<td><input type='text' class='form-control' name='ssologout_url' value='\" .\n                 $CFG_GLPI['ssologout_url'] . \"'></td>\";\n        echo \"</tr>\";\n\n        echo \"<tr class='tab_bg_2'>\";\n        echo \"<td class='center'>\" . __('Remove the domain of logins like login@domain') . \"</td><td>\";\n        Dropdown::showYesNo(\n            'existing_auth_server_field_clean_domain',\n            $CFG_GLPI['existing_auth_server_field_clean_domain']\n        );\n        echo \"</td></tr>\";\n\n        echo \"<tr class='tab_bg_2'>\";\n        echo \"<td class='center'>\" . __('Surname') . \"</td>\";\n        echo \"<td><input type='text' class='form-control' name='realname_ssofield' value='\" .\n                 $CFG_GLPI['realname_ssofield'] . \"'></td>\";\n        echo \"</tr>\";\n\n        echo \"<tr class='tab_bg_2'>\";\n        echo \"<td class='center'>\" . __('First name') . \"</td>\";\n        echo \"<td><input type='text' class='form-control' name='firstname_ssofield' value='\" .\n                 $CFG_GLPI['firstname_ssofield'] . \"'></td>\";\n        echo \"</tr>\";\n\n        echo \"<tr class='tab_bg_2'>\";\n        echo \"<td class='center'>\" . __('Comments') . \"</td>\";\n        echo \"<td><input type='text' class='form-control' name='comment_ssofield' value='\" .\n                 $CFG_GLPI['comment_ssofield'] . \"'>\";\n        echo \"</td>\";\n        echo \"</tr>\";\n\n        echo \"<tr class='tab_bg_2'>\";\n        echo \"<td class='center'>\" . _x('user', 'Administrative number') . \"</td>\";\n        echo \"<td><input type='text' class='form-control' name='registration_number_ssofield' value='\" .\n                  $CFG_GLPI['registration_number_ssofield'] . \"'>\";\n        echo \"</td>\";\n        echo \"</tr>\";\n\n        echo \"<tr class='tab_bg_2'>\";\n        echo \"<td class='center'>\" . _n('Email', 'Emails', 1) . \"</td>\";\n        echo \"<td><input type='text' class='form-control' name='email1_ssofield' value='\" . $CFG_GLPI['email1_ssofield'] . \"'>\";\n        echo \"</td>\";\n        echo \"</tr>\";\n\n        echo \"<tr class='tab_bg_2'>\";\n        echo \"<td class='center'>\" . sprintf(__('%1$s %2$s'), _n('Email', 'Emails', 1), '2') . \"</td>\";\n        echo \"<td><input type='text' class='form-control' name='email2_ssofield' value='\" . $CFG_GLPI['email2_ssofield'] . \"'>\";\n        echo \"</td>\";\n        echo \"</tr>\";\n\n        echo \"<tr class='tab_bg_2'>\";\n        echo \"<td class='center'>\" . sprintf(__('%1$s %2$s'), _n('Email', 'Emails', 1), '3') . \"</td>\";\n        echo \"<td><input type='text' class='form-control' name='email3_ssofield' value='\" . $CFG_GLPI['email3_ssofield'] . \"'>\";\n        echo \"</td>\";\n        echo \"</tr>\";\n\n        echo \"<tr class='tab_bg_2'>\";\n        echo \"<td class='center'>\" . sprintf(__('%1$s %2$s'), _n('Email', 'Emails', 1), '4') . \"</td>\";\n        echo \"<td><input type='text' class='form-control' name='email4_ssofield' value='\" . $CFG_GLPI['email4_ssofield'] . \"'>\";\n        echo \"</td>\";\n        echo \"</tr>\";\n\n        echo \"<tr class='tab_bg_2'>\";\n        echo \"<td class='center'>\" . Phone::getTypeName(1) . \"</td>\";\n        echo \"<td><input type='text' class='form-control' name='phone_ssofield' value='\" . $CFG_GLPI['phone_ssofield'] . \"'>\";\n        echo \"</td>\";\n        echo \"</tr>\";\n\n        echo \"<tr class='tab_bg_2'>\";\n        echo \"<td class='center'>\" .  __('Phone 2') . \"</td>\";\n        echo \"<td><input type='text' class='form-control' name='phone2_ssofield' value='\" . $CFG_GLPI['phone2_ssofield'] . \"'>\";\n        echo \"</td>\";\n        echo \"</tr>\";\n\n        echo \"<tr class='tab_bg_2'>\";\n        echo \"<td class='center'>\" . __('Mobile phone') . \"</td>\";\n        echo \"<td><input type='text' class='form-control' name='mobile_ssofield' value='\" . $CFG_GLPI['mobile_ssofield'] . \"'>\";\n        echo \"</td>\";\n        echo \"</tr>\";\n\n        echo \"<tr class='tab_bg_2'>\";\n        echo \"<td class='center'>\" . _x('person', 'Title') . \"</td>\";\n        echo \"<td><input type='text' class='form-control' name='title_ssofield' value='\" . $CFG_GLPI['title_ssofield'] . \"'>\";\n        echo \"</td>\";\n        echo \"</tr>\";\n\n        echo \"<tr class='tab_bg_2'>\";\n        echo \"<td class='center'>\" . _n('Category', 'Categories', 1) . \"</td>\";\n        echo \"<td><input type='text' class='form-control' name='category_ssofield' value='\" .\n                 $CFG_GLPI['category_ssofield'] . \"'></td>\";\n        echo \"</tr>\";\n\n        echo \"<tr class='tab_bg_2'>\";\n        echo \"<td class='center'>\" . __('Language') . \"</td>\";\n        echo \"<td><input type='text' class='form-control' name='language_ssofield' value='\" .\n                 $CFG_GLPI['language_ssofield'] . \"'></td></tr>\";\n\n        echo \"<tr class='tab_bg_1'><td class='center' colspan='2'>\";\n        echo \"<input type='submit' name='update' class='btn btn-primary' value=\\\"\" . __s('Save') . \"\\\" >\";\n        echo \"</td></tr>\";\n\n        echo \"</table></div>\";\n        Html::closeForm();\n    }\n\n    /**\n     * Get authentication methods available\n     *\n     * @return array\n     */\n    public static function getLoginAuthMethods()\n    {\n        global $DB;\n\n        $elements = [\n            '_default'  => 'local',\n            'local'     => __(\"GLPI internal database\")\n        ];\n\n       // Get LDAP\n        if (Toolbox::canUseLdap()) {\n            $iterator = $DB->request([\n                'FROM'   => 'glpi_authldaps',\n                'WHERE'  => [\n                    'is_active' => 1\n                ],\n                'ORDER'  => ['name']\n            ]);\n            foreach ($iterator as $data) {\n                $elements['ldap-' . $data['id']] = $data['name'];\n                if ($data['is_default'] == 1) {\n                    $elements['_default'] = 'ldap-' . $data['id'];\n                }\n            }\n        }\n\n       // GET Mail servers\n        $iterator = $DB->request([\n            'FROM'   => 'glpi_authmails',\n            'WHERE'  => [\n                'is_active' => 1\n            ],\n            'ORDER'  => ['name']\n        ]);\n        foreach ($iterator as $data) {\n            $elements['mail-' . $data['id']] = $data['name'];\n        }\n\n        return $elements;\n    }\n\n    /**\n     * Display the authentication source dropdown for login form\n     */\n    public static function dropdownLogin(bool $display = true)\n    {\n        $out = \"\";\n        $elements = self::getLoginAuthMethods();\n        $default = $elements['_default'];\n        unset($elements['_default']);\n       // show dropdown of login src only when multiple src\n        $out .= Dropdown::showFromArray('auth', $elements, [\n            'display'   => false,\n            'rand'      => '1',\n            'value'     => $default,\n            'width'     => '100%'\n        ]);\n\n        if ($display) {\n            echo $out;\n            return \"\";\n        }\n\n        return $out;\n    }\n\n\n    public static function getIcon()\n    {\n        return \"ti ti-login\";\n    }\n\n    /**\n     * Defines \"rememberme\" cookie.\n     *\n     * @param string $cookie_value\n     *\n     * @return void\n     */\n    public static function setRememberMeCookie(string $cookie_value): void\n    {\n        global $CFG_GLPI;\n\n        $cookie_name     = session_name() . '_rememberme';\n        $cookie_lifetime = empty($cookie_value) ? time() - 3600 : time() + $CFG_GLPI['login_remember_time'];\n        $cookie_path     = ini_get('session.cookie_path');\n        $cookie_domain   = ini_get('session.cookie_domain');\n        $cookie_secure   = (bool)ini_get('session.cookie_secure');\n\n        if (empty($cookie_value) && !isset($_COOKIE[$cookie_name])) {\n            return;\n        }\n\n        setcookie($cookie_name, $cookie_value, $cookie_lifetime, $cookie_path, $cookie_domain, $cookie_secure, true);\n\n        if (empty($cookie_value)) {\n            unset($_COOKIE[$cookie_name]);\n        } else {\n            $_COOKIE[$cookie_name] = $cookie_value;\n        }\n    }\n}\n"], "filenames": ["src/Auth.php"], "buggy_code_start_loc": [739], "buggy_code_end_loc": [752], "fixing_code_start_loc": [739], "fixing_code_end_loc": [749], "type": "CWE-89", "message": "GLPI is a Free Asset and IT Management Software package, Data center management, ITIL Service Desk, licenses tracking and software auditing. In affected versions there is a SQL injection vulnerability which is possible on login page. No user credentials are required to exploit this vulnerability. Users are advised to upgrade as soon as possible. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-31061", "sourceIdentifier": "security-advisories@github.com", "published": "2022-06-28T18:15:08.430", "lastModified": "2022-07-07T16:47:11.150", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "GLPI is a Free Asset and IT Management Software package, Data center management, ITIL Service Desk, licenses tracking and software auditing. In affected versions there is a SQL injection vulnerability which is possible on login page. No user credentials are required to exploit this vulnerability. Users are advised to upgrade as soon as possible. There are no known workarounds for this issue."}, {"lang": "es", "value": "GLPI es un paquete de software gratuito de administraci\u00f3n de activos y TI, administraci\u00f3n de centros de datos, ITIL Service Desk, seguimiento de licencias y auditor\u00eda de software. En las versiones afectadas se presenta una vulnerabilidad de inyecci\u00f3n SQL que es posible en la p\u00e1gina de inicio de sesi\u00f3n. No son requeridas credenciales de usuario para explotar esta vulnerabilidad. Es recomendado a usuarios actualizar lo antes posible. No se presentan mitigaciones conocidas para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:glpi-project:glpi:*:*:*:*:*:*:*:*", "versionStartIncluding": "9.3.0", "versionEndExcluding": "9.5.8", "matchCriteriaId": "0C62EFBE-E0E7-4665-8D9A-8981B554001E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:glpi-project:glpi:*:*:*:*:*:*:*:*", "versionStartIncluding": "10.0.0", "versionEndExcluding": "10.0.2", "matchCriteriaId": "6CB71059-6156-42BE-8A8D-73F053C080C7"}]}]}], "references": [{"url": "https://github.com/glpi-project/glpi/commit/21ae07d00d0b3230f6235386e98388cfc5bb0514", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/glpi-project/glpi/security/advisories/GHSA-w2gc-v2gm-q7wq", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/glpi-project/glpi/commit/21ae07d00d0b3230f6235386e98388cfc5bb0514"}}