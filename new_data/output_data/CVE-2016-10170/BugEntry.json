{"buggy_code": ["////////////////////////////////////////////////////////////////////////////\n//                           **** WAVPACK ****                            //\n//                  Hybrid Lossless Wavefile Compressor                   //\n//                Copyright (c) 1998 - 2016 David Bryant.                 //\n//                          All Rights Reserved.                          //\n//      Distributed under the BSD Software License (see license.txt)      //\n////////////////////////////////////////////////////////////////////////////\n\n// open_utils.c\n\n// This module provides all the code required to open an existing WavPack file\n// for reading by using a reader callback mechanism (NOT a filename). This\n// includes the code required to find and parse WavPack blocks, process any\n// included metadata, and queue up the bitstreams containing the encoded audio\n// data. It does not the actual code to unpack audio data and this was done so\n// that programs that just want to query WavPack files for information (like,\n// for example, taggers) don't need to link in a lot of unnecessary code.\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"wavpack_local.h\"\n\n// This function is identical to WavpackOpenFileInput() except that instead\n// of providing a filename to open, the caller provides a pointer to a set of\n// reader callbacks and instances of up to two streams. The first of these\n// streams is required and contains the regular WavPack data stream; the second\n// contains the \"correction\" file if desired. Unlike the standard open\n// function which handles the correction file transparently, in this case it\n// is the responsibility of the caller to be aware of correction files.\n\nstatic int seek_eof_information (WavpackContext *wpc, int64_t *final_index, int get_wrapper);\n\nWavpackContext *WavpackOpenFileInputEx64 (WavpackStreamReader64 *reader, void *wv_id, void *wvc_id, char *error, int flags, int norm_offset)\n{\n    WavpackContext *wpc = malloc (sizeof (WavpackContext));\n    WavpackStream *wps;\n    int num_blocks = 0;\n    unsigned char first_byte;\n    uint32_t bcount;\n\n    if (!wpc) {\n        if (error) strcpy (error, \"can't allocate memory\");\n        return NULL;\n    }\n\n    CLEAR (*wpc);\n    wpc->wv_in = wv_id;\n    wpc->wvc_in = wvc_id;\n    wpc->reader = reader;\n    wpc->total_samples = -1;\n    wpc->norm_offset = norm_offset;\n    wpc->max_streams = OLD_MAX_STREAMS;     // use this until overwritten with actual number\n    wpc->open_flags = flags;\n\n    wpc->filelen = wpc->reader->get_length (wpc->wv_in);\n\n#ifndef NO_TAGS\n    if ((flags & (OPEN_TAGS | OPEN_EDIT_TAGS)) && wpc->reader->can_seek (wpc->wv_in)) {\n        load_tag (wpc);\n        wpc->reader->set_pos_abs (wpc->wv_in, 0);\n\n        if ((flags & OPEN_EDIT_TAGS) && !editable_tag (&wpc->m_tag)) {\n            if (error) strcpy (error, \"can't edit tags located at the beginning of files!\");\n            return WavpackCloseFile (wpc);\n        }\n    }\n#endif\n\n    if (wpc->reader->read_bytes (wpc->wv_in, &first_byte, 1) != 1) {\n        if (error) strcpy (error, \"can't read all of WavPack file!\");\n        return WavpackCloseFile (wpc);\n    }\n\n    wpc->reader->push_back_byte (wpc->wv_in, first_byte);\n\n    if (first_byte == 'R') {\n#ifdef ENABLE_LEGACY\n        return open_file3 (wpc, error);\n#else\n        if (error) strcpy (error, \"this legacy WavPack file is deprecated, use version 4.80.0 to transcode\");\n        return WavpackCloseFile (wpc);\n#endif\n    }\n\n    wpc->streams = malloc ((wpc->num_streams = 1) * sizeof (wpc->streams [0]));\n    if (!wpc->streams) {\n        if (error) strcpy (error, \"can't allocate memory\");\n        return WavpackCloseFile (wpc);\n    }\n\n    wpc->streams [0] = wps = malloc (sizeof (WavpackStream));\n    if (!wps) {\n        if (error) strcpy (error, \"can't allocate memory\");\n        return WavpackCloseFile (wpc);\n    }\n    CLEAR (*wps);\n\n    while (!wps->wphdr.block_samples) {\n\n        wpc->filepos = wpc->reader->get_pos (wpc->wv_in);\n        bcount = read_next_header (wpc->reader, wpc->wv_in, &wps->wphdr);\n\n        if (bcount == (uint32_t) -1 ||\n            (!wps->wphdr.block_samples && num_blocks++ > 16)) {\n                if (error) strcpy (error, \"not compatible with this version of WavPack file!\");\n                return WavpackCloseFile (wpc);\n        }\n\n        wpc->filepos += bcount;\n        wps->blockbuff = malloc (wps->wphdr.ckSize + 8);\n        if (!wps->blockbuff) {\n            if (error) strcpy (error, \"can't allocate memory\");\n            return WavpackCloseFile (wpc);\n        }\n        memcpy (wps->blockbuff, &wps->wphdr, 32);\n\n        if (wpc->reader->read_bytes (wpc->wv_in, wps->blockbuff + 32, wps->wphdr.ckSize - 24) != wps->wphdr.ckSize - 24) {\n            if (error) strcpy (error, \"can't read all of WavPack file!\");\n            return WavpackCloseFile (wpc);\n        }\n\n        // if block does not verify, flag error, free buffer, and continue\n        if (!WavpackVerifySingleBlock (wps->blockbuff, !(flags & OPEN_NO_CHECKSUM))) {\n            wps->wphdr.block_samples = 0;\n            free (wps->blockbuff);\n            wps->blockbuff = NULL;\n            wpc->crc_errors++;\n            continue;\n        }\n\n        wps->init_done = FALSE;\n\n        if (wps->wphdr.block_samples) {\n            if (flags & OPEN_STREAMING)\n                SET_BLOCK_INDEX (wps->wphdr, 0);\n            else if (wpc->total_samples == -1) {\n                if (GET_BLOCK_INDEX (wps->wphdr) || GET_TOTAL_SAMPLES (wps->wphdr) == -1) {\n                    wpc->initial_index = GET_BLOCK_INDEX (wps->wphdr);\n                    SET_BLOCK_INDEX (wps->wphdr, 0);\n\n                    if (wpc->reader->can_seek (wpc->wv_in)) {\n                        int64_t final_index = -1;\n\n                        seek_eof_information (wpc, &final_index, FALSE);\n\n                        if (final_index != -1)\n                            wpc->total_samples = final_index - wpc->initial_index;\n                    }\n                }\n                else\n                    wpc->total_samples = GET_TOTAL_SAMPLES (wps->wphdr);\n            }\n        }\n        else if (wpc->total_samples == -1 && !GET_BLOCK_INDEX (wps->wphdr) && GET_TOTAL_SAMPLES (wps->wphdr))\n            wpc->total_samples = GET_TOTAL_SAMPLES (wps->wphdr);\n\n        if (wpc->wvc_in && wps->wphdr.block_samples && (wps->wphdr.flags & HYBRID_FLAG)) {\n            unsigned char ch;\n\n            if (wpc->reader->read_bytes (wpc->wvc_in, &ch, 1) == 1) {\n                wpc->reader->push_back_byte (wpc->wvc_in, ch);\n                wpc->file2len = wpc->reader->get_length (wpc->wvc_in);\n                wpc->wvc_flag = TRUE;\n            }\n        }\n\n        if (wpc->wvc_flag && !read_wvc_block (wpc)) {\n            if (error) strcpy (error, \"not compatible with this version of correction file!\");\n            return WavpackCloseFile (wpc);\n        }\n\n        if (!wps->init_done && !unpack_init (wpc)) {\n            if (error) strcpy (error, wpc->error_message [0] ? wpc->error_message :\n                \"not compatible with this version of WavPack file!\");\n\n            return WavpackCloseFile (wpc);\n        }\n\n        wps->init_done = TRUE;\n    }\n\n    wpc->config.flags &= ~0xff;\n    wpc->config.flags |= wps->wphdr.flags & 0xff;\n\n    if (!wpc->config.num_channels) {\n        wpc->config.num_channels = (wps->wphdr.flags & MONO_FLAG) ? 1 : 2;\n        wpc->config.channel_mask = 0x5 - wpc->config.num_channels;\n    }\n\n    if ((flags & OPEN_2CH_MAX) && !(wps->wphdr.flags & FINAL_BLOCK))\n        wpc->reduced_channels = (wps->wphdr.flags & MONO_FLAG) ? 1 : 2;\n\n    if (wps->wphdr.flags & DSD_FLAG) {\n#ifdef ENABLE_DSD\n        if (flags & OPEN_DSD_NATIVE) {\n            wpc->config.bytes_per_sample = 1;\n            wpc->config.bits_per_sample = 8;\n        }\n        else if (flags & OPEN_DSD_AS_PCM) {\n            wpc->decimation_context = decimate_dsd_init (wpc->reduced_channels ?\n                wpc->reduced_channels : wpc->config.num_channels);\n\n            wpc->config.bytes_per_sample = 3;\n            wpc->config.bits_per_sample = 24;\n        }\n        else {\n            if (error) strcpy (error, \"not configured to handle DSD WavPack files!\");\n            return WavpackCloseFile (wpc);\n        }\n#else\n        if (error) strcpy (error, \"not configured to handle DSD WavPack files!\");\n        return WavpackCloseFile (wpc);\n#endif\n    }\n    else {\n        wpc->config.bytes_per_sample = (wps->wphdr.flags & BYTES_STORED) + 1;\n        wpc->config.float_norm_exp = wps->float_norm_exp;\n\n        wpc->config.bits_per_sample = (wpc->config.bytes_per_sample * 8) -\n            ((wps->wphdr.flags & SHIFT_MASK) >> SHIFT_LSB);\n    }\n\n    if (!wpc->config.sample_rate) {\n        if (!wps->wphdr.block_samples || (wps->wphdr.flags & SRATE_MASK) == SRATE_MASK)\n            wpc->config.sample_rate = 44100;\n        else\n            wpc->config.sample_rate = sample_rates [(wps->wphdr.flags & SRATE_MASK) >> SRATE_LSB];\n    }\n\n    return wpc;\n}\n\n// This function returns the major version number of the WavPack program\n// (or library) that created the open file. Currently, this can be 1 to 5.\n// Minor versions are not recorded in WavPack files.\n\nint WavpackGetVersion (WavpackContext *wpc)\n{\n    if (wpc) {\n#ifdef ENABLE_LEGACY\n        if (wpc->stream3)\n            return get_version3 (wpc);\n#endif\n        return wpc->version_five ? 5 : 4;\n    }\n\n    return 0;\n}\n\n// Return the file format specified in the call to WavpackSetFileInformation()\n// when the file was created. For all files created prior to WavPack 5.0 this\n// will 0 (WP_FORMAT_WAV).\n\nunsigned char WavpackGetFileFormat (WavpackContext *wpc)\n{\n    return wpc->file_format;\n}\n\n// Return a string representing the recommended file extension for the open\n// WavPack file. For all files created prior to WavPack 5.0 this will be \"wav\",\n// even for raw files with no RIFF into. This string is specified in the\n// call to WavpackSetFileInformation() when the file was created.\n\nchar *WavpackGetFileExtension (WavpackContext *wpc)\n{\n    if (wpc && wpc->file_extension [0])\n        return wpc->file_extension;\n    else\n        return \"wav\";\n}\n\n// This function initializes everything required to unpack a WavPack block\n// and must be called before unpack_samples() is called to obtain audio data.\n// It is assumed that the WavpackHeader has been read into the wps->wphdr\n// (in the current WavpackStream) and that the entire block has been read at\n// wps->blockbuff. If a correction file is available (wpc->wvc_flag = TRUE)\n// then the corresponding correction block must be read into wps->block2buff\n// and its WavpackHeader has overwritten the header at wps->wphdr. This is\n// where all the metadata blocks are scanned including those that contain\n// bitstream data.\n\nstatic int read_metadata_buff (WavpackMetadata *wpmd, unsigned char *blockbuff, unsigned char **buffptr);\nstatic int process_metadata (WavpackContext *wpc, WavpackMetadata *wpmd);\nstatic void bs_open_read (Bitstream *bs, void *buffer_start, void *buffer_end);\n\nint unpack_init (WavpackContext *wpc)\n{\n    WavpackStream *wps = wpc->streams [wpc->current_stream];\n    unsigned char *blockptr, *block2ptr;\n    WavpackMetadata wpmd;\n\n    wps->num_terms = 0;\n    wps->mute_error = FALSE;\n    wps->crc = wps->crc_x = 0xffffffff;\n    wps->dsd.ready = 0;\n    CLEAR (wps->wvbits);\n    CLEAR (wps->wvcbits);\n    CLEAR (wps->wvxbits);\n    CLEAR (wps->decorr_passes);\n    CLEAR (wps->dc);\n    CLEAR (wps->w);\n\n    if (!(wps->wphdr.flags & MONO_FLAG) && wpc->config.num_channels && wps->wphdr.block_samples &&\n        (wpc->reduced_channels == 1 || wpc->config.num_channels == 1)) {\n            wps->mute_error = TRUE;\n            return FALSE;\n    }\n\n    if ((wps->wphdr.flags & UNKNOWN_FLAGS) || (wps->wphdr.flags & MONO_DATA) == MONO_DATA) {\n        wps->mute_error = TRUE;\n        return FALSE;\n    }\n\n    blockptr = wps->blockbuff + sizeof (WavpackHeader);\n\n    while (read_metadata_buff (&wpmd, wps->blockbuff, &blockptr))\n        if (!process_metadata (wpc, &wpmd)) {\n            wps->mute_error = TRUE;\n            return FALSE;\n        }\n\n    if (wps->wphdr.block_samples && wpc->wvc_flag && wps->block2buff) {\n        block2ptr = wps->block2buff + sizeof (WavpackHeader);\n\n        while (read_metadata_buff (&wpmd, wps->block2buff, &block2ptr))\n            if (!process_metadata (wpc, &wpmd)) {\n                wps->mute_error = TRUE;\n                return FALSE;\n            }\n    }\n\n    if (wps->wphdr.block_samples && ((wps->wphdr.flags & DSD_FLAG) ? !wps->dsd.ready : !bs_is_open (&wps->wvbits))) {\n        if (bs_is_open (&wps->wvcbits))\n            strcpy (wpc->error_message, \"can't unpack correction files alone!\");\n\n        wps->mute_error = TRUE;\n        return FALSE;\n    }\n\n    if (wps->wphdr.block_samples && !bs_is_open (&wps->wvxbits)) {\n        if ((wps->wphdr.flags & INT32_DATA) && wps->int32_sent_bits)\n            wpc->lossy_blocks = TRUE;\n\n        if ((wps->wphdr.flags & FLOAT_DATA) &&\n            wps->float_flags & (FLOAT_EXCEPTIONS | FLOAT_ZEROS_SENT | FLOAT_SHIFT_SENT | FLOAT_SHIFT_SAME))\n                wpc->lossy_blocks = TRUE;\n    }\n\n    if (wps->wphdr.block_samples)\n        wps->sample_index = GET_BLOCK_INDEX (wps->wphdr);\n\n    return TRUE;\n}\n\n//////////////////////////////// matadata handlers ///////////////////////////////\n\n// These functions handle specific metadata types and are called directly\n// during WavPack block parsing by process_metadata() at the bottom.\n\n// This function initialzes the main bitstream for audio samples, which must\n// be in the \"wv\" file.\n\nstatic int init_wv_bitstream (WavpackStream *wps, WavpackMetadata *wpmd)\n{\n    if (!wpmd->byte_length || (wpmd->byte_length & 1))\n        return FALSE;\n\n    bs_open_read (&wps->wvbits, wpmd->data, (unsigned char *) wpmd->data + wpmd->byte_length);\n    return TRUE;\n}\n\n// This function initialzes the \"correction\" bitstream for audio samples,\n// which currently must be in the \"wvc\" file.\n\nstatic int init_wvc_bitstream (WavpackStream *wps, WavpackMetadata *wpmd)\n{\n    if (!wpmd->byte_length || (wpmd->byte_length & 1))\n        return FALSE;\n\n    bs_open_read (&wps->wvcbits, wpmd->data, (unsigned char *) wpmd->data + wpmd->byte_length);\n    return TRUE;\n}\n\n// This function initialzes the \"extra\" bitstream for audio samples which\n// contains the information required to losslessly decompress 32-bit float data\n// or integer data that exceeds 24 bits. This bitstream is in the \"wv\" file\n// for pure lossless data or the \"wvc\" file for hybrid lossless. This data\n// would not be used for hybrid lossy mode. There is also a 32-bit CRC stored\n// in the first 4 bytes of these blocks.\n\nstatic int init_wvx_bitstream (WavpackStream *wps, WavpackMetadata *wpmd)\n{\n    unsigned char *cp = wpmd->data;\n\n    if (wpmd->byte_length <= 4 || (wpmd->byte_length & 1))\n        return FALSE;\n\n    wps->crc_wvx = *cp++;\n    wps->crc_wvx |= (int32_t) *cp++ << 8;\n    wps->crc_wvx |= (int32_t) *cp++ << 16;\n    wps->crc_wvx |= (int32_t) *cp++ << 24;\n\n    bs_open_read (&wps->wvxbits, cp, (unsigned char *) wpmd->data + wpmd->byte_length);\n    return TRUE;\n}\n\n// Read the int32 data from the specified metadata into the specified stream.\n// This data is used for integer data that has more than 24 bits of magnitude\n// or, in some cases, used to eliminate redundant bits from any audio stream.\n\nstatic int read_int32_info (WavpackStream *wps, WavpackMetadata *wpmd)\n{\n    int bytecnt = wpmd->byte_length;\n    char *byteptr = wpmd->data;\n\n    if (bytecnt != 4)\n        return FALSE;\n\n    wps->int32_sent_bits = *byteptr++;\n    wps->int32_zeros = *byteptr++;\n    wps->int32_ones = *byteptr++;\n    wps->int32_dups = *byteptr;\n\n    return TRUE;\n}\n\nstatic int read_float_info (WavpackStream *wps, WavpackMetadata *wpmd)\n{\n    int bytecnt = wpmd->byte_length;\n    char *byteptr = wpmd->data;\n\n    if (bytecnt != 4)\n        return FALSE;\n\n    wps->float_flags = *byteptr++;\n    wps->float_shift = *byteptr++;\n    wps->float_max_exp = *byteptr++;\n    wps->float_norm_exp = *byteptr;\n    return TRUE;\n}\n\n// Read multichannel information from metadata. The first byte is the total\n// number of channels and the following bytes represent the channel_mask\n// as described for Microsoft WAVEFORMATEX.\n\nstatic int read_channel_info (WavpackContext *wpc, WavpackMetadata *wpmd)\n{\n    int bytecnt = wpmd->byte_length, shift = 0, mask_bits;\n    unsigned char *byteptr = wpmd->data;\n    uint32_t mask = 0;\n\n    if (!bytecnt || bytecnt > 7)\n        return FALSE;\n\n    if (!wpc->config.num_channels) {\n\n        // if bytecnt is 6 or 7 we are using new configuration with \"unlimited\" streams\n\n        if (bytecnt >= 6) {\n            wpc->config.num_channels = (byteptr [0] | ((byteptr [2] & 0xf) << 8)) + 1;\n            wpc->max_streams = (byteptr [1] | ((byteptr [2] & 0xf0) << 4)) + 1;\n\n            if (wpc->config.num_channels < wpc->max_streams)\n                return FALSE;\n    \n            byteptr += 3;\n            mask = *byteptr++;\n            mask |= (uint32_t) *byteptr++ << 8;\n            mask |= (uint32_t) *byteptr++ << 16;\n\n            if (bytecnt == 7)                           // this was introduced in 5.0\n                mask |= (uint32_t) *byteptr << 24;\n        }\n        else {\n            wpc->config.num_channels = *byteptr++;\n\n            while (--bytecnt) {\n                mask |= (uint32_t) *byteptr++ << shift;\n                shift += 8;\n            }\n        }\n\n        if (wpc->config.num_channels > wpc->max_streams * 2)\n            return FALSE;\n\n        wpc->config.channel_mask = mask;\n\n        for (mask_bits = 0; mask; mask >>= 1)\n            if ((mask & 1) && ++mask_bits > wpc->config.num_channels)\n                return FALSE;\n    }\n\n    return TRUE;\n}\n\n// Read multichannel identity information from metadata. Data is an array of\n// unsigned characters representing any channels in the file that DO NOT\n// match one the 18 Microsoft standard channels (and are represented in the\n// channel mask). A value of 0 is not allowed and 0xff means an unknown or\n// undefined channel identity.\n\nstatic int read_channel_identities (WavpackContext *wpc, WavpackMetadata *wpmd)\n{\n    if (!wpc->channel_identities) {\n        wpc->channel_identities = malloc (wpmd->byte_length + 1);\n        memcpy (wpc->channel_identities, wpmd->data, wpmd->byte_length);\n        wpc->channel_identities [wpmd->byte_length] = 0;\n    }\n\n    return TRUE;\n}\n\n// Read configuration information from metadata.\n\nstatic int read_config_info (WavpackContext *wpc, WavpackMetadata *wpmd)\n{\n    int bytecnt = wpmd->byte_length;\n    unsigned char *byteptr = wpmd->data;\n\n    if (bytecnt >= 3) {\n        wpc->config.flags &= 0xff;\n        wpc->config.flags |= (int32_t) *byteptr++ << 8;\n        wpc->config.flags |= (int32_t) *byteptr++ << 16;\n        wpc->config.flags |= (int32_t) *byteptr++ << 24;\n        bytecnt -= 3;\n\n        if (bytecnt && (wpc->config.flags & CONFIG_EXTRA_MODE)) {\n            wpc->config.xmode = *byteptr++;\n            bytecnt--;\n        }\n\n        // we used an extra config byte here for the 5.0.0 alpha, so still\n        // honor it now (but this has been replaced with NEW_CONFIG)\n\n        if (bytecnt) {\n            wpc->config.qmode = (wpc->config.qmode & ~0xff) | *byteptr;\n            wpc->version_five = 1;\n        }\n    }\n\n    return TRUE;\n}\n\n// Read \"new\" configuration information from metadata.\n\nstatic int read_new_config_info (WavpackContext *wpc, WavpackMetadata *wpmd)\n{\n    int bytecnt = wpmd->byte_length;\n    unsigned char *byteptr = wpmd->data;\n\n    wpc->version_five = 1;      // just having this block signals version 5.0\n\n    wpc->file_format = wpc->config.qmode = wpc->channel_layout = 0;\n\n    if (wpc->channel_reordering) {\n        free (wpc->channel_reordering);\n        wpc->channel_reordering = NULL;\n    }\n\n    // if there's any data, the first two bytes are file_format and qmode flags\n\n    if (bytecnt) {\n        wpc->file_format = *byteptr++;\n        wpc->config.qmode = (wpc->config.qmode & ~0xff) | *byteptr++;\n        bytecnt -= 2;\n\n        // another byte indicates a channel layout\n\n        if (bytecnt) {\n            int nchans, i;\n\n            wpc->channel_layout = (int32_t) *byteptr++ << 16;\n            bytecnt--;\n\n            // another byte means we have a channel count for the layout and maybe a reordering\n\n            if (bytecnt) {\n                wpc->channel_layout += nchans = *byteptr++;\n                bytecnt--;\n\n                // any more means there's a reordering string\n\n                if (bytecnt) {\n                    if (bytecnt > nchans)\n                        return FALSE;\n\n                    wpc->channel_reordering = malloc (nchans);\n\n                    // note that redundant reordering info is not stored, so we fill in the rest\n\n                    if (wpc->channel_reordering) {\n                        for (i = 0; i < nchans; ++i)\n                            if (bytecnt) {\n                                wpc->channel_reordering [i] = *byteptr++;\n                                bytecnt--;\n                            }\n                            else\n                                wpc->channel_reordering [i] = i;\n                    }\n                }\n            }\n            else\n                wpc->channel_layout += wpc->config.num_channels;\n        }\n    }\n\n    return TRUE;\n}\n\n// Read non-standard sampling rate from metadata.\n\nstatic int read_sample_rate (WavpackContext *wpc, WavpackMetadata *wpmd)\n{\n    int bytecnt = wpmd->byte_length;\n    unsigned char *byteptr = wpmd->data;\n\n    if (bytecnt == 3 || bytecnt == 4) {\n        wpc->config.sample_rate = (int32_t) *byteptr++;\n        wpc->config.sample_rate |= (int32_t) *byteptr++ << 8;\n        wpc->config.sample_rate |= (int32_t) *byteptr++ << 16;\n\n        // for sampling rates > 16777215 (non-audio probably, or ...)\n\n        if (bytecnt == 4)\n            wpc->config.sample_rate |= (int32_t) (*byteptr & 0x7f) << 24;\n    }\n\n    return TRUE;\n}\n\n// Read wrapper data from metadata. Currently, this consists of the RIFF\n// header and trailer that wav files contain around the audio data but could\n// be used for other formats as well. Because WavPack files contain all the\n// information required for decoding and playback, this data can probably\n// be ignored except when an exact wavefile restoration is needed.\n\nstatic int read_wrapper_data (WavpackContext *wpc, WavpackMetadata *wpmd)\n{\n    if ((wpc->open_flags & OPEN_WRAPPER) && wpc->wrapper_bytes < MAX_WRAPPER_BYTES && wpmd->byte_length) {\n        wpc->wrapper_data = realloc (wpc->wrapper_data, wpc->wrapper_bytes + wpmd->byte_length);\n\tif (!wpc->wrapper_data)\n\t    return FALSE;\n        memcpy (wpc->wrapper_data + wpc->wrapper_bytes, wpmd->data, wpmd->byte_length);\n        wpc->wrapper_bytes += wpmd->byte_length;\n    }\n\n    return TRUE;\n}\n\nstatic int read_metadata_buff (WavpackMetadata *wpmd, unsigned char *blockbuff, unsigned char **buffptr)\n{\n    WavpackHeader *wphdr = (WavpackHeader *) blockbuff;\n    unsigned char *buffend = blockbuff + wphdr->ckSize + 8;\n\n    if (buffend - *buffptr < 2)\n        return FALSE;\n\n    wpmd->id = *(*buffptr)++;\n    wpmd->byte_length = *(*buffptr)++ << 1;\n\n    if (wpmd->id & ID_LARGE) {\n        wpmd->id &= ~ID_LARGE;\n\n        if (buffend - *buffptr < 2)\n            return FALSE;\n\n        wpmd->byte_length += *(*buffptr)++ << 9;\n        wpmd->byte_length += *(*buffptr)++ << 17;\n    }\n\n    if (wpmd->id & ID_ODD_SIZE) {\n        if (!wpmd->byte_length)         // odd size and zero length makes no sense\n            return FALSE;\n        wpmd->id &= ~ID_ODD_SIZE;\n        wpmd->byte_length--;\n    }\n\n    if (wpmd->byte_length) {\n        if (buffend - *buffptr < wpmd->byte_length + (wpmd->byte_length & 1)) {\n            wpmd->data = NULL;\n            return FALSE;\n        }\n\n        wpmd->data = *buffptr;\n        (*buffptr) += wpmd->byte_length + (wpmd->byte_length & 1);\n    }\n    else\n        wpmd->data = NULL;\n\n    return TRUE;\n}\n\nstatic int process_metadata (WavpackContext *wpc, WavpackMetadata *wpmd)\n{\n    WavpackStream *wps = wpc->streams [wpc->current_stream];\n\n    switch (wpmd->id) {\n        case ID_DUMMY:\n            return TRUE;\n\n        case ID_DECORR_TERMS:\n            return read_decorr_terms (wps, wpmd);\n\n        case ID_DECORR_WEIGHTS:\n            return read_decorr_weights (wps, wpmd);\n\n        case ID_DECORR_SAMPLES:\n            return read_decorr_samples (wps, wpmd);\n\n        case ID_ENTROPY_VARS:\n            return read_entropy_vars (wps, wpmd);\n\n        case ID_HYBRID_PROFILE:\n            return read_hybrid_profile (wps, wpmd);\n\n        case ID_SHAPING_WEIGHTS:\n            return read_shaping_info (wps, wpmd);\n\n        case ID_FLOAT_INFO:\n            return read_float_info (wps, wpmd);\n\n        case ID_INT32_INFO:\n            return read_int32_info (wps, wpmd);\n\n        case ID_CHANNEL_INFO:\n            return read_channel_info (wpc, wpmd);\n\n        case ID_CHANNEL_IDENTITIES:\n            return read_channel_identities (wpc, wpmd);\n\n        case ID_CONFIG_BLOCK:\n            return read_config_info (wpc, wpmd);\n\n        case ID_NEW_CONFIG_BLOCK:\n            return read_new_config_info (wpc, wpmd);\n\n        case ID_SAMPLE_RATE:\n            return read_sample_rate (wpc, wpmd);\n\n        case ID_WV_BITSTREAM:\n            return init_wv_bitstream (wps, wpmd);\n\n        case ID_WVC_BITSTREAM:\n            return init_wvc_bitstream (wps, wpmd);\n\n        case ID_WVX_BITSTREAM:\n            return init_wvx_bitstream (wps, wpmd);\n\n        case ID_DSD_BLOCK:\n#ifdef ENABLE_DSD\n            return init_dsd_block (wpc, wpmd);\n#else\n            strcpy (wpc->error_message, \"not configured to handle DSD WavPack files!\");\n            return FALSE;\n#endif\n\n        case ID_ALT_HEADER: case ID_ALT_TRAILER:\n            if (!(wpc->open_flags & OPEN_ALT_TYPES))\n                return TRUE;\n\n        case ID_RIFF_HEADER: case ID_RIFF_TRAILER:\n            return read_wrapper_data (wpc, wpmd);\n\n        case ID_ALT_MD5_CHECKSUM:\n            if (!(wpc->open_flags & OPEN_ALT_TYPES))\n                return TRUE;\n\n        case ID_MD5_CHECKSUM:\n            if (wpmd->byte_length == 16) {\n                memcpy (wpc->config.md5_checksum, wpmd->data, 16);\n                wpc->config.flags |= CONFIG_MD5_CHECKSUM;\n                wpc->config.md5_read = 1;\n            }\n\n            return TRUE;\n\n        case ID_ALT_EXTENSION:\n            if (wpmd->byte_length && wpmd->byte_length < sizeof (wpc->file_extension)) {\n                memcpy (wpc->file_extension, wpmd->data, wpmd->byte_length);\n                wpc->file_extension [wpmd->byte_length] = 0;\n            }\n\n            return TRUE;\n\n        // we don't actually verify the checksum here (it's done right after the\n        // block is read), but it's a good indicator of version 5 files\n\n        case ID_BLOCK_CHECKSUM:\n            wpc->version_five = 1;\n            return TRUE;\n\n        default:\n            return (wpmd->id & ID_OPTIONAL_DATA) ? TRUE : FALSE;\n    }\n}\n\n//////////////////////////////// bitstream management ///////////////////////////////\n\n// Open the specified BitStream and associate with the specified buffer.\n\nstatic void bs_read (Bitstream *bs);\n\nstatic void bs_open_read (Bitstream *bs, void *buffer_start, void *buffer_end)\n{\n    bs->error = bs->sr = bs->bc = 0;\n    bs->ptr = (bs->buf = buffer_start) - 1;\n    bs->end = buffer_end;\n    bs->wrap = bs_read;\n}\n\n// This function is only called from the getbit() and getbits() macros when\n// the BitStream has been exhausted and more data is required. Sinve these\n// bistreams no longer access files, this function simple sets an error and\n// resets the buffer.\n\nstatic void bs_read (Bitstream *bs)\n{\n    bs->ptr = bs->buf;\n    bs->error = 1;\n}\n\n// This function is called to close the bitstream. It returns the number of\n// full bytes actually read as bits.\n\nuint32_t bs_close_read (Bitstream *bs)\n{\n    uint32_t bytes_read;\n\n    if (bs->bc < sizeof (*(bs->ptr)) * 8)\n        bs->ptr++;\n\n    bytes_read = (uint32_t)(bs->ptr - bs->buf) * sizeof (*(bs->ptr));\n\n    if (!(bytes_read & 1))\n        ++bytes_read;\n\n    CLEAR (*bs);\n    return bytes_read;\n}\n\n// Normally the trailing wrapper will not be available when a WavPack file is first\n// opened for reading because it is stored in the final block of the file. This\n// function forces a seek to the end of the file to pick up any trailing wrapper\n// stored there (then use WavPackGetWrapper**() to obtain). This can obviously only\n// be used for seekable files (not pipes) and is not available for pre-4.0 WavPack\n// files.\n\nvoid WavpackSeekTrailingWrapper (WavpackContext *wpc)\n{\n    if ((wpc->open_flags & OPEN_WRAPPER) &&\n        wpc->reader->can_seek (wpc->wv_in) && !wpc->stream3)\n            seek_eof_information (wpc, NULL, TRUE);\n}\n\n// Get any MD5 checksum stored in the metadata (should be called after reading\n// last sample or an extra seek will occur). A return value of FALSE indicates\n// that no MD5 checksum was stored.\n\nint WavpackGetMD5Sum (WavpackContext *wpc, unsigned char data [16])\n{\n    if (wpc->config.flags & CONFIG_MD5_CHECKSUM) {\n        if (!wpc->config.md5_read && wpc->reader->can_seek (wpc->wv_in))\n            seek_eof_information (wpc, NULL, FALSE);\n\n        if (wpc->config.md5_read) {\n            memcpy (data, wpc->config.md5_checksum, 16);\n            return TRUE;\n        }\n    }\n\n    return FALSE;\n}\n\n// Read from current file position until a valid 32-byte WavPack 4.0 header is\n// found and read into the specified pointer. The number of bytes skipped is\n// returned. If no WavPack header is found within 1 meg, then a -1 is returned\n// to indicate the error. No additional bytes are read past the header and it\n// is returned in the processor's native endian mode. Seeking is not required.\n\nuint32_t read_next_header (WavpackStreamReader64 *reader, void *id, WavpackHeader *wphdr)\n{\n    unsigned char buffer [sizeof (*wphdr)], *sp = buffer + sizeof (*wphdr), *ep = sp;\n    uint32_t bytes_skipped = 0;\n    int bleft;\n\n    while (1) {\n        if (sp < ep) {\n            bleft = (int)(ep - sp);\n            memmove (buffer, sp, bleft);\n        }\n        else\n            bleft = 0;\n\n        if (reader->read_bytes (id, buffer + bleft, sizeof (*wphdr) - bleft) != sizeof (*wphdr) - bleft)\n            return -1;\n\n        sp = buffer;\n\n        if (*sp++ == 'w' && *sp == 'v' && *++sp == 'p' && *++sp == 'k' &&\n            !(*++sp & 1) && sp [2] < 16 && !sp [3] && (sp [2] || sp [1] || *sp >= 24) && sp [5] == 4 &&\n            sp [4] >= (MIN_STREAM_VERS & 0xff) && sp [4] <= (MAX_STREAM_VERS & 0xff) && sp [18] < 3 && !sp [19]) {\n                memcpy (wphdr, buffer, sizeof (*wphdr));\n                WavpackLittleEndianToNative (wphdr, WavpackHeaderFormat);\n                return bytes_skipped;\n            }\n\n        while (sp < ep && *sp != 'w')\n            sp++;\n\n        if ((bytes_skipped += (uint32_t)(sp - buffer)) > 1024 * 1024)\n            return -1;\n    }\n}\n\n// Compare the regular wv file block header to a potential matching wvc\n// file block header and return action code based on analysis:\n//\n//   0 = use wvc block (assuming rest of block is readable)\n//   1 = bad match; try to read next wvc block\n//  -1 = bad match; ignore wvc file for this block and backup fp (if\n//       possible) and try to use this block next time\n\nstatic int match_wvc_header (WavpackHeader *wv_hdr, WavpackHeader *wvc_hdr)\n{\n    if (GET_BLOCK_INDEX (*wv_hdr) == GET_BLOCK_INDEX (*wvc_hdr) &&\n        wv_hdr->block_samples == wvc_hdr->block_samples) {\n            int wvi = 0, wvci = 0;\n\n            if (wv_hdr->flags == wvc_hdr->flags)\n                return 0;\n\n            if (wv_hdr->flags & INITIAL_BLOCK)\n                wvi -= 1;\n\n            if (wv_hdr->flags & FINAL_BLOCK)\n                wvi += 1;\n\n            if (wvc_hdr->flags & INITIAL_BLOCK)\n                wvci -= 1;\n\n            if (wvc_hdr->flags & FINAL_BLOCK)\n                wvci += 1;\n\n            return (wvci - wvi < 0) ? 1 : -1;\n        }\n\n    if (((GET_BLOCK_INDEX (*wvc_hdr) - GET_BLOCK_INDEX (*wv_hdr)) << 24) < 0)\n        return 1;\n    else\n        return -1;\n}\n\n// Read the wvc block that matches the regular wv block that has been\n// read for the current stream. If an exact match is not found then\n// we either keep reading or back up and (possibly) use the block\n// later. The skip_wvc flag is set if not matching wvc block is found\n// so that we can still decode using only the lossy version (although\n// we flag this as an error). A return of FALSE indicates a serious\n// error (not just that we missed one wvc block).\n\nint read_wvc_block (WavpackContext *wpc)\n{\n    WavpackStream *wps = wpc->streams [wpc->current_stream];\n    int64_t bcount, file2pos;\n    WavpackHeader orig_wphdr;\n    WavpackHeader wphdr;\n    int compare_result;\n\n    while (1) {\n        file2pos = wpc->reader->get_pos (wpc->wvc_in);\n        bcount = read_next_header (wpc->reader, wpc->wvc_in, &wphdr);\n\n        if (bcount == (uint32_t) -1) {\n            wps->wvc_skip = TRUE;\n            wpc->crc_errors++;\n            return FALSE;\n        }\n\n        memcpy (&orig_wphdr, &wphdr, 32);       // save original header for verify step\n\n        if (wpc->open_flags & OPEN_STREAMING)\n            SET_BLOCK_INDEX (wphdr, wps->sample_index = 0);\n        else\n            SET_BLOCK_INDEX (wphdr, GET_BLOCK_INDEX (wphdr) - wpc->initial_index);\n\n        if (wphdr.flags & INITIAL_BLOCK)\n            wpc->file2pos = file2pos + bcount;\n\n        compare_result = match_wvc_header (&wps->wphdr, &wphdr);\n\n        if (!compare_result) {\n            wps->block2buff = malloc (wphdr.ckSize + 8);\n\t    if (!wps->block2buff)\n\t        return FALSE;\n\n            if (wpc->reader->read_bytes (wpc->wvc_in, wps->block2buff + 32, wphdr.ckSize - 24) !=\n                wphdr.ckSize - 24) {\n                    free (wps->block2buff);\n                    wps->block2buff = NULL;\n                    wps->wvc_skip = TRUE;\n                    wpc->crc_errors++;\n                    return FALSE;\n            }\n\n            memcpy (wps->block2buff, &orig_wphdr, 32);\n\n            // don't use corrupt blocks\n            if (!WavpackVerifySingleBlock (wps->block2buff, !(wpc->open_flags & OPEN_NO_CHECKSUM))) {\n                free (wps->block2buff);\n                wps->block2buff = NULL;\n                wps->wvc_skip = TRUE;\n                wpc->crc_errors++;\n                return TRUE;\n            }\n\n            wps->wvc_skip = FALSE;\n            memcpy (wps->block2buff, &wphdr, 32);\n            memcpy (&wps->wphdr, &wphdr, 32);\n            return TRUE;\n        }\n        else if (compare_result == -1) {\n            wps->wvc_skip = TRUE;\n            wpc->reader->set_pos_rel (wpc->wvc_in, -32, SEEK_CUR);\n            wpc->crc_errors++;\n            return TRUE;\n        }\n    }\n}\n\n// This function is used to seek to end of a file to obtain certain information\n// that is stored there at the file creation time because it is not known at\n// the start. This includes the MD5 sum and and trailing part of the file\n// wrapper, and in some rare cases may include the total number of samples in\n// the file (although we usually try to back up and write that at the front of\n// the file). Note this function restores the file position to its original\n// location (and obviously requires a seekable file). The normal return value\n// is TRUE indicating no errors, although this does not actually mean that any\n// information was retrieved. An error return of FALSE usually means the file\n// terminated unexpectedly. Note that this could be used to get all three\n// types of information in one go, but it's not actually used that way now.\n\nstatic int seek_eof_information (WavpackContext *wpc, int64_t *final_index, int get_wrapper)\n{\n    int64_t restore_pos, last_pos = -1;\n    WavpackStreamReader64 *reader = wpc->reader;\n    int alt_types = wpc->open_flags & OPEN_ALT_TYPES;\n    uint32_t blocks = 0, audio_blocks = 0;\n    void *id = wpc->wv_in;\n    WavpackHeader wphdr;\n\n    restore_pos = reader->get_pos (id);    // we restore file position when done\n\n    // start 1MB from the end-of-file, or from the start if the file is not that big\n\n    if (reader->get_length (id) > 1048576LL)\n        reader->set_pos_rel (id, -1048576, SEEK_END);\n    else\n        reader->set_pos_abs (id, 0);\n\n    // Note that we go backward (without parsing inside blocks) until we find a block\n    // with audio (careful to not get stuck in a loop). Only then do we go forward\n    // parsing all blocks in their entirety.\n\n    while (1) {\n        uint32_t bcount = read_next_header (reader, id, &wphdr);\n        int64_t current_pos = reader->get_pos (id);\n\n        // if we just got to the same place as last time, we're stuck and need to give up\n\n        if (current_pos == last_pos) {\n            reader->set_pos_abs (id, restore_pos);\n            return FALSE;\n        }\n\n        last_pos = current_pos;\n\n        // We enter here if we just read 1 MB without seeing any WavPack block headers.\n        // Since WavPack blocks are < 1 MB, that means we're in a big APE tag, or we got\n        // to the end-of-file.\n\n        if (bcount == (uint32_t) -1) {\n\n            // if we have not seen any blocks at all yet, back up almost 2 MB (or to the\n            // beginning of the file) and try again\n\n            if (!blocks) {\n                if (current_pos > 2000000LL)\n                    reader->set_pos_rel (id, -2000000, SEEK_CUR);\n                else\n                    reader->set_pos_abs (id, 0);\n\n                continue;\n            }\n\n            // if we have seen WavPack blocks, then this means we've done all we can do here\n\n            reader->set_pos_abs (id, restore_pos);\n            return TRUE;\n        }\n\n        blocks++;\n\n        // If the block has audio samples, calculate a final index, although this is not\n        // final since this may not be the last block with audio. On the other hand, if\n        // this block does not have audio, and we haven't seen one with audio, we have\n        // to go back some more.\n\n        if (wphdr.block_samples) {\n            if (final_index)\n                *final_index = GET_BLOCK_INDEX (wphdr) + wphdr.block_samples;\n\n            audio_blocks++;\n        }\n        else if (!audio_blocks) {\n            if (current_pos > 1048576LL)\n                reader->set_pos_rel (id, -1048576, SEEK_CUR);\n            else\n                reader->set_pos_abs (id, 0);\n\n            continue;\n        }\n\n        // at this point we have seen at least one block with audio, so we parse the\n        // entire block looking for MD5 metadata or (conditionally) trailing wrappers\n\n        bcount = wphdr.ckSize - sizeof (WavpackHeader) + 8;\n\n        while (bcount >= 2) {\n            unsigned char meta_id, c1, c2;\n            uint32_t meta_bc, meta_size;\n\n            if (reader->read_bytes (id, &meta_id, 1) != 1 ||\n                reader->read_bytes (id, &c1, 1) != 1) {\n                    reader->set_pos_abs (id, restore_pos);\n                    return FALSE;\n            }\n\n            meta_bc = c1 << 1;\n            bcount -= 2;\n\n            if (meta_id & ID_LARGE) {\n                if (bcount < 2 || reader->read_bytes (id, &c1, 1) != 1 ||\n                    reader->read_bytes (id, &c2, 1) != 1) {\n                        reader->set_pos_abs (id, restore_pos);\n                        return FALSE;\n                }\n\n                meta_bc += ((uint32_t) c1 << 9) + ((uint32_t) c2 << 17);\n                bcount -= 2;\n            }\n\n            meta_size = (meta_id & ID_ODD_SIZE) ? meta_bc - 1 : meta_bc;\n            meta_id &= ID_UNIQUE;\n\n            if (get_wrapper && (meta_id == ID_RIFF_TRAILER || (alt_types && meta_id == ID_ALT_TRAILER)) && meta_bc) {\n                wpc->wrapper_data = realloc (wpc->wrapper_data, wpc->wrapper_bytes + meta_bc);\n\n                if (!wpc->wrapper_data) {\n                    reader->set_pos_abs (id, restore_pos);\n                    return FALSE;\n                }\n\n                if (reader->read_bytes (id, wpc->wrapper_data + wpc->wrapper_bytes, meta_bc) == meta_bc)\n                    wpc->wrapper_bytes += meta_size;\n                else {\n                    reader->set_pos_abs (id, restore_pos);\n                    return FALSE;\n                }\n            }\n            else if (meta_id == ID_MD5_CHECKSUM || (alt_types && meta_id == ID_ALT_MD5_CHECKSUM)) {\n                if (meta_bc == 16 && bcount >= 16) {\n                    if (reader->read_bytes (id, wpc->config.md5_checksum, 16) == 16)\n                        wpc->config.md5_read = TRUE;\n                    else {\n                        reader->set_pos_abs (id, restore_pos);\n                        return FALSE;\n                    }\n                }\n                else\n                    reader->set_pos_rel (id, meta_bc, SEEK_CUR);\n            }\n            else\n                reader->set_pos_rel (id, meta_bc, SEEK_CUR);\n\n            bcount -= meta_bc;\n        }\n    }\n}\n\n// Quickly verify the referenced block. It is assumed that the WavPack header has been converted\n// to native endian format. If a block checksum is performed, that is done in little-endian\n// (file) format. It is also assumed that the caller has made sure that the block length\n// indicated in the header is correct (we won't overflow the buffer). If a checksum is present,\n// then it is checked, otherwise we just check that all the metadata blocks are formatted\n// correctly (without looking at their contents). Returns FALSE for bad block.\n\nint WavpackVerifySingleBlock (unsigned char *buffer, int verify_checksum)\n{\n    WavpackHeader *wphdr = (WavpackHeader *) buffer;\n    uint32_t checksum_passed = 0, bcount, meta_bc;\n    unsigned char *dp, meta_id, c1, c2;\n\n    if (strncmp (wphdr->ckID, \"wvpk\", 4) || wphdr->ckSize + 8 < sizeof (WavpackHeader))\n        return FALSE;\n\n    bcount = wphdr->ckSize - sizeof (WavpackHeader) + 8;\n    dp = (unsigned char *)(wphdr + 1);\n\n    while (bcount >= 2) {\n        meta_id = *dp++;\n        c1 = *dp++;\n\n        meta_bc = c1 << 1;\n        bcount -= 2;\n\n        if (meta_id & ID_LARGE) {\n            if (bcount < 2)\n                return FALSE;\n\n            c1 = *dp++;\n            c2 = *dp++;\n            meta_bc += ((uint32_t) c1 << 9) + ((uint32_t) c2 << 17);\n            bcount -= 2;\n        }\n\n        if (bcount < meta_bc)\n            return FALSE;\n\n        if (verify_checksum && (meta_id & ID_UNIQUE) == ID_BLOCK_CHECKSUM) {\n#ifdef BITSTREAM_SHORTS\n            uint16_t *csptr = (uint16_t*) buffer;\n#else\n            unsigned char *csptr = buffer;\n#endif\n            int wcount = (int)(dp - 2 - buffer) >> 1;\n            uint32_t csum = (uint32_t) -1;\n\n            if ((meta_id & ID_ODD_SIZE) || meta_bc < 2 || meta_bc > 4)\n                return FALSE;\n\n#ifdef BITSTREAM_SHORTS\n            while (wcount--)\n                csum = (csum * 3) + *csptr++;\n#else\n            WavpackNativeToLittleEndian ((WavpackHeader *) buffer, WavpackHeaderFormat);\n\n            while (wcount--) {\n                csum = (csum * 3) + csptr [0] + (csptr [1] << 8);\n                csptr += 2;\n            }\n\n            WavpackLittleEndianToNative ((WavpackHeader *) buffer, WavpackHeaderFormat);\n#endif\n\n            if (meta_bc == 4) {\n                if (*dp++ != (csum & 0xff) || *dp++ != ((csum >> 8) & 0xff) || *dp++ != ((csum >> 16) & 0xff) || *dp++ != ((csum >> 24) & 0xff))\n                    return FALSE;\n            }\n            else {\n                csum ^= csum >> 16;\n\n                if (*dp++ != (csum & 0xff) || *dp++ != ((csum >> 8) & 0xff))\n                    return FALSE;\n            }\n\n            checksum_passed++;\n        }\n\n        bcount -= meta_bc;\n        dp += meta_bc;\n    }\n\n    return (bcount == 0) && (!verify_checksum || !(wphdr->flags & HAS_CHECKSUM) || checksum_passed);\n}\n", "////////////////////////////////////////////////////////////////////////////\n//                           **** WAVPACK ****                            //\n//                  Hybrid Lossless Wavefile Compressor                   //\n//              Copyright (c) 1998 - 2013 Conifer Software.               //\n//                          All Rights Reserved.                          //\n//      Distributed under the BSD Software License (see license.txt)      //\n////////////////////////////////////////////////////////////////////////////\n\n// read_words.c\n\n// This module provides entropy word decoding functions using\n// a variation on the Rice method.  This was introduced in version 3.93\n// because it allows splitting the data into a \"lossy\" stream and a\n// \"correction\" stream in a very efficient manner and is therefore ideal\n// for the \"hybrid\" mode.  For 4.0, the efficiency of this method was\n// significantly improved by moving away from the normal Rice restriction of\n// using powers of two for the modulus divisions and now the method can be\n// used for both hybrid and pure lossless encoding.\n\n// Samples are divided by median probabilities at 5/7 (71.43%), 10/49 (20.41%),\n// and 20/343 (5.83%). Each zone has 3.5 times fewer samples than the\n// previous. Using standard Rice coding on this data would result in 1.4\n// bits per sample average (not counting sign bit). However, there is a\n// very simple encoding that is over 99% efficient with this data and\n// results in about 1.22 bits per sample.\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"wavpack_local.h\"\n\n#if defined (HAVE___BUILTIN_CTZ) || defined (_WIN64)\n#define USE_CTZ_OPTIMIZATION    // use ctz intrinsic (or Windows equivalent) to count trailing ones\n#else\n#define USE_NEXT8_OPTIMIZATION  // optimization using a table to count trailing ones\n#endif\n\n#define USE_BITMASK_TABLES      // use tables instead of shifting for certain masking operations\n\n///////////////////////////// local table storage ////////////////////////////\n\n#ifdef USE_NEXT8_OPTIMIZATION\nstatic const char ones_count_table [] = {\n    0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,\n    0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,\n    0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,\n    0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,7,\n    0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,\n    0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,\n    0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,\n    0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,8\n};\n#endif\n\n///////////////////////////// executable code ////////////////////////////////\n\nstatic uint32_t __inline read_code (Bitstream *bs, uint32_t maxcode);\n\n// Read the next word from the bitstream \"wvbits\" and return the value. This\n// function can be used for hybrid or lossless streams, but since an\n// optimized version is available for lossless this function would normally\n// be used for hybrid only. If a hybrid lossless stream is being read then\n// the \"correction\" offset is written at the specified pointer. A return value\n// of WORD_EOF indicates that the end of the bitstream was reached (all 1s) or\n// some other error occurred.\n\nint32_t FASTCALL get_word (WavpackStream *wps, int chan, int32_t *correction)\n{\n    register struct entropy_data *c = wps->w.c + chan;\n    uint32_t ones_count, low, mid, high;\n    int32_t value;\n    int sign;\n\n    if (!wps->wvbits.ptr)\n        return WORD_EOF;\n\n    if (correction)\n        *correction = 0;\n\n    if (!(wps->w.c [0].median [0] & ~1) && !wps->w.holding_zero && !wps->w.holding_one && !(wps->w.c [1].median [0] & ~1)) {\n        uint32_t mask;\n        int cbits;\n\n        if (wps->w.zeros_acc) {\n            if (--wps->w.zeros_acc) {\n                c->slow_level -= (c->slow_level + SLO) >> SLS;\n                return 0;\n            }\n        }\n        else {\n            for (cbits = 0; cbits < 33 && getbit (&wps->wvbits); ++cbits);\n\n            if (cbits == 33)\n                return WORD_EOF;\n\n            if (cbits < 2)\n                wps->w.zeros_acc = cbits;\n            else {\n                for (mask = 1, wps->w.zeros_acc = 0; --cbits; mask <<= 1)\n                    if (getbit (&wps->wvbits))\n                        wps->w.zeros_acc |= mask;\n\n                wps->w.zeros_acc |= mask;\n            }\n\n            if (wps->w.zeros_acc) {\n                c->slow_level -= (c->slow_level + SLO) >> SLS;\n                CLEAR (wps->w.c [0].median);\n                CLEAR (wps->w.c [1].median);\n                return 0;\n            }\n        }\n    }\n\n    if (wps->w.holding_zero)\n        ones_count = wps->w.holding_zero = 0;\n    else {\n#ifdef USE_CTZ_OPTIMIZATION\n        while (wps->wvbits.bc < LIMIT_ONES) {\n            if (++(wps->wvbits.ptr) == wps->wvbits.end)\n                wps->wvbits.wrap (&wps->wvbits);\n\n            wps->wvbits.sr |= *(wps->wvbits.ptr) << wps->wvbits.bc;\n            wps->wvbits.bc += sizeof (*(wps->wvbits.ptr)) * 8;\n        }\n\n#ifdef _WIN32\n        _BitScanForward (&ones_count, ~wps->wvbits.sr);\n#else\n        ones_count = __builtin_ctz (~wps->wvbits.sr);\n#endif\n\n        if (ones_count >= LIMIT_ONES) {\n            wps->wvbits.bc -= ones_count;\n            wps->wvbits.sr >>= ones_count;\n\n            for (; ones_count < (LIMIT_ONES + 1) && getbit (&wps->wvbits); ++ones_count);\n\n            if (ones_count == (LIMIT_ONES + 1))\n                return WORD_EOF;\n\n            if (ones_count == LIMIT_ONES) {\n                uint32_t mask;\n                int cbits;\n\n                for (cbits = 0; cbits < 33 && getbit (&wps->wvbits); ++cbits);\n\n                if (cbits == 33)\n                    return WORD_EOF;\n\n                if (cbits < 2)\n                    ones_count = cbits;\n                else {\n                    for (mask = 1, ones_count = 0; --cbits; mask <<= 1)\n                        if (getbit (&wps->wvbits))\n                            ones_count |= mask;\n\n                    ones_count |= mask;\n                }\n\n                ones_count += LIMIT_ONES;\n            }\n        }\n        else {\n            wps->wvbits.bc -= ones_count + 1;\n            wps->wvbits.sr >>= ones_count + 1;\n        }\n#elif defined (USE_NEXT8_OPTIMIZATION)\n        int next8;\n\n        if (wps->wvbits.bc < 8) {\n            if (++(wps->wvbits.ptr) == wps->wvbits.end)\n                wps->wvbits.wrap (&wps->wvbits);\n\n            next8 = (wps->wvbits.sr |= *(wps->wvbits.ptr) << wps->wvbits.bc) & 0xff;\n            wps->wvbits.bc += sizeof (*(wps->wvbits.ptr)) * 8;\n        }\n        else\n            next8 = wps->wvbits.sr & 0xff;\n\n        if (next8 == 0xff) {\n            wps->wvbits.bc -= 8;\n            wps->wvbits.sr >>= 8;\n\n            for (ones_count = 8; ones_count < (LIMIT_ONES + 1) && getbit (&wps->wvbits); ++ones_count);\n\n            if (ones_count == (LIMIT_ONES + 1))\n                return WORD_EOF;\n\n            if (ones_count == LIMIT_ONES) {\n                uint32_t mask;\n                int cbits;\n\n                for (cbits = 0; cbits < 33 && getbit (&wps->wvbits); ++cbits);\n\n                if (cbits == 33)\n                    return WORD_EOF;\n\n                if (cbits < 2)\n                    ones_count = cbits;\n                else {\n                    for (mask = 1, ones_count = 0; --cbits; mask <<= 1)\n                        if (getbit (&wps->wvbits))\n                            ones_count |= mask;\n\n                    ones_count |= mask;\n                }\n\n                ones_count += LIMIT_ONES;\n            }\n        }\n        else {\n            wps->wvbits.bc -= (ones_count = ones_count_table [next8]) + 1;\n            wps->wvbits.sr >>= ones_count + 1;\n        }\n#else\n        for (ones_count = 0; ones_count < (LIMIT_ONES + 1) && getbit (&wps->wvbits); ++ones_count);\n\n        if (ones_count >= LIMIT_ONES) {\n            uint32_t mask;\n            int cbits;\n\n            if (ones_count == (LIMIT_ONES + 1))\n                return WORD_EOF;\n\n            for (cbits = 0; cbits < 33 && getbit (&wps->wvbits); ++cbits);\n\n            if (cbits == 33)\n                return WORD_EOF;\n\n            if (cbits < 2)\n                ones_count = cbits;\n            else {\n                for (mask = 1, ones_count = 0; --cbits; mask <<= 1)\n                    if (getbit (&wps->wvbits))\n                        ones_count |= mask;\n\n                ones_count |= mask;\n            }\n\n            ones_count += LIMIT_ONES;\n        }\n#endif\n\n        if (wps->w.holding_one) {\n            wps->w.holding_one = ones_count & 1;\n            ones_count = (ones_count >> 1) + 1;\n        }\n        else {\n            wps->w.holding_one = ones_count & 1;\n            ones_count >>= 1;\n        }\n\n        wps->w.holding_zero = ~wps->w.holding_one & 1;\n    }\n\n    if ((wps->wphdr.flags & HYBRID_FLAG) && !chan)\n        update_error_limit (wps);\n\n    if (ones_count == 0) {\n        low = 0;\n        high = GET_MED (0) - 1;\n        DEC_MED0 ();\n    }\n    else {\n        low = GET_MED (0);\n        INC_MED0 ();\n\n        if (ones_count == 1) {\n            high = low + GET_MED (1) - 1;\n            DEC_MED1 ();\n        }\n        else {\n            low += GET_MED (1);\n            INC_MED1 ();\n\n            if (ones_count == 2) {\n                high = low + GET_MED (2) - 1;\n                DEC_MED2 ();\n            }\n            else {\n                low += (ones_count - 2) * GET_MED (2);\n                high = low + GET_MED (2) - 1;\n                INC_MED2 ();\n            }\n        }\n    }\n\n    low &= 0x7fffffff;\n    high &= 0x7fffffff;\n    mid = (high + low + 1) >> 1;\n\n    if (!c->error_limit)\n        mid = read_code (&wps->wvbits, high - low) + low;\n    else while (high - low > c->error_limit) {\n        if (getbit (&wps->wvbits))\n            mid = (high + (low = mid) + 1) >> 1;\n        else\n            mid = ((high = mid - 1) + low + 1) >> 1;\n    }\n\n    sign = getbit (&wps->wvbits);\n\n    if (bs_is_open (&wps->wvcbits) && c->error_limit) {\n        value = read_code (&wps->wvcbits, high - low) + low;\n\n        if (correction)\n            *correction = sign ? (mid - value) : (value - mid);\n    }\n\n    if (wps->wphdr.flags & HYBRID_BITRATE) {\n        c->slow_level -= (c->slow_level + SLO) >> SLS;\n        c->slow_level += wp_log2 (mid);\n    }\n\n    return sign ? ~mid : mid;\n}\n\n// This is an optimized version of get_word() that is used for lossless only\n// (error_limit == 0). Also, rather than obtaining a single sample, it can be\n// used to obtain an entire buffer of either mono or stereo samples.\n\nint32_t get_words_lossless (WavpackStream *wps, int32_t *buffer, int32_t nsamples)\n{\n    struct entropy_data *c = wps->w.c;\n    uint32_t ones_count, low, high;\n    Bitstream *bs = &wps->wvbits;\n    int32_t csamples;\n#ifdef USE_NEXT8_OPTIMIZATION\n    int32_t next8;\n#endif\n\n    if (nsamples && !bs->ptr) {\n        memset (buffer, 0, (wps->wphdr.flags & MONO_DATA) ? nsamples * 4 : nsamples * 8);\n        return nsamples;\n    }\n\n    if (!(wps->wphdr.flags & MONO_DATA))\n        nsamples *= 2;\n\n    for (csamples = 0; csamples < nsamples; ++csamples) {\n        if (!(wps->wphdr.flags & MONO_DATA))\n            c = wps->w.c + (csamples & 1);\n\n        if (wps->w.holding_zero) {\n            wps->w.holding_zero = 0;\n            low = read_code (bs, GET_MED (0) - 1);\n            DEC_MED0 ();\n            buffer [csamples] = (getbit (bs)) ? ~low : low;\n\n            if (++csamples == nsamples)\n                break;\n\n            if (!(wps->wphdr.flags & MONO_DATA))\n                c = wps->w.c + (csamples & 1);\n        }\n\n        if (wps->w.c [0].median [0] < 2 && !wps->w.holding_one && wps->w.c [1].median [0] < 2) {\n            uint32_t mask;\n            int cbits;\n\n            if (wps->w.zeros_acc) {\n                if (--wps->w.zeros_acc) {\n                    buffer [csamples] = 0;\n                    continue;\n                }\n            }\n            else {\n                for (cbits = 0; cbits < 33 && getbit (bs); ++cbits);\n\n                if (cbits == 33)\n                    break;\n\n                if (cbits < 2)\n                    wps->w.zeros_acc = cbits;\n                else {\n                    for (mask = 1, wps->w.zeros_acc = 0; --cbits; mask <<= 1)\n                        if (getbit (bs))\n                            wps->w.zeros_acc |= mask;\n\n                    wps->w.zeros_acc |= mask;\n                }\n\n                if (wps->w.zeros_acc) {\n                    CLEAR (wps->w.c [0].median);\n                    CLEAR (wps->w.c [1].median);\n                    buffer [csamples] = 0;\n                    continue;\n                }\n            }\n        }\n\n#ifdef USE_CTZ_OPTIMIZATION\n        while (bs->bc < LIMIT_ONES) {\n            if (++(bs->ptr) == bs->end)\n                bs->wrap (bs);\n\n            bs->sr |= *(bs->ptr) << bs->bc;\n            bs->bc += sizeof (*(bs->ptr)) * 8;\n        }\n\n#ifdef _WIN32\n        _BitScanForward (&ones_count, ~wps->wvbits.sr);\n#else\n        ones_count = __builtin_ctz (~wps->wvbits.sr);\n#endif\n\n        if (ones_count >= LIMIT_ONES) {\n            bs->bc -= ones_count;\n            bs->sr >>= ones_count;\n\n            for (; ones_count < (LIMIT_ONES + 1) && getbit (bs); ++ones_count);\n\n            if (ones_count == (LIMIT_ONES + 1))\n                break;\n\n            if (ones_count == LIMIT_ONES) {\n                uint32_t mask;\n                int cbits;\n\n                for (cbits = 0; cbits < 33 && getbit (bs); ++cbits);\n\n                if (cbits == 33)\n                    break;\n\n                if (cbits < 2)\n                    ones_count = cbits;\n                else {\n                    for (mask = 1, ones_count = 0; --cbits; mask <<= 1)\n                        if (getbit (bs))\n                            ones_count |= mask;\n\n                    ones_count |= mask;\n                }\n\n                ones_count += LIMIT_ONES;\n            }\n        }\n        else {\n            bs->bc -= ones_count + 1;\n            bs->sr >>= ones_count + 1;\n        }\n#elif defined (USE_NEXT8_OPTIMIZATION)\n        if (bs->bc < 8) {\n            if (++(bs->ptr) == bs->end)\n                bs->wrap (bs);\n\n            next8 = (bs->sr |= *(bs->ptr) << bs->bc) & 0xff;\n            bs->bc += sizeof (*(bs->ptr)) * 8;\n        }\n        else\n            next8 = bs->sr & 0xff;\n\n        if (next8 == 0xff) {\n            bs->bc -= 8;\n            bs->sr >>= 8;\n\n            for (ones_count = 8; ones_count < (LIMIT_ONES + 1) && getbit (bs); ++ones_count);\n\n            if (ones_count == (LIMIT_ONES + 1))\n                break;\n\n            if (ones_count == LIMIT_ONES) {\n                uint32_t mask;\n                int cbits;\n\n                for (cbits = 0; cbits < 33 && getbit (bs); ++cbits);\n\n                if (cbits == 33)\n                    break;\n\n                if (cbits < 2)\n                    ones_count = cbits;\n                else {\n                    for (mask = 1, ones_count = 0; --cbits; mask <<= 1)\n                        if (getbit (bs))\n                            ones_count |= mask;\n\n                    ones_count |= mask;\n                }\n\n                ones_count += LIMIT_ONES;\n            }\n        }\n        else {\n            bs->bc -= (ones_count = ones_count_table [next8]) + 1;\n            bs->sr >>= ones_count + 1;\n        }\n#else\n        for (ones_count = 0; ones_count < (LIMIT_ONES + 1) && getbit (bs); ++ones_count);\n\n        if (ones_count >= LIMIT_ONES) {\n            uint32_t mask;\n            int cbits;\n\n            if (ones_count == (LIMIT_ONES + 1))\n                break;\n\n            for (cbits = 0; cbits < 33 && getbit (bs); ++cbits);\n\n            if (cbits == 33)\n                break;\n\n            if (cbits < 2)\n                ones_count = cbits;\n            else {\n                for (mask = 1, ones_count = 0; --cbits; mask <<= 1)\n                    if (getbit (bs))\n                        ones_count |= mask;\n\n                ones_count |= mask;\n            }\n\n            ones_count += LIMIT_ONES;\n        }\n#endif\n\n        low = wps->w.holding_one;\n        wps->w.holding_one = ones_count & 1;\n        wps->w.holding_zero = ~ones_count & 1;\n        ones_count = (ones_count >> 1) + low;\n\n        if (ones_count == 0) {\n            low = 0;\n            high = GET_MED (0) - 1;\n            DEC_MED0 ();\n        }\n        else {\n            low = GET_MED (0);\n            INC_MED0 ();\n\n            if (ones_count == 1) {\n                high = low + GET_MED (1) - 1;\n                DEC_MED1 ();\n            }\n            else {\n                low += GET_MED (1);\n                INC_MED1 ();\n\n                if (ones_count == 2) {\n                    high = low + GET_MED (2) - 1;\n                    DEC_MED2 ();\n                }\n                else {\n                    low += (ones_count - 2) * GET_MED (2);\n                    high = low + GET_MED (2) - 1;\n                    INC_MED2 ();\n                }\n            }\n        }\n\n        low += read_code (bs, high - low);\n        buffer [csamples] = (getbit (bs)) ? ~low : low;\n    }\n\n    return (wps->wphdr.flags & MONO_DATA) ? csamples : (csamples / 2);\n}\n\n// Read a single unsigned value from the specified bitstream with a value\n// from 0 to maxcode. If there are exactly a power of two number of possible\n// codes then this will read a fixed number of bits; otherwise it reads the\n// minimum number of bits and then determines whether another bit is needed\n// to define the code.\n\nstatic uint32_t __inline read_code (Bitstream *bs, uint32_t maxcode)\n{\n    unsigned long local_sr;\n    uint32_t extras, code;\n    int bitcount;\n\n    if (maxcode < 2)\n        return maxcode ? getbit (bs) : 0;\n\n    bitcount = count_bits (maxcode);\n#ifdef USE_BITMASK_TABLES\n    extras = bitset [bitcount] - maxcode - 1;\n#else\n    extras = (1 << bitcount) - maxcode - 1;\n#endif\n\n    local_sr = bs->sr;\n\n    while (bs->bc < bitcount) {\n        if (++(bs->ptr) == bs->end)\n            bs->wrap (bs);\n\n        local_sr |= (long)*(bs->ptr) << bs->bc;\n        bs->bc += sizeof (*(bs->ptr)) * 8;\n    }\n\n#ifdef USE_BITMASK_TABLES\n    if ((code = local_sr & bitmask [bitcount - 1]) >= extras)\n#else\n    if ((code = local_sr & ((1 << (bitcount - 1)) - 1)) >= extras)\n#endif\n        code = (code << 1) - extras + ((local_sr >> (bitcount - 1)) & 1);\n    else\n        bitcount--;\n\n    if (sizeof (local_sr) < 8 && bs->bc > sizeof (local_sr) * 8) {\n        bs->bc -= bitcount;\n        bs->sr = *(bs->ptr) >> (sizeof (*(bs->ptr)) * 8 - bs->bc);\n    }\n    else {\n        bs->bc -= bitcount;\n        bs->sr = local_sr >> bitcount;\n    }\n\n    return code;\n}\n"], "fixing_code": ["////////////////////////////////////////////////////////////////////////////\n//                           **** WAVPACK ****                            //\n//                  Hybrid Lossless Wavefile Compressor                   //\n//                Copyright (c) 1998 - 2016 David Bryant.                 //\n//                          All Rights Reserved.                          //\n//      Distributed under the BSD Software License (see license.txt)      //\n////////////////////////////////////////////////////////////////////////////\n\n// open_utils.c\n\n// This module provides all the code required to open an existing WavPack file\n// for reading by using a reader callback mechanism (NOT a filename). This\n// includes the code required to find and parse WavPack blocks, process any\n// included metadata, and queue up the bitstreams containing the encoded audio\n// data. It does not the actual code to unpack audio data and this was done so\n// that programs that just want to query WavPack files for information (like,\n// for example, taggers) don't need to link in a lot of unnecessary code.\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"wavpack_local.h\"\n\n// This function is identical to WavpackOpenFileInput() except that instead\n// of providing a filename to open, the caller provides a pointer to a set of\n// reader callbacks and instances of up to two streams. The first of these\n// streams is required and contains the regular WavPack data stream; the second\n// contains the \"correction\" file if desired. Unlike the standard open\n// function which handles the correction file transparently, in this case it\n// is the responsibility of the caller to be aware of correction files.\n\nstatic int seek_eof_information (WavpackContext *wpc, int64_t *final_index, int get_wrapper);\n\nWavpackContext *WavpackOpenFileInputEx64 (WavpackStreamReader64 *reader, void *wv_id, void *wvc_id, char *error, int flags, int norm_offset)\n{\n    WavpackContext *wpc = malloc (sizeof (WavpackContext));\n    WavpackStream *wps;\n    int num_blocks = 0;\n    unsigned char first_byte;\n    uint32_t bcount;\n\n    if (!wpc) {\n        if (error) strcpy (error, \"can't allocate memory\");\n        return NULL;\n    }\n\n    CLEAR (*wpc);\n    wpc->wv_in = wv_id;\n    wpc->wvc_in = wvc_id;\n    wpc->reader = reader;\n    wpc->total_samples = -1;\n    wpc->norm_offset = norm_offset;\n    wpc->max_streams = OLD_MAX_STREAMS;     // use this until overwritten with actual number\n    wpc->open_flags = flags;\n\n    wpc->filelen = wpc->reader->get_length (wpc->wv_in);\n\n#ifndef NO_TAGS\n    if ((flags & (OPEN_TAGS | OPEN_EDIT_TAGS)) && wpc->reader->can_seek (wpc->wv_in)) {\n        load_tag (wpc);\n        wpc->reader->set_pos_abs (wpc->wv_in, 0);\n\n        if ((flags & OPEN_EDIT_TAGS) && !editable_tag (&wpc->m_tag)) {\n            if (error) strcpy (error, \"can't edit tags located at the beginning of files!\");\n            return WavpackCloseFile (wpc);\n        }\n    }\n#endif\n\n    if (wpc->reader->read_bytes (wpc->wv_in, &first_byte, 1) != 1) {\n        if (error) strcpy (error, \"can't read all of WavPack file!\");\n        return WavpackCloseFile (wpc);\n    }\n\n    wpc->reader->push_back_byte (wpc->wv_in, first_byte);\n\n    if (first_byte == 'R') {\n#ifdef ENABLE_LEGACY\n        return open_file3 (wpc, error);\n#else\n        if (error) strcpy (error, \"this legacy WavPack file is deprecated, use version 4.80.0 to transcode\");\n        return WavpackCloseFile (wpc);\n#endif\n    }\n\n    wpc->streams = malloc ((wpc->num_streams = 1) * sizeof (wpc->streams [0]));\n    if (!wpc->streams) {\n        if (error) strcpy (error, \"can't allocate memory\");\n        return WavpackCloseFile (wpc);\n    }\n\n    wpc->streams [0] = wps = malloc (sizeof (WavpackStream));\n    if (!wps) {\n        if (error) strcpy (error, \"can't allocate memory\");\n        return WavpackCloseFile (wpc);\n    }\n    CLEAR (*wps);\n\n    while (!wps->wphdr.block_samples) {\n\n        wpc->filepos = wpc->reader->get_pos (wpc->wv_in);\n        bcount = read_next_header (wpc->reader, wpc->wv_in, &wps->wphdr);\n\n        if (bcount == (uint32_t) -1 ||\n            (!wps->wphdr.block_samples && num_blocks++ > 16)) {\n                if (error) strcpy (error, \"not compatible with this version of WavPack file!\");\n                return WavpackCloseFile (wpc);\n        }\n\n        wpc->filepos += bcount;\n        wps->blockbuff = malloc (wps->wphdr.ckSize + 8);\n        if (!wps->blockbuff) {\n            if (error) strcpy (error, \"can't allocate memory\");\n            return WavpackCloseFile (wpc);\n        }\n        memcpy (wps->blockbuff, &wps->wphdr, 32);\n\n        if (wpc->reader->read_bytes (wpc->wv_in, wps->blockbuff + 32, wps->wphdr.ckSize - 24) != wps->wphdr.ckSize - 24) {\n            if (error) strcpy (error, \"can't read all of WavPack file!\");\n            return WavpackCloseFile (wpc);\n        }\n\n        // if block does not verify, flag error, free buffer, and continue\n        if (!WavpackVerifySingleBlock (wps->blockbuff, !(flags & OPEN_NO_CHECKSUM))) {\n            wps->wphdr.block_samples = 0;\n            free (wps->blockbuff);\n            wps->blockbuff = NULL;\n            wpc->crc_errors++;\n            continue;\n        }\n\n        wps->init_done = FALSE;\n\n        if (wps->wphdr.block_samples) {\n            if (flags & OPEN_STREAMING)\n                SET_BLOCK_INDEX (wps->wphdr, 0);\n            else if (wpc->total_samples == -1) {\n                if (GET_BLOCK_INDEX (wps->wphdr) || GET_TOTAL_SAMPLES (wps->wphdr) == -1) {\n                    wpc->initial_index = GET_BLOCK_INDEX (wps->wphdr);\n                    SET_BLOCK_INDEX (wps->wphdr, 0);\n\n                    if (wpc->reader->can_seek (wpc->wv_in)) {\n                        int64_t final_index = -1;\n\n                        seek_eof_information (wpc, &final_index, FALSE);\n\n                        if (final_index != -1)\n                            wpc->total_samples = final_index - wpc->initial_index;\n                    }\n                }\n                else\n                    wpc->total_samples = GET_TOTAL_SAMPLES (wps->wphdr);\n            }\n        }\n        else if (wpc->total_samples == -1 && !GET_BLOCK_INDEX (wps->wphdr) && GET_TOTAL_SAMPLES (wps->wphdr))\n            wpc->total_samples = GET_TOTAL_SAMPLES (wps->wphdr);\n\n        if (wpc->wvc_in && wps->wphdr.block_samples && (wps->wphdr.flags & HYBRID_FLAG)) {\n            unsigned char ch;\n\n            if (wpc->reader->read_bytes (wpc->wvc_in, &ch, 1) == 1) {\n                wpc->reader->push_back_byte (wpc->wvc_in, ch);\n                wpc->file2len = wpc->reader->get_length (wpc->wvc_in);\n                wpc->wvc_flag = TRUE;\n            }\n        }\n\n        if (wpc->wvc_flag && !read_wvc_block (wpc)) {\n            if (error) strcpy (error, \"not compatible with this version of correction file!\");\n            return WavpackCloseFile (wpc);\n        }\n\n        if (!wps->init_done && !unpack_init (wpc)) {\n            if (error) strcpy (error, wpc->error_message [0] ? wpc->error_message :\n                \"not compatible with this version of WavPack file!\");\n\n            return WavpackCloseFile (wpc);\n        }\n\n        wps->init_done = TRUE;\n    }\n\n    wpc->config.flags &= ~0xff;\n    wpc->config.flags |= wps->wphdr.flags & 0xff;\n\n    if (!wpc->config.num_channels) {\n        wpc->config.num_channels = (wps->wphdr.flags & MONO_FLAG) ? 1 : 2;\n        wpc->config.channel_mask = 0x5 - wpc->config.num_channels;\n    }\n\n    if ((flags & OPEN_2CH_MAX) && !(wps->wphdr.flags & FINAL_BLOCK))\n        wpc->reduced_channels = (wps->wphdr.flags & MONO_FLAG) ? 1 : 2;\n\n    if (wps->wphdr.flags & DSD_FLAG) {\n#ifdef ENABLE_DSD\n        if (flags & OPEN_DSD_NATIVE) {\n            wpc->config.bytes_per_sample = 1;\n            wpc->config.bits_per_sample = 8;\n        }\n        else if (flags & OPEN_DSD_AS_PCM) {\n            wpc->decimation_context = decimate_dsd_init (wpc->reduced_channels ?\n                wpc->reduced_channels : wpc->config.num_channels);\n\n            wpc->config.bytes_per_sample = 3;\n            wpc->config.bits_per_sample = 24;\n        }\n        else {\n            if (error) strcpy (error, \"not configured to handle DSD WavPack files!\");\n            return WavpackCloseFile (wpc);\n        }\n#else\n        if (error) strcpy (error, \"not configured to handle DSD WavPack files!\");\n        return WavpackCloseFile (wpc);\n#endif\n    }\n    else {\n        wpc->config.bytes_per_sample = (wps->wphdr.flags & BYTES_STORED) + 1;\n        wpc->config.float_norm_exp = wps->float_norm_exp;\n\n        wpc->config.bits_per_sample = (wpc->config.bytes_per_sample * 8) -\n            ((wps->wphdr.flags & SHIFT_MASK) >> SHIFT_LSB);\n    }\n\n    if (!wpc->config.sample_rate) {\n        if (!wps->wphdr.block_samples || (wps->wphdr.flags & SRATE_MASK) == SRATE_MASK)\n            wpc->config.sample_rate = 44100;\n        else\n            wpc->config.sample_rate = sample_rates [(wps->wphdr.flags & SRATE_MASK) >> SRATE_LSB];\n    }\n\n    return wpc;\n}\n\n// This function returns the major version number of the WavPack program\n// (or library) that created the open file. Currently, this can be 1 to 5.\n// Minor versions are not recorded in WavPack files.\n\nint WavpackGetVersion (WavpackContext *wpc)\n{\n    if (wpc) {\n#ifdef ENABLE_LEGACY\n        if (wpc->stream3)\n            return get_version3 (wpc);\n#endif\n        return wpc->version_five ? 5 : 4;\n    }\n\n    return 0;\n}\n\n// Return the file format specified in the call to WavpackSetFileInformation()\n// when the file was created. For all files created prior to WavPack 5.0 this\n// will 0 (WP_FORMAT_WAV).\n\nunsigned char WavpackGetFileFormat (WavpackContext *wpc)\n{\n    return wpc->file_format;\n}\n\n// Return a string representing the recommended file extension for the open\n// WavPack file. For all files created prior to WavPack 5.0 this will be \"wav\",\n// even for raw files with no RIFF into. This string is specified in the\n// call to WavpackSetFileInformation() when the file was created.\n\nchar *WavpackGetFileExtension (WavpackContext *wpc)\n{\n    if (wpc && wpc->file_extension [0])\n        return wpc->file_extension;\n    else\n        return \"wav\";\n}\n\n// This function initializes everything required to unpack a WavPack block\n// and must be called before unpack_samples() is called to obtain audio data.\n// It is assumed that the WavpackHeader has been read into the wps->wphdr\n// (in the current WavpackStream) and that the entire block has been read at\n// wps->blockbuff. If a correction file is available (wpc->wvc_flag = TRUE)\n// then the corresponding correction block must be read into wps->block2buff\n// and its WavpackHeader has overwritten the header at wps->wphdr. This is\n// where all the metadata blocks are scanned including those that contain\n// bitstream data.\n\nstatic int read_metadata_buff (WavpackMetadata *wpmd, unsigned char *blockbuff, unsigned char **buffptr);\nstatic int process_metadata (WavpackContext *wpc, WavpackMetadata *wpmd);\nstatic void bs_open_read (Bitstream *bs, void *buffer_start, void *buffer_end);\n\nint unpack_init (WavpackContext *wpc)\n{\n    WavpackStream *wps = wpc->streams [wpc->current_stream];\n    unsigned char *blockptr, *block2ptr;\n    WavpackMetadata wpmd;\n\n    wps->num_terms = 0;\n    wps->mute_error = FALSE;\n    wps->crc = wps->crc_x = 0xffffffff;\n    wps->dsd.ready = 0;\n    CLEAR (wps->wvbits);\n    CLEAR (wps->wvcbits);\n    CLEAR (wps->wvxbits);\n    CLEAR (wps->decorr_passes);\n    CLEAR (wps->dc);\n    CLEAR (wps->w);\n\n    if (!(wps->wphdr.flags & MONO_FLAG) && wpc->config.num_channels && wps->wphdr.block_samples &&\n        (wpc->reduced_channels == 1 || wpc->config.num_channels == 1)) {\n            wps->mute_error = TRUE;\n            return FALSE;\n    }\n\n    if ((wps->wphdr.flags & UNKNOWN_FLAGS) || (wps->wphdr.flags & MONO_DATA) == MONO_DATA) {\n        wps->mute_error = TRUE;\n        return FALSE;\n    }\n\n    blockptr = wps->blockbuff + sizeof (WavpackHeader);\n\n    while (read_metadata_buff (&wpmd, wps->blockbuff, &blockptr))\n        if (!process_metadata (wpc, &wpmd)) {\n            wps->mute_error = TRUE;\n            return FALSE;\n        }\n\n    if (wps->wphdr.block_samples && wpc->wvc_flag && wps->block2buff) {\n        block2ptr = wps->block2buff + sizeof (WavpackHeader);\n\n        while (read_metadata_buff (&wpmd, wps->block2buff, &block2ptr))\n            if (!process_metadata (wpc, &wpmd)) {\n                wps->mute_error = TRUE;\n                return FALSE;\n            }\n    }\n\n    if (wps->wphdr.block_samples && ((wps->wphdr.flags & DSD_FLAG) ? !wps->dsd.ready : !bs_is_open (&wps->wvbits))) {\n        if (bs_is_open (&wps->wvcbits))\n            strcpy (wpc->error_message, \"can't unpack correction files alone!\");\n\n        wps->mute_error = TRUE;\n        return FALSE;\n    }\n\n    if (wps->wphdr.block_samples && !bs_is_open (&wps->wvxbits)) {\n        if ((wps->wphdr.flags & INT32_DATA) && wps->int32_sent_bits)\n            wpc->lossy_blocks = TRUE;\n\n        if ((wps->wphdr.flags & FLOAT_DATA) &&\n            wps->float_flags & (FLOAT_EXCEPTIONS | FLOAT_ZEROS_SENT | FLOAT_SHIFT_SENT | FLOAT_SHIFT_SAME))\n                wpc->lossy_blocks = TRUE;\n    }\n\n    if (wps->wphdr.block_samples)\n        wps->sample_index = GET_BLOCK_INDEX (wps->wphdr);\n\n    return TRUE;\n}\n\n//////////////////////////////// matadata handlers ///////////////////////////////\n\n// These functions handle specific metadata types and are called directly\n// during WavPack block parsing by process_metadata() at the bottom.\n\n// This function initialzes the main bitstream for audio samples, which must\n// be in the \"wv\" file.\n\nstatic int init_wv_bitstream (WavpackStream *wps, WavpackMetadata *wpmd)\n{\n    if (!wpmd->byte_length || (wpmd->byte_length & 1))\n        return FALSE;\n\n    bs_open_read (&wps->wvbits, wpmd->data, (unsigned char *) wpmd->data + wpmd->byte_length);\n    return TRUE;\n}\n\n// This function initialzes the \"correction\" bitstream for audio samples,\n// which currently must be in the \"wvc\" file.\n\nstatic int init_wvc_bitstream (WavpackStream *wps, WavpackMetadata *wpmd)\n{\n    if (!wpmd->byte_length || (wpmd->byte_length & 1))\n        return FALSE;\n\n    bs_open_read (&wps->wvcbits, wpmd->data, (unsigned char *) wpmd->data + wpmd->byte_length);\n    return TRUE;\n}\n\n// This function initialzes the \"extra\" bitstream for audio samples which\n// contains the information required to losslessly decompress 32-bit float data\n// or integer data that exceeds 24 bits. This bitstream is in the \"wv\" file\n// for pure lossless data or the \"wvc\" file for hybrid lossless. This data\n// would not be used for hybrid lossy mode. There is also a 32-bit CRC stored\n// in the first 4 bytes of these blocks.\n\nstatic int init_wvx_bitstream (WavpackStream *wps, WavpackMetadata *wpmd)\n{\n    unsigned char *cp = wpmd->data;\n\n    if (wpmd->byte_length <= 4 || (wpmd->byte_length & 1))\n        return FALSE;\n\n    wps->crc_wvx = *cp++;\n    wps->crc_wvx |= (int32_t) *cp++ << 8;\n    wps->crc_wvx |= (int32_t) *cp++ << 16;\n    wps->crc_wvx |= (int32_t) *cp++ << 24;\n\n    bs_open_read (&wps->wvxbits, cp, (unsigned char *) wpmd->data + wpmd->byte_length);\n    return TRUE;\n}\n\n// Read the int32 data from the specified metadata into the specified stream.\n// This data is used for integer data that has more than 24 bits of magnitude\n// or, in some cases, used to eliminate redundant bits from any audio stream.\n\nstatic int read_int32_info (WavpackStream *wps, WavpackMetadata *wpmd)\n{\n    int bytecnt = wpmd->byte_length;\n    char *byteptr = wpmd->data;\n\n    if (bytecnt != 4)\n        return FALSE;\n\n    wps->int32_sent_bits = *byteptr++;\n    wps->int32_zeros = *byteptr++;\n    wps->int32_ones = *byteptr++;\n    wps->int32_dups = *byteptr;\n\n    return TRUE;\n}\n\nstatic int read_float_info (WavpackStream *wps, WavpackMetadata *wpmd)\n{\n    int bytecnt = wpmd->byte_length;\n    char *byteptr = wpmd->data;\n\n    if (bytecnt != 4)\n        return FALSE;\n\n    wps->float_flags = *byteptr++;\n    wps->float_shift = *byteptr++;\n    wps->float_max_exp = *byteptr++;\n    wps->float_norm_exp = *byteptr;\n    return TRUE;\n}\n\n// Read multichannel information from metadata. The first byte is the total\n// number of channels and the following bytes represent the channel_mask\n// as described for Microsoft WAVEFORMATEX.\n\nstatic int read_channel_info (WavpackContext *wpc, WavpackMetadata *wpmd)\n{\n    int bytecnt = wpmd->byte_length, shift = 0, mask_bits;\n    unsigned char *byteptr = wpmd->data;\n    uint32_t mask = 0;\n\n    if (!bytecnt || bytecnt > 7)\n        return FALSE;\n\n    if (!wpc->config.num_channels) {\n\n        // if bytecnt is 6 or 7 we are using new configuration with \"unlimited\" streams\n\n        if (bytecnt >= 6) {\n            wpc->config.num_channels = (byteptr [0] | ((byteptr [2] & 0xf) << 8)) + 1;\n            wpc->max_streams = (byteptr [1] | ((byteptr [2] & 0xf0) << 4)) + 1;\n\n            if (wpc->config.num_channels < wpc->max_streams)\n                return FALSE;\n    \n            byteptr += 3;\n            mask = *byteptr++;\n            mask |= (uint32_t) *byteptr++ << 8;\n            mask |= (uint32_t) *byteptr++ << 16;\n\n            if (bytecnt == 7)                           // this was introduced in 5.0\n                mask |= (uint32_t) *byteptr << 24;\n        }\n        else {\n            wpc->config.num_channels = *byteptr++;\n\n            while (--bytecnt) {\n                mask |= (uint32_t) *byteptr++ << shift;\n                shift += 8;\n            }\n        }\n\n        if (wpc->config.num_channels > wpc->max_streams * 2)\n            return FALSE;\n\n        wpc->config.channel_mask = mask;\n\n        for (mask_bits = 0; mask; mask >>= 1)\n            if ((mask & 1) && ++mask_bits > wpc->config.num_channels)\n                return FALSE;\n    }\n\n    return TRUE;\n}\n\n// Read multichannel identity information from metadata. Data is an array of\n// unsigned characters representing any channels in the file that DO NOT\n// match one the 18 Microsoft standard channels (and are represented in the\n// channel mask). A value of 0 is not allowed and 0xff means an unknown or\n// undefined channel identity.\n\nstatic int read_channel_identities (WavpackContext *wpc, WavpackMetadata *wpmd)\n{\n    if (!wpc->channel_identities) {\n        wpc->channel_identities = malloc (wpmd->byte_length + 1);\n        memcpy (wpc->channel_identities, wpmd->data, wpmd->byte_length);\n        wpc->channel_identities [wpmd->byte_length] = 0;\n    }\n\n    return TRUE;\n}\n\n// Read configuration information from metadata.\n\nstatic int read_config_info (WavpackContext *wpc, WavpackMetadata *wpmd)\n{\n    int bytecnt = wpmd->byte_length;\n    unsigned char *byteptr = wpmd->data;\n\n    if (bytecnt >= 3) {\n        wpc->config.flags &= 0xff;\n        wpc->config.flags |= (int32_t) *byteptr++ << 8;\n        wpc->config.flags |= (int32_t) *byteptr++ << 16;\n        wpc->config.flags |= (int32_t) *byteptr++ << 24;\n        bytecnt -= 3;\n\n        if (bytecnt && (wpc->config.flags & CONFIG_EXTRA_MODE)) {\n            wpc->config.xmode = *byteptr++;\n            bytecnt--;\n        }\n\n        // we used an extra config byte here for the 5.0.0 alpha, so still\n        // honor it now (but this has been replaced with NEW_CONFIG)\n\n        if (bytecnt) {\n            wpc->config.qmode = (wpc->config.qmode & ~0xff) | *byteptr;\n            wpc->version_five = 1;\n        }\n    }\n\n    return TRUE;\n}\n\n// Read \"new\" configuration information from metadata.\n\nstatic int read_new_config_info (WavpackContext *wpc, WavpackMetadata *wpmd)\n{\n    int bytecnt = wpmd->byte_length;\n    unsigned char *byteptr = wpmd->data;\n\n    wpc->version_five = 1;      // just having this block signals version 5.0\n\n    wpc->file_format = wpc->config.qmode = wpc->channel_layout = 0;\n\n    if (wpc->channel_reordering) {\n        free (wpc->channel_reordering);\n        wpc->channel_reordering = NULL;\n    }\n\n    // if there's any data, the first two bytes are file_format and qmode flags\n\n    if (bytecnt >= 2) {\n        wpc->file_format = *byteptr++;\n        wpc->config.qmode = (wpc->config.qmode & ~0xff) | *byteptr++;\n        bytecnt -= 2;\n\n        // another byte indicates a channel layout\n\n        if (bytecnt) {\n            int nchans, i;\n\n            wpc->channel_layout = (int32_t) *byteptr++ << 16;\n            bytecnt--;\n\n            // another byte means we have a channel count for the layout and maybe a reordering\n\n            if (bytecnt) {\n                wpc->channel_layout += nchans = *byteptr++;\n                bytecnt--;\n\n                // any more means there's a reordering string\n\n                if (bytecnt) {\n                    if (bytecnt > nchans)\n                        return FALSE;\n\n                    wpc->channel_reordering = malloc (nchans);\n\n                    // note that redundant reordering info is not stored, so we fill in the rest\n\n                    if (wpc->channel_reordering) {\n                        for (i = 0; i < nchans; ++i)\n                            if (bytecnt) {\n                                wpc->channel_reordering [i] = *byteptr++;\n\n                                if (wpc->channel_reordering [i] >= nchans)  // make sure index is in range\n                                    wpc->channel_reordering [i] = 0;\n\n                                bytecnt--;\n                            }\n                            else\n                                wpc->channel_reordering [i] = i;\n                    }\n                }\n            }\n            else\n                wpc->channel_layout += wpc->config.num_channels;\n        }\n    }\n\n    return TRUE;\n}\n\n// Read non-standard sampling rate from metadata.\n\nstatic int read_sample_rate (WavpackContext *wpc, WavpackMetadata *wpmd)\n{\n    int bytecnt = wpmd->byte_length;\n    unsigned char *byteptr = wpmd->data;\n\n    if (bytecnt == 3 || bytecnt == 4) {\n        wpc->config.sample_rate = (int32_t) *byteptr++;\n        wpc->config.sample_rate |= (int32_t) *byteptr++ << 8;\n        wpc->config.sample_rate |= (int32_t) *byteptr++ << 16;\n\n        // for sampling rates > 16777215 (non-audio probably, or ...)\n\n        if (bytecnt == 4)\n            wpc->config.sample_rate |= (int32_t) (*byteptr & 0x7f) << 24;\n    }\n\n    return TRUE;\n}\n\n// Read wrapper data from metadata. Currently, this consists of the RIFF\n// header and trailer that wav files contain around the audio data but could\n// be used for other formats as well. Because WavPack files contain all the\n// information required for decoding and playback, this data can probably\n// be ignored except when an exact wavefile restoration is needed.\n\nstatic int read_wrapper_data (WavpackContext *wpc, WavpackMetadata *wpmd)\n{\n    if ((wpc->open_flags & OPEN_WRAPPER) && wpc->wrapper_bytes < MAX_WRAPPER_BYTES && wpmd->byte_length) {\n        wpc->wrapper_data = realloc (wpc->wrapper_data, wpc->wrapper_bytes + wpmd->byte_length);\n\tif (!wpc->wrapper_data)\n\t    return FALSE;\n        memcpy (wpc->wrapper_data + wpc->wrapper_bytes, wpmd->data, wpmd->byte_length);\n        wpc->wrapper_bytes += wpmd->byte_length;\n    }\n\n    return TRUE;\n}\n\nstatic int read_metadata_buff (WavpackMetadata *wpmd, unsigned char *blockbuff, unsigned char **buffptr)\n{\n    WavpackHeader *wphdr = (WavpackHeader *) blockbuff;\n    unsigned char *buffend = blockbuff + wphdr->ckSize + 8;\n\n    if (buffend - *buffptr < 2)\n        return FALSE;\n\n    wpmd->id = *(*buffptr)++;\n    wpmd->byte_length = *(*buffptr)++ << 1;\n\n    if (wpmd->id & ID_LARGE) {\n        wpmd->id &= ~ID_LARGE;\n\n        if (buffend - *buffptr < 2)\n            return FALSE;\n\n        wpmd->byte_length += *(*buffptr)++ << 9;\n        wpmd->byte_length += *(*buffptr)++ << 17;\n    }\n\n    if (wpmd->id & ID_ODD_SIZE) {\n        if (!wpmd->byte_length)         // odd size and zero length makes no sense\n            return FALSE;\n        wpmd->id &= ~ID_ODD_SIZE;\n        wpmd->byte_length--;\n    }\n\n    if (wpmd->byte_length) {\n        if (buffend - *buffptr < wpmd->byte_length + (wpmd->byte_length & 1)) {\n            wpmd->data = NULL;\n            return FALSE;\n        }\n\n        wpmd->data = *buffptr;\n        (*buffptr) += wpmd->byte_length + (wpmd->byte_length & 1);\n    }\n    else\n        wpmd->data = NULL;\n\n    return TRUE;\n}\n\nstatic int process_metadata (WavpackContext *wpc, WavpackMetadata *wpmd)\n{\n    WavpackStream *wps = wpc->streams [wpc->current_stream];\n\n    switch (wpmd->id) {\n        case ID_DUMMY:\n            return TRUE;\n\n        case ID_DECORR_TERMS:\n            return read_decorr_terms (wps, wpmd);\n\n        case ID_DECORR_WEIGHTS:\n            return read_decorr_weights (wps, wpmd);\n\n        case ID_DECORR_SAMPLES:\n            return read_decorr_samples (wps, wpmd);\n\n        case ID_ENTROPY_VARS:\n            return read_entropy_vars (wps, wpmd);\n\n        case ID_HYBRID_PROFILE:\n            return read_hybrid_profile (wps, wpmd);\n\n        case ID_SHAPING_WEIGHTS:\n            return read_shaping_info (wps, wpmd);\n\n        case ID_FLOAT_INFO:\n            return read_float_info (wps, wpmd);\n\n        case ID_INT32_INFO:\n            return read_int32_info (wps, wpmd);\n\n        case ID_CHANNEL_INFO:\n            return read_channel_info (wpc, wpmd);\n\n        case ID_CHANNEL_IDENTITIES:\n            return read_channel_identities (wpc, wpmd);\n\n        case ID_CONFIG_BLOCK:\n            return read_config_info (wpc, wpmd);\n\n        case ID_NEW_CONFIG_BLOCK:\n            return read_new_config_info (wpc, wpmd);\n\n        case ID_SAMPLE_RATE:\n            return read_sample_rate (wpc, wpmd);\n\n        case ID_WV_BITSTREAM:\n            return init_wv_bitstream (wps, wpmd);\n\n        case ID_WVC_BITSTREAM:\n            return init_wvc_bitstream (wps, wpmd);\n\n        case ID_WVX_BITSTREAM:\n            return init_wvx_bitstream (wps, wpmd);\n\n        case ID_DSD_BLOCK:\n#ifdef ENABLE_DSD\n            return init_dsd_block (wpc, wpmd);\n#else\n            strcpy (wpc->error_message, \"not configured to handle DSD WavPack files!\");\n            return FALSE;\n#endif\n\n        case ID_ALT_HEADER: case ID_ALT_TRAILER:\n            if (!(wpc->open_flags & OPEN_ALT_TYPES))\n                return TRUE;\n\n        case ID_RIFF_HEADER: case ID_RIFF_TRAILER:\n            return read_wrapper_data (wpc, wpmd);\n\n        case ID_ALT_MD5_CHECKSUM:\n            if (!(wpc->open_flags & OPEN_ALT_TYPES))\n                return TRUE;\n\n        case ID_MD5_CHECKSUM:\n            if (wpmd->byte_length == 16) {\n                memcpy (wpc->config.md5_checksum, wpmd->data, 16);\n                wpc->config.flags |= CONFIG_MD5_CHECKSUM;\n                wpc->config.md5_read = 1;\n            }\n\n            return TRUE;\n\n        case ID_ALT_EXTENSION:\n            if (wpmd->byte_length && wpmd->byte_length < sizeof (wpc->file_extension)) {\n                memcpy (wpc->file_extension, wpmd->data, wpmd->byte_length);\n                wpc->file_extension [wpmd->byte_length] = 0;\n            }\n\n            return TRUE;\n\n        // we don't actually verify the checksum here (it's done right after the\n        // block is read), but it's a good indicator of version 5 files\n\n        case ID_BLOCK_CHECKSUM:\n            wpc->version_five = 1;\n            return TRUE;\n\n        default:\n            return (wpmd->id & ID_OPTIONAL_DATA) ? TRUE : FALSE;\n    }\n}\n\n//////////////////////////////// bitstream management ///////////////////////////////\n\n// Open the specified BitStream and associate with the specified buffer.\n\nstatic void bs_read (Bitstream *bs);\n\nstatic void bs_open_read (Bitstream *bs, void *buffer_start, void *buffer_end)\n{\n    bs->error = bs->sr = bs->bc = 0;\n    bs->ptr = (bs->buf = buffer_start) - 1;\n    bs->end = buffer_end;\n    bs->wrap = bs_read;\n}\n\n// This function is only called from the getbit() and getbits() macros when\n// the BitStream has been exhausted and more data is required. Sinve these\n// bistreams no longer access files, this function simple sets an error and\n// resets the buffer.\n\nstatic void bs_read (Bitstream *bs)\n{\n    bs->ptr = bs->buf;\n    bs->error = 1;\n}\n\n// This function is called to close the bitstream. It returns the number of\n// full bytes actually read as bits.\n\nuint32_t bs_close_read (Bitstream *bs)\n{\n    uint32_t bytes_read;\n\n    if (bs->bc < sizeof (*(bs->ptr)) * 8)\n        bs->ptr++;\n\n    bytes_read = (uint32_t)(bs->ptr - bs->buf) * sizeof (*(bs->ptr));\n\n    if (!(bytes_read & 1))\n        ++bytes_read;\n\n    CLEAR (*bs);\n    return bytes_read;\n}\n\n// Normally the trailing wrapper will not be available when a WavPack file is first\n// opened for reading because it is stored in the final block of the file. This\n// function forces a seek to the end of the file to pick up any trailing wrapper\n// stored there (then use WavPackGetWrapper**() to obtain). This can obviously only\n// be used for seekable files (not pipes) and is not available for pre-4.0 WavPack\n// files.\n\nvoid WavpackSeekTrailingWrapper (WavpackContext *wpc)\n{\n    if ((wpc->open_flags & OPEN_WRAPPER) &&\n        wpc->reader->can_seek (wpc->wv_in) && !wpc->stream3)\n            seek_eof_information (wpc, NULL, TRUE);\n}\n\n// Get any MD5 checksum stored in the metadata (should be called after reading\n// last sample or an extra seek will occur). A return value of FALSE indicates\n// that no MD5 checksum was stored.\n\nint WavpackGetMD5Sum (WavpackContext *wpc, unsigned char data [16])\n{\n    if (wpc->config.flags & CONFIG_MD5_CHECKSUM) {\n        if (!wpc->config.md5_read && wpc->reader->can_seek (wpc->wv_in))\n            seek_eof_information (wpc, NULL, FALSE);\n\n        if (wpc->config.md5_read) {\n            memcpy (data, wpc->config.md5_checksum, 16);\n            return TRUE;\n        }\n    }\n\n    return FALSE;\n}\n\n// Read from current file position until a valid 32-byte WavPack 4.0 header is\n// found and read into the specified pointer. The number of bytes skipped is\n// returned. If no WavPack header is found within 1 meg, then a -1 is returned\n// to indicate the error. No additional bytes are read past the header and it\n// is returned in the processor's native endian mode. Seeking is not required.\n\nuint32_t read_next_header (WavpackStreamReader64 *reader, void *id, WavpackHeader *wphdr)\n{\n    unsigned char buffer [sizeof (*wphdr)], *sp = buffer + sizeof (*wphdr), *ep = sp;\n    uint32_t bytes_skipped = 0;\n    int bleft;\n\n    while (1) {\n        if (sp < ep) {\n            bleft = (int)(ep - sp);\n            memmove (buffer, sp, bleft);\n        }\n        else\n            bleft = 0;\n\n        if (reader->read_bytes (id, buffer + bleft, sizeof (*wphdr) - bleft) != sizeof (*wphdr) - bleft)\n            return -1;\n\n        sp = buffer;\n\n        if (*sp++ == 'w' && *sp == 'v' && *++sp == 'p' && *++sp == 'k' &&\n            !(*++sp & 1) && sp [2] < 16 && !sp [3] && (sp [2] || sp [1] || *sp >= 24) && sp [5] == 4 &&\n            sp [4] >= (MIN_STREAM_VERS & 0xff) && sp [4] <= (MAX_STREAM_VERS & 0xff) && sp [18] < 3 && !sp [19]) {\n                memcpy (wphdr, buffer, sizeof (*wphdr));\n                WavpackLittleEndianToNative (wphdr, WavpackHeaderFormat);\n                return bytes_skipped;\n            }\n\n        while (sp < ep && *sp != 'w')\n            sp++;\n\n        if ((bytes_skipped += (uint32_t)(sp - buffer)) > 1024 * 1024)\n            return -1;\n    }\n}\n\n// Compare the regular wv file block header to a potential matching wvc\n// file block header and return action code based on analysis:\n//\n//   0 = use wvc block (assuming rest of block is readable)\n//   1 = bad match; try to read next wvc block\n//  -1 = bad match; ignore wvc file for this block and backup fp (if\n//       possible) and try to use this block next time\n\nstatic int match_wvc_header (WavpackHeader *wv_hdr, WavpackHeader *wvc_hdr)\n{\n    if (GET_BLOCK_INDEX (*wv_hdr) == GET_BLOCK_INDEX (*wvc_hdr) &&\n        wv_hdr->block_samples == wvc_hdr->block_samples) {\n            int wvi = 0, wvci = 0;\n\n            if (wv_hdr->flags == wvc_hdr->flags)\n                return 0;\n\n            if (wv_hdr->flags & INITIAL_BLOCK)\n                wvi -= 1;\n\n            if (wv_hdr->flags & FINAL_BLOCK)\n                wvi += 1;\n\n            if (wvc_hdr->flags & INITIAL_BLOCK)\n                wvci -= 1;\n\n            if (wvc_hdr->flags & FINAL_BLOCK)\n                wvci += 1;\n\n            return (wvci - wvi < 0) ? 1 : -1;\n        }\n\n    if (((GET_BLOCK_INDEX (*wvc_hdr) - GET_BLOCK_INDEX (*wv_hdr)) << 24) < 0)\n        return 1;\n    else\n        return -1;\n}\n\n// Read the wvc block that matches the regular wv block that has been\n// read for the current stream. If an exact match is not found then\n// we either keep reading or back up and (possibly) use the block\n// later. The skip_wvc flag is set if not matching wvc block is found\n// so that we can still decode using only the lossy version (although\n// we flag this as an error). A return of FALSE indicates a serious\n// error (not just that we missed one wvc block).\n\nint read_wvc_block (WavpackContext *wpc)\n{\n    WavpackStream *wps = wpc->streams [wpc->current_stream];\n    int64_t bcount, file2pos;\n    WavpackHeader orig_wphdr;\n    WavpackHeader wphdr;\n    int compare_result;\n\n    while (1) {\n        file2pos = wpc->reader->get_pos (wpc->wvc_in);\n        bcount = read_next_header (wpc->reader, wpc->wvc_in, &wphdr);\n\n        if (bcount == (uint32_t) -1) {\n            wps->wvc_skip = TRUE;\n            wpc->crc_errors++;\n            return FALSE;\n        }\n\n        memcpy (&orig_wphdr, &wphdr, 32);       // save original header for verify step\n\n        if (wpc->open_flags & OPEN_STREAMING)\n            SET_BLOCK_INDEX (wphdr, wps->sample_index = 0);\n        else\n            SET_BLOCK_INDEX (wphdr, GET_BLOCK_INDEX (wphdr) - wpc->initial_index);\n\n        if (wphdr.flags & INITIAL_BLOCK)\n            wpc->file2pos = file2pos + bcount;\n\n        compare_result = match_wvc_header (&wps->wphdr, &wphdr);\n\n        if (!compare_result) {\n            wps->block2buff = malloc (wphdr.ckSize + 8);\n\t    if (!wps->block2buff)\n\t        return FALSE;\n\n            if (wpc->reader->read_bytes (wpc->wvc_in, wps->block2buff + 32, wphdr.ckSize - 24) !=\n                wphdr.ckSize - 24) {\n                    free (wps->block2buff);\n                    wps->block2buff = NULL;\n                    wps->wvc_skip = TRUE;\n                    wpc->crc_errors++;\n                    return FALSE;\n            }\n\n            memcpy (wps->block2buff, &orig_wphdr, 32);\n\n            // don't use corrupt blocks\n            if (!WavpackVerifySingleBlock (wps->block2buff, !(wpc->open_flags & OPEN_NO_CHECKSUM))) {\n                free (wps->block2buff);\n                wps->block2buff = NULL;\n                wps->wvc_skip = TRUE;\n                wpc->crc_errors++;\n                return TRUE;\n            }\n\n            wps->wvc_skip = FALSE;\n            memcpy (wps->block2buff, &wphdr, 32);\n            memcpy (&wps->wphdr, &wphdr, 32);\n            return TRUE;\n        }\n        else if (compare_result == -1) {\n            wps->wvc_skip = TRUE;\n            wpc->reader->set_pos_rel (wpc->wvc_in, -32, SEEK_CUR);\n            wpc->crc_errors++;\n            return TRUE;\n        }\n    }\n}\n\n// This function is used to seek to end of a file to obtain certain information\n// that is stored there at the file creation time because it is not known at\n// the start. This includes the MD5 sum and and trailing part of the file\n// wrapper, and in some rare cases may include the total number of samples in\n// the file (although we usually try to back up and write that at the front of\n// the file). Note this function restores the file position to its original\n// location (and obviously requires a seekable file). The normal return value\n// is TRUE indicating no errors, although this does not actually mean that any\n// information was retrieved. An error return of FALSE usually means the file\n// terminated unexpectedly. Note that this could be used to get all three\n// types of information in one go, but it's not actually used that way now.\n\nstatic int seek_eof_information (WavpackContext *wpc, int64_t *final_index, int get_wrapper)\n{\n    int64_t restore_pos, last_pos = -1;\n    WavpackStreamReader64 *reader = wpc->reader;\n    int alt_types = wpc->open_flags & OPEN_ALT_TYPES;\n    uint32_t blocks = 0, audio_blocks = 0;\n    void *id = wpc->wv_in;\n    WavpackHeader wphdr;\n\n    restore_pos = reader->get_pos (id);    // we restore file position when done\n\n    // start 1MB from the end-of-file, or from the start if the file is not that big\n\n    if (reader->get_length (id) > 1048576LL)\n        reader->set_pos_rel (id, -1048576, SEEK_END);\n    else\n        reader->set_pos_abs (id, 0);\n\n    // Note that we go backward (without parsing inside blocks) until we find a block\n    // with audio (careful to not get stuck in a loop). Only then do we go forward\n    // parsing all blocks in their entirety.\n\n    while (1) {\n        uint32_t bcount = read_next_header (reader, id, &wphdr);\n        int64_t current_pos = reader->get_pos (id);\n\n        // if we just got to the same place as last time, we're stuck and need to give up\n\n        if (current_pos == last_pos) {\n            reader->set_pos_abs (id, restore_pos);\n            return FALSE;\n        }\n\n        last_pos = current_pos;\n\n        // We enter here if we just read 1 MB without seeing any WavPack block headers.\n        // Since WavPack blocks are < 1 MB, that means we're in a big APE tag, or we got\n        // to the end-of-file.\n\n        if (bcount == (uint32_t) -1) {\n\n            // if we have not seen any blocks at all yet, back up almost 2 MB (or to the\n            // beginning of the file) and try again\n\n            if (!blocks) {\n                if (current_pos > 2000000LL)\n                    reader->set_pos_rel (id, -2000000, SEEK_CUR);\n                else\n                    reader->set_pos_abs (id, 0);\n\n                continue;\n            }\n\n            // if we have seen WavPack blocks, then this means we've done all we can do here\n\n            reader->set_pos_abs (id, restore_pos);\n            return TRUE;\n        }\n\n        blocks++;\n\n        // If the block has audio samples, calculate a final index, although this is not\n        // final since this may not be the last block with audio. On the other hand, if\n        // this block does not have audio, and we haven't seen one with audio, we have\n        // to go back some more.\n\n        if (wphdr.block_samples) {\n            if (final_index)\n                *final_index = GET_BLOCK_INDEX (wphdr) + wphdr.block_samples;\n\n            audio_blocks++;\n        }\n        else if (!audio_blocks) {\n            if (current_pos > 1048576LL)\n                reader->set_pos_rel (id, -1048576, SEEK_CUR);\n            else\n                reader->set_pos_abs (id, 0);\n\n            continue;\n        }\n\n        // at this point we have seen at least one block with audio, so we parse the\n        // entire block looking for MD5 metadata or (conditionally) trailing wrappers\n\n        bcount = wphdr.ckSize - sizeof (WavpackHeader) + 8;\n\n        while (bcount >= 2) {\n            unsigned char meta_id, c1, c2;\n            uint32_t meta_bc, meta_size;\n\n            if (reader->read_bytes (id, &meta_id, 1) != 1 ||\n                reader->read_bytes (id, &c1, 1) != 1) {\n                    reader->set_pos_abs (id, restore_pos);\n                    return FALSE;\n            }\n\n            meta_bc = c1 << 1;\n            bcount -= 2;\n\n            if (meta_id & ID_LARGE) {\n                if (bcount < 2 || reader->read_bytes (id, &c1, 1) != 1 ||\n                    reader->read_bytes (id, &c2, 1) != 1) {\n                        reader->set_pos_abs (id, restore_pos);\n                        return FALSE;\n                }\n\n                meta_bc += ((uint32_t) c1 << 9) + ((uint32_t) c2 << 17);\n                bcount -= 2;\n            }\n\n            meta_size = (meta_id & ID_ODD_SIZE) ? meta_bc - 1 : meta_bc;\n            meta_id &= ID_UNIQUE;\n\n            if (get_wrapper && (meta_id == ID_RIFF_TRAILER || (alt_types && meta_id == ID_ALT_TRAILER)) && meta_bc) {\n                wpc->wrapper_data = realloc (wpc->wrapper_data, wpc->wrapper_bytes + meta_bc);\n\n                if (!wpc->wrapper_data) {\n                    reader->set_pos_abs (id, restore_pos);\n                    return FALSE;\n                }\n\n                if (reader->read_bytes (id, wpc->wrapper_data + wpc->wrapper_bytes, meta_bc) == meta_bc)\n                    wpc->wrapper_bytes += meta_size;\n                else {\n                    reader->set_pos_abs (id, restore_pos);\n                    return FALSE;\n                }\n            }\n            else if (meta_id == ID_MD5_CHECKSUM || (alt_types && meta_id == ID_ALT_MD5_CHECKSUM)) {\n                if (meta_bc == 16 && bcount >= 16) {\n                    if (reader->read_bytes (id, wpc->config.md5_checksum, 16) == 16)\n                        wpc->config.md5_read = TRUE;\n                    else {\n                        reader->set_pos_abs (id, restore_pos);\n                        return FALSE;\n                    }\n                }\n                else\n                    reader->set_pos_rel (id, meta_bc, SEEK_CUR);\n            }\n            else\n                reader->set_pos_rel (id, meta_bc, SEEK_CUR);\n\n            bcount -= meta_bc;\n        }\n    }\n}\n\n// Quickly verify the referenced block. It is assumed that the WavPack header has been converted\n// to native endian format. If a block checksum is performed, that is done in little-endian\n// (file) format. It is also assumed that the caller has made sure that the block length\n// indicated in the header is correct (we won't overflow the buffer). If a checksum is present,\n// then it is checked, otherwise we just check that all the metadata blocks are formatted\n// correctly (without looking at their contents). Returns FALSE for bad block.\n\nint WavpackVerifySingleBlock (unsigned char *buffer, int verify_checksum)\n{\n    WavpackHeader *wphdr = (WavpackHeader *) buffer;\n    uint32_t checksum_passed = 0, bcount, meta_bc;\n    unsigned char *dp, meta_id, c1, c2;\n\n    if (strncmp (wphdr->ckID, \"wvpk\", 4) || wphdr->ckSize + 8 < sizeof (WavpackHeader))\n        return FALSE;\n\n    bcount = wphdr->ckSize - sizeof (WavpackHeader) + 8;\n    dp = (unsigned char *)(wphdr + 1);\n\n    while (bcount >= 2) {\n        meta_id = *dp++;\n        c1 = *dp++;\n\n        meta_bc = c1 << 1;\n        bcount -= 2;\n\n        if (meta_id & ID_LARGE) {\n            if (bcount < 2)\n                return FALSE;\n\n            c1 = *dp++;\n            c2 = *dp++;\n            meta_bc += ((uint32_t) c1 << 9) + ((uint32_t) c2 << 17);\n            bcount -= 2;\n        }\n\n        if (bcount < meta_bc)\n            return FALSE;\n\n        if (verify_checksum && (meta_id & ID_UNIQUE) == ID_BLOCK_CHECKSUM) {\n#ifdef BITSTREAM_SHORTS\n            uint16_t *csptr = (uint16_t*) buffer;\n#else\n            unsigned char *csptr = buffer;\n#endif\n            int wcount = (int)(dp - 2 - buffer) >> 1;\n            uint32_t csum = (uint32_t) -1;\n\n            if ((meta_id & ID_ODD_SIZE) || meta_bc < 2 || meta_bc > 4)\n                return FALSE;\n\n#ifdef BITSTREAM_SHORTS\n            while (wcount--)\n                csum = (csum * 3) + *csptr++;\n#else\n            WavpackNativeToLittleEndian ((WavpackHeader *) buffer, WavpackHeaderFormat);\n\n            while (wcount--) {\n                csum = (csum * 3) + csptr [0] + (csptr [1] << 8);\n                csptr += 2;\n            }\n\n            WavpackLittleEndianToNative ((WavpackHeader *) buffer, WavpackHeaderFormat);\n#endif\n\n            if (meta_bc == 4) {\n                if (*dp++ != (csum & 0xff) || *dp++ != ((csum >> 8) & 0xff) || *dp++ != ((csum >> 16) & 0xff) || *dp++ != ((csum >> 24) & 0xff))\n                    return FALSE;\n            }\n            else {\n                csum ^= csum >> 16;\n\n                if (*dp++ != (csum & 0xff) || *dp++ != ((csum >> 8) & 0xff))\n                    return FALSE;\n            }\n\n            checksum_passed++;\n        }\n\n        bcount -= meta_bc;\n        dp += meta_bc;\n    }\n\n    return (bcount == 0) && (!verify_checksum || !(wphdr->flags & HAS_CHECKSUM) || checksum_passed);\n}\n", "////////////////////////////////////////////////////////////////////////////\n//                           **** WAVPACK ****                            //\n//                  Hybrid Lossless Wavefile Compressor                   //\n//              Copyright (c) 1998 - 2013 Conifer Software.               //\n//                          All Rights Reserved.                          //\n//      Distributed under the BSD Software License (see license.txt)      //\n////////////////////////////////////////////////////////////////////////////\n\n// read_words.c\n\n// This module provides entropy word decoding functions using\n// a variation on the Rice method.  This was introduced in version 3.93\n// because it allows splitting the data into a \"lossy\" stream and a\n// \"correction\" stream in a very efficient manner and is therefore ideal\n// for the \"hybrid\" mode.  For 4.0, the efficiency of this method was\n// significantly improved by moving away from the normal Rice restriction of\n// using powers of two for the modulus divisions and now the method can be\n// used for both hybrid and pure lossless encoding.\n\n// Samples are divided by median probabilities at 5/7 (71.43%), 10/49 (20.41%),\n// and 20/343 (5.83%). Each zone has 3.5 times fewer samples than the\n// previous. Using standard Rice coding on this data would result in 1.4\n// bits per sample average (not counting sign bit). However, there is a\n// very simple encoding that is over 99% efficient with this data and\n// results in about 1.22 bits per sample.\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"wavpack_local.h\"\n\n#if defined (HAVE___BUILTIN_CTZ) || defined (_WIN64)\n#define USE_CTZ_OPTIMIZATION    // use ctz intrinsic (or Windows equivalent) to count trailing ones\n#else\n#define USE_NEXT8_OPTIMIZATION  // optimization using a table to count trailing ones\n#endif\n\n#define USE_BITMASK_TABLES      // use tables instead of shifting for certain masking operations\n\n///////////////////////////// local table storage ////////////////////////////\n\n#ifdef USE_NEXT8_OPTIMIZATION\nstatic const char ones_count_table [] = {\n    0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,\n    0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,\n    0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,\n    0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,7,\n    0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,\n    0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,\n    0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,\n    0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,8\n};\n#endif\n\n///////////////////////////// executable code ////////////////////////////////\n\nstatic uint32_t __inline read_code (Bitstream *bs, uint32_t maxcode);\n\n// Read the next word from the bitstream \"wvbits\" and return the value. This\n// function can be used for hybrid or lossless streams, but since an\n// optimized version is available for lossless this function would normally\n// be used for hybrid only. If a hybrid lossless stream is being read then\n// the \"correction\" offset is written at the specified pointer. A return value\n// of WORD_EOF indicates that the end of the bitstream was reached (all 1s) or\n// some other error occurred.\n\nint32_t FASTCALL get_word (WavpackStream *wps, int chan, int32_t *correction)\n{\n    register struct entropy_data *c = wps->w.c + chan;\n    uint32_t ones_count, low, mid, high;\n    int32_t value;\n    int sign;\n\n    if (!wps->wvbits.ptr)\n        return WORD_EOF;\n\n    if (correction)\n        *correction = 0;\n\n    if (!(wps->w.c [0].median [0] & ~1) && !wps->w.holding_zero && !wps->w.holding_one && !(wps->w.c [1].median [0] & ~1)) {\n        uint32_t mask;\n        int cbits;\n\n        if (wps->w.zeros_acc) {\n            if (--wps->w.zeros_acc) {\n                c->slow_level -= (c->slow_level + SLO) >> SLS;\n                return 0;\n            }\n        }\n        else {\n            for (cbits = 0; cbits < 33 && getbit (&wps->wvbits); ++cbits);\n\n            if (cbits == 33)\n                return WORD_EOF;\n\n            if (cbits < 2)\n                wps->w.zeros_acc = cbits;\n            else {\n                for (mask = 1, wps->w.zeros_acc = 0; --cbits; mask <<= 1)\n                    if (getbit (&wps->wvbits))\n                        wps->w.zeros_acc |= mask;\n\n                wps->w.zeros_acc |= mask;\n            }\n\n            if (wps->w.zeros_acc) {\n                c->slow_level -= (c->slow_level + SLO) >> SLS;\n                CLEAR (wps->w.c [0].median);\n                CLEAR (wps->w.c [1].median);\n                return 0;\n            }\n        }\n    }\n\n    if (wps->w.holding_zero)\n        ones_count = wps->w.holding_zero = 0;\n    else {\n#ifdef USE_CTZ_OPTIMIZATION\n        while (wps->wvbits.bc < LIMIT_ONES) {\n            if (++(wps->wvbits.ptr) == wps->wvbits.end)\n                wps->wvbits.wrap (&wps->wvbits);\n\n            wps->wvbits.sr |= *(wps->wvbits.ptr) << wps->wvbits.bc;\n            wps->wvbits.bc += sizeof (*(wps->wvbits.ptr)) * 8;\n        }\n\n#ifdef _WIN32\n        _BitScanForward (&ones_count, ~wps->wvbits.sr);\n#else\n        ones_count = __builtin_ctz (~wps->wvbits.sr);\n#endif\n\n        if (ones_count >= LIMIT_ONES) {\n            wps->wvbits.bc -= ones_count;\n            wps->wvbits.sr >>= ones_count;\n\n            for (; ones_count < (LIMIT_ONES + 1) && getbit (&wps->wvbits); ++ones_count);\n\n            if (ones_count == (LIMIT_ONES + 1))\n                return WORD_EOF;\n\n            if (ones_count == LIMIT_ONES) {\n                uint32_t mask;\n                int cbits;\n\n                for (cbits = 0; cbits < 33 && getbit (&wps->wvbits); ++cbits);\n\n                if (cbits == 33)\n                    return WORD_EOF;\n\n                if (cbits < 2)\n                    ones_count = cbits;\n                else {\n                    for (mask = 1, ones_count = 0; --cbits; mask <<= 1)\n                        if (getbit (&wps->wvbits))\n                            ones_count |= mask;\n\n                    ones_count |= mask;\n                }\n\n                ones_count += LIMIT_ONES;\n            }\n        }\n        else {\n            wps->wvbits.bc -= ones_count + 1;\n            wps->wvbits.sr >>= ones_count + 1;\n        }\n#elif defined (USE_NEXT8_OPTIMIZATION)\n        int next8;\n\n        if (wps->wvbits.bc < 8) {\n            if (++(wps->wvbits.ptr) == wps->wvbits.end)\n                wps->wvbits.wrap (&wps->wvbits);\n\n            next8 = (wps->wvbits.sr |= *(wps->wvbits.ptr) << wps->wvbits.bc) & 0xff;\n            wps->wvbits.bc += sizeof (*(wps->wvbits.ptr)) * 8;\n        }\n        else\n            next8 = wps->wvbits.sr & 0xff;\n\n        if (next8 == 0xff) {\n            wps->wvbits.bc -= 8;\n            wps->wvbits.sr >>= 8;\n\n            for (ones_count = 8; ones_count < (LIMIT_ONES + 1) && getbit (&wps->wvbits); ++ones_count);\n\n            if (ones_count == (LIMIT_ONES + 1))\n                return WORD_EOF;\n\n            if (ones_count == LIMIT_ONES) {\n                uint32_t mask;\n                int cbits;\n\n                for (cbits = 0; cbits < 33 && getbit (&wps->wvbits); ++cbits);\n\n                if (cbits == 33)\n                    return WORD_EOF;\n\n                if (cbits < 2)\n                    ones_count = cbits;\n                else {\n                    for (mask = 1, ones_count = 0; --cbits; mask <<= 1)\n                        if (getbit (&wps->wvbits))\n                            ones_count |= mask;\n\n                    ones_count |= mask;\n                }\n\n                ones_count += LIMIT_ONES;\n            }\n        }\n        else {\n            wps->wvbits.bc -= (ones_count = ones_count_table [next8]) + 1;\n            wps->wvbits.sr >>= ones_count + 1;\n        }\n#else\n        for (ones_count = 0; ones_count < (LIMIT_ONES + 1) && getbit (&wps->wvbits); ++ones_count);\n\n        if (ones_count >= LIMIT_ONES) {\n            uint32_t mask;\n            int cbits;\n\n            if (ones_count == (LIMIT_ONES + 1))\n                return WORD_EOF;\n\n            for (cbits = 0; cbits < 33 && getbit (&wps->wvbits); ++cbits);\n\n            if (cbits == 33)\n                return WORD_EOF;\n\n            if (cbits < 2)\n                ones_count = cbits;\n            else {\n                for (mask = 1, ones_count = 0; --cbits; mask <<= 1)\n                    if (getbit (&wps->wvbits))\n                        ones_count |= mask;\n\n                ones_count |= mask;\n            }\n\n            ones_count += LIMIT_ONES;\n        }\n#endif\n\n        if (wps->w.holding_one) {\n            wps->w.holding_one = ones_count & 1;\n            ones_count = (ones_count >> 1) + 1;\n        }\n        else {\n            wps->w.holding_one = ones_count & 1;\n            ones_count >>= 1;\n        }\n\n        wps->w.holding_zero = ~wps->w.holding_one & 1;\n    }\n\n    if ((wps->wphdr.flags & HYBRID_FLAG) && !chan)\n        update_error_limit (wps);\n\n    if (ones_count == 0) {\n        low = 0;\n        high = GET_MED (0) - 1;\n        DEC_MED0 ();\n    }\n    else {\n        low = GET_MED (0);\n        INC_MED0 ();\n\n        if (ones_count == 1) {\n            high = low + GET_MED (1) - 1;\n            DEC_MED1 ();\n        }\n        else {\n            low += GET_MED (1);\n            INC_MED1 ();\n\n            if (ones_count == 2) {\n                high = low + GET_MED (2) - 1;\n                DEC_MED2 ();\n            }\n            else {\n                low += (ones_count - 2) * GET_MED (2);\n                high = low + GET_MED (2) - 1;\n                INC_MED2 ();\n            }\n        }\n    }\n\n    low &= 0x7fffffff;\n    high &= 0x7fffffff;\n\n    if (low > high)         // make sure high and low make sense\n        high = low;\n\n    mid = (high + low + 1) >> 1;\n\n    if (!c->error_limit)\n        mid = read_code (&wps->wvbits, high - low) + low;\n    else while (high - low > c->error_limit) {\n        if (getbit (&wps->wvbits))\n            mid = (high + (low = mid) + 1) >> 1;\n        else\n            mid = ((high = mid - 1) + low + 1) >> 1;\n    }\n\n    sign = getbit (&wps->wvbits);\n\n    if (bs_is_open (&wps->wvcbits) && c->error_limit) {\n        value = read_code (&wps->wvcbits, high - low) + low;\n\n        if (correction)\n            *correction = sign ? (mid - value) : (value - mid);\n    }\n\n    if (wps->wphdr.flags & HYBRID_BITRATE) {\n        c->slow_level -= (c->slow_level + SLO) >> SLS;\n        c->slow_level += wp_log2 (mid);\n    }\n\n    return sign ? ~mid : mid;\n}\n\n// This is an optimized version of get_word() that is used for lossless only\n// (error_limit == 0). Also, rather than obtaining a single sample, it can be\n// used to obtain an entire buffer of either mono or stereo samples.\n\nint32_t get_words_lossless (WavpackStream *wps, int32_t *buffer, int32_t nsamples)\n{\n    struct entropy_data *c = wps->w.c;\n    uint32_t ones_count, low, high;\n    Bitstream *bs = &wps->wvbits;\n    int32_t csamples;\n#ifdef USE_NEXT8_OPTIMIZATION\n    int32_t next8;\n#endif\n\n    if (nsamples && !bs->ptr) {\n        memset (buffer, 0, (wps->wphdr.flags & MONO_DATA) ? nsamples * 4 : nsamples * 8);\n        return nsamples;\n    }\n\n    if (!(wps->wphdr.flags & MONO_DATA))\n        nsamples *= 2;\n\n    for (csamples = 0; csamples < nsamples; ++csamples) {\n        if (!(wps->wphdr.flags & MONO_DATA))\n            c = wps->w.c + (csamples & 1);\n\n        if (wps->w.holding_zero) {\n            wps->w.holding_zero = 0;\n            low = read_code (bs, GET_MED (0) - 1);\n            DEC_MED0 ();\n            buffer [csamples] = (getbit (bs)) ? ~low : low;\n\n            if (++csamples == nsamples)\n                break;\n\n            if (!(wps->wphdr.flags & MONO_DATA))\n                c = wps->w.c + (csamples & 1);\n        }\n\n        if (wps->w.c [0].median [0] < 2 && !wps->w.holding_one && wps->w.c [1].median [0] < 2) {\n            uint32_t mask;\n            int cbits;\n\n            if (wps->w.zeros_acc) {\n                if (--wps->w.zeros_acc) {\n                    buffer [csamples] = 0;\n                    continue;\n                }\n            }\n            else {\n                for (cbits = 0; cbits < 33 && getbit (bs); ++cbits);\n\n                if (cbits == 33)\n                    break;\n\n                if (cbits < 2)\n                    wps->w.zeros_acc = cbits;\n                else {\n                    for (mask = 1, wps->w.zeros_acc = 0; --cbits; mask <<= 1)\n                        if (getbit (bs))\n                            wps->w.zeros_acc |= mask;\n\n                    wps->w.zeros_acc |= mask;\n                }\n\n                if (wps->w.zeros_acc) {\n                    CLEAR (wps->w.c [0].median);\n                    CLEAR (wps->w.c [1].median);\n                    buffer [csamples] = 0;\n                    continue;\n                }\n            }\n        }\n\n#ifdef USE_CTZ_OPTIMIZATION\n        while (bs->bc < LIMIT_ONES) {\n            if (++(bs->ptr) == bs->end)\n                bs->wrap (bs);\n\n            bs->sr |= *(bs->ptr) << bs->bc;\n            bs->bc += sizeof (*(bs->ptr)) * 8;\n        }\n\n#ifdef _WIN32\n        _BitScanForward (&ones_count, ~wps->wvbits.sr);\n#else\n        ones_count = __builtin_ctz (~wps->wvbits.sr);\n#endif\n\n        if (ones_count >= LIMIT_ONES) {\n            bs->bc -= ones_count;\n            bs->sr >>= ones_count;\n\n            for (; ones_count < (LIMIT_ONES + 1) && getbit (bs); ++ones_count);\n\n            if (ones_count == (LIMIT_ONES + 1))\n                break;\n\n            if (ones_count == LIMIT_ONES) {\n                uint32_t mask;\n                int cbits;\n\n                for (cbits = 0; cbits < 33 && getbit (bs); ++cbits);\n\n                if (cbits == 33)\n                    break;\n\n                if (cbits < 2)\n                    ones_count = cbits;\n                else {\n                    for (mask = 1, ones_count = 0; --cbits; mask <<= 1)\n                        if (getbit (bs))\n                            ones_count |= mask;\n\n                    ones_count |= mask;\n                }\n\n                ones_count += LIMIT_ONES;\n            }\n        }\n        else {\n            bs->bc -= ones_count + 1;\n            bs->sr >>= ones_count + 1;\n        }\n#elif defined (USE_NEXT8_OPTIMIZATION)\n        if (bs->bc < 8) {\n            if (++(bs->ptr) == bs->end)\n                bs->wrap (bs);\n\n            next8 = (bs->sr |= *(bs->ptr) << bs->bc) & 0xff;\n            bs->bc += sizeof (*(bs->ptr)) * 8;\n        }\n        else\n            next8 = bs->sr & 0xff;\n\n        if (next8 == 0xff) {\n            bs->bc -= 8;\n            bs->sr >>= 8;\n\n            for (ones_count = 8; ones_count < (LIMIT_ONES + 1) && getbit (bs); ++ones_count);\n\n            if (ones_count == (LIMIT_ONES + 1))\n                break;\n\n            if (ones_count == LIMIT_ONES) {\n                uint32_t mask;\n                int cbits;\n\n                for (cbits = 0; cbits < 33 && getbit (bs); ++cbits);\n\n                if (cbits == 33)\n                    break;\n\n                if (cbits < 2)\n                    ones_count = cbits;\n                else {\n                    for (mask = 1, ones_count = 0; --cbits; mask <<= 1)\n                        if (getbit (bs))\n                            ones_count |= mask;\n\n                    ones_count |= mask;\n                }\n\n                ones_count += LIMIT_ONES;\n            }\n        }\n        else {\n            bs->bc -= (ones_count = ones_count_table [next8]) + 1;\n            bs->sr >>= ones_count + 1;\n        }\n#else\n        for (ones_count = 0; ones_count < (LIMIT_ONES + 1) && getbit (bs); ++ones_count);\n\n        if (ones_count >= LIMIT_ONES) {\n            uint32_t mask;\n            int cbits;\n\n            if (ones_count == (LIMIT_ONES + 1))\n                break;\n\n            for (cbits = 0; cbits < 33 && getbit (bs); ++cbits);\n\n            if (cbits == 33)\n                break;\n\n            if (cbits < 2)\n                ones_count = cbits;\n            else {\n                for (mask = 1, ones_count = 0; --cbits; mask <<= 1)\n                    if (getbit (bs))\n                        ones_count |= mask;\n\n                ones_count |= mask;\n            }\n\n            ones_count += LIMIT_ONES;\n        }\n#endif\n\n        low = wps->w.holding_one;\n        wps->w.holding_one = ones_count & 1;\n        wps->w.holding_zero = ~ones_count & 1;\n        ones_count = (ones_count >> 1) + low;\n\n        if (ones_count == 0) {\n            low = 0;\n            high = GET_MED (0) - 1;\n            DEC_MED0 ();\n        }\n        else {\n            low = GET_MED (0);\n            INC_MED0 ();\n\n            if (ones_count == 1) {\n                high = low + GET_MED (1) - 1;\n                DEC_MED1 ();\n            }\n            else {\n                low += GET_MED (1);\n                INC_MED1 ();\n\n                if (ones_count == 2) {\n                    high = low + GET_MED (2) - 1;\n                    DEC_MED2 ();\n                }\n                else {\n                    low += (ones_count - 2) * GET_MED (2);\n                    high = low + GET_MED (2) - 1;\n                    INC_MED2 ();\n                }\n            }\n        }\n\n        low += read_code (bs, high - low);\n        buffer [csamples] = (getbit (bs)) ? ~low : low;\n    }\n\n    return (wps->wphdr.flags & MONO_DATA) ? csamples : (csamples / 2);\n}\n\n// Read a single unsigned value from the specified bitstream with a value\n// from 0 to maxcode. If there are exactly a power of two number of possible\n// codes then this will read a fixed number of bits; otherwise it reads the\n// minimum number of bits and then determines whether another bit is needed\n// to define the code.\n\nstatic uint32_t __inline read_code (Bitstream *bs, uint32_t maxcode)\n{\n    unsigned long local_sr;\n    uint32_t extras, code;\n    int bitcount;\n\n    if (maxcode < 2)\n        return maxcode ? getbit (bs) : 0;\n\n    bitcount = count_bits (maxcode);\n#ifdef USE_BITMASK_TABLES\n    extras = bitset [bitcount] - maxcode - 1;\n#else\n    extras = (1 << bitcount) - maxcode - 1;\n#endif\n\n    local_sr = bs->sr;\n\n    while (bs->bc < bitcount) {\n        if (++(bs->ptr) == bs->end)\n            bs->wrap (bs);\n\n        local_sr |= (long)*(bs->ptr) << bs->bc;\n        bs->bc += sizeof (*(bs->ptr)) * 8;\n    }\n\n#ifdef USE_BITMASK_TABLES\n    if ((code = local_sr & bitmask [bitcount - 1]) >= extras)\n#else\n    if ((code = local_sr & ((1 << (bitcount - 1)) - 1)) >= extras)\n#endif\n        code = (code << 1) - extras + ((local_sr >> (bitcount - 1)) & 1);\n    else\n        bitcount--;\n\n    if (sizeof (local_sr) < 8 && bs->bc > sizeof (local_sr) * 8) {\n        bs->bc -= bitcount;\n        bs->sr = *(bs->ptr) >> (sizeof (*(bs->ptr)) * 8 - bs->bc);\n    }\n    else {\n        bs->bc -= bitcount;\n        bs->sr = local_sr >> bitcount;\n    }\n\n    return code;\n}\n"], "filenames": ["src/open_utils.c", "src/read_words.c"], "buggy_code_start_loc": [563, 290], "buggy_code_end_loc": [595, 290], "fixing_code_start_loc": [563, 291], "fixing_code_end_loc": [600, 295], "type": "CWE-125", "message": "The WriteCaffHeader function in cli/caff.c in Wavpack before 5.1.0 allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted WV file.", "other": {"cve": {"id": "CVE-2016-10170", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-14T14:59:00.213", "lastModified": "2017-03-14T16:06:52.567", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The WriteCaffHeader function in cli/caff.c in Wavpack before 5.1.0 allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted WV file."}, {"lang": "es", "value": "La funci\u00f3n WriteCaffHeader en cli/caff.c en Wavpack en versiones anteriores a 5.1.0 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (lectura fuera de l\u00edmites) a trav\u00e9s de un archivo WV manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:wavpack_project:wavpack:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.0.0", "matchCriteriaId": "BEA8FE0F-A350-495F-9038-BC6BDB094612"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2017/01/28/9", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/95883", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/dbry/WavPack/commit/4bc05fc490b66ef2d45b1de26abf1455b486b0dc", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://sourceforge.net/p/wavpack/mailman/message/35561921/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/dbry/WavPack/commit/4bc05fc490b66ef2d45b1de26abf1455b486b0dc"}}