{"buggy_code": ["wheel>=0.38.1,<=0.40.0\nappdirs>=1.4.3\nattr==0.3.1\nattrs>=19.2.0\npyyaml>=5.3.1\nazure-storage-blob>=12.6.0\n\nboto~=2.49.0\nboto3~=1.16.28\nbotocore~=1.19.28\nbleach~=5.0.0\n\ngoogle-api-core==2.11.0\ngoogle-auth==2.14.1\ngoogle-cloud-appengine-logging==1.1.0\ngoogle-cloud-audit-log==0.2.0\ngoogle-cloud-core==2.3.2\ngoogle-cloud-storage~=2.5.0\ngoogle-cloud-logging~=2.7.0\ngoogle-resumable-media==2.3.3\ngoogleapis-common-protos==1.56.4\ngrpc-google-iam-v1==0.12.4\n\nDjango==3.2.20\ndjango-storages==1.12.3\ndjango_annoying==0.10.6\ndjango_debug_toolbar==3.2.1\ndjango_filter==2.4.0\ndjango_model_utils==4.1.1\ndjango_rq==2.5.1\ndjango-cors-headers==3.6.0\ndjango-extensions==3.1.0\ndjango-rest-swagger==2.2.0\ndjango-user-agents==0.4.0\ndjango-ranged-fileresponse>=0.1.2\ndrf_dynamic_fields==0.3.0\ndjangorestframework==3.13.1\ndrf-flex-fields==0.9.5\ndrf_yasg==1.20.0\ndrf-generators==0.3.0\nhtmlmin==0.1.12\njsonschema==3.2.0\nlockfile>=0.12.0\nlxml>=4.2.5\ndefusedxml>=0.7.1\nnumpy==1.24.3\nordered_set==4.0.2\npandas>=0.24.0\nprotobuf>=3.15.5\npsycopg2-binary==2.9.6\npydantic>=1.7.3,<=1.11.0\npython_dateutil==2.8.1\npytz ~=2022.1\nrequests==2.31.0\nurllib3==1.26.16\nrq==1.10.1\nrules==2.2\nujson>=3.0.0\nxmljson==0.2.0\ncolorama>=0.4.4\nboxing>=0.1.4\nredis~=3.5\nsentry-sdk>=1.1.0\nlaunchdarkly-server-sdk==7.5.0\npython-json-logger==2.0.4\n\nlabel-studio-converter==0.0.54rc0\n", "\"\"\"This file and its contents are licensed under the Apache License 2.0. Please see the included NOTICE for copyright information and LICENSE for a copy of the license.\n\"\"\"\n\"\"\"\nDjango Base settings for Label Studio.\n\nFor more information on this file, see\nhttps://docs.djangoproject.com/en/3.1/topics/settings/\n\nFor the full list of settings and their values, see\nhttps://docs.djangoproject.com/en/3.1/ref/settings/\n\"\"\"\nimport os\nimport re\nimport logging\nimport json\n\nfrom datetime import timedelta\nfrom label_studio.core.utils.params import get_bool_env, get_env\n\nformatter = 'standard'\nJSON_LOG = get_bool_env('JSON_LOG', False)\nif JSON_LOG:\n    formatter = 'json'\n\nLOGGING = {\n    'version': 1,\n    'disable_existing_loggers': False,\n    'formatters': {\n        'json': {\n            '()': 'label_studio.core.utils.formatter.CustomJsonFormatter',\n            'format': '[%(asctime)s] [%(name)s::%(funcName)s::%(lineno)d] [%(levelname)s] [%(user_id)s] %(message)s',\n            'datefmt': '%d/%b/%Y:%H:%M:%S %z',\n        },\n        'standard': {\n            'format': '[%(asctime)s] [%(name)s::%(funcName)s::%(lineno)d] [%(levelname)s] %(message)s',\n        },\n    },\n    'handlers': {\n        'console': {\n            'class': 'logging.StreamHandler',\n            'formatter': formatter,\n        },\n    },\n    'root': {\n        'handlers': ['console'],\n        'level': os.environ.get('LOG_LEVEL', 'DEBUG'),\n    },\n    'loggers': {\n        'pykwalify': {'level': 'ERROR', 'propagate': False},\n        'tavern': {'level': 'ERROR', 'propagate': False},\n        'asyncio': {'level': 'WARNING'},\n        'rules': {'level': 'WARNING'},\n        'django': {\n            'handlers': ['console'],\n            # 'propagate': True,\n        },\n        'django_auth_ldap': {'level': os.environ.get('LOG_LEVEL', 'DEBUG')},\n        \"rq.worker\": {\n            \"handlers\": [\"console\"],\n            \"level\": os.environ.get('LOG_LEVEL', 'INFO'),\n        },\n        'ddtrace': {\n            'handlers': ['console'],\n            'level': 'WARNING',\n        },\n        'ldclient.util': {\n            'handlers': ['console'],\n            'level': 'ERROR',\n        },\n    },\n}\n\n# for printing messages before main logging config applied\nif not logging.getLogger().hasHandlers():\n    logging.basicConfig(level=logging.DEBUG, format='%(message)s')\n\nfrom label_studio.core.utils.io import get_data_dir\nfrom label_studio.core.utils.params import get_bool_env, get_env, get_env_list_int\n\nlogger = logging.getLogger(__name__)\nSILENCED_SYSTEM_CHECKS = []\n\n# Hostname is used for proper path generation to the resources, pages, etc\nHOSTNAME = get_env('HOST', '')\nif HOSTNAME:\n    if not HOSTNAME.startswith('http://') and not HOSTNAME.startswith('https://'):\n        logger.info(\n            \"! HOST variable found in environment, but it must start with http:// or https://, ignore it: %s\", HOSTNAME\n        )\n        HOSTNAME = ''\n    else:\n        logger.info(\"=> Hostname correctly is set to: %s\", HOSTNAME)\n        if HOSTNAME.endswith('/'):\n            HOSTNAME = HOSTNAME[0:-1]\n\n        # for django url resolver\n        if HOSTNAME:\n            # http[s]://domain.com:8080/script_name => /script_name\n            pattern = re.compile(r'^http[s]?:\\/\\/([^:\\/\\s]+(:\\d*)?)(.*)?')\n            match = pattern.match(HOSTNAME)\n            FORCE_SCRIPT_NAME = match.group(3)\n            if FORCE_SCRIPT_NAME:\n                logger.info(\"=> Django URL prefix is set to: %s\", FORCE_SCRIPT_NAME)\n\nINTERNAL_PORT = '8080'\n\n# SECURITY WARNING: keep the secret key used in production secret!\nSECRET_KEY = '$(fefwefwef13;LFK{P!)@#*!)kdsjfWF2l+i5e3t(8a1n'\n\n# SECURITY WARNING: don't run with debug turned on in production!\nDEBUG = get_bool_env('DEBUG', True)\nDEBUG_MODAL_EXCEPTIONS = get_bool_env('DEBUG_MODAL_EXCEPTIONS', True)\n\n# Build paths inside the project like this: os.path.join(BASE_DIR, ...)\nBASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n\n# Base path for media root and other uploaded files\nBASE_DATA_DIR = get_env('BASE_DATA_DIR', get_data_dir())\nos.makedirs(BASE_DATA_DIR, exist_ok=True)\nlogger.info('=> Database and media directory: %s', BASE_DATA_DIR)\n\n# Databases\n# https://docs.djangoproject.com/en/2.1/ref/settings/#databases\nDJANGO_DB_MYSQL = 'mysql'\nDJANGO_DB_SQLITE = 'sqlite'\nDJANGO_DB_POSTGRESQL = 'postgresql'\nDJANGO_DB = 'default'\nDATABASE_NAME_DEFAULT = os.path.join(BASE_DATA_DIR, 'label_studio.sqlite3')\nDATABASE_NAME = get_env('DATABASE_NAME', DATABASE_NAME_DEFAULT)\nDATABASES_ALL = {\n    DJANGO_DB_POSTGRESQL: {\n        'ENGINE': 'django.db.backends.postgresql',\n        'USER': get_env('POSTGRE_USER', 'postgres'),\n        'PASSWORD': get_env('POSTGRE_PASSWORD', 'postgres'),\n        'NAME': get_env('POSTGRE_NAME', 'postgres'),\n        'HOST': get_env('POSTGRE_HOST', 'localhost'),\n        'PORT': int(get_env('POSTGRE_PORT', '5432')),\n    },\n    DJANGO_DB_MYSQL: {\n        'ENGINE': 'django.db.backends.mysql',\n        'USER': get_env('MYSQL_USER', 'root'),\n        'PASSWORD': get_env('MYSQL_PASSWORD', ''),\n        'NAME': get_env('MYSQL_NAME', 'labelstudio'),\n        'HOST': get_env('MYSQL_HOST', 'localhost'),\n        'PORT': int(get_env('MYSQL_PORT', '3306')),\n    },\n    DJANGO_DB_SQLITE: {\n        'ENGINE': 'django.db.backends.sqlite3',\n        'NAME': DATABASE_NAME,\n        'OPTIONS': {\n            # 'timeout': 20,\n        },\n    },\n}\nDATABASES_ALL['default'] = DATABASES_ALL[DJANGO_DB_POSTGRESQL]\nDATABASES = {'default': DATABASES_ALL.get(get_env('DJANGO_DB', 'default'))}\n\nDEFAULT_AUTO_FIELD = 'django.db.models.AutoField'\n\nif get_bool_env('GOOGLE_LOGGING_ENABLED', False):\n    logging.info('Google Cloud Logging handler is enabled.')\n    try:\n        import google.cloud.logging\n        from google.auth.exceptions import GoogleAuthError\n\n        client = google.cloud.logging.Client()\n        client.setup_logging()\n\n        LOGGING['handlers']['google_cloud_logging'] = {\n            'level': get_env('LOG_LEVEL', 'WARNING'),\n            'class': 'google.cloud.logging.handlers.CloudLoggingHandler',\n            'client': client,\n        }\n        LOGGING['root']['handlers'].append('google_cloud_logging')\n    except GoogleAuthError as e:\n        logger.exception('Google Cloud Logging handler could not be setup.')\n\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    'django.contrib.humanize',\n    'drf_yasg',\n    'corsheaders',\n    'django_extensions',\n    'django_rq',\n    'django_filters',\n    'rules',\n    'annoying',\n    'rest_framework',\n    'rest_framework_swagger',\n    'rest_framework.authtoken',\n    'drf_generators',\n    'core',\n    'users',\n    'organizations',\n    'data_import',\n    'data_export',\n    'projects',\n    'tasks',\n    'data_manager',\n    'io_storages',\n    'ml',\n    'webhooks',\n    'labels_manager',\n]\n\nMIDDLEWARE = [\n    'corsheaders.middleware.CorsMiddleware',\n    'django.middleware.security.SecurityMiddleware',\n    'django.contrib.sessions.middleware.SessionMiddleware',\n    'django.middleware.locale.LocaleMiddleware',\n    'core.middleware.DisableCSRF',\n    'django.middleware.csrf.CsrfViewMiddleware',\n    'django.contrib.auth.middleware.AuthenticationMiddleware',\n    'django.contrib.messages.middleware.MessageMiddleware',\n    'core.middleware.CommonMiddlewareAppendSlashWithoutRedirect',  # instead of 'CommonMiddleware'\n    'core.middleware.CommonMiddleware',\n    'django_user_agents.middleware.UserAgentMiddleware',\n    'core.middleware.SetSessionUIDMiddleware',\n    'core.middleware.ContextLogMiddleware',\n    'core.middleware.DatabaseIsLockedRetryMiddleware',\n    'core.current_request.ThreadLocalMiddleware',\n]\n\nREST_FRAMEWORK = {\n    'DEFAULT_FILTER_BACKENDS': ['django_filters.rest_framework.DjangoFilterBackend'],\n    'DEFAULT_AUTHENTICATION_CLASSES': (\n        'rest_framework.authentication.TokenAuthentication',\n        'rest_framework.authentication.SessionAuthentication',\n    ),\n    'DEFAULT_PERMISSION_CLASSES': [\n        'core.api_permissions.HasObjectPermission',\n        'rest_framework.permissions.IsAuthenticated',\n    ],\n    'EXCEPTION_HANDLER': 'core.utils.common.custom_exception_handler',\n    'DEFAULT_RENDERER_CLASSES': ('rest_framework.renderers.JSONRenderer',),\n    'DEFAULT_VERSIONING_CLASS': 'rest_framework.versioning.NamespaceVersioning',\n    'PAGE_SIZE': 100,\n    # 'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination'\n}\nSILENCED_SYSTEM_CHECKS += [\"rest_framework.W001\"]\n\n# CORS & Host settings\nINTERNAL_IPS = [  # django debug toolbar for django==2.2 requirement\n    '127.0.0.1',\n    'localhost',\n]\nCORS_ORIGIN_ALLOW_ALL = True\nCORS_ALLOW_METHODS = [\n    'DELETE',\n    'GET',\n    'OPTIONS',\n    'PATCH',\n    'POST',\n    'PUT',\n]\nALLOWED_HOSTS = ['*']\n\n# Auth modules\nAUTH_USER_MODEL = 'users.User'\nAUTHENTICATION_BACKENDS = ['rules.permissions.ObjectPermissionBackend', 'django.contrib.auth.backends.ModelBackend', ]\nUSE_USERNAME_FOR_LOGIN = False\n\nDISABLE_SIGNUP_WITHOUT_LINK = get_bool_env('DISABLE_SIGNUP_WITHOUT_LINK', False)\n\n# Password validation:\n# https://docs.djangoproject.com/en/2.1/ref/settings/#auth-password-validators\nAUTH_PASSWORD_VALIDATORS = [\n    {'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator'},\n    {'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator'},\n    {'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator'},\n    {'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator'},\n]\n\n# Django templates\nTEMPLATES_DIR = os.path.join(os.path.dirname(BASE_DIR), 'templates')  # ../../from_this = 'web' dir\nTEMPLATES = [\n    {\n        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n        'DIRS': [TEMPLATES_DIR],\n        'APP_DIRS': True,\n        'OPTIONS': {\n            'context_processors': [\n                'django.template.context_processors.debug',\n                'django.template.context_processors.request',\n                'django.contrib.auth.context_processors.auth',\n                'django.contrib.messages.context_processors.messages',\n                'core.context_processors.settings',\n            ],\n            'builtins': ['django.templatetags.i18n'],\n        },\n    }\n]\n\n# RQ\nRQ_QUEUES = {\n    'critical': {\n        'HOST': 'localhost',\n        'PORT': 6379,\n        'DB': 0,\n        'DEFAULT_TIMEOUT': 180,\n    },\n    'high': {\n        'HOST': 'localhost',\n        'PORT': 6379,\n        'DB': 0,\n        'DEFAULT_TIMEOUT': 180,\n    },\n    'default': {\n        'HOST': 'localhost',\n        'PORT': 6379,\n        'DB': 0,\n        'DEFAULT_TIMEOUT': 180,\n    },\n    'low': {\n        'HOST': 'localhost',\n        'PORT': 6379,\n        'DB': 0,\n        'DEFAULT_TIMEOUT': 180,\n    },\n}\n\n# Swagger: automatic API documentation\nSWAGGER_SETTINGS = {\n    'SECURITY_DEFINITIONS': {\n        'Token': {\n            'type': 'apiKey',\n            'name': 'Authorization',\n            'in': 'header',\n            'description':\n                'The token (or API key) must be passed as a request header. '\n                'You can find your user token on the User Account page in Label Studio. Example: '\n                '<br><pre><code class=\"language-bash\">'\n                'curl https://label-studio-host/api/projects -H \"Authorization: Token [your-token]\"'\n                '</code></pre>'\n        }\n    },\n    'APIS_SORTER': 'alpha',\n    'SUPPORTED_SUBMIT_METHODS': ['get', 'post', 'put', 'delete', 'patch'],\n    'OPERATIONS_SORTER': 'alpha',\n\n}\n\nSENTRY_DSN = get_env('SENTRY_DSN', None)\nSENTRY_RATE = float(get_env('SENTRY_RATE', 0.25))\nSENTRY_ENVIRONMENT = get_env('SENTRY_ENVIRONMENT', 'stage.opensource')\nSENTRY_REDIS_ENABLED = False\nFRONTEND_SENTRY_DSN = get_env('FRONTEND_SENTRY_DSN', None)\nFRONTEND_SENTRY_RATE = get_env('FRONTEND_SENTRY_RATE', 0.1)\nFRONTEND_SENTRY_ENVIRONMENT = get_env('FRONTEND_SENTRY_ENVIRONMENT', 'stage.opensource')\n\nROOT_URLCONF = 'core.urls'\nWSGI_APPLICATION = 'core.wsgi.application'\nGRAPHIQL = True\n\n# Internationalization\n# https://docs.djangoproject.com/en/2.1/topics/i18n/\nLANGUAGE_CODE = 'en-us'\nTIME_ZONE = 'UTC'\nUSE_I18N = False\nUSE_L10N = True\nUSE_TZ = True\n\n# Static files (CSS, JavaScript, Images)\n# https://docs.djangoproject.com/en/2.1/howto/static-files/\nSTATIC_URL = '/static/'\n# if FORCE_SCRIPT_NAME:\n#    STATIC_URL = FORCE_SCRIPT_NAME + STATIC_URL\nlogger.info(f'=> Static URL is set to: {STATIC_URL}')\n\nSTATIC_ROOT = os.path.join(BASE_DIR, 'static_build')\nSTATICFILES_DIRS = [os.path.join(BASE_DIR, 'static')]\nSTATICFILES_FINDERS = (\n    'django.contrib.staticfiles.finders.FileSystemFinder',\n    'django.contrib.staticfiles.finders.AppDirectoriesFinder',\n)\nSTATICFILES_STORAGE = 'core.storage.SkipMissedManifestStaticFilesStorage'\n\n# Sessions and CSRF\nSESSION_COOKIE_SECURE = bool(int(get_env('SESSION_COOKIE_SECURE', False)))\nSESSION_COOKIE_SAMESITE = get_env('SESSION_COOKIE_SAMESITE', 'Lax')\n\nCSRF_COOKIE_SECURE = bool(int(get_env('CSRF_COOKIE_SECURE', SESSION_COOKIE_SECURE)))\nCSRF_COOKIE_HTTPONLY = bool(int(get_env('CSRF_COOKIE_HTTPONLY', SESSION_COOKIE_SECURE)))\nCSRF_COOKIE_SAMESITE = get_env('CSRF_COOKIE_SAMESITE', 'Lax')\n\n# Inactivity user sessions\nINACTIVITY_SESSION_TIMEOUT_ENABLED = bool(int(get_env('INACTIVITY_SESSION_TIMEOUT_ENABLED', True)))\n# The most time a login will last, regardless of activity\nMAX_SESSION_AGE = int(get_env('MAX_SESSION_AGE', timedelta(days=14).total_seconds()))\n# The most time that can elapse between activity with the server before the user is logged out\nMAX_TIME_BETWEEN_ACTIVITY = int(get_env('MAX_TIME_BETWEEN_ACTIVITY', timedelta(days=5).total_seconds()))\n\nSSRF_PROTECTION_ENABLED = get_bool_env('SSRF_PROTECTION_ENABLED', False)\n\n# user media files\nMEDIA_ROOT = os.path.join(BASE_DATA_DIR, 'media')\nos.makedirs(MEDIA_ROOT, exist_ok=True)\nMEDIA_URL = '/data/'\nUPLOAD_DIR = 'upload'\nAVATAR_PATH = 'avatars'\n\nSUPPORTED_EXTENSIONS = set(\n    [\n        '.bmp',\n        '.csv',\n        '.flac',\n        '.gif',\n        '.htm',\n        '.html',\n        '.jpg',\n        '.jpeg',\n        '.json',\n        '.m4a',\n        '.mp3',\n        '.ogg',\n        '.png',\n        '.svg',\n        '.tsv',\n        '.txt',\n        '.wav',\n        '.xml',\n        '.mp4',\n        '.webm',\n        '.webp',\n    ]\n)\n\n# directory for files created during unit tests\nTEST_DATA_ROOT = os.path.join(BASE_DATA_DIR, 'test_data')\nos.makedirs(TEST_DATA_ROOT, exist_ok=True)\n\n# project exports\nEXPORT_DIR = os.path.join(BASE_DATA_DIR, 'export')\nEXPORT_URL_ROOT = '/export/'\nEXPORT_MIXIN = 'data_export.mixins.ExportMixin'\n# old export dir\nos.makedirs(EXPORT_DIR, exist_ok=True)\n# dir for delayed export\nDELAYED_EXPORT_DIR = 'export'\nos.makedirs(os.path.join(BASE_DATA_DIR, MEDIA_ROOT, DELAYED_EXPORT_DIR), exist_ok=True)\n\n# file / task size limits\nDATA_UPLOAD_MAX_MEMORY_SIZE = int(get_env('DATA_UPLOAD_MAX_MEMORY_SIZE', 250 * 1024 * 1024))\nTASKS_MAX_NUMBER = 1000000\nTASKS_MAX_FILE_SIZE = DATA_UPLOAD_MAX_MEMORY_SIZE\n\nTASK_LOCK_TTL = int(get_env('TASK_LOCK_TTL', default=86400))\n\nLABEL_STREAM_HISTORY_LIMIT = int(get_env('LABEL_STREAM_HISTORY_LIMIT', default=100))\n\nRANDOM_NEXT_TASK_SAMPLE_SIZE = int(get_env('RANDOM_NEXT_TASK_SAMPLE_SIZE', 50))\n\nTASK_API_PAGE_SIZE_MAX = int(get_env('TASK_API_PAGE_SIZE_MAX', 0)) or None\n\n# Email backend\nFROM_EMAIL = get_env('FROM_EMAIL', 'Label Studio <hello@labelstud.io>')\nEMAIL_BACKEND = get_env('EMAIL_BACKEND', 'django.core.mail.backends.dummy.EmailBackend')\n\nENABLE_LOCAL_FILES_STORAGE = get_bool_env('ENABLE_LOCAL_FILES_STORAGE', default=True)\nLOCAL_FILES_SERVING_ENABLED = get_bool_env('LOCAL_FILES_SERVING_ENABLED', default=False)\nLOCAL_FILES_DOCUMENT_ROOT = get_env('LOCAL_FILES_DOCUMENT_ROOT', default=os.path.abspath(os.sep))\n\nSYNC_ON_TARGET_STORAGE_CREATION = get_bool_env('SYNC_ON_TARGET_STORAGE_CREATION', default=True)\n\nALLOW_IMPORT_TASKS_WITH_UNKNOWN_EMAILS = get_bool_env('ALLOW_IMPORT_TASKS_WITH_UNKNOWN_EMAILS', default=False)\n\n\"\"\" React Libraries: do not forget to change this dir in /etc/nginx/nginx.conf \"\"\"\n# EDITOR = label-studio-frontend repository\nEDITOR_ROOT = os.path.join(BASE_DIR, '../frontend/dist/lsf')\n# DM = data manager (included into FRONTEND due npm building, we need only version.json file from there)\nDM_ROOT = os.path.join(BASE_DIR, '../frontend/dist/dm')\n# FRONTEND = GUI for django backend\nREACT_APP_ROOT = os.path.join(BASE_DIR, '../frontend/dist/react-app')\n\n# per project settings\nBATCH_SIZE = 1000\nPROJECT_TITLE_MIN_LEN = 3\nPROJECT_TITLE_MAX_LEN = 50\nLOGIN_REDIRECT_URL = '/'\nLOGIN_URL = '/'\nMIN_GROUND_TRUTH = 10\nDATA_UNDEFINED_NAME = '$undefined$'\nLICENSE = {}\nVERSIONS = {}\nVERSION_EDITION = 'Community'\nLATEST_VERSION_CHECK = True\nVERSIONS_CHECK_TIME = 0\nALLOW_ORGANIZATION_WEBHOOKS = get_bool_env('ALLOW_ORGANIZATION_WEBHOOKS', False)\nCONVERTER_DOWNLOAD_RESOURCES = get_bool_env('CONVERTER_DOWNLOAD_RESOURCES', True)\nEXPERIMENTAL_FEATURES = get_bool_env('EXPERIMENTAL_FEATURES', False)\nUSE_ENFORCE_CSRF_CHECKS = get_bool_env('USE_ENFORCE_CSRF_CHECKS', True)  # False is for tests\nCLOUD_FILE_STORAGE_ENABLED = False\n\nIO_STORAGES_IMPORT_LINK_NAMES = [\n    'io_storages_s3importstoragelink',\n    'io_storages_gcsimportstoragelink',\n    'io_storages_azureblobimportstoragelink',\n    'io_storages_localfilesimportstoragelink',\n    'io_storages_redisimportstoragelink',\n]\n\nCREATE_ORGANIZATION = 'organizations.functions.create_organization'\nSAVE_USER = 'users.functions.save_user'\nPOST_PROCESS_REIMPORT = 'core.utils.common.empty'\nUSER_SERIALIZER = 'users.serializers.BaseUserSerializer'\nUSER_SERIALIZER_UPDATE = 'users.serializers.BaseUserSerializerUpdate'\nTASK_SERIALIZER = 'tasks.serializers.BaseTaskSerializer'\nEXPORT_DATA_SERIALIZER = 'data_export.serializers.BaseExportDataSerializer'\nDATA_MANAGER_GET_ALL_COLUMNS = 'data_manager.functions.get_all_columns'\nDATA_MANAGER_ANNOTATIONS_MAP = {}\nDATA_MANAGER_ACTIONS = {}\nDATA_MANAGER_CUSTOM_FILTER_EXPRESSIONS = 'data_manager.functions.custom_filter_expressions'\nDATA_MANAGER_PREPROCESS_FILTER = 'data_manager.functions.preprocess_filter'\nUSER_LOGIN_FORM = 'users.forms.LoginForm'\nPROJECT_MIXIN = 'projects.mixins.ProjectMixin'\nTASK_MIXIN = 'tasks.mixins.TaskMixin'\nANNOTATION_MIXIN = 'tasks.mixins.AnnotationMixin'\nORGANIZATION_MIXIN = 'organizations.mixins.OrganizationMixin'\nUSER_MIXIN = 'users.mixins.UserMixin'\nRECALCULATE_ALL_STATS = None\nGET_STORAGE_LIST = 'io_storages.functions.get_storage_list'\nSTORAGE_ANNOTATION_SERIALIZER = 'io_storages.serializers.StorageAnnotationSerializer'\nTASK_SERIALIZER_BULK = 'tasks.serializers.BaseTaskSerializerBulk'\nPREPROCESS_FIELD_NAME = 'data_manager.functions.preprocess_field_name'\nINTERACTIVE_DATA_SERIALIZER = 'data_export.serializers.BaseExportDataSerializerForInteractive'\nDELETE_TASKS_ANNOTATIONS_POSTPROCESS = None\n\n\ndef project_delete(project):\n    project.delete()\n\n\ndef user_auth(user_model, email, password):\n    return None\n\n\ndef collect_versions_dummy(**kwargs):\n    return {}\n\n\nPROJECT_DELETE = project_delete\nUSER_AUTH = user_auth\nCOLLECT_VERSIONS = collect_versions_dummy\n\nWEBHOOK_TIMEOUT = float(get_env('WEBHOOK_TIMEOUT', 1.0))\nWEBHOOK_SERIALIZERS = {\n    'project': 'webhooks.serializers_for_hooks.ProjectWebhookSerializer',\n    'task': 'webhooks.serializers_for_hooks.TaskWebhookSerializer',\n    'annotation': 'webhooks.serializers_for_hooks.AnnotationWebhookSerializer',\n    'label': 'labels_manager.serializers.LabelSerializer',\n    'label_link': 'labels_manager.serializers.LabelLinkSerializer',\n}\n\nEDITOR_KEYMAP = json.dumps(get_env(\"EDITOR_KEYMAP\"))\n\n# fix a problem with Windows mimetypes for JS and PNG\nimport mimetypes\n\nmimetypes.add_type(\"application/javascript\", \".js\", True)\nmimetypes.add_type(\"image/png\", \".png\", True)\n\n# fields name was used in DM api before\nREST_FLEX_FIELDS = {\"FIELDS_PARAM\": \"include\"}\n\nINTERPOLATE_KEY_FRAMES = get_env('INTERPOLATE_KEY_FRAMES', False)\n\n# Feature Flags\nFEATURE_FLAGS_API_KEY = get_env('FEATURE_FLAGS_API_KEY', default='any key')\n\n# we may set feature flags from file\nFEATURE_FLAGS_FROM_FILE = get_bool_env('FEATURE_FLAGS_FROM_FILE', False)\nFEATURE_FLAGS_FILE = get_env('FEATURE_FLAGS_FILE', 'feature_flags.json')\n# or if file is not set, default is using offline mode\nFEATURE_FLAGS_OFFLINE = get_bool_env('FEATURE_FLAGS_OFFLINE', True)\n# default value for feature flags (if not overridden by environment or client)\nFEATURE_FLAGS_DEFAULT_VALUE = False\n\n# Whether to send analytics telemetry data\nCOLLECT_ANALYTICS = get_bool_env('collect_analytics', True)\n\n# Strip harmful content from SVG files by default\nSVG_SECURITY_CLEANUP = get_bool_env('SVG_SECURITY_CLEANUP', False)\n\nML_BLOCK_LOCAL_IP = get_bool_env('ML_BLOCK_LOCAL_IP', False)\n\nRQ_LONG_JOB_TIMEOUT = int(get_env('RQ_LONG_JOB_TIMEOUT', 36000))\n\nAPP_WEBSERVER = get_env('APP_WEBSERVER', 'django')\n\nBATCH_JOB_RETRY_TIMEOUT = int(get_env('BATCH_JOB_RETRY_TIMEOUT', 60))\n\nFUTURE_SAVE_TASK_TO_STORAGE = get_bool_env('FUTURE_SAVE_TASK_TO_STORAGE', default=False)\nFUTURE_SAVE_TASK_TO_STORAGE_JSON_EXT = get_bool_env('FUTURE_SAVE_TASK_TO_STORAGE_JSON_EXT', default=True)\nSTORAGE_IN_PROGRESS_TIMER = get_env('STORAGE_IN_PROGRESS_TIMER', 5.0)\n\nUSE_NGINX_FOR_EXPORT_DOWNLOADS = get_bool_env('USE_NGINX_FOR_EXPORT_DOWNLOADS', False)\n\nif get_env('MINIO_STORAGE_ENDPOINT') and not get_bool_env('MINIO_SKIP', False):\n    CLOUD_FILE_STORAGE_ENABLED = True\n    DEFAULT_FILE_STORAGE = 'storages.backends.s3boto3.S3Boto3Storage'\n    AWS_STORAGE_BUCKET_NAME = get_env('MINIO_STORAGE_BUCKET_NAME')\n    AWS_ACCESS_KEY_ID = get_env('MINIO_STORAGE_ACCESS_KEY')\n    AWS_SECRET_ACCESS_KEY = get_env('MINIO_STORAGE_SECRET_KEY')\n    AWS_S3_ENDPOINT_URL = get_env('MINIO_STORAGE_ENDPOINT')\n    AWS_QUERYSTRING_AUTH = False\n    # make domain for FileUpload.file\n    AWS_S3_SECURE_URLS = False\n    AWS_S3_URL_PROTOCOL = 'http:' if HOSTNAME.startswith('http://') else 'https:'\n    AWS_S3_CUSTOM_DOMAIN = HOSTNAME.replace('http://', '').replace('https://', '') + '/data'\n\nif get_env('STORAGE_TYPE') == \"s3\":\n    CLOUD_FILE_STORAGE_ENABLED = True\n    DEFAULT_FILE_STORAGE = 'core.storage.CustomS3Boto3Storage'\n    if get_env('STORAGE_AWS_ACCESS_KEY_ID'):\n        AWS_ACCESS_KEY_ID = get_env('STORAGE_AWS_ACCESS_KEY_ID')\n    if get_env('STORAGE_AWS_SECRET_ACCESS_KEY'):\n        AWS_SECRET_ACCESS_KEY = get_env('STORAGE_AWS_SECRET_ACCESS_KEY')\n    AWS_STORAGE_BUCKET_NAME = get_env('STORAGE_AWS_BUCKET_NAME')\n    AWS_S3_REGION_NAME = get_env('STORAGE_AWS_REGION_NAME', None)\n    AWS_S3_ENDPOINT_URL = get_env('STORAGE_AWS_ENDPOINT_URL', None)\n    if get_env('STORAGE_AWS_OBJECT_PARAMETERS'):\n        AWS_S3_OBJECT_PARAMETERS = json.loads(get_env('STORAGE_AWS_OBJECT_PARAMETERS'))\n    AWS_QUERYSTRING_EXPIRE = int(get_env('STORAGE_AWS_X_AMZ_EXPIRES', '86400'))\n    AWS_LOCATION = get_env('STORAGE_AWS_FOLDER', default='')\n    AWS_S3_USE_SSL = get_bool_env('STORAGE_AWS_S3_USE_SSL', True)\n    AWS_S3_VERIFY = get_env('STORAGE_AWS_S3_VERIFY', None)\n    if AWS_S3_VERIFY == 'false' or AWS_S3_VERIFY == 'False' or AWS_S3_VERIFY == '0':\n        AWS_S3_VERIFY = False\n\nif get_env('STORAGE_TYPE') == \"azure\":\n    CLOUD_FILE_STORAGE_ENABLED = True\n    DEFAULT_FILE_STORAGE = 'core.storage.CustomAzureStorage'\n    AZURE_ACCOUNT_NAME = get_env('STORAGE_AZURE_ACCOUNT_NAME')\n    AZURE_ACCOUNT_KEY = get_env('STORAGE_AZURE_ACCOUNT_KEY')\n    AZURE_CONTAINER = get_env('STORAGE_AZURE_CONTAINER_NAME')\n    AZURE_URL_EXPIRATION_SECS = int(get_env('STORAGE_AZURE_URL_EXPIRATION_SECS', '86400'))\n    AZURE_LOCATION = get_env('STORAGE_AZURE_FOLDER', default='')\n\nif get_env('STORAGE_TYPE') == \"gcs\":\n    CLOUD_FILE_STORAGE_ENABLED = True\n    # DEFAULT_FILE_STORAGE = 'storages.backends.gcloud.GoogleCloudStorage'\n    DEFAULT_FILE_STORAGE = 'core.storage.AlternativeGoogleCloudStorage'\n    GS_PROJECT_ID = get_env('STORAGE_GCS_PROJECT_ID')\n    GS_BUCKET_NAME = get_env('STORAGE_GCS_BUCKET_NAME')\n    GS_EXPIRATION = timedelta(seconds=int(get_env('STORAGE_GCS_EXPIRATION_SECS', '86400')))\n    GS_LOCATION = get_env('STORAGE_GCS_FOLDER', default='')\n    GS_CUSTOM_ENDPOINT = get_env('STORAGE_GCS_ENDPOINT')\n\nCSRF_TRUSTED_ORIGINS = get_env('CSRF_TRUSTED_ORIGINS', [])\nif CSRF_TRUSTED_ORIGINS:\n    CSRF_TRUSTED_ORIGINS = CSRF_TRUSTED_ORIGINS.split(\",\")\n\nREAL_HOSTNAME = os.getenv('HOSTNAME')  # we have to use getenv, because we don't use LABEL_STUDIO_ prefix\nGCS_CLOUD_STORAGE_FORCE_DEFAULT_CREDENTIALS = get_bool_env('GCS_CLOUD_STORAGE_FORCE_DEFAULT_CREDENTIALS', False)\n", "\"\"\"This file and its contents are licensed under the Apache License 2.0. Please see the included NOTICE for copyright information and LICENSE for a copy of the license.\n\"\"\"\nimport os\nimport socket\nimport ipaddress\nimport pkg_resources\nimport shutil\nimport glob\nimport io\nimport ujson as json\nimport itertools\nimport yaml\n\nfrom urllib3.util import parse_url\nfrom contextlib import contextmanager\nfrom tempfile import mkstemp, mkdtemp\n\nfrom django.conf import settings\nfrom appdirs import user_config_dir, user_data_dir, user_cache_dir\n\n# full path import results in unit test failures\nfrom .exceptions import InvalidUploadUrlError\n\n\n_DIR_APP_NAME = 'label-studio'\n\n\ndef good_path(path):\n    return os.path.abspath(os.path.expanduser(path))\n\n\ndef find_node(package_name, node_path, node_type):\n    assert node_type in ('dir', 'file', 'any')\n    basedir = pkg_resources.resource_filename(package_name, '')\n    node_path = os.path.join(*node_path.split('/'))  # linux to windows compatibility\n    search_by_path = '/' in node_path or '\\\\' in node_path\n\n    for path, dirs, filenames in os.walk(basedir):\n        if node_type == 'file':\n            nodes = filenames\n        elif node_type == 'dir':\n            nodes = dirs\n        else:\n            nodes = filenames + dirs\n        if search_by_path:\n            for found_node in nodes:\n                found_node = os.path.join(path, found_node)\n                if found_node.endswith(node_path):\n                    return found_node\n        elif node_path in nodes:\n            return os.path.join(path, node_path)\n    else:\n        raise IOError(\n            'Could not find \"%s\" at package \"%s\"' % (node_path, basedir)\n        )\n\n\ndef find_file(file):\n    return find_node('label_studio', file, 'file')\n\n\ndef find_dir(directory):\n    return find_node('label_studio', directory, 'dir')\n\n\n@contextmanager\ndef get_temp_file():\n    fd, path = mkstemp()\n    yield path\n    os.close(fd)\n\n\n@contextmanager\ndef get_temp_dir():\n    dirpath = mkdtemp()\n    yield dirpath\n    shutil.rmtree(dirpath)\n\n\ndef get_config_dir():\n    config_dir = user_config_dir(appname=_DIR_APP_NAME)\n    try:\n        os.makedirs(config_dir, exist_ok=True)\n    except OSError:\n        pass\n    return config_dir\n\n\ndef get_data_dir():\n    data_dir = user_data_dir(appname=_DIR_APP_NAME)\n    os.makedirs(data_dir, exist_ok=True)\n    return data_dir\n\n\ndef get_cache_dir():\n    cache_dir = user_cache_dir(appname=_DIR_APP_NAME)\n    os.makedirs(cache_dir, exist_ok=True)\n    return cache_dir\n\n\ndef delete_dir_content(dirpath):\n    for f in glob.glob(dirpath + '/*'):\n        remove_file_or_dir(f)\n\n\ndef remove_file_or_dir(path):\n    if os.path.isfile(path):\n        os.remove(path)\n    elif os.path.isdir(path):\n        shutil.rmtree(path)\n\n\ndef get_all_files_from_dir(d):\n    out = []\n    for name in os.listdir(d):\n        filepath = os.path.join(d, name)\n        if os.path.isfile(filepath):\n            out.append(filepath)\n    return out\n\n\ndef iter_files(root_dir, ext):\n    for root, _, files in os.walk(root_dir):\n        for f in files:\n            if f.lower().endswith(ext):\n                yield os.path.join(root, f)\n\n\ndef json_load(file, int_keys=False):\n    with io.open(file, encoding='utf8') as f:\n        data = json.load(f)\n        if int_keys:\n            return {int(k): v for k, v in data.items()}\n        else:\n            return data\n\n\ndef read_yaml(filepath):\n    if not os.path.exists(filepath):\n        filepath = find_file(filepath)\n    with io.open(filepath, encoding='utf-8') as f:\n        data = yaml.load(f, Loader=yaml.FullLoader)  # nosec\n    return data\n\n\ndef read_bytes_stream(filepath):\n    with open(filepath, mode='rb') as f:\n        return io.BytesIO(f.read())\n\n\ndef get_all_dirs_from_dir(d):\n    out = []\n    for name in os.listdir(d):\n        filepath = os.path.join(d, name)\n        if os.path.isdir(filepath):\n            out.append(filepath)\n    return out\n\n\nclass SerializableGenerator(list):\n    \"\"\"Generator that is serializable by JSON\"\"\"\n\n    def __init__(self, iterable):\n        tmp_body = iter(iterable)\n        try:\n            self._head = iter([next(tmp_body)])\n            self.append(tmp_body)\n        except StopIteration:\n            self._head = []\n\n    def __iter__(self):\n        return itertools.chain(self._head, *self[:1])\n\ndef validate_upload_url(url, block_local_urls=True):\n    \"\"\"Utility function for defending against SSRF attacks. Raises\n        - InvalidUploadUrlError if the url is not HTTP[S], or if block_local_urls is enabled\n          and the URL resolves to a local address.\n        - LabelStudioApiException if the hostname cannot be resolved\n\n    :param url: Url to be checked for validity/safety,\n    :param block_local_urls: Whether urls that resolve to local/private networks should be allowed.\n    \"\"\"\n\n    parsed_url = parse_url(url)\n\n    if parsed_url.scheme not in ('http', 'https'):\n        raise InvalidUploadUrlError\n\n    domain = parsed_url.host\n    try:\n        ip = socket.gethostbyname(domain)\n    except socket.error:\n        from core.utils.exceptions import LabelStudioAPIException\n        raise LabelStudioAPIException(f\"Can't resolve hostname {domain}\")\n\n    if not block_local_urls:\n        return\n\n    if ip == '0.0.0.0':  # nosec\n        raise InvalidUploadUrlError\n    local_subnets = [\n        '127.0.0.0/8',\n        '10.0.0.0/8',\n        '172.16.0.0/12',\n        '192.168.0.0/16',\n    ]\n    for subnet in local_subnets:\n        if ipaddress.ip_address(ip) in ipaddress.ip_network(subnet):\n            raise InvalidUploadUrlError\n\n", "import os\nfrom rest_framework.exceptions import ValidationError\n\n\ndef cast_bool_from_str(value):\n    if isinstance(value, str):\n        if value.lower() in ['true', 'yes', 'on', '1']:\n            value = True\n        elif value.lower() in ['false', 'no', 'not', 'off', '0']:\n            value = False\n        else:\n            raise ValueError(f'Incorrect bool value \"{value}\". '\n                             f'It should be one of [1, 0, true, false, yes, no]')\n    return value\n\n\ndef bool_from_request(params, key, default):\n    \"\"\" Get boolean value from request GET, POST, etc\n\n    :param params: dict POST, GET, etc\n    :param key: key to find\n    :param default: default value\n    :return: boolean\n    \"\"\"\n    value = params.get(key, default)\n\n    try:\n        if isinstance(value, str):\n            value = cast_bool_from_str(value)\n        return bool(int(value))\n    except Exception as e:\n        raise ValidationError({key: str(e)})\n\n\ndef int_from_request(params, key, default):\n    \"\"\" Get integer from request GET, POST, etc\n\n    :param params: dict POST, GET, etc\n    :param key: key to find\n    :param default: default value\n    :return: int\n    \"\"\"\n    value = params.get(key, default)\n\n    # str\n    if isinstance(value, str):\n        try:\n            return int(value)\n        except ValueError:\n            raise ValidationError({key: f'Incorrect value in key \"{key}\" = \"{value}\". It should be digit string.'})\n        except Exception as e:\n            raise ValidationError({key: str(e)})\n    # int\n    elif isinstance(value, int):\n        return value\n    # other\n    else:\n        raise ValidationError({key: f'Incorrect value type in key \"{key}\" = \"{value}\". '\n                                    f'It should be digit string or integer.'})\n\n\ndef float_from_request(params, key, default):\n    \"\"\" Get float from request GET, POST, etc\n\n    :param params: dict POST, GET, etc\n    :param key: key to find\n    :param default: default value\n    :return: float\n    \"\"\"\n    value = params.get(key, default)\n\n    # str\n    if isinstance(value, str):\n        try:\n            return float(value)\n        except ValueError:\n            raise ValidationError({key: f'Incorrect value in key \"{key}\" = \"{value}\". It should be digit string.'})\n    # float\n    elif isinstance(value, float) or isinstance(value, int):\n        return float(value)\n    # other\n    else:\n        raise ValidationError({key: f'Incorrect value type in key \"{key}\" = \"{value}\". '\n                                    f'It should be digit string or float.'})\n\n\ndef list_of_strings_from_request(params, key, default):\n    \"\"\" Get list of strings from request GET, POST, etc\n\n    :param params: dict POST, GET, etc\n    :param key: key to find\n    :param default: default value\n    :return: float\n    \"\"\"\n    value = params.get(key, default)\n    if value is None:\n        return\n    splitters = (',', ';', '|')\n    # str\n    if isinstance(value, str):\n        for splitter in splitters:\n            if splitter in value:\n                return value.split(splitter)\n        return [value]\n    else:\n        raise ValidationError({key: f'Incorrect value type in key \"{key}\" = \"{value}\". '\n                                    f'It should be digit string or float.'})\n\n\ndef get_env(name, default=None, is_bool=False):\n    for env_key in ['LABEL_STUDIO_' + name, 'HEARTEX_' + name, name]:\n        value = os.environ.get(env_key)\n        if value is not None:\n            if is_bool:\n                return bool_from_request(os.environ, env_key, default)\n            else:\n                return value\n    return default\n\n\ndef get_bool_env(key, default):\n    return get_env(key, default, is_bool=True)\n\n\ndef get_env_list_int(key, default=None):\n    \"\"\"\n    \"1,2,3\" in env variable => [1, 2, 3] in python\n    \"\"\"\n    value = get_env(key)\n    if not value:\n        if default is None:\n            return []\n        return default\n    return [int(el) for el in value.split(',')]\n\n\ndef get_all_env_with_prefix(prefix=None, is_bool=True, default_value=None):\n    out = {}\n    for key in os.environ.keys():\n        if not key.startswith(prefix):\n            continue\n        if is_bool:\n            out[key] = bool_from_request(os.environ, key, default_value)\n        else:\n            out[key] = os.environ[key]\n    return out\n"], "fixing_code": ["wheel>=0.38.1,<=0.40.0\nappdirs>=1.4.3\nattr==0.3.1\nattrs>=19.2.0\npyyaml>=5.3.1\nazure-storage-blob>=12.6.0\n\nboto~=2.49.0\nboto3~=1.16.28\nbotocore~=1.19.28\nbleach~=5.0.0\n\ngoogle-api-core==2.11.0\ngoogle-auth==2.14.1\ngoogle-cloud-appengine-logging==1.1.0\ngoogle-cloud-audit-log==0.2.0\ngoogle-cloud-core==2.3.2\ngoogle-cloud-storage~=2.5.0\ngoogle-cloud-logging~=2.7.0\ngoogle-resumable-media==2.3.3\ngoogleapis-common-protos==1.56.4\ngrpc-google-iam-v1==0.12.4\n\nDjango==3.2.20\ndjango-storages==1.12.3\ndjango_annoying==0.10.6\ndjango_debug_toolbar==3.2.1\ndjango-environ==0.10.0\ndjango_filter==2.4.0\ndjango_model_utils==4.1.1\ndjango_rq==2.5.1\ndjango-cors-headers==3.6.0\ndjango-extensions==3.1.0\ndjango-rest-swagger==2.2.0\ndjango-user-agents==0.4.0\ndjango-ranged-fileresponse>=0.1.2\ndrf_dynamic_fields==0.3.0\ndjangorestframework==3.13.1\ndrf-flex-fields==0.9.5\ndrf_yasg==1.20.0\ndrf-generators==0.3.0\nhtmlmin==0.1.12\njsonschema==3.2.0\nlockfile>=0.12.0\nlxml>=4.2.5\ndefusedxml>=0.7.1\nnumpy==1.24.3\nordered_set==4.0.2\npandas>=0.24.0\nprotobuf>=3.15.5\npsycopg2-binary==2.9.6\npydantic>=1.7.3,<=1.11.0\npython_dateutil==2.8.1\npytz ~=2022.1\nrequests==2.31.0\nurllib3==1.26.16\nrq==1.10.1\nrules==2.2\nujson>=3.0.0\nxmljson==0.2.0\ncolorama>=0.4.4\nboxing>=0.1.4\nredis~=3.5\nsentry-sdk>=1.1.0\nlaunchdarkly-server-sdk==7.5.0\npython-json-logger==2.0.4\n\nlabel-studio-converter==0.0.54rc0\n", "\"\"\"This file and its contents are licensed under the Apache License 2.0. Please see the included NOTICE for copyright information and LICENSE for a copy of the license.\n\"\"\"\n\"\"\"\nDjango Base settings for Label Studio.\n\nFor more information on this file, see\nhttps://docs.djangoproject.com/en/3.1/topics/settings/\n\nFor the full list of settings and their values, see\nhttps://docs.djangoproject.com/en/3.1/ref/settings/\n\"\"\"\nimport os\nimport re\nimport logging\nimport json\n\nfrom datetime import timedelta\nfrom label_studio.core.utils.params import get_bool_env, get_env\n\nformatter = 'standard'\nJSON_LOG = get_bool_env('JSON_LOG', False)\nif JSON_LOG:\n    formatter = 'json'\n\nLOGGING = {\n    'version': 1,\n    'disable_existing_loggers': False,\n    'formatters': {\n        'json': {\n            '()': 'label_studio.core.utils.formatter.CustomJsonFormatter',\n            'format': '[%(asctime)s] [%(name)s::%(funcName)s::%(lineno)d] [%(levelname)s] [%(user_id)s] %(message)s',\n            'datefmt': '%d/%b/%Y:%H:%M:%S %z',\n        },\n        'standard': {\n            'format': '[%(asctime)s] [%(name)s::%(funcName)s::%(lineno)d] [%(levelname)s] %(message)s',\n        },\n    },\n    'handlers': {\n        'console': {\n            'class': 'logging.StreamHandler',\n            'formatter': formatter,\n        },\n    },\n    'root': {\n        'handlers': ['console'],\n        'level': os.environ.get('LOG_LEVEL', 'DEBUG'),\n    },\n    'loggers': {\n        'pykwalify': {'level': 'ERROR', 'propagate': False},\n        'tavern': {'level': 'ERROR', 'propagate': False},\n        'asyncio': {'level': 'WARNING'},\n        'rules': {'level': 'WARNING'},\n        'django': {\n            'handlers': ['console'],\n            # 'propagate': True,\n        },\n        'django_auth_ldap': {'level': os.environ.get('LOG_LEVEL', 'DEBUG')},\n        \"rq.worker\": {\n            \"handlers\": [\"console\"],\n            \"level\": os.environ.get('LOG_LEVEL', 'INFO'),\n        },\n        'ddtrace': {\n            'handlers': ['console'],\n            'level': 'WARNING',\n        },\n        'ldclient.util': {\n            'handlers': ['console'],\n            'level': 'ERROR',\n        },\n    },\n}\n\n# for printing messages before main logging config applied\nif not logging.getLogger().hasHandlers():\n    logging.basicConfig(level=logging.DEBUG, format='%(message)s')\n\nfrom label_studio.core.utils.io import get_data_dir, generate_key_if_missing\nfrom label_studio.core.utils.params import get_bool_env, get_env, get_env_list_int\n\nlogger = logging.getLogger(__name__)\nSILENCED_SYSTEM_CHECKS = []\n\n# Hostname is used for proper path generation to the resources, pages, etc\nHOSTNAME = get_env('HOST', '')\nif HOSTNAME:\n    if not HOSTNAME.startswith('http://') and not HOSTNAME.startswith('https://'):\n        logger.info(\n            \"! HOST variable found in environment, but it must start with http:// or https://, ignore it: %s\", HOSTNAME\n        )\n        HOSTNAME = ''\n    else:\n        logger.info(\"=> Hostname correctly is set to: %s\", HOSTNAME)\n        if HOSTNAME.endswith('/'):\n            HOSTNAME = HOSTNAME[0:-1]\n\n        # for django url resolver\n        if HOSTNAME:\n            # http[s]://domain.com:8080/script_name => /script_name\n            pattern = re.compile(r'^http[s]?:\\/\\/([^:\\/\\s]+(:\\d*)?)(.*)?')\n            match = pattern.match(HOSTNAME)\n            FORCE_SCRIPT_NAME = match.group(3)\n            if FORCE_SCRIPT_NAME:\n                logger.info(\"=> Django URL prefix is set to: %s\", FORCE_SCRIPT_NAME)\n\nINTERNAL_PORT = '8080'\n\n# SECURITY WARNING: keep the secret key used in production secret!\nSECRET_KEY = generate_key_if_missing('SECRET_KEY')\n\n# SECURITY WARNING: don't run with debug turned on in production!\nDEBUG = get_bool_env('DEBUG', True)\nDEBUG_MODAL_EXCEPTIONS = get_bool_env('DEBUG_MODAL_EXCEPTIONS', True)\n\n# Build paths inside the project like this: os.path.join(BASE_DIR, ...)\nBASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n\n# Base path for media root and other uploaded files\nBASE_DATA_DIR = get_env('BASE_DATA_DIR', get_data_dir())\nos.makedirs(BASE_DATA_DIR, exist_ok=True)\nlogger.info('=> Database and media directory: %s', BASE_DATA_DIR)\n\n# Databases\n# https://docs.djangoproject.com/en/2.1/ref/settings/#databases\nDJANGO_DB_MYSQL = 'mysql'\nDJANGO_DB_SQLITE = 'sqlite'\nDJANGO_DB_POSTGRESQL = 'postgresql'\nDJANGO_DB = 'default'\nDATABASE_NAME_DEFAULT = os.path.join(BASE_DATA_DIR, 'label_studio.sqlite3')\nDATABASE_NAME = get_env('DATABASE_NAME', DATABASE_NAME_DEFAULT)\nDATABASES_ALL = {\n    DJANGO_DB_POSTGRESQL: {\n        'ENGINE': 'django.db.backends.postgresql',\n        'USER': get_env('POSTGRE_USER', 'postgres'),\n        'PASSWORD': get_env('POSTGRE_PASSWORD', 'postgres'),\n        'NAME': get_env('POSTGRE_NAME', 'postgres'),\n        'HOST': get_env('POSTGRE_HOST', 'localhost'),\n        'PORT': int(get_env('POSTGRE_PORT', '5432')),\n    },\n    DJANGO_DB_MYSQL: {\n        'ENGINE': 'django.db.backends.mysql',\n        'USER': get_env('MYSQL_USER', 'root'),\n        'PASSWORD': get_env('MYSQL_PASSWORD', ''),\n        'NAME': get_env('MYSQL_NAME', 'labelstudio'),\n        'HOST': get_env('MYSQL_HOST', 'localhost'),\n        'PORT': int(get_env('MYSQL_PORT', '3306')),\n    },\n    DJANGO_DB_SQLITE: {\n        'ENGINE': 'django.db.backends.sqlite3',\n        'NAME': DATABASE_NAME,\n        'OPTIONS': {\n            # 'timeout': 20,\n        },\n    },\n}\nDATABASES_ALL['default'] = DATABASES_ALL[DJANGO_DB_POSTGRESQL]\nDATABASES = {'default': DATABASES_ALL.get(get_env('DJANGO_DB', 'default'))}\n\nDEFAULT_AUTO_FIELD = 'django.db.models.AutoField'\n\nif get_bool_env('GOOGLE_LOGGING_ENABLED', False):\n    logging.info('Google Cloud Logging handler is enabled.')\n    try:\n        import google.cloud.logging\n        from google.auth.exceptions import GoogleAuthError\n\n        client = google.cloud.logging.Client()\n        client.setup_logging()\n\n        LOGGING['handlers']['google_cloud_logging'] = {\n            'level': get_env('LOG_LEVEL', 'WARNING'),\n            'class': 'google.cloud.logging.handlers.CloudLoggingHandler',\n            'client': client,\n        }\n        LOGGING['root']['handlers'].append('google_cloud_logging')\n    except GoogleAuthError as e:\n        logger.exception('Google Cloud Logging handler could not be setup.')\n\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    'django.contrib.humanize',\n    'drf_yasg',\n    'corsheaders',\n    'django_extensions',\n    'django_rq',\n    'django_filters',\n    'rules',\n    'annoying',\n    'rest_framework',\n    'rest_framework_swagger',\n    'rest_framework.authtoken',\n    'drf_generators',\n    'core',\n    'users',\n    'organizations',\n    'data_import',\n    'data_export',\n    'projects',\n    'tasks',\n    'data_manager',\n    'io_storages',\n    'ml',\n    'webhooks',\n    'labels_manager',\n]\n\nMIDDLEWARE = [\n    'corsheaders.middleware.CorsMiddleware',\n    'django.middleware.security.SecurityMiddleware',\n    'django.contrib.sessions.middleware.SessionMiddleware',\n    'django.middleware.locale.LocaleMiddleware',\n    'core.middleware.DisableCSRF',\n    'django.middleware.csrf.CsrfViewMiddleware',\n    'django.contrib.auth.middleware.AuthenticationMiddleware',\n    'django.contrib.messages.middleware.MessageMiddleware',\n    'core.middleware.CommonMiddlewareAppendSlashWithoutRedirect',  # instead of 'CommonMiddleware'\n    'core.middleware.CommonMiddleware',\n    'django_user_agents.middleware.UserAgentMiddleware',\n    'core.middleware.SetSessionUIDMiddleware',\n    'core.middleware.ContextLogMiddleware',\n    'core.middleware.DatabaseIsLockedRetryMiddleware',\n    'core.current_request.ThreadLocalMiddleware',\n]\n\nREST_FRAMEWORK = {\n    'DEFAULT_FILTER_BACKENDS': ['django_filters.rest_framework.DjangoFilterBackend'],\n    'DEFAULT_AUTHENTICATION_CLASSES': (\n        'rest_framework.authentication.TokenAuthentication',\n        'rest_framework.authentication.SessionAuthentication',\n    ),\n    'DEFAULT_PERMISSION_CLASSES': [\n        'core.api_permissions.HasObjectPermission',\n        'rest_framework.permissions.IsAuthenticated',\n    ],\n    'EXCEPTION_HANDLER': 'core.utils.common.custom_exception_handler',\n    'DEFAULT_RENDERER_CLASSES': ('rest_framework.renderers.JSONRenderer',),\n    'DEFAULT_VERSIONING_CLASS': 'rest_framework.versioning.NamespaceVersioning',\n    'PAGE_SIZE': 100,\n    # 'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination'\n}\nSILENCED_SYSTEM_CHECKS += [\"rest_framework.W001\"]\n\n# CORS & Host settings\nINTERNAL_IPS = [  # django debug toolbar for django==2.2 requirement\n    '127.0.0.1',\n    'localhost',\n]\nCORS_ORIGIN_ALLOW_ALL = True\nCORS_ALLOW_METHODS = [\n    'DELETE',\n    'GET',\n    'OPTIONS',\n    'PATCH',\n    'POST',\n    'PUT',\n]\nALLOWED_HOSTS = ['*']\n\n# Auth modules\nAUTH_USER_MODEL = 'users.User'\nAUTHENTICATION_BACKENDS = ['rules.permissions.ObjectPermissionBackend', 'django.contrib.auth.backends.ModelBackend', ]\nUSE_USERNAME_FOR_LOGIN = False\n\nDISABLE_SIGNUP_WITHOUT_LINK = get_bool_env('DISABLE_SIGNUP_WITHOUT_LINK', False)\n\n# Password validation:\n# https://docs.djangoproject.com/en/2.1/ref/settings/#auth-password-validators\nAUTH_PASSWORD_VALIDATORS = [\n    {'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator'},\n    {'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator'},\n    {'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator'},\n    {'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator'},\n]\n\n# Django templates\nTEMPLATES_DIR = os.path.join(os.path.dirname(BASE_DIR), 'templates')  # ../../from_this = 'web' dir\nTEMPLATES = [\n    {\n        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n        'DIRS': [TEMPLATES_DIR],\n        'APP_DIRS': True,\n        'OPTIONS': {\n            'context_processors': [\n                'django.template.context_processors.debug',\n                'django.template.context_processors.request',\n                'django.contrib.auth.context_processors.auth',\n                'django.contrib.messages.context_processors.messages',\n                'core.context_processors.settings',\n            ],\n            'builtins': ['django.templatetags.i18n'],\n        },\n    }\n]\n\n# RQ\nRQ_QUEUES = {\n    'critical': {\n        'HOST': 'localhost',\n        'PORT': 6379,\n        'DB': 0,\n        'DEFAULT_TIMEOUT': 180,\n    },\n    'high': {\n        'HOST': 'localhost',\n        'PORT': 6379,\n        'DB': 0,\n        'DEFAULT_TIMEOUT': 180,\n    },\n    'default': {\n        'HOST': 'localhost',\n        'PORT': 6379,\n        'DB': 0,\n        'DEFAULT_TIMEOUT': 180,\n    },\n    'low': {\n        'HOST': 'localhost',\n        'PORT': 6379,\n        'DB': 0,\n        'DEFAULT_TIMEOUT': 180,\n    },\n}\n\n# Swagger: automatic API documentation\nSWAGGER_SETTINGS = {\n    'SECURITY_DEFINITIONS': {\n        'Token': {\n            'type': 'apiKey',\n            'name': 'Authorization',\n            'in': 'header',\n            'description':\n                'The token (or API key) must be passed as a request header. '\n                'You can find your user token on the User Account page in Label Studio. Example: '\n                '<br><pre><code class=\"language-bash\">'\n                'curl https://label-studio-host/api/projects -H \"Authorization: Token [your-token]\"'\n                '</code></pre>'\n        }\n    },\n    'APIS_SORTER': 'alpha',\n    'SUPPORTED_SUBMIT_METHODS': ['get', 'post', 'put', 'delete', 'patch'],\n    'OPERATIONS_SORTER': 'alpha',\n\n}\n\nSENTRY_DSN = get_env('SENTRY_DSN', None)\nSENTRY_RATE = float(get_env('SENTRY_RATE', 0.25))\nSENTRY_ENVIRONMENT = get_env('SENTRY_ENVIRONMENT', 'stage.opensource')\nSENTRY_REDIS_ENABLED = False\nFRONTEND_SENTRY_DSN = get_env('FRONTEND_SENTRY_DSN', None)\nFRONTEND_SENTRY_RATE = get_env('FRONTEND_SENTRY_RATE', 0.1)\nFRONTEND_SENTRY_ENVIRONMENT = get_env('FRONTEND_SENTRY_ENVIRONMENT', 'stage.opensource')\n\nROOT_URLCONF = 'core.urls'\nWSGI_APPLICATION = 'core.wsgi.application'\nGRAPHIQL = True\n\n# Internationalization\n# https://docs.djangoproject.com/en/2.1/topics/i18n/\nLANGUAGE_CODE = 'en-us'\nTIME_ZONE = 'UTC'\nUSE_I18N = False\nUSE_L10N = True\nUSE_TZ = True\n\n# Static files (CSS, JavaScript, Images)\n# https://docs.djangoproject.com/en/2.1/howto/static-files/\nSTATIC_URL = '/static/'\n# if FORCE_SCRIPT_NAME:\n#    STATIC_URL = FORCE_SCRIPT_NAME + STATIC_URL\nlogger.info(f'=> Static URL is set to: {STATIC_URL}')\n\nSTATIC_ROOT = os.path.join(BASE_DIR, 'static_build')\nSTATICFILES_DIRS = [os.path.join(BASE_DIR, 'static')]\nSTATICFILES_FINDERS = (\n    'django.contrib.staticfiles.finders.FileSystemFinder',\n    'django.contrib.staticfiles.finders.AppDirectoriesFinder',\n)\nSTATICFILES_STORAGE = 'core.storage.SkipMissedManifestStaticFilesStorage'\n\n# Sessions and CSRF\nSESSION_COOKIE_SECURE = bool(int(get_env('SESSION_COOKIE_SECURE', False)))\nSESSION_COOKIE_SAMESITE = get_env('SESSION_COOKIE_SAMESITE', 'Lax')\n\nCSRF_COOKIE_SECURE = bool(int(get_env('CSRF_COOKIE_SECURE', SESSION_COOKIE_SECURE)))\nCSRF_COOKIE_HTTPONLY = bool(int(get_env('CSRF_COOKIE_HTTPONLY', SESSION_COOKIE_SECURE)))\nCSRF_COOKIE_SAMESITE = get_env('CSRF_COOKIE_SAMESITE', 'Lax')\n\n# Inactivity user sessions\nINACTIVITY_SESSION_TIMEOUT_ENABLED = bool(int(get_env('INACTIVITY_SESSION_TIMEOUT_ENABLED', True)))\n# The most time a login will last, regardless of activity\nMAX_SESSION_AGE = int(get_env('MAX_SESSION_AGE', timedelta(days=14).total_seconds()))\n# The most time that can elapse between activity with the server before the user is logged out\nMAX_TIME_BETWEEN_ACTIVITY = int(get_env('MAX_TIME_BETWEEN_ACTIVITY', timedelta(days=5).total_seconds()))\n\nSSRF_PROTECTION_ENABLED = get_bool_env('SSRF_PROTECTION_ENABLED', False)\n\n# user media files\nMEDIA_ROOT = os.path.join(BASE_DATA_DIR, 'media')\nos.makedirs(MEDIA_ROOT, exist_ok=True)\nMEDIA_URL = '/data/'\nUPLOAD_DIR = 'upload'\nAVATAR_PATH = 'avatars'\n\nSUPPORTED_EXTENSIONS = set(\n    [\n        '.bmp',\n        '.csv',\n        '.flac',\n        '.gif',\n        '.htm',\n        '.html',\n        '.jpg',\n        '.jpeg',\n        '.json',\n        '.m4a',\n        '.mp3',\n        '.ogg',\n        '.png',\n        '.svg',\n        '.tsv',\n        '.txt',\n        '.wav',\n        '.xml',\n        '.mp4',\n        '.webm',\n        '.webp',\n    ]\n)\n\n# directory for files created during unit tests\nTEST_DATA_ROOT = os.path.join(BASE_DATA_DIR, 'test_data')\nos.makedirs(TEST_DATA_ROOT, exist_ok=True)\n\n# project exports\nEXPORT_DIR = os.path.join(BASE_DATA_DIR, 'export')\nEXPORT_URL_ROOT = '/export/'\nEXPORT_MIXIN = 'data_export.mixins.ExportMixin'\n# old export dir\nos.makedirs(EXPORT_DIR, exist_ok=True)\n# dir for delayed export\nDELAYED_EXPORT_DIR = 'export'\nos.makedirs(os.path.join(BASE_DATA_DIR, MEDIA_ROOT, DELAYED_EXPORT_DIR), exist_ok=True)\n\n# file / task size limits\nDATA_UPLOAD_MAX_MEMORY_SIZE = int(get_env('DATA_UPLOAD_MAX_MEMORY_SIZE', 250 * 1024 * 1024))\nTASKS_MAX_NUMBER = 1000000\nTASKS_MAX_FILE_SIZE = DATA_UPLOAD_MAX_MEMORY_SIZE\n\nTASK_LOCK_TTL = int(get_env('TASK_LOCK_TTL', default=86400))\n\nLABEL_STREAM_HISTORY_LIMIT = int(get_env('LABEL_STREAM_HISTORY_LIMIT', default=100))\n\nRANDOM_NEXT_TASK_SAMPLE_SIZE = int(get_env('RANDOM_NEXT_TASK_SAMPLE_SIZE', 50))\n\nTASK_API_PAGE_SIZE_MAX = int(get_env('TASK_API_PAGE_SIZE_MAX', 0)) or None\n\n# Email backend\nFROM_EMAIL = get_env('FROM_EMAIL', 'Label Studio <hello@labelstud.io>')\nEMAIL_BACKEND = get_env('EMAIL_BACKEND', 'django.core.mail.backends.dummy.EmailBackend')\n\nENABLE_LOCAL_FILES_STORAGE = get_bool_env('ENABLE_LOCAL_FILES_STORAGE', default=True)\nLOCAL_FILES_SERVING_ENABLED = get_bool_env('LOCAL_FILES_SERVING_ENABLED', default=False)\nLOCAL_FILES_DOCUMENT_ROOT = get_env('LOCAL_FILES_DOCUMENT_ROOT', default=os.path.abspath(os.sep))\n\nSYNC_ON_TARGET_STORAGE_CREATION = get_bool_env('SYNC_ON_TARGET_STORAGE_CREATION', default=True)\n\nALLOW_IMPORT_TASKS_WITH_UNKNOWN_EMAILS = get_bool_env('ALLOW_IMPORT_TASKS_WITH_UNKNOWN_EMAILS', default=False)\n\n\"\"\" React Libraries: do not forget to change this dir in /etc/nginx/nginx.conf \"\"\"\n# EDITOR = label-studio-frontend repository\nEDITOR_ROOT = os.path.join(BASE_DIR, '../frontend/dist/lsf')\n# DM = data manager (included into FRONTEND due npm building, we need only version.json file from there)\nDM_ROOT = os.path.join(BASE_DIR, '../frontend/dist/dm')\n# FRONTEND = GUI for django backend\nREACT_APP_ROOT = os.path.join(BASE_DIR, '../frontend/dist/react-app')\n\n# per project settings\nBATCH_SIZE = 1000\nPROJECT_TITLE_MIN_LEN = 3\nPROJECT_TITLE_MAX_LEN = 50\nLOGIN_REDIRECT_URL = '/'\nLOGIN_URL = '/'\nMIN_GROUND_TRUTH = 10\nDATA_UNDEFINED_NAME = '$undefined$'\nLICENSE = {}\nVERSIONS = {}\nVERSION_EDITION = 'Community'\nLATEST_VERSION_CHECK = True\nVERSIONS_CHECK_TIME = 0\nALLOW_ORGANIZATION_WEBHOOKS = get_bool_env('ALLOW_ORGANIZATION_WEBHOOKS', False)\nCONVERTER_DOWNLOAD_RESOURCES = get_bool_env('CONVERTER_DOWNLOAD_RESOURCES', True)\nEXPERIMENTAL_FEATURES = get_bool_env('EXPERIMENTAL_FEATURES', False)\nUSE_ENFORCE_CSRF_CHECKS = get_bool_env('USE_ENFORCE_CSRF_CHECKS', True)  # False is for tests\nCLOUD_FILE_STORAGE_ENABLED = False\n\nIO_STORAGES_IMPORT_LINK_NAMES = [\n    'io_storages_s3importstoragelink',\n    'io_storages_gcsimportstoragelink',\n    'io_storages_azureblobimportstoragelink',\n    'io_storages_localfilesimportstoragelink',\n    'io_storages_redisimportstoragelink',\n]\n\nCREATE_ORGANIZATION = 'organizations.functions.create_organization'\nSAVE_USER = 'users.functions.save_user'\nPOST_PROCESS_REIMPORT = 'core.utils.common.empty'\nUSER_SERIALIZER = 'users.serializers.BaseUserSerializer'\nUSER_SERIALIZER_UPDATE = 'users.serializers.BaseUserSerializerUpdate'\nTASK_SERIALIZER = 'tasks.serializers.BaseTaskSerializer'\nEXPORT_DATA_SERIALIZER = 'data_export.serializers.BaseExportDataSerializer'\nDATA_MANAGER_GET_ALL_COLUMNS = 'data_manager.functions.get_all_columns'\nDATA_MANAGER_ANNOTATIONS_MAP = {}\nDATA_MANAGER_ACTIONS = {}\nDATA_MANAGER_CUSTOM_FILTER_EXPRESSIONS = 'data_manager.functions.custom_filter_expressions'\nDATA_MANAGER_PREPROCESS_FILTER = 'data_manager.functions.preprocess_filter'\nUSER_LOGIN_FORM = 'users.forms.LoginForm'\nPROJECT_MIXIN = 'projects.mixins.ProjectMixin'\nTASK_MIXIN = 'tasks.mixins.TaskMixin'\nANNOTATION_MIXIN = 'tasks.mixins.AnnotationMixin'\nORGANIZATION_MIXIN = 'organizations.mixins.OrganizationMixin'\nUSER_MIXIN = 'users.mixins.UserMixin'\nRECALCULATE_ALL_STATS = None\nGET_STORAGE_LIST = 'io_storages.functions.get_storage_list'\nSTORAGE_ANNOTATION_SERIALIZER = 'io_storages.serializers.StorageAnnotationSerializer'\nTASK_SERIALIZER_BULK = 'tasks.serializers.BaseTaskSerializerBulk'\nPREPROCESS_FIELD_NAME = 'data_manager.functions.preprocess_field_name'\nINTERACTIVE_DATA_SERIALIZER = 'data_export.serializers.BaseExportDataSerializerForInteractive'\nDELETE_TASKS_ANNOTATIONS_POSTPROCESS = None\n\n\ndef project_delete(project):\n    project.delete()\n\n\ndef user_auth(user_model, email, password):\n    return None\n\n\ndef collect_versions_dummy(**kwargs):\n    return {}\n\n\nPROJECT_DELETE = project_delete\nUSER_AUTH = user_auth\nCOLLECT_VERSIONS = collect_versions_dummy\n\nWEBHOOK_TIMEOUT = float(get_env('WEBHOOK_TIMEOUT', 1.0))\nWEBHOOK_SERIALIZERS = {\n    'project': 'webhooks.serializers_for_hooks.ProjectWebhookSerializer',\n    'task': 'webhooks.serializers_for_hooks.TaskWebhookSerializer',\n    'annotation': 'webhooks.serializers_for_hooks.AnnotationWebhookSerializer',\n    'label': 'labels_manager.serializers.LabelSerializer',\n    'label_link': 'labels_manager.serializers.LabelLinkSerializer',\n}\n\nEDITOR_KEYMAP = json.dumps(get_env(\"EDITOR_KEYMAP\"))\n\n# fix a problem with Windows mimetypes for JS and PNG\nimport mimetypes\n\nmimetypes.add_type(\"application/javascript\", \".js\", True)\nmimetypes.add_type(\"image/png\", \".png\", True)\n\n# fields name was used in DM api before\nREST_FLEX_FIELDS = {\"FIELDS_PARAM\": \"include\"}\n\nINTERPOLATE_KEY_FRAMES = get_env('INTERPOLATE_KEY_FRAMES', False)\n\n# Feature Flags\nFEATURE_FLAGS_API_KEY = get_env('FEATURE_FLAGS_API_KEY', default='any key')\n\n# we may set feature flags from file\nFEATURE_FLAGS_FROM_FILE = get_bool_env('FEATURE_FLAGS_FROM_FILE', False)\nFEATURE_FLAGS_FILE = get_env('FEATURE_FLAGS_FILE', 'feature_flags.json')\n# or if file is not set, default is using offline mode\nFEATURE_FLAGS_OFFLINE = get_bool_env('FEATURE_FLAGS_OFFLINE', True)\n# default value for feature flags (if not overridden by environment or client)\nFEATURE_FLAGS_DEFAULT_VALUE = False\n\n# Whether to send analytics telemetry data\nCOLLECT_ANALYTICS = get_bool_env('collect_analytics', True)\n\n# Strip harmful content from SVG files by default\nSVG_SECURITY_CLEANUP = get_bool_env('SVG_SECURITY_CLEANUP', False)\n\nML_BLOCK_LOCAL_IP = get_bool_env('ML_BLOCK_LOCAL_IP', False)\n\nRQ_LONG_JOB_TIMEOUT = int(get_env('RQ_LONG_JOB_TIMEOUT', 36000))\n\nAPP_WEBSERVER = get_env('APP_WEBSERVER', 'django')\n\nBATCH_JOB_RETRY_TIMEOUT = int(get_env('BATCH_JOB_RETRY_TIMEOUT', 60))\n\nFUTURE_SAVE_TASK_TO_STORAGE = get_bool_env('FUTURE_SAVE_TASK_TO_STORAGE', default=False)\nFUTURE_SAVE_TASK_TO_STORAGE_JSON_EXT = get_bool_env('FUTURE_SAVE_TASK_TO_STORAGE_JSON_EXT', default=True)\nSTORAGE_IN_PROGRESS_TIMER = get_env('STORAGE_IN_PROGRESS_TIMER', 5.0)\n\nUSE_NGINX_FOR_EXPORT_DOWNLOADS = get_bool_env('USE_NGINX_FOR_EXPORT_DOWNLOADS', False)\n\nif get_env('MINIO_STORAGE_ENDPOINT') and not get_bool_env('MINIO_SKIP', False):\n    CLOUD_FILE_STORAGE_ENABLED = True\n    DEFAULT_FILE_STORAGE = 'storages.backends.s3boto3.S3Boto3Storage'\n    AWS_STORAGE_BUCKET_NAME = get_env('MINIO_STORAGE_BUCKET_NAME')\n    AWS_ACCESS_KEY_ID = get_env('MINIO_STORAGE_ACCESS_KEY')\n    AWS_SECRET_ACCESS_KEY = get_env('MINIO_STORAGE_SECRET_KEY')\n    AWS_S3_ENDPOINT_URL = get_env('MINIO_STORAGE_ENDPOINT')\n    AWS_QUERYSTRING_AUTH = False\n    # make domain for FileUpload.file\n    AWS_S3_SECURE_URLS = False\n    AWS_S3_URL_PROTOCOL = 'http:' if HOSTNAME.startswith('http://') else 'https:'\n    AWS_S3_CUSTOM_DOMAIN = HOSTNAME.replace('http://', '').replace('https://', '') + '/data'\n\nif get_env('STORAGE_TYPE') == \"s3\":\n    CLOUD_FILE_STORAGE_ENABLED = True\n    DEFAULT_FILE_STORAGE = 'core.storage.CustomS3Boto3Storage'\n    if get_env('STORAGE_AWS_ACCESS_KEY_ID'):\n        AWS_ACCESS_KEY_ID = get_env('STORAGE_AWS_ACCESS_KEY_ID')\n    if get_env('STORAGE_AWS_SECRET_ACCESS_KEY'):\n        AWS_SECRET_ACCESS_KEY = get_env('STORAGE_AWS_SECRET_ACCESS_KEY')\n    AWS_STORAGE_BUCKET_NAME = get_env('STORAGE_AWS_BUCKET_NAME')\n    AWS_S3_REGION_NAME = get_env('STORAGE_AWS_REGION_NAME', None)\n    AWS_S3_ENDPOINT_URL = get_env('STORAGE_AWS_ENDPOINT_URL', None)\n    if get_env('STORAGE_AWS_OBJECT_PARAMETERS'):\n        AWS_S3_OBJECT_PARAMETERS = json.loads(get_env('STORAGE_AWS_OBJECT_PARAMETERS'))\n    AWS_QUERYSTRING_EXPIRE = int(get_env('STORAGE_AWS_X_AMZ_EXPIRES', '86400'))\n    AWS_LOCATION = get_env('STORAGE_AWS_FOLDER', default='')\n    AWS_S3_USE_SSL = get_bool_env('STORAGE_AWS_S3_USE_SSL', True)\n    AWS_S3_VERIFY = get_env('STORAGE_AWS_S3_VERIFY', None)\n    if AWS_S3_VERIFY == 'false' or AWS_S3_VERIFY == 'False' or AWS_S3_VERIFY == '0':\n        AWS_S3_VERIFY = False\n\nif get_env('STORAGE_TYPE') == \"azure\":\n    CLOUD_FILE_STORAGE_ENABLED = True\n    DEFAULT_FILE_STORAGE = 'core.storage.CustomAzureStorage'\n    AZURE_ACCOUNT_NAME = get_env('STORAGE_AZURE_ACCOUNT_NAME')\n    AZURE_ACCOUNT_KEY = get_env('STORAGE_AZURE_ACCOUNT_KEY')\n    AZURE_CONTAINER = get_env('STORAGE_AZURE_CONTAINER_NAME')\n    AZURE_URL_EXPIRATION_SECS = int(get_env('STORAGE_AZURE_URL_EXPIRATION_SECS', '86400'))\n    AZURE_LOCATION = get_env('STORAGE_AZURE_FOLDER', default='')\n\nif get_env('STORAGE_TYPE') == \"gcs\":\n    CLOUD_FILE_STORAGE_ENABLED = True\n    # DEFAULT_FILE_STORAGE = 'storages.backends.gcloud.GoogleCloudStorage'\n    DEFAULT_FILE_STORAGE = 'core.storage.AlternativeGoogleCloudStorage'\n    GS_PROJECT_ID = get_env('STORAGE_GCS_PROJECT_ID')\n    GS_BUCKET_NAME = get_env('STORAGE_GCS_BUCKET_NAME')\n    GS_EXPIRATION = timedelta(seconds=int(get_env('STORAGE_GCS_EXPIRATION_SECS', '86400')))\n    GS_LOCATION = get_env('STORAGE_GCS_FOLDER', default='')\n    GS_CUSTOM_ENDPOINT = get_env('STORAGE_GCS_ENDPOINT')\n\nCSRF_TRUSTED_ORIGINS = get_env('CSRF_TRUSTED_ORIGINS', [])\nif CSRF_TRUSTED_ORIGINS:\n    CSRF_TRUSTED_ORIGINS = CSRF_TRUSTED_ORIGINS.split(\",\")\n\nREAL_HOSTNAME = os.getenv('HOSTNAME')  # we have to use getenv, because we don't use LABEL_STUDIO_ prefix\nGCS_CLOUD_STORAGE_FORCE_DEFAULT_CREDENTIALS = get_bool_env('GCS_CLOUD_STORAGE_FORCE_DEFAULT_CREDENTIALS', False)\n", "\"\"\"This file and its contents are licensed under the Apache License 2.0. Please see the included NOTICE for copyright information and LICENSE for a copy of the license.\n\n\"\"\"\nimport os\nimport socket\nimport ipaddress\nimport pkg_resources\nimport shutil\nimport glob\nimport io\nimport ujson as json\nimport itertools\nimport yaml\n\nfrom urllib3.util import parse_url\nfrom contextlib import contextmanager\nfrom tempfile import mkstemp, mkdtemp\n\nfrom django.conf import settings\nfrom django.core.management.utils import get_random_secret_key\nfrom label_studio.core.utils.params import env, env_file\nfrom appdirs import user_config_dir, user_data_dir, user_cache_dir\n\n# full path import results in unit test failures\nfrom .exceptions import InvalidUploadUrlError\n\n\n_DIR_APP_NAME = 'label-studio'\n\n\ndef good_path(path):\n    return os.path.abspath(os.path.expanduser(path))\n\n\ndef find_node(package_name, node_path, node_type):\n    assert node_type in ('dir', 'file', 'any')\n    basedir = pkg_resources.resource_filename(package_name, '')\n    node_path = os.path.join(*node_path.split('/'))  # linux to windows compatibility\n    search_by_path = '/' in node_path or '\\\\' in node_path\n\n    for path, dirs, filenames in os.walk(basedir):\n        if node_type == 'file':\n            nodes = filenames\n        elif node_type == 'dir':\n            nodes = dirs\n        else:\n            nodes = filenames + dirs\n        if search_by_path:\n            for found_node in nodes:\n                found_node = os.path.join(path, found_node)\n                if found_node.endswith(node_path):\n                    return found_node\n        elif node_path in nodes:\n            return os.path.join(path, node_path)\n    else:\n        raise IOError(\n            'Could not find \"%s\" at package \"%s\"' % (node_path, basedir)\n        )\n\n\ndef find_file(file):\n    return find_node('label_studio', file, 'file')\n\n\ndef find_dir(directory):\n    return find_node('label_studio', directory, 'dir')\n\n\n@contextmanager\ndef get_temp_file():\n    fd, path = mkstemp()\n    yield path\n    os.close(fd)\n\n\n@contextmanager\ndef get_temp_dir():\n    dirpath = mkdtemp()\n    yield dirpath\n    shutil.rmtree(dirpath)\n\n\ndef get_config_dir():\n    config_dir = user_config_dir(appname=_DIR_APP_NAME)\n    try:\n        os.makedirs(config_dir, exist_ok=True)\n    except OSError:\n        pass\n    return config_dir\n\n\ndef get_data_dir():\n    data_dir = user_data_dir(appname=_DIR_APP_NAME)\n    os.makedirs(data_dir, exist_ok=True)\n    return data_dir\n\n\ndef get_cache_dir():\n    cache_dir = user_cache_dir(appname=_DIR_APP_NAME)\n    os.makedirs(cache_dir, exist_ok=True)\n    return cache_dir\n\n\ndef delete_dir_content(dirpath):\n    for f in glob.glob(dirpath + '/*'):\n        remove_file_or_dir(f)\n\n\ndef remove_file_or_dir(path):\n    if os.path.isfile(path):\n        os.remove(path)\n    elif os.path.isdir(path):\n        shutil.rmtree(path)\n\n\ndef get_all_files_from_dir(d):\n    out = []\n    for name in os.listdir(d):\n        filepath = os.path.join(d, name)\n        if os.path.isfile(filepath):\n            out.append(filepath)\n    return out\n\n\ndef iter_files(root_dir, ext):\n    for root, _, files in os.walk(root_dir):\n        for f in files:\n            if f.lower().endswith(ext):\n                yield os.path.join(root, f)\n\n\ndef json_load(file, int_keys=False):\n    with io.open(file, encoding='utf8') as f:\n        data = json.load(f)\n        if int_keys:\n            return {int(k): v for k, v in data.items()}\n        else:\n            return data\n\n\ndef read_yaml(filepath):\n    if not os.path.exists(filepath):\n        filepath = find_file(filepath)\n    with io.open(filepath, encoding='utf-8') as f:\n        data = yaml.load(f, Loader=yaml.FullLoader)  # nosec\n    return data\n\n\ndef read_bytes_stream(filepath):\n    with open(filepath, mode='rb') as f:\n        return io.BytesIO(f.read())\n\n\ndef get_all_dirs_from_dir(d):\n    out = []\n    for name in os.listdir(d):\n        filepath = os.path.join(d, name)\n        if os.path.isdir(filepath):\n            out.append(filepath)\n    return out\n\n\nclass SerializableGenerator(list):\n    \"\"\"Generator that is serializable by JSON\"\"\"\n\n    def __init__(self, iterable):\n        tmp_body = iter(iterable)\n        try:\n            self._head = iter([next(tmp_body)])\n            self.append(tmp_body)\n        except StopIteration:\n            self._head = []\n\n    def __iter__(self):\n        return itertools.chain(self._head, *self[:1])\n\ndef validate_upload_url(url, block_local_urls=True):\n    \"\"\"Utility function for defending against SSRF attacks. Raises\n        - InvalidUploadUrlError if the url is not HTTP[S], or if block_local_urls is enabled\n          and the URL resolves to a local address.\n        - LabelStudioApiException if the hostname cannot be resolved\n\n    :param url: Url to be checked for validity/safety,\n    :param block_local_urls: Whether urls that resolve to local/private networks should be allowed.\n    \"\"\"\n\n    parsed_url = parse_url(url)\n\n    if parsed_url.scheme not in ('http', 'https'):\n        raise InvalidUploadUrlError\n\n    domain = parsed_url.host\n    try:\n        ip = socket.gethostbyname(domain)\n    except socket.error:\n        from core.utils.exceptions import LabelStudioAPIException\n        raise LabelStudioAPIException(f\"Can't resolve hostname {domain}\")\n\n    if not block_local_urls:\n        return\n\n    if ip == '0.0.0.0':  # nosec\n        raise InvalidUploadUrlError\n    local_subnets = [\n        '127.0.0.0/8',\n        '10.0.0.0/8',\n        '172.16.0.0/12',\n        '192.168.0.0/16',\n    ]\n    for subnet in local_subnets:\n        if ipaddress.ip_address(ip) in ipaddress.ip_network(subnet):\n            raise InvalidUploadUrlError\n\ndef generate_key_if_missing(key):\n    value = env.str(key, \"\")\n\n    if value == \"\":\n        print(f'Warning: {key} not found in environment variables will generate a random key.')\n        value = get_random_secret_key()\n        try:\n            with open(env_file, 'a') as f:\n                f.write(f'\\n{key}={value}\\n')\n        except Exception as e:\n            print(f'Warning: failed to write {key} to .env file: {e}, new key will be regenerated on every server restart. If this key is used for signing, it will invalidate all existing sessions or tokens. Please set {key} in your environment variables to avoid this warning.')\n\n        os.environ[key] = value\n\n    return value\n\n", "import os\nimport environ\n\nfrom rest_framework.exceptions import ValidationError\n\n\nenv = environ.Env()\ndata_dir = os.environ.get('LABEL_STUDIO_DATA_DIR', os.path.join(os.path.dirname(__file__), '..', '..', '..', 'data'))\nenv_file = os.path.join(data_dir, '.env')\nenviron.Env.read_env(env_file)\n\ndef cast_bool_from_str(value):\n    if isinstance(value, str):\n        if value.lower() in ['true', 'yes', 'on', '1']:\n            value = True\n        elif value.lower() in ['false', 'no', 'not', 'off', '0']:\n            value = False\n        else:\n            raise ValueError(f'Incorrect bool value \"{value}\". '\n                             f'It should be one of [1, 0, true, false, yes, no]')\n    return value\n\n\ndef bool_from_request(params, key, default):\n    \"\"\" Get boolean value from request GET, POST, etc\n\n    :param params: dict POST, GET, etc\n    :param key: key to find\n    :param default: default value\n    :return: boolean\n    \"\"\"\n    value = params.get(key, default)\n\n    try:\n        if isinstance(value, str):\n            value = cast_bool_from_str(value)\n        return bool(int(value))\n    except Exception as e:\n        raise ValidationError({key: str(e)})\n\n\ndef int_from_request(params, key, default):\n    \"\"\" Get integer from request GET, POST, etc\n\n    :param params: dict POST, GET, etc\n    :param key: key to find\n    :param default: default value\n    :return: int\n    \"\"\"\n    value = params.get(key, default)\n\n    # str\n    if isinstance(value, str):\n        try:\n            return int(value)\n        except ValueError:\n            raise ValidationError({key: f'Incorrect value in key \"{key}\" = \"{value}\". It should be digit string.'})\n        except Exception as e:\n            raise ValidationError({key: str(e)})\n    # int\n    elif isinstance(value, int):\n        return value\n    # other\n    else:\n        raise ValidationError({key: f'Incorrect value type in key \"{key}\" = \"{value}\". '\n                                    f'It should be digit string or integer.'})\n\n\ndef float_from_request(params, key, default):\n    \"\"\" Get float from request GET, POST, etc\n\n    :param params: dict POST, GET, etc\n    :param key: key to find\n    :param default: default value\n    :return: float\n    \"\"\"\n    value = params.get(key, default)\n\n    # str\n    if isinstance(value, str):\n        try:\n            return float(value)\n        except ValueError:\n            raise ValidationError({key: f'Incorrect value in key \"{key}\" = \"{value}\". It should be digit string.'})\n    # float\n    elif isinstance(value, float) or isinstance(value, int):\n        return float(value)\n    # other\n    else:\n        raise ValidationError({key: f'Incorrect value type in key \"{key}\" = \"{value}\". '\n                                    f'It should be digit string or float.'})\n\n\ndef list_of_strings_from_request(params, key, default):\n    \"\"\" Get list of strings from request GET, POST, etc\n\n    :param params: dict POST, GET, etc\n    :param key: key to find\n    :param default: default value\n    :return: float\n    \"\"\"\n    value = params.get(key, default)\n    if value is None:\n        return\n    splitters = (',', ';', '|')\n    # str\n    if isinstance(value, str):\n        for splitter in splitters:\n            if splitter in value:\n                return value.split(splitter)\n        return [value]\n    else:\n        raise ValidationError({key: f'Incorrect value type in key \"{key}\" = \"{value}\". '\n                                    f'It should be digit string or float.'})\n\n\ndef get_env(name, default=None, is_bool=False):\n    for env_key in ['LABEL_STUDIO_' + name, 'HEARTEX_' + name, name]:\n        value = os.environ.get(env_key)\n        if value is not None:\n            if is_bool:\n                return bool_from_request(os.environ, env_key, default)\n            else:\n                return value\n    return default\n\n\ndef get_bool_env(key, default):\n    return get_env(key, default, is_bool=True)\n\n\ndef get_env_list_int(key, default=None):\n    \"\"\"\n    \"1,2,3\" in env variable => [1, 2, 3] in python\n    \"\"\"\n    value = get_env(key)\n    if not value:\n        if default is None:\n            return []\n        return default\n    return [int(el) for el in value.split(',')]\n\n\ndef get_all_env_with_prefix(prefix=None, is_bool=True, default_value=None):\n    out = {}\n    for key in os.environ.keys():\n        if not key.startswith(prefix):\n            continue\n        if is_bool:\n            out[key] = bool_from_request(os.environ, key, default_value)\n        else:\n            out[key] = os.environ[key]\n    return out\n"], "filenames": ["deploy/requirements.txt", "label_studio/core/settings/base.py", "label_studio/core/utils/io.py", "label_studio/core/utils/params.py"], "buggy_code_start_loc": [27, 77, 1, 1], "buggy_code_end_loc": [27, 109, 210, 3], "fixing_code_start_loc": [28, 77, 2, 2], "fixing_code_end_loc": [29, 109, 230, 11], "type": "CWE-200", "message": "Label Studio is a multi-type data labeling and annotation tool with standardized output format. There is a vulnerability that can be chained within the ORM Leak vulnerability to impersonate any account on Label Studio. An attacker could exploit these vulnerabilities to escalate their privileges from a low privilege user to a Django Super Administrator user. The vulnerability was found to affect versions before `1.8.2`, where a patch was introduced.", "other": {"cve": {"id": "CVE-2023-43791", "sourceIdentifier": "security-advisories@github.com", "published": "2023-11-09T15:15:08.743", "lastModified": "2023-11-18T00:55:15.610", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Label Studio is a multi-type data labeling and annotation tool with standardized output format. There is a vulnerability that can be chained within the ORM Leak vulnerability to impersonate any account on Label Studio. An attacker could exploit these vulnerabilities to escalate their privileges from a low privilege user to a Django Super Administrator user. The vulnerability was found to affect versions before `1.8.2`, where a patch was introduced."}, {"lang": "es", "value": "Label Studio es una herramienta de anotaci\u00f3n y etiquetado de datos de varios tipos con formato de salida estandarizado. Existe una vulnerabilidad que se puede encadenar dentro de la vulnerabilidad ORM Leak para hacerse pasar por cualquier cuenta en Label Studio. Un atacante podr\u00eda aprovechar estas vulnerabilidades para escalar sus privilegios de un usuario con permisos bajos a un usuario s\u00faper administrador de Django. Se descubri\u00f3 que la vulnerabilidad afectaba a versiones anteriores a la \"1.8.2\", donde se introdujo un parche."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:humansignal:label_studio:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.8.2", "matchCriteriaId": "ACEFE38F-DAA5-4450-9527-0669A8790ADC"}]}]}], "references": [{"url": "https://github.com/HumanSignal/label-studio/commit/3d06c5131c15600621e08b06f07d976887cde81b", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/HumanSignal/label-studio/pull/4690", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/HumanSignal/label-studio/releases/tag/1.8.2", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/HumanSignal/label-studio/security/advisories/GHSA-f475-x83m-rx5m", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/HumanSignal/label-studio/commit/3d06c5131c15600621e08b06f07d976887cde81b"}}