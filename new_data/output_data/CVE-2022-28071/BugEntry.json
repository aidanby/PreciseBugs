{"buggy_code": ["/* radare - LGPL - Copyright 2016-2020 - oddcoder, sivaramaaa */\n/* type matching - type propagation */\n\n#include <r_anal.h>\n#include <r_util.h>\n#include <r_core.h>\n#define LOOP_MAX 10\n\nstatic bool anal_emul_init(RCore *core, RConfigHold *hc, RDebugTrace **dt, RAnalEsilTrace **et) {\n\tif (!core->anal->esil) {\n\t\treturn false;\n\t}\n\t*dt = core->dbg->trace;\n\t*et = core->anal->esil->trace;\n\tcore->dbg->trace = r_debug_trace_new ();\n\tcore->anal->esil->trace = r_anal_esil_trace_new (core->anal->esil);\n\tr_config_hold (hc, \"esil.romem\", \"dbg.trace\", \"esil.nonull\", \"dbg.follow\", NULL);\n\tr_config_set (core->config, \"esil.romem\", \"true\");\n\tr_config_set (core->config, \"dbg.trace\", \"true\");\n\tr_config_set (core->config, \"esil.nonull\", \"true\");\n\tr_config_set_i (core->config, \"dbg.follow\", false);\n\tconst char *bp = r_reg_get_name (core->anal->reg, R_REG_NAME_BP);\n\tconst char *sp = r_reg_get_name (core->anal->reg, R_REG_NAME_SP);\n\tif ((bp && !r_reg_getv (core->anal->reg, bp)) && (sp && !r_reg_getv (core->anal->reg, sp))) {\n\t\teprintf (\"Stack isn't initialized.\\n\");\n\t\teprintf (\"Try running aei and aeim commands before aft for default stack initialization\\n\");\n\t\treturn false;\n\t}\n\treturn (core->dbg->trace && core->anal->esil->trace);\n}\n\nstatic void anal_emul_restore(RCore *core, RConfigHold *hc, RDebugTrace *dt, RAnalEsilTrace *et) {\n\tr_config_hold_restore (hc);\n\tr_config_hold_free (hc);\n\tr_debug_trace_free (core->dbg->trace);\n\tr_anal_esil_trace_free (core->anal->esil->trace);\n\tcore->anal->esil->trace = et;\n\tcore->dbg->trace = dt;\n}\n\n#define SDB_CONTAINS(i,s) sdb_array_contains (trace, sdb_fmt (\"%d.reg.write\", i), s, 0)\n\nstatic bool type_pos_hit(RAnal *anal, Sdb *trace, bool in_stack, int idx, int size, const char *place) {\n\tif (in_stack) {\n\t\tconst char *sp_name = r_reg_get_name (anal->reg, R_REG_NAME_SP);\n\t\tut64 sp = r_reg_getv (anal->reg, sp_name);\n\t\tut64 write_addr = sdb_num_get (trace, sdb_fmt (\"%d.mem.write\", idx), 0);\n\t\treturn (write_addr == sp + size);\n\t}\n\treturn SDB_CONTAINS (idx, place);\n}\n\nstatic void __var_rename(RAnal *anal, RAnalVar *v, const char *name, ut64 addr) {\n\tif (!name || !v) {\n\t\treturn;\n\t}\n\tif (!*name || !strcmp (name , \"...\")) {\n\t\treturn;\n\t}\n\tbool is_default = (r_str_startswith (v->name, VARPREFIX)\n\t\t\t|| r_str_startswith (v->name, ARGPREFIX));\n\tif (*name == '*') {\n\t\tname++;\n\t}\n\t// longer name tends to be meaningful like \"src\" instead of \"s1\"\n\tif (!is_default && (strlen (v->name) > strlen (name))) {\n\t\treturn;\n\t}\n\tRAnalFunction *fcn = r_anal_get_fcn_in (anal, addr, 0);\n\tif (!fcn) {\n\t\treturn;\n\t}\n\tr_anal_var_rename (v, name, false);\n}\n\nstatic void __var_retype(RAnal *anal, RAnalVar *var, const char *vname, const char *type, bool ref, bool pfx) {\n\tr_return_if_fail (anal && var && type);\n\t// XXX types should be passed without spaces to trim\n\ttype = r_str_trim_head_ro (type);\n\t// default type if none is provided\n\tif (!*type) {\n\t\ttype = \"int\";\n\t}\n\tbool is_ptr = (vname && *vname == '*');\n\t// removing this return makes 64bit vars become 32bit\n\tif (!strncmp (type, \"int\", 3) || (!is_ptr && !strcmp (type, \"void\"))) {\n\t\t// default or void type\n\t\treturn;\n\t}\n\tconst char *expand = var->type;\n\tif (!strcmp (var->type, \"int32_t\")) {\n\t\texpand = \"int\";\n\t} else if (!strcmp (var->type, \"uint32_t\")) {\n\t\texpand = \"unsigned int\";\n\t} else if (!strcmp (var->type, \"uint64_t\")) {\n\t\texpand = \"unsigned long long\";\n\t}\n\tconst char *tmp = strstr (expand, \"int\");\n\tbool is_default = tmp != NULL;\n\tif (!is_default && strncmp (var->type, \"void\", 4)) {\n\t\t// return since type is already propagated\n\t\t// except for \"void *\", since \"void *\" => \"char *\" is possible\n\t\treturn;\n\t}\n\tRStrBuf *sb = r_strbuf_new (\"\");\n\tif (pfx) {\n\t\tif (is_default && strncmp (var->type, \"signed\", 6)) {\n\t\t\tr_strbuf_setf (sb, \"%s %s\", type, tmp);\n\t\t} else {\n\t\t\tr_strbuf_free (sb);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tr_strbuf_set (sb, type);\n\t}\n\tif (!strncmp (r_strbuf_get (sb), \"const \", 6)) {\n\t\t// Dropping const from type\n\t\t//TODO: Inferring const type\n\t\tr_strbuf_setf (sb, \"%s\", type + 6);\n\t}\n\tif (is_ptr) {\n\t\t//type *ptr => type *\n\t\tr_strbuf_append (sb, \" *\");\n\t}\n\tif (ref) {\n\t\tif (r_str_endswith (r_strbuf_get (sb), \"*\")) { // type * => type **\n\t\t\tr_strbuf_append (sb, \"*\");\n\t\t} else {   //  type => type *\n\t\t\tr_strbuf_append (sb, \" *\");\n\t\t}\n\t}\n\n\tchar* tmp1 = r_strbuf_get (sb);\n\tif (r_str_startswith (tmp1, \"unsigned long long\")) {\n\t\tr_strbuf_set (sb, \"uint64_t\");\n\t} else if (r_str_startswith (tmp1, \"unsigned\")) {\n\t\tr_strbuf_set (sb, \"uint32_t\");\n\t} else if (r_str_startswith (tmp1, \"int\")) {\n\t\tr_strbuf_set (sb, \"int32_t\");\n\t}\n\tr_anal_var_set_type (var, r_strbuf_get (sb));\n\tr_strbuf_free (sb);\n}\n\nstatic void get_src_regname(RCore *core, ut64 addr, char *regname, int size) {\n\tRAnal *anal = core->anal;\n\tRAnalOp *op = r_core_anal_op (core, addr, R_ANAL_OP_MASK_VAL | R_ANAL_OP_MASK_ESIL);\n\tif (!op || r_strbuf_is_empty (&op->esil)) {\n\t\tr_anal_op_free (op);\n\t\treturn;\n\t}\n\tchar *op_esil = strdup (r_strbuf_get (&op->esil));\n\tchar *tmp = strchr (op_esil, ',');\n\tif (tmp) {\n\t\t*tmp = '\\0';\n\t}\n\tmemset (regname, 0, size);\n\tRRegItem *ri = r_reg_get (anal->reg, op_esil, -1);\n\tif (ri) {\n\t\tif ((anal->bits == 64) && (ri->size == 32)) {\n\t\t\tconst char *reg = r_reg_32_to_64 (anal->reg, op_esil);\n\t\t\tif (reg) {\n\t\t\t\tfree (op_esil);\n\t\t\t\top_esil = strdup (reg);\n\t\t\t}\n\t\t}\n\t\tstrncpy (regname, op_esil, size - 1);\n\t}\n\tfree (op_esil);\n\tr_anal_op_free (op);\n}\n\nstatic ut64 get_addr(Sdb *trace, const char *regname, int idx) {\n\tif (!regname || !*regname) {\n\t\treturn UT64_MAX;\n\t}\n\tconst char *query = sdb_fmt (\"%d.reg.read.%s\", idx, regname);\n\treturn r_num_math (NULL, sdb_const_get (trace, query, 0));\n}\n\nstatic _RAnalCond cond_invert(RAnal *anal, _RAnalCond cond) {\n\tswitch (cond) {\n\tcase R_ANAL_COND_LE:\n\t\treturn R_ANAL_COND_GT;\n\tcase R_ANAL_COND_LT:\n\t\treturn R_ANAL_COND_GE;\n\tcase R_ANAL_COND_GE:\n\t\treturn R_ANAL_COND_LT;\n\tcase R_ANAL_COND_GT:\n\t\treturn R_ANAL_COND_LE;\n\tdefault:\n\t\tif (anal->verbose) {\n\t\t\teprintf (\"Unhandled conditional swap\\n\");\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0; // 0 is COND_ALways...\n\t/* I haven't looked into it but I suspect that this might be confusing:\n\tthe opposite of any condition not in the list above is \"always\"? */\n}\n\nstatic RList *parse_format(RCore *core, char *fmt) {\n\tif (!fmt || !*fmt) {\n\t\treturn NULL;\n\t}\n\tRList *ret = r_list_new ();\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tSdb *s = core->anal->sdb_fmts;\n\tconst char *spec = r_config_get (core->config, \"anal.types.spec\");\n\tchar arr[10] = {0};\n\tchar *ptr = strchr (fmt, '%');\n\tfmt[strlen (fmt) - 1] = '\\0';\n\twhile (ptr) {\n\t\tptr++;\n\t\t// strip [width] specifier\n\t\twhile (IS_DIGIT (*ptr)) {\n\t\t\tptr++;\n\t\t}\n\t\tr_str_ncpy (arr, ptr, sizeof (arr) - 1);\n\t\tchar *tmp = arr;\n\t\twhile (tmp && (IS_LOWER (*tmp) || IS_UPPER (*tmp))) {\n\t\t\ttmp++;\n\t\t}\n\t\t*tmp = '\\0';\n\t\tconst char *query = sdb_fmt (\"spec.%s.%s\", spec, arr);\n\t\tchar *type = (char *) sdb_const_get (s, query, 0);\n\t\tif (type) {\n\t\t\tr_list_append (ret, type);\n\t\t}\n\t\tptr = strchr (ptr, '%');\n\t}\n\treturn ret;\n}\n\nstatic void retype_callee_arg(RAnal *anal, const char *callee_name, bool in_stack, const char *place, int size, const char *type) {\n\tRAnalFunction *fcn = r_anal_get_function_byname (anal, callee_name);\n\tif (!fcn) {\n\t\treturn;\n\t}\n\tif (in_stack) {\n\t\tRAnalVar *var = r_anal_function_get_var (fcn, R_ANAL_VAR_KIND_BPV, size - fcn->bp_off + 8);\n\t\tif (!var) {\n\t\t\treturn;\n\t\t}\n\t\t__var_retype (anal, var, NULL, type, false, false);\n\t} else {\n\t\tRRegItem *item = r_reg_get (anal->reg, place, -1);\n\t\tif (!item) {\n\t\t\treturn;\n\t\t}\n\t\tRAnalVar *rvar = r_anal_function_get_var (fcn, R_ANAL_VAR_KIND_REG, item->index);\n\t\tif (!rvar) {\n\t\t\treturn;\n\t\t}\n\t\tchar *t = strdup (type);\n\t\t__var_retype (anal, rvar, NULL, type, false, false);\n\t\tRAnalVar *lvar = r_anal_var_get_dst_var (rvar);\n\t\tif (lvar) {\n\t\t\t__var_retype (anal, lvar, NULL, t, false, false);\n\t\t}\n\t\tfree (t);\n\t}\n}\n\n#define DEFAULT_MAX 3\n#define REGNAME_SIZE 10\n#define MAX_INSTR 5\n\n/**\n * type match at a call instruction inside another function\n *\n * \\param fcn_name name of the callee\n * \\param addr addr of the call instruction\n * \\param baddr addr of the caller function\n * \\param cc cc of the callee\n * \\param prev_idx index in the esil trace\n * \\param userfnc whether the callee is a user function (affects propagation direction)\n * \\param caddr addr of the callee\n */\nstatic void type_match(RCore *core, char *fcn_name, ut64 addr, ut64 baddr, const char* cc,\n\t\tint prev_idx, bool userfnc, ut64 caddr) {\n\tSdb *trace = core->anal->esil->trace->db;\n\tSdb *TDB = core->anal->sdb_types;\n\tRAnal *anal = core->anal;\n\tRList *types = NULL;\n\tint idx = sdb_num_get (trace, \"idx\", 0);\n\tbool verbose = r_config_get_i (core->config, \"anal.types.verbose\");\n\tbool stack_rev = false, in_stack = false, format = false;\n\n\tif (!fcn_name || !cc) {\n\t\treturn;\n\t}\n\tint i, j, pos = 0, size = 0, max = r_type_func_args_count (TDB, fcn_name);\n\tconst char *place = r_anal_cc_arg (anal, cc, ST32_MAX);\n\tr_cons_break_push (NULL, NULL);\n\n\tif (place && !strcmp (place, \"stack_rev\")) {\n\t\tstack_rev = true;\n\t}\n\tplace = r_anal_cc_arg (anal, cc, 0);\n\tif (place && r_str_startswith (\"stack\", place)) {\n\t\tin_stack = true;\n\t}\n\tif (verbose && !strncmp (fcn_name, \"sym.imp.\", 8)) {\n\t\teprintf (\"%s missing function definition\\n\", fcn_name + 8);\n\t}\n\tif (!max) {\n\t\tif (!in_stack) {\n\t\t\tmax = r_anal_cc_max_arg (anal, cc);\n\t\t} else {\n\t\t\tmax = DEFAULT_MAX;\n\t\t}\n\t}\n\tfor (i = 0; i < max; i++) {\n\t\tint arg_num = stack_rev ? (max - 1 - i) : i;\n\t\tchar *type = NULL;\n\t\tconst char *name = NULL;\n\t\tif (format) {\n\t\t\tif (r_list_empty (types)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttype = r_str_new (r_list_get_n (types, pos++));\n\t\t} else {\n\t\t\ttype = r_type_func_args_type (TDB, fcn_name, arg_num);\n\t\t\tname = r_type_func_args_name (TDB, fcn_name, arg_num);\n\t\t}\n\t\tif (!type && !userfnc) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!in_stack) {\n\t\t\t//XXX: param arg_num must be fixed to support floating point register\n\t\t\tplace = r_anal_cc_arg (anal, cc, arg_num);\n\t\t\tif (place && r_str_startswith (\"stack\", place)) {\n\t\t\t\tin_stack = true;\n\t\t\t}\n\t\t}\n\t\tchar regname[REGNAME_SIZE] = {0};\n\t\tut64 xaddr = UT64_MAX;\n\t\tbool memref = false;\n\t\tbool cmt_set = false;\n\t\tbool res = false;\n\t\t// Backtrace instruction from source sink to prev source sink\n\t\tfor (j = idx; j >= prev_idx; j--) {\n\t\t\tut64 instr_addr = sdb_num_get (trace, sdb_fmt (\"%d.addr\", j), 0);\n\t\t\tif (instr_addr < baddr) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRAnalOp *op = r_core_anal_op (core, instr_addr, R_ANAL_OP_MASK_BASIC | R_ANAL_OP_MASK_VAL);\n\t\t\tif (!op) {\n\t\t\t\tr_anal_op_free (op);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRAnalOp *next_op = r_core_anal_op (core, instr_addr + op->size, R_ANAL_OP_MASK_BASIC | R_ANAL_OP_MASK_VAL);\n\t\t\tif (!next_op || (j != idx && (next_op->type == R_ANAL_OP_TYPE_CALL\n\t\t\t\t\t\t\t|| next_op->type == R_ANAL_OP_TYPE_JMP))) {\n\t\t\t\tr_anal_op_free (op);\n\t\t\t\tr_anal_op_free (next_op);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRAnalVar *var = r_anal_get_used_function_var (anal, op->addr);\n\t\t\tconst char *query = sdb_fmt (\"%d.mem.read\", j);\n\t\t\tif (op->type == R_ANAL_OP_TYPE_MOV && sdb_const_get (trace, query, 0)) {\n\t\t\t\tmemref = ! (!memref && var && (var->kind != R_ANAL_VAR_KIND_REG));\n\t\t\t}\n\t\t\t// Match type from function param to instr\n\t\t\tif (type_pos_hit (anal, trace, in_stack, j, size, place)) {\n\t\t\t\tif (!cmt_set && type && name) {\n\t\t\t\t\tr_meta_set_string (anal, R_META_TYPE_VARTYPE, instr_addr,\n\t\t\t\t\t\t\tsdb_fmt (\"%s%s%s\", type, r_str_endswith (type, \"*\") ? \"\" : \" \", name));\n\t\t\t\t\tcmt_set = true;\n\t\t\t\t\tif ((op->ptr && op->ptr != UT64_MAX) && !strcmp (name, \"format\")) {\n\t\t\t\t\t\tRFlagItem *f = r_flag_get_by_spaces (core->flags, op->ptr, R_FLAGS_FS_STRINGS, NULL);\n\t\t\t\t\t\tif (f) {\n\t\t\t\t\t\t\tchar formatstr[0x200];\n\t\t\t\t\t\t\tint read = r_io_nread_at (core->io, f->offset, (ut8 *)formatstr, R_MIN (sizeof (formatstr) - 1, f->size));\n\t\t\t\t\t\t\tif (read > 0) {\n\t\t\t\t\t\t\t\tformatstr[read] = '\\0';\n\t\t\t\t\t\t\t\tif ((types = parse_format (core, formatstr))) {\n\t\t\t\t\t\t\t\t\tmax += r_list_length (types);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tformat = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (var) {\n\t\t\t\t\tif (!userfnc) {\n\t\t\t\t\t\t// not a userfunction, propagate the callee's arg types into our function's vars\n\t\t\t\t\t\t__var_retype (anal, var, name, type, memref, false);\n\t\t\t\t\t\t__var_rename (anal, var, name, addr);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// callee is a userfunction, propagate our variable's type into the callee's args\n\t\t\t\t\t\tretype_callee_arg (anal, fcn_name, in_stack, place, size, var->type);\n\t\t\t\t\t}\n\t\t\t\t\tres = true;\n\t\t\t\t} else {\n\t\t\t\t\tget_src_regname (core, instr_addr, regname, sizeof (regname));\n\t\t\t\t\txaddr = get_addr (trace, regname, j);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Type propagate by following source reg\n\t\t\tif (!res && *regname && SDB_CONTAINS (j, regname)) {\n\t\t\t\tif (var) {\n\t\t\t\t\tif (!userfnc) {\n\t\t\t\t\t\t// not a userfunction, propagate the callee's arg types into our function's vars\n\t\t\t\t\t\t__var_retype (anal, var, name, type, memref, false);\n\t\t\t\t\t\t__var_rename (anal, var, name, addr);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// callee is a userfunction, propagate our variable's type into the callee's args\n\t\t\t\t\t\tretype_callee_arg (anal, fcn_name, in_stack, place, size, var->type);\n\t\t\t\t\t}\n\t\t\t\t\tres = true;\n\t\t\t\t} else {\n\t\t\t\t\tswitch (op->type) {\n\t\t\t\t\tcase R_ANAL_OP_TYPE_MOV:\n\t\t\t\t\tcase R_ANAL_OP_TYPE_PUSH:\n\t\t\t\t\t\tget_src_regname (core, instr_addr, regname, sizeof (regname));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase R_ANAL_OP_TYPE_LEA:\n\t\t\t\t\tcase R_ANAL_OP_TYPE_LOAD:\n\t\t\t\t\tcase R_ANAL_OP_TYPE_STORE:\n\t\t\t\t\t\tres = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (var && res && xaddr && (xaddr != UT64_MAX)) { // Type progation using value\n\t\t\t\tchar tmp[REGNAME_SIZE] = {0};\n\t\t\t\tget_src_regname (core, instr_addr, tmp, sizeof (tmp));\n\t\t\t\tut64 ptr = get_addr (trace, tmp, j);\n\t\t\t\tif (ptr == xaddr) {\n\t\t\t\t\t__var_retype (anal, var, name, r_str_get_fail (type, \"int\"), memref, false);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_anal_op_free (op);\n\t\t\tr_anal_op_free (next_op);\n\t\t}\n\t\tsize += anal->bits / 8;\n\t\tfree (type);\n\t}\n\tr_list_free (types);\n\tr_cons_break_pop ();\n}\n\nstatic int bb_cmpaddr(const void *_a, const void *_b) {\n\tconst RAnalBlock *a = _a, *b = _b;\n\treturn a->addr > b->addr ? 1 : (a->addr < b->addr ? -1 : 0);\n}\n\nR_API void r_core_anal_type_match(RCore *core, RAnalFunction *fcn) {\n\tRAnalBlock *bb;\n\tRListIter *it;\n\tRAnalOp aop = {0};\n\tbool resolved = false;\n\n\tr_return_if_fail (core && core->anal && fcn);\n\n\tif (!core->anal->esil) {\n\t\teprintf (\"Please run aeim\\n\");\n\t\treturn;\n\t}\n\n\tRAnal *anal = core->anal;\n\tSdb *TDB = anal->sdb_types;\n\tbool chk_constraint = r_config_get_i (core->config, \"anal.types.constraint\");\n\tint ret, bsize = R_MAX (64, core->blocksize);\n\tconst int mininstrsz = r_anal_archinfo (anal, R_ANAL_ARCHINFO_MIN_OP_SIZE);\n\tconst int minopcode = R_MAX (1, mininstrsz);\n\tint cur_idx , prev_idx = 0;\n\tRConfigHold *hc = r_config_hold_new (core->config);\n\tif (!hc) {\n\t\treturn;\n\t}\n\tRDebugTrace *dt = NULL;\n\tRAnalEsilTrace *et = NULL;\n\tif (!anal_emul_init (core, hc, &dt, &et) || !fcn) {\n\t\tanal_emul_restore (core, hc, dt, et);\n\t\treturn;\n\t}\n\tut8 *buf = malloc (bsize);\n\tif (!buf) {\n\t\tanal_emul_restore (core, hc, dt, et);\n\t\treturn;\n\t}\n\n\t// Reserve bigger ht to avoid rehashing\n\tSdb *etracedb = core->anal->esil->trace->db;\n\tHtPPOptions opt = etracedb->ht->opt;\n\tht_pp_free (etracedb->ht);\n\tetracedb->ht = ht_pp_new_size (fcn->ninstr * 0xf, opt.dupvalue, opt.freefn, opt.calcsizeV);\n\tetracedb->ht->opt = opt;\n\tRDebugTrace *dtrace = core->dbg->trace;\n\topt = dtrace->ht->opt;\n\tht_pp_free (dtrace->ht);\n\tdtrace->ht = ht_pp_new_size (fcn->ninstr, opt.dupvalue, opt.freefn, opt.calcsizeV);\n\tdtrace->ht->opt = opt;\n\n\tchar *fcn_name = NULL;\n\tchar *ret_type = NULL;\n\tbool str_flag = false;\n\tbool prop = false;\n\tbool prev_var = false;\n\tchar prev_type[256] = {0};\n\tconst char *prev_dest = NULL;\n\tchar *ret_reg = NULL;\n\tconst char *pc = r_reg_get_name (core->dbg->reg, R_REG_NAME_PC);\n\tif (!pc) {\n        free (buf);\n\t\treturn;\n\t}\n\tRRegItem *r = r_reg_get (core->dbg->reg, pc, -1);\n\tif (!r) {\n\t\tfree (buf);\n\t\treturn;\n\t}\n\tr_cons_break_push (NULL, NULL);\n\tr_list_sort (fcn->bbs, bb_cmpaddr); // TODO: The algorithm can be more accurate if blocks are followed by their jmp/fail, not just by address\n\tr_list_foreach (fcn->bbs, it, bb) {\n\t\tut64 addr = bb->addr;\n\t\tint i = 0;\n\t\tr_reg_set_value (core->dbg->reg, r, addr);\n\t\twhile (1) {\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tgoto out_function;\n\t\t\t}\n\t\t\tif (i >= (bsize - 32)) {\n\t\t\t\ti = 0;\n\t\t\t}\n\t\t\tut64 pcval = r_reg_getv (anal->reg, pc);\n\t\t\tif ((addr >= bb->addr + bb->size) || (addr < bb->addr) || pcval != addr) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!i) {\n\t\t\t\tr_io_read_at (core->io, addr, buf, bsize);\n\t\t\t}\n\t\t\tret = r_anal_op (anal, &aop, addr, buf + i, bsize - i, R_ANAL_OP_MASK_BASIC | R_ANAL_OP_MASK_VAL);\n\t\t\tif (ret <= 0) {\n\t\t\t\ti += minopcode;\n\t\t\t\taddr += minopcode;\n\t\t\t\tr_anal_op_fini (&aop);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint loop_count = sdb_num_get (anal->esil->trace->db, sdb_fmt (\"0x%\"PFMT64x\".count\", addr), 0);\n\t\t\tif (loop_count > LOOP_MAX || aop.type == R_ANAL_OP_TYPE_RET) {\n\t\t\t\tr_anal_op_fini (&aop);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsdb_num_set (anal->esil->trace->db, sdb_fmt (\"0x%\"PFMT64x\".count\", addr), loop_count + 1, 0);\n\t\t\tif (r_anal_op_nonlinear (aop.type)) {   // skip the instr\n\t\t\t\tr_reg_set_value (core->dbg->reg, r, addr + ret);\n\t\t\t} else {\n\t\t\t\tr_core_esil_step (core, UT64_MAX, NULL, NULL, false);\n\t\t\t}\n\t\t\tbool userfnc = false;\n\t\t\tSdb *trace = anal->esil->trace->db;\n\t\t\tcur_idx = sdb_num_get (trace, \"idx\", 0);\n\t\t\tRAnalVar *var = r_anal_get_used_function_var (anal, aop.addr);\n\t\t\tRAnalOp *next_op = r_core_anal_op (core, addr + ret, R_ANAL_OP_MASK_BASIC); // | _VAL ?\n\t\t\tut32 type = aop.type & R_ANAL_OP_TYPE_MASK;\n\t\t\tif (aop.type == R_ANAL_OP_TYPE_CALL || aop.type & R_ANAL_OP_TYPE_UCALL) {\n\t\t\t\tchar *full_name = NULL;\n\t\t\t\tut64 callee_addr;\n\t\t\t\tif (aop.type == R_ANAL_OP_TYPE_CALL) {\n\t\t\t\t\tRAnalFunction *fcn_call = r_anal_get_fcn_in (anal, aop.jump, -1);\n\t\t\t\t\tif (fcn_call) {\n\t\t\t\t\t\tfull_name = fcn_call->name;\n\t\t\t\t\t\tcallee_addr = fcn_call->addr;\n\t\t\t\t\t}\n\t\t\t\t} else if (aop.ptr != UT64_MAX) {\n\t\t\t\t\tRFlagItem *flag = r_flag_get_by_spaces (core->flags, aop.ptr, R_FLAGS_FS_IMPORTS, NULL);\n\t\t\t\t\tif (flag && flag->realname) {\n\t\t\t\t\t\tfull_name = flag->realname;\n\t\t\t\t\t\tcallee_addr = aop.ptr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (full_name) {\n\t\t\t\t\tif (r_type_func_exist (TDB, full_name)) {\n\t\t\t\t\t\tfcn_name = strdup (full_name);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfcn_name = r_type_func_guess (TDB, full_name);\n\t\t\t\t\t}\n\t\t\t\t\tif (!fcn_name) {\n\t\t\t\t\t\tfcn_name = strdup (full_name);\n\t\t\t\t\t\tuserfnc = true;\n\t\t\t\t\t}\n\t\t\t\t\tconst char* Cc = r_anal_cc_func (anal, fcn_name);\n\t\t\t\t\tif (Cc && r_anal_cc_exist (anal, Cc)) {\n\t\t\t\t\t\tchar *cc = strdup (Cc);\n\t\t\t\t\t\ttype_match (core, fcn_name, addr, bb->addr, cc, prev_idx, userfnc, callee_addr);\n\t\t\t\t\t\tprev_idx = cur_idx;\n\t\t\t\t\t\tR_FREE (ret_type);\n\t\t\t\t\t\tconst char *rt = r_type_func_ret (TDB, fcn_name);\n\t\t\t\t\t\tif (rt) {\n\t\t\t\t\t\t\tret_type = strdup (rt);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tR_FREE (ret_reg);\n\t\t\t\t\t\tconst char *rr = r_anal_cc_ret (anal, cc);\n\t\t\t\t\t\tif (rr) {\n\t\t\t\t\t\t\tret_reg = strdup (rr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresolved = false;\n\t\t\t\t\t\tfree (cc);\n\t\t\t\t\t}\n\t\t\t\t\tif (!strcmp (fcn_name, \"__stack_chk_fail\")) {\n\t\t\t\t\t\tconst char *query = sdb_fmt (\"%d.addr\", cur_idx - 1);\n\t\t\t\t\t\tut64 mov_addr = sdb_num_get (trace, query, 0);\n\t\t\t\t\t\tRAnalOp *mop = r_core_anal_op (core, mov_addr, R_ANAL_OP_MASK_VAL | R_ANAL_OP_MASK_BASIC);\n\t\t\t\t\t\tif (mop) {\n\t\t\t\t\t\t\tRAnalVar *mopvar = r_anal_get_used_function_var (anal, mop->addr);\n\t\t\t\t\t\t\tut32 type = mop->type & R_ANAL_OP_TYPE_MASK;\n\t\t\t\t\t\t\tif (type == R_ANAL_OP_TYPE_MOV) {\n\t\t\t\t\t\t\t\t__var_rename (anal, mopvar, \"canary\", addr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_anal_op_free (mop);\n\t\t\t\t\t}\n\t\t\t\t\tfree (fcn_name);\n\t\t\t\t}\n\t\t\t} else if (!resolved && ret_type && ret_reg) {\n\t\t\t\t// Forward propgation of function return type\n\t\t\t\tchar src[REGNAME_SIZE] = {0};\n\t\t\t\tconst char *query = sdb_fmt (\"%d.reg.write\", cur_idx);\n\t\t\t\tconst char *cur_dest = sdb_const_get (trace, query, 0);\n\t\t\t\tget_src_regname (core, aop.addr, src, sizeof (src));\n\t\t\t\tif (ret_reg && *src && strstr (ret_reg, src)) {\n\t\t\t\t\tif (var && aop.direction == R_ANAL_OP_DIR_WRITE) {\n\t\t\t\t\t\t__var_retype (anal, var, NULL, ret_type, false, false);\n\t\t\t\t\t\tresolved = true;\n\t\t\t\t\t} else if (type == R_ANAL_OP_TYPE_MOV) {\n\t\t\t\t\t\tR_FREE (ret_reg);\n\t\t\t\t\t\tif (cur_dest) {\n\t\t\t\t\t\t\tret_reg = strdup (cur_dest);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (cur_dest) {\n\t\t\t\t\tchar *foo = strdup (cur_dest);\n\t\t\t\t\tchar *tmp = strchr (foo, ',');\n\t\t\t\t\tif (tmp) {\n\t\t\t\t\t\t*tmp++ = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tif (ret_reg && (strstr (ret_reg, foo) || (tmp && strstr (ret_reg, tmp)))) {\n\t\t\t\t\t\tresolved = true;\n\t\t\t\t\t} else if (type == R_ANAL_OP_TYPE_MOV &&\n\t\t\t\t\t\t\t(next_op && next_op->type == R_ANAL_OP_TYPE_MOV)){\n\t\t\t\t\t\t// Progate return type passed using pointer\n\t\t\t\t\t\t// int *ret; *ret = strlen(s);\n\t\t\t\t\t\t// TODO: memref check , dest and next src match\n\t\t\t\t\t\tchar nsrc[REGNAME_SIZE] = {0};\n\t\t\t\t\t\tget_src_regname (core, next_op->addr, nsrc, sizeof (nsrc));\n\t\t\t\t\t\tif (ret_reg && *nsrc && strstr (ret_reg, nsrc) && var &&\n\t\t\t\t\t\t\t\taop.direction == R_ANAL_OP_DIR_READ) {\n\t\t\t\t\t\t\t__var_retype (anal, var, NULL, ret_type, true, false);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree (foo);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Type propagation using instruction access pattern\n\t\t\tif (var) {\n\t\t\t\tbool sign = false;\n\t\t\t\tif ((type == R_ANAL_OP_TYPE_CMP) && next_op) {\n\t\t\t\t\tif (next_op->sign) {\n\t\t\t\t\t\tsign = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// cmp [local_ch], rax ; jb\n\t\t\t\t\t\t__var_retype (anal, var, NULL, \"unsigned\", false, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// cmp [local_ch], rax ; jge\n\t\t\t\tif (sign || aop.sign) {\n\t\t\t\t\t__var_retype (anal, var, NULL, \"signed\", false, true);\n\t\t\t\t}\n\t\t\t\t// lea rax , str.hello  ; mov [local_ch], rax;\n\t\t\t\t// mov rdx , [local_4h] ; mov [local_8h], rdx;\n\t\t\t\tif (prev_dest && (type == R_ANAL_OP_TYPE_MOV || type == R_ANAL_OP_TYPE_STORE)) {\n\t\t\t\t\tchar reg[REGNAME_SIZE] = {0};\n\t\t\t\t\tget_src_regname (core, addr, reg, sizeof (reg));\n\t\t\t\t\tbool match = strstr (prev_dest, reg) != NULL;\n\t\t\t\t\tif (str_flag && match) {\n\t\t\t\t\t\t__var_retype (anal, var, NULL, \"const char *\", false, false);\n\t\t\t\t\t}\n\t\t\t\t\tif (prop && match && prev_var) {\n\t\t\t\t\t\t__var_retype (anal, var, NULL, prev_type, false, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (chk_constraint && var && (type == R_ANAL_OP_TYPE_CMP && aop.disp != UT64_MAX)\n\t\t\t\t\t\t&& next_op && next_op->type == R_ANAL_OP_TYPE_CJMP) {\n\t\t\t\t\tbool jmp = false;\n\t\t\t\t\tRAnalOp *jmp_op = {0};\n\t\t\t\t\tut64 jmp_addr = next_op->jump;\n\t\t\t\t\tRAnalBlock *jmpbb = r_anal_fcn_bbget_in (anal, fcn, jmp_addr);\n\n\t\t\t\t\t// Check exit status of jmp branch\n\t\t\t\t\tfor (i = 0; i < MAX_INSTR ; i++) {\n\t\t\t\t\t\tjmp_op = r_core_anal_op (core, jmp_addr, R_ANAL_OP_MASK_BASIC);\n\t\t\t\t\t\tif (!jmp_op) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ((jmp_op->type == R_ANAL_OP_TYPE_RET && r_anal_block_contains (jmpbb, jmp_addr))\n\t\t\t\t\t\t\t\t|| jmp_op->type == R_ANAL_OP_TYPE_CJMP) {\n\t\t\t\t\t\t\tjmp = true;\n\t\t\t\t\t\t\tr_anal_op_free (jmp_op);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tjmp_addr += jmp_op->size;\n\t\t\t\t\t\tr_anal_op_free (jmp_op);\n\t\t\t\t\t}\n\t\t\t\t\tRAnalVarConstraint constr = {\n\t\t\t\t\t\t.cond = jmp? cond_invert (anal, next_op->cond): next_op->cond,\n\t\t\t\t\t\t.val = aop.val\n\t\t\t\t\t};\n\t\t\t\t\tr_anal_var_add_constraint (var, &constr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprev_var = (var && aop.direction == R_ANAL_OP_DIR_READ);\n\t\t\tstr_flag = false;\n\t\t\tprop = false;\n\t\t\tprev_dest = NULL;\n\t\t\tswitch (type) {\n\t\t\tcase R_ANAL_OP_TYPE_MOV:\n\t\t\tcase R_ANAL_OP_TYPE_LEA:\n\t\t\tcase R_ANAL_OP_TYPE_LOAD:\n\t\t\t\tif (aop.ptr && aop.refptr && aop.ptr != UT64_MAX) {\n\t\t\t\t\tif (type == R_ANAL_OP_TYPE_LOAD) {\n\t\t\t\t\t\tut8 buf[256] = {0};\n\t\t\t\t\t\tr_io_read_at (core->io, aop.ptr, buf, sizeof (buf) - 1);\n\t\t\t\t\t\tut64 ptr = r_read_ble (buf, core->print->big_endian, aop.refptr * 8);\n\t\t\t\t\t\tif (ptr && ptr != UT64_MAX) {\n\t\t\t\t\t\t\tRFlagItem *f = r_flag_get_by_spaces (core->flags, ptr, R_FLAGS_FS_STRINGS, NULL);\n\t\t\t\t\t\t\tif (f) {\n\t\t\t\t\t\t\t\tstr_flag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (r_flag_exist_at (core->flags, \"str\", 3, aop.ptr)) {\n\t\t\t\t\t\tstr_flag = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// mov dword [local_4h], str.hello;\n\t\t\t\tif (var && str_flag) {\n\t\t\t\t\t__var_retype (anal, var, NULL, \"const char *\", false, false);\n\t\t\t\t}\n\t\t\t\tconst char *query = sdb_fmt (\"%d.reg.write\", cur_idx);\n\t\t\t\tprev_dest = sdb_const_get (trace, query, 0);\n\t\t\t\tif (var) {\n\t\t\t\t\tstrncpy (prev_type, var->type, sizeof (prev_type) - 1);\n\t\t\t\t\tprop = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti += ret;\n\t\t\taddr += ret;\n\t\t\tr_anal_op_free (next_op);\n\t\t\tr_anal_op_fini (&aop);\n\n\t\t}\n\t}\n\t// Type propgation for register based args\n\tRList *list = r_anal_var_list (anal, fcn, R_ANAL_VAR_KIND_REG);\n\tRAnalVar *rvar;\n\tRListIter *iter;\n\tr_list_foreach (list, iter, rvar) {\n\t\tRAnalVar *lvar = r_anal_var_get_dst_var (rvar);\n\t\tRRegItem *i = r_reg_index_get (anal->reg, rvar->delta);\n\t\tif (!i) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (lvar) {\n\t\t\t// Propagate local var type = to => register-based var\n\t\t\t__var_retype (anal, rvar, NULL, lvar->type, false, false);\n\t\t\t// Propagate local var type <= from = register-based var\n\t\t\t__var_retype (anal, lvar, NULL, rvar->type, false, false);\n\t\t}\n\t}\n\tr_list_free (list);\nout_function:\n\tR_FREE (ret_reg);\n\tR_FREE (ret_type);\n\tfree (buf);\n\tr_cons_break_pop();\n\tanal_emul_restore (core, hc, dt, et);\n}\n"], "fixing_code": ["/* radare - LGPL - Copyright 2016-2020 - oddcoder, sivaramaaa */\n/* type matching - type propagation */\n\n#include <r_anal.h>\n#include <r_util.h>\n#include <r_core.h>\n#define LOOP_MAX 10\n\nstatic bool anal_emul_init(RCore *core, RConfigHold *hc, RDebugTrace **dt, RAnalEsilTrace **et) {\n\tif (!core->anal->esil) {\n\t\treturn false;\n\t}\n\t*dt = core->dbg->trace;\n\t*et = core->anal->esil->trace;\n\tcore->dbg->trace = r_debug_trace_new ();\n\tcore->anal->esil->trace = r_anal_esil_trace_new (core->anal->esil);\n\tr_config_hold (hc, \"esil.romem\", \"dbg.trace\", \"esil.nonull\", \"dbg.follow\", NULL);\n\tr_config_set (core->config, \"esil.romem\", \"true\");\n\tr_config_set (core->config, \"dbg.trace\", \"true\");\n\tr_config_set (core->config, \"esil.nonull\", \"true\");\n\tr_config_set_i (core->config, \"dbg.follow\", false);\n\tconst char *bp = r_reg_get_name (core->anal->reg, R_REG_NAME_BP);\n\tconst char *sp = r_reg_get_name (core->anal->reg, R_REG_NAME_SP);\n\tif ((bp && !r_reg_getv (core->anal->reg, bp)) && (sp && !r_reg_getv (core->anal->reg, sp))) {\n\t\teprintf (\"Stack isn't initialized.\\n\");\n\t\teprintf (\"Try running aei and aeim commands before aft for default stack initialization\\n\");\n\t\treturn false;\n\t}\n\treturn (core->dbg->trace && core->anal->esil->trace);\n}\n\nstatic void anal_emul_restore(RCore *core, RConfigHold *hc, RDebugTrace *dt, RAnalEsilTrace *et) {\n\tr_config_hold_restore (hc);\n\tr_config_hold_free (hc);\n\tr_debug_trace_free (core->dbg->trace);\n\tr_anal_esil_trace_free (core->anal->esil->trace);\n\tcore->anal->esil->trace = et;\n\tcore->dbg->trace = dt;\n}\n\n#define SDB_CONTAINS(i,s) sdb_array_contains (trace, sdb_fmt (\"%d.reg.write\", i), s, 0)\n\nstatic bool type_pos_hit(RAnal *anal, Sdb *trace, bool in_stack, int idx, int size, const char *place) {\n\tif (in_stack) {\n\t\tconst char *sp_name = r_reg_get_name (anal->reg, R_REG_NAME_SP);\n\t\tut64 sp = r_reg_getv (anal->reg, sp_name);\n\t\tut64 write_addr = sdb_num_get (trace, sdb_fmt (\"%d.mem.write\", idx), 0);\n\t\treturn (write_addr == sp + size);\n\t}\n\treturn SDB_CONTAINS (idx, place);\n}\n\nstatic void __var_rename(RAnal *anal, RAnalVar *v, const char *name, ut64 addr) {\n\tif (!name || !v) {\n\t\treturn;\n\t}\n\tif (!*name || !strcmp (name , \"...\")) {\n\t\treturn;\n\t}\n\tbool is_default = (r_str_startswith (v->name, VARPREFIX)\n\t\t\t|| r_str_startswith (v->name, ARGPREFIX));\n\tif (*name == '*') {\n\t\tname++;\n\t}\n\t// longer name tends to be meaningful like \"src\" instead of \"s1\"\n\tif (!is_default && (strlen (v->name) > strlen (name))) {\n\t\treturn;\n\t}\n\tRAnalFunction *fcn = r_anal_get_fcn_in (anal, addr, 0);\n\tif (!fcn) {\n\t\treturn;\n\t}\n\tr_anal_var_rename (v, name, false);\n}\n\nstatic void __var_retype(RAnal *anal, RAnalVar *var, const char *vname, const char *type, bool ref, bool pfx) {\n\tr_return_if_fail (anal && var && type);\n\t// XXX types should be passed without spaces to trim\n\ttype = r_str_trim_head_ro (type);\n\t// default type if none is provided\n\tif (!*type) {\n\t\ttype = \"int\";\n\t}\n\tbool is_ptr = (vname && *vname == '*');\n\t// removing this return makes 64bit vars become 32bit\n\tif (!strncmp (type, \"int\", 3) || (!is_ptr && !strcmp (type, \"void\"))) {\n\t\t// default or void type\n\t\treturn;\n\t}\n\tconst char *expand = var->type;\n\tif (!strcmp (var->type, \"int32_t\")) {\n\t\texpand = \"int\";\n\t} else if (!strcmp (var->type, \"uint32_t\")) {\n\t\texpand = \"unsigned int\";\n\t} else if (!strcmp (var->type, \"uint64_t\")) {\n\t\texpand = \"unsigned long long\";\n\t}\n\tconst char *tmp = strstr (expand, \"int\");\n\tbool is_default = tmp != NULL;\n\tif (!is_default && strncmp (var->type, \"void\", 4)) {\n\t\t// return since type is already propagated\n\t\t// except for \"void *\", since \"void *\" => \"char *\" is possible\n\t\treturn;\n\t}\n\tRStrBuf *sb = r_strbuf_new (\"\");\n\tif (pfx) {\n\t\tif (is_default && strncmp (var->type, \"signed\", 6)) {\n\t\t\tr_strbuf_setf (sb, \"%s %s\", type, tmp);\n\t\t} else {\n\t\t\tr_strbuf_free (sb);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tr_strbuf_set (sb, type);\n\t}\n\tif (!strncmp (r_strbuf_get (sb), \"const \", 6)) {\n\t\t// Dropping const from type\n\t\t//TODO: Inferring const type\n\t\tr_strbuf_setf (sb, \"%s\", type + 6);\n\t}\n\tif (is_ptr) {\n\t\t//type *ptr => type *\n\t\tr_strbuf_append (sb, \" *\");\n\t}\n\tif (ref) {\n\t\tif (r_str_endswith (r_strbuf_get (sb), \"*\")) { // type * => type **\n\t\t\tr_strbuf_append (sb, \"*\");\n\t\t} else {   //  type => type *\n\t\t\tr_strbuf_append (sb, \" *\");\n\t\t}\n\t}\n\n\tchar* tmp1 = r_strbuf_get (sb);\n\tif (r_str_startswith (tmp1, \"unsigned long long\")) {\n\t\tr_strbuf_set (sb, \"uint64_t\");\n\t} else if (r_str_startswith (tmp1, \"unsigned\")) {\n\t\tr_strbuf_set (sb, \"uint32_t\");\n\t} else if (r_str_startswith (tmp1, \"int\")) {\n\t\tr_strbuf_set (sb, \"int32_t\");\n\t}\n\tr_anal_var_set_type (var, r_strbuf_get (sb));\n\tr_strbuf_free (sb);\n}\n\nstatic void get_src_regname(RCore *core, ut64 addr, char *regname, int size) {\n\tRAnal *anal = core->anal;\n\tRAnalOp *op = r_core_anal_op (core, addr, R_ANAL_OP_MASK_VAL | R_ANAL_OP_MASK_ESIL);\n\tif (!op || r_strbuf_is_empty (&op->esil)) {\n\t\tr_anal_op_free (op);\n\t\treturn;\n\t}\n\tchar *op_esil = strdup (r_strbuf_get (&op->esil));\n\tchar *tmp = strchr (op_esil, ',');\n\tif (tmp) {\n\t\t*tmp = '\\0';\n\t}\n\tmemset (regname, 0, size);\n\tRRegItem *ri = r_reg_get (anal->reg, op_esil, -1);\n\tif (ri) {\n\t\tif ((anal->bits == 64) && (ri->size == 32)) {\n\t\t\tconst char *reg = r_reg_32_to_64 (anal->reg, op_esil);\n\t\t\tif (reg) {\n\t\t\t\tfree (op_esil);\n\t\t\t\top_esil = strdup (reg);\n\t\t\t}\n\t\t}\n\t\tstrncpy (regname, op_esil, size - 1);\n\t}\n\tfree (op_esil);\n\tr_anal_op_free (op);\n}\n\nstatic ut64 get_addr(Sdb *trace, const char *regname, int idx) {\n\tif (!regname || !*regname) {\n\t\treturn UT64_MAX;\n\t}\n\tconst char *query = sdb_fmt (\"%d.reg.read.%s\", idx, regname);\n\treturn r_num_math (NULL, sdb_const_get (trace, query, 0));\n}\n\nstatic _RAnalCond cond_invert(RAnal *anal, _RAnalCond cond) {\n\tswitch (cond) {\n\tcase R_ANAL_COND_LE:\n\t\treturn R_ANAL_COND_GT;\n\tcase R_ANAL_COND_LT:\n\t\treturn R_ANAL_COND_GE;\n\tcase R_ANAL_COND_GE:\n\t\treturn R_ANAL_COND_LT;\n\tcase R_ANAL_COND_GT:\n\t\treturn R_ANAL_COND_LE;\n\tdefault:\n\t\tif (anal->verbose) {\n\t\t\teprintf (\"Unhandled conditional swap\\n\");\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0; // 0 is COND_ALways...\n\t/* I haven't looked into it but I suspect that this might be confusing:\n\tthe opposite of any condition not in the list above is \"always\"? */\n}\n\nstatic RList *parse_format(RCore *core, char *fmt) {\n\tif (!fmt || !*fmt) {\n\t\treturn NULL;\n\t}\n\tRList *ret = r_list_new ();\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tSdb *s = core->anal->sdb_fmts;\n\tconst char *spec = r_config_get (core->config, \"anal.types.spec\");\n\tchar arr[10] = {0};\n\tchar *ptr = strchr (fmt, '%');\n\tfmt[strlen (fmt) - 1] = '\\0';\n\twhile (ptr) {\n\t\tptr++;\n\t\t// strip [width] specifier\n\t\twhile (IS_DIGIT (*ptr)) {\n\t\t\tptr++;\n\t\t}\n\t\tr_str_ncpy (arr, ptr, sizeof (arr) - 1);\n\t\tchar *tmp = arr;\n\t\twhile (tmp && (IS_LOWER (*tmp) || IS_UPPER (*tmp))) {\n\t\t\ttmp++;\n\t\t}\n\t\t*tmp = '\\0';\n\t\tconst char *query = sdb_fmt (\"spec.%s.%s\", spec, arr);\n\t\tchar *type = (char *) sdb_const_get (s, query, 0);\n\t\tif (type) {\n\t\t\tr_list_append (ret, type);\n\t\t}\n\t\tptr = strchr (ptr, '%');\n\t}\n\treturn ret;\n}\n\nstatic void retype_callee_arg(RAnal *anal, const char *callee_name, bool in_stack, const char *place, int size, const char *type) {\n\tRAnalFunction *fcn = r_anal_get_function_byname (anal, callee_name);\n\tif (!fcn) {\n\t\treturn;\n\t}\n\tif (in_stack) {\n\t\tRAnalVar *var = r_anal_function_get_var (fcn, R_ANAL_VAR_KIND_BPV, size - fcn->bp_off + 8);\n\t\tif (!var) {\n\t\t\treturn;\n\t\t}\n\t\t__var_retype (anal, var, NULL, type, false, false);\n\t} else {\n\t\tRRegItem *item = r_reg_get (anal->reg, place, -1);\n\t\tif (!item) {\n\t\t\treturn;\n\t\t}\n\t\tRAnalVar *rvar = r_anal_function_get_var (fcn, R_ANAL_VAR_KIND_REG, item->index);\n\t\tif (!rvar) {\n\t\t\treturn;\n\t\t}\n\t\tchar *t = strdup (type);\n\t\t__var_retype (anal, rvar, NULL, type, false, false);\n\t\tRAnalVar *lvar = r_anal_var_get_dst_var (rvar);\n\t\tif (lvar) {\n\t\t\t__var_retype (anal, lvar, NULL, t, false, false);\n\t\t}\n\t\tfree (t);\n\t}\n}\n\n#define DEFAULT_MAX 3\n#define REGNAME_SIZE 10\n#define MAX_INSTR 5\n\n/**\n * type match at a call instruction inside another function\n *\n * \\param fcn_name name of the callee\n * \\param addr addr of the call instruction\n * \\param baddr addr of the caller function\n * \\param cc cc of the callee\n * \\param prev_idx index in the esil trace\n * \\param userfnc whether the callee is a user function (affects propagation direction)\n * \\param caddr addr of the callee\n */\nstatic void type_match(RCore *core, char *fcn_name, ut64 addr, ut64 baddr, const char* cc,\n\t\tint prev_idx, bool userfnc, ut64 caddr) {\n\tSdb *trace = core->anal->esil->trace->db;\n\tSdb *TDB = core->anal->sdb_types;\n\tRAnal *anal = core->anal;\n\tRList *types = NULL;\n\tint idx = sdb_num_get (trace, \"idx\", 0);\n\tbool verbose = r_config_get_i (core->config, \"anal.types.verbose\");\n\tbool stack_rev = false, in_stack = false, format = false;\n\n\tif (!fcn_name || !cc) {\n\t\treturn;\n\t}\n\tint i, j, pos = 0, size = 0, max = r_type_func_args_count (TDB, fcn_name);\n\tconst char *place = r_anal_cc_arg (anal, cc, ST32_MAX);\n\tr_cons_break_push (NULL, NULL);\n\n\tif (place && !strcmp (place, \"stack_rev\")) {\n\t\tstack_rev = true;\n\t}\n\tplace = r_anal_cc_arg (anal, cc, 0);\n\tif (place && r_str_startswith (\"stack\", place)) {\n\t\tin_stack = true;\n\t}\n\tif (verbose && !strncmp (fcn_name, \"sym.imp.\", 8)) {\n\t\teprintf (\"%s missing function definition\\n\", fcn_name + 8);\n\t}\n\tif (!max) {\n\t\tif (!in_stack) {\n\t\t\tmax = r_anal_cc_max_arg (anal, cc);\n\t\t} else {\n\t\t\tmax = DEFAULT_MAX;\n\t\t}\n\t}\n\tfor (i = 0; i < max; i++) {\n\t\tint arg_num = stack_rev ? (max - 1 - i) : i;\n\t\tchar *type = NULL;\n\t\tconst char *name = NULL;\n\t\tif (format) {\n\t\t\tif (r_list_empty (types)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttype = r_str_new (r_list_get_n (types, pos++));\n\t\t} else {\n\t\t\ttype = r_type_func_args_type (TDB, fcn_name, arg_num);\n\t\t\tname = r_type_func_args_name (TDB, fcn_name, arg_num);\n\t\t}\n\t\tif (!type && !userfnc) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!in_stack) {\n\t\t\t//XXX: param arg_num must be fixed to support floating point register\n\t\t\tplace = r_anal_cc_arg (anal, cc, arg_num);\n\t\t\tif (place && r_str_startswith (\"stack\", place)) {\n\t\t\t\tin_stack = true;\n\t\t\t}\n\t\t}\n\t\tchar regname[REGNAME_SIZE] = {0};\n\t\tut64 xaddr = UT64_MAX;\n\t\tbool memref = false;\n\t\tbool cmt_set = false;\n\t\tbool res = false;\n\t\t// Backtrace instruction from source sink to prev source sink\n\t\tfor (j = idx; j >= prev_idx; j--) {\n\t\t\tut64 instr_addr = sdb_num_get (trace, sdb_fmt (\"%d.addr\", j), 0);\n\t\t\tif (instr_addr < baddr) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRAnalOp *op = r_core_anal_op (core, instr_addr, R_ANAL_OP_MASK_BASIC | R_ANAL_OP_MASK_VAL);\n\t\t\tif (!op) {\n\t\t\t\tr_anal_op_free (op);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRAnalOp *next_op = r_core_anal_op (core, instr_addr + op->size, R_ANAL_OP_MASK_BASIC | R_ANAL_OP_MASK_VAL);\n\t\t\tif (!next_op || (j != idx && (next_op->type == R_ANAL_OP_TYPE_CALL\n\t\t\t\t\t\t\t|| next_op->type == R_ANAL_OP_TYPE_JMP))) {\n\t\t\t\tr_anal_op_free (op);\n\t\t\t\tr_anal_op_free (next_op);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRAnalVar *var = r_anal_get_used_function_var (anal, op->addr);\n\t\t\tconst char *query = sdb_fmt (\"%d.mem.read\", j);\n\t\t\tif (op->type == R_ANAL_OP_TYPE_MOV && sdb_const_get (trace, query, 0)) {\n\t\t\t\tmemref = ! (!memref && var && (var->kind != R_ANAL_VAR_KIND_REG));\n\t\t\t}\n\t\t\t// Match type from function param to instr\n\t\t\tif (type_pos_hit (anal, trace, in_stack, j, size, place)) {\n\t\t\t\tif (!cmt_set && type && name) {\n\t\t\t\t\tr_meta_set_string (anal, R_META_TYPE_VARTYPE, instr_addr,\n\t\t\t\t\t\t\tsdb_fmt (\"%s%s%s\", type, r_str_endswith (type, \"*\") ? \"\" : \" \", name));\n\t\t\t\t\tcmt_set = true;\n\t\t\t\t\tif ((op->ptr && op->ptr != UT64_MAX) && !strcmp (name, \"format\")) {\n\t\t\t\t\t\tRFlagItem *f = r_flag_get_by_spaces (core->flags, op->ptr, R_FLAGS_FS_STRINGS, NULL);\n\t\t\t\t\t\tif (f) {\n\t\t\t\t\t\t\tchar formatstr[0x200];\n\t\t\t\t\t\t\tint read = r_io_nread_at (core->io, f->offset, (ut8 *)formatstr, R_MIN (sizeof (formatstr) - 1, f->size));\n\t\t\t\t\t\t\tif (read > 0) {\n\t\t\t\t\t\t\t\tformatstr[read] = '\\0';\n\t\t\t\t\t\t\t\tif ((types = parse_format (core, formatstr))) {\n\t\t\t\t\t\t\t\t\tmax += r_list_length (types);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tformat = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (var) {\n\t\t\t\t\tif (!userfnc) {\n\t\t\t\t\t\t// not a userfunction, propagate the callee's arg types into our function's vars\n\t\t\t\t\t\t__var_retype (anal, var, name, type, memref, false);\n\t\t\t\t\t\t__var_rename (anal, var, name, addr);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// callee is a userfunction, propagate our variable's type into the callee's args\n\t\t\t\t\t\tretype_callee_arg (anal, fcn_name, in_stack, place, size, var->type);\n\t\t\t\t\t}\n\t\t\t\t\tres = true;\n\t\t\t\t} else {\n\t\t\t\t\tget_src_regname (core, instr_addr, regname, sizeof (regname));\n\t\t\t\t\txaddr = get_addr (trace, regname, j);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Type propagate by following source reg\n\t\t\tif (!res && *regname && SDB_CONTAINS (j, regname)) {\n\t\t\t\tif (var) {\n\t\t\t\t\tif (!userfnc) {\n\t\t\t\t\t\t// not a userfunction, propagate the callee's arg types into our function's vars\n\t\t\t\t\t\t__var_retype (anal, var, name, type, memref, false);\n\t\t\t\t\t\t__var_rename (anal, var, name, addr);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// callee is a userfunction, propagate our variable's type into the callee's args\n\t\t\t\t\t\tretype_callee_arg (anal, fcn_name, in_stack, place, size, var->type);\n\t\t\t\t\t}\n\t\t\t\t\tres = true;\n\t\t\t\t} else {\n\t\t\t\t\tswitch (op->type) {\n\t\t\t\t\tcase R_ANAL_OP_TYPE_MOV:\n\t\t\t\t\tcase R_ANAL_OP_TYPE_PUSH:\n\t\t\t\t\t\tget_src_regname (core, instr_addr, regname, sizeof (regname));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase R_ANAL_OP_TYPE_LEA:\n\t\t\t\t\tcase R_ANAL_OP_TYPE_LOAD:\n\t\t\t\t\tcase R_ANAL_OP_TYPE_STORE:\n\t\t\t\t\t\tres = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (var && res && xaddr && (xaddr != UT64_MAX)) { // Type progation using value\n\t\t\t\tchar tmp[REGNAME_SIZE] = {0};\n\t\t\t\tget_src_regname (core, instr_addr, tmp, sizeof (tmp));\n\t\t\t\tut64 ptr = get_addr (trace, tmp, j);\n\t\t\t\tif (ptr == xaddr) {\n\t\t\t\t\t__var_retype (anal, var, name, r_str_get_fail (type, \"int\"), memref, false);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_anal_op_free (op);\n\t\t\tr_anal_op_free (next_op);\n\t\t}\n\t\tsize += anal->bits / 8;\n\t\tfree (type);\n\t}\n\tr_list_free (types);\n\tr_cons_break_pop ();\n}\n\nstatic int bb_cmpaddr(const void *_a, const void *_b) {\n\tconst RAnalBlock *a = _a, *b = _b;\n\treturn a->addr > b->addr ? 1 : (a->addr < b->addr ? -1 : 0);\n}\n\nR_API void r_core_anal_type_match(RCore *core, RAnalFunction *fcn) {\n\tRAnalBlock *bb;\n\tRListIter *it;\n\tRAnalOp aop = {0};\n\tbool resolved = false;\n\n\tr_return_if_fail (core && core->anal && fcn);\n\n\tif (!core->anal->esil) {\n\t\teprintf (\"Please run aeim\\n\");\n\t\treturn;\n\t}\n\n\tRAnal *anal = core->anal;\n\tSdb *TDB = anal->sdb_types;\n\tbool chk_constraint = r_config_get_i (core->config, \"anal.types.constraint\");\n\tint ret, bsize = R_MAX (64, core->blocksize);\n\tconst int mininstrsz = r_anal_archinfo (anal, R_ANAL_ARCHINFO_MIN_OP_SIZE);\n\tconst int minopcode = R_MAX (1, mininstrsz);\n\tint cur_idx , prev_idx = 0;\n\tRConfigHold *hc = r_config_hold_new (core->config);\n\tif (!hc) {\n\t\treturn;\n\t}\n\tRDebugTrace *dt = NULL;\n\tRAnalEsilTrace *et = NULL;\n\tif (!anal_emul_init (core, hc, &dt, &et) || !fcn) {\n\t\tanal_emul_restore (core, hc, dt, et);\n\t\treturn;\n\t}\n\tut8 *buf = malloc (bsize);\n\tif (!buf) {\n\t\tanal_emul_restore (core, hc, dt, et);\n\t\treturn;\n\t}\n\n\t// Reserve bigger ht to avoid rehashing\n\tSdb *etracedb = core->anal->esil->trace->db;\n\tHtPPOptions opt = etracedb->ht->opt;\n\tht_pp_free (etracedb->ht);\n\tetracedb->ht = ht_pp_new_size (fcn->ninstr * 0xf, opt.dupvalue, opt.freefn, opt.calcsizeV);\n\tetracedb->ht->opt = opt;\n\tRDebugTrace *dtrace = core->dbg->trace;\n\topt = dtrace->ht->opt;\n\tht_pp_free (dtrace->ht);\n\tdtrace->ht = ht_pp_new_size (fcn->ninstr, opt.dupvalue, opt.freefn, opt.calcsizeV);\n\tdtrace->ht->opt = opt;\n\n\tchar *fcn_name = NULL;\n\tchar *ret_type = NULL;\n\tbool str_flag = false;\n\tbool prop = false;\n\tbool prev_var = false;\n\tchar prev_type[256] = {0};\n\tconst char *prev_dest = NULL;\n\tchar *ret_reg = NULL;\n\tconst char *_pc = r_reg_get_name (core->dbg->reg, R_REG_NAME_PC);\n\tif (!_pc) {\n\t\tfree (buf);\n\t\treturn;\n\t}\n\tchar *pc = strdup (_pc);\n\tRRegItem *r = r_reg_get (core->dbg->reg, pc, -1);\n\tif (!r) {\n\t\tfree (buf);\n\t\treturn;\n\t}\n\tr_cons_break_push (NULL, NULL);\n\tr_list_sort (fcn->bbs, bb_cmpaddr); // TODO: The algorithm can be more accurate if blocks are followed by their jmp/fail, not just by address\n\tr_list_foreach (fcn->bbs, it, bb) {\n\t\tut64 addr = bb->addr;\n\t\tint i = 0;\n\t\tr_reg_set_value (core->dbg->reg, r, addr);\n\t\twhile (1) {\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tgoto out_function;\n\t\t\t}\n\t\t\tif (i >= (bsize - 32)) {\n\t\t\t\ti = 0;\n\t\t\t}\n\t\t\tut64 pcval = r_reg_getv (anal->reg, pc);\n\t\t\tif ((addr >= bb->addr + bb->size) || (addr < bb->addr) || pcval != addr) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!i) {\n\t\t\t\tr_io_read_at (core->io, addr, buf, bsize);\n\t\t\t}\n\t\t\tret = r_anal_op (anal, &aop, addr, buf + i, bsize - i, R_ANAL_OP_MASK_BASIC | R_ANAL_OP_MASK_VAL);\n\t\t\tif (ret <= 0) {\n\t\t\t\ti += minopcode;\n\t\t\t\taddr += minopcode;\n\t\t\t\tr_anal_op_fini (&aop);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint loop_count = sdb_num_get (anal->esil->trace->db, sdb_fmt (\"0x%\"PFMT64x\".count\", addr), 0);\n\t\t\tif (loop_count > LOOP_MAX || aop.type == R_ANAL_OP_TYPE_RET) {\n\t\t\t\tr_anal_op_fini (&aop);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsdb_num_set (anal->esil->trace->db, sdb_fmt (\"0x%\"PFMT64x\".count\", addr), loop_count + 1, 0);\n\t\t\tif (r_anal_op_nonlinear (aop.type)) {   // skip the instr\n\t\t\t\tr_reg_set_value (core->dbg->reg, r, addr + ret);\n\t\t\t} else {\n\t\t\t\tr_core_esil_step (core, UT64_MAX, NULL, NULL, false);\n\t\t\t}\n\t\t\tbool userfnc = false;\n\t\t\tSdb *trace = anal->esil->trace->db;\n\t\t\tcur_idx = sdb_num_get (trace, \"idx\", 0);\n\t\t\tRAnalVar *var = r_anal_get_used_function_var (anal, aop.addr);\n\t\t\tRAnalOp *next_op = r_core_anal_op (core, addr + ret, R_ANAL_OP_MASK_BASIC); // | _VAL ?\n\t\t\tut32 type = aop.type & R_ANAL_OP_TYPE_MASK;\n\t\t\tif (aop.type == R_ANAL_OP_TYPE_CALL || aop.type & R_ANAL_OP_TYPE_UCALL) {\n\t\t\t\tchar *full_name = NULL;\n\t\t\t\tut64 callee_addr;\n\t\t\t\tif (aop.type == R_ANAL_OP_TYPE_CALL) {\n\t\t\t\t\tRAnalFunction *fcn_call = r_anal_get_fcn_in (anal, aop.jump, -1);\n\t\t\t\t\tif (fcn_call) {\n\t\t\t\t\t\tfull_name = fcn_call->name;\n\t\t\t\t\t\tcallee_addr = fcn_call->addr;\n\t\t\t\t\t}\n\t\t\t\t} else if (aop.ptr != UT64_MAX) {\n\t\t\t\t\tRFlagItem *flag = r_flag_get_by_spaces (core->flags, aop.ptr, R_FLAGS_FS_IMPORTS, NULL);\n\t\t\t\t\tif (flag && flag->realname) {\n\t\t\t\t\t\tfull_name = flag->realname;\n\t\t\t\t\t\tcallee_addr = aop.ptr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (full_name) {\n\t\t\t\t\tif (r_type_func_exist (TDB, full_name)) {\n\t\t\t\t\t\tfcn_name = strdup (full_name);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfcn_name = r_type_func_guess (TDB, full_name);\n\t\t\t\t\t}\n\t\t\t\t\tif (!fcn_name) {\n\t\t\t\t\t\tfcn_name = strdup (full_name);\n\t\t\t\t\t\tuserfnc = true;\n\t\t\t\t\t}\n\t\t\t\t\tconst char* Cc = r_anal_cc_func (anal, fcn_name);\n\t\t\t\t\tif (Cc && r_anal_cc_exist (anal, Cc)) {\n\t\t\t\t\t\tchar *cc = strdup (Cc);\n\t\t\t\t\t\ttype_match (core, fcn_name, addr, bb->addr, cc, prev_idx, userfnc, callee_addr);\n\t\t\t\t\t\tprev_idx = cur_idx;\n\t\t\t\t\t\tR_FREE (ret_type);\n\t\t\t\t\t\tconst char *rt = r_type_func_ret (TDB, fcn_name);\n\t\t\t\t\t\tif (rt) {\n\t\t\t\t\t\t\tret_type = strdup (rt);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tR_FREE (ret_reg);\n\t\t\t\t\t\tconst char *rr = r_anal_cc_ret (anal, cc);\n\t\t\t\t\t\tif (rr) {\n\t\t\t\t\t\t\tret_reg = strdup (rr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresolved = false;\n\t\t\t\t\t\tfree (cc);\n\t\t\t\t\t}\n\t\t\t\t\tif (!strcmp (fcn_name, \"__stack_chk_fail\")) {\n\t\t\t\t\t\tconst char *query = sdb_fmt (\"%d.addr\", cur_idx - 1);\n\t\t\t\t\t\tut64 mov_addr = sdb_num_get (trace, query, 0);\n\t\t\t\t\t\tRAnalOp *mop = r_core_anal_op (core, mov_addr, R_ANAL_OP_MASK_VAL | R_ANAL_OP_MASK_BASIC);\n\t\t\t\t\t\tif (mop) {\n\t\t\t\t\t\t\tRAnalVar *mopvar = r_anal_get_used_function_var (anal, mop->addr);\n\t\t\t\t\t\t\tut32 type = mop->type & R_ANAL_OP_TYPE_MASK;\n\t\t\t\t\t\t\tif (type == R_ANAL_OP_TYPE_MOV) {\n\t\t\t\t\t\t\t\t__var_rename (anal, mopvar, \"canary\", addr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_anal_op_free (mop);\n\t\t\t\t\t}\n\t\t\t\t\tfree (fcn_name);\n\t\t\t\t}\n\t\t\t} else if (!resolved && ret_type && ret_reg) {\n\t\t\t\t// Forward propgation of function return type\n\t\t\t\tchar src[REGNAME_SIZE] = {0};\n\t\t\t\tconst char *query = sdb_fmt (\"%d.reg.write\", cur_idx);\n\t\t\t\tconst char *cur_dest = sdb_const_get (trace, query, 0);\n\t\t\t\tget_src_regname (core, aop.addr, src, sizeof (src));\n\t\t\t\tif (ret_reg && *src && strstr (ret_reg, src)) {\n\t\t\t\t\tif (var && aop.direction == R_ANAL_OP_DIR_WRITE) {\n\t\t\t\t\t\t__var_retype (anal, var, NULL, ret_type, false, false);\n\t\t\t\t\t\tresolved = true;\n\t\t\t\t\t} else if (type == R_ANAL_OP_TYPE_MOV) {\n\t\t\t\t\t\tR_FREE (ret_reg);\n\t\t\t\t\t\tif (cur_dest) {\n\t\t\t\t\t\t\tret_reg = strdup (cur_dest);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (cur_dest) {\n\t\t\t\t\tchar *foo = strdup (cur_dest);\n\t\t\t\t\tchar *tmp = strchr (foo, ',');\n\t\t\t\t\tif (tmp) {\n\t\t\t\t\t\t*tmp++ = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tif (ret_reg && (strstr (ret_reg, foo) || (tmp && strstr (ret_reg, tmp)))) {\n\t\t\t\t\t\tresolved = true;\n\t\t\t\t\t} else if (type == R_ANAL_OP_TYPE_MOV &&\n\t\t\t\t\t\t\t(next_op && next_op->type == R_ANAL_OP_TYPE_MOV)){\n\t\t\t\t\t\t// Progate return type passed using pointer\n\t\t\t\t\t\t// int *ret; *ret = strlen(s);\n\t\t\t\t\t\t// TODO: memref check , dest and next src match\n\t\t\t\t\t\tchar nsrc[REGNAME_SIZE] = {0};\n\t\t\t\t\t\tget_src_regname (core, next_op->addr, nsrc, sizeof (nsrc));\n\t\t\t\t\t\tif (ret_reg && *nsrc && strstr (ret_reg, nsrc) && var &&\n\t\t\t\t\t\t\t\taop.direction == R_ANAL_OP_DIR_READ) {\n\t\t\t\t\t\t\t__var_retype (anal, var, NULL, ret_type, true, false);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree (foo);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Type propagation using instruction access pattern\n\t\t\tif (var) {\n\t\t\t\tbool sign = false;\n\t\t\t\tif ((type == R_ANAL_OP_TYPE_CMP) && next_op) {\n\t\t\t\t\tif (next_op->sign) {\n\t\t\t\t\t\tsign = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// cmp [local_ch], rax ; jb\n\t\t\t\t\t\t__var_retype (anal, var, NULL, \"unsigned\", false, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// cmp [local_ch], rax ; jge\n\t\t\t\tif (sign || aop.sign) {\n\t\t\t\t\t__var_retype (anal, var, NULL, \"signed\", false, true);\n\t\t\t\t}\n\t\t\t\t// lea rax , str.hello  ; mov [local_ch], rax;\n\t\t\t\t// mov rdx , [local_4h] ; mov [local_8h], rdx;\n\t\t\t\tif (prev_dest && (type == R_ANAL_OP_TYPE_MOV || type == R_ANAL_OP_TYPE_STORE)) {\n\t\t\t\t\tchar reg[REGNAME_SIZE] = {0};\n\t\t\t\t\tget_src_regname (core, addr, reg, sizeof (reg));\n\t\t\t\t\tbool match = strstr (prev_dest, reg) != NULL;\n\t\t\t\t\tif (str_flag && match) {\n\t\t\t\t\t\t__var_retype (anal, var, NULL, \"const char *\", false, false);\n\t\t\t\t\t}\n\t\t\t\t\tif (prop && match && prev_var) {\n\t\t\t\t\t\t__var_retype (anal, var, NULL, prev_type, false, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (chk_constraint && var && (type == R_ANAL_OP_TYPE_CMP && aop.disp != UT64_MAX)\n\t\t\t\t\t\t&& next_op && next_op->type == R_ANAL_OP_TYPE_CJMP) {\n\t\t\t\t\tbool jmp = false;\n\t\t\t\t\tRAnalOp *jmp_op = {0};\n\t\t\t\t\tut64 jmp_addr = next_op->jump;\n\t\t\t\t\tRAnalBlock *jmpbb = r_anal_fcn_bbget_in (anal, fcn, jmp_addr);\n\n\t\t\t\t\t// Check exit status of jmp branch\n\t\t\t\t\tfor (i = 0; i < MAX_INSTR ; i++) {\n\t\t\t\t\t\tjmp_op = r_core_anal_op (core, jmp_addr, R_ANAL_OP_MASK_BASIC);\n\t\t\t\t\t\tif (!jmp_op) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ((jmp_op->type == R_ANAL_OP_TYPE_RET && r_anal_block_contains (jmpbb, jmp_addr))\n\t\t\t\t\t\t\t\t|| jmp_op->type == R_ANAL_OP_TYPE_CJMP) {\n\t\t\t\t\t\t\tjmp = true;\n\t\t\t\t\t\t\tr_anal_op_free (jmp_op);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tjmp_addr += jmp_op->size;\n\t\t\t\t\t\tr_anal_op_free (jmp_op);\n\t\t\t\t\t}\n\t\t\t\t\tRAnalVarConstraint constr = {\n\t\t\t\t\t\t.cond = jmp? cond_invert (anal, next_op->cond): next_op->cond,\n\t\t\t\t\t\t.val = aop.val\n\t\t\t\t\t};\n\t\t\t\t\tr_anal_var_add_constraint (var, &constr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprev_var = (var && aop.direction == R_ANAL_OP_DIR_READ);\n\t\t\tstr_flag = false;\n\t\t\tprop = false;\n\t\t\tprev_dest = NULL;\n\t\t\tswitch (type) {\n\t\t\tcase R_ANAL_OP_TYPE_MOV:\n\t\t\tcase R_ANAL_OP_TYPE_LEA:\n\t\t\tcase R_ANAL_OP_TYPE_LOAD:\n\t\t\t\tif (aop.ptr && aop.refptr && aop.ptr != UT64_MAX) {\n\t\t\t\t\tif (type == R_ANAL_OP_TYPE_LOAD) {\n\t\t\t\t\t\tut8 buf[256] = {0};\n\t\t\t\t\t\tr_io_read_at (core->io, aop.ptr, buf, sizeof (buf) - 1);\n\t\t\t\t\t\tut64 ptr = r_read_ble (buf, core->print->big_endian, aop.refptr * 8);\n\t\t\t\t\t\tif (ptr && ptr != UT64_MAX) {\n\t\t\t\t\t\t\tRFlagItem *f = r_flag_get_by_spaces (core->flags, ptr, R_FLAGS_FS_STRINGS, NULL);\n\t\t\t\t\t\t\tif (f) {\n\t\t\t\t\t\t\t\tstr_flag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (r_flag_exist_at (core->flags, \"str\", 3, aop.ptr)) {\n\t\t\t\t\t\tstr_flag = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// mov dword [local_4h], str.hello;\n\t\t\t\tif (var && str_flag) {\n\t\t\t\t\t__var_retype (anal, var, NULL, \"const char *\", false, false);\n\t\t\t\t}\n\t\t\t\tconst char *query = sdb_fmt (\"%d.reg.write\", cur_idx);\n\t\t\t\tprev_dest = sdb_const_get (trace, query, 0);\n\t\t\t\tif (var) {\n\t\t\t\t\tstrncpy (prev_type, var->type, sizeof (prev_type) - 1);\n\t\t\t\t\tprop = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti += ret;\n\t\t\taddr += ret;\n\t\t\tr_anal_op_free (next_op);\n\t\t\tr_anal_op_fini (&aop);\n\n\t\t}\n\t}\n\t// Type propgation for register based args\n\tRList *list = r_anal_var_list (anal, fcn, R_ANAL_VAR_KIND_REG);\n\tRAnalVar *rvar;\n\tRListIter *iter;\n\tr_list_foreach (list, iter, rvar) {\n\t\tRAnalVar *lvar = r_anal_var_get_dst_var (rvar);\n\t\tRRegItem *i = r_reg_index_get (anal->reg, rvar->delta);\n\t\tif (!i) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (lvar) {\n\t\t\t// Propagate local var type = to => register-based var\n\t\t\t__var_retype (anal, rvar, NULL, lvar->type, false, false);\n\t\t\t// Propagate local var type <= from = register-based var\n\t\t\t__var_retype (anal, lvar, NULL, rvar->type, false, false);\n\t\t}\n\t}\n\tr_list_free (list);\nout_function:\n\tR_FREE (ret_reg);\n\tR_FREE (ret_type);\n\tfree (buf);\n\tr_cons_break_pop();\n\tanal_emul_restore (core, hc, dt, et);\n\tfree (pc);\n}\n"], "filenames": ["libr/core/anal_tp.c"], "buggy_code_start_loc": [507], "buggy_code_end_loc": [782], "fixing_code_start_loc": [507], "fixing_code_end_loc": [784], "type": "CWE-416", "message": "A use after free in r_reg_get_name_idx function in radare2 5.4.2 and 5.4.0.", "other": {"cve": {"id": "CVE-2022-28071", "sourceIdentifier": "cve@mitre.org", "published": "2023-08-22T19:16:22.667", "lastModified": "2023-08-24T22:04:41.027", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A use after free in r_reg_get_name_idx function in radare2 5.4.2 and 5.4.0."}, {"lang": "es", "value": "Un use after free en la funci\u00f3n r_reg_get_name_idx en radare2 5.4.2 y 5.4.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:5.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "834B6EB8-099A-469F-ADA3-183E51E43717"}, {"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:5.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "C9DEDA4E-172C-482D-8527-D9AEF8A1D7CC"}]}]}], "references": [{"url": "https://github.com/radareorg/radare2/commit/65448811e5b9582a19cf631e03cfcaa025a92ef5", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radareorg/radare2/commit/65448811e5b9582a19cf631e03cfcaa025a92ef5"}}