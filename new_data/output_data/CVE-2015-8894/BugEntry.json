{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            TTTTT   GGGG   AAA                               %\n%                              T    G      A   A                              %\n%                              T    G  GG  AAAAA                              %\n%                              T    G   G  A   A                              %\n%                              T     GGG   A   A                              %\n%                                                                             %\n%                                                                             %\n%                    Read/Write Truevision Targa Image Format                 %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2015 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colormap-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n\n/*\n  Enumerated declaractions.\n*/\ntypedef enum\n{\n  TGAColormap = 1,\n  TGARGB = 2,\n  TGAMonochrome = 3,\n  TGARLEColormap = 9,\n  TGARLERGB = 10,\n  TGARLEMonochrome = 11\n} TGAImageType;\n\n/*\n  Typedef declaractions.\n*/\ntypedef struct _TGAInfo\n{\n  TGAImageType\n    image_type;\n\n  unsigned char\n    id_length,\n    colormap_type;\n\n  unsigned short\n    colormap_index,\n    colormap_length;\n\n  unsigned char\n    colormap_size;\n\n  unsigned short\n    x_origin,\n    y_origin,\n    width,\n    height;\n\n  unsigned char\n    bits_per_pixel,\n    attributes;\n} TGAInfo;\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WriteTGAImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d T G A I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadTGAImage() reads a Truevision TGA image file and returns it.\n%  It allocates the memory necessary for the new Image structure and returns\n%  a pointer to the new image.\n%\n%  The format of the ReadTGAImage method is:\n%\n%      Image *ReadTGAImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadTGAImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  PixelInfo\n    pixel;\n\n  Quantum\n    index;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  size_t\n    base,\n    flag,\n    offset,\n    real,\n    skip;\n\n  ssize_t\n    count,\n    y;\n\n  TGAInfo\n    tga_info;\n\n  unsigned char\n    j,\n    k,\n    pixels[4],\n    runlength;\n\n  unsigned int\n    alpha_bits;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read TGA header information.\n  */\n  count=ReadBlob(image,1,&tga_info.id_length);\n  tga_info.colormap_type=(unsigned char) ReadBlobByte(image);\n  tga_info.image_type=(TGAImageType) ReadBlobByte(image);\n  if ((count != 1) ||\n      ((tga_info.image_type != TGAColormap) &&\n       (tga_info.image_type != TGARGB) &&\n       (tga_info.image_type != TGAMonochrome) &&\n       (tga_info.image_type != TGARLEColormap) &&\n       (tga_info.image_type != TGARLERGB) &&\n       (tga_info.image_type != TGARLEMonochrome)) ||\n      (((tga_info.image_type == TGAColormap) ||\n       (tga_info.image_type == TGARLEColormap)) &&\n       (tga_info.colormap_type == 0)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  tga_info.colormap_index=ReadBlobLSBShort(image);\n  tga_info.colormap_length=ReadBlobLSBShort(image);\n  tga_info.colormap_size=(unsigned char) ReadBlobByte(image);\n  tga_info.x_origin=ReadBlobLSBShort(image);\n  tga_info.y_origin=ReadBlobLSBShort(image);\n  tga_info.width=(unsigned short) ReadBlobLSBShort(image);\n  tga_info.height=(unsigned short) ReadBlobLSBShort(image);\n  tga_info.bits_per_pixel=(unsigned char) ReadBlobByte(image);\n  tga_info.attributes=(unsigned char) ReadBlobByte(image);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n  if ((((tga_info.bits_per_pixel <= 1) || (tga_info.bits_per_pixel >= 17)) &&\n       (tga_info.bits_per_pixel != 24) && (tga_info.bits_per_pixel != 32)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  /*\n    Initialize image structure.\n  */\n  image->columns=tga_info.width;\n  image->rows=tga_info.height;\n  alpha_bits=(tga_info.attributes & 0x0FU);\n  image->alpha_trait=(alpha_bits > 0) || (tga_info.bits_per_pixel == 32) ||\n    (tga_info.colormap_size == 32) ?  BlendPixelTrait : UndefinedPixelTrait;\n  if ((tga_info.image_type != TGAColormap) &&\n      (tga_info.image_type != TGARLEColormap))\n    image->depth=(size_t) ((tga_info.bits_per_pixel <= 8) ? 8 :\n      (tga_info.bits_per_pixel <= 16) ? 5 :\n      (tga_info.bits_per_pixel == 24) ? 8 :\n      (tga_info.bits_per_pixel == 32) ? 8 : 8);\n  else\n    image->depth=(size_t) ((tga_info.colormap_size <= 8) ? 8 :\n      (tga_info.colormap_size <= 16) ? 5 :\n      (tga_info.colormap_size == 24) ? 8 :\n      (tga_info.colormap_size == 32) ? 8 : 8);\n  if ((tga_info.image_type == TGAColormap) ||\n      (tga_info.image_type == TGAMonochrome) ||\n      (tga_info.image_type == TGARLEColormap) ||\n      (tga_info.image_type == TGARLEMonochrome))\n    image->storage_class=PseudoClass;\n  image->compression=NoCompression;\n  if ((tga_info.image_type == TGARLEColormap) ||\n      (tga_info.image_type == TGARLEMonochrome) ||\n      (tga_info.image_type == TGARLERGB))\n    image->compression=RLECompression;\n  if (image->storage_class == PseudoClass)\n    {\n      if (tga_info.colormap_type != 0)\n        image->colors=tga_info.colormap_index+tga_info.colormap_length;\n      else\n        {\n          size_t\n            one;\n\n          one=1;\n          image->colors=one << tga_info.bits_per_pixel;\n          if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n    }\n  if (tga_info.id_length != 0)\n    {\n      char\n        *comment;\n\n      size_t\n        length;\n\n      /*\n        TGA image comment.\n      */\n      length=(size_t) tga_info.id_length;\n      comment=(char *) NULL;\n      if (~length >= (MagickPathExtent-1))\n        comment=(char *) AcquireQuantumMemory(length+MagickPathExtent,\n          sizeof(*comment));\n      if (comment == (char *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      count=ReadBlob(image,tga_info.id_length,(unsigned char *) comment);\n      comment[tga_info.id_length]='\\0';\n      (void) SetImageProperty(image,\"comment\",comment,exception);\n      comment=DestroyString(comment);\n    }\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(image);\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  (void) ResetMagickMemory(&pixel,0,sizeof(pixel));\n  pixel.alpha=(MagickRealType) OpaqueAlpha;\n  if (tga_info.colormap_type != 0)\n    {\n      /*\n        Read TGA raster colormap.\n      */\n      if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      for (i=0; i < (ssize_t) tga_info.colormap_index; i++)\n        image->colormap[i]=pixel;\n      for ( ; i < (ssize_t) image->colors; i++)\n      {\n        switch (tga_info.colormap_size)\n        {\n          case 8:\n          default:\n          {\n            /*\n              Gray scale.\n            */\n            pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            pixel.green=pixel.red;\n            pixel.blue=pixel.red;\n            break;\n          }\n          case 15:\n          case 16:\n          {\n            QuantumAny\n              range;\n\n            /*\n              5 bits each of red green and blue.\n            */\n            j=(unsigned char) ReadBlobByte(image);\n            k=(unsigned char) ReadBlobByte(image);\n            range=GetQuantumRange(5UL);\n            pixel.red=(MagickRealType) ScaleAnyToQuantum(1UL*(k & 0x7c) >> 2,\n              range);\n            pixel.green=(MagickRealType) ScaleAnyToQuantum((1UL*(k & 0x03)\n              << 3)+(1UL*(j & 0xe0) >> 5),range);\n            pixel.blue=(MagickRealType) ScaleAnyToQuantum(1UL*(j & 0x1f),range);\n            break;\n          }\n          case 24:\n          {\n            /*\n              8 bits each of blue, green and red.\n            */\n            pixel.blue=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            pixel.green=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            break;\n          }\n          case 32:\n          {\n            /*\n              8 bits each of blue, green, red, and alpha.\n            */\n            pixel.blue=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            pixel.green=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            pixel.alpha=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            break;\n          }\n        }\n        image->colormap[i]=pixel;\n      }\n    }\n  /*\n    Convert TGA pixels to pixel packets.\n  */\n  base=0;\n  flag=0;\n  skip=MagickFalse;\n  real=0;\n  index=0;\n  runlength=0;\n  offset=0;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    real=offset;\n    if (((unsigned char) (tga_info.attributes & 0x20) >> 5) == 0)\n      real=image->rows-real-1;\n    q=QueueAuthenticPixels(image,0,(ssize_t) real,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if ((tga_info.image_type == TGARLEColormap) ||\n          (tga_info.image_type == TGARLERGB) ||\n          (tga_info.image_type == TGARLEMonochrome))\n        {\n          if (runlength != 0)\n            {\n              runlength--;\n              skip=flag != 0;\n            }\n          else\n            {\n              count=ReadBlob(image,1,&runlength);\n              if (count != 1)\n                ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n              flag=runlength & 0x80;\n              if (flag != 0)\n                runlength-=128;\n              skip=MagickFalse;\n            }\n        }\n      if (skip == MagickFalse)\n        switch (tga_info.bits_per_pixel)\n        {\n          case 8:\n          default:\n          {\n            /*\n              Gray scale.\n            */\n            index=(Quantum) ReadBlobByte(image);\n            if (tga_info.colormap_type != 0)\n              pixel=image->colormap[(ssize_t) ConstrainColormapIndex(image,\n                (ssize_t) index,exception)];\n            else\n              {\n                pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)\n                  index);\n                pixel.green=(MagickRealType) ScaleCharToQuantum((unsigned char)\n                  index);\n                pixel.blue=(MagickRealType) ScaleCharToQuantum((unsigned char)\n                  index);\n              }\n            break;\n          }\n          case 15:\n          case 16:\n          {\n            QuantumAny\n              range;\n\n            /*\n              5 bits each of RGB.\n            */\n            if (ReadBlob(image,2,pixels) != 2)\n              ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n            j=pixels[0];\n            k=pixels[1];\n            range=GetQuantumRange(5UL);\n            pixel.red=(MagickRealType) ScaleAnyToQuantum(1UL*(k & 0x7c) >> 2,\n              range);\n            pixel.green=(MagickRealType) ScaleAnyToQuantum((1UL*\n              (k & 0x03) << 3)+(1UL*(j & 0xe0) >> 5),range);\n            pixel.blue=(MagickRealType) ScaleAnyToQuantum(1UL*(j & 0x1f),range);\n            if (image->alpha_trait != UndefinedPixelTrait)\n              pixel.alpha=(MagickRealType) ((k & 0x80) == 0 ? (Quantum)\n                TransparentAlpha : (Quantum) OpaqueAlpha);\n            if (image->storage_class == PseudoClass)\n              index=(Quantum) ConstrainColormapIndex(image,((ssize_t) (k << 8))+\n                j,exception);\n            break;\n          }\n          case 24:\n          {\n            /*\n              BGR pixels.\n            */\n            if (ReadBlob(image,3,pixels) != 3)\n              ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n            pixel.blue=(MagickRealType) ScaleCharToQuantum(pixels[0]);\n            pixel.green=(MagickRealType) ScaleCharToQuantum(pixels[1]);\n            pixel.red=(MagickRealType) ScaleCharToQuantum(pixels[2]);\n            break;\n          }\n          case 32:\n          {\n            /*\n              BGRA pixels.\n            */\n            if (ReadBlob(image,4,pixels) != 4)\n              ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n            pixel.blue=(MagickRealType) ScaleCharToQuantum(pixels[0]);\n            pixel.green=(MagickRealType) ScaleCharToQuantum(pixels[1]);\n            pixel.red=(MagickRealType) ScaleCharToQuantum(pixels[2]);\n            pixel.alpha=(MagickRealType) ScaleCharToQuantum(pixels[3]);\n            break;\n          }\n        }\n      if (status == MagickFalse)\n        ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n      if (image->storage_class == PseudoClass)\n        SetPixelIndex(image,index,q);\n      SetPixelRed(image,ClampToQuantum(pixel.red),q);\n      SetPixelGreen(image,ClampToQuantum(pixel.green),q);\n      SetPixelBlue(image,ClampToQuantum(pixel.blue),q);\n      if (image->alpha_trait != UndefinedPixelTrait)\n        SetPixelAlpha(image,ClampToQuantum(pixel.alpha),q);\n      q+=GetPixelChannels(image);\n    }\n    /*\n      if (((unsigned char) (tga_info.attributes & 0xc0) >> 6) == 4)\n        offset+=4;\n      else\n    */\n      if (((unsigned char) (tga_info.attributes & 0xc0) >> 6) == 2)\n        offset+=2;\n      else\n        offset++;\n    if (offset >= image->rows)\n      {\n        base++;\n        offset=base;\n      }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r T G A I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterTGAImage() adds properties for the TGA image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterTGAImage method is:\n%\n%      size_t RegisterTGAImage(void)\n%\n*/\nModuleExport size_t RegisterTGAImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"TGA\",\"ICB\",\"Truevision Targa image\");\n  entry->decoder=(DecodeImageHandler *) ReadTGAImage;\n  entry->encoder=(EncodeImageHandler *) WriteTGAImage;\n  entry->flags^=CoderAdjoinFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TGA\",\"TGA\",\"Truevision Targa image\");\n  entry->decoder=(DecodeImageHandler *) ReadTGAImage;\n  entry->encoder=(EncodeImageHandler *) WriteTGAImage;\n  entry->flags^=CoderAdjoinFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TGA\",\"VDA\",\"Truevision Targa image\");\n  entry->decoder=(DecodeImageHandler *) ReadTGAImage;\n  entry->encoder=(EncodeImageHandler *) WriteTGAImage;\n  entry->flags^=CoderAdjoinFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TGA\",\"VST\",\"Truevision Targa image\");\n  entry->decoder=(DecodeImageHandler *) ReadTGAImage;\n  entry->encoder=(EncodeImageHandler *) WriteTGAImage;\n  entry->flags^=CoderAdjoinFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r T G A I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterTGAImage() removes format registrations made by the\n%  TGA module from the list of supported formats.\n%\n%  The format of the UnregisterTGAImage method is:\n%\n%      UnregisterTGAImage(void)\n%\n*/\nModuleExport void UnregisterTGAImage(void)\n{\n  (void) UnregisterMagickInfo(\"ICB\");\n  (void) UnregisterMagickInfo(\"TGA\");\n  (void) UnregisterMagickInfo(\"VDA\");\n  (void) UnregisterMagickInfo(\"VST\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e T G A I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteTGAImage() writes a image in the Truevision Targa rasterfile\n%  format.\n%\n%  The format of the WriteTGAImage method is:\n%\n%      MagickBooleanType WriteTGAImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n*/\nstatic inline void WriteTGAPixel(Image *image,TGAImageType image_type,\n  const Quantum *p,const QuantumAny range,const double midpoint)\n{\n  if (image_type == TGAColormap || image_type == TGARLEColormap)\n    (void) WriteBlobByte(image,(unsigned char) GetPixelIndex(image,p));\n  else\n    {\n      if (image_type == TGAMonochrome || image_type == TGARLEMonochrome)\n        (void) WriteBlobByte(image,ScaleQuantumToChar(ClampToQuantum(\n          GetPixelLuma(image,p))));\n      else\n        if (image->depth == 5)\n          {\n            unsigned char\n              green,\n              value;\n\n            green=(unsigned char) ScaleQuantumToAny(GetPixelGreen(image,p),\n              range);\n            value=((unsigned char) ScaleQuantumToAny(GetPixelBlue(image,p),\n              range)) | ((green & 0x07) << 5);\n            (void) WriteBlobByte(image,value);\n            value=(((image->alpha_trait != UndefinedPixelTrait) &&\n              ((double) GetPixelAlpha(image,p) > midpoint)) ? 0x80 : 0) |\n              ((unsigned char) ScaleQuantumToAny(GetPixelRed(image,p),range) <<\n              2) | ((green & 0x18) >> 3);\n            (void) WriteBlobByte(image,value);\n          }\n        else\n          {\n            (void) WriteBlobByte(image,ScaleQuantumToChar(\n              GetPixelBlue(image,p)));\n            (void) WriteBlobByte(image,ScaleQuantumToChar(\n              GetPixelGreen(image,p)));\n            (void) WriteBlobByte(image,ScaleQuantumToChar(\n              GetPixelRed(image,p)));\n            if (image->alpha_trait != UndefinedPixelTrait)\n              (void) WriteBlobByte(image,ScaleQuantumToChar(\n                GetPixelAlpha(image,p)));\n          }\n    }\n}\n\nstatic MagickBooleanType WriteTGAImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  CompressionType\n    compression;\n\n  const char\n    *value;\n\n  const double\n    midpoint = QuantumRange/2.0;\n\n  MagickBooleanType\n    status;\n\n  QuantumAny\n    range;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    x;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *q;\n\n  size_t\n    channels;\n\n  ssize_t\n    count,\n    y;\n\n  TGAInfo\n    tga_info;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  /*\n    Initialize TGA raster file header.\n  */\n  if ((image->columns > 65535L) || (image->rows > 65535L))\n    ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n  (void) TransformImageColorspace(image,sRGBColorspace,exception);\n  compression=image->compression;\n  if (image_info->compression != UndefinedCompression)\n    compression=image_info->compression;\n  range=GetQuantumRange(5UL);\n  tga_info.id_length=0;\n  value=GetImageProperty(image,\"comment\",exception);\n  if (value != (const char *) NULL)\n    tga_info.id_length=(unsigned char) MagickMin(strlen(value),255);\n  tga_info.colormap_type=0;\n  tga_info.colormap_index=0;\n  tga_info.colormap_length=0;\n  tga_info.colormap_size=0;\n  tga_info.x_origin=0;\n  tga_info.y_origin=0;\n  tga_info.width=(unsigned short) image->columns;\n  tga_info.height=(unsigned short) image->rows;\n  tga_info.bits_per_pixel=8;\n  tga_info.attributes=0;\n  if ((image_info->type != TrueColorType) &&\n      (image_info->type != TrueColorAlphaType) &&\n      (image_info->type != PaletteType) &&\n      (image->alpha_trait == UndefinedPixelTrait) &&\n      (SetImageGray(image,exception) != MagickFalse))\n    tga_info.image_type=compression == RLECompression ? TGARLEMonochrome :\n      TGAMonochrome;\n  else\n    if ((image->storage_class == DirectClass) || (image->colors > 256))\n      {\n        /*\n          Full color TGA raster.\n        */\n        tga_info.image_type=compression == RLECompression ? TGARLERGB : TGARGB;\n        if (image_info->depth == 5)\n          {\n            tga_info.bits_per_pixel=16;\n            if (image->alpha_trait != UndefinedPixelTrait)\n              tga_info.attributes=1;  /* # of alpha bits */\n          }\n        else\n          {\n            tga_info.bits_per_pixel=24;\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                tga_info.bits_per_pixel=32;\n                tga_info.attributes=8;  /* # of alpha bits */\n              }\n          }\n      }\n    else\n      {\n        /*\n          Colormapped TGA raster.\n        */\n        tga_info.image_type=compression == RLECompression ? TGARLEColormap :\n          TGAColormap;\n        tga_info.colormap_type=1;\n        tga_info.colormap_length=(unsigned short) image->colors;\n        if (image_info->depth == 5)\n          tga_info.colormap_size=16;\n        else\n          tga_info.colormap_size=24;\n      }\n  /*\n    Write TGA header.\n  */\n  (void) WriteBlobByte(image,tga_info.id_length);\n  (void) WriteBlobByte(image,tga_info.colormap_type);\n  (void) WriteBlobByte(image,(unsigned char) tga_info.image_type);\n  (void) WriteBlobLSBShort(image,tga_info.colormap_index);\n  (void) WriteBlobLSBShort(image,tga_info.colormap_length);\n  (void) WriteBlobByte(image,tga_info.colormap_size);\n  (void) WriteBlobLSBShort(image,tga_info.x_origin);\n  (void) WriteBlobLSBShort(image,tga_info.y_origin);\n  (void) WriteBlobLSBShort(image,tga_info.width);\n  (void) WriteBlobLSBShort(image,tga_info.height);\n  (void) WriteBlobByte(image,tga_info.bits_per_pixel);\n  (void) WriteBlobByte(image,tga_info.attributes);\n  if (tga_info.id_length != 0)\n    (void) WriteBlob(image,tga_info.id_length,(unsigned char *) value);\n  if (tga_info.colormap_type != 0)\n    {\n      unsigned char\n        green,\n        *targa_colormap;\n\n      /*\n        Dump colormap to file (blue, green, red byte order).\n      */\n      targa_colormap=(unsigned char *) AcquireQuantumMemory((size_t)\n        tga_info.colormap_length,(tga_info.colormap_size/8)*\n        sizeof(*targa_colormap));\n      if (targa_colormap == (unsigned char *) NULL)\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      q=targa_colormap;\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        if (image_info->depth == 5)\n          {\n            green=(unsigned char) ScaleQuantumToAny(ClampToQuantum(\n              image->colormap[i].green),range);\n            *q++=((unsigned char) ScaleQuantumToAny(ClampToQuantum(\n              image->colormap[i].blue),range)) | ((green & 0x07) << 5);\n            *q++=(((image->alpha_trait != UndefinedPixelTrait) && ((double)\n              ClampToQuantum(image->colormap[i].alpha) > midpoint)) ? 0x80 : 0) |\n              ((unsigned char) ScaleQuantumToAny(ClampToQuantum(\n              image->colormap[i].red),range) << 2) | ((green & 0x18) >> 3);\n          }\n        else\n          {\n            *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].blue));\n            *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].green));\n            *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].red));\n          }\n      }\n      (void) WriteBlob(image,(size_t) ((tga_info.colormap_size/8)*\n        tga_info.colormap_length),targa_colormap);\n      targa_colormap=(unsigned char *) RelinquishMagickMemory(targa_colormap);\n    }\n  /*\n    Convert MIFF to TGA raster pixels.\n  */\n  channels=GetPixelChannels(image);\n  for (y=(ssize_t) (image->rows-1); y >= 0; y--)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    if (compression == RLECompression)\n      {\n        x=0;\n        count=0;\n        while (x < (ssize_t) image->columns)\n        {\n          i=1;\n          while ((i < 128) && (count + i < 128) &&\n                 ((x + i) < (ssize_t) image->columns))\n          {\n            if (tga_info.image_type == TGARLEColormap)\n              {\n                if (GetPixelIndex(image,p+(i*channels)) !=\n                    GetPixelIndex(image,p+((i-1)*channels)))\n                  break;\n              }\n            else if (tga_info.image_type == TGARLEMonochrome)\n              {\n                if (GetPixelLuma(image,p+(i*channels)) !=\n                    GetPixelLuma(image,p+((i-1)*channels)))\n                  break;\n              }\n            else\n              {\n                if ((GetPixelBlue(image,p+(i*channels)) !=\n                     GetPixelBlue(image,p+((i-1)*channels))) ||\n                    (GetPixelGreen(image,p+(i*channels)) !=\n                     GetPixelGreen(image,p+((i-1)*channels))) ||\n                    (GetPixelRed(image,p+(i*channels)) !=\n                     GetPixelRed(image,p+((i-1)*channels))))\n                  break;\n                if ((image->alpha_trait != UndefinedPixelTrait) &&\n                    (GetPixelAlpha(image,p+(i*channels)) !=\n                     GetPixelAlpha(image,p+(i-1)*channels)))\n                  break;\n              }\n            i++;\n          }\n          if (i < 3)\n            {\n              count+=i;\n              p+=(i*channels);\n            }\n          if ((i >= 3) || (count == 128) ||\n              ((x + i) == (ssize_t) image->columns))\n            {\n              if (count > 0)\n                {\n                  (void) WriteBlobByte(image,(unsigned char) (--count));\n                  while (count >= 0)\n                  {\n                    WriteTGAPixel(image,tga_info.image_type,p-((count+1)*\n                      channels),range,midpoint);\n                    count--;\n                  }\n                  count=0;\n                }\n            }\n          if (i >= 3)\n            {\n              (void) WriteBlobByte(image,(unsigned char) ((i-1) | 0x80));\n              WriteTGAPixel(image,tga_info.image_type,p,range,midpoint);\n              p+=(i*channels);\n            }\n          x+=i;\n        }\n      }\n    else\n      {\n        for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            WriteTGAPixel(image,tga_info.image_type,p,range,midpoint);\n            p+=channels;\n          }\n      }\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            TTTTT   GGGG   AAA                               %\n%                              T    G      A   A                              %\n%                              T    G  GG  AAAAA                              %\n%                              T    G   G  A   A                              %\n%                              T     GGG   A   A                              %\n%                                                                             %\n%                                                                             %\n%                    Read/Write Truevision Targa Image Format                 %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2015 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colormap-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n\n/*\n  Enumerated declaractions.\n*/\ntypedef enum\n{\n  TGAColormap = 1,\n  TGARGB = 2,\n  TGAMonochrome = 3,\n  TGARLEColormap = 9,\n  TGARLERGB = 10,\n  TGARLEMonochrome = 11\n} TGAImageType;\n\n/*\n  Typedef declaractions.\n*/\ntypedef struct _TGAInfo\n{\n  TGAImageType\n    image_type;\n\n  unsigned char\n    id_length,\n    colormap_type;\n\n  unsigned short\n    colormap_index,\n    colormap_length;\n\n  unsigned char\n    colormap_size;\n\n  unsigned short\n    x_origin,\n    y_origin,\n    width,\n    height;\n\n  unsigned char\n    bits_per_pixel,\n    attributes;\n} TGAInfo;\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WriteTGAImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d T G A I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadTGAImage() reads a Truevision TGA image file and returns it.\n%  It allocates the memory necessary for the new Image structure and returns\n%  a pointer to the new image.\n%\n%  The format of the ReadTGAImage method is:\n%\n%      Image *ReadTGAImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadTGAImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  PixelInfo\n    pixel;\n\n  Quantum\n    index;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  size_t\n    base,\n    flag,\n    offset,\n    real,\n    skip;\n\n  ssize_t\n    count,\n    y;\n\n  TGAInfo\n    tga_info;\n\n  unsigned char\n    j,\n    k,\n    pixels[4],\n    runlength;\n\n  unsigned int\n    alpha_bits;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read TGA header information.\n  */\n  count=ReadBlob(image,1,&tga_info.id_length);\n  tga_info.colormap_type=(unsigned char) ReadBlobByte(image);\n  tga_info.image_type=(TGAImageType) ReadBlobByte(image);\n  if ((count != 1) ||\n      ((tga_info.image_type != TGAColormap) &&\n       (tga_info.image_type != TGARGB) &&\n       (tga_info.image_type != TGAMonochrome) &&\n       (tga_info.image_type != TGARLEColormap) &&\n       (tga_info.image_type != TGARLERGB) &&\n       (tga_info.image_type != TGARLEMonochrome)) ||\n      (((tga_info.image_type == TGAColormap) ||\n       (tga_info.image_type == TGARLEColormap)) &&\n       (tga_info.colormap_type == 0)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  tga_info.colormap_index=ReadBlobLSBShort(image);\n  tga_info.colormap_length=ReadBlobLSBShort(image);\n  tga_info.colormap_size=(unsigned char) ReadBlobByte(image);\n  tga_info.x_origin=ReadBlobLSBShort(image);\n  tga_info.y_origin=ReadBlobLSBShort(image);\n  tga_info.width=(unsigned short) ReadBlobLSBShort(image);\n  tga_info.height=(unsigned short) ReadBlobLSBShort(image);\n  tga_info.bits_per_pixel=(unsigned char) ReadBlobByte(image);\n  tga_info.attributes=(unsigned char) ReadBlobByte(image);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n  if ((((tga_info.bits_per_pixel <= 1) || (tga_info.bits_per_pixel >= 17)) &&\n       (tga_info.bits_per_pixel != 24) && (tga_info.bits_per_pixel != 32)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  /*\n    Initialize image structure.\n  */\n  image->columns=tga_info.width;\n  image->rows=tga_info.height;\n  alpha_bits=(tga_info.attributes & 0x0FU);\n  image->alpha_trait=(alpha_bits > 0) || (tga_info.bits_per_pixel == 32) ||\n    (tga_info.colormap_size == 32) ?  BlendPixelTrait : UndefinedPixelTrait;\n  if ((tga_info.image_type != TGAColormap) &&\n      (tga_info.image_type != TGARLEColormap))\n    image->depth=(size_t) ((tga_info.bits_per_pixel <= 8) ? 8 :\n      (tga_info.bits_per_pixel <= 16) ? 5 :\n      (tga_info.bits_per_pixel == 24) ? 8 :\n      (tga_info.bits_per_pixel == 32) ? 8 : 8);\n  else\n    image->depth=(size_t) ((tga_info.colormap_size <= 8) ? 8 :\n      (tga_info.colormap_size <= 16) ? 5 :\n      (tga_info.colormap_size == 24) ? 8 :\n      (tga_info.colormap_size == 32) ? 8 : 8);\n  if ((tga_info.image_type == TGAColormap) ||\n      (tga_info.image_type == TGAMonochrome) ||\n      (tga_info.image_type == TGARLEColormap) ||\n      (tga_info.image_type == TGARLEMonochrome))\n    image->storage_class=PseudoClass;\n  image->compression=NoCompression;\n  if ((tga_info.image_type == TGARLEColormap) ||\n      (tga_info.image_type == TGARLEMonochrome) ||\n      (tga_info.image_type == TGARLERGB))\n    image->compression=RLECompression;\n  if (image->storage_class == PseudoClass)\n    {\n      if (tga_info.colormap_type != 0)\n        image->colors=tga_info.colormap_index+tga_info.colormap_length;\n      else\n        {\n          size_t\n            one;\n\n          one=1;\n          image->colors=one << tga_info.bits_per_pixel;\n          if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n    }\n  if (tga_info.id_length != 0)\n    {\n      char\n        *comment;\n\n      size_t\n        length;\n\n      /*\n        TGA image comment.\n      */\n      length=(size_t) tga_info.id_length;\n      comment=(char *) NULL;\n      if (~length >= (MagickPathExtent-1))\n        comment=(char *) AcquireQuantumMemory(length+MagickPathExtent,\n          sizeof(*comment));\n      if (comment == (char *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      count=ReadBlob(image,tga_info.id_length,(unsigned char *) comment);\n      comment[tga_info.id_length]='\\0';\n      (void) SetImageProperty(image,\"comment\",comment,exception);\n      comment=DestroyString(comment);\n    }\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(image);\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  (void) ResetMagickMemory(&pixel,0,sizeof(pixel));\n  pixel.alpha=(MagickRealType) OpaqueAlpha;\n  if (tga_info.colormap_type != 0)\n    {\n      /*\n        Read TGA raster colormap.\n      */\n      if (image->colors < tga_info.colormap_index)\n        image->colors=tga_info.colormap_index;\n      if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      for (i=0; i < (ssize_t) tga_info.colormap_index; i++)\n        image->colormap[i]=pixel;\n      for ( ; i < (ssize_t) image->colors; i++)\n      {\n        switch (tga_info.colormap_size)\n        {\n          case 8:\n          default:\n          {\n            /*\n              Gray scale.\n            */\n            pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            pixel.green=pixel.red;\n            pixel.blue=pixel.red;\n            break;\n          }\n          case 15:\n          case 16:\n          {\n            QuantumAny\n              range;\n\n            /*\n              5 bits each of red green and blue.\n            */\n            j=(unsigned char) ReadBlobByte(image);\n            k=(unsigned char) ReadBlobByte(image);\n            range=GetQuantumRange(5UL);\n            pixel.red=(MagickRealType) ScaleAnyToQuantum(1UL*(k & 0x7c) >> 2,\n              range);\n            pixel.green=(MagickRealType) ScaleAnyToQuantum((1UL*(k & 0x03)\n              << 3)+(1UL*(j & 0xe0) >> 5),range);\n            pixel.blue=(MagickRealType) ScaleAnyToQuantum(1UL*(j & 0x1f),range);\n            break;\n          }\n          case 24:\n          {\n            /*\n              8 bits each of blue, green and red.\n            */\n            pixel.blue=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            pixel.green=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            break;\n          }\n          case 32:\n          {\n            /*\n              8 bits each of blue, green, red, and alpha.\n            */\n            pixel.blue=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            pixel.green=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            pixel.alpha=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            break;\n          }\n        }\n        image->colormap[i]=pixel;\n      }\n    }\n  /*\n    Convert TGA pixels to pixel packets.\n  */\n  base=0;\n  flag=0;\n  skip=MagickFalse;\n  real=0;\n  index=0;\n  runlength=0;\n  offset=0;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    real=offset;\n    if (((unsigned char) (tga_info.attributes & 0x20) >> 5) == 0)\n      real=image->rows-real-1;\n    q=QueueAuthenticPixels(image,0,(ssize_t) real,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if ((tga_info.image_type == TGARLEColormap) ||\n          (tga_info.image_type == TGARLERGB) ||\n          (tga_info.image_type == TGARLEMonochrome))\n        {\n          if (runlength != 0)\n            {\n              runlength--;\n              skip=flag != 0;\n            }\n          else\n            {\n              count=ReadBlob(image,1,&runlength);\n              if (count != 1)\n                ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n              flag=runlength & 0x80;\n              if (flag != 0)\n                runlength-=128;\n              skip=MagickFalse;\n            }\n        }\n      if (skip == MagickFalse)\n        switch (tga_info.bits_per_pixel)\n        {\n          case 8:\n          default:\n          {\n            /*\n              Gray scale.\n            */\n            index=(Quantum) ReadBlobByte(image);\n            if (tga_info.colormap_type != 0)\n              pixel=image->colormap[(ssize_t) ConstrainColormapIndex(image,\n                (ssize_t) index,exception)];\n            else\n              {\n                pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)\n                  index);\n                pixel.green=(MagickRealType) ScaleCharToQuantum((unsigned char)\n                  index);\n                pixel.blue=(MagickRealType) ScaleCharToQuantum((unsigned char)\n                  index);\n              }\n            break;\n          }\n          case 15:\n          case 16:\n          {\n            QuantumAny\n              range;\n\n            /*\n              5 bits each of RGB.\n            */\n            if (ReadBlob(image,2,pixels) != 2)\n              ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n            j=pixels[0];\n            k=pixels[1];\n            range=GetQuantumRange(5UL);\n            pixel.red=(MagickRealType) ScaleAnyToQuantum(1UL*(k & 0x7c) >> 2,\n              range);\n            pixel.green=(MagickRealType) ScaleAnyToQuantum((1UL*\n              (k & 0x03) << 3)+(1UL*(j & 0xe0) >> 5),range);\n            pixel.blue=(MagickRealType) ScaleAnyToQuantum(1UL*(j & 0x1f),range);\n            if (image->alpha_trait != UndefinedPixelTrait)\n              pixel.alpha=(MagickRealType) ((k & 0x80) == 0 ? (Quantum)\n                TransparentAlpha : (Quantum) OpaqueAlpha);\n            if (image->storage_class == PseudoClass)\n              index=(Quantum) ConstrainColormapIndex(image,((ssize_t) (k << 8))+\n                j,exception);\n            break;\n          }\n          case 24:\n          {\n            /*\n              BGR pixels.\n            */\n            if (ReadBlob(image,3,pixels) != 3)\n              ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n            pixel.blue=(MagickRealType) ScaleCharToQuantum(pixels[0]);\n            pixel.green=(MagickRealType) ScaleCharToQuantum(pixels[1]);\n            pixel.red=(MagickRealType) ScaleCharToQuantum(pixels[2]);\n            break;\n          }\n          case 32:\n          {\n            /*\n              BGRA pixels.\n            */\n            if (ReadBlob(image,4,pixels) != 4)\n              ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n            pixel.blue=(MagickRealType) ScaleCharToQuantum(pixels[0]);\n            pixel.green=(MagickRealType) ScaleCharToQuantum(pixels[1]);\n            pixel.red=(MagickRealType) ScaleCharToQuantum(pixels[2]);\n            pixel.alpha=(MagickRealType) ScaleCharToQuantum(pixels[3]);\n            break;\n          }\n        }\n      if (status == MagickFalse)\n        ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n      if (image->storage_class == PseudoClass)\n        SetPixelIndex(image,index,q);\n      SetPixelRed(image,ClampToQuantum(pixel.red),q);\n      SetPixelGreen(image,ClampToQuantum(pixel.green),q);\n      SetPixelBlue(image,ClampToQuantum(pixel.blue),q);\n      if (image->alpha_trait != UndefinedPixelTrait)\n        SetPixelAlpha(image,ClampToQuantum(pixel.alpha),q);\n      q+=GetPixelChannels(image);\n    }\n    /*\n      if (((unsigned char) (tga_info.attributes & 0xc0) >> 6) == 4)\n        offset+=4;\n      else\n    */\n      if (((unsigned char) (tga_info.attributes & 0xc0) >> 6) == 2)\n        offset+=2;\n      else\n        offset++;\n    if (offset >= image->rows)\n      {\n        base++;\n        offset=base;\n      }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r T G A I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterTGAImage() adds properties for the TGA image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterTGAImage method is:\n%\n%      size_t RegisterTGAImage(void)\n%\n*/\nModuleExport size_t RegisterTGAImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"TGA\",\"ICB\",\"Truevision Targa image\");\n  entry->decoder=(DecodeImageHandler *) ReadTGAImage;\n  entry->encoder=(EncodeImageHandler *) WriteTGAImage;\n  entry->flags^=CoderAdjoinFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TGA\",\"TGA\",\"Truevision Targa image\");\n  entry->decoder=(DecodeImageHandler *) ReadTGAImage;\n  entry->encoder=(EncodeImageHandler *) WriteTGAImage;\n  entry->flags^=CoderAdjoinFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TGA\",\"VDA\",\"Truevision Targa image\");\n  entry->decoder=(DecodeImageHandler *) ReadTGAImage;\n  entry->encoder=(EncodeImageHandler *) WriteTGAImage;\n  entry->flags^=CoderAdjoinFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"TGA\",\"VST\",\"Truevision Targa image\");\n  entry->decoder=(DecodeImageHandler *) ReadTGAImage;\n  entry->encoder=(EncodeImageHandler *) WriteTGAImage;\n  entry->flags^=CoderAdjoinFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r T G A I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterTGAImage() removes format registrations made by the\n%  TGA module from the list of supported formats.\n%\n%  The format of the UnregisterTGAImage method is:\n%\n%      UnregisterTGAImage(void)\n%\n*/\nModuleExport void UnregisterTGAImage(void)\n{\n  (void) UnregisterMagickInfo(\"ICB\");\n  (void) UnregisterMagickInfo(\"TGA\");\n  (void) UnregisterMagickInfo(\"VDA\");\n  (void) UnregisterMagickInfo(\"VST\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e T G A I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteTGAImage() writes a image in the Truevision Targa rasterfile\n%  format.\n%\n%  The format of the WriteTGAImage method is:\n%\n%      MagickBooleanType WriteTGAImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n*/\nstatic inline void WriteTGAPixel(Image *image,TGAImageType image_type,\n  const Quantum *p,const QuantumAny range,const double midpoint)\n{\n  if (image_type == TGAColormap || image_type == TGARLEColormap)\n    (void) WriteBlobByte(image,(unsigned char) GetPixelIndex(image,p));\n  else\n    {\n      if (image_type == TGAMonochrome || image_type == TGARLEMonochrome)\n        (void) WriteBlobByte(image,ScaleQuantumToChar(ClampToQuantum(\n          GetPixelLuma(image,p))));\n      else\n        if (image->depth == 5)\n          {\n            unsigned char\n              green,\n              value;\n\n            green=(unsigned char) ScaleQuantumToAny(GetPixelGreen(image,p),\n              range);\n            value=((unsigned char) ScaleQuantumToAny(GetPixelBlue(image,p),\n              range)) | ((green & 0x07) << 5);\n            (void) WriteBlobByte(image,value);\n            value=(((image->alpha_trait != UndefinedPixelTrait) &&\n              ((double) GetPixelAlpha(image,p) > midpoint)) ? 0x80 : 0) |\n              ((unsigned char) ScaleQuantumToAny(GetPixelRed(image,p),range) <<\n              2) | ((green & 0x18) >> 3);\n            (void) WriteBlobByte(image,value);\n          }\n        else\n          {\n            (void) WriteBlobByte(image,ScaleQuantumToChar(\n              GetPixelBlue(image,p)));\n            (void) WriteBlobByte(image,ScaleQuantumToChar(\n              GetPixelGreen(image,p)));\n            (void) WriteBlobByte(image,ScaleQuantumToChar(\n              GetPixelRed(image,p)));\n            if (image->alpha_trait != UndefinedPixelTrait)\n              (void) WriteBlobByte(image,ScaleQuantumToChar(\n                GetPixelAlpha(image,p)));\n          }\n    }\n}\n\nstatic MagickBooleanType WriteTGAImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  CompressionType\n    compression;\n\n  const char\n    *value;\n\n  const double\n    midpoint = QuantumRange/2.0;\n\n  MagickBooleanType\n    status;\n\n  QuantumAny\n    range;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    x;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *q;\n\n  size_t\n    channels;\n\n  ssize_t\n    count,\n    y;\n\n  TGAInfo\n    tga_info;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  /*\n    Initialize TGA raster file header.\n  */\n  if ((image->columns > 65535L) || (image->rows > 65535L))\n    ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n  (void) TransformImageColorspace(image,sRGBColorspace,exception);\n  compression=image->compression;\n  if (image_info->compression != UndefinedCompression)\n    compression=image_info->compression;\n  range=GetQuantumRange(5UL);\n  tga_info.id_length=0;\n  value=GetImageProperty(image,\"comment\",exception);\n  if (value != (const char *) NULL)\n    tga_info.id_length=(unsigned char) MagickMin(strlen(value),255);\n  tga_info.colormap_type=0;\n  tga_info.colormap_index=0;\n  tga_info.colormap_length=0;\n  tga_info.colormap_size=0;\n  tga_info.x_origin=0;\n  tga_info.y_origin=0;\n  tga_info.width=(unsigned short) image->columns;\n  tga_info.height=(unsigned short) image->rows;\n  tga_info.bits_per_pixel=8;\n  tga_info.attributes=0;\n  if ((image_info->type != TrueColorType) &&\n      (image_info->type != TrueColorAlphaType) &&\n      (image_info->type != PaletteType) &&\n      (image->alpha_trait == UndefinedPixelTrait) &&\n      (SetImageGray(image,exception) != MagickFalse))\n    tga_info.image_type=compression == RLECompression ? TGARLEMonochrome :\n      TGAMonochrome;\n  else\n    if ((image->storage_class == DirectClass) || (image->colors > 256))\n      {\n        /*\n          Full color TGA raster.\n        */\n        tga_info.image_type=compression == RLECompression ? TGARLERGB : TGARGB;\n        if (image_info->depth == 5)\n          {\n            tga_info.bits_per_pixel=16;\n            if (image->alpha_trait != UndefinedPixelTrait)\n              tga_info.attributes=1;  /* # of alpha bits */\n          }\n        else\n          {\n            tga_info.bits_per_pixel=24;\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                tga_info.bits_per_pixel=32;\n                tga_info.attributes=8;  /* # of alpha bits */\n              }\n          }\n      }\n    else\n      {\n        /*\n          Colormapped TGA raster.\n        */\n        tga_info.image_type=compression == RLECompression ? TGARLEColormap :\n          TGAColormap;\n        tga_info.colormap_type=1;\n        tga_info.colormap_length=(unsigned short) image->colors;\n        if (image_info->depth == 5)\n          tga_info.colormap_size=16;\n        else\n          tga_info.colormap_size=24;\n      }\n  /*\n    Write TGA header.\n  */\n  (void) WriteBlobByte(image,tga_info.id_length);\n  (void) WriteBlobByte(image,tga_info.colormap_type);\n  (void) WriteBlobByte(image,(unsigned char) tga_info.image_type);\n  (void) WriteBlobLSBShort(image,tga_info.colormap_index);\n  (void) WriteBlobLSBShort(image,tga_info.colormap_length);\n  (void) WriteBlobByte(image,tga_info.colormap_size);\n  (void) WriteBlobLSBShort(image,tga_info.x_origin);\n  (void) WriteBlobLSBShort(image,tga_info.y_origin);\n  (void) WriteBlobLSBShort(image,tga_info.width);\n  (void) WriteBlobLSBShort(image,tga_info.height);\n  (void) WriteBlobByte(image,tga_info.bits_per_pixel);\n  (void) WriteBlobByte(image,tga_info.attributes);\n  if (tga_info.id_length != 0)\n    (void) WriteBlob(image,tga_info.id_length,(unsigned char *) value);\n  if (tga_info.colormap_type != 0)\n    {\n      unsigned char\n        green,\n        *targa_colormap;\n\n      /*\n        Dump colormap to file (blue, green, red byte order).\n      */\n      targa_colormap=(unsigned char *) AcquireQuantumMemory((size_t)\n        tga_info.colormap_length,(tga_info.colormap_size/8)*\n        sizeof(*targa_colormap));\n      if (targa_colormap == (unsigned char *) NULL)\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      q=targa_colormap;\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        if (image_info->depth == 5)\n          {\n            green=(unsigned char) ScaleQuantumToAny(ClampToQuantum(\n              image->colormap[i].green),range);\n            *q++=((unsigned char) ScaleQuantumToAny(ClampToQuantum(\n              image->colormap[i].blue),range)) | ((green & 0x07) << 5);\n            *q++=(((image->alpha_trait != UndefinedPixelTrait) && ((double)\n              ClampToQuantum(image->colormap[i].alpha) > midpoint)) ? 0x80 : 0) |\n              ((unsigned char) ScaleQuantumToAny(ClampToQuantum(\n              image->colormap[i].red),range) << 2) | ((green & 0x18) >> 3);\n          }\n        else\n          {\n            *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].blue));\n            *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].green));\n            *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].red));\n          }\n      }\n      (void) WriteBlob(image,(size_t) ((tga_info.colormap_size/8)*\n        tga_info.colormap_length),targa_colormap);\n      targa_colormap=(unsigned char *) RelinquishMagickMemory(targa_colormap);\n    }\n  /*\n    Convert MIFF to TGA raster pixels.\n  */\n  channels=GetPixelChannels(image);\n  for (y=(ssize_t) (image->rows-1); y >= 0; y--)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    if (compression == RLECompression)\n      {\n        x=0;\n        count=0;\n        while (x < (ssize_t) image->columns)\n        {\n          i=1;\n          while ((i < 128) && (count + i < 128) &&\n                 ((x + i) < (ssize_t) image->columns))\n          {\n            if (tga_info.image_type == TGARLEColormap)\n              {\n                if (GetPixelIndex(image,p+(i*channels)) !=\n                    GetPixelIndex(image,p+((i-1)*channels)))\n                  break;\n              }\n            else if (tga_info.image_type == TGARLEMonochrome)\n              {\n                if (GetPixelLuma(image,p+(i*channels)) !=\n                    GetPixelLuma(image,p+((i-1)*channels)))\n                  break;\n              }\n            else\n              {\n                if ((GetPixelBlue(image,p+(i*channels)) !=\n                     GetPixelBlue(image,p+((i-1)*channels))) ||\n                    (GetPixelGreen(image,p+(i*channels)) !=\n                     GetPixelGreen(image,p+((i-1)*channels))) ||\n                    (GetPixelRed(image,p+(i*channels)) !=\n                     GetPixelRed(image,p+((i-1)*channels))))\n                  break;\n                if ((image->alpha_trait != UndefinedPixelTrait) &&\n                    (GetPixelAlpha(image,p+(i*channels)) !=\n                     GetPixelAlpha(image,p+(i-1)*channels)))\n                  break;\n              }\n            i++;\n          }\n          if (i < 3)\n            {\n              count+=i;\n              p+=(i*channels);\n            }\n          if ((i >= 3) || (count == 128) ||\n              ((x + i) == (ssize_t) image->columns))\n            {\n              if (count > 0)\n                {\n                  (void) WriteBlobByte(image,(unsigned char) (--count));\n                  while (count >= 0)\n                  {\n                    WriteTGAPixel(image,tga_info.image_type,p-((count+1)*\n                      channels),range,midpoint);\n                    count--;\n                  }\n                  count=0;\n                }\n            }\n          if (i >= 3)\n            {\n              (void) WriteBlobByte(image,(unsigned char) ((i-1) | 0x80));\n              WriteTGAPixel(image,tga_info.image_type,p,range,midpoint);\n              p+=(i*channels);\n            }\n          x+=i;\n        }\n      }\n    else\n      {\n        for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            WriteTGAPixel(image,tga_info.image_type,p,range,midpoint);\n            p+=channels;\n          }\n      }\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "filenames": ["coders/tga.c"], "buggy_code_start_loc": [320], "buggy_code_end_loc": [320], "fixing_code_start_loc": [321], "fixing_code_end_loc": [323], "type": "CWE-415", "message": "Double free vulnerability in coders/tga.c in ImageMagick 7.0.0 and later allows remote attackers to cause a denial of service (application crash) via a crafted tga file.", "other": {"cve": {"id": "CVE-2015-8894", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-15T19:59:00.143", "lastModified": "2017-03-17T12:22:45.017", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Double free vulnerability in coders/tga.c in ImageMagick 7.0.0 and later allows remote attackers to cause a denial of service (application crash) via a crafted tga file."}, {"lang": "es", "value": "Vulnerabilidad de liberaci\u00f3n doble en coders/tga.c en ImageMagick 7.0.0 y versiones posteriores permite a atacantes remotos provocar una denegaci\u00f3n de servicio (ca\u00edda de la aplicaci\u00f3n) a trav\u00e9s de un archivo tga manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-415"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-0:*:*:*:*:*:*:*", "matchCriteriaId": "693C9F8F-A8C1-4D06-8F31-E085E16E701C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-1:*:*:*:*:*:*:*", "matchCriteriaId": "6D3D3DFC-8459-41BA-BF3E-AE84E48FCEE7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-2:*:*:*:*:*:*:*", "matchCriteriaId": "A3E12EB4-B8F6-43A3-847D-DBC96AE10905"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-3:*:*:*:*:*:*:*", "matchCriteriaId": "30539421-5872-4C2E-94AE-8A2B05C952C0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-4:*:*:*:*:*:*:*", "matchCriteriaId": "1A5B7537-8563-409D-82DE-EB07107D3C04"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-5:*:*:*:*:*:*:*", "matchCriteriaId": "FA648D3C-A464-4F54-8B5E-E8431531FBB5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-6:*:*:*:*:*:*:*", "matchCriteriaId": "D6666BB0-B211-490F-884C-BE410CD19DAF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-7:*:*:*:*:*:*:*", "matchCriteriaId": "5FF2582D-1513-448B-8B61-9C4844B08324"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-8:*:*:*:*:*:*:*", "matchCriteriaId": "E57E6BA4-A727-4CF5-B15F-76632D02617A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-9:*:*:*:*:*:*:*", "matchCriteriaId": "C721BC6F-61DD-4ED1-8024-2946C494AEC4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-10:*:*:*:*:*:*:*", "matchCriteriaId": "CD319D32-FE7A-456D-AFEE-DC9F0D98652C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-0:*:*:*:*:*:*:*", "matchCriteriaId": "09CDF263-38F5-469F-984B-9D9A223159B3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-1:*:*:*:*:*:*:*", "matchCriteriaId": "243FF3C1-D676-4D5F-A90C-3017DCBBE73A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-2:*:*:*:*:*:*:*", "matchCriteriaId": "1B8BDDE6-6B38-442B-83A4-FAADBAE1C792"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-3:*:*:*:*:*:*:*", "matchCriteriaId": "4DCD89B9-6A69-41DE-BE38-5E9193828279"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-4:*:*:*:*:*:*:*", "matchCriteriaId": "139BC277-8E00-4700-8B47-6D3A3CB38B04"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-5:*:*:*:*:*:*:*", "matchCriteriaId": "D0FA2E18-6F7B-49D6-B60C-38851398F9B7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-6:*:*:*:*:*:*:*", "matchCriteriaId": "7B7F510A-A439-47A3-AF31-4BF7F74D58A5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-7:*:*:*:*:*:*:*", "matchCriteriaId": "A91B94E3-33BB-46B6-A1AE-EAA9906605CF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-8:*:*:*:*:*:*:*", "matchCriteriaId": "F5B3DE17-08A8-457D-9AEB-BD6E04376B34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-9:*:*:*:*:*:*:*", "matchCriteriaId": "98AD438E-28B7-4491-B58F-55FDE7F67CFD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-10:*:*:*:*:*:*:*", "matchCriteriaId": "7E033A09-4F2F-4957-A9A8-5C9E7D90A1CA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-0:*:*:*:*:*:*:*", "matchCriteriaId": "BB9B68E7-0E40-437A-A71B-0C078FE76FD8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-1:*:*:*:*:*:*:*", "matchCriteriaId": "948D5778-AD2A-4293-AE39-A406D75F5678"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-2:*:*:*:*:*:*:*", "matchCriteriaId": "D391DECE-2408-4A8F-ACE6-F18028C422A3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-3:*:*:*:*:*:*:*", "matchCriteriaId": "CC773CB4-0E7B-4D73-AB9C-D7CC98C38BD7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-4:*:*:*:*:*:*:*", "matchCriteriaId": "24A0C584-9DA3-48B0-B152-67B9E0239876"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-5:*:*:*:*:*:*:*", "matchCriteriaId": "E42943C5-CC66-4E88-9085-1BD39937C09B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-6:*:*:*:*:*:*:*", "matchCriteriaId": "E396985D-BE6A-4F4C-B294-FE69724534EF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-7:*:*:*:*:*:*:*", "matchCriteriaId": "D1D84944-322C-4B5D-9B1C-587301747A34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-8:*:*:*:*:*:*:*", "matchCriteriaId": "B48F5327-CA20-4756-A06F-B30B660E8DA7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-9:*:*:*:*:*:*:*", "matchCriteriaId": "84C11EC2-C798-4C3B-8E00-9C70C3499B33"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-10:*:*:*:*:*:*:*", "matchCriteriaId": "D30A3BD6-5903-42D6-A1E3-C6D2FE468A1E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-0:*:*:*:*:*:*:*", "matchCriteriaId": "441F9FAE-11FA-4976-8BB3-4A3A79B57663"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-1:*:*:*:*:*:*:*", "matchCriteriaId": "F4389D4A-8AD4-421E-AD4D-6761F45B7F6B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-2:*:*:*:*:*:*:*", "matchCriteriaId": "1620AF57-49AF-4487-80A1-07627F50F817"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-3:*:*:*:*:*:*:*", "matchCriteriaId": "DF373D13-0AB1-4518-AFFE-D09A5F56E992"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-4:*:*:*:*:*:*:*", "matchCriteriaId": "86483865-BFC3-4845-80DE-A6AC632A92A2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-5:*:*:*:*:*:*:*", "matchCriteriaId": "2A147E12-E5D4-400E-9432-BB5BCF2352CE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-6:*:*:*:*:*:*:*", "matchCriteriaId": "B1F2BF9D-9821-424E-8F06-BFB637C103A7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-7:*:*:*:*:*:*:*", "matchCriteriaId": "26D7231D-442B-4E7C-BCB2-EE8D787FD46D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-8:*:*:*:*:*:*:*", "matchCriteriaId": "749B8733-47B0-4F63-874D-62DF323CD045"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-9:*:*:*:*:*:*:*", "matchCriteriaId": "AD9D1C91-B67A-430B-AB24-DCC7DAF69D7C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.4-10:*:*:*:*:*:*:*", "matchCriteriaId": "0C5BE761-44E8-4614-BBD4-3FA7148156B0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.5-0:*:*:*:*:*:*:*", "matchCriteriaId": "79AA4723-3637-4FA7-AE60-9CEE7C535A13"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2016/06/02/13", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://bugs.launchpad.net/ubuntu/+source/imagemagick/+bug/1490362", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/4f68e9661518463fca523c9726bb5d940a2aa6d8", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/4f68e9661518463fca523c9726bb5d940a2aa6d8"}}