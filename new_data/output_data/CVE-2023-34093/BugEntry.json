{"buggy_code": ["'use strict';\n\nconst { createStrapiInstance } = require('api-tests/strapi');\n\nlet strapi;\n\ndescribe('transactions', () => {\n  let original;\n  beforeAll(async () => {\n    strapi = await createStrapiInstance();\n    original = await strapi.db\n      .queryBuilder('strapi::core-store')\n      .select(['*'])\n      .where({ id: 1 })\n      .execute();\n  });\n\n  afterAll(async () => {\n    await strapi.destroy();\n  });\n\n  afterEach(async () => {\n    await strapi.db\n      .queryBuilder('strapi::core-store')\n      .update({\n        key: original[0].key,\n      })\n      .where({ id: 1 })\n      .execute();\n  });\n\n  describe('using a transaction method', () => {\n    test('commits successfully', async () => {\n      await strapi.db.transaction(async () => {\n        await strapi.db\n          .queryBuilder('strapi::core-store')\n          .update({\n            key: 'wrong key',\n          })\n          .where({ id: 1 })\n          .execute();\n\n        await strapi.db\n          .queryBuilder('strapi::core-store')\n          .update({\n            key: 'new key',\n          })\n          .where({ id: 1 })\n          .execute();\n      });\n\n      const end = await strapi.db\n        .queryBuilder('strapi::core-store')\n        .select(['*'])\n        .where({ id: 1 })\n        .execute();\n\n      expect(end[0].key).toEqual('new key');\n    });\n\n    test('rollback successfully', async () => {\n      try {\n        await strapi.db.transaction(async () => {\n          // this is valid\n          await strapi.db\n            .queryBuilder('strapi::core-store')\n            .update({\n              key: 'wrong key',\n            })\n            .where({ id: 1 })\n            .execute();\n\n          // this throws\n          await strapi.db\n            .queryBuilder('invalid_uid')\n            .update({\n              key: 'bad key',\n              invalid_key: 'error',\n            })\n            .where({ id: 1 })\n            .execute();\n        });\n\n        expect('this should not be reached').toBe(false);\n      } catch (e) {\n        // do nothing\n      }\n\n      const end = await strapi.db\n        .queryBuilder('strapi::core-store')\n        .select(['*'])\n        .where({ id: 1 })\n        .execute();\n\n      expect(end[0].key).toEqual(original[0].key);\n    });\n\n    test('nested rollback -> rollback works', async () => {\n      try {\n        await strapi.db.transaction(async () => {\n          // this is valid\n          await strapi.db\n            .queryBuilder('strapi::core-store')\n            .update({\n              key: 'changed key',\n            })\n            .where({ id: 1 })\n            .execute();\n\n          // here we'll make a nested transaction that throws and then confirm we still have \"changed key\" from above\n          try {\n            await strapi.db.transaction(async () => {\n              await strapi.db\n                .queryBuilder('strapi::core-store')\n                .update({\n                  key: 'changed key - nested',\n                })\n                .where({ id: 1 })\n                .execute();\n\n              // this should throw and roll back\n              await strapi.db\n                .queryBuilder('invalid_uid')\n                .update({\n                  invalid_key: 'error',\n                })\n                .where({ id: 1 })\n                .execute();\n            });\n          } catch (e) {\n            // do nothing\n          }\n\n          // should equal the result from above\n          const result = await strapi.db\n            .queryBuilder('strapi::core-store')\n            .select(['*'])\n            .where({ id: 1 })\n            .execute();\n\n          expect(result[0].key).toEqual('changed key');\n\n          // this throws\n          await strapi.db\n            .queryBuilder('invalid_uid')\n            .update({\n              key: original[0].key,\n              invalid_key: 'error',\n            })\n            .where({ id: 1 })\n            .execute();\n        });\n\n        expect('this should not be reached').toBe(false);\n      } catch (e) {\n        // do nothing\n      }\n\n      const end = await strapi.db\n        .queryBuilder('strapi::core-store')\n        .select(['*'])\n        .where({ id: 1 })\n        .execute();\n\n      expect(end[0].key).toEqual(original[0].key);\n    });\n\n    test('nested commit -> rollback works', async () => {\n      try {\n        await strapi.db.transaction(async () => {\n          // this is valid\n          await strapi.db\n            .queryBuilder('strapi::core-store')\n            .update({\n              key: 'changed key',\n            })\n            .where({ id: 1 })\n            .execute();\n\n          // here we'll make a nested transaction that works, and then later we'll rollback the outer transaction\n          try {\n            await strapi.db.transaction(async () => {\n              await strapi.db\n                .queryBuilder('strapi::core-store')\n                .update({\n                  key: 'changed key - nested',\n                })\n                .where({ id: 1 })\n                .execute();\n            });\n          } catch (e) {\n            // do nothing\n          }\n\n          // should equal the result from above\n          const result = await strapi.db\n            .queryBuilder('strapi::core-store')\n            .select(['*'])\n            .where({ id: 1 })\n            .execute();\n\n          expect(result[0].key).toEqual('changed key - nested');\n\n          // this throws\n          await strapi.db\n            .queryBuilder('invalid_uid')\n            .update({\n              key: original[0].key,\n              invalid_key: 'error',\n            })\n            .where({ id: 1 })\n            .execute();\n        });\n\n        expect('this should not be reached').toBe(false);\n      } catch (e) {\n        // do nothing\n      }\n\n      const end = await strapi.db\n        .queryBuilder('strapi::core-store')\n        .select(['*'])\n        .where({ id: 1 })\n        .execute();\n\n      expect(end[0].key).toEqual(original[0].key);\n    });\n\n    test('onCommit hook works', async () => {\n      let count = 0;\n      await strapi.db.transaction(({ onCommit, onRollback }) => {\n        onCommit(() => count++);\n      });\n      expect(count).toEqual(1);\n    });\n\n    test('onRollback hook works', async () => {\n      let count = 0;\n      try {\n        await strapi.db.transaction(({ onRollback }) => {\n          onRollback(() => count++);\n          throw new Error('test');\n        });\n      } catch (e) {\n        // do nothing\n      }\n      expect(count).toEqual(1);\n    });\n  });\n\n  describe('using a transaction object', () => {\n    test('commits successfully', async () => {\n      const trx = await strapi.db.transaction();\n\n      try {\n        await strapi.db\n          .queryBuilder('strapi::core-store')\n          .update({\n            key: 'wrong key',\n          })\n          .where({ id: 1 })\n          .transacting(trx.get())\n          .execute();\n\n        await strapi.db\n          .queryBuilder('strapi::core-store')\n          .update({\n            key: original[0].key,\n          })\n          .where({ id: 1 })\n          .transacting(trx.get())\n          .execute();\n\n        await trx.commit();\n      } catch (e) {\n        await trx.rollback();\n        console.log(e.message);\n        expect('this should not be reached').toBe(false);\n      }\n\n      const end = await strapi.db\n        .queryBuilder('strapi::core-store')\n        .select(['*'])\n        .where({ id: 1 })\n        .execute();\n\n      expect(end[0].key).toEqual('strapi_content_types_schema');\n    });\n\n    test('rollback successfully', async () => {\n      const trx = await strapi.db.transaction();\n\n      try {\n        await strapi.db\n          .queryBuilder('strapi::core-store')\n          .update({\n            key: 'wrong key',\n          })\n          .where({ id: 1 })\n          .transacting(trx.get())\n          .execute();\n\n        // this query should throw because it has errors\n        await strapi.db\n          .queryBuilder('invalid_uid')\n          .update({\n            key: 123,\n            key_not_here: 'this should error',\n          })\n          .where({ id: 'this should error' })\n          .transacting(trx.get())\n          .execute();\n\n        await trx.commit();\n        expect('this should not be reached').toBe(false);\n      } catch (e) {\n        await trx.rollback();\n      }\n\n      const end = await strapi.db\n        .queryBuilder('strapi::core-store')\n        .select(['*'])\n        .where({ id: 1 })\n        .execute();\n\n      expect(end[0].key).toEqual('strapi_content_types_schema');\n    });\n  });\n});\n", "'use strict';\n\nconst { AbilityBuilder, Ability } = require('@casl/ability');\nconst { pick } = require('lodash/fp');\nconst sift = require('sift');\nconst { buildStrapiQuery } = require('../permission/permissions-manager/query-builers');\nconst createPermissionsManager = require('../permission/permissions-manager');\n\nconst allowedOperations = [\n  '$or',\n  '$and',\n  '$eq',\n  '$ne',\n  '$in',\n  '$nin',\n  '$lt',\n  '$lte',\n  '$gt',\n  '$gte',\n  '$exists',\n  '$elemMatch',\n];\n\nconst operations = pick(allowedOperations, sift);\n\nconst conditionsMatcher = (conditions) => {\n  return sift.createQueryTester(conditions, { operations });\n};\n\nconst defineAbility = (register) => {\n  const { can, build } = new AbilityBuilder(Ability);\n\n  register(can);\n\n  return build({ conditionsMatcher });\n};\n\ndescribe('Permissions Manager', () => {\n  beforeEach(() => {\n    global.strapi = {\n      getModel() {\n        return {};\n      },\n    };\n  });\n\n  describe('get Query', () => {\n    test('It should returns an empty query when no conditions are defined', async () => {\n      const ability = defineAbility((can) => can('read', 'foo'));\n      const pm = createPermissionsManager({\n        ability,\n        action: 'read',\n        model: 'foo',\n      });\n\n      expect(pm.getQuery()).toStrictEqual({});\n    });\n\n    test('It should returns a valid query from the ability', () => {\n      const ability = defineAbility((can) => can('read', 'foo', ['bar'], { kai: 'doe' }));\n      const pm = createPermissionsManager({\n        ability,\n        action: 'read',\n        model: 'foo',\n      });\n\n      const expected = { $or: [{ kai: 'doe' }] };\n\n      expect(pm.getQuery()).toStrictEqual(expected);\n    });\n\n    test('It should throw if no action is defined', () => {\n      const ability = defineAbility((can) => can('read', 'foo', ['bar'], { kai: 'doe' }));\n      const pm = createPermissionsManager({\n        ability,\n        model: 'foo',\n      });\n\n      expect(() => pm.getQuery()).toThrowError();\n    });\n  });\n\n  describe('get isAllowed', () => {\n    const ability = defineAbility((can) => can('read', 'foo'));\n\n    test('It should grants access', () => {\n      const pm = createPermissionsManager({\n        ability,\n        action: 'read',\n        model: 'foo',\n      });\n\n      expect(pm.isAllowed).toBeTruthy();\n    });\n\n    test('It should deny access', () => {\n      const pm = createPermissionsManager({\n        ability,\n        action: 'read',\n        model: 'bar',\n      });\n\n      expect(pm.isAllowed).toBeFalsy();\n    });\n  });\n\n  describe('toSubject', () => {\n    global.strapi = {\n      getModel() {\n        return {};\n      },\n    };\n\n    const attr = '__caslSubjectType__';\n    const ability = defineAbility((can) => can('read', 'foo'));\n    const pm = createPermissionsManager({\n      ability,\n      action: 'read',\n      model: 'foo',\n    });\n\n    test('It should transform an object to a subject using default model', () => {\n      const input = { foo: 'bar' };\n      const sub = pm.toSubject(input);\n\n      expect(sub[attr]).toBeDefined();\n      expect(sub[attr]).toEqual('foo');\n      expect(sub).toStrictEqual(input);\n    });\n\n    test('It should transform an object to a subject using the given model', () => {\n      const input = { foo: 'bar' };\n      const newSubjectName = 'another_subject';\n      const sub = pm.toSubject(input, newSubjectName);\n\n      expect(sub[attr]).toBeDefined();\n      expect(sub[attr]).toEqual(newSubjectName);\n      expect(sub).toStrictEqual(input);\n    });\n  });\n\n  describe('pickPermittedFieldsOf', () => {\n    global.strapi = {\n      getModel() {\n        return {\n          privateAttributes: [],\n          attributes: {\n            title: {\n              type: 'text',\n              private: false,\n            },\n          },\n          primaryKey: 'id',\n          options: {},\n        };\n      },\n      config: {\n        get: jest.fn,\n      },\n    };\n\n    const ability = defineAbility((can) => {\n      can('read', 'article', ['title'], { title: 'foo' });\n      can('edit', 'article', ['title'], { title: { $in: ['kai', 'doe'] } });\n    });\n\n    const pm = createPermissionsManager({\n      ability,\n      action: 'read',\n      model: 'article',\n    });\n\n    test('Pick all fields (output) using default model', async () => {\n      const input = { title: 'foo' };\n      const res = await pm.pickPermittedFieldsOf(input);\n\n      expect(res).toStrictEqual(input);\n    });\n\n    test(`Pick 0 fields (output) using custom model`, async () => {\n      const input = { title: 'foo' };\n      const res = await pm.pickPermittedFieldsOf(input, { action: 'edit' });\n\n      expect(res).toStrictEqual({});\n    });\n\n    test('Sanitize an array of objects', async () => {\n      const input = [{ title: 'foo' }, { title: 'kai' }];\n      const expected = [{ title: 'foo' }, {}];\n\n      const res = await pm.pickPermittedFieldsOf(input);\n\n      expect(res).toStrictEqual(expected);\n    });\n  });\n\n  describe('addPermissionsQueryTo', () => {\n    const ability = defineAbility((can) =>\n      can('read', 'article', ['title'], { $and: [{ title: 'foo' }] })\n    );\n    const pm = createPermissionsManager({\n      ability,\n      action: 'read',\n      model: 'article',\n    });\n\n    const pmQuery = { $or: [{ $and: [{ title: 'foo' }] }] };\n\n    test('Create query from simple object', () => {\n      const query = { limit: 100 };\n      const expected = { limit: 100, filters: pmQuery };\n\n      const res = pm.addPermissionsQueryTo(query);\n\n      expect(res).toStrictEqual(expected);\n    });\n\n    test('Create query from complex object', () => {\n      const query = { limit: 100, filters: { $and: [{ a: 'b' }, { c: 'd' }] } };\n      const expected = {\n        limit: 100,\n        filters: {\n          $and: [query.filters, pmQuery],\n        },\n      };\n\n      const res = pm.addPermissionsQueryTo(query);\n\n      expect(res).toStrictEqual(expected);\n    });\n  });\n\n  describe('buildStrapiQuery', () => {\n    const tests = [\n      ['No transform', { foo: 'bar' }, { foo: 'bar' }],\n      ['Simple op', { foo: { $eq: 'bar' } }, { foo: { $eq: 'bar' } }],\n      ['Nested property', { 'foo.nested': 'bar' }, { foo: { nested: 'bar' } }],\n      [\n        'Nested property + $eq',\n        { 'foo.nested': { $eq: 'bar' } },\n        { foo: { nested: { $eq: 'bar' } } },\n      ],\n      [\n        'Nested property + $elementMatch',\n        { 'foo.nested': { $elemMatch: 'bar' } },\n        { foo: { nested: 'bar' } },\n      ],\n      [\n        'Deeply nested property',\n        { 'foo.nested.again': 'bar' },\n        { foo: { nested: { again: 'bar' } } },\n      ],\n      ['Op with array', { foo: { $in: ['bar', 'rab'] } }, { foo: { $in: ['bar', 'rab'] } }],\n      ['Removable op', { foo: { $elemMatch: { a: 'b' } } }, { foo: { a: 'b' } }],\n      [\n        'Combination of removable and basic ops',\n        { foo: { $elemMatch: { a: { $in: [1, 2, 3] } } } },\n        { foo: { a: { $in: [1, 2, 3] } } },\n      ],\n      [\n        'Decoupling of nested properties with/without op',\n        { foo: { $elemMatch: { a: { $in: [1, 2, 3] }, b: 'c' } } },\n        { foo: { a: { $in: [1, 2, 3] }, b: 'c' } },\n      ],\n      [\n        'OR op and properties decoupling',\n        { $or: [{ foo: { a: 2 } }, { foo: { b: 3 } }] },\n        { $or: [{ foo: { a: 2 } }, { foo: { b: 3 } }] },\n      ],\n      [\n        'OR op with nested properties & ops',\n        { $or: [{ foo: { a: 2 } }, { foo: { b: { $in: [1, 2, 3] } } }] },\n        { $or: [{ foo: { a: 2 } }, { foo: { b: { $in: [1, 2, 3] } } }] },\n      ],\n      [\n        'Nested OR op',\n        { $or: [{ $or: [{ a: 2 }, { a: 3 }] }] },\n        { $or: [{ $or: [{ a: 2 }, { a: 3 }] }] },\n      ],\n      [\n        'OR op with nested AND op',\n        { $or: [{ a: 2 }, [{ a: 3 }, { $or: [{ b: 1 }, { b: 4 }] }]] },\n        { $or: [{ a: 2 }, [{ a: 3 }, { $or: [{ b: 1 }, { b: 4 }] }]] },\n      ],\n      [\n        'OR op with nested AND op and nested properties',\n        { $or: [{ a: 2 }, [{ a: 3 }, { b: { c: 'foo' } }]] },\n        { $or: [{ a: 2 }, [{ a: 3 }, { b: { c: 'foo' } }]] },\n      ],\n      [\n        'Literal nested property with removable op',\n        {\n          created_by: {\n            roles: {\n              $elemMatch: {\n                id: {\n                  $in: [1, 2, 3],\n                },\n              },\n            },\n          },\n        },\n        {\n          created_by: {\n            roles: {\n              id: {\n                $in: [1, 2, 3],\n              },\n            },\n          },\n        },\n      ],\n    ];\n\n    test.each(tests)(`Test n\u00b0%#: %s`, (name, input, expected) => {\n      expect(buildStrapiQuery(input)).toStrictEqual(expected);\n    });\n  });\n});\n", "'use strict';\n\nconst { cloneDeep } = require('lodash/fp');\nconst _ = require('lodash');\nconst { hasDraftAndPublish, getPrivateAttributes } = require('@strapi/utils').contentTypes;\nconst {\n  CREATED_AT_ATTRIBUTE,\n  UPDATED_AT_ATTRIBUTE,\n  PUBLISHED_AT_ATTRIBUTE,\n  CREATED_BY_ATTRIBUTE,\n  UPDATED_BY_ATTRIBUTE,\n} = require('@strapi/utils').contentTypes.constants;\nconst { validateContentTypeDefinition } = require('./validator');\n\nconst createContentType = (uid, definition) => {\n  try {\n    validateContentTypeDefinition(definition);\n  } catch (e) {\n    throw new Error(`Content Type Definition is invalid for ${uid}'.\\n${e.errors}`);\n  }\n\n  const { schema, actions, lifecycles } = cloneDeep(definition);\n\n  // general info\n  Object.assign(schema, {\n    kind: schema.kind || 'collectionType',\n    __schema__: pickSchema(definition.schema),\n    modelType: 'contentType',\n    modelName: definition.schema.info.singularName,\n    connection: 'default',\n  });\n\n  if (uid.startsWith('api::')) {\n    Object.assign(schema, {\n      uid,\n      apiName: uid.split('::')[1].split('.')[0],\n      collectionName: schema.collectionName || schema.info.singularName,\n      globalId: getGlobalId(schema, schema.info.singularName),\n    });\n  } else if (uid.startsWith('plugin::')) {\n    const pluginName = uid.split('::')[1].split('.')[0];\n    Object.assign(schema, {\n      uid,\n      plugin: pluginName, // TODO: to be set in load-plugins.js\n      collectionName:\n        schema.collectionName || `${pluginName}_${schema.info.singularName}`.toLowerCase(),\n      globalId: getGlobalId(schema, schema.info.singularName, pluginName),\n    });\n  } else if (uid.startsWith('admin::')) {\n    Object.assign(schema, {\n      uid,\n      plugin: 'admin',\n      globalId: getGlobalId(schema, schema.info.singularName, 'admin'),\n    });\n  } else {\n    throw new Error(\n      `Incorrect Content Type UID \"${uid}\". The UID should start with api::, plugin:: or admin::.`\n    );\n  }\n\n  Object.defineProperty(schema, 'privateAttributes', {\n    get() {\n      return getPrivateAttributes(schema);\n    },\n  });\n\n  // attributes\n  Object.assign(schema.attributes, {\n    [CREATED_AT_ATTRIBUTE]: {\n      type: 'datetime',\n    },\n    // TODO: handle on edit set to new date\n    [UPDATED_AT_ATTRIBUTE]: {\n      type: 'datetime',\n    },\n  });\n\n  if (hasDraftAndPublish(schema)) {\n    schema.attributes[PUBLISHED_AT_ATTRIBUTE] = {\n      type: 'datetime',\n      configurable: false,\n      writable: true,\n      visible: false,\n    };\n  }\n\n  const isPrivate = !_.get(schema, 'options.populateCreatorFields', false);\n\n  schema.attributes[CREATED_BY_ATTRIBUTE] = {\n    type: 'relation',\n    relation: 'oneToOne',\n    target: 'admin::user',\n    configurable: false,\n    writable: false,\n    visible: false,\n    useJoinTable: false,\n    private: isPrivate,\n  };\n\n  schema.attributes[UPDATED_BY_ATTRIBUTE] = {\n    type: 'relation',\n    relation: 'oneToOne',\n    target: 'admin::user',\n    configurable: false,\n    writable: false,\n    visible: false,\n    useJoinTable: false,\n    private: isPrivate,\n  };\n\n  Object.assign(schema, { actions, lifecycles });\n\n  return schema;\n};\n\nconst getGlobalId = (model, modelName, prefix) => {\n  const globalId = prefix ? `${prefix}-${modelName}` : modelName;\n\n  return model.globalId || _.upperFirst(_.camelCase(globalId));\n};\n\nconst pickSchema = (model) => {\n  const schema = _.cloneDeep(\n    _.pick(model, [\n      'connection',\n      'collectionName',\n      'info',\n      'options',\n      'pluginOptions',\n      'attributes',\n    ])\n  );\n\n  schema.kind = model.kind || 'collectionType';\n  return schema;\n};\n\nmodule.exports = {\n  createContentType,\n};\n", "'use strict';\n\nconst createEntityService = require('..');\nconst entityValidator = require('../../entity-validator');\n\ndescribe('Entity service triggers webhooks', () => {\n  let instance;\n  const eventHub = { emit: jest.fn() };\n  let entity = { attr: 'value' };\n\n  beforeAll(() => {\n    const model = {\n      uid: 'api::test.test',\n      kind: 'singleType',\n      modelName: 'test-model',\n      privateAttributes: [],\n      attributes: {\n        attr: { type: 'string' },\n      },\n    };\n    instance = createEntityService({\n      strapi: {\n        getModel: () => model,\n      },\n      db: {\n        transaction: (cb) => cb(),\n        query: () => ({\n          count: () => 0,\n          create: ({ data }) => data,\n          update: ({ data }) => data,\n          findOne: () => entity,\n          findMany: () => [entity, entity],\n          delete: () => ({}),\n          deleteMany: () => ({}),\n        }),\n      },\n      eventHub,\n      entityValidator,\n    });\n\n    global.strapi = {\n      getModel: () => model,\n      config: {\n        get: () => [],\n      },\n    };\n  });\n\n  test('Emit event: Create', async () => {\n    // Create entity\n    await instance.create('test-model', { data: entity });\n\n    // Expect entry.create event to be emitted\n    expect(eventHub.emit).toHaveBeenCalledWith('entry.create', {\n      entry: entity,\n      model: 'test-model',\n      uid: 'api::test.test',\n    });\n\n    eventHub.emit.mockClear();\n  });\n\n  test('Emit event: Update', async () => {\n    // Update entity\n    await instance.update('test-model', 'entity-id', { data: entity });\n\n    // Expect entry.update event to be emitted\n    expect(eventHub.emit).toHaveBeenCalledWith('entry.update', {\n      entry: entity,\n      model: 'test-model',\n      uid: 'api::test.test',\n    });\n\n    eventHub.emit.mockClear();\n  });\n\n  test('Emit event: Delete', async () => {\n    // Delete entity\n    await instance.delete('test-model', 'entity-id', {});\n\n    // Expect entry.create event to be emitted\n    expect(eventHub.emit).toHaveBeenCalledWith('entry.delete', {\n      entry: entity,\n      model: 'test-model',\n      uid: 'api::test.test',\n    });\n\n    eventHub.emit.mockClear();\n  });\n\n  test('Emit event: Delete Many', async () => {\n    // Delete entity\n    await instance.deleteMany('test-model', {});\n\n    // Expect entry.create event to be emitted\n    expect(eventHub.emit).toHaveBeenCalledWith('entry.delete', {\n      entry: entity,\n      model: 'test-model',\n      uid: 'api::test.test',\n    });\n    // One event per each entity deleted\n    expect(eventHub.emit).toHaveBeenCalledTimes(2);\n\n    eventHub.emit.mockClear();\n  });\n\n  test('Do not emit event when no deleted entity', async () => {\n    entity = null;\n    // Delete non existent entity\n    await instance.delete('test-model', 'entity-id', {});\n\n    // Expect entry.create event to be emitted\n    expect(eventHub.emit).toHaveBeenCalledTimes(0);\n\n    eventHub.emit.mockClear();\n  });\n});\n", "'use strict';\n\njest.mock('bcryptjs', () => ({ hashSync: () => 'secret-password' }));\n\nconst { EventEmitter } = require('events');\nconst { ValidationError } = require('@strapi/utils').errors;\nconst createEntityService = require('..');\nconst entityValidator = require('../../entity-validator');\n\njest.mock('../../utils/upload-files', () => jest.fn(() => Promise.resolve()));\n\ndescribe('Entity service', () => {\n  global.strapi = {\n    getModel: jest.fn(() => ({})),\n    config: {\n      get() {\n        return [];\n      },\n    },\n    query: jest.fn(() => ({})),\n  };\n\n  describe('Decorator', () => {\n    test.each(['create', 'update', 'findMany', 'findOne', 'delete', 'count', 'findPage'])(\n      'Can decorate',\n      async (method) => {\n        const instance = createEntityService({\n          strapi: {},\n          db: {},\n          eventHub: new EventEmitter(),\n        });\n\n        const methodFn = jest.fn();\n        const decorator = () => ({\n          [method]: methodFn,\n        });\n\n        instance.decorate(decorator);\n\n        const args = [{}, {}];\n        await instance[method](...args);\n        expect(methodFn).toHaveBeenCalled();\n      }\n    );\n  });\n\n  describe('Find', () => {\n    test('Returns first element for single types', async () => {\n      const data = {\n        id: 1,\n        title: 'Test',\n      };\n\n      const fakeQuery = {\n        findOne: jest.fn(() => Promise.resolve(data)),\n      };\n\n      const fakeDB = {\n        query: jest.fn(() => fakeQuery),\n        transaction: (cb) => cb(),\n      };\n\n      const fakeStrapi = {\n        getModel: jest.fn(() => {\n          return { kind: 'singleType', privateAttributes: [] };\n        }),\n      };\n\n      const instance = createEntityService({\n        strapi: fakeStrapi,\n        db: fakeDB,\n        eventHub: new EventEmitter(),\n      });\n\n      const result = await instance.findMany('test-model');\n\n      expect(fakeStrapi.getModel).toHaveBeenCalledTimes(1);\n      expect(fakeStrapi.getModel).toHaveBeenCalledWith('test-model');\n\n      expect(fakeDB.query).toHaveBeenCalledWith('test-model');\n      expect(fakeQuery.findOne).toHaveBeenCalledWith({});\n      expect(result).toEqual(data);\n    });\n  });\n\n  describe('Create', () => {\n    const fakeQuery = {\n      count: jest.fn(() => 0),\n      create: jest.fn(({ data }) => ({\n        id: 1,\n        ...data,\n      })),\n      findOne: jest.fn(),\n    };\n    const fakeModels = {};\n\n    beforeAll(() => {\n      global.strapi.getModel.mockImplementation((modelName) => fakeModels[modelName]);\n      global.strapi.query.mockImplementation(() => fakeQuery);\n    });\n    beforeEach(() => {\n      jest.clearAllMocks();\n    });\n    afterAll(() => {\n      global.strapi.getModel.mockImplementation(() => ({}));\n    });\n    describe('assign default values', () => {\n      let instance;\n      const entityUID = 'api::entity.entity';\n      const relationUID = 'api::relation.relation';\n\n      beforeAll(() => {\n        const fakeEntities = {\n          [relationUID]: {\n            1: {\n              id: 1,\n              Name: 'TestRelation',\n              createdAt: '2022-09-28T15:11:22.995Z',\n              updatedAt: '2022-09-29T09:01:02.949Z',\n              publishedAt: null,\n            },\n            2: {\n              id: 2,\n              Name: 'TestRelation2',\n              createdAt: '2022-09-28T15:11:22.995Z',\n              updatedAt: '2022-09-29T09:01:02.949Z',\n              publishedAt: null,\n            },\n          },\n        };\n\n        fakeModels[entityUID] = {\n          uid: entityUID,\n          kind: 'contentType',\n          modelName: 'test-model',\n          privateAttributes: [],\n          options: {},\n          attributes: {\n            attrStringDefaultRequired: {\n              type: 'string',\n              default: 'default value',\n              required: true,\n            },\n            attrStringDefault: { type: 'string', default: 'default value' },\n            attrBoolDefaultRequired: { type: 'boolean', default: true, required: true },\n            attrBoolDefault: { type: 'boolean', default: true },\n            attrIntDefaultRequired: { type: 'integer', default: 1, required: true },\n            attrIntDefault: { type: 'integer', default: 1 },\n            attrEnumDefaultRequired: {\n              type: 'enumeration',\n              enum: ['a', 'b', 'c'],\n              default: 'a',\n              required: true,\n            },\n            attrEnumDefault: {\n              type: 'enumeration',\n              enum: ['a', 'b', 'c'],\n              default: 'b',\n            },\n            attrPassword: { type: 'password' },\n            attrRelation: {\n              type: 'relation',\n              relation: 'oneToMany',\n              target: relationUID,\n              mappedBy: 'entity',\n            },\n          },\n        };\n        fakeModels[relationUID] = {\n          uid: relationUID,\n          kind: 'contentType',\n          modelName: 'relation',\n          attributes: {\n            Name: {\n              type: 'string',\n              default: 'default value',\n              required: true,\n            },\n          },\n        };\n        const fakeQuery = (uid) => ({\n          create: jest.fn(({ data }) => data),\n          count: jest.fn(({ where }) => {\n            return where.id.$in.filter((id) => Boolean(fakeEntities[uid][id])).length;\n          }),\n        });\n\n        const fakeDB = {\n          transaction: (cb) => cb(),\n          query: jest.fn((uid) => fakeQuery(uid)),\n        };\n\n        global.strapi.db = fakeDB;\n\n        instance = createEntityService({\n          strapi: global.strapi,\n          db: fakeDB,\n          eventHub: new EventEmitter(),\n          entityValidator,\n        });\n      });\n      afterAll(() => {\n        global.strapi.db = {\n          query: jest.fn(() => fakeQuery),\n        };\n      });\n      test('should create record with all default attributes', async () => {\n        const data = {};\n\n        await expect(instance.create(entityUID, { data })).resolves.toMatchObject({\n          attrStringDefaultRequired: 'default value',\n          attrStringDefault: 'default value',\n          attrBoolDefaultRequired: true,\n          attrBoolDefault: true,\n          attrIntDefaultRequired: 1,\n          attrIntDefault: 1,\n          attrEnumDefaultRequired: 'a',\n          attrEnumDefault: 'b',\n        });\n      });\n\n      test('should create record with default and required attributes', async () => {\n        const data = {\n          attrStringDefault: 'my value',\n          attrBoolDefault: false,\n          attrIntDefault: 2,\n          attrEnumDefault: 'c',\n        };\n\n        await expect(instance.create(entityUID, { data })).resolves.toMatchObject({\n          attrStringDefault: 'my value',\n          attrBoolDefault: false,\n          attrIntDefault: 2,\n          attrEnumDefault: 'c',\n          attrStringDefaultRequired: 'default value',\n          attrBoolDefaultRequired: true,\n          attrIntDefaultRequired: 1,\n          attrEnumDefaultRequired: 'a',\n        });\n      });\n\n      test('should create record with provided data', async () => {\n        const data = {\n          attrStringDefaultRequired: 'my value',\n          attrStringDefault: 'my value',\n          attrBoolDefaultRequired: true,\n          attrBoolDefault: true,\n          attrIntDefaultRequired: 10,\n          attrIntDefault: 10,\n          attrEnumDefaultRequired: 'c',\n          attrEnumDefault: 'a',\n          attrPassword: 'fooBar',\n        };\n\n        await expect(instance.create(entityUID, { data })).resolves.toMatchObject({\n          ...data,\n          attrPassword: 'secret-password',\n        });\n      });\n\n      test('should create record with valid relation', async () => {\n        const data = {\n          attrStringDefaultRequired: 'my value',\n          attrStringDefault: 'my value',\n          attrBoolDefaultRequired: true,\n          attrBoolDefault: true,\n          attrIntDefaultRequired: 10,\n          attrIntDefault: 10,\n          attrEnumDefaultRequired: 'c',\n          attrEnumDefault: 'a',\n          attrPassword: 'fooBar',\n          attrRelation: {\n            connect: [\n              {\n                id: 1,\n              },\n            ],\n          },\n        };\n\n        const res = instance.create(entityUID, { data });\n\n        await expect(res).resolves.toMatchObject({\n          ...data,\n          attrPassword: 'secret-password',\n        });\n      });\n\n      test('should fail to create a record with an invalid relation', async () => {\n        const data = {\n          attrStringDefaultRequired: 'my value',\n          attrStringDefault: 'my value',\n          attrBoolDefaultRequired: true,\n          attrBoolDefault: true,\n          attrIntDefaultRequired: 10,\n          attrIntDefault: 10,\n          attrEnumDefaultRequired: 'c',\n          attrEnumDefault: 'a',\n          attrPassword: 'fooBar',\n          attrRelation: {\n            connect: [\n              {\n                id: 3,\n              },\n            ],\n          },\n        };\n\n        const res = instance.create(entityUID, { data });\n        await expect(res).rejects.toThrowError(\n          new ValidationError(\n            `1 relation(s) of type api::relation.relation associated with this entity do not exist`\n          )\n        );\n      });\n    });\n\n    describe('with files', () => {\n      let instance;\n      beforeAll(() => {\n        fakeModels['test-model'] = {\n          uid: 'test-model',\n          kind: 'collectionType',\n          collectionName: 'test-model',\n          options: {},\n          attributes: {\n            name: {\n              type: 'string',\n            },\n            activity: {\n              displayName: 'activity',\n              type: 'component',\n              repeatable: true,\n              component: 'basic.activity',\n            },\n          },\n          modelType: 'contentType',\n          modelName: 'test-model',\n        };\n        fakeModels['basic.activity'] = {\n          collectionName: 'components_basic_activities',\n          info: {\n            displayName: 'activity',\n          },\n          options: {},\n          attributes: {\n            docs: {\n              allowedTypes: ['images', 'files', 'videos', 'audios'],\n              type: 'media',\n              multiple: true,\n            },\n            name: {\n              type: 'string',\n            },\n          },\n          uid: 'basic.activity',\n          category: 'basic',\n          modelType: 'component',\n          modelName: 'activity',\n          globalId: 'ComponentBasicActivity',\n        };\n\n        const fakeDB = {\n          query: jest.fn(() => fakeQuery),\n        };\n\n        const fakeStrapi = {\n          getModel: jest.fn((modelName) => fakeModels[modelName]),\n          query: jest.fn(() => fakeQuery),\n          db: {\n            dialect: {\n              client: 'sqlite',\n            },\n          },\n        };\n\n        global.strapi = fakeStrapi;\n\n        instance = createEntityService({\n          strapi: fakeStrapi,\n          db: fakeDB,\n          eventHub: new EventEmitter(),\n          entityValidator,\n        });\n      });\n      test('should create record with attached files', async () => {\n        const uploadFiles = require('../../utils/upload-files');\n        const data = {\n          name: 'demoEvent',\n          activity: [{ name: 'Powering the Aviation of the Future' }],\n        };\n        const files = {\n          'activity.0.docs': {\n            size: 381924,\n            path: '/tmp/upload_4cab76a3a443b584a1fd3aa52e045130',\n            name: 'thisisajpeg.jpeg',\n            type: 'image/jpeg',\n            mtime: '2022-11-03T13:36:51.764Z',\n          },\n        };\n\n        fakeQuery.findOne.mockResolvedValue({ id: 1, ...data });\n\n        await instance.create('test-model', { data, files });\n\n        expect(global.strapi.getModel).toBeCalled();\n        expect(uploadFiles).toBeCalled();\n        expect(uploadFiles).toBeCalledTimes(1);\n        expect(uploadFiles).toBeCalledWith(\n          'test-model',\n          {\n            id: 1,\n            name: 'demoEvent',\n            activity: [\n              {\n                id: 1,\n                __pivot: {\n                  field: 'activity',\n                  component_type: 'basic.activity',\n                },\n              },\n            ],\n          },\n          files\n        );\n      });\n    });\n  });\n\n  describe('Update', () => {\n    describe('assign default values', () => {\n      let instance;\n\n      const entityUID = 'api::entity.entity';\n      const relationUID = 'api::relation.relation';\n\n      const fakeEntities = {\n        [entityUID]: {\n          0: {\n            id: 0,\n            Name: 'TestEntity',\n            createdAt: '2022-09-28T15:11:22.995Z',\n            updatedAt: '2022-09-29T09:01:02.949Z',\n            publishedAt: null,\n          },\n        },\n        [relationUID]: {\n          1: {\n            id: 1,\n            Name: 'TestRelation',\n            createdAt: '2022-09-28T15:11:22.995Z',\n            updatedAt: '2022-09-29T09:01:02.949Z',\n            publishedAt: null,\n          },\n          2: {\n            id: 2,\n            Name: 'TestRelation2',\n            createdAt: '2022-09-28T15:11:22.995Z',\n            updatedAt: '2022-09-29T09:01:02.949Z',\n            publishedAt: null,\n          },\n        },\n      };\n      const fakeModels = {\n        [entityUID]: {\n          kind: 'collectionType',\n          modelName: 'entity',\n          collectionName: 'entity',\n          uid: entityUID,\n          privateAttributes: [],\n          options: {},\n          info: {\n            singularName: 'entity',\n            pluralName: 'entities',\n            displayName: 'ENTITY',\n          },\n          attributes: {\n            Name: {\n              type: 'string',\n            },\n            addresses: {\n              type: 'relation',\n              relation: 'oneToMany',\n              target: relationUID,\n              mappedBy: 'entity',\n            },\n          },\n        },\n        [relationUID]: {\n          kind: 'contentType',\n          modelName: 'relation',\n          attributes: {\n            Name: {\n              type: 'string',\n              default: 'default value',\n              required: true,\n            },\n          },\n        },\n      };\n\n      beforeAll(() => {\n        const fakeQuery = (key) => ({\n          findOne: jest.fn(({ where }) => fakeEntities[key][where.id]),\n          count: jest.fn(({ where }) => {\n            let ret = 0;\n            where.id.$in.forEach((id) => {\n              const entity = fakeEntities[key][id];\n              if (!entity) return;\n              ret += 1;\n            });\n            return ret;\n          }),\n          update: jest.fn(({ where }) => ({\n            ...fakeEntities[key][where.id],\n            addresses: {\n              count: 1,\n            },\n          })),\n        });\n\n        const fakeDB = {\n          query: jest.fn((key) => fakeQuery(key)),\n        };\n\n        global.strapi = {\n          getModel: jest.fn((uid) => {\n            return fakeModels[uid];\n          }),\n          db: fakeDB,\n        };\n\n        instance = createEntityService({\n          strapi: global.strapi,\n          db: fakeDB,\n          eventHub: new EventEmitter(),\n          entityValidator,\n        });\n      });\n\n      test(`should fail if the entity doesn't exist`, async () => {\n        expect(\n          await instance.update(entityUID, Math.random() * (10000 - 100) + 100, {})\n        ).toBeNull();\n      });\n\n      test('should successfully update an existing relation', async () => {\n        const data = {\n          Name: 'TestEntry',\n          addresses: {\n            connect: [\n              {\n                id: 1,\n              },\n            ],\n          },\n        };\n        expect(await instance.update(entityUID, 0, { data })).toMatchObject({\n          ...fakeEntities[entityUID][0],\n          addresses: {\n            count: 1,\n          },\n        });\n      });\n\n      test('should throw an error when trying to associate a relation that does not exist', async () => {\n        const data = {\n          Name: 'TestEntry',\n          addresses: {\n            connect: [\n              {\n                id: 3,\n              },\n            ],\n          },\n        };\n\n        const res = instance.update(entityUID, 0, { data });\n        await expect(res).rejects.toThrowError(\n          new ValidationError(\n            `1 relation(s) of type api::relation.relation associated with this entity do not exist`\n          )\n        );\n      });\n    });\n  });\n});\n", "'use strict';\n\nconst strapiUtils = require('@strapi/utils');\nconst {\n  errors: { YupValidationError },\n} = require('@strapi/utils');\nconst validators = require('../validators');\n\ndescribe('BigInteger validator', () => {\n  describe('unique', () => {\n    const fakeFindOne = jest.fn();\n\n    global.strapi = {\n      db: {\n        query: jest.fn(() => ({\n          findOne: fakeFindOne,\n        })),\n      },\n    };\n\n    afterEach(() => {\n      jest.clearAllMocks();\n      fakeFindOne.mockReset();\n    });\n\n    const fakeModel = {\n      kind: 'contentType',\n      modelName: 'test-model',\n      uid: 'test-uid',\n      privateAttributes: [],\n      options: {},\n      attributes: {\n        attrBigIntegerUnique: { type: 'biginteger', unique: true },\n      },\n    };\n\n    test('it does not validate the unique constraint if the attribute is not set as unique', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.biginteger(\n          {\n            attr: { type: 'biginteger' },\n            model: fakeModel,\n            updatedAttribute: {\n              name: 'attrBigIntegerUnique',\n              value: 1,\n            },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator(1);\n\n      expect(fakeFindOne).not.toHaveBeenCalled();\n    });\n\n    test('it does not validate the unique constraint if the attribute value is `null`', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators\n          .biginteger(\n            {\n              attr: { type: 'biginteger', unique: true },\n              model: fakeModel,\n              updatedAttribute: {\n                name: 'attrBigIntegerUnique',\n                value: null,\n              },\n              entity: null,\n            },\n            { isDraft: false }\n          )\n          .nullable()\n      );\n\n      await validator(null);\n\n      expect(fakeFindOne).not.toHaveBeenCalled();\n    });\n\n    test('it validates the unique constraint if there is no other record in the database', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.biginteger(\n          {\n            attr: { type: 'biginteger', unique: true },\n            model: fakeModel,\n            updatedAttribute: {\n              name: 'attrBigIntegerUnique',\n              value: 1,\n            },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator(1)).toBe(1);\n    });\n\n    test('it fails the validation of the unique constraint if the database contains a record with the same attribute value', async () => {\n      expect.assertions(1);\n      fakeFindOne.mockResolvedValueOnce({ attrBigIntegerUnique: 2 });\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.biginteger(\n          {\n            attr: { type: 'biginteger', unique: true },\n            model: fakeModel,\n            updatedAttribute: {\n              name: 'attrBigIntegerUnique',\n              value: 2,\n            },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      try {\n        await validator(2);\n      } catch (err) {\n        expect(err).toBeInstanceOf(YupValidationError);\n      }\n    });\n\n    test('it validates the unique constraint if the attribute data has not changed even if there is a record in the database with the same attribute value', async () => {\n      fakeFindOne.mockResolvedValueOnce({ attrBigIntegerUnique: 3 });\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.biginteger(\n          {\n            attr: { type: 'biginteger', unique: true },\n            model: fakeModel,\n            updatedAttribute: {\n              name: 'attrBigIntegerUnique',\n              value: 3,\n            },\n            entity: { id: 1, attrBigIntegerUnique: 3 },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator(3)).toBe(3);\n    });\n\n    test('it checks the database for records with the same value for the checked attribute', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.biginteger(\n          {\n            attr: { type: 'biginteger', unique: true },\n            model: fakeModel,\n            updatedAttribute: {\n              name: 'attrBigIntegerUnique',\n              value: 4,\n            },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator(4);\n\n      expect(fakeFindOne).toHaveBeenCalledWith({\n        select: ['id'],\n        where: { attrBigIntegerUnique: 4 },\n      });\n    });\n\n    test('it checks the database for records with the same value but not the same id for the checked attribute if an entity is passed', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.biginteger(\n          {\n            attr: { type: 'biginteger', unique: true },\n            model: fakeModel,\n            updatedAttribute: {\n              name: 'attrBigIntegerUnique',\n              value: 5,\n            },\n            entity: { id: 1, attrBigIntegerUnique: 42 },\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator(5);\n\n      expect(fakeFindOne).toHaveBeenCalledWith({\n        select: ['id'],\n        where: { $and: [{ attrBigIntegerUnique: 5 }, { $not: { id: 1 } }] },\n      });\n    });\n  });\n\n  describe('min', () => {\n    test('it does not validate the min constraint if the attribute min is not a number', async () => {\n      const validator = strapiUtils.validateYupSchema(\n        validators.biginteger(\n          {\n            attr: { type: 'biginteger', minLength: '123' },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator(1)).toBe(1);\n    });\n  });\n});\n", "'use strict';\n\nconst strapiUtils = require('@strapi/utils');\nconst {\n  errors: { YupValidationError },\n} = require('@strapi/utils');\nconst validators = require('../validators');\n\ndescribe('Date validator', () => {\n  describe('unique', () => {\n    const fakeFindOne = jest.fn();\n\n    global.strapi = {\n      db: {\n        query: jest.fn(() => ({\n          findOne: fakeFindOne,\n        })),\n      },\n    };\n\n    afterEach(() => {\n      jest.clearAllMocks();\n      fakeFindOne.mockReset();\n    });\n\n    const fakeModel = {\n      kind: 'contentType',\n      modelName: 'test-model',\n      uid: 'test-uid',\n      privateAttributes: [],\n      options: {},\n      attributes: {\n        attrDateUnique: { type: 'date', unique: true },\n      },\n    };\n\n    test('it does not validates the unique constraint if the attribute is not set as unique', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.date(\n          {\n            attr: { type: 'date' },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrDateUnique', value: '2021-11-29' },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator('2021-11-29');\n\n      expect(fakeFindOne).not.toHaveBeenCalled();\n    });\n\n    test('it does not validates the unique constraint if the attribute value is `null`', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators\n          .date(\n            {\n              attr: { type: 'date', unique: true },\n              model: fakeModel,\n              updatedAttribute: { name: 'attrDateUnique', value: null },\n              entity: null,\n            },\n            { isDraft: false }\n          )\n          .nullable()\n      );\n\n      await validator(null);\n      expect(fakeFindOne).not.toHaveBeenCalled();\n    });\n\n    test('it validates the unique constraint if there is no other record in the database', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.date(\n          {\n            attr: { type: 'date', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrDateUnique', value: '2021-11-29' },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator('2021-11-29')).toBe('2021-11-29');\n    });\n\n    test('it fails the validation of the unique constraint if the database contains a record with the same attribute value', async () => {\n      expect.assertions(1);\n      fakeFindOne.mockResolvedValueOnce({ attrDateUnique: '2021-11-29' });\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.date(\n          {\n            attr: { type: 'date', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrDateUnique', value: '2021-11-29' },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      try {\n        await validator('2021-11-29');\n      } catch (err) {\n        expect(err).toBeInstanceOf(YupValidationError);\n      }\n    });\n\n    test('it validates the unique constraint if the attribute data has not changed even if there is a record in the database with the same attribute value', async () => {\n      fakeFindOne.mockResolvedValueOnce({ attrDateUnique: '2021-11-29' });\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.date(\n          {\n            attr: { type: 'date', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrDateUnique', value: '2021-11-29' },\n            entity: { id: 1, attrDateUnique: '2021-11-29' },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator('2021-11-29')).toBe('2021-11-29');\n    });\n\n    test('it checks the database for records with the same value for the checked attribute', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.date(\n          {\n            attr: { type: 'date', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrDateUnique', value: '2021-11-29' },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator('2021-11-29');\n\n      expect(fakeFindOne).toHaveBeenCalledWith({\n        select: ['id'],\n        where: { attrDateUnique: '2021-11-29' },\n      });\n    });\n\n    test('it checks the database for records with the same value but not the same id for the checked attribute if an entity is passed', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.date(\n          {\n            attr: { type: 'date', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrDateUnique', value: '2021-11-29' },\n            entity: { id: 1, attrDateUnique: '2021-12-15' },\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator('2021-11-29');\n\n      expect(fakeFindOne).toHaveBeenCalledWith({\n        select: ['id'],\n        where: { $and: [{ attrDateUnique: '2021-11-29' }, { $not: { id: 1 } }] },\n      });\n    });\n  });\n});\n", "'use strict';\n\nconst strapiUtils = require('@strapi/utils');\nconst {\n  errors: { YupValidationError },\n} = require('@strapi/utils');\nconst validators = require('../validators');\n\ndescribe('Datetime validator', () => {\n  describe('unique', () => {\n    const fakeFindOne = jest.fn();\n\n    global.strapi = {\n      db: {\n        query: jest.fn(() => ({\n          findOne: fakeFindOne,\n        })),\n      },\n    };\n\n    afterEach(() => {\n      jest.clearAllMocks();\n      fakeFindOne.mockReset();\n    });\n\n    const fakeModel = {\n      kind: 'contentType',\n      modelName: 'test-model',\n      uid: 'test-uid',\n      privateAttributes: [],\n      options: {},\n      attributes: {\n        attrDateTimeUnique: { type: 'datetime', unique: true },\n      },\n    };\n\n    test('it does not validates the unique constraint if the attribute is not set as unique', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.datetime(\n          {\n            attr: { type: 'datetime' },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrDateTimeUnique', value: '2021-11-29T00:00:00.000Z' },\n            entity: { id: 1, attrDateTimeUnique: '2021-11-29T00:00:00.000Z' },\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator('2021-11-29T00:00:00.000Z');\n\n      expect(fakeFindOne).not.toHaveBeenCalled();\n    });\n\n    test('it does not validates the unique constraint if the attribute value is `null`', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators\n          .datetime(\n            {\n              attr: { type: 'datetime', unique: true },\n              model: fakeModel,\n              updatedAttribute: { name: 'attrDateTimeUnique', value: null },\n              entity: null,\n            },\n            { isDraft: false }\n          )\n          .nullable()\n      );\n\n      await validator(null);\n      expect(fakeFindOne).not.toHaveBeenCalled();\n    });\n\n    test('it validates the unique constraint if there is no other record in the database', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.datetime(\n          {\n            attr: { type: 'datetime', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrDateTimeUnique', value: '2021-11-29T00:00:00.000Z' },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator('2021-11-29T00:00:00.000Z')).toBe('2021-11-29T00:00:00.000Z');\n    });\n\n    test('it fails the validation of the unique constraint if the database contains a record with the same attribute value', async () => {\n      expect.assertions(1);\n      fakeFindOne.mockResolvedValueOnce({ attrDateTimeUnique: '2021-11-29T00:00:00.000Z' });\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.datetime(\n          {\n            attr: { type: 'datetime', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrDateTimeUnique', value: '2021-11-29T00:00:00.000Z' },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      try {\n        await validator('2021-11-29T00:00:00.000Z');\n      } catch (err) {\n        expect(err).toBeInstanceOf(YupValidationError);\n      }\n    });\n\n    test('it validates the unique constraint if the attribute data has not changed even if there is a record in the database with the same attribute value', async () => {\n      fakeFindOne.mockResolvedValueOnce({ attrDateTimeUnique: '2021-11-29T00:00:00.000Z' });\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.datetime(\n          {\n            attr: { type: 'datetime', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrDateTimeUnique', value: '2021-11-29T00:00:00.000Z' },\n            entity: { id: 1, attrDateTimeUnique: '2021-11-29T00:00:00.000Z' },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator('2021-11-29T00:00:00.000Z')).toBe('2021-11-29T00:00:00.000Z');\n    });\n\n    test('it checks the database for records with the same value for the checked attribute', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.datetime(\n          {\n            attr: { type: 'datetime', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrDateTimeUnique', value: '2021-11-29T00:00:00.000Z' },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator('2021-11-29T00:00:00.000Z');\n\n      expect(fakeFindOne).toHaveBeenCalledWith({\n        select: ['id'],\n        where: { attrDateTimeUnique: '2021-11-29T00:00:00.000Z' },\n      });\n    });\n\n    test('it checks the database for records with the same value but not the same id for the checked attribute if an entity is passed', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.datetime(\n          {\n            attr: { type: 'datetime', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrDateTimeUnique', value: '2021-11-29T00:00:00.000Z' },\n            entity: { id: 1, attrDateTimeUnique: '2021-12-25T00:00:00.000Z' },\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator('2021-11-29T00:00:00.000Z');\n\n      expect(fakeFindOne).toHaveBeenCalledWith({\n        select: ['id'],\n        where: { $and: [{ attrDateTimeUnique: '2021-11-29T00:00:00.000Z' }, { $not: { id: 1 } }] },\n      });\n    });\n  });\n});\n", "'use strict';\n\nconst strapiUtils = require('@strapi/utils');\nconst {\n  errors: { YupValidationError },\n} = require('@strapi/utils');\nconst validators = require('../validators');\n\ndescribe('Float validator', () => {\n  describe('unique', () => {\n    const fakeFindOne = jest.fn();\n\n    global.strapi = {\n      db: {\n        query: jest.fn(() => ({\n          findOne: fakeFindOne,\n        })),\n      },\n    };\n\n    afterEach(() => {\n      jest.clearAllMocks();\n      fakeFindOne.mockReset();\n    });\n\n    const fakeModel = {\n      kind: 'contentType',\n      uid: 'test-uid',\n      modelName: 'test-model',\n      privateAttributes: [],\n      options: {},\n      attributes: {\n        attrFloatUnique: { type: 'float', unique: true },\n      },\n    };\n\n    test('it does not validates the unique constraint if the attribute is not set as unique', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.float(\n          {\n            attr: { type: 'float' },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrFloatUnique', value: 1 },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator(1);\n\n      expect(fakeFindOne).not.toHaveBeenCalled();\n    });\n\n    test('it does not validates the unique constraint if the attribute value is `null`', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators\n          .float(\n            {\n              attr: { type: 'float', unique: true },\n              model: fakeModel,\n              updatedAttribute: { name: 'attrFloatUnique', value: null },\n              entity: null,\n            },\n            { isDraft: false }\n          )\n          .nullable()\n      );\n\n      await validator(null);\n\n      expect(fakeFindOne).not.toHaveBeenCalled();\n    });\n\n    test('it validates the unique constraint if there is no other record in the database', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.float(\n          {\n            attr: { type: 'float', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrFloatUnique', value: 2 },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator(1)).toBe(1);\n    });\n\n    test('it fails the validation of the unique constraint if the database contains a record with the same attribute value', async () => {\n      expect.assertions(1);\n      fakeFindOne.mockResolvedValueOnce({ attrFloatUnique: 2 });\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.float(\n          {\n            attr: { type: 'float', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrFloatUnique', value: 2 },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      try {\n        await validator(2);\n      } catch (err) {\n        expect(err).toBeInstanceOf(YupValidationError);\n      }\n    });\n\n    test('it validates the unique constraint if the attribute data has not changed even if there is a record in the database with the same attribute value', async () => {\n      fakeFindOne.mockResolvedValueOnce({ attrFloatUnique: 3 });\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.float(\n          {\n            attr: { type: 'float', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrFloatUnique', value: 3 },\n            entity: { id: 1, attrFloatUnique: 3 },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator(3)).toBe(3);\n    });\n\n    test('it checks the database for records with the same value for the checked attribute', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.float(\n          {\n            attr: { type: 'float', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrFloatUnique', value: 4 },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator(4);\n\n      expect(fakeFindOne).toHaveBeenCalledWith({\n        select: ['id'],\n        where: { attrFloatUnique: 4 },\n      });\n    });\n\n    test('it checks the database for records with the same value but not the same id for the checked attribute if an entity is passed', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.float(\n          {\n            attr: { type: 'float', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrFloatUnique', value: 5 },\n            entity: { id: 1, attrFloatUnique: 42 },\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator(5);\n\n      expect(fakeFindOne).toHaveBeenCalledWith({\n        select: ['id'],\n        where: { $and: [{ attrFloatUnique: 5 }, { $not: { id: 1 } }] },\n      });\n    });\n  });\n\n  describe('min', () => {\n    test('it does not validates the min constraint if the attribute min is not a number', async () => {\n      const validator = strapiUtils.validateYupSchema(\n        validators.float(\n          {\n            attr: { type: 'float', minLength: '123' },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator(1)).toBe(1);\n    });\n\n    test('it fails the validation if the float is lower than the define min', async () => {\n      expect.assertions(1);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.float(\n          {\n            attr: { type: 'float', min: 3 },\n          },\n          { isDraft: false }\n        )\n      );\n\n      try {\n        await validator(1);\n      } catch (err) {\n        expect(err).toBeInstanceOf(YupValidationError);\n      }\n    });\n\n    test('it validates the min constraint if the float is higher than the define min', async () => {\n      const validator = strapiUtils.validateYupSchema(\n        validators.float(\n          {\n            attr: { type: 'float', min: 3 },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator(4)).toBe(4);\n    });\n  });\n\n  describe('max', () => {\n    test('it does not validates the max constraint if the attribute max is not an float', async () => {\n      const validator = strapiUtils.validateYupSchema(\n        validators.float(\n          {\n            attr: { type: 'float', maxLength: '123' },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator(1)).toBe(1);\n    });\n\n    test('it fails the validation if the number is float than the define max', async () => {\n      expect.assertions(1);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.float(\n          {\n            attr: { type: 'float', max: 3 },\n          },\n          { isDraft: false }\n        )\n      );\n\n      try {\n        await validator(4);\n      } catch (err) {\n        expect(err).toBeInstanceOf(YupValidationError);\n      }\n    });\n\n    test('it validates the max constraint if the float is lower than the define max', async () => {\n      const validator = strapiUtils.validateYupSchema(\n        validators.float(\n          {\n            attr: { type: 'float', max: 3 },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator(2)).toBe(2);\n    });\n  });\n});\n", "'use strict';\n\nconst strapiUtils = require('@strapi/utils');\nconst {\n  errors: { YupValidationError },\n} = require('@strapi/utils');\nconst validators = require('../validators');\n\ndescribe('Integer validator', () => {\n  describe('unique', () => {\n    const fakeFindOne = jest.fn();\n\n    global.strapi = {\n      db: {\n        query: jest.fn(() => ({\n          findOne: fakeFindOne,\n        })),\n      },\n    };\n\n    afterEach(() => {\n      jest.clearAllMocks();\n      fakeFindOne.mockReset();\n    });\n\n    const fakeModel = {\n      kind: 'contentType',\n      uid: 'test-uid',\n      modelName: 'test-model',\n      privateAttributes: [],\n      options: {},\n      attributes: {\n        attrIntegerUnique: { type: 'integer', unique: true },\n      },\n    };\n\n    test('it does not validates the unique constraint if the attribute is not set as unique', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.integer(\n          {\n            attr: { type: 'integer' },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrIntegerUnique', value: 1 },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator(1);\n\n      expect(fakeFindOne).not.toHaveBeenCalled();\n    });\n\n    test('it does not validates the unique constraint if the attribute value is `null`', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators\n          .integer(\n            {\n              attr: { type: 'integer', unique: true },\n              model: fakeModel,\n              updatedAttribute: { name: 'attrIntegerUnique', value: null },\n              entity: null,\n            },\n            { isDraft: false }\n          )\n          .nullable()\n      );\n\n      await validator(null);\n\n      expect(fakeFindOne).not.toHaveBeenCalled();\n    });\n\n    test('it validates the unique constraint if there is no other record in the database', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.integer(\n          {\n            attr: { type: 'integer', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrIntegerUnique', value: 2 },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator(1)).toBe(1);\n    });\n\n    test('it fails the validation of the unique constraint if the database contains a record with the same attribute value', async () => {\n      expect.assertions(1);\n      fakeFindOne.mockResolvedValueOnce({ attrIntegerUnique: 2 });\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.integer(\n          {\n            attr: { type: 'integer', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrIntegerUnique', value: 2 },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      try {\n        await validator(2);\n      } catch (err) {\n        expect(err).toBeInstanceOf(YupValidationError);\n      }\n    });\n\n    test('it validates the unique constraint if the attribute data has not changed even if there is a record in the database with the same attribute value', async () => {\n      fakeFindOne.mockResolvedValueOnce({ attrIntegerUnique: 3 });\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.integer(\n          {\n            attr: { type: 'integer', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrIntegerUnique', value: 3 },\n            entity: { id: 1, attrIntegerUnique: 3 },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator(3)).toBe(3);\n    });\n\n    test('it checks the database for records with the same value for the checked attribute', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.integer(\n          {\n            attr: { type: 'integer', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrIntegerUnique', value: 4 },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator(4);\n\n      expect(fakeFindOne).toHaveBeenCalledWith({\n        select: ['id'],\n        where: { attrIntegerUnique: 4 },\n      });\n    });\n\n    test('it checks the database for records with the same value but not the same id for the checked attribute if an entity is passed', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.integer(\n          {\n            attr: { type: 'integer', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrIntegerUnique', value: 5 },\n            entity: { id: 1, attrIntegerUnique: 42 },\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator(5);\n\n      expect(fakeFindOne).toHaveBeenCalledWith({\n        select: ['id'],\n        where: { $and: [{ attrIntegerUnique: 5 }, { $not: { id: 1 } }] },\n      });\n    });\n  });\n\n  describe('min', () => {\n    test('it does not validates the min constraint if the attribute min is not a number', async () => {\n      const validator = strapiUtils.validateYupSchema(\n        validators.integer(\n          {\n            attr: { type: 'integer', minLength: '123' },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator(1)).toBe(1);\n    });\n\n    test('it fails the validation if the integer is lower than the define min', async () => {\n      expect.assertions(1);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.integer(\n          {\n            attr: { type: 'integer', min: 3 },\n          },\n          { isDraft: false }\n        )\n      );\n\n      try {\n        await validator(1);\n      } catch (err) {\n        expect(err).toBeInstanceOf(YupValidationError);\n      }\n    });\n\n    test('it validates the min constraint if the integer is higher than the define min', async () => {\n      const validator = strapiUtils.validateYupSchema(\n        validators.integer(\n          {\n            attr: { type: 'integer', min: 3 },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator(4)).toBe(4);\n    });\n  });\n\n  describe('max', () => {\n    test('it does not validates the max constraint if the attribute max is not an integer', async () => {\n      const validator = strapiUtils.validateYupSchema(\n        validators.integer(\n          {\n            attr: { type: 'integer', maxLength: '123' },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator(1)).toBe(1);\n    });\n\n    test('it fails the validation if the number is integer than the define max', async () => {\n      expect.assertions(1);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.integer(\n          {\n            attr: { type: 'integer', max: 3 },\n          },\n          { isDraft: false }\n        )\n      );\n\n      try {\n        await validator(4);\n      } catch (err) {\n        expect(err).toBeInstanceOf(YupValidationError);\n      }\n    });\n\n    test('it validates the max constraint if the integer is lower than the define max', async () => {\n      const validator = strapiUtils.validateYupSchema(\n        validators.integer(\n          {\n            attr: { type: 'integer', max: 3 },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator(2)).toBe(2);\n    });\n  });\n});\n", "'use strict';\n\nconst strapiUtils = require('@strapi/utils');\nconst {\n  errors: { YupValidationError },\n} = require('@strapi/utils');\nconst validators = require('../validators');\n\ndescribe('String validator', () => {\n  describe('unique', () => {\n    const fakeFindOne = jest.fn();\n\n    global.strapi = {\n      db: {\n        query: jest.fn(() => ({\n          findOne: fakeFindOne,\n        })),\n      },\n    };\n\n    afterEach(() => {\n      jest.clearAllMocks();\n      fakeFindOne.mockReset();\n    });\n\n    const fakeModel = {\n      kind: 'contentType',\n      modelName: 'test-model',\n      uid: 'test-uid',\n      privateAttributes: [],\n      options: {},\n      attributes: {\n        attrStringUnique: { type: 'string', unique: true },\n      },\n    };\n\n    test('it does not validates the unique constraint if the attribute is not set as unique', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.string(\n          {\n            attr: { type: 'string' },\n            model: fakeModel,\n            updatedAttribute: {\n              name: 'attrStringUnique',\n              value: 'non-unique-test-data',\n            },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator('non-unique-test-data');\n\n      expect(fakeFindOne).not.toHaveBeenCalled();\n    });\n\n    test('it does not validates the unique constraint if the attribute value is `null`', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators\n          .string(\n            {\n              attr: { type: 'string', unique: true },\n              model: fakeModel,\n              updatedAttribute: {\n                name: 'attrStringUnique',\n                value: null,\n              },\n              entity: null,\n            },\n            { isDraft: false }\n          )\n          .nullable()\n      );\n\n      await validator(null);\n\n      expect(fakeFindOne).not.toHaveBeenCalled();\n    });\n\n    test('it validates the unique constraint if there is no other record in the database', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.string(\n          {\n            attr: { type: 'string', unique: true },\n            model: fakeModel,\n            updatedAttribute: {\n              name: 'attrStringUnique',\n              value: 'non-unique-test-data',\n            },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator('non-unique-test-data')).toBe('non-unique-test-data');\n    });\n\n    test('it fails the validation of the unique constraint if the database contains a record with the same attribute value', async () => {\n      expect.assertions(1);\n      fakeFindOne.mockResolvedValueOnce({ attrStringUnique: 'unique-test-data' });\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.string(\n          {\n            attr: { type: 'string', unique: true },\n            model: fakeModel,\n            updatedAttribute: {\n              name: 'attrStringUnique',\n              value: 'unique-test-data',\n            },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      try {\n        await validator('unique-test-data');\n      } catch (err) {\n        expect(err).toBeInstanceOf(YupValidationError);\n      }\n    });\n\n    test('it validates the unique constraint if the attribute data has not changed even if there is a record in the database with the same attribute value', async () => {\n      fakeFindOne.mockResolvedValueOnce({ attrStringUnique: 'non-updated-unique-test-data' });\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.string(\n          {\n            attr: { type: 'string', unique: true },\n            model: fakeModel,\n            updatedAttribute: {\n              name: 'attrStringUnique',\n              value: 'non-updated-unique-test-data',\n            },\n            entity: { id: 1, attrStringUnique: 'non-updated-unique-test-data' },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator('non-updated-unique-test-data')).toBe('non-updated-unique-test-data');\n    });\n\n    test('it checks the database for records with the same value for the checked attribute', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.string(\n          {\n            attr: { type: 'string', unique: true },\n            model: fakeModel,\n            updatedAttribute: {\n              name: 'attrStringUnique',\n              value: 'test-data',\n            },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator('test-data');\n\n      expect(fakeFindOne).toHaveBeenCalledWith({\n        select: ['id'],\n        where: { attrStringUnique: 'test-data' },\n      });\n    });\n\n    test('it checks the database for records with the same value but not the same id for the checked attribute if an entity is passed', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.string(\n          {\n            attr: { type: 'string', unique: true },\n            model: fakeModel,\n            updatedAttribute: {\n              name: 'attrStringUnique',\n              value: 'test-data',\n            },\n            entity: { id: 1, attrStringUnique: 'other-data' },\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator('test-data');\n\n      expect(fakeFindOne).toHaveBeenCalledWith({\n        select: ['id'],\n        where: { $and: [{ attrStringUnique: 'test-data' }, { $not: { id: 1 } }] },\n      });\n    });\n  });\n\n  describe('minLength', () => {\n    test('it does not validates the minLength constraint if the attribute minLength is not an integer', async () => {\n      const validator = strapiUtils.validateYupSchema(\n        validators.string(\n          {\n            attr: { type: 'string', minLength: '123' },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator('a')).toBe('a');\n    });\n\n    test('it does not validates the minLength constraint if it is a draft', async () => {\n      const validator = strapiUtils.validateYupSchema(\n        validators.string(\n          {\n            attr: { type: 'string', minLength: 3 },\n          },\n          { isDraft: true }\n        )\n      );\n\n      expect(await validator('a')).toBe('a');\n    });\n\n    test('it fails the validation if the string is shorter than the define minLength', async () => {\n      expect.assertions(1);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.string(\n          {\n            attr: { type: 'string', minLength: 3 },\n          },\n          { isDraft: false }\n        )\n      );\n\n      try {\n        await validator('a');\n      } catch (err) {\n        expect(err).toBeInstanceOf(YupValidationError);\n      }\n    });\n\n    test('it validates the minLength constraint if the string is longer than the define minLength', async () => {\n      const validator = strapiUtils.validateYupSchema(\n        validators.string(\n          {\n            attr: { type: 'string', minLength: 3 },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator('this string is longer than the minLenght')).toBe(\n        'this string is longer than the minLenght'\n      );\n    });\n  });\n\n  describe('maxLength', () => {\n    test('it does not validates the maxLength constraint if the attribute maxLength is not an integer', async () => {\n      const validator = strapiUtils.validateYupSchema(\n        validators.string(\n          {\n            attr: { type: 'string', maxLength: '123' },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator('a')).toBe('a');\n    });\n\n    test('it fails the validation if the string is longer than the define maxLength', async () => {\n      expect.assertions(1);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.string(\n          {\n            attr: { type: 'string', maxLength: 3 },\n          },\n          { isDraft: false }\n        )\n      );\n\n      try {\n        await validator('this string is too long');\n      } catch (err) {\n        expect(err).toBeInstanceOf(YupValidationError);\n      }\n    });\n\n    test('it validates the maxLength constraint if the string is shorter than the define maxLength', async () => {\n      const validator = strapiUtils.validateYupSchema(\n        validators.string(\n          {\n            attr: { type: 'string', maxLength: 3 },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator('a')).toBe('a');\n    });\n  });\n\n  describe('regExp', () => {\n    test('it fails the validation of an empty string for a required field', async () => {\n      expect.assertions(1);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.string(\n          {\n            attr: { type: 'string', required: true, regex: '^\\\\w+$' },\n          },\n          { isDraft: false }\n        )\n      );\n\n      try {\n        await validator('');\n      } catch (err) {\n        expect(err).toBeInstanceOf(YupValidationError);\n      }\n    });\n\n    test('it validates a string for required field according to the regex constraint', async () => {\n      const validator = strapiUtils.validateYupSchema(\n        validators.string(\n          {\n            attr: { type: 'string', required: true, regex: '^\\\\w+$' },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator('Strapi')).toBe('Strapi');\n    });\n\n    test('it validates an empty string for non-required field with a regex constraint', async () => {\n      const validator = strapiUtils.validateYupSchema(\n        validators.string(\n          {\n            attr: { type: 'string', required: false, regex: '^\\\\w+$' },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator('')).toBe('');\n    });\n\n    test('it validates a string for non-required field according to the regex constraint', async () => {\n      const validator = strapiUtils.validateYupSchema(\n        validators.string(\n          {\n            attr: { type: 'string', required: false, regex: '^\\\\w+$' },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator('Strapi')).toBe('Strapi');\n    });\n  });\n});\n", "'use strict';\n\nconst strapiUtils = require('@strapi/utils');\nconst {\n  errors: { YupValidationError },\n} = require('@strapi/utils');\nconst validators = require('../validators');\n\ndescribe('Time validator', () => {\n  describe('unique', () => {\n    const fakeFindOne = jest.fn();\n\n    global.strapi = {\n      db: {\n        query: jest.fn(() => ({\n          findOne: fakeFindOne,\n        })),\n      },\n    };\n\n    afterEach(() => {\n      jest.clearAllMocks();\n      fakeFindOne.mockReset();\n    });\n\n    const fakeModel = {\n      kind: 'contentType',\n      modelName: 'test-model',\n      uid: 'test-uid',\n      privateAttributes: [],\n      options: {},\n      attributes: {\n        attrTimeUnique: { type: 'time', unique: true },\n      },\n    };\n\n    test('it does not validates the unique constraint if the attribute is not set as unique', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.time(\n          {\n            attr: { type: 'time' },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrTimeUnique', value: '00:00:00.000Z' },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator('00:00:00.000Z');\n\n      expect(fakeFindOne).not.toHaveBeenCalled();\n    });\n\n    test('it does not validates the unique constraint if the attribute value is `null`', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators\n          .time(\n            {\n              attr: { type: 'time', unique: true },\n              model: fakeModel,\n              updatedAttribute: { name: 'attrTimeUnique', value: null },\n              entity: { id: 1, attrTimeUnique: '00:00:00.000Z' },\n            },\n            { isDraft: false }\n          )\n          .nullable()\n      );\n\n      await validator(null);\n      expect(fakeFindOne).not.toHaveBeenCalled();\n    });\n\n    test('it validates the unique constraint if there is no other record in the database', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.time(\n          {\n            attr: { type: 'time', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrTimeUnique', value: '00:00:00.000Z' },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator('00:00:00.000Z')).toBe('00:00:00.000Z');\n    });\n\n    test('it fails the validation of the unique constraint if the database contains a record with the same attribute value', async () => {\n      expect.assertions(1);\n      fakeFindOne.mockResolvedValueOnce({ attrTimeUnique: '00:00:00.000Z' });\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.time(\n          {\n            attr: { type: 'time', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrTimeUnique', value: '00:00:00.000Z' },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      try {\n        await validator('00:00:00.000Z');\n      } catch (err) {\n        expect(err).toBeInstanceOf(YupValidationError);\n      }\n    });\n\n    test('it validates the unique constraint if the attribute data has not changed even if there is a record in the database with the same attribute value', async () => {\n      fakeFindOne.mockResolvedValueOnce({ attrTimeUnique: '00:00:00.000Z' });\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.time(\n          {\n            attr: { type: 'time', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrTimeUnique', value: '00:00:00.000Z' },\n            entity: { id: 1, attrTimeUnique: '00:00:00.000Z' },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator('00:00:00.000Z')).toBe('00:00:00.000Z');\n    });\n\n    test('it checks the database for records with the same value for the checked attribute', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.time(\n          {\n            attr: { type: 'time', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrTimeUnique', value: '00:00:00.000Z' },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator('00:00:00.000Z');\n\n      expect(fakeFindOne).toHaveBeenCalledWith({\n        select: ['id'],\n        where: { attrTimeUnique: '00:00:00.000Z' },\n      });\n    });\n\n    test('it checks the database for records with the same value but not the same id for the checked attribute if an entity is passed', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.time(\n          {\n            attr: { type: 'time', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrTimeUnique', value: '00:00:00.000Z' },\n            entity: { id: 1, attrTimeUnique: '01:00:00.000Z' },\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator('00:00:00.000Z');\n\n      expect(fakeFindOne).toHaveBeenCalledWith({\n        select: ['id'],\n        where: { $and: [{ attrTimeUnique: '00:00:00.000Z' }, { $not: { id: 1 } }] },\n      });\n    });\n  });\n});\n", "'use strict';\n\nconst strapiUtils = require('@strapi/utils');\nconst {\n  errors: { YupValidationError },\n} = require('@strapi/utils');\nconst validators = require('../validators');\n\ndescribe('Time validator', () => {\n  describe('unique', () => {\n    const fakeFindOne = jest.fn();\n\n    global.strapi = {\n      db: {\n        query: jest.fn(() => ({\n          findOne: fakeFindOne,\n        })),\n      },\n    };\n\n    afterEach(() => {\n      jest.clearAllMocks();\n      fakeFindOne.mockReset();\n    });\n\n    const fakeModel = {\n      kind: 'contentType',\n      modelName: 'test-model',\n      uid: 'test-uid',\n      privateAttributes: [],\n      options: {},\n      attributes: {\n        attrTimestampUnique: { type: 'timestamp', unique: true },\n      },\n    };\n\n    test('it does not validates the unique constraint if the attribute is not set as unique', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.timestamp(\n          {\n            attr: { type: 'timestamp' },\n            model: fakeModel,\n            updatedAttribute: {\n              name: 'attrTimestampUnique',\n              value: '1638140400',\n            },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator('1638140400');\n\n      expect(fakeFindOne).not.toHaveBeenCalled();\n    });\n\n    test('it does not validates the unique constraint if the attribute value is `null`', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators\n          .timestamp(\n            {\n              attr: { type: 'timestamp', unique: true },\n              model: fakeModel,\n              updatedAttribute: {\n                name: 'attrTimestampUnique',\n                value: null,\n              },\n              entity: null,\n            },\n            { isDraft: false }\n          )\n          .nullable()\n      );\n\n      await validator(null);\n      expect(fakeFindOne).not.toHaveBeenCalled();\n    });\n\n    test('it validates the unique constraint if there is no other record in the database', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.timestamp(\n          {\n            attr: { type: 'timestamp', unique: true },\n            model: fakeModel,\n            updatedAttribute: {\n              name: 'attrTimestampUnique',\n              value: '1638140400',\n            },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator('1638140400')).toBe('1638140400');\n    });\n\n    test('it fails the validation of the unique constraint if the database contains a record with the same attribute value', async () => {\n      expect.assertions(1);\n      fakeFindOne.mockResolvedValueOnce({ attrTimestampUnique: '1638140400' });\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.timestamp(\n          {\n            attr: { type: 'timestamp', unique: true },\n            model: fakeModel,\n            updatedAttribute: {\n              name: 'attrTimestampUnique',\n              value: '1638140400',\n            },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      try {\n        await validator('1638140400');\n      } catch (err) {\n        expect(err).toBeInstanceOf(YupValidationError);\n      }\n    });\n\n    test('it validates the unique constraint if the attribute data has not changed even if there is a record in the database with the same attribute value', async () => {\n      fakeFindOne.mockResolvedValueOnce({ attrTimestampUnique: '1638140400' });\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.timestamp(\n          {\n            attr: { type: 'timestamp', unique: true },\n            model: fakeModel,\n            updatedAttribute: {\n              name: 'attrTimestampUnique',\n              value: '1638140400',\n            },\n            entity: { id: 1, attrTimestampUnique: '1638140400' },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator('1638140400')).toBe('1638140400');\n    });\n\n    test('it checks the database for records with the same value for the checked attribute', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.timestamp(\n          {\n            attr: { type: 'timestamp', unique: true },\n            model: fakeModel,\n            updatedAttribute: {\n              name: 'attrTimestampUnique',\n              value: '1638140400',\n            },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator('1638140400');\n\n      expect(fakeFindOne).toHaveBeenCalledWith({\n        select: ['id'],\n        where: { attrTimestampUnique: '1638140400' },\n      });\n    });\n\n    test('it checks the database for records with the same value but not the same id for the checked attribute if an entity is passed', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.timestamp(\n          {\n            attr: { type: 'timestamp', unique: true },\n            model: fakeModel,\n            updatedAttribute: {\n              name: 'attrTimestampUnique',\n              value: '1638140400',\n            },\n            entity: { id: 1, attrTimestampUnique: '1000000000' },\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator('1638140400');\n\n      expect(fakeFindOne).toHaveBeenCalledWith({\n        select: ['id'],\n        where: { $and: [{ attrTimestampUnique: '1638140400' }, { $not: { id: 1 } }] },\n      });\n    });\n  });\n});\n", "'use strict';\n\nconst strapiUtils = require('@strapi/utils');\nconst {\n  errors: { YupValidationError },\n} = require('@strapi/utils');\nconst validators = require('../validators');\n\ndescribe('UID validator', () => {\n  const fakeFindOne = jest.fn();\n\n  global.strapi = {\n    db: {\n      query: jest.fn(() => ({\n        findOne: fakeFindOne,\n      })),\n    },\n  };\n\n  afterEach(() => {\n    jest.clearAllMocks();\n    fakeFindOne.mockReset();\n  });\n\n  const fakeModel = {\n    kind: 'contentType',\n    modelName: 'test-model',\n    uid: 'test-uid',\n    privateAttributes: [],\n    options: {},\n    attributes: {\n      attrUidUnique: { type: 'uid' },\n    },\n  };\n\n  describe('unique', () => {\n    test('it validates the unique constraint if there is no other record in the database', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.uid(\n          {\n            attr: { type: 'uid', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrUidUnique', value: 'non-unique-uid' },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator('non-unique-uid')).toBe('non-unique-uid');\n    });\n\n    test('it does not validates the unique constraint if the attribute value is `null`', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators\n          .uid(\n            {\n              attr: { type: 'uid', unique: true },\n              model: fakeModel,\n              updatedAttribute: { name: 'attrUidUnique', value: null },\n              entity: null,\n            },\n            { isDraft: false }\n          )\n          .nullable()\n      );\n\n      await validator(null);\n\n      expect(fakeFindOne).not.toHaveBeenCalled();\n    });\n\n    test('it always validates the unique constraint even if the attribute is not set as unique', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.uid(\n          {\n            attr: { type: 'uid' },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrUidUnique', value: 'non-unique-uid' },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator('non-unique-uid')).toBe('non-unique-uid');\n      expect(fakeFindOne).toHaveBeenCalledWith({\n        select: ['id'],\n        where: { attrUidUnique: 'non-unique-uid' },\n      });\n    });\n\n    test('it fails the validation of the unique constraint if the database contains a record with the same attribute value', async () => {\n      expect.assertions(1);\n      fakeFindOne.mockResolvedValueOnce({ attrUidUnique: 'unique-uid' });\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.uid(\n          {\n            attr: { type: 'uid', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrUidUnique', value: 'unique-uid' },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      try {\n        await validator('unique-uid');\n      } catch (err) {\n        expect(err).toBeInstanceOf(YupValidationError);\n      }\n    });\n\n    test('it validates the unique constraint if the attribute data has not changed even if there is a record in the database with the same attribute value', async () => {\n      fakeFindOne.mockResolvedValueOnce({ attrUidUnique: 'unchanged-unique-uid' });\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.uid(\n          {\n            attr: { type: 'uid', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrUidUnique', value: 'unchanged-unique-uid' },\n            entity: { id: 1, attrUidUnique: 'unchanged-unique-uid' },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator('unchanged-unique-uid')).toBe('unchanged-unique-uid');\n    });\n\n    test('it checks the database for records with the same value for the checked attribute', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.uid(\n          {\n            attr: { type: 'uid', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrUidUnique', value: 'unique-uid' },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator('unique-uid');\n\n      expect(fakeFindOne).toHaveBeenCalledWith({\n        select: ['id'],\n        where: { attrUidUnique: 'unique-uid' },\n      });\n    });\n\n    test('it checks the database for records with the same value but not the same id for the checked attribute if an entity is passed', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.uid(\n          {\n            attr: { type: 'uid', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrUidUnique', value: 'unique-uid' },\n            entity: { id: 1, attrUidUnique: 'other-uid' },\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator('unique-uid');\n\n      expect(fakeFindOne).toHaveBeenCalledWith({\n        select: ['id'],\n        where: { $and: [{ attrUidUnique: 'unique-uid' }, { $not: { id: 1 } }] },\n      });\n    });\n  });\n\n  describe('regExp', () => {\n    test('it fails to validate the uid if it does not fit the requried format', async () => {\n      expect.assertions(1);\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.uid(\n          {\n            attr: { type: 'uid', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrUidUnique', value: 'non-unique-uid' },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      try {\n        await validator('wrongly\\\\formated||UID');\n      } catch (err) {\n        expect(err).toBeInstanceOf(YupValidationError);\n      }\n    });\n\n    test('it validate the uid if it fit the required format', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.uid(\n          {\n            attr: { type: 'uid', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrUidUnique', value: 'non-unique-uid' },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator('properly.formated-uid')).toBe('properly.formated-uid');\n    });\n  });\n});\n", "'use strict';\n\nconst {\n  isPrivateAttribute,\n  isTypedAttribute,\n  getPrivateAttributes,\n  getVisibleAttributes,\n  getNonWritableAttributes,\n  getScalarAttributes,\n  constants,\n} = require('../content-types');\n\nconst createModelWithPrivates = (privateAttributes = []) => ({\n  uid: 'myModel',\n  options: {\n    privateAttributes,\n  },\n  attributes: {\n    foo: {\n      type: 'string',\n      private: true,\n    },\n    bar: {\n      type: 'number',\n      private: false,\n    },\n    foobar: {\n      type: 'string',\n    },\n  },\n});\n\nconst createConfig = (privateAttributes = []) => ({\n  get: jest.fn(() => privateAttributes),\n});\n\nconst createModel = (opts) => ({\n  ...opts,\n});\n\ndescribe('Content types utils', () => {\n  beforeEach(() => {\n    jest.resetAllMocks();\n  });\n\n  test('Verify constants exist', () => {\n    expect(constants.CREATED_BY_ATTRIBUTE).toBeDefined();\n    expect(constants.UPDATED_BY_ATTRIBUTE).toBeDefined();\n    expect(constants.PUBLISHED_AT_ATTRIBUTE).toBeDefined();\n  });\n\n  describe('getNonWritableAttributes', () => {\n    test('Includes non writable fields', () => {\n      const model = createModel({\n        attributes: {\n          title: {\n            type: 'string',\n          },\n          non_writable_field: {\n            type: 'string',\n            writable: false,\n          },\n          createdAt: {\n            type: 'datetime',\n          },\n          updatedAt: {\n            type: 'datetime',\n          },\n        },\n      });\n\n      expect(getNonWritableAttributes(model)).toEqual([\n        'id',\n        'createdAt',\n        'updatedAt',\n        'non_writable_field',\n      ]);\n    });\n  });\n\n  describe('getVisibleAttributes', () => {\n    test('Excludes non visible fields', () => {\n      const model = createModel({\n        attributes: {\n          title: {\n            type: 'string',\n          },\n          invisible_field: {\n            type: 'datetime',\n            visible: false,\n          },\n        },\n      });\n\n      expect(getVisibleAttributes(model)).toEqual(['title']);\n    });\n\n    test('Excludes id', () => {\n      const model = createModel({\n        attributes: {\n          id: {\n            type: 'integer',\n          },\n          title: {\n            type: 'string',\n          },\n        },\n      });\n\n      expect(getVisibleAttributes(model)).toEqual(['title']);\n    });\n  });\n\n  describe('getPrivateAttributes', () => {\n    test('Attribute is private in the model attributes', () => {\n      const model = createModelWithPrivates();\n      global.strapi = { config: createConfig() };\n\n      const privateAttributes = getPrivateAttributes(model);\n\n      expect(privateAttributes).toContain('foo');\n      expect(privateAttributes).not.toContain('bar');\n      expect(privateAttributes).not.toContain('foobar');\n      expect(strapi.config.get).toHaveBeenCalledWith('api.responses.privateAttributes', []);\n    });\n\n    test('Attribute is set to private in the app config', () => {\n      const model = createModelWithPrivates();\n      global.strapi = { config: createConfig(['bar']) };\n\n      const privateAttributes = getPrivateAttributes(model);\n\n      expect(privateAttributes).toContain('foo');\n      expect(privateAttributes).toContain('bar');\n      expect(privateAttributes).not.toContain('foobar');\n      expect(strapi.config.get).toHaveBeenCalledWith('api.responses.privateAttributes', []);\n    });\n\n    test('Attribute is set to private in the model options', () => {\n      const model = createModelWithPrivates(['foobar']);\n      global.strapi = { config: createConfig() };\n\n      const privateAttributes = getPrivateAttributes(model);\n\n      expect(privateAttributes).toContain('foo');\n      expect(privateAttributes).not.toContain('bar');\n      expect(privateAttributes).toContain('foobar');\n      expect(strapi.config.get).toHaveBeenCalledWith('api.responses.privateAttributes', []);\n    });\n  });\n\n  describe('isPrivateAttribute', () => {\n    test('Attribute is private in the model attributes', () => {\n      const model = createModelWithPrivates();\n      global.strapi = { config: createConfig() };\n      Object.assign(model, { privateAttributes: getPrivateAttributes(model) });\n\n      expect(isPrivateAttribute(model, 'foo')).toBeTruthy();\n      expect(isPrivateAttribute(model, 'bar')).toBeFalsy();\n      expect(isPrivateAttribute(model, 'foobar')).toBeFalsy();\n      expect(strapi.config.get).toHaveBeenCalledWith('api.responses.privateAttributes', []);\n    });\n\n    test('Attribute is set to private in the app config', () => {\n      const model = createModelWithPrivates();\n      global.strapi = { config: createConfig(['bar']) };\n      Object.assign(model, { privateAttributes: getPrivateAttributes(model) });\n\n      expect(isPrivateAttribute(model, 'foo')).toBeTruthy();\n      expect(isPrivateAttribute(model, 'bar')).toBeTruthy();\n      expect(isPrivateAttribute(model, 'foobar')).toBeFalsy();\n      expect(strapi.config.get).toHaveBeenCalledWith('api.responses.privateAttributes', []);\n    });\n\n    test('Attribute is set to private in the model options', () => {\n      const model = createModelWithPrivates(['foobar']);\n      global.strapi = { config: createConfig() };\n      Object.assign(model, { privateAttributes: getPrivateAttributes(model) });\n\n      expect(isPrivateAttribute(model, 'foo')).toBeTruthy();\n      expect(isPrivateAttribute(model, 'bar')).toBeFalsy();\n      expect(isPrivateAttribute(model, 'foobar')).toBeTruthy();\n      expect(strapi.config.get).toHaveBeenCalledWith('api.responses.privateAttributes', []);\n    });\n  });\n\n  describe('isTypedAttribute', () => {\n    test('Returns false if attribute does not have a type', () => {\n      expect(isTypedAttribute({})).toBe(false);\n    });\n\n    test('Returns true if attribute type matches passed type', () => {\n      expect(isTypedAttribute({ type: 'test' }, 'test')).toBe(true);\n    });\n\n    test('Returns false if type do not match', () => {\n      expect(isTypedAttribute({ type: 'test' }, 'other-type')).toBe(false);\n    });\n  });\n\n  describe('getScalarAttributes', () => {\n    test('returns only scalar attributes', () => {\n      const schema = {\n        attributes: {\n          mediaField: { type: 'media' },\n          componentField: { type: 'component' },\n          relationField: { type: 'relation' },\n          dynamiczoneField: { type: 'dynamiczone' },\n          stringField: { type: 'string' },\n          textField: { type: 'text' },\n          richtextField: { type: 'richtext' },\n          enumerationField: { type: 'enumeration' },\n          emailField: { type: 'email' },\n          passwordField: { type: 'password' },\n          uidField: { type: 'uid' },\n          dateField: { type: 'date' },\n          timeField: { type: 'time' },\n          datetimeField: { type: 'datetime' },\n          timestampField: { type: 'timestamp' },\n          integerField: { type: 'integer' },\n          bigintegerField: { type: 'biginteger' },\n          floatField: { type: 'float' },\n          decimalField: { type: 'decimal' },\n          booleanField: { type: 'boolean' },\n          arrayField: { type: 'array' },\n          jsonField: { type: 'json' },\n        },\n      };\n\n      const scalarAttributes = getScalarAttributes(schema);\n      expect(scalarAttributes).toEqual([\n        'stringField',\n        'textField',\n        'richtextField',\n        'enumerationField',\n        'emailField',\n        'passwordField',\n        'uidField',\n        'dateField',\n        'timeField',\n        'datetimeField',\n        'timestampField',\n        'integerField',\n        'bigintegerField',\n        'floatField',\n        'decimalField',\n        'booleanField',\n        'arrayField',\n        'jsonField',\n      ]);\n    });\n  });\n});\n", "'use strict';\n\nconst _ = require('lodash');\nconst { has } = require('lodash/fp');\n\nconst SINGLE_TYPE = 'singleType';\nconst COLLECTION_TYPE = 'collectionType';\n\nconst ID_ATTRIBUTE = 'id';\nconst PUBLISHED_AT_ATTRIBUTE = 'publishedAt';\nconst CREATED_BY_ATTRIBUTE = 'createdBy';\nconst UPDATED_BY_ATTRIBUTE = 'updatedBy';\n\nconst CREATED_AT_ATTRIBUTE = 'createdAt';\nconst UPDATED_AT_ATTRIBUTE = 'updatedAt';\n\nconst DP_PUB_STATE_LIVE = 'live';\nconst DP_PUB_STATE_PREVIEW = 'preview';\nconst DP_PUB_STATES = [DP_PUB_STATE_LIVE, DP_PUB_STATE_PREVIEW];\n\nconst constants = {\n  ID_ATTRIBUTE,\n  PUBLISHED_AT_ATTRIBUTE,\n  CREATED_BY_ATTRIBUTE,\n  UPDATED_BY_ATTRIBUTE,\n  CREATED_AT_ATTRIBUTE,\n  UPDATED_AT_ATTRIBUTE,\n  DP_PUB_STATES,\n  DP_PUB_STATE_LIVE,\n  DP_PUB_STATE_PREVIEW,\n  SINGLE_TYPE,\n  COLLECTION_TYPE,\n};\n\nconst getTimestamps = (model) => {\n  const attributes = [];\n\n  if (has(CREATED_AT_ATTRIBUTE, model.attributes)) {\n    attributes.push(CREATED_AT_ATTRIBUTE);\n  }\n\n  if (has(UPDATED_AT_ATTRIBUTE, model.attributes)) {\n    attributes.push(UPDATED_AT_ATTRIBUTE);\n  }\n\n  return attributes;\n};\n\nconst getNonWritableAttributes = (model = {}) => {\n  const nonWritableAttributes = _.reduce(\n    model.attributes,\n    (acc, attr, attrName) => (attr.writable === false ? acc.concat(attrName) : acc),\n    []\n  );\n\n  return _.uniq([ID_ATTRIBUTE, ...getTimestamps(model), ...nonWritableAttributes]);\n};\n\nconst getWritableAttributes = (model = {}) => {\n  return _.difference(Object.keys(model.attributes), getNonWritableAttributes(model));\n};\n\nconst isWritableAttribute = (model, attributeName) => {\n  return getWritableAttributes(model).includes(attributeName);\n};\n\nconst getNonVisibleAttributes = (model) => {\n  const nonVisibleAttributes = _.reduce(\n    model.attributes,\n    (acc, attr, attrName) => (attr.visible === false ? acc.concat(attrName) : acc),\n    []\n  );\n\n  return _.uniq([ID_ATTRIBUTE, ...getTimestamps(model), ...nonVisibleAttributes]);\n};\n\nconst getVisibleAttributes = (model) => {\n  return _.difference(_.keys(model.attributes), getNonVisibleAttributes(model));\n};\n\nconst isVisibleAttribute = (model, attributeName) => {\n  return getVisibleAttributes(model).includes(attributeName);\n};\n\nconst getOptions = (model) => _.assign({ draftAndPublish: false }, _.get(model, 'options', {}));\nconst hasDraftAndPublish = (model) => _.get(model, 'options.draftAndPublish', false) === true;\n\nconst isDraft = (data, model) =>\n  hasDraftAndPublish(model) && _.get(data, PUBLISHED_AT_ATTRIBUTE) === null;\n\nconst isSingleType = ({ kind = COLLECTION_TYPE }) => kind === SINGLE_TYPE;\nconst isCollectionType = ({ kind = COLLECTION_TYPE }) => kind === COLLECTION_TYPE;\nconst isKind = (kind) => (model) => model.kind === kind;\n\nconst getPrivateAttributes = (model = {}) => {\n  return _.union(\n    strapi.config.get('api.responses.privateAttributes', []),\n    _.get(model, 'options.privateAttributes', []),\n    _.keys(_.pickBy(model.attributes, (attr) => !!attr.private))\n  );\n};\n\nconst isPrivateAttribute = (model, attributeName) => {\n  return model?.privateAttributes?.includes(attributeName) ?? false;\n};\n\nconst isScalarAttribute = (attribute) => {\n  return !['media', 'component', 'relation', 'dynamiczone'].includes(attribute?.type);\n};\nconst isMediaAttribute = (attribute) => attribute?.type === 'media';\nconst isRelationalAttribute = (attribute) => attribute?.type === 'relation';\nconst isComponentAttribute = (attribute) => ['component', 'dynamiczone'].includes(attribute?.type);\n\nconst isDynamicZoneAttribute = (attribute) => attribute?.type === 'dynamiczone';\nconst isMorphToRelationalAttribute = (attribute) => {\n  return isRelationalAttribute(attribute) && attribute?.relation?.startsWith?.('morphTo');\n};\n\nconst getComponentAttributes = (schema) => {\n  return _.reduce(\n    schema.attributes,\n    (acc, attr, attrName) => {\n      if (isComponentAttribute(attr)) acc.push(attrName);\n      return acc;\n    },\n    []\n  );\n};\n\nconst getScalarAttributes = (schema) => {\n  return _.reduce(\n    schema.attributes,\n    (acc, attr, attrName) => {\n      if (isScalarAttribute(attr)) acc.push(attrName);\n      return acc;\n    },\n    []\n  );\n};\n\n/**\n * Checks if an attribute is of type `type`\n * @param {object} attribute\n * @param {string} type\n */\nconst isTypedAttribute = (attribute, type) => {\n  return _.has(attribute, 'type') && attribute.type === type;\n};\n\n/**\n *  Returns a route prefix for a contentType\n * @param {object} contentType\n * @returns {string}\n */\nconst getContentTypeRoutePrefix = (contentType) => {\n  return isSingleType(contentType)\n    ? _.kebabCase(contentType.info.singularName)\n    : _.kebabCase(contentType.info.pluralName);\n};\n\nmodule.exports = {\n  isScalarAttribute,\n  isMediaAttribute,\n  isRelationalAttribute,\n  isComponentAttribute,\n  isDynamicZoneAttribute,\n  isMorphToRelationalAttribute,\n  isTypedAttribute,\n  getPrivateAttributes,\n  isPrivateAttribute,\n  constants,\n  getNonWritableAttributes,\n  getComponentAttributes,\n  getScalarAttributes,\n  getWritableAttributes,\n  isWritableAttribute,\n  getNonVisibleAttributes,\n  getVisibleAttributes,\n  getTimestamps,\n  isVisibleAttribute,\n  hasDraftAndPublish,\n  getOptions,\n  isDraft,\n  isSingleType,\n  isCollectionType,\n  isKind,\n  getContentTypeRoutePrefix,\n};\n", "'use strict';\n\nconst { isPrivateAttribute } = require('../../content-types');\n\nmodule.exports = ({ schema, key, attribute }, { remove }) => {\n  if (!attribute) {\n    return;\n  }\n\n  const isPrivate = isPrivateAttribute(schema, key) || attribute.private === true;\n\n  if (isPrivate) {\n    remove(key);\n  }\n};\n"], "fixing_code": ["'use strict';\n\nconst { createStrapiInstance } = require('api-tests/strapi');\n\nlet strapi;\n\ndescribe('transactions', () => {\n  let original;\n  beforeAll(async () => {\n    strapi = await createStrapiInstance();\n    original = await strapi.db\n      .queryBuilder('strapi::core-store')\n      .select(['*'])\n      .where({ id: 1 })\n      .execute();\n  });\n\n  afterAll(async () => {\n    await strapi.destroy();\n  });\n\n  afterEach(async () => {\n    await strapi.db\n      .queryBuilder('strapi::core-store')\n      .update({\n        key: original[0].key,\n      })\n      .where({ id: 1 })\n      .execute();\n  });\n\n  describe('using a transaction method', () => {\n    test('commits successfully', async () => {\n      await strapi.db.transaction(async () => {\n        await strapi.db\n          .queryBuilder('strapi::core-store')\n          .update({\n            key: 'wrong key',\n          })\n          .where({ id: 1 })\n          .execute();\n\n        await strapi.db\n          .queryBuilder('strapi::core-store')\n          .update({\n            key: 'new key',\n          })\n          .where({ id: 1 })\n          .execute();\n      });\n\n      const end = await strapi.db\n        .queryBuilder('strapi::core-store')\n        .select(['*'])\n        .where({ id: 1 })\n        .execute();\n\n      expect(end[0].key).toEqual('new key');\n    });\n\n    test('rollback successfully', async () => {\n      try {\n        await strapi.db.transaction(async () => {\n          // this is valid\n          await strapi.db\n            .queryBuilder('strapi::core-store')\n            .update({\n              key: 'wrong key',\n            })\n            .where({ id: 1 })\n            .execute();\n\n          // this throws\n          await strapi.db\n            .queryBuilder('invalid_uid')\n            .update({\n              key: 'bad key',\n              invalid_key: 'error',\n            })\n            .where({ id: 1 })\n            .execute();\n        });\n\n        expect('this should not be reached').toBe(false);\n      } catch (e) {\n        // do nothing\n      }\n\n      const end = await strapi.db\n        .queryBuilder('strapi::core-store')\n        .select(['*'])\n        .where({ id: 1 })\n        .execute();\n\n      expect(end[0].key).toEqual(original[0].key);\n    });\n\n    test('nested rollback -> rollback works', async () => {\n      try {\n        await strapi.db.transaction(async () => {\n          // this is valid\n          await strapi.db\n            .queryBuilder('strapi::core-store')\n            .update({\n              key: 'changed key',\n            })\n            .where({ id: 1 })\n            .execute();\n\n          // here we'll make a nested transaction that throws and then confirm we still have \"changed key\" from above\n          try {\n            await strapi.db.transaction(async () => {\n              await strapi.db\n                .queryBuilder('strapi::core-store')\n                .update({\n                  key: 'changed key - nested',\n                })\n                .where({ id: 1 })\n                .execute();\n\n              // this should throw and roll back\n              await strapi.db\n                .queryBuilder('invalid_uid')\n                .update({\n                  invalid_key: 'error',\n                })\n                .where({ id: 1 })\n                .execute();\n            });\n          } catch (e) {\n            // do nothing\n          }\n\n          // should equal the result from above\n          const result = await strapi.db\n            .queryBuilder('strapi::core-store')\n            .select(['*'])\n            .where({ id: 1 })\n            .execute();\n\n          expect(result[0].key).toEqual('changed key');\n\n          // this throws\n          await strapi.db\n            .queryBuilder('invalid_uid')\n            .update({\n              key: original[0].key,\n              invalid_key: 'error',\n            })\n            .where({ id: 1 })\n            .execute();\n        });\n\n        expect('this should not be reached').toBe(false);\n      } catch (e) {\n        // do nothing\n      }\n\n      const end = await strapi.db\n        .queryBuilder('strapi::core-store')\n        .select(['*'])\n        .where({ id: 1 })\n        .execute();\n\n      expect(end[0].key).toEqual(original[0].key);\n    });\n\n    test('nested commit -> rollback works', async () => {\n      try {\n        await strapi.db.transaction(async () => {\n          // this is valid\n          await strapi.db\n            .queryBuilder('strapi::core-store')\n            .update({\n              key: 'changed key',\n            })\n            .where({ id: 1 })\n            .execute();\n\n          // here we'll make a nested transaction that works, and then later we'll rollback the outer transaction\n          try {\n            await strapi.db.transaction(async () => {\n              await strapi.db\n                .queryBuilder('strapi::core-store')\n                .update({\n                  key: 'changed key - nested',\n                })\n                .where({ id: 1 })\n                .execute();\n            });\n          } catch (e) {\n            // do nothing\n          }\n\n          // should equal the result from above\n          const result = await strapi.db\n            .queryBuilder('strapi::core-store')\n            .select(['*'])\n            .where({ id: 1 })\n            .execute();\n\n          expect(result[0].key).toEqual('changed key - nested');\n\n          // this throws\n          await strapi.db\n            .queryBuilder('invalid_uid')\n            .update({\n              key: original[0].key,\n              invalid_key: 'error',\n            })\n            .where({ id: 1 })\n            .execute();\n        });\n\n        expect('this should not be reached').toBe(false);\n      } catch (e) {\n        // do nothing\n      }\n\n      const end = await strapi.db\n        .queryBuilder('strapi::core-store')\n        .select(['*'])\n        .where({ id: 1 })\n        .execute();\n\n      expect(end[0].key).toEqual(original[0].key);\n    });\n\n    test('onCommit hook works', async () => {\n      let count = 0;\n      await strapi.db.transaction(({ onCommit, onRollback }) => {\n        onCommit(() => count++);\n      });\n      expect(count).toEqual(1);\n    });\n\n    test('onRollback hook works', async () => {\n      let count = 0;\n      try {\n        await strapi.db.transaction(({ onRollback }) => {\n          onRollback(() => count++);\n          throw new Error('test');\n        });\n      } catch (e) {\n        // do nothing\n      }\n      expect(count).toEqual(1);\n    });\n  });\n\n  describe('using a transaction object', () => {\n    test('commits successfully', async () => {\n      const trx = await strapi.db.transaction();\n\n      try {\n        await strapi.db\n          .queryBuilder('strapi::core-store')\n          .update({\n            key: 'wrong key',\n          })\n          .where({ id: 1 })\n          .transacting(trx.get())\n          .execute();\n\n        await strapi.db\n          .queryBuilder('strapi::core-store')\n          .update({\n            key: original[0].key,\n          })\n          .where({ id: 1 })\n          .transacting(trx.get())\n          .execute();\n\n        await trx.commit();\n      } catch (e) {\n        await trx.rollback();\n        console.log(e.message);\n        expect('this should not be reached').toBe(false);\n      }\n\n      const end = await strapi.db\n        .queryBuilder('strapi::core-store')\n        .select(['*'])\n        .where({ id: 1 })\n        .execute();\n\n      expect(end[0].key).toEqual(original[0].key);\n    });\n\n    test('rollback successfully', async () => {\n      const trx = await strapi.db.transaction();\n\n      try {\n        await strapi.db\n          .queryBuilder('strapi::core-store')\n          .update({\n            key: 'wrong key',\n          })\n          .where({ id: 1 })\n          .transacting(trx.get())\n          .execute();\n\n        // this query should throw because it has errors\n        await strapi.db\n          .queryBuilder('invalid_uid')\n          .update({\n            key: 123,\n            key_not_here: 'this should error',\n          })\n          .where({ id: 'this should error' })\n          .transacting(trx.get())\n          .execute();\n\n        await trx.commit();\n        expect('this should not be reached').toBe(false);\n      } catch (e) {\n        await trx.rollback();\n      }\n\n      const end = await strapi.db\n        .queryBuilder('strapi::core-store')\n        .select(['*'])\n        .where({ id: 1 })\n        .execute();\n\n      expect(end[0].key).toEqual(original[0].key);\n    });\n  });\n});\n", "'use strict';\n\nconst { AbilityBuilder, Ability } = require('@casl/ability');\nconst { pick } = require('lodash/fp');\nconst sift = require('sift');\nconst { buildStrapiQuery } = require('../permission/permissions-manager/query-builers');\nconst createPermissionsManager = require('../permission/permissions-manager');\n\nconst allowedOperations = [\n  '$or',\n  '$and',\n  '$eq',\n  '$ne',\n  '$in',\n  '$nin',\n  '$lt',\n  '$lte',\n  '$gt',\n  '$gte',\n  '$exists',\n  '$elemMatch',\n];\n\nconst operations = pick(allowedOperations, sift);\n\nconst conditionsMatcher = (conditions) => {\n  return sift.createQueryTester(conditions, { operations });\n};\n\nconst defineAbility = (register) => {\n  const { can, build } = new AbilityBuilder(Ability);\n\n  register(can);\n\n  return build({ conditionsMatcher });\n};\n\ndescribe('Permissions Manager', () => {\n  beforeEach(() => {\n    global.strapi = {\n      getModel() {\n        return {};\n      },\n    };\n  });\n\n  describe('get Query', () => {\n    test('It should returns an empty query when no conditions are defined', async () => {\n      const ability = defineAbility((can) => can('read', 'foo'));\n      const pm = createPermissionsManager({\n        ability,\n        action: 'read',\n        model: 'foo',\n      });\n\n      expect(pm.getQuery()).toStrictEqual({});\n    });\n\n    test('It should returns a valid query from the ability', () => {\n      const ability = defineAbility((can) => can('read', 'foo', ['bar'], { kai: 'doe' }));\n      const pm = createPermissionsManager({\n        ability,\n        action: 'read',\n        model: 'foo',\n      });\n\n      const expected = { $or: [{ kai: 'doe' }] };\n\n      expect(pm.getQuery()).toStrictEqual(expected);\n    });\n\n    test('It should throw if no action is defined', () => {\n      const ability = defineAbility((can) => can('read', 'foo', ['bar'], { kai: 'doe' }));\n      const pm = createPermissionsManager({\n        ability,\n        model: 'foo',\n      });\n\n      expect(() => pm.getQuery()).toThrowError();\n    });\n  });\n\n  describe('get isAllowed', () => {\n    const ability = defineAbility((can) => can('read', 'foo'));\n\n    test('It should grants access', () => {\n      const pm = createPermissionsManager({\n        ability,\n        action: 'read',\n        model: 'foo',\n      });\n\n      expect(pm.isAllowed).toBeTruthy();\n    });\n\n    test('It should deny access', () => {\n      const pm = createPermissionsManager({\n        ability,\n        action: 'read',\n        model: 'bar',\n      });\n\n      expect(pm.isAllowed).toBeFalsy();\n    });\n  });\n\n  describe('toSubject', () => {\n    global.strapi = {\n      getModel() {\n        return {};\n      },\n    };\n\n    const attr = '__caslSubjectType__';\n    const ability = defineAbility((can) => can('read', 'foo'));\n    const pm = createPermissionsManager({\n      ability,\n      action: 'read',\n      model: 'foo',\n    });\n\n    test('It should transform an object to a subject using default model', () => {\n      const input = { foo: 'bar' };\n      const sub = pm.toSubject(input);\n\n      expect(sub[attr]).toBeDefined();\n      expect(sub[attr]).toEqual('foo');\n      expect(sub).toStrictEqual(input);\n    });\n\n    test('It should transform an object to a subject using the given model', () => {\n      const input = { foo: 'bar' };\n      const newSubjectName = 'another_subject';\n      const sub = pm.toSubject(input, newSubjectName);\n\n      expect(sub[attr]).toBeDefined();\n      expect(sub[attr]).toEqual(newSubjectName);\n      expect(sub).toStrictEqual(input);\n    });\n  });\n\n  describe('pickPermittedFieldsOf', () => {\n    global.strapi = {\n      getModel() {\n        return {\n          attributes: {\n            title: {\n              type: 'text',\n              private: false,\n            },\n          },\n          primaryKey: 'id',\n          options: {},\n        };\n      },\n      config: {\n        get: jest.fn,\n      },\n    };\n\n    const ability = defineAbility((can) => {\n      can('read', 'article', ['title'], { title: 'foo' });\n      can('edit', 'article', ['title'], { title: { $in: ['kai', 'doe'] } });\n    });\n\n    const pm = createPermissionsManager({\n      ability,\n      action: 'read',\n      model: 'article',\n    });\n\n    test('Pick all fields (output) using default model', async () => {\n      const input = { title: 'foo' };\n      const res = await pm.pickPermittedFieldsOf(input);\n\n      expect(res).toStrictEqual(input);\n    });\n\n    test(`Pick 0 fields (output) using custom model`, async () => {\n      const input = { title: 'foo' };\n      const res = await pm.pickPermittedFieldsOf(input, { action: 'edit' });\n\n      expect(res).toStrictEqual({});\n    });\n\n    test('Sanitize an array of objects', async () => {\n      const input = [{ title: 'foo' }, { title: 'kai' }];\n      const expected = [{ title: 'foo' }, {}];\n\n      const res = await pm.pickPermittedFieldsOf(input);\n\n      expect(res).toStrictEqual(expected);\n    });\n  });\n\n  describe('addPermissionsQueryTo', () => {\n    const ability = defineAbility((can) =>\n      can('read', 'article', ['title'], { $and: [{ title: 'foo' }] })\n    );\n    const pm = createPermissionsManager({\n      ability,\n      action: 'read',\n      model: 'article',\n    });\n\n    const pmQuery = { $or: [{ $and: [{ title: 'foo' }] }] };\n\n    test('Create query from simple object', () => {\n      const query = { limit: 100 };\n      const expected = { limit: 100, filters: pmQuery };\n\n      const res = pm.addPermissionsQueryTo(query);\n\n      expect(res).toStrictEqual(expected);\n    });\n\n    test('Create query from complex object', () => {\n      const query = { limit: 100, filters: { $and: [{ a: 'b' }, { c: 'd' }] } };\n      const expected = {\n        limit: 100,\n        filters: {\n          $and: [query.filters, pmQuery],\n        },\n      };\n\n      const res = pm.addPermissionsQueryTo(query);\n\n      expect(res).toStrictEqual(expected);\n    });\n  });\n\n  describe('buildStrapiQuery', () => {\n    const tests = [\n      ['No transform', { foo: 'bar' }, { foo: 'bar' }],\n      ['Simple op', { foo: { $eq: 'bar' } }, { foo: { $eq: 'bar' } }],\n      ['Nested property', { 'foo.nested': 'bar' }, { foo: { nested: 'bar' } }],\n      [\n        'Nested property + $eq',\n        { 'foo.nested': { $eq: 'bar' } },\n        { foo: { nested: { $eq: 'bar' } } },\n      ],\n      [\n        'Nested property + $elementMatch',\n        { 'foo.nested': { $elemMatch: 'bar' } },\n        { foo: { nested: 'bar' } },\n      ],\n      [\n        'Deeply nested property',\n        { 'foo.nested.again': 'bar' },\n        { foo: { nested: { again: 'bar' } } },\n      ],\n      ['Op with array', { foo: { $in: ['bar', 'rab'] } }, { foo: { $in: ['bar', 'rab'] } }],\n      ['Removable op', { foo: { $elemMatch: { a: 'b' } } }, { foo: { a: 'b' } }],\n      [\n        'Combination of removable and basic ops',\n        { foo: { $elemMatch: { a: { $in: [1, 2, 3] } } } },\n        { foo: { a: { $in: [1, 2, 3] } } },\n      ],\n      [\n        'Decoupling of nested properties with/without op',\n        { foo: { $elemMatch: { a: { $in: [1, 2, 3] }, b: 'c' } } },\n        { foo: { a: { $in: [1, 2, 3] }, b: 'c' } },\n      ],\n      [\n        'OR op and properties decoupling',\n        { $or: [{ foo: { a: 2 } }, { foo: { b: 3 } }] },\n        { $or: [{ foo: { a: 2 } }, { foo: { b: 3 } }] },\n      ],\n      [\n        'OR op with nested properties & ops',\n        { $or: [{ foo: { a: 2 } }, { foo: { b: { $in: [1, 2, 3] } } }] },\n        { $or: [{ foo: { a: 2 } }, { foo: { b: { $in: [1, 2, 3] } } }] },\n      ],\n      [\n        'Nested OR op',\n        { $or: [{ $or: [{ a: 2 }, { a: 3 }] }] },\n        { $or: [{ $or: [{ a: 2 }, { a: 3 }] }] },\n      ],\n      [\n        'OR op with nested AND op',\n        { $or: [{ a: 2 }, [{ a: 3 }, { $or: [{ b: 1 }, { b: 4 }] }]] },\n        { $or: [{ a: 2 }, [{ a: 3 }, { $or: [{ b: 1 }, { b: 4 }] }]] },\n      ],\n      [\n        'OR op with nested AND op and nested properties',\n        { $or: [{ a: 2 }, [{ a: 3 }, { b: { c: 'foo' } }]] },\n        { $or: [{ a: 2 }, [{ a: 3 }, { b: { c: 'foo' } }]] },\n      ],\n      [\n        'Literal nested property with removable op',\n        {\n          created_by: {\n            roles: {\n              $elemMatch: {\n                id: {\n                  $in: [1, 2, 3],\n                },\n              },\n            },\n          },\n        },\n        {\n          created_by: {\n            roles: {\n              id: {\n                $in: [1, 2, 3],\n              },\n            },\n          },\n        },\n      ],\n    ];\n\n    test.each(tests)(`Test n\u00b0%#: %s`, (name, input, expected) => {\n      expect(buildStrapiQuery(input)).toStrictEqual(expected);\n    });\n  });\n});\n", "'use strict';\n\nconst { cloneDeep } = require('lodash/fp');\nconst _ = require('lodash');\nconst { hasDraftAndPublish } = require('@strapi/utils').contentTypes;\nconst {\n  CREATED_AT_ATTRIBUTE,\n  UPDATED_AT_ATTRIBUTE,\n  PUBLISHED_AT_ATTRIBUTE,\n  CREATED_BY_ATTRIBUTE,\n  UPDATED_BY_ATTRIBUTE,\n} = require('@strapi/utils').contentTypes.constants;\nconst { validateContentTypeDefinition } = require('./validator');\n\nconst createContentType = (uid, definition) => {\n  try {\n    validateContentTypeDefinition(definition);\n  } catch (e) {\n    throw new Error(`Content Type Definition is invalid for ${uid}'.\\n${e.errors}`);\n  }\n\n  const { schema, actions, lifecycles } = cloneDeep(definition);\n\n  // general info\n  Object.assign(schema, {\n    kind: schema.kind || 'collectionType',\n    __schema__: pickSchema(definition.schema),\n    modelType: 'contentType',\n    modelName: definition.schema.info.singularName,\n    connection: 'default',\n  });\n\n  if (uid.startsWith('api::')) {\n    Object.assign(schema, {\n      uid,\n      apiName: uid.split('::')[1].split('.')[0],\n      collectionName: schema.collectionName || schema.info.singularName,\n      globalId: getGlobalId(schema, schema.info.singularName),\n    });\n  } else if (uid.startsWith('plugin::')) {\n    const pluginName = uid.split('::')[1].split('.')[0];\n    Object.assign(schema, {\n      uid,\n      plugin: pluginName, // TODO: to be set in load-plugins.js\n      collectionName:\n        schema.collectionName || `${pluginName}_${schema.info.singularName}`.toLowerCase(),\n      globalId: getGlobalId(schema, schema.info.singularName, pluginName),\n    });\n  } else if (uid.startsWith('admin::')) {\n    Object.assign(schema, {\n      uid,\n      plugin: 'admin',\n      globalId: getGlobalId(schema, schema.info.singularName, 'admin'),\n    });\n  } else {\n    throw new Error(\n      `Incorrect Content Type UID \"${uid}\". The UID should start with api::, plugin:: or admin::.`\n    );\n  }\n\n  // attributes\n  Object.assign(schema.attributes, {\n    [CREATED_AT_ATTRIBUTE]: {\n      type: 'datetime',\n    },\n    // TODO: handle on edit set to new date\n    [UPDATED_AT_ATTRIBUTE]: {\n      type: 'datetime',\n    },\n  });\n\n  if (hasDraftAndPublish(schema)) {\n    schema.attributes[PUBLISHED_AT_ATTRIBUTE] = {\n      type: 'datetime',\n      configurable: false,\n      writable: true,\n      visible: false,\n    };\n  }\n\n  const isPrivate = !_.get(schema, 'options.populateCreatorFields', false);\n\n  schema.attributes[CREATED_BY_ATTRIBUTE] = {\n    type: 'relation',\n    relation: 'oneToOne',\n    target: 'admin::user',\n    configurable: false,\n    writable: false,\n    visible: false,\n    useJoinTable: false,\n    private: isPrivate,\n  };\n\n  schema.attributes[UPDATED_BY_ATTRIBUTE] = {\n    type: 'relation',\n    relation: 'oneToOne',\n    target: 'admin::user',\n    configurable: false,\n    writable: false,\n    visible: false,\n    useJoinTable: false,\n    private: isPrivate,\n  };\n\n  Object.assign(schema, { actions, lifecycles });\n\n  return schema;\n};\n\nconst getGlobalId = (model, modelName, prefix) => {\n  const globalId = prefix ? `${prefix}-${modelName}` : modelName;\n\n  return model.globalId || _.upperFirst(_.camelCase(globalId));\n};\n\nconst pickSchema = (model) => {\n  const schema = _.cloneDeep(\n    _.pick(model, [\n      'connection',\n      'collectionName',\n      'info',\n      'options',\n      'pluginOptions',\n      'attributes',\n    ])\n  );\n\n  schema.kind = model.kind || 'collectionType';\n  return schema;\n};\n\nmodule.exports = {\n  createContentType,\n};\n", "'use strict';\n\nconst createEntityService = require('..');\nconst entityValidator = require('../../entity-validator');\n\ndescribe('Entity service triggers webhooks', () => {\n  let instance;\n  const eventHub = { emit: jest.fn() };\n  let entity = { attr: 'value' };\n\n  beforeAll(() => {\n    const model = {\n      uid: 'api::test.test',\n      kind: 'singleType',\n      modelName: 'test-model',\n      attributes: {\n        attr: { type: 'string' },\n      },\n    };\n    instance = createEntityService({\n      strapi: {\n        getModel: () => model,\n      },\n      db: {\n        transaction: (cb) => cb(),\n        query: () => ({\n          count: () => 0,\n          create: ({ data }) => data,\n          update: ({ data }) => data,\n          findOne: () => entity,\n          findMany: () => [entity, entity],\n          delete: () => ({}),\n          deleteMany: () => ({}),\n        }),\n      },\n      eventHub,\n      entityValidator,\n    });\n\n    global.strapi = {\n      getModel: () => model,\n      config: {\n        get: () => [],\n      },\n    };\n  });\n\n  test('Emit event: Create', async () => {\n    // Create entity\n    await instance.create('test-model', { data: entity });\n\n    // Expect entry.create event to be emitted\n    expect(eventHub.emit).toHaveBeenCalledWith('entry.create', {\n      entry: entity,\n      model: 'test-model',\n      uid: 'api::test.test',\n    });\n\n    eventHub.emit.mockClear();\n  });\n\n  test('Emit event: Update', async () => {\n    // Update entity\n    await instance.update('test-model', 'entity-id', { data: entity });\n\n    // Expect entry.update event to be emitted\n    expect(eventHub.emit).toHaveBeenCalledWith('entry.update', {\n      entry: entity,\n      model: 'test-model',\n      uid: 'api::test.test',\n    });\n\n    eventHub.emit.mockClear();\n  });\n\n  test('Emit event: Delete', async () => {\n    // Delete entity\n    await instance.delete('test-model', 'entity-id', {});\n\n    // Expect entry.create event to be emitted\n    expect(eventHub.emit).toHaveBeenCalledWith('entry.delete', {\n      entry: entity,\n      model: 'test-model',\n      uid: 'api::test.test',\n    });\n\n    eventHub.emit.mockClear();\n  });\n\n  test('Emit event: Delete Many', async () => {\n    // Delete entity\n    await instance.deleteMany('test-model', {});\n\n    // Expect entry.create event to be emitted\n    expect(eventHub.emit).toHaveBeenCalledWith('entry.delete', {\n      entry: entity,\n      model: 'test-model',\n      uid: 'api::test.test',\n    });\n    // One event per each entity deleted\n    expect(eventHub.emit).toHaveBeenCalledTimes(2);\n\n    eventHub.emit.mockClear();\n  });\n\n  test('Do not emit event when no deleted entity', async () => {\n    entity = null;\n    // Delete non existent entity\n    await instance.delete('test-model', 'entity-id', {});\n\n    // Expect entry.create event to be emitted\n    expect(eventHub.emit).toHaveBeenCalledTimes(0);\n\n    eventHub.emit.mockClear();\n  });\n});\n", "'use strict';\n\njest.mock('bcryptjs', () => ({ hashSync: () => 'secret-password' }));\n\nconst { EventEmitter } = require('events');\nconst { ValidationError } = require('@strapi/utils').errors;\nconst createEntityService = require('..');\nconst entityValidator = require('../../entity-validator');\n\njest.mock('../../utils/upload-files', () => jest.fn(() => Promise.resolve()));\n\ndescribe('Entity service', () => {\n  global.strapi = {\n    getModel: jest.fn(() => ({})),\n    config: {\n      get() {\n        return [];\n      },\n    },\n    query: jest.fn(() => ({})),\n  };\n\n  describe('Decorator', () => {\n    test.each(['create', 'update', 'findMany', 'findOne', 'delete', 'count', 'findPage'])(\n      'Can decorate',\n      async (method) => {\n        const instance = createEntityService({\n          strapi: {},\n          db: {},\n          eventHub: new EventEmitter(),\n        });\n\n        const methodFn = jest.fn();\n        const decorator = () => ({\n          [method]: methodFn,\n        });\n\n        instance.decorate(decorator);\n\n        const args = [{}, {}];\n        await instance[method](...args);\n        expect(methodFn).toHaveBeenCalled();\n      }\n    );\n  });\n\n  describe('Find', () => {\n    test('Returns first element for single types', async () => {\n      const data = {\n        id: 1,\n        title: 'Test',\n      };\n\n      const fakeQuery = {\n        findOne: jest.fn(() => Promise.resolve(data)),\n      };\n\n      const fakeDB = {\n        query: jest.fn(() => fakeQuery),\n        transaction: (cb) => cb(),\n      };\n\n      const fakeStrapi = {\n        getModel: jest.fn(() => {\n          return { kind: 'singleType' };\n        }),\n      };\n\n      const instance = createEntityService({\n        strapi: fakeStrapi,\n        db: fakeDB,\n        eventHub: new EventEmitter(),\n      });\n\n      const result = await instance.findMany('test-model');\n\n      expect(fakeStrapi.getModel).toHaveBeenCalledTimes(1);\n      expect(fakeStrapi.getModel).toHaveBeenCalledWith('test-model');\n\n      expect(fakeDB.query).toHaveBeenCalledWith('test-model');\n      expect(fakeQuery.findOne).toHaveBeenCalledWith({});\n      expect(result).toEqual(data);\n    });\n  });\n\n  describe('Create', () => {\n    const fakeQuery = {\n      count: jest.fn(() => 0),\n      create: jest.fn(({ data }) => ({\n        id: 1,\n        ...data,\n      })),\n      findOne: jest.fn(),\n    };\n    const fakeModels = {};\n\n    beforeAll(() => {\n      global.strapi.getModel.mockImplementation((modelName) => fakeModels[modelName]);\n      global.strapi.query.mockImplementation(() => fakeQuery);\n    });\n    beforeEach(() => {\n      jest.clearAllMocks();\n    });\n    afterAll(() => {\n      global.strapi.getModel.mockImplementation(() => ({}));\n    });\n    describe('assign default values', () => {\n      let instance;\n      const entityUID = 'api::entity.entity';\n      const relationUID = 'api::relation.relation';\n\n      beforeAll(() => {\n        const fakeEntities = {\n          [relationUID]: {\n            1: {\n              id: 1,\n              Name: 'TestRelation',\n              createdAt: '2022-09-28T15:11:22.995Z',\n              updatedAt: '2022-09-29T09:01:02.949Z',\n              publishedAt: null,\n            },\n            2: {\n              id: 2,\n              Name: 'TestRelation2',\n              createdAt: '2022-09-28T15:11:22.995Z',\n              updatedAt: '2022-09-29T09:01:02.949Z',\n              publishedAt: null,\n            },\n          },\n        };\n\n        fakeModels[entityUID] = {\n          uid: entityUID,\n          kind: 'contentType',\n          modelName: 'test-model',\n          options: {},\n          attributes: {\n            attrStringDefaultRequired: {\n              type: 'string',\n              default: 'default value',\n              required: true,\n            },\n            attrStringDefault: { type: 'string', default: 'default value' },\n            attrBoolDefaultRequired: { type: 'boolean', default: true, required: true },\n            attrBoolDefault: { type: 'boolean', default: true },\n            attrIntDefaultRequired: { type: 'integer', default: 1, required: true },\n            attrIntDefault: { type: 'integer', default: 1 },\n            attrEnumDefaultRequired: {\n              type: 'enumeration',\n              enum: ['a', 'b', 'c'],\n              default: 'a',\n              required: true,\n            },\n            attrEnumDefault: {\n              type: 'enumeration',\n              enum: ['a', 'b', 'c'],\n              default: 'b',\n            },\n            attrPassword: { type: 'password' },\n            attrRelation: {\n              type: 'relation',\n              relation: 'oneToMany',\n              target: relationUID,\n              mappedBy: 'entity',\n            },\n          },\n        };\n        fakeModels[relationUID] = {\n          uid: relationUID,\n          kind: 'contentType',\n          modelName: 'relation',\n          attributes: {\n            Name: {\n              type: 'string',\n              default: 'default value',\n              required: true,\n            },\n          },\n        };\n        const fakeQuery = (uid) => ({\n          create: jest.fn(({ data }) => data),\n          count: jest.fn(({ where }) => {\n            return where.id.$in.filter((id) => Boolean(fakeEntities[uid][id])).length;\n          }),\n        });\n\n        const fakeDB = {\n          transaction: (cb) => cb(),\n          query: jest.fn((uid) => fakeQuery(uid)),\n        };\n\n        global.strapi.db = fakeDB;\n\n        instance = createEntityService({\n          strapi: global.strapi,\n          db: fakeDB,\n          eventHub: new EventEmitter(),\n          entityValidator,\n        });\n      });\n      afterAll(() => {\n        global.strapi.db = {\n          query: jest.fn(() => fakeQuery),\n        };\n      });\n      test('should create record with all default attributes', async () => {\n        const data = {};\n\n        await expect(instance.create(entityUID, { data })).resolves.toMatchObject({\n          attrStringDefaultRequired: 'default value',\n          attrStringDefault: 'default value',\n          attrBoolDefaultRequired: true,\n          attrBoolDefault: true,\n          attrIntDefaultRequired: 1,\n          attrIntDefault: 1,\n          attrEnumDefaultRequired: 'a',\n          attrEnumDefault: 'b',\n        });\n      });\n\n      test('should create record with default and required attributes', async () => {\n        const data = {\n          attrStringDefault: 'my value',\n          attrBoolDefault: false,\n          attrIntDefault: 2,\n          attrEnumDefault: 'c',\n        };\n\n        await expect(instance.create(entityUID, { data })).resolves.toMatchObject({\n          attrStringDefault: 'my value',\n          attrBoolDefault: false,\n          attrIntDefault: 2,\n          attrEnumDefault: 'c',\n          attrStringDefaultRequired: 'default value',\n          attrBoolDefaultRequired: true,\n          attrIntDefaultRequired: 1,\n          attrEnumDefaultRequired: 'a',\n        });\n      });\n\n      test('should create record with provided data', async () => {\n        const data = {\n          attrStringDefaultRequired: 'my value',\n          attrStringDefault: 'my value',\n          attrBoolDefaultRequired: true,\n          attrBoolDefault: true,\n          attrIntDefaultRequired: 10,\n          attrIntDefault: 10,\n          attrEnumDefaultRequired: 'c',\n          attrEnumDefault: 'a',\n          attrPassword: 'fooBar',\n        };\n\n        await expect(instance.create(entityUID, { data })).resolves.toMatchObject({\n          ...data,\n          attrPassword: 'secret-password',\n        });\n      });\n\n      test('should create record with valid relation', async () => {\n        const data = {\n          attrStringDefaultRequired: 'my value',\n          attrStringDefault: 'my value',\n          attrBoolDefaultRequired: true,\n          attrBoolDefault: true,\n          attrIntDefaultRequired: 10,\n          attrIntDefault: 10,\n          attrEnumDefaultRequired: 'c',\n          attrEnumDefault: 'a',\n          attrPassword: 'fooBar',\n          attrRelation: {\n            connect: [\n              {\n                id: 1,\n              },\n            ],\n          },\n        };\n\n        const res = instance.create(entityUID, { data });\n\n        await expect(res).resolves.toMatchObject({\n          ...data,\n          attrPassword: 'secret-password',\n        });\n      });\n\n      test('should fail to create a record with an invalid relation', async () => {\n        const data = {\n          attrStringDefaultRequired: 'my value',\n          attrStringDefault: 'my value',\n          attrBoolDefaultRequired: true,\n          attrBoolDefault: true,\n          attrIntDefaultRequired: 10,\n          attrIntDefault: 10,\n          attrEnumDefaultRequired: 'c',\n          attrEnumDefault: 'a',\n          attrPassword: 'fooBar',\n          attrRelation: {\n            connect: [\n              {\n                id: 3,\n              },\n            ],\n          },\n        };\n\n        const res = instance.create(entityUID, { data });\n        await expect(res).rejects.toThrowError(\n          new ValidationError(\n            `1 relation(s) of type api::relation.relation associated with this entity do not exist`\n          )\n        );\n      });\n    });\n\n    describe('with files', () => {\n      let instance;\n      beforeAll(() => {\n        fakeModels['test-model'] = {\n          uid: 'test-model',\n          kind: 'collectionType',\n          collectionName: 'test-model',\n          options: {},\n          attributes: {\n            name: {\n              type: 'string',\n            },\n            activity: {\n              displayName: 'activity',\n              type: 'component',\n              repeatable: true,\n              component: 'basic.activity',\n            },\n          },\n          modelType: 'contentType',\n          modelName: 'test-model',\n        };\n        fakeModels['basic.activity'] = {\n          collectionName: 'components_basic_activities',\n          info: {\n            displayName: 'activity',\n          },\n          options: {},\n          attributes: {\n            docs: {\n              allowedTypes: ['images', 'files', 'videos', 'audios'],\n              type: 'media',\n              multiple: true,\n            },\n            name: {\n              type: 'string',\n            },\n          },\n          uid: 'basic.activity',\n          category: 'basic',\n          modelType: 'component',\n          modelName: 'activity',\n          globalId: 'ComponentBasicActivity',\n        };\n\n        const fakeDB = {\n          query: jest.fn(() => fakeQuery),\n        };\n\n        const fakeStrapi = {\n          getModel: jest.fn((modelName) => fakeModels[modelName]),\n          query: jest.fn(() => fakeQuery),\n          db: {\n            dialect: {\n              client: 'sqlite',\n            },\n          },\n        };\n\n        global.strapi = fakeStrapi;\n\n        instance = createEntityService({\n          strapi: fakeStrapi,\n          db: fakeDB,\n          eventHub: new EventEmitter(),\n          entityValidator,\n        });\n      });\n      test('should create record with attached files', async () => {\n        const uploadFiles = require('../../utils/upload-files');\n        const data = {\n          name: 'demoEvent',\n          activity: [{ name: 'Powering the Aviation of the Future' }],\n        };\n        const files = {\n          'activity.0.docs': {\n            size: 381924,\n            path: '/tmp/upload_4cab76a3a443b584a1fd3aa52e045130',\n            name: 'thisisajpeg.jpeg',\n            type: 'image/jpeg',\n            mtime: '2022-11-03T13:36:51.764Z',\n          },\n        };\n\n        fakeQuery.findOne.mockResolvedValue({ id: 1, ...data });\n\n        await instance.create('test-model', { data, files });\n\n        expect(global.strapi.getModel).toBeCalled();\n        expect(uploadFiles).toBeCalled();\n        expect(uploadFiles).toBeCalledTimes(1);\n        expect(uploadFiles).toBeCalledWith(\n          'test-model',\n          {\n            id: 1,\n            name: 'demoEvent',\n            activity: [\n              {\n                id: 1,\n                __pivot: {\n                  field: 'activity',\n                  component_type: 'basic.activity',\n                },\n              },\n            ],\n          },\n          files\n        );\n      });\n    });\n  });\n\n  describe('Update', () => {\n    describe('assign default values', () => {\n      let instance;\n\n      const entityUID = 'api::entity.entity';\n      const relationUID = 'api::relation.relation';\n\n      const fakeEntities = {\n        [entityUID]: {\n          0: {\n            id: 0,\n            Name: 'TestEntity',\n            createdAt: '2022-09-28T15:11:22.995Z',\n            updatedAt: '2022-09-29T09:01:02.949Z',\n            publishedAt: null,\n          },\n        },\n        [relationUID]: {\n          1: {\n            id: 1,\n            Name: 'TestRelation',\n            createdAt: '2022-09-28T15:11:22.995Z',\n            updatedAt: '2022-09-29T09:01:02.949Z',\n            publishedAt: null,\n          },\n          2: {\n            id: 2,\n            Name: 'TestRelation2',\n            createdAt: '2022-09-28T15:11:22.995Z',\n            updatedAt: '2022-09-29T09:01:02.949Z',\n            publishedAt: null,\n          },\n        },\n      };\n      const fakeModels = {\n        [entityUID]: {\n          kind: 'collectionType',\n          modelName: 'entity',\n          collectionName: 'entity',\n          uid: entityUID,\n          options: {},\n          info: {\n            singularName: 'entity',\n            pluralName: 'entities',\n            displayName: 'ENTITY',\n          },\n          attributes: {\n            Name: {\n              type: 'string',\n            },\n            addresses: {\n              type: 'relation',\n              relation: 'oneToMany',\n              target: relationUID,\n              mappedBy: 'entity',\n            },\n          },\n        },\n        [relationUID]: {\n          kind: 'contentType',\n          modelName: 'relation',\n          attributes: {\n            Name: {\n              type: 'string',\n              default: 'default value',\n              required: true,\n            },\n          },\n        },\n      };\n\n      beforeAll(() => {\n        const fakeQuery = (key) => ({\n          findOne: jest.fn(({ where }) => fakeEntities[key][where.id]),\n          count: jest.fn(({ where }) => {\n            let ret = 0;\n            where.id.$in.forEach((id) => {\n              const entity = fakeEntities[key][id];\n              if (!entity) return;\n              ret += 1;\n            });\n            return ret;\n          }),\n          update: jest.fn(({ where }) => ({\n            ...fakeEntities[key][where.id],\n            addresses: {\n              count: 1,\n            },\n          })),\n        });\n\n        const fakeDB = {\n          query: jest.fn((key) => fakeQuery(key)),\n        };\n\n        global.strapi = {\n          getModel: jest.fn((uid) => {\n            return fakeModels[uid];\n          }),\n          db: fakeDB,\n        };\n\n        instance = createEntityService({\n          strapi: global.strapi,\n          db: fakeDB,\n          eventHub: new EventEmitter(),\n          entityValidator,\n        });\n      });\n\n      test(`should fail if the entity doesn't exist`, async () => {\n        expect(\n          await instance.update(entityUID, Math.random() * (10000 - 100) + 100, {})\n        ).toBeNull();\n      });\n\n      test('should successfully update an existing relation', async () => {\n        const data = {\n          Name: 'TestEntry',\n          addresses: {\n            connect: [\n              {\n                id: 1,\n              },\n            ],\n          },\n        };\n        expect(await instance.update(entityUID, 0, { data })).toMatchObject({\n          ...fakeEntities[entityUID][0],\n          addresses: {\n            count: 1,\n          },\n        });\n      });\n\n      test('should throw an error when trying to associate a relation that does not exist', async () => {\n        const data = {\n          Name: 'TestEntry',\n          addresses: {\n            connect: [\n              {\n                id: 3,\n              },\n            ],\n          },\n        };\n\n        const res = instance.update(entityUID, 0, { data });\n        await expect(res).rejects.toThrowError(\n          new ValidationError(\n            `1 relation(s) of type api::relation.relation associated with this entity do not exist`\n          )\n        );\n      });\n    });\n  });\n});\n", "'use strict';\n\nconst strapiUtils = require('@strapi/utils');\nconst {\n  errors: { YupValidationError },\n} = require('@strapi/utils');\nconst validators = require('../validators');\n\ndescribe('BigInteger validator', () => {\n  describe('unique', () => {\n    const fakeFindOne = jest.fn();\n\n    global.strapi = {\n      db: {\n        query: jest.fn(() => ({\n          findOne: fakeFindOne,\n        })),\n      },\n    };\n\n    afterEach(() => {\n      jest.clearAllMocks();\n      fakeFindOne.mockReset();\n    });\n\n    const fakeModel = {\n      kind: 'contentType',\n      modelName: 'test-model',\n      uid: 'test-uid',\n      options: {},\n      attributes: {\n        attrBigIntegerUnique: { type: 'biginteger', unique: true },\n      },\n    };\n\n    test('it does not validate the unique constraint if the attribute is not set as unique', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.biginteger(\n          {\n            attr: { type: 'biginteger' },\n            model: fakeModel,\n            updatedAttribute: {\n              name: 'attrBigIntegerUnique',\n              value: 1,\n            },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator(1);\n\n      expect(fakeFindOne).not.toHaveBeenCalled();\n    });\n\n    test('it does not validate the unique constraint if the attribute value is `null`', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators\n          .biginteger(\n            {\n              attr: { type: 'biginteger', unique: true },\n              model: fakeModel,\n              updatedAttribute: {\n                name: 'attrBigIntegerUnique',\n                value: null,\n              },\n              entity: null,\n            },\n            { isDraft: false }\n          )\n          .nullable()\n      );\n\n      await validator(null);\n\n      expect(fakeFindOne).not.toHaveBeenCalled();\n    });\n\n    test('it validates the unique constraint if there is no other record in the database', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.biginteger(\n          {\n            attr: { type: 'biginteger', unique: true },\n            model: fakeModel,\n            updatedAttribute: {\n              name: 'attrBigIntegerUnique',\n              value: 1,\n            },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator(1)).toBe(1);\n    });\n\n    test('it fails the validation of the unique constraint if the database contains a record with the same attribute value', async () => {\n      expect.assertions(1);\n      fakeFindOne.mockResolvedValueOnce({ attrBigIntegerUnique: 2 });\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.biginteger(\n          {\n            attr: { type: 'biginteger', unique: true },\n            model: fakeModel,\n            updatedAttribute: {\n              name: 'attrBigIntegerUnique',\n              value: 2,\n            },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      try {\n        await validator(2);\n      } catch (err) {\n        expect(err).toBeInstanceOf(YupValidationError);\n      }\n    });\n\n    test('it validates the unique constraint if the attribute data has not changed even if there is a record in the database with the same attribute value', async () => {\n      fakeFindOne.mockResolvedValueOnce({ attrBigIntegerUnique: 3 });\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.biginteger(\n          {\n            attr: { type: 'biginteger', unique: true },\n            model: fakeModel,\n            updatedAttribute: {\n              name: 'attrBigIntegerUnique',\n              value: 3,\n            },\n            entity: { id: 1, attrBigIntegerUnique: 3 },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator(3)).toBe(3);\n    });\n\n    test('it checks the database for records with the same value for the checked attribute', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.biginteger(\n          {\n            attr: { type: 'biginteger', unique: true },\n            model: fakeModel,\n            updatedAttribute: {\n              name: 'attrBigIntegerUnique',\n              value: 4,\n            },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator(4);\n\n      expect(fakeFindOne).toHaveBeenCalledWith({\n        select: ['id'],\n        where: { attrBigIntegerUnique: 4 },\n      });\n    });\n\n    test('it checks the database for records with the same value but not the same id for the checked attribute if an entity is passed', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.biginteger(\n          {\n            attr: { type: 'biginteger', unique: true },\n            model: fakeModel,\n            updatedAttribute: {\n              name: 'attrBigIntegerUnique',\n              value: 5,\n            },\n            entity: { id: 1, attrBigIntegerUnique: 42 },\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator(5);\n\n      expect(fakeFindOne).toHaveBeenCalledWith({\n        select: ['id'],\n        where: { $and: [{ attrBigIntegerUnique: 5 }, { $not: { id: 1 } }] },\n      });\n    });\n  });\n\n  describe('min', () => {\n    test('it does not validate the min constraint if the attribute min is not a number', async () => {\n      const validator = strapiUtils.validateYupSchema(\n        validators.biginteger(\n          {\n            attr: { type: 'biginteger', minLength: '123' },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator(1)).toBe(1);\n    });\n  });\n});\n", "'use strict';\n\nconst strapiUtils = require('@strapi/utils');\nconst {\n  errors: { YupValidationError },\n} = require('@strapi/utils');\nconst validators = require('../validators');\n\ndescribe('Date validator', () => {\n  describe('unique', () => {\n    const fakeFindOne = jest.fn();\n\n    global.strapi = {\n      db: {\n        query: jest.fn(() => ({\n          findOne: fakeFindOne,\n        })),\n      },\n    };\n\n    afterEach(() => {\n      jest.clearAllMocks();\n      fakeFindOne.mockReset();\n    });\n\n    const fakeModel = {\n      kind: 'contentType',\n      modelName: 'test-model',\n      uid: 'test-uid',\n      options: {},\n      attributes: {\n        attrDateUnique: { type: 'date', unique: true },\n      },\n    };\n\n    test('it does not validates the unique constraint if the attribute is not set as unique', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.date(\n          {\n            attr: { type: 'date' },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrDateUnique', value: '2021-11-29' },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator('2021-11-29');\n\n      expect(fakeFindOne).not.toHaveBeenCalled();\n    });\n\n    test('it does not validates the unique constraint if the attribute value is `null`', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators\n          .date(\n            {\n              attr: { type: 'date', unique: true },\n              model: fakeModel,\n              updatedAttribute: { name: 'attrDateUnique', value: null },\n              entity: null,\n            },\n            { isDraft: false }\n          )\n          .nullable()\n      );\n\n      await validator(null);\n      expect(fakeFindOne).not.toHaveBeenCalled();\n    });\n\n    test('it validates the unique constraint if there is no other record in the database', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.date(\n          {\n            attr: { type: 'date', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrDateUnique', value: '2021-11-29' },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator('2021-11-29')).toBe('2021-11-29');\n    });\n\n    test('it fails the validation of the unique constraint if the database contains a record with the same attribute value', async () => {\n      expect.assertions(1);\n      fakeFindOne.mockResolvedValueOnce({ attrDateUnique: '2021-11-29' });\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.date(\n          {\n            attr: { type: 'date', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrDateUnique', value: '2021-11-29' },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      try {\n        await validator('2021-11-29');\n      } catch (err) {\n        expect(err).toBeInstanceOf(YupValidationError);\n      }\n    });\n\n    test('it validates the unique constraint if the attribute data has not changed even if there is a record in the database with the same attribute value', async () => {\n      fakeFindOne.mockResolvedValueOnce({ attrDateUnique: '2021-11-29' });\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.date(\n          {\n            attr: { type: 'date', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrDateUnique', value: '2021-11-29' },\n            entity: { id: 1, attrDateUnique: '2021-11-29' },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator('2021-11-29')).toBe('2021-11-29');\n    });\n\n    test('it checks the database for records with the same value for the checked attribute', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.date(\n          {\n            attr: { type: 'date', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrDateUnique', value: '2021-11-29' },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator('2021-11-29');\n\n      expect(fakeFindOne).toHaveBeenCalledWith({\n        select: ['id'],\n        where: { attrDateUnique: '2021-11-29' },\n      });\n    });\n\n    test('it checks the database for records with the same value but not the same id for the checked attribute if an entity is passed', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.date(\n          {\n            attr: { type: 'date', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrDateUnique', value: '2021-11-29' },\n            entity: { id: 1, attrDateUnique: '2021-12-15' },\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator('2021-11-29');\n\n      expect(fakeFindOne).toHaveBeenCalledWith({\n        select: ['id'],\n        where: { $and: [{ attrDateUnique: '2021-11-29' }, { $not: { id: 1 } }] },\n      });\n    });\n  });\n});\n", "'use strict';\n\nconst strapiUtils = require('@strapi/utils');\nconst {\n  errors: { YupValidationError },\n} = require('@strapi/utils');\nconst validators = require('../validators');\n\ndescribe('Datetime validator', () => {\n  describe('unique', () => {\n    const fakeFindOne = jest.fn();\n\n    global.strapi = {\n      db: {\n        query: jest.fn(() => ({\n          findOne: fakeFindOne,\n        })),\n      },\n    };\n\n    afterEach(() => {\n      jest.clearAllMocks();\n      fakeFindOne.mockReset();\n    });\n\n    const fakeModel = {\n      kind: 'contentType',\n      modelName: 'test-model',\n      uid: 'test-uid',\n      options: {},\n      attributes: {\n        attrDateTimeUnique: { type: 'datetime', unique: true },\n      },\n    };\n\n    test('it does not validates the unique constraint if the attribute is not set as unique', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.datetime(\n          {\n            attr: { type: 'datetime' },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrDateTimeUnique', value: '2021-11-29T00:00:00.000Z' },\n            entity: { id: 1, attrDateTimeUnique: '2021-11-29T00:00:00.000Z' },\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator('2021-11-29T00:00:00.000Z');\n\n      expect(fakeFindOne).not.toHaveBeenCalled();\n    });\n\n    test('it does not validates the unique constraint if the attribute value is `null`', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators\n          .datetime(\n            {\n              attr: { type: 'datetime', unique: true },\n              model: fakeModel,\n              updatedAttribute: { name: 'attrDateTimeUnique', value: null },\n              entity: null,\n            },\n            { isDraft: false }\n          )\n          .nullable()\n      );\n\n      await validator(null);\n      expect(fakeFindOne).not.toHaveBeenCalled();\n    });\n\n    test('it validates the unique constraint if there is no other record in the database', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.datetime(\n          {\n            attr: { type: 'datetime', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrDateTimeUnique', value: '2021-11-29T00:00:00.000Z' },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator('2021-11-29T00:00:00.000Z')).toBe('2021-11-29T00:00:00.000Z');\n    });\n\n    test('it fails the validation of the unique constraint if the database contains a record with the same attribute value', async () => {\n      expect.assertions(1);\n      fakeFindOne.mockResolvedValueOnce({ attrDateTimeUnique: '2021-11-29T00:00:00.000Z' });\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.datetime(\n          {\n            attr: { type: 'datetime', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrDateTimeUnique', value: '2021-11-29T00:00:00.000Z' },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      try {\n        await validator('2021-11-29T00:00:00.000Z');\n      } catch (err) {\n        expect(err).toBeInstanceOf(YupValidationError);\n      }\n    });\n\n    test('it validates the unique constraint if the attribute data has not changed even if there is a record in the database with the same attribute value', async () => {\n      fakeFindOne.mockResolvedValueOnce({ attrDateTimeUnique: '2021-11-29T00:00:00.000Z' });\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.datetime(\n          {\n            attr: { type: 'datetime', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrDateTimeUnique', value: '2021-11-29T00:00:00.000Z' },\n            entity: { id: 1, attrDateTimeUnique: '2021-11-29T00:00:00.000Z' },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator('2021-11-29T00:00:00.000Z')).toBe('2021-11-29T00:00:00.000Z');\n    });\n\n    test('it checks the database for records with the same value for the checked attribute', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.datetime(\n          {\n            attr: { type: 'datetime', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrDateTimeUnique', value: '2021-11-29T00:00:00.000Z' },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator('2021-11-29T00:00:00.000Z');\n\n      expect(fakeFindOne).toHaveBeenCalledWith({\n        select: ['id'],\n        where: { attrDateTimeUnique: '2021-11-29T00:00:00.000Z' },\n      });\n    });\n\n    test('it checks the database for records with the same value but not the same id for the checked attribute if an entity is passed', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.datetime(\n          {\n            attr: { type: 'datetime', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrDateTimeUnique', value: '2021-11-29T00:00:00.000Z' },\n            entity: { id: 1, attrDateTimeUnique: '2021-12-25T00:00:00.000Z' },\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator('2021-11-29T00:00:00.000Z');\n\n      expect(fakeFindOne).toHaveBeenCalledWith({\n        select: ['id'],\n        where: { $and: [{ attrDateTimeUnique: '2021-11-29T00:00:00.000Z' }, { $not: { id: 1 } }] },\n      });\n    });\n  });\n});\n", "'use strict';\n\nconst strapiUtils = require('@strapi/utils');\nconst {\n  errors: { YupValidationError },\n} = require('@strapi/utils');\nconst validators = require('../validators');\n\ndescribe('Float validator', () => {\n  describe('unique', () => {\n    const fakeFindOne = jest.fn();\n\n    global.strapi = {\n      db: {\n        query: jest.fn(() => ({\n          findOne: fakeFindOne,\n        })),\n      },\n    };\n\n    afterEach(() => {\n      jest.clearAllMocks();\n      fakeFindOne.mockReset();\n    });\n\n    const fakeModel = {\n      kind: 'contentType',\n      uid: 'test-uid',\n      modelName: 'test-model',\n      options: {},\n      attributes: {\n        attrFloatUnique: { type: 'float', unique: true },\n      },\n    };\n\n    test('it does not validates the unique constraint if the attribute is not set as unique', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.float(\n          {\n            attr: { type: 'float' },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrFloatUnique', value: 1 },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator(1);\n\n      expect(fakeFindOne).not.toHaveBeenCalled();\n    });\n\n    test('it does not validates the unique constraint if the attribute value is `null`', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators\n          .float(\n            {\n              attr: { type: 'float', unique: true },\n              model: fakeModel,\n              updatedAttribute: { name: 'attrFloatUnique', value: null },\n              entity: null,\n            },\n            { isDraft: false }\n          )\n          .nullable()\n      );\n\n      await validator(null);\n\n      expect(fakeFindOne).not.toHaveBeenCalled();\n    });\n\n    test('it validates the unique constraint if there is no other record in the database', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.float(\n          {\n            attr: { type: 'float', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrFloatUnique', value: 2 },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator(1)).toBe(1);\n    });\n\n    test('it fails the validation of the unique constraint if the database contains a record with the same attribute value', async () => {\n      expect.assertions(1);\n      fakeFindOne.mockResolvedValueOnce({ attrFloatUnique: 2 });\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.float(\n          {\n            attr: { type: 'float', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrFloatUnique', value: 2 },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      try {\n        await validator(2);\n      } catch (err) {\n        expect(err).toBeInstanceOf(YupValidationError);\n      }\n    });\n\n    test('it validates the unique constraint if the attribute data has not changed even if there is a record in the database with the same attribute value', async () => {\n      fakeFindOne.mockResolvedValueOnce({ attrFloatUnique: 3 });\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.float(\n          {\n            attr: { type: 'float', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrFloatUnique', value: 3 },\n            entity: { id: 1, attrFloatUnique: 3 },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator(3)).toBe(3);\n    });\n\n    test('it checks the database for records with the same value for the checked attribute', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.float(\n          {\n            attr: { type: 'float', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrFloatUnique', value: 4 },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator(4);\n\n      expect(fakeFindOne).toHaveBeenCalledWith({\n        select: ['id'],\n        where: { attrFloatUnique: 4 },\n      });\n    });\n\n    test('it checks the database for records with the same value but not the same id for the checked attribute if an entity is passed', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.float(\n          {\n            attr: { type: 'float', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrFloatUnique', value: 5 },\n            entity: { id: 1, attrFloatUnique: 42 },\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator(5);\n\n      expect(fakeFindOne).toHaveBeenCalledWith({\n        select: ['id'],\n        where: { $and: [{ attrFloatUnique: 5 }, { $not: { id: 1 } }] },\n      });\n    });\n  });\n\n  describe('min', () => {\n    test('it does not validates the min constraint if the attribute min is not a number', async () => {\n      const validator = strapiUtils.validateYupSchema(\n        validators.float(\n          {\n            attr: { type: 'float', minLength: '123' },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator(1)).toBe(1);\n    });\n\n    test('it fails the validation if the float is lower than the define min', async () => {\n      expect.assertions(1);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.float(\n          {\n            attr: { type: 'float', min: 3 },\n          },\n          { isDraft: false }\n        )\n      );\n\n      try {\n        await validator(1);\n      } catch (err) {\n        expect(err).toBeInstanceOf(YupValidationError);\n      }\n    });\n\n    test('it validates the min constraint if the float is higher than the define min', async () => {\n      const validator = strapiUtils.validateYupSchema(\n        validators.float(\n          {\n            attr: { type: 'float', min: 3 },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator(4)).toBe(4);\n    });\n  });\n\n  describe('max', () => {\n    test('it does not validates the max constraint if the attribute max is not an float', async () => {\n      const validator = strapiUtils.validateYupSchema(\n        validators.float(\n          {\n            attr: { type: 'float', maxLength: '123' },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator(1)).toBe(1);\n    });\n\n    test('it fails the validation if the number is float than the define max', async () => {\n      expect.assertions(1);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.float(\n          {\n            attr: { type: 'float', max: 3 },\n          },\n          { isDraft: false }\n        )\n      );\n\n      try {\n        await validator(4);\n      } catch (err) {\n        expect(err).toBeInstanceOf(YupValidationError);\n      }\n    });\n\n    test('it validates the max constraint if the float is lower than the define max', async () => {\n      const validator = strapiUtils.validateYupSchema(\n        validators.float(\n          {\n            attr: { type: 'float', max: 3 },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator(2)).toBe(2);\n    });\n  });\n});\n", "'use strict';\n\nconst strapiUtils = require('@strapi/utils');\nconst {\n  errors: { YupValidationError },\n} = require('@strapi/utils');\nconst validators = require('../validators');\n\ndescribe('Integer validator', () => {\n  describe('unique', () => {\n    const fakeFindOne = jest.fn();\n\n    global.strapi = {\n      db: {\n        query: jest.fn(() => ({\n          findOne: fakeFindOne,\n        })),\n      },\n    };\n\n    afterEach(() => {\n      jest.clearAllMocks();\n      fakeFindOne.mockReset();\n    });\n\n    const fakeModel = {\n      kind: 'contentType',\n      uid: 'test-uid',\n      modelName: 'test-model',\n      options: {},\n      attributes: {\n        attrIntegerUnique: { type: 'integer', unique: true },\n      },\n    };\n\n    test('it does not validates the unique constraint if the attribute is not set as unique', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.integer(\n          {\n            attr: { type: 'integer' },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrIntegerUnique', value: 1 },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator(1);\n\n      expect(fakeFindOne).not.toHaveBeenCalled();\n    });\n\n    test('it does not validates the unique constraint if the attribute value is `null`', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators\n          .integer(\n            {\n              attr: { type: 'integer', unique: true },\n              model: fakeModel,\n              updatedAttribute: { name: 'attrIntegerUnique', value: null },\n              entity: null,\n            },\n            { isDraft: false }\n          )\n          .nullable()\n      );\n\n      await validator(null);\n\n      expect(fakeFindOne).not.toHaveBeenCalled();\n    });\n\n    test('it validates the unique constraint if there is no other record in the database', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.integer(\n          {\n            attr: { type: 'integer', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrIntegerUnique', value: 2 },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator(1)).toBe(1);\n    });\n\n    test('it fails the validation of the unique constraint if the database contains a record with the same attribute value', async () => {\n      expect.assertions(1);\n      fakeFindOne.mockResolvedValueOnce({ attrIntegerUnique: 2 });\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.integer(\n          {\n            attr: { type: 'integer', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrIntegerUnique', value: 2 },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      try {\n        await validator(2);\n      } catch (err) {\n        expect(err).toBeInstanceOf(YupValidationError);\n      }\n    });\n\n    test('it validates the unique constraint if the attribute data has not changed even if there is a record in the database with the same attribute value', async () => {\n      fakeFindOne.mockResolvedValueOnce({ attrIntegerUnique: 3 });\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.integer(\n          {\n            attr: { type: 'integer', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrIntegerUnique', value: 3 },\n            entity: { id: 1, attrIntegerUnique: 3 },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator(3)).toBe(3);\n    });\n\n    test('it checks the database for records with the same value for the checked attribute', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.integer(\n          {\n            attr: { type: 'integer', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrIntegerUnique', value: 4 },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator(4);\n\n      expect(fakeFindOne).toHaveBeenCalledWith({\n        select: ['id'],\n        where: { attrIntegerUnique: 4 },\n      });\n    });\n\n    test('it checks the database for records with the same value but not the same id for the checked attribute if an entity is passed', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.integer(\n          {\n            attr: { type: 'integer', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrIntegerUnique', value: 5 },\n            entity: { id: 1, attrIntegerUnique: 42 },\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator(5);\n\n      expect(fakeFindOne).toHaveBeenCalledWith({\n        select: ['id'],\n        where: { $and: [{ attrIntegerUnique: 5 }, { $not: { id: 1 } }] },\n      });\n    });\n  });\n\n  describe('min', () => {\n    test('it does not validates the min constraint if the attribute min is not a number', async () => {\n      const validator = strapiUtils.validateYupSchema(\n        validators.integer(\n          {\n            attr: { type: 'integer', minLength: '123' },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator(1)).toBe(1);\n    });\n\n    test('it fails the validation if the integer is lower than the define min', async () => {\n      expect.assertions(1);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.integer(\n          {\n            attr: { type: 'integer', min: 3 },\n          },\n          { isDraft: false }\n        )\n      );\n\n      try {\n        await validator(1);\n      } catch (err) {\n        expect(err).toBeInstanceOf(YupValidationError);\n      }\n    });\n\n    test('it validates the min constraint if the integer is higher than the define min', async () => {\n      const validator = strapiUtils.validateYupSchema(\n        validators.integer(\n          {\n            attr: { type: 'integer', min: 3 },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator(4)).toBe(4);\n    });\n  });\n\n  describe('max', () => {\n    test('it does not validates the max constraint if the attribute max is not an integer', async () => {\n      const validator = strapiUtils.validateYupSchema(\n        validators.integer(\n          {\n            attr: { type: 'integer', maxLength: '123' },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator(1)).toBe(1);\n    });\n\n    test('it fails the validation if the number is integer than the define max', async () => {\n      expect.assertions(1);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.integer(\n          {\n            attr: { type: 'integer', max: 3 },\n          },\n          { isDraft: false }\n        )\n      );\n\n      try {\n        await validator(4);\n      } catch (err) {\n        expect(err).toBeInstanceOf(YupValidationError);\n      }\n    });\n\n    test('it validates the max constraint if the integer is lower than the define max', async () => {\n      const validator = strapiUtils.validateYupSchema(\n        validators.integer(\n          {\n            attr: { type: 'integer', max: 3 },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator(2)).toBe(2);\n    });\n  });\n});\n", "'use strict';\n\nconst strapiUtils = require('@strapi/utils');\nconst {\n  errors: { YupValidationError },\n} = require('@strapi/utils');\nconst validators = require('../validators');\n\ndescribe('String validator', () => {\n  describe('unique', () => {\n    const fakeFindOne = jest.fn();\n\n    global.strapi = {\n      db: {\n        query: jest.fn(() => ({\n          findOne: fakeFindOne,\n        })),\n      },\n    };\n\n    afterEach(() => {\n      jest.clearAllMocks();\n      fakeFindOne.mockReset();\n    });\n\n    const fakeModel = {\n      kind: 'contentType',\n      modelName: 'test-model',\n      uid: 'test-uid',\n      options: {},\n      attributes: {\n        attrStringUnique: { type: 'string', unique: true },\n      },\n    };\n\n    test('it does not validates the unique constraint if the attribute is not set as unique', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.string(\n          {\n            attr: { type: 'string' },\n            model: fakeModel,\n            updatedAttribute: {\n              name: 'attrStringUnique',\n              value: 'non-unique-test-data',\n            },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator('non-unique-test-data');\n\n      expect(fakeFindOne).not.toHaveBeenCalled();\n    });\n\n    test('it does not validates the unique constraint if the attribute value is `null`', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators\n          .string(\n            {\n              attr: { type: 'string', unique: true },\n              model: fakeModel,\n              updatedAttribute: {\n                name: 'attrStringUnique',\n                value: null,\n              },\n              entity: null,\n            },\n            { isDraft: false }\n          )\n          .nullable()\n      );\n\n      await validator(null);\n\n      expect(fakeFindOne).not.toHaveBeenCalled();\n    });\n\n    test('it validates the unique constraint if there is no other record in the database', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.string(\n          {\n            attr: { type: 'string', unique: true },\n            model: fakeModel,\n            updatedAttribute: {\n              name: 'attrStringUnique',\n              value: 'non-unique-test-data',\n            },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator('non-unique-test-data')).toBe('non-unique-test-data');\n    });\n\n    test('it fails the validation of the unique constraint if the database contains a record with the same attribute value', async () => {\n      expect.assertions(1);\n      fakeFindOne.mockResolvedValueOnce({ attrStringUnique: 'unique-test-data' });\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.string(\n          {\n            attr: { type: 'string', unique: true },\n            model: fakeModel,\n            updatedAttribute: {\n              name: 'attrStringUnique',\n              value: 'unique-test-data',\n            },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      try {\n        await validator('unique-test-data');\n      } catch (err) {\n        expect(err).toBeInstanceOf(YupValidationError);\n      }\n    });\n\n    test('it validates the unique constraint if the attribute data has not changed even if there is a record in the database with the same attribute value', async () => {\n      fakeFindOne.mockResolvedValueOnce({ attrStringUnique: 'non-updated-unique-test-data' });\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.string(\n          {\n            attr: { type: 'string', unique: true },\n            model: fakeModel,\n            updatedAttribute: {\n              name: 'attrStringUnique',\n              value: 'non-updated-unique-test-data',\n            },\n            entity: { id: 1, attrStringUnique: 'non-updated-unique-test-data' },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator('non-updated-unique-test-data')).toBe('non-updated-unique-test-data');\n    });\n\n    test('it checks the database for records with the same value for the checked attribute', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.string(\n          {\n            attr: { type: 'string', unique: true },\n            model: fakeModel,\n            updatedAttribute: {\n              name: 'attrStringUnique',\n              value: 'test-data',\n            },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator('test-data');\n\n      expect(fakeFindOne).toHaveBeenCalledWith({\n        select: ['id'],\n        where: { attrStringUnique: 'test-data' },\n      });\n    });\n\n    test('it checks the database for records with the same value but not the same id for the checked attribute if an entity is passed', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.string(\n          {\n            attr: { type: 'string', unique: true },\n            model: fakeModel,\n            updatedAttribute: {\n              name: 'attrStringUnique',\n              value: 'test-data',\n            },\n            entity: { id: 1, attrStringUnique: 'other-data' },\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator('test-data');\n\n      expect(fakeFindOne).toHaveBeenCalledWith({\n        select: ['id'],\n        where: { $and: [{ attrStringUnique: 'test-data' }, { $not: { id: 1 } }] },\n      });\n    });\n  });\n\n  describe('minLength', () => {\n    test('it does not validates the minLength constraint if the attribute minLength is not an integer', async () => {\n      const validator = strapiUtils.validateYupSchema(\n        validators.string(\n          {\n            attr: { type: 'string', minLength: '123' },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator('a')).toBe('a');\n    });\n\n    test('it does not validates the minLength constraint if it is a draft', async () => {\n      const validator = strapiUtils.validateYupSchema(\n        validators.string(\n          {\n            attr: { type: 'string', minLength: 3 },\n          },\n          { isDraft: true }\n        )\n      );\n\n      expect(await validator('a')).toBe('a');\n    });\n\n    test('it fails the validation if the string is shorter than the define minLength', async () => {\n      expect.assertions(1);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.string(\n          {\n            attr: { type: 'string', minLength: 3 },\n          },\n          { isDraft: false }\n        )\n      );\n\n      try {\n        await validator('a');\n      } catch (err) {\n        expect(err).toBeInstanceOf(YupValidationError);\n      }\n    });\n\n    test('it validates the minLength constraint if the string is longer than the define minLength', async () => {\n      const validator = strapiUtils.validateYupSchema(\n        validators.string(\n          {\n            attr: { type: 'string', minLength: 3 },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator('this string is longer than the minLenght')).toBe(\n        'this string is longer than the minLenght'\n      );\n    });\n  });\n\n  describe('maxLength', () => {\n    test('it does not validates the maxLength constraint if the attribute maxLength is not an integer', async () => {\n      const validator = strapiUtils.validateYupSchema(\n        validators.string(\n          {\n            attr: { type: 'string', maxLength: '123' },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator('a')).toBe('a');\n    });\n\n    test('it fails the validation if the string is longer than the define maxLength', async () => {\n      expect.assertions(1);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.string(\n          {\n            attr: { type: 'string', maxLength: 3 },\n          },\n          { isDraft: false }\n        )\n      );\n\n      try {\n        await validator('this string is too long');\n      } catch (err) {\n        expect(err).toBeInstanceOf(YupValidationError);\n      }\n    });\n\n    test('it validates the maxLength constraint if the string is shorter than the define maxLength', async () => {\n      const validator = strapiUtils.validateYupSchema(\n        validators.string(\n          {\n            attr: { type: 'string', maxLength: 3 },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator('a')).toBe('a');\n    });\n  });\n\n  describe('regExp', () => {\n    test('it fails the validation of an empty string for a required field', async () => {\n      expect.assertions(1);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.string(\n          {\n            attr: { type: 'string', required: true, regex: '^\\\\w+$' },\n          },\n          { isDraft: false }\n        )\n      );\n\n      try {\n        await validator('');\n      } catch (err) {\n        expect(err).toBeInstanceOf(YupValidationError);\n      }\n    });\n\n    test('it validates a string for required field according to the regex constraint', async () => {\n      const validator = strapiUtils.validateYupSchema(\n        validators.string(\n          {\n            attr: { type: 'string', required: true, regex: '^\\\\w+$' },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator('Strapi')).toBe('Strapi');\n    });\n\n    test('it validates an empty string for non-required field with a regex constraint', async () => {\n      const validator = strapiUtils.validateYupSchema(\n        validators.string(\n          {\n            attr: { type: 'string', required: false, regex: '^\\\\w+$' },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator('')).toBe('');\n    });\n\n    test('it validates a string for non-required field according to the regex constraint', async () => {\n      const validator = strapiUtils.validateYupSchema(\n        validators.string(\n          {\n            attr: { type: 'string', required: false, regex: '^\\\\w+$' },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator('Strapi')).toBe('Strapi');\n    });\n  });\n});\n", "'use strict';\n\nconst strapiUtils = require('@strapi/utils');\nconst {\n  errors: { YupValidationError },\n} = require('@strapi/utils');\nconst validators = require('../validators');\n\ndescribe('Time validator', () => {\n  describe('unique', () => {\n    const fakeFindOne = jest.fn();\n\n    global.strapi = {\n      db: {\n        query: jest.fn(() => ({\n          findOne: fakeFindOne,\n        })),\n      },\n    };\n\n    afterEach(() => {\n      jest.clearAllMocks();\n      fakeFindOne.mockReset();\n    });\n\n    const fakeModel = {\n      kind: 'contentType',\n      modelName: 'test-model',\n      uid: 'test-uid',\n      options: {},\n      attributes: {\n        attrTimeUnique: { type: 'time', unique: true },\n      },\n    };\n\n    test('it does not validates the unique constraint if the attribute is not set as unique', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.time(\n          {\n            attr: { type: 'time' },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrTimeUnique', value: '00:00:00.000Z' },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator('00:00:00.000Z');\n\n      expect(fakeFindOne).not.toHaveBeenCalled();\n    });\n\n    test('it does not validates the unique constraint if the attribute value is `null`', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators\n          .time(\n            {\n              attr: { type: 'time', unique: true },\n              model: fakeModel,\n              updatedAttribute: { name: 'attrTimeUnique', value: null },\n              entity: { id: 1, attrTimeUnique: '00:00:00.000Z' },\n            },\n            { isDraft: false }\n          )\n          .nullable()\n      );\n\n      await validator(null);\n      expect(fakeFindOne).not.toHaveBeenCalled();\n    });\n\n    test('it validates the unique constraint if there is no other record in the database', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.time(\n          {\n            attr: { type: 'time', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrTimeUnique', value: '00:00:00.000Z' },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator('00:00:00.000Z')).toBe('00:00:00.000Z');\n    });\n\n    test('it fails the validation of the unique constraint if the database contains a record with the same attribute value', async () => {\n      expect.assertions(1);\n      fakeFindOne.mockResolvedValueOnce({ attrTimeUnique: '00:00:00.000Z' });\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.time(\n          {\n            attr: { type: 'time', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrTimeUnique', value: '00:00:00.000Z' },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      try {\n        await validator('00:00:00.000Z');\n      } catch (err) {\n        expect(err).toBeInstanceOf(YupValidationError);\n      }\n    });\n\n    test('it validates the unique constraint if the attribute data has not changed even if there is a record in the database with the same attribute value', async () => {\n      fakeFindOne.mockResolvedValueOnce({ attrTimeUnique: '00:00:00.000Z' });\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.time(\n          {\n            attr: { type: 'time', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrTimeUnique', value: '00:00:00.000Z' },\n            entity: { id: 1, attrTimeUnique: '00:00:00.000Z' },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator('00:00:00.000Z')).toBe('00:00:00.000Z');\n    });\n\n    test('it checks the database for records with the same value for the checked attribute', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.time(\n          {\n            attr: { type: 'time', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrTimeUnique', value: '00:00:00.000Z' },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator('00:00:00.000Z');\n\n      expect(fakeFindOne).toHaveBeenCalledWith({\n        select: ['id'],\n        where: { attrTimeUnique: '00:00:00.000Z' },\n      });\n    });\n\n    test('it checks the database for records with the same value but not the same id for the checked attribute if an entity is passed', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.time(\n          {\n            attr: { type: 'time', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrTimeUnique', value: '00:00:00.000Z' },\n            entity: { id: 1, attrTimeUnique: '01:00:00.000Z' },\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator('00:00:00.000Z');\n\n      expect(fakeFindOne).toHaveBeenCalledWith({\n        select: ['id'],\n        where: { $and: [{ attrTimeUnique: '00:00:00.000Z' }, { $not: { id: 1 } }] },\n      });\n    });\n  });\n});\n", "'use strict';\n\nconst strapiUtils = require('@strapi/utils');\nconst {\n  errors: { YupValidationError },\n} = require('@strapi/utils');\nconst validators = require('../validators');\n\ndescribe('Time validator', () => {\n  describe('unique', () => {\n    const fakeFindOne = jest.fn();\n\n    global.strapi = {\n      db: {\n        query: jest.fn(() => ({\n          findOne: fakeFindOne,\n        })),\n      },\n    };\n\n    afterEach(() => {\n      jest.clearAllMocks();\n      fakeFindOne.mockReset();\n    });\n\n    const fakeModel = {\n      kind: 'contentType',\n      modelName: 'test-model',\n      uid: 'test-uid',\n      options: {},\n      attributes: {\n        attrTimestampUnique: { type: 'timestamp', unique: true },\n      },\n    };\n\n    test('it does not validates the unique constraint if the attribute is not set as unique', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.timestamp(\n          {\n            attr: { type: 'timestamp' },\n            model: fakeModel,\n            updatedAttribute: {\n              name: 'attrTimestampUnique',\n              value: '1638140400',\n            },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator('1638140400');\n\n      expect(fakeFindOne).not.toHaveBeenCalled();\n    });\n\n    test('it does not validates the unique constraint if the attribute value is `null`', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators\n          .timestamp(\n            {\n              attr: { type: 'timestamp', unique: true },\n              model: fakeModel,\n              updatedAttribute: {\n                name: 'attrTimestampUnique',\n                value: null,\n              },\n              entity: null,\n            },\n            { isDraft: false }\n          )\n          .nullable()\n      );\n\n      await validator(null);\n      expect(fakeFindOne).not.toHaveBeenCalled();\n    });\n\n    test('it validates the unique constraint if there is no other record in the database', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.timestamp(\n          {\n            attr: { type: 'timestamp', unique: true },\n            model: fakeModel,\n            updatedAttribute: {\n              name: 'attrTimestampUnique',\n              value: '1638140400',\n            },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator('1638140400')).toBe('1638140400');\n    });\n\n    test('it fails the validation of the unique constraint if the database contains a record with the same attribute value', async () => {\n      expect.assertions(1);\n      fakeFindOne.mockResolvedValueOnce({ attrTimestampUnique: '1638140400' });\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.timestamp(\n          {\n            attr: { type: 'timestamp', unique: true },\n            model: fakeModel,\n            updatedAttribute: {\n              name: 'attrTimestampUnique',\n              value: '1638140400',\n            },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      try {\n        await validator('1638140400');\n      } catch (err) {\n        expect(err).toBeInstanceOf(YupValidationError);\n      }\n    });\n\n    test('it validates the unique constraint if the attribute data has not changed even if there is a record in the database with the same attribute value', async () => {\n      fakeFindOne.mockResolvedValueOnce({ attrTimestampUnique: '1638140400' });\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.timestamp(\n          {\n            attr: { type: 'timestamp', unique: true },\n            model: fakeModel,\n            updatedAttribute: {\n              name: 'attrTimestampUnique',\n              value: '1638140400',\n            },\n            entity: { id: 1, attrTimestampUnique: '1638140400' },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator('1638140400')).toBe('1638140400');\n    });\n\n    test('it checks the database for records with the same value for the checked attribute', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.timestamp(\n          {\n            attr: { type: 'timestamp', unique: true },\n            model: fakeModel,\n            updatedAttribute: {\n              name: 'attrTimestampUnique',\n              value: '1638140400',\n            },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator('1638140400');\n\n      expect(fakeFindOne).toHaveBeenCalledWith({\n        select: ['id'],\n        where: { attrTimestampUnique: '1638140400' },\n      });\n    });\n\n    test('it checks the database for records with the same value but not the same id for the checked attribute if an entity is passed', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.timestamp(\n          {\n            attr: { type: 'timestamp', unique: true },\n            model: fakeModel,\n            updatedAttribute: {\n              name: 'attrTimestampUnique',\n              value: '1638140400',\n            },\n            entity: { id: 1, attrTimestampUnique: '1000000000' },\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator('1638140400');\n\n      expect(fakeFindOne).toHaveBeenCalledWith({\n        select: ['id'],\n        where: { $and: [{ attrTimestampUnique: '1638140400' }, { $not: { id: 1 } }] },\n      });\n    });\n  });\n});\n", "'use strict';\n\nconst strapiUtils = require('@strapi/utils');\nconst {\n  errors: { YupValidationError },\n} = require('@strapi/utils');\nconst validators = require('../validators');\n\ndescribe('UID validator', () => {\n  const fakeFindOne = jest.fn();\n\n  global.strapi = {\n    db: {\n      query: jest.fn(() => ({\n        findOne: fakeFindOne,\n      })),\n    },\n  };\n\n  afterEach(() => {\n    jest.clearAllMocks();\n    fakeFindOne.mockReset();\n  });\n\n  const fakeModel = {\n    kind: 'contentType',\n    modelName: 'test-model',\n    uid: 'test-uid',\n    options: {},\n    attributes: {\n      attrUidUnique: { type: 'uid' },\n    },\n  };\n\n  describe('unique', () => {\n    test('it validates the unique constraint if there is no other record in the database', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.uid(\n          {\n            attr: { type: 'uid', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrUidUnique', value: 'non-unique-uid' },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator('non-unique-uid')).toBe('non-unique-uid');\n    });\n\n    test('it does not validates the unique constraint if the attribute value is `null`', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators\n          .uid(\n            {\n              attr: { type: 'uid', unique: true },\n              model: fakeModel,\n              updatedAttribute: { name: 'attrUidUnique', value: null },\n              entity: null,\n            },\n            { isDraft: false }\n          )\n          .nullable()\n      );\n\n      await validator(null);\n\n      expect(fakeFindOne).not.toHaveBeenCalled();\n    });\n\n    test('it always validates the unique constraint even if the attribute is not set as unique', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.uid(\n          {\n            attr: { type: 'uid' },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrUidUnique', value: 'non-unique-uid' },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator('non-unique-uid')).toBe('non-unique-uid');\n      expect(fakeFindOne).toHaveBeenCalledWith({\n        select: ['id'],\n        where: { attrUidUnique: 'non-unique-uid' },\n      });\n    });\n\n    test('it fails the validation of the unique constraint if the database contains a record with the same attribute value', async () => {\n      expect.assertions(1);\n      fakeFindOne.mockResolvedValueOnce({ attrUidUnique: 'unique-uid' });\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.uid(\n          {\n            attr: { type: 'uid', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrUidUnique', value: 'unique-uid' },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      try {\n        await validator('unique-uid');\n      } catch (err) {\n        expect(err).toBeInstanceOf(YupValidationError);\n      }\n    });\n\n    test('it validates the unique constraint if the attribute data has not changed even if there is a record in the database with the same attribute value', async () => {\n      fakeFindOne.mockResolvedValueOnce({ attrUidUnique: 'unchanged-unique-uid' });\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.uid(\n          {\n            attr: { type: 'uid', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrUidUnique', value: 'unchanged-unique-uid' },\n            entity: { id: 1, attrUidUnique: 'unchanged-unique-uid' },\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator('unchanged-unique-uid')).toBe('unchanged-unique-uid');\n    });\n\n    test('it checks the database for records with the same value for the checked attribute', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.uid(\n          {\n            attr: { type: 'uid', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrUidUnique', value: 'unique-uid' },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator('unique-uid');\n\n      expect(fakeFindOne).toHaveBeenCalledWith({\n        select: ['id'],\n        where: { attrUidUnique: 'unique-uid' },\n      });\n    });\n\n    test('it checks the database for records with the same value but not the same id for the checked attribute if an entity is passed', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.uid(\n          {\n            attr: { type: 'uid', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrUidUnique', value: 'unique-uid' },\n            entity: { id: 1, attrUidUnique: 'other-uid' },\n          },\n          { isDraft: false }\n        )\n      );\n\n      await validator('unique-uid');\n\n      expect(fakeFindOne).toHaveBeenCalledWith({\n        select: ['id'],\n        where: { $and: [{ attrUidUnique: 'unique-uid' }, { $not: { id: 1 } }] },\n      });\n    });\n  });\n\n  describe('regExp', () => {\n    test('it fails to validate the uid if it does not fit the requried format', async () => {\n      expect.assertions(1);\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.uid(\n          {\n            attr: { type: 'uid', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrUidUnique', value: 'non-unique-uid' },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      try {\n        await validator('wrongly\\\\formated||UID');\n      } catch (err) {\n        expect(err).toBeInstanceOf(YupValidationError);\n      }\n    });\n\n    test('it validate the uid if it fit the required format', async () => {\n      fakeFindOne.mockResolvedValueOnce(null);\n\n      const validator = strapiUtils.validateYupSchema(\n        validators.uid(\n          {\n            attr: { type: 'uid', unique: true },\n            model: fakeModel,\n            updatedAttribute: { name: 'attrUidUnique', value: 'non-unique-uid' },\n            entity: null,\n          },\n          { isDraft: false }\n        )\n      );\n\n      expect(await validator('properly.formated-uid')).toBe('properly.formated-uid');\n    });\n  });\n});\n", "'use strict';\n\nconst {\n  isPrivateAttribute,\n  isTypedAttribute,\n  getPrivateAttributes,\n  getVisibleAttributes,\n  getNonWritableAttributes,\n  getScalarAttributes,\n  constants,\n} = require('../content-types');\n\nconst createModelWithPrivates = (privateAttributes = []) => ({\n  uid: 'myModel',\n  options: {\n    privateAttributes,\n  },\n  attributes: {\n    foo: {\n      type: 'string',\n      private: true,\n    },\n    bar: {\n      type: 'number',\n      private: false,\n    },\n    foobar: {\n      type: 'string',\n    },\n  },\n});\n\nconst createConfig = (privateAttributes = []) => ({\n  get: jest.fn(() => privateAttributes),\n});\n\nconst createModel = (opts) => ({\n  ...opts,\n});\n\ndescribe('Content types utils', () => {\n  beforeEach(() => {\n    jest.resetAllMocks();\n  });\n\n  test('Verify constants exist', () => {\n    expect(constants.CREATED_BY_ATTRIBUTE).toBeDefined();\n    expect(constants.UPDATED_BY_ATTRIBUTE).toBeDefined();\n    expect(constants.PUBLISHED_AT_ATTRIBUTE).toBeDefined();\n  });\n\n  describe('getNonWritableAttributes', () => {\n    test('Includes non writable fields', () => {\n      const model = createModel({\n        attributes: {\n          title: {\n            type: 'string',\n          },\n          non_writable_field: {\n            type: 'string',\n            writable: false,\n          },\n          createdAt: {\n            type: 'datetime',\n          },\n          updatedAt: {\n            type: 'datetime',\n          },\n        },\n      });\n\n      expect(getNonWritableAttributes(model)).toEqual([\n        'id',\n        'createdAt',\n        'updatedAt',\n        'non_writable_field',\n      ]);\n    });\n  });\n\n  describe('getVisibleAttributes', () => {\n    test('Excludes non visible fields', () => {\n      const model = createModel({\n        attributes: {\n          title: {\n            type: 'string',\n          },\n          invisible_field: {\n            type: 'datetime',\n            visible: false,\n          },\n        },\n      });\n\n      expect(getVisibleAttributes(model)).toEqual(['title']);\n    });\n\n    test('Excludes id', () => {\n      const model = createModel({\n        attributes: {\n          id: {\n            type: 'integer',\n          },\n          title: {\n            type: 'string',\n          },\n        },\n      });\n\n      expect(getVisibleAttributes(model)).toEqual(['title']);\n    });\n  });\n\n  describe('getPrivateAttributes', () => {\n    test('Attribute is private in the model attributes', () => {\n      const model = createModelWithPrivates();\n      global.strapi = { config: createConfig() };\n\n      const privateAttributes = getPrivateAttributes(model);\n\n      expect(privateAttributes).toContain('foo');\n      expect(privateAttributes).not.toContain('bar');\n      expect(privateAttributes).not.toContain('foobar');\n      expect(strapi.config.get).toHaveBeenCalledWith('api.responses.privateAttributes', []);\n    });\n\n    test('Attribute is set to private in the app config', () => {\n      const model = createModelWithPrivates();\n      global.strapi = { config: createConfig(['bar']) };\n\n      const privateAttributes = getPrivateAttributes(model);\n\n      expect(privateAttributes).toContain('foo');\n      expect(privateAttributes).toContain('bar');\n      expect(privateAttributes).not.toContain('foobar');\n      expect(strapi.config.get).toHaveBeenCalledWith('api.responses.privateAttributes', []);\n    });\n\n    test('Attribute is set to private in the model options', () => {\n      const model = createModelWithPrivates(['foobar']);\n      global.strapi = { config: createConfig() };\n\n      const privateAttributes = getPrivateAttributes(model);\n\n      expect(privateAttributes).toContain('foo');\n      expect(privateAttributes).not.toContain('bar');\n      expect(privateAttributes).toContain('foobar');\n      expect(strapi.config.get).toHaveBeenCalledWith('api.responses.privateAttributes', []);\n    });\n  });\n\n  describe('isPrivateAttribute', () => {\n    test('Attribute is private in the model attributes', () => {\n      const model = createModelWithPrivates();\n      global.strapi = { config: createConfig() };\n\n      expect(isPrivateAttribute(model, 'foo')).toBeTruthy();\n      expect(isPrivateAttribute(model, 'bar')).toBeFalsy();\n      expect(isPrivateAttribute(model, 'foobar')).toBeFalsy();\n      expect(strapi.config.get).toHaveBeenCalledWith('api.responses.privateAttributes', []);\n    });\n\n    test('Attribute is set to private in the app config', () => {\n      const model = createModelWithPrivates();\n      global.strapi = { config: createConfig(['bar']) };\n\n      expect(isPrivateAttribute(model, 'foo')).toBeTruthy();\n      expect(isPrivateAttribute(model, 'bar')).toBeTruthy();\n      expect(isPrivateAttribute(model, 'foobar')).toBeFalsy();\n      expect(strapi.config.get).toHaveBeenCalledWith('api.responses.privateAttributes', []);\n    });\n\n    test('Attribute is set to private in the model options', () => {\n      const model = createModelWithPrivates(['foobar']);\n      global.strapi = { config: createConfig() };\n\n      expect(isPrivateAttribute(model, 'foo')).toBeTruthy();\n      expect(isPrivateAttribute(model, 'bar')).toBeFalsy();\n      expect(isPrivateAttribute(model, 'foobar')).toBeTruthy();\n      expect(strapi.config.get).toHaveBeenCalledWith('api.responses.privateAttributes', []);\n    });\n  });\n\n  describe('isTypedAttribute', () => {\n    test('Returns false if attribute does not have a type', () => {\n      expect(isTypedAttribute({})).toBe(false);\n    });\n\n    test('Returns true if attribute type matches passed type', () => {\n      expect(isTypedAttribute({ type: 'test' }, 'test')).toBe(true);\n    });\n\n    test('Returns false if type do not match', () => {\n      expect(isTypedAttribute({ type: 'test' }, 'other-type')).toBe(false);\n    });\n  });\n\n  describe('getScalarAttributes', () => {\n    test('returns only scalar attributes', () => {\n      const schema = {\n        attributes: {\n          mediaField: { type: 'media' },\n          componentField: { type: 'component' },\n          relationField: { type: 'relation' },\n          dynamiczoneField: { type: 'dynamiczone' },\n          stringField: { type: 'string' },\n          textField: { type: 'text' },\n          richtextField: { type: 'richtext' },\n          enumerationField: { type: 'enumeration' },\n          emailField: { type: 'email' },\n          passwordField: { type: 'password' },\n          uidField: { type: 'uid' },\n          dateField: { type: 'date' },\n          timeField: { type: 'time' },\n          datetimeField: { type: 'datetime' },\n          timestampField: { type: 'timestamp' },\n          integerField: { type: 'integer' },\n          bigintegerField: { type: 'biginteger' },\n          floatField: { type: 'float' },\n          decimalField: { type: 'decimal' },\n          booleanField: { type: 'boolean' },\n          arrayField: { type: 'array' },\n          jsonField: { type: 'json' },\n        },\n      };\n\n      const scalarAttributes = getScalarAttributes(schema);\n      expect(scalarAttributes).toEqual([\n        'stringField',\n        'textField',\n        'richtextField',\n        'enumerationField',\n        'emailField',\n        'passwordField',\n        'uidField',\n        'dateField',\n        'timeField',\n        'datetimeField',\n        'timestampField',\n        'integerField',\n        'bigintegerField',\n        'floatField',\n        'decimalField',\n        'booleanField',\n        'arrayField',\n        'jsonField',\n      ]);\n    });\n  });\n});\n", "'use strict';\n\nconst _ = require('lodash');\nconst { getOr, has, union } = require('lodash/fp');\n\nconst SINGLE_TYPE = 'singleType';\nconst COLLECTION_TYPE = 'collectionType';\n\nconst ID_ATTRIBUTE = 'id';\nconst PUBLISHED_AT_ATTRIBUTE = 'publishedAt';\nconst CREATED_BY_ATTRIBUTE = 'createdBy';\nconst UPDATED_BY_ATTRIBUTE = 'updatedBy';\n\nconst CREATED_AT_ATTRIBUTE = 'createdAt';\nconst UPDATED_AT_ATTRIBUTE = 'updatedAt';\n\nconst DP_PUB_STATE_LIVE = 'live';\nconst DP_PUB_STATE_PREVIEW = 'preview';\nconst DP_PUB_STATES = [DP_PUB_STATE_LIVE, DP_PUB_STATE_PREVIEW];\n\nconst constants = {\n  ID_ATTRIBUTE,\n  PUBLISHED_AT_ATTRIBUTE,\n  CREATED_BY_ATTRIBUTE,\n  UPDATED_BY_ATTRIBUTE,\n  CREATED_AT_ATTRIBUTE,\n  UPDATED_AT_ATTRIBUTE,\n  DP_PUB_STATES,\n  DP_PUB_STATE_LIVE,\n  DP_PUB_STATE_PREVIEW,\n  SINGLE_TYPE,\n  COLLECTION_TYPE,\n};\n\nconst getTimestamps = (model) => {\n  const attributes = [];\n\n  if (has(CREATED_AT_ATTRIBUTE, model.attributes)) {\n    attributes.push(CREATED_AT_ATTRIBUTE);\n  }\n\n  if (has(UPDATED_AT_ATTRIBUTE, model.attributes)) {\n    attributes.push(UPDATED_AT_ATTRIBUTE);\n  }\n\n  return attributes;\n};\n\nconst getNonWritableAttributes = (model = {}) => {\n  const nonWritableAttributes = _.reduce(\n    model.attributes,\n    (acc, attr, attrName) => (attr.writable === false ? acc.concat(attrName) : acc),\n    []\n  );\n\n  return _.uniq([ID_ATTRIBUTE, ...getTimestamps(model), ...nonWritableAttributes]);\n};\n\nconst getWritableAttributes = (model = {}) => {\n  return _.difference(Object.keys(model.attributes), getNonWritableAttributes(model));\n};\n\nconst isWritableAttribute = (model, attributeName) => {\n  return getWritableAttributes(model).includes(attributeName);\n};\n\nconst getNonVisibleAttributes = (model) => {\n  const nonVisibleAttributes = _.reduce(\n    model.attributes,\n    (acc, attr, attrName) => (attr.visible === false ? acc.concat(attrName) : acc),\n    []\n  );\n\n  return _.uniq([ID_ATTRIBUTE, ...getTimestamps(model), ...nonVisibleAttributes]);\n};\n\nconst getVisibleAttributes = (model) => {\n  return _.difference(_.keys(model.attributes), getNonVisibleAttributes(model));\n};\n\nconst isVisibleAttribute = (model, attributeName) => {\n  return getVisibleAttributes(model).includes(attributeName);\n};\n\nconst getOptions = (model) => _.assign({ draftAndPublish: false }, _.get(model, 'options', {}));\nconst hasDraftAndPublish = (model) => _.get(model, 'options.draftAndPublish', false) === true;\n\nconst isDraft = (data, model) =>\n  hasDraftAndPublish(model) && _.get(data, PUBLISHED_AT_ATTRIBUTE) === null;\n\nconst isSingleType = ({ kind = COLLECTION_TYPE }) => kind === SINGLE_TYPE;\nconst isCollectionType = ({ kind = COLLECTION_TYPE }) => kind === COLLECTION_TYPE;\nconst isKind = (kind) => (model) => model.kind === kind;\n\nconst getStoredPrivateAttributes = (model) => union(\n  strapi?.config?.get('api.responses.privateAttributes', []) ?? [],\n  getOr([], 'options.privateAttributes', model)\n);\n\nconst getPrivateAttributes = (model = {}) => {\n  return _.union(\n    getStoredPrivateAttributes(model),\n    _.keys(_.pickBy(model.attributes, (attr) => !!attr.private))\n  );\n};\n\nconst isPrivateAttribute = (model, attributeName) => {\n  if (model?.attributes?.[attributeName]?.private === true) {\n    return true;\n  }\n  return getStoredPrivateAttributes(model).includes(attributeName);\n};\n\nconst isScalarAttribute = (attribute) => {\n  return !['media', 'component', 'relation', 'dynamiczone'].includes(attribute?.type);\n};\nconst isMediaAttribute = (attribute) => attribute?.type === 'media';\nconst isRelationalAttribute = (attribute) => attribute?.type === 'relation';\nconst isComponentAttribute = (attribute) => ['component', 'dynamiczone'].includes(attribute?.type);\n\nconst isDynamicZoneAttribute = (attribute) => attribute?.type === 'dynamiczone';\nconst isMorphToRelationalAttribute = (attribute) => {\n  return isRelationalAttribute(attribute) && attribute?.relation?.startsWith?.('morphTo');\n};\n\nconst getComponentAttributes = (schema) => {\n  return _.reduce(\n    schema.attributes,\n    (acc, attr, attrName) => {\n      if (isComponentAttribute(attr)) acc.push(attrName);\n      return acc;\n    },\n    []\n  );\n};\n\nconst getScalarAttributes = (schema) => {\n  return _.reduce(\n    schema.attributes,\n    (acc, attr, attrName) => {\n      if (isScalarAttribute(attr)) acc.push(attrName);\n      return acc;\n    },\n    []\n  );\n};\n\n/**\n * Checks if an attribute is of type `type`\n * @param {object} attribute\n * @param {string} type\n */\nconst isTypedAttribute = (attribute, type) => {\n  return _.has(attribute, 'type') && attribute.type === type;\n};\n\n/**\n *  Returns a route prefix for a contentType\n * @param {object} contentType\n * @returns {string}\n */\nconst getContentTypeRoutePrefix = (contentType) => {\n  return isSingleType(contentType)\n    ? _.kebabCase(contentType.info.singularName)\n    : _.kebabCase(contentType.info.pluralName);\n};\n\nmodule.exports = {\n  isScalarAttribute,\n  isMediaAttribute,\n  isRelationalAttribute,\n  isComponentAttribute,\n  isDynamicZoneAttribute,\n  isMorphToRelationalAttribute,\n  isTypedAttribute,\n  getPrivateAttributes,\n  isPrivateAttribute,\n  constants,\n  getNonWritableAttributes,\n  getComponentAttributes,\n  getScalarAttributes,\n  getWritableAttributes,\n  isWritableAttribute,\n  getNonVisibleAttributes,\n  getVisibleAttributes,\n  getTimestamps,\n  isVisibleAttribute,\n  hasDraftAndPublish,\n  getOptions,\n  isDraft,\n  isSingleType,\n  isCollectionType,\n  isKind,\n  getContentTypeRoutePrefix,\n};\n", "'use strict';\n\nconst { isPrivateAttribute } = require('../../content-types');\n\nmodule.exports = ({ schema, key, attribute }, { remove }) => {\n  if (!attribute) {\n    return;\n  }\n\n  const isPrivate = attribute.private === true || isPrivateAttribute(schema, key);\n\n  if (isPrivate) {\n    remove(key);\n  }\n};\n"], "filenames": ["api-tests/core/database/transactions.test.api.js", "packages/core/admin/server/services/__tests__/permissions-manager.test.js", "packages/core/strapi/lib/core/domain/content-type/index.js", "packages/core/strapi/lib/services/entity-service/__tests__/entity-service-events.test.js", "packages/core/strapi/lib/services/entity-service/__tests__/entity-service.test.js", "packages/core/strapi/lib/services/entity-validator/__tests__/biginteger-validators.test.js", "packages/core/strapi/lib/services/entity-validator/__tests__/date-validators.test.js", "packages/core/strapi/lib/services/entity-validator/__tests__/datetime-validators.test.js", "packages/core/strapi/lib/services/entity-validator/__tests__/float-validators.test.js", "packages/core/strapi/lib/services/entity-validator/__tests__/integer-validators.test.js", "packages/core/strapi/lib/services/entity-validator/__tests__/string-validators.test.js", "packages/core/strapi/lib/services/entity-validator/__tests__/time-validators.test.js", "packages/core/strapi/lib/services/entity-validator/__tests__/timestamp-validators.test.js", "packages/core/strapi/lib/services/entity-validator/__tests__/uid-validators.test.js", "packages/core/utils/lib/__tests__/content-types.test.js", "packages/core/utils/lib/content-types.js", "packages/core/utils/lib/sanitize/visitors/remove-private.js"], "buggy_code_start_loc": [287, 146, 5, 16, 65, 30, 30, 30, 30, 30, 30, 30, 30, 29, 156, 4, 10], "buggy_code_end_loc": [327, 147, 66, 17, 471, 31, 31, 31, 31, 31, 31, 31, 31, 30, 179, 105, 11], "fixing_code_start_loc": [287, 145, 5, 15, 65, 29, 29, 29, 29, 29, 29, 29, 29, 28, 155, 4, 10], "fixing_code_end_loc": [327, 145, 59, 15, 468, 29, 29, 29, 29, 29, 29, 29, 29, 28, 175, 112, 11], "type": "CWE-200", "message": "Strapi is an open-source headless content management system. Prior to version 4.10.8, anyone (Strapi developers, users, plugins) can make every attribute of a Content-Type public without knowing it. The vulnerability only affects the handling of content types by Strapi, not the actual content types themselves. Users can use plugins or modify their own content types without realizing that the `privateAttributes` getter is being removed, which can result in any attribute becoming public. This can lead to sensitive information being exposed or the entire system being taken control of by an attacker(having access to password hashes). Anyone can be impacted, depending on how people are using/extending content-types. If the users are mutating the content-type, they will not be affected. Version 4.10.8 contains a patch for this issue.", "other": {"cve": {"id": "CVE-2023-34093", "sourceIdentifier": "security-advisories@github.com", "published": "2023-07-25T15:15:13.377", "lastModified": "2023-08-03T13:45:58.610", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Strapi is an open-source headless content management system. Prior to version 4.10.8, anyone (Strapi developers, users, plugins) can make every attribute of a Content-Type public without knowing it. The vulnerability only affects the handling of content types by Strapi, not the actual content types themselves. Users can use plugins or modify their own content types without realizing that the `privateAttributes` getter is being removed, which can result in any attribute becoming public. This can lead to sensitive information being exposed or the entire system being taken control of by an attacker(having access to password hashes). Anyone can be impacted, depending on how people are using/extending content-types. If the users are mutating the content-type, they will not be affected. Version 4.10.8 contains a patch for this issue."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 4.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:H/UI:R/S:U/C:H/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.5, "impactScore": 4.2}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:strapi:strapi:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.10.8", "matchCriteriaId": "BA7C9D2E-E4B5-4BA7-9174-51A805D34E39"}]}]}], "references": [{"url": "https://github.com/strapi/strapi/commit/2fa8f30371bfd1db44c15e5747860ee5789096de", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/strapi/strapi/releases/tag/v4.10.8", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/strapi/strapi/security/advisories/GHSA-chmr-rg2f-9jmf", "source": "security-advisories@github.com", "tags": ["Exploit"]}]}, "github_commit_url": "https://github.com/strapi/strapi/commit/2fa8f30371bfd1db44c15e5747860ee5789096de"}}