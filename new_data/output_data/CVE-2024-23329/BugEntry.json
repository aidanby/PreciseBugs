{"buggy_code": ["import os\nfrom distutils.util import strtobool\n\nfrom flask_expects_json import expects_json\nfrom changedetectionio import queuedWatchMetaData\nfrom flask_restful import abort, Resource\nfrom flask import request, make_response\nimport validators\nfrom . import auth\nimport copy\n\n# See docs/README.md for rebuilding the docs/apidoc information\n\nfrom . import api_schema\n\n# Build a JSON Schema atleast partially based on our Watch model\nfrom changedetectionio.model.Watch import base_config as watch_base_config\nschema = api_schema.build_watch_json_schema(watch_base_config)\n\nschema_create_watch = copy.deepcopy(schema)\nschema_create_watch['required'] = ['url']\n\nschema_update_watch = copy.deepcopy(schema)\nschema_update_watch['additionalProperties'] = False\n\nclass Watch(Resource):\n    def __init__(self, **kwargs):\n        # datastore is a black box dependency\n        self.datastore = kwargs['datastore']\n        self.update_q = kwargs['update_q']\n\n    # Get information about a single watch, excluding the history list (can be large)\n    # curl http://localhost:5000/api/v1/watch/<string:uuid>\n    # @todo - version2 - ?muted and ?paused should be able to be called together, return the watch struct not \"OK\"\n    # ?recheck=true\n    @auth.check_token\n    def get(self, uuid):\n        \"\"\"\n        @api {get} /api/v1/watch/:uuid Single watch - get data, recheck, pause, mute.\n        @apiDescription Retrieve watch information and set muted/paused status\n        @apiExample {curl} Example usage:\n            curl http://localhost:5000/api/v1/watch/cc0cfffa-f449-477b-83ea-0caafd1dc091  -H\"x-api-key:813031b16330fe25e3780cf0325daa45\"\n            curl \"http://localhost:5000/api/v1/watch/cc0cfffa-f449-477b-83ea-0caafd1dc091?muted=unmuted\"  -H\"x-api-key:813031b16330fe25e3780cf0325daa45\"\n            curl \"http://localhost:5000/api/v1/watch/cc0cfffa-f449-477b-83ea-0caafd1dc091?paused=unpaused\"  -H\"x-api-key:813031b16330fe25e3780cf0325daa45\"\n        @apiName Watch\n        @apiGroup Watch\n        @apiParam {uuid} uuid Watch unique ID.\n        @apiQuery {Boolean} [recheck] Recheck this watch `recheck=1`\n        @apiQuery {String} [paused] =`paused` or =`unpaused` , Sets the PAUSED state\n        @apiQuery {String} [muted] =`muted` or =`unmuted` , Sets the MUTE NOTIFICATIONS state\n        @apiSuccess (200) {String} OK When paused/muted/recheck operation OR full JSON object of the watch\n        @apiSuccess (200) {JSON} WatchJSON JSON Full JSON object of the watch\n        \"\"\"\n        from copy import deepcopy\n        watch = deepcopy(self.datastore.data['watching'].get(uuid))\n        if not watch:\n            abort(404, message='No watch exists with the UUID of {}'.format(uuid))\n\n        if request.args.get('recheck'):\n            self.update_q.put(queuedWatchMetaData.PrioritizedItem(priority=1, item={'uuid': uuid, 'skip_when_checksum_same': True}))\n            return \"OK\", 200\n        if request.args.get('paused', '') == 'paused':\n            self.datastore.data['watching'].get(uuid).pause()\n            return \"OK\", 200\n        elif request.args.get('paused', '') == 'unpaused':\n            self.datastore.data['watching'].get(uuid).unpause()\n            return \"OK\", 200\n        if request.args.get('muted', '') == 'muted':\n            self.datastore.data['watching'].get(uuid).mute()\n            return \"OK\", 200\n        elif request.args.get('muted', '') == 'unmuted':\n            self.datastore.data['watching'].get(uuid).unmute()\n            return \"OK\", 200\n\n        # Return without history, get that via another API call\n        # Properties are not returned as a JSON, so add the required props manually\n        watch['history_n'] = watch.history_n\n        watch['last_changed'] = watch.last_changed\n        watch['viewed'] = watch.viewed\n        return watch\n\n    @auth.check_token\n    def delete(self, uuid):\n        \"\"\"\n        @api {delete} /api/v1/watch/:uuid Delete a watch and related history\n        @apiExample {curl} Example usage:\n            curl http://localhost:5000/api/v1/watch/cc0cfffa-f449-477b-83ea-0caafd1dc091 -X DELETE -H\"x-api-key:813031b16330fe25e3780cf0325daa45\"\n        @apiParam {uuid} uuid Watch unique ID.\n        @apiName Delete\n        @apiGroup Watch\n        @apiSuccess (200) {String} OK Was deleted\n        \"\"\"\n        if not self.datastore.data['watching'].get(uuid):\n            abort(400, message='No watch exists with the UUID of {}'.format(uuid))\n\n        self.datastore.delete(uuid)\n        return 'OK', 204\n\n    @auth.check_token\n    @expects_json(schema_update_watch)\n    def put(self, uuid):\n        \"\"\"\n        @api {put} /api/v1/watch/:uuid Update watch information\n        @apiExample {curl} Example usage:\n            Update (PUT)\n            curl http://localhost:5000/api/v1/watch/cc0cfffa-f449-477b-83ea-0caafd1dc091 -X PUT -H\"x-api-key:813031b16330fe25e3780cf0325daa45\" -H \"Content-Type: application/json\" -d '{\"url\": \"https://my-nice.com\" , \"tag\": \"new list\"}'\n\n        @apiDescription Updates an existing watch using JSON, accepts the same structure as returned in <a href=\"#api-Watch-Watch\">get single watch information</a>\n        @apiParam {uuid} uuid Watch unique ID.\n        @apiName Update a watch\n        @apiGroup Watch\n        @apiSuccess (200) {String} OK Was updated\n        @apiSuccess (500) {String} ERR Some other error\n        \"\"\"\n        watch = self.datastore.data['watching'].get(uuid)\n        if not watch:\n            abort(404, message='No watch exists with the UUID of {}'.format(uuid))\n\n        if request.json.get('proxy'):\n            plist = self.datastore.proxy_list\n            if not request.json.get('proxy') in plist:\n                return \"Invalid proxy choice, currently supported proxies are '{}'\".format(', '.join(plist)), 400\n\n        watch.update(request.json)\n\n        return \"OK\", 200\n\n\nclass WatchHistory(Resource):\n    def __init__(self, **kwargs):\n        # datastore is a black box dependency\n        self.datastore = kwargs['datastore']\n\n    # Get a list of available history for a watch by UUID\n    # curl http://localhost:5000/api/v1/watch/<string:uuid>/history\n    def get(self, uuid):\n        \"\"\"\n        @api {get} /api/v1/watch/<string:uuid>/history Get a list of all historical snapshots available for a watch\n        @apiDescription Requires `uuid`, returns list\n        @apiExample {curl} Example usage:\n            curl http://localhost:5000/api/v1/watch/cc0cfffa-f449-477b-83ea-0caafd1dc091/history -H\"x-api-key:813031b16330fe25e3780cf0325daa45\" -H \"Content-Type: application/json\"\n            {\n                \"1676649279\": \"/tmp/data/6a4b7d5c-fee4-4616-9f43-4ac97046b595/cb7e9be8258368262246910e6a2a4c30.txt\",\n                \"1677092785\": \"/tmp/data/6a4b7d5c-fee4-4616-9f43-4ac97046b595/e20db368d6fc633e34f559ff67bb4044.txt\",\n                \"1677103794\": \"/tmp/data/6a4b7d5c-fee4-4616-9f43-4ac97046b595/02efdd37dacdae96554a8cc85dc9c945.txt\"\n            }\n        @apiName Get list of available stored snapshots for watch\n        @apiGroup Watch History\n        @apiSuccess (200) {String} OK\n        @apiSuccess (404) {String} ERR Not found\n        \"\"\"\n        watch = self.datastore.data['watching'].get(uuid)\n        if not watch:\n            abort(404, message='No watch exists with the UUID of {}'.format(uuid))\n        return watch.history, 200\n\n\nclass WatchSingleHistory(Resource):\n    def __init__(self, **kwargs):\n        # datastore is a black box dependency\n        self.datastore = kwargs['datastore']\n\n    @auth.check_token\n    def get(self, uuid, timestamp):\n        \"\"\"\n        @api {get} /api/v1/watch/<string:uuid>/history/<int:timestamp> Get single snapshot from watch\n        @apiDescription Requires watch `uuid` and `timestamp`. `timestamp` of \"`latest`\" for latest available snapshot, or <a href=\"#api-Watch_History-Get_list_of_available_stored_snapshots_for_watch\">use the list returned here</a>\n        @apiExample {curl} Example usage:\n            curl http://localhost:5000/api/v1/watch/cc0cfffa-f449-477b-83ea-0caafd1dc091/history/1677092977 -H\"x-api-key:813031b16330fe25e3780cf0325daa45\" -H \"Content-Type: application/json\"\n        @apiName Get single snapshot content\n        @apiGroup Watch History\n        @apiSuccess (200) {String} OK\n        @apiSuccess (404) {String} ERR Not found\n        \"\"\"\n        watch = self.datastore.data['watching'].get(uuid)\n        if not watch:\n            abort(404, message='No watch exists with the UUID of {}'.format(uuid))\n\n        if not len(watch.history):\n            abort(404, message='Watch found but no history exists for the UUID {}'.format(uuid))\n\n        if timestamp == 'latest':\n            timestamp = list(watch.history.keys())[-1]\n\n        content = watch.get_history_snapshot(timestamp)\n\n        response = make_response(content, 200)\n        response.mimetype = \"text/plain\"\n        return response\n\n\nclass CreateWatch(Resource):\n    def __init__(self, **kwargs):\n        # datastore is a black box dependency\n        self.datastore = kwargs['datastore']\n        self.update_q = kwargs['update_q']\n\n    @auth.check_token\n    @expects_json(schema_create_watch)\n    def post(self):\n        \"\"\"\n        @api {post} /api/v1/watch Create a single watch\n        @apiDescription Requires atleast `url` set, can accept the same structure as <a href=\"#api-Watch-Watch\">get single watch information</a> to create.\n        @apiExample {curl} Example usage:\n            curl http://localhost:5000/api/v1/watch -H\"x-api-key:813031b16330fe25e3780cf0325daa45\" -H \"Content-Type: application/json\" -d '{\"url\": \"https://my-nice.com\" , \"tag\": \"nice list\"}'\n        @apiName Create\n        @apiGroup Watch\n        @apiSuccess (200) {String} OK Was created\n        @apiSuccess (500) {String} ERR Some other error\n        \"\"\"\n\n        json_data = request.get_json()\n        url = json_data['url'].strip()\n\n        # If hosts that only contain alphanumerics are allowed (\"localhost\" for example)\n        allow_simplehost = not strtobool(os.getenv('BLOCK_SIMPLEHOSTS', 'False'))\n        if not validators.url(url, simple_host=allow_simplehost):\n            return \"Invalid or unsupported URL\", 400\n\n        if json_data.get('proxy'):\n            plist = self.datastore.proxy_list\n            if not json_data.get('proxy') in plist:\n                return \"Invalid proxy choice, currently supported proxies are '{}'\".format(', '.join(plist)), 400\n\n        extras = copy.deepcopy(json_data)\n\n        # Because we renamed 'tag' to 'tags' but don't want to change the API (can do this in v2 of the API)\n        tags = None\n        if extras.get('tag'):\n            tags = extras.get('tag')\n            del extras['tag']\n\n        del extras['url']\n\n        new_uuid = self.datastore.add_watch(url=url, extras=extras, tag=tags)\n        if new_uuid:\n            self.update_q.put(queuedWatchMetaData.PrioritizedItem(priority=1, item={'uuid': new_uuid, 'skip_when_checksum_same': True}))\n            return {'uuid': new_uuid}, 201\n        else:\n            return \"Invalid or unsupported URL\", 400\n\n    @auth.check_token\n    def get(self):\n        \"\"\"\n        @api {get} /api/v1/watch List watches\n        @apiDescription Return concise list of available watches and some very basic info\n        @apiExample {curl} Example usage:\n            curl http://localhost:5000/api/v1/watch -H\"x-api-key:813031b16330fe25e3780cf0325daa45\"\n            {\n                \"6a4b7d5c-fee4-4616-9f43-4ac97046b595\": {\n                    \"last_changed\": 1677103794,\n                    \"last_checked\": 1677103794,\n                    \"last_error\": false,\n                    \"title\": \"\",\n                    \"url\": \"http://www.quotationspage.com/random.php\"\n                },\n                \"e6f5fd5c-dbfe-468b-b8f3-f9d6ff5ad69b\": {\n                    \"last_changed\": 0,\n                    \"last_checked\": 1676662819,\n                    \"last_error\": false,\n                    \"title\": \"QuickLook\",\n                    \"url\": \"https://github.com/QL-Win/QuickLook/tags\"\n                }\n            }\n\n        @apiParam {String} [recheck_all]       Optional Set to =1 to force recheck of all watches\n        @apiParam {String} [tag]               Optional name of tag to limit results\n        @apiName ListWatches\n        @apiGroup Watch Management\n        @apiSuccess (200) {String} OK JSON dict\n        \"\"\"\n        list = {}\n\n        tag_limit = request.args.get('tag', '').lower()\n\n\n        for uuid, watch in self.datastore.data['watching'].items():\n            # Watch tags by name (replace the other calls?)\n            tags = self.datastore.get_all_tags_for_watch(uuid=uuid)\n            if tag_limit and not any(v.get('title').lower() == tag_limit for k, v in tags.items()):\n                continue\n\n            list[uuid] = {\n                'last_changed': watch.last_changed,\n                'last_checked': watch['last_checked'],\n                'last_error': watch['last_error'],\n                'title': watch['title'],\n                'url': watch['url'],\n                'viewed': watch.viewed\n            }\n\n        if request.args.get('recheck_all'):\n            for uuid in self.datastore.data['watching'].keys():\n                self.update_q.put(queuedWatchMetaData.PrioritizedItem(priority=1, item={'uuid': uuid, 'skip_when_checksum_same': True}))\n            return {'status': \"OK\"}, 200\n\n        return list, 200\n\nclass Import(Resource):\n    def __init__(self, **kwargs):\n        # datastore is a black box dependency\n        self.datastore = kwargs['datastore']\n\n    @auth.check_token\n    def post(self):\n        \"\"\"\n        @api {post} /api/v1/import Import a list of watched URLs\n        @apiDescription Accepts a line-feed separated list of URLs to import, additionally with ?tag_uuids=(tag  id), ?tag=(name), ?proxy={key}, ?dedupe=true (default true) one URL per line.\n        @apiExample {curl} Example usage:\n            curl http://localhost:5000/api/v1/import --data-binary @list-of-sites.txt -H\"x-api-key:8a111a21bc2f8f1dd9b9353bbd46049a\"\n        @apiName Import\n        @apiGroup Watch\n        @apiSuccess (200) {List} OK List of watch UUIDs added\n        @apiSuccess (500) {String} ERR Some other error\n        \"\"\"\n\n        extras = {}\n\n        if request.args.get('proxy'):\n            plist = self.datastore.proxy_list\n            if not request.args.get('proxy') in plist:\n                return \"Invalid proxy choice, currently supported proxies are '{}'\".format(', '.join(plist)), 400\n            else:\n                extras['proxy'] = request.args.get('proxy')\n\n        dedupe = strtobool(request.args.get('dedupe', 'true'))\n\n        tags = request.args.get('tag')\n        tag_uuids = request.args.get('tag_uuids')\n\n        if tag_uuids:\n            tag_uuids = tag_uuids.split(',')\n\n        urls = request.get_data().decode('utf8').splitlines()\n        added = []\n        allow_simplehost = not strtobool(os.getenv('BLOCK_SIMPLEHOSTS', 'False'))\n        for url in urls:\n            url = url.strip()\n            if not len(url):\n                continue\n\n            # If hosts that only contain alphanumerics are allowed (\"localhost\" for example)\n            if not validators.url(url, simple_host=allow_simplehost):\n                return f\"Invalid or unsupported URL - {url}\", 400\n\n            if dedupe and self.datastore.url_exists(url):\n                continue\n\n            new_uuid = self.datastore.add_watch(url=url, extras=extras, tag=tags, tag_uuids=tag_uuids)\n            added.append(new_uuid)\n\n        return added\n\nclass SystemInfo(Resource):\n    def __init__(self, **kwargs):\n        # datastore is a black box dependency\n        self.datastore = kwargs['datastore']\n        self.update_q = kwargs['update_q']\n\n    @auth.check_token\n    def get(self):\n        \"\"\"\n        @api {get} /api/v1/systeminfo Return system info\n        @apiDescription Return some info about the current system state\n        @apiExample {curl} Example usage:\n            curl http://localhost:5000/api/v1/systeminfo -H\"x-api-key:813031b16330fe25e3780cf0325daa45\"\n            HTTP/1.0 200\n            {\n                'queue_size': 10 ,\n                'overdue_watches': [\"watch-uuid-list\"],\n                'uptime': 38344.55,\n                'watch_count': 800,\n                'version': \"0.40.1\"\n            }\n        @apiName Get Info\n        @apiGroup System Information\n        \"\"\"\n        import time\n        overdue_watches = []\n\n        # Check all watches and report which have not been checked but should have been\n\n        for uuid, watch in self.datastore.data.get('watching', {}).items():\n            # see if now - last_checked is greater than the time that should have been\n            # this is not super accurate (maybe they just edited it) but better than nothing\n            t = watch.threshold_seconds()\n            if not t:\n                # Use the system wide default\n                t = self.datastore.threshold_seconds\n\n            time_since_check = time.time() - watch.get('last_checked')\n\n            # Allow 5 minutes of grace time before we decide it's overdue\n            if time_since_check - (5 * 60) > t:\n                overdue_watches.append(uuid)\n        from changedetectionio import __version__ as main_version\n        return {\n                   'queue_size': self.update_q.qsize(),\n                   'overdue_watches': overdue_watches,\n                   'uptime': round(time.time() - self.datastore.start_time, 2),\n                   'watch_count': len(self.datastore.data.get('watching', {})),\n                   'version': main_version\n               }, 200\n"], "fixing_code": ["import os\nfrom distutils.util import strtobool\n\nfrom flask_expects_json import expects_json\nfrom changedetectionio import queuedWatchMetaData\nfrom flask_restful import abort, Resource\nfrom flask import request, make_response\nimport validators\nfrom . import auth\nimport copy\n\n# See docs/README.md for rebuilding the docs/apidoc information\n\nfrom . import api_schema\n\n# Build a JSON Schema atleast partially based on our Watch model\nfrom changedetectionio.model.Watch import base_config as watch_base_config\nschema = api_schema.build_watch_json_schema(watch_base_config)\n\nschema_create_watch = copy.deepcopy(schema)\nschema_create_watch['required'] = ['url']\n\nschema_update_watch = copy.deepcopy(schema)\nschema_update_watch['additionalProperties'] = False\n\nclass Watch(Resource):\n    def __init__(self, **kwargs):\n        # datastore is a black box dependency\n        self.datastore = kwargs['datastore']\n        self.update_q = kwargs['update_q']\n\n    # Get information about a single watch, excluding the history list (can be large)\n    # curl http://localhost:5000/api/v1/watch/<string:uuid>\n    # @todo - version2 - ?muted and ?paused should be able to be called together, return the watch struct not \"OK\"\n    # ?recheck=true\n    @auth.check_token\n    def get(self, uuid):\n        \"\"\"\n        @api {get} /api/v1/watch/:uuid Single watch - get data, recheck, pause, mute.\n        @apiDescription Retrieve watch information and set muted/paused status\n        @apiExample {curl} Example usage:\n            curl http://localhost:5000/api/v1/watch/cc0cfffa-f449-477b-83ea-0caafd1dc091  -H\"x-api-key:813031b16330fe25e3780cf0325daa45\"\n            curl \"http://localhost:5000/api/v1/watch/cc0cfffa-f449-477b-83ea-0caafd1dc091?muted=unmuted\"  -H\"x-api-key:813031b16330fe25e3780cf0325daa45\"\n            curl \"http://localhost:5000/api/v1/watch/cc0cfffa-f449-477b-83ea-0caafd1dc091?paused=unpaused\"  -H\"x-api-key:813031b16330fe25e3780cf0325daa45\"\n        @apiName Watch\n        @apiGroup Watch\n        @apiParam {uuid} uuid Watch unique ID.\n        @apiQuery {Boolean} [recheck] Recheck this watch `recheck=1`\n        @apiQuery {String} [paused] =`paused` or =`unpaused` , Sets the PAUSED state\n        @apiQuery {String} [muted] =`muted` or =`unmuted` , Sets the MUTE NOTIFICATIONS state\n        @apiSuccess (200) {String} OK When paused/muted/recheck operation OR full JSON object of the watch\n        @apiSuccess (200) {JSON} WatchJSON JSON Full JSON object of the watch\n        \"\"\"\n        from copy import deepcopy\n        watch = deepcopy(self.datastore.data['watching'].get(uuid))\n        if not watch:\n            abort(404, message='No watch exists with the UUID of {}'.format(uuid))\n\n        if request.args.get('recheck'):\n            self.update_q.put(queuedWatchMetaData.PrioritizedItem(priority=1, item={'uuid': uuid, 'skip_when_checksum_same': True}))\n            return \"OK\", 200\n        if request.args.get('paused', '') == 'paused':\n            self.datastore.data['watching'].get(uuid).pause()\n            return \"OK\", 200\n        elif request.args.get('paused', '') == 'unpaused':\n            self.datastore.data['watching'].get(uuid).unpause()\n            return \"OK\", 200\n        if request.args.get('muted', '') == 'muted':\n            self.datastore.data['watching'].get(uuid).mute()\n            return \"OK\", 200\n        elif request.args.get('muted', '') == 'unmuted':\n            self.datastore.data['watching'].get(uuid).unmute()\n            return \"OK\", 200\n\n        # Return without history, get that via another API call\n        # Properties are not returned as a JSON, so add the required props manually\n        watch['history_n'] = watch.history_n\n        watch['last_changed'] = watch.last_changed\n        watch['viewed'] = watch.viewed\n        return watch\n\n    @auth.check_token\n    def delete(self, uuid):\n        \"\"\"\n        @api {delete} /api/v1/watch/:uuid Delete a watch and related history\n        @apiExample {curl} Example usage:\n            curl http://localhost:5000/api/v1/watch/cc0cfffa-f449-477b-83ea-0caafd1dc091 -X DELETE -H\"x-api-key:813031b16330fe25e3780cf0325daa45\"\n        @apiParam {uuid} uuid Watch unique ID.\n        @apiName Delete\n        @apiGroup Watch\n        @apiSuccess (200) {String} OK Was deleted\n        \"\"\"\n        if not self.datastore.data['watching'].get(uuid):\n            abort(400, message='No watch exists with the UUID of {}'.format(uuid))\n\n        self.datastore.delete(uuid)\n        return 'OK', 204\n\n    @auth.check_token\n    @expects_json(schema_update_watch)\n    def put(self, uuid):\n        \"\"\"\n        @api {put} /api/v1/watch/:uuid Update watch information\n        @apiExample {curl} Example usage:\n            Update (PUT)\n            curl http://localhost:5000/api/v1/watch/cc0cfffa-f449-477b-83ea-0caafd1dc091 -X PUT -H\"x-api-key:813031b16330fe25e3780cf0325daa45\" -H \"Content-Type: application/json\" -d '{\"url\": \"https://my-nice.com\" , \"tag\": \"new list\"}'\n\n        @apiDescription Updates an existing watch using JSON, accepts the same structure as returned in <a href=\"#api-Watch-Watch\">get single watch information</a>\n        @apiParam {uuid} uuid Watch unique ID.\n        @apiName Update a watch\n        @apiGroup Watch\n        @apiSuccess (200) {String} OK Was updated\n        @apiSuccess (500) {String} ERR Some other error\n        \"\"\"\n        watch = self.datastore.data['watching'].get(uuid)\n        if not watch:\n            abort(404, message='No watch exists with the UUID of {}'.format(uuid))\n\n        if request.json.get('proxy'):\n            plist = self.datastore.proxy_list\n            if not request.json.get('proxy') in plist:\n                return \"Invalid proxy choice, currently supported proxies are '{}'\".format(', '.join(plist)), 400\n\n        watch.update(request.json)\n\n        return \"OK\", 200\n\n\nclass WatchHistory(Resource):\n    def __init__(self, **kwargs):\n        # datastore is a black box dependency\n        self.datastore = kwargs['datastore']\n\n    # Get a list of available history for a watch by UUID\n    # curl http://localhost:5000/api/v1/watch/<string:uuid>/history\n    @auth.check_token\n    def get(self, uuid):\n        \"\"\"\n        @api {get} /api/v1/watch/<string:uuid>/history Get a list of all historical snapshots available for a watch\n        @apiDescription Requires `uuid`, returns list\n        @apiExample {curl} Example usage:\n            curl http://localhost:5000/api/v1/watch/cc0cfffa-f449-477b-83ea-0caafd1dc091/history -H\"x-api-key:813031b16330fe25e3780cf0325daa45\" -H \"Content-Type: application/json\"\n            {\n                \"1676649279\": \"/tmp/data/6a4b7d5c-fee4-4616-9f43-4ac97046b595/cb7e9be8258368262246910e6a2a4c30.txt\",\n                \"1677092785\": \"/tmp/data/6a4b7d5c-fee4-4616-9f43-4ac97046b595/e20db368d6fc633e34f559ff67bb4044.txt\",\n                \"1677103794\": \"/tmp/data/6a4b7d5c-fee4-4616-9f43-4ac97046b595/02efdd37dacdae96554a8cc85dc9c945.txt\"\n            }\n        @apiName Get list of available stored snapshots for watch\n        @apiGroup Watch History\n        @apiSuccess (200) {String} OK\n        @apiSuccess (404) {String} ERR Not found\n        \"\"\"\n        watch = self.datastore.data['watching'].get(uuid)\n        if not watch:\n            abort(404, message='No watch exists with the UUID of {}'.format(uuid))\n        return watch.history, 200\n\n\nclass WatchSingleHistory(Resource):\n    def __init__(self, **kwargs):\n        # datastore is a black box dependency\n        self.datastore = kwargs['datastore']\n\n    @auth.check_token\n    def get(self, uuid, timestamp):\n        \"\"\"\n        @api {get} /api/v1/watch/<string:uuid>/history/<int:timestamp> Get single snapshot from watch\n        @apiDescription Requires watch `uuid` and `timestamp`. `timestamp` of \"`latest`\" for latest available snapshot, or <a href=\"#api-Watch_History-Get_list_of_available_stored_snapshots_for_watch\">use the list returned here</a>\n        @apiExample {curl} Example usage:\n            curl http://localhost:5000/api/v1/watch/cc0cfffa-f449-477b-83ea-0caafd1dc091/history/1677092977 -H\"x-api-key:813031b16330fe25e3780cf0325daa45\" -H \"Content-Type: application/json\"\n        @apiName Get single snapshot content\n        @apiGroup Watch History\n        @apiSuccess (200) {String} OK\n        @apiSuccess (404) {String} ERR Not found\n        \"\"\"\n        watch = self.datastore.data['watching'].get(uuid)\n        if not watch:\n            abort(404, message='No watch exists with the UUID of {}'.format(uuid))\n\n        if not len(watch.history):\n            abort(404, message='Watch found but no history exists for the UUID {}'.format(uuid))\n\n        if timestamp == 'latest':\n            timestamp = list(watch.history.keys())[-1]\n\n        content = watch.get_history_snapshot(timestamp)\n\n        response = make_response(content, 200)\n        response.mimetype = \"text/plain\"\n        return response\n\n\nclass CreateWatch(Resource):\n    def __init__(self, **kwargs):\n        # datastore is a black box dependency\n        self.datastore = kwargs['datastore']\n        self.update_q = kwargs['update_q']\n\n    @auth.check_token\n    @expects_json(schema_create_watch)\n    def post(self):\n        \"\"\"\n        @api {post} /api/v1/watch Create a single watch\n        @apiDescription Requires atleast `url` set, can accept the same structure as <a href=\"#api-Watch-Watch\">get single watch information</a> to create.\n        @apiExample {curl} Example usage:\n            curl http://localhost:5000/api/v1/watch -H\"x-api-key:813031b16330fe25e3780cf0325daa45\" -H \"Content-Type: application/json\" -d '{\"url\": \"https://my-nice.com\" , \"tag\": \"nice list\"}'\n        @apiName Create\n        @apiGroup Watch\n        @apiSuccess (200) {String} OK Was created\n        @apiSuccess (500) {String} ERR Some other error\n        \"\"\"\n\n        json_data = request.get_json()\n        url = json_data['url'].strip()\n\n        # If hosts that only contain alphanumerics are allowed (\"localhost\" for example)\n        allow_simplehost = not strtobool(os.getenv('BLOCK_SIMPLEHOSTS', 'False'))\n        if not validators.url(url, simple_host=allow_simplehost):\n            return \"Invalid or unsupported URL\", 400\n\n        if json_data.get('proxy'):\n            plist = self.datastore.proxy_list\n            if not json_data.get('proxy') in plist:\n                return \"Invalid proxy choice, currently supported proxies are '{}'\".format(', '.join(plist)), 400\n\n        extras = copy.deepcopy(json_data)\n\n        # Because we renamed 'tag' to 'tags' but don't want to change the API (can do this in v2 of the API)\n        tags = None\n        if extras.get('tag'):\n            tags = extras.get('tag')\n            del extras['tag']\n\n        del extras['url']\n\n        new_uuid = self.datastore.add_watch(url=url, extras=extras, tag=tags)\n        if new_uuid:\n            self.update_q.put(queuedWatchMetaData.PrioritizedItem(priority=1, item={'uuid': new_uuid, 'skip_when_checksum_same': True}))\n            return {'uuid': new_uuid}, 201\n        else:\n            return \"Invalid or unsupported URL\", 400\n\n    @auth.check_token\n    def get(self):\n        \"\"\"\n        @api {get} /api/v1/watch List watches\n        @apiDescription Return concise list of available watches and some very basic info\n        @apiExample {curl} Example usage:\n            curl http://localhost:5000/api/v1/watch -H\"x-api-key:813031b16330fe25e3780cf0325daa45\"\n            {\n                \"6a4b7d5c-fee4-4616-9f43-4ac97046b595\": {\n                    \"last_changed\": 1677103794,\n                    \"last_checked\": 1677103794,\n                    \"last_error\": false,\n                    \"title\": \"\",\n                    \"url\": \"http://www.quotationspage.com/random.php\"\n                },\n                \"e6f5fd5c-dbfe-468b-b8f3-f9d6ff5ad69b\": {\n                    \"last_changed\": 0,\n                    \"last_checked\": 1676662819,\n                    \"last_error\": false,\n                    \"title\": \"QuickLook\",\n                    \"url\": \"https://github.com/QL-Win/QuickLook/tags\"\n                }\n            }\n\n        @apiParam {String} [recheck_all]       Optional Set to =1 to force recheck of all watches\n        @apiParam {String} [tag]               Optional name of tag to limit results\n        @apiName ListWatches\n        @apiGroup Watch Management\n        @apiSuccess (200) {String} OK JSON dict\n        \"\"\"\n        list = {}\n\n        tag_limit = request.args.get('tag', '').lower()\n\n\n        for uuid, watch in self.datastore.data['watching'].items():\n            # Watch tags by name (replace the other calls?)\n            tags = self.datastore.get_all_tags_for_watch(uuid=uuid)\n            if tag_limit and not any(v.get('title').lower() == tag_limit for k, v in tags.items()):\n                continue\n\n            list[uuid] = {\n                'last_changed': watch.last_changed,\n                'last_checked': watch['last_checked'],\n                'last_error': watch['last_error'],\n                'title': watch['title'],\n                'url': watch['url'],\n                'viewed': watch.viewed\n            }\n\n        if request.args.get('recheck_all'):\n            for uuid in self.datastore.data['watching'].keys():\n                self.update_q.put(queuedWatchMetaData.PrioritizedItem(priority=1, item={'uuid': uuid, 'skip_when_checksum_same': True}))\n            return {'status': \"OK\"}, 200\n\n        return list, 200\n\nclass Import(Resource):\n    def __init__(self, **kwargs):\n        # datastore is a black box dependency\n        self.datastore = kwargs['datastore']\n\n    @auth.check_token\n    def post(self):\n        \"\"\"\n        @api {post} /api/v1/import Import a list of watched URLs\n        @apiDescription Accepts a line-feed separated list of URLs to import, additionally with ?tag_uuids=(tag  id), ?tag=(name), ?proxy={key}, ?dedupe=true (default true) one URL per line.\n        @apiExample {curl} Example usage:\n            curl http://localhost:5000/api/v1/import --data-binary @list-of-sites.txt -H\"x-api-key:8a111a21bc2f8f1dd9b9353bbd46049a\"\n        @apiName Import\n        @apiGroup Watch\n        @apiSuccess (200) {List} OK List of watch UUIDs added\n        @apiSuccess (500) {String} ERR Some other error\n        \"\"\"\n\n        extras = {}\n\n        if request.args.get('proxy'):\n            plist = self.datastore.proxy_list\n            if not request.args.get('proxy') in plist:\n                return \"Invalid proxy choice, currently supported proxies are '{}'\".format(', '.join(plist)), 400\n            else:\n                extras['proxy'] = request.args.get('proxy')\n\n        dedupe = strtobool(request.args.get('dedupe', 'true'))\n\n        tags = request.args.get('tag')\n        tag_uuids = request.args.get('tag_uuids')\n\n        if tag_uuids:\n            tag_uuids = tag_uuids.split(',')\n\n        urls = request.get_data().decode('utf8').splitlines()\n        added = []\n        allow_simplehost = not strtobool(os.getenv('BLOCK_SIMPLEHOSTS', 'False'))\n        for url in urls:\n            url = url.strip()\n            if not len(url):\n                continue\n\n            # If hosts that only contain alphanumerics are allowed (\"localhost\" for example)\n            if not validators.url(url, simple_host=allow_simplehost):\n                return f\"Invalid or unsupported URL - {url}\", 400\n\n            if dedupe and self.datastore.url_exists(url):\n                continue\n\n            new_uuid = self.datastore.add_watch(url=url, extras=extras, tag=tags, tag_uuids=tag_uuids)\n            added.append(new_uuid)\n\n        return added\n\nclass SystemInfo(Resource):\n    def __init__(self, **kwargs):\n        # datastore is a black box dependency\n        self.datastore = kwargs['datastore']\n        self.update_q = kwargs['update_q']\n\n    @auth.check_token\n    def get(self):\n        \"\"\"\n        @api {get} /api/v1/systeminfo Return system info\n        @apiDescription Return some info about the current system state\n        @apiExample {curl} Example usage:\n            curl http://localhost:5000/api/v1/systeminfo -H\"x-api-key:813031b16330fe25e3780cf0325daa45\"\n            HTTP/1.0 200\n            {\n                'queue_size': 10 ,\n                'overdue_watches': [\"watch-uuid-list\"],\n                'uptime': 38344.55,\n                'watch_count': 800,\n                'version': \"0.40.1\"\n            }\n        @apiName Get Info\n        @apiGroup System Information\n        \"\"\"\n        import time\n        overdue_watches = []\n\n        # Check all watches and report which have not been checked but should have been\n\n        for uuid, watch in self.datastore.data.get('watching', {}).items():\n            # see if now - last_checked is greater than the time that should have been\n            # this is not super accurate (maybe they just edited it) but better than nothing\n            t = watch.threshold_seconds()\n            if not t:\n                # Use the system wide default\n                t = self.datastore.threshold_seconds\n\n            time_since_check = time.time() - watch.get('last_checked')\n\n            # Allow 5 minutes of grace time before we decide it's overdue\n            if time_since_check - (5 * 60) > t:\n                overdue_watches.append(uuid)\n        from changedetectionio import __version__ as main_version\n        return {\n                   'queue_size': self.update_q.qsize(),\n                   'overdue_watches': overdue_watches,\n                   'uptime': round(time.time() - self.datastore.start_time, 2),\n                   'watch_count': len(self.datastore.data.get('watching', {})),\n                   'version': main_version\n               }, 200\n"], "filenames": ["changedetectionio/api/api_v1.py"], "buggy_code_start_loc": [135], "buggy_code_end_loc": [135], "fixing_code_start_loc": [136], "fixing_code_end_loc": [137], "type": "CWE-863", "message": " changedetection.io is an open source tool designed to monitor websites for content changes. In affected versions the API endpoint `/api/v1/watch/<uuid>/history` can be accessed by any unauthorized user. As a result any unauthorized user can check one's watch history. However, because unauthorized party first needs to know a watch UUID, and the watch history endpoint itself returns only paths to the snapshot on the server, an impact on users' data privacy is minimal. This issue has been addressed in version 0.45.13. Users are advised to upgrade. There are no known workarounds for this vulnerability.", "other": {"cve": {"id": "CVE-2024-23329", "sourceIdentifier": "security-advisories@github.com", "published": "2024-01-19T20:15:13.827", "lastModified": "2024-01-26T20:19:59.393", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": " changedetection.io is an open source tool designed to monitor websites for content changes. In affected versions the API endpoint `/api/v1/watch/<uuid>/history` can be accessed by any unauthorized user. As a result any unauthorized user can check one's watch history. However, because unauthorized party first needs to know a watch UUID, and the watch history endpoint itself returns only paths to the snapshot on the server, an impact on users' data privacy is minimal. This issue has been addressed in version 0.45.13. Users are advised to upgrade. There are no known workarounds for this vulnerability."}, {"lang": "es", "value": "changetection.io es una herramienta de c\u00f3digo abierto dise\u00f1ada para monitorizar sitios web en busca de cambios de contenido. En las versiones afectadas, cualquier usuario no autorizado puede acceder al endpoint API `/api/v1/watch//history`. Como resultado, cualquier usuario no autorizado puede comprobar su historial de reproducciones. Sin embargo, debido a que la parte no autorizada primero necesita conocer un UUID de vigilancia, y el punto final del historial de vigilancia solo devuelve rutas a la instant\u00e1nea en el servidor, el impacto en la privacidad de los datos de los usuarios es m\u00ednimo. Este problema se solucion\u00f3 en la versi\u00f3n 0.45.13. Se recomienda a los usuarios que actualicen. No se conocen workarounds para esta vulnerabilidad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.7, "baseSeverity": "LOW"}, "exploitabilityScore": 2.2, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.7, "baseSeverity": "LOW"}, "exploitabilityScore": 2.2, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:changedetection:changedetection:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.39.14", "versionEndExcluding": "0.45.13", "matchCriteriaId": "2C57D18E-669F-4D21-BDBE-25B6CD057DB0"}]}]}], "references": [{"url": "https://github.com/dgtlmoon/changedetection.io/commit/402f1e47e78ecd155b1e90f30cce424ff7763e0f", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/dgtlmoon/changedetection.io/security/advisories/GHSA-hcvp-2cc7-jrwr", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/dgtlmoon/changedetection.io/commit/402f1e47e78ecd155b1e90f30cce424ff7763e0f"}}