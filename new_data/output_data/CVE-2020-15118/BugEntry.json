{"buggy_code": ["========\nSettings\n========\n\nWagtail makes use of the following settings, in addition to :doc:`Django's core settings <ref/settings>`:\n\nSite Name\n=========\n\n.. code-block:: python\n\n  WAGTAIL_SITE_NAME = 'Stark Industries Skunkworks'\n\nThis is the human-readable name of your Wagtail install which welcomes users upon login to the Wagtail admin.\n\n.. _append_slash:\n\nAppend Slash\n============\n\n.. code-block:: python\n\n  # Don't add a trailing slash to Wagtail-served URLs\n  WAGTAIL_APPEND_SLASH = False\n\nSimilar to Django's ``APPEND_SLASH``, this setting controls how Wagtail will handle requests that don't end in a trailing slash.\n\nWhen ``WAGTAIL_APPEND_SLASH`` is ``True`` (default), requests to Wagtail pages which omit a trailing slash will be redirected by Django's :class:`~django.middleware.common.CommonMiddleware` to a URL with a trailing slash.\n\nWhen ``WAGTAIL_APPEND_SLASH`` is ``False``, requests to Wagtail pages will be served both with and without trailing slashes. Page links generated by Wagtail, however, will not include trailing slashes.\n\n.. note::\n\n  If you use the ``False`` setting, keep in mind that serving your pages both with and without slashes may affect search engines' ability to index your site. See `this Google Webmaster Blog post`_ for more details.\n\n.. _this Google Webmaster Blog post: https://webmasters.googleblog.com/2010/04/to-slash-or-not-to-slash.html\n\nSearch\n======\n\n.. code-block:: python\n\n  WAGTAILSEARCH_BACKENDS = {\n      'default': {\n          'BACKEND': 'wagtail.search.backends.elasticsearch2',\n          'INDEX': 'myapp'\n      }\n  }\n\nDefine a search backend. For a full explanation, see :ref:`wagtailsearch_backends`.\n\n.. code-block:: python\n\n  WAGTAILSEARCH_RESULTS_TEMPLATE = 'myapp/search_results.html'\n  WAGTAILSEARCH_RESULTS_TEMPLATE_AJAX = 'myapp/includes/search_listing.html'\n\nOverride the templates used by the search front-end views.\n\n.. _wagtailsearch_hits_max_age:\n\n.. code-block:: python\n\n  WAGTAILSEARCH_HITS_MAX_AGE = 14\n\nSet the number of days (default 7) that search query logs are kept for; these are used to identify popular search terms for :ref:`promoted search results <editors-picks>`. Queries older than this will be removed by the :ref:`search_garbage_collect` command.\n\nEmbeds\n======\n\nWagtail supports generating embed code from URLs to content on an external\nproviders such as Youtube or Twitter. By default, Wagtail will fetch the embed\ncode directly from the relevant provider's site using the oEmbed protocol.\nWagtail has a builtin list of the most common providers.\n\nThe embeds fetching can be fully configured using the ``WAGTAILEMBEDS_FINDERS``\nsetting. This is fully documented in :ref:`configuring_embed_finders`.\n\n.. code-block:: python\n\n    WAGTAILEMBEDS_RESPONSIVE_HTML = True\n\nAdds ``class=\"responsive-object\"`` and an inline ``padding-bottom`` style to embeds,\nto assist in making them responsive. See :ref:`responsive-embeds` for details.\n\nDashboard\n=========\n\n.. code-block:: python\n\n    WAGTAILADMIN_RECENT_EDITS_LIMIT = 5\n\nThis setting lets you change the number of items shown at 'Your most recent edits' on the dashboard.\n\n\n.. code-block:: python\n\n  WAGTAILADMIN_USER_LOGIN_FORM = 'users.forms.LoginForm'\n\nAllows the default ``LoginForm`` to be extended with extra fields.\n\n\n.. _wagtail_gravatar_provider_url:\n\n.. code-block:: python\n\n  WAGTAIL_GRAVATAR_PROVIDER_URL = '//www.gravatar.com/avatar'\n\nIf a user has not uploaded a profile picture, Wagtail will look for an avatar linked to their email address on gravatar.com. This setting allows you to specify an alternative provider such as like robohash.org, or can be set to ``None`` to disable the use of remote avatars completely.\n\n.. _wagtail_moderation_enabled:\n\n.. code-block:: python\n\n  WAGTAIL_MODERATION_ENABLED = True\n\nChanges whether the Submit for Moderation button is displayed in the action menu.\n\nImages\n======\n\n.. code-block:: python\n\n  WAGTAILIMAGES_IMAGE_MODEL = 'myapp.MyImage'\n\nThis setting lets you provide your own image model for use in Wagtail, which might extend the built-in ``AbstractImage`` class or replace it entirely.\n\n\n.. code-block:: python\n\n    WAGTAILIMAGES_MAX_UPLOAD_SIZE = 20 * 1024 * 1024  # i.e. 20MB\n\nThis setting lets you override the maximum upload size for images (in bytes). If omitted, Wagtail will fall back to using its 10MB default value.\n\n.. code-block:: python\n\n    WAGTAILIMAGES_MAX_IMAGE_PIXELS = 128000000  # i.e. 128 megapixels\n\nThis setting lets you override the maximum number of pixels an image can have. If omitted, Wagtail will fall back to using its 128 megapixels default value. The pixel count takes animation frames into account - for example, a 25-frame animation of size 100x100 is considered to have 100 * 100 * 25 = 250000 pixels.\n\n.. code-block:: python\n\n    WAGTAILIMAGES_FEATURE_DETECTION_ENABLED = True\n\nThis setting enables feature detection once OpenCV is installed, see all details on the :ref:`image_feature_detection` documentation.\n\n.. code-block:: python\n\n    WAGTAILIMAGES_INDEX_PAGE_SIZE = 20\n\nSpecifies the number of images per page shown on the main Images listing in the Wagtail admin.\n\n.. code-block:: python\n\n    WAGTAILIMAGES_USAGE_PAGE_SIZE = 20\n\nSpecifies the number of items per page shown when viewing an image's usage (see :ref:`WAGTAIL_USAGE_COUNT_ENABLED <WAGTAIL_USAGE_COUNT_ENABLED>`).\n\n.. code-block:: python\n\n    WAGTAILIMAGES_CHOOSER_PAGE_SIZE = 12\n\nSpecifies the number of images shown per page in the image chooser modal.\n\nDocuments\n=========\n\n.. _wagtaildocs_serve_method:\n\n.. code-block:: python\n\n  WAGTAILDOCS_SERVE_METHOD = 'redirect'\n\nDetermines how document downloads will be linked to and served. Normally, requests for documents are sent through a Django view, to perform permission checks (see :ref:`image_document_permissions`) and potentially other housekeeping tasks such as hit counting. To fully protect against users bypassing this check, it needs to happen in the same request where the document is served; however, this incurs a performance hit as the document then needs to be served by the Django server. In particular, this cancels out much of the benefit of hosting documents on external storage, such as S3 or a CDN.\n\nFor this reason, Wagtail provides a number of serving methods which trade some of the strictness of the permission check for performance:\n\n * ``'direct'`` - links to documents point directly to the URL provided by the underlying storage, bypassing the Django view that provides the permission check. This is most useful when deploying sites as fully static HTML (e.g. using `wagtail-bakery <https://github.com/wagtail/wagtail-bakery>`_ or `Gatsby <https://www.gatsbyjs.org/>`_).\n * ``'redirect'`` - links to documents point to a Django view which will check the user's permission; if successful, it will redirect to the URL provided by the underlying storage to allow the document to be downloaded. This is most suitable for remote storage backends such as S3, as it allows the document to be served independently of the Django server. Note that if a user is able to guess the latter URL, they will be able to bypass the permission check; some storage backends may provide configuration options to generate a random or short-lived URL to mitigate this.\n * ``'serve_view'`` - links to documents point to a Django view which both checks the user's permission, and serves the document. Serving will be handled by `django-sendfile <https://github.com/johnsensible/django-sendfile>`_, if this is installed and supported by your server configuration, or as a streaming response from Django if not. When using this method, it is recommended that you configure your webserver to *disallow* serving documents directly from their location under ``MEDIA_ROOT``, as this would provide a way to bypass the permission check.\n\nIf ``WAGTAILDOCS_SERVE_METHOD`` is unspecified or set to ``None``, the default method is ``'redirect'`` when a remote storage backend is in use (i.e. one that exposes a URL but not a local filesystem path), and ``'serve_view'`` otherwise. Finally, some storage backends may not expose a URL at all; in this case, serving will proceed as for ``'serve_view'``.\n\nPassword Management\n===================\n\n.. code-block:: python\n\n  WAGTAIL_PASSWORD_MANAGEMENT_ENABLED = True\n\nThis specifies whether users are allowed to change their passwords (enabled by default).\n\n.. code-block:: python\n\n  WAGTAIL_PASSWORD_RESET_ENABLED = True\n\nThis specifies whether users are allowed to reset their passwords. Defaults to the same as ``WAGTAIL_PASSWORD_MANAGEMENT_ENABLED``. Password reset emails will be sent from the address specified in Django's ``DEFAULT_FROM_EMAIL`` setting.\n\n.. code-block:: python\n\n  WAGTAILUSERS_PASSWORD_ENABLED = True\n\nThis specifies whether password fields are shown when creating or editing users through Settings -> Users (enabled by default). Set this to False (along with ``WAGTAIL_PASSWORD_MANAGEMENT_ENABLED`` and ``WAGTAIL_PASSWORD_RESET_ENABLED``) if your users are authenticated through an external system such as LDAP.\n\n.. code-block:: python\n\n  WAGTAILUSERS_PASSWORD_REQUIRED = True\n\nThis specifies whether password is a required field when creating a new user. True by default; ignored if ``WAGTAILUSERS_PASSWORD_ENABLED`` is false. If this is set to False, and the password field is left blank when creating a user, then that user will have no usable password; in order to log in, they will have to reset their password (if ``WAGTAIL_PASSWORD_RESET_ENABLED`` is True) or use an alternative authentication system such as LDAP (if one is set up).\n\n.. code-block:: python\n\n  WAGTAIL_EMAIL_MANAGEMENT_ENABLED = True\n\nThis specifies whether users are allowed to change their email (enabled by default).\n\n.. _email_notifications:\n\nEmail Notifications\n===================\n\n.. code-block:: python\n\n  WAGTAILADMIN_NOTIFICATION_FROM_EMAIL = 'wagtail@myhost.io'\n\nWagtail sends email notifications when content is submitted for moderation, and when the content is accepted or rejected. This setting lets you pick which email address these automatic notifications will come from. If omitted, Wagtail will fall back to using Django's ``DEFAULT_FROM_EMAIL`` setting if set, or ``webmaster@localhost`` if not.\n\n.. code-block:: python\n\n  WAGTAILADMIN_NOTIFICATION_USE_HTML = True\n\nNotification emails are sent in `text/plain` by default, change this to use HTML formatting.\n\n.. code-block:: python\n\n  WAGTAILADMIN_NOTIFICATION_INCLUDE_SUPERUSERS = False\n\nNotification emails are sent to moderators and superusers by default. You can change this to exclude superusers and only notify moderators.\n\n.. _update_notifications:\n\nWagtail update notifications\n============================\n\n.. code-block:: python\n\n  WAGTAIL_ENABLE_UPDATE_CHECK = True\n\nFor admins only, Wagtail performs a check on the dashboard to see if newer releases are available. This also provides the Wagtail team with the hostname of your Wagtail site. If you'd rather not receive update notifications, or if you'd like your site to remain unknown, you can disable it with this setting.\n\n\nPrivate pages / documents\n=========================\n\n.. code-block:: python\n\n  PASSWORD_REQUIRED_TEMPLATE = 'myapp/password_required.html'\n\nThis is the path to the Django template which will be used to display the \"password required\" form when a user accesses a private page. For more details, see the :ref:`private_pages` documentation.\n\n.. code-block:: python\n\n  DOCUMENT_PASSWORD_REQUIRED_TEMPLATE = 'myapp/document_password_required.html'\n\nAs above, but for password restrictions on documents. For more details, see the :ref:`private_pages` documentation.\n\nLogin page\n==========\n\nThe basic login page can be customised with a custom template.\n\n.. code-block:: python\n\n  WAGTAIL_FRONTEND_LOGIN_TEMPLATE = 'myapp/login.html'\n\nOr the login page can be a redirect to an external or internal URL.\n\n.. code-block:: python\n\n  WAGTAIL_FRONTEND_LOGIN_URL = '/accounts/login/'\n\nFor more details, see the :ref:`login_page` documentation.\n\nCase-Insensitive Tags\n=====================\n\n.. code-block:: python\n\n  TAGGIT_CASE_INSENSITIVE = True\n\nTags are case-sensitive by default ('music' and 'Music' are treated as distinct tags). In many cases the reverse behaviour is preferable.\n\nMulti-word tags\n===============\n\n.. code-block:: python\n\n  TAG_SPACES_ALLOWED = False\n\nTags can only consist of a single word, no spaces allowed. The default setting is ``True`` (spaces in tags are allowed).\n\nTag limit\n=========\n\n.. code-block:: python\n\n  TAG_LIMIT = 5\n\nLimit the number of tags that can be added to (django-taggit) Tag model. Default setting is ``None``, meaning no limit on tags.\n\nUnicode Page Slugs\n==================\n\n.. code-block:: python\n\n  WAGTAIL_ALLOW_UNICODE_SLUGS = True\n\nBy default, page slugs can contain any alphanumeric characters, including non-Latin alphabets. Set this to False to limit slugs to ASCII characters.\n\n.. _WAGTAIL_AUTO_UPDATE_PREVIEW:\n\nAuto update preview\n===================\n\n.. code-block:: python\n\n  WAGTAIL_AUTO_UPDATE_PREVIEW = False\n\nWhen enabled, data from an edited page is automatically sent to the server\non each change, even without saving. That way, users don\u2019t have to click on\n\u201cPreview\u201d to update the content of the preview page. However, the preview page\ntab is not refreshed automatically, users have to do it manually.\nThis behaviour is disabled by default.\n\nCustom User Edit Forms\n======================\n\nSee :doc:`/advanced_topics/customisation/custom_user_models`.\n\n.. code-block:: python\n\n  WAGTAIL_USER_EDIT_FORM = 'users.forms.CustomUserEditForm'\n\nAllows the default ``UserEditForm`` class to be overridden with a custom form when\na custom user model is being used and extra fields are required in the user edit form.\n\n.. code-block:: python\n\n  WAGTAIL_USER_CREATION_FORM = 'users.forms.CustomUserCreationForm'\n\nAllows the default ``UserCreationForm`` class to be overridden with a custom form when\na custom user model is being used and extra fields are required in the user creation form.\n\n.. code-block:: python\n\n  WAGTAIL_USER_CUSTOM_FIELDS = ['country']\n\nA list of the extra custom fields to be appended to the default list.\n\n.. _WAGTAIL_USAGE_COUNT_ENABLED:\n\nUsage for images, documents and snippets\n========================================\n\n.. code-block:: python\n\n    WAGTAIL_USAGE_COUNT_ENABLED = True\n\nWhen enabled Wagtail shows where a particular image, document or snippet is being used on your site.\nThis is disabled by default because it generates a query which may run slowly on sites with large numbers of pages.\n\nA link will appear on the edit page (in the rightmost column) showing you how many times the item is used.\nClicking this link takes you to the \"Usage\" page, which shows you where the snippet, document or image is used.\n\nThe link is also shown on the delete page, above the \"Delete\" button.\n\n.. note::\n\n    The usage count only applies to direct (database) references. Using documents, images and snippets within StreamFields or rich text fields will not be taken into account.\n\nDate and DateTime inputs\n========================\n\n.. code-block:: python\n\n    WAGTAIL_DATE_FORMAT = '%d.%m.%Y.'\n    WAGTAIL_DATETIME_FORMAT = '%d.%m.%Y. %H:%M'\n    WAGTAIL_TIME_FORMAT = '%H:%M'\n\n\nSpecifies the date, time and datetime format to be used in input fields in the Wagtail admin. The format is specified in `Python datetime module syntax <https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior>`_, and must be one of the recognised formats listed in the ``DATE_INPUT_FORMATS``, ``TIME_INPUT_FORMATS``, or ``DATETIME_INPUT_FORMATS`` setting respectively (see `DATE_INPUT_FORMATS <https://docs.djangoproject.com/en/stable/ref/settings/#std:setting-DATE_INPUT_FORMATS>`_).\n\n.. _WAGTAIL_USER_TIME_ZONES:\n\nTime zones\n==========\n\nLogged-in users can choose their current time zone for the admin interface in the account settings.  If is no time zone selected by the user, then ``TIME_ZONE`` will be used.\n(Note that time zones are only applied to datetime fields, not to plain time or date fields.  This is a Django design decision.)\n\nThe list of time zones is by default the common_timezones list from pytz.\nIt is possible to override this list via the ``WAGTAIL_USER_TIME_ZONES`` setting.\nIf there is zero or one time zone permitted, the account settings form will be hidden.\n\n.. code-block:: python\n\n    WAGTAIL_USER_TIME_ZONES = ['America/Chicago', 'Australia/Sydney', 'Europe/Rome']\n\n.. _WAGTAILADMIN_PERMITTED_LANGUAGES:\n\nAdmin languages\n===============\n\nUsers can choose between several languages for the admin interface\nin the account settings. The list of languages is by default all the available\nlanguages in Wagtail with at least 90% coverage. To change it, set ``WAGTAILADMIN_PERMITTED_LANGUAGES``:\n\n.. code-block:: python\n\n    WAGTAILADMIN_PERMITTED_LANGUAGES = [('en', 'English'),\n                                        ('pt', 'Portuguese')]\n\nSince the syntax is the same as Django ``LANGUAGES``, you can do this so users\ncan only choose between front office languages:\n\n.. code-block:: python\n\n    LANGUAGES = WAGTAILADMIN_PERMITTED_LANGUAGES = [('en', 'English'),\n                                                    ('pt', 'Portuguese')]\n\nStatic files\n============\n\n.. code-block:: python\n\n    WAGTAILADMIN_STATIC_FILE_VERSION_STRINGS = False\n\nStatic file URLs within the Wagtail admin are given a version-specific query string of the form ``?v=1a2b3c4d``, to prevent outdated cached copies of Javascript and CSS files from persisting after a Wagtail upgrade. To disable these, set ``WAGTAILADMIN_STATIC_FILE_VERSION_STRINGS`` to ``False``.\n\nAPI Settings\n============\n\nFor full documenation on API configuration, including these settings, see :ref:`api_v2_configuration` documentation.\n\n.. code-block:: python\n\n    WAGTAILAPI_BASE_URL = 'http://api.example.com/'\n\nRequired when using frontend cache invalidation, used to generate absolute URLs to document files and invalidating the cache.\n\n\n.. code-block:: python\n\n    WAGTAILAPI_LIMIT_MAX = 500\n\nDefault is 20, used to change the maximum number of results a user can request at a time, set to ``None`` for no limit.\n\n\n.. code-block:: python\n\n    WAGTAILAPI_SEARCH_ENABLED = False\n\nDefault is true, setting this to false will disable full text search on all endpoints.\n\n.. code-block:: python\n\n    WAGTAILAPI_USE_FRONTENDCACHE = True\n\nRequires ``wagtailfrontendcache`` app to be installed, inidicates the API should use the frontend cache.\n\nFrontend cache\n==============\n\nFor full documenation on frontend cache invalidation, including these settings, see :ref:`frontend_cache_purging`.\n\n\n.. code-block:: python\n\n    WAGTAILFRONTENDCACHE = {\n        'varnish': {\n            'BACKEND': 'wagtail.contrib.frontend_cache.backends.HTTPBackend',\n            'LOCATION': 'http://localhost:8000',\n        },\n    }\n\nSee documentation linked above for full options available.\n\n.. note::\n\n    ``WAGTAILFRONTENDCACHE_LOCATION`` is no longer the preferred way to set the cache location, instead set the ``LOCATION`` within the ``WAGTAILFRONTENDCACHE`` item.\n\n\n.. code-block:: python\n\n    WAGTAILFRONTENDCACHE_LANGUAGES = [l[0] for l in settings.LANGUAGES]\n\nDefault is an empty list, must be a list of languages to also purge the urls for each language of a purging url. This setting needs ``settings.USE_I18N`` to be ``True`` to work.\n\n.. _WAGTAILADMIN_RICH_TEXT_EDITORS:\n\nRich text\n=========\n\n.. code-block:: python\n\n    WAGTAILADMIN_RICH_TEXT_EDITORS = {\n        'default': {\n            'WIDGET': 'wagtail.admin.rich_text.DraftailRichTextArea',\n            'OPTIONS': {\n                'features': ['h2', 'bold', 'italic', 'link', 'document-link']\n            }\n        },\n        'legacy': {\n            'WIDGET': 'wagtail.admin.rich_text.HalloRichTextArea',\n        }\n    }\n\nCustomise the behaviour of rich text fields. By default, ``RichTextField`` and ``RichTextBlock`` use the configuration given under the ``'default'`` key, but this can be overridden on a per-field basis through the ``editor`` keyword argument, e.g. ``body = RichTextField(editor='legacy')``. Within each configuration block, the following fields are recognised:\n\n * ``WIDGET``: The rich text widget implementation to use. Wagtail provides two implementations: ``wagtail.admin.rich_text.DraftailRichTextArea`` (a modern extensible editor which enforces well-structured markup) and ``wagtail.admin.rich_text.HalloRichTextArea`` (deprecated; works directly at the HTML level). Other widgets may be provided by third-party packages.\n\n * ``OPTIONS``: Configuration options to pass to the widget. Recognised options are widget-specific, but both ``DraftailRichTextArea`` and ``HalloRichTextArea`` accept a ``features`` list indicating the active rich text features (see :ref:`rich_text_features`).\n\nIf a ``'default'`` editor is not specified, rich text fields that do not specify an ``editor`` argument will use the Draftail editor with the default feature set enabled.\n\n.. versionchanged:: 2.10\n\n    Omitting the ``'default'`` editor now leaves the original default editor intact, so it is no longer necessary to redefine ``'default'`` when adding alternative editors.\n\n\n.. _WAGTAILADMIN_GLOBAL_PAGE_EDIT_LOCK:\n\nPage locking\n============\n\n``WAGTAILADMIN_GLOBAL_PAGE_EDIT_LOCK`` can be set to ``True`` to prevent users\nfrom editing pages that they have locked.\n\nRedirects\n=========\n\n.. code-block:: python\n\n   WAGTAIL_REDIRECTS_FILE_STORAGE = 'tmp_file'\n\nBy default the redirect importer keeps track of the uploaded file as a temp file, but on certain environments (load balanced/cloud environments), you cannot keep a shared file between environments. For those cases you can use the built-in cache to store the file instead.\n\n.. code-block:: python\n\n   WAGTAIL_REDIRECTS_FILE_STORAGE = 'cache'\n", "from collections import OrderedDict\n\nimport django.forms\nfrom django.utils.translation import gettext_lazy as _\n\nfrom wagtail.admin.forms import WagtailAdminPageForm\nfrom wagtail.contrib.forms.utils import get_field_clean_name\n\n\nclass BaseForm(django.forms.Form):\n    def __init__(self, *args, **kwargs):\n        kwargs.setdefault('label_suffix', '')\n\n        self.user = kwargs.pop('user', None)\n        self.page = kwargs.pop('page', None)\n\n        super().__init__(*args, **kwargs)\n\n\nclass FormBuilder:\n    def __init__(self, fields):\n        self.fields = fields\n\n    def create_singleline_field(self, field, options):\n        # TODO: This is a default value - it may need to be changed\n        options['max_length'] = 255\n        return django.forms.CharField(**options)\n\n    def create_multiline_field(self, field, options):\n        return django.forms.CharField(widget=django.forms.Textarea, **options)\n\n    def create_date_field(self, field, options):\n        return django.forms.DateField(**options)\n\n    def create_datetime_field(self, field, options):\n        return django.forms.DateTimeField(**options)\n\n    def create_email_field(self, field, options):\n        return django.forms.EmailField(**options)\n\n    def create_url_field(self, field, options):\n        return django.forms.URLField(**options)\n\n    def create_number_field(self, field, options):\n        return django.forms.DecimalField(**options)\n\n    def create_dropdown_field(self, field, options):\n        options['choices'] = map(\n            lambda x: (x.strip(), x.strip()),\n            field.choices.split(',')\n        )\n        return django.forms.ChoiceField(**options)\n\n    def create_multiselect_field(self, field, options):\n        options['choices'] = map(\n            lambda x: (x.strip(), x.strip()),\n            field.choices.split(',')\n        )\n        return django.forms.MultipleChoiceField(**options)\n\n    def create_radio_field(self, field, options):\n        options['choices'] = map(\n            lambda x: (x.strip(), x.strip()),\n            field.choices.split(',')\n        )\n        return django.forms.ChoiceField(widget=django.forms.RadioSelect, **options)\n\n    def create_checkboxes_field(self, field, options):\n        options['choices'] = [(x.strip(), x.strip()) for x in field.choices.split(',')]\n        options['initial'] = [x.strip() for x in field.default_value.split(',')]\n        return django.forms.MultipleChoiceField(\n            widget=django.forms.CheckboxSelectMultiple, **options\n        )\n\n    def create_checkbox_field(self, field, options):\n        return django.forms.BooleanField(**options)\n\n    def create_hidden_field(self, field, options):\n        return django.forms.CharField(widget=django.forms.HiddenInput, **options)\n\n    def get_create_field_function(self, type):\n        \"\"\"\n            Takes string of field type and returns a Django Form Field Instance.\n            Assumes form field creation functions are in the format:\n            'create_fieldtype_field'\n        \"\"\"\n        create_field_function = getattr(self, 'create_%s_field' % type, None)\n        if create_field_function:\n            return create_field_function\n        else:\n            import inspect\n            method_list = [\n                f[0] for f in\n                inspect.getmembers(self.__class__, inspect.isfunction)\n                if f[0].startswith('create_') and f[0].endswith('_field')\n            ]\n            raise AttributeError(\n                \"Could not find function matching format \\\n                create_<fieldname>_field for type: \" + type,\n                \"Must be one of: \" + \", \".join(method_list)\n            )\n\n    @property\n    def formfields(self):\n        formfields = OrderedDict()\n\n        for field in self.fields:\n            options = self.get_field_options(field)\n            create_field = self.get_create_field_function(field.field_type)\n            formfields[field.clean_name] = create_field(field, options)\n\n        return formfields\n\n    def get_field_options(self, field):\n        options = {}\n        options['label'] = field.label\n        options['help_text'] = field.help_text\n        options['required'] = field.required\n        options['initial'] = field.default_value\n        return options\n\n    def get_form_class(self):\n        return type(str('WagtailForm'), (BaseForm,), self.formfields)\n\n\nclass SelectDateForm(django.forms.Form):\n    date_from = django.forms.DateTimeField(\n        required=False,\n        widget=django.forms.DateInput(attrs={'placeholder': _('Date from')})\n    )\n    date_to = django.forms.DateTimeField(\n        required=False,\n        widget=django.forms.DateInput(attrs={'placeholder': _('Date to')})\n    )\n\n\nclass WagtailAdminFormPageForm(WagtailAdminPageForm):\n\n    def clean(self):\n\n        super().clean()\n\n        # Check for dupe form field labels - fixes #585\n        if 'form_fields' in self.formsets:\n            _forms = self.formsets['form_fields'].forms\n            for f in _forms:\n                f.is_valid()\n\n            for i, form in enumerate(_forms):\n                if 'label' in form.changed_data:\n                    label = form.cleaned_data.get('label')\n                    clean_name = get_field_clean_name(label)\n                    for idx, ff in enumerate(_forms):\n                        # Exclude self\n                        ff_clean_name = get_field_clean_name(ff.cleaned_data.get('label'))\n                        if idx != i and clean_name == ff_clean_name:\n                            form.add_error(\n                                'label',\n                                django.forms.ValidationError(_('There is another field with the label %s, please change one of them.' % label))\n                            )\n", "# -*- coding: utf-8 -*-\nimport json\n\nfrom django.core import mail\nfrom django.core.checks import Info\nfrom django.test import TestCase, override_settings\n\nfrom wagtail.contrib.forms.models import FormSubmission\nfrom wagtail.contrib.forms.tests.utils import (\n    make_form_page, make_form_page_with_custom_submission, make_form_page_with_redirect,\n    make_types_test_form_page)\nfrom wagtail.core.models import Page\nfrom wagtail.tests.testapp.models import (\n    CustomFormPageSubmission, ExtendedFormField, FormField, FormFieldWithCustomSubmission,\n    FormPageWithCustomFormBuilder, JadeFormPage)\nfrom wagtail.tests.utils import WagtailTestUtils\n\n\nclass TestFormSubmission(TestCase):\n    def setUp(self):\n        # Create a form page\n        self.form_page = make_form_page()\n\n    def test_get_form(self):\n        response = self.client.get('/contact-us/')\n\n        # Check response\n        self.assertContains(response, \"\"\"<label for=\"id_your_email\">Your email</label>\"\"\")\n        self.assertTemplateUsed(response, 'tests/form_page.html')\n        self.assertTemplateNotUsed(response, 'tests/form_page_landing.html')\n\n        # check that variables defined in get_context are passed through to the template (#1429)\n        self.assertContains(response, \"<p>hello world</p>\")\n\n    def test_post_invalid_form(self):\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob',\n            'your_message': 'hello world',\n            'your_choices': ''\n        })\n\n        # Check response\n        self.assertContains(response, \"Enter a valid email address.\")\n        self.assertTemplateUsed(response, 'tests/form_page.html')\n        self.assertTemplateNotUsed(response, 'tests/form_page_landing.html')\n\n    def test_post_valid_form(self):\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': 'hello world',\n            'your_choices': {'foo': '', 'bar': '', 'baz': ''}\n        })\n\n        # Check response\n        self.assertContains(response, \"Thank you for your feedback.\")\n        self.assertTemplateNotUsed(response, 'tests/form_page.html')\n        self.assertTemplateUsed(response, 'tests/form_page_landing.html')\n\n        # check that variables defined in get_context are passed through to the template (#1429)\n        self.assertContains(response, \"<p>hello world</p>\")\n\n        # check the default form_submission is added to the context\n        self.assertContains(response, \"<li>your_email: bob@example.com</li>\")\n\n        # Check that an email was sent\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertEqual(mail.outbox[0].subject, \"The subject\")\n        self.assertIn(\"Your message: hello world\", mail.outbox[0].body)\n        self.assertEqual(mail.outbox[0].to, ['to@email.com'])\n        self.assertEqual(mail.outbox[0].from_email, 'from@email.com')\n\n        # Check that form submission was saved correctly\n        form_page = Page.objects.get(url_path='/home/contact-us/')\n        self.assertTrue(FormSubmission.objects.filter(page=form_page, form_data__contains='hello world').exists())\n\n    def test_post_unicode_characters(self):\n        self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': '\u3053\u3093\u306b\u3061\u306f\u3001\u4e16\u754c',\n            'your_choices': {'foo': '', 'bar': '', 'baz': ''}\n        })\n\n        # Check the email\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertIn(\"Your message: \u3053\u3093\u306b\u3061\u306f\u3001\u4e16\u754c\", mail.outbox[0].body)\n\n        # Check the form submission\n        submission = FormSubmission.objects.get()\n        submission_data = json.loads(submission.form_data)\n        self.assertEqual(submission_data['your_message'], '\u3053\u3093\u306b\u3061\u306f\u3001\u4e16\u754c')\n\n    def test_post_multiple_values(self):\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': 'hello world',\n            'your_choices': {'foo': 'on', 'bar': 'on', 'baz': 'on'}\n        })\n\n        # Check response\n        self.assertContains(response, \"Thank you for your feedback.\")\n        self.assertTemplateNotUsed(response, 'tests/form_page.html')\n        self.assertTemplateUsed(response, 'tests/form_page_landing.html')\n\n        # Check that the three checkbox values were saved correctly\n        form_page = Page.objects.get(url_path='/home/contact-us/')\n        submission = FormSubmission.objects.filter(\n            page=form_page, form_data__contains='hello world'\n        )\n        self.assertIn(\"foo\", submission[0].form_data)\n        self.assertIn(\"bar\", submission[0].form_data)\n        self.assertIn(\"baz\", submission[0].form_data)\n\n        # Check that the all the multiple checkbox values are serialised in the\n        # email correctly\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertIn(\"bar\", mail.outbox[0].body)\n        self.assertIn(\"foo\", mail.outbox[0].body)\n        self.assertIn(\"baz\", mail.outbox[0].body)\n\n    def test_post_blank_checkbox(self):\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': 'hello world',\n            'your_choices': {},\n        })\n\n        # Check response\n        self.assertContains(response, \"Thank you for your feedback.\")\n        self.assertTemplateNotUsed(response, 'tests/form_page.html')\n        self.assertTemplateUsed(response, 'tests/form_page_landing.html')\n\n        # Check that the checkbox was serialised in the email correctly\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertIn(\"Your choices: \", mail.outbox[0].body)\n\n\nclass TestFormWithCustomSubmission(TestCase, WagtailTestUtils):\n    def setUp(self):\n        # Create a form page\n        self.form_page = make_form_page_with_custom_submission()\n\n        self.user = self.login()\n\n    def test_get_form(self):\n        response = self.client.get('/contact-us/')\n\n        # Check response\n        self.assertContains(response, \"\"\"<label for=\"id_your_email\">Your email</label>\"\"\")\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission.html')\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission_landing.html')\n        self.assertNotContains(response, '<div>You must log in first.</div>', html=True)\n        self.assertContains(response, '<p>Boring intro text</p>', html=True)\n\n        # check that variables defined in get_context are passed through to the template (#1429)\n        self.assertContains(response, \"<p>hello world</p>\")\n\n    def test_get_form_with_anonymous_user(self):\n        self.client.logout()\n\n        response = self.client.get('/contact-us/')\n\n        # Check response\n        self.assertNotContains(response, \"\"\"<label for=\"id_your_email\">Your email</label>\"\"\")\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission.html')\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission_landing.html')\n        self.assertContains(response, '<div>You must log in first.</div>', html=True)\n        self.assertNotContains(response, '<p>Boring intro text</p>', html=True)\n\n        # check that variables defined in get_context are passed through to the template (#1429)\n        self.assertContains(response, \"<p>hello world</p>\")\n\n    def test_post_invalid_form(self):\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob',\n            'your_message': 'hello world',\n            'your_choices': ''\n        })\n\n        # Check response\n        self.assertContains(response, \"Enter a valid email address.\")\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission.html')\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission_landing.html')\n\n    def test_post_valid_form(self):\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': 'hello world',\n            'your_choices': {'foo': '', 'bar': '', 'baz': ''}\n        })\n\n        # Check response\n        self.assertContains(response, \"Thank you for your patience!\")\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission.html')\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission_landing.html')\n\n        # check that variables defined in get_context are passed through to the template (#1429)\n        self.assertContains(response, \"<p>hello world</p>\")\n\n        # check that the custom form_submission is added to the context\n        self.assertContains(response, \"<p>Username: test@email.com</p>\")\n\n        # Check that an email was sent\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertEqual(mail.outbox[0].subject, \"The subject\")\n        self.assertIn(\"Your message: hello world\", mail.outbox[0].body)\n        self.assertEqual(mail.outbox[0].to, ['to@email.com'])\n        self.assertEqual(mail.outbox[0].from_email, 'from@email.com')\n\n        # Check that form submission was saved correctly\n        form_page = Page.objects.get(url_path='/home/contact-us/')\n        self.assertTrue(CustomFormPageSubmission.objects.filter(page=form_page, form_data__contains='hello world').exists())\n\n    def test_post_form_twice(self):\n        # First submission\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': 'hello world',\n            'your_choices': {'foo': '', 'bar': '', 'baz': ''}\n        })\n\n        # Check response\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission.html')\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission_landing.html')\n        self.assertContains(response, '<p>Thank you for your patience!</p>', html=True)\n        self.assertNotContains(response, '<div>The form is already filled.</div>', html=True)\n\n        # Check that first form submission was saved correctly\n        submissions_qs = CustomFormPageSubmission.objects.filter(user=self.user, page=self.form_page)\n        self.assertEqual(submissions_qs.count(), 1)\n        self.assertTrue(submissions_qs.filter(form_data__contains='hello world').exists())\n\n        # Second submission\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': 'hello world',\n            'your_choices': {'foo': '', 'bar': '', 'baz': ''}\n        })\n\n        # Check response\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission.html')\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission_landing.html')\n        self.assertNotContains(response, '<p>Thank you for your patience!</p>', html=True)\n        self.assertContains(response, '<div>The form is already filled.</div>', html=True)\n        self.assertNotContains(response, '<div>You must log in first.</div>', html=True)\n        self.assertNotContains(response, '<p>Boring intro text</p>', html=True)\n\n        # Check that first submission exists and second submission wasn't saved\n        submissions_qs = CustomFormPageSubmission.objects.filter(user=self.user, page=self.form_page)\n        self.assertEqual(submissions_qs.count(), 1)\n        self.assertTrue(submissions_qs.filter(form_data__contains='hello world').exists())\n        self.assertFalse(submissions_qs.filter(form_data__contains='hello cruel world').exists())\n\n    def test_post_unicode_characters(self):\n        self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': '\u3053\u3093\u306b\u3061\u306f\u3001\u4e16\u754c',\n            'your_choices': {'foo': '', 'bar': '', 'baz': ''}\n        })\n\n        # Check the email\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertIn(\"Your message: \u3053\u3093\u306b\u3061\u306f\u3001\u4e16\u754c\", mail.outbox[0].body)\n\n        # Check the form submission\n        submission = CustomFormPageSubmission.objects.get()\n        submission_data = json.loads(submission.form_data)\n        self.assertEqual(submission_data['your_message'], '\u3053\u3093\u306b\u3061\u306f\u3001\u4e16\u754c')\n\n    def test_post_multiple_values(self):\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': 'hello world',\n            'your_choices': {'foo': 'on', 'bar': 'on', 'baz': 'on'}\n        })\n\n        # Check response\n        self.assertContains(response, \"Thank you for your patience!\")\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission.html')\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission_landing.html')\n\n        # Check that the three checkbox values were saved correctly\n        form_page = Page.objects.get(url_path='/home/contact-us/')\n        submission = CustomFormPageSubmission.objects.filter(\n            page=form_page, form_data__contains='hello world'\n        )\n        self.assertIn(\"foo\", submission[0].form_data)\n        self.assertIn(\"bar\", submission[0].form_data)\n        self.assertIn(\"baz\", submission[0].form_data)\n\n    def test_post_blank_checkbox(self):\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': 'hello world',\n            'your_choices': {},\n        })\n\n        # Check response\n        self.assertContains(response, \"Thank you for your patience!\")\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission.html')\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission_landing.html')\n\n        # Check that the checkbox was serialised in the email correctly\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertIn(\"Your choices: None\", mail.outbox[0].body)\n\n\nclass TestFormSubmissionWithMultipleRecipients(TestCase):\n    def setUp(self):\n        # Create a form page\n        self.form_page = make_form_page(to_address='to@email.com, another@email.com')\n\n    def test_post_valid_form(self):\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': 'hello world',\n            'your_choices': {'foo': '', 'bar': '', 'baz': ''}\n        })\n\n        # Check response\n        self.assertContains(response, \"Thank you for your feedback.\")\n        self.assertTemplateNotUsed(response, 'tests/form_page.html')\n        self.assertTemplateUsed(response, 'tests/form_page_landing.html')\n\n        # check that variables defined in get_context are passed through to the template (#1429)\n        self.assertContains(response, \"<p>hello world</p>\")\n\n        # Check that one email was sent, but to two recipients\n        self.assertEqual(len(mail.outbox), 1)\n\n        self.assertEqual(mail.outbox[0].subject, \"The subject\")\n        self.assertIn(\"Your message: hello world\", mail.outbox[0].body)\n        self.assertEqual(mail.outbox[0].from_email, 'from@email.com')\n        self.assertEqual(set(mail.outbox[0].to), {'to@email.com', 'another@email.com'})\n\n        # Check that form submission was saved correctly\n        form_page = Page.objects.get(url_path='/home/contact-us/')\n        self.assertTrue(FormSubmission.objects.filter(page=form_page, form_data__contains='hello world').exists())\n\n\nclass TestFormSubmissionWithMultipleRecipientsAndWithCustomSubmission(TestCase, WagtailTestUtils):\n    def setUp(self):\n        # Create a form page\n        self.form_page = make_form_page_with_custom_submission(\n            to_address='to@email.com, another@email.com'\n        )\n\n        self.user = self.login()\n\n    def test_post_valid_form(self):\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': 'hello world',\n            'your_choices': {'foo': '', 'bar': '', 'baz': ''}\n        })\n\n        # Check response\n        self.assertContains(response, \"Thank you for your patience!\")\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission.html')\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission_landing.html')\n\n        # check that variables defined in get_context are passed through to the template (#1429)\n        self.assertContains(response, \"<p>hello world</p>\")\n\n        # Check that one email was sent, but to two recipients\n        self.assertEqual(len(mail.outbox), 1)\n\n        self.assertEqual(mail.outbox[0].subject, \"The subject\")\n        self.assertIn(\"Your message: hello world\", mail.outbox[0].body)\n        self.assertEqual(mail.outbox[0].from_email, 'from@email.com')\n        self.assertEqual(set(mail.outbox[0].to), {'to@email.com', 'another@email.com'})\n\n        # Check that form submission was saved correctly\n        form_page = Page.objects.get(url_path='/home/contact-us/')\n        self.assertTrue(\n            CustomFormPageSubmission.objects.filter(page=form_page, form_data__contains='hello world').exists()\n        )\n\n\nclass TestFormWithRedirect(TestCase):\n    def setUp(self):\n        # Create a form page\n        self.form_page = make_form_page_with_redirect(to_address='to@email.com, another@email.com')\n\n    def test_post_valid_form(self):\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': 'hello world',\n            'your_choices': {'foo': '', 'bar': '', 'baz': ''}\n        })\n\n        # Check response\n        self.assertRedirects(response, '/')\n\n        # Check that one email was sent, but to two recipients\n        self.assertEqual(len(mail.outbox), 1)\n\n        self.assertEqual(mail.outbox[0].subject, \"The subject\")\n        self.assertIn(\"Your message: hello world\", mail.outbox[0].body)\n        self.assertEqual(mail.outbox[0].from_email, 'from@email.com')\n        self.assertEqual(set(mail.outbox[0].to), {'to@email.com', 'another@email.com'})\n\n        # Check that form submission was saved correctly\n        form_page = Page.objects.get(url_path='/home/contact-us/')\n        self.assertTrue(FormSubmission.objects.filter(page=form_page, form_data__contains='hello world').exists())\n\n\nclass TestFormPageWithCustomFormBuilder(TestCase, WagtailTestUtils):\n\n    def setUp(self):\n\n        home_page = Page.objects.get(url_path='/home/')\n        form_page = home_page.add_child(\n            instance=FormPageWithCustomFormBuilder(\n                title='Support Request',\n                slug='support-request',\n                to_address='it@jenkins.com',\n                from_address='support@jenkins.com',\n                subject='Support Request Submitted',\n            )\n        )\n        ExtendedFormField.objects.create(\n            page=form_page,\n            sort_order=1,\n            label='Name',\n            field_type='singleline',  # singleline field will be max_length 120\n            required=True,\n        )\n        ExtendedFormField.objects.create(\n            page=form_page,\n            sort_order=1,\n            label='Device IP Address',\n            field_type='ipaddress',\n            required=True,\n        )\n\n    def test_get_form(self):\n        response = self.client.get('/support-request/')\n\n        # Check response\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_form_builder.html')\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_form_builder_landing.html')\n        self.assertContains(response, '<title>Support Request</title>', html=True)\n        # check that max_length attribute has been passed into form\n        self.assertContains(response, '<input type=\"text\" name=\"name\" required maxlength=\"120\" id=\"id_name\" />', html=True)\n        # check ip address field has rendered\n        self.assertContains(response, '<input type=\"text\" name=\"device_ip_address\" required id=\"id_device_ip_address\" />', html=True)\n\n    def test_post_invalid_form(self):\n        response = self.client.post('/support-request/', {\n            'name': 'very long name longer than 120 characters' * 3,  # invalid\n            'device_ip_address': '192.0.2.30',  # valid\n        })\n        # Check response with invalid character count\n        self.assertContains(response, 'Ensure this value has at most 120 characters (it has 123)')\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_form_builder.html')\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_form_builder_landing.html')\n\n        response = self.client.post('/support-request/', {\n            'name': 'Ron Johnson',  # valid\n            'device_ip_address': '3300.192.0.2.30',  # invalid\n        })\n        # Check response with invalid character count\n        self.assertContains(response, 'Enter a valid IPv4 or IPv6 address.')\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_form_builder.html')\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_form_builder_landing.html')\n\n    def test_post_valid_form(self):\n        response = self.client.post('/support-request/', {\n            'name': 'Ron Johnson',\n            'device_ip_address': '192.0.2.30',\n        })\n\n        # Check response\n        self.assertContains(response, 'Thank you for submitting a Support Request.')\n        self.assertContains(response, 'Ron Johnson')\n        self.assertContains(response, '192.0.2.30')\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_form_builder.html')\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_form_builder_landing.html')\n\n\nclass TestCleanedDataEmails(TestCase):\n    def setUp(self):\n        # Create a form page\n        self.form_page = make_types_test_form_page()\n\n    def test_empty_field_presence(self):\n        self.client.post('/contact-us/', {})\n\n        # Check the email\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertIn(\"Single line text: \", mail.outbox[0].body)\n        self.assertIn(\"Multiline: \", mail.outbox[0].body)\n        self.assertIn(\"Email: \", mail.outbox[0].body)\n        self.assertIn(\"Number: \", mail.outbox[0].body)\n        self.assertIn(\"URL: \", mail.outbox[0].body)\n        self.assertIn(\"Checkbox: \", mail.outbox[0].body)\n        self.assertIn(\"Checkboxes: \", mail.outbox[0].body)\n        self.assertIn(\"Drop down: \", mail.outbox[0].body)\n        self.assertIn(\"Multiple select: \", mail.outbox[0].body)\n        self.assertIn(\"Radio buttons: \", mail.outbox[0].body)\n        self.assertIn(\"Date: \", mail.outbox[0].body)\n        self.assertIn(\"Datetime: \", mail.outbox[0].body)\n\n    def test_email_field_order(self):\n        self.client.post('/contact-us/', {})\n\n        line_beginnings = [\n            \"Single line text: \",\n            \"Multiline: \",\n            \"Email: \",\n            \"Number: \",\n            \"URL: \",\n            \"Checkbox: \",\n            \"Checkboxes: \",\n            \"Drop down: \",\n            \"Multiple select: \",\n            \"Radio buttons: \",\n            \"Date: \",\n            \"Datetime: \",\n        ]\n\n        # Check the email\n        self.assertEqual(len(mail.outbox), 1)\n        email_lines = mail.outbox[0].body.split('\\n')\n\n        for beginning in line_beginnings:\n            message_line = email_lines.pop(0)\n            self.assertTrue(message_line.startswith(beginning))\n\n    @override_settings(SHORT_DATE_FORMAT='m/d/Y')\n    def test_date_normalization(self):\n        self.client.post('/contact-us/', {\n            'date': '12/31/17',\n        })\n\n        # Check the email\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertIn(\"Date: 12/31/2017\", mail.outbox[0].body)\n\n        self.client.post('/contact-us/', {\n            'date': '12/31/1917',\n        })\n\n        # Check the email\n        self.assertEqual(len(mail.outbox), 2)\n        self.assertIn(\"Date: 12/31/1917\", mail.outbox[1].body)\n\n\n    @override_settings(SHORT_DATETIME_FORMAT='m/d/Y P')\n    def test_datetime_normalization(self):\n        self.client.post('/contact-us/', {\n            'datetime': '12/31/17 4:00:00',\n        })\n\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertIn(\"Datetime: 12/31/2017 4 a.m.\", mail.outbox[0].body)\n\n        self.client.post('/contact-us/', {\n            'datetime': '12/31/1917 21:19',\n        })\n\n        self.assertEqual(len(mail.outbox), 2)\n        self.assertIn(\"Datetime: 12/31/1917 9:19 p.m.\", mail.outbox[1].body)\n\n        self.client.post('/contact-us/', {\n            'datetime': '1910-12-21 21:19:12',\n        })\n\n        self.assertEqual(len(mail.outbox), 3)\n        self.assertIn(\"Datetime: 12/21/1910 9:19 p.m.\", mail.outbox[2].body)\n\n\n\nclass TestIssue798(TestCase):\n    fixtures = ['test.json']\n\n    def setUp(self):\n        self.assertTrue(self.client.login(username='siteeditor', password='password'))\n        self.form_page = Page.objects.get(url_path='/home/contact-us/').specific\n\n        # Add a number field to the page\n        FormField.objects.create(\n            page=self.form_page,\n            label=\"Your favourite number\",\n            field_type='number',\n        )\n\n    def test_post(self):\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': 'hello world',\n            'your_choices': {'foo': '', 'bar': '', 'baz': ''},\n            'your_favourite_number': '7.3',\n        })\n\n        # Check response\n        self.assertTemplateUsed(response, 'tests/form_page_landing.html')\n\n        # Check that form submission was saved correctly\n        self.assertTrue(FormSubmission.objects.filter(page=self.form_page, form_data__contains='hello world').exists())\n        self.assertTrue(FormSubmission.objects.filter(page=self.form_page, form_data__contains='7.3').exists())\n\n\nclass TestNonHtmlExtension(TestCase):\n    fixtures = ['test.json']\n\n    def test_non_html_extension(self):\n        form_page = JadeFormPage(title=\"test\")\n        self.assertEqual(form_page.landing_page_template, \"tests/form_page_landing.jade\")\n\n\nclass TestLegacyFormFieldCleanNameChecks(TestCase):\n    fixtures = ['test.json']\n\n    def setUp(self):\n        self.assertTrue(self.client.login(username='siteeditor', password='password'))\n        self.form_page = Page.objects.get(url_path='/home/contact-us-one-more-time/').specific\n\n\n    def test_form_field_clean_name_update_on_checks(self):\n\n        fields_before_checks = [\n            (field.label, field.clean_name,)\n            for field in FormFieldWithCustomSubmission.objects.all()\n        ]\n\n        self.assertEqual(fields_before_checks, [\n            ('Your email', ''),\n            ('Your message', ''),\n            ('Your choices', ''),\n        ])\n\n        # running checks should show an info message AND update blank clean_name values\n\n        messages = FormFieldWithCustomSubmission.check()\n\n        self.assertEqual(\n            messages,\n            [Info('Added `clean_name` on 3 form field(s)', obj=FormFieldWithCustomSubmission)]\n        )\n\n\n        fields_after_checks = [\n            (field.label, field.clean_name,)\n            for field in FormFieldWithCustomSubmission.objects.all()\n        ]\n\n        self.assertEqual(fields_after_checks, [\n            ('Your email', 'your-email'),  # kebab case, legacy format\n            ('Your message', 'your-message'),\n            ('Your choices', 'your-choices'),\n        ])\n\n        # running checks again should return no messages as fields no longer need changing\n        self.assertEqual(FormFieldWithCustomSubmission.check(), [])\n\n        # creating a new field should use the non-legacy clean_name format\n\n        field = FormFieldWithCustomSubmission.objects.create(\n            page=self.form_page,\n            label=\"Your FAVOURITE #number\",\n            field_type='number',\n        )\n\n        self.assertEqual(field.clean_name, 'your_favourite_number')\n", "# -*- coding: utf-8 -*-\nfrom wagtail.core.models import Page\nfrom wagtail.tests.testapp.models import (\n    FormField, FormFieldWithCustomSubmission, FormPage, FormPageWithCustomSubmission,\n    FormPageWithRedirect, RedirectFormField)\n\n\ndef make_form_page(**kwargs):\n    kwargs.setdefault('title', \"Contact us\")\n    kwargs.setdefault('slug', \"contact-us\")\n    kwargs.setdefault('to_address', \"to@email.com\")\n    kwargs.setdefault('from_address', \"from@email.com\")\n    kwargs.setdefault('subject', \"The subject\")\n\n    home_page = Page.objects.get(url_path='/home/')\n    form_page = home_page.add_child(instance=FormPage(**kwargs))\n\n    FormField.objects.create(\n        page=form_page,\n        sort_order=1,\n        label=\"Your email\",\n        field_type='email',\n        required=True,\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=2,\n        label=\"Your message\",\n        field_type='multiline',\n        required=True,\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=3,\n        label=\"Your choices\",\n        field_type='checkboxes',\n        required=False,\n        choices='foo,bar,baz',\n    )\n\n    return form_page\n\n\ndef make_form_page_with_custom_submission(**kwargs):\n    kwargs.setdefault('title', \"Contact us\")\n    kwargs.setdefault('intro', \"<p>Boring intro text</p>\")\n    kwargs.setdefault('thank_you_text', \"<p>Thank you for your patience!</p>\")\n    kwargs.setdefault('slug', \"contact-us\")\n    kwargs.setdefault('to_address', \"to@email.com\")\n    kwargs.setdefault('from_address', \"from@email.com\")\n    kwargs.setdefault('subject', \"The subject\")\n\n    home_page = Page.objects.get(url_path='/home/')\n    form_page = home_page.add_child(instance=FormPageWithCustomSubmission(**kwargs))\n\n    FormFieldWithCustomSubmission.objects.create(\n        page=form_page,\n        sort_order=1,\n        label=\"Your email\",\n        field_type='email',\n        required=True,\n    )\n    FormFieldWithCustomSubmission.objects.create(\n        page=form_page,\n        sort_order=2,\n        label=\"Your message\",\n        field_type='multiline',\n        required=True,\n    )\n    FormFieldWithCustomSubmission.objects.create(\n        page=form_page,\n        sort_order=3,\n        label=\"Your choices\",\n        field_type='checkboxes',\n        required=False,\n        choices='foo,bar,baz',\n    )\n\n    return form_page\n\n\ndef make_form_page_with_redirect(**kwargs):\n    kwargs.setdefault('title', \"Contact us\")\n    kwargs.setdefault('slug', \"contact-us\")\n    kwargs.setdefault('to_address', \"to@email.com\")\n    kwargs.setdefault('from_address', \"from@email.com\")\n    kwargs.setdefault('subject', \"The subject\")\n\n\n    home_page = Page.objects.get(url_path='/home/')\n    kwargs.setdefault('thank_you_redirect_page', home_page)\n    form_page = home_page.add_child(instance=FormPageWithRedirect(**kwargs))\n    # form_page.thank_you_redirect_page = home_page\n\n    RedirectFormField.objects.create(\n        page=form_page,\n        sort_order=1,\n        label=\"Your email\",\n        field_type='email',\n        required=True,\n    )\n    RedirectFormField.objects.create(\n        page=form_page,\n        sort_order=2,\n        label=\"Your message\",\n        field_type='multiline',\n        required=True,\n    )\n    RedirectFormField.objects.create(\n        page=form_page,\n        sort_order=3,\n        label=\"Your choices\",\n        field_type='checkboxes',\n        required=False,\n        choices='foo,bar,baz',\n    )\n\n    return form_page\n\n\ndef make_types_test_form_page(**kwargs):\n    kwargs.setdefault('title', \"Contact us\")\n    kwargs.setdefault('slug', \"contact-us\")\n    kwargs.setdefault('to_address', \"to@email.com\")\n    kwargs.setdefault('from_address', \"from@email.com\")\n    kwargs.setdefault('subject', \"The subject\")\n\n    home_page = Page.objects.get(url_path='/home/')\n    form_page = home_page.add_child(instance=FormPage(**kwargs))\n\n    FormField.objects.create(\n        page=form_page,\n        sort_order=1,\n        label=\"Single line text\",\n        field_type='singleline',\n        required=False,\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=2,\n        label=\"Multiline\",\n        field_type='multiline',\n        required=False,\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=3,\n        label=\"Email\",\n        field_type='email',\n        required=False,\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=4,\n        label=\"Number\",\n        field_type='number',\n        required=False,\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=5,\n        label=\"URL\",\n        field_type='url',\n        required=False,\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=6,\n        label=\"Checkbox\",\n        field_type='checkbox',\n        required=False,\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=7,\n        label=\"Checkboxes\",\n        field_type='checkboxes',\n        required=False,\n        choices='foo,bar,baz',\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=8,\n        label=\"Drop down\",\n        field_type='dropdown',\n        required=False,\n        choices='spam,ham,eggs',\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=9,\n        label=\"Multiple select\",\n        field_type='multiselect',\n        required=False,\n        choices='qux,quux,quuz,corge',\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=10,\n        label=\"Radio buttons\",\n        field_type='radio',\n        required=False,\n        choices='wibble,wobble,wubble',\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=11,\n        label=\"Date\",\n        field_type='date',\n        required=False,\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=12,\n        label=\"Datetime\",\n        field_type='datetime',\n        required=False,\n    )\n\n    return form_page\n"], "fixing_code": ["========\nSettings\n========\n\nWagtail makes use of the following settings, in addition to :doc:`Django's core settings <ref/settings>`:\n\nSite Name\n=========\n\n.. code-block:: python\n\n  WAGTAIL_SITE_NAME = 'Stark Industries Skunkworks'\n\nThis is the human-readable name of your Wagtail install which welcomes users upon login to the Wagtail admin.\n\n.. _append_slash:\n\nAppend Slash\n============\n\n.. code-block:: python\n\n  # Don't add a trailing slash to Wagtail-served URLs\n  WAGTAIL_APPEND_SLASH = False\n\nSimilar to Django's ``APPEND_SLASH``, this setting controls how Wagtail will handle requests that don't end in a trailing slash.\n\nWhen ``WAGTAIL_APPEND_SLASH`` is ``True`` (default), requests to Wagtail pages which omit a trailing slash will be redirected by Django's :class:`~django.middleware.common.CommonMiddleware` to a URL with a trailing slash.\n\nWhen ``WAGTAIL_APPEND_SLASH`` is ``False``, requests to Wagtail pages will be served both with and without trailing slashes. Page links generated by Wagtail, however, will not include trailing slashes.\n\n.. note::\n\n  If you use the ``False`` setting, keep in mind that serving your pages both with and without slashes may affect search engines' ability to index your site. See `this Google Webmaster Blog post`_ for more details.\n\n.. _this Google Webmaster Blog post: https://webmasters.googleblog.com/2010/04/to-slash-or-not-to-slash.html\n\nSearch\n======\n\n.. code-block:: python\n\n  WAGTAILSEARCH_BACKENDS = {\n      'default': {\n          'BACKEND': 'wagtail.search.backends.elasticsearch2',\n          'INDEX': 'myapp'\n      }\n  }\n\nDefine a search backend. For a full explanation, see :ref:`wagtailsearch_backends`.\n\n.. code-block:: python\n\n  WAGTAILSEARCH_RESULTS_TEMPLATE = 'myapp/search_results.html'\n  WAGTAILSEARCH_RESULTS_TEMPLATE_AJAX = 'myapp/includes/search_listing.html'\n\nOverride the templates used by the search front-end views.\n\n.. _wagtailsearch_hits_max_age:\n\n.. code-block:: python\n\n  WAGTAILSEARCH_HITS_MAX_AGE = 14\n\nSet the number of days (default 7) that search query logs are kept for; these are used to identify popular search terms for :ref:`promoted search results <editors-picks>`. Queries older than this will be removed by the :ref:`search_garbage_collect` command.\n\nEmbeds\n======\n\nWagtail supports generating embed code from URLs to content on an external\nproviders such as Youtube or Twitter. By default, Wagtail will fetch the embed\ncode directly from the relevant provider's site using the oEmbed protocol.\nWagtail has a builtin list of the most common providers.\n\nThe embeds fetching can be fully configured using the ``WAGTAILEMBEDS_FINDERS``\nsetting. This is fully documented in :ref:`configuring_embed_finders`.\n\n.. code-block:: python\n\n    WAGTAILEMBEDS_RESPONSIVE_HTML = True\n\nAdds ``class=\"responsive-object\"`` and an inline ``padding-bottom`` style to embeds,\nto assist in making them responsive. See :ref:`responsive-embeds` for details.\n\nDashboard\n=========\n\n.. code-block:: python\n\n    WAGTAILADMIN_RECENT_EDITS_LIMIT = 5\n\nThis setting lets you change the number of items shown at 'Your most recent edits' on the dashboard.\n\n\n.. code-block:: python\n\n  WAGTAILADMIN_USER_LOGIN_FORM = 'users.forms.LoginForm'\n\nAllows the default ``LoginForm`` to be extended with extra fields.\n\n\n.. _wagtail_gravatar_provider_url:\n\n.. code-block:: python\n\n  WAGTAIL_GRAVATAR_PROVIDER_URL = '//www.gravatar.com/avatar'\n\nIf a user has not uploaded a profile picture, Wagtail will look for an avatar linked to their email address on gravatar.com. This setting allows you to specify an alternative provider such as like robohash.org, or can be set to ``None`` to disable the use of remote avatars completely.\n\n.. _wagtail_moderation_enabled:\n\n.. code-block:: python\n\n  WAGTAIL_MODERATION_ENABLED = True\n\nChanges whether the Submit for Moderation button is displayed in the action menu.\n\nImages\n======\n\n.. code-block:: python\n\n  WAGTAILIMAGES_IMAGE_MODEL = 'myapp.MyImage'\n\nThis setting lets you provide your own image model for use in Wagtail, which might extend the built-in ``AbstractImage`` class or replace it entirely.\n\n\n.. code-block:: python\n\n    WAGTAILIMAGES_MAX_UPLOAD_SIZE = 20 * 1024 * 1024  # i.e. 20MB\n\nThis setting lets you override the maximum upload size for images (in bytes). If omitted, Wagtail will fall back to using its 10MB default value.\n\n.. code-block:: python\n\n    WAGTAILIMAGES_MAX_IMAGE_PIXELS = 128000000  # i.e. 128 megapixels\n\nThis setting lets you override the maximum number of pixels an image can have. If omitted, Wagtail will fall back to using its 128 megapixels default value. The pixel count takes animation frames into account - for example, a 25-frame animation of size 100x100 is considered to have 100 * 100 * 25 = 250000 pixels.\n\n.. code-block:: python\n\n    WAGTAILIMAGES_FEATURE_DETECTION_ENABLED = True\n\nThis setting enables feature detection once OpenCV is installed, see all details on the :ref:`image_feature_detection` documentation.\n\n.. code-block:: python\n\n    WAGTAILIMAGES_INDEX_PAGE_SIZE = 20\n\nSpecifies the number of images per page shown on the main Images listing in the Wagtail admin.\n\n.. code-block:: python\n\n    WAGTAILIMAGES_USAGE_PAGE_SIZE = 20\n\nSpecifies the number of items per page shown when viewing an image's usage (see :ref:`WAGTAIL_USAGE_COUNT_ENABLED <WAGTAIL_USAGE_COUNT_ENABLED>`).\n\n.. code-block:: python\n\n    WAGTAILIMAGES_CHOOSER_PAGE_SIZE = 12\n\nSpecifies the number of images shown per page in the image chooser modal.\n\nDocuments\n=========\n\n.. _wagtaildocs_serve_method:\n\n.. code-block:: python\n\n  WAGTAILDOCS_SERVE_METHOD = 'redirect'\n\nDetermines how document downloads will be linked to and served. Normally, requests for documents are sent through a Django view, to perform permission checks (see :ref:`image_document_permissions`) and potentially other housekeeping tasks such as hit counting. To fully protect against users bypassing this check, it needs to happen in the same request where the document is served; however, this incurs a performance hit as the document then needs to be served by the Django server. In particular, this cancels out much of the benefit of hosting documents on external storage, such as S3 or a CDN.\n\nFor this reason, Wagtail provides a number of serving methods which trade some of the strictness of the permission check for performance:\n\n * ``'direct'`` - links to documents point directly to the URL provided by the underlying storage, bypassing the Django view that provides the permission check. This is most useful when deploying sites as fully static HTML (e.g. using `wagtail-bakery <https://github.com/wagtail/wagtail-bakery>`_ or `Gatsby <https://www.gatsbyjs.org/>`_).\n * ``'redirect'`` - links to documents point to a Django view which will check the user's permission; if successful, it will redirect to the URL provided by the underlying storage to allow the document to be downloaded. This is most suitable for remote storage backends such as S3, as it allows the document to be served independently of the Django server. Note that if a user is able to guess the latter URL, they will be able to bypass the permission check; some storage backends may provide configuration options to generate a random or short-lived URL to mitigate this.\n * ``'serve_view'`` - links to documents point to a Django view which both checks the user's permission, and serves the document. Serving will be handled by `django-sendfile <https://github.com/johnsensible/django-sendfile>`_, if this is installed and supported by your server configuration, or as a streaming response from Django if not. When using this method, it is recommended that you configure your webserver to *disallow* serving documents directly from their location under ``MEDIA_ROOT``, as this would provide a way to bypass the permission check.\n\nIf ``WAGTAILDOCS_SERVE_METHOD`` is unspecified or set to ``None``, the default method is ``'redirect'`` when a remote storage backend is in use (i.e. one that exposes a URL but not a local filesystem path), and ``'serve_view'`` otherwise. Finally, some storage backends may not expose a URL at all; in this case, serving will proceed as for ``'serve_view'``.\n\nPassword Management\n===================\n\n.. code-block:: python\n\n  WAGTAIL_PASSWORD_MANAGEMENT_ENABLED = True\n\nThis specifies whether users are allowed to change their passwords (enabled by default).\n\n.. code-block:: python\n\n  WAGTAIL_PASSWORD_RESET_ENABLED = True\n\nThis specifies whether users are allowed to reset their passwords. Defaults to the same as ``WAGTAIL_PASSWORD_MANAGEMENT_ENABLED``. Password reset emails will be sent from the address specified in Django's ``DEFAULT_FROM_EMAIL`` setting.\n\n.. code-block:: python\n\n  WAGTAILUSERS_PASSWORD_ENABLED = True\n\nThis specifies whether password fields are shown when creating or editing users through Settings -> Users (enabled by default). Set this to False (along with ``WAGTAIL_PASSWORD_MANAGEMENT_ENABLED`` and ``WAGTAIL_PASSWORD_RESET_ENABLED``) if your users are authenticated through an external system such as LDAP.\n\n.. code-block:: python\n\n  WAGTAILUSERS_PASSWORD_REQUIRED = True\n\nThis specifies whether password is a required field when creating a new user. True by default; ignored if ``WAGTAILUSERS_PASSWORD_ENABLED`` is false. If this is set to False, and the password field is left blank when creating a user, then that user will have no usable password; in order to log in, they will have to reset their password (if ``WAGTAIL_PASSWORD_RESET_ENABLED`` is True) or use an alternative authentication system such as LDAP (if one is set up).\n\n.. code-block:: python\n\n  WAGTAIL_EMAIL_MANAGEMENT_ENABLED = True\n\nThis specifies whether users are allowed to change their email (enabled by default).\n\n.. _email_notifications:\n\nEmail Notifications\n===================\n\n.. code-block:: python\n\n  WAGTAILADMIN_NOTIFICATION_FROM_EMAIL = 'wagtail@myhost.io'\n\nWagtail sends email notifications when content is submitted for moderation, and when the content is accepted or rejected. This setting lets you pick which email address these automatic notifications will come from. If omitted, Wagtail will fall back to using Django's ``DEFAULT_FROM_EMAIL`` setting if set, or ``webmaster@localhost`` if not.\n\n.. code-block:: python\n\n  WAGTAILADMIN_NOTIFICATION_USE_HTML = True\n\nNotification emails are sent in `text/plain` by default, change this to use HTML formatting.\n\n.. code-block:: python\n\n  WAGTAILADMIN_NOTIFICATION_INCLUDE_SUPERUSERS = False\n\nNotification emails are sent to moderators and superusers by default. You can change this to exclude superusers and only notify moderators.\n\n.. _update_notifications:\n\nWagtail update notifications\n============================\n\n.. code-block:: python\n\n  WAGTAIL_ENABLE_UPDATE_CHECK = True\n\nFor admins only, Wagtail performs a check on the dashboard to see if newer releases are available. This also provides the Wagtail team with the hostname of your Wagtail site. If you'd rather not receive update notifications, or if you'd like your site to remain unknown, you can disable it with this setting.\n\n\nPrivate pages / documents\n=========================\n\n.. code-block:: python\n\n  PASSWORD_REQUIRED_TEMPLATE = 'myapp/password_required.html'\n\nThis is the path to the Django template which will be used to display the \"password required\" form when a user accesses a private page. For more details, see the :ref:`private_pages` documentation.\n\n.. code-block:: python\n\n  DOCUMENT_PASSWORD_REQUIRED_TEMPLATE = 'myapp/document_password_required.html'\n\nAs above, but for password restrictions on documents. For more details, see the :ref:`private_pages` documentation.\n\nLogin page\n==========\n\nThe basic login page can be customised with a custom template.\n\n.. code-block:: python\n\n  WAGTAIL_FRONTEND_LOGIN_TEMPLATE = 'myapp/login.html'\n\nOr the login page can be a redirect to an external or internal URL.\n\n.. code-block:: python\n\n  WAGTAIL_FRONTEND_LOGIN_URL = '/accounts/login/'\n\nFor more details, see the :ref:`login_page` documentation.\n\nCase-Insensitive Tags\n=====================\n\n.. code-block:: python\n\n  TAGGIT_CASE_INSENSITIVE = True\n\nTags are case-sensitive by default ('music' and 'Music' are treated as distinct tags). In many cases the reverse behaviour is preferable.\n\nMulti-word tags\n===============\n\n.. code-block:: python\n\n  TAG_SPACES_ALLOWED = False\n\nTags can only consist of a single word, no spaces allowed. The default setting is ``True`` (spaces in tags are allowed).\n\nTag limit\n=========\n\n.. code-block:: python\n\n  TAG_LIMIT = 5\n\nLimit the number of tags that can be added to (django-taggit) Tag model. Default setting is ``None``, meaning no limit on tags.\n\nUnicode Page Slugs\n==================\n\n.. code-block:: python\n\n  WAGTAIL_ALLOW_UNICODE_SLUGS = True\n\nBy default, page slugs can contain any alphanumeric characters, including non-Latin alphabets. Set this to False to limit slugs to ASCII characters.\n\n.. _WAGTAIL_AUTO_UPDATE_PREVIEW:\n\nAuto update preview\n===================\n\n.. code-block:: python\n\n  WAGTAIL_AUTO_UPDATE_PREVIEW = False\n\nWhen enabled, data from an edited page is automatically sent to the server\non each change, even without saving. That way, users don\u2019t have to click on\n\u201cPreview\u201d to update the content of the preview page. However, the preview page\ntab is not refreshed automatically, users have to do it manually.\nThis behaviour is disabled by default.\n\nCustom User Edit Forms\n======================\n\nSee :doc:`/advanced_topics/customisation/custom_user_models`.\n\n.. code-block:: python\n\n  WAGTAIL_USER_EDIT_FORM = 'users.forms.CustomUserEditForm'\n\nAllows the default ``UserEditForm`` class to be overridden with a custom form when\na custom user model is being used and extra fields are required in the user edit form.\n\n.. code-block:: python\n\n  WAGTAIL_USER_CREATION_FORM = 'users.forms.CustomUserCreationForm'\n\nAllows the default ``UserCreationForm`` class to be overridden with a custom form when\na custom user model is being used and extra fields are required in the user creation form.\n\n.. code-block:: python\n\n  WAGTAIL_USER_CUSTOM_FIELDS = ['country']\n\nA list of the extra custom fields to be appended to the default list.\n\n.. _WAGTAIL_USAGE_COUNT_ENABLED:\n\nUsage for images, documents and snippets\n========================================\n\n.. code-block:: python\n\n    WAGTAIL_USAGE_COUNT_ENABLED = True\n\nWhen enabled Wagtail shows where a particular image, document or snippet is being used on your site.\nThis is disabled by default because it generates a query which may run slowly on sites with large numbers of pages.\n\nA link will appear on the edit page (in the rightmost column) showing you how many times the item is used.\nClicking this link takes you to the \"Usage\" page, which shows you where the snippet, document or image is used.\n\nThe link is also shown on the delete page, above the \"Delete\" button.\n\n.. note::\n\n    The usage count only applies to direct (database) references. Using documents, images and snippets within StreamFields or rich text fields will not be taken into account.\n\nDate and DateTime inputs\n========================\n\n.. code-block:: python\n\n    WAGTAIL_DATE_FORMAT = '%d.%m.%Y.'\n    WAGTAIL_DATETIME_FORMAT = '%d.%m.%Y. %H:%M'\n    WAGTAIL_TIME_FORMAT = '%H:%M'\n\n\nSpecifies the date, time and datetime format to be used in input fields in the Wagtail admin. The format is specified in `Python datetime module syntax <https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior>`_, and must be one of the recognised formats listed in the ``DATE_INPUT_FORMATS``, ``TIME_INPUT_FORMATS``, or ``DATETIME_INPUT_FORMATS`` setting respectively (see `DATE_INPUT_FORMATS <https://docs.djangoproject.com/en/stable/ref/settings/#std:setting-DATE_INPUT_FORMATS>`_).\n\n.. _WAGTAIL_USER_TIME_ZONES:\n\nTime zones\n==========\n\nLogged-in users can choose their current time zone for the admin interface in the account settings.  If is no time zone selected by the user, then ``TIME_ZONE`` will be used.\n(Note that time zones are only applied to datetime fields, not to plain time or date fields.  This is a Django design decision.)\n\nThe list of time zones is by default the common_timezones list from pytz.\nIt is possible to override this list via the ``WAGTAIL_USER_TIME_ZONES`` setting.\nIf there is zero or one time zone permitted, the account settings form will be hidden.\n\n.. code-block:: python\n\n    WAGTAIL_USER_TIME_ZONES = ['America/Chicago', 'Australia/Sydney', 'Europe/Rome']\n\n.. _WAGTAILADMIN_PERMITTED_LANGUAGES:\n\nAdmin languages\n===============\n\nUsers can choose between several languages for the admin interface\nin the account settings. The list of languages is by default all the available\nlanguages in Wagtail with at least 90% coverage. To change it, set ``WAGTAILADMIN_PERMITTED_LANGUAGES``:\n\n.. code-block:: python\n\n    WAGTAILADMIN_PERMITTED_LANGUAGES = [('en', 'English'),\n                                        ('pt', 'Portuguese')]\n\nSince the syntax is the same as Django ``LANGUAGES``, you can do this so users\ncan only choose between front office languages:\n\n.. code-block:: python\n\n    LANGUAGES = WAGTAILADMIN_PERMITTED_LANGUAGES = [('en', 'English'),\n                                                    ('pt', 'Portuguese')]\n\nStatic files\n============\n\n.. code-block:: python\n\n    WAGTAILADMIN_STATIC_FILE_VERSION_STRINGS = False\n\nStatic file URLs within the Wagtail admin are given a version-specific query string of the form ``?v=1a2b3c4d``, to prevent outdated cached copies of Javascript and CSS files from persisting after a Wagtail upgrade. To disable these, set ``WAGTAILADMIN_STATIC_FILE_VERSION_STRINGS`` to ``False``.\n\nAPI Settings\n============\n\nFor full documenation on API configuration, including these settings, see :ref:`api_v2_configuration` documentation.\n\n.. code-block:: python\n\n    WAGTAILAPI_BASE_URL = 'http://api.example.com/'\n\nRequired when using frontend cache invalidation, used to generate absolute URLs to document files and invalidating the cache.\n\n\n.. code-block:: python\n\n    WAGTAILAPI_LIMIT_MAX = 500\n\nDefault is 20, used to change the maximum number of results a user can request at a time, set to ``None`` for no limit.\n\n\n.. code-block:: python\n\n    WAGTAILAPI_SEARCH_ENABLED = False\n\nDefault is true, setting this to false will disable full text search on all endpoints.\n\n.. code-block:: python\n\n    WAGTAILAPI_USE_FRONTENDCACHE = True\n\nRequires ``wagtailfrontendcache`` app to be installed, inidicates the API should use the frontend cache.\n\nFrontend cache\n==============\n\nFor full documenation on frontend cache invalidation, including these settings, see :ref:`frontend_cache_purging`.\n\n\n.. code-block:: python\n\n    WAGTAILFRONTENDCACHE = {\n        'varnish': {\n            'BACKEND': 'wagtail.contrib.frontend_cache.backends.HTTPBackend',\n            'LOCATION': 'http://localhost:8000',\n        },\n    }\n\nSee documentation linked above for full options available.\n\n.. note::\n\n    ``WAGTAILFRONTENDCACHE_LOCATION`` is no longer the preferred way to set the cache location, instead set the ``LOCATION`` within the ``WAGTAILFRONTENDCACHE`` item.\n\n\n.. code-block:: python\n\n    WAGTAILFRONTENDCACHE_LANGUAGES = [l[0] for l in settings.LANGUAGES]\n\nDefault is an empty list, must be a list of languages to also purge the urls for each language of a purging url. This setting needs ``settings.USE_I18N`` to be ``True`` to work.\n\n.. _WAGTAILADMIN_RICH_TEXT_EDITORS:\n\nRich text\n=========\n\n.. code-block:: python\n\n    WAGTAILADMIN_RICH_TEXT_EDITORS = {\n        'default': {\n            'WIDGET': 'wagtail.admin.rich_text.DraftailRichTextArea',\n            'OPTIONS': {\n                'features': ['h2', 'bold', 'italic', 'link', 'document-link']\n            }\n        },\n        'legacy': {\n            'WIDGET': 'wagtail.admin.rich_text.HalloRichTextArea',\n        }\n    }\n\nCustomise the behaviour of rich text fields. By default, ``RichTextField`` and ``RichTextBlock`` use the configuration given under the ``'default'`` key, but this can be overridden on a per-field basis through the ``editor`` keyword argument, e.g. ``body = RichTextField(editor='legacy')``. Within each configuration block, the following fields are recognised:\n\n * ``WIDGET``: The rich text widget implementation to use. Wagtail provides two implementations: ``wagtail.admin.rich_text.DraftailRichTextArea`` (a modern extensible editor which enforces well-structured markup) and ``wagtail.admin.rich_text.HalloRichTextArea`` (deprecated; works directly at the HTML level). Other widgets may be provided by third-party packages.\n\n * ``OPTIONS``: Configuration options to pass to the widget. Recognised options are widget-specific, but both ``DraftailRichTextArea`` and ``HalloRichTextArea`` accept a ``features`` list indicating the active rich text features (see :ref:`rich_text_features`).\n\nIf a ``'default'`` editor is not specified, rich text fields that do not specify an ``editor`` argument will use the Draftail editor with the default feature set enabled.\n\n.. versionchanged:: 2.10\n\n    Omitting the ``'default'`` editor now leaves the original default editor intact, so it is no longer necessary to redefine ``'default'`` when adding alternative editors.\n\n\n.. _WAGTAILADMIN_GLOBAL_PAGE_EDIT_LOCK:\n\nPage locking\n============\n\n``WAGTAILADMIN_GLOBAL_PAGE_EDIT_LOCK`` can be set to ``True`` to prevent users\nfrom editing pages that they have locked.\n\nRedirects\n=========\n\n.. code-block:: python\n\n   WAGTAIL_REDIRECTS_FILE_STORAGE = 'tmp_file'\n\nBy default the redirect importer keeps track of the uploaded file as a temp file, but on certain environments (load balanced/cloud environments), you cannot keep a shared file between environments. For those cases you can use the built-in cache to store the file instead.\n\n.. code-block:: python\n\n   WAGTAIL_REDIRECTS_FILE_STORAGE = 'cache'\n\nForm builder\n============\n\n.. versionadded:: 2.7.4/2.9.3\n\n    The ``WAGTAILFORMS_HELP_TEXT_ALLOW_HTML`` option was added.\n\n.. code-block:: python\n\n    WAGTAILFORMS_HELP_TEXT_ALLOW_HTML = True\n\nWhen true, HTML tags in form field help text will be rendered unescaped (default: False).\n", "from collections import OrderedDict\n\nimport django.forms\nfrom django.conf import settings\nfrom django.utils.html import conditional_escape\nfrom django.utils.translation import gettext_lazy as _\n\nfrom wagtail.admin.forms import WagtailAdminPageForm\nfrom wagtail.contrib.forms.utils import get_field_clean_name\n\n\nclass BaseForm(django.forms.Form):\n    def __init__(self, *args, **kwargs):\n        kwargs.setdefault('label_suffix', '')\n\n        self.user = kwargs.pop('user', None)\n        self.page = kwargs.pop('page', None)\n\n        super().__init__(*args, **kwargs)\n\n\nclass FormBuilder:\n    def __init__(self, fields):\n        self.fields = fields\n\n    def create_singleline_field(self, field, options):\n        # TODO: This is a default value - it may need to be changed\n        options['max_length'] = 255\n        return django.forms.CharField(**options)\n\n    def create_multiline_field(self, field, options):\n        return django.forms.CharField(widget=django.forms.Textarea, **options)\n\n    def create_date_field(self, field, options):\n        return django.forms.DateField(**options)\n\n    def create_datetime_field(self, field, options):\n        return django.forms.DateTimeField(**options)\n\n    def create_email_field(self, field, options):\n        return django.forms.EmailField(**options)\n\n    def create_url_field(self, field, options):\n        return django.forms.URLField(**options)\n\n    def create_number_field(self, field, options):\n        return django.forms.DecimalField(**options)\n\n    def create_dropdown_field(self, field, options):\n        options['choices'] = map(\n            lambda x: (x.strip(), x.strip()),\n            field.choices.split(',')\n        )\n        return django.forms.ChoiceField(**options)\n\n    def create_multiselect_field(self, field, options):\n        options['choices'] = map(\n            lambda x: (x.strip(), x.strip()),\n            field.choices.split(',')\n        )\n        return django.forms.MultipleChoiceField(**options)\n\n    def create_radio_field(self, field, options):\n        options['choices'] = map(\n            lambda x: (x.strip(), x.strip()),\n            field.choices.split(',')\n        )\n        return django.forms.ChoiceField(widget=django.forms.RadioSelect, **options)\n\n    def create_checkboxes_field(self, field, options):\n        options['choices'] = [(x.strip(), x.strip()) for x in field.choices.split(',')]\n        options['initial'] = [x.strip() for x in field.default_value.split(',')]\n        return django.forms.MultipleChoiceField(\n            widget=django.forms.CheckboxSelectMultiple, **options\n        )\n\n    def create_checkbox_field(self, field, options):\n        return django.forms.BooleanField(**options)\n\n    def create_hidden_field(self, field, options):\n        return django.forms.CharField(widget=django.forms.HiddenInput, **options)\n\n    def get_create_field_function(self, type):\n        \"\"\"\n            Takes string of field type and returns a Django Form Field Instance.\n            Assumes form field creation functions are in the format:\n            'create_fieldtype_field'\n        \"\"\"\n        create_field_function = getattr(self, 'create_%s_field' % type, None)\n        if create_field_function:\n            return create_field_function\n        else:\n            import inspect\n            method_list = [\n                f[0] for f in\n                inspect.getmembers(self.__class__, inspect.isfunction)\n                if f[0].startswith('create_') and f[0].endswith('_field')\n            ]\n            raise AttributeError(\n                \"Could not find function matching format \\\n                create_<fieldname>_field for type: \" + type,\n                \"Must be one of: \" + \", \".join(method_list)\n            )\n\n    @property\n    def formfields(self):\n        formfields = OrderedDict()\n\n        for field in self.fields:\n            options = self.get_field_options(field)\n            create_field = self.get_create_field_function(field.field_type)\n            formfields[field.clean_name] = create_field(field, options)\n\n        return formfields\n\n    def get_field_options(self, field):\n        options = {}\n        options['label'] = field.label\n        if getattr(settings, 'WAGTAILFORMS_HELP_TEXT_ALLOW_HTML', False):\n            options['help_text'] = field.help_text\n        else:\n            options['help_text'] = conditional_escape(field.help_text)\n        options['required'] = field.required\n        options['initial'] = field.default_value\n        return options\n\n    def get_form_class(self):\n        return type(str('WagtailForm'), (BaseForm,), self.formfields)\n\n\nclass SelectDateForm(django.forms.Form):\n    date_from = django.forms.DateTimeField(\n        required=False,\n        widget=django.forms.DateInput(attrs={'placeholder': _('Date from')})\n    )\n    date_to = django.forms.DateTimeField(\n        required=False,\n        widget=django.forms.DateInput(attrs={'placeholder': _('Date to')})\n    )\n\n\nclass WagtailAdminFormPageForm(WagtailAdminPageForm):\n\n    def clean(self):\n\n        super().clean()\n\n        # Check for dupe form field labels - fixes #585\n        if 'form_fields' in self.formsets:\n            _forms = self.formsets['form_fields'].forms\n            for f in _forms:\n                f.is_valid()\n\n            for i, form in enumerate(_forms):\n                if 'label' in form.changed_data:\n                    label = form.cleaned_data.get('label')\n                    clean_name = get_field_clean_name(label)\n                    for idx, ff in enumerate(_forms):\n                        # Exclude self\n                        ff_clean_name = get_field_clean_name(ff.cleaned_data.get('label'))\n                        if idx != i and clean_name == ff_clean_name:\n                            form.add_error(\n                                'label',\n                                django.forms.ValidationError(_('There is another field with the label %s, please change one of them.' % label))\n                            )\n", "# -*- coding: utf-8 -*-\nimport json\n\nfrom django.core import mail\nfrom django.core.checks import Info\nfrom django.test import TestCase, override_settings\n\nfrom wagtail.contrib.forms.models import FormSubmission\nfrom wagtail.contrib.forms.tests.utils import (\n    make_form_page, make_form_page_with_custom_submission, make_form_page_with_redirect,\n    make_types_test_form_page)\nfrom wagtail.core.models import Page\nfrom wagtail.tests.testapp.models import (\n    CustomFormPageSubmission, ExtendedFormField, FormField, FormFieldWithCustomSubmission,\n    FormPageWithCustomFormBuilder, JadeFormPage)\nfrom wagtail.tests.utils import WagtailTestUtils\n\n\nclass TestFormSubmission(TestCase):\n    def setUp(self):\n        # Create a form page\n        self.form_page = make_form_page()\n\n    def test_get_form(self):\n        response = self.client.get('/contact-us/')\n\n        # Check response\n        self.assertContains(response, \"\"\"<label for=\"id_your_email\">Your email</label>\"\"\")\n        self.assertTemplateUsed(response, 'tests/form_page.html')\n        self.assertTemplateNotUsed(response, 'tests/form_page_landing.html')\n\n        # HTML in help text should be escaped\n        self.assertContains(response, \"&lt;em&gt;please&lt;/em&gt; be polite\")\n\n        # check that variables defined in get_context are passed through to the template (#1429)\n        self.assertContains(response, \"<p>hello world</p>\")\n\n    @override_settings(WAGTAILFORMS_HELP_TEXT_ALLOW_HTML=True)\n    def test_get_form_without_help_text_escaping(self):\n        response = self.client.get('/contact-us/')\n        # HTML in help text should not be escaped\n        self.assertContains(response, \"<em>please</em> be polite\")\n\n    def test_post_invalid_form(self):\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob',\n            'your_message': 'hello world',\n            'your_choices': ''\n        })\n\n        # Check response\n        self.assertContains(response, \"Enter a valid email address.\")\n        self.assertTemplateUsed(response, 'tests/form_page.html')\n        self.assertTemplateNotUsed(response, 'tests/form_page_landing.html')\n\n    def test_post_valid_form(self):\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': 'hello world',\n            'your_choices': {'foo': '', 'bar': '', 'baz': ''}\n        })\n\n        # Check response\n        self.assertContains(response, \"Thank you for your feedback.\")\n        self.assertTemplateNotUsed(response, 'tests/form_page.html')\n        self.assertTemplateUsed(response, 'tests/form_page_landing.html')\n\n        # check that variables defined in get_context are passed through to the template (#1429)\n        self.assertContains(response, \"<p>hello world</p>\")\n\n        # check the default form_submission is added to the context\n        self.assertContains(response, \"<li>your_email: bob@example.com</li>\")\n\n        # Check that an email was sent\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertEqual(mail.outbox[0].subject, \"The subject\")\n        self.assertIn(\"Your message: hello world\", mail.outbox[0].body)\n        self.assertEqual(mail.outbox[0].to, ['to@email.com'])\n        self.assertEqual(mail.outbox[0].from_email, 'from@email.com')\n\n        # Check that form submission was saved correctly\n        form_page = Page.objects.get(url_path='/home/contact-us/')\n        self.assertTrue(FormSubmission.objects.filter(page=form_page, form_data__contains='hello world').exists())\n\n    def test_post_unicode_characters(self):\n        self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': '\u3053\u3093\u306b\u3061\u306f\u3001\u4e16\u754c',\n            'your_choices': {'foo': '', 'bar': '', 'baz': ''}\n        })\n\n        # Check the email\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertIn(\"Your message: \u3053\u3093\u306b\u3061\u306f\u3001\u4e16\u754c\", mail.outbox[0].body)\n\n        # Check the form submission\n        submission = FormSubmission.objects.get()\n        submission_data = json.loads(submission.form_data)\n        self.assertEqual(submission_data['your_message'], '\u3053\u3093\u306b\u3061\u306f\u3001\u4e16\u754c')\n\n    def test_post_multiple_values(self):\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': 'hello world',\n            'your_choices': {'foo': 'on', 'bar': 'on', 'baz': 'on'}\n        })\n\n        # Check response\n        self.assertContains(response, \"Thank you for your feedback.\")\n        self.assertTemplateNotUsed(response, 'tests/form_page.html')\n        self.assertTemplateUsed(response, 'tests/form_page_landing.html')\n\n        # Check that the three checkbox values were saved correctly\n        form_page = Page.objects.get(url_path='/home/contact-us/')\n        submission = FormSubmission.objects.filter(\n            page=form_page, form_data__contains='hello world'\n        )\n        self.assertIn(\"foo\", submission[0].form_data)\n        self.assertIn(\"bar\", submission[0].form_data)\n        self.assertIn(\"baz\", submission[0].form_data)\n\n        # Check that the all the multiple checkbox values are serialised in the\n        # email correctly\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertIn(\"bar\", mail.outbox[0].body)\n        self.assertIn(\"foo\", mail.outbox[0].body)\n        self.assertIn(\"baz\", mail.outbox[0].body)\n\n    def test_post_blank_checkbox(self):\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': 'hello world',\n            'your_choices': {},\n        })\n\n        # Check response\n        self.assertContains(response, \"Thank you for your feedback.\")\n        self.assertTemplateNotUsed(response, 'tests/form_page.html')\n        self.assertTemplateUsed(response, 'tests/form_page_landing.html')\n\n        # Check that the checkbox was serialised in the email correctly\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertIn(\"Your choices: \", mail.outbox[0].body)\n\n\nclass TestFormWithCustomSubmission(TestCase, WagtailTestUtils):\n    def setUp(self):\n        # Create a form page\n        self.form_page = make_form_page_with_custom_submission()\n\n        self.user = self.login()\n\n    def test_get_form(self):\n        response = self.client.get('/contact-us/')\n\n        # Check response\n        self.assertContains(response, \"\"\"<label for=\"id_your_email\">Your email</label>\"\"\")\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission.html')\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission_landing.html')\n        self.assertNotContains(response, '<div>You must log in first.</div>', html=True)\n        self.assertContains(response, '<p>Boring intro text</p>', html=True)\n\n        # check that variables defined in get_context are passed through to the template (#1429)\n        self.assertContains(response, \"<p>hello world</p>\")\n\n    def test_get_form_with_anonymous_user(self):\n        self.client.logout()\n\n        response = self.client.get('/contact-us/')\n\n        # Check response\n        self.assertNotContains(response, \"\"\"<label for=\"id_your_email\">Your email</label>\"\"\")\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission.html')\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission_landing.html')\n        self.assertContains(response, '<div>You must log in first.</div>', html=True)\n        self.assertNotContains(response, '<p>Boring intro text</p>', html=True)\n\n        # check that variables defined in get_context are passed through to the template (#1429)\n        self.assertContains(response, \"<p>hello world</p>\")\n\n    def test_post_invalid_form(self):\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob',\n            'your_message': 'hello world',\n            'your_choices': ''\n        })\n\n        # Check response\n        self.assertContains(response, \"Enter a valid email address.\")\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission.html')\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission_landing.html')\n\n    def test_post_valid_form(self):\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': 'hello world',\n            'your_choices': {'foo': '', 'bar': '', 'baz': ''}\n        })\n\n        # Check response\n        self.assertContains(response, \"Thank you for your patience!\")\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission.html')\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission_landing.html')\n\n        # check that variables defined in get_context are passed through to the template (#1429)\n        self.assertContains(response, \"<p>hello world</p>\")\n\n        # check that the custom form_submission is added to the context\n        self.assertContains(response, \"<p>Username: test@email.com</p>\")\n\n        # Check that an email was sent\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertEqual(mail.outbox[0].subject, \"The subject\")\n        self.assertIn(\"Your message: hello world\", mail.outbox[0].body)\n        self.assertEqual(mail.outbox[0].to, ['to@email.com'])\n        self.assertEqual(mail.outbox[0].from_email, 'from@email.com')\n\n        # Check that form submission was saved correctly\n        form_page = Page.objects.get(url_path='/home/contact-us/')\n        self.assertTrue(CustomFormPageSubmission.objects.filter(page=form_page, form_data__contains='hello world').exists())\n\n    def test_post_form_twice(self):\n        # First submission\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': 'hello world',\n            'your_choices': {'foo': '', 'bar': '', 'baz': ''}\n        })\n\n        # Check response\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission.html')\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission_landing.html')\n        self.assertContains(response, '<p>Thank you for your patience!</p>', html=True)\n        self.assertNotContains(response, '<div>The form is already filled.</div>', html=True)\n\n        # Check that first form submission was saved correctly\n        submissions_qs = CustomFormPageSubmission.objects.filter(user=self.user, page=self.form_page)\n        self.assertEqual(submissions_qs.count(), 1)\n        self.assertTrue(submissions_qs.filter(form_data__contains='hello world').exists())\n\n        # Second submission\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': 'hello world',\n            'your_choices': {'foo': '', 'bar': '', 'baz': ''}\n        })\n\n        # Check response\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission.html')\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission_landing.html')\n        self.assertNotContains(response, '<p>Thank you for your patience!</p>', html=True)\n        self.assertContains(response, '<div>The form is already filled.</div>', html=True)\n        self.assertNotContains(response, '<div>You must log in first.</div>', html=True)\n        self.assertNotContains(response, '<p>Boring intro text</p>', html=True)\n\n        # Check that first submission exists and second submission wasn't saved\n        submissions_qs = CustomFormPageSubmission.objects.filter(user=self.user, page=self.form_page)\n        self.assertEqual(submissions_qs.count(), 1)\n        self.assertTrue(submissions_qs.filter(form_data__contains='hello world').exists())\n        self.assertFalse(submissions_qs.filter(form_data__contains='hello cruel world').exists())\n\n    def test_post_unicode_characters(self):\n        self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': '\u3053\u3093\u306b\u3061\u306f\u3001\u4e16\u754c',\n            'your_choices': {'foo': '', 'bar': '', 'baz': ''}\n        })\n\n        # Check the email\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertIn(\"Your message: \u3053\u3093\u306b\u3061\u306f\u3001\u4e16\u754c\", mail.outbox[0].body)\n\n        # Check the form submission\n        submission = CustomFormPageSubmission.objects.get()\n        submission_data = json.loads(submission.form_data)\n        self.assertEqual(submission_data['your_message'], '\u3053\u3093\u306b\u3061\u306f\u3001\u4e16\u754c')\n\n    def test_post_multiple_values(self):\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': 'hello world',\n            'your_choices': {'foo': 'on', 'bar': 'on', 'baz': 'on'}\n        })\n\n        # Check response\n        self.assertContains(response, \"Thank you for your patience!\")\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission.html')\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission_landing.html')\n\n        # Check that the three checkbox values were saved correctly\n        form_page = Page.objects.get(url_path='/home/contact-us/')\n        submission = CustomFormPageSubmission.objects.filter(\n            page=form_page, form_data__contains='hello world'\n        )\n        self.assertIn(\"foo\", submission[0].form_data)\n        self.assertIn(\"bar\", submission[0].form_data)\n        self.assertIn(\"baz\", submission[0].form_data)\n\n    def test_post_blank_checkbox(self):\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': 'hello world',\n            'your_choices': {},\n        })\n\n        # Check response\n        self.assertContains(response, \"Thank you for your patience!\")\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission.html')\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission_landing.html')\n\n        # Check that the checkbox was serialised in the email correctly\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertIn(\"Your choices: None\", mail.outbox[0].body)\n\n\nclass TestFormSubmissionWithMultipleRecipients(TestCase):\n    def setUp(self):\n        # Create a form page\n        self.form_page = make_form_page(to_address='to@email.com, another@email.com')\n\n    def test_post_valid_form(self):\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': 'hello world',\n            'your_choices': {'foo': '', 'bar': '', 'baz': ''}\n        })\n\n        # Check response\n        self.assertContains(response, \"Thank you for your feedback.\")\n        self.assertTemplateNotUsed(response, 'tests/form_page.html')\n        self.assertTemplateUsed(response, 'tests/form_page_landing.html')\n\n        # check that variables defined in get_context are passed through to the template (#1429)\n        self.assertContains(response, \"<p>hello world</p>\")\n\n        # Check that one email was sent, but to two recipients\n        self.assertEqual(len(mail.outbox), 1)\n\n        self.assertEqual(mail.outbox[0].subject, \"The subject\")\n        self.assertIn(\"Your message: hello world\", mail.outbox[0].body)\n        self.assertEqual(mail.outbox[0].from_email, 'from@email.com')\n        self.assertEqual(set(mail.outbox[0].to), {'to@email.com', 'another@email.com'})\n\n        # Check that form submission was saved correctly\n        form_page = Page.objects.get(url_path='/home/contact-us/')\n        self.assertTrue(FormSubmission.objects.filter(page=form_page, form_data__contains='hello world').exists())\n\n\nclass TestFormSubmissionWithMultipleRecipientsAndWithCustomSubmission(TestCase, WagtailTestUtils):\n    def setUp(self):\n        # Create a form page\n        self.form_page = make_form_page_with_custom_submission(\n            to_address='to@email.com, another@email.com'\n        )\n\n        self.user = self.login()\n\n    def test_post_valid_form(self):\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': 'hello world',\n            'your_choices': {'foo': '', 'bar': '', 'baz': ''}\n        })\n\n        # Check response\n        self.assertContains(response, \"Thank you for your patience!\")\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission.html')\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission_landing.html')\n\n        # check that variables defined in get_context are passed through to the template (#1429)\n        self.assertContains(response, \"<p>hello world</p>\")\n\n        # Check that one email was sent, but to two recipients\n        self.assertEqual(len(mail.outbox), 1)\n\n        self.assertEqual(mail.outbox[0].subject, \"The subject\")\n        self.assertIn(\"Your message: hello world\", mail.outbox[0].body)\n        self.assertEqual(mail.outbox[0].from_email, 'from@email.com')\n        self.assertEqual(set(mail.outbox[0].to), {'to@email.com', 'another@email.com'})\n\n        # Check that form submission was saved correctly\n        form_page = Page.objects.get(url_path='/home/contact-us/')\n        self.assertTrue(\n            CustomFormPageSubmission.objects.filter(page=form_page, form_data__contains='hello world').exists()\n        )\n\n\nclass TestFormWithRedirect(TestCase):\n    def setUp(self):\n        # Create a form page\n        self.form_page = make_form_page_with_redirect(to_address='to@email.com, another@email.com')\n\n    def test_post_valid_form(self):\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': 'hello world',\n            'your_choices': {'foo': '', 'bar': '', 'baz': ''}\n        })\n\n        # Check response\n        self.assertRedirects(response, '/')\n\n        # Check that one email was sent, but to two recipients\n        self.assertEqual(len(mail.outbox), 1)\n\n        self.assertEqual(mail.outbox[0].subject, \"The subject\")\n        self.assertIn(\"Your message: hello world\", mail.outbox[0].body)\n        self.assertEqual(mail.outbox[0].from_email, 'from@email.com')\n        self.assertEqual(set(mail.outbox[0].to), {'to@email.com', 'another@email.com'})\n\n        # Check that form submission was saved correctly\n        form_page = Page.objects.get(url_path='/home/contact-us/')\n        self.assertTrue(FormSubmission.objects.filter(page=form_page, form_data__contains='hello world').exists())\n\n\nclass TestFormPageWithCustomFormBuilder(TestCase, WagtailTestUtils):\n\n    def setUp(self):\n\n        home_page = Page.objects.get(url_path='/home/')\n        form_page = home_page.add_child(\n            instance=FormPageWithCustomFormBuilder(\n                title='Support Request',\n                slug='support-request',\n                to_address='it@jenkins.com',\n                from_address='support@jenkins.com',\n                subject='Support Request Submitted',\n            )\n        )\n        ExtendedFormField.objects.create(\n            page=form_page,\n            sort_order=1,\n            label='Name',\n            field_type='singleline',  # singleline field will be max_length 120\n            required=True,\n        )\n        ExtendedFormField.objects.create(\n            page=form_page,\n            sort_order=1,\n            label='Device IP Address',\n            field_type='ipaddress',\n            required=True,\n        )\n\n    def test_get_form(self):\n        response = self.client.get('/support-request/')\n\n        # Check response\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_form_builder.html')\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_form_builder_landing.html')\n        self.assertContains(response, '<title>Support Request</title>', html=True)\n        # check that max_length attribute has been passed into form\n        self.assertContains(response, '<input type=\"text\" name=\"name\" required maxlength=\"120\" id=\"id_name\" />', html=True)\n        # check ip address field has rendered\n        self.assertContains(response, '<input type=\"text\" name=\"device_ip_address\" required id=\"id_device_ip_address\" />', html=True)\n\n    def test_post_invalid_form(self):\n        response = self.client.post('/support-request/', {\n            'name': 'very long name longer than 120 characters' * 3,  # invalid\n            'device_ip_address': '192.0.2.30',  # valid\n        })\n        # Check response with invalid character count\n        self.assertContains(response, 'Ensure this value has at most 120 characters (it has 123)')\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_form_builder.html')\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_form_builder_landing.html')\n\n        response = self.client.post('/support-request/', {\n            'name': 'Ron Johnson',  # valid\n            'device_ip_address': '3300.192.0.2.30',  # invalid\n        })\n        # Check response with invalid character count\n        self.assertContains(response, 'Enter a valid IPv4 or IPv6 address.')\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_form_builder.html')\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_form_builder_landing.html')\n\n    def test_post_valid_form(self):\n        response = self.client.post('/support-request/', {\n            'name': 'Ron Johnson',\n            'device_ip_address': '192.0.2.30',\n        })\n\n        # Check response\n        self.assertContains(response, 'Thank you for submitting a Support Request.')\n        self.assertContains(response, 'Ron Johnson')\n        self.assertContains(response, '192.0.2.30')\n        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_form_builder.html')\n        self.assertTemplateUsed(response, 'tests/form_page_with_custom_form_builder_landing.html')\n\n\nclass TestCleanedDataEmails(TestCase):\n    def setUp(self):\n        # Create a form page\n        self.form_page = make_types_test_form_page()\n\n    def test_empty_field_presence(self):\n        self.client.post('/contact-us/', {})\n\n        # Check the email\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertIn(\"Single line text: \", mail.outbox[0].body)\n        self.assertIn(\"Multiline: \", mail.outbox[0].body)\n        self.assertIn(\"Email: \", mail.outbox[0].body)\n        self.assertIn(\"Number: \", mail.outbox[0].body)\n        self.assertIn(\"URL: \", mail.outbox[0].body)\n        self.assertIn(\"Checkbox: \", mail.outbox[0].body)\n        self.assertIn(\"Checkboxes: \", mail.outbox[0].body)\n        self.assertIn(\"Drop down: \", mail.outbox[0].body)\n        self.assertIn(\"Multiple select: \", mail.outbox[0].body)\n        self.assertIn(\"Radio buttons: \", mail.outbox[0].body)\n        self.assertIn(\"Date: \", mail.outbox[0].body)\n        self.assertIn(\"Datetime: \", mail.outbox[0].body)\n\n    def test_email_field_order(self):\n        self.client.post('/contact-us/', {})\n\n        line_beginnings = [\n            \"Single line text: \",\n            \"Multiline: \",\n            \"Email: \",\n            \"Number: \",\n            \"URL: \",\n            \"Checkbox: \",\n            \"Checkboxes: \",\n            \"Drop down: \",\n            \"Multiple select: \",\n            \"Radio buttons: \",\n            \"Date: \",\n            \"Datetime: \",\n        ]\n\n        # Check the email\n        self.assertEqual(len(mail.outbox), 1)\n        email_lines = mail.outbox[0].body.split('\\n')\n\n        for beginning in line_beginnings:\n            message_line = email_lines.pop(0)\n            self.assertTrue(message_line.startswith(beginning))\n\n    @override_settings(SHORT_DATE_FORMAT='m/d/Y')\n    def test_date_normalization(self):\n        self.client.post('/contact-us/', {\n            'date': '12/31/17',\n        })\n\n        # Check the email\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertIn(\"Date: 12/31/2017\", mail.outbox[0].body)\n\n        self.client.post('/contact-us/', {\n            'date': '12/31/1917',\n        })\n\n        # Check the email\n        self.assertEqual(len(mail.outbox), 2)\n        self.assertIn(\"Date: 12/31/1917\", mail.outbox[1].body)\n\n\n    @override_settings(SHORT_DATETIME_FORMAT='m/d/Y P')\n    def test_datetime_normalization(self):\n        self.client.post('/contact-us/', {\n            'datetime': '12/31/17 4:00:00',\n        })\n\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertIn(\"Datetime: 12/31/2017 4 a.m.\", mail.outbox[0].body)\n\n        self.client.post('/contact-us/', {\n            'datetime': '12/31/1917 21:19',\n        })\n\n        self.assertEqual(len(mail.outbox), 2)\n        self.assertIn(\"Datetime: 12/31/1917 9:19 p.m.\", mail.outbox[1].body)\n\n        self.client.post('/contact-us/', {\n            'datetime': '1910-12-21 21:19:12',\n        })\n\n        self.assertEqual(len(mail.outbox), 3)\n        self.assertIn(\"Datetime: 12/21/1910 9:19 p.m.\", mail.outbox[2].body)\n\n\n\nclass TestIssue798(TestCase):\n    fixtures = ['test.json']\n\n    def setUp(self):\n        self.assertTrue(self.client.login(username='siteeditor', password='password'))\n        self.form_page = Page.objects.get(url_path='/home/contact-us/').specific\n\n        # Add a number field to the page\n        FormField.objects.create(\n            page=self.form_page,\n            label=\"Your favourite number\",\n            field_type='number',\n        )\n\n    def test_post(self):\n        response = self.client.post('/contact-us/', {\n            'your_email': 'bob@example.com',\n            'your_message': 'hello world',\n            'your_choices': {'foo': '', 'bar': '', 'baz': ''},\n            'your_favourite_number': '7.3',\n        })\n\n        # Check response\n        self.assertTemplateUsed(response, 'tests/form_page_landing.html')\n\n        # Check that form submission was saved correctly\n        self.assertTrue(FormSubmission.objects.filter(page=self.form_page, form_data__contains='hello world').exists())\n        self.assertTrue(FormSubmission.objects.filter(page=self.form_page, form_data__contains='7.3').exists())\n\n\nclass TestNonHtmlExtension(TestCase):\n    fixtures = ['test.json']\n\n    def test_non_html_extension(self):\n        form_page = JadeFormPage(title=\"test\")\n        self.assertEqual(form_page.landing_page_template, \"tests/form_page_landing.jade\")\n\n\nclass TestLegacyFormFieldCleanNameChecks(TestCase):\n    fixtures = ['test.json']\n\n    def setUp(self):\n        self.assertTrue(self.client.login(username='siteeditor', password='password'))\n        self.form_page = Page.objects.get(url_path='/home/contact-us-one-more-time/').specific\n\n\n    def test_form_field_clean_name_update_on_checks(self):\n\n        fields_before_checks = [\n            (field.label, field.clean_name,)\n            for field in FormFieldWithCustomSubmission.objects.all()\n        ]\n\n        self.assertEqual(fields_before_checks, [\n            ('Your email', ''),\n            ('Your message', ''),\n            ('Your choices', ''),\n        ])\n\n        # running checks should show an info message AND update blank clean_name values\n\n        messages = FormFieldWithCustomSubmission.check()\n\n        self.assertEqual(\n            messages,\n            [Info('Added `clean_name` on 3 form field(s)', obj=FormFieldWithCustomSubmission)]\n        )\n\n\n        fields_after_checks = [\n            (field.label, field.clean_name,)\n            for field in FormFieldWithCustomSubmission.objects.all()\n        ]\n\n        self.assertEqual(fields_after_checks, [\n            ('Your email', 'your-email'),  # kebab case, legacy format\n            ('Your message', 'your-message'),\n            ('Your choices', 'your-choices'),\n        ])\n\n        # running checks again should return no messages as fields no longer need changing\n        self.assertEqual(FormFieldWithCustomSubmission.check(), [])\n\n        # creating a new field should use the non-legacy clean_name format\n\n        field = FormFieldWithCustomSubmission.objects.create(\n            page=self.form_page,\n            label=\"Your FAVOURITE #number\",\n            field_type='number',\n        )\n\n        self.assertEqual(field.clean_name, 'your_favourite_number')\n", "# -*- coding: utf-8 -*-\nfrom wagtail.core.models import Page\nfrom wagtail.tests.testapp.models import (\n    FormField, FormFieldWithCustomSubmission, FormPage, FormPageWithCustomSubmission,\n    FormPageWithRedirect, RedirectFormField)\n\n\ndef make_form_page(**kwargs):\n    kwargs.setdefault('title', \"Contact us\")\n    kwargs.setdefault('slug', \"contact-us\")\n    kwargs.setdefault('to_address', \"to@email.com\")\n    kwargs.setdefault('from_address', \"from@email.com\")\n    kwargs.setdefault('subject', \"The subject\")\n\n    home_page = Page.objects.get(url_path='/home/')\n    form_page = home_page.add_child(instance=FormPage(**kwargs))\n\n    FormField.objects.create(\n        page=form_page,\n        sort_order=1,\n        label=\"Your email\",\n        field_type='email',\n        required=True,\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=2,\n        label=\"Your message\",\n        field_type='multiline',\n        required=True,\n        help_text=\"<em>please</em> be polite\"\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=3,\n        label=\"Your choices\",\n        field_type='checkboxes',\n        required=False,\n        choices='foo,bar,baz',\n    )\n\n    return form_page\n\n\ndef make_form_page_with_custom_submission(**kwargs):\n    kwargs.setdefault('title', \"Contact us\")\n    kwargs.setdefault('intro', \"<p>Boring intro text</p>\")\n    kwargs.setdefault('thank_you_text', \"<p>Thank you for your patience!</p>\")\n    kwargs.setdefault('slug', \"contact-us\")\n    kwargs.setdefault('to_address', \"to@email.com\")\n    kwargs.setdefault('from_address', \"from@email.com\")\n    kwargs.setdefault('subject', \"The subject\")\n\n    home_page = Page.objects.get(url_path='/home/')\n    form_page = home_page.add_child(instance=FormPageWithCustomSubmission(**kwargs))\n\n    FormFieldWithCustomSubmission.objects.create(\n        page=form_page,\n        sort_order=1,\n        label=\"Your email\",\n        field_type='email',\n        required=True,\n    )\n    FormFieldWithCustomSubmission.objects.create(\n        page=form_page,\n        sort_order=2,\n        label=\"Your message\",\n        field_type='multiline',\n        required=True,\n    )\n    FormFieldWithCustomSubmission.objects.create(\n        page=form_page,\n        sort_order=3,\n        label=\"Your choices\",\n        field_type='checkboxes',\n        required=False,\n        choices='foo,bar,baz',\n    )\n\n    return form_page\n\n\ndef make_form_page_with_redirect(**kwargs):\n    kwargs.setdefault('title', \"Contact us\")\n    kwargs.setdefault('slug', \"contact-us\")\n    kwargs.setdefault('to_address', \"to@email.com\")\n    kwargs.setdefault('from_address', \"from@email.com\")\n    kwargs.setdefault('subject', \"The subject\")\n\n\n    home_page = Page.objects.get(url_path='/home/')\n    kwargs.setdefault('thank_you_redirect_page', home_page)\n    form_page = home_page.add_child(instance=FormPageWithRedirect(**kwargs))\n    # form_page.thank_you_redirect_page = home_page\n\n    RedirectFormField.objects.create(\n        page=form_page,\n        sort_order=1,\n        label=\"Your email\",\n        field_type='email',\n        required=True,\n    )\n    RedirectFormField.objects.create(\n        page=form_page,\n        sort_order=2,\n        label=\"Your message\",\n        field_type='multiline',\n        required=True,\n    )\n    RedirectFormField.objects.create(\n        page=form_page,\n        sort_order=3,\n        label=\"Your choices\",\n        field_type='checkboxes',\n        required=False,\n        choices='foo,bar,baz',\n    )\n\n    return form_page\n\n\ndef make_types_test_form_page(**kwargs):\n    kwargs.setdefault('title', \"Contact us\")\n    kwargs.setdefault('slug', \"contact-us\")\n    kwargs.setdefault('to_address', \"to@email.com\")\n    kwargs.setdefault('from_address', \"from@email.com\")\n    kwargs.setdefault('subject', \"The subject\")\n\n    home_page = Page.objects.get(url_path='/home/')\n    form_page = home_page.add_child(instance=FormPage(**kwargs))\n\n    FormField.objects.create(\n        page=form_page,\n        sort_order=1,\n        label=\"Single line text\",\n        field_type='singleline',\n        required=False,\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=2,\n        label=\"Multiline\",\n        field_type='multiline',\n        required=False,\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=3,\n        label=\"Email\",\n        field_type='email',\n        required=False,\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=4,\n        label=\"Number\",\n        field_type='number',\n        required=False,\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=5,\n        label=\"URL\",\n        field_type='url',\n        required=False,\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=6,\n        label=\"Checkbox\",\n        field_type='checkbox',\n        required=False,\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=7,\n        label=\"Checkboxes\",\n        field_type='checkboxes',\n        required=False,\n        choices='foo,bar,baz',\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=8,\n        label=\"Drop down\",\n        field_type='dropdown',\n        required=False,\n        choices='spam,ham,eggs',\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=9,\n        label=\"Multiple select\",\n        field_type='multiselect',\n        required=False,\n        choices='qux,quux,quuz,corge',\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=10,\n        label=\"Radio buttons\",\n        field_type='radio',\n        required=False,\n        choices='wibble,wobble,wubble',\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=11,\n        label=\"Date\",\n        field_type='date',\n        required=False,\n    )\n    FormField.objects.create(\n        page=form_page,\n        sort_order=12,\n        label=\"Datetime\",\n        field_type='datetime',\n        required=False,\n    )\n\n    return form_page\n"], "filenames": ["docs/reference/settings.rst", "wagtail/contrib/forms/forms.py", "wagtail/contrib/forms/tests/test_models.py", "wagtail/contrib/forms/tests/utils.py"], "buggy_code_start_loc": [549, 3, 31, 30], "buggy_code_end_loc": [549, 118, 33, 30], "fixing_code_start_loc": [550, 4, 32, 31], "fixing_code_end_loc": [563, 123, 43, 32], "type": "CWE-79", "message": "In Wagtail before versions 2.7.4 and 2.9.3, when a form page type is made available to Wagtail editors through the `wagtail.contrib.forms` app, and the page template is built using Django's standard form rendering helpers such as form.as_p, any HTML tags used within a form field's help text will be rendered unescaped in the page. Allowing HTML within help text is an intentional design decision by Django; however, as a matter of policy Wagtail does not allow editors to insert arbitrary HTML by default, as this could potentially be used to carry out cross-site scripting attacks, including privilege escalation. This functionality should therefore not have been made available to editor-level users. The vulnerability is not exploitable by an ordinary site visitor without access to the Wagtail admin. Patched versions have been released as Wagtail 2.7.4 (for the LTS 2.7 branch) and Wagtail 2.9.3 (for the current 2.9 branch). In these versions, help text will be escaped to prevent the inclusion of HTML tags. Site owners who wish to re-enable the use of HTML within help text (and are willing to accept the risk of this being exploited by editors) may set WAGTAILFORMS_HELP_TEXT_ALLOW_HTML = True in their configuration settings. Site owners who are unable to upgrade to the new versions can secure their form page templates by rendering forms field-by-field as per Django's documentation, but omitting the |safe filter when outputting the help text.", "other": {"cve": {"id": "CVE-2020-15118", "sourceIdentifier": "security-advisories@github.com", "published": "2020-07-20T18:15:12.107", "lastModified": "2020-07-28T12:29:45.730", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Wagtail before versions 2.7.4 and 2.9.3, when a form page type is made available to Wagtail editors through the `wagtail.contrib.forms` app, and the page template is built using Django's standard form rendering helpers such as form.as_p, any HTML tags used within a form field's help text will be rendered unescaped in the page. Allowing HTML within help text is an intentional design decision by Django; however, as a matter of policy Wagtail does not allow editors to insert arbitrary HTML by default, as this could potentially be used to carry out cross-site scripting attacks, including privilege escalation. This functionality should therefore not have been made available to editor-level users. The vulnerability is not exploitable by an ordinary site visitor without access to the Wagtail admin. Patched versions have been released as Wagtail 2.7.4 (for the LTS 2.7 branch) and Wagtail 2.9.3 (for the current 2.9 branch). In these versions, help text will be escaped to prevent the inclusion of HTML tags. Site owners who wish to re-enable the use of HTML within help text (and are willing to accept the risk of this being exploited by editors) may set WAGTAILFORMS_HELP_TEXT_ALLOW_HTML = True in their configuration settings. Site owners who are unable to upgrade to the new versions can secure their form page templates by rendering forms field-by-field as per Django's documentation, but omitting the |safe filter when outputting the help text."}, {"lang": "es", "value": "En Wagtail versiones anteriores a 2.7.4 y 2.9.3, cuando un tipo de p\u00e1gina de formulario est\u00e1 disponible para los editores de Wagtail mediante la aplicaci\u00f3n \"wagtail.contrib.forms\", y la plantilla de la p\u00e1gina es creada utilizando los asistentes de renderizaci\u00f3n de formularios est\u00e1ndar de Django, tal y como form.as_p, cualquiera de las etiquetas HTML utilizadas en el texto de ayuda de un campo de formulario ser\u00e1n renderizadas sin escape en la p\u00e1gina. Permitir HTML dentro del texto de ayuda es una decisi\u00f3n de dise\u00f1o intencional por Django; sin embargo, como cuesti\u00f3n de la pol\u00edtica, Wagtail no permite a editores insertar HTML arbitrario por defecto, ya que esto podr\u00eda potencialmente ser usado para llevar a cabo ataques de tipo cross-site scripting, incluyendo una escalada de privilegios. Esta funcionalidad por lo tanto no deber\u00eda haberse puesto a disposici\u00f3n de los usuarios de nivel editor. La vulnerabilidad no es explotable por un visitante ordinario del sitio sin acceso al administrador de Wagtail. Las versiones parcheadas han sido iniciadas como Wagtail versi\u00f3n 2.7.4 (para la rama LTS 2.7) y Wagtail versi\u00f3n 2.9.3 (para la rama 2.9 actual). En estas versiones, ser\u00e1 escapado el texto de ayuda para impedir la inclusi\u00f3n de etiquetas HTML. Los propietarios de sitios que deseen volver a habilitar el uso de HTML en el texto de ayuda (y est\u00e9n dispuestos a aceptar el riesgo de que los editores lo exploten) pueden establecer WAGTAILFORMS_HELP_TEXT_ALLOW_HTML = True en sus ajustes de configuraci\u00f3n. Los propietarios de sitios que no son capaces de actualizar a las nuevas versiones pueden proteger sus plantillas de p\u00e1gina de formulario al renderizar formularios campo por campo seg\u00fan la documentaci\u00f3n de Django, pero omitiendo el filtro seguro al generar el texto de ayuda"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:H/UI:R/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.5, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:torchbox:wagtail:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.7", "versionEndExcluding": "2.7.4", "matchCriteriaId": "2220EE02-4D15-4969-85A0-73492983333E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:torchbox:wagtail:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.9", "versionEndExcluding": "2.9.3", "matchCriteriaId": "937BB6AA-059B-403B-908B-52FB905FFD77"}]}]}], "references": [{"url": "https://docs.djangoproject.com/en/3.0/ref/models/fields/#django.db.models.Field.help_text", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://docs.wagtail.io/en/stable/reference/contrib/forms/index.html#usage", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/wagtail/wagtail/blob/master/docs/releases/2.9.3.rst", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/wagtail/wagtail/commit/d9a41e7f24d08c024acc9a3094940199df94db34", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/wagtail/wagtail/security/advisories/GHSA-2473-9hgq-j7xw", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/wagtail/wagtail/commit/d9a41e7f24d08c024acc9a3094940199df94db34"}}