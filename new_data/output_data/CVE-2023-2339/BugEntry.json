{"buggy_code": ["<?php\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\Bundle\\AdminBundle\\Controller\\Admin\\Asset;\n\nuse League\\Flysystem\\FilesystemException;\nuse League\\Flysystem\\UnableToReadFile;\nuse PhpOffice\\PhpSpreadsheet\\Reader\\Csv;\nuse PhpOffice\\PhpSpreadsheet\\Writer\\Xlsx;\nuse Pimcore\\Bundle\\AdminBundle\\Controller\\AdminController;\nuse Pimcore\\Bundle\\AdminBundle\\Helper\\GridHelperService;\nuse Pimcore\\Db;\nuse Pimcore\\Event\\AdminEvents;\nuse Pimcore\\Loader\\ImplementationLoader\\Exception\\UnsupportedException;\nuse Pimcore\\Localization\\LocaleServiceInterface;\nuse Pimcore\\Logger;\nuse Pimcore\\Model\\Asset;\nuse Pimcore\\Model\\Element;\nuse Pimcore\\Model\\GridConfig;\nuse Pimcore\\Model\\GridConfigFavourite;\nuse Pimcore\\Model\\GridConfigShare;\nuse Pimcore\\Model\\Metadata;\nuse Pimcore\\Model\\User;\nuse Pimcore\\Tool;\nuse Pimcore\\Tool\\Storage;\nuse Pimcore\\Version;\nuse Symfony\\Component\\EventDispatcher\\GenericEvent;\nuse Symfony\\Component\\HttpFoundation\\BinaryFileResponse;\nuse Symfony\\Component\\HttpFoundation\\HeaderUtils;\nuse Symfony\\Component\\HttpFoundation\\JsonResponse;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpFoundation\\Session\\Attribute\\AttributeBagInterface;\nuse Symfony\\Component\\Routing\\Annotation\\Route;\nuse Symfony\\Contracts\\EventDispatcher\\EventDispatcherInterface;\n\n/**\n * @Route(\"/asset-helper\")\n *\n * @internal\n */\nclass AssetHelperController extends AdminController\n{\n    /**\n     * @param int $userId\n     * @param string $classId\n     * @param string $searchType\n     *\n     * @return array\n     */\n    public function getMyOwnGridColumnConfigs($userId, $classId, $searchType)\n    {\n        $db = Db::get();\n        $configListingConditionParts = [];\n        $configListingConditionParts[] = 'ownerId = ' . $userId;\n        $configListingConditionParts[] = 'classId = ' . $db->quote($classId);\n\n        if ($searchType) {\n            $configListingConditionParts[] = 'searchType = ' . $db->quote($searchType);\n        }\n\n        $configCondition = implode(' AND ', $configListingConditionParts);\n        $configListing = new GridConfig\\Listing();\n        $configListing->setOrderKey('name');\n        $configListing->setOrder('ASC');\n        $configListing->setCondition($configCondition);\n        $configListing = $configListing->load();\n\n        $configData = [];\n        if (is_array($configListing)) {\n            foreach ($configListing as $config) {\n                $configData[] = $config->getObjectVars();\n            }\n        }\n\n        return $configData;\n    }\n\n    /**\n     * @param User $user\n     * @param string $classId\n     * @param string $searchType\n     *\n     * @return array\n     */\n    public function getSharedGridColumnConfigs($user, $classId, $searchType = null)\n    {\n        $db = Db::get();\n\n        $configListing = [];\n\n        $userIds = [$user->getId()];\n        // collect all roles\n        $userIds = array_merge($userIds, $user->getRoles());\n        $userIds = implode(',', $userIds);\n\n        $query = 'select distinct c1.id from gridconfigs c1, gridconfig_shares s\n                    where (c1.searchType = ' . $db->quote($searchType) . ' and ((c1.id = s.gridConfigId and s.sharedWithUserId IN (' . $userIds . '))) and c1.classId = ' . $db->quote($classId) . ')\n                            UNION distinct select c2.id from gridconfigs c2 where shareGlobally = 1 and c2.classId = '. $db->quote($classId) . '  and c2.ownerId != ' . $db->quote($user->getId());\n\n        $ids = $db->fetchFirstColumn($query);\n\n        if ($ids) {\n            $ids = implode(',', $ids);\n            $configListing = new GridConfig\\Listing();\n            $configListing->setOrderKey('name');\n            $configListing->setOrder('ASC');\n            $configListing->setCondition('id in (' . $ids . ')');\n            $configListing = $configListing->load();\n        }\n\n        $configData = [];\n        if (is_array($configListing)) {\n            foreach ($configListing as $config) {\n                $configData[] = $config->getObjectVars();\n            }\n        }\n\n        return $configData;\n    }\n\n    /**\n     * @Route(\"/grid-delete-column-config\", name=\"pimcore_admin_asset_assethelper_griddeletecolumnconfig\", methods={\"DELETE\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function gridDeleteColumnConfigAction(Request $request)\n    {\n        $gridConfigId = $request->get('gridConfigId');\n        $gridConfig = GridConfig::getById($gridConfigId);\n        $success = false;\n        if ($gridConfig) {\n            if ($gridConfig->getOwnerId() != $this->getAdminUser()->getId()) {\n                throw new \\Exception(\"don't mess with someone elses grid config\");\n            }\n\n            $gridConfig->delete();\n            $success = true;\n        }\n\n        $newGridConfig = $this->doGetGridColumnConfig($request, true);\n        $newGridConfig['deleteSuccess'] = $success;\n\n        return $this->adminJson($newGridConfig);\n    }\n\n    /**\n     * @Route(\"/grid-get-column-config\", name=\"pimcore_admin_asset_assethelper_gridgetcolumnconfig\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function gridGetColumnConfigAction(Request $request)\n    {\n        $result = $this->doGetGridColumnConfig($request);\n\n        return $this->adminJson($result);\n    }\n\n    /**\n     * @param Request $request\n     * @param bool $isDelete\n     *\n     * @return array\n     */\n    public function doGetGridColumnConfig(Request $request, $isDelete = false)\n    {\n        $gridConfigId = null;\n\n        $classId = $request->get('id');\n        $type = $request->get('type');\n\n        $context = ['purpose' => 'gridconfig'];\n\n        $types = [];\n        if ($request->get('types')) {\n            $types = explode(',', $request->get('types'));\n        }\n\n        $userId = $this->getAdminUser()->getId();\n\n        $requestedGridConfigId = $isDelete ? null : $request->get('gridConfigId');\n\n        // grid config\n        $gridConfig = [];\n        $searchType = $request->get('searchType');\n\n        if (strlen($requestedGridConfigId) == 0) {\n            // check if there is a favourite view\n            $favourite = GridConfigFavourite::getByOwnerAndClassAndObjectId($userId, $classId, 0, $searchType);\n\n            if ($favourite) {\n                $requestedGridConfigId = $favourite->getGridConfigId();\n            }\n        }\n\n        if (is_numeric($requestedGridConfigId) && $requestedGridConfigId > 0) {\n            $db = Db::get();\n            $savedGridConfig = GridConfig::getById((int) $requestedGridConfigId);\n\n            if ($savedGridConfig) {\n                $shared = null;\n\n                try {\n                    $userIds = [$this->getAdminUser()->getId()];\n                    if ($this->getAdminUser()->getRoles()) {\n                        $userIds = array_merge($userIds, $this->getAdminUser()->getRoles());\n                    }\n                    $userIds = implode(',', $userIds);\n                    $shared = ($savedGridConfig->getOwnerId() != $userId && $savedGridConfig->isShareGlobally()) || $db->fetchOne('select * from gridconfig_shares where sharedWithUserId IN (' . $userIds . ') and gridConfigId = ' . $savedGridConfig->getId());\n                } catch (\\Exception $e) {\n                }\n\n                if (!$shared && $savedGridConfig->getOwnerId() != $this->getAdminUser()->getId()) {\n                    throw new \\Exception('You are neither the owner of this config nor it is shared with you');\n                }\n                $gridConfigId = $savedGridConfig->getId();\n                $gridConfig = $savedGridConfig->getConfig();\n                $gridConfig = json_decode($gridConfig, true);\n                $gridConfigName = $savedGridConfig->getName();\n                $gridConfigDescription = $savedGridConfig->getDescription();\n                $sharedGlobally = $savedGridConfig->isShareGlobally();\n                $setAsFavourite = $savedGridConfig->isSetAsFavourite();\n            }\n        }\n\n        $availableFields = [];\n        $language = '';\n\n        if (empty($gridConfig)) {\n            $availableFields = $this->getDefaultGridFields(\n                $request->get('no_system_columns'),\n                [], //maybe required for types other than metadata\n                $context,\n                $types);\n        } else {\n            $savedColumns = $gridConfig['columns'];\n\n            foreach ($savedColumns as $key => $sc) {\n                if (!$sc['hidden']) {\n                    $colConfig = $this->getFieldGridConfig($sc, $language, null);\n                    if ($colConfig) {\n                        $availableFields[] = $colConfig;\n                    }\n                }\n            }\n        }\n        usort($availableFields, function ($a, $b) {\n            if ($a['position'] == $b['position']) {\n                return 0;\n            }\n\n            return ($a['position'] < $b['position']) ? -1 : 1;\n        });\n\n        $availableConfigs = $classId ? $this->getMyOwnGridColumnConfigs($userId, $classId, $searchType) : [];\n        $sharedConfigs = $classId ? $this->getSharedGridColumnConfigs($this->getAdminUser(), $classId, $searchType) : [];\n        $settings = $this->getShareSettings((int)$gridConfigId);\n        $settings['gridConfigId'] = (int)$gridConfigId;\n        $settings['gridConfigName'] = $gridConfigName ?? null;\n        $settings['gridConfigDescription'] = $gridConfigDescription ?? null;\n        $settings['shareGlobally'] = $sharedGlobally ?? null;\n        $settings['setAsFavourite'] = $setAsFavourite ?? null;\n        $settings['isShared'] = !$gridConfigId || ($shared ?? null);\n\n        $context = $gridConfig['context'] ?? null;\n        if ($context) {\n            $context = json_decode($context, true);\n        }\n\n        return [\n            'sortinfo' => isset($gridConfig['sortinfo']) ? $gridConfig['sortinfo'] : false,\n            'availableFields' => $availableFields,\n            'settings' => $settings,\n            'onlyDirectChildren' => isset($gridConfig['onlyDirectChildren']) ? $gridConfig['onlyDirectChildren'] : false,\n            'onlyUnreferenced' => isset($gridConfig['onlyUnreferenced']) ? $gridConfig['onlyUnreferenced'] : false,\n            'pageSize' => isset($gridConfig['pageSize']) ? $gridConfig['pageSize'] : false,\n            'availableConfigs' => $availableConfigs,\n            'sharedConfigs' => $sharedConfigs,\n            'context' => $context,\n        ];\n    }\n\n    /**\n     * @param array $field\n     * @param string $language\n     * @param string|null $keyPrefix\n     *\n     * @return array|null\n     */\n    protected function getFieldGridConfig($field, $language = '', $keyPrefix = null)\n    {\n        $defaulMetadataFields = ['copyright', 'alt', 'title'];\n        $predefined = null;\n\n        if (isset($field['fieldConfig']['layout']['name'])) {\n            $predefined = Metadata\\Predefined::getByName($field['fieldConfig']['layout']['name']);\n        }\n\n        $key = $field['name'];\n        if ($keyPrefix) {\n            $key = $keyPrefix . $key;\n        }\n\n        $fieldDef = explode('~', $field['name']);\n        $field['name'] = $fieldDef[0];\n\n        if (isset($fieldDef[1]) && $fieldDef[1] === 'system') {\n            $type = 'system';\n        } elseif (in_array($fieldDef[0], $defaulMetadataFields)) {\n            $type = 'input';\n        } else {\n            $type = $field['fieldConfig']['type'];\n            if (isset($fieldDef[1])) {\n                $field['fieldConfig']['label'] = $field['fieldConfig']['layout']['title'] = $fieldDef[0] . ' (' . $fieldDef[1] . ')';\n                $field['fieldConfig']['layout']['icon'] = Tool::getLanguageFlagFile($fieldDef[1], true);\n            }\n        }\n\n        $result = [\n            'key' => $key,\n            'type' => $type,\n            'label' => $field['fieldConfig']['label'] ?? $key,\n            'width' => $field['width'],\n            'position' => $field['position'],\n            'language' => $field['fieldConfig']['language'] ?? null,\n            'layout' => $field['fieldConfig']['layout'] ?? null,\n        ];\n\n        if (isset($field['locked'])) {\n            $result['locked'] = $field['locked'];\n        }\n\n        if ($type === 'select' && $predefined) {\n            $field['fieldConfig']['layout']['config'] = $predefined->getConfig();\n            $result['layout'] = $field['fieldConfig']['layout'];\n        } elseif ($type === 'document' || $type === 'asset' || $type === 'object') {\n            $result['layout']['fieldtype'] = 'manyToOneRelation';\n            $result['layout']['subtype'] = $type;\n        }\n\n        return $result;\n    }\n\n    /**\n     * @param bool $noSystemColumns\n     * @param array $fields\n     * @param array $context\n     * @param array $types\n     *\n     * @return array\n     */\n    public function getDefaultGridFields($noSystemColumns, $fields, $context, $types = [])\n    {\n        $count = 0;\n        $availableFields = [];\n\n        if (!$noSystemColumns) {\n            foreach (Asset\\Service::GRID_SYSTEM_COLUMNS as $sc) {\n                if (empty($types)) {\n                    $availableFields[] = [\n                        'key' => $sc . '~system',\n                        'type' => 'system',\n                        'label' => $sc,\n                        'position' => $count, ];\n                    $count++;\n                }\n            }\n        }\n\n        return $availableFields;\n    }\n\n    /**\n     * @Route(\"/prepare-helper-column-configs\", name=\"pimcore_admin_asset_assethelper_preparehelpercolumnconfigs\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function prepareHelperColumnConfigs(Request $request)\n    {\n        $helperColumns = [];\n        $newData = [];\n        $data = json_decode($request->get('columns'));\n        /** @var \\stdClass $item */\n        foreach ($data as $item) {\n            if (!empty($item->isOperator)) {\n                $itemKey = '#' . uniqid();\n\n                $item->key = $itemKey;\n                $newData[] = $item;\n                $helperColumns[$itemKey] = $item;\n            } else {\n                $newData[] = $item;\n            }\n        }\n\n        Tool\\Session::useSession(function (AttributeBagInterface $session) use ($helperColumns) {\n            $existingColumns = $session->get('helpercolumns', []);\n            $helperColumns = array_merge($helperColumns, $existingColumns);\n            $session->set('helpercolumns', $helperColumns);\n        }, 'pimcore_gridconfig');\n\n        return $this->adminJson(['success' => true, 'columns' => $newData]);\n    }\n\n    /**\n     * @Route(\"/grid-mark-favourite-column-config\", name=\"pimcore_admin_asset_assethelper_gridmarkfavouritecolumnconfig\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function gridMarkFavouriteColumnConfigAction(Request $request)\n    {\n        $classId = $request->get('classId');\n        $asset = Asset::getById($classId);\n\n        if ($asset->isAllowed('list')) {\n            $gridConfigId = $request->get('gridConfigId');\n            $searchType = $request->get('searchType');\n            $type = $request->get('type');\n            $user = $this->getAdminUser();\n\n            $favourite = new GridConfigFavourite();\n            $favourite->setOwnerId($user->getId());\n            $favourite->setClassId($classId);\n            $favourite->setSearchType($searchType);\n            $favourite->setType($type);\n            $specializedConfigs = false;\n\n            try {\n                if ($gridConfigId != 0) {\n                    $gridConfig = GridConfig::getById($gridConfigId);\n                    $favourite->setGridConfigId($gridConfig->getId());\n                }\n\n                $favourite->setObjectId(0);\n                $favourite->save();\n            } catch (\\Exception $e) {\n                $favourite->delete();\n            }\n\n            return $this->adminJson(['success' => true, 'spezializedConfigs' => $specializedConfigs]);\n        }\n\n        throw $this->createAccessDeniedHttpException();\n    }\n\n    /**\n     * @param int $gridConfigId\n     *\n     * @return array\n     */\n    protected function getShareSettings($gridConfigId)\n    {\n        $result = [\n            'sharedUserIds' => [],\n            'sharedRoleIds' => [],\n        ];\n\n        $db = Db::get();\n        $allShares = $db->fetchAllAssociative('select s.sharedWithUserId, u.type from gridconfig_shares s, users u\n                      where s.sharedWithUserId = u.id and s.gridConfigId = ' . $gridConfigId);\n\n        if ($allShares) {\n            foreach ($allShares as $share) {\n                $type = $share['type'];\n                $key = 'shared' . ucfirst($type) . 'Ids';\n                $result[$key][] = $share['sharedWithUserId'];\n            }\n        }\n\n        foreach ($result as $idx => $value) {\n            $value = $value ? implode(',', $value) : '';\n            $result[$idx] = $value;\n        }\n\n        return $result;\n    }\n\n    /**\n     * @Route(\"/grid-save-column-config\", name=\"pimcore_admin_asset_assethelper_gridsavecolumnconfig\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function gridSaveColumnConfigAction(Request $request)\n    {\n        $asset = Asset::getById((int) $request->get('id'));\n\n        if (!$asset) {\n            throw $this->createNotFoundException();\n        }\n\n        if ($asset->isAllowed('list')) {\n            try {\n                $classId = $request->get('class_id');\n                $context = $request->get('context');\n\n                $searchType = $request->get('searchType');\n                $type = $request->get('type');\n\n                // grid config\n                $gridConfigData = $this->decodeJson($request->get('gridconfig'));\n                $gridConfigData['pimcore_version'] = Version::getVersion();\n                $gridConfigData['pimcore_revision'] = Version::getRevision();\n                $gridConfigData['context'] = $context;\n                unset($gridConfigData['settings']['isShared']);\n\n                $metadata = $request->get('settings');\n                $metadata = json_decode($metadata, true);\n\n                $gridConfigId = $metadata['gridConfigId'];\n                $gridConfig = GridConfig::getById($gridConfigId);\n\n                if ($gridConfig && $gridConfig->getOwnerId() != $this->getAdminUser()->getId()) {\n                    throw new \\Exception(\"don't mess around with somebody else's configuration\");\n                }\n\n                $this->updateGridConfigShares($gridConfig, $metadata);\n\n                if ($metadata['setAsFavourite'] && $this->getAdminUser()->isAdmin()) {\n                    $this->updateGridConfigFavourites($gridConfig, $metadata);\n                }\n\n                if (!$gridConfig) {\n                    $gridConfig = new GridConfig();\n                    $gridConfig->setName(date('c'));\n                    $gridConfig->setClassId($classId);\n                    $gridConfig->setSearchType($searchType);\n                    $gridConfig->setType($type);\n\n                    $gridConfig->setOwnerId($this->getAdminUser()->getId());\n                }\n\n                if ($metadata) {\n                    $gridConfig->setName($metadata['gridConfigName']);\n                    $gridConfig->setDescription($metadata['gridConfigDescription']);\n                    $gridConfig->setShareGlobally($metadata['shareGlobally'] && $this->getAdminUser()->isAdmin());\n                    $gridConfig->setSetAsFavourite($metadata['setAsFavourite'] && $this->getAdminUser()->isAdmin());\n                }\n\n                $gridConfigData = json_encode($gridConfigData);\n                $gridConfig->setConfig($gridConfigData);\n                $gridConfig->save();\n\n                $userId = $this->getAdminUser()->getId();\n\n                $availableConfigs = $this->getMyOwnGridColumnConfigs($userId, $classId, $searchType);\n                $sharedConfigs = $this->getSharedGridColumnConfigs($this->getAdminUser(), $classId, $searchType);\n\n                $settings = $this->getShareSettings($gridConfig->getId());\n                $settings['gridConfigId'] = (int)$gridConfig->getId();\n                $settings['gridConfigName'] = $gridConfig->getName();\n                $settings['gridConfigDescription'] = $gridConfig->getDescription();\n                $settings['shareGlobally'] = $gridConfig->isShareGlobally();\n                $settings['setAsFavourite'] = $gridConfig->isSetAsFavourite();\n                $settings['isShared'] = $gridConfig->getOwnerId() != $this->getAdminUser()->getId();\n\n                return $this->adminJson([\n                    'success' => true,\n                    'settings' => $settings,\n                    'availableConfigs' => $availableConfigs,\n                    'sharedConfigs' => $sharedConfigs,\n                ]);\n            } catch (\\Exception $e) {\n                return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n            }\n        }\n\n        throw $this->createAccessDeniedHttpException();\n    }\n\n    /**\n     * @param GridConfig|null $gridConfig\n     * @param array $metadata\n     *\n     * @throws \\Exception\n     */\n    protected function updateGridConfigShares($gridConfig, $metadata)\n    {\n        $user = $this->getAdminUser();\n        if (!$gridConfig || !$user->isAllowed('share_configurations')) {\n            // nothing to do\n            return;\n        }\n\n        if ($gridConfig->getOwnerId() != $this->getAdminUser()->getId()) {\n            throw new \\Exception(\"don't mess with someone elses grid config\");\n        }\n        $combinedShares = [];\n        $sharedUserIds = $metadata['sharedUserIds'];\n        $sharedRoleIds = $metadata['sharedRoleIds'];\n\n        if ($sharedUserIds) {\n            $combinedShares = explode(',', $sharedUserIds);\n        }\n\n        if ($sharedRoleIds) {\n            $sharedRoleIds = explode(',', $sharedRoleIds);\n            $combinedShares = array_merge($combinedShares, $sharedRoleIds);\n        }\n\n        $db = Db::get();\n        $db->delete('gridconfig_shares', ['gridConfigId' => $gridConfig->getId()]);\n\n        foreach ($combinedShares as $id) {\n            $share = new GridConfigShare();\n            $share->setGridConfigId($gridConfig->getId());\n            $share->setSharedWithUserId((int) $id);\n            $share->save();\n        }\n    }\n\n    /**\n     * @param GridConfig|null $gridConfig\n     * @param array $metadata\n     *\n     * @throws \\Exception\n     */\n    protected function updateGridConfigFavourites($gridConfig, $metadata)\n    {\n        $currentUser = $this->getAdminUser();\n\n        if (!$gridConfig || $currentUser === null || !$currentUser->isAllowed('share_configurations')) {\n            // nothing to do\n            return;\n        }\n\n        if (!$currentUser->isAdmin() && (int) $gridConfig->getOwnerId() !== $currentUser->getId()) {\n            throw new \\Exception(\"don't mess with someone elses grid config\");\n        }\n\n        $sharedUsers = [];\n\n        if ($metadata['shareGlobally'] === false) {\n            $sharedUserIds = $metadata['sharedUserIds'];\n\n            if ($sharedUserIds) {\n                $sharedUsers = explode(',', $sharedUserIds);\n            }\n        }\n\n        if ($metadata['shareGlobally'] === true) {\n            $users = new User\\Listing();\n            $users->setCondition('id = ?', $currentUser->getId());\n\n            foreach ($users as $user) {\n                $sharedUsers[] = $user->getId();\n            }\n        }\n\n        foreach ($sharedUsers as $id) {\n            // Check if the user has already a favourite\n            $favourite = GridConfigFavourite::getByOwnerAndClassAndObjectId(\n                (int) $id,\n                $gridConfig->getClassId(),\n                0,\n                $gridConfig->getSearchType()\n            );\n\n            if ($favourite instanceof GridConfigFavourite) {\n                $favouriteGridConfig = GridConfig::getById($favourite->getGridConfigId());\n\n                if ($favouriteGridConfig instanceof GridConfig) {\n                    // Check if the grid config was shared globally if that is *not* the case we also not update\n                    if ((bool) $favouriteGridConfig->isShareGlobally() === false) {\n                        continue;\n                    }\n\n                    // Check if the user is the owner. If that is the case we do not update the favourite\n                    if ((int) $favouriteGridConfig->getOwnerId() === (int) $id) {\n                        continue;\n                    }\n                }\n            }\n\n            $favourite = new GridConfigFavourite();\n            $favourite->setGridConfigId($gridConfig->getId());\n            $favourite->setClassId($gridConfig->getClassId());\n            $favourite->setObjectId(0);\n            $favourite->setOwnerId($id);\n            $favourite->setType($gridConfig->getType());\n            $favourite->setSearchType($gridConfig->getSearchType());\n            $favourite->save();\n        }\n    }\n\n    /**\n     * @Route(\"/get-export-jobs\", name=\"pimcore_admin_asset_assethelper_getexportjobs\", methods={\"POST\"})\n     *\n     * @param Request $request\n     * @param GridHelperService $gridHelperService\n     *\n     * @return JsonResponse\n     */\n    public function getExportJobsAction(Request $request, GridHelperService $gridHelperService)\n    {\n        $allParams = array_merge($request->request->all(), $request->query->all());\n        $list = $gridHelperService->prepareAssetListingForGrid($allParams, $this->getAdminUser());\n\n        if (empty($ids = $allParams['ids'] ?? '')) {\n            $ids = $list->loadIdList();\n        }\n\n        $jobs = array_chunk($ids, 20);\n\n        $fileHandle = uniqid('asset-export-');\n        $storage = Storage::get('temp');\n        $storage->write($this->getCsvFile($fileHandle), '');\n\n        return $this->adminJson(['success' => true, 'jobs' => $jobs, 'fileHandle' => $fileHandle]);\n    }\n\n    /**\n     * @Route(\"/do-export\", name=\"pimcore_admin_asset_assethelper_doexport\", methods={\"POST\"})\n     *\n     * @param Request $request\n     * @param LocaleServiceInterface $localeService\n     *\n     * @return JsonResponse\n     */\n    public function doExportAction(Request $request, LocaleServiceInterface $localeService)\n    {\n        $fileHandle = \\Pimcore\\File::getValidFilename($request->get('fileHandle'));\n        $ids = $request->get('ids');\n        $settings = $request->get('settings');\n        $settings = json_decode($settings, true);\n        $delimiter = $settings['delimiter'] ?? ';';\n        $language = str_replace('default', '', $request->get('language'));\n\n        $list = new Asset\\Listing();\n\n        $quotedIds = [];\n        foreach ($ids as $id) {\n            $quotedIds[] = $list->quote($id);\n        }\n\n        $list->setCondition('id IN (' . implode(',', $quotedIds) . ')');\n        $list->setOrderKey(' FIELD(id, ' . implode(',', $quotedIds) . ')', false);\n\n        $fields = $request->get('fields');\n\n        $addTitles = $request->get('initial');\n\n        $csv = $this->getCsvData($request, $language, $list, $fields, $addTitles);\n\n        $storage = Storage::get('temp');\n        $csvFile = $this->getCsvFile($fileHandle);\n\n        $fileStream = $storage->readStream($csvFile);\n\n        $temp = tmpfile();\n        stream_copy_to_stream($fileStream, $temp, null, 0);\n\n        $firstLine = true;\n        foreach ($csv as $line) {\n            if ($addTitles && $firstLine) {\n                $firstLine = false;\n                $line = implode($delimiter, $line) . \"\\r\\n\";\n                fwrite($temp, $line);\n            } else {\n                fwrite($temp, implode($delimiter, array_map([$this, 'encodeFunc'], $line)) . \"\\r\\n\");\n            }\n        }\n\n        $storage->writeStream($csvFile, $temp);\n\n        return $this->adminJson(['success' => true]);\n    }\n\n    public function encodeFunc($value)\n    {\n        $value = str_replace('\"', '\"\"', $value);\n        //force wrap value in quotes and return\n        return '\"' . $value . '\"';\n    }\n\n    /**\n     * @param Request $request\n     * @param string $language\n     * @param Asset\\Listing $list\n     * @param array $fields\n     * @param bool $addTitles\n     *\n     * @return array\n     */\n    protected function getCsvData(Request $request, $language, $list, $fields, $addTitles = true)\n    {\n        //create csv\n        $csv = [];\n\n        $unsupportedFields = ['preview~system', 'size~system'];\n        $fields = array_diff($fields, $unsupportedFields);\n\n        if ($addTitles) {\n            $columns = $fields;\n            foreach ($columns as $columnIdx => $columnKey) {\n                $columns[$columnIdx] = '\"' . $columnKey . '\"';\n            }\n            $csv[] = $columns;\n        }\n\n        foreach ($list->load() as $asset) {\n            if ($fields) {\n                $dataRows = [];\n                foreach ($fields as $field) {\n                    $fieldDef = explode('~', $field);\n                    $getter = 'get' . ucfirst($fieldDef[0]);\n\n                    if (isset($fieldDef[1])) {\n                        if ($fieldDef[1] == 'system' && method_exists($asset, $getter)) {\n                            $data = $asset->$getter($language);\n                        } else {\n                            $fieldDef[1] = str_replace('none', '', $fieldDef[1]);\n                            $data = $asset->getMetadata($fieldDef[0], $fieldDef[1], true);\n                        }\n                    } else {\n                        $data = $asset->getMetadata($field, $language, true);\n                    }\n\n                    if ($data instanceof Element\\ElementInterface) {\n                        $data = $data->getRealFullPath();\n                    }\n                    $dataRows[] = $data;\n                }\n                $dataRows = Element\\Service::escapeCsvRecord($dataRows);\n                $csv[] = $dataRows;\n            }\n        }\n\n        return $csv;\n    }\n\n    /**\n     * @param Request $request\n     *\n     * @return string\n     */\n    protected function extractLanguage(Request $request)\n    {\n        $requestedLanguage = $request->get('language');\n        if ($requestedLanguage) {\n            if ($requestedLanguage != 'default') {\n                $request->setLocale($requestedLanguage);\n            }\n        } else {\n            $requestedLanguage = $request->getLocale();\n        }\n\n        return $requestedLanguage;\n    }\n\n    /**\n     * @param string $fileHandle\n     *\n     * @return string\n     */\n    protected function getCsvFile($fileHandle)\n    {\n        return $fileHandle . '.csv';\n    }\n\n    /**\n     * @Route(\"/download-csv-file\", name=\"pimcore_admin_asset_assethelper_downloadcsvfile\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function downloadCsvFileAction(Request $request)\n    {\n        $storage = Storage::get('temp');\n        $fileHandle = \\Pimcore\\File::getValidFilename($request->get('fileHandle'));\n        $csvFile = $this->getCsvFile($fileHandle);\n\n        try {\n            $csvData = $storage->read($csvFile);\n            $response = new Response($csvData);\n            $response->headers->set('Content-Type', 'application/csv');\n            $disposition = HeaderUtils::makeDisposition(\n                HeaderUtils::DISPOSITION_ATTACHMENT,\n                'export.csv'\n            );\n\n            $response->headers->set('Content-Disposition', $disposition);\n            $storage->delete($csvFile);\n\n            return $response;\n        } catch (FilesystemException | UnableToReadFile $exception) {\n            // handle the error\n            throw $this->createNotFoundException('CSV file not found');\n        }\n    }\n\n    /**\n     * @Route(\"/download-xlsx-file\", name=\"pimcore_admin_asset_assethelper_downloadxlsxfile\", methods={\"GET\"})\n     *\n     * @param Request $request\n     * @param GridHelperService $gridHelperService\n     *\n     * @return BinaryFileResponse\n     */\n    public function downloadXlsxFileAction(Request $request, GridHelperService $gridHelperService)\n    {\n        $storage = Storage::get('temp');\n        $fileHandle = \\Pimcore\\File::getValidFilename($request->get('fileHandle'));\n        $csvFile = $this->getCsvFile($fileHandle);\n\n        try {\n            return $gridHelperService->createXlsxExportFile($storage, $fileHandle, $csvFile);\n        } catch (\\Exception | FilesystemException | UnableToReadFile $exception) {\n            // handle the error\n            throw $this->createNotFoundException('XLSX file not found');\n        }\n    }\n\n    /**\n     * @Route(\"/get-metadata-for-column-config\", name=\"pimcore_admin_asset_assethelper_getmetadataforcolumnconfig\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getMetadataForColumnConfigAction(Request $request)\n    {\n        $result = [];\n\n        //default metadata\n        $defaultMetadataNames = ['copyright', 'alt', 'title'];\n        foreach ($defaultMetadataNames as $defaultMetadata) {\n            $defaultColumns[] = ['title' => $defaultMetadata, 'name' => $defaultMetadata, 'datatype' => 'data', 'fieldtype' => 'input'];\n        }\n        $result['defaultColumns']['nodeLabel'] = 'default_metadata';\n        $result['defaultColumns']['nodeType'] = 'image';\n        $result['defaultColumns']['children'] = $defaultColumns;\n\n        //predefined metadata\n        $list = Metadata\\Predefined\\Listing::getByTargetType('asset');\n        $metadataItems = [];\n        $tmp = [];\n        foreach ($list as $item) {\n            //only allow unique metadata columns with subtypes\n            $uniqueKey = $item->getName().'_'.$item->getTargetSubtype();\n            if (!in_array($uniqueKey, $tmp) && !in_array($item->getName(), $defaultMetadataNames)) {\n                $tmp[] = $uniqueKey;\n                $item->expand();\n                $metadataItems[] = [\n                    'title' => $item->getName(),\n                    'name' => $item->getName(),\n                    'subtype' => $item->getTargetSubtype(),\n                    'datatype' => 'data',\n                    'fieldtype' => $item->getType(),\n                    'config' => $item->getConfig(),\n                ];\n            }\n        }\n\n        $result['metadataColumns']['children'] = $metadataItems;\n        $result['metadataColumns']['nodeLabel'] = 'predefined_metadata';\n        $result['metadataColumns']['nodeType'] = 'metadata';\n\n        //system columns\n        $systemColumnNames = Asset\\Service::GRID_SYSTEM_COLUMNS;\n        $systemColumns = [];\n        foreach ($systemColumnNames as $systemColumn) {\n            $systemColumns[] = ['title' => $systemColumn, 'name' => $systemColumn, 'datatype' => 'data', 'fieldtype' => 'system'];\n        }\n        $result['systemColumns']['nodeLabel'] = 'system_columns';\n        $result['systemColumns']['nodeType'] = 'system';\n        $result['systemColumns']['children'] = $systemColumns;\n\n        return $this->adminJson($result);\n    }\n\n    /**\n     * @Route(\"/get-batch-jobs\", name=\"pimcore_admin_asset_assethelper_getbatchjobs\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getBatchJobsAction(Request $request, GridHelperService $gridHelperService)\n    {\n        if ($request->get('language')) {\n            $request->setLocale($request->get('language'));\n        }\n\n        $allParams = array_merge($request->request->all(), $request->query->all());\n        $list = $gridHelperService->prepareAssetListingForGrid($allParams, $this->getAdminUser());\n\n        $jobs = $list->loadIdList();\n\n        return $this->adminJson(['success' => true, 'jobs' => $jobs]);\n    }\n\n    /**\n     * @Route(\"/batch\", name=\"pimcore_admin_asset_assethelper_batch\", methods={\"PUT\"})\n     *\n     * @param Request $request\n     * @param EventDispatcherInterface $eventDispatcher\n     *\n     * @return JsonResponse\n     */\n    public function batchAction(Request $request, EventDispatcherInterface $eventDispatcher)\n    {\n        try {\n            if ($request->get('data')) {\n                $loader = \\Pimcore::getContainer()->get('pimcore.implementation_loader.asset.metadata.data');\n\n                $data = $this->decodeJson($request->get('data'), true);\n\n                $updateEvent = new GenericEvent($this, [\n                    'data' => $data,\n                    'processed' => false,\n                ]);\n\n                $eventDispatcher->dispatch($updateEvent, AdminEvents::ASSET_LIST_BEFORE_BATCH_UPDATE);\n\n                $processed = $updateEvent->getArgument('processed');\n\n                if ($processed) {\n                    return $this->adminJson(['success' => true]);\n                }\n\n                $language = null;\n                if (isset($data['language'])) {\n                    $language = $data['language'] != 'default' ? $data['language'] : null;\n                }\n\n                $asset = Asset::getById($data['job']);\n\n                if ($asset) {\n                    if (!$asset->isAllowed('publish')) {\n                        throw new \\Exception(\"Permission denied. You don't have the rights to save this asset.\");\n                    }\n\n                    $metadata = $asset->getMetadata(null, null, false, true);\n                    $dirty = false;\n\n                    $name = $data['name'];\n                    $value = $data['value'];\n\n                    if ($data['valueType'] == 'object') {\n                        $value = $this->decodeJson($value);\n                    }\n\n                    $fieldDef = explode('~', $name);\n                    $name = $fieldDef[0];\n                    if (count($fieldDef) > 1) {\n                        $language = ($fieldDef[1] == 'none' ? '' : $fieldDef[1]);\n                    }\n\n                    foreach ($metadata as $idx => &$em) {\n                        if ($em['name'] == $name && $em['language'] == $language) {\n                            try {\n                                $dataImpl = $loader->build($em['type']);\n                                $value = $dataImpl->getDataFromListfolderGrid($value, $em);\n                            } catch (UnsupportedException $le) {\n                                Logger::error('could not resolve metadata implementation for ' . $em['type']);\n                            }\n                            $em['data'] = $value;\n                            $dirty = true;\n\n                            break;\n                        }\n                    }\n\n                    if (!$dirty) {\n                        $defaulMetadata = ['title', 'alt', 'copyright'];\n                        if (in_array($name, $defaulMetadata)) {\n                            $newEm = [\n                                'name' => $name,\n                                'language' => $language,\n                                'type' => 'input',\n                                'data' => $value,\n                            ];\n\n                            try {\n                                $dataImpl = $loader->build($newEm['type']);\n                                $newEm['data'] = $dataImpl->getDataFromListfolderGrid($value, $newEm);\n                            } catch (UnsupportedException $le) {\n                                Logger::error('could not resolve metadata implementation for ' . $newEm['type']);\n                            }\n\n                            $metadata[] = $newEm;\n                            $dirty = true;\n                        } else {\n                            $predefined = Metadata\\Predefined::getByName($name);\n                            if ($predefined && (empty($predefined->getTargetSubtype())\n                                    || $predefined->getTargetSubtype() == $asset->getType())) {\n                                $newEm = [\n                                    'name' => $name,\n                                    'language' => $language,\n                                    'type' => $predefined->getType(),\n                                    'data' => $value,\n                                ];\n\n                                try {\n                                    $dataImpl = $loader->build($newEm['type']);\n                                    $newEm['data'] = $dataImpl->getDataFromListfolderGrid($value, $newEm);\n                                } catch (UnsupportedException $le) {\n                                    Logger::error('could not resolve metadata implementation for ' . $newEm['type']);\n                                }\n\n                                $metadata[] = $newEm;\n\n                                $dirty = true;\n                            }\n                        }\n                    }\n\n                    try {\n                        if ($dirty) {\n                            // $metadata = Asset\\Service::minimizeMetadata($metadata, \"grid\");\n                            $asset->setMetadataRaw($metadata);\n                            $asset->save();\n\n                            return $this->adminJson(['success' => true]);\n                        }\n                    } catch (\\Exception $e) {\n                        return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n                    }\n                } else {\n                    Logger::debug('AssetHelperController::batchAction => There is no asset left to update.');\n\n                    return $this->adminJson(['success' => false, 'message' => 'AssetHelperController::batchAction => There is no asset left to update.']);\n                }\n            }\n        } catch (\\Exception $e) {\n            Logger::err($e);\n\n            return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n        }\n\n        return $this->adminJson(['success' => false, 'message' => 'something went wrong.']);\n    }\n}\n", "<?php\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\Bundle\\AdminBundle\\Controller\\Admin\\DataObject;\n\nuse League\\Flysystem\\FilesystemException;\nuse League\\Flysystem\\UnableToReadFile;\nuse PhpOffice\\PhpSpreadsheet\\Reader\\Csv;\nuse PhpOffice\\PhpSpreadsheet\\Writer\\Xlsx;\nuse Pimcore\\Bundle\\AdminBundle\\Controller\\AdminController;\nuse Pimcore\\Bundle\\AdminBundle\\Helper\\GridHelperService;\nuse Pimcore\\Config;\nuse Pimcore\\Db;\nuse Pimcore\\Event\\AdminEvents;\nuse Pimcore\\File;\nuse Pimcore\\Localization\\LocaleServiceInterface;\nuse Pimcore\\Logger;\nuse Pimcore\\Model\\DataObject;\nuse Pimcore\\Model\\GridConfig;\nuse Pimcore\\Model\\GridConfigFavourite;\nuse Pimcore\\Model\\GridConfigShare;\nuse Pimcore\\Model\\User;\nuse Pimcore\\Tool;\nuse Pimcore\\Tool\\Storage;\nuse Pimcore\\Version;\nuse Symfony\\Component\\EventDispatcher\\GenericEvent;\nuse Symfony\\Component\\HttpFoundation\\BinaryFileResponse;\nuse Symfony\\Component\\HttpFoundation\\HeaderUtils;\nuse Symfony\\Component\\HttpFoundation\\JsonResponse;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpFoundation\\Session\\Attribute\\AttributeBagInterface;\nuse Symfony\\Component\\Routing\\Annotation\\Route;\nuse Symfony\\Contracts\\EventDispatcher\\EventDispatcherInterface;\n\n/**\n * @Route(\"/object-helper\", name=\"pimcore_admin_dataobject_dataobjecthelper_\")\n *\n * @internal\n */\nclass DataObjectHelperController extends AdminController\n{\n    const SYSTEM_COLUMNS = ['id', 'fullpath', 'key', 'published', 'creationDate', 'modificationDate', 'filename', 'classname'];\n\n    /**\n     * @Route(\"/load-object-data\", name=\"loadobjectdata\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function loadObjectDataAction(Request $request)\n    {\n        $object = DataObject::getById((int) $request->get('id'));\n        $result = [];\n        if ($object) {\n            $result['success'] = true;\n            $fields = $request->get('fields');\n            $result['fields'] = DataObject\\Service::gridObjectData($object, $fields);\n        } else {\n            $result['success'] = false;\n        }\n\n        return $this->adminJson($result);\n    }\n\n    /**\n     * @param int $userId\n     * @param string $classId\n     * @param string|null $searchType\n     *\n     * @return array\n     */\n    public function getMyOwnGridColumnConfigs($userId, $classId, $searchType = null)\n    {\n        $db = Db::get();\n        $configListingConditionParts = [];\n        $configListingConditionParts[] = 'ownerId = ' . $userId;\n        $configListingConditionParts[] = 'classId = ' . $db->quote($classId);\n\n        if ($searchType) {\n            $configListingConditionParts[] = 'searchType = ' . $db->quote($searchType);\n        }\n\n        $configCondition = implode(' AND ', $configListingConditionParts);\n        $configListing = new GridConfig\\Listing();\n        $configListing->setOrderKey('name');\n        $configListing->setOrder('ASC');\n        $configListing->setCondition($configCondition);\n        $configListing = $configListing->load();\n\n        $configData = [];\n        if (is_array($configListing)) {\n            foreach ($configListing as $config) {\n                $configData[] = $config->getObjectVars();\n            }\n        }\n\n        return $configData;\n    }\n\n    /**\n     * @param User $user\n     * @param string $classId\n     * @param string $searchType\n     *\n     * @return array\n     */\n    public function getSharedGridColumnConfigs($user, $classId, $searchType = null)\n    {\n        $configListing = [];\n\n        $userIds = [$user->getId()];\n        // collect all roles\n        $userIds = array_merge($userIds, $user->getRoles());\n        $userIds = implode(',', $userIds);\n        $db = Db::get();\n\n        $query = 'select distinct c1.id from gridconfigs c1, gridconfig_shares s\n                    where (c1.searchType = ' . $db->quote($searchType) . ' and ((c1.id = s.gridConfigId and s.sharedWithUserId IN (' . $userIds . '))) and c1.classId = ' . $db->quote($classId) . ')\n                            UNION distinct select c2.id from gridconfigs c2 where shareGlobally = 1 and c2.classId = '. $db->quote($classId) . '  and c2.ownerId != ' . $db->quote($user->getId());\n\n        $ids = $db->fetchFirstColumn($query);\n\n        if ($ids) {\n            $ids = implode(',', $ids);\n            $configListing = new GridConfig\\Listing();\n            $configListing->setOrderKey('name');\n            $configListing->setOrder('ASC');\n            $configListing->setCondition('id in (' . $ids . ')');\n            $configListing = $configListing->load();\n        }\n\n        $configData = [];\n        if (is_array($configListing)) {\n            foreach ($configListing as $config) {\n                $configData[] = $config->getObjectVars();\n            }\n        }\n\n        return $configData;\n    }\n\n    /**\n     * @Route(\"/get-export-configs\", name=\"getexportconfigs\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getExportConfigsAction(Request $request)\n    {\n        $classId = $request->get('classId');\n        $list = $this->getMyOwnGridColumnConfigs($this->getAdminUser()->getId(), $classId);\n        if (!is_array($list)) {\n            $list = [];\n        }\n        $list = array_merge($list, $this->getSharedGridColumnConfigs($this->getAdminUser(), $classId));\n        $result = [];\n\n        $result[] = [\n            'id' => -1,\n            'name' => '--default--',\n        ];\n\n        if ($list) {\n            /** @var GridConfig $config */\n            foreach ($list as $config) {\n                $result[] = [\n                    'id' => $config['id'],\n                    'name' => $config['name'],\n                ];\n            }\n        }\n\n        return $this->adminJson(['success' => true, 'data' => $result]);\n    }\n\n    /**\n     * @Route(\"/grid-delete-column-config\", name=\"griddeletecolumnconfig\", methods={\"DELETE\"})\n     *\n     * @param Request $request\n     * @param EventDispatcherInterface $eventDispatcher\n     * @param Config $config\n     *\n     * @return JsonResponse\n     */\n    public function gridDeleteColumnConfigAction(Request $request, EventDispatcherInterface $eventDispatcher, Config $config)\n    {\n        $gridConfigId = $request->get('gridConfigId');\n        $gridConfig = GridConfig::getById($gridConfigId);\n        $success = false;\n        if ($gridConfig) {\n            if ($gridConfig->getOwnerId() != $this->getAdminUser()->getId() && !$this->getAdminUser()->isAdmin()) {\n                throw new \\Exception(\"don't mess with someone elses grid config\");\n            }\n\n            $gridConfig->delete();\n            $success = true;\n        }\n\n        $newGridConfig = $this->doGetGridColumnConfig($request, $config, true);\n        $newGridConfig['deleteSuccess'] = $success;\n\n        $event = new GenericEvent($this, [\n            'data' => $newGridConfig,\n            'request' => $request,\n            'config' => $config,\n            'context' => 'delete',\n        ]);\n\n        $eventDispatcher->dispatch($event, AdminEvents::OBJECT_GRID_GET_COLUMN_CONFIG_PRE_SEND_DATA);\n        $newGridConfig = $event->getArgument('data');\n\n        return $this->adminJson($newGridConfig);\n    }\n\n    /**\n     * @Route(\"/grid-get-column-config\", name=\"gridgetcolumnconfig\", methods={\"GET\"})\n     *\n     * @param Request $request\n     * @param EventDispatcherInterface $eventDispatcher\n     * @param Config $config\n     *\n     * @return JsonResponse\n     */\n    public function gridGetColumnConfigAction(Request $request, EventDispatcherInterface $eventDispatcher, Config $config)\n    {\n        $result = $this->doGetGridColumnConfig($request, $config);\n\n        $event = new GenericEvent($this, [\n            'data' => $result,\n            'request' => $request,\n            'config' => $config,\n            'context' => 'get',\n        ]);\n\n        $eventDispatcher->dispatch($event, AdminEvents::OBJECT_GRID_GET_COLUMN_CONFIG_PRE_SEND_DATA);\n        $result = $event->getArgument('data');\n\n        return $this->adminJson($result);\n    }\n\n    /**\n     * @param Request $request\n     * @param Config $config\n     * @param bool $isDelete\n     *\n     * @return array\n     */\n    public function doGetGridColumnConfig(Request $request, Config $config, $isDelete = false)\n    {\n        $class = null;\n        $fields = null;\n\n        if ($request->get('id')) {\n            $class = DataObject\\ClassDefinition::getById($request->get('id'));\n        } elseif ($request->get('name')) {\n            $class = DataObject\\ClassDefinition::getByName($request->get('name'));\n        }\n\n        $gridConfigId = null;\n        $gridType = 'search';\n        if ($request->get('gridtype')) {\n            $gridType = $request->get('gridtype');\n        }\n\n        $objectId = (int) $request->get('objectId');\n\n        if ($objectId) {\n            $fields = DataObject\\Service::getCustomGridFieldDefinitions($class->getId(), $objectId);\n        }\n\n        $context = ['purpose' => 'gridconfig'];\n        if ($class) {\n            $context['class'] = $class;\n        }\n\n        if ($objectId) {\n            $object = DataObject::getById($objectId);\n            $context['object'] = $object;\n        }\n\n        if (!$fields && $class) {\n            $fields = $class->getFieldDefinitions();\n        }\n\n        $types = [];\n        if ($request->get('types')) {\n            $types = explode(',', $request->get('types'));\n        }\n\n        $userId = $this->getAdminUser()->getId();\n\n        $requestedGridConfigId = $isDelete ? null : $request->get('gridConfigId');\n\n        // grid config\n        $gridConfig = [];\n        $searchType = $request->get('searchType');\n\n        if (strlen($requestedGridConfigId) == 0 && $class) {\n            // check if there is a favourite view\n            $favourite = GridConfigFavourite::getByOwnerAndClassAndObjectId($userId, $class->getId(), $objectId ?: 0, $searchType);\n            if (!$favourite && $objectId) {\n                $favourite = GridConfigFavourite::getByOwnerAndClassAndObjectId($userId, $class->getId(), 0, $searchType);\n            }\n\n            if ($favourite) {\n                $requestedGridConfigId = $favourite->getGridConfigId();\n            }\n        }\n\n        if (is_numeric($requestedGridConfigId) && $requestedGridConfigId > 0) {\n            $db = Db::get();\n            $savedGridConfig = GridConfig::getById((int) $requestedGridConfigId);\n\n            if ($savedGridConfig) {\n                $shared = false;\n                if (!$this->getAdminUser()->isAdmin()) {\n                    $userIds = [$this->getAdminUser()->getId()];\n                    if ($this->getAdminUser()->getRoles()) {\n                        $userIds = array_merge($userIds, $this->getAdminUser()->getRoles());\n                    }\n                    $userIds = implode(',', $userIds);\n                    $shared = ($savedGridConfig->getOwnerId() != $userId && $savedGridConfig->isShareGlobally()) || $db->fetchOne('select 1 from gridconfig_shares where sharedWithUserId IN ('.$userIds.') and gridConfigId = '.$savedGridConfig->getId());\n                    //                  $shared = $savedGridConfig->isShareGlobally() || GridConfigShare::getByGridConfigAndSharedWithId($savedGridConfig->getId(), $this->getUser()->getId());\n\n                    if (!$shared && $savedGridConfig->getOwnerId() != $this->getAdminUser()->getId()) {\n                        throw new \\Exception('You are neither the owner of this config nor it is shared with you');\n                    }\n                }\n\n                $gridConfigId = $savedGridConfig->getId();\n                $gridConfig = $savedGridConfig->getConfig();\n                $gridConfig = json_decode($gridConfig, true);\n                $gridConfigName = $savedGridConfig->getName();\n                $owner = $savedGridConfig->getOwnerId();\n                $ownerObject = User::getById($owner);\n                if ($ownerObject instanceof User) {\n                    $owner = $ownerObject->getName();\n                }\n                $modificationDate = $savedGridConfig->getModificationDate();\n                $gridConfigDescription = $savedGridConfig->getDescription();\n                $sharedGlobally = $savedGridConfig->isShareGlobally();\n                $setAsFavourite = $savedGridConfig->isSetAsFavourite();\n            }\n        }\n\n        $localizedFields = [];\n        $objectbrickFields = [];\n        if (is_array($fields)) {\n            foreach ($fields as $key => $field) {\n                if ($field instanceof DataObject\\ClassDefinition\\Data\\Localizedfields) {\n                    $localizedFields[] = $field;\n                } elseif ($field instanceof DataObject\\ClassDefinition\\Data\\Objectbricks) {\n                    $objectbrickFields[] = $field;\n                }\n            }\n        }\n\n        $availableFields = [];\n\n        if (empty($gridConfig)) {\n            $availableFields = $this->getDefaultGridFields(\n                $request->get('no_system_columns'),\n                $class,\n                $gridType,\n                $request->get('no_brick_columns'),\n                $fields,\n                $context,\n                $objectId,\n                $types);\n        } else {\n            $savedColumns = $gridConfig['columns'];\n            foreach ($savedColumns as $key => $sc) {\n                if (!$sc['hidden']) {\n                    if (in_array($key, self::SYSTEM_COLUMNS)) {\n                        $colConfig = [\n                            'key' => $key,\n                            'type' => 'system',\n                            'label' => $key,\n                            'locked' => $sc['locked'] ?? null,\n                            'position' => $sc['position'],\n                        ];\n                        if (isset($sc['width'])) {\n                            $colConfig['width'] = $sc['width'];\n                        }\n                        $availableFields[] = $colConfig;\n                    } else {\n                        $keyParts = explode('~', $key);\n\n                        if (substr($key, 0, 1) == '~') {\n                            // not needed for now\n                            $type = $keyParts[1];\n                            //                            $field = $keyParts[2];\n                            $groupAndKeyId = explode('-', $keyParts[3]);\n                            $keyId = (int) $groupAndKeyId[1];\n\n                            if ($type == 'classificationstore') {\n                                $keyDef = DataObject\\Classificationstore\\KeyConfig::getById($keyId);\n                                if ($keyDef) {\n                                    $keyFieldDef = json_decode($keyDef->getDefinition(), true);\n                                    if ($keyFieldDef) {\n                                        $keyFieldDef = \\Pimcore\\Model\\DataObject\\Classificationstore\\Service::getFieldDefinitionFromJson($keyFieldDef, $keyDef->getType());\n                                        $fieldConfig = $this->getFieldGridConfig($keyFieldDef, $gridType, $sc['position'], true, null, $class, $objectId);\n                                        if ($fieldConfig) {\n                                            $fieldConfig['key'] = $key;\n                                            $fieldConfig['label'] = '#' . $keyFieldDef->getTitle();\n                                            if (isset($sc['locked'])) {\n                                                $fieldConfig['locked'] = $sc['locked'];\n                                            }\n                                            $availableFields[] = $fieldConfig;\n                                        }\n                                    }\n                                }\n                            }\n                        } elseif (count($keyParts) > 1) {\n                            $brick = $keyParts[0];\n                            $brickDescriptor = null;\n\n                            if (strpos($brick, '?') !== false) {\n                                $brickDescriptor = substr($brick, 1);\n                                $brickDescriptor = json_decode($brickDescriptor, true);\n                                $keyPrefix = $brick . '~';\n                                $brick = $brickDescriptor['containerKey'];\n                            } else {\n                                $keyPrefix = $brick . '~';\n                            }\n\n                            $fieldname = $keyParts[1];\n\n                            $brickClass = DataObject\\Objectbrick\\Definition::getByKey($brick);\n\n                            $fd = null;\n                            if ($brickClass instanceof DataObject\\Objectbrick\\Definition) {\n                                if ($brickDescriptor) {\n                                    $innerContainer = $brickDescriptor['innerContainer'] ?? 'localizedfields';\n                                    /** @var DataObject\\ClassDefinition\\Data\\Localizedfields $localizedFields */\n                                    $localizedFields = $brickClass->getFieldDefinition($innerContainer);\n                                    $fd = $localizedFields->getFieldDefinition($brickDescriptor['brickfield']);\n                                } else {\n                                    $fd = $brickClass->getFieldDefinition($fieldname);\n                                }\n                            }\n\n                            if ($fd !== null) {\n                                $fieldConfig = $this->getFieldGridConfig($fd, $gridType, $sc['position'], true, $keyPrefix, $class, $objectId);\n                                if (!empty($fieldConfig)) {\n                                    if (isset($sc['width'])) {\n                                        $fieldConfig['width'] = $sc['width'];\n                                    }\n                                    if (isset($sc['locked'])) {\n                                        $fieldConfig['locked'] = $sc['locked'];\n                                    }\n                                    $availableFields[] = $fieldConfig;\n                                }\n                            }\n                        } else {\n                            if (DataObject\\Service::isHelperGridColumnConfig($key)) {\n                                $calculatedColumnConfig = $this->getCalculatedColumnConfig($savedColumns[$key]);\n                                if ($calculatedColumnConfig) {\n                                    $availableFields[] = $calculatedColumnConfig;\n                                }\n                            } else {\n                                $fd = $class->getFieldDefinition($key);\n                                //if not found, look for localized fields\n                                if (empty($fd)) {\n                                    foreach ($localizedFields as $lf) {\n                                        $fd = $lf->getFieldDefinition($key);\n                                        if (!empty($fd)) {\n                                            break;\n                                        }\n                                    }\n                                }\n\n                                if (!empty($fd)) {\n                                    $fieldConfig = $this->getFieldGridConfig($fd, $gridType, $sc['position'], true, null, $class, $objectId);\n                                    if (!empty($fieldConfig)) {\n                                        if (isset($sc['width'])) {\n                                            $fieldConfig['width'] = $sc['width'];\n                                        }\n                                        if (isset($sc['locked'])) {\n                                            $fieldConfig['locked'] = $sc['locked'];\n                                        }\n                                        $availableFields[] = $fieldConfig;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        usort($availableFields, function ($a, $b) {\n            if ($a['position'] == $b['position']) {\n                return 0;\n            }\n\n            return ($a['position'] < $b['position']) ? -1 : 1;\n        });\n\n        $frontendLanguages = Tool\\Admin::reorderWebsiteLanguages(\\Pimcore\\Tool\\Admin::getCurrentUser(), $config['general']['valid_languages']);\n        if ($frontendLanguages) {\n            $language = explode(',', $frontendLanguages)[0];\n        } else {\n            $language = $request->getLocale();\n        }\n\n        if (!Tool::isValidLanguage($language)) {\n            $validLanguages = Tool::getValidLanguages();\n            $language = $validLanguages[0];\n        }\n\n        if (!empty($gridConfig) && !empty($gridConfig['language'])) {\n            $language = $gridConfig['language'];\n        }\n\n        $availableConfigs = $class ? $this->getMyOwnGridColumnConfigs($userId, $class->getId(), $searchType) : [];\n        $sharedConfigs = $class ? $this->getSharedGridColumnConfigs($this->getAdminUser(), $class->getId(), $searchType) : [];\n        $settings = $this->getShareSettings((int)$gridConfigId);\n        $settings['gridConfigId'] = (int)$gridConfigId;\n        $settings['gridConfigName'] = $gridConfigName ?? null;\n        $settings['gridConfigDescription'] = $gridConfigDescription ?? null;\n        $settings['owner'] = $owner ?? null;\n        $settings['modificationDate'] = $modificationDate ?? null;\n        $settings['shareGlobally'] = $sharedGlobally ?? null;\n        $settings['setAsFavourite'] = $setAsFavourite ?? null;\n        $settings['isShared'] = !$gridConfigId || ($shared ?? null);\n\n        $context = $gridConfig['context'] ?? null;\n        if ($context) {\n            $context = json_decode($context, true);\n        }\n\n        return [\n            'sortinfo' => $gridConfig['sortinfo'] ?? false,\n            'language' => $language,\n            'availableFields' => $availableFields,\n            'settings' => $settings,\n            'onlyDirectChildren' => $gridConfig['onlyDirectChildren'] ?? false,\n            'pageSize' => $gridConfig['pageSize'] ?? false,\n            'availableConfigs' => $availableConfigs,\n            'sharedConfigs' => $sharedConfigs,\n            'context' => $context,\n            'sqlFilter' => $gridConfig['sqlFilter'] ?? '',\n            'searchFilter' => $gridConfig['searchFilter'] ?? '',\n        ];\n    }\n\n    /**\n     * @param bool $noSystemColumns\n     * @param DataObject\\ClassDefinition|null $class\n     * @param string $gridType\n     * @param bool $noBrickColumns\n     * @param DataObject\\ClassDefinition\\Data[] $fields\n     * @param array $context\n     * @param int $objectId\n     * @param array $types\n     *\n     * @return array\n     */\n    public function getDefaultGridFields($noSystemColumns, $class, $gridType, $noBrickColumns, $fields, $context, $objectId, $types = [])\n    {\n        $count = 0;\n        $availableFields = [];\n\n        if (!$noSystemColumns && $class) {\n            $vis = $class->getPropertyVisibility();\n            foreach (self::SYSTEM_COLUMNS as $sc) {\n                $key = $sc;\n                if ($key === 'fullpath') {\n                    $key = 'path';\n                }\n\n                if (empty($types) && (!empty($vis[$gridType][$key]) || $gridType === 'all')) {\n                    $availableFields[] = [\n                        'key' => $sc,\n                        'type' => 'system',\n                        'label' => $sc,\n                        'position' => $count, ];\n                    $count++;\n                }\n            }\n        }\n\n        $includeBricks = !$noBrickColumns;\n\n        if (is_array($fields)) {\n            foreach ($fields as $key => $field) {\n                if ($field instanceof DataObject\\ClassDefinition\\Data\\Localizedfields) {\n                    foreach ($field->getFieldDefinitions($context) as $fd) {\n                        if (empty($types) || in_array($fd->getFieldType(), $types)) {\n                            $fieldConfig = $this->getFieldGridConfig($fd, $gridType, $count, false, null, $class, $objectId);\n                            if (!empty($fieldConfig)) {\n                                $availableFields[] = $fieldConfig;\n                                $count++;\n                            }\n                        }\n                    }\n                } elseif ($field instanceof DataObject\\ClassDefinition\\Data\\Objectbricks && $includeBricks) {\n                    if (in_array($field->getFieldType(), $types)) {\n                        $fieldConfig = $this->getFieldGridConfig($field, $gridType, $count, false, null, $class, $objectId);\n                        if (!empty($fieldConfig)) {\n                            $availableFields[] = $fieldConfig;\n                            $count++;\n                        }\n                    } else {\n                        $allowedTypes = $field->getAllowedTypes();\n                        if (!empty($allowedTypes)) {\n                            foreach ($allowedTypes as $t) {\n                                $brickClass = DataObject\\Objectbrick\\Definition::getByKey($t);\n                                $brickFields = $brickClass->getFieldDefinitions($context);\n\n                                $this->appendBrickFields($field, $brickFields, $availableFields, $gridType, $count, $t, $class, $objectId);\n                            }\n                        }\n                    }\n                } else {\n                    if (empty($types) || in_array($field->getFieldType(), $types)) {\n                        $fieldConfig = $this->getFieldGridConfig($field, $gridType, $count, !empty($types), null, $class, $objectId);\n                        if (!empty($fieldConfig)) {\n                            $availableFields[] = $fieldConfig;\n                            $count++;\n                        }\n                    }\n                }\n            }\n        }\n\n        return $availableFields;\n    }\n\n    /**\n     * @param DataObject\\ClassDefinition\\Data $field\n     * @param DataObject\\ClassDefinition\\Data[] $brickFields\n     * @param array $availableFields\n     * @param string $gridType\n     * @param int $count\n     * @param string $brickType\n     * @param DataObject\\ClassDefinition $class\n     * @param int $objectId\n     * @param array|null $context\n     */\n    protected function appendBrickFields($field, $brickFields, &$availableFields, $gridType, &$count, $brickType, $class, $objectId, $context = null)\n    {\n        if (!empty($brickFields)) {\n            foreach ($brickFields as $bf) {\n                if ($bf instanceof DataObject\\ClassDefinition\\Data\\Localizedfields) {\n                    $localizedFieldDefinitions = $bf->getFieldDefinitions();\n\n                    $localizedContext = [\n                        'containerKey' => $brickType,\n                        'fieldname' => $field->getName(),\n                    ];\n\n                    $this->appendBrickFields($bf, $localizedFieldDefinitions, $availableFields, $gridType, $count, $brickType, $class, $objectId, $localizedContext);\n                } else {\n                    if ($context) {\n                        $context['brickfield'] = $bf->getName();\n                        $keyPrefix = '?' . json_encode($context) . '~';\n                    } else {\n                        $keyPrefix = $brickType . '~';\n                    }\n                    $fieldConfig = $this->getFieldGridConfig($bf, $gridType, $count, false, $keyPrefix, $class, $objectId);\n                    if (!empty($fieldConfig)) {\n                        $availableFields[] = $fieldConfig;\n                        $count++;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @param array $config\n     *\n     * @return mixed\n     */\n    protected function getCalculatedColumnConfig($config)\n    {\n        try {\n            $calculatedColumnConfig = Tool\\Session::useSession(function (AttributeBagInterface $session) use ($config) {\n                //otherwise create a new one\n\n                $calculatedColumn = [];\n                // note that we have to generate a new key!\n\n                $existingKey = $config['fieldConfig']['key'];\n                $calculatedColumnConfig['key'] = $existingKey;\n                $calculatedColumnConfig['position'] = $config['position'];\n                $calculatedColumnConfig['isOperator'] = true;\n                $calculatedColumnConfig['attributes'] = $config['fieldConfig']['attributes'];\n                $calculatedColumnConfig['width'] = $config['width'];\n                $calculatedColumnConfig['locked'] = $config['locked'];\n\n                $existingColumns = $session->get('helpercolumns', []);\n\n                if (isset($existingColumns[$existingKey])) {\n                    // if the configuration is still in the session, then reuse it\n                    return $calculatedColumnConfig;\n                }\n\n                $newKey = '#' . uniqid();\n                $calculatedColumnConfig['key'] = $newKey;\n\n                // prepare a column config on the fly\n                $phpConfig = json_encode($config['fieldConfig']);\n                $phpConfig = json_decode($phpConfig);\n                $helperColumns = [];\n                $helperColumns[$newKey] = $phpConfig;\n\n                $helperColumns = array_merge($helperColumns, $existingColumns);\n                $session->set('helpercolumns', $helperColumns);\n\n                return $calculatedColumnConfig;\n            }, 'pimcore_gridconfig');\n\n            return $calculatedColumnConfig;\n        } catch (\\Exception $e) {\n            Logger::error((string) $e);\n        }\n    }\n\n    /**\n     * @Route(\"/prepare-helper-column-configs\", name=\"preparehelpercolumnconfigs\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function prepareHelperColumnConfigs(Request $request)\n    {\n        $helperColumns = [];\n        $newData = [];\n        /** @var \\stdClass[] $data */\n        $data = json_decode($request->get('columns'));\n        foreach ($data as $item) {\n            if (!empty($item->isOperator)) {\n                $itemKey = '#' . uniqid();\n\n                $item->key = $itemKey;\n                $newData[] = $item;\n                $helperColumns[$itemKey] = $item;\n            } else {\n                $newData[] = $item;\n            }\n        }\n\n        Tool\\Session::useSession(function (AttributeBagInterface $session) use ($helperColumns) {\n            $existingColumns = $session->get('helpercolumns', []);\n            $helperColumns = array_merge($helperColumns, $existingColumns);\n            $session->set('helpercolumns', $helperColumns);\n        }, 'pimcore_gridconfig');\n\n        return $this->adminJson(['success' => true, 'columns' => $newData]);\n    }\n\n    /**\n     * @Route(\"/grid-config-apply-to-all\", name=\"gridconfigapplytoall\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function gridConfigApplyToAllAction(Request $request)\n    {\n        $objectId = $request->get('objectId');\n        $object = DataObject::getById($objectId);\n\n        if ($object->isAllowed('list')) {\n            $classId = $request->get('classId');\n            $searchType = $request->get('searchType');\n            $user = $this->getAdminUser();\n            $db = Db::get();\n            $db->executeQuery('delete from gridconfig_favourites where '\n                . 'ownerId = ' . $user->getId()\n                . ' and classId = ' . $db->quote($classId) .\n                ' and searchType = ' . $db->quote($searchType)\n                . ' and objectId != ' . $objectId . ' and objectId != 0');\n\n            return $this->adminJson(['success' => true]);\n        }\n\n        throw $this->createAccessDeniedHttpException();\n    }\n\n    /**\n     * @Route(\"/grid-mark-favourite-column-config\", name=\"gridmarkfavouritecolumnconfig\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function gridMarkFavouriteColumnConfigAction(Request $request)\n    {\n        $objectId = $request->get('objectId');\n        $object = DataObject::getById($objectId);\n\n        if ($object->isAllowed('list')) {\n            $classId = $request->get('classId');\n            $gridConfigId = $request->get('gridConfigId');\n            $searchType = $request->get('searchType');\n            $global = $request->get('global');\n            $user = $this->getAdminUser();\n            $type = $request->get('type');\n\n            $favourite = new GridConfigFavourite();\n            $favourite->setOwnerId($user->getId());\n            $class = DataObject\\ClassDefinition::getById($classId);\n            if (!$class) {\n                throw new \\Exception('class ' . $classId . ' does not exist anymore');\n            }\n            $favourite->setClassId($classId);\n            $favourite->setSearchType($searchType);\n            $favourite->setType($type);\n            $specializedConfigs = false;\n\n            try {\n                if ($gridConfigId != 0) {\n                    $gridConfig = GridConfig::getById($gridConfigId);\n                    $favourite->setGridConfigId($gridConfig->getId());\n                }\n                $favourite->setObjectId($objectId);\n                $favourite->save();\n\n                if ($global) {\n                    $favourite->setObjectId(0);\n                    $favourite->save();\n                }\n                $db = Db::get();\n                $count = $db->fetchOne('select * from gridconfig_favourites where '\n                    . 'ownerId = ' . $user->getId()\n                    . ' and classId = ' . $db->quote($classId).\n                    ' and searchType = ' . $db->quote($searchType)\n                    . ' and objectId != ' . $objectId . ' and objectId != 0'\n                    . ' and type != ' . $db->quote($type));\n                $specializedConfigs = $count > 0;\n            } catch (\\Exception $e) {\n                $favourite->delete();\n            }\n\n            return $this->adminJson(['success' => true, 'spezializedConfigs' => $specializedConfigs]);\n        }\n\n        throw $this->createAccessDeniedHttpException();\n    }\n\n    /**\n     * @param int $gridConfigId\n     *\n     * @return array\n     */\n    protected function getShareSettings($gridConfigId)\n    {\n        $result = [\n            'sharedUserIds' => [],\n            'sharedRoleIds' => [],\n        ];\n\n        $db = Db::get();\n        $allShares = $db->fetchAllAssociative('select s.sharedWithUserId, u.type from gridconfig_shares s, users u\n                      where s.sharedWithUserId = u.id and s.gridConfigId = ' . $gridConfigId);\n\n        if ($allShares) {\n            foreach ($allShares as $share) {\n                $type = $share['type'];\n                $key = 'shared' . ucfirst($type) . 'Ids';\n                $result[$key][] = $share['sharedWithUserId'];\n            }\n        }\n\n        foreach ($result as $idx => $value) {\n            $value = $value ? implode(',', $value) : '';\n            $result[$idx] = $value;\n        }\n\n        return $result;\n    }\n\n    /**\n     * @Route(\"/grid-save-column-config\", name=\"gridsavecolumnconfig\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function gridSaveColumnConfigAction(Request $request)\n    {\n        $objectId = $request->get('id');\n        $object   = DataObject::getById($objectId);\n\n        if ($object->isAllowed('list')) {\n            try {\n                $classId = $request->get('class_id');\n                $context = $request->get('context');\n\n                $searchType = $request->get('searchType');\n\n                // grid config\n                $gridConfigData = $this->decodeJson($request->get('gridconfig'));\n                $gridConfigData['pimcore_version'] = Version::getVersion();\n                $gridConfigData['pimcore_revision'] = Version::getRevision();\n\n                $gridConfigData['context'] = $context;\n\n                unset($gridConfigData['settings']['isShared']);\n\n                $metadata = $request->get('settings');\n                $metadata = json_decode($metadata, true);\n\n                $gridConfigId = $metadata['gridConfigId'];\n                $gridConfig = GridConfig::getById($gridConfigId);\n\n                if ($gridConfig && $gridConfig->getOwnerId() != $this->getAdminUser()->getId() && !$this->getAdminUser()->isAdmin()) {\n                    throw new \\Exception(\"don't mess around with somebody elses configuration\");\n                }\n\n                $this->updateGridConfigShares($gridConfig, $metadata);\n\n                if ($metadata['setAsFavourite'] && $this->getAdminUser()->isAdmin()) {\n                    $this->updateGridConfigFavourites($gridConfig, $metadata, $objectId);\n                }\n\n                if (!$gridConfig) {\n                    $gridConfig = new GridConfig();\n                    $gridConfig->setName(date('c'));\n                    $gridConfig->setClassId($classId);\n                    $gridConfig->setSearchType($searchType);\n\n                    $gridConfig->setOwnerId($this->getAdminUser()->getId());\n                }\n\n                if ($metadata) {\n                    $gridConfig->setName($metadata['gridConfigName']);\n                    $gridConfig->setDescription($metadata['gridConfigDescription']);\n                    $gridConfig->setShareGlobally($metadata['shareGlobally'] && $this->getAdminUser()->isAdmin());\n                    $gridConfig->setSetAsFavourite($metadata['setAsFavourite'] && $this->getAdminUser()->isAdmin());\n                }\n\n                $gridConfigData = json_encode($gridConfigData);\n                $gridConfig->setConfig($gridConfigData);\n                $gridConfig->save();\n\n                $userId = $this->getAdminUser()->getId();\n\n                $availableConfigs = $this->getMyOwnGridColumnConfigs($userId, $classId, $searchType);\n                $sharedConfigs = $this->getSharedGridColumnConfigs($this->getAdminUser(), $classId, $searchType);\n\n                $settings = $this->getShareSettings($gridConfig->getId());\n                $settings['gridConfigId'] = (int)$gridConfig->getId();\n                $settings['gridConfigName'] = $gridConfig->getName();\n                $settings['gridConfigDescription'] = $gridConfig->getDescription();\n                $settings['shareGlobally'] = $gridConfig->isShareGlobally();\n                $settings['setAsFavourite'] = $gridConfig->isSetAsFavourite();\n                $settings['isShared'] = $gridConfig->getOwnerId() != $this->getAdminUser()->getId() && !$this->getAdminUser()->isAdmin();\n\n                return $this->adminJson([\n                    'success' => true,\n                    'settings' => $settings,\n                    'availableConfigs' => $availableConfigs,\n                    'sharedConfigs' => $sharedConfigs,\n                ]);\n            } catch (\\Exception $e) {\n                return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n            }\n        }\n\n        throw $this->createAccessDeniedHttpException();\n    }\n\n    /**\n     * @param GridConfig|null $gridConfig\n     * @param array $metadata\n     *\n     * @throws \\Exception\n     */\n    protected function updateGridConfigShares($gridConfig, $metadata)\n    {\n        $user = $this->getAdminUser();\n        if (!$gridConfig || !$user->isAllowed('share_configurations')) {\n            // nothing to do\n            return;\n        }\n\n        if ($gridConfig->getOwnerId() != $user->getId() && !$user->isAdmin()) {\n            throw new \\Exception(\"don't mess with someone elses grid config\");\n        }\n        $combinedShares = [];\n        $sharedUserIds = $metadata['sharedUserIds'];\n        $sharedRoleIds = $metadata['sharedRoleIds'];\n\n        if ($sharedUserIds) {\n            $combinedShares = explode(',', $sharedUserIds);\n        }\n\n        if ($sharedRoleIds) {\n            $sharedRoleIds = explode(',', $sharedRoleIds);\n            $combinedShares = array_merge($combinedShares, $sharedRoleIds);\n        }\n\n        $db = Db::get();\n        $db->delete('gridconfig_shares', ['gridConfigId' => $gridConfig->getId()]);\n\n        foreach ($combinedShares as $id) {\n            $share = new GridConfigShare();\n            $share->setGridConfigId($gridConfig->getId());\n            $share->setSharedWithUserId((int) $id);\n            $share->save();\n        }\n    }\n\n    /**\n     * @param GridConfig|null $gridConfig\n     * @param array $metadata\n     * @param int $objectId\n     *\n     * @throws \\Exception\n     */\n    protected function updateGridConfigFavourites($gridConfig, $metadata, $objectId)\n    {\n        $currentUser = $this->getAdminUser();\n\n        if (!$gridConfig || $currentUser === null || !$currentUser->isAllowed('share_configurations')) {\n            // nothing to do\n            return;\n        }\n\n        if (!$currentUser->isAdmin() && (int) $gridConfig->getOwnerId() !== $currentUser->getId()) {\n            throw new \\Exception(\"don't mess with someone elses grid config\");\n        }\n\n        $sharedUsers = [];\n\n        if ($metadata['shareGlobally'] === false) {\n            $sharedUserIds = $metadata['sharedUserIds'];\n\n            if ($sharedUserIds) {\n                $sharedUsers = explode(',', $sharedUserIds);\n            }\n        }\n\n        if ($metadata['shareGlobally'] === true) {\n            $users = new User\\Listing();\n            $users->setCondition('id = ?', $currentUser->getId());\n\n            foreach ($users as $user) {\n                $sharedUsers[] = $user->getId();\n            }\n        }\n\n        foreach ($sharedUsers as $id) {\n            $global    = true;\n            $favourite = GridConfigFavourite::getByOwnerAndClassAndObjectId(\n                (int) $id,\n                $gridConfig->getClassId(),\n                (int) $objectId,\n                $gridConfig->getSearchType()\n            );\n\n            // If the user has already a favourite for that object we check the current favourite and decide if we update\n            if ($favourite instanceof GridConfigFavourite) {\n                $favouriteGridConfig = GridConfig::getById($favourite->getGridConfigId());\n\n                if ($favouriteGridConfig instanceof GridConfig) {\n                    // Check if the grid config was shared globally if that is *not* the case we also not update\n                    if ((bool) $favouriteGridConfig->isShareGlobally() === false) {\n                        continue;\n                    }\n\n                    // Check if the user is the owner. If that is the case we do not update the favourite\n                    if ((int) $favouriteGridConfig->getOwnerId() === (int) $id) {\n                        continue;\n                    }\n                }\n            }\n\n            // Check if the user has already a global favourite then we do not save the favourite as global\n            $favourite = GridConfigFavourite::getByOwnerAndClassAndObjectId(\n                (int) $id,\n                $gridConfig->getClassId(),\n                0,\n                $gridConfig->getSearchType()\n            );\n\n            if ($favourite instanceof GridConfigFavourite) {\n                $favouriteGridConfig = GridConfig::getById($favourite->getGridConfigId());\n\n                if ($favouriteGridConfig instanceof GridConfig) {\n                    // Check if the grid config was shared globally if that is *not* the case we also not update\n                    if ($favouriteGridConfig->isShareGlobally() === false) {\n                        $global = false;\n                    }\n\n                    // Check if the user is the owner. If that is the case we do not update the global favourite\n                    if ($favouriteGridConfig->getOwnerId() === (int) $id) {\n                        $global = false;\n                    }\n                }\n            }\n\n            $favourite = new GridConfigFavourite();\n            $favourite->setGridConfigId($gridConfig->getId());\n            $favourite->setClassId($gridConfig->getClassId());\n            $favourite->setObjectId($objectId);\n            $favourite->setOwnerId($id);\n            $favourite->setType($gridConfig->getType());\n            $favourite->setSearchType($gridConfig->getSearchType());\n            $favourite->save();\n\n            if ($global === true) {\n                $favourite->setObjectId(0);\n                $favourite->save();\n            }\n        }\n    }\n\n    /**\n     * @param DataObject\\ClassDefinition\\Data $field\n     * @param string $gridType\n     * @param string $position\n     * @param bool $force\n     * @param string|null $keyPrefix\n     * @param DataObject\\ClassDefinition|null $class\n     * @param int|null $objectId\n     *\n     * @return array|null\n     */\n    protected function getFieldGridConfig($field, $gridType, $position, $force = false, $keyPrefix = null, $class = null, $objectId = null)\n    {\n        $key = $keyPrefix . $field->getName();\n        $config = null;\n        $title = $field->getName();\n        if (method_exists($field, 'getTitle')) {\n            if ($field->getTitle()) {\n                $title = $field->getTitle();\n            }\n        }\n\n        if ($field instanceof DataObject\\ClassDefinition\\Data\\Slider) {\n            $config['minValue'] = $field->getMinValue();\n            $config['maxValue'] = $field->getMaxValue();\n            $config['increment'] = $field->getIncrement();\n        }\n\n        if (method_exists($field, 'getWidth')) {\n            $config['width'] = $field->getWidth();\n        }\n        if (method_exists($field, 'getHeight')) {\n            $config['height'] = $field->getHeight();\n        }\n\n        $visible = false;\n        if ($gridType == 'search') {\n            $visible = $field->getVisibleSearch();\n        } elseif ($gridType == 'grid') {\n            $visible = $field->getVisibleGridView();\n        } elseif ($gridType == 'all') {\n            $visible = true;\n        }\n\n        if (!$field->getInvisible() && ($force || $visible)) {\n            $context = ['purpose' => 'gridconfig'];\n            if ($class) {\n                $context['class'] = $class;\n            }\n\n            if ($objectId) {\n                $object = DataObject::getById($objectId);\n                $context['object'] = $object;\n            }\n            DataObject\\Service::enrichLayoutDefinition($field, null, $context);\n\n            $result = [\n                'key' => $key,\n                'type' => $field->getFieldType(),\n                'label' => $title,\n                'config' => $config,\n                'layout' => $field,\n                'position' => $position,\n            ];\n\n            if ($field instanceof DataObject\\ClassDefinition\\Data\\EncryptedField) {\n                $result['delegateDatatype'] = $field->getDelegateDatatype();\n            }\n\n            return $result;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * IMPORTER\n     */\n\n    /**\n     * @Route(\"/import-upload\", name=\"importupload\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function importUploadAction(Request $request)\n    {\n        $data = file_get_contents($_FILES['Filedata']['tmp_name']);\n        $data = Tool\\Text::convertToUTF8($data);\n\n        $importId = $request->get('importId');\n        $importId = str_replace('..', '', $importId);\n        $importFile = PIMCORE_SYSTEM_TEMP_DIRECTORY . '/import_' . $importId;\n        File::put($importFile, $data);\n\n        $importFileOriginal = PIMCORE_SYSTEM_TEMP_DIRECTORY . '/import_' . $importId . '_original';\n        File::put($importFileOriginal, $data);\n\n        $response = $this->adminJson([\n            'success' => true,\n        ]);\n\n        // set content-type to text/html, otherwise (when application/json is sent) chrome will complain in\n        // Ext.form.Action.Submit and mark the submission as failed\n        $response->headers->set('Content-Type', 'text/html');\n\n        return $response;\n    }\n\n    private function getDataPreview($originalFile, $dialect)\n    {\n        $count = 0;\n        $data = [];\n        if (($handle = fopen($originalFile, 'r')) !== false) {\n            while (($rowData = fgetcsv($handle, 0, $dialect->delimiter, $dialect->quotechar, $dialect->escapechar)) !== false) {\n                $tmpData = [];\n\n                foreach ($rowData as $key => $value) {\n                    $tmpData['field_' . $key] = $value;\n                }\n\n                $tmpData['rowId'] = $count + 1;\n                $data[] = $tmpData;\n\n                $count++;\n\n                /**\n                 * Reached the number or rows for the preview\n                 */\n                if ($count > 18) {\n                    break;\n                }\n            }\n            fclose($handle);\n        }\n\n        return $data;\n    }\n\n    /**\n     * @param Request $request\n     *\n     * @return string\n     */\n    protected function extractLanguage(Request $request)\n    {\n        $requestedLanguage = $request->get('language');\n        if ($requestedLanguage) {\n            if ($requestedLanguage != 'default') {\n                $request->setLocale($requestedLanguage);\n            }\n        } else {\n            $requestedLanguage = $request->getLocale();\n        }\n\n        return $requestedLanguage;\n    }\n\n    /**\n     * @param string $fileHandle\n     *\n     * @return string\n     */\n    protected function getCsvFile($fileHandle)\n    {\n        return $fileHandle . '.csv';\n    }\n\n    /**\n     * @Route(\"/get-export-jobs\", name=\"getexportjobs\", methods={\"POST\"})\n     *\n     * @param Request $request\n     * @param GridHelperService $gridHelperService\n     * @param EventDispatcherInterface $eventDispatcher\n     *\n     * @return JsonResponse\n     */\n    public function getExportJobsAction(Request $request, GridHelperService $gridHelperService, EventDispatcherInterface $eventDispatcher)\n    {\n        $requestedLanguage = $this->extractLanguage($request);\n        $allParams = array_merge($request->request->all(), $request->query->all());\n\n        $list = $gridHelperService->prepareListingForGrid($allParams, $requestedLanguage, $this->getAdminUser());\n\n        $beforeListPrepareEvent = new GenericEvent($this, [\n            'list' => $list,\n            'context' => $allParams,\n        ]);\n        $eventDispatcher->dispatch($beforeListPrepareEvent, AdminEvents::OBJECT_LIST_BEFORE_EXPORT_PREPARE);\n\n        $list = $beforeListPrepareEvent->getArgument('list');\n\n        $ids = $list->loadIdList();\n\n        $jobs = array_chunk($ids, 20);\n\n        $fileHandle = uniqid('export-');\n\n        $storage = Storage::get('temp');\n        $storage->write($this->getCsvFile($fileHandle), '');\n\n        return $this->adminJson(['success' => true, 'jobs' => $jobs, 'fileHandle' => $fileHandle]);\n    }\n\n    /**\n     * @Route(\"/do-export\", name=\"doexport\", methods={\"POST\"})\n     *\n     * @param Request $request\n     * @param LocaleServiceInterface $localeService\n     * @param EventDispatcherInterface $eventDispatcher\n     *\n     * @return JsonResponse\n     *\n     * @throws \\Exception\n     */\n    public function doExportAction(Request $request, LocaleServiceInterface $localeService, EventDispatcherInterface $eventDispatcher)\n    {\n        $fileHandle = \\Pimcore\\File::getValidFilename($request->get('fileHandle'));\n        $ids = $request->get('ids');\n        $settings = $request->get('settings');\n        $settings = json_decode($settings, true);\n        $delimiter = $settings['delimiter'] ?? ';';\n\n        $allParams = array_merge($request->request->all(), $request->query->all());\n\n        $enableInheritance = $settings['enableInheritance'] ?? null;\n        DataObject\\Concrete::setGetInheritedValues($enableInheritance);\n\n        $class = DataObject\\ClassDefinition::getById($request->get('classId'));\n\n        if (!$class) {\n            throw new \\Exception('No class definition found');\n        }\n\n        $className = $class->getName();\n        $listClass = '\\\\Pimcore\\\\Model\\\\DataObject\\\\' . ucfirst($className) . '\\\\Listing';\n\n        /** @var \\Pimcore\\Model\\DataObject\\Listing $list */\n        $list = new $listClass();\n\n        $quotedIds = [];\n        foreach ($ids as $id) {\n            $quotedIds[] = $list->quote($id);\n        }\n\n        $list->setObjectTypes(DataObject::$types);\n        $list->setCondition('o_id IN (' . implode(',', $quotedIds) . ')');\n        $list->setOrderKey(' FIELD(o_id, ' . implode(',', $quotedIds) . ')', false);\n\n        $beforeListExportEvent = new GenericEvent($this, [\n            'list' => $list,\n            'context' => $allParams,\n        ]);\n        $eventDispatcher->dispatch($beforeListExportEvent, AdminEvents::OBJECT_LIST_BEFORE_EXPORT);\n\n        $list = $beforeListExportEvent->getArgument('list');\n\n        $fields = $request->get('fields');\n\n        $addTitles = (bool) $request->get('initial');\n\n        $requestedLanguage = $this->extractLanguage($request);\n\n        $contextFromRequest = $request->get('context');\n        if ($contextFromRequest) {\n            $contextFromRequest = json_decode($contextFromRequest, true);\n        }\n\n        $context = [\n            'source' => 'pimcore-export',\n        ];\n\n        if (is_array($contextFromRequest)) {\n            $context = array_merge($context, $contextFromRequest);\n        }\n\n        $csv = DataObject\\Service::getCsvData($requestedLanguage, $localeService, $list, $fields, $addTitles, $context);\n\n        $storage = Storage::get('temp');\n        $csvFile = $this->getCsvFile($fileHandle);\n\n        $fileStream = $storage->readStream($csvFile);\n\n        $temp = tmpfile();\n        stream_copy_to_stream($fileStream, $temp, null, 0);\n\n        $firstLine = true;\n        $lineCount = count($csv);\n\n        if (!$addTitles && $lineCount > 0) {\n            fwrite($temp, \"\\r\\n\");\n        }\n\n        for ($i = 0; $i < $lineCount; $i++) {\n            $line = $csv[$i];\n            if ($addTitles && $firstLine) {\n                $firstLine = false;\n                $line = implode($delimiter, $line);\n                fwrite($temp, $line);\n            } else {\n                fwrite($temp, implode($delimiter, array_map([$this, 'encodeFunc'], $line)));\n            }\n            if ($i < $lineCount - 1) {\n                fwrite($temp, \"\\r\\n\");\n            }\n        }\n        $storage->writeStream($csvFile, $temp);\n\n        return $this->adminJson(['success' => true]);\n    }\n\n    public function encodeFunc($value)\n    {\n        $value = str_replace('\"', '\"\"', $value);\n        //force wrap value in quotes and return\n        return '\"' . $value . '\"';\n    }\n\n    /**\n     * @Route(\"/download-csv-file\", name=\"downloadcsvfile\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function downloadCsvFileAction(Request $request)\n    {\n        $storage = Storage::get('temp');\n        $fileHandle = \\Pimcore\\File::getValidFilename($request->get('fileHandle'));\n        $csvFile = $this->getCsvFile($fileHandle);\n\n        try {\n            $csvData = $storage->read($csvFile);\n            $response = new Response($csvData);\n            $response->headers->set('Content-Type', 'application/csv');\n            $disposition = HeaderUtils::makeDisposition(\n                HeaderUtils::DISPOSITION_ATTACHMENT,\n                'export.csv'\n            );\n\n            $response->headers->set('Content-Disposition', $disposition);\n            $storage->delete($csvFile);\n\n            return $response;\n        } catch (FilesystemException | UnableToReadFile $exception) {\n            // handle the error\n            throw $this->createNotFoundException('CSV file not found');\n        }\n    }\n\n    /**\n     * @Route(\"/download-xlsx-file\", name=\"downloadxlsxfile\", methods={\"GET\"})\n     *\n     * @param Request $request\n     * @param GridHelperService $gridHelperService\n     *\n     * @return BinaryFileResponse\n     */\n    public function downloadXlsxFileAction(Request $request, GridHelperService $gridHelperService)\n    {\n        $storage = Storage::get('temp');\n        $fileHandle = \\Pimcore\\File::getValidFilename($request->get('fileHandle'));\n        $csvFile = $this->getCsvFile($fileHandle);\n\n        try {\n            return $gridHelperService->createXlsxExportFile($storage, $fileHandle, $csvFile);\n        } catch (\\Exception | FilesystemException | UnableToReadFile $exception) {\n            // handle the error\n            throw $this->createNotFoundException('XLSX file not found');\n        }\n    }\n\n    /**\n     * Flattens object data to an array with key=>value where\n     * value is simply a string representation of the value (for objects, hrefs and assets the full path is used)\n     *\n     * @param DataObject\\Concrete $object\n     *\n     * @return array\n     */\n    protected function csvObjectData($object)\n    {\n        $o = [];\n        foreach ($object->getClass()->getFieldDefinitions() as $key => $value) {\n            $o[$key] = $value->getForCsvExport($object);\n        }\n\n        $o['id (system)'] = $object->getId();\n        $o['key (system)'] = $object->getKey();\n        $o['fullpath (system)'] = $object->getRealFullPath();\n        $o['published (system)'] = $object->isPublished();\n        $o['type (system)'] = $object->getType();\n\n        return $o;\n    }\n\n    /**\n     * @Route(\"/get-batch-jobs\", name=\"getbatchjobs\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getBatchJobsAction(Request $request, GridHelperService $gridHelperService)\n    {\n        if ($request->get('language')) {\n            $request->setLocale($request->get('language'));\n        }\n\n        $allParams = array_merge($request->request->all(), $request->query->all());\n        $list = $gridHelperService->prepareListingForGrid($allParams, $request->getLocale(), $this->getAdminUser());\n\n        $jobs = $list->loadIdList();\n\n        return $this->adminJson(['success' => true, 'jobs' => $jobs]);\n    }\n\n    /**\n     * @Route(\"/batch\", name=\"batch\", methods={\"PUT\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function batchAction(Request $request)\n    {\n        $success = true;\n\n        try {\n            if ($request->get('data')) {\n                $params = $this->decodeJson($request->get('data'), true);\n                $object = DataObject\\Concrete::getById($params['job']);\n\n                if ($object) {\n                    $name = $params['name'];\n\n                    if (!$object->isAllowed('save') || ($name === 'published' && !$object->isAllowed('publish'))) {\n                        throw new \\Exception(\"Permission denied. You don't have the rights to save this object.\");\n                    }\n\n                    $append = $params['append'] ?? false;\n                    $remove = $params['remove'] ?? false;\n\n                    $className = $object->getClassName();\n                    $class = DataObject\\ClassDefinition::getByName($className);\n                    $value = $params['value'];\n                    if ($params['valueType'] == 'object') {\n                        $value = $this->decodeJson($value);\n                    }\n\n                    $parts = explode('~', $name);\n\n                    if (substr($name, 0, 1) == '~') {\n                        $type = $parts[1];\n                        $field = $parts[2];\n                        $keyId = $parts[3];\n\n                        if ($type == 'classificationstore') {\n                            $requestedLanguage = $params['language'];\n                            if ($requestedLanguage) {\n                                if ($requestedLanguage != 'default') {\n                                    $request->setLocale($requestedLanguage);\n                                }\n                            } else {\n                                $requestedLanguage = $request->getLocale();\n                            }\n\n                            $groupKeyId = explode('-', $keyId);\n                            $groupId = (int) $groupKeyId[0];\n                            $keyId = (int) $groupKeyId[1];\n\n                            $getter = 'get' . ucfirst($field);\n                            if (method_exists($object, $getter)) {\n                                /** @var DataObject\\ClassDefinition\\Data\\Classificationstore $csFieldDefinition */\n                                $csFieldDefinition = $object->getClass()->getFieldDefinition($field);\n                                $csLanguage = $requestedLanguage;\n                                if (!$csFieldDefinition->isLocalized()) {\n                                    $csLanguage = 'default';\n                                }\n\n                                /** @var DataObject\\ClassDefinition\\Data\\Classificationstore $fd */\n                                $fd = $class->getFieldDefinition($field);\n                                $keyConfig = $fd->getKeyConfiguration($keyId);\n                                $dataDefinition = DataObject\\Classificationstore\\Service::getFieldDefinitionFromKeyConfig($keyConfig);\n\n                                /** @var DataObject\\Classificationstore $classificationStoreData */\n                                $classificationStoreData = $object->$getter();\n                                if ($append) {\n                                    $oldValue = $classificationStoreData->getLocalizedKeyValue($groupId, $keyId);\n                                    $value = $dataDefinition->appendData($oldValue, $value);\n                                }\n                                if ($remove) {\n                                    $oldValue = $classificationStoreData->getLocalizedKeyValue($groupId, $keyId);\n                                    $value = $dataDefinition->removeData($oldValue, $value);\n                                }\n                                $classificationStoreData->setLocalizedKeyValue(\n                                    $groupId,\n                                    $keyId,\n                                    $dataDefinition->getDataFromEditmode($value),\n                                    $csLanguage\n                                );\n                            }\n                        }\n                    } elseif (count($parts) > 1) {\n                        // check for bricks\n                        $brickType = $parts[0];\n                        $brickKey = $parts[1];\n                        $brickField = DataObject\\Service::getFieldForBrickType($object->getClass(), $brickType);\n\n                        $fieldGetter = 'get' . ucfirst($brickField);\n                        $brickGetter = 'get' . ucfirst($brickType);\n                        $valueSetter = 'set' . ucfirst($brickKey);\n\n                        $brick = $object->$fieldGetter()->$brickGetter();\n                        if (empty($brick)) {\n                            $classname = '\\\\Pimcore\\\\Model\\\\DataObject\\\\Objectbrick\\\\Data\\\\' . ucfirst($brickType);\n                            $brickSetter = 'set' . ucfirst($brickType);\n                            $brick = new $classname($object);\n                            $object->$fieldGetter()->$brickSetter($brick);\n                        }\n\n                        $brickClass = DataObject\\Objectbrick\\Definition::getByKey($brickType);\n                        $field = $brickClass->getFieldDefinition($brickKey);\n\n                        $newData = $field->getDataFromEditmode($value, $object);\n\n                        if ($append) {\n                            $valueGetter = 'get' . ucfirst($brickKey);\n                            $existingData = $brick->$valueGetter();\n                            $newData = $field->appendData($existingData, $newData);\n                        }\n                        if ($remove) {\n                            $valueGetter = 'get' . ucfirst($brickKey);\n                            $existingData = $brick->$valueGetter();\n                            $newData = $field->removeData($existingData, $newData);\n                        }\n                        $brick->$valueSetter($newData);\n                    } else {\n                        // everything else\n                        $field = $class->getFieldDefinition($name);\n                        if ($field) {\n                            $newData = $field->getDataFromEditmode($value, $object);\n\n                            if ($append) {\n                                $existingData = $object->{'get' . $name}();\n                                $newData = $field->appendData($existingData, $newData);\n                            }\n                            if ($remove) {\n                                $existingData = $object->{'get' . $name}();\n                                $newData = $field->removeData($existingData, $newData);\n                            }\n                            $object->setValue($name, $newData);\n                        } else {\n                            // check if it is a localized field\n                            if ($params['language']) {\n                                $localizedField = $class->getFieldDefinition('localizedfields');\n                                if ($localizedField instanceof DataObject\\ClassDefinition\\Data\\Localizedfields) {\n                                    $field = $localizedField->getFieldDefinition($name);\n                                    if ($field) {\n                                        $getter = 'get' . $name;\n                                        $setter = 'set' . $name;\n                                        $newData = $field->getDataFromEditmode($value, $object);\n                                        if ($append) {\n                                            $existingData = $object->$getter($params['language']);\n                                            $newData = $field->appendData($existingData, $newData);\n                                        }\n                                        if ($remove) {\n                                            $existingData = $object->$getter($request->get('language'));\n                                            $newData = $field->removeData($existingData, $newData);\n                                        }\n\n                                        $object->$setter($newData, $params['language']);\n                                    }\n                                }\n                            }\n\n                            // seems to be a system field, this is actually only possible for the \"published\" field yet\n                            if ($name == 'published') {\n                                if ($value === 'false' || empty($value)) {\n                                    $object->setPublished(false);\n                                } else {\n                                    $object->setPublished(true);\n                                }\n                            }\n                        }\n                    }\n\n                    try {\n                        // don't check for mandatory fields here\n                        $object->setOmitMandatoryCheck(!$object->isPublished());\n                        $object->setUserModification($this->getAdminUser()->getId());\n                        $object->save();\n                        $success = true;\n                    } catch (\\Exception $e) {\n                        return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n                    }\n                } else {\n                    Logger::debug('DataObjectController::batchAction => There is no object left to update.');\n\n                    return $this->adminJson(['success' => false, 'message' => 'DataObjectController::batchAction => There is no object left to update.']);\n                }\n            }\n        } catch (\\Exception $e) {\n            Logger::err((string) $e);\n\n            return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n        }\n\n        return $this->adminJson(['success' => $success]);\n    }\n\n    /**\n     * @Route(\"/get-available-visible-vields\", name=\"getavailablevisiblefields\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getAvailableVisibleFieldsAction(Request $request)\n    {\n        $class = null;\n        $fields = null;\n\n        $classList = [];\n        $classNameList = [];\n\n        if ($request->get('classes')) {\n            $classNameList = $request->get('classes');\n            $classNameList = explode(',', $classNameList);\n            foreach ($classNameList as $className) {\n                $class = DataObject\\ClassDefinition::getByName($className);\n                if ($class) {\n                    $classList[] = $class;\n                }\n            }\n        }\n\n        if (!$classList) {\n            return $this->adminJson(['availableFields' => []]);\n        }\n        $availableFields = [];\n        foreach (self::SYSTEM_COLUMNS as $field) {\n            $availableFields[] = [\n                'key' => $field,\n                'value' => $field,\n            ];\n        }\n\n        /** @var DataObject\\ClassDefinition\\Data[] $commonFields */\n        $commonFields = [];\n\n        $firstOne = true;\n        foreach ($classNameList as $className) {\n            $class = DataObject\\ClassDefinition::getByName($className);\n            if ($class) {\n                $fds = $class->getFieldDefinitions();\n\n                $additionalFieldNames = array_keys($fds);\n                $localizedFields = $class->getFieldDefinition('localizedfields');\n                if ($localizedFields instanceof DataObject\\ClassDefinition\\Data\\Localizedfields) {\n                    $lfNames = array_keys($localizedFields->getFieldDefinitions());\n                    $additionalFieldNames = array_merge($additionalFieldNames, $lfNames);\n                }\n\n                foreach ($commonFields as $commonFieldKey => $commonFieldDefinition) {\n                    if (!in_array($commonFieldKey, $additionalFieldNames)) {\n                        unset($commonFields[$commonFieldKey]);\n                    }\n                }\n\n                $this->processAvailableFieldDefinitions($fds, $firstOne, $commonFields);\n\n                $firstOne = false;\n            }\n        }\n\n        $commonFieldKeys = array_keys($commonFields);\n        foreach ($commonFieldKeys as $field) {\n            $availableFields[] = [\n                'key' => $field,\n                'value' => $field,\n            ];\n        }\n\n        return $this->adminJson(['availableFields' => $availableFields]);\n    }\n\n    /**\n     * @param DataObject\\ClassDefinition\\Data[] $fds\n     * @param bool $firstOne\n     * @param DataObject\\ClassDefinition\\Data[] $commonFields\n     */\n    protected function processAvailableFieldDefinitions($fds, &$firstOne, &$commonFields)\n    {\n        foreach ($fds as $fd) {\n            if ($fd instanceof DataObject\\ClassDefinition\\Data\\Fieldcollections || $fd instanceof DataObject\\ClassDefinition\\Data\\Objectbricks\n                || $fd instanceof DataObject\\ClassDefinition\\Data\\Block) {\n                continue;\n            }\n\n            if ($fd instanceof DataObject\\ClassDefinition\\Data\\Localizedfields) {\n                $lfDefs = $fd->getFieldDefinitions();\n                $this->processAvailableFieldDefinitions($lfDefs, $firstOne, $commonFields);\n            } elseif ($firstOne || (isset($commonFields[$fd->getName()]) && $commonFields[$fd->getName()]->getFieldtype() == $fd->getFieldtype())) {\n                $commonFields[$fd->getName()] = $fd;\n            }\n        }\n    }\n}\n", "/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n * @category   Pimcore\n * @package    Object\n *\n * @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n * @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\n\npimcore.registerNS(\"pimcore.object.gridcolumn.operator.anygetter\");\n\npimcore.object.gridcolumn.operator.anygetter = Class.create(pimcore.object.gridcolumn.Abstract, {\n        operatorGroup: \"extractor\",\n        type: \"operator\",\n        class: \"AnyGetter\",\n        iconCls: \"pimcore_icon_operator_anygetter\",\n        defaultText: \"Any Getter\",\n        group: \"getter\",\n\n\n        getConfigTreeNode: function (configAttributes) {\n            if (configAttributes) {\n                var nodeLabel = this.getNodeLabel(configAttributes);\n                var node = {\n                    draggable: true,\n                    iconCls: this.iconCls,\n                    text: nodeLabel,\n                    configAttributes: configAttributes,\n                    isTarget: true,\n                    expanded: true,\n                    leaf: false,\n                    expandable: false\n                };\n            } else {\n\n                //For building up operator list\n                var configAttributes = {type: this.type, class: this.class, label: this.getDefaultText()};\n\n                var node = {\n                    draggable: true,\n                    iconCls: this.iconCls,\n                    text: this.getDefaultText(),\n                    configAttributes: configAttributes,\n                    isTarget: true,\n                    leaf: true\n                };\n            }\n            node.isOperator = true;\n            return node;\n        },\n\n\n        getCopyNode: function (source) {\n            var copy = source.createNode({\n                iconCls: this.iconCls,\n                text: source.data.cssClass,\n                isTarget: true,\n                leaf: false,\n                expanded: true,\n                isOperator: true,\n                configAttributes: {\n                    label: source.data.configAttributes.label,\n                    type: this.type,\n                    class: this.class\n                }\n            });\n            return copy;\n        },\n\n\n        getConfigDialog: function (node, params) {\n            this.node = node;\n\n            this.textfield = new Ext.form.TextField({\n                fieldLabel: t('label'),\n                length: 255,\n                width: 200,\n                value: this.node.data.configAttributes.label\n            });\n\n            this.attributeField = new Ext.form.TextField({\n                fieldLabel: t('attribute'),\n                length: 255,\n                width: 200,\n                value: this.node.data.configAttributes.attribute\n            });\n\n            this.param1Field = new Ext.form.TextField({\n                fieldLabel: t('parameter'),\n                length: 255,\n                width: 200,\n                value: this.node.data.configAttributes.param1\n            });\n\n            this.returnLastResultField = new Ext.form.Checkbox({\n                fieldLabel: t('return_last_result'),\n                length: 255,\n                width: 200,\n                value: this.node.data.configAttributes.returnLastResult\n            });\n\n\n            this.isArrayField = new Ext.form.Checkbox({\n                fieldLabel: t('is_array'),\n                length: 255,\n                width: 200,\n                value: this.node.data.configAttributes.isArrayType\n            });\n\n            this.forwardAttributeField = new Ext.form.TextField({\n                fieldLabel: t('forward_attribute'),\n                length: 255,\n                width: 200,\n                value: this.node.data.configAttributes.forwardAttribute\n            });\n\n            this.forwardParam1Field = new Ext.form.TextField({\n                fieldLabel: t('forward_parameter'),\n                length: 255,\n                width: 200,\n                value: this.node.data.configAttributes.forwardParam1\n            });\n\n\n            this.configPanel = new Ext.Panel({\n                layout: \"form\",\n                bodyStyle: \"padding: 10px;\",\n                items: [this.textfield, this.attributeField, this.param1Field, this.isArrayField, this.returnLastResultField, this.forwardAttributeField, this.forwardParam1Field],\n                buttons: [{\n                    text: t(\"apply\"),\n                    iconCls: \"pimcore_icon_apply\",\n                    handler: function () {\n                        this.commitData(params);\n                    }.bind(this)\n                }]\n            });\n\n            this.window = new Ext.Window({\n                width: 400,\n                height: 450,\n                modal: true,\n                title: t('settings'),\n                layout: \"fit\",\n                items: [this.configPanel]\n            });\n\n            this.window.show();\n\n            return this.window;\n        },\n\n        commitData: function (params) {\n            this.node.set('isOperator', true);\n            this.node.data.configAttributes.label = this.textfield.getValue();\n            this.node.data.configAttributes.attribute = this.attributeField.getValue();\n            this.node.data.configAttributes.param1 = this.param1Field.getValue();\n            this.node.data.configAttributes.isArrayType = this.isArrayField.getValue();\n            this.node.data.configAttributes.forwardAttribute = this.forwardAttributeField.getValue();\n            this.node.data.configAttributes.forwardParam1 = this.forwardParam1Field.getValue();\n            this.node.data.configAttributes.returnLastResult = this.returnLastResultField.getValue();\n\n            var nodeLabel = this.getNodeLabel(this.node.data.configAttributes);\n            this.node.set('text', nodeLabel);\n            this.window.close();\n\n            if (params && params.callback) {\n                params.callback();\n            }\n        },\n\n        getNodeLabel: function (configAttributes) {\n            var nodeLabel = configAttributes.label ? configAttributes.label : this.getDefaultText();\n            if (configAttributes.attribute) {\n                var attr = configAttributes.attribute;\n                if (configAttributes.param1) {\n                    attr += \" \" + configAttributes.param1;\n                }\n                nodeLabel += '<span class=\"pimcore_gridnode_hint\"> (' + attr + ')</span>';\n            }\n\n            return nodeLabel;\n        }\n    }\n);", "/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n * @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n * @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\npimcore.registerNS(\"pimcore.settings.metadata.predefined\");\npimcore.settings.metadata.predefined = Class.create({\n\n    initialize: function () {\n        this.getTabPanel();\n    },\n\n    activate: function () {\n        var tabPanel = Ext.getCmp(\"pimcore_panel_tabs\");\n        tabPanel.setActiveItem(\"predefined_metadata\");\n    },\n\n    getTabPanel: function () {\n\n        if (!this.panel) {\n            this.panel = new Ext.Panel({\n                id: \"predefined_metadata\",\n                title: t(\"predefined_metadata_definitions\"),\n                iconCls: \"pimcore_icon_metadata\",\n                border: false,\n                layout: \"fit\",\n                closable:true,\n                items: [this.getRowEditor()]\n            });\n\n            var tabPanel = Ext.getCmp(\"pimcore_panel_tabs\");\n            tabPanel.add(this.panel);\n            tabPanel.setActiveItem(\"predefined_metadata\");\n\n\n            this.panel.on(\"destroy\", function () {\n                pimcore.globalmanager.remove(\"predefined_metadata\");\n            }.bind(this));\n\n            pimcore.layout.refresh();\n        }\n\n        return this.panel;\n    },\n\n    getRowEditor: function () {\n        var url = Routing.generate('pimcore_admin_settings_metadata');\n\n        this.store = pimcore.helpers.grid.buildDefaultStore(\n            url,\n            [\n                'id',\n                {\n                    name: 'name',\n                    allowBlank: false,\n                    convert: function (v, r) {\n                        return v.replace(/[~]/g, \"---\");\n                    }\n                },\n                'description','type',\n                {name: 'data',\n                    convert: function (v, r) {\n                        let dataType = r.data.type;\n                        if (typeof pimcore.asset.metadata.tags[dataType].prototype.convertPredefinedGridData === \"function\") {\n                            v = pimcore.asset.metadata.tags[dataType].prototype.convertPredefinedGridData(v, r);\n                        }\n                        return v;\n                    }\n                },'config', 'targetSubtype', 'language', 'creationDate' ,'modificationDate'\n            ], null, {\n                remoteSort: false,\n                remoteFilter: false\n            }\n        );\n\n        this.store.getProxy().getReader().setMessageProperty('message');\n        this.store.getProxy().on('exception', function (proxy, response, operation) {\n            pimcore.helpers.showNotification(t(\"error\"), t(operation.getError()), \"error\");\n            this.store.load();\n        }.bind(this));\n\n        this.store.addListener('exception', function(proxy, mode, action, options, response) {\n            Ext.Msg.show({\n                title: t(\"error\"),\n                msg: t(response.raw.message),\n                buttons: Ext.Msg.OK,\n                animEl: 'elId',\n                icon: Ext.MessageBox.ERROR\n            });\n        });\n\n        this.filterField = new Ext.form.TextField({\n            xtype: \"textfield\",\n            width: 200,\n            style: \"margin: 0 10px 0 0;\",\n            enableKeyEvents: true,\n            listeners: {\n                \"keydown\" : function (field, key) {\n                    if (key.getKey() == key.ENTER) {\n                        var input = field;\n                        var proxy = this.store.getProxy();\n                        proxy.extraParams.filter = input.getValue();\n                        this.store.load();\n                    }\n                }.bind(this)\n            }\n        });\n\n\n        var languagestore = [[\"\",t(\"none\")]];\n        for (let i=0; i<pimcore.settings.websiteLanguages.length; i++) {\n            languagestore.push([pimcore.settings.websiteLanguages[i],pimcore.settings.websiteLanguages[i]]);\n        }\n\n        var supportedTypes = pimcore.helpers.getAssetMetadataDataTypes(\"predefined\");\n        var typeStore = [];\n\n        for (let i = 0; i < supportedTypes.length; i++) {\n            let type = supportedTypes[i];\n            typeStore.push([type, t(type)]);\n        }\n\n        var metadataColumns = [\n            {\n                text: t(\"type\"),\n                dataIndex: 'type',\n                editable: false,\n                width: 40,\n                renderer: this.getTypeRenderer.bind(this),\n                sortable: true\n            },\n            {text: t(\"name\"), width: 200, sortable: true, dataIndex: 'name',\n                getEditor: function() { return new Ext.form.TextField({}); }\n            },\n            {text: t(\"group\"), width: 200, sortable: true, dataIndex: 'group',\n                getEditor: function() { return new Ext.form.TextField({}); }\n            },\n            {text: t(\"description\"), sortable: true, dataIndex: 'description',\n                getEditor: function() { return new Ext.form.TextArea({}); },\n                renderer: function (value, metaData, record, rowIndex, colIndex, store) {\n                    if (empty(value)) {\n                        return \"\";\n                    }\n                    return nl2br(Ext.util.Format.htmlEncode(value));\n                }\n            },\n            {text: t(\"type\"), width: 90, sortable: true,\n                dataIndex: 'type',\n                getEditor: function() {\n                    return new Ext.form.ComboBox({\n                        editable: false,\n                        store: typeStore\n\n                    })\n                }\n            },\n            {text: t(\"value\"),\n                flex: 510,\n                sortable: true,\n                dataIndex: 'data',\n                editable: true,\n                getEditor: this.getCellEditor.bind(this),\n                renderer: this.getCellRenderer.bind(this)\n            },\n            {text: t(\"configuration\"),\n                width: 100,\n                sortable: false,\n                dataIndex: 'config',\n                getEditor: function() { return new Ext.form.TextField({}); }\n            },\n            {\n                text: t('language'),\n                sortable: true,\n                dataIndex: \"language\",\n                getEditor: function() {\n                    return new Ext.form.ComboBox({\n                        name: \"language\",\n                        store: languagestore,\n                        editable: false,\n                        triggerAction: 'all',\n                        mode: \"local\"\n                    });\n                },\n                width: 70\n            },\n            {\n                text: t(\"target_subtype\"), width: 80, sortable: true, dataIndex: 'targetSubtype',\n                getEditor: function() {\n                    return new Ext.form.ComboBox({\n                        editable: true,\n                        store: [\"image\", \"text\", \"audio\", \"video\", \"document\", \"archive\", \"unknown\"]\n                    });\n                }\n            },\n            {\n                xtype: 'actioncolumn',\n                menuText: t('delete'),\n                width: 40,\n                items: [{\n                    getClass: function(v, meta, rec) {\n                        var klass = \"pimcore_action_column \";\n                        if(rec.data.writeable) {\n                            klass += \"pimcore_icon_minus\";\n                        }\n                        return klass;\n                    },\n                    tooltip: t('delete'),\n                    handler: function (grid, rowIndex) {\n                        let data = grid.getStore().getAt(rowIndex);\n                        pimcore.helpers.deleteConfirm(t('predefined_metadata'),\n                            Ext.util.Format.htmlEncode(data.data.name),\n                            function () {\n                            grid.getStore().removeAt(rowIndex);\n                        }.bind(this));\n                    }.bind(this)\n                }]\n            },\n            {text: t(\"creationDate\"), sortable: true, dataIndex: 'creationDate', editable: false,\n                hidden: true,\n                renderer: function(d) {\n                    if (d !== undefined) {\n                        var date = new Date(d * 1000);\n                        return date.format(\"Y-m-d H:i:s\");\n                    }\n                    return \"\";\n                }\n            },\n            {text: t(\"modificationDate\"), sortable: true, dataIndex: 'modificationDate', editable: false,\n                hidden: true,\n                renderer: function(d) {\n                    if (d !== undefined) {\n                        var date = new Date(d * 1000);\n                        return date.format(\"Y-m-d H:i:s\");\n                    }\n                    return \"\";\n                }\n            }\n        ];\n\n        this.cellEditing = Ext.create('Ext.grid.plugin.CellEditing', {\n            clicksToEdit: 1,\n            listeners: {\n                beforeedit: function(editor, context, eOpts) {\n                    //need to clear cached editors of cell-editing editor in order to\n                    //enable different editors per row\n                    editor.editors.each(function (e) {\n                        try {\n                            // complete edit, so the value is stored when hopping around with TAB\n                            e.completeEdit();\n                            Ext.destroy(e);\n                        } catch (exception) {\n                            // garbage collector was faster\n                            // already destroyed\n                        }\n                    });\n\n                    editor.editors.clear();\n                },\n                validateedit: function (editor, context, eOpts) {\n                    if (!context.record.data.writeable) {\n                        editor.cancelEdit();\n                        pimcore.helpers.showNotification(t(\"info\"), t(\"config_not_writeable\"), \"info\");\n                        return false;\n                    }\n                }\n            }\n        });\n\n        this.grid = Ext.create('Ext.grid.Panel', {\n            frame: false,\n            autoScroll: true,\n            store: this.store,\n            columnLines: true,\n            stripeRows: true,\n            bodyCls: \"pimcore_editable_grid\",\n            trackMouseOver: true,\n            columns: {\n                items: metadataColumns,\n                defaults: {\n                    renderer: Ext.util.Format.htmlEncode\n                },\n            },\n            clicksToEdit: 1,\n            selModel: Ext.create('Ext.selection.CellModel', {}),\n            bbar: this.pagingtoolbar,\n            autoExpandColumn: \"value_col\",\n            plugins: [\n                this.cellEditing\n            ],\n\n            viewConfig: {\n                listeners: {\n                    rowupdated: this.updateRows.bind(this, \"rowupdated\"),\n                    refresh: this.updateRows.bind(this, \"refresh\")\n                },\n                forceFit: true,\n                getRowClass: function (record, rowIndex) {\n                    return record.data.writeable ? '' : 'pimcore_grid_row_disabled';\n                }\n            },\n            tbar: {\n                cls: 'pimcore_main_toolbar',\n                items: [\n                    {\n                        text: t('add'),\n                        handler: this.onAdd.bind(this),\n                        iconCls: \"pimcore_icon_add\",\n                        disabled: !pimcore.settings['predefined-asset-metadata-writeable']\n                    },\"->\",{\n                        text: t(\"filter\") + \"/\" + t(\"search\"),\n                        xtype: \"tbtext\",\n                        style: \"margin: 0 10px 0 0;\"\n                    },\n                    this.filterField\n                ]\n            }\n        });\n\n        this.grid.on(\"viewready\", this.updateRows.bind(this));\n        this.store.on(\"update\", this.updateRows.bind(this));\n\n        return this.grid;\n    },\n\n    getTypeRenderer: function (value, metaData, record, rowIndex, colIndex, store) {\n\n        if (value == \"input\") {\n            value = \"text\";\n        }\n        return '<div class=\"pimcore_icon_' + value + '\" recordid=' + record.id + '>&nbsp;</div>';\n    },\n\n    getCellRenderer: function (value, metaData, record, rowIndex, colIndex, store) {\n        var data = store.getAt(rowIndex).data;\n        var type = data.type;\n        return pimcore.asset.metadata.tags[type].prototype.getGridCellRenderer(value, metaData, record, rowIndex, colIndex, store);\n    },\n\n    onAdd: function (btn, ev) {\n        var model = this.grid.store.getModel();\n        var newEntry = new model({\n            name: t('new_definition'),\n            key: \"new_key\",\n            subtype: \"image\",\n            type: \"input\"\n        });\n\n        this.grid.store.insert(0, newEntry);\n    },\n\n    updateRows: function (event) {\n        var rows = Ext.get(this.grid.getEl().dom).query(\".x-grid-row\");\n\n        for (let i = 0; i < rows.length; i++) {\n\n            try {\n                var list = Ext.get(rows[i]).query(\".x-grid-cell-first div div\");\n                var firstItem = list[0];\n                if (!firstItem) {\n                    continue;\n                }\n                var recordId = firstItem.getAttribute(\"recordid\");\n                var data = this.grid.getStore().getById(recordId);\n                if (!data) {\n                    continue;\n                }\n\n                data = data.data;\n\n                if(in_array(data.name, this.disallowedKeys)) {\n                    Ext.get(rows[i]).addCls(\"pimcore_properties_hidden_row\");\n                }\n\n                pimcore.asset.metadata.tags[data.type].prototype.updatePredefinedGridRow(this.grid, rows[i], data);\n            }\n            catch (e) {\n                console.log(e);\n            }\n        }\n    },\n\n    getCellEditor: function (record) {\n        var data = record.data;\n        var type = data.type;\n        var editor = pimcore.asset.metadata.tags[type].prototype.getGridCellEditor(\"predefined\", record);\n        return editor;\n    }\n});\n", "<?php\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\DataObject\\GridColumnConfig\\Operator;\n\nuse Pimcore\\DataObject\\GridColumnConfig\\ConfigElementInterface;\nuse Pimcore\\Tool;\n\nabstract class AbstractOperator implements OperatorInterface\n{\n    /**\n     * @var string\n     */\n    protected $label;\n\n    /**\n     * @var array\n     */\n    protected array $context = [];\n\n    /**\n     * @var ConfigElementInterface[]\n     */\n    protected $childs;\n\n    /**\n     * @param \\stdClass $config\n     * @param array $context\n     */\n    public function __construct(\\stdClass $config, array $context = [])\n    {\n        $this->label = $config->label;\n        $this->childs = $config->childs;\n        $this->context = $context;\n    }\n\n    /**\n     * @return ConfigElementInterface[]\n     */\n    public function getChilds()\n    {\n        return $this->childs;\n    }\n\n    /**\n     * @return bool\n     */\n    public function expandLocales()\n    {\n        return false;\n    }\n\n    /**\n     * @return array\n     */\n    public function getContext()\n    {\n        return $this->context;\n    }\n\n    /**\n     * @param array $context\n     */\n    public function setContext($context)\n    {\n        $this->context = $context;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function getLabel()\n    {\n        return $this->label;\n    }\n\n    /**\n     * @param string $label\n     */\n    public function setLabel($label)\n    {\n        $this->label = $label;\n    }\n\n    /**\n     * @return string[]\n     */\n    public function getValidLanguages()\n    {\n        return Tool::getValidLanguages();\n    }\n}\n", "<?php\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\DataObject\\GridColumnConfig\\Operator;\n\nuse Pimcore\\Model\\AbstractModel;\nuse Pimcore\\Tool\\Admin;\n\n/**\n * @internal\n */\nfinal class AnyGetter extends AbstractOperator\n{\n    /**\n     * @var string\n     */\n    private $attribute;\n\n    /**\n     * @var string\n     */\n    private $param1;\n\n    /**\n     * @var bool\n     */\n    private $isArrayType;\n\n    /**\n     * @var string\n     */\n    private $forwardAttribute;\n\n    /**\n     * @var string\n     */\n    private $forwardParam1;\n\n    /**\n     * @var bool\n     */\n    private $returnLastResult;\n\n    /**\n     * {@inheritdoc}\n     */\n    public function __construct(\\stdClass $config, $context = null)\n    {\n        if (!Admin::getCurrentUser()->isAdmin()) {\n            throw new \\Exception('AnyGetter only allowed for admin users');\n        }\n\n        parent::__construct($config, $context);\n\n        $this->attribute = $config->attribute ?? '';\n        $this->param1 = $config->param1 ?? '';\n        $this->isArrayType = $config->isArrayType ?? false;\n\n        $this->forwardAttribute = $config->forwardAttribute ?? '';\n        $this->forwardParam1 = $config->forwardParam1 ?? '';\n\n        $this->returnLastResult = $config->returnLastResult ?? false;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function getLabeledValue($element)\n    {\n        $result = new \\stdClass();\n        $result->label = $this->label;\n\n        $childs = $this->getChilds();\n\n        $getter = 'get'.ucfirst($this->attribute);\n        $fallbackGetter = $this->attribute;\n\n        if (!$childs) {\n            $result->value = null;\n            if ($this->attribute && method_exists($element, $getter)) {\n                $result->value = $element->$getter($this->getParam1());\n            } elseif ($this->attribute && method_exists($element, $fallbackGetter)) {\n                $result->value = $element->$fallbackGetter($this->getParam1());\n            }\n\n            if ($result->value instanceof AbstractModel) {\n                $result->value = $result->value->getObjectVars();\n            }\n        } else {\n            if (count($childs) > 1) {\n                $result->isArrayType = true;\n            }\n            $resultElements = [];\n\n            if (!is_array($childs)) {\n                $childs = [$childs];\n            }\n\n            foreach ($childs as $c) {\n                $forwardObject = $element;\n\n                if ($this->forwardAttribute) {\n                    $forwardGetter = 'get'.ucfirst($this->forwardAttribute);\n                    $forwardParam = $this->getForwardParam1();\n                    if (method_exists($element, $forwardGetter)) {\n                        $forwardObject = $element->$forwardGetter($forwardParam);\n                        if (!$forwardObject) {\n                            return $result;\n                        }\n                    } else {\n                        return $result;\n                    }\n                }\n\n                $valueContainer = $c->getLabeledValue($forwardObject);\n\n                $value = $valueContainer->value;\n                if ($value || $this->getReturnLastResult()) {\n                    $resultElementValue = $value;\n                } else {\n                    $resultElementValue = null;\n                }\n\n                if ($this->getisArrayType()) {\n                    if (is_array($value)) {\n                        $subValues = [];\n                        foreach ($value as $o) {\n                            if ($o) {\n                                if ($this->attribute && method_exists($o, $getter)) {\n                                    $subValues[] = $o->$getter($this->getParam1());\n                                } elseif ($this->attribute && method_exists($o, $fallbackGetter)) {\n                                    $subValues[] = $o->$fallbackGetter($this->getParam1());\n                                }\n                            }\n                        }\n                        $resultElementValue = $subValues;\n                    }\n                } else {\n                    $o = $value;\n                    if ($o) {\n                        if ($this->attribute && method_exists($o, $getter)) {\n                            $resultElementValue = $o->$getter($this->getParam1());\n                        } elseif ($this->attribute && method_exists($o, $fallbackGetter)) {\n                            $resultElementValue = $o->$fallbackGetter($this->getParam1());\n                        }\n                    }\n                }\n                $resultElements[] = $resultElementValue;\n            }\n            if (count($childs) == 1) {\n                $result->value = $resultElements[0];\n            } else {\n                $result->value = $resultElements;\n            }\n        }\n\n        return $result;\n    }\n\n    /**\n     * @return string\n     */\n    public function getAttribute()\n    {\n        return $this->attribute;\n    }\n\n    /**\n     * @param string $attribute\n     */\n    public function setAttribute($attribute)\n    {\n        $this->attribute = $attribute;\n    }\n\n    /**\n     * @return string\n     */\n    public function getParam1()\n    {\n        return $this->param1;\n    }\n\n    /**\n     * @param string $param1\n     */\n    public function setParam1($param1)\n    {\n        $this->param1 = $param1;\n    }\n\n    /**\n     * @return string\n     */\n    public function getForwardAttribute()\n    {\n        return $this->forwardAttribute;\n    }\n\n    /**\n     * @param string $forwardAttribute\n     */\n    public function setForwardAttribute($forwardAttribute)\n    {\n        $this->forwardAttribute = $forwardAttribute;\n    }\n\n    /**\n     * @return string\n     */\n    public function getForwardParam1()\n    {\n        return $this->forwardParam1;\n    }\n\n    /**\n     * @param string $forwardParam1\n     */\n    public function setForwardParam1($forwardParam1)\n    {\n        $this->forwardParam1 = $forwardParam1;\n    }\n\n    /**\n     * @return bool\n     */\n    public function getIsArrayType()\n    {\n        return $this->isArrayType;\n    }\n\n    /**\n     * @param bool $isArrayType\n     */\n    public function setIsArrayType($isArrayType)\n    {\n        $this->isArrayType = $isArrayType;\n    }\n\n    /**\n     * @return bool\n     */\n    public function getReturnLastResult()\n    {\n        return $this->returnLastResult;\n    }\n\n    /**\n     * @param bool $returnLastResult\n     */\n    public function setReturnLastResult($returnLastResult)\n    {\n        $this->returnLastResult = $returnLastResult;\n    }\n}\n", "<?php\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\Security;\n\nclass SecurityHelper\n{\n    public static function convertHtmlSpecialChars(?string $text): ?string\n    {\n        if(is_string($text)) {\n            return htmlspecialchars($text, ENT_QUOTES | ENT_SUBSTITUTE, 'UTF-8', false);\n        }\n\n        return null;\n    }\n}\n"], "fixing_code": ["<?php\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\Bundle\\AdminBundle\\Controller\\Admin\\Asset;\n\nuse League\\Flysystem\\FilesystemException;\nuse League\\Flysystem\\UnableToReadFile;\nuse PhpOffice\\PhpSpreadsheet\\Reader\\Csv;\nuse PhpOffice\\PhpSpreadsheet\\Writer\\Xlsx;\nuse Pimcore\\Bundle\\AdminBundle\\Controller\\AdminController;\nuse Pimcore\\Bundle\\AdminBundle\\Helper\\GridHelperService;\nuse Pimcore\\Db;\nuse Pimcore\\Event\\AdminEvents;\nuse Pimcore\\Loader\\ImplementationLoader\\Exception\\UnsupportedException;\nuse Pimcore\\Localization\\LocaleServiceInterface;\nuse Pimcore\\Logger;\nuse Pimcore\\Model\\Asset;\nuse Pimcore\\Model\\Element;\nuse Pimcore\\Model\\GridConfig;\nuse Pimcore\\Model\\GridConfigFavourite;\nuse Pimcore\\Model\\GridConfigShare;\nuse Pimcore\\Model\\Metadata;\nuse Pimcore\\Model\\User;\nuse Pimcore\\Security\\SecurityHelper;\nuse Pimcore\\Tool;\nuse Pimcore\\Tool\\Storage;\nuse Pimcore\\Version;\nuse Symfony\\Component\\EventDispatcher\\GenericEvent;\nuse Symfony\\Component\\HttpFoundation\\BinaryFileResponse;\nuse Symfony\\Component\\HttpFoundation\\HeaderUtils;\nuse Symfony\\Component\\HttpFoundation\\JsonResponse;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpFoundation\\Session\\Attribute\\AttributeBagInterface;\nuse Symfony\\Component\\Routing\\Annotation\\Route;\nuse Symfony\\Contracts\\EventDispatcher\\EventDispatcherInterface;\n\n/**\n * @Route(\"/asset-helper\")\n *\n * @internal\n */\nclass AssetHelperController extends AdminController\n{\n    /**\n     * @param int $userId\n     * @param string $classId\n     * @param string $searchType\n     *\n     * @return array\n     */\n    public function getMyOwnGridColumnConfigs($userId, $classId, $searchType)\n    {\n        $db = Db::get();\n        $configListingConditionParts = [];\n        $configListingConditionParts[] = 'ownerId = ' . $userId;\n        $configListingConditionParts[] = 'classId = ' . $db->quote($classId);\n\n        if ($searchType) {\n            $configListingConditionParts[] = 'searchType = ' . $db->quote($searchType);\n        }\n\n        $configCondition = implode(' AND ', $configListingConditionParts);\n        $configListing = new GridConfig\\Listing();\n        $configListing->setOrderKey('name');\n        $configListing->setOrder('ASC');\n        $configListing->setCondition($configCondition);\n        $configListing = $configListing->load();\n\n        $configData = [];\n        if (is_array($configListing)) {\n            foreach ($configListing as $config) {\n                $configData[] = $config->getObjectVars();\n            }\n        }\n\n        return $configData;\n    }\n\n    /**\n     * @param User $user\n     * @param string $classId\n     * @param string $searchType\n     *\n     * @return array\n     */\n    public function getSharedGridColumnConfigs($user, $classId, $searchType = null)\n    {\n        $db = Db::get();\n\n        $configListing = [];\n\n        $userIds = [$user->getId()];\n        // collect all roles\n        $userIds = array_merge($userIds, $user->getRoles());\n        $userIds = implode(',', $userIds);\n\n        $query = 'select distinct c1.id from gridconfigs c1, gridconfig_shares s\n                    where (c1.searchType = ' . $db->quote($searchType) . ' and ((c1.id = s.gridConfigId and s.sharedWithUserId IN (' . $userIds . '))) and c1.classId = ' . $db->quote($classId) . ')\n                            UNION distinct select c2.id from gridconfigs c2 where shareGlobally = 1 and c2.classId = '. $db->quote($classId) . '  and c2.ownerId != ' . $db->quote($user->getId());\n\n        $ids = $db->fetchFirstColumn($query);\n\n        if ($ids) {\n            $ids = implode(',', $ids);\n            $configListing = new GridConfig\\Listing();\n            $configListing->setOrderKey('name');\n            $configListing->setOrder('ASC');\n            $configListing->setCondition('id in (' . $ids . ')');\n            $configListing = $configListing->load();\n        }\n\n        $configData = [];\n        if (is_array($configListing)) {\n            foreach ($configListing as $config) {\n                $configData[] = $config->getObjectVars();\n            }\n        }\n\n        return $configData;\n    }\n\n    /**\n     * @Route(\"/grid-delete-column-config\", name=\"pimcore_admin_asset_assethelper_griddeletecolumnconfig\", methods={\"DELETE\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function gridDeleteColumnConfigAction(Request $request)\n    {\n        $gridConfigId = $request->get('gridConfigId');\n        $gridConfig = GridConfig::getById($gridConfigId);\n        $success = false;\n        if ($gridConfig) {\n            if ($gridConfig->getOwnerId() != $this->getAdminUser()->getId()) {\n                throw new \\Exception(\"don't mess with someone elses grid config\");\n            }\n\n            $gridConfig->delete();\n            $success = true;\n        }\n\n        $newGridConfig = $this->doGetGridColumnConfig($request, true);\n        $newGridConfig['deleteSuccess'] = $success;\n\n        return $this->adminJson($newGridConfig);\n    }\n\n    /**\n     * @Route(\"/grid-get-column-config\", name=\"pimcore_admin_asset_assethelper_gridgetcolumnconfig\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function gridGetColumnConfigAction(Request $request)\n    {\n        $result = $this->doGetGridColumnConfig($request);\n\n        return $this->adminJson($result);\n    }\n\n    /**\n     * @param Request $request\n     * @param bool $isDelete\n     *\n     * @return array\n     */\n    public function doGetGridColumnConfig(Request $request, $isDelete = false)\n    {\n        $gridConfigId = null;\n\n        $classId = $request->get('id');\n        $type = $request->get('type');\n\n        $context = ['purpose' => 'gridconfig'];\n\n        $types = [];\n        if ($request->get('types')) {\n            $types = explode(',', $request->get('types'));\n        }\n\n        $userId = $this->getAdminUser()->getId();\n\n        $requestedGridConfigId = $isDelete ? null : $request->get('gridConfigId');\n\n        // grid config\n        $gridConfig = [];\n        $searchType = $request->get('searchType');\n\n        if (strlen($requestedGridConfigId) == 0) {\n            // check if there is a favourite view\n            $favourite = GridConfigFavourite::getByOwnerAndClassAndObjectId($userId, $classId, 0, $searchType);\n\n            if ($favourite) {\n                $requestedGridConfigId = $favourite->getGridConfigId();\n            }\n        }\n\n        if (is_numeric($requestedGridConfigId) && $requestedGridConfigId > 0) {\n            $db = Db::get();\n            $savedGridConfig = GridConfig::getById((int) $requestedGridConfigId);\n\n            if ($savedGridConfig) {\n                $shared = null;\n\n                try {\n                    $userIds = [$this->getAdminUser()->getId()];\n                    if ($this->getAdminUser()->getRoles()) {\n                        $userIds = array_merge($userIds, $this->getAdminUser()->getRoles());\n                    }\n                    $userIds = implode(',', $userIds);\n                    $shared = ($savedGridConfig->getOwnerId() != $userId && $savedGridConfig->isShareGlobally()) || $db->fetchOne('select * from gridconfig_shares where sharedWithUserId IN (' . $userIds . ') and gridConfigId = ' . $savedGridConfig->getId());\n                } catch (\\Exception $e) {\n                }\n\n                if (!$shared && $savedGridConfig->getOwnerId() != $this->getAdminUser()->getId()) {\n                    throw new \\Exception('You are neither the owner of this config nor it is shared with you');\n                }\n                $gridConfigId = $savedGridConfig->getId();\n                $gridConfig = $savedGridConfig->getConfig();\n                $gridConfig = json_decode($gridConfig, true);\n                $gridConfigName = $savedGridConfig->getName();\n                $gridConfigDescription = $savedGridConfig->getDescription();\n                $sharedGlobally = $savedGridConfig->isShareGlobally();\n                $setAsFavourite = $savedGridConfig->isSetAsFavourite();\n            }\n        }\n\n        $availableFields = [];\n        $language = '';\n\n        if (empty($gridConfig)) {\n            $availableFields = $this->getDefaultGridFields(\n                $request->get('no_system_columns'),\n                [], //maybe required for types other than metadata\n                $context,\n                $types);\n        } else {\n            $savedColumns = $gridConfig['columns'];\n\n            foreach ($savedColumns as $key => $sc) {\n                if (!$sc['hidden']) {\n                    $colConfig = $this->getFieldGridConfig($sc, $language, null);\n                    if ($colConfig) {\n                        $availableFields[] = $colConfig;\n                    }\n                }\n            }\n        }\n        usort($availableFields, function ($a, $b) {\n            if ($a['position'] == $b['position']) {\n                return 0;\n            }\n\n            return ($a['position'] < $b['position']) ? -1 : 1;\n        });\n\n        $availableConfigs = $classId ? $this->getMyOwnGridColumnConfigs($userId, $classId, $searchType) : [];\n        $sharedConfigs = $classId ? $this->getSharedGridColumnConfigs($this->getAdminUser(), $classId, $searchType) : [];\n        $settings = $this->getShareSettings((int)$gridConfigId);\n        $settings['gridConfigId'] = (int)$gridConfigId;\n        $settings['gridConfigName'] = $gridConfigName ?? null;\n        $settings['gridConfigDescription'] = $gridConfigDescription ?? null;\n        $settings['shareGlobally'] = $sharedGlobally ?? null;\n        $settings['setAsFavourite'] = $setAsFavourite ?? null;\n        $settings['isShared'] = !$gridConfigId || ($shared ?? null);\n\n        $context = $gridConfig['context'] ?? null;\n        if ($context) {\n            $context = json_decode($context, true);\n        }\n\n        return [\n            'sortinfo' => isset($gridConfig['sortinfo']) ? $gridConfig['sortinfo'] : false,\n            'availableFields' => $availableFields,\n            'settings' => $settings,\n            'onlyDirectChildren' => isset($gridConfig['onlyDirectChildren']) ? $gridConfig['onlyDirectChildren'] : false,\n            'onlyUnreferenced' => isset($gridConfig['onlyUnreferenced']) ? $gridConfig['onlyUnreferenced'] : false,\n            'pageSize' => isset($gridConfig['pageSize']) ? $gridConfig['pageSize'] : false,\n            'availableConfigs' => $availableConfigs,\n            'sharedConfigs' => $sharedConfigs,\n            'context' => $context,\n        ];\n    }\n\n    /**\n     * @param array $field\n     * @param string $language\n     * @param string|null $keyPrefix\n     *\n     * @return array|null\n     */\n    protected function getFieldGridConfig($field, $language = '', $keyPrefix = null)\n    {\n        $defaulMetadataFields = ['copyright', 'alt', 'title'];\n        $predefined = null;\n\n        if (isset($field['fieldConfig']['layout']['name'])) {\n            $predefined = Metadata\\Predefined::getByName($field['fieldConfig']['layout']['name']);\n        }\n\n        $key = $field['name'];\n        if ($keyPrefix) {\n            $key = $keyPrefix . $key;\n        }\n\n        $fieldDef = explode('~', $field['name']);\n        $field['name'] = $fieldDef[0];\n\n        if (isset($fieldDef[1]) && $fieldDef[1] === 'system') {\n            $type = 'system';\n        } elseif (in_array($fieldDef[0], $defaulMetadataFields)) {\n            $type = 'input';\n        } else {\n            $type = $field['fieldConfig']['type'];\n            if (isset($fieldDef[1])) {\n                $field['fieldConfig']['label'] = $field['fieldConfig']['layout']['title'] = $fieldDef[0] . ' (' . $fieldDef[1] . ')';\n                $field['fieldConfig']['layout']['icon'] = Tool::getLanguageFlagFile($fieldDef[1], true);\n            }\n        }\n\n        $result = [\n            'key' => $key,\n            'type' => $type,\n            'label' => $field['fieldConfig']['label'] ?? $key,\n            'width' => $field['width'],\n            'position' => $field['position'],\n            'language' => $field['fieldConfig']['language'] ?? null,\n            'layout' => $field['fieldConfig']['layout'] ?? null,\n        ];\n\n        if (isset($field['locked'])) {\n            $result['locked'] = $field['locked'];\n        }\n\n        if ($type === 'select' && $predefined) {\n            $field['fieldConfig']['layout']['config'] = $predefined->getConfig();\n            $result['layout'] = $field['fieldConfig']['layout'];\n        } elseif ($type === 'document' || $type === 'asset' || $type === 'object') {\n            $result['layout']['fieldtype'] = 'manyToOneRelation';\n            $result['layout']['subtype'] = $type;\n        }\n\n        return $result;\n    }\n\n    /**\n     * @param bool $noSystemColumns\n     * @param array $fields\n     * @param array $context\n     * @param array $types\n     *\n     * @return array\n     */\n    public function getDefaultGridFields($noSystemColumns, $fields, $context, $types = [])\n    {\n        $count = 0;\n        $availableFields = [];\n\n        if (!$noSystemColumns) {\n            foreach (Asset\\Service::GRID_SYSTEM_COLUMNS as $sc) {\n                if (empty($types)) {\n                    $availableFields[] = [\n                        'key' => $sc . '~system',\n                        'type' => 'system',\n                        'label' => $sc,\n                        'position' => $count, ];\n                    $count++;\n                }\n            }\n        }\n\n        return $availableFields;\n    }\n\n    /**\n     * @Route(\"/prepare-helper-column-configs\", name=\"pimcore_admin_asset_assethelper_preparehelpercolumnconfigs\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function prepareHelperColumnConfigs(Request $request)\n    {\n        $helperColumns = [];\n        $newData = [];\n        $data = json_decode($request->get('columns'));\n        /** @var \\stdClass $item */\n        foreach ($data as $item) {\n            if (!empty($item->isOperator)) {\n                $itemKey = '#' . uniqid();\n\n                $item->key = $itemKey;\n                $newData[] = $item;\n                $helperColumns[$itemKey] = $item;\n            } else {\n                $newData[] = $item;\n            }\n        }\n\n        Tool\\Session::useSession(function (AttributeBagInterface $session) use ($helperColumns) {\n            $existingColumns = $session->get('helpercolumns', []);\n            $helperColumns = array_merge($helperColumns, $existingColumns);\n            $session->set('helpercolumns', $helperColumns);\n        }, 'pimcore_gridconfig');\n\n        return $this->adminJson(['success' => true, 'columns' => $newData]);\n    }\n\n    /**\n     * @Route(\"/grid-mark-favourite-column-config\", name=\"pimcore_admin_asset_assethelper_gridmarkfavouritecolumnconfig\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function gridMarkFavouriteColumnConfigAction(Request $request)\n    {\n        $classId = $request->get('classId');\n        $asset = Asset::getById($classId);\n\n        if ($asset->isAllowed('list')) {\n            $gridConfigId = $request->get('gridConfigId');\n            $searchType = $request->get('searchType');\n            $type = $request->get('type');\n            $user = $this->getAdminUser();\n\n            $favourite = new GridConfigFavourite();\n            $favourite->setOwnerId($user->getId());\n            $favourite->setClassId($classId);\n            $favourite->setSearchType($searchType);\n            $favourite->setType($type);\n            $specializedConfigs = false;\n\n            try {\n                if ($gridConfigId != 0) {\n                    $gridConfig = GridConfig::getById($gridConfigId);\n                    $favourite->setGridConfigId($gridConfig->getId());\n                }\n\n                $favourite->setObjectId(0);\n                $favourite->save();\n            } catch (\\Exception $e) {\n                $favourite->delete();\n            }\n\n            return $this->adminJson(['success' => true, 'spezializedConfigs' => $specializedConfigs]);\n        }\n\n        throw $this->createAccessDeniedHttpException();\n    }\n\n    /**\n     * @param int $gridConfigId\n     *\n     * @return array\n     */\n    protected function getShareSettings($gridConfigId)\n    {\n        $result = [\n            'sharedUserIds' => [],\n            'sharedRoleIds' => [],\n        ];\n\n        $db = Db::get();\n        $allShares = $db->fetchAllAssociative('select s.sharedWithUserId, u.type from gridconfig_shares s, users u\n                      where s.sharedWithUserId = u.id and s.gridConfigId = ' . $gridConfigId);\n\n        if ($allShares) {\n            foreach ($allShares as $share) {\n                $type = $share['type'];\n                $key = 'shared' . ucfirst($type) . 'Ids';\n                $result[$key][] = $share['sharedWithUserId'];\n            }\n        }\n\n        foreach ($result as $idx => $value) {\n            $value = $value ? implode(',', $value) : '';\n            $result[$idx] = $value;\n        }\n\n        return $result;\n    }\n\n    /**\n     * @Route(\"/grid-save-column-config\", name=\"pimcore_admin_asset_assethelper_gridsavecolumnconfig\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function gridSaveColumnConfigAction(Request $request)\n    {\n        $asset = Asset::getById((int) $request->get('id'));\n\n        if (!$asset) {\n            throw $this->createNotFoundException();\n        }\n\n        if ($asset->isAllowed('list')) {\n            try {\n                $classId = $request->get('class_id');\n                $context = $request->get('context');\n\n                $searchType = $request->get('searchType');\n                $type = $request->get('type');\n\n                // grid config\n                $gridConfigData = $this->decodeJson($request->get('gridconfig'));\n                $gridConfigData['pimcore_version'] = Version::getVersion();\n                $gridConfigData['pimcore_revision'] = Version::getRevision();\n                $gridConfigData['context'] = $context;\n                unset($gridConfigData['settings']['isShared']);\n\n                $metadata = $request->get('settings');\n                $metadata = json_decode($metadata, true);\n\n                $gridConfigId = $metadata['gridConfigId'];\n                $gridConfig = GridConfig::getById($gridConfigId);\n\n                if ($gridConfig && $gridConfig->getOwnerId() != $this->getAdminUser()->getId()) {\n                    throw new \\Exception(\"don't mess around with somebody else's configuration\");\n                }\n\n                $this->updateGridConfigShares($gridConfig, $metadata);\n\n                if ($metadata['setAsFavourite'] && $this->getAdminUser()->isAdmin()) {\n                    $this->updateGridConfigFavourites($gridConfig, $metadata);\n                }\n\n                if (!$gridConfig) {\n                    $gridConfig = new GridConfig();\n                    $gridConfig->setName(date('c'));\n                    $gridConfig->setClassId($classId);\n                    $gridConfig->setSearchType($searchType);\n                    $gridConfig->setType($type);\n\n                    $gridConfig->setOwnerId($this->getAdminUser()->getId());\n                }\n\n                if ($metadata) {\n                    $gridConfig->setName($metadata['gridConfigName']);\n                    $gridConfig->setDescription($metadata['gridConfigDescription']);\n                    $gridConfig->setShareGlobally($metadata['shareGlobally'] && $this->getAdminUser()->isAdmin());\n                    $gridConfig->setSetAsFavourite($metadata['setAsFavourite'] && $this->getAdminUser()->isAdmin());\n                }\n\n                $gridConfigData = json_encode($gridConfigData);\n                $gridConfig->setConfig($gridConfigData);\n                $gridConfig->save();\n\n                $userId = $this->getAdminUser()->getId();\n\n                $availableConfigs = $this->getMyOwnGridColumnConfigs($userId, $classId, $searchType);\n                $sharedConfigs = $this->getSharedGridColumnConfigs($this->getAdminUser(), $classId, $searchType);\n\n                $settings = $this->getShareSettings($gridConfig->getId());\n                $settings['gridConfigId'] = (int)$gridConfig->getId();\n                $settings['gridConfigName'] = $gridConfig->getName();\n                $settings['gridConfigDescription'] = $gridConfig->getDescription();\n                $settings['shareGlobally'] = $gridConfig->isShareGlobally();\n                $settings['setAsFavourite'] = $gridConfig->isSetAsFavourite();\n                $settings['isShared'] = $gridConfig->getOwnerId() != $this->getAdminUser()->getId();\n\n                return $this->adminJson([\n                    'success' => true,\n                    'settings' => $settings,\n                    'availableConfigs' => $availableConfigs,\n                    'sharedConfigs' => $sharedConfigs,\n                ]);\n            } catch (\\Exception $e) {\n                return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n            }\n        }\n\n        throw $this->createAccessDeniedHttpException();\n    }\n\n    /**\n     * @param GridConfig|null $gridConfig\n     * @param array $metadata\n     *\n     * @throws \\Exception\n     */\n    protected function updateGridConfigShares($gridConfig, $metadata)\n    {\n        $user = $this->getAdminUser();\n        if (!$gridConfig || !$user->isAllowed('share_configurations')) {\n            // nothing to do\n            return;\n        }\n\n        if ($gridConfig->getOwnerId() != $this->getAdminUser()->getId()) {\n            throw new \\Exception(\"don't mess with someone elses grid config\");\n        }\n        $combinedShares = [];\n        $sharedUserIds = $metadata['sharedUserIds'];\n        $sharedRoleIds = $metadata['sharedRoleIds'];\n\n        if ($sharedUserIds) {\n            $combinedShares = explode(',', $sharedUserIds);\n        }\n\n        if ($sharedRoleIds) {\n            $sharedRoleIds = explode(',', $sharedRoleIds);\n            $combinedShares = array_merge($combinedShares, $sharedRoleIds);\n        }\n\n        $db = Db::get();\n        $db->delete('gridconfig_shares', ['gridConfigId' => $gridConfig->getId()]);\n\n        foreach ($combinedShares as $id) {\n            $share = new GridConfigShare();\n            $share->setGridConfigId($gridConfig->getId());\n            $share->setSharedWithUserId((int) $id);\n            $share->save();\n        }\n    }\n\n    /**\n     * @param GridConfig|null $gridConfig\n     * @param array $metadata\n     *\n     * @throws \\Exception\n     */\n    protected function updateGridConfigFavourites($gridConfig, $metadata)\n    {\n        $currentUser = $this->getAdminUser();\n\n        if (!$gridConfig || $currentUser === null || !$currentUser->isAllowed('share_configurations')) {\n            // nothing to do\n            return;\n        }\n\n        if (!$currentUser->isAdmin() && (int) $gridConfig->getOwnerId() !== $currentUser->getId()) {\n            throw new \\Exception(\"don't mess with someone elses grid config\");\n        }\n\n        $sharedUsers = [];\n\n        if ($metadata['shareGlobally'] === false) {\n            $sharedUserIds = $metadata['sharedUserIds'];\n\n            if ($sharedUserIds) {\n                $sharedUsers = explode(',', $sharedUserIds);\n            }\n        }\n\n        if ($metadata['shareGlobally'] === true) {\n            $users = new User\\Listing();\n            $users->setCondition('id = ?', $currentUser->getId());\n\n            foreach ($users as $user) {\n                $sharedUsers[] = $user->getId();\n            }\n        }\n\n        foreach ($sharedUsers as $id) {\n            // Check if the user has already a favourite\n            $favourite = GridConfigFavourite::getByOwnerAndClassAndObjectId(\n                (int) $id,\n                $gridConfig->getClassId(),\n                0,\n                $gridConfig->getSearchType()\n            );\n\n            if ($favourite instanceof GridConfigFavourite) {\n                $favouriteGridConfig = GridConfig::getById($favourite->getGridConfigId());\n\n                if ($favouriteGridConfig instanceof GridConfig) {\n                    // Check if the grid config was shared globally if that is *not* the case we also not update\n                    if ((bool) $favouriteGridConfig->isShareGlobally() === false) {\n                        continue;\n                    }\n\n                    // Check if the user is the owner. If that is the case we do not update the favourite\n                    if ((int) $favouriteGridConfig->getOwnerId() === (int) $id) {\n                        continue;\n                    }\n                }\n            }\n\n            $favourite = new GridConfigFavourite();\n            $favourite->setGridConfigId($gridConfig->getId());\n            $favourite->setClassId($gridConfig->getClassId());\n            $favourite->setObjectId(0);\n            $favourite->setOwnerId($id);\n            $favourite->setType($gridConfig->getType());\n            $favourite->setSearchType($gridConfig->getSearchType());\n            $favourite->save();\n        }\n    }\n\n    /**\n     * @Route(\"/get-export-jobs\", name=\"pimcore_admin_asset_assethelper_getexportjobs\", methods={\"POST\"})\n     *\n     * @param Request $request\n     * @param GridHelperService $gridHelperService\n     *\n     * @return JsonResponse\n     */\n    public function getExportJobsAction(Request $request, GridHelperService $gridHelperService)\n    {\n        $allParams = array_merge($request->request->all(), $request->query->all());\n        $list = $gridHelperService->prepareAssetListingForGrid($allParams, $this->getAdminUser());\n\n        if (empty($ids = $allParams['ids'] ?? '')) {\n            $ids = $list->loadIdList();\n        }\n\n        $jobs = array_chunk($ids, 20);\n\n        $fileHandle = uniqid('asset-export-');\n        $storage = Storage::get('temp');\n        $storage->write($this->getCsvFile($fileHandle), '');\n\n        return $this->adminJson(['success' => true, 'jobs' => $jobs, 'fileHandle' => $fileHandle]);\n    }\n\n    /**\n     * @Route(\"/do-export\", name=\"pimcore_admin_asset_assethelper_doexport\", methods={\"POST\"})\n     *\n     * @param Request $request\n     * @param LocaleServiceInterface $localeService\n     *\n     * @return JsonResponse\n     */\n    public function doExportAction(Request $request, LocaleServiceInterface $localeService)\n    {\n        $fileHandle = \\Pimcore\\File::getValidFilename($request->get('fileHandle'));\n        $ids = $request->get('ids');\n        $settings = $request->get('settings');\n        $settings = json_decode($settings, true);\n        $delimiter = $settings['delimiter'] ?? ';';\n        $language = str_replace('default', '', $request->get('language'));\n\n        $list = new Asset\\Listing();\n\n        $quotedIds = [];\n        foreach ($ids as $id) {\n            $quotedIds[] = $list->quote($id);\n        }\n\n        $list->setCondition('id IN (' . implode(',', $quotedIds) . ')');\n        $list->setOrderKey(' FIELD(id, ' . implode(',', $quotedIds) . ')', false);\n\n        $fields = $request->get('fields');\n\n        $addTitles = $request->get('initial');\n\n        $csv = $this->getCsvData($request, $language, $list, $fields, $addTitles);\n\n        $storage = Storage::get('temp');\n        $csvFile = $this->getCsvFile($fileHandle);\n\n        $fileStream = $storage->readStream($csvFile);\n\n        $temp = tmpfile();\n        stream_copy_to_stream($fileStream, $temp, null, 0);\n\n        $firstLine = true;\n        foreach ($csv as $line) {\n            if ($addTitles && $firstLine) {\n                $firstLine = false;\n                $line = implode($delimiter, $line) . \"\\r\\n\";\n                fwrite($temp, $line);\n            } else {\n                fwrite($temp, implode($delimiter, array_map([$this, 'encodeFunc'], $line)) . \"\\r\\n\");\n            }\n        }\n\n        $storage->writeStream($csvFile, $temp);\n\n        return $this->adminJson(['success' => true]);\n    }\n\n    public function encodeFunc($value)\n    {\n        $value = str_replace('\"', '\"\"', $value);\n        //force wrap value in quotes and return\n        return '\"' . $value . '\"';\n    }\n\n    /**\n     * @param Request $request\n     * @param string $language\n     * @param Asset\\Listing $list\n     * @param array $fields\n     * @param bool $addTitles\n     *\n     * @return array\n     */\n    protected function getCsvData(Request $request, $language, $list, $fields, $addTitles = true)\n    {\n        //create csv\n        $csv = [];\n\n        $unsupportedFields = ['preview~system', 'size~system'];\n        $fields = array_diff($fields, $unsupportedFields);\n\n        if ($addTitles) {\n            $columns = $fields;\n            foreach ($columns as $columnIdx => $columnKey) {\n                $columns[$columnIdx] = '\"' . $columnKey . '\"';\n            }\n            $csv[] = $columns;\n        }\n\n        foreach ($list->load() as $asset) {\n            if ($fields) {\n                $dataRows = [];\n                foreach ($fields as $field) {\n                    $fieldDef = explode('~', $field);\n                    $getter = 'get' . ucfirst($fieldDef[0]);\n\n                    if (isset($fieldDef[1])) {\n                        if ($fieldDef[1] == 'system' && method_exists($asset, $getter)) {\n                            $data = $asset->$getter($language);\n                        } else {\n                            $fieldDef[1] = str_replace('none', '', $fieldDef[1]);\n                            $data = $asset->getMetadata($fieldDef[0], $fieldDef[1], true);\n                        }\n                    } else {\n                        $data = $asset->getMetadata($field, $language, true);\n                    }\n\n                    if ($data instanceof Element\\ElementInterface) {\n                        $data = $data->getRealFullPath();\n                    }\n                    $dataRows[] = $data;\n                }\n                $dataRows = Element\\Service::escapeCsvRecord($dataRows);\n                $csv[] = $dataRows;\n            }\n        }\n\n        return $csv;\n    }\n\n    /**\n     * @param Request $request\n     *\n     * @return string\n     */\n    protected function extractLanguage(Request $request)\n    {\n        $requestedLanguage = $request->get('language');\n        if ($requestedLanguage) {\n            if ($requestedLanguage != 'default') {\n                $request->setLocale($requestedLanguage);\n            }\n        } else {\n            $requestedLanguage = $request->getLocale();\n        }\n\n        return $requestedLanguage;\n    }\n\n    /**\n     * @param string $fileHandle\n     *\n     * @return string\n     */\n    protected function getCsvFile($fileHandle)\n    {\n        return $fileHandle . '.csv';\n    }\n\n    /**\n     * @Route(\"/download-csv-file\", name=\"pimcore_admin_asset_assethelper_downloadcsvfile\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function downloadCsvFileAction(Request $request)\n    {\n        $storage = Storage::get('temp');\n        $fileHandle = \\Pimcore\\File::getValidFilename($request->get('fileHandle'));\n        $csvFile = $this->getCsvFile($fileHandle);\n\n        try {\n            $csvData = $storage->read($csvFile);\n            $response = new Response($csvData);\n            $response->headers->set('Content-Type', 'application/csv');\n            $disposition = HeaderUtils::makeDisposition(\n                HeaderUtils::DISPOSITION_ATTACHMENT,\n                'export.csv'\n            );\n\n            $response->headers->set('Content-Disposition', $disposition);\n            $storage->delete($csvFile);\n\n            return $response;\n        } catch (FilesystemException | UnableToReadFile $exception) {\n            // handle the error\n            throw $this->createNotFoundException('CSV file not found');\n        }\n    }\n\n    /**\n     * @Route(\"/download-xlsx-file\", name=\"pimcore_admin_asset_assethelper_downloadxlsxfile\", methods={\"GET\"})\n     *\n     * @param Request $request\n     * @param GridHelperService $gridHelperService\n     *\n     * @return BinaryFileResponse\n     */\n    public function downloadXlsxFileAction(Request $request, GridHelperService $gridHelperService)\n    {\n        $storage = Storage::get('temp');\n        $fileHandle = \\Pimcore\\File::getValidFilename($request->get('fileHandle'));\n        $csvFile = $this->getCsvFile($fileHandle);\n\n        try {\n            return $gridHelperService->createXlsxExportFile($storage, $fileHandle, $csvFile);\n        } catch (\\Exception | FilesystemException | UnableToReadFile $exception) {\n            // handle the error\n            throw $this->createNotFoundException('XLSX file not found');\n        }\n    }\n\n    /**\n     * @Route(\"/get-metadata-for-column-config\", name=\"pimcore_admin_asset_assethelper_getmetadataforcolumnconfig\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getMetadataForColumnConfigAction(Request $request)\n    {\n        $result = [];\n\n        //default metadata\n        $defaultMetadataNames = ['copyright', 'alt', 'title'];\n        foreach ($defaultMetadataNames as $defaultMetadata) {\n            $defaultColumns[] = ['title' => $defaultMetadata, 'name' => $defaultMetadata, 'datatype' => 'data', 'fieldtype' => 'input'];\n        }\n        $result['defaultColumns']['nodeLabel'] = 'default_metadata';\n        $result['defaultColumns']['nodeType'] = 'image';\n        $result['defaultColumns']['children'] = $defaultColumns;\n\n        //predefined metadata\n        $list = Metadata\\Predefined\\Listing::getByTargetType('asset');\n        $metadataItems = [];\n        $tmp = [];\n        foreach ($list as $item) {\n            //only allow unique metadata columns with subtypes\n            $uniqueKey = $item->getName().'_'.$item->getTargetSubtype();\n            if (!in_array($uniqueKey, $tmp) && !in_array($item->getName(), $defaultMetadataNames)) {\n                $tmp[] = $uniqueKey;\n                $item->expand();\n                $name = SecurityHelper::convertHtmlSpecialChars($item->getName());\n                $metadataItems[] = [\n                    'title' => $name,\n                    'name' => $name,\n                    'subtype' => $item->getTargetSubtype(),\n                    'datatype' => 'data',\n                    'fieldtype' => $item->getType(),\n                    'config' => $item->getConfig(),\n                ];\n            }\n        }\n\n        $result['metadataColumns']['children'] = $metadataItems;\n        $result['metadataColumns']['nodeLabel'] = 'predefined_metadata';\n        $result['metadataColumns']['nodeType'] = 'metadata';\n\n        //system columns\n        $systemColumnNames = Asset\\Service::GRID_SYSTEM_COLUMNS;\n        $systemColumns = [];\n        foreach ($systemColumnNames as $systemColumn) {\n            $systemColumns[] = ['title' => $systemColumn, 'name' => $systemColumn, 'datatype' => 'data', 'fieldtype' => 'system'];\n        }\n        $result['systemColumns']['nodeLabel'] = 'system_columns';\n        $result['systemColumns']['nodeType'] = 'system';\n        $result['systemColumns']['children'] = $systemColumns;\n\n        return $this->adminJson($result);\n    }\n\n    /**\n     * @Route(\"/get-batch-jobs\", name=\"pimcore_admin_asset_assethelper_getbatchjobs\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getBatchJobsAction(Request $request, GridHelperService $gridHelperService)\n    {\n        if ($request->get('language')) {\n            $request->setLocale($request->get('language'));\n        }\n\n        $allParams = array_merge($request->request->all(), $request->query->all());\n        $list = $gridHelperService->prepareAssetListingForGrid($allParams, $this->getAdminUser());\n\n        $jobs = $list->loadIdList();\n\n        return $this->adminJson(['success' => true, 'jobs' => $jobs]);\n    }\n\n    /**\n     * @Route(\"/batch\", name=\"pimcore_admin_asset_assethelper_batch\", methods={\"PUT\"})\n     *\n     * @param Request $request\n     * @param EventDispatcherInterface $eventDispatcher\n     *\n     * @return JsonResponse\n     */\n    public function batchAction(Request $request, EventDispatcherInterface $eventDispatcher)\n    {\n        try {\n            if ($request->get('data')) {\n                $loader = \\Pimcore::getContainer()->get('pimcore.implementation_loader.asset.metadata.data');\n\n                $data = $this->decodeJson($request->get('data'), true);\n\n                $updateEvent = new GenericEvent($this, [\n                    'data' => $data,\n                    'processed' => false,\n                ]);\n\n                $eventDispatcher->dispatch($updateEvent, AdminEvents::ASSET_LIST_BEFORE_BATCH_UPDATE);\n\n                $processed = $updateEvent->getArgument('processed');\n\n                if ($processed) {\n                    return $this->adminJson(['success' => true]);\n                }\n\n                $language = null;\n                if (isset($data['language'])) {\n                    $language = $data['language'] != 'default' ? $data['language'] : null;\n                }\n\n                $asset = Asset::getById($data['job']);\n\n                if ($asset) {\n                    if (!$asset->isAllowed('publish')) {\n                        throw new \\Exception(\"Permission denied. You don't have the rights to save this asset.\");\n                    }\n\n                    $metadata = $asset->getMetadata(null, null, false, true);\n                    $dirty = false;\n\n                    $name = $data['name'];\n                    $value = $data['value'];\n\n                    if ($data['valueType'] == 'object') {\n                        $value = $this->decodeJson($value);\n                    }\n\n                    $fieldDef = explode('~', $name);\n                    $name = $fieldDef[0];\n                    if (count($fieldDef) > 1) {\n                        $language = ($fieldDef[1] == 'none' ? '' : $fieldDef[1]);\n                    }\n\n                    foreach ($metadata as $idx => &$em) {\n                        if ($em['name'] == $name && $em['language'] == $language) {\n                            try {\n                                $dataImpl = $loader->build($em['type']);\n                                $value = $dataImpl->getDataFromListfolderGrid($value, $em);\n                            } catch (UnsupportedException $le) {\n                                Logger::error('could not resolve metadata implementation for ' . $em['type']);\n                            }\n                            $em['data'] = $value;\n                            $dirty = true;\n\n                            break;\n                        }\n                    }\n\n                    if (!$dirty) {\n                        $defaulMetadata = ['title', 'alt', 'copyright'];\n                        if (in_array($name, $defaulMetadata)) {\n                            $newEm = [\n                                'name' => $name,\n                                'language' => $language,\n                                'type' => 'input',\n                                'data' => $value,\n                            ];\n\n                            try {\n                                $dataImpl = $loader->build($newEm['type']);\n                                $newEm['data'] = $dataImpl->getDataFromListfolderGrid($value, $newEm);\n                            } catch (UnsupportedException $le) {\n                                Logger::error('could not resolve metadata implementation for ' . $newEm['type']);\n                            }\n\n                            $metadata[] = $newEm;\n                            $dirty = true;\n                        } else {\n                            $predefined = Metadata\\Predefined::getByName($name);\n                            if ($predefined && (empty($predefined->getTargetSubtype())\n                                    || $predefined->getTargetSubtype() == $asset->getType())) {\n                                $newEm = [\n                                    'name' => $name,\n                                    'language' => $language,\n                                    'type' => $predefined->getType(),\n                                    'data' => $value,\n                                ];\n\n                                try {\n                                    $dataImpl = $loader->build($newEm['type']);\n                                    $newEm['data'] = $dataImpl->getDataFromListfolderGrid($value, $newEm);\n                                } catch (UnsupportedException $le) {\n                                    Logger::error('could not resolve metadata implementation for ' . $newEm['type']);\n                                }\n\n                                $metadata[] = $newEm;\n\n                                $dirty = true;\n                            }\n                        }\n                    }\n\n                    try {\n                        if ($dirty) {\n                            // $metadata = Asset\\Service::minimizeMetadata($metadata, \"grid\");\n                            $asset->setMetadataRaw($metadata);\n                            $asset->save();\n\n                            return $this->adminJson(['success' => true]);\n                        }\n                    } catch (\\Exception $e) {\n                        return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n                    }\n                } else {\n                    Logger::debug('AssetHelperController::batchAction => There is no asset left to update.');\n\n                    return $this->adminJson(['success' => false, 'message' => 'AssetHelperController::batchAction => There is no asset left to update.']);\n                }\n            }\n        } catch (\\Exception $e) {\n            Logger::err($e);\n\n            return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n        }\n\n        return $this->adminJson(['success' => false, 'message' => 'something went wrong.']);\n    }\n}\n", "<?php\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\Bundle\\AdminBundle\\Controller\\Admin\\DataObject;\n\nuse League\\Flysystem\\FilesystemException;\nuse League\\Flysystem\\UnableToReadFile;\nuse PhpOffice\\PhpSpreadsheet\\Reader\\Csv;\nuse PhpOffice\\PhpSpreadsheet\\Writer\\Xlsx;\nuse Pimcore\\Bundle\\AdminBundle\\Controller\\AdminController;\nuse Pimcore\\Bundle\\AdminBundle\\Helper\\GridHelperService;\nuse Pimcore\\Config;\nuse Pimcore\\Db;\nuse Pimcore\\Event\\AdminEvents;\nuse Pimcore\\File;\nuse Pimcore\\Localization\\LocaleServiceInterface;\nuse Pimcore\\Logger;\nuse Pimcore\\Model\\DataObject;\nuse Pimcore\\Model\\GridConfig;\nuse Pimcore\\Model\\GridConfigFavourite;\nuse Pimcore\\Model\\GridConfigShare;\nuse Pimcore\\Model\\User;\nuse Pimcore\\Security\\SecurityHelper;\nuse Pimcore\\Tool;\nuse Pimcore\\Tool\\Storage;\nuse Pimcore\\Version;\nuse Symfony\\Component\\EventDispatcher\\GenericEvent;\nuse Symfony\\Component\\HttpFoundation\\BinaryFileResponse;\nuse Symfony\\Component\\HttpFoundation\\HeaderUtils;\nuse Symfony\\Component\\HttpFoundation\\JsonResponse;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpFoundation\\Session\\Attribute\\AttributeBagInterface;\nuse Symfony\\Component\\Routing\\Annotation\\Route;\nuse Symfony\\Contracts\\EventDispatcher\\EventDispatcherInterface;\n\n/**\n * @Route(\"/object-helper\", name=\"pimcore_admin_dataobject_dataobjecthelper_\")\n *\n * @internal\n */\nclass DataObjectHelperController extends AdminController\n{\n    const SYSTEM_COLUMNS = ['id', 'fullpath', 'key', 'published', 'creationDate', 'modificationDate', 'filename', 'classname'];\n\n    /**\n     * @Route(\"/load-object-data\", name=\"loadobjectdata\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function loadObjectDataAction(Request $request)\n    {\n        $object = DataObject::getById((int) $request->get('id'));\n        $result = [];\n        if ($object) {\n            $result['success'] = true;\n            $fields = $request->get('fields');\n            $result['fields'] = DataObject\\Service::gridObjectData($object, $fields);\n        } else {\n            $result['success'] = false;\n        }\n\n        return $this->adminJson($result);\n    }\n\n    /**\n     * @param int $userId\n     * @param string $classId\n     * @param string|null $searchType\n     *\n     * @return array\n     */\n    public function getMyOwnGridColumnConfigs($userId, $classId, $searchType = null)\n    {\n        $db = Db::get();\n        $configListingConditionParts = [];\n        $configListingConditionParts[] = 'ownerId = ' . $userId;\n        $configListingConditionParts[] = 'classId = ' . $db->quote($classId);\n\n        if ($searchType) {\n            $configListingConditionParts[] = 'searchType = ' . $db->quote($searchType);\n        }\n\n        $configCondition = implode(' AND ', $configListingConditionParts);\n        $configListing = new GridConfig\\Listing();\n        $configListing->setOrderKey('name');\n        $configListing->setOrder('ASC');\n        $configListing->setCondition($configCondition);\n        $configListing = $configListing->load();\n\n        $configData = [];\n        if (is_array($configListing)) {\n            foreach ($configListing as $config) {\n                $configData[] = $config->getObjectVars();\n            }\n        }\n\n        return $configData;\n    }\n\n    /**\n     * @param User $user\n     * @param string $classId\n     * @param string $searchType\n     *\n     * @return array\n     */\n    public function getSharedGridColumnConfigs($user, $classId, $searchType = null)\n    {\n        $configListing = [];\n\n        $userIds = [$user->getId()];\n        // collect all roles\n        $userIds = array_merge($userIds, $user->getRoles());\n        $userIds = implode(',', $userIds);\n        $db = Db::get();\n\n        $query = 'select distinct c1.id from gridconfigs c1, gridconfig_shares s\n                    where (c1.searchType = ' . $db->quote($searchType) . ' and ((c1.id = s.gridConfigId and s.sharedWithUserId IN (' . $userIds . '))) and c1.classId = ' . $db->quote($classId) . ')\n                            UNION distinct select c2.id from gridconfigs c2 where shareGlobally = 1 and c2.classId = '. $db->quote($classId) . '  and c2.ownerId != ' . $db->quote($user->getId());\n\n        $ids = $db->fetchFirstColumn($query);\n\n        if ($ids) {\n            $ids = implode(',', $ids);\n            $configListing = new GridConfig\\Listing();\n            $configListing->setOrderKey('name');\n            $configListing->setOrder('ASC');\n            $configListing->setCondition('id in (' . $ids . ')');\n            $configListing = $configListing->load();\n        }\n\n        $configData = [];\n        if (is_array($configListing)) {\n            foreach ($configListing as $config) {\n                $configData[] = $config->getObjectVars();\n            }\n        }\n\n        return $configData;\n    }\n\n    /**\n     * @Route(\"/get-export-configs\", name=\"getexportconfigs\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getExportConfigsAction(Request $request)\n    {\n        $classId = $request->get('classId');\n        $list = $this->getMyOwnGridColumnConfigs($this->getAdminUser()->getId(), $classId);\n        if (!is_array($list)) {\n            $list = [];\n        }\n        $list = array_merge($list, $this->getSharedGridColumnConfigs($this->getAdminUser(), $classId));\n        $result = [];\n\n        $result[] = [\n            'id' => -1,\n            'name' => '--default--',\n        ];\n\n        if ($list) {\n            /** @var GridConfig $config */\n            foreach ($list as $config) {\n                $result[] = [\n                    'id' => $config['id'],\n                    'name' => $config['name'],\n                ];\n            }\n        }\n\n        return $this->adminJson(['success' => true, 'data' => $result]);\n    }\n\n    /**\n     * @Route(\"/grid-delete-column-config\", name=\"griddeletecolumnconfig\", methods={\"DELETE\"})\n     *\n     * @param Request $request\n     * @param EventDispatcherInterface $eventDispatcher\n     * @param Config $config\n     *\n     * @return JsonResponse\n     */\n    public function gridDeleteColumnConfigAction(Request $request, EventDispatcherInterface $eventDispatcher, Config $config)\n    {\n        $gridConfigId = $request->get('gridConfigId');\n        $gridConfig = GridConfig::getById($gridConfigId);\n        $success = false;\n        if ($gridConfig) {\n            if ($gridConfig->getOwnerId() != $this->getAdminUser()->getId() && !$this->getAdminUser()->isAdmin()) {\n                throw new \\Exception(\"don't mess with someone elses grid config\");\n            }\n\n            $gridConfig->delete();\n            $success = true;\n        }\n\n        $newGridConfig = $this->doGetGridColumnConfig($request, $config, true);\n        $newGridConfig['deleteSuccess'] = $success;\n\n        $event = new GenericEvent($this, [\n            'data' => $newGridConfig,\n            'request' => $request,\n            'config' => $config,\n            'context' => 'delete',\n        ]);\n\n        $eventDispatcher->dispatch($event, AdminEvents::OBJECT_GRID_GET_COLUMN_CONFIG_PRE_SEND_DATA);\n        $newGridConfig = $event->getArgument('data');\n\n        return $this->adminJson($newGridConfig);\n    }\n\n    /**\n     * @Route(\"/grid-get-column-config\", name=\"gridgetcolumnconfig\", methods={\"GET\"})\n     *\n     * @param Request $request\n     * @param EventDispatcherInterface $eventDispatcher\n     * @param Config $config\n     *\n     * @return JsonResponse\n     */\n    public function gridGetColumnConfigAction(Request $request, EventDispatcherInterface $eventDispatcher, Config $config)\n    {\n        $result = $this->doGetGridColumnConfig($request, $config);\n\n        $event = new GenericEvent($this, [\n            'data' => $result,\n            'request' => $request,\n            'config' => $config,\n            'context' => 'get',\n        ]);\n\n        $eventDispatcher->dispatch($event, AdminEvents::OBJECT_GRID_GET_COLUMN_CONFIG_PRE_SEND_DATA);\n        $result = $event->getArgument('data');\n\n        return $this->adminJson($result);\n    }\n\n    /**\n     * @param Request $request\n     * @param Config $config\n     * @param bool $isDelete\n     *\n     * @return array\n     */\n    public function doGetGridColumnConfig(Request $request, Config $config, $isDelete = false)\n    {\n        $class = null;\n        $fields = null;\n\n        if ($request->get('id')) {\n            $class = DataObject\\ClassDefinition::getById($request->get('id'));\n        } elseif ($request->get('name')) {\n            $class = DataObject\\ClassDefinition::getByName($request->get('name'));\n        }\n\n        $gridConfigId = null;\n        $gridType = 'search';\n        if ($request->get('gridtype')) {\n            $gridType = $request->get('gridtype');\n        }\n\n        $objectId = (int) $request->get('objectId');\n\n        if ($objectId) {\n            $fields = DataObject\\Service::getCustomGridFieldDefinitions($class->getId(), $objectId);\n        }\n\n        $context = ['purpose' => 'gridconfig'];\n        if ($class) {\n            $context['class'] = $class;\n        }\n\n        if ($objectId) {\n            $object = DataObject::getById($objectId);\n            $context['object'] = $object;\n        }\n\n        if (!$fields && $class) {\n            $fields = $class->getFieldDefinitions();\n        }\n\n        $types = [];\n        if ($request->get('types')) {\n            $types = explode(',', $request->get('types'));\n        }\n\n        $userId = $this->getAdminUser()->getId();\n\n        $requestedGridConfigId = $isDelete ? null : $request->get('gridConfigId');\n\n        // grid config\n        $gridConfig = [];\n        $searchType = $request->get('searchType');\n\n        if (strlen($requestedGridConfigId) == 0 && $class) {\n            // check if there is a favourite view\n            $favourite = GridConfigFavourite::getByOwnerAndClassAndObjectId($userId, $class->getId(), $objectId ?: 0, $searchType);\n            if (!$favourite && $objectId) {\n                $favourite = GridConfigFavourite::getByOwnerAndClassAndObjectId($userId, $class->getId(), 0, $searchType);\n            }\n\n            if ($favourite) {\n                $requestedGridConfigId = $favourite->getGridConfigId();\n            }\n        }\n\n        if (is_numeric($requestedGridConfigId) && $requestedGridConfigId > 0) {\n            $db = Db::get();\n            $savedGridConfig = GridConfig::getById((int) $requestedGridConfigId);\n\n            if ($savedGridConfig) {\n                $shared = false;\n                if (!$this->getAdminUser()->isAdmin()) {\n                    $userIds = [$this->getAdminUser()->getId()];\n                    if ($this->getAdminUser()->getRoles()) {\n                        $userIds = array_merge($userIds, $this->getAdminUser()->getRoles());\n                    }\n                    $userIds = implode(',', $userIds);\n                    $shared = ($savedGridConfig->getOwnerId() != $userId && $savedGridConfig->isShareGlobally()) || $db->fetchOne('select 1 from gridconfig_shares where sharedWithUserId IN ('.$userIds.') and gridConfigId = '.$savedGridConfig->getId());\n                    //                  $shared = $savedGridConfig->isShareGlobally() || GridConfigShare::getByGridConfigAndSharedWithId($savedGridConfig->getId(), $this->getUser()->getId());\n\n                    if (!$shared && $savedGridConfig->getOwnerId() != $this->getAdminUser()->getId()) {\n                        throw new \\Exception('You are neither the owner of this config nor it is shared with you');\n                    }\n                }\n\n                $gridConfigId = $savedGridConfig->getId();\n                $gridConfig = $savedGridConfig->getConfig();\n                $gridConfig = json_decode($gridConfig, true);\n                $gridConfigName = $savedGridConfig->getName();\n                $owner = $savedGridConfig->getOwnerId();\n                $ownerObject = User::getById($owner);\n                if ($ownerObject instanceof User) {\n                    $owner = $ownerObject->getName();\n                }\n                $modificationDate = $savedGridConfig->getModificationDate();\n                $gridConfigDescription = $savedGridConfig->getDescription();\n                $sharedGlobally = $savedGridConfig->isShareGlobally();\n                $setAsFavourite = $savedGridConfig->isSetAsFavourite();\n\n                foreach($gridConfig['columns'] as &$column) {\n                    if (array_key_exists('isOperator', $column) && $column['isOperator']) {\n                        $colAttributes = &$column['fieldConfig']['attributes'];\n                        SecurityHelper::convertHtmlSpecialCharsArrayKeys($colAttributes, ['label', 'attribute', 'param1']);\n                    }\n                }\n            }\n        }\n\n        $localizedFields = [];\n        $objectbrickFields = [];\n        if (is_array($fields)) {\n            foreach ($fields as $key => $field) {\n                if ($field instanceof DataObject\\ClassDefinition\\Data\\Localizedfields) {\n                    $localizedFields[] = $field;\n                } elseif ($field instanceof DataObject\\ClassDefinition\\Data\\Objectbricks) {\n                    $objectbrickFields[] = $field;\n                }\n            }\n        }\n\n        $availableFields = [];\n\n        if (empty($gridConfig)) {\n            $availableFields = $this->getDefaultGridFields(\n                $request->get('no_system_columns'),\n                $class,\n                $gridType,\n                $request->get('no_brick_columns'),\n                $fields,\n                $context,\n                $objectId,\n                $types);\n        } else {\n            $savedColumns = $gridConfig['columns'];\n            foreach ($savedColumns as $key => $sc) {\n                if (!$sc['hidden']) {\n                    if (in_array($key, self::SYSTEM_COLUMNS)) {\n                        $colConfig = [\n                            'key' => $key,\n                            'type' => 'system',\n                            'label' => $key,\n                            'locked' => $sc['locked'] ?? null,\n                            'position' => $sc['position'],\n                        ];\n                        if (isset($sc['width'])) {\n                            $colConfig['width'] = $sc['width'];\n                        }\n                        $availableFields[] = $colConfig;\n                    } else {\n                        $keyParts = explode('~', $key);\n\n                        if (substr($key, 0, 1) == '~') {\n                            // not needed for now\n                            $type = $keyParts[1];\n                            //                            $field = $keyParts[2];\n                            $groupAndKeyId = explode('-', $keyParts[3]);\n                            $keyId = (int) $groupAndKeyId[1];\n\n                            if ($type == 'classificationstore') {\n                                $keyDef = DataObject\\Classificationstore\\KeyConfig::getById($keyId);\n                                if ($keyDef) {\n                                    $keyFieldDef = json_decode($keyDef->getDefinition(), true);\n                                    if ($keyFieldDef) {\n                                        $keyFieldDef = \\Pimcore\\Model\\DataObject\\Classificationstore\\Service::getFieldDefinitionFromJson($keyFieldDef, $keyDef->getType());\n                                        $fieldConfig = $this->getFieldGridConfig($keyFieldDef, $gridType, $sc['position'], true, null, $class, $objectId);\n                                        if ($fieldConfig) {\n                                            $fieldConfig['key'] = $key;\n                                            $fieldConfig['label'] = '#' . $keyFieldDef->getTitle();\n                                            if (isset($sc['locked'])) {\n                                                $fieldConfig['locked'] = $sc['locked'];\n                                            }\n                                            $availableFields[] = $fieldConfig;\n                                        }\n                                    }\n                                }\n                            }\n                        } elseif (count($keyParts) > 1) {\n                            $brick = $keyParts[0];\n                            $brickDescriptor = null;\n\n                            if (strpos($brick, '?') !== false) {\n                                $brickDescriptor = substr($brick, 1);\n                                $brickDescriptor = json_decode($brickDescriptor, true);\n                                $keyPrefix = $brick . '~';\n                                $brick = $brickDescriptor['containerKey'];\n                            } else {\n                                $keyPrefix = $brick . '~';\n                            }\n\n                            $fieldname = $keyParts[1];\n\n                            $brickClass = DataObject\\Objectbrick\\Definition::getByKey($brick);\n\n                            $fd = null;\n                            if ($brickClass instanceof DataObject\\Objectbrick\\Definition) {\n                                if ($brickDescriptor) {\n                                    $innerContainer = $brickDescriptor['innerContainer'] ?? 'localizedfields';\n                                    /** @var DataObject\\ClassDefinition\\Data\\Localizedfields $localizedFields */\n                                    $localizedFields = $brickClass->getFieldDefinition($innerContainer);\n                                    $fd = $localizedFields->getFieldDefinition($brickDescriptor['brickfield']);\n                                } else {\n                                    $fd = $brickClass->getFieldDefinition($fieldname);\n                                }\n                            }\n\n                            if ($fd !== null) {\n                                $fieldConfig = $this->getFieldGridConfig($fd, $gridType, $sc['position'], true, $keyPrefix, $class, $objectId);\n                                if (!empty($fieldConfig)) {\n                                    if (isset($sc['width'])) {\n                                        $fieldConfig['width'] = $sc['width'];\n                                    }\n                                    if (isset($sc['locked'])) {\n                                        $fieldConfig['locked'] = $sc['locked'];\n                                    }\n                                    $availableFields[] = $fieldConfig;\n                                }\n                            }\n                        } else {\n                            if (DataObject\\Service::isHelperGridColumnConfig($key)) {\n                                $calculatedColumnConfig = $this->getCalculatedColumnConfig($savedColumns[$key]);\n                                if ($calculatedColumnConfig) {\n                                    $availableFields[] = $calculatedColumnConfig;\n                                }\n                            } else {\n                                $fd = $class->getFieldDefinition($key);\n                                //if not found, look for localized fields\n                                if (empty($fd)) {\n                                    foreach ($localizedFields as $lf) {\n                                        $fd = $lf->getFieldDefinition($key);\n                                        if (!empty($fd)) {\n                                            break;\n                                        }\n                                    }\n                                }\n\n                                if (!empty($fd)) {\n                                    $fieldConfig = $this->getFieldGridConfig($fd, $gridType, $sc['position'], true, null, $class, $objectId);\n                                    if (!empty($fieldConfig)) {\n                                        if (isset($sc['width'])) {\n                                            $fieldConfig['width'] = $sc['width'];\n                                        }\n                                        if (isset($sc['locked'])) {\n                                            $fieldConfig['locked'] = $sc['locked'];\n                                        }\n                                        $availableFields[] = $fieldConfig;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        usort($availableFields, function ($a, $b) {\n            if ($a['position'] == $b['position']) {\n                return 0;\n            }\n\n            return ($a['position'] < $b['position']) ? -1 : 1;\n        });\n\n        $frontendLanguages = Tool\\Admin::reorderWebsiteLanguages(\\Pimcore\\Tool\\Admin::getCurrentUser(), $config['general']['valid_languages']);\n        if ($frontendLanguages) {\n            $language = explode(',', $frontendLanguages)[0];\n        } else {\n            $language = $request->getLocale();\n        }\n\n        if (!Tool::isValidLanguage($language)) {\n            $validLanguages = Tool::getValidLanguages();\n            $language = $validLanguages[0];\n        }\n\n        if (!empty($gridConfig) && !empty($gridConfig['language'])) {\n            $language = $gridConfig['language'];\n        }\n\n        $availableConfigs = $class ? $this->getMyOwnGridColumnConfigs($userId, $class->getId(), $searchType) : [];\n        $sharedConfigs = $class ? $this->getSharedGridColumnConfigs($this->getAdminUser(), $class->getId(), $searchType) : [];\n        $settings = $this->getShareSettings((int)$gridConfigId);\n        $settings['gridConfigId'] = (int)$gridConfigId;\n        $settings['gridConfigName'] = $gridConfigName ?? null;\n        $settings['gridConfigDescription'] = $gridConfigDescription ?? null;\n        $settings['owner'] = $owner ?? null;\n        $settings['modificationDate'] = $modificationDate ?? null;\n        $settings['shareGlobally'] = $sharedGlobally ?? null;\n        $settings['setAsFavourite'] = $setAsFavourite ?? null;\n        $settings['isShared'] = !$gridConfigId || ($shared ?? null);\n\n        $context = $gridConfig['context'] ?? null;\n        if ($context) {\n            $context = json_decode($context, true);\n        }\n\n        return [\n            'sortinfo' => $gridConfig['sortinfo'] ?? false,\n            'language' => $language,\n            'availableFields' => $availableFields,\n            'settings' => $settings,\n            'onlyDirectChildren' => $gridConfig['onlyDirectChildren'] ?? false,\n            'pageSize' => $gridConfig['pageSize'] ?? false,\n            'availableConfigs' => $availableConfigs,\n            'sharedConfigs' => $sharedConfigs,\n            'context' => $context,\n            'sqlFilter' => $gridConfig['sqlFilter'] ?? '',\n            'searchFilter' => $gridConfig['searchFilter'] ?? '',\n        ];\n    }\n\n    /**\n     * @param bool $noSystemColumns\n     * @param DataObject\\ClassDefinition|null $class\n     * @param string $gridType\n     * @param bool $noBrickColumns\n     * @param DataObject\\ClassDefinition\\Data[] $fields\n     * @param array $context\n     * @param int $objectId\n     * @param array $types\n     *\n     * @return array\n     */\n    public function getDefaultGridFields($noSystemColumns, $class, $gridType, $noBrickColumns, $fields, $context, $objectId, $types = [])\n    {\n        $count = 0;\n        $availableFields = [];\n\n        if (!$noSystemColumns && $class) {\n            $vis = $class->getPropertyVisibility();\n            foreach (self::SYSTEM_COLUMNS as $sc) {\n                $key = $sc;\n                if ($key === 'fullpath') {\n                    $key = 'path';\n                }\n\n                if (empty($types) && (!empty($vis[$gridType][$key]) || $gridType === 'all')) {\n                    $availableFields[] = [\n                        'key' => $sc,\n                        'type' => 'system',\n                        'label' => $sc,\n                        'position' => $count, ];\n                    $count++;\n                }\n            }\n        }\n\n        $includeBricks = !$noBrickColumns;\n\n        if (is_array($fields)) {\n            foreach ($fields as $key => $field) {\n                if ($field instanceof DataObject\\ClassDefinition\\Data\\Localizedfields) {\n                    foreach ($field->getFieldDefinitions($context) as $fd) {\n                        if (empty($types) || in_array($fd->getFieldType(), $types)) {\n                            $fieldConfig = $this->getFieldGridConfig($fd, $gridType, $count, false, null, $class, $objectId);\n                            if (!empty($fieldConfig)) {\n                                $availableFields[] = $fieldConfig;\n                                $count++;\n                            }\n                        }\n                    }\n                } elseif ($field instanceof DataObject\\ClassDefinition\\Data\\Objectbricks && $includeBricks) {\n                    if (in_array($field->getFieldType(), $types)) {\n                        $fieldConfig = $this->getFieldGridConfig($field, $gridType, $count, false, null, $class, $objectId);\n                        if (!empty($fieldConfig)) {\n                            $availableFields[] = $fieldConfig;\n                            $count++;\n                        }\n                    } else {\n                        $allowedTypes = $field->getAllowedTypes();\n                        if (!empty($allowedTypes)) {\n                            foreach ($allowedTypes as $t) {\n                                $brickClass = DataObject\\Objectbrick\\Definition::getByKey($t);\n                                $brickFields = $brickClass->getFieldDefinitions($context);\n\n                                $this->appendBrickFields($field, $brickFields, $availableFields, $gridType, $count, $t, $class, $objectId);\n                            }\n                        }\n                    }\n                } else {\n                    if (empty($types) || in_array($field->getFieldType(), $types)) {\n                        $fieldConfig = $this->getFieldGridConfig($field, $gridType, $count, !empty($types), null, $class, $objectId);\n                        if (!empty($fieldConfig)) {\n                            $availableFields[] = $fieldConfig;\n                            $count++;\n                        }\n                    }\n                }\n            }\n        }\n\n        return $availableFields;\n    }\n\n    /**\n     * @param DataObject\\ClassDefinition\\Data $field\n     * @param DataObject\\ClassDefinition\\Data[] $brickFields\n     * @param array $availableFields\n     * @param string $gridType\n     * @param int $count\n     * @param string $brickType\n     * @param DataObject\\ClassDefinition $class\n     * @param int $objectId\n     * @param array|null $context\n     */\n    protected function appendBrickFields($field, $brickFields, &$availableFields, $gridType, &$count, $brickType, $class, $objectId, $context = null)\n    {\n        if (!empty($brickFields)) {\n            foreach ($brickFields as $bf) {\n                if ($bf instanceof DataObject\\ClassDefinition\\Data\\Localizedfields) {\n                    $localizedFieldDefinitions = $bf->getFieldDefinitions();\n\n                    $localizedContext = [\n                        'containerKey' => $brickType,\n                        'fieldname' => $field->getName(),\n                    ];\n\n                    $this->appendBrickFields($bf, $localizedFieldDefinitions, $availableFields, $gridType, $count, $brickType, $class, $objectId, $localizedContext);\n                } else {\n                    if ($context) {\n                        $context['brickfield'] = $bf->getName();\n                        $keyPrefix = '?' . json_encode($context) . '~';\n                    } else {\n                        $keyPrefix = $brickType . '~';\n                    }\n                    $fieldConfig = $this->getFieldGridConfig($bf, $gridType, $count, false, $keyPrefix, $class, $objectId);\n                    if (!empty($fieldConfig)) {\n                        $availableFields[] = $fieldConfig;\n                        $count++;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @param array $config\n     *\n     * @return mixed\n     */\n    protected function getCalculatedColumnConfig($config)\n    {\n        try {\n            $calculatedColumnConfig = Tool\\Session::useSession(function (AttributeBagInterface $session) use ($config) {\n                //otherwise create a new one\n\n                $calculatedColumn = [];\n                // note that we have to generate a new key!\n\n                $existingKey = $config['fieldConfig']['key'];\n                $calculatedColumnConfig['key'] = $existingKey;\n                $calculatedColumnConfig['position'] = $config['position'];\n                $calculatedColumnConfig['isOperator'] = true;\n                $calculatedColumnConfig['attributes'] = $config['fieldConfig']['attributes'];\n                $calculatedColumnConfig['width'] = $config['width'];\n                $calculatedColumnConfig['locked'] = $config['locked'];\n\n                $existingColumns = $session->get('helpercolumns', []);\n\n                if (isset($existingColumns[$existingKey])) {\n                    // if the configuration is still in the session, then reuse it\n                    return $calculatedColumnConfig;\n                }\n\n                $newKey = '#' . uniqid();\n                $calculatedColumnConfig['key'] = $newKey;\n\n                // prepare a column config on the fly\n                $phpConfig = json_encode($config['fieldConfig']);\n                $phpConfig = json_decode($phpConfig);\n                $helperColumns = [];\n                $helperColumns[$newKey] = $phpConfig;\n\n                $helperColumns = array_merge($helperColumns, $existingColumns);\n                $session->set('helpercolumns', $helperColumns);\n\n                return $calculatedColumnConfig;\n            }, 'pimcore_gridconfig');\n\n            return $calculatedColumnConfig;\n        } catch (\\Exception $e) {\n            Logger::error((string) $e);\n        }\n    }\n\n    /**\n     * @Route(\"/prepare-helper-column-configs\", name=\"preparehelpercolumnconfigs\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function prepareHelperColumnConfigs(Request $request)\n    {\n        $helperColumns = [];\n        $newData = [];\n        /** @var \\stdClass[] $data */\n        $data = json_decode($request->get('columns'));\n        foreach ($data as $item) {\n            if (!empty($item->isOperator)) {\n                $itemKey = '#' . uniqid();\n\n                $item->key = $itemKey;\n                $newData[] = $item;\n                $helperColumns[$itemKey] = $item;\n            } else {\n                $newData[] = $item;\n            }\n        }\n\n        Tool\\Session::useSession(function (AttributeBagInterface $session) use ($helperColumns) {\n            $existingColumns = $session->get('helpercolumns', []);\n            $helperColumns = array_merge($helperColumns, $existingColumns);\n            $session->set('helpercolumns', $helperColumns);\n        }, 'pimcore_gridconfig');\n\n        return $this->adminJson(['success' => true, 'columns' => $newData]);\n    }\n\n    /**\n     * @Route(\"/grid-config-apply-to-all\", name=\"gridconfigapplytoall\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function gridConfigApplyToAllAction(Request $request)\n    {\n        $objectId = $request->get('objectId');\n        $object = DataObject::getById($objectId);\n\n        if ($object->isAllowed('list')) {\n            $classId = $request->get('classId');\n            $searchType = $request->get('searchType');\n            $user = $this->getAdminUser();\n            $db = Db::get();\n            $db->executeQuery('delete from gridconfig_favourites where '\n                . 'ownerId = ' . $user->getId()\n                . ' and classId = ' . $db->quote($classId) .\n                ' and searchType = ' . $db->quote($searchType)\n                . ' and objectId != ' . $objectId . ' and objectId != 0');\n\n            return $this->adminJson(['success' => true]);\n        }\n\n        throw $this->createAccessDeniedHttpException();\n    }\n\n    /**\n     * @Route(\"/grid-mark-favourite-column-config\", name=\"gridmarkfavouritecolumnconfig\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function gridMarkFavouriteColumnConfigAction(Request $request)\n    {\n        $objectId = $request->get('objectId');\n        $object = DataObject::getById($objectId);\n\n        if ($object->isAllowed('list')) {\n            $classId = $request->get('classId');\n            $gridConfigId = $request->get('gridConfigId');\n            $searchType = $request->get('searchType');\n            $global = $request->get('global');\n            $user = $this->getAdminUser();\n            $type = $request->get('type');\n\n            $favourite = new GridConfigFavourite();\n            $favourite->setOwnerId($user->getId());\n            $class = DataObject\\ClassDefinition::getById($classId);\n            if (!$class) {\n                throw new \\Exception('class ' . $classId . ' does not exist anymore');\n            }\n            $favourite->setClassId($classId);\n            $favourite->setSearchType($searchType);\n            $favourite->setType($type);\n            $specializedConfigs = false;\n\n            try {\n                if ($gridConfigId != 0) {\n                    $gridConfig = GridConfig::getById($gridConfigId);\n                    $favourite->setGridConfigId($gridConfig->getId());\n                }\n                $favourite->setObjectId($objectId);\n                $favourite->save();\n\n                if ($global) {\n                    $favourite->setObjectId(0);\n                    $favourite->save();\n                }\n                $db = Db::get();\n                $count = $db->fetchOne('select * from gridconfig_favourites where '\n                    . 'ownerId = ' . $user->getId()\n                    . ' and classId = ' . $db->quote($classId).\n                    ' and searchType = ' . $db->quote($searchType)\n                    . ' and objectId != ' . $objectId . ' and objectId != 0'\n                    . ' and type != ' . $db->quote($type));\n                $specializedConfigs = $count > 0;\n            } catch (\\Exception $e) {\n                $favourite->delete();\n            }\n\n            return $this->adminJson(['success' => true, 'spezializedConfigs' => $specializedConfigs]);\n        }\n\n        throw $this->createAccessDeniedHttpException();\n    }\n\n    /**\n     * @param int $gridConfigId\n     *\n     * @return array\n     */\n    protected function getShareSettings($gridConfigId)\n    {\n        $result = [\n            'sharedUserIds' => [],\n            'sharedRoleIds' => [],\n        ];\n\n        $db = Db::get();\n        $allShares = $db->fetchAllAssociative('select s.sharedWithUserId, u.type from gridconfig_shares s, users u\n                      where s.sharedWithUserId = u.id and s.gridConfigId = ' . $gridConfigId);\n\n        if ($allShares) {\n            foreach ($allShares as $share) {\n                $type = $share['type'];\n                $key = 'shared' . ucfirst($type) . 'Ids';\n                $result[$key][] = $share['sharedWithUserId'];\n            }\n        }\n\n        foreach ($result as $idx => $value) {\n            $value = $value ? implode(',', $value) : '';\n            $result[$idx] = $value;\n        }\n\n        return $result;\n    }\n\n    /**\n     * @Route(\"/grid-save-column-config\", name=\"gridsavecolumnconfig\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function gridSaveColumnConfigAction(Request $request)\n    {\n        $objectId = $request->get('id');\n        $object   = DataObject::getById($objectId);\n\n        if ($object->isAllowed('list')) {\n            try {\n                $classId = $request->get('class_id');\n                $context = $request->get('context');\n\n                $searchType = $request->get('searchType');\n\n                // grid config\n                $gridConfigData = $this->decodeJson($request->get('gridconfig'));\n                $gridConfigData['pimcore_version'] = Version::getVersion();\n                $gridConfigData['pimcore_revision'] = Version::getRevision();\n\n                $gridConfigData['context'] = $context;\n\n                unset($gridConfigData['settings']['isShared']);\n\n                $metadata = $request->get('settings');\n                $metadata = json_decode($metadata, true);\n\n                $gridConfigId = $metadata['gridConfigId'];\n                $gridConfig = GridConfig::getById($gridConfigId);\n\n                if ($gridConfig && $gridConfig->getOwnerId() != $this->getAdminUser()->getId() && !$this->getAdminUser()->isAdmin()) {\n                    throw new \\Exception(\"don't mess around with somebody elses configuration\");\n                }\n\n                $this->updateGridConfigShares($gridConfig, $metadata);\n\n                if ($metadata['setAsFavourite'] && $this->getAdminUser()->isAdmin()) {\n                    $this->updateGridConfigFavourites($gridConfig, $metadata, $objectId);\n                }\n\n                if (!$gridConfig) {\n                    $gridConfig = new GridConfig();\n                    $gridConfig->setName(date('c'));\n                    $gridConfig->setClassId($classId);\n                    $gridConfig->setSearchType($searchType);\n\n                    $gridConfig->setOwnerId($this->getAdminUser()->getId());\n                }\n\n                if ($metadata) {\n                    $gridConfig->setName($metadata['gridConfigName']);\n                    $gridConfig->setDescription($metadata['gridConfigDescription']);\n                    $gridConfig->setShareGlobally($metadata['shareGlobally'] && $this->getAdminUser()->isAdmin());\n                    $gridConfig->setSetAsFavourite($metadata['setAsFavourite'] && $this->getAdminUser()->isAdmin());\n                }\n\n                $gridConfigData = json_encode($gridConfigData);\n                $gridConfig->setConfig($gridConfigData);\n                $gridConfig->save();\n\n                $userId = $this->getAdminUser()->getId();\n\n                $availableConfigs = $this->getMyOwnGridColumnConfigs($userId, $classId, $searchType);\n                $sharedConfigs = $this->getSharedGridColumnConfigs($this->getAdminUser(), $classId, $searchType);\n\n                $settings = $this->getShareSettings($gridConfig->getId());\n                $settings['gridConfigId'] = (int)$gridConfig->getId();\n                $settings['gridConfigName'] = $gridConfig->getName();\n                $settings['gridConfigDescription'] = $gridConfig->getDescription();\n                $settings['shareGlobally'] = $gridConfig->isShareGlobally();\n                $settings['setAsFavourite'] = $gridConfig->isSetAsFavourite();\n                $settings['isShared'] = $gridConfig->getOwnerId() != $this->getAdminUser()->getId() && !$this->getAdminUser()->isAdmin();\n\n                return $this->adminJson([\n                    'success' => true,\n                    'settings' => $settings,\n                    'availableConfigs' => $availableConfigs,\n                    'sharedConfigs' => $sharedConfigs,\n                ]);\n            } catch (\\Exception $e) {\n                return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n            }\n        }\n\n        throw $this->createAccessDeniedHttpException();\n    }\n\n    /**\n     * @param GridConfig|null $gridConfig\n     * @param array $metadata\n     *\n     * @throws \\Exception\n     */\n    protected function updateGridConfigShares($gridConfig, $metadata)\n    {\n        $user = $this->getAdminUser();\n        if (!$gridConfig || !$user->isAllowed('share_configurations')) {\n            // nothing to do\n            return;\n        }\n\n        if ($gridConfig->getOwnerId() != $user->getId() && !$user->isAdmin()) {\n            throw new \\Exception(\"don't mess with someone elses grid config\");\n        }\n        $combinedShares = [];\n        $sharedUserIds = $metadata['sharedUserIds'];\n        $sharedRoleIds = $metadata['sharedRoleIds'];\n\n        if ($sharedUserIds) {\n            $combinedShares = explode(',', $sharedUserIds);\n        }\n\n        if ($sharedRoleIds) {\n            $sharedRoleIds = explode(',', $sharedRoleIds);\n            $combinedShares = array_merge($combinedShares, $sharedRoleIds);\n        }\n\n        $db = Db::get();\n        $db->delete('gridconfig_shares', ['gridConfigId' => $gridConfig->getId()]);\n\n        foreach ($combinedShares as $id) {\n            $share = new GridConfigShare();\n            $share->setGridConfigId($gridConfig->getId());\n            $share->setSharedWithUserId((int) $id);\n            $share->save();\n        }\n    }\n\n    /**\n     * @param GridConfig|null $gridConfig\n     * @param array $metadata\n     * @param int $objectId\n     *\n     * @throws \\Exception\n     */\n    protected function updateGridConfigFavourites($gridConfig, $metadata, $objectId)\n    {\n        $currentUser = $this->getAdminUser();\n\n        if (!$gridConfig || $currentUser === null || !$currentUser->isAllowed('share_configurations')) {\n            // nothing to do\n            return;\n        }\n\n        if (!$currentUser->isAdmin() && (int) $gridConfig->getOwnerId() !== $currentUser->getId()) {\n            throw new \\Exception(\"don't mess with someone elses grid config\");\n        }\n\n        $sharedUsers = [];\n\n        if ($metadata['shareGlobally'] === false) {\n            $sharedUserIds = $metadata['sharedUserIds'];\n\n            if ($sharedUserIds) {\n                $sharedUsers = explode(',', $sharedUserIds);\n            }\n        }\n\n        if ($metadata['shareGlobally'] === true) {\n            $users = new User\\Listing();\n            $users->setCondition('id = ?', $currentUser->getId());\n\n            foreach ($users as $user) {\n                $sharedUsers[] = $user->getId();\n            }\n        }\n\n        foreach ($sharedUsers as $id) {\n            $global    = true;\n            $favourite = GridConfigFavourite::getByOwnerAndClassAndObjectId(\n                (int) $id,\n                $gridConfig->getClassId(),\n                (int) $objectId,\n                $gridConfig->getSearchType()\n            );\n\n            // If the user has already a favourite for that object we check the current favourite and decide if we update\n            if ($favourite instanceof GridConfigFavourite) {\n                $favouriteGridConfig = GridConfig::getById($favourite->getGridConfigId());\n\n                if ($favouriteGridConfig instanceof GridConfig) {\n                    // Check if the grid config was shared globally if that is *not* the case we also not update\n                    if ((bool) $favouriteGridConfig->isShareGlobally() === false) {\n                        continue;\n                    }\n\n                    // Check if the user is the owner. If that is the case we do not update the favourite\n                    if ((int) $favouriteGridConfig->getOwnerId() === (int) $id) {\n                        continue;\n                    }\n                }\n            }\n\n            // Check if the user has already a global favourite then we do not save the favourite as global\n            $favourite = GridConfigFavourite::getByOwnerAndClassAndObjectId(\n                (int) $id,\n                $gridConfig->getClassId(),\n                0,\n                $gridConfig->getSearchType()\n            );\n\n            if ($favourite instanceof GridConfigFavourite) {\n                $favouriteGridConfig = GridConfig::getById($favourite->getGridConfigId());\n\n                if ($favouriteGridConfig instanceof GridConfig) {\n                    // Check if the grid config was shared globally if that is *not* the case we also not update\n                    if ($favouriteGridConfig->isShareGlobally() === false) {\n                        $global = false;\n                    }\n\n                    // Check if the user is the owner. If that is the case we do not update the global favourite\n                    if ($favouriteGridConfig->getOwnerId() === (int) $id) {\n                        $global = false;\n                    }\n                }\n            }\n\n            $favourite = new GridConfigFavourite();\n            $favourite->setGridConfigId($gridConfig->getId());\n            $favourite->setClassId($gridConfig->getClassId());\n            $favourite->setObjectId($objectId);\n            $favourite->setOwnerId($id);\n            $favourite->setType($gridConfig->getType());\n            $favourite->setSearchType($gridConfig->getSearchType());\n            $favourite->save();\n\n            if ($global === true) {\n                $favourite->setObjectId(0);\n                $favourite->save();\n            }\n        }\n    }\n\n    /**\n     * @param DataObject\\ClassDefinition\\Data $field\n     * @param string $gridType\n     * @param string $position\n     * @param bool $force\n     * @param string|null $keyPrefix\n     * @param DataObject\\ClassDefinition|null $class\n     * @param int|null $objectId\n     *\n     * @return array|null\n     */\n    protected function getFieldGridConfig($field, $gridType, $position, $force = false, $keyPrefix = null, $class = null, $objectId = null)\n    {\n        $key = $keyPrefix . $field->getName();\n        $config = null;\n        $title = $field->getName();\n        if (method_exists($field, 'getTitle')) {\n            if ($field->getTitle()) {\n                $title = $field->getTitle();\n            }\n        }\n\n        if ($field instanceof DataObject\\ClassDefinition\\Data\\Slider) {\n            $config['minValue'] = $field->getMinValue();\n            $config['maxValue'] = $field->getMaxValue();\n            $config['increment'] = $field->getIncrement();\n        }\n\n        if (method_exists($field, 'getWidth')) {\n            $config['width'] = $field->getWidth();\n        }\n        if (method_exists($field, 'getHeight')) {\n            $config['height'] = $field->getHeight();\n        }\n\n        $visible = false;\n        if ($gridType == 'search') {\n            $visible = $field->getVisibleSearch();\n        } elseif ($gridType == 'grid') {\n            $visible = $field->getVisibleGridView();\n        } elseif ($gridType == 'all') {\n            $visible = true;\n        }\n\n        if (!$field->getInvisible() && ($force || $visible)) {\n            $context = ['purpose' => 'gridconfig'];\n            if ($class) {\n                $context['class'] = $class;\n            }\n\n            if ($objectId) {\n                $object = DataObject::getById($objectId);\n                $context['object'] = $object;\n            }\n            DataObject\\Service::enrichLayoutDefinition($field, null, $context);\n\n            $result = [\n                'key' => $key,\n                'type' => $field->getFieldType(),\n                'label' => $title,\n                'config' => $config,\n                'layout' => $field,\n                'position' => $position,\n            ];\n\n            if ($field instanceof DataObject\\ClassDefinition\\Data\\EncryptedField) {\n                $result['delegateDatatype'] = $field->getDelegateDatatype();\n            }\n\n            return $result;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * IMPORTER\n     */\n\n    /**\n     * @Route(\"/import-upload\", name=\"importupload\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function importUploadAction(Request $request)\n    {\n        $data = file_get_contents($_FILES['Filedata']['tmp_name']);\n        $data = Tool\\Text::convertToUTF8($data);\n\n        $importId = $request->get('importId');\n        $importId = str_replace('..', '', $importId);\n        $importFile = PIMCORE_SYSTEM_TEMP_DIRECTORY . '/import_' . $importId;\n        File::put($importFile, $data);\n\n        $importFileOriginal = PIMCORE_SYSTEM_TEMP_DIRECTORY . '/import_' . $importId . '_original';\n        File::put($importFileOriginal, $data);\n\n        $response = $this->adminJson([\n            'success' => true,\n        ]);\n\n        // set content-type to text/html, otherwise (when application/json is sent) chrome will complain in\n        // Ext.form.Action.Submit and mark the submission as failed\n        $response->headers->set('Content-Type', 'text/html');\n\n        return $response;\n    }\n\n    private function getDataPreview($originalFile, $dialect)\n    {\n        $count = 0;\n        $data = [];\n        if (($handle = fopen($originalFile, 'r')) !== false) {\n            while (($rowData = fgetcsv($handle, 0, $dialect->delimiter, $dialect->quotechar, $dialect->escapechar)) !== false) {\n                $tmpData = [];\n\n                foreach ($rowData as $key => $value) {\n                    $tmpData['field_' . $key] = $value;\n                }\n\n                $tmpData['rowId'] = $count + 1;\n                $data[] = $tmpData;\n\n                $count++;\n\n                /**\n                 * Reached the number or rows for the preview\n                 */\n                if ($count > 18) {\n                    break;\n                }\n            }\n            fclose($handle);\n        }\n\n        return $data;\n    }\n\n    /**\n     * @param Request $request\n     *\n     * @return string\n     */\n    protected function extractLanguage(Request $request)\n    {\n        $requestedLanguage = $request->get('language');\n        if ($requestedLanguage) {\n            if ($requestedLanguage != 'default') {\n                $request->setLocale($requestedLanguage);\n            }\n        } else {\n            $requestedLanguage = $request->getLocale();\n        }\n\n        return $requestedLanguage;\n    }\n\n    /**\n     * @param string $fileHandle\n     *\n     * @return string\n     */\n    protected function getCsvFile($fileHandle)\n    {\n        return $fileHandle . '.csv';\n    }\n\n    /**\n     * @Route(\"/get-export-jobs\", name=\"getexportjobs\", methods={\"POST\"})\n     *\n     * @param Request $request\n     * @param GridHelperService $gridHelperService\n     * @param EventDispatcherInterface $eventDispatcher\n     *\n     * @return JsonResponse\n     */\n    public function getExportJobsAction(Request $request, GridHelperService $gridHelperService, EventDispatcherInterface $eventDispatcher)\n    {\n        $requestedLanguage = $this->extractLanguage($request);\n        $allParams = array_merge($request->request->all(), $request->query->all());\n\n        $list = $gridHelperService->prepareListingForGrid($allParams, $requestedLanguage, $this->getAdminUser());\n\n        $beforeListPrepareEvent = new GenericEvent($this, [\n            'list' => $list,\n            'context' => $allParams,\n        ]);\n        $eventDispatcher->dispatch($beforeListPrepareEvent, AdminEvents::OBJECT_LIST_BEFORE_EXPORT_PREPARE);\n\n        $list = $beforeListPrepareEvent->getArgument('list');\n\n        $ids = $list->loadIdList();\n\n        $jobs = array_chunk($ids, 20);\n\n        $fileHandle = uniqid('export-');\n\n        $storage = Storage::get('temp');\n        $storage->write($this->getCsvFile($fileHandle), '');\n\n        return $this->adminJson(['success' => true, 'jobs' => $jobs, 'fileHandle' => $fileHandle]);\n    }\n\n    /**\n     * @Route(\"/do-export\", name=\"doexport\", methods={\"POST\"})\n     *\n     * @param Request $request\n     * @param LocaleServiceInterface $localeService\n     * @param EventDispatcherInterface $eventDispatcher\n     *\n     * @return JsonResponse\n     *\n     * @throws \\Exception\n     */\n    public function doExportAction(Request $request, LocaleServiceInterface $localeService, EventDispatcherInterface $eventDispatcher)\n    {\n        $fileHandle = \\Pimcore\\File::getValidFilename($request->get('fileHandle'));\n        $ids = $request->get('ids');\n        $settings = $request->get('settings');\n        $settings = json_decode($settings, true);\n        $delimiter = $settings['delimiter'] ?? ';';\n\n        $allParams = array_merge($request->request->all(), $request->query->all());\n\n        $enableInheritance = $settings['enableInheritance'] ?? null;\n        DataObject\\Concrete::setGetInheritedValues($enableInheritance);\n\n        $class = DataObject\\ClassDefinition::getById($request->get('classId'));\n\n        if (!$class) {\n            throw new \\Exception('No class definition found');\n        }\n\n        $className = $class->getName();\n        $listClass = '\\\\Pimcore\\\\Model\\\\DataObject\\\\' . ucfirst($className) . '\\\\Listing';\n\n        /** @var \\Pimcore\\Model\\DataObject\\Listing $list */\n        $list = new $listClass();\n\n        $quotedIds = [];\n        foreach ($ids as $id) {\n            $quotedIds[] = $list->quote($id);\n        }\n\n        $list->setObjectTypes(DataObject::$types);\n        $list->setCondition('o_id IN (' . implode(',', $quotedIds) . ')');\n        $list->setOrderKey(' FIELD(o_id, ' . implode(',', $quotedIds) . ')', false);\n\n        $beforeListExportEvent = new GenericEvent($this, [\n            'list' => $list,\n            'context' => $allParams,\n        ]);\n        $eventDispatcher->dispatch($beforeListExportEvent, AdminEvents::OBJECT_LIST_BEFORE_EXPORT);\n\n        $list = $beforeListExportEvent->getArgument('list');\n\n        $fields = $request->get('fields');\n\n        $addTitles = (bool) $request->get('initial');\n\n        $requestedLanguage = $this->extractLanguage($request);\n\n        $contextFromRequest = $request->get('context');\n        if ($contextFromRequest) {\n            $contextFromRequest = json_decode($contextFromRequest, true);\n        }\n\n        $context = [\n            'source' => 'pimcore-export',\n        ];\n\n        if (is_array($contextFromRequest)) {\n            $context = array_merge($context, $contextFromRequest);\n        }\n\n        $csv = DataObject\\Service::getCsvData($requestedLanguage, $localeService, $list, $fields, $addTitles, $context);\n\n        $storage = Storage::get('temp');\n        $csvFile = $this->getCsvFile($fileHandle);\n\n        $fileStream = $storage->readStream($csvFile);\n\n        $temp = tmpfile();\n        stream_copy_to_stream($fileStream, $temp, null, 0);\n\n        $firstLine = true;\n        $lineCount = count($csv);\n\n        if (!$addTitles && $lineCount > 0) {\n            fwrite($temp, \"\\r\\n\");\n        }\n\n        for ($i = 0; $i < $lineCount; $i++) {\n            $line = $csv[$i];\n            if ($addTitles && $firstLine) {\n                $firstLine = false;\n                $line = implode($delimiter, $line);\n                fwrite($temp, $line);\n            } else {\n                fwrite($temp, implode($delimiter, array_map([$this, 'encodeFunc'], $line)));\n            }\n            if ($i < $lineCount - 1) {\n                fwrite($temp, \"\\r\\n\");\n            }\n        }\n        $storage->writeStream($csvFile, $temp);\n\n        return $this->adminJson(['success' => true]);\n    }\n\n    public function encodeFunc($value)\n    {\n        $value = str_replace('\"', '\"\"', $value);\n        //force wrap value in quotes and return\n        return '\"' . $value . '\"';\n    }\n\n    /**\n     * @Route(\"/download-csv-file\", name=\"downloadcsvfile\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function downloadCsvFileAction(Request $request)\n    {\n        $storage = Storage::get('temp');\n        $fileHandle = \\Pimcore\\File::getValidFilename($request->get('fileHandle'));\n        $csvFile = $this->getCsvFile($fileHandle);\n\n        try {\n            $csvData = $storage->read($csvFile);\n            $response = new Response($csvData);\n            $response->headers->set('Content-Type', 'application/csv');\n            $disposition = HeaderUtils::makeDisposition(\n                HeaderUtils::DISPOSITION_ATTACHMENT,\n                'export.csv'\n            );\n\n            $response->headers->set('Content-Disposition', $disposition);\n            $storage->delete($csvFile);\n\n            return $response;\n        } catch (FilesystemException | UnableToReadFile $exception) {\n            // handle the error\n            throw $this->createNotFoundException('CSV file not found');\n        }\n    }\n\n    /**\n     * @Route(\"/download-xlsx-file\", name=\"downloadxlsxfile\", methods={\"GET\"})\n     *\n     * @param Request $request\n     * @param GridHelperService $gridHelperService\n     *\n     * @return BinaryFileResponse\n     */\n    public function downloadXlsxFileAction(Request $request, GridHelperService $gridHelperService)\n    {\n        $storage = Storage::get('temp');\n        $fileHandle = \\Pimcore\\File::getValidFilename($request->get('fileHandle'));\n        $csvFile = $this->getCsvFile($fileHandle);\n\n        try {\n            return $gridHelperService->createXlsxExportFile($storage, $fileHandle, $csvFile);\n        } catch (\\Exception | FilesystemException | UnableToReadFile $exception) {\n            // handle the error\n            throw $this->createNotFoundException('XLSX file not found');\n        }\n    }\n\n    /**\n     * Flattens object data to an array with key=>value where\n     * value is simply a string representation of the value (for objects, hrefs and assets the full path is used)\n     *\n     * @param DataObject\\Concrete $object\n     *\n     * @return array\n     */\n    protected function csvObjectData($object)\n    {\n        $o = [];\n        foreach ($object->getClass()->getFieldDefinitions() as $key => $value) {\n            $o[$key] = $value->getForCsvExport($object);\n        }\n\n        $o['id (system)'] = $object->getId();\n        $o['key (system)'] = $object->getKey();\n        $o['fullpath (system)'] = $object->getRealFullPath();\n        $o['published (system)'] = $object->isPublished();\n        $o['type (system)'] = $object->getType();\n\n        return $o;\n    }\n\n    /**\n     * @Route(\"/get-batch-jobs\", name=\"getbatchjobs\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getBatchJobsAction(Request $request, GridHelperService $gridHelperService)\n    {\n        if ($request->get('language')) {\n            $request->setLocale($request->get('language'));\n        }\n\n        $allParams = array_merge($request->request->all(), $request->query->all());\n        $list = $gridHelperService->prepareListingForGrid($allParams, $request->getLocale(), $this->getAdminUser());\n\n        $jobs = $list->loadIdList();\n\n        return $this->adminJson(['success' => true, 'jobs' => $jobs]);\n    }\n\n    /**\n     * @Route(\"/batch\", name=\"batch\", methods={\"PUT\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function batchAction(Request $request)\n    {\n        $success = true;\n\n        try {\n            if ($request->get('data')) {\n                $params = $this->decodeJson($request->get('data'), true);\n                $object = DataObject\\Concrete::getById($params['job']);\n\n                if ($object) {\n                    $name = $params['name'];\n\n                    if (!$object->isAllowed('save') || ($name === 'published' && !$object->isAllowed('publish'))) {\n                        throw new \\Exception(\"Permission denied. You don't have the rights to save this object.\");\n                    }\n\n                    $append = $params['append'] ?? false;\n                    $remove = $params['remove'] ?? false;\n\n                    $className = $object->getClassName();\n                    $class = DataObject\\ClassDefinition::getByName($className);\n                    $value = $params['value'];\n                    if ($params['valueType'] == 'object') {\n                        $value = $this->decodeJson($value);\n                    }\n\n                    $parts = explode('~', $name);\n\n                    if (substr($name, 0, 1) == '~') {\n                        $type = $parts[1];\n                        $field = $parts[2];\n                        $keyId = $parts[3];\n\n                        if ($type == 'classificationstore') {\n                            $requestedLanguage = $params['language'];\n                            if ($requestedLanguage) {\n                                if ($requestedLanguage != 'default') {\n                                    $request->setLocale($requestedLanguage);\n                                }\n                            } else {\n                                $requestedLanguage = $request->getLocale();\n                            }\n\n                            $groupKeyId = explode('-', $keyId);\n                            $groupId = (int) $groupKeyId[0];\n                            $keyId = (int) $groupKeyId[1];\n\n                            $getter = 'get' . ucfirst($field);\n                            if (method_exists($object, $getter)) {\n                                /** @var DataObject\\ClassDefinition\\Data\\Classificationstore $csFieldDefinition */\n                                $csFieldDefinition = $object->getClass()->getFieldDefinition($field);\n                                $csLanguage = $requestedLanguage;\n                                if (!$csFieldDefinition->isLocalized()) {\n                                    $csLanguage = 'default';\n                                }\n\n                                /** @var DataObject\\ClassDefinition\\Data\\Classificationstore $fd */\n                                $fd = $class->getFieldDefinition($field);\n                                $keyConfig = $fd->getKeyConfiguration($keyId);\n                                $dataDefinition = DataObject\\Classificationstore\\Service::getFieldDefinitionFromKeyConfig($keyConfig);\n\n                                /** @var DataObject\\Classificationstore $classificationStoreData */\n                                $classificationStoreData = $object->$getter();\n                                if ($append) {\n                                    $oldValue = $classificationStoreData->getLocalizedKeyValue($groupId, $keyId);\n                                    $value = $dataDefinition->appendData($oldValue, $value);\n                                }\n                                if ($remove) {\n                                    $oldValue = $classificationStoreData->getLocalizedKeyValue($groupId, $keyId);\n                                    $value = $dataDefinition->removeData($oldValue, $value);\n                                }\n                                $classificationStoreData->setLocalizedKeyValue(\n                                    $groupId,\n                                    $keyId,\n                                    $dataDefinition->getDataFromEditmode($value),\n                                    $csLanguage\n                                );\n                            }\n                        }\n                    } elseif (count($parts) > 1) {\n                        // check for bricks\n                        $brickType = $parts[0];\n                        $brickKey = $parts[1];\n                        $brickField = DataObject\\Service::getFieldForBrickType($object->getClass(), $brickType);\n\n                        $fieldGetter = 'get' . ucfirst($brickField);\n                        $brickGetter = 'get' . ucfirst($brickType);\n                        $valueSetter = 'set' . ucfirst($brickKey);\n\n                        $brick = $object->$fieldGetter()->$brickGetter();\n                        if (empty($brick)) {\n                            $classname = '\\\\Pimcore\\\\Model\\\\DataObject\\\\Objectbrick\\\\Data\\\\' . ucfirst($brickType);\n                            $brickSetter = 'set' . ucfirst($brickType);\n                            $brick = new $classname($object);\n                            $object->$fieldGetter()->$brickSetter($brick);\n                        }\n\n                        $brickClass = DataObject\\Objectbrick\\Definition::getByKey($brickType);\n                        $field = $brickClass->getFieldDefinition($brickKey);\n\n                        $newData = $field->getDataFromEditmode($value, $object);\n\n                        if ($append) {\n                            $valueGetter = 'get' . ucfirst($brickKey);\n                            $existingData = $brick->$valueGetter();\n                            $newData = $field->appendData($existingData, $newData);\n                        }\n                        if ($remove) {\n                            $valueGetter = 'get' . ucfirst($brickKey);\n                            $existingData = $brick->$valueGetter();\n                            $newData = $field->removeData($existingData, $newData);\n                        }\n                        $brick->$valueSetter($newData);\n                    } else {\n                        // everything else\n                        $field = $class->getFieldDefinition($name);\n                        if ($field) {\n                            $newData = $field->getDataFromEditmode($value, $object);\n\n                            if ($append) {\n                                $existingData = $object->{'get' . $name}();\n                                $newData = $field->appendData($existingData, $newData);\n                            }\n                            if ($remove) {\n                                $existingData = $object->{'get' . $name}();\n                                $newData = $field->removeData($existingData, $newData);\n                            }\n                            $object->setValue($name, $newData);\n                        } else {\n                            // check if it is a localized field\n                            if ($params['language']) {\n                                $localizedField = $class->getFieldDefinition('localizedfields');\n                                if ($localizedField instanceof DataObject\\ClassDefinition\\Data\\Localizedfields) {\n                                    $field = $localizedField->getFieldDefinition($name);\n                                    if ($field) {\n                                        $getter = 'get' . $name;\n                                        $setter = 'set' . $name;\n                                        $newData = $field->getDataFromEditmode($value, $object);\n                                        if ($append) {\n                                            $existingData = $object->$getter($params['language']);\n                                            $newData = $field->appendData($existingData, $newData);\n                                        }\n                                        if ($remove) {\n                                            $existingData = $object->$getter($request->get('language'));\n                                            $newData = $field->removeData($existingData, $newData);\n                                        }\n\n                                        $object->$setter($newData, $params['language']);\n                                    }\n                                }\n                            }\n\n                            // seems to be a system field, this is actually only possible for the \"published\" field yet\n                            if ($name == 'published') {\n                                if ($value === 'false' || empty($value)) {\n                                    $object->setPublished(false);\n                                } else {\n                                    $object->setPublished(true);\n                                }\n                            }\n                        }\n                    }\n\n                    try {\n                        // don't check for mandatory fields here\n                        $object->setOmitMandatoryCheck(!$object->isPublished());\n                        $object->setUserModification($this->getAdminUser()->getId());\n                        $object->save();\n                        $success = true;\n                    } catch (\\Exception $e) {\n                        return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n                    }\n                } else {\n                    Logger::debug('DataObjectController::batchAction => There is no object left to update.');\n\n                    return $this->adminJson(['success' => false, 'message' => 'DataObjectController::batchAction => There is no object left to update.']);\n                }\n            }\n        } catch (\\Exception $e) {\n            Logger::err((string) $e);\n\n            return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n        }\n\n        return $this->adminJson(['success' => $success]);\n    }\n\n    /**\n     * @Route(\"/get-available-visible-vields\", name=\"getavailablevisiblefields\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getAvailableVisibleFieldsAction(Request $request)\n    {\n        $class = null;\n        $fields = null;\n\n        $classList = [];\n        $classNameList = [];\n\n        if ($request->get('classes')) {\n            $classNameList = $request->get('classes');\n            $classNameList = explode(',', $classNameList);\n            foreach ($classNameList as $className) {\n                $class = DataObject\\ClassDefinition::getByName($className);\n                if ($class) {\n                    $classList[] = $class;\n                }\n            }\n        }\n\n        if (!$classList) {\n            return $this->adminJson(['availableFields' => []]);\n        }\n        $availableFields = [];\n        foreach (self::SYSTEM_COLUMNS as $field) {\n            $availableFields[] = [\n                'key' => $field,\n                'value' => $field,\n            ];\n        }\n\n        /** @var DataObject\\ClassDefinition\\Data[] $commonFields */\n        $commonFields = [];\n\n        $firstOne = true;\n        foreach ($classNameList as $className) {\n            $class = DataObject\\ClassDefinition::getByName($className);\n            if ($class) {\n                $fds = $class->getFieldDefinitions();\n\n                $additionalFieldNames = array_keys($fds);\n                $localizedFields = $class->getFieldDefinition('localizedfields');\n                if ($localizedFields instanceof DataObject\\ClassDefinition\\Data\\Localizedfields) {\n                    $lfNames = array_keys($localizedFields->getFieldDefinitions());\n                    $additionalFieldNames = array_merge($additionalFieldNames, $lfNames);\n                }\n\n                foreach ($commonFields as $commonFieldKey => $commonFieldDefinition) {\n                    if (!in_array($commonFieldKey, $additionalFieldNames)) {\n                        unset($commonFields[$commonFieldKey]);\n                    }\n                }\n\n                $this->processAvailableFieldDefinitions($fds, $firstOne, $commonFields);\n\n                $firstOne = false;\n            }\n        }\n\n        $commonFieldKeys = array_keys($commonFields);\n        foreach ($commonFieldKeys as $field) {\n            $availableFields[] = [\n                'key' => $field,\n                'value' => $field,\n            ];\n        }\n\n        return $this->adminJson(['availableFields' => $availableFields]);\n    }\n\n    /**\n     * @param DataObject\\ClassDefinition\\Data[] $fds\n     * @param bool $firstOne\n     * @param DataObject\\ClassDefinition\\Data[] $commonFields\n     */\n    protected function processAvailableFieldDefinitions($fds, &$firstOne, &$commonFields)\n    {\n        foreach ($fds as $fd) {\n            if ($fd instanceof DataObject\\ClassDefinition\\Data\\Fieldcollections || $fd instanceof DataObject\\ClassDefinition\\Data\\Objectbricks\n                || $fd instanceof DataObject\\ClassDefinition\\Data\\Block) {\n                continue;\n            }\n\n            if ($fd instanceof DataObject\\ClassDefinition\\Data\\Localizedfields) {\n                $lfDefs = $fd->getFieldDefinitions();\n                $this->processAvailableFieldDefinitions($lfDefs, $firstOne, $commonFields);\n            } elseif ($firstOne || (isset($commonFields[$fd->getName()]) && $commonFields[$fd->getName()]->getFieldtype() == $fd->getFieldtype())) {\n                $commonFields[$fd->getName()] = $fd;\n            }\n        }\n    }\n}\n", "/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n * @category   Pimcore\n * @package    Object\n *\n * @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n * @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\n\npimcore.registerNS(\"pimcore.object.gridcolumn.operator.anygetter\");\n\npimcore.object.gridcolumn.operator.anygetter = Class.create(pimcore.object.gridcolumn.Abstract, {\n        operatorGroup: \"extractor\",\n        type: \"operator\",\n        class: \"AnyGetter\",\n        iconCls: \"pimcore_icon_operator_anygetter\",\n        defaultText: \"Any Getter\",\n        group: \"getter\",\n\n\n        getConfigTreeNode: function (configAttributes) {\n            if (configAttributes) {\n                var nodeLabel = this.getNodeLabel(configAttributes);\n                var node = {\n                    draggable: true,\n                    iconCls: this.iconCls,\n                    text: nodeLabel,\n                    configAttributes: configAttributes,\n                    isTarget: true,\n                    expanded: true,\n                    leaf: false,\n                    expandable: false\n                };\n            } else {\n\n                //For building up operator list\n                var configAttributes = {type: this.type, class: this.class, label: this.getDefaultText()};\n\n                var node = {\n                    draggable: true,\n                    iconCls: this.iconCls,\n                    text: this.getDefaultText(),\n                    configAttributes: configAttributes,\n                    isTarget: true,\n                    leaf: true\n                };\n            }\n            node.isOperator = true;\n            return node;\n        },\n\n\n        getCopyNode: function (source) {\n            var copy = source.createNode({\n                iconCls: this.iconCls,\n                text: source.data.cssClass,\n                isTarget: true,\n                leaf: false,\n                expanded: true,\n                isOperator: true,\n                configAttributes: {\n                    label: source.data.configAttributes.label,\n                    type: this.type,\n                    class: this.class\n                }\n            });\n            return copy;\n        },\n\n\n        getConfigDialog: function (node, params) {\n            this.node = node;\n\n            this.textfield = new Ext.form.TextField({\n                fieldLabel: t('label'),\n                length: 255,\n                width: 200,\n                value: this.node.data.configAttributes.label,\n                listeners: {'change': pimcore.helpers.htmlEncodeTextField }\n            });\n\n            this.attributeField = new Ext.form.TextField({\n                fieldLabel: t('attribute'),\n                length: 255,\n                width: 200,\n                value: this.node.data.configAttributes.attribute,\n                listeners: {'change': pimcore.helpers.htmlEncodeTextField }\n            });\n\n            this.param1Field = new Ext.form.TextField({\n                fieldLabel: t('parameter'),\n                length: 255,\n                width: 200,\n                value: this.node.data.configAttributes.param1,\n                listeners: {'change': pimcore.helpers.htmlEncodeTextField }\n        });\n\n            this.returnLastResultField = new Ext.form.Checkbox({\n                fieldLabel: t('return_last_result'),\n                length: 255,\n                width: 200,\n                value: this.node.data.configAttributes.returnLastResult\n            });\n\n\n            this.isArrayField = new Ext.form.Checkbox({\n                fieldLabel: t('is_array'),\n                length: 255,\n                width: 200,\n                value: this.node.data.configAttributes.isArrayType\n            });\n\n            this.forwardAttributeField = new Ext.form.TextField({\n                fieldLabel: t('forward_attribute'),\n                length: 255,\n                width: 200,\n                value: this.node.data.configAttributes.forwardAttribute\n            });\n\n            this.forwardParam1Field = new Ext.form.TextField({\n                fieldLabel: t('forward_parameter'),\n                length: 255,\n                width: 200,\n                value: this.node.data.configAttributes.forwardParam1\n            });\n\n\n            this.configPanel = new Ext.Panel({\n                layout: \"form\",\n                bodyStyle: \"padding: 10px;\",\n                items: [this.textfield, this.attributeField, this.param1Field, this.isArrayField, this.returnLastResultField, this.forwardAttributeField, this.forwardParam1Field],\n                buttons: [{\n                    text: t(\"apply\"),\n                    iconCls: \"pimcore_icon_apply\",\n                    handler: function () {\n                        this.commitData(params);\n                    }.bind(this)\n                }]\n            });\n\n            this.window = new Ext.Window({\n                width: 400,\n                height: 450,\n                modal: true,\n                title: t('settings'),\n                layout: \"fit\",\n                items: [this.configPanel]\n            });\n\n            this.window.show();\n\n            return this.window;\n        },\n\n        commitData: function (params) {\n            this.node.set('isOperator', true);\n            this.node.data.configAttributes.label = this.textfield.getValue();\n            this.node.data.configAttributes.attribute = this.attributeField.getValue();\n            this.node.data.configAttributes.param1 = this.param1Field.getValue();\n            this.node.data.configAttributes.isArrayType = this.isArrayField.getValue();\n            this.node.data.configAttributes.forwardAttribute = this.forwardAttributeField.getValue();\n            this.node.data.configAttributes.forwardParam1 = this.forwardParam1Field.getValue();\n            this.node.data.configAttributes.returnLastResult = this.returnLastResultField.getValue();\n\n            var nodeLabel = this.getNodeLabel(this.node.data.configAttributes);\n            this.node.set('text', nodeLabel);\n            this.window.close();\n\n            if (params && params.callback) {\n                params.callback();\n            }\n        },\n\n        getNodeLabel: function (configAttributes) {\n            var nodeLabel = configAttributes.label ? configAttributes.label : this.getDefaultText();\n            if (configAttributes.attribute) {\n                var attr = configAttributes.attribute;\n                if (configAttributes.param1) {\n                    attr += \" \" + configAttributes.param1;\n                }\n                nodeLabel += '<span class=\"pimcore_gridnode_hint\"> (' + Ext.util.Format.htmlEncode(attr) + ')</span>';\n            }\n\n            return nodeLabel;\n        }\n    }\n);", "/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n * @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n * @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\npimcore.registerNS(\"pimcore.settings.metadata.predefined\");\npimcore.settings.metadata.predefined = Class.create({\n\n    initialize: function () {\n        this.getTabPanel();\n    },\n\n    activate: function () {\n        var tabPanel = Ext.getCmp(\"pimcore_panel_tabs\");\n        tabPanel.setActiveItem(\"predefined_metadata\");\n    },\n\n    getTabPanel: function () {\n\n        if (!this.panel) {\n            this.panel = new Ext.Panel({\n                id: \"predefined_metadata\",\n                title: t(\"predefined_metadata_definitions\"),\n                iconCls: \"pimcore_icon_metadata\",\n                border: false,\n                layout: \"fit\",\n                closable:true,\n                items: [this.getRowEditor()]\n            });\n\n            var tabPanel = Ext.getCmp(\"pimcore_panel_tabs\");\n            tabPanel.add(this.panel);\n            tabPanel.setActiveItem(\"predefined_metadata\");\n\n\n            this.panel.on(\"destroy\", function () {\n                pimcore.globalmanager.remove(\"predefined_metadata\");\n            }.bind(this));\n\n            pimcore.layout.refresh();\n        }\n\n        return this.panel;\n    },\n\n    getRowEditor: function () {\n        var url = Routing.generate('pimcore_admin_settings_metadata');\n\n        this.store = pimcore.helpers.grid.buildDefaultStore(\n            url,\n            [\n                'id',\n                {\n                    name: 'name',\n                    allowBlank: false,\n                    convert: function (v, r) {\n                        return v.replace(/[~]/g, \"---\");\n                    }\n                },\n                'description','type',\n                {name: 'data',\n                    convert: function (v, r) {\n                        let dataType = r.data.type;\n                        if (typeof pimcore.asset.metadata.tags[dataType].prototype.convertPredefinedGridData === \"function\") {\n                            v = pimcore.asset.metadata.tags[dataType].prototype.convertPredefinedGridData(v, r);\n                        }\n                        return v;\n                    }\n                },'config', 'targetSubtype', 'language', 'creationDate' ,'modificationDate'\n            ], null, {\n                remoteSort: false,\n                remoteFilter: false\n            }\n        );\n\n        this.store.getProxy().getReader().setMessageProperty('message');\n        this.store.getProxy().on('exception', function (proxy, response, operation) {\n            pimcore.helpers.showNotification(t(\"error\"), t(operation.getError()), \"error\");\n            this.store.load();\n        }.bind(this));\n\n        this.store.addListener('exception', function(proxy, mode, action, options, response) {\n            Ext.Msg.show({\n                title: t(\"error\"),\n                msg: t(response.raw.message),\n                buttons: Ext.Msg.OK,\n                animEl: 'elId',\n                icon: Ext.MessageBox.ERROR\n            });\n        });\n\n        this.filterField = new Ext.form.TextField({\n            xtype: \"textfield\",\n            width: 200,\n            style: \"margin: 0 10px 0 0;\",\n            enableKeyEvents: true,\n            listeners: {\n                \"keydown\" : function (field, key) {\n                    if (key.getKey() == key.ENTER) {\n                        var input = field;\n                        var proxy = this.store.getProxy();\n                        proxy.extraParams.filter = input.getValue();\n                        this.store.load();\n                    }\n                }.bind(this)\n            }\n        });\n\n\n        var languagestore = [[\"\",t(\"none\")]];\n        for (let i=0; i<pimcore.settings.websiteLanguages.length; i++) {\n            languagestore.push([pimcore.settings.websiteLanguages[i],pimcore.settings.websiteLanguages[i]]);\n        }\n\n        var supportedTypes = pimcore.helpers.getAssetMetadataDataTypes(\"predefined\");\n        var typeStore = [];\n\n        for (let i = 0; i < supportedTypes.length; i++) {\n            let type = supportedTypes[i];\n            typeStore.push([type, t(type)]);\n        }\n\n        var metadataColumns = [\n            {\n                text: t(\"type\"),\n                dataIndex: 'type',\n                editable: false,\n                width: 40,\n                renderer: this.getTypeRenderer.bind(this),\n                sortable: true\n            },\n            {text: t(\"name\"), width: 200, sortable: true, dataIndex: 'name',\n                getEditor: function() { return new Ext.form.TextField({ listeners: {'change': pimcore.helpers.htmlEncodeTextField } }); }\n            },\n            {text: t(\"group\"), width: 200, sortable: true, dataIndex: 'group',\n                getEditor: function() { return new Ext.form.TextField({}); }\n            },\n            {text: t(\"description\"), sortable: true, dataIndex: 'description',\n                getEditor: function() { return new Ext.form.TextArea({}); },\n                renderer: function (value, metaData, record, rowIndex, colIndex, store) {\n                    if (empty(value)) {\n                        return \"\";\n                    }\n                    return nl2br(Ext.util.Format.htmlEncode(value));\n                }\n            },\n            {text: t(\"type\"), width: 90, sortable: true,\n                dataIndex: 'type',\n                getEditor: function() {\n                    return new Ext.form.ComboBox({\n                        editable: false,\n                        store: typeStore\n\n                    })\n                }\n            },\n            {text: t(\"value\"),\n                flex: 510,\n                sortable: true,\n                dataIndex: 'data',\n                editable: true,\n                getEditor: this.getCellEditor.bind(this),\n                renderer: this.getCellRenderer.bind(this)\n            },\n            {text: t(\"configuration\"),\n                width: 100,\n                sortable: false,\n                dataIndex: 'config',\n                getEditor: function() { return new Ext.form.TextField({}); }\n            },\n            {\n                text: t('language'),\n                sortable: true,\n                dataIndex: \"language\",\n                getEditor: function() {\n                    return new Ext.form.ComboBox({\n                        name: \"language\",\n                        store: languagestore,\n                        editable: false,\n                        triggerAction: 'all',\n                        mode: \"local\"\n                    });\n                },\n                width: 70\n            },\n            {\n                text: t(\"target_subtype\"), width: 80, sortable: true, dataIndex: 'targetSubtype',\n                getEditor: function() {\n                    return new Ext.form.ComboBox({\n                        editable: true,\n                        store: [\"image\", \"text\", \"audio\", \"video\", \"document\", \"archive\", \"unknown\"]\n                    });\n                }\n            },\n            {\n                xtype: 'actioncolumn',\n                menuText: t('delete'),\n                width: 40,\n                items: [{\n                    getClass: function(v, meta, rec) {\n                        var klass = \"pimcore_action_column \";\n                        if(rec.data.writeable) {\n                            klass += \"pimcore_icon_minus\";\n                        }\n                        return klass;\n                    },\n                    tooltip: t('delete'),\n                    handler: function (grid, rowIndex) {\n                        let data = grid.getStore().getAt(rowIndex);\n                        pimcore.helpers.deleteConfirm(t('predefined_metadata'),\n                            Ext.util.Format.htmlEncode(data.data.name),\n                            function () {\n                            grid.getStore().removeAt(rowIndex);\n                        }.bind(this));\n                    }.bind(this)\n                }]\n            },\n            {text: t(\"creationDate\"), sortable: true, dataIndex: 'creationDate', editable: false,\n                hidden: true,\n                renderer: function(d) {\n                    if (d !== undefined) {\n                        var date = new Date(d * 1000);\n                        return date.format(\"Y-m-d H:i:s\");\n                    }\n                    return \"\";\n                }\n            },\n            {text: t(\"modificationDate\"), sortable: true, dataIndex: 'modificationDate', editable: false,\n                hidden: true,\n                renderer: function(d) {\n                    if (d !== undefined) {\n                        var date = new Date(d * 1000);\n                        return date.format(\"Y-m-d H:i:s\");\n                    }\n                    return \"\";\n                }\n            }\n        ];\n\n        this.cellEditing = Ext.create('Ext.grid.plugin.CellEditing', {\n            clicksToEdit: 1,\n            listeners: {\n                beforeedit: function(editor, context, eOpts) {\n                    //need to clear cached editors of cell-editing editor in order to\n                    //enable different editors per row\n                    editor.editors.each(function (e) {\n                        try {\n                            // complete edit, so the value is stored when hopping around with TAB\n                            e.completeEdit();\n                            Ext.destroy(e);\n                        } catch (exception) {\n                            // garbage collector was faster\n                            // already destroyed\n                        }\n                    });\n\n                    editor.editors.clear();\n                },\n                validateedit: function (editor, context, eOpts) {\n                    if (!context.record.data.writeable) {\n                        editor.cancelEdit();\n                        pimcore.helpers.showNotification(t(\"info\"), t(\"config_not_writeable\"), \"info\");\n                        return false;\n                    }\n                }\n            }\n        });\n\n        this.grid = Ext.create('Ext.grid.Panel', {\n            frame: false,\n            autoScroll: true,\n            store: this.store,\n            columnLines: true,\n            stripeRows: true,\n            bodyCls: \"pimcore_editable_grid\",\n            trackMouseOver: true,\n            columns: {\n                items: metadataColumns,\n                defaults: {\n                    renderer: Ext.util.Format.htmlEncode\n                },\n            },\n            clicksToEdit: 1,\n            selModel: Ext.create('Ext.selection.CellModel', {}),\n            bbar: this.pagingtoolbar,\n            autoExpandColumn: \"value_col\",\n            plugins: [\n                this.cellEditing\n            ],\n\n            viewConfig: {\n                listeners: {\n                    rowupdated: this.updateRows.bind(this, \"rowupdated\"),\n                    refresh: this.updateRows.bind(this, \"refresh\")\n                },\n                forceFit: true,\n                getRowClass: function (record, rowIndex) {\n                    return record.data.writeable ? '' : 'pimcore_grid_row_disabled';\n                }\n            },\n            tbar: {\n                cls: 'pimcore_main_toolbar',\n                items: [\n                    {\n                        text: t('add'),\n                        handler: this.onAdd.bind(this),\n                        iconCls: \"pimcore_icon_add\",\n                        disabled: !pimcore.settings['predefined-asset-metadata-writeable']\n                    },\"->\",{\n                        text: t(\"filter\") + \"/\" + t(\"search\"),\n                        xtype: \"tbtext\",\n                        style: \"margin: 0 10px 0 0;\"\n                    },\n                    this.filterField\n                ]\n            }\n        });\n\n        this.grid.on(\"viewready\", this.updateRows.bind(this));\n        this.store.on(\"update\", this.updateRows.bind(this));\n\n        return this.grid;\n    },\n\n    getTypeRenderer: function (value, metaData, record, rowIndex, colIndex, store) {\n\n        if (value == \"input\") {\n            value = \"text\";\n        }\n        return '<div class=\"pimcore_icon_' + value + '\" recordid=' + record.id + '>&nbsp;</div>';\n    },\n\n    getCellRenderer: function (value, metaData, record, rowIndex, colIndex, store) {\n        var data = store.getAt(rowIndex).data;\n        var type = data.type;\n        return pimcore.asset.metadata.tags[type].prototype.getGridCellRenderer(value, metaData, record, rowIndex, colIndex, store);\n    },\n\n    onAdd: function (btn, ev) {\n        var model = this.grid.store.getModel();\n        var newEntry = new model({\n            name: t('new_definition'),\n            key: \"new_key\",\n            subtype: \"image\",\n            type: \"input\"\n        });\n\n        this.grid.store.insert(0, newEntry);\n    },\n\n    updateRows: function (event) {\n        var rows = Ext.get(this.grid.getEl().dom).query(\".x-grid-row\");\n\n        for (let i = 0; i < rows.length; i++) {\n\n            try {\n                var list = Ext.get(rows[i]).query(\".x-grid-cell-first div div\");\n                var firstItem = list[0];\n                if (!firstItem) {\n                    continue;\n                }\n                var recordId = firstItem.getAttribute(\"recordid\");\n                var data = this.grid.getStore().getById(recordId);\n                if (!data) {\n                    continue;\n                }\n\n                data = data.data;\n\n                if(in_array(data.name, this.disallowedKeys)) {\n                    Ext.get(rows[i]).addCls(\"pimcore_properties_hidden_row\");\n                }\n\n                pimcore.asset.metadata.tags[data.type].prototype.updatePredefinedGridRow(this.grid, rows[i], data);\n            }\n            catch (e) {\n                console.log(e);\n            }\n        }\n    },\n\n    getCellEditor: function (record) {\n        var data = record.data;\n        var type = data.type;\n        var editor = pimcore.asset.metadata.tags[type].prototype.getGridCellEditor(\"predefined\", record);\n        return editor;\n    }\n});\n", "<?php\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\DataObject\\GridColumnConfig\\Operator;\n\nuse Pimcore\\DataObject\\GridColumnConfig\\ConfigElementInterface;\nuse Pimcore\\Security\\SecurityHelper;\nuse Pimcore\\Tool;\n\nabstract class AbstractOperator implements OperatorInterface\n{\n    /**\n     * @var string\n     */\n    protected $label;\n\n    /**\n     * @var array\n     */\n    protected array $context = [];\n\n    /**\n     * @var ConfigElementInterface[]\n     */\n    protected $childs;\n\n    /**\n     * @param \\stdClass $config\n     * @param array $context\n     */\n    public function __construct(\\stdClass $config, array $context = [])\n    {\n        $this->label = SecurityHelper::convertHtmlSpecialChars($config->label);\n        $this->childs = $config->childs;\n        $this->context = $context;\n    }\n\n    /**\n     * @return ConfigElementInterface[]\n     */\n    public function getChilds()\n    {\n        return $this->childs;\n    }\n\n    /**\n     * @return bool\n     */\n    public function expandLocales()\n    {\n        return false;\n    }\n\n    /**\n     * @return array\n     */\n    public function getContext()\n    {\n        return $this->context;\n    }\n\n    /**\n     * @param array $context\n     */\n    public function setContext($context)\n    {\n        $this->context = $context;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function getLabel()\n    {\n        return $this->label;\n    }\n\n    /**\n     * @param string $label\n     */\n    public function setLabel($label)\n    {\n        $this->label = SecurityHelper::convertHtmlSpecialChars($label);\n    }\n\n    /**\n     * @return string[]\n     */\n    public function getValidLanguages()\n    {\n        return Tool::getValidLanguages();\n    }\n}\n", "<?php\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\DataObject\\GridColumnConfig\\Operator;\n\nuse Pimcore\\Model\\AbstractModel;\nuse Pimcore\\Security\\SecurityHelper;\nuse Pimcore\\Tool\\Admin;\n\n/**\n * @internal\n */\nfinal class AnyGetter extends AbstractOperator\n{\n    /**\n     * @var string\n     */\n    private $attribute;\n\n    /**\n     * @var string\n     */\n    private $param1;\n\n    /**\n     * @var bool\n     */\n    private $isArrayType;\n\n    /**\n     * @var string\n     */\n    private $forwardAttribute;\n\n    /**\n     * @var string\n     */\n    private $forwardParam1;\n\n    /**\n     * @var bool\n     */\n    private $returnLastResult;\n\n    /**\n     * {@inheritdoc}\n     */\n    public function __construct(\\stdClass $config, $context = null)\n    {\n        if (!Admin::getCurrentUser()->isAdmin()) {\n            throw new \\Exception('AnyGetter only allowed for admin users');\n        }\n\n        parent::__construct($config, $context);\n\n        $this->attribute = SecurityHelper::convertHtmlSpecialChars($config->attribute ?? '');\n        $this->param1 = SecurityHelper::convertHtmlSpecialChars($config->param1 ?? '');\n        $this->isArrayType = $config->isArrayType ?? false;\n\n        $this->forwardAttribute = $config->forwardAttribute ?? '';\n        $this->forwardParam1 = $config->forwardParam1 ?? '';\n\n        $this->returnLastResult = $config->returnLastResult ?? false;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function getLabeledValue($element)\n    {\n        $result = new \\stdClass();\n        $result->label = $this->label;\n\n        $childs = $this->getChilds();\n\n        $getter = 'get'.ucfirst($this->attribute);\n        $fallbackGetter = $this->attribute;\n\n        if (!$childs) {\n            $result->value = null;\n            if ($this->attribute && method_exists($element, $getter)) {\n                $result->value = $element->$getter($this->getParam1());\n            } elseif ($this->attribute && method_exists($element, $fallbackGetter)) {\n                $result->value = $element->$fallbackGetter($this->getParam1());\n            }\n\n            if ($result->value instanceof AbstractModel) {\n                $result->value = $result->value->getObjectVars();\n            }\n        } else {\n            if (count($childs) > 1) {\n                $result->isArrayType = true;\n            }\n            $resultElements = [];\n\n            if (!is_array($childs)) {\n                $childs = [$childs];\n            }\n\n            foreach ($childs as $c) {\n                $forwardObject = $element;\n\n                if ($this->forwardAttribute) {\n                    $forwardGetter = 'get'.ucfirst($this->forwardAttribute);\n                    $forwardParam = $this->getForwardParam1();\n                    if (method_exists($element, $forwardGetter)) {\n                        $forwardObject = $element->$forwardGetter($forwardParam);\n                        if (!$forwardObject) {\n                            return $result;\n                        }\n                    } else {\n                        return $result;\n                    }\n                }\n\n                $valueContainer = $c->getLabeledValue($forwardObject);\n\n                $value = $valueContainer->value;\n                if ($value || $this->getReturnLastResult()) {\n                    $resultElementValue = $value;\n                } else {\n                    $resultElementValue = null;\n                }\n\n                if ($this->getisArrayType()) {\n                    if (is_array($value)) {\n                        $subValues = [];\n                        foreach ($value as $o) {\n                            if ($o) {\n                                if ($this->attribute && method_exists($o, $getter)) {\n                                    $subValues[] = $o->$getter($this->getParam1());\n                                } elseif ($this->attribute && method_exists($o, $fallbackGetter)) {\n                                    $subValues[] = $o->$fallbackGetter($this->getParam1());\n                                }\n                            }\n                        }\n                        $resultElementValue = $subValues;\n                    }\n                } else {\n                    $o = $value;\n                    if ($o) {\n                        if ($this->attribute && method_exists($o, $getter)) {\n                            $resultElementValue = $o->$getter($this->getParam1());\n                        } elseif ($this->attribute && method_exists($o, $fallbackGetter)) {\n                            $resultElementValue = $o->$fallbackGetter($this->getParam1());\n                        }\n                    }\n                }\n                $resultElements[] = $resultElementValue;\n            }\n            if (count($childs) == 1) {\n                $result->value = $resultElements[0];\n            } else {\n                $result->value = $resultElements;\n            }\n        }\n\n        return $result;\n    }\n\n    /**\n     * @return string\n     */\n    public function getAttribute()\n    {\n        return $this->attribute;\n    }\n\n    /**\n     * @param string $attribute\n     */\n    public function setAttribute($attribute)\n    {\n        $this->attribute = SecurityHelper::convertHtmlSpecialChars($attribute);\n    }\n\n    /**\n     * @return string\n     */\n    public function getParam1()\n    {\n        return $this->param1;\n    }\n\n    /**\n     * @param string $param1\n     */\n    public function setParam1($param1)\n    {\n        $this->param1 = SecurityHelper::convertHtmlSpecialChars($param1);\n    }\n\n    /**\n     * @return string\n     */\n    public function getForwardAttribute()\n    {\n        return $this->forwardAttribute;\n    }\n\n    /**\n     * @param string $forwardAttribute\n     */\n    public function setForwardAttribute($forwardAttribute)\n    {\n        $this->forwardAttribute = $forwardAttribute;\n    }\n\n    /**\n     * @return string\n     */\n    public function getForwardParam1()\n    {\n        return $this->forwardParam1;\n    }\n\n    /**\n     * @param string $forwardParam1\n     */\n    public function setForwardParam1($forwardParam1)\n    {\n        $this->forwardParam1 = $forwardParam1;\n    }\n\n    /**\n     * @return bool\n     */\n    public function getIsArrayType()\n    {\n        return $this->isArrayType;\n    }\n\n    /**\n     * @param bool $isArrayType\n     */\n    public function setIsArrayType($isArrayType)\n    {\n        $this->isArrayType = $isArrayType;\n    }\n\n    /**\n     * @return bool\n     */\n    public function getReturnLastResult()\n    {\n        return $this->returnLastResult;\n    }\n\n    /**\n     * @param bool $returnLastResult\n     */\n    public function setReturnLastResult($returnLastResult)\n    {\n        $this->returnLastResult = $returnLastResult;\n    }\n}\n", "<?php\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\Security;\n\nclass SecurityHelper\n{\n    public static function convertHtmlSpecialChars(?string $text): ?string\n    {\n        if(is_string($text)) {\n            return htmlspecialchars($text, ENT_QUOTES | ENT_SUBSTITUTE, 'UTF-8', false);\n        }\n\n        return null;\n    }\n\n    public static function convertHtmlSpecialCharsArrayKeys(array &$array, array $keys): void\n    {\n        foreach ($keys as $key) {\n            if (array_key_exists($key, $array)) {\n                $array[$key] = self::convertHtmlSpecialChars($array[$key]);\n            }\n        }\n    }\n}\n"], "filenames": ["bundles/AdminBundle/Controller/Admin/Asset/AssetHelperController.php", "bundles/AdminBundle/Controller/Admin/DataObject/DataObjectHelperController.php", "bundles/AdminBundle/Resources/public/js/pimcore/object/gridcolumn/operator/AnyGetter.js", "bundles/AdminBundle/Resources/public/js/pimcore/settings/metadata/predefined.js", "lib/DataObject/GridColumnConfig/Operator/AbstractOperator.php", "lib/DataObject/GridColumnConfig/Operator/AnyGetter.php", "lib/Security/SecurityHelper.php"], "buggy_code_start_loc": [35, 34, 86, 141, 18, 18, 27], "buggy_code_end_loc": [969, 357, 187, 142, 95, 202, 27], "fixing_code_start_loc": [36, 35, 86, 141, 19, 19, 28], "fixing_code_end_loc": [971, 366, 190, 142, 96, 203, 37], "type": "CWE-79", "message": "Cross-site Scripting (XSS) - Reflected in GitHub repository pimcore/pimcore prior to 10.5.21.", "other": {"cve": {"id": "CVE-2023-2339", "sourceIdentifier": "security@huntr.dev", "published": "2023-04-27T12:15:09.300", "lastModified": "2023-05-04T20:07:25.237", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site Scripting (XSS) - Reflected in GitHub repository pimcore/pimcore prior to 10.5.21."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pimcore:pimcore:*:*:*:*:*:*:*:*", "versionEndExcluding": "10.5.21", "matchCriteriaId": "72C537D6-67BA-4562-B853-F99E6C14315C"}]}]}], "references": [{"url": "https://github.com/pimcore/pimcore/commit/6946f8a5a0a93b516c49f17a5b45044eebd73480", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/bb1537a5-fe7b-4c77-a582-10a82435fbc2", "source": "security@huntr.dev", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/pimcore/pimcore/commit/6946f8a5a0a93b516c49f17a5b45044eebd73480"}}