{"buggy_code": ["// Package proxyproto implements Proxy Protocol (v1 and v2) parser and writer, as per specification:\n// https://www.haproxy.org/download/2.3/doc/proxy-protocol.txt\npackage proxyproto\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"net\"\n\t\"time\"\n)\n\nvar (\n\t// Protocol\n\tSIGV1 = []byte{'\\x50', '\\x52', '\\x4F', '\\x58', '\\x59'}\n\tSIGV2 = []byte{'\\x0D', '\\x0A', '\\x0D', '\\x0A', '\\x00', '\\x0D', '\\x0A', '\\x51', '\\x55', '\\x49', '\\x54', '\\x0A'}\n\n\tErrLineMustEndWithCrlf                  = errors.New(\"proxyproto: header is invalid, must end with \\\\r\\\\n\")\n\tErrCantReadProtocolVersionAndCommand    = errors.New(\"proxyproto: can't read proxy protocol version and command\")\n\tErrCantReadAddressFamilyAndProtocol     = errors.New(\"proxyproto: can't read address family or protocol\")\n\tErrCantReadLength                       = errors.New(\"proxyproto: can't read length\")\n\tErrCantResolveSourceUnixAddress         = errors.New(\"proxyproto: can't resolve source Unix address\")\n\tErrCantResolveDestinationUnixAddress    = errors.New(\"proxyproto: can't resolve destination Unix address\")\n\tErrNoProxyProtocol                      = errors.New(\"proxyproto: proxy protocol signature not present\")\n\tErrUnknownProxyProtocolVersion          = errors.New(\"proxyproto: unknown proxy protocol version\")\n\tErrUnsupportedProtocolVersionAndCommand = errors.New(\"proxyproto: unsupported proxy protocol version and command\")\n\tErrUnsupportedAddressFamilyAndProtocol  = errors.New(\"proxyproto: unsupported address family and protocol\")\n\tErrInvalidLength                        = errors.New(\"proxyproto: invalid length\")\n\tErrInvalidAddress                       = errors.New(\"proxyproto: invalid address\")\n\tErrInvalidPortNumber                    = errors.New(\"proxyproto: invalid port number\")\n\tErrSuperfluousProxyHeader               = errors.New(\"proxyproto: upstream connection sent PROXY header but isn't allowed to send one\")\n)\n\n// Header is the placeholder for proxy protocol header.\ntype Header struct {\n\tVersion           byte\n\tCommand           ProtocolVersionAndCommand\n\tTransportProtocol AddressFamilyAndProtocol\n\tSourceAddr        net.Addr\n\tDestinationAddr   net.Addr\n\trawTLVs           []byte\n}\n\n// HeaderProxyFromAddrs creates a new PROXY header from a source and a\n// destination address. If version is zero, the latest protocol version is\n// used.\n//\n// The header is filled on a best-effort basis: if hints cannot be inferred\n// from the provided addresses, the header will be left unspecified.\nfunc HeaderProxyFromAddrs(version byte, sourceAddr, destAddr net.Addr) *Header {\n\tif version < 1 || version > 2 {\n\t\tversion = 2\n\t}\n\th := &Header{\n\t\tVersion:           version,\n\t\tCommand:           LOCAL,\n\t\tTransportProtocol: UNSPEC,\n\t}\n\tswitch sourceAddr := sourceAddr.(type) {\n\tcase *net.TCPAddr:\n\t\tif _, ok := destAddr.(*net.TCPAddr); !ok {\n\t\t\tbreak\n\t\t}\n\t\tif len(sourceAddr.IP.To4()) == net.IPv4len {\n\t\t\th.TransportProtocol = TCPv4\n\t\t} else if len(sourceAddr.IP) == net.IPv6len {\n\t\t\th.TransportProtocol = TCPv6\n\t\t}\n\tcase *net.UDPAddr:\n\t\tif _, ok := destAddr.(*net.UDPAddr); !ok {\n\t\t\tbreak\n\t\t}\n\t\tif len(sourceAddr.IP.To4()) == net.IPv4len {\n\t\t\th.TransportProtocol = UDPv4\n\t\t} else if len(sourceAddr.IP) == net.IPv6len {\n\t\t\th.TransportProtocol = UDPv6\n\t\t}\n\tcase *net.UnixAddr:\n\t\tif _, ok := destAddr.(*net.UnixAddr); !ok {\n\t\t\tbreak\n\t\t}\n\t\tswitch sourceAddr.Net {\n\t\tcase \"unix\":\n\t\t\th.TransportProtocol = UnixStream\n\t\tcase \"unixgram\":\n\t\t\th.TransportProtocol = UnixDatagram\n\t\t}\n\t}\n\tif h.TransportProtocol != UNSPEC {\n\t\th.Command = PROXY\n\t\th.SourceAddr = sourceAddr\n\t\th.DestinationAddr = destAddr\n\t}\n\treturn h\n}\n\nfunc (header *Header) TCPAddrs() (sourceAddr, destAddr *net.TCPAddr, ok bool) {\n\tif !header.TransportProtocol.IsStream() {\n\t\treturn nil, nil, false\n\t}\n\tsourceAddr, sourceOK := header.SourceAddr.(*net.TCPAddr)\n\tdestAddr, destOK := header.DestinationAddr.(*net.TCPAddr)\n\treturn sourceAddr, destAddr, sourceOK && destOK\n}\n\nfunc (header *Header) UDPAddrs() (sourceAddr, destAddr *net.UDPAddr, ok bool) {\n\tif !header.TransportProtocol.IsDatagram() {\n\t\treturn nil, nil, false\n\t}\n\tsourceAddr, sourceOK := header.SourceAddr.(*net.UDPAddr)\n\tdestAddr, destOK := header.DestinationAddr.(*net.UDPAddr)\n\treturn sourceAddr, destAddr, sourceOK && destOK\n}\n\nfunc (header *Header) UnixAddrs() (sourceAddr, destAddr *net.UnixAddr, ok bool) {\n\tif !header.TransportProtocol.IsUnix() {\n\t\treturn nil, nil, false\n\t}\n\tsourceAddr, sourceOK := header.SourceAddr.(*net.UnixAddr)\n\tdestAddr, destOK := header.DestinationAddr.(*net.UnixAddr)\n\treturn sourceAddr, destAddr, sourceOK && destOK\n}\n\nfunc (header *Header) IPs() (sourceIP, destIP net.IP, ok bool) {\n\tif sourceAddr, destAddr, ok := header.TCPAddrs(); ok {\n\t\treturn sourceAddr.IP, destAddr.IP, true\n\t} else if sourceAddr, destAddr, ok := header.UDPAddrs(); ok {\n\t\treturn sourceAddr.IP, destAddr.IP, true\n\t} else {\n\t\treturn nil, nil, false\n\t}\n}\n\nfunc (header *Header) Ports() (sourcePort, destPort int, ok bool) {\n\tif sourceAddr, destAddr, ok := header.TCPAddrs(); ok {\n\t\treturn sourceAddr.Port, destAddr.Port, true\n\t} else if sourceAddr, destAddr, ok := header.UDPAddrs(); ok {\n\t\treturn sourceAddr.Port, destAddr.Port, true\n\t} else {\n\t\treturn 0, 0, false\n\t}\n}\n\n// EqualTo returns true if headers are equivalent, false otherwise.\n// Deprecated: use EqualsTo instead. This method will eventually be removed.\nfunc (header *Header) EqualTo(otherHeader *Header) bool {\n\treturn header.EqualsTo(otherHeader)\n}\n\n// EqualsTo returns true if headers are equivalent, false otherwise.\nfunc (header *Header) EqualsTo(otherHeader *Header) bool {\n\tif otherHeader == nil {\n\t\treturn false\n\t}\n\t// TLVs only exist for version 2\n\tif header.Version == 2 && !bytes.Equal(header.rawTLVs, otherHeader.rawTLVs) {\n\t\treturn false\n\t}\n\tif header.Version != otherHeader.Version || header.Command != otherHeader.Command || header.TransportProtocol != otherHeader.TransportProtocol {\n\t\treturn false\n\t}\n\t// Return early for header with LOCAL command, which contains no address information\n\tif header.Command == LOCAL {\n\t\treturn true\n\t}\n\treturn header.SourceAddr.String() == otherHeader.SourceAddr.String() &&\n\t\theader.DestinationAddr.String() == otherHeader.DestinationAddr.String()\n}\n\n// WriteTo renders a proxy protocol header in a format and writes it to an io.Writer.\nfunc (header *Header) WriteTo(w io.Writer) (int64, error) {\n\tbuf, err := header.Format()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn bytes.NewBuffer(buf).WriteTo(w)\n}\n\n// Format renders a proxy protocol header in a format to write over the wire.\nfunc (header *Header) Format() ([]byte, error) {\n\tswitch header.Version {\n\tcase 1:\n\t\treturn header.formatVersion1()\n\tcase 2:\n\t\treturn header.formatVersion2()\n\tdefault:\n\t\treturn nil, ErrUnknownProxyProtocolVersion\n\t}\n}\n\n// TLVs returns the TLVs stored into this header, if they exist.  TLVs are optional for v2 of the protocol.\nfunc (header *Header) TLVs() ([]TLV, error) {\n\treturn SplitTLVs(header.rawTLVs)\n}\n\n// SetTLVs sets the TLVs stored in this header. This method replaces any\n// previous TLV.\nfunc (header *Header) SetTLVs(tlvs []TLV) error {\n\traw, err := JoinTLVs(tlvs)\n\tif err != nil {\n\t\treturn err\n\t}\n\theader.rawTLVs = raw\n\treturn nil\n}\n\n// Read identifies the proxy protocol version and reads the remaining of\n// the header, accordingly.\n//\n// If proxy protocol header signature is not present, the reader buffer remains untouched\n// and is safe for reading outside of this code.\n//\n// If proxy protocol header signature is present but an error is raised while processing\n// the remaining header, assume the reader buffer to be in a corrupt state.\n// Also, this operation will block until enough bytes are available for peeking.\nfunc Read(reader *bufio.Reader) (*Header, error) {\n\t// In order to improve speed for small non-PROXYed packets, take a peek at the first byte alone.\n\tb1, err := reader.Peek(1)\n\tif err != nil {\n\t\tif err == io.EOF {\n\t\t\treturn nil, ErrNoProxyProtocol\n\t\t}\n\t\treturn nil, err\n\t}\n\n\tif bytes.Equal(b1[:1], SIGV1[:1]) || bytes.Equal(b1[:1], SIGV2[:1]) {\n\t\tsignature, err := reader.Peek(5)\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\treturn nil, ErrNoProxyProtocol\n\t\t\t}\n\t\t\treturn nil, err\n\t\t}\n\t\tif bytes.Equal(signature[:5], SIGV1) {\n\t\t\treturn parseVersion1(reader)\n\t\t}\n\n\t\tsignature, err = reader.Peek(12)\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\treturn nil, ErrNoProxyProtocol\n\t\t\t}\n\t\t\treturn nil, err\n\t\t}\n\t\tif bytes.Equal(signature[:12], SIGV2) {\n\t\t\treturn parseVersion2(reader)\n\t\t}\n\t}\n\n\treturn nil, ErrNoProxyProtocol\n}\n\n// ReadTimeout acts as Read but takes a timeout. If that timeout is reached, it's assumed\n// there's no proxy protocol header.\nfunc ReadTimeout(reader *bufio.Reader, timeout time.Duration) (*Header, error) {\n\ttype header struct {\n\t\th *Header\n\t\te error\n\t}\n\tread := make(chan *header, 1)\n\n\tgo func() {\n\t\th := &header{}\n\t\th.h, h.e = Read(reader)\n\t\tread <- h\n\t}()\n\n\ttimer := time.NewTimer(timeout)\n\tselect {\n\tcase result := <-read:\n\t\ttimer.Stop()\n\t\treturn result.h, result.e\n\tcase <-timer.C:\n\t\treturn nil, ErrNoProxyProtocol\n\t}\n}\n", "package proxyproto\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"errors\"\n\t\"net\"\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n)\n\n// Stuff to be used in both versions tests.\n\nconst (\n\tNO_PROTOCOL  = \"There is no spoon\"\n\tIP4_ADDR     = \"127.0.0.1\"\n\tIP6_ADDR     = \"::1\"\n\tPORT         = 65533\n\tINVALID_PORT = 99999\n)\n\nvar (\n\tv4ip = net.ParseIP(IP4_ADDR).To4()\n\tv6ip = net.ParseIP(IP6_ADDR).To16()\n\n\tv4addr net.Addr = &net.TCPAddr{IP: v4ip, Port: PORT}\n\tv6addr net.Addr = &net.TCPAddr{IP: v6ip, Port: PORT}\n\n\tv4UDPAddr net.Addr = &net.UDPAddr{IP: v4ip, Port: PORT}\n\tv6UDPAddr net.Addr = &net.UDPAddr{IP: v6ip, Port: PORT}\n\n\tunixStreamAddr   net.Addr = &net.UnixAddr{Net: \"unix\", Name: \"socket\"}\n\tunixDatagramAddr net.Addr = &net.UnixAddr{Net: \"unixgram\", Name: \"socket\"}\n\n\terrReadIntentionallyBroken = errors.New(\"read is intentionally broken\")\n)\n\ntype timeoutReader []byte\n\nfunc (t *timeoutReader) Read([]byte) (int, error) {\n\ttime.Sleep(500 * time.Millisecond)\n\treturn 0, nil\n}\n\ntype errorReader []byte\n\nfunc (e *errorReader) Read([]byte) (int, error) {\n\treturn 0, errReadIntentionallyBroken\n}\n\nfunc TestReadTimeoutV1Invalid(t *testing.T) {\n\tvar b timeoutReader\n\treader := bufio.NewReader(&b)\n\t_, err := ReadTimeout(reader, 50*time.Millisecond)\n\tif err == nil {\n\t\tt.Fatalf(\"expected error %s\", ErrNoProxyProtocol)\n\t} else if err != ErrNoProxyProtocol {\n\t\tt.Fatalf(\"expected %s, actual %s\", ErrNoProxyProtocol, err)\n\t}\n}\n\nfunc TestReadTimeoutPropagatesReadError(t *testing.T) {\n\tvar e errorReader\n\treader := bufio.NewReader(&e)\n\t_, err := ReadTimeout(reader, 50*time.Millisecond)\n\n\tif err == nil {\n\t\tt.Fatalf(\"expected error %s\", errReadIntentionallyBroken)\n\t} else if err != errReadIntentionallyBroken {\n\t\tt.Fatalf(\"expected error %s, actual %s\", errReadIntentionallyBroken, err)\n\t}\n}\n\nfunc TestEqualsTo(t *testing.T) {\n\tvar headersEqual = []struct {\n\t\tthis, that *Header\n\t\texpected   bool\n\t}{\n\t\t{\n\t\t\t&Header{\n\t\t\t\tVersion:           1,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: TCPv4,\n\t\t\t\tSourceAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"10.1.1.1\"),\n\t\t\t\t\tPort: 1000,\n\t\t\t\t},\n\t\t\t\tDestinationAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"20.2.2.2\"),\n\t\t\t\t\tPort: 2000,\n\t\t\t\t},\n\t\t\t},\n\t\t\tnil,\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t&Header{\n\t\t\t\tVersion:           1,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: TCPv4,\n\t\t\t\tSourceAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"10.1.1.1\"),\n\t\t\t\t\tPort: 1000,\n\t\t\t\t},\n\t\t\t\tDestinationAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"20.2.2.2\"),\n\t\t\t\t\tPort: 2000,\n\t\t\t\t},\n\t\t\t},\n\t\t\t&Header{\n\t\t\t\tVersion:           2,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: TCPv4,\n\t\t\t\tSourceAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"10.1.1.1\"),\n\t\t\t\t\tPort: 1000,\n\t\t\t\t},\n\t\t\t\tDestinationAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"20.2.2.2\"),\n\t\t\t\t\tPort: 2000,\n\t\t\t\t},\n\t\t\t},\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t&Header{\n\t\t\t\tVersion:           1,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: TCPv4,\n\t\t\t\tSourceAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"10.1.1.1\"),\n\t\t\t\t\tPort: 1000,\n\t\t\t\t},\n\t\t\t\tDestinationAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"20.2.2.2\"),\n\t\t\t\t\tPort: 2000,\n\t\t\t\t},\n\t\t\t},\n\t\t\t&Header{\n\t\t\t\tVersion:           1,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: TCPv4,\n\t\t\t\tSourceAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"10.1.1.1\"),\n\t\t\t\t\tPort: 1000,\n\t\t\t\t},\n\t\t\t\tDestinationAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"20.2.2.2\"),\n\t\t\t\t\tPort: 2000,\n\t\t\t\t},\n\t\t\t},\n\t\t\ttrue,\n\t\t},\n\t}\n\n\tfor _, tt := range headersEqual {\n\t\tif actual := tt.this.EqualsTo(tt.that); actual != tt.expected {\n\t\t\tt.Fatalf(\"expected %t, actual %t\", tt.expected, actual)\n\t\t}\n\t}\n}\n\n// This is here just because of coveralls\nfunc TestEqualTo(t *testing.T) {\n\tTestEqualsTo(t)\n}\n\nfunc TestGetters(t *testing.T) {\n\tvar tests = []struct {\n\t\tname                         string\n\t\theader                       *Header\n\t\ttcpSourceAddr, tcpDestAddr   *net.TCPAddr\n\t\tudpSourceAddr, udpDestAddr   *net.UDPAddr\n\t\tunixSourceAddr, unixDestAddr *net.UnixAddr\n\t\tipSource, ipDest             net.IP\n\t\tportSource, portDest         int\n\t}{\n\t\t{\n\t\t\tname: \"TCPv4\",\n\t\t\theader: &Header{\n\t\t\t\tVersion:           1,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: TCPv4,\n\t\t\t\tSourceAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"10.1.1.1\"),\n\t\t\t\t\tPort: 1000,\n\t\t\t\t},\n\t\t\t\tDestinationAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"20.2.2.2\"),\n\t\t\t\t\tPort: 2000,\n\t\t\t\t},\n\t\t\t},\n\t\t\ttcpSourceAddr: &net.TCPAddr{\n\t\t\t\tIP:   net.ParseIP(\"10.1.1.1\"),\n\t\t\t\tPort: 1000,\n\t\t\t},\n\t\t\ttcpDestAddr: &net.TCPAddr{\n\t\t\t\tIP:   net.ParseIP(\"20.2.2.2\"),\n\t\t\t\tPort: 2000,\n\t\t\t},\n\t\t\tipSource:   net.ParseIP(\"10.1.1.1\"),\n\t\t\tipDest:     net.ParseIP(\"20.2.2.2\"),\n\t\t\tportSource: 1000,\n\t\t\tportDest:   2000,\n\t\t},\n\t\t{\n\t\t\tname: \"UDPv4\",\n\t\t\theader: &Header{\n\t\t\t\tVersion:           2,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: UDPv6,\n\t\t\t\tSourceAddr: &net.UDPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"10.1.1.1\"),\n\t\t\t\t\tPort: 1000,\n\t\t\t\t},\n\t\t\t\tDestinationAddr: &net.UDPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"20.2.2.2\"),\n\t\t\t\t\tPort: 2000,\n\t\t\t\t},\n\t\t\t},\n\t\t\tudpSourceAddr: &net.UDPAddr{\n\t\t\t\tIP:   net.ParseIP(\"10.1.1.1\"),\n\t\t\t\tPort: 1000,\n\t\t\t},\n\t\t\tudpDestAddr: &net.UDPAddr{\n\t\t\t\tIP:   net.ParseIP(\"20.2.2.2\"),\n\t\t\t\tPort: 2000,\n\t\t\t},\n\t\t\tipSource:   net.ParseIP(\"10.1.1.1\"),\n\t\t\tipDest:     net.ParseIP(\"20.2.2.2\"),\n\t\t\tportSource: 1000,\n\t\t\tportDest:   2000,\n\t\t},\n\t\t{\n\t\t\tname: \"UnixStream\",\n\t\t\theader: &Header{\n\t\t\t\tVersion:           2,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: UnixStream,\n\t\t\t\tSourceAddr: &net.UnixAddr{\n\t\t\t\t\tNet:  \"unix\",\n\t\t\t\t\tName: \"src\",\n\t\t\t\t},\n\t\t\t\tDestinationAddr: &net.UnixAddr{\n\t\t\t\t\tNet:  \"unix\",\n\t\t\t\t\tName: \"dst\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tunixSourceAddr: &net.UnixAddr{\n\t\t\t\tNet:  \"unix\",\n\t\t\t\tName: \"src\",\n\t\t\t},\n\t\t\tunixDestAddr: &net.UnixAddr{\n\t\t\t\tNet:  \"unix\",\n\t\t\t\tName: \"dst\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"UnixDatagram\",\n\t\t\theader: &Header{\n\t\t\t\tVersion:           2,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: UnixDatagram,\n\t\t\t\tSourceAddr: &net.UnixAddr{\n\t\t\t\t\tNet:  \"unix\",\n\t\t\t\t\tName: \"src\",\n\t\t\t\t},\n\t\t\t\tDestinationAddr: &net.UnixAddr{\n\t\t\t\t\tNet:  \"unix\",\n\t\t\t\t\tName: \"dst\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tunixSourceAddr: &net.UnixAddr{\n\t\t\t\tNet:  \"unix\",\n\t\t\t\tName: \"src\",\n\t\t\t},\n\t\t\tunixDestAddr: &net.UnixAddr{\n\t\t\t\tNet:  \"unix\",\n\t\t\t\tName: \"dst\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Unspec\",\n\t\t\theader: &Header{\n\t\t\t\tVersion:           1,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: UNSPEC,\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\ttcpSourceAddr, tcpDestAddr, _ := test.header.TCPAddrs()\n\t\t\tif test.tcpSourceAddr != nil && !reflect.DeepEqual(tcpSourceAddr, test.tcpSourceAddr) {\n\t\t\t\tt.Errorf(\"TCPAddrs() source = %v, want %v\", tcpSourceAddr, test.tcpSourceAddr)\n\t\t\t}\n\t\t\tif test.tcpDestAddr != nil && !reflect.DeepEqual(tcpDestAddr, test.tcpDestAddr) {\n\t\t\t\tt.Errorf(\"TCPAddrs() dest = %v, want %v\", tcpDestAddr, test.tcpDestAddr)\n\t\t\t}\n\n\t\t\tudpSourceAddr, udpDestAddr, _ := test.header.UDPAddrs()\n\t\t\tif test.udpSourceAddr != nil && !reflect.DeepEqual(udpSourceAddr, test.udpSourceAddr) {\n\t\t\t\tt.Errorf(\"TCPAddrs() source = %v, want %v\", udpSourceAddr, test.udpSourceAddr)\n\t\t\t}\n\t\t\tif test.udpDestAddr != nil && !reflect.DeepEqual(udpDestAddr, test.udpDestAddr) {\n\t\t\t\tt.Errorf(\"TCPAddrs() dest = %v, want %v\", udpDestAddr, test.udpDestAddr)\n\t\t\t}\n\n\t\t\tunixSourceAddr, unixDestAddr, _ := test.header.UnixAddrs()\n\t\t\tif test.unixSourceAddr != nil && !reflect.DeepEqual(unixSourceAddr, test.unixSourceAddr) {\n\t\t\t\tt.Errorf(\"UnixAddrs() source = %v, want %v\", unixSourceAddr, test.unixSourceAddr)\n\t\t\t}\n\t\t\tif test.unixDestAddr != nil && !reflect.DeepEqual(unixDestAddr, test.unixDestAddr) {\n\t\t\t\tt.Errorf(\"UnixAddrs() dest = %v, want %v\", unixDestAddr, test.unixDestAddr)\n\t\t\t}\n\n\t\t\tipSource, ipDest, _ := test.header.IPs()\n\t\t\tif test.ipSource != nil && !ipSource.Equal(test.ipSource) {\n\t\t\t\tt.Errorf(\"IPs() source = %v, want %v\", ipSource, test.ipSource)\n\t\t\t}\n\t\t\tif test.ipDest != nil && !ipDest.Equal(test.ipDest) {\n\t\t\t\tt.Errorf(\"IPs() dest = %v, want %v\", ipDest, test.ipDest)\n\t\t\t}\n\n\t\t\tportSource, portDest, _ := test.header.Ports()\n\t\t\tif test.portSource != 0 && portSource != test.portSource {\n\t\t\t\tt.Errorf(\"Ports() source = %v, want %v\", portSource, test.portSource)\n\t\t\t}\n\t\t\tif test.portDest != 0 && portDest != test.portDest {\n\t\t\t\tt.Errorf(\"Ports() dest = %v, want %v\", portDest, test.portDest)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSetTLVs(t *testing.T) {\n\ttests := []struct {\n\t\theader    *Header\n\t\tname      string\n\t\ttlvs      []TLV\n\t\texpectErr bool\n\t}{\n\t\t{\n\t\t\tname: \"add authority TLV\",\n\t\t\theader: &Header{\n\t\t\t\tVersion:           1,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: TCPv4,\n\t\t\t\tSourceAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"10.1.1.1\"),\n\t\t\t\t\tPort: 1000,\n\t\t\t\t},\n\t\t\t\tDestinationAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"20.2.2.2\"),\n\t\t\t\t\tPort: 2000,\n\t\t\t\t},\n\t\t\t},\n\t\t\ttlvs: []TLV{{\n\t\t\t\tType:  PP2_TYPE_AUTHORITY,\n\t\t\t\tValue: []byte(\"example.org\"),\n\t\t\t}},\n\t\t},\n\t\t{\n\t\t\tname: \"add too long TLV\",\n\t\t\theader: &Header{\n\t\t\t\tVersion:           1,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: TCPv4,\n\t\t\t\tSourceAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"10.1.1.1\"),\n\t\t\t\t\tPort: 1000,\n\t\t\t\t},\n\t\t\t\tDestinationAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"20.2.2.2\"),\n\t\t\t\t\tPort: 2000,\n\t\t\t\t},\n\t\t\t},\n\t\t\ttlvs: []TLV{{\n\t\t\t\tType:  PP2_TYPE_AUTHORITY,\n\t\t\t\tValue: append(bytes.Repeat([]byte(\"a\"), 0xFFFF), []byte(\".example.org\")...),\n\t\t\t}},\n\t\t\texpectErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\terr := tt.header.SetTLVs(tt.tlvs)\n\t\tif err != nil && !tt.expectErr {\n\t\t\tt.Fatalf(\"shouldn't have thrown error %q\", err.Error())\n\t\t}\n\t}\n}\n\nfunc TestWriteTo(t *testing.T) {\n\tvar buf bytes.Buffer\n\n\tvalidHeader := &Header{\n\t\tVersion:           1,\n\t\tCommand:           PROXY,\n\t\tTransportProtocol: TCPv4,\n\t\tSourceAddr: &net.TCPAddr{\n\t\t\tIP:   net.ParseIP(\"10.1.1.1\"),\n\t\t\tPort: 1000,\n\t\t},\n\t\tDestinationAddr: &net.TCPAddr{\n\t\t\tIP:   net.ParseIP(\"20.2.2.2\"),\n\t\t\tPort: 2000,\n\t\t},\n\t}\n\n\tif _, err := validHeader.WriteTo(&buf); err != nil {\n\t\tt.Fatalf(\"shouldn't have thrown error %q\", err.Error())\n\t}\n\n\tinvalidHeader := &Header{\n\t\tSourceAddr: &net.TCPAddr{\n\t\t\tIP:   net.ParseIP(\"10.1.1.1\"),\n\t\t\tPort: 1000,\n\t\t},\n\t\tDestinationAddr: &net.TCPAddr{\n\t\t\tIP:   net.ParseIP(\"20.2.2.2\"),\n\t\t\tPort: 2000,\n\t\t},\n\t}\n\n\tif _, err := invalidHeader.WriteTo(&buf); err == nil {\n\t\tt.Fatalf(\"should have thrown error %q\", err.Error())\n\t}\n}\n\nfunc TestFormat(t *testing.T) {\n\tvalidHeader := &Header{\n\t\tVersion:           1,\n\t\tCommand:           PROXY,\n\t\tTransportProtocol: TCPv4,\n\t\tSourceAddr: &net.TCPAddr{\n\t\t\tIP:   net.ParseIP(\"10.1.1.1\"),\n\t\t\tPort: 1000,\n\t\t},\n\t\tDestinationAddr: &net.TCPAddr{\n\t\t\tIP:   net.ParseIP(\"20.2.2.2\"),\n\t\t\tPort: 2000,\n\t\t},\n\t}\n\n\tif _, err := validHeader.Format(); err != nil {\n\t\tt.Fatalf(\"shouldn't have thrown error %q\", err.Error())\n\t}\n}\n\nfunc TestFormatInvalid(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\theader *Header\n\t\terr    error\n\t}{\n\t\t{\n\t\t\tname: \"invalidVersion\",\n\t\t\theader: &Header{\n\t\t\t\tVersion:           3,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: TCPv4,\n\t\t\t\tSourceAddr:        v4addr,\n\t\t\t\tDestinationAddr:   v4addr,\n\t\t\t},\n\t\t\terr: ErrUnknownProxyProtocolVersion,\n\t\t},\n\t\t{\n\t\t\tname: \"v2MismatchTCPv4_UDPv4\",\n\t\t\theader: &Header{\n\t\t\t\tVersion:           2,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: TCPv4,\n\t\t\t\tSourceAddr:        v4UDPAddr,\n\t\t\t\tDestinationAddr:   v4addr,\n\t\t\t},\n\t\t\terr: ErrInvalidAddress,\n\t\t},\n\t\t{\n\t\t\tname: \"v2MismatchTCPv4_TCPv6\",\n\t\t\theader: &Header{\n\t\t\t\tVersion:           2,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: TCPv4,\n\t\t\t\tSourceAddr:        v4addr,\n\t\t\t\tDestinationAddr:   v6addr,\n\t\t\t},\n\t\t\terr: ErrInvalidAddress,\n\t\t},\n\t\t{\n\t\t\tname: \"v2MismatchUnixStream_TCPv4\",\n\t\t\theader: &Header{\n\t\t\t\tVersion:           2,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: UnixStream,\n\t\t\t\tSourceAddr:        v4addr,\n\t\t\t\tDestinationAddr:   unixStreamAddr,\n\t\t\t},\n\t\t\terr: ErrInvalidAddress,\n\t\t},\n\t\t{\n\t\t\tname: \"v1MismatchTCPv4_TCPv6\",\n\t\t\theader: &Header{\n\t\t\t\tVersion:           1,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: TCPv4,\n\t\t\t\tSourceAddr:        v6addr,\n\t\t\t\tDestinationAddr:   v4addr,\n\t\t\t},\n\t\t\terr: ErrInvalidAddress,\n\t\t},\n\t\t{\n\t\t\tname: \"v1MismatchTCPv4_UDPv4\",\n\t\t\theader: &Header{\n\t\t\t\tVersion:           1,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: TCPv4,\n\t\t\t\tSourceAddr:        v4UDPAddr,\n\t\t\t\tDestinationAddr:   v4addr,\n\t\t\t},\n\t\t\terr: ErrInvalidAddress,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tif _, err := test.header.Format(); err == nil {\n\t\t\t\tt.Errorf(\"Header.Format() succeeded, want an error\")\n\t\t\t} else if err != test.err {\n\t\t\t\tt.Errorf(\"Header.Format() = %q, want %q\", err, test.err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestHeaderProxyFromAddrs(t *testing.T) {\n\tunspec := &Header{\n\t\tVersion:           2,\n\t\tCommand:           LOCAL,\n\t\tTransportProtocol: UNSPEC,\n\t}\n\n\ttests := []struct {\n\t\tname                 string\n\t\tversion              byte\n\t\tsourceAddr, destAddr net.Addr\n\t\texpected             *Header\n\t}{\n\t\t{\n\t\t\tname: \"TCPv4\",\n\t\t\tsourceAddr: &net.TCPAddr{\n\t\t\t\tIP:   net.ParseIP(\"10.1.1.1\"),\n\t\t\t\tPort: 1000,\n\t\t\t},\n\t\t\tdestAddr: &net.TCPAddr{\n\t\t\t\tIP:   net.ParseIP(\"20.2.2.2\"),\n\t\t\t\tPort: 2000,\n\t\t\t},\n\t\t\texpected: &Header{\n\t\t\t\tVersion:           2,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: TCPv4,\n\t\t\t\tSourceAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"10.1.1.1\"),\n\t\t\t\t\tPort: 1000,\n\t\t\t\t},\n\t\t\t\tDestinationAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"20.2.2.2\"),\n\t\t\t\t\tPort: 2000,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"TCPv6\",\n\t\t\tsourceAddr: &net.TCPAddr{\n\t\t\t\tIP:   net.ParseIP(\"fde7::372\"),\n\t\t\t\tPort: 1000,\n\t\t\t},\n\t\t\tdestAddr: &net.TCPAddr{\n\t\t\t\tIP:   net.ParseIP(\"fde7::1\"),\n\t\t\t\tPort: 2000,\n\t\t\t},\n\t\t\texpected: &Header{\n\t\t\t\tVersion:           2,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: TCPv6,\n\t\t\t\tSourceAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"fde7::372\"),\n\t\t\t\t\tPort: 1000,\n\t\t\t\t},\n\t\t\t\tDestinationAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"fde7::1\"),\n\t\t\t\t\tPort: 2000,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"UDPv4\",\n\t\t\tsourceAddr: &net.UDPAddr{\n\t\t\t\tIP:   net.ParseIP(\"10.1.1.1\"),\n\t\t\t\tPort: 1000,\n\t\t\t},\n\t\t\tdestAddr: &net.UDPAddr{\n\t\t\t\tIP:   net.ParseIP(\"20.2.2.2\"),\n\t\t\t\tPort: 2000,\n\t\t\t},\n\t\t\texpected: &Header{\n\t\t\t\tVersion:           2,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: UDPv4,\n\t\t\t\tSourceAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"10.1.1.1\"),\n\t\t\t\t\tPort: 1000,\n\t\t\t\t},\n\t\t\t\tDestinationAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"20.2.2.2\"),\n\t\t\t\t\tPort: 2000,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"UDPv6\",\n\t\t\tsourceAddr: &net.UDPAddr{\n\t\t\t\tIP:   net.ParseIP(\"fde7::372\"),\n\t\t\t\tPort: 1000,\n\t\t\t},\n\t\t\tdestAddr: &net.UDPAddr{\n\t\t\t\tIP:   net.ParseIP(\"fde7::1\"),\n\t\t\t\tPort: 2000,\n\t\t\t},\n\t\t\texpected: &Header{\n\t\t\t\tVersion:           2,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: UDPv6,\n\t\t\t\tSourceAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"fde7::372\"),\n\t\t\t\t\tPort: 1000,\n\t\t\t\t},\n\t\t\t\tDestinationAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"fde7::1\"),\n\t\t\t\t\tPort: 2000,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"UnixStream\",\n\t\t\tsourceAddr: &net.UnixAddr{\n\t\t\t\tNet:  \"unix\",\n\t\t\t\tName: \"src\",\n\t\t\t},\n\t\t\tdestAddr: &net.UnixAddr{\n\t\t\t\tNet:  \"unix\",\n\t\t\t\tName: \"dst\",\n\t\t\t},\n\t\t\texpected: &Header{\n\t\t\t\tVersion:           2,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: UnixStream,\n\t\t\t\tSourceAddr: &net.UnixAddr{\n\t\t\t\t\tNet:  \"unix\",\n\t\t\t\t\tName: \"src\",\n\t\t\t\t},\n\t\t\t\tDestinationAddr: &net.UnixAddr{\n\t\t\t\t\tNet:  \"unix\",\n\t\t\t\t\tName: \"dst\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"UnixDatagram\",\n\t\t\tsourceAddr: &net.UnixAddr{\n\t\t\t\tNet:  \"unixgram\",\n\t\t\t\tName: \"src\",\n\t\t\t},\n\t\t\tdestAddr: &net.UnixAddr{\n\t\t\t\tNet:  \"unixgram\",\n\t\t\t\tName: \"dst\",\n\t\t\t},\n\t\t\texpected: &Header{\n\t\t\t\tVersion:           2,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: UnixDatagram,\n\t\t\t\tSourceAddr: &net.UnixAddr{\n\t\t\t\t\tNet:  \"unixgram\",\n\t\t\t\t\tName: \"src\",\n\t\t\t\t},\n\t\t\t\tDestinationAddr: &net.UnixAddr{\n\t\t\t\t\tNet:  \"unixgram\",\n\t\t\t\t\tName: \"dst\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:    \"Version1\",\n\t\t\tversion: 1,\n\t\t\tsourceAddr: &net.TCPAddr{\n\t\t\t\tIP:   net.ParseIP(\"10.1.1.1\"),\n\t\t\t\tPort: 1000,\n\t\t\t},\n\t\t\tdestAddr: &net.TCPAddr{\n\t\t\t\tIP:   net.ParseIP(\"20.2.2.2\"),\n\t\t\t\tPort: 2000,\n\t\t\t},\n\t\t\texpected: &Header{\n\t\t\t\tVersion:           1,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: TCPv4,\n\t\t\t\tSourceAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"10.1.1.1\"),\n\t\t\t\t\tPort: 1000,\n\t\t\t\t},\n\t\t\t\tDestinationAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"20.2.2.2\"),\n\t\t\t\t\tPort: 2000,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"TCPInvalidIP\",\n\t\t\tsourceAddr: &net.TCPAddr{\n\t\t\t\tIP:   nil,\n\t\t\t\tPort: 1000,\n\t\t\t},\n\t\t\tdestAddr: &net.TCPAddr{\n\t\t\t\tIP:   nil,\n\t\t\t\tPort: 2000,\n\t\t\t},\n\t\t\texpected: unspec,\n\t\t},\n\t\t{\n\t\t\tname: \"UDPInvalidIP\",\n\t\t\tsourceAddr: &net.UDPAddr{\n\t\t\t\tIP:   nil,\n\t\t\t\tPort: 1000,\n\t\t\t},\n\t\t\tdestAddr: &net.UDPAddr{\n\t\t\t\tIP:   nil,\n\t\t\t\tPort: 2000,\n\t\t\t},\n\t\t\texpected: unspec,\n\t\t},\n\t\t{\n\t\t\tname: \"TCPAddrTypeMismatch\",\n\t\t\tsourceAddr: &net.TCPAddr{\n\t\t\t\tIP:   net.ParseIP(\"10.1.1.1\"),\n\t\t\t\tPort: 1000,\n\t\t\t},\n\t\t\tdestAddr: &net.UDPAddr{\n\t\t\t\tIP:   net.ParseIP(\"20.2.2.2\"),\n\t\t\t\tPort: 2000,\n\t\t\t},\n\t\t\texpected: unspec,\n\t\t},\n\t\t{\n\t\t\tname: \"UDPAddrTypeMismatch\",\n\t\t\tsourceAddr: &net.UDPAddr{\n\t\t\t\tIP:   net.ParseIP(\"10.1.1.1\"),\n\t\t\t\tPort: 1000,\n\t\t\t},\n\t\t\tdestAddr: &net.TCPAddr{\n\t\t\t\tIP:   net.ParseIP(\"20.2.2.2\"),\n\t\t\t\tPort: 2000,\n\t\t\t},\n\t\t\texpected: unspec,\n\t\t},\n\t\t{\n\t\t\tname: \"UnixAddrTypeMismatch\",\n\t\t\tsourceAddr: &net.UnixAddr{\n\t\t\t\tNet: \"unix\",\n\t\t\t},\n\t\t\tdestAddr: &net.TCPAddr{\n\t\t\t\tIP:   net.ParseIP(\"20.2.2.2\"),\n\t\t\t\tPort: 2000,\n\t\t\t},\n\t\t\texpected: unspec,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\th := HeaderProxyFromAddrs(tt.version, tt.sourceAddr, tt.destAddr)\n\n\t\t\tif !h.EqualsTo(tt.expected) {\n\t\t\t\tt.Errorf(\"expected %+v, actual %+v for source %+v and destination %+v\", tt.expected, h, tt.sourceAddr, tt.destAddr)\n\t\t\t}\n\t\t})\n\t}\n}\n", "package proxyproto\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"net\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nconst (\n\tcrlf      = \"\\r\\n\"\n\tseparator = \" \"\n)\n\nfunc initVersion1() *Header {\n\theader := new(Header)\n\theader.Version = 1\n\t// Command doesn't exist in v1\n\theader.Command = PROXY\n\treturn header\n}\n\nfunc parseVersion1(reader *bufio.Reader) (*Header, error) {\n\t// Read until LF shows up, otherwise fail.\n\t// At this point, can't be sure CR precedes LF which will be validated next.\n\tline, err := reader.ReadString('\\n')\n\tif err != nil {\n\t\treturn nil, ErrLineMustEndWithCrlf\n\t}\n\tif !strings.HasSuffix(line, crlf) {\n\t\treturn nil, ErrLineMustEndWithCrlf\n\t}\n\t// Check full signature.\n\ttokens := strings.Split(line[:len(line)-2], separator)\n\n\t// Expect at least 2 tokens: \"PROXY\" and the transport protocol.\n\tif len(tokens) < 2 {\n\t\treturn nil, ErrCantReadAddressFamilyAndProtocol\n\t}\n\n\t// Read address family and protocol\n\tvar transportProtocol AddressFamilyAndProtocol\n\tswitch tokens[1] {\n\tcase \"TCP4\":\n\t\ttransportProtocol = TCPv4\n\tcase \"TCP6\":\n\t\ttransportProtocol = TCPv6\n\tcase \"UNKNOWN\":\n\t\ttransportProtocol = UNSPEC // doesn't exist in v1 but fits UNKNOWN\n\tdefault:\n\t\treturn nil, ErrCantReadAddressFamilyAndProtocol\n\t}\n\n\t// Expect 6 tokens only when UNKNOWN is not present.\n\tif transportProtocol != UNSPEC && len(tokens) < 6 {\n\t\treturn nil, ErrCantReadAddressFamilyAndProtocol\n\t}\n\n\t// When a signature is found, allocate a v1 header with Command set to PROXY.\n\t// Command doesn't exist in v1 but set it for other parts of this library\n\t// to rely on it for determining connection details.\n\theader := initVersion1()\n\n\t// Transport protocol has been processed already.\n\theader.TransportProtocol = transportProtocol\n\n\t// When UNKNOWN, set the command to LOCAL and return early\n\tif header.TransportProtocol == UNSPEC {\n\t\theader.Command = LOCAL\n\t\treturn header, nil\n\t}\n\n\t// Otherwise, continue to read addresses and ports\n\tsourceIP, err := parseV1IPAddress(header.TransportProtocol, tokens[2])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdestIP, err := parseV1IPAddress(header.TransportProtocol, tokens[3])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tsourcePort, err := parseV1PortNumber(tokens[4])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdestPort, err := parseV1PortNumber(tokens[5])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\theader.SourceAddr = &net.TCPAddr{\n\t\tIP:   sourceIP,\n\t\tPort: sourcePort,\n\t}\n\theader.DestinationAddr = &net.TCPAddr{\n\t\tIP:   destIP,\n\t\tPort: destPort,\n\t}\n\n\treturn header, nil\n}\n\nfunc (header *Header) formatVersion1() ([]byte, error) {\n\t// As of version 1, only \"TCP4\" ( \\x54 \\x43 \\x50 \\x34 ) for TCP over IPv4,\n\t// and \"TCP6\" ( \\x54 \\x43 \\x50 \\x36 ) for TCP over IPv6 are allowed.\n\tvar proto string\n\tswitch header.TransportProtocol {\n\tcase TCPv4:\n\t\tproto = \"TCP4\"\n\tcase TCPv6:\n\t\tproto = \"TCP6\"\n\tdefault:\n\t\t// Unknown connection (short form)\n\t\treturn []byte(\"PROXY UNKNOWN\" + crlf), nil\n\t}\n\n\tsourceAddr, sourceOK := header.SourceAddr.(*net.TCPAddr)\n\tdestAddr, destOK := header.DestinationAddr.(*net.TCPAddr)\n\tif !sourceOK || !destOK {\n\t\treturn nil, ErrInvalidAddress\n\t}\n\n\tsourceIP, destIP := sourceAddr.IP, destAddr.IP\n\tswitch header.TransportProtocol {\n\tcase TCPv4:\n\t\tsourceIP = sourceIP.To4()\n\t\tdestIP = destIP.To4()\n\tcase TCPv6:\n\t\tsourceIP = sourceIP.To16()\n\t\tdestIP = destIP.To16()\n\t}\n\tif sourceIP == nil || destIP == nil {\n\t\treturn nil, ErrInvalidAddress\n\t}\n\n\tbuf := bytes.NewBuffer(make([]byte, 0, 108))\n\tbuf.Write(SIGV1)\n\tbuf.WriteString(separator)\n\tbuf.WriteString(proto)\n\tbuf.WriteString(separator)\n\tbuf.WriteString(sourceIP.String())\n\tbuf.WriteString(separator)\n\tbuf.WriteString(destIP.String())\n\tbuf.WriteString(separator)\n\tbuf.WriteString(strconv.Itoa(sourceAddr.Port))\n\tbuf.WriteString(separator)\n\tbuf.WriteString(strconv.Itoa(destAddr.Port))\n\tbuf.WriteString(crlf)\n\n\treturn buf.Bytes(), nil\n}\n\nfunc parseV1PortNumber(portStr string) (int, error) {\n\tport, err := strconv.Atoi(portStr)\n\tif err != nil || port < 0 || port > 65535 {\n\t\treturn 0, ErrInvalidPortNumber\n\t}\n\treturn port, nil\n}\n\nfunc parseV1IPAddress(protocol AddressFamilyAndProtocol, addrStr string) (addr net.IP, err error) {\n\taddr = net.ParseIP(addrStr)\n\ttryV4 := addr.To4()\n\tif (protocol == TCPv4 && tryV4 == nil) || (protocol == TCPv6 && tryV4 != nil) {\n\t\terr = ErrInvalidAddress\n\t}\n\treturn\n}\n", "package proxyproto\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n)\n\nvar (\n\tIPv4AddressesAndPorts        = strings.Join([]string{IP4_ADDR, IP4_ADDR, strconv.Itoa(PORT), strconv.Itoa(PORT)}, separator)\n\tIPv4AddressesAndInvalidPorts = strings.Join([]string{IP4_ADDR, IP4_ADDR, strconv.Itoa(INVALID_PORT), strconv.Itoa(INVALID_PORT)}, separator)\n\tIPv6AddressesAndPorts        = strings.Join([]string{IP6_ADDR, IP6_ADDR, strconv.Itoa(PORT), strconv.Itoa(PORT)}, separator)\n\n\tfixtureTCP4V1 = \"PROXY TCP4 \" + IPv4AddressesAndPorts + crlf + \"GET /\"\n\tfixtureTCP6V1 = \"PROXY TCP6 \" + IPv6AddressesAndPorts + crlf + \"GET /\"\n\n\tfixtureUnknown              = \"PROXY UNKNOWN\" + crlf\n\tfixtureUnknownWithAddresses = \"PROXY UNKNOWN \" + IPv4AddressesAndInvalidPorts + crlf\n)\n\nvar invalidParseV1Tests = []struct {\n\tdesc          string\n\treader        *bufio.Reader\n\texpectedError error\n}{\n\t{\n\t\tdesc:          \"no signature\",\n\t\treader:        newBufioReader([]byte(NO_PROTOCOL)),\n\t\texpectedError: ErrNoProxyProtocol,\n\t},\n\t{\n\t\tdesc:          \"prox\",\n\t\treader:        newBufioReader([]byte(\"PROX\")),\n\t\texpectedError: ErrNoProxyProtocol,\n\t},\n\t{\n\t\tdesc:          \"proxy lf\",\n\t\treader:        newBufioReader([]byte(\"PROXY \\n\")),\n\t\texpectedError: ErrLineMustEndWithCrlf,\n\t},\n\t{\n\t\tdesc:          \"proxy crlf\",\n\t\treader:        newBufioReader([]byte(\"PROXY \" + crlf)),\n\t\texpectedError: ErrCantReadAddressFamilyAndProtocol,\n\t},\n\t{\n\t\tdesc:          \"proxy no space crlf\",\n\t\treader:        newBufioReader([]byte(\"PROXY\" + crlf)),\n\t\texpectedError: ErrCantReadAddressFamilyAndProtocol,\n\t},\n\t{\n\t\tdesc:          \"proxy something crlf\",\n\t\treader:        newBufioReader([]byte(\"PROXY SOMETHING\" + crlf)),\n\t\texpectedError: ErrCantReadAddressFamilyAndProtocol,\n\t},\n\t{\n\t\tdesc:          \"incomplete signature TCP4\",\n\t\treader:        newBufioReader([]byte(\"PROXY TCP4 \" + IPv4AddressesAndPorts)),\n\t\texpectedError: ErrLineMustEndWithCrlf,\n\t},\n\t{\n\t\tdesc:          \"TCP6 with IPv4 addresses\",\n\t\treader:        newBufioReader([]byte(\"PROXY TCP6 \" + IPv4AddressesAndPorts + crlf)),\n\t\texpectedError: ErrInvalidAddress,\n\t},\n\t{\n\t\tdesc:          \"TCP4 with IPv6 addresses\",\n\t\treader:        newBufioReader([]byte(\"PROXY TCP4 \" + IPv6AddressesAndPorts + crlf)),\n\t\texpectedError: ErrInvalidAddress,\n\t},\n\t{\n\t\tdesc:          \"TCP4 with invalid port\",\n\t\treader:        newBufioReader([]byte(\"PROXY TCP4 \" + IPv4AddressesAndInvalidPorts + crlf)),\n\t\texpectedError: ErrInvalidPortNumber,\n\t},\n}\n\nfunc TestReadV1Invalid(t *testing.T) {\n\tfor _, tt := range invalidParseV1Tests {\n\t\tt.Run(tt.desc, func(t *testing.T) {\n\t\t\tif _, err := Read(tt.reader); err != tt.expectedError {\n\t\t\t\tt.Fatalf(\"expected %s, actual %s\", tt.expectedError, err.Error())\n\t\t\t}\n\t\t})\n\t}\n}\n\nvar validParseAndWriteV1Tests = []struct {\n\tdesc           string\n\treader         *bufio.Reader\n\texpectedHeader *Header\n}{\n\t{\n\t\tdesc:   \"TCP4\",\n\t\treader: bufio.NewReader(strings.NewReader(fixtureTCP4V1)),\n\t\texpectedHeader: &Header{\n\t\t\tVersion:           1,\n\t\t\tCommand:           PROXY,\n\t\t\tTransportProtocol: TCPv4,\n\t\t\tSourceAddr:        v4addr,\n\t\t\tDestinationAddr:   v4addr,\n\t\t},\n\t},\n\t{\n\t\tdesc:   \"TCP6\",\n\t\treader: bufio.NewReader(strings.NewReader(fixtureTCP6V1)),\n\t\texpectedHeader: &Header{\n\t\t\tVersion:           1,\n\t\t\tCommand:           PROXY,\n\t\t\tTransportProtocol: TCPv6,\n\t\t\tSourceAddr:        v6addr,\n\t\t\tDestinationAddr:   v6addr,\n\t\t},\n\t},\n\t{\n\t\tdesc:   \"unknown\",\n\t\treader: bufio.NewReader(strings.NewReader(fixtureUnknown)),\n\t\texpectedHeader: &Header{\n\t\t\tVersion:           1,\n\t\t\tCommand:           LOCAL,\n\t\t\tTransportProtocol: UNSPEC,\n\t\t\tSourceAddr:        nil,\n\t\t\tDestinationAddr:   nil,\n\t\t},\n\t},\n\t{\n\t\tdesc:   \"unknown with addresses and ports\",\n\t\treader: bufio.NewReader(strings.NewReader(fixtureUnknownWithAddresses)),\n\t\texpectedHeader: &Header{\n\t\t\tVersion:           1,\n\t\t\tCommand:           LOCAL,\n\t\t\tTransportProtocol: UNSPEC,\n\t\t\tSourceAddr:        nil,\n\t\t\tDestinationAddr:   nil,\n\t\t},\n\t},\n}\n\nfunc TestParseV1Valid(t *testing.T) {\n\tfor _, tt := range validParseAndWriteV1Tests {\n\t\tt.Run(tt.desc, func(t *testing.T) {\n\t\t\theader, err := Read(tt.reader)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(\"unexpected error\", err.Error())\n\t\t\t}\n\t\t\tif !header.EqualsTo(tt.expectedHeader) {\n\t\t\t\tt.Fatalf(\"expected %#v, actual %#v\", tt.expectedHeader, header)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestWriteV1Valid(t *testing.T) {\n\tfor _, tt := range validParseAndWriteV1Tests {\n\t\tt.Run(tt.desc, func(t *testing.T) {\n\t\t\tvar b bytes.Buffer\n\t\t\tw := bufio.NewWriter(&b)\n\t\t\tif _, err := tt.expectedHeader.WriteTo(w); err != nil {\n\t\t\t\tt.Fatal(\"unexpected error \", err)\n\t\t\t}\n\t\t\tw.Flush()\n\n\t\t\t// Read written bytes to validate written header\n\t\t\tr := bufio.NewReader(&b)\n\t\t\tnewHeader, err := Read(r)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(\"unexpected error \", err)\n\t\t\t}\n\n\t\t\tif !newHeader.EqualsTo(tt.expectedHeader) {\n\t\t\t\tt.Fatalf(\"expected %#v, actual %#v\", tt.expectedHeader, newHeader)\n\t\t\t}\n\t\t})\n\t}\n}\n"], "fixing_code": ["// Package proxyproto implements Proxy Protocol (v1 and v2) parser and writer, as per specification:\n// https://www.haproxy.org/download/2.3/doc/proxy-protocol.txt\npackage proxyproto\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"net\"\n\t\"time\"\n)\n\nvar (\n\t// Protocol\n\tSIGV1 = []byte{'\\x50', '\\x52', '\\x4F', '\\x58', '\\x59'}\n\tSIGV2 = []byte{'\\x0D', '\\x0A', '\\x0D', '\\x0A', '\\x00', '\\x0D', '\\x0A', '\\x51', '\\x55', '\\x49', '\\x54', '\\x0A'}\n\n\tErrCantReadVersion1Header               = errors.New(\"proxyproto: can't read version 1 header\")\n\tErrVersion1HeaderTooLong                = errors.New(\"proxyproto: version 1 header must be 107 bytes or less\")\n\tErrLineMustEndWithCrlf                  = errors.New(\"proxyproto: version 1 header is invalid, must end with \\\\r\\\\n\")\n\tErrCantReadProtocolVersionAndCommand    = errors.New(\"proxyproto: can't read proxy protocol version and command\")\n\tErrCantReadAddressFamilyAndProtocol     = errors.New(\"proxyproto: can't read address family or protocol\")\n\tErrCantReadLength                       = errors.New(\"proxyproto: can't read length\")\n\tErrCantResolveSourceUnixAddress         = errors.New(\"proxyproto: can't resolve source Unix address\")\n\tErrCantResolveDestinationUnixAddress    = errors.New(\"proxyproto: can't resolve destination Unix address\")\n\tErrNoProxyProtocol                      = errors.New(\"proxyproto: proxy protocol signature not present\")\n\tErrUnknownProxyProtocolVersion          = errors.New(\"proxyproto: unknown proxy protocol version\")\n\tErrUnsupportedProtocolVersionAndCommand = errors.New(\"proxyproto: unsupported proxy protocol version and command\")\n\tErrUnsupportedAddressFamilyAndProtocol  = errors.New(\"proxyproto: unsupported address family and protocol\")\n\tErrInvalidLength                        = errors.New(\"proxyproto: invalid length\")\n\tErrInvalidAddress                       = errors.New(\"proxyproto: invalid address\")\n\tErrInvalidPortNumber                    = errors.New(\"proxyproto: invalid port number\")\n\tErrSuperfluousProxyHeader               = errors.New(\"proxyproto: upstream connection sent PROXY header but isn't allowed to send one\")\n)\n\n// Header is the placeholder for proxy protocol header.\ntype Header struct {\n\tVersion           byte\n\tCommand           ProtocolVersionAndCommand\n\tTransportProtocol AddressFamilyAndProtocol\n\tSourceAddr        net.Addr\n\tDestinationAddr   net.Addr\n\trawTLVs           []byte\n}\n\n// HeaderProxyFromAddrs creates a new PROXY header from a source and a\n// destination address. If version is zero, the latest protocol version is\n// used.\n//\n// The header is filled on a best-effort basis: if hints cannot be inferred\n// from the provided addresses, the header will be left unspecified.\nfunc HeaderProxyFromAddrs(version byte, sourceAddr, destAddr net.Addr) *Header {\n\tif version < 1 || version > 2 {\n\t\tversion = 2\n\t}\n\th := &Header{\n\t\tVersion:           version,\n\t\tCommand:           LOCAL,\n\t\tTransportProtocol: UNSPEC,\n\t}\n\tswitch sourceAddr := sourceAddr.(type) {\n\tcase *net.TCPAddr:\n\t\tif _, ok := destAddr.(*net.TCPAddr); !ok {\n\t\t\tbreak\n\t\t}\n\t\tif len(sourceAddr.IP.To4()) == net.IPv4len {\n\t\t\th.TransportProtocol = TCPv4\n\t\t} else if len(sourceAddr.IP) == net.IPv6len {\n\t\t\th.TransportProtocol = TCPv6\n\t\t}\n\tcase *net.UDPAddr:\n\t\tif _, ok := destAddr.(*net.UDPAddr); !ok {\n\t\t\tbreak\n\t\t}\n\t\tif len(sourceAddr.IP.To4()) == net.IPv4len {\n\t\t\th.TransportProtocol = UDPv4\n\t\t} else if len(sourceAddr.IP) == net.IPv6len {\n\t\t\th.TransportProtocol = UDPv6\n\t\t}\n\tcase *net.UnixAddr:\n\t\tif _, ok := destAddr.(*net.UnixAddr); !ok {\n\t\t\tbreak\n\t\t}\n\t\tswitch sourceAddr.Net {\n\t\tcase \"unix\":\n\t\t\th.TransportProtocol = UnixStream\n\t\tcase \"unixgram\":\n\t\t\th.TransportProtocol = UnixDatagram\n\t\t}\n\t}\n\tif h.TransportProtocol != UNSPEC {\n\t\th.Command = PROXY\n\t\th.SourceAddr = sourceAddr\n\t\th.DestinationAddr = destAddr\n\t}\n\treturn h\n}\n\nfunc (header *Header) TCPAddrs() (sourceAddr, destAddr *net.TCPAddr, ok bool) {\n\tif !header.TransportProtocol.IsStream() {\n\t\treturn nil, nil, false\n\t}\n\tsourceAddr, sourceOK := header.SourceAddr.(*net.TCPAddr)\n\tdestAddr, destOK := header.DestinationAddr.(*net.TCPAddr)\n\treturn sourceAddr, destAddr, sourceOK && destOK\n}\n\nfunc (header *Header) UDPAddrs() (sourceAddr, destAddr *net.UDPAddr, ok bool) {\n\tif !header.TransportProtocol.IsDatagram() {\n\t\treturn nil, nil, false\n\t}\n\tsourceAddr, sourceOK := header.SourceAddr.(*net.UDPAddr)\n\tdestAddr, destOK := header.DestinationAddr.(*net.UDPAddr)\n\treturn sourceAddr, destAddr, sourceOK && destOK\n}\n\nfunc (header *Header) UnixAddrs() (sourceAddr, destAddr *net.UnixAddr, ok bool) {\n\tif !header.TransportProtocol.IsUnix() {\n\t\treturn nil, nil, false\n\t}\n\tsourceAddr, sourceOK := header.SourceAddr.(*net.UnixAddr)\n\tdestAddr, destOK := header.DestinationAddr.(*net.UnixAddr)\n\treturn sourceAddr, destAddr, sourceOK && destOK\n}\n\nfunc (header *Header) IPs() (sourceIP, destIP net.IP, ok bool) {\n\tif sourceAddr, destAddr, ok := header.TCPAddrs(); ok {\n\t\treturn sourceAddr.IP, destAddr.IP, true\n\t} else if sourceAddr, destAddr, ok := header.UDPAddrs(); ok {\n\t\treturn sourceAddr.IP, destAddr.IP, true\n\t} else {\n\t\treturn nil, nil, false\n\t}\n}\n\nfunc (header *Header) Ports() (sourcePort, destPort int, ok bool) {\n\tif sourceAddr, destAddr, ok := header.TCPAddrs(); ok {\n\t\treturn sourceAddr.Port, destAddr.Port, true\n\t} else if sourceAddr, destAddr, ok := header.UDPAddrs(); ok {\n\t\treturn sourceAddr.Port, destAddr.Port, true\n\t} else {\n\t\treturn 0, 0, false\n\t}\n}\n\n// EqualTo returns true if headers are equivalent, false otherwise.\n// Deprecated: use EqualsTo instead. This method will eventually be removed.\nfunc (header *Header) EqualTo(otherHeader *Header) bool {\n\treturn header.EqualsTo(otherHeader)\n}\n\n// EqualsTo returns true if headers are equivalent, false otherwise.\nfunc (header *Header) EqualsTo(otherHeader *Header) bool {\n\tif otherHeader == nil {\n\t\treturn false\n\t}\n\t// TLVs only exist for version 2\n\tif header.Version == 2 && !bytes.Equal(header.rawTLVs, otherHeader.rawTLVs) {\n\t\treturn false\n\t}\n\tif header.Version != otherHeader.Version || header.Command != otherHeader.Command || header.TransportProtocol != otherHeader.TransportProtocol {\n\t\treturn false\n\t}\n\t// Return early for header with LOCAL command, which contains no address information\n\tif header.Command == LOCAL {\n\t\treturn true\n\t}\n\treturn header.SourceAddr.String() == otherHeader.SourceAddr.String() &&\n\t\theader.DestinationAddr.String() == otherHeader.DestinationAddr.String()\n}\n\n// WriteTo renders a proxy protocol header in a format and writes it to an io.Writer.\nfunc (header *Header) WriteTo(w io.Writer) (int64, error) {\n\tbuf, err := header.Format()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn bytes.NewBuffer(buf).WriteTo(w)\n}\n\n// Format renders a proxy protocol header in a format to write over the wire.\nfunc (header *Header) Format() ([]byte, error) {\n\tswitch header.Version {\n\tcase 1:\n\t\treturn header.formatVersion1()\n\tcase 2:\n\t\treturn header.formatVersion2()\n\tdefault:\n\t\treturn nil, ErrUnknownProxyProtocolVersion\n\t}\n}\n\n// TLVs returns the TLVs stored into this header, if they exist.  TLVs are optional for v2 of the protocol.\nfunc (header *Header) TLVs() ([]TLV, error) {\n\treturn SplitTLVs(header.rawTLVs)\n}\n\n// SetTLVs sets the TLVs stored in this header. This method replaces any\n// previous TLV.\nfunc (header *Header) SetTLVs(tlvs []TLV) error {\n\traw, err := JoinTLVs(tlvs)\n\tif err != nil {\n\t\treturn err\n\t}\n\theader.rawTLVs = raw\n\treturn nil\n}\n\n// Read identifies the proxy protocol version and reads the remaining of\n// the header, accordingly.\n//\n// If proxy protocol header signature is not present, the reader buffer remains untouched\n// and is safe for reading outside of this code.\n//\n// If proxy protocol header signature is present but an error is raised while processing\n// the remaining header, assume the reader buffer to be in a corrupt state.\n// Also, this operation will block until enough bytes are available for peeking.\nfunc Read(reader *bufio.Reader) (*Header, error) {\n\t// In order to improve speed for small non-PROXYed packets, take a peek at the first byte alone.\n\tb1, err := reader.Peek(1)\n\tif err != nil {\n\t\tif err == io.EOF {\n\t\t\treturn nil, ErrNoProxyProtocol\n\t\t}\n\t\treturn nil, err\n\t}\n\n\tif bytes.Equal(b1[:1], SIGV1[:1]) || bytes.Equal(b1[:1], SIGV2[:1]) {\n\t\tsignature, err := reader.Peek(5)\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\treturn nil, ErrNoProxyProtocol\n\t\t\t}\n\t\t\treturn nil, err\n\t\t}\n\t\tif bytes.Equal(signature[:5], SIGV1) {\n\t\t\treturn parseVersion1(reader)\n\t\t}\n\n\t\tsignature, err = reader.Peek(12)\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\treturn nil, ErrNoProxyProtocol\n\t\t\t}\n\t\t\treturn nil, err\n\t\t}\n\t\tif bytes.Equal(signature[:12], SIGV2) {\n\t\t\treturn parseVersion2(reader)\n\t\t}\n\t}\n\n\treturn nil, ErrNoProxyProtocol\n}\n\n// ReadTimeout acts as Read but takes a timeout. If that timeout is reached, it's assumed\n// there's no proxy protocol header.\nfunc ReadTimeout(reader *bufio.Reader, timeout time.Duration) (*Header, error) {\n\ttype header struct {\n\t\th *Header\n\t\te error\n\t}\n\tread := make(chan *header, 1)\n\n\tgo func() {\n\t\th := &header{}\n\t\th.h, h.e = Read(reader)\n\t\tread <- h\n\t}()\n\n\ttimer := time.NewTimer(timeout)\n\tselect {\n\tcase result := <-read:\n\t\ttimer.Stop()\n\t\treturn result.h, result.e\n\tcase <-timer.C:\n\t\treturn nil, ErrNoProxyProtocol\n\t}\n}\n", "package proxyproto\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"errors\"\n\t\"net\"\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n)\n\n// Stuff to be used in both versions tests.\n\nconst (\n\tNO_PROTOCOL   = \"There is no spoon\"\n\tIP4_ADDR      = \"127.0.0.1\"\n\tIP6_ADDR      = \"::1\"\n\tIP6_LONG_ADDR = \"1234:5678:9abc:def0:cafe:babe:dead:2bad\"\n\tPORT          = 65533\n\tINVALID_PORT  = 99999\n)\n\nvar (\n\tv4ip = net.ParseIP(IP4_ADDR).To4()\n\tv6ip = net.ParseIP(IP6_ADDR).To16()\n\n\tv4addr net.Addr = &net.TCPAddr{IP: v4ip, Port: PORT}\n\tv6addr net.Addr = &net.TCPAddr{IP: v6ip, Port: PORT}\n\n\tv4UDPAddr net.Addr = &net.UDPAddr{IP: v4ip, Port: PORT}\n\tv6UDPAddr net.Addr = &net.UDPAddr{IP: v6ip, Port: PORT}\n\n\tunixStreamAddr   net.Addr = &net.UnixAddr{Net: \"unix\", Name: \"socket\"}\n\tunixDatagramAddr net.Addr = &net.UnixAddr{Net: \"unixgram\", Name: \"socket\"}\n\n\terrReadIntentionallyBroken = errors.New(\"read is intentionally broken\")\n)\n\ntype timeoutReader []byte\n\nfunc (t *timeoutReader) Read([]byte) (int, error) {\n\ttime.Sleep(500 * time.Millisecond)\n\treturn 0, nil\n}\n\ntype errorReader []byte\n\nfunc (e *errorReader) Read([]byte) (int, error) {\n\treturn 0, errReadIntentionallyBroken\n}\n\nfunc TestReadTimeoutV1Invalid(t *testing.T) {\n\tvar b timeoutReader\n\treader := bufio.NewReader(&b)\n\t_, err := ReadTimeout(reader, 50*time.Millisecond)\n\tif err == nil {\n\t\tt.Fatalf(\"expected error %s\", ErrNoProxyProtocol)\n\t} else if err != ErrNoProxyProtocol {\n\t\tt.Fatalf(\"expected %s, actual %s\", ErrNoProxyProtocol, err)\n\t}\n}\n\nfunc TestReadTimeoutPropagatesReadError(t *testing.T) {\n\tvar e errorReader\n\treader := bufio.NewReader(&e)\n\t_, err := ReadTimeout(reader, 50*time.Millisecond)\n\n\tif err == nil {\n\t\tt.Fatalf(\"expected error %s\", errReadIntentionallyBroken)\n\t} else if err != errReadIntentionallyBroken {\n\t\tt.Fatalf(\"expected error %s, actual %s\", errReadIntentionallyBroken, err)\n\t}\n}\n\nfunc TestEqualsTo(t *testing.T) {\n\tvar headersEqual = []struct {\n\t\tthis, that *Header\n\t\texpected   bool\n\t}{\n\t\t{\n\t\t\t&Header{\n\t\t\t\tVersion:           1,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: TCPv4,\n\t\t\t\tSourceAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"10.1.1.1\"),\n\t\t\t\t\tPort: 1000,\n\t\t\t\t},\n\t\t\t\tDestinationAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"20.2.2.2\"),\n\t\t\t\t\tPort: 2000,\n\t\t\t\t},\n\t\t\t},\n\t\t\tnil,\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t&Header{\n\t\t\t\tVersion:           1,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: TCPv4,\n\t\t\t\tSourceAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"10.1.1.1\"),\n\t\t\t\t\tPort: 1000,\n\t\t\t\t},\n\t\t\t\tDestinationAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"20.2.2.2\"),\n\t\t\t\t\tPort: 2000,\n\t\t\t\t},\n\t\t\t},\n\t\t\t&Header{\n\t\t\t\tVersion:           2,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: TCPv4,\n\t\t\t\tSourceAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"10.1.1.1\"),\n\t\t\t\t\tPort: 1000,\n\t\t\t\t},\n\t\t\t\tDestinationAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"20.2.2.2\"),\n\t\t\t\t\tPort: 2000,\n\t\t\t\t},\n\t\t\t},\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t&Header{\n\t\t\t\tVersion:           1,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: TCPv4,\n\t\t\t\tSourceAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"10.1.1.1\"),\n\t\t\t\t\tPort: 1000,\n\t\t\t\t},\n\t\t\t\tDestinationAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"20.2.2.2\"),\n\t\t\t\t\tPort: 2000,\n\t\t\t\t},\n\t\t\t},\n\t\t\t&Header{\n\t\t\t\tVersion:           1,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: TCPv4,\n\t\t\t\tSourceAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"10.1.1.1\"),\n\t\t\t\t\tPort: 1000,\n\t\t\t\t},\n\t\t\t\tDestinationAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"20.2.2.2\"),\n\t\t\t\t\tPort: 2000,\n\t\t\t\t},\n\t\t\t},\n\t\t\ttrue,\n\t\t},\n\t}\n\n\tfor _, tt := range headersEqual {\n\t\tif actual := tt.this.EqualsTo(tt.that); actual != tt.expected {\n\t\t\tt.Fatalf(\"expected %t, actual %t\", tt.expected, actual)\n\t\t}\n\t}\n}\n\n// This is here just because of coveralls\nfunc TestEqualTo(t *testing.T) {\n\tTestEqualsTo(t)\n}\n\nfunc TestGetters(t *testing.T) {\n\tvar tests = []struct {\n\t\tname                         string\n\t\theader                       *Header\n\t\ttcpSourceAddr, tcpDestAddr   *net.TCPAddr\n\t\tudpSourceAddr, udpDestAddr   *net.UDPAddr\n\t\tunixSourceAddr, unixDestAddr *net.UnixAddr\n\t\tipSource, ipDest             net.IP\n\t\tportSource, portDest         int\n\t}{\n\t\t{\n\t\t\tname: \"TCPv4\",\n\t\t\theader: &Header{\n\t\t\t\tVersion:           1,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: TCPv4,\n\t\t\t\tSourceAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"10.1.1.1\"),\n\t\t\t\t\tPort: 1000,\n\t\t\t\t},\n\t\t\t\tDestinationAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"20.2.2.2\"),\n\t\t\t\t\tPort: 2000,\n\t\t\t\t},\n\t\t\t},\n\t\t\ttcpSourceAddr: &net.TCPAddr{\n\t\t\t\tIP:   net.ParseIP(\"10.1.1.1\"),\n\t\t\t\tPort: 1000,\n\t\t\t},\n\t\t\ttcpDestAddr: &net.TCPAddr{\n\t\t\t\tIP:   net.ParseIP(\"20.2.2.2\"),\n\t\t\t\tPort: 2000,\n\t\t\t},\n\t\t\tipSource:   net.ParseIP(\"10.1.1.1\"),\n\t\t\tipDest:     net.ParseIP(\"20.2.2.2\"),\n\t\t\tportSource: 1000,\n\t\t\tportDest:   2000,\n\t\t},\n\t\t{\n\t\t\tname: \"UDPv4\",\n\t\t\theader: &Header{\n\t\t\t\tVersion:           2,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: UDPv6,\n\t\t\t\tSourceAddr: &net.UDPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"10.1.1.1\"),\n\t\t\t\t\tPort: 1000,\n\t\t\t\t},\n\t\t\t\tDestinationAddr: &net.UDPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"20.2.2.2\"),\n\t\t\t\t\tPort: 2000,\n\t\t\t\t},\n\t\t\t},\n\t\t\tudpSourceAddr: &net.UDPAddr{\n\t\t\t\tIP:   net.ParseIP(\"10.1.1.1\"),\n\t\t\t\tPort: 1000,\n\t\t\t},\n\t\t\tudpDestAddr: &net.UDPAddr{\n\t\t\t\tIP:   net.ParseIP(\"20.2.2.2\"),\n\t\t\t\tPort: 2000,\n\t\t\t},\n\t\t\tipSource:   net.ParseIP(\"10.1.1.1\"),\n\t\t\tipDest:     net.ParseIP(\"20.2.2.2\"),\n\t\t\tportSource: 1000,\n\t\t\tportDest:   2000,\n\t\t},\n\t\t{\n\t\t\tname: \"UnixStream\",\n\t\t\theader: &Header{\n\t\t\t\tVersion:           2,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: UnixStream,\n\t\t\t\tSourceAddr: &net.UnixAddr{\n\t\t\t\t\tNet:  \"unix\",\n\t\t\t\t\tName: \"src\",\n\t\t\t\t},\n\t\t\t\tDestinationAddr: &net.UnixAddr{\n\t\t\t\t\tNet:  \"unix\",\n\t\t\t\t\tName: \"dst\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tunixSourceAddr: &net.UnixAddr{\n\t\t\t\tNet:  \"unix\",\n\t\t\t\tName: \"src\",\n\t\t\t},\n\t\t\tunixDestAddr: &net.UnixAddr{\n\t\t\t\tNet:  \"unix\",\n\t\t\t\tName: \"dst\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"UnixDatagram\",\n\t\t\theader: &Header{\n\t\t\t\tVersion:           2,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: UnixDatagram,\n\t\t\t\tSourceAddr: &net.UnixAddr{\n\t\t\t\t\tNet:  \"unix\",\n\t\t\t\t\tName: \"src\",\n\t\t\t\t},\n\t\t\t\tDestinationAddr: &net.UnixAddr{\n\t\t\t\t\tNet:  \"unix\",\n\t\t\t\t\tName: \"dst\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tunixSourceAddr: &net.UnixAddr{\n\t\t\t\tNet:  \"unix\",\n\t\t\t\tName: \"src\",\n\t\t\t},\n\t\t\tunixDestAddr: &net.UnixAddr{\n\t\t\t\tNet:  \"unix\",\n\t\t\t\tName: \"dst\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Unspec\",\n\t\t\theader: &Header{\n\t\t\t\tVersion:           1,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: UNSPEC,\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\ttcpSourceAddr, tcpDestAddr, _ := test.header.TCPAddrs()\n\t\t\tif test.tcpSourceAddr != nil && !reflect.DeepEqual(tcpSourceAddr, test.tcpSourceAddr) {\n\t\t\t\tt.Errorf(\"TCPAddrs() source = %v, want %v\", tcpSourceAddr, test.tcpSourceAddr)\n\t\t\t}\n\t\t\tif test.tcpDestAddr != nil && !reflect.DeepEqual(tcpDestAddr, test.tcpDestAddr) {\n\t\t\t\tt.Errorf(\"TCPAddrs() dest = %v, want %v\", tcpDestAddr, test.tcpDestAddr)\n\t\t\t}\n\n\t\t\tudpSourceAddr, udpDestAddr, _ := test.header.UDPAddrs()\n\t\t\tif test.udpSourceAddr != nil && !reflect.DeepEqual(udpSourceAddr, test.udpSourceAddr) {\n\t\t\t\tt.Errorf(\"TCPAddrs() source = %v, want %v\", udpSourceAddr, test.udpSourceAddr)\n\t\t\t}\n\t\t\tif test.udpDestAddr != nil && !reflect.DeepEqual(udpDestAddr, test.udpDestAddr) {\n\t\t\t\tt.Errorf(\"TCPAddrs() dest = %v, want %v\", udpDestAddr, test.udpDestAddr)\n\t\t\t}\n\n\t\t\tunixSourceAddr, unixDestAddr, _ := test.header.UnixAddrs()\n\t\t\tif test.unixSourceAddr != nil && !reflect.DeepEqual(unixSourceAddr, test.unixSourceAddr) {\n\t\t\t\tt.Errorf(\"UnixAddrs() source = %v, want %v\", unixSourceAddr, test.unixSourceAddr)\n\t\t\t}\n\t\t\tif test.unixDestAddr != nil && !reflect.DeepEqual(unixDestAddr, test.unixDestAddr) {\n\t\t\t\tt.Errorf(\"UnixAddrs() dest = %v, want %v\", unixDestAddr, test.unixDestAddr)\n\t\t\t}\n\n\t\t\tipSource, ipDest, _ := test.header.IPs()\n\t\t\tif test.ipSource != nil && !ipSource.Equal(test.ipSource) {\n\t\t\t\tt.Errorf(\"IPs() source = %v, want %v\", ipSource, test.ipSource)\n\t\t\t}\n\t\t\tif test.ipDest != nil && !ipDest.Equal(test.ipDest) {\n\t\t\t\tt.Errorf(\"IPs() dest = %v, want %v\", ipDest, test.ipDest)\n\t\t\t}\n\n\t\t\tportSource, portDest, _ := test.header.Ports()\n\t\t\tif test.portSource != 0 && portSource != test.portSource {\n\t\t\t\tt.Errorf(\"Ports() source = %v, want %v\", portSource, test.portSource)\n\t\t\t}\n\t\t\tif test.portDest != 0 && portDest != test.portDest {\n\t\t\t\tt.Errorf(\"Ports() dest = %v, want %v\", portDest, test.portDest)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSetTLVs(t *testing.T) {\n\ttests := []struct {\n\t\theader    *Header\n\t\tname      string\n\t\ttlvs      []TLV\n\t\texpectErr bool\n\t}{\n\t\t{\n\t\t\tname: \"add authority TLV\",\n\t\t\theader: &Header{\n\t\t\t\tVersion:           1,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: TCPv4,\n\t\t\t\tSourceAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"10.1.1.1\"),\n\t\t\t\t\tPort: 1000,\n\t\t\t\t},\n\t\t\t\tDestinationAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"20.2.2.2\"),\n\t\t\t\t\tPort: 2000,\n\t\t\t\t},\n\t\t\t},\n\t\t\ttlvs: []TLV{{\n\t\t\t\tType:  PP2_TYPE_AUTHORITY,\n\t\t\t\tValue: []byte(\"example.org\"),\n\t\t\t}},\n\t\t},\n\t\t{\n\t\t\tname: \"add too long TLV\",\n\t\t\theader: &Header{\n\t\t\t\tVersion:           1,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: TCPv4,\n\t\t\t\tSourceAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"10.1.1.1\"),\n\t\t\t\t\tPort: 1000,\n\t\t\t\t},\n\t\t\t\tDestinationAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"20.2.2.2\"),\n\t\t\t\t\tPort: 2000,\n\t\t\t\t},\n\t\t\t},\n\t\t\ttlvs: []TLV{{\n\t\t\t\tType:  PP2_TYPE_AUTHORITY,\n\t\t\t\tValue: append(bytes.Repeat([]byte(\"a\"), 0xFFFF), []byte(\".example.org\")...),\n\t\t\t}},\n\t\t\texpectErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\terr := tt.header.SetTLVs(tt.tlvs)\n\t\tif err != nil && !tt.expectErr {\n\t\t\tt.Fatalf(\"shouldn't have thrown error %q\", err.Error())\n\t\t}\n\t}\n}\n\nfunc TestWriteTo(t *testing.T) {\n\tvar buf bytes.Buffer\n\n\tvalidHeader := &Header{\n\t\tVersion:           1,\n\t\tCommand:           PROXY,\n\t\tTransportProtocol: TCPv4,\n\t\tSourceAddr: &net.TCPAddr{\n\t\t\tIP:   net.ParseIP(\"10.1.1.1\"),\n\t\t\tPort: 1000,\n\t\t},\n\t\tDestinationAddr: &net.TCPAddr{\n\t\t\tIP:   net.ParseIP(\"20.2.2.2\"),\n\t\t\tPort: 2000,\n\t\t},\n\t}\n\n\tif _, err := validHeader.WriteTo(&buf); err != nil {\n\t\tt.Fatalf(\"shouldn't have thrown error %q\", err.Error())\n\t}\n\n\tinvalidHeader := &Header{\n\t\tSourceAddr: &net.TCPAddr{\n\t\t\tIP:   net.ParseIP(\"10.1.1.1\"),\n\t\t\tPort: 1000,\n\t\t},\n\t\tDestinationAddr: &net.TCPAddr{\n\t\t\tIP:   net.ParseIP(\"20.2.2.2\"),\n\t\t\tPort: 2000,\n\t\t},\n\t}\n\n\tif _, err := invalidHeader.WriteTo(&buf); err == nil {\n\t\tt.Fatalf(\"should have thrown error %q\", err.Error())\n\t}\n}\n\nfunc TestFormat(t *testing.T) {\n\tvalidHeader := &Header{\n\t\tVersion:           1,\n\t\tCommand:           PROXY,\n\t\tTransportProtocol: TCPv4,\n\t\tSourceAddr: &net.TCPAddr{\n\t\t\tIP:   net.ParseIP(\"10.1.1.1\"),\n\t\t\tPort: 1000,\n\t\t},\n\t\tDestinationAddr: &net.TCPAddr{\n\t\t\tIP:   net.ParseIP(\"20.2.2.2\"),\n\t\t\tPort: 2000,\n\t\t},\n\t}\n\n\tif _, err := validHeader.Format(); err != nil {\n\t\tt.Fatalf(\"shouldn't have thrown error %q\", err.Error())\n\t}\n}\n\nfunc TestFormatInvalid(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\theader *Header\n\t\terr    error\n\t}{\n\t\t{\n\t\t\tname: \"invalidVersion\",\n\t\t\theader: &Header{\n\t\t\t\tVersion:           3,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: TCPv4,\n\t\t\t\tSourceAddr:        v4addr,\n\t\t\t\tDestinationAddr:   v4addr,\n\t\t\t},\n\t\t\terr: ErrUnknownProxyProtocolVersion,\n\t\t},\n\t\t{\n\t\t\tname: \"v2MismatchTCPv4_UDPv4\",\n\t\t\theader: &Header{\n\t\t\t\tVersion:           2,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: TCPv4,\n\t\t\t\tSourceAddr:        v4UDPAddr,\n\t\t\t\tDestinationAddr:   v4addr,\n\t\t\t},\n\t\t\terr: ErrInvalidAddress,\n\t\t},\n\t\t{\n\t\t\tname: \"v2MismatchTCPv4_TCPv6\",\n\t\t\theader: &Header{\n\t\t\t\tVersion:           2,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: TCPv4,\n\t\t\t\tSourceAddr:        v4addr,\n\t\t\t\tDestinationAddr:   v6addr,\n\t\t\t},\n\t\t\terr: ErrInvalidAddress,\n\t\t},\n\t\t{\n\t\t\tname: \"v2MismatchUnixStream_TCPv4\",\n\t\t\theader: &Header{\n\t\t\t\tVersion:           2,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: UnixStream,\n\t\t\t\tSourceAddr:        v4addr,\n\t\t\t\tDestinationAddr:   unixStreamAddr,\n\t\t\t},\n\t\t\terr: ErrInvalidAddress,\n\t\t},\n\t\t{\n\t\t\tname: \"v1MismatchTCPv4_TCPv6\",\n\t\t\theader: &Header{\n\t\t\t\tVersion:           1,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: TCPv4,\n\t\t\t\tSourceAddr:        v6addr,\n\t\t\t\tDestinationAddr:   v4addr,\n\t\t\t},\n\t\t\terr: ErrInvalidAddress,\n\t\t},\n\t\t{\n\t\t\tname: \"v1MismatchTCPv4_UDPv4\",\n\t\t\theader: &Header{\n\t\t\t\tVersion:           1,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: TCPv4,\n\t\t\t\tSourceAddr:        v4UDPAddr,\n\t\t\t\tDestinationAddr:   v4addr,\n\t\t\t},\n\t\t\terr: ErrInvalidAddress,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tif _, err := test.header.Format(); err == nil {\n\t\t\t\tt.Errorf(\"Header.Format() succeeded, want an error\")\n\t\t\t} else if err != test.err {\n\t\t\t\tt.Errorf(\"Header.Format() = %q, want %q\", err, test.err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestHeaderProxyFromAddrs(t *testing.T) {\n\tunspec := &Header{\n\t\tVersion:           2,\n\t\tCommand:           LOCAL,\n\t\tTransportProtocol: UNSPEC,\n\t}\n\n\ttests := []struct {\n\t\tname                 string\n\t\tversion              byte\n\t\tsourceAddr, destAddr net.Addr\n\t\texpected             *Header\n\t}{\n\t\t{\n\t\t\tname: \"TCPv4\",\n\t\t\tsourceAddr: &net.TCPAddr{\n\t\t\t\tIP:   net.ParseIP(\"10.1.1.1\"),\n\t\t\t\tPort: 1000,\n\t\t\t},\n\t\t\tdestAddr: &net.TCPAddr{\n\t\t\t\tIP:   net.ParseIP(\"20.2.2.2\"),\n\t\t\t\tPort: 2000,\n\t\t\t},\n\t\t\texpected: &Header{\n\t\t\t\tVersion:           2,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: TCPv4,\n\t\t\t\tSourceAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"10.1.1.1\"),\n\t\t\t\t\tPort: 1000,\n\t\t\t\t},\n\t\t\t\tDestinationAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"20.2.2.2\"),\n\t\t\t\t\tPort: 2000,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"TCPv6\",\n\t\t\tsourceAddr: &net.TCPAddr{\n\t\t\t\tIP:   net.ParseIP(\"fde7::372\"),\n\t\t\t\tPort: 1000,\n\t\t\t},\n\t\t\tdestAddr: &net.TCPAddr{\n\t\t\t\tIP:   net.ParseIP(\"fde7::1\"),\n\t\t\t\tPort: 2000,\n\t\t\t},\n\t\t\texpected: &Header{\n\t\t\t\tVersion:           2,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: TCPv6,\n\t\t\t\tSourceAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"fde7::372\"),\n\t\t\t\t\tPort: 1000,\n\t\t\t\t},\n\t\t\t\tDestinationAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"fde7::1\"),\n\t\t\t\t\tPort: 2000,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"UDPv4\",\n\t\t\tsourceAddr: &net.UDPAddr{\n\t\t\t\tIP:   net.ParseIP(\"10.1.1.1\"),\n\t\t\t\tPort: 1000,\n\t\t\t},\n\t\t\tdestAddr: &net.UDPAddr{\n\t\t\t\tIP:   net.ParseIP(\"20.2.2.2\"),\n\t\t\t\tPort: 2000,\n\t\t\t},\n\t\t\texpected: &Header{\n\t\t\t\tVersion:           2,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: UDPv4,\n\t\t\t\tSourceAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"10.1.1.1\"),\n\t\t\t\t\tPort: 1000,\n\t\t\t\t},\n\t\t\t\tDestinationAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"20.2.2.2\"),\n\t\t\t\t\tPort: 2000,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"UDPv6\",\n\t\t\tsourceAddr: &net.UDPAddr{\n\t\t\t\tIP:   net.ParseIP(\"fde7::372\"),\n\t\t\t\tPort: 1000,\n\t\t\t},\n\t\t\tdestAddr: &net.UDPAddr{\n\t\t\t\tIP:   net.ParseIP(\"fde7::1\"),\n\t\t\t\tPort: 2000,\n\t\t\t},\n\t\t\texpected: &Header{\n\t\t\t\tVersion:           2,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: UDPv6,\n\t\t\t\tSourceAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"fde7::372\"),\n\t\t\t\t\tPort: 1000,\n\t\t\t\t},\n\t\t\t\tDestinationAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"fde7::1\"),\n\t\t\t\t\tPort: 2000,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"UnixStream\",\n\t\t\tsourceAddr: &net.UnixAddr{\n\t\t\t\tNet:  \"unix\",\n\t\t\t\tName: \"src\",\n\t\t\t},\n\t\t\tdestAddr: &net.UnixAddr{\n\t\t\t\tNet:  \"unix\",\n\t\t\t\tName: \"dst\",\n\t\t\t},\n\t\t\texpected: &Header{\n\t\t\t\tVersion:           2,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: UnixStream,\n\t\t\t\tSourceAddr: &net.UnixAddr{\n\t\t\t\t\tNet:  \"unix\",\n\t\t\t\t\tName: \"src\",\n\t\t\t\t},\n\t\t\t\tDestinationAddr: &net.UnixAddr{\n\t\t\t\t\tNet:  \"unix\",\n\t\t\t\t\tName: \"dst\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"UnixDatagram\",\n\t\t\tsourceAddr: &net.UnixAddr{\n\t\t\t\tNet:  \"unixgram\",\n\t\t\t\tName: \"src\",\n\t\t\t},\n\t\t\tdestAddr: &net.UnixAddr{\n\t\t\t\tNet:  \"unixgram\",\n\t\t\t\tName: \"dst\",\n\t\t\t},\n\t\t\texpected: &Header{\n\t\t\t\tVersion:           2,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: UnixDatagram,\n\t\t\t\tSourceAddr: &net.UnixAddr{\n\t\t\t\t\tNet:  \"unixgram\",\n\t\t\t\t\tName: \"src\",\n\t\t\t\t},\n\t\t\t\tDestinationAddr: &net.UnixAddr{\n\t\t\t\t\tNet:  \"unixgram\",\n\t\t\t\t\tName: \"dst\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:    \"Version1\",\n\t\t\tversion: 1,\n\t\t\tsourceAddr: &net.TCPAddr{\n\t\t\t\tIP:   net.ParseIP(\"10.1.1.1\"),\n\t\t\t\tPort: 1000,\n\t\t\t},\n\t\t\tdestAddr: &net.TCPAddr{\n\t\t\t\tIP:   net.ParseIP(\"20.2.2.2\"),\n\t\t\t\tPort: 2000,\n\t\t\t},\n\t\t\texpected: &Header{\n\t\t\t\tVersion:           1,\n\t\t\t\tCommand:           PROXY,\n\t\t\t\tTransportProtocol: TCPv4,\n\t\t\t\tSourceAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"10.1.1.1\"),\n\t\t\t\t\tPort: 1000,\n\t\t\t\t},\n\t\t\t\tDestinationAddr: &net.TCPAddr{\n\t\t\t\t\tIP:   net.ParseIP(\"20.2.2.2\"),\n\t\t\t\t\tPort: 2000,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"TCPInvalidIP\",\n\t\t\tsourceAddr: &net.TCPAddr{\n\t\t\t\tIP:   nil,\n\t\t\t\tPort: 1000,\n\t\t\t},\n\t\t\tdestAddr: &net.TCPAddr{\n\t\t\t\tIP:   nil,\n\t\t\t\tPort: 2000,\n\t\t\t},\n\t\t\texpected: unspec,\n\t\t},\n\t\t{\n\t\t\tname: \"UDPInvalidIP\",\n\t\t\tsourceAddr: &net.UDPAddr{\n\t\t\t\tIP:   nil,\n\t\t\t\tPort: 1000,\n\t\t\t},\n\t\t\tdestAddr: &net.UDPAddr{\n\t\t\t\tIP:   nil,\n\t\t\t\tPort: 2000,\n\t\t\t},\n\t\t\texpected: unspec,\n\t\t},\n\t\t{\n\t\t\tname: \"TCPAddrTypeMismatch\",\n\t\t\tsourceAddr: &net.TCPAddr{\n\t\t\t\tIP:   net.ParseIP(\"10.1.1.1\"),\n\t\t\t\tPort: 1000,\n\t\t\t},\n\t\t\tdestAddr: &net.UDPAddr{\n\t\t\t\tIP:   net.ParseIP(\"20.2.2.2\"),\n\t\t\t\tPort: 2000,\n\t\t\t},\n\t\t\texpected: unspec,\n\t\t},\n\t\t{\n\t\t\tname: \"UDPAddrTypeMismatch\",\n\t\t\tsourceAddr: &net.UDPAddr{\n\t\t\t\tIP:   net.ParseIP(\"10.1.1.1\"),\n\t\t\t\tPort: 1000,\n\t\t\t},\n\t\t\tdestAddr: &net.TCPAddr{\n\t\t\t\tIP:   net.ParseIP(\"20.2.2.2\"),\n\t\t\t\tPort: 2000,\n\t\t\t},\n\t\t\texpected: unspec,\n\t\t},\n\t\t{\n\t\t\tname: \"UnixAddrTypeMismatch\",\n\t\t\tsourceAddr: &net.UnixAddr{\n\t\t\t\tNet: \"unix\",\n\t\t\t},\n\t\t\tdestAddr: &net.TCPAddr{\n\t\t\t\tIP:   net.ParseIP(\"20.2.2.2\"),\n\t\t\t\tPort: 2000,\n\t\t\t},\n\t\t\texpected: unspec,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\th := HeaderProxyFromAddrs(tt.version, tt.sourceAddr, tt.destAddr)\n\n\t\t\tif !h.EqualsTo(tt.expected) {\n\t\t\t\tt.Errorf(\"expected %+v, actual %+v for source %+v and destination %+v\", tt.expected, h, tt.sourceAddr, tt.destAddr)\n\t\t\t}\n\t\t})\n\t}\n}\n", "package proxyproto\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"fmt\"\n\t\"net\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nconst (\n\tcrlf      = \"\\r\\n\"\n\tseparator = \" \"\n)\n\nfunc initVersion1() *Header {\n\theader := new(Header)\n\theader.Version = 1\n\t// Command doesn't exist in v1\n\theader.Command = PROXY\n\treturn header\n}\n\nfunc parseVersion1(reader *bufio.Reader) (*Header, error) {\n\t//The header cannot be more than 107 bytes long. Per spec:\n\t//\n\t//   (...)\n\t//   - worst case (optional fields set to 0xff) :\n\t//     \"PROXY UNKNOWN ffff:f...f:ffff ffff:f...f:ffff 65535 65535\\r\\n\"\n\t//     => 5 + 1 + 7 + 1 + 39 + 1 + 39 + 1 + 5 + 1 + 5 + 2 = 107 chars\n\t//\n\t//   So a 108-byte buffer is always enough to store all the line and a\n\t//   trailing zero for string processing.\n\t//\n\t// It must also be CRLF terminated, as above. The header does not otherwise\n\t// contain a CR or LF byte.\n\t//\n\t// ISSUE #69\n\t// We can't use Peek here as it will block trying to fill the buffer, which\n\t// will never happen if the header is TCP4 or TCP6 (max. 56 and 104 bytes\n\t// respectively) and the server is expected to speak first.\n\t//\n\t// Similarly, we can't use ReadString or ReadBytes as these will keep reading\n\t// until the delimiter is found; an abusive client could easily disrupt a\n\t// server by sending a large amount of data that do not contain a LF byte.\n\t// Another means of attack would be to start connections and simply not send\n\t// data after the initial PROXY signature bytes, accumulating a large\n\t// number of blocked goroutines on the server. ReadSlice will also block for\n\t// a delimiter when the internal buffer does not fill up.\n\t//\n\t// A plain Read is also problematic since we risk reading past the end of the\n\t// header without being able to easily put the excess bytes back into the reader's\n\t// buffer (with the current implementation's design).\n\t//\n\t// So we use a ReadByte loop, which solves the overflow problem and avoids\n\t// reading beyond the end of the header. However, we need one more trick to harden\n\t// against partial header attacks (slow loris) - per spec:\n\t//\n\t//    (..) The sender must always ensure that the header is sent at once, so that\n\t//    the transport layer maintains atomicity along the path to the receiver. The\n\t//    receiver may be tolerant to partial headers or may simply drop the connection\n\t//    when receiving a partial header. Recommendation is to be tolerant, but\n\t//    implementation constraints may not always easily permit this.\n\t//\n\t// We are subject to such implementation constraints. So we return an error if\n\t// the header cannot be fully extracted with a single read of the underlying\n\t// reader.\n\tbuf := make([]byte, 0, 107)\n\tfor {\n\t\tb, err := reader.ReadByte()\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(ErrCantReadVersion1Header.Error()+\": %v\", err)\n\t\t}\n\t\tbuf = append(buf, b)\n\t\tif b == '\\n' {\n\t\t\t// End of header found\n\t\t\tbreak\n\t\t}\n\t\tif len(buf) == 107 {\n\t\t\t// No delimiter in first 107 bytes\n\t\t\treturn nil, ErrVersion1HeaderTooLong\n\t\t}\n\t\tif reader.Buffered() == 0 {\n\t\t\t// Header was not buffered in a single read. Since we can't\n\t\t\t// differentiate between genuine slow writers and DoS agents,\n\t\t\t// we abort. On healthy networks, this should never happen.\n\t\t\treturn nil, ErrCantReadVersion1Header\n\t\t}\n\t}\n\n\t// Check for CR before LF.\n\tif len(buf) < 2 || buf[len(buf)-2] != '\\r' {\n\t\treturn nil, ErrLineMustEndWithCrlf\n\t}\n\n\t// Check full signature.\n\ttokens := strings.Split(string(buf[:len(buf)-2]), separator)\n\n\t// Expect at least 2 tokens: \"PROXY\" and the transport protocol.\n\tif len(tokens) < 2 {\n\t\treturn nil, ErrCantReadAddressFamilyAndProtocol\n\t}\n\n\t// Read address family and protocol\n\tvar transportProtocol AddressFamilyAndProtocol\n\tswitch tokens[1] {\n\tcase \"TCP4\":\n\t\ttransportProtocol = TCPv4\n\tcase \"TCP6\":\n\t\ttransportProtocol = TCPv6\n\tcase \"UNKNOWN\":\n\t\ttransportProtocol = UNSPEC // doesn't exist in v1 but fits UNKNOWN\n\tdefault:\n\t\treturn nil, ErrCantReadAddressFamilyAndProtocol\n\t}\n\n\t// Expect 6 tokens only when UNKNOWN is not present.\n\tif transportProtocol != UNSPEC && len(tokens) < 6 {\n\t\treturn nil, ErrCantReadAddressFamilyAndProtocol\n\t}\n\n\t// When a signature is found, allocate a v1 header with Command set to PROXY.\n\t// Command doesn't exist in v1 but set it for other parts of this library\n\t// to rely on it for determining connection details.\n\theader := initVersion1()\n\n\t// Transport protocol has been processed already.\n\theader.TransportProtocol = transportProtocol\n\n\t// When UNKNOWN, set the command to LOCAL and return early\n\tif header.TransportProtocol == UNSPEC {\n\t\theader.Command = LOCAL\n\t\treturn header, nil\n\t}\n\n\t// Otherwise, continue to read addresses and ports\n\tsourceIP, err := parseV1IPAddress(header.TransportProtocol, tokens[2])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdestIP, err := parseV1IPAddress(header.TransportProtocol, tokens[3])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tsourcePort, err := parseV1PortNumber(tokens[4])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdestPort, err := parseV1PortNumber(tokens[5])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\theader.SourceAddr = &net.TCPAddr{\n\t\tIP:   sourceIP,\n\t\tPort: sourcePort,\n\t}\n\theader.DestinationAddr = &net.TCPAddr{\n\t\tIP:   destIP,\n\t\tPort: destPort,\n\t}\n\n\treturn header, nil\n}\n\nfunc (header *Header) formatVersion1() ([]byte, error) {\n\t// As of version 1, only \"TCP4\" ( \\x54 \\x43 \\x50 \\x34 ) for TCP over IPv4,\n\t// and \"TCP6\" ( \\x54 \\x43 \\x50 \\x36 ) for TCP over IPv6 are allowed.\n\tvar proto string\n\tswitch header.TransportProtocol {\n\tcase TCPv4:\n\t\tproto = \"TCP4\"\n\tcase TCPv6:\n\t\tproto = \"TCP6\"\n\tdefault:\n\t\t// Unknown connection (short form)\n\t\treturn []byte(\"PROXY UNKNOWN\" + crlf), nil\n\t}\n\n\tsourceAddr, sourceOK := header.SourceAddr.(*net.TCPAddr)\n\tdestAddr, destOK := header.DestinationAddr.(*net.TCPAddr)\n\tif !sourceOK || !destOK {\n\t\treturn nil, ErrInvalidAddress\n\t}\n\n\tsourceIP, destIP := sourceAddr.IP, destAddr.IP\n\tswitch header.TransportProtocol {\n\tcase TCPv4:\n\t\tsourceIP = sourceIP.To4()\n\t\tdestIP = destIP.To4()\n\tcase TCPv6:\n\t\tsourceIP = sourceIP.To16()\n\t\tdestIP = destIP.To16()\n\t}\n\tif sourceIP == nil || destIP == nil {\n\t\treturn nil, ErrInvalidAddress\n\t}\n\n\tbuf := bytes.NewBuffer(make([]byte, 0, 108))\n\tbuf.Write(SIGV1)\n\tbuf.WriteString(separator)\n\tbuf.WriteString(proto)\n\tbuf.WriteString(separator)\n\tbuf.WriteString(sourceIP.String())\n\tbuf.WriteString(separator)\n\tbuf.WriteString(destIP.String())\n\tbuf.WriteString(separator)\n\tbuf.WriteString(strconv.Itoa(sourceAddr.Port))\n\tbuf.WriteString(separator)\n\tbuf.WriteString(strconv.Itoa(destAddr.Port))\n\tbuf.WriteString(crlf)\n\n\treturn buf.Bytes(), nil\n}\n\nfunc parseV1PortNumber(portStr string) (int, error) {\n\tport, err := strconv.Atoi(portStr)\n\tif err != nil || port < 0 || port > 65535 {\n\t\treturn 0, ErrInvalidPortNumber\n\t}\n\treturn port, nil\n}\n\nfunc parseV1IPAddress(protocol AddressFamilyAndProtocol, addrStr string) (addr net.IP, err error) {\n\taddr = net.ParseIP(addrStr)\n\ttryV4 := addr.To4()\n\tif (protocol == TCPv4 && tryV4 == nil) || (protocol == TCPv6 && tryV4 != nil) {\n\t\terr = ErrInvalidAddress\n\t}\n\treturn\n}\n", "package proxyproto\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"io\"\n\t\"net\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\nvar (\n\tIPv4AddressesAndPorts        = strings.Join([]string{IP4_ADDR, IP4_ADDR, strconv.Itoa(PORT), strconv.Itoa(PORT)}, separator)\n\tIPv4AddressesAndInvalidPorts = strings.Join([]string{IP4_ADDR, IP4_ADDR, strconv.Itoa(INVALID_PORT), strconv.Itoa(INVALID_PORT)}, separator)\n\tIPv6AddressesAndPorts        = strings.Join([]string{IP6_ADDR, IP6_ADDR, strconv.Itoa(PORT), strconv.Itoa(PORT)}, separator)\n\tIPv6LongAddressesAndPorts    = strings.Join([]string{IP6_LONG_ADDR, IP6_LONG_ADDR, strconv.Itoa(PORT), strconv.Itoa(PORT)}, separator)\n\n\tfixtureTCP4V1 = \"PROXY TCP4 \" + IPv4AddressesAndPorts + crlf + \"GET /\"\n\tfixtureTCP6V1 = \"PROXY TCP6 \" + IPv6AddressesAndPorts + crlf + \"GET /\"\n\n\tfixtureTCP6V1Overflow = \"PROXY TCP6 \" + IPv6LongAddressesAndPorts\n\n\tfixtureUnknown              = \"PROXY UNKNOWN\" + crlf\n\tfixtureUnknownWithAddresses = \"PROXY UNKNOWN \" + IPv4AddressesAndInvalidPorts + crlf\n)\n\nvar invalidParseV1Tests = []struct {\n\tdesc          string\n\treader        *bufio.Reader\n\texpectedError error\n}{\n\t{\n\t\tdesc:          \"no signature\",\n\t\treader:        newBufioReader([]byte(NO_PROTOCOL)),\n\t\texpectedError: ErrNoProxyProtocol,\n\t},\n\t{\n\t\tdesc:          \"prox\",\n\t\treader:        newBufioReader([]byte(\"PROX\")),\n\t\texpectedError: ErrNoProxyProtocol,\n\t},\n\t{\n\t\tdesc:          \"proxy lf\",\n\t\treader:        newBufioReader([]byte(\"PROXY \\n\")),\n\t\texpectedError: ErrLineMustEndWithCrlf,\n\t},\n\t{\n\t\tdesc:          \"proxy crlf\",\n\t\treader:        newBufioReader([]byte(\"PROXY \" + crlf)),\n\t\texpectedError: ErrCantReadAddressFamilyAndProtocol,\n\t},\n\t{\n\t\tdesc:          \"proxy no space crlf\",\n\t\treader:        newBufioReader([]byte(\"PROXY\" + crlf)),\n\t\texpectedError: ErrCantReadAddressFamilyAndProtocol,\n\t},\n\t{\n\t\tdesc:          \"proxy something crlf\",\n\t\treader:        newBufioReader([]byte(\"PROXY SOMETHING\" + crlf)),\n\t\texpectedError: ErrCantReadAddressFamilyAndProtocol,\n\t},\n\t{\n\t\tdesc:          \"incomplete signature TCP4\",\n\t\treader:        newBufioReader([]byte(\"PROXY TCP4 \" + IPv4AddressesAndPorts)),\n\t\texpectedError: ErrCantReadVersion1Header,\n\t},\n\t{\n\t\tdesc:          \"TCP6 with IPv4 addresses\",\n\t\treader:        newBufioReader([]byte(\"PROXY TCP6 \" + IPv4AddressesAndPorts + crlf)),\n\t\texpectedError: ErrInvalidAddress,\n\t},\n\t{\n\t\tdesc:          \"TCP4 with IPv6 addresses\",\n\t\treader:        newBufioReader([]byte(\"PROXY TCP4 \" + IPv6AddressesAndPorts + crlf)),\n\t\texpectedError: ErrInvalidAddress,\n\t},\n\t{\n\t\tdesc:          \"TCP4 with invalid port\",\n\t\treader:        newBufioReader([]byte(\"PROXY TCP4 \" + IPv4AddressesAndInvalidPorts + crlf)),\n\t\texpectedError: ErrInvalidPortNumber,\n\t},\n\t{\n\t\tdesc:          \"header too long\",\n\t\treader:        newBufioReader([]byte(\"PROXY UNKNOWN \" + IPv6LongAddressesAndPorts + \" \" + crlf)),\n\t\texpectedError: ErrVersion1HeaderTooLong,\n\t},\n}\n\nfunc TestReadV1Invalid(t *testing.T) {\n\tfor _, tt := range invalidParseV1Tests {\n\t\tt.Run(tt.desc, func(t *testing.T) {\n\t\t\tif _, err := Read(tt.reader); err != tt.expectedError {\n\t\t\t\tt.Fatalf(\"expected %s, actual %v\", tt.expectedError, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nvar validParseAndWriteV1Tests = []struct {\n\tdesc           string\n\treader         *bufio.Reader\n\texpectedHeader *Header\n}{\n\t{\n\t\tdesc:   \"TCP4\",\n\t\treader: bufio.NewReader(strings.NewReader(fixtureTCP4V1)),\n\t\texpectedHeader: &Header{\n\t\t\tVersion:           1,\n\t\t\tCommand:           PROXY,\n\t\t\tTransportProtocol: TCPv4,\n\t\t\tSourceAddr:        v4addr,\n\t\t\tDestinationAddr:   v4addr,\n\t\t},\n\t},\n\t{\n\t\tdesc:   \"TCP6\",\n\t\treader: bufio.NewReader(strings.NewReader(fixtureTCP6V1)),\n\t\texpectedHeader: &Header{\n\t\t\tVersion:           1,\n\t\t\tCommand:           PROXY,\n\t\t\tTransportProtocol: TCPv6,\n\t\t\tSourceAddr:        v6addr,\n\t\t\tDestinationAddr:   v6addr,\n\t\t},\n\t},\n\t{\n\t\tdesc:   \"unknown\",\n\t\treader: bufio.NewReader(strings.NewReader(fixtureUnknown)),\n\t\texpectedHeader: &Header{\n\t\t\tVersion:           1,\n\t\t\tCommand:           LOCAL,\n\t\t\tTransportProtocol: UNSPEC,\n\t\t\tSourceAddr:        nil,\n\t\t\tDestinationAddr:   nil,\n\t\t},\n\t},\n\t{\n\t\tdesc:   \"unknown with addresses and ports\",\n\t\treader: bufio.NewReader(strings.NewReader(fixtureUnknownWithAddresses)),\n\t\texpectedHeader: &Header{\n\t\t\tVersion:           1,\n\t\t\tCommand:           LOCAL,\n\t\t\tTransportProtocol: UNSPEC,\n\t\t\tSourceAddr:        nil,\n\t\t\tDestinationAddr:   nil,\n\t\t},\n\t},\n}\n\nfunc TestParseV1Valid(t *testing.T) {\n\tfor _, tt := range validParseAndWriteV1Tests {\n\t\tt.Run(tt.desc, func(t *testing.T) {\n\t\t\theader, err := Read(tt.reader)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(\"unexpected error\", err.Error())\n\t\t\t}\n\t\t\tif !header.EqualsTo(tt.expectedHeader) {\n\t\t\t\tt.Fatalf(\"expected %#v, actual %#v\", tt.expectedHeader, header)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestWriteV1Valid(t *testing.T) {\n\tfor _, tt := range validParseAndWriteV1Tests {\n\t\tt.Run(tt.desc, func(t *testing.T) {\n\t\t\tvar b bytes.Buffer\n\t\t\tw := bufio.NewWriter(&b)\n\t\t\tif _, err := tt.expectedHeader.WriteTo(w); err != nil {\n\t\t\t\tt.Fatal(\"unexpected error \", err)\n\t\t\t}\n\t\t\tw.Flush()\n\n\t\t\t// Read written bytes to validate written header\n\t\t\tr := bufio.NewReader(&b)\n\t\t\tnewHeader, err := Read(r)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(\"unexpected error \", err)\n\t\t\t}\n\n\t\t\tif !newHeader.EqualsTo(tt.expectedHeader) {\n\t\t\t\tt.Fatalf(\"expected %#v, actual %#v\", tt.expectedHeader, newHeader)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Tests for parseVersion1 overflow - issue #69.\n\ntype dataSource struct {\n\tNBytes int\n\tNRead  int\n}\n\nfunc (ds *dataSource) Read(b []byte) (int, error) {\n\tif ds.NRead >= ds.NBytes {\n\t\treturn 0, io.EOF\n\t}\n\tavail := ds.NBytes - ds.NRead\n\tif len(b) < avail {\n\t\tavail = len(b)\n\t}\n\tfor i := 0; i < avail; i++ {\n\t\tb[i] = 0x20\n\t}\n\tds.NRead += avail\n\treturn avail, nil\n}\n\nfunc TestParseVersion1Overflow(t *testing.T) {\n\tds := &dataSource{}\n\treader := bufio.NewReader(ds)\n\tbufSize := reader.Size()\n\tds.NBytes = bufSize * 16\n\tparseVersion1(reader)\n\tif ds.NRead > bufSize {\n\t\tt.Fatalf(\"read: expected max %d bytes, actual %d\\n\", bufSize, ds.NRead)\n\t}\n}\n\nfunc listen(t *testing.T) *Listener {\n\tl, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n\tif err != nil {\n\t\tt.Fatalf(\"listen: %v\", err)\n\t}\n\treturn &Listener{Listener: l}\n}\n\nfunc client(t *testing.T, addr, header string, length int, terminate bool, wait time.Duration, done chan struct{}) {\n\tc, err := net.Dial(\"tcp\", addr)\n\tif err != nil {\n\t\tt.Fatalf(\"dial: %v\", err)\n\t}\n\tdefer c.Close()\n\n\tif terminate && length < 2 {\n\t\tlength = 2\n\t}\n\n\tbuf := make([]byte, len(header)+length)\n\tcopy(buf, []byte(header))\n\tfor i := 0; i < length-2; i++ {\n\t\tbuf[i+len(header)] = 0x20\n\t}\n\tif terminate {\n\t\tcopy(buf[len(header)+length-2:], []byte(crlf))\n\t}\n\n\tn, err := c.Write(buf)\n\tif err != nil {\n\t\tt.Fatalf(\"write: %v\", err)\n\t}\n\tif n != len(buf) {\n\t\tt.Fatalf(\"write; short write\")\n\t}\n\n\ttime.Sleep(wait)\n\tclose(done)\n}\n\nfunc TestVersion1Overflow(t *testing.T) {\n\tdone := make(chan struct{})\n\n\tl := listen(t)\n\tgo client(t, l.Addr().String(), fixtureTCP6V1Overflow, 10240, true, 10*time.Second, done)\n\n\tc, err := l.Accept()\n\tif err != nil {\n\t\tt.Fatalf(\"accept: %v\", err)\n\t}\n\n\tb := []byte{}\n\t_, err = c.Read(b)\n\tif err == nil {\n\t\tt.Fatalf(\"net.Conn: no error reported for oversized header\")\n\t}\n}\n\nfunc TestVersion1SlowLoris(t *testing.T) {\n\tdone := make(chan struct{})\n\ttimeout := make(chan error)\n\n\tl := listen(t)\n\tgo client(t, l.Addr().String(), fixtureTCP6V1Overflow, 0, false, 10*time.Second, done)\n\n\tc, err := l.Accept()\n\tif err != nil {\n\t\tt.Fatalf(\"accept: %v\", err)\n\t}\n\n\tgo func() {\n\t\tb := []byte{}\n\t\t_, err = c.Read(b)\n\t\ttimeout <- err\n\t}()\n\n\tselect {\n\tcase <-done:\n\t\tt.Fatalf(\"net.Conn: reader still blocked after 10 seconds\")\n\tcase err := <-timeout:\n\t\tif err == nil {\n\t\t\tt.Fatalf(\"net.Conn: no error reported for incomplete header\")\n\t\t}\n\t}\n}\n\nfunc TestVersion1SlowLorisOverflow(t *testing.T) {\n\tdone := make(chan struct{})\n\ttimeout := make(chan error)\n\n\tl := listen(t)\n\tgo client(t, l.Addr().String(), fixtureTCP6V1Overflow, 10240, false, 10*time.Second, done)\n\n\tc, err := l.Accept()\n\tif err != nil {\n\t\tt.Fatalf(\"accept: %v\", err)\n\t}\n\n\tgo func() {\n\t\tb := []byte{}\n\t\t_, err = c.Read(b)\n\t\ttimeout <- err\n\t}()\n\n\tselect {\n\tcase <-done:\n\t\tt.Fatalf(\"net.Conn: reader still blocked after 10 seconds\")\n\tcase err := <-timeout:\n\t\tif err == nil {\n\t\t\tt.Fatalf(\"net.Conn: no error reported for incomplete and overflowed header\")\n\t\t}\n\t}\n}\n"], "filenames": ["header.go", "header_test.go", "v1.go", "v1_test.go"], "buggy_code_start_loc": [19, 16, 5, 5], "buggy_code_end_loc": [20, 21, 36, 177], "fixing_code_start_loc": [19, 16, 6, 6], "fixing_code_end_loc": [22, 22, 99, 336], "type": "NVD-CWE-noinfo", "message": "The package github.com/pires/go-proxyproto before 0.5.0 are vulnerable to Denial of Service (DoS) via the parseVersion1() function. The reader in this package is a default bufio.Reader wrapping a net.Conn. It will read from the connection until it finds a newline. Since no limits are implemented in the code, a deliberately malformed V1 header could be used to exhaust memory in a server process using this code - and create a DoS. This can be exploited by sending a stream starting with PROXY and continuing to send data (which does not contain a newline) until the target stops acknowledging. The risk here is small, because only trusted sources should be allowed to send proxy protocol headers.", "other": {"cve": {"id": "CVE-2021-23351", "sourceIdentifier": "report@snyk.io", "published": "2021-03-08T05:15:12.593", "lastModified": "2021-03-23T18:23:16.590", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The package github.com/pires/go-proxyproto before 0.5.0 are vulnerable to Denial of Service (DoS) via the parseVersion1() function. The reader in this package is a default bufio.Reader wrapping a net.Conn. It will read from the connection until it finds a newline. Since no limits are implemented in the code, a deliberately malformed V1 header could be used to exhaust memory in a server process using this code - and create a DoS. This can be exploited by sending a stream starting with PROXY and continuing to send data (which does not contain a newline) until the target stops acknowledging. The risk here is small, because only trusted sources should be allowed to send proxy protocol headers."}, {"lang": "es", "value": "El paquete github.com/pires/go-proxyproto versiones anteriores a 0.5.0, son vulnerables a una Denegaci\u00f3n de Servicio (DoS) por medio de la funci\u00f3n parseVersion1().&#xa0;El lector de este paquete es un bufio.Reader predeterminado que contiene un net.Conn.&#xa0;Leer\u00e1 desde la conexi\u00f3n hasta que encuentre una nueva l\u00ednea.&#xa0;Dado que no se implementan l\u00edmites en el c\u00f3digo, un encabezado V1 deliberadamente malformado podr\u00eda ser usado para agotar la memoria en un proceso de servidor usando este c\u00f3digo y crear una DoS.&#xa0;Esto puede ser explotado mediante el envi\u00f3 de una secuencia que comience con PROXY y contin\u00fae enviando datos (que no contienen una nueva l\u00ednea) hasta que el objetivo deje de reconocer.&#xa0;El riesgo aqu\u00ed es peque\u00f1o, porque solo las fuentes confiables deben poder enviar encabezados de protocolo proxy"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 3.6}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:H/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.7, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:go-proxyproto_project:go-proxyproto:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.5.0", "matchCriteriaId": "F01D02DD-799C-4234-B4B8-2A5FF4DDD98B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}]}]}], "references": [{"url": "https://github.com/pires/go-proxyproto/commit/7f48261db810703d173f27f3309a808cc2b49b8b", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/pires/go-proxyproto/issues/69", "source": "report@snyk.io", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/pires/go-proxyproto/pull/71", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/4BNVGJMVI3ZTZ675EFPUHPGXCKCGSX46/", "source": "report@snyk.io", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/C36IBVOZXRTWM7MGTRUTOM56P5RR74VU/", "source": "report@snyk.io", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-GOLANG-GITHUBCOMPIRESGOPROXYPROTO-1081577", "source": "report@snyk.io", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pires/go-proxyproto/commit/7f48261db810703d173f27f3309a808cc2b49b8b"}}