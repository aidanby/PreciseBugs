{"buggy_code": ["<?php\n/**\n * Copyright (c) Enalean, 2021-Present. All Rights Reserved.\n *\n * Tuleap is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * Tuleap is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Tuleap; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\ndeclare(strict_types=1);\n\nnamespace Tuleap\\Gitlab\\Artifact\\Action;\n\nuse Tuleap\\Git\\Branch\\BranchName;\nuse Tuleap\\Git\\Branch\\InvalidBranchNameException;\nuse Tuleap\\Gitlab\\Repository\\GitlabRepositoryIntegrationFactory;\nuse Tuleap\\Gitlab\\Repository\\GitlabRepositoryIntegrationNotFoundException;\n\nfinal class CreateBranchPrefixUpdater\n{\n    private const FAKE_BRANCH_NAME = 'branch_name';\n\n    public function __construct(\n        private GitlabRepositoryIntegrationFactory $integration_factory,\n        private SaveIntegrationBranchPrefix $branch_prefix_saver,\n    ) {\n    }\n\n    /**\n     * @throws GitlabRepositoryIntegrationNotFoundException\n     * @throws InvalidBranchNameException\n     */\n    public function updateBranchPrefix(int $integration_id, string $prefix): void\n    {\n        $gitlab_repository = $this->integration_factory->getIntegrationById($integration_id);\n        if (! $gitlab_repository) {\n            throw new GitlabRepositoryIntegrationNotFoundException($integration_id);\n        }\n\n        BranchName::fromBranchNameShortHand($prefix . self::FAKE_BRANCH_NAME);\n\n        $this->branch_prefix_saver->setCreateBranchPrefixForIntegration(\n            $integration_id,\n            $prefix\n        );\n    }\n}\n", "<?php\n/**\n * Copyright (c) Enalean, 2020-Present. All Rights Reserved.\n *\n * Tuleap is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * Tuleap is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Tuleap; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\ndeclare(strict_types=1);\n\nnamespace Tuleap\\Gitlab\\REST\\v1;\n\nuse BackendLogger;\nuse Git_PermissionsDao;\nuse Git_SystemEventManager;\nuse GitDao;\nuse GitPermissionsManager;\nuse GitRepositoryFactory;\nuse GitUserNotAdminException;\nuse Luracast\\Restler\\RestException;\nuse Project;\nuse ProjectManager;\nuse SystemEventManager;\nuse Tuleap\\Cryptography\\ConcealedString;\nuse Tuleap\\Cryptography\\KeyFactory;\nuse Tuleap\\DB\\DBFactory;\nuse Tuleap\\DB\\DBTransactionExecutorWithConnection;\nuse Tuleap\\Git\\Branch\\InvalidBranchNameException;\nuse Tuleap\\Git\\Permissions\\FineGrainedDao;\nuse Tuleap\\Git\\Permissions\\FineGrainedRetriever;\nuse Tuleap\\Gitlab\\API\\ClientWrapper;\nuse Tuleap\\Gitlab\\API\\Credentials;\nuse Tuleap\\Gitlab\\API\\GitlabHTTPClientFactory;\nuse Tuleap\\Gitlab\\API\\GitlabProjectBuilder;\nuse Tuleap\\Gitlab\\API\\GitlabRequestException;\nuse Tuleap\\Gitlab\\API\\GitlabResponseAPIException;\nuse Tuleap\\Gitlab\\Artifact\\Action\\CreateBranchPrefixDao;\nuse Tuleap\\Gitlab\\Artifact\\Action\\CreateBranchPrefixUpdater;\nuse Tuleap\\Gitlab\\Repository\\GitlabRepositoryAlreadyIntegratedInProjectException;\nuse Tuleap\\Gitlab\\Repository\\GitlabRepositoryCreator;\nuse Tuleap\\Gitlab\\Repository\\GitlabRepositoryCreatorConfiguration;\nuse Tuleap\\Gitlab\\Repository\\GitlabRepositoryDeletor;\nuse Tuleap\\Gitlab\\Repository\\GitlabRepositoryIntegrationDao;\nuse Tuleap\\Gitlab\\Repository\\GitlabRepositoryIntegrationFactory;\nuse Tuleap\\Gitlab\\Repository\\GitlabRepositoryIntegrationUpdator;\nuse Tuleap\\Gitlab\\Repository\\GitlabRepositoryNotInProjectException;\nuse Tuleap\\Gitlab\\Repository\\GitlabRepositoryIntegrationNotFoundException;\nuse Tuleap\\Gitlab\\Repository\\GitlabRepositoryWithSameNameAlreadyIntegratedInProjectException;\nuse Tuleap\\Gitlab\\Repository\\Token\\IntegrationApiToken;\nuse Tuleap\\Gitlab\\Repository\\Token\\IntegrationApiTokenDao;\nuse Tuleap\\Gitlab\\Repository\\Token\\IntegrationApiTokenInserter;\nuse Tuleap\\Gitlab\\Repository\\Token\\IntegrationApiTokenRetriever;\nuse Tuleap\\Gitlab\\Repository\\Webhook\\Bot\\CredentialsRetriever;\nuse Tuleap\\Gitlab\\Repository\\Webhook\\PostMergeRequest\\MergeRequestTuleapReferenceDao;\nuse Tuleap\\Gitlab\\Repository\\Webhook\\PostPush\\Branch\\BranchInfoDao;\nuse Tuleap\\Gitlab\\Repository\\Webhook\\PostPush\\Commits\\CommitTuleapReferenceDao;\nuse Tuleap\\Gitlab\\Repository\\Webhook\\TagPush\\TagInfoDao;\nuse Tuleap\\Gitlab\\Repository\\Webhook\\WebhookCreator;\nuse Tuleap\\Gitlab\\Repository\\Webhook\\WebhookDao;\nuse Tuleap\\Gitlab\\Repository\\Webhook\\WebhookDeletor;\nuse Tuleap\\Http\\HttpClientFactory;\nuse Tuleap\\Http\\HTTPFactoryBuilder;\nuse Tuleap\\REST\\Header;\nuse UserManager;\n\nfinal class GitlabRepositoryResource\n{\n    /**\n     * @url OPTIONS\n     */\n    public function options(): void\n    {\n        Header::allowOptionsPost();\n    }\n\n    /**\n     * Integrate a GitLab repository into a project.\n     *\n     * /!\\ This route is under construction.\n     * <br>\n     * Integrate the given GitLab repository into project.\n     *\n     * <br>\n     * <br>\n     * A GitLab repository can be integrated into a project like:\n     * <br>\n     * <pre>\n     * {<br>\n     *   &nbsp;\"project_id\": 122,<br>\n     *   &nbsp;\"gitlab_server_url\" : \"https://example.com\",<br>\n     *   &nbsp;\"gitlab_bot_api_token\" : \"project_bot_token\",<br>\n     *   &nbsp;\"gitlab_repository_id\" : 145896<br>\n     *  }<br>\n     * </pre>\n     *\n     *\n     * @url    POST\n     * @access protected\n     *\n     * @param GitlabRepositoryPOSTRepresentation $gitlab_repository {@from body}\n     *\n     * @status 201\n     * @return GitlabRepositoryRepresentation {@type GitlabRepositoryRepresentation}\n     *\n     * @throws RestException 400\n     * @throws RestException 401\n     * @throws RestException 404\n     *\n     */\n    protected function createGitlabRepository(GitlabRepositoryPOSTRepresentation $gitlab_repository): GitlabRepositoryRepresentation\n    {\n        $this->options();\n\n        $gitlab_server_url     = $gitlab_repository->gitlab_server_url;\n        $integration_api_token = IntegrationApiToken::buildBrandNewToken(new ConcealedString($gitlab_repository->gitlab_bot_api_token));\n        $project_id            = $gitlab_repository->project_id;\n        $gitlab_repository_id  = $gitlab_repository->gitlab_repository_id;\n\n        $project     = $this->getProjectById($project_id);\n        $credentials = new Credentials($gitlab_server_url, $integration_api_token);\n\n        $request_factory       = HTTPFactoryBuilder::requestFactory();\n        $stream_factory        = HTTPFactoryBuilder::streamFactory();\n        $gitlab_client_factory = new GitlabHTTPClientFactory(HttpClientFactory::createClient());\n        $gitlab_api_client     = new ClientWrapper($request_factory, $stream_factory, $gitlab_client_factory);\n\n        $current_user = UserManager::instance()->getCurrentUser();\n        if (! $this->getGitPermissionsManager()->userIsGitAdmin($current_user, $project)) {\n            throw new RestException(401, \"User must be Git administrator.\");\n        }\n\n        try {\n            $gitlab_api_project = (new GitlabProjectBuilder($gitlab_api_client))->getProjectFromGitlabAPI(\n                $credentials,\n                $gitlab_repository_id\n            );\n\n            $gitlab_repository_creator = new GitlabRepositoryCreator(\n                new DBTransactionExecutorWithConnection(\n                    DBFactory::getMainTuleapDBConnection()\n                ),\n                new GitlabRepositoryIntegrationFactory(\n                    new GitlabRepositoryIntegrationDao(),\n                    ProjectManager::instance()\n                ),\n                new GitlabRepositoryIntegrationDao(),\n                new WebhookCreator(\n                    new KeyFactory(),\n                    new WebhookDao(),\n                    new WebhookDeletor(\n                        new WebhookDao(),\n                        $gitlab_api_client,\n                        BackendLogger::getDefaultLogger(\\gitlabPlugin::LOG_IDENTIFIER)\n                    ),\n                    $gitlab_api_client,\n                    BackendLogger::getDefaultLogger(\\gitlabPlugin::LOG_IDENTIFIER),\n                ),\n                new IntegrationApiTokenInserter(new IntegrationApiTokenDao(), new KeyFactory())\n            );\n\n            if (isset($gitlab_repository->allow_artifact_closure) && $gitlab_repository->allow_artifact_closure === true) {\n                $configuration = GitlabRepositoryCreatorConfiguration::buildConfigurationAllowingArtifactClosure();\n            } else {\n                $configuration = GitlabRepositoryCreatorConfiguration::buildDefaultConfiguration();\n            }\n\n            $integrated_gitlab_repository = $gitlab_repository_creator->integrateGitlabRepositoryInProject(\n                $credentials,\n                $gitlab_api_project,\n                $project,\n                $configuration\n            );\n\n            $webhook_dao         = new WebhookDao();\n            $integration_webhook = $webhook_dao->getGitlabRepositoryWebhook(\n                $integrated_gitlab_repository->getId()\n            );\n\n            $create_branch_prefix = (new CreateBranchPrefixDao())->searchCreateBranchPrefixForIntegration(\n                $integrated_gitlab_repository->getId()\n            );\n\n            return new GitlabRepositoryRepresentation(\n                $integrated_gitlab_repository->getId(),\n                $integrated_gitlab_repository->getGitlabRepositoryId(),\n                $integrated_gitlab_repository->getName(),\n                $integrated_gitlab_repository->getDescription(),\n                $integrated_gitlab_repository->getGitlabRepositoryUrl(),\n                $integrated_gitlab_repository->getLastPushDate()->getTimestamp(),\n                $integrated_gitlab_repository->getProject(),\n                $integrated_gitlab_repository->isArtifactClosureAllowed(),\n                $integration_webhook !== null,\n                $create_branch_prefix\n            );\n        } catch (\n            GitlabResponseAPIException |\n            GitlabRepositoryAlreadyIntegratedInProjectException |\n            GitlabRepositoryWithSameNameAlreadyIntegratedInProjectException $exception\n        ) {\n            throw new RestException(400, $exception->getMessage());\n        } catch (GitlabRequestException $exception) {\n            throw new RestException(\n                $exception->getErrorCode(),\n                $exception->getMessage()\n            );\n        }\n    }\n\n    /**\n     * @url OPTIONS {id}\n     *\n     * @param int $id Id of the GitLab repository integration\n     */\n    public function optionsId(int $id): void\n    {\n        Header::allowOptionsPatchDelete();\n    }\n\n    /**\n     * Delete Gitlab Integrations.\n     *\n     * /!\\ This route is under construction.\n     * <br>\n     * Delete the given GitLab integration.\n     *\n     * @url    DELETE {id}\n     * @access protected\n     *\n     * @param int $id Id of the GitLab repository integration\n     *\n     * @status 204\n     *\n     * @throws RestException 400\n     * @throws RestException 401\n     * @throws RestException 404\n     */\n    protected function deleteGitlabRepository(int $id): void\n    {\n        $this->optionsId($id);\n\n        $repository_integration_factory = new GitlabRepositoryIntegrationFactory(\n            new GitlabRepositoryIntegrationDao(),\n            ProjectManager::instance()\n        );\n\n        $gitlab_repository_integration = $repository_integration_factory->getIntegrationById($id);\n\n        if ($gitlab_repository_integration === null) {\n            throw new RestException(404, \"Repository #$id not found.\");\n        }\n\n        $current_user          = UserManager::instance()->getCurrentUser();\n        $request_factory       = HTTPFactoryBuilder::requestFactory();\n        $stream_factory        = HTTPFactoryBuilder::streamFactory();\n        $gitlab_client_factory = new GitlabHTTPClientFactory(HttpClientFactory::createClient());\n        $gitlab_api_client     = new ClientWrapper($request_factory, $stream_factory, $gitlab_client_factory);\n\n        $deletor = new GitlabRepositoryDeletor(\n            $this->getGitPermissionsManager(),\n            new DBTransactionExecutorWithConnection(\n                DBFactory::getMainTuleapDBConnection()\n            ),\n            new WebhookDeletor(\n                new WebhookDao(),\n                $gitlab_api_client,\n                BackendLogger::getDefaultLogger(\\gitlabPlugin::LOG_IDENTIFIER)\n            ),\n            new GitlabRepositoryIntegrationDao(),\n            new IntegrationApiTokenDao(),\n            new CommitTuleapReferenceDao(),\n            new MergeRequestTuleapReferenceDao(),\n            new TagInfoDao(),\n            new BranchInfoDao(),\n            new CredentialsRetriever(new IntegrationApiTokenRetriever(new IntegrationApiTokenDao(), new KeyFactory())),\n            new CreateBranchPrefixDao()\n        );\n\n        try {\n            $deletor->deleteRepositoryIntegration(\n                $gitlab_repository_integration,\n                $current_user\n            );\n        } catch (GitUserNotAdminException $exception) {\n            throw new RestException(401, \"User is not Git administrator.\");\n        } catch (GitlabRepositoryNotInProjectException | GitlabRepositoryIntegrationNotFoundException $exception) {\n            throw new RestException(400, $exception->getMessage());\n        }\n    }\n\n    /**\n     * Update GitLab integration\n     *\n     * <pre>\n     * /!\\ This route is under construction and subject to changes /!\\\n     * </pre>\n     *\n     * <p>To update the API token, used by Tuleap to communicate with GitLab:</p>\n     * <pre>\n     * {<br>\n     *   &nbsp;\"update_bot_api_token\": {<br>\n     *   &nbsp;&nbsp;&nbsp;\"gitlab_api_token\" : \"The new token\"<br>\n     *   &nbsp;}<br>\n     *  }<br>\n     * </pre>\n     * <br>\n     * <p>\n     * <strong>Note:</strong> To ensure that the new token has needed access, it will regenerate the webhook used by GitLab.\n     * </p>\n     *\n     * <p>To update the webhook secret, used by GitLab to communicate with Tuleap:</p>\n     * <pre>\n     * {<br>\n     *   &nbsp;\"generate_new_secret\": true\n     * }<br>\n     * </pre>\n     *\n     * <p>To update the artifact closure option :</p>\n     * <pre>\n     * {<br>\n     *   &nbsp;\"allow_artifact_closure\" : false<br>\n     * }<br>\n     * </pre>\n     *\n     * <p>To update the prefix used in the branch creation (feature flag must be enabled):</p>\n     * <pre>\n     * {<br>\n     *   &nbsp;\"create_branch_prefix\" : \"dev-\"<br>\n     * }<br>\n     * </pre>\n     *\n     * <p>\n     * <strong>Note:</strong> You cannot do multiple actions at the same.\n     * You will get a <code>400</code> if you send either <code>update_bot_api_token</code> or <code>generate_new_secret</code> or <code>allow_artifact_closure</code> or <code>create_branch_prefix</code>.\n     * </p>\n     *\n     * @url    PATCH {id}\n     * @access protected\n     *\n     * @param int                                 $id                   Id of the Gitlab integration\n     * @param GitlabRepositoryPatchRepresentation $patch_representation {@from body}\n     *\n     * @return GitlabRepositoryRepresentation {@type GitlabRepositoryRepresentation}\n     *\n     * @throws RestException 401\n     * @throws RestException 404\n     * @throws RestException 500\n     */\n    protected function patchId(\n        int $id,\n        GitlabRepositoryPatchRepresentation $patch_representation,\n    ): GitlabRepositoryRepresentation {\n        $this->optionsId($id);\n\n        $request_factory       = HTTPFactoryBuilder::requestFactory();\n        $stream_factory        = HTTPFactoryBuilder::streamFactory();\n        $gitlab_client_factory = new GitlabHTTPClientFactory(HttpClientFactory::createClient());\n        $gitlab_api_client     = new ClientWrapper($request_factory, $stream_factory, $gitlab_client_factory);\n        $logger                = BackendLogger::getDefaultLogger(\\gitlabPlugin::LOG_IDENTIFIER);\n\n        $current_user = UserManager::instance()->getCurrentUser();\n\n        $this->validateJSONIsWellFormed($patch_representation);\n\n        if ($patch_representation->update_bot_api_token) {\n            $bot_api_token_updater = new BotApiTokenUpdater(\n                new GitlabRepositoryIntegrationFactory(\n                    new GitlabRepositoryIntegrationDao(),\n                    ProjectManager::instance()\n                ),\n                new GitlabProjectBuilder($gitlab_api_client),\n                $this->getGitPermissionsManager(),\n                new IntegrationApiTokenInserter(\n                    new IntegrationApiTokenDao(),\n                    new KeyFactory()\n                ),\n                new WebhookCreator(\n                    new KeyFactory(),\n                    new WebhookDao(),\n                    new WebhookDeletor(\n                        new WebhookDao(),\n                        $gitlab_api_client,\n                        BackendLogger::getDefaultLogger(\\gitlabPlugin::LOG_IDENTIFIER)\n                    ),\n                    $gitlab_api_client,\n                    $logger,\n                ),\n                $logger,\n            );\n\n            $bot_api_token_updater->update(\n                new ConcealedBotApiTokenPatchRepresentation(\n                    $id,\n                    new ConcealedString($patch_representation->update_bot_api_token->gitlab_api_token),\n                ),\n                $current_user,\n            );\n\n            return $this->buildUpdatedIntegrationRepresentation($id);\n        }\n\n        if ($patch_representation->generate_new_secret && $patch_representation->generate_new_secret === true) {\n            $generator = new WebhookSecretGenerator(\n                new GitlabRepositoryIntegrationFactory(\n                    new GitlabRepositoryIntegrationDao(),\n                    ProjectManager::instance()\n                ),\n                $this->getGitPermissionsManager(),\n                new CredentialsRetriever(\n                    new IntegrationApiTokenRetriever(\n                        new IntegrationApiTokenDao(),\n                        new KeyFactory()\n                    ),\n                ),\n                new WebhookCreator(\n                    new KeyFactory(),\n                    new WebhookDao(),\n                    new WebhookDeletor(\n                        new WebhookDao(),\n                        $gitlab_api_client,\n                        BackendLogger::getDefaultLogger(\\gitlabPlugin::LOG_IDENTIFIER)\n                    ),\n                    $gitlab_api_client,\n                    $logger,\n                )\n            );\n\n            $generator->regenerate($id, $current_user);\n\n            return $this->buildUpdatedIntegrationRepresentation($id);\n        }\n\n        if (isset($patch_representation->allow_artifact_closure)) {\n            $dao                                   = new GitlabRepositoryIntegrationDao();\n            $gitlab_repository_integration_factory =   new GitlabRepositoryIntegrationFactory(\n                $dao,\n                ProjectManager::instance()\n            );\n            $updater                               = new GitlabRepositoryIntegrationUpdator(\n                $dao,\n                $this->getGitPermissionsManager(),\n                $gitlab_repository_integration_factory,\n                new DBTransactionExecutorWithConnection(\n                    DBFactory::getMainTuleapDBConnection()\n                ),\n            );\n            try {\n                $updater->updateTuleapArtifactClosureOfAGitlabIntegration(\n                    $id,\n                    $patch_representation->allow_artifact_closure,\n                    $current_user\n                );\n\n                return $this->buildUpdatedIntegrationRepresentation($id);\n            } catch (GitUserNotAdminException $e) {\n                throw new RestException(401, \"User must be Git administrator.\");\n            } catch (GitlabRepositoryIntegrationNotFoundException $e) {\n                throw new RestException(404, $e->getMessage());\n            }\n        }\n\n        if ($patch_representation->create_branch_prefix !== null) {\n            $prefix_updater = new CreateBranchPrefixUpdater(\n                new GitlabRepositoryIntegrationFactory(\n                    new GitlabRepositoryIntegrationDao(),\n                    ProjectManager::instance()\n                ),\n                new CreateBranchPrefixDao()\n            );\n\n            try {\n                $prefix_updater->updateBranchPrefix(\n                    $id,\n                    $patch_representation->create_branch_prefix\n                );\n\n                return $this->buildUpdatedIntegrationRepresentation($id);\n            } catch (InvalidBranchNameException $exception) {\n                throw new RestException(\n                    400,\n                    $exception->getMessage()\n                );\n            }\n        }\n\n        throw new RestException(400, \"The JSON representation cannot be null\");\n    }\n\n    /**\n     * @url    OPTIONS {id}/branches\n     * @access protected\n     */\n    protected function optionBranches(int $id): void\n    {\n        Header::allowOptionsGet();\n    }\n\n    /**\n     * Get information on branches of the GitLab repository\n     *\n     * @url    GET {id}/branches\n     * @access protected\n     *\n     * @param int $id ID of the GitLab integration\n     *\n     *\n     * Only members of the project where the integration lives can access the branches information\n     *\n     * @throws RestException 404\n     */\n    protected function getBranches(int $id): BranchesInformationRepresentation\n    {\n        $this->optionBranches($id);\n\n        $branch_information_retriever = new GitlabBranchInformationRetriever(\n            new GitlabRepositoryIntegrationFactory(\n                new GitlabRepositoryIntegrationDao(),\n                ProjectManager::instance()\n            ),\n            new CredentialsRetriever(new IntegrationApiTokenRetriever(new IntegrationApiTokenDao(), new KeyFactory())),\n            new GitlabProjectBuilder(\n                new ClientWrapper(\n                    HTTPFactoryBuilder::requestFactory(),\n                    HTTPFactoryBuilder::streamFactory(),\n                    new GitlabHTTPClientFactory(HttpClientFactory::createClient())\n                )\n            )\n        );\n\n        return $branch_information_retriever->getBranchInformation(UserManager::instance()->getCurrentUser(), $id);\n    }\n\n    /**\n     * @throws RestException\n     */\n    private function buildUpdatedIntegrationRepresentation(int $id): GitlabRepositoryRepresentation\n    {\n        $dao                                   = new GitlabRepositoryIntegrationDao();\n        $gitlab_repository_integration_factory = new GitlabRepositoryIntegrationFactory(\n            $dao,\n            ProjectManager::instance()\n        );\n\n        $updated_gitlab_integration = $gitlab_repository_integration_factory->getIntegrationById($id);\n        if ($updated_gitlab_integration === null) {\n            throw new RestException(500, \"Updated repository not found, this must not happen\");\n        }\n\n        $webhook_dao         = new WebhookDao();\n        $integration_webhook = $webhook_dao->getGitlabRepositoryWebhook(\n            $updated_gitlab_integration->getId()\n        );\n\n        $create_branch_prefix = (new CreateBranchPrefixDao())->searchCreateBranchPrefixForIntegration($id);\n\n        return new GitlabRepositoryRepresentation(\n            $updated_gitlab_integration->getId(),\n            $updated_gitlab_integration->getGitlabRepositoryId(),\n            $updated_gitlab_integration->getName(),\n            $updated_gitlab_integration->getDescription(),\n            $updated_gitlab_integration->getGitlabRepositoryUrl(),\n            $updated_gitlab_integration->getLastPushDate()->getTimestamp(),\n            $updated_gitlab_integration->getProject(),\n            $updated_gitlab_integration->isArtifactClosureAllowed(),\n            $integration_webhook !== null,\n            $create_branch_prefix\n        );\n    }\n\n    private function getGitPermissionsManager(): GitPermissionsManager\n    {\n        $git_system_event_manager = new Git_SystemEventManager(\n            SystemEventManager::instance(),\n            new GitRepositoryFactory(\n                new GitDao(),\n                ProjectManager::instance()\n            )\n        );\n\n        $fine_grained_dao       = new FineGrainedDao();\n        $fine_grained_retriever = new FineGrainedRetriever($fine_grained_dao);\n\n        return new GitPermissionsManager(\n            new Git_PermissionsDao(),\n            $git_system_event_manager,\n            $fine_grained_dao,\n            $fine_grained_retriever\n        );\n    }\n\n    /**\n     * @throws RestException\n     */\n    private function getProjectById(int $project_id): Project\n    {\n        $project = ProjectManager::instance()->getProject($project_id);\n        if (! $project || $project->isError()) {\n            throw new RestException(404, \"Project #$project_id not found.\");\n        }\n\n        return $project;\n    }\n\n    /**\n     * @throws RestException\n     */\n    private function validateJSONIsWellFormed(GitlabRepositoryPatchRepresentation $patch_representation): void\n    {\n        $provided_parameter = 0;\n        foreach (get_object_vars($patch_representation) as $parameter) {\n            if ($parameter !== null) {\n                $provided_parameter++;\n            }\n        }\n\n        if ($provided_parameter > 1) {\n            throw new RestException(\n                400,\n                'You cannot ask at the same time to update the api token, generate a new webhook secret, allowing artifact closure or updating the create branch prefix.'\n            );\n        }\n    }\n}\n", "<?php\n/**\n * Copyright (c) Enalean, 2021 - present. All Rights Reserved.\n *\n * This file is a part of Tuleap.\n *\n * Tuleap is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * Tuleap is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Tuleap. If not, see http://www.gnu.org/licenses/.\n */\n\ndeclare(strict_types=1);\n\nnamespace Tuleap\\Gitlab\\Artifact\\Action;\n\nuse Tuleap\\Git\\Branch\\InvalidBranchNameException;\nuse Tuleap\\Gitlab\\Repository\\GitlabRepositoryIntegrationFactory;\nuse Tuleap\\Gitlab\\Repository\\GitlabRepositoryIntegrationNotFoundException;\nuse Tuleap\\Gitlab\\Test\\Builder\\RepositoryIntegrationBuilder;\nuse Tuleap\\Gitlab\\Test\\Stubs\\SaveIntegrationBranchPrefixStub;\nuse Tuleap\\Test\\PHPUnit\\TestCase;\n\nfinal class CreateBranchPrefixUpdaterTest extends TestCase\n{\n    private const INTEGRATION_ID = 18;\n    /**\n     * @var \\PHPUnit\\Framework\\MockObject\\MockObject&GitlabRepositoryIntegrationFactory\n     */\n    private $integration_factory;\n    private SaveIntegrationBranchPrefixStub $branch_prefix_saver;\n    private string $branch_prefix;\n\n    protected function setUp(): void\n    {\n        $this->integration_factory = $this->createMock(GitlabRepositoryIntegrationFactory::class);\n        $this->branch_prefix_saver = SaveIntegrationBranchPrefixStub::withCallCount();\n\n        $this->branch_prefix = 'dev-';\n    }\n\n    private function updateBranchPrefix(): void\n    {\n        $updater = new CreateBranchPrefixUpdater(\n            $this->integration_factory,\n            $this->branch_prefix_saver\n        );\n\n        $updater->updateBranchPrefix(self::INTEGRATION_ID, $this->branch_prefix);\n    }\n\n    public function testItStoresTheBranchPrefix(): void\n    {\n        $this->integration_factory\n            ->expects(self::once())\n            ->method('getIntegrationById')\n            ->with(self::INTEGRATION_ID)\n            ->willReturn(RepositoryIntegrationBuilder::aGitlabRepositoryIntegration(self::INTEGRATION_ID)->build());\n\n        $this->updateBranchPrefix();\n\n        self::assertSame(1, $this->branch_prefix_saver->getCallCount());\n    }\n\n    public function testItStoresTheBranchPrefixWithSomeSpecialChars(): void\n    {\n        $this->integration_factory\n            ->expects(self::once())\n            ->method('getIntegrationById')\n            ->with(self::INTEGRATION_ID)\n            ->willReturn(RepositoryIntegrationBuilder::aGitlabRepositoryIntegration(self::INTEGRATION_ID)->build());\n\n        $this->branch_prefix = 'dev/';\n        $this->updateBranchPrefix();\n\n        self::assertSame(1, $this->branch_prefix_saver->getCallCount());\n    }\n\n    public function testItThrowsAnExceptionIfIntegrationNotFoundTheBranchPrefix(): void\n    {\n        $this->integration_factory\n            ->expects(self::once())\n            ->method('getIntegrationById')\n            ->with(self::INTEGRATION_ID)\n            ->willReturn(null);\n\n        $this->expectException(GitlabRepositoryIntegrationNotFoundException::class);\n        $this->updateBranchPrefix();\n\n        self::assertSame(0, $this->branch_prefix_saver->getCallCount());\n    }\n\n    public function testItThrowsAnExceptionIfBranchPrefixIsNotValid(): void\n    {\n        $this->integration_factory\n            ->expects(self::once())\n            ->method('getIntegrationById')\n            ->with(self::INTEGRATION_ID)\n            ->willReturn(RepositoryIntegrationBuilder::aGitlabRepositoryIntegration(self::INTEGRATION_ID)->build());\n\n        $this->branch_prefix = 'dev:';\n\n        $this->expectException(InvalidBranchNameException::class);\n        $this->updateBranchPrefix();\n\n        self::assertSame(0, $this->branch_prefix_saver->getCallCount());\n    }\n}\n"], "fixing_code": ["<?php\n/**\n * Copyright (c) Enalean, 2021-Present. All Rights Reserved.\n *\n * Tuleap is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * Tuleap is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Tuleap; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\ndeclare(strict_types=1);\n\nnamespace Tuleap\\Gitlab\\Artifact\\Action;\n\nuse GitPermissionsManager;\nuse GitUserNotAdminException;\nuse PFUser;\nuse Tuleap\\Git\\Branch\\BranchName;\nuse Tuleap\\Git\\Branch\\InvalidBranchNameException;\nuse Tuleap\\Gitlab\\Repository\\GitlabRepositoryIntegrationFactory;\nuse Tuleap\\Gitlab\\Repository\\GitlabRepositoryIntegrationNotFoundException;\n\nfinal class CreateBranchPrefixUpdater\n{\n    private const FAKE_BRANCH_NAME = 'branch_name';\n\n    public function __construct(\n        private GitlabRepositoryIntegrationFactory $integration_factory,\n        private GitPermissionsManager $git_permissions_manager,\n        private SaveIntegrationBranchPrefix $branch_prefix_saver,\n    ) {\n    }\n\n    /**\n     * @throws GitlabRepositoryIntegrationNotFoundException\n     * @throws InvalidBranchNameException\n     * @throws GitUserNotAdminException\n     */\n    public function updateBranchPrefix(PFUser $user, int $integration_id, string $prefix): void\n    {\n        $gitlab_repository = $this->integration_factory->getIntegrationById($integration_id);\n        if (! $gitlab_repository) {\n            throw new GitlabRepositoryIntegrationNotFoundException($integration_id);\n        }\n\n        $project = $gitlab_repository->getProject();\n        if (! $this->git_permissions_manager->userIsGitAdmin($user, $project)) {\n            throw new GitUserNotAdminException();\n        }\n\n        BranchName::fromBranchNameShortHand($prefix . self::FAKE_BRANCH_NAME);\n\n        $this->branch_prefix_saver->setCreateBranchPrefixForIntegration(\n            $integration_id,\n            $prefix\n        );\n    }\n}\n", "<?php\n/**\n * Copyright (c) Enalean, 2020-Present. All Rights Reserved.\n *\n * Tuleap is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * Tuleap is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Tuleap; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\ndeclare(strict_types=1);\n\nnamespace Tuleap\\Gitlab\\REST\\v1;\n\nuse BackendLogger;\nuse Git_PermissionsDao;\nuse Git_SystemEventManager;\nuse GitDao;\nuse GitPermissionsManager;\nuse GitRepositoryFactory;\nuse GitUserNotAdminException;\nuse Luracast\\Restler\\RestException;\nuse Project;\nuse ProjectManager;\nuse SystemEventManager;\nuse Tuleap\\Cryptography\\ConcealedString;\nuse Tuleap\\Cryptography\\KeyFactory;\nuse Tuleap\\DB\\DBFactory;\nuse Tuleap\\DB\\DBTransactionExecutorWithConnection;\nuse Tuleap\\Git\\Branch\\InvalidBranchNameException;\nuse Tuleap\\Git\\Permissions\\FineGrainedDao;\nuse Tuleap\\Git\\Permissions\\FineGrainedRetriever;\nuse Tuleap\\Gitlab\\API\\ClientWrapper;\nuse Tuleap\\Gitlab\\API\\Credentials;\nuse Tuleap\\Gitlab\\API\\GitlabHTTPClientFactory;\nuse Tuleap\\Gitlab\\API\\GitlabProjectBuilder;\nuse Tuleap\\Gitlab\\API\\GitlabRequestException;\nuse Tuleap\\Gitlab\\API\\GitlabResponseAPIException;\nuse Tuleap\\Gitlab\\Artifact\\Action\\CreateBranchPrefixDao;\nuse Tuleap\\Gitlab\\Artifact\\Action\\CreateBranchPrefixUpdater;\nuse Tuleap\\Gitlab\\Repository\\GitlabRepositoryAlreadyIntegratedInProjectException;\nuse Tuleap\\Gitlab\\Repository\\GitlabRepositoryCreator;\nuse Tuleap\\Gitlab\\Repository\\GitlabRepositoryCreatorConfiguration;\nuse Tuleap\\Gitlab\\Repository\\GitlabRepositoryDeletor;\nuse Tuleap\\Gitlab\\Repository\\GitlabRepositoryIntegrationDao;\nuse Tuleap\\Gitlab\\Repository\\GitlabRepositoryIntegrationFactory;\nuse Tuleap\\Gitlab\\Repository\\GitlabRepositoryIntegrationUpdator;\nuse Tuleap\\Gitlab\\Repository\\GitlabRepositoryNotInProjectException;\nuse Tuleap\\Gitlab\\Repository\\GitlabRepositoryIntegrationNotFoundException;\nuse Tuleap\\Gitlab\\Repository\\GitlabRepositoryWithSameNameAlreadyIntegratedInProjectException;\nuse Tuleap\\Gitlab\\Repository\\Token\\IntegrationApiToken;\nuse Tuleap\\Gitlab\\Repository\\Token\\IntegrationApiTokenDao;\nuse Tuleap\\Gitlab\\Repository\\Token\\IntegrationApiTokenInserter;\nuse Tuleap\\Gitlab\\Repository\\Token\\IntegrationApiTokenRetriever;\nuse Tuleap\\Gitlab\\Repository\\Webhook\\Bot\\CredentialsRetriever;\nuse Tuleap\\Gitlab\\Repository\\Webhook\\PostMergeRequest\\MergeRequestTuleapReferenceDao;\nuse Tuleap\\Gitlab\\Repository\\Webhook\\PostPush\\Branch\\BranchInfoDao;\nuse Tuleap\\Gitlab\\Repository\\Webhook\\PostPush\\Commits\\CommitTuleapReferenceDao;\nuse Tuleap\\Gitlab\\Repository\\Webhook\\TagPush\\TagInfoDao;\nuse Tuleap\\Gitlab\\Repository\\Webhook\\WebhookCreator;\nuse Tuleap\\Gitlab\\Repository\\Webhook\\WebhookDao;\nuse Tuleap\\Gitlab\\Repository\\Webhook\\WebhookDeletor;\nuse Tuleap\\Http\\HttpClientFactory;\nuse Tuleap\\Http\\HTTPFactoryBuilder;\nuse Tuleap\\REST\\Header;\nuse UserManager;\n\nfinal class GitlabRepositoryResource\n{\n    /**\n     * @url OPTIONS\n     */\n    public function options(): void\n    {\n        Header::allowOptionsPost();\n    }\n\n    /**\n     * Integrate a GitLab repository into a project.\n     *\n     * /!\\ This route is under construction.\n     * <br>\n     * Integrate the given GitLab repository into project.\n     *\n     * <br>\n     * <br>\n     * A GitLab repository can be integrated into a project like:\n     * <br>\n     * <pre>\n     * {<br>\n     *   &nbsp;\"project_id\": 122,<br>\n     *   &nbsp;\"gitlab_server_url\" : \"https://example.com\",<br>\n     *   &nbsp;\"gitlab_bot_api_token\" : \"project_bot_token\",<br>\n     *   &nbsp;\"gitlab_repository_id\" : 145896<br>\n     *  }<br>\n     * </pre>\n     *\n     *\n     * @url    POST\n     * @access protected\n     *\n     * @param GitlabRepositoryPOSTRepresentation $gitlab_repository {@from body}\n     *\n     * @status 201\n     * @return GitlabRepositoryRepresentation {@type GitlabRepositoryRepresentation}\n     *\n     * @throws RestException 400\n     * @throws RestException 401\n     * @throws RestException 404\n     *\n     */\n    protected function createGitlabRepository(GitlabRepositoryPOSTRepresentation $gitlab_repository): GitlabRepositoryRepresentation\n    {\n        $this->options();\n\n        $gitlab_server_url     = $gitlab_repository->gitlab_server_url;\n        $integration_api_token = IntegrationApiToken::buildBrandNewToken(new ConcealedString($gitlab_repository->gitlab_bot_api_token));\n        $project_id            = $gitlab_repository->project_id;\n        $gitlab_repository_id  = $gitlab_repository->gitlab_repository_id;\n\n        $project     = $this->getProjectById($project_id);\n        $credentials = new Credentials($gitlab_server_url, $integration_api_token);\n\n        $request_factory       = HTTPFactoryBuilder::requestFactory();\n        $stream_factory        = HTTPFactoryBuilder::streamFactory();\n        $gitlab_client_factory = new GitlabHTTPClientFactory(HttpClientFactory::createClient());\n        $gitlab_api_client     = new ClientWrapper($request_factory, $stream_factory, $gitlab_client_factory);\n\n        $current_user = UserManager::instance()->getCurrentUser();\n        if (! $this->getGitPermissionsManager()->userIsGitAdmin($current_user, $project)) {\n            throw new RestException(401, \"User must be Git administrator.\");\n        }\n\n        try {\n            $gitlab_api_project = (new GitlabProjectBuilder($gitlab_api_client))->getProjectFromGitlabAPI(\n                $credentials,\n                $gitlab_repository_id\n            );\n\n            $gitlab_repository_creator = new GitlabRepositoryCreator(\n                new DBTransactionExecutorWithConnection(\n                    DBFactory::getMainTuleapDBConnection()\n                ),\n                new GitlabRepositoryIntegrationFactory(\n                    new GitlabRepositoryIntegrationDao(),\n                    ProjectManager::instance()\n                ),\n                new GitlabRepositoryIntegrationDao(),\n                new WebhookCreator(\n                    new KeyFactory(),\n                    new WebhookDao(),\n                    new WebhookDeletor(\n                        new WebhookDao(),\n                        $gitlab_api_client,\n                        BackendLogger::getDefaultLogger(\\gitlabPlugin::LOG_IDENTIFIER)\n                    ),\n                    $gitlab_api_client,\n                    BackendLogger::getDefaultLogger(\\gitlabPlugin::LOG_IDENTIFIER),\n                ),\n                new IntegrationApiTokenInserter(new IntegrationApiTokenDao(), new KeyFactory())\n            );\n\n            if (isset($gitlab_repository->allow_artifact_closure) && $gitlab_repository->allow_artifact_closure === true) {\n                $configuration = GitlabRepositoryCreatorConfiguration::buildConfigurationAllowingArtifactClosure();\n            } else {\n                $configuration = GitlabRepositoryCreatorConfiguration::buildDefaultConfiguration();\n            }\n\n            $integrated_gitlab_repository = $gitlab_repository_creator->integrateGitlabRepositoryInProject(\n                $credentials,\n                $gitlab_api_project,\n                $project,\n                $configuration\n            );\n\n            $webhook_dao         = new WebhookDao();\n            $integration_webhook = $webhook_dao->getGitlabRepositoryWebhook(\n                $integrated_gitlab_repository->getId()\n            );\n\n            $create_branch_prefix = (new CreateBranchPrefixDao())->searchCreateBranchPrefixForIntegration(\n                $integrated_gitlab_repository->getId()\n            );\n\n            return new GitlabRepositoryRepresentation(\n                $integrated_gitlab_repository->getId(),\n                $integrated_gitlab_repository->getGitlabRepositoryId(),\n                $integrated_gitlab_repository->getName(),\n                $integrated_gitlab_repository->getDescription(),\n                $integrated_gitlab_repository->getGitlabRepositoryUrl(),\n                $integrated_gitlab_repository->getLastPushDate()->getTimestamp(),\n                $integrated_gitlab_repository->getProject(),\n                $integrated_gitlab_repository->isArtifactClosureAllowed(),\n                $integration_webhook !== null,\n                $create_branch_prefix\n            );\n        } catch (\n            GitlabResponseAPIException |\n            GitlabRepositoryAlreadyIntegratedInProjectException |\n            GitlabRepositoryWithSameNameAlreadyIntegratedInProjectException $exception\n        ) {\n            throw new RestException(400, $exception->getMessage());\n        } catch (GitlabRequestException $exception) {\n            throw new RestException(\n                $exception->getErrorCode(),\n                $exception->getMessage()\n            );\n        }\n    }\n\n    /**\n     * @url OPTIONS {id}\n     *\n     * @param int $id Id of the GitLab repository integration\n     */\n    public function optionsId(int $id): void\n    {\n        Header::allowOptionsPatchDelete();\n    }\n\n    /**\n     * Delete Gitlab Integrations.\n     *\n     * /!\\ This route is under construction.\n     * <br>\n     * Delete the given GitLab integration.\n     *\n     * @url    DELETE {id}\n     * @access protected\n     *\n     * @param int $id Id of the GitLab repository integration\n     *\n     * @status 204\n     *\n     * @throws RestException 400\n     * @throws RestException 401\n     * @throws RestException 404\n     */\n    protected function deleteGitlabRepository(int $id): void\n    {\n        $this->optionsId($id);\n\n        $repository_integration_factory = new GitlabRepositoryIntegrationFactory(\n            new GitlabRepositoryIntegrationDao(),\n            ProjectManager::instance()\n        );\n\n        $gitlab_repository_integration = $repository_integration_factory->getIntegrationById($id);\n\n        if ($gitlab_repository_integration === null) {\n            throw new RestException(404, \"Repository #$id not found.\");\n        }\n\n        $current_user          = UserManager::instance()->getCurrentUser();\n        $request_factory       = HTTPFactoryBuilder::requestFactory();\n        $stream_factory        = HTTPFactoryBuilder::streamFactory();\n        $gitlab_client_factory = new GitlabHTTPClientFactory(HttpClientFactory::createClient());\n        $gitlab_api_client     = new ClientWrapper($request_factory, $stream_factory, $gitlab_client_factory);\n\n        $deletor = new GitlabRepositoryDeletor(\n            $this->getGitPermissionsManager(),\n            new DBTransactionExecutorWithConnection(\n                DBFactory::getMainTuleapDBConnection()\n            ),\n            new WebhookDeletor(\n                new WebhookDao(),\n                $gitlab_api_client,\n                BackendLogger::getDefaultLogger(\\gitlabPlugin::LOG_IDENTIFIER)\n            ),\n            new GitlabRepositoryIntegrationDao(),\n            new IntegrationApiTokenDao(),\n            new CommitTuleapReferenceDao(),\n            new MergeRequestTuleapReferenceDao(),\n            new TagInfoDao(),\n            new BranchInfoDao(),\n            new CredentialsRetriever(new IntegrationApiTokenRetriever(new IntegrationApiTokenDao(), new KeyFactory())),\n            new CreateBranchPrefixDao()\n        );\n\n        try {\n            $deletor->deleteRepositoryIntegration(\n                $gitlab_repository_integration,\n                $current_user\n            );\n        } catch (GitUserNotAdminException $exception) {\n            throw new RestException(401, \"User is not Git administrator.\");\n        } catch (GitlabRepositoryNotInProjectException | GitlabRepositoryIntegrationNotFoundException $exception) {\n            throw new RestException(400, $exception->getMessage());\n        }\n    }\n\n    /**\n     * Update GitLab integration\n     *\n     * <pre>\n     * /!\\ This route is under construction and subject to changes /!\\\n     * </pre>\n     *\n     * <p>To update the API token, used by Tuleap to communicate with GitLab:</p>\n     * <pre>\n     * {<br>\n     *   &nbsp;\"update_bot_api_token\": {<br>\n     *   &nbsp;&nbsp;&nbsp;\"gitlab_api_token\" : \"The new token\"<br>\n     *   &nbsp;}<br>\n     *  }<br>\n     * </pre>\n     * <br>\n     * <p>\n     * <strong>Note:</strong> To ensure that the new token has needed access, it will regenerate the webhook used by GitLab.\n     * </p>\n     *\n     * <p>To update the webhook secret, used by GitLab to communicate with Tuleap:</p>\n     * <pre>\n     * {<br>\n     *   &nbsp;\"generate_new_secret\": true\n     * }<br>\n     * </pre>\n     *\n     * <p>To update the artifact closure option :</p>\n     * <pre>\n     * {<br>\n     *   &nbsp;\"allow_artifact_closure\" : false<br>\n     * }<br>\n     * </pre>\n     *\n     * <p>To update the prefix used in the branch creation (feature flag must be enabled):</p>\n     * <pre>\n     * {<br>\n     *   &nbsp;\"create_branch_prefix\" : \"dev-\"<br>\n     * }<br>\n     * </pre>\n     *\n     * <p>\n     * <strong>Note:</strong> You cannot do multiple actions at the same.\n     * You will get a <code>400</code> if you send either <code>update_bot_api_token</code> or <code>generate_new_secret</code> or <code>allow_artifact_closure</code> or <code>create_branch_prefix</code>.\n     * </p>\n     *\n     * @url    PATCH {id}\n     * @access protected\n     *\n     * @param int                                 $id                   Id of the Gitlab integration\n     * @param GitlabRepositoryPatchRepresentation $patch_representation {@from body}\n     *\n     * @return GitlabRepositoryRepresentation {@type GitlabRepositoryRepresentation}\n     *\n     * @throws RestException 401\n     * @throws RestException 404\n     * @throws RestException 500\n     */\n    protected function patchId(\n        int $id,\n        GitlabRepositoryPatchRepresentation $patch_representation,\n    ): GitlabRepositoryRepresentation {\n        $this->optionsId($id);\n\n        $request_factory       = HTTPFactoryBuilder::requestFactory();\n        $stream_factory        = HTTPFactoryBuilder::streamFactory();\n        $gitlab_client_factory = new GitlabHTTPClientFactory(HttpClientFactory::createClient());\n        $gitlab_api_client     = new ClientWrapper($request_factory, $stream_factory, $gitlab_client_factory);\n        $logger                = BackendLogger::getDefaultLogger(\\gitlabPlugin::LOG_IDENTIFIER);\n\n        $current_user = UserManager::instance()->getCurrentUser();\n\n        $this->validateJSONIsWellFormed($patch_representation);\n\n        if ($patch_representation->update_bot_api_token) {\n            $bot_api_token_updater = new BotApiTokenUpdater(\n                new GitlabRepositoryIntegrationFactory(\n                    new GitlabRepositoryIntegrationDao(),\n                    ProjectManager::instance()\n                ),\n                new GitlabProjectBuilder($gitlab_api_client),\n                $this->getGitPermissionsManager(),\n                new IntegrationApiTokenInserter(\n                    new IntegrationApiTokenDao(),\n                    new KeyFactory()\n                ),\n                new WebhookCreator(\n                    new KeyFactory(),\n                    new WebhookDao(),\n                    new WebhookDeletor(\n                        new WebhookDao(),\n                        $gitlab_api_client,\n                        BackendLogger::getDefaultLogger(\\gitlabPlugin::LOG_IDENTIFIER)\n                    ),\n                    $gitlab_api_client,\n                    $logger,\n                ),\n                $logger,\n            );\n\n            $bot_api_token_updater->update(\n                new ConcealedBotApiTokenPatchRepresentation(\n                    $id,\n                    new ConcealedString($patch_representation->update_bot_api_token->gitlab_api_token),\n                ),\n                $current_user,\n            );\n\n            return $this->buildUpdatedIntegrationRepresentation($id);\n        }\n\n        if ($patch_representation->generate_new_secret && $patch_representation->generate_new_secret === true) {\n            $generator = new WebhookSecretGenerator(\n                new GitlabRepositoryIntegrationFactory(\n                    new GitlabRepositoryIntegrationDao(),\n                    ProjectManager::instance()\n                ),\n                $this->getGitPermissionsManager(),\n                new CredentialsRetriever(\n                    new IntegrationApiTokenRetriever(\n                        new IntegrationApiTokenDao(),\n                        new KeyFactory()\n                    ),\n                ),\n                new WebhookCreator(\n                    new KeyFactory(),\n                    new WebhookDao(),\n                    new WebhookDeletor(\n                        new WebhookDao(),\n                        $gitlab_api_client,\n                        BackendLogger::getDefaultLogger(\\gitlabPlugin::LOG_IDENTIFIER)\n                    ),\n                    $gitlab_api_client,\n                    $logger,\n                )\n            );\n\n            $generator->regenerate($id, $current_user);\n\n            return $this->buildUpdatedIntegrationRepresentation($id);\n        }\n\n        if (isset($patch_representation->allow_artifact_closure)) {\n            $dao                                   = new GitlabRepositoryIntegrationDao();\n            $gitlab_repository_integration_factory =   new GitlabRepositoryIntegrationFactory(\n                $dao,\n                ProjectManager::instance()\n            );\n            $updater                               = new GitlabRepositoryIntegrationUpdator(\n                $dao,\n                $this->getGitPermissionsManager(),\n                $gitlab_repository_integration_factory,\n                new DBTransactionExecutorWithConnection(\n                    DBFactory::getMainTuleapDBConnection()\n                ),\n            );\n            try {\n                $updater->updateTuleapArtifactClosureOfAGitlabIntegration(\n                    $id,\n                    $patch_representation->allow_artifact_closure,\n                    $current_user\n                );\n\n                return $this->buildUpdatedIntegrationRepresentation($id);\n            } catch (GitUserNotAdminException $e) {\n                throw new RestException(401, \"User must be Git administrator.\");\n            } catch (GitlabRepositoryIntegrationNotFoundException $e) {\n                throw new RestException(404, $e->getMessage());\n            }\n        }\n\n        if ($patch_representation->create_branch_prefix !== null) {\n            $prefix_updater = new CreateBranchPrefixUpdater(\n                new GitlabRepositoryIntegrationFactory(\n                    new GitlabRepositoryIntegrationDao(),\n                    ProjectManager::instance(),\n                ),\n                $this->getGitPermissionsManager(),\n                new CreateBranchPrefixDao(),\n            );\n\n            try {\n                $prefix_updater->updateBranchPrefix(\n                    $current_user,\n                    $id,\n                    $patch_representation->create_branch_prefix\n                );\n\n                return $this->buildUpdatedIntegrationRepresentation($id);\n            } catch (InvalidBranchNameException $exception) {\n                throw new RestException(\n                    400,\n                    $exception->getMessage()\n                );\n            } catch (GitUserNotAdminException $exception) {\n                throw new RestException(401, \"User must be Git administrator.\");\n            }\n        }\n\n        throw new RestException(400, \"The JSON representation cannot be null\");\n    }\n\n    /**\n     * @url    OPTIONS {id}/branches\n     * @access protected\n     */\n    protected function optionBranches(int $id): void\n    {\n        Header::allowOptionsGet();\n    }\n\n    /**\n     * Get information on branches of the GitLab repository\n     *\n     * @url    GET {id}/branches\n     * @access protected\n     *\n     * @param int $id ID of the GitLab integration\n     *\n     *\n     * Only members of the project where the integration lives can access the branches information\n     *\n     * @throws RestException 404\n     */\n    protected function getBranches(int $id): BranchesInformationRepresentation\n    {\n        $this->optionBranches($id);\n\n        $branch_information_retriever = new GitlabBranchInformationRetriever(\n            new GitlabRepositoryIntegrationFactory(\n                new GitlabRepositoryIntegrationDao(),\n                ProjectManager::instance()\n            ),\n            new CredentialsRetriever(new IntegrationApiTokenRetriever(new IntegrationApiTokenDao(), new KeyFactory())),\n            new GitlabProjectBuilder(\n                new ClientWrapper(\n                    HTTPFactoryBuilder::requestFactory(),\n                    HTTPFactoryBuilder::streamFactory(),\n                    new GitlabHTTPClientFactory(HttpClientFactory::createClient())\n                )\n            )\n        );\n\n        return $branch_information_retriever->getBranchInformation(UserManager::instance()->getCurrentUser(), $id);\n    }\n\n    /**\n     * @throws RestException\n     */\n    private function buildUpdatedIntegrationRepresentation(int $id): GitlabRepositoryRepresentation\n    {\n        $dao                                   = new GitlabRepositoryIntegrationDao();\n        $gitlab_repository_integration_factory = new GitlabRepositoryIntegrationFactory(\n            $dao,\n            ProjectManager::instance()\n        );\n\n        $updated_gitlab_integration = $gitlab_repository_integration_factory->getIntegrationById($id);\n        if ($updated_gitlab_integration === null) {\n            throw new RestException(500, \"Updated repository not found, this must not happen\");\n        }\n\n        $webhook_dao         = new WebhookDao();\n        $integration_webhook = $webhook_dao->getGitlabRepositoryWebhook(\n            $updated_gitlab_integration->getId()\n        );\n\n        $create_branch_prefix = (new CreateBranchPrefixDao())->searchCreateBranchPrefixForIntegration($id);\n\n        return new GitlabRepositoryRepresentation(\n            $updated_gitlab_integration->getId(),\n            $updated_gitlab_integration->getGitlabRepositoryId(),\n            $updated_gitlab_integration->getName(),\n            $updated_gitlab_integration->getDescription(),\n            $updated_gitlab_integration->getGitlabRepositoryUrl(),\n            $updated_gitlab_integration->getLastPushDate()->getTimestamp(),\n            $updated_gitlab_integration->getProject(),\n            $updated_gitlab_integration->isArtifactClosureAllowed(),\n            $integration_webhook !== null,\n            $create_branch_prefix\n        );\n    }\n\n    private function getGitPermissionsManager(): GitPermissionsManager\n    {\n        $git_system_event_manager = new Git_SystemEventManager(\n            SystemEventManager::instance(),\n            new GitRepositoryFactory(\n                new GitDao(),\n                ProjectManager::instance()\n            )\n        );\n\n        $fine_grained_dao       = new FineGrainedDao();\n        $fine_grained_retriever = new FineGrainedRetriever($fine_grained_dao);\n\n        return new GitPermissionsManager(\n            new Git_PermissionsDao(),\n            $git_system_event_manager,\n            $fine_grained_dao,\n            $fine_grained_retriever\n        );\n    }\n\n    /**\n     * @throws RestException\n     */\n    private function getProjectById(int $project_id): Project\n    {\n        $project = ProjectManager::instance()->getProject($project_id);\n        if (! $project || $project->isError()) {\n            throw new RestException(404, \"Project #$project_id not found.\");\n        }\n\n        return $project;\n    }\n\n    /**\n     * @throws RestException\n     */\n    private function validateJSONIsWellFormed(GitlabRepositoryPatchRepresentation $patch_representation): void\n    {\n        $provided_parameter = 0;\n        foreach (get_object_vars($patch_representation) as $parameter) {\n            if ($parameter !== null) {\n                $provided_parameter++;\n            }\n        }\n\n        if ($provided_parameter > 1) {\n            throw new RestException(\n                400,\n                'You cannot ask at the same time to update the api token, generate a new webhook secret, allowing artifact closure or updating the create branch prefix.'\n            );\n        }\n    }\n}\n", "<?php\n/**\n * Copyright (c) Enalean, 2021 - present. All Rights Reserved.\n *\n * This file is a part of Tuleap.\n *\n * Tuleap is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * Tuleap is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Tuleap. If not, see http://www.gnu.org/licenses/.\n */\n\ndeclare(strict_types=1);\n\nnamespace Tuleap\\Gitlab\\Artifact\\Action;\n\nuse GitPermissionsManager;\nuse GitUserNotAdminException;\nuse Tuleap\\Git\\Branch\\InvalidBranchNameException;\nuse Tuleap\\Gitlab\\Repository\\GitlabRepositoryIntegrationFactory;\nuse Tuleap\\Gitlab\\Repository\\GitlabRepositoryIntegrationNotFoundException;\nuse Tuleap\\Gitlab\\Test\\Builder\\RepositoryIntegrationBuilder;\nuse Tuleap\\Gitlab\\Test\\Stubs\\SaveIntegrationBranchPrefixStub;\nuse Tuleap\\Test\\Builders\\UserTestBuilder;\nuse Tuleap\\Test\\PHPUnit\\TestCase;\n\nfinal class CreateBranchPrefixUpdaterTest extends TestCase\n{\n    private const INTEGRATION_ID = 18;\n    /**\n     * @var \\PHPUnit\\Framework\\MockObject\\MockObject&GitlabRepositoryIntegrationFactory\n     */\n    private $integration_factory;\n    private SaveIntegrationBranchPrefixStub $branch_prefix_saver;\n    private string $branch_prefix;\n    /**\n     * @var GitPermissionsManager&\\PHPUnit\\Framework\\MockObject\\MockObject\n     */\n    private $git_permissions_manager;\n\n    protected function setUp(): void\n    {\n        $this->integration_factory     = $this->createMock(GitlabRepositoryIntegrationFactory::class);\n        $this->git_permissions_manager = $this->createMock(GitPermissionsManager::class);\n        $this->branch_prefix_saver     = SaveIntegrationBranchPrefixStub::withCallCount();\n\n        $this->branch_prefix = 'dev-';\n    }\n\n    private function updateBranchPrefix(): void\n    {\n        $updater = new CreateBranchPrefixUpdater(\n            $this->integration_factory,\n            $this->git_permissions_manager,\n            $this->branch_prefix_saver,\n        );\n\n        $updater->updateBranchPrefix(\n            UserTestBuilder::anActiveUser()->build(),\n            self::INTEGRATION_ID,\n            $this->branch_prefix,\n        );\n    }\n\n    public function testItStoresTheBranchPrefix(): void\n    {\n        $this->integration_factory\n            ->expects(self::once())\n            ->method('getIntegrationById')\n            ->with(self::INTEGRATION_ID)\n            ->willReturn(RepositoryIntegrationBuilder::aGitlabRepositoryIntegration(self::INTEGRATION_ID)->build());\n\n        $this->git_permissions_manager\n            ->expects(self::once())\n            ->method('userIsGitAdmin')\n            ->willReturn(true);\n\n        $this->updateBranchPrefix();\n\n        self::assertSame(1, $this->branch_prefix_saver->getCallCount());\n    }\n\n    public function testItStoresTheBranchPrefixWithSomeSpecialChars(): void\n    {\n        $this->integration_factory\n            ->expects(self::once())\n            ->method('getIntegrationById')\n            ->with(self::INTEGRATION_ID)\n            ->willReturn(RepositoryIntegrationBuilder::aGitlabRepositoryIntegration(self::INTEGRATION_ID)->build());\n\n        $this->git_permissions_manager\n            ->expects(self::once())\n            ->method('userIsGitAdmin')\n            ->willReturn(true);\n\n        $this->branch_prefix = 'dev/';\n        $this->updateBranchPrefix();\n\n        self::assertSame(1, $this->branch_prefix_saver->getCallCount());\n    }\n\n    public function testItThrowsAnExceptionIfIntegrationNotFoundTheBranchPrefix(): void\n    {\n        $this->integration_factory\n            ->expects(self::once())\n            ->method('getIntegrationById')\n            ->with(self::INTEGRATION_ID)\n            ->willReturn(null);\n\n        $this->expectException(GitlabRepositoryIntegrationNotFoundException::class);\n        $this->updateBranchPrefix();\n\n        self::assertSame(0, $this->branch_prefix_saver->getCallCount());\n    }\n\n    public function testItThrowsAnExceptionIfUserIsNotGitAdministrator(): void\n    {\n        $this->integration_factory\n            ->expects(self::once())\n            ->method('getIntegrationById')\n            ->with(self::INTEGRATION_ID)\n            ->willReturn(RepositoryIntegrationBuilder::aGitlabRepositoryIntegration(self::INTEGRATION_ID)->build());\n\n        $this->git_permissions_manager\n            ->expects(self::once())\n            ->method('userIsGitAdmin')\n            ->willReturn(false);\n\n        $this->expectException(GitUserNotAdminException::class);\n        $this->updateBranchPrefix();\n\n        self::assertSame(0, $this->branch_prefix_saver->getCallCount());\n    }\n\n    public function testItThrowsAnExceptionIfBranchPrefixIsNotValid(): void\n    {\n        $this->integration_factory\n            ->expects(self::once())\n            ->method('getIntegrationById')\n            ->with(self::INTEGRATION_ID)\n            ->willReturn(RepositoryIntegrationBuilder::aGitlabRepositoryIntegration(self::INTEGRATION_ID)->build());\n\n        $this->git_permissions_manager\n            ->expects(self::once())\n            ->method('userIsGitAdmin')\n            ->willReturn(true);\n\n        $this->branch_prefix = 'dev:';\n\n        $this->expectException(InvalidBranchNameException::class);\n        $this->updateBranchPrefix();\n\n        self::assertSame(0, $this->branch_prefix_saver->getCallCount());\n    }\n}\n"], "filenames": ["plugins/gitlab/include/Artifact/Action/CreateBranchPrefixUpdater.php", "plugins/gitlab/include/REST/v1/GitlabRepositoryResource.php", "plugins/gitlab/tests/unit/Artifact/Action/CreateBranchPrefixUpdaterTest.php"], "buggy_code_start_loc": [23, 476, 24], "buggy_code_end_loc": [47, 492, 107], "fixing_code_start_loc": [24, 476, 25], "fixing_code_end_loc": [58, 497, 155], "type": "CWE-863", "message": "Tuleap is a Free & Open Source Suite to improve management of software developments and collaboration. In versions 12.9.99.228 and above, prior to 14.0.99.24, authorizations are not properly verified when updating the branch prefix used by the GitLab repository integration. Authenticated users can change the branch prefix of any of the GitLab repository integration they can see vie the REST endpoint `PATCH /gitlab_repositories/{id}`. This action should be restricted to Git administrators. This issue is patched in Tuleap Community Edition 14.0.99.24 and Tuleap Enterprise Edition 14.0-3. There are no known workarounds.", "other": {"cve": {"id": "CVE-2022-39233", "sourceIdentifier": "security-advisories@github.com", "published": "2022-10-19T11:15:11.160", "lastModified": "2022-10-21T16:57:54.080", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Tuleap is a Free & Open Source Suite to improve management of software developments and collaboration. In versions 12.9.99.228 and above, prior to 14.0.99.24, authorizations are not properly verified when updating the branch prefix used by the GitLab repository integration. Authenticated users can change the branch prefix of any of the GitLab repository integration they can see vie the REST endpoint `PATCH /gitlab_repositories/{id}`. This action should be restricted to Git administrators. This issue is patched in Tuleap Community Edition 14.0.99.24 and Tuleap Enterprise Edition 14.0-3. There are no known workarounds."}, {"lang": "es", "value": "Tuleap es una suite libre y de c\u00f3digo abierto para mejorar la administraci\u00f3n de los desarrollos de software y la colaboraci\u00f3n. En versiones 12.9.99.228 y superiores, anteriores a 14.0.99.24, las autorizaciones no son verificadas apropiadamente cuando es actualizado el prefijo de la rama usado por la integraci\u00f3n del repositorio GitLab. Los usuarios autenticados pueden cambiar el prefijo de rama de cualquiera de las integraciones de repositorios de GitLab que pueden visualizar mediante el endpoint REST \"PATCH /gitlab_repositories/{id}\". Esta acci\u00f3n deber\u00eda estar restringida a administradores de Git. Este problema est\u00e1 parcheado en Tuleap Community Edition versi\u00f3n 4.0.99.24 y Tuleap Enterprise Edition versi\u00f3n 14.0-3. No son conocidas mitigaciones"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-862"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:enalean:tuleap:*:*:*:*:community:*:*:*", "versionStartIncluding": "12.9.99.228", "versionEndExcluding": "14.0.99.24", "matchCriteriaId": "6D8CF699-74B7-4FEE-804C-1729780FA0EE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:enalean:tuleap:*:*:*:*:enterprise:*:*:*", "versionStartIncluding": "12.10", "versionEndExcluding": "13.12-6", "matchCriteriaId": "38FC5DF7-5EF5-4EE8-9B23-539CC0F8E6C9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:enalean:tuleap:*:*:*:*:enterprise:*:*:*", "versionStartIncluding": "14.0", "versionEndExcluding": "14.0-3", "matchCriteriaId": "B2BBE4EC-1B9E-44C6-A191-A23182941E2B"}]}]}], "references": [{"url": "https://github.com/Enalean/tuleap/commit/a06cb42d55c840d61a484472ed6b169ab23853ac", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Enalean/tuleap/security/advisories/GHSA-3884-972x-3ccq", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://tuleap.net/plugins/git/tuleap/tuleap/stable?a=commit&h=a06cb42d55c840d61a484472ed6b169ab23853ac", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://tuleap.net/plugins/tracker/?aid=28848", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/Enalean/tuleap/commit/a06cb42d55c840d61a484472ed6b169ab23853ac"}}