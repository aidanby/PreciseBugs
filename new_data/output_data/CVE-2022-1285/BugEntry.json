{"buggy_code": ["# Changelog\n\nAll notable changes to Gogs are documented in this file.\n\n## 0.13.0+dev (`main`)\n\n### Added\n\n- An unlisted option is added when create or migrate a repository. Unlisted repositories are public but not being listed for users without direct access in the UI. [#5733](https://github.com/gogs/gogs/issues/5733)\n- New configuration option `[git.timeout] DIFF` for customizing operation timeout of `git diff`. [#6315](https://github.com/gogs/gogs/issues/6315)\n- New configuration option `[server] SSH_SERVER_MACS` for setting list of accepted MACs for connections to builtin SSH server. [#6434](https://github.com/gogs/gogs/issues/6434)\n- Support specifying custom schema for PostgreSQL. [#6695](https://github.com/gogs/gogs/pull/6695)\n- Support rendering Mermaid diagrams in Markdown. [#6776](https://github.com/gogs/gogs/pull/6776)\n- New languages support: Mongolian. [#6510](https://github.com/gogs/gogs/pull/6510)\n\n### Changed\n\n- The default branch has been changed to `main`. [#6285](https://github.com/gogs/gogs/pull/6285)\n- MSSQL as database backend is deprecated, installation page no longer shows it as an option. Existing installations and manually craft configuration file continue to work. [#6295](https://github.com/gogs/gogs/pull/6295)\n- Use [Task](https://github.com/go-task/task) as the build tool. [#6297](https://github.com/gogs/gogs/pull/6297)\n- The required Go version to compile source code changed to 1.16.\n\n### Fixed\n\n- _Security:_ XSS in cookies. [#6953](https://github.com/gogs/gogs/issues/6953)\n- _Security:_ OS Command Injection in file uploading. [#6968](https://github.com/gogs/gogs/issues/6968)\n- _Security:_ Remote Command Execution in file editing. [#6555](https://github.com/gogs/gogs/issues/6555)\n- Unable to use LDAP authentication on ARM machines. [#6761](https://github.com/gogs/gogs/issues/6761)\n\n### Removed\n\n- \u26a0\ufe0f Migrations before 0.12 are removed, installations not on 0.12 should upgrade to it to run the migrations and then upgrade to 0.13.\n- Configuration section `[mailer]` is no longer used, please use `[email]`.\n- Configuration section `[service]` is no longer used, please use `[auth]`.\n- Configuration option `APP_NAME` is no longer used, please use `BRAND_NAME`.\n- Configuration option `[security] REVERSE_PROXY_AUTHENTICATION_USER` is no longer used, please use `[auth] REVERSE_PROXY_AUTHENTICATION_HEADER`.\n- Configuration option `[auth] ACTIVE_CODE_LIVE_MINUTES` is no longer used, please use `[auth] ACTIVATE_CODE_LIVES`.\n- Configuration option `[auth] RESET_PASSWD_CODE_LIVE_MINUTES` is no longer used, please use `[auth] RESET_PASSWORD_CODE_LIVES`.\n- Configuration option `[auth] ENABLE_CAPTCHA` is no longer used, please use `[auth] ENABLE_REGISTRATION_CAPTCHA`.\n- Configuration option `[auth] ENABLE_NOTIFY_MAIL` is no longer used, please use `[user] ENABLE_EMAIL_NOTIFICATION`.\n- Configuration option `[auth] REGISTER_EMAIL_CONFIRM` is no longer used, please use `[auth] REQUIRE_EMAIL_CONFIRMATION`.\n- Configuration option `[session] GC_INTERVAL_TIME` is no longer used, please use `[session] GC_INTERVAL`.\n- Configuration option `[session] SESSION_LIFE_TIME` is no longer used, please use `[session] MAX_LIFE_TIME`.\n- Configuration option `[server] ROOT_URL` is no longer used, please use `[server] EXTERNAL_URL`.\n- Configuration option `[server] LANDING_PAGE` is no longer used, please use `[server] LANDING_URL`.\n- Configuration option `[database] DB_TYPE` is no longer used, please use `[database] TYPE`.\n- Configuration option `[database] PASSWD` is no longer used, please use `[database] PASSWORD`.\n- Remove option to use Makefile as the build tool. [#6980](https://github.com/gogs/gogs/pull/6980)\n\n## 0.12.7\n\n### Fixed\n\n- _Security:_ Stored XSS in issues. [#6919](https://github.com/gogs/gogs/issues/6919)\n- Invalid character in `Access-Control-Allow-Credentials` response header. [#4983](https://github.com/gogs/gogs/issues/4983)\n- Mysterious `ssh: overflow reading version string` errors from builtin SSH server. [#6882](https://github.com/gogs/gogs/issues/6882)\n\n## 0.12.6\n\n### Fixed\n\n- _Security:_ Remote command execution in file uploading. [#6833](https://github.com/gogs/gogs/issues/6833)\n- _Regression:_ Unable to migrate repository from other local Git hosting. Added a new configuration option `[security] LOCAL_NETWORK_ALLOWLIST`, which is a comma separated list of hostnames that are explicitly allowed to be accessed within the local network. [#6841](https://github.com/gogs/gogs/issues/6841)\n- Slow start of Docker containers using NAS devices. [#6554](https://github.com/gogs/gogs/issues/6554)\n\n## 0.12.5\n\n### Fixed\n\n- _Security:_ Potential SSRF in repository migration. [#6754](https://github.com/gogs/gogs/issues/6754)\n- _Security:_ Improper PAM authorization handling. [#6810](https://github.com/gogs/gogs/issues/6810)\n\n## 0.12.4\n\n### Fixed\n\n- _Security:_ Potential SSRF attack by CRLF injection via repository migration. [#6413](https://github.com/gogs/gogs/issues/6413)\n- _Regression:_ Fixed smart links for issues stops rendering. [#6506](https://github.com/gogs/gogs/issues/6506)\n- Added `X-Frame-Options` header to prevent Clickjacking. [#6409](https://github.com/gogs/gogs/issues/6409)\n\n## 0.12.3\n\n### Fixed\n\n- _Regression:_ When running Gogs on Windows, push commits no longer fail on a daily basis with the error \"pre-receive hook declined\". [#6316](https://github.com/gogs/gogs/issues/6316)\n- Auto-linked commit SHAs now have correct links. [#6300](https://github.com/gogs/gogs/issues/6300)\n- Git LFS client (with version >= 2.5.0) wasn't able to upload files with known format (e.g. PNG, JPEG), and the server is expecting the HTTP Header `Content-Type` to be `application/octet-stream`. The server now tells the LFS client to always use `Content-Type: application/octet-stream` when upload files.\n\n## 0.12.2\n\n### Fixed\n\n- _Regression:_ Pages are correctly rendered when requesting `?go-get=1` for subdirectories. [#6314](https://github.com/gogs/gogs/issues/6314)\n- _Regression:_ Submodule with a relative path is linked correctly. [#6319](https://github.com/gogs/gogs/issues/6319)\n- Backup can be processed when `--target` is specified on Windows. [#6339](https://github.com/gogs/gogs/issues/6339)\n- Commit message contains keywords look like an issue reference no longer fails the push entirely. [#6289](https://github.com/gogs/gogs/issues/6289)\n\n## 0.12.1\n\n### Fixed\n\n- The `updated_at` field is now correctly updated when updates an issue. [#6209](https://github.com/gogs/gogs/issues/6209)\n- Fixed a regression which created `login_source.cfg` column to have `VARCHAR(255)` instead of `TEXT` in MySQL. [#6280](https://github.com/gogs/gogs/issues/6280)\n\n## 0.12.0\n\n### Added\n\n- Support for Git LFS, you can read documentation for both [user](https://github.com/gogs/gogs/blob/main/docs/user/lfs.md) and [admin](https://github.com/gogs/gogs/blob/main/docs/admin/lfs.md). [#1322](https://github.com/gogs/gogs/issues/1322)\n- Allow admin to remove observers from the repository. [#5803](https://github.com/gogs/gogs/pull/5803)\n- Use `Last-Modified` HTTP header for raw files. [#5811](https://github.com/gogs/gogs/issues/5811)\n- Support syntax highlighting for SAS code files (i.e. `.r`, `.sas`, `.tex`, `.yaml`). [#5856](https://github.com/gogs/gogs/pull/5856)\n- Able to fill in pull request title with a template. [#5901](https://github.com/gogs/gogs/pull/5901)\n- Able to override static files under `public/` directory, please refer to [documentation](https://gogs.io/docs/features/custom_template) for usage. [#5920](https://github.com/gogs/gogs/pull/5920)\n- New API endpoint `GET /admin/teams/:teamid/members` to list members of a team. [#5877](https://github.com/gogs/gogs/issues/5877)\n- Support backup with retention policy for Docker deployments. [#6140](https://github.com/gogs/gogs/pull/6140)\n\n### Changed\n\n- The organization profile page has changed to display at most 12 members. [#5506](https://github.com/gogs/gogs/issues/5506)\n- The required Go version to compile source code changed to 1.14.\n- All assets are now embedded into binary and served from memory by default. Set `[server] LOAD_ASSETS_FROM_DISK = true` to load them from disk. [#5920](https://github.com/gogs/gogs/pull/5920)\n- Application and Go versions are removed from page footer and only show in the admin dashboard.\n- Build tag for running as Windows Service has been changed from `miniwinsvc` to `minwinsvc`.\n- Configuration option `APP_NAME` is deprecated and will end support in 0.13.0, please start using `BRAND_NAME`.\n- Configuration option `[server] ROOT_URL` is deprecated and will end support in 0.13.0, please start using `[server] EXTERNAL_URL`.\n- Configuration option `[server] LANDING_PAGE` is deprecated and will end support in 0.13.0, please start using `[server] LANDING_URL`.\n- Configuration option `[database] DB_TYPE` is deprecated and will end support in 0.13.0, please start using `[database] TYPE`.\n- Configuration option `[database] PASSWD` is deprecated and will end support in 0.13.0, please start using `[database] PASSWORD`.\n- Configuration option `[security] REVERSE_PROXY_AUTHENTICATION_USER` is deprecated and will end support in 0.13.0, please start using `[auth] REVERSE_PROXY_AUTHENTICATION_HEADER`.\n- Configuration section `[mailer]` is deprecated and will end support in 0.13.0, please start using `[email]`.\n- Configuration section `[service]` is deprecated and will end support in 0.13.0, please start using `[auth]`.\n- Configuration option `[auth] ACTIVE_CODE_LIVE_MINUTES` is deprecated and will end support in 0.13.0, please start using `[auth] ACTIVATE_CODE_LIVES`.\n- Configuration option `[auth] RESET_PASSWD_CODE_LIVE_MINUTES` is deprecated and will end support in 0.13.0, please start using `[auth] RESET_PASSWORD_CODE_LIVES`.\n- Configuration option `[auth] REGISTER_EMAIL_CONFIRM` is deprecated and will end support in 0.13.0, please start using `[auth] REQUIRE_EMAIL_CONFIRMATION`.\n- Configuration option `[auth] ENABLE_CAPTCHA` is deprecated and will end support in 0.13.0, please start using `[auth] ENABLE_REGISTRATION_CAPTCHA`.\n- Configuration option `[auth] ENABLE_NOTIFY_MAIL` is deprecated and will end support in 0.13.0, please start using `[user] ENABLE_EMAIL_NOTIFICATION`.\n- Configuration option `[session] GC_INTERVAL_TIME` is deprecated and will end support in 0.13.0, please start using `[session] GC_INTERVAL`.\n- Configuration option `[session] SESSION_LIFE_TIME` is deprecated and will end support in 0.13.0, please start using `[session] MAX_LIFE_TIME`.\n- The name `-` is reserved and cannot be used for users or organizations.\n\n### Fixed\n\n- [Security] Potential open redirection with i18n.\n- [Security] Potential ability to delete files outside a repository.\n- [Security] Potential ability to set primary email on others' behalf from their verified emails.\n- [Security] Potential XSS attack via `.ipynb`. [#5170](https://github.com/gogs/gogs/issues/5170)\n- [Security] Potential SSRF attack via webhooks. [#5366](https://github.com/gogs/gogs/issues/5366)\n- [Security] Potential CSRF attack in admin panel. [#5367](https://github.com/gogs/gogs/issues/5367)\n- [Security] Potential stored XSS attack in some browsers. [#5397](https://github.com/gogs/gogs/issues/5397)\n- [Security] Potential RCE on mirror repositories. [#5767](https://github.com/gogs/gogs/issues/5767)\n- [Security] Potential XSS attack with raw markdown API. [#5907](https://github.com/gogs/gogs/pull/5907)\n- File both modified and renamed within a commit treated as separate files. [#5056](https://github.com/gogs/gogs/issues/5056)\n- Unable to restore the database backup to MySQL 8.0 with syntax error. [#5602](https://github.com/gogs/gogs/issues/5602)\n- Open/close milestone redirects to a 404 page. [#5677](https://github.com/gogs/gogs/issues/5677)\n- Disallow multiple tokens with same name. [#5587](https://github.com/gogs/gogs/issues/5587) [#5820](https://github.com/gogs/gogs/pull/5820)\n- Enable Federated Avatar Lookup could cause server to crash. [#5848](https://github.com/gogs/gogs/issues/5848)\n- Private repositories are hidden in the organization's view. [#5869](https://github.com/gogs/gogs/issues/5869)\n- Users have access to base repository cannot view commits in forks. [#5878](https://github.com/gogs/gogs/issues/5878)\n- Server error when changing email address in user settings page. [#5899](https://github.com/gogs/gogs/issues/5899)\n- Fall back to use RFC 3339 as time layout when misconfigured. [#6098](https://github.com/gogs/gogs/issues/6098)\n- Unable to update team with server error. [#6185](https://github.com/gogs/gogs/issues/6185)\n- Webhooks are not fired after push when `[service] REQUIRE_SIGNIN_VIEW = true`.\n- Files with identical content are randomly displayed one of them.\n\n### Removed\n\n- Configuration option `[other] SHOW_FOOTER_VERSION`\n- Configuration option `[server] STATIC_ROOT_PATH`\n- Configuration option `[repository] MIRROR_QUEUE_LENGTH`\n- Configuration option `[repository] PULL_REQUEST_QUEUE_LENGTH`\n- Configuration option `[session] ENABLE_SET_COOKIE`\n- Configuration option `[release.attachment] PATH`\n- Configuration option `[webhook] QUEUE_LENGTH`\n- Build tag `sqlite`, which means CGO is now required.\n\n---\n\n**Older change logs can be found on [GitHub](https://github.com/gogs/gogs/releases?after=v0.12.0).**\n", "app_desc = A painless self-hosted Git service\n\nhome = Home\ndashboard = Dashboard\nexplore = Explore\nhelp = Help\nsign_in = Sign In\nsign_out = Sign Out\nsign_up = Sign Up\nregister = Register\nwebsite = Website\npage = Page\ntemplate = Template\nlanguage = Language\ncreate_new = Create...\nuser_profile_and_more = User profile and more\nsigned_in_as = Signed in as\n\nusername = Username\nemail = Email\npassword = Password\nre_type = Re-Type\ncaptcha = Captcha\n\nrepository = Repository\norganization = Organization\nmirror = Mirror\nnew_repo = New Repository\nnew_migrate = New Migration\nnew_mirror = New Mirror\nnew_fork = New Fork Repository\nnew_org = New Organization\nmanage_org = Manage Organizations\nadmin_panel = Admin Panel\naccount_settings = Account Settings\nsettings = Settings\nyour_profile = Your Profile\nyour_settings = Your Settings\n\nactivities = Activities\npull_requests = Pull Requests\nissues = Issues\n\ncancel = Cancel\n\n[status]\npage_not_found = Page Not Found\ninternal_server_error = Internal Server Error\n\n[install]\ninstall = Installation\ntitle = Install Steps For First-time Run\ndocker_helper = If you're running Gogs inside Docker, please read <a target=\"_blank\" href=\"%s\">Guidelines</a> carefully before you change anything in this page!\nrequite_db_desc = Gogs requires MySQL, PostgreSQL, SQLite3 or TiDB (via MySQL protocol).\ndb_title = Database Settings\ndb_type = Database Type\nhost = Host\nuser = User\npassword = Password\ndb_name = Database Name\ndb_schema = Schema\ndb_helper = Please use INNODB engine with utf8_general_ci charset for MySQL.\nssl_mode = SSL Mode\npath = Path\nsqlite_helper = The file path of SQLite3 database. <br>Please use absolute path when you start as service.\nerr_empty_db_path = SQLite3 database path cannot be empty.\nno_admin_and_disable_registration = You cannot disable registration without creating an admin account.\nerr_empty_admin_password = Admin password cannot be empty.\n\ngeneral_title = Application General Settings\napp_name = Application Name\napp_name_helper = Put your organization name here huge and loud!\nrepo_path = Repository Root Path\nrepo_path_helper = All Git remote repositories will be saved to this directory.\nrun_user = Run User\nrun_user_helper = The user must have access to Repository Root Path and run Gogs.\ndomain = Domain\ndomain_helper = This affects SSH clone URLs.\nssh_port = SSH Port\nssh_port_helper = Port number which your SSH server is using, leave it empty to disable SSH feature.\nuse_builtin_ssh_server = Use Builtin SSH Server\nuse_builtin_ssh_server_popup = Start builtin SSH server for Git operations to distinguish from system SSH daemon.\nhttp_port = HTTP Port\nhttp_port_helper = Port number which application will listen on.\napp_url = Application URL\napp_url_helper = This affects HTTP/HTTPS clone URL and somewhere in email.\nlog_root_path = Log Path\nlog_root_path_helper = Directory to write log files to.\nenable_console_mode = Enable Console Mode\nenable_console_mode_popup = In addition to file mode, also print logs to console.\n\noptional_title = Optional Settings\nemail_title = Email Service Settings\nsmtp_host = SMTP Host\nsmtp_from = From\nsmtp_from_helper = Mail from address, RFC 5322. It can be just an email address, or the \"Name\" <email@example.com> format.\nmailer_user = Sender Email\nmailer_password = Sender Password\nregister_confirm = Enable Register Confirmation\nmail_notify = Enable Mail Notification\nserver_service_title = Server and Other Services Settings\noffline_mode = Enable Offline Mode\noffline_mode_popup = Disable CDN even in production mode, all resource files will be served locally.\ndisable_gravatar = Disable Gravatar Service\ndisable_gravatar_popup = Disable Gravatar and custom sources, all avatars are uploaded by users or default.\nfederated_avatar_lookup = Enable Federated Avatars Lookup\nfederated_avatar_lookup_popup = Enable federated avatars lookup to use federated open source service based on libravatar.\ndisable_registration = Disable Self-registration\ndisable_registration_popup = Disable user self-registration, only admin can create accounts.\nenable_captcha = Enable Captcha\nenable_captcha_popup = Require validate captcha for user self-registration.\nrequire_sign_in_view = Enable Require Sign In to View Pages\nrequire_sign_in_view_popup = Only signed in users can view pages, visitors will only be able to see sign in/up pages.\nadmin_setting_desc = You don't need to create an admin account right now. The first user in the users table will be automatically granted admin access.\nadmin_title = Admin Account Settings\nadmin_name = Username\nadmin_password = Password\nconfirm_password = Confirm Password\nadmin_email = Admin Email\ninstall_gogs = Install Gogs\ntest_git_failed = Failed to test 'git' command: %v\nsqlite3_not_available = Your release version does not support SQLite3, please download the official binary version from %s, NOT the gobuild version.\ninvalid_db_setting = Database setting is not correct: %v\ninvalid_repo_path = Repository root path is invalid: %v\nrun_user_not_match = Run user isn't the current user: %s -> %s\nsmtp_host_missing_port = SMTP Host port missing from address.\ninvalid_smtp_from = SMTP From field is invalid: %v\nsave_config_failed = Failed to save configuration: %v\ninit_failed = Failed to initialize application: %v\ninvalid_admin_setting = Admin account setting is invalid: %v\ninstall_success = Welcome! We're glad that you chose Gogs, have fun and take care.\ninvalid_log_root_path = Log root path is invalid: %v\n\n[home]\nuname_holder = Username or email\npassword_holder = Password\nswitch_dashboard_context = Switch Dashboard Context\nmy_repos = My Repositories\nshow_more_repos = Show more repositories...\ncollaborative_repos = Collaborative Repositories\nmy_orgs = My Organizations\nmy_mirrors = My Mirrors\nview_home = View %s\n\nissues.in_your_repos = In your repositories\n\n[explore]\nrepos = Repositories\nusers = Users\norganizations = Organizations\nsearch = Search\n\n[auth]\ncreate_new_account = Create New Account\nregister_hepler_msg = Already have an account? Sign in now!\nsocial_register_hepler_msg = Already have an account? Bind now!\ndisable_register_prompt = Sorry, registration has been disabled. Please contact the site administrator.\ndisable_register_mail = Sorry, email services are disabled. Please contact the site administrator.\nauth_source = Authentication Source\nlocal = Local\nremember_me = Remember Me\nforgot_password= Forgot Password\nforget_password = Forgot password?\nsign_up_now = Need an account? Sign up now.\nconfirmation_mail_sent_prompt = A new confirmation email has been sent to <b>%s</b>, please check your inbox within the next %d hours to complete the registration process.\nactive_your_account = Activate Your Account\nprohibit_login = Login Prohibited\nprohibit_login_desc = Your account is prohibited from logging in. Please contact the site admin.\nresent_limit_prompt = Sorry, you already requested an activation email recently. Please wait 3 minutes then try again.\nhas_unconfirmed_mail = Hi %s, you have an unconfirmed email address (<b>%s</b>). If you haven't received a confirmation email or need to receive a new one, please click the button below.\nresend_mail = Click here to resend your activation email\nsend_reset_mail = Click here to (re)send your password reset email\nreset_password = Reset Your Password\ninvalid_code = Sorry, your confirmation code has expired or not valid.\nreset_password_helper = Click here to reset your password\npassword_too_short = Password length must be at least 6 characters.\nnon_local_account = Non-local accounts cannot change passwords through Gogs.\n\nlogin_two_factor = Two-factor Authentication\nlogin_two_factor_passcode = Authentication Passcode\nlogin_two_factor_enter_recovery_code = Enter a two-factor recovery code\nlogin_two_factor_recovery = Two-factor Recovery\nlogin_two_factor_recovery_code = Recovery Code\nlogin_two_factor_enter_passcode = Enter a two-factor passcode\nlogin_two_factor_invalid_recovery_code = Recovery code already used or invalid.\n\n[mail]\nactivate_account = Please activate your account\nactivate_email = Verify your email address\nreset_password = Reset your password\nregister_success = Registration successful, welcome\nregister_notify = Welcome on board\n\n[modal]\nyes = Yes\nno = No\nmodify = Modify\n\n[form]\nUserName = Username\nRepoName = Repository name\nEmail = Email address\nPassword = Password\nRetype = Re-type password\nSSHTitle = SSH key name\nHttpsUrl = HTTPS URL\nPayloadUrl = Payload URL\nTeamName = Team name\nAuthName = Authorization name\nAdminEmail = Admin email\n\nNewBranchName = New branch name\nCommitSummary = Commit summary\nCommitMessage = Commit message\nCommitChoice = Commit choice\nTreeName = File path\nContent = Content\n\nrequire_error = ` cannot be empty.`\nalpha_dash_error = ` must be alphanumeric or dash(-_) characters.`\nalpha_dash_dot_error = ` must be alphanumeric or dash(-_) or dot characters.`\nalpha_dash_dot_slash_error = ` must be alphanumeric, dash (-_), dot or slash characters.`\nsize_error  = ` size must be %s.`\nmin_size_error = ` must contain at least %s characters.`\nmax_size_error = ` must contain at most %s characters.`\nemail_error = ` is not a valid email address.`\nurl_error = ` is not a valid URL.`\ninclude_error = ` must contain substring '%s'.`\nunknown_error = Unknown error:\ncaptcha_incorrect = Captcha didn't match.\npassword_not_match = Password and confirm password are not same.\n\nusername_been_taken = Username has already been taken.\nrepo_name_been_taken = Repository name has already been taken.\norg_name_been_taken = Organization name has already been taken.\nteam_name_been_taken = Team name has already been taken.\nemail_been_used = Email address has already been used.\nusername_password_incorrect = Username or password is not correct.\nauth_source_mismatch = The authentication source selected is not associated with the user.\nenterred_invalid_repo_name = Please make sure that the repository name you entered is correct.\nenterred_invalid_owner_name = Please make sure that the owner name you entered is correct.\nenterred_invalid_password = Please make sure the that password you entered is correct.\nuser_not_exist = Given user does not exist.\nlast_org_owner = Removing the last remaining user from an owner team is not allowed, as an organization must always have at least one owner.\n\ninvalid_ssh_key = Sorry, verification of your SSH key failed: %s\nunable_verify_ssh_key = Gogs cannot verify your SSH key, but it's assumed to be valid. Please double-check it.\nauth_failed = Authentication failed: %v\n\nstill_own_repo = Your account still has ownership over at least one repository, you have to delete or transfer them first.\nstill_has_org = Your account still has membership in at least one organization, you have to leave or delete your memberships first.\norg_still_own_repo = This organization still has ownership of repositories, you must delete or transfer them first.\n\ntarget_branch_not_exist = Target branch does not exist.\n\n[user]\nchange_avatar = Change your avatar\njoin_on = Joined on\nrepositories = Repositories\nactivity = Public Activity\nfollowers = Followers\nstarred = Starred repositories\nfollowing = Following\nfollow = Follow\nunfollow = Unfollow\n\nform.name_not_allowed = User name or pattern %q is not allowed.\n\n[settings]\nprofile = Profile\npassword = Password\navatar = Avatar\nssh_keys = SSH Keys\nsecurity = Security\nrepos = Repositories\norgs = Organizations\napplications = Applications\ndelete = Delete Account\n\npublic_profile = Public Profile\nprofile_desc = Your email address is public and will be used for any account related notifications, and any web based operations made via the site.\npassword_username_disabled = Non-local type users are not allowed to change their username.\nfull_name = Full Name\nwebsite = Website\nlocation = Location\nupdate_profile = Update Profile\nupdate_profile_success = Your profile has been updated successfully.\nchange_username = Username Changed\nchange_username_prompt = This change will affect the way how links relate to your account.\ncontinue = Continue\ncancel = Cancel\n\nlookup_avatar_by_mail = Lookup Avatar by mail\nfederated_avatar_lookup = Federated Avatar Lookup\nenable_custom_avatar = Use Custom Avatar\nchoose_new_avatar = Choose new avatar\nupdate_avatar = Update Avatar Setting\ndelete_current_avatar = Delete Current Avatar\nuploaded_avatar_not_a_image = Uploaded file is not a image.\nupdate_avatar_success = Your avatar setting has been updated successfully.\n\nchange_password = Change Password\nold_password = Current Password\nnew_password = New Password\nretype_new_password = Retype New Password\npassword_incorrect = Current password is not correct.\nchange_password_success = Your password was successfully changed and can now be used for logging in.\npassword_change_disabled = Non-local type users are not allowed to change their password.\n\nemails = Email Addresses\nmanage_emails = Manage email addresses\nemail_desc = Your primary email address will be used for notifications and other operations.\nprimary = Primary\nprimary_email = Set as primary\ndelete_email = Delete\nemail_deletion = Email Deletion\nemail_deletion_desc = Deleting this email address will remove related information from your account. Do you want to continue?\nemail_deletion_success = Email has been deleted successfully!\nadd_new_email = Add new email address\nadd_email = Add Email\nadd_email_confirmation_sent = A new confirmation email has been sent to '%s', please check your inbox within the next %d hours to complete the confirmation process.\nadd_email_success = Your new email address was successfully added.\n\nmanage_ssh_keys = Manage SSH Keys\nadd_key = Add Key\nssh_desc = This is a list of SSH keys associated with your account. As these keys allow anyone using them to gain access to your repositories, it is highly important that you make sure you recognize them.\nssh_helper = <strong>Don't know how?</strong> Check out GitHub's guide to <a href=\"%s\">create your own SSH keys</a> or solve <a href=\"%s\">common problems</a> you might encounter using SSH.\nadd_new_key = Add SSH Key\nssh_key_been_used = Public key content has been used.\nssh_key_name_used = Public key with same name has already existed.\nkey_name = Key Name\nkey_content = Content\nadd_key_success = New SSH key '%s' has been added successfully!\ndelete_key = Delete\nssh_key_deletion = SSH Key Deletion\nssh_key_deletion_desc = Delete this SSH key will remove all related accesses for your account. Do you want to continue?\nssh_key_deletion_success = SSH key has been deleted successfully!\nadd_on = Added on\nlast_used = Last used on\nno_activity = No recent activity\nkey_state_desc = This key is used in last 7 days\ntoken_state_desc = This token is used in last 7 days\n\ntwo_factor = Two-factor Authentication\ntwo_factor_status = Status:\ntwo_factor_on = On\ntwo_factor_off = Off\ntwo_factor_enable = Enable\ntwo_factor_disable = Disable\ntwo_factor_view_recovery_codes = View and save <a href=\"%s%s\">your recovery codes</a> in a safe place. You can use them as passcode if you lose access to your authentication application.\ntwo_factor_http = For HTTP/HTTPS operations, you are no longer able to use plain username and password. Please create and use <a href=\"%[1]s%[2]s\">Personal Access Token</a> as your credential, e.g. <code>%[3]s</code>.\ntwo_factor_enable_title = Enable Two-factor Authentication\ntwo_factor_scan_qr = Please use your authentication application to scan the image:\ntwo_factor_or_enter_secret = Or enter the secret:\ntwo_factor_then_enter_passcode = Then enter passcode:\ntwo_factor_verify = Verify\ntwo_factor_invalid_passcode = The passcode you entered is not valid, please try again!\ntwo_factor_reused_passcode = The passcode you entered has already been used, please try another one!\ntwo_factor_enable_error = Enable Two-factor authentication failed: %v\ntwo_factor_enable_success = Two-factor authentication has enabled for your account successfully!\ntwo_factor_recovery_codes_title = Two-factor Authentication Recovery Codes\ntwo_factor_recovery_codes_desc = Recovery codes are used when you temporarily lose access to your authentication application. Each recovery code can only be used once, <b>please keep these codes in a safe place</b>.\ntwo_factor_regenerate_recovery_codes = Regenerate Recovery Codes\ntwo_factor_regenerate_recovery_codes_error = Regenerate recovery codes failed: %v\ntwo_factor_regenerate_recovery_codes_success = New recovery codes has been generated successfully!\ntwo_factor_disable_title = Disable Two-factor Authentication\ntwo_factor_disable_desc = Your account security level will decrease after disabled two-factor authentication. Do you want to continue?\ntwo_factor_disable_success = Two-factor authentication has disabled successfully!\n\nmanage_access_token = Manage Personal Access Tokens\ngenerate_new_token = Generate New Token\ntokens_desc = Tokens you have generated that can be used to access the Gogs APIs.\nnew_token_desc = Each token will have full access to your account.\ntoken_name = Token Name\ngenerate_token = Generate Token\ngenerate_token_succees = Your access token was successfully generated! Make sure to copy it right now, as you won't be able to see it again later!\ndelete_token = Delete\naccess_token_deletion = Personal Access Token Deletion\naccess_token_deletion_desc = Delete this personal access token will remove all related accesses of application. Do you want to continue?\ndelete_token_success = Personal access token has been removed successfully! Don't forget to update your application as well.\ntoken_name_exists = Token with same name already exists.\n\norgs.none = You are not a member of any organizations.\norgs.leave_title = Leave organization\norgs.leave_desc = You will lose access to all repositories and teams after you left the organization. Do you want to continue?\n\nrepos.leave = Leave\nrepos.leave_title = Leave repository\nrepos.leave_desc = You will lose access to the repository after you left. Do you want to continue?\nrepos.leave_success = You have left repository '%s' successfully!\n\ndelete_account = Delete Your Account\ndelete_prompt = The operation will delete your account permanently, and <strong>CANNOT</strong> be undone!\nconfirm_delete_account = Confirm Deletion\ndelete_account_title = Account Deletion\ndelete_account_desc = This account is going to be deleted permanently, do you want to continue?\n\n[repo]\nowner = Owner\nrepo_name = Repository Name\nrepo_name_helper = A good repository name is usually composed of short, memorable and unique keywords.\nvisibility = Visibility\nunlisted = Unlisted\nvisiblity_helper = This repository is <span class=\"ui red text\">Private</span>\nunlisted_helper = This repository is <span class=\"ui red text\">Unlisted</span>\nvisiblity_helper_forced = Site admin has forced all new repositories to be <span class=\"ui red text\">Private</span>\nvisiblity_fork_helper = (Change of this value will affect all forks)\nclone_helper = Need help cloning? Visit <a target=\"_blank\" href=\"%s\">Help</a>!\nfork_repo = Fork Repository\nfork_from = Fork From\nfork_visiblity_helper = You cannot alter the visibility of a forked repository.\nrepo_desc = Description\nrepo_lang = Language\nrepo_gitignore_helper = Select .gitignore templates\nlicense = License\nlicense_helper = Select a license file\nreadme = Readme\nreadme_helper = Select a readme template\nauto_init = Initialize this repository with selected files and template\ncreate_repo = Create Repository\ndefault_branch = Default Branch\nmirror_prune = Prune\nmirror_prune_desc = Remove any remote-tracking references that no longer exist on the remote\nmirror_interval = Mirror Interval (hour)\nmirror_address = Mirror Address\nmirror_address_desc = Please include necessary user credentials in the address.\nmirror_last_synced = Last Synced\nwatchers = Watchers\nstargazers = Stargazers\nforks = Forks\nrepo_description_helper = Description of repository. Maximum 512 characters length.\nrepo_description_length = Available characters\n\nform.reach_limit_of_creation = The owner has reached maximum creation limit of %d repositories.\nform.name_not_allowed = Repository name or pattern %q is not allowed.\n\nneed_auth = Need Authorization\nmigrate_type = Migration Type\nmigrate_type_helper = This repository will be a <span class=\"text blue\">mirror</span>\nmigrate_repo = Migrate Repository\nmigrate.clone_address = Clone Address\nmigrate.clone_address_desc = This can be a HTTP/HTTPS/GIT URL.\nmigrate.clone_address_desc_import_local = You're also allowed to migrate a repository by local server path.\nmigrate.permission_denied = You are not allowed to import local repositories.\nmigrate.invalid_local_path = Invalid local path, it does not exist or not a directory.\nmigrate.failed = Migration failed: %v\n\nmirror_from = mirror of\nforked_from = forked from\ncopy_link = Copy\ncopy_link_success = Copied!\ncopy_link_error = Press \u2318-C or Ctrl-C to copy\ncopied = Copied OK\nunwatch = Unwatch\nwatch = Watch\nunstar = Unstar\nstar = Star\nfork = Fork\n\nno_desc = No Description\nquick_guide = Quick Guide\nclone_this_repo = Clone this repository\ncreate_new_repo_command = Create a new repository on the command line\npush_exist_repo = Push an existing repository from the command line\nbare_message = This repository does not have any content yet.\n\nfiles = Files\nbranch = Branch\ntree = Tree\nfilter_branch_and_tag = Filter branch or tag\nbranches = Branches\ntags = Tags\nissues = Issues\npulls = Pull Requests\nlabels = Labels\nmilestones = Milestones\ncommits = Commits\ngit_branches = Branches\nreleases = Releases\nfile_raw = Raw\nfile_history = History\nfile_view_raw = View Raw\nfile_permalink = Permalink\nfile_too_large = This file is too large to be shown\nvideo_not_supported_in_browser = Your browser doesn't support HTML5 video tag.\n\nbranches.overview = Overview\nbranches.active_branches = Active Branches\nbranches.stale_branches = Stale Branches\nbranches.all = All Branches\nbranches.updated_by = Updated %[1]s by %[2]s\nbranches.change_default_branch = Change Default Branch\n\neditor.new_file = New file\neditor.upload_file = Upload file\neditor.edit_file = Edit file\neditor.preview_changes = Preview Changes\neditor.cannot_edit_non_text_files = Cannot edit non-text files\neditor.edit_this_file = Edit this file\neditor.must_be_on_a_branch = You must be on a branch to make or propose changes to this file\neditor.fork_before_edit = You must fork this repository before editing the file\neditor.delete_this_file = Delete this file\neditor.must_have_write_access = You must have write access to make or propose changes to this file\neditor.file_delete_success = File '%s' has been deleted successfully!\neditor.name_your_file = Name your file...\neditor.filename_help = To add directory, just type it and press /. To remove a directory, go to the beginning of the field and press backspace.\neditor.or = or\neditor.cancel_lower = cancel\neditor.commit_changes = Commit Changes\neditor.add_tmpl = Add '%s/<filename>'\neditor.add = Add '%s'\neditor.update = Update '%s'\neditor.delete = Delete '%s'\neditor.commit_message_desc = Add an optional extended description...\neditor.commit_directly_to_this_branch = Commit directly to the <strong class=\"branch-name\">%s</strong> branch.\neditor.create_new_branch = Create a <strong>new branch</strong> for this commit and start a pull request.\neditor.new_branch_name_desc = New branch name...\neditor.cancel = Cancel\neditor.filename_cannot_be_empty = Filename cannot be empty.\neditor.branch_already_exists = Branch '%s' already exists in this repository.\neditor.directory_is_a_file = Entry '%s' in the parent path is a file not a directory in this repository.\neditor.file_is_a_symlink = The file '%s' is a symlink that cannot be modified from the web editor.\neditor.filename_is_a_directory = The filename '%s' is an existing directory in this repository.\neditor.file_editing_no_longer_exists = The file '%s' you are editing no longer exists in the repository.\neditor.file_changed_while_editing = File content has been changed since you started editing. <a target=\"_blank\" href=\"%s\">Click here</a> to see what have been changed or <strong>press commit again</strong> to overwrite those changes.\neditor.file_already_exists = A file with name '%s' already exists in this repository.\neditor.no_changes_to_show = There are no changes to show.\neditor.fail_to_update_file = Failed to update/create file '%s' with error: %v\neditor.fail_to_delete_file = Failed to delete file '%s' with error: %v\neditor.add_subdir = Add subdirectory...\neditor.unable_to_upload_files = Failed to upload files to '%s' with error: %v\neditor.upload_files_to_dir = Upload files to '%s'\n\ncommits.commit_history = Commit History\ncommits.commits = Commits\ncommits.search = Search commits\ncommits.find = Find\ncommits.author = Author\ncommits.message = Message\ncommits.date = Date\ncommits.older = Older\ncommits.newer = Newer\n\nissues.new = New Issue\nissues.new.labels = Labels\nissues.new.no_label = No Label\nissues.new.clear_labels = Clear labels\nissues.new.milestone = Milestone\nissues.new.no_milestone = No Milestone\nissues.new.clear_milestone = Clear milestone\nissues.new.open_milestone = Open Milestones\nissues.new.closed_milestone = Closed Milestones\nissues.new.assignee = Assignee\nissues.new.clear_assignee = Clear assignee\nissues.new.no_assignee = No assignee\nissues.create = Create Issue\nissues.new_label = New Label\nissues.new_label_placeholder = Label name...\nissues.create_label = Create Label\nissues.label_templates.title = Load a predefined set of labels\nissues.label_templates.info = There aren't any labels yet. You can click on the \"New Label\" button above to create one or use a predefined set below.\nissues.label_templates.helper = Select a label set\nissues.label_templates.use = Use this label set\nissues.label_templates.fail_to_load_file = Failed to load label template file '%s': %v\nissues.open_tab = %d Open\nissues.close_tab = %d Closed\nissues.filter_label = Label\nissues.filter_label_no_select = No selected label\nissues.filter_milestone = Milestone\nissues.filter_milestone_no_select = No selected milestone\nissues.filter_assignee = Assignee\nissues.filter_assginee_no_select = No selected Assignee\nissues.filter_type = Type\nissues.filter_type.all_issues = All issues\nissues.filter_type.assigned_to_you = Assigned to you\nissues.filter_type.created_by_you = Created by you\nissues.filter_type.mentioning_you = Mentioning you\nissues.filter_sort = Sort\nissues.filter_sort.latest = Newest\nissues.filter_sort.oldest = Oldest\nissues.filter_sort.recentupdate = Recently updated\nissues.filter_sort.leastupdate = Least recently updated\nissues.filter_sort.mostcomment = Most commented\nissues.filter_sort.leastcomment = Least commented\nissues.opened_by = opened %[1]s by <a href=\"%[2]s\">%[3]s</a>\nissues.opened_by_fake = opened %[1]s by %[2]s\nissues.previous = Previous\nissues.next = Next\nissues.open_title = Open\nissues.closed_title = Closed\nissues.num_comments = %d comments\nissues.commented_at = `commented <a href=\"#%s\">%s</a>`\nissues.delete_comment_confirm = Are you sure you want to delete this comment?\nissues.no_content = There is no content yet.\nissues.close_issue = Close\nissues.close_comment_issue = Comment and close\nissues.reopen_issue = Reopen\nissues.reopen_comment_issue = Comment and reopen\nissues.create_comment = Comment\nissues.closed_at = `closed <a id=\"%[1]s\" href=\"#%[1]s\">%[2]s</a>`\nissues.reopened_at = `reopened <a id=\"%[1]s\" href=\"#%[1]s\">%[2]s</a>`\nissues.commit_ref_at = `referenced this issue from a commit <a id=\"%[1]s\" href=\"#%[1]s\">%[2]s</a>`\nissues.poster = Poster\nissues.collaborator = Collaborator\nissues.owner = Owner\nissues.sign_in_require_desc = <a href=\"%s\">Sign in</a> to join this conversation.\nissues.edit = Edit\nissues.cancel = Cancel\nissues.save = Save\nissues.label_title = Label name\nissues.label_color = Label color\nissues.label_count = %d labels\nissues.label_open_issues = %d open issues\nissues.label_edit = Edit\nissues.label_delete = Delete\nissues.label_modify = Label Modification\nissues.label_deletion = Label Deletion\nissues.label_deletion_desc = Deleting this label will remove its information in all related issues. Do you want to continue?\nissues.label_deletion_success = Label has been deleted successfully!\nissues.num_participants = %d Participants\nissues.attachment.open_tab = `Click to see \"%s\" in a new tab`\nissues.attachment.download = `Click to download \"%s\"`\n\npulls.new = New Pull Request\npulls.compare_changes = Compare Changes\npulls.compare_changes_desc = Compare two branches and make a pull request for changes.\npulls.compare_base = base\npulls.compare_compare = compare\npulls.filter_branch = Filter branch\npulls.no_results = No results found.\npulls.nothing_to_compare = There is nothing to compare because base and head branches are even.\npulls.nothing_merge_base = There is nothing to compare because two branches have completely different history.\npulls.has_pull_request = `There is already a pull request between these two targets: <a href=\"%[1]s/pulls/%[3]d\">%[2]s#%[3]d</a>`\npulls.create = Create Pull Request\npulls.title_desc = wants to merge %[1]d commits from <code>%[2]s</code> into <code>%[3]s</code>\npulls.merged_title_desc = merged %[1]d commits from <code>%[2]s</code> into <code>%[3]s</code> %[4]s\npulls.tab_conversation = Conversation\npulls.tab_commits = Commits\npulls.tab_files = Files changed\npulls.reopen_to_merge = Please reopen this pull request to perform merge operation.\npulls.merged = Merged\npulls.has_merged = This pull request has been merged successfully!\npulls.data_broken = Data of this pull request has been broken due to deletion of fork information.\npulls.is_checking = The conflict checking is still in progress, please refresh page in few moments.\npulls.can_auto_merge_desc = This pull request can be merged automatically.\npulls.cannot_auto_merge_desc = This pull request can't be merged automatically because there are conflicts.\npulls.cannot_auto_merge_helper = Please merge manually in order to resolve the conflicts.\npulls.create_merge_commit = Create a merge commit\npulls.rebase_before_merging = Rebase before merging\npulls.commit_description = Commit Description\npulls.merge_pull_request = Merge Pull Request\npulls.open_unmerged_pull_exists = `You can't perform reopen operation because there is already an open pull request (#%d) from same repository with same merge information and is waiting for merging.`\npulls.delete_branch = Delete Branch\npulls.delete_branch_has_new_commits = Branch cannot be deleted because it has new commits after mergence.\n\nmilestones.new = New Milestone\nmilestones.open_tab = %d Open\nmilestones.close_tab = %d Closed\nmilestones.closed = Closed %s\nmilestones.no_due_date = No due date\nmilestones.open = Open\nmilestones.close = Close\nmilestones.new_subheader = Create milestones to organize your issues.\nmilestones.create = Create Milestone\nmilestones.title = Title\nmilestones.desc = Description\nmilestones.due_date = Due Date (optional)\nmilestones.clear = Clear\nmilestones.invalid_due_date_format = Due date format is invalid, must be 'yyyy-mm-dd'.\nmilestones.create_success = Milestone '%s' has been created successfully!\nmilestones.edit = Edit Milestone\nmilestones.edit_subheader = Use a better description for milestones so people won't be confused.\nmilestones.cancel = Cancel\nmilestones.modify = Modify Milestone\nmilestones.edit_success = Changes of milestone '%s' has been saved successfully!\nmilestones.deletion = Milestone Deletion\nmilestones.deletion_desc = Deleting this milestone will remove its information in all related issues. Do you want to continue?\nmilestones.deletion_success = Milestone has been deleted successfully!\n\nwiki = Wiki\nwiki.welcome = Welcome to Wiki!\nwiki.welcome_desc = Wiki is the place where you would like to document your project together and make it better.\nwiki.create_first_page = Create the first page\nwiki.page = Page\nwiki.filter_page = Filter page\nwiki.new_page = Create New Page\nwiki.default_commit_message = Write a note about this update (optional).\nwiki.save_page = Save Page\nwiki.last_commit_info = %s edited this page %s\nwiki.edit_page_button = Edit\nwiki.new_page_button = New Page\nwiki.delete_page_button = Delete Page\nwiki.delete_page_notice_1 = This will delete the page <code>\"%s\"</code>. Please be certain.\nwiki.page_already_exists = Wiki page with same name already exists.\nwiki.pages = Pages\nwiki.last_updated = Last updated %s\n\nsettings = Settings\nsettings.options = Options\nsettings.collaboration = Collaboration\nsettings.collaboration.admin = Admin\nsettings.collaboration.write = Write\nsettings.collaboration.read = Read\nsettings.collaboration.undefined = Undefined\nsettings.branches = Branches\nsettings.branches_bare = You cannot manage branches for bare repository. Please push some content first.\nsettings.default_branch = Default Branch\nsettings.default_branch_desc = The default branch is considered the \"base\" branch for code commits, pull requests and online editing.\nsettings.update = Update\nsettings.update_default_branch_unsupported = Change default branch is not supported by the Git version on server.\nsettings.update_default_branch_success = Default branch of this repository has been updated successfully!\nsettings.protected_branches = Protected Branches\nsettings.protected_branches_desc = Protect branches from force pushing, accidental deletion and whitelist code committers.\nsettings.choose_a_branch = Choose a branch...\nsettings.branch_protection = Branch Protection\nsettings.branch_protection_desc = Please choose protect options for branch <b>%s</b>.\nsettings.protect_this_branch = Protect this branch\nsettings.protect_this_branch_desc = Disable force pushes and prevent from deletion.\nsettings.protect_require_pull_request = Require pull request instead direct pushing\nsettings.protect_require_pull_request_desc = Enable this option to disable direct pushing to this branch. Commits have to be pushed to another non-protected branch and merged to this branch through pull request.\nsettings.protect_whitelist_committers = Whitelist who can push to this branch\nsettings.protect_whitelist_committers_desc = Add people or teams to whitelist of direct push to this branch. Users in whitelist will bypass require pull request check.\nsettings.protect_whitelist_users = Users who can push to this branch\nsettings.protect_whitelist_search_users = Search users\nsettings.protect_whitelist_teams = Teams for which members of them can push to this branch\nsettings.protect_whitelist_search_teams = Search teams\nsettings.update_protect_branch_success = Protect options for this branch has been updated successfully!\nsettings.hooks = Webhooks\nsettings.githooks = Git Hooks\nsettings.basic_settings = Basic Settings\nsettings.mirror_settings = Mirror Settings\nsettings.sync_mirror = Sync Now\nsettings.mirror_sync_in_progress = Mirror syncing is in progress, please refresh page in about a minute.\nsettings.site = Official Site\nsettings.update_settings = Update Settings\nsettings.change_reponame_prompt = This change will affect how links relate to the repository.\nsettings.advanced_settings = Advanced Settings\nsettings.wiki_desc = Enable wiki system\nsettings.use_internal_wiki = Use builtin wiki\nsettings.allow_public_wiki_desc = Allow public access to wiki when repository is private\nsettings.use_external_wiki = Use external wiki\nsettings.external_wiki_url = External Wiki URL\nsettings.external_wiki_url_desc = Visitors will be redirected to URL when they click on the tab.\nsettings.issues_desc = Enable issue tracker\nsettings.use_internal_issue_tracker = Use builtin lightweight issue tracker\nsettings.allow_public_issues_desc = Allow public access to issues when repository is private\nsettings.use_external_issue_tracker = Use external issue tracker\nsettings.external_tracker_url = External Issue Tracker URL\nsettings.external_tracker_url_desc = Visitors will be redirected to URL when they click on the tab.\nsettings.tracker_url_format = External Issue Tracker URL Format\nsettings.tracker_issue_style = External Issue Tracker Naming Style:\nsettings.tracker_issue_style.numeric = Numeric\nsettings.tracker_issue_style.alphanumeric = Alphanumeric\nsettings.tracker_url_format_desc = You can use placeholder <code>{user} {repo} {index}</code> for user name, repository name and issue index.\nsettings.pulls_desc = Enable pull requests to accept contributions between repositories and branches\nsettings.pulls.ignore_whitespace = Ignore changes in whitespace\nsettings.pulls.allow_rebase_merge = Allow use rebase to merge commits\nsettings.danger_zone = Danger Zone\nsettings.cannot_fork_to_same_owner = You cannot fork a repository to its original owner.\nsettings.new_owner_has_same_repo = The new owner already has a repository with same name. Please choose another name.\nsettings.convert = Convert To Regular Repository\nsettings.convert_desc = You can convert this mirror to a regular repository. This cannot be reversed.\nsettings.convert_notices_1 = - This operation will convert this repository mirror into a regular repository and cannot be undone.\nsettings.convert_confirm = Confirm Conversion\nsettings.convert_succeed = Repository has been converted to regular type successfully.\nsettings.transfer = Transfer Ownership\nsettings.transfer_desc = Transfer this repository to another user or to an organization in which you have admin rights.\nsettings.transfer_notices_1 = - You will lose access if new owner is a individual user.\nsettings.transfer_notices_2 = - You will conserve access if new owner is an organization and if you're one of the owners.\nsettings.transfer_form_title = Please enter following information to confirm your operation:\nsettings.wiki_delete = Erase Wiki Data\nsettings.wiki_delete_desc = Once you erase wiki data there is no going back. Please be certain.\nsettings.wiki_delete_notices_1 = - This will delete and disable the wiki for %s\nsettings.wiki_deletion_success = Repository wiki data have been erased successfully.\nsettings.delete = Delete This Repository\nsettings.delete_desc = Once you delete a repository, there is no going back. Please be certain.\nsettings.delete_notices_1 = - This operation <strong>CANNOT</strong> be undone.\nsettings.delete_notices_2 = - This operation will permanently delete everything in this repository, including Git data, issues, comments and collaborator access.\nsettings.delete_notices_fork_1 = - All forks will become independent after deletion.\nsettings.deletion_success = Repository has been deleted successfully!\nsettings.update_settings_success = Repository options has been updated successfully.\nsettings.transfer_owner = New Owner\nsettings.make_transfer = Make Transfer\nsettings.transfer_succeed = Repository ownership has been transferred successfully.\nsettings.confirm_delete = Confirm Deletion\nsettings.add_collaborator = Add New Collaborator\nsettings.add_collaborator_success = New collaborator has been added.\nsettings.delete_collaborator = Delete\nsettings.collaborator_deletion = Collaborator Deletion\nsettings.collaborator_deletion_desc = This user will no longer have collaboration access to this repository after deletion. Do you want to continue?\nsettings.remove_collaborator_success = Collaborator has been removed.\nsettings.search_user_placeholder = Search user...\nsettings.org_not_allowed_to_be_collaborator = Organization is not allowed to be added as a collaborator.\nsettings.hooks_desc = Webhooks are much like basic HTTP POST event triggers. Whenever something occurs in Gogs, we will handle the notification to the target host you specify.\nsettings.webhooks.add_new = Add a new webhook:\nsettings.webhooks.choose_a_type = Choose a type...\nsettings.add_webhook = Add webhook\nsettings.webhook_deletion = Delete Webhook\nsettings.webhook_deletion_desc = Delete this webhook will remove its information and all delivery history. Do you want to continue?\nsettings.webhook_deletion_success = Webhook has been deleted successfully!\nsettings.webhook.test_delivery = Test Delivery\nsettings.webhook.test_delivery_desc = Send a fake push event delivery to test your webhook settings\nsettings.webhook.test_delivery_success = Test webhook has been added to delivery queue. It may take few seconds before it shows up in the delivery history.\nsettings.webhook.redelivery = Redelivery\nsettings.webhook.redelivery_success = Hook task '%s' has been readded to delivery queue. It may take few seconds to update delivery status in history.\nsettings.webhook.request = Request\nsettings.webhook.response = Response\nsettings.webhook.headers = Headers\nsettings.webhook.payload = Payload\nsettings.webhook.body = Body\nsettings.webhook.err_cannot_parse_payload_url = Cannot parse payload URL: %v\nsettings.webhook.err_cannot_use_local_addresses = Non admins are not allowed to use local addresses.\nsettings.githooks_desc = Git Hooks are powered by Git itself, you can edit files of supported hooks in the list below to perform custom operations.\nsettings.githook_edit_desc = If the hook is inactive, sample content will be presented. Leaving content to an empty value will disable this hook.\nsettings.githook_name = Hook Name\nsettings.githook_content = Hook Content\nsettings.update_githook = Update Hook\nsettings.add_webhook_desc = Gogs will send a <code>POST</code> request to the URL you specify, along with details regarding the event that occurred. You can also specify what kind of data format you'd like to get upon triggering the hook (JSON, x-www-form-urlencoded, XML, etc). More information can be found in our <a target=\"_blank\" href=\"%s\">Webhooks Guide</a>.\nsettings.payload_url = Payload URL\nsettings.content_type = Content Type\nsettings.secret = Secret\nsettings.secret_desc = Secret will be sent as SHA256 HMAC hex digest of payload via <code>X-Gogs-Signature</code> header.\nsettings.slack_username = Username\nsettings.slack_icon_url = Icon URL\nsettings.slack_color = Color\nsettings.event_desc = When should this webhook be triggered?\nsettings.event_push_only = Just the <code>push</code> event\nsettings.event_send_everything = I need <strong>everything</strong>\nsettings.event_choose = Let me choose what I need\nsettings.event_create = Create\nsettings.event_create_desc = Branch or tag created\nsettings.event_delete = Delete\nsettings.event_delete_desc = Branch or tag deleted\nsettings.event_fork = Fork\nsettings.event_fork_desc = Repository forked\nsettings.event_push = Push\nsettings.event_push_desc = Git push to a repository\nsettings.event_issues = Issues\nsettings.event_issues_desc = Issue opened, closed, reopened, edited, assigned, unassigned, label updated, label cleared, milestoned, or demilestoned.\nsettings.event_pull_request = Pull Request\nsettings.event_pull_request_desc = Pull request opened, closed, reopened, edited, assigned, unassigned, label updated, label cleared, milestoned, demilestoned, or synchronized.\nsettings.event_issue_comment = Issue Comment\nsettings.event_issue_comment_desc = Issue comment created, edited, or deleted.\nsettings.event_release = Release\nsettings.event_release_desc = Release published in a repository.\nsettings.active = Active\nsettings.active_helper = Details regarding the event which triggered the hook will be delivered as well.\nsettings.add_hook_success = New webhook has been added.\nsettings.update_webhook = Update Webhook\nsettings.update_hook_success = Webhook has been updated.\nsettings.delete_webhook = Delete Webhook\nsettings.recent_deliveries = Recent Deliveries\nsettings.hook_type = Hook Type\nsettings.add_slack_hook_desc = Add <a href=\"%s\">Slack</a> integration to your repository.\nsettings.add_discord_hook_desc = Add <a href=\"%s\">Discord</a> integration to your repository.\nsettings.add_dingtalk_hook_desc = Add <a href=\"%s\">Dingtalk</a> integration to your repository.\nsettings.slack_token = Token\nsettings.slack_domain = Domain\nsettings.slack_channel = Channel\nsettings.deploy_keys = Deploy Keys\nsettings.deploy_keys_helper = <b>Common Gotcha!</b> If you're looking for adding personal public keys, please add them in your <a href=\"%s%s\">account settings</a>.\nsettings.add_deploy_key = Add Deploy Key\nsettings.deploy_key_desc = Deploy keys have read-only access. They are not the same as personal account SSH keys.\nsettings.no_deploy_keys = You haven't added any deploy keys.\nsettings.title = Title\nsettings.deploy_key_content = Content\nsettings.key_been_used = Deploy key content has been used.\nsettings.key_name_used = Deploy key with the same name already exists.\nsettings.add_key_success = New deploy key '%s' has been added successfully!\nsettings.deploy_key_deletion = Delete Deploy Key\nsettings.deploy_key_deletion_desc = Deleting this deploy key will remove all related accesses for this repository. Do you want to continue?\nsettings.deploy_key_deletion_success = Deploy key has been deleted successfully!\nsettings.description_desc = Description of repository. Maximum 512 characters length.\nsettings.description_length = Available characters\n\ndiff.browse_source = Browse Source\ndiff.parent = parent\ndiff.commit = commit\ndiff.data_not_available = Diff Data Not Available.\ndiff.show_diff_stats = Show Diff Stats\ndiff.show_split_view = Split View\ndiff.show_unified_view = Unified View\ndiff.stats_desc = <strong> %d changed files</strong> with <strong>%d additions</strong> and <strong>%d deletions</strong>\ndiff.bin = BIN\ndiff.view_file = View File\ndiff.file_suppressed = File diff suppressed because it is too large\ndiff.too_many_files = Some files were not shown because too many files changed in this diff\n\nrelease.releases = Releases\nrelease.new_release = New Release\nrelease.draft = Draft\nrelease.prerelease = Pre-Release\nrelease.edit = edit\nrelease.ahead = <strong>%d</strong> commits to %s since this release\nrelease.source_code = Source Code\nrelease.new_subheader = Publish releases to iterate product.\nrelease.edit_subheader = Detailed change log can help users understand what has been improved.\nrelease.tag_name = Tag name\nrelease.target = Target\nrelease.tag_helper = Choose an existing tag, or create a new tag on publish.\nrelease.title = Title\nrelease.content = Content\nrelease.write = Write\nrelease.preview = Preview\nrelease.loading = Loading...\nrelease.prerelease_desc = This is a pre-release\nrelease.prerelease_helper = We'll point out that this release is not production-ready.\nrelease.cancel = Cancel\nrelease.publish = Publish Release\nrelease.save_draft = Save Draft\nrelease.edit_release = Edit Release\nrelease.delete_release = Delete This Release\nrelease.deletion = Release Deletion\nrelease.deletion_desc = Deleting this release will delete the corresponding Git tag. Do you want to continue?\nrelease.deletion_success = Release has been deleted successfully!\nrelease.tag_name_already_exist = Release with this tag name already exists.\nrelease.tag_name_invalid = Tag name is not valid.\nrelease.downloads = Downloads\n\n[org]\norg_name_holder = Organization Name\norg_full_name_holder = Organization Full Name\norg_name_helper = Great organization names are short and memorable.\ncreate_org = Create Organization\nrepo_updated = Updated\npeople = People\ninvite_someone = Invite Someone\nteams = Teams\nlower_members = members\nlower_repositories = repositories\ncreate_new_team = Create New Team\norg_desc = Description\nteam_name = Team Name\nteam_desc = Description\nteam_name_helper = You'll use this name to mention this team in conversations.\nteam_desc_helper = What is this team all about?\nteam_permission_desc = What permission level should this team have?\n\nform.name_not_allowed = Organization name or pattern %q is not allowed.\nform.team_name_not_allowed = Team name or pattern %q is not allowed.\n\nsettings = Settings\nsettings.options = Options\nsettings.full_name = Full Name\nsettings.website = Website\nsettings.location = Location\nsettings.update_settings = Update Settings\nsettings.update_setting_success = Organization settings has been updated successfully.\nsettings.change_orgname_prompt = This change will affect how links relate to the organization.\nsettings.update_avatar_success = Organization avatar setting has been updated successfully.\nsettings.delete = Delete Organization\nsettings.delete_account = Delete This Organization\nsettings.delete_prompt = The organization will be permanently removed, and this <strong>CANNOT</strong> be undone!\nsettings.confirm_delete_account = Confirm Deletion\nsettings.delete_org_title = Organization Deletion\nsettings.delete_org_desc = This organization is going to be deleted permanently, do you want to continue?\nsettings.hooks_desc = Add webhooks that will be triggered for <strong>all repositories</strong> under this organization.\n\nmembers.membership_visibility = Membership Visibility:\nmembers.public = Public\nmembers.public_helper = make private\nmembers.private = Private\nmembers.private_helper = make public\nmembers.member_role = Member Role:\nmembers.owner = Owner\nmembers.member = Member\nmembers.remove = Remove\nmembers.leave = Leave\nmembers.invite_desc = Add a new member to %s:\nmembers.invite_now = Invite Now\n\nteams.join = Join\nteams.leave = Leave\nteams.read_access = Read Access\nteams.read_access_helper = This team will be able to view and clone its repositories.\nteams.write_access = Write Access\nteams.write_access_helper = This team will be able to read its repositories, as well as push to them.\nteams.admin_access = Admin Access\nteams.admin_access_helper = This team will be able to push/pull to its repositories, as well as add other collaborators to them.\nteams.no_desc = This team has no description\nteams.settings = Settings\nteams.owners_permission_desc = Owners have full access to <strong>all repositories</strong> and have <strong>admin rights</strong> to the organization.\nteams.members = Team Members\nteams.update_settings = Update Settings\nteams.delete_team = Delete This Team\nteams.add_team_member = Add Team Member\nteams.delete_team_title = Team Deletion\nteams.delete_team_desc = As this team will be deleted, members of this team may lose access to some repositories. Do you want to continue?\nteams.delete_team_success = Given team has been deleted successfully.\nteams.read_permission_desc = Membership in this team grants <strong>Read</strong> access: members can view and clone the team's repositories.\nteams.write_permission_desc = Membership in this team grants <strong>Write</strong> access: members can read from and push to the team's repositories.\nteams.admin_permission_desc = Membership in this team grants <strong>Admin</strong> access: members can read from, push to, and add collaborators to the team's repositories.\nteams.repositories = Team Repositories\nteams.search_repo_placeholder = Search repository...\nteams.add_team_repository = Add Team Repository\nteams.remove_repo = Remove\nteams.add_nonexistent_repo = The repository you're trying to add does not exist, please create it first.\n\n[admin]\ndashboard = Dashboard\nusers = Users\norganizations = Organizations\nrepositories = Repositories\nauthentication = Authentications\nconfig = Configuration\nnotices = System Notices\nmonitor = Monitoring\nfirst_page = First\nlast_page = Last\ntotal = Total: %d\n\ndashboard.build_info = Build Information\ndashboard.app_ver = Application version\ndashboard.git_version = Git version\ndashboard.go_version = Go version\ndashboard.build_time = Build time\ndashboard.build_commit = Build commit\ndashboard.statistic = Statistics\ndashboard.operations = Operations\ndashboard.system_status = System Monitor Status\ndashboard.statistic_info = Gogs database has <b>%d</b> users, <b>%d</b> organizations, <b>%d</b> public keys, <b>%d</b> repositories, <b>%d</b> watches, <b>%d</b> stars, <b>%d</b> actions, <b>%d</b> accesses, <b>%d</b> issues, <b>%d</b> comments, <b>%d</b> social accounts, <b>%d</b> follows, <b>%d</b> mirrors, <b>%d</b> releases, <b>%d</b> login sources, <b>%d</b> webhooks, <b>%d</b> milestones, <b>%d</b> labels, <b>%d</b> hook tasks, <b>%d</b> teams, <b>%d</b> update tasks, <b>%d</b> attachments.\ndashboard.operation_name = Operation Name\ndashboard.operation_switch = Switch\ndashboard.select_operation_to_run = Please select operation to run\ndashboard.operation_run = Run\ndashboard.clean_unbind_oauth = Clean unbound OAuthes\ndashboard.clean_unbind_oauth_success = All unbind OAuthes have been deleted successfully.\ndashboard.delete_inactivate_accounts = Delete all inactive accounts\ndashboard.delete_inactivate_accounts_success = All inactivate accounts have been deleted successfully.\ndashboard.delete_repo_archives = Delete all repositories archives\ndashboard.delete_repo_archives_success = All repositories archives have been deleted successfully.\ndashboard.delete_missing_repos = Delete all repository records that lost Git files\ndashboard.delete_missing_repos_success = All repository records that lost Git files have been deleted successfully.\ndashboard.git_gc_repos = Do garbage collection on repositories\ndashboard.git_gc_repos_success = All repositories have done garbage collection successfully.\ndashboard.resync_all_sshkeys = Rewrite '.ssh/authorized_keys' file (caution: non-Gogs keys will be lost)\ndashboard.resync_all_sshkeys_success = All public keys have been rewritten successfully.\ndashboard.resync_all_hooks = Resync pre-receive, update and post-receive hooks of all repositories\ndashboard.resync_all_hooks_success = All repositories' pre-receive, update and post-receive hooks have been resynced successfully.\ndashboard.reinit_missing_repos = Reinitialize all repository records that lost Git files\ndashboard.reinit_missing_repos_success = All repository records that lost Git files have been reinitialized successfully.\n\ndashboard.server_uptime = Server Uptime\ndashboard.current_goroutine = Current Goroutines\ndashboard.current_memory_usage = Current Memory Usage\ndashboard.total_memory_allocated = Total Memory Allocated\ndashboard.memory_obtained = Memory Obtained\ndashboard.pointer_lookup_times = Pointer Lookup Times\ndashboard.memory_allocate_times = Memory Allocate Times\ndashboard.memory_free_times = Memory Free Times\ndashboard.current_heap_usage = Current Heap Usage\ndashboard.heap_memory_obtained = Heap Memory Obtained\ndashboard.heap_memory_idle = Heap Memory Idle\ndashboard.heap_memory_in_use = Heap Memory In Use\ndashboard.heap_memory_released = Heap Memory Released\ndashboard.heap_objects = Heap Objects\ndashboard.bootstrap_stack_usage = Bootstrap Stack Usage\ndashboard.stack_memory_obtained = Stack Memory Obtained\ndashboard.mspan_structures_usage = MSpan Structures Usage\ndashboard.mspan_structures_obtained = MSpan Structures Obtained\ndashboard.mcache_structures_usage = MCache Structures Usage\ndashboard.mcache_structures_obtained = MCache Structures Obtained\ndashboard.profiling_bucket_hash_table_obtained = Profiling Bucket Hash Table Obtained\ndashboard.gc_metadata_obtained = GC Metadata Obtained\ndashboard.other_system_allocation_obtained = Other System Allocation Obtained\ndashboard.next_gc_recycle = Next GC Recycle\ndashboard.last_gc_time = Since Last GC Time\ndashboard.total_gc_time = Total GC Pause\ndashboard.total_gc_pause = Total GC Pause\ndashboard.last_gc_pause = Last GC Pause\ndashboard.gc_times = GC Times\n\nusers.user_manage_panel = User Manage Panel\nusers.new_account = Create New Account\nusers.name = Name\nusers.activated = Activated\nusers.admin = Admin\nusers.repos = Repos\nusers.created = Created\nusers.send_register_notify = Send Registration Notification To User\nusers.new_success = New account '%s' has been created successfully.\nusers.edit = Edit\nusers.auth_source = Authentication Source\nusers.local = Local\nusers.auth_login_name = Authentication Login Name\nusers.password_helper = Leave it empty to remain unchanged.\nusers.update_profile_success = Account profile has been updated successfully.\nusers.edit_account = Edit Account\nusers.max_repo_creation = Maximum Repository Creation Limit\nusers.max_repo_creation_desc = (Set -1 to use global default limit)\nusers.is_activated = This account is activated\nusers.prohibit_login = This account is prohibited to login\nusers.is_admin = This account has administrator permissions\nusers.allow_git_hook = This account has permissions to create Git hooks\nusers.allow_import_local = This account has permissions to import local repositories\nusers.update_profile = Update Account Profile\nusers.delete_account = Delete This Account\nusers.still_own_repo = This account still has ownership over at least one repository, you have to delete or transfer them first.\nusers.still_has_org = This account still has membership in at least one organization, you have to leave or delete the organizations first.\nusers.deletion_success = Account has been deleted successfully!\n\norgs.org_manage_panel = Organization Manage Panel\norgs.name = Name\norgs.teams = Teams\norgs.members = Members\n\nrepos.repo_manage_panel = Repository Manage Panel\nrepos.owner = Owner\nrepos.name = Name\nrepos.private = Private\nrepos.watches = Watches\nrepos.stars = Stars\nrepos.issues = Issues\nrepos.size = Size\n\nauths.auth_sources = Authentication Sources\nauths.new = Add New Source\nauths.name = Name\nauths.type = Type\nauths.enabled = Enabled\nauths.default = Default\nauths.updated = Updated\nauths.auth_type = Authentication Type\nauths.auth_name = Authentication Name\nauths.security_protocol = Security Protocol\nauths.domain = Domain\nauths.host = Host\nauths.port = Port\nauths.bind_dn = Bind DN\nauths.bind_dn_helper = You can use '%s' as placeholder for username, e.g. DOM\\%s\nauths.bind_password = Bind Password\nauths.bind_password_helper = Warning: This password is stored in plain text. Do not use a high privileged account.\nauths.user_base = User Search Base\nauths.user_dn = User DN\nauths.attribute_username = Username Attribute\nauths.attribute_username_placeholder = Leave empty to use sign-in form field value for user name.\nauths.attribute_name = First Name Attribute\nauths.attribute_surname = Surname Attribute\nauths.attribute_mail = Email Attribute\nauths.verify_group_membership = Verify group membership\nauths.group_search_base_dn = Group Search Base DN\nauths.group_filter = Group Filter\nauths.group_attribute_contain_user_list = Group Attribute Containing List of Users\nauths.user_attribute_listed_in_group = User Attribute Listed in Group\nauths.attributes_in_bind = Fetch attributes in Bind DN context\nauths.filter = User Filter\nauths.admin_filter = Admin Filter\nauths.ms_ad_sa = Ms Ad SA\nauths.smtp_auth = SMTP Authentication Type\nauths.smtphost = SMTP Host\nauths.smtpport = SMTP Port\nauths.allowed_domains = Allowed Domains\nauths.allowed_domains_helper = Leave it empty to not restrict any domains. Multiple domains should be separated by comma ','.\nauths.enable_tls = Enable TLS Encryption\nauths.skip_tls_verify = Skip TLS Verify\nauths.pam_service_name = PAM Service Name\nauths.enable_auto_register = Enable Auto Registration\nauths.edit = Edit Authentication Setting\nauths.activated = This authentication is activated\nauths.default_auth =  This authentication is default login source\nauths.new_success = New authentication '%s' has been added successfully.\nauths.update_success = Authentication setting has been updated successfully.\nauths.update = Update Authentication Setting\nauths.delete = Delete This Authentication\nauths.delete_auth_title = Authentication Deletion\nauths.delete_auth_desc = This authentication is going to be deleted, do you want to continue?\nauths.still_in_used = This authentication is still used by some users, please delete or convert these users to another login type first.\nauths.deletion_success = Authentication has been deleted successfully!\nauths.login_source_exist = Login source '%s' already exists.\nauths.github_api_endpoint = API Endpoint\n\nconfig.not_set = (not set)\nconfig.server_config = Server configuration\nconfig.brand_name = Brand name\nconfig.run_user = Run user\nconfig.run_mode = Run mode\nconfig.server.external_url = External URL\nconfig.server.domain = Domain\nconfig.server.protocol = Protocol\nconfig.server.http_addr = HTTP address\nconfig.server.http_port = HTTP port\nconfig.server.cert_file = Certificate file\nconfig.server.key_file = Key file\nconfig.server.tls_min_version = Minimum TLS version\nconfig.server.unix_socket_permission = Unix socket permission\nconfig.server.local_root_url = Local root URL\nconfig.server.offline_mode = Offline mode\nconfig.server.disable_router_log = Disable router log\nconfig.server.enable_gzip = Enable Gzip\nconfig.server.app_data_path = Application data path\nconfig.server.load_assets_from_disk = Load assets from disk\nconfig.server.landing_url = Landing URL\n\nconfig.ssh_config = SSH configuration\nconfig.ssh.enabled = Enabled\nconfig.ssh.domain = Exposed domain\nconfig.ssh.port = Exposed port\nconfig.ssh.root_path = Root path\nconfig.ssh.keygen_path = Keygen path\nconfig.ssh.key_test_path = Key test path\nconfig.ssh.minimum_key_size_check = Minimum key size check\nconfig.ssh.minimum_key_sizes = Minimum key sizes\nconfig.ssh.rewrite_authorized_keys_at_start = Rewrite \"authorized_keys\" at start\nconfig.ssh.start_builtin_server = Start builtin server\nconfig.ssh.listen_host = Listen host\nconfig.ssh.listen_port = Listen port\nconfig.ssh.server_ciphers = Server ciphers\nconfig.ssh.server_macs = Server MACs\n\nconfig.repo_config = Repository configuration\nconfig.repo.root_path = Root path\nconfig.repo.script_type = Script type\nconfig.repo.ansi_chatset = ANSI charset\nconfig.repo.force_private = Force private\nconfig.repo.max_creation_limit = Max creation limit\nconfig.repo.preferred_licenses = Preferred licenses\nconfig.repo.disable_http_git = Disable HTTP Git\nconfig.repo.enable_local_path_migration = Enable local path migration\nconfig.repo.enable_raw_file_render_mode = Enable raw file render mode\nconfig.repo.commits_fetch_concurrency = Commits fetch concurrency\nconfig.repo.editor.line_wrap_extensions = Editor line wrap extensions\nconfig.repo.editor.previewable_file_modes = Editor previewable file modes\nconfig.repo.upload.enabled = Upload enabled\nconfig.repo.upload.temp_path = Upload temporary path\nconfig.repo.upload.allowed_types = Upload allowed types\nconfig.repo.upload.file_max_size = Upload file size limit\nconfig.repo.upload.max_files = Upload files limit\n\nconfig.db_config = Database configuration\nconfig.db.type = Type\nconfig.db.host = Host\nconfig.db.name = Name\nconfig.db.schema = Schema\nconfig.db.schema_helper = (for \"postgres\" only)\nconfig.db.user = User\nconfig.db.ssl_mode = SSL mode\nconfig.db.ssl_mode_helper = (for \"postgres\" only)\nconfig.db.path = Path\nconfig.db.path_helper = (for \"sqlite3\"only)\nconfig.db.max_open_conns = Maximum open connections\nconfig.db.max_idle_conns = Maximum idle connections\n\nconfig.security_config = Security configuration\nconfig.security.login_remember_days = Login remember days\nconfig.security.cookie_remember_name = Remember cookie\nconfig.security.cookie_username = Username cookie\nconfig.security.cookie_secure = Enable secure cookie\nconfig.security.reverse_proxy_auth_user = Reverse proxy authentication header\nconfig.security.enable_login_status_cookie = Enable login status cookie\nconfig.security.login_status_cookie_name = Login status cookie\nconfig.security.local_network_allowlist = Local network allowlist\n\nconfig.email_config = Email configuration\nconfig.email.enabled = Enabled\nconfig.email.subject_prefix = Subject prefix\nconfig.email.host = Host\nconfig.email.from = From\nconfig.email.user = User\nconfig.email.disable_helo = Disable HELO\nconfig.email.helo_hostname = HELO hostname\nconfig.email.skip_verify = Skip certificate verify\nconfig.email.use_certificate = Use custom certificate\nconfig.email.cert_file = Certificate file\nconfig.email.key_file = Key file\nconfig.email.use_plain_text = Use plain text\nconfig.email.add_plain_text_alt = Add plain text alternative\nconfig.email.send_test_mail = Send test email\nconfig.email.test_mail_failed = Failed to send test email to '%s': %v\nconfig.email.test_mail_sent = Test email has been sent to '%s'.\n\nconfig.auth_config = Authentication configuration\nconfig.auth.activate_code_lives = Activate code lives\nconfig.auth.reset_password_code_lives = Reset password code lives\nconfig.auth.require_email_confirm = Require email confirmation\nconfig.auth.require_sign_in_view = Require sign in view\nconfig.auth.disable_registration = Disable registration\nconfig.auth.enable_registration_captcha = Enable registration captcha\nconfig.auth.enable_reverse_proxy_authentication = Enable reverse proxy authentication\nconfig.auth.enable_reverse_proxy_auto_registration = Enable reverse proxy auto registration\nconfig.auth.reverse_proxy_authentication_header = Reverse proxy authentication header\n\nconfig.user_config = User configuration\nconfig.user.enable_email_notify = Enable email notification\n\nconfig.session_config = Session configuration\nconfig.session.provider = Provider\nconfig.session.provider_config = Provider config\nconfig.session.cookie_name = Cookie\nconfig.session.https_only = HTTPS only\nconfig.session.gc_interval = GC interval\nconfig.session.max_life_time = Max life time\nconfig.session.csrf_cookie_name = CSRF cookie\n\nconfig.cache_config = Cache configuration\nconfig.cache.adapter = Adapter\nconfig.cache.interval = GC interval\nconfig.cache.host = Host\n\nconfig.http_config = HTTP configuration\nconfig.http.access_control_allow_origin = Access control allow origin\n\nconfig.attachment_config = Attachment configuration\nconfig.attachment.enabled = Enabled\nconfig.attachment.path = Path\nconfig.attachment.allowed_types = Allowed types\nconfig.attachment.max_size = Size limit\nconfig.attachment.max_files = Files limit\n\nconfig.release_config = Release configuration\nconfig.release.attachment.enabled = Attachment enabled\nconfig.release.attachment.allowed_types = Attachment allowed types\nconfig.release.attachment.max_size = Attachment size limit\nconfig.release.attachment.max_files = Attachment files limit\n\nconfig.picture_config = Picture configuration\nconfig.picture.avatar_upload_path = User avatar upload path\nconfig.picture.repo_avatar_upload_path = Repository avatar upload path\nconfig.picture.gravatar_source = Gravatar source\nconfig.picture.disable_gravatar = Disable Gravatar\nconfig.picture.enable_federated_avatar = Enable federated avatars\n\nconfig.mirror_config = Mirror configuration\nconfig.mirror.default_interval = Default interval\n\nconfig.webhook_config = Webhook configuration\nconfig.webhook.types = Types\nconfig.webhook.deliver_timeout = Deliver timeout\nconfig.webhook.skip_tls_verify = Skip TLS verify\n\nconfig.git_config = Git configuration\nconfig.git.disable_diff_highlight = Disable diff syntax highlight\nconfig.git.max_diff_lines = Diff lines limit (for a single file)\nconfig.git.max_diff_line_characters = Diff characters limit (for a single line)\nconfig.git.max_diff_files = Diff files limit (for a single diff)\nconfig.git.gc_args = GC arguments\nconfig.git.migrate_timeout = Migration timeout\nconfig.git.mirror_timeout = Mirror fetch timeout\nconfig.git.clone_timeout = Clone timeout\nconfig.git.pull_timeout = Pull timeout\nconfig.git.gc_timeout = GC timeout\n\nconfig.lfs_config = LFS configuration\nconfig.lfs.storage = Storage\nconfig.lfs.objects_path = Objects path\n\nconfig.log_config = Log configuration\nconfig.log_file_root_path = Log file root path\nconfig.log_mode = Mode\nconfig.log_options = Options\n\nmonitor.cron = Cron Tasks\nmonitor.name = Name\nmonitor.schedule = Schedule\nmonitor.next = Next Time\nmonitor.previous = Previous Time\nmonitor.execute_times = Execute Times\nmonitor.process = Running Processes\nmonitor.desc = Description\nmonitor.start = Start Time\nmonitor.execute_time = Execution Time\n\nnotices.system_notice_list = System Notices\nnotices.view_detail_header = View Notice Detail\nnotices.actions = Actions\nnotices.select_all = Select All\nnotices.deselect_all = Deselect All\nnotices.inverse_selection = Inverse Selection\nnotices.delete_selected = Delete Selected\nnotices.delete_all = Delete All Notices\nnotices.type = Type\nnotices.type_1 = Repository\nnotices.desc = Description\nnotices.op = Op.\nnotices.delete_success = System notices have been deleted successfully.\n\n[action]\ncreate_repo = created repository <a href=\"%s\">%s</a>\nrename_repo = renamed repository from <code>%[1]s</code> to <a href=\"%[2]s\">%[3]s</a>\ncommit_repo = pushed to <a href=\"%[1]s/src/%[2]s\">%[3]s</a> at <a href=\"%[1]s\">%[4]s</a>\ncompare_commits = View comparison for these %d commits\ntransfer_repo = transfered repository <code>%s</code> to <a href=\"%s\">%s</a>\ncreate_issue = `opened issue <a href=\"%s/issues/%s\">%s#%[2]s</a>`\nclose_issue = `closed issue <a href=\"%s/issues/%s\">%s#%[2]s</a>`\nreopen_issue = `reopened issue <a href=\"%s/issues/%s\">%s#%[2]s</a>`\ncomment_issue = `commented on issue <a href=\"%s/issues/%s\">%s#%[2]s</a>`\ncreate_pull_request = `created pull request <a href=\"%s/pulls/%s\">%s#%[2]s</a>`\nclose_pull_request = `closed pull request <a href=\"%s/pulls/%s\">%s#%[2]s</a>`\nreopen_pull_request = `reopened pull request <a href=\"%s/pulls/%s\">%s#%[2]s</a>`\nmerge_pull_request = `merged pull request <a href=\"%s/pulls/%s\">%s#%[2]s</a>`\ncreate_branch = created new branch <a href=\"%[1]s/src/%[2]s\">%[3]s</a> at <a href=\"%[1]s\">%[4]s</a>\ndelete_branch = deleted branch <code>%[2]s</code> at <a href=\"%[1]s\">%[3]s</a>\npush_tag = pushed tag <a href=\"%s/src/%s\">%[2]s</a> to <a href=\"%[1]s\">%[3]s</a>\ndelete_tag = deleted tag <code>%[2]s</code> at <a href=\"%[1]s\">%[3]s</a>\nfork_repo = forked a repository to <a href=\"%s\">%s</a>\nmirror_sync_push = synced commits to <a href=\"%[1]s/src/%[2]s\">%[3]s</a> at <a href=\"%[1]s\">%[4]s</a> from mirror\nmirror_sync_create = synced new reference <a href=\"%s/src/%s\">%[2]s</a> to <a href=\"%[1]s\">%[3]s</a> from mirror\nmirror_sync_delete = synced and deleted reference <code>%[2]s</code> at <a href=\"%[1]s\">%[3]s</a> from mirror\n\n[tool]\nago = ago\nfrom_now = from now\nnow = now\n1s = 1 second %s\n1m = 1 minute %s\n1h = 1 hour %s\n1d = 1 day %s\n1w = 1 week %s\n1mon = 1 month %s\n1y = 1 year %s\nseconds = %d seconds %s\nminutes = %d minutes %s\nhours = %d hours %s\ndays = %d days %s\nweeks = %d weeks %s\nmonths = %d months %s\nyears = %d years %s\nraw_seconds = seconds\nraw_minutes = minutes\nraw_hours = hours\n\n[dropzone]\ndefault_message = Drop files here or click to upload.\ninvalid_input_type = You can't upload files of this type.\nfile_too_big = File size ({{filesize}} MB) exceeds maximum size ({{maxFilesize}} MB).\nremove_file = Remove file\n", "// Copyright 2015 The Gogs Authors. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage db\n\nimport (\n\t\"fmt\"\n)\n\n//  ____ ___\n// |    |   \\______ ___________\n// |    |   /  ___// __ \\_  __ \\\n// |    |  /\\___ \\\\  ___/|  | \\/\n// |______//____  >\\___  >__|\n//              \\/     \\/\n\ntype ErrUserOwnRepos struct {\n\tUID int64\n}\n\nfunc IsErrUserOwnRepos(err error) bool {\n\t_, ok := err.(ErrUserOwnRepos)\n\treturn ok\n}\n\nfunc (err ErrUserOwnRepos) Error() string {\n\treturn fmt.Sprintf(\"user still has ownership of repositories [uid: %d]\", err.UID)\n}\n\ntype ErrUserHasOrgs struct {\n\tUID int64\n}\n\nfunc IsErrUserHasOrgs(err error) bool {\n\t_, ok := err.(ErrUserHasOrgs)\n\treturn ok\n}\n\nfunc (err ErrUserHasOrgs) Error() string {\n\treturn fmt.Sprintf(\"user still has membership of organizations [uid: %d]\", err.UID)\n}\n\n//  __      __.__ __   .__\n// /  \\    /  \\__|  | _|__|\n// \\   \\/\\/   /  |  |/ /  |\n//  \\        /|  |    <|  |\n//   \\__/\\  / |__|__|_ \\__|\n//        \\/          \\/\n\ntype ErrWikiAlreadyExist struct {\n\tTitle string\n}\n\nfunc IsErrWikiAlreadyExist(err error) bool {\n\t_, ok := err.(ErrWikiAlreadyExist)\n\treturn ok\n}\n\nfunc (err ErrWikiAlreadyExist) Error() string {\n\treturn fmt.Sprintf(\"wiki page already exists [title: %s]\", err.Title)\n}\n\n// __________     ___.   .__  .__          ____  __.\n// \\______   \\__ _\\_ |__ |  | |__| ____   |    |/ _|____ ___.__.\n//  |     ___/  |  \\ __ \\|  | |  |/ ___\\  |      <_/ __ <   |  |\n//  |    |   |  |  / \\_\\ \\  |_|  \\  \\___  |    |  \\  ___/\\___  |\n//  |____|   |____/|___  /____/__|\\___  > |____|__ \\___  > ____|\n//                     \\/             \\/          \\/   \\/\\/\n\ntype ErrKeyUnableVerify struct {\n\tResult string\n}\n\nfunc IsErrKeyUnableVerify(err error) bool {\n\t_, ok := err.(ErrKeyUnableVerify)\n\treturn ok\n}\n\nfunc (err ErrKeyUnableVerify) Error() string {\n\treturn fmt.Sprintf(\"Unable to verify key content [result: %s]\", err.Result)\n}\n\ntype ErrKeyNotExist struct {\n\tID int64\n}\n\nfunc IsErrKeyNotExist(err error) bool {\n\t_, ok := err.(ErrKeyNotExist)\n\treturn ok\n}\n\nfunc (err ErrKeyNotExist) Error() string {\n\treturn fmt.Sprintf(\"public key does not exist [id: %d]\", err.ID)\n}\n\ntype ErrKeyAlreadyExist struct {\n\tOwnerID int64\n\tContent string\n}\n\nfunc IsErrKeyAlreadyExist(err error) bool {\n\t_, ok := err.(ErrKeyAlreadyExist)\n\treturn ok\n}\n\nfunc (err ErrKeyAlreadyExist) Error() string {\n\treturn fmt.Sprintf(\"public key already exists [owner_id: %d, content: %s]\", err.OwnerID, err.Content)\n}\n\ntype ErrKeyNameAlreadyUsed struct {\n\tOwnerID int64\n\tName    string\n}\n\nfunc IsErrKeyNameAlreadyUsed(err error) bool {\n\t_, ok := err.(ErrKeyNameAlreadyUsed)\n\treturn ok\n}\n\nfunc (err ErrKeyNameAlreadyUsed) Error() string {\n\treturn fmt.Sprintf(\"public key already exists [owner_id: %d, name: %s]\", err.OwnerID, err.Name)\n}\n\ntype ErrKeyAccessDenied struct {\n\tUserID int64\n\tKeyID  int64\n\tNote   string\n}\n\nfunc IsErrKeyAccessDenied(err error) bool {\n\t_, ok := err.(ErrKeyAccessDenied)\n\treturn ok\n}\n\nfunc (err ErrKeyAccessDenied) Error() string {\n\treturn fmt.Sprintf(\"user does not have access to the key [user_id: %d, key_id: %d, note: %s]\",\n\t\terr.UserID, err.KeyID, err.Note)\n}\n\ntype ErrDeployKeyAlreadyExist struct {\n\tKeyID  int64\n\tRepoID int64\n}\n\nfunc IsErrDeployKeyAlreadyExist(err error) bool {\n\t_, ok := err.(ErrDeployKeyAlreadyExist)\n\treturn ok\n}\n\nfunc (err ErrDeployKeyAlreadyExist) Error() string {\n\treturn fmt.Sprintf(\"public key already exists [key_id: %d, repo_id: %d]\", err.KeyID, err.RepoID)\n}\n\ntype ErrDeployKeyNameAlreadyUsed struct {\n\tRepoID int64\n\tName   string\n}\n\nfunc IsErrDeployKeyNameAlreadyUsed(err error) bool {\n\t_, ok := err.(ErrDeployKeyNameAlreadyUsed)\n\treturn ok\n}\n\nfunc (err ErrDeployKeyNameAlreadyUsed) Error() string {\n\treturn fmt.Sprintf(\"public key already exists [repo_id: %d, name: %s]\", err.RepoID, err.Name)\n}\n\n// ________                            .__                __  .__\n// \\_____  \\_______  _________    ____ |__|____________ _/  |_|__| ____   ____\n//  /   |   \\_  __ \\/ ___\\__  \\  /    \\|  \\___   /\\__  \\\\   __\\  |/  _ \\ /    \\\n// /    |    \\  | \\/ /_/  > __ \\|   |  \\  |/    /  / __ \\|  | |  (  <_> )   |  \\\n// \\_______  /__|  \\___  (____  /___|  /__/_____ \\(____  /__| |__|\\____/|___|  /\n//         \\/     /_____/     \\/     \\/         \\/     \\/                    \\/\n\ntype ErrLastOrgOwner struct {\n\tUID int64\n}\n\nfunc IsErrLastOrgOwner(err error) bool {\n\t_, ok := err.(ErrLastOrgOwner)\n\treturn ok\n}\n\nfunc (err ErrLastOrgOwner) Error() string {\n\treturn fmt.Sprintf(\"user is the last member of owner team [uid: %d]\", err.UID)\n}\n\n// __________                           .__  __\n// \\______   \\ ____ ______   ____  _____|__|/  |_  ___________ ___.__.\n//  |       _// __ \\\\____ \\ /  _ \\/  ___/  \\   __\\/  _ \\_  __ <   |  |\n//  |    |   \\  ___/|  |_> >  <_> )___ \\|  ||  | (  <_> )  | \\/\\___  |\n//  |____|_  /\\___  >   __/ \\____/____  >__||__|  \\____/|__|   / ____|\n//         \\/     \\/|__|              \\/                       \\/\n\ntype ErrInvalidCloneAddr struct {\n\tIsURLError         bool\n\tIsInvalidPath      bool\n\tIsPermissionDenied bool\n}\n\nfunc IsErrInvalidCloneAddr(err error) bool {\n\t_, ok := err.(ErrInvalidCloneAddr)\n\treturn ok\n}\n\nfunc (err ErrInvalidCloneAddr) Error() string {\n\treturn fmt.Sprintf(\"invalid clone address [is_url_error: %v, is_invalid_path: %v, is_permission_denied: %v]\",\n\t\terr.IsURLError, err.IsInvalidPath, err.IsPermissionDenied)\n}\n\ntype ErrUpdateTaskNotExist struct {\n\tUUID string\n}\n\nfunc IsErrUpdateTaskNotExist(err error) bool {\n\t_, ok := err.(ErrUpdateTaskNotExist)\n\treturn ok\n}\n\nfunc (err ErrUpdateTaskNotExist) Error() string {\n\treturn fmt.Sprintf(\"update task does not exist [uuid: %s]\", err.UUID)\n}\n\ntype ErrReleaseAlreadyExist struct {\n\tTagName string\n}\n\nfunc IsErrReleaseAlreadyExist(err error) bool {\n\t_, ok := err.(ErrReleaseAlreadyExist)\n\treturn ok\n}\n\nfunc (err ErrReleaseAlreadyExist) Error() string {\n\treturn fmt.Sprintf(\"release tag already exist [tag_name: %s]\", err.TagName)\n}\n\ntype ErrInvalidTagName struct {\n\tTagName string\n}\n\nfunc IsErrInvalidTagName(err error) bool {\n\t_, ok := err.(ErrInvalidTagName)\n\treturn ok\n}\n\nfunc (err ErrInvalidTagName) Error() string {\n\treturn fmt.Sprintf(\"release tag name is not valid [tag_name: %s]\", err.TagName)\n}\n\ntype ErrRepoFileAlreadyExist struct {\n\tFileName string\n}\n\nfunc IsErrRepoFileAlreadyExist(err error) bool {\n\t_, ok := err.(ErrRepoFileAlreadyExist)\n\treturn ok\n}\n\nfunc (err ErrRepoFileAlreadyExist) Error() string {\n\treturn fmt.Sprintf(\"repository file already exists [file_name: %s]\", err.FileName)\n}\n\n// ___________\n// \\__    ___/___ _____    _____\n//   |    |_/ __ \\\\__  \\  /     \\\n//   |    |\\  ___/ / __ \\|  Y Y  \\\n//   |____| \\___  >____  /__|_|  /\n//              \\/     \\/      \\/\n\ntype ErrTeamAlreadyExist struct {\n\tID    int64\n\tOrgID int64\n\tName  string\n}\n\nfunc IsErrTeamAlreadyExist(err error) bool {\n\t_, ok := err.(ErrTeamAlreadyExist)\n\treturn ok\n}\n\nfunc (err ErrTeamAlreadyExist) Error() string {\n\treturn fmt.Sprintf(\"team already exists [id: %d, org_id: %d, name: %s]\", err.ID, err.OrgID, err.Name)\n}\n\n//  ____ ___        .__                    .___\n// |    |   \\______ |  |   _________     __| _/\n// |    |   /\\____ \\|  |  /  _ \\__  \\   / __ |\n// |    |  / |  |_> >  |_(  <_> ) __ \\_/ /_/ |\n// |______/  |   __/|____/\\____(____  /\\____ |\n//           |__|                   \\/      \\/\n//\n\ntype ErrUploadNotExist struct {\n\tID   int64\n\tUUID string\n}\n\nfunc IsErrUploadNotExist(err error) bool {\n\t_, ok := err.(ErrAttachmentNotExist)\n\treturn ok\n}\n\nfunc (err ErrUploadNotExist) Error() string {\n\treturn fmt.Sprintf(\"attachment does not exist [id: %d, uuid: %s]\", err.ID, err.UUID)\n}\n", "// Copyright 2014 The Gogs Authors. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage db\n\nimport (\n\t\"crypto/hmac\"\n\t\"crypto/sha256\"\n\t\"crypto/tls\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"strings\"\n\t\"time\"\n\n\tjsoniter \"github.com/json-iterator/go\"\n\tgouuid \"github.com/satori/go.uuid\"\n\tlog \"unknwon.dev/clog/v2\"\n\t\"xorm.io/xorm\"\n\n\tapi \"github.com/gogs/go-gogs-client\"\n\n\t\"gogs.io/gogs/internal/conf\"\n\t\"gogs.io/gogs/internal/errutil\"\n\t\"gogs.io/gogs/internal/httplib\"\n\t\"gogs.io/gogs/internal/sync\"\n)\n\nvar HookQueue = sync.NewUniqueQueue(1000)\n\ntype HookContentType int\n\nconst (\n\tJSON HookContentType = iota + 1\n\tFORM\n)\n\nvar hookContentTypes = map[string]HookContentType{\n\t\"json\": JSON,\n\t\"form\": FORM,\n}\n\n// ToHookContentType returns HookContentType by given name.\nfunc ToHookContentType(name string) HookContentType {\n\treturn hookContentTypes[name]\n}\n\nfunc (t HookContentType) Name() string {\n\tswitch t {\n\tcase JSON:\n\t\treturn \"json\"\n\tcase FORM:\n\t\treturn \"form\"\n\t}\n\treturn \"\"\n}\n\n// IsValidHookContentType returns true if given name is a valid hook content type.\nfunc IsValidHookContentType(name string) bool {\n\t_, ok := hookContentTypes[name]\n\treturn ok\n}\n\ntype HookEvents struct {\n\tCreate       bool `json:\"create\"`\n\tDelete       bool `json:\"delete\"`\n\tFork         bool `json:\"fork\"`\n\tPush         bool `json:\"push\"`\n\tIssues       bool `json:\"issues\"`\n\tPullRequest  bool `json:\"pull_request\"`\n\tIssueComment bool `json:\"issue_comment\"`\n\tRelease      bool `json:\"release\"`\n}\n\n// HookEvent represents events that will delivery hook.\ntype HookEvent struct {\n\tPushOnly       bool `json:\"push_only\"`\n\tSendEverything bool `json:\"send_everything\"`\n\tChooseEvents   bool `json:\"choose_events\"`\n\n\tHookEvents `json:\"events\"`\n}\n\ntype HookStatus int\n\nconst (\n\tHOOK_STATUS_NONE = iota\n\tHOOK_STATUS_SUCCEED\n\tHOOK_STATUS_FAILED\n)\n\n// Webhook represents a web hook object.\ntype Webhook struct {\n\tID           int64\n\tRepoID       int64\n\tOrgID        int64\n\tURL          string `xorm:\"url TEXT\"`\n\tContentType  HookContentType\n\tSecret       string     `xorm:\"TEXT\"`\n\tEvents       string     `xorm:\"TEXT\"`\n\t*HookEvent   `xorm:\"-\"` // LEGACY [1.0]: Cannot ignore JSON (i.e. json:\"-\") here, it breaks old backup archive\n\tIsSSL        bool       `xorm:\"is_ssl\"`\n\tIsActive     bool\n\tHookTaskType HookTaskType\n\tMeta         string     `xorm:\"TEXT\"` // store hook-specific attributes\n\tLastStatus   HookStatus // Last delivery status\n\n\tCreated     time.Time `xorm:\"-\" json:\"-\"`\n\tCreatedUnix int64\n\tUpdated     time.Time `xorm:\"-\" json:\"-\"`\n\tUpdatedUnix int64\n}\n\nfunc (w *Webhook) BeforeInsert() {\n\tw.CreatedUnix = time.Now().Unix()\n\tw.UpdatedUnix = w.CreatedUnix\n}\n\nfunc (w *Webhook) BeforeUpdate() {\n\tw.UpdatedUnix = time.Now().Unix()\n}\n\nfunc (w *Webhook) AfterSet(colName string, _ xorm.Cell) {\n\tvar err error\n\tswitch colName {\n\tcase \"events\":\n\t\tw.HookEvent = &HookEvent{}\n\t\tif err = jsoniter.Unmarshal([]byte(w.Events), w.HookEvent); err != nil {\n\t\t\tlog.Error(\"Unmarshal [%d]: %v\", w.ID, err)\n\t\t}\n\tcase \"created_unix\":\n\t\tw.Created = time.Unix(w.CreatedUnix, 0).Local()\n\tcase \"updated_unix\":\n\t\tw.Updated = time.Unix(w.UpdatedUnix, 0).Local()\n\t}\n}\n\nfunc (w *Webhook) SlackMeta() *SlackMeta {\n\ts := &SlackMeta{}\n\tif err := jsoniter.Unmarshal([]byte(w.Meta), s); err != nil {\n\t\tlog.Error(\"Failed to get Slack meta [webhook_id: %d]: %v\", w.ID, err)\n\t}\n\treturn s\n}\n\n// History returns history of webhook by given conditions.\nfunc (w *Webhook) History(page int) ([]*HookTask, error) {\n\treturn HookTasks(w.ID, page)\n}\n\n// UpdateEvent handles conversion from HookEvent to Events.\nfunc (w *Webhook) UpdateEvent() error {\n\tdata, err := jsoniter.Marshal(w.HookEvent)\n\tw.Events = string(data)\n\treturn err\n}\n\n// HasCreateEvent returns true if hook enabled create event.\nfunc (w *Webhook) HasCreateEvent() bool {\n\treturn w.SendEverything ||\n\t\t(w.ChooseEvents && w.HookEvents.Create)\n}\n\n// HasDeleteEvent returns true if hook enabled delete event.\nfunc (w *Webhook) HasDeleteEvent() bool {\n\treturn w.SendEverything ||\n\t\t(w.ChooseEvents && w.HookEvents.Delete)\n}\n\n// HasForkEvent returns true if hook enabled fork event.\nfunc (w *Webhook) HasForkEvent() bool {\n\treturn w.SendEverything ||\n\t\t(w.ChooseEvents && w.HookEvents.Fork)\n}\n\n// HasPushEvent returns true if hook enabled push event.\nfunc (w *Webhook) HasPushEvent() bool {\n\treturn w.PushOnly || w.SendEverything ||\n\t\t(w.ChooseEvents && w.HookEvents.Push)\n}\n\n// HasIssuesEvent returns true if hook enabled issues event.\nfunc (w *Webhook) HasIssuesEvent() bool {\n\treturn w.SendEverything ||\n\t\t(w.ChooseEvents && w.HookEvents.Issues)\n}\n\n// HasPullRequestEvent returns true if hook enabled pull request event.\nfunc (w *Webhook) HasPullRequestEvent() bool {\n\treturn w.SendEverything ||\n\t\t(w.ChooseEvents && w.HookEvents.PullRequest)\n}\n\n// HasIssueCommentEvent returns true if hook enabled issue comment event.\nfunc (w *Webhook) HasIssueCommentEvent() bool {\n\treturn w.SendEverything ||\n\t\t(w.ChooseEvents && w.HookEvents.IssueComment)\n}\n\n// HasReleaseEvent returns true if hook enabled release event.\nfunc (w *Webhook) HasReleaseEvent() bool {\n\treturn w.SendEverything ||\n\t\t(w.ChooseEvents && w.HookEvents.Release)\n}\n\ntype eventChecker struct {\n\tchecker func() bool\n\ttyp     HookEventType\n}\n\nfunc (w *Webhook) EventsArray() []string {\n\tevents := make([]string, 0, 8)\n\teventCheckers := []eventChecker{\n\t\t{w.HasCreateEvent, HOOK_EVENT_CREATE},\n\t\t{w.HasDeleteEvent, HOOK_EVENT_DELETE},\n\t\t{w.HasForkEvent, HOOK_EVENT_FORK},\n\t\t{w.HasPushEvent, HOOK_EVENT_PUSH},\n\t\t{w.HasIssuesEvent, HOOK_EVENT_ISSUES},\n\t\t{w.HasPullRequestEvent, HOOK_EVENT_PULL_REQUEST},\n\t\t{w.HasIssueCommentEvent, HOOK_EVENT_ISSUE_COMMENT},\n\t\t{w.HasReleaseEvent, HOOK_EVENT_RELEASE},\n\t}\n\tfor _, c := range eventCheckers {\n\t\tif c.checker() {\n\t\t\tevents = append(events, string(c.typ))\n\t\t}\n\t}\n\treturn events\n}\n\n// CreateWebhook creates a new web hook.\nfunc CreateWebhook(w *Webhook) error {\n\t_, err := x.Insert(w)\n\treturn err\n}\n\nvar _ errutil.NotFound = (*ErrWebhookNotExist)(nil)\n\ntype ErrWebhookNotExist struct {\n\targs map[string]interface{}\n}\n\nfunc IsErrWebhookNotExist(err error) bool {\n\t_, ok := err.(ErrWebhookNotExist)\n\treturn ok\n}\n\nfunc (err ErrWebhookNotExist) Error() string {\n\treturn fmt.Sprintf(\"webhook does not exist: %v\", err.args)\n}\n\nfunc (ErrWebhookNotExist) NotFound() bool {\n\treturn true\n}\n\n// getWebhook uses argument bean as query condition,\n// ID must be specified and do not assign unnecessary fields.\nfunc getWebhook(bean *Webhook) (*Webhook, error) {\n\thas, err := x.Get(bean)\n\tif err != nil {\n\t\treturn nil, err\n\t} else if !has {\n\t\treturn nil, ErrWebhookNotExist{args: map[string]interface{}{\"webhookID\": bean.ID}}\n\t}\n\treturn bean, nil\n}\n\n// GetWebhookByID returns webhook by given ID.\n// Use this function with caution of accessing unauthorized webhook,\n// which means should only be used in non-user interactive functions.\nfunc GetWebhookByID(id int64) (*Webhook, error) {\n\treturn getWebhook(&Webhook{\n\t\tID: id,\n\t})\n}\n\n// GetWebhookOfRepoByID returns webhook of repository by given ID.\nfunc GetWebhookOfRepoByID(repoID, id int64) (*Webhook, error) {\n\treturn getWebhook(&Webhook{\n\t\tID:     id,\n\t\tRepoID: repoID,\n\t})\n}\n\n// GetWebhookByOrgID returns webhook of organization by given ID.\nfunc GetWebhookByOrgID(orgID, id int64) (*Webhook, error) {\n\treturn getWebhook(&Webhook{\n\t\tID:    id,\n\t\tOrgID: orgID,\n\t})\n}\n\n// getActiveWebhooksByRepoID returns all active webhooks of repository.\nfunc getActiveWebhooksByRepoID(e Engine, repoID int64) ([]*Webhook, error) {\n\twebhooks := make([]*Webhook, 0, 5)\n\treturn webhooks, e.Where(\"repo_id = ?\", repoID).And(\"is_active = ?\", true).Find(&webhooks)\n}\n\n// GetWebhooksByRepoID returns all webhooks of a repository.\nfunc GetWebhooksByRepoID(repoID int64) ([]*Webhook, error) {\n\twebhooks := make([]*Webhook, 0, 5)\n\treturn webhooks, x.Find(&webhooks, &Webhook{RepoID: repoID})\n}\n\n// UpdateWebhook updates information of webhook.\nfunc UpdateWebhook(w *Webhook) error {\n\t_, err := x.Id(w.ID).AllCols().Update(w)\n\treturn err\n}\n\n// deleteWebhook uses argument bean as query condition,\n// ID must be specified and do not assign unnecessary fields.\nfunc deleteWebhook(bean *Webhook) (err error) {\n\tsess := x.NewSession()\n\tdefer sess.Close()\n\tif err = sess.Begin(); err != nil {\n\t\treturn err\n\t}\n\n\tif _, err = sess.Delete(bean); err != nil {\n\t\treturn err\n\t} else if _, err = sess.Delete(&HookTask{HookID: bean.ID}); err != nil {\n\t\treturn err\n\t}\n\n\treturn sess.Commit()\n}\n\n// DeleteWebhookOfRepoByID deletes webhook of repository by given ID.\nfunc DeleteWebhookOfRepoByID(repoID, id int64) error {\n\treturn deleteWebhook(&Webhook{\n\t\tID:     id,\n\t\tRepoID: repoID,\n\t})\n}\n\n// DeleteWebhookOfOrgByID deletes webhook of organization by given ID.\nfunc DeleteWebhookOfOrgByID(orgID, id int64) error {\n\treturn deleteWebhook(&Webhook{\n\t\tID:    id,\n\t\tOrgID: orgID,\n\t})\n}\n\n// GetWebhooksByOrgID returns all webhooks for an organization.\nfunc GetWebhooksByOrgID(orgID int64) (ws []*Webhook, err error) {\n\terr = x.Find(&ws, &Webhook{OrgID: orgID})\n\treturn ws, err\n}\n\n// getActiveWebhooksByOrgID returns all active webhooks for an organization.\nfunc getActiveWebhooksByOrgID(e Engine, orgID int64) ([]*Webhook, error) {\n\tws := make([]*Webhook, 0, 3)\n\treturn ws, e.Where(\"org_id=?\", orgID).And(\"is_active=?\", true).Find(&ws)\n}\n\n//   ___ ___                __   ___________              __\n//  /   |   \\  ____   ____ |  | _\\__    ___/____    _____|  | __\n// /    ~    \\/  _ \\ /  _ \\|  |/ / |    |  \\__  \\  /  ___/  |/ /\n// \\    Y    (  <_> |  <_> )    <  |    |   / __ \\_\\___ \\|    <\n//  \\___|_  / \\____/ \\____/|__|_ \\ |____|  (____  /____  >__|_ \\\n//        \\/                    \\/              \\/     \\/     \\/\n\ntype HookTaskType int\n\nconst (\n\tGOGS HookTaskType = iota + 1\n\tSLACK\n\tDISCORD\n\tDINGTALK\n)\n\nvar hookTaskTypes = map[string]HookTaskType{\n\t\"gogs\":     GOGS,\n\t\"slack\":    SLACK,\n\t\"discord\":  DISCORD,\n\t\"dingtalk\": DINGTALK,\n}\n\n// ToHookTaskType returns HookTaskType by given name.\nfunc ToHookTaskType(name string) HookTaskType {\n\treturn hookTaskTypes[name]\n}\n\nfunc (t HookTaskType) Name() string {\n\tswitch t {\n\tcase GOGS:\n\t\treturn \"gogs\"\n\tcase SLACK:\n\t\treturn \"slack\"\n\tcase DISCORD:\n\t\treturn \"discord\"\n\tcase DINGTALK:\n\t\treturn \"dingtalk\"\n\t}\n\treturn \"\"\n}\n\n// IsValidHookTaskType returns true if given name is a valid hook task type.\nfunc IsValidHookTaskType(name string) bool {\n\t_, ok := hookTaskTypes[name]\n\treturn ok\n}\n\ntype HookEventType string\n\nconst (\n\tHOOK_EVENT_CREATE        HookEventType = \"create\"\n\tHOOK_EVENT_DELETE        HookEventType = \"delete\"\n\tHOOK_EVENT_FORK          HookEventType = \"fork\"\n\tHOOK_EVENT_PUSH          HookEventType = \"push\"\n\tHOOK_EVENT_ISSUES        HookEventType = \"issues\"\n\tHOOK_EVENT_PULL_REQUEST  HookEventType = \"pull_request\"\n\tHOOK_EVENT_ISSUE_COMMENT HookEventType = \"issue_comment\"\n\tHOOK_EVENT_RELEASE       HookEventType = \"release\"\n)\n\n// HookRequest represents hook task request information.\ntype HookRequest struct {\n\tHeaders map[string]string `json:\"headers\"`\n}\n\n// HookResponse represents hook task response information.\ntype HookResponse struct {\n\tStatus  int               `json:\"status\"`\n\tHeaders map[string]string `json:\"headers\"`\n\tBody    string            `json:\"body\"`\n}\n\n// HookTask represents a hook task.\ntype HookTask struct {\n\tID              int64\n\tRepoID          int64 `xorm:\"INDEX\"`\n\tHookID          int64\n\tUUID            string\n\tType            HookTaskType\n\tURL             string `xorm:\"TEXT\"`\n\tSignature       string `xorm:\"TEXT\"`\n\tapi.Payloader   `xorm:\"-\" json:\"-\"`\n\tPayloadContent  string `xorm:\"TEXT\"`\n\tContentType     HookContentType\n\tEventType       HookEventType\n\tIsSSL           bool\n\tIsDelivered     bool\n\tDelivered       int64\n\tDeliveredString string `xorm:\"-\" json:\"-\"`\n\n\t// History info.\n\tIsSucceed       bool\n\tRequestContent  string        `xorm:\"TEXT\"`\n\tRequestInfo     *HookRequest  `xorm:\"-\" json:\"-\"`\n\tResponseContent string        `xorm:\"TEXT\"`\n\tResponseInfo    *HookResponse `xorm:\"-\" json:\"-\"`\n}\n\nfunc (t *HookTask) BeforeUpdate() {\n\tif t.RequestInfo != nil {\n\t\tt.RequestContent = t.ToJSON(t.RequestInfo)\n\t}\n\tif t.ResponseInfo != nil {\n\t\tt.ResponseContent = t.ToJSON(t.ResponseInfo)\n\t}\n}\n\nfunc (t *HookTask) AfterSet(colName string, _ xorm.Cell) {\n\tvar err error\n\tswitch colName {\n\tcase \"delivered\":\n\t\tt.DeliveredString = time.Unix(0, t.Delivered).Format(\"2006-01-02 15:04:05 MST\")\n\n\tcase \"request_content\":\n\t\tif t.RequestContent == \"\" {\n\t\t\treturn\n\t\t}\n\n\t\tt.RequestInfo = &HookRequest{}\n\t\tif err = jsoniter.Unmarshal([]byte(t.RequestContent), t.RequestInfo); err != nil {\n\t\t\tlog.Error(\"Unmarshal[%d]: %v\", t.ID, err)\n\t\t}\n\n\tcase \"response_content\":\n\t\tif t.ResponseContent == \"\" {\n\t\t\treturn\n\t\t}\n\n\t\tt.ResponseInfo = &HookResponse{}\n\t\tif err = jsoniter.Unmarshal([]byte(t.ResponseContent), t.ResponseInfo); err != nil {\n\t\t\tlog.Error(\"Unmarshal [%d]: %v\", t.ID, err)\n\t\t}\n\t}\n}\n\nfunc (t *HookTask) ToJSON(v interface{}) string {\n\tp, err := jsoniter.Marshal(v)\n\tif err != nil {\n\t\tlog.Error(\"Marshal [%d]: %v\", t.ID, err)\n\t}\n\treturn string(p)\n}\n\n// HookTasks returns a list of hook tasks by given conditions.\nfunc HookTasks(hookID int64, page int) ([]*HookTask, error) {\n\ttasks := make([]*HookTask, 0, conf.Webhook.PagingNum)\n\treturn tasks, x.Limit(conf.Webhook.PagingNum, (page-1)*conf.Webhook.PagingNum).Where(\"hook_id=?\", hookID).Desc(\"id\").Find(&tasks)\n}\n\n// createHookTask creates a new hook task,\n// it handles conversion from Payload to PayloadContent.\nfunc createHookTask(e Engine, t *HookTask) error {\n\tdata, err := t.Payloader.JSONPayload()\n\tif err != nil {\n\t\treturn err\n\t}\n\tt.UUID = gouuid.NewV4().String()\n\tt.PayloadContent = string(data)\n\t_, err = e.Insert(t)\n\treturn err\n}\n\nvar _ errutil.NotFound = (*ErrHookTaskNotExist)(nil)\n\ntype ErrHookTaskNotExist struct {\n\targs map[string]interface{}\n}\n\nfunc IsHookTaskNotExist(err error) bool {\n\t_, ok := err.(ErrHookTaskNotExist)\n\treturn ok\n}\n\nfunc (err ErrHookTaskNotExist) Error() string {\n\treturn fmt.Sprintf(\"hook task does not exist: %v\", err.args)\n}\n\nfunc (ErrHookTaskNotExist) NotFound() bool {\n\treturn true\n}\n\n// GetHookTaskOfWebhookByUUID returns hook task of given webhook by UUID.\nfunc GetHookTaskOfWebhookByUUID(webhookID int64, uuid string) (*HookTask, error) {\n\thookTask := &HookTask{\n\t\tHookID: webhookID,\n\t\tUUID:   uuid,\n\t}\n\thas, err := x.Get(hookTask)\n\tif err != nil {\n\t\treturn nil, err\n\t} else if !has {\n\t\treturn nil, ErrHookTaskNotExist{args: map[string]interface{}{\"webhookID\": webhookID, \"uuid\": uuid}}\n\t}\n\treturn hookTask, nil\n}\n\n// UpdateHookTask updates information of hook task.\nfunc UpdateHookTask(t *HookTask) error {\n\t_, err := x.Id(t.ID).AllCols().Update(t)\n\treturn err\n}\n\n// prepareHookTasks adds list of webhooks to task queue.\nfunc prepareHookTasks(e Engine, repo *Repository, event HookEventType, p api.Payloader, webhooks []*Webhook) (err error) {\n\tif len(webhooks) == 0 {\n\t\treturn nil\n\t}\n\n\tvar payloader api.Payloader\n\tfor _, w := range webhooks {\n\t\tswitch event {\n\t\tcase HOOK_EVENT_CREATE:\n\t\t\tif !w.HasCreateEvent() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\tcase HOOK_EVENT_DELETE:\n\t\t\tif !w.HasDeleteEvent() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\tcase HOOK_EVENT_FORK:\n\t\t\tif !w.HasForkEvent() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\tcase HOOK_EVENT_PUSH:\n\t\t\tif !w.HasPushEvent() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\tcase HOOK_EVENT_ISSUES:\n\t\t\tif !w.HasIssuesEvent() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\tcase HOOK_EVENT_PULL_REQUEST:\n\t\t\tif !w.HasPullRequestEvent() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\tcase HOOK_EVENT_ISSUE_COMMENT:\n\t\t\tif !w.HasIssueCommentEvent() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\tcase HOOK_EVENT_RELEASE:\n\t\t\tif !w.HasReleaseEvent() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\t// Use separate objects so modifications won't be made on payload on non-Gogs type hooks.\n\t\tswitch w.HookTaskType {\n\t\tcase SLACK:\n\t\t\tpayloader, err = GetSlackPayload(p, event, w.Meta)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"GetSlackPayload: %v\", err)\n\t\t\t}\n\t\tcase DISCORD:\n\t\t\tpayloader, err = GetDiscordPayload(p, event, w.Meta)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"GetDiscordPayload: %v\", err)\n\t\t\t}\n\t\tcase DINGTALK:\n\t\t\tpayloader, err = GetDingtalkPayload(p, event)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"GetDingtalkPayload: %v\", err)\n\t\t\t}\n\t\tdefault:\n\t\t\tpayloader = p\n\t\t}\n\n\t\tvar signature string\n\t\tif len(w.Secret) > 0 {\n\t\t\tdata, err := payloader.JSONPayload()\n\t\t\tif err != nil {\n\t\t\t\tlog.Error(\"prepareWebhooks.JSONPayload: %v\", err)\n\t\t\t}\n\t\t\tsig := hmac.New(sha256.New, []byte(w.Secret))\n\t\t\t_, _ = sig.Write(data)\n\t\t\tsignature = hex.EncodeToString(sig.Sum(nil))\n\t\t}\n\n\t\tif err = createHookTask(e, &HookTask{\n\t\t\tRepoID:      repo.ID,\n\t\t\tHookID:      w.ID,\n\t\t\tType:        w.HookTaskType,\n\t\t\tURL:         w.URL,\n\t\t\tSignature:   signature,\n\t\t\tPayloader:   payloader,\n\t\t\tContentType: w.ContentType,\n\t\t\tEventType:   event,\n\t\t\tIsSSL:       w.IsSSL,\n\t\t}); err != nil {\n\t\t\treturn fmt.Errorf(\"createHookTask: %v\", err)\n\t\t}\n\t}\n\n\t// It's safe to fail when the whole function is called during hook execution\n\t// because resource released after exit. Also, there is no process started to\n\t// consume this input during hook execution.\n\tgo HookQueue.Add(repo.ID)\n\treturn nil\n}\n\nfunc prepareWebhooks(e Engine, repo *Repository, event HookEventType, p api.Payloader) error {\n\twebhooks, err := getActiveWebhooksByRepoID(e, repo.ID)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"getActiveWebhooksByRepoID [%d]: %v\", repo.ID, err)\n\t}\n\n\t// check if repo belongs to org and append additional webhooks\n\tif repo.mustOwner(e).IsOrganization() {\n\t\t// get hooks for org\n\t\torgws, err := getActiveWebhooksByOrgID(e, repo.OwnerID)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"getActiveWebhooksByOrgID [%d]: %v\", repo.OwnerID, err)\n\t\t}\n\t\twebhooks = append(webhooks, orgws...)\n\t}\n\treturn prepareHookTasks(e, repo, event, p, webhooks)\n}\n\n// PrepareWebhooks adds all active webhooks to task queue.\nfunc PrepareWebhooks(repo *Repository, event HookEventType, p api.Payloader) error {\n\treturn prepareWebhooks(x, repo, event, p)\n}\n\n// TestWebhook adds the test webhook matches the ID to task queue.\nfunc TestWebhook(repo *Repository, event HookEventType, p api.Payloader, webhookID int64) error {\n\twebhook, err := GetWebhookOfRepoByID(repo.ID, webhookID)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"GetWebhookOfRepoByID [repo_id: %d, id: %d]: %v\", repo.ID, webhookID, err)\n\t}\n\treturn prepareHookTasks(x, repo, event, p, []*Webhook{webhook})\n}\n\nfunc (t *HookTask) deliver() {\n\tt.IsDelivered = true\n\n\ttimeout := time.Duration(conf.Webhook.DeliverTimeout) * time.Second\n\treq := httplib.Post(t.URL).SetTimeout(timeout, timeout).\n\t\tHeader(\"X-Github-Delivery\", t.UUID).\n\t\tHeader(\"X-Github-Event\", string(t.EventType)).\n\t\tHeader(\"X-Gogs-Delivery\", t.UUID).\n\t\tHeader(\"X-Gogs-Signature\", t.Signature).\n\t\tHeader(\"X-Gogs-Event\", string(t.EventType)).\n\t\tSetTLSClientConfig(&tls.Config{InsecureSkipVerify: conf.Webhook.SkipTLSVerify})\n\n\tswitch t.ContentType {\n\tcase JSON:\n\t\treq = req.Header(\"Content-Type\", \"application/json\").Body(t.PayloadContent)\n\tcase FORM:\n\t\treq.Param(\"payload\", t.PayloadContent)\n\t}\n\n\t// Record delivery information.\n\tt.RequestInfo = &HookRequest{\n\t\tHeaders: map[string]string{},\n\t}\n\tfor k, vals := range req.Headers() {\n\t\tt.RequestInfo.Headers[k] = strings.Join(vals, \",\")\n\t}\n\n\tt.ResponseInfo = &HookResponse{\n\t\tHeaders: map[string]string{},\n\t}\n\n\tdefer func() {\n\t\tt.Delivered = time.Now().UnixNano()\n\t\tif t.IsSucceed {\n\t\t\tlog.Trace(\"Hook delivered: %s\", t.UUID)\n\t\t} else {\n\t\t\tlog.Trace(\"Hook delivery failed: %s\", t.UUID)\n\t\t}\n\n\t\t// Update webhook last delivery status.\n\t\tw, err := GetWebhookByID(t.HookID)\n\t\tif err != nil {\n\t\t\tlog.Error(\"GetWebhookByID: %v\", err)\n\t\t\treturn\n\t\t}\n\t\tif t.IsSucceed {\n\t\t\tw.LastStatus = HOOK_STATUS_SUCCEED\n\t\t} else {\n\t\t\tw.LastStatus = HOOK_STATUS_FAILED\n\t\t}\n\t\tif err = UpdateWebhook(w); err != nil {\n\t\t\tlog.Error(\"UpdateWebhook: %v\", err)\n\t\t\treturn\n\t\t}\n\t}()\n\n\tresp, err := req.Response()\n\tif err != nil {\n\t\tt.ResponseInfo.Body = fmt.Sprintf(\"Delivery: %v\", err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\t// Status code is 20x can be seen as succeed.\n\tt.IsSucceed = resp.StatusCode/100 == 2\n\tt.ResponseInfo.Status = resp.StatusCode\n\tfor k, vals := range resp.Header {\n\t\tt.ResponseInfo.Headers[k] = strings.Join(vals, \",\")\n\t}\n\n\tp, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tt.ResponseInfo.Body = fmt.Sprintf(\"read body: %s\", err)\n\t\treturn\n\t}\n\tt.ResponseInfo.Body = string(p)\n}\n\n// DeliverHooks checks and delivers undelivered hooks.\n// TODO: shoot more hooks at same time.\nfunc DeliverHooks() {\n\ttasks := make([]*HookTask, 0, 10)\n\t_ = x.Where(\"is_delivered = ?\", false).Iterate(new(HookTask),\n\t\tfunc(idx int, bean interface{}) error {\n\t\t\tt := bean.(*HookTask)\n\t\t\tt.deliver()\n\t\t\ttasks = append(tasks, t)\n\t\t\treturn nil\n\t\t})\n\n\t// Update hook task status.\n\tfor _, t := range tasks {\n\t\tif err := UpdateHookTask(t); err != nil {\n\t\t\tlog.Error(\"UpdateHookTask [%d]: %v\", t.ID, err)\n\t\t}\n\t}\n\n\t// Start listening on new hook requests.\n\tfor repoID := range HookQueue.Queue() {\n\t\tlog.Trace(\"DeliverHooks [repo_id: %v]\", repoID)\n\t\tHookQueue.Remove(repoID)\n\n\t\ttasks = make([]*HookTask, 0, 5)\n\t\tif err := x.Where(\"repo_id = ?\", repoID).And(\"is_delivered = ?\", false).Find(&tasks); err != nil {\n\t\t\tlog.Error(\"Get repository [%s] hook tasks: %v\", repoID, err)\n\t\t\tcontinue\n\t\t}\n\t\tfor _, t := range tasks {\n\t\t\tt.deliver()\n\t\t\tif err := UpdateHookTask(t); err != nil {\n\t\t\t\tlog.Error(\"UpdateHookTask [%d]: %v\", t.ID, err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc InitDeliverHooks() {\n\tgo DeliverHooks()\n}\n", "// Copyright 2014 The Gogs Authors. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage form\n\nimport (\n\t\"net/url\"\n\t\"strings\"\n\n\t\"github.com/go-macaron/binding\"\n\t\"github.com/unknwon/com\"\n\t\"gopkg.in/macaron.v1\"\n\n\t\"gogs.io/gogs/internal/conf\"\n\t\"gogs.io/gogs/internal/db\"\n\t\"gogs.io/gogs/internal/netutil\"\n)\n\n// _______________________________________    _________.______________________ _______________.___.\n// \\______   \\_   _____/\\______   \\_____  \\  /   _____/|   \\__    ___/\\_____  \\\\______   \\__  |   |\n//  |       _/|    __)_  |     ___//   |   \\ \\_____  \\ |   | |    |    /   |   \\|       _//   |   |\n//  |    |   \\|        \\ |    |   /    |    \\/        \\|   | |    |   /    |    \\    |   \\\\____   |\n//  |____|_  /_______  / |____|   \\_______  /_______  /|___| |____|   \\_______  /____|_  // ______|\n//         \\/        \\/                   \\/        \\/                        \\/       \\/ \\/\n\ntype CreateRepo struct {\n\tUserID      int64  `binding:\"Required\"`\n\tRepoName    string `binding:\"Required;AlphaDashDot;MaxSize(100)\"`\n\tPrivate     bool\n\tUnlisted    bool\n\tDescription string `binding:\"MaxSize(512)\"`\n\tAutoInit    bool\n\tGitignores  string\n\tLicense     string\n\tReadme      string\n}\n\nfunc (f *CreateRepo) Validate(ctx *macaron.Context, errs binding.Errors) binding.Errors {\n\treturn validate(errs, ctx.Data, f, ctx.Locale)\n}\n\ntype MigrateRepo struct {\n\tCloneAddr    string `json:\"clone_addr\" binding:\"Required\"`\n\tAuthUsername string `json:\"auth_username\"`\n\tAuthPassword string `json:\"auth_password\"`\n\tUid          int64  `json:\"uid\" binding:\"Required\"`\n\tRepoName     string `json:\"repo_name\" binding:\"Required;AlphaDashDot;MaxSize(100)\"`\n\tMirror       bool   `json:\"mirror\"`\n\tPrivate      bool   `json:\"private\"`\n\tUnlisted     bool   `json:\"unlisted\"`\n\tDescription  string `json:\"description\" binding:\"MaxSize(512)\"`\n}\n\nfunc (f *MigrateRepo) Validate(ctx *macaron.Context, errs binding.Errors) binding.Errors {\n\treturn validate(errs, ctx.Data, f, ctx.Locale)\n}\n\n// ParseRemoteAddr checks if given remote address is valid,\n// and returns composed URL with needed username and password.\n// It also checks if given user has permission when remote address\n// is actually a local path.\nfunc (f MigrateRepo) ParseRemoteAddr(user *db.User) (string, error) {\n\tremoteAddr := strings.TrimSpace(f.CloneAddr)\n\n\t// Remote address can be HTTP/HTTPS/Git URL or local path.\n\tif strings.HasPrefix(remoteAddr, \"http://\") ||\n\t\tstrings.HasPrefix(remoteAddr, \"https://\") ||\n\t\tstrings.HasPrefix(remoteAddr, \"git://\") {\n\t\tu, err := url.Parse(remoteAddr)\n\t\tif err != nil {\n\t\t\treturn \"\", db.ErrInvalidCloneAddr{IsURLError: true}\n\t\t}\n\n\t\tif netutil.IsLocalHostname(u.Hostname(), conf.Security.LocalNetworkAllowlist) {\n\t\t\treturn \"\", db.ErrInvalidCloneAddr{IsURLError: true}\n\t\t}\n\n\t\tif len(f.AuthUsername)+len(f.AuthPassword) > 0 {\n\t\t\tu.User = url.UserPassword(f.AuthUsername, f.AuthPassword)\n\t\t}\n\t\t// To prevent CRLF injection in git protocol, see https://github.com/gogs/gogs/issues/6413\n\t\tif u.Scheme == \"git\" && (strings.Contains(remoteAddr, \"%0d\") || strings.Contains(remoteAddr, \"%0a\")) {\n\t\t\treturn \"\", db.ErrInvalidCloneAddr{IsURLError: true}\n\t\t}\n\t\tremoteAddr = u.String()\n\t} else if !user.CanImportLocal() {\n\t\treturn \"\", db.ErrInvalidCloneAddr{IsPermissionDenied: true}\n\t} else if !com.IsDir(remoteAddr) {\n\t\treturn \"\", db.ErrInvalidCloneAddr{IsInvalidPath: true}\n\t}\n\n\treturn remoteAddr, nil\n}\n\ntype RepoSetting struct {\n\tRepoName      string `binding:\"Required;AlphaDashDot;MaxSize(100)\"`\n\tDescription   string `binding:\"MaxSize(512)\"`\n\tWebsite       string `binding:\"Url;MaxSize(100)\"`\n\tBranch        string\n\tInterval      int\n\tMirrorAddress string\n\tPrivate       bool\n\tUnlisted      bool\n\tEnablePrune   bool\n\n\t// Advanced settings\n\tEnableWiki            bool\n\tAllowPublicWiki       bool\n\tEnableExternalWiki    bool\n\tExternalWikiURL       string\n\tEnableIssues          bool\n\tAllowPublicIssues     bool\n\tEnableExternalTracker bool\n\tExternalTrackerURL    string\n\tTrackerURLFormat      string\n\tTrackerIssueStyle     string\n\tEnablePulls           bool\n\tPullsIgnoreWhitespace bool\n\tPullsAllowRebase      bool\n}\n\nfunc (f *RepoSetting) Validate(ctx *macaron.Context, errs binding.Errors) binding.Errors {\n\treturn validate(errs, ctx.Data, f, ctx.Locale)\n}\n\n// __________                             .__\n// \\______   \\____________    ____   ____ |  |__\n//  |    |  _/\\_  __ \\__  \\  /    \\_/ ___\\|  |  \\\n//  |    |   \\ |  | \\// __ \\|   |  \\  \\___|   Y  \\\n//  |______  / |__|  (____  /___|  /\\___  >___|  /\n//         \\/             \\/     \\/     \\/     \\/\n\ntype ProtectBranch struct {\n\tProtected          bool\n\tRequirePullRequest bool\n\tEnableWhitelist    bool\n\tWhitelistUsers     string\n\tWhitelistTeams     string\n}\n\nfunc (f *ProtectBranch) Validate(ctx *macaron.Context, errs binding.Errors) binding.Errors {\n\treturn validate(errs, ctx.Data, f, ctx.Locale)\n}\n\n//  __      __      ___.   .__    .__            __\n// /  \\    /  \\ ____\\_ |__ |  |__ |  |__   ____ |  | __\n// \\   \\/\\/   // __ \\| __ \\|  |  \\|  |  \\ /  _ \\|  |/ /\n//  \\        /\\  ___/| \\_\\ \\   Y  \\   Y  (  <_> )    <\n//   \\__/\\  /  \\___  >___  /___|  /___|  /\\____/|__|_ \\\n//        \\/       \\/    \\/     \\/     \\/            \\/\n\ntype Webhook struct {\n\tEvents       string\n\tCreate       bool\n\tDelete       bool\n\tFork         bool\n\tPush         bool\n\tIssues       bool\n\tIssueComment bool\n\tPullRequest  bool\n\tRelease      bool\n\tActive       bool\n}\n\nfunc (f Webhook) PushOnly() bool {\n\treturn f.Events == \"push_only\"\n}\n\nfunc (f Webhook) SendEverything() bool {\n\treturn f.Events == \"send_everything\"\n}\n\nfunc (f Webhook) ChooseEvents() bool {\n\treturn f.Events == \"choose_events\"\n}\n\ntype NewWebhook struct {\n\tPayloadURL  string `binding:\"Required;Url\"`\n\tContentType int    `binding:\"Required\"`\n\tSecret      string\n\tWebhook\n}\n\nfunc (f *NewWebhook) Validate(ctx *macaron.Context, errs binding.Errors) binding.Errors {\n\treturn validate(errs, ctx.Data, f, ctx.Locale)\n}\n\ntype NewSlackHook struct {\n\tPayloadURL string `binding:\"Required;Url\"`\n\tChannel    string `binding:\"Required\"`\n\tUsername   string\n\tIconURL    string\n\tColor      string\n\tWebhook\n}\n\nfunc (f *NewSlackHook) Validate(ctx *macaron.Context, errs binding.Errors) binding.Errors {\n\treturn validate(errs, ctx.Data, f, ctx.Locale)\n}\n\ntype NewDiscordHook struct {\n\tPayloadURL string `binding:\"Required;Url\"`\n\tUsername   string\n\tIconURL    string\n\tColor      string\n\tWebhook\n}\n\nfunc (f *NewDiscordHook) Validate(ctx *macaron.Context, errs binding.Errors) binding.Errors {\n\treturn validate(errs, ctx.Data, f, ctx.Locale)\n}\n\ntype NewDingtalkHook struct {\n\tPayloadURL string `binding:\"Required;Url\"`\n\tWebhook\n}\n\nfunc (f *NewDingtalkHook) Validate(ctx *macaron.Context, errs binding.Errors) binding.Errors {\n\treturn validate(errs, ctx.Data, f, ctx.Locale)\n}\n\n// .___\n// |   | ______ ________ __   ____\n// |   |/  ___//  ___/  |  \\_/ __ \\\n// |   |\\___ \\ \\___ \\|  |  /\\  ___/\n// |___/____  >____  >____/  \\___  >\n//          \\/     \\/            \\/\n\ntype NewIssue struct {\n\tTitle       string `binding:\"Required;MaxSize(255)\"`\n\tLabelIDs    string `form:\"label_ids\"`\n\tMilestoneID int64\n\tAssigneeID  int64\n\tContent     string\n\tFiles       []string\n}\n\nfunc (f *NewIssue) Validate(ctx *macaron.Context, errs binding.Errors) binding.Errors {\n\treturn validate(errs, ctx.Data, f, ctx.Locale)\n}\n\ntype CreateComment struct {\n\tContent string\n\tStatus  string `binding:\"OmitEmpty;In(reopen,close)\"`\n\tFiles   []string\n}\n\nfunc (f *CreateComment) Validate(ctx *macaron.Context, errs binding.Errors) binding.Errors {\n\treturn validate(errs, ctx.Data, f, ctx.Locale)\n}\n\n//    _____  .__.__                   __\n//   /     \\ |__|  |   ____   _______/  |_  ____   ____   ____\n//  /  \\ /  \\|  |  | _/ __ \\ /  ___/\\   __\\/  _ \\ /    \\_/ __ \\\n// /    Y    \\  |  |_\\  ___/ \\___ \\  |  | (  <_> )   |  \\  ___/\n// \\____|__  /__|____/\\___  >____  > |__|  \\____/|___|  /\\___  >\n//         \\/             \\/     \\/                   \\/     \\/\n\ntype CreateMilestone struct {\n\tTitle    string `binding:\"Required;MaxSize(50)\"`\n\tContent  string\n\tDeadline string\n}\n\nfunc (f *CreateMilestone) Validate(ctx *macaron.Context, errs binding.Errors) binding.Errors {\n\treturn validate(errs, ctx.Data, f, ctx.Locale)\n}\n\n// .____          ___.          .__\n// |    |   _____ \\_ |__   ____ |  |\n// |    |   \\__  \\ | __ \\_/ __ \\|  |\n// |    |___ / __ \\| \\_\\ \\  ___/|  |__\n// |_______ (____  /___  /\\___  >____/\n//         \\/    \\/    \\/     \\/\n\ntype CreateLabel struct {\n\tID    int64\n\tTitle string `binding:\"Required;MaxSize(50)\" locale:\"repo.issues.label_title\"`\n\tColor string `binding:\"Required;Size(7)\" locale:\"repo.issues.label_color\"`\n}\n\nfunc (f *CreateLabel) Validate(ctx *macaron.Context, errs binding.Errors) binding.Errors {\n\treturn validate(errs, ctx.Data, f, ctx.Locale)\n}\n\ntype InitializeLabels struct {\n\tTemplateName string `binding:\"Required\"`\n}\n\nfunc (f *InitializeLabels) Validate(ctx *macaron.Context, errs binding.Errors) binding.Errors {\n\treturn validate(errs, ctx.Data, f, ctx.Locale)\n}\n\n// __________       .__\n// \\______   \\ ____ |  |   ____ _____    ______ ____\n//  |       _// __ \\|  | _/ __ \\\\__  \\  /  ___// __ \\\n//  |    |   \\  ___/|  |_\\  ___/ / __ \\_\\___ \\\\  ___/\n//  |____|_  /\\___  >____/\\___  >____  /____  >\\___  >\n//         \\/     \\/          \\/     \\/     \\/     \\/\n\ntype NewRelease struct {\n\tTagName    string `binding:\"Required\"`\n\tTarget     string `form:\"tag_target\" binding:\"Required\"`\n\tTitle      string `binding:\"Required\"`\n\tContent    string\n\tDraft      string\n\tPrerelease bool\n\tFiles      []string\n}\n\nfunc (f *NewRelease) Validate(ctx *macaron.Context, errs binding.Errors) binding.Errors {\n\treturn validate(errs, ctx.Data, f, ctx.Locale)\n}\n\ntype EditRelease struct {\n\tTitle      string `binding:\"Required\"`\n\tContent    string\n\tDraft      string\n\tPrerelease bool\n\tFiles      []string\n}\n\nfunc (f *EditRelease) Validate(ctx *macaron.Context, errs binding.Errors) binding.Errors {\n\treturn validate(errs, ctx.Data, f, ctx.Locale)\n}\n\n//  __      __.__ __   .__\n// /  \\    /  \\__|  | _|__|\n// \\   \\/\\/   /  |  |/ /  |\n//  \\        /|  |    <|  |\n//   \\__/\\  / |__|__|_ \\__|\n//        \\/          \\/\n\ntype NewWiki struct {\n\tOldTitle string\n\tTitle    string `binding:\"Required\"`\n\tContent  string `binding:\"Required\"`\n\tMessage  string\n}\n\n// FIXME: use code generation to generate this method.\nfunc (f *NewWiki) Validate(ctx *macaron.Context, errs binding.Errors) binding.Errors {\n\treturn validate(errs, ctx.Data, f, ctx.Locale)\n}\n\n// ___________    .___.__  __\n// \\_   _____/  __| _/|__|/  |_\n//  |    __)_  / __ | |  \\   __\\\n//  |        \\/ /_/ | |  ||  |\n// /_______  /\\____ | |__||__|\n//         \\/      \\/\n\ntype EditRepoFile struct {\n\tTreePath      string `binding:\"Required;MaxSize(500)\"`\n\tContent       string `binding:\"Required\"`\n\tCommitSummary string `binding:\"MaxSize(100)\"`\n\tCommitMessage string\n\tCommitChoice  string `binding:\"Required;MaxSize(50)\"`\n\tNewBranchName string `binding:\"AlphaDashDotSlash;MaxSize(100)\"`\n\tLastCommit    string\n}\n\nfunc (f *EditRepoFile) Validate(ctx *macaron.Context, errs binding.Errors) binding.Errors {\n\treturn validate(errs, ctx.Data, f, ctx.Locale)\n}\n\nfunc (f *EditRepoFile) IsNewBrnach() bool {\n\treturn f.CommitChoice == \"commit-to-new-branch\"\n}\n\ntype EditPreviewDiff struct {\n\tContent string\n}\n\nfunc (f *EditPreviewDiff) Validate(ctx *macaron.Context, errs binding.Errors) binding.Errors {\n\treturn validate(errs, ctx.Data, f, ctx.Locale)\n}\n\n//  ____ ___        .__                    .___\n// |    |   \\______ |  |   _________     __| _/\n// |    |   /\\____ \\|  |  /  _ \\__  \\   / __ |\n// |    |  / |  |_> >  |_(  <_> ) __ \\_/ /_/ |\n// |______/  |   __/|____/\\____(____  /\\____ |\n//           |__|                   \\/      \\/\n//\n\ntype UploadRepoFile struct {\n\tTreePath      string `binding:\"MaxSize(500)\"`\n\tCommitSummary string `binding:\"MaxSize(100)\"`\n\tCommitMessage string\n\tCommitChoice  string `binding:\"Required;MaxSize(50)\"`\n\tNewBranchName string `binding:\"AlphaDashDot;MaxSize(100)\"`\n\tFiles         []string\n}\n\nfunc (f *UploadRepoFile) Validate(ctx *macaron.Context, errs binding.Errors) binding.Errors {\n\treturn validate(errs, ctx.Data, f, ctx.Locale)\n}\n\nfunc (f *UploadRepoFile) IsNewBrnach() bool {\n\treturn f.CommitChoice == \"commit-to-new-branch\"\n}\n\ntype RemoveUploadFile struct {\n\tFile string `binding:\"Required;MaxSize(50)\"`\n}\n\nfunc (f *RemoveUploadFile) Validate(ctx *macaron.Context, errs binding.Errors) binding.Errors {\n\treturn validate(errs, ctx.Data, f, ctx.Locale)\n}\n\n// ________         .__          __\n// \\______ \\   ____ |  |   _____/  |_  ____\n// |    |  \\_/ __ \\|  | _/ __ \\   __\\/ __ \\\n// |    `   \\  ___/|  |_\\  ___/|  | \\  ___/\n// /_______  /\\___  >____/\\___  >__|  \\___  >\n//         \\/     \\/          \\/          \\/\n\ntype DeleteRepoFile struct {\n\tCommitSummary string `binding:\"MaxSize(100)\"`\n\tCommitMessage string\n\tCommitChoice  string `binding:\"Required;MaxSize(50)\"`\n\tNewBranchName string `binding:\"AlphaDashDot;MaxSize(100)\"`\n}\n\nfunc (f *DeleteRepoFile) Validate(ctx *macaron.Context, errs binding.Errors) binding.Errors {\n\treturn validate(errs, ctx.Data, f, ctx.Locale)\n}\n\nfunc (f *DeleteRepoFile) IsNewBrnach() bool {\n\treturn f.CommitChoice == \"commit-to-new-branch\"\n}\n", "// Copyright 2022 The Gogs Authors. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage netutil\n\nimport (\n\t\"fmt\"\n\t\"net\"\n)\n\nvar localCIDRs []*net.IPNet\n\nfunc init() {\n\t// Parsing hardcoded CIDR strings should never fail, if in case it does, let's\n\t// fail it at start.\n\trawCIDRs := []string{\n\t\t// https://datatracker.ietf.org/doc/html/rfc5735:\n\t\t\"127.0.0.0/8\",        // Loopback\n\t\t\"0.0.0.0/8\",          // \"This\" network\n\t\t\"100.64.0.0/10\",      // Shared address space\n\t\t\"169.254.0.0/16\",     // Link local\n\t\t\"172.16.0.0/12\",      // Private-use networks\n\t\t\"192.0.0.0/24\",       // IETF Protocol assignments\n\t\t\"192.0.2.0/24\",       // TEST-NET-1\n\t\t\"192.88.99.0/24\",     // 6to4 Relay anycast\n\t\t\"192.168.0.0/16\",     // Private-use networks\n\t\t\"198.18.0.0/15\",      // Network interconnect\n\t\t\"198.51.100.0/24\",    // TEST-NET-2\n\t\t\"203.0.113.0/24\",     // TEST-NET-3\n\t\t\"255.255.255.255/32\", // Limited broadcast\n\n\t\t// https://datatracker.ietf.org/doc/html/rfc1918:\n\t\t\"10.0.0.0/8\", // Private-use networks\n\n\t\t// https://datatracker.ietf.org/doc/html/rfc6890:\n\t\t\"::1/128\",   // Loopback\n\t\t\"FC00::/7\",  // Unique local address\n\t\t\"FE80::/10\", // Multicast address\n\t}\n\tfor _, raw := range rawCIDRs {\n\t\t_, cidr, err := net.ParseCIDR(raw)\n\t\tif err != nil {\n\t\t\tpanic(fmt.Sprintf(\"parse CIDR %q: %v\", raw, err))\n\t\t}\n\t\tlocalCIDRs = append(localCIDRs, cidr)\n\t}\n}\n\n// IsLocalHostname returns true if given hostname is resolved to local network\n// address, except exempted from the allowlist.\nfunc IsLocalHostname(hostname string, allowlist []string) bool {\n\tfor _, allow := range allowlist {\n\t\tif hostname == allow {\n\t\t\treturn false\n\t\t}\n\t}\n\n\tips, err := net.LookupIP(hostname)\n\tif err != nil {\n\t\treturn true\n\t}\n\tfor _, ip := range ips {\n\t\tfor _, cidr := range localCIDRs {\n\t\t\tif cidr.Contains(ip) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n", "// Copyright 2022 The Gogs Authors. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage netutil\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestIsLocalHostname(t *testing.T) {\n\ttests := []struct {\n\t\thostname  string\n\t\tallowlist []string\n\t\twant      bool\n\t}{\n\t\t{hostname: \"localhost\", want: true},       // #00\n\t\t{hostname: \"127.0.0.1\", want: true},       // #01\n\t\t{hostname: \"::1\", want: true},             // #02\n\t\t{hostname: \"0:0:0:0:0:0:0:1\", want: true}, // #03\n\t\t{hostname: \"fuf.me\", want: true},          // #04\n\t\t{hostname: \"127.0.0.95\", want: true},      // #05\n\t\t{hostname: \"0.0.0.0\", want: true},         // #06\n\t\t{hostname: \"192.168.123.45\", want: true},  // #07\n\n\t\t{hostname: \"gogs.io\", want: false},         // #08\n\t\t{hostname: \"google.com\", want: false},      // #09\n\t\t{hostname: \"165.232.140.255\", want: false}, // #10\n\n\t\t{hostname: \"192.168.123.45\", allowlist: []string{\"10.0.0.17\"}, want: true}, // #11\n\t\t{hostname: \"gogs.local\", allowlist: []string{\"gogs.local\"}, want: false},   // #12\n\t}\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tassert.Equal(t, test.want, IsLocalHostname(test.hostname, test.allowlist))\n\t\t})\n\t}\n}\n", "// Copyright 2014 The Gogs Authors. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage repo\n\nimport (\n\t\"net/http\"\n\t\"path\"\n\n\tapi \"github.com/gogs/go-gogs-client\"\n\t\"github.com/pkg/errors\"\n\tlog \"unknwon.dev/clog/v2\"\n\n\t\"gogs.io/gogs/internal/conf\"\n\t\"gogs.io/gogs/internal/context\"\n\t\"gogs.io/gogs/internal/db\"\n\t\"gogs.io/gogs/internal/form\"\n\t\"gogs.io/gogs/internal/route/api/v1/convert\"\n)\n\nfunc Search(c *context.APIContext) {\n\topts := &db.SearchRepoOptions{\n\t\tKeyword:  path.Base(c.Query(\"q\")),\n\t\tOwnerID:  c.QueryInt64(\"uid\"),\n\t\tPageSize: convert.ToCorrectPageSize(c.QueryInt(\"limit\")),\n\t\tPage:     c.QueryInt(\"page\"),\n\t}\n\n\t// Check visibility.\n\tif c.IsLogged && opts.OwnerID > 0 {\n\t\tif c.User.ID == opts.OwnerID {\n\t\t\topts.Private = true\n\t\t} else {\n\t\t\tu, err := db.GetUserByID(opts.OwnerID)\n\t\t\tif err != nil {\n\t\t\t\tc.JSON(http.StatusInternalServerError, map[string]interface{}{\n\t\t\t\t\t\"ok\":    false,\n\t\t\t\t\t\"error\": err.Error(),\n\t\t\t\t})\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif u.IsOrganization() && u.IsOwnedBy(c.User.ID) {\n\t\t\t\topts.Private = true\n\t\t\t}\n\t\t\t// FIXME: how about collaborators?\n\t\t}\n\t}\n\n\trepos, count, err := db.SearchRepositoryByName(opts)\n\tif err != nil {\n\t\tc.JSON(http.StatusInternalServerError, map[string]interface{}{\n\t\t\t\"ok\":    false,\n\t\t\t\"error\": err.Error(),\n\t\t})\n\t\treturn\n\t}\n\n\tif err = db.RepositoryList(repos).LoadAttributes(); err != nil {\n\t\tc.JSON(http.StatusInternalServerError, map[string]interface{}{\n\t\t\t\"ok\":    false,\n\t\t\t\"error\": err.Error(),\n\t\t})\n\t\treturn\n\t}\n\n\tresults := make([]*api.Repository, len(repos))\n\tfor i := range repos {\n\t\tresults[i] = repos[i].APIFormat(nil)\n\t}\n\n\tc.SetLinkHeader(int(count), opts.PageSize)\n\tc.JSONSuccess(map[string]interface{}{\n\t\t\"ok\":   true,\n\t\t\"data\": results,\n\t})\n}\n\nfunc listUserRepositories(c *context.APIContext, username string) {\n\tuser, err := db.GetUserByName(username)\n\tif err != nil {\n\t\tc.NotFoundOrError(err, \"get user by name\")\n\t\treturn\n\t}\n\n\t// Only list public repositories if user requests someone else's repository list,\n\t// or an organization isn't a member of.\n\tvar ownRepos []*db.Repository\n\tif user.IsOrganization() {\n\t\townRepos, _, err = user.GetUserRepositories(c.User.ID, 1, user.NumRepos)\n\t} else {\n\t\townRepos, err = db.GetUserRepositories(&db.UserRepoOptions{\n\t\t\tUserID:   user.ID,\n\t\t\tPrivate:  c.User.ID == user.ID,\n\t\t\tPage:     1,\n\t\t\tPageSize: user.NumRepos,\n\t\t})\n\t}\n\tif err != nil {\n\t\tc.Error(err, \"get user repositories\")\n\t\treturn\n\t}\n\n\tif err = db.RepositoryList(ownRepos).LoadAttributes(); err != nil {\n\t\tc.Error(err, \"load attributes\")\n\t\treturn\n\t}\n\n\t// Early return for querying other user's repositories\n\tif c.User.ID != user.ID {\n\t\trepos := make([]*api.Repository, len(ownRepos))\n\t\tfor i := range ownRepos {\n\t\t\trepos[i] = ownRepos[i].APIFormat(&api.Permission{Admin: true, Push: true, Pull: true})\n\t\t}\n\t\tc.JSONSuccess(&repos)\n\t\treturn\n\t}\n\n\taccessibleRepos, err := user.GetRepositoryAccesses()\n\tif err != nil {\n\t\tc.Error(err, \"get repositories accesses\")\n\t\treturn\n\t}\n\n\tnumOwnRepos := len(ownRepos)\n\trepos := make([]*api.Repository, numOwnRepos+len(accessibleRepos))\n\tfor i := range ownRepos {\n\t\trepos[i] = ownRepos[i].APIFormat(&api.Permission{Admin: true, Push: true, Pull: true})\n\t}\n\n\ti := numOwnRepos\n\tfor repo, access := range accessibleRepos {\n\t\trepos[i] = repo.APIFormat(&api.Permission{\n\t\t\tAdmin: access >= db.AccessModeAdmin,\n\t\t\tPush:  access >= db.AccessModeWrite,\n\t\t\tPull:  true,\n\t\t})\n\t\ti++\n\t}\n\n\tc.JSONSuccess(&repos)\n}\n\nfunc ListMyRepos(c *context.APIContext) {\n\tlistUserRepositories(c, c.User.Name)\n}\n\nfunc ListUserRepositories(c *context.APIContext) {\n\tlistUserRepositories(c, c.Params(\":username\"))\n}\n\nfunc ListOrgRepositories(c *context.APIContext) {\n\tlistUserRepositories(c, c.Params(\":org\"))\n}\n\nfunc CreateUserRepo(c *context.APIContext, owner *db.User, opt api.CreateRepoOption) {\n\trepo, err := db.CreateRepository(c.User, owner, db.CreateRepoOptions{\n\t\tName:        opt.Name,\n\t\tDescription: opt.Description,\n\t\tGitignores:  opt.Gitignores,\n\t\tLicense:     opt.License,\n\t\tReadme:      opt.Readme,\n\t\tIsPrivate:   opt.Private,\n\t\tAutoInit:    opt.AutoInit,\n\t})\n\tif err != nil {\n\t\tif db.IsErrRepoAlreadyExist(err) ||\n\t\t\tdb.IsErrNameNotAllowed(err) {\n\t\t\tc.ErrorStatus(http.StatusUnprocessableEntity, err)\n\t\t} else {\n\t\t\tif repo != nil {\n\t\t\t\tif err = db.DeleteRepository(c.User.ID, repo.ID); err != nil {\n\t\t\t\t\tlog.Error(\"Failed to delete repository: %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tc.Error(err, \"create repository\")\n\t\t}\n\t\treturn\n\t}\n\n\tc.JSON(201, repo.APIFormat(&api.Permission{Admin: true, Push: true, Pull: true}))\n}\n\nfunc Create(c *context.APIContext, opt api.CreateRepoOption) {\n\t// Shouldn't reach this condition, but just in case.\n\tif c.User.IsOrganization() {\n\t\tc.ErrorStatus(http.StatusUnprocessableEntity, errors.New(\"Not allowed to create repository for organization.\"))\n\t\treturn\n\t}\n\tCreateUserRepo(c, c.User, opt)\n}\n\nfunc CreateOrgRepo(c *context.APIContext, opt api.CreateRepoOption) {\n\torg, err := db.GetOrgByName(c.Params(\":org\"))\n\tif err != nil {\n\t\tc.NotFoundOrError(err, \"get organization by name\")\n\t\treturn\n\t}\n\n\tif !org.IsOwnedBy(c.User.ID) {\n\t\tc.ErrorStatus(http.StatusForbidden, errors.New(\"Given user is not owner of organization.\"))\n\t\treturn\n\t}\n\tCreateUserRepo(c, org, opt)\n}\n\nfunc Migrate(c *context.APIContext, f form.MigrateRepo) {\n\tctxUser := c.User\n\t// Not equal means context user is an organization,\n\t// or is another user/organization if current user is admin.\n\tif f.Uid != ctxUser.ID {\n\t\torg, err := db.GetUserByID(f.Uid)\n\t\tif err != nil {\n\t\t\tif db.IsErrUserNotExist(err) {\n\t\t\t\tc.ErrorStatus(http.StatusUnprocessableEntity, err)\n\t\t\t} else {\n\t\t\t\tc.Error(err, \"get user by ID\")\n\t\t\t}\n\t\t\treturn\n\t\t} else if !org.IsOrganization() && !c.User.IsAdmin {\n\t\t\tc.ErrorStatus(http.StatusForbidden, errors.New(\"Given user is not an organization.\"))\n\t\t\treturn\n\t\t}\n\t\tctxUser = org\n\t}\n\n\tif c.HasError() {\n\t\tc.ErrorStatus(http.StatusUnprocessableEntity, errors.New(c.GetErrMsg()))\n\t\treturn\n\t}\n\n\tif ctxUser.IsOrganization() && !c.User.IsAdmin {\n\t\t// Check ownership of organization.\n\t\tif !ctxUser.IsOwnedBy(c.User.ID) {\n\t\t\tc.ErrorStatus(http.StatusForbidden, errors.New(\"Given user is not owner of organization.\"))\n\t\t\treturn\n\t\t}\n\t}\n\n\tremoteAddr, err := f.ParseRemoteAddr(c.User)\n\tif err != nil {\n\t\tif db.IsErrInvalidCloneAddr(err) {\n\t\t\taddrErr := err.(db.ErrInvalidCloneAddr)\n\t\t\tswitch {\n\t\t\tcase addrErr.IsURLError:\n\t\t\t\tc.ErrorStatus(http.StatusUnprocessableEntity, err)\n\t\t\tcase addrErr.IsPermissionDenied:\n\t\t\t\tc.ErrorStatus(http.StatusUnprocessableEntity, errors.New(\"You are not allowed to import local repositories.\"))\n\t\t\tcase addrErr.IsInvalidPath:\n\t\t\t\tc.ErrorStatus(http.StatusUnprocessableEntity, errors.New(\"Invalid local path, it does not exist or not a directory.\"))\n\t\t\tdefault:\n\t\t\t\tc.Error(err, \"unexpected error\")\n\t\t\t}\n\t\t} else {\n\t\t\tc.Error(err, \"parse remote address\")\n\t\t}\n\t\treturn\n\t}\n\n\trepo, err := db.MigrateRepository(c.User, ctxUser, db.MigrateRepoOptions{\n\t\tName:        f.RepoName,\n\t\tDescription: f.Description,\n\t\tIsPrivate:   f.Private || conf.Repository.ForcePrivate,\n\t\tIsMirror:    f.Mirror,\n\t\tRemoteAddr:  remoteAddr,\n\t})\n\tif err != nil {\n\t\tif repo != nil {\n\t\t\tif errDelete := db.DeleteRepository(ctxUser.ID, repo.ID); errDelete != nil {\n\t\t\t\tlog.Error(\"DeleteRepository: %v\", errDelete)\n\t\t\t}\n\t\t}\n\n\t\tif db.IsErrReachLimitOfRepo(err) {\n\t\t\tc.ErrorStatus(http.StatusUnprocessableEntity, err)\n\t\t} else {\n\t\t\tc.Error(errors.New(db.HandleMirrorCredentials(err.Error(), true)), \"migrate repository\")\n\t\t}\n\t\treturn\n\t}\n\n\tlog.Trace(\"Repository migrated: %s/%s\", ctxUser.Name, f.RepoName)\n\tc.JSON(201, repo.APIFormat(&api.Permission{Admin: true, Push: true, Pull: true}))\n}\n\n// FIXME: inject in the handler chain\nfunc parseOwnerAndRepo(c *context.APIContext) (*db.User, *db.Repository) {\n\towner, err := db.GetUserByName(c.Params(\":username\"))\n\tif err != nil {\n\t\tif db.IsErrUserNotExist(err) {\n\t\t\tc.ErrorStatus(http.StatusUnprocessableEntity, err)\n\t\t} else {\n\t\t\tc.Error(err, \"get user by name\")\n\t\t}\n\t\treturn nil, nil\n\t}\n\n\trepo, err := db.GetRepositoryByName(owner.ID, c.Params(\":reponame\"))\n\tif err != nil {\n\t\tc.NotFoundOrError(err, \"get repository by name\")\n\t\treturn nil, nil\n\t}\n\n\treturn owner, repo\n}\n\nfunc Get(c *context.APIContext) {\n\t_, repo := parseOwnerAndRepo(c)\n\tif c.Written() {\n\t\treturn\n\t}\n\n\tc.JSONSuccess(repo.APIFormat(&api.Permission{\n\t\tAdmin: c.Repo.IsAdmin(),\n\t\tPush:  c.Repo.IsWriter(),\n\t\tPull:  true,\n\t}))\n}\n\nfunc Delete(c *context.APIContext) {\n\towner, repo := parseOwnerAndRepo(c)\n\tif c.Written() {\n\t\treturn\n\t}\n\n\tif owner.IsOrganization() && !owner.IsOwnedBy(c.User.ID) {\n\t\tc.ErrorStatus(http.StatusForbidden, errors.New(\"Given user is not owner of organization.\"))\n\t\treturn\n\t}\n\n\tif err := db.DeleteRepository(owner.ID, repo.ID); err != nil {\n\t\tc.Error(err, \"delete repository\")\n\t\treturn\n\t}\n\n\tlog.Trace(\"Repository deleted: %s/%s\", owner.Name, repo.Name)\n\tc.NoContent()\n}\n\nfunc ListForks(c *context.APIContext) {\n\tforks, err := c.Repo.Repository.GetForks()\n\tif err != nil {\n\t\tc.Error(err, \"get forks\")\n\t\treturn\n\t}\n\n\tapiForks := make([]*api.Repository, len(forks))\n\tfor i := range forks {\n\t\tif err := forks[i].GetOwner(); err != nil {\n\t\t\tc.Error(err, \"get owner\")\n\t\t\treturn\n\t\t}\n\t\tapiForks[i] = forks[i].APIFormat(&api.Permission{\n\t\t\tAdmin: c.User.IsAdminOfRepo(forks[i]),\n\t\t\tPush:  c.User.IsWriterOfRepo(forks[i]),\n\t\t\tPull:  true,\n\t\t})\n\t}\n\n\tc.JSONSuccess(&apiForks)\n}\n\nfunc IssueTracker(c *context.APIContext, form api.EditIssueTrackerOption) {\n\t_, repo := parseOwnerAndRepo(c)\n\tif c.Written() {\n\t\treturn\n\t}\n\n\tif form.EnableIssues != nil {\n\t\trepo.EnableIssues = *form.EnableIssues\n\t}\n\tif form.EnableExternalTracker != nil {\n\t\trepo.EnableExternalTracker = *form.EnableExternalTracker\n\t}\n\tif form.ExternalTrackerURL != nil {\n\t\trepo.ExternalTrackerURL = *form.ExternalTrackerURL\n\t}\n\tif form.TrackerURLFormat != nil {\n\t\trepo.ExternalTrackerFormat = *form.TrackerURLFormat\n\t}\n\tif form.TrackerIssueStyle != nil {\n\t\trepo.ExternalTrackerStyle = *form.TrackerIssueStyle\n\t}\n\n\tif err := db.UpdateRepository(repo, false); err != nil {\n\t\tc.Error(err, \"update repository\")\n\t\treturn\n\t}\n\n\tc.NoContent()\n}\n\nfunc Wiki(c *context.APIContext, form api.EditWikiOption) {\n\t_, repo := parseOwnerAndRepo(c)\n\tif c.Written() {\n\t\treturn\n\t}\n\n\tif form.AllowPublicWiki != nil {\n\t\trepo.AllowPublicWiki = *form.AllowPublicWiki\n\t}\n\tif form.EnableExternalWiki != nil {\n\t\trepo.EnableExternalWiki = *form.EnableExternalWiki\n\t}\n\tif form.EnableWiki != nil {\n\t\trepo.EnableWiki = *form.EnableWiki\n\t}\n\tif form.ExternalWikiURL != nil {\n\t\trepo.ExternalWikiURL = *form.ExternalWikiURL\n\t}\n\tif err := db.UpdateRepository(repo, false); err != nil {\n\t\tc.Error(err, \"update repository\")\n\t\treturn\n\t}\n\n\tc.NoContent()\n}\n\nfunc MirrorSync(c *context.APIContext) {\n\t_, repo := parseOwnerAndRepo(c)\n\tif c.Written() {\n\t\treturn\n\t} else if !repo.IsMirror {\n\t\tc.NotFound()\n\t\treturn\n\t}\n\n\tgo db.MirrorQueue.Add(repo.ID)\n\tc.Status(http.StatusAccepted)\n}\n\nfunc Releases(c *context.APIContext) {\n\t_, repo := parseOwnerAndRepo(c)\n\treleases, err := db.GetReleasesByRepoID(repo.ID)\n\tif err != nil {\n\t\tc.Error(err, \"get releases by repository ID\")\n\t\treturn\n\t}\n\tapiReleases := make([]*api.Release, 0, len(releases))\n\tfor _, r := range releases {\n\t\tpublisher, err := db.GetUserByID(r.PublisherID)\n\t\tif err != nil {\n\t\t\tc.Error(err, \"get release publisher\")\n\t\t\treturn\n\t\t}\n\t\tr.Publisher = publisher\n\t}\n\tfor _, r := range releases {\n\t\tapiReleases = append(apiReleases, r.APIFormat())\n\t}\n\n\tc.JSONSuccess(&apiReleases)\n}\n", "// Copyright 2014 The Gogs Authors. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage repo\n\nimport (\n\t\"net/http\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/unknwon/com\"\n\tlog \"unknwon.dev/clog/v2\"\n\n\t\"github.com/gogs/git-module\"\n\n\t\"gogs.io/gogs/internal/conf\"\n\t\"gogs.io/gogs/internal/context\"\n\t\"gogs.io/gogs/internal/db\"\n\t\"gogs.io/gogs/internal/form\"\n\t\"gogs.io/gogs/internal/tool\"\n)\n\nconst (\n\tCREATE  = \"repo/create\"\n\tMIGRATE = \"repo/migrate\"\n)\n\nfunc MustBeNotBare(c *context.Context) {\n\tif c.Repo.Repository.IsBare {\n\t\tc.NotFound()\n\t}\n}\n\nfunc checkContextUser(c *context.Context, uid int64) *db.User {\n\torgs, err := db.GetOwnedOrgsByUserIDDesc(c.User.ID, \"updated_unix\")\n\tif err != nil {\n\t\tc.Error(err, \"get owned organization by user ID\")\n\t\treturn nil\n\t}\n\tc.Data[\"Orgs\"] = orgs\n\n\t// Not equal means current user is an organization.\n\tif uid == c.User.ID || uid == 0 {\n\t\treturn c.User\n\t}\n\n\torg, err := db.GetUserByID(uid)\n\tif db.IsErrUserNotExist(err) {\n\t\treturn c.User\n\t}\n\n\tif err != nil {\n\t\tc.Error(err, \"get user by ID\")\n\t\treturn nil\n\t}\n\n\t// Check ownership of organization.\n\tif !org.IsOrganization() || !(c.User.IsAdmin || org.IsOwnedBy(c.User.ID)) {\n\t\tc.Status(http.StatusForbidden)\n\t\treturn nil\n\t}\n\treturn org\n}\n\nfunc Create(c *context.Context) {\n\tc.Title(\"new_repo\")\n\tc.RequireAutosize()\n\n\t// Give default value for template to render.\n\tc.Data[\"Gitignores\"] = db.Gitignores\n\tc.Data[\"Licenses\"] = db.Licenses\n\tc.Data[\"Readmes\"] = db.Readmes\n\tc.Data[\"readme\"] = \"Default\"\n\tc.Data[\"private\"] = c.User.LastRepoVisibility\n\tc.Data[\"IsForcedPrivate\"] = conf.Repository.ForcePrivate\n\n\tctxUser := checkContextUser(c, c.QueryInt64(\"org\"))\n\tif c.Written() {\n\t\treturn\n\t}\n\tc.Data[\"ContextUser\"] = ctxUser\n\n\tc.Success(CREATE)\n}\n\nfunc handleCreateError(c *context.Context, owner *db.User, err error, name, tpl string, form interface{}) {\n\tswitch {\n\tcase db.IsErrReachLimitOfRepo(err):\n\t\tc.RenderWithErr(c.Tr(\"repo.form.reach_limit_of_creation\", owner.RepoCreationNum()), tpl, form)\n\tcase db.IsErrRepoAlreadyExist(err):\n\t\tc.Data[\"Err_RepoName\"] = true\n\t\tc.RenderWithErr(c.Tr(\"form.repo_name_been_taken\"), tpl, form)\n\tcase db.IsErrNameNotAllowed(err):\n\t\tc.Data[\"Err_RepoName\"] = true\n\t\tc.RenderWithErr(c.Tr(\"repo.form.name_not_allowed\", err.(db.ErrNameNotAllowed).Value()), tpl, form)\n\tdefault:\n\t\tc.Error(err, name)\n\t}\n}\n\nfunc CreatePost(c *context.Context, f form.CreateRepo) {\n\tc.Data[\"Title\"] = c.Tr(\"new_repo\")\n\n\tc.Data[\"Gitignores\"] = db.Gitignores\n\tc.Data[\"Licenses\"] = db.Licenses\n\tc.Data[\"Readmes\"] = db.Readmes\n\n\tctxUser := checkContextUser(c, f.UserID)\n\tif c.Written() {\n\t\treturn\n\t}\n\tc.Data[\"ContextUser\"] = ctxUser\n\n\tif c.HasError() {\n\t\tc.Success(CREATE)\n\t\treturn\n\t}\n\n\trepo, err := db.CreateRepository(c.User, ctxUser, db.CreateRepoOptions{\n\t\tName:        f.RepoName,\n\t\tDescription: f.Description,\n\t\tGitignores:  f.Gitignores,\n\t\tLicense:     f.License,\n\t\tReadme:      f.Readme,\n\t\tIsPrivate:   f.Private || conf.Repository.ForcePrivate,\n\t\tIsUnlisted:  f.Unlisted,\n\t\tAutoInit:    f.AutoInit,\n\t})\n\tif err == nil {\n\t\tlog.Trace(\"Repository created [%d]: %s/%s\", repo.ID, ctxUser.Name, repo.Name)\n\t\tc.Redirect(conf.Server.Subpath + \"/\" + ctxUser.Name + \"/\" + repo.Name)\n\t\treturn\n\t}\n\n\tif repo != nil {\n\t\tif errDelete := db.DeleteRepository(ctxUser.ID, repo.ID); errDelete != nil {\n\t\t\tlog.Error(\"DeleteRepository: %v\", errDelete)\n\t\t}\n\t}\n\n\thandleCreateError(c, ctxUser, err, \"CreatePost\", CREATE, &f)\n}\n\nfunc Migrate(c *context.Context) {\n\tc.Data[\"Title\"] = c.Tr(\"new_migrate\")\n\tc.Data[\"private\"] = c.User.LastRepoVisibility\n\tc.Data[\"IsForcedPrivate\"] = conf.Repository.ForcePrivate\n\tc.Data[\"mirror\"] = c.Query(\"mirror\") == \"1\"\n\n\tctxUser := checkContextUser(c, c.QueryInt64(\"org\"))\n\tif c.Written() {\n\t\treturn\n\t}\n\tc.Data[\"ContextUser\"] = ctxUser\n\n\tc.Success(MIGRATE)\n}\n\nfunc MigratePost(c *context.Context, f form.MigrateRepo) {\n\tc.Data[\"Title\"] = c.Tr(\"new_migrate\")\n\n\tctxUser := checkContextUser(c, f.Uid)\n\tif c.Written() {\n\t\treturn\n\t}\n\tc.Data[\"ContextUser\"] = ctxUser\n\n\tif c.HasError() {\n\t\tc.Success(MIGRATE)\n\t\treturn\n\t}\n\n\tremoteAddr, err := f.ParseRemoteAddr(c.User)\n\tif err != nil {\n\t\tif db.IsErrInvalidCloneAddr(err) {\n\t\t\tc.Data[\"Err_CloneAddr\"] = true\n\t\t\taddrErr := err.(db.ErrInvalidCloneAddr)\n\t\t\tswitch {\n\t\t\tcase addrErr.IsURLError:\n\t\t\t\tc.RenderWithErr(c.Tr(\"form.url_error\"), MIGRATE, &f)\n\t\t\tcase addrErr.IsPermissionDenied:\n\t\t\t\tc.RenderWithErr(c.Tr(\"repo.migrate.permission_denied\"), MIGRATE, &f)\n\t\t\tcase addrErr.IsInvalidPath:\n\t\t\t\tc.RenderWithErr(c.Tr(\"repo.migrate.invalid_local_path\"), MIGRATE, &f)\n\t\t\tdefault:\n\t\t\t\tc.Error(err, \"unexpected error\")\n\t\t\t}\n\t\t} else {\n\t\t\tc.Error(err, \"parse remote address\")\n\t\t}\n\t\treturn\n\t}\n\n\trepo, err := db.MigrateRepository(c.User, ctxUser, db.MigrateRepoOptions{\n\t\tName:        f.RepoName,\n\t\tDescription: f.Description,\n\t\tIsPrivate:   f.Private || conf.Repository.ForcePrivate,\n\t\tIsUnlisted:  f.Unlisted,\n\t\tIsMirror:    f.Mirror,\n\t\tRemoteAddr:  remoteAddr,\n\t})\n\tif err == nil {\n\t\tlog.Trace(\"Repository migrated [%d]: %s/%s\", repo.ID, ctxUser.Name, f.RepoName)\n\t\tc.Redirect(conf.Server.Subpath + \"/\" + ctxUser.Name + \"/\" + f.RepoName)\n\t\treturn\n\t}\n\n\tif repo != nil {\n\t\tif errDelete := db.DeleteRepository(ctxUser.ID, repo.ID); errDelete != nil {\n\t\t\tlog.Error(\"DeleteRepository: %v\", errDelete)\n\t\t}\n\t}\n\n\tif strings.Contains(err.Error(), \"Authentication failed\") ||\n\t\tstrings.Contains(err.Error(), \"could not read Username\") {\n\t\tc.Data[\"Err_Auth\"] = true\n\t\tc.RenderWithErr(c.Tr(\"form.auth_failed\", db.HandleMirrorCredentials(err.Error(), true)), MIGRATE, &f)\n\t\treturn\n\t} else if strings.Contains(err.Error(), \"fatal:\") {\n\t\tc.Data[\"Err_CloneAddr\"] = true\n\t\tc.RenderWithErr(c.Tr(\"repo.migrate.failed\", db.HandleMirrorCredentials(err.Error(), true)), MIGRATE, &f)\n\t\treturn\n\t}\n\n\thandleCreateError(c, ctxUser, err, \"MigratePost\", MIGRATE, &f)\n}\n\nfunc Action(c *context.Context) {\n\tvar err error\n\tswitch c.Params(\":action\") {\n\tcase \"watch\":\n\t\terr = db.WatchRepo(c.User.ID, c.Repo.Repository.ID, true)\n\tcase \"unwatch\":\n\t\tif userID := c.QueryInt64(\"user_id\"); userID != 0 {\n\t\t\tif c.User.IsAdmin {\n\t\t\t\terr = db.WatchRepo(userID, c.Repo.Repository.ID, false)\n\t\t\t}\n\t\t} else {\n\t\t\terr = db.WatchRepo(c.User.ID, c.Repo.Repository.ID, false)\n\t\t}\n\tcase \"star\":\n\t\terr = db.StarRepo(c.User.ID, c.Repo.Repository.ID, true)\n\tcase \"unstar\":\n\t\terr = db.StarRepo(c.User.ID, c.Repo.Repository.ID, false)\n\tcase \"desc\": // FIXME: this is not used\n\t\tif !c.Repo.IsOwner() {\n\t\t\tc.NotFound()\n\t\t\treturn\n\t\t}\n\n\t\tc.Repo.Repository.Description = c.Query(\"desc\")\n\t\tc.Repo.Repository.Website = c.Query(\"site\")\n\t\terr = db.UpdateRepository(c.Repo.Repository, false)\n\t}\n\n\tif err != nil {\n\t\tc.Errorf(err, \"action %q\", c.Params(\":action\"))\n\t\treturn\n\t}\n\n\tredirectTo := c.Query(\"redirect_to\")\n\tif !tool.IsSameSiteURLPath(redirectTo) {\n\t\tredirectTo = c.Repo.RepoLink\n\t}\n\tc.Redirect(redirectTo)\n}\n\nfunc Download(c *context.Context) {\n\tvar (\n\t\turi           = c.Params(\"*\")\n\t\trefName       string\n\t\text           string\n\t\tarchivePath   string\n\t\tarchiveFormat git.ArchiveFormat\n\t)\n\n\tswitch {\n\tcase strings.HasSuffix(uri, \".zip\"):\n\t\text = \".zip\"\n\t\tarchivePath = filepath.Join(c.Repo.GitRepo.Path(), \"archives\", \"zip\")\n\t\tarchiveFormat = git.ArchiveZip\n\tcase strings.HasSuffix(uri, \".tar.gz\"):\n\t\text = \".tar.gz\"\n\t\tarchivePath = filepath.Join(c.Repo.GitRepo.Path(), \"archives\", \"targz\")\n\t\tarchiveFormat = git.ArchiveTarGz\n\tdefault:\n\t\tlog.Trace(\"Unknown format: %s\", uri)\n\t\tc.NotFound()\n\t\treturn\n\t}\n\trefName = strings.TrimSuffix(uri, ext)\n\n\tif !com.IsDir(archivePath) {\n\t\tif err := os.MkdirAll(archivePath, os.ModePerm); err != nil {\n\t\t\tc.Error(err, \"create archive directory\")\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Get corresponding commit.\n\tvar (\n\t\tcommit *git.Commit\n\t\terr    error\n\t)\n\tgitRepo := c.Repo.GitRepo\n\tif gitRepo.HasBranch(refName) {\n\t\tcommit, err = gitRepo.BranchCommit(refName)\n\t\tif err != nil {\n\t\t\tc.Error(err, \"get branch commit\")\n\t\t\treturn\n\t\t}\n\t} else if gitRepo.HasTag(refName) {\n\t\tcommit, err = gitRepo.TagCommit(refName)\n\t\tif err != nil {\n\t\t\tc.Error(err, \"get tag commit\")\n\t\t\treturn\n\t\t}\n\t} else if len(refName) >= 7 && len(refName) <= 40 {\n\t\tcommit, err = gitRepo.CatFileCommit(refName)\n\t\tif err != nil {\n\t\t\tc.NotFound()\n\t\t\treturn\n\t\t}\n\t} else {\n\t\tc.NotFound()\n\t\treturn\n\t}\n\n\tarchivePath = path.Join(archivePath, tool.ShortSHA1(commit.ID.String())+ext)\n\tif !com.IsFile(archivePath) {\n\t\tif err := commit.CreateArchive(archiveFormat, archivePath); err != nil {\n\t\t\tc.Error(err, \"creates archive\")\n\t\t\treturn\n\t\t}\n\t}\n\n\tc.ServeFile(archivePath, c.Repo.Repository.Name+\"-\"+refName+ext)\n}\n", "// Copyright 2015 The Gogs Authors. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage repo\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\n\t\"github.com/gogs/git-module\"\n\tapi \"github.com/gogs/go-gogs-client\"\n\tjsoniter \"github.com/json-iterator/go\"\n\t\"gopkg.in/macaron.v1\"\n\n\t\"gogs.io/gogs/internal/conf\"\n\t\"gogs.io/gogs/internal/context\"\n\t\"gogs.io/gogs/internal/db\"\n\t\"gogs.io/gogs/internal/db/errors\"\n\t\"gogs.io/gogs/internal/form\"\n\t\"gogs.io/gogs/internal/netutil\"\n)\n\nconst (\n\ttmplRepoSettingsWebhooks   = \"repo/settings/webhook/base\"\n\ttmplRepoSettingsWebhookNew = \"repo/settings/webhook/new\"\n\ttmplOrgSettingsWebhooks    = \"org/settings/webhooks\"\n\ttmplOrgSettingsWebhookNew  = \"org/settings/webhook_new\"\n)\n\nfunc InjectOrgRepoContext() macaron.Handler {\n\treturn func(c *context.Context) {\n\t\torCtx, err := getOrgRepoContext(c)\n\t\tif err != nil {\n\t\t\tc.Error(err, \"get organization or repository context\")\n\t\t\treturn\n\t\t}\n\t\tc.Map(orCtx)\n\t}\n}\n\ntype orgRepoContext struct {\n\tOrgID    int64\n\tRepoID   int64\n\tLink     string\n\tTmplList string\n\tTmplNew  string\n}\n\n// getOrgRepoContext determines whether this is a repo context or organization context.\nfunc getOrgRepoContext(c *context.Context) (*orgRepoContext, error) {\n\tif len(c.Repo.RepoLink) > 0 {\n\t\tc.PageIs(\"RepositoryContext\")\n\t\treturn &orgRepoContext{\n\t\t\tRepoID:   c.Repo.Repository.ID,\n\t\t\tLink:     c.Repo.RepoLink,\n\t\t\tTmplList: tmplRepoSettingsWebhooks,\n\t\t\tTmplNew:  tmplRepoSettingsWebhookNew,\n\t\t}, nil\n\t}\n\n\tif len(c.Org.OrgLink) > 0 {\n\t\tc.PageIs(\"OrganizationContext\")\n\t\treturn &orgRepoContext{\n\t\t\tOrgID:    c.Org.Organization.ID,\n\t\t\tLink:     c.Org.OrgLink,\n\t\t\tTmplList: tmplOrgSettingsWebhooks,\n\t\t\tTmplNew:  tmplOrgSettingsWebhookNew,\n\t\t}, nil\n\t}\n\n\treturn nil, errors.New(\"unable to determine context\")\n}\n\nfunc Webhooks(c *context.Context, orCtx *orgRepoContext) {\n\tc.Title(\"repo.settings.hooks\")\n\tc.PageIs(\"SettingsHooks\")\n\tc.Data[\"Types\"] = conf.Webhook.Types\n\n\tvar err error\n\tvar ws []*db.Webhook\n\tif orCtx.RepoID > 0 {\n\t\tc.Data[\"Description\"] = c.Tr(\"repo.settings.hooks_desc\", \"https://gogs.io/docs/features/webhook.html\")\n\t\tws, err = db.GetWebhooksByRepoID(orCtx.RepoID)\n\t} else {\n\t\tc.Data[\"Description\"] = c.Tr(\"org.settings.hooks_desc\")\n\t\tws, err = db.GetWebhooksByOrgID(orCtx.OrgID)\n\t}\n\tif err != nil {\n\t\tc.Error(err, \"get webhooks\")\n\t\treturn\n\t}\n\tc.Data[\"Webhooks\"] = ws\n\n\tc.Success(orCtx.TmplList)\n}\n\nfunc WebhooksNew(c *context.Context, orCtx *orgRepoContext) {\n\tc.Title(\"repo.settings.add_webhook\")\n\tc.PageIs(\"SettingsHooks\")\n\tc.PageIs(\"SettingsHooksNew\")\n\n\tallowed := false\n\thookType := strings.ToLower(c.Params(\":type\"))\n\tfor _, typ := range conf.Webhook.Types {\n\t\tif hookType == typ {\n\t\t\tallowed = true\n\t\t\tc.Data[\"HookType\"] = typ\n\t\t\tbreak\n\t\t}\n\t}\n\tif !allowed {\n\t\tc.NotFound()\n\t\treturn\n\t}\n\n\tc.Success(orCtx.TmplNew)\n}\n\nfunc validateWebhook(actor *db.User, l macaron.Locale, w *db.Webhook) (field, msg string, ok bool) {\n\tif !actor.IsAdmin {\n\t\t// \ud83d\udea8 SECURITY: Local addresses must not be allowed by non-admins to prevent SSRF,\n\t\t// see https://github.com/gogs/gogs/issues/5366 for details.\n\t\tpayloadURL, err := url.Parse(w.URL)\n\t\tif err != nil {\n\t\t\treturn \"PayloadURL\", l.Tr(\"repo.settings.webhook.err_cannot_parse_payload_url\", err), false\n\t\t}\n\n\t\tif netutil.IsLocalHostname(payloadURL.Hostname(), conf.Security.LocalNetworkAllowlist) {\n\t\t\treturn \"PayloadURL\", l.Tr(\"repo.settings.webhook.err_cannot_use_local_addresses\"), false\n\t\t}\n\t}\n\n\treturn \"\", \"\", true\n}\n\nfunc validateAndCreateWebhook(c *context.Context, orCtx *orgRepoContext, w *db.Webhook) {\n\tc.Data[\"Webhook\"] = w\n\n\tif c.HasError() {\n\t\tc.Success(orCtx.TmplNew)\n\t\treturn\n\t}\n\n\tfield, msg, ok := validateWebhook(c.User, c.Locale, w)\n\tif !ok {\n\t\tc.FormErr(field)\n\t\tc.RenderWithErr(msg, orCtx.TmplNew, nil)\n\t\treturn\n\t}\n\n\tif err := w.UpdateEvent(); err != nil {\n\t\tc.Error(err, \"update event\")\n\t\treturn\n\t} else if err := db.CreateWebhook(w); err != nil {\n\t\tc.Error(err, \"create webhook\")\n\t\treturn\n\t}\n\n\tc.Flash.Success(c.Tr(\"repo.settings.add_hook_success\"))\n\tc.Redirect(orCtx.Link + \"/settings/hooks\")\n}\n\nfunc toHookEvent(f form.Webhook) *db.HookEvent {\n\treturn &db.HookEvent{\n\t\tPushOnly:       f.PushOnly(),\n\t\tSendEverything: f.SendEverything(),\n\t\tChooseEvents:   f.ChooseEvents(),\n\t\tHookEvents: db.HookEvents{\n\t\t\tCreate:       f.Create,\n\t\t\tDelete:       f.Delete,\n\t\t\tFork:         f.Fork,\n\t\t\tPush:         f.Push,\n\t\t\tIssues:       f.Issues,\n\t\t\tIssueComment: f.IssueComment,\n\t\t\tPullRequest:  f.PullRequest,\n\t\t\tRelease:      f.Release,\n\t\t},\n\t}\n}\n\nfunc WebhooksNewPost(c *context.Context, orCtx *orgRepoContext, f form.NewWebhook) {\n\tc.Title(\"repo.settings.add_webhook\")\n\tc.PageIs(\"SettingsHooks\")\n\tc.PageIs(\"SettingsHooksNew\")\n\tc.Data[\"HookType\"] = \"gogs\"\n\n\tcontentType := db.JSON\n\tif db.HookContentType(f.ContentType) == db.FORM {\n\t\tcontentType = db.FORM\n\t}\n\n\tw := &db.Webhook{\n\t\tRepoID:       orCtx.RepoID,\n\t\tOrgID:        orCtx.OrgID,\n\t\tURL:          f.PayloadURL,\n\t\tContentType:  contentType,\n\t\tSecret:       f.Secret,\n\t\tHookEvent:    toHookEvent(f.Webhook),\n\t\tIsActive:     f.Active,\n\t\tHookTaskType: db.GOGS,\n\t}\n\tvalidateAndCreateWebhook(c, orCtx, w)\n}\n\nfunc WebhooksSlackNewPost(c *context.Context, orCtx *orgRepoContext, f form.NewSlackHook) {\n\tc.Title(\"repo.settings.add_webhook\")\n\tc.PageIs(\"SettingsHooks\")\n\tc.PageIs(\"SettingsHooksNew\")\n\tc.Data[\"HookType\"] = \"slack\"\n\n\tmeta := &db.SlackMeta{\n\t\tChannel:  f.Channel,\n\t\tUsername: f.Username,\n\t\tIconURL:  f.IconURL,\n\t\tColor:    f.Color,\n\t}\n\tc.Data[\"SlackMeta\"] = meta\n\n\tp, err := jsoniter.Marshal(meta)\n\tif err != nil {\n\t\tc.Error(err, \"marshal JSON\")\n\t\treturn\n\t}\n\n\tw := &db.Webhook{\n\t\tRepoID:       orCtx.RepoID,\n\t\tURL:          f.PayloadURL,\n\t\tContentType:  db.JSON,\n\t\tHookEvent:    toHookEvent(f.Webhook),\n\t\tIsActive:     f.Active,\n\t\tHookTaskType: db.SLACK,\n\t\tMeta:         string(p),\n\t\tOrgID:        orCtx.OrgID,\n\t}\n\tvalidateAndCreateWebhook(c, orCtx, w)\n}\n\nfunc WebhooksDiscordNewPost(c *context.Context, orCtx *orgRepoContext, f form.NewDiscordHook) {\n\tc.Title(\"repo.settings.add_webhook\")\n\tc.PageIs(\"SettingsHooks\")\n\tc.PageIs(\"SettingsHooksNew\")\n\tc.Data[\"HookType\"] = \"discord\"\n\n\tmeta := &db.SlackMeta{\n\t\tUsername: f.Username,\n\t\tIconURL:  f.IconURL,\n\t\tColor:    f.Color,\n\t}\n\tc.Data[\"SlackMeta\"] = meta\n\n\tp, err := jsoniter.Marshal(meta)\n\tif err != nil {\n\t\tc.Error(err, \"marshal JSON\")\n\t\treturn\n\t}\n\n\tw := &db.Webhook{\n\t\tRepoID:       orCtx.RepoID,\n\t\tURL:          f.PayloadURL,\n\t\tContentType:  db.JSON,\n\t\tHookEvent:    toHookEvent(f.Webhook),\n\t\tIsActive:     f.Active,\n\t\tHookTaskType: db.DISCORD,\n\t\tMeta:         string(p),\n\t\tOrgID:        orCtx.OrgID,\n\t}\n\tvalidateAndCreateWebhook(c, orCtx, w)\n}\n\nfunc WebhooksDingtalkNewPost(c *context.Context, orCtx *orgRepoContext, f form.NewDingtalkHook) {\n\tc.Title(\"repo.settings.add_webhook\")\n\tc.PageIs(\"SettingsHooks\")\n\tc.PageIs(\"SettingsHooksNew\")\n\tc.Data[\"HookType\"] = \"dingtalk\"\n\n\tw := &db.Webhook{\n\t\tRepoID:       orCtx.RepoID,\n\t\tURL:          f.PayloadURL,\n\t\tContentType:  db.JSON,\n\t\tHookEvent:    toHookEvent(f.Webhook),\n\t\tIsActive:     f.Active,\n\t\tHookTaskType: db.DINGTALK,\n\t\tOrgID:        orCtx.OrgID,\n\t}\n\tvalidateAndCreateWebhook(c, orCtx, w)\n}\n\nfunc loadWebhook(c *context.Context, orCtx *orgRepoContext) *db.Webhook {\n\tc.RequireHighlightJS()\n\n\tvar err error\n\tvar w *db.Webhook\n\tif orCtx.RepoID > 0 {\n\t\tw, err = db.GetWebhookOfRepoByID(c.Repo.Repository.ID, c.ParamsInt64(\":id\"))\n\t} else {\n\t\tw, err = db.GetWebhookByOrgID(c.Org.Organization.ID, c.ParamsInt64(\":id\"))\n\t}\n\tif err != nil {\n\t\tc.NotFoundOrError(err, \"get webhook\")\n\t\treturn nil\n\t}\n\tc.Data[\"Webhook\"] = w\n\n\tswitch w.HookTaskType {\n\tcase db.SLACK:\n\t\tc.Data[\"SlackMeta\"] = w.SlackMeta()\n\t\tc.Data[\"HookType\"] = \"slack\"\n\tcase db.DISCORD:\n\t\tc.Data[\"SlackMeta\"] = w.SlackMeta()\n\t\tc.Data[\"HookType\"] = \"discord\"\n\tcase db.DINGTALK:\n\t\tc.Data[\"HookType\"] = \"dingtalk\"\n\tdefault:\n\t\tc.Data[\"HookType\"] = \"gogs\"\n\t}\n\tc.Data[\"FormURL\"] = fmt.Sprintf(\"%s/settings/hooks/%s/%d\", orCtx.Link, c.Data[\"HookType\"], w.ID)\n\tc.Data[\"DeleteURL\"] = fmt.Sprintf(\"%s/settings/hooks/delete\", orCtx.Link)\n\n\tc.Data[\"History\"], err = w.History(1)\n\tif err != nil {\n\t\tc.Error(err, \"get history\")\n\t\treturn nil\n\t}\n\treturn w\n}\n\nfunc WebhooksEdit(c *context.Context, orCtx *orgRepoContext) {\n\tc.Title(\"repo.settings.update_webhook\")\n\tc.PageIs(\"SettingsHooks\")\n\tc.PageIs(\"SettingsHooksEdit\")\n\n\tloadWebhook(c, orCtx)\n\tif c.Written() {\n\t\treturn\n\t}\n\n\tc.Success(orCtx.TmplNew)\n}\n\nfunc validateAndUpdateWebhook(c *context.Context, orCtx *orgRepoContext, w *db.Webhook) {\n\tc.Data[\"Webhook\"] = w\n\n\tif c.HasError() {\n\t\tc.Success(orCtx.TmplNew)\n\t\treturn\n\t}\n\n\tfield, msg, ok := validateWebhook(c.User, c.Locale, w)\n\tif !ok {\n\t\tc.FormErr(field)\n\t\tc.RenderWithErr(msg, orCtx.TmplNew, nil)\n\t\treturn\n\t}\n\n\tif err := w.UpdateEvent(); err != nil {\n\t\tc.Error(err, \"update event\")\n\t\treturn\n\t} else if err := db.UpdateWebhook(w); err != nil {\n\t\tc.Error(err, \"update webhook\")\n\t\treturn\n\t}\n\n\tc.Flash.Success(c.Tr(\"repo.settings.update_hook_success\"))\n\tc.Redirect(fmt.Sprintf(\"%s/settings/hooks/%d\", orCtx.Link, w.ID))\n}\n\nfunc WebhooksEditPost(c *context.Context, orCtx *orgRepoContext, f form.NewWebhook) {\n\tc.Title(\"repo.settings.update_webhook\")\n\tc.PageIs(\"SettingsHooks\")\n\tc.PageIs(\"SettingsHooksEdit\")\n\n\tw := loadWebhook(c, orCtx)\n\tif c.Written() {\n\t\treturn\n\t}\n\n\tcontentType := db.JSON\n\tif db.HookContentType(f.ContentType) == db.FORM {\n\t\tcontentType = db.FORM\n\t}\n\n\tw.URL = f.PayloadURL\n\tw.ContentType = contentType\n\tw.Secret = f.Secret\n\tw.HookEvent = toHookEvent(f.Webhook)\n\tw.IsActive = f.Active\n\tvalidateAndUpdateWebhook(c, orCtx, w)\n}\n\nfunc WebhooksSlackEditPost(c *context.Context, orCtx *orgRepoContext, f form.NewSlackHook) {\n\tc.Title(\"repo.settings.update_webhook\")\n\tc.PageIs(\"SettingsHooks\")\n\tc.PageIs(\"SettingsHooksEdit\")\n\n\tw := loadWebhook(c, orCtx)\n\tif c.Written() {\n\t\treturn\n\t}\n\n\tmeta, err := jsoniter.Marshal(&db.SlackMeta{\n\t\tChannel:  f.Channel,\n\t\tUsername: f.Username,\n\t\tIconURL:  f.IconURL,\n\t\tColor:    f.Color,\n\t})\n\tif err != nil {\n\t\tc.Error(err, \"marshal JSON\")\n\t\treturn\n\t}\n\n\tw.URL = f.PayloadURL\n\tw.Meta = string(meta)\n\tw.HookEvent = toHookEvent(f.Webhook)\n\tw.IsActive = f.Active\n\tvalidateAndUpdateWebhook(c, orCtx, w)\n}\n\nfunc WebhooksDiscordEditPost(c *context.Context, orCtx *orgRepoContext, f form.NewDiscordHook) {\n\tc.Title(\"repo.settings.update_webhook\")\n\tc.PageIs(\"SettingsHooks\")\n\tc.PageIs(\"SettingsHooksEdit\")\n\n\tw := loadWebhook(c, orCtx)\n\tif c.Written() {\n\t\treturn\n\t}\n\n\tmeta, err := jsoniter.Marshal(&db.SlackMeta{\n\t\tUsername: f.Username,\n\t\tIconURL:  f.IconURL,\n\t\tColor:    f.Color,\n\t})\n\tif err != nil {\n\t\tc.Error(err, \"marshal JSON\")\n\t\treturn\n\t}\n\n\tw.URL = f.PayloadURL\n\tw.Meta = string(meta)\n\tw.HookEvent = toHookEvent(f.Webhook)\n\tw.IsActive = f.Active\n\tvalidateAndUpdateWebhook(c, orCtx, w)\n}\n\nfunc WebhooksDingtalkEditPost(c *context.Context, orCtx *orgRepoContext, f form.NewDingtalkHook) {\n\tc.Title(\"repo.settings.update_webhook\")\n\tc.PageIs(\"SettingsHooks\")\n\tc.PageIs(\"SettingsHooksEdit\")\n\n\tw := loadWebhook(c, orCtx)\n\tif c.Written() {\n\t\treturn\n\t}\n\n\tw.URL = f.PayloadURL\n\tw.HookEvent = toHookEvent(f.Webhook)\n\tw.IsActive = f.Active\n\tvalidateAndUpdateWebhook(c, orCtx, w)\n}\n\nfunc TestWebhook(c *context.Context) {\n\tvar (\n\t\tcommitID          string\n\t\tcommitMessage     string\n\t\tauthor            *git.Signature\n\t\tcommitter         *git.Signature\n\t\tauthorUsername    string\n\t\tcommitterUsername string\n\t\tnameStatus        *git.NameStatus\n\t)\n\n\t// Grab latest commit or fake one if it's empty repository.\n\n\tif c.Repo.Commit == nil {\n\t\tcommitID = git.EmptyID\n\t\tcommitMessage = \"This is a fake commit\"\n\t\tghost := db.NewGhostUser()\n\t\tauthor = ghost.NewGitSig()\n\t\tcommitter = ghost.NewGitSig()\n\t\tauthorUsername = ghost.Name\n\t\tcommitterUsername = ghost.Name\n\t\tnameStatus = &git.NameStatus{}\n\n\t} else {\n\t\tcommitID = c.Repo.Commit.ID.String()\n\t\tcommitMessage = c.Repo.Commit.Message\n\t\tauthor = c.Repo.Commit.Author\n\t\tcommitter = c.Repo.Commit.Committer\n\n\t\t// Try to match email with a real user.\n\t\tauthor, err := db.GetUserByEmail(c.Repo.Commit.Author.Email)\n\t\tif err == nil {\n\t\t\tauthorUsername = author.Name\n\t\t} else if !db.IsErrUserNotExist(err) {\n\t\t\tc.Error(err, \"get user by email\")\n\t\t\treturn\n\t\t}\n\n\t\tuser, err := db.GetUserByEmail(c.Repo.Commit.Committer.Email)\n\t\tif err == nil {\n\t\t\tcommitterUsername = user.Name\n\t\t} else if !db.IsErrUserNotExist(err) {\n\t\t\tc.Error(err, \"get user by email\")\n\t\t\treturn\n\t\t}\n\n\t\tnameStatus, err = c.Repo.Commit.ShowNameStatus()\n\t\tif err != nil {\n\t\t\tc.Error(err, \"get changed files\")\n\t\t\treturn\n\t\t}\n\t}\n\n\tapiUser := c.User.APIFormat()\n\tp := &api.PushPayload{\n\t\tRef:    git.RefsHeads + c.Repo.Repository.DefaultBranch,\n\t\tBefore: commitID,\n\t\tAfter:  commitID,\n\t\tCommits: []*api.PayloadCommit{\n\t\t\t{\n\t\t\t\tID:      commitID,\n\t\t\t\tMessage: commitMessage,\n\t\t\t\tURL:     c.Repo.Repository.HTMLURL() + \"/commit/\" + commitID,\n\t\t\t\tAuthor: &api.PayloadUser{\n\t\t\t\t\tName:     author.Name,\n\t\t\t\t\tEmail:    author.Email,\n\t\t\t\t\tUserName: authorUsername,\n\t\t\t\t},\n\t\t\t\tCommitter: &api.PayloadUser{\n\t\t\t\t\tName:     committer.Name,\n\t\t\t\t\tEmail:    committer.Email,\n\t\t\t\t\tUserName: committerUsername,\n\t\t\t\t},\n\t\t\t\tAdded:    nameStatus.Added,\n\t\t\t\tRemoved:  nameStatus.Removed,\n\t\t\t\tModified: nameStatus.Modified,\n\t\t\t},\n\t\t},\n\t\tRepo:   c.Repo.Repository.APIFormat(nil),\n\t\tPusher: apiUser,\n\t\tSender: apiUser,\n\t}\n\tif err := db.TestWebhook(c.Repo.Repository, db.HOOK_EVENT_PUSH, p, c.ParamsInt64(\"id\")); err != nil {\n\t\tc.Error(err, \"test webhook\")\n\t\treturn\n\t}\n\n\tc.Flash.Info(c.Tr(\"repo.settings.webhook.test_delivery_success\"))\n\tc.Status(http.StatusOK)\n}\n\nfunc RedeliveryWebhook(c *context.Context) {\n\twebhook, err := db.GetWebhookOfRepoByID(c.Repo.Repository.ID, c.ParamsInt64(\":id\"))\n\tif err != nil {\n\t\tc.NotFoundOrError(err, \"get webhook\")\n\t\treturn\n\t}\n\n\thookTask, err := db.GetHookTaskOfWebhookByUUID(webhook.ID, c.Query(\"uuid\"))\n\tif err != nil {\n\t\tc.NotFoundOrError(err, \"get hook task by UUID\")\n\t\treturn\n\t}\n\n\thookTask.IsDelivered = false\n\tif err = db.UpdateHookTask(hookTask); err != nil {\n\t\tc.Error(err, \"update hook task\")\n\t\treturn\n\t}\n\n\tgo db.HookQueue.Add(c.Repo.Repository.ID)\n\tc.Flash.Info(c.Tr(\"repo.settings.webhook.redelivery_success\", hookTask.UUID))\n\tc.Status(http.StatusOK)\n}\n\nfunc DeleteWebhook(c *context.Context, orCtx *orgRepoContext) {\n\tvar err error\n\tif orCtx.RepoID > 0 {\n\t\terr = db.DeleteWebhookOfRepoByID(orCtx.RepoID, c.QueryInt64(\"id\"))\n\t} else {\n\t\terr = db.DeleteWebhookOfOrgByID(orCtx.OrgID, c.QueryInt64(\"id\"))\n\t}\n\tif err != nil {\n\t\tc.Error(err, \"delete webhook\")\n\t\treturn\n\t}\n\tc.Flash.Success(c.Tr(\"repo.settings.webhook_deletion_success\"))\n\n\tc.JSONSuccess(map[string]interface{}{\n\t\t\"redirect\": orCtx.Link + \"/settings/hooks\",\n\t})\n}\n", "// Copyright 2020 The Gogs Authors. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage repo\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\n\t\"gogs.io/gogs/internal/db\"\n\t\"gogs.io/gogs/internal/mocks\"\n)\n\nfunc Test_validateWebhook(t *testing.T) {\n\tl := &mocks.Locale{\n\t\tMockLang: \"en\",\n\t\tMockTr: func(s string, _ ...interface{}) string {\n\t\t\treturn s\n\t\t},\n\t}\n\n\ttests := []struct {\n\t\tname     string\n\t\tactor    *db.User\n\t\twebhook  *db.Webhook\n\t\texpField string\n\t\texpMsg   string\n\t\texpOK    bool\n\t}{\n\t\t{\n\t\t\tname:    \"admin bypass local address check\",\n\t\t\tactor:   &db.User{IsAdmin: true},\n\t\t\twebhook: &db.Webhook{URL: \"http://localhost:3306\"},\n\t\t\texpOK:   true,\n\t\t},\n\n\t\t{\n\t\t\tname:     \"local address not allowed\",\n\t\t\tactor:    &db.User{},\n\t\t\twebhook:  &db.Webhook{URL: \"http://localhost:3306\"},\n\t\t\texpField: \"PayloadURL\",\n\t\t\texpMsg:   \"repo.settings.webhook.err_cannot_use_local_addresses\",\n\t\t\texpOK:    false,\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tfield, msg, ok := validateWebhook(test.actor, l, test.webhook)\n\t\t\tassert.Equal(t, test.expOK, ok)\n\t\t\tassert.Equal(t, test.expMsg, msg)\n\t\t\tassert.Equal(t, test.expField, field)\n\t\t})\n\t}\n}\n"], "fixing_code": ["# Changelog\n\nAll notable changes to Gogs are documented in this file.\n\n## 0.13.0+dev (`main`)\n\n### Added\n\n- An unlisted option is added when create or migrate a repository. Unlisted repositories are public but not being listed for users without direct access in the UI. [#5733](https://github.com/gogs/gogs/issues/5733)\n- New configuration option `[git.timeout] DIFF` for customizing operation timeout of `git diff`. [#6315](https://github.com/gogs/gogs/issues/6315)\n- New configuration option `[server] SSH_SERVER_MACS` for setting list of accepted MACs for connections to builtin SSH server. [#6434](https://github.com/gogs/gogs/issues/6434)\n- Support specifying custom schema for PostgreSQL. [#6695](https://github.com/gogs/gogs/pull/6695)\n- Support rendering Mermaid diagrams in Markdown. [#6776](https://github.com/gogs/gogs/pull/6776)\n- New languages support: Mongolian. [#6510](https://github.com/gogs/gogs/pull/6510)\n\n### Changed\n\n- The default branch has been changed to `main`. [#6285](https://github.com/gogs/gogs/pull/6285)\n- MSSQL as database backend is deprecated, installation page no longer shows it as an option. Existing installations and manually craft configuration file continue to work. [#6295](https://github.com/gogs/gogs/pull/6295)\n- Use [Task](https://github.com/go-task/task) as the build tool. [#6297](https://github.com/gogs/gogs/pull/6297)\n- The required Go version to compile source code changed to 1.16.\n\n### Fixed\n\n- _Security:_ SSRF in webhook. [#6901](https://github.com/gogs/gogs/issues/6901)\n- _Security:_ XSS in cookies. [#6953](https://github.com/gogs/gogs/issues/6953)\n- _Security:_ OS Command Injection in file uploading. [#6968](https://github.com/gogs/gogs/issues/6968)\n- _Security:_ Remote Command Execution in file editing. [#6555](https://github.com/gogs/gogs/issues/6555)\n- Unable to use LDAP authentication on ARM machines. [#6761](https://github.com/gogs/gogs/issues/6761)\n\n### Removed\n\n- \u26a0\ufe0f Migrations before 0.12 are removed, installations not on 0.12 should upgrade to it to run the migrations and then upgrade to 0.13.\n- Configuration section `[mailer]` is no longer used, please use `[email]`.\n- Configuration section `[service]` is no longer used, please use `[auth]`.\n- Configuration option `APP_NAME` is no longer used, please use `BRAND_NAME`.\n- Configuration option `[security] REVERSE_PROXY_AUTHENTICATION_USER` is no longer used, please use `[auth] REVERSE_PROXY_AUTHENTICATION_HEADER`.\n- Configuration option `[auth] ACTIVE_CODE_LIVE_MINUTES` is no longer used, please use `[auth] ACTIVATE_CODE_LIVES`.\n- Configuration option `[auth] RESET_PASSWD_CODE_LIVE_MINUTES` is no longer used, please use `[auth] RESET_PASSWORD_CODE_LIVES`.\n- Configuration option `[auth] ENABLE_CAPTCHA` is no longer used, please use `[auth] ENABLE_REGISTRATION_CAPTCHA`.\n- Configuration option `[auth] ENABLE_NOTIFY_MAIL` is no longer used, please use `[user] ENABLE_EMAIL_NOTIFICATION`.\n- Configuration option `[auth] REGISTER_EMAIL_CONFIRM` is no longer used, please use `[auth] REQUIRE_EMAIL_CONFIRMATION`.\n- Configuration option `[session] GC_INTERVAL_TIME` is no longer used, please use `[session] GC_INTERVAL`.\n- Configuration option `[session] SESSION_LIFE_TIME` is no longer used, please use `[session] MAX_LIFE_TIME`.\n- Configuration option `[server] ROOT_URL` is no longer used, please use `[server] EXTERNAL_URL`.\n- Configuration option `[server] LANDING_PAGE` is no longer used, please use `[server] LANDING_URL`.\n- Configuration option `[database] DB_TYPE` is no longer used, please use `[database] TYPE`.\n- Configuration option `[database] PASSWD` is no longer used, please use `[database] PASSWORD`.\n- Remove option to use Makefile as the build tool. [#6980](https://github.com/gogs/gogs/pull/6980)\n\n## 0.12.7\n\n### Fixed\n\n- _Security:_ Stored XSS in issues. [#6919](https://github.com/gogs/gogs/issues/6919)\n- Invalid character in `Access-Control-Allow-Credentials` response header. [#4983](https://github.com/gogs/gogs/issues/4983)\n- Mysterious `ssh: overflow reading version string` errors from builtin SSH server. [#6882](https://github.com/gogs/gogs/issues/6882)\n\n## 0.12.6\n\n### Fixed\n\n- _Security:_ Remote command execution in file uploading. [#6833](https://github.com/gogs/gogs/issues/6833)\n- _Regression:_ Unable to migrate repository from other local Git hosting. Added a new configuration option `[security] LOCAL_NETWORK_ALLOWLIST`, which is a comma separated list of hostnames that are explicitly allowed to be accessed within the local network. [#6841](https://github.com/gogs/gogs/issues/6841)\n- Slow start of Docker containers using NAS devices. [#6554](https://github.com/gogs/gogs/issues/6554)\n\n## 0.12.5\n\n### Fixed\n\n- _Security:_ Potential SSRF in repository migration. [#6754](https://github.com/gogs/gogs/issues/6754)\n- _Security:_ Improper PAM authorization handling. [#6810](https://github.com/gogs/gogs/issues/6810)\n\n## 0.12.4\n\n### Fixed\n\n- _Security:_ Potential SSRF attack by CRLF injection via repository migration. [#6413](https://github.com/gogs/gogs/issues/6413)\n- _Regression:_ Fixed smart links for issues stops rendering. [#6506](https://github.com/gogs/gogs/issues/6506)\n- Added `X-Frame-Options` header to prevent Clickjacking. [#6409](https://github.com/gogs/gogs/issues/6409)\n\n## 0.12.3\n\n### Fixed\n\n- _Regression:_ When running Gogs on Windows, push commits no longer fail on a daily basis with the error \"pre-receive hook declined\". [#6316](https://github.com/gogs/gogs/issues/6316)\n- Auto-linked commit SHAs now have correct links. [#6300](https://github.com/gogs/gogs/issues/6300)\n- Git LFS client (with version >= 2.5.0) wasn't able to upload files with known format (e.g. PNG, JPEG), and the server is expecting the HTTP Header `Content-Type` to be `application/octet-stream`. The server now tells the LFS client to always use `Content-Type: application/octet-stream` when upload files.\n\n## 0.12.2\n\n### Fixed\n\n- _Regression:_ Pages are correctly rendered when requesting `?go-get=1` for subdirectories. [#6314](https://github.com/gogs/gogs/issues/6314)\n- _Regression:_ Submodule with a relative path is linked correctly. [#6319](https://github.com/gogs/gogs/issues/6319)\n- Backup can be processed when `--target` is specified on Windows. [#6339](https://github.com/gogs/gogs/issues/6339)\n- Commit message contains keywords look like an issue reference no longer fails the push entirely. [#6289](https://github.com/gogs/gogs/issues/6289)\n\n## 0.12.1\n\n### Fixed\n\n- The `updated_at` field is now correctly updated when updates an issue. [#6209](https://github.com/gogs/gogs/issues/6209)\n- Fixed a regression which created `login_source.cfg` column to have `VARCHAR(255)` instead of `TEXT` in MySQL. [#6280](https://github.com/gogs/gogs/issues/6280)\n\n## 0.12.0\n\n### Added\n\n- Support for Git LFS, you can read documentation for both [user](https://github.com/gogs/gogs/blob/main/docs/user/lfs.md) and [admin](https://github.com/gogs/gogs/blob/main/docs/admin/lfs.md). [#1322](https://github.com/gogs/gogs/issues/1322)\n- Allow admin to remove observers from the repository. [#5803](https://github.com/gogs/gogs/pull/5803)\n- Use `Last-Modified` HTTP header for raw files. [#5811](https://github.com/gogs/gogs/issues/5811)\n- Support syntax highlighting for SAS code files (i.e. `.r`, `.sas`, `.tex`, `.yaml`). [#5856](https://github.com/gogs/gogs/pull/5856)\n- Able to fill in pull request title with a template. [#5901](https://github.com/gogs/gogs/pull/5901)\n- Able to override static files under `public/` directory, please refer to [documentation](https://gogs.io/docs/features/custom_template) for usage. [#5920](https://github.com/gogs/gogs/pull/5920)\n- New API endpoint `GET /admin/teams/:teamid/members` to list members of a team. [#5877](https://github.com/gogs/gogs/issues/5877)\n- Support backup with retention policy for Docker deployments. [#6140](https://github.com/gogs/gogs/pull/6140)\n\n### Changed\n\n- The organization profile page has changed to display at most 12 members. [#5506](https://github.com/gogs/gogs/issues/5506)\n- The required Go version to compile source code changed to 1.14.\n- All assets are now embedded into binary and served from memory by default. Set `[server] LOAD_ASSETS_FROM_DISK = true` to load them from disk. [#5920](https://github.com/gogs/gogs/pull/5920)\n- Application and Go versions are removed from page footer and only show in the admin dashboard.\n- Build tag for running as Windows Service has been changed from `miniwinsvc` to `minwinsvc`.\n- Configuration option `APP_NAME` is deprecated and will end support in 0.13.0, please start using `BRAND_NAME`.\n- Configuration option `[server] ROOT_URL` is deprecated and will end support in 0.13.0, please start using `[server] EXTERNAL_URL`.\n- Configuration option `[server] LANDING_PAGE` is deprecated and will end support in 0.13.0, please start using `[server] LANDING_URL`.\n- Configuration option `[database] DB_TYPE` is deprecated and will end support in 0.13.0, please start using `[database] TYPE`.\n- Configuration option `[database] PASSWD` is deprecated and will end support in 0.13.0, please start using `[database] PASSWORD`.\n- Configuration option `[security] REVERSE_PROXY_AUTHENTICATION_USER` is deprecated and will end support in 0.13.0, please start using `[auth] REVERSE_PROXY_AUTHENTICATION_HEADER`.\n- Configuration section `[mailer]` is deprecated and will end support in 0.13.0, please start using `[email]`.\n- Configuration section `[service]` is deprecated and will end support in 0.13.0, please start using `[auth]`.\n- Configuration option `[auth] ACTIVE_CODE_LIVE_MINUTES` is deprecated and will end support in 0.13.0, please start using `[auth] ACTIVATE_CODE_LIVES`.\n- Configuration option `[auth] RESET_PASSWD_CODE_LIVE_MINUTES` is deprecated and will end support in 0.13.0, please start using `[auth] RESET_PASSWORD_CODE_LIVES`.\n- Configuration option `[auth] REGISTER_EMAIL_CONFIRM` is deprecated and will end support in 0.13.0, please start using `[auth] REQUIRE_EMAIL_CONFIRMATION`.\n- Configuration option `[auth] ENABLE_CAPTCHA` is deprecated and will end support in 0.13.0, please start using `[auth] ENABLE_REGISTRATION_CAPTCHA`.\n- Configuration option `[auth] ENABLE_NOTIFY_MAIL` is deprecated and will end support in 0.13.0, please start using `[user] ENABLE_EMAIL_NOTIFICATION`.\n- Configuration option `[session] GC_INTERVAL_TIME` is deprecated and will end support in 0.13.0, please start using `[session] GC_INTERVAL`.\n- Configuration option `[session] SESSION_LIFE_TIME` is deprecated and will end support in 0.13.0, please start using `[session] MAX_LIFE_TIME`.\n- The name `-` is reserved and cannot be used for users or organizations.\n\n### Fixed\n\n- [Security] Potential open redirection with i18n.\n- [Security] Potential ability to delete files outside a repository.\n- [Security] Potential ability to set primary email on others' behalf from their verified emails.\n- [Security] Potential XSS attack via `.ipynb`. [#5170](https://github.com/gogs/gogs/issues/5170)\n- [Security] Potential SSRF attack via webhooks. [#5366](https://github.com/gogs/gogs/issues/5366)\n- [Security] Potential CSRF attack in admin panel. [#5367](https://github.com/gogs/gogs/issues/5367)\n- [Security] Potential stored XSS attack in some browsers. [#5397](https://github.com/gogs/gogs/issues/5397)\n- [Security] Potential RCE on mirror repositories. [#5767](https://github.com/gogs/gogs/issues/5767)\n- [Security] Potential XSS attack with raw markdown API. [#5907](https://github.com/gogs/gogs/pull/5907)\n- File both modified and renamed within a commit treated as separate files. [#5056](https://github.com/gogs/gogs/issues/5056)\n- Unable to restore the database backup to MySQL 8.0 with syntax error. [#5602](https://github.com/gogs/gogs/issues/5602)\n- Open/close milestone redirects to a 404 page. [#5677](https://github.com/gogs/gogs/issues/5677)\n- Disallow multiple tokens with same name. [#5587](https://github.com/gogs/gogs/issues/5587) [#5820](https://github.com/gogs/gogs/pull/5820)\n- Enable Federated Avatar Lookup could cause server to crash. [#5848](https://github.com/gogs/gogs/issues/5848)\n- Private repositories are hidden in the organization's view. [#5869](https://github.com/gogs/gogs/issues/5869)\n- Users have access to base repository cannot view commits in forks. [#5878](https://github.com/gogs/gogs/issues/5878)\n- Server error when changing email address in user settings page. [#5899](https://github.com/gogs/gogs/issues/5899)\n- Fall back to use RFC 3339 as time layout when misconfigured. [#6098](https://github.com/gogs/gogs/issues/6098)\n- Unable to update team with server error. [#6185](https://github.com/gogs/gogs/issues/6185)\n- Webhooks are not fired after push when `[service] REQUIRE_SIGNIN_VIEW = true`.\n- Files with identical content are randomly displayed one of them.\n\n### Removed\n\n- Configuration option `[other] SHOW_FOOTER_VERSION`\n- Configuration option `[server] STATIC_ROOT_PATH`\n- Configuration option `[repository] MIRROR_QUEUE_LENGTH`\n- Configuration option `[repository] PULL_REQUEST_QUEUE_LENGTH`\n- Configuration option `[session] ENABLE_SET_COOKIE`\n- Configuration option `[release.attachment] PATH`\n- Configuration option `[webhook] QUEUE_LENGTH`\n- Build tag `sqlite`, which means CGO is now required.\n\n---\n\n**Older change logs can be found on [GitHub](https://github.com/gogs/gogs/releases?after=v0.12.0).**\n", "app_desc = A painless self-hosted Git service\n\nhome = Home\ndashboard = Dashboard\nexplore = Explore\nhelp = Help\nsign_in = Sign In\nsign_out = Sign Out\nsign_up = Sign Up\nregister = Register\nwebsite = Website\npage = Page\ntemplate = Template\nlanguage = Language\ncreate_new = Create...\nuser_profile_and_more = User profile and more\nsigned_in_as = Signed in as\n\nusername = Username\nemail = Email\npassword = Password\nre_type = Re-Type\ncaptcha = Captcha\n\nrepository = Repository\norganization = Organization\nmirror = Mirror\nnew_repo = New Repository\nnew_migrate = New Migration\nnew_mirror = New Mirror\nnew_fork = New Fork Repository\nnew_org = New Organization\nmanage_org = Manage Organizations\nadmin_panel = Admin Panel\naccount_settings = Account Settings\nsettings = Settings\nyour_profile = Your Profile\nyour_settings = Your Settings\n\nactivities = Activities\npull_requests = Pull Requests\nissues = Issues\n\ncancel = Cancel\n\n[status]\npage_not_found = Page Not Found\ninternal_server_error = Internal Server Error\n\n[install]\ninstall = Installation\ntitle = Install Steps For First-time Run\ndocker_helper = If you're running Gogs inside Docker, please read <a target=\"_blank\" href=\"%s\">Guidelines</a> carefully before you change anything in this page!\nrequite_db_desc = Gogs requires MySQL, PostgreSQL, SQLite3 or TiDB (via MySQL protocol).\ndb_title = Database Settings\ndb_type = Database Type\nhost = Host\nuser = User\npassword = Password\ndb_name = Database Name\ndb_schema = Schema\ndb_helper = Please use INNODB engine with utf8_general_ci charset for MySQL.\nssl_mode = SSL Mode\npath = Path\nsqlite_helper = The file path of SQLite3 database. <br>Please use absolute path when you start as service.\nerr_empty_db_path = SQLite3 database path cannot be empty.\nno_admin_and_disable_registration = You cannot disable registration without creating an admin account.\nerr_empty_admin_password = Admin password cannot be empty.\n\ngeneral_title = Application General Settings\napp_name = Application Name\napp_name_helper = Put your organization name here huge and loud!\nrepo_path = Repository Root Path\nrepo_path_helper = All Git remote repositories will be saved to this directory.\nrun_user = Run User\nrun_user_helper = The user must have access to Repository Root Path and run Gogs.\ndomain = Domain\ndomain_helper = This affects SSH clone URLs.\nssh_port = SSH Port\nssh_port_helper = Port number which your SSH server is using, leave it empty to disable SSH feature.\nuse_builtin_ssh_server = Use Builtin SSH Server\nuse_builtin_ssh_server_popup = Start builtin SSH server for Git operations to distinguish from system SSH daemon.\nhttp_port = HTTP Port\nhttp_port_helper = Port number which application will listen on.\napp_url = Application URL\napp_url_helper = This affects HTTP/HTTPS clone URL and somewhere in email.\nlog_root_path = Log Path\nlog_root_path_helper = Directory to write log files to.\nenable_console_mode = Enable Console Mode\nenable_console_mode_popup = In addition to file mode, also print logs to console.\n\noptional_title = Optional Settings\nemail_title = Email Service Settings\nsmtp_host = SMTP Host\nsmtp_from = From\nsmtp_from_helper = Mail from address, RFC 5322. It can be just an email address, or the \"Name\" <email@example.com> format.\nmailer_user = Sender Email\nmailer_password = Sender Password\nregister_confirm = Enable Register Confirmation\nmail_notify = Enable Mail Notification\nserver_service_title = Server and Other Services Settings\noffline_mode = Enable Offline Mode\noffline_mode_popup = Disable CDN even in production mode, all resource files will be served locally.\ndisable_gravatar = Disable Gravatar Service\ndisable_gravatar_popup = Disable Gravatar and custom sources, all avatars are uploaded by users or default.\nfederated_avatar_lookup = Enable Federated Avatars Lookup\nfederated_avatar_lookup_popup = Enable federated avatars lookup to use federated open source service based on libravatar.\ndisable_registration = Disable Self-registration\ndisable_registration_popup = Disable user self-registration, only admin can create accounts.\nenable_captcha = Enable Captcha\nenable_captcha_popup = Require validate captcha for user self-registration.\nrequire_sign_in_view = Enable Require Sign In to View Pages\nrequire_sign_in_view_popup = Only signed in users can view pages, visitors will only be able to see sign in/up pages.\nadmin_setting_desc = You don't need to create an admin account right now. The first user in the users table will be automatically granted admin access.\nadmin_title = Admin Account Settings\nadmin_name = Username\nadmin_password = Password\nconfirm_password = Confirm Password\nadmin_email = Admin Email\ninstall_gogs = Install Gogs\ntest_git_failed = Failed to test 'git' command: %v\nsqlite3_not_available = Your release version does not support SQLite3, please download the official binary version from %s, NOT the gobuild version.\ninvalid_db_setting = Database setting is not correct: %v\ninvalid_repo_path = Repository root path is invalid: %v\nrun_user_not_match = Run user isn't the current user: %s -> %s\nsmtp_host_missing_port = SMTP Host port missing from address.\ninvalid_smtp_from = SMTP From field is invalid: %v\nsave_config_failed = Failed to save configuration: %v\ninit_failed = Failed to initialize application: %v\ninvalid_admin_setting = Admin account setting is invalid: %v\ninstall_success = Welcome! We're glad that you chose Gogs, have fun and take care.\ninvalid_log_root_path = Log root path is invalid: %v\n\n[home]\nuname_holder = Username or email\npassword_holder = Password\nswitch_dashboard_context = Switch Dashboard Context\nmy_repos = My Repositories\nshow_more_repos = Show more repositories...\ncollaborative_repos = Collaborative Repositories\nmy_orgs = My Organizations\nmy_mirrors = My Mirrors\nview_home = View %s\n\nissues.in_your_repos = In your repositories\n\n[explore]\nrepos = Repositories\nusers = Users\norganizations = Organizations\nsearch = Search\n\n[auth]\ncreate_new_account = Create New Account\nregister_hepler_msg = Already have an account? Sign in now!\nsocial_register_hepler_msg = Already have an account? Bind now!\ndisable_register_prompt = Sorry, registration has been disabled. Please contact the site administrator.\ndisable_register_mail = Sorry, email services are disabled. Please contact the site administrator.\nauth_source = Authentication Source\nlocal = Local\nremember_me = Remember Me\nforgot_password= Forgot Password\nforget_password = Forgot password?\nsign_up_now = Need an account? Sign up now.\nconfirmation_mail_sent_prompt = A new confirmation email has been sent to <b>%s</b>, please check your inbox within the next %d hours to complete the registration process.\nactive_your_account = Activate Your Account\nprohibit_login = Login Prohibited\nprohibit_login_desc = Your account is prohibited from logging in. Please contact the site admin.\nresent_limit_prompt = Sorry, you already requested an activation email recently. Please wait 3 minutes then try again.\nhas_unconfirmed_mail = Hi %s, you have an unconfirmed email address (<b>%s</b>). If you haven't received a confirmation email or need to receive a new one, please click the button below.\nresend_mail = Click here to resend your activation email\nsend_reset_mail = Click here to (re)send your password reset email\nreset_password = Reset Your Password\ninvalid_code = Sorry, your confirmation code has expired or not valid.\nreset_password_helper = Click here to reset your password\npassword_too_short = Password length must be at least 6 characters.\nnon_local_account = Non-local accounts cannot change passwords through Gogs.\n\nlogin_two_factor = Two-factor Authentication\nlogin_two_factor_passcode = Authentication Passcode\nlogin_two_factor_enter_recovery_code = Enter a two-factor recovery code\nlogin_two_factor_recovery = Two-factor Recovery\nlogin_two_factor_recovery_code = Recovery Code\nlogin_two_factor_enter_passcode = Enter a two-factor passcode\nlogin_two_factor_invalid_recovery_code = Recovery code already used or invalid.\n\n[mail]\nactivate_account = Please activate your account\nactivate_email = Verify your email address\nreset_password = Reset your password\nregister_success = Registration successful, welcome\nregister_notify = Welcome on board\n\n[modal]\nyes = Yes\nno = No\nmodify = Modify\n\n[form]\nUserName = Username\nRepoName = Repository name\nEmail = Email address\nPassword = Password\nRetype = Re-type password\nSSHTitle = SSH key name\nHttpsUrl = HTTPS URL\nPayloadUrl = Payload URL\nTeamName = Team name\nAuthName = Authorization name\nAdminEmail = Admin email\n\nNewBranchName = New branch name\nCommitSummary = Commit summary\nCommitMessage = Commit message\nCommitChoice = Commit choice\nTreeName = File path\nContent = Content\n\nrequire_error = ` cannot be empty.`\nalpha_dash_error = ` must be alphanumeric or dash(-_) characters.`\nalpha_dash_dot_error = ` must be alphanumeric or dash(-_) or dot characters.`\nalpha_dash_dot_slash_error = ` must be alphanumeric, dash (-_), dot or slash characters.`\nsize_error  = ` size must be %s.`\nmin_size_error = ` must contain at least %s characters.`\nmax_size_error = ` must contain at most %s characters.`\nemail_error = ` is not a valid email address.`\nurl_error = ` is not a valid URL.`\ninclude_error = ` must contain substring '%s'.`\nunknown_error = Unknown error:\ncaptcha_incorrect = Captcha didn't match.\npassword_not_match = Password and confirm password are not same.\n\nusername_been_taken = Username has already been taken.\nrepo_name_been_taken = Repository name has already been taken.\norg_name_been_taken = Organization name has already been taken.\nteam_name_been_taken = Team name has already been taken.\nemail_been_used = Email address has already been used.\nusername_password_incorrect = Username or password is not correct.\nauth_source_mismatch = The authentication source selected is not associated with the user.\nenterred_invalid_repo_name = Please make sure that the repository name you entered is correct.\nenterred_invalid_owner_name = Please make sure that the owner name you entered is correct.\nenterred_invalid_password = Please make sure the that password you entered is correct.\nuser_not_exist = Given user does not exist.\nlast_org_owner = Removing the last remaining user from an owner team is not allowed, as an organization must always have at least one owner.\n\ninvalid_ssh_key = Sorry, verification of your SSH key failed: %s\nunable_verify_ssh_key = Gogs cannot verify your SSH key, but it's assumed to be valid. Please double-check it.\nauth_failed = Authentication failed: %v\n\nstill_own_repo = Your account still has ownership over at least one repository, you have to delete or transfer them first.\nstill_has_org = Your account still has membership in at least one organization, you have to leave or delete your memberships first.\norg_still_own_repo = This organization still has ownership of repositories, you must delete or transfer them first.\n\ntarget_branch_not_exist = Target branch does not exist.\n\n[user]\nchange_avatar = Change your avatar\njoin_on = Joined on\nrepositories = Repositories\nactivity = Public Activity\nfollowers = Followers\nstarred = Starred repositories\nfollowing = Following\nfollow = Follow\nunfollow = Unfollow\n\nform.name_not_allowed = User name or pattern %q is not allowed.\n\n[settings]\nprofile = Profile\npassword = Password\navatar = Avatar\nssh_keys = SSH Keys\nsecurity = Security\nrepos = Repositories\norgs = Organizations\napplications = Applications\ndelete = Delete Account\n\npublic_profile = Public Profile\nprofile_desc = Your email address is public and will be used for any account related notifications, and any web based operations made via the site.\npassword_username_disabled = Non-local type users are not allowed to change their username.\nfull_name = Full Name\nwebsite = Website\nlocation = Location\nupdate_profile = Update Profile\nupdate_profile_success = Your profile has been updated successfully.\nchange_username = Username Changed\nchange_username_prompt = This change will affect the way how links relate to your account.\ncontinue = Continue\ncancel = Cancel\n\nlookup_avatar_by_mail = Lookup Avatar by mail\nfederated_avatar_lookup = Federated Avatar Lookup\nenable_custom_avatar = Use Custom Avatar\nchoose_new_avatar = Choose new avatar\nupdate_avatar = Update Avatar Setting\ndelete_current_avatar = Delete Current Avatar\nuploaded_avatar_not_a_image = Uploaded file is not a image.\nupdate_avatar_success = Your avatar setting has been updated successfully.\n\nchange_password = Change Password\nold_password = Current Password\nnew_password = New Password\nretype_new_password = Retype New Password\npassword_incorrect = Current password is not correct.\nchange_password_success = Your password was successfully changed and can now be used for logging in.\npassword_change_disabled = Non-local type users are not allowed to change their password.\n\nemails = Email Addresses\nmanage_emails = Manage email addresses\nemail_desc = Your primary email address will be used for notifications and other operations.\nprimary = Primary\nprimary_email = Set as primary\ndelete_email = Delete\nemail_deletion = Email Deletion\nemail_deletion_desc = Deleting this email address will remove related information from your account. Do you want to continue?\nemail_deletion_success = Email has been deleted successfully!\nadd_new_email = Add new email address\nadd_email = Add Email\nadd_email_confirmation_sent = A new confirmation email has been sent to '%s', please check your inbox within the next %d hours to complete the confirmation process.\nadd_email_success = Your new email address was successfully added.\n\nmanage_ssh_keys = Manage SSH Keys\nadd_key = Add Key\nssh_desc = This is a list of SSH keys associated with your account. As these keys allow anyone using them to gain access to your repositories, it is highly important that you make sure you recognize them.\nssh_helper = <strong>Don't know how?</strong> Check out GitHub's guide to <a href=\"%s\">create your own SSH keys</a> or solve <a href=\"%s\">common problems</a> you might encounter using SSH.\nadd_new_key = Add SSH Key\nssh_key_been_used = Public key content has been used.\nssh_key_name_used = Public key with same name has already existed.\nkey_name = Key Name\nkey_content = Content\nadd_key_success = New SSH key '%s' has been added successfully!\ndelete_key = Delete\nssh_key_deletion = SSH Key Deletion\nssh_key_deletion_desc = Delete this SSH key will remove all related accesses for your account. Do you want to continue?\nssh_key_deletion_success = SSH key has been deleted successfully!\nadd_on = Added on\nlast_used = Last used on\nno_activity = No recent activity\nkey_state_desc = This key is used in last 7 days\ntoken_state_desc = This token is used in last 7 days\n\ntwo_factor = Two-factor Authentication\ntwo_factor_status = Status:\ntwo_factor_on = On\ntwo_factor_off = Off\ntwo_factor_enable = Enable\ntwo_factor_disable = Disable\ntwo_factor_view_recovery_codes = View and save <a href=\"%s%s\">your recovery codes</a> in a safe place. You can use them as passcode if you lose access to your authentication application.\ntwo_factor_http = For HTTP/HTTPS operations, you are no longer able to use plain username and password. Please create and use <a href=\"%[1]s%[2]s\">Personal Access Token</a> as your credential, e.g. <code>%[3]s</code>.\ntwo_factor_enable_title = Enable Two-factor Authentication\ntwo_factor_scan_qr = Please use your authentication application to scan the image:\ntwo_factor_or_enter_secret = Or enter the secret:\ntwo_factor_then_enter_passcode = Then enter passcode:\ntwo_factor_verify = Verify\ntwo_factor_invalid_passcode = The passcode you entered is not valid, please try again!\ntwo_factor_reused_passcode = The passcode you entered has already been used, please try another one!\ntwo_factor_enable_error = Enable Two-factor authentication failed: %v\ntwo_factor_enable_success = Two-factor authentication has enabled for your account successfully!\ntwo_factor_recovery_codes_title = Two-factor Authentication Recovery Codes\ntwo_factor_recovery_codes_desc = Recovery codes are used when you temporarily lose access to your authentication application. Each recovery code can only be used once, <b>please keep these codes in a safe place</b>.\ntwo_factor_regenerate_recovery_codes = Regenerate Recovery Codes\ntwo_factor_regenerate_recovery_codes_error = Regenerate recovery codes failed: %v\ntwo_factor_regenerate_recovery_codes_success = New recovery codes has been generated successfully!\ntwo_factor_disable_title = Disable Two-factor Authentication\ntwo_factor_disable_desc = Your account security level will decrease after disabled two-factor authentication. Do you want to continue?\ntwo_factor_disable_success = Two-factor authentication has disabled successfully!\n\nmanage_access_token = Manage Personal Access Tokens\ngenerate_new_token = Generate New Token\ntokens_desc = Tokens you have generated that can be used to access the Gogs APIs.\nnew_token_desc = Each token will have full access to your account.\ntoken_name = Token Name\ngenerate_token = Generate Token\ngenerate_token_succees = Your access token was successfully generated! Make sure to copy it right now, as you won't be able to see it again later!\ndelete_token = Delete\naccess_token_deletion = Personal Access Token Deletion\naccess_token_deletion_desc = Delete this personal access token will remove all related accesses of application. Do you want to continue?\ndelete_token_success = Personal access token has been removed successfully! Don't forget to update your application as well.\ntoken_name_exists = Token with same name already exists.\n\norgs.none = You are not a member of any organizations.\norgs.leave_title = Leave organization\norgs.leave_desc = You will lose access to all repositories and teams after you left the organization. Do you want to continue?\n\nrepos.leave = Leave\nrepos.leave_title = Leave repository\nrepos.leave_desc = You will lose access to the repository after you left. Do you want to continue?\nrepos.leave_success = You have left repository '%s' successfully!\n\ndelete_account = Delete Your Account\ndelete_prompt = The operation will delete your account permanently, and <strong>CANNOT</strong> be undone!\nconfirm_delete_account = Confirm Deletion\ndelete_account_title = Account Deletion\ndelete_account_desc = This account is going to be deleted permanently, do you want to continue?\n\n[repo]\nowner = Owner\nrepo_name = Repository Name\nrepo_name_helper = A good repository name is usually composed of short, memorable and unique keywords.\nvisibility = Visibility\nunlisted = Unlisted\nvisiblity_helper = This repository is <span class=\"ui red text\">Private</span>\nunlisted_helper = This repository is <span class=\"ui red text\">Unlisted</span>\nvisiblity_helper_forced = Site admin has forced all new repositories to be <span class=\"ui red text\">Private</span>\nvisiblity_fork_helper = (Change of this value will affect all forks)\nclone_helper = Need help cloning? Visit <a target=\"_blank\" href=\"%s\">Help</a>!\nfork_repo = Fork Repository\nfork_from = Fork From\nfork_visiblity_helper = You cannot alter the visibility of a forked repository.\nrepo_desc = Description\nrepo_lang = Language\nrepo_gitignore_helper = Select .gitignore templates\nlicense = License\nlicense_helper = Select a license file\nreadme = Readme\nreadme_helper = Select a readme template\nauto_init = Initialize this repository with selected files and template\ncreate_repo = Create Repository\ndefault_branch = Default Branch\nmirror_prune = Prune\nmirror_prune_desc = Remove any remote-tracking references that no longer exist on the remote\nmirror_interval = Mirror Interval (hour)\nmirror_address = Mirror Address\nmirror_address_desc = Please include necessary user credentials in the address.\nmirror_last_synced = Last Synced\nwatchers = Watchers\nstargazers = Stargazers\nforks = Forks\nrepo_description_helper = Description of repository. Maximum 512 characters length.\nrepo_description_length = Available characters\n\nform.reach_limit_of_creation = The owner has reached maximum creation limit of %d repositories.\nform.name_not_allowed = Repository name or pattern %q is not allowed.\n\nneed_auth = Need Authorization\nmigrate_type = Migration Type\nmigrate_type_helper = This repository will be a <span class=\"text blue\">mirror</span>\nmigrate_repo = Migrate Repository\nmigrate.clone_address = Clone Address\nmigrate.clone_address_desc = This can be a HTTP/HTTPS/GIT URL.\nmigrate.clone_address_desc_import_local = You're also allowed to migrate a repository by local server path.\nmigrate.permission_denied = You are not allowed to import local repositories.\nmigrate.invalid_local_path = Invalid local path, it does not exist or not a directory.\nmigrate.clone_address_resolved_to_blocked_local_address = Clone address resolved to a local network address that is implicitly blocked.\nmigrate.failed = Migration failed: %v\n\nmirror_from = mirror of\nforked_from = forked from\ncopy_link = Copy\ncopy_link_success = Copied!\ncopy_link_error = Press \u2318-C or Ctrl-C to copy\ncopied = Copied OK\nunwatch = Unwatch\nwatch = Watch\nunstar = Unstar\nstar = Star\nfork = Fork\n\nno_desc = No Description\nquick_guide = Quick Guide\nclone_this_repo = Clone this repository\ncreate_new_repo_command = Create a new repository on the command line\npush_exist_repo = Push an existing repository from the command line\nbare_message = This repository does not have any content yet.\n\nfiles = Files\nbranch = Branch\ntree = Tree\nfilter_branch_and_tag = Filter branch or tag\nbranches = Branches\ntags = Tags\nissues = Issues\npulls = Pull Requests\nlabels = Labels\nmilestones = Milestones\ncommits = Commits\ngit_branches = Branches\nreleases = Releases\nfile_raw = Raw\nfile_history = History\nfile_view_raw = View Raw\nfile_permalink = Permalink\nfile_too_large = This file is too large to be shown\nvideo_not_supported_in_browser = Your browser doesn't support HTML5 video tag.\n\nbranches.overview = Overview\nbranches.active_branches = Active Branches\nbranches.stale_branches = Stale Branches\nbranches.all = All Branches\nbranches.updated_by = Updated %[1]s by %[2]s\nbranches.change_default_branch = Change Default Branch\n\neditor.new_file = New file\neditor.upload_file = Upload file\neditor.edit_file = Edit file\neditor.preview_changes = Preview Changes\neditor.cannot_edit_non_text_files = Cannot edit non-text files\neditor.edit_this_file = Edit this file\neditor.must_be_on_a_branch = You must be on a branch to make or propose changes to this file\neditor.fork_before_edit = You must fork this repository before editing the file\neditor.delete_this_file = Delete this file\neditor.must_have_write_access = You must have write access to make or propose changes to this file\neditor.file_delete_success = File '%s' has been deleted successfully!\neditor.name_your_file = Name your file...\neditor.filename_help = To add directory, just type it and press /. To remove a directory, go to the beginning of the field and press backspace.\neditor.or = or\neditor.cancel_lower = cancel\neditor.commit_changes = Commit Changes\neditor.add_tmpl = Add '%s/<filename>'\neditor.add = Add '%s'\neditor.update = Update '%s'\neditor.delete = Delete '%s'\neditor.commit_message_desc = Add an optional extended description...\neditor.commit_directly_to_this_branch = Commit directly to the <strong class=\"branch-name\">%s</strong> branch.\neditor.create_new_branch = Create a <strong>new branch</strong> for this commit and start a pull request.\neditor.new_branch_name_desc = New branch name...\neditor.cancel = Cancel\neditor.filename_cannot_be_empty = Filename cannot be empty.\neditor.branch_already_exists = Branch '%s' already exists in this repository.\neditor.directory_is_a_file = Entry '%s' in the parent path is a file not a directory in this repository.\neditor.file_is_a_symlink = The file '%s' is a symlink that cannot be modified from the web editor.\neditor.filename_is_a_directory = The filename '%s' is an existing directory in this repository.\neditor.file_editing_no_longer_exists = The file '%s' you are editing no longer exists in the repository.\neditor.file_changed_while_editing = File content has been changed since you started editing. <a target=\"_blank\" href=\"%s\">Click here</a> to see what have been changed or <strong>press commit again</strong> to overwrite those changes.\neditor.file_already_exists = A file with name '%s' already exists in this repository.\neditor.no_changes_to_show = There are no changes to show.\neditor.fail_to_update_file = Failed to update/create file '%s' with error: %v\neditor.fail_to_delete_file = Failed to delete file '%s' with error: %v\neditor.add_subdir = Add subdirectory...\neditor.unable_to_upload_files = Failed to upload files to '%s' with error: %v\neditor.upload_files_to_dir = Upload files to '%s'\n\ncommits.commit_history = Commit History\ncommits.commits = Commits\ncommits.search = Search commits\ncommits.find = Find\ncommits.author = Author\ncommits.message = Message\ncommits.date = Date\ncommits.older = Older\ncommits.newer = Newer\n\nissues.new = New Issue\nissues.new.labels = Labels\nissues.new.no_label = No Label\nissues.new.clear_labels = Clear labels\nissues.new.milestone = Milestone\nissues.new.no_milestone = No Milestone\nissues.new.clear_milestone = Clear milestone\nissues.new.open_milestone = Open Milestones\nissues.new.closed_milestone = Closed Milestones\nissues.new.assignee = Assignee\nissues.new.clear_assignee = Clear assignee\nissues.new.no_assignee = No assignee\nissues.create = Create Issue\nissues.new_label = New Label\nissues.new_label_placeholder = Label name...\nissues.create_label = Create Label\nissues.label_templates.title = Load a predefined set of labels\nissues.label_templates.info = There aren't any labels yet. You can click on the \"New Label\" button above to create one or use a predefined set below.\nissues.label_templates.helper = Select a label set\nissues.label_templates.use = Use this label set\nissues.label_templates.fail_to_load_file = Failed to load label template file '%s': %v\nissues.open_tab = %d Open\nissues.close_tab = %d Closed\nissues.filter_label = Label\nissues.filter_label_no_select = No selected label\nissues.filter_milestone = Milestone\nissues.filter_milestone_no_select = No selected milestone\nissues.filter_assignee = Assignee\nissues.filter_assginee_no_select = No selected Assignee\nissues.filter_type = Type\nissues.filter_type.all_issues = All issues\nissues.filter_type.assigned_to_you = Assigned to you\nissues.filter_type.created_by_you = Created by you\nissues.filter_type.mentioning_you = Mentioning you\nissues.filter_sort = Sort\nissues.filter_sort.latest = Newest\nissues.filter_sort.oldest = Oldest\nissues.filter_sort.recentupdate = Recently updated\nissues.filter_sort.leastupdate = Least recently updated\nissues.filter_sort.mostcomment = Most commented\nissues.filter_sort.leastcomment = Least commented\nissues.opened_by = opened %[1]s by <a href=\"%[2]s\">%[3]s</a>\nissues.opened_by_fake = opened %[1]s by %[2]s\nissues.previous = Previous\nissues.next = Next\nissues.open_title = Open\nissues.closed_title = Closed\nissues.num_comments = %d comments\nissues.commented_at = `commented <a href=\"#%s\">%s</a>`\nissues.delete_comment_confirm = Are you sure you want to delete this comment?\nissues.no_content = There is no content yet.\nissues.close_issue = Close\nissues.close_comment_issue = Comment and close\nissues.reopen_issue = Reopen\nissues.reopen_comment_issue = Comment and reopen\nissues.create_comment = Comment\nissues.closed_at = `closed <a id=\"%[1]s\" href=\"#%[1]s\">%[2]s</a>`\nissues.reopened_at = `reopened <a id=\"%[1]s\" href=\"#%[1]s\">%[2]s</a>`\nissues.commit_ref_at = `referenced this issue from a commit <a id=\"%[1]s\" href=\"#%[1]s\">%[2]s</a>`\nissues.poster = Poster\nissues.collaborator = Collaborator\nissues.owner = Owner\nissues.sign_in_require_desc = <a href=\"%s\">Sign in</a> to join this conversation.\nissues.edit = Edit\nissues.cancel = Cancel\nissues.save = Save\nissues.label_title = Label name\nissues.label_color = Label color\nissues.label_count = %d labels\nissues.label_open_issues = %d open issues\nissues.label_edit = Edit\nissues.label_delete = Delete\nissues.label_modify = Label Modification\nissues.label_deletion = Label Deletion\nissues.label_deletion_desc = Deleting this label will remove its information in all related issues. Do you want to continue?\nissues.label_deletion_success = Label has been deleted successfully!\nissues.num_participants = %d Participants\nissues.attachment.open_tab = `Click to see \"%s\" in a new tab`\nissues.attachment.download = `Click to download \"%s\"`\n\npulls.new = New Pull Request\npulls.compare_changes = Compare Changes\npulls.compare_changes_desc = Compare two branches and make a pull request for changes.\npulls.compare_base = base\npulls.compare_compare = compare\npulls.filter_branch = Filter branch\npulls.no_results = No results found.\npulls.nothing_to_compare = There is nothing to compare because base and head branches are even.\npulls.nothing_merge_base = There is nothing to compare because two branches have completely different history.\npulls.has_pull_request = `There is already a pull request between these two targets: <a href=\"%[1]s/pulls/%[3]d\">%[2]s#%[3]d</a>`\npulls.create = Create Pull Request\npulls.title_desc = wants to merge %[1]d commits from <code>%[2]s</code> into <code>%[3]s</code>\npulls.merged_title_desc = merged %[1]d commits from <code>%[2]s</code> into <code>%[3]s</code> %[4]s\npulls.tab_conversation = Conversation\npulls.tab_commits = Commits\npulls.tab_files = Files changed\npulls.reopen_to_merge = Please reopen this pull request to perform merge operation.\npulls.merged = Merged\npulls.has_merged = This pull request has been merged successfully!\npulls.data_broken = Data of this pull request has been broken due to deletion of fork information.\npulls.is_checking = The conflict checking is still in progress, please refresh page in few moments.\npulls.can_auto_merge_desc = This pull request can be merged automatically.\npulls.cannot_auto_merge_desc = This pull request can't be merged automatically because there are conflicts.\npulls.cannot_auto_merge_helper = Please merge manually in order to resolve the conflicts.\npulls.create_merge_commit = Create a merge commit\npulls.rebase_before_merging = Rebase before merging\npulls.commit_description = Commit Description\npulls.merge_pull_request = Merge Pull Request\npulls.open_unmerged_pull_exists = `You can't perform reopen operation because there is already an open pull request (#%d) from same repository with same merge information and is waiting for merging.`\npulls.delete_branch = Delete Branch\npulls.delete_branch_has_new_commits = Branch cannot be deleted because it has new commits after mergence.\n\nmilestones.new = New Milestone\nmilestones.open_tab = %d Open\nmilestones.close_tab = %d Closed\nmilestones.closed = Closed %s\nmilestones.no_due_date = No due date\nmilestones.open = Open\nmilestones.close = Close\nmilestones.new_subheader = Create milestones to organize your issues.\nmilestones.create = Create Milestone\nmilestones.title = Title\nmilestones.desc = Description\nmilestones.due_date = Due Date (optional)\nmilestones.clear = Clear\nmilestones.invalid_due_date_format = Due date format is invalid, must be 'yyyy-mm-dd'.\nmilestones.create_success = Milestone '%s' has been created successfully!\nmilestones.edit = Edit Milestone\nmilestones.edit_subheader = Use a better description for milestones so people won't be confused.\nmilestones.cancel = Cancel\nmilestones.modify = Modify Milestone\nmilestones.edit_success = Changes of milestone '%s' has been saved successfully!\nmilestones.deletion = Milestone Deletion\nmilestones.deletion_desc = Deleting this milestone will remove its information in all related issues. Do you want to continue?\nmilestones.deletion_success = Milestone has been deleted successfully!\n\nwiki = Wiki\nwiki.welcome = Welcome to Wiki!\nwiki.welcome_desc = Wiki is the place where you would like to document your project together and make it better.\nwiki.create_first_page = Create the first page\nwiki.page = Page\nwiki.filter_page = Filter page\nwiki.new_page = Create New Page\nwiki.default_commit_message = Write a note about this update (optional).\nwiki.save_page = Save Page\nwiki.last_commit_info = %s edited this page %s\nwiki.edit_page_button = Edit\nwiki.new_page_button = New Page\nwiki.delete_page_button = Delete Page\nwiki.delete_page_notice_1 = This will delete the page <code>\"%s\"</code>. Please be certain.\nwiki.page_already_exists = Wiki page with same name already exists.\nwiki.pages = Pages\nwiki.last_updated = Last updated %s\n\nsettings = Settings\nsettings.options = Options\nsettings.collaboration = Collaboration\nsettings.collaboration.admin = Admin\nsettings.collaboration.write = Write\nsettings.collaboration.read = Read\nsettings.collaboration.undefined = Undefined\nsettings.branches = Branches\nsettings.branches_bare = You cannot manage branches for bare repository. Please push some content first.\nsettings.default_branch = Default Branch\nsettings.default_branch_desc = The default branch is considered the \"base\" branch for code commits, pull requests and online editing.\nsettings.update = Update\nsettings.update_default_branch_unsupported = Change default branch is not supported by the Git version on server.\nsettings.update_default_branch_success = Default branch of this repository has been updated successfully!\nsettings.protected_branches = Protected Branches\nsettings.protected_branches_desc = Protect branches from force pushing, accidental deletion and whitelist code committers.\nsettings.choose_a_branch = Choose a branch...\nsettings.branch_protection = Branch Protection\nsettings.branch_protection_desc = Please choose protect options for branch <b>%s</b>.\nsettings.protect_this_branch = Protect this branch\nsettings.protect_this_branch_desc = Disable force pushes and prevent from deletion.\nsettings.protect_require_pull_request = Require pull request instead direct pushing\nsettings.protect_require_pull_request_desc = Enable this option to disable direct pushing to this branch. Commits have to be pushed to another non-protected branch and merged to this branch through pull request.\nsettings.protect_whitelist_committers = Whitelist who can push to this branch\nsettings.protect_whitelist_committers_desc = Add people or teams to whitelist of direct push to this branch. Users in whitelist will bypass require pull request check.\nsettings.protect_whitelist_users = Users who can push to this branch\nsettings.protect_whitelist_search_users = Search users\nsettings.protect_whitelist_teams = Teams for which members of them can push to this branch\nsettings.protect_whitelist_search_teams = Search teams\nsettings.update_protect_branch_success = Protect options for this branch has been updated successfully!\nsettings.hooks = Webhooks\nsettings.githooks = Git Hooks\nsettings.basic_settings = Basic Settings\nsettings.mirror_settings = Mirror Settings\nsettings.sync_mirror = Sync Now\nsettings.mirror_sync_in_progress = Mirror syncing is in progress, please refresh page in about a minute.\nsettings.site = Official Site\nsettings.update_settings = Update Settings\nsettings.change_reponame_prompt = This change will affect how links relate to the repository.\nsettings.advanced_settings = Advanced Settings\nsettings.wiki_desc = Enable wiki system\nsettings.use_internal_wiki = Use builtin wiki\nsettings.allow_public_wiki_desc = Allow public access to wiki when repository is private\nsettings.use_external_wiki = Use external wiki\nsettings.external_wiki_url = External Wiki URL\nsettings.external_wiki_url_desc = Visitors will be redirected to URL when they click on the tab.\nsettings.issues_desc = Enable issue tracker\nsettings.use_internal_issue_tracker = Use builtin lightweight issue tracker\nsettings.allow_public_issues_desc = Allow public access to issues when repository is private\nsettings.use_external_issue_tracker = Use external issue tracker\nsettings.external_tracker_url = External Issue Tracker URL\nsettings.external_tracker_url_desc = Visitors will be redirected to URL when they click on the tab.\nsettings.tracker_url_format = External Issue Tracker URL Format\nsettings.tracker_issue_style = External Issue Tracker Naming Style:\nsettings.tracker_issue_style.numeric = Numeric\nsettings.tracker_issue_style.alphanumeric = Alphanumeric\nsettings.tracker_url_format_desc = You can use placeholder <code>{user} {repo} {index}</code> for user name, repository name and issue index.\nsettings.pulls_desc = Enable pull requests to accept contributions between repositories and branches\nsettings.pulls.ignore_whitespace = Ignore changes in whitespace\nsettings.pulls.allow_rebase_merge = Allow use rebase to merge commits\nsettings.danger_zone = Danger Zone\nsettings.cannot_fork_to_same_owner = You cannot fork a repository to its original owner.\nsettings.new_owner_has_same_repo = The new owner already has a repository with same name. Please choose another name.\nsettings.convert = Convert To Regular Repository\nsettings.convert_desc = You can convert this mirror to a regular repository. This cannot be reversed.\nsettings.convert_notices_1 = - This operation will convert this repository mirror into a regular repository and cannot be undone.\nsettings.convert_confirm = Confirm Conversion\nsettings.convert_succeed = Repository has been converted to regular type successfully.\nsettings.transfer = Transfer Ownership\nsettings.transfer_desc = Transfer this repository to another user or to an organization in which you have admin rights.\nsettings.transfer_notices_1 = - You will lose access if new owner is a individual user.\nsettings.transfer_notices_2 = - You will conserve access if new owner is an organization and if you're one of the owners.\nsettings.transfer_form_title = Please enter following information to confirm your operation:\nsettings.wiki_delete = Erase Wiki Data\nsettings.wiki_delete_desc = Once you erase wiki data there is no going back. Please be certain.\nsettings.wiki_delete_notices_1 = - This will delete and disable the wiki for %s\nsettings.wiki_deletion_success = Repository wiki data have been erased successfully.\nsettings.delete = Delete This Repository\nsettings.delete_desc = Once you delete a repository, there is no going back. Please be certain.\nsettings.delete_notices_1 = - This operation <strong>CANNOT</strong> be undone.\nsettings.delete_notices_2 = - This operation will permanently delete everything in this repository, including Git data, issues, comments and collaborator access.\nsettings.delete_notices_fork_1 = - All forks will become independent after deletion.\nsettings.deletion_success = Repository has been deleted successfully!\nsettings.update_settings_success = Repository options has been updated successfully.\nsettings.transfer_owner = New Owner\nsettings.make_transfer = Make Transfer\nsettings.transfer_succeed = Repository ownership has been transferred successfully.\nsettings.confirm_delete = Confirm Deletion\nsettings.add_collaborator = Add New Collaborator\nsettings.add_collaborator_success = New collaborator has been added.\nsettings.delete_collaborator = Delete\nsettings.collaborator_deletion = Collaborator Deletion\nsettings.collaborator_deletion_desc = This user will no longer have collaboration access to this repository after deletion. Do you want to continue?\nsettings.remove_collaborator_success = Collaborator has been removed.\nsettings.search_user_placeholder = Search user...\nsettings.org_not_allowed_to_be_collaborator = Organization is not allowed to be added as a collaborator.\nsettings.hooks_desc = Webhooks are much like basic HTTP POST event triggers. Whenever something occurs in Gogs, we will handle the notification to the target host you specify.\nsettings.webhooks.add_new = Add a new webhook:\nsettings.webhooks.choose_a_type = Choose a type...\nsettings.add_webhook = Add webhook\nsettings.webhook_deletion = Delete Webhook\nsettings.webhook_deletion_desc = Delete this webhook will remove its information and all delivery history. Do you want to continue?\nsettings.webhook_deletion_success = Webhook has been deleted successfully!\nsettings.webhook.test_delivery = Test Delivery\nsettings.webhook.test_delivery_desc = Send a fake push event delivery to test your webhook settings\nsettings.webhook.test_delivery_success = Test webhook has been added to delivery queue. It may take few seconds before it shows up in the delivery history.\nsettings.webhook.redelivery = Redelivery\nsettings.webhook.redelivery_success = Hook task '%s' has been readded to delivery queue. It may take few seconds to update delivery status in history.\nsettings.webhook.request = Request\nsettings.webhook.response = Response\nsettings.webhook.headers = Headers\nsettings.webhook.payload = Payload\nsettings.webhook.body = Body\nsettings.webhook.err_cannot_parse_payload_url = Cannot parse payload URL: %v\nsettings.webhook.url_resolved_to_blocked_local_address = Payload URL resolved to a local network address that is implicitly blocked.\nsettings.githooks_desc = Git Hooks are powered by Git itself, you can edit files of supported hooks in the list below to perform custom operations.\nsettings.githook_edit_desc = If the hook is inactive, sample content will be presented. Leaving content to an empty value will disable this hook.\nsettings.githook_name = Hook Name\nsettings.githook_content = Hook Content\nsettings.update_githook = Update Hook\nsettings.add_webhook_desc = Gogs will send a <code>POST</code> request to the URL you specify, along with details regarding the event that occurred. You can also specify what kind of data format you'd like to get upon triggering the hook (JSON, x-www-form-urlencoded, XML, etc). More information can be found in our <a target=\"_blank\" href=\"%s\">Webhooks Guide</a>.\nsettings.payload_url = Payload URL\nsettings.content_type = Content Type\nsettings.secret = Secret\nsettings.secret_desc = Secret will be sent as SHA256 HMAC hex digest of payload via <code>X-Gogs-Signature</code> header.\nsettings.slack_username = Username\nsettings.slack_icon_url = Icon URL\nsettings.slack_color = Color\nsettings.event_desc = When should this webhook be triggered?\nsettings.event_push_only = Just the <code>push</code> event\nsettings.event_send_everything = I need <strong>everything</strong>\nsettings.event_choose = Let me choose what I need\nsettings.event_create = Create\nsettings.event_create_desc = Branch or tag created\nsettings.event_delete = Delete\nsettings.event_delete_desc = Branch or tag deleted\nsettings.event_fork = Fork\nsettings.event_fork_desc = Repository forked\nsettings.event_push = Push\nsettings.event_push_desc = Git push to a repository\nsettings.event_issues = Issues\nsettings.event_issues_desc = Issue opened, closed, reopened, edited, assigned, unassigned, label updated, label cleared, milestoned, or demilestoned.\nsettings.event_pull_request = Pull Request\nsettings.event_pull_request_desc = Pull request opened, closed, reopened, edited, assigned, unassigned, label updated, label cleared, milestoned, demilestoned, or synchronized.\nsettings.event_issue_comment = Issue Comment\nsettings.event_issue_comment_desc = Issue comment created, edited, or deleted.\nsettings.event_release = Release\nsettings.event_release_desc = Release published in a repository.\nsettings.active = Active\nsettings.active_helper = Details regarding the event which triggered the hook will be delivered as well.\nsettings.add_hook_success = New webhook has been added.\nsettings.update_webhook = Update Webhook\nsettings.update_hook_success = Webhook has been updated.\nsettings.delete_webhook = Delete Webhook\nsettings.recent_deliveries = Recent Deliveries\nsettings.hook_type = Hook Type\nsettings.add_slack_hook_desc = Add <a href=\"%s\">Slack</a> integration to your repository.\nsettings.add_discord_hook_desc = Add <a href=\"%s\">Discord</a> integration to your repository.\nsettings.add_dingtalk_hook_desc = Add <a href=\"%s\">Dingtalk</a> integration to your repository.\nsettings.slack_token = Token\nsettings.slack_domain = Domain\nsettings.slack_channel = Channel\nsettings.deploy_keys = Deploy Keys\nsettings.deploy_keys_helper = <b>Common Gotcha!</b> If you're looking for adding personal public keys, please add them in your <a href=\"%s%s\">account settings</a>.\nsettings.add_deploy_key = Add Deploy Key\nsettings.deploy_key_desc = Deploy keys have read-only access. They are not the same as personal account SSH keys.\nsettings.no_deploy_keys = You haven't added any deploy keys.\nsettings.title = Title\nsettings.deploy_key_content = Content\nsettings.key_been_used = Deploy key content has been used.\nsettings.key_name_used = Deploy key with the same name already exists.\nsettings.add_key_success = New deploy key '%s' has been added successfully!\nsettings.deploy_key_deletion = Delete Deploy Key\nsettings.deploy_key_deletion_desc = Deleting this deploy key will remove all related accesses for this repository. Do you want to continue?\nsettings.deploy_key_deletion_success = Deploy key has been deleted successfully!\nsettings.description_desc = Description of repository. Maximum 512 characters length.\nsettings.description_length = Available characters\n\ndiff.browse_source = Browse Source\ndiff.parent = parent\ndiff.commit = commit\ndiff.data_not_available = Diff Data Not Available.\ndiff.show_diff_stats = Show Diff Stats\ndiff.show_split_view = Split View\ndiff.show_unified_view = Unified View\ndiff.stats_desc = <strong> %d changed files</strong> with <strong>%d additions</strong> and <strong>%d deletions</strong>\ndiff.bin = BIN\ndiff.view_file = View File\ndiff.file_suppressed = File diff suppressed because it is too large\ndiff.too_many_files = Some files were not shown because too many files changed in this diff\n\nrelease.releases = Releases\nrelease.new_release = New Release\nrelease.draft = Draft\nrelease.prerelease = Pre-Release\nrelease.edit = edit\nrelease.ahead = <strong>%d</strong> commits to %s since this release\nrelease.source_code = Source Code\nrelease.new_subheader = Publish releases to iterate product.\nrelease.edit_subheader = Detailed change log can help users understand what has been improved.\nrelease.tag_name = Tag name\nrelease.target = Target\nrelease.tag_helper = Choose an existing tag, or create a new tag on publish.\nrelease.title = Title\nrelease.content = Content\nrelease.write = Write\nrelease.preview = Preview\nrelease.loading = Loading...\nrelease.prerelease_desc = This is a pre-release\nrelease.prerelease_helper = We'll point out that this release is not production-ready.\nrelease.cancel = Cancel\nrelease.publish = Publish Release\nrelease.save_draft = Save Draft\nrelease.edit_release = Edit Release\nrelease.delete_release = Delete This Release\nrelease.deletion = Release Deletion\nrelease.deletion_desc = Deleting this release will delete the corresponding Git tag. Do you want to continue?\nrelease.deletion_success = Release has been deleted successfully!\nrelease.tag_name_already_exist = Release with this tag name already exists.\nrelease.tag_name_invalid = Tag name is not valid.\nrelease.downloads = Downloads\n\n[org]\norg_name_holder = Organization Name\norg_full_name_holder = Organization Full Name\norg_name_helper = Great organization names are short and memorable.\ncreate_org = Create Organization\nrepo_updated = Updated\npeople = People\ninvite_someone = Invite Someone\nteams = Teams\nlower_members = members\nlower_repositories = repositories\ncreate_new_team = Create New Team\norg_desc = Description\nteam_name = Team Name\nteam_desc = Description\nteam_name_helper = You'll use this name to mention this team in conversations.\nteam_desc_helper = What is this team all about?\nteam_permission_desc = What permission level should this team have?\n\nform.name_not_allowed = Organization name or pattern %q is not allowed.\nform.team_name_not_allowed = Team name or pattern %q is not allowed.\n\nsettings = Settings\nsettings.options = Options\nsettings.full_name = Full Name\nsettings.website = Website\nsettings.location = Location\nsettings.update_settings = Update Settings\nsettings.update_setting_success = Organization settings has been updated successfully.\nsettings.change_orgname_prompt = This change will affect how links relate to the organization.\nsettings.update_avatar_success = Organization avatar setting has been updated successfully.\nsettings.delete = Delete Organization\nsettings.delete_account = Delete This Organization\nsettings.delete_prompt = The organization will be permanently removed, and this <strong>CANNOT</strong> be undone!\nsettings.confirm_delete_account = Confirm Deletion\nsettings.delete_org_title = Organization Deletion\nsettings.delete_org_desc = This organization is going to be deleted permanently, do you want to continue?\nsettings.hooks_desc = Add webhooks that will be triggered for <strong>all repositories</strong> under this organization.\n\nmembers.membership_visibility = Membership Visibility:\nmembers.public = Public\nmembers.public_helper = make private\nmembers.private = Private\nmembers.private_helper = make public\nmembers.member_role = Member Role:\nmembers.owner = Owner\nmembers.member = Member\nmembers.remove = Remove\nmembers.leave = Leave\nmembers.invite_desc = Add a new member to %s:\nmembers.invite_now = Invite Now\n\nteams.join = Join\nteams.leave = Leave\nteams.read_access = Read Access\nteams.read_access_helper = This team will be able to view and clone its repositories.\nteams.write_access = Write Access\nteams.write_access_helper = This team will be able to read its repositories, as well as push to them.\nteams.admin_access = Admin Access\nteams.admin_access_helper = This team will be able to push/pull to its repositories, as well as add other collaborators to them.\nteams.no_desc = This team has no description\nteams.settings = Settings\nteams.owners_permission_desc = Owners have full access to <strong>all repositories</strong> and have <strong>admin rights</strong> to the organization.\nteams.members = Team Members\nteams.update_settings = Update Settings\nteams.delete_team = Delete This Team\nteams.add_team_member = Add Team Member\nteams.delete_team_title = Team Deletion\nteams.delete_team_desc = As this team will be deleted, members of this team may lose access to some repositories. Do you want to continue?\nteams.delete_team_success = Given team has been deleted successfully.\nteams.read_permission_desc = Membership in this team grants <strong>Read</strong> access: members can view and clone the team's repositories.\nteams.write_permission_desc = Membership in this team grants <strong>Write</strong> access: members can read from and push to the team's repositories.\nteams.admin_permission_desc = Membership in this team grants <strong>Admin</strong> access: members can read from, push to, and add collaborators to the team's repositories.\nteams.repositories = Team Repositories\nteams.search_repo_placeholder = Search repository...\nteams.add_team_repository = Add Team Repository\nteams.remove_repo = Remove\nteams.add_nonexistent_repo = The repository you're trying to add does not exist, please create it first.\n\n[admin]\ndashboard = Dashboard\nusers = Users\norganizations = Organizations\nrepositories = Repositories\nauthentication = Authentications\nconfig = Configuration\nnotices = System Notices\nmonitor = Monitoring\nfirst_page = First\nlast_page = Last\ntotal = Total: %d\n\ndashboard.build_info = Build Information\ndashboard.app_ver = Application version\ndashboard.git_version = Git version\ndashboard.go_version = Go version\ndashboard.build_time = Build time\ndashboard.build_commit = Build commit\ndashboard.statistic = Statistics\ndashboard.operations = Operations\ndashboard.system_status = System Monitor Status\ndashboard.statistic_info = Gogs database has <b>%d</b> users, <b>%d</b> organizations, <b>%d</b> public keys, <b>%d</b> repositories, <b>%d</b> watches, <b>%d</b> stars, <b>%d</b> actions, <b>%d</b> accesses, <b>%d</b> issues, <b>%d</b> comments, <b>%d</b> social accounts, <b>%d</b> follows, <b>%d</b> mirrors, <b>%d</b> releases, <b>%d</b> login sources, <b>%d</b> webhooks, <b>%d</b> milestones, <b>%d</b> labels, <b>%d</b> hook tasks, <b>%d</b> teams, <b>%d</b> update tasks, <b>%d</b> attachments.\ndashboard.operation_name = Operation Name\ndashboard.operation_switch = Switch\ndashboard.select_operation_to_run = Please select operation to run\ndashboard.operation_run = Run\ndashboard.clean_unbind_oauth = Clean unbound OAuthes\ndashboard.clean_unbind_oauth_success = All unbind OAuthes have been deleted successfully.\ndashboard.delete_inactivate_accounts = Delete all inactive accounts\ndashboard.delete_inactivate_accounts_success = All inactivate accounts have been deleted successfully.\ndashboard.delete_repo_archives = Delete all repositories archives\ndashboard.delete_repo_archives_success = All repositories archives have been deleted successfully.\ndashboard.delete_missing_repos = Delete all repository records that lost Git files\ndashboard.delete_missing_repos_success = All repository records that lost Git files have been deleted successfully.\ndashboard.git_gc_repos = Do garbage collection on repositories\ndashboard.git_gc_repos_success = All repositories have done garbage collection successfully.\ndashboard.resync_all_sshkeys = Rewrite '.ssh/authorized_keys' file (caution: non-Gogs keys will be lost)\ndashboard.resync_all_sshkeys_success = All public keys have been rewritten successfully.\ndashboard.resync_all_hooks = Resync pre-receive, update and post-receive hooks of all repositories\ndashboard.resync_all_hooks_success = All repositories' pre-receive, update and post-receive hooks have been resynced successfully.\ndashboard.reinit_missing_repos = Reinitialize all repository records that lost Git files\ndashboard.reinit_missing_repos_success = All repository records that lost Git files have been reinitialized successfully.\n\ndashboard.server_uptime = Server Uptime\ndashboard.current_goroutine = Current Goroutines\ndashboard.current_memory_usage = Current Memory Usage\ndashboard.total_memory_allocated = Total Memory Allocated\ndashboard.memory_obtained = Memory Obtained\ndashboard.pointer_lookup_times = Pointer Lookup Times\ndashboard.memory_allocate_times = Memory Allocate Times\ndashboard.memory_free_times = Memory Free Times\ndashboard.current_heap_usage = Current Heap Usage\ndashboard.heap_memory_obtained = Heap Memory Obtained\ndashboard.heap_memory_idle = Heap Memory Idle\ndashboard.heap_memory_in_use = Heap Memory In Use\ndashboard.heap_memory_released = Heap Memory Released\ndashboard.heap_objects = Heap Objects\ndashboard.bootstrap_stack_usage = Bootstrap Stack Usage\ndashboard.stack_memory_obtained = Stack Memory Obtained\ndashboard.mspan_structures_usage = MSpan Structures Usage\ndashboard.mspan_structures_obtained = MSpan Structures Obtained\ndashboard.mcache_structures_usage = MCache Structures Usage\ndashboard.mcache_structures_obtained = MCache Structures Obtained\ndashboard.profiling_bucket_hash_table_obtained = Profiling Bucket Hash Table Obtained\ndashboard.gc_metadata_obtained = GC Metadata Obtained\ndashboard.other_system_allocation_obtained = Other System Allocation Obtained\ndashboard.next_gc_recycle = Next GC Recycle\ndashboard.last_gc_time = Since Last GC Time\ndashboard.total_gc_time = Total GC Pause\ndashboard.total_gc_pause = Total GC Pause\ndashboard.last_gc_pause = Last GC Pause\ndashboard.gc_times = GC Times\n\nusers.user_manage_panel = User Manage Panel\nusers.new_account = Create New Account\nusers.name = Name\nusers.activated = Activated\nusers.admin = Admin\nusers.repos = Repos\nusers.created = Created\nusers.send_register_notify = Send Registration Notification To User\nusers.new_success = New account '%s' has been created successfully.\nusers.edit = Edit\nusers.auth_source = Authentication Source\nusers.local = Local\nusers.auth_login_name = Authentication Login Name\nusers.password_helper = Leave it empty to remain unchanged.\nusers.update_profile_success = Account profile has been updated successfully.\nusers.edit_account = Edit Account\nusers.max_repo_creation = Maximum Repository Creation Limit\nusers.max_repo_creation_desc = (Set -1 to use global default limit)\nusers.is_activated = This account is activated\nusers.prohibit_login = This account is prohibited to login\nusers.is_admin = This account has administrator permissions\nusers.allow_git_hook = This account has permissions to create Git hooks\nusers.allow_import_local = This account has permissions to import local repositories\nusers.update_profile = Update Account Profile\nusers.delete_account = Delete This Account\nusers.still_own_repo = This account still has ownership over at least one repository, you have to delete or transfer them first.\nusers.still_has_org = This account still has membership in at least one organization, you have to leave or delete the organizations first.\nusers.deletion_success = Account has been deleted successfully!\n\norgs.org_manage_panel = Organization Manage Panel\norgs.name = Name\norgs.teams = Teams\norgs.members = Members\n\nrepos.repo_manage_panel = Repository Manage Panel\nrepos.owner = Owner\nrepos.name = Name\nrepos.private = Private\nrepos.watches = Watches\nrepos.stars = Stars\nrepos.issues = Issues\nrepos.size = Size\n\nauths.auth_sources = Authentication Sources\nauths.new = Add New Source\nauths.name = Name\nauths.type = Type\nauths.enabled = Enabled\nauths.default = Default\nauths.updated = Updated\nauths.auth_type = Authentication Type\nauths.auth_name = Authentication Name\nauths.security_protocol = Security Protocol\nauths.domain = Domain\nauths.host = Host\nauths.port = Port\nauths.bind_dn = Bind DN\nauths.bind_dn_helper = You can use '%s' as placeholder for username, e.g. DOM\\%s\nauths.bind_password = Bind Password\nauths.bind_password_helper = Warning: This password is stored in plain text. Do not use a high privileged account.\nauths.user_base = User Search Base\nauths.user_dn = User DN\nauths.attribute_username = Username Attribute\nauths.attribute_username_placeholder = Leave empty to use sign-in form field value for user name.\nauths.attribute_name = First Name Attribute\nauths.attribute_surname = Surname Attribute\nauths.attribute_mail = Email Attribute\nauths.verify_group_membership = Verify group membership\nauths.group_search_base_dn = Group Search Base DN\nauths.group_filter = Group Filter\nauths.group_attribute_contain_user_list = Group Attribute Containing List of Users\nauths.user_attribute_listed_in_group = User Attribute Listed in Group\nauths.attributes_in_bind = Fetch attributes in Bind DN context\nauths.filter = User Filter\nauths.admin_filter = Admin Filter\nauths.ms_ad_sa = Ms Ad SA\nauths.smtp_auth = SMTP Authentication Type\nauths.smtphost = SMTP Host\nauths.smtpport = SMTP Port\nauths.allowed_domains = Allowed Domains\nauths.allowed_domains_helper = Leave it empty to not restrict any domains. Multiple domains should be separated by comma ','.\nauths.enable_tls = Enable TLS Encryption\nauths.skip_tls_verify = Skip TLS Verify\nauths.pam_service_name = PAM Service Name\nauths.enable_auto_register = Enable Auto Registration\nauths.edit = Edit Authentication Setting\nauths.activated = This authentication is activated\nauths.default_auth =  This authentication is default login source\nauths.new_success = New authentication '%s' has been added successfully.\nauths.update_success = Authentication setting has been updated successfully.\nauths.update = Update Authentication Setting\nauths.delete = Delete This Authentication\nauths.delete_auth_title = Authentication Deletion\nauths.delete_auth_desc = This authentication is going to be deleted, do you want to continue?\nauths.still_in_used = This authentication is still used by some users, please delete or convert these users to another login type first.\nauths.deletion_success = Authentication has been deleted successfully!\nauths.login_source_exist = Login source '%s' already exists.\nauths.github_api_endpoint = API Endpoint\n\nconfig.not_set = (not set)\nconfig.server_config = Server configuration\nconfig.brand_name = Brand name\nconfig.run_user = Run user\nconfig.run_mode = Run mode\nconfig.server.external_url = External URL\nconfig.server.domain = Domain\nconfig.server.protocol = Protocol\nconfig.server.http_addr = HTTP address\nconfig.server.http_port = HTTP port\nconfig.server.cert_file = Certificate file\nconfig.server.key_file = Key file\nconfig.server.tls_min_version = Minimum TLS version\nconfig.server.unix_socket_permission = Unix socket permission\nconfig.server.local_root_url = Local root URL\nconfig.server.offline_mode = Offline mode\nconfig.server.disable_router_log = Disable router log\nconfig.server.enable_gzip = Enable Gzip\nconfig.server.app_data_path = Application data path\nconfig.server.load_assets_from_disk = Load assets from disk\nconfig.server.landing_url = Landing URL\n\nconfig.ssh_config = SSH configuration\nconfig.ssh.enabled = Enabled\nconfig.ssh.domain = Exposed domain\nconfig.ssh.port = Exposed port\nconfig.ssh.root_path = Root path\nconfig.ssh.keygen_path = Keygen path\nconfig.ssh.key_test_path = Key test path\nconfig.ssh.minimum_key_size_check = Minimum key size check\nconfig.ssh.minimum_key_sizes = Minimum key sizes\nconfig.ssh.rewrite_authorized_keys_at_start = Rewrite \"authorized_keys\" at start\nconfig.ssh.start_builtin_server = Start builtin server\nconfig.ssh.listen_host = Listen host\nconfig.ssh.listen_port = Listen port\nconfig.ssh.server_ciphers = Server ciphers\nconfig.ssh.server_macs = Server MACs\n\nconfig.repo_config = Repository configuration\nconfig.repo.root_path = Root path\nconfig.repo.script_type = Script type\nconfig.repo.ansi_chatset = ANSI charset\nconfig.repo.force_private = Force private\nconfig.repo.max_creation_limit = Max creation limit\nconfig.repo.preferred_licenses = Preferred licenses\nconfig.repo.disable_http_git = Disable HTTP Git\nconfig.repo.enable_local_path_migration = Enable local path migration\nconfig.repo.enable_raw_file_render_mode = Enable raw file render mode\nconfig.repo.commits_fetch_concurrency = Commits fetch concurrency\nconfig.repo.editor.line_wrap_extensions = Editor line wrap extensions\nconfig.repo.editor.previewable_file_modes = Editor previewable file modes\nconfig.repo.upload.enabled = Upload enabled\nconfig.repo.upload.temp_path = Upload temporary path\nconfig.repo.upload.allowed_types = Upload allowed types\nconfig.repo.upload.file_max_size = Upload file size limit\nconfig.repo.upload.max_files = Upload files limit\n\nconfig.db_config = Database configuration\nconfig.db.type = Type\nconfig.db.host = Host\nconfig.db.name = Name\nconfig.db.schema = Schema\nconfig.db.schema_helper = (for \"postgres\" only)\nconfig.db.user = User\nconfig.db.ssl_mode = SSL mode\nconfig.db.ssl_mode_helper = (for \"postgres\" only)\nconfig.db.path = Path\nconfig.db.path_helper = (for \"sqlite3\"only)\nconfig.db.max_open_conns = Maximum open connections\nconfig.db.max_idle_conns = Maximum idle connections\n\nconfig.security_config = Security configuration\nconfig.security.login_remember_days = Login remember days\nconfig.security.cookie_remember_name = Remember cookie\nconfig.security.cookie_username = Username cookie\nconfig.security.cookie_secure = Enable secure cookie\nconfig.security.reverse_proxy_auth_user = Reverse proxy authentication header\nconfig.security.enable_login_status_cookie = Enable login status cookie\nconfig.security.login_status_cookie_name = Login status cookie\nconfig.security.local_network_allowlist = Local network allowlist\n\nconfig.email_config = Email configuration\nconfig.email.enabled = Enabled\nconfig.email.subject_prefix = Subject prefix\nconfig.email.host = Host\nconfig.email.from = From\nconfig.email.user = User\nconfig.email.disable_helo = Disable HELO\nconfig.email.helo_hostname = HELO hostname\nconfig.email.skip_verify = Skip certificate verify\nconfig.email.use_certificate = Use custom certificate\nconfig.email.cert_file = Certificate file\nconfig.email.key_file = Key file\nconfig.email.use_plain_text = Use plain text\nconfig.email.add_plain_text_alt = Add plain text alternative\nconfig.email.send_test_mail = Send test email\nconfig.email.test_mail_failed = Failed to send test email to '%s': %v\nconfig.email.test_mail_sent = Test email has been sent to '%s'.\n\nconfig.auth_config = Authentication configuration\nconfig.auth.activate_code_lives = Activate code lives\nconfig.auth.reset_password_code_lives = Reset password code lives\nconfig.auth.require_email_confirm = Require email confirmation\nconfig.auth.require_sign_in_view = Require sign in view\nconfig.auth.disable_registration = Disable registration\nconfig.auth.enable_registration_captcha = Enable registration captcha\nconfig.auth.enable_reverse_proxy_authentication = Enable reverse proxy authentication\nconfig.auth.enable_reverse_proxy_auto_registration = Enable reverse proxy auto registration\nconfig.auth.reverse_proxy_authentication_header = Reverse proxy authentication header\n\nconfig.user_config = User configuration\nconfig.user.enable_email_notify = Enable email notification\n\nconfig.session_config = Session configuration\nconfig.session.provider = Provider\nconfig.session.provider_config = Provider config\nconfig.session.cookie_name = Cookie\nconfig.session.https_only = HTTPS only\nconfig.session.gc_interval = GC interval\nconfig.session.max_life_time = Max life time\nconfig.session.csrf_cookie_name = CSRF cookie\n\nconfig.cache_config = Cache configuration\nconfig.cache.adapter = Adapter\nconfig.cache.interval = GC interval\nconfig.cache.host = Host\n\nconfig.http_config = HTTP configuration\nconfig.http.access_control_allow_origin = Access control allow origin\n\nconfig.attachment_config = Attachment configuration\nconfig.attachment.enabled = Enabled\nconfig.attachment.path = Path\nconfig.attachment.allowed_types = Allowed types\nconfig.attachment.max_size = Size limit\nconfig.attachment.max_files = Files limit\n\nconfig.release_config = Release configuration\nconfig.release.attachment.enabled = Attachment enabled\nconfig.release.attachment.allowed_types = Attachment allowed types\nconfig.release.attachment.max_size = Attachment size limit\nconfig.release.attachment.max_files = Attachment files limit\n\nconfig.picture_config = Picture configuration\nconfig.picture.avatar_upload_path = User avatar upload path\nconfig.picture.repo_avatar_upload_path = Repository avatar upload path\nconfig.picture.gravatar_source = Gravatar source\nconfig.picture.disable_gravatar = Disable Gravatar\nconfig.picture.enable_federated_avatar = Enable federated avatars\n\nconfig.mirror_config = Mirror configuration\nconfig.mirror.default_interval = Default interval\n\nconfig.webhook_config = Webhook configuration\nconfig.webhook.types = Types\nconfig.webhook.deliver_timeout = Deliver timeout\nconfig.webhook.skip_tls_verify = Skip TLS verify\n\nconfig.git_config = Git configuration\nconfig.git.disable_diff_highlight = Disable diff syntax highlight\nconfig.git.max_diff_lines = Diff lines limit (for a single file)\nconfig.git.max_diff_line_characters = Diff characters limit (for a single line)\nconfig.git.max_diff_files = Diff files limit (for a single diff)\nconfig.git.gc_args = GC arguments\nconfig.git.migrate_timeout = Migration timeout\nconfig.git.mirror_timeout = Mirror fetch timeout\nconfig.git.clone_timeout = Clone timeout\nconfig.git.pull_timeout = Pull timeout\nconfig.git.gc_timeout = GC timeout\n\nconfig.lfs_config = LFS configuration\nconfig.lfs.storage = Storage\nconfig.lfs.objects_path = Objects path\n\nconfig.log_config = Log configuration\nconfig.log_file_root_path = Log file root path\nconfig.log_mode = Mode\nconfig.log_options = Options\n\nmonitor.cron = Cron Tasks\nmonitor.name = Name\nmonitor.schedule = Schedule\nmonitor.next = Next Time\nmonitor.previous = Previous Time\nmonitor.execute_times = Execute Times\nmonitor.process = Running Processes\nmonitor.desc = Description\nmonitor.start = Start Time\nmonitor.execute_time = Execution Time\n\nnotices.system_notice_list = System Notices\nnotices.view_detail_header = View Notice Detail\nnotices.actions = Actions\nnotices.select_all = Select All\nnotices.deselect_all = Deselect All\nnotices.inverse_selection = Inverse Selection\nnotices.delete_selected = Delete Selected\nnotices.delete_all = Delete All Notices\nnotices.type = Type\nnotices.type_1 = Repository\nnotices.desc = Description\nnotices.op = Op.\nnotices.delete_success = System notices have been deleted successfully.\n\n[action]\ncreate_repo = created repository <a href=\"%s\">%s</a>\nrename_repo = renamed repository from <code>%[1]s</code> to <a href=\"%[2]s\">%[3]s</a>\ncommit_repo = pushed to <a href=\"%[1]s/src/%[2]s\">%[3]s</a> at <a href=\"%[1]s\">%[4]s</a>\ncompare_commits = View comparison for these %d commits\ntransfer_repo = transfered repository <code>%s</code> to <a href=\"%s\">%s</a>\ncreate_issue = `opened issue <a href=\"%s/issues/%s\">%s#%[2]s</a>`\nclose_issue = `closed issue <a href=\"%s/issues/%s\">%s#%[2]s</a>`\nreopen_issue = `reopened issue <a href=\"%s/issues/%s\">%s#%[2]s</a>`\ncomment_issue = `commented on issue <a href=\"%s/issues/%s\">%s#%[2]s</a>`\ncreate_pull_request = `created pull request <a href=\"%s/pulls/%s\">%s#%[2]s</a>`\nclose_pull_request = `closed pull request <a href=\"%s/pulls/%s\">%s#%[2]s</a>`\nreopen_pull_request = `reopened pull request <a href=\"%s/pulls/%s\">%s#%[2]s</a>`\nmerge_pull_request = `merged pull request <a href=\"%s/pulls/%s\">%s#%[2]s</a>`\ncreate_branch = created new branch <a href=\"%[1]s/src/%[2]s\">%[3]s</a> at <a href=\"%[1]s\">%[4]s</a>\ndelete_branch = deleted branch <code>%[2]s</code> at <a href=\"%[1]s\">%[3]s</a>\npush_tag = pushed tag <a href=\"%s/src/%s\">%[2]s</a> to <a href=\"%[1]s\">%[3]s</a>\ndelete_tag = deleted tag <code>%[2]s</code> at <a href=\"%[1]s\">%[3]s</a>\nfork_repo = forked a repository to <a href=\"%s\">%s</a>\nmirror_sync_push = synced commits to <a href=\"%[1]s/src/%[2]s\">%[3]s</a> at <a href=\"%[1]s\">%[4]s</a> from mirror\nmirror_sync_create = synced new reference <a href=\"%s/src/%s\">%[2]s</a> to <a href=\"%[1]s\">%[3]s</a> from mirror\nmirror_sync_delete = synced and deleted reference <code>%[2]s</code> at <a href=\"%[1]s\">%[3]s</a> from mirror\n\n[tool]\nago = ago\nfrom_now = from now\nnow = now\n1s = 1 second %s\n1m = 1 minute %s\n1h = 1 hour %s\n1d = 1 day %s\n1w = 1 week %s\n1mon = 1 month %s\n1y = 1 year %s\nseconds = %d seconds %s\nminutes = %d minutes %s\nhours = %d hours %s\ndays = %d days %s\nweeks = %d weeks %s\nmonths = %d months %s\nyears = %d years %s\nraw_seconds = seconds\nraw_minutes = minutes\nraw_hours = hours\n\n[dropzone]\ndefault_message = Drop files here or click to upload.\ninvalid_input_type = You can't upload files of this type.\nfile_too_big = File size ({{filesize}} MB) exceeds maximum size ({{maxFilesize}} MB).\nremove_file = Remove file\n", "// Copyright 2015 The Gogs Authors. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage db\n\nimport (\n\t\"fmt\"\n)\n\n//  ____ ___\n// |    |   \\______ ___________\n// |    |   /  ___// __ \\_  __ \\\n// |    |  /\\___ \\\\  ___/|  | \\/\n// |______//____  >\\___  >__|\n//              \\/     \\/\n\ntype ErrUserOwnRepos struct {\n\tUID int64\n}\n\nfunc IsErrUserOwnRepos(err error) bool {\n\t_, ok := err.(ErrUserOwnRepos)\n\treturn ok\n}\n\nfunc (err ErrUserOwnRepos) Error() string {\n\treturn fmt.Sprintf(\"user still has ownership of repositories [uid: %d]\", err.UID)\n}\n\ntype ErrUserHasOrgs struct {\n\tUID int64\n}\n\nfunc IsErrUserHasOrgs(err error) bool {\n\t_, ok := err.(ErrUserHasOrgs)\n\treturn ok\n}\n\nfunc (err ErrUserHasOrgs) Error() string {\n\treturn fmt.Sprintf(\"user still has membership of organizations [uid: %d]\", err.UID)\n}\n\n//  __      __.__ __   .__\n// /  \\    /  \\__|  | _|__|\n// \\   \\/\\/   /  |  |/ /  |\n//  \\        /|  |    <|  |\n//   \\__/\\  / |__|__|_ \\__|\n//        \\/          \\/\n\ntype ErrWikiAlreadyExist struct {\n\tTitle string\n}\n\nfunc IsErrWikiAlreadyExist(err error) bool {\n\t_, ok := err.(ErrWikiAlreadyExist)\n\treturn ok\n}\n\nfunc (err ErrWikiAlreadyExist) Error() string {\n\treturn fmt.Sprintf(\"wiki page already exists [title: %s]\", err.Title)\n}\n\n// __________     ___.   .__  .__          ____  __.\n// \\______   \\__ _\\_ |__ |  | |__| ____   |    |/ _|____ ___.__.\n//  |     ___/  |  \\ __ \\|  | |  |/ ___\\  |      <_/ __ <   |  |\n//  |    |   |  |  / \\_\\ \\  |_|  \\  \\___  |    |  \\  ___/\\___  |\n//  |____|   |____/|___  /____/__|\\___  > |____|__ \\___  > ____|\n//                     \\/             \\/          \\/   \\/\\/\n\ntype ErrKeyUnableVerify struct {\n\tResult string\n}\n\nfunc IsErrKeyUnableVerify(err error) bool {\n\t_, ok := err.(ErrKeyUnableVerify)\n\treturn ok\n}\n\nfunc (err ErrKeyUnableVerify) Error() string {\n\treturn fmt.Sprintf(\"Unable to verify key content [result: %s]\", err.Result)\n}\n\ntype ErrKeyNotExist struct {\n\tID int64\n}\n\nfunc IsErrKeyNotExist(err error) bool {\n\t_, ok := err.(ErrKeyNotExist)\n\treturn ok\n}\n\nfunc (err ErrKeyNotExist) Error() string {\n\treturn fmt.Sprintf(\"public key does not exist [id: %d]\", err.ID)\n}\n\ntype ErrKeyAlreadyExist struct {\n\tOwnerID int64\n\tContent string\n}\n\nfunc IsErrKeyAlreadyExist(err error) bool {\n\t_, ok := err.(ErrKeyAlreadyExist)\n\treturn ok\n}\n\nfunc (err ErrKeyAlreadyExist) Error() string {\n\treturn fmt.Sprintf(\"public key already exists [owner_id: %d, content: %s]\", err.OwnerID, err.Content)\n}\n\ntype ErrKeyNameAlreadyUsed struct {\n\tOwnerID int64\n\tName    string\n}\n\nfunc IsErrKeyNameAlreadyUsed(err error) bool {\n\t_, ok := err.(ErrKeyNameAlreadyUsed)\n\treturn ok\n}\n\nfunc (err ErrKeyNameAlreadyUsed) Error() string {\n\treturn fmt.Sprintf(\"public key already exists [owner_id: %d, name: %s]\", err.OwnerID, err.Name)\n}\n\ntype ErrKeyAccessDenied struct {\n\tUserID int64\n\tKeyID  int64\n\tNote   string\n}\n\nfunc IsErrKeyAccessDenied(err error) bool {\n\t_, ok := err.(ErrKeyAccessDenied)\n\treturn ok\n}\n\nfunc (err ErrKeyAccessDenied) Error() string {\n\treturn fmt.Sprintf(\"user does not have access to the key [user_id: %d, key_id: %d, note: %s]\",\n\t\terr.UserID, err.KeyID, err.Note)\n}\n\ntype ErrDeployKeyAlreadyExist struct {\n\tKeyID  int64\n\tRepoID int64\n}\n\nfunc IsErrDeployKeyAlreadyExist(err error) bool {\n\t_, ok := err.(ErrDeployKeyAlreadyExist)\n\treturn ok\n}\n\nfunc (err ErrDeployKeyAlreadyExist) Error() string {\n\treturn fmt.Sprintf(\"public key already exists [key_id: %d, repo_id: %d]\", err.KeyID, err.RepoID)\n}\n\ntype ErrDeployKeyNameAlreadyUsed struct {\n\tRepoID int64\n\tName   string\n}\n\nfunc IsErrDeployKeyNameAlreadyUsed(err error) bool {\n\t_, ok := err.(ErrDeployKeyNameAlreadyUsed)\n\treturn ok\n}\n\nfunc (err ErrDeployKeyNameAlreadyUsed) Error() string {\n\treturn fmt.Sprintf(\"public key already exists [repo_id: %d, name: %s]\", err.RepoID, err.Name)\n}\n\n// ________                            .__                __  .__\n// \\_____  \\_______  _________    ____ |__|____________ _/  |_|__| ____   ____\n//  /   |   \\_  __ \\/ ___\\__  \\  /    \\|  \\___   /\\__  \\\\   __\\  |/  _ \\ /    \\\n// /    |    \\  | \\/ /_/  > __ \\|   |  \\  |/    /  / __ \\|  | |  (  <_> )   |  \\\n// \\_______  /__|  \\___  (____  /___|  /__/_____ \\(____  /__| |__|\\____/|___|  /\n//         \\/     /_____/     \\/     \\/         \\/     \\/                    \\/\n\ntype ErrLastOrgOwner struct {\n\tUID int64\n}\n\nfunc IsErrLastOrgOwner(err error) bool {\n\t_, ok := err.(ErrLastOrgOwner)\n\treturn ok\n}\n\nfunc (err ErrLastOrgOwner) Error() string {\n\treturn fmt.Sprintf(\"user is the last member of owner team [uid: %d]\", err.UID)\n}\n\n// __________                           .__  __\n// \\______   \\ ____ ______   ____  _____|__|/  |_  ___________ ___.__.\n//  |       _// __ \\\\____ \\ /  _ \\/  ___/  \\   __\\/  _ \\_  __ <   |  |\n//  |    |   \\  ___/|  |_> >  <_> )___ \\|  ||  | (  <_> )  | \\/\\___  |\n//  |____|_  /\\___  >   __/ \\____/____  >__||__|  \\____/|__|   / ____|\n//         \\/     \\/|__|              \\/                       \\/\n\ntype ErrInvalidCloneAddr struct {\n\tIsURLError            bool\n\tIsInvalidPath         bool\n\tIsPermissionDenied    bool\n\tIsBlockedLocalAddress bool\n}\n\nfunc IsErrInvalidCloneAddr(err error) bool {\n\t_, ok := err.(ErrInvalidCloneAddr)\n\treturn ok\n}\n\nfunc (err ErrInvalidCloneAddr) Error() string {\n\treturn fmt.Sprintf(\"invalid clone address [is_url_error: %v, is_invalid_path: %v, is_permission_denied: %v, is_blocked_local_address: %v]\",\n\t\terr.IsURLError, err.IsInvalidPath, err.IsPermissionDenied, err.IsBlockedLocalAddress)\n}\n\ntype ErrUpdateTaskNotExist struct {\n\tUUID string\n}\n\nfunc IsErrUpdateTaskNotExist(err error) bool {\n\t_, ok := err.(ErrUpdateTaskNotExist)\n\treturn ok\n}\n\nfunc (err ErrUpdateTaskNotExist) Error() string {\n\treturn fmt.Sprintf(\"update task does not exist [uuid: %s]\", err.UUID)\n}\n\ntype ErrReleaseAlreadyExist struct {\n\tTagName string\n}\n\nfunc IsErrReleaseAlreadyExist(err error) bool {\n\t_, ok := err.(ErrReleaseAlreadyExist)\n\treturn ok\n}\n\nfunc (err ErrReleaseAlreadyExist) Error() string {\n\treturn fmt.Sprintf(\"release tag already exist [tag_name: %s]\", err.TagName)\n}\n\ntype ErrInvalidTagName struct {\n\tTagName string\n}\n\nfunc IsErrInvalidTagName(err error) bool {\n\t_, ok := err.(ErrInvalidTagName)\n\treturn ok\n}\n\nfunc (err ErrInvalidTagName) Error() string {\n\treturn fmt.Sprintf(\"release tag name is not valid [tag_name: %s]\", err.TagName)\n}\n\ntype ErrRepoFileAlreadyExist struct {\n\tFileName string\n}\n\nfunc IsErrRepoFileAlreadyExist(err error) bool {\n\t_, ok := err.(ErrRepoFileAlreadyExist)\n\treturn ok\n}\n\nfunc (err ErrRepoFileAlreadyExist) Error() string {\n\treturn fmt.Sprintf(\"repository file already exists [file_name: %s]\", err.FileName)\n}\n\n// ___________\n// \\__    ___/___ _____    _____\n//   |    |_/ __ \\\\__  \\  /     \\\n//   |    |\\  ___/ / __ \\|  Y Y  \\\n//   |____| \\___  >____  /__|_|  /\n//              \\/     \\/      \\/\n\ntype ErrTeamAlreadyExist struct {\n\tID    int64\n\tOrgID int64\n\tName  string\n}\n\nfunc IsErrTeamAlreadyExist(err error) bool {\n\t_, ok := err.(ErrTeamAlreadyExist)\n\treturn ok\n}\n\nfunc (err ErrTeamAlreadyExist) Error() string {\n\treturn fmt.Sprintf(\"team already exists [id: %d, org_id: %d, name: %s]\", err.ID, err.OrgID, err.Name)\n}\n\n//  ____ ___        .__                    .___\n// |    |   \\______ |  |   _________     __| _/\n// |    |   /\\____ \\|  |  /  _ \\__  \\   / __ |\n// |    |  / |  |_> >  |_(  <_> ) __ \\_/ /_/ |\n// |______/  |   __/|____/\\____(____  /\\____ |\n//           |__|                   \\/      \\/\n//\n\ntype ErrUploadNotExist struct {\n\tID   int64\n\tUUID string\n}\n\nfunc IsErrUploadNotExist(err error) bool {\n\t_, ok := err.(ErrAttachmentNotExist)\n\treturn ok\n}\n\nfunc (err ErrUploadNotExist) Error() string {\n\treturn fmt.Sprintf(\"attachment does not exist [id: %d, uuid: %s]\", err.ID, err.UUID)\n}\n", "// Copyright 2014 The Gogs Authors. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage db\n\nimport (\n\t\"crypto/hmac\"\n\t\"crypto/sha256\"\n\t\"crypto/tls\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"strings\"\n\t\"time\"\n\n\tjsoniter \"github.com/json-iterator/go\"\n\tgouuid \"github.com/satori/go.uuid\"\n\tlog \"unknwon.dev/clog/v2\"\n\t\"xorm.io/xorm\"\n\n\tapi \"github.com/gogs/go-gogs-client\"\n\n\t\"gogs.io/gogs/internal/conf\"\n\t\"gogs.io/gogs/internal/errutil\"\n\t\"gogs.io/gogs/internal/httplib\"\n\t\"gogs.io/gogs/internal/netutil\"\n\t\"gogs.io/gogs/internal/sync\"\n)\n\nvar HookQueue = sync.NewUniqueQueue(1000)\n\ntype HookContentType int\n\nconst (\n\tJSON HookContentType = iota + 1\n\tFORM\n)\n\nvar hookContentTypes = map[string]HookContentType{\n\t\"json\": JSON,\n\t\"form\": FORM,\n}\n\n// ToHookContentType returns HookContentType by given name.\nfunc ToHookContentType(name string) HookContentType {\n\treturn hookContentTypes[name]\n}\n\nfunc (t HookContentType) Name() string {\n\tswitch t {\n\tcase JSON:\n\t\treturn \"json\"\n\tcase FORM:\n\t\treturn \"form\"\n\t}\n\treturn \"\"\n}\n\n// IsValidHookContentType returns true if given name is a valid hook content type.\nfunc IsValidHookContentType(name string) bool {\n\t_, ok := hookContentTypes[name]\n\treturn ok\n}\n\ntype HookEvents struct {\n\tCreate       bool `json:\"create\"`\n\tDelete       bool `json:\"delete\"`\n\tFork         bool `json:\"fork\"`\n\tPush         bool `json:\"push\"`\n\tIssues       bool `json:\"issues\"`\n\tPullRequest  bool `json:\"pull_request\"`\n\tIssueComment bool `json:\"issue_comment\"`\n\tRelease      bool `json:\"release\"`\n}\n\n// HookEvent represents events that will delivery hook.\ntype HookEvent struct {\n\tPushOnly       bool `json:\"push_only\"`\n\tSendEverything bool `json:\"send_everything\"`\n\tChooseEvents   bool `json:\"choose_events\"`\n\n\tHookEvents `json:\"events\"`\n}\n\ntype HookStatus int\n\nconst (\n\tHOOK_STATUS_NONE = iota\n\tHOOK_STATUS_SUCCEED\n\tHOOK_STATUS_FAILED\n)\n\n// Webhook represents a web hook object.\ntype Webhook struct {\n\tID           int64\n\tRepoID       int64\n\tOrgID        int64\n\tURL          string `xorm:\"url TEXT\"`\n\tContentType  HookContentType\n\tSecret       string     `xorm:\"TEXT\"`\n\tEvents       string     `xorm:\"TEXT\"`\n\t*HookEvent   `xorm:\"-\"` // LEGACY [1.0]: Cannot ignore JSON (i.e. json:\"-\") here, it breaks old backup archive\n\tIsSSL        bool       `xorm:\"is_ssl\"`\n\tIsActive     bool\n\tHookTaskType HookTaskType\n\tMeta         string     `xorm:\"TEXT\"` // store hook-specific attributes\n\tLastStatus   HookStatus // Last delivery status\n\n\tCreated     time.Time `xorm:\"-\" json:\"-\"`\n\tCreatedUnix int64\n\tUpdated     time.Time `xorm:\"-\" json:\"-\"`\n\tUpdatedUnix int64\n}\n\nfunc (w *Webhook) BeforeInsert() {\n\tw.CreatedUnix = time.Now().Unix()\n\tw.UpdatedUnix = w.CreatedUnix\n}\n\nfunc (w *Webhook) BeforeUpdate() {\n\tw.UpdatedUnix = time.Now().Unix()\n}\n\nfunc (w *Webhook) AfterSet(colName string, _ xorm.Cell) {\n\tvar err error\n\tswitch colName {\n\tcase \"events\":\n\t\tw.HookEvent = &HookEvent{}\n\t\tif err = jsoniter.Unmarshal([]byte(w.Events), w.HookEvent); err != nil {\n\t\t\tlog.Error(\"Unmarshal [%d]: %v\", w.ID, err)\n\t\t}\n\tcase \"created_unix\":\n\t\tw.Created = time.Unix(w.CreatedUnix, 0).Local()\n\tcase \"updated_unix\":\n\t\tw.Updated = time.Unix(w.UpdatedUnix, 0).Local()\n\t}\n}\n\nfunc (w *Webhook) SlackMeta() *SlackMeta {\n\ts := &SlackMeta{}\n\tif err := jsoniter.Unmarshal([]byte(w.Meta), s); err != nil {\n\t\tlog.Error(\"Failed to get Slack meta [webhook_id: %d]: %v\", w.ID, err)\n\t}\n\treturn s\n}\n\n// History returns history of webhook by given conditions.\nfunc (w *Webhook) History(page int) ([]*HookTask, error) {\n\treturn HookTasks(w.ID, page)\n}\n\n// UpdateEvent handles conversion from HookEvent to Events.\nfunc (w *Webhook) UpdateEvent() error {\n\tdata, err := jsoniter.Marshal(w.HookEvent)\n\tw.Events = string(data)\n\treturn err\n}\n\n// HasCreateEvent returns true if hook enabled create event.\nfunc (w *Webhook) HasCreateEvent() bool {\n\treturn w.SendEverything ||\n\t\t(w.ChooseEvents && w.HookEvents.Create)\n}\n\n// HasDeleteEvent returns true if hook enabled delete event.\nfunc (w *Webhook) HasDeleteEvent() bool {\n\treturn w.SendEverything ||\n\t\t(w.ChooseEvents && w.HookEvents.Delete)\n}\n\n// HasForkEvent returns true if hook enabled fork event.\nfunc (w *Webhook) HasForkEvent() bool {\n\treturn w.SendEverything ||\n\t\t(w.ChooseEvents && w.HookEvents.Fork)\n}\n\n// HasPushEvent returns true if hook enabled push event.\nfunc (w *Webhook) HasPushEvent() bool {\n\treturn w.PushOnly || w.SendEverything ||\n\t\t(w.ChooseEvents && w.HookEvents.Push)\n}\n\n// HasIssuesEvent returns true if hook enabled issues event.\nfunc (w *Webhook) HasIssuesEvent() bool {\n\treturn w.SendEverything ||\n\t\t(w.ChooseEvents && w.HookEvents.Issues)\n}\n\n// HasPullRequestEvent returns true if hook enabled pull request event.\nfunc (w *Webhook) HasPullRequestEvent() bool {\n\treturn w.SendEverything ||\n\t\t(w.ChooseEvents && w.HookEvents.PullRequest)\n}\n\n// HasIssueCommentEvent returns true if hook enabled issue comment event.\nfunc (w *Webhook) HasIssueCommentEvent() bool {\n\treturn w.SendEverything ||\n\t\t(w.ChooseEvents && w.HookEvents.IssueComment)\n}\n\n// HasReleaseEvent returns true if hook enabled release event.\nfunc (w *Webhook) HasReleaseEvent() bool {\n\treturn w.SendEverything ||\n\t\t(w.ChooseEvents && w.HookEvents.Release)\n}\n\ntype eventChecker struct {\n\tchecker func() bool\n\ttyp     HookEventType\n}\n\nfunc (w *Webhook) EventsArray() []string {\n\tevents := make([]string, 0, 8)\n\teventCheckers := []eventChecker{\n\t\t{w.HasCreateEvent, HOOK_EVENT_CREATE},\n\t\t{w.HasDeleteEvent, HOOK_EVENT_DELETE},\n\t\t{w.HasForkEvent, HOOK_EVENT_FORK},\n\t\t{w.HasPushEvent, HOOK_EVENT_PUSH},\n\t\t{w.HasIssuesEvent, HOOK_EVENT_ISSUES},\n\t\t{w.HasPullRequestEvent, HOOK_EVENT_PULL_REQUEST},\n\t\t{w.HasIssueCommentEvent, HOOK_EVENT_ISSUE_COMMENT},\n\t\t{w.HasReleaseEvent, HOOK_EVENT_RELEASE},\n\t}\n\tfor _, c := range eventCheckers {\n\t\tif c.checker() {\n\t\t\tevents = append(events, string(c.typ))\n\t\t}\n\t}\n\treturn events\n}\n\n// CreateWebhook creates a new web hook.\nfunc CreateWebhook(w *Webhook) error {\n\t_, err := x.Insert(w)\n\treturn err\n}\n\nvar _ errutil.NotFound = (*ErrWebhookNotExist)(nil)\n\ntype ErrWebhookNotExist struct {\n\targs map[string]interface{}\n}\n\nfunc IsErrWebhookNotExist(err error) bool {\n\t_, ok := err.(ErrWebhookNotExist)\n\treturn ok\n}\n\nfunc (err ErrWebhookNotExist) Error() string {\n\treturn fmt.Sprintf(\"webhook does not exist: %v\", err.args)\n}\n\nfunc (ErrWebhookNotExist) NotFound() bool {\n\treturn true\n}\n\n// getWebhook uses argument bean as query condition,\n// ID must be specified and do not assign unnecessary fields.\nfunc getWebhook(bean *Webhook) (*Webhook, error) {\n\thas, err := x.Get(bean)\n\tif err != nil {\n\t\treturn nil, err\n\t} else if !has {\n\t\treturn nil, ErrWebhookNotExist{args: map[string]interface{}{\"webhookID\": bean.ID}}\n\t}\n\treturn bean, nil\n}\n\n// GetWebhookByID returns webhook by given ID.\n// Use this function with caution of accessing unauthorized webhook,\n// which means should only be used in non-user interactive functions.\nfunc GetWebhookByID(id int64) (*Webhook, error) {\n\treturn getWebhook(&Webhook{\n\t\tID: id,\n\t})\n}\n\n// GetWebhookOfRepoByID returns webhook of repository by given ID.\nfunc GetWebhookOfRepoByID(repoID, id int64) (*Webhook, error) {\n\treturn getWebhook(&Webhook{\n\t\tID:     id,\n\t\tRepoID: repoID,\n\t})\n}\n\n// GetWebhookByOrgID returns webhook of organization by given ID.\nfunc GetWebhookByOrgID(orgID, id int64) (*Webhook, error) {\n\treturn getWebhook(&Webhook{\n\t\tID:    id,\n\t\tOrgID: orgID,\n\t})\n}\n\n// getActiveWebhooksByRepoID returns all active webhooks of repository.\nfunc getActiveWebhooksByRepoID(e Engine, repoID int64) ([]*Webhook, error) {\n\twebhooks := make([]*Webhook, 0, 5)\n\treturn webhooks, e.Where(\"repo_id = ?\", repoID).And(\"is_active = ?\", true).Find(&webhooks)\n}\n\n// GetWebhooksByRepoID returns all webhooks of a repository.\nfunc GetWebhooksByRepoID(repoID int64) ([]*Webhook, error) {\n\twebhooks := make([]*Webhook, 0, 5)\n\treturn webhooks, x.Find(&webhooks, &Webhook{RepoID: repoID})\n}\n\n// UpdateWebhook updates information of webhook.\nfunc UpdateWebhook(w *Webhook) error {\n\t_, err := x.Id(w.ID).AllCols().Update(w)\n\treturn err\n}\n\n// deleteWebhook uses argument bean as query condition,\n// ID must be specified and do not assign unnecessary fields.\nfunc deleteWebhook(bean *Webhook) (err error) {\n\tsess := x.NewSession()\n\tdefer sess.Close()\n\tif err = sess.Begin(); err != nil {\n\t\treturn err\n\t}\n\n\tif _, err = sess.Delete(bean); err != nil {\n\t\treturn err\n\t} else if _, err = sess.Delete(&HookTask{HookID: bean.ID}); err != nil {\n\t\treturn err\n\t}\n\n\treturn sess.Commit()\n}\n\n// DeleteWebhookOfRepoByID deletes webhook of repository by given ID.\nfunc DeleteWebhookOfRepoByID(repoID, id int64) error {\n\treturn deleteWebhook(&Webhook{\n\t\tID:     id,\n\t\tRepoID: repoID,\n\t})\n}\n\n// DeleteWebhookOfOrgByID deletes webhook of organization by given ID.\nfunc DeleteWebhookOfOrgByID(orgID, id int64) error {\n\treturn deleteWebhook(&Webhook{\n\t\tID:    id,\n\t\tOrgID: orgID,\n\t})\n}\n\n// GetWebhooksByOrgID returns all webhooks for an organization.\nfunc GetWebhooksByOrgID(orgID int64) (ws []*Webhook, err error) {\n\terr = x.Find(&ws, &Webhook{OrgID: orgID})\n\treturn ws, err\n}\n\n// getActiveWebhooksByOrgID returns all active webhooks for an organization.\nfunc getActiveWebhooksByOrgID(e Engine, orgID int64) ([]*Webhook, error) {\n\tws := make([]*Webhook, 0, 3)\n\treturn ws, e.Where(\"org_id=?\", orgID).And(\"is_active=?\", true).Find(&ws)\n}\n\n//   ___ ___                __   ___________              __\n//  /   |   \\  ____   ____ |  | _\\__    ___/____    _____|  | __\n// /    ~    \\/  _ \\ /  _ \\|  |/ / |    |  \\__  \\  /  ___/  |/ /\n// \\    Y    (  <_> |  <_> )    <  |    |   / __ \\_\\___ \\|    <\n//  \\___|_  / \\____/ \\____/|__|_ \\ |____|  (____  /____  >__|_ \\\n//        \\/                    \\/              \\/     \\/     \\/\n\ntype HookTaskType int\n\nconst (\n\tGOGS HookTaskType = iota + 1\n\tSLACK\n\tDISCORD\n\tDINGTALK\n)\n\nvar hookTaskTypes = map[string]HookTaskType{\n\t\"gogs\":     GOGS,\n\t\"slack\":    SLACK,\n\t\"discord\":  DISCORD,\n\t\"dingtalk\": DINGTALK,\n}\n\n// ToHookTaskType returns HookTaskType by given name.\nfunc ToHookTaskType(name string) HookTaskType {\n\treturn hookTaskTypes[name]\n}\n\nfunc (t HookTaskType) Name() string {\n\tswitch t {\n\tcase GOGS:\n\t\treturn \"gogs\"\n\tcase SLACK:\n\t\treturn \"slack\"\n\tcase DISCORD:\n\t\treturn \"discord\"\n\tcase DINGTALK:\n\t\treturn \"dingtalk\"\n\t}\n\treturn \"\"\n}\n\n// IsValidHookTaskType returns true if given name is a valid hook task type.\nfunc IsValidHookTaskType(name string) bool {\n\t_, ok := hookTaskTypes[name]\n\treturn ok\n}\n\ntype HookEventType string\n\nconst (\n\tHOOK_EVENT_CREATE        HookEventType = \"create\"\n\tHOOK_EVENT_DELETE        HookEventType = \"delete\"\n\tHOOK_EVENT_FORK          HookEventType = \"fork\"\n\tHOOK_EVENT_PUSH          HookEventType = \"push\"\n\tHOOK_EVENT_ISSUES        HookEventType = \"issues\"\n\tHOOK_EVENT_PULL_REQUEST  HookEventType = \"pull_request\"\n\tHOOK_EVENT_ISSUE_COMMENT HookEventType = \"issue_comment\"\n\tHOOK_EVENT_RELEASE       HookEventType = \"release\"\n)\n\n// HookRequest represents hook task request information.\ntype HookRequest struct {\n\tHeaders map[string]string `json:\"headers\"`\n}\n\n// HookResponse represents hook task response information.\ntype HookResponse struct {\n\tStatus  int               `json:\"status\"`\n\tHeaders map[string]string `json:\"headers\"`\n\tBody    string            `json:\"body\"`\n}\n\n// HookTask represents a hook task.\ntype HookTask struct {\n\tID              int64\n\tRepoID          int64 `xorm:\"INDEX\"`\n\tHookID          int64\n\tUUID            string\n\tType            HookTaskType\n\tURL             string `xorm:\"TEXT\"`\n\tSignature       string `xorm:\"TEXT\"`\n\tapi.Payloader   `xorm:\"-\" json:\"-\"`\n\tPayloadContent  string `xorm:\"TEXT\"`\n\tContentType     HookContentType\n\tEventType       HookEventType\n\tIsSSL           bool\n\tIsDelivered     bool\n\tDelivered       int64\n\tDeliveredString string `xorm:\"-\" json:\"-\"`\n\n\t// History info.\n\tIsSucceed       bool\n\tRequestContent  string        `xorm:\"TEXT\"`\n\tRequestInfo     *HookRequest  `xorm:\"-\" json:\"-\"`\n\tResponseContent string        `xorm:\"TEXT\"`\n\tResponseInfo    *HookResponse `xorm:\"-\" json:\"-\"`\n}\n\nfunc (t *HookTask) BeforeUpdate() {\n\tif t.RequestInfo != nil {\n\t\tt.RequestContent = t.ToJSON(t.RequestInfo)\n\t}\n\tif t.ResponseInfo != nil {\n\t\tt.ResponseContent = t.ToJSON(t.ResponseInfo)\n\t}\n}\n\nfunc (t *HookTask) AfterSet(colName string, _ xorm.Cell) {\n\tvar err error\n\tswitch colName {\n\tcase \"delivered\":\n\t\tt.DeliveredString = time.Unix(0, t.Delivered).Format(\"2006-01-02 15:04:05 MST\")\n\n\tcase \"request_content\":\n\t\tif t.RequestContent == \"\" {\n\t\t\treturn\n\t\t}\n\n\t\tt.RequestInfo = &HookRequest{}\n\t\tif err = jsoniter.Unmarshal([]byte(t.RequestContent), t.RequestInfo); err != nil {\n\t\t\tlog.Error(\"Unmarshal[%d]: %v\", t.ID, err)\n\t\t}\n\n\tcase \"response_content\":\n\t\tif t.ResponseContent == \"\" {\n\t\t\treturn\n\t\t}\n\n\t\tt.ResponseInfo = &HookResponse{}\n\t\tif err = jsoniter.Unmarshal([]byte(t.ResponseContent), t.ResponseInfo); err != nil {\n\t\t\tlog.Error(\"Unmarshal [%d]: %v\", t.ID, err)\n\t\t}\n\t}\n}\n\nfunc (t *HookTask) ToJSON(v interface{}) string {\n\tp, err := jsoniter.Marshal(v)\n\tif err != nil {\n\t\tlog.Error(\"Marshal [%d]: %v\", t.ID, err)\n\t}\n\treturn string(p)\n}\n\n// HookTasks returns a list of hook tasks by given conditions.\nfunc HookTasks(hookID int64, page int) ([]*HookTask, error) {\n\ttasks := make([]*HookTask, 0, conf.Webhook.PagingNum)\n\treturn tasks, x.Limit(conf.Webhook.PagingNum, (page-1)*conf.Webhook.PagingNum).Where(\"hook_id=?\", hookID).Desc(\"id\").Find(&tasks)\n}\n\n// createHookTask creates a new hook task,\n// it handles conversion from Payload to PayloadContent.\nfunc createHookTask(e Engine, t *HookTask) error {\n\tdata, err := t.Payloader.JSONPayload()\n\tif err != nil {\n\t\treturn err\n\t}\n\tt.UUID = gouuid.NewV4().String()\n\tt.PayloadContent = string(data)\n\t_, err = e.Insert(t)\n\treturn err\n}\n\nvar _ errutil.NotFound = (*ErrHookTaskNotExist)(nil)\n\ntype ErrHookTaskNotExist struct {\n\targs map[string]interface{}\n}\n\nfunc IsHookTaskNotExist(err error) bool {\n\t_, ok := err.(ErrHookTaskNotExist)\n\treturn ok\n}\n\nfunc (err ErrHookTaskNotExist) Error() string {\n\treturn fmt.Sprintf(\"hook task does not exist: %v\", err.args)\n}\n\nfunc (ErrHookTaskNotExist) NotFound() bool {\n\treturn true\n}\n\n// GetHookTaskOfWebhookByUUID returns hook task of given webhook by UUID.\nfunc GetHookTaskOfWebhookByUUID(webhookID int64, uuid string) (*HookTask, error) {\n\thookTask := &HookTask{\n\t\tHookID: webhookID,\n\t\tUUID:   uuid,\n\t}\n\thas, err := x.Get(hookTask)\n\tif err != nil {\n\t\treturn nil, err\n\t} else if !has {\n\t\treturn nil, ErrHookTaskNotExist{args: map[string]interface{}{\"webhookID\": webhookID, \"uuid\": uuid}}\n\t}\n\treturn hookTask, nil\n}\n\n// UpdateHookTask updates information of hook task.\nfunc UpdateHookTask(t *HookTask) error {\n\t_, err := x.Id(t.ID).AllCols().Update(t)\n\treturn err\n}\n\n// prepareHookTasks adds list of webhooks to task queue.\nfunc prepareHookTasks(e Engine, repo *Repository, event HookEventType, p api.Payloader, webhooks []*Webhook) (err error) {\n\tif len(webhooks) == 0 {\n\t\treturn nil\n\t}\n\n\tvar payloader api.Payloader\n\tfor _, w := range webhooks {\n\t\tswitch event {\n\t\tcase HOOK_EVENT_CREATE:\n\t\t\tif !w.HasCreateEvent() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\tcase HOOK_EVENT_DELETE:\n\t\t\tif !w.HasDeleteEvent() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\tcase HOOK_EVENT_FORK:\n\t\t\tif !w.HasForkEvent() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\tcase HOOK_EVENT_PUSH:\n\t\t\tif !w.HasPushEvent() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\tcase HOOK_EVENT_ISSUES:\n\t\t\tif !w.HasIssuesEvent() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\tcase HOOK_EVENT_PULL_REQUEST:\n\t\t\tif !w.HasPullRequestEvent() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\tcase HOOK_EVENT_ISSUE_COMMENT:\n\t\t\tif !w.HasIssueCommentEvent() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\tcase HOOK_EVENT_RELEASE:\n\t\t\tif !w.HasReleaseEvent() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\t// Use separate objects so modifications won't be made on payload on non-Gogs type hooks.\n\t\tswitch w.HookTaskType {\n\t\tcase SLACK:\n\t\t\tpayloader, err = GetSlackPayload(p, event, w.Meta)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"GetSlackPayload: %v\", err)\n\t\t\t}\n\t\tcase DISCORD:\n\t\t\tpayloader, err = GetDiscordPayload(p, event, w.Meta)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"GetDiscordPayload: %v\", err)\n\t\t\t}\n\t\tcase DINGTALK:\n\t\t\tpayloader, err = GetDingtalkPayload(p, event)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"GetDingtalkPayload: %v\", err)\n\t\t\t}\n\t\tdefault:\n\t\t\tpayloader = p\n\t\t}\n\n\t\tvar signature string\n\t\tif len(w.Secret) > 0 {\n\t\t\tdata, err := payloader.JSONPayload()\n\t\t\tif err != nil {\n\t\t\t\tlog.Error(\"prepareWebhooks.JSONPayload: %v\", err)\n\t\t\t}\n\t\t\tsig := hmac.New(sha256.New, []byte(w.Secret))\n\t\t\t_, _ = sig.Write(data)\n\t\t\tsignature = hex.EncodeToString(sig.Sum(nil))\n\t\t}\n\n\t\tif err = createHookTask(e, &HookTask{\n\t\t\tRepoID:      repo.ID,\n\t\t\tHookID:      w.ID,\n\t\t\tType:        w.HookTaskType,\n\t\t\tURL:         w.URL,\n\t\t\tSignature:   signature,\n\t\t\tPayloader:   payloader,\n\t\t\tContentType: w.ContentType,\n\t\t\tEventType:   event,\n\t\t\tIsSSL:       w.IsSSL,\n\t\t}); err != nil {\n\t\t\treturn fmt.Errorf(\"createHookTask: %v\", err)\n\t\t}\n\t}\n\n\t// It's safe to fail when the whole function is called during hook execution\n\t// because resource released after exit. Also, there is no process started to\n\t// consume this input during hook execution.\n\tgo HookQueue.Add(repo.ID)\n\treturn nil\n}\n\nfunc prepareWebhooks(e Engine, repo *Repository, event HookEventType, p api.Payloader) error {\n\twebhooks, err := getActiveWebhooksByRepoID(e, repo.ID)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"getActiveWebhooksByRepoID [%d]: %v\", repo.ID, err)\n\t}\n\n\t// check if repo belongs to org and append additional webhooks\n\tif repo.mustOwner(e).IsOrganization() {\n\t\t// get hooks for org\n\t\torgws, err := getActiveWebhooksByOrgID(e, repo.OwnerID)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"getActiveWebhooksByOrgID [%d]: %v\", repo.OwnerID, err)\n\t\t}\n\t\twebhooks = append(webhooks, orgws...)\n\t}\n\treturn prepareHookTasks(e, repo, event, p, webhooks)\n}\n\n// PrepareWebhooks adds all active webhooks to task queue.\nfunc PrepareWebhooks(repo *Repository, event HookEventType, p api.Payloader) error {\n\treturn prepareWebhooks(x, repo, event, p)\n}\n\n// TestWebhook adds the test webhook matches the ID to task queue.\nfunc TestWebhook(repo *Repository, event HookEventType, p api.Payloader, webhookID int64) error {\n\twebhook, err := GetWebhookOfRepoByID(repo.ID, webhookID)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"GetWebhookOfRepoByID [repo_id: %d, id: %d]: %v\", repo.ID, webhookID, err)\n\t}\n\treturn prepareHookTasks(x, repo, event, p, []*Webhook{webhook})\n}\n\nfunc (t *HookTask) deliver() {\n\tif netutil.IsBlockedLocalHostname(t.URL, conf.Security.LocalNetworkAllowlist) {\n\t\tt.ResponseContent = \"Payload URL resolved to a local network address that is implicitly blocked.\"\n\t\treturn\n\t}\n\n\tt.IsDelivered = true\n\n\ttimeout := time.Duration(conf.Webhook.DeliverTimeout) * time.Second\n\treq := httplib.Post(t.URL).SetTimeout(timeout, timeout).\n\t\tHeader(\"X-Github-Delivery\", t.UUID).\n\t\tHeader(\"X-Github-Event\", string(t.EventType)).\n\t\tHeader(\"X-Gogs-Delivery\", t.UUID).\n\t\tHeader(\"X-Gogs-Signature\", t.Signature).\n\t\tHeader(\"X-Gogs-Event\", string(t.EventType)).\n\t\tSetTLSClientConfig(&tls.Config{InsecureSkipVerify: conf.Webhook.SkipTLSVerify})\n\n\tswitch t.ContentType {\n\tcase JSON:\n\t\treq = req.Header(\"Content-Type\", \"application/json\").Body(t.PayloadContent)\n\tcase FORM:\n\t\treq.Param(\"payload\", t.PayloadContent)\n\t}\n\n\t// Record delivery information.\n\tt.RequestInfo = &HookRequest{\n\t\tHeaders: map[string]string{},\n\t}\n\tfor k, vals := range req.Headers() {\n\t\tt.RequestInfo.Headers[k] = strings.Join(vals, \",\")\n\t}\n\n\tt.ResponseInfo = &HookResponse{\n\t\tHeaders: map[string]string{},\n\t}\n\n\tdefer func() {\n\t\tt.Delivered = time.Now().UnixNano()\n\t\tif t.IsSucceed {\n\t\t\tlog.Trace(\"Hook delivered: %s\", t.UUID)\n\t\t} else {\n\t\t\tlog.Trace(\"Hook delivery failed: %s\", t.UUID)\n\t\t}\n\n\t\t// Update webhook last delivery status.\n\t\tw, err := GetWebhookByID(t.HookID)\n\t\tif err != nil {\n\t\t\tlog.Error(\"GetWebhookByID: %v\", err)\n\t\t\treturn\n\t\t}\n\t\tif t.IsSucceed {\n\t\t\tw.LastStatus = HOOK_STATUS_SUCCEED\n\t\t} else {\n\t\t\tw.LastStatus = HOOK_STATUS_FAILED\n\t\t}\n\t\tif err = UpdateWebhook(w); err != nil {\n\t\t\tlog.Error(\"UpdateWebhook: %v\", err)\n\t\t\treturn\n\t\t}\n\t}()\n\n\tresp, err := req.Response()\n\tif err != nil {\n\t\tt.ResponseInfo.Body = fmt.Sprintf(\"Delivery: %v\", err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\t// Status code is 20x can be seen as succeed.\n\tt.IsSucceed = resp.StatusCode/100 == 2\n\tt.ResponseInfo.Status = resp.StatusCode\n\tfor k, vals := range resp.Header {\n\t\tt.ResponseInfo.Headers[k] = strings.Join(vals, \",\")\n\t}\n\n\tp, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tt.ResponseInfo.Body = fmt.Sprintf(\"read body: %s\", err)\n\t\treturn\n\t}\n\tt.ResponseInfo.Body = string(p)\n}\n\n// DeliverHooks checks and delivers undelivered hooks.\n// TODO: shoot more hooks at same time.\nfunc DeliverHooks() {\n\ttasks := make([]*HookTask, 0, 10)\n\t_ = x.Where(\"is_delivered = ?\", false).Iterate(new(HookTask),\n\t\tfunc(idx int, bean interface{}) error {\n\t\t\tt := bean.(*HookTask)\n\t\t\tt.deliver()\n\t\t\ttasks = append(tasks, t)\n\t\t\treturn nil\n\t\t})\n\n\t// Update hook task status.\n\tfor _, t := range tasks {\n\t\tif err := UpdateHookTask(t); err != nil {\n\t\t\tlog.Error(\"UpdateHookTask [%d]: %v\", t.ID, err)\n\t\t}\n\t}\n\n\t// Start listening on new hook requests.\n\tfor repoID := range HookQueue.Queue() {\n\t\tlog.Trace(\"DeliverHooks [repo_id: %v]\", repoID)\n\t\tHookQueue.Remove(repoID)\n\n\t\ttasks = make([]*HookTask, 0, 5)\n\t\tif err := x.Where(\"repo_id = ?\", repoID).And(\"is_delivered = ?\", false).Find(&tasks); err != nil {\n\t\t\tlog.Error(\"Get repository [%s] hook tasks: %v\", repoID, err)\n\t\t\tcontinue\n\t\t}\n\t\tfor _, t := range tasks {\n\t\t\tt.deliver()\n\t\t\tif err := UpdateHookTask(t); err != nil {\n\t\t\t\tlog.Error(\"UpdateHookTask [%d]: %v\", t.ID, err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc InitDeliverHooks() {\n\tgo DeliverHooks()\n}\n", "// Copyright 2014 The Gogs Authors. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage form\n\nimport (\n\t\"net/url\"\n\t\"strings\"\n\n\t\"github.com/go-macaron/binding\"\n\t\"github.com/unknwon/com\"\n\t\"gopkg.in/macaron.v1\"\n\n\t\"gogs.io/gogs/internal/conf\"\n\t\"gogs.io/gogs/internal/db\"\n\t\"gogs.io/gogs/internal/netutil\"\n)\n\n// _______________________________________    _________.______________________ _______________.___.\n// \\______   \\_   _____/\\______   \\_____  \\  /   _____/|   \\__    ___/\\_____  \\\\______   \\__  |   |\n//  |       _/|    __)_  |     ___//   |   \\ \\_____  \\ |   | |    |    /   |   \\|       _//   |   |\n//  |    |   \\|        \\ |    |   /    |    \\/        \\|   | |    |   /    |    \\    |   \\\\____   |\n//  |____|_  /_______  / |____|   \\_______  /_______  /|___| |____|   \\_______  /____|_  // ______|\n//         \\/        \\/                   \\/        \\/                        \\/       \\/ \\/\n\ntype CreateRepo struct {\n\tUserID      int64  `binding:\"Required\"`\n\tRepoName    string `binding:\"Required;AlphaDashDot;MaxSize(100)\"`\n\tPrivate     bool\n\tUnlisted    bool\n\tDescription string `binding:\"MaxSize(512)\"`\n\tAutoInit    bool\n\tGitignores  string\n\tLicense     string\n\tReadme      string\n}\n\nfunc (f *CreateRepo) Validate(ctx *macaron.Context, errs binding.Errors) binding.Errors {\n\treturn validate(errs, ctx.Data, f, ctx.Locale)\n}\n\ntype MigrateRepo struct {\n\tCloneAddr    string `json:\"clone_addr\" binding:\"Required\"`\n\tAuthUsername string `json:\"auth_username\"`\n\tAuthPassword string `json:\"auth_password\"`\n\tUid          int64  `json:\"uid\" binding:\"Required\"`\n\tRepoName     string `json:\"repo_name\" binding:\"Required;AlphaDashDot;MaxSize(100)\"`\n\tMirror       bool   `json:\"mirror\"`\n\tPrivate      bool   `json:\"private\"`\n\tUnlisted     bool   `json:\"unlisted\"`\n\tDescription  string `json:\"description\" binding:\"MaxSize(512)\"`\n}\n\nfunc (f *MigrateRepo) Validate(ctx *macaron.Context, errs binding.Errors) binding.Errors {\n\treturn validate(errs, ctx.Data, f, ctx.Locale)\n}\n\n// ParseRemoteAddr checks if given remote address is valid,\n// and returns composed URL with needed username and password.\n// It also checks if given user has permission when remote address\n// is actually a local path.\nfunc (f MigrateRepo) ParseRemoteAddr(user *db.User) (string, error) {\n\tremoteAddr := strings.TrimSpace(f.CloneAddr)\n\n\t// Remote address can be HTTP/HTTPS/Git URL or local path.\n\tif strings.HasPrefix(remoteAddr, \"http://\") ||\n\t\tstrings.HasPrefix(remoteAddr, \"https://\") ||\n\t\tstrings.HasPrefix(remoteAddr, \"git://\") {\n\t\tu, err := url.Parse(remoteAddr)\n\t\tif err != nil {\n\t\t\treturn \"\", db.ErrInvalidCloneAddr{IsURLError: true}\n\t\t}\n\n\t\tif netutil.IsBlockedLocalHostname(u.Hostname(), conf.Security.LocalNetworkAllowlist) {\n\t\t\treturn \"\", db.ErrInvalidCloneAddr{IsBlockedLocalAddress: true}\n\t\t}\n\n\t\tif len(f.AuthUsername)+len(f.AuthPassword) > 0 {\n\t\t\tu.User = url.UserPassword(f.AuthUsername, f.AuthPassword)\n\t\t}\n\t\t// To prevent CRLF injection in git protocol, see https://github.com/gogs/gogs/issues/6413\n\t\tif u.Scheme == \"git\" && (strings.Contains(remoteAddr, \"%0d\") || strings.Contains(remoteAddr, \"%0a\")) {\n\t\t\treturn \"\", db.ErrInvalidCloneAddr{IsURLError: true}\n\t\t}\n\t\tremoteAddr = u.String()\n\t} else if !user.CanImportLocal() {\n\t\treturn \"\", db.ErrInvalidCloneAddr{IsPermissionDenied: true}\n\t} else if !com.IsDir(remoteAddr) {\n\t\treturn \"\", db.ErrInvalidCloneAddr{IsInvalidPath: true}\n\t}\n\n\treturn remoteAddr, nil\n}\n\ntype RepoSetting struct {\n\tRepoName      string `binding:\"Required;AlphaDashDot;MaxSize(100)\"`\n\tDescription   string `binding:\"MaxSize(512)\"`\n\tWebsite       string `binding:\"Url;MaxSize(100)\"`\n\tBranch        string\n\tInterval      int\n\tMirrorAddress string\n\tPrivate       bool\n\tUnlisted      bool\n\tEnablePrune   bool\n\n\t// Advanced settings\n\tEnableWiki            bool\n\tAllowPublicWiki       bool\n\tEnableExternalWiki    bool\n\tExternalWikiURL       string\n\tEnableIssues          bool\n\tAllowPublicIssues     bool\n\tEnableExternalTracker bool\n\tExternalTrackerURL    string\n\tTrackerURLFormat      string\n\tTrackerIssueStyle     string\n\tEnablePulls           bool\n\tPullsIgnoreWhitespace bool\n\tPullsAllowRebase      bool\n}\n\nfunc (f *RepoSetting) Validate(ctx *macaron.Context, errs binding.Errors) binding.Errors {\n\treturn validate(errs, ctx.Data, f, ctx.Locale)\n}\n\n// __________                             .__\n// \\______   \\____________    ____   ____ |  |__\n//  |    |  _/\\_  __ \\__  \\  /    \\_/ ___\\|  |  \\\n//  |    |   \\ |  | \\// __ \\|   |  \\  \\___|   Y  \\\n//  |______  / |__|  (____  /___|  /\\___  >___|  /\n//         \\/             \\/     \\/     \\/     \\/\n\ntype ProtectBranch struct {\n\tProtected          bool\n\tRequirePullRequest bool\n\tEnableWhitelist    bool\n\tWhitelistUsers     string\n\tWhitelistTeams     string\n}\n\nfunc (f *ProtectBranch) Validate(ctx *macaron.Context, errs binding.Errors) binding.Errors {\n\treturn validate(errs, ctx.Data, f, ctx.Locale)\n}\n\n//  __      __      ___.   .__    .__            __\n// /  \\    /  \\ ____\\_ |__ |  |__ |  |__   ____ |  | __\n// \\   \\/\\/   // __ \\| __ \\|  |  \\|  |  \\ /  _ \\|  |/ /\n//  \\        /\\  ___/| \\_\\ \\   Y  \\   Y  (  <_> )    <\n//   \\__/\\  /  \\___  >___  /___|  /___|  /\\____/|__|_ \\\n//        \\/       \\/    \\/     \\/     \\/            \\/\n\ntype Webhook struct {\n\tEvents       string\n\tCreate       bool\n\tDelete       bool\n\tFork         bool\n\tPush         bool\n\tIssues       bool\n\tIssueComment bool\n\tPullRequest  bool\n\tRelease      bool\n\tActive       bool\n}\n\nfunc (f Webhook) PushOnly() bool {\n\treturn f.Events == \"push_only\"\n}\n\nfunc (f Webhook) SendEverything() bool {\n\treturn f.Events == \"send_everything\"\n}\n\nfunc (f Webhook) ChooseEvents() bool {\n\treturn f.Events == \"choose_events\"\n}\n\ntype NewWebhook struct {\n\tPayloadURL  string `binding:\"Required;Url\"`\n\tContentType int    `binding:\"Required\"`\n\tSecret      string\n\tWebhook\n}\n\nfunc (f *NewWebhook) Validate(ctx *macaron.Context, errs binding.Errors) binding.Errors {\n\treturn validate(errs, ctx.Data, f, ctx.Locale)\n}\n\ntype NewSlackHook struct {\n\tPayloadURL string `binding:\"Required;Url\"`\n\tChannel    string `binding:\"Required\"`\n\tUsername   string\n\tIconURL    string\n\tColor      string\n\tWebhook\n}\n\nfunc (f *NewSlackHook) Validate(ctx *macaron.Context, errs binding.Errors) binding.Errors {\n\treturn validate(errs, ctx.Data, f, ctx.Locale)\n}\n\ntype NewDiscordHook struct {\n\tPayloadURL string `binding:\"Required;Url\"`\n\tUsername   string\n\tIconURL    string\n\tColor      string\n\tWebhook\n}\n\nfunc (f *NewDiscordHook) Validate(ctx *macaron.Context, errs binding.Errors) binding.Errors {\n\treturn validate(errs, ctx.Data, f, ctx.Locale)\n}\n\ntype NewDingtalkHook struct {\n\tPayloadURL string `binding:\"Required;Url\"`\n\tWebhook\n}\n\nfunc (f *NewDingtalkHook) Validate(ctx *macaron.Context, errs binding.Errors) binding.Errors {\n\treturn validate(errs, ctx.Data, f, ctx.Locale)\n}\n\n// .___\n// |   | ______ ________ __   ____\n// |   |/  ___//  ___/  |  \\_/ __ \\\n// |   |\\___ \\ \\___ \\|  |  /\\  ___/\n// |___/____  >____  >____/  \\___  >\n//          \\/     \\/            \\/\n\ntype NewIssue struct {\n\tTitle       string `binding:\"Required;MaxSize(255)\"`\n\tLabelIDs    string `form:\"label_ids\"`\n\tMilestoneID int64\n\tAssigneeID  int64\n\tContent     string\n\tFiles       []string\n}\n\nfunc (f *NewIssue) Validate(ctx *macaron.Context, errs binding.Errors) binding.Errors {\n\treturn validate(errs, ctx.Data, f, ctx.Locale)\n}\n\ntype CreateComment struct {\n\tContent string\n\tStatus  string `binding:\"OmitEmpty;In(reopen,close)\"`\n\tFiles   []string\n}\n\nfunc (f *CreateComment) Validate(ctx *macaron.Context, errs binding.Errors) binding.Errors {\n\treturn validate(errs, ctx.Data, f, ctx.Locale)\n}\n\n//    _____  .__.__                   __\n//   /     \\ |__|  |   ____   _______/  |_  ____   ____   ____\n//  /  \\ /  \\|  |  | _/ __ \\ /  ___/\\   __\\/  _ \\ /    \\_/ __ \\\n// /    Y    \\  |  |_\\  ___/ \\___ \\  |  | (  <_> )   |  \\  ___/\n// \\____|__  /__|____/\\___  >____  > |__|  \\____/|___|  /\\___  >\n//         \\/             \\/     \\/                   \\/     \\/\n\ntype CreateMilestone struct {\n\tTitle    string `binding:\"Required;MaxSize(50)\"`\n\tContent  string\n\tDeadline string\n}\n\nfunc (f *CreateMilestone) Validate(ctx *macaron.Context, errs binding.Errors) binding.Errors {\n\treturn validate(errs, ctx.Data, f, ctx.Locale)\n}\n\n// .____          ___.          .__\n// |    |   _____ \\_ |__   ____ |  |\n// |    |   \\__  \\ | __ \\_/ __ \\|  |\n// |    |___ / __ \\| \\_\\ \\  ___/|  |__\n// |_______ (____  /___  /\\___  >____/\n//         \\/    \\/    \\/     \\/\n\ntype CreateLabel struct {\n\tID    int64\n\tTitle string `binding:\"Required;MaxSize(50)\" locale:\"repo.issues.label_title\"`\n\tColor string `binding:\"Required;Size(7)\" locale:\"repo.issues.label_color\"`\n}\n\nfunc (f *CreateLabel) Validate(ctx *macaron.Context, errs binding.Errors) binding.Errors {\n\treturn validate(errs, ctx.Data, f, ctx.Locale)\n}\n\ntype InitializeLabels struct {\n\tTemplateName string `binding:\"Required\"`\n}\n\nfunc (f *InitializeLabels) Validate(ctx *macaron.Context, errs binding.Errors) binding.Errors {\n\treturn validate(errs, ctx.Data, f, ctx.Locale)\n}\n\n// __________       .__\n// \\______   \\ ____ |  |   ____ _____    ______ ____\n//  |       _// __ \\|  | _/ __ \\\\__  \\  /  ___// __ \\\n//  |    |   \\  ___/|  |_\\  ___/ / __ \\_\\___ \\\\  ___/\n//  |____|_  /\\___  >____/\\___  >____  /____  >\\___  >\n//         \\/     \\/          \\/     \\/     \\/     \\/\n\ntype NewRelease struct {\n\tTagName    string `binding:\"Required\"`\n\tTarget     string `form:\"tag_target\" binding:\"Required\"`\n\tTitle      string `binding:\"Required\"`\n\tContent    string\n\tDraft      string\n\tPrerelease bool\n\tFiles      []string\n}\n\nfunc (f *NewRelease) Validate(ctx *macaron.Context, errs binding.Errors) binding.Errors {\n\treturn validate(errs, ctx.Data, f, ctx.Locale)\n}\n\ntype EditRelease struct {\n\tTitle      string `binding:\"Required\"`\n\tContent    string\n\tDraft      string\n\tPrerelease bool\n\tFiles      []string\n}\n\nfunc (f *EditRelease) Validate(ctx *macaron.Context, errs binding.Errors) binding.Errors {\n\treturn validate(errs, ctx.Data, f, ctx.Locale)\n}\n\n//  __      __.__ __   .__\n// /  \\    /  \\__|  | _|__|\n// \\   \\/\\/   /  |  |/ /  |\n//  \\        /|  |    <|  |\n//   \\__/\\  / |__|__|_ \\__|\n//        \\/          \\/\n\ntype NewWiki struct {\n\tOldTitle string\n\tTitle    string `binding:\"Required\"`\n\tContent  string `binding:\"Required\"`\n\tMessage  string\n}\n\n// FIXME: use code generation to generate this method.\nfunc (f *NewWiki) Validate(ctx *macaron.Context, errs binding.Errors) binding.Errors {\n\treturn validate(errs, ctx.Data, f, ctx.Locale)\n}\n\n// ___________    .___.__  __\n// \\_   _____/  __| _/|__|/  |_\n//  |    __)_  / __ | |  \\   __\\\n//  |        \\/ /_/ | |  ||  |\n// /_______  /\\____ | |__||__|\n//         \\/      \\/\n\ntype EditRepoFile struct {\n\tTreePath      string `binding:\"Required;MaxSize(500)\"`\n\tContent       string `binding:\"Required\"`\n\tCommitSummary string `binding:\"MaxSize(100)\"`\n\tCommitMessage string\n\tCommitChoice  string `binding:\"Required;MaxSize(50)\"`\n\tNewBranchName string `binding:\"AlphaDashDotSlash;MaxSize(100)\"`\n\tLastCommit    string\n}\n\nfunc (f *EditRepoFile) Validate(ctx *macaron.Context, errs binding.Errors) binding.Errors {\n\treturn validate(errs, ctx.Data, f, ctx.Locale)\n}\n\nfunc (f *EditRepoFile) IsNewBrnach() bool {\n\treturn f.CommitChoice == \"commit-to-new-branch\"\n}\n\ntype EditPreviewDiff struct {\n\tContent string\n}\n\nfunc (f *EditPreviewDiff) Validate(ctx *macaron.Context, errs binding.Errors) binding.Errors {\n\treturn validate(errs, ctx.Data, f, ctx.Locale)\n}\n\n//  ____ ___        .__                    .___\n// |    |   \\______ |  |   _________     __| _/\n// |    |   /\\____ \\|  |  /  _ \\__  \\   / __ |\n// |    |  / |  |_> >  |_(  <_> ) __ \\_/ /_/ |\n// |______/  |   __/|____/\\____(____  /\\____ |\n//           |__|                   \\/      \\/\n//\n\ntype UploadRepoFile struct {\n\tTreePath      string `binding:\"MaxSize(500)\"`\n\tCommitSummary string `binding:\"MaxSize(100)\"`\n\tCommitMessage string\n\tCommitChoice  string `binding:\"Required;MaxSize(50)\"`\n\tNewBranchName string `binding:\"AlphaDashDot;MaxSize(100)\"`\n\tFiles         []string\n}\n\nfunc (f *UploadRepoFile) Validate(ctx *macaron.Context, errs binding.Errors) binding.Errors {\n\treturn validate(errs, ctx.Data, f, ctx.Locale)\n}\n\nfunc (f *UploadRepoFile) IsNewBrnach() bool {\n\treturn f.CommitChoice == \"commit-to-new-branch\"\n}\n\ntype RemoveUploadFile struct {\n\tFile string `binding:\"Required;MaxSize(50)\"`\n}\n\nfunc (f *RemoveUploadFile) Validate(ctx *macaron.Context, errs binding.Errors) binding.Errors {\n\treturn validate(errs, ctx.Data, f, ctx.Locale)\n}\n\n// ________         .__          __\n// \\______ \\   ____ |  |   _____/  |_  ____\n// |    |  \\_/ __ \\|  | _/ __ \\   __\\/ __ \\\n// |    `   \\  ___/|  |_\\  ___/|  | \\  ___/\n// /_______  /\\___  >____/\\___  >__|  \\___  >\n//         \\/     \\/          \\/          \\/\n\ntype DeleteRepoFile struct {\n\tCommitSummary string `binding:\"MaxSize(100)\"`\n\tCommitMessage string\n\tCommitChoice  string `binding:\"Required;MaxSize(50)\"`\n\tNewBranchName string `binding:\"AlphaDashDot;MaxSize(100)\"`\n}\n\nfunc (f *DeleteRepoFile) Validate(ctx *macaron.Context, errs binding.Errors) binding.Errors {\n\treturn validate(errs, ctx.Data, f, ctx.Locale)\n}\n\nfunc (f *DeleteRepoFile) IsNewBrnach() bool {\n\treturn f.CommitChoice == \"commit-to-new-branch\"\n}\n", "// Copyright 2022 The Gogs Authors. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage netutil\n\nimport (\n\t\"fmt\"\n\t\"net\"\n)\n\nvar localCIDRs []*net.IPNet\n\nfunc init() {\n\t// Parsing hardcoded CIDR strings should never fail, if in case it does, let's\n\t// fail it at start.\n\trawCIDRs := []string{\n\t\t// https://datatracker.ietf.org/doc/html/rfc5735:\n\t\t\"127.0.0.0/8\",        // Loopback\n\t\t\"0.0.0.0/8\",          // \"This\" network\n\t\t\"100.64.0.0/10\",      // Shared address space\n\t\t\"169.254.0.0/16\",     // Link local\n\t\t\"172.16.0.0/12\",      // Private-use networks\n\t\t\"192.0.0.0/24\",       // IETF Protocol assignments\n\t\t\"192.0.2.0/24\",       // TEST-NET-1\n\t\t\"192.88.99.0/24\",     // 6to4 Relay anycast\n\t\t\"192.168.0.0/16\",     // Private-use networks\n\t\t\"198.18.0.0/15\",      // Network interconnect\n\t\t\"198.51.100.0/24\",    // TEST-NET-2\n\t\t\"203.0.113.0/24\",     // TEST-NET-3\n\t\t\"255.255.255.255/32\", // Limited broadcast\n\n\t\t// https://datatracker.ietf.org/doc/html/rfc1918:\n\t\t\"10.0.0.0/8\", // Private-use networks\n\n\t\t// https://datatracker.ietf.org/doc/html/rfc6890:\n\t\t\"::1/128\",   // Loopback\n\t\t\"FC00::/7\",  // Unique local address\n\t\t\"FE80::/10\", // Multicast address\n\t}\n\tfor _, raw := range rawCIDRs {\n\t\t_, cidr, err := net.ParseCIDR(raw)\n\t\tif err != nil {\n\t\t\tpanic(fmt.Sprintf(\"parse CIDR %q: %v\", raw, err))\n\t\t}\n\t\tlocalCIDRs = append(localCIDRs, cidr)\n\t}\n}\n\n// IsBlockedLocalHostname returns true if given hostname is resolved to a local\n// network address that is implicitly blocked (i.e. not exempted from the\n// allowlist).\nfunc IsBlockedLocalHostname(hostname string, allowlist []string) bool {\n\tfor _, allow := range allowlist {\n\t\tif hostname == allow {\n\t\t\treturn false\n\t\t}\n\t}\n\n\tips, err := net.LookupIP(hostname)\n\tif err != nil {\n\t\treturn true\n\t}\n\tfor _, ip := range ips {\n\t\tfor _, cidr := range localCIDRs {\n\t\t\tif cidr.Contains(ip) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n", "// Copyright 2022 The Gogs Authors. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage netutil\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestIsLocalHostname(t *testing.T) {\n\ttests := []struct {\n\t\thostname  string\n\t\tallowlist []string\n\t\twant      bool\n\t}{\n\t\t{hostname: \"localhost\", want: true},       // #00\n\t\t{hostname: \"127.0.0.1\", want: true},       // #01\n\t\t{hostname: \"::1\", want: true},             // #02\n\t\t{hostname: \"0:0:0:0:0:0:0:1\", want: true}, // #03\n\t\t{hostname: \"fuf.me\", want: true},          // #04\n\t\t{hostname: \"127.0.0.95\", want: true},      // #05\n\t\t{hostname: \"0.0.0.0\", want: true},         // #06\n\t\t{hostname: \"192.168.123.45\", want: true},  // #07\n\n\t\t{hostname: \"gogs.io\", want: false},         // #08\n\t\t{hostname: \"google.com\", want: false},      // #09\n\t\t{hostname: \"165.232.140.255\", want: false}, // #10\n\n\t\t{hostname: \"192.168.123.45\", allowlist: []string{\"10.0.0.17\"}, want: true}, // #11\n\t\t{hostname: \"gogs.local\", allowlist: []string{\"gogs.local\"}, want: false},   // #12\n\t}\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tassert.Equal(t, test.want, IsBlockedLocalHostname(test.hostname, test.allowlist))\n\t\t})\n\t}\n}\n", "// Copyright 2014 The Gogs Authors. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage repo\n\nimport (\n\t\"net/http\"\n\t\"path\"\n\n\tapi \"github.com/gogs/go-gogs-client\"\n\t\"github.com/pkg/errors\"\n\tlog \"unknwon.dev/clog/v2\"\n\n\t\"gogs.io/gogs/internal/conf\"\n\t\"gogs.io/gogs/internal/context\"\n\t\"gogs.io/gogs/internal/db\"\n\t\"gogs.io/gogs/internal/form\"\n\t\"gogs.io/gogs/internal/route/api/v1/convert\"\n)\n\nfunc Search(c *context.APIContext) {\n\topts := &db.SearchRepoOptions{\n\t\tKeyword:  path.Base(c.Query(\"q\")),\n\t\tOwnerID:  c.QueryInt64(\"uid\"),\n\t\tPageSize: convert.ToCorrectPageSize(c.QueryInt(\"limit\")),\n\t\tPage:     c.QueryInt(\"page\"),\n\t}\n\n\t// Check visibility.\n\tif c.IsLogged && opts.OwnerID > 0 {\n\t\tif c.User.ID == opts.OwnerID {\n\t\t\topts.Private = true\n\t\t} else {\n\t\t\tu, err := db.GetUserByID(opts.OwnerID)\n\t\t\tif err != nil {\n\t\t\t\tc.JSON(http.StatusInternalServerError, map[string]interface{}{\n\t\t\t\t\t\"ok\":    false,\n\t\t\t\t\t\"error\": err.Error(),\n\t\t\t\t})\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif u.IsOrganization() && u.IsOwnedBy(c.User.ID) {\n\t\t\t\topts.Private = true\n\t\t\t}\n\t\t\t// FIXME: how about collaborators?\n\t\t}\n\t}\n\n\trepos, count, err := db.SearchRepositoryByName(opts)\n\tif err != nil {\n\t\tc.JSON(http.StatusInternalServerError, map[string]interface{}{\n\t\t\t\"ok\":    false,\n\t\t\t\"error\": err.Error(),\n\t\t})\n\t\treturn\n\t}\n\n\tif err = db.RepositoryList(repos).LoadAttributes(); err != nil {\n\t\tc.JSON(http.StatusInternalServerError, map[string]interface{}{\n\t\t\t\"ok\":    false,\n\t\t\t\"error\": err.Error(),\n\t\t})\n\t\treturn\n\t}\n\n\tresults := make([]*api.Repository, len(repos))\n\tfor i := range repos {\n\t\tresults[i] = repos[i].APIFormat(nil)\n\t}\n\n\tc.SetLinkHeader(int(count), opts.PageSize)\n\tc.JSONSuccess(map[string]interface{}{\n\t\t\"ok\":   true,\n\t\t\"data\": results,\n\t})\n}\n\nfunc listUserRepositories(c *context.APIContext, username string) {\n\tuser, err := db.GetUserByName(username)\n\tif err != nil {\n\t\tc.NotFoundOrError(err, \"get user by name\")\n\t\treturn\n\t}\n\n\t// Only list public repositories if user requests someone else's repository list,\n\t// or an organization isn't a member of.\n\tvar ownRepos []*db.Repository\n\tif user.IsOrganization() {\n\t\townRepos, _, err = user.GetUserRepositories(c.User.ID, 1, user.NumRepos)\n\t} else {\n\t\townRepos, err = db.GetUserRepositories(&db.UserRepoOptions{\n\t\t\tUserID:   user.ID,\n\t\t\tPrivate:  c.User.ID == user.ID,\n\t\t\tPage:     1,\n\t\t\tPageSize: user.NumRepos,\n\t\t})\n\t}\n\tif err != nil {\n\t\tc.Error(err, \"get user repositories\")\n\t\treturn\n\t}\n\n\tif err = db.RepositoryList(ownRepos).LoadAttributes(); err != nil {\n\t\tc.Error(err, \"load attributes\")\n\t\treturn\n\t}\n\n\t// Early return for querying other user's repositories\n\tif c.User.ID != user.ID {\n\t\trepos := make([]*api.Repository, len(ownRepos))\n\t\tfor i := range ownRepos {\n\t\t\trepos[i] = ownRepos[i].APIFormat(&api.Permission{Admin: true, Push: true, Pull: true})\n\t\t}\n\t\tc.JSONSuccess(&repos)\n\t\treturn\n\t}\n\n\taccessibleRepos, err := user.GetRepositoryAccesses()\n\tif err != nil {\n\t\tc.Error(err, \"get repositories accesses\")\n\t\treturn\n\t}\n\n\tnumOwnRepos := len(ownRepos)\n\trepos := make([]*api.Repository, numOwnRepos+len(accessibleRepos))\n\tfor i := range ownRepos {\n\t\trepos[i] = ownRepos[i].APIFormat(&api.Permission{Admin: true, Push: true, Pull: true})\n\t}\n\n\ti := numOwnRepos\n\tfor repo, access := range accessibleRepos {\n\t\trepos[i] = repo.APIFormat(&api.Permission{\n\t\t\tAdmin: access >= db.AccessModeAdmin,\n\t\t\tPush:  access >= db.AccessModeWrite,\n\t\t\tPull:  true,\n\t\t})\n\t\ti++\n\t}\n\n\tc.JSONSuccess(&repos)\n}\n\nfunc ListMyRepos(c *context.APIContext) {\n\tlistUserRepositories(c, c.User.Name)\n}\n\nfunc ListUserRepositories(c *context.APIContext) {\n\tlistUserRepositories(c, c.Params(\":username\"))\n}\n\nfunc ListOrgRepositories(c *context.APIContext) {\n\tlistUserRepositories(c, c.Params(\":org\"))\n}\n\nfunc CreateUserRepo(c *context.APIContext, owner *db.User, opt api.CreateRepoOption) {\n\trepo, err := db.CreateRepository(c.User, owner, db.CreateRepoOptions{\n\t\tName:        opt.Name,\n\t\tDescription: opt.Description,\n\t\tGitignores:  opt.Gitignores,\n\t\tLicense:     opt.License,\n\t\tReadme:      opt.Readme,\n\t\tIsPrivate:   opt.Private,\n\t\tAutoInit:    opt.AutoInit,\n\t})\n\tif err != nil {\n\t\tif db.IsErrRepoAlreadyExist(err) ||\n\t\t\tdb.IsErrNameNotAllowed(err) {\n\t\t\tc.ErrorStatus(http.StatusUnprocessableEntity, err)\n\t\t} else {\n\t\t\tif repo != nil {\n\t\t\t\tif err = db.DeleteRepository(c.User.ID, repo.ID); err != nil {\n\t\t\t\t\tlog.Error(\"Failed to delete repository: %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tc.Error(err, \"create repository\")\n\t\t}\n\t\treturn\n\t}\n\n\tc.JSON(201, repo.APIFormat(&api.Permission{Admin: true, Push: true, Pull: true}))\n}\n\nfunc Create(c *context.APIContext, opt api.CreateRepoOption) {\n\t// Shouldn't reach this condition, but just in case.\n\tif c.User.IsOrganization() {\n\t\tc.ErrorStatus(http.StatusUnprocessableEntity, errors.New(\"Not allowed to create repository for organization.\"))\n\t\treturn\n\t}\n\tCreateUserRepo(c, c.User, opt)\n}\n\nfunc CreateOrgRepo(c *context.APIContext, opt api.CreateRepoOption) {\n\torg, err := db.GetOrgByName(c.Params(\":org\"))\n\tif err != nil {\n\t\tc.NotFoundOrError(err, \"get organization by name\")\n\t\treturn\n\t}\n\n\tif !org.IsOwnedBy(c.User.ID) {\n\t\tc.ErrorStatus(http.StatusForbidden, errors.New(\"Given user is not owner of organization.\"))\n\t\treturn\n\t}\n\tCreateUserRepo(c, org, opt)\n}\n\nfunc Migrate(c *context.APIContext, f form.MigrateRepo) {\n\tctxUser := c.User\n\t// Not equal means context user is an organization,\n\t// or is another user/organization if current user is admin.\n\tif f.Uid != ctxUser.ID {\n\t\torg, err := db.GetUserByID(f.Uid)\n\t\tif err != nil {\n\t\t\tif db.IsErrUserNotExist(err) {\n\t\t\t\tc.ErrorStatus(http.StatusUnprocessableEntity, err)\n\t\t\t} else {\n\t\t\t\tc.Error(err, \"get user by ID\")\n\t\t\t}\n\t\t\treturn\n\t\t} else if !org.IsOrganization() && !c.User.IsAdmin {\n\t\t\tc.ErrorStatus(http.StatusForbidden, errors.New(\"Given user is not an organization.\"))\n\t\t\treturn\n\t\t}\n\t\tctxUser = org\n\t}\n\n\tif c.HasError() {\n\t\tc.ErrorStatus(http.StatusUnprocessableEntity, errors.New(c.GetErrMsg()))\n\t\treturn\n\t}\n\n\tif ctxUser.IsOrganization() && !c.User.IsAdmin {\n\t\t// Check ownership of organization.\n\t\tif !ctxUser.IsOwnedBy(c.User.ID) {\n\t\t\tc.ErrorStatus(http.StatusForbidden, errors.New(\"Given user is not owner of organization.\"))\n\t\t\treturn\n\t\t}\n\t}\n\n\tremoteAddr, err := f.ParseRemoteAddr(c.User)\n\tif err != nil {\n\t\tif db.IsErrInvalidCloneAddr(err) {\n\t\t\taddrErr := err.(db.ErrInvalidCloneAddr)\n\t\t\tswitch {\n\t\t\tcase addrErr.IsURLError:\n\t\t\t\tc.ErrorStatus(http.StatusUnprocessableEntity, err)\n\t\t\tcase addrErr.IsPermissionDenied:\n\t\t\t\tc.ErrorStatus(http.StatusUnprocessableEntity, errors.New(\"You are not allowed to import local repositories.\"))\n\t\t\tcase addrErr.IsInvalidPath:\n\t\t\t\tc.ErrorStatus(http.StatusUnprocessableEntity, errors.New(\"Invalid local path, it does not exist or not a directory.\"))\n\t\t\tcase addrErr.IsBlockedLocalAddress:\n\t\t\t\tc.ErrorStatus(http.StatusUnprocessableEntity, errors.New(\"Clone address resolved to a local network address that is implicitly blocked.\"))\n\t\t\tdefault:\n\t\t\t\tc.Error(err, \"unexpected error\")\n\t\t\t}\n\t\t} else {\n\t\t\tc.Error(err, \"parse remote address\")\n\t\t}\n\t\treturn\n\t}\n\n\trepo, err := db.MigrateRepository(c.User, ctxUser, db.MigrateRepoOptions{\n\t\tName:        f.RepoName,\n\t\tDescription: f.Description,\n\t\tIsPrivate:   f.Private || conf.Repository.ForcePrivate,\n\t\tIsMirror:    f.Mirror,\n\t\tRemoteAddr:  remoteAddr,\n\t})\n\tif err != nil {\n\t\tif repo != nil {\n\t\t\tif errDelete := db.DeleteRepository(ctxUser.ID, repo.ID); errDelete != nil {\n\t\t\t\tlog.Error(\"DeleteRepository: %v\", errDelete)\n\t\t\t}\n\t\t}\n\n\t\tif db.IsErrReachLimitOfRepo(err) {\n\t\t\tc.ErrorStatus(http.StatusUnprocessableEntity, err)\n\t\t} else {\n\t\t\tc.Error(errors.New(db.HandleMirrorCredentials(err.Error(), true)), \"migrate repository\")\n\t\t}\n\t\treturn\n\t}\n\n\tlog.Trace(\"Repository migrated: %s/%s\", ctxUser.Name, f.RepoName)\n\tc.JSON(201, repo.APIFormat(&api.Permission{Admin: true, Push: true, Pull: true}))\n}\n\n// FIXME: inject in the handler chain\nfunc parseOwnerAndRepo(c *context.APIContext) (*db.User, *db.Repository) {\n\towner, err := db.GetUserByName(c.Params(\":username\"))\n\tif err != nil {\n\t\tif db.IsErrUserNotExist(err) {\n\t\t\tc.ErrorStatus(http.StatusUnprocessableEntity, err)\n\t\t} else {\n\t\t\tc.Error(err, \"get user by name\")\n\t\t}\n\t\treturn nil, nil\n\t}\n\n\trepo, err := db.GetRepositoryByName(owner.ID, c.Params(\":reponame\"))\n\tif err != nil {\n\t\tc.NotFoundOrError(err, \"get repository by name\")\n\t\treturn nil, nil\n\t}\n\n\treturn owner, repo\n}\n\nfunc Get(c *context.APIContext) {\n\t_, repo := parseOwnerAndRepo(c)\n\tif c.Written() {\n\t\treturn\n\t}\n\n\tc.JSONSuccess(repo.APIFormat(&api.Permission{\n\t\tAdmin: c.Repo.IsAdmin(),\n\t\tPush:  c.Repo.IsWriter(),\n\t\tPull:  true,\n\t}))\n}\n\nfunc Delete(c *context.APIContext) {\n\towner, repo := parseOwnerAndRepo(c)\n\tif c.Written() {\n\t\treturn\n\t}\n\n\tif owner.IsOrganization() && !owner.IsOwnedBy(c.User.ID) {\n\t\tc.ErrorStatus(http.StatusForbidden, errors.New(\"Given user is not owner of organization.\"))\n\t\treturn\n\t}\n\n\tif err := db.DeleteRepository(owner.ID, repo.ID); err != nil {\n\t\tc.Error(err, \"delete repository\")\n\t\treturn\n\t}\n\n\tlog.Trace(\"Repository deleted: %s/%s\", owner.Name, repo.Name)\n\tc.NoContent()\n}\n\nfunc ListForks(c *context.APIContext) {\n\tforks, err := c.Repo.Repository.GetForks()\n\tif err != nil {\n\t\tc.Error(err, \"get forks\")\n\t\treturn\n\t}\n\n\tapiForks := make([]*api.Repository, len(forks))\n\tfor i := range forks {\n\t\tif err := forks[i].GetOwner(); err != nil {\n\t\t\tc.Error(err, \"get owner\")\n\t\t\treturn\n\t\t}\n\t\tapiForks[i] = forks[i].APIFormat(&api.Permission{\n\t\t\tAdmin: c.User.IsAdminOfRepo(forks[i]),\n\t\t\tPush:  c.User.IsWriterOfRepo(forks[i]),\n\t\t\tPull:  true,\n\t\t})\n\t}\n\n\tc.JSONSuccess(&apiForks)\n}\n\nfunc IssueTracker(c *context.APIContext, form api.EditIssueTrackerOption) {\n\t_, repo := parseOwnerAndRepo(c)\n\tif c.Written() {\n\t\treturn\n\t}\n\n\tif form.EnableIssues != nil {\n\t\trepo.EnableIssues = *form.EnableIssues\n\t}\n\tif form.EnableExternalTracker != nil {\n\t\trepo.EnableExternalTracker = *form.EnableExternalTracker\n\t}\n\tif form.ExternalTrackerURL != nil {\n\t\trepo.ExternalTrackerURL = *form.ExternalTrackerURL\n\t}\n\tif form.TrackerURLFormat != nil {\n\t\trepo.ExternalTrackerFormat = *form.TrackerURLFormat\n\t}\n\tif form.TrackerIssueStyle != nil {\n\t\trepo.ExternalTrackerStyle = *form.TrackerIssueStyle\n\t}\n\n\tif err := db.UpdateRepository(repo, false); err != nil {\n\t\tc.Error(err, \"update repository\")\n\t\treturn\n\t}\n\n\tc.NoContent()\n}\n\nfunc Wiki(c *context.APIContext, form api.EditWikiOption) {\n\t_, repo := parseOwnerAndRepo(c)\n\tif c.Written() {\n\t\treturn\n\t}\n\n\tif form.AllowPublicWiki != nil {\n\t\trepo.AllowPublicWiki = *form.AllowPublicWiki\n\t}\n\tif form.EnableExternalWiki != nil {\n\t\trepo.EnableExternalWiki = *form.EnableExternalWiki\n\t}\n\tif form.EnableWiki != nil {\n\t\trepo.EnableWiki = *form.EnableWiki\n\t}\n\tif form.ExternalWikiURL != nil {\n\t\trepo.ExternalWikiURL = *form.ExternalWikiURL\n\t}\n\tif err := db.UpdateRepository(repo, false); err != nil {\n\t\tc.Error(err, \"update repository\")\n\t\treturn\n\t}\n\n\tc.NoContent()\n}\n\nfunc MirrorSync(c *context.APIContext) {\n\t_, repo := parseOwnerAndRepo(c)\n\tif c.Written() {\n\t\treturn\n\t} else if !repo.IsMirror {\n\t\tc.NotFound()\n\t\treturn\n\t}\n\n\tgo db.MirrorQueue.Add(repo.ID)\n\tc.Status(http.StatusAccepted)\n}\n\nfunc Releases(c *context.APIContext) {\n\t_, repo := parseOwnerAndRepo(c)\n\treleases, err := db.GetReleasesByRepoID(repo.ID)\n\tif err != nil {\n\t\tc.Error(err, \"get releases by repository ID\")\n\t\treturn\n\t}\n\tapiReleases := make([]*api.Release, 0, len(releases))\n\tfor _, r := range releases {\n\t\tpublisher, err := db.GetUserByID(r.PublisherID)\n\t\tif err != nil {\n\t\t\tc.Error(err, \"get release publisher\")\n\t\t\treturn\n\t\t}\n\t\tr.Publisher = publisher\n\t}\n\tfor _, r := range releases {\n\t\tapiReleases = append(apiReleases, r.APIFormat())\n\t}\n\n\tc.JSONSuccess(&apiReleases)\n}\n", "// Copyright 2014 The Gogs Authors. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage repo\n\nimport (\n\t\"net/http\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/unknwon/com\"\n\tlog \"unknwon.dev/clog/v2\"\n\n\t\"github.com/gogs/git-module\"\n\n\t\"gogs.io/gogs/internal/conf\"\n\t\"gogs.io/gogs/internal/context\"\n\t\"gogs.io/gogs/internal/db\"\n\t\"gogs.io/gogs/internal/form\"\n\t\"gogs.io/gogs/internal/tool\"\n)\n\nconst (\n\tCREATE  = \"repo/create\"\n\tMIGRATE = \"repo/migrate\"\n)\n\nfunc MustBeNotBare(c *context.Context) {\n\tif c.Repo.Repository.IsBare {\n\t\tc.NotFound()\n\t}\n}\n\nfunc checkContextUser(c *context.Context, uid int64) *db.User {\n\torgs, err := db.GetOwnedOrgsByUserIDDesc(c.User.ID, \"updated_unix\")\n\tif err != nil {\n\t\tc.Error(err, \"get owned organization by user ID\")\n\t\treturn nil\n\t}\n\tc.Data[\"Orgs\"] = orgs\n\n\t// Not equal means current user is an organization.\n\tif uid == c.User.ID || uid == 0 {\n\t\treturn c.User\n\t}\n\n\torg, err := db.GetUserByID(uid)\n\tif db.IsErrUserNotExist(err) {\n\t\treturn c.User\n\t}\n\n\tif err != nil {\n\t\tc.Error(err, \"get user by ID\")\n\t\treturn nil\n\t}\n\n\t// Check ownership of organization.\n\tif !org.IsOrganization() || !(c.User.IsAdmin || org.IsOwnedBy(c.User.ID)) {\n\t\tc.Status(http.StatusForbidden)\n\t\treturn nil\n\t}\n\treturn org\n}\n\nfunc Create(c *context.Context) {\n\tc.Title(\"new_repo\")\n\tc.RequireAutosize()\n\n\t// Give default value for template to render.\n\tc.Data[\"Gitignores\"] = db.Gitignores\n\tc.Data[\"Licenses\"] = db.Licenses\n\tc.Data[\"Readmes\"] = db.Readmes\n\tc.Data[\"readme\"] = \"Default\"\n\tc.Data[\"private\"] = c.User.LastRepoVisibility\n\tc.Data[\"IsForcedPrivate\"] = conf.Repository.ForcePrivate\n\n\tctxUser := checkContextUser(c, c.QueryInt64(\"org\"))\n\tif c.Written() {\n\t\treturn\n\t}\n\tc.Data[\"ContextUser\"] = ctxUser\n\n\tc.Success(CREATE)\n}\n\nfunc handleCreateError(c *context.Context, owner *db.User, err error, name, tpl string, form interface{}) {\n\tswitch {\n\tcase db.IsErrReachLimitOfRepo(err):\n\t\tc.RenderWithErr(c.Tr(\"repo.form.reach_limit_of_creation\", owner.RepoCreationNum()), tpl, form)\n\tcase db.IsErrRepoAlreadyExist(err):\n\t\tc.Data[\"Err_RepoName\"] = true\n\t\tc.RenderWithErr(c.Tr(\"form.repo_name_been_taken\"), tpl, form)\n\tcase db.IsErrNameNotAllowed(err):\n\t\tc.Data[\"Err_RepoName\"] = true\n\t\tc.RenderWithErr(c.Tr(\"repo.form.name_not_allowed\", err.(db.ErrNameNotAllowed).Value()), tpl, form)\n\tdefault:\n\t\tc.Error(err, name)\n\t}\n}\n\nfunc CreatePost(c *context.Context, f form.CreateRepo) {\n\tc.Data[\"Title\"] = c.Tr(\"new_repo\")\n\n\tc.Data[\"Gitignores\"] = db.Gitignores\n\tc.Data[\"Licenses\"] = db.Licenses\n\tc.Data[\"Readmes\"] = db.Readmes\n\n\tctxUser := checkContextUser(c, f.UserID)\n\tif c.Written() {\n\t\treturn\n\t}\n\tc.Data[\"ContextUser\"] = ctxUser\n\n\tif c.HasError() {\n\t\tc.Success(CREATE)\n\t\treturn\n\t}\n\n\trepo, err := db.CreateRepository(c.User, ctxUser, db.CreateRepoOptions{\n\t\tName:        f.RepoName,\n\t\tDescription: f.Description,\n\t\tGitignores:  f.Gitignores,\n\t\tLicense:     f.License,\n\t\tReadme:      f.Readme,\n\t\tIsPrivate:   f.Private || conf.Repository.ForcePrivate,\n\t\tIsUnlisted:  f.Unlisted,\n\t\tAutoInit:    f.AutoInit,\n\t})\n\tif err == nil {\n\t\tlog.Trace(\"Repository created [%d]: %s/%s\", repo.ID, ctxUser.Name, repo.Name)\n\t\tc.Redirect(conf.Server.Subpath + \"/\" + ctxUser.Name + \"/\" + repo.Name)\n\t\treturn\n\t}\n\n\tif repo != nil {\n\t\tif errDelete := db.DeleteRepository(ctxUser.ID, repo.ID); errDelete != nil {\n\t\t\tlog.Error(\"DeleteRepository: %v\", errDelete)\n\t\t}\n\t}\n\n\thandleCreateError(c, ctxUser, err, \"CreatePost\", CREATE, &f)\n}\n\nfunc Migrate(c *context.Context) {\n\tc.Data[\"Title\"] = c.Tr(\"new_migrate\")\n\tc.Data[\"private\"] = c.User.LastRepoVisibility\n\tc.Data[\"IsForcedPrivate\"] = conf.Repository.ForcePrivate\n\tc.Data[\"mirror\"] = c.Query(\"mirror\") == \"1\"\n\n\tctxUser := checkContextUser(c, c.QueryInt64(\"org\"))\n\tif c.Written() {\n\t\treturn\n\t}\n\tc.Data[\"ContextUser\"] = ctxUser\n\n\tc.Success(MIGRATE)\n}\n\nfunc MigratePost(c *context.Context, f form.MigrateRepo) {\n\tc.Data[\"Title\"] = c.Tr(\"new_migrate\")\n\n\tctxUser := checkContextUser(c, f.Uid)\n\tif c.Written() {\n\t\treturn\n\t}\n\tc.Data[\"ContextUser\"] = ctxUser\n\n\tif c.HasError() {\n\t\tc.Success(MIGRATE)\n\t\treturn\n\t}\n\n\tremoteAddr, err := f.ParseRemoteAddr(c.User)\n\tif err != nil {\n\t\tif db.IsErrInvalidCloneAddr(err) {\n\t\t\tc.Data[\"Err_CloneAddr\"] = true\n\t\t\taddrErr := err.(db.ErrInvalidCloneAddr)\n\t\t\tswitch {\n\t\t\tcase addrErr.IsURLError:\n\t\t\t\tc.RenderWithErr(c.Tr(\"repo.migrate.clone_address\")+c.Tr(\"form.url_error\"), MIGRATE, &f)\n\t\t\tcase addrErr.IsPermissionDenied:\n\t\t\t\tc.RenderWithErr(c.Tr(\"repo.migrate.permission_denied\"), MIGRATE, &f)\n\t\t\tcase addrErr.IsInvalidPath:\n\t\t\t\tc.RenderWithErr(c.Tr(\"repo.migrate.invalid_local_path\"), MIGRATE, &f)\n\t\t\tcase addrErr.IsBlockedLocalAddress:\n\t\t\t\tc.RenderWithErr(c.Tr(\"repo.migrate.clone_address_resolved_to_blocked_local_address\"), MIGRATE, &f)\n\t\t\tdefault:\n\t\t\t\tc.Error(err, \"unexpected error\")\n\t\t\t}\n\t\t} else {\n\t\t\tc.Error(err, \"parse remote address\")\n\t\t}\n\t\treturn\n\t}\n\n\trepo, err := db.MigrateRepository(c.User, ctxUser, db.MigrateRepoOptions{\n\t\tName:        f.RepoName,\n\t\tDescription: f.Description,\n\t\tIsPrivate:   f.Private || conf.Repository.ForcePrivate,\n\t\tIsUnlisted:  f.Unlisted,\n\t\tIsMirror:    f.Mirror,\n\t\tRemoteAddr:  remoteAddr,\n\t})\n\tif err == nil {\n\t\tlog.Trace(\"Repository migrated [%d]: %s/%s\", repo.ID, ctxUser.Name, f.RepoName)\n\t\tc.Redirect(conf.Server.Subpath + \"/\" + ctxUser.Name + \"/\" + f.RepoName)\n\t\treturn\n\t}\n\n\tif repo != nil {\n\t\tif errDelete := db.DeleteRepository(ctxUser.ID, repo.ID); errDelete != nil {\n\t\t\tlog.Error(\"DeleteRepository: %v\", errDelete)\n\t\t}\n\t}\n\n\tif strings.Contains(err.Error(), \"Authentication failed\") ||\n\t\tstrings.Contains(err.Error(), \"could not read Username\") {\n\t\tc.Data[\"Err_Auth\"] = true\n\t\tc.RenderWithErr(c.Tr(\"form.auth_failed\", db.HandleMirrorCredentials(err.Error(), true)), MIGRATE, &f)\n\t\treturn\n\t} else if strings.Contains(err.Error(), \"fatal:\") {\n\t\tc.Data[\"Err_CloneAddr\"] = true\n\t\tc.RenderWithErr(c.Tr(\"repo.migrate.failed\", db.HandleMirrorCredentials(err.Error(), true)), MIGRATE, &f)\n\t\treturn\n\t}\n\n\thandleCreateError(c, ctxUser, err, \"MigratePost\", MIGRATE, &f)\n}\n\nfunc Action(c *context.Context) {\n\tvar err error\n\tswitch c.Params(\":action\") {\n\tcase \"watch\":\n\t\terr = db.WatchRepo(c.User.ID, c.Repo.Repository.ID, true)\n\tcase \"unwatch\":\n\t\tif userID := c.QueryInt64(\"user_id\"); userID != 0 {\n\t\t\tif c.User.IsAdmin {\n\t\t\t\terr = db.WatchRepo(userID, c.Repo.Repository.ID, false)\n\t\t\t}\n\t\t} else {\n\t\t\terr = db.WatchRepo(c.User.ID, c.Repo.Repository.ID, false)\n\t\t}\n\tcase \"star\":\n\t\terr = db.StarRepo(c.User.ID, c.Repo.Repository.ID, true)\n\tcase \"unstar\":\n\t\terr = db.StarRepo(c.User.ID, c.Repo.Repository.ID, false)\n\tcase \"desc\": // FIXME: this is not used\n\t\tif !c.Repo.IsOwner() {\n\t\t\tc.NotFound()\n\t\t\treturn\n\t\t}\n\n\t\tc.Repo.Repository.Description = c.Query(\"desc\")\n\t\tc.Repo.Repository.Website = c.Query(\"site\")\n\t\terr = db.UpdateRepository(c.Repo.Repository, false)\n\t}\n\n\tif err != nil {\n\t\tc.Errorf(err, \"action %q\", c.Params(\":action\"))\n\t\treturn\n\t}\n\n\tredirectTo := c.Query(\"redirect_to\")\n\tif !tool.IsSameSiteURLPath(redirectTo) {\n\t\tredirectTo = c.Repo.RepoLink\n\t}\n\tc.Redirect(redirectTo)\n}\n\nfunc Download(c *context.Context) {\n\tvar (\n\t\turi           = c.Params(\"*\")\n\t\trefName       string\n\t\text           string\n\t\tarchivePath   string\n\t\tarchiveFormat git.ArchiveFormat\n\t)\n\n\tswitch {\n\tcase strings.HasSuffix(uri, \".zip\"):\n\t\text = \".zip\"\n\t\tarchivePath = filepath.Join(c.Repo.GitRepo.Path(), \"archives\", \"zip\")\n\t\tarchiveFormat = git.ArchiveZip\n\tcase strings.HasSuffix(uri, \".tar.gz\"):\n\t\text = \".tar.gz\"\n\t\tarchivePath = filepath.Join(c.Repo.GitRepo.Path(), \"archives\", \"targz\")\n\t\tarchiveFormat = git.ArchiveTarGz\n\tdefault:\n\t\tlog.Trace(\"Unknown format: %s\", uri)\n\t\tc.NotFound()\n\t\treturn\n\t}\n\trefName = strings.TrimSuffix(uri, ext)\n\n\tif !com.IsDir(archivePath) {\n\t\tif err := os.MkdirAll(archivePath, os.ModePerm); err != nil {\n\t\t\tc.Error(err, \"create archive directory\")\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Get corresponding commit.\n\tvar (\n\t\tcommit *git.Commit\n\t\terr    error\n\t)\n\tgitRepo := c.Repo.GitRepo\n\tif gitRepo.HasBranch(refName) {\n\t\tcommit, err = gitRepo.BranchCommit(refName)\n\t\tif err != nil {\n\t\t\tc.Error(err, \"get branch commit\")\n\t\t\treturn\n\t\t}\n\t} else if gitRepo.HasTag(refName) {\n\t\tcommit, err = gitRepo.TagCommit(refName)\n\t\tif err != nil {\n\t\t\tc.Error(err, \"get tag commit\")\n\t\t\treturn\n\t\t}\n\t} else if len(refName) >= 7 && len(refName) <= 40 {\n\t\tcommit, err = gitRepo.CatFileCommit(refName)\n\t\tif err != nil {\n\t\t\tc.NotFound()\n\t\t\treturn\n\t\t}\n\t} else {\n\t\tc.NotFound()\n\t\treturn\n\t}\n\n\tarchivePath = path.Join(archivePath, tool.ShortSHA1(commit.ID.String())+ext)\n\tif !com.IsFile(archivePath) {\n\t\tif err := commit.CreateArchive(archiveFormat, archivePath); err != nil {\n\t\t\tc.Error(err, \"creates archive\")\n\t\t\treturn\n\t\t}\n\t}\n\n\tc.ServeFile(archivePath, c.Repo.Repository.Name+\"-\"+refName+ext)\n}\n", "// Copyright 2015 The Gogs Authors. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage repo\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\n\t\"github.com/gogs/git-module\"\n\tapi \"github.com/gogs/go-gogs-client\"\n\tjsoniter \"github.com/json-iterator/go\"\n\t\"gopkg.in/macaron.v1\"\n\n\t\"gogs.io/gogs/internal/conf\"\n\t\"gogs.io/gogs/internal/context\"\n\t\"gogs.io/gogs/internal/db\"\n\t\"gogs.io/gogs/internal/db/errors\"\n\t\"gogs.io/gogs/internal/form\"\n\t\"gogs.io/gogs/internal/netutil\"\n)\n\nconst (\n\ttmplRepoSettingsWebhooks   = \"repo/settings/webhook/base\"\n\ttmplRepoSettingsWebhookNew = \"repo/settings/webhook/new\"\n\ttmplOrgSettingsWebhooks    = \"org/settings/webhooks\"\n\ttmplOrgSettingsWebhookNew  = \"org/settings/webhook_new\"\n)\n\nfunc InjectOrgRepoContext() macaron.Handler {\n\treturn func(c *context.Context) {\n\t\torCtx, err := getOrgRepoContext(c)\n\t\tif err != nil {\n\t\t\tc.Error(err, \"get organization or repository context\")\n\t\t\treturn\n\t\t}\n\t\tc.Map(orCtx)\n\t}\n}\n\ntype orgRepoContext struct {\n\tOrgID    int64\n\tRepoID   int64\n\tLink     string\n\tTmplList string\n\tTmplNew  string\n}\n\n// getOrgRepoContext determines whether this is a repo context or organization context.\nfunc getOrgRepoContext(c *context.Context) (*orgRepoContext, error) {\n\tif len(c.Repo.RepoLink) > 0 {\n\t\tc.PageIs(\"RepositoryContext\")\n\t\treturn &orgRepoContext{\n\t\t\tRepoID:   c.Repo.Repository.ID,\n\t\t\tLink:     c.Repo.RepoLink,\n\t\t\tTmplList: tmplRepoSettingsWebhooks,\n\t\t\tTmplNew:  tmplRepoSettingsWebhookNew,\n\t\t}, nil\n\t}\n\n\tif len(c.Org.OrgLink) > 0 {\n\t\tc.PageIs(\"OrganizationContext\")\n\t\treturn &orgRepoContext{\n\t\t\tOrgID:    c.Org.Organization.ID,\n\t\t\tLink:     c.Org.OrgLink,\n\t\t\tTmplList: tmplOrgSettingsWebhooks,\n\t\t\tTmplNew:  tmplOrgSettingsWebhookNew,\n\t\t}, nil\n\t}\n\n\treturn nil, errors.New(\"unable to determine context\")\n}\n\nfunc Webhooks(c *context.Context, orCtx *orgRepoContext) {\n\tc.Title(\"repo.settings.hooks\")\n\tc.PageIs(\"SettingsHooks\")\n\tc.Data[\"Types\"] = conf.Webhook.Types\n\n\tvar err error\n\tvar ws []*db.Webhook\n\tif orCtx.RepoID > 0 {\n\t\tc.Data[\"Description\"] = c.Tr(\"repo.settings.hooks_desc\", \"https://gogs.io/docs/features/webhook.html\")\n\t\tws, err = db.GetWebhooksByRepoID(orCtx.RepoID)\n\t} else {\n\t\tc.Data[\"Description\"] = c.Tr(\"org.settings.hooks_desc\")\n\t\tws, err = db.GetWebhooksByOrgID(orCtx.OrgID)\n\t}\n\tif err != nil {\n\t\tc.Error(err, \"get webhooks\")\n\t\treturn\n\t}\n\tc.Data[\"Webhooks\"] = ws\n\n\tc.Success(orCtx.TmplList)\n}\n\nfunc WebhooksNew(c *context.Context, orCtx *orgRepoContext) {\n\tc.Title(\"repo.settings.add_webhook\")\n\tc.PageIs(\"SettingsHooks\")\n\tc.PageIs(\"SettingsHooksNew\")\n\n\tallowed := false\n\thookType := strings.ToLower(c.Params(\":type\"))\n\tfor _, typ := range conf.Webhook.Types {\n\t\tif hookType == typ {\n\t\t\tallowed = true\n\t\t\tc.Data[\"HookType\"] = typ\n\t\t\tbreak\n\t\t}\n\t}\n\tif !allowed {\n\t\tc.NotFound()\n\t\treturn\n\t}\n\n\tc.Success(orCtx.TmplNew)\n}\n\nfunc validateWebhook(l macaron.Locale, w *db.Webhook) (field, msg string, ok bool) {\n\t// \ud83d\udea8 SECURITY: Local addresses must not be allowed by non-admins to prevent SSRF,\n\t// see https://github.com/gogs/gogs/issues/5366 for details.\n\tpayloadURL, err := url.Parse(w.URL)\n\tif err != nil {\n\t\treturn \"PayloadURL\", l.Tr(\"repo.settings.webhook.err_cannot_parse_payload_url\", err), false\n\t}\n\n\tif netutil.IsBlockedLocalHostname(payloadURL.Hostname(), conf.Security.LocalNetworkAllowlist) {\n\t\treturn \"PayloadURL\", l.Tr(\"repo.settings.webhook.url_resolved_to_blocked_local_address\"), false\n\t}\n\treturn \"\", \"\", true\n}\n\nfunc validateAndCreateWebhook(c *context.Context, orCtx *orgRepoContext, w *db.Webhook) {\n\tc.Data[\"Webhook\"] = w\n\n\tif c.HasError() {\n\t\tc.Success(orCtx.TmplNew)\n\t\treturn\n\t}\n\n\tfield, msg, ok := validateWebhook(c.Locale, w)\n\tif !ok {\n\t\tc.FormErr(field)\n\t\tc.RenderWithErr(msg, orCtx.TmplNew, nil)\n\t\treturn\n\t}\n\n\tif err := w.UpdateEvent(); err != nil {\n\t\tc.Error(err, \"update event\")\n\t\treturn\n\t} else if err := db.CreateWebhook(w); err != nil {\n\t\tc.Error(err, \"create webhook\")\n\t\treturn\n\t}\n\n\tc.Flash.Success(c.Tr(\"repo.settings.add_hook_success\"))\n\tc.Redirect(orCtx.Link + \"/settings/hooks\")\n}\n\nfunc toHookEvent(f form.Webhook) *db.HookEvent {\n\treturn &db.HookEvent{\n\t\tPushOnly:       f.PushOnly(),\n\t\tSendEverything: f.SendEverything(),\n\t\tChooseEvents:   f.ChooseEvents(),\n\t\tHookEvents: db.HookEvents{\n\t\t\tCreate:       f.Create,\n\t\t\tDelete:       f.Delete,\n\t\t\tFork:         f.Fork,\n\t\t\tPush:         f.Push,\n\t\t\tIssues:       f.Issues,\n\t\t\tIssueComment: f.IssueComment,\n\t\t\tPullRequest:  f.PullRequest,\n\t\t\tRelease:      f.Release,\n\t\t},\n\t}\n}\n\nfunc WebhooksNewPost(c *context.Context, orCtx *orgRepoContext, f form.NewWebhook) {\n\tc.Title(\"repo.settings.add_webhook\")\n\tc.PageIs(\"SettingsHooks\")\n\tc.PageIs(\"SettingsHooksNew\")\n\tc.Data[\"HookType\"] = \"gogs\"\n\n\tcontentType := db.JSON\n\tif db.HookContentType(f.ContentType) == db.FORM {\n\t\tcontentType = db.FORM\n\t}\n\n\tw := &db.Webhook{\n\t\tRepoID:       orCtx.RepoID,\n\t\tOrgID:        orCtx.OrgID,\n\t\tURL:          f.PayloadURL,\n\t\tContentType:  contentType,\n\t\tSecret:       f.Secret,\n\t\tHookEvent:    toHookEvent(f.Webhook),\n\t\tIsActive:     f.Active,\n\t\tHookTaskType: db.GOGS,\n\t}\n\tvalidateAndCreateWebhook(c, orCtx, w)\n}\n\nfunc WebhooksSlackNewPost(c *context.Context, orCtx *orgRepoContext, f form.NewSlackHook) {\n\tc.Title(\"repo.settings.add_webhook\")\n\tc.PageIs(\"SettingsHooks\")\n\tc.PageIs(\"SettingsHooksNew\")\n\tc.Data[\"HookType\"] = \"slack\"\n\n\tmeta := &db.SlackMeta{\n\t\tChannel:  f.Channel,\n\t\tUsername: f.Username,\n\t\tIconURL:  f.IconURL,\n\t\tColor:    f.Color,\n\t}\n\tc.Data[\"SlackMeta\"] = meta\n\n\tp, err := jsoniter.Marshal(meta)\n\tif err != nil {\n\t\tc.Error(err, \"marshal JSON\")\n\t\treturn\n\t}\n\n\tw := &db.Webhook{\n\t\tRepoID:       orCtx.RepoID,\n\t\tURL:          f.PayloadURL,\n\t\tContentType:  db.JSON,\n\t\tHookEvent:    toHookEvent(f.Webhook),\n\t\tIsActive:     f.Active,\n\t\tHookTaskType: db.SLACK,\n\t\tMeta:         string(p),\n\t\tOrgID:        orCtx.OrgID,\n\t}\n\tvalidateAndCreateWebhook(c, orCtx, w)\n}\n\nfunc WebhooksDiscordNewPost(c *context.Context, orCtx *orgRepoContext, f form.NewDiscordHook) {\n\tc.Title(\"repo.settings.add_webhook\")\n\tc.PageIs(\"SettingsHooks\")\n\tc.PageIs(\"SettingsHooksNew\")\n\tc.Data[\"HookType\"] = \"discord\"\n\n\tmeta := &db.SlackMeta{\n\t\tUsername: f.Username,\n\t\tIconURL:  f.IconURL,\n\t\tColor:    f.Color,\n\t}\n\tc.Data[\"SlackMeta\"] = meta\n\n\tp, err := jsoniter.Marshal(meta)\n\tif err != nil {\n\t\tc.Error(err, \"marshal JSON\")\n\t\treturn\n\t}\n\n\tw := &db.Webhook{\n\t\tRepoID:       orCtx.RepoID,\n\t\tURL:          f.PayloadURL,\n\t\tContentType:  db.JSON,\n\t\tHookEvent:    toHookEvent(f.Webhook),\n\t\tIsActive:     f.Active,\n\t\tHookTaskType: db.DISCORD,\n\t\tMeta:         string(p),\n\t\tOrgID:        orCtx.OrgID,\n\t}\n\tvalidateAndCreateWebhook(c, orCtx, w)\n}\n\nfunc WebhooksDingtalkNewPost(c *context.Context, orCtx *orgRepoContext, f form.NewDingtalkHook) {\n\tc.Title(\"repo.settings.add_webhook\")\n\tc.PageIs(\"SettingsHooks\")\n\tc.PageIs(\"SettingsHooksNew\")\n\tc.Data[\"HookType\"] = \"dingtalk\"\n\n\tw := &db.Webhook{\n\t\tRepoID:       orCtx.RepoID,\n\t\tURL:          f.PayloadURL,\n\t\tContentType:  db.JSON,\n\t\tHookEvent:    toHookEvent(f.Webhook),\n\t\tIsActive:     f.Active,\n\t\tHookTaskType: db.DINGTALK,\n\t\tOrgID:        orCtx.OrgID,\n\t}\n\tvalidateAndCreateWebhook(c, orCtx, w)\n}\n\nfunc loadWebhook(c *context.Context, orCtx *orgRepoContext) *db.Webhook {\n\tc.RequireHighlightJS()\n\n\tvar err error\n\tvar w *db.Webhook\n\tif orCtx.RepoID > 0 {\n\t\tw, err = db.GetWebhookOfRepoByID(c.Repo.Repository.ID, c.ParamsInt64(\":id\"))\n\t} else {\n\t\tw, err = db.GetWebhookByOrgID(c.Org.Organization.ID, c.ParamsInt64(\":id\"))\n\t}\n\tif err != nil {\n\t\tc.NotFoundOrError(err, \"get webhook\")\n\t\treturn nil\n\t}\n\tc.Data[\"Webhook\"] = w\n\n\tswitch w.HookTaskType {\n\tcase db.SLACK:\n\t\tc.Data[\"SlackMeta\"] = w.SlackMeta()\n\t\tc.Data[\"HookType\"] = \"slack\"\n\tcase db.DISCORD:\n\t\tc.Data[\"SlackMeta\"] = w.SlackMeta()\n\t\tc.Data[\"HookType\"] = \"discord\"\n\tcase db.DINGTALK:\n\t\tc.Data[\"HookType\"] = \"dingtalk\"\n\tdefault:\n\t\tc.Data[\"HookType\"] = \"gogs\"\n\t}\n\tc.Data[\"FormURL\"] = fmt.Sprintf(\"%s/settings/hooks/%s/%d\", orCtx.Link, c.Data[\"HookType\"], w.ID)\n\tc.Data[\"DeleteURL\"] = fmt.Sprintf(\"%s/settings/hooks/delete\", orCtx.Link)\n\n\tc.Data[\"History\"], err = w.History(1)\n\tif err != nil {\n\t\tc.Error(err, \"get history\")\n\t\treturn nil\n\t}\n\treturn w\n}\n\nfunc WebhooksEdit(c *context.Context, orCtx *orgRepoContext) {\n\tc.Title(\"repo.settings.update_webhook\")\n\tc.PageIs(\"SettingsHooks\")\n\tc.PageIs(\"SettingsHooksEdit\")\n\n\tloadWebhook(c, orCtx)\n\tif c.Written() {\n\t\treturn\n\t}\n\n\tc.Success(orCtx.TmplNew)\n}\n\nfunc validateAndUpdateWebhook(c *context.Context, orCtx *orgRepoContext, w *db.Webhook) {\n\tc.Data[\"Webhook\"] = w\n\n\tif c.HasError() {\n\t\tc.Success(orCtx.TmplNew)\n\t\treturn\n\t}\n\n\tfield, msg, ok := validateWebhook(c.Locale, w)\n\tif !ok {\n\t\tc.FormErr(field)\n\t\tc.RenderWithErr(msg, orCtx.TmplNew, nil)\n\t\treturn\n\t}\n\n\tif err := w.UpdateEvent(); err != nil {\n\t\tc.Error(err, \"update event\")\n\t\treturn\n\t} else if err := db.UpdateWebhook(w); err != nil {\n\t\tc.Error(err, \"update webhook\")\n\t\treturn\n\t}\n\n\tc.Flash.Success(c.Tr(\"repo.settings.update_hook_success\"))\n\tc.Redirect(fmt.Sprintf(\"%s/settings/hooks/%d\", orCtx.Link, w.ID))\n}\n\nfunc WebhooksEditPost(c *context.Context, orCtx *orgRepoContext, f form.NewWebhook) {\n\tc.Title(\"repo.settings.update_webhook\")\n\tc.PageIs(\"SettingsHooks\")\n\tc.PageIs(\"SettingsHooksEdit\")\n\n\tw := loadWebhook(c, orCtx)\n\tif c.Written() {\n\t\treturn\n\t}\n\n\tcontentType := db.JSON\n\tif db.HookContentType(f.ContentType) == db.FORM {\n\t\tcontentType = db.FORM\n\t}\n\n\tw.URL = f.PayloadURL\n\tw.ContentType = contentType\n\tw.Secret = f.Secret\n\tw.HookEvent = toHookEvent(f.Webhook)\n\tw.IsActive = f.Active\n\tvalidateAndUpdateWebhook(c, orCtx, w)\n}\n\nfunc WebhooksSlackEditPost(c *context.Context, orCtx *orgRepoContext, f form.NewSlackHook) {\n\tc.Title(\"repo.settings.update_webhook\")\n\tc.PageIs(\"SettingsHooks\")\n\tc.PageIs(\"SettingsHooksEdit\")\n\n\tw := loadWebhook(c, orCtx)\n\tif c.Written() {\n\t\treturn\n\t}\n\n\tmeta, err := jsoniter.Marshal(&db.SlackMeta{\n\t\tChannel:  f.Channel,\n\t\tUsername: f.Username,\n\t\tIconURL:  f.IconURL,\n\t\tColor:    f.Color,\n\t})\n\tif err != nil {\n\t\tc.Error(err, \"marshal JSON\")\n\t\treturn\n\t}\n\n\tw.URL = f.PayloadURL\n\tw.Meta = string(meta)\n\tw.HookEvent = toHookEvent(f.Webhook)\n\tw.IsActive = f.Active\n\tvalidateAndUpdateWebhook(c, orCtx, w)\n}\n\nfunc WebhooksDiscordEditPost(c *context.Context, orCtx *orgRepoContext, f form.NewDiscordHook) {\n\tc.Title(\"repo.settings.update_webhook\")\n\tc.PageIs(\"SettingsHooks\")\n\tc.PageIs(\"SettingsHooksEdit\")\n\n\tw := loadWebhook(c, orCtx)\n\tif c.Written() {\n\t\treturn\n\t}\n\n\tmeta, err := jsoniter.Marshal(&db.SlackMeta{\n\t\tUsername: f.Username,\n\t\tIconURL:  f.IconURL,\n\t\tColor:    f.Color,\n\t})\n\tif err != nil {\n\t\tc.Error(err, \"marshal JSON\")\n\t\treturn\n\t}\n\n\tw.URL = f.PayloadURL\n\tw.Meta = string(meta)\n\tw.HookEvent = toHookEvent(f.Webhook)\n\tw.IsActive = f.Active\n\tvalidateAndUpdateWebhook(c, orCtx, w)\n}\n\nfunc WebhooksDingtalkEditPost(c *context.Context, orCtx *orgRepoContext, f form.NewDingtalkHook) {\n\tc.Title(\"repo.settings.update_webhook\")\n\tc.PageIs(\"SettingsHooks\")\n\tc.PageIs(\"SettingsHooksEdit\")\n\n\tw := loadWebhook(c, orCtx)\n\tif c.Written() {\n\t\treturn\n\t}\n\n\tw.URL = f.PayloadURL\n\tw.HookEvent = toHookEvent(f.Webhook)\n\tw.IsActive = f.Active\n\tvalidateAndUpdateWebhook(c, orCtx, w)\n}\n\nfunc TestWebhook(c *context.Context) {\n\tvar (\n\t\tcommitID          string\n\t\tcommitMessage     string\n\t\tauthor            *git.Signature\n\t\tcommitter         *git.Signature\n\t\tauthorUsername    string\n\t\tcommitterUsername string\n\t\tnameStatus        *git.NameStatus\n\t)\n\n\t// Grab latest commit or fake one if it's empty repository.\n\n\tif c.Repo.Commit == nil {\n\t\tcommitID = git.EmptyID\n\t\tcommitMessage = \"This is a fake commit\"\n\t\tghost := db.NewGhostUser()\n\t\tauthor = ghost.NewGitSig()\n\t\tcommitter = ghost.NewGitSig()\n\t\tauthorUsername = ghost.Name\n\t\tcommitterUsername = ghost.Name\n\t\tnameStatus = &git.NameStatus{}\n\n\t} else {\n\t\tcommitID = c.Repo.Commit.ID.String()\n\t\tcommitMessage = c.Repo.Commit.Message\n\t\tauthor = c.Repo.Commit.Author\n\t\tcommitter = c.Repo.Commit.Committer\n\n\t\t// Try to match email with a real user.\n\t\tauthor, err := db.GetUserByEmail(c.Repo.Commit.Author.Email)\n\t\tif err == nil {\n\t\t\tauthorUsername = author.Name\n\t\t} else if !db.IsErrUserNotExist(err) {\n\t\t\tc.Error(err, \"get user by email\")\n\t\t\treturn\n\t\t}\n\n\t\tuser, err := db.GetUserByEmail(c.Repo.Commit.Committer.Email)\n\t\tif err == nil {\n\t\t\tcommitterUsername = user.Name\n\t\t} else if !db.IsErrUserNotExist(err) {\n\t\t\tc.Error(err, \"get user by email\")\n\t\t\treturn\n\t\t}\n\n\t\tnameStatus, err = c.Repo.Commit.ShowNameStatus()\n\t\tif err != nil {\n\t\t\tc.Error(err, \"get changed files\")\n\t\t\treturn\n\t\t}\n\t}\n\n\tapiUser := c.User.APIFormat()\n\tp := &api.PushPayload{\n\t\tRef:    git.RefsHeads + c.Repo.Repository.DefaultBranch,\n\t\tBefore: commitID,\n\t\tAfter:  commitID,\n\t\tCommits: []*api.PayloadCommit{\n\t\t\t{\n\t\t\t\tID:      commitID,\n\t\t\t\tMessage: commitMessage,\n\t\t\t\tURL:     c.Repo.Repository.HTMLURL() + \"/commit/\" + commitID,\n\t\t\t\tAuthor: &api.PayloadUser{\n\t\t\t\t\tName:     author.Name,\n\t\t\t\t\tEmail:    author.Email,\n\t\t\t\t\tUserName: authorUsername,\n\t\t\t\t},\n\t\t\t\tCommitter: &api.PayloadUser{\n\t\t\t\t\tName:     committer.Name,\n\t\t\t\t\tEmail:    committer.Email,\n\t\t\t\t\tUserName: committerUsername,\n\t\t\t\t},\n\t\t\t\tAdded:    nameStatus.Added,\n\t\t\t\tRemoved:  nameStatus.Removed,\n\t\t\t\tModified: nameStatus.Modified,\n\t\t\t},\n\t\t},\n\t\tRepo:   c.Repo.Repository.APIFormat(nil),\n\t\tPusher: apiUser,\n\t\tSender: apiUser,\n\t}\n\tif err := db.TestWebhook(c.Repo.Repository, db.HOOK_EVENT_PUSH, p, c.ParamsInt64(\"id\")); err != nil {\n\t\tc.Error(err, \"test webhook\")\n\t\treturn\n\t}\n\n\tc.Flash.Info(c.Tr(\"repo.settings.webhook.test_delivery_success\"))\n\tc.Status(http.StatusOK)\n}\n\nfunc RedeliveryWebhook(c *context.Context) {\n\twebhook, err := db.GetWebhookOfRepoByID(c.Repo.Repository.ID, c.ParamsInt64(\":id\"))\n\tif err != nil {\n\t\tc.NotFoundOrError(err, \"get webhook\")\n\t\treturn\n\t}\n\n\thookTask, err := db.GetHookTaskOfWebhookByUUID(webhook.ID, c.Query(\"uuid\"))\n\tif err != nil {\n\t\tc.NotFoundOrError(err, \"get hook task by UUID\")\n\t\treturn\n\t}\n\n\thookTask.IsDelivered = false\n\tif err = db.UpdateHookTask(hookTask); err != nil {\n\t\tc.Error(err, \"update hook task\")\n\t\treturn\n\t}\n\n\tgo db.HookQueue.Add(c.Repo.Repository.ID)\n\tc.Flash.Info(c.Tr(\"repo.settings.webhook.redelivery_success\", hookTask.UUID))\n\tc.Status(http.StatusOK)\n}\n\nfunc DeleteWebhook(c *context.Context, orCtx *orgRepoContext) {\n\tvar err error\n\tif orCtx.RepoID > 0 {\n\t\terr = db.DeleteWebhookOfRepoByID(orCtx.RepoID, c.QueryInt64(\"id\"))\n\t} else {\n\t\terr = db.DeleteWebhookOfOrgByID(orCtx.OrgID, c.QueryInt64(\"id\"))\n\t}\n\tif err != nil {\n\t\tc.Error(err, \"delete webhook\")\n\t\treturn\n\t}\n\tc.Flash.Success(c.Tr(\"repo.settings.webhook_deletion_success\"))\n\n\tc.JSONSuccess(map[string]interface{}{\n\t\t\"redirect\": orCtx.Link + \"/settings/hooks\",\n\t})\n}\n", "// Copyright 2020 The Gogs Authors. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage repo\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\n\t\"gogs.io/gogs/internal/db\"\n\t\"gogs.io/gogs/internal/mocks\"\n)\n\nfunc Test_validateWebhook(t *testing.T) {\n\tl := &mocks.Locale{\n\t\tMockLang: \"en\",\n\t\tMockTr: func(s string, _ ...interface{}) string {\n\t\t\treturn s\n\t\t},\n\t}\n\n\ttests := []struct {\n\t\tname     string\n\t\tactor    *db.User\n\t\twebhook  *db.Webhook\n\t\texpField string\n\t\texpMsg   string\n\t\texpOK    bool\n\t}{\n\t\t{\n\t\t\tname:    \"admin bypass local address check\",\n\t\t\twebhook: &db.Webhook{URL: \"https://www.google.com\"},\n\t\t\texpOK:   true,\n\t\t},\n\n\t\t{\n\t\t\tname:     \"local address not allowed\",\n\t\t\twebhook:  &db.Webhook{URL: \"http://localhost:3306\"},\n\t\t\texpField: \"PayloadURL\",\n\t\t\texpMsg:   \"repo.settings.webhook.url_resolved_to_blocked_local_address\",\n\t\t\texpOK:    false,\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tfield, msg, ok := validateWebhook(l, test.webhook)\n\t\t\tassert.Equal(t, test.expOK, ok)\n\t\t\tassert.Equal(t, test.expMsg, msg)\n\t\t\tassert.Equal(t, test.expField, field)\n\t\t})\n\t}\n}\n"], "filenames": ["CHANGELOG.md", "conf/locale/locale_en-US.ini", "internal/db/error.go", "internal/db/webhook.go", "internal/form/repo.go", "internal/netutil/netutil.go", "internal/netutil/netutil_test.go", "internal/route/api/v1/repo/repo.go", "internal/route/repo/repo.go", "internal/route/repo/webhook.go", "internal/route/repo/webhook_test.go"], "buggy_code_start_loc": [24, 445, 197, 26, 75, 50, 37, 250, 183, 122, 34], "buggy_code_end_loc": [24, 813, 210, 690, 77, 53, 38, 250, 187, 352, 51], "fixing_code_start_loc": [25, 446, 197, 27, 75, 50, 37, 251, 183, 122, 34], "fixing_code_end_loc": [26, 814, 211, 697, 77, 54, 38, 253, 190, 349, 49], "type": "CWE-918", "message": "Server-Side Request Forgery (SSRF) in GitHub repository gogs/gogs prior to 0.12.8.", "other": {"cve": {"id": "CVE-2022-1285", "sourceIdentifier": "security@huntr.dev", "published": "2022-06-01T06:15:07.193", "lastModified": "2022-06-08T19:53:03.027", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Server-Side Request Forgery (SSRF) in GitHub repository gogs/gogs prior to 0.12.8."}, {"lang": "es", "value": "Una vulnerabilidad de tipo Server-Side Request Forgery (SSRF) en el repositorio de GitHub gogs/gogs versiones anteriores a 0.12.8"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 8.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-918"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-918"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gogs:gogs:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.12.8", "matchCriteriaId": "95A31B26-0A2D-4BC0-AC6C-4342A81CC093"}]}]}], "references": [{"url": "https://github.com/gogs/gogs/commit/7885f454a4946c4bbec1b4f8c603b5eea7429c7f", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/da1fbd6e-7a02-458e-9c2e-6d226c47046d", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gogs/gogs/commit/7885f454a4946c4bbec1b4f8c603b5eea7429c7f"}}