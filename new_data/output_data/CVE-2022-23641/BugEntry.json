{"buggy_code": ["# frozen_string_literal: true\n\nrequire 'socket'\nrequire 'ipaddr'\nrequire 'excon'\nrequire 'rate_limiter'\nrequire 'url_helper'\n\n# Determine the final endpoint for a Web URI, following redirects\nclass FinalDestination\n\n  def self.clear_https_cache!(domain)\n    key = redis_https_key(domain)\n    Discourse.redis.without_namespace.del(key)\n  end\n\n  def self.cache_https_domain(domain)\n    key = redis_https_key(domain)\n    Discourse.redis.without_namespace.setex(key, 1.day.to_i, \"1\")\n  end\n\n  def self.is_https_domain?(domain)\n    key = redis_https_key(domain)\n    Discourse.redis.without_namespace.get(key).present?\n  end\n\n  def self.redis_https_key(domain)\n    \"HTTPS_DOMAIN_#{domain}\"\n  end\n\n  DEFAULT_USER_AGENT = \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0 Safari/605.1.15\"\n\n  attr_reader :status, :cookie, :status_code, :content_type, :ignored\n\n  def initialize(url, opts = nil)\n    @url = url\n    @uri = uri(escape_url) if @url\n\n    @opts = opts || {}\n    @force_get_hosts = @opts[:force_get_hosts] || []\n    @preserve_fragment_url_hosts = @opts[:preserve_fragment_url_hosts] || []\n    @force_custom_user_agent_hosts = @opts[:force_custom_user_agent_hosts] || []\n    @default_user_agent = @opts[:default_user_agent] || DEFAULT_USER_AGENT\n    @opts[:max_redirects] ||= 5\n    @opts[:lookup_ip] ||= lambda { |host| FinalDestination.lookup_ip(host) }\n\n    @limit = @opts[:max_redirects]\n\n    @ignored = []\n    if @limit > 0\n      ignore_redirects = [Discourse.base_url_no_prefix]\n\n      if @opts[:ignore_redirects]\n        ignore_redirects.concat(@opts[:ignore_redirects])\n      end\n\n      ignore_redirects.each do |ignore_redirect|\n        ignore_redirect = uri(ignore_redirect)\n        if ignore_redirect.present? && ignore_redirect.hostname\n          @ignored << ignore_redirect.hostname\n        end\n      end\n    end\n\n    @status = :ready\n    @follow_canonical = @opts[:follow_canonical]\n    @http_verb = http_verb(@force_get_hosts, @follow_canonical)\n    @cookie = nil\n    @limited_ips = []\n    @verbose = @opts[:verbose] || false\n    @timeout = @opts[:timeout] || nil\n    @preserve_fragment_url = @preserve_fragment_url_hosts.any? { |host| hostname_matches?(host) }\n    @validate_uri = @opts.fetch(:validate_uri) { true }\n    @user_agent = @force_custom_user_agent_hosts.any? { |host| hostname_matches?(host) } ? Onebox.options.user_agent : @default_user_agent\n  end\n\n  def self.connection_timeout\n    20\n  end\n\n  def http_verb(force_get_hosts, follow_canonical)\n    if follow_canonical || force_get_hosts.any? { |host| hostname_matches?(host) }\n      :get\n    else\n      :head\n    end\n  end\n\n  def timeout\n    @timeout || FinalDestination.connection_timeout\n  end\n\n  def redirected?\n    @limit < @opts[:max_redirects]\n  end\n\n  def request_headers\n    result = {\n      \"User-Agent\" => @user_agent,\n      \"Accept\" => \"*/*\",\n      \"Accept-Language\" => \"*\",\n      \"Host\" => @uri.hostname\n    }\n\n    result['Cookie'] = @cookie if @cookie\n\n    result\n  end\n\n  def small_get(request_headers)\n    status_code, response_headers = nil\n\n    catch(:done) do\n      Net::HTTP.start(@uri.host, @uri.port, use_ssl: @uri.is_a?(URI::HTTPS), open_timeout: timeout) do |http|\n        http.read_timeout = timeout\n        http.request_get(@uri.request_uri, request_headers) do |resp|\n          status_code = resp.code.to_i\n          response_headers = resp.to_hash\n\n          # see: https://bugs.ruby-lang.org/issues/15624\n          # if we allow response to return then body will be read\n          # got to abort without reading body\n          throw :done\n        end\n      end\n    end\n\n    [status_code, response_headers]\n  end\n\n  # this is a new interface for simply getting\n  # N bytes accounting for all internal logic\n  def get(uri = @uri, redirects = @limit, extra_headers: {}, &blk)\n    raise \"Must specify block\" unless block_given?\n\n    if uri && uri.port == 80 && FinalDestination.is_https_domain?(uri.hostname)\n      uri.scheme = \"https\"\n      uri = URI(uri.to_s)\n    end\n\n    return nil unless validate_uri\n\n    result, (location, cookie) = safe_get(uri, &blk)\n\n    if result == :redirect && (redirects == 0 || !location)\n      return nil\n    end\n\n    if result == :redirect\n      old_port = uri.port\n      location = \"#{uri.scheme}://#{uri.host}#{location}\" if location[0] == \"/\"\n      uri = uri(location)\n\n      # https redirect, so just cache that whole new domain is https\n      if old_port == 80 && uri&.port == 443 && (URI::HTTPS === uri)\n        FinalDestination.cache_https_domain(uri.hostname)\n      end\n\n      return nil if !uri\n\n      extra = nil\n      extra = { 'Cookie' => cookie } if cookie\n\n      get(uri, redirects - 1, extra_headers: extra, &blk)\n    elsif result == :ok\n      uri.to_s\n    else\n      nil\n    end\n  end\n\n  def resolve\n    if @uri && @uri.port == 80 && FinalDestination.is_https_domain?(@uri.hostname)\n      @uri.scheme = \"https\"\n      @uri = URI(@uri.to_s)\n    end\n\n    if @limit < 0\n      @status = :too_many_redirects\n      log(:warn, \"FinalDestination could not resolve URL (too many redirects): #{@uri}\") if @verbose\n      return nil\n    end\n\n    unless validate_uri\n      @status = :invalid_address\n      log(:warn, \"FinalDestination could not resolve URL (invalid URI): #{@uri}\") if @verbose\n      return nil\n    end\n\n    @ignored.each do |host|\n      if @uri&.hostname&.match?(host)\n        @status = :resolved\n        return @uri\n      end\n    end\n\n    if Oneboxer.cached_response_body_exists?(@uri.to_s)\n      @status = :resolved\n      return @uri\n    end\n\n    headers = request_headers\n    middlewares = Excon.defaults[:middlewares]\n    middlewares << Excon::Middleware::Decompress if @http_verb == :get\n\n    response = Excon.public_send(@http_verb,\n      @uri.to_s,\n      read_timeout: timeout,\n      connect_timeout: timeout,\n      headers: headers,\n      middlewares: middlewares\n    )\n\n    location = nil\n    response_headers = nil\n    response_status = response.status.to_i\n\n    case response.status\n    when 200\n      # Cache body of successful `get` requests\n      if @http_verb == :get\n        if Oneboxer.cache_response_body?(@uri)\n          Oneboxer.cache_response_body(@uri.to_s, response.body)\n        end\n      end\n\n      if @follow_canonical\n        next_url = fetch_canonical_url(response.body)\n\n        if next_url.to_s.present? && next_url != @uri\n          @follow_canonical = false\n          @uri = next_url\n          @http_verb = http_verb(@force_get_hosts, @follow_canonical)\n\n          return resolve\n        end\n      end\n\n      @content_type = response.headers['Content-Type'] if response.headers.has_key?('Content-Type')\n      @status = :resolved\n      return @uri\n    when 103, 400, 405, 406, 409, 500, 501\n      response_status, small_headers = small_get(request_headers)\n\n      if response_status == 200\n        @status = :resolved\n        return @uri\n      end\n\n      response_headers = {}\n      if cookie_val = small_headers['set-cookie']\n        response_headers[:cookies] = cookie_val\n      end\n\n      if location_val = small_headers['location']\n        response_headers[:location] = location_val.join\n      end\n    end\n\n    unless response_headers\n      response_headers = {\n        cookies: response.data[:cookies] || response.headers[:\"set-cookie\"],\n        location: response.headers[:location]\n      }\n    end\n\n    if (300..399).include?(response_status)\n      location = response_headers[:location]\n    end\n\n    if cookies = response_headers[:cookies]\n      @cookie = Array.wrap(cookies).map { |c| c.split(';').first.strip }.join('; ')\n    end\n\n    if location\n      redirect_uri = uri(location)\n      if @uri.host == redirect_uri.host && (redirect_uri.path =~ /\\/login/ || redirect_uri.path =~ /\\/session/)\n        @status = :resolved\n        return @uri\n      end\n\n      old_port = @uri.port\n      location = \"#{location}##{@uri.fragment}\" if @preserve_fragment_url && @uri.fragment.present?\n      location = \"#{@uri.scheme}://#{@uri.host}#{location}\" if location[0] == \"/\"\n      @uri = uri(location)\n      @limit -= 1\n\n      # https redirect, so just cache that whole new domain is https\n      if old_port == 80 && @uri.port == 443 && (URI::HTTPS === @uri)\n        FinalDestination.cache_https_domain(@uri.hostname)\n      end\n\n      return resolve\n    end\n\n    # this is weird an exception seems better\n    @status = :failure\n    @status_code = response.status\n\n    log(:warn, \"FinalDestination could not resolve URL (status #{response.status}): #{@uri}\") if @verbose\n    nil\n  rescue Excon::Errors::Timeout\n    log(:warn, \"FinalDestination could not resolve URL (timeout): #{@uri}\") if @verbose\n    nil\n  end\n\n  def validate_uri\n    !@validate_uri || (validate_uri_format && is_dest_valid?)\n  end\n\n  def validate_uri_format\n    return false unless @uri\n    return false unless ['https', 'http'].include?(@uri.scheme)\n    return false if @uri.scheme == 'http' && @uri.port != 80\n    return false if @uri.scheme == 'https' && @uri.port != 443\n\n    # Disallow IP based crawling\n    (IPAddr.new(@uri.hostname) rescue nil).nil?\n  end\n\n  def hostname\n    @uri.hostname\n  end\n\n  def hostname_matches?(url)\n    url = uri(url)\n\n    if @uri&.hostname.present? && url&.hostname.present?\n      hostname_parts = url.hostname.split('.')\n      has_wildcard = hostname_parts.first == '*'\n\n      if has_wildcard\n        @uri.hostname.end_with?(hostname_parts[1..-1].join('.'))\n      else\n        @uri.hostname == url.hostname\n      end\n    end\n  end\n\n  def is_dest_valid?\n    return false unless @uri && @uri.host\n\n    # Allowlisted hosts\n    return true if hostname_matches?(SiteSetting.Upload.s3_cdn_url) ||\n      hostname_matches?(GlobalSetting.try(:cdn_url)) ||\n      hostname_matches?(Discourse.base_url_no_prefix)\n\n    if SiteSetting.allowed_internal_hosts.present?\n      return true if SiteSetting.allowed_internal_hosts.split(\"|\").any? { |h| h.downcase == @uri.hostname.downcase }\n    end\n\n    address_s = @opts[:lookup_ip].call(@uri.hostname)\n    return false unless address_s\n\n    address = IPAddr.new(address_s)\n\n    if private_ranges.any? { |r| r === address }\n      @status = :invalid_address\n      return false\n    end\n\n    # Rate limit how often this IP can be crawled\n    if !@opts[:skip_rate_limit] && !@limited_ips.include?(address)\n      @limited_ips << address\n      RateLimiter.new(nil, \"crawl-destination-ip:#{address_s}\", 1000, 1.hour).performed!\n    end\n\n    true\n  rescue RateLimiter::LimitExceeded\n    false\n  end\n\n  def escape_url\n    UrlHelper.escape_uri(@url)\n  end\n\n  def private_ranges\n    FinalDestination.standard_private_ranges +\n      SiteSetting.blocked_ip_blocks.split('|').map { |r| IPAddr.new(r) rescue nil }.compact\n  end\n\n  def log(log_level, message)\n    return if @status_code == 404\n\n    Rails.logger.public_send(\n      log_level,\n      \"#{RailsMultisite::ConnectionManagement.current_db}: #{message}\"\n    )\n  end\n\n  def self.standard_private_ranges\n    @private_ranges ||= [\n      IPAddr.new('0.0.0.0/8'),\n      IPAddr.new('127.0.0.1'),\n      IPAddr.new('172.16.0.0/12'),\n      IPAddr.new('192.168.0.0/16'),\n      IPAddr.new('10.0.0.0/8'),\n      IPAddr.new('fc00::/7')\n    ]\n  end\n\n  def self.lookup_ip(host)\n    if Rails.env.test?\n      \"1.1.1.1\"\n    else\n      IPSocket::getaddress(host)\n    end\n  rescue SocketError\n    nil\n  end\n\n  protected\n\n  def safe_get(uri)\n    result = nil\n    unsafe_close = false\n\n    safe_session(uri) do |http|\n      headers = request_headers.merge(\n        'Accept-Encoding' => 'gzip',\n        'Host' => uri.host\n      )\n\n      req = Net::HTTP::Get.new(uri.request_uri, headers)\n\n      http.request(req) do |resp|\n        if Net::HTTPRedirection === resp\n          result = :redirect, [resp['location'], resp['Set-Cookie']]\n        end\n\n        if Net::HTTPSuccess === resp\n          resp.decode_content = true\n          resp.read_body do |chunk|\n            read_next = true\n\n            catch(:done) do\n              if read_next\n                read_next = false\n                yield resp, chunk, uri\n                read_next = true\n              end\n            end\n\n            # no clean way of finishing abruptly cause\n            # response likes reading till the end\n            if !read_next\n              unsafe_close = true\n              http.finish\n              raise StandardError\n            end\n          end\n          result = :ok\n        else\n          catch(:done) do\n            yield resp, nil, nil\n          end\n        end\n      end\n    end\n\n    result\n  rescue StandardError\n    unsafe_close ? :ok : raise\n  end\n\n  def safe_session(uri)\n    Net::HTTP.start(uri.host, uri.port, use_ssl: (uri.scheme == \"https\"), open_timeout: timeout) do |http|\n      http.read_timeout = timeout\n      yield http\n    end\n  end\n\n  private\n\n  def uri(location)\n    begin\n      URI.parse(location)\n    rescue URI::Error\n    end\n  end\n\n  def fetch_canonical_url(body)\n    return if body.blank?\n\n    canonical_element = Nokogiri::HTML5(body).at(\"link[rel='canonical']\")\n    return if canonical_element.nil?\n    canonical_uri = uri(canonical_element['href'])\n    return if canonical_uri.blank?\n\n    return canonical_uri if canonical_uri.host.present?\n    parts = [@uri.host, canonical_uri.to_s]\n    complete_url = canonical_uri.to_s.starts_with?('/') ? parts.join('') : parts.join('/')\n    complete_url = \"#{@uri.scheme}://#{complete_url}\" if @uri.scheme\n\n    uri(complete_url)\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'rails_helper'\nrequire 'final_destination'\n\ndescribe FinalDestination do\n\n  let(:opts) do\n    {\n      ignore_redirects: ['https://ignore-me.com'],\n\n      force_get_hosts: ['https://force.get.com', 'https://*.ihaveawildcard.com/'],\n\n      preserve_fragment_url_hosts: ['https://eviltrout.com'],\n\n      # avoid IP lookups in test\n      lookup_ip: lambda do |host|\n        case host\n        when 'eviltrout.com' then '52.84.143.152'\n        when 'particularly.eviltrout.com' then '52.84.143.152'\n        when 'codinghorror.com' then '91.146.108.148'\n        when 'discourse.org' then '104.25.152.10'\n        when 'some_thing.example.com' then '104.25.152.10'\n        when 'private-host.com' then '192.168.10.1'\n        when 'internal-ipv6.com' then '2001:abc:de:01:3:3d0:6a65:c2bf'\n        when 'ignore-me.com' then '53.84.143.152'\n        when 'force.get.com' then '22.102.29.40'\n        when 'any-subdomain.ihaveawildcard.com' then '104.25.152.11'\n        when 'wikipedia.com' then '1.2.3.4'\n        else\n          as_ip = IPAddr.new(host)\n          host\n        end\n      end\n    }\n  end\n\n  let(:doc_response) do\n    {\n      status: 200,\n      headers: { \"Content-Type\" => \"text/html\" }\n    }\n  end\n\n  let(:image_response) do\n    {\n      status: 200,\n      headers: { \"Content-Type\" => \"image/jpeg\" }\n    }\n  end\n\n  def canonical_follow(from, dest)\n    stub_request(:get, from).to_return(\n      status: 200,\n      body: \"<head><link rel=\\\"canonical\\\" href=\\\"#{dest}\\\"></head>\"\n    )\n  end\n\n  def redirect_response(from, dest)\n    stub_request(:head, from).to_return(\n      status: 302,\n      headers: { \"Location\" => dest }\n    )\n  end\n\n  def fd(url)\n    FinalDestination.new(url, opts)\n  end\n\n  it 'correctly parses ignored hostnames' do\n    fd = FinalDestination.new('https://meta.discourse.org',\n      ignore_redirects: ['http://google.com', 'youtube.com', 'https://meta.discourse.org', '://bing.com']\n    )\n\n    expect(fd.ignored).to eq(['test.localhost', 'google.com', 'meta.discourse.org'])\n  end\n\n  describe '.resolve' do\n\n    it \"has a ready status code before anything happens\" do\n      expect(fd('https://eviltrout.com').status).to eq(:ready)\n    end\n\n    it \"returns nil for an invalid url\" do\n      expect(fd(nil).resolve).to be_nil\n      expect(fd('asdf').resolve).to be_nil\n    end\n\n    it \"returns nil when read timeouts\" do\n      Excon.expects(:public_send).raises(Excon::Errors::Timeout)\n\n      expect(fd('https://discourse.org').resolve).to eq(nil)\n    end\n\n    context \"without redirects\" do\n      before do\n        stub_request(:head, \"https://eviltrout.com\").to_return(doc_response)\n      end\n\n      it \"returns the final url\" do\n        final = FinalDestination.new('https://eviltrout.com', opts)\n        expect(final.resolve.to_s).to eq('https://eviltrout.com')\n        expect(final.redirected?).to eq(false)\n        expect(final.status).to eq(:resolved)\n      end\n    end\n\n    it \"ignores redirects\" do\n      final = FinalDestination.new('https://ignore-me.com/some-url', opts)\n      expect(final.resolve.to_s).to eq('https://ignore-me.com/some-url')\n      expect(final.redirected?).to eq(false)\n      expect(final.status).to eq(:resolved)\n    end\n\n    context \"underscores in URLs\" do\n      before do\n        stub_request(:head, 'https://some_thing.example.com').to_return(doc_response)\n      end\n\n      it \"doesn't raise errors with underscores in urls\" do\n        final = FinalDestination.new('https://some_thing.example.com', opts)\n        expect(final.resolve.to_s).to eq('https://some_thing.example.com')\n        expect(final.redirected?).to eq(false)\n        expect(final.status).to eq(:resolved)\n      end\n    end\n\n    context \"with a couple of redirects\" do\n      before do\n        redirect_response(\"https://eviltrout.com\", \"https://codinghorror.com/blog\")\n        redirect_response(\"https://codinghorror.com/blog\", \"https://discourse.org\")\n        stub_request(:head, \"https://discourse.org\").to_return(doc_response)\n      end\n\n      it \"returns the final url\" do\n        final = FinalDestination.new('https://eviltrout.com', opts)\n        expect(final.resolve.to_s).to eq('https://discourse.org')\n        expect(final.redirected?).to eq(true)\n        expect(final.status).to eq(:resolved)\n      end\n    end\n\n    context \"with too many redirects\" do\n      before do\n        redirect_response(\"https://eviltrout.com\", \"https://codinghorror.com/blog\")\n        redirect_response(\"https://codinghorror.com/blog\", \"https://discourse.org\")\n        stub_request(:head, \"https://discourse.org\").to_return(doc_response)\n      end\n\n      it \"returns the final url\" do\n        final = FinalDestination.new('https://eviltrout.com', opts.merge(max_redirects: 1))\n        expect(final.resolve).to be_nil\n        expect(final.redirected?).to eq(true)\n        expect(final.status).to eq(:too_many_redirects)\n      end\n    end\n\n    context \"with a redirect to an internal IP\" do\n      before do\n        redirect_response(\"https://eviltrout.com\", \"https://private-host.com\")\n        stub_request(:head, \"https://private-host.com\").to_return(doc_response)\n      end\n\n      it \"returns the final url\" do\n        final = FinalDestination.new('https://eviltrout.com', opts)\n        expect(final.resolve).to be_nil\n        expect(final.redirected?).to eq(true)\n        expect(final.status).to eq(:invalid_address)\n      end\n    end\n\n    context \"with a redirect to login path\" do\n      before do\n        redirect_response(\"https://eviltrout.com/t/xyz/1\", \"https://eviltrout.com/login\")\n      end\n\n      it \"does not follow redirect\" do\n        final = FinalDestination.new('https://eviltrout.com/t/xyz/1', opts)\n        expect(final.resolve.to_s).to eq('https://eviltrout.com/t/xyz/1')\n        expect(final.redirected?).to eq(false)\n        expect(final.status).to eq(:resolved)\n      end\n    end\n\n    context 'follows canonical links' do\n      it 'resolves the canonical link as the final destination' do\n        canonical_follow(\"https://eviltrout.com\", \"https://codinghorror.com/blog\")\n        stub_request(:head, \"https://codinghorror.com/blog\").to_return(doc_response)\n\n        final = FinalDestination.new('https://eviltrout.com', opts.merge(follow_canonical: true))\n\n        expect(final.resolve.to_s).to eq(\"https://codinghorror.com/blog\")\n        expect(final.redirected?).to eq(false)\n        expect(final.status).to eq(:resolved)\n      end\n\n      it 'resolves the canonical link when the URL is relative' do\n        host = \"https://codinghorror.com\"\n\n        canonical_follow(\"#{host}/blog\", \"/blog/canonical\")\n        stub_request(:head, \"#{host}/blog/canonical\").to_return(doc_response)\n\n        final = FinalDestination.new(\"#{host}/blog\", opts.merge(follow_canonical: true))\n\n        expect(final.resolve.to_s).to eq(\"#{host}/blog/canonical\")\n        expect(final.redirected?).to eq(false)\n        expect(final.status).to eq(:resolved)\n      end\n\n      it 'resolves the canonical link when the URL is relative and does not start with the / symbol' do\n        host = \"https://codinghorror.com\"\n        canonical_follow(\"#{host}/blog\", \"blog/canonical\")\n        stub_request(:head, \"#{host}/blog/canonical\").to_return(doc_response)\n\n        final = FinalDestination.new(\"#{host}/blog\", opts.merge(follow_canonical: true))\n\n        expect(final.resolve.to_s).to eq(\"#{host}/blog/canonical\")\n        expect(final.redirected?).to eq(false)\n        expect(final.status).to eq(:resolved)\n      end\n\n      it \"does not follow the canonical link if it's the same as the current URL\" do\n        canonical_follow(\"https://eviltrout.com\", \"https://eviltrout.com\")\n\n        final = FinalDestination.new('https://eviltrout.com', opts.merge(follow_canonical: true))\n\n        expect(final.resolve.to_s).to eq(\"https://eviltrout.com\")\n        expect(final.redirected?).to eq(false)\n        expect(final.status).to eq(:resolved)\n      end\n\n      it \"does not follow the canonical link if it's invalid\" do\n        canonical_follow(\"https://eviltrout.com\", \"\")\n\n        final = FinalDestination.new('https://eviltrout.com', opts.merge(follow_canonical: true))\n\n        expect(final.resolve.to_s).to eq(\"https://eviltrout.com\")\n        expect(final.redirected?).to eq(false)\n        expect(final.status).to eq(:resolved)\n      end\n    end\n\n    context \"GET can be forced\" do\n      before do\n        stub_request(:head, 'https://force.get.com/posts?page=4')\n        stub_request(:get, 'https://force.get.com/posts?page=4')\n        stub_request(:get, 'https://any-subdomain.ihaveawildcard.com/some/other/content')\n        stub_request(:head, 'https://eviltrout.com/posts?page=2')\n        stub_request(:get, 'https://eviltrout.com/posts?page=2')\n        stub_request(:head, 'https://particularly.eviltrout.com/has/a/secret/plan')\n        stub_request(:get, 'https://particularly.eviltrout.com/has/a/secret/plan')\n      end\n\n      it \"will do a GET when forced\" do\n        final = FinalDestination.new('https://force.get.com/posts?page=4', opts)\n        expect(final.resolve.to_s).to eq('https://force.get.com/posts?page=4')\n        expect(final.status).to eq(:resolved)\n        expect(WebMock).to have_requested(:get, 'https://force.get.com/posts?page=4')\n        expect(WebMock).to_not have_requested(:head, 'https://force.get.com/posts?page=4')\n      end\n\n      it \"will do a HEAD if not forced\" do\n        final = FinalDestination.new('https://eviltrout.com/posts?page=2', opts)\n        expect(final.resolve.to_s).to eq('https://eviltrout.com/posts?page=2')\n        expect(final.status).to eq(:resolved)\n        expect(WebMock).to_not have_requested(:get, 'https://eviltrout.com/posts?page=2')\n        expect(WebMock).to have_requested(:head, 'https://eviltrout.com/posts?page=2')\n      end\n\n      it \"will do a GET when forced on a wildcard subdomain\" do\n        final = FinalDestination.new('https://any-subdomain.ihaveawildcard.com/some/other/content', opts)\n        expect(final.resolve.to_s).to eq('https://any-subdomain.ihaveawildcard.com/some/other/content')\n        expect(final.status).to eq(:resolved)\n        expect(WebMock).to have_requested(:get, 'https://any-subdomain.ihaveawildcard.com/some/other/content')\n        expect(WebMock).to_not have_requested(:head, 'https://any-subdomain.ihaveawildcard.com/some/other/content')\n      end\n\n      it \"will do a HEAD if on a subdomain of a forced get domain without a wildcard\" do\n        final = FinalDestination.new('https://particularly.eviltrout.com/has/a/secret/plan', opts)\n        expect(final.resolve.to_s).to eq('https://particularly.eviltrout.com/has/a/secret/plan')\n        expect(final.status).to eq(:resolved)\n        expect(WebMock).to_not have_requested(:get, 'https://particularly.eviltrout.com/has/a/secret/plan')\n        expect(WebMock).to have_requested(:head, 'https://particularly.eviltrout.com/has/a/secret/plan')\n      end\n\n    end\n\n    context \"HEAD not supported\" do\n      before do\n        stub_request(:get, 'https://eviltrout.com').to_return(\n          status: 301,\n          headers: {\n            \"Location\" => 'https://discourse.org',\n            'Set-Cookie' => 'evil=trout'\n          }\n        )\n        stub_request(:head, 'https://discourse.org')\n      end\n\n      context \"when the status code is 405\" do\n        before do\n          stub_request(:head, 'https://eviltrout.com').to_return(status: 405)\n        end\n\n        it \"will try a GET\" do\n          final = FinalDestination.new('https://eviltrout.com', opts)\n          expect(final.resolve.to_s).to eq('https://discourse.org')\n          expect(final.status).to eq(:resolved)\n          expect(final.cookie).to eq('evil=trout')\n        end\n      end\n\n      context \"when the status code is 501\" do\n        before do\n          stub_request(:head, 'https://eviltrout.com').to_return(status: 501)\n        end\n\n        it \"will try a GET\" do\n          final = FinalDestination.new('https://eviltrout.com', opts)\n          expect(final.resolve.to_s).to eq('https://discourse.org')\n          expect(final.status).to eq(:resolved)\n          expect(final.cookie).to eq('evil=trout')\n        end\n      end\n\n      it \"correctly extracts cookies during GET\" do\n        stub_request(:head, \"https://eviltrout.com\").to_return(status: 405)\n\n        stub_request(:get, \"https://eviltrout.com\")\n          .to_return(status: 302, body: \"\" , headers: {\n            \"Location\" => \"https://eviltrout.com\",\n            \"Set-Cookie\" => [\"foo=219ffwef9w0f; expires=Mon, 19-Feb-2018 10:44:24 GMT; path=/; domain=eviltrout.com\",\n                             \"bar=1\",\n                             \"baz=2; expires=Tue, 19-Feb-2019 10:14:24 GMT; path=/; domain=eviltrout.com\"]\n          })\n\n        stub_request(:head, \"https://eviltrout.com\")\n          .with(headers: { \"Cookie\" => \"bar=1; baz=2; foo=219ffwef9w0f\" })\n\n        final = FinalDestination.new(\"https://eviltrout.com\", opts)\n        expect(final.resolve.to_s).to eq(\"https://eviltrout.com\")\n        expect(final.status).to eq(:resolved)\n        expect(final.cookie).to eq(\"bar=1; baz=2; foo=219ffwef9w0f\")\n      end\n    end\n\n    it \"should use the correct format for cookies when there is only one cookie\" do\n      stub_request(:head, \"https://eviltrout.com\")\n        .to_return(status: 302, headers: {\n          \"Location\" => \"https://eviltrout.com\",\n          \"Set-Cookie\" => \"foo=219ffwef9w0f; expires=Mon, 19-Feb-2018 10:44:24 GMT; path=/; domain=eviltrout.com\"\n        })\n\n      stub_request(:head, \"https://eviltrout.com\")\n        .with(headers: { \"Cookie\" => \"foo=219ffwef9w0f\" })\n\n      final = FinalDestination.new(\"https://eviltrout.com\", opts)\n      expect(final.resolve.to_s).to eq(\"https://eviltrout.com\")\n      expect(final.status).to eq(:resolved)\n      expect(final.cookie).to eq(\"foo=219ffwef9w0f\")\n    end\n\n    it \"should use the correct format for cookies when there are multiple cookies\" do\n      stub_request(:head, \"https://eviltrout.com\")\n        .to_return(status: 302, headers: {\n          \"Location\" => \"https://eviltrout.com\",\n          \"Set-Cookie\" => [\"foo=219ffwef9w0f; expires=Mon, 19-Feb-2018 10:44:24 GMT; path=/; domain=eviltrout.com\",\n                           \"bar=1\",\n                           \"baz=2; expires=Tue, 19-Feb-2019 10:14:24 GMT; path=/; domain=eviltrout.com\"]\n        })\n\n      stub_request(:head, \"https://eviltrout.com\")\n        .with(headers: { \"Cookie\" => \"bar=1; baz=2; foo=219ffwef9w0f\" })\n\n      final = FinalDestination.new(\"https://eviltrout.com\", opts)\n      expect(final.resolve.to_s).to eq(\"https://eviltrout.com\")\n      expect(final.status).to eq(:resolved)\n      expect(final.cookie).to eq(\"bar=1; baz=2; foo=219ffwef9w0f\")\n    end\n\n    it \"persists fragment url\" do\n      origin_url = \"https://eviltrout.com/origin/lib/code/foobar.rb\"\n      upstream_url = \"https://eviltrout.com/upstream/lib/code/foobar.rb\"\n\n      redirect_response(origin_url, upstream_url)\n      stub_request(:head, upstream_url).to_return(doc_response)\n\n      final = FinalDestination.new(\"#{origin_url}#L154-L205\", opts)\n      expect(final.resolve.to_s).to eq(\"#{upstream_url}#L154-L205\")\n      expect(final.status).to eq(:resolved)\n    end\n\n    context \"content_type\" do\n      before do\n        stub_request(:head, \"https://eviltrout.com/this/is/an/image\").to_return(image_response)\n      end\n\n      it \"returns a content_type\" do\n        final = FinalDestination.new(\"https://eviltrout.com/this/is/an/image\", opts)\n        expect(final.resolve.to_s).to eq(\"https://eviltrout.com/this/is/an/image\")\n        expect(final.content_type).to eq(\"image/jpeg\")\n        expect(final.status).to eq(:resolved)\n      end\n    end\n  end\n\n  describe '.get' do\n\n    it \"can correctly stream with a redirect\" do\n      FinalDestination.clear_https_cache!(\"wikipedia.com\")\n\n      stub_request(:get, \"http://wikipedia.com/\").\n        to_return(status: 302, body: \"\" , headers: { \"location\" => \"https://wikipedia.com/\" })\n\n      # webmock does not do chunks\n      stub_request(:get, \"https://wikipedia.com/\").\n        to_return(status: 200, body: \"<html><head>\" , headers: {})\n\n      result = nil\n      chunk = nil\n\n      result = FinalDestination.new(\"http://wikipedia.com\", opts).get do |resp, c|\n        chunk = c\n        throw :done\n      end\n\n      expect(result).to eq(\"https://wikipedia.com/\")\n      expect(chunk).to eq(\"<html><head>\")\n    end\n  end\n\n  describe '.validate_uri' do\n    context \"host lookups\" do\n      it \"works for various hosts\" do\n        expect(fd('https://private-host.com').validate_uri).to eq(false)\n        expect(fd('https://eviltrout.com:443').validate_uri).to eq(true)\n      end\n    end\n  end\n\n  describe \".validate_url_format\" do\n    it \"supports http urls\" do\n      expect(fd('http://eviltrout.com').validate_uri_format).to eq(true)\n    end\n\n    it \"supports https urls\" do\n      expect(fd('https://eviltrout.com').validate_uri_format).to eq(true)\n    end\n\n    it \"doesn't support ftp urls\" do\n      expect(fd('ftp://eviltrout.com').validate_uri_format).to eq(false)\n    end\n\n    it \"doesn't support IP urls\" do\n      expect(fd('http://104.25.152.10').validate_uri_format).to eq(false)\n      expect(fd('https://[2001:abc:de:01:0:3f0:6a65:c2bf]').validate_uri_format).to eq(false)\n    end\n\n    it \"returns false for schemeless URL\" do\n      expect(fd('eviltrout.com').validate_uri_format).to eq(false)\n    end\n\n    it \"returns false for nil URL\" do\n      expect(fd(nil).validate_uri_format).to eq(false)\n    end\n\n    it \"returns false for invalid ports\" do\n      expect(fd('http://eviltrout.com:21').validate_uri_format).to eq(false)\n      expect(fd('https://eviltrout.com:8000').validate_uri_format).to eq(false)\n    end\n\n    it \"returns true for valid ports\" do\n      expect(fd('http://eviltrout.com:80').validate_uri_format).to eq(true)\n      expect(fd('https://eviltrout.com:443').validate_uri_format).to eq(true)\n    end\n  end\n\n  describe \".is_dest_valid\" do\n    it \"returns false for a valid ipv4\" do\n      expect(fd(\"https://52.84.143.67\").is_dest_valid?).to eq(true)\n      expect(fd(\"https://104.25.153.10\").is_dest_valid?).to eq(true)\n    end\n\n    it \"returns false for short ip\" do\n      lookup = lambda do |host|\n        # How IPs are looked up for single digits\n        if host == \"0\"\n          \"0.0.0.0\"\n        elsif host == \"1\"\n          \"0.0.0.1\"\n        end\n      end\n\n      expect(FinalDestination.new('https://0/logo.png', lookup_ip: lookup).is_dest_valid?).to eq(false)\n      expect(FinalDestination.new('https://1/logo.png', lookup_ip: lookup).is_dest_valid?).to eq(false)\n    end\n\n    it \"returns false for private ipv4\" do\n      expect(fd(\"https://127.0.0.1\").is_dest_valid?).to eq(false)\n      expect(fd(\"https://192.168.1.3\").is_dest_valid?).to eq(false)\n      expect(fd(\"https://10.0.0.5\").is_dest_valid?).to eq(false)\n      expect(fd(\"https://172.16.0.1\").is_dest_valid?).to eq(false)\n    end\n\n    it \"returns false for IPV6 via site settings\" do\n      SiteSetting.blocked_ip_blocks = '2001:abc:de::/48|2002:abc:de::/48'\n      expect(fd('https://[2001:abc:de:01:0:3f0:6a65:c2bf]').is_dest_valid?).to eq(false)\n      expect(fd('https://[2002:abc:de:01:0:3f0:6a65:c2bf]').is_dest_valid?).to eq(false)\n      expect(fd('https://internal-ipv6.com').is_dest_valid?).to eq(false)\n      expect(fd('https://[2003:abc:de:01:0:3f0:6a65:c2bf]').is_dest_valid?).to eq(true)\n    end\n\n    it \"ignores invalid ranges\" do\n      SiteSetting.blocked_ip_blocks = '2001:abc:de::/48|eviltrout'\n      expect(fd('https://[2001:abc:de:01:0:3f0:6a65:c2bf]').is_dest_valid?).to eq(false)\n    end\n\n    it \"returns true for public ipv6\" do\n      expect(fd(\"https://[2001:470:1:3a8::251]\").is_dest_valid?).to eq(true)\n    end\n\n    it \"returns false for private ipv6\" do\n      expect(fd(\"https://[fdd7:b450:d4d1:6b44::1]\").is_dest_valid?).to eq(false)\n    end\n\n    it \"returns true for the base uri\" do\n      SiteSetting.force_hostname = \"final-test.example.com\"\n      expect(fd(\"https://final-test.example.com/onebox\").is_dest_valid?).to eq(true)\n    end\n\n    it \"returns true for the S3 CDN url\" do\n      SiteSetting.enable_s3_uploads = true\n      SiteSetting.s3_cdn_url = \"https://s3.example.com\"\n      expect(fd(\"https://s3.example.com/some/thing\").is_dest_valid?).to eq(true)\n    end\n\n    it \"returns true for the CDN url\" do\n      GlobalSetting.stubs(:cdn_url).returns(\"https://cdn.example.com/discourse\")\n      expect(fd(\"https://cdn.example.com/some/asset\").is_dest_valid?).to eq(true)\n    end\n\n    it 'supports allowlisting via a site setting' do\n      SiteSetting.allowed_internal_hosts = 'private-host.com'\n      expect(fd(\"https://private-host.com/some/url\").is_dest_valid?).to eq(true)\n    end\n  end\n\n  describe \"https cache\" do\n    it 'will cache https lookups' do\n\n      FinalDestination.clear_https_cache!(\"wikipedia.com\")\n\n      stub_request(:head, \"http://wikipedia.com/image.png\")\n        .to_return(status: 302, body: \"\", headers: { location: 'https://wikipedia.com/image.png' })\n\n      stub_request(:head, \"https://wikipedia.com/image.png\")\n\n      fd('http://wikipedia.com/image.png').resolve\n\n      stub_request(:head, \"https://wikipedia.com/image2.png\")\n\n      fd('http://wikipedia.com/image2.png').resolve\n    end\n  end\n\n  describe \"#escape_url\" do\n    it \"correctly escapes url\" do\n      fragment_url = \"https://eviltrout.com/2016/02/25/fixing-android-performance.html#discourse-comments\"\n\n      expect(fd(fragment_url).escape_url.to_s).to eq(fragment_url)\n\n      expect(fd(\"https://eviltrout.com?s=180&#038;d=mm&#038;r=g\").escape_url.to_s)\n        .to eq(\"https://eviltrout.com?s=180&#038;d=mm&%23038;r=g\")\n\n      expect(fd(\"http://example.com/?a=\\11\\15\").escape_url.to_s).to eq(\"http://example.com/?a=%09%0D\")\n\n      expect(fd(\"https://ru.wikipedia.org/wiki/%D0%A1%D0%B2%D0%BE%D0%B1%D0%BE\").escape_url.to_s)\n        .to eq('https://ru.wikipedia.org/wiki/%D0%A1%D0%B2%D0%BE%D0%B1%D0%BE')\n\n      expect(fd('https://ru.wikipedia.org/wiki/\u0421\u0432\u043e\u0431\u043e').escape_url.to_s)\n        .to eq('https://ru.wikipedia.org/wiki/%D0%A1%D0%B2%D0%BE%D0%B1%D0%BE')\n    end\n  end\n\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\nrequire 'socket'\nrequire 'ipaddr'\nrequire 'excon'\nrequire 'rate_limiter'\nrequire 'url_helper'\n\n# Determine the final endpoint for a Web URI, following redirects\nclass FinalDestination\n  MAX_REQUEST_TIME_SECONDS = 10\n  MAX_REQUEST_SIZE_BYTES = 1_048_576 # 1024 * 1024\n\n  def self.clear_https_cache!(domain)\n    key = redis_https_key(domain)\n    Discourse.redis.without_namespace.del(key)\n  end\n\n  def self.cache_https_domain(domain)\n    key = redis_https_key(domain)\n    Discourse.redis.without_namespace.setex(key, 1.day.to_i, \"1\")\n  end\n\n  def self.is_https_domain?(domain)\n    key = redis_https_key(domain)\n    Discourse.redis.without_namespace.get(key).present?\n  end\n\n  def self.redis_https_key(domain)\n    \"HTTPS_DOMAIN_#{domain}\"\n  end\n\n  DEFAULT_USER_AGENT = \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0 Safari/605.1.15\"\n\n  attr_reader :status, :cookie, :status_code, :content_type, :ignored\n\n  def initialize(url, opts = nil)\n    @url = url\n    @uri = uri(escape_url) if @url\n\n    @opts = opts || {}\n    @force_get_hosts = @opts[:force_get_hosts] || []\n    @preserve_fragment_url_hosts = @opts[:preserve_fragment_url_hosts] || []\n    @force_custom_user_agent_hosts = @opts[:force_custom_user_agent_hosts] || []\n    @default_user_agent = @opts[:default_user_agent] || DEFAULT_USER_AGENT\n    @opts[:max_redirects] ||= 5\n    @opts[:lookup_ip] ||= lambda { |host| FinalDestination.lookup_ip(host) }\n\n    @limit = @opts[:max_redirects]\n\n    @ignored = []\n    if @limit > 0\n      ignore_redirects = [Discourse.base_url_no_prefix]\n\n      if @opts[:ignore_redirects]\n        ignore_redirects.concat(@opts[:ignore_redirects])\n      end\n\n      ignore_redirects.each do |ignore_redirect|\n        ignore_redirect = uri(ignore_redirect)\n        if ignore_redirect.present? && ignore_redirect.hostname\n          @ignored << ignore_redirect.hostname\n        end\n      end\n    end\n\n    @status = :ready\n    @follow_canonical = @opts[:follow_canonical]\n    @http_verb = http_verb(@force_get_hosts, @follow_canonical)\n    @cookie = nil\n    @limited_ips = []\n    @verbose = @opts[:verbose] || false\n    @timeout = @opts[:timeout] || nil\n    @preserve_fragment_url = @preserve_fragment_url_hosts.any? { |host| hostname_matches?(host) }\n    @validate_uri = @opts.fetch(:validate_uri) { true }\n    @user_agent = @force_custom_user_agent_hosts.any? { |host| hostname_matches?(host) } ? Onebox.options.user_agent : @default_user_agent\n  end\n\n  def self.connection_timeout\n    20\n  end\n\n  def http_verb(force_get_hosts, follow_canonical)\n    if follow_canonical || force_get_hosts.any? { |host| hostname_matches?(host) }\n      :get\n    else\n      :head\n    end\n  end\n\n  def timeout\n    @timeout || FinalDestination.connection_timeout\n  end\n\n  def redirected?\n    @limit < @opts[:max_redirects]\n  end\n\n  def request_headers\n    result = {\n      \"User-Agent\" => @user_agent,\n      \"Accept\" => \"*/*\",\n      \"Accept-Language\" => \"*\",\n      \"Host\" => @uri.hostname\n    }\n\n    result['Cookie'] = @cookie if @cookie\n\n    result\n  end\n\n  def small_get(request_headers)\n    status_code, response_headers = nil\n\n    catch(:done) do\n      Net::HTTP.start(@uri.host, @uri.port, use_ssl: @uri.is_a?(URI::HTTPS), open_timeout: timeout) do |http|\n        http.read_timeout = timeout\n        http.request_get(@uri.request_uri, request_headers) do |resp|\n          status_code = resp.code.to_i\n          response_headers = resp.to_hash\n\n          # see: https://bugs.ruby-lang.org/issues/15624\n          # if we allow response to return then body will be read\n          # got to abort without reading body\n          throw :done\n        end\n      end\n    end\n\n    [status_code, response_headers]\n  end\n\n  # this is a new interface for simply getting\n  # N bytes accounting for all internal logic\n  def get(uri = @uri, redirects = @limit, extra_headers: {}, &blk)\n    raise \"Must specify block\" unless block_given?\n\n    if uri && uri.port == 80 && FinalDestination.is_https_domain?(uri.hostname)\n      uri.scheme = \"https\"\n      uri = URI(uri.to_s)\n    end\n\n    return nil unless validate_uri\n\n    result, (location, cookie) = safe_get(uri, &blk)\n\n    if result == :redirect && (redirects == 0 || !location)\n      return nil\n    end\n\n    if result == :redirect\n      old_port = uri.port\n      location = \"#{uri.scheme}://#{uri.host}#{location}\" if location[0] == \"/\"\n      uri = uri(location)\n\n      # https redirect, so just cache that whole new domain is https\n      if old_port == 80 && uri&.port == 443 && (URI::HTTPS === uri)\n        FinalDestination.cache_https_domain(uri.hostname)\n      end\n\n      return nil if !uri\n\n      extra = nil\n      extra = { 'Cookie' => cookie } if cookie\n\n      get(uri, redirects - 1, extra_headers: extra, &blk)\n    elsif result == :ok\n      uri.to_s\n    else\n      nil\n    end\n  end\n\n  def resolve\n    if @uri && @uri.port == 80 && FinalDestination.is_https_domain?(@uri.hostname)\n      @uri.scheme = \"https\"\n      @uri = URI(@uri.to_s)\n    end\n\n    if @limit < 0\n      @status = :too_many_redirects\n      log(:warn, \"FinalDestination could not resolve URL (too many redirects): #{@uri}\") if @verbose\n      return nil\n    end\n\n    unless validate_uri\n      @status = :invalid_address\n      log(:warn, \"FinalDestination could not resolve URL (invalid URI): #{@uri}\") if @verbose\n      return nil\n    end\n\n    @ignored.each do |host|\n      if @uri&.hostname&.match?(host)\n        @status = :resolved\n        return @uri\n      end\n    end\n\n    if Oneboxer.cached_response_body_exists?(@uri.to_s)\n      @status = :resolved\n      return @uri\n    end\n\n    headers = request_headers\n    middlewares = Excon.defaults[:middlewares]\n    middlewares << Excon::Middleware::Decompress if @http_verb == :get\n\n    request_start_time = Time.now\n    response_body = +\"\"\n    request_validator = lambda do |chunk, _remaining_bytes, _total_bytes|\n      response_body << chunk\n      raise Excon::Errors::ExpectationFailed.new(\"response size too big: #{@uri.to_s}\") if response_body.bytesize > MAX_REQUEST_SIZE_BYTES\n      raise Excon::Errors::ExpectationFailed.new(\"connect timeout reached: #{@uri.to_s}\") if Time.now - request_start_time > MAX_REQUEST_TIME_SECONDS\n    end\n\n    response = Excon.public_send(@http_verb,\n      @uri.to_s,\n      read_timeout: timeout,\n      connect_timeout: timeout,\n      headers: headers,\n      middlewares: middlewares,\n      response_block: request_validator\n    )\n\n    location = nil\n    response_headers = nil\n    response_status = response.status.to_i\n\n    case response.status\n    when 200\n      # Cache body of successful `get` requests\n      if @http_verb == :get\n        if Oneboxer.cache_response_body?(@uri)\n          Oneboxer.cache_response_body(@uri.to_s, response_body)\n        end\n      end\n\n      if @follow_canonical\n        next_url = fetch_canonical_url(response_body)\n\n        if next_url.to_s.present? && next_url != @uri\n          @follow_canonical = false\n          @uri = next_url\n          @http_verb = http_verb(@force_get_hosts, @follow_canonical)\n\n          return resolve\n        end\n      end\n\n      @content_type = response.headers['Content-Type'] if response.headers.has_key?('Content-Type')\n      @status = :resolved\n      return @uri\n    when 103, 400, 405, 406, 409, 500, 501\n      response_status, small_headers = small_get(request_headers)\n\n      if response_status == 200\n        @status = :resolved\n        return @uri\n      end\n\n      response_headers = {}\n      if cookie_val = small_headers['set-cookie']\n        response_headers[:cookies] = cookie_val\n      end\n\n      if location_val = small_headers['location']\n        response_headers[:location] = location_val.join\n      end\n    end\n\n    unless response_headers\n      response_headers = {\n        cookies: response.data[:cookies] || response.headers[:\"set-cookie\"],\n        location: response.headers[:location]\n      }\n    end\n\n    if (300..399).include?(response_status)\n      location = response_headers[:location]\n    end\n\n    if cookies = response_headers[:cookies]\n      @cookie = Array.wrap(cookies).map { |c| c.split(';').first.strip }.join('; ')\n    end\n\n    if location\n      redirect_uri = uri(location)\n      if @uri.host == redirect_uri.host && (redirect_uri.path =~ /\\/login/ || redirect_uri.path =~ /\\/session/)\n        @status = :resolved\n        return @uri\n      end\n\n      old_port = @uri.port\n      location = \"#{location}##{@uri.fragment}\" if @preserve_fragment_url && @uri.fragment.present?\n      location = \"#{@uri.scheme}://#{@uri.host}#{location}\" if location[0] == \"/\"\n      @uri = uri(location)\n      @limit -= 1\n\n      # https redirect, so just cache that whole new domain is https\n      if old_port == 80 && @uri.port == 443 && (URI::HTTPS === @uri)\n        FinalDestination.cache_https_domain(@uri.hostname)\n      end\n\n      return resolve\n    end\n\n    # this is weird an exception seems better\n    @status = :failure\n    @status_code = response.status\n\n    log(:warn, \"FinalDestination could not resolve URL (status #{response.status}): #{@uri}\") if @verbose\n    nil\n  rescue Excon::Errors::Timeout\n    log(:warn, \"FinalDestination could not resolve URL (timeout): #{@uri}\") if @verbose\n    nil\n  end\n\n  def validate_uri\n    !@validate_uri || (validate_uri_format && is_dest_valid?)\n  end\n\n  def validate_uri_format\n    return false unless @uri\n    return false unless ['https', 'http'].include?(@uri.scheme)\n    return false if @uri.scheme == 'http' && @uri.port != 80\n    return false if @uri.scheme == 'https' && @uri.port != 443\n\n    # Disallow IP based crawling\n    (IPAddr.new(@uri.hostname) rescue nil).nil?\n  end\n\n  def hostname\n    @uri.hostname\n  end\n\n  def hostname_matches?(url)\n    url = uri(url)\n\n    if @uri&.hostname.present? && url&.hostname.present?\n      hostname_parts = url.hostname.split('.')\n      has_wildcard = hostname_parts.first == '*'\n\n      if has_wildcard\n        @uri.hostname.end_with?(hostname_parts[1..-1].join('.'))\n      else\n        @uri.hostname == url.hostname\n      end\n    end\n  end\n\n  def is_dest_valid?\n    return false unless @uri && @uri.host\n\n    # Allowlisted hosts\n    return true if hostname_matches?(SiteSetting.Upload.s3_cdn_url) ||\n      hostname_matches?(GlobalSetting.try(:cdn_url)) ||\n      hostname_matches?(Discourse.base_url_no_prefix)\n\n    if SiteSetting.allowed_internal_hosts.present?\n      return true if SiteSetting.allowed_internal_hosts.split(\"|\").any? { |h| h.downcase == @uri.hostname.downcase }\n    end\n\n    address_s = @opts[:lookup_ip].call(@uri.hostname)\n    return false unless address_s\n\n    address = IPAddr.new(address_s)\n\n    if private_ranges.any? { |r| r === address }\n      @status = :invalid_address\n      return false\n    end\n\n    # Rate limit how often this IP can be crawled\n    if !@opts[:skip_rate_limit] && !@limited_ips.include?(address)\n      @limited_ips << address\n      RateLimiter.new(nil, \"crawl-destination-ip:#{address_s}\", 1000, 1.hour).performed!\n    end\n\n    true\n  rescue RateLimiter::LimitExceeded\n    false\n  end\n\n  def escape_url\n    UrlHelper.escape_uri(@url)\n  end\n\n  def private_ranges\n    FinalDestination.standard_private_ranges +\n      SiteSetting.blocked_ip_blocks.split('|').map { |r| IPAddr.new(r) rescue nil }.compact\n  end\n\n  def log(log_level, message)\n    return if @status_code == 404\n\n    Rails.logger.public_send(\n      log_level,\n      \"#{RailsMultisite::ConnectionManagement.current_db}: #{message}\"\n    )\n  end\n\n  def self.standard_private_ranges\n    @private_ranges ||= [\n      IPAddr.new('0.0.0.0/8'),\n      IPAddr.new('127.0.0.1'),\n      IPAddr.new('172.16.0.0/12'),\n      IPAddr.new('192.168.0.0/16'),\n      IPAddr.new('10.0.0.0/8'),\n      IPAddr.new('fc00::/7')\n    ]\n  end\n\n  def self.lookup_ip(host)\n    if Rails.env.test?\n      \"1.1.1.1\"\n    else\n      IPSocket::getaddress(host)\n    end\n  rescue SocketError\n    nil\n  end\n\n  protected\n\n  def safe_get(uri)\n    result = nil\n    unsafe_close = false\n\n    safe_session(uri) do |http|\n      headers = request_headers.merge(\n        'Accept-Encoding' => 'gzip',\n        'Host' => uri.host\n      )\n\n      req = Net::HTTP::Get.new(uri.request_uri, headers)\n\n      http.request(req) do |resp|\n        if Net::HTTPRedirection === resp\n          result = :redirect, [resp['location'], resp['Set-Cookie']]\n        end\n\n        if Net::HTTPSuccess === resp\n          resp.decode_content = true\n          resp.read_body do |chunk|\n            read_next = true\n\n            catch(:done) do\n              if read_next\n                read_next = false\n                yield resp, chunk, uri\n                read_next = true\n              end\n            end\n\n            # no clean way of finishing abruptly cause\n            # response likes reading till the end\n            if !read_next\n              unsafe_close = true\n              http.finish\n              raise StandardError\n            end\n          end\n          result = :ok\n        else\n          catch(:done) do\n            yield resp, nil, nil\n          end\n        end\n      end\n    end\n\n    result\n  rescue StandardError\n    unsafe_close ? :ok : raise\n  end\n\n  def safe_session(uri)\n    Net::HTTP.start(uri.host, uri.port, use_ssl: (uri.scheme == \"https\"), open_timeout: timeout) do |http|\n      http.read_timeout = timeout\n      yield http\n    end\n  end\n\n  private\n\n  def uri(location)\n    begin\n      URI.parse(location)\n    rescue URI::Error\n    end\n  end\n\n  def fetch_canonical_url(body)\n    return if body.blank?\n\n    canonical_element = Nokogiri::HTML5(body).at(\"link[rel='canonical']\")\n    return if canonical_element.nil?\n    canonical_uri = uri(canonical_element['href'])\n    return if canonical_uri.blank?\n\n    return canonical_uri if canonical_uri.host.present?\n    parts = [@uri.host, canonical_uri.to_s]\n    complete_url = canonical_uri.to_s.starts_with?('/') ? parts.join('') : parts.join('/')\n    complete_url = \"#{@uri.scheme}://#{complete_url}\" if @uri.scheme\n\n    uri(complete_url)\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'rails_helper'\nrequire 'final_destination'\n\ndescribe FinalDestination do\n\n  let(:opts) do\n    {\n      ignore_redirects: ['https://ignore-me.com'],\n\n      force_get_hosts: ['https://force.get.com', 'https://*.ihaveawildcard.com/'],\n\n      preserve_fragment_url_hosts: ['https://eviltrout.com'],\n\n      # avoid IP lookups in test\n      lookup_ip: lambda do |host|\n        case host\n        when 'eviltrout.com' then '52.84.143.152'\n        when 'particularly.eviltrout.com' then '52.84.143.152'\n        when 'codinghorror.com' then '91.146.108.148'\n        when 'discourse.org' then '104.25.152.10'\n        when 'some_thing.example.com' then '104.25.152.10'\n        when 'private-host.com' then '192.168.10.1'\n        when 'internal-ipv6.com' then '2001:abc:de:01:3:3d0:6a65:c2bf'\n        when 'ignore-me.com' then '53.84.143.152'\n        when 'force.get.com' then '22.102.29.40'\n        when 'any-subdomain.ihaveawildcard.com' then '104.25.152.11'\n        when 'wikipedia.com' then '1.2.3.4'\n        else\n          as_ip = IPAddr.new(host)\n          host\n        end\n      end\n    }\n  end\n\n  let(:doc_response) do\n    {\n      status: 200,\n      headers: { \"Content-Type\" => \"text/html\" }\n    }\n  end\n\n  let(:image_response) do\n    {\n      status: 200,\n      headers: { \"Content-Type\" => \"image/jpeg\" }\n    }\n  end\n\n  let(:body_response) do\n    {\n      status: 200,\n      body: \"<body>test</body>\"\n    }\n  end\n\n  def canonical_follow(from, dest)\n    stub_request(:get, from).to_return(\n      status: 200,\n      body: \"<head><link rel=\\\"canonical\\\" href=\\\"#{dest}\\\"></head>\"\n    )\n  end\n\n  def redirect_response(from, dest)\n    stub_request(:head, from).to_return(\n      status: 302,\n      headers: { \"Location\" => dest }\n    )\n  end\n\n  def fd(url)\n    FinalDestination.new(url, opts)\n  end\n\n  it 'correctly parses ignored hostnames' do\n    fd = FinalDestination.new('https://meta.discourse.org',\n      ignore_redirects: ['http://google.com', 'youtube.com', 'https://meta.discourse.org', '://bing.com']\n    )\n\n    expect(fd.ignored).to eq(['test.localhost', 'google.com', 'meta.discourse.org'])\n  end\n\n  describe '.resolve' do\n\n    it \"has a ready status code before anything happens\" do\n      expect(fd('https://eviltrout.com').status).to eq(:ready)\n    end\n\n    it \"returns nil for an invalid url\" do\n      expect(fd(nil).resolve).to be_nil\n      expect(fd('asdf').resolve).to be_nil\n    end\n\n    it \"returns nil when read timeouts\" do\n      Excon.expects(:public_send).raises(Excon::Errors::Timeout)\n\n      expect(fd('https://discourse.org').resolve).to eq(nil)\n    end\n\n    context \"without redirects\" do\n      before do\n        stub_request(:head, \"https://eviltrout.com\").to_return(doc_response)\n      end\n\n      it \"returns the final url\" do\n        final = FinalDestination.new('https://eviltrout.com', opts)\n        expect(final.resolve.to_s).to eq('https://eviltrout.com')\n        expect(final.redirected?).to eq(false)\n        expect(final.status).to eq(:resolved)\n      end\n    end\n\n    it \"ignores redirects\" do\n      final = FinalDestination.new('https://ignore-me.com/some-url', opts)\n      expect(final.resolve.to_s).to eq('https://ignore-me.com/some-url')\n      expect(final.redirected?).to eq(false)\n      expect(final.status).to eq(:resolved)\n    end\n\n    context \"underscores in URLs\" do\n      before do\n        stub_request(:head, 'https://some_thing.example.com').to_return(doc_response)\n      end\n\n      it \"doesn't raise errors with underscores in urls\" do\n        final = FinalDestination.new('https://some_thing.example.com', opts)\n        expect(final.resolve.to_s).to eq('https://some_thing.example.com')\n        expect(final.redirected?).to eq(false)\n        expect(final.status).to eq(:resolved)\n      end\n    end\n\n    context \"with a couple of redirects\" do\n      before do\n        redirect_response(\"https://eviltrout.com\", \"https://codinghorror.com/blog\")\n        redirect_response(\"https://codinghorror.com/blog\", \"https://discourse.org\")\n        stub_request(:head, \"https://discourse.org\").to_return(doc_response)\n      end\n\n      it \"returns the final url\" do\n        final = FinalDestination.new('https://eviltrout.com', opts)\n        expect(final.resolve.to_s).to eq('https://discourse.org')\n        expect(final.redirected?).to eq(true)\n        expect(final.status).to eq(:resolved)\n      end\n    end\n\n    context \"with too many redirects\" do\n      before do\n        redirect_response(\"https://eviltrout.com\", \"https://codinghorror.com/blog\")\n        redirect_response(\"https://codinghorror.com/blog\", \"https://discourse.org\")\n        stub_request(:head, \"https://discourse.org\").to_return(doc_response)\n      end\n\n      it \"returns the final url\" do\n        final = FinalDestination.new('https://eviltrout.com', opts.merge(max_redirects: 1))\n        expect(final.resolve).to be_nil\n        expect(final.redirected?).to eq(true)\n        expect(final.status).to eq(:too_many_redirects)\n      end\n    end\n\n    context \"with a redirect to an internal IP\" do\n      before do\n        redirect_response(\"https://eviltrout.com\", \"https://private-host.com\")\n        stub_request(:head, \"https://private-host.com\").to_return(doc_response)\n      end\n\n      it \"returns the final url\" do\n        final = FinalDestination.new('https://eviltrout.com', opts)\n        expect(final.resolve).to be_nil\n        expect(final.redirected?).to eq(true)\n        expect(final.status).to eq(:invalid_address)\n      end\n    end\n\n    context \"with a redirect to login path\" do\n      before do\n        redirect_response(\"https://eviltrout.com/t/xyz/1\", \"https://eviltrout.com/login\")\n      end\n\n      it \"does not follow redirect\" do\n        final = FinalDestination.new('https://eviltrout.com/t/xyz/1', opts)\n        expect(final.resolve.to_s).to eq('https://eviltrout.com/t/xyz/1')\n        expect(final.redirected?).to eq(false)\n        expect(final.status).to eq(:resolved)\n      end\n    end\n\n    it 'raises error when response is too big' do\n      stub_const(described_class, \"MAX_REQUEST_SIZE_BYTES\", 1) do\n        stub_request(:get, \"https://codinghorror.com/blog\").to_return(body_response)\n        final = FinalDestination.new('https://codinghorror.com/blog', opts.merge(follow_canonical: true))\n        expect { final.resolve }.to raise_error(Excon::Errors::ExpectationFailed, \"response size too big: https://codinghorror.com/blog\")\n      end\n    end\n\n    it 'raises error when response is too slow' do\n      stub_request(:get, \"https://codinghorror.com/blog\").to_return(lambda { |request| freeze_time(11.seconds.from_now) ; body_response })\n      final = FinalDestination.new('https://codinghorror.com/blog', opts.merge(follow_canonical: true))\n      expect { final.resolve }.to raise_error(Excon::Errors::ExpectationFailed, \"connect timeout reached: https://codinghorror.com/blog\")\n    end\n\n    context 'follows canonical links' do\n      it 'resolves the canonical link as the final destination' do\n        canonical_follow(\"https://eviltrout.com\", \"https://codinghorror.com/blog\")\n        stub_request(:head, \"https://codinghorror.com/blog\").to_return(doc_response)\n\n        final = FinalDestination.new('https://eviltrout.com', opts.merge(follow_canonical: true))\n\n        expect(final.resolve.to_s).to eq(\"https://codinghorror.com/blog\")\n        expect(final.redirected?).to eq(false)\n        expect(final.status).to eq(:resolved)\n      end\n\n      it 'resolves the canonical link when the URL is relative' do\n        host = \"https://codinghorror.com\"\n\n        canonical_follow(\"#{host}/blog\", \"/blog/canonical\")\n        stub_request(:head, \"#{host}/blog/canonical\").to_return(doc_response)\n\n        final = FinalDestination.new(\"#{host}/blog\", opts.merge(follow_canonical: true))\n\n        expect(final.resolve.to_s).to eq(\"#{host}/blog/canonical\")\n        expect(final.redirected?).to eq(false)\n        expect(final.status).to eq(:resolved)\n      end\n\n      it 'resolves the canonical link when the URL is relative and does not start with the / symbol' do\n        host = \"https://codinghorror.com\"\n        canonical_follow(\"#{host}/blog\", \"blog/canonical\")\n        stub_request(:head, \"#{host}/blog/canonical\").to_return(doc_response)\n\n        final = FinalDestination.new(\"#{host}/blog\", opts.merge(follow_canonical: true))\n\n        expect(final.resolve.to_s).to eq(\"#{host}/blog/canonical\")\n        expect(final.redirected?).to eq(false)\n        expect(final.status).to eq(:resolved)\n      end\n\n      it \"does not follow the canonical link if it's the same as the current URL\" do\n        canonical_follow(\"https://eviltrout.com\", \"https://eviltrout.com\")\n\n        final = FinalDestination.new('https://eviltrout.com', opts.merge(follow_canonical: true))\n\n        expect(final.resolve.to_s).to eq(\"https://eviltrout.com\")\n        expect(final.redirected?).to eq(false)\n        expect(final.status).to eq(:resolved)\n      end\n\n      it \"does not follow the canonical link if it's invalid\" do\n        canonical_follow(\"https://eviltrout.com\", \"\")\n\n        final = FinalDestination.new('https://eviltrout.com', opts.merge(follow_canonical: true))\n\n        expect(final.resolve.to_s).to eq(\"https://eviltrout.com\")\n        expect(final.redirected?).to eq(false)\n        expect(final.status).to eq(:resolved)\n      end\n    end\n\n    context \"GET can be forced\" do\n      before do\n        stub_request(:head, 'https://force.get.com/posts?page=4')\n        stub_request(:get, 'https://force.get.com/posts?page=4')\n        stub_request(:get, 'https://any-subdomain.ihaveawildcard.com/some/other/content')\n        stub_request(:head, 'https://eviltrout.com/posts?page=2')\n        stub_request(:get, 'https://eviltrout.com/posts?page=2')\n        stub_request(:head, 'https://particularly.eviltrout.com/has/a/secret/plan')\n        stub_request(:get, 'https://particularly.eviltrout.com/has/a/secret/plan')\n      end\n\n      it \"will do a GET when forced\" do\n        final = FinalDestination.new('https://force.get.com/posts?page=4', opts)\n        expect(final.resolve.to_s).to eq('https://force.get.com/posts?page=4')\n        expect(final.status).to eq(:resolved)\n        expect(WebMock).to have_requested(:get, 'https://force.get.com/posts?page=4')\n        expect(WebMock).to_not have_requested(:head, 'https://force.get.com/posts?page=4')\n      end\n\n      it \"will do a HEAD if not forced\" do\n        final = FinalDestination.new('https://eviltrout.com/posts?page=2', opts)\n        expect(final.resolve.to_s).to eq('https://eviltrout.com/posts?page=2')\n        expect(final.status).to eq(:resolved)\n        expect(WebMock).to_not have_requested(:get, 'https://eviltrout.com/posts?page=2')\n        expect(WebMock).to have_requested(:head, 'https://eviltrout.com/posts?page=2')\n      end\n\n      it \"will do a GET when forced on a wildcard subdomain\" do\n        final = FinalDestination.new('https://any-subdomain.ihaveawildcard.com/some/other/content', opts)\n        expect(final.resolve.to_s).to eq('https://any-subdomain.ihaveawildcard.com/some/other/content')\n        expect(final.status).to eq(:resolved)\n        expect(WebMock).to have_requested(:get, 'https://any-subdomain.ihaveawildcard.com/some/other/content')\n        expect(WebMock).to_not have_requested(:head, 'https://any-subdomain.ihaveawildcard.com/some/other/content')\n      end\n\n      it \"will do a HEAD if on a subdomain of a forced get domain without a wildcard\" do\n        final = FinalDestination.new('https://particularly.eviltrout.com/has/a/secret/plan', opts)\n        expect(final.resolve.to_s).to eq('https://particularly.eviltrout.com/has/a/secret/plan')\n        expect(final.status).to eq(:resolved)\n        expect(WebMock).to_not have_requested(:get, 'https://particularly.eviltrout.com/has/a/secret/plan')\n        expect(WebMock).to have_requested(:head, 'https://particularly.eviltrout.com/has/a/secret/plan')\n      end\n\n    end\n\n    context \"HEAD not supported\" do\n      before do\n        stub_request(:get, 'https://eviltrout.com').to_return(\n          status: 301,\n          headers: {\n            \"Location\" => 'https://discourse.org',\n            'Set-Cookie' => 'evil=trout'\n          }\n        )\n        stub_request(:head, 'https://discourse.org')\n      end\n\n      context \"when the status code is 405\" do\n        before do\n          stub_request(:head, 'https://eviltrout.com').to_return(status: 405)\n        end\n\n        it \"will try a GET\" do\n          final = FinalDestination.new('https://eviltrout.com', opts)\n          expect(final.resolve.to_s).to eq('https://discourse.org')\n          expect(final.status).to eq(:resolved)\n          expect(final.cookie).to eq('evil=trout')\n        end\n      end\n\n      context \"when the status code is 501\" do\n        before do\n          stub_request(:head, 'https://eviltrout.com').to_return(status: 501)\n        end\n\n        it \"will try a GET\" do\n          final = FinalDestination.new('https://eviltrout.com', opts)\n          expect(final.resolve.to_s).to eq('https://discourse.org')\n          expect(final.status).to eq(:resolved)\n          expect(final.cookie).to eq('evil=trout')\n        end\n      end\n\n      it \"correctly extracts cookies during GET\" do\n        stub_request(:head, \"https://eviltrout.com\").to_return(status: 405)\n\n        stub_request(:get, \"https://eviltrout.com\")\n          .to_return(status: 302, body: \"\" , headers: {\n            \"Location\" => \"https://eviltrout.com\",\n            \"Set-Cookie\" => [\"foo=219ffwef9w0f; expires=Mon, 19-Feb-2018 10:44:24 GMT; path=/; domain=eviltrout.com\",\n                             \"bar=1\",\n                             \"baz=2; expires=Tue, 19-Feb-2019 10:14:24 GMT; path=/; domain=eviltrout.com\"]\n          })\n\n        stub_request(:head, \"https://eviltrout.com\")\n          .with(headers: { \"Cookie\" => \"bar=1; baz=2; foo=219ffwef9w0f\" })\n\n        final = FinalDestination.new(\"https://eviltrout.com\", opts)\n        expect(final.resolve.to_s).to eq(\"https://eviltrout.com\")\n        expect(final.status).to eq(:resolved)\n        expect(final.cookie).to eq(\"bar=1; baz=2; foo=219ffwef9w0f\")\n      end\n    end\n\n    it \"should use the correct format for cookies when there is only one cookie\" do\n      stub_request(:head, \"https://eviltrout.com\")\n        .to_return(status: 302, headers: {\n          \"Location\" => \"https://eviltrout.com\",\n          \"Set-Cookie\" => \"foo=219ffwef9w0f; expires=Mon, 19-Feb-2018 10:44:24 GMT; path=/; domain=eviltrout.com\"\n        })\n\n      stub_request(:head, \"https://eviltrout.com\")\n        .with(headers: { \"Cookie\" => \"foo=219ffwef9w0f\" })\n\n      final = FinalDestination.new(\"https://eviltrout.com\", opts)\n      expect(final.resolve.to_s).to eq(\"https://eviltrout.com\")\n      expect(final.status).to eq(:resolved)\n      expect(final.cookie).to eq(\"foo=219ffwef9w0f\")\n    end\n\n    it \"should use the correct format for cookies when there are multiple cookies\" do\n      stub_request(:head, \"https://eviltrout.com\")\n        .to_return(status: 302, headers: {\n          \"Location\" => \"https://eviltrout.com\",\n          \"Set-Cookie\" => [\"foo=219ffwef9w0f; expires=Mon, 19-Feb-2018 10:44:24 GMT; path=/; domain=eviltrout.com\",\n                           \"bar=1\",\n                           \"baz=2; expires=Tue, 19-Feb-2019 10:14:24 GMT; path=/; domain=eviltrout.com\"]\n        })\n\n      stub_request(:head, \"https://eviltrout.com\")\n        .with(headers: { \"Cookie\" => \"bar=1; baz=2; foo=219ffwef9w0f\" })\n\n      final = FinalDestination.new(\"https://eviltrout.com\", opts)\n      expect(final.resolve.to_s).to eq(\"https://eviltrout.com\")\n      expect(final.status).to eq(:resolved)\n      expect(final.cookie).to eq(\"bar=1; baz=2; foo=219ffwef9w0f\")\n    end\n\n    it \"persists fragment url\" do\n      origin_url = \"https://eviltrout.com/origin/lib/code/foobar.rb\"\n      upstream_url = \"https://eviltrout.com/upstream/lib/code/foobar.rb\"\n\n      redirect_response(origin_url, upstream_url)\n      stub_request(:head, upstream_url).to_return(doc_response)\n\n      final = FinalDestination.new(\"#{origin_url}#L154-L205\", opts)\n      expect(final.resolve.to_s).to eq(\"#{upstream_url}#L154-L205\")\n      expect(final.status).to eq(:resolved)\n    end\n\n    context \"content_type\" do\n      before do\n        stub_request(:head, \"https://eviltrout.com/this/is/an/image\").to_return(image_response)\n      end\n\n      it \"returns a content_type\" do\n        final = FinalDestination.new(\"https://eviltrout.com/this/is/an/image\", opts)\n        expect(final.resolve.to_s).to eq(\"https://eviltrout.com/this/is/an/image\")\n        expect(final.content_type).to eq(\"image/jpeg\")\n        expect(final.status).to eq(:resolved)\n      end\n    end\n  end\n\n  describe '.get' do\n\n    it \"can correctly stream with a redirect\" do\n      FinalDestination.clear_https_cache!(\"wikipedia.com\")\n\n      stub_request(:get, \"http://wikipedia.com/\").\n        to_return(status: 302, body: \"\" , headers: { \"location\" => \"https://wikipedia.com/\" })\n\n      # webmock does not do chunks\n      stub_request(:get, \"https://wikipedia.com/\").\n        to_return(status: 200, body: \"<html><head>\" , headers: {})\n\n      result = nil\n      chunk = nil\n\n      result = FinalDestination.new(\"http://wikipedia.com\", opts).get do |resp, c|\n        chunk = c\n        throw :done\n      end\n\n      expect(result).to eq(\"https://wikipedia.com/\")\n      expect(chunk).to eq(\"<html><head>\")\n    end\n  end\n\n  describe '.validate_uri' do\n    context \"host lookups\" do\n      it \"works for various hosts\" do\n        expect(fd('https://private-host.com').validate_uri).to eq(false)\n        expect(fd('https://eviltrout.com:443').validate_uri).to eq(true)\n      end\n    end\n  end\n\n  describe \".validate_url_format\" do\n    it \"supports http urls\" do\n      expect(fd('http://eviltrout.com').validate_uri_format).to eq(true)\n    end\n\n    it \"supports https urls\" do\n      expect(fd('https://eviltrout.com').validate_uri_format).to eq(true)\n    end\n\n    it \"doesn't support ftp urls\" do\n      expect(fd('ftp://eviltrout.com').validate_uri_format).to eq(false)\n    end\n\n    it \"doesn't support IP urls\" do\n      expect(fd('http://104.25.152.10').validate_uri_format).to eq(false)\n      expect(fd('https://[2001:abc:de:01:0:3f0:6a65:c2bf]').validate_uri_format).to eq(false)\n    end\n\n    it \"returns false for schemeless URL\" do\n      expect(fd('eviltrout.com').validate_uri_format).to eq(false)\n    end\n\n    it \"returns false for nil URL\" do\n      expect(fd(nil).validate_uri_format).to eq(false)\n    end\n\n    it \"returns false for invalid ports\" do\n      expect(fd('http://eviltrout.com:21').validate_uri_format).to eq(false)\n      expect(fd('https://eviltrout.com:8000').validate_uri_format).to eq(false)\n    end\n\n    it \"returns true for valid ports\" do\n      expect(fd('http://eviltrout.com:80').validate_uri_format).to eq(true)\n      expect(fd('https://eviltrout.com:443').validate_uri_format).to eq(true)\n    end\n  end\n\n  describe \".is_dest_valid\" do\n    it \"returns false for a valid ipv4\" do\n      expect(fd(\"https://52.84.143.67\").is_dest_valid?).to eq(true)\n      expect(fd(\"https://104.25.153.10\").is_dest_valid?).to eq(true)\n    end\n\n    it \"returns false for short ip\" do\n      lookup = lambda do |host|\n        # How IPs are looked up for single digits\n        if host == \"0\"\n          \"0.0.0.0\"\n        elsif host == \"1\"\n          \"0.0.0.1\"\n        end\n      end\n\n      expect(FinalDestination.new('https://0/logo.png', lookup_ip: lookup).is_dest_valid?).to eq(false)\n      expect(FinalDestination.new('https://1/logo.png', lookup_ip: lookup).is_dest_valid?).to eq(false)\n    end\n\n    it \"returns false for private ipv4\" do\n      expect(fd(\"https://127.0.0.1\").is_dest_valid?).to eq(false)\n      expect(fd(\"https://192.168.1.3\").is_dest_valid?).to eq(false)\n      expect(fd(\"https://10.0.0.5\").is_dest_valid?).to eq(false)\n      expect(fd(\"https://172.16.0.1\").is_dest_valid?).to eq(false)\n    end\n\n    it \"returns false for IPV6 via site settings\" do\n      SiteSetting.blocked_ip_blocks = '2001:abc:de::/48|2002:abc:de::/48'\n      expect(fd('https://[2001:abc:de:01:0:3f0:6a65:c2bf]').is_dest_valid?).to eq(false)\n      expect(fd('https://[2002:abc:de:01:0:3f0:6a65:c2bf]').is_dest_valid?).to eq(false)\n      expect(fd('https://internal-ipv6.com').is_dest_valid?).to eq(false)\n      expect(fd('https://[2003:abc:de:01:0:3f0:6a65:c2bf]').is_dest_valid?).to eq(true)\n    end\n\n    it \"ignores invalid ranges\" do\n      SiteSetting.blocked_ip_blocks = '2001:abc:de::/48|eviltrout'\n      expect(fd('https://[2001:abc:de:01:0:3f0:6a65:c2bf]').is_dest_valid?).to eq(false)\n    end\n\n    it \"returns true for public ipv6\" do\n      expect(fd(\"https://[2001:470:1:3a8::251]\").is_dest_valid?).to eq(true)\n    end\n\n    it \"returns false for private ipv6\" do\n      expect(fd(\"https://[fdd7:b450:d4d1:6b44::1]\").is_dest_valid?).to eq(false)\n    end\n\n    it \"returns true for the base uri\" do\n      SiteSetting.force_hostname = \"final-test.example.com\"\n      expect(fd(\"https://final-test.example.com/onebox\").is_dest_valid?).to eq(true)\n    end\n\n    it \"returns true for the S3 CDN url\" do\n      SiteSetting.enable_s3_uploads = true\n      SiteSetting.s3_cdn_url = \"https://s3.example.com\"\n      expect(fd(\"https://s3.example.com/some/thing\").is_dest_valid?).to eq(true)\n    end\n\n    it \"returns true for the CDN url\" do\n      GlobalSetting.stubs(:cdn_url).returns(\"https://cdn.example.com/discourse\")\n      expect(fd(\"https://cdn.example.com/some/asset\").is_dest_valid?).to eq(true)\n    end\n\n    it 'supports allowlisting via a site setting' do\n      SiteSetting.allowed_internal_hosts = 'private-host.com'\n      expect(fd(\"https://private-host.com/some/url\").is_dest_valid?).to eq(true)\n    end\n  end\n\n  describe \"https cache\" do\n    it 'will cache https lookups' do\n\n      FinalDestination.clear_https_cache!(\"wikipedia.com\")\n\n      stub_request(:head, \"http://wikipedia.com/image.png\")\n        .to_return(status: 302, body: \"\", headers: { location: 'https://wikipedia.com/image.png' })\n\n      stub_request(:head, \"https://wikipedia.com/image.png\")\n\n      fd('http://wikipedia.com/image.png').resolve\n\n      stub_request(:head, \"https://wikipedia.com/image2.png\")\n\n      fd('http://wikipedia.com/image2.png').resolve\n    end\n  end\n\n  describe \"#escape_url\" do\n    it \"correctly escapes url\" do\n      fragment_url = \"https://eviltrout.com/2016/02/25/fixing-android-performance.html#discourse-comments\"\n\n      expect(fd(fragment_url).escape_url.to_s).to eq(fragment_url)\n\n      expect(fd(\"https://eviltrout.com?s=180&#038;d=mm&#038;r=g\").escape_url.to_s)\n        .to eq(\"https://eviltrout.com?s=180&#038;d=mm&%23038;r=g\")\n\n      expect(fd(\"http://example.com/?a=\\11\\15\").escape_url.to_s).to eq(\"http://example.com/?a=%09%0D\")\n\n      expect(fd(\"https://ru.wikipedia.org/wiki/%D0%A1%D0%B2%D0%BE%D0%B1%D0%BE\").escape_url.to_s)\n        .to eq('https://ru.wikipedia.org/wiki/%D0%A1%D0%B2%D0%BE%D0%B1%D0%BE')\n\n      expect(fd('https://ru.wikipedia.org/wiki/\u0421\u0432\u043e\u0431\u043e').escape_url.to_s)\n        .to eq('https://ru.wikipedia.org/wiki/%D0%A1%D0%B2%D0%BE%D0%B1%D0%BE')\n    end\n  end\n\nend\n"], "filenames": ["lib/final_destination.rb", "spec/components/final_destination_spec.rb"], "buggy_code_start_loc": [10, 51], "buggy_code_end_loc": [229, 182], "fixing_code_start_loc": [11, 52], "fixing_code_end_loc": [240, 204], "type": "CWE-835", "message": "Discourse is an open source discussion platform. In versions prior to 2.8.1 in the `stable` branch, 2.9.0.beta2 in the `beta` branch, and 2.9.0.beta2 in the `tests-passed` branch, users can trigger a Denial of Service attack by posting a streaming URL. Parsing Oneboxes in the background job trigger an infinite loop, which cause memory leaks. This issue is patched in version 2.8.1 of the `stable` branch, 2.9.0.beta2 of the `beta` branch, and 2.9.0.beta2 of the `tests-passed` branch. As a workaround, disable onebox in admin panel completely or specify allow list of domains that will be oneboxed.", "other": {"cve": {"id": "CVE-2022-23641", "sourceIdentifier": "security-advisories@github.com", "published": "2022-02-15T21:15:07.657", "lastModified": "2022-02-24T02:20:23.657", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Discourse is an open source discussion platform. In versions prior to 2.8.1 in the `stable` branch, 2.9.0.beta2 in the `beta` branch, and 2.9.0.beta2 in the `tests-passed` branch, users can trigger a Denial of Service attack by posting a streaming URL. Parsing Oneboxes in the background job trigger an infinite loop, which cause memory leaks. This issue is patched in version 2.8.1 of the `stable` branch, 2.9.0.beta2 of the `beta` branch, and 2.9.0.beta2 of the `tests-passed` branch. As a workaround, disable onebox in admin panel completely or specify allow list of domains that will be oneboxed."}, {"lang": "es", "value": "Discourse es una plataforma de debate de c\u00f3digo abierto. En las versiones anteriores a 2.8.1 en la rama \"stable\", versi\u00f3n 2.9.0.beta2 en la rama \"beta\" y versi\u00f3n 2.9.0.beta2 en la rama \"tests-passed\", los usuarios pueden desencadenar un ataque de Denegaci\u00f3n de Servicio al publicar una URL en streaming. El an\u00e1lisis de Oneboxes en el trabajo de fondo desencadena un bucle infinito, que causa p\u00e9rdidas de memoria. Este problema est\u00e1 parcheado en versi\u00f3n 2.8.1 de la rama \"stable\", en versi\u00f3n 2.9.0.beta2 de la rama \"beta\" y en versi\u00f3n 2.9.0.beta2 de la rama \"tests-passed\". Como medida de mitigaci\u00f3n, deshabilite por completo el onebox en el panel de administraci\u00f3n o especifique la lista de dominios permitidos para el oneboxing"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-835"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-835"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.8.1", "matchCriteriaId": "F30E662C-449F-46D7-BB7B-6DF48073B795"}]}]}], "references": [{"url": "https://github.com/discourse/discourse/commit/a34075d205a8857e29574ffd82aaece0c467565e", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/discourse/discourse/pull/15927", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/discourse/discourse/security/advisories/GHSA-22xw-f62v-cfxv", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/discourse/discourse/commit/a34075d205a8857e29574ffd82aaece0c467565e"}}