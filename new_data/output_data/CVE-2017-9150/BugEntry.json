{"buggy_code": ["/* Copyright (c) 2011-2014 PLUMgrid, http://plumgrid.com\n * Copyright (c) 2016 Facebook\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of version 2 of the GNU General Public\n * License as published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * General Public License for more details.\n */\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/bpf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/filter.h>\n#include <net/netlink.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/stringify.h>\n\n/* bpf_check() is a static code analyzer that walks eBPF program\n * instruction by instruction and updates register/stack state.\n * All paths of conditional branches are analyzed until 'bpf_exit' insn.\n *\n * The first pass is depth-first-search to check that the program is a DAG.\n * It rejects the following programs:\n * - larger than BPF_MAXINSNS insns\n * - if loop is present (detected via back-edge)\n * - unreachable insns exist (shouldn't be a forest. program = one function)\n * - out of bounds or malformed jumps\n * The second pass is all possible path descent from the 1st insn.\n * Since it's analyzing all pathes through the program, the length of the\n * analysis is limited to 64k insn, which may be hit even if total number of\n * insn is less then 4K, but there are too many branches that change stack/regs.\n * Number of 'branches to be analyzed' is limited to 1k\n *\n * On entry to each instruction, each register has a type, and the instruction\n * changes the types of the registers depending on instruction semantics.\n * If instruction is BPF_MOV64_REG(BPF_REG_1, BPF_REG_5), then type of R5 is\n * copied to R1.\n *\n * All registers are 64-bit.\n * R0 - return register\n * R1-R5 argument passing registers\n * R6-R9 callee saved registers\n * R10 - frame pointer read-only\n *\n * At the start of BPF program the register R1 contains a pointer to bpf_context\n * and has type PTR_TO_CTX.\n *\n * Verifier tracks arithmetic operations on pointers in case:\n *    BPF_MOV64_REG(BPF_REG_1, BPF_REG_10),\n *    BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, -20),\n * 1st insn copies R10 (which has FRAME_PTR) type into R1\n * and 2nd arithmetic instruction is pattern matched to recognize\n * that it wants to construct a pointer to some element within stack.\n * So after 2nd insn, the register R1 has type PTR_TO_STACK\n * (and -20 constant is saved for further stack bounds checking).\n * Meaning that this reg is a pointer to stack plus known immediate constant.\n *\n * Most of the time the registers have UNKNOWN_VALUE type, which\n * means the register has some value, but it's not a valid pointer.\n * (like pointer plus pointer becomes UNKNOWN_VALUE type)\n *\n * When verifier sees load or store instructions the type of base register\n * can be: PTR_TO_MAP_VALUE, PTR_TO_CTX, FRAME_PTR. These are three pointer\n * types recognized by check_mem_access() function.\n *\n * PTR_TO_MAP_VALUE means that this register is pointing to 'map element value'\n * and the range of [ptr, ptr + map's value_size) is accessible.\n *\n * registers used to pass values to function calls are checked against\n * function argument constraints.\n *\n * ARG_PTR_TO_MAP_KEY is one of such argument constraints.\n * It means that the register type passed to this function must be\n * PTR_TO_STACK and it will be used inside the function as\n * 'pointer to map element key'\n *\n * For example the argument constraints for bpf_map_lookup_elem():\n *   .ret_type = RET_PTR_TO_MAP_VALUE_OR_NULL,\n *   .arg1_type = ARG_CONST_MAP_PTR,\n *   .arg2_type = ARG_PTR_TO_MAP_KEY,\n *\n * ret_type says that this function returns 'pointer to map elem value or null'\n * function expects 1st argument to be a const pointer to 'struct bpf_map' and\n * 2nd argument should be a pointer to stack, which will be used inside\n * the helper function as a pointer to map element key.\n *\n * On the kernel side the helper function looks like:\n * u64 bpf_map_lookup_elem(u64 r1, u64 r2, u64 r3, u64 r4, u64 r5)\n * {\n *    struct bpf_map *map = (struct bpf_map *) (unsigned long) r1;\n *    void *key = (void *) (unsigned long) r2;\n *    void *value;\n *\n *    here kernel can access 'key' and 'map' pointers safely, knowing that\n *    [key, key + map->key_size) bytes are valid and were initialized on\n *    the stack of eBPF program.\n * }\n *\n * Corresponding eBPF program may look like:\n *    BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),  // after this insn R2 type is FRAME_PTR\n *    BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4), // after this insn R2 type is PTR_TO_STACK\n *    BPF_LD_MAP_FD(BPF_REG_1, map_fd),      // after this insn R1 type is CONST_PTR_TO_MAP\n *    BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),\n * here verifier looks at prototype of map_lookup_elem() and sees:\n * .arg1_type == ARG_CONST_MAP_PTR and R1->type == CONST_PTR_TO_MAP, which is ok,\n * Now verifier knows that this map has key of R1->map_ptr->key_size bytes\n *\n * Then .arg2_type == ARG_PTR_TO_MAP_KEY and R2->type == PTR_TO_STACK, ok so far,\n * Now verifier checks that [R2, R2 + map's key_size) are within stack limits\n * and were initialized prior to this call.\n * If it's ok, then verifier allows this BPF_CALL insn and looks at\n * .ret_type which is RET_PTR_TO_MAP_VALUE_OR_NULL, so it sets\n * R0->type = PTR_TO_MAP_VALUE_OR_NULL which means bpf_map_lookup_elem() function\n * returns ether pointer to map value or NULL.\n *\n * When type PTR_TO_MAP_VALUE_OR_NULL passes through 'if (reg != 0) goto +off'\n * insn, the register holding that pointer in the true branch changes state to\n * PTR_TO_MAP_VALUE and the same register changes state to CONST_IMM in the false\n * branch. See check_cond_jmp_op().\n *\n * After the call R0 is set to return type of the function and registers R1-R5\n * are set to NOT_INIT to indicate that they are no longer readable.\n */\n\n/* verifier_state + insn_idx are pushed to stack when branch is encountered */\nstruct bpf_verifier_stack_elem {\n\t/* verifer state is 'st'\n\t * before processing instruction 'insn_idx'\n\t * and after processing instruction 'prev_insn_idx'\n\t */\n\tstruct bpf_verifier_state st;\n\tint insn_idx;\n\tint prev_insn_idx;\n\tstruct bpf_verifier_stack_elem *next;\n};\n\n#define BPF_COMPLEXITY_LIMIT_INSNS\t65536\n#define BPF_COMPLEXITY_LIMIT_STACK\t1024\n\n#define BPF_MAP_PTR_POISON ((void *)0xeB9F + POISON_POINTER_DELTA)\n\nstruct bpf_call_arg_meta {\n\tstruct bpf_map *map_ptr;\n\tbool raw_mode;\n\tbool pkt_access;\n\tint regno;\n\tint access_size;\n};\n\n/* verbose verifier prints what it's seeing\n * bpf_check() is called under lock, so no race to access these global vars\n */\nstatic u32 log_level, log_size, log_len;\nstatic char *log_buf;\n\nstatic DEFINE_MUTEX(bpf_verifier_lock);\n\n/* log_level controls verbosity level of eBPF verifier.\n * verbose() is used to dump the verification trace to the log, so the user\n * can figure out what's wrong with the program\n */\nstatic __printf(1, 2) void verbose(const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (log_level == 0 || log_len >= log_size - 1)\n\t\treturn;\n\n\tva_start(args, fmt);\n\tlog_len += vscnprintf(log_buf + log_len, log_size - log_len, fmt, args);\n\tva_end(args);\n}\n\n/* string representation of 'enum bpf_reg_type' */\nstatic const char * const reg_type_str[] = {\n\t[NOT_INIT]\t\t= \"?\",\n\t[UNKNOWN_VALUE]\t\t= \"inv\",\n\t[PTR_TO_CTX]\t\t= \"ctx\",\n\t[CONST_PTR_TO_MAP]\t= \"map_ptr\",\n\t[PTR_TO_MAP_VALUE]\t= \"map_value\",\n\t[PTR_TO_MAP_VALUE_OR_NULL] = \"map_value_or_null\",\n\t[PTR_TO_MAP_VALUE_ADJ]\t= \"map_value_adj\",\n\t[FRAME_PTR]\t\t= \"fp\",\n\t[PTR_TO_STACK]\t\t= \"fp\",\n\t[CONST_IMM]\t\t= \"imm\",\n\t[PTR_TO_PACKET]\t\t= \"pkt\",\n\t[PTR_TO_PACKET_END]\t= \"pkt_end\",\n};\n\n#define __BPF_FUNC_STR_FN(x) [BPF_FUNC_ ## x] = __stringify(bpf_ ## x)\nstatic const char * const func_id_str[] = {\n\t__BPF_FUNC_MAPPER(__BPF_FUNC_STR_FN)\n};\n#undef __BPF_FUNC_STR_FN\n\nstatic const char *func_id_name(int id)\n{\n\tBUILD_BUG_ON(ARRAY_SIZE(func_id_str) != __BPF_FUNC_MAX_ID);\n\n\tif (id >= 0 && id < __BPF_FUNC_MAX_ID && func_id_str[id])\n\t\treturn func_id_str[id];\n\telse\n\t\treturn \"unknown\";\n}\n\nstatic void print_verifier_state(struct bpf_verifier_state *state)\n{\n\tstruct bpf_reg_state *reg;\n\tenum bpf_reg_type t;\n\tint i;\n\n\tfor (i = 0; i < MAX_BPF_REG; i++) {\n\t\treg = &state->regs[i];\n\t\tt = reg->type;\n\t\tif (t == NOT_INIT)\n\t\t\tcontinue;\n\t\tverbose(\" R%d=%s\", i, reg_type_str[t]);\n\t\tif (t == CONST_IMM || t == PTR_TO_STACK)\n\t\t\tverbose(\"%lld\", reg->imm);\n\t\telse if (t == PTR_TO_PACKET)\n\t\t\tverbose(\"(id=%d,off=%d,r=%d)\",\n\t\t\t\treg->id, reg->off, reg->range);\n\t\telse if (t == UNKNOWN_VALUE && reg->imm)\n\t\t\tverbose(\"%lld\", reg->imm);\n\t\telse if (t == CONST_PTR_TO_MAP || t == PTR_TO_MAP_VALUE ||\n\t\t\t t == PTR_TO_MAP_VALUE_OR_NULL ||\n\t\t\t t == PTR_TO_MAP_VALUE_ADJ)\n\t\t\tverbose(\"(ks=%d,vs=%d,id=%u)\",\n\t\t\t\treg->map_ptr->key_size,\n\t\t\t\treg->map_ptr->value_size,\n\t\t\t\treg->id);\n\t\tif (reg->min_value != BPF_REGISTER_MIN_RANGE)\n\t\t\tverbose(\",min_value=%lld\",\n\t\t\t\t(long long)reg->min_value);\n\t\tif (reg->max_value != BPF_REGISTER_MAX_RANGE)\n\t\t\tverbose(\",max_value=%llu\",\n\t\t\t\t(unsigned long long)reg->max_value);\n\t}\n\tfor (i = 0; i < MAX_BPF_STACK; i += BPF_REG_SIZE) {\n\t\tif (state->stack_slot_type[i] == STACK_SPILL)\n\t\t\tverbose(\" fp%d=%s\", -MAX_BPF_STACK + i,\n\t\t\t\treg_type_str[state->spilled_regs[i / BPF_REG_SIZE].type]);\n\t}\n\tverbose(\"\\n\");\n}\n\nstatic const char *const bpf_class_string[] = {\n\t[BPF_LD]    = \"ld\",\n\t[BPF_LDX]   = \"ldx\",\n\t[BPF_ST]    = \"st\",\n\t[BPF_STX]   = \"stx\",\n\t[BPF_ALU]   = \"alu\",\n\t[BPF_JMP]   = \"jmp\",\n\t[BPF_RET]   = \"BUG\",\n\t[BPF_ALU64] = \"alu64\",\n};\n\nstatic const char *const bpf_alu_string[16] = {\n\t[BPF_ADD >> 4]  = \"+=\",\n\t[BPF_SUB >> 4]  = \"-=\",\n\t[BPF_MUL >> 4]  = \"*=\",\n\t[BPF_DIV >> 4]  = \"/=\",\n\t[BPF_OR  >> 4]  = \"|=\",\n\t[BPF_AND >> 4]  = \"&=\",\n\t[BPF_LSH >> 4]  = \"<<=\",\n\t[BPF_RSH >> 4]  = \">>=\",\n\t[BPF_NEG >> 4]  = \"neg\",\n\t[BPF_MOD >> 4]  = \"%=\",\n\t[BPF_XOR >> 4]  = \"^=\",\n\t[BPF_MOV >> 4]  = \"=\",\n\t[BPF_ARSH >> 4] = \"s>>=\",\n\t[BPF_END >> 4]  = \"endian\",\n};\n\nstatic const char *const bpf_ldst_string[] = {\n\t[BPF_W >> 3]  = \"u32\",\n\t[BPF_H >> 3]  = \"u16\",\n\t[BPF_B >> 3]  = \"u8\",\n\t[BPF_DW >> 3] = \"u64\",\n};\n\nstatic const char *const bpf_jmp_string[16] = {\n\t[BPF_JA >> 4]   = \"jmp\",\n\t[BPF_JEQ >> 4]  = \"==\",\n\t[BPF_JGT >> 4]  = \">\",\n\t[BPF_JGE >> 4]  = \">=\",\n\t[BPF_JSET >> 4] = \"&\",\n\t[BPF_JNE >> 4]  = \"!=\",\n\t[BPF_JSGT >> 4] = \"s>\",\n\t[BPF_JSGE >> 4] = \"s>=\",\n\t[BPF_CALL >> 4] = \"call\",\n\t[BPF_EXIT >> 4] = \"exit\",\n};\n\nstatic void print_bpf_insn(struct bpf_insn *insn)\n{\n\tu8 class = BPF_CLASS(insn->code);\n\n\tif (class == BPF_ALU || class == BPF_ALU64) {\n\t\tif (BPF_SRC(insn->code) == BPF_X)\n\t\t\tverbose(\"(%02x) %sr%d %s %sr%d\\n\",\n\t\t\t\tinsn->code, class == BPF_ALU ? \"(u32) \" : \"\",\n\t\t\t\tinsn->dst_reg,\n\t\t\t\tbpf_alu_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tclass == BPF_ALU ? \"(u32) \" : \"\",\n\t\t\t\tinsn->src_reg);\n\t\telse\n\t\t\tverbose(\"(%02x) %sr%d %s %s%d\\n\",\n\t\t\t\tinsn->code, class == BPF_ALU ? \"(u32) \" : \"\",\n\t\t\t\tinsn->dst_reg,\n\t\t\t\tbpf_alu_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tclass == BPF_ALU ? \"(u32) \" : \"\",\n\t\t\t\tinsn->imm);\n\t} else if (class == BPF_STX) {\n\t\tif (BPF_MODE(insn->code) == BPF_MEM)\n\t\t\tverbose(\"(%02x) *(%s *)(r%d %+d) = r%d\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->dst_reg,\n\t\t\t\tinsn->off, insn->src_reg);\n\t\telse if (BPF_MODE(insn->code) == BPF_XADD)\n\t\t\tverbose(\"(%02x) lock *(%s *)(r%d %+d) += r%d\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->dst_reg, insn->off,\n\t\t\t\tinsn->src_reg);\n\t\telse\n\t\t\tverbose(\"BUG_%02x\\n\", insn->code);\n\t} else if (class == BPF_ST) {\n\t\tif (BPF_MODE(insn->code) != BPF_MEM) {\n\t\t\tverbose(\"BUG_st_%02x\\n\", insn->code);\n\t\t\treturn;\n\t\t}\n\t\tverbose(\"(%02x) *(%s *)(r%d %+d) = %d\\n\",\n\t\t\tinsn->code,\n\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\tinsn->dst_reg,\n\t\t\tinsn->off, insn->imm);\n\t} else if (class == BPF_LDX) {\n\t\tif (BPF_MODE(insn->code) != BPF_MEM) {\n\t\t\tverbose(\"BUG_ldx_%02x\\n\", insn->code);\n\t\t\treturn;\n\t\t}\n\t\tverbose(\"(%02x) r%d = *(%s *)(r%d %+d)\\n\",\n\t\t\tinsn->code, insn->dst_reg,\n\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\tinsn->src_reg, insn->off);\n\t} else if (class == BPF_LD) {\n\t\tif (BPF_MODE(insn->code) == BPF_ABS) {\n\t\t\tverbose(\"(%02x) r0 = *(%s *)skb[%d]\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->imm);\n\t\t} else if (BPF_MODE(insn->code) == BPF_IND) {\n\t\t\tverbose(\"(%02x) r0 = *(%s *)skb[r%d + %d]\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->src_reg, insn->imm);\n\t\t} else if (BPF_MODE(insn->code) == BPF_IMM) {\n\t\t\tverbose(\"(%02x) r%d = 0x%x\\n\",\n\t\t\t\tinsn->code, insn->dst_reg, insn->imm);\n\t\t} else {\n\t\t\tverbose(\"BUG_ld_%02x\\n\", insn->code);\n\t\t\treturn;\n\t\t}\n\t} else if (class == BPF_JMP) {\n\t\tu8 opcode = BPF_OP(insn->code);\n\n\t\tif (opcode == BPF_CALL) {\n\t\t\tverbose(\"(%02x) call %s#%d\\n\", insn->code,\n\t\t\t\tfunc_id_name(insn->imm), insn->imm);\n\t\t} else if (insn->code == (BPF_JMP | BPF_JA)) {\n\t\t\tverbose(\"(%02x) goto pc%+d\\n\",\n\t\t\t\tinsn->code, insn->off);\n\t\t} else if (insn->code == (BPF_JMP | BPF_EXIT)) {\n\t\t\tverbose(\"(%02x) exit\\n\", insn->code);\n\t\t} else if (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tverbose(\"(%02x) if r%d %s r%d goto pc%+d\\n\",\n\t\t\t\tinsn->code, insn->dst_reg,\n\t\t\t\tbpf_jmp_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tinsn->src_reg, insn->off);\n\t\t} else {\n\t\t\tverbose(\"(%02x) if r%d %s 0x%x goto pc%+d\\n\",\n\t\t\t\tinsn->code, insn->dst_reg,\n\t\t\t\tbpf_jmp_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tinsn->imm, insn->off);\n\t\t}\n\t} else {\n\t\tverbose(\"(%02x) %s\\n\", insn->code, bpf_class_string[class]);\n\t}\n}\n\nstatic int pop_stack(struct bpf_verifier_env *env, int *prev_insn_idx)\n{\n\tstruct bpf_verifier_stack_elem *elem;\n\tint insn_idx;\n\n\tif (env->head == NULL)\n\t\treturn -1;\n\n\tmemcpy(&env->cur_state, &env->head->st, sizeof(env->cur_state));\n\tinsn_idx = env->head->insn_idx;\n\tif (prev_insn_idx)\n\t\t*prev_insn_idx = env->head->prev_insn_idx;\n\telem = env->head->next;\n\tkfree(env->head);\n\tenv->head = elem;\n\tenv->stack_size--;\n\treturn insn_idx;\n}\n\nstatic struct bpf_verifier_state *push_stack(struct bpf_verifier_env *env,\n\t\t\t\t\t     int insn_idx, int prev_insn_idx)\n{\n\tstruct bpf_verifier_stack_elem *elem;\n\n\telem = kmalloc(sizeof(struct bpf_verifier_stack_elem), GFP_KERNEL);\n\tif (!elem)\n\t\tgoto err;\n\n\tmemcpy(&elem->st, &env->cur_state, sizeof(env->cur_state));\n\telem->insn_idx = insn_idx;\n\telem->prev_insn_idx = prev_insn_idx;\n\telem->next = env->head;\n\tenv->head = elem;\n\tenv->stack_size++;\n\tif (env->stack_size > BPF_COMPLEXITY_LIMIT_STACK) {\n\t\tverbose(\"BPF program is too complex\\n\");\n\t\tgoto err;\n\t}\n\treturn &elem->st;\nerr:\n\t/* pop all elements and return */\n\twhile (pop_stack(env, NULL) >= 0);\n\treturn NULL;\n}\n\n#define CALLER_SAVED_REGS 6\nstatic const int caller_saved[CALLER_SAVED_REGS] = {\n\tBPF_REG_0, BPF_REG_1, BPF_REG_2, BPF_REG_3, BPF_REG_4, BPF_REG_5\n};\n\nstatic void init_reg_state(struct bpf_reg_state *regs)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_BPF_REG; i++) {\n\t\tregs[i].type = NOT_INIT;\n\t\tregs[i].imm = 0;\n\t\tregs[i].min_value = BPF_REGISTER_MIN_RANGE;\n\t\tregs[i].max_value = BPF_REGISTER_MAX_RANGE;\n\t}\n\n\t/* frame pointer */\n\tregs[BPF_REG_FP].type = FRAME_PTR;\n\n\t/* 1st arg to a function */\n\tregs[BPF_REG_1].type = PTR_TO_CTX;\n}\n\nstatic void __mark_reg_unknown_value(struct bpf_reg_state *regs, u32 regno)\n{\n\tregs[regno].type = UNKNOWN_VALUE;\n\tregs[regno].id = 0;\n\tregs[regno].imm = 0;\n}\n\nstatic void mark_reg_unknown_value(struct bpf_reg_state *regs, u32 regno)\n{\n\tBUG_ON(regno >= MAX_BPF_REG);\n\t__mark_reg_unknown_value(regs, regno);\n}\n\nstatic void reset_reg_range_values(struct bpf_reg_state *regs, u32 regno)\n{\n\tregs[regno].min_value = BPF_REGISTER_MIN_RANGE;\n\tregs[regno].max_value = BPF_REGISTER_MAX_RANGE;\n}\n\nstatic void mark_reg_unknown_value_and_range(struct bpf_reg_state *regs,\n\t\t\t\t\t     u32 regno)\n{\n\tmark_reg_unknown_value(regs, regno);\n\treset_reg_range_values(regs, regno);\n}\n\nenum reg_arg_type {\n\tSRC_OP,\t\t/* register is used as source operand */\n\tDST_OP,\t\t/* register is used as destination operand */\n\tDST_OP_NO_MARK\t/* same as above, check only, don't mark */\n};\n\nstatic int check_reg_arg(struct bpf_reg_state *regs, u32 regno,\n\t\t\t enum reg_arg_type t)\n{\n\tif (regno >= MAX_BPF_REG) {\n\t\tverbose(\"R%d is invalid\\n\", regno);\n\t\treturn -EINVAL;\n\t}\n\n\tif (t == SRC_OP) {\n\t\t/* check whether register used as source operand can be read */\n\t\tif (regs[regno].type == NOT_INIT) {\n\t\t\tverbose(\"R%d !read_ok\\n\", regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t} else {\n\t\t/* check whether register used as dest operand can be written to */\n\t\tif (regno == BPF_REG_FP) {\n\t\t\tverbose(\"frame pointer is read only\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (t == DST_OP)\n\t\t\tmark_reg_unknown_value(regs, regno);\n\t}\n\treturn 0;\n}\n\nstatic int bpf_size_to_bytes(int bpf_size)\n{\n\tif (bpf_size == BPF_W)\n\t\treturn 4;\n\telse if (bpf_size == BPF_H)\n\t\treturn 2;\n\telse if (bpf_size == BPF_B)\n\t\treturn 1;\n\telse if (bpf_size == BPF_DW)\n\t\treturn 8;\n\telse\n\t\treturn -EINVAL;\n}\n\nstatic bool is_spillable_regtype(enum bpf_reg_type type)\n{\n\tswitch (type) {\n\tcase PTR_TO_MAP_VALUE:\n\tcase PTR_TO_MAP_VALUE_OR_NULL:\n\tcase PTR_TO_MAP_VALUE_ADJ:\n\tcase PTR_TO_STACK:\n\tcase PTR_TO_CTX:\n\tcase PTR_TO_PACKET:\n\tcase PTR_TO_PACKET_END:\n\tcase FRAME_PTR:\n\tcase CONST_PTR_TO_MAP:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n/* check_stack_read/write functions track spill/fill of registers,\n * stack boundary and alignment are checked in check_mem_access()\n */\nstatic int check_stack_write(struct bpf_verifier_state *state, int off,\n\t\t\t     int size, int value_regno)\n{\n\tint i;\n\t/* caller checked that off % size == 0 and -MAX_BPF_STACK <= off < 0,\n\t * so it's aligned access and [off, off + size) are within stack limits\n\t */\n\n\tif (value_regno >= 0 &&\n\t    is_spillable_regtype(state->regs[value_regno].type)) {\n\n\t\t/* register containing pointer is being spilled into stack */\n\t\tif (size != BPF_REG_SIZE) {\n\t\t\tverbose(\"invalid size of register spill\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\t/* save register state */\n\t\tstate->spilled_regs[(MAX_BPF_STACK + off) / BPF_REG_SIZE] =\n\t\t\tstate->regs[value_regno];\n\n\t\tfor (i = 0; i < BPF_REG_SIZE; i++)\n\t\t\tstate->stack_slot_type[MAX_BPF_STACK + off + i] = STACK_SPILL;\n\t} else {\n\t\t/* regular write of data into stack */\n\t\tstate->spilled_regs[(MAX_BPF_STACK + off) / BPF_REG_SIZE] =\n\t\t\t(struct bpf_reg_state) {};\n\n\t\tfor (i = 0; i < size; i++)\n\t\t\tstate->stack_slot_type[MAX_BPF_STACK + off + i] = STACK_MISC;\n\t}\n\treturn 0;\n}\n\nstatic int check_stack_read(struct bpf_verifier_state *state, int off, int size,\n\t\t\t    int value_regno)\n{\n\tu8 *slot_type;\n\tint i;\n\n\tslot_type = &state->stack_slot_type[MAX_BPF_STACK + off];\n\n\tif (slot_type[0] == STACK_SPILL) {\n\t\tif (size != BPF_REG_SIZE) {\n\t\t\tverbose(\"invalid size of register spill\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tfor (i = 1; i < BPF_REG_SIZE; i++) {\n\t\t\tif (slot_type[i] != STACK_SPILL) {\n\t\t\t\tverbose(\"corrupted spill memory\\n\");\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\t\t}\n\n\t\tif (value_regno >= 0)\n\t\t\t/* restore register state from stack */\n\t\t\tstate->regs[value_regno] =\n\t\t\t\tstate->spilled_regs[(MAX_BPF_STACK + off) / BPF_REG_SIZE];\n\t\treturn 0;\n\t} else {\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tif (slot_type[i] != STACK_MISC) {\n\t\t\t\tverbose(\"invalid read from stack off %d+%d size %d\\n\",\n\t\t\t\t\toff, i, size);\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\t\t}\n\t\tif (value_regno >= 0)\n\t\t\t/* have read misc data from the stack */\n\t\t\tmark_reg_unknown_value_and_range(state->regs,\n\t\t\t\t\t\t\t value_regno);\n\t\treturn 0;\n\t}\n}\n\n/* check read/write into map element returned by bpf_map_lookup_elem() */\nstatic int check_map_access(struct bpf_verifier_env *env, u32 regno, int off,\n\t\t\t    int size)\n{\n\tstruct bpf_map *map = env->cur_state.regs[regno].map_ptr;\n\n\tif (off < 0 || size <= 0 || off + size > map->value_size) {\n\t\tverbose(\"invalid access to map value, value_size=%d off=%d size=%d\\n\",\n\t\t\tmap->value_size, off, size);\n\t\treturn -EACCES;\n\t}\n\treturn 0;\n}\n\n/* check read/write into an adjusted map element */\nstatic int check_map_access_adj(struct bpf_verifier_env *env, u32 regno,\n\t\t\t\tint off, int size)\n{\n\tstruct bpf_verifier_state *state = &env->cur_state;\n\tstruct bpf_reg_state *reg = &state->regs[regno];\n\tint err;\n\n\t/* We adjusted the register to this map value, so we\n\t * need to change off and size to min_value and max_value\n\t * respectively to make sure our theoretical access will be\n\t * safe.\n\t */\n\tif (log_level)\n\t\tprint_verifier_state(state);\n\tenv->varlen_map_value_access = true;\n\t/* The minimum value is only important with signed\n\t * comparisons where we can't assume the floor of a\n\t * value is 0.  If we are using signed variables for our\n\t * index'es we need to make sure that whatever we use\n\t * will have a set floor within our range.\n\t */\n\tif (reg->min_value < 0) {\n\t\tverbose(\"R%d min value is negative, either use unsigned index or do a if (index >=0) check.\\n\",\n\t\t\tregno);\n\t\treturn -EACCES;\n\t}\n\terr = check_map_access(env, regno, reg->min_value + off, size);\n\tif (err) {\n\t\tverbose(\"R%d min value is outside of the array range\\n\",\n\t\t\tregno);\n\t\treturn err;\n\t}\n\n\t/* If we haven't set a max value then we need to bail\n\t * since we can't be sure we won't do bad things.\n\t */\n\tif (reg->max_value == BPF_REGISTER_MAX_RANGE) {\n\t\tverbose(\"R%d unbounded memory access, make sure to bounds check any array access into a map\\n\",\n\t\t\tregno);\n\t\treturn -EACCES;\n\t}\n\treturn check_map_access(env, regno, reg->max_value + off, size);\n}\n\n#define MAX_PACKET_OFF 0xffff\n\nstatic bool may_access_direct_pkt_data(struct bpf_verifier_env *env,\n\t\t\t\t       const struct bpf_call_arg_meta *meta,\n\t\t\t\t       enum bpf_access_type t)\n{\n\tswitch (env->prog->type) {\n\tcase BPF_PROG_TYPE_LWT_IN:\n\tcase BPF_PROG_TYPE_LWT_OUT:\n\t\t/* dst_input() and dst_output() can't write for now */\n\t\tif (t == BPF_WRITE)\n\t\t\treturn false;\n\t\t/* fallthrough */\n\tcase BPF_PROG_TYPE_SCHED_CLS:\n\tcase BPF_PROG_TYPE_SCHED_ACT:\n\tcase BPF_PROG_TYPE_XDP:\n\tcase BPF_PROG_TYPE_LWT_XMIT:\n\t\tif (meta)\n\t\t\treturn meta->pkt_access;\n\n\t\tenv->seen_direct_write = true;\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int check_packet_access(struct bpf_verifier_env *env, u32 regno, int off,\n\t\t\t       int size)\n{\n\tstruct bpf_reg_state *regs = env->cur_state.regs;\n\tstruct bpf_reg_state *reg = &regs[regno];\n\n\toff += reg->off;\n\tif (off < 0 || size <= 0 || off + size > reg->range) {\n\t\tverbose(\"invalid access to packet, off=%d size=%d, R%d(id=%d,off=%d,r=%d)\\n\",\n\t\t\toff, size, regno, reg->id, reg->off, reg->range);\n\t\treturn -EACCES;\n\t}\n\treturn 0;\n}\n\n/* check access to 'struct bpf_context' fields */\nstatic int check_ctx_access(struct bpf_verifier_env *env, int off, int size,\n\t\t\t    enum bpf_access_type t, enum bpf_reg_type *reg_type)\n{\n\t/* for analyzer ctx accesses are already validated and converted */\n\tif (env->analyzer_ops)\n\t\treturn 0;\n\n\tif (env->prog->aux->ops->is_valid_access &&\n\t    env->prog->aux->ops->is_valid_access(off, size, t, reg_type)) {\n\t\t/* remember the offset of last byte accessed in ctx */\n\t\tif (env->prog->aux->max_ctx_offset < off + size)\n\t\t\tenv->prog->aux->max_ctx_offset = off + size;\n\t\treturn 0;\n\t}\n\n\tverbose(\"invalid bpf_context access off=%d size=%d\\n\", off, size);\n\treturn -EACCES;\n}\n\nstatic bool is_pointer_value(struct bpf_verifier_env *env, int regno)\n{\n\tif (env->allow_ptr_leaks)\n\t\treturn false;\n\n\tswitch (env->cur_state.regs[regno].type) {\n\tcase UNKNOWN_VALUE:\n\tcase CONST_IMM:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic int check_pkt_ptr_alignment(const struct bpf_reg_state *reg,\n\t\t\t\t   int off, int size)\n{\n\tif (reg->id && size != 1) {\n\t\tverbose(\"Unknown alignment. Only byte-sized access allowed in packet access.\\n\");\n\t\treturn -EACCES;\n\t}\n\n\t/* skb->data is NET_IP_ALIGN-ed */\n\tif ((NET_IP_ALIGN + reg->off + off) % size != 0) {\n\t\tverbose(\"misaligned packet access off %d+%d+%d size %d\\n\",\n\t\t\tNET_IP_ALIGN, reg->off, off, size);\n\t\treturn -EACCES;\n\t}\n\n\treturn 0;\n}\n\nstatic int check_val_ptr_alignment(const struct bpf_reg_state *reg,\n\t\t\t\t   int size)\n{\n\tif (size != 1) {\n\t\tverbose(\"Unknown alignment. Only byte-sized access allowed in value access.\\n\");\n\t\treturn -EACCES;\n\t}\n\n\treturn 0;\n}\n\nstatic int check_ptr_alignment(const struct bpf_reg_state *reg,\n\t\t\t       int off, int size)\n{\n\tswitch (reg->type) {\n\tcase PTR_TO_PACKET:\n\t\treturn IS_ENABLED(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) ? 0 :\n\t\t       check_pkt_ptr_alignment(reg, off, size);\n\tcase PTR_TO_MAP_VALUE_ADJ:\n\t\treturn IS_ENABLED(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) ? 0 :\n\t\t       check_val_ptr_alignment(reg, size);\n\tdefault:\n\t\tif (off % size != 0) {\n\t\t\tverbose(\"misaligned access off %d size %d\\n\",\n\t\t\t\toff, size);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\treturn 0;\n\t}\n}\n\n/* check whether memory at (regno + off) is accessible for t = (read | write)\n * if t==write, value_regno is a register which value is stored into memory\n * if t==read, value_regno is a register which will receive the value from memory\n * if t==write && value_regno==-1, some unknown value is stored into memory\n * if t==read && value_regno==-1, don't care what we read from memory\n */\nstatic int check_mem_access(struct bpf_verifier_env *env, u32 regno, int off,\n\t\t\t    int bpf_size, enum bpf_access_type t,\n\t\t\t    int value_regno)\n{\n\tstruct bpf_verifier_state *state = &env->cur_state;\n\tstruct bpf_reg_state *reg = &state->regs[regno];\n\tint size, err = 0;\n\n\tif (reg->type == PTR_TO_STACK)\n\t\toff += reg->imm;\n\n\tsize = bpf_size_to_bytes(bpf_size);\n\tif (size < 0)\n\t\treturn size;\n\n\terr = check_ptr_alignment(reg, off, size);\n\tif (err)\n\t\treturn err;\n\n\tif (reg->type == PTR_TO_MAP_VALUE ||\n\t    reg->type == PTR_TO_MAP_VALUE_ADJ) {\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(\"R%d leaks addr into map\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (reg->type == PTR_TO_MAP_VALUE_ADJ)\n\t\t\terr = check_map_access_adj(env, regno, off, size);\n\t\telse\n\t\t\terr = check_map_access(env, regno, off, size);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown_value_and_range(state->regs,\n\t\t\t\t\t\t\t value_regno);\n\n\t} else if (reg->type == PTR_TO_CTX) {\n\t\tenum bpf_reg_type reg_type = UNKNOWN_VALUE;\n\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(\"R%d leaks addr into ctx\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_ctx_access(env, off, size, t, &reg_type);\n\t\tif (!err && t == BPF_READ && value_regno >= 0) {\n\t\t\tmark_reg_unknown_value_and_range(state->regs,\n\t\t\t\t\t\t\t value_regno);\n\t\t\t/* note that reg.[id|off|range] == 0 */\n\t\t\tstate->regs[value_regno].type = reg_type;\n\t\t}\n\n\t} else if (reg->type == FRAME_PTR || reg->type == PTR_TO_STACK) {\n\t\tif (off >= 0 || off < -MAX_BPF_STACK) {\n\t\t\tverbose(\"invalid stack off=%d size=%d\\n\", off, size);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (t == BPF_WRITE) {\n\t\t\tif (!env->allow_ptr_leaks &&\n\t\t\t    state->stack_slot_type[MAX_BPF_STACK + off] == STACK_SPILL &&\n\t\t\t    size != BPF_REG_SIZE) {\n\t\t\t\tverbose(\"attempt to corrupt spilled pointer on stack\\n\");\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\t\t\terr = check_stack_write(state, off, size, value_regno);\n\t\t} else {\n\t\t\terr = check_stack_read(state, off, size, value_regno);\n\t\t}\n\t} else if (state->regs[regno].type == PTR_TO_PACKET) {\n\t\tif (t == BPF_WRITE && !may_access_direct_pkt_data(env, NULL, t)) {\n\t\t\tverbose(\"cannot write into packet\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(\"R%d leaks addr into packet\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_packet_access(env, regno, off, size);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown_value_and_range(state->regs,\n\t\t\t\t\t\t\t value_regno);\n\t} else {\n\t\tverbose(\"R%d invalid mem access '%s'\\n\",\n\t\t\tregno, reg_type_str[reg->type]);\n\t\treturn -EACCES;\n\t}\n\n\tif (!err && size <= 2 && value_regno >= 0 && env->allow_ptr_leaks &&\n\t    state->regs[value_regno].type == UNKNOWN_VALUE) {\n\t\t/* 1 or 2 byte load zero-extends, determine the number of\n\t\t * zero upper bits. Not doing it fo 4 byte load, since\n\t\t * such values cannot be added to ptr_to_packet anyway.\n\t\t */\n\t\tstate->regs[value_regno].imm = 64 - size * 8;\n\t}\n\treturn err;\n}\n\nstatic int check_xadd(struct bpf_verifier_env *env, struct bpf_insn *insn)\n{\n\tstruct bpf_reg_state *regs = env->cur_state.regs;\n\tint err;\n\n\tif ((BPF_SIZE(insn->code) != BPF_W && BPF_SIZE(insn->code) != BPF_DW) ||\n\t    insn->imm != 0) {\n\t\tverbose(\"BPF_XADD uses reserved fields\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* check src1 operand */\n\terr = check_reg_arg(regs, insn->src_reg, SRC_OP);\n\tif (err)\n\t\treturn err;\n\n\t/* check src2 operand */\n\terr = check_reg_arg(regs, insn->dst_reg, SRC_OP);\n\tif (err)\n\t\treturn err;\n\n\t/* check whether atomic_add can read the memory */\n\terr = check_mem_access(env, insn->dst_reg, insn->off,\n\t\t\t       BPF_SIZE(insn->code), BPF_READ, -1);\n\tif (err)\n\t\treturn err;\n\n\t/* check whether atomic_add can write into the same memory */\n\treturn check_mem_access(env, insn->dst_reg, insn->off,\n\t\t\t\tBPF_SIZE(insn->code), BPF_WRITE, -1);\n}\n\n/* when register 'regno' is passed into function that will read 'access_size'\n * bytes from that pointer, make sure that it's within stack boundary\n * and all elements of stack are initialized\n */\nstatic int check_stack_boundary(struct bpf_verifier_env *env, int regno,\n\t\t\t\tint access_size, bool zero_size_allowed,\n\t\t\t\tstruct bpf_call_arg_meta *meta)\n{\n\tstruct bpf_verifier_state *state = &env->cur_state;\n\tstruct bpf_reg_state *regs = state->regs;\n\tint off, i;\n\n\tif (regs[regno].type != PTR_TO_STACK) {\n\t\tif (zero_size_allowed && access_size == 0 &&\n\t\t    regs[regno].type == CONST_IMM &&\n\t\t    regs[regno].imm  == 0)\n\t\t\treturn 0;\n\n\t\tverbose(\"R%d type=%s expected=%s\\n\", regno,\n\t\t\treg_type_str[regs[regno].type],\n\t\t\treg_type_str[PTR_TO_STACK]);\n\t\treturn -EACCES;\n\t}\n\n\toff = regs[regno].imm;\n\tif (off >= 0 || off < -MAX_BPF_STACK || off + access_size > 0 ||\n\t    access_size <= 0) {\n\t\tverbose(\"invalid stack type R%d off=%d access_size=%d\\n\",\n\t\t\tregno, off, access_size);\n\t\treturn -EACCES;\n\t}\n\n\tif (meta && meta->raw_mode) {\n\t\tmeta->access_size = access_size;\n\t\tmeta->regno = regno;\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < access_size; i++) {\n\t\tif (state->stack_slot_type[MAX_BPF_STACK + off + i] != STACK_MISC) {\n\t\t\tverbose(\"invalid indirect read from stack off %d+%d size %d\\n\",\n\t\t\t\toff, i, access_size);\n\t\t\treturn -EACCES;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int check_helper_mem_access(struct bpf_verifier_env *env, int regno,\n\t\t\t\t   int access_size, bool zero_size_allowed,\n\t\t\t\t   struct bpf_call_arg_meta *meta)\n{\n\tstruct bpf_reg_state *regs = env->cur_state.regs;\n\n\tswitch (regs[regno].type) {\n\tcase PTR_TO_PACKET:\n\t\treturn check_packet_access(env, regno, 0, access_size);\n\tcase PTR_TO_MAP_VALUE:\n\t\treturn check_map_access(env, regno, 0, access_size);\n\tcase PTR_TO_MAP_VALUE_ADJ:\n\t\treturn check_map_access_adj(env, regno, 0, access_size);\n\tdefault: /* const_imm|ptr_to_stack or invalid ptr */\n\t\treturn check_stack_boundary(env, regno, access_size,\n\t\t\t\t\t    zero_size_allowed, meta);\n\t}\n}\n\nstatic int check_func_arg(struct bpf_verifier_env *env, u32 regno,\n\t\t\t  enum bpf_arg_type arg_type,\n\t\t\t  struct bpf_call_arg_meta *meta)\n{\n\tstruct bpf_reg_state *regs = env->cur_state.regs, *reg = &regs[regno];\n\tenum bpf_reg_type expected_type, type = reg->type;\n\tint err = 0;\n\n\tif (arg_type == ARG_DONTCARE)\n\t\treturn 0;\n\n\tif (type == NOT_INIT) {\n\t\tverbose(\"R%d !read_ok\\n\", regno);\n\t\treturn -EACCES;\n\t}\n\n\tif (arg_type == ARG_ANYTHING) {\n\t\tif (is_pointer_value(env, regno)) {\n\t\t\tverbose(\"R%d leaks addr into helper function\\n\", regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (type == PTR_TO_PACKET &&\n\t    !may_access_direct_pkt_data(env, meta, BPF_READ)) {\n\t\tverbose(\"helper access to the packet is not allowed\\n\");\n\t\treturn -EACCES;\n\t}\n\n\tif (arg_type == ARG_PTR_TO_MAP_KEY ||\n\t    arg_type == ARG_PTR_TO_MAP_VALUE) {\n\t\texpected_type = PTR_TO_STACK;\n\t\tif (type != PTR_TO_PACKET && type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type == ARG_CONST_SIZE ||\n\t\t   arg_type == ARG_CONST_SIZE_OR_ZERO) {\n\t\texpected_type = CONST_IMM;\n\t\t/* One exception. Allow UNKNOWN_VALUE registers when the\n\t\t * boundaries are known and don't cause unsafe memory accesses\n\t\t */\n\t\tif (type != UNKNOWN_VALUE && type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type == ARG_CONST_MAP_PTR) {\n\t\texpected_type = CONST_PTR_TO_MAP;\n\t\tif (type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type == ARG_PTR_TO_CTX) {\n\t\texpected_type = PTR_TO_CTX;\n\t\tif (type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type == ARG_PTR_TO_MEM ||\n\t\t   arg_type == ARG_PTR_TO_UNINIT_MEM) {\n\t\texpected_type = PTR_TO_STACK;\n\t\t/* One exception here. In case function allows for NULL to be\n\t\t * passed in as argument, it's a CONST_IMM type. Final test\n\t\t * happens during stack boundary checking.\n\t\t */\n\t\tif (type == CONST_IMM && reg->imm == 0)\n\t\t\t/* final test in check_stack_boundary() */;\n\t\telse if (type != PTR_TO_PACKET && type != PTR_TO_MAP_VALUE &&\n\t\t\t type != PTR_TO_MAP_VALUE_ADJ && type != expected_type)\n\t\t\tgoto err_type;\n\t\tmeta->raw_mode = arg_type == ARG_PTR_TO_UNINIT_MEM;\n\t} else {\n\t\tverbose(\"unsupported arg_type %d\\n\", arg_type);\n\t\treturn -EFAULT;\n\t}\n\n\tif (arg_type == ARG_CONST_MAP_PTR) {\n\t\t/* bpf_map_xxx(map_ptr) call: remember that map_ptr */\n\t\tmeta->map_ptr = reg->map_ptr;\n\t} else if (arg_type == ARG_PTR_TO_MAP_KEY) {\n\t\t/* bpf_map_xxx(..., map_ptr, ..., key) call:\n\t\t * check that [key, key + map->key_size) are within\n\t\t * stack limits and initialized\n\t\t */\n\t\tif (!meta->map_ptr) {\n\t\t\t/* in function declaration map_ptr must come before\n\t\t\t * map_key, so that it's verified and known before\n\t\t\t * we have to check map_key here. Otherwise it means\n\t\t\t * that kernel subsystem misconfigured verifier\n\t\t\t */\n\t\t\tverbose(\"invalid map_ptr to access map->key\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (type == PTR_TO_PACKET)\n\t\t\terr = check_packet_access(env, regno, 0,\n\t\t\t\t\t\t  meta->map_ptr->key_size);\n\t\telse\n\t\t\terr = check_stack_boundary(env, regno,\n\t\t\t\t\t\t   meta->map_ptr->key_size,\n\t\t\t\t\t\t   false, NULL);\n\t} else if (arg_type == ARG_PTR_TO_MAP_VALUE) {\n\t\t/* bpf_map_xxx(..., map_ptr, ..., value) call:\n\t\t * check [value, value + map->value_size) validity\n\t\t */\n\t\tif (!meta->map_ptr) {\n\t\t\t/* kernel subsystem misconfigured verifier */\n\t\t\tverbose(\"invalid map_ptr to access map->value\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (type == PTR_TO_PACKET)\n\t\t\terr = check_packet_access(env, regno, 0,\n\t\t\t\t\t\t  meta->map_ptr->value_size);\n\t\telse\n\t\t\terr = check_stack_boundary(env, regno,\n\t\t\t\t\t\t   meta->map_ptr->value_size,\n\t\t\t\t\t\t   false, NULL);\n\t} else if (arg_type == ARG_CONST_SIZE ||\n\t\t   arg_type == ARG_CONST_SIZE_OR_ZERO) {\n\t\tbool zero_size_allowed = (arg_type == ARG_CONST_SIZE_OR_ZERO);\n\n\t\t/* bpf_xxx(..., buf, len) call will access 'len' bytes\n\t\t * from stack pointer 'buf'. Check it\n\t\t * note: regno == len, regno - 1 == buf\n\t\t */\n\t\tif (regno == 0) {\n\t\t\t/* kernel subsystem misconfigured verifier */\n\t\t\tverbose(\"ARG_CONST_SIZE cannot be first argument\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\t/* If the register is UNKNOWN_VALUE, the access check happens\n\t\t * using its boundaries. Otherwise, just use its imm\n\t\t */\n\t\tif (type == UNKNOWN_VALUE) {\n\t\t\t/* For unprivileged variable accesses, disable raw\n\t\t\t * mode so that the program is required to\n\t\t\t * initialize all the memory that the helper could\n\t\t\t * just partially fill up.\n\t\t\t */\n\t\t\tmeta = NULL;\n\n\t\t\tif (reg->min_value < 0) {\n\t\t\t\tverbose(\"R%d min value is negative, either use unsigned or 'var &= const'\\n\",\n\t\t\t\t\tregno);\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\n\t\t\tif (reg->min_value == 0) {\n\t\t\t\terr = check_helper_mem_access(env, regno - 1, 0,\n\t\t\t\t\t\t\t      zero_size_allowed,\n\t\t\t\t\t\t\t      meta);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\n\t\t\tif (reg->max_value == BPF_REGISTER_MAX_RANGE) {\n\t\t\t\tverbose(\"R%d unbounded memory access, use 'var &= const' or 'if (var < const)'\\n\",\n\t\t\t\t\tregno);\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\t\t\terr = check_helper_mem_access(env, regno - 1,\n\t\t\t\t\t\t      reg->max_value,\n\t\t\t\t\t\t      zero_size_allowed, meta);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\t/* register is CONST_IMM */\n\t\t\terr = check_helper_mem_access(env, regno - 1, reg->imm,\n\t\t\t\t\t\t      zero_size_allowed, meta);\n\t\t}\n\t}\n\n\treturn err;\nerr_type:\n\tverbose(\"R%d type=%s expected=%s\\n\", regno,\n\t\treg_type_str[type], reg_type_str[expected_type]);\n\treturn -EACCES;\n}\n\nstatic int check_map_func_compatibility(struct bpf_map *map, int func_id)\n{\n\tif (!map)\n\t\treturn 0;\n\n\t/* We need a two way check, first is from map perspective ... */\n\tswitch (map->map_type) {\n\tcase BPF_MAP_TYPE_PROG_ARRAY:\n\t\tif (func_id != BPF_FUNC_tail_call)\n\t\t\tgoto error;\n\t\tbreak;\n\tcase BPF_MAP_TYPE_PERF_EVENT_ARRAY:\n\t\tif (func_id != BPF_FUNC_perf_event_read &&\n\t\t    func_id != BPF_FUNC_perf_event_output)\n\t\t\tgoto error;\n\t\tbreak;\n\tcase BPF_MAP_TYPE_STACK_TRACE:\n\t\tif (func_id != BPF_FUNC_get_stackid)\n\t\t\tgoto error;\n\t\tbreak;\n\tcase BPF_MAP_TYPE_CGROUP_ARRAY:\n\t\tif (func_id != BPF_FUNC_skb_under_cgroup &&\n\t\t    func_id != BPF_FUNC_current_task_under_cgroup)\n\t\t\tgoto error;\n\t\tbreak;\n\tcase BPF_MAP_TYPE_ARRAY_OF_MAPS:\n\tcase BPF_MAP_TYPE_HASH_OF_MAPS:\n\t\tif (func_id != BPF_FUNC_map_lookup_elem)\n\t\t\tgoto error;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* ... and second from the function itself. */\n\tswitch (func_id) {\n\tcase BPF_FUNC_tail_call:\n\t\tif (map->map_type != BPF_MAP_TYPE_PROG_ARRAY)\n\t\t\tgoto error;\n\t\tbreak;\n\tcase BPF_FUNC_perf_event_read:\n\tcase BPF_FUNC_perf_event_output:\n\t\tif (map->map_type != BPF_MAP_TYPE_PERF_EVENT_ARRAY)\n\t\t\tgoto error;\n\t\tbreak;\n\tcase BPF_FUNC_get_stackid:\n\t\tif (map->map_type != BPF_MAP_TYPE_STACK_TRACE)\n\t\t\tgoto error;\n\t\tbreak;\n\tcase BPF_FUNC_current_task_under_cgroup:\n\tcase BPF_FUNC_skb_under_cgroup:\n\t\tif (map->map_type != BPF_MAP_TYPE_CGROUP_ARRAY)\n\t\t\tgoto error;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\nerror:\n\tverbose(\"cannot pass map_type %d into func %s#%d\\n\",\n\t\tmap->map_type, func_id_name(func_id), func_id);\n\treturn -EINVAL;\n}\n\nstatic int check_raw_mode(const struct bpf_func_proto *fn)\n{\n\tint count = 0;\n\n\tif (fn->arg1_type == ARG_PTR_TO_UNINIT_MEM)\n\t\tcount++;\n\tif (fn->arg2_type == ARG_PTR_TO_UNINIT_MEM)\n\t\tcount++;\n\tif (fn->arg3_type == ARG_PTR_TO_UNINIT_MEM)\n\t\tcount++;\n\tif (fn->arg4_type == ARG_PTR_TO_UNINIT_MEM)\n\t\tcount++;\n\tif (fn->arg5_type == ARG_PTR_TO_UNINIT_MEM)\n\t\tcount++;\n\n\treturn count > 1 ? -EINVAL : 0;\n}\n\nstatic void clear_all_pkt_pointers(struct bpf_verifier_env *env)\n{\n\tstruct bpf_verifier_state *state = &env->cur_state;\n\tstruct bpf_reg_state *regs = state->regs, *reg;\n\tint i;\n\n\tfor (i = 0; i < MAX_BPF_REG; i++)\n\t\tif (regs[i].type == PTR_TO_PACKET ||\n\t\t    regs[i].type == PTR_TO_PACKET_END)\n\t\t\tmark_reg_unknown_value(regs, i);\n\n\tfor (i = 0; i < MAX_BPF_STACK; i += BPF_REG_SIZE) {\n\t\tif (state->stack_slot_type[i] != STACK_SPILL)\n\t\t\tcontinue;\n\t\treg = &state->spilled_regs[i / BPF_REG_SIZE];\n\t\tif (reg->type != PTR_TO_PACKET &&\n\t\t    reg->type != PTR_TO_PACKET_END)\n\t\t\tcontinue;\n\t\treg->type = UNKNOWN_VALUE;\n\t\treg->imm = 0;\n\t}\n}\n\nstatic int check_call(struct bpf_verifier_env *env, int func_id, int insn_idx)\n{\n\tstruct bpf_verifier_state *state = &env->cur_state;\n\tconst struct bpf_func_proto *fn = NULL;\n\tstruct bpf_reg_state *regs = state->regs;\n\tstruct bpf_reg_state *reg;\n\tstruct bpf_call_arg_meta meta;\n\tbool changes_data;\n\tint i, err;\n\n\t/* find function prototype */\n\tif (func_id < 0 || func_id >= __BPF_FUNC_MAX_ID) {\n\t\tverbose(\"invalid func %s#%d\\n\", func_id_name(func_id), func_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (env->prog->aux->ops->get_func_proto)\n\t\tfn = env->prog->aux->ops->get_func_proto(func_id);\n\n\tif (!fn) {\n\t\tverbose(\"unknown func %s#%d\\n\", func_id_name(func_id), func_id);\n\t\treturn -EINVAL;\n\t}\n\n\t/* eBPF programs must be GPL compatible to use GPL-ed functions */\n\tif (!env->prog->gpl_compatible && fn->gpl_only) {\n\t\tverbose(\"cannot call GPL only function from proprietary program\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tchanges_data = bpf_helper_changes_pkt_data(fn->func);\n\n\tmemset(&meta, 0, sizeof(meta));\n\tmeta.pkt_access = fn->pkt_access;\n\n\t/* We only support one arg being in raw mode at the moment, which\n\t * is sufficient for the helper functions we have right now.\n\t */\n\terr = check_raw_mode(fn);\n\tif (err) {\n\t\tverbose(\"kernel subsystem misconfigured func %s#%d\\n\",\n\t\t\tfunc_id_name(func_id), func_id);\n\t\treturn err;\n\t}\n\n\t/* check args */\n\terr = check_func_arg(env, BPF_REG_1, fn->arg1_type, &meta);\n\tif (err)\n\t\treturn err;\n\terr = check_func_arg(env, BPF_REG_2, fn->arg2_type, &meta);\n\tif (err)\n\t\treturn err;\n\terr = check_func_arg(env, BPF_REG_3, fn->arg3_type, &meta);\n\tif (err)\n\t\treturn err;\n\terr = check_func_arg(env, BPF_REG_4, fn->arg4_type, &meta);\n\tif (err)\n\t\treturn err;\n\terr = check_func_arg(env, BPF_REG_5, fn->arg5_type, &meta);\n\tif (err)\n\t\treturn err;\n\n\t/* Mark slots with STACK_MISC in case of raw mode, stack offset\n\t * is inferred from register state.\n\t */\n\tfor (i = 0; i < meta.access_size; i++) {\n\t\terr = check_mem_access(env, meta.regno, i, BPF_B, BPF_WRITE, -1);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t/* reset caller saved regs */\n\tfor (i = 0; i < CALLER_SAVED_REGS; i++) {\n\t\treg = regs + caller_saved[i];\n\t\treg->type = NOT_INIT;\n\t\treg->imm = 0;\n\t}\n\n\t/* update return register */\n\tif (fn->ret_type == RET_INTEGER) {\n\t\tregs[BPF_REG_0].type = UNKNOWN_VALUE;\n\t} else if (fn->ret_type == RET_VOID) {\n\t\tregs[BPF_REG_0].type = NOT_INIT;\n\t} else if (fn->ret_type == RET_PTR_TO_MAP_VALUE_OR_NULL) {\n\t\tstruct bpf_insn_aux_data *insn_aux;\n\n\t\tregs[BPF_REG_0].type = PTR_TO_MAP_VALUE_OR_NULL;\n\t\tregs[BPF_REG_0].max_value = regs[BPF_REG_0].min_value = 0;\n\t\t/* remember map_ptr, so that check_map_access()\n\t\t * can check 'value_size' boundary of memory access\n\t\t * to map element returned from bpf_map_lookup_elem()\n\t\t */\n\t\tif (meta.map_ptr == NULL) {\n\t\t\tverbose(\"kernel subsystem misconfigured verifier\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tregs[BPF_REG_0].map_ptr = meta.map_ptr;\n\t\tregs[BPF_REG_0].id = ++env->id_gen;\n\t\tinsn_aux = &env->insn_aux_data[insn_idx];\n\t\tif (!insn_aux->map_ptr)\n\t\t\tinsn_aux->map_ptr = meta.map_ptr;\n\t\telse if (insn_aux->map_ptr != meta.map_ptr)\n\t\t\tinsn_aux->map_ptr = BPF_MAP_PTR_POISON;\n\t} else {\n\t\tverbose(\"unknown return type %d of func %s#%d\\n\",\n\t\t\tfn->ret_type, func_id_name(func_id), func_id);\n\t\treturn -EINVAL;\n\t}\n\n\terr = check_map_func_compatibility(meta.map_ptr, func_id);\n\tif (err)\n\t\treturn err;\n\n\tif (changes_data)\n\t\tclear_all_pkt_pointers(env);\n\treturn 0;\n}\n\nstatic int check_packet_ptr_add(struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_insn *insn)\n{\n\tstruct bpf_reg_state *regs = env->cur_state.regs;\n\tstruct bpf_reg_state *dst_reg = &regs[insn->dst_reg];\n\tstruct bpf_reg_state *src_reg = &regs[insn->src_reg];\n\tstruct bpf_reg_state tmp_reg;\n\ts32 imm;\n\n\tif (BPF_SRC(insn->code) == BPF_K) {\n\t\t/* pkt_ptr += imm */\n\t\timm = insn->imm;\n\nadd_imm:\n\t\tif (imm < 0) {\n\t\t\tverbose(\"addition of negative constant to packet pointer is not allowed\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (imm >= MAX_PACKET_OFF ||\n\t\t    imm + dst_reg->off >= MAX_PACKET_OFF) {\n\t\t\tverbose(\"constant %d is too large to add to packet pointer\\n\",\n\t\t\t\timm);\n\t\t\treturn -EACCES;\n\t\t}\n\t\t/* a constant was added to pkt_ptr.\n\t\t * Remember it while keeping the same 'id'\n\t\t */\n\t\tdst_reg->off += imm;\n\t} else {\n\t\tif (src_reg->type == PTR_TO_PACKET) {\n\t\t\t/* R6=pkt(id=0,off=0,r=62) R7=imm22; r7 += r6 */\n\t\t\ttmp_reg = *dst_reg;  /* save r7 state */\n\t\t\t*dst_reg = *src_reg; /* copy pkt_ptr state r6 into r7 */\n\t\t\tsrc_reg = &tmp_reg;  /* pretend it's src_reg state */\n\t\t\t/* if the checks below reject it, the copy won't matter,\n\t\t\t * since we're rejecting the whole program. If all ok,\n\t\t\t * then imm22 state will be added to r7\n\t\t\t * and r7 will be pkt(id=0,off=22,r=62) while\n\t\t\t * r6 will stay as pkt(id=0,off=0,r=62)\n\t\t\t */\n\t\t}\n\n\t\tif (src_reg->type == CONST_IMM) {\n\t\t\t/* pkt_ptr += reg where reg is known constant */\n\t\t\timm = src_reg->imm;\n\t\t\tgoto add_imm;\n\t\t}\n\t\t/* disallow pkt_ptr += reg\n\t\t * if reg is not uknown_value with guaranteed zero upper bits\n\t\t * otherwise pkt_ptr may overflow and addition will become\n\t\t * subtraction which is not allowed\n\t\t */\n\t\tif (src_reg->type != UNKNOWN_VALUE) {\n\t\t\tverbose(\"cannot add '%s' to ptr_to_packet\\n\",\n\t\t\t\treg_type_str[src_reg->type]);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (src_reg->imm < 48) {\n\t\t\tverbose(\"cannot add integer value with %lld upper zero bits to ptr_to_packet\\n\",\n\t\t\t\tsrc_reg->imm);\n\t\t\treturn -EACCES;\n\t\t}\n\t\t/* dst_reg stays as pkt_ptr type and since some positive\n\t\t * integer value was added to the pointer, increment its 'id'\n\t\t */\n\t\tdst_reg->id = ++env->id_gen;\n\n\t\t/* something was added to pkt_ptr, set range and off to zero */\n\t\tdst_reg->off = 0;\n\t\tdst_reg->range = 0;\n\t}\n\treturn 0;\n}\n\nstatic int evaluate_reg_alu(struct bpf_verifier_env *env, struct bpf_insn *insn)\n{\n\tstruct bpf_reg_state *regs = env->cur_state.regs;\n\tstruct bpf_reg_state *dst_reg = &regs[insn->dst_reg];\n\tu8 opcode = BPF_OP(insn->code);\n\ts64 imm_log2;\n\n\t/* for type == UNKNOWN_VALUE:\n\t * imm > 0 -> number of zero upper bits\n\t * imm == 0 -> don't track which is the same as all bits can be non-zero\n\t */\n\n\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\tstruct bpf_reg_state *src_reg = &regs[insn->src_reg];\n\n\t\tif (src_reg->type == UNKNOWN_VALUE && src_reg->imm > 0 &&\n\t\t    dst_reg->imm && opcode == BPF_ADD) {\n\t\t\t/* dreg += sreg\n\t\t\t * where both have zero upper bits. Adding them\n\t\t\t * can only result making one more bit non-zero\n\t\t\t * in the larger value.\n\t\t\t * Ex. 0xffff (imm=48) + 1 (imm=63) = 0x10000 (imm=47)\n\t\t\t *     0xffff (imm=48) + 0xffff = 0x1fffe (imm=47)\n\t\t\t */\n\t\t\tdst_reg->imm = min(dst_reg->imm, src_reg->imm);\n\t\t\tdst_reg->imm--;\n\t\t\treturn 0;\n\t\t}\n\t\tif (src_reg->type == CONST_IMM && src_reg->imm > 0 &&\n\t\t    dst_reg->imm && opcode == BPF_ADD) {\n\t\t\t/* dreg += sreg\n\t\t\t * where dreg has zero upper bits and sreg is const.\n\t\t\t * Adding them can only result making one more bit\n\t\t\t * non-zero in the larger value.\n\t\t\t */\n\t\t\timm_log2 = __ilog2_u64((long long)src_reg->imm);\n\t\t\tdst_reg->imm = min(dst_reg->imm, 63 - imm_log2);\n\t\t\tdst_reg->imm--;\n\t\t\treturn 0;\n\t\t}\n\t\t/* all other cases non supported yet, just mark dst_reg */\n\t\tdst_reg->imm = 0;\n\t\treturn 0;\n\t}\n\n\t/* sign extend 32-bit imm into 64-bit to make sure that\n\t * negative values occupy bit 63. Note ilog2() would have\n\t * been incorrect, since sizeof(insn->imm) == 4\n\t */\n\timm_log2 = __ilog2_u64((long long)insn->imm);\n\n\tif (dst_reg->imm && opcode == BPF_LSH) {\n\t\t/* reg <<= imm\n\t\t * if reg was a result of 2 byte load, then its imm == 48\n\t\t * which means that upper 48 bits are zero and shifting this reg\n\t\t * left by 4 would mean that upper 44 bits are still zero\n\t\t */\n\t\tdst_reg->imm -= insn->imm;\n\t} else if (dst_reg->imm && opcode == BPF_MUL) {\n\t\t/* reg *= imm\n\t\t * if multiplying by 14 subtract 4\n\t\t * This is conservative calculation of upper zero bits.\n\t\t * It's not trying to special case insn->imm == 1 or 0 cases\n\t\t */\n\t\tdst_reg->imm -= imm_log2 + 1;\n\t} else if (opcode == BPF_AND) {\n\t\t/* reg &= imm */\n\t\tdst_reg->imm = 63 - imm_log2;\n\t} else if (dst_reg->imm && opcode == BPF_ADD) {\n\t\t/* reg += imm */\n\t\tdst_reg->imm = min(dst_reg->imm, 63 - imm_log2);\n\t\tdst_reg->imm--;\n\t} else if (opcode == BPF_RSH) {\n\t\t/* reg >>= imm\n\t\t * which means that after right shift, upper bits will be zero\n\t\t * note that verifier already checked that\n\t\t * 0 <= imm < 64 for shift insn\n\t\t */\n\t\tdst_reg->imm += insn->imm;\n\t\tif (unlikely(dst_reg->imm > 64))\n\t\t\t/* some dumb code did:\n\t\t\t * r2 = *(u32 *)mem;\n\t\t\t * r2 >>= 32;\n\t\t\t * and all bits are zero now */\n\t\t\tdst_reg->imm = 64;\n\t} else {\n\t\t/* all other alu ops, means that we don't know what will\n\t\t * happen to the value, mark it with unknown number of zero bits\n\t\t */\n\t\tdst_reg->imm = 0;\n\t}\n\n\tif (dst_reg->imm < 0) {\n\t\t/* all 64 bits of the register can contain non-zero bits\n\t\t * and such value cannot be added to ptr_to_packet, since it\n\t\t * may overflow, mark it as unknown to avoid further eval\n\t\t */\n\t\tdst_reg->imm = 0;\n\t}\n\treturn 0;\n}\n\nstatic int evaluate_reg_imm_alu(struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_insn *insn)\n{\n\tstruct bpf_reg_state *regs = env->cur_state.regs;\n\tstruct bpf_reg_state *dst_reg = &regs[insn->dst_reg];\n\tstruct bpf_reg_state *src_reg = &regs[insn->src_reg];\n\tu8 opcode = BPF_OP(insn->code);\n\tu64 dst_imm = dst_reg->imm;\n\n\t/* dst_reg->type == CONST_IMM here. Simulate execution of insns\n\t * containing ALU ops. Don't care about overflow or negative\n\t * values, just add/sub/... them; registers are in u64.\n\t */\n\tif (opcode == BPF_ADD && BPF_SRC(insn->code) == BPF_K) {\n\t\tdst_imm += insn->imm;\n\t} else if (opcode == BPF_ADD && BPF_SRC(insn->code) == BPF_X &&\n\t\t   src_reg->type == CONST_IMM) {\n\t\tdst_imm += src_reg->imm;\n\t} else if (opcode == BPF_SUB && BPF_SRC(insn->code) == BPF_K) {\n\t\tdst_imm -= insn->imm;\n\t} else if (opcode == BPF_SUB && BPF_SRC(insn->code) == BPF_X &&\n\t\t   src_reg->type == CONST_IMM) {\n\t\tdst_imm -= src_reg->imm;\n\t} else if (opcode == BPF_MUL && BPF_SRC(insn->code) == BPF_K) {\n\t\tdst_imm *= insn->imm;\n\t} else if (opcode == BPF_MUL && BPF_SRC(insn->code) == BPF_X &&\n\t\t   src_reg->type == CONST_IMM) {\n\t\tdst_imm *= src_reg->imm;\n\t} else if (opcode == BPF_OR && BPF_SRC(insn->code) == BPF_K) {\n\t\tdst_imm |= insn->imm;\n\t} else if (opcode == BPF_OR && BPF_SRC(insn->code) == BPF_X &&\n\t\t   src_reg->type == CONST_IMM) {\n\t\tdst_imm |= src_reg->imm;\n\t} else if (opcode == BPF_AND && BPF_SRC(insn->code) == BPF_K) {\n\t\tdst_imm &= insn->imm;\n\t} else if (opcode == BPF_AND && BPF_SRC(insn->code) == BPF_X &&\n\t\t   src_reg->type == CONST_IMM) {\n\t\tdst_imm &= src_reg->imm;\n\t} else if (opcode == BPF_RSH && BPF_SRC(insn->code) == BPF_K) {\n\t\tdst_imm >>= insn->imm;\n\t} else if (opcode == BPF_RSH && BPF_SRC(insn->code) == BPF_X &&\n\t\t   src_reg->type == CONST_IMM) {\n\t\tdst_imm >>= src_reg->imm;\n\t} else if (opcode == BPF_LSH && BPF_SRC(insn->code) == BPF_K) {\n\t\tdst_imm <<= insn->imm;\n\t} else if (opcode == BPF_LSH && BPF_SRC(insn->code) == BPF_X &&\n\t\t   src_reg->type == CONST_IMM) {\n\t\tdst_imm <<= src_reg->imm;\n\t} else {\n\t\tmark_reg_unknown_value(regs, insn->dst_reg);\n\t\tgoto out;\n\t}\n\n\tdst_reg->imm = dst_imm;\nout:\n\treturn 0;\n}\n\nstatic void check_reg_overflow(struct bpf_reg_state *reg)\n{\n\tif (reg->max_value > BPF_REGISTER_MAX_RANGE)\n\t\treg->max_value = BPF_REGISTER_MAX_RANGE;\n\tif (reg->min_value < BPF_REGISTER_MIN_RANGE ||\n\t    reg->min_value > BPF_REGISTER_MAX_RANGE)\n\t\treg->min_value = BPF_REGISTER_MIN_RANGE;\n}\n\nstatic void adjust_reg_min_max_vals(struct bpf_verifier_env *env,\n\t\t\t\t    struct bpf_insn *insn)\n{\n\tstruct bpf_reg_state *regs = env->cur_state.regs, *dst_reg;\n\ts64 min_val = BPF_REGISTER_MIN_RANGE;\n\tu64 max_val = BPF_REGISTER_MAX_RANGE;\n\tu8 opcode = BPF_OP(insn->code);\n\n\tdst_reg = &regs[insn->dst_reg];\n\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\tcheck_reg_overflow(&regs[insn->src_reg]);\n\t\tmin_val = regs[insn->src_reg].min_value;\n\t\tmax_val = regs[insn->src_reg].max_value;\n\n\t\t/* If the source register is a random pointer then the\n\t\t * min_value/max_value values represent the range of the known\n\t\t * accesses into that value, not the actual min/max value of the\n\t\t * register itself.  In this case we have to reset the reg range\n\t\t * values so we know it is not safe to look at.\n\t\t */\n\t\tif (regs[insn->src_reg].type != CONST_IMM &&\n\t\t    regs[insn->src_reg].type != UNKNOWN_VALUE) {\n\t\t\tmin_val = BPF_REGISTER_MIN_RANGE;\n\t\t\tmax_val = BPF_REGISTER_MAX_RANGE;\n\t\t}\n\t} else if (insn->imm < BPF_REGISTER_MAX_RANGE &&\n\t\t   (s64)insn->imm > BPF_REGISTER_MIN_RANGE) {\n\t\tmin_val = max_val = insn->imm;\n\t}\n\n\t/* We don't know anything about what was done to this register, mark it\n\t * as unknown.\n\t */\n\tif (min_val == BPF_REGISTER_MIN_RANGE &&\n\t    max_val == BPF_REGISTER_MAX_RANGE) {\n\t\treset_reg_range_values(regs, insn->dst_reg);\n\t\treturn;\n\t}\n\n\t/* If one of our values was at the end of our ranges then we can't just\n\t * do our normal operations to the register, we need to set the values\n\t * to the min/max since they are undefined.\n\t */\n\tif (min_val == BPF_REGISTER_MIN_RANGE)\n\t\tdst_reg->min_value = BPF_REGISTER_MIN_RANGE;\n\tif (max_val == BPF_REGISTER_MAX_RANGE)\n\t\tdst_reg->max_value = BPF_REGISTER_MAX_RANGE;\n\n\tswitch (opcode) {\n\tcase BPF_ADD:\n\t\tif (dst_reg->min_value != BPF_REGISTER_MIN_RANGE)\n\t\t\tdst_reg->min_value += min_val;\n\t\tif (dst_reg->max_value != BPF_REGISTER_MAX_RANGE)\n\t\t\tdst_reg->max_value += max_val;\n\t\tbreak;\n\tcase BPF_SUB:\n\t\tif (dst_reg->min_value != BPF_REGISTER_MIN_RANGE)\n\t\t\tdst_reg->min_value -= min_val;\n\t\tif (dst_reg->max_value != BPF_REGISTER_MAX_RANGE)\n\t\t\tdst_reg->max_value -= max_val;\n\t\tbreak;\n\tcase BPF_MUL:\n\t\tif (dst_reg->min_value != BPF_REGISTER_MIN_RANGE)\n\t\t\tdst_reg->min_value *= min_val;\n\t\tif (dst_reg->max_value != BPF_REGISTER_MAX_RANGE)\n\t\t\tdst_reg->max_value *= max_val;\n\t\tbreak;\n\tcase BPF_AND:\n\t\t/* Disallow AND'ing of negative numbers, ain't nobody got time\n\t\t * for that.  Otherwise the minimum is 0 and the max is the max\n\t\t * value we could AND against.\n\t\t */\n\t\tif (min_val < 0)\n\t\t\tdst_reg->min_value = BPF_REGISTER_MIN_RANGE;\n\t\telse\n\t\t\tdst_reg->min_value = 0;\n\t\tdst_reg->max_value = max_val;\n\t\tbreak;\n\tcase BPF_LSH:\n\t\t/* Gotta have special overflow logic here, if we're shifting\n\t\t * more than MAX_RANGE then just assume we have an invalid\n\t\t * range.\n\t\t */\n\t\tif (min_val > ilog2(BPF_REGISTER_MAX_RANGE))\n\t\t\tdst_reg->min_value = BPF_REGISTER_MIN_RANGE;\n\t\telse if (dst_reg->min_value != BPF_REGISTER_MIN_RANGE)\n\t\t\tdst_reg->min_value <<= min_val;\n\n\t\tif (max_val > ilog2(BPF_REGISTER_MAX_RANGE))\n\t\t\tdst_reg->max_value = BPF_REGISTER_MAX_RANGE;\n\t\telse if (dst_reg->max_value != BPF_REGISTER_MAX_RANGE)\n\t\t\tdst_reg->max_value <<= max_val;\n\t\tbreak;\n\tcase BPF_RSH:\n\t\t/* RSH by a negative number is undefined, and the BPF_RSH is an\n\t\t * unsigned shift, so make the appropriate casts.\n\t\t */\n\t\tif (min_val < 0 || dst_reg->min_value < 0)\n\t\t\tdst_reg->min_value = BPF_REGISTER_MIN_RANGE;\n\t\telse\n\t\t\tdst_reg->min_value =\n\t\t\t\t(u64)(dst_reg->min_value) >> min_val;\n\t\tif (dst_reg->max_value != BPF_REGISTER_MAX_RANGE)\n\t\t\tdst_reg->max_value >>= max_val;\n\t\tbreak;\n\tdefault:\n\t\treset_reg_range_values(regs, insn->dst_reg);\n\t\tbreak;\n\t}\n\n\tcheck_reg_overflow(dst_reg);\n}\n\n/* check validity of 32-bit and 64-bit arithmetic operations */\nstatic int check_alu_op(struct bpf_verifier_env *env, struct bpf_insn *insn)\n{\n\tstruct bpf_reg_state *regs = env->cur_state.regs, *dst_reg;\n\tu8 opcode = BPF_OP(insn->code);\n\tint err;\n\n\tif (opcode == BPF_END || opcode == BPF_NEG) {\n\t\tif (opcode == BPF_NEG) {\n\t\t\tif (BPF_SRC(insn->code) != 0 ||\n\t\t\t    insn->src_reg != BPF_REG_0 ||\n\t\t\t    insn->off != 0 || insn->imm != 0) {\n\t\t\t\tverbose(\"BPF_NEG uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0 ||\n\t\t\t    (insn->imm != 16 && insn->imm != 32 && insn->imm != 64)) {\n\t\t\t\tverbose(\"BPF_END uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check src operand */\n\t\terr = check_reg_arg(regs, insn->dst_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (is_pointer_value(env, insn->dst_reg)) {\n\t\t\tverbose(\"R%d pointer arithmetic prohibited\\n\",\n\t\t\t\tinsn->dst_reg);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\t/* check dest operand */\n\t\terr = check_reg_arg(regs, insn->dst_reg, DST_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t} else if (opcode == BPF_MOV) {\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (insn->imm != 0 || insn->off != 0) {\n\t\t\t\tverbose(\"BPF_MOV uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t/* check src operand */\n\t\t\terr = check_reg_arg(regs, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0) {\n\t\t\t\tverbose(\"BPF_MOV uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check dest operand */\n\t\terr = check_reg_arg(regs, insn->dst_reg, DST_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t/* we are setting our register to something new, we need to\n\t\t * reset its range values.\n\t\t */\n\t\treset_reg_range_values(regs, insn->dst_reg);\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64) {\n\t\t\t\t/* case: R1 = R2\n\t\t\t\t * copy register state to dest reg\n\t\t\t\t */\n\t\t\t\tregs[insn->dst_reg] = regs[insn->src_reg];\n\t\t\t} else {\n\t\t\t\tif (is_pointer_value(env, insn->src_reg)) {\n\t\t\t\t\tverbose(\"R%d partial copy of pointer\\n\",\n\t\t\t\t\t\tinsn->src_reg);\n\t\t\t\t\treturn -EACCES;\n\t\t\t\t}\n\t\t\t\tmark_reg_unknown_value(regs, insn->dst_reg);\n\t\t\t}\n\t\t} else {\n\t\t\t/* case: R = imm\n\t\t\t * remember the value we stored into this reg\n\t\t\t */\n\t\t\tregs[insn->dst_reg].type = CONST_IMM;\n\t\t\tregs[insn->dst_reg].imm = insn->imm;\n\t\t\tregs[insn->dst_reg].max_value = insn->imm;\n\t\t\tregs[insn->dst_reg].min_value = insn->imm;\n\t\t}\n\n\t} else if (opcode > BPF_END) {\n\t\tverbose(\"invalid BPF_ALU opcode %x\\n\", opcode);\n\t\treturn -EINVAL;\n\n\t} else {\t/* all other ALU ops: and, sub, xor, add, ... */\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (insn->imm != 0 || insn->off != 0) {\n\t\t\t\tverbose(\"BPF_ALU uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t/* check src1 operand */\n\t\t\terr = check_reg_arg(regs, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0) {\n\t\t\t\tverbose(\"BPF_ALU uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check src2 operand */\n\t\terr = check_reg_arg(regs, insn->dst_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif ((opcode == BPF_MOD || opcode == BPF_DIV) &&\n\t\t    BPF_SRC(insn->code) == BPF_K && insn->imm == 0) {\n\t\t\tverbose(\"div by zero\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif ((opcode == BPF_LSH || opcode == BPF_RSH ||\n\t\t     opcode == BPF_ARSH) && BPF_SRC(insn->code) == BPF_K) {\n\t\t\tint size = BPF_CLASS(insn->code) == BPF_ALU64 ? 64 : 32;\n\n\t\t\tif (insn->imm < 0 || insn->imm >= size) {\n\t\t\t\tverbose(\"invalid shift %d\\n\", insn->imm);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check dest operand */\n\t\terr = check_reg_arg(regs, insn->dst_reg, DST_OP_NO_MARK);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tdst_reg = &regs[insn->dst_reg];\n\n\t\t/* first we want to adjust our ranges. */\n\t\tadjust_reg_min_max_vals(env, insn);\n\n\t\t/* pattern match 'bpf_add Rx, imm' instruction */\n\t\tif (opcode == BPF_ADD && BPF_CLASS(insn->code) == BPF_ALU64 &&\n\t\t    dst_reg->type == FRAME_PTR && BPF_SRC(insn->code) == BPF_K) {\n\t\t\tdst_reg->type = PTR_TO_STACK;\n\t\t\tdst_reg->imm = insn->imm;\n\t\t\treturn 0;\n\t\t} else if (opcode == BPF_ADD &&\n\t\t\t   BPF_CLASS(insn->code) == BPF_ALU64 &&\n\t\t\t   dst_reg->type == PTR_TO_STACK &&\n\t\t\t   ((BPF_SRC(insn->code) == BPF_X &&\n\t\t\t     regs[insn->src_reg].type == CONST_IMM) ||\n\t\t\t    BPF_SRC(insn->code) == BPF_K)) {\n\t\t\tif (BPF_SRC(insn->code) == BPF_X)\n\t\t\t\tdst_reg->imm += regs[insn->src_reg].imm;\n\t\t\telse\n\t\t\t\tdst_reg->imm += insn->imm;\n\t\t\treturn 0;\n\t\t} else if (opcode == BPF_ADD &&\n\t\t\t   BPF_CLASS(insn->code) == BPF_ALU64 &&\n\t\t\t   (dst_reg->type == PTR_TO_PACKET ||\n\t\t\t    (BPF_SRC(insn->code) == BPF_X &&\n\t\t\t     regs[insn->src_reg].type == PTR_TO_PACKET))) {\n\t\t\t/* ptr_to_packet += K|X */\n\t\t\treturn check_packet_ptr_add(env, insn);\n\t\t} else if (BPF_CLASS(insn->code) == BPF_ALU64 &&\n\t\t\t   dst_reg->type == UNKNOWN_VALUE &&\n\t\t\t   env->allow_ptr_leaks) {\n\t\t\t/* unknown += K|X */\n\t\t\treturn evaluate_reg_alu(env, insn);\n\t\t} else if (BPF_CLASS(insn->code) == BPF_ALU64 &&\n\t\t\t   dst_reg->type == CONST_IMM &&\n\t\t\t   env->allow_ptr_leaks) {\n\t\t\t/* reg_imm += K|X */\n\t\t\treturn evaluate_reg_imm_alu(env, insn);\n\t\t} else if (is_pointer_value(env, insn->dst_reg)) {\n\t\t\tverbose(\"R%d pointer arithmetic prohibited\\n\",\n\t\t\t\tinsn->dst_reg);\n\t\t\treturn -EACCES;\n\t\t} else if (BPF_SRC(insn->code) == BPF_X &&\n\t\t\t   is_pointer_value(env, insn->src_reg)) {\n\t\t\tverbose(\"R%d pointer arithmetic prohibited\\n\",\n\t\t\t\tinsn->src_reg);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\t/* If we did pointer math on a map value then just set it to our\n\t\t * PTR_TO_MAP_VALUE_ADJ type so we can deal with any stores or\n\t\t * loads to this register appropriately, otherwise just mark the\n\t\t * register as unknown.\n\t\t */\n\t\tif (env->allow_ptr_leaks &&\n\t\t    BPF_CLASS(insn->code) == BPF_ALU64 && opcode == BPF_ADD &&\n\t\t    (dst_reg->type == PTR_TO_MAP_VALUE ||\n\t\t     dst_reg->type == PTR_TO_MAP_VALUE_ADJ))\n\t\t\tdst_reg->type = PTR_TO_MAP_VALUE_ADJ;\n\t\telse\n\t\t\tmark_reg_unknown_value(regs, insn->dst_reg);\n\t}\n\n\treturn 0;\n}\n\nstatic void find_good_pkt_pointers(struct bpf_verifier_state *state,\n\t\t\t\t   struct bpf_reg_state *dst_reg)\n{\n\tstruct bpf_reg_state *regs = state->regs, *reg;\n\tint i;\n\n\t/* LLVM can generate two kind of checks:\n\t *\n\t * Type 1:\n\t *\n\t *   r2 = r3;\n\t *   r2 += 8;\n\t *   if (r2 > pkt_end) goto <handle exception>\n\t *   <access okay>\n\t *\n\t *   Where:\n\t *     r2 == dst_reg, pkt_end == src_reg\n\t *     r2=pkt(id=n,off=8,r=0)\n\t *     r3=pkt(id=n,off=0,r=0)\n\t *\n\t * Type 2:\n\t *\n\t *   r2 = r3;\n\t *   r2 += 8;\n\t *   if (pkt_end >= r2) goto <access okay>\n\t *   <handle exception>\n\t *\n\t *   Where:\n\t *     pkt_end == dst_reg, r2 == src_reg\n\t *     r2=pkt(id=n,off=8,r=0)\n\t *     r3=pkt(id=n,off=0,r=0)\n\t *\n\t * Find register r3 and mark its range as r3=pkt(id=n,off=0,r=8)\n\t * so that range of bytes [r3, r3 + 8) is safe to access.\n\t */\n\n\tfor (i = 0; i < MAX_BPF_REG; i++)\n\t\tif (regs[i].type == PTR_TO_PACKET && regs[i].id == dst_reg->id)\n\t\t\t/* keep the maximum range already checked */\n\t\t\tregs[i].range = max(regs[i].range, dst_reg->off);\n\n\tfor (i = 0; i < MAX_BPF_STACK; i += BPF_REG_SIZE) {\n\t\tif (state->stack_slot_type[i] != STACK_SPILL)\n\t\t\tcontinue;\n\t\treg = &state->spilled_regs[i / BPF_REG_SIZE];\n\t\tif (reg->type == PTR_TO_PACKET && reg->id == dst_reg->id)\n\t\t\treg->range = max(reg->range, dst_reg->off);\n\t}\n}\n\n/* Adjusts the register min/max values in the case that the dst_reg is the\n * variable register that we are working on, and src_reg is a constant or we're\n * simply doing a BPF_K check.\n */\nstatic void reg_set_min_max(struct bpf_reg_state *true_reg,\n\t\t\t    struct bpf_reg_state *false_reg, u64 val,\n\t\t\t    u8 opcode)\n{\n\tswitch (opcode) {\n\tcase BPF_JEQ:\n\t\t/* If this is false then we know nothing Jon Snow, but if it is\n\t\t * true then we know for sure.\n\t\t */\n\t\ttrue_reg->max_value = true_reg->min_value = val;\n\t\tbreak;\n\tcase BPF_JNE:\n\t\t/* If this is true we know nothing Jon Snow, but if it is false\n\t\t * we know the value for sure;\n\t\t */\n\t\tfalse_reg->max_value = false_reg->min_value = val;\n\t\tbreak;\n\tcase BPF_JGT:\n\t\t/* Unsigned comparison, the minimum value is 0. */\n\t\tfalse_reg->min_value = 0;\n\t\t/* fallthrough */\n\tcase BPF_JSGT:\n\t\t/* If this is false then we know the maximum val is val,\n\t\t * otherwise we know the min val is val+1.\n\t\t */\n\t\tfalse_reg->max_value = val;\n\t\ttrue_reg->min_value = val + 1;\n\t\tbreak;\n\tcase BPF_JGE:\n\t\t/* Unsigned comparison, the minimum value is 0. */\n\t\tfalse_reg->min_value = 0;\n\t\t/* fallthrough */\n\tcase BPF_JSGE:\n\t\t/* If this is false then we know the maximum value is val - 1,\n\t\t * otherwise we know the mimimum value is val.\n\t\t */\n\t\tfalse_reg->max_value = val - 1;\n\t\ttrue_reg->min_value = val;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tcheck_reg_overflow(false_reg);\n\tcheck_reg_overflow(true_reg);\n}\n\n/* Same as above, but for the case that dst_reg is a CONST_IMM reg and src_reg\n * is the variable reg.\n */\nstatic void reg_set_min_max_inv(struct bpf_reg_state *true_reg,\n\t\t\t\tstruct bpf_reg_state *false_reg, u64 val,\n\t\t\t\tu8 opcode)\n{\n\tswitch (opcode) {\n\tcase BPF_JEQ:\n\t\t/* If this is false then we know nothing Jon Snow, but if it is\n\t\t * true then we know for sure.\n\t\t */\n\t\ttrue_reg->max_value = true_reg->min_value = val;\n\t\tbreak;\n\tcase BPF_JNE:\n\t\t/* If this is true we know nothing Jon Snow, but if it is false\n\t\t * we know the value for sure;\n\t\t */\n\t\tfalse_reg->max_value = false_reg->min_value = val;\n\t\tbreak;\n\tcase BPF_JGT:\n\t\t/* Unsigned comparison, the minimum value is 0. */\n\t\ttrue_reg->min_value = 0;\n\t\t/* fallthrough */\n\tcase BPF_JSGT:\n\t\t/*\n\t\t * If this is false, then the val is <= the register, if it is\n\t\t * true the register <= to the val.\n\t\t */\n\t\tfalse_reg->min_value = val;\n\t\ttrue_reg->max_value = val - 1;\n\t\tbreak;\n\tcase BPF_JGE:\n\t\t/* Unsigned comparison, the minimum value is 0. */\n\t\ttrue_reg->min_value = 0;\n\t\t/* fallthrough */\n\tcase BPF_JSGE:\n\t\t/* If this is false then constant < register, if it is true then\n\t\t * the register < constant.\n\t\t */\n\t\tfalse_reg->min_value = val + 1;\n\t\ttrue_reg->max_value = val;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tcheck_reg_overflow(false_reg);\n\tcheck_reg_overflow(true_reg);\n}\n\nstatic void mark_map_reg(struct bpf_reg_state *regs, u32 regno, u32 id,\n\t\t\t enum bpf_reg_type type)\n{\n\tstruct bpf_reg_state *reg = &regs[regno];\n\n\tif (reg->type == PTR_TO_MAP_VALUE_OR_NULL && reg->id == id) {\n\t\tif (type == UNKNOWN_VALUE) {\n\t\t\t__mark_reg_unknown_value(regs, regno);\n\t\t} else if (reg->map_ptr->inner_map_meta) {\n\t\t\treg->type = CONST_PTR_TO_MAP;\n\t\t\treg->map_ptr = reg->map_ptr->inner_map_meta;\n\t\t} else {\n\t\t\treg->type = type;\n\t\t}\n\t\t/* We don't need id from this point onwards anymore, thus we\n\t\t * should better reset it, so that state pruning has chances\n\t\t * to take effect.\n\t\t */\n\t\treg->id = 0;\n\t}\n}\n\n/* The logic is similar to find_good_pkt_pointers(), both could eventually\n * be folded together at some point.\n */\nstatic void mark_map_regs(struct bpf_verifier_state *state, u32 regno,\n\t\t\t  enum bpf_reg_type type)\n{\n\tstruct bpf_reg_state *regs = state->regs;\n\tu32 id = regs[regno].id;\n\tint i;\n\n\tfor (i = 0; i < MAX_BPF_REG; i++)\n\t\tmark_map_reg(regs, i, id, type);\n\n\tfor (i = 0; i < MAX_BPF_STACK; i += BPF_REG_SIZE) {\n\t\tif (state->stack_slot_type[i] != STACK_SPILL)\n\t\t\tcontinue;\n\t\tmark_map_reg(state->spilled_regs, i / BPF_REG_SIZE, id, type);\n\t}\n}\n\nstatic int check_cond_jmp_op(struct bpf_verifier_env *env,\n\t\t\t     struct bpf_insn *insn, int *insn_idx)\n{\n\tstruct bpf_verifier_state *other_branch, *this_branch = &env->cur_state;\n\tstruct bpf_reg_state *regs = this_branch->regs, *dst_reg;\n\tu8 opcode = BPF_OP(insn->code);\n\tint err;\n\n\tif (opcode > BPF_EXIT) {\n\t\tverbose(\"invalid BPF_JMP opcode %x\\n\", opcode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\tif (insn->imm != 0) {\n\t\t\tverbose(\"BPF_JMP uses reserved fields\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* check src1 operand */\n\t\terr = check_reg_arg(regs, insn->src_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (is_pointer_value(env, insn->src_reg)) {\n\t\t\tverbose(\"R%d pointer comparison prohibited\\n\",\n\t\t\t\tinsn->src_reg);\n\t\t\treturn -EACCES;\n\t\t}\n\t} else {\n\t\tif (insn->src_reg != BPF_REG_0) {\n\t\t\tverbose(\"BPF_JMP uses reserved fields\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* check src2 operand */\n\terr = check_reg_arg(regs, insn->dst_reg, SRC_OP);\n\tif (err)\n\t\treturn err;\n\n\tdst_reg = &regs[insn->dst_reg];\n\n\t/* detect if R == 0 where R was initialized to zero earlier */\n\tif (BPF_SRC(insn->code) == BPF_K &&\n\t    (opcode == BPF_JEQ || opcode == BPF_JNE) &&\n\t    dst_reg->type == CONST_IMM && dst_reg->imm == insn->imm) {\n\t\tif (opcode == BPF_JEQ) {\n\t\t\t/* if (imm == imm) goto pc+off;\n\t\t\t * only follow the goto, ignore fall-through\n\t\t\t */\n\t\t\t*insn_idx += insn->off;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/* if (imm != imm) goto pc+off;\n\t\t\t * only follow fall-through branch, since\n\t\t\t * that's where the program will go\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tother_branch = push_stack(env, *insn_idx + insn->off + 1, *insn_idx);\n\tif (!other_branch)\n\t\treturn -EFAULT;\n\n\t/* detect if we are comparing against a constant value so we can adjust\n\t * our min/max values for our dst register.\n\t */\n\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\tif (regs[insn->src_reg].type == CONST_IMM)\n\t\t\treg_set_min_max(&other_branch->regs[insn->dst_reg],\n\t\t\t\t\tdst_reg, regs[insn->src_reg].imm,\n\t\t\t\t\topcode);\n\t\telse if (dst_reg->type == CONST_IMM)\n\t\t\treg_set_min_max_inv(&other_branch->regs[insn->src_reg],\n\t\t\t\t\t    &regs[insn->src_reg], dst_reg->imm,\n\t\t\t\t\t    opcode);\n\t} else {\n\t\treg_set_min_max(&other_branch->regs[insn->dst_reg],\n\t\t\t\t\tdst_reg, insn->imm, opcode);\n\t}\n\n\t/* detect if R == 0 where R is returned from bpf_map_lookup_elem() */\n\tif (BPF_SRC(insn->code) == BPF_K &&\n\t    insn->imm == 0 && (opcode == BPF_JEQ || opcode == BPF_JNE) &&\n\t    dst_reg->type == PTR_TO_MAP_VALUE_OR_NULL) {\n\t\t/* Mark all identical map registers in each branch as either\n\t\t * safe or unknown depending R == 0 or R != 0 conditional.\n\t\t */\n\t\tmark_map_regs(this_branch, insn->dst_reg,\n\t\t\t      opcode == BPF_JEQ ? PTR_TO_MAP_VALUE : UNKNOWN_VALUE);\n\t\tmark_map_regs(other_branch, insn->dst_reg,\n\t\t\t      opcode == BPF_JEQ ? UNKNOWN_VALUE : PTR_TO_MAP_VALUE);\n\t} else if (BPF_SRC(insn->code) == BPF_X && opcode == BPF_JGT &&\n\t\t   dst_reg->type == PTR_TO_PACKET &&\n\t\t   regs[insn->src_reg].type == PTR_TO_PACKET_END) {\n\t\tfind_good_pkt_pointers(this_branch, dst_reg);\n\t} else if (BPF_SRC(insn->code) == BPF_X && opcode == BPF_JGE &&\n\t\t   dst_reg->type == PTR_TO_PACKET_END &&\n\t\t   regs[insn->src_reg].type == PTR_TO_PACKET) {\n\t\tfind_good_pkt_pointers(other_branch, &regs[insn->src_reg]);\n\t} else if (is_pointer_value(env, insn->dst_reg)) {\n\t\tverbose(\"R%d pointer comparison prohibited\\n\", insn->dst_reg);\n\t\treturn -EACCES;\n\t}\n\tif (log_level)\n\t\tprint_verifier_state(this_branch);\n\treturn 0;\n}\n\n/* return the map pointer stored inside BPF_LD_IMM64 instruction */\nstatic struct bpf_map *ld_imm64_to_map_ptr(struct bpf_insn *insn)\n{\n\tu64 imm64 = ((u64) (u32) insn[0].imm) | ((u64) (u32) insn[1].imm) << 32;\n\n\treturn (struct bpf_map *) (unsigned long) imm64;\n}\n\n/* verify BPF_LD_IMM64 instruction */\nstatic int check_ld_imm(struct bpf_verifier_env *env, struct bpf_insn *insn)\n{\n\tstruct bpf_reg_state *regs = env->cur_state.regs;\n\tint err;\n\n\tif (BPF_SIZE(insn->code) != BPF_DW) {\n\t\tverbose(\"invalid BPF_LD_IMM insn\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (insn->off != 0) {\n\t\tverbose(\"BPF_LD_IMM64 uses reserved fields\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = check_reg_arg(regs, insn->dst_reg, DST_OP);\n\tif (err)\n\t\treturn err;\n\n\tif (insn->src_reg == 0) {\n\t\tu64 imm = ((u64)(insn + 1)->imm << 32) | (u32)insn->imm;\n\n\t\tregs[insn->dst_reg].type = CONST_IMM;\n\t\tregs[insn->dst_reg].imm = imm;\n\t\treturn 0;\n\t}\n\n\t/* replace_map_fd_with_map_ptr() should have caught bad ld_imm64 */\n\tBUG_ON(insn->src_reg != BPF_PSEUDO_MAP_FD);\n\n\tregs[insn->dst_reg].type = CONST_PTR_TO_MAP;\n\tregs[insn->dst_reg].map_ptr = ld_imm64_to_map_ptr(insn);\n\treturn 0;\n}\n\nstatic bool may_access_skb(enum bpf_prog_type type)\n{\n\tswitch (type) {\n\tcase BPF_PROG_TYPE_SOCKET_FILTER:\n\tcase BPF_PROG_TYPE_SCHED_CLS:\n\tcase BPF_PROG_TYPE_SCHED_ACT:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n/* verify safety of LD_ABS|LD_IND instructions:\n * - they can only appear in the programs where ctx == skb\n * - since they are wrappers of function calls, they scratch R1-R5 registers,\n *   preserve R6-R9, and store return value into R0\n *\n * Implicit input:\n *   ctx == skb == R6 == CTX\n *\n * Explicit input:\n *   SRC == any register\n *   IMM == 32-bit immediate\n *\n * Output:\n *   R0 - 8/16/32-bit skb data converted to cpu endianness\n */\nstatic int check_ld_abs(struct bpf_verifier_env *env, struct bpf_insn *insn)\n{\n\tstruct bpf_reg_state *regs = env->cur_state.regs;\n\tu8 mode = BPF_MODE(insn->code);\n\tstruct bpf_reg_state *reg;\n\tint i, err;\n\n\tif (!may_access_skb(env->prog->type)) {\n\t\tverbose(\"BPF_LD_[ABS|IND] instructions not allowed for this program type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (insn->dst_reg != BPF_REG_0 || insn->off != 0 ||\n\t    BPF_SIZE(insn->code) == BPF_DW ||\n\t    (mode == BPF_ABS && insn->src_reg != BPF_REG_0)) {\n\t\tverbose(\"BPF_LD_[ABS|IND] uses reserved fields\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* check whether implicit source operand (register R6) is readable */\n\terr = check_reg_arg(regs, BPF_REG_6, SRC_OP);\n\tif (err)\n\t\treturn err;\n\n\tif (regs[BPF_REG_6].type != PTR_TO_CTX) {\n\t\tverbose(\"at the time of BPF_LD_ABS|IND R6 != pointer to skb\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (mode == BPF_IND) {\n\t\t/* check explicit source operand */\n\t\terr = check_reg_arg(regs, insn->src_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t/* reset caller saved regs to unreadable */\n\tfor (i = 0; i < CALLER_SAVED_REGS; i++) {\n\t\treg = regs + caller_saved[i];\n\t\treg->type = NOT_INIT;\n\t\treg->imm = 0;\n\t}\n\n\t/* mark destination R0 register as readable, since it contains\n\t * the value fetched from the packet\n\t */\n\tregs[BPF_REG_0].type = UNKNOWN_VALUE;\n\treturn 0;\n}\n\n/* non-recursive DFS pseudo code\n * 1  procedure DFS-iterative(G,v):\n * 2      label v as discovered\n * 3      let S be a stack\n * 4      S.push(v)\n * 5      while S is not empty\n * 6            t <- S.pop()\n * 7            if t is what we're looking for:\n * 8                return t\n * 9            for all edges e in G.adjacentEdges(t) do\n * 10               if edge e is already labelled\n * 11                   continue with the next edge\n * 12               w <- G.adjacentVertex(t,e)\n * 13               if vertex w is not discovered and not explored\n * 14                   label e as tree-edge\n * 15                   label w as discovered\n * 16                   S.push(w)\n * 17                   continue at 5\n * 18               else if vertex w is discovered\n * 19                   label e as back-edge\n * 20               else\n * 21                   // vertex w is explored\n * 22                   label e as forward- or cross-edge\n * 23           label t as explored\n * 24           S.pop()\n *\n * convention:\n * 0x10 - discovered\n * 0x11 - discovered and fall-through edge labelled\n * 0x12 - discovered and fall-through and branch edges labelled\n * 0x20 - explored\n */\n\nenum {\n\tDISCOVERED = 0x10,\n\tEXPLORED = 0x20,\n\tFALLTHROUGH = 1,\n\tBRANCH = 2,\n};\n\n#define STATE_LIST_MARK ((struct bpf_verifier_state_list *) -1L)\n\nstatic int *insn_stack;\t/* stack of insns to process */\nstatic int cur_stack;\t/* current stack index */\nstatic int *insn_state;\n\n/* t, w, e - match pseudo-code above:\n * t - index of current instruction\n * w - next instruction\n * e - edge\n */\nstatic int push_insn(int t, int w, int e, struct bpf_verifier_env *env)\n{\n\tif (e == FALLTHROUGH && insn_state[t] >= (DISCOVERED | FALLTHROUGH))\n\t\treturn 0;\n\n\tif (e == BRANCH && insn_state[t] >= (DISCOVERED | BRANCH))\n\t\treturn 0;\n\n\tif (w < 0 || w >= env->prog->len) {\n\t\tverbose(\"jump out of range from insn %d to %d\\n\", t, w);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e == BRANCH)\n\t\t/* mark branch target for state pruning */\n\t\tenv->explored_states[w] = STATE_LIST_MARK;\n\n\tif (insn_state[w] == 0) {\n\t\t/* tree-edge */\n\t\tinsn_state[t] = DISCOVERED | e;\n\t\tinsn_state[w] = DISCOVERED;\n\t\tif (cur_stack >= env->prog->len)\n\t\t\treturn -E2BIG;\n\t\tinsn_stack[cur_stack++] = w;\n\t\treturn 1;\n\t} else if ((insn_state[w] & 0xF0) == DISCOVERED) {\n\t\tverbose(\"back-edge from insn %d to %d\\n\", t, w);\n\t\treturn -EINVAL;\n\t} else if (insn_state[w] == EXPLORED) {\n\t\t/* forward- or cross-edge */\n\t\tinsn_state[t] = DISCOVERED | e;\n\t} else {\n\t\tverbose(\"insn state internal bug\\n\");\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\n/* non-recursive depth-first-search to detect loops in BPF program\n * loop == back-edge in directed graph\n */\nstatic int check_cfg(struct bpf_verifier_env *env)\n{\n\tstruct bpf_insn *insns = env->prog->insnsi;\n\tint insn_cnt = env->prog->len;\n\tint ret = 0;\n\tint i, t;\n\n\tinsn_state = kcalloc(insn_cnt, sizeof(int), GFP_KERNEL);\n\tif (!insn_state)\n\t\treturn -ENOMEM;\n\n\tinsn_stack = kcalloc(insn_cnt, sizeof(int), GFP_KERNEL);\n\tif (!insn_stack) {\n\t\tkfree(insn_state);\n\t\treturn -ENOMEM;\n\t}\n\n\tinsn_state[0] = DISCOVERED; /* mark 1st insn as discovered */\n\tinsn_stack[0] = 0; /* 0 is the first instruction */\n\tcur_stack = 1;\n\npeek_stack:\n\tif (cur_stack == 0)\n\t\tgoto check_state;\n\tt = insn_stack[cur_stack - 1];\n\n\tif (BPF_CLASS(insns[t].code) == BPF_JMP) {\n\t\tu8 opcode = BPF_OP(insns[t].code);\n\n\t\tif (opcode == BPF_EXIT) {\n\t\t\tgoto mark_explored;\n\t\t} else if (opcode == BPF_CALL) {\n\t\t\tret = push_insn(t, t + 1, FALLTHROUGH, env);\n\t\t\tif (ret == 1)\n\t\t\t\tgoto peek_stack;\n\t\t\telse if (ret < 0)\n\t\t\t\tgoto err_free;\n\t\t\tif (t + 1 < insn_cnt)\n\t\t\t\tenv->explored_states[t + 1] = STATE_LIST_MARK;\n\t\t} else if (opcode == BPF_JA) {\n\t\t\tif (BPF_SRC(insns[t].code) != BPF_K) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err_free;\n\t\t\t}\n\t\t\t/* unconditional jump with single edge */\n\t\t\tret = push_insn(t, t + insns[t].off + 1,\n\t\t\t\t\tFALLTHROUGH, env);\n\t\t\tif (ret == 1)\n\t\t\t\tgoto peek_stack;\n\t\t\telse if (ret < 0)\n\t\t\t\tgoto err_free;\n\t\t\t/* tell verifier to check for equivalent states\n\t\t\t * after every call and jump\n\t\t\t */\n\t\t\tif (t + 1 < insn_cnt)\n\t\t\t\tenv->explored_states[t + 1] = STATE_LIST_MARK;\n\t\t} else {\n\t\t\t/* conditional jump with two edges */\n\t\t\tret = push_insn(t, t + 1, FALLTHROUGH, env);\n\t\t\tif (ret == 1)\n\t\t\t\tgoto peek_stack;\n\t\t\telse if (ret < 0)\n\t\t\t\tgoto err_free;\n\n\t\t\tret = push_insn(t, t + insns[t].off + 1, BRANCH, env);\n\t\t\tif (ret == 1)\n\t\t\t\tgoto peek_stack;\n\t\t\telse if (ret < 0)\n\t\t\t\tgoto err_free;\n\t\t}\n\t} else {\n\t\t/* all other non-branch instructions with single\n\t\t * fall-through edge\n\t\t */\n\t\tret = push_insn(t, t + 1, FALLTHROUGH, env);\n\t\tif (ret == 1)\n\t\t\tgoto peek_stack;\n\t\telse if (ret < 0)\n\t\t\tgoto err_free;\n\t}\n\nmark_explored:\n\tinsn_state[t] = EXPLORED;\n\tif (cur_stack-- <= 0) {\n\t\tverbose(\"pop stack internal bug\\n\");\n\t\tret = -EFAULT;\n\t\tgoto err_free;\n\t}\n\tgoto peek_stack;\n\ncheck_state:\n\tfor (i = 0; i < insn_cnt; i++) {\n\t\tif (insn_state[i] != EXPLORED) {\n\t\t\tverbose(\"unreachable insn %d\\n\", i);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_free;\n\t\t}\n\t}\n\tret = 0; /* cfg looks good */\n\nerr_free:\n\tkfree(insn_state);\n\tkfree(insn_stack);\n\treturn ret;\n}\n\n/* the following conditions reduce the number of explored insns\n * from ~140k to ~80k for ultra large programs that use a lot of ptr_to_packet\n */\nstatic bool compare_ptrs_to_packet(struct bpf_reg_state *old,\n\t\t\t\t   struct bpf_reg_state *cur)\n{\n\tif (old->id != cur->id)\n\t\treturn false;\n\n\t/* old ptr_to_packet is more conservative, since it allows smaller\n\t * range. Ex:\n\t * old(off=0,r=10) is equal to cur(off=0,r=20), because\n\t * old(off=0,r=10) means that with range=10 the verifier proceeded\n\t * further and found no issues with the program. Now we're in the same\n\t * spot with cur(off=0,r=20), so we're safe too, since anything further\n\t * will only be looking at most 10 bytes after this pointer.\n\t */\n\tif (old->off == cur->off && old->range < cur->range)\n\t\treturn true;\n\n\t/* old(off=20,r=10) is equal to cur(off=22,re=22 or 5 or 0)\n\t * since both cannot be used for packet access and safe(old)\n\t * pointer has smaller off that could be used for further\n\t * 'if (ptr > data_end)' check\n\t * Ex:\n\t * old(off=20,r=10) and cur(off=22,r=22) and cur(off=22,r=0) mean\n\t * that we cannot access the packet.\n\t * The safe range is:\n\t * [ptr, ptr + range - off)\n\t * so whenever off >=range, it means no safe bytes from this pointer.\n\t * When comparing old->off <= cur->off, it means that older code\n\t * went with smaller offset and that offset was later\n\t * used to figure out the safe range after 'if (ptr > data_end)' check\n\t * Say, 'old' state was explored like:\n\t * ... R3(off=0, r=0)\n\t * R4 = R3 + 20\n\t * ... now R4(off=20,r=0)  <-- here\n\t * if (R4 > data_end)\n\t * ... R4(off=20,r=20), R3(off=0,r=20) and R3 can be used to access.\n\t * ... the code further went all the way to bpf_exit.\n\t * Now the 'cur' state at the mark 'here' has R4(off=30,r=0).\n\t * old_R4(off=20,r=0) equal to cur_R4(off=30,r=0), since if the verifier\n\t * goes further, such cur_R4 will give larger safe packet range after\n\t * 'if (R4 > data_end)' and all further insn were already good with r=20,\n\t * so they will be good with r=30 and we can prune the search.\n\t */\n\tif (old->off <= cur->off &&\n\t    old->off >= old->range && cur->off >= cur->range)\n\t\treturn true;\n\n\treturn false;\n}\n\n/* compare two verifier states\n *\n * all states stored in state_list are known to be valid, since\n * verifier reached 'bpf_exit' instruction through them\n *\n * this function is called when verifier exploring different branches of\n * execution popped from the state stack. If it sees an old state that has\n * more strict register state and more strict stack state then this execution\n * branch doesn't need to be explored further, since verifier already\n * concluded that more strict state leads to valid finish.\n *\n * Therefore two states are equivalent if register state is more conservative\n * and explored stack state is more conservative than the current one.\n * Example:\n *       explored                   current\n * (slot1=INV slot2=MISC) == (slot1=MISC slot2=MISC)\n * (slot1=MISC slot2=MISC) != (slot1=INV slot2=MISC)\n *\n * In other words if current stack state (one being explored) has more\n * valid slots than old one that already passed validation, it means\n * the verifier can stop exploring and conclude that current state is valid too\n *\n * Similarly with registers. If explored state has register type as invalid\n * whereas register type in current state is meaningful, it means that\n * the current state will reach 'bpf_exit' instruction safely\n */\nstatic bool states_equal(struct bpf_verifier_env *env,\n\t\t\t struct bpf_verifier_state *old,\n\t\t\t struct bpf_verifier_state *cur)\n{\n\tbool varlen_map_access = env->varlen_map_value_access;\n\tstruct bpf_reg_state *rold, *rcur;\n\tint i;\n\n\tfor (i = 0; i < MAX_BPF_REG; i++) {\n\t\trold = &old->regs[i];\n\t\trcur = &cur->regs[i];\n\n\t\tif (memcmp(rold, rcur, sizeof(*rold)) == 0)\n\t\t\tcontinue;\n\n\t\t/* If the ranges were not the same, but everything else was and\n\t\t * we didn't do a variable access into a map then we are a-ok.\n\t\t */\n\t\tif (!varlen_map_access &&\n\t\t    memcmp(rold, rcur, offsetofend(struct bpf_reg_state, id)) == 0)\n\t\t\tcontinue;\n\n\t\t/* If we didn't map access then again we don't care about the\n\t\t * mismatched range values and it's ok if our old type was\n\t\t * UNKNOWN and we didn't go to a NOT_INIT'ed reg.\n\t\t */\n\t\tif (rold->type == NOT_INIT ||\n\t\t    (!varlen_map_access && rold->type == UNKNOWN_VALUE &&\n\t\t     rcur->type != NOT_INIT))\n\t\t\tcontinue;\n\n\t\tif (rold->type == PTR_TO_PACKET && rcur->type == PTR_TO_PACKET &&\n\t\t    compare_ptrs_to_packet(rold, rcur))\n\t\t\tcontinue;\n\n\t\treturn false;\n\t}\n\n\tfor (i = 0; i < MAX_BPF_STACK; i++) {\n\t\tif (old->stack_slot_type[i] == STACK_INVALID)\n\t\t\tcontinue;\n\t\tif (old->stack_slot_type[i] != cur->stack_slot_type[i])\n\t\t\t/* Ex: old explored (safe) state has STACK_SPILL in\n\t\t\t * this stack slot, but current has has STACK_MISC ->\n\t\t\t * this verifier states are not equivalent,\n\t\t\t * return false to continue verification of this path\n\t\t\t */\n\t\t\treturn false;\n\t\tif (i % BPF_REG_SIZE)\n\t\t\tcontinue;\n\t\tif (memcmp(&old->spilled_regs[i / BPF_REG_SIZE],\n\t\t\t   &cur->spilled_regs[i / BPF_REG_SIZE],\n\t\t\t   sizeof(old->spilled_regs[0])))\n\t\t\t/* when explored and current stack slot types are\n\t\t\t * the same, check that stored pointers types\n\t\t\t * are the same as well.\n\t\t\t * Ex: explored safe path could have stored\n\t\t\t * (bpf_reg_state) {.type = PTR_TO_STACK, .imm = -8}\n\t\t\t * but current path has stored:\n\t\t\t * (bpf_reg_state) {.type = PTR_TO_STACK, .imm = -16}\n\t\t\t * such verifier states are not equivalent.\n\t\t\t * return false to continue verification of this path\n\t\t\t */\n\t\t\treturn false;\n\t\telse\n\t\t\tcontinue;\n\t}\n\treturn true;\n}\n\nstatic int is_state_visited(struct bpf_verifier_env *env, int insn_idx)\n{\n\tstruct bpf_verifier_state_list *new_sl;\n\tstruct bpf_verifier_state_list *sl;\n\n\tsl = env->explored_states[insn_idx];\n\tif (!sl)\n\t\t/* this 'insn_idx' instruction wasn't marked, so we will not\n\t\t * be doing state search here\n\t\t */\n\t\treturn 0;\n\n\twhile (sl != STATE_LIST_MARK) {\n\t\tif (states_equal(env, &sl->state, &env->cur_state))\n\t\t\t/* reached equivalent register/stack state,\n\t\t\t * prune the search\n\t\t\t */\n\t\t\treturn 1;\n\t\tsl = sl->next;\n\t}\n\n\t/* there were no equivalent states, remember current one.\n\t * technically the current state is not proven to be safe yet,\n\t * but it will either reach bpf_exit (which means it's safe) or\n\t * it will be rejected. Since there are no loops, we won't be\n\t * seeing this 'insn_idx' instruction again on the way to bpf_exit\n\t */\n\tnew_sl = kmalloc(sizeof(struct bpf_verifier_state_list), GFP_USER);\n\tif (!new_sl)\n\t\treturn -ENOMEM;\n\n\t/* add new state to the head of linked list */\n\tmemcpy(&new_sl->state, &env->cur_state, sizeof(env->cur_state));\n\tnew_sl->next = env->explored_states[insn_idx];\n\tenv->explored_states[insn_idx] = new_sl;\n\treturn 0;\n}\n\nstatic int ext_analyzer_insn_hook(struct bpf_verifier_env *env,\n\t\t\t\t  int insn_idx, int prev_insn_idx)\n{\n\tif (!env->analyzer_ops || !env->analyzer_ops->insn_hook)\n\t\treturn 0;\n\n\treturn env->analyzer_ops->insn_hook(env, insn_idx, prev_insn_idx);\n}\n\nstatic int do_check(struct bpf_verifier_env *env)\n{\n\tstruct bpf_verifier_state *state = &env->cur_state;\n\tstruct bpf_insn *insns = env->prog->insnsi;\n\tstruct bpf_reg_state *regs = state->regs;\n\tint insn_cnt = env->prog->len;\n\tint insn_idx, prev_insn_idx = 0;\n\tint insn_processed = 0;\n\tbool do_print_state = false;\n\n\tinit_reg_state(regs);\n\tinsn_idx = 0;\n\tenv->varlen_map_value_access = false;\n\tfor (;;) {\n\t\tstruct bpf_insn *insn;\n\t\tu8 class;\n\t\tint err;\n\n\t\tif (insn_idx >= insn_cnt) {\n\t\t\tverbose(\"invalid insn idx %d insn_cnt %d\\n\",\n\t\t\t\tinsn_idx, insn_cnt);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tinsn = &insns[insn_idx];\n\t\tclass = BPF_CLASS(insn->code);\n\n\t\tif (++insn_processed > BPF_COMPLEXITY_LIMIT_INSNS) {\n\t\t\tverbose(\"BPF program is too large. Processed %d insn\\n\",\n\t\t\t\tinsn_processed);\n\t\t\treturn -E2BIG;\n\t\t}\n\n\t\terr = is_state_visited(env, insn_idx);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (err == 1) {\n\t\t\t/* found equivalent state, can prune the search */\n\t\t\tif (log_level) {\n\t\t\t\tif (do_print_state)\n\t\t\t\t\tverbose(\"\\nfrom %d to %d: safe\\n\",\n\t\t\t\t\t\tprev_insn_idx, insn_idx);\n\t\t\t\telse\n\t\t\t\t\tverbose(\"%d: safe\\n\", insn_idx);\n\t\t\t}\n\t\t\tgoto process_bpf_exit;\n\t\t}\n\n\t\tif (log_level && do_print_state) {\n\t\t\tverbose(\"\\nfrom %d to %d:\", prev_insn_idx, insn_idx);\n\t\t\tprint_verifier_state(&env->cur_state);\n\t\t\tdo_print_state = false;\n\t\t}\n\n\t\tif (log_level) {\n\t\t\tverbose(\"%d: \", insn_idx);\n\t\t\tprint_bpf_insn(insn);\n\t\t}\n\n\t\terr = ext_analyzer_insn_hook(env, insn_idx, prev_insn_idx);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (class == BPF_ALU || class == BPF_ALU64) {\n\t\t\terr = check_alu_op(env, insn);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t} else if (class == BPF_LDX) {\n\t\t\tenum bpf_reg_type *prev_src_type, src_reg_type;\n\n\t\t\t/* check for reserved fields is already done */\n\n\t\t\t/* check src operand */\n\t\t\terr = check_reg_arg(regs, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\terr = check_reg_arg(regs, insn->dst_reg, DST_OP_NO_MARK);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tsrc_reg_type = regs[insn->src_reg].type;\n\n\t\t\t/* check that memory (src_reg + off) is readable,\n\t\t\t * the state of dst_reg will be updated by this func\n\t\t\t */\n\t\t\terr = check_mem_access(env, insn->src_reg, insn->off,\n\t\t\t\t\t       BPF_SIZE(insn->code), BPF_READ,\n\t\t\t\t\t       insn->dst_reg);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tif (BPF_SIZE(insn->code) != BPF_W &&\n\t\t\t    BPF_SIZE(insn->code) != BPF_DW) {\n\t\t\t\tinsn_idx++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tprev_src_type = &env->insn_aux_data[insn_idx].ptr_type;\n\n\t\t\tif (*prev_src_type == NOT_INIT) {\n\t\t\t\t/* saw a valid insn\n\t\t\t\t * dst_reg = *(u32 *)(src_reg + off)\n\t\t\t\t * save type to validate intersecting paths\n\t\t\t\t */\n\t\t\t\t*prev_src_type = src_reg_type;\n\n\t\t\t} else if (src_reg_type != *prev_src_type &&\n\t\t\t\t   (src_reg_type == PTR_TO_CTX ||\n\t\t\t\t    *prev_src_type == PTR_TO_CTX)) {\n\t\t\t\t/* ABuser program is trying to use the same insn\n\t\t\t\t * dst_reg = *(u32*) (src_reg + off)\n\t\t\t\t * with different pointer types:\n\t\t\t\t * src_reg == ctx in one branch and\n\t\t\t\t * src_reg == stack|map in some other branch.\n\t\t\t\t * Reject it.\n\t\t\t\t */\n\t\t\t\tverbose(\"same insn cannot be used with different pointers\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t} else if (class == BPF_STX) {\n\t\t\tenum bpf_reg_type *prev_dst_type, dst_reg_type;\n\n\t\t\tif (BPF_MODE(insn->code) == BPF_XADD) {\n\t\t\t\terr = check_xadd(env, insn);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tinsn_idx++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* check src1 operand */\n\t\t\terr = check_reg_arg(regs, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\t/* check src2 operand */\n\t\t\terr = check_reg_arg(regs, insn->dst_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tdst_reg_type = regs[insn->dst_reg].type;\n\n\t\t\t/* check that memory (dst_reg + off) is writeable */\n\t\t\terr = check_mem_access(env, insn->dst_reg, insn->off,\n\t\t\t\t\t       BPF_SIZE(insn->code), BPF_WRITE,\n\t\t\t\t\t       insn->src_reg);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tprev_dst_type = &env->insn_aux_data[insn_idx].ptr_type;\n\n\t\t\tif (*prev_dst_type == NOT_INIT) {\n\t\t\t\t*prev_dst_type = dst_reg_type;\n\t\t\t} else if (dst_reg_type != *prev_dst_type &&\n\t\t\t\t   (dst_reg_type == PTR_TO_CTX ||\n\t\t\t\t    *prev_dst_type == PTR_TO_CTX)) {\n\t\t\t\tverbose(\"same insn cannot be used with different pointers\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t} else if (class == BPF_ST) {\n\t\t\tif (BPF_MODE(insn->code) != BPF_MEM ||\n\t\t\t    insn->src_reg != BPF_REG_0) {\n\t\t\t\tverbose(\"BPF_ST uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t/* check src operand */\n\t\t\terr = check_reg_arg(regs, insn->dst_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\t/* check that memory (dst_reg + off) is writeable */\n\t\t\terr = check_mem_access(env, insn->dst_reg, insn->off,\n\t\t\t\t\t       BPF_SIZE(insn->code), BPF_WRITE,\n\t\t\t\t\t       -1);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t} else if (class == BPF_JMP) {\n\t\t\tu8 opcode = BPF_OP(insn->code);\n\n\t\t\tif (opcode == BPF_CALL) {\n\t\t\t\tif (BPF_SRC(insn->code) != BPF_K ||\n\t\t\t\t    insn->off != 0 ||\n\t\t\t\t    insn->src_reg != BPF_REG_0 ||\n\t\t\t\t    insn->dst_reg != BPF_REG_0) {\n\t\t\t\t\tverbose(\"BPF_CALL uses reserved fields\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\terr = check_call(env, insn->imm, insn_idx);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t} else if (opcode == BPF_JA) {\n\t\t\t\tif (BPF_SRC(insn->code) != BPF_K ||\n\t\t\t\t    insn->imm != 0 ||\n\t\t\t\t    insn->src_reg != BPF_REG_0 ||\n\t\t\t\t    insn->dst_reg != BPF_REG_0) {\n\t\t\t\t\tverbose(\"BPF_JA uses reserved fields\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tinsn_idx += insn->off + 1;\n\t\t\t\tcontinue;\n\n\t\t\t} else if (opcode == BPF_EXIT) {\n\t\t\t\tif (BPF_SRC(insn->code) != BPF_K ||\n\t\t\t\t    insn->imm != 0 ||\n\t\t\t\t    insn->src_reg != BPF_REG_0 ||\n\t\t\t\t    insn->dst_reg != BPF_REG_0) {\n\t\t\t\t\tverbose(\"BPF_EXIT uses reserved fields\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\t/* eBPF calling convetion is such that R0 is used\n\t\t\t\t * to return the value from eBPF program.\n\t\t\t\t * Make sure that it's readable at this time\n\t\t\t\t * of bpf_exit, which means that program wrote\n\t\t\t\t * something into it earlier\n\t\t\t\t */\n\t\t\t\terr = check_reg_arg(regs, BPF_REG_0, SRC_OP);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\tif (is_pointer_value(env, BPF_REG_0)) {\n\t\t\t\t\tverbose(\"R0 leaks addr as return value\\n\");\n\t\t\t\t\treturn -EACCES;\n\t\t\t\t}\n\nprocess_bpf_exit:\n\t\t\t\tinsn_idx = pop_stack(env, &prev_insn_idx);\n\t\t\t\tif (insn_idx < 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tdo_print_state = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terr = check_cond_jmp_op(env, insn, &insn_idx);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t} else if (class == BPF_LD) {\n\t\t\tu8 mode = BPF_MODE(insn->code);\n\n\t\t\tif (mode == BPF_ABS || mode == BPF_IND) {\n\t\t\t\terr = check_ld_abs(env, insn);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t} else if (mode == BPF_IMM) {\n\t\t\t\terr = check_ld_imm(env, insn);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\tinsn_idx++;\n\t\t\t} else {\n\t\t\t\tverbose(\"invalid BPF_LD mode\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\treset_reg_range_values(regs, insn->dst_reg);\n\t\t} else {\n\t\t\tverbose(\"unknown insn class %d\\n\", class);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tinsn_idx++;\n\t}\n\n\tverbose(\"processed %d insns\\n\", insn_processed);\n\treturn 0;\n}\n\nstatic int check_map_prealloc(struct bpf_map *map)\n{\n\treturn (map->map_type != BPF_MAP_TYPE_HASH &&\n\t\tmap->map_type != BPF_MAP_TYPE_PERCPU_HASH &&\n\t\tmap->map_type != BPF_MAP_TYPE_HASH_OF_MAPS) ||\n\t\t!(map->map_flags & BPF_F_NO_PREALLOC);\n}\n\nstatic int check_map_prog_compatibility(struct bpf_map *map,\n\t\t\t\t\tstruct bpf_prog *prog)\n\n{\n\t/* Make sure that BPF_PROG_TYPE_PERF_EVENT programs only use\n\t * preallocated hash maps, since doing memory allocation\n\t * in overflow_handler can crash depending on where nmi got\n\t * triggered.\n\t */\n\tif (prog->type == BPF_PROG_TYPE_PERF_EVENT) {\n\t\tif (!check_map_prealloc(map)) {\n\t\t\tverbose(\"perf_event programs can only use preallocated hash map\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (map->inner_map_meta &&\n\t\t    !check_map_prealloc(map->inner_map_meta)) {\n\t\t\tverbose(\"perf_event programs can only use preallocated inner hash map\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/* look for pseudo eBPF instructions that access map FDs and\n * replace them with actual map pointers\n */\nstatic int replace_map_fd_with_map_ptr(struct bpf_verifier_env *env)\n{\n\tstruct bpf_insn *insn = env->prog->insnsi;\n\tint insn_cnt = env->prog->len;\n\tint i, j, err;\n\n\terr = bpf_prog_calc_tag(env->prog);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (BPF_CLASS(insn->code) == BPF_LDX &&\n\t\t    (BPF_MODE(insn->code) != BPF_MEM || insn->imm != 0)) {\n\t\t\tverbose(\"BPF_LDX uses reserved fields\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (BPF_CLASS(insn->code) == BPF_STX &&\n\t\t    ((BPF_MODE(insn->code) != BPF_MEM &&\n\t\t      BPF_MODE(insn->code) != BPF_XADD) || insn->imm != 0)) {\n\t\t\tverbose(\"BPF_STX uses reserved fields\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (insn[0].code == (BPF_LD | BPF_IMM | BPF_DW)) {\n\t\t\tstruct bpf_map *map;\n\t\t\tstruct fd f;\n\n\t\t\tif (i == insn_cnt - 1 || insn[1].code != 0 ||\n\t\t\t    insn[1].dst_reg != 0 || insn[1].src_reg != 0 ||\n\t\t\t    insn[1].off != 0) {\n\t\t\t\tverbose(\"invalid bpf_ld_imm64 insn\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (insn->src_reg == 0)\n\t\t\t\t/* valid generic load 64-bit imm */\n\t\t\t\tgoto next_insn;\n\n\t\t\tif (insn->src_reg != BPF_PSEUDO_MAP_FD) {\n\t\t\t\tverbose(\"unrecognized bpf_ld_imm64 insn\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tf = fdget(insn->imm);\n\t\t\tmap = __bpf_map_get(f);\n\t\t\tif (IS_ERR(map)) {\n\t\t\t\tverbose(\"fd %d is not pointing to valid bpf_map\\n\",\n\t\t\t\t\tinsn->imm);\n\t\t\t\treturn PTR_ERR(map);\n\t\t\t}\n\n\t\t\terr = check_map_prog_compatibility(map, env->prog);\n\t\t\tif (err) {\n\t\t\t\tfdput(f);\n\t\t\t\treturn err;\n\t\t\t}\n\n\t\t\t/* store map pointer inside BPF_LD_IMM64 instruction */\n\t\t\tinsn[0].imm = (u32) (unsigned long) map;\n\t\t\tinsn[1].imm = ((u64) (unsigned long) map) >> 32;\n\n\t\t\t/* check whether we recorded this map already */\n\t\t\tfor (j = 0; j < env->used_map_cnt; j++)\n\t\t\t\tif (env->used_maps[j] == map) {\n\t\t\t\t\tfdput(f);\n\t\t\t\t\tgoto next_insn;\n\t\t\t\t}\n\n\t\t\tif (env->used_map_cnt >= MAX_USED_MAPS) {\n\t\t\t\tfdput(f);\n\t\t\t\treturn -E2BIG;\n\t\t\t}\n\n\t\t\t/* hold the map. If the program is rejected by verifier,\n\t\t\t * the map will be released by release_maps() or it\n\t\t\t * will be used by the valid program until it's unloaded\n\t\t\t * and all maps are released in free_bpf_prog_info()\n\t\t\t */\n\t\t\tmap = bpf_map_inc(map, false);\n\t\t\tif (IS_ERR(map)) {\n\t\t\t\tfdput(f);\n\t\t\t\treturn PTR_ERR(map);\n\t\t\t}\n\t\t\tenv->used_maps[env->used_map_cnt++] = map;\n\n\t\t\tfdput(f);\nnext_insn:\n\t\t\tinsn++;\n\t\t\ti++;\n\t\t}\n\t}\n\n\t/* now all pseudo BPF_LD_IMM64 instructions load valid\n\t * 'struct bpf_map *' into a register instead of user map_fd.\n\t * These pointers will be used later by verifier to validate map access.\n\t */\n\treturn 0;\n}\n\n/* drop refcnt of maps used by the rejected program */\nstatic void release_maps(struct bpf_verifier_env *env)\n{\n\tint i;\n\n\tfor (i = 0; i < env->used_map_cnt; i++)\n\t\tbpf_map_put(env->used_maps[i]);\n}\n\n/* convert pseudo BPF_LD_IMM64 into generic BPF_LD_IMM64 */\nstatic void convert_pseudo_ld_imm64(struct bpf_verifier_env *env)\n{\n\tstruct bpf_insn *insn = env->prog->insnsi;\n\tint insn_cnt = env->prog->len;\n\tint i;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++)\n\t\tif (insn->code == (BPF_LD | BPF_IMM | BPF_DW))\n\t\t\tinsn->src_reg = 0;\n}\n\n/* single env->prog->insni[off] instruction was replaced with the range\n * insni[off, off + cnt).  Adjust corresponding insn_aux_data by copying\n * [0, off) and [off, end) to new locations, so the patched range stays zero\n */\nstatic int adjust_insn_aux_data(struct bpf_verifier_env *env, u32 prog_len,\n\t\t\t\tu32 off, u32 cnt)\n{\n\tstruct bpf_insn_aux_data *new_data, *old_data = env->insn_aux_data;\n\n\tif (cnt == 1)\n\t\treturn 0;\n\tnew_data = vzalloc(sizeof(struct bpf_insn_aux_data) * prog_len);\n\tif (!new_data)\n\t\treturn -ENOMEM;\n\tmemcpy(new_data, old_data, sizeof(struct bpf_insn_aux_data) * off);\n\tmemcpy(new_data + off + cnt - 1, old_data + off,\n\t       sizeof(struct bpf_insn_aux_data) * (prog_len - off - cnt + 1));\n\tenv->insn_aux_data = new_data;\n\tvfree(old_data);\n\treturn 0;\n}\n\nstatic struct bpf_prog *bpf_patch_insn_data(struct bpf_verifier_env *env, u32 off,\n\t\t\t\t\t    const struct bpf_insn *patch, u32 len)\n{\n\tstruct bpf_prog *new_prog;\n\n\tnew_prog = bpf_patch_insn_single(env->prog, off, patch, len);\n\tif (!new_prog)\n\t\treturn NULL;\n\tif (adjust_insn_aux_data(env, new_prog->len, off, len))\n\t\treturn NULL;\n\treturn new_prog;\n}\n\n/* convert load instructions that access fields of 'struct __sk_buff'\n * into sequence of instructions that access fields of 'struct sk_buff'\n */\nstatic int convert_ctx_accesses(struct bpf_verifier_env *env)\n{\n\tconst struct bpf_verifier_ops *ops = env->prog->aux->ops;\n\tconst int insn_cnt = env->prog->len;\n\tstruct bpf_insn insn_buf[16], *insn;\n\tstruct bpf_prog *new_prog;\n\tenum bpf_access_type type;\n\tint i, cnt, delta = 0;\n\n\tif (ops->gen_prologue) {\n\t\tcnt = ops->gen_prologue(insn_buf, env->seen_direct_write,\n\t\t\t\t\tenv->prog);\n\t\tif (cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\tverbose(\"bpf verifier is misconfigured\\n\");\n\t\t\treturn -EINVAL;\n\t\t} else if (cnt) {\n\t\t\tnew_prog = bpf_patch_insn_data(env, 0, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tenv->prog = new_prog;\n\t\t\tdelta += cnt - 1;\n\t\t}\n\t}\n\n\tif (!ops->convert_ctx_access)\n\t\treturn 0;\n\n\tinsn = env->prog->insnsi + delta;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (insn->code == (BPF_LDX | BPF_MEM | BPF_B) ||\n\t\t    insn->code == (BPF_LDX | BPF_MEM | BPF_H) ||\n\t\t    insn->code == (BPF_LDX | BPF_MEM | BPF_W) ||\n\t\t    insn->code == (BPF_LDX | BPF_MEM | BPF_DW))\n\t\t\ttype = BPF_READ;\n\t\telse if (insn->code == (BPF_STX | BPF_MEM | BPF_B) ||\n\t\t\t insn->code == (BPF_STX | BPF_MEM | BPF_H) ||\n\t\t\t insn->code == (BPF_STX | BPF_MEM | BPF_W) ||\n\t\t\t insn->code == (BPF_STX | BPF_MEM | BPF_DW))\n\t\t\ttype = BPF_WRITE;\n\t\telse\n\t\t\tcontinue;\n\n\t\tif (env->insn_aux_data[i + delta].ptr_type != PTR_TO_CTX)\n\t\t\tcontinue;\n\n\t\tcnt = ops->convert_ctx_access(type, insn, insn_buf, env->prog);\n\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\tverbose(\"bpf verifier is misconfigured\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\tif (!new_prog)\n\t\t\treturn -ENOMEM;\n\n\t\tdelta += cnt - 1;\n\n\t\t/* keep walking new program and skip insns we just inserted */\n\t\tenv->prog = new_prog;\n\t\tinsn      = new_prog->insnsi + i + delta;\n\t}\n\n\treturn 0;\n}\n\n/* fixup insn->imm field of bpf_call instructions\n * and inline eligible helpers as explicit sequence of BPF instructions\n *\n * this function is called after eBPF program passed verification\n */\nstatic int fixup_bpf_calls(struct bpf_verifier_env *env)\n{\n\tstruct bpf_prog *prog = env->prog;\n\tstruct bpf_insn *insn = prog->insnsi;\n\tconst struct bpf_func_proto *fn;\n\tconst int insn_cnt = prog->len;\n\tstruct bpf_insn insn_buf[16];\n\tstruct bpf_prog *new_prog;\n\tstruct bpf_map *map_ptr;\n\tint i, cnt, delta = 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (insn->code != (BPF_JMP | BPF_CALL))\n\t\t\tcontinue;\n\n\t\tif (insn->imm == BPF_FUNC_get_route_realm)\n\t\t\tprog->dst_needed = 1;\n\t\tif (insn->imm == BPF_FUNC_get_prandom_u32)\n\t\t\tbpf_user_rnd_init_once();\n\t\tif (insn->imm == BPF_FUNC_tail_call) {\n\t\t\t/* If we tail call into other programs, we\n\t\t\t * cannot make any assumptions since they can\n\t\t\t * be replaced dynamically during runtime in\n\t\t\t * the program array.\n\t\t\t */\n\t\t\tprog->cb_access = 1;\n\n\t\t\t/* mark bpf_tail_call as different opcode to avoid\n\t\t\t * conditional branch in the interpeter for every normal\n\t\t\t * call and to prevent accidental JITing by JIT compiler\n\t\t\t * that doesn't support bpf_tail_call yet\n\t\t\t */\n\t\t\tinsn->imm = 0;\n\t\t\tinsn->code |= BPF_X;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ebpf_jit_enabled() && insn->imm == BPF_FUNC_map_lookup_elem) {\n\t\t\tmap_ptr = env->insn_aux_data[i + delta].map_ptr;\n\t\t\tif (map_ptr == BPF_MAP_PTR_POISON ||\n\t\t\t    !map_ptr->ops->map_gen_lookup)\n\t\t\t\tgoto patch_call_imm;\n\n\t\t\tcnt = map_ptr->ops->map_gen_lookup(map_ptr, insn_buf);\n\t\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\tverbose(\"bpf verifier is misconfigured\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf,\n\t\t\t\t\t\t       cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta += cnt - 1;\n\n\t\t\t/* keep walking new program and skip insns we just inserted */\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\npatch_call_imm:\n\t\tfn = prog->aux->ops->get_func_proto(insn->imm);\n\t\t/* all functions that have prototype and verifier allowed\n\t\t * programs to call them, must be real in-kernel functions\n\t\t */\n\t\tif (!fn->func) {\n\t\t\tverbose(\"kernel subsystem misconfigured func %s#%d\\n\",\n\t\t\t\tfunc_id_name(insn->imm), insn->imm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tinsn->imm = fn->func - __bpf_call_base;\n\t}\n\n\treturn 0;\n}\n\nstatic void free_states(struct bpf_verifier_env *env)\n{\n\tstruct bpf_verifier_state_list *sl, *sln;\n\tint i;\n\n\tif (!env->explored_states)\n\t\treturn;\n\n\tfor (i = 0; i < env->prog->len; i++) {\n\t\tsl = env->explored_states[i];\n\n\t\tif (sl)\n\t\t\twhile (sl != STATE_LIST_MARK) {\n\t\t\t\tsln = sl->next;\n\t\t\t\tkfree(sl);\n\t\t\t\tsl = sln;\n\t\t\t}\n\t}\n\n\tkfree(env->explored_states);\n}\n\nint bpf_check(struct bpf_prog **prog, union bpf_attr *attr)\n{\n\tchar __user *log_ubuf = NULL;\n\tstruct bpf_verifier_env *env;\n\tint ret = -EINVAL;\n\n\t/* 'struct bpf_verifier_env' can be global, but since it's not small,\n\t * allocate/free it every time bpf_check() is called\n\t */\n\tenv = kzalloc(sizeof(struct bpf_verifier_env), GFP_KERNEL);\n\tif (!env)\n\t\treturn -ENOMEM;\n\n\tenv->insn_aux_data = vzalloc(sizeof(struct bpf_insn_aux_data) *\n\t\t\t\t     (*prog)->len);\n\tret = -ENOMEM;\n\tif (!env->insn_aux_data)\n\t\tgoto err_free_env;\n\tenv->prog = *prog;\n\n\t/* grab the mutex to protect few globals used by verifier */\n\tmutex_lock(&bpf_verifier_lock);\n\n\tif (attr->log_level || attr->log_buf || attr->log_size) {\n\t\t/* user requested verbose verifier output\n\t\t * and supplied buffer to store the verification trace\n\t\t */\n\t\tlog_level = attr->log_level;\n\t\tlog_ubuf = (char __user *) (unsigned long) attr->log_buf;\n\t\tlog_size = attr->log_size;\n\t\tlog_len = 0;\n\n\t\tret = -EINVAL;\n\t\t/* log_* values have to be sane */\n\t\tif (log_size < 128 || log_size > UINT_MAX >> 8 ||\n\t\t    log_level == 0 || log_ubuf == NULL)\n\t\t\tgoto err_unlock;\n\n\t\tret = -ENOMEM;\n\t\tlog_buf = vmalloc(log_size);\n\t\tif (!log_buf)\n\t\t\tgoto err_unlock;\n\t} else {\n\t\tlog_level = 0;\n\t}\n\n\tret = replace_map_fd_with_map_ptr(env);\n\tif (ret < 0)\n\t\tgoto skip_full_check;\n\n\tenv->explored_states = kcalloc(env->prog->len,\n\t\t\t\t       sizeof(struct bpf_verifier_state_list *),\n\t\t\t\t       GFP_USER);\n\tret = -ENOMEM;\n\tif (!env->explored_states)\n\t\tgoto skip_full_check;\n\n\tret = check_cfg(env);\n\tif (ret < 0)\n\t\tgoto skip_full_check;\n\n\tenv->allow_ptr_leaks = capable(CAP_SYS_ADMIN);\n\n\tret = do_check(env);\n\nskip_full_check:\n\twhile (pop_stack(env, NULL) >= 0);\n\tfree_states(env);\n\n\tif (ret == 0)\n\t\t/* program is valid, convert *(u32*)(ctx + off) accesses */\n\t\tret = convert_ctx_accesses(env);\n\n\tif (ret == 0)\n\t\tret = fixup_bpf_calls(env);\n\n\tif (log_level && log_len >= log_size - 1) {\n\t\tBUG_ON(log_len >= log_size);\n\t\t/* verifier log exceeded user supplied buffer */\n\t\tret = -ENOSPC;\n\t\t/* fall through to return what was recorded */\n\t}\n\n\t/* copy verifier log back to user space including trailing zero */\n\tif (log_level && copy_to_user(log_ubuf, log_buf, log_len + 1) != 0) {\n\t\tret = -EFAULT;\n\t\tgoto free_log_buf;\n\t}\n\n\tif (ret == 0 && env->used_map_cnt) {\n\t\t/* if program passed verifier, update used_maps in bpf_prog_info */\n\t\tenv->prog->aux->used_maps = kmalloc_array(env->used_map_cnt,\n\t\t\t\t\t\t\t  sizeof(env->used_maps[0]),\n\t\t\t\t\t\t\t  GFP_KERNEL);\n\n\t\tif (!env->prog->aux->used_maps) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_log_buf;\n\t\t}\n\n\t\tmemcpy(env->prog->aux->used_maps, env->used_maps,\n\t\t       sizeof(env->used_maps[0]) * env->used_map_cnt);\n\t\tenv->prog->aux->used_map_cnt = env->used_map_cnt;\n\n\t\t/* program is valid. Convert pseudo bpf_ld_imm64 into generic\n\t\t * bpf_ld_imm64 instructions\n\t\t */\n\t\tconvert_pseudo_ld_imm64(env);\n\t}\n\nfree_log_buf:\n\tif (log_level)\n\t\tvfree(log_buf);\n\tif (!env->prog->aux->used_maps)\n\t\t/* if we didn't copy map pointers into bpf_prog_info, release\n\t\t * them now. Otherwise free_bpf_prog_info() will release them.\n\t\t */\n\t\trelease_maps(env);\n\t*prog = env->prog;\nerr_unlock:\n\tmutex_unlock(&bpf_verifier_lock);\n\tvfree(env->insn_aux_data);\nerr_free_env:\n\tkfree(env);\n\treturn ret;\n}\n\nint bpf_analyzer(struct bpf_prog *prog, const struct bpf_ext_analyzer_ops *ops,\n\t\t void *priv)\n{\n\tstruct bpf_verifier_env *env;\n\tint ret;\n\n\tenv = kzalloc(sizeof(struct bpf_verifier_env), GFP_KERNEL);\n\tif (!env)\n\t\treturn -ENOMEM;\n\n\tenv->insn_aux_data = vzalloc(sizeof(struct bpf_insn_aux_data) *\n\t\t\t\t     prog->len);\n\tret = -ENOMEM;\n\tif (!env->insn_aux_data)\n\t\tgoto err_free_env;\n\tenv->prog = prog;\n\tenv->analyzer_ops = ops;\n\tenv->analyzer_priv = priv;\n\n\t/* grab the mutex to protect few globals used by verifier */\n\tmutex_lock(&bpf_verifier_lock);\n\n\tlog_level = 0;\n\n\tenv->explored_states = kcalloc(env->prog->len,\n\t\t\t\t       sizeof(struct bpf_verifier_state_list *),\n\t\t\t\t       GFP_KERNEL);\n\tret = -ENOMEM;\n\tif (!env->explored_states)\n\t\tgoto skip_full_check;\n\n\tret = check_cfg(env);\n\tif (ret < 0)\n\t\tgoto skip_full_check;\n\n\tenv->allow_ptr_leaks = capable(CAP_SYS_ADMIN);\n\n\tret = do_check(env);\n\nskip_full_check:\n\twhile (pop_stack(env, NULL) >= 0);\n\tfree_states(env);\n\n\tmutex_unlock(&bpf_verifier_lock);\n\tvfree(env->insn_aux_data);\nerr_free_env:\n\tkfree(env);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(bpf_analyzer);\n"], "fixing_code": ["/* Copyright (c) 2011-2014 PLUMgrid, http://plumgrid.com\n * Copyright (c) 2016 Facebook\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of version 2 of the GNU General Public\n * License as published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * General Public License for more details.\n */\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/bpf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/filter.h>\n#include <net/netlink.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/stringify.h>\n\n/* bpf_check() is a static code analyzer that walks eBPF program\n * instruction by instruction and updates register/stack state.\n * All paths of conditional branches are analyzed until 'bpf_exit' insn.\n *\n * The first pass is depth-first-search to check that the program is a DAG.\n * It rejects the following programs:\n * - larger than BPF_MAXINSNS insns\n * - if loop is present (detected via back-edge)\n * - unreachable insns exist (shouldn't be a forest. program = one function)\n * - out of bounds or malformed jumps\n * The second pass is all possible path descent from the 1st insn.\n * Since it's analyzing all pathes through the program, the length of the\n * analysis is limited to 64k insn, which may be hit even if total number of\n * insn is less then 4K, but there are too many branches that change stack/regs.\n * Number of 'branches to be analyzed' is limited to 1k\n *\n * On entry to each instruction, each register has a type, and the instruction\n * changes the types of the registers depending on instruction semantics.\n * If instruction is BPF_MOV64_REG(BPF_REG_1, BPF_REG_5), then type of R5 is\n * copied to R1.\n *\n * All registers are 64-bit.\n * R0 - return register\n * R1-R5 argument passing registers\n * R6-R9 callee saved registers\n * R10 - frame pointer read-only\n *\n * At the start of BPF program the register R1 contains a pointer to bpf_context\n * and has type PTR_TO_CTX.\n *\n * Verifier tracks arithmetic operations on pointers in case:\n *    BPF_MOV64_REG(BPF_REG_1, BPF_REG_10),\n *    BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, -20),\n * 1st insn copies R10 (which has FRAME_PTR) type into R1\n * and 2nd arithmetic instruction is pattern matched to recognize\n * that it wants to construct a pointer to some element within stack.\n * So after 2nd insn, the register R1 has type PTR_TO_STACK\n * (and -20 constant is saved for further stack bounds checking).\n * Meaning that this reg is a pointer to stack plus known immediate constant.\n *\n * Most of the time the registers have UNKNOWN_VALUE type, which\n * means the register has some value, but it's not a valid pointer.\n * (like pointer plus pointer becomes UNKNOWN_VALUE type)\n *\n * When verifier sees load or store instructions the type of base register\n * can be: PTR_TO_MAP_VALUE, PTR_TO_CTX, FRAME_PTR. These are three pointer\n * types recognized by check_mem_access() function.\n *\n * PTR_TO_MAP_VALUE means that this register is pointing to 'map element value'\n * and the range of [ptr, ptr + map's value_size) is accessible.\n *\n * registers used to pass values to function calls are checked against\n * function argument constraints.\n *\n * ARG_PTR_TO_MAP_KEY is one of such argument constraints.\n * It means that the register type passed to this function must be\n * PTR_TO_STACK and it will be used inside the function as\n * 'pointer to map element key'\n *\n * For example the argument constraints for bpf_map_lookup_elem():\n *   .ret_type = RET_PTR_TO_MAP_VALUE_OR_NULL,\n *   .arg1_type = ARG_CONST_MAP_PTR,\n *   .arg2_type = ARG_PTR_TO_MAP_KEY,\n *\n * ret_type says that this function returns 'pointer to map elem value or null'\n * function expects 1st argument to be a const pointer to 'struct bpf_map' and\n * 2nd argument should be a pointer to stack, which will be used inside\n * the helper function as a pointer to map element key.\n *\n * On the kernel side the helper function looks like:\n * u64 bpf_map_lookup_elem(u64 r1, u64 r2, u64 r3, u64 r4, u64 r5)\n * {\n *    struct bpf_map *map = (struct bpf_map *) (unsigned long) r1;\n *    void *key = (void *) (unsigned long) r2;\n *    void *value;\n *\n *    here kernel can access 'key' and 'map' pointers safely, knowing that\n *    [key, key + map->key_size) bytes are valid and were initialized on\n *    the stack of eBPF program.\n * }\n *\n * Corresponding eBPF program may look like:\n *    BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),  // after this insn R2 type is FRAME_PTR\n *    BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4), // after this insn R2 type is PTR_TO_STACK\n *    BPF_LD_MAP_FD(BPF_REG_1, map_fd),      // after this insn R1 type is CONST_PTR_TO_MAP\n *    BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),\n * here verifier looks at prototype of map_lookup_elem() and sees:\n * .arg1_type == ARG_CONST_MAP_PTR and R1->type == CONST_PTR_TO_MAP, which is ok,\n * Now verifier knows that this map has key of R1->map_ptr->key_size bytes\n *\n * Then .arg2_type == ARG_PTR_TO_MAP_KEY and R2->type == PTR_TO_STACK, ok so far,\n * Now verifier checks that [R2, R2 + map's key_size) are within stack limits\n * and were initialized prior to this call.\n * If it's ok, then verifier allows this BPF_CALL insn and looks at\n * .ret_type which is RET_PTR_TO_MAP_VALUE_OR_NULL, so it sets\n * R0->type = PTR_TO_MAP_VALUE_OR_NULL which means bpf_map_lookup_elem() function\n * returns ether pointer to map value or NULL.\n *\n * When type PTR_TO_MAP_VALUE_OR_NULL passes through 'if (reg != 0) goto +off'\n * insn, the register holding that pointer in the true branch changes state to\n * PTR_TO_MAP_VALUE and the same register changes state to CONST_IMM in the false\n * branch. See check_cond_jmp_op().\n *\n * After the call R0 is set to return type of the function and registers R1-R5\n * are set to NOT_INIT to indicate that they are no longer readable.\n */\n\n/* verifier_state + insn_idx are pushed to stack when branch is encountered */\nstruct bpf_verifier_stack_elem {\n\t/* verifer state is 'st'\n\t * before processing instruction 'insn_idx'\n\t * and after processing instruction 'prev_insn_idx'\n\t */\n\tstruct bpf_verifier_state st;\n\tint insn_idx;\n\tint prev_insn_idx;\n\tstruct bpf_verifier_stack_elem *next;\n};\n\n#define BPF_COMPLEXITY_LIMIT_INSNS\t65536\n#define BPF_COMPLEXITY_LIMIT_STACK\t1024\n\n#define BPF_MAP_PTR_POISON ((void *)0xeB9F + POISON_POINTER_DELTA)\n\nstruct bpf_call_arg_meta {\n\tstruct bpf_map *map_ptr;\n\tbool raw_mode;\n\tbool pkt_access;\n\tint regno;\n\tint access_size;\n};\n\n/* verbose verifier prints what it's seeing\n * bpf_check() is called under lock, so no race to access these global vars\n */\nstatic u32 log_level, log_size, log_len;\nstatic char *log_buf;\n\nstatic DEFINE_MUTEX(bpf_verifier_lock);\n\n/* log_level controls verbosity level of eBPF verifier.\n * verbose() is used to dump the verification trace to the log, so the user\n * can figure out what's wrong with the program\n */\nstatic __printf(1, 2) void verbose(const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (log_level == 0 || log_len >= log_size - 1)\n\t\treturn;\n\n\tva_start(args, fmt);\n\tlog_len += vscnprintf(log_buf + log_len, log_size - log_len, fmt, args);\n\tva_end(args);\n}\n\n/* string representation of 'enum bpf_reg_type' */\nstatic const char * const reg_type_str[] = {\n\t[NOT_INIT]\t\t= \"?\",\n\t[UNKNOWN_VALUE]\t\t= \"inv\",\n\t[PTR_TO_CTX]\t\t= \"ctx\",\n\t[CONST_PTR_TO_MAP]\t= \"map_ptr\",\n\t[PTR_TO_MAP_VALUE]\t= \"map_value\",\n\t[PTR_TO_MAP_VALUE_OR_NULL] = \"map_value_or_null\",\n\t[PTR_TO_MAP_VALUE_ADJ]\t= \"map_value_adj\",\n\t[FRAME_PTR]\t\t= \"fp\",\n\t[PTR_TO_STACK]\t\t= \"fp\",\n\t[CONST_IMM]\t\t= \"imm\",\n\t[PTR_TO_PACKET]\t\t= \"pkt\",\n\t[PTR_TO_PACKET_END]\t= \"pkt_end\",\n};\n\n#define __BPF_FUNC_STR_FN(x) [BPF_FUNC_ ## x] = __stringify(bpf_ ## x)\nstatic const char * const func_id_str[] = {\n\t__BPF_FUNC_MAPPER(__BPF_FUNC_STR_FN)\n};\n#undef __BPF_FUNC_STR_FN\n\nstatic const char *func_id_name(int id)\n{\n\tBUILD_BUG_ON(ARRAY_SIZE(func_id_str) != __BPF_FUNC_MAX_ID);\n\n\tif (id >= 0 && id < __BPF_FUNC_MAX_ID && func_id_str[id])\n\t\treturn func_id_str[id];\n\telse\n\t\treturn \"unknown\";\n}\n\nstatic void print_verifier_state(struct bpf_verifier_state *state)\n{\n\tstruct bpf_reg_state *reg;\n\tenum bpf_reg_type t;\n\tint i;\n\n\tfor (i = 0; i < MAX_BPF_REG; i++) {\n\t\treg = &state->regs[i];\n\t\tt = reg->type;\n\t\tif (t == NOT_INIT)\n\t\t\tcontinue;\n\t\tverbose(\" R%d=%s\", i, reg_type_str[t]);\n\t\tif (t == CONST_IMM || t == PTR_TO_STACK)\n\t\t\tverbose(\"%lld\", reg->imm);\n\t\telse if (t == PTR_TO_PACKET)\n\t\t\tverbose(\"(id=%d,off=%d,r=%d)\",\n\t\t\t\treg->id, reg->off, reg->range);\n\t\telse if (t == UNKNOWN_VALUE && reg->imm)\n\t\t\tverbose(\"%lld\", reg->imm);\n\t\telse if (t == CONST_PTR_TO_MAP || t == PTR_TO_MAP_VALUE ||\n\t\t\t t == PTR_TO_MAP_VALUE_OR_NULL ||\n\t\t\t t == PTR_TO_MAP_VALUE_ADJ)\n\t\t\tverbose(\"(ks=%d,vs=%d,id=%u)\",\n\t\t\t\treg->map_ptr->key_size,\n\t\t\t\treg->map_ptr->value_size,\n\t\t\t\treg->id);\n\t\tif (reg->min_value != BPF_REGISTER_MIN_RANGE)\n\t\t\tverbose(\",min_value=%lld\",\n\t\t\t\t(long long)reg->min_value);\n\t\tif (reg->max_value != BPF_REGISTER_MAX_RANGE)\n\t\t\tverbose(\",max_value=%llu\",\n\t\t\t\t(unsigned long long)reg->max_value);\n\t}\n\tfor (i = 0; i < MAX_BPF_STACK; i += BPF_REG_SIZE) {\n\t\tif (state->stack_slot_type[i] == STACK_SPILL)\n\t\t\tverbose(\" fp%d=%s\", -MAX_BPF_STACK + i,\n\t\t\t\treg_type_str[state->spilled_regs[i / BPF_REG_SIZE].type]);\n\t}\n\tverbose(\"\\n\");\n}\n\nstatic const char *const bpf_class_string[] = {\n\t[BPF_LD]    = \"ld\",\n\t[BPF_LDX]   = \"ldx\",\n\t[BPF_ST]    = \"st\",\n\t[BPF_STX]   = \"stx\",\n\t[BPF_ALU]   = \"alu\",\n\t[BPF_JMP]   = \"jmp\",\n\t[BPF_RET]   = \"BUG\",\n\t[BPF_ALU64] = \"alu64\",\n};\n\nstatic const char *const bpf_alu_string[16] = {\n\t[BPF_ADD >> 4]  = \"+=\",\n\t[BPF_SUB >> 4]  = \"-=\",\n\t[BPF_MUL >> 4]  = \"*=\",\n\t[BPF_DIV >> 4]  = \"/=\",\n\t[BPF_OR  >> 4]  = \"|=\",\n\t[BPF_AND >> 4]  = \"&=\",\n\t[BPF_LSH >> 4]  = \"<<=\",\n\t[BPF_RSH >> 4]  = \">>=\",\n\t[BPF_NEG >> 4]  = \"neg\",\n\t[BPF_MOD >> 4]  = \"%=\",\n\t[BPF_XOR >> 4]  = \"^=\",\n\t[BPF_MOV >> 4]  = \"=\",\n\t[BPF_ARSH >> 4] = \"s>>=\",\n\t[BPF_END >> 4]  = \"endian\",\n};\n\nstatic const char *const bpf_ldst_string[] = {\n\t[BPF_W >> 3]  = \"u32\",\n\t[BPF_H >> 3]  = \"u16\",\n\t[BPF_B >> 3]  = \"u8\",\n\t[BPF_DW >> 3] = \"u64\",\n};\n\nstatic const char *const bpf_jmp_string[16] = {\n\t[BPF_JA >> 4]   = \"jmp\",\n\t[BPF_JEQ >> 4]  = \"==\",\n\t[BPF_JGT >> 4]  = \">\",\n\t[BPF_JGE >> 4]  = \">=\",\n\t[BPF_JSET >> 4] = \"&\",\n\t[BPF_JNE >> 4]  = \"!=\",\n\t[BPF_JSGT >> 4] = \"s>\",\n\t[BPF_JSGE >> 4] = \"s>=\",\n\t[BPF_CALL >> 4] = \"call\",\n\t[BPF_EXIT >> 4] = \"exit\",\n};\n\nstatic void print_bpf_insn(const struct bpf_verifier_env *env,\n\t\t\t   const struct bpf_insn *insn)\n{\n\tu8 class = BPF_CLASS(insn->code);\n\n\tif (class == BPF_ALU || class == BPF_ALU64) {\n\t\tif (BPF_SRC(insn->code) == BPF_X)\n\t\t\tverbose(\"(%02x) %sr%d %s %sr%d\\n\",\n\t\t\t\tinsn->code, class == BPF_ALU ? \"(u32) \" : \"\",\n\t\t\t\tinsn->dst_reg,\n\t\t\t\tbpf_alu_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tclass == BPF_ALU ? \"(u32) \" : \"\",\n\t\t\t\tinsn->src_reg);\n\t\telse\n\t\t\tverbose(\"(%02x) %sr%d %s %s%d\\n\",\n\t\t\t\tinsn->code, class == BPF_ALU ? \"(u32) \" : \"\",\n\t\t\t\tinsn->dst_reg,\n\t\t\t\tbpf_alu_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tclass == BPF_ALU ? \"(u32) \" : \"\",\n\t\t\t\tinsn->imm);\n\t} else if (class == BPF_STX) {\n\t\tif (BPF_MODE(insn->code) == BPF_MEM)\n\t\t\tverbose(\"(%02x) *(%s *)(r%d %+d) = r%d\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->dst_reg,\n\t\t\t\tinsn->off, insn->src_reg);\n\t\telse if (BPF_MODE(insn->code) == BPF_XADD)\n\t\t\tverbose(\"(%02x) lock *(%s *)(r%d %+d) += r%d\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->dst_reg, insn->off,\n\t\t\t\tinsn->src_reg);\n\t\telse\n\t\t\tverbose(\"BUG_%02x\\n\", insn->code);\n\t} else if (class == BPF_ST) {\n\t\tif (BPF_MODE(insn->code) != BPF_MEM) {\n\t\t\tverbose(\"BUG_st_%02x\\n\", insn->code);\n\t\t\treturn;\n\t\t}\n\t\tverbose(\"(%02x) *(%s *)(r%d %+d) = %d\\n\",\n\t\t\tinsn->code,\n\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\tinsn->dst_reg,\n\t\t\tinsn->off, insn->imm);\n\t} else if (class == BPF_LDX) {\n\t\tif (BPF_MODE(insn->code) != BPF_MEM) {\n\t\t\tverbose(\"BUG_ldx_%02x\\n\", insn->code);\n\t\t\treturn;\n\t\t}\n\t\tverbose(\"(%02x) r%d = *(%s *)(r%d %+d)\\n\",\n\t\t\tinsn->code, insn->dst_reg,\n\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\tinsn->src_reg, insn->off);\n\t} else if (class == BPF_LD) {\n\t\tif (BPF_MODE(insn->code) == BPF_ABS) {\n\t\t\tverbose(\"(%02x) r0 = *(%s *)skb[%d]\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->imm);\n\t\t} else if (BPF_MODE(insn->code) == BPF_IND) {\n\t\t\tverbose(\"(%02x) r0 = *(%s *)skb[r%d + %d]\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->src_reg, insn->imm);\n\t\t} else if (BPF_MODE(insn->code) == BPF_IMM &&\n\t\t\t   BPF_SIZE(insn->code) == BPF_DW) {\n\t\t\t/* At this point, we already made sure that the second\n\t\t\t * part of the ldimm64 insn is accessible.\n\t\t\t */\n\t\t\tu64 imm = ((u64)(insn + 1)->imm << 32) | (u32)insn->imm;\n\t\t\tbool map_ptr = insn->src_reg == BPF_PSEUDO_MAP_FD;\n\n\t\t\tif (map_ptr && !env->allow_ptr_leaks)\n\t\t\t\timm = 0;\n\n\t\t\tverbose(\"(%02x) r%d = 0x%llx\\n\", insn->code,\n\t\t\t\tinsn->dst_reg, (unsigned long long)imm);\n\t\t} else {\n\t\t\tverbose(\"BUG_ld_%02x\\n\", insn->code);\n\t\t\treturn;\n\t\t}\n\t} else if (class == BPF_JMP) {\n\t\tu8 opcode = BPF_OP(insn->code);\n\n\t\tif (opcode == BPF_CALL) {\n\t\t\tverbose(\"(%02x) call %s#%d\\n\", insn->code,\n\t\t\t\tfunc_id_name(insn->imm), insn->imm);\n\t\t} else if (insn->code == (BPF_JMP | BPF_JA)) {\n\t\t\tverbose(\"(%02x) goto pc%+d\\n\",\n\t\t\t\tinsn->code, insn->off);\n\t\t} else if (insn->code == (BPF_JMP | BPF_EXIT)) {\n\t\t\tverbose(\"(%02x) exit\\n\", insn->code);\n\t\t} else if (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tverbose(\"(%02x) if r%d %s r%d goto pc%+d\\n\",\n\t\t\t\tinsn->code, insn->dst_reg,\n\t\t\t\tbpf_jmp_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tinsn->src_reg, insn->off);\n\t\t} else {\n\t\t\tverbose(\"(%02x) if r%d %s 0x%x goto pc%+d\\n\",\n\t\t\t\tinsn->code, insn->dst_reg,\n\t\t\t\tbpf_jmp_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tinsn->imm, insn->off);\n\t\t}\n\t} else {\n\t\tverbose(\"(%02x) %s\\n\", insn->code, bpf_class_string[class]);\n\t}\n}\n\nstatic int pop_stack(struct bpf_verifier_env *env, int *prev_insn_idx)\n{\n\tstruct bpf_verifier_stack_elem *elem;\n\tint insn_idx;\n\n\tif (env->head == NULL)\n\t\treturn -1;\n\n\tmemcpy(&env->cur_state, &env->head->st, sizeof(env->cur_state));\n\tinsn_idx = env->head->insn_idx;\n\tif (prev_insn_idx)\n\t\t*prev_insn_idx = env->head->prev_insn_idx;\n\telem = env->head->next;\n\tkfree(env->head);\n\tenv->head = elem;\n\tenv->stack_size--;\n\treturn insn_idx;\n}\n\nstatic struct bpf_verifier_state *push_stack(struct bpf_verifier_env *env,\n\t\t\t\t\t     int insn_idx, int prev_insn_idx)\n{\n\tstruct bpf_verifier_stack_elem *elem;\n\n\telem = kmalloc(sizeof(struct bpf_verifier_stack_elem), GFP_KERNEL);\n\tif (!elem)\n\t\tgoto err;\n\n\tmemcpy(&elem->st, &env->cur_state, sizeof(env->cur_state));\n\telem->insn_idx = insn_idx;\n\telem->prev_insn_idx = prev_insn_idx;\n\telem->next = env->head;\n\tenv->head = elem;\n\tenv->stack_size++;\n\tif (env->stack_size > BPF_COMPLEXITY_LIMIT_STACK) {\n\t\tverbose(\"BPF program is too complex\\n\");\n\t\tgoto err;\n\t}\n\treturn &elem->st;\nerr:\n\t/* pop all elements and return */\n\twhile (pop_stack(env, NULL) >= 0);\n\treturn NULL;\n}\n\n#define CALLER_SAVED_REGS 6\nstatic const int caller_saved[CALLER_SAVED_REGS] = {\n\tBPF_REG_0, BPF_REG_1, BPF_REG_2, BPF_REG_3, BPF_REG_4, BPF_REG_5\n};\n\nstatic void init_reg_state(struct bpf_reg_state *regs)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_BPF_REG; i++) {\n\t\tregs[i].type = NOT_INIT;\n\t\tregs[i].imm = 0;\n\t\tregs[i].min_value = BPF_REGISTER_MIN_RANGE;\n\t\tregs[i].max_value = BPF_REGISTER_MAX_RANGE;\n\t}\n\n\t/* frame pointer */\n\tregs[BPF_REG_FP].type = FRAME_PTR;\n\n\t/* 1st arg to a function */\n\tregs[BPF_REG_1].type = PTR_TO_CTX;\n}\n\nstatic void __mark_reg_unknown_value(struct bpf_reg_state *regs, u32 regno)\n{\n\tregs[regno].type = UNKNOWN_VALUE;\n\tregs[regno].id = 0;\n\tregs[regno].imm = 0;\n}\n\nstatic void mark_reg_unknown_value(struct bpf_reg_state *regs, u32 regno)\n{\n\tBUG_ON(regno >= MAX_BPF_REG);\n\t__mark_reg_unknown_value(regs, regno);\n}\n\nstatic void reset_reg_range_values(struct bpf_reg_state *regs, u32 regno)\n{\n\tregs[regno].min_value = BPF_REGISTER_MIN_RANGE;\n\tregs[regno].max_value = BPF_REGISTER_MAX_RANGE;\n}\n\nstatic void mark_reg_unknown_value_and_range(struct bpf_reg_state *regs,\n\t\t\t\t\t     u32 regno)\n{\n\tmark_reg_unknown_value(regs, regno);\n\treset_reg_range_values(regs, regno);\n}\n\nenum reg_arg_type {\n\tSRC_OP,\t\t/* register is used as source operand */\n\tDST_OP,\t\t/* register is used as destination operand */\n\tDST_OP_NO_MARK\t/* same as above, check only, don't mark */\n};\n\nstatic int check_reg_arg(struct bpf_reg_state *regs, u32 regno,\n\t\t\t enum reg_arg_type t)\n{\n\tif (regno >= MAX_BPF_REG) {\n\t\tverbose(\"R%d is invalid\\n\", regno);\n\t\treturn -EINVAL;\n\t}\n\n\tif (t == SRC_OP) {\n\t\t/* check whether register used as source operand can be read */\n\t\tif (regs[regno].type == NOT_INIT) {\n\t\t\tverbose(\"R%d !read_ok\\n\", regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t} else {\n\t\t/* check whether register used as dest operand can be written to */\n\t\tif (regno == BPF_REG_FP) {\n\t\t\tverbose(\"frame pointer is read only\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (t == DST_OP)\n\t\t\tmark_reg_unknown_value(regs, regno);\n\t}\n\treturn 0;\n}\n\nstatic int bpf_size_to_bytes(int bpf_size)\n{\n\tif (bpf_size == BPF_W)\n\t\treturn 4;\n\telse if (bpf_size == BPF_H)\n\t\treturn 2;\n\telse if (bpf_size == BPF_B)\n\t\treturn 1;\n\telse if (bpf_size == BPF_DW)\n\t\treturn 8;\n\telse\n\t\treturn -EINVAL;\n}\n\nstatic bool is_spillable_regtype(enum bpf_reg_type type)\n{\n\tswitch (type) {\n\tcase PTR_TO_MAP_VALUE:\n\tcase PTR_TO_MAP_VALUE_OR_NULL:\n\tcase PTR_TO_MAP_VALUE_ADJ:\n\tcase PTR_TO_STACK:\n\tcase PTR_TO_CTX:\n\tcase PTR_TO_PACKET:\n\tcase PTR_TO_PACKET_END:\n\tcase FRAME_PTR:\n\tcase CONST_PTR_TO_MAP:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n/* check_stack_read/write functions track spill/fill of registers,\n * stack boundary and alignment are checked in check_mem_access()\n */\nstatic int check_stack_write(struct bpf_verifier_state *state, int off,\n\t\t\t     int size, int value_regno)\n{\n\tint i;\n\t/* caller checked that off % size == 0 and -MAX_BPF_STACK <= off < 0,\n\t * so it's aligned access and [off, off + size) are within stack limits\n\t */\n\n\tif (value_regno >= 0 &&\n\t    is_spillable_regtype(state->regs[value_regno].type)) {\n\n\t\t/* register containing pointer is being spilled into stack */\n\t\tif (size != BPF_REG_SIZE) {\n\t\t\tverbose(\"invalid size of register spill\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\t/* save register state */\n\t\tstate->spilled_regs[(MAX_BPF_STACK + off) / BPF_REG_SIZE] =\n\t\t\tstate->regs[value_regno];\n\n\t\tfor (i = 0; i < BPF_REG_SIZE; i++)\n\t\t\tstate->stack_slot_type[MAX_BPF_STACK + off + i] = STACK_SPILL;\n\t} else {\n\t\t/* regular write of data into stack */\n\t\tstate->spilled_regs[(MAX_BPF_STACK + off) / BPF_REG_SIZE] =\n\t\t\t(struct bpf_reg_state) {};\n\n\t\tfor (i = 0; i < size; i++)\n\t\t\tstate->stack_slot_type[MAX_BPF_STACK + off + i] = STACK_MISC;\n\t}\n\treturn 0;\n}\n\nstatic int check_stack_read(struct bpf_verifier_state *state, int off, int size,\n\t\t\t    int value_regno)\n{\n\tu8 *slot_type;\n\tint i;\n\n\tslot_type = &state->stack_slot_type[MAX_BPF_STACK + off];\n\n\tif (slot_type[0] == STACK_SPILL) {\n\t\tif (size != BPF_REG_SIZE) {\n\t\t\tverbose(\"invalid size of register spill\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tfor (i = 1; i < BPF_REG_SIZE; i++) {\n\t\t\tif (slot_type[i] != STACK_SPILL) {\n\t\t\t\tverbose(\"corrupted spill memory\\n\");\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\t\t}\n\n\t\tif (value_regno >= 0)\n\t\t\t/* restore register state from stack */\n\t\t\tstate->regs[value_regno] =\n\t\t\t\tstate->spilled_regs[(MAX_BPF_STACK + off) / BPF_REG_SIZE];\n\t\treturn 0;\n\t} else {\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tif (slot_type[i] != STACK_MISC) {\n\t\t\t\tverbose(\"invalid read from stack off %d+%d size %d\\n\",\n\t\t\t\t\toff, i, size);\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\t\t}\n\t\tif (value_regno >= 0)\n\t\t\t/* have read misc data from the stack */\n\t\t\tmark_reg_unknown_value_and_range(state->regs,\n\t\t\t\t\t\t\t value_regno);\n\t\treturn 0;\n\t}\n}\n\n/* check read/write into map element returned by bpf_map_lookup_elem() */\nstatic int check_map_access(struct bpf_verifier_env *env, u32 regno, int off,\n\t\t\t    int size)\n{\n\tstruct bpf_map *map = env->cur_state.regs[regno].map_ptr;\n\n\tif (off < 0 || size <= 0 || off + size > map->value_size) {\n\t\tverbose(\"invalid access to map value, value_size=%d off=%d size=%d\\n\",\n\t\t\tmap->value_size, off, size);\n\t\treturn -EACCES;\n\t}\n\treturn 0;\n}\n\n/* check read/write into an adjusted map element */\nstatic int check_map_access_adj(struct bpf_verifier_env *env, u32 regno,\n\t\t\t\tint off, int size)\n{\n\tstruct bpf_verifier_state *state = &env->cur_state;\n\tstruct bpf_reg_state *reg = &state->regs[regno];\n\tint err;\n\n\t/* We adjusted the register to this map value, so we\n\t * need to change off and size to min_value and max_value\n\t * respectively to make sure our theoretical access will be\n\t * safe.\n\t */\n\tif (log_level)\n\t\tprint_verifier_state(state);\n\tenv->varlen_map_value_access = true;\n\t/* The minimum value is only important with signed\n\t * comparisons where we can't assume the floor of a\n\t * value is 0.  If we are using signed variables for our\n\t * index'es we need to make sure that whatever we use\n\t * will have a set floor within our range.\n\t */\n\tif (reg->min_value < 0) {\n\t\tverbose(\"R%d min value is negative, either use unsigned index or do a if (index >=0) check.\\n\",\n\t\t\tregno);\n\t\treturn -EACCES;\n\t}\n\terr = check_map_access(env, regno, reg->min_value + off, size);\n\tif (err) {\n\t\tverbose(\"R%d min value is outside of the array range\\n\",\n\t\t\tregno);\n\t\treturn err;\n\t}\n\n\t/* If we haven't set a max value then we need to bail\n\t * since we can't be sure we won't do bad things.\n\t */\n\tif (reg->max_value == BPF_REGISTER_MAX_RANGE) {\n\t\tverbose(\"R%d unbounded memory access, make sure to bounds check any array access into a map\\n\",\n\t\t\tregno);\n\t\treturn -EACCES;\n\t}\n\treturn check_map_access(env, regno, reg->max_value + off, size);\n}\n\n#define MAX_PACKET_OFF 0xffff\n\nstatic bool may_access_direct_pkt_data(struct bpf_verifier_env *env,\n\t\t\t\t       const struct bpf_call_arg_meta *meta,\n\t\t\t\t       enum bpf_access_type t)\n{\n\tswitch (env->prog->type) {\n\tcase BPF_PROG_TYPE_LWT_IN:\n\tcase BPF_PROG_TYPE_LWT_OUT:\n\t\t/* dst_input() and dst_output() can't write for now */\n\t\tif (t == BPF_WRITE)\n\t\t\treturn false;\n\t\t/* fallthrough */\n\tcase BPF_PROG_TYPE_SCHED_CLS:\n\tcase BPF_PROG_TYPE_SCHED_ACT:\n\tcase BPF_PROG_TYPE_XDP:\n\tcase BPF_PROG_TYPE_LWT_XMIT:\n\t\tif (meta)\n\t\t\treturn meta->pkt_access;\n\n\t\tenv->seen_direct_write = true;\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int check_packet_access(struct bpf_verifier_env *env, u32 regno, int off,\n\t\t\t       int size)\n{\n\tstruct bpf_reg_state *regs = env->cur_state.regs;\n\tstruct bpf_reg_state *reg = &regs[regno];\n\n\toff += reg->off;\n\tif (off < 0 || size <= 0 || off + size > reg->range) {\n\t\tverbose(\"invalid access to packet, off=%d size=%d, R%d(id=%d,off=%d,r=%d)\\n\",\n\t\t\toff, size, regno, reg->id, reg->off, reg->range);\n\t\treturn -EACCES;\n\t}\n\treturn 0;\n}\n\n/* check access to 'struct bpf_context' fields */\nstatic int check_ctx_access(struct bpf_verifier_env *env, int off, int size,\n\t\t\t    enum bpf_access_type t, enum bpf_reg_type *reg_type)\n{\n\t/* for analyzer ctx accesses are already validated and converted */\n\tif (env->analyzer_ops)\n\t\treturn 0;\n\n\tif (env->prog->aux->ops->is_valid_access &&\n\t    env->prog->aux->ops->is_valid_access(off, size, t, reg_type)) {\n\t\t/* remember the offset of last byte accessed in ctx */\n\t\tif (env->prog->aux->max_ctx_offset < off + size)\n\t\t\tenv->prog->aux->max_ctx_offset = off + size;\n\t\treturn 0;\n\t}\n\n\tverbose(\"invalid bpf_context access off=%d size=%d\\n\", off, size);\n\treturn -EACCES;\n}\n\nstatic bool is_pointer_value(struct bpf_verifier_env *env, int regno)\n{\n\tif (env->allow_ptr_leaks)\n\t\treturn false;\n\n\tswitch (env->cur_state.regs[regno].type) {\n\tcase UNKNOWN_VALUE:\n\tcase CONST_IMM:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic int check_pkt_ptr_alignment(const struct bpf_reg_state *reg,\n\t\t\t\t   int off, int size)\n{\n\tif (reg->id && size != 1) {\n\t\tverbose(\"Unknown alignment. Only byte-sized access allowed in packet access.\\n\");\n\t\treturn -EACCES;\n\t}\n\n\t/* skb->data is NET_IP_ALIGN-ed */\n\tif ((NET_IP_ALIGN + reg->off + off) % size != 0) {\n\t\tverbose(\"misaligned packet access off %d+%d+%d size %d\\n\",\n\t\t\tNET_IP_ALIGN, reg->off, off, size);\n\t\treturn -EACCES;\n\t}\n\n\treturn 0;\n}\n\nstatic int check_val_ptr_alignment(const struct bpf_reg_state *reg,\n\t\t\t\t   int size)\n{\n\tif (size != 1) {\n\t\tverbose(\"Unknown alignment. Only byte-sized access allowed in value access.\\n\");\n\t\treturn -EACCES;\n\t}\n\n\treturn 0;\n}\n\nstatic int check_ptr_alignment(const struct bpf_reg_state *reg,\n\t\t\t       int off, int size)\n{\n\tswitch (reg->type) {\n\tcase PTR_TO_PACKET:\n\t\treturn IS_ENABLED(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) ? 0 :\n\t\t       check_pkt_ptr_alignment(reg, off, size);\n\tcase PTR_TO_MAP_VALUE_ADJ:\n\t\treturn IS_ENABLED(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) ? 0 :\n\t\t       check_val_ptr_alignment(reg, size);\n\tdefault:\n\t\tif (off % size != 0) {\n\t\t\tverbose(\"misaligned access off %d size %d\\n\",\n\t\t\t\toff, size);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\treturn 0;\n\t}\n}\n\n/* check whether memory at (regno + off) is accessible for t = (read | write)\n * if t==write, value_regno is a register which value is stored into memory\n * if t==read, value_regno is a register which will receive the value from memory\n * if t==write && value_regno==-1, some unknown value is stored into memory\n * if t==read && value_regno==-1, don't care what we read from memory\n */\nstatic int check_mem_access(struct bpf_verifier_env *env, u32 regno, int off,\n\t\t\t    int bpf_size, enum bpf_access_type t,\n\t\t\t    int value_regno)\n{\n\tstruct bpf_verifier_state *state = &env->cur_state;\n\tstruct bpf_reg_state *reg = &state->regs[regno];\n\tint size, err = 0;\n\n\tif (reg->type == PTR_TO_STACK)\n\t\toff += reg->imm;\n\n\tsize = bpf_size_to_bytes(bpf_size);\n\tif (size < 0)\n\t\treturn size;\n\n\terr = check_ptr_alignment(reg, off, size);\n\tif (err)\n\t\treturn err;\n\n\tif (reg->type == PTR_TO_MAP_VALUE ||\n\t    reg->type == PTR_TO_MAP_VALUE_ADJ) {\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(\"R%d leaks addr into map\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (reg->type == PTR_TO_MAP_VALUE_ADJ)\n\t\t\terr = check_map_access_adj(env, regno, off, size);\n\t\telse\n\t\t\terr = check_map_access(env, regno, off, size);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown_value_and_range(state->regs,\n\t\t\t\t\t\t\t value_regno);\n\n\t} else if (reg->type == PTR_TO_CTX) {\n\t\tenum bpf_reg_type reg_type = UNKNOWN_VALUE;\n\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(\"R%d leaks addr into ctx\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_ctx_access(env, off, size, t, &reg_type);\n\t\tif (!err && t == BPF_READ && value_regno >= 0) {\n\t\t\tmark_reg_unknown_value_and_range(state->regs,\n\t\t\t\t\t\t\t value_regno);\n\t\t\t/* note that reg.[id|off|range] == 0 */\n\t\t\tstate->regs[value_regno].type = reg_type;\n\t\t}\n\n\t} else if (reg->type == FRAME_PTR || reg->type == PTR_TO_STACK) {\n\t\tif (off >= 0 || off < -MAX_BPF_STACK) {\n\t\t\tverbose(\"invalid stack off=%d size=%d\\n\", off, size);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (t == BPF_WRITE) {\n\t\t\tif (!env->allow_ptr_leaks &&\n\t\t\t    state->stack_slot_type[MAX_BPF_STACK + off] == STACK_SPILL &&\n\t\t\t    size != BPF_REG_SIZE) {\n\t\t\t\tverbose(\"attempt to corrupt spilled pointer on stack\\n\");\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\t\t\terr = check_stack_write(state, off, size, value_regno);\n\t\t} else {\n\t\t\terr = check_stack_read(state, off, size, value_regno);\n\t\t}\n\t} else if (state->regs[regno].type == PTR_TO_PACKET) {\n\t\tif (t == BPF_WRITE && !may_access_direct_pkt_data(env, NULL, t)) {\n\t\t\tverbose(\"cannot write into packet\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(\"R%d leaks addr into packet\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_packet_access(env, regno, off, size);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown_value_and_range(state->regs,\n\t\t\t\t\t\t\t value_regno);\n\t} else {\n\t\tverbose(\"R%d invalid mem access '%s'\\n\",\n\t\t\tregno, reg_type_str[reg->type]);\n\t\treturn -EACCES;\n\t}\n\n\tif (!err && size <= 2 && value_regno >= 0 && env->allow_ptr_leaks &&\n\t    state->regs[value_regno].type == UNKNOWN_VALUE) {\n\t\t/* 1 or 2 byte load zero-extends, determine the number of\n\t\t * zero upper bits. Not doing it fo 4 byte load, since\n\t\t * such values cannot be added to ptr_to_packet anyway.\n\t\t */\n\t\tstate->regs[value_regno].imm = 64 - size * 8;\n\t}\n\treturn err;\n}\n\nstatic int check_xadd(struct bpf_verifier_env *env, struct bpf_insn *insn)\n{\n\tstruct bpf_reg_state *regs = env->cur_state.regs;\n\tint err;\n\n\tif ((BPF_SIZE(insn->code) != BPF_W && BPF_SIZE(insn->code) != BPF_DW) ||\n\t    insn->imm != 0) {\n\t\tverbose(\"BPF_XADD uses reserved fields\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* check src1 operand */\n\terr = check_reg_arg(regs, insn->src_reg, SRC_OP);\n\tif (err)\n\t\treturn err;\n\n\t/* check src2 operand */\n\terr = check_reg_arg(regs, insn->dst_reg, SRC_OP);\n\tif (err)\n\t\treturn err;\n\n\t/* check whether atomic_add can read the memory */\n\terr = check_mem_access(env, insn->dst_reg, insn->off,\n\t\t\t       BPF_SIZE(insn->code), BPF_READ, -1);\n\tif (err)\n\t\treturn err;\n\n\t/* check whether atomic_add can write into the same memory */\n\treturn check_mem_access(env, insn->dst_reg, insn->off,\n\t\t\t\tBPF_SIZE(insn->code), BPF_WRITE, -1);\n}\n\n/* when register 'regno' is passed into function that will read 'access_size'\n * bytes from that pointer, make sure that it's within stack boundary\n * and all elements of stack are initialized\n */\nstatic int check_stack_boundary(struct bpf_verifier_env *env, int regno,\n\t\t\t\tint access_size, bool zero_size_allowed,\n\t\t\t\tstruct bpf_call_arg_meta *meta)\n{\n\tstruct bpf_verifier_state *state = &env->cur_state;\n\tstruct bpf_reg_state *regs = state->regs;\n\tint off, i;\n\n\tif (regs[regno].type != PTR_TO_STACK) {\n\t\tif (zero_size_allowed && access_size == 0 &&\n\t\t    regs[regno].type == CONST_IMM &&\n\t\t    regs[regno].imm  == 0)\n\t\t\treturn 0;\n\n\t\tverbose(\"R%d type=%s expected=%s\\n\", regno,\n\t\t\treg_type_str[regs[regno].type],\n\t\t\treg_type_str[PTR_TO_STACK]);\n\t\treturn -EACCES;\n\t}\n\n\toff = regs[regno].imm;\n\tif (off >= 0 || off < -MAX_BPF_STACK || off + access_size > 0 ||\n\t    access_size <= 0) {\n\t\tverbose(\"invalid stack type R%d off=%d access_size=%d\\n\",\n\t\t\tregno, off, access_size);\n\t\treturn -EACCES;\n\t}\n\n\tif (meta && meta->raw_mode) {\n\t\tmeta->access_size = access_size;\n\t\tmeta->regno = regno;\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < access_size; i++) {\n\t\tif (state->stack_slot_type[MAX_BPF_STACK + off + i] != STACK_MISC) {\n\t\t\tverbose(\"invalid indirect read from stack off %d+%d size %d\\n\",\n\t\t\t\toff, i, access_size);\n\t\t\treturn -EACCES;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int check_helper_mem_access(struct bpf_verifier_env *env, int regno,\n\t\t\t\t   int access_size, bool zero_size_allowed,\n\t\t\t\t   struct bpf_call_arg_meta *meta)\n{\n\tstruct bpf_reg_state *regs = env->cur_state.regs;\n\n\tswitch (regs[regno].type) {\n\tcase PTR_TO_PACKET:\n\t\treturn check_packet_access(env, regno, 0, access_size);\n\tcase PTR_TO_MAP_VALUE:\n\t\treturn check_map_access(env, regno, 0, access_size);\n\tcase PTR_TO_MAP_VALUE_ADJ:\n\t\treturn check_map_access_adj(env, regno, 0, access_size);\n\tdefault: /* const_imm|ptr_to_stack or invalid ptr */\n\t\treturn check_stack_boundary(env, regno, access_size,\n\t\t\t\t\t    zero_size_allowed, meta);\n\t}\n}\n\nstatic int check_func_arg(struct bpf_verifier_env *env, u32 regno,\n\t\t\t  enum bpf_arg_type arg_type,\n\t\t\t  struct bpf_call_arg_meta *meta)\n{\n\tstruct bpf_reg_state *regs = env->cur_state.regs, *reg = &regs[regno];\n\tenum bpf_reg_type expected_type, type = reg->type;\n\tint err = 0;\n\n\tif (arg_type == ARG_DONTCARE)\n\t\treturn 0;\n\n\tif (type == NOT_INIT) {\n\t\tverbose(\"R%d !read_ok\\n\", regno);\n\t\treturn -EACCES;\n\t}\n\n\tif (arg_type == ARG_ANYTHING) {\n\t\tif (is_pointer_value(env, regno)) {\n\t\t\tverbose(\"R%d leaks addr into helper function\\n\", regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (type == PTR_TO_PACKET &&\n\t    !may_access_direct_pkt_data(env, meta, BPF_READ)) {\n\t\tverbose(\"helper access to the packet is not allowed\\n\");\n\t\treturn -EACCES;\n\t}\n\n\tif (arg_type == ARG_PTR_TO_MAP_KEY ||\n\t    arg_type == ARG_PTR_TO_MAP_VALUE) {\n\t\texpected_type = PTR_TO_STACK;\n\t\tif (type != PTR_TO_PACKET && type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type == ARG_CONST_SIZE ||\n\t\t   arg_type == ARG_CONST_SIZE_OR_ZERO) {\n\t\texpected_type = CONST_IMM;\n\t\t/* One exception. Allow UNKNOWN_VALUE registers when the\n\t\t * boundaries are known and don't cause unsafe memory accesses\n\t\t */\n\t\tif (type != UNKNOWN_VALUE && type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type == ARG_CONST_MAP_PTR) {\n\t\texpected_type = CONST_PTR_TO_MAP;\n\t\tif (type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type == ARG_PTR_TO_CTX) {\n\t\texpected_type = PTR_TO_CTX;\n\t\tif (type != expected_type)\n\t\t\tgoto err_type;\n\t} else if (arg_type == ARG_PTR_TO_MEM ||\n\t\t   arg_type == ARG_PTR_TO_UNINIT_MEM) {\n\t\texpected_type = PTR_TO_STACK;\n\t\t/* One exception here. In case function allows for NULL to be\n\t\t * passed in as argument, it's a CONST_IMM type. Final test\n\t\t * happens during stack boundary checking.\n\t\t */\n\t\tif (type == CONST_IMM && reg->imm == 0)\n\t\t\t/* final test in check_stack_boundary() */;\n\t\telse if (type != PTR_TO_PACKET && type != PTR_TO_MAP_VALUE &&\n\t\t\t type != PTR_TO_MAP_VALUE_ADJ && type != expected_type)\n\t\t\tgoto err_type;\n\t\tmeta->raw_mode = arg_type == ARG_PTR_TO_UNINIT_MEM;\n\t} else {\n\t\tverbose(\"unsupported arg_type %d\\n\", arg_type);\n\t\treturn -EFAULT;\n\t}\n\n\tif (arg_type == ARG_CONST_MAP_PTR) {\n\t\t/* bpf_map_xxx(map_ptr) call: remember that map_ptr */\n\t\tmeta->map_ptr = reg->map_ptr;\n\t} else if (arg_type == ARG_PTR_TO_MAP_KEY) {\n\t\t/* bpf_map_xxx(..., map_ptr, ..., key) call:\n\t\t * check that [key, key + map->key_size) are within\n\t\t * stack limits and initialized\n\t\t */\n\t\tif (!meta->map_ptr) {\n\t\t\t/* in function declaration map_ptr must come before\n\t\t\t * map_key, so that it's verified and known before\n\t\t\t * we have to check map_key here. Otherwise it means\n\t\t\t * that kernel subsystem misconfigured verifier\n\t\t\t */\n\t\t\tverbose(\"invalid map_ptr to access map->key\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (type == PTR_TO_PACKET)\n\t\t\terr = check_packet_access(env, regno, 0,\n\t\t\t\t\t\t  meta->map_ptr->key_size);\n\t\telse\n\t\t\terr = check_stack_boundary(env, regno,\n\t\t\t\t\t\t   meta->map_ptr->key_size,\n\t\t\t\t\t\t   false, NULL);\n\t} else if (arg_type == ARG_PTR_TO_MAP_VALUE) {\n\t\t/* bpf_map_xxx(..., map_ptr, ..., value) call:\n\t\t * check [value, value + map->value_size) validity\n\t\t */\n\t\tif (!meta->map_ptr) {\n\t\t\t/* kernel subsystem misconfigured verifier */\n\t\t\tverbose(\"invalid map_ptr to access map->value\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (type == PTR_TO_PACKET)\n\t\t\terr = check_packet_access(env, regno, 0,\n\t\t\t\t\t\t  meta->map_ptr->value_size);\n\t\telse\n\t\t\terr = check_stack_boundary(env, regno,\n\t\t\t\t\t\t   meta->map_ptr->value_size,\n\t\t\t\t\t\t   false, NULL);\n\t} else if (arg_type == ARG_CONST_SIZE ||\n\t\t   arg_type == ARG_CONST_SIZE_OR_ZERO) {\n\t\tbool zero_size_allowed = (arg_type == ARG_CONST_SIZE_OR_ZERO);\n\n\t\t/* bpf_xxx(..., buf, len) call will access 'len' bytes\n\t\t * from stack pointer 'buf'. Check it\n\t\t * note: regno == len, regno - 1 == buf\n\t\t */\n\t\tif (regno == 0) {\n\t\t\t/* kernel subsystem misconfigured verifier */\n\t\t\tverbose(\"ARG_CONST_SIZE cannot be first argument\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\t/* If the register is UNKNOWN_VALUE, the access check happens\n\t\t * using its boundaries. Otherwise, just use its imm\n\t\t */\n\t\tif (type == UNKNOWN_VALUE) {\n\t\t\t/* For unprivileged variable accesses, disable raw\n\t\t\t * mode so that the program is required to\n\t\t\t * initialize all the memory that the helper could\n\t\t\t * just partially fill up.\n\t\t\t */\n\t\t\tmeta = NULL;\n\n\t\t\tif (reg->min_value < 0) {\n\t\t\t\tverbose(\"R%d min value is negative, either use unsigned or 'var &= const'\\n\",\n\t\t\t\t\tregno);\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\n\t\t\tif (reg->min_value == 0) {\n\t\t\t\terr = check_helper_mem_access(env, regno - 1, 0,\n\t\t\t\t\t\t\t      zero_size_allowed,\n\t\t\t\t\t\t\t      meta);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\n\t\t\tif (reg->max_value == BPF_REGISTER_MAX_RANGE) {\n\t\t\t\tverbose(\"R%d unbounded memory access, use 'var &= const' or 'if (var < const)'\\n\",\n\t\t\t\t\tregno);\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\t\t\terr = check_helper_mem_access(env, regno - 1,\n\t\t\t\t\t\t      reg->max_value,\n\t\t\t\t\t\t      zero_size_allowed, meta);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\t/* register is CONST_IMM */\n\t\t\terr = check_helper_mem_access(env, regno - 1, reg->imm,\n\t\t\t\t\t\t      zero_size_allowed, meta);\n\t\t}\n\t}\n\n\treturn err;\nerr_type:\n\tverbose(\"R%d type=%s expected=%s\\n\", regno,\n\t\treg_type_str[type], reg_type_str[expected_type]);\n\treturn -EACCES;\n}\n\nstatic int check_map_func_compatibility(struct bpf_map *map, int func_id)\n{\n\tif (!map)\n\t\treturn 0;\n\n\t/* We need a two way check, first is from map perspective ... */\n\tswitch (map->map_type) {\n\tcase BPF_MAP_TYPE_PROG_ARRAY:\n\t\tif (func_id != BPF_FUNC_tail_call)\n\t\t\tgoto error;\n\t\tbreak;\n\tcase BPF_MAP_TYPE_PERF_EVENT_ARRAY:\n\t\tif (func_id != BPF_FUNC_perf_event_read &&\n\t\t    func_id != BPF_FUNC_perf_event_output)\n\t\t\tgoto error;\n\t\tbreak;\n\tcase BPF_MAP_TYPE_STACK_TRACE:\n\t\tif (func_id != BPF_FUNC_get_stackid)\n\t\t\tgoto error;\n\t\tbreak;\n\tcase BPF_MAP_TYPE_CGROUP_ARRAY:\n\t\tif (func_id != BPF_FUNC_skb_under_cgroup &&\n\t\t    func_id != BPF_FUNC_current_task_under_cgroup)\n\t\t\tgoto error;\n\t\tbreak;\n\tcase BPF_MAP_TYPE_ARRAY_OF_MAPS:\n\tcase BPF_MAP_TYPE_HASH_OF_MAPS:\n\t\tif (func_id != BPF_FUNC_map_lookup_elem)\n\t\t\tgoto error;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* ... and second from the function itself. */\n\tswitch (func_id) {\n\tcase BPF_FUNC_tail_call:\n\t\tif (map->map_type != BPF_MAP_TYPE_PROG_ARRAY)\n\t\t\tgoto error;\n\t\tbreak;\n\tcase BPF_FUNC_perf_event_read:\n\tcase BPF_FUNC_perf_event_output:\n\t\tif (map->map_type != BPF_MAP_TYPE_PERF_EVENT_ARRAY)\n\t\t\tgoto error;\n\t\tbreak;\n\tcase BPF_FUNC_get_stackid:\n\t\tif (map->map_type != BPF_MAP_TYPE_STACK_TRACE)\n\t\t\tgoto error;\n\t\tbreak;\n\tcase BPF_FUNC_current_task_under_cgroup:\n\tcase BPF_FUNC_skb_under_cgroup:\n\t\tif (map->map_type != BPF_MAP_TYPE_CGROUP_ARRAY)\n\t\t\tgoto error;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\nerror:\n\tverbose(\"cannot pass map_type %d into func %s#%d\\n\",\n\t\tmap->map_type, func_id_name(func_id), func_id);\n\treturn -EINVAL;\n}\n\nstatic int check_raw_mode(const struct bpf_func_proto *fn)\n{\n\tint count = 0;\n\n\tif (fn->arg1_type == ARG_PTR_TO_UNINIT_MEM)\n\t\tcount++;\n\tif (fn->arg2_type == ARG_PTR_TO_UNINIT_MEM)\n\t\tcount++;\n\tif (fn->arg3_type == ARG_PTR_TO_UNINIT_MEM)\n\t\tcount++;\n\tif (fn->arg4_type == ARG_PTR_TO_UNINIT_MEM)\n\t\tcount++;\n\tif (fn->arg5_type == ARG_PTR_TO_UNINIT_MEM)\n\t\tcount++;\n\n\treturn count > 1 ? -EINVAL : 0;\n}\n\nstatic void clear_all_pkt_pointers(struct bpf_verifier_env *env)\n{\n\tstruct bpf_verifier_state *state = &env->cur_state;\n\tstruct bpf_reg_state *regs = state->regs, *reg;\n\tint i;\n\n\tfor (i = 0; i < MAX_BPF_REG; i++)\n\t\tif (regs[i].type == PTR_TO_PACKET ||\n\t\t    regs[i].type == PTR_TO_PACKET_END)\n\t\t\tmark_reg_unknown_value(regs, i);\n\n\tfor (i = 0; i < MAX_BPF_STACK; i += BPF_REG_SIZE) {\n\t\tif (state->stack_slot_type[i] != STACK_SPILL)\n\t\t\tcontinue;\n\t\treg = &state->spilled_regs[i / BPF_REG_SIZE];\n\t\tif (reg->type != PTR_TO_PACKET &&\n\t\t    reg->type != PTR_TO_PACKET_END)\n\t\t\tcontinue;\n\t\treg->type = UNKNOWN_VALUE;\n\t\treg->imm = 0;\n\t}\n}\n\nstatic int check_call(struct bpf_verifier_env *env, int func_id, int insn_idx)\n{\n\tstruct bpf_verifier_state *state = &env->cur_state;\n\tconst struct bpf_func_proto *fn = NULL;\n\tstruct bpf_reg_state *regs = state->regs;\n\tstruct bpf_reg_state *reg;\n\tstruct bpf_call_arg_meta meta;\n\tbool changes_data;\n\tint i, err;\n\n\t/* find function prototype */\n\tif (func_id < 0 || func_id >= __BPF_FUNC_MAX_ID) {\n\t\tverbose(\"invalid func %s#%d\\n\", func_id_name(func_id), func_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (env->prog->aux->ops->get_func_proto)\n\t\tfn = env->prog->aux->ops->get_func_proto(func_id);\n\n\tif (!fn) {\n\t\tverbose(\"unknown func %s#%d\\n\", func_id_name(func_id), func_id);\n\t\treturn -EINVAL;\n\t}\n\n\t/* eBPF programs must be GPL compatible to use GPL-ed functions */\n\tif (!env->prog->gpl_compatible && fn->gpl_only) {\n\t\tverbose(\"cannot call GPL only function from proprietary program\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tchanges_data = bpf_helper_changes_pkt_data(fn->func);\n\n\tmemset(&meta, 0, sizeof(meta));\n\tmeta.pkt_access = fn->pkt_access;\n\n\t/* We only support one arg being in raw mode at the moment, which\n\t * is sufficient for the helper functions we have right now.\n\t */\n\terr = check_raw_mode(fn);\n\tif (err) {\n\t\tverbose(\"kernel subsystem misconfigured func %s#%d\\n\",\n\t\t\tfunc_id_name(func_id), func_id);\n\t\treturn err;\n\t}\n\n\t/* check args */\n\terr = check_func_arg(env, BPF_REG_1, fn->arg1_type, &meta);\n\tif (err)\n\t\treturn err;\n\terr = check_func_arg(env, BPF_REG_2, fn->arg2_type, &meta);\n\tif (err)\n\t\treturn err;\n\terr = check_func_arg(env, BPF_REG_3, fn->arg3_type, &meta);\n\tif (err)\n\t\treturn err;\n\terr = check_func_arg(env, BPF_REG_4, fn->arg4_type, &meta);\n\tif (err)\n\t\treturn err;\n\terr = check_func_arg(env, BPF_REG_5, fn->arg5_type, &meta);\n\tif (err)\n\t\treturn err;\n\n\t/* Mark slots with STACK_MISC in case of raw mode, stack offset\n\t * is inferred from register state.\n\t */\n\tfor (i = 0; i < meta.access_size; i++) {\n\t\terr = check_mem_access(env, meta.regno, i, BPF_B, BPF_WRITE, -1);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t/* reset caller saved regs */\n\tfor (i = 0; i < CALLER_SAVED_REGS; i++) {\n\t\treg = regs + caller_saved[i];\n\t\treg->type = NOT_INIT;\n\t\treg->imm = 0;\n\t}\n\n\t/* update return register */\n\tif (fn->ret_type == RET_INTEGER) {\n\t\tregs[BPF_REG_0].type = UNKNOWN_VALUE;\n\t} else if (fn->ret_type == RET_VOID) {\n\t\tregs[BPF_REG_0].type = NOT_INIT;\n\t} else if (fn->ret_type == RET_PTR_TO_MAP_VALUE_OR_NULL) {\n\t\tstruct bpf_insn_aux_data *insn_aux;\n\n\t\tregs[BPF_REG_0].type = PTR_TO_MAP_VALUE_OR_NULL;\n\t\tregs[BPF_REG_0].max_value = regs[BPF_REG_0].min_value = 0;\n\t\t/* remember map_ptr, so that check_map_access()\n\t\t * can check 'value_size' boundary of memory access\n\t\t * to map element returned from bpf_map_lookup_elem()\n\t\t */\n\t\tif (meta.map_ptr == NULL) {\n\t\t\tverbose(\"kernel subsystem misconfigured verifier\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tregs[BPF_REG_0].map_ptr = meta.map_ptr;\n\t\tregs[BPF_REG_0].id = ++env->id_gen;\n\t\tinsn_aux = &env->insn_aux_data[insn_idx];\n\t\tif (!insn_aux->map_ptr)\n\t\t\tinsn_aux->map_ptr = meta.map_ptr;\n\t\telse if (insn_aux->map_ptr != meta.map_ptr)\n\t\t\tinsn_aux->map_ptr = BPF_MAP_PTR_POISON;\n\t} else {\n\t\tverbose(\"unknown return type %d of func %s#%d\\n\",\n\t\t\tfn->ret_type, func_id_name(func_id), func_id);\n\t\treturn -EINVAL;\n\t}\n\n\terr = check_map_func_compatibility(meta.map_ptr, func_id);\n\tif (err)\n\t\treturn err;\n\n\tif (changes_data)\n\t\tclear_all_pkt_pointers(env);\n\treturn 0;\n}\n\nstatic int check_packet_ptr_add(struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_insn *insn)\n{\n\tstruct bpf_reg_state *regs = env->cur_state.regs;\n\tstruct bpf_reg_state *dst_reg = &regs[insn->dst_reg];\n\tstruct bpf_reg_state *src_reg = &regs[insn->src_reg];\n\tstruct bpf_reg_state tmp_reg;\n\ts32 imm;\n\n\tif (BPF_SRC(insn->code) == BPF_K) {\n\t\t/* pkt_ptr += imm */\n\t\timm = insn->imm;\n\nadd_imm:\n\t\tif (imm < 0) {\n\t\t\tverbose(\"addition of negative constant to packet pointer is not allowed\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (imm >= MAX_PACKET_OFF ||\n\t\t    imm + dst_reg->off >= MAX_PACKET_OFF) {\n\t\t\tverbose(\"constant %d is too large to add to packet pointer\\n\",\n\t\t\t\timm);\n\t\t\treturn -EACCES;\n\t\t}\n\t\t/* a constant was added to pkt_ptr.\n\t\t * Remember it while keeping the same 'id'\n\t\t */\n\t\tdst_reg->off += imm;\n\t} else {\n\t\tif (src_reg->type == PTR_TO_PACKET) {\n\t\t\t/* R6=pkt(id=0,off=0,r=62) R7=imm22; r7 += r6 */\n\t\t\ttmp_reg = *dst_reg;  /* save r7 state */\n\t\t\t*dst_reg = *src_reg; /* copy pkt_ptr state r6 into r7 */\n\t\t\tsrc_reg = &tmp_reg;  /* pretend it's src_reg state */\n\t\t\t/* if the checks below reject it, the copy won't matter,\n\t\t\t * since we're rejecting the whole program. If all ok,\n\t\t\t * then imm22 state will be added to r7\n\t\t\t * and r7 will be pkt(id=0,off=22,r=62) while\n\t\t\t * r6 will stay as pkt(id=0,off=0,r=62)\n\t\t\t */\n\t\t}\n\n\t\tif (src_reg->type == CONST_IMM) {\n\t\t\t/* pkt_ptr += reg where reg is known constant */\n\t\t\timm = src_reg->imm;\n\t\t\tgoto add_imm;\n\t\t}\n\t\t/* disallow pkt_ptr += reg\n\t\t * if reg is not uknown_value with guaranteed zero upper bits\n\t\t * otherwise pkt_ptr may overflow and addition will become\n\t\t * subtraction which is not allowed\n\t\t */\n\t\tif (src_reg->type != UNKNOWN_VALUE) {\n\t\t\tverbose(\"cannot add '%s' to ptr_to_packet\\n\",\n\t\t\t\treg_type_str[src_reg->type]);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (src_reg->imm < 48) {\n\t\t\tverbose(\"cannot add integer value with %lld upper zero bits to ptr_to_packet\\n\",\n\t\t\t\tsrc_reg->imm);\n\t\t\treturn -EACCES;\n\t\t}\n\t\t/* dst_reg stays as pkt_ptr type and since some positive\n\t\t * integer value was added to the pointer, increment its 'id'\n\t\t */\n\t\tdst_reg->id = ++env->id_gen;\n\n\t\t/* something was added to pkt_ptr, set range and off to zero */\n\t\tdst_reg->off = 0;\n\t\tdst_reg->range = 0;\n\t}\n\treturn 0;\n}\n\nstatic int evaluate_reg_alu(struct bpf_verifier_env *env, struct bpf_insn *insn)\n{\n\tstruct bpf_reg_state *regs = env->cur_state.regs;\n\tstruct bpf_reg_state *dst_reg = &regs[insn->dst_reg];\n\tu8 opcode = BPF_OP(insn->code);\n\ts64 imm_log2;\n\n\t/* for type == UNKNOWN_VALUE:\n\t * imm > 0 -> number of zero upper bits\n\t * imm == 0 -> don't track which is the same as all bits can be non-zero\n\t */\n\n\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\tstruct bpf_reg_state *src_reg = &regs[insn->src_reg];\n\n\t\tif (src_reg->type == UNKNOWN_VALUE && src_reg->imm > 0 &&\n\t\t    dst_reg->imm && opcode == BPF_ADD) {\n\t\t\t/* dreg += sreg\n\t\t\t * where both have zero upper bits. Adding them\n\t\t\t * can only result making one more bit non-zero\n\t\t\t * in the larger value.\n\t\t\t * Ex. 0xffff (imm=48) + 1 (imm=63) = 0x10000 (imm=47)\n\t\t\t *     0xffff (imm=48) + 0xffff = 0x1fffe (imm=47)\n\t\t\t */\n\t\t\tdst_reg->imm = min(dst_reg->imm, src_reg->imm);\n\t\t\tdst_reg->imm--;\n\t\t\treturn 0;\n\t\t}\n\t\tif (src_reg->type == CONST_IMM && src_reg->imm > 0 &&\n\t\t    dst_reg->imm && opcode == BPF_ADD) {\n\t\t\t/* dreg += sreg\n\t\t\t * where dreg has zero upper bits and sreg is const.\n\t\t\t * Adding them can only result making one more bit\n\t\t\t * non-zero in the larger value.\n\t\t\t */\n\t\t\timm_log2 = __ilog2_u64((long long)src_reg->imm);\n\t\t\tdst_reg->imm = min(dst_reg->imm, 63 - imm_log2);\n\t\t\tdst_reg->imm--;\n\t\t\treturn 0;\n\t\t}\n\t\t/* all other cases non supported yet, just mark dst_reg */\n\t\tdst_reg->imm = 0;\n\t\treturn 0;\n\t}\n\n\t/* sign extend 32-bit imm into 64-bit to make sure that\n\t * negative values occupy bit 63. Note ilog2() would have\n\t * been incorrect, since sizeof(insn->imm) == 4\n\t */\n\timm_log2 = __ilog2_u64((long long)insn->imm);\n\n\tif (dst_reg->imm && opcode == BPF_LSH) {\n\t\t/* reg <<= imm\n\t\t * if reg was a result of 2 byte load, then its imm == 48\n\t\t * which means that upper 48 bits are zero and shifting this reg\n\t\t * left by 4 would mean that upper 44 bits are still zero\n\t\t */\n\t\tdst_reg->imm -= insn->imm;\n\t} else if (dst_reg->imm && opcode == BPF_MUL) {\n\t\t/* reg *= imm\n\t\t * if multiplying by 14 subtract 4\n\t\t * This is conservative calculation of upper zero bits.\n\t\t * It's not trying to special case insn->imm == 1 or 0 cases\n\t\t */\n\t\tdst_reg->imm -= imm_log2 + 1;\n\t} else if (opcode == BPF_AND) {\n\t\t/* reg &= imm */\n\t\tdst_reg->imm = 63 - imm_log2;\n\t} else if (dst_reg->imm && opcode == BPF_ADD) {\n\t\t/* reg += imm */\n\t\tdst_reg->imm = min(dst_reg->imm, 63 - imm_log2);\n\t\tdst_reg->imm--;\n\t} else if (opcode == BPF_RSH) {\n\t\t/* reg >>= imm\n\t\t * which means that after right shift, upper bits will be zero\n\t\t * note that verifier already checked that\n\t\t * 0 <= imm < 64 for shift insn\n\t\t */\n\t\tdst_reg->imm += insn->imm;\n\t\tif (unlikely(dst_reg->imm > 64))\n\t\t\t/* some dumb code did:\n\t\t\t * r2 = *(u32 *)mem;\n\t\t\t * r2 >>= 32;\n\t\t\t * and all bits are zero now */\n\t\t\tdst_reg->imm = 64;\n\t} else {\n\t\t/* all other alu ops, means that we don't know what will\n\t\t * happen to the value, mark it with unknown number of zero bits\n\t\t */\n\t\tdst_reg->imm = 0;\n\t}\n\n\tif (dst_reg->imm < 0) {\n\t\t/* all 64 bits of the register can contain non-zero bits\n\t\t * and such value cannot be added to ptr_to_packet, since it\n\t\t * may overflow, mark it as unknown to avoid further eval\n\t\t */\n\t\tdst_reg->imm = 0;\n\t}\n\treturn 0;\n}\n\nstatic int evaluate_reg_imm_alu(struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_insn *insn)\n{\n\tstruct bpf_reg_state *regs = env->cur_state.regs;\n\tstruct bpf_reg_state *dst_reg = &regs[insn->dst_reg];\n\tstruct bpf_reg_state *src_reg = &regs[insn->src_reg];\n\tu8 opcode = BPF_OP(insn->code);\n\tu64 dst_imm = dst_reg->imm;\n\n\t/* dst_reg->type == CONST_IMM here. Simulate execution of insns\n\t * containing ALU ops. Don't care about overflow or negative\n\t * values, just add/sub/... them; registers are in u64.\n\t */\n\tif (opcode == BPF_ADD && BPF_SRC(insn->code) == BPF_K) {\n\t\tdst_imm += insn->imm;\n\t} else if (opcode == BPF_ADD && BPF_SRC(insn->code) == BPF_X &&\n\t\t   src_reg->type == CONST_IMM) {\n\t\tdst_imm += src_reg->imm;\n\t} else if (opcode == BPF_SUB && BPF_SRC(insn->code) == BPF_K) {\n\t\tdst_imm -= insn->imm;\n\t} else if (opcode == BPF_SUB && BPF_SRC(insn->code) == BPF_X &&\n\t\t   src_reg->type == CONST_IMM) {\n\t\tdst_imm -= src_reg->imm;\n\t} else if (opcode == BPF_MUL && BPF_SRC(insn->code) == BPF_K) {\n\t\tdst_imm *= insn->imm;\n\t} else if (opcode == BPF_MUL && BPF_SRC(insn->code) == BPF_X &&\n\t\t   src_reg->type == CONST_IMM) {\n\t\tdst_imm *= src_reg->imm;\n\t} else if (opcode == BPF_OR && BPF_SRC(insn->code) == BPF_K) {\n\t\tdst_imm |= insn->imm;\n\t} else if (opcode == BPF_OR && BPF_SRC(insn->code) == BPF_X &&\n\t\t   src_reg->type == CONST_IMM) {\n\t\tdst_imm |= src_reg->imm;\n\t} else if (opcode == BPF_AND && BPF_SRC(insn->code) == BPF_K) {\n\t\tdst_imm &= insn->imm;\n\t} else if (opcode == BPF_AND && BPF_SRC(insn->code) == BPF_X &&\n\t\t   src_reg->type == CONST_IMM) {\n\t\tdst_imm &= src_reg->imm;\n\t} else if (opcode == BPF_RSH && BPF_SRC(insn->code) == BPF_K) {\n\t\tdst_imm >>= insn->imm;\n\t} else if (opcode == BPF_RSH && BPF_SRC(insn->code) == BPF_X &&\n\t\t   src_reg->type == CONST_IMM) {\n\t\tdst_imm >>= src_reg->imm;\n\t} else if (opcode == BPF_LSH && BPF_SRC(insn->code) == BPF_K) {\n\t\tdst_imm <<= insn->imm;\n\t} else if (opcode == BPF_LSH && BPF_SRC(insn->code) == BPF_X &&\n\t\t   src_reg->type == CONST_IMM) {\n\t\tdst_imm <<= src_reg->imm;\n\t} else {\n\t\tmark_reg_unknown_value(regs, insn->dst_reg);\n\t\tgoto out;\n\t}\n\n\tdst_reg->imm = dst_imm;\nout:\n\treturn 0;\n}\n\nstatic void check_reg_overflow(struct bpf_reg_state *reg)\n{\n\tif (reg->max_value > BPF_REGISTER_MAX_RANGE)\n\t\treg->max_value = BPF_REGISTER_MAX_RANGE;\n\tif (reg->min_value < BPF_REGISTER_MIN_RANGE ||\n\t    reg->min_value > BPF_REGISTER_MAX_RANGE)\n\t\treg->min_value = BPF_REGISTER_MIN_RANGE;\n}\n\nstatic void adjust_reg_min_max_vals(struct bpf_verifier_env *env,\n\t\t\t\t    struct bpf_insn *insn)\n{\n\tstruct bpf_reg_state *regs = env->cur_state.regs, *dst_reg;\n\ts64 min_val = BPF_REGISTER_MIN_RANGE;\n\tu64 max_val = BPF_REGISTER_MAX_RANGE;\n\tu8 opcode = BPF_OP(insn->code);\n\n\tdst_reg = &regs[insn->dst_reg];\n\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\tcheck_reg_overflow(&regs[insn->src_reg]);\n\t\tmin_val = regs[insn->src_reg].min_value;\n\t\tmax_val = regs[insn->src_reg].max_value;\n\n\t\t/* If the source register is a random pointer then the\n\t\t * min_value/max_value values represent the range of the known\n\t\t * accesses into that value, not the actual min/max value of the\n\t\t * register itself.  In this case we have to reset the reg range\n\t\t * values so we know it is not safe to look at.\n\t\t */\n\t\tif (regs[insn->src_reg].type != CONST_IMM &&\n\t\t    regs[insn->src_reg].type != UNKNOWN_VALUE) {\n\t\t\tmin_val = BPF_REGISTER_MIN_RANGE;\n\t\t\tmax_val = BPF_REGISTER_MAX_RANGE;\n\t\t}\n\t} else if (insn->imm < BPF_REGISTER_MAX_RANGE &&\n\t\t   (s64)insn->imm > BPF_REGISTER_MIN_RANGE) {\n\t\tmin_val = max_val = insn->imm;\n\t}\n\n\t/* We don't know anything about what was done to this register, mark it\n\t * as unknown.\n\t */\n\tif (min_val == BPF_REGISTER_MIN_RANGE &&\n\t    max_val == BPF_REGISTER_MAX_RANGE) {\n\t\treset_reg_range_values(regs, insn->dst_reg);\n\t\treturn;\n\t}\n\n\t/* If one of our values was at the end of our ranges then we can't just\n\t * do our normal operations to the register, we need to set the values\n\t * to the min/max since they are undefined.\n\t */\n\tif (min_val == BPF_REGISTER_MIN_RANGE)\n\t\tdst_reg->min_value = BPF_REGISTER_MIN_RANGE;\n\tif (max_val == BPF_REGISTER_MAX_RANGE)\n\t\tdst_reg->max_value = BPF_REGISTER_MAX_RANGE;\n\n\tswitch (opcode) {\n\tcase BPF_ADD:\n\t\tif (dst_reg->min_value != BPF_REGISTER_MIN_RANGE)\n\t\t\tdst_reg->min_value += min_val;\n\t\tif (dst_reg->max_value != BPF_REGISTER_MAX_RANGE)\n\t\t\tdst_reg->max_value += max_val;\n\t\tbreak;\n\tcase BPF_SUB:\n\t\tif (dst_reg->min_value != BPF_REGISTER_MIN_RANGE)\n\t\t\tdst_reg->min_value -= min_val;\n\t\tif (dst_reg->max_value != BPF_REGISTER_MAX_RANGE)\n\t\t\tdst_reg->max_value -= max_val;\n\t\tbreak;\n\tcase BPF_MUL:\n\t\tif (dst_reg->min_value != BPF_REGISTER_MIN_RANGE)\n\t\t\tdst_reg->min_value *= min_val;\n\t\tif (dst_reg->max_value != BPF_REGISTER_MAX_RANGE)\n\t\t\tdst_reg->max_value *= max_val;\n\t\tbreak;\n\tcase BPF_AND:\n\t\t/* Disallow AND'ing of negative numbers, ain't nobody got time\n\t\t * for that.  Otherwise the minimum is 0 and the max is the max\n\t\t * value we could AND against.\n\t\t */\n\t\tif (min_val < 0)\n\t\t\tdst_reg->min_value = BPF_REGISTER_MIN_RANGE;\n\t\telse\n\t\t\tdst_reg->min_value = 0;\n\t\tdst_reg->max_value = max_val;\n\t\tbreak;\n\tcase BPF_LSH:\n\t\t/* Gotta have special overflow logic here, if we're shifting\n\t\t * more than MAX_RANGE then just assume we have an invalid\n\t\t * range.\n\t\t */\n\t\tif (min_val > ilog2(BPF_REGISTER_MAX_RANGE))\n\t\t\tdst_reg->min_value = BPF_REGISTER_MIN_RANGE;\n\t\telse if (dst_reg->min_value != BPF_REGISTER_MIN_RANGE)\n\t\t\tdst_reg->min_value <<= min_val;\n\n\t\tif (max_val > ilog2(BPF_REGISTER_MAX_RANGE))\n\t\t\tdst_reg->max_value = BPF_REGISTER_MAX_RANGE;\n\t\telse if (dst_reg->max_value != BPF_REGISTER_MAX_RANGE)\n\t\t\tdst_reg->max_value <<= max_val;\n\t\tbreak;\n\tcase BPF_RSH:\n\t\t/* RSH by a negative number is undefined, and the BPF_RSH is an\n\t\t * unsigned shift, so make the appropriate casts.\n\t\t */\n\t\tif (min_val < 0 || dst_reg->min_value < 0)\n\t\t\tdst_reg->min_value = BPF_REGISTER_MIN_RANGE;\n\t\telse\n\t\t\tdst_reg->min_value =\n\t\t\t\t(u64)(dst_reg->min_value) >> min_val;\n\t\tif (dst_reg->max_value != BPF_REGISTER_MAX_RANGE)\n\t\t\tdst_reg->max_value >>= max_val;\n\t\tbreak;\n\tdefault:\n\t\treset_reg_range_values(regs, insn->dst_reg);\n\t\tbreak;\n\t}\n\n\tcheck_reg_overflow(dst_reg);\n}\n\n/* check validity of 32-bit and 64-bit arithmetic operations */\nstatic int check_alu_op(struct bpf_verifier_env *env, struct bpf_insn *insn)\n{\n\tstruct bpf_reg_state *regs = env->cur_state.regs, *dst_reg;\n\tu8 opcode = BPF_OP(insn->code);\n\tint err;\n\n\tif (opcode == BPF_END || opcode == BPF_NEG) {\n\t\tif (opcode == BPF_NEG) {\n\t\t\tif (BPF_SRC(insn->code) != 0 ||\n\t\t\t    insn->src_reg != BPF_REG_0 ||\n\t\t\t    insn->off != 0 || insn->imm != 0) {\n\t\t\t\tverbose(\"BPF_NEG uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0 ||\n\t\t\t    (insn->imm != 16 && insn->imm != 32 && insn->imm != 64)) {\n\t\t\t\tverbose(\"BPF_END uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check src operand */\n\t\terr = check_reg_arg(regs, insn->dst_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (is_pointer_value(env, insn->dst_reg)) {\n\t\t\tverbose(\"R%d pointer arithmetic prohibited\\n\",\n\t\t\t\tinsn->dst_reg);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\t/* check dest operand */\n\t\terr = check_reg_arg(regs, insn->dst_reg, DST_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t} else if (opcode == BPF_MOV) {\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (insn->imm != 0 || insn->off != 0) {\n\t\t\t\tverbose(\"BPF_MOV uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t/* check src operand */\n\t\t\terr = check_reg_arg(regs, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0) {\n\t\t\t\tverbose(\"BPF_MOV uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check dest operand */\n\t\terr = check_reg_arg(regs, insn->dst_reg, DST_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t/* we are setting our register to something new, we need to\n\t\t * reset its range values.\n\t\t */\n\t\treset_reg_range_values(regs, insn->dst_reg);\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64) {\n\t\t\t\t/* case: R1 = R2\n\t\t\t\t * copy register state to dest reg\n\t\t\t\t */\n\t\t\t\tregs[insn->dst_reg] = regs[insn->src_reg];\n\t\t\t} else {\n\t\t\t\tif (is_pointer_value(env, insn->src_reg)) {\n\t\t\t\t\tverbose(\"R%d partial copy of pointer\\n\",\n\t\t\t\t\t\tinsn->src_reg);\n\t\t\t\t\treturn -EACCES;\n\t\t\t\t}\n\t\t\t\tmark_reg_unknown_value(regs, insn->dst_reg);\n\t\t\t}\n\t\t} else {\n\t\t\t/* case: R = imm\n\t\t\t * remember the value we stored into this reg\n\t\t\t */\n\t\t\tregs[insn->dst_reg].type = CONST_IMM;\n\t\t\tregs[insn->dst_reg].imm = insn->imm;\n\t\t\tregs[insn->dst_reg].max_value = insn->imm;\n\t\t\tregs[insn->dst_reg].min_value = insn->imm;\n\t\t}\n\n\t} else if (opcode > BPF_END) {\n\t\tverbose(\"invalid BPF_ALU opcode %x\\n\", opcode);\n\t\treturn -EINVAL;\n\n\t} else {\t/* all other ALU ops: and, sub, xor, add, ... */\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (insn->imm != 0 || insn->off != 0) {\n\t\t\t\tverbose(\"BPF_ALU uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t/* check src1 operand */\n\t\t\terr = check_reg_arg(regs, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0) {\n\t\t\t\tverbose(\"BPF_ALU uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check src2 operand */\n\t\terr = check_reg_arg(regs, insn->dst_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif ((opcode == BPF_MOD || opcode == BPF_DIV) &&\n\t\t    BPF_SRC(insn->code) == BPF_K && insn->imm == 0) {\n\t\t\tverbose(\"div by zero\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif ((opcode == BPF_LSH || opcode == BPF_RSH ||\n\t\t     opcode == BPF_ARSH) && BPF_SRC(insn->code) == BPF_K) {\n\t\t\tint size = BPF_CLASS(insn->code) == BPF_ALU64 ? 64 : 32;\n\n\t\t\tif (insn->imm < 0 || insn->imm >= size) {\n\t\t\t\tverbose(\"invalid shift %d\\n\", insn->imm);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check dest operand */\n\t\terr = check_reg_arg(regs, insn->dst_reg, DST_OP_NO_MARK);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tdst_reg = &regs[insn->dst_reg];\n\n\t\t/* first we want to adjust our ranges. */\n\t\tadjust_reg_min_max_vals(env, insn);\n\n\t\t/* pattern match 'bpf_add Rx, imm' instruction */\n\t\tif (opcode == BPF_ADD && BPF_CLASS(insn->code) == BPF_ALU64 &&\n\t\t    dst_reg->type == FRAME_PTR && BPF_SRC(insn->code) == BPF_K) {\n\t\t\tdst_reg->type = PTR_TO_STACK;\n\t\t\tdst_reg->imm = insn->imm;\n\t\t\treturn 0;\n\t\t} else if (opcode == BPF_ADD &&\n\t\t\t   BPF_CLASS(insn->code) == BPF_ALU64 &&\n\t\t\t   dst_reg->type == PTR_TO_STACK &&\n\t\t\t   ((BPF_SRC(insn->code) == BPF_X &&\n\t\t\t     regs[insn->src_reg].type == CONST_IMM) ||\n\t\t\t    BPF_SRC(insn->code) == BPF_K)) {\n\t\t\tif (BPF_SRC(insn->code) == BPF_X)\n\t\t\t\tdst_reg->imm += regs[insn->src_reg].imm;\n\t\t\telse\n\t\t\t\tdst_reg->imm += insn->imm;\n\t\t\treturn 0;\n\t\t} else if (opcode == BPF_ADD &&\n\t\t\t   BPF_CLASS(insn->code) == BPF_ALU64 &&\n\t\t\t   (dst_reg->type == PTR_TO_PACKET ||\n\t\t\t    (BPF_SRC(insn->code) == BPF_X &&\n\t\t\t     regs[insn->src_reg].type == PTR_TO_PACKET))) {\n\t\t\t/* ptr_to_packet += K|X */\n\t\t\treturn check_packet_ptr_add(env, insn);\n\t\t} else if (BPF_CLASS(insn->code) == BPF_ALU64 &&\n\t\t\t   dst_reg->type == UNKNOWN_VALUE &&\n\t\t\t   env->allow_ptr_leaks) {\n\t\t\t/* unknown += K|X */\n\t\t\treturn evaluate_reg_alu(env, insn);\n\t\t} else if (BPF_CLASS(insn->code) == BPF_ALU64 &&\n\t\t\t   dst_reg->type == CONST_IMM &&\n\t\t\t   env->allow_ptr_leaks) {\n\t\t\t/* reg_imm += K|X */\n\t\t\treturn evaluate_reg_imm_alu(env, insn);\n\t\t} else if (is_pointer_value(env, insn->dst_reg)) {\n\t\t\tverbose(\"R%d pointer arithmetic prohibited\\n\",\n\t\t\t\tinsn->dst_reg);\n\t\t\treturn -EACCES;\n\t\t} else if (BPF_SRC(insn->code) == BPF_X &&\n\t\t\t   is_pointer_value(env, insn->src_reg)) {\n\t\t\tverbose(\"R%d pointer arithmetic prohibited\\n\",\n\t\t\t\tinsn->src_reg);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\t/* If we did pointer math on a map value then just set it to our\n\t\t * PTR_TO_MAP_VALUE_ADJ type so we can deal with any stores or\n\t\t * loads to this register appropriately, otherwise just mark the\n\t\t * register as unknown.\n\t\t */\n\t\tif (env->allow_ptr_leaks &&\n\t\t    BPF_CLASS(insn->code) == BPF_ALU64 && opcode == BPF_ADD &&\n\t\t    (dst_reg->type == PTR_TO_MAP_VALUE ||\n\t\t     dst_reg->type == PTR_TO_MAP_VALUE_ADJ))\n\t\t\tdst_reg->type = PTR_TO_MAP_VALUE_ADJ;\n\t\telse\n\t\t\tmark_reg_unknown_value(regs, insn->dst_reg);\n\t}\n\n\treturn 0;\n}\n\nstatic void find_good_pkt_pointers(struct bpf_verifier_state *state,\n\t\t\t\t   struct bpf_reg_state *dst_reg)\n{\n\tstruct bpf_reg_state *regs = state->regs, *reg;\n\tint i;\n\n\t/* LLVM can generate two kind of checks:\n\t *\n\t * Type 1:\n\t *\n\t *   r2 = r3;\n\t *   r2 += 8;\n\t *   if (r2 > pkt_end) goto <handle exception>\n\t *   <access okay>\n\t *\n\t *   Where:\n\t *     r2 == dst_reg, pkt_end == src_reg\n\t *     r2=pkt(id=n,off=8,r=0)\n\t *     r3=pkt(id=n,off=0,r=0)\n\t *\n\t * Type 2:\n\t *\n\t *   r2 = r3;\n\t *   r2 += 8;\n\t *   if (pkt_end >= r2) goto <access okay>\n\t *   <handle exception>\n\t *\n\t *   Where:\n\t *     pkt_end == dst_reg, r2 == src_reg\n\t *     r2=pkt(id=n,off=8,r=0)\n\t *     r3=pkt(id=n,off=0,r=0)\n\t *\n\t * Find register r3 and mark its range as r3=pkt(id=n,off=0,r=8)\n\t * so that range of bytes [r3, r3 + 8) is safe to access.\n\t */\n\n\tfor (i = 0; i < MAX_BPF_REG; i++)\n\t\tif (regs[i].type == PTR_TO_PACKET && regs[i].id == dst_reg->id)\n\t\t\t/* keep the maximum range already checked */\n\t\t\tregs[i].range = max(regs[i].range, dst_reg->off);\n\n\tfor (i = 0; i < MAX_BPF_STACK; i += BPF_REG_SIZE) {\n\t\tif (state->stack_slot_type[i] != STACK_SPILL)\n\t\t\tcontinue;\n\t\treg = &state->spilled_regs[i / BPF_REG_SIZE];\n\t\tif (reg->type == PTR_TO_PACKET && reg->id == dst_reg->id)\n\t\t\treg->range = max(reg->range, dst_reg->off);\n\t}\n}\n\n/* Adjusts the register min/max values in the case that the dst_reg is the\n * variable register that we are working on, and src_reg is a constant or we're\n * simply doing a BPF_K check.\n */\nstatic void reg_set_min_max(struct bpf_reg_state *true_reg,\n\t\t\t    struct bpf_reg_state *false_reg, u64 val,\n\t\t\t    u8 opcode)\n{\n\tswitch (opcode) {\n\tcase BPF_JEQ:\n\t\t/* If this is false then we know nothing Jon Snow, but if it is\n\t\t * true then we know for sure.\n\t\t */\n\t\ttrue_reg->max_value = true_reg->min_value = val;\n\t\tbreak;\n\tcase BPF_JNE:\n\t\t/* If this is true we know nothing Jon Snow, but if it is false\n\t\t * we know the value for sure;\n\t\t */\n\t\tfalse_reg->max_value = false_reg->min_value = val;\n\t\tbreak;\n\tcase BPF_JGT:\n\t\t/* Unsigned comparison, the minimum value is 0. */\n\t\tfalse_reg->min_value = 0;\n\t\t/* fallthrough */\n\tcase BPF_JSGT:\n\t\t/* If this is false then we know the maximum val is val,\n\t\t * otherwise we know the min val is val+1.\n\t\t */\n\t\tfalse_reg->max_value = val;\n\t\ttrue_reg->min_value = val + 1;\n\t\tbreak;\n\tcase BPF_JGE:\n\t\t/* Unsigned comparison, the minimum value is 0. */\n\t\tfalse_reg->min_value = 0;\n\t\t/* fallthrough */\n\tcase BPF_JSGE:\n\t\t/* If this is false then we know the maximum value is val - 1,\n\t\t * otherwise we know the mimimum value is val.\n\t\t */\n\t\tfalse_reg->max_value = val - 1;\n\t\ttrue_reg->min_value = val;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tcheck_reg_overflow(false_reg);\n\tcheck_reg_overflow(true_reg);\n}\n\n/* Same as above, but for the case that dst_reg is a CONST_IMM reg and src_reg\n * is the variable reg.\n */\nstatic void reg_set_min_max_inv(struct bpf_reg_state *true_reg,\n\t\t\t\tstruct bpf_reg_state *false_reg, u64 val,\n\t\t\t\tu8 opcode)\n{\n\tswitch (opcode) {\n\tcase BPF_JEQ:\n\t\t/* If this is false then we know nothing Jon Snow, but if it is\n\t\t * true then we know for sure.\n\t\t */\n\t\ttrue_reg->max_value = true_reg->min_value = val;\n\t\tbreak;\n\tcase BPF_JNE:\n\t\t/* If this is true we know nothing Jon Snow, but if it is false\n\t\t * we know the value for sure;\n\t\t */\n\t\tfalse_reg->max_value = false_reg->min_value = val;\n\t\tbreak;\n\tcase BPF_JGT:\n\t\t/* Unsigned comparison, the minimum value is 0. */\n\t\ttrue_reg->min_value = 0;\n\t\t/* fallthrough */\n\tcase BPF_JSGT:\n\t\t/*\n\t\t * If this is false, then the val is <= the register, if it is\n\t\t * true the register <= to the val.\n\t\t */\n\t\tfalse_reg->min_value = val;\n\t\ttrue_reg->max_value = val - 1;\n\t\tbreak;\n\tcase BPF_JGE:\n\t\t/* Unsigned comparison, the minimum value is 0. */\n\t\ttrue_reg->min_value = 0;\n\t\t/* fallthrough */\n\tcase BPF_JSGE:\n\t\t/* If this is false then constant < register, if it is true then\n\t\t * the register < constant.\n\t\t */\n\t\tfalse_reg->min_value = val + 1;\n\t\ttrue_reg->max_value = val;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tcheck_reg_overflow(false_reg);\n\tcheck_reg_overflow(true_reg);\n}\n\nstatic void mark_map_reg(struct bpf_reg_state *regs, u32 regno, u32 id,\n\t\t\t enum bpf_reg_type type)\n{\n\tstruct bpf_reg_state *reg = &regs[regno];\n\n\tif (reg->type == PTR_TO_MAP_VALUE_OR_NULL && reg->id == id) {\n\t\tif (type == UNKNOWN_VALUE) {\n\t\t\t__mark_reg_unknown_value(regs, regno);\n\t\t} else if (reg->map_ptr->inner_map_meta) {\n\t\t\treg->type = CONST_PTR_TO_MAP;\n\t\t\treg->map_ptr = reg->map_ptr->inner_map_meta;\n\t\t} else {\n\t\t\treg->type = type;\n\t\t}\n\t\t/* We don't need id from this point onwards anymore, thus we\n\t\t * should better reset it, so that state pruning has chances\n\t\t * to take effect.\n\t\t */\n\t\treg->id = 0;\n\t}\n}\n\n/* The logic is similar to find_good_pkt_pointers(), both could eventually\n * be folded together at some point.\n */\nstatic void mark_map_regs(struct bpf_verifier_state *state, u32 regno,\n\t\t\t  enum bpf_reg_type type)\n{\n\tstruct bpf_reg_state *regs = state->regs;\n\tu32 id = regs[regno].id;\n\tint i;\n\n\tfor (i = 0; i < MAX_BPF_REG; i++)\n\t\tmark_map_reg(regs, i, id, type);\n\n\tfor (i = 0; i < MAX_BPF_STACK; i += BPF_REG_SIZE) {\n\t\tif (state->stack_slot_type[i] != STACK_SPILL)\n\t\t\tcontinue;\n\t\tmark_map_reg(state->spilled_regs, i / BPF_REG_SIZE, id, type);\n\t}\n}\n\nstatic int check_cond_jmp_op(struct bpf_verifier_env *env,\n\t\t\t     struct bpf_insn *insn, int *insn_idx)\n{\n\tstruct bpf_verifier_state *other_branch, *this_branch = &env->cur_state;\n\tstruct bpf_reg_state *regs = this_branch->regs, *dst_reg;\n\tu8 opcode = BPF_OP(insn->code);\n\tint err;\n\n\tif (opcode > BPF_EXIT) {\n\t\tverbose(\"invalid BPF_JMP opcode %x\\n\", opcode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\tif (insn->imm != 0) {\n\t\t\tverbose(\"BPF_JMP uses reserved fields\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* check src1 operand */\n\t\terr = check_reg_arg(regs, insn->src_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (is_pointer_value(env, insn->src_reg)) {\n\t\t\tverbose(\"R%d pointer comparison prohibited\\n\",\n\t\t\t\tinsn->src_reg);\n\t\t\treturn -EACCES;\n\t\t}\n\t} else {\n\t\tif (insn->src_reg != BPF_REG_0) {\n\t\t\tverbose(\"BPF_JMP uses reserved fields\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* check src2 operand */\n\terr = check_reg_arg(regs, insn->dst_reg, SRC_OP);\n\tif (err)\n\t\treturn err;\n\n\tdst_reg = &regs[insn->dst_reg];\n\n\t/* detect if R == 0 where R was initialized to zero earlier */\n\tif (BPF_SRC(insn->code) == BPF_K &&\n\t    (opcode == BPF_JEQ || opcode == BPF_JNE) &&\n\t    dst_reg->type == CONST_IMM && dst_reg->imm == insn->imm) {\n\t\tif (opcode == BPF_JEQ) {\n\t\t\t/* if (imm == imm) goto pc+off;\n\t\t\t * only follow the goto, ignore fall-through\n\t\t\t */\n\t\t\t*insn_idx += insn->off;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/* if (imm != imm) goto pc+off;\n\t\t\t * only follow fall-through branch, since\n\t\t\t * that's where the program will go\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tother_branch = push_stack(env, *insn_idx + insn->off + 1, *insn_idx);\n\tif (!other_branch)\n\t\treturn -EFAULT;\n\n\t/* detect if we are comparing against a constant value so we can adjust\n\t * our min/max values for our dst register.\n\t */\n\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\tif (regs[insn->src_reg].type == CONST_IMM)\n\t\t\treg_set_min_max(&other_branch->regs[insn->dst_reg],\n\t\t\t\t\tdst_reg, regs[insn->src_reg].imm,\n\t\t\t\t\topcode);\n\t\telse if (dst_reg->type == CONST_IMM)\n\t\t\treg_set_min_max_inv(&other_branch->regs[insn->src_reg],\n\t\t\t\t\t    &regs[insn->src_reg], dst_reg->imm,\n\t\t\t\t\t    opcode);\n\t} else {\n\t\treg_set_min_max(&other_branch->regs[insn->dst_reg],\n\t\t\t\t\tdst_reg, insn->imm, opcode);\n\t}\n\n\t/* detect if R == 0 where R is returned from bpf_map_lookup_elem() */\n\tif (BPF_SRC(insn->code) == BPF_K &&\n\t    insn->imm == 0 && (opcode == BPF_JEQ || opcode == BPF_JNE) &&\n\t    dst_reg->type == PTR_TO_MAP_VALUE_OR_NULL) {\n\t\t/* Mark all identical map registers in each branch as either\n\t\t * safe or unknown depending R == 0 or R != 0 conditional.\n\t\t */\n\t\tmark_map_regs(this_branch, insn->dst_reg,\n\t\t\t      opcode == BPF_JEQ ? PTR_TO_MAP_VALUE : UNKNOWN_VALUE);\n\t\tmark_map_regs(other_branch, insn->dst_reg,\n\t\t\t      opcode == BPF_JEQ ? UNKNOWN_VALUE : PTR_TO_MAP_VALUE);\n\t} else if (BPF_SRC(insn->code) == BPF_X && opcode == BPF_JGT &&\n\t\t   dst_reg->type == PTR_TO_PACKET &&\n\t\t   regs[insn->src_reg].type == PTR_TO_PACKET_END) {\n\t\tfind_good_pkt_pointers(this_branch, dst_reg);\n\t} else if (BPF_SRC(insn->code) == BPF_X && opcode == BPF_JGE &&\n\t\t   dst_reg->type == PTR_TO_PACKET_END &&\n\t\t   regs[insn->src_reg].type == PTR_TO_PACKET) {\n\t\tfind_good_pkt_pointers(other_branch, &regs[insn->src_reg]);\n\t} else if (is_pointer_value(env, insn->dst_reg)) {\n\t\tverbose(\"R%d pointer comparison prohibited\\n\", insn->dst_reg);\n\t\treturn -EACCES;\n\t}\n\tif (log_level)\n\t\tprint_verifier_state(this_branch);\n\treturn 0;\n}\n\n/* return the map pointer stored inside BPF_LD_IMM64 instruction */\nstatic struct bpf_map *ld_imm64_to_map_ptr(struct bpf_insn *insn)\n{\n\tu64 imm64 = ((u64) (u32) insn[0].imm) | ((u64) (u32) insn[1].imm) << 32;\n\n\treturn (struct bpf_map *) (unsigned long) imm64;\n}\n\n/* verify BPF_LD_IMM64 instruction */\nstatic int check_ld_imm(struct bpf_verifier_env *env, struct bpf_insn *insn)\n{\n\tstruct bpf_reg_state *regs = env->cur_state.regs;\n\tint err;\n\n\tif (BPF_SIZE(insn->code) != BPF_DW) {\n\t\tverbose(\"invalid BPF_LD_IMM insn\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (insn->off != 0) {\n\t\tverbose(\"BPF_LD_IMM64 uses reserved fields\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = check_reg_arg(regs, insn->dst_reg, DST_OP);\n\tif (err)\n\t\treturn err;\n\n\tif (insn->src_reg == 0) {\n\t\tu64 imm = ((u64)(insn + 1)->imm << 32) | (u32)insn->imm;\n\n\t\tregs[insn->dst_reg].type = CONST_IMM;\n\t\tregs[insn->dst_reg].imm = imm;\n\t\treturn 0;\n\t}\n\n\t/* replace_map_fd_with_map_ptr() should have caught bad ld_imm64 */\n\tBUG_ON(insn->src_reg != BPF_PSEUDO_MAP_FD);\n\n\tregs[insn->dst_reg].type = CONST_PTR_TO_MAP;\n\tregs[insn->dst_reg].map_ptr = ld_imm64_to_map_ptr(insn);\n\treturn 0;\n}\n\nstatic bool may_access_skb(enum bpf_prog_type type)\n{\n\tswitch (type) {\n\tcase BPF_PROG_TYPE_SOCKET_FILTER:\n\tcase BPF_PROG_TYPE_SCHED_CLS:\n\tcase BPF_PROG_TYPE_SCHED_ACT:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n/* verify safety of LD_ABS|LD_IND instructions:\n * - they can only appear in the programs where ctx == skb\n * - since they are wrappers of function calls, they scratch R1-R5 registers,\n *   preserve R6-R9, and store return value into R0\n *\n * Implicit input:\n *   ctx == skb == R6 == CTX\n *\n * Explicit input:\n *   SRC == any register\n *   IMM == 32-bit immediate\n *\n * Output:\n *   R0 - 8/16/32-bit skb data converted to cpu endianness\n */\nstatic int check_ld_abs(struct bpf_verifier_env *env, struct bpf_insn *insn)\n{\n\tstruct bpf_reg_state *regs = env->cur_state.regs;\n\tu8 mode = BPF_MODE(insn->code);\n\tstruct bpf_reg_state *reg;\n\tint i, err;\n\n\tif (!may_access_skb(env->prog->type)) {\n\t\tverbose(\"BPF_LD_[ABS|IND] instructions not allowed for this program type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (insn->dst_reg != BPF_REG_0 || insn->off != 0 ||\n\t    BPF_SIZE(insn->code) == BPF_DW ||\n\t    (mode == BPF_ABS && insn->src_reg != BPF_REG_0)) {\n\t\tverbose(\"BPF_LD_[ABS|IND] uses reserved fields\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* check whether implicit source operand (register R6) is readable */\n\terr = check_reg_arg(regs, BPF_REG_6, SRC_OP);\n\tif (err)\n\t\treturn err;\n\n\tif (regs[BPF_REG_6].type != PTR_TO_CTX) {\n\t\tverbose(\"at the time of BPF_LD_ABS|IND R6 != pointer to skb\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (mode == BPF_IND) {\n\t\t/* check explicit source operand */\n\t\terr = check_reg_arg(regs, insn->src_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t/* reset caller saved regs to unreadable */\n\tfor (i = 0; i < CALLER_SAVED_REGS; i++) {\n\t\treg = regs + caller_saved[i];\n\t\treg->type = NOT_INIT;\n\t\treg->imm = 0;\n\t}\n\n\t/* mark destination R0 register as readable, since it contains\n\t * the value fetched from the packet\n\t */\n\tregs[BPF_REG_0].type = UNKNOWN_VALUE;\n\treturn 0;\n}\n\n/* non-recursive DFS pseudo code\n * 1  procedure DFS-iterative(G,v):\n * 2      label v as discovered\n * 3      let S be a stack\n * 4      S.push(v)\n * 5      while S is not empty\n * 6            t <- S.pop()\n * 7            if t is what we're looking for:\n * 8                return t\n * 9            for all edges e in G.adjacentEdges(t) do\n * 10               if edge e is already labelled\n * 11                   continue with the next edge\n * 12               w <- G.adjacentVertex(t,e)\n * 13               if vertex w is not discovered and not explored\n * 14                   label e as tree-edge\n * 15                   label w as discovered\n * 16                   S.push(w)\n * 17                   continue at 5\n * 18               else if vertex w is discovered\n * 19                   label e as back-edge\n * 20               else\n * 21                   // vertex w is explored\n * 22                   label e as forward- or cross-edge\n * 23           label t as explored\n * 24           S.pop()\n *\n * convention:\n * 0x10 - discovered\n * 0x11 - discovered and fall-through edge labelled\n * 0x12 - discovered and fall-through and branch edges labelled\n * 0x20 - explored\n */\n\nenum {\n\tDISCOVERED = 0x10,\n\tEXPLORED = 0x20,\n\tFALLTHROUGH = 1,\n\tBRANCH = 2,\n};\n\n#define STATE_LIST_MARK ((struct bpf_verifier_state_list *) -1L)\n\nstatic int *insn_stack;\t/* stack of insns to process */\nstatic int cur_stack;\t/* current stack index */\nstatic int *insn_state;\n\n/* t, w, e - match pseudo-code above:\n * t - index of current instruction\n * w - next instruction\n * e - edge\n */\nstatic int push_insn(int t, int w, int e, struct bpf_verifier_env *env)\n{\n\tif (e == FALLTHROUGH && insn_state[t] >= (DISCOVERED | FALLTHROUGH))\n\t\treturn 0;\n\n\tif (e == BRANCH && insn_state[t] >= (DISCOVERED | BRANCH))\n\t\treturn 0;\n\n\tif (w < 0 || w >= env->prog->len) {\n\t\tverbose(\"jump out of range from insn %d to %d\\n\", t, w);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e == BRANCH)\n\t\t/* mark branch target for state pruning */\n\t\tenv->explored_states[w] = STATE_LIST_MARK;\n\n\tif (insn_state[w] == 0) {\n\t\t/* tree-edge */\n\t\tinsn_state[t] = DISCOVERED | e;\n\t\tinsn_state[w] = DISCOVERED;\n\t\tif (cur_stack >= env->prog->len)\n\t\t\treturn -E2BIG;\n\t\tinsn_stack[cur_stack++] = w;\n\t\treturn 1;\n\t} else if ((insn_state[w] & 0xF0) == DISCOVERED) {\n\t\tverbose(\"back-edge from insn %d to %d\\n\", t, w);\n\t\treturn -EINVAL;\n\t} else if (insn_state[w] == EXPLORED) {\n\t\t/* forward- or cross-edge */\n\t\tinsn_state[t] = DISCOVERED | e;\n\t} else {\n\t\tverbose(\"insn state internal bug\\n\");\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\n/* non-recursive depth-first-search to detect loops in BPF program\n * loop == back-edge in directed graph\n */\nstatic int check_cfg(struct bpf_verifier_env *env)\n{\n\tstruct bpf_insn *insns = env->prog->insnsi;\n\tint insn_cnt = env->prog->len;\n\tint ret = 0;\n\tint i, t;\n\n\tinsn_state = kcalloc(insn_cnt, sizeof(int), GFP_KERNEL);\n\tif (!insn_state)\n\t\treturn -ENOMEM;\n\n\tinsn_stack = kcalloc(insn_cnt, sizeof(int), GFP_KERNEL);\n\tif (!insn_stack) {\n\t\tkfree(insn_state);\n\t\treturn -ENOMEM;\n\t}\n\n\tinsn_state[0] = DISCOVERED; /* mark 1st insn as discovered */\n\tinsn_stack[0] = 0; /* 0 is the first instruction */\n\tcur_stack = 1;\n\npeek_stack:\n\tif (cur_stack == 0)\n\t\tgoto check_state;\n\tt = insn_stack[cur_stack - 1];\n\n\tif (BPF_CLASS(insns[t].code) == BPF_JMP) {\n\t\tu8 opcode = BPF_OP(insns[t].code);\n\n\t\tif (opcode == BPF_EXIT) {\n\t\t\tgoto mark_explored;\n\t\t} else if (opcode == BPF_CALL) {\n\t\t\tret = push_insn(t, t + 1, FALLTHROUGH, env);\n\t\t\tif (ret == 1)\n\t\t\t\tgoto peek_stack;\n\t\t\telse if (ret < 0)\n\t\t\t\tgoto err_free;\n\t\t\tif (t + 1 < insn_cnt)\n\t\t\t\tenv->explored_states[t + 1] = STATE_LIST_MARK;\n\t\t} else if (opcode == BPF_JA) {\n\t\t\tif (BPF_SRC(insns[t].code) != BPF_K) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err_free;\n\t\t\t}\n\t\t\t/* unconditional jump with single edge */\n\t\t\tret = push_insn(t, t + insns[t].off + 1,\n\t\t\t\t\tFALLTHROUGH, env);\n\t\t\tif (ret == 1)\n\t\t\t\tgoto peek_stack;\n\t\t\telse if (ret < 0)\n\t\t\t\tgoto err_free;\n\t\t\t/* tell verifier to check for equivalent states\n\t\t\t * after every call and jump\n\t\t\t */\n\t\t\tif (t + 1 < insn_cnt)\n\t\t\t\tenv->explored_states[t + 1] = STATE_LIST_MARK;\n\t\t} else {\n\t\t\t/* conditional jump with two edges */\n\t\t\tret = push_insn(t, t + 1, FALLTHROUGH, env);\n\t\t\tif (ret == 1)\n\t\t\t\tgoto peek_stack;\n\t\t\telse if (ret < 0)\n\t\t\t\tgoto err_free;\n\n\t\t\tret = push_insn(t, t + insns[t].off + 1, BRANCH, env);\n\t\t\tif (ret == 1)\n\t\t\t\tgoto peek_stack;\n\t\t\telse if (ret < 0)\n\t\t\t\tgoto err_free;\n\t\t}\n\t} else {\n\t\t/* all other non-branch instructions with single\n\t\t * fall-through edge\n\t\t */\n\t\tret = push_insn(t, t + 1, FALLTHROUGH, env);\n\t\tif (ret == 1)\n\t\t\tgoto peek_stack;\n\t\telse if (ret < 0)\n\t\t\tgoto err_free;\n\t}\n\nmark_explored:\n\tinsn_state[t] = EXPLORED;\n\tif (cur_stack-- <= 0) {\n\t\tverbose(\"pop stack internal bug\\n\");\n\t\tret = -EFAULT;\n\t\tgoto err_free;\n\t}\n\tgoto peek_stack;\n\ncheck_state:\n\tfor (i = 0; i < insn_cnt; i++) {\n\t\tif (insn_state[i] != EXPLORED) {\n\t\t\tverbose(\"unreachable insn %d\\n\", i);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_free;\n\t\t}\n\t}\n\tret = 0; /* cfg looks good */\n\nerr_free:\n\tkfree(insn_state);\n\tkfree(insn_stack);\n\treturn ret;\n}\n\n/* the following conditions reduce the number of explored insns\n * from ~140k to ~80k for ultra large programs that use a lot of ptr_to_packet\n */\nstatic bool compare_ptrs_to_packet(struct bpf_reg_state *old,\n\t\t\t\t   struct bpf_reg_state *cur)\n{\n\tif (old->id != cur->id)\n\t\treturn false;\n\n\t/* old ptr_to_packet is more conservative, since it allows smaller\n\t * range. Ex:\n\t * old(off=0,r=10) is equal to cur(off=0,r=20), because\n\t * old(off=0,r=10) means that with range=10 the verifier proceeded\n\t * further and found no issues with the program. Now we're in the same\n\t * spot with cur(off=0,r=20), so we're safe too, since anything further\n\t * will only be looking at most 10 bytes after this pointer.\n\t */\n\tif (old->off == cur->off && old->range < cur->range)\n\t\treturn true;\n\n\t/* old(off=20,r=10) is equal to cur(off=22,re=22 or 5 or 0)\n\t * since both cannot be used for packet access and safe(old)\n\t * pointer has smaller off that could be used for further\n\t * 'if (ptr > data_end)' check\n\t * Ex:\n\t * old(off=20,r=10) and cur(off=22,r=22) and cur(off=22,r=0) mean\n\t * that we cannot access the packet.\n\t * The safe range is:\n\t * [ptr, ptr + range - off)\n\t * so whenever off >=range, it means no safe bytes from this pointer.\n\t * When comparing old->off <= cur->off, it means that older code\n\t * went with smaller offset and that offset was later\n\t * used to figure out the safe range after 'if (ptr > data_end)' check\n\t * Say, 'old' state was explored like:\n\t * ... R3(off=0, r=0)\n\t * R4 = R3 + 20\n\t * ... now R4(off=20,r=0)  <-- here\n\t * if (R4 > data_end)\n\t * ... R4(off=20,r=20), R3(off=0,r=20) and R3 can be used to access.\n\t * ... the code further went all the way to bpf_exit.\n\t * Now the 'cur' state at the mark 'here' has R4(off=30,r=0).\n\t * old_R4(off=20,r=0) equal to cur_R4(off=30,r=0), since if the verifier\n\t * goes further, such cur_R4 will give larger safe packet range after\n\t * 'if (R4 > data_end)' and all further insn were already good with r=20,\n\t * so they will be good with r=30 and we can prune the search.\n\t */\n\tif (old->off <= cur->off &&\n\t    old->off >= old->range && cur->off >= cur->range)\n\t\treturn true;\n\n\treturn false;\n}\n\n/* compare two verifier states\n *\n * all states stored in state_list are known to be valid, since\n * verifier reached 'bpf_exit' instruction through them\n *\n * this function is called when verifier exploring different branches of\n * execution popped from the state stack. If it sees an old state that has\n * more strict register state and more strict stack state then this execution\n * branch doesn't need to be explored further, since verifier already\n * concluded that more strict state leads to valid finish.\n *\n * Therefore two states are equivalent if register state is more conservative\n * and explored stack state is more conservative than the current one.\n * Example:\n *       explored                   current\n * (slot1=INV slot2=MISC) == (slot1=MISC slot2=MISC)\n * (slot1=MISC slot2=MISC) != (slot1=INV slot2=MISC)\n *\n * In other words if current stack state (one being explored) has more\n * valid slots than old one that already passed validation, it means\n * the verifier can stop exploring and conclude that current state is valid too\n *\n * Similarly with registers. If explored state has register type as invalid\n * whereas register type in current state is meaningful, it means that\n * the current state will reach 'bpf_exit' instruction safely\n */\nstatic bool states_equal(struct bpf_verifier_env *env,\n\t\t\t struct bpf_verifier_state *old,\n\t\t\t struct bpf_verifier_state *cur)\n{\n\tbool varlen_map_access = env->varlen_map_value_access;\n\tstruct bpf_reg_state *rold, *rcur;\n\tint i;\n\n\tfor (i = 0; i < MAX_BPF_REG; i++) {\n\t\trold = &old->regs[i];\n\t\trcur = &cur->regs[i];\n\n\t\tif (memcmp(rold, rcur, sizeof(*rold)) == 0)\n\t\t\tcontinue;\n\n\t\t/* If the ranges were not the same, but everything else was and\n\t\t * we didn't do a variable access into a map then we are a-ok.\n\t\t */\n\t\tif (!varlen_map_access &&\n\t\t    memcmp(rold, rcur, offsetofend(struct bpf_reg_state, id)) == 0)\n\t\t\tcontinue;\n\n\t\t/* If we didn't map access then again we don't care about the\n\t\t * mismatched range values and it's ok if our old type was\n\t\t * UNKNOWN and we didn't go to a NOT_INIT'ed reg.\n\t\t */\n\t\tif (rold->type == NOT_INIT ||\n\t\t    (!varlen_map_access && rold->type == UNKNOWN_VALUE &&\n\t\t     rcur->type != NOT_INIT))\n\t\t\tcontinue;\n\n\t\tif (rold->type == PTR_TO_PACKET && rcur->type == PTR_TO_PACKET &&\n\t\t    compare_ptrs_to_packet(rold, rcur))\n\t\t\tcontinue;\n\n\t\treturn false;\n\t}\n\n\tfor (i = 0; i < MAX_BPF_STACK; i++) {\n\t\tif (old->stack_slot_type[i] == STACK_INVALID)\n\t\t\tcontinue;\n\t\tif (old->stack_slot_type[i] != cur->stack_slot_type[i])\n\t\t\t/* Ex: old explored (safe) state has STACK_SPILL in\n\t\t\t * this stack slot, but current has has STACK_MISC ->\n\t\t\t * this verifier states are not equivalent,\n\t\t\t * return false to continue verification of this path\n\t\t\t */\n\t\t\treturn false;\n\t\tif (i % BPF_REG_SIZE)\n\t\t\tcontinue;\n\t\tif (memcmp(&old->spilled_regs[i / BPF_REG_SIZE],\n\t\t\t   &cur->spilled_regs[i / BPF_REG_SIZE],\n\t\t\t   sizeof(old->spilled_regs[0])))\n\t\t\t/* when explored and current stack slot types are\n\t\t\t * the same, check that stored pointers types\n\t\t\t * are the same as well.\n\t\t\t * Ex: explored safe path could have stored\n\t\t\t * (bpf_reg_state) {.type = PTR_TO_STACK, .imm = -8}\n\t\t\t * but current path has stored:\n\t\t\t * (bpf_reg_state) {.type = PTR_TO_STACK, .imm = -16}\n\t\t\t * such verifier states are not equivalent.\n\t\t\t * return false to continue verification of this path\n\t\t\t */\n\t\t\treturn false;\n\t\telse\n\t\t\tcontinue;\n\t}\n\treturn true;\n}\n\nstatic int is_state_visited(struct bpf_verifier_env *env, int insn_idx)\n{\n\tstruct bpf_verifier_state_list *new_sl;\n\tstruct bpf_verifier_state_list *sl;\n\n\tsl = env->explored_states[insn_idx];\n\tif (!sl)\n\t\t/* this 'insn_idx' instruction wasn't marked, so we will not\n\t\t * be doing state search here\n\t\t */\n\t\treturn 0;\n\n\twhile (sl != STATE_LIST_MARK) {\n\t\tif (states_equal(env, &sl->state, &env->cur_state))\n\t\t\t/* reached equivalent register/stack state,\n\t\t\t * prune the search\n\t\t\t */\n\t\t\treturn 1;\n\t\tsl = sl->next;\n\t}\n\n\t/* there were no equivalent states, remember current one.\n\t * technically the current state is not proven to be safe yet,\n\t * but it will either reach bpf_exit (which means it's safe) or\n\t * it will be rejected. Since there are no loops, we won't be\n\t * seeing this 'insn_idx' instruction again on the way to bpf_exit\n\t */\n\tnew_sl = kmalloc(sizeof(struct bpf_verifier_state_list), GFP_USER);\n\tif (!new_sl)\n\t\treturn -ENOMEM;\n\n\t/* add new state to the head of linked list */\n\tmemcpy(&new_sl->state, &env->cur_state, sizeof(env->cur_state));\n\tnew_sl->next = env->explored_states[insn_idx];\n\tenv->explored_states[insn_idx] = new_sl;\n\treturn 0;\n}\n\nstatic int ext_analyzer_insn_hook(struct bpf_verifier_env *env,\n\t\t\t\t  int insn_idx, int prev_insn_idx)\n{\n\tif (!env->analyzer_ops || !env->analyzer_ops->insn_hook)\n\t\treturn 0;\n\n\treturn env->analyzer_ops->insn_hook(env, insn_idx, prev_insn_idx);\n}\n\nstatic int do_check(struct bpf_verifier_env *env)\n{\n\tstruct bpf_verifier_state *state = &env->cur_state;\n\tstruct bpf_insn *insns = env->prog->insnsi;\n\tstruct bpf_reg_state *regs = state->regs;\n\tint insn_cnt = env->prog->len;\n\tint insn_idx, prev_insn_idx = 0;\n\tint insn_processed = 0;\n\tbool do_print_state = false;\n\n\tinit_reg_state(regs);\n\tinsn_idx = 0;\n\tenv->varlen_map_value_access = false;\n\tfor (;;) {\n\t\tstruct bpf_insn *insn;\n\t\tu8 class;\n\t\tint err;\n\n\t\tif (insn_idx >= insn_cnt) {\n\t\t\tverbose(\"invalid insn idx %d insn_cnt %d\\n\",\n\t\t\t\tinsn_idx, insn_cnt);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tinsn = &insns[insn_idx];\n\t\tclass = BPF_CLASS(insn->code);\n\n\t\tif (++insn_processed > BPF_COMPLEXITY_LIMIT_INSNS) {\n\t\t\tverbose(\"BPF program is too large. Processed %d insn\\n\",\n\t\t\t\tinsn_processed);\n\t\t\treturn -E2BIG;\n\t\t}\n\n\t\terr = is_state_visited(env, insn_idx);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (err == 1) {\n\t\t\t/* found equivalent state, can prune the search */\n\t\t\tif (log_level) {\n\t\t\t\tif (do_print_state)\n\t\t\t\t\tverbose(\"\\nfrom %d to %d: safe\\n\",\n\t\t\t\t\t\tprev_insn_idx, insn_idx);\n\t\t\t\telse\n\t\t\t\t\tverbose(\"%d: safe\\n\", insn_idx);\n\t\t\t}\n\t\t\tgoto process_bpf_exit;\n\t\t}\n\n\t\tif (log_level && do_print_state) {\n\t\t\tverbose(\"\\nfrom %d to %d:\", prev_insn_idx, insn_idx);\n\t\t\tprint_verifier_state(&env->cur_state);\n\t\t\tdo_print_state = false;\n\t\t}\n\n\t\tif (log_level) {\n\t\t\tverbose(\"%d: \", insn_idx);\n\t\t\tprint_bpf_insn(env, insn);\n\t\t}\n\n\t\terr = ext_analyzer_insn_hook(env, insn_idx, prev_insn_idx);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (class == BPF_ALU || class == BPF_ALU64) {\n\t\t\terr = check_alu_op(env, insn);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t} else if (class == BPF_LDX) {\n\t\t\tenum bpf_reg_type *prev_src_type, src_reg_type;\n\n\t\t\t/* check for reserved fields is already done */\n\n\t\t\t/* check src operand */\n\t\t\terr = check_reg_arg(regs, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\terr = check_reg_arg(regs, insn->dst_reg, DST_OP_NO_MARK);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tsrc_reg_type = regs[insn->src_reg].type;\n\n\t\t\t/* check that memory (src_reg + off) is readable,\n\t\t\t * the state of dst_reg will be updated by this func\n\t\t\t */\n\t\t\terr = check_mem_access(env, insn->src_reg, insn->off,\n\t\t\t\t\t       BPF_SIZE(insn->code), BPF_READ,\n\t\t\t\t\t       insn->dst_reg);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tif (BPF_SIZE(insn->code) != BPF_W &&\n\t\t\t    BPF_SIZE(insn->code) != BPF_DW) {\n\t\t\t\tinsn_idx++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tprev_src_type = &env->insn_aux_data[insn_idx].ptr_type;\n\n\t\t\tif (*prev_src_type == NOT_INIT) {\n\t\t\t\t/* saw a valid insn\n\t\t\t\t * dst_reg = *(u32 *)(src_reg + off)\n\t\t\t\t * save type to validate intersecting paths\n\t\t\t\t */\n\t\t\t\t*prev_src_type = src_reg_type;\n\n\t\t\t} else if (src_reg_type != *prev_src_type &&\n\t\t\t\t   (src_reg_type == PTR_TO_CTX ||\n\t\t\t\t    *prev_src_type == PTR_TO_CTX)) {\n\t\t\t\t/* ABuser program is trying to use the same insn\n\t\t\t\t * dst_reg = *(u32*) (src_reg + off)\n\t\t\t\t * with different pointer types:\n\t\t\t\t * src_reg == ctx in one branch and\n\t\t\t\t * src_reg == stack|map in some other branch.\n\t\t\t\t * Reject it.\n\t\t\t\t */\n\t\t\t\tverbose(\"same insn cannot be used with different pointers\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t} else if (class == BPF_STX) {\n\t\t\tenum bpf_reg_type *prev_dst_type, dst_reg_type;\n\n\t\t\tif (BPF_MODE(insn->code) == BPF_XADD) {\n\t\t\t\terr = check_xadd(env, insn);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tinsn_idx++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* check src1 operand */\n\t\t\terr = check_reg_arg(regs, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\t/* check src2 operand */\n\t\t\terr = check_reg_arg(regs, insn->dst_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tdst_reg_type = regs[insn->dst_reg].type;\n\n\t\t\t/* check that memory (dst_reg + off) is writeable */\n\t\t\terr = check_mem_access(env, insn->dst_reg, insn->off,\n\t\t\t\t\t       BPF_SIZE(insn->code), BPF_WRITE,\n\t\t\t\t\t       insn->src_reg);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tprev_dst_type = &env->insn_aux_data[insn_idx].ptr_type;\n\n\t\t\tif (*prev_dst_type == NOT_INIT) {\n\t\t\t\t*prev_dst_type = dst_reg_type;\n\t\t\t} else if (dst_reg_type != *prev_dst_type &&\n\t\t\t\t   (dst_reg_type == PTR_TO_CTX ||\n\t\t\t\t    *prev_dst_type == PTR_TO_CTX)) {\n\t\t\t\tverbose(\"same insn cannot be used with different pointers\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t} else if (class == BPF_ST) {\n\t\t\tif (BPF_MODE(insn->code) != BPF_MEM ||\n\t\t\t    insn->src_reg != BPF_REG_0) {\n\t\t\t\tverbose(\"BPF_ST uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t/* check src operand */\n\t\t\terr = check_reg_arg(regs, insn->dst_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\t/* check that memory (dst_reg + off) is writeable */\n\t\t\terr = check_mem_access(env, insn->dst_reg, insn->off,\n\t\t\t\t\t       BPF_SIZE(insn->code), BPF_WRITE,\n\t\t\t\t\t       -1);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t} else if (class == BPF_JMP) {\n\t\t\tu8 opcode = BPF_OP(insn->code);\n\n\t\t\tif (opcode == BPF_CALL) {\n\t\t\t\tif (BPF_SRC(insn->code) != BPF_K ||\n\t\t\t\t    insn->off != 0 ||\n\t\t\t\t    insn->src_reg != BPF_REG_0 ||\n\t\t\t\t    insn->dst_reg != BPF_REG_0) {\n\t\t\t\t\tverbose(\"BPF_CALL uses reserved fields\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\terr = check_call(env, insn->imm, insn_idx);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t} else if (opcode == BPF_JA) {\n\t\t\t\tif (BPF_SRC(insn->code) != BPF_K ||\n\t\t\t\t    insn->imm != 0 ||\n\t\t\t\t    insn->src_reg != BPF_REG_0 ||\n\t\t\t\t    insn->dst_reg != BPF_REG_0) {\n\t\t\t\t\tverbose(\"BPF_JA uses reserved fields\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tinsn_idx += insn->off + 1;\n\t\t\t\tcontinue;\n\n\t\t\t} else if (opcode == BPF_EXIT) {\n\t\t\t\tif (BPF_SRC(insn->code) != BPF_K ||\n\t\t\t\t    insn->imm != 0 ||\n\t\t\t\t    insn->src_reg != BPF_REG_0 ||\n\t\t\t\t    insn->dst_reg != BPF_REG_0) {\n\t\t\t\t\tverbose(\"BPF_EXIT uses reserved fields\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\t/* eBPF calling convetion is such that R0 is used\n\t\t\t\t * to return the value from eBPF program.\n\t\t\t\t * Make sure that it's readable at this time\n\t\t\t\t * of bpf_exit, which means that program wrote\n\t\t\t\t * something into it earlier\n\t\t\t\t */\n\t\t\t\terr = check_reg_arg(regs, BPF_REG_0, SRC_OP);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\tif (is_pointer_value(env, BPF_REG_0)) {\n\t\t\t\t\tverbose(\"R0 leaks addr as return value\\n\");\n\t\t\t\t\treturn -EACCES;\n\t\t\t\t}\n\nprocess_bpf_exit:\n\t\t\t\tinsn_idx = pop_stack(env, &prev_insn_idx);\n\t\t\t\tif (insn_idx < 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tdo_print_state = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terr = check_cond_jmp_op(env, insn, &insn_idx);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t} else if (class == BPF_LD) {\n\t\t\tu8 mode = BPF_MODE(insn->code);\n\n\t\t\tif (mode == BPF_ABS || mode == BPF_IND) {\n\t\t\t\terr = check_ld_abs(env, insn);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t} else if (mode == BPF_IMM) {\n\t\t\t\terr = check_ld_imm(env, insn);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\tinsn_idx++;\n\t\t\t} else {\n\t\t\t\tverbose(\"invalid BPF_LD mode\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\treset_reg_range_values(regs, insn->dst_reg);\n\t\t} else {\n\t\t\tverbose(\"unknown insn class %d\\n\", class);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tinsn_idx++;\n\t}\n\n\tverbose(\"processed %d insns\\n\", insn_processed);\n\treturn 0;\n}\n\nstatic int check_map_prealloc(struct bpf_map *map)\n{\n\treturn (map->map_type != BPF_MAP_TYPE_HASH &&\n\t\tmap->map_type != BPF_MAP_TYPE_PERCPU_HASH &&\n\t\tmap->map_type != BPF_MAP_TYPE_HASH_OF_MAPS) ||\n\t\t!(map->map_flags & BPF_F_NO_PREALLOC);\n}\n\nstatic int check_map_prog_compatibility(struct bpf_map *map,\n\t\t\t\t\tstruct bpf_prog *prog)\n\n{\n\t/* Make sure that BPF_PROG_TYPE_PERF_EVENT programs only use\n\t * preallocated hash maps, since doing memory allocation\n\t * in overflow_handler can crash depending on where nmi got\n\t * triggered.\n\t */\n\tif (prog->type == BPF_PROG_TYPE_PERF_EVENT) {\n\t\tif (!check_map_prealloc(map)) {\n\t\t\tverbose(\"perf_event programs can only use preallocated hash map\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (map->inner_map_meta &&\n\t\t    !check_map_prealloc(map->inner_map_meta)) {\n\t\t\tverbose(\"perf_event programs can only use preallocated inner hash map\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/* look for pseudo eBPF instructions that access map FDs and\n * replace them with actual map pointers\n */\nstatic int replace_map_fd_with_map_ptr(struct bpf_verifier_env *env)\n{\n\tstruct bpf_insn *insn = env->prog->insnsi;\n\tint insn_cnt = env->prog->len;\n\tint i, j, err;\n\n\terr = bpf_prog_calc_tag(env->prog);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (BPF_CLASS(insn->code) == BPF_LDX &&\n\t\t    (BPF_MODE(insn->code) != BPF_MEM || insn->imm != 0)) {\n\t\t\tverbose(\"BPF_LDX uses reserved fields\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (BPF_CLASS(insn->code) == BPF_STX &&\n\t\t    ((BPF_MODE(insn->code) != BPF_MEM &&\n\t\t      BPF_MODE(insn->code) != BPF_XADD) || insn->imm != 0)) {\n\t\t\tverbose(\"BPF_STX uses reserved fields\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (insn[0].code == (BPF_LD | BPF_IMM | BPF_DW)) {\n\t\t\tstruct bpf_map *map;\n\t\t\tstruct fd f;\n\n\t\t\tif (i == insn_cnt - 1 || insn[1].code != 0 ||\n\t\t\t    insn[1].dst_reg != 0 || insn[1].src_reg != 0 ||\n\t\t\t    insn[1].off != 0) {\n\t\t\t\tverbose(\"invalid bpf_ld_imm64 insn\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (insn->src_reg == 0)\n\t\t\t\t/* valid generic load 64-bit imm */\n\t\t\t\tgoto next_insn;\n\n\t\t\tif (insn->src_reg != BPF_PSEUDO_MAP_FD) {\n\t\t\t\tverbose(\"unrecognized bpf_ld_imm64 insn\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tf = fdget(insn->imm);\n\t\t\tmap = __bpf_map_get(f);\n\t\t\tif (IS_ERR(map)) {\n\t\t\t\tverbose(\"fd %d is not pointing to valid bpf_map\\n\",\n\t\t\t\t\tinsn->imm);\n\t\t\t\treturn PTR_ERR(map);\n\t\t\t}\n\n\t\t\terr = check_map_prog_compatibility(map, env->prog);\n\t\t\tif (err) {\n\t\t\t\tfdput(f);\n\t\t\t\treturn err;\n\t\t\t}\n\n\t\t\t/* store map pointer inside BPF_LD_IMM64 instruction */\n\t\t\tinsn[0].imm = (u32) (unsigned long) map;\n\t\t\tinsn[1].imm = ((u64) (unsigned long) map) >> 32;\n\n\t\t\t/* check whether we recorded this map already */\n\t\t\tfor (j = 0; j < env->used_map_cnt; j++)\n\t\t\t\tif (env->used_maps[j] == map) {\n\t\t\t\t\tfdput(f);\n\t\t\t\t\tgoto next_insn;\n\t\t\t\t}\n\n\t\t\tif (env->used_map_cnt >= MAX_USED_MAPS) {\n\t\t\t\tfdput(f);\n\t\t\t\treturn -E2BIG;\n\t\t\t}\n\n\t\t\t/* hold the map. If the program is rejected by verifier,\n\t\t\t * the map will be released by release_maps() or it\n\t\t\t * will be used by the valid program until it's unloaded\n\t\t\t * and all maps are released in free_bpf_prog_info()\n\t\t\t */\n\t\t\tmap = bpf_map_inc(map, false);\n\t\t\tif (IS_ERR(map)) {\n\t\t\t\tfdput(f);\n\t\t\t\treturn PTR_ERR(map);\n\t\t\t}\n\t\t\tenv->used_maps[env->used_map_cnt++] = map;\n\n\t\t\tfdput(f);\nnext_insn:\n\t\t\tinsn++;\n\t\t\ti++;\n\t\t}\n\t}\n\n\t/* now all pseudo BPF_LD_IMM64 instructions load valid\n\t * 'struct bpf_map *' into a register instead of user map_fd.\n\t * These pointers will be used later by verifier to validate map access.\n\t */\n\treturn 0;\n}\n\n/* drop refcnt of maps used by the rejected program */\nstatic void release_maps(struct bpf_verifier_env *env)\n{\n\tint i;\n\n\tfor (i = 0; i < env->used_map_cnt; i++)\n\t\tbpf_map_put(env->used_maps[i]);\n}\n\n/* convert pseudo BPF_LD_IMM64 into generic BPF_LD_IMM64 */\nstatic void convert_pseudo_ld_imm64(struct bpf_verifier_env *env)\n{\n\tstruct bpf_insn *insn = env->prog->insnsi;\n\tint insn_cnt = env->prog->len;\n\tint i;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++)\n\t\tif (insn->code == (BPF_LD | BPF_IMM | BPF_DW))\n\t\t\tinsn->src_reg = 0;\n}\n\n/* single env->prog->insni[off] instruction was replaced with the range\n * insni[off, off + cnt).  Adjust corresponding insn_aux_data by copying\n * [0, off) and [off, end) to new locations, so the patched range stays zero\n */\nstatic int adjust_insn_aux_data(struct bpf_verifier_env *env, u32 prog_len,\n\t\t\t\tu32 off, u32 cnt)\n{\n\tstruct bpf_insn_aux_data *new_data, *old_data = env->insn_aux_data;\n\n\tif (cnt == 1)\n\t\treturn 0;\n\tnew_data = vzalloc(sizeof(struct bpf_insn_aux_data) * prog_len);\n\tif (!new_data)\n\t\treturn -ENOMEM;\n\tmemcpy(new_data, old_data, sizeof(struct bpf_insn_aux_data) * off);\n\tmemcpy(new_data + off + cnt - 1, old_data + off,\n\t       sizeof(struct bpf_insn_aux_data) * (prog_len - off - cnt + 1));\n\tenv->insn_aux_data = new_data;\n\tvfree(old_data);\n\treturn 0;\n}\n\nstatic struct bpf_prog *bpf_patch_insn_data(struct bpf_verifier_env *env, u32 off,\n\t\t\t\t\t    const struct bpf_insn *patch, u32 len)\n{\n\tstruct bpf_prog *new_prog;\n\n\tnew_prog = bpf_patch_insn_single(env->prog, off, patch, len);\n\tif (!new_prog)\n\t\treturn NULL;\n\tif (adjust_insn_aux_data(env, new_prog->len, off, len))\n\t\treturn NULL;\n\treturn new_prog;\n}\n\n/* convert load instructions that access fields of 'struct __sk_buff'\n * into sequence of instructions that access fields of 'struct sk_buff'\n */\nstatic int convert_ctx_accesses(struct bpf_verifier_env *env)\n{\n\tconst struct bpf_verifier_ops *ops = env->prog->aux->ops;\n\tconst int insn_cnt = env->prog->len;\n\tstruct bpf_insn insn_buf[16], *insn;\n\tstruct bpf_prog *new_prog;\n\tenum bpf_access_type type;\n\tint i, cnt, delta = 0;\n\n\tif (ops->gen_prologue) {\n\t\tcnt = ops->gen_prologue(insn_buf, env->seen_direct_write,\n\t\t\t\t\tenv->prog);\n\t\tif (cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\tverbose(\"bpf verifier is misconfigured\\n\");\n\t\t\treturn -EINVAL;\n\t\t} else if (cnt) {\n\t\t\tnew_prog = bpf_patch_insn_data(env, 0, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tenv->prog = new_prog;\n\t\t\tdelta += cnt - 1;\n\t\t}\n\t}\n\n\tif (!ops->convert_ctx_access)\n\t\treturn 0;\n\n\tinsn = env->prog->insnsi + delta;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (insn->code == (BPF_LDX | BPF_MEM | BPF_B) ||\n\t\t    insn->code == (BPF_LDX | BPF_MEM | BPF_H) ||\n\t\t    insn->code == (BPF_LDX | BPF_MEM | BPF_W) ||\n\t\t    insn->code == (BPF_LDX | BPF_MEM | BPF_DW))\n\t\t\ttype = BPF_READ;\n\t\telse if (insn->code == (BPF_STX | BPF_MEM | BPF_B) ||\n\t\t\t insn->code == (BPF_STX | BPF_MEM | BPF_H) ||\n\t\t\t insn->code == (BPF_STX | BPF_MEM | BPF_W) ||\n\t\t\t insn->code == (BPF_STX | BPF_MEM | BPF_DW))\n\t\t\ttype = BPF_WRITE;\n\t\telse\n\t\t\tcontinue;\n\n\t\tif (env->insn_aux_data[i + delta].ptr_type != PTR_TO_CTX)\n\t\t\tcontinue;\n\n\t\tcnt = ops->convert_ctx_access(type, insn, insn_buf, env->prog);\n\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\tverbose(\"bpf verifier is misconfigured\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\tif (!new_prog)\n\t\t\treturn -ENOMEM;\n\n\t\tdelta += cnt - 1;\n\n\t\t/* keep walking new program and skip insns we just inserted */\n\t\tenv->prog = new_prog;\n\t\tinsn      = new_prog->insnsi + i + delta;\n\t}\n\n\treturn 0;\n}\n\n/* fixup insn->imm field of bpf_call instructions\n * and inline eligible helpers as explicit sequence of BPF instructions\n *\n * this function is called after eBPF program passed verification\n */\nstatic int fixup_bpf_calls(struct bpf_verifier_env *env)\n{\n\tstruct bpf_prog *prog = env->prog;\n\tstruct bpf_insn *insn = prog->insnsi;\n\tconst struct bpf_func_proto *fn;\n\tconst int insn_cnt = prog->len;\n\tstruct bpf_insn insn_buf[16];\n\tstruct bpf_prog *new_prog;\n\tstruct bpf_map *map_ptr;\n\tint i, cnt, delta = 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (insn->code != (BPF_JMP | BPF_CALL))\n\t\t\tcontinue;\n\n\t\tif (insn->imm == BPF_FUNC_get_route_realm)\n\t\t\tprog->dst_needed = 1;\n\t\tif (insn->imm == BPF_FUNC_get_prandom_u32)\n\t\t\tbpf_user_rnd_init_once();\n\t\tif (insn->imm == BPF_FUNC_tail_call) {\n\t\t\t/* If we tail call into other programs, we\n\t\t\t * cannot make any assumptions since they can\n\t\t\t * be replaced dynamically during runtime in\n\t\t\t * the program array.\n\t\t\t */\n\t\t\tprog->cb_access = 1;\n\n\t\t\t/* mark bpf_tail_call as different opcode to avoid\n\t\t\t * conditional branch in the interpeter for every normal\n\t\t\t * call and to prevent accidental JITing by JIT compiler\n\t\t\t * that doesn't support bpf_tail_call yet\n\t\t\t */\n\t\t\tinsn->imm = 0;\n\t\t\tinsn->code |= BPF_X;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ebpf_jit_enabled() && insn->imm == BPF_FUNC_map_lookup_elem) {\n\t\t\tmap_ptr = env->insn_aux_data[i + delta].map_ptr;\n\t\t\tif (map_ptr == BPF_MAP_PTR_POISON ||\n\t\t\t    !map_ptr->ops->map_gen_lookup)\n\t\t\t\tgoto patch_call_imm;\n\n\t\t\tcnt = map_ptr->ops->map_gen_lookup(map_ptr, insn_buf);\n\t\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\tverbose(\"bpf verifier is misconfigured\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf,\n\t\t\t\t\t\t       cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta += cnt - 1;\n\n\t\t\t/* keep walking new program and skip insns we just inserted */\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\npatch_call_imm:\n\t\tfn = prog->aux->ops->get_func_proto(insn->imm);\n\t\t/* all functions that have prototype and verifier allowed\n\t\t * programs to call them, must be real in-kernel functions\n\t\t */\n\t\tif (!fn->func) {\n\t\t\tverbose(\"kernel subsystem misconfigured func %s#%d\\n\",\n\t\t\t\tfunc_id_name(insn->imm), insn->imm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tinsn->imm = fn->func - __bpf_call_base;\n\t}\n\n\treturn 0;\n}\n\nstatic void free_states(struct bpf_verifier_env *env)\n{\n\tstruct bpf_verifier_state_list *sl, *sln;\n\tint i;\n\n\tif (!env->explored_states)\n\t\treturn;\n\n\tfor (i = 0; i < env->prog->len; i++) {\n\t\tsl = env->explored_states[i];\n\n\t\tif (sl)\n\t\t\twhile (sl != STATE_LIST_MARK) {\n\t\t\t\tsln = sl->next;\n\t\t\t\tkfree(sl);\n\t\t\t\tsl = sln;\n\t\t\t}\n\t}\n\n\tkfree(env->explored_states);\n}\n\nint bpf_check(struct bpf_prog **prog, union bpf_attr *attr)\n{\n\tchar __user *log_ubuf = NULL;\n\tstruct bpf_verifier_env *env;\n\tint ret = -EINVAL;\n\n\t/* 'struct bpf_verifier_env' can be global, but since it's not small,\n\t * allocate/free it every time bpf_check() is called\n\t */\n\tenv = kzalloc(sizeof(struct bpf_verifier_env), GFP_KERNEL);\n\tif (!env)\n\t\treturn -ENOMEM;\n\n\tenv->insn_aux_data = vzalloc(sizeof(struct bpf_insn_aux_data) *\n\t\t\t\t     (*prog)->len);\n\tret = -ENOMEM;\n\tif (!env->insn_aux_data)\n\t\tgoto err_free_env;\n\tenv->prog = *prog;\n\n\t/* grab the mutex to protect few globals used by verifier */\n\tmutex_lock(&bpf_verifier_lock);\n\n\tif (attr->log_level || attr->log_buf || attr->log_size) {\n\t\t/* user requested verbose verifier output\n\t\t * and supplied buffer to store the verification trace\n\t\t */\n\t\tlog_level = attr->log_level;\n\t\tlog_ubuf = (char __user *) (unsigned long) attr->log_buf;\n\t\tlog_size = attr->log_size;\n\t\tlog_len = 0;\n\n\t\tret = -EINVAL;\n\t\t/* log_* values have to be sane */\n\t\tif (log_size < 128 || log_size > UINT_MAX >> 8 ||\n\t\t    log_level == 0 || log_ubuf == NULL)\n\t\t\tgoto err_unlock;\n\n\t\tret = -ENOMEM;\n\t\tlog_buf = vmalloc(log_size);\n\t\tif (!log_buf)\n\t\t\tgoto err_unlock;\n\t} else {\n\t\tlog_level = 0;\n\t}\n\n\tret = replace_map_fd_with_map_ptr(env);\n\tif (ret < 0)\n\t\tgoto skip_full_check;\n\n\tenv->explored_states = kcalloc(env->prog->len,\n\t\t\t\t       sizeof(struct bpf_verifier_state_list *),\n\t\t\t\t       GFP_USER);\n\tret = -ENOMEM;\n\tif (!env->explored_states)\n\t\tgoto skip_full_check;\n\n\tret = check_cfg(env);\n\tif (ret < 0)\n\t\tgoto skip_full_check;\n\n\tenv->allow_ptr_leaks = capable(CAP_SYS_ADMIN);\n\n\tret = do_check(env);\n\nskip_full_check:\n\twhile (pop_stack(env, NULL) >= 0);\n\tfree_states(env);\n\n\tif (ret == 0)\n\t\t/* program is valid, convert *(u32*)(ctx + off) accesses */\n\t\tret = convert_ctx_accesses(env);\n\n\tif (ret == 0)\n\t\tret = fixup_bpf_calls(env);\n\n\tif (log_level && log_len >= log_size - 1) {\n\t\tBUG_ON(log_len >= log_size);\n\t\t/* verifier log exceeded user supplied buffer */\n\t\tret = -ENOSPC;\n\t\t/* fall through to return what was recorded */\n\t}\n\n\t/* copy verifier log back to user space including trailing zero */\n\tif (log_level && copy_to_user(log_ubuf, log_buf, log_len + 1) != 0) {\n\t\tret = -EFAULT;\n\t\tgoto free_log_buf;\n\t}\n\n\tif (ret == 0 && env->used_map_cnt) {\n\t\t/* if program passed verifier, update used_maps in bpf_prog_info */\n\t\tenv->prog->aux->used_maps = kmalloc_array(env->used_map_cnt,\n\t\t\t\t\t\t\t  sizeof(env->used_maps[0]),\n\t\t\t\t\t\t\t  GFP_KERNEL);\n\n\t\tif (!env->prog->aux->used_maps) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_log_buf;\n\t\t}\n\n\t\tmemcpy(env->prog->aux->used_maps, env->used_maps,\n\t\t       sizeof(env->used_maps[0]) * env->used_map_cnt);\n\t\tenv->prog->aux->used_map_cnt = env->used_map_cnt;\n\n\t\t/* program is valid. Convert pseudo bpf_ld_imm64 into generic\n\t\t * bpf_ld_imm64 instructions\n\t\t */\n\t\tconvert_pseudo_ld_imm64(env);\n\t}\n\nfree_log_buf:\n\tif (log_level)\n\t\tvfree(log_buf);\n\tif (!env->prog->aux->used_maps)\n\t\t/* if we didn't copy map pointers into bpf_prog_info, release\n\t\t * them now. Otherwise free_bpf_prog_info() will release them.\n\t\t */\n\t\trelease_maps(env);\n\t*prog = env->prog;\nerr_unlock:\n\tmutex_unlock(&bpf_verifier_lock);\n\tvfree(env->insn_aux_data);\nerr_free_env:\n\tkfree(env);\n\treturn ret;\n}\n\nint bpf_analyzer(struct bpf_prog *prog, const struct bpf_ext_analyzer_ops *ops,\n\t\t void *priv)\n{\n\tstruct bpf_verifier_env *env;\n\tint ret;\n\n\tenv = kzalloc(sizeof(struct bpf_verifier_env), GFP_KERNEL);\n\tif (!env)\n\t\treturn -ENOMEM;\n\n\tenv->insn_aux_data = vzalloc(sizeof(struct bpf_insn_aux_data) *\n\t\t\t\t     prog->len);\n\tret = -ENOMEM;\n\tif (!env->insn_aux_data)\n\t\tgoto err_free_env;\n\tenv->prog = prog;\n\tenv->analyzer_ops = ops;\n\tenv->analyzer_priv = priv;\n\n\t/* grab the mutex to protect few globals used by verifier */\n\tmutex_lock(&bpf_verifier_lock);\n\n\tlog_level = 0;\n\n\tenv->explored_states = kcalloc(env->prog->len,\n\t\t\t\t       sizeof(struct bpf_verifier_state_list *),\n\t\t\t\t       GFP_KERNEL);\n\tret = -ENOMEM;\n\tif (!env->explored_states)\n\t\tgoto skip_full_check;\n\n\tret = check_cfg(env);\n\tif (ret < 0)\n\t\tgoto skip_full_check;\n\n\tenv->allow_ptr_leaks = capable(CAP_SYS_ADMIN);\n\n\tret = do_check(env);\n\nskip_full_check:\n\twhile (pop_stack(env, NULL) >= 0);\n\tfree_states(env);\n\n\tmutex_unlock(&bpf_verifier_lock);\n\tvfree(env->insn_aux_data);\nerr_free_env:\n\tkfree(env);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(bpf_analyzer);\n"], "filenames": ["kernel/bpf/verifier.c"], "buggy_code_start_loc": [301], "buggy_code_end_loc": [2857], "fixing_code_start_loc": [301], "fixing_code_end_loc": [2868], "type": "CWE-200", "message": "The do_check function in kernel/bpf/verifier.c in the Linux kernel before 4.11.1 does not make the allow_ptr_leaks value available for restricting the output of the print_bpf_insn function, which allows local users to obtain sensitive address information via crafted bpf system calls.", "other": {"cve": {"id": "CVE-2017-9150", "sourceIdentifier": "cve@mitre.org", "published": "2017-05-22T22:29:00.190", "lastModified": "2017-09-09T01:29:03.863", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The do_check function in kernel/bpf/verifier.c in the Linux kernel before 4.11.1 does not make the allow_ptr_leaks value available for restricting the output of the print_bpf_insn function, which allows local users to obtain sensitive address information via crafted bpf system calls."}, {"lang": "es", "value": "La funci\u00f3n do_check en el archivo kernel/bpf/verifier.c en el kernel de Linux anterior a versi\u00f3n 4.11.1, no hace que el valor de allow_ptr_leaks est\u00e9 disponible para restringir la salida de la funci\u00f3n print_bpf_insn, que permite a los usuarios locales obtener informaci\u00f3n de una direcci\u00f3n confidencial  por medio de llamadas del sistema bpf especialmente dise\u00f1adas."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.10.9", "matchCriteriaId": "526CF197-BAE6-4F03-9D2F-07A864CD9185"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=0d0e57697f162da4aa218b5feafe614fb666db07", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.11.1", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/98635", "source": "cve@mitre.org"}, {"url": "https://bugs.chromium.org/p/project-zero/issues/detail?id=1251", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/0d0e57697f162da4aa218b5feafe614fb666db07", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://source.android.com/security/bulletin/2017-09-01", "source": "cve@mitre.org"}, {"url": "https://www.exploit-db.com/exploits/42048/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/0d0e57697f162da4aa218b5feafe614fb666db07"}}