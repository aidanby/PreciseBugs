{"buggy_code": ["/* Large capacity key type\n *\n * Copyright (C) 2013 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public Licence\n * as published by the Free Software Foundation; either version\n * 2 of the Licence, or (at your option) any later version.\n */\n\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/shmem_fs.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <keys/user-type.h>\n#include <keys/big_key-type.h>\n#include <crypto/rng.h>\n#include <crypto/skcipher.h>\n\n/*\n * Layout of key payload words.\n */\nenum {\n\tbig_key_data,\n\tbig_key_path,\n\tbig_key_path_2nd_part,\n\tbig_key_len,\n};\n\n/*\n * Crypto operation with big_key data\n */\nenum big_key_op {\n\tBIG_KEY_ENC,\n\tBIG_KEY_DEC,\n};\n\n/*\n * If the data is under this limit, there's no point creating a shm file to\n * hold it as the permanently resident metadata for the shmem fs will be at\n * least as large as the data.\n */\n#define BIG_KEY_FILE_THRESHOLD (sizeof(struct inode) + sizeof(struct dentry))\n\n/*\n * Key size for big_key data encryption\n */\n#define ENC_KEY_SIZE\t16\n\n/*\n * big_key defined keys take an arbitrary string as the description and an\n * arbitrary blob of data as the payload\n */\nstruct key_type key_type_big_key = {\n\t.name\t\t\t= \"big_key\",\n\t.preparse\t\t= big_key_preparse,\n\t.free_preparse\t\t= big_key_free_preparse,\n\t.instantiate\t\t= generic_key_instantiate,\n\t.revoke\t\t\t= big_key_revoke,\n\t.destroy\t\t= big_key_destroy,\n\t.describe\t\t= big_key_describe,\n\t.read\t\t\t= big_key_read,\n};\n\n/*\n * Crypto names for big_key data encryption\n */\nstatic const char big_key_rng_name[] = \"stdrng\";\nstatic const char big_key_alg_name[] = \"ecb(aes)\";\n\n/*\n * Crypto algorithms for big_key data encryption\n */\nstatic struct crypto_rng *big_key_rng;\nstatic struct crypto_skcipher *big_key_skcipher;\n\n/*\n * Generate random key to encrypt big_key data\n */\nstatic inline int big_key_gen_enckey(u8 *key)\n{\n\treturn crypto_rng_get_bytes(big_key_rng, key, ENC_KEY_SIZE);\n}\n\n/*\n * Encrypt/decrypt big_key data\n */\nstatic int big_key_crypt(enum big_key_op op, u8 *data, size_t datalen, u8 *key)\n{\n\tint ret = -EINVAL;\n\tstruct scatterlist sgio;\n\tSKCIPHER_REQUEST_ON_STACK(req, big_key_skcipher);\n\n\tif (crypto_skcipher_setkey(big_key_skcipher, key, ENC_KEY_SIZE)) {\n\t\tret = -EAGAIN;\n\t\tgoto error;\n\t}\n\n\tskcipher_request_set_tfm(req, big_key_skcipher);\n\tskcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\t\t\t      NULL, NULL);\n\n\tsg_init_one(&sgio, data, datalen);\n\tskcipher_request_set_crypt(req, &sgio, &sgio, datalen, NULL);\n\n\tif (op == BIG_KEY_ENC)\n\t\tret = crypto_skcipher_encrypt(req);\n\telse\n\t\tret = crypto_skcipher_decrypt(req);\n\n\tskcipher_request_zero(req);\n\nerror:\n\treturn ret;\n}\n\n/*\n * Preparse a big key\n */\nint big_key_preparse(struct key_preparsed_payload *prep)\n{\n\tstruct path *path = (struct path *)&prep->payload.data[big_key_path];\n\tstruct file *file;\n\tu8 *enckey;\n\tu8 *data = NULL;\n\tssize_t written;\n\tsize_t datalen = prep->datalen;\n\tint ret;\n\n\tret = -EINVAL;\n\tif (datalen <= 0 || datalen > 1024 * 1024 || !prep->data)\n\t\tgoto error;\n\n\t/* Set an arbitrary quota */\n\tprep->quotalen = 16;\n\n\tprep->payload.data[big_key_len] = (void *)(unsigned long)datalen;\n\n\tif (datalen > BIG_KEY_FILE_THRESHOLD) {\n\t\t/* Create a shmem file to store the data in.  This will permit the data\n\t\t * to be swapped out if needed.\n\t\t *\n\t\t * File content is stored encrypted with randomly generated key.\n\t\t */\n\t\tsize_t enclen = ALIGN(datalen, crypto_skcipher_blocksize(big_key_skcipher));\n\n\t\t/* prepare aligned data to encrypt */\n\t\tdata = kmalloc(enclen, GFP_KERNEL);\n\t\tif (!data)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(data, prep->data, datalen);\n\t\tmemset(data + datalen, 0x00, enclen - datalen);\n\n\t\t/* generate random key */\n\t\tenckey = kmalloc(ENC_KEY_SIZE, GFP_KERNEL);\n\t\tif (!enckey) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\n\t\tret = big_key_gen_enckey(enckey);\n\t\tif (ret)\n\t\t\tgoto err_enckey;\n\n\t\t/* encrypt aligned data */\n\t\tret = big_key_crypt(BIG_KEY_ENC, data, enclen, enckey);\n\t\tif (ret)\n\t\t\tgoto err_enckey;\n\n\t\t/* save aligned data to file */\n\t\tfile = shmem_kernel_file_setup(\"\", enclen, 0);\n\t\tif (IS_ERR(file)) {\n\t\t\tret = PTR_ERR(file);\n\t\t\tgoto err_enckey;\n\t\t}\n\n\t\twritten = kernel_write(file, data, enclen, 0);\n\t\tif (written != enclen) {\n\t\t\tret = written;\n\t\t\tif (written >= 0)\n\t\t\t\tret = -ENOMEM;\n\t\t\tgoto err_fput;\n\t\t}\n\n\t\t/* Pin the mount and dentry to the key so that we can open it again\n\t\t * later\n\t\t */\n\t\tprep->payload.data[big_key_data] = enckey;\n\t\t*path = file->f_path;\n\t\tpath_get(path);\n\t\tfput(file);\n\t\tkfree(data);\n\t} else {\n\t\t/* Just store the data in a buffer */\n\t\tvoid *data = kmalloc(datalen, GFP_KERNEL);\n\n\t\tif (!data)\n\t\t\treturn -ENOMEM;\n\n\t\tprep->payload.data[big_key_data] = data;\n\t\tmemcpy(data, prep->data, prep->datalen);\n\t}\n\treturn 0;\n\nerr_fput:\n\tfput(file);\nerr_enckey:\n\tkfree(enckey);\nerror:\n\tkfree(data);\n\treturn ret;\n}\n\n/*\n * Clear preparsement.\n */\nvoid big_key_free_preparse(struct key_preparsed_payload *prep)\n{\n\tif (prep->datalen > BIG_KEY_FILE_THRESHOLD) {\n\t\tstruct path *path = (struct path *)&prep->payload.data[big_key_path];\n\n\t\tpath_put(path);\n\t}\n\tkfree(prep->payload.data[big_key_data]);\n}\n\n/*\n * dispose of the links from a revoked keyring\n * - called with the key sem write-locked\n */\nvoid big_key_revoke(struct key *key)\n{\n\tstruct path *path = (struct path *)&key->payload.data[big_key_path];\n\n\t/* clear the quota */\n\tkey_payload_reserve(key, 0);\n\tif (key_is_instantiated(key) &&\n\t    (size_t)key->payload.data[big_key_len] > BIG_KEY_FILE_THRESHOLD)\n\t\tvfs_truncate(path, 0);\n}\n\n/*\n * dispose of the data dangling from the corpse of a big_key key\n */\nvoid big_key_destroy(struct key *key)\n{\n\tsize_t datalen = (size_t)key->payload.data[big_key_len];\n\n\tif (datalen > BIG_KEY_FILE_THRESHOLD) {\n\t\tstruct path *path = (struct path *)&key->payload.data[big_key_path];\n\n\t\tpath_put(path);\n\t\tpath->mnt = NULL;\n\t\tpath->dentry = NULL;\n\t}\n\tkfree(key->payload.data[big_key_data]);\n\tkey->payload.data[big_key_data] = NULL;\n}\n\n/*\n * describe the big_key key\n */\nvoid big_key_describe(const struct key *key, struct seq_file *m)\n{\n\tsize_t datalen = (size_t)key->payload.data[big_key_len];\n\n\tseq_puts(m, key->description);\n\n\tif (key_is_instantiated(key))\n\t\tseq_printf(m, \": %zu [%s]\",\n\t\t\t   datalen,\n\t\t\t   datalen > BIG_KEY_FILE_THRESHOLD ? \"file\" : \"buff\");\n}\n\n/*\n * read the key data\n * - the key's semaphore is read-locked\n */\nlong big_key_read(const struct key *key, char __user *buffer, size_t buflen)\n{\n\tsize_t datalen = (size_t)key->payload.data[big_key_len];\n\tlong ret;\n\n\tif (!buffer || buflen < datalen)\n\t\treturn datalen;\n\n\tif (datalen > BIG_KEY_FILE_THRESHOLD) {\n\t\tstruct path *path = (struct path *)&key->payload.data[big_key_path];\n\t\tstruct file *file;\n\t\tu8 *data;\n\t\tu8 *enckey = (u8 *)key->payload.data[big_key_data];\n\t\tsize_t enclen = ALIGN(datalen, crypto_skcipher_blocksize(big_key_skcipher));\n\n\t\tdata = kmalloc(enclen, GFP_KERNEL);\n\t\tif (!data)\n\t\t\treturn -ENOMEM;\n\n\t\tfile = dentry_open(path, O_RDONLY, current_cred());\n\t\tif (IS_ERR(file)) {\n\t\t\tret = PTR_ERR(file);\n\t\t\tgoto error;\n\t\t}\n\n\t\t/* read file to kernel and decrypt */\n\t\tret = kernel_read(file, 0, data, enclen);\n\t\tif (ret >= 0 && ret != enclen) {\n\t\t\tret = -EIO;\n\t\t\tgoto err_fput;\n\t\t}\n\n\t\tret = big_key_crypt(BIG_KEY_DEC, data, enclen, enckey);\n\t\tif (ret)\n\t\t\tgoto err_fput;\n\n\t\tret = datalen;\n\n\t\t/* copy decrypted data to user */\n\t\tif (copy_to_user(buffer, data, datalen) != 0)\n\t\t\tret = -EFAULT;\n\nerr_fput:\n\t\tfput(file);\nerror:\n\t\tkfree(data);\n\t} else {\n\t\tret = datalen;\n\t\tif (copy_to_user(buffer, key->payload.data[big_key_data],\n\t\t\t\t datalen) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\n\treturn ret;\n}\n\n/*\n * Register key type\n */\nstatic int __init big_key_init(void)\n{\n\treturn register_key_type(&key_type_big_key);\n}\n\n/*\n * Initialize big_key crypto and RNG algorithms\n */\nstatic int __init big_key_crypto_init(void)\n{\n\tint ret = -EINVAL;\n\n\t/* init RNG */\n\tbig_key_rng = crypto_alloc_rng(big_key_rng_name, 0, 0);\n\tif (IS_ERR(big_key_rng)) {\n\t\tbig_key_rng = NULL;\n\t\treturn -EFAULT;\n\t}\n\n\t/* seed RNG */\n\tret = crypto_rng_reset(big_key_rng, NULL, crypto_rng_seedsize(big_key_rng));\n\tif (ret)\n\t\tgoto error;\n\n\t/* init block cipher */\n\tbig_key_skcipher = crypto_alloc_skcipher(big_key_alg_name,\n\t\t\t\t\t\t 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(big_key_skcipher)) {\n\t\tbig_key_skcipher = NULL;\n\t\tret = -EFAULT;\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\tcrypto_free_rng(big_key_rng);\n\tbig_key_rng = NULL;\n\treturn ret;\n}\n\ndevice_initcall(big_key_init);\nlate_initcall(big_key_crypto_init);\n"], "fixing_code": ["/* Large capacity key type\n *\n * Copyright (C) 2013 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public Licence\n * as published by the Free Software Foundation; either version\n * 2 of the Licence, or (at your option) any later version.\n */\n\n#define pr_fmt(fmt) \"big_key: \"fmt\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/shmem_fs.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <keys/user-type.h>\n#include <keys/big_key-type.h>\n#include <crypto/rng.h>\n#include <crypto/skcipher.h>\n\n/*\n * Layout of key payload words.\n */\nenum {\n\tbig_key_data,\n\tbig_key_path,\n\tbig_key_path_2nd_part,\n\tbig_key_len,\n};\n\n/*\n * Crypto operation with big_key data\n */\nenum big_key_op {\n\tBIG_KEY_ENC,\n\tBIG_KEY_DEC,\n};\n\n/*\n * If the data is under this limit, there's no point creating a shm file to\n * hold it as the permanently resident metadata for the shmem fs will be at\n * least as large as the data.\n */\n#define BIG_KEY_FILE_THRESHOLD (sizeof(struct inode) + sizeof(struct dentry))\n\n/*\n * Key size for big_key data encryption\n */\n#define ENC_KEY_SIZE\t16\n\n/*\n * big_key defined keys take an arbitrary string as the description and an\n * arbitrary blob of data as the payload\n */\nstruct key_type key_type_big_key = {\n\t.name\t\t\t= \"big_key\",\n\t.preparse\t\t= big_key_preparse,\n\t.free_preparse\t\t= big_key_free_preparse,\n\t.instantiate\t\t= generic_key_instantiate,\n\t.revoke\t\t\t= big_key_revoke,\n\t.destroy\t\t= big_key_destroy,\n\t.describe\t\t= big_key_describe,\n\t.read\t\t\t= big_key_read,\n};\n\n/*\n * Crypto names for big_key data encryption\n */\nstatic const char big_key_rng_name[] = \"stdrng\";\nstatic const char big_key_alg_name[] = \"ecb(aes)\";\n\n/*\n * Crypto algorithms for big_key data encryption\n */\nstatic struct crypto_rng *big_key_rng;\nstatic struct crypto_skcipher *big_key_skcipher;\n\n/*\n * Generate random key to encrypt big_key data\n */\nstatic inline int big_key_gen_enckey(u8 *key)\n{\n\treturn crypto_rng_get_bytes(big_key_rng, key, ENC_KEY_SIZE);\n}\n\n/*\n * Encrypt/decrypt big_key data\n */\nstatic int big_key_crypt(enum big_key_op op, u8 *data, size_t datalen, u8 *key)\n{\n\tint ret = -EINVAL;\n\tstruct scatterlist sgio;\n\tSKCIPHER_REQUEST_ON_STACK(req, big_key_skcipher);\n\n\tif (crypto_skcipher_setkey(big_key_skcipher, key, ENC_KEY_SIZE)) {\n\t\tret = -EAGAIN;\n\t\tgoto error;\n\t}\n\n\tskcipher_request_set_tfm(req, big_key_skcipher);\n\tskcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\t\t\t      NULL, NULL);\n\n\tsg_init_one(&sgio, data, datalen);\n\tskcipher_request_set_crypt(req, &sgio, &sgio, datalen, NULL);\n\n\tif (op == BIG_KEY_ENC)\n\t\tret = crypto_skcipher_encrypt(req);\n\telse\n\t\tret = crypto_skcipher_decrypt(req);\n\n\tskcipher_request_zero(req);\n\nerror:\n\treturn ret;\n}\n\n/*\n * Preparse a big key\n */\nint big_key_preparse(struct key_preparsed_payload *prep)\n{\n\tstruct path *path = (struct path *)&prep->payload.data[big_key_path];\n\tstruct file *file;\n\tu8 *enckey;\n\tu8 *data = NULL;\n\tssize_t written;\n\tsize_t datalen = prep->datalen;\n\tint ret;\n\n\tret = -EINVAL;\n\tif (datalen <= 0 || datalen > 1024 * 1024 || !prep->data)\n\t\tgoto error;\n\n\t/* Set an arbitrary quota */\n\tprep->quotalen = 16;\n\n\tprep->payload.data[big_key_len] = (void *)(unsigned long)datalen;\n\n\tif (datalen > BIG_KEY_FILE_THRESHOLD) {\n\t\t/* Create a shmem file to store the data in.  This will permit the data\n\t\t * to be swapped out if needed.\n\t\t *\n\t\t * File content is stored encrypted with randomly generated key.\n\t\t */\n\t\tsize_t enclen = ALIGN(datalen, crypto_skcipher_blocksize(big_key_skcipher));\n\n\t\t/* prepare aligned data to encrypt */\n\t\tdata = kmalloc(enclen, GFP_KERNEL);\n\t\tif (!data)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(data, prep->data, datalen);\n\t\tmemset(data + datalen, 0x00, enclen - datalen);\n\n\t\t/* generate random key */\n\t\tenckey = kmalloc(ENC_KEY_SIZE, GFP_KERNEL);\n\t\tif (!enckey) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\n\t\tret = big_key_gen_enckey(enckey);\n\t\tif (ret)\n\t\t\tgoto err_enckey;\n\n\t\t/* encrypt aligned data */\n\t\tret = big_key_crypt(BIG_KEY_ENC, data, enclen, enckey);\n\t\tif (ret)\n\t\t\tgoto err_enckey;\n\n\t\t/* save aligned data to file */\n\t\tfile = shmem_kernel_file_setup(\"\", enclen, 0);\n\t\tif (IS_ERR(file)) {\n\t\t\tret = PTR_ERR(file);\n\t\t\tgoto err_enckey;\n\t\t}\n\n\t\twritten = kernel_write(file, data, enclen, 0);\n\t\tif (written != enclen) {\n\t\t\tret = written;\n\t\t\tif (written >= 0)\n\t\t\t\tret = -ENOMEM;\n\t\t\tgoto err_fput;\n\t\t}\n\n\t\t/* Pin the mount and dentry to the key so that we can open it again\n\t\t * later\n\t\t */\n\t\tprep->payload.data[big_key_data] = enckey;\n\t\t*path = file->f_path;\n\t\tpath_get(path);\n\t\tfput(file);\n\t\tkfree(data);\n\t} else {\n\t\t/* Just store the data in a buffer */\n\t\tvoid *data = kmalloc(datalen, GFP_KERNEL);\n\n\t\tif (!data)\n\t\t\treturn -ENOMEM;\n\n\t\tprep->payload.data[big_key_data] = data;\n\t\tmemcpy(data, prep->data, prep->datalen);\n\t}\n\treturn 0;\n\nerr_fput:\n\tfput(file);\nerr_enckey:\n\tkfree(enckey);\nerror:\n\tkfree(data);\n\treturn ret;\n}\n\n/*\n * Clear preparsement.\n */\nvoid big_key_free_preparse(struct key_preparsed_payload *prep)\n{\n\tif (prep->datalen > BIG_KEY_FILE_THRESHOLD) {\n\t\tstruct path *path = (struct path *)&prep->payload.data[big_key_path];\n\n\t\tpath_put(path);\n\t}\n\tkfree(prep->payload.data[big_key_data]);\n}\n\n/*\n * dispose of the links from a revoked keyring\n * - called with the key sem write-locked\n */\nvoid big_key_revoke(struct key *key)\n{\n\tstruct path *path = (struct path *)&key->payload.data[big_key_path];\n\n\t/* clear the quota */\n\tkey_payload_reserve(key, 0);\n\tif (key_is_instantiated(key) &&\n\t    (size_t)key->payload.data[big_key_len] > BIG_KEY_FILE_THRESHOLD)\n\t\tvfs_truncate(path, 0);\n}\n\n/*\n * dispose of the data dangling from the corpse of a big_key key\n */\nvoid big_key_destroy(struct key *key)\n{\n\tsize_t datalen = (size_t)key->payload.data[big_key_len];\n\n\tif (datalen > BIG_KEY_FILE_THRESHOLD) {\n\t\tstruct path *path = (struct path *)&key->payload.data[big_key_path];\n\n\t\tpath_put(path);\n\t\tpath->mnt = NULL;\n\t\tpath->dentry = NULL;\n\t}\n\tkfree(key->payload.data[big_key_data]);\n\tkey->payload.data[big_key_data] = NULL;\n}\n\n/*\n * describe the big_key key\n */\nvoid big_key_describe(const struct key *key, struct seq_file *m)\n{\n\tsize_t datalen = (size_t)key->payload.data[big_key_len];\n\n\tseq_puts(m, key->description);\n\n\tif (key_is_instantiated(key))\n\t\tseq_printf(m, \": %zu [%s]\",\n\t\t\t   datalen,\n\t\t\t   datalen > BIG_KEY_FILE_THRESHOLD ? \"file\" : \"buff\");\n}\n\n/*\n * read the key data\n * - the key's semaphore is read-locked\n */\nlong big_key_read(const struct key *key, char __user *buffer, size_t buflen)\n{\n\tsize_t datalen = (size_t)key->payload.data[big_key_len];\n\tlong ret;\n\n\tif (!buffer || buflen < datalen)\n\t\treturn datalen;\n\n\tif (datalen > BIG_KEY_FILE_THRESHOLD) {\n\t\tstruct path *path = (struct path *)&key->payload.data[big_key_path];\n\t\tstruct file *file;\n\t\tu8 *data;\n\t\tu8 *enckey = (u8 *)key->payload.data[big_key_data];\n\t\tsize_t enclen = ALIGN(datalen, crypto_skcipher_blocksize(big_key_skcipher));\n\n\t\tdata = kmalloc(enclen, GFP_KERNEL);\n\t\tif (!data)\n\t\t\treturn -ENOMEM;\n\n\t\tfile = dentry_open(path, O_RDONLY, current_cred());\n\t\tif (IS_ERR(file)) {\n\t\t\tret = PTR_ERR(file);\n\t\t\tgoto error;\n\t\t}\n\n\t\t/* read file to kernel and decrypt */\n\t\tret = kernel_read(file, 0, data, enclen);\n\t\tif (ret >= 0 && ret != enclen) {\n\t\t\tret = -EIO;\n\t\t\tgoto err_fput;\n\t\t}\n\n\t\tret = big_key_crypt(BIG_KEY_DEC, data, enclen, enckey);\n\t\tif (ret)\n\t\t\tgoto err_fput;\n\n\t\tret = datalen;\n\n\t\t/* copy decrypted data to user */\n\t\tif (copy_to_user(buffer, data, datalen) != 0)\n\t\t\tret = -EFAULT;\n\nerr_fput:\n\t\tfput(file);\nerror:\n\t\tkfree(data);\n\t} else {\n\t\tret = datalen;\n\t\tif (copy_to_user(buffer, key->payload.data[big_key_data],\n\t\t\t\t datalen) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\n\treturn ret;\n}\n\n/*\n * Register key type\n */\nstatic int __init big_key_init(void)\n{\n\tstruct crypto_skcipher *cipher;\n\tstruct crypto_rng *rng;\n\tint ret;\n\n\trng = crypto_alloc_rng(big_key_rng_name, 0, 0);\n\tif (IS_ERR(rng)) {\n\t\tpr_err(\"Can't alloc rng: %ld\\n\", PTR_ERR(rng));\n\t\treturn PTR_ERR(rng);\n\t}\n\n\tbig_key_rng = rng;\n\n\t/* seed RNG */\n\tret = crypto_rng_reset(rng, NULL, crypto_rng_seedsize(rng));\n\tif (ret) {\n\t\tpr_err(\"Can't reset rng: %d\\n\", ret);\n\t\tgoto error_rng;\n\t}\n\n\t/* init block cipher */\n\tcipher = crypto_alloc_skcipher(big_key_alg_name, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(cipher)) {\n\t\tret = PTR_ERR(cipher);\n\t\tpr_err(\"Can't alloc crypto: %d\\n\", ret);\n\t\tgoto error_rng;\n\t}\n\n\tbig_key_skcipher = cipher;\n\n\tret = register_key_type(&key_type_big_key);\n\tif (ret < 0) {\n\t\tpr_err(\"Can't register type: %d\\n\", ret);\n\t\tgoto error_cipher;\n\t}\n\n\treturn 0;\n\nerror_cipher:\n\tcrypto_free_skcipher(big_key_skcipher);\nerror_rng:\n\tcrypto_free_rng(big_key_rng);\n\treturn ret;\n}\n\nlate_initcall(big_key_init);\n"], "filenames": ["security/keys/big_key.c"], "buggy_code_start_loc": [11], "buggy_code_end_loc": [385], "fixing_code_start_loc": [12], "fixing_code_end_loc": [390], "type": "CWE-476", "message": "security/keys/big_key.c in the Linux kernel before 4.8.7 mishandles unsuccessful crypto registration in conjunction with successful key-type registration, which allows local users to cause a denial of service (NULL pointer dereference and panic) or possibly have unspecified other impact via a crafted application that uses the big_key data type.", "other": {"cve": {"id": "CVE-2016-9313", "sourceIdentifier": "cve@mitre.org", "published": "2016-11-28T03:59:15.033", "lastModified": "2022-12-09T18:27:24.417", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "security/keys/big_key.c in the Linux kernel before 4.8.7 mishandles unsuccessful crypto registration in conjunction with successful key-type registration, which allows local users to cause a denial of service (NULL pointer dereference and panic) or possibly have unspecified other impact via a crafted application that uses the big_key data type."}, {"lang": "es", "value": "security/keys/big_key.c en el kernel Linux en versiones anteriores a 4.8.7 maneja incorrectamente un registro criptogr\u00e1fico no exitoso en conjunci\u00f3n con un registro key-type exitoso,lo que permite a usuarios locales provocar una denegaci\u00f3n de servicio (referencia al puntero NULO y p\u00e1nico) o tener otros posibles impactos no especificados a trav\u00e9s de una aplicaci\u00f3n manipulada que utiliza el tipo de dato big_key."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 9.3}, "baseSeverity": "HIGH", "exploitabilityScore": 8.6, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.7", "versionEndExcluding": "4.8.7", "matchCriteriaId": "F84F32C0-3005-4EF3-8E51-3B69041D53AC"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=7df3e59c3d1df4f87fe874c7956ef7a3d2f4d5fb", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.8.7", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/07/22/1", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/94546", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/torvalds/linux/commit/7df3e59c3d1df4f87fe874c7956ef7a3d2f4d5fb", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/7df3e59c3d1df4f87fe874c7956ef7a3d2f4d5fb"}}