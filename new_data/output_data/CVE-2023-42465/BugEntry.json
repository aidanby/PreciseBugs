{"buggy_code": ["/*\n * SPDX-License-Identifier: ISC\n *\n * Copyright (c) 1999-2005, 2010-2015 Todd C. Miller <Todd.Miller@sudo.ws>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n *\n * Sponsored in part by the Defense Advanced Research Projects\n * Agency (DARPA) and Air Force Research Laboratory, Air Force\n * Materiel Command, USAF, under agreement number F39502-99-1-0512.\n */\n\n/*\n * This is an open source non-commercial project. Dear PVS-Studio, please check it.\n * PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n */\n\n#include <config.h>\n\n#include <sys/types.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <pwd.h>\n\n#include \"sudoers.h\"\n#include \"sudo_auth.h\"\n\n#define DESLEN\t\t\t13\n#define HAS_AGEINFO(p, l)\t(l == 18 && p[DESLEN] == ',')\n\nint\nsudo_passwd_init(const struct sudoers_context *ctx, struct passwd *pw,\n    sudo_auth *auth)\n{\n    debug_decl(sudo_passwd_init, SUDOERS_DEBUG_AUTH);\n\n    /* Only initialize once. */\n    if (auth->data != NULL)\n\tdebug_return_int(AUTH_SUCCESS);\n\n#ifdef HAVE_SKEYACCESS\n    if (skeyaccess(pw, ctx->user.tty, NULL, NULL) == 0)\n\tdebug_return_int(AUTH_FAILURE);\n#endif\n    sudo_setspent();\n    auth->data = sudo_getepw(pw);\n    sudo_endspent();\n    debug_return_int(auth->data ? AUTH_SUCCESS : AUTH_ERROR);\n}\n\n#ifdef HAVE_CRYPT\nint\nsudo_passwd_verify(const struct sudoers_context *ctx, struct passwd *pw,\n    const char *pass, sudo_auth *auth, struct sudo_conv_callback *callback)\n{\n    char des_pass[9], *epass;\n    char *pw_epasswd = auth->data;\n    size_t pw_len;\n    int matched = 0;\n    debug_decl(sudo_passwd_verify, SUDOERS_DEBUG_AUTH);\n\n    /* An empty plain-text password must match an empty encrypted password. */\n    if (pass[0] == '\\0')\n\tdebug_return_int(pw_epasswd[0] ? AUTH_FAILURE : AUTH_SUCCESS);\n\n    /*\n     * Truncate to 8 chars if standard DES since not all crypt()'s do this.\n     */\n    pw_len = strlen(pw_epasswd);\n    if (pw_len == DESLEN || HAS_AGEINFO(pw_epasswd, pw_len)) {\n\tstrlcpy(des_pass, pass, sizeof(des_pass));\n\tpass = des_pass;\n    }\n\n    /*\n     * Normal UN*X password check.\n     * HP-UX may add aging info (separated by a ',') at the end so\n     * only compare the first DESLEN characters in that case.\n     */\n    epass = (char *) crypt(pass, pw_epasswd);\n    if (epass != NULL) {\n\tif (HAS_AGEINFO(pw_epasswd, pw_len) && strlen(epass) == DESLEN)\n\t    matched = !strncmp(pw_epasswd, epass, DESLEN);\n\telse\n\t    matched = !strcmp(pw_epasswd, epass);\n    }\n\n    explicit_bzero(des_pass, sizeof(des_pass));\n\n    debug_return_int(matched ? AUTH_SUCCESS : AUTH_FAILURE);\n}\n#else\nint\nsudo_passwd_verify(const struct sudoers_context *ctx, struct passwd *pw,\n    const char *pass, sudo_auth *auth, struct sudo_conv_callback *callback)\n{\n    char *pw_passwd = auth->data;\n    int matched;\n    debug_decl(sudo_passwd_verify, SUDOERS_DEBUG_AUTH);\n\n    /* Simple string compare for systems without crypt(). */\n    matched = !strcmp(pass, pw_passwd);\n\n    debug_return_int(matched ? AUTH_SUCCESS : AUTH_FAILURE);\n}\n#endif\n\nint\nsudo_passwd_cleanup(const struct sudoers_context *ctx, struct passwd *pw,\n    sudo_auth *auth, bool force)\n{\n    debug_decl(sudo_passwd_cleanup, SUDOERS_DEBUG_AUTH);\n\n    if (auth->data != NULL) {\n\t/* Zero out encrypted password before freeing. */\n\tsize_t len = strlen((char *)auth->data);\n\tfreezero(auth->data, len);\n\tauth->data = NULL;\n    }\n\n    debug_return_int(AUTH_SUCCESS);\n}\n", "/*\n * SPDX-License-Identifier: ISC\n *\n * Copyright (c) 1999-2005, 2008-2020 Todd C. Miller <Todd.Miller@sudo.ws>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n *\n * Sponsored in part by the Defense Advanced Research Projects\n * Agency (DARPA) and Air Force Research Laboratory, Air Force\n * Materiel Command, USAF, under agreement number F39502-99-1-0512.\n */\n\n/*\n * This is an open source non-commercial project. Dear PVS-Studio, please check it.\n * PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n */\n\n#include <config.h>\n\n#include <sys/types.h>\n#include <stdio.h>\n#include <stdlib.h>\n#if defined(HAVE_STDINT_H)\n# include <stdint.h>\n#elif defined(HAVE_INTTYPES_H)\n# include <inttypes.h>\n#endif\n#include <string.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <time.h>\n#include <signal.h>\n\n#include \"sudoers.h\"\n#include \"sudo_auth.h\"\n#include \"insults.h\"\n#include \"timestamp.h\"\n\nstatic sudo_auth auth_switch[] = {\n/* Standalone entries first */\n#ifdef HAVE_AIXAUTH\n    AUTH_ENTRY(\"aixauth\", FLAG_STANDALONE, sudo_aix_init, NULL, sudo_aix_verify, NULL, sudo_aix_cleanup, NULL, NULL)\n#endif\n#ifdef HAVE_PAM\n    AUTH_ENTRY(\"pam\", FLAG_STANDALONE, sudo_pam_init, NULL, sudo_pam_verify, sudo_pam_approval, sudo_pam_cleanup, sudo_pam_begin_session, sudo_pam_end_session)\n#endif\n#ifdef HAVE_SECURID\n    AUTH_ENTRY(\"SecurId\", FLAG_STANDALONE, sudo_securid_init, sudo_securid_setup, sudo_securid_verify, NULL, NULL, NULL, NULL)\n#endif\n#ifdef HAVE_SIA_SES_INIT\n    AUTH_ENTRY(\"sia\", FLAG_STANDALONE, NULL, sudo_sia_setup, sudo_sia_verify, NULL, sudo_sia_cleanup, sudo_sia_begin_session, NULL)\n#endif\n#ifdef HAVE_FWTK\n    AUTH_ENTRY(\"fwtk\", FLAG_STANDALONE, sudo_fwtk_init, NULL, sudo_fwtk_verify, NULL, sudo_fwtk_cleanup, NULL, NULL)\n#endif\n#ifdef HAVE_BSD_AUTH_H\n    AUTH_ENTRY(\"bsdauth\", FLAG_STANDALONE, bsdauth_init, NULL, bsdauth_verify, bsdauth_approval, bsdauth_cleanup, NULL, NULL)\n#endif\n\n/* Non-standalone entries */\n#ifndef WITHOUT_PASSWD\n    AUTH_ENTRY(\"passwd\", 0, sudo_passwd_init, NULL, sudo_passwd_verify, NULL, sudo_passwd_cleanup, NULL, NULL)\n#endif\n#if defined(HAVE_GETPRPWNAM) && !defined(WITHOUT_PASSWD)\n    AUTH_ENTRY(\"secureware\", 0, sudo_secureware_init, NULL, sudo_secureware_verify, NULL, sudo_secureware_cleanup, NULL, NULL)\n#endif\n#ifdef HAVE_AFS\n    AUTH_ENTRY(\"afs\", 0, NULL, NULL, sudo_afs_verify, NULL, NULL, NULL, NULL)\n#endif\n#ifdef HAVE_DCE\n    AUTH_ENTRY(\"dce\", 0, NULL, NULL, sudo_dce_verify, NULL, NULL, NULL, NULL)\n#endif\n#ifdef HAVE_KERB5\n    AUTH_ENTRY(\"kerb5\", 0, sudo_krb5_init, sudo_krb5_setup, sudo_krb5_verify, NULL, sudo_krb5_cleanup, NULL, NULL)\n#endif\n#ifdef HAVE_SKEY\n    AUTH_ENTRY(\"S/Key\", 0, NULL, sudo_rfc1938_setup, sudo_rfc1938_verify, NULL, NULL, NULL, NULL)\n#endif\n#ifdef HAVE_OPIE\n    AUTH_ENTRY(\"OPIE\", 0, NULL, sudo_rfc1938_setup, sudo_rfc1938_verify, NULL, NULL, NULL, NULL)\n#endif\n    AUTH_ENTRY(NULL, 0, NULL, NULL, NULL, NULL, NULL, NULL, NULL)\n};\n\nstatic bool standalone;\n\n/*\n * Initialize sudoers authentication method(s).\n * Returns 0 on success and -1 on error.\n */\nint\nsudo_auth_init(const struct sudoers_context *ctx, struct passwd *pw,\n    unsigned int mode)\n{\n    sudo_auth *auth;\n    int status = AUTH_SUCCESS;\n    debug_decl(sudo_auth_init, SUDOERS_DEBUG_AUTH);\n\n    if (auth_switch[0].name == NULL)\n\tdebug_return_int(0);\n\n    /* Initialize auth methods and unconfigure the method if necessary. */\n    for (auth = auth_switch; auth->name; auth++) {\n\tif (ISSET(mode, MODE_NONINTERACTIVE))\n\t    SET(auth->flags, FLAG_NONINTERACTIVE);\n\tif (auth->init && !IS_DISABLED(auth)) {\n\t    /* Disable if it failed to init unless there was a fatal error. */\n\t    status = (auth->init)(ctx, pw, auth);\n\t    if (status == AUTH_FAILURE)\n\t\tSET(auth->flags, FLAG_DISABLED);\n\t    else if (status == AUTH_ERROR)\n\t\tbreak;\t\t/* assume error msg already printed */\n\t}\n    }\n\n    /*\n     * Make sure we haven't mixed standalone and shared auth methods.\n     * If there are multiple standalone methods, only use the first one.\n     */\n    if ((standalone = IS_STANDALONE(&auth_switch[0]))) {\n\tbool found = false;\n\tfor (auth = auth_switch; auth->name; auth++) {\n\t    if (IS_DISABLED(auth))\n\t\tcontinue;\n\t    if (!IS_STANDALONE(auth)) {\n\t\taudit_failure(ctx, ctx->runas.argv,\n\t\t    N_(\"invalid authentication methods\"));\n\t\tlog_warningx(ctx, SLOG_SEND_MAIL,\n\t\t    N_(\"Invalid authentication methods compiled into sudo!  \"\n\t\t    \"You may not mix standalone and non-standalone authentication.\"));\n\t\tdebug_return_int(-1);\n\t    }\n\t    if (!found) {\n\t\t/* Found first standalone method. */\n\t\tfound = true;\n\t\tcontinue;\n\t    }\n\t    /* Disable other standalone methods. */\n\t    SET(auth->flags, FLAG_DISABLED);\n\t}\n    }\n\n    /* Set FLAG_ONEANDONLY if there is only one auth method. */\n    for (auth = auth_switch; auth->name; auth++) {\n\t/* Find first enabled auth method. */\n\tif (!IS_DISABLED(auth)) {\n\t    sudo_auth *first = auth;\n\t    /* Check for others. */\n\t    for (; auth->name; auth++) {\n\t\tif (!IS_DISABLED(auth))\n\t\t    break;\n\t    }\n\t    if (auth->name == NULL)\n\t\tSET(first->flags, FLAG_ONEANDONLY);\n\t    break;\n\t}\n    }\n\n    debug_return_int(status == AUTH_ERROR ? -1 : 0);\n}\n\n/*\n * Cleanup all authentication approval methods.\n * Returns true on success, false on failure and -1 on error.\n */\nint\nsudo_auth_approval(const struct sudoers_context *ctx, struct passwd *pw,\n    unsigned int validated, bool exempt)\n{\n    sudo_auth *auth;\n    debug_decl(sudo_auth_approval, SUDOERS_DEBUG_AUTH);\n\n    /* Call approval routines. */\n    for (auth = auth_switch; auth->name; auth++) {\n\tif (auth->approval && !IS_DISABLED(auth)) {\n\t    int status = (auth->approval)(ctx, pw, auth, exempt);\n\t    if (status != AUTH_SUCCESS) {\n\t\t/* Assume error msg already printed. */\n\t\tlog_auth_failure(ctx, validated, 0);\n\t\tdebug_return_int(status == AUTH_FAILURE ? false : -1);\n\t    }\n\t}\n    }\n    debug_return_int(true);\n}\n\n/*\n * Cleanup all authentication methods.\n * Returns 0 on success and -1 on error.\n */\nint\nsudo_auth_cleanup(const struct sudoers_context *ctx, struct passwd *pw,\n    bool force)\n{\n    sudo_auth *auth;\n    debug_decl(sudo_auth_cleanup, SUDOERS_DEBUG_AUTH);\n\n    /* Call cleanup routines. */\n    for (auth = auth_switch; auth->name; auth++) {\n\tif (auth->cleanup && !IS_DISABLED(auth)) {\n\t    int status = (auth->cleanup)(ctx, pw, auth, force);\n\t    if (status == AUTH_ERROR) {\n\t\t/* Assume error msg already printed. */\n\t\tdebug_return_int(-1);\n\t    }\n\t}\n    }\n    debug_return_int(0);\n}\n\nstatic void\npass_warn(void)\n{\n    const char *warning = def_badpass_message;\n    debug_decl(pass_warn, SUDOERS_DEBUG_AUTH);\n\n#ifdef INSULT\n    if (def_insults)\n\twarning = INSULT;\n#endif\n    sudo_printf(SUDO_CONV_ERROR_MSG|SUDO_CONV_PREFER_TTY, \"%s\\n\", warning);\n\n    debug_return;\n}\n\nstatic bool\nuser_interrupted(void)\n{\n    sigset_t mask;\n\n    return (sigpending(&mask) == 0 &&\n\t(sigismember(&mask, SIGINT) || sigismember(&mask, SIGQUIT)));\n}\n\n/*\n * Verify the specified user.\n * Returns true if verified, false if not or -1 on error.\n */\nint\nverify_user(const struct sudoers_context *ctx, struct passwd *pw, char *prompt,\n    unsigned int validated, struct sudo_conv_callback *callback)\n{\n    unsigned int ntries;\n    int ret, status, success = AUTH_FAILURE;\n    sudo_auth *auth;\n    sigset_t mask, omask;\n    struct sigaction sa, saved_sigtstp;\n    debug_decl(verify_user, SUDOERS_DEBUG_AUTH);\n\n    /* Make sure we have at least one auth method. */\n    if (auth_switch[0].name == NULL) {\n\taudit_failure(ctx, ctx->runas.argv, N_(\"no authentication methods\"));\n    \tlog_warningx(ctx, SLOG_SEND_MAIL,\n\t    N_(\"There are no authentication methods compiled into sudo!  \"\n\t    \"If you want to turn off authentication, use the \"\n\t    \"--disable-authentication configure option.\"));\n\tdebug_return_int(-1);\n    }\n\n    /* Enable suspend during password entry. */\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = SA_RESTART;\n    sa.sa_handler = SIG_DFL;\n    (void) sigaction(SIGTSTP, &sa, &saved_sigtstp);\n\n    /*\n     * We treat authentication as a critical section and block\n     * keyboard-generated signals such as SIGINT and SIGQUIT\n     * which might otherwise interrupt a sleep(3).\n     * They are temporarily unblocked by auth_getpass().\n     */\n    sigemptyset(&mask);\n    sigaddset(&mask, SIGINT);\n    sigaddset(&mask, SIGQUIT);\n    (void) sigprocmask(SIG_BLOCK, &mask, &omask);\n\n    for (ntries = 0; ntries < def_passwd_tries; ntries++) {\n\tint num_methods = 0;\n\tchar *pass = NULL;\n\n\t/* If user attempted to interrupt password verify, quit now. */\n\tif (user_interrupted())\n\t    goto done;\n\n\tif (ntries != 0)\n\t    pass_warn();\n\n\t/* Do any per-method setup and unconfigure the method if needed */\n\tfor (auth = auth_switch; auth->name; auth++) {\n\t    if (IS_DISABLED(auth))\n\t\tcontinue;\n\t    num_methods++;\n\t    if (auth->setup != NULL) {\n\t\tstatus = (auth->setup)(ctx, pw, &prompt, auth);\n\t\tif (status == AUTH_FAILURE)\n\t\t    SET(auth->flags, FLAG_DISABLED);\n\t\telse if (status == AUTH_NONINTERACTIVE)\n\t\t    goto done;\n\t\telse if (status == AUTH_ERROR || user_interrupted())\n\t\t    goto done;\t\t/* assume error msg already printed */\n\t    }\n\t}\n\tif (num_methods == 0) {\n\t    audit_failure(ctx, ctx->runas.argv,\n\t\tN_(\"no authentication methods\"));\n\t    log_warningx(ctx, SLOG_SEND_MAIL,\n\t\tN_(\"Unable to initialize authentication methods.\"));\n\t    debug_return_int(-1);\n\t}\n\n\t/* Get the password unless the auth function will do it for us */\n\tif (!standalone) {\n\t    if (IS_NONINTERACTIVE(&auth_switch[0])) {\n\t\tsuccess = AUTH_NONINTERACTIVE;\n\t\tgoto done;\n\t    }\n\t    pass = auth_getpass(prompt, SUDO_CONV_PROMPT_ECHO_OFF, callback);\n\t    if (pass == NULL)\n\t\tbreak;\n\t}\n\n\t/* Call authentication functions. */\n\tfor (auth = auth_switch; auth->name; auth++) {\n\t    if (IS_DISABLED(auth))\n\t\tcontinue;\n\n\t    success = auth->status = (auth->verify)(ctx, pw,\n\t\tstandalone ? prompt : pass, auth, callback);\n\t    if (success != AUTH_FAILURE)\n\t\tbreak;\n\t}\n\tif (pass != NULL)\n\t    freezero(pass, strlen(pass));\n\n\tif (success != AUTH_FAILURE)\n\t    goto done;\n    }\n\ndone:\n    /* Restore signal handlers and signal mask. */\n    (void) sigaction(SIGTSTP, &saved_sigtstp, NULL);\n    (void) sigprocmask(SIG_SETMASK, &omask, NULL);\n\n    switch (success) {\n\tcase AUTH_SUCCESS:\n\t    ret = true;\n\t    break;\n\tcase AUTH_INTR:\n\tcase AUTH_FAILURE:\n\t    if (ntries != 0)\n\t\tSET(validated, FLAG_BAD_PASSWORD);\n\t    log_auth_failure(ctx, validated, ntries);\n\t    ret = false;\n\t    break;\n\tcase AUTH_NONINTERACTIVE:\n\t    SET(validated, FLAG_NO_USER_INPUT);\n\t    FALLTHROUGH;\n\tcase AUTH_ERROR:\n\tdefault:\n\t    log_auth_failure(ctx, validated, 0);\n\t    ret = -1;\n\t    break;\n    }\n\n    debug_return_int(ret);\n}\n\n/*\n * Call authentication method begin session hooks.\n * Returns 1 on success and -1 on error.\n */\nint\nsudo_auth_begin_session(const struct sudoers_context *ctx, struct passwd *pw,\n    char **user_env[])\n{\n    sudo_auth *auth;\n    debug_decl(sudo_auth_begin_session, SUDOERS_DEBUG_AUTH);\n\n    for (auth = auth_switch; auth->name; auth++) {\n\tif (auth->begin_session && !IS_DISABLED(auth)) {\n\t    int status = (auth->begin_session)(ctx, pw, user_env, auth);\n\t    if (status != AUTH_SUCCESS) {\n\t\t/* Assume error msg already printed. */\n\t\tdebug_return_int(-1);\n\t    }\n\t}\n    }\n    debug_return_int(1);\n}\n\nbool\nsudo_auth_needs_end_session(void)\n{\n    sudo_auth *auth;\n    bool needed = false;\n    debug_decl(sudo_auth_needs_end_session, SUDOERS_DEBUG_AUTH);\n\n    for (auth = auth_switch; auth->name; auth++) {\n\tif (auth->end_session && !IS_DISABLED(auth)) {\n\t    needed = true;\n\t    break;\n\t}\n    }\n    debug_return_bool(needed);\n}\n\n/*\n * Call authentication method end session hooks.\n * Returns 1 on success and -1 on error.\n */\nint\nsudo_auth_end_session(void)\n{\n    sudo_auth *auth;\n    int status;\n    debug_decl(sudo_auth_end_session, SUDOERS_DEBUG_AUTH);\n\n    for (auth = auth_switch; auth->name; auth++) {\n\tif (auth->end_session && !IS_DISABLED(auth)) {\n\t    status = (auth->end_session)(auth);\n\t    if (status == AUTH_ERROR) {\n\t\t/* Assume error msg already printed. */\n\t\tdebug_return_int(-1);\n\t    }\n\t}\n    }\n    debug_return_int(1);\n}\n\n/*\n * Prompts the user for a password using the conversation function.\n * Returns the plaintext password or NULL.\n * The user is responsible for freeing the returned value.\n */\nchar *\nauth_getpass(const char *prompt, int type, struct sudo_conv_callback *callback)\n{\n    struct sudo_conv_message msg;\n    struct sudo_conv_reply repl;\n    sigset_t mask, omask;\n    debug_decl(auth_getpass, SUDOERS_DEBUG_AUTH);\n\n    /* Display lecture if needed and we haven't already done so. */\n    display_lecture(callback);\n\n    /* Mask user input if pwfeedback set and echo is off. */\n    if (type == SUDO_CONV_PROMPT_ECHO_OFF && def_pwfeedback)\n\ttype = SUDO_CONV_PROMPT_MASK;\n\n    /* If visiblepw set, do not error out if there is no tty. */\n    if (def_visiblepw)\n\ttype |= SUDO_CONV_PROMPT_ECHO_OK;\n\n    /* Unblock SIGINT and SIGQUIT during password entry. */\n    /* XXX - do in tgetpass() itself instead? */\n    sigemptyset(&mask);\n    sigaddset(&mask, SIGINT);\n    sigaddset(&mask, SIGQUIT);\n    (void) sigprocmask(SIG_UNBLOCK, &mask, &omask);\n\n    /* Call conversation function. */\n    memset(&msg, 0, sizeof(msg));\n    msg.msg_type = type;\n    msg.timeout = (int)def_passwd_timeout.tv_sec;\n    msg.msg = prompt;\n    memset(&repl, 0, sizeof(repl));\n    sudo_conv(1, &msg, &repl, callback);\n    /* XXX - check for ENOTTY? */\n\n    /* Restore previous signal mask. */\n    (void) sigprocmask(SIG_SETMASK, &omask, NULL);\n\n    debug_return_str_masked(repl.reply);\n}\n\nvoid\ndump_auth_methods(void)\n{\n    sudo_auth *auth;\n    debug_decl(dump_auth_methods, SUDOERS_DEBUG_AUTH);\n\n    sudo_printf(SUDO_CONV_INFO_MSG, _(\"Authentication methods:\"));\n    for (auth = auth_switch; auth->name; auth++)\n\tsudo_printf(SUDO_CONV_INFO_MSG, \" '%s'\", auth->name);\n    sudo_printf(SUDO_CONV_INFO_MSG, \"\\n\");\n\n    debug_return;\n}\n", "/*\n * SPDX-License-Identifier: ISC\n *\n * Copyright (c) 1999-2005, 2007-2016, 2018 Todd C. Miller <Todd.Miller@sudo.ws>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#ifndef SUDO_AUTH_H\n#define SUDO_AUTH_H\n\n/* Auth function return values.  */\n#define AUTH_SUCCESS\t\t0\n#define AUTH_FAILURE\t\t1\n#define AUTH_INTR\t\t2\n#define AUTH_ERROR\t\t3\n#define AUTH_NONINTERACTIVE\t4\n\ntypedef struct sudo_auth {\n    unsigned int flags;\t\t/* various flags, see below */\n    int status;\t\t\t/* status from verify routine */\n    const char *name;\t\t/* name of the method as a string */\n    void *data;\t\t\t/* method-specific data pointer */\n    int (*init)(const struct sudoers_context *ctx, struct passwd *pw, struct sudo_auth *auth);\n    int (*setup)(const struct sudoers_context *ctx, struct passwd *pw, char **prompt, struct sudo_auth *auth);\n    int (*verify)(const struct sudoers_context *ctx, struct passwd *pw, const char *p, struct sudo_auth *auth, struct sudo_conv_callback *callback);\n    int (*approval)(const struct sudoers_context *ctx, struct passwd *pw, struct sudo_auth *auth, bool exempt);\n    int (*cleanup)(const struct sudoers_context *ctx, struct passwd *pw, struct sudo_auth *auth, bool force);\n    int (*begin_session)(const struct sudoers_context *ctx, struct passwd *pw, char **user_env[], struct sudo_auth *auth);\n    int (*end_session)(struct sudo_auth *auth);\n} sudo_auth;\n\n/* Values for sudo_auth.flags.  */\n#define FLAG_DISABLED\t\t0x02U\t/* method disabled */\n#define FLAG_STANDALONE\t\t0x04U\t/* standalone auth method */\n#define FLAG_ONEANDONLY\t\t0x08U\t/* one and only auth method */\n#define FLAG_NONINTERACTIVE\t0x10U\t/* no user input allowed */\n\n/* Shortcuts for using the flags above. */\n#define IS_DISABLED(x)\t\t((x)->flags & FLAG_DISABLED)\n#define IS_STANDALONE(x)\t((x)->flags & FLAG_STANDALONE)\n#define IS_ONEANDONLY(x)\t((x)->flags & FLAG_ONEANDONLY)\n#define IS_NONINTERACTIVE(x)\t((x)->flags & FLAG_NONINTERACTIVE)\n\n/* Like tgetpass() but uses conversation function */\nchar *auth_getpass(const char *prompt, int type, struct sudo_conv_callback *callback);\n\n/* Pointer to conversation function to use with auth_getpass(). */\nextern sudo_conv_t sudo_conv;\n\n/* Prototypes for standalone methods */\nint bsdauth_init(const struct sudoers_context *ctx, struct passwd *pw, sudo_auth *auth);\nint bsdauth_verify(const struct sudoers_context *ctx, struct passwd *pw, const char *prompt, sudo_auth *auth, struct sudo_conv_callback *callback);\nint bsdauth_approval(const struct sudoers_context *ctx, struct passwd *pw, sudo_auth *auth, bool exempt);\nint bsdauth_cleanup(const struct sudoers_context *ctx, struct passwd *pw, sudo_auth *auth, bool force);\nvoid bsdauth_set_style(const char *style);\nint sudo_aix_init(const struct sudoers_context *ctx, struct passwd *pw, sudo_auth *auth);\nint sudo_aix_verify(const struct sudoers_context *ctx, struct passwd *pw, const char *pass, sudo_auth *auth, struct sudo_conv_callback *callback);\nint sudo_aix_cleanup(const struct sudoers_context *ctx, struct passwd *pw, sudo_auth *auth, bool force);\nint sudo_fwtk_init(const struct sudoers_context *ctx, struct passwd *pw, sudo_auth *auth);\nint sudo_fwtk_verify(const struct sudoers_context *ctx, struct passwd *pw, const char *prompt, sudo_auth *auth, struct sudo_conv_callback *callback);\nint sudo_fwtk_cleanup(const struct sudoers_context *ctx, struct passwd *pw, sudo_auth *auth, bool force);\nint sudo_pam_init(const struct sudoers_context *ctx, struct passwd *pw, sudo_auth *auth);\nint sudo_pam_init_quiet(const struct sudoers_context *ctx, struct passwd *pw, sudo_auth *auth);\nint sudo_pam_verify(const struct sudoers_context *ctx, struct passwd *pw, const char *prompt, sudo_auth *auth, struct sudo_conv_callback *callback);\nint sudo_pam_approval(const struct sudoers_context *ctx, struct passwd *pw, sudo_auth *auth, bool exempt);\nint sudo_pam_cleanup(const struct sudoers_context *ctx, struct passwd *pw, sudo_auth *auth, bool force);\nint sudo_pam_begin_session(const struct sudoers_context *ctx, struct passwd *pw, char **user_env[], sudo_auth *auth);\nint sudo_pam_end_session(sudo_auth *auth);\nint sudo_securid_init(const struct sudoers_context *ctx, struct passwd *pw, sudo_auth *auth);\nint sudo_securid_setup(const struct sudoers_context *ctx, struct passwd *pw, char **prompt, sudo_auth *auth);\nint sudo_securid_verify(const struct sudoers_context *ctx, struct passwd *pw, const char *pass, sudo_auth *auth, struct sudo_conv_callback *callback);\nint sudo_sia_setup(const struct sudoers_context *ctx, struct passwd *pw, char **prompt, sudo_auth *auth);\nint sudo_sia_verify(const struct sudoers_context *ctx, struct passwd *pw, const char *prompt, sudo_auth *auth, struct sudo_conv_callback *callback);\nint sudo_sia_cleanup(const struct sudoers_context *ctx, struct passwd *pw, sudo_auth *auth, bool force);\nint sudo_sia_begin_session(const struct sudoers_context *ctx, struct passwd *pw, char **user_env[], sudo_auth *auth);\n\n/* Prototypes for normal methods */\nint sudo_afs_verify(const struct sudoers_context *ctx, struct passwd *pw, const char *pass, sudo_auth *auth, struct sudo_conv_callback *callback);\nint sudo_dce_verify(const struct sudoers_context *ctx, struct passwd *pw, const char *pass, sudo_auth *auth, struct sudo_conv_callback *callback);\nint sudo_krb5_init(const struct sudoers_context *ctx, struct passwd *pw, sudo_auth *auth);\nint sudo_krb5_setup(const struct sudoers_context *ctx, struct passwd *pw, char **prompt, sudo_auth *auth);\nint sudo_krb5_verify(const struct sudoers_context *ctx, struct passwd *pw, const char *pass, sudo_auth *auth, struct sudo_conv_callback *callback);\nint sudo_krb5_cleanup(const struct sudoers_context *ctx, struct passwd *pw, sudo_auth *auth, bool force);\nint sudo_passwd_init(const struct sudoers_context *ctx, struct passwd *pw, sudo_auth *auth);\nint sudo_passwd_verify(const struct sudoers_context *ctx, struct passwd *pw, const char *pass, sudo_auth *auth, struct sudo_conv_callback *callback);\nint sudo_passwd_cleanup(const struct sudoers_context *ctx, struct passwd *pw, sudo_auth *auth, bool force);\nint sudo_rfc1938_setup(const struct sudoers_context *ctx, struct passwd *pw, char **prompt, sudo_auth *auth);\nint sudo_rfc1938_verify(const struct sudoers_context *ctx, struct passwd *pw, const char *pass, sudo_auth *auth, struct sudo_conv_callback *callback);\nint sudo_secureware_init(const struct sudoers_context *ctx, struct passwd *pw, sudo_auth *auth);\nint sudo_secureware_verify(const struct sudoers_context *ctx, struct passwd *pw, const char *pass, sudo_auth *auth, struct sudo_conv_callback *callback);\nint sudo_secureware_cleanup(const struct sudoers_context *ctx, struct passwd *pw, sudo_auth *auth, bool force);\n\n/* Fields: name, flags, init, setup, verify, approval, cleanup, begin_sess, end_sess */\n#define AUTH_ENTRY(n, f, i, s, v, a, c, b, e) \\\n\t{ (f), AUTH_FAILURE, (n), NULL, (i), (s), (v), (a), (c) , (b), (e) },\n\n#endif /* SUDO_AUTH_H */\n", "/*\n * SPDX-License-Identifier: ISC\n *\n * Copyright (c) 2004-2005, 2007-2023 Todd C. Miller <Todd.Miller@sudo.ws>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n/*\n * This is an open source non-commercial project. Dear PVS-Studio, please check it.\n * PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n */\n\n#include <config.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <pwd.h>\n\n#include \"sudoers.h\"\n#include <gram.h>\n\nstatic int\nrunas_matches_pw(struct sudoers_parse_tree *parse_tree,\n    const struct cmndspec *cs, const struct passwd *pw)\n{\n    debug_decl(runas_matches_pw, SUDOERS_DEBUG_PARSER);\n\n    if (cs->runasuserlist != NULL)\n\tdebug_return_int(userlist_matches(parse_tree, pw, cs->runasuserlist));\n\n    if (cs->runasgrouplist == NULL) {\n\t/* No explicit runas user or group, use default. */\n\tif (userpw_matches(def_runas_default, pw->pw_name, pw))\n\t    debug_return_int(ALLOW);\n    }\n    debug_return_int(UNSPEC);\n}\n\n/*\n * Look up the user in the sudoers parse tree for pseudo-commands like\n * list, verify and kill.\n */\nstatic unsigned int\nsudoers_lookup_pseudo(struct sudo_nss_list *snl, struct sudoers_context *ctx,\n    time_t now, sudoers_lookup_callback_fn_t callback, void *cb_data,\n    int pwflag)\n{\n    char *saved_runchroot;\n    struct passwd *root_pw = NULL;\n    struct sudo_nss *nss;\n    struct cmndspec *cs;\n    struct privilege *priv;\n    struct userspec *us;\n    struct defaults *def;\n    int nopass, match = DENY;\n    unsigned int validated = 0;\n    enum def_tuple pwcheck;\n    debug_decl(sudoers_lookup_pseudo, SUDOERS_DEBUG_PARSER);\n\n    pwcheck = (pwflag == -1) ? never : sudo_defs_table[pwflag].sd_un.tuple;\n    nopass = (pwcheck == never || pwcheck == all) ? true : false;\n\n    if (ctx->runas.list_pw != NULL) {\n\troot_pw = sudo_getpwuid(ROOT_UID);\n\tif (root_pw == NULL)\n\t    sudo_warnx(U_(\"unknown uid %u\"), ROOT_UID);\n    } else {\n\tSET(validated, FLAG_NO_CHECK);\n    }\n\n    /* Don't use chroot setting for pseudo-commands. */\n    saved_runchroot = def_runchroot;\n    def_runchroot = NULL;\n\n    TAILQ_FOREACH(nss, snl, entries) {\n\tif (nss->query(ctx, nss, ctx->user.pw) == -1) {\n\t    /* The query function should have printed an error message. */\n\t    SET(validated, VALIDATE_ERROR);\n\t    break;\n\t}\n\n\t/*\n\t * We have to traverse the policy forwards, not in reverse,\n\t * to support the \"pwcheck == all\" case.\n\t */\n\tTAILQ_FOREACH(us, &nss->parse_tree->userspecs, entries) {\n\t    int user_match = userlist_matches(nss->parse_tree, ctx->user.pw,\n\t\t&us->users);\n\t    if (user_match != ALLOW) {\n\t\tif (callback != NULL && user_match != UNSPEC) {\n\t\t    callback(nss->parse_tree, us, user_match, NULL, UNSPEC,\n\t\t\tNULL, UNSPEC, UNSPEC, UNSPEC, cb_data);\n\t\t}\n\t\tcontinue;\n\t    }\n\t    TAILQ_FOREACH(priv, &us->privileges, entries) {\n\t\tint priv_nopass = UNSPEC;\n\t\tint host_match = hostlist_matches(nss->parse_tree, ctx->user.pw,\n\t\t    &priv->hostlist);\n\t\tif (host_match != ALLOW) {\n\t\t    if (callback != NULL) {\n\t\t\tcallback(nss->parse_tree, us, user_match, priv,\n\t\t\t    host_match, NULL, UNSPEC, UNSPEC, UNSPEC, cb_data);\n\t\t    }\n\t\t    continue;\n\t\t}\n\t\tTAILQ_FOREACH(def, &priv->defaults, entries) {\n\t\t    if (strcmp(def->var, \"authenticate\") == 0) {\n\t\t\tpriv_nopass = !def->op;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tTAILQ_FOREACH(cs, &priv->cmndlist, entries) {\n\t\t    int cmnd_match = UNSPEC;\n\t\t    int date_match = UNSPEC;\n\t\t    int runas_match = UNSPEC;\n\n\t\t    if (pwcheck == any) {\n\t\t\tif (cs->tags.nopasswd == true || priv_nopass == true)\n\t\t\t    nopass = true;\n\t\t    } else if (pwcheck == all) {\n\t\t\tif (cs->tags.nopasswd != true && priv_nopass != true)\n\t\t\t    nopass = false;\n\t\t    }\n\n\t\t    if (cs->notbefore != UNSPEC) {\n\t\t\tdate_match = now < cs->notbefore ? DENY : ALLOW;\n\t\t    }\n\t\t    if (cs->notafter != UNSPEC) {\n\t\t\tdate_match = now > cs->notafter ? DENY : ALLOW;\n\t\t    }\n\t\t    /*\n\t\t     * Root can list any user's privileges.\n\t\t     * A user may always list their own privileges.\n\t\t     */\n\t\t    if (ctx->user.uid == 0 || ctx->runas.list_pw == NULL ||\n\t\t\t    ctx->user.uid == ctx->runas.list_pw->pw_uid) {\n\t\t\tcmnd_match = ALLOW;\n\t\t\trunas_match = ALLOW;\n\t\t    } else if (date_match != DENY) {\n\t\t\t/*\n\t\t\t * To list another user's prilileges, the runas\n\t\t\t * user must match the list user or root.\n\t\t\t */\n\t\t\trunas_match = runas_matches_pw(nss->parse_tree, cs,\n\t\t\t    ctx->runas.list_pw);\n\t\t\tswitch (runas_match) {\n\t\t\tcase DENY:\n\t\t\t    break;\n\t\t\tcase ALLOW:\n\t\t\t    /*\n\t\t\t     * RunAs user matches list user.\n\t\t\t     * Match on command \"list\" or ALL.\n\t\t\t     */\n\t\t\t    cmnd_match = cmnd_matches(nss->parse_tree,\n\t\t\t\tcs->cmnd, cs->runchroot, NULL);\n\t\t\t    break;\n\t\t\tdefault:\n\t\t\t    /*\n\t\t\t     * RunAs user doesn't match list user.\n\t\t\t     * Only allow listing if the user has\n\t\t\t     * \"sudo ALL\" for root.\n\t\t\t     */\n\t\t\t    if (root_pw != NULL &&\n\t\t\t\t    runas_matches_pw(nss->parse_tree, cs,\n\t\t\t\t    root_pw) == ALLOW) {\n\t\t\t\trunas_match = ALLOW;\n\t\t\t\tcmnd_match = cmnd_matches_all(nss->parse_tree,\n\t\t\t\t    cs->cmnd, cs->runchroot, NULL);\n\t\t\t    }\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    if (callback != NULL) {\n\t\t\tcallback(nss->parse_tree, us, user_match, priv,\n\t\t\t    host_match, cs, date_match, runas_match,\n\t\t\t    cmnd_match, cb_data);\n\t\t    }\n\t\t    if (cmnd_match != UNSPEC) {\n\t\t\t/*\n\t\t\t * We take the last match but must process\n\t\t\t * the entire policy for pwcheck == all.\n\t\t\t */\n\t\t\tmatch = cmnd_match;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif (!sudo_nss_can_continue(nss, match))\n\t    break;\n    }\n    if (root_pw != NULL)\n\tsudo_pw_delref(root_pw);\n    if (match == ALLOW || ctx->user.uid == 0) {\n\t/* User has an entry for this host. */\n\tSET(validated, VALIDATE_SUCCESS);\n    } else if (match == DENY)\n\tSET(validated, VALIDATE_FAILURE);\n    if (pwcheck == always && def_authenticate)\n\tSET(validated, FLAG_CHECK_USER);\n    else if (nopass == true)\n\tdef_authenticate = false;\n\n    /* Restore original def_runchroot. */\n    def_runchroot = saved_runchroot;\n\n    debug_return_uint(validated);\n}\n\nstatic void\ninit_cmnd_info(struct sudoers_context *ctx, struct cmnd_info *info)\n{\n    memset(info, 0, sizeof(*info));\n    if (def_intercept || ISSET(ctx->mode, MODE_POLICY_INTERCEPTED))\n\tinfo->intercepted = true;\n}\n\nstatic int\nsudoers_lookup_check(struct sudo_nss *nss, struct sudoers_context *ctx,\n    unsigned int *validated, struct cmnd_info *info, time_t now,\n    sudoers_lookup_callback_fn_t callback, void *cb_data,\n    struct cmndspec **matching_cs, struct defaults_list **defs)\n{\n    struct cmndspec *cs;\n    struct privilege *priv;\n    struct userspec *us;\n    struct member *matching_user;\n    debug_decl(sudoers_lookup_check, SUDOERS_DEBUG_PARSER);\n\n    init_cmnd_info(ctx, info);\n\n    TAILQ_FOREACH_REVERSE(us, &nss->parse_tree->userspecs, userspec_list, entries) {\n\tint user_match = userlist_matches(nss->parse_tree, ctx->user.pw, &us->users);\n\tif (user_match != ALLOW) {\n\t    if (callback != NULL && user_match != UNSPEC) {\n\t\tcallback(nss->parse_tree, us, user_match, NULL, UNSPEC, NULL,\n\t\t    UNSPEC, UNSPEC, UNSPEC, cb_data);\n\t    }\n\t    continue;\n\t}\n\tCLR(*validated, FLAG_NO_USER);\n\tTAILQ_FOREACH_REVERSE(priv, &us->privileges, privilege_list, entries) {\n\t    int host_match = hostlist_matches(nss->parse_tree, ctx->user.pw,\n\t\t&priv->hostlist);\n\t    if (host_match == ALLOW) {\n\t\tCLR(*validated, FLAG_NO_HOST);\n\t    } else {\n\t\tif (callback != NULL) {\n\t\t    callback(nss->parse_tree, us, user_match, priv, host_match,\n\t\t\tNULL, UNSPEC, UNSPEC, UNSPEC, cb_data);\n\t\t}\n\t\tcontinue;\n\t    }\n\t    TAILQ_FOREACH_REVERSE(cs, &priv->cmndlist, cmndspec_list, entries) {\n\t\tint cmnd_match = UNSPEC;\n\t\tint date_match = UNSPEC;\n\t\tint runas_match = UNSPEC;\n\n\t\tif (cs->notbefore != UNSPEC) {\n\t\t    date_match = now < cs->notbefore ? DENY : ALLOW;\n\t\t}\n\t\tif (cs->notafter != UNSPEC) {\n\t\t    date_match = now > cs->notafter ? DENY : ALLOW;\n\t\t}\n\t\tif (date_match != DENY) {\n\t\t    matching_user = NULL;\n\t\t    runas_match = runaslist_matches(nss->parse_tree,\n\t\t\tcs->runasuserlist, cs->runasgrouplist, &matching_user,\n\t\t\tNULL);\n\t\t    if (runas_match == ALLOW) {\n\t\t\tcmnd_match = cmnd_matches(nss->parse_tree, cs->cmnd,\n\t\t\t    cs->runchroot, info);\n\t\t    }\n\t\t}\n\t\tif (callback != NULL) {\n\t\t    callback(nss->parse_tree, us, user_match, priv, host_match,\n\t\t\tcs, date_match, runas_match, cmnd_match, cb_data);\n\t\t}\n\n\t\tif (cmnd_match != UNSPEC) {\n\t\t    /*\n\t\t     * If user is running command as themselves,\n\t\t     * set ctx->runas.pw = ctx->user.pw.\n\t\t     * XXX - hack, want more general solution\n\t\t     */\n\t\t    if (matching_user && matching_user->type == MYSELF) {\n\t\t\tsudo_pw_delref(ctx->runas.pw);\n\t\t\tsudo_pw_addref(ctx->user.pw);\n\t\t\tctx->runas.pw = ctx->user.pw;\n\t\t    }\n\t\t    *matching_cs = cs;\n\t\t    *defs = &priv->defaults;\n\t\t    sudo_debug_printf(SUDO_DEBUG_DEBUG|SUDO_DEBUG_LINENO,\n\t\t\t\"userspec matched @ %s:%d:%d: %s\",\n\t\t\tus->file ? us->file : \"???\", us->line, us->column,\n\t\t\tcmnd_match ? \"allowed\" : \"denied\");\n\t\t    debug_return_int(cmnd_match);\n\t\t}\n\t\tfree(info->cmnd_path);\n\t\tinit_cmnd_info(ctx, info);\n\t    }\n\t}\n    }\n    debug_return_int(UNSPEC);\n}\n\n/*\n * Apply cmndspec-specific settings including SELinux role/type,\n * Solaris privs, and command tags.\n */\nstatic bool\napply_cmndspec(struct sudoers_context *ctx, struct cmndspec *cs)\n{\n    debug_decl(apply_cmndspec, SUDOERS_DEBUG_PARSER);\n\n    if (cs != NULL) {\n#ifdef HAVE_SELINUX\n\t/* Set role and type if not specified on command line. */\n\tif (ctx->runas.role == NULL) {\n\t    if (cs->role != NULL) {\n\t\tctx->runas.role = strdup(cs->role);\n\t\tif (ctx->runas.role == NULL) {\n\t\t    sudo_warnx(U_(\"%s: %s\"), __func__,\n\t\t\tU_(\"unable to allocate memory\"));\n\t\t    debug_return_bool(false);\n\t\t}\n\t    } else {\n\t\tctx->runas.role = def_role;\n\t\tdef_role = NULL;\n\t    }\n\t    if (ctx->runas.role != NULL) {\n\t\tsudo_debug_printf(SUDO_DEBUG_INFO|SUDO_DEBUG_LINENO,\n\t\t    \"ctx->runas.role -> %s\", ctx->runas.role);\n\t    }\n\t}\n\tif (ctx->runas.type == NULL) {\n\t    if (cs->type != NULL) {\n\t\tctx->runas.type = strdup(cs->type);\n\t\tif (ctx->runas.type == NULL) {\n\t\t    sudo_warnx(U_(\"%s: %s\"), __func__,\n\t\t\tU_(\"unable to allocate memory\"));\n\t\t    debug_return_bool(false);\n\t\t}\n\t    } else {\n\t\tctx->runas.type = def_type;\n\t\tdef_type = NULL;\n\t    }\n\t    if (ctx->runas.type != NULL) {\n\t\tsudo_debug_printf(SUDO_DEBUG_INFO|SUDO_DEBUG_LINENO,\n\t\t    \"ctx->runas.type -> %s\", ctx->runas.type);\n\t    }\n\t}\n#endif /* HAVE_SELINUX */\n#ifdef HAVE_APPARMOR\n\t/* Set AppArmor profile, if specified */\n\tif (cs->apparmor_profile != NULL) {\n\t    ctx->runas.apparmor_profile = strdup(cs->apparmor_profile);\n\t    if (ctx->runas.apparmor_profile == NULL) {\n\t\tsudo_warnx(U_(\"%s: %s\"), __func__,\n\t\t    U_(\"unable to allocate memory\"));\n\t\tdebug_return_bool(false);\n\t    }\n\t} else {\n\t    ctx->runas.apparmor_profile = def_apparmor_profile;\n\t    def_apparmor_profile = NULL;\n\t}\n\tif (ctx->runas.apparmor_profile != NULL) {\n\t    sudo_debug_printf(SUDO_DEBUG_INFO|SUDO_DEBUG_LINENO,\n\t\t\"ctx->runas.apparmor_profile -> %s\", ctx->runas.apparmor_profile);\n\t}\n#endif\n#ifdef HAVE_PRIV_SET\n\t/* Set Solaris privilege sets */\n\tif (ctx->runas.privs == NULL) {\n\t    if (cs->privs != NULL) {\n\t\tctx->runas.privs = strdup(cs->privs);\n\t\tif (ctx->runas.privs == NULL) {\n\t\t    sudo_warnx(U_(\"%s: %s\"), __func__,\n\t\t\tU_(\"unable to allocate memory\"));\n\t\t    debug_return_bool(false);\n\t\t}\n\t    } else {\n\t\tctx->runas.privs = def_privs;\n\t\tdef_privs = NULL;\n\t    }\n\t    if (ctx->runas.privs != NULL) {\n\t\tsudo_debug_printf(SUDO_DEBUG_INFO|SUDO_DEBUG_LINENO,\n\t\t    \"ctx->runas.privs -> %s\", ctx->runas.privs);\n\t    }\n\t}\n\tif (ctx->runas.limitprivs == NULL) {\n\t    if (cs->limitprivs != NULL) {\n\t\tctx->runas.limitprivs = strdup(cs->limitprivs);\n\t\tif (ctx->runas.limitprivs == NULL) {\n\t\t    sudo_warnx(U_(\"%s: %s\"), __func__,\n\t\t\tU_(\"unable to allocate memory\"));\n\t\t    debug_return_bool(false);\n\t\t}\n\t    } else {\n\t\tctx->runas.limitprivs = def_limitprivs;\n\t\tdef_limitprivs = NULL;\n\t    }\n\t    if (ctx->runas.limitprivs != NULL) {\n\t\tsudo_debug_printf(SUDO_DEBUG_INFO|SUDO_DEBUG_LINENO,\n\t\t    \"ctx->runas.limitprivs -> %s\", ctx->runas.limitprivs);\n\t    }\n\t}\n#endif /* HAVE_PRIV_SET */\n\tif (cs->timeout > 0) {\n\t    def_command_timeout = cs->timeout;\n\t    sudo_debug_printf(SUDO_DEBUG_INFO|SUDO_DEBUG_LINENO,\n\t\t\"def_command_timeout -> %d\", def_command_timeout);\n\t}\n\tif (cs->runcwd != NULL) {\n\t    free(def_runcwd);\n\t    def_runcwd = strdup(cs->runcwd);\n\t    if (def_runcwd == NULL) {\n\t\tsudo_warnx(U_(\"%s: %s\"), __func__,\n\t\t    U_(\"unable to allocate memory\"));\n\t\tdebug_return_bool(false);\n\t    }\n\t    sudo_debug_printf(SUDO_DEBUG_INFO|SUDO_DEBUG_LINENO,\n\t\t\"def_runcwd -> %s\", def_runcwd);\n\t}\n\tif (cs->runchroot != NULL) {\n\t    free(def_runchroot);\n\t    def_runchroot = strdup(cs->runchroot);\n\t    if (def_runchroot == NULL) {\n\t\tsudo_warnx(U_(\"%s: %s\"), __func__,\n\t\t    U_(\"unable to allocate memory\"));\n\t\tdebug_return_bool(false);\n\t    }\n\t    sudo_debug_printf(SUDO_DEBUG_INFO|SUDO_DEBUG_LINENO,\n\t\t\"def_runchroot -> %s\", def_runchroot);\n\t}\n\tif (cs->tags.nopasswd != UNSPEC) {\n\t    def_authenticate = !cs->tags.nopasswd;\n\t    sudo_debug_printf(SUDO_DEBUG_INFO|SUDO_DEBUG_LINENO,\n\t\t\"def_authenticate -> %s\", def_authenticate ? \"true\" : \"false\");\n\t}\n\tif (cs->tags.noexec != UNSPEC) {\n\t    def_noexec = cs->tags.noexec;\n\t    sudo_debug_printf(SUDO_DEBUG_INFO|SUDO_DEBUG_LINENO,\n\t\t\"def_noexec -> %s\", def_noexec ? \"true\" : \"false\");\n\t}\n\tif (cs->tags.intercept != UNSPEC) {\n\t    def_intercept = cs->tags.intercept;\n\t    sudo_debug_printf(SUDO_DEBUG_INFO|SUDO_DEBUG_LINENO,\n\t\t\"def_intercept -> %s\", def_intercept ? \"true\" : \"false\");\n\t}\n\tif (cs->tags.setenv != UNSPEC) {\n\t    def_setenv = cs->tags.setenv;\n\t    sudo_debug_printf(SUDO_DEBUG_INFO|SUDO_DEBUG_LINENO,\n\t\t\"def_setenv -> %s\", def_setenv ? \"true\" : \"false\");\n\t}\n\tif (cs->tags.log_input != UNSPEC) {\n\t    def_log_input = cs->tags.log_input;\n\t    cb_log_input(ctx, NULL, 0, 0, NULL, cs->tags.log_input);\n\t    sudo_debug_printf(SUDO_DEBUG_INFO|SUDO_DEBUG_LINENO,\n\t\t\"def_log_input -> %s\", def_log_input ? \"true\" : \"false\");\n\t}\n\tif (cs->tags.log_output != UNSPEC) {\n\t    def_log_output = cs->tags.log_output;\n\t    cb_log_output(ctx, NULL, 0, 0, NULL, cs->tags.log_output);\n\t    sudo_debug_printf(SUDO_DEBUG_INFO|SUDO_DEBUG_LINENO,\n\t\t\"def_log_output -> %s\", def_log_output ? \"true\" : \"false\");\n\t}\n\tif (cs->tags.send_mail != UNSPEC) {\n\t    if (cs->tags.send_mail) {\n\t\tdef_mail_all_cmnds = true;\n\t\tsudo_debug_printf(SUDO_DEBUG_INFO|SUDO_DEBUG_LINENO,\n\t\t    \"def_mail_all_cmnds -> true\");\n\t    } else {\n\t\tdef_mail_all_cmnds = false;\n\t\tdef_mail_always = false;\n\t\tdef_mail_no_perms = false;\n\t\tsudo_debug_printf(SUDO_DEBUG_INFO|SUDO_DEBUG_LINENO,\n\t\t    \"def_mail_all_cmnds -> false, def_mail_always -> false, \"\n\t\t    \"def_mail_no_perms -> false\");\n\t    }\n\t}\n\tif (cs->tags.follow != UNSPEC) {\n\t    def_sudoedit_follow = cs->tags.follow;\n\t    sudo_debug_printf(SUDO_DEBUG_INFO|SUDO_DEBUG_LINENO,\n\t\t\"def_sudoedit_follow -> %s\", def_sudoedit_follow ? \"true\" : \"false\");\n\t}\n    }\n\n    debug_return_bool(true);\n}\n\n/*\n * Look up the user in the sudoers parse tree and check to see if they are\n * allowed to run the specified command on this host as the target user.\n */\nunsigned int\nsudoers_lookup(struct sudo_nss_list *snl, struct sudoers_context *ctx,\n    time_t now, sudoers_lookup_callback_fn_t callback, void *cb_data,\n    int *cmnd_status, int pwflag)\n{\n    struct defaults_list *defs = NULL;\n    struct sudoers_parse_tree *parse_tree = NULL;\n    struct cmndspec *cs = NULL;\n    struct sudo_nss *nss;\n    struct cmnd_info info;\n    unsigned int validated = FLAG_NO_USER | FLAG_NO_HOST;\n    int m, match = UNSPEC;\n    debug_decl(sudoers_lookup, SUDOERS_DEBUG_PARSER);\n\n    /*\n     * Special case checking the \"validate\", \"list\" and \"kill\" pseudo-commands.\n     */\n    if (pwflag) {\n\tdebug_return_uint(sudoers_lookup_pseudo(snl, ctx, now, callback,\n\t    cb_data, pwflag));\n    }\n\n    /* Need to be runas user while stat'ing things. */\n    if (!set_perms(ctx, PERM_RUNAS))\n\tdebug_return_uint(validated);\n\n    /* Query each sudoers source and check the user. */\n    TAILQ_FOREACH(nss, snl, entries) {\n\tif (nss->query(ctx, nss, ctx->user.pw) == -1) {\n\t    /* The query function should have printed an error message. */\n\t    SET(validated, VALIDATE_ERROR);\n\t    break;\n\t}\n\n\tm = sudoers_lookup_check(nss, ctx, &validated, &info, now, callback,\n\t    cb_data, &cs, &defs);\n\tif (m != UNSPEC) {\n\t    match = m;\n\t    parse_tree = nss->parse_tree;\n\t}\n\n\tif (!sudo_nss_can_continue(nss, m))\n\t    break;\n    }\n    if (match != UNSPEC) {\n\tif (info.cmnd_path != NULL) {\n\t    /* Update cmnd, cmnd_stat, cmnd_status from matching entry. */\n\t    free(ctx->user.cmnd);\n\t    ctx->user.cmnd = info.cmnd_path;\n\t    if (ctx->user.cmnd_stat != NULL)\n\t\t*ctx->user.cmnd_stat = info.cmnd_stat;\n\t    *cmnd_status = info.status;\n\t}\n\tif (defs != NULL)\n\t    (void)update_defaults(ctx, parse_tree, defs, SETDEF_GENERIC, false);\n\tif (!apply_cmndspec(ctx, cs))\n\t    SET(validated, VALIDATE_ERROR);\n\telse if (match == ALLOW)\n\t    SET(validated, VALIDATE_SUCCESS);\n\telse\n\t    SET(validated, VALIDATE_FAILURE);\n    }\n    if (!restore_perms())\n\tSET(validated, VALIDATE_ERROR);\n    debug_return_uint(validated);\n}\n", "/*\n * SPDX-License-Identifier: ISC\n *\n * Copyright (c) 1996, 1998-2005, 2007-2023\n *\tTodd C. Miller <Todd.Miller@sudo.ws>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n *\n * Sponsored in part by the Defense Advanced Research Projects\n * Agency (DARPA) and Air Force Research Laboratory, Air Force\n * Materiel Command, USAF, under agreement number F39502-99-1-0512.\n */\n\n/*\n * This is an open source non-commercial project. Dear PVS-Studio, please check it.\n * PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n */\n\n#include <config.h>\n\n#include <sys/stat.h>\n#ifdef HAVE_SYS_SYSTEMINFO_H\n# include <sys/systeminfo.h>\n#endif\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef HAVE_STRINGS_H\n# include <strings.h>\n#endif /* HAVE_STRINGS_H */\n#include <unistd.h>\n#ifdef HAVE_NETGROUP_H\n# include <netgroup.h>\n#else\n# include <netdb.h>\n#endif /* HAVE_NETGROUP_H */\n#include <dirent.h>\n#include <fcntl.h>\n#include <pwd.h>\n#include <grp.h>\n#include <errno.h>\n#ifdef HAVE_FNMATCH\n# include <fnmatch.h>\n#else\n# include \"compat/fnmatch.h\"\n#endif /* HAVE_FNMATCH */\n\n#include \"sudoers.h\"\n#include <gram.h>\n\n/*\n * Check whether user described by pw matches member.\n * Returns ALLOW, DENY or UNSPEC.\n */\nint\nuser_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct passwd *pw, const struct member *m)\n{\n    const struct sudoers_context *ctx = parse_tree->ctx;\n    const char *lhost = parse_tree->lhost ? parse_tree->lhost : ctx->runas.host;\n    const char *shost = parse_tree->shost ? parse_tree->shost : ctx->runas.shost;\n    int matched = UNSPEC;\n    struct alias *a;\n    debug_decl(user_matches, SUDOERS_DEBUG_MATCH);\n\n    switch (m->type) {\n\tcase ALL:\n\t    matched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase NETGROUP:\n\t    if (netgr_matches(parse_tree->nss, m->name,\n\t\tdef_netgroup_tuple ? lhost : NULL,\n\t\tdef_netgroup_tuple ? shost : NULL, pw->pw_name))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase USERGROUP:\n\t    if (usergr_matches(m->name, pw->pw_name, pw))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase ALIAS:\n\t    if ((a = alias_get(parse_tree, m->name, USERALIAS)) != NULL) {\n\t\t/* XXX */\n\t\tconst int rc = userlist_matches(parse_tree, pw, &a->members);\n\t\tif (rc != UNSPEC) {\n\t\t    if (m->negated) {\n\t\t\tmatched = rc == ALLOW ? DENY : ALLOW;\n\t\t    } else {\n\t\t\tmatched = rc;\n\t\t    }\n\t\t}\n\t\talias_put(a);\n\t\tbreak;\n\t    }\n\t    FALLTHROUGH;\n\tcase WORD:\n\t    if (userpw_matches(m->name, pw->pw_name, pw))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n    }\n    debug_return_int(matched);\n}\n\n/*\n * Check for user described by pw in a list of members.\n * Returns ALLOW, DENY or UNSPEC.\n */\nint\nuserlist_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct passwd *pw, const struct member_list *list)\n{\n    struct member *m;\n    int matched = UNSPEC;\n    debug_decl(userlist_matches, SUDOERS_DEBUG_MATCH);\n\n    TAILQ_FOREACH_REVERSE(m, list, member_list, entries) {\n\tif ((matched = user_matches(parse_tree, pw, m)) != UNSPEC)\n\t    break;\n    }\n    debug_return_int(matched);\n}\n\nstruct gid_list *\nrunas_getgroups(const struct sudoers_context *ctx)\n{\n    const struct passwd *pw;\n    debug_decl(runas_getgroups, SUDOERS_DEBUG_MATCH);\n\n    if (def_preserve_groups) {\n\tsudo_gidlist_addref(ctx->user.gid_list);\n\tdebug_return_ptr(ctx->user.gid_list);\n    }\n\n    /* Only use results from a group db query, not the front end. */\n    pw = ctx->runas.pw ? ctx->runas.pw : ctx->user.pw;\n    debug_return_ptr(sudo_get_gidlist(pw, ENTRY_TYPE_QUERIED));\n}\n\n/*\n * Check whether the requested runas user matches user_list, the\n * user portion of a sudoers runaslist.  If user_list is NULL, a\n * list containing runas_default is used.\n * Returns ALLOW, DENY or UNSPEC.\n */\nstatic int\nrunas_userlist_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct member_list *user_list, struct member **matching_user)\n{\n    const struct sudoers_context *ctx = parse_tree->ctx;\n    const char *lhost = parse_tree->lhost ? parse_tree->lhost : ctx->runas.host;\n    const char *shost = parse_tree->shost ? parse_tree->shost : ctx->runas.shost;\n    int user_matched = UNSPEC;\n    struct member *m;\n    struct alias *a;\n    debug_decl(runas_userlist_matches, SUDOERS_DEBUG_MATCH);\n\n    TAILQ_FOREACH_REVERSE(m, user_list, member_list, entries) {\n\tswitch (m->type) {\n\t    case ALL:\n\t\tuser_matched = m->negated ? DENY : ALLOW;\n\t\tbreak;\n\t    case NETGROUP:\n\t\tif (netgr_matches(parse_tree->nss, m->name,\n\t\t    def_netgroup_tuple ? lhost : NULL,\n\t\t    def_netgroup_tuple ? shost : NULL,\n\t\t    ctx->runas.pw->pw_name))\n\t\t    user_matched = m->negated ? DENY : ALLOW;\n\t\tbreak;\n\t    case USERGROUP:\n\t\tif (usergr_matches(m->name, ctx->runas.pw->pw_name, ctx->runas.pw))\n\t\t    user_matched = m->negated ? DENY : ALLOW;\n\t\tbreak;\n\t    case ALIAS:\n\t\ta = alias_get(parse_tree, m->name, RUNASALIAS);\n\t\tif (a != NULL) {\n\t\t    const int rc = runas_userlist_matches(parse_tree,\n\t\t\t&a->members, matching_user);\n\t\t    if (rc != UNSPEC) {\n\t\t\tif (m->negated) {\n\t\t\t    user_matched = rc == ALLOW ? DENY : ALLOW;\n\t\t\t} else {\n\t\t\t    user_matched = rc;\n\t\t\t}\n\t\t    }\n\t\t    alias_put(a);\n\t\t    break;\n\t\t}\n\t\tFALLTHROUGH;\n\t    case WORD:\n\t\tif (userpw_matches(m->name, ctx->runas.pw->pw_name, ctx->runas.pw))\n\t\t    user_matched = m->negated ? DENY : ALLOW;\n\t\tbreak;\n\t    case MYSELF:\n\t\t/*\n\t\t * Only match a rule with an empty runas user if a group\n\t\t * was specified on the command line without a user _or_\n\t\t * the user specified their own name on the command line.\n\t\t */\n\t\tif ((!ISSET(ctx->settings.flags, RUNAS_USER_SPECIFIED) &&\n\t\t\tISSET(ctx->settings.flags, RUNAS_GROUP_SPECIFIED)) ||\n\t\t\tstrcmp(ctx->user.name, ctx->runas.pw->pw_name) == 0)\n\t\t    user_matched = m->negated ? DENY : ALLOW;\n\t\tbreak;\n\t}\n\tif (user_matched != UNSPEC) {\n\t    if (matching_user != NULL && m->type != ALIAS)\n\t\t*matching_user = m;\n\t    break;\n\t}\n    }\n    debug_return_int(user_matched);\n}\n\n/*\n * Check whether the requested runas group matches group_list, the\n * group portion of a sudoers runaslist, or the runas user's groups.\n * Returns ALLOW, DENY or UNSPEC.\n */\nstatic int\nrunas_grouplist_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct member_list *group_list, struct member **matching_group)\n{\n    const struct sudoers_context *ctx = parse_tree->ctx;\n    int group_matched = UNSPEC;\n    struct member *m;\n    struct alias *a;\n    debug_decl(runas_grouplist_matches, SUDOERS_DEBUG_MATCH);\n\n    if (group_list != NULL) {\n\tTAILQ_FOREACH_REVERSE(m, group_list, member_list, entries) {\n\t    switch (m->type) {\n\t\tcase ALL:\n\t\t    group_matched = m->negated ? DENY : ALLOW;\n\t\t    break;\n\t\tcase ALIAS:\n\t\t    a = alias_get(parse_tree, m->name, RUNASALIAS);\n\t\t    if (a != NULL) {\n\t\t\tconst int rc = runas_grouplist_matches(parse_tree,\n\t\t\t    &a->members, matching_group);\n\t\t\tif (rc != UNSPEC) {\n\t\t\t    if (m->negated) {\n\t\t\t\tgroup_matched = rc == ALLOW ? DENY : ALLOW;\n\t\t\t    } else {\n\t\t\t\tgroup_matched = rc;\n\t\t\t    }\n\t\t\t}\n\t\t\talias_put(a);\n\t\t\tbreak;\n\t\t    }\n\t\t    FALLTHROUGH;\n\t\tcase WORD:\n\t\t    if (group_matches(m->name, ctx->runas.gr))\n\t\t\tgroup_matched = m->negated ? DENY : ALLOW;\n\t\t    break;\n\t    }\n\t    if (group_matched != UNSPEC) {\n\t\tif (matching_group != NULL && m->type != ALIAS)\n\t\t    *matching_group = m;\n\t\tbreak;\n\t    }\n\t}\n    }\n    if (group_matched == UNSPEC) {\n\tstruct gid_list *runas_groups;\n\t/*\n\t * The runas group was not explicitly allowed by sudoers.\n\t * Check whether it is one of the target user's groups.\n\t */\n\tif (ctx->runas.pw->pw_gid == ctx->runas.gr->gr_gid) {\n\t    group_matched = ALLOW;\t/* runas group matches passwd db */\n\t} else if ((runas_groups = runas_getgroups(ctx)) != NULL) {\n\t    int i;\n\n\t    for (i = 0; i < runas_groups->ngids; i++) {\n\t\tif (runas_groups->gids[i] == ctx->runas.gr->gr_gid) {\n\t\t    group_matched = ALLOW;\t/* matched aux group vector */\n\t\t    break;\n\t\t}\n\t    }\n\t    sudo_gidlist_delref(runas_groups);\n\t}\n    }\n\n    debug_return_int(group_matched);\n}\n\n/*\n * Check whether the sudoers runaslist, composed of user_list and\n * group_list, matches the runas user/group requested by the user.\n * Either (or both) user_list and group_list may be NULL.\n * If user_list is NULL, a list containing runas_default is used.\n * Returns ALLOW, DENY or UNSPEC.\n */\nint\nrunaslist_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct member_list *user_list, const struct member_list *group_list,\n    struct member **matching_user, struct member **matching_group)\n{\n    const struct sudoers_context *ctx = parse_tree->ctx;\n    struct member_list _user_list = TAILQ_HEAD_INITIALIZER(_user_list);\n    int user_matched, group_matched = UNSPEC;\n    struct member m_user;\n    debug_decl(runaslist_matches, SUDOERS_DEBUG_MATCH);\n\n    /* If no runas user listed in sudoers, use the default value.  */\n    if (user_list == NULL) {\n\tm_user.name = def_runas_default;\n\tm_user.type = WORD;\n\tm_user.negated = false;\n\tTAILQ_INSERT_HEAD(&_user_list, &m_user, entries);\n\tuser_list = &_user_list;\n\tmatching_user = NULL;\n    }\n\n    user_matched = runas_userlist_matches(parse_tree, user_list, matching_user);\n    if (ISSET(ctx->settings.flags, RUNAS_GROUP_SPECIFIED)) {\n\tgroup_matched = runas_grouplist_matches(parse_tree, group_list,\n\t    matching_group);\n    }\n\n    if (user_matched == DENY || group_matched == DENY)\n\tdebug_return_int(DENY);\n    if (user_matched == group_matched || ctx->runas.gr == NULL)\n\tdebug_return_int(user_matched);\n    debug_return_int(UNSPEC);\n}\n\n/*\n * Check for lhost and shost in a list of members.\n * Returns ALLOW, DENY or UNSPEC.\n */\nstatic int\nhostlist_matches_int(const struct sudoers_parse_tree *parse_tree,\n    const struct passwd *pw, const char *lhost, const char *shost,\n    const struct member_list *list)\n{\n    struct member *m;\n    int matched = UNSPEC;\n    debug_decl(hostlist_matches, SUDOERS_DEBUG_MATCH);\n\n    TAILQ_FOREACH_REVERSE(m, list, member_list, entries) {\n\tmatched = host_matches(parse_tree, pw, lhost, shost, m);\n\tif (matched != UNSPEC)\n\t    break;\n    }\n    debug_return_int(matched);\n}\n\n/*\n * Check for ctx->runas.host and ctx->runas.shost in a list of members.\n * Returns ALLOW, DENY or UNSPEC.\n */\nint\nhostlist_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct passwd *pw, const struct member_list *list)\n{\n    const struct sudoers_context *ctx = parse_tree->ctx;\n    const char *lhost = parse_tree->lhost ? parse_tree->lhost : ctx->runas.host;\n    const char *shost = parse_tree->shost ? parse_tree->shost : ctx->runas.shost;\n\n    return hostlist_matches_int(parse_tree, pw, lhost, shost, list);\n}\n\n/*\n * Check whether host or shost matches member.\n * Returns ALLOW, DENY or UNSPEC.\n */\nint\nhost_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct passwd *pw, const char *lhost, const char *shost,\n    const struct member *m)\n{\n    struct alias *a;\n    int matched = UNSPEC;\n    debug_decl(host_matches, SUDOERS_DEBUG_MATCH);\n\n    switch (m->type) {\n\tcase ALL:\n\t    matched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase NETGROUP:\n\t    if (netgr_matches(parse_tree->nss, m->name, lhost, shost,\n\t\tdef_netgroup_tuple ? pw->pw_name : NULL))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase NTWKADDR:\n\t    if (addr_matches(m->name))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase ALIAS:\n\t    a = alias_get(parse_tree, m->name, HOSTALIAS);\n\t    if (a != NULL) {\n\t\t/* XXX */\n\t\tconst int rc = hostlist_matches_int(parse_tree, pw, lhost,\n\t\t    shost, &a->members);\n\t\tif (rc != UNSPEC) {\n\t\t    if (m->negated) {\n\t\t\tmatched = rc == ALLOW ? DENY : ALLOW;\n\t\t    } else {\n\t\t\tmatched = rc;\n\t\t    }\n\t\t}\n\t\talias_put(a);\n\t\tbreak;\n\t    }\n\t    FALLTHROUGH;\n\tcase WORD:\n\t    if (hostname_matches(shost, lhost, m->name))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n    }\n    sudo_debug_printf(SUDO_DEBUG_DEBUG,\n\t\"host %s (%s) matches sudoers host %s%s: %s\", lhost, shost,\n\tm->negated ? \"!\" : \"\", m->name ? m->name : \"ALL\",\n\tmatched == true ? \"true\" : \"false\");\n    debug_return_int(matched);\n}\n\n/*\n * Check for cmnd and args in a list of members.\n * Returns ALLOW, DENY or UNSPEC.\n */\nint\ncmndlist_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct member_list *list, const char *runchroot,\n    struct cmnd_info *info)\n{\n    struct member *m;\n    int matched = UNSPEC;\n    debug_decl(cmndlist_matches, SUDOERS_DEBUG_MATCH);\n\n    TAILQ_FOREACH_REVERSE(m, list, member_list, entries) {\n\tmatched = cmnd_matches(parse_tree, m, runchroot, info);\n\tif (matched != UNSPEC)\n\t    break;\n    }\n    debug_return_int(matched);\n}\n\n/*\n * Check cmnd and args.\n * Returns ALLOW, DENY or UNSPEC.\n */\nint\ncmnd_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct member *m, const char *runchroot, struct cmnd_info *info)\n{\n    struct alias *a;\n    struct sudo_command *c;\n    int rc, matched = UNSPEC;\n    debug_decl(cmnd_matches, SUDOERS_DEBUG_MATCH);\n\n    switch (m->type) {\n\tcase ALL:\n\tcase COMMAND:\n\t    c = (struct sudo_command *)m->name;\n\t    if (command_matches(parse_tree->ctx, c->cmnd, c->args, runchroot,\n\t\t    info, &c->digests))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase ALIAS:\n\t    a = alias_get(parse_tree, m->name, CMNDALIAS);\n\t    if (a != NULL) {\n\t\trc = cmndlist_matches(parse_tree, &a->members, runchroot, info);\n\t\tif (rc != UNSPEC) {\n\t\t    if (m->negated) {\n\t\t\tmatched = rc == ALLOW ? DENY : ALLOW;\n\t\t    } else {\n\t\t\tmatched = rc;\n\t\t    }\n\t\t}\n\t\talias_put(a);\n\t    }\n\t    break;\n    }\n    debug_return_int(matched);\n}\n\n/*\n * Like cmnd_matches() but only matches against the ALL command.\n * Returns ALLOW, DENY or UNSPEC.\n */\nint\ncmnd_matches_all(const struct sudoers_parse_tree *parse_tree,\n    const struct member *m, const char *runchroot, struct cmnd_info *info)\n{\n    const bool negated = m->negated;\n    struct sudo_command *c;\n    int matched = UNSPEC;\n    struct alias *a;\n    debug_decl(cmnd_matches_all, SUDOERS_DEBUG_MATCH);\n\n    switch (m->type) {\n\tcase ALL:\n\t    c = (struct sudo_command *)m->name;\n\t    if (command_matches(parse_tree->ctx, c->cmnd, c->args, runchroot,\n\t\t    info, &c->digests))\n\t\tmatched = negated ? DENY : ALLOW;\n\t    break;\n\tcase ALIAS:\n\t    a = alias_get(parse_tree, m->name, CMNDALIAS);\n\t    if (a != NULL) {\n\t\tTAILQ_FOREACH_REVERSE(m, &a->members, member_list, entries) {\n\t\t    matched = cmnd_matches_all(parse_tree, m, runchroot, info);\n\t\t    if (matched != UNSPEC) {\n\t\t\tif (negated)\n\t\t\t    matched = matched == ALLOW ? DENY : ALLOW;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\talias_put(a);\n\t    }\n\t    break;\n    }\n    debug_return_int(matched);\n}\n\n/*\n * Returns true if the hostname matches the pattern, else false\n */\nbool\nhostname_matches(const char *shost, const char *lhost, const char *pattern)\n{\n    const char *host;\n    bool rc;\n    debug_decl(hostname_matches, SUDOERS_DEBUG_MATCH);\n\n    host = strchr(pattern, '.') != NULL ? lhost : shost;\n    if (has_meta(pattern)) {\n\trc = !fnmatch(pattern, host, FNM_CASEFOLD);\n    } else {\n\trc = !strcasecmp(host, pattern);\n    }\n    debug_return_bool(rc);\n}\n\n/*\n * Returns true if the user/uid from sudoers matches the specified user/uid,\n * else returns false.\n */\nbool\nuserpw_matches(const char *sudoers_user, const char *user, const struct passwd *pw)\n{\n    const char *errstr;\n    uid_t uid;\n    bool rc;\n    debug_decl(userpw_matches, SUDOERS_DEBUG_MATCH);\n\n    if (pw != NULL && *sudoers_user == '#') {\n\tuid = (uid_t) sudo_strtoid(sudoers_user + 1, &errstr);\n\tif (errstr == NULL && uid == pw->pw_uid) {\n\t    rc = true;\n\t    goto done;\n\t}\n    }\n    if (def_case_insensitive_user)\n\trc = strcasecmp(sudoers_user, user) == 0;\n    else\n\trc = strcmp(sudoers_user, user) == 0;\ndone:\n    sudo_debug_printf(SUDO_DEBUG_DEBUG|SUDO_DEBUG_LINENO,\n\t\"user %s matches sudoers user %s: %s\",\n\tuser, sudoers_user, rc ? \"true\" : \"false\");\n    debug_return_bool(rc);\n}\n\n/*\n * Returns true if the group/gid from sudoers matches the specified group/gid,\n * else returns false.\n */\nbool\ngroup_matches(const char *sudoers_group, const struct group *gr)\n{\n    const char *errstr;\n    gid_t gid;\n    bool rc;\n    debug_decl(group_matches, SUDOERS_DEBUG_MATCH);\n\n    if (*sudoers_group == '#') {\n\tgid = (gid_t) sudo_strtoid(sudoers_group + 1, &errstr);\n\tif (errstr == NULL && gid == gr->gr_gid) {\n\t    rc = true;\n\t    goto done;\n\t}\n    }\n    if (def_case_insensitive_group)\n\trc = strcasecmp(sudoers_group, gr->gr_name) == 0;\n    else\n\trc = strcmp(sudoers_group, gr->gr_name) == 0;\ndone:\n    sudo_debug_printf(SUDO_DEBUG_DEBUG|SUDO_DEBUG_LINENO,\n\t\"group %s matches sudoers group %s: %s\",\n\tgr->gr_name, sudoers_group, rc ? \"true\" : \"false\");\n    debug_return_bool(rc);\n}\n\n/*\n * Returns true if the given user belongs to the named group,\n * else returns false.\n */\nbool\nusergr_matches(const char *group, const char *user, const struct passwd *pw)\n{\n    bool matched = false;\n    struct passwd *pw0 = NULL;\n    debug_decl(usergr_matches, SUDOERS_DEBUG_MATCH);\n\n    /* Make sure we have a valid usergroup, sudo style */\n    if (*group++ != '%') {\n\tsudo_debug_printf(SUDO_DEBUG_DIAG, \"user group %s has no leading '%%'\",\n\t    group);\n\tgoto done;\n    }\n\n    /* Query group plugin for %:name groups. */\n    if (*group == ':' && def_group_plugin) {\n\tif (group_plugin_query(user, group + 1, pw) == true)\n\t    matched = true;\n\tgoto done;\n    }\n\n    /* Look up user's primary gid in the passwd file. */\n    if (pw == NULL) {\n\tif ((pw0 = sudo_getpwnam(user)) == NULL) {\n\t    sudo_debug_printf(SUDO_DEBUG_DIAG, \"unable to find %s in passwd db\",\n\t\tuser);\n\t    goto done;\n\t}\n\tpw = pw0;\n    }\n\n    if (user_in_group(pw, group)) {\n\tmatched = true;\n\tgoto done;\n    }\n\n    /* Query the group plugin for Unix groups too? */\n    if (def_group_plugin && def_always_query_group_plugin) {\n\tif (group_plugin_query(user, group, pw) == true) {\n\t    matched = true;\n\t    goto done;\n\t}\n    }\n\ndone:\n    if (pw0 != NULL)\n\tsudo_pw_delref(pw0);\n\n    sudo_debug_printf(SUDO_DEBUG_DEBUG|SUDO_DEBUG_LINENO,\n\t\"user %s matches group %s: %s\", user, group, matched ? \"true\" : \"false\");\n    debug_return_bool(matched);\n}\n\n#if defined(HAVE_GETDOMAINNAME) || defined(SI_SRPC_DOMAIN)\n/*\n * Check the domain for invalid characters.\n * Linux getdomainname(2) returns (none) if no domain is set.\n */\nstatic bool\nvalid_domain(const char *domain)\n{\n    const char *cp;\n    debug_decl(valid_domain, SUDOERS_DEBUG_MATCH);\n\n    for (cp = domain; *cp != '\\0'; cp++) {\n\t/* Check for illegal characters, Linux may use \"(none)\". */\n\tif (*cp == '(' || *cp == ')' || *cp == ',' || *cp == ' ')\n\t    break;\n    }\n    if (cp == domain || *cp != '\\0')\n\tdebug_return_bool(false);\n    debug_return_bool(true);\n}\n\n/*\n * Get NIS-style domain name and copy from static storage or NULL if none.\n */\nconst char *\nsudo_getdomainname(void)\n{\n    static char *domain;\n    static bool initialized;\n    debug_decl(sudo_getdomainname, SUDOERS_DEBUG_MATCH);\n\n    if (!initialized) {\n\tsize_t host_name_max;\n\tint rc;\n\n# ifdef _SC_HOST_NAME_MAX\n\thost_name_max = (size_t)sysconf(_SC_HOST_NAME_MAX);\n\tif (host_name_max == (size_t)-1)\n# endif\n\t    host_name_max = 255;    /* POSIX and historic BSD */\n\n\tdomain = malloc(host_name_max + 1);\n\tif (domain != NULL) {\n\t    domain[0] = '\\0';\n# ifdef SI_SRPC_DOMAIN\n\t    rc = sysinfo(SI_SRPC_DOMAIN, domain, host_name_max + 1);\n# else\n\t    rc = getdomainname(domain, host_name_max + 1);\n# endif\n\t    if (rc == -1 || !valid_domain(domain)) {\n\t\t/* Error or invalid domain name. */\n\t\tfree(domain);\n\t\tdomain = NULL;\n\t    }\n\t} else {\n\t    /* XXX - want to pass error back to caller */\n\t    sudo_debug_printf(SUDO_DEBUG_ERROR|SUDO_DEBUG_LINENO,\n\t\t\"unable to allocate memory\");\n\t}\n\tinitialized = true;\n    }\n    debug_return_str(domain);\n}\n#else\nconst char *\nsudo_getdomainname(void)\n{\n    debug_decl(sudo_getdomainname, SUDOERS_DEBUG_MATCH);\n    debug_return_ptr(NULL);\n}\n#endif /* HAVE_GETDOMAINNAME || SI_SRPC_DOMAIN */\n\n/*\n * Returns true if \"host\" and \"user\" belong to the netgroup \"netgr\",\n * else return false.  Either of \"lhost\", \"shost\" or \"user\" may be NULL\n * in which case that argument is not checked...\n */\nbool\nnetgr_matches(const struct sudo_nss *nss, const char *netgr,\n    const char *lhost, const char *shost, const char *user)\n{\n    const char *domain;\n    bool rc = false;\n    debug_decl(netgr_matches, SUDOERS_DEBUG_MATCH);\n\n    if (!def_use_netgroups) {\n\tsudo_debug_printf(SUDO_DEBUG_INFO, \"netgroups are disabled\");\n\tdebug_return_bool(false);\n    }\n\n    /* make sure we have a valid netgroup, sudo style */\n    if (*netgr++ != '+') {\n\tsudo_debug_printf(SUDO_DEBUG_DIAG, \"netgroup %s has no leading '+'\",\n\t    netgr);\n\tdebug_return_bool(false);\n    }\n\n    /* get the domain name (if any) */\n    domain = sudo_getdomainname();\n\n    /* Use nss-specific innetgr() function if available. */\n    if (nss != NULL && nss->innetgr != NULL) {\n\tswitch (nss->innetgr(nss, netgr, lhost, user, domain)) {\n\tcase 0:\n\t    if (lhost != shost) {\n\t\tif (nss->innetgr(nss, netgr, shost, user, domain) == 1)\n\t\t    rc = true;\n\t    }\n\t    goto done;\n\tcase 1:\n\t    rc = true;\n\t    goto done;\n\tdefault:\n\t    /* Not supported, use system innetgr(3). */\n\t    break;\n\t}\n    }\n\n#ifdef HAVE_INNETGR\n    /* Use system innetgr() function. */\n    if (innetgr(netgr, lhost, user, domain) == 1) {\n\trc = true;\n    } else if (lhost != shost) {\n\tif (innetgr(netgr, shost, user, domain) == 1)\n\t    rc = true;\n    }\n#else\n    sudo_debug_printf(SUDO_DEBUG_WARN|SUDO_DEBUG_LINENO,\n\t\"%s: no system netgroup support\", __func__);\n#endif /* HAVE_INNETGR */\n\ndone:\n    sudo_debug_printf(SUDO_DEBUG_DEBUG|SUDO_DEBUG_LINENO,\n\t\"netgroup %s matches (%s|%s, %s, %s): %s\", netgr, lhost ? lhost : \"\",\n\tshost ? shost : \"\", user ? user : \"\", domain ? domain : \"\",\n\trc ? \"true\" : \"false\");\n\n    debug_return_bool(rc);\n}\n", "/*\n * SPDX-License-Identifier: ISC\n *\n * Copyright (c) 1996, 1998-2000, 2004, 2007-2023\n *\tTodd C. Miller <Todd.Miller@sudo.ws>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#ifndef SUDOERS_PARSE_H\n#define SUDOERS_PARSE_H\n\n#include <sys/stat.h>\n#include \"sudo_queue.h\"\n\n/* Characters that must be quoted in sudoers. */\n#define SUDOERS_QUOTED\t\t\":,=#\\\"\"\n#define SUDOERS_QUOTED_CMD\t\":,= \\t#\"\n#define SUDOERS_QUOTED_ARG\t\":,=#\"\n\n/* Returns true if string 's' contains meta characters. */\n#define has_meta(s)\t(strpbrk(s, \"\\\\?*[]\") != NULL)\n\n/* Match by name, not inode, when fuzzing. */\n#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n# define SUDOERS_NAME_MATCH\n#endif\n\n#undef UNSPEC\n#define UNSPEC\t-1\n#undef DENY\n#define DENY\t 0\n#undef ALLOW\n#define ALLOW\t 1\n#undef IMPLIED\n#define IMPLIED\t 2\n\n/*\n * Initialize all tags to UNSPEC.\n */\n#define TAGS_INIT(t)\tdo {\t\t\t\t\t\t       \\\n    (t)->follow = UNSPEC;\t\t\t\t\t\t       \\\n    (t)->intercept = UNSPEC;\t\t\t\t\t\t       \\\n    (t)->log_input = UNSPEC;\t\t\t\t\t\t       \\\n    (t)->log_output = UNSPEC;\t\t\t\t\t\t       \\\n    (t)->noexec = UNSPEC;\t\t\t\t\t\t       \\\n    (t)->nopasswd = UNSPEC;\t\t\t\t\t\t       \\\n    (t)->send_mail = UNSPEC;\t\t\t\t\t\t       \\\n    (t)->setenv = UNSPEC;\t\t\t\t\t\t       \\\n} while (0)\n\n/*\n * Copy any tags set in t2 into t, overriding the value in t.\n */\n#define TAGS_MERGE(t, t2) do {\t\t\t\t\t\t       \\\n    if ((t2).follow != UNSPEC)\t\t\t\t\t\t       \\\n\t(t).follow = (t2).follow;\t\t\t\t\t       \\\n    if ((t2).intercept != UNSPEC)\t\t\t\t\t       \\\n\t(t).intercept = (t2).intercept;\t\t\t\t\t       \\\n    if ((t2).log_input != UNSPEC)\t\t\t\t\t       \\\n\t(t).log_input = (t2).log_input;\t\t\t\t\t       \\\n    if ((t2).log_output != UNSPEC)\t\t\t\t\t       \\\n\t(t).log_output = (t2).log_output;\t\t\t\t       \\\n    if ((t2).noexec != UNSPEC)\t\t\t\t\t\t       \\\n\t(t).noexec = (t2).noexec;\t\t\t\t\t       \\\n    if ((t2).nopasswd != UNSPEC)\t\t\t\t\t       \\\n\t(t).nopasswd = (t2).nopasswd;\t\t\t\t\t       \\\n    if ((t2).send_mail != UNSPEC)\t\t\t\t\t       \\\n\t(t).send_mail = (t2).send_mail;\t\t\t\t\t       \\\n    if ((t2).setenv != UNSPEC)\t\t\t\t\t\t       \\\n\t(t).setenv = (t2).setenv;\t\t\t\t\t       \\\n} while (0)\n\n/*\n * Returns true if any tag are not UNSPEC, else false.\n */\n#define TAGS_SET(t)\t\t\t\t\t\t\t       \\\n    ((t).follow != UNSPEC || (t).intercept != UNSPEC ||\t\t\t       \\\n     (t).log_input != UNSPEC || (t).log_output != UNSPEC ||\t\t       \\\n     (t).noexec != UNSPEC || (t).nopasswd != UNSPEC ||\t\t\t       \\\n     (t).send_mail != UNSPEC ||\t(t).setenv != UNSPEC)\n\n/*\n * Returns true if the specified tag is not UNSPEC or IMPLIED, else false.\n */\n#define TAG_SET(tt) \\\n    ((tt) != UNSPEC && (tt) != IMPLIED)\n\n/*\n * Returns true if any tags set in nt differ between ot and nt, else false.\n */\n#define TAGS_CHANGED(ot, nt) \\\n    ((TAG_SET((nt).follow) && (nt).follow != (ot).follow) || \\\n    (TAG_SET((nt).intercept) && (nt).intercept != (ot).intercept) || \\\n    (TAG_SET((nt).log_input) && (nt).log_input != (ot).log_input) || \\\n    (TAG_SET((nt).log_output) && (nt).log_output != (ot).log_output) || \\\n    (TAG_SET((nt).noexec) && (nt).noexec != (ot).noexec) || \\\n    (TAG_SET((nt).nopasswd) && (nt).nopasswd != (ot).nopasswd) || \\\n    (TAG_SET((nt).setenv) && (nt).setenv != (ot).setenv) || \\\n    (TAG_SET((nt).send_mail) && (nt).send_mail != (ot).send_mail))\n\n/*\n * Returns true if the runas user and group lists match, else false.\n */\n#define RUNAS_CHANGED(cs1, cs2) \\\n     ((cs1)->runasuserlist != (cs2)->runasuserlist || \\\n     (cs1)->runasgrouplist != (cs2)->runasgrouplist)\n\nstruct command_digest {\n    TAILQ_ENTRY(command_digest) entries;\n    unsigned int digest_type;\n    char *digest_str;\n};\n\n/*\n * Tags associated with a command.\n * Possible values: true, false, IMPLIED, UNSPEC.\n */\nstruct cmndtag {\n    signed int follow: 3;\n    signed int intercept: 3;\n    signed int log_input: 3;\n    signed int log_output: 3;\n    signed int noexec: 3;\n    signed int nopasswd: 3;\n    signed int send_mail: 3;\n    signed int setenv: 3;\n};\n\n/*\n * Per-command option container struct.\n */\nstruct command_options {\n    time_t notbefore;\t\t\t/* time restriction */\n    time_t notafter;\t\t\t/* time restriction */\n    int timeout;\t\t\t/* command timeout */\n    char *runcwd;\t\t\t/* working directory */\n    char *runchroot;\t\t\t/* root directory */\n#ifdef HAVE_SELINUX\n    char *role, *type;\t\t\t/* SELinux role and type */\n#endif\n#ifdef HAVE_APPARMOR\n    char *apparmor_profile;\t\t/* AppArmor profile */\n#endif\n#ifdef HAVE_PRIV_SET\n    char *privs, *limitprivs;\t\t/* Solaris privilege sets */\n#endif\n};\n\n/*\n * The parsed sudoers file is stored as a collection of linked lists,\n * modelled after the yacc grammar.\n *\n * Other than the alias struct, which is stored in a red-black tree,\n * the data structure used is a doubly-linked tail queue.  While sudoers\n * is being parsed, a headless tail queue is used where the first entry\n * acts as the head and the prev pointer does double duty as the tail pointer.\n * This makes it possible to trivially append sub-lists.  In addition, the prev\n * pointer is always valid (even if it points to itself).  Unlike a circle\n * queue, the next pointer of the last entry is NULL and does not point back\n * to the head.  When the tail queue is finalized, it is converted to a\n * normal BSD tail queue.\n */\n\n/*\n * Tail queue list head structures.\n */\nTAILQ_HEAD(defaults_list, defaults);\nTAILQ_HEAD(userspec_list, userspec);\nTAILQ_HEAD(member_list, member);\nTAILQ_HEAD(privilege_list, privilege);\nTAILQ_HEAD(cmndspec_list, cmndspec);\nTAILQ_HEAD(command_digest_list, command_digest);\nSTAILQ_HEAD(comment_list, sudoers_comment);\nTAILQ_HEAD(sudoers_parse_tree_list, sudoers_parse_tree);\n\n/*\n * Structure describing a user specification and list thereof.\n */\nstruct userspec {\n    TAILQ_ENTRY(userspec) entries;\n    struct member_list users;\t\t/* list of users */\n    struct privilege_list privileges;\t/* list of privileges */\n    struct comment_list comments;\t/* optional comments */\n    int line;\t\t\t\t/* line number in sudoers */\n    int column;\t\t\t\t/* column number in sudoers */\n    char *file;\t\t\t\t/* name of sudoers file */\n};\n\n/*\n * Structure describing a privilege specification.\n */\nstruct privilege {\n    TAILQ_ENTRY(privilege) entries;\n    char *ldap_role;\t\t\t/* LDAP sudoRole */\n    struct member_list hostlist;\t/* list of hosts */\n    struct cmndspec_list cmndlist;\t/* list of Cmnd_Specs */\n    struct defaults_list defaults;\t/* list of sudoOptions */\n};\n\n/*\n * A command with option args and digest.\n * XXX - merge into struct member\n */\nstruct sudo_command {\n    char *cmnd;\n    char *args;\n    struct command_digest_list digests;\n};\n\n/*\n * Structure describing a linked list of Cmnd_Specs.\n * XXX - include struct command_options instead of its contents inline\n */\nstruct cmndspec {\n    TAILQ_ENTRY(cmndspec) entries;\n    struct member_list *runasuserlist;\t/* list of runas users */\n    struct member_list *runasgrouplist;\t/* list of runas groups */\n    struct member *cmnd;\t\t/* command to allow/deny */\n    struct cmndtag tags;\t\t/* tag specificaion */\n    int timeout;\t\t\t/* command timeout */\n    time_t notbefore;\t\t\t/* time restriction */\n    time_t notafter;\t\t\t/* time restriction */\n    char *runcwd;\t\t\t/* working directory */\n    char *runchroot;\t\t\t/* root directory */\n#ifdef HAVE_SELINUX\n    char *role, *type;\t\t\t/* SELinux role and type */\n#endif\n#ifdef HAVE_APPARMOR\n    char *apparmor_profile;\t\t/* AppArmor profile */\n#endif\n#ifdef HAVE_PRIV_SET\n    char *privs, *limitprivs;\t\t/* Solaris privilege sets */\n#endif\n};\n\n/*\n * Generic structure to hold users, hosts, commands.\n */\nstruct member {\n    TAILQ_ENTRY(member) entries;\n    char *name;\t\t\t\t/* member name */\n    short type;\t\t\t\t/* type (see gram.h) */\n    short negated;\t\t\t/* negated via '!'? */\n};\n\nstruct runascontainer {\n    struct member *runasusers;\n    struct member *runasgroups;\n};\n\nstruct defaults_binding {\n    struct member_list members;\n    unsigned int refcnt;\n};\n\nstruct sudoers_comment {\n    STAILQ_ENTRY(sudoers_comment) entries;\n    char *str;\n};\n\n/*\n * Generic structure to hold {User,Host,Runas,Cmnd}_Alias\n * Aliases are stored in a red-black tree, sorted by name and type.\n */\nstruct alias {\n    char *name;\t\t\t\t/* alias name */\n    short type;\t\t\t\t/* {USER,HOST,RUNAS,CMND}ALIAS */\n    short used;\t\t\t\t/* \"used\" flag for cycle detection */\n    int line;\t\t\t\t/* line number of alias entry */\n    int column;\t\t\t\t/* column number of alias entry */\n    char *file;\t\t\t\t/* file the alias entry was in */\n    struct member_list members;\t\t/* list of alias members */\n};\n\n/*\n * Structure describing a Defaults entry in sudoers.\n */\nstruct defaults {\n    TAILQ_ENTRY(defaults) entries;\n    char *var;\t\t\t\t/* variable name */\n    char *val;\t\t\t\t/* variable value */\n    struct defaults_binding *binding;\t/* user/host/runas binding */\n    char *file;\t\t\t\t/* file Defaults entry was in */\n    int type;\t\t\t\t/* DEFAULTS{,_USER,_RUNAS,_HOST} */\n    int op;\t\t\t\t/* true, false, '+', '-' */\n    int line;\t\t\t\t/* line number of Defaults entry */\n    int column;\t\t\t\t/* column number of Defaults entry */\n};\n\nstruct sudoers_match_info {\n    const struct sudoers_parse_tree *parse_tree;\n    const struct userspec *us;\t\t/* matching userspec */\n    const struct privilege *priv;\t/* matching privilege */\n    const struct cmndspec *cs;\t\t/* matching cmndspec */\n};\n\n/*\n * Parsed sudoers policy.\n */\nstruct sudo_nss;\nstruct sudoers_parse_tree {\n    TAILQ_ENTRY(sudoers_parse_tree) entries;\n    struct userspec_list userspecs;\n    struct defaults_list defaults;\n    struct rbtree *aliases;\n    char *shost, *lhost;\n    struct sudo_nss *nss;\n    struct sudoers_context *ctx;\n};\n\n/*\n * Info about the command being resolved.\n */\nstruct cmnd_info {\n    struct stat cmnd_stat;\n    char *cmnd_path;\n    int status;\n    bool intercepted;\n};\n\n/*\n * Optional callback for sudoers_lookup().\n */\ntypedef void (*sudoers_lookup_callback_fn_t)(const struct sudoers_parse_tree *parse_tree, const struct userspec *us, int user_match, const struct privilege *priv, int host_match, const struct cmndspec *cs, int date_match, int runas_match, int cmnd_match, void *closure);\n\n/*\n * The parser passes pointers to data structures that are not stored anywhere.\n * We add them to the leak list at allocation time and remove them from\n * the list when they are stored in another data structure.\n * This makes it possible to free data on error that would otherwise be leaked.\n */\nenum parser_leak_types {\n    LEAK_UNKNOWN,\n    LEAK_PRIVILEGE,\n    LEAK_CMNDSPEC,\n    LEAK_DEFAULTS,\n    LEAK_MEMBER,\n    LEAK_DIGEST,\n    LEAK_RUNAS,\n    LEAK_PTR\n};\nstruct parser_leak_entry {\n    SLIST_ENTRY(parser_leak_entry) entries;\n    enum parser_leak_types type;\n    union {\n\tstruct command_digest *dig;\n\tstruct privilege *p;\n\tstruct cmndspec *cs;\n\tstruct defaults *d;\n\tstruct member *m;\n\tstruct runascontainer *rc;\n\tvoid *ptr;\n    } u;\n};\nSLIST_HEAD(parser_leak_list, parser_leak_entry);\n\n#define YY_DECL int sudoerslex(void)\n\n/* alias.c */\nstruct rbtree *alloc_aliases(void);\nvoid free_aliases(struct rbtree *aliases);\nbool no_aliases(const struct sudoers_parse_tree *parse_tree);\nbool alias_add(struct sudoers_parse_tree *parse_tree, char *name, short type, char *file, int line, int column, struct member *members);\nconst char *alias_type_to_string(short alias_type);\nstruct alias *alias_get(const struct sudoers_parse_tree *parse_tree, const char *name, short type);\nstruct alias *alias_remove(struct sudoers_parse_tree *parse_tree, const char *name, short type);\nbool alias_find_used(struct sudoers_parse_tree *parse_tree, struct rbtree *used_aliases);\nvoid alias_apply(struct sudoers_parse_tree *parse_tree, int (*func)(struct sudoers_parse_tree *, struct alias *, void *), void *cookie);\nvoid alias_free(void *a);\nvoid alias_put(struct alias *a);\n\n/* check_aliases.c */\nint check_aliases(struct sudoers_parse_tree *parse_tree, bool strict, bool quiet, int (*cb_unused)(struct sudoers_parse_tree *, struct alias *, void *));\n\n/* gram.y */\nextern bool parse_error;\nextern struct sudoers_parse_tree parsed_policy;\nextern bool (*sudoers_error_hook)(const struct sudoers_context *ctx, const char *file, int line, int column, const char * restrict fmt, va_list args);\nbool reset_parser(void);\nvoid free_member(struct member *m);\nvoid free_members(struct member_list *members);\nvoid free_cmndspec(struct cmndspec *cs, struct cmndspec_list *csl);\nvoid free_cmndspecs(struct cmndspec_list *csl);\nvoid free_privilege(struct privilege *priv);\nvoid free_userspec(struct userspec *us);\nvoid free_userspecs(struct userspec_list *usl);\nvoid free_default(struct defaults *def);\nvoid free_defaults(struct defaults_list *defs);\nbool init_parser(struct sudoers_context *ctx, const char *file);\nvoid init_parse_tree(struct sudoers_parse_tree *parse_tree, char *lhost, char *shost, struct sudoers_context *ctx, struct sudo_nss *nss);\nvoid free_parse_tree(struct sudoers_parse_tree *parse_tree);\nbool parser_leak_add(enum parser_leak_types type, void *v);\nbool parser_leak_remove(enum parser_leak_types type, void *v);\nvoid parser_leak_init(void);\nvoid reparent_parse_tree(struct sudoers_parse_tree *new_tree);\nint sudoersparse(void);\nuid_t sudoers_file_uid(void);\ngid_t sudoers_file_gid(void);\nmode_t sudoers_file_mode(void);\nbool sudoers_error_recovery(void);\nbool sudoers_strict(void);\n\n/* match_addr.c */\nbool addr_matches(char *n);\n\n/* match_command.c */\nbool command_matches(struct sudoers_context *ctx, const char *sudoers_cmnd, const char *sudoers_args, const char *runchroot, struct cmnd_info *info, const struct command_digest_list *digests);\n\n/* match_digest.c */\nbool digest_matches(int fd, const char *path, const struct command_digest_list *digests);\n\n/* match.c */\nstruct group;\nstruct passwd;\nbool group_matches(const char *sudoers_group, const struct group *gr);\nbool hostname_matches(const char *shost, const char *lhost, const char *pattern);\nbool netgr_matches(const struct sudo_nss *nss, const char *netgr, const char *lhost, const char *shost, const char *user);\nbool usergr_matches(const char *group, const char *user, const struct passwd *pw);\nbool userpw_matches(const char *sudoers_user, const char *user, const struct passwd *pw);\nint cmnd_matches(const struct sudoers_parse_tree *parse_tree, const struct member *m, const char *runchroot, struct cmnd_info *info);\nint cmnd_matches_all(const struct sudoers_parse_tree *parse_tree, const struct member *m, const char *runchroot, struct cmnd_info *info);\nint cmndlist_matches(const struct sudoers_parse_tree *parse_tree, const struct member_list *list, const char *runchroot, struct cmnd_info *info);\nint host_matches(const struct sudoers_parse_tree *parse_tree, const struct passwd *pw, const char *host, const char *shost, const struct member *m);\nint hostlist_matches(const struct sudoers_parse_tree *parse_tree, const struct passwd *pw, const struct member_list *list);\nint runaslist_matches(const struct sudoers_parse_tree *parse_tree, const struct member_list *user_list, const struct member_list *group_list, struct member **matching_user, struct member **matching_group);\nint user_matches(const struct sudoers_parse_tree *parse_tree, const struct passwd *pw, const struct member *m);\nint userlist_matches(const struct sudoers_parse_tree *parse_tree, const struct passwd *pw, const struct member_list *list);\nconst char *sudo_getdomainname(void);\nstruct gid_list *runas_getgroups(const struct sudoers_context *ctx);\n\n/* toke.l */\nYY_DECL;\nvoid sudoersrestart(FILE *);\nextern FILE *sudoersin;\nextern char *sudoers;\n\n/* base64.c */\nsize_t base64_decode(const char *str, unsigned char *dst, size_t dsize);\nsize_t base64_encode(const unsigned char *in, size_t in_len, char *out, size_t out_len);\n\n/* timeout.c */\nint parse_timeout(const char *timestr);\n\n/* gentime.c */\ntime_t parse_gentime(const char *expstr);\n\n/* filedigest.c */\nunsigned char *sudo_filedigest(int fd, const char *file, unsigned int digest_type, size_t *digest_len);\n\n/* digestname.c */\nconst char *digest_type_to_name(unsigned int digest_type);\n\n/* parse.c */\nstruct sudo_nss_list;\nunsigned int sudoers_lookup(struct sudo_nss_list *snl, struct sudoers_context *ctx, time_t now, sudoers_lookup_callback_fn_t callback, void *cb_data, int *cmnd_status, int pwflag);\n\n/* display.c */\nint display_privs(struct sudoers_context *ctx, const struct sudo_nss_list *snl, struct passwd *pw, bool verbose);\nint display_cmnd(struct sudoers_context *ctx, const struct sudo_nss_list *snl, struct passwd *pw, bool verbose);\n\n/* parse_ldif.c */\nbool sudoers_parse_ldif(struct sudoers_parse_tree *parse_tree, FILE *fp, const char *sudoers_base, bool store_options);\n\n/* fmtsudoers.c */\nstruct sudo_lbuf;\nbool sudoers_format_cmndspec(struct sudo_lbuf *lbuf, const struct sudoers_parse_tree *parse_tree, const struct cmndspec *cs, const struct cmndspec *prev_cs, struct cmndtag tags, bool expand_aliases);\nbool sudoers_format_default(struct sudo_lbuf *lbuf, const struct defaults *d);\nbool sudoers_format_member(struct sudo_lbuf *lbuf, const struct sudoers_parse_tree *parse_tree, const struct member *m, const char *separator, short alias_type);\nbool sudoers_defaults_to_tags(const char *var, const char *val, int op, struct cmndtag *tags);\nbool sudoers_defaults_list_to_tags(const struct defaults_list *defs, struct cmndtag *tags);\n\n/* fmtsudoers_cvt.c */\nbool sudoers_format_privilege(struct sudo_lbuf *lbuf, const struct sudoers_parse_tree *parse_tree, const struct privilege *priv, bool expand_aliases);\nbool sudoers_format_userspec(struct sudo_lbuf *lbuf, const struct sudoers_parse_tree *parse_tree, const struct userspec *us, bool expand_aliases);\nbool sudoers_format_userspecs(struct sudo_lbuf *lbuf, const struct sudoers_parse_tree *parse_tree, const char *separator, bool expand_aliases, bool flush);\nbool sudoers_format_default_line(struct sudo_lbuf *lbuf, const struct sudoers_parse_tree *parse_tree, const struct defaults *d, struct defaults **next, bool expand_aliases);\n\n#endif /* SUDOERS_PARSE_H */\n"], "fixing_code": ["/*\n * SPDX-License-Identifier: ISC\n *\n * Copyright (c) 1999-2005, 2010-2015 Todd C. Miller <Todd.Miller@sudo.ws>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n *\n * Sponsored in part by the Defense Advanced Research Projects\n * Agency (DARPA) and Air Force Research Laboratory, Air Force\n * Materiel Command, USAF, under agreement number F39502-99-1-0512.\n */\n\n/*\n * This is an open source non-commercial project. Dear PVS-Studio, please check it.\n * PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n */\n\n#include <config.h>\n\n#include <sys/types.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <pwd.h>\n\n#include \"sudoers.h\"\n#include \"sudo_auth.h\"\n\n#define DESLEN\t\t\t13\n#define HAS_AGEINFO(p, l)\t(l == 18 && p[DESLEN] == ',')\n\nint\nsudo_passwd_init(const struct sudoers_context *ctx, struct passwd *pw,\n    sudo_auth *auth)\n{\n    debug_decl(sudo_passwd_init, SUDOERS_DEBUG_AUTH);\n\n    /* Only initialize once. */\n    if (auth->data != NULL)\n\tdebug_return_int(AUTH_SUCCESS);\n\n#ifdef HAVE_SKEYACCESS\n    if (skeyaccess(pw, ctx->user.tty, NULL, NULL) == 0)\n\tdebug_return_int(AUTH_FAILURE);\n#endif\n    sudo_setspent();\n    auth->data = sudo_getepw(pw);\n    sudo_endspent();\n    debug_return_int(auth->data ? AUTH_SUCCESS : AUTH_ERROR);\n}\n\n#ifdef HAVE_CRYPT\nint\nsudo_passwd_verify(const struct sudoers_context *ctx, struct passwd *pw,\n    const char *pass, sudo_auth *auth, struct sudo_conv_callback *callback)\n{\n    char des_pass[9], *epass;\n    char *pw_epasswd = auth->data;\n    size_t pw_len;\n    int ret;\n    debug_decl(sudo_passwd_verify, SUDOERS_DEBUG_AUTH);\n\n    /* An empty plain-text password must match an empty encrypted password. */\n    if (pass[0] == '\\0')\n\tdebug_return_int(pw_epasswd[0] ? AUTH_FAILURE : AUTH_SUCCESS);\n\n    /*\n     * Truncate to 8 chars if standard DES since not all crypt()'s do this.\n     */\n    pw_len = strlen(pw_epasswd);\n    if (pw_len == DESLEN || HAS_AGEINFO(pw_epasswd, pw_len)) {\n\t(void)strlcpy(des_pass, pass, sizeof(des_pass));\n\tpass = des_pass;\n    }\n\n    /*\n     * Normal UN*X password check.\n     * HP-UX may add aging info (separated by a ',') at the end so\n     * only compare the first DESLEN characters in that case.\n     */\n    epass = (char *) crypt(pass, pw_epasswd);\n    ret = AUTH_FAILURE;\n    if (epass != NULL) {\n\tif (HAS_AGEINFO(pw_epasswd, pw_len) && strlen(epass) == DESLEN) {\n\t    if (strncmp(pw_epasswd, epass, DESLEN) == 0)\n\t\tret = AUTH_SUCCESS;\n\t} else {\n\t    if (strcmp(pw_epasswd, epass) == 0)\n\t\tret = AUTH_SUCCESS;\n\t}\n    }\n\n    explicit_bzero(des_pass, sizeof(des_pass));\n\n    debug_return_int(ret);\n}\n#else\nint\nsudo_passwd_verify(const struct sudoers_context *ctx, struct passwd *pw,\n    const char *pass, sudo_auth *auth, struct sudo_conv_callback *callback)\n{\n    char *pw_passwd = auth->data;\n    int ret;\n    debug_decl(sudo_passwd_verify, SUDOERS_DEBUG_AUTH);\n\n    /* Simple string compare for systems without crypt(). */\n    if (strcmp(pass, pw_passwd) == 0)\n\tret = AUTH_SUCCESS;\n    else\n\tret = AUTH_FAILURE;\n\n    debug_return_int(ret);\n}\n#endif\n\nint\nsudo_passwd_cleanup(const struct sudoers_context *ctx, struct passwd *pw,\n    sudo_auth *auth, bool force)\n{\n    debug_decl(sudo_passwd_cleanup, SUDOERS_DEBUG_AUTH);\n\n    if (auth->data != NULL) {\n\t/* Zero out encrypted password before freeing. */\n\tsize_t len = strlen((char *)auth->data);\n\tfreezero(auth->data, len);\n\tauth->data = NULL;\n    }\n\n    debug_return_int(AUTH_SUCCESS);\n}\n", "/*\n * SPDX-License-Identifier: ISC\n *\n * Copyright (c) 1999-2005, 2008-2020 Todd C. Miller <Todd.Miller@sudo.ws>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n *\n * Sponsored in part by the Defense Advanced Research Projects\n * Agency (DARPA) and Air Force Research Laboratory, Air Force\n * Materiel Command, USAF, under agreement number F39502-99-1-0512.\n */\n\n/*\n * This is an open source non-commercial project. Dear PVS-Studio, please check it.\n * PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n */\n\n#include <config.h>\n\n#include <sys/types.h>\n#include <stdio.h>\n#include <stdlib.h>\n#if defined(HAVE_STDINT_H)\n# include <stdint.h>\n#elif defined(HAVE_INTTYPES_H)\n# include <inttypes.h>\n#endif\n#include <string.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <time.h>\n#include <signal.h>\n\n#include \"sudoers.h\"\n#include \"sudo_auth.h\"\n#include \"insults.h\"\n#include \"timestamp.h\"\n\nstatic sudo_auth auth_switch[] = {\n/* Standalone entries first */\n#ifdef HAVE_AIXAUTH\n    AUTH_ENTRY(\"aixauth\", FLAG_STANDALONE, sudo_aix_init, NULL, sudo_aix_verify, NULL, sudo_aix_cleanup, NULL, NULL)\n#endif\n#ifdef HAVE_PAM\n    AUTH_ENTRY(\"pam\", FLAG_STANDALONE, sudo_pam_init, NULL, sudo_pam_verify, sudo_pam_approval, sudo_pam_cleanup, sudo_pam_begin_session, sudo_pam_end_session)\n#endif\n#ifdef HAVE_SECURID\n    AUTH_ENTRY(\"SecurId\", FLAG_STANDALONE, sudo_securid_init, sudo_securid_setup, sudo_securid_verify, NULL, NULL, NULL, NULL)\n#endif\n#ifdef HAVE_SIA_SES_INIT\n    AUTH_ENTRY(\"sia\", FLAG_STANDALONE, NULL, sudo_sia_setup, sudo_sia_verify, NULL, sudo_sia_cleanup, sudo_sia_begin_session, NULL)\n#endif\n#ifdef HAVE_FWTK\n    AUTH_ENTRY(\"fwtk\", FLAG_STANDALONE, sudo_fwtk_init, NULL, sudo_fwtk_verify, NULL, sudo_fwtk_cleanup, NULL, NULL)\n#endif\n#ifdef HAVE_BSD_AUTH_H\n    AUTH_ENTRY(\"bsdauth\", FLAG_STANDALONE, bsdauth_init, NULL, bsdauth_verify, bsdauth_approval, bsdauth_cleanup, NULL, NULL)\n#endif\n\n/* Non-standalone entries */\n#ifndef WITHOUT_PASSWD\n    AUTH_ENTRY(\"passwd\", 0, sudo_passwd_init, NULL, sudo_passwd_verify, NULL, sudo_passwd_cleanup, NULL, NULL)\n#endif\n#if defined(HAVE_GETPRPWNAM) && !defined(WITHOUT_PASSWD)\n    AUTH_ENTRY(\"secureware\", 0, sudo_secureware_init, NULL, sudo_secureware_verify, NULL, sudo_secureware_cleanup, NULL, NULL)\n#endif\n#ifdef HAVE_AFS\n    AUTH_ENTRY(\"afs\", 0, NULL, NULL, sudo_afs_verify, NULL, NULL, NULL, NULL)\n#endif\n#ifdef HAVE_DCE\n    AUTH_ENTRY(\"dce\", 0, NULL, NULL, sudo_dce_verify, NULL, NULL, NULL, NULL)\n#endif\n#ifdef HAVE_KERB5\n    AUTH_ENTRY(\"kerb5\", 0, sudo_krb5_init, sudo_krb5_setup, sudo_krb5_verify, NULL, sudo_krb5_cleanup, NULL, NULL)\n#endif\n#ifdef HAVE_SKEY\n    AUTH_ENTRY(\"S/Key\", 0, NULL, sudo_rfc1938_setup, sudo_rfc1938_verify, NULL, NULL, NULL, NULL)\n#endif\n#ifdef HAVE_OPIE\n    AUTH_ENTRY(\"OPIE\", 0, NULL, sudo_rfc1938_setup, sudo_rfc1938_verify, NULL, NULL, NULL, NULL)\n#endif\n    AUTH_ENTRY(NULL, 0, NULL, NULL, NULL, NULL, NULL, NULL, NULL)\n};\n\nstatic bool standalone;\n\n/*\n * Initialize sudoers authentication method(s).\n * Returns 0 on success and -1 on error.\n */\nint\nsudo_auth_init(const struct sudoers_context *ctx, struct passwd *pw,\n    unsigned int mode)\n{\n    sudo_auth *auth;\n    int status = AUTH_SUCCESS;\n    debug_decl(sudo_auth_init, SUDOERS_DEBUG_AUTH);\n\n    if (auth_switch[0].name == NULL)\n\tdebug_return_int(0);\n\n    /* Initialize auth methods and unconfigure the method if necessary. */\n    for (auth = auth_switch; auth->name; auth++) {\n\tif (ISSET(mode, MODE_NONINTERACTIVE))\n\t    SET(auth->flags, FLAG_NONINTERACTIVE);\n\tif (auth->init && !IS_DISABLED(auth)) {\n\t    /* Disable if it failed to init unless there was a fatal error. */\n\t    status = (auth->init)(ctx, pw, auth);\n\t    switch (status) {\n\t    case AUTH_SUCCESS:\n\t\tbreak;\n\t    case AUTH_FAILURE:\n\t\tSET(auth->flags, FLAG_DISABLED);\n\t\tbreak;\n\t    default:\n\t\t/* Assume error msg already printed. */\n\t\tdebug_return_int(-1);\n\t    }\n\t}\n    }\n\n    /*\n     * Make sure we haven't mixed standalone and shared auth methods.\n     * If there are multiple standalone methods, only use the first one.\n     */\n    if ((standalone = IS_STANDALONE(&auth_switch[0]))) {\n\tbool found = false;\n\tfor (auth = auth_switch; auth->name; auth++) {\n\t    if (IS_DISABLED(auth))\n\t\tcontinue;\n\t    if (!IS_STANDALONE(auth)) {\n\t\taudit_failure(ctx, ctx->runas.argv,\n\t\t    N_(\"invalid authentication methods\"));\n\t\tlog_warningx(ctx, SLOG_SEND_MAIL,\n\t\t    N_(\"Invalid authentication methods compiled into sudo!  \"\n\t\t    \"You may not mix standalone and non-standalone authentication.\"));\n\t\tdebug_return_int(-1);\n\t    }\n\t    if (!found) {\n\t\t/* Found first standalone method. */\n\t\tfound = true;\n\t\tcontinue;\n\t    }\n\t    /* Disable other standalone methods. */\n\t    SET(auth->flags, FLAG_DISABLED);\n\t}\n    }\n\n    /* Set FLAG_ONEANDONLY if there is only one auth method. */\n    for (auth = auth_switch; auth->name; auth++) {\n\t/* Find first enabled auth method. */\n\tif (!IS_DISABLED(auth)) {\n\t    sudo_auth *first = auth;\n\t    /* Check for others. */\n\t    for (; auth->name; auth++) {\n\t\tif (!IS_DISABLED(auth))\n\t\t    break;\n\t    }\n\t    if (auth->name == NULL)\n\t\tSET(first->flags, FLAG_ONEANDONLY);\n\t    break;\n\t}\n    }\n\n    debug_return_int(0);\n}\n\n/*\n * Cleanup all authentication approval methods.\n * Returns true on success, false on failure and -1 on error.\n */\nint\nsudo_auth_approval(const struct sudoers_context *ctx, struct passwd *pw,\n    unsigned int validated, bool exempt)\n{\n    sudo_auth *auth;\n    debug_decl(sudo_auth_approval, SUDOERS_DEBUG_AUTH);\n\n    /* Call approval routines. */\n    for (auth = auth_switch; auth->name; auth++) {\n\tif (auth->approval && !IS_DISABLED(auth)) {\n\t    int status = (auth->approval)(ctx, pw, auth, exempt);\n\t    if (status != AUTH_SUCCESS) {\n\t\t/* Assume error msg already printed. */\n\t\tlog_auth_failure(ctx, validated, 0);\n\t\tdebug_return_int(status == AUTH_FAILURE ? false : -1);\n\t    }\n\t}\n    }\n    debug_return_int(true);\n}\n\n/*\n * Cleanup all authentication methods.\n * Returns 0 on success and -1 on error.\n */\nint\nsudo_auth_cleanup(const struct sudoers_context *ctx, struct passwd *pw,\n    bool force)\n{\n    sudo_auth *auth;\n    debug_decl(sudo_auth_cleanup, SUDOERS_DEBUG_AUTH);\n\n    /* Call cleanup routines. */\n    for (auth = auth_switch; auth->name; auth++) {\n\tif (auth->cleanup && !IS_DISABLED(auth)) {\n\t    int status = (auth->cleanup)(ctx, pw, auth, force);\n\t    if (status != AUTH_SUCCESS) {\n\t\t/* Assume error msg already printed. */\n\t\tdebug_return_int(-1);\n\t    }\n\t}\n    }\n    debug_return_int(0);\n}\n\nstatic void\npass_warn(void)\n{\n    const char *warning = def_badpass_message;\n    debug_decl(pass_warn, SUDOERS_DEBUG_AUTH);\n\n#ifdef INSULT\n    if (def_insults)\n\twarning = INSULT;\n#endif\n    sudo_printf(SUDO_CONV_ERROR_MSG|SUDO_CONV_PREFER_TTY, \"%s\\n\", warning);\n\n    debug_return;\n}\n\nstatic bool\nuser_interrupted(void)\n{\n    sigset_t mask;\n\n    return (sigpending(&mask) == 0 &&\n\t(sigismember(&mask, SIGINT) || sigismember(&mask, SIGQUIT)));\n}\n\n/*\n * Verify the specified user.\n * Returns true if verified, false if not or -1 on error.\n */\nint\nverify_user(const struct sudoers_context *ctx, struct passwd *pw, char *prompt,\n    unsigned int validated, struct sudo_conv_callback *callback)\n{\n    unsigned int ntries;\n    int ret, status, success = AUTH_FAILURE;\n    sudo_auth *auth;\n    sigset_t mask, omask;\n    struct sigaction sa, saved_sigtstp;\n    debug_decl(verify_user, SUDOERS_DEBUG_AUTH);\n\n    /* Make sure we have at least one auth method. */\n    if (auth_switch[0].name == NULL) {\n\taudit_failure(ctx, ctx->runas.argv, N_(\"no authentication methods\"));\n    \tlog_warningx(ctx, SLOG_SEND_MAIL,\n\t    N_(\"There are no authentication methods compiled into sudo!  \"\n\t    \"If you want to turn off authentication, use the \"\n\t    \"--disable-authentication configure option.\"));\n\tdebug_return_int(-1);\n    }\n\n    /* Enable suspend during password entry. */\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = SA_RESTART;\n    sa.sa_handler = SIG_DFL;\n    (void) sigaction(SIGTSTP, &sa, &saved_sigtstp);\n\n    /*\n     * We treat authentication as a critical section and block\n     * keyboard-generated signals such as SIGINT and SIGQUIT\n     * which might otherwise interrupt a sleep(3).\n     * They are temporarily unblocked by auth_getpass().\n     */\n    sigemptyset(&mask);\n    sigaddset(&mask, SIGINT);\n    sigaddset(&mask, SIGQUIT);\n    (void) sigprocmask(SIG_BLOCK, &mask, &omask);\n\n    for (ntries = 0; ntries < def_passwd_tries; ntries++) {\n\tint num_methods = 0;\n\tchar *pass = NULL;\n\n\t/* If user attempted to interrupt password verify, quit now. */\n\tif (user_interrupted())\n\t    goto done;\n\n\tif (ntries != 0)\n\t    pass_warn();\n\n\t/* Do any per-method setup and unconfigure the method if needed */\n\tfor (auth = auth_switch; auth->name; auth++) {\n\t    if (IS_DISABLED(auth))\n\t\tcontinue;\n\t    num_methods++;\n\t    if (auth->setup != NULL) {\n\t\tstatus = (auth->setup)(ctx, pw, &prompt, auth);\n\t\tif (status == AUTH_FAILURE)\n\t\t    SET(auth->flags, FLAG_DISABLED);\n\t\telse if (status == AUTH_NONINTERACTIVE)\n\t\t    goto done;\n\t\telse if (status != AUTH_SUCCESS || user_interrupted())\n\t\t    goto done;\t\t/* assume error msg already printed */\n\t    }\n\t}\n\tif (num_methods == 0) {\n\t    audit_failure(ctx, ctx->runas.argv,\n\t\tN_(\"no authentication methods\"));\n\t    log_warningx(ctx, SLOG_SEND_MAIL,\n\t\tN_(\"Unable to initialize authentication methods.\"));\n\t    debug_return_int(-1);\n\t}\n\n\t/* Get the password unless the auth function will do it for us */\n\tif (!standalone) {\n\t    if (IS_NONINTERACTIVE(&auth_switch[0])) {\n\t\tsuccess = AUTH_NONINTERACTIVE;\n\t\tgoto done;\n\t    }\n\t    pass = auth_getpass(prompt, SUDO_CONV_PROMPT_ECHO_OFF, callback);\n\t    if (pass == NULL)\n\t\tbreak;\n\t}\n\n\t/* Call authentication functions. */\n\tfor (auth = auth_switch; auth->name; auth++) {\n\t    if (IS_DISABLED(auth))\n\t\tcontinue;\n\n\t    success = auth->status = (auth->verify)(ctx, pw,\n\t\tstandalone ? prompt : pass, auth, callback);\n\t    if (success != AUTH_FAILURE)\n\t\tbreak;\n\t}\n\tif (pass != NULL)\n\t    freezero(pass, strlen(pass));\n\n\tif (success != AUTH_FAILURE)\n\t    goto done;\n    }\n\ndone:\n    /* Restore signal handlers and signal mask. */\n    (void) sigaction(SIGTSTP, &saved_sigtstp, NULL);\n    (void) sigprocmask(SIG_SETMASK, &omask, NULL);\n\n    switch (success) {\n\tcase AUTH_SUCCESS:\n\t    ret = true;\n\t    break;\n\tcase AUTH_INTR:\n\tcase AUTH_FAILURE:\n\t    if (ntries != 0)\n\t\tSET(validated, FLAG_BAD_PASSWORD);\n\t    log_auth_failure(ctx, validated, ntries);\n\t    ret = false;\n\t    break;\n\tcase AUTH_NONINTERACTIVE:\n\t    SET(validated, FLAG_NO_USER_INPUT);\n\t    FALLTHROUGH;\n\tdefault:\n\t    log_auth_failure(ctx, validated, 0);\n\t    ret = -1;\n\t    break;\n    }\n\n    debug_return_int(ret);\n}\n\n/*\n * Call authentication method begin session hooks.\n * Returns true on success, false on failure and -1 on error.\n */\nint\nsudo_auth_begin_session(const struct sudoers_context *ctx, struct passwd *pw,\n    char **user_env[])\n{\n    sudo_auth *auth;\n    int ret = true;\n    debug_decl(sudo_auth_begin_session, SUDOERS_DEBUG_AUTH);\n\n    for (auth = auth_switch; auth->name; auth++) {\n\tif (auth->begin_session && !IS_DISABLED(auth)) {\n\t    int status = (auth->begin_session)(ctx, pw, user_env, auth);\n\t    switch (status) {\n\t    case AUTH_SUCCESS:\n\t\tbreak;\n\t    case AUTH_FAILURE:\n\t\tret = false;\n\t\tbreak;\n\t    default:\n\t\t/* Assume error msg already printed. */\n\t\tret = -1;\n\t\tbreak;\n\t    }\n\t}\n    }\n    debug_return_int(ret);\n}\n\nbool\nsudo_auth_needs_end_session(void)\n{\n    sudo_auth *auth;\n    bool needed = false;\n    debug_decl(sudo_auth_needs_end_session, SUDOERS_DEBUG_AUTH);\n\n    for (auth = auth_switch; auth->name; auth++) {\n\tif (auth->end_session && !IS_DISABLED(auth)) {\n\t    needed = true;\n\t    break;\n\t}\n    }\n    debug_return_bool(needed);\n}\n\n/*\n * Call authentication method end session hooks.\n * Returns true on success, false on failure and -1 on error.\n */\nint\nsudo_auth_end_session(void)\n{\n    sudo_auth *auth;\n    int ret = true;\n    int status;\n    debug_decl(sudo_auth_end_session, SUDOERS_DEBUG_AUTH);\n\n    for (auth = auth_switch; auth->name; auth++) {\n\tif (auth->end_session && !IS_DISABLED(auth)) {\n\t    status = (auth->end_session)(auth);\n\t    switch (status) {\n\t    case AUTH_SUCCESS:\n\t\tbreak;\n\t    case AUTH_FAILURE:\n\t\tret = false;\n\t\tbreak;\n\t    default:\n\t\t/* Assume error msg already printed. */\n\t\tret = -1;\n\t\tbreak;\n\t    }\n\t}\n    }\n    debug_return_int(ret);\n}\n\n/*\n * Prompts the user for a password using the conversation function.\n * Returns the plaintext password or NULL.\n * The user is responsible for freeing the returned value.\n */\nchar *\nauth_getpass(const char *prompt, int type, struct sudo_conv_callback *callback)\n{\n    struct sudo_conv_message msg;\n    struct sudo_conv_reply repl;\n    sigset_t mask, omask;\n    debug_decl(auth_getpass, SUDOERS_DEBUG_AUTH);\n\n    /* Display lecture if needed and we haven't already done so. */\n    display_lecture(callback);\n\n    /* Mask user input if pwfeedback set and echo is off. */\n    if (type == SUDO_CONV_PROMPT_ECHO_OFF && def_pwfeedback)\n\ttype = SUDO_CONV_PROMPT_MASK;\n\n    /* If visiblepw set, do not error out if there is no tty. */\n    if (def_visiblepw)\n\ttype |= SUDO_CONV_PROMPT_ECHO_OK;\n\n    /* Unblock SIGINT and SIGQUIT during password entry. */\n    /* XXX - do in tgetpass() itself instead? */\n    sigemptyset(&mask);\n    sigaddset(&mask, SIGINT);\n    sigaddset(&mask, SIGQUIT);\n    (void) sigprocmask(SIG_UNBLOCK, &mask, &omask);\n\n    /* Call conversation function. */\n    memset(&msg, 0, sizeof(msg));\n    msg.msg_type = type;\n    msg.timeout = (int)def_passwd_timeout.tv_sec;\n    msg.msg = prompt;\n    memset(&repl, 0, sizeof(repl));\n    sudo_conv(1, &msg, &repl, callback);\n    /* XXX - check for ENOTTY? */\n\n    /* Restore previous signal mask. */\n    (void) sigprocmask(SIG_SETMASK, &omask, NULL);\n\n    debug_return_str_masked(repl.reply);\n}\n\nvoid\ndump_auth_methods(void)\n{\n    sudo_auth *auth;\n    debug_decl(dump_auth_methods, SUDOERS_DEBUG_AUTH);\n\n    sudo_printf(SUDO_CONV_INFO_MSG, _(\"Authentication methods:\"));\n    for (auth = auth_switch; auth->name; auth++)\n\tsudo_printf(SUDO_CONV_INFO_MSG, \" '%s'\", auth->name);\n    sudo_printf(SUDO_CONV_INFO_MSG, \"\\n\");\n\n    debug_return;\n}\n", "/*\n * SPDX-License-Identifier: ISC\n *\n * Copyright (c) 1999-2005, 2007-2016, 2018 Todd C. Miller <Todd.Miller@sudo.ws>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#ifndef SUDO_AUTH_H\n#define SUDO_AUTH_H\n\n/* Auth function return values (rowhammer resistent).  */\n#define AUTH_SUCCESS\t\t0x52a2925\t/* 0101001010100010100100100101 */\n#define AUTH_FAILURE\t\t0xad5d6da\t/* 1010110101011101011011011010 */\n#define AUTH_INTR\t\t0x69d61fc8\t/* 1101001110101100001111111001000 */\n#define AUTH_ERROR\t\t0x1629e037\t/* 0010110001010011110000000110111 */\n#define AUTH_NONINTERACTIVE\t0x1fc8d3ac\t/* 11111110010001101001110101100 */\n\ntypedef struct sudo_auth {\n    unsigned int flags;\t\t/* various flags, see below */\n    int status;\t\t\t/* status from verify routine */\n    const char *name;\t\t/* name of the method as a string */\n    void *data;\t\t\t/* method-specific data pointer */\n    int (*init)(const struct sudoers_context *ctx, struct passwd *pw, struct sudo_auth *auth);\n    int (*setup)(const struct sudoers_context *ctx, struct passwd *pw, char **prompt, struct sudo_auth *auth);\n    int (*verify)(const struct sudoers_context *ctx, struct passwd *pw, const char *p, struct sudo_auth *auth, struct sudo_conv_callback *callback);\n    int (*approval)(const struct sudoers_context *ctx, struct passwd *pw, struct sudo_auth *auth, bool exempt);\n    int (*cleanup)(const struct sudoers_context *ctx, struct passwd *pw, struct sudo_auth *auth, bool force);\n    int (*begin_session)(const struct sudoers_context *ctx, struct passwd *pw, char **user_env[], struct sudo_auth *auth);\n    int (*end_session)(struct sudo_auth *auth);\n} sudo_auth;\n\n/* Values for sudo_auth.flags.  */\n#define FLAG_DISABLED\t\t0x02U\t/* method disabled */\n#define FLAG_STANDALONE\t\t0x04U\t/* standalone auth method */\n#define FLAG_ONEANDONLY\t\t0x08U\t/* one and only auth method */\n#define FLAG_NONINTERACTIVE\t0x10U\t/* no user input allowed */\n\n/* Shortcuts for using the flags above. */\n#define IS_DISABLED(x)\t\t((x)->flags & FLAG_DISABLED)\n#define IS_STANDALONE(x)\t((x)->flags & FLAG_STANDALONE)\n#define IS_ONEANDONLY(x)\t((x)->flags & FLAG_ONEANDONLY)\n#define IS_NONINTERACTIVE(x)\t((x)->flags & FLAG_NONINTERACTIVE)\n\n/* Like tgetpass() but uses conversation function */\nchar *auth_getpass(const char *prompt, int type, struct sudo_conv_callback *callback);\n\n/* Pointer to conversation function to use with auth_getpass(). */\nextern sudo_conv_t sudo_conv;\n\n/* Prototypes for standalone methods */\nint bsdauth_init(const struct sudoers_context *ctx, struct passwd *pw, sudo_auth *auth);\nint bsdauth_verify(const struct sudoers_context *ctx, struct passwd *pw, const char *prompt, sudo_auth *auth, struct sudo_conv_callback *callback);\nint bsdauth_approval(const struct sudoers_context *ctx, struct passwd *pw, sudo_auth *auth, bool exempt);\nint bsdauth_cleanup(const struct sudoers_context *ctx, struct passwd *pw, sudo_auth *auth, bool force);\nvoid bsdauth_set_style(const char *style);\nint sudo_aix_init(const struct sudoers_context *ctx, struct passwd *pw, sudo_auth *auth);\nint sudo_aix_verify(const struct sudoers_context *ctx, struct passwd *pw, const char *pass, sudo_auth *auth, struct sudo_conv_callback *callback);\nint sudo_aix_cleanup(const struct sudoers_context *ctx, struct passwd *pw, sudo_auth *auth, bool force);\nint sudo_fwtk_init(const struct sudoers_context *ctx, struct passwd *pw, sudo_auth *auth);\nint sudo_fwtk_verify(const struct sudoers_context *ctx, struct passwd *pw, const char *prompt, sudo_auth *auth, struct sudo_conv_callback *callback);\nint sudo_fwtk_cleanup(const struct sudoers_context *ctx, struct passwd *pw, sudo_auth *auth, bool force);\nint sudo_pam_init(const struct sudoers_context *ctx, struct passwd *pw, sudo_auth *auth);\nint sudo_pam_init_quiet(const struct sudoers_context *ctx, struct passwd *pw, sudo_auth *auth);\nint sudo_pam_verify(const struct sudoers_context *ctx, struct passwd *pw, const char *prompt, sudo_auth *auth, struct sudo_conv_callback *callback);\nint sudo_pam_approval(const struct sudoers_context *ctx, struct passwd *pw, sudo_auth *auth, bool exempt);\nint sudo_pam_cleanup(const struct sudoers_context *ctx, struct passwd *pw, sudo_auth *auth, bool force);\nint sudo_pam_begin_session(const struct sudoers_context *ctx, struct passwd *pw, char **user_env[], sudo_auth *auth);\nint sudo_pam_end_session(sudo_auth *auth);\nint sudo_securid_init(const struct sudoers_context *ctx, struct passwd *pw, sudo_auth *auth);\nint sudo_securid_setup(const struct sudoers_context *ctx, struct passwd *pw, char **prompt, sudo_auth *auth);\nint sudo_securid_verify(const struct sudoers_context *ctx, struct passwd *pw, const char *pass, sudo_auth *auth, struct sudo_conv_callback *callback);\nint sudo_sia_setup(const struct sudoers_context *ctx, struct passwd *pw, char **prompt, sudo_auth *auth);\nint sudo_sia_verify(const struct sudoers_context *ctx, struct passwd *pw, const char *prompt, sudo_auth *auth, struct sudo_conv_callback *callback);\nint sudo_sia_cleanup(const struct sudoers_context *ctx, struct passwd *pw, sudo_auth *auth, bool force);\nint sudo_sia_begin_session(const struct sudoers_context *ctx, struct passwd *pw, char **user_env[], sudo_auth *auth);\n\n/* Prototypes for normal methods */\nint sudo_afs_verify(const struct sudoers_context *ctx, struct passwd *pw, const char *pass, sudo_auth *auth, struct sudo_conv_callback *callback);\nint sudo_dce_verify(const struct sudoers_context *ctx, struct passwd *pw, const char *pass, sudo_auth *auth, struct sudo_conv_callback *callback);\nint sudo_krb5_init(const struct sudoers_context *ctx, struct passwd *pw, sudo_auth *auth);\nint sudo_krb5_setup(const struct sudoers_context *ctx, struct passwd *pw, char **prompt, sudo_auth *auth);\nint sudo_krb5_verify(const struct sudoers_context *ctx, struct passwd *pw, const char *pass, sudo_auth *auth, struct sudo_conv_callback *callback);\nint sudo_krb5_cleanup(const struct sudoers_context *ctx, struct passwd *pw, sudo_auth *auth, bool force);\nint sudo_passwd_init(const struct sudoers_context *ctx, struct passwd *pw, sudo_auth *auth);\nint sudo_passwd_verify(const struct sudoers_context *ctx, struct passwd *pw, const char *pass, sudo_auth *auth, struct sudo_conv_callback *callback);\nint sudo_passwd_cleanup(const struct sudoers_context *ctx, struct passwd *pw, sudo_auth *auth, bool force);\nint sudo_rfc1938_setup(const struct sudoers_context *ctx, struct passwd *pw, char **prompt, sudo_auth *auth);\nint sudo_rfc1938_verify(const struct sudoers_context *ctx, struct passwd *pw, const char *pass, sudo_auth *auth, struct sudo_conv_callback *callback);\nint sudo_secureware_init(const struct sudoers_context *ctx, struct passwd *pw, sudo_auth *auth);\nint sudo_secureware_verify(const struct sudoers_context *ctx, struct passwd *pw, const char *pass, sudo_auth *auth, struct sudo_conv_callback *callback);\nint sudo_secureware_cleanup(const struct sudoers_context *ctx, struct passwd *pw, sudo_auth *auth, bool force);\n\n/* Fields: name, flags, init, setup, verify, approval, cleanup, begin_sess, end_sess */\n#define AUTH_ENTRY(n, f, i, s, v, a, c, b, e) \\\n\t{ (f), AUTH_FAILURE, (n), NULL, (i), (s), (v), (a), (c) , (b), (e) },\n\n#endif /* SUDO_AUTH_H */\n", "/*\n * SPDX-License-Identifier: ISC\n *\n * Copyright (c) 2004-2005, 2007-2023 Todd C. Miller <Todd.Miller@sudo.ws>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n/*\n * This is an open source non-commercial project. Dear PVS-Studio, please check it.\n * PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n */\n\n#include <config.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <pwd.h>\n\n#include \"sudoers.h\"\n#include <gram.h>\n\nstatic int\nrunas_matches_pw(struct sudoers_parse_tree *parse_tree,\n    const struct cmndspec *cs, const struct passwd *pw)\n{\n    debug_decl(runas_matches_pw, SUDOERS_DEBUG_PARSER);\n\n    if (cs->runasuserlist != NULL)\n\tdebug_return_int(userlist_matches(parse_tree, pw, cs->runasuserlist));\n\n    if (cs->runasgrouplist == NULL) {\n\t/* No explicit runas user or group, use default. */\n\tif (userpw_matches(def_runas_default, pw->pw_name, pw))\n\t    debug_return_int(ALLOW);\n    }\n    debug_return_int(UNSPEC);\n}\n\n/*\n * Look up the user in the sudoers parse tree for pseudo-commands like\n * list, verify and kill.\n */\nstatic unsigned int\nsudoers_lookup_pseudo(struct sudo_nss_list *snl, struct sudoers_context *ctx,\n    time_t now, sudoers_lookup_callback_fn_t callback, void *cb_data,\n    int pwflag)\n{\n    char *saved_runchroot;\n    struct passwd *root_pw = NULL;\n    struct sudo_nss *nss;\n    struct cmndspec *cs;\n    struct privilege *priv;\n    struct userspec *us;\n    struct defaults *def;\n    int nopass, match = DENY;\n    unsigned int validated = 0;\n    enum def_tuple pwcheck;\n    debug_decl(sudoers_lookup_pseudo, SUDOERS_DEBUG_PARSER);\n\n    pwcheck = (pwflag == -1) ? never : sudo_defs_table[pwflag].sd_un.tuple;\n    nopass = (pwcheck == never || pwcheck == all) ? true : false;\n\n    if (ctx->runas.list_pw != NULL) {\n\troot_pw = sudo_getpwuid(ROOT_UID);\n\tif (root_pw == NULL)\n\t    sudo_warnx(U_(\"unknown uid %u\"), ROOT_UID);\n    } else {\n\tSET(validated, FLAG_NO_CHECK);\n    }\n\n    /* Don't use chroot setting for pseudo-commands. */\n    saved_runchroot = def_runchroot;\n    def_runchroot = NULL;\n\n    TAILQ_FOREACH(nss, snl, entries) {\n\tif (nss->query(ctx, nss, ctx->user.pw) == -1) {\n\t    /* The query function should have printed an error message. */\n\t    SET(validated, VALIDATE_ERROR);\n\t    break;\n\t}\n\n\t/*\n\t * We have to traverse the policy forwards, not in reverse,\n\t * to support the \"pwcheck == all\" case.\n\t */\n\tTAILQ_FOREACH(us, &nss->parse_tree->userspecs, entries) {\n\t    int user_match = userlist_matches(nss->parse_tree, ctx->user.pw,\n\t\t&us->users);\n\t    if (user_match != ALLOW) {\n\t\tif (callback != NULL && user_match == DENY) {\n\t\t    callback(nss->parse_tree, us, user_match, NULL, UNSPEC,\n\t\t\tNULL, UNSPEC, UNSPEC, UNSPEC, cb_data);\n\t\t}\n\t\tcontinue;\n\t    }\n\t    TAILQ_FOREACH(priv, &us->privileges, entries) {\n\t\tint priv_nopass = UNSPEC;\n\t\tint host_match = hostlist_matches(nss->parse_tree, ctx->user.pw,\n\t\t    &priv->hostlist);\n\t\tif (host_match != ALLOW) {\n\t\t    if (callback != NULL) {\n\t\t\tcallback(nss->parse_tree, us, user_match, priv,\n\t\t\t    host_match, NULL, UNSPEC, UNSPEC, UNSPEC, cb_data);\n\t\t    }\n\t\t    continue;\n\t\t}\n\t\tTAILQ_FOREACH(def, &priv->defaults, entries) {\n\t\t    if (strcmp(def->var, \"authenticate\") == 0) {\n\t\t\tpriv_nopass = !def->op;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tTAILQ_FOREACH(cs, &priv->cmndlist, entries) {\n\t\t    int cmnd_match = UNSPEC;\n\t\t    int date_match = UNSPEC;\n\t\t    int runas_match = UNSPEC;\n\n\t\t    if (pwcheck == any) {\n\t\t\tif (cs->tags.nopasswd == true || priv_nopass == true)\n\t\t\t    nopass = true;\n\t\t    } else if (pwcheck == all) {\n\t\t\tif (cs->tags.nopasswd != true && priv_nopass != true)\n\t\t\t    nopass = false;\n\t\t    }\n\n\t\t    if (cs->notbefore != UNSPEC) {\n\t\t\tdate_match = now < cs->notbefore ? DENY : ALLOW;\n\t\t    }\n\t\t    if (cs->notafter != UNSPEC) {\n\t\t\tdate_match = now > cs->notafter ? DENY : ALLOW;\n\t\t    }\n\t\t    /*\n\t\t     * Root can list any user's privileges.\n\t\t     * A user may always list their own privileges.\n\t\t     */\n\t\t    if (ctx->user.uid == 0 || ctx->runas.list_pw == NULL ||\n\t\t\t    ctx->user.uid == ctx->runas.list_pw->pw_uid) {\n\t\t\tcmnd_match = ALLOW;\n\t\t\trunas_match = ALLOW;\n\t\t    } else if (date_match != DENY) {\n\t\t\t/*\n\t\t\t * To list another user's prilileges, the runas\n\t\t\t * user must match the list user or root.\n\t\t\t */\n\t\t\trunas_match = runas_matches_pw(nss->parse_tree, cs,\n\t\t\t    ctx->runas.list_pw);\n\t\t\tswitch (runas_match) {\n\t\t\tcase DENY:\n\t\t\t    break;\n\t\t\tcase ALLOW:\n\t\t\t    /*\n\t\t\t     * RunAs user matches list user.\n\t\t\t     * Match on command \"list\" or ALL.\n\t\t\t     */\n\t\t\t    cmnd_match = cmnd_matches(nss->parse_tree,\n\t\t\t\tcs->cmnd, cs->runchroot, NULL);\n\t\t\t    break;\n\t\t\tdefault:\n\t\t\t    /*\n\t\t\t     * RunAs user doesn't match list user.\n\t\t\t     * Only allow listing if the user has\n\t\t\t     * \"sudo ALL\" for root.\n\t\t\t     */\n\t\t\t    if (root_pw != NULL &&\n\t\t\t\t    runas_matches_pw(nss->parse_tree, cs,\n\t\t\t\t    root_pw) == ALLOW) {\n\t\t\t\trunas_match = ALLOW;\n\t\t\t\tcmnd_match = cmnd_matches_all(nss->parse_tree,\n\t\t\t\t    cs->cmnd, cs->runchroot, NULL);\n\t\t\t    }\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    if (callback != NULL) {\n\t\t\tcallback(nss->parse_tree, us, user_match, priv,\n\t\t\t    host_match, cs, date_match, runas_match,\n\t\t\t    cmnd_match, cb_data);\n\t\t    }\n\t\t    if (SPECIFIED(cmnd_match)) {\n\t\t\t/*\n\t\t\t * We take the last match but must process\n\t\t\t * the entire policy for pwcheck == all.\n\t\t\t */\n\t\t\tmatch = cmnd_match;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif (!sudo_nss_can_continue(nss, match))\n\t    break;\n    }\n    if (root_pw != NULL)\n\tsudo_pw_delref(root_pw);\n    if (match == ALLOW || ctx->user.uid == 0) {\n\t/* User has an entry for this host. */\n\tSET(validated, VALIDATE_SUCCESS);\n    } else if (match == DENY)\n\tSET(validated, VALIDATE_FAILURE);\n    if (pwcheck == always && def_authenticate)\n\tSET(validated, FLAG_CHECK_USER);\n    else if (nopass == true)\n\tdef_authenticate = false;\n\n    /* Restore original def_runchroot. */\n    def_runchroot = saved_runchroot;\n\n    debug_return_uint(validated);\n}\n\nstatic void\ninit_cmnd_info(struct sudoers_context *ctx, struct cmnd_info *info)\n{\n    memset(info, 0, sizeof(*info));\n    if (def_intercept || ISSET(ctx->mode, MODE_POLICY_INTERCEPTED))\n\tinfo->intercepted = true;\n}\n\nstatic int\nsudoers_lookup_check(struct sudo_nss *nss, struct sudoers_context *ctx,\n    unsigned int *validated, struct cmnd_info *info, time_t now,\n    sudoers_lookup_callback_fn_t callback, void *cb_data,\n    struct cmndspec **matching_cs, struct defaults_list **defs)\n{\n    struct cmndspec *cs;\n    struct privilege *priv;\n    struct userspec *us;\n    struct member *matching_user;\n    debug_decl(sudoers_lookup_check, SUDOERS_DEBUG_PARSER);\n\n    init_cmnd_info(ctx, info);\n\n    TAILQ_FOREACH_REVERSE(us, &nss->parse_tree->userspecs, userspec_list, entries) {\n\tint user_match = userlist_matches(nss->parse_tree, ctx->user.pw, &us->users);\n\tif (user_match != ALLOW) {\n\t    if (callback != NULL && user_match == DENY) {\n\t\tcallback(nss->parse_tree, us, user_match, NULL, UNSPEC, NULL,\n\t\t    UNSPEC, UNSPEC, UNSPEC, cb_data);\n\t    }\n\t    continue;\n\t}\n\tCLR(*validated, FLAG_NO_USER);\n\tTAILQ_FOREACH_REVERSE(priv, &us->privileges, privilege_list, entries) {\n\t    int host_match = hostlist_matches(nss->parse_tree, ctx->user.pw,\n\t\t&priv->hostlist);\n\t    if (host_match == ALLOW) {\n\t\tCLR(*validated, FLAG_NO_HOST);\n\t    } else {\n\t\tif (callback != NULL) {\n\t\t    callback(nss->parse_tree, us, user_match, priv, host_match,\n\t\t\tNULL, UNSPEC, UNSPEC, UNSPEC, cb_data);\n\t\t}\n\t\tcontinue;\n\t    }\n\t    TAILQ_FOREACH_REVERSE(cs, &priv->cmndlist, cmndspec_list, entries) {\n\t\tint cmnd_match = UNSPEC;\n\t\tint date_match = UNSPEC;\n\t\tint runas_match = UNSPEC;\n\n\t\tif (cs->notbefore != UNSPEC) {\n\t\t    date_match = now < cs->notbefore ? DENY : ALLOW;\n\t\t}\n\t\tif (cs->notafter != UNSPEC) {\n\t\t    date_match = now > cs->notafter ? DENY : ALLOW;\n\t\t}\n\t\tif (date_match != DENY) {\n\t\t    matching_user = NULL;\n\t\t    runas_match = runaslist_matches(nss->parse_tree,\n\t\t\tcs->runasuserlist, cs->runasgrouplist, &matching_user,\n\t\t\tNULL);\n\t\t    if (runas_match == ALLOW) {\n\t\t\tcmnd_match = cmnd_matches(nss->parse_tree, cs->cmnd,\n\t\t\t    cs->runchroot, info);\n\t\t    }\n\t\t}\n\t\tif (callback != NULL) {\n\t\t    callback(nss->parse_tree, us, user_match, priv, host_match,\n\t\t\tcs, date_match, runas_match, cmnd_match, cb_data);\n\t\t}\n\n\t\tif (SPECIFIED(cmnd_match)) {\n\t\t    /*\n\t\t     * If user is running command as themselves,\n\t\t     * set ctx->runas.pw = ctx->user.pw.\n\t\t     * XXX - hack, want more general solution\n\t\t     */\n\t\t    if (matching_user && matching_user->type == MYSELF) {\n\t\t\tsudo_pw_delref(ctx->runas.pw);\n\t\t\tsudo_pw_addref(ctx->user.pw);\n\t\t\tctx->runas.pw = ctx->user.pw;\n\t\t    }\n\t\t    *matching_cs = cs;\n\t\t    *defs = &priv->defaults;\n\t\t    sudo_debug_printf(SUDO_DEBUG_DEBUG|SUDO_DEBUG_LINENO,\n\t\t\t\"userspec matched @ %s:%d:%d: %s\",\n\t\t\tus->file ? us->file : \"???\", us->line, us->column,\n\t\t\tcmnd_match ? \"allowed\" : \"denied\");\n\t\t    debug_return_int(cmnd_match);\n\t\t}\n\t\tfree(info->cmnd_path);\n\t\tinit_cmnd_info(ctx, info);\n\t    }\n\t}\n    }\n    debug_return_int(UNSPEC);\n}\n\n/*\n * Apply cmndspec-specific settings including SELinux role/type,\n * Solaris privs, and command tags.\n */\nstatic bool\napply_cmndspec(struct sudoers_context *ctx, struct cmndspec *cs)\n{\n    debug_decl(apply_cmndspec, SUDOERS_DEBUG_PARSER);\n\n    if (cs != NULL) {\n#ifdef HAVE_SELINUX\n\t/* Set role and type if not specified on command line. */\n\tif (ctx->runas.role == NULL) {\n\t    if (cs->role != NULL) {\n\t\tctx->runas.role = strdup(cs->role);\n\t\tif (ctx->runas.role == NULL) {\n\t\t    sudo_warnx(U_(\"%s: %s\"), __func__,\n\t\t\tU_(\"unable to allocate memory\"));\n\t\t    debug_return_bool(false);\n\t\t}\n\t    } else {\n\t\tctx->runas.role = def_role;\n\t\tdef_role = NULL;\n\t    }\n\t    if (ctx->runas.role != NULL) {\n\t\tsudo_debug_printf(SUDO_DEBUG_INFO|SUDO_DEBUG_LINENO,\n\t\t    \"ctx->runas.role -> %s\", ctx->runas.role);\n\t    }\n\t}\n\tif (ctx->runas.type == NULL) {\n\t    if (cs->type != NULL) {\n\t\tctx->runas.type = strdup(cs->type);\n\t\tif (ctx->runas.type == NULL) {\n\t\t    sudo_warnx(U_(\"%s: %s\"), __func__,\n\t\t\tU_(\"unable to allocate memory\"));\n\t\t    debug_return_bool(false);\n\t\t}\n\t    } else {\n\t\tctx->runas.type = def_type;\n\t\tdef_type = NULL;\n\t    }\n\t    if (ctx->runas.type != NULL) {\n\t\tsudo_debug_printf(SUDO_DEBUG_INFO|SUDO_DEBUG_LINENO,\n\t\t    \"ctx->runas.type -> %s\", ctx->runas.type);\n\t    }\n\t}\n#endif /* HAVE_SELINUX */\n#ifdef HAVE_APPARMOR\n\t/* Set AppArmor profile, if specified */\n\tif (cs->apparmor_profile != NULL) {\n\t    ctx->runas.apparmor_profile = strdup(cs->apparmor_profile);\n\t    if (ctx->runas.apparmor_profile == NULL) {\n\t\tsudo_warnx(U_(\"%s: %s\"), __func__,\n\t\t    U_(\"unable to allocate memory\"));\n\t\tdebug_return_bool(false);\n\t    }\n\t} else {\n\t    ctx->runas.apparmor_profile = def_apparmor_profile;\n\t    def_apparmor_profile = NULL;\n\t}\n\tif (ctx->runas.apparmor_profile != NULL) {\n\t    sudo_debug_printf(SUDO_DEBUG_INFO|SUDO_DEBUG_LINENO,\n\t\t\"ctx->runas.apparmor_profile -> %s\", ctx->runas.apparmor_profile);\n\t}\n#endif\n#ifdef HAVE_PRIV_SET\n\t/* Set Solaris privilege sets */\n\tif (ctx->runas.privs == NULL) {\n\t    if (cs->privs != NULL) {\n\t\tctx->runas.privs = strdup(cs->privs);\n\t\tif (ctx->runas.privs == NULL) {\n\t\t    sudo_warnx(U_(\"%s: %s\"), __func__,\n\t\t\tU_(\"unable to allocate memory\"));\n\t\t    debug_return_bool(false);\n\t\t}\n\t    } else {\n\t\tctx->runas.privs = def_privs;\n\t\tdef_privs = NULL;\n\t    }\n\t    if (ctx->runas.privs != NULL) {\n\t\tsudo_debug_printf(SUDO_DEBUG_INFO|SUDO_DEBUG_LINENO,\n\t\t    \"ctx->runas.privs -> %s\", ctx->runas.privs);\n\t    }\n\t}\n\tif (ctx->runas.limitprivs == NULL) {\n\t    if (cs->limitprivs != NULL) {\n\t\tctx->runas.limitprivs = strdup(cs->limitprivs);\n\t\tif (ctx->runas.limitprivs == NULL) {\n\t\t    sudo_warnx(U_(\"%s: %s\"), __func__,\n\t\t\tU_(\"unable to allocate memory\"));\n\t\t    debug_return_bool(false);\n\t\t}\n\t    } else {\n\t\tctx->runas.limitprivs = def_limitprivs;\n\t\tdef_limitprivs = NULL;\n\t    }\n\t    if (ctx->runas.limitprivs != NULL) {\n\t\tsudo_debug_printf(SUDO_DEBUG_INFO|SUDO_DEBUG_LINENO,\n\t\t    \"ctx->runas.limitprivs -> %s\", ctx->runas.limitprivs);\n\t    }\n\t}\n#endif /* HAVE_PRIV_SET */\n\tif (cs->timeout > 0) {\n\t    def_command_timeout = cs->timeout;\n\t    sudo_debug_printf(SUDO_DEBUG_INFO|SUDO_DEBUG_LINENO,\n\t\t\"def_command_timeout -> %d\", def_command_timeout);\n\t}\n\tif (cs->runcwd != NULL) {\n\t    free(def_runcwd);\n\t    def_runcwd = strdup(cs->runcwd);\n\t    if (def_runcwd == NULL) {\n\t\tsudo_warnx(U_(\"%s: %s\"), __func__,\n\t\t    U_(\"unable to allocate memory\"));\n\t\tdebug_return_bool(false);\n\t    }\n\t    sudo_debug_printf(SUDO_DEBUG_INFO|SUDO_DEBUG_LINENO,\n\t\t\"def_runcwd -> %s\", def_runcwd);\n\t}\n\tif (cs->runchroot != NULL) {\n\t    free(def_runchroot);\n\t    def_runchroot = strdup(cs->runchroot);\n\t    if (def_runchroot == NULL) {\n\t\tsudo_warnx(U_(\"%s: %s\"), __func__,\n\t\t    U_(\"unable to allocate memory\"));\n\t\tdebug_return_bool(false);\n\t    }\n\t    sudo_debug_printf(SUDO_DEBUG_INFO|SUDO_DEBUG_LINENO,\n\t\t\"def_runchroot -> %s\", def_runchroot);\n\t}\n\tif (cs->tags.nopasswd != UNSPEC) {\n\t    def_authenticate = !cs->tags.nopasswd;\n\t    sudo_debug_printf(SUDO_DEBUG_INFO|SUDO_DEBUG_LINENO,\n\t\t\"def_authenticate -> %s\", def_authenticate ? \"true\" : \"false\");\n\t}\n\tif (cs->tags.noexec != UNSPEC) {\n\t    def_noexec = cs->tags.noexec;\n\t    sudo_debug_printf(SUDO_DEBUG_INFO|SUDO_DEBUG_LINENO,\n\t\t\"def_noexec -> %s\", def_noexec ? \"true\" : \"false\");\n\t}\n\tif (cs->tags.intercept != UNSPEC) {\n\t    def_intercept = cs->tags.intercept;\n\t    sudo_debug_printf(SUDO_DEBUG_INFO|SUDO_DEBUG_LINENO,\n\t\t\"def_intercept -> %s\", def_intercept ? \"true\" : \"false\");\n\t}\n\tif (cs->tags.setenv != UNSPEC) {\n\t    def_setenv = cs->tags.setenv;\n\t    sudo_debug_printf(SUDO_DEBUG_INFO|SUDO_DEBUG_LINENO,\n\t\t\"def_setenv -> %s\", def_setenv ? \"true\" : \"false\");\n\t}\n\tif (cs->tags.log_input != UNSPEC) {\n\t    def_log_input = cs->tags.log_input;\n\t    cb_log_input(ctx, NULL, 0, 0, NULL, cs->tags.log_input);\n\t    sudo_debug_printf(SUDO_DEBUG_INFO|SUDO_DEBUG_LINENO,\n\t\t\"def_log_input -> %s\", def_log_input ? \"true\" : \"false\");\n\t}\n\tif (cs->tags.log_output != UNSPEC) {\n\t    def_log_output = cs->tags.log_output;\n\t    cb_log_output(ctx, NULL, 0, 0, NULL, cs->tags.log_output);\n\t    sudo_debug_printf(SUDO_DEBUG_INFO|SUDO_DEBUG_LINENO,\n\t\t\"def_log_output -> %s\", def_log_output ? \"true\" : \"false\");\n\t}\n\tif (cs->tags.send_mail != UNSPEC) {\n\t    if (cs->tags.send_mail) {\n\t\tdef_mail_all_cmnds = true;\n\t\tsudo_debug_printf(SUDO_DEBUG_INFO|SUDO_DEBUG_LINENO,\n\t\t    \"def_mail_all_cmnds -> true\");\n\t    } else {\n\t\tdef_mail_all_cmnds = false;\n\t\tdef_mail_always = false;\n\t\tdef_mail_no_perms = false;\n\t\tsudo_debug_printf(SUDO_DEBUG_INFO|SUDO_DEBUG_LINENO,\n\t\t    \"def_mail_all_cmnds -> false, def_mail_always -> false, \"\n\t\t    \"def_mail_no_perms -> false\");\n\t    }\n\t}\n\tif (cs->tags.follow != UNSPEC) {\n\t    def_sudoedit_follow = cs->tags.follow;\n\t    sudo_debug_printf(SUDO_DEBUG_INFO|SUDO_DEBUG_LINENO,\n\t\t\"def_sudoedit_follow -> %s\", def_sudoedit_follow ? \"true\" : \"false\");\n\t}\n    }\n\n    debug_return_bool(true);\n}\n\n/*\n * Look up the user in the sudoers parse tree and check to see if they are\n * allowed to run the specified command on this host as the target user.\n */\nunsigned int\nsudoers_lookup(struct sudo_nss_list *snl, struct sudoers_context *ctx,\n    time_t now, sudoers_lookup_callback_fn_t callback, void *cb_data,\n    int *cmnd_status, int pwflag)\n{\n    struct defaults_list *defs = NULL;\n    struct sudoers_parse_tree *parse_tree = NULL;\n    struct cmndspec *cs = NULL;\n    struct sudo_nss *nss;\n    struct cmnd_info info;\n    unsigned int validated = FLAG_NO_USER | FLAG_NO_HOST;\n    int m, match = UNSPEC;\n    debug_decl(sudoers_lookup, SUDOERS_DEBUG_PARSER);\n\n    /*\n     * Special case checking the \"validate\", \"list\" and \"kill\" pseudo-commands.\n     */\n    if (pwflag) {\n\tdebug_return_uint(sudoers_lookup_pseudo(snl, ctx, now, callback,\n\t    cb_data, pwflag));\n    }\n\n    /* Need to be runas user while stat'ing things. */\n    if (!set_perms(ctx, PERM_RUNAS))\n\tdebug_return_uint(validated);\n\n    /* Query each sudoers source and check the user. */\n    TAILQ_FOREACH(nss, snl, entries) {\n\tif (nss->query(ctx, nss, ctx->user.pw) == -1) {\n\t    /* The query function should have printed an error message. */\n\t    SET(validated, VALIDATE_ERROR);\n\t    break;\n\t}\n\n\tm = sudoers_lookup_check(nss, ctx, &validated, &info, now, callback,\n\t    cb_data, &cs, &defs);\n\tif (SPECIFIED(m)) {\n\t    match = m;\n\t    parse_tree = nss->parse_tree;\n\t}\n\n\tif (!sudo_nss_can_continue(nss, m))\n\t    break;\n    }\n    if (SPECIFIED(match)) {\n\tif (info.cmnd_path != NULL) {\n\t    /* Update cmnd, cmnd_stat, cmnd_status from matching entry. */\n\t    free(ctx->user.cmnd);\n\t    ctx->user.cmnd = info.cmnd_path;\n\t    if (ctx->user.cmnd_stat != NULL)\n\t\t*ctx->user.cmnd_stat = info.cmnd_stat;\n\t    *cmnd_status = info.status;\n\t}\n\tif (defs != NULL)\n\t    (void)update_defaults(ctx, parse_tree, defs, SETDEF_GENERIC, false);\n\tif (!apply_cmndspec(ctx, cs))\n\t    SET(validated, VALIDATE_ERROR);\n\telse if (match == ALLOW)\n\t    SET(validated, VALIDATE_SUCCESS);\n\telse\n\t    SET(validated, VALIDATE_FAILURE);\n    }\n    if (!restore_perms())\n\tSET(validated, VALIDATE_ERROR);\n    debug_return_uint(validated);\n}\n", "/*\n * SPDX-License-Identifier: ISC\n *\n * Copyright (c) 1996, 1998-2005, 2007-2023\n *\tTodd C. Miller <Todd.Miller@sudo.ws>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n *\n * Sponsored in part by the Defense Advanced Research Projects\n * Agency (DARPA) and Air Force Research Laboratory, Air Force\n * Materiel Command, USAF, under agreement number F39502-99-1-0512.\n */\n\n/*\n * This is an open source non-commercial project. Dear PVS-Studio, please check it.\n * PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n */\n\n#include <config.h>\n\n#include <sys/stat.h>\n#ifdef HAVE_SYS_SYSTEMINFO_H\n# include <sys/systeminfo.h>\n#endif\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef HAVE_STRINGS_H\n# include <strings.h>\n#endif /* HAVE_STRINGS_H */\n#include <unistd.h>\n#ifdef HAVE_NETGROUP_H\n# include <netgroup.h>\n#else\n# include <netdb.h>\n#endif /* HAVE_NETGROUP_H */\n#include <dirent.h>\n#include <fcntl.h>\n#include <pwd.h>\n#include <grp.h>\n#include <errno.h>\n#ifdef HAVE_FNMATCH\n# include <fnmatch.h>\n#else\n# include \"compat/fnmatch.h\"\n#endif /* HAVE_FNMATCH */\n\n#include \"sudoers.h\"\n#include <gram.h>\n\n/*\n * Check whether user described by pw matches member.\n * Returns ALLOW, DENY or UNSPEC.\n */\nint\nuser_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct passwd *pw, const struct member *m)\n{\n    const struct sudoers_context *ctx = parse_tree->ctx;\n    const char *lhost = parse_tree->lhost ? parse_tree->lhost : ctx->runas.host;\n    const char *shost = parse_tree->shost ? parse_tree->shost : ctx->runas.shost;\n    int matched = UNSPEC;\n    struct alias *a;\n    debug_decl(user_matches, SUDOERS_DEBUG_MATCH);\n\n    switch (m->type) {\n\tcase ALL:\n\t    matched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase NETGROUP:\n\t    if (netgr_matches(parse_tree->nss, m->name,\n\t\tdef_netgroup_tuple ? lhost : NULL,\n\t\tdef_netgroup_tuple ? shost : NULL, pw->pw_name))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase USERGROUP:\n\t    if (usergr_matches(m->name, pw->pw_name, pw))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase ALIAS:\n\t    if ((a = alias_get(parse_tree, m->name, USERALIAS)) != NULL) {\n\t\t/* XXX */\n\t\tconst int rc = userlist_matches(parse_tree, pw, &a->members);\n\t\tif (SPECIFIED(rc)) {\n\t\t    if (m->negated) {\n\t\t\tmatched = rc == ALLOW ? DENY : ALLOW;\n\t\t    } else {\n\t\t\tmatched = rc;\n\t\t    }\n\t\t}\n\t\talias_put(a);\n\t\tbreak;\n\t    }\n\t    FALLTHROUGH;\n\tcase WORD:\n\t    if (userpw_matches(m->name, pw->pw_name, pw))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n    }\n    debug_return_int(matched);\n}\n\n/*\n * Check for user described by pw in a list of members.\n * Returns ALLOW, DENY or UNSPEC.\n */\nint\nuserlist_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct passwd *pw, const struct member_list *list)\n{\n    struct member *m;\n    int matched = UNSPEC;\n    debug_decl(userlist_matches, SUDOERS_DEBUG_MATCH);\n\n    TAILQ_FOREACH_REVERSE(m, list, member_list, entries) {\n\tmatched = user_matches(parse_tree, pw, m);\n\tif (SPECIFIED(matched))\n\t    break;\n    }\n    debug_return_int(matched);\n}\n\nstruct gid_list *\nrunas_getgroups(const struct sudoers_context *ctx)\n{\n    const struct passwd *pw;\n    debug_decl(runas_getgroups, SUDOERS_DEBUG_MATCH);\n\n    if (def_preserve_groups) {\n\tsudo_gidlist_addref(ctx->user.gid_list);\n\tdebug_return_ptr(ctx->user.gid_list);\n    }\n\n    /* Only use results from a group db query, not the front end. */\n    pw = ctx->runas.pw ? ctx->runas.pw : ctx->user.pw;\n    debug_return_ptr(sudo_get_gidlist(pw, ENTRY_TYPE_QUERIED));\n}\n\n/*\n * Check whether the requested runas user matches user_list, the\n * user portion of a sudoers runaslist.  If user_list is NULL, a\n * list containing runas_default is used.\n * Returns ALLOW, DENY or UNSPEC.\n */\nstatic int\nrunas_userlist_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct member_list *user_list, struct member **matching_user)\n{\n    const struct sudoers_context *ctx = parse_tree->ctx;\n    const char *lhost = parse_tree->lhost ? parse_tree->lhost : ctx->runas.host;\n    const char *shost = parse_tree->shost ? parse_tree->shost : ctx->runas.shost;\n    int user_matched = UNSPEC;\n    struct member *m;\n    struct alias *a;\n    debug_decl(runas_userlist_matches, SUDOERS_DEBUG_MATCH);\n\n    TAILQ_FOREACH_REVERSE(m, user_list, member_list, entries) {\n\tswitch (m->type) {\n\t    case ALL:\n\t\tuser_matched = m->negated ? DENY : ALLOW;\n\t\tbreak;\n\t    case NETGROUP:\n\t\tif (netgr_matches(parse_tree->nss, m->name,\n\t\t    def_netgroup_tuple ? lhost : NULL,\n\t\t    def_netgroup_tuple ? shost : NULL,\n\t\t    ctx->runas.pw->pw_name))\n\t\t    user_matched = m->negated ? DENY : ALLOW;\n\t\tbreak;\n\t    case USERGROUP:\n\t\tif (usergr_matches(m->name, ctx->runas.pw->pw_name, ctx->runas.pw))\n\t\t    user_matched = m->negated ? DENY : ALLOW;\n\t\tbreak;\n\t    case ALIAS:\n\t\ta = alias_get(parse_tree, m->name, RUNASALIAS);\n\t\tif (a != NULL) {\n\t\t    const int rc = runas_userlist_matches(parse_tree,\n\t\t\t&a->members, matching_user);\n\t\t    if (SPECIFIED(rc)) {\n\t\t\tif (m->negated) {\n\t\t\t    user_matched = rc == ALLOW ? DENY : ALLOW;\n\t\t\t} else {\n\t\t\t    user_matched = rc;\n\t\t\t}\n\t\t    }\n\t\t    alias_put(a);\n\t\t    break;\n\t\t}\n\t\tFALLTHROUGH;\n\t    case WORD:\n\t\tif (userpw_matches(m->name, ctx->runas.pw->pw_name, ctx->runas.pw))\n\t\t    user_matched = m->negated ? DENY : ALLOW;\n\t\tbreak;\n\t    case MYSELF:\n\t\t/*\n\t\t * Only match a rule with an empty runas user if a group\n\t\t * was specified on the command line without a user _or_\n\t\t * the user specified their own name on the command line.\n\t\t */\n\t\tif ((!ISSET(ctx->settings.flags, RUNAS_USER_SPECIFIED) &&\n\t\t\tISSET(ctx->settings.flags, RUNAS_GROUP_SPECIFIED)) ||\n\t\t\tstrcmp(ctx->user.name, ctx->runas.pw->pw_name) == 0)\n\t\t    user_matched = m->negated ? DENY : ALLOW;\n\t\tbreak;\n\t}\n\tif (SPECIFIED(user_matched)) {\n\t    if (matching_user != NULL && m->type != ALIAS)\n\t\t*matching_user = m;\n\t    break;\n\t}\n    }\n    debug_return_int(user_matched);\n}\n\n/*\n * Check whether the requested runas group matches group_list, the\n * group portion of a sudoers runaslist, or the runas user's groups.\n * Returns ALLOW, DENY or UNSPEC.\n */\nstatic int\nrunas_grouplist_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct member_list *group_list, struct member **matching_group)\n{\n    const struct sudoers_context *ctx = parse_tree->ctx;\n    int group_matched = UNSPEC;\n    struct member *m;\n    struct alias *a;\n    debug_decl(runas_grouplist_matches, SUDOERS_DEBUG_MATCH);\n\n    if (group_list != NULL) {\n\tTAILQ_FOREACH_REVERSE(m, group_list, member_list, entries) {\n\t    switch (m->type) {\n\t\tcase ALL:\n\t\t    group_matched = m->negated ? DENY : ALLOW;\n\t\t    break;\n\t\tcase ALIAS:\n\t\t    a = alias_get(parse_tree, m->name, RUNASALIAS);\n\t\t    if (a != NULL) {\n\t\t\tconst int rc = runas_grouplist_matches(parse_tree,\n\t\t\t    &a->members, matching_group);\n\t\t\tif (SPECIFIED(rc)) {\n\t\t\t    if (m->negated) {\n\t\t\t\tgroup_matched = rc == ALLOW ? DENY : ALLOW;\n\t\t\t    } else {\n\t\t\t\tgroup_matched = rc;\n\t\t\t    }\n\t\t\t}\n\t\t\talias_put(a);\n\t\t\tbreak;\n\t\t    }\n\t\t    FALLTHROUGH;\n\t\tcase WORD:\n\t\t    if (group_matches(m->name, ctx->runas.gr))\n\t\t\tgroup_matched = m->negated ? DENY : ALLOW;\n\t\t    break;\n\t    }\n\t    if (SPECIFIED(group_matched)) {\n\t\tif (matching_group != NULL && m->type != ALIAS)\n\t\t    *matching_group = m;\n\t\tbreak;\n\t    }\n\t}\n    }\n    if (!SPECIFIED(group_matched)) {\n\tstruct gid_list *runas_groups;\n\t/*\n\t * The runas group was not explicitly allowed by sudoers.\n\t * Check whether it is one of the target user's groups.\n\t */\n\tif (ctx->runas.pw->pw_gid == ctx->runas.gr->gr_gid) {\n\t    group_matched = ALLOW;\t/* runas group matches passwd db */\n\t} else if ((runas_groups = runas_getgroups(ctx)) != NULL) {\n\t    int i;\n\n\t    for (i = 0; i < runas_groups->ngids; i++) {\n\t\tif (runas_groups->gids[i] == ctx->runas.gr->gr_gid) {\n\t\t    group_matched = ALLOW;\t/* matched aux group vector */\n\t\t    break;\n\t\t}\n\t    }\n\t    sudo_gidlist_delref(runas_groups);\n\t}\n    }\n\n    debug_return_int(group_matched);\n}\n\n/*\n * Check whether the sudoers runaslist, composed of user_list and\n * group_list, matches the runas user/group requested by the user.\n * Either (or both) user_list and group_list may be NULL.\n * If user_list is NULL, a list containing runas_default is used.\n * Returns ALLOW, DENY or UNSPEC.\n */\nint\nrunaslist_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct member_list *user_list, const struct member_list *group_list,\n    struct member **matching_user, struct member **matching_group)\n{\n    const struct sudoers_context *ctx = parse_tree->ctx;\n    struct member_list _user_list = TAILQ_HEAD_INITIALIZER(_user_list);\n    int user_matched, group_matched = UNSPEC;\n    struct member m_user;\n    debug_decl(runaslist_matches, SUDOERS_DEBUG_MATCH);\n\n    /* If no runas user listed in sudoers, use the default value.  */\n    if (user_list == NULL) {\n\tm_user.name = def_runas_default;\n\tm_user.type = WORD;\n\tm_user.negated = false;\n\tTAILQ_INSERT_HEAD(&_user_list, &m_user, entries);\n\tuser_list = &_user_list;\n\tmatching_user = NULL;\n    }\n\n    user_matched = runas_userlist_matches(parse_tree, user_list, matching_user);\n    if (ISSET(ctx->settings.flags, RUNAS_GROUP_SPECIFIED)) {\n\tgroup_matched = runas_grouplist_matches(parse_tree, group_list,\n\t    matching_group);\n    }\n\n    if (user_matched == DENY || group_matched == DENY)\n\tdebug_return_int(DENY);\n    if (user_matched == group_matched || ctx->runas.gr == NULL)\n\tdebug_return_int(user_matched);\n    debug_return_int(UNSPEC);\n}\n\n/*\n * Check for lhost and shost in a list of members.\n * Returns ALLOW, DENY or UNSPEC.\n */\nstatic int\nhostlist_matches_int(const struct sudoers_parse_tree *parse_tree,\n    const struct passwd *pw, const char *lhost, const char *shost,\n    const struct member_list *list)\n{\n    struct member *m;\n    int matched = UNSPEC;\n    debug_decl(hostlist_matches, SUDOERS_DEBUG_MATCH);\n\n    TAILQ_FOREACH_REVERSE(m, list, member_list, entries) {\n\tmatched = host_matches(parse_tree, pw, lhost, shost, m);\n\tif (SPECIFIED(matched))\n\t    break;\n    }\n    debug_return_int(matched);\n}\n\n/*\n * Check for ctx->runas.host and ctx->runas.shost in a list of members.\n * Returns ALLOW, DENY or UNSPEC.\n */\nint\nhostlist_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct passwd *pw, const struct member_list *list)\n{\n    const struct sudoers_context *ctx = parse_tree->ctx;\n    const char *lhost = parse_tree->lhost ? parse_tree->lhost : ctx->runas.host;\n    const char *shost = parse_tree->shost ? parse_tree->shost : ctx->runas.shost;\n\n    return hostlist_matches_int(parse_tree, pw, lhost, shost, list);\n}\n\n/*\n * Check whether host or shost matches member.\n * Returns ALLOW, DENY or UNSPEC.\n */\nint\nhost_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct passwd *pw, const char *lhost, const char *shost,\n    const struct member *m)\n{\n    struct alias *a;\n    int matched = UNSPEC;\n    debug_decl(host_matches, SUDOERS_DEBUG_MATCH);\n\n    switch (m->type) {\n\tcase ALL:\n\t    matched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase NETGROUP:\n\t    if (netgr_matches(parse_tree->nss, m->name, lhost, shost,\n\t\tdef_netgroup_tuple ? pw->pw_name : NULL))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase NTWKADDR:\n\t    if (addr_matches(m->name))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase ALIAS:\n\t    a = alias_get(parse_tree, m->name, HOSTALIAS);\n\t    if (a != NULL) {\n\t\t/* XXX */\n\t\tconst int rc = hostlist_matches_int(parse_tree, pw, lhost,\n\t\t    shost, &a->members);\n\t\tif (SPECIFIED(rc)) {\n\t\t    if (m->negated) {\n\t\t\tmatched = rc == ALLOW ? DENY : ALLOW;\n\t\t    } else {\n\t\t\tmatched = rc;\n\t\t    }\n\t\t}\n\t\talias_put(a);\n\t\tbreak;\n\t    }\n\t    FALLTHROUGH;\n\tcase WORD:\n\t    if (hostname_matches(shost, lhost, m->name))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n    }\n    sudo_debug_printf(SUDO_DEBUG_DEBUG,\n\t\"host %s (%s) matches sudoers host %s%s: %s\", lhost, shost,\n\tm->negated ? \"!\" : \"\", m->name ? m->name : \"ALL\",\n\tmatched == true ? \"true\" : \"false\");\n    debug_return_int(matched);\n}\n\n/*\n * Check for cmnd and args in a list of members.\n * Returns ALLOW, DENY or UNSPEC.\n */\nint\ncmndlist_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct member_list *list, const char *runchroot,\n    struct cmnd_info *info)\n{\n    struct member *m;\n    int matched = UNSPEC;\n    debug_decl(cmndlist_matches, SUDOERS_DEBUG_MATCH);\n\n    TAILQ_FOREACH_REVERSE(m, list, member_list, entries) {\n\tmatched = cmnd_matches(parse_tree, m, runchroot, info);\n\tif (SPECIFIED(matched))\n\t    break;\n    }\n    debug_return_int(matched);\n}\n\n/*\n * Check cmnd and args.\n * Returns ALLOW, DENY or UNSPEC.\n */\nint\ncmnd_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct member *m, const char *runchroot, struct cmnd_info *info)\n{\n    struct alias *a;\n    struct sudo_command *c;\n    int rc, matched = UNSPEC;\n    debug_decl(cmnd_matches, SUDOERS_DEBUG_MATCH);\n\n    switch (m->type) {\n\tcase ALL:\n\tcase COMMAND:\n\t    c = (struct sudo_command *)m->name;\n\t    if (command_matches(parse_tree->ctx, c->cmnd, c->args, runchroot,\n\t\t    info, &c->digests))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase ALIAS:\n\t    a = alias_get(parse_tree, m->name, CMNDALIAS);\n\t    if (a != NULL) {\n\t\trc = cmndlist_matches(parse_tree, &a->members, runchroot, info);\n\t\tif (SPECIFIED(rc)) {\n\t\t    if (m->negated) {\n\t\t\tmatched = rc == ALLOW ? DENY : ALLOW;\n\t\t    } else {\n\t\t\tmatched = rc;\n\t\t    }\n\t\t}\n\t\talias_put(a);\n\t    }\n\t    break;\n    }\n    debug_return_int(matched);\n}\n\n/*\n * Like cmnd_matches() but only matches against the ALL command.\n * Returns ALLOW, DENY or UNSPEC.\n */\nint\ncmnd_matches_all(const struct sudoers_parse_tree *parse_tree,\n    const struct member *m, const char *runchroot, struct cmnd_info *info)\n{\n    const bool negated = m->negated;\n    struct sudo_command *c;\n    int matched = UNSPEC;\n    struct alias *a;\n    debug_decl(cmnd_matches_all, SUDOERS_DEBUG_MATCH);\n\n    switch (m->type) {\n\tcase ALL:\n\t    c = (struct sudo_command *)m->name;\n\t    if (command_matches(parse_tree->ctx, c->cmnd, c->args, runchroot,\n\t\t    info, &c->digests))\n\t\tmatched = negated ? DENY : ALLOW;\n\t    break;\n\tcase ALIAS:\n\t    a = alias_get(parse_tree, m->name, CMNDALIAS);\n\t    if (a != NULL) {\n\t\tTAILQ_FOREACH_REVERSE(m, &a->members, member_list, entries) {\n\t\t    matched = cmnd_matches_all(parse_tree, m, runchroot, info);\n\t\t    if (SPECIFIED(matched)) {\n\t\t\tif (negated)\n\t\t\t    matched = matched == ALLOW ? DENY : ALLOW;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\talias_put(a);\n\t    }\n\t    break;\n    }\n    debug_return_int(matched);\n}\n\n/*\n * Returns true if the hostname matches the pattern, else false\n */\nbool\nhostname_matches(const char *shost, const char *lhost, const char *pattern)\n{\n    const char *host;\n    bool rc;\n    debug_decl(hostname_matches, SUDOERS_DEBUG_MATCH);\n\n    host = strchr(pattern, '.') != NULL ? lhost : shost;\n    if (has_meta(pattern)) {\n\trc = !fnmatch(pattern, host, FNM_CASEFOLD);\n    } else {\n\trc = !strcasecmp(host, pattern);\n    }\n    debug_return_bool(rc);\n}\n\n/*\n * Returns true if the user/uid from sudoers matches the specified user/uid,\n * else returns false.\n */\nbool\nuserpw_matches(const char *sudoers_user, const char *user, const struct passwd *pw)\n{\n    const char *errstr;\n    uid_t uid;\n    bool rc;\n    debug_decl(userpw_matches, SUDOERS_DEBUG_MATCH);\n\n    if (pw != NULL && *sudoers_user == '#') {\n\tuid = (uid_t) sudo_strtoid(sudoers_user + 1, &errstr);\n\tif (errstr == NULL && uid == pw->pw_uid) {\n\t    rc = true;\n\t    goto done;\n\t}\n    }\n    if (def_case_insensitive_user)\n\trc = strcasecmp(sudoers_user, user) == 0;\n    else\n\trc = strcmp(sudoers_user, user) == 0;\ndone:\n    sudo_debug_printf(SUDO_DEBUG_DEBUG|SUDO_DEBUG_LINENO,\n\t\"user %s matches sudoers user %s: %s\",\n\tuser, sudoers_user, rc ? \"true\" : \"false\");\n    debug_return_bool(rc);\n}\n\n/*\n * Returns true if the group/gid from sudoers matches the specified group/gid,\n * else returns false.\n */\nbool\ngroup_matches(const char *sudoers_group, const struct group *gr)\n{\n    const char *errstr;\n    gid_t gid;\n    bool rc;\n    debug_decl(group_matches, SUDOERS_DEBUG_MATCH);\n\n    if (*sudoers_group == '#') {\n\tgid = (gid_t) sudo_strtoid(sudoers_group + 1, &errstr);\n\tif (errstr == NULL && gid == gr->gr_gid) {\n\t    rc = true;\n\t    goto done;\n\t}\n    }\n    if (def_case_insensitive_group)\n\trc = strcasecmp(sudoers_group, gr->gr_name) == 0;\n    else\n\trc = strcmp(sudoers_group, gr->gr_name) == 0;\ndone:\n    sudo_debug_printf(SUDO_DEBUG_DEBUG|SUDO_DEBUG_LINENO,\n\t\"group %s matches sudoers group %s: %s\",\n\tgr->gr_name, sudoers_group, rc ? \"true\" : \"false\");\n    debug_return_bool(rc);\n}\n\n/*\n * Returns true if the given user belongs to the named group,\n * else returns false.\n */\nbool\nusergr_matches(const char *group, const char *user, const struct passwd *pw)\n{\n    bool matched = false;\n    struct passwd *pw0 = NULL;\n    debug_decl(usergr_matches, SUDOERS_DEBUG_MATCH);\n\n    /* Make sure we have a valid usergroup, sudo style */\n    if (*group++ != '%') {\n\tsudo_debug_printf(SUDO_DEBUG_DIAG, \"user group %s has no leading '%%'\",\n\t    group);\n\tgoto done;\n    }\n\n    /* Query group plugin for %:name groups. */\n    if (*group == ':' && def_group_plugin) {\n\tif (group_plugin_query(user, group + 1, pw) == true)\n\t    matched = true;\n\tgoto done;\n    }\n\n    /* Look up user's primary gid in the passwd file. */\n    if (pw == NULL) {\n\tif ((pw0 = sudo_getpwnam(user)) == NULL) {\n\t    sudo_debug_printf(SUDO_DEBUG_DIAG, \"unable to find %s in passwd db\",\n\t\tuser);\n\t    goto done;\n\t}\n\tpw = pw0;\n    }\n\n    if (user_in_group(pw, group)) {\n\tmatched = true;\n\tgoto done;\n    }\n\n    /* Query the group plugin for Unix groups too? */\n    if (def_group_plugin && def_always_query_group_plugin) {\n\tif (group_plugin_query(user, group, pw) == true) {\n\t    matched = true;\n\t    goto done;\n\t}\n    }\n\ndone:\n    if (pw0 != NULL)\n\tsudo_pw_delref(pw0);\n\n    sudo_debug_printf(SUDO_DEBUG_DEBUG|SUDO_DEBUG_LINENO,\n\t\"user %s matches group %s: %s\", user, group, matched ? \"true\" : \"false\");\n    debug_return_bool(matched);\n}\n\n#if defined(HAVE_GETDOMAINNAME) || defined(SI_SRPC_DOMAIN)\n/*\n * Check the domain for invalid characters.\n * Linux getdomainname(2) returns (none) if no domain is set.\n */\nstatic bool\nvalid_domain(const char *domain)\n{\n    const char *cp;\n    debug_decl(valid_domain, SUDOERS_DEBUG_MATCH);\n\n    for (cp = domain; *cp != '\\0'; cp++) {\n\t/* Check for illegal characters, Linux may use \"(none)\". */\n\tif (*cp == '(' || *cp == ')' || *cp == ',' || *cp == ' ')\n\t    break;\n    }\n    if (cp == domain || *cp != '\\0')\n\tdebug_return_bool(false);\n    debug_return_bool(true);\n}\n\n/*\n * Get NIS-style domain name and copy from static storage or NULL if none.\n */\nconst char *\nsudo_getdomainname(void)\n{\n    static char *domain;\n    static bool initialized;\n    debug_decl(sudo_getdomainname, SUDOERS_DEBUG_MATCH);\n\n    if (!initialized) {\n\tsize_t host_name_max;\n\tint rc;\n\n# ifdef _SC_HOST_NAME_MAX\n\thost_name_max = (size_t)sysconf(_SC_HOST_NAME_MAX);\n\tif (host_name_max == (size_t)-1)\n# endif\n\t    host_name_max = 255;    /* POSIX and historic BSD */\n\n\tdomain = malloc(host_name_max + 1);\n\tif (domain != NULL) {\n\t    domain[0] = '\\0';\n# ifdef SI_SRPC_DOMAIN\n\t    rc = sysinfo(SI_SRPC_DOMAIN, domain, host_name_max + 1);\n# else\n\t    rc = getdomainname(domain, host_name_max + 1);\n# endif\n\t    if (rc == -1 || !valid_domain(domain)) {\n\t\t/* Error or invalid domain name. */\n\t\tfree(domain);\n\t\tdomain = NULL;\n\t    }\n\t} else {\n\t    /* XXX - want to pass error back to caller */\n\t    sudo_debug_printf(SUDO_DEBUG_ERROR|SUDO_DEBUG_LINENO,\n\t\t\"unable to allocate memory\");\n\t}\n\tinitialized = true;\n    }\n    debug_return_str(domain);\n}\n#else\nconst char *\nsudo_getdomainname(void)\n{\n    debug_decl(sudo_getdomainname, SUDOERS_DEBUG_MATCH);\n    debug_return_ptr(NULL);\n}\n#endif /* HAVE_GETDOMAINNAME || SI_SRPC_DOMAIN */\n\n/*\n * Returns true if \"host\" and \"user\" belong to the netgroup \"netgr\",\n * else return false.  Either of \"lhost\", \"shost\" or \"user\" may be NULL\n * in which case that argument is not checked...\n */\nbool\nnetgr_matches(const struct sudo_nss *nss, const char *netgr,\n    const char *lhost, const char *shost, const char *user)\n{\n    const char *domain;\n    bool rc = false;\n    debug_decl(netgr_matches, SUDOERS_DEBUG_MATCH);\n\n    if (!def_use_netgroups) {\n\tsudo_debug_printf(SUDO_DEBUG_INFO, \"netgroups are disabled\");\n\tdebug_return_bool(false);\n    }\n\n    /* make sure we have a valid netgroup, sudo style */\n    if (*netgr++ != '+') {\n\tsudo_debug_printf(SUDO_DEBUG_DIAG, \"netgroup %s has no leading '+'\",\n\t    netgr);\n\tdebug_return_bool(false);\n    }\n\n    /* get the domain name (if any) */\n    domain = sudo_getdomainname();\n\n    /* Use nss-specific innetgr() function if available. */\n    if (nss != NULL && nss->innetgr != NULL) {\n\tswitch (nss->innetgr(nss, netgr, lhost, user, domain)) {\n\tcase 0:\n\t    if (lhost != shost) {\n\t\tif (nss->innetgr(nss, netgr, shost, user, domain) == 1)\n\t\t    rc = true;\n\t    }\n\t    goto done;\n\tcase 1:\n\t    rc = true;\n\t    goto done;\n\tdefault:\n\t    /* Not supported, use system innetgr(3). */\n\t    break;\n\t}\n    }\n\n#ifdef HAVE_INNETGR\n    /* Use system innetgr() function. */\n    if (innetgr(netgr, lhost, user, domain) == 1) {\n\trc = true;\n    } else if (lhost != shost) {\n\tif (innetgr(netgr, shost, user, domain) == 1)\n\t    rc = true;\n    }\n#else\n    sudo_debug_printf(SUDO_DEBUG_WARN|SUDO_DEBUG_LINENO,\n\t\"%s: no system netgroup support\", __func__);\n#endif /* HAVE_INNETGR */\n\ndone:\n    sudo_debug_printf(SUDO_DEBUG_DEBUG|SUDO_DEBUG_LINENO,\n\t\"netgroup %s matches (%s|%s, %s, %s): %s\", netgr, lhost ? lhost : \"\",\n\tshost ? shost : \"\", user ? user : \"\", domain ? domain : \"\",\n\trc ? \"true\" : \"false\");\n\n    debug_return_bool(rc);\n}\n", "/*\n * SPDX-License-Identifier: ISC\n *\n * Copyright (c) 1996, 1998-2000, 2004, 2007-2023\n *\tTodd C. Miller <Todd.Miller@sudo.ws>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#ifndef SUDOERS_PARSE_H\n#define SUDOERS_PARSE_H\n\n#include <sys/stat.h>\n#include \"sudo_queue.h\"\n\n/* Characters that must be quoted in sudoers. */\n#define SUDOERS_QUOTED\t\t\":,=#\\\"\"\n#define SUDOERS_QUOTED_CMD\t\":,= \\t#\"\n#define SUDOERS_QUOTED_ARG\t\":,=#\"\n\n/* Returns true if string 's' contains meta characters. */\n#define has_meta(s)\t(strpbrk(s, \"\\\\?*[]\") != NULL)\n\n/* Match by name, not inode, when fuzzing. */\n#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n# define SUDOERS_NAME_MATCH\n#endif\n\n/* Allowed by policy (rowhammer resistent). */\n#undef ALLOW\n#define ALLOW\t 0x52a2925\t/* 0101001010100010100100100101 */\n\n/* Denied by policy (rowhammer resistent). */\n#undef DENY\n#define DENY\t 0xad5d6da\t/* 1010110101011101011011011010 */\n\n/* Neither allowed, nor denied. */\n#undef UNSPEC\n#define UNSPEC\t-1\n\n/* Tag implied by root access (SETENV only). */\n#undef IMPLIED\n#define IMPLIED\t 2\n\n/*\n * We must explicitly check against ALLOW and DENY instead testing\n * that the value is not UNSPEC to avoid potential ROWHAMMER issues.\n */\n#define SPECIFIED(_v)\t((_v) == ALLOW || (_v) == DENY)\n\n/*\n * Initialize all tags to UNSPEC.\n */\n#define TAGS_INIT(t)\tdo {\t\t\t\t\t\t       \\\n    (t)->follow = UNSPEC;\t\t\t\t\t\t       \\\n    (t)->intercept = UNSPEC;\t\t\t\t\t\t       \\\n    (t)->log_input = UNSPEC;\t\t\t\t\t\t       \\\n    (t)->log_output = UNSPEC;\t\t\t\t\t\t       \\\n    (t)->noexec = UNSPEC;\t\t\t\t\t\t       \\\n    (t)->nopasswd = UNSPEC;\t\t\t\t\t\t       \\\n    (t)->send_mail = UNSPEC;\t\t\t\t\t\t       \\\n    (t)->setenv = UNSPEC;\t\t\t\t\t\t       \\\n} while (0)\n\n/*\n * Copy any tags set in t2 into t, overriding the value in t.\n */\n#define TAGS_MERGE(t, t2) do {\t\t\t\t\t\t       \\\n    if ((t2).follow != UNSPEC)\t\t\t\t\t\t       \\\n\t(t).follow = (t2).follow;\t\t\t\t\t       \\\n    if ((t2).intercept != UNSPEC)\t\t\t\t\t       \\\n\t(t).intercept = (t2).intercept;\t\t\t\t\t       \\\n    if ((t2).log_input != UNSPEC)\t\t\t\t\t       \\\n\t(t).log_input = (t2).log_input;\t\t\t\t\t       \\\n    if ((t2).log_output != UNSPEC)\t\t\t\t\t       \\\n\t(t).log_output = (t2).log_output;\t\t\t\t       \\\n    if ((t2).noexec != UNSPEC)\t\t\t\t\t\t       \\\n\t(t).noexec = (t2).noexec;\t\t\t\t\t       \\\n    if ((t2).nopasswd != UNSPEC)\t\t\t\t\t       \\\n\t(t).nopasswd = (t2).nopasswd;\t\t\t\t\t       \\\n    if ((t2).send_mail != UNSPEC)\t\t\t\t\t       \\\n\t(t).send_mail = (t2).send_mail;\t\t\t\t\t       \\\n    if ((t2).setenv != UNSPEC)\t\t\t\t\t\t       \\\n\t(t).setenv = (t2).setenv;\t\t\t\t\t       \\\n} while (0)\n\n/*\n * Returns true if any tag are not UNSPEC, else false.\n */\n#define TAGS_SET(t)\t\t\t\t\t\t\t       \\\n    ((t).follow != UNSPEC || (t).intercept != UNSPEC ||\t\t\t       \\\n     (t).log_input != UNSPEC || (t).log_output != UNSPEC ||\t\t       \\\n     (t).noexec != UNSPEC || (t).nopasswd != UNSPEC ||\t\t\t       \\\n     (t).send_mail != UNSPEC ||\t(t).setenv != UNSPEC)\n\n/*\n * Returns true if the specified tag is not UNSPEC or IMPLIED, else false.\n */\n#define TAG_SET(tt) \\\n    ((tt) == true || (tt) == false)\n\n/*\n * Returns true if any tags set in nt differ between ot and nt, else false.\n */\n#define TAGS_CHANGED(ot, nt) \\\n    ((TAG_SET((nt).follow) && (nt).follow != (ot).follow) || \\\n    (TAG_SET((nt).intercept) && (nt).intercept != (ot).intercept) || \\\n    (TAG_SET((nt).log_input) && (nt).log_input != (ot).log_input) || \\\n    (TAG_SET((nt).log_output) && (nt).log_output != (ot).log_output) || \\\n    (TAG_SET((nt).noexec) && (nt).noexec != (ot).noexec) || \\\n    (TAG_SET((nt).nopasswd) && (nt).nopasswd != (ot).nopasswd) || \\\n    (TAG_SET((nt).setenv) && (nt).setenv != (ot).setenv) || \\\n    (TAG_SET((nt).send_mail) && (nt).send_mail != (ot).send_mail))\n\n/*\n * Returns true if the runas user and group lists match, else false.\n */\n#define RUNAS_CHANGED(cs1, cs2) \\\n     ((cs1)->runasuserlist != (cs2)->runasuserlist || \\\n     (cs1)->runasgrouplist != (cs2)->runasgrouplist)\n\nstruct command_digest {\n    TAILQ_ENTRY(command_digest) entries;\n    unsigned int digest_type;\n    char *digest_str;\n};\n\n/*\n * Tags associated with a command.\n * Possible values: true, false, IMPLIED, UNSPEC.\n */\nstruct cmndtag {\n    signed int follow: 3;\n    signed int intercept: 3;\n    signed int log_input: 3;\n    signed int log_output: 3;\n    signed int noexec: 3;\n    signed int nopasswd: 3;\n    signed int send_mail: 3;\n    signed int setenv: 3;\n};\n\n/*\n * Per-command option container struct.\n */\nstruct command_options {\n    time_t notbefore;\t\t\t/* time restriction */\n    time_t notafter;\t\t\t/* time restriction */\n    int timeout;\t\t\t/* command timeout */\n    char *runcwd;\t\t\t/* working directory */\n    char *runchroot;\t\t\t/* root directory */\n#ifdef HAVE_SELINUX\n    char *role, *type;\t\t\t/* SELinux role and type */\n#endif\n#ifdef HAVE_APPARMOR\n    char *apparmor_profile;\t\t/* AppArmor profile */\n#endif\n#ifdef HAVE_PRIV_SET\n    char *privs, *limitprivs;\t\t/* Solaris privilege sets */\n#endif\n};\n\n/*\n * The parsed sudoers file is stored as a collection of linked lists,\n * modelled after the yacc grammar.\n *\n * Other than the alias struct, which is stored in a red-black tree,\n * the data structure used is a doubly-linked tail queue.  While sudoers\n * is being parsed, a headless tail queue is used where the first entry\n * acts as the head and the prev pointer does double duty as the tail pointer.\n * This makes it possible to trivially append sub-lists.  In addition, the prev\n * pointer is always valid (even if it points to itself).  Unlike a circle\n * queue, the next pointer of the last entry is NULL and does not point back\n * to the head.  When the tail queue is finalized, it is converted to a\n * normal BSD tail queue.\n */\n\n/*\n * Tail queue list head structures.\n */\nTAILQ_HEAD(defaults_list, defaults);\nTAILQ_HEAD(userspec_list, userspec);\nTAILQ_HEAD(member_list, member);\nTAILQ_HEAD(privilege_list, privilege);\nTAILQ_HEAD(cmndspec_list, cmndspec);\nTAILQ_HEAD(command_digest_list, command_digest);\nSTAILQ_HEAD(comment_list, sudoers_comment);\nTAILQ_HEAD(sudoers_parse_tree_list, sudoers_parse_tree);\n\n/*\n * Structure describing a user specification and list thereof.\n */\nstruct userspec {\n    TAILQ_ENTRY(userspec) entries;\n    struct member_list users;\t\t/* list of users */\n    struct privilege_list privileges;\t/* list of privileges */\n    struct comment_list comments;\t/* optional comments */\n    int line;\t\t\t\t/* line number in sudoers */\n    int column;\t\t\t\t/* column number in sudoers */\n    char *file;\t\t\t\t/* name of sudoers file */\n};\n\n/*\n * Structure describing a privilege specification.\n */\nstruct privilege {\n    TAILQ_ENTRY(privilege) entries;\n    char *ldap_role;\t\t\t/* LDAP sudoRole */\n    struct member_list hostlist;\t/* list of hosts */\n    struct cmndspec_list cmndlist;\t/* list of Cmnd_Specs */\n    struct defaults_list defaults;\t/* list of sudoOptions */\n};\n\n/*\n * A command with option args and digest.\n * XXX - merge into struct member\n */\nstruct sudo_command {\n    char *cmnd;\n    char *args;\n    struct command_digest_list digests;\n};\n\n/*\n * Structure describing a linked list of Cmnd_Specs.\n * XXX - include struct command_options instead of its contents inline\n */\nstruct cmndspec {\n    TAILQ_ENTRY(cmndspec) entries;\n    struct member_list *runasuserlist;\t/* list of runas users */\n    struct member_list *runasgrouplist;\t/* list of runas groups */\n    struct member *cmnd;\t\t/* command to allow/deny */\n    struct cmndtag tags;\t\t/* tag specificaion */\n    int timeout;\t\t\t/* command timeout */\n    time_t notbefore;\t\t\t/* time restriction */\n    time_t notafter;\t\t\t/* time restriction */\n    char *runcwd;\t\t\t/* working directory */\n    char *runchroot;\t\t\t/* root directory */\n#ifdef HAVE_SELINUX\n    char *role, *type;\t\t\t/* SELinux role and type */\n#endif\n#ifdef HAVE_APPARMOR\n    char *apparmor_profile;\t\t/* AppArmor profile */\n#endif\n#ifdef HAVE_PRIV_SET\n    char *privs, *limitprivs;\t\t/* Solaris privilege sets */\n#endif\n};\n\n/*\n * Generic structure to hold users, hosts, commands.\n */\nstruct member {\n    TAILQ_ENTRY(member) entries;\n    char *name;\t\t\t\t/* member name */\n    short type;\t\t\t\t/* type (see gram.h) */\n    short negated;\t\t\t/* negated via '!'? */\n};\n\nstruct runascontainer {\n    struct member *runasusers;\n    struct member *runasgroups;\n};\n\nstruct defaults_binding {\n    struct member_list members;\n    unsigned int refcnt;\n};\n\nstruct sudoers_comment {\n    STAILQ_ENTRY(sudoers_comment) entries;\n    char *str;\n};\n\n/*\n * Generic structure to hold {User,Host,Runas,Cmnd}_Alias\n * Aliases are stored in a red-black tree, sorted by name and type.\n */\nstruct alias {\n    char *name;\t\t\t\t/* alias name */\n    short type;\t\t\t\t/* {USER,HOST,RUNAS,CMND}ALIAS */\n    short used;\t\t\t\t/* \"used\" flag for cycle detection */\n    int line;\t\t\t\t/* line number of alias entry */\n    int column;\t\t\t\t/* column number of alias entry */\n    char *file;\t\t\t\t/* file the alias entry was in */\n    struct member_list members;\t\t/* list of alias members */\n};\n\n/*\n * Structure describing a Defaults entry in sudoers.\n */\nstruct defaults {\n    TAILQ_ENTRY(defaults) entries;\n    char *var;\t\t\t\t/* variable name */\n    char *val;\t\t\t\t/* variable value */\n    struct defaults_binding *binding;\t/* user/host/runas binding */\n    char *file;\t\t\t\t/* file Defaults entry was in */\n    int type;\t\t\t\t/* DEFAULTS{,_USER,_RUNAS,_HOST} */\n    int op;\t\t\t\t/* true, false, '+', '-' */\n    int line;\t\t\t\t/* line number of Defaults entry */\n    int column;\t\t\t\t/* column number of Defaults entry */\n};\n\nstruct sudoers_match_info {\n    const struct sudoers_parse_tree *parse_tree;\n    const struct userspec *us;\t\t/* matching userspec */\n    const struct privilege *priv;\t/* matching privilege */\n    const struct cmndspec *cs;\t\t/* matching cmndspec */\n};\n\n/*\n * Parsed sudoers policy.\n */\nstruct sudo_nss;\nstruct sudoers_parse_tree {\n    TAILQ_ENTRY(sudoers_parse_tree) entries;\n    struct userspec_list userspecs;\n    struct defaults_list defaults;\n    struct rbtree *aliases;\n    char *shost, *lhost;\n    struct sudo_nss *nss;\n    struct sudoers_context *ctx;\n};\n\n/*\n * Info about the command being resolved.\n */\nstruct cmnd_info {\n    struct stat cmnd_stat;\n    char *cmnd_path;\n    int status;\n    bool intercepted;\n};\n\n/*\n * Optional callback for sudoers_lookup().\n */\ntypedef void (*sudoers_lookup_callback_fn_t)(const struct sudoers_parse_tree *parse_tree, const struct userspec *us, int user_match, const struct privilege *priv, int host_match, const struct cmndspec *cs, int date_match, int runas_match, int cmnd_match, void *closure);\n\n/*\n * The parser passes pointers to data structures that are not stored anywhere.\n * We add them to the leak list at allocation time and remove them from\n * the list when they are stored in another data structure.\n * This makes it possible to free data on error that would otherwise be leaked.\n */\nenum parser_leak_types {\n    LEAK_UNKNOWN,\n    LEAK_PRIVILEGE,\n    LEAK_CMNDSPEC,\n    LEAK_DEFAULTS,\n    LEAK_MEMBER,\n    LEAK_DIGEST,\n    LEAK_RUNAS,\n    LEAK_PTR\n};\nstruct parser_leak_entry {\n    SLIST_ENTRY(parser_leak_entry) entries;\n    enum parser_leak_types type;\n    union {\n\tstruct command_digest *dig;\n\tstruct privilege *p;\n\tstruct cmndspec *cs;\n\tstruct defaults *d;\n\tstruct member *m;\n\tstruct runascontainer *rc;\n\tvoid *ptr;\n    } u;\n};\nSLIST_HEAD(parser_leak_list, parser_leak_entry);\n\n#define YY_DECL int sudoerslex(void)\n\n/* alias.c */\nstruct rbtree *alloc_aliases(void);\nvoid free_aliases(struct rbtree *aliases);\nbool no_aliases(const struct sudoers_parse_tree *parse_tree);\nbool alias_add(struct sudoers_parse_tree *parse_tree, char *name, short type, char *file, int line, int column, struct member *members);\nconst char *alias_type_to_string(short alias_type);\nstruct alias *alias_get(const struct sudoers_parse_tree *parse_tree, const char *name, short type);\nstruct alias *alias_remove(struct sudoers_parse_tree *parse_tree, const char *name, short type);\nbool alias_find_used(struct sudoers_parse_tree *parse_tree, struct rbtree *used_aliases);\nvoid alias_apply(struct sudoers_parse_tree *parse_tree, int (*func)(struct sudoers_parse_tree *, struct alias *, void *), void *cookie);\nvoid alias_free(void *a);\nvoid alias_put(struct alias *a);\n\n/* check_aliases.c */\nint check_aliases(struct sudoers_parse_tree *parse_tree, bool strict, bool quiet, int (*cb_unused)(struct sudoers_parse_tree *, struct alias *, void *));\n\n/* gram.y */\nextern bool parse_error;\nextern struct sudoers_parse_tree parsed_policy;\nextern bool (*sudoers_error_hook)(const struct sudoers_context *ctx, const char *file, int line, int column, const char * restrict fmt, va_list args);\nbool reset_parser(void);\nvoid free_member(struct member *m);\nvoid free_members(struct member_list *members);\nvoid free_cmndspec(struct cmndspec *cs, struct cmndspec_list *csl);\nvoid free_cmndspecs(struct cmndspec_list *csl);\nvoid free_privilege(struct privilege *priv);\nvoid free_userspec(struct userspec *us);\nvoid free_userspecs(struct userspec_list *usl);\nvoid free_default(struct defaults *def);\nvoid free_defaults(struct defaults_list *defs);\nbool init_parser(struct sudoers_context *ctx, const char *file);\nvoid init_parse_tree(struct sudoers_parse_tree *parse_tree, char *lhost, char *shost, struct sudoers_context *ctx, struct sudo_nss *nss);\nvoid free_parse_tree(struct sudoers_parse_tree *parse_tree);\nbool parser_leak_add(enum parser_leak_types type, void *v);\nbool parser_leak_remove(enum parser_leak_types type, void *v);\nvoid parser_leak_init(void);\nvoid reparent_parse_tree(struct sudoers_parse_tree *new_tree);\nint sudoersparse(void);\nuid_t sudoers_file_uid(void);\ngid_t sudoers_file_gid(void);\nmode_t sudoers_file_mode(void);\nbool sudoers_error_recovery(void);\nbool sudoers_strict(void);\n\n/* match_addr.c */\nbool addr_matches(char *n);\n\n/* match_command.c */\nbool command_matches(struct sudoers_context *ctx, const char *sudoers_cmnd, const char *sudoers_args, const char *runchroot, struct cmnd_info *info, const struct command_digest_list *digests);\n\n/* match_digest.c */\nbool digest_matches(int fd, const char *path, const struct command_digest_list *digests);\n\n/* match.c */\nstruct group;\nstruct passwd;\nbool group_matches(const char *sudoers_group, const struct group *gr);\nbool hostname_matches(const char *shost, const char *lhost, const char *pattern);\nbool netgr_matches(const struct sudo_nss *nss, const char *netgr, const char *lhost, const char *shost, const char *user);\nbool usergr_matches(const char *group, const char *user, const struct passwd *pw);\nbool userpw_matches(const char *sudoers_user, const char *user, const struct passwd *pw);\nint cmnd_matches(const struct sudoers_parse_tree *parse_tree, const struct member *m, const char *runchroot, struct cmnd_info *info);\nint cmnd_matches_all(const struct sudoers_parse_tree *parse_tree, const struct member *m, const char *runchroot, struct cmnd_info *info);\nint cmndlist_matches(const struct sudoers_parse_tree *parse_tree, const struct member_list *list, const char *runchroot, struct cmnd_info *info);\nint host_matches(const struct sudoers_parse_tree *parse_tree, const struct passwd *pw, const char *host, const char *shost, const struct member *m);\nint hostlist_matches(const struct sudoers_parse_tree *parse_tree, const struct passwd *pw, const struct member_list *list);\nint runaslist_matches(const struct sudoers_parse_tree *parse_tree, const struct member_list *user_list, const struct member_list *group_list, struct member **matching_user, struct member **matching_group);\nint user_matches(const struct sudoers_parse_tree *parse_tree, const struct passwd *pw, const struct member *m);\nint userlist_matches(const struct sudoers_parse_tree *parse_tree, const struct passwd *pw, const struct member_list *list);\nconst char *sudo_getdomainname(void);\nstruct gid_list *runas_getgroups(const struct sudoers_context *ctx);\n\n/* toke.l */\nYY_DECL;\nvoid sudoersrestart(FILE *);\nextern FILE *sudoersin;\nextern char *sudoers;\n\n/* base64.c */\nsize_t base64_decode(const char *str, unsigned char *dst, size_t dsize);\nsize_t base64_encode(const unsigned char *in, size_t in_len, char *out, size_t out_len);\n\n/* timeout.c */\nint parse_timeout(const char *timestr);\n\n/* gentime.c */\ntime_t parse_gentime(const char *expstr);\n\n/* filedigest.c */\nunsigned char *sudo_filedigest(int fd, const char *file, unsigned int digest_type, size_t *digest_len);\n\n/* digestname.c */\nconst char *digest_type_to_name(unsigned int digest_type);\n\n/* parse.c */\nstruct sudo_nss_list;\nunsigned int sudoers_lookup(struct sudo_nss_list *snl, struct sudoers_context *ctx, time_t now, sudoers_lookup_callback_fn_t callback, void *cb_data, int *cmnd_status, int pwflag);\n\n/* display.c */\nint display_privs(struct sudoers_context *ctx, const struct sudo_nss_list *snl, struct passwd *pw, bool verbose);\nint display_cmnd(struct sudoers_context *ctx, const struct sudo_nss_list *snl, struct passwd *pw, bool verbose);\n\n/* parse_ldif.c */\nbool sudoers_parse_ldif(struct sudoers_parse_tree *parse_tree, FILE *fp, const char *sudoers_base, bool store_options);\n\n/* fmtsudoers.c */\nstruct sudo_lbuf;\nbool sudoers_format_cmndspec(struct sudo_lbuf *lbuf, const struct sudoers_parse_tree *parse_tree, const struct cmndspec *cs, const struct cmndspec *prev_cs, struct cmndtag tags, bool expand_aliases);\nbool sudoers_format_default(struct sudo_lbuf *lbuf, const struct defaults *d);\nbool sudoers_format_member(struct sudo_lbuf *lbuf, const struct sudoers_parse_tree *parse_tree, const struct member *m, const char *separator, short alias_type);\nbool sudoers_defaults_to_tags(const char *var, const char *val, int op, struct cmndtag *tags);\nbool sudoers_defaults_list_to_tags(const struct defaults_list *defs, struct cmndtag *tags);\n\n/* fmtsudoers_cvt.c */\nbool sudoers_format_privilege(struct sudo_lbuf *lbuf, const struct sudoers_parse_tree *parse_tree, const struct privilege *priv, bool expand_aliases);\nbool sudoers_format_userspec(struct sudo_lbuf *lbuf, const struct sudoers_parse_tree *parse_tree, const struct userspec *us, bool expand_aliases);\nbool sudoers_format_userspecs(struct sudo_lbuf *lbuf, const struct sudoers_parse_tree *parse_tree, const char *separator, bool expand_aliases, bool flush);\nbool sudoers_format_default_line(struct sudo_lbuf *lbuf, const struct sudoers_parse_tree *parse_tree, const struct defaults *d, struct defaults **next, bool expand_aliases);\n\n#endif /* SUDOERS_PARSE_H */\n"], "filenames": ["plugins/sudoers/auth/passwd.c", "plugins/sudoers/auth/sudo_auth.c", "plugins/sudoers/auth/sudo_auth.h", "plugins/sudoers/lookup.c", "plugins/sudoers/match.c", "plugins/sudoers/parse.h"], "buggy_code_start_loc": [71, 119, 22, 103, 94, 38], "buggy_code_end_loc": [117, 438, 28, 554, 515, 98], "fixing_code_start_loc": [71, 119, 22, 103, 94, 39], "fixing_code_end_loc": [124, 459, 28, 554, 516, 111], "type": "NVD-CWE-noinfo", "message": "Sudo before 1.9.15 might allow row hammer attacks (for authentication bypass or privilege escalation) because application logic sometimes is based on not equaling an error value (instead of equaling a success value), and because the values do not resist flips of a single bit.", "other": {"cve": {"id": "CVE-2023-42465", "sourceIdentifier": "cve@mitre.org", "published": "2023-12-22T16:15:08.057", "lastModified": "2024-02-18T03:15:07.767", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Sudo before 1.9.15 might allow row hammer attacks (for authentication bypass or privilege escalation) because application logic sometimes is based on not equaling an error value (instead of equaling a success value), and because the values do not resist flips of a single bit."}, {"lang": "es", "value": "Sudo anterior a 1.9.15 podr\u00eda permitir row hammer attacks (para eludir la autenticaci\u00f3n o escalar privilegios) porque la l\u00f3gica de la aplicaci\u00f3n a veces se basa en no igualar un valor de error (en lugar de igualar un valor de \u00e9xito) y porque los valores no resisten los cambios de un solo bit."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.0, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sudo_project:sudo:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.9.15", "matchCriteriaId": "0352673D-D618-41C1-BC9F-8B3582BC277E"}]}]}], "references": [{"url": "https://arxiv.org/abs/2309.02545", "source": "cve@mitre.org", "tags": ["Technical Description", "Third Party Advisory"]}, {"url": "https://github.com/sudo-project/sudo/commit/7873f8334c8d31031f8cfa83bd97ac6029309e4f", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/sudo-project/sudo/releases/tag/SUDO_1_9_15", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/R4Q23NHCKCLFIHSNY6KJ27GM7FSCEVXM/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/U6XMRUJCPII4MPWG43HTYR76DGLEYEFZ/", "source": "cve@mitre.org"}, {"url": "https://security.gentoo.org/glsa/202401-29", "source": "cve@mitre.org"}, {"url": "https://security.netapp.com/advisory/ntap-20240208-0002/", "source": "cve@mitre.org"}, {"url": "https://www.openwall.com/lists/oss-security/2023/12/21/9", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List"]}, {"url": "https://www.sudo.ws/releases/changelog/", "source": "cve@mitre.org", "tags": ["Release Notes"]}]}, "github_commit_url": "https://github.com/sudo-project/sudo/commit/7873f8334c8d31031f8cfa83bd97ac6029309e4f"}}