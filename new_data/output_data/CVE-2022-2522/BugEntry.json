{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * autocmd.c: Autocommand related functions\n */\n\n#include \"vim.h\"\n\n/*\n * The autocommands are stored in a list for each event.\n * Autocommands for the same pattern, that are consecutive, are joined\n * together, to avoid having to match the pattern too often.\n * The result is an array of Autopat lists, which point to AutoCmd lists:\n *\n * last_autopat[0]  -----------------------------+\n *\t\t\t\t\t\t V\n * first_autopat[0] --> Autopat.next  -->  Autopat.next -->  NULL\n *\t\t\tAutopat.cmds\t   Autopat.cmds\n *\t\t\t    |\t\t\t |\n *\t\t\t    V\t\t\t V\n *\t\t\tAutoCmd.next\t   AutoCmd.next\n *\t\t\t    |\t\t\t |\n *\t\t\t    V\t\t\t V\n *\t\t\tAutoCmd.next\t\tNULL\n *\t\t\t    |\n *\t\t\t    V\n *\t\t\t   NULL\n *\n * last_autopat[1]  --------+\n *\t\t\t    V\n * first_autopat[1] --> Autopat.next  -->  NULL\n *\t\t\tAutopat.cmds\n *\t\t\t    |\n *\t\t\t    V\n *\t\t\tAutoCmd.next\n *\t\t\t    |\n *\t\t\t    V\n *\t\t\t   NULL\n *   etc.\n *\n *   The order of AutoCmds is important, this is the order in which they were\n *   defined and will have to be executed.\n */\ntypedef struct AutoCmd\n{\n    char_u\t    *cmd;\t\t// The command to be executed (NULL\n\t\t\t\t\t// when command has been removed).\n    char\t    once;\t\t// \"One shot\": removed after execution\n    char\t    nested;\t\t// If autocommands nest here.\n    char\t    last;\t\t// last command in list\n    sctx_T\t    script_ctx;\t\t// script context where it is defined\n    struct AutoCmd  *next;\t\t// next AutoCmd in list\n} AutoCmd;\n\ntypedef struct AutoPat\n{\n    struct AutoPat  *next;\t\t// Next AutoPat in AutoPat list; MUST\n\t\t\t\t\t// be the first entry.\n    char_u\t    *pat;\t\t// pattern as typed (NULL when pattern\n\t\t\t\t\t// has been removed)\n    regprog_T\t    *reg_prog;\t\t// compiled regprog for pattern\n    AutoCmd\t    *cmds;\t\t// list of commands to do\n    int\t\t    group;\t\t// group ID\n    int\t\t    patlen;\t\t// strlen() of pat\n    int\t\t    buflocal_nr;\t// !=0 for buffer-local AutoPat\n    char\t    allow_dirs;\t\t// Pattern may match whole path\n    char\t    last;\t\t// last pattern for apply_autocmds()\n} AutoPat;\n\nstatic struct event_name\n{\n    char\t*name;\t// event name\n    event_T\tevent;\t// event number\n} event_names[] =\n{\n    {\"BufAdd\",\t\tEVENT_BUFADD},\n    {\"BufCreate\",\tEVENT_BUFADD},\n    {\"BufDelete\",\tEVENT_BUFDELETE},\n    {\"BufEnter\",\tEVENT_BUFENTER},\n    {\"BufFilePost\",\tEVENT_BUFFILEPOST},\n    {\"BufFilePre\",\tEVENT_BUFFILEPRE},\n    {\"BufHidden\",\tEVENT_BUFHIDDEN},\n    {\"BufLeave\",\tEVENT_BUFLEAVE},\n    {\"BufNew\",\t\tEVENT_BUFNEW},\n    {\"BufNewFile\",\tEVENT_BUFNEWFILE},\n    {\"BufRead\",\t\tEVENT_BUFREADPOST},\n    {\"BufReadCmd\",\tEVENT_BUFREADCMD},\n    {\"BufReadPost\",\tEVENT_BUFREADPOST},\n    {\"BufReadPre\",\tEVENT_BUFREADPRE},\n    {\"BufUnload\",\tEVENT_BUFUNLOAD},\n    {\"BufWinEnter\",\tEVENT_BUFWINENTER},\n    {\"BufWinLeave\",\tEVENT_BUFWINLEAVE},\n    {\"BufWipeout\",\tEVENT_BUFWIPEOUT},\n    {\"BufWrite\",\tEVENT_BUFWRITEPRE},\n    {\"BufWritePost\",\tEVENT_BUFWRITEPOST},\n    {\"BufWritePre\",\tEVENT_BUFWRITEPRE},\n    {\"BufWriteCmd\",\tEVENT_BUFWRITECMD},\n    {\"CmdlineChanged\",\tEVENT_CMDLINECHANGED},\n    {\"CmdlineEnter\",\tEVENT_CMDLINEENTER},\n    {\"CmdlineLeave\",\tEVENT_CMDLINELEAVE},\n    {\"CmdwinEnter\",\tEVENT_CMDWINENTER},\n    {\"CmdwinLeave\",\tEVENT_CMDWINLEAVE},\n    {\"CmdUndefined\",\tEVENT_CMDUNDEFINED},\n    {\"ColorScheme\",\tEVENT_COLORSCHEME},\n    {\"ColorSchemePre\",\tEVENT_COLORSCHEMEPRE},\n    {\"CompleteChanged\",\tEVENT_COMPLETECHANGED},\n    {\"CompleteDone\",\tEVENT_COMPLETEDONE},\n    {\"CompleteDonePre\",\tEVENT_COMPLETEDONEPRE},\n    {\"CursorHold\",\tEVENT_CURSORHOLD},\n    {\"CursorHoldI\",\tEVENT_CURSORHOLDI},\n    {\"CursorMoved\",\tEVENT_CURSORMOVED},\n    {\"CursorMovedI\",\tEVENT_CURSORMOVEDI},\n    {\"DiffUpdated\",\tEVENT_DIFFUPDATED},\n    {\"DirChanged\",\tEVENT_DIRCHANGED},\n    {\"DirChangedPre\",\tEVENT_DIRCHANGEDPRE},\n    {\"EncodingChanged\",\tEVENT_ENCODINGCHANGED},\n    {\"ExitPre\",\t\tEVENT_EXITPRE},\n    {\"FileEncoding\",\tEVENT_ENCODINGCHANGED},\n    {\"FileAppendPost\",\tEVENT_FILEAPPENDPOST},\n    {\"FileAppendPre\",\tEVENT_FILEAPPENDPRE},\n    {\"FileAppendCmd\",\tEVENT_FILEAPPENDCMD},\n    {\"FileChangedShell\",EVENT_FILECHANGEDSHELL},\n    {\"FileChangedShellPost\",EVENT_FILECHANGEDSHELLPOST},\n    {\"FileChangedRO\",\tEVENT_FILECHANGEDRO},\n    {\"FileReadPost\",\tEVENT_FILEREADPOST},\n    {\"FileReadPre\",\tEVENT_FILEREADPRE},\n    {\"FileReadCmd\",\tEVENT_FILEREADCMD},\n    {\"FileType\",\tEVENT_FILETYPE},\n    {\"FileWritePost\",\tEVENT_FILEWRITEPOST},\n    {\"FileWritePre\",\tEVENT_FILEWRITEPRE},\n    {\"FileWriteCmd\",\tEVENT_FILEWRITECMD},\n    {\"FilterReadPost\",\tEVENT_FILTERREADPOST},\n    {\"FilterReadPre\",\tEVENT_FILTERREADPRE},\n    {\"FilterWritePost\",\tEVENT_FILTERWRITEPOST},\n    {\"FilterWritePre\",\tEVENT_FILTERWRITEPRE},\n    {\"FocusGained\",\tEVENT_FOCUSGAINED},\n    {\"FocusLost\",\tEVENT_FOCUSLOST},\n    {\"FuncUndefined\",\tEVENT_FUNCUNDEFINED},\n    {\"GUIEnter\",\tEVENT_GUIENTER},\n    {\"GUIFailed\",\tEVENT_GUIFAILED},\n    {\"InsertChange\",\tEVENT_INSERTCHANGE},\n    {\"InsertEnter\",\tEVENT_INSERTENTER},\n    {\"InsertLeave\",\tEVENT_INSERTLEAVE},\n    {\"InsertLeavePre\",\tEVENT_INSERTLEAVEPRE},\n    {\"InsertCharPre\",\tEVENT_INSERTCHARPRE},\n    {\"MenuPopup\",\tEVENT_MENUPOPUP},\n    {\"ModeChanged\",\tEVENT_MODECHANGED},\n    {\"OptionSet\",\tEVENT_OPTIONSET},\n    {\"QuickFixCmdPost\",\tEVENT_QUICKFIXCMDPOST},\n    {\"QuickFixCmdPre\",\tEVENT_QUICKFIXCMDPRE},\n    {\"QuitPre\",\t\tEVENT_QUITPRE},\n    {\"RemoteReply\",\tEVENT_REMOTEREPLY},\n    {\"SafeState\",\tEVENT_SAFESTATE},\n    {\"SafeStateAgain\",\tEVENT_SAFESTATEAGAIN},\n    {\"SessionLoadPost\",\tEVENT_SESSIONLOADPOST},\n    {\"ShellCmdPost\",\tEVENT_SHELLCMDPOST},\n    {\"ShellFilterPost\",\tEVENT_SHELLFILTERPOST},\n    {\"SigUSR1\",\t\tEVENT_SIGUSR1},\n    {\"SourceCmd\",\tEVENT_SOURCECMD},\n    {\"SourcePre\",\tEVENT_SOURCEPRE},\n    {\"SourcePost\",\tEVENT_SOURCEPOST},\n    {\"SpellFileMissing\",EVENT_SPELLFILEMISSING},\n    {\"StdinReadPost\",\tEVENT_STDINREADPOST},\n    {\"StdinReadPre\",\tEVENT_STDINREADPRE},\n    {\"SwapExists\",\tEVENT_SWAPEXISTS},\n    {\"Syntax\",\t\tEVENT_SYNTAX},\n    {\"TabNew\",\t\tEVENT_TABNEW},\n    {\"TabClosed\",\tEVENT_TABCLOSED},\n    {\"TabEnter\",\tEVENT_TABENTER},\n    {\"TabLeave\",\tEVENT_TABLEAVE},\n    {\"TermChanged\",\tEVENT_TERMCHANGED},\n    {\"TerminalOpen\",\tEVENT_TERMINALOPEN},\n    {\"TerminalWinOpen\", EVENT_TERMINALWINOPEN},\n    {\"TermResponse\",\tEVENT_TERMRESPONSE},\n    {\"TextChanged\",\tEVENT_TEXTCHANGED},\n    {\"TextChangedI\",\tEVENT_TEXTCHANGEDI},\n    {\"TextChangedP\",\tEVENT_TEXTCHANGEDP},\n    {\"User\",\t\tEVENT_USER},\n    {\"VimEnter\",\tEVENT_VIMENTER},\n    {\"VimLeave\",\tEVENT_VIMLEAVE},\n    {\"VimLeavePre\",\tEVENT_VIMLEAVEPRE},\n    {\"WinNew\",\t\tEVENT_WINNEW},\n    {\"WinClosed\",\tEVENT_WINCLOSED},\n    {\"WinEnter\",\tEVENT_WINENTER},\n    {\"WinLeave\",\tEVENT_WINLEAVE},\n    {\"WinScrolled\",\tEVENT_WINSCROLLED},\n    {\"VimResized\",\tEVENT_VIMRESIZED},\n    {\"TextYankPost\",\tEVENT_TEXTYANKPOST},\n    {\"VimSuspend\",\tEVENT_VIMSUSPEND},\n    {\"VimResume\",\tEVENT_VIMRESUME},\n    {NULL,\t\t(event_T)0}\n};\n\nstatic AutoPat *first_autopat[NUM_EVENTS] =\n{\n    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL\n};\n\nstatic AutoPat *last_autopat[NUM_EVENTS] =\n{\n    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL\n};\n\n#define AUGROUP_DEFAULT    (-1)\t    // default autocmd group\n#define AUGROUP_ERROR\t   (-2)\t    // erroneous autocmd group\n#define AUGROUP_ALL\t   (-3)\t    // all autocmd groups\n\n/*\n * struct used to keep status while executing autocommands for an event.\n */\nstruct AutoPatCmd_S\n{\n    AutoPat\t*curpat;\t// next AutoPat to examine\n    AutoCmd\t*nextcmd;\t// next AutoCmd to execute\n    int\t\tgroup;\t\t// group being used\n    char_u\t*fname;\t\t// fname to match with\n    char_u\t*sfname;\t// sfname to match with\n    char_u\t*tail;\t\t// tail of fname\n    event_T\tevent;\t\t// current event\n    sctx_T\tscript_ctx;\t// script context where it is defined\n    int\t\targ_bufnr;\t// Initially equal to <abuf>, set to zero when\n\t\t\t\t// buf is deleted.\n    AutoPatCmd_T *next;\t\t// chain of active apc-s for auto-invalidation\n};\n\nstatic AutoPatCmd_T *active_apc_list = NULL; // stack of active autocommands\n\n// Macro to loop over all the patterns for an autocmd event\n#define FOR_ALL_AUTOCMD_PATTERNS(event, ap) \\\n    for ((ap) = first_autopat[(int)(event)]; (ap) != NULL; (ap) = (ap)->next)\n\n/*\n * augroups stores a list of autocmd group names.\n */\nstatic garray_T augroups = {0, 0, sizeof(char_u *), 10, NULL};\n#define AUGROUP_NAME(i) (((char_u **)augroups.ga_data)[i])\n// use get_deleted_augroup() to get this\nstatic char_u *deleted_augroup = NULL;\n\n/*\n * The ID of the current group.  Group 0 is the default one.\n */\nstatic int current_augroup = AUGROUP_DEFAULT;\n\nstatic int au_need_clean = FALSE;   // need to delete marked patterns\n\nstatic char_u *event_nr2name(event_T event);\nstatic int au_get_grouparg(char_u **argp);\nstatic int do_autocmd_event(event_T event, char_u *pat, int once, int nested, char_u *cmd, int forceit, int group, int flags);\nstatic int apply_autocmds_group(event_T event, char_u *fname, char_u *fname_io, int force, int group, buf_T *buf, exarg_T *eap);\nstatic void auto_next_pat(AutoPatCmd_T *apc, int stop_at_last);\nstatic int au_find_group(char_u *name);\n\nstatic event_T\tlast_event;\nstatic int\tlast_group;\nstatic int\tautocmd_blocked = 0;\t// block all autocmds\n\n    static char_u *\nget_deleted_augroup(void)\n{\n    if (deleted_augroup == NULL)\n\tdeleted_augroup = (char_u *)_(\"--Deleted--\");\n    return deleted_augroup;\n}\n\n/*\n * Show the autocommands for one AutoPat.\n */\n    static void\nshow_autocmd(AutoPat *ap, event_T event)\n{\n    AutoCmd *ac;\n\n    // Check for \"got_int\" (here and at various places below), which is set\n    // when \"q\" has been hit for the \"--more--\" prompt\n    if (got_int)\n\treturn;\n    if (ap->pat == NULL)\t\t// pattern has been removed\n\treturn;\n\n    msg_putchar('\\n');\n    if (got_int)\n\treturn;\n    if (event != last_event || ap->group != last_group)\n    {\n\tif (ap->group != AUGROUP_DEFAULT)\n\t{\n\t    if (AUGROUP_NAME(ap->group) == NULL)\n\t\tmsg_puts_attr((char *)get_deleted_augroup(), HL_ATTR(HLF_E));\n\t    else\n\t\tmsg_puts_attr((char *)AUGROUP_NAME(ap->group), HL_ATTR(HLF_T));\n\t    msg_puts(\"  \");\n\t}\n\tmsg_puts_attr((char *)event_nr2name(event), HL_ATTR(HLF_T));\n\tlast_event = event;\n\tlast_group = ap->group;\n\tmsg_putchar('\\n');\n\tif (got_int)\n\t    return;\n    }\n    msg_col = 4;\n    msg_outtrans(ap->pat);\n\n    for (ac = ap->cmds; ac != NULL; ac = ac->next)\n    {\n\tif (ac->cmd != NULL)\t\t// skip removed commands\n\t{\n\t    if (msg_col >= 14)\n\t\tmsg_putchar('\\n');\n\t    msg_col = 14;\n\t    if (got_int)\n\t\treturn;\n\t    msg_outtrans(ac->cmd);\n#ifdef FEAT_EVAL\n\t    if (p_verbose > 0)\n\t\tlast_set_msg(ac->script_ctx);\n#endif\n\t    if (got_int)\n\t\treturn;\n\t    if (ac->next != NULL)\n\t    {\n\t\tmsg_putchar('\\n');\n\t\tif (got_int)\n\t\t    return;\n\t    }\n\t}\n    }\n}\n\n/*\n * Mark an autocommand pattern for deletion.\n */\n    static void\nau_remove_pat(AutoPat *ap)\n{\n    VIM_CLEAR(ap->pat);\n    ap->buflocal_nr = -1;\n    au_need_clean = TRUE;\n}\n\n/*\n * Mark all commands for a pattern for deletion.\n */\n    static void\nau_remove_cmds(AutoPat *ap)\n{\n    AutoCmd *ac;\n\n    for (ac = ap->cmds; ac != NULL; ac = ac->next)\n\tVIM_CLEAR(ac->cmd);\n    au_need_clean = TRUE;\n}\n\n// Delete one command from an autocmd pattern.\nstatic void au_del_cmd(AutoCmd *ac)\n{\n    VIM_CLEAR(ac->cmd);\n    au_need_clean = TRUE;\n}\n\n/*\n * Cleanup autocommands and patterns that have been deleted.\n * This is only done when not executing autocommands.\n */\n    static void\nau_cleanup(void)\n{\n    AutoPat\t*ap, **prev_ap;\n    AutoCmd\t*ac, **prev_ac;\n    event_T\tevent;\n\n    if (autocmd_busy || !au_need_clean)\n\treturn;\n\n    // loop over all events\n    for (event = (event_T)0; (int)event < NUM_EVENTS;\n\t\t\t\t\t    event = (event_T)((int)event + 1))\n    {\n\t// loop over all autocommand patterns\n\tprev_ap = &(first_autopat[(int)event]);\n\tfor (ap = *prev_ap; ap != NULL; ap = *prev_ap)\n\t{\n\t    int has_cmd = FALSE;\n\n\t    // loop over all commands for this pattern\n\t    prev_ac = &(ap->cmds);\n\t    for (ac = *prev_ac; ac != NULL; ac = *prev_ac)\n\t    {\n\t\t// remove the command if the pattern is to be deleted or when\n\t\t// the command has been marked for deletion\n\t\tif (ap->pat == NULL || ac->cmd == NULL)\n\t\t{\n\t\t    *prev_ac = ac->next;\n\t\t    vim_free(ac->cmd);\n\t\t    vim_free(ac);\n\t\t}\n\t\telse\n\t\t{\n\t\t    has_cmd = TRUE;\n\t\t    prev_ac = &(ac->next);\n\t\t}\n\t    }\n\n\t    if (ap->pat != NULL && !has_cmd)\n\t\t// Pattern was not marked for deletion, but all of its\n\t\t// commands were.  So mark the pattern for deletion.\n\t\tau_remove_pat(ap);\n\n\t    // remove the pattern if it has been marked for deletion\n\t    if (ap->pat == NULL)\n\t    {\n\t\tif (ap->next == NULL)\n\t\t{\n\t\t    if (prev_ap == &(first_autopat[(int)event]))\n\t\t\tlast_autopat[(int)event] = NULL;\n\t\t    else\n\t\t\t// this depends on the \"next\" field being the first in\n\t\t\t// the struct\n\t\t\tlast_autopat[(int)event] = (AutoPat *)prev_ap;\n\t\t}\n\t\t*prev_ap = ap->next;\n\t\tvim_regfree(ap->reg_prog);\n\t\tvim_free(ap);\n\t    }\n\t    else\n\t\tprev_ap = &(ap->next);\n\t}\n    }\n\n    au_need_clean = FALSE;\n}\n\n/*\n * Called when buffer is freed, to remove/invalidate related buffer-local\n * autocmds.\n */\n    void\naubuflocal_remove(buf_T *buf)\n{\n    AutoPat\t    *ap;\n    event_T\t    event;\n    AutoPatCmd_T    *apc;\n\n    // invalidate currently executing autocommands\n    for (apc = active_apc_list; apc; apc = apc->next)\n\tif (buf->b_fnum == apc->arg_bufnr)\n\t    apc->arg_bufnr = 0;\n\n    // invalidate buflocals looping through events\n    for (event = (event_T)0; (int)event < NUM_EVENTS;\n\t\t\t\t\t    event = (event_T)((int)event + 1))\n\t// loop over all autocommand patterns\n\tFOR_ALL_AUTOCMD_PATTERNS(event, ap)\n\t    if (ap->buflocal_nr == buf->b_fnum)\n\t    {\n\t\tau_remove_pat(ap);\n\t\tif (p_verbose >= 6)\n\t\t{\n\t\t    verbose_enter();\n\t\t    smsg(_(\"auto-removing autocommand: %s <buffer=%d>\"),\n\t\t\t\t\t   event_nr2name(event), buf->b_fnum);\n\t\t    verbose_leave();\n\t\t}\n\t    }\n    au_cleanup();\n}\n\n/*\n * Add an autocmd group name.\n * Return its ID.  Returns AUGROUP_ERROR (< 0) for error.\n */\n    static int\nau_new_group(char_u *name)\n{\n    int\t\ti;\n\n    i = au_find_group(name);\n    if (i == AUGROUP_ERROR)\t// the group doesn't exist yet, add it\n    {\n\t// First try using a free entry.\n\tfor (i = 0; i < augroups.ga_len; ++i)\n\t    if (AUGROUP_NAME(i) == NULL)\n\t\tbreak;\n\tif (i == augroups.ga_len && ga_grow(&augroups, 1) == FAIL)\n\t    return AUGROUP_ERROR;\n\n\tAUGROUP_NAME(i) = vim_strsave(name);\n\tif (AUGROUP_NAME(i) == NULL)\n\t    return AUGROUP_ERROR;\n\tif (i == augroups.ga_len)\n\t    ++augroups.ga_len;\n    }\n\n    return i;\n}\n\n    static void\nau_del_group(char_u *name)\n{\n    int\t    i;\n\n    i = au_find_group(name);\n    if (i == AUGROUP_ERROR)\t// the group doesn't exist\n\tsemsg(_(e_no_such_group_str), name);\n    else if (i == current_augroup)\n\temsg(_(e_cannot_delete_current_group));\n    else\n    {\n\tevent_T\tevent;\n\tAutoPat\t*ap;\n\tint\tin_use = FALSE;\n\n\tfor (event = (event_T)0; (int)event < NUM_EVENTS;\n\t\t\t\t\t    event = (event_T)((int)event + 1))\n\t{\n\t    FOR_ALL_AUTOCMD_PATTERNS(event, ap)\n\t\tif (ap->group == i && ap->pat != NULL)\n\t\t{\n\t\t    give_warning((char_u *)_(\"W19: Deleting augroup that is still in use\"), TRUE);\n\t\t    in_use = TRUE;\n\t\t    event = NUM_EVENTS;\n\t\t    break;\n\t\t}\n\t}\n\tvim_free(AUGROUP_NAME(i));\n\tif (in_use)\n\t    AUGROUP_NAME(i) = get_deleted_augroup();\n\telse\n\t    AUGROUP_NAME(i) = NULL;\n    }\n}\n\n/*\n * Find the ID of an autocmd group name.\n * Return its ID.  Returns AUGROUP_ERROR (< 0) for error.\n */\n    static int\nau_find_group(char_u *name)\n{\n    int\t    i;\n\n    for (i = 0; i < augroups.ga_len; ++i)\n\tif (AUGROUP_NAME(i) != NULL && AUGROUP_NAME(i) != get_deleted_augroup()\n\t\t&& STRCMP(AUGROUP_NAME(i), name) == 0)\n\t    return i;\n    return AUGROUP_ERROR;\n}\n\n/*\n * Return TRUE if augroup \"name\" exists.\n */\n    int\nau_has_group(char_u *name)\n{\n    return au_find_group(name) != AUGROUP_ERROR;\n}\n\n/*\n * \":augroup {name}\".\n */\n    void\ndo_augroup(char_u *arg, int del_group)\n{\n    int\t    i;\n\n    if (del_group)\n    {\n\tif (*arg == NUL)\n\t    emsg(_(e_argument_required));\n\telse\n\t    au_del_group(arg);\n    }\n    else if (STRICMP(arg, \"end\") == 0)   // \":aug end\": back to group 0\n\tcurrent_augroup = AUGROUP_DEFAULT;\n    else if (*arg)\t\t    // \":aug xxx\": switch to group xxx\n    {\n\ti = au_new_group(arg);\n\tif (i != AUGROUP_ERROR)\n\t    current_augroup = i;\n    }\n    else\t\t\t    // \":aug\": list the group names\n    {\n\tmsg_start();\n\tfor (i = 0; i < augroups.ga_len; ++i)\n\t{\n\t    if (AUGROUP_NAME(i) != NULL)\n\t    {\n\t\tmsg_puts((char *)AUGROUP_NAME(i));\n\t\tmsg_puts(\"  \");\n\t    }\n\t}\n\tmsg_clr_eos();\n\tmsg_end();\n    }\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_all_autocmds(void)\n{\n    int\t\ti;\n    char_u\t*s;\n\n    for (current_augroup = -1; current_augroup < augroups.ga_len;\n\t\t\t\t\t\t\t    ++current_augroup)\n\tdo_autocmd(NULL, (char_u *)\"\", TRUE);\n\n    for (i = 0; i < augroups.ga_len; ++i)\n    {\n\ts = ((char_u **)(augroups.ga_data))[i];\n\tif (s != get_deleted_augroup())\n\t    vim_free(s);\n    }\n    ga_clear(&augroups);\n}\n#endif\n\n/*\n * Return the event number for event name \"start\".\n * Return NUM_EVENTS if the event name was not found.\n * Return a pointer to the next event name in \"end\".\n */\n    static event_T\nevent_name2nr(char_u *start, char_u **end)\n{\n    char_u\t*p;\n    int\t\ti;\n    int\t\tlen;\n\n    // the event name ends with end of line, '|', a blank or a comma\n    for (p = start; *p && !VIM_ISWHITE(*p) && *p != ',' && *p != '|'; ++p)\n\t;\n    for (i = 0; event_names[i].name != NULL; ++i)\n    {\n\tlen = (int)STRLEN(event_names[i].name);\n\tif (len == p - start && STRNICMP(event_names[i].name, start, len) == 0)\n\t    break;\n    }\n    if (*p == ',')\n\t++p;\n    *end = p;\n    if (event_names[i].name == NULL)\n\treturn NUM_EVENTS;\n    return event_names[i].event;\n}\n\n/*\n * Return the name for event \"event\".\n */\n    static char_u *\nevent_nr2name(event_T event)\n{\n    int\t    i;\n\n    for (i = 0; event_names[i].name != NULL; ++i)\n\tif (event_names[i].event == event)\n\t    return (char_u *)event_names[i].name;\n    return (char_u *)\"Unknown\";\n}\n\n/*\n * Scan over the events.  \"*\" stands for all events.\n */\n    static char_u *\nfind_end_event(\n    char_u  *arg,\n    int\t    have_group)\t    // TRUE when group name was found\n{\n    char_u  *pat;\n    char_u  *p;\n\n    if (*arg == '*')\n    {\n\tif (arg[1] && !VIM_ISWHITE(arg[1]))\n\t{\n\t    semsg(_(e_illegal_character_after_star_str), arg);\n\t    return NULL;\n\t}\n\tpat = arg + 1;\n    }\n    else\n    {\n\tfor (pat = arg; *pat && *pat != '|' && !VIM_ISWHITE(*pat); pat = p)\n\t{\n\t    if ((int)event_name2nr(pat, &p) >= NUM_EVENTS)\n\t    {\n\t\tif (have_group)\n\t\t    semsg(_(e_no_such_event_str), pat);\n\t\telse\n\t\t    semsg(_(e_no_such_group_or_event_str), pat);\n\t\treturn NULL;\n\t    }\n\t}\n    }\n    return pat;\n}\n\n/*\n * Return TRUE if \"event\" is included in 'eventignore'.\n */\n    static int\nevent_ignored(event_T event)\n{\n    char_u\t*p = p_ei;\n\n    while (*p != NUL)\n    {\n\tif (STRNICMP(p, \"all\", 3) == 0 && (p[3] == NUL || p[3] == ','))\n\t    return TRUE;\n\tif (event_name2nr(p, &p) == event)\n\t    return TRUE;\n    }\n\n    return FALSE;\n}\n\n/*\n * Return OK when the contents of p_ei is valid, FAIL otherwise.\n */\n    int\ncheck_ei(void)\n{\n    char_u\t*p = p_ei;\n\n    while (*p)\n    {\n\tif (STRNICMP(p, \"all\", 3) == 0 && (p[3] == NUL || p[3] == ','))\n\t{\n\t    p += 3;\n\t    if (*p == ',')\n\t\t++p;\n\t}\n\telse if (event_name2nr(p, &p) == NUM_EVENTS)\n\t    return FAIL;\n    }\n\n    return OK;\n}\n\n# if defined(FEAT_SYN_HL) || defined(PROTO)\n\n/*\n * Add \"what\" to 'eventignore' to skip loading syntax highlighting for every\n * buffer loaded into the window.  \"what\" must start with a comma.\n * Returns the old value of 'eventignore' in allocated memory.\n */\n    char_u *\nau_event_disable(char *what)\n{\n    char_u\t*new_ei;\n    char_u\t*save_ei;\n\n    save_ei = vim_strsave(p_ei);\n    if (save_ei != NULL)\n    {\n\tnew_ei = vim_strnsave(p_ei, STRLEN(p_ei) + STRLEN(what));\n\tif (new_ei != NULL)\n\t{\n\t    if (*what == ',' && *p_ei == NUL)\n\t\tSTRCPY(new_ei, what + 1);\n\t    else\n\t\tSTRCAT(new_ei, what);\n\t    set_string_option_direct((char_u *)\"ei\", -1, new_ei,\n\t\t\t\t\t\t\t  OPT_FREE, SID_NONE);\n\t    vim_free(new_ei);\n\t}\n    }\n    return save_ei;\n}\n\n    void\nau_event_restore(char_u *old_ei)\n{\n    if (old_ei != NULL)\n    {\n\tset_string_option_direct((char_u *)\"ei\", -1, old_ei,\n\t\t\t\t\t\t\t  OPT_FREE, SID_NONE);\n\tvim_free(old_ei);\n    }\n}\n# endif  // FEAT_SYN_HL\n\n/*\n * do_autocmd() -- implements the :autocmd command.  Can be used in the\n *  following ways:\n *\n * :autocmd <event> <pat> <cmd>\t    Add <cmd> to the list of commands that\n *\t\t\t\t    will be automatically executed for <event>\n *\t\t\t\t    when editing a file matching <pat>, in\n *\t\t\t\t    the current group.\n * :autocmd <event> <pat>\t    Show the autocommands associated with\n *\t\t\t\t    <event> and <pat>.\n * :autocmd <event>\t\t    Show the autocommands associated with\n *\t\t\t\t    <event>.\n * :autocmd\t\t\t    Show all autocommands.\n * :autocmd! <event> <pat> <cmd>    Remove all autocommands associated with\n *\t\t\t\t    <event> and <pat>, and add the command\n *\t\t\t\t    <cmd>, for the current group.\n * :autocmd! <event> <pat>\t    Remove all autocommands associated with\n *\t\t\t\t    <event> and <pat> for the current group.\n * :autocmd! <event>\t\t    Remove all autocommands associated with\n *\t\t\t\t    <event> for the current group.\n * :autocmd!\t\t\t    Remove ALL autocommands for the current\n *\t\t\t\t    group.\n *\n *  Multiple events and patterns may be given separated by commas.  Here are\n *  some examples:\n * :autocmd bufread,bufenter *.c,*.h\tset tw=0 smartindent noic\n * :autocmd bufleave\t     *\t\tset tw=79 nosmartindent ic infercase\n *\n * :autocmd * *.c\t\tshow all autocommands for *.c files.\n *\n * Mostly a {group} argument can optionally appear before <event>.\n * \"eap\" can be NULL.\n */\n    void\ndo_autocmd(exarg_T *eap, char_u *arg_in, int forceit)\n{\n    char_u\t*arg = arg_in;\n    char_u\t*pat;\n    char_u\t*envpat = NULL;\n    char_u\t*cmd;\n    int\t\tcmd_need_free = FALSE;\n    event_T\tevent;\n    char_u\t*tofree = NULL;\n    int\t\tnested = FALSE;\n    int\t\tonce = FALSE;\n    int\t\tgroup;\n    int\t\ti;\n    int\t\tflags = 0;\n\n    if (*arg == '|')\n    {\n\teap->nextcmd = arg + 1;\n\targ = (char_u *)\"\";\n\tgroup = AUGROUP_ALL;\t// no argument, use all groups\n    }\n    else\n    {\n\t/*\n\t * Check for a legal group name.  If not, use AUGROUP_ALL.\n\t */\n\tgroup = au_get_grouparg(&arg);\n\tif (arg == NULL)\t    // out of memory\n\t    return;\n    }\n\n    /*\n     * Scan over the events.\n     * If we find an illegal name, return here, don't do anything.\n     */\n    pat = find_end_event(arg, group != AUGROUP_ALL);\n    if (pat == NULL)\n\treturn;\n\n    pat = skipwhite(pat);\n    if (*pat == '|')\n    {\n\teap->nextcmd = pat + 1;\n\tpat = (char_u *)\"\";\n\tcmd = (char_u *)\"\";\n    }\n    else\n    {\n\t/*\n\t * Scan over the pattern.  Put a NUL at the end.\n\t */\n\tcmd = pat;\n\twhile (*cmd && (!VIM_ISWHITE(*cmd) || cmd[-1] == '\\\\'))\n\t    cmd++;\n\tif (*cmd)\n\t    *cmd++ = NUL;\n\n\t// Expand environment variables in the pattern.  Set 'shellslash', we\n\t// want forward slashes here.\n\tif (vim_strchr(pat, '$') != NULL || vim_strchr(pat, '~') != NULL)\n\t{\n#ifdef BACKSLASH_IN_FILENAME\n\t    int\tp_ssl_save = p_ssl;\n\n\t    p_ssl = TRUE;\n#endif\n\t    envpat = expand_env_save(pat);\n#ifdef BACKSLASH_IN_FILENAME\n\t    p_ssl = p_ssl_save;\n#endif\n\t    if (envpat != NULL)\n\t\tpat = envpat;\n\t}\n\n\tcmd = skipwhite(cmd);\n\tfor (i = 0; i < 2; i++)\n\t{\n\t    if (*cmd != NUL)\n\t    {\n\t\t// Check for \"++once\" flag.\n\t\tif (STRNCMP(cmd, \"++once\", 6) == 0 && VIM_ISWHITE(cmd[6]))\n\t\t{\n\t\t    if (once)\n\t\t\tsemsg(_(e_duplicate_argument_str), \"++once\");\n\t\t    once = TRUE;\n\t\t    cmd = skipwhite(cmd + 6);\n\t\t}\n\n\t\t// Check for \"++nested\" flag.\n\t\tif ((STRNCMP(cmd, \"++nested\", 8) == 0 && VIM_ISWHITE(cmd[8])))\n\t\t{\n\t\t    if (nested)\n\t\t    {\n\t\t\tsemsg(_(e_duplicate_argument_str), \"++nested\");\n\t\t\treturn;\n\t\t    }\n\t\t    nested = TRUE;\n\t\t    cmd = skipwhite(cmd + 8);\n\t\t}\n\n\t\t// Check for the old \"nested\" flag in legacy script.\n\t\tif (STRNCMP(cmd, \"nested\", 6) == 0 && VIM_ISWHITE(cmd[6]))\n\t\t{\n\t\t    if (in_vim9script())\n\t\t    {\n\t\t\t// If there ever is a :nested command this error should\n\t\t\t// be removed and \"nested\" accepted as the start of the\n\t\t\t// command.\n\t\t\temsg(_(e_invalid_command_nested_did_you_mean_plusplus_nested));\n\t\t\treturn;\n\t\t    }\n\t\t    if (nested)\n\t\t    {\n\t\t\tsemsg(_(e_duplicate_argument_str), \"nested\");\n\t\t\treturn;\n\t\t    }\n\t\t    nested = TRUE;\n\t\t    cmd = skipwhite(cmd + 6);\n\t\t}\n\t    }\n\t}\n\n\t/*\n\t * Find the start of the commands.\n\t * Expand <sfile> in it.\n\t */\n\tif (*cmd != NUL)\n\t{\n\t    if (eap != NULL)\n\t\t// Read a {} block if it follows.\n\t\tcmd = may_get_cmd_block(eap, cmd, &tofree, &flags);\n\n\t    cmd = expand_sfile(cmd);\n\t    if (cmd == NULL)\t    // some error\n\t\treturn;\n\t    cmd_need_free = TRUE;\n\t}\n    }\n\n    /*\n     * Print header when showing autocommands.\n     */\n    if (!forceit && *cmd == NUL)\n\t// Highlight title\n\tmsg_puts_title(_(\"\\n--- Autocommands ---\"));\n\n    /*\n     * Loop over the events.\n     */\n    last_event = (event_T)-1;\t\t// for listing the event name\n    last_group = AUGROUP_ERROR;\t\t// for listing the group name\n    if (*arg == '*' || *arg == NUL || *arg == '|')\n    {\n\tif (*cmd != NUL)\n\t    emsg(_(e_cannot_define_autocommands_for_all_events));\n\telse\n\t    for (event = (event_T)0; (int)event < NUM_EVENTS;\n\t\t\t\t\t     event = (event_T)((int)event + 1))\n\t\tif (do_autocmd_event(event, pat,\n\t\t\t     once, nested, cmd, forceit, group, flags) == FAIL)\n\t\t    break;\n    }\n    else\n    {\n\twhile (*arg && *arg != '|' && !VIM_ISWHITE(*arg))\n\t    if (do_autocmd_event(event_name2nr(arg, &arg), pat,\n\t\t\t  once, nested,\tcmd, forceit, group, flags) == FAIL)\n\t\tbreak;\n    }\n\n    if (cmd_need_free)\n\tvim_free(cmd);\n    vim_free(tofree);\n    vim_free(envpat);\n}\n\n/*\n * Find the group ID in a \":autocmd\" or \":doautocmd\" argument.\n * The \"argp\" argument is advanced to the following argument.\n *\n * Returns the group ID, AUGROUP_ERROR for error (out of memory).\n */\n    static int\nau_get_grouparg(char_u **argp)\n{\n    char_u\t*group_name;\n    char_u\t*p;\n    char_u\t*arg = *argp;\n    int\t\tgroup = AUGROUP_ALL;\n\n    for (p = arg; *p && !VIM_ISWHITE(*p) && *p != '|'; ++p)\n\t;\n    if (p > arg)\n    {\n\tgroup_name = vim_strnsave(arg, p - arg);\n\tif (group_name == NULL)\t\t// out of memory\n\t    return AUGROUP_ERROR;\n\tgroup = au_find_group(group_name);\n\tif (group == AUGROUP_ERROR)\n\t    group = AUGROUP_ALL;\t// no match, use all groups\n\telse\n\t    *argp = skipwhite(p);\t// match, skip over group name\n\tvim_free(group_name);\n    }\n    return group;\n}\n\n/*\n * do_autocmd() for one event.\n * If *pat == NUL do for all patterns.\n * If *cmd == NUL show entries.\n * If forceit == TRUE delete entries.\n * If group is not AUGROUP_ALL, only use this group.\n */\n    static int\ndo_autocmd_event(\n    event_T\tevent,\n    char_u\t*pat,\n    int\t\tonce,\n    int\t\tnested,\n    char_u\t*cmd,\n    int\t\tforceit,\n    int\t\tgroup,\n    int\t\tflags)\n{\n    AutoPat\t*ap;\n    AutoPat\t**prev_ap;\n    AutoCmd\t*ac;\n    AutoCmd\t**prev_ac;\n    int\t\tbrace_level;\n    char_u\t*endpat;\n    int\t\tfindgroup;\n    int\t\tallgroups;\n    int\t\tpatlen;\n    int\t\tis_buflocal;\n    int\t\tbuflocal_nr;\n    char_u\tbuflocal_pat[25];\t// for \"<buffer=X>\"\n\n    if (group == AUGROUP_ALL)\n\tfindgroup = current_augroup;\n    else\n\tfindgroup = group;\n    allgroups = (group == AUGROUP_ALL && !forceit && *cmd == NUL);\n\n    /*\n     * Show or delete all patterns for an event.\n     */\n    if (*pat == NUL)\n    {\n\tFOR_ALL_AUTOCMD_PATTERNS(event, ap)\n\t{\n\t    if (forceit)  // delete the AutoPat, if it's in the current group\n\t    {\n\t\tif (ap->group == findgroup)\n\t\t    au_remove_pat(ap);\n\t    }\n\t    else if (group == AUGROUP_ALL || ap->group == group)\n\t\tshow_autocmd(ap, event);\n\t}\n    }\n\n    /*\n     * Loop through all the specified patterns.\n     */\n    for ( ; *pat; pat = (*endpat == ',' ? endpat + 1 : endpat))\n    {\n\t/*\n\t * Find end of the pattern.\n\t * Watch out for a comma in braces, like \"*.\\{obj,o\\}\".\n\t */\n\tbrace_level = 0;\n\tfor (endpat = pat; *endpat && (*endpat != ',' || brace_level\n\t\t\t   || (endpat > pat && endpat[-1] == '\\\\')); ++endpat)\n\t{\n\t    if (*endpat == '{')\n\t\tbrace_level++;\n\t    else if (*endpat == '}')\n\t\tbrace_level--;\n\t}\n\tif (pat == endpat)\t\t// ignore single comma\n\t    continue;\n\tpatlen = (int)(endpat - pat);\n\n\t/*\n\t * detect special <buflocal[=X]> buffer-local patterns\n\t */\n\tis_buflocal = FALSE;\n\tbuflocal_nr = 0;\n\n\tif (patlen >= 8 && STRNCMP(pat, \"<buffer\", 7) == 0\n\t\t\t\t\t\t    && pat[patlen - 1] == '>')\n\t{\n\t    // \"<buffer...>\": Error will be printed only for addition.\n\t    // printing and removing will proceed silently.\n\t    is_buflocal = TRUE;\n\t    if (patlen == 8)\n\t\t// \"<buffer>\"\n\t\tbuflocal_nr = curbuf->b_fnum;\n\t    else if (patlen > 9 && pat[7] == '=')\n\t    {\n\t\tif (patlen == 13 && STRNICMP(pat, \"<buffer=abuf>\", 13) == 0)\n\t\t    // \"<buffer=abuf>\"\n\t\t    buflocal_nr = autocmd_bufnr;\n\t\telse if (skipdigits(pat + 8) == pat + patlen - 1)\n\t\t    // \"<buffer=123>\"\n\t\t    buflocal_nr = atoi((char *)pat + 8);\n\t    }\n\t}\n\n\tif (is_buflocal)\n\t{\n\t    // normalize pat into standard \"<buffer>#N\" form\n\t    sprintf((char *)buflocal_pat, \"<buffer=%d>\", buflocal_nr);\n\t    pat = buflocal_pat;\t\t\t// can modify pat and patlen\n\t    patlen = (int)STRLEN(buflocal_pat);\t//   but not endpat\n\t}\n\n\t/*\n\t * Find AutoPat entries with this pattern.  When adding a command it\n\t * always goes at or after the last one, so start at the end.\n\t */\n\tif (!forceit && *cmd != NUL && last_autopat[(int)event] != NULL)\n\t    prev_ap = &last_autopat[(int)event];\n\telse\n\t    prev_ap = &first_autopat[(int)event];\n\twhile ((ap = *prev_ap) != NULL)\n\t{\n\t    if (ap->pat != NULL)\n\t    {\n\t\t/*\n\t\t * Accept a pattern when:\n\t\t * - a group was specified and it's that group, or a group was\n\t\t *   not specified and it's the current group, or a group was\n\t\t *   not specified and we are listing\n\t\t * - the length of the pattern matches\n\t\t * - the pattern matches.\n\t\t * For <buffer[=X]>, this condition works because we normalize\n\t\t * all buffer-local patterns.\n\t\t */\n\t\tif ((allgroups || ap->group == findgroup)\n\t\t\t&& ap->patlen == patlen\n\t\t\t&& STRNCMP(pat, ap->pat, patlen) == 0)\n\t\t{\n\t\t    /*\n\t\t     * Remove existing autocommands.\n\t\t     * If adding any new autocmd's for this AutoPat, don't\n\t\t     * delete the pattern from the autopat list, append to\n\t\t     * this list.\n\t\t     */\n\t\t    if (forceit)\n\t\t    {\n\t\t\tif (*cmd != NUL && ap->next == NULL)\n\t\t\t{\n\t\t\t    au_remove_cmds(ap);\n\t\t\t    break;\n\t\t\t}\n\t\t\tau_remove_pat(ap);\n\t\t    }\n\n\t\t    /*\n\t\t     * Show autocmd's for this autopat, or buflocals <buffer=X>\n\t\t     */\n\t\t    else if (*cmd == NUL)\n\t\t\tshow_autocmd(ap, event);\n\n\t\t    /*\n\t\t     * Add autocmd to this autopat, if it's the last one.\n\t\t     */\n\t\t    else if (ap->next == NULL)\n\t\t\tbreak;\n\t\t}\n\t    }\n\t    prev_ap = &ap->next;\n\t}\n\n\t/*\n\t * Add a new command.\n\t */\n\tif (*cmd != NUL)\n\t{\n\t    /*\n\t     * If the pattern we want to add a command to does appear at the\n\t     * end of the list (or not is not in the list at all), add the\n\t     * pattern at the end of the list.\n\t     */\n\t    if (ap == NULL)\n\t    {\n\t\t// refuse to add buffer-local ap if buffer number is invalid\n\t\tif (is_buflocal && (buflocal_nr == 0\n\t\t\t\t      || buflist_findnr(buflocal_nr) == NULL))\n\t\t{\n\t\t    semsg(_(e_buffer_nr_invalid_buffer_number), buflocal_nr);\n\t\t    return FAIL;\n\t\t}\n\n\t\tap = ALLOC_ONE(AutoPat);\n\t\tif (ap == NULL)\n\t\t    return FAIL;\n\t\tap->pat = vim_strnsave(pat, patlen);\n\t\tap->patlen = patlen;\n\t\tif (ap->pat == NULL)\n\t\t{\n\t\t    vim_free(ap);\n\t\t    return FAIL;\n\t\t}\n\n#ifdef FEAT_EVAL\n\t\t// need to initialize last_mode for the first ModeChanged\n\t\t// autocmd\n\t\tif (event == EVENT_MODECHANGED && !has_modechanged())\n\t\t    get_mode(last_mode);\n#endif\n\t\t// Initialize the fields checked by the WinScrolled trigger to\n\t\t// stop it from firing right after the first autocmd is defined.\n\t\tif (event == EVENT_WINSCROLLED && !has_winscrolled())\n\t\t{\n\t\t    curwin->w_last_topline = curwin->w_topline;\n\t\t    curwin->w_last_leftcol = curwin->w_leftcol;\n\t\t    curwin->w_last_width = curwin->w_width;\n\t\t    curwin->w_last_height = curwin->w_height;\n\t\t}\n\n\t\tif (is_buflocal)\n\t\t{\n\t\t    ap->buflocal_nr = buflocal_nr;\n\t\t    ap->reg_prog = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t    char_u\t*reg_pat;\n\n\t\t    ap->buflocal_nr = 0;\n\t\t    reg_pat = file_pat_to_reg_pat(pat, endpat,\n\t\t\t\t\t\t\t &ap->allow_dirs, TRUE);\n\t\t    if (reg_pat != NULL)\n\t\t\tap->reg_prog = vim_regcomp(reg_pat, RE_MAGIC);\n\t\t    vim_free(reg_pat);\n\t\t    if (reg_pat == NULL || ap->reg_prog == NULL)\n\t\t    {\n\t\t\tvim_free(ap->pat);\n\t\t\tvim_free(ap);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t}\n\t\tap->cmds = NULL;\n\t\t*prev_ap = ap;\n\t\tlast_autopat[(int)event] = ap;\n\t\tap->next = NULL;\n\t\tif (group == AUGROUP_ALL)\n\t\t    ap->group = current_augroup;\n\t\telse\n\t\t    ap->group = group;\n\t    }\n\n\t    /*\n\t     * Add the autocmd at the end of the AutoCmd list.\n\t     */\n\t    prev_ac = &(ap->cmds);\n\t    while ((ac = *prev_ac) != NULL)\n\t\tprev_ac = &ac->next;\n\t    ac = ALLOC_ONE(AutoCmd);\n\t    if (ac == NULL)\n\t\treturn FAIL;\n\t    ac->cmd = vim_strsave(cmd);\n\t    ac->script_ctx = current_sctx;\n\t    if (flags & UC_VIM9)\n\t\tac->script_ctx.sc_version = SCRIPT_VERSION_VIM9;\n#ifdef FEAT_EVAL\n\t    ac->script_ctx.sc_lnum += SOURCING_LNUM;\n#endif\n\t    if (ac->cmd == NULL)\n\t    {\n\t\tvim_free(ac);\n\t\treturn FAIL;\n\t    }\n\t    ac->next = NULL;\n\t    *prev_ac = ac;\n\t    ac->once = once;\n\t    ac->nested = nested;\n\t}\n    }\n\n    au_cleanup();\t// may really delete removed patterns/commands now\n    return OK;\n}\n\n/*\n * Implementation of \":doautocmd [group] event [fname]\".\n * Return OK for success, FAIL for failure;\n */\n    int\ndo_doautocmd(\n    char_u\t*arg_start,\n    int\t\tdo_msg,\t    // give message for no matching autocmds?\n    int\t\t*did_something)\n{\n    char_u\t*arg = arg_start;\n    char_u\t*fname;\n    int\t\tnothing_done = TRUE;\n    int\t\tgroup;\n\n    if (did_something != NULL)\n\t*did_something = FALSE;\n\n    /*\n     * Check for a legal group name.  If not, use AUGROUP_ALL.\n     */\n    group = au_get_grouparg(&arg);\n    if (arg == NULL)\t    // out of memory\n\treturn FAIL;\n\n    if (*arg == '*')\n    {\n\temsg(_(e_cant_execute_autocommands_for_all_events));\n\treturn FAIL;\n    }\n\n    /*\n     * Scan over the events.\n     * If we find an illegal name, return here, don't do anything.\n     */\n    fname = find_end_event(arg, group != AUGROUP_ALL);\n    if (fname == NULL)\n\treturn FAIL;\n\n    fname = skipwhite(fname);\n\n    /*\n     * Loop over the events.\n     */\n    while (*arg && !ends_excmd(*arg) && !VIM_ISWHITE(*arg))\n\tif (apply_autocmds_group(event_name2nr(arg, &arg),\n\t\t\t\t      fname, NULL, TRUE, group, curbuf, NULL))\n\t    nothing_done = FALSE;\n\n    if (nothing_done && do_msg\n#ifdef FEAT_EVAL\n\t\t&& !aborting()\n#endif\n\t       )\n\tsmsg(_(\"No matching autocommands: %s\"), arg_start);\n    if (did_something != NULL)\n\t*did_something = !nothing_done;\n\n#ifdef FEAT_EVAL\n    return aborting() ? FAIL : OK;\n#else\n    return OK;\n#endif\n}\n\n/*\n * \":doautoall\": execute autocommands for each loaded buffer.\n */\n    void\nex_doautoall(exarg_T *eap)\n{\n    int\t\tretval = OK;\n    aco_save_T\taco;\n    buf_T\t*buf;\n    bufref_T\tbufref;\n    char_u\t*arg = eap->arg;\n    int\t\tcall_do_modelines = check_nomodeline(&arg);\n    int\t\tdid_aucmd;\n\n    /*\n     * This is a bit tricky: For some commands curwin->w_buffer needs to be\n     * equal to curbuf, but for some buffers there may not be a window.\n     * So we change the buffer for the current window for a moment.  This\n     * gives problems when the autocommands make changes to the list of\n     * buffers or windows...\n     */\n    FOR_ALL_BUFFERS(buf)\n    {\n\t// Only do loaded buffers and skip the current buffer, it's done last.\n\tif (buf->b_ml.ml_mfp != NULL && buf != curbuf)\n\t{\n\t    // find a window for this buffer and save some values\n\t    aucmd_prepbuf(&aco, buf);\n\t    set_bufref(&bufref, buf);\n\n\t    // execute the autocommands for this buffer\n\t    retval = do_doautocmd(arg, FALSE, &did_aucmd);\n\n\t    if (call_do_modelines && did_aucmd)\n\t\t// Execute the modeline settings, but don't set window-local\n\t\t// options if we are using the current window for another\n\t\t// buffer.\n\t\tdo_modelines(curwin == aucmd_win ? OPT_NOWIN : 0);\n\n\t    // restore the current window\n\t    aucmd_restbuf(&aco);\n\n\t    // stop if there is some error or buffer was deleted\n\t    if (retval == FAIL || !bufref_valid(&bufref))\n\t    {\n\t\tretval = FAIL;\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    // Execute autocommands for the current buffer last.\n    if (retval == OK)\n    {\n\tdo_doautocmd(arg, FALSE, &did_aucmd);\n\tif (call_do_modelines && did_aucmd)\n\t    do_modelines(0);\n    }\n}\n\n/*\n * Check *argp for <nomodeline>.  When it is present return FALSE, otherwise\n * return TRUE and advance *argp to after it.\n * Thus return TRUE when do_modelines() should be called.\n */\n    int\ncheck_nomodeline(char_u **argp)\n{\n    if (STRNCMP(*argp, \"<nomodeline>\", 12) == 0)\n    {\n\t*argp = skipwhite(*argp + 12);\n\treturn FALSE;\n    }\n    return TRUE;\n}\n\n/*\n * Prepare for executing autocommands for (hidden) buffer \"buf\".\n * Search for a visible window containing the current buffer.  If there isn't\n * one then use \"aucmd_win\".\n * Set \"curbuf\" and \"curwin\" to match \"buf\".\n */\n    void\naucmd_prepbuf(\n    aco_save_T\t*aco,\t\t// structure to save values in\n    buf_T\t*buf)\t\t// new curbuf\n{\n    win_T\t*win;\n    int\t\tsave_ea;\n#ifdef FEAT_AUTOCHDIR\n    int\t\tsave_acd;\n#endif\n\n    // Find a window that is for the new buffer\n    if (buf == curbuf)\t\t// be quick when buf is curbuf\n\twin = curwin;\n    else\n\tFOR_ALL_WINDOWS(win)\n\t    if (win->w_buffer == buf)\n\t\tbreak;\n\n    // Allocate \"aucmd_win\" when needed.  If this fails (out of memory) fall\n    // back to using the current window.\n    if (win == NULL && aucmd_win == NULL)\n    {\n\taucmd_win = win_alloc_popup_win();\n\tif (aucmd_win == NULL)\n\t    win = curwin;\n    }\n    if (win == NULL && aucmd_win_used)\n\t// Strange recursive autocommand, fall back to using the current\n\t// window.  Expect a few side effects...\n\twin = curwin;\n\n    aco->save_curwin_id = curwin->w_id;\n    aco->save_curbuf = curbuf;\n    aco->save_prevwin_id = prevwin == NULL ? 0 : prevwin->w_id;\n    if (win != NULL)\n    {\n\t// There is a window for \"buf\" in the current tab page, make it the\n\t// curwin.  This is preferred, it has the least side effects (esp. if\n\t// \"buf\" is curbuf).\n\taco->use_aucmd_win = FALSE;\n\tcurwin = win;\n    }\n    else\n    {\n\t// There is no window for \"buf\", use \"aucmd_win\".  To minimize the side\n\t// effects, insert it in the current tab page.\n\t// Anything related to a window (e.g., setting folds) may have\n\t// unexpected results.\n\taco->use_aucmd_win = TRUE;\n\taucmd_win_used = TRUE;\n\n\twin_init_popup_win(aucmd_win, buf);\n\n\taco->globaldir = globaldir;\n\tglobaldir = NULL;\n\n\t// Split the current window, put the aucmd_win in the upper half.\n\t// We don't want the BufEnter or WinEnter autocommands.\n\tblock_autocmds();\n\tmake_snapshot(SNAP_AUCMD_IDX);\n\tsave_ea = p_ea;\n\tp_ea = FALSE;\n\n#ifdef FEAT_AUTOCHDIR\n\t// Prevent chdir() call in win_enter_ext(), through do_autochdir().\n\tsave_acd = p_acd;\n\tp_acd = FALSE;\n#endif\n\n\t// no redrawing and don't set the window title\n\t++RedrawingDisabled;\n\t(void)win_split_ins(0, WSP_TOP, aucmd_win, 0);\n\t--RedrawingDisabled;\n\t(void)win_comp_pos();   // recompute window positions\n\tp_ea = save_ea;\n#ifdef FEAT_AUTOCHDIR\n\tp_acd = save_acd;\n#endif\n\tunblock_autocmds();\n\tcurwin = aucmd_win;\n    }\n    curbuf = buf;\n    aco->new_curwin_id = curwin->w_id;\n    set_bufref(&aco->new_curbuf, curbuf);\n\n    // disable the Visual area, the position may be invalid in another buffer\n    aco->save_VIsual_active = VIsual_active;\n    VIsual_active = FALSE;\n}\n\n/*\n * Cleanup after executing autocommands for a (hidden) buffer.\n * Restore the window as it was (if possible).\n */\n    void\naucmd_restbuf(\n    aco_save_T\t*aco)\t\t// structure holding saved values\n{\n    int\t    dummy;\n    win_T   *save_curwin;\n\n    if (aco->use_aucmd_win)\n    {\n\t--curbuf->b_nwindows;\n\t// Find \"aucmd_win\", it can't be closed, but it may be in another tab\n\t// page. Do not trigger autocommands here.\n\tblock_autocmds();\n\tif (curwin != aucmd_win)\n\t{\n\t    tabpage_T\t*tp;\n\t    win_T\t*wp;\n\n\t    FOR_ALL_TAB_WINDOWS(tp, wp)\n\t    {\n\t\tif (wp == aucmd_win)\n\t\t{\n\t\t    if (tp != curtab)\n\t\t\tgoto_tabpage_tp(tp, TRUE, TRUE);\n\t\t    win_goto(aucmd_win);\n\t\t    goto win_found;\n\t\t}\n\t    }\n\t}\nwin_found:\n\n\t// Remove the window and frame from the tree of frames.\n\t(void)winframe_remove(curwin, &dummy, NULL);\n\twin_remove(curwin, NULL);\n\taucmd_win_used = FALSE;\n\tlast_status(FALSE);\t    // may need to remove last status line\n\n\tif (!valid_tabpage_win(curtab))\n\t    // no valid window in current tabpage\n\t    close_tabpage(curtab);\n\n\trestore_snapshot(SNAP_AUCMD_IDX, FALSE);\n\t(void)win_comp_pos();   // recompute window positions\n\tunblock_autocmds();\n\n\tsave_curwin = win_find_by_id(aco->save_curwin_id);\n\tif (save_curwin != NULL)\n\t    curwin = save_curwin;\n\telse\n\t    // Hmm, original window disappeared.  Just use the first one.\n\t    curwin = firstwin;\n\tcurbuf = curwin->w_buffer;\n#ifdef FEAT_JOB_CHANNEL\n\t// May need to restore insert mode for a prompt buffer.\n\tentering_window(curwin);\n#endif\n\tprevwin = win_find_by_id(aco->save_prevwin_id);\n#ifdef FEAT_EVAL\n\tvars_clear(&aucmd_win->w_vars->dv_hashtab);  // free all w: variables\n\thash_init(&aucmd_win->w_vars->dv_hashtab);   // re-use the hashtab\n#endif\n\tvim_free(globaldir);\n\tglobaldir = aco->globaldir;\n\n\t// the buffer contents may have changed\n\tcheck_cursor();\n\tif (curwin->w_topline > curbuf->b_ml.ml_line_count)\n\t{\n\t    curwin->w_topline = curbuf->b_ml.ml_line_count;\n#ifdef FEAT_DIFF\n\t    curwin->w_topfill = 0;\n#endif\n\t}\n#if defined(FEAT_GUI)\n\tif (gui.in_use)\n\t{\n\t    // Hide the scrollbars from the aucmd_win and update.\n\t    gui_mch_enable_scrollbar(\n\t\t\t\t   &aucmd_win->w_scrollbars[SBAR_LEFT], FALSE);\n\t    gui_mch_enable_scrollbar(\n\t\t\t\t  &aucmd_win->w_scrollbars[SBAR_RIGHT], FALSE);\n\t    gui_may_update_scrollbars();\n\t}\n#endif\n    }\n    else\n    {\n\t// Restore curwin.  Use the window ID, a window may have been closed\n\t// and the memory re-used for another one.\n\tsave_curwin = win_find_by_id(aco->save_curwin_id);\n\tif (save_curwin != NULL)\n\t{\n\t    // Restore the buffer which was previously edited by curwin, if\n\t    // it was changed, we are still the same window and the buffer is\n\t    // valid.\n\t    if (curwin->w_id == aco->new_curwin_id\n\t\t    && curbuf != aco->new_curbuf.br_buf\n\t\t    && bufref_valid(&aco->new_curbuf)\n\t\t    && aco->new_curbuf.br_buf->b_ml.ml_mfp != NULL)\n\t    {\n# if defined(FEAT_SYN_HL) || defined(FEAT_SPELL)\n\t\tif (curwin->w_s == &curbuf->b_s)\n\t\t    curwin->w_s = &aco->new_curbuf.br_buf->b_s;\n# endif\n\t\t--curbuf->b_nwindows;\n\t\tcurbuf = aco->new_curbuf.br_buf;\n\t\tcurwin->w_buffer = curbuf;\n\t\t++curbuf->b_nwindows;\n\t    }\n\n\t    curwin = save_curwin;\n\t    curbuf = curwin->w_buffer;\n\t    prevwin = win_find_by_id(aco->save_prevwin_id);\n\t    // In case the autocommand moves the cursor to a position that\n\t    // does not exist in curbuf.\n\t    check_cursor();\n\t}\n    }\n\n    check_cursor();\t    // just in case lines got deleted\n    VIsual_active = aco->save_VIsual_active;\n    if (VIsual_active)\n\tcheck_pos(curbuf, &VIsual);\n}\n\nstatic int\tautocmd_nested = FALSE;\n\n/*\n * Execute autocommands for \"event\" and file name \"fname\".\n * Return TRUE if some commands were executed.\n */\n    int\napply_autocmds(\n    event_T\tevent,\n    char_u\t*fname,\t    // NULL or empty means use actual file name\n    char_u\t*fname_io,  // fname to use for <afile> on cmdline\n    int\t\tforce,\t    // when TRUE, ignore autocmd_busy\n    buf_T\t*buf)\t    // buffer for <abuf>\n{\n    return apply_autocmds_group(event, fname, fname_io, force,\n\t\t\t\t\t\t      AUGROUP_ALL, buf, NULL);\n}\n\n/*\n * Like apply_autocmds(), but with extra \"eap\" argument.  This takes care of\n * setting v:filearg.\n */\n    int\napply_autocmds_exarg(\n    event_T\tevent,\n    char_u\t*fname,\n    char_u\t*fname_io,\n    int\t\tforce,\n    buf_T\t*buf,\n    exarg_T\t*eap)\n{\n    return apply_autocmds_group(event, fname, fname_io, force,\n\t\t\t\t\t\t       AUGROUP_ALL, buf, eap);\n}\n\n/*\n * Like apply_autocmds(), but handles the caller's retval.  If the script\n * processing is being aborted or if retval is FAIL when inside a try\n * conditional, no autocommands are executed.  If otherwise the autocommands\n * cause the script to be aborted, retval is set to FAIL.\n */\n    int\napply_autocmds_retval(\n    event_T\tevent,\n    char_u\t*fname,\t    // NULL or empty means use actual file name\n    char_u\t*fname_io,  // fname to use for <afile> on cmdline\n    int\t\tforce,\t    // when TRUE, ignore autocmd_busy\n    buf_T\t*buf,\t    // buffer for <abuf>\n    int\t\t*retval)    // pointer to caller's retval\n{\n    int\t\tdid_cmd;\n\n#ifdef FEAT_EVAL\n    if (should_abort(*retval))\n\treturn FALSE;\n#endif\n\n    did_cmd = apply_autocmds_group(event, fname, fname_io, force,\n\t\t\t\t\t\t      AUGROUP_ALL, buf, NULL);\n    if (did_cmd\n#ifdef FEAT_EVAL\n\t    && aborting()\n#endif\n\t    )\n\t*retval = FAIL;\n    return did_cmd;\n}\n\n/*\n * Return TRUE when there is a CursorHold autocommand defined.\n */\n    static int\nhas_cursorhold(void)\n{\n    return (first_autopat[(int)(get_real_state() == MODE_NORMAL_BUSY\n\t\t\t    ? EVENT_CURSORHOLD : EVENT_CURSORHOLDI)] != NULL);\n}\n\n/*\n * Return TRUE if the CursorHold event can be triggered.\n */\n    int\ntrigger_cursorhold(void)\n{\n    int\t\tstate;\n\n    if (!did_cursorhold\n\t    && has_cursorhold()\n\t    && reg_recording == 0\n\t    && typebuf.tb_len == 0\n\t    && !ins_compl_active())\n    {\n\tstate = get_real_state();\n\tif (state == MODE_NORMAL_BUSY || (state & MODE_INSERT) != 0)\n\t    return TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Return TRUE when there is a WinScrolled autocommand defined.\n */\n    int\nhas_winscrolled(void)\n{\n    return (first_autopat[(int)EVENT_WINSCROLLED] != NULL);\n}\n\n/*\n * Return TRUE when there is a CursorMoved autocommand defined.\n */\n    int\nhas_cursormoved(void)\n{\n    return (first_autopat[(int)EVENT_CURSORMOVED] != NULL);\n}\n\n/*\n * Return TRUE when there is a CursorMovedI autocommand defined.\n */\n    int\nhas_cursormovedI(void)\n{\n    return (first_autopat[(int)EVENT_CURSORMOVEDI] != NULL);\n}\n\n/*\n * Return TRUE when there is a TextChanged autocommand defined.\n */\n    int\nhas_textchanged(void)\n{\n    return (first_autopat[(int)EVENT_TEXTCHANGED] != NULL);\n}\n\n/*\n * Return TRUE when there is a TextChangedI autocommand defined.\n */\n    int\nhas_textchangedI(void)\n{\n    return (first_autopat[(int)EVENT_TEXTCHANGEDI] != NULL);\n}\n\n/*\n * Return TRUE when there is a TextChangedP autocommand defined.\n */\n    int\nhas_textchangedP(void)\n{\n    return (first_autopat[(int)EVENT_TEXTCHANGEDP] != NULL);\n}\n\n/*\n * Return TRUE when there is an InsertCharPre autocommand defined.\n */\n    int\nhas_insertcharpre(void)\n{\n    return (first_autopat[(int)EVENT_INSERTCHARPRE] != NULL);\n}\n\n/*\n * Return TRUE when there is an CmdUndefined autocommand defined.\n */\n    int\nhas_cmdundefined(void)\n{\n    return (first_autopat[(int)EVENT_CMDUNDEFINED] != NULL);\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE when there is a TextYankPost autocommand defined.\n */\n    int\nhas_textyankpost(void)\n{\n    return (first_autopat[(int)EVENT_TEXTYANKPOST] != NULL);\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE when there is a CompleteChanged autocommand defined.\n */\n    int\nhas_completechanged(void)\n{\n    return (first_autopat[(int)EVENT_COMPLETECHANGED] != NULL);\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE when there is a ModeChanged autocommand defined.\n */\n    int\nhas_modechanged(void)\n{\n    return (first_autopat[(int)EVENT_MODECHANGED] != NULL);\n}\n#endif\n\n/*\n * Execute autocommands for \"event\" and file name \"fname\".\n * Return TRUE if some commands were executed.\n */\n    static int\napply_autocmds_group(\n    event_T\tevent,\n    char_u\t*fname,\t     // NULL or empty means use actual file name\n    char_u\t*fname_io,   // fname to use for <afile> on cmdline, NULL means\n\t\t\t     // use fname\n    int\t\tforce,\t     // when TRUE, ignore autocmd_busy\n    int\t\tgroup,\t     // group ID, or AUGROUP_ALL\n    buf_T\t*buf,\t     // buffer for <abuf>\n    exarg_T\t*eap UNUSED) // command arguments\n{\n    char_u\t*sfname = NULL;\t// short file name\n    char_u\t*tail;\n    int\t\tsave_changed;\n    buf_T\t*old_curbuf;\n    int\t\tretval = FALSE;\n    char_u\t*save_autocmd_fname;\n    int\t\tsave_autocmd_fname_full;\n    int\t\tsave_autocmd_bufnr;\n    char_u\t*save_autocmd_match;\n    int\t\tsave_autocmd_busy;\n    int\t\tsave_autocmd_nested;\n    static int\tnesting = 0;\n    AutoPatCmd_T patcmd;\n    AutoPat\t*ap;\n    sctx_T\tsave_current_sctx;\n#ifdef FEAT_EVAL\n    funccal_entry_T funccal_entry;\n    char_u\t*save_cmdarg;\n    long\tsave_cmdbang;\n#endif\n    static int\tfilechangeshell_busy = FALSE;\n#ifdef FEAT_PROFILE\n    proftime_T\twait_time;\n#endif\n    int\t\tdid_save_redobuff = FALSE;\n    save_redo_T\tsave_redo;\n    int\t\tsave_KeyTyped = KeyTyped;\n    int\t\tsave_did_emsg;\n    ESTACK_CHECK_DECLARATION\n\n    /*\n     * Quickly return if there are no autocommands for this event or\n     * autocommands are blocked.\n     */\n    if (event == NUM_EVENTS || first_autopat[(int)event] == NULL\n\t    || autocmd_blocked > 0)\n\tgoto BYPASS_AU;\n\n    /*\n     * When autocommands are busy, new autocommands are only executed when\n     * explicitly enabled with the \"nested\" flag.\n     */\n    if (autocmd_busy && !(force || autocmd_nested))\n\tgoto BYPASS_AU;\n\n#ifdef FEAT_EVAL\n    /*\n     * Quickly return when immediately aborting on error, or when an interrupt\n     * occurred or an exception was thrown but not caught.\n     */\n    if (aborting())\n\tgoto BYPASS_AU;\n#endif\n\n    /*\n     * FileChangedShell never nests, because it can create an endless loop.\n     */\n    if (filechangeshell_busy && (event == EVENT_FILECHANGEDSHELL\n\t\t\t\t      || event == EVENT_FILECHANGEDSHELLPOST))\n\tgoto BYPASS_AU;\n\n    /*\n     * Ignore events in 'eventignore'.\n     */\n    if (event_ignored(event))\n\tgoto BYPASS_AU;\n\n    /*\n     * Allow nesting of autocommands, but restrict the depth, because it's\n     * possible to create an endless loop.\n     */\n    if (nesting == 10)\n    {\n\temsg(_(e_autocommand_nesting_too_deep));\n\tgoto BYPASS_AU;\n    }\n\n    /*\n     * Check if these autocommands are disabled.  Used when doing \":all\" or\n     * \":ball\".\n     */\n    if (       (autocmd_no_enter\n\t\t&& (event == EVENT_WINENTER || event == EVENT_BUFENTER))\n\t    || (autocmd_no_leave\n\t\t&& (event == EVENT_WINLEAVE || event == EVENT_BUFLEAVE)))\n\tgoto BYPASS_AU;\n\n    /*\n     * Save the autocmd_* variables and info about the current buffer.\n     */\n    save_autocmd_fname = autocmd_fname;\n    save_autocmd_fname_full = autocmd_fname_full;\n    save_autocmd_bufnr = autocmd_bufnr;\n    save_autocmd_match = autocmd_match;\n    save_autocmd_busy = autocmd_busy;\n    save_autocmd_nested = autocmd_nested;\n    save_changed = curbuf->b_changed;\n    old_curbuf = curbuf;\n\n    /*\n     * Set the file name to be used for <afile>.\n     * Make a copy to avoid that changing a buffer name or directory makes it\n     * invalid.\n     */\n    if (fname_io == NULL)\n    {\n\tif (event == EVENT_COLORSCHEME || event == EVENT_COLORSCHEMEPRE\n\t\t\t\t\t\t   || event == EVENT_OPTIONSET\n\t\t\t\t\t\t   || event == EVENT_MODECHANGED)\n\t    autocmd_fname = NULL;\n\telse if (fname != NULL && !ends_excmd(*fname))\n\t    autocmd_fname = fname;\n\telse if (buf != NULL)\n\t    autocmd_fname = buf->b_ffname;\n\telse\n\t    autocmd_fname = NULL;\n    }\n    else\n\tautocmd_fname = fname_io;\n    if (autocmd_fname != NULL)\n\tautocmd_fname = vim_strsave(autocmd_fname);\n    autocmd_fname_full = FALSE; // call FullName_save() later\n\n    /*\n     * Set the buffer number to be used for <abuf>.\n     */\n    if (buf == NULL)\n\tautocmd_bufnr = 0;\n    else\n\tautocmd_bufnr = buf->b_fnum;\n\n    /*\n     * When the file name is NULL or empty, use the file name of buffer \"buf\".\n     * Always use the full path of the file name to match with, in case\n     * \"allow_dirs\" is set.\n     */\n    if (fname == NULL || *fname == NUL)\n    {\n\tif (buf == NULL)\n\t    fname = NULL;\n\telse\n\t{\n#ifdef FEAT_SYN_HL\n\t    if (event == EVENT_SYNTAX)\n\t\tfname = buf->b_p_syn;\n\t    else\n#endif\n\t\tif (event == EVENT_FILETYPE)\n\t\t    fname = buf->b_p_ft;\n\t\telse\n\t\t{\n\t\t    if (buf->b_sfname != NULL)\n\t\t\tsfname = vim_strsave(buf->b_sfname);\n\t\t    fname = buf->b_ffname;\n\t\t}\n\t}\n\tif (fname == NULL)\n\t    fname = (char_u *)\"\";\n\tfname = vim_strsave(fname);\t// make a copy, so we can change it\n    }\n    else\n    {\n\tsfname = vim_strsave(fname);\n\t// Don't try expanding FileType, Syntax, FuncUndefined, WindowID,\n\t// ColorScheme, QuickFixCmd*, DirChanged and similar.\n\tif (event == EVENT_FILETYPE\n\t\t|| event == EVENT_SYNTAX\n\t\t|| event == EVENT_CMDLINECHANGED\n\t\t|| event == EVENT_CMDLINEENTER\n\t\t|| event == EVENT_CMDLINELEAVE\n\t\t|| event == EVENT_CMDWINENTER\n\t\t|| event == EVENT_CMDWINLEAVE\n\t\t|| event == EVENT_CMDUNDEFINED\n\t\t|| event == EVENT_FUNCUNDEFINED\n\t\t|| event == EVENT_REMOTEREPLY\n\t\t|| event == EVENT_SPELLFILEMISSING\n\t\t|| event == EVENT_QUICKFIXCMDPRE\n\t\t|| event == EVENT_COLORSCHEME\n\t\t|| event == EVENT_COLORSCHEMEPRE\n\t\t|| event == EVENT_OPTIONSET\n\t\t|| event == EVENT_QUICKFIXCMDPOST\n\t\t|| event == EVENT_DIRCHANGED\n\t\t|| event == EVENT_DIRCHANGEDPRE\n\t\t|| event == EVENT_MODECHANGED\n\t\t|| event == EVENT_USER\n\t\t|| event == EVENT_WINCLOSED\n\t\t|| event == EVENT_WINSCROLLED)\n\t{\n\t    fname = vim_strsave(fname);\n\t    autocmd_fname_full = TRUE; // don't expand it later\n\t}\n\telse\n\t    fname = FullName_save(fname, FALSE);\n    }\n    if (fname == NULL)\t    // out of memory\n    {\n\tvim_free(sfname);\n\tretval = FALSE;\n\tgoto BYPASS_AU;\n    }\n\n#ifdef BACKSLASH_IN_FILENAME\n    /*\n     * Replace all backslashes with forward slashes.  This makes the\n     * autocommand patterns portable between Unix and MS-DOS.\n     */\n    if (sfname != NULL)\n\tforward_slash(sfname);\n    forward_slash(fname);\n#endif\n\n#ifdef VMS\n    // remove version for correct match\n    if (sfname != NULL)\n\tvms_remove_version(sfname);\n    vms_remove_version(fname);\n#endif\n\n    /*\n     * Set the name to be used for <amatch>.\n     */\n    autocmd_match = fname;\n\n\n    // Don't redraw while doing autocommands.\n    ++RedrawingDisabled;\n\n    // name and lnum are filled in later\n    estack_push(ETYPE_AUCMD, NULL, 0);\n    ESTACK_CHECK_SETUP\n\n    save_current_sctx = current_sctx;\n\n#ifdef FEAT_EVAL\n# ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n\tprof_child_enter(&wait_time); // doesn't count for the caller itself\n# endif\n\n    // Don't use local function variables, if called from a function.\n    save_funccal(&funccal_entry);\n#endif\n\n    /*\n     * When starting to execute autocommands, save the search patterns.\n     */\n    if (!autocmd_busy)\n    {\n\tsave_search_patterns();\n\tif (!ins_compl_active())\n\t{\n\t    saveRedobuff(&save_redo);\n\t    did_save_redobuff = TRUE;\n\t}\n\tdid_filetype = keep_filetype;\n    }\n\n    /*\n     * Note that we are applying autocmds.  Some commands need to know.\n     */\n    autocmd_busy = TRUE;\n    filechangeshell_busy = (event == EVENT_FILECHANGEDSHELL);\n    ++nesting;\t\t// see matching decrement below\n\n    // Remember that FileType was triggered.  Used for did_filetype().\n    if (event == EVENT_FILETYPE)\n\tdid_filetype = TRUE;\n\n    tail = gettail(fname);\n\n    // Find first autocommand that matches\n    CLEAR_FIELD(patcmd);\n    patcmd.curpat = first_autopat[(int)event];\n    patcmd.group = group;\n    patcmd.fname = fname;\n    patcmd.sfname = sfname;\n    patcmd.tail = tail;\n    patcmd.event = event;\n    patcmd.arg_bufnr = autocmd_bufnr;\n    auto_next_pat(&patcmd, FALSE);\n\n    // found one, start executing the autocommands\n    if (patcmd.curpat != NULL)\n    {\n\t// add to active_apc_list\n\tpatcmd.next = active_apc_list;\n\tactive_apc_list = &patcmd;\n\n#ifdef FEAT_EVAL\n\t// set v:cmdarg (only when there is a matching pattern)\n\tsave_cmdbang = (long)get_vim_var_nr(VV_CMDBANG);\n\tif (eap != NULL)\n\t{\n\t    save_cmdarg = set_cmdarg(eap, NULL);\n\t    set_vim_var_nr(VV_CMDBANG, (long)eap->forceit);\n\t}\n\telse\n\t    save_cmdarg = NULL;\t// avoid gcc warning\n#endif\n\tretval = TRUE;\n\t// mark the last pattern, to avoid an endless loop when more patterns\n\t// are added when executing autocommands\n\tfor (ap = patcmd.curpat; ap->next != NULL; ap = ap->next)\n\t    ap->last = FALSE;\n\tap->last = TRUE;\n\n\tif (nesting == 1)\n\t    // make sure cursor and topline are valid\n\t    check_lnums(TRUE);\n\n\tsave_did_emsg = did_emsg;\n\n\tdo_cmdline(NULL, getnextac, (void *)&patcmd,\n\t\t\t\t     DOCMD_NOWAIT|DOCMD_VERBOSE|DOCMD_REPEAT);\n\n\tdid_emsg += save_did_emsg;\n\n\tif (nesting == 1)\n\t    // restore cursor and topline, unless they were changed\n\t    reset_lnums();\n\n#ifdef FEAT_EVAL\n\tif (eap != NULL)\n\t{\n\t    (void)set_cmdarg(NULL, save_cmdarg);\n\t    set_vim_var_nr(VV_CMDBANG, save_cmdbang);\n\t}\n#endif\n\t// delete from active_apc_list\n\tif (active_apc_list == &patcmd)\t    // just in case\n\t    active_apc_list = patcmd.next;\n    }\n\n    --RedrawingDisabled;\n    autocmd_busy = save_autocmd_busy;\n    filechangeshell_busy = FALSE;\n    autocmd_nested = save_autocmd_nested;\n    vim_free(SOURCING_NAME);\n    ESTACK_CHECK_NOW\n    estack_pop();\n    vim_free(autocmd_fname);\n    autocmd_fname = save_autocmd_fname;\n    autocmd_fname_full = save_autocmd_fname_full;\n    autocmd_bufnr = save_autocmd_bufnr;\n    autocmd_match = save_autocmd_match;\n    current_sctx = save_current_sctx;\n#ifdef FEAT_EVAL\n    restore_funccal();\n# ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n\tprof_child_exit(&wait_time);\n# endif\n#endif\n    KeyTyped = save_KeyTyped;\n    vim_free(fname);\n    vim_free(sfname);\n    --nesting;\t\t// see matching increment above\n\n    /*\n     * When stopping to execute autocommands, restore the search patterns and\n     * the redo buffer.  Free any buffers in the au_pending_free_buf list and\n     * free any windows in the au_pending_free_win list.\n     */\n    if (!autocmd_busy)\n    {\n\trestore_search_patterns();\n\tif (did_save_redobuff)\n\t    restoreRedobuff(&save_redo);\n\tdid_filetype = FALSE;\n\twhile (au_pending_free_buf != NULL)\n\t{\n\t    buf_T *b = au_pending_free_buf->b_next;\n\n\t    vim_free(au_pending_free_buf);\n\t    au_pending_free_buf = b;\n\t}\n\twhile (au_pending_free_win != NULL)\n\t{\n\t    win_T *w = au_pending_free_win->w_next;\n\n\t    vim_free(au_pending_free_win);\n\t    au_pending_free_win = w;\n\t}\n    }\n\n    /*\n     * Some events don't set or reset the Changed flag.\n     * Check if still in the same buffer!\n     */\n    if (curbuf == old_curbuf\n\t    && (event == EVENT_BUFREADPOST\n\t\t|| event == EVENT_BUFWRITEPOST\n\t\t|| event == EVENT_FILEAPPENDPOST\n\t\t|| event == EVENT_VIMLEAVE\n\t\t|| event == EVENT_VIMLEAVEPRE))\n    {\n\tif (curbuf->b_changed != save_changed)\n\t    need_maketitle = TRUE;\n\tcurbuf->b_changed = save_changed;\n    }\n\n    au_cleanup();\t// may really delete removed patterns/commands now\n\nBYPASS_AU:\n    // When wiping out a buffer make sure all its buffer-local autocommands\n    // are deleted.\n    if (event == EVENT_BUFWIPEOUT && buf != NULL)\n\taubuflocal_remove(buf);\n\n    if (retval == OK && event == EVENT_FILETYPE)\n\tau_did_filetype = TRUE;\n\n    return retval;\n}\n\n# ifdef FEAT_EVAL\nstatic char_u\t*old_termresponse = NULL;\n# endif\n\n/*\n * Block triggering autocommands until unblock_autocmd() is called.\n * Can be used recursively, so long as it's symmetric.\n */\n    void\nblock_autocmds(void)\n{\n# ifdef FEAT_EVAL\n    // Remember the value of v:termresponse.\n    if (autocmd_blocked == 0)\n\told_termresponse = get_vim_var_str(VV_TERMRESPONSE);\n# endif\n    ++autocmd_blocked;\n}\n\n    void\nunblock_autocmds(void)\n{\n    --autocmd_blocked;\n\n# ifdef FEAT_EVAL\n    // When v:termresponse was set while autocommands were blocked, trigger\n    // the autocommands now.  Esp. useful when executing a shell command\n    // during startup (vimdiff).\n    if (autocmd_blocked == 0\n\t\t      && get_vim_var_str(VV_TERMRESPONSE) != old_termresponse)\n\tapply_autocmds(EVENT_TERMRESPONSE, NULL, NULL, FALSE, curbuf);\n# endif\n}\n\n    int\nis_autocmd_blocked(void)\n{\n    return autocmd_blocked != 0;\n}\n\n/*\n * Find next autocommand pattern that matches.\n */\n    static void\nauto_next_pat(\n    AutoPatCmd_T *apc,\n    int\t\tstop_at_last)\t    // stop when 'last' flag is set\n{\n    AutoPat\t*ap;\n    AutoCmd\t*cp;\n    char_u\t*name;\n    char\t*s;\n    estack_T\t*entry;\n    char_u\t*namep;\n\n    entry = ((estack_T *)exestack.ga_data) + exestack.ga_len - 1;\n\n    // Clear the exestack entry for this ETYPE_AUCMD entry.\n    VIM_CLEAR(entry->es_name);\n    entry->es_info.aucmd = NULL;\n\n    for (ap = apc->curpat; ap != NULL && !got_int; ap = ap->next)\n    {\n\tapc->curpat = NULL;\n\n\t// Only use a pattern when it has not been removed, has commands and\n\t// the group matches. For buffer-local autocommands only check the\n\t// buffer number.\n\tif (ap->pat != NULL && ap->cmds != NULL\n\t\t&& (apc->group == AUGROUP_ALL || apc->group == ap->group))\n\t{\n\t    // execution-condition\n\t    if (ap->buflocal_nr == 0\n\t\t    ? (match_file_pat(NULL, &ap->reg_prog, apc->fname,\n\t\t\t\t      apc->sfname, apc->tail, ap->allow_dirs))\n\t\t    : ap->buflocal_nr == apc->arg_bufnr)\n\t    {\n\t\tname = event_nr2name(apc->event);\n\t\ts = _(\"%s Autocommands for \\\"%s\\\"\");\n\t\tnamep = alloc(STRLEN(s) + STRLEN(name) + ap->patlen + 1);\n\t\tif (namep != NULL)\n\t\t{\n\t\t    sprintf((char *)namep, s, (char *)name, (char *)ap->pat);\n\t\t    if (p_verbose >= 8)\n\t\t    {\n\t\t\tverbose_enter();\n\t\t\tsmsg(_(\"Executing %s\"), namep);\n\t\t\tverbose_leave();\n\t\t    }\n\t\t}\n\n\t\t// Update the exestack entry for this autocmd.\n\t\tentry->es_name = namep;\n\t\tentry->es_info.aucmd = apc;\n\n\t\tapc->curpat = ap;\n\t\tapc->nextcmd = ap->cmds;\n\t\t// mark last command\n\t\tfor (cp = ap->cmds; cp->next != NULL; cp = cp->next)\n\t\t    cp->last = FALSE;\n\t\tcp->last = TRUE;\n\t    }\n\t    line_breakcheck();\n\t    if (apc->curpat != NULL)\t    // found a match\n\t\tbreak;\n\t}\n\tif (stop_at_last && ap->last)\n\t    break;\n    }\n}\n\n/*\n * Get the script context where autocommand \"acp\" is defined.\n */\n    sctx_T *\nacp_script_ctx(AutoPatCmd_T *acp)\n{\n    return &acp->script_ctx;\n}\n\n/*\n * Get next autocommand command.\n * Called by do_cmdline() to get the next line for \":if\".\n * Returns allocated string, or NULL for end of autocommands.\n */\n    char_u *\ngetnextac(\n\tint c UNUSED,\n\tvoid *cookie,\n\tint indent UNUSED,\n\tgetline_opt_T options UNUSED)\n{\n    AutoPatCmd_T    *acp = (AutoPatCmd_T *)cookie;\n    char_u\t    *retval;\n    AutoCmd\t    *ac;\n\n    // Can be called again after returning the last line.\n    if (acp->curpat == NULL)\n\treturn NULL;\n\n    // repeat until we find an autocommand to execute\n    for (;;)\n    {\n\t// skip removed commands\n\twhile (acp->nextcmd != NULL && acp->nextcmd->cmd == NULL)\n\t    if (acp->nextcmd->last)\n\t\tacp->nextcmd = NULL;\n\t    else\n\t\tacp->nextcmd = acp->nextcmd->next;\n\n\tif (acp->nextcmd != NULL)\n\t    break;\n\n\t// at end of commands, find next pattern that matches\n\tif (acp->curpat->last)\n\t    acp->curpat = NULL;\n\telse\n\t    acp->curpat = acp->curpat->next;\n\tif (acp->curpat != NULL)\n\t    auto_next_pat(acp, TRUE);\n\tif (acp->curpat == NULL)\n\t    return NULL;\n    }\n\n    ac = acp->nextcmd;\n\n    if (p_verbose >= 9)\n    {\n\tverbose_enter_scroll();\n\tsmsg(_(\"autocommand %s\"), ac->cmd);\n\tmsg_puts(\"\\n\");   // don't overwrite this either\n\tverbose_leave_scroll();\n    }\n    retval = vim_strsave(ac->cmd);\n    // Remove one-shot (\"once\") autocmd in anticipation of its execution.\n    if (ac->once)\n\tau_del_cmd(ac);\n    autocmd_nested = ac->nested;\n    current_sctx = ac->script_ctx;\n    acp->script_ctx = current_sctx;\n    if (ac->last)\n\tacp->nextcmd = NULL;\n    else\n\tacp->nextcmd = ac->next;\n    return retval;\n}\n\n/*\n * Return TRUE if there is a matching autocommand for \"fname\".\n * To account for buffer-local autocommands, function needs to know\n * in which buffer the file will be opened.\n */\n    int\nhas_autocmd(event_T event, char_u *sfname, buf_T *buf)\n{\n    AutoPat\t*ap;\n    char_u\t*fname;\n    char_u\t*tail = gettail(sfname);\n    int\t\tretval = FALSE;\n\n    fname = FullName_save(sfname, FALSE);\n    if (fname == NULL)\n\treturn FALSE;\n\n#ifdef BACKSLASH_IN_FILENAME\n    /*\n     * Replace all backslashes with forward slashes.  This makes the\n     * autocommand patterns portable between Unix and MS-DOS.\n     */\n    sfname = vim_strsave(sfname);\n    if (sfname != NULL)\n\tforward_slash(sfname);\n    forward_slash(fname);\n#endif\n\n    FOR_ALL_AUTOCMD_PATTERNS(event, ap)\n\tif (ap->pat != NULL && ap->cmds != NULL\n\t      && (ap->buflocal_nr == 0\n\t\t? match_file_pat(NULL, &ap->reg_prog,\n\t\t\t\t\t  fname, sfname, tail, ap->allow_dirs)\n\t\t: buf != NULL && ap->buflocal_nr == buf->b_fnum\n\t   ))\n\t{\n\t    retval = TRUE;\n\t    break;\n\t}\n\n    vim_free(fname);\n#ifdef BACKSLASH_IN_FILENAME\n    vim_free(sfname);\n#endif\n\n    return retval;\n}\n\n/*\n * Function given to ExpandGeneric() to obtain the list of autocommand group\n * names.\n */\n    char_u *\nget_augroup_name(expand_T *xp UNUSED, int idx)\n{\n    if (idx == augroups.ga_len)\t\t// add \"END\" add the end\n\treturn (char_u *)\"END\";\n    if (idx < 0 || idx >= augroups.ga_len)\t// end of list\n\treturn NULL;\n    if (AUGROUP_NAME(idx) == NULL || AUGROUP_NAME(idx) == get_deleted_augroup())\n\t// skip deleted entries\n\treturn (char_u *)\"\";\n    return AUGROUP_NAME(idx);\t\t// return a name\n}\n\nstatic int include_groups = FALSE;\n\n    char_u  *\nset_context_in_autocmd(\n    expand_T\t*xp,\n    char_u\t*arg,\n    int\t\tdoautocmd)\t// TRUE for :doauto*, FALSE for :autocmd\n{\n    char_u\t*p;\n    int\t\tgroup;\n\n    // check for a group name, skip it if present\n    include_groups = FALSE;\n    p = arg;\n    group = au_get_grouparg(&arg);\n    if (group == AUGROUP_ERROR)\n\treturn NULL;\n    // If there only is a group name that's what we expand.\n    if (*arg == NUL && group != AUGROUP_ALL && !VIM_ISWHITE(arg[-1]))\n    {\n\targ = p;\n\tgroup = AUGROUP_ALL;\n    }\n\n    // skip over event name\n    for (p = arg; *p != NUL && !VIM_ISWHITE(*p); ++p)\n\tif (*p == ',')\n\t    arg = p + 1;\n    if (*p == NUL)\n    {\n\tif (group == AUGROUP_ALL)\n\t    include_groups = TRUE;\n\txp->xp_context = EXPAND_EVENTS;\t    // expand event name\n\txp->xp_pattern = arg;\n\treturn NULL;\n    }\n\n    // skip over pattern\n    arg = skipwhite(p);\n    while (*arg && (!VIM_ISWHITE(*arg) || arg[-1] == '\\\\'))\n\targ++;\n    if (*arg)\n\treturn arg;\t\t\t    // expand (next) command\n\n    if (doautocmd)\n\txp->xp_context = EXPAND_FILES;\t    // expand file names\n    else\n\txp->xp_context = EXPAND_NOTHING;    // pattern is not expanded\n    return NULL;\n}\n\n/*\n * Function given to ExpandGeneric() to obtain the list of event names.\n */\n    char_u *\nget_event_name(expand_T *xp UNUSED, int idx)\n{\n    if (idx < augroups.ga_len)\t\t// First list group names, if wanted\n    {\n\tif (!include_groups || AUGROUP_NAME(idx) == NULL\n\t\t\t\t || AUGROUP_NAME(idx) == get_deleted_augroup())\n\t    return (char_u *)\"\";\t// skip deleted entries\n\treturn AUGROUP_NAME(idx);\t// return a name\n    }\n    return (char_u *)event_names[idx - augroups.ga_len].name;\n}\n\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if autocmd is supported.\n */\n    int\nautocmd_supported(char_u *name)\n{\n    char_u *p;\n\n    return (event_name2nr(name, &p) != NUM_EVENTS);\n}\n\n/*\n * Return TRUE if an autocommand is defined for a group, event and\n * pattern:  The group can be omitted to accept any group. \"event\" and \"pattern\"\n * can be NULL to accept any event and pattern. \"pattern\" can be NULL to accept\n * any pattern. Buffer-local patterns <buffer> or <buffer=N> are accepted.\n * Used for:\n *\texists(\"#Group\") or\n *\texists(\"#Group#Event\") or\n *\texists(\"#Group#Event#pat\") or\n *\texists(\"#Event\") or\n *\texists(\"#Event#pat\")\n */\n    int\nau_exists(char_u *arg)\n{\n    char_u\t*arg_save;\n    char_u\t*pattern = NULL;\n    char_u\t*event_name;\n    char_u\t*p;\n    event_T\tevent;\n    AutoPat\t*ap;\n    buf_T\t*buflocal_buf = NULL;\n    int\t\tgroup;\n    int\t\tretval = FALSE;\n\n    // Make a copy so that we can change the '#' chars to a NUL.\n    arg_save = vim_strsave(arg);\n    if (arg_save == NULL)\n\treturn FALSE;\n    p = vim_strchr(arg_save, '#');\n    if (p != NULL)\n\t*p++ = NUL;\n\n    // First, look for an autocmd group name\n    group = au_find_group(arg_save);\n    if (group == AUGROUP_ERROR)\n    {\n\t// Didn't match a group name, assume the first argument is an event.\n\tgroup = AUGROUP_ALL;\n\tevent_name = arg_save;\n    }\n    else\n    {\n\tif (p == NULL)\n\t{\n\t    // \"Group\": group name is present and it's recognized\n\t    retval = TRUE;\n\t    goto theend;\n\t}\n\n\t// Must be \"Group#Event\" or \"Group#Event#pat\".\n\tevent_name = p;\n\tp = vim_strchr(event_name, '#');\n\tif (p != NULL)\n\t    *p++ = NUL;\t    // \"Group#Event#pat\"\n    }\n\n    pattern = p;\t    // \"pattern\" is NULL when there is no pattern\n\n    // find the index (enum) for the event name\n    event = event_name2nr(event_name, &p);\n\n    // return FALSE if the event name is not recognized\n    if (event == NUM_EVENTS)\n\tgoto theend;\n\n    // Find the first autocommand for this event.\n    // If there isn't any, return FALSE;\n    // If there is one and no pattern given, return TRUE;\n    ap = first_autopat[(int)event];\n    if (ap == NULL)\n\tgoto theend;\n\n    // if pattern is \"<buffer>\", special handling is needed which uses curbuf\n    // for pattern \"<buffer=N>, fnamecmp() will work fine\n    if (pattern != NULL && STRICMP(pattern, \"<buffer>\") == 0)\n\tbuflocal_buf = curbuf;\n\n    // Check if there is an autocommand with the given pattern.\n    for ( ; ap != NULL; ap = ap->next)\n\t// only use a pattern when it has not been removed and has commands.\n\t// For buffer-local autocommands, fnamecmp() works fine.\n\tif (ap->pat != NULL && ap->cmds != NULL\n\t    && (group == AUGROUP_ALL || ap->group == group)\n\t    && (pattern == NULL\n\t\t|| (buflocal_buf == NULL\n\t\t    ? fnamecmp(ap->pat, pattern) == 0\n\t\t    : ap->buflocal_nr == buflocal_buf->b_fnum)))\n\t{\n\t    retval = TRUE;\n\t    break;\n\t}\n\ntheend:\n    vim_free(arg_save);\n    return retval;\n}\n\n/*\n * autocmd_add() and autocmd_delete() functions\n */\n    static void\nautocmd_add_or_delete(typval_T *argvars, typval_T *rettv, int delete)\n{\n    list_T\t*aucmd_list;\n    listitem_T\t*li;\n    dict_T\t*event_dict;\n    dictitem_T\t*di;\n    char_u\t*event_name = NULL;\n    list_T\t*event_list;\n    listitem_T\t*eli;\n    event_T\tevent;\n    char_u\t*group_name = NULL;\n    int\t\tgroup;\n    char_u\t*pat = NULL;\n    list_T\t*pat_list;\n    listitem_T\t*pli;\n    char_u\t*cmd = NULL;\n    char_u\t*end;\n    int\t\tonce;\n    int\t\tnested;\n    int\t\treplace;\t\t// replace the cmd for a group/event\n    int\t\tretval = VVAL_TRUE;\n    int\t\tsave_augroup = current_augroup;\n\n    rettv->v_type = VAR_BOOL;\n    rettv->vval.v_number = VVAL_FALSE;\n\n    if (check_for_list_arg(argvars, 0) == FAIL)\n\treturn;\n\n    aucmd_list = argvars[0].vval.v_list;\n    if (aucmd_list == NULL)\n\treturn;\n\n    FOR_ALL_LIST_ITEMS(aucmd_list, li)\n    {\n\tVIM_CLEAR(group_name);\n\tVIM_CLEAR(cmd);\n\tevent_name = NULL;\n\tevent_list = NULL;\n\tpat = NULL;\n\tpat_list = NULL;\n\n\tif (li->li_tv.v_type != VAR_DICT)\n\t    continue;\n\n\tevent_dict = li->li_tv.vval.v_dict;\n\tif (event_dict == NULL)\n\t    continue;\n\n\tdi = dict_find(event_dict, (char_u *)\"event\", -1);\n\tif (di != NULL)\n\t{\n\t    if (di->di_tv.v_type == VAR_STRING)\n\t    {\n\t\tevent_name = di->di_tv.vval.v_string;\n\t\tif (event_name == NULL)\n\t\t{\n\t\t    emsg(_(e_string_required));\n\t\t    continue;\n\t\t}\n\t    }\n\t    else if (di->di_tv.v_type == VAR_LIST)\n\t    {\n\t\tevent_list = di->di_tv.vval.v_list;\n\t\tif (event_list == NULL)\n\t\t{\n\t\t    emsg(_(e_list_required));\n\t\t    continue;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\temsg(_(e_string_or_list_expected));\n\t\tcontinue;\n\t    }\n\t}\n\n\tgroup_name = dict_get_string(event_dict, (char_u *)\"group\", TRUE);\n\tif (group_name == NULL || *group_name == NUL)\n\t    // if the autocmd group name is not specified, then use the current\n\t    // autocmd group\n\t    group = current_augroup;\n\telse\n\t{\n\t    group = au_find_group(group_name);\n\t    if (group == AUGROUP_ERROR)\n\t    {\n\t\tif (delete)\n\t\t{\n\t\t    semsg(_(e_no_such_group_str), group_name);\n\t\t    retval = VVAL_FALSE;\n\t\t    break;\n\t\t}\n\t\t// group is not found, create it now\n\t\tgroup = au_new_group(group_name);\n\t\tif (group == AUGROUP_ERROR)\n\t\t{\n\t\t    semsg(_(e_no_such_group_str), group_name);\n\t\t    retval = VVAL_FALSE;\n\t\t    break;\n\t\t}\n\n\t\tcurrent_augroup = group;\n\t    }\n\t}\n\n\t// if a buffer number is specified, then generate a pattern of the form\n\t// \"<buffer=n>. Otherwise, use the pattern supplied by the user.\n\tif (dict_has_key(event_dict, \"bufnr\"))\n\t{\n\t    varnumber_T\tbnum;\n\n\t    bnum = dict_get_number_def(event_dict, (char_u *)\"bufnr\", -1);\n\t    if (bnum == -1)\n\t\tcontinue;\n\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"<buffer=%d>\", (int)bnum);\n\t    pat = IObuff;\n\t}\n\telse\n\t{\n\t    di = dict_find(event_dict, (char_u *)\"pattern\", -1);\n\t    if (di != NULL)\n\t    {\n\t\tif (di->di_tv.v_type == VAR_STRING)\n\t\t{\n\t\t    pat = di->di_tv.vval.v_string;\n\t\t    if (pat == NULL)\n\t\t    {\n\t\t\temsg(_(e_string_required));\n\t\t\tcontinue;\n\t\t    }\n\t\t}\n\t\telse if (di->di_tv.v_type == VAR_LIST)\n\t\t{\n\t\t    pat_list = di->di_tv.vval.v_list;\n\t\t    if (pat_list == NULL)\n\t\t    {\n\t\t\temsg(_(e_list_required));\n\t\t\tcontinue;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    emsg(_(e_string_or_list_expected));\n\t\t    continue;\n\t\t}\n\t    }\n\t    else if (delete)\n\t\tpat = (char_u *)\"\";\n\t}\n\n\tonce = dict_get_bool(event_dict, (char_u *)\"once\", FALSE);\n\tnested = dict_get_bool(event_dict, (char_u *)\"nested\", FALSE);\n\t// if 'replace' is true, then remove all the commands associated with\n\t// this autocmd event/group and add the new command.\n\treplace = dict_get_bool(event_dict, (char_u *)\"replace\", FALSE);\n\n\tcmd = dict_get_string(event_dict, (char_u *)\"cmd\", TRUE);\n\tif (cmd == NULL)\n\t{\n\t    if (delete)\n\t\tcmd = vim_strsave((char_u *)\"\");\n\t    else\n\t\tcontinue;\n\t}\n\n\tif (delete && (event_name == NULL\n\t\t    || (event_name[0] == '*' && event_name[1] == NUL)))\n\t{\n\t    // if the event name is not specified or '*', delete all the events\n\t    for (event = (event_T)0; (int)event < NUM_EVENTS;\n\t\t    event = (event_T)((int)event + 1))\n\t    {\n\t\tif (do_autocmd_event(event, pat, once, nested, cmd, delete,\n\t\t\t\t\t\t\tgroup, 0) == FAIL)\n\t\t{\n\t\t    retval = VVAL_FALSE;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    char_u *p = NULL;\n\n\t    eli = NULL;\n\t    end = NULL;\n\t    while (TRUE)\n\t    {\n\t\tif (event_list != NULL)\n\t\t{\n\t\t    if (eli == NULL)\n\t\t\teli = event_list->lv_first;\n\t\t    else\n\t\t\teli = eli->li_next;\n\t\t    if (eli == NULL)\n\t\t\tbreak;\n\t\t    if (eli->li_tv.v_type != VAR_STRING\n\t\t\t    || (p = eli->li_tv.vval.v_string) == NULL)\n\t\t    {\n\t\t\temsg(_(e_string_required));\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (p == NULL)\n\t\t\tp = event_name;\n\t\t    if (p == NULL || *p == NUL)\n\t\t\tbreak;\n\t\t}\n\n\t\tevent = event_name2nr(p, &end);\n\t\tif (event == NUM_EVENTS || *end != NUL)\n\t\t{\n\t\t    // this also catches something following a valid event name\n\t\t    semsg(_(e_no_such_event_str), p);\n\t\t    retval = VVAL_FALSE;\n\t\t    break;\n\t\t}\n\t\tif (pat != NULL)\n\t\t{\n\t\t    if (do_autocmd_event(event, pat, once, nested, cmd,\n\t\t\t\tdelete | replace, group, 0) == FAIL)\n\t\t    {\n\t\t\tretval = VVAL_FALSE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\telse if (pat_list != NULL)\n\t\t{\n\t\t    FOR_ALL_LIST_ITEMS(pat_list, pli)\n\t\t    {\n\t\t\tif (pli->li_tv.v_type != VAR_STRING\n\t\t\t\t|| pli->li_tv.vval.v_string == NULL)\n\t\t\t{\n\t\t\t    emsg(_(e_string_required));\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (do_autocmd_event(event,\n\t\t\t\t    pli->li_tv.vval.v_string, once, nested,\n\t\t\t\t    cmd, delete | replace, group, 0) ==\n\t\t\t\tFAIL)\n\t\t\t{\n\t\t\t    retval = VVAL_FALSE;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    if (retval == VVAL_FALSE)\n\t\t\tbreak;\n\t\t}\n\t\tif (event_name != NULL)\n\t\t    p = end;\n\t    }\n\t}\n\n\t// if only the autocmd group name is specified for delete and the\n\t// autocmd event, pattern and cmd are not specified, then delete the\n\t// autocmd group.\n\tif (delete && group_name != NULL &&\n\t\t(event_name == NULL || event_name[0] == NUL)\n\t\t&& (pat == NULL || pat[0] == NUL)\n\t\t&& (cmd == NULL || cmd[0] == NUL))\n\t    au_del_group(group_name);\n    }\n\n    VIM_CLEAR(group_name);\n    VIM_CLEAR(cmd);\n\n    current_augroup = save_augroup;\n    rettv->vval.v_number = retval;\n}\n\n/*\n * autocmd_add() function\n */\n    void\nf_autocmd_add(typval_T *argvars, typval_T *rettv)\n{\n    autocmd_add_or_delete(argvars, rettv, FALSE);\n}\n\n/*\n * autocmd_delete() function\n */\n    void\nf_autocmd_delete(typval_T *argvars, typval_T *rettv)\n{\n    autocmd_add_or_delete(argvars, rettv, TRUE);\n}\n\n/*\n * autocmd_get() function\n * Returns a List of autocmds.\n */\n    void\nf_autocmd_get(typval_T *argvars, typval_T *rettv)\n{\n    event_T\tevent_arg = NUM_EVENTS;\n    event_T\tevent;\n    AutoPat\t*ap;\n    AutoCmd\t*ac;\n    list_T\t*event_list;\n    dict_T\t*event_dict;\n    char_u\t*event_name = NULL;\n    char_u\t*pat = NULL;\n    char_u\t*name = NULL;\n    int\t\tgroup = AUGROUP_ALL;\n\n    if (rettv_list_alloc(rettv) == FAIL)\n\treturn;\n    if (check_for_opt_dict_arg(argvars, 0) == FAIL)\n\treturn;\n\n    if (argvars[0].v_type == VAR_DICT)\n    {\n\t// return only the autocmds in the specified group\n\tif (dict_has_key(argvars[0].vval.v_dict, \"group\"))\n\t{\n\t    name = dict_get_string(argvars[0].vval.v_dict,\n\t\t\t\t\t\t      (char_u *)\"group\", TRUE);\n\t    if (name == NULL)\n\t\treturn;\n\n\t    if (*name == NUL)\n\t\tgroup = AUGROUP_DEFAULT;\n\t    else\n\t    {\n\t\tgroup = au_find_group(name);\n\t\tif (group == AUGROUP_ERROR)\n\t\t{\n\t\t    semsg(_(e_no_such_group_str), name);\n\t\t    vim_free(name);\n\t\t    return;\n\t\t}\n\t    }\n\t    vim_free(name);\n\t}\n\n\t// return only the autocmds for the specified event\n\tif (dict_has_key(argvars[0].vval.v_dict, \"event\"))\n\t{\n\t    int\t\ti;\n\n\t    name = dict_get_string(argvars[0].vval.v_dict,\n\t\t\t\t\t\t      (char_u *)\"event\", TRUE);\n\t    if (name == NULL)\n\t\treturn;\n\n\t    if (name[0] == '*' && name[1] == NUL)\n\t\tevent_arg = NUM_EVENTS;\n\t    else\n\t    {\n\t\tfor (i = 0; event_names[i].name != NULL; i++)\n\t\t    if (STRICMP(event_names[i].name, name) == 0)\n\t\t\tbreak;\n\t\tif (event_names[i].name == NULL)\n\t\t{\n\t\t    semsg(_(e_no_such_event_str), name);\n\t\t    vim_free(name);\n\t\t    return;\n\t\t}\n\t\tevent_arg = event_names[i].event;\n\t    }\n\t    vim_free(name);\n\t}\n\n\t// return only the autocmds for the specified pattern\n\tif (dict_has_key(argvars[0].vval.v_dict, \"pattern\"))\n\t{\n\t    pat = dict_get_string(argvars[0].vval.v_dict,\n\t\t\t\t\t\t    (char_u *)\"pattern\", TRUE);\n\t    if (pat == NULL)\n\t\treturn;\n\t}\n    }\n\n    event_list = rettv->vval.v_list;\n\n    // iterate through all the autocmd events\n    for (event = (event_T)0; (int)event < NUM_EVENTS;\n\t    event = (event_T)((int)event + 1))\n    {\n\tif (event_arg != NUM_EVENTS && event != event_arg)\n\t    continue;\n\n\tevent_name = event_nr2name(event);\n\n\t// iterate through all the patterns for this autocmd event\n\tFOR_ALL_AUTOCMD_PATTERNS(event, ap)\n\t{\n\t    char_u\t*group_name;\n\n\t    if (group != AUGROUP_ALL && group != ap->group)\n\t\tcontinue;\n\n\t    if (pat != NULL && STRCMP(pat, ap->pat) != 0)\n\t\tcontinue;\n\n\t    group_name = get_augroup_name(NULL, ap->group);\n\n\t    // iterate through all the commands for this pattern and add one\n\t    // item for each cmd.\n\t    for (ac = ap->cmds; ac != NULL; ac = ac->next)\n\t    {\n\t\tevent_dict = dict_alloc();\n\t\tif (event_dict == NULL\n\t\t\t|| list_append_dict(event_list, event_dict) == FAIL)\n\t\t    return;\n\n\t\tif (dict_add_string(event_dict, \"event\", event_name) == FAIL\n\t\t\t|| dict_add_string(event_dict, \"group\",\n\t\t\t\t\tgroup_name == NULL ? (char_u *)\"\"\n\t\t\t\t\t\t\t  : group_name) == FAIL\n\t\t\t|| (ap->buflocal_nr != 0\n\t\t\t\t&& (dict_add_number(event_dict, \"bufnr\",\n\t\t\t\t\t\t    ap->buflocal_nr) == FAIL))\n\t\t\t|| dict_add_string(event_dict, \"pattern\",\n\t\t\t\t\t\t\t      ap->pat) == FAIL\n\t\t\t|| dict_add_string(event_dict, \"cmd\", ac->cmd) == FAIL\n\t\t\t|| dict_add_bool(event_dict, \"once\", ac->once) == FAIL\n\t\t\t|| dict_add_bool(event_dict, \"nested\",\n\t\t\t\t\t\t\t   ac->nested) == FAIL)\n\t\t    return;\n\t    }\n\t}\n    }\n\n    vim_free(pat);\n}\n\n#endif\n", "/* window.c */\nwin_T *prevwin_curwin(void);\nvoid do_window(int nchar, long Prenum, int xchar);\nvoid get_wincmd_addr_type(char_u *arg, exarg_T *eap);\nint win_split(int size, int flags);\nint win_split_ins(int size, int flags, win_T *new_wp, int dir);\nint win_valid_popup(win_T *win);\nint win_valid(win_T *win);\nwin_T *win_find_by_id(int id);\nint win_valid_any_tab(win_T *win);\nint win_count(void);\nint make_windows(int count, int vertical);\nvoid win_move_after(win_T *win1, win_T *win2);\nvoid win_equal(win_T *next_curwin, int current, int dir);\nvoid entering_window(win_T *win);\nvoid curwin_init(void);\nvoid close_windows(buf_T *buf, int keep_curwin);\nint one_window(void);\nint win_close(win_T *win, int free_buf);\nvoid may_trigger_winscrolled(void);\nvoid win_close_othertab(win_T *win, int free_buf, tabpage_T *tp);\nvoid win_free_all(void);\nwin_T *winframe_remove(win_T *win, int *dirp, tabpage_T *tp);\nvoid close_others(int message, int forceit);\nint win_alloc_first(void);\nwin_T *win_alloc_popup_win(void);\nvoid win_init_popup_win(win_T *wp, buf_T *buf);\nvoid win_init_size(void);\nvoid free_tabpage(tabpage_T *tp);\nint win_new_tabpage(int after);\nint make_tabpages(int maxcount);\nint valid_tabpage(tabpage_T *tpc);\nint valid_tabpage_win(tabpage_T *tpc);\nvoid close_tabpage(tabpage_T *tab);\ntabpage_T *find_tabpage(int n);\nint tabpage_index(tabpage_T *ftp);\nvoid goto_tabpage(int n);\nvoid goto_tabpage_tp(tabpage_T *tp, int trigger_enter_autocmds, int trigger_leave_autocmds);\nint goto_tabpage_lastused(void);\nvoid goto_tabpage_win(tabpage_T *tp, win_T *wp);\nvoid tabpage_move(int nr);\nvoid win_goto(win_T *wp);\nwin_T *win_find_nr(int winnr);\ntabpage_T *win_find_tabpage(win_T *win);\nwin_T *win_vert_neighbor(tabpage_T *tp, win_T *wp, int up, long count);\nwin_T *win_horz_neighbor(tabpage_T *tp, win_T *wp, int left, long count);\nvoid win_enter(win_T *wp, int undo_sync);\nwin_T *buf_jump_open_win(buf_T *buf);\nwin_T *buf_jump_open_tab(buf_T *buf);\nint win_unlisted(win_T *wp);\nvoid win_free_popup(win_T *win);\nvoid win_remove(win_T *wp, tabpage_T *tp);\nint win_alloc_lines(win_T *wp);\nvoid win_free_lsize(win_T *wp);\nvoid shell_new_rows(void);\nvoid shell_new_columns(void);\nvoid win_size_save(garray_T *gap);\nvoid win_size_restore(garray_T *gap);\nint win_comp_pos(void);\nvoid win_ensure_size(void);\nvoid win_setheight(int height);\nvoid win_setheight_win(int height, win_T *win);\nvoid win_setwidth(int width);\nvoid win_setwidth_win(int width, win_T *wp);\nvoid win_setminheight(void);\nvoid win_setminwidth(void);\nvoid win_drag_status_line(win_T *dragwin, int offset);\nvoid win_drag_vsep_line(win_T *dragwin, int offset);\nvoid set_fraction(win_T *wp);\nvoid win_new_height(win_T *wp, int height);\nvoid scroll_to_fraction(win_T *wp, int prev_height);\nvoid win_new_width(win_T *wp, int width);\nvoid win_comp_scroll(win_T *wp);\nvoid command_height(void);\nvoid last_status(int morewin);\nint tabline_height(void);\nint min_rows(void);\nint only_one_window(void);\nvoid check_lnums(int do_curwin);\nvoid reset_lnums(void);\nvoid make_snapshot(int idx);\nvoid restore_snapshot(int idx, int close_curwin);\nint win_hasvertsplit(void);\nint get_win_number(win_T *wp, win_T *first_win);\nint get_tab_number(tabpage_T *tp);\nchar *check_colorcolumn(win_T *wp);\n/* vim: set ft=c : */\n", "\" Tests for autocommands\n\nsource shared.vim\nsource check.vim\nsource term_util.vim\nsource screendump.vim\nimport './vim9.vim' as v9\n\nfunc s:cleanup_buffers() abort\n  for bnr in range(1, bufnr('$'))\n    if bufloaded(bnr) && bufnr('%') != bnr\n      execute 'bd! ' . bnr\n    endif\n  endfor\nendfunc\n\nfunc Test_vim_did_enter()\n  call assert_false(v:vim_did_enter)\n\n  \" This script will never reach the main loop, can't check if v:vim_did_enter\n  \" becomes one.\nendfunc\n\n\" Test for the CursorHold autocmd\nfunc Test_CursorHold_autocmd()\n  CheckRunVimInTerminal\n  call writefile(['one', 'two', 'three'], 'Xfile')\n  let before =<< trim END\n    set updatetime=10\n    au CursorHold * call writefile([line('.')], 'Xoutput', 'a')\n  END\n  call writefile(before, 'Xinit')\n  let buf = RunVimInTerminal('-S Xinit Xfile', {})\n  call term_sendkeys(buf, \"G\")\n  call term_wait(buf, 50)\n  call term_sendkeys(buf, \"gg\")\n  call term_wait(buf)\n  call WaitForAssert({-> assert_equal(['1'], readfile('Xoutput')[-1:-1])})\n  call term_sendkeys(buf, \"j\")\n  call term_wait(buf)\n  call WaitForAssert({-> assert_equal(['1', '2'], readfile('Xoutput')[-2:-1])})\n  call term_sendkeys(buf, \"j\")\n  call term_wait(buf)\n  call WaitForAssert({-> assert_equal(['1', '2', '3'], readfile('Xoutput')[-3:-1])})\n  call StopVimInTerminal(buf)\n\n  call delete('Xinit')\n  call delete('Xoutput')\n  call delete('Xfile')\nendfunc\n\nif has('timers')\n\n  func ExitInsertMode(id)\n    call feedkeys(\"\\<Esc>\")\n  endfunc\n\n  func Test_cursorhold_insert()\n    \" Need to move the cursor.\n    call feedkeys(\"ggG\", \"xt\")\n\n    let g:triggered = 0\n    au CursorHoldI * let g:triggered += 1\n    set updatetime=20\n    call timer_start(200, 'ExitInsertMode')\n    call feedkeys('a', 'x!')\n    call assert_equal(1, g:triggered)\n    unlet g:triggered\n    au! CursorHoldI\n    set updatetime&\n  endfunc\n\n  func Test_cursorhold_insert_with_timer_interrupt()\n    CheckFeature job\n    \" Need to move the cursor.\n    call feedkeys(\"ggG\", \"xt\")\n\n    \" Confirm the timer invoked in exit_cb of the job doesn't disturb\n    \" CursorHoldI event.\n    let g:triggered = 0\n    au CursorHoldI * let g:triggered += 1\n    set updatetime=100\n    call job_start(has('win32') ? 'cmd /c echo:' : 'echo',\n          \\ {'exit_cb': {-> timer_start(200, 'ExitInsertMode')}})\n    call feedkeys('a', 'x!')\n    call assert_equal(1, g:triggered)\n    unlet g:triggered\n    au! CursorHoldI\n    set updatetime&\n  endfunc\n\n  func Test_cursorhold_insert_ctrl_x()\n    let g:triggered = 0\n    au CursorHoldI * let g:triggered += 1\n    set updatetime=20\n    call timer_start(100, 'ExitInsertMode')\n    \" CursorHoldI does not trigger after CTRL-X\n    call feedkeys(\"a\\<C-X>\", 'x!')\n    call assert_equal(0, g:triggered)\n    unlet g:triggered\n    au! CursorHoldI\n    set updatetime&\n  endfunc\n\n  func Test_cursorhold_insert_ctrl_g_U()\n    au CursorHoldI * :\n    set updatetime=20\n    new\n    call timer_start(100, { -> feedkeys(\"\\<Left>foo\\<Esc>\", 't') })\n    call feedkeys(\"i()\\<C-g>U\", 'tx!')\n    sleep 200m\n    call assert_equal('(foo)', getline(1))\n    undo\n    call assert_equal('', getline(1))\n\n    bwipe!\n    au! CursorHoldI\n    set updatetime&\n  endfunc\n\n  func Test_OptionSet_modeline()\n    call test_override('starting', 1)\n    au! OptionSet\n    augroup set_tabstop\n      au OptionSet tabstop call timer_start(1, {-> execute(\"echo 'Handler called'\", \"\")})\n    augroup END\n    call writefile(['vim: set ts=7 sw=5 :', 'something'], 'XoptionsetModeline')\n    set modeline\n    let v:errmsg = ''\n    call assert_fails('split XoptionsetModeline', 'E12:')\n    call assert_equal(7, &ts)\n    call assert_equal('', v:errmsg)\n\n    augroup set_tabstop\n      au!\n    augroup END\n    bwipe!\n    set ts&\n    call delete('XoptionsetModeline')\n    call test_override('starting', 0)\n  endfunc\n\nendif \"has('timers')\n\nfunc Test_bufunload()\n  augroup test_bufunload_group\n    autocmd!\n    autocmd BufUnload * call add(s:li, \"bufunload\")\n    autocmd BufDelete * call add(s:li, \"bufdelete\")\n    autocmd BufWipeout * call add(s:li, \"bufwipeout\")\n  augroup END\n\n  let s:li = []\n  new\n  setlocal bufhidden=\n  bunload\n  call assert_equal([\"bufunload\", \"bufdelete\"], s:li)\n\n  let s:li = []\n  new\n  setlocal bufhidden=delete\n  bunload\n  call assert_equal([\"bufunload\", \"bufdelete\"], s:li)\n\n  let s:li = []\n  new\n  setlocal bufhidden=unload\n  bwipeout\n  call assert_equal([\"bufunload\", \"bufdelete\", \"bufwipeout\"], s:li)\n\n  au! test_bufunload_group\n  augroup! test_bufunload_group\nendfunc\n\n\" SEGV occurs in older versions.  (At least 7.4.2005 or older)\nfunc Test_autocmd_bufunload_with_tabnext()\n  tabedit\n  tabfirst\n\n  augroup test_autocmd_bufunload_with_tabnext_group\n    autocmd!\n    autocmd BufUnload <buffer> tabnext\n  augroup END\n\n  quit\n  call assert_equal(2, tabpagenr('$'))\n\n  autocmd! test_autocmd_bufunload_with_tabnext_group\n  augroup! test_autocmd_bufunload_with_tabnext_group\n  tablast\n  quit\nendfunc\n\nfunc Test_argdelete_in_next()\n  au BufNew,BufEnter,BufLeave,BufWinEnter * argdel\n  call assert_fails('next a b', 'E1156:')\n  au! BufNew,BufEnter,BufLeave,BufWinEnter *\nendfunc\n\nfunc Test_autocmd_bufwinleave_with_tabfirst()\n  tabedit\n  augroup sample\n    autocmd!\n    autocmd BufWinLeave <buffer> tabfirst\n  augroup END\n  call setline(1, ['a', 'b', 'c'])\n  edit! a.txt\n  tabclose\nendfunc\n\n\" SEGV occurs in older versions.  (At least 7.4.2321 or older)\nfunc Test_autocmd_bufunload_avoiding_SEGV_01()\n  split aa.txt\n  let lastbuf = bufnr('$')\n\n  augroup test_autocmd_bufunload\n    autocmd!\n    exe 'autocmd BufUnload <buffer> ' . (lastbuf + 1) . 'bwipeout!'\n  augroup END\n\n  call assert_fails('edit bb.txt', 'E937:')\n\n  autocmd! test_autocmd_bufunload\n  augroup! test_autocmd_bufunload\n  bwipe! aa.txt\n  bwipe! bb.txt\nendfunc\n\n\" SEGV occurs in older versions.  (At least 7.4.2321 or older)\nfunc Test_autocmd_bufunload_avoiding_SEGV_02()\n  setlocal buftype=nowrite\n  let lastbuf = bufnr('$')\n\n  augroup test_autocmd_bufunload\n    autocmd!\n    exe 'autocmd BufUnload <buffer> ' . (lastbuf + 1) . 'bwipeout!'\n  augroup END\n\n  normal! i1\n  call assert_fails('edit a.txt', 'E517:')\n\n  autocmd! test_autocmd_bufunload\n  augroup! test_autocmd_bufunload\n  bwipe! a.txt\nendfunc\n\nfunc Test_autocmd_dummy_wipeout()\n  \" prepare files\n  call writefile([''], 'Xdummywipetest1.txt')\n  call writefile([''], 'Xdummywipetest2.txt')\n  augroup test_bufunload_group\n    autocmd!\n    autocmd BufUnload * call add(s:li, \"bufunload\")\n    autocmd BufDelete * call add(s:li, \"bufdelete\")\n    autocmd BufWipeout * call add(s:li, \"bufwipeout\")\n  augroup END\n\n  let s:li = []\n  split Xdummywipetest1.txt\n  silent! vimgrep /notmatched/ Xdummywipetest*\n  call assert_equal([\"bufunload\", \"bufwipeout\"], s:li)\n\n  bwipeout\n  call delete('Xdummywipetest1.txt')\n  call delete('Xdummywipetest2.txt')\n  au! test_bufunload_group\n  augroup! test_bufunload_group\nendfunc\n\nfunc Test_win_tab_autocmd()\n  let g:record = []\n\n  augroup testing\n    au WinNew * call add(g:record, 'WinNew')\n    au WinClosed * call add(g:record, 'WinClosed')\n    au WinEnter * call add(g:record, 'WinEnter') \n    au WinLeave * call add(g:record, 'WinLeave') \n    au TabNew * call add(g:record, 'TabNew')\n    au TabClosed * call add(g:record, 'TabClosed')\n    au TabEnter * call add(g:record, 'TabEnter')\n    au TabLeave * call add(g:record, 'TabLeave')\n  augroup END\n\n  split\n  tabnew\n  close\n  close\n\n  call assert_equal([\n\t\\ 'WinLeave', 'WinNew', 'WinEnter',\n\t\\ 'WinLeave', 'TabLeave', 'WinNew', 'WinEnter', 'TabNew', 'TabEnter',\n\t\\ 'WinLeave', 'TabLeave', 'WinClosed', 'TabClosed', 'WinEnter', 'TabEnter',\n\t\\ 'WinLeave', 'WinClosed', 'WinEnter'\n\t\\ ], g:record)\n\n  let g:record = []\n  tabnew somefile\n  tabnext\n  bwipe somefile\n\n  call assert_equal([\n\t\\ 'WinLeave', 'TabLeave', 'WinNew', 'WinEnter', 'TabNew', 'TabEnter',\n\t\\ 'WinLeave', 'TabLeave', 'WinEnter', 'TabEnter',\n\t\\ 'WinClosed', 'TabClosed'\n\t\\ ], g:record)\n\n  augroup testing\n    au!\n  augroup END\n  unlet g:record\nendfunc\n\nfunc Test_WinScrolled()\n  CheckRunVimInTerminal\n\n  let lines =<< trim END\n    set nowrap scrolloff=0\n    for ii in range(1, 18)\n      call setline(ii, repeat(nr2char(96 + ii), ii * 2))\n    endfor\n    let win_id = win_getid()\n    let g:matched = v:false\n    execute 'au WinScrolled' win_id 'let g:matched = v:true'\n    let g:scrolled = 0\n    au WinScrolled * let g:scrolled += 1\n    au WinScrolled * let g:amatch = str2nr(expand('<amatch>'))\n    au WinScrolled * let g:afile = str2nr(expand('<afile>'))\n  END\n  call writefile(lines, 'Xtest_winscrolled')\n  let buf = RunVimInTerminal('-S Xtest_winscrolled', {'rows': 6})\n\n  call term_sendkeys(buf, \":echo g:scrolled\\<CR>\")\n  call WaitForAssert({-> assert_match('^0 ', term_getline(buf, 6))}, 1000)\n\n  \" Scroll left/right in Normal mode.\n  call term_sendkeys(buf, \"zlzh:echo g:scrolled\\<CR>\")\n  call WaitForAssert({-> assert_match('^2 ', term_getline(buf, 6))}, 1000)\n\n  \" Scroll up/down in Normal mode.\n  call term_sendkeys(buf, \"\\<c-e>\\<c-y>:echo g:scrolled\\<CR>\")\n  call WaitForAssert({-> assert_match('^4 ', term_getline(buf, 6))}, 1000)\n\n  \" Scroll up/down in Insert mode.\n  call term_sendkeys(buf, \"Mi\\<c-x>\\<c-e>\\<Esc>i\\<c-x>\\<c-y>\\<Esc>\")\n  call term_sendkeys(buf, \":echo g:scrolled\\<CR>\")\n  call WaitForAssert({-> assert_match('^6 ', term_getline(buf, 6))}, 1000)\n\n  \" Scroll the window horizontally to focus the last letter of the third line\n  \" containing only six characters. Moving to the previous and shorter lines\n  \" should trigger another autocommand as Vim has to make them visible.\n  call term_sendkeys(buf, \"5zl2k\")\n  call term_sendkeys(buf, \":echo g:scrolled\\<CR>\")\n  call WaitForAssert({-> assert_match('^8 ', term_getline(buf, 6))}, 1000)\n\n  \" Ensure the command was triggered for the specified window ID.\n  call term_sendkeys(buf, \":echo g:matched\\<CR>\")\n  call WaitForAssert({-> assert_match('^v:true ', term_getline(buf, 6))}, 1000)\n\n  \" Ensure the expansion of <amatch> and <afile> matches the window ID.\n  call term_sendkeys(buf, \":echo g:amatch == win_id && g:afile == win_id\\<CR>\")\n  call WaitForAssert({-> assert_match('^v:true ', term_getline(buf, 6))}, 1000)\n\n  call StopVimInTerminal(buf)\n  call delete('Xtest_winscrolled')\nendfunc\n\nfunc Test_WinScrolled_mouse()\n  CheckRunVimInTerminal\n\n  let lines =<< trim END\n    set nowrap scrolloff=0\n    set mouse=a term=xterm ttymouse=sgr mousetime=200 clipboard=\n    call setline(1, ['foo']->repeat(32))\n    split\n    let g:scrolled = 0\n    au WinScrolled * let g:scrolled += 1\n  END\n  call writefile(lines, 'Xtest_winscrolled_mouse')\n  let buf = RunVimInTerminal('-S Xtest_winscrolled_mouse', {'rows': 10})\n\n  \" With the upper split focused, send a scroll-down event to the unfocused one.\n  call test_setmouse(7, 1)\n  call term_sendkeys(buf, \"\\<ScrollWheelDown>\")\n  call TermWait(buf)\n  call term_sendkeys(buf, \":echo g:scrolled\\<CR>\")\n  call WaitForAssert({-> assert_match('^1', term_getline(buf, 10))}, 1000)\n\n  \" Again, but this time while we're in insert mode.\n  call term_sendkeys(buf, \"i\\<ScrollWheelDown>\\<Esc>\")\n  call TermWait(buf)\n  call term_sendkeys(buf, \":echo g:scrolled\\<CR>\")\n  call WaitForAssert({-> assert_match('^2', term_getline(buf, 10))}, 1000)\n\n  call StopVimInTerminal(buf)\n  call delete('Xtest_winscrolled_mouse')\nendfunc\n\nfunc Test_WinScrolled_close_curwin()\n  CheckRunVimInTerminal\n\n  let lines =<< trim END\n    set nowrap scrolloff=0\n    call setline(1, ['aaa', 'bbb'])\n    vsplit\n    au WinScrolled * close\n    au VimLeave * call writefile(['123456'], 'Xtestout')\n  END\n  call writefile(lines, 'Xtest_winscrolled_close_curwin')\n  let buf = RunVimInTerminal('-S Xtest_winscrolled_close_curwin', {'rows': 6})\n\n  \" This was using freed memory\n  call term_sendkeys(buf, \"\\<C-E>\")\n  call TermWait(buf)\n  call StopVimInTerminal(buf)\n\n  call assert_equal(['123456'], readfile('Xtestout'))\n\n  call delete('Xtest_winscrolled_close_curwin')\n  call delete('Xtestout')\nendfunc\n\nfunc Test_WinClosed()\n  \" Test that the pattern is matched against the closed window's ID, and both\n  \" <amatch> and <afile> are set to it.\n  new\n  let winid = win_getid()\n  let g:matched = v:false\n  augroup test-WinClosed\n    autocmd!\n    execute 'autocmd WinClosed' winid 'let g:matched = v:true'\n    autocmd WinClosed * let g:amatch = str2nr(expand('<amatch>'))\n    autocmd WinClosed * let g:afile = str2nr(expand('<afile>'))\n  augroup END\n  close\n  call assert_true(g:matched)\n  call assert_equal(winid, g:amatch)\n  call assert_equal(winid, g:afile)\n\n  \" Test that WinClosed is non-recursive.\n  new\n  new\n  call assert_equal(3, winnr('$'))\n  let g:triggered = 0\n  augroup test-WinClosed\n    autocmd!\n    autocmd WinClosed * let g:triggered += 1\n    autocmd WinClosed * 2 wincmd c\n  augroup END\n  close\n  call assert_equal(1, winnr('$'))\n  call assert_equal(1, g:triggered)\n\n  autocmd! test-WinClosed\n  augroup! test-WinClosed\n  unlet g:matched\n  unlet g:amatch\n  unlet g:afile\n  unlet g:triggered\nendfunc\n\nfunc Test_WinClosed_throws()\n  vnew\n  let bnr = bufnr()\n  call assert_equal(1, bufloaded(bnr))\n  augroup test-WinClosed\n    autocmd WinClosed * throw 'foo'\n  augroup END\n  try\n    close\n  catch /.*/\n  endtry\n  call assert_equal(0, bufloaded(bnr))\n\n  autocmd! test-WinClosed\n  augroup! test-WinClosed\nendfunc\n\nfunc Test_WinClosed_throws_with_tabs()\n  tabnew\n  let bnr = bufnr()\n  call assert_equal(1, bufloaded(bnr))\n  augroup test-WinClosed\n    autocmd WinClosed * throw 'foo'\n  augroup END\n  try\n    close\n  catch /.*/\n  endtry\n  call assert_equal(0, bufloaded(bnr))\n\n  autocmd! test-WinClosed\n  augroup! test-WinClosed\nendfunc\n\nfunc s:AddAnAutocmd()\n  augroup vimBarTest\n    au BufReadCmd * echo 'hello'\n  augroup END\n  call assert_equal(3, len(split(execute('au vimBarTest'), \"\\n\")))\nendfunc\n\nfunc Test_early_bar()\n  \" test that a bar is recognized before the {event}\n  call s:AddAnAutocmd()\n  augroup vimBarTest | au! | let done = 77 | augroup END\n  call assert_equal(1, len(split(execute('au vimBarTest'), \"\\n\")))\n  call assert_equal(77, done)\n\n  call s:AddAnAutocmd()\n  augroup vimBarTest| au!| let done = 88 | augroup END\n  call assert_equal(1, len(split(execute('au vimBarTest'), \"\\n\")))\n  call assert_equal(88, done)\n\n  \" test that a bar is recognized after the {event}\n  call s:AddAnAutocmd()\n  augroup vimBarTest| au!BufReadCmd| let done = 99 | augroup END\n  call assert_equal(1, len(split(execute('au vimBarTest'), \"\\n\")))\n  call assert_equal(99, done)\n\n  \" test that a bar is recognized after the {group}\n  call s:AddAnAutocmd()\n  au! vimBarTest|echo 'hello'\n  call assert_equal(1, len(split(execute('au vimBarTest'), \"\\n\")))\nendfunc\n\nfunc RemoveGroup()\n  autocmd! StartOK\n  augroup! StartOK\nendfunc\n\nfunc Test_augroup_warning()\n  augroup TheWarning\n    au VimEnter * echo 'entering'\n  augroup END\n  call assert_match(\"TheWarning.*VimEnter\", execute('au VimEnter'))\n  redir => res\n  augroup! TheWarning\n  redir END\n  call assert_match(\"W19:\", res)\n  call assert_match(\"-Deleted-.*VimEnter\", execute('au VimEnter'))\n\n  \" check \"Another\" does not take the pace of the deleted entry\n  augroup Another\n  augroup END\n  call assert_match(\"-Deleted-.*VimEnter\", execute('au VimEnter'))\n  augroup! Another\n\n  \" no warning for postpone aucmd delete\n  augroup StartOK\n    au VimEnter * call RemoveGroup()\n  augroup END\n  call assert_match(\"StartOK.*VimEnter\", execute('au VimEnter'))\n  redir => res\n  doautocmd VimEnter\n  redir END\n  call assert_notmatch(\"W19:\", res)\n  au! VimEnter\n\n  call assert_fails('augroup!', 'E471:')\nendfunc\n\nfunc Test_BufReadCmdHelp()\n  \" This used to cause access to free memory\n  au BufReadCmd * e +h\n  help\n\n  au! BufReadCmd\nendfunc\n\nfunc Test_BufReadCmdHelpJump()\n  \" This used to cause access to free memory\n  au BufReadCmd * e +h{\n  \" } to fix highlighting\n  call assert_fails('help', 'E434:')\n\n  au! BufReadCmd\nendfunc\n\nfunc Test_augroup_deleted()\n  \" This caused a crash before E936 was introduced\n  augroup x\n    call assert_fails('augroup! x', 'E936:')\n    au VimEnter * echo\n  augroup end\n  augroup! x\n  call assert_match(\"-Deleted-.*VimEnter\", execute('au VimEnter'))\n  au! VimEnter\nendfunc\n\n\" Tests for autocommands on :close command.\n\" This used to be in test13.\nfunc Test_three_windows()\n  \" Clean up buffers, because in some cases this function fails.\n  call s:cleanup_buffers()\n\n  \" Write three files and open them, each in a window.\n  \" Then go to next window, with autocommand that deletes the previous one.\n  \" Do this twice, writing the file.\n  e! Xtestje1\n  call setline(1, 'testje1')\n  w\n  sp Xtestje2\n  call setline(1, 'testje2')\n  w\n  sp Xtestje3\n  call setline(1, 'testje3')\n  w\n  wincmd w\n  au WinLeave Xtestje2 bwipe\n  wincmd w\n  call assert_equal('Xtestje1', expand('%'))\n\n  au WinLeave Xtestje1 bwipe Xtestje3\n  close\n  call assert_equal('Xtestje1', expand('%'))\n\n  \" Test deleting the buffer on a Unload event.  If this goes wrong there\n  \" will be the ATTENTION prompt.\n  e Xtestje1\n  au!\n  au! BufUnload Xtestje1 bwipe\n  call assert_fails('e Xtestje3', 'E937:')\n  call assert_equal('Xtestje3', expand('%'))\n\n  e Xtestje2\n  sp Xtestje1\n  call assert_fails('e', 'E937:')\n  call assert_equal('Xtestje1', expand('%'))\n\n  \" Test changing buffers in a BufWipeout autocommand.  If this goes wrong\n  \" there are ml_line errors and/or a Crash.\n  au!\n  only\n  e Xanother\n  e Xtestje1\n  bwipe Xtestje2\n  bwipe Xtestje3\n  au BufWipeout Xtestje1 buf Xtestje1\n  bwipe\n  call assert_equal('Xanother', expand('%'))\n\n  only\n  help\n  wincmd w\n  1quit\n  call assert_equal('Xanother', expand('%'))\n\n  au!\n  enew\n  call delete('Xtestje1')\n  call delete('Xtestje2')\n  call delete('Xtestje3')\nendfunc\n\nfunc Test_BufEnter()\n  au! BufEnter\n  au Bufenter * let val = val . '+'\n  let g:val = ''\n  split NewFile\n  call assert_equal('+', g:val)\n  bwipe!\n  call assert_equal('++', g:val)\n\n  \" Also get BufEnter when editing a directory\n  call mkdir('Xdir')\n  split Xdir\n  call assert_equal('+++', g:val)\n\n  \" On MS-Windows we can't edit the directory, make sure we wipe the right\n  \" buffer.\n  bwipe! Xdir\n\n  call delete('Xdir', 'd')\n  au! BufEnter\nendfunc\n\n\" Closing a window might cause an endless loop\n\" E814 for older Vims\nfunc Test_autocmd_bufwipe_in_SessLoadPost()\n  edit Xtest\n  tabnew\n  file Xsomething\n  set noswapfile\n  mksession!\n\n  let content =<< trim [CODE]\n    call test_override('ui_delay', 10)\n    set nocp noswapfile\n    let v:swapchoice = \"e\"\n    augroup test_autocmd_sessionload\n    autocmd!\n    autocmd SessionLoadPost * exe bufnr(\"Xsomething\") . \"bw!\"\n    augroup END\n\n    func WriteErrors()\n      call writefile([execute(\"messages\")], \"Xerrors\")\n    endfunc\n    au VimLeave * call WriteErrors()\n  [CODE]\n\n  call writefile(content, 'Xvimrc')\n  call system(GetVimCommand('Xvimrc') .. ' --not-a-term --noplugins -S Session.vim -c cq')\n  let errors = join(readfile('Xerrors'))\n  call assert_match('E814:', errors)\n\n  set swapfile\n  for file in ['Session.vim', 'Xvimrc', 'Xerrors']\n    call delete(file)\n  endfor\nendfunc\n\n\" Using :blast and :ball for many events caused a crash, because b_nwindows was\n\" not incremented correctly.\nfunc Test_autocmd_blast_badd()\n  let content =<< trim [CODE]\n      au BufNew,BufAdd,BufWinEnter,BufEnter,BufLeave,BufWinLeave,BufUnload,VimEnter foo* blast\n      edit foo1\n      au BufNew,BufAdd,BufWinEnter,BufEnter,BufLeave,BufWinLeave,BufUnload,VimEnter foo* ball\n      edit foo2\n      call writefile(['OK'], 'Xerrors')\n      qall\n  [CODE]\n\n  call writefile(content, 'XblastBall')\n  call system(GetVimCommand() .. ' --clean -S XblastBall')\n  call assert_match('OK', readfile('Xerrors')->join())\n\n  call delete('XblastBall')\n  call delete('Xerrors')\nendfunc\n\n\" SEGV occurs in older versions.\nfunc Test_autocmd_bufwipe_in_SessLoadPost2()\n  tabnew\n  set noswapfile\n  mksession!\n\n  let content =<< trim [CODE]\n    set nocp noswapfile\n    function! DeleteInactiveBufs()\n      tabfirst\n      let tabblist = []\n      for i in range(1, tabpagenr(''$''))\n        call extend(tabblist, tabpagebuflist(i))\n      endfor\n      for b in range(1, bufnr(''$''))\n        if bufexists(b) && buflisted(b) && (index(tabblist, b) == -1 || bufname(b) =~# ''^$'')\n          exec ''bwipeout '' . b\n        endif\n      endfor\n      echomsg \"SessionLoadPost DONE\"\n    endfunction\n    au SessionLoadPost * call DeleteInactiveBufs()\n\n    func WriteErrors()\n      call writefile([execute(\"messages\")], \"Xerrors\")\n    endfunc\n    au VimLeave * call WriteErrors()\n  [CODE]\n\n  call writefile(content, 'Xvimrc')\n  call system(GetVimCommand('Xvimrc') .. ' --not-a-term --noplugins -S Session.vim -c cq')\n  let errors = join(readfile('Xerrors'))\n  \" This probably only ever matches on unix.\n  call assert_notmatch('Caught deadly signal SEGV', errors)\n  call assert_match('SessionLoadPost DONE', errors)\n\n  set swapfile\n  for file in ['Session.vim', 'Xvimrc', 'Xerrors']\n    call delete(file)\n  endfor\nendfunc\n\nfunc Test_empty_doau()\n  doau \\|\nendfunc\n\nfunc s:AutoCommandOptionSet(match)\n  let template = \"Option: <%s>, OldVal: <%s>, OldValLocal: <%s>, OldValGlobal: <%s>, NewVal: <%s>, Scope: <%s>, Command: <%s>\\n\"\n  let item     = remove(g:options, 0)\n  let expected = printf(template, item[0], item[1], item[2], item[3], item[4], item[5], item[6])\n  let actual   = printf(template, a:match, v:option_old, v:option_oldlocal, v:option_oldglobal, v:option_new, v:option_type, v:option_command)\n  let g:opt    = [expected, actual]\n  \"call assert_equal(expected, actual)\nendfunc\n\nfunc Test_OptionSet()\n  CheckOption autochdir\n\n  badd test_autocmd.vim\n\n  call test_override('starting', 1)\n  set nocp\n  au OptionSet * :call s:AutoCommandOptionSet(expand(\"<amatch>\"))\n\n  \" 1: Setting number option\"\n  let g:options = [['number', 0, 0, 0, 1, 'global', 'set']]\n  set nu\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 2: Setting local number option\"\n  let g:options = [['number', 1, 1, '', 0, 'local', 'setlocal']]\n  setlocal nonu\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 3: Setting global number option\"\n  let g:options = [['number', 1, '', 1, 0, 'global', 'setglobal']]\n  setglobal nonu\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 4: Setting local autoindent option\"\n  let g:options = [['autoindent', 0, 0, '', 1, 'local', 'setlocal']]\n  setlocal ai\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 5: Setting global autoindent option\"\n  let g:options = [['autoindent', 0, '', 0, 1, 'global', 'setglobal']]\n  setglobal ai\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 6: Setting global autoindent option\"\n  let g:options = [['autoindent', 1, 1, 1, 0, 'global', 'set']]\n  set ai!\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 6a: Setting global autoindent option\"\n  let g:options = [['autoindent', 1, 1, 0, 0, 'global', 'set']]\n  noa setlocal ai\n  noa setglobal noai\n  set ai!\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" Should not print anything, use :noa\n  \" 7: don't trigger OptionSet\"\n  let g:options = [['invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid']]\n  noa set nonu\n  call assert_equal([['invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid']], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 8: Setting several global list and number option\"\n  let g:options = [['list', 0, 0, 0, 1, 'global', 'set'], ['number', 0, 0, 0, 1, 'global', 'set']]\n  set list nu\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 9: don't trigger OptionSet\"\n  let g:options = [['invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid'], ['invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid']]\n  noa set nolist nonu\n  call assert_equal([['invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid'], ['invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid']], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 10: Setting global acd\"\n  let g:options = [['autochdir', 0, 0, '', 1, 'local', 'setlocal']]\n  setlocal acd\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 11: Setting global autoread (also sets local value)\"\n  let g:options = [['autoread', 0, 0, 0, 1, 'global', 'set']]\n  set ar\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 12: Setting local autoread\"\n  let g:options = [['autoread', 1, 1, '', 1, 'local', 'setlocal']]\n  setlocal ar\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 13: Setting global autoread\"\n  let g:options = [['autoread', 1, '', 1, 0, 'global', 'setglobal']]\n  setglobal invar\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 14: Setting option backspace through :let\"\n  let g:options = [['backspace', '', '', '', 'eol,indent,start', 'global', 'set']]\n  let &bs = \"eol,indent,start\"\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 15: Setting option backspace through setbufvar()\"\n  let g:options = [['backup', 0, 0, '', 1, 'local', 'setlocal']]\n  \" try twice, first time, shouldn't trigger because option name is invalid,\n  \" second time, it should trigger\n  let bnum = bufnr('%')\n  call assert_fails(\"call setbufvar(bnum, '&l:bk', 1)\", 'E355:')\n  \" should trigger, use correct option name\n  call setbufvar(bnum, '&backup', 1)\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 16: Setting number option using setwinvar\"\n  let g:options = [['number', 0, 0, '', 1, 'local', 'setlocal']]\n  call setwinvar(0, '&number', 1)\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 17: Setting key option, shouldn't trigger\"\n  let g:options = [['key', 'invalid', 'invalid1', 'invalid2', 'invalid3', 'invalid4', 'invalid5']]\n  setlocal key=blah\n  setlocal key=\n  call assert_equal([['key', 'invalid', 'invalid1', 'invalid2', 'invalid3', 'invalid4', 'invalid5']], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 18a: Setting string global option\"\n  let oldval = &backupext\n  let g:options = [['backupext', oldval, oldval, oldval, 'foo', 'global', 'set']]\n  set backupext=foo\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 18b: Resetting string global option\"\n  let g:options = [['backupext', 'foo', 'foo', 'foo', oldval, 'global', 'set']]\n  set backupext&\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 18c: Setting global string global option\"\n  let g:options = [['backupext', oldval, '', oldval, 'bar', 'global', 'setglobal']]\n  setglobal backupext=bar\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 18d: Setting local string global option\"\n  \" As this is a global option this sets the global value even though\n  \" :setlocal is used!\n  noa set backupext& \" Reset global and local value (without triggering autocmd)\n  let g:options = [['backupext', oldval, oldval, '', 'baz', 'local', 'setlocal']]\n  setlocal backupext=baz\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 18e: Setting again string global option\"\n  noa setglobal backupext=ext_global \" Reset global and local value (without triggering autocmd)\n  noa setlocal backupext=ext_local \" Sets the global(!) value!\n  let g:options = [['backupext', 'ext_local', 'ext_local', 'ext_local', 'fuu', 'global', 'set']]\n  set backupext=fuu\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 19a: Setting string global-local (to buffer) option\"\n  let oldval = &tags\n  let g:options = [['tags', oldval, oldval, oldval, 'tagpath', 'global', 'set']]\n  set tags=tagpath\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 19b: Resetting string global-local (to buffer) option\"\n  let g:options = [['tags', 'tagpath', 'tagpath', 'tagpath', oldval, 'global', 'set']]\n  set tags&\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 19c: Setting global string global-local (to buffer) option \"\n  let g:options = [['tags', oldval, '', oldval, 'tagpath1', 'global', 'setglobal']]\n  setglobal tags=tagpath1\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 19d: Setting local string global-local (to buffer) option\"\n  let g:options = [['tags', 'tagpath1', 'tagpath1', '', 'tagpath2', 'local', 'setlocal']]\n  setlocal tags=tagpath2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 19e: Setting again string global-local (to buffer) option\"\n  \" Note: v:option_old is the old global value for global-local string options\n  \" but the old local value for all other kinds of options.\n  noa setglobal tags=tag_global \" Reset global and local value (without triggering autocmd)\n  noa setlocal tags=tag_local\n  let g:options = [['tags', 'tag_global', 'tag_local', 'tag_global', 'tagpath', 'global', 'set']]\n  set tags=tagpath\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 19f: Setting string global-local (to buffer) option to an empty string\"\n  \" Note: v:option_old is the old global value for global-local string options\n  \" but the old local value for all other kinds of options.\n  noa set tags=tag_global \" Reset global and local value (without triggering autocmd)\n  noa setlocal tags= \" empty string\n  let g:options = [['tags', 'tag_global', '', 'tag_global', 'tagpath', 'global', 'set']]\n  set tags=tagpath\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 20a: Setting string local (to buffer) option\"\n  let oldval = &spelllang\n  let g:options = [['spelllang', oldval, oldval, oldval, 'elvish,klingon', 'global', 'set']]\n  set spelllang=elvish,klingon\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 20b: Resetting string local (to buffer) option\"\n  let g:options = [['spelllang', 'elvish,klingon', 'elvish,klingon', 'elvish,klingon', oldval, 'global', 'set']]\n  set spelllang&\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 20c: Setting global string local (to buffer) option\"\n  let g:options = [['spelllang', oldval, '', oldval, 'elvish', 'global', 'setglobal']]\n  setglobal spelllang=elvish\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 20d: Setting local string local (to buffer) option\"\n  noa set spelllang& \" Reset global and local value (without triggering autocmd)\n  let g:options = [['spelllang', oldval, oldval, '', 'klingon', 'local', 'setlocal']]\n  setlocal spelllang=klingon\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 20e: Setting again string local (to buffer) option\"\n  \" Note: v:option_old is the old global value for global-local string options\n  \" but the old local value for all other kinds of options.\n  noa setglobal spelllang=spellglobal \" Reset global and local value (without triggering autocmd)\n  noa setlocal spelllang=spelllocal\n  let g:options = [['spelllang', 'spelllocal', 'spelllocal', 'spellglobal', 'foo', 'global', 'set']]\n  set spelllang=foo\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 21a: Setting string global-local (to window) option\"\n  let oldval = &statusline\n  let g:options = [['statusline', oldval, oldval, oldval, 'foo', 'global', 'set']]\n  set statusline=foo\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 21b: Resetting string global-local (to window) option\"\n  \" Note: v:option_old is the old global value for global-local string options\n  \" but the old local value for all other kinds of options.\n  let g:options = [['statusline', 'foo', 'foo', 'foo', oldval, 'global', 'set']]\n  set statusline&\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 21c: Setting global string global-local (to window) option\"\n  let g:options = [['statusline', oldval, '', oldval, 'bar', 'global', 'setglobal']]\n  setglobal statusline=bar\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 21d: Setting local string global-local (to window) option\"\n  noa set statusline& \" Reset global and local value (without triggering autocmd)\n  let g:options = [['statusline', oldval, oldval, '', 'baz', 'local', 'setlocal']]\n  setlocal statusline=baz\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 21e: Setting again string global-local (to window) option\"\n  \" Note: v:option_old is the old global value for global-local string options\n  \" but the old local value for all other kinds of options.\n  noa setglobal statusline=bar \" Reset global and local value (without triggering autocmd)\n  noa setlocal statusline=baz\n  let g:options = [['statusline', 'bar', 'baz', 'bar', 'foo', 'global', 'set']]\n  set statusline=foo\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 22a: Setting string local (to window) option\"\n  let oldval = &foldignore\n  let g:options = [['foldignore', oldval, oldval, oldval, 'fo', 'global', 'set']]\n  set foldignore=fo\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 22b: Resetting string local (to window) option\"\n  let g:options = [['foldignore', 'fo', 'fo', 'fo', oldval, 'global', 'set']]\n  set foldignore&\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 22c: Setting global string local (to window) option\"\n  let g:options = [['foldignore', oldval, '', oldval, 'bar', 'global', 'setglobal']]\n  setglobal foldignore=bar\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 22d: Setting local string local (to window) option\"\n  noa set foldignore& \" Reset global and local value (without triggering autocmd)\n  let g:options = [['foldignore', oldval, oldval, '', 'baz', 'local', 'setlocal']]\n  setlocal foldignore=baz\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 22e: Setting again string local (to window) option\"\n  noa setglobal foldignore=glob \" Reset global and local value (without triggering autocmd)\n  noa setlocal foldignore=loc\n  let g:options = [['foldignore', 'loc', 'loc', 'glob', 'fo', 'global', 'set']]\n  set foldignore=fo\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 23a: Setting global number global option\"\n  noa setglobal cmdheight=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal cmdheight=1 \" Sets the global(!) value!\n  let g:options = [['cmdheight', '1', '', '1', '2', 'global', 'setglobal']]\n  setglobal cmdheight=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 23b: Setting local number global option\"\n  noa setglobal cmdheight=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal cmdheight=1 \" Sets the global(!) value!\n  let g:options = [['cmdheight', '1', '1', '', '2', 'local', 'setlocal']]\n  setlocal cmdheight=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 23c: Setting again number global option\"\n  noa setglobal cmdheight=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal cmdheight=1 \" Sets the global(!) value!\n  let g:options = [['cmdheight', '1', '1', '1', '2', 'global', 'set']]\n  set cmdheight=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 23d: Setting again number global option\"\n  noa set cmdheight=8 \" Reset global and local value (without triggering autocmd)\n  let g:options = [['cmdheight', '8', '8', '8', '2', 'global', 'set']]\n  set cmdheight=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 24a: Setting global number global-local (to buffer) option\"\n  noa setglobal undolevels=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal undolevels=1\n  let g:options = [['undolevels', '8', '', '8', '2', 'global', 'setglobal']]\n  setglobal undolevels=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 24b: Setting local number global-local (to buffer) option\"\n  noa setglobal undolevels=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal undolevels=1\n  let g:options = [['undolevels', '1', '1', '', '2', 'local', 'setlocal']]\n  setlocal undolevels=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 24c: Setting again number global-local (to buffer) option\"\n  noa setglobal undolevels=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal undolevels=1\n  let g:options = [['undolevels', '1', '1', '8', '2', 'global', 'set']]\n  set undolevels=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 24d: Setting again global number global-local (to buffer) option\"\n  noa set undolevels=8 \" Reset global and local value (without triggering autocmd)\n  let g:options = [['undolevels', '8', '8', '8', '2', 'global', 'set']]\n  set undolevels=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 25a: Setting global number local (to buffer) option\"\n  noa setglobal wrapmargin=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal wrapmargin=1\n  let g:options = [['wrapmargin', '8', '', '8', '2', 'global', 'setglobal']]\n  setglobal wrapmargin=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 25b: Setting local number local (to buffer) option\"\n  noa setglobal wrapmargin=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal wrapmargin=1\n  let g:options = [['wrapmargin', '1', '1', '', '2', 'local', 'setlocal']]\n  setlocal wrapmargin=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 25c: Setting again number local (to buffer) option\"\n  noa setglobal wrapmargin=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal wrapmargin=1\n  let g:options = [['wrapmargin', '1', '1', '8', '2', 'global', 'set']]\n  set wrapmargin=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 25d: Setting again global number local (to buffer) option\"\n  noa set wrapmargin=8 \" Reset global and local value (without triggering autocmd)\n  let g:options = [['wrapmargin', '8', '8', '8', '2', 'global', 'set']]\n  set wrapmargin=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 26: Setting number global-local (to window) option.\n  \" Such option does currently not exist.\n\n\n  \" 27a: Setting global number local (to window) option\"\n  noa setglobal foldcolumn=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal foldcolumn=1\n  let g:options = [['foldcolumn', '8', '', '8', '2', 'global', 'setglobal']]\n  setglobal foldcolumn=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 27b: Setting local number local (to window) option\"\n  noa setglobal foldcolumn=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal foldcolumn=1\n  let g:options = [['foldcolumn', '1', '1', '', '2', 'local', 'setlocal']]\n  setlocal foldcolumn=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 27c: Setting again number local (to window) option\"\n  noa setglobal foldcolumn=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal foldcolumn=1\n  let g:options = [['foldcolumn', '1', '1', '8', '2', 'global', 'set']]\n  set foldcolumn=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 27d: Setting again global number local (to window) option\"\n  noa set foldcolumn=8 \" Reset global and local value (without triggering autocmd)\n  let g:options = [['foldcolumn', '8', '8', '8', '2', 'global', 'set']]\n  set foldcolumn=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 28a: Setting global boolean global option\"\n  noa setglobal nowrapscan \" Reset global and local value (without triggering autocmd)\n  noa setlocal wrapscan \" Sets the global(!) value!\n  let g:options = [['wrapscan', '1', '', '1', '0', 'global', 'setglobal']]\n  setglobal nowrapscan\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 28b: Setting local boolean global option\"\n  noa setglobal nowrapscan \" Reset global and local value (without triggering autocmd)\n  noa setlocal wrapscan \" Sets the global(!) value!\n  let g:options = [['wrapscan', '1', '1', '', '0', 'local', 'setlocal']]\n  setlocal nowrapscan\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 28c: Setting again boolean global option\"\n  noa setglobal nowrapscan \" Reset global and local value (without triggering autocmd)\n  noa setlocal wrapscan \" Sets the global(!) value!\n  let g:options = [['wrapscan', '1', '1', '1', '0', 'global', 'set']]\n  set nowrapscan\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 28d: Setting again global boolean global option\"\n  noa set nowrapscan \" Reset global and local value (without triggering autocmd)\n  let g:options = [['wrapscan', '0', '0', '0', '1', 'global', 'set']]\n  set wrapscan\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 29a: Setting global boolean global-local (to buffer) option\"\n  noa setglobal noautoread \" Reset global and local value (without triggering autocmd)\n  noa setlocal autoread\n  let g:options = [['autoread', '0', '', '0', '1', 'global', 'setglobal']]\n  setglobal autoread\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 29b: Setting local boolean global-local (to buffer) option\"\n  noa setglobal noautoread \" Reset global and local value (without triggering autocmd)\n  noa setlocal autoread\n  let g:options = [['autoread', '1', '1', '', '0', 'local', 'setlocal']]\n  setlocal noautoread\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 29c: Setting again boolean global-local (to buffer) option\"\n  noa setglobal noautoread \" Reset global and local value (without triggering autocmd)\n  noa setlocal autoread\n  let g:options = [['autoread', '1', '1', '0', '1', 'global', 'set']]\n  set autoread\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 29d: Setting again global boolean global-local (to buffer) option\"\n  noa set noautoread \" Reset global and local value (without triggering autocmd)\n  let g:options = [['autoread', '0', '0', '0', '1', 'global', 'set']]\n  set autoread\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 30a: Setting global boolean local (to buffer) option\"\n  noa setglobal nocindent \" Reset global and local value (without triggering autocmd)\n  noa setlocal cindent\n  let g:options = [['cindent', '0', '', '0', '1', 'global', 'setglobal']]\n  setglobal cindent\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 30b: Setting local boolean local (to buffer) option\"\n  noa setglobal nocindent \" Reset global and local value (without triggering autocmd)\n  noa setlocal cindent\n  let g:options = [['cindent', '1', '1', '', '0', 'local', 'setlocal']]\n  setlocal nocindent\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 30c: Setting again boolean local (to buffer) option\"\n  noa setglobal nocindent \" Reset global and local value (without triggering autocmd)\n  noa setlocal cindent\n  let g:options = [['cindent', '1', '1', '0', '1', 'global', 'set']]\n  set cindent\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 30d: Setting again global boolean local (to buffer) option\"\n  noa set nocindent \" Reset global and local value (without triggering autocmd)\n  let g:options = [['cindent', '0', '0', '0', '1', 'global', 'set']]\n  set cindent\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 31: Setting boolean global-local (to window) option\n  \" Currently no such option exists.\n\n\n  \" 32a: Setting global boolean local (to window) option\"\n  noa setglobal nocursorcolumn \" Reset global and local value (without triggering autocmd)\n  noa setlocal cursorcolumn\n  let g:options = [['cursorcolumn', '0', '', '0', '1', 'global', 'setglobal']]\n  setglobal cursorcolumn\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 32b: Setting local boolean local (to window) option\"\n  noa setglobal nocursorcolumn \" Reset global and local value (without triggering autocmd)\n  noa setlocal cursorcolumn\n  let g:options = [['cursorcolumn', '1', '1', '', '0', 'local', 'setlocal']]\n  setlocal nocursorcolumn\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 32c: Setting again boolean local (to window) option\"\n  noa setglobal nocursorcolumn \" Reset global and local value (without triggering autocmd)\n  noa setlocal cursorcolumn\n  let g:options = [['cursorcolumn', '1', '1', '0', '1', 'global', 'set']]\n  set cursorcolumn\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 32d: Setting again global boolean local (to window) option\"\n  noa set nocursorcolumn \" Reset global and local value (without triggering autocmd)\n  let g:options = [['cursorcolumn', '0', '0', '0', '1', 'global', 'set']]\n  set cursorcolumn\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 33: Test autocommands when an option value is converted internally.\n  noa set backspace=1 \" Reset global and local value (without triggering autocmd)\n  let g:options = [['backspace', 'indent,eol', 'indent,eol', 'indent,eol', '2', 'global', 'set']]\n  set backspace=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" Cleanup\n  au! OptionSet\n  \" set tags&\n  for opt in ['nu', 'ai', 'acd', 'ar', 'bs', 'backup', 'cul', 'cp', 'backupext', 'tags', 'spelllang', 'statusline', 'foldignore', 'cmdheight', 'undolevels', 'wrapmargin', 'foldcolumn', 'wrapscan', 'autoread', 'cindent', 'cursorcolumn']\n    exe printf(\":set %s&vim\", opt)\n  endfor\n  call test_override('starting', 0)\n  delfunc! AutoCommandOptionSet\nendfunc\n\nfunc Test_OptionSet_diffmode()\n  call test_override('starting', 1)\n  \" 18: Changing an option when entering diff mode\n  new\n  au OptionSet diff :let &l:cul = v:option_new\n\n  call setline(1, ['buffer 1', 'line2', 'line3', 'line4'])\n  call assert_equal(0, &l:cul)\n  diffthis\n  call assert_equal(1, &l:cul)\n\n  vnew\n  call setline(1, ['buffer 2', 'line 2', 'line 3', 'line4'])\n  call assert_equal(0, &l:cul)\n  diffthis\n  call assert_equal(1, &l:cul)\n\n  diffoff\n  call assert_equal(0, &l:cul)\n  call assert_equal(1, getwinvar(2, '&l:cul'))\n  bw!\n\n  call assert_equal(1, &l:cul)\n  diffoff!\n  call assert_equal(0, &l:cul)\n  call assert_equal(0, getwinvar(1, '&l:cul'))\n  bw!\n\n  \" Cleanup\n  au! OptionSet\n  call test_override('starting', 0)\nendfunc\n\nfunc Test_OptionSet_diffmode_close()\n  call test_override('starting', 1)\n  \" 19: Try to close the current window when entering diff mode\n  \" should not segfault\n  new\n  au OptionSet diff close\n\n  call setline(1, ['buffer 1', 'line2', 'line3', 'line4'])\n  call assert_fails(':diffthis', 'E788:')\n  call assert_equal(1, &diff)\n  vnew\n  call setline(1, ['buffer 2', 'line 2', 'line 3', 'line4'])\n  call assert_fails(':diffthis', 'E788:')\n  call assert_equal(1, &diff)\n  set diffopt-=closeoff\n  bw!\n  call assert_fails(':diffoff!', 'E788:')\n  bw!\n\n  \" Cleanup\n  au! OptionSet\n  call test_override('starting', 0)\n  \"delfunc! AutoCommandOptionSet\nendfunc\n\n\" Test for Bufleave autocommand that deletes the buffer we are about to edit.\nfunc Test_BufleaveWithDelete()\n  new | edit Xfile1\n\n  augroup test_bufleavewithdelete\n      autocmd!\n      autocmd BufLeave Xfile1 bwipe Xfile2\n  augroup END\n\n  call assert_fails('edit Xfile2', 'E143:')\n  call assert_equal('Xfile1', bufname('%'))\n\n  autocmd! test_bufleavewithdelete BufLeave Xfile1\n  augroup! test_bufleavewithdelete\n\n  new\n  bwipe! Xfile1\nendfunc\n\n\" Test for autocommand that changes the buffer list, when doing \":ball\".\nfunc Test_Acmd_BufAll()\n  enew!\n  %bwipe!\n  call writefile(['Test file Xxx1'], 'Xxx1')\n  call writefile(['Test file Xxx2'], 'Xxx2')\n  call writefile(['Test file Xxx3'], 'Xxx3')\n\n  \" Add three files to the buffer list\n  split Xxx1\n  close\n  split Xxx2\n  close\n  split Xxx3\n  close\n\n  \" Wipe the buffer when the buffer is opened\n  au BufReadPost Xxx2 bwipe\n\n  call append(0, 'Test file Xxx4')\n  ball\n\n  call assert_equal(2, winnr('$'))\n  call assert_equal('Xxx1', bufname(winbufnr(winnr('$'))))\n  wincmd t\n\n  au! BufReadPost\n  %bwipe!\n  call delete('Xxx1')\n  call delete('Xxx2')\n  call delete('Xxx3')\n  enew! | only\nendfunc\n\n\" Test for autocommand that changes current buffer on BufEnter event.\n\" Check if modelines are interpreted for the correct buffer.\nfunc Test_Acmd_BufEnter()\n  %bwipe!\n  call writefile(['start of test file Xxx1',\n\t      \\ \"\\<Tab>this is a test\",\n\t      \\ 'end of test file Xxx1'], 'Xxx1')\n  call writefile(['start of test file Xxx2',\n\t      \\ 'vim: set noai :',\n\t      \\ \"\\<Tab>this is a test\",\n\t      \\ 'end of test file Xxx2'], 'Xxx2')\n\n  au BufEnter Xxx2 brew\n  set ai modeline modelines=3\n  edit Xxx1\n  \" edit Xxx2, autocmd will do :brew\n  edit Xxx2\n  exe \"normal G?this is a\\<CR>\"\n  \" Append text with autoindent to this file\n  normal othis should be auto-indented\n  call assert_equal(\"\\<Tab>this should be auto-indented\", getline('.'))\n  call assert_equal(3, line('.'))\n  \" Remove autocmd and edit Xxx2 again\n  au! BufEnter Xxx2\n  buf! Xxx2\n  exe \"normal G?this is a\\<CR>\"\n  \" append text without autoindent to Xxx\n  normal othis should be in column 1\n  call assert_equal(\"this should be in column 1\", getline('.'))\n  call assert_equal(4, line('.'))\n\n  %bwipe!\n  call delete('Xxx1')\n  call delete('Xxx2')\n  set ai&vim modeline&vim modelines&vim\nendfunc\n\n\" Test for issue #57\n\" do not move cursor on <c-o> when autoindent is set\nfunc Test_ai_CTRL_O()\n  enew!\n  set ai\n  let save_fo = &fo\n  set fo+=r\n  exe \"normal o# abcdef\\<Esc>2hi\\<CR>\\<C-O>d0\\<Esc>\"\n  exe \"normal o# abcdef\\<Esc>2hi\\<C-O>d0\\<Esc>\"\n  call assert_equal(['# abc', 'def', 'def'], getline(2, 4))\n\n  set ai&vim\n  let &fo = save_fo\n  enew!\nendfunc\n\n\" Test for autocommand that deletes the current buffer on BufLeave event.\n\" Also test deleting the last buffer, should give a new, empty buffer.\nfunc Test_BufLeave_Wipe()\n  %bwipe!\n  let content = ['start of test file Xxx',\n\t      \\ 'this is a test',\n\t      \\ 'end of test file Xxx']\n  call writefile(content, 'Xxx1')\n  call writefile(content, 'Xxx2')\n\n  au BufLeave Xxx2 bwipe\n  edit Xxx1\n  split Xxx2\n  \" delete buffer Xxx2, we should be back to Xxx1\n  bwipe\n  call assert_equal('Xxx1', bufname('%'))\n  call assert_equal(1, winnr('$'))\n\n  \" Create an alternate buffer\n  %write! test.out\n  call assert_equal('test.out', bufname('#'))\n  \" delete alternate buffer\n  bwipe test.out\n  call assert_equal('Xxx1', bufname('%'))\n  call assert_equal('', bufname('#'))\n\n  au BufLeave Xxx1 bwipe\n  \" delete current buffer, get an empty one\n  bwipe!\n  call assert_equal(1, line('$'))\n  call assert_equal('', bufname('%'))\n  let g:bufinfo = getbufinfo()\n  call assert_equal(1, len(g:bufinfo))\n\n  call delete('Xxx1')\n  call delete('Xxx2')\n  call delete('test.out')\n  %bwipe\n  au! BufLeave\n\n  \" check that bufinfo doesn't contain a pointer to freed memory\n  call test_garbagecollect_now()\nendfunc\n\nfunc Test_QuitPre()\n  edit Xfoo\n  let winid = win_getid(winnr())\n  split Xbar\n  au! QuitPre * let g:afile = expand('<afile>')\n  \" Close the other window, <afile> should be correct.\n  exe win_id2win(winid) . 'q'\n  call assert_equal('Xfoo', g:afile)\n\n  unlet g:afile\n  bwipe Xfoo\n  bwipe Xbar\nendfunc\n\nfunc Test_Cmdline()\n  au! CmdlineChanged : let g:text = getcmdline()\n  let g:text = 0\n  call feedkeys(\":echom 'hello'\\<CR>\", 'xt')\n  call assert_equal(\"echom 'hello'\", g:text)\n  au! CmdlineChanged\n\n  au! CmdlineChanged : let g:entered = expand('<afile>')\n  let g:entered = 0\n  call feedkeys(\":echom 'hello'\\<CR>\", 'xt')\n  call assert_equal(':', g:entered)\n  au! CmdlineChanged\n\n  au! CmdlineEnter : let g:entered = expand('<afile>')\n  au! CmdlineLeave : let g:left = expand('<afile>')\n  let g:entered = 0\n  let g:left = 0\n  call feedkeys(\":echo 'hello'\\<CR>\", 'xt')\n  call assert_equal(':', g:entered)\n  call assert_equal(':', g:left)\n  au! CmdlineEnter\n  au! CmdlineLeave\n\n  let save_shellslash = &shellslash\n  set noshellslash\n  au! CmdlineEnter / let g:entered = expand('<afile>')\n  au! CmdlineLeave / let g:left = expand('<afile>')\n  let g:entered = 0\n  let g:left = 0\n  new\n  call setline(1, 'hello')\n  call feedkeys(\"/hello\\<CR>\", 'xt')\n  call assert_equal('/', g:entered)\n  call assert_equal('/', g:left)\n  bwipe!\n  au! CmdlineEnter\n  au! CmdlineLeave\n  let &shellslash = save_shellslash\nendfunc\n\n\" Test for BufWritePre autocommand that deletes or unloads the buffer.\nfunc Test_BufWritePre()\n  %bwipe\n  au BufWritePre Xxx1 bunload\n  au BufWritePre Xxx2 bwipe\n\n  call writefile(['start of Xxx1', 'test', 'end of Xxx1'], 'Xxx1')\n  call writefile(['start of Xxx2', 'test', 'end of Xxx2'], 'Xxx2')\n\n  edit Xtest\n  e! Xxx2\n  bdel Xtest\n  e Xxx1\n  \" write it, will unload it and give an error msg\n  call assert_fails('w', 'E203:')\n  call assert_equal('Xxx2', bufname('%'))\n  edit Xtest\n  e! Xxx2\n  bwipe Xtest\n  \" write it, will delete the buffer and give an error msg\n  call assert_fails('w', 'E203:')\n  call assert_equal('Xxx1', bufname('%'))\n  au! BufWritePre\n  call delete('Xxx1')\n  call delete('Xxx2')\nendfunc\n\n\" Test for BufUnload autocommand that unloads all the other buffers\nfunc Test_bufunload_all()\n  let g:test_is_flaky = 1\n  call writefile(['Test file Xxx1'], 'Xxx1')\"\n  call writefile(['Test file Xxx2'], 'Xxx2')\"\n\n  let content =<< trim [CODE]\n    func UnloadAllBufs()\n      let i = 1\n      while i <= bufnr('$')\n        if i != bufnr('%') && bufloaded(i)\n          exe  i . 'bunload'\n        endif\n        let i += 1\n      endwhile\n    endfunc\n    au BufUnload * call UnloadAllBufs()\n    au VimLeave * call writefile(['Test Finished'], 'Xout')\n    edit Xxx1\n    split Xxx2\n    q\n  [CODE]\n\n  call writefile(content, 'Xtest')\n\n  call delete('Xout')\n  call system(GetVimCommandClean() .. ' -N --not-a-term -S Xtest')\n  call assert_true(filereadable('Xout'))\n\n  call delete('Xxx1')\n  call delete('Xxx2')\n  call delete('Xtest')\n  call delete('Xout')\nendfunc\n\n\" Some tests for buffer-local autocommands\nfunc Test_buflocal_autocmd()\n  let g:bname = ''\n  edit xx\n  au BufLeave <buffer> let g:bname = expand(\"%\")\n  \" here, autocommand for xx should trigger.\n  \" but autocommand shall not apply to buffer named <buffer>.\n  edit somefile\n  call assert_equal('xx', g:bname)\n  let g:bname = ''\n  \" here, autocommand shall be auto-deleted\n  bwipe xx\n  \" autocmd should not trigger\n  edit xx\n  call assert_equal('', g:bname)\n  \" autocmd should not trigger\n  edit somefile\n  call assert_equal('', g:bname)\n  enew\n  unlet g:bname\nendfunc\n\n\" Test for \"*Cmd\" autocommands\nfunc Test_Cmd_Autocmds()\n  call writefile(['start of Xxx', \"\\tabc2\", 'end of Xxx'], 'Xxx')\n\n  enew!\n  au BufReadCmd XtestA 0r Xxx|$del\n  edit XtestA\t\t\t\" will read text of Xxd instead\n  call assert_equal('start of Xxx', getline(1))\n\n  au BufWriteCmd XtestA call append(line(\"$\"), \"write\")\n  write\t\t\t\t\" will append a line to the file\n  call assert_equal('write', getline('$'))\n  call assert_fails('read XtestA', 'E484:')\t\" should not read anything\n  call assert_equal('write', getline(4))\n\n  \" now we have:\n  \" 1\tstart of Xxx\n  \" 2\t\tabc2\n  \" 3\tend of Xxx\n  \" 4\twrite\n\n  au FileReadCmd XtestB '[r Xxx\n  2r XtestB\t\t\t\" will read Xxx below line 2 instead\n  call assert_equal('start of Xxx', getline(3))\n\n  \" now we have:\n  \" 1\tstart of Xxx\n  \" 2\t\tabc2\n  \" 3\tstart of Xxx\n  \" 4\t\tabc2\n  \" 5\tend of Xxx\n  \" 6\tend of Xxx\n  \" 7\twrite\n\n  au FileWriteCmd XtestC '[,']copy $\n  normal 4GA1\n  4,5w XtestC\t\t\t\" will copy lines 4 and 5 to the end\n  call assert_equal(\"\\tabc21\", getline(8))\n  call assert_fails('r XtestC', 'E484:')\t\" should not read anything\n  call assert_equal(\"end of Xxx\", getline(9))\n\n  \" now we have:\n  \" 1\tstart of Xxx\n  \" 2\t\tabc2\n  \" 3\tstart of Xxx\n  \" 4\t\tabc21\n  \" 5\tend of Xxx\n  \" 6\tend of Xxx\n  \" 7\twrite\n  \" 8\t\tabc21\n  \" 9\tend of Xxx\n\n  let g:lines = []\n  au FileAppendCmd XtestD call extend(g:lines, getline(line(\"'[\"), line(\"']\")))\n  w >>XtestD\t\t\t\" will add lines to 'lines'\n  call assert_equal(9, len(g:lines))\n  call assert_fails('$r XtestD', 'E484:')\t\" should not read anything\n  call assert_equal(9, line('$'))\n  call assert_equal('end of Xxx', getline('$'))\n\n  au BufReadCmd XtestE 0r Xxx|$del\n  sp XtestE\t\t\t\" split window with test.out\n  call assert_equal('end of Xxx', getline(3))\n\n  let g:lines = []\n  exe \"normal 2Goasdf\\<Esc>\\<C-W>\\<C-W>\"\n  au BufWriteCmd XtestE call extend(g:lines, getline(0, '$'))\n  wall\t\t\t\t\" will write other window to 'lines'\n  call assert_equal(4, len(g:lines), g:lines)\n  call assert_equal('asdf', g:lines[2])\n\n  au! BufReadCmd\n  au! BufWriteCmd\n  au! FileReadCmd\n  au! FileWriteCmd\n  au! FileAppendCmd\n  %bwipe!\n  call delete('Xxx')\n  enew!\nendfunc\n\nfunc s:ReadFile()\n  setl noswapfile nomodified\n  let filename = resolve(expand(\"<afile>:p\"))\n  execute 'read' fnameescape(filename)\n  1d_\n  exe 'file' fnameescape(filename)\n  setl buftype=acwrite\nendfunc\n\nfunc s:WriteFile()\n  let filename = resolve(expand(\"<afile>:p\"))\n  setl buftype=\n  noautocmd execute 'write' fnameescape(filename)\n  setl buftype=acwrite\n  setl nomodified\nendfunc\n\nfunc Test_BufReadCmd()\n  autocmd BufReadCmd *.test call s:ReadFile()\n  autocmd BufWriteCmd *.test call s:WriteFile()\n\n  call writefile(['one', 'two', 'three'], 'Xcmd.test')\n  edit Xcmd.test\n  call assert_match('Xcmd.test\" line 1 of 3', execute('file'))\n  normal! Gofour\n  write\n  call assert_equal(['one', 'two', 'three', 'four'], readfile('Xcmd.test'))\n\n  bwipe!\n  call delete('Xcmd.test')\n  au! BufReadCmd\n  au! BufWriteCmd\nendfunc\n\nfunc SetChangeMarks(start, end)\n  exe a:start .. 'mark ['\n  exe a:end .. 'mark ]'\nendfunc\n\n\" Verify the effects of autocmds on '[ and ']\nfunc Test_change_mark_in_autocmds()\n  edit! Xtest\n  call feedkeys(\"ia\\<CR>b\\<CR>c\\<CR>d\\<C-g>u\\<Esc>\", 'xtn')\n\n  call SetChangeMarks(2, 3)\n  write\n  call assert_equal([1, 4], [line(\"'[\"), line(\"']\")])\n\n  call SetChangeMarks(2, 3)\n  au BufWritePre * call assert_equal([1, 4], [line(\"'[\"), line(\"']\")])\n  write\n  au! BufWritePre\n\n  if has('unix')\n    write XtestFilter\n    write >> XtestFilter\n\n    call SetChangeMarks(2, 3)\n    \" Marks are set to the entire range of the write\n    au FilterWritePre * call assert_equal([1, 4], [line(\"'[\"), line(\"']\")])\n    \" '[ is adjusted to just before the line that will receive the filtered\n    \" data\n    au FilterReadPre * call assert_equal([4, 4], [line(\"'[\"), line(\"']\")])\n    \" The filtered data is read into the buffer, and the source lines are\n    \" still present, so the range is after the source lines\n    au FilterReadPost * call assert_equal([5, 12], [line(\"'[\"), line(\"']\")])\n    %!cat XtestFilter\n    \" After the filtered data is read, the original lines are deleted\n    call assert_equal([1, 8], [line(\"'[\"), line(\"']\")])\n    au! FilterWritePre,FilterReadPre,FilterReadPost\n    undo\n\n    call SetChangeMarks(1, 4)\n    au FilterWritePre * call assert_equal([2, 3], [line(\"'[\"), line(\"']\")])\n    au FilterReadPre * call assert_equal([3, 3], [line(\"'[\"), line(\"']\")])\n    au FilterReadPost * call assert_equal([4, 11], [line(\"'[\"), line(\"']\")])\n    2,3!cat XtestFilter\n    call assert_equal([2, 9], [line(\"'[\"), line(\"']\")])\n    au! FilterWritePre,FilterReadPre,FilterReadPost\n    undo\n\n    call delete('XtestFilter')\n  endif\n\n  call SetChangeMarks(1, 4)\n  au FileWritePre * call assert_equal([2, 3], [line(\"'[\"), line(\"']\")])\n  2,3write Xtest2\n  au! FileWritePre\n\n  call SetChangeMarks(2, 3)\n  au FileAppendPre * call assert_equal([1, 4], [line(\"'[\"), line(\"']\")])\n  write >> Xtest2\n  au! FileAppendPre\n\n  call SetChangeMarks(1, 4)\n  au FileAppendPre * call assert_equal([2, 3], [line(\"'[\"), line(\"']\")])\n  2,3write >> Xtest2\n  au! FileAppendPre\n\n  call SetChangeMarks(1, 1)\n  au FileReadPre * call assert_equal([3, 1], [line(\"'[\"), line(\"']\")])\n  au FileReadPost * call assert_equal([4, 11], [line(\"'[\"), line(\"']\")])\n  3read Xtest2\n  au! FileReadPre,FileReadPost\n  undo\n\n  call SetChangeMarks(4, 4)\n  \" When the line is 0, it's adjusted to 1\n  au FileReadPre * call assert_equal([1, 4], [line(\"'[\"), line(\"']\")])\n  au FileReadPost * call assert_equal([1, 8], [line(\"'[\"), line(\"']\")])\n  0read Xtest2\n  au! FileReadPre,FileReadPost\n  undo\n\n  call SetChangeMarks(4, 4)\n  \" When the line is 0, it's adjusted to 1\n  au FileReadPre * call assert_equal([1, 4], [line(\"'[\"), line(\"']\")])\n  au FileReadPost * call assert_equal([2, 9], [line(\"'[\"), line(\"']\")])\n  1read Xtest2\n  au! FileReadPre,FileReadPost\n  undo\n\n  bwipe!\n  call delete('Xtest')\n  call delete('Xtest2')\nendfunc\n\nfunc Test_Filter_noshelltemp()\n  CheckExecutable cat\n\n  enew!\n  call setline(1, ['a', 'b', 'c', 'd'])\n\n  let shelltemp = &shelltemp\n  set shelltemp\n\n  let g:filter_au = 0\n  au FilterWritePre * let g:filter_au += 1\n  au FilterReadPre * let g:filter_au += 1\n  au FilterReadPost * let g:filter_au += 1\n  %!cat\n  call assert_equal(3, g:filter_au)\n\n  if has('filterpipe')\n    set noshelltemp\n\n    let g:filter_au = 0\n    au FilterWritePre * let g:filter_au += 1\n    au FilterReadPre * let g:filter_au += 1\n    au FilterReadPost * let g:filter_au += 1\n    %!cat\n    call assert_equal(0, g:filter_au)\n  endif\n\n  au! FilterWritePre,FilterReadPre,FilterReadPost\n  let &shelltemp = shelltemp\n  bwipe!\nendfunc\n\nfunc Test_TextYankPost()\n  enew!\n  call setline(1, ['foo'])\n\n  let g:event = []\n  au TextYankPost * let g:event = copy(v:event)\n\n  call assert_equal({}, v:event)\n  call assert_fails('let v:event = {}', 'E46:')\n  call assert_fails('let v:event.mykey = 0', 'E742:')\n\n  norm \"ayiw\n  call assert_equal(\n        \\ #{regcontents: ['foo'], regname: 'a', operator: 'y',\n        \\   regtype: 'v', visual: v:false, inclusive: v:true},\n        \\ g:event)\n  norm y_\n  call assert_equal(\n        \\ #{regcontents: ['foo'], regname: '',  operator: 'y', regtype: 'V',\n        \\   visual: v:false, inclusive: v:false},\n        \\ g:event)\n  norm Vy\n  call assert_equal(\n        \\ #{regcontents: ['foo'], regname: '',  operator: 'y', regtype: 'V',\n        \\   visual: v:true, inclusive: v:true},\n        \\ g:event)\n  call feedkeys(\"\\<C-V>y\", 'x')\n  call assert_equal(\n        \\ #{regcontents: ['f'], regname: '',  operator: 'y', regtype: \"\\x161\",\n        \\   visual: v:true, inclusive: v:true},\n        \\ g:event)\n  norm \"xciwbar\n  call assert_equal(\n        \\ #{regcontents: ['foo'], regname: 'x', operator: 'c', regtype: 'v',\n        \\   visual: v:false, inclusive: v:true},\n        \\ g:event)\n  norm \"bdiw\n  call assert_equal(\n        \\ #{regcontents: ['bar'], regname: 'b', operator: 'd', regtype: 'v',\n        \\   visual: v:false, inclusive: v:true},\n        \\ g:event)\n\n  call setline(1, 'foobar')\n  \" exclusive motion\n  norm $\"ay0\n  call assert_equal(\n        \\ #{regcontents: ['fooba'], regname: 'a', operator: 'y', regtype: 'v',\n        \\   visual: v:false, inclusive: v:false},\n        \\ g:event)\n  \" inclusive motion\n  norm 0\"ay$\n  call assert_equal(\n        \\ #{regcontents: ['foobar'], regname: 'a', operator: 'y', regtype: 'v',\n        \\   visual: v:false, inclusive: v:true},\n        \\ g:event)\n\n  call assert_equal({}, v:event)\n\n  if has('clipboard_working') && !has('gui_running')\n    \" Test that when the visual selection is automatically copied to clipboard\n    \" register a TextYankPost is emitted\n    call setline(1, ['foobar'])\n\n    let @* = ''\n    set clipboard=autoselect\n    exe \"norm! ggviw\\<Esc>\"\n    call assert_equal(\n          \\ #{regcontents: ['foobar'], regname: '*', operator: 'y',\n          \\   regtype: 'v', visual: v:true, inclusive: v:false},\n          \\ g:event)\n\n    let @+ = ''\n    set clipboard=autoselectplus\n    exe \"norm! ggviw\\<Esc>\"\n    call assert_equal(\n          \\ #{regcontents: ['foobar'], regname: '+', operator: 'y',\n          \\   regtype: 'v', visual: v:true, inclusive: v:false},\n          \\ g:event)\n\n    set clipboard&vim\n  endif\n\n  au! TextYankPost\n  unlet g:event\n  bwipe!\nendfunc\n\nfunc Test_autocommand_all_events()\n  call assert_fails('au * * bwipe', 'E1155:')\n  call assert_fails('au * x bwipe', 'E1155:')\n  call assert_fails('au! * x bwipe', 'E1155:')\nendfunc\n\nfunc Test_autocmd_user()\n  au User MyEvent let s:res = [expand(\"<afile>\"), expand(\"<amatch>\")]\n  doautocmd User MyEvent\n  call assert_equal(['MyEvent', 'MyEvent'], s:res)\n  au! User\n  unlet s:res\nendfunc\n\nfunction s:Before_test_dirchanged()\n  augroup test_dirchanged\n    autocmd!\n  augroup END\n  let s:li = []\n  let s:dir_this = getcwd()\n  let s:dir_foo = s:dir_this . '/Xfoo'\n  call mkdir(s:dir_foo)\n  let s:dir_bar = s:dir_this . '/Xbar'\n  call mkdir(s:dir_bar)\nendfunc\n\nfunction s:After_test_dirchanged()\n  call chdir(s:dir_this)\n  call delete(s:dir_foo, 'd')\n  call delete(s:dir_bar, 'd')\n  augroup test_dirchanged\n    autocmd!\n  augroup END\nendfunc\n\nfunction Test_dirchanged_global()\n  call s:Before_test_dirchanged()\n  autocmd test_dirchanged DirChangedPre global call add(s:li, expand(\"<amatch>\") .. \" pre cd \" .. v:event.directory)\n  autocmd test_dirchanged DirChanged global call add(s:li, \"cd:\")\n  autocmd test_dirchanged DirChanged global call add(s:li, expand(\"<afile>\"))\n  call chdir(s:dir_foo)\n  let expected = [\"global pre cd \" .. s:dir_foo, \"cd:\", s:dir_foo]\n  call assert_equal(expected, s:li)\n  call chdir(s:dir_foo)\n  call assert_equal(expected, s:li)\n  exe 'lcd ' .. fnameescape(s:dir_bar)\n  call assert_equal(expected, s:li)\n\n  exe 'cd ' .. s:dir_foo\n  exe 'cd ' .. s:dir_bar\n  autocmd! test_dirchanged DirChanged global let g:result = expand(\"<afile>\")\n  cd -\n  call assert_equal(s:dir_foo, substitute(g:result, '\\\\', '/', 'g'))\n\n  call s:After_test_dirchanged()\nendfunc\n\nfunction Test_dirchanged_local()\n  call s:Before_test_dirchanged()\n  autocmd test_dirchanged DirChanged window call add(s:li, \"lcd:\")\n  autocmd test_dirchanged DirChanged window call add(s:li, expand(\"<afile>\"))\n  call chdir(s:dir_foo)\n  call assert_equal([], s:li)\n  exe 'lcd ' .. fnameescape(s:dir_bar)\n  call assert_equal([\"lcd:\", s:dir_bar], s:li)\n  exe 'lcd ' .. fnameescape(s:dir_bar)\n  call assert_equal([\"lcd:\", s:dir_bar], s:li)\n  call s:After_test_dirchanged()\nendfunc\n\nfunction Test_dirchanged_auto()\n  CheckOption autochdir\n  call s:Before_test_dirchanged()\n  call test_autochdir()\n  autocmd test_dirchanged DirChangedPre auto call add(s:li, \"pre cd \" .. v:event.directory)\n  autocmd test_dirchanged DirChanged auto call add(s:li, \"auto:\")\n  autocmd test_dirchanged DirChanged auto call add(s:li, expand(\"<afile>\"))\n  set acd\n  cd ..\n  call assert_equal([], s:li)\n  exe 'edit ' . s:dir_foo . '/Xfile'\n  call assert_equal(s:dir_foo, getcwd())\n  let expected = [\"pre cd \" .. s:dir_foo, \"auto:\", s:dir_foo]\n  call assert_equal(expected, s:li)\n  set noacd\n  bwipe!\n  call s:After_test_dirchanged()\nendfunc\n\n\" Test TextChangedI and TextChangedP\nfunc Test_ChangedP()\n  new\n  call setline(1, ['foo', 'bar', 'foobar'])\n  call test_override(\"char_avail\", 1)\n  set complete=. completeopt=menuone\n\n  func! TextChangedAutocmd(char)\n    let g:autocmd .= a:char\n  endfunc\n\n  \" TextChanged will not be triggered, only check that it isn't.\n  au! TextChanged <buffer> :call TextChangedAutocmd('N')\n  au! TextChangedI <buffer> :call TextChangedAutocmd('I')\n  au! TextChangedP <buffer> :call TextChangedAutocmd('P')\n\n  call cursor(3, 1)\n  let g:autocmd = ''\n  call feedkeys(\"o\\<esc>\", 'tnix')\n  call assert_equal('I', g:autocmd)\n\n  let g:autocmd = ''\n  call feedkeys(\"Sf\", 'tnix')\n  call assert_equal('II', g:autocmd)\n\n  let g:autocmd = ''\n  call feedkeys(\"Sf\\<C-N>\", 'tnix')\n  call assert_equal('IIP', g:autocmd)\n\n  let g:autocmd = ''\n  call feedkeys(\"Sf\\<C-N>\\<C-N>\", 'tnix')\n  call assert_equal('IIPP', g:autocmd)\n\n  let g:autocmd = ''\n  call feedkeys(\"Sf\\<C-N>\\<C-N>\\<C-N>\", 'tnix')\n  call assert_equal('IIPPP', g:autocmd)\n\n  let g:autocmd = ''\n  call feedkeys(\"Sf\\<C-N>\\<C-N>\\<C-N>\\<C-N>\", 'tnix')\n  call assert_equal('IIPPPP', g:autocmd)\n\n  call assert_equal(['foo', 'bar', 'foobar', 'foo'], getline(1, '$'))\n  \" TODO: how should it handle completeopt=noinsert,noselect?\n\n  \" CleanUp\n  call test_override(\"char_avail\", 0)\n  au! TextChanged\n  au! TextChangedI\n  au! TextChangedP\n  delfu TextChangedAutocmd\n  unlet! g:autocmd\n  set complete&vim completeopt&vim\n\n  bw!\nendfunc\n\nlet g:setline_handled = v:false\nfunc SetLineOne()\n  if !g:setline_handled\n    call setline(1, \"(x)\")\n    let g:setline_handled = v:true\n  endif\nendfunc\n\nfunc Test_TextChangedI_with_setline()\n  new\n  call test_override('char_avail', 1)\n  autocmd TextChangedI <buffer> call SetLineOne()\n  call feedkeys(\"i(\\<CR>\\<Esc>\", 'tx')\n  call assert_equal('(', getline(1))\n  call assert_equal('x)', getline(2))\n  undo\n  call assert_equal('', getline(1))\n  call assert_equal('', getline(2))\n\n  call test_override('char_avail', 0)\n  bwipe!\nendfunc\n\nfunc Test_Changed_FirstTime()\n  CheckFeature terminal\n  CheckNotGui\n  \" Starting a terminal to run Vim is always considered flaky.\n  let g:test_is_flaky = 1\n\n  \" Prepare file for TextChanged event.\n  call writefile([''], 'Xchanged.txt')\n  let buf = term_start([GetVimProg(), '--clean', '-c', 'set noswapfile'], {'term_rows': 3})\n  call assert_equal('running', term_getstatus(buf))\n  \" Wait for the ruler (in the status line) to be shown.\n  \" In ConPTY, there is additional character which is drawn up to the width of\n  \" the screen.\n  if has('conpty')\n    call WaitForAssert({-> assert_match('\\<All.*$', term_getline(buf, 3))})\n  else\n    call WaitForAssert({-> assert_match('\\<All$', term_getline(buf, 3))})\n  endif\n  \" It's only adding autocmd, so that no event occurs.\n  call term_sendkeys(buf, \":au! TextChanged <buffer> call writefile(['No'], 'Xchanged.txt')\\<cr>\")\n  call term_sendkeys(buf, \"\\<C-\\\\>\\<C-N>:qa!\\<cr>\")\n  call WaitForAssert({-> assert_equal('finished', term_getstatus(buf))})\n  call assert_equal([''], readfile('Xchanged.txt'))\n\n  \" clean up\n  call delete('Xchanged.txt')\n  bwipe!\nendfunc\n\nfunc Test_autocmd_nested()\n  let g:did_nested = 0\n  augroup Testing\n    au WinNew * edit somefile\n    au BufNew * let g:did_nested = 1\n  augroup END\n  split\n  call assert_equal(0, g:did_nested)\n  close\n  bwipe! somefile\n\n  \" old nested argument still works\n  augroup Testing\n    au!\n    au WinNew * nested edit somefile\n    au BufNew * let g:did_nested = 1\n  augroup END\n  split\n  call assert_equal(1, g:did_nested)\n  close\n  bwipe! somefile\n\n  \" New ++nested argument works\n  augroup Testing\n    au!\n    au WinNew * ++nested edit somefile\n    au BufNew * let g:did_nested = 1\n  augroup END\n  split\n  call assert_equal(1, g:did_nested)\n  close\n  bwipe! somefile\n\n  \" nested without ++ does not work in Vim9 script\n  call assert_fails('vim9cmd au WinNew * nested echo fails', 'E1078:')\n\n  augroup Testing\n    au!\n  augroup END\n\n  call assert_fails('au WinNew * ++nested ++nested echo bad', 'E983:')\n  call assert_fails('au WinNew * nested nested echo bad', 'E983:')\nendfunc\n\nfunc Test_autocmd_once()\n  \" Without ++once WinNew triggers twice\n  let g:did_split = 0\n  augroup Testing\n    au WinNew * let g:did_split += 1\n  augroup END\n  split\n  split\n  call assert_equal(2, g:did_split)\n  call assert_true(exists('#WinNew'))\n  close\n  close\n\n  \" With ++once WinNew triggers once\n  let g:did_split = 0\n  augroup Testing\n    au!\n    au WinNew * ++once let g:did_split += 1\n  augroup END\n  split\n  split\n  call assert_equal(1, g:did_split)\n  call assert_false(exists('#WinNew'))\n  close\n  close\n\n  call assert_fails('au WinNew * ++once ++once echo bad', 'E983:')\nendfunc\n\nfunc Test_autocmd_bufreadpre()\n  new\n  let b:bufreadpre = 1\n  call append(0, range(1000))\n  w! XAutocmdBufReadPre.txt\n  autocmd BufReadPre <buffer> :let b:bufreadpre += 1\n  norm! 500gg\n  sp\n  norm! 1000gg\n  wincmd p\n  let g:wsv1 = winsaveview()\n  wincmd p\n  let g:wsv2 = winsaveview()\n  \" triggers BufReadPre, should not move the cursor in either window\n  \" The topline may change one line in a large window.\n  edit\n  call assert_inrange(g:wsv2.topline - 1, g:wsv2.topline + 1, winsaveview().topline)\n  call assert_equal(g:wsv2.lnum, winsaveview().lnum)\n  call assert_equal(2, b:bufreadpre)\n  wincmd p\n  call assert_equal(g:wsv1.topline, winsaveview().topline)\n  call assert_equal(g:wsv1.lnum, winsaveview().lnum)\n  call assert_equal(2, b:bufreadpre)\n  \" Now set the cursor position in an BufReadPre autocommand\n  \" (even though the position will be invalid, this should make Vim reset the\n  \" cursor position in the other window.\n  wincmd p\n  set cpo+=g\n  \" won't do anything, but try to set the cursor on an invalid lnum\n  autocmd BufReadPre <buffer> :norm! 70gg\n  \" triggers BufReadPre, should not move the cursor in either window\n  e\n  call assert_equal(1, winsaveview().topline)\n  call assert_equal(1, winsaveview().lnum)\n  call assert_equal(3, b:bufreadpre)\n  wincmd p\n  call assert_equal(g:wsv1.topline, winsaveview().topline)\n  call assert_equal(g:wsv1.lnum, winsaveview().lnum)\n  call assert_equal(3, b:bufreadpre)\n  close\n  close\n  call delete('XAutocmdBufReadPre.txt')\n  set cpo-=g\nendfunc\n\n\" FileChangedShell tested in test_filechanged.vim\n\n\" Tests for the following autocommands:\n\" - FileWritePre\twriting a compressed file\n\" - FileReadPost\treading a compressed file\n\" - BufNewFile\t\treading a file template\n\" - BufReadPre\t\tdecompressing the file to be read\n\" - FilterReadPre\tsubstituting characters in the temp file\n\" - FilterReadPost\tsubstituting characters after filtering\n\" - FileReadPre\t\tset options for decompression\n\" - FileReadPost\tdecompress the file\nfunc Test_ReadWrite_Autocmds()\n  \" Run this test only on Unix-like systems and if gzip is available\n  CheckUnix\n  CheckExecutable gzip\n\n  \" Make $GZIP empty, \"-v\" would cause trouble.\n  let $GZIP = \"\"\n\n  \" Use a FileChangedShell autocommand to avoid a prompt for 'Xtestfile.gz'\n  \" being modified outside of Vim (noticed on Solaris).\n  au FileChangedShell * echo 'caught FileChangedShell'\n\n  \" Test for the FileReadPost, FileWritePre and FileWritePost autocmds\n  augroup Test1\n    au!\n    au FileWritePre    *.gz   '[,']!gzip\n    au FileWritePost   *.gz   undo\n    au FileReadPost    *.gz   '[,']!gzip -d\n  augroup END\n\n  new\n  set bin\n  call append(0, [\n\t      \\ 'line 2\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 3\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 4\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 5\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 6\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 7\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 8\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 9\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 10 Abcdefghijklmnopqrstuvwxyz'\n\t      \\ ])\n  1,9write! Xtestfile.gz\n  enew! | close\n\n  new\n  \" Read and decompress the testfile\n  0read Xtestfile.gz\n  call assert_equal([\n\t      \\ 'line 2\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 3\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 4\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 5\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 6\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 7\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 8\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 9\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 10 Abcdefghijklmnopqrstuvwxyz'\n\t      \\ ], getline(1, 9))\n  enew! | close\n\n  augroup Test1\n    au!\n  augroup END\n\n  \" Test for the FileAppendPre and FileAppendPost autocmds\n  augroup Test2\n    au!\n    au BufNewFile      *.c    read Xtest.c\n    au FileAppendPre   *.out  '[,']s/new/NEW/\n    au FileAppendPost  *.out  !cat Xtest.c >> test.out\n  augroup END\n\n  call writefile(['/*', ' * Here is a new .c file', ' */'], 'Xtest.c')\n  new foo.c\t\t\t\" should load Xtest.c\n  call assert_equal(['/*', ' * Here is a new .c file', ' */'], getline(2, 4))\n  w! >> test.out\t\t\" append it to the output file\n\n  let contents = readfile('test.out')\n  call assert_equal(' * Here is a NEW .c file', contents[2])\n  call assert_equal(' * Here is a new .c file', contents[5])\n\n  call delete('test.out')\n  enew! | close\n  augroup Test2\n    au!\n  augroup END\n\n  \" Test for the BufReadPre and BufReadPost autocmds\n  augroup Test3\n    au!\n    \" setup autocommands to decompress before reading and re-compress\n    \" afterwards\n    au BufReadPre  *.gz  exe '!gzip -d ' . shellescape(expand(\"<afile>\"))\n    au BufReadPre  *.gz  call rename(expand(\"<afile>:r\"), expand(\"<afile>\"))\n    au BufReadPost *.gz  call rename(expand(\"<afile>\"), expand(\"<afile>:r\"))\n    au BufReadPost *.gz  exe '!gzip ' . shellescape(expand(\"<afile>:r\"))\n  augroup END\n\n  e! Xtestfile.gz\t\t\" Edit compressed file\n  call assert_equal([\n\t      \\ 'line 2\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 3\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 4\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 5\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 6\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 7\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 8\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 9\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 10 Abcdefghijklmnopqrstuvwxyz'\n\t      \\ ], getline(1, 9))\n\n  w! >> test.out\t\t\" Append it to the output file\n\n  augroup Test3\n    au!\n  augroup END\n\n  \" Test for the FilterReadPre and FilterReadPost autocmds.\n  set shelltemp\t\t\t\" need temp files here\n  augroup Test4\n    au!\n    au FilterReadPre   *.out  call rename(expand(\"<afile>\"), expand(\"<afile>\") . \".t\")\n    au FilterReadPre   *.out  exe 'silent !sed s/e/E/ ' . shellescape(expand(\"<afile>\")) . \".t >\" . shellescape(expand(\"<afile>\"))\n    au FilterReadPre   *.out  exe 'silent !rm ' . shellescape(expand(\"<afile>\")) . '.t'\n    au FilterReadPost  *.out  '[,']s/x/X/g\n  augroup END\n\n  e! test.out\t\t\t\" Edit the output file\n  1,$!cat\n  call assert_equal([\n\t      \\ 'linE 2\tAbcdefghijklmnopqrstuvwXyz',\n\t      \\ 'linE 3\tXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX',\n\t      \\ 'linE 4\tAbcdefghijklmnopqrstuvwXyz',\n\t      \\ 'linE 5\tXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX',\n\t      \\ 'linE 6\tAbcdefghijklmnopqrstuvwXyz',\n\t      \\ 'linE 7\tXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX',\n\t      \\ 'linE 8\tAbcdefghijklmnopqrstuvwXyz',\n\t      \\ 'linE 9\tXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX',\n\t      \\ 'linE 10 AbcdefghijklmnopqrstuvwXyz'\n\t      \\ ], getline(1, 9))\n  call assert_equal([\n\t      \\ 'line 2\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 3\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 4\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 5\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 6\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 7\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 8\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 9\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 10 Abcdefghijklmnopqrstuvwxyz'\n\t      \\ ], readfile('test.out'))\n\n  augroup Test4\n    au!\n  augroup END\n  set shelltemp&vim\n\n  \" Test for the FileReadPre and FileReadPost autocmds.\n  augroup Test5\n    au!\n    au FileReadPre *.gz exe 'silent !gzip -d ' . shellescape(expand(\"<afile>\"))\n    au FileReadPre *.gz call rename(expand(\"<afile>:r\"), expand(\"<afile>\"))\n    au FileReadPost *.gz '[,']s/l/L/\n  augroup END\n\n  new\n  0r Xtestfile.gz\t\t\" Read compressed file\n  call assert_equal([\n\t      \\ 'Line 2\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'Line 3\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'Line 4\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'Line 5\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'Line 6\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'Line 7\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'Line 8\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'Line 9\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'Line 10 Abcdefghijklmnopqrstuvwxyz'\n\t      \\ ], getline(1, 9))\n  call assert_equal([\n\t      \\ 'line 2\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 3\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 4\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 5\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 6\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 7\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 8\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 9\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 10 Abcdefghijklmnopqrstuvwxyz'\n\t      \\ ], readfile('Xtestfile.gz'))\n\n  augroup Test5\n    au!\n  augroup END\n\n  au! FileChangedShell\n  call delete('Xtestfile.gz')\n  call delete('Xtest.c')\n  call delete('test.out')\nendfunc\n\nfunc Test_throw_in_BufWritePre()\n  new\n  call setline(1, ['one', 'two', 'three'])\n  call assert_false(filereadable('Xthefile'))\n  augroup throwing\n    au BufWritePre X* throw 'do not write'\n  augroup END\n  try\n    w Xthefile\n  catch\n    let caught = 1\n  endtry\n  call assert_equal(1, caught)\n  call assert_false(filereadable('Xthefile'))\n\n  bwipe!\n  au! throwing\nendfunc\n\nfunc Test_autocmd_in_try_block()\n  call mkdir('Xdir')\n  au BufEnter * let g:fname = expand('%')\n  try\n    edit Xdir/\n  endtry\n  call assert_match('Xdir', g:fname)\n\n  unlet g:fname\n  au! BufEnter\n  call delete('Xdir', 'rf')\nendfunc\n\nfunc Test_autocmd_SafeState()\n  CheckRunVimInTerminal\n  let g:test_is_flaky = 1\n\n  let lines =<< trim END\n\tlet g:safe = 0\n\tlet g:again = ''\n\tau SafeState * let g:safe += 1\n\tau SafeStateAgain * let g:again ..= 'x'\n\tfunc CallTimer()\n\t  call timer_start(10, {id -> execute('let g:again ..= \"t\"')})\n\tendfunc\n  END\n  call writefile(lines, 'XSafeState')\n  let buf = RunVimInTerminal('-S XSafeState', #{rows: 6})\n\n  \" Sometimes we loop to handle a K_IGNORE, SafeState may be triggered once or\n  \" more often.\n  call term_sendkeys(buf, \":echo g:safe\\<CR>\")\n  call WaitForAssert({-> assert_match('^\\d ', term_getline(buf, 6))}, 1000)\n\n  \" SafeStateAgain should be invoked at least three times\n  call term_sendkeys(buf, \":echo g:again\\<CR>\")\n  call WaitForAssert({-> assert_match('^xxx', term_getline(buf, 6))}, 1000)\n\n  call term_sendkeys(buf, \":let g:again = ''\\<CR>:call CallTimer()\\<CR>\")\n  call TermWait(buf, 50)\n  call term_sendkeys(buf, \":\\<CR>\")\n  call TermWait(buf, 50)\n  call term_sendkeys(buf, \":echo g:again\\<CR>\")\n  call WaitForAssert({-> assert_match('xtx', term_getline(buf, 6))}, 1000)\n\n  call StopVimInTerminal(buf)\n  call delete('XSafeState')\nendfunc\n\nfunc Test_autocmd_CmdWinEnter()\n  CheckRunVimInTerminal\n  CheckFeature cmdwin\n\n  let lines =<< trim END\n    augroup vimHints | au! | augroup END\n    let b:dummy_var = 'This is a dummy'\n    autocmd CmdWinEnter * quit\n    let winnr = winnr('$')\n  END\n  let filename = 'XCmdWinEnter'\n  call writefile(lines, filename)\n  let buf = RunVimInTerminal('-S '.filename, #{rows: 6})\n\n  call term_sendkeys(buf, \"q:\")\n  call TermWait(buf)\n  call term_sendkeys(buf, \":echo b:dummy_var\\<cr>\")\n  call WaitForAssert({-> assert_match('^This is a dummy', term_getline(buf, 6))}, 2000)\n  call term_sendkeys(buf, \":echo &buftype\\<cr>\")\n  call WaitForAssert({-> assert_notmatch('^nofile', term_getline(buf, 6))}, 1000)\n  call term_sendkeys(buf, \":echo winnr\\<cr>\")\n  call WaitForAssert({-> assert_match('^1', term_getline(buf, 6))}, 1000)\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete(filename)\nendfunc\n\nfunc Test_autocmd_was_using_freed_memory()\n  CheckFeature quickfix\n\n  pedit xx\n  n x\n  augroup winenter\n    au WinEnter * if winnr('$') > 2 | quit | endif\n  augroup END\n  split\n\n  augroup winenter\n    au! WinEnter\n  augroup END\n\n  bwipe xx\n  bwipe x\n  pclose\nendfunc\n\nfunc Test_BufWrite_lockmarks()\n  let g:test_is_flaky = 1\n  edit! Xtest\n  call setline(1, ['a', 'b', 'c', 'd'])\n\n  \" :lockmarks preserves the marks\n  call SetChangeMarks(2, 3)\n  lockmarks write\n  call assert_equal([2, 3], [line(\"'[\"), line(\"']\")])\n\n  \" *WritePre autocmds get the correct line range, but lockmarks preserves the\n  \" original values for the user\n  augroup lockmarks\n    au!\n    au BufWritePre,FilterWritePre * call assert_equal([1, 4], [line(\"'[\"), line(\"']\")])\n    au FileWritePre * call assert_equal([3, 4], [line(\"'[\"), line(\"']\")])\n  augroup END\n\n  lockmarks write\n  call assert_equal([2, 3], [line(\"'[\"), line(\"']\")])\n\n  if executable('cat')\n    lockmarks %!cat\n    call assert_equal([2, 3], [line(\"'[\"), line(\"']\")])\n  endif\n\n  lockmarks 3,4write Xtest2\n  call assert_equal([2, 3], [line(\"'[\"), line(\"']\")])\n\n  au! lockmarks\n  augroup! lockmarks\n  call delete('Xtest')\n  call delete('Xtest2')\nendfunc\n\nfunc Test_FileType_spell()\n  if !isdirectory('/tmp')\n    throw \"Skipped: requires /tmp directory\"\n  endif\n\n  \" this was crashing with an invalid free()\n  setglobal spellfile=/tmp/en.utf-8.add\n  augroup crash\n    autocmd!\n    autocmd BufNewFile,BufReadPost crashfile setf somefiletype\n    autocmd BufNewFile,BufReadPost crashfile set ft=anotherfiletype\n    autocmd FileType anotherfiletype setlocal spell\n  augroup END\n  func! NoCrash() abort\n    edit /tmp/crashfile\n  endfunc\n  call NoCrash()\n\n  au! crash\n  setglobal spellfile=\nendfunc\n\n\" Test closing a window or editing another buffer from a FileChangedRO handler\n\" in a readonly buffer\nfunc Test_FileChangedRO_winclose()\n  call test_override('ui_delay', 10)\n\n  augroup FileChangedROTest\n    au!\n    autocmd FileChangedRO * quit\n  augroup END\n  new\n  set readonly\n  call assert_fails('normal i', 'E788:')\n  close\n  augroup! FileChangedROTest\n\n  augroup FileChangedROTest\n    au!\n    autocmd FileChangedRO * edit Xfile\n  augroup END\n  new\n  set readonly\n  call assert_fails('normal i', 'E788:')\n  close\n  augroup! FileChangedROTest\n  call test_override('ALL', 0)\nendfunc\n\nfunc LogACmd()\n  call add(g:logged, line('$'))\nendfunc\n\nfunc Test_TermChanged()\n  CheckNotGui\n\n  enew!\n  tabnew\n  call setline(1, ['a', 'b', 'c', 'd'])\n  $\n  au TermChanged * call LogACmd()\n  let g:logged = []\n  let term_save = &term\n  set term=xterm\n  call assert_equal([1, 4], g:logged)\n\n  au! TermChanged\n  let &term = term_save\n  bwipe!\nendfunc\n\n\" Test for FileReadCmd autocmd\nfunc Test_autocmd_FileReadCmd()\n  func ReadFileCmd()\n    call append(line('$'), \"v:cmdarg = \" .. v:cmdarg)\n  endfunc\n  augroup FileReadCmdTest\n    au!\n    au FileReadCmd Xtest call ReadFileCmd()\n  augroup END\n\n  new\n  read ++bin Xtest\n  read ++nobin Xtest\n  read ++edit Xtest\n  read ++bad=keep Xtest\n  read ++bad=drop Xtest\n  read ++bad=- Xtest\n  read ++ff=unix Xtest\n  read ++ff=dos Xtest\n  read ++ff=mac Xtest\n  read ++enc=utf-8 Xtest\n\n  call assert_equal(['',\n        \\ 'v:cmdarg =  ++bin',\n        \\ 'v:cmdarg =  ++nobin',\n        \\ 'v:cmdarg =  ++edit',\n        \\ 'v:cmdarg =  ++bad=keep',\n        \\ 'v:cmdarg =  ++bad=drop',\n        \\ 'v:cmdarg =  ++bad=-',\n        \\ 'v:cmdarg =  ++ff=unix',\n        \\ 'v:cmdarg =  ++ff=dos',\n        \\ 'v:cmdarg =  ++ff=mac',\n        \\ 'v:cmdarg =  ++enc=utf-8'], getline(1, '$'))\n\n  close!\n  augroup FileReadCmdTest\n    au!\n  augroup END\n  delfunc ReadFileCmd\nendfunc\n\n\" Test for passing invalid arguments to autocmd\nfunc Test_autocmd_invalid_args()\n  \" Additional character after * for event\n  call assert_fails('autocmd *a Xfile set ff=unix', 'E215:')\n  augroup Test\n  augroup END\n  \" Invalid autocmd event\n  call assert_fails('autocmd Bufabc Xfile set ft=vim', 'E216:')\n  \" Invalid autocmd event in a autocmd group\n  call assert_fails('autocmd Test Bufabc Xfile set ft=vim', 'E216:')\n  augroup! Test\n  \" Execute all autocmds\n  call assert_fails('doautocmd * BufEnter', 'E217:')\n  call assert_fails('augroup! x1a2b3', 'E367:')\n  call assert_fails('autocmd BufNew <buffer=999> pwd', 'E680:')\n  call assert_fails('autocmd BufNew \\) set ff=unix', 'E55:')\nendfunc\n\n\" Test for deep nesting of autocmds\nfunc Test_autocmd_deep_nesting()\n  autocmd BufEnter Xfile doautocmd BufEnter Xfile\n  call assert_fails('doautocmd BufEnter Xfile', 'E218:')\n  autocmd! BufEnter Xfile\nendfunc\n\n\" Tests for SigUSR1 autocmd event, which is only available on posix systems.\nfunc Test_autocmd_sigusr1()\n  CheckUnix\n  CheckExecutable /bin/kill\n\n  let g:sigusr1_passed = 0\n  au SigUSR1 * let g:sigusr1_passed = 1\n  call system('/bin/kill -s usr1 ' . getpid())\n  call WaitForAssert({-> assert_true(g:sigusr1_passed)})\n\n  au! SigUSR1\n  unlet g:sigusr1_passed\nendfunc\n\n\" Test for BufReadPre autocmd deleting the file\nfunc Test_BufReadPre_delfile()\n  augroup TestAuCmd\n    au!\n    autocmd BufReadPre Xfile call delete('Xfile')\n  augroup END\n  call writefile([], 'Xfile')\n  call assert_fails('new Xfile', 'E200:')\n  call assert_equal('Xfile', @%)\n  call assert_equal(1, &readonly)\n  call delete('Xfile')\n  augroup TestAuCmd\n    au!\n  augroup END\n  close!\nendfunc\n\n\" Test for BufReadPre autocmd changing the current buffer\nfunc Test_BufReadPre_changebuf()\n  augroup TestAuCmd\n    au!\n    autocmd BufReadPre Xfile edit Xsomeotherfile\n  augroup END\n  call writefile([], 'Xfile')\n  call assert_fails('new Xfile', 'E201:')\n  call assert_equal('Xsomeotherfile', @%)\n  call assert_equal(1, &readonly)\n  call delete('Xfile')\n  augroup TestAuCmd\n    au!\n  augroup END\n  close!\nendfunc\n\n\" Test for BufWipeouti autocmd changing the current buffer when reading a file\n\" in an empty buffer with 'f' flag in 'cpo'\nfunc Test_BufDelete_changebuf()\n  new\n  augroup TestAuCmd\n    au!\n    autocmd BufWipeout * let bufnr = bufadd('somefile') | exe \"b \" .. bufnr\n  augroup END\n  let save_cpo = &cpo\n  set cpo+=f\n  call assert_fails('r Xfile', ['E812:', 'E484:'])\n  call assert_equal('somefile', @%)\n  let &cpo = save_cpo\n  augroup TestAuCmd\n    au!\n  augroup END\n  close!\nendfunc\n\n\" Test for the temporary internal window used to execute autocmds\nfunc Test_autocmd_window()\n  %bw!\n  edit one.txt\n  tabnew two.txt\n  vnew three.txt\n  tabnew four.txt\n  tabprevious\n  let g:blist = []\n  augroup aucmd_win_test1\n    au!\n    au BufEnter * call add(g:blist, [expand('<afile>'),\n          \\ win_gettype(bufwinnr(expand('<afile>')))])\n  augroup END\n\n  doautoall BufEnter\n  call assert_equal([\n        \\ ['one.txt', 'autocmd'],\n        \\ ['two.txt', ''],\n        \\ ['four.txt', 'autocmd'],\n        \\ ['three.txt', ''],\n        \\ ], g:blist)\n\n  augroup aucmd_win_test1\n    au!\n  augroup END\n  augroup! aucmd_win_test1\n  %bw!\nendfunc\n\n\" Test for trying to close the temporary window used for executing an autocmd\nfunc Test_close_autocmd_window()\n  %bw!\n  edit one.txt\n  tabnew two.txt\n  augroup aucmd_win_test2\n    au!\n    au BufEnter * if expand('<afile>') == 'one.txt' | 1close | endif\n  augroup END\n\n  call assert_fails('doautoall BufEnter', 'E813:')\n\n  augroup aucmd_win_test2\n    au!\n  augroup END\n  augroup! aucmd_win_test2\n  %bwipe!\nendfunc\n\n\" Test for trying to close the tab that has the temporary window for exeucing\n\" an autocmd.\nfunc Test_close_autocmd_tab()\n  edit one.txt\n  tabnew two.txt\n   augroup aucmd_win_test\n    au!\n    au BufEnter * if expand('<afile>') == 'one.txt' | tabfirst | tabonly | endif\n  augroup END\n\n  call assert_fails('doautoall BufEnter', 'E813:')\n\n  tabonly\n  augroup aucmd_win_test\n    au!\n  augroup END\n  augroup! aucmd_win_test\n  %bwipe!\nendfunc\n\nfunc Test_Visual_doautoall_redraw()\n  call setline(1, ['a', 'b'])\n  new \n  wincmd p\n  call feedkeys(\"G\\<C-V>\", 'txn')\n  autocmd User Explode ++once redraw\n  doautoall User Explode\n  %bwipe!\nendfunc\n\n\" This was using freed memory.\nfunc Test_BufNew_arglocal()\n  arglocal\n  au BufNew * arglocal\n  call assert_fails('drop xx', 'E1156:')\n\n  au! BufNew\nendfunc\n\nfunc Test_autocmd_closes_window()\n  au BufNew,BufWinLeave * e %e\n  file yyy\n  au BufNew,BufWinLeave * ball\n  n xxx\n\n  %bwipe\n  au! BufNew\n  au! BufWinLeave\nendfunc\n\nfunc Test_autocmd_quit_psearch()\n  sn aa bb\n  augroup aucmd_win_test\n    au!\n    au BufEnter,BufLeave,BufNew,WinEnter,WinLeave,WinNew * if winnr('$') > 1 | q | endif\n  augroup END\n  ps /\n\n  augroup aucmd_win_test\n    au!\n  augroup END\n  new\n  pclose\nendfunc\n\n\" Fuzzer found some strange combination that caused a crash.\nfunc Test_autocmd_normal_mess()\n  \" For unknown reason this hangs on MS-Windows\n  CheckNotMSWindows\n\n  augroup aucmd_normal_test\n    au BufLeave,BufWinLeave,BufHidden,BufUnload,BufDelete,BufWipeout * norm 7q/qc\n  augroup END\n  call assert_fails('o4', 'E1159')\n  silent! H\n  call assert_fails('e xx', 'E1159')\n  normal G\n\n  augroup aucmd_normal_test\n    au!\n  augroup END\nendfunc\n\nfunc Test_autocmd_closing_cmdwin()\n  \" For unknown reason this hangs on MS-Windows\n  CheckNotMSWindows\n\n  au BufWinLeave * nested q\n  call assert_fails(\"norm 7q?\\n\", 'E855:')\n\n  au! BufWinLeave\n  new\n  only\nendfunc\n\nfunc Test_autocmd_vimgrep()\n  augroup aucmd_vimgrep\n    au QuickfixCmdPre,BufNew,BufReadCmd * sb\n    au QuickfixCmdPre,BufNew,BufReadCmd * q9\n  augroup END\n  call assert_fails('lv ?a? foo', 'E926:')\n\n  augroup aucmd_vimgrep\n    au!\n  augroup END\nendfunc\n\nfunc Test_autocmd_with_block()\n  augroup block_testing\n    au BufReadPost *.xml {\n            setlocal matchpairs+=<:>\n            /<start\n          }\n    au CursorHold * {\n        autocmd BufReadPre * ++once echo 'one' | echo 'two'\n        g:gotSafeState = 77\n      }\n  augroup END\n\n  let expected = \"\\n--- Autocommands ---\\nblock_testing  BufRead\\n    *.xml     {^@            setlocal matchpairs+=<:>^@            /<start^@          }\"\n  call assert_equal(expected, execute('au BufReadPost *.xml'))\n\n  doautocmd CursorHold\n  call assert_equal(77, g:gotSafeState)\n  unlet g:gotSafeState\n\n  augroup block_testing\n    au!\n    autocmd CursorHold * {\n      if true\n        # comment\n        && true\n\n        && true\n        g:done = 'yes'\n      endif\n      }\n  augroup END\n  doautocmd CursorHold\n  call assert_equal('yes', g:done)\n\n  unlet g:done\n  augroup block_testing\n    au!\n  augroup END\nendfunc\n\n\" Test TextChangedI and TextChanged\nfunc Test_Changed_ChangedI()\n  new\n  call test_override(\"char_avail\", 1)\n  let [g:autocmd_i, g:autocmd_n] = ['','']\n\n  func! TextChangedAutocmdI(char)\n    let g:autocmd_{tolower(a:char)} = a:char .. b:changedtick\n  endfunc\n\n  augroup Test_TextChanged\n    au!\n    au TextChanged  <buffer> :call TextChangedAutocmdI('N')\n    au TextChangedI <buffer> :call TextChangedAutocmdI('I')\n  augroup END\n\n  call feedkeys(\"ifoo\\<esc>\", 'tnix')\n  \" TODO: Test test does not seem to trigger TextChanged autocommand, this\n  \" requires running Vim in a terminal window.\n  \" call assert_equal('N3', g:autocmd_n)\n  call assert_equal('I3', g:autocmd_i)\n\n  call feedkeys(\"yyp\", 'tnix')\n  \" TODO: Test test does not seem to trigger TextChanged autocommand.\n  \" call assert_equal('N4', g:autocmd_n)\n  call assert_equal('I3', g:autocmd_i)\n\n  \" CleanUp\n  call test_override(\"char_avail\", 0)\n  au! TextChanged  <buffer>\n  au! TextChangedI <buffer>\n  augroup! Test_TextChanged\n  delfu TextChangedAutocmdI\n  unlet! g:autocmd_i g:autocmd_n\n\n  bw!\nendfunc\n\nfunc Test_closing_autocmd_window()\n  let lines =<< trim END\n      edit Xa.txt\n      tabnew Xb.txt\n      autocmd BufEnter Xa.txt unhide 1\n      doautoall BufEnter\n  END\n  call v9.CheckScriptFailure(lines, 'E814:')\n  au! BufEnter\n  only!\n  bwipe Xa.txt\n  bwipe Xb.txt\nendfunc\n\nfunc Test_bufwipeout_changes_window()\n  \" This should not crash, but we don't have any expectations about what\n  \" happens, changing window in BufWipeout has unpredictable results.\n  tabedit\n  let g:window_id = win_getid()\n  topleft new\n  setlocal bufhidden=wipe\n  autocmd BufWipeout <buffer> call win_gotoid(g:window_id)\n  tabprevious\n  +tabclose\n\n  unlet g:window_id\n  au! BufWipeout\n  %bwipe!\nendfunc\n\nfunc Test_v_event_readonly()\n  autocmd CompleteChanged * let v:event.width = 0\n  call assert_fails(\"normal! i\\<C-X>\\<C-V>\", 'E46:')\n  au! CompleteChanged\n\n  autocmd DirChangedPre * let v:event.directory = ''\n  call assert_fails('cd .', 'E46:')\n  au! DirChangedPre\n\n  autocmd ModeChanged * let v:event.new_mode = ''\n  call assert_fails('normal! cc', 'E46:')\n  au! ModeChanged\n\n  autocmd TextYankPost * let v:event.operator = ''\n  call assert_fails('normal! yy', 'E46:')\n  au! TextYankPost\nendfunc\n\n\nfunc Test_noname_autocmd()\n  augroup test_noname_autocmd_group\n    autocmd!\n    autocmd BufEnter * call add(s:li, [\"BufEnter\", expand(\"<afile>\")])\n    autocmd BufDelete * call add(s:li, [\"BufDelete\", expand(\"<afile>\")])\n    autocmd BufLeave * call add(s:li, [\"BufLeave\", expand(\"<afile>\")])\n    autocmd BufUnload * call add(s:li, [\"BufUnload\", expand(\"<afile>\")])\n    autocmd BufWipeout * call add(s:li, [\"BufWipeout\", expand(\"<afile>\")])\n  augroup END\n\n  let s:li = []\n  edit foo\n  call assert_equal([['BufUnload', ''], ['BufDelete', ''], ['BufWipeout', ''], ['BufEnter', 'foo']], s:li)\n\n  au! test_noname_autocmd_group\n  augroup! test_noname_autocmd_group\nendfunc\n\n\" Test for the autocmd_get() function\nfunc Test_autocmd_get()\n  augroup TestAutoCmdFns\n    au!\n    autocmd BufAdd *.vim echo \"bufadd-vim\"\n    autocmd BufAdd *.py echo \"bufadd-py\"\n    autocmd BufHidden *.vim echo \"bufhidden\"\n  augroup END\n  augroup TestAutoCmdFns2\n    autocmd BufAdd *.vim echo \"bufadd-vim-2\"\n    autocmd BufRead *.a1b2c3 echo \"bufadd-vim-2\"\n  augroup END\n\n  let l = autocmd_get()\n  call assert_true(l->len() > 0)\n\n  \" Test for getting all the autocmds in a group\n  let expected = [\n        \\ #{cmd: 'echo \"bufadd-vim\"', group: 'TestAutoCmdFns',\n        \\  pattern: '*.vim', nested: v:false, once: v:false,\n        \\  event: 'BufAdd'},\n        \\ #{cmd: 'echo \"bufadd-py\"', group: 'TestAutoCmdFns',\n        \\  pattern: '*.py', nested: v:false, once: v:false,\n        \\  event: 'BufAdd'},\n        \\ #{cmd: 'echo \"bufhidden\"', group: 'TestAutoCmdFns',\n        \\  pattern: '*.vim', nested: v:false,\n        \\  once: v:false, event: 'BufHidden'}]\n  call assert_equal(expected, autocmd_get(#{group: 'TestAutoCmdFns'}))\n\n  \" Test for getting autocmds for all the patterns in a group\n  call assert_equal(expected, autocmd_get(#{group: 'TestAutoCmdFns',\n        \\ event: '*'}))\n\n  \" Test for getting autocmds for an event in a group\n  let expected = [\n        \\ #{cmd: 'echo \"bufadd-vim\"', group: 'TestAutoCmdFns',\n        \\  pattern: '*.vim', nested: v:false, once: v:false,\n        \\  event: 'BufAdd'},\n        \\ #{cmd: 'echo \"bufadd-py\"', group: 'TestAutoCmdFns',\n        \\  pattern: '*.py', nested: v:false, once: v:false,\n        \\  event: 'BufAdd'}]\n  call assert_equal(expected, autocmd_get(#{group: 'TestAutoCmdFns',\n        \\ event: 'BufAdd'}))\n\n  \" Test for getting the autocmds for all the events in a group for particular\n  \" pattern\n  call assert_equal([{'cmd': 'echo \"bufadd-py\"', 'group': 'TestAutoCmdFns',\n        \\ 'pattern': '*.py', 'nested': v:false, 'once': v:false,\n        \\ 'event': 'BufAdd'}],\n        \\ autocmd_get(#{group: 'TestAutoCmdFns', event: '*', pattern: '*.py'}))\n\n  \" Test for getting the autocmds for an events in a group for particular\n  \" pattern\n  let l = autocmd_get(#{group: 'TestAutoCmdFns', event: 'BufAdd',\n        \\ pattern: '*.vim'})\n  call assert_equal([\n        \\ #{cmd: 'echo \"bufadd-vim\"', group: 'TestAutoCmdFns',\n        \\  pattern: '*.vim', nested: v:false, once: v:false,\n        \\  event: 'BufAdd'}], l)\n\n  \" Test for getting the autocmds for a pattern in a group\n  let l = autocmd_get(#{group: 'TestAutoCmdFns', pattern: '*.vim'})\n  call assert_equal([\n        \\ #{cmd: 'echo \"bufadd-vim\"', group: 'TestAutoCmdFns',\n        \\  pattern: '*.vim', nested: v:false, once: v:false,\n        \\  event: 'BufAdd'},\n        \\ #{cmd: 'echo \"bufhidden\"', group: 'TestAutoCmdFns',\n        \\  pattern: '*.vim', nested: v:false,\n        \\  once: v:false, event: 'BufHidden'}], l)\n\n  \" Test for getting the autocmds for a pattern in all the groups\n  let l = autocmd_get(#{pattern: '*.a1b2c3'})\n  call assert_equal([{'cmd': 'echo \"bufadd-vim-2\"', 'group': 'TestAutoCmdFns2',\n        \\ 'pattern': '*.a1b2c3', 'nested': v:false, 'once': v:false,\n        \\ 'event': 'BufRead'}], l)\n\n  \" Test for getting autocmds for a pattern without any autocmds\n  call assert_equal([], autocmd_get(#{group: 'TestAutoCmdFns',\n        \\ pattern: '*.abc'}))\n  call assert_equal([], autocmd_get(#{group: 'TestAutoCmdFns',\n        \\ event: 'BufAdd', pattern: '*.abc'}))\n  call assert_equal([], autocmd_get(#{group: 'TestAutoCmdFns',\n        \\ event: 'BufWipeout'}))\n  call assert_fails(\"call autocmd_get(#{group: 'abc', event: 'BufAdd'})\",\n        \\ 'E367:')\n  let cmd = \"echo autocmd_get(#{group: 'TestAutoCmdFns', event: 'abc'})\"\n  call assert_fails(cmd, 'E216:')\n  call assert_fails(\"call autocmd_get(#{group: 'abc'})\", 'E367:')\n  call assert_fails(\"echo autocmd_get(#{event: 'abc'})\", 'E216:')\n\n  augroup TestAutoCmdFns\n    au!\n  augroup END\n  call assert_equal([], autocmd_get(#{group: 'TestAutoCmdFns'}))\n\n  \" Test for nested and once autocmds\n  augroup TestAutoCmdFns\n    au!\n    autocmd VimSuspend * ++nested echo \"suspend\"\n    autocmd VimResume * ++once echo \"resume\"\n  augroup END\n\n  let expected = [\n        \\ {'cmd': 'echo \"suspend\"', 'group': 'TestAutoCmdFns', 'pattern': '*',\n        \\ 'nested': v:true, 'once': v:false, 'event': 'VimSuspend'},\n        \\ {'cmd': 'echo \"resume\"', 'group': 'TestAutoCmdFns', 'pattern': '*',\n        \\  'nested': v:false, 'once': v:true, 'event': 'VimResume'}]\n  call assert_equal(expected, autocmd_get(#{group: 'TestAutoCmdFns'}))\n\n  \" Test for buffer-local autocmd\n  augroup TestAutoCmdFns\n    au!\n    autocmd TextYankPost <buffer> echo \"textyankpost\"\n  augroup END\n\n  let expected = [\n        \\ {'cmd': 'echo \"textyankpost\"', 'group': 'TestAutoCmdFns',\n        \\  'pattern': '<buffer=' .. bufnr() .. '>', 'nested': v:false,\n        \\  'once': v:false, 'bufnr': bufnr(), 'event': 'TextYankPost'}]\n  call assert_equal(expected, autocmd_get(#{group: 'TestAutoCmdFns'}))\n\n  augroup TestAutoCmdFns\n    au!\n  augroup END\n  augroup! TestAutoCmdFns\n  augroup TestAutoCmdFns2\n    au!\n  augroup END\n  augroup! TestAutoCmdFns2\n\n  call assert_fails(\"echo autocmd_get(#{group: []})\", 'E730:')\n  call assert_fails(\"echo autocmd_get(#{event: {}})\", 'E731:')\n  call assert_fails(\"echo autocmd_get([])\", 'E1206:')\nendfunc\n\n\" Test for the autocmd_add() function\nfunc Test_autocmd_add()\n  \" Define a single autocmd in a group\n  call autocmd_add([#{group: 'TestAcSet', event: 'BufAdd', pattern: '*.sh',\n        \\ cmd: 'echo \"bufadd\"', once: v:true, nested: v:true}])\n  call assert_equal([#{cmd: 'echo \"bufadd\"', group: 'TestAcSet',\n        \\ pattern: '*.sh', nested: v:true, once: v:true,\n        \\ event: 'BufAdd'}], autocmd_get(#{group: 'TestAcSet'}))\n\n  \" Define two autocmds in the same group\n  call autocmd_delete([#{group: 'TestAcSet'}])\n  call autocmd_add([#{group: 'TestAcSet', event: 'BufAdd', pattern: '*.sh',\n        \\ cmd: 'echo \"bufadd\"'},\n        \\ #{group: 'TestAcSet', event: 'BufEnter', pattern: '*.sh',\n        \\   cmd: 'echo \"bufenter\"'}])\n  call assert_equal([\n        \\ #{cmd: 'echo \"bufadd\"', group: 'TestAcSet', pattern: '*.sh',\n        \\   nested: v:false, once: v:false, event: 'BufAdd'},\n        \\ #{cmd: 'echo \"bufenter\"', group: 'TestAcSet', pattern: '*.sh',\n        \\   nested: v:false, once: v:false, event: 'BufEnter'}],\n        \\   autocmd_get(#{group: 'TestAcSet'}))\n\n  \" Define a buffer-local autocmd\n  call autocmd_delete([#{group: 'TestAcSet'}])\n  call autocmd_add([#{group: 'TestAcSet', event: 'CursorHold',\n        \\ bufnr: bufnr(), cmd: 'echo \"cursorhold\"'}])\n  call assert_equal([\n        \\ #{cmd: 'echo \"cursorhold\"', group: 'TestAcSet',\n        \\   pattern: '<buffer=' .. bufnr() .. '>', nested: v:false,\n        \\   once: v:false, bufnr: bufnr(), event: 'CursorHold'}],\n        \\   autocmd_get(#{group: 'TestAcSet'}))\n\n  \" Use an invalid buffer number\n  call autocmd_delete([#{group: 'TestAcSet'}])\n  call autocmd_add([#{group: 'TestAcSet', event: 'BufEnter',\n        \\ bufnr: -1, cmd: 'echo \"bufenter\"'}])\n  let l = [#{group: 'TestAcSet', event: 'BufAdd', bufnr: 9999,\n        \\ cmd: 'echo \"bufadd\"'}]\n  call assert_fails(\"echo autocmd_add(l)\", 'E680:')\n  let l = [#{group: 'TestAcSet', event: 'BufAdd', bufnr: 9999,\n        \\ pattern: '*.py', cmd: 'echo \"bufadd\"'}]\n  call assert_fails(\"echo autocmd_add(l)\", 'E680:')\n  let l = [#{group: 'TestAcSet', event: 'BufAdd', bufnr: 9999,\n        \\ pattern: ['*.py', '*.c'], cmd: 'echo \"bufadd\"'}]\n  call assert_fails(\"echo autocmd_add(l)\", 'E680:')\n  let l = [#{group: 'TestAcSet', event: 'BufRead', bufnr: [],\n        \\ cmd: 'echo \"bufread\"'}]\n  call assert_fails(\"echo autocmd_add(l)\", 'E745:')\n  call assert_equal([], autocmd_get(#{group: 'TestAcSet'}))\n\n  \" Add two commands to the same group, event and pattern\n  call autocmd_delete([#{group: 'TestAcSet'}])\n  call autocmd_add([#{group: 'TestAcSet', event: 'BufUnload',\n        \\ pattern: 'abc', cmd: 'echo \"cmd1\"'}])\n  call autocmd_add([#{group: 'TestAcSet', event: 'BufUnload',\n        \\ pattern: 'abc', cmd: 'echo \"cmd2\"'}])\n  call assert_equal([\n        \\ #{cmd: 'echo \"cmd1\"', group: 'TestAcSet', pattern: 'abc',\n        \\   nested: v:false,  once: v:false, event: 'BufUnload'},\n        \\ #{cmd: 'echo \"cmd2\"', group: 'TestAcSet', pattern: 'abc',\n        \\   nested: v:false,  once: v:false, event: 'BufUnload'}],\n        \\   autocmd_get(#{group: 'TestAcSet'}))\n\n  \" When adding a new autocmd, if the autocmd 'group' is not specified, then\n  \" the current autocmd group should be used.\n  call autocmd_delete([#{group: 'TestAcSet'}])\n  augroup TestAcSet\n    call autocmd_add([#{event: 'BufHidden', pattern: 'abc', cmd: 'echo \"abc\"'}])\n  augroup END\n  call assert_equal([\n        \\ #{cmd: 'echo \"abc\"', group: 'TestAcSet', pattern: 'abc',\n        \\   nested: v:false,  once: v:false, event: 'BufHidden'}],\n        \\   autocmd_get(#{group: 'TestAcSet'}))\n\n  \" Test for replacing a cmd for an event in a group\n  call autocmd_delete([#{group: 'TestAcSet'}])\n  call autocmd_add([#{replace: v:true, group: 'TestAcSet', event: 'BufEnter',\n        \\ pattern: '*.py', cmd: 'echo \"bufenter\"'}])\n  call autocmd_add([#{replace: v:true, group: 'TestAcSet', event: 'BufEnter',\n        \\ pattern: '*.py', cmd: 'echo \"bufenter\"'}])\n  call assert_equal([\n        \\ #{cmd: 'echo \"bufenter\"', group: 'TestAcSet', pattern: '*.py',\n        \\   nested: v:false,  once: v:false, event: 'BufEnter'}],\n        \\   autocmd_get(#{group: 'TestAcSet'}))\n\n  \" Test for adding a command for an unsupported autocmd event\n  let l = [#{group: 'TestAcSet', event: 'abc', pattern: '*.sh',\n        \\ cmd: 'echo \"bufadd\"'}]\n  call assert_fails('call autocmd_add(l)', 'E216:')\n\n  \" Test for using a list of events and patterns\n  call autocmd_delete([#{group: 'TestAcSet'}])\n  let l = [#{group: 'TestAcSet', event: ['BufEnter', 'BufLeave'],\n        \\ pattern: ['*.py', '*.sh'], cmd: 'echo \"bufcmds\"'}]\n  call autocmd_add(l)\n  call assert_equal([\n        \\ #{cmd: 'echo \"bufcmds\"', group: 'TestAcSet', pattern: '*.py',\n        \\   nested: v:false,  once: v:false, event: 'BufEnter'},\n        \\ #{cmd: 'echo \"bufcmds\"', group: 'TestAcSet', pattern: '*.sh',\n        \\   nested: v:false,  once: v:false, event: 'BufEnter'},\n        \\ #{cmd: 'echo \"bufcmds\"', group: 'TestAcSet', pattern: '*.py',\n        \\   nested: v:false,  once: v:false, event: 'BufLeave'},\n        \\ #{cmd: 'echo \"bufcmds\"', group: 'TestAcSet', pattern: '*.sh',\n        \\   nested: v:false,  once: v:false, event: 'BufLeave'}],\n        \\   autocmd_get(#{group: 'TestAcSet'}))\n\n  \" Test for invalid values for 'event' item\n  call autocmd_delete([#{group: 'TestAcSet'}])\n  let l = [#{group: 'TestAcSet', event: test_null_string(),\n        \\ pattern: \"*.py\", cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E928:')\n  let l = [#{group: 'TestAcSet', event: test_null_list(),\n        \\ pattern: \"*.py\", cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E714:')\n  let l = [#{group: 'TestAcSet', event: {},\n        \\ pattern: \"*.py\", cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E777:')\n  let l = [#{group: 'TestAcSet', event: [{}],\n        \\ pattern: \"*.py\", cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E928:')\n  let l = [#{group: 'TestAcSet', event: [test_null_string()],\n        \\ pattern: \"*.py\", cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E928:')\n  let l = [#{group: 'TestAcSet', event: 'BufEnter,BufLeave',\n        \\ pattern: '*.py', cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E216:')\n  let l = [#{group: 'TestAcSet', event: [],\n        \\ pattern: \"*.py\", cmd: 'echo \"bufcmds\"'}]\n  call autocmd_add(l)\n  let l = [#{group: 'TestAcSet', event: [\"\"],\n        \\ pattern: \"*.py\", cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E216:')\n  let l = [#{group: 'TestAcSet', event: \"\",\n        \\ pattern: \"*.py\", cmd: 'echo \"bufcmds\"'}]\n  call autocmd_add(l)\n  call assert_equal([], autocmd_get(#{group: 'TestAcSet'}))\n\n  \" Test for invalid values for 'pattern' item\n  let l = [#{group: 'TestAcSet', event: \"BufEnter\",\n        \\ pattern: test_null_string(), cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E928:')\n  let l = [#{group: 'TestAcSet', event: \"BufEnter\",\n        \\ pattern: test_null_list(), cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E714:')\n  let l = [#{group: 'TestAcSet', event: \"BufEnter\",\n        \\ pattern: {}, cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E777:')\n  let l = [#{group: 'TestAcSet', event: \"BufEnter\",\n        \\ pattern: [{}], cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E928:')\n  let l = [#{group: 'TestAcSet', event: \"BufEnter\",\n        \\ pattern: [test_null_string()], cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E928:')\n  let l = [#{group: 'TestAcSet', event: \"BufEnter\",\n        \\ pattern: [], cmd: 'echo \"bufcmds\"'}]\n  call autocmd_add(l)\n  let l = [#{group: 'TestAcSet', event: \"BufEnter\",\n        \\ pattern: [\"\"], cmd: 'echo \"bufcmds\"'}]\n  call autocmd_add(l)\n  let l = [#{group: 'TestAcSet', event: \"BufEnter\",\n        \\ pattern: \"\", cmd: 'echo \"bufcmds\"'}]\n  call autocmd_add(l)\n  call assert_equal([], autocmd_get(#{group: 'TestAcSet'}))\n\n  let l = [#{group: 'TestAcSet', event: 'BufEnter,abc,BufLeave',\n        \\ pattern: '*.py', cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E216:')\n\n  call assert_fails(\"call autocmd_add({})\", 'E1211:')\n  call assert_equal(v:false,  autocmd_add(test_null_list()))\n  call assert_true(autocmd_add([[]]))\n  call assert_true(autocmd_add([test_null_dict()]))\n\n  augroup TestAcSet\n    au!\n  augroup END\n\n  call autocmd_add([#{group: 'TestAcSet'}])\n  call autocmd_add([#{group: 'TestAcSet', event: 'BufAdd'}])\n  call autocmd_add([#{group: 'TestAcSet', pat: '*.sh'}])\n  call autocmd_add([#{group: 'TestAcSet', cmd: 'echo \"a\"'}])\n  call autocmd_add([#{group: 'TestAcSet', event: 'BufAdd', pat: '*.sh'}])\n  call autocmd_add([#{group: 'TestAcSet', event: 'BufAdd', cmd: 'echo \"a\"'}])\n  call autocmd_add([#{group: 'TestAcSet', pat: '*.sh', cmd: 'echo \"a\"'}])\n  call assert_equal([], autocmd_get(#{group: 'TestAcSet'}))\n\n  augroup! TestAcSet\nendfunc\n\n\" Test for deleting autocmd events and groups\nfunc Test_autocmd_delete()\n  \" Delete an event in an autocmd group\n  augroup TestAcSet\n    au!\n    au BufAdd *.sh echo \"bufadd\"\n    au BufEnter *.sh echo \"bufenter\"\n  augroup END\n  call autocmd_delete([#{group: 'TestAcSet', event: 'BufAdd'}])\n  call assert_equal([#{cmd: 'echo \"bufenter\"', group: 'TestAcSet',\n        \\ pattern: '*.sh', nested: v:false, once: v:false,\n        \\ event: 'BufEnter'}], autocmd_get(#{group: 'TestAcSet'}))\n\n  \" Delete all the events in an autocmd group\n  augroup TestAcSet\n    au BufAdd *.sh echo \"bufadd\"\n  augroup END\n  call autocmd_delete([#{group: 'TestAcSet', event: '*'}])\n  call assert_equal([], autocmd_get(#{group: 'TestAcSet'}))\n\n  \" Delete a non-existing autocmd group\n  call assert_fails(\"call autocmd_delete([#{group: 'abc'}])\", 'E367:')\n  \" Delete a non-existing autocmd event\n  let l = [#{group: 'TestAcSet', event: 'abc'}]\n  call assert_fails(\"call autocmd_delete(l)\", 'E216:')\n  \" Delete a non-existing autocmd pattern\n  let l = [#{group: 'TestAcSet', event: 'BufAdd', pat: 'abc'}]\n  call assert_true(autocmd_delete(l))\n  \" Delete an autocmd for a non-existing buffer\n  let l = [#{event: '*', bufnr: 9999, cmd: 'echo \"x\"'}]\n  call assert_fails('call autocmd_delete(l)', 'E680:')\n\n  \" Delete an autocmd group\n  augroup TestAcSet\n    au!\n    au BufAdd *.sh echo \"bufadd\"\n    au BufEnter *.sh echo \"bufenter\"\n  augroup END\n  call autocmd_delete([#{group: 'TestAcSet'}])\n  call assert_fails(\"call autocmd_get(#{group: 'TestAcSet'})\", 'E367:')\n\n  call assert_true(autocmd_delete([[]]))\n  call assert_true(autocmd_delete([test_null_dict()]))\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read a list of people who contributed.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\nstatic void cmd_with_count(char *cmd, char_u *bufp, size_t bufsize, long Prenum);\nstatic void win_init(win_T *newp, win_T *oldp, int flags);\nstatic void win_init_some(win_T *newp, win_T *oldp);\nstatic void frame_comp_pos(frame_T *topfrp, int *row, int *col);\nstatic void frame_setheight(frame_T *curfrp, int height);\nstatic void frame_setwidth(frame_T *curfrp, int width);\nstatic void win_exchange(long);\nstatic void win_rotate(int, int);\nstatic void win_totop(int size, int flags);\nstatic void win_equal_rec(win_T *next_curwin, int current, frame_T *topfr, int dir, int col, int row, int width, int height);\nstatic void trigger_winclosed(win_T *win);\nstatic win_T *win_free_mem(win_T *win, int *dirp, tabpage_T *tp);\nstatic frame_T *win_altframe(win_T *win, tabpage_T *tp);\nstatic tabpage_T *alt_tabpage(void);\nstatic win_T *frame2win(frame_T *frp);\nstatic int frame_has_win(frame_T *frp, win_T *wp);\nstatic void frame_new_height(frame_T *topfrp, int height, int topfirst, int wfh);\nstatic int frame_fixed_height(frame_T *frp);\nstatic int frame_fixed_width(frame_T *frp);\nstatic void frame_add_statusline(frame_T *frp);\nstatic void frame_new_width(frame_T *topfrp, int width, int leftfirst, int wfw);\nstatic void frame_add_vsep(frame_T *frp);\nstatic int frame_minwidth(frame_T *topfrp, win_T *next_curwin);\nstatic void frame_fix_width(win_T *wp);\nstatic int win_alloc_firstwin(win_T *oldwin);\nstatic void new_frame(win_T *wp);\nstatic tabpage_T *alloc_tabpage(void);\nstatic int leave_tabpage(buf_T *new_curbuf, int trigger_leave_autocmds);\nstatic void enter_tabpage(tabpage_T *tp, buf_T *old_curbuf, int trigger_enter_autocmds, int trigger_leave_autocmds);\nstatic void frame_fix_height(win_T *wp);\nstatic int frame_minheight(frame_T *topfrp, win_T *next_curwin);\nstatic int may_open_tabpage(void);\nstatic int win_enter_ext(win_T *wp, int flags);\nstatic void win_free(win_T *wp, tabpage_T *tp);\nstatic void win_append(win_T *after, win_T *wp);\nstatic void frame_append(frame_T *after, frame_T *frp);\nstatic void frame_insert(frame_T *before, frame_T *frp);\nstatic void frame_remove(frame_T *frp);\nstatic void win_goto_ver(int up, long count);\nstatic void win_goto_hor(int left, long count);\nstatic void frame_add_height(frame_T *frp, int n);\nstatic void last_status_rec(frame_T *fr, int statusline);\n\nstatic void make_snapshot_rec(frame_T *fr, frame_T **frp);\nstatic void clear_snapshot(tabpage_T *tp, int idx);\nstatic void clear_snapshot_rec(frame_T *fr);\nstatic int check_snapshot_rec(frame_T *sn, frame_T *fr);\nstatic win_T *restore_snapshot_rec(frame_T *sn, frame_T *fr);\nstatic win_T *get_snapshot_curwin(int idx);\n\nstatic int frame_check_height(frame_T *topfrp, int height);\nstatic int frame_check_width(frame_T *topfrp, int width);\n\nstatic win_T *win_alloc(win_T *after, int hidden);\n\n#define NOWIN\t\t((win_T *)-1)\t// non-existing window\n\n#define ROWS_AVAIL (Rows - p_ch - tabline_height())\n\n// flags for win_enter_ext()\n#define WEE_UNDO_SYNC\t\t\t0x01\n#define WEE_CURWIN_INVALID\t\t0x02\n#define WEE_TRIGGER_NEW_AUTOCMDS\t0x04\n#define WEE_TRIGGER_ENTER_AUTOCMDS\t0x08\n#define WEE_TRIGGER_LEAVE_AUTOCMDS\t0x10\n#define WEE_ALLOW_PARSE_MESSAGES\t0x20\n\nstatic char *m_onlyone = N_(\"Already only one window\");\n\n// When non-zero splitting a window is forbidden.  Used to avoid that nasty\n// autocommands mess up the window structure.\nstatic int split_disallowed = 0;\n\n// #define WIN_DEBUG\n#ifdef WIN_DEBUG\n/*\n * Call this method to log the current window layout.\n */\n    static void\nlog_frame_layout(frame_T *frame)\n{\n    ch_log(NULL, \"layout %s, wi: %d, he: %d, wwi: %d, whe: %d, id: %d\",\n\t    frame->fr_layout == FR_LEAF ? \"LEAF\"\n\t\t\t\t  : frame->fr_layout == FR_ROW ? \"ROW\" : \"COL\",\n\t    frame->fr_width,\n\t    frame->fr_height,\n\t    frame->fr_win == NULL ? -1 : frame->fr_win->w_width,\n\t    frame->fr_win == NULL ? -1 : frame->fr_win->w_height,\n\t    frame->fr_win == NULL ? -1 : frame->fr_win->w_id);\n    if (frame->fr_child != NULL)\n    {\n\tch_log(NULL, \"children\");\n\tlog_frame_layout(frame->fr_child);\n\tif (frame->fr_next != NULL)\n\t    ch_log(NULL, \"END of children\");\n    }\n    if (frame->fr_next != NULL)\n\tlog_frame_layout(frame->fr_next);\n}\n#endif\n\n/*\n * Return the current window, unless in the cmdline window and \"prevwin\" is\n * set, then return \"prevwin\".\n */\n    win_T *\nprevwin_curwin(void)\n{\n    return\n#ifdef FEAT_CMDWIN\n\t// In cmdwin, the alternative buffer should be used.\n\tis_in_cmdwin() && prevwin != NULL ? prevwin :\n#endif\n\tcurwin;\n}\n\n/*\n * All CTRL-W window commands are handled here, called from normal_cmd().\n */\n    void\ndo_window(\n    int\t\tnchar,\n    long\tPrenum,\n    int\t\txchar)\t    // extra char from \":wincmd gx\" or NUL\n{\n    long\tPrenum1;\n    win_T\t*wp;\n#if defined(FEAT_SEARCHPATH) || defined(FEAT_FIND_ID)\n    char_u\t*ptr;\n    linenr_T    lnum = -1;\n#endif\n#ifdef FEAT_FIND_ID\n    int\t\ttype = FIND_DEFINE;\n    int\t\tlen;\n#endif\n    char_u\tcbuf[40];\n\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n#ifdef FEAT_CMDWIN\n# define CHECK_CMDWIN \\\n    do { \\\n\tif (cmdwin_type != 0) \\\n\t{ \\\n\t    emsg(_(e_invalid_in_cmdline_window)); \\\n\t    return; \\\n\t} \\\n    } while (0)\n#else\n# define CHECK_CMDWIN do { /**/ } while (0)\n#endif\n\n    Prenum1 = Prenum == 0 ? 1 : Prenum;\n\n    switch (nchar)\n    {\n// split current window in two parts, horizontally\n    case 'S':\n    case Ctrl_S:\n    case 's':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n#ifdef FEAT_QUICKFIX\n\t\t// When splitting the quickfix window open a new buffer in it,\n\t\t// don't replicate the quickfix buffer.\n\t\tif (bt_quickfix(curbuf))\n\t\t    goto newwindow;\n#endif\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\t(void)win_split((int)Prenum, 0);\n\t\tbreak;\n\n// split current window in two parts, vertically\n    case Ctrl_V:\n    case 'v':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n#ifdef FEAT_QUICKFIX\n\t\t// When splitting the quickfix window open a new buffer in it,\n\t\t// don't replicate the quickfix buffer.\n\t\tif (bt_quickfix(curbuf))\n\t\t    goto newwindow;\n#endif\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\t(void)win_split((int)Prenum, WSP_VERT);\n\t\tbreak;\n\n// split current window and edit alternate file\n    case Ctrl_HAT:\n    case '^':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\n\t\tif (buflist_findnr(Prenum == 0\n\t\t\t\t\t? curwin->w_alt_fnum : Prenum) == NULL)\n\t\t{\n\t\t    if (Prenum == 0)\n\t\t\temsg(_(e_no_alternate_file));\n\t\t    else\n\t\t\tsemsg(_(e_buffer_nr_not_found), Prenum);\n\t\t    break;\n\t\t}\n\n\t\tif (!curbuf_locked() && win_split(0, 0) == OK)\n\t\t    (void)buflist_getfile(\n\t\t\t    Prenum == 0 ? curwin->w_alt_fnum : Prenum,\n\t\t\t    (linenr_T)0, GETF_ALT, FALSE);\n\t\tbreak;\n\n// open new window\n    case Ctrl_N:\n    case 'n':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n#ifdef FEAT_QUICKFIX\nnewwindow:\n#endif\n\t\tif (Prenum)\n\t\t    // window height\n\t\t    vim_snprintf((char *)cbuf, sizeof(cbuf) - 5, \"%ld\", Prenum);\n\t\telse\n\t\t    cbuf[0] = NUL;\n#if defined(FEAT_QUICKFIX)\n\t\tif (nchar == 'v' || nchar == Ctrl_V)\n\t\t    STRCAT(cbuf, \"v\");\n#endif\n\t\tSTRCAT(cbuf, \"new\");\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n// quit current window\n    case Ctrl_Q:\n    case 'q':\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tcmd_with_count(\"quit\", cbuf, sizeof(cbuf), Prenum);\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n// close current window\n    case Ctrl_C:\n    case 'c':\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tcmd_with_count(\"close\", cbuf, sizeof(cbuf), Prenum);\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n#if defined(FEAT_QUICKFIX)\n// close preview window\n    case Ctrl_Z:\n    case 'z':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tdo_cmdline_cmd((char_u *)\"pclose\");\n\t\tbreak;\n\n// cursor to preview window\n    case 'P':\n\t\tFOR_ALL_WINDOWS(wp)\n\t\t    if (wp->w_p_pvw)\n\t\t\tbreak;\n\t\tif (wp == NULL)\n\t\t    emsg(_(e_there_is_no_preview_window));\n\t\telse\n\t\t    win_goto(wp);\n\t\tbreak;\n#endif\n\n// close all but current window\n    case Ctrl_O:\n    case 'o':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tcmd_with_count(\"only\", cbuf, sizeof(cbuf), Prenum);\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n// cursor to next window with wrap around\n    case Ctrl_W:\n    case 'w':\n// cursor to previous window with wrap around\n    case 'W':\n\t\tCHECK_CMDWIN;\n\t\tif (ONE_WINDOW && Prenum != 1)\t// just one window\n\t\t    beep_flush();\n\t\telse\n\t\t{\n\t\t    if (Prenum)\t\t\t// go to specified window\n\t\t    {\n\t\t\tfor (wp = firstwin; --Prenum > 0; )\n\t\t\t{\n\t\t\t    if (wp->w_next == NULL)\n\t\t\t\tbreak;\n\t\t\t    else\n\t\t\t\twp = wp->w_next;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (nchar == 'W')\t    // go to previous window\n\t\t\t{\n\t\t\t    wp = curwin->w_prev;\n\t\t\t    if (wp == NULL)\n\t\t\t\twp = lastwin;\t    // wrap around\n\t\t\t}\n\t\t\telse\t\t\t    // go to next window\n\t\t\t{\n\t\t\t    wp = curwin->w_next;\n\t\t\t    if (wp == NULL)\n\t\t\t\twp = firstwin;\t    // wrap around\n\t\t\t}\n\t\t    }\n\t\t    win_goto(wp);\n\t\t}\n\t\tbreak;\n\n// cursor to window below\n    case 'j':\n    case K_DOWN:\n    case Ctrl_J:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_ver(FALSE, Prenum1);\n\t\tbreak;\n\n// cursor to window above\n    case 'k':\n    case K_UP:\n    case Ctrl_K:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_ver(TRUE, Prenum1);\n\t\tbreak;\n\n// cursor to left window\n    case 'h':\n    case K_LEFT:\n    case Ctrl_H:\n    case K_BS:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_hor(TRUE, Prenum1);\n\t\tbreak;\n\n// cursor to right window\n    case 'l':\n    case K_RIGHT:\n    case Ctrl_L:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_hor(FALSE, Prenum1);\n\t\tbreak;\n\n// move window to new tab page\n    case 'T':\n\t\tCHECK_CMDWIN;\n\t\tif (one_window())\n\t\t    msg(_(m_onlyone));\n\t\telse\n\t\t{\n\t\t    tabpage_T\t*oldtab = curtab;\n\t\t    tabpage_T\t*newtab;\n\n\t\t    // First create a new tab with the window, then go back to\n\t\t    // the old tab and close the window there.\n\t\t    wp = curwin;\n\t\t    if (win_new_tabpage((int)Prenum) == OK\n\t\t\t\t\t\t     && valid_tabpage(oldtab))\n\t\t    {\n\t\t\tnewtab = curtab;\n\t\t\tgoto_tabpage_tp(oldtab, TRUE, TRUE);\n\t\t\tif (curwin == wp)\n\t\t\t    win_close(curwin, FALSE);\n\t\t\tif (valid_tabpage(newtab))\n\t\t\t    goto_tabpage_tp(newtab, TRUE, TRUE);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n// cursor to top-left window\n    case 't':\n    case Ctrl_T:\n\t\twin_goto(firstwin);\n\t\tbreak;\n\n// cursor to bottom-right window\n    case 'b':\n    case Ctrl_B:\n\t\twin_goto(lastwin);\n\t\tbreak;\n\n// cursor to last accessed (previous) window\n    case 'p':\n    case Ctrl_P:\n\t\tif (!win_valid(prevwin))\n\t\t    beep_flush();\n\t\telse\n\t\t    win_goto(prevwin);\n\t\tbreak;\n\n// exchange current and next window\n    case 'x':\n    case Ctrl_X:\n\t\tCHECK_CMDWIN;\n\t\twin_exchange(Prenum);\n\t\tbreak;\n\n// rotate windows downwards\n    case Ctrl_R:\n    case 'r':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\twin_rotate(FALSE, (int)Prenum1);    // downwards\n\t\tbreak;\n\n// rotate windows upwards\n    case 'R':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\twin_rotate(TRUE, (int)Prenum1);\t    // upwards\n\t\tbreak;\n\n// move window to the very top/bottom/left/right\n    case 'K':\n    case 'J':\n    case 'H':\n    case 'L':\n\t\tCHECK_CMDWIN;\n\t\twin_totop((int)Prenum,\n\t\t\t((nchar == 'H' || nchar == 'L') ? WSP_VERT : 0)\n\t\t\t| ((nchar == 'H' || nchar == 'K') ? WSP_TOP : WSP_BOT));\n\t\tbreak;\n\n// make all windows the same height\n    case '=':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_equal(NULL, FALSE, 'b');\n\t\tbreak;\n\n// increase current window height\n    case '+':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight(curwin->w_height + (int)Prenum1);\n\t\tbreak;\n\n// decrease current window height\n    case '-':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight(curwin->w_height - (int)Prenum1);\n\t\tbreak;\n\n// set current window height\n    case Ctrl__:\n    case '_':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight(Prenum ? (int)Prenum : 9999);\n\t\tbreak;\n\n// increase current window width\n    case '>':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setwidth(curwin->w_width + (int)Prenum1);\n\t\tbreak;\n\n// decrease current window width\n    case '<':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setwidth(curwin->w_width - (int)Prenum1);\n\t\tbreak;\n\n// set current window width\n    case '|':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setwidth(Prenum != 0 ? (int)Prenum : 9999);\n\t\tbreak;\n\n// jump to tag and split window if tag exists (in preview window)\n#if defined(FEAT_QUICKFIX)\n    case '}':\n\t\tCHECK_CMDWIN;\n\t\tif (Prenum)\n\t\t    g_do_tagpreview = Prenum;\n\t\telse\n\t\t    g_do_tagpreview = p_pvh;\n#endif\n\t\t// FALLTHROUGH\n    case ']':\n    case Ctrl_RSB:\n\t\tCHECK_CMDWIN;\n\t\t// keep Visual mode, can select words to use as a tag\n\t\tif (Prenum)\n\t\t    postponed_split = Prenum;\n\t\telse\n\t\t    postponed_split = -1;\n#ifdef FEAT_QUICKFIX\n\t\tif (nchar != '}')\n\t\t    g_do_tagpreview = 0;\n#endif\n\n\t\t// Execute the command right here, required when \"wincmd ]\"\n\t\t// was used in a function.\n\t\tdo_nv_ident(Ctrl_RSB, NUL);\n\t\tbreak;\n\n#ifdef FEAT_SEARCHPATH\n// edit file name under cursor in a new window\n    case 'f':\n    case 'F':\n    case Ctrl_F:\nwingotofile:\n\t\tCHECK_CMDWIN;\n\n\t\tptr = grab_file_name(Prenum1, &lnum);\n\t\tif (ptr != NULL)\n\t\t{\n\t\t    tabpage_T\t*oldtab = curtab;\n\t\t    win_T\t*oldwin = curwin;\n# ifdef FEAT_GUI\n\t\t    need_mouse_correct = TRUE;\n# endif\n\t\t    setpcmark();\n\t\t    if (win_split(0, 0) == OK)\n\t\t    {\n\t\t\tRESET_BINDING(curwin);\n\t\t\tif (do_ecmd(0, ptr, NULL, NULL, ECMD_LASTL,\n\t\t\t\t\t\t   ECMD_HIDE, NULL) == FAIL)\n\t\t\t{\n\t\t\t    // Failed to open the file, close the window\n\t\t\t    // opened for it.\n\t\t\t    win_close(curwin, FALSE);\n\t\t\t    goto_tabpage_win(oldtab, oldwin);\n\t\t\t}\n\t\t\telse if (nchar == 'F' && lnum >= 0)\n\t\t\t{\n\t\t\t    curwin->w_cursor.lnum = lnum;\n\t\t\t    check_cursor_lnum();\n\t\t\t    beginline(BL_SOL | BL_FIX);\n\t\t\t}\n\t\t    }\n\t\t    vim_free(ptr);\n\t\t}\n\t\tbreak;\n#endif\n\n#ifdef FEAT_FIND_ID\n// Go to the first occurrence of the identifier under cursor along path in a\n// new window -- webb\n    case 'i':\t\t\t    // Go to any match\n    case Ctrl_I:\n\t\ttype = FIND_ANY;\n\t\t// FALLTHROUGH\n    case 'd':\t\t\t    // Go to definition, using 'define'\n    case Ctrl_D:\n\t\tCHECK_CMDWIN;\n\t\tif ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)\n\t\t    break;\n\n\t\t// Make a copy, if the line was changed it will be freed.\n\t\tptr = vim_strnsave(ptr, len);\n\t\tif (ptr == NULL)\n\t\t    break;\n\n\t\tfind_pattern_in_path(ptr, 0, len, TRUE,\n\t\t\tPrenum == 0 ? TRUE : FALSE, type,\n\t\t\tPrenum1, ACTION_SPLIT, (linenr_T)1, (linenr_T)MAXLNUM);\n\t\tvim_free(ptr);\n\t\tcurwin->w_set_curswant = TRUE;\n\t\tbreak;\n#endif\n\n// Quickfix window only: view the result under the cursor in a new split.\n#if defined(FEAT_QUICKFIX)\n    case K_KENTER:\n    case CAR:\n\t\tif (bt_quickfix(curbuf))\n\t\t    qf_view_result(TRUE);\n\t\tbreak;\n#endif\n\n// CTRL-W g  extended commands\n    case 'g':\n    case Ctrl_G:\n\t\tCHECK_CMDWIN;\n#ifdef USE_ON_FLY_SCROLL\n\t\tdont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n\t\t++no_mapping;\n\t\t++allow_keys;   // no mapping for xchar, but allow key codes\n\t\tif (xchar == NUL)\n\t\t    xchar = plain_vgetc();\n\t\tLANGMAP_ADJUST(xchar, TRUE);\n\t\t--no_mapping;\n\t\t--allow_keys;\n#ifdef FEAT_CMDL_INFO\n\t\t(void)add_to_showcmd(xchar);\n#endif\n\t\tswitch (xchar)\n\t\t{\n#if defined(FEAT_QUICKFIX)\n\t\t    case '}':\n\t\t\txchar = Ctrl_RSB;\n\t\t\tif (Prenum)\n\t\t\t    g_do_tagpreview = Prenum;\n\t\t\telse\n\t\t\t    g_do_tagpreview = p_pvh;\n#endif\n\t\t\t// FALLTHROUGH\n\t\t    case ']':\n\t\t    case Ctrl_RSB:\n\t\t\t// keep Visual mode, can select words to use as a tag\n\t\t\tif (Prenum)\n\t\t\t    postponed_split = Prenum;\n\t\t\telse\n\t\t\t    postponed_split = -1;\n\n\t\t\t// Execute the command right here, required when\n\t\t\t// \"wincmd g}\" was used in a function.\n\t\t\tdo_nv_ident('g', xchar);\n\t\t\tbreak;\n\n#ifdef FEAT_SEARCHPATH\n\t\t    case 'f':\t    // CTRL-W gf: \"gf\" in a new tab page\n\t\t    case 'F':\t    // CTRL-W gF: \"gF\" in a new tab page\n\t\t\tcmdmod.cmod_tab = tabpage_index(curtab) + 1;\n\t\t\tnchar = xchar;\n\t\t\tgoto wingotofile;\n#endif\n\t\t    case 't':\t    // CTRL-W gt: go to next tab page\n\t\t\tgoto_tabpage((int)Prenum);\n\t\t\tbreak;\n\n\t\t    case 'T':\t    // CTRL-W gT: go to previous tab page\n\t\t\tgoto_tabpage(-(int)Prenum1);\n\t\t\tbreak;\n\n\t\t    case TAB:\t    // CTRL-W g<Tab>: go to last used tab page\n\t\t\tif (goto_tabpage_lastused() == FAIL)\n\t\t\t    beep_flush();\n\t\t\tbreak;\n\n\t\t    default:\n\t\t\tbeep_flush();\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n    default:\tbeep_flush();\n\t\tbreak;\n    }\n}\n\n/*\n * Figure out the address type for \":wincmd\".\n */\n    void\nget_wincmd_addr_type(char_u *arg, exarg_T *eap)\n{\n    switch (*arg)\n    {\n    case 'S':\n    case Ctrl_S:\n    case 's':\n    case Ctrl_N:\n    case 'n':\n    case 'j':\n    case Ctrl_J:\n    case 'k':\n    case Ctrl_K:\n    case 'T':\n    case Ctrl_R:\n    case 'r':\n    case 'R':\n    case 'K':\n    case 'J':\n    case '+':\n    case '-':\n    case Ctrl__:\n    case '_':\n    case '|':\n    case ']':\n    case Ctrl_RSB:\n    case 'g':\n    case Ctrl_G:\n    case Ctrl_V:\n    case 'v':\n    case 'h':\n    case Ctrl_H:\n    case 'l':\n    case Ctrl_L:\n    case 'H':\n    case 'L':\n    case '>':\n    case '<':\n#if defined(FEAT_QUICKFIX)\n    case '}':\n#endif\n#ifdef FEAT_SEARCHPATH\n    case 'f':\n    case 'F':\n    case Ctrl_F:\n#endif\n#ifdef FEAT_FIND_ID\n    case 'i':\n    case Ctrl_I:\n    case 'd':\n    case Ctrl_D:\n#endif\n\t\t// window size or any count\n\t\teap->addr_type = ADDR_OTHER;\n\t\tbreak;\n\n    case Ctrl_HAT:\n    case '^':\n\t\t// buffer number\n\t\teap->addr_type = ADDR_BUFFERS;\n\t\tbreak;\n\n    case Ctrl_Q:\n    case 'q':\n    case Ctrl_C:\n    case 'c':\n    case Ctrl_O:\n    case 'o':\n    case Ctrl_W:\n    case 'w':\n    case 'W':\n    case 'x':\n    case Ctrl_X:\n\t\t// window number\n\t\teap->addr_type = ADDR_WINDOWS;\n\t\tbreak;\n\n#if defined(FEAT_QUICKFIX)\n    case Ctrl_Z:\n    case 'z':\n    case 'P':\n#endif\n    case 't':\n    case Ctrl_T:\n    case 'b':\n    case Ctrl_B:\n    case 'p':\n    case Ctrl_P:\n    case '=':\n    case CAR:\n\t\t// no count\n\t\teap->addr_type = ADDR_NONE;\n\t\tbreak;\n    }\n}\n\n    static void\ncmd_with_count(\n    char\t*cmd,\n    char_u\t*bufp,\n    size_t\tbufsize,\n    long\tPrenum)\n{\n    if (Prenum > 0)\n\tvim_snprintf((char *)bufp, bufsize, \"%s %ld\", cmd, Prenum);\n    else\n\tSTRCPY(bufp, cmd);\n}\n\n/*\n * If \"split_disallowed\" is set give an error and return FAIL.\n * Otherwise return OK.\n */\n    static int\ncheck_split_disallowed()\n{\n    if (split_disallowed > 0)\n    {\n\temsg(_(e_cant_split_window_while_closing_another));\n\treturn FAIL;\n    }\n    if (curwin->w_buffer->b_locked_split)\n    {\n\temsg(_(e_cannot_split_window_when_closing_buffer));\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * split the current window, implements CTRL-W s and :split\n *\n * \"size\" is the height or width for the new window, 0 to use half of current\n * height or width.\n *\n * \"flags\":\n * WSP_ROOM: require enough room for new window\n * WSP_VERT: vertical split.\n * WSP_TOP:  open window at the top-left of the shell (help window).\n * WSP_BOT:  open window at the bottom-right of the shell (quickfix window).\n * WSP_HELP: creating the help window, keep layout snapshot\n *\n * return FAIL for failure, OK otherwise\n */\n    int\nwin_split(int size, int flags)\n{\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn FAIL;\n\n    if (check_split_disallowed() == FAIL)\n\treturn FAIL;\n\n    // When the \":tab\" modifier was used open a new tab page instead.\n    if (may_open_tabpage() == OK)\n\treturn OK;\n\n    // Add flags from \":vertical\", \":topleft\" and \":botright\".\n    flags |= cmdmod.cmod_split;\n    if ((flags & WSP_TOP) && (flags & WSP_BOT))\n    {\n\temsg(_(e_cant_split_topleft_and_botright_at_the_same_time));\n\treturn FAIL;\n    }\n\n    // When creating the help window make a snapshot of the window layout.\n    // Otherwise clear the snapshot, it's now invalid.\n    if (flags & WSP_HELP)\n\tmake_snapshot(SNAP_HELP_IDX);\n    else\n\tclear_snapshot(curtab, SNAP_HELP_IDX);\n\n    return win_split_ins(size, flags, NULL, 0);\n}\n\n/*\n * When \"new_wp\" is NULL: split the current window in two.\n * When \"new_wp\" is not NULL: insert this window at the far\n * top/left/right/bottom.\n * return FAIL for failure, OK otherwise\n */\n    int\nwin_split_ins(\n    int\t\tsize,\n    int\t\tflags,\n    win_T\t*new_wp,\n    int\t\tdir)\n{\n    win_T\t*wp = new_wp;\n    win_T\t*oldwin;\n    int\t\tnew_size = size;\n    int\t\ti;\n    int\t\tneed_status = 0;\n    int\t\tdo_equal = FALSE;\n    int\t\tneeded;\n    int\t\tavailable;\n    int\t\toldwin_height = 0;\n    int\t\tlayout;\n    frame_T\t*frp, *curfrp, *frp2, *prevfrp;\n    int\t\tbefore;\n    int\t\tminheight;\n    int\t\twmh1;\n    int\t\tdid_set_fraction = FALSE;\n\n    if (flags & WSP_TOP)\n\toldwin = firstwin;\n    else if (flags & WSP_BOT)\n\toldwin = lastwin;\n    else\n\toldwin = curwin;\n\n    // add a status line when p_ls == 1 and splitting the first window\n    if (ONE_WINDOW && p_ls == 1 && oldwin->w_status_height == 0)\n    {\n\tif (VISIBLE_HEIGHT(oldwin) <= p_wmh && new_wp == NULL)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    return FAIL;\n\t}\n\tneed_status = STATUS_HEIGHT;\n    }\n\n#ifdef FEAT_GUI\n    // May be needed for the scrollbars that are going to change.\n    if (gui.in_use)\n\tout_flush();\n#endif\n\n    if (flags & WSP_VERT)\n    {\n\tint\twmw1;\n\tint\tminwidth;\n\n\tlayout = FR_ROW;\n\n\t/*\n\t * Check if we are able to split the current window and compute its\n\t * width.\n\t */\n\t// Current window requires at least 1 space.\n\twmw1 = (p_wmw == 0 ? 1 : p_wmw);\n\tneeded = wmw1 + 1;\n\tif (flags & WSP_ROOM)\n\t    needed += p_wiw - wmw1;\n\tif (flags & (WSP_BOT | WSP_TOP))\n\t{\n\t    minwidth = frame_minwidth(topframe, NOWIN);\n\t    available = topframe->fr_width;\n\t    needed += minwidth;\n\t}\n\telse if (p_ea)\n\t{\n\t    minwidth = frame_minwidth(oldwin->w_frame, NOWIN);\n\t    prevfrp = oldwin->w_frame;\n\t    for (frp = oldwin->w_frame->fr_parent; frp != NULL;\n\t\t\t\t\t\t\tfrp = frp->fr_parent)\n\t    {\n\t\tif (frp->fr_layout == FR_ROW)\n\t\t    FOR_ALL_FRAMES(frp2, frp->fr_child)\n\t\t\tif (frp2 != prevfrp)\n\t\t\t    minwidth += frame_minwidth(frp2, NOWIN);\n\t\tprevfrp = frp;\n\t    }\n\t    available = topframe->fr_width;\n\t    needed += minwidth;\n\t}\n\telse\n\t{\n\t    minwidth = frame_minwidth(oldwin->w_frame, NOWIN);\n\t    available = oldwin->w_frame->fr_width;\n\t    needed += minwidth;\n\t}\n\tif (available < needed && new_wp == NULL)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    return FAIL;\n\t}\n\tif (new_size == 0)\n\t    new_size = oldwin->w_width / 2;\n\tif (new_size > available - minwidth - 1)\n\t    new_size = available - minwidth - 1;\n\tif (new_size < wmw1)\n\t    new_size = wmw1;\n\n\t// if it doesn't fit in the current window, need win_equal()\n\tif (oldwin->w_width - new_size - 1 < p_wmw)\n\t    do_equal = TRUE;\n\n\t// We don't like to take lines for the new window from a\n\t// 'winfixwidth' window.  Take them from a window to the left or right\n\t// instead, if possible. Add one for the separator.\n\tif (oldwin->w_p_wfw)\n\t    win_setwidth_win(oldwin->w_width + new_size + 1, oldwin);\n\n\t// Only make all windows the same width if one of them (except oldwin)\n\t// is wider than one of the split windows.\n\tif (!do_equal && p_ea && size == 0 && *p_ead != 'v'\n\t\t\t\t\t && oldwin->w_frame->fr_parent != NULL)\n\t{\n\t    frp = oldwin->w_frame->fr_parent->fr_child;\n\t    while (frp != NULL)\n\t    {\n\t\tif (frp->fr_win != oldwin && frp->fr_win != NULL\n\t\t\t&& (frp->fr_win->w_width > new_size\n\t\t\t    || frp->fr_win->w_width > oldwin->w_width\n\t\t\t\t\t\t\t      - new_size - 1))\n\t\t{\n\t\t    do_equal = TRUE;\n\t\t    break;\n\t\t}\n\t\tfrp = frp->fr_next;\n\t    }\n\t}\n    }\n    else\n    {\n\tlayout = FR_COL;\n\n\t/*\n\t * Check if we are able to split the current window and compute its\n\t * height.\n\t */\n\t// Current window requires at least 1 space.\n\twmh1 = (p_wmh == 0 ? 1 : p_wmh) + WINBAR_HEIGHT(curwin);\n\tneeded = wmh1 + STATUS_HEIGHT;\n\tif (flags & WSP_ROOM)\n\t    needed += p_wh - wmh1;\n\tif (flags & (WSP_BOT | WSP_TOP))\n\t{\n\t    minheight = frame_minheight(topframe, NOWIN) + need_status;\n\t    available = topframe->fr_height;\n\t    needed += minheight;\n\t}\n\telse if (p_ea)\n\t{\n\t    minheight = frame_minheight(oldwin->w_frame, NOWIN) + need_status;\n\t    prevfrp = oldwin->w_frame;\n\t    for (frp = oldwin->w_frame->fr_parent; frp != NULL;\n\t\t\t\t\t\t\tfrp = frp->fr_parent)\n\t    {\n\t\tif (frp->fr_layout == FR_COL)\n\t\t    FOR_ALL_FRAMES(frp2, frp->fr_child)\n\t\t\tif (frp2 != prevfrp)\n\t\t\t    minheight += frame_minheight(frp2, NOWIN);\n\t\tprevfrp = frp;\n\t    }\n\t    available = topframe->fr_height;\n\t    needed += minheight;\n\t}\n\telse\n\t{\n\t    minheight = frame_minheight(oldwin->w_frame, NOWIN) + need_status;\n\t    available = oldwin->w_frame->fr_height;\n\t    needed += minheight;\n\t}\n\tif (available < needed && new_wp == NULL)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    return FAIL;\n\t}\n\toldwin_height = oldwin->w_height;\n\tif (need_status)\n\t{\n\t    oldwin->w_status_height = STATUS_HEIGHT;\n\t    oldwin_height -= STATUS_HEIGHT;\n\t}\n\tif (new_size == 0)\n\t    new_size = oldwin_height / 2;\n\tif (new_size > available - minheight - STATUS_HEIGHT)\n\t    new_size = available - minheight - STATUS_HEIGHT;\n\tif (new_size < wmh1)\n\t    new_size = wmh1;\n\n\t// if it doesn't fit in the current window, need win_equal()\n\tif (oldwin_height - new_size - STATUS_HEIGHT < p_wmh)\n\t    do_equal = TRUE;\n\n\t// We don't like to take lines for the new window from a\n\t// 'winfixheight' window.  Take them from a window above or below\n\t// instead, if possible.\n\tif (oldwin->w_p_wfh)\n\t{\n\t    // Set w_fraction now so that the cursor keeps the same relative\n\t    // vertical position using the old height.\n\t    set_fraction(oldwin);\n\t    did_set_fraction = TRUE;\n\n\t    win_setheight_win(oldwin->w_height + new_size + STATUS_HEIGHT,\n\t\t\t\t\t\t\t\t      oldwin);\n\t    oldwin_height = oldwin->w_height;\n\t    if (need_status)\n\t\toldwin_height -= STATUS_HEIGHT;\n\t}\n\n\t// Only make all windows the same height if one of them (except oldwin)\n\t// is higher than one of the split windows.\n\tif (!do_equal && p_ea && size == 0 && *p_ead != 'h'\n\t   && oldwin->w_frame->fr_parent != NULL)\n\t{\n\t    frp = oldwin->w_frame->fr_parent->fr_child;\n\t    while (frp != NULL)\n\t    {\n\t\tif (frp->fr_win != oldwin && frp->fr_win != NULL\n\t\t\t&& (frp->fr_win->w_height > new_size\n\t\t\t    || frp->fr_win->w_height > oldwin_height - new_size\n\t\t\t\t\t\t\t      - STATUS_HEIGHT))\n\t\t{\n\t\t    do_equal = TRUE;\n\t\t    break;\n\t\t}\n\t\tfrp = frp->fr_next;\n\t    }\n\t}\n    }\n\n    /*\n     * allocate new window structure and link it in the window list\n     */\n    if ((flags & WSP_TOP) == 0\n\t    && ((flags & WSP_BOT)\n\t\t|| (flags & WSP_BELOW)\n\t\t|| (!(flags & WSP_ABOVE)\n\t\t    && ( (flags & WSP_VERT) ? p_spr : p_sb))))\n    {\n\t// new window below/right of current one\n\tif (new_wp == NULL)\n\t    wp = win_alloc(oldwin, FALSE);\n\telse\n\t    win_append(oldwin, wp);\n    }\n    else\n    {\n\tif (new_wp == NULL)\n\t    wp = win_alloc(oldwin->w_prev, FALSE);\n\telse\n\t    win_append(oldwin->w_prev, wp);\n    }\n\n    if (new_wp == NULL)\n    {\n\tif (wp == NULL)\n\t    return FAIL;\n\n\tnew_frame(wp);\n\tif (wp->w_frame == NULL)\n\t{\n\t    win_free(wp, NULL);\n\t    return FAIL;\n\t}\n\n\t// make the contents of the new window the same as the current one\n\twin_init(wp, curwin, flags);\n    }\n\n    /*\n     * Reorganise the tree of frames to insert the new window.\n     */\n    if (flags & (WSP_TOP | WSP_BOT))\n    {\n\tif ((topframe->fr_layout == FR_COL && (flags & WSP_VERT) == 0)\n\t    || (topframe->fr_layout == FR_ROW && (flags & WSP_VERT) != 0))\n\t{\n\t    curfrp = topframe->fr_child;\n\t    if (flags & WSP_BOT)\n\t\twhile (curfrp->fr_next != NULL)\n\t\t    curfrp = curfrp->fr_next;\n\t}\n\telse\n\t    curfrp = topframe;\n\tbefore = (flags & WSP_TOP);\n    }\n    else\n    {\n\tcurfrp = oldwin->w_frame;\n\tif (flags & WSP_BELOW)\n\t    before = FALSE;\n\telse if (flags & WSP_ABOVE)\n\t    before = TRUE;\n\telse if (flags & WSP_VERT)\n\t    before = !p_spr;\n\telse\n\t    before = !p_sb;\n    }\n    if (curfrp->fr_parent == NULL || curfrp->fr_parent->fr_layout != layout)\n    {\n\t// Need to create a new frame in the tree to make a branch.\n\tfrp = ALLOC_CLEAR_ONE(frame_T);\n\t*frp = *curfrp;\n\tcurfrp->fr_layout = layout;\n\tfrp->fr_parent = curfrp;\n\tfrp->fr_next = NULL;\n\tfrp->fr_prev = NULL;\n\tcurfrp->fr_child = frp;\n\tcurfrp->fr_win = NULL;\n\tcurfrp = frp;\n\tif (frp->fr_win != NULL)\n\t    oldwin->w_frame = frp;\n\telse\n\t    FOR_ALL_FRAMES(frp, frp->fr_child)\n\t\tfrp->fr_parent = curfrp;\n    }\n\n    if (new_wp == NULL)\n\tfrp = wp->w_frame;\n    else\n\tfrp = new_wp->w_frame;\n    frp->fr_parent = curfrp->fr_parent;\n\n    // Insert the new frame at the right place in the frame list.\n    if (before)\n\tframe_insert(curfrp, frp);\n    else\n\tframe_append(curfrp, frp);\n\n    // Set w_fraction now so that the cursor keeps the same relative\n    // vertical position.\n    if (!did_set_fraction)\n\tset_fraction(oldwin);\n    wp->w_fraction = oldwin->w_fraction;\n\n    if (flags & WSP_VERT)\n    {\n\twp->w_p_scr = curwin->w_p_scr;\n\n\tif (need_status)\n\t{\n\t    win_new_height(oldwin, oldwin->w_height - 1);\n\t    oldwin->w_status_height = need_status;\n\t}\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    // set height and row of new window to full height\n\t    wp->w_winrow = tabline_height();\n\t    win_new_height(wp, curfrp->fr_height - (p_ls > 0)\n\t\t\t\t\t\t\t  - WINBAR_HEIGHT(wp));\n\t    wp->w_status_height = (p_ls > 0);\n\t}\n\telse\n\t{\n\t    // height and row of new window is same as current window\n\t    wp->w_winrow = oldwin->w_winrow;\n\t    win_new_height(wp, VISIBLE_HEIGHT(oldwin));\n\t    wp->w_status_height = oldwin->w_status_height;\n\t}\n\tfrp->fr_height = curfrp->fr_height;\n\n\t// \"new_size\" of the current window goes to the new window, use\n\t// one column for the vertical separator\n\twin_new_width(wp, new_size);\n\tif (before)\n\t    wp->w_vsep_width = 1;\n\telse\n\t{\n\t    wp->w_vsep_width = oldwin->w_vsep_width;\n\t    oldwin->w_vsep_width = 1;\n\t}\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    if (flags & WSP_BOT)\n\t\tframe_add_vsep(curfrp);\n\t    // Set width of neighbor frame\n\t    frame_new_width(curfrp, curfrp->fr_width\n\t\t     - (new_size + ((flags & WSP_TOP) != 0)), flags & WSP_TOP,\n\t\t\t\t\t\t\t\t       FALSE);\n\t}\n\telse\n\t    win_new_width(oldwin, oldwin->w_width - (new_size + 1));\n\tif (before)\t// new window left of current one\n\t{\n\t    wp->w_wincol = oldwin->w_wincol;\n\t    oldwin->w_wincol += new_size + 1;\n\t}\n\telse\t\t// new window right of current one\n\t    wp->w_wincol = oldwin->w_wincol + oldwin->w_width + 1;\n\tframe_fix_width(oldwin);\n\tframe_fix_width(wp);\n    }\n    else\n    {\n\t// width and column of new window is same as current window\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    wp->w_wincol = 0;\n\t    win_new_width(wp, Columns);\n\t    wp->w_vsep_width = 0;\n\t}\n\telse\n\t{\n\t    wp->w_wincol = oldwin->w_wincol;\n\t    win_new_width(wp, oldwin->w_width);\n\t    wp->w_vsep_width = oldwin->w_vsep_width;\n\t}\n\tfrp->fr_width = curfrp->fr_width;\n\n\t// \"new_size\" of the current window goes to the new window, use\n\t// one row for the status line\n\twin_new_height(wp, new_size);\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    int new_fr_height = curfrp->fr_height - new_size\n\t\t\t\t\t\t\t  + WINBAR_HEIGHT(wp) ;\n\n\t    if (!((flags & WSP_BOT) && p_ls == 0))\n\t\tnew_fr_height -= STATUS_HEIGHT;\n\t    frame_new_height(curfrp, new_fr_height, flags & WSP_TOP, FALSE);\n\t}\n\telse\n\t    win_new_height(oldwin, oldwin_height - (new_size + STATUS_HEIGHT));\n\tif (before)\t// new window above current one\n\t{\n\t    wp->w_winrow = oldwin->w_winrow;\n\t    wp->w_status_height = STATUS_HEIGHT;\n\t    oldwin->w_winrow += wp->w_height + STATUS_HEIGHT;\n\t}\n\telse\t\t// new window below current one\n\t{\n\t    wp->w_winrow = oldwin->w_winrow + VISIBLE_HEIGHT(oldwin)\n\t\t\t\t\t\t\t       + STATUS_HEIGHT;\n\t    wp->w_status_height = oldwin->w_status_height;\n\t    if (!(flags & WSP_BOT))\n\t\toldwin->w_status_height = STATUS_HEIGHT;\n\t}\n\tif (flags & WSP_BOT)\n\t    frame_add_statusline(curfrp);\n\tframe_fix_height(wp);\n\tframe_fix_height(oldwin);\n    }\n\n    if (flags & (WSP_TOP | WSP_BOT))\n\t(void)win_comp_pos();\n\n     // Both windows need redrawing.  Update all status lines, in case they\n     // show something related to the window count or position.\n    redraw_win_later(wp, NOT_VALID);\n    redraw_win_later(oldwin, NOT_VALID);\n    status_redraw_all();\n\n    if (need_status)\n    {\n\tmsg_row = Rows - 1;\n\tmsg_col = sc_col;\n\tmsg_clr_eos_force();\t// Old command/ruler may still be there\n\tcomp_col();\n\tmsg_row = Rows - 1;\n\tmsg_col = 0;\t// put position back at start of line\n    }\n\n    /*\n     * equalize the window sizes.\n     */\n    if (do_equal || dir != 0)\n\twin_equal(wp, TRUE,\n\t\t(flags & WSP_VERT) ? (dir == 'v' ? 'b' : 'h')\n\t\t: dir == 'h' ? 'b' : 'v');\n\n    // Don't change the window height/width to 'winheight' / 'winwidth' if a\n    // size was given.\n    if (flags & WSP_VERT)\n    {\n\ti = p_wiw;\n\tif (size != 0)\n\t    p_wiw = size;\n\n# ifdef FEAT_GUI\n\t// When 'guioptions' includes 'L' or 'R' may have to add scrollbars.\n\tif (gui.in_use)\n\t    gui_init_which_components(NULL);\n# endif\n    }\n    else\n    {\n\ti = p_wh;\n\tif (size != 0)\n\t    p_wh = size;\n    }\n\n    /*\n     * make the new window the current window\n     */\n    (void)win_enter_ext(wp, WEE_TRIGGER_NEW_AUTOCMDS\n\t\t    | WEE_TRIGGER_ENTER_AUTOCMDS | WEE_TRIGGER_LEAVE_AUTOCMDS);\n    if (flags & WSP_VERT)\n\tp_wiw = i;\n    else\n\tp_wh = i;\n\n    return OK;\n}\n\n\n/*\n * Initialize window \"newp\" from window \"oldp\".\n * Used when splitting a window and when creating a new tab page.\n * The windows will both edit the same buffer.\n * WSP_NEWLOC may be specified in flags to prevent the location list from\n * being copied.\n */\n    static void\nwin_init(win_T *newp, win_T *oldp, int flags UNUSED)\n{\n    int\t\ti;\n\n    newp->w_buffer = oldp->w_buffer;\n#ifdef FEAT_SYN_HL\n    newp->w_s = &(oldp->w_buffer->b_s);\n#endif\n    oldp->w_buffer->b_nwindows++;\n    newp->w_cursor = oldp->w_cursor;\n    newp->w_valid = 0;\n    newp->w_curswant = oldp->w_curswant;\n    newp->w_set_curswant = oldp->w_set_curswant;\n    newp->w_topline = oldp->w_topline;\n#ifdef FEAT_DIFF\n    newp->w_topfill = oldp->w_topfill;\n#endif\n    newp->w_leftcol = oldp->w_leftcol;\n    newp->w_pcmark = oldp->w_pcmark;\n    newp->w_prev_pcmark = oldp->w_prev_pcmark;\n    newp->w_alt_fnum = oldp->w_alt_fnum;\n    newp->w_wrow = oldp->w_wrow;\n    newp->w_fraction = oldp->w_fraction;\n    newp->w_prev_fraction_row = oldp->w_prev_fraction_row;\n    copy_jumplist(oldp, newp);\n#ifdef FEAT_QUICKFIX\n    if (flags & WSP_NEWLOC)\n    {\n\t// Don't copy the location list.\n\tnewp->w_llist = NULL;\n\tnewp->w_llist_ref = NULL;\n    }\n    else\n\tcopy_loclist_stack(oldp, newp);\n#endif\n    newp->w_localdir = (oldp->w_localdir == NULL)\n\t\t\t\t    ? NULL : vim_strsave(oldp->w_localdir);\n    newp->w_prevdir = (oldp->w_prevdir == NULL)\n\t\t\t\t    ? NULL : vim_strsave(oldp->w_prevdir);\n\n    // copy tagstack and folds\n    for (i = 0; i < oldp->w_tagstacklen; i++)\n    {\n\ttaggy_T\t*tag = &newp->w_tagstack[i];\n\t*tag = oldp->w_tagstack[i];\n\tif (tag->tagname != NULL)\n\t    tag->tagname = vim_strsave(tag->tagname);\n\tif (tag->user_data != NULL)\n\t    tag->user_data = vim_strsave(tag->user_data);\n    }\n    newp->w_tagstackidx = oldp->w_tagstackidx;\n    newp->w_tagstacklen = oldp->w_tagstacklen;\n\n    // Keep same changelist position in new window.\n    newp->w_changelistidx = oldp->w_changelistidx;\n\n#ifdef FEAT_FOLDING\n    copyFoldingState(oldp, newp);\n#endif\n\n    win_init_some(newp, oldp);\n#ifdef FEAT_TERMINAL\n    term_update_wincolor(newp);\n#endif\n}\n\n/*\n * Initialize window \"newp\" from window \"old\".\n * Only the essential things are copied.\n */\n    static void\nwin_init_some(win_T *newp, win_T *oldp)\n{\n    // Use the same argument list.\n    newp->w_alist = oldp->w_alist;\n    ++newp->w_alist->al_refcount;\n    newp->w_arg_idx = oldp->w_arg_idx;\n\n    // copy options from existing window\n    win_copy_options(oldp, newp);\n}\n\n/*\n * Return TRUE if \"win\" is a global popup or a popup in the current tab page.\n */\n    int\nwin_valid_popup(win_T *win UNUSED)\n{\n#ifdef FEAT_PROP_POPUP\n    win_T\t*wp;\n\n    FOR_ALL_POPUPWINS(wp)\n\tif (wp == win)\n\t    return TRUE;\n    FOR_ALL_POPUPWINS_IN_TAB(curtab, wp)\n\tif (wp == win)\n\t    return TRUE;\n#endif\n    return FALSE;\n}\n\n/*\n * Check if \"win\" is a pointer to an existing window in the current tab page.\n */\n    int\nwin_valid(win_T *win)\n{\n    win_T\t*wp;\n\n    if (win == NULL)\n\treturn FALSE;\n    FOR_ALL_WINDOWS(wp)\n\tif (wp == win)\n\t    return TRUE;\n    return win_valid_popup(win);\n}\n\n/*\n * Find window \"id\" in the current tab page.\n * Also find popup windows.\n * Return NULL if not found.\n */\n    win_T *\nwin_find_by_id(int id)\n{\n    win_T   *wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (wp->w_id == id)\n\t    return wp;\n#ifdef FEAT_PROP_POPUP\n    FOR_ALL_POPUPWINS(wp)\n\tif (wp->w_id == id)\n\t    return wp;\n    FOR_ALL_POPUPWINS_IN_TAB(curtab, wp)\n\tif (wp->w_id == id)\n\t    return wp;\n#endif\n    return NULL;\n}\n\n/*\n * Check if \"win\" is a pointer to an existing window in any tab page.\n */\n    int\nwin_valid_any_tab(win_T *win)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    if (win == NULL)\n\treturn FALSE;\n    FOR_ALL_TABPAGES(tp)\n    {\n\tFOR_ALL_WINDOWS_IN_TAB(tp, wp)\n\t{\n\t    if (wp == win)\n\t\treturn TRUE;\n\t}\n#ifdef FEAT_PROP_POPUP\n\tFOR_ALL_POPUPWINS_IN_TAB(tp, wp)\n\t    if (wp == win)\n\t\treturn TRUE;\n#endif\n    }\n    return win_valid_popup(win);\n}\n\n/*\n * Return the number of windows.\n */\n    int\nwin_count(void)\n{\n    win_T\t*wp;\n    int\t\tcount = 0;\n\n    FOR_ALL_WINDOWS(wp)\n\t++count;\n    return count;\n}\n\n/*\n * Make \"count\" windows on the screen.\n * Return actual number of windows on the screen.\n * Must be called when there is just one window, filling the whole screen\n * (excluding the command line).\n */\n    int\nmake_windows(\n    int\t\tcount,\n    int\t\tvertical UNUSED)  // split windows vertically if TRUE\n{\n    int\t\tmaxcount;\n    int\t\ttodo;\n\n    if (vertical)\n    {\n\t// Each window needs at least 'winminwidth' lines and a separator\n\t// column.\n\tmaxcount = (curwin->w_width + curwin->w_vsep_width\n\t\t\t\t\t     - (p_wiw - p_wmw)) / (p_wmw + 1);\n    }\n    else\n    {\n\t// Each window needs at least 'winminheight' lines and a status line.\n\tmaxcount = (VISIBLE_HEIGHT(curwin) + curwin->w_status_height\n\t\t\t\t  - (p_wh - p_wmh)) / (p_wmh + STATUS_HEIGHT);\n    }\n\n    if (maxcount < 2)\n\tmaxcount = 2;\n    if (count > maxcount)\n\tcount = maxcount;\n\n    /*\n     * add status line now, otherwise first window will be too big\n     */\n    if (count > 1)\n\tlast_status(TRUE);\n\n    /*\n     * Don't execute autocommands while creating the windows.  Must do that\n     * when putting the buffers in the windows.\n     */\n    block_autocmds();\n\n    // todo is number of windows left to create\n    for (todo = count - 1; todo > 0; --todo)\n\tif (vertical)\n\t{\n\t    if (win_split(curwin->w_width - (curwin->w_width - todo)\n\t\t\t/ (todo + 1) - 1, WSP_VERT | WSP_ABOVE) == FAIL)\n\t\tbreak;\n\t}\n\telse\n\t{\n\t    if (win_split(curwin->w_height - (curwin->w_height - todo\n\t\t\t    * STATUS_HEIGHT) / (todo + 1)\n\t\t\t- STATUS_HEIGHT, WSP_ABOVE) == FAIL)\n\t\tbreak;\n\t}\n\n    unblock_autocmds();\n\n    // return actual number of windows\n    return (count - todo);\n}\n\n/*\n * Exchange current and next window\n */\n    static void\nwin_exchange(long Prenum)\n{\n    frame_T\t*frp;\n    frame_T\t*frp2;\n    win_T\t*wp;\n    win_T\t*wp2;\n    int\t\ttemp;\n\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n    if (ONE_WINDOW)\t    // just one window\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    /*\n     * find window to exchange with\n     */\n    if (Prenum)\n    {\n\tfrp = curwin->w_frame->fr_parent->fr_child;\n\twhile (frp != NULL && --Prenum > 0)\n\t    frp = frp->fr_next;\n    }\n    else if (curwin->w_frame->fr_next != NULL)\t// Swap with next\n\tfrp = curwin->w_frame->fr_next;\n    else    // Swap last window in row/col with previous\n\tfrp = curwin->w_frame->fr_prev;\n\n    // We can only exchange a window with another window, not with a frame\n    // containing windows.\n    if (frp == NULL || frp->fr_win == NULL || frp->fr_win == curwin)\n\treturn;\n    wp = frp->fr_win;\n\n/*\n * 1. remove curwin from the list. Remember after which window it was in wp2\n * 2. insert curwin before wp in the list\n * if wp != wp2\n *    3. remove wp from the list\n *    4. insert wp after wp2\n * 5. exchange the status line height and vsep width.\n */\n    wp2 = curwin->w_prev;\n    frp2 = curwin->w_frame->fr_prev;\n    if (wp->w_prev != curwin)\n    {\n\twin_remove(curwin, NULL);\n\tframe_remove(curwin->w_frame);\n\twin_append(wp->w_prev, curwin);\n\tframe_insert(frp, curwin->w_frame);\n    }\n    if (wp != wp2)\n    {\n\twin_remove(wp, NULL);\n\tframe_remove(wp->w_frame);\n\twin_append(wp2, wp);\n\tif (frp2 == NULL)\n\t    frame_insert(wp->w_frame->fr_parent->fr_child, wp->w_frame);\n\telse\n\t    frame_append(frp2, wp->w_frame);\n    }\n    temp = curwin->w_status_height;\n    curwin->w_status_height = wp->w_status_height;\n    wp->w_status_height = temp;\n    temp = curwin->w_vsep_width;\n    curwin->w_vsep_width = wp->w_vsep_width;\n    wp->w_vsep_width = temp;\n\n    frame_fix_height(curwin);\n    frame_fix_height(wp);\n    frame_fix_width(curwin);\n    frame_fix_width(wp);\n\n    (void)win_comp_pos();\t\t// recompute window positions\n\n    if (wp->w_buffer != curbuf)\n\treset_VIsual_and_resel();\n    else if (VIsual_active)\n\twp->w_cursor = curwin->w_cursor;\n\n    win_enter(wp, TRUE);\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * rotate windows: if upwards TRUE the second window becomes the first one\n *\t\t   if upwards FALSE the first window becomes the second one\n */\n    static void\nwin_rotate(int upwards, int count)\n{\n    win_T\t*wp1;\n    win_T\t*wp2;\n    frame_T\t*frp;\n    int\t\tn;\n\n    if (ONE_WINDOW)\t\t// nothing to do\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    // Check if all frames in this row/col have one window.\n    FOR_ALL_FRAMES(frp, curwin->w_frame->fr_parent->fr_child)\n\tif (frp->fr_win == NULL)\n\t{\n\t    emsg(_(e_cannot_rotate_when_another_window_is_split));\n\t    return;\n\t}\n\n    while (count--)\n    {\n\tif (upwards)\t\t// first window becomes last window\n\t{\n\t    // remove first window/frame from the list\n\t    frp = curwin->w_frame->fr_parent->fr_child;\n\t    wp1 = frp->fr_win;\n\t    win_remove(wp1, NULL);\n\t    frame_remove(frp);\n\n\t    // find last frame and append removed window/frame after it\n\t    for ( ; frp->fr_next != NULL; frp = frp->fr_next)\n\t\t;\n\t    win_append(frp->fr_win, wp1);\n\t    frame_append(frp, wp1->w_frame);\n\n\t    wp2 = frp->fr_win;\t\t// previously last window\n\t}\n\telse\t\t\t// last window becomes first window\n\t{\n\t    // find last window/frame in the list and remove it\n\t    for (frp = curwin->w_frame; frp->fr_next != NULL;\n\t\t\t\t\t\t\t   frp = frp->fr_next)\n\t\t;\n\t    wp1 = frp->fr_win;\n\t    wp2 = wp1->w_prev;\t\t    // will become last window\n\t    win_remove(wp1, NULL);\n\t    frame_remove(frp);\n\n\t    // append the removed window/frame before the first in the list\n\t    win_append(frp->fr_parent->fr_child->fr_win->w_prev, wp1);\n\t    frame_insert(frp->fr_parent->fr_child, frp);\n\t}\n\n\t// exchange status height and vsep width of old and new last window\n\tn = wp2->w_status_height;\n\twp2->w_status_height = wp1->w_status_height;\n\twp1->w_status_height = n;\n\tframe_fix_height(wp1);\n\tframe_fix_height(wp2);\n\tn = wp2->w_vsep_width;\n\twp2->w_vsep_width = wp1->w_vsep_width;\n\twp1->w_vsep_width = n;\n\tframe_fix_width(wp1);\n\tframe_fix_width(wp2);\n\n\t// recompute w_winrow and w_wincol for all windows\n\t(void)win_comp_pos();\n    }\n\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * Move the current window to the very top/bottom/left/right of the screen.\n */\n    static void\nwin_totop(int size, int flags)\n{\n    int\t\tdir;\n    int\t\theight = curwin->w_height;\n\n    if (ONE_WINDOW)\n    {\n\tbeep_flush();\n\treturn;\n    }\n    if (check_split_disallowed() == FAIL)\n\treturn;\n\n    // Remove the window and frame from the tree of frames.\n    (void)winframe_remove(curwin, &dir, NULL);\n    win_remove(curwin, NULL);\n    last_status(FALSE);\t    // may need to remove last status line\n    (void)win_comp_pos();   // recompute window positions\n\n    // Split a window on the desired side and put the window there.\n    (void)win_split_ins(size, flags, curwin, dir);\n    if (!(flags & WSP_VERT))\n    {\n\twin_setheight(height);\n\tif (p_ea)\n\t    win_equal(curwin, TRUE, 'v');\n    }\n\n#if defined(FEAT_GUI)\n    // When 'guioptions' includes 'L' or 'R' may have to remove or add\n    // scrollbars.  Have to update them anyway.\n    gui_may_update_scrollbars();\n#endif\n}\n\n/*\n * Move window \"win1\" to below/right of \"win2\" and make \"win1\" the current\n * window.  Only works within the same frame!\n */\n    void\nwin_move_after(win_T *win1, win_T *win2)\n{\n    int\t\theight;\n\n    // check if the arguments are reasonable\n    if (win1 == win2)\n\treturn;\n\n    // check if there is something to do\n    if (win2->w_next != win1)\n    {\n\tif (win1->w_frame->fr_parent != win2->w_frame->fr_parent)\n\t{\n\t    iemsg(\"INTERNAL: trying to move a window into another frame\");\n\t    return;\n\t}\n\n\t// may need to move the status line/vertical separator of the last\n\t// window\n\tif (win1 == lastwin)\n\t{\n\t    height = win1->w_prev->w_status_height;\n\t    win1->w_prev->w_status_height = win1->w_status_height;\n\t    win1->w_status_height = height;\n\t    if (win1->w_prev->w_vsep_width == 1)\n\t    {\n\t\t// Remove the vertical separator from the last-but-one window,\n\t\t// add it to the last window.  Adjust the frame widths.\n\t\twin1->w_prev->w_vsep_width = 0;\n\t\twin1->w_prev->w_frame->fr_width -= 1;\n\t\twin1->w_vsep_width = 1;\n\t\twin1->w_frame->fr_width += 1;\n\t    }\n\t}\n\telse if (win2 == lastwin)\n\t{\n\t    height = win1->w_status_height;\n\t    win1->w_status_height = win2->w_status_height;\n\t    win2->w_status_height = height;\n\t    if (win1->w_vsep_width == 1)\n\t    {\n\t\t// Remove the vertical separator from win1, add it to the last\n\t\t// window, win2.  Adjust the frame widths.\n\t\twin2->w_vsep_width = 1;\n\t\twin2->w_frame->fr_width += 1;\n\t\twin1->w_vsep_width = 0;\n\t\twin1->w_frame->fr_width -= 1;\n\t    }\n\t}\n\twin_remove(win1, NULL);\n\tframe_remove(win1->w_frame);\n\twin_append(win2, win1);\n\tframe_append(win2->w_frame, win1->w_frame);\n\n\t(void)win_comp_pos();\t// recompute w_winrow for all windows\n\tredraw_later(NOT_VALID);\n    }\n    win_enter(win1, FALSE);\n}\n\n/*\n * Make all windows the same height.\n * 'next_curwin' will soon be the current window, make sure it has enough\n * rows.\n */\n    void\nwin_equal(\n    win_T\t*next_curwin,\t// pointer to current window to be or NULL\n    int\t\tcurrent,\t// do only frame with current window\n    int\t\tdir)\t\t// 'v' for vertically, 'h' for horizontally,\n\t\t\t\t// 'b' for both, 0 for using p_ead\n{\n    if (dir == 0)\n\tdir = *p_ead;\n    win_equal_rec(next_curwin == NULL ? curwin : next_curwin, current,\n\t\t      topframe, dir, 0, tabline_height(),\n\t\t\t\t\t   (int)Columns, topframe->fr_height);\n}\n\n/*\n * Set a frame to a new position and height, spreading the available room\n * equally over contained frames.\n * The window \"next_curwin\" (if not NULL) should at least get the size from\n * 'winheight' and 'winwidth' if possible.\n */\n    static void\nwin_equal_rec(\n    win_T\t*next_curwin,\t// pointer to current window to be or NULL\n    int\t\tcurrent,\t// do only frame with current window\n    frame_T\t*topfr,\t\t// frame to set size off\n    int\t\tdir,\t\t// 'v', 'h' or 'b', see win_equal()\n    int\t\tcol,\t\t// horizontal position for frame\n    int\t\trow,\t\t// vertical position for frame\n    int\t\twidth,\t\t// new width of frame\n    int\t\theight)\t\t// new height of frame\n{\n    int\t\tn, m;\n    int\t\textra_sep = 0;\n    int\t\twincount, totwincount = 0;\n    frame_T\t*fr;\n    int\t\tnext_curwin_size = 0;\n    int\t\troom = 0;\n    int\t\tnew_size;\n    int\t\thas_next_curwin = 0;\n    int\t\thnc;\n\n    if (topfr->fr_layout == FR_LEAF)\n    {\n\t// Set the width/height of this frame.\n\t// Redraw when size or position changes\n\tif (topfr->fr_height != height || topfr->fr_win->w_winrow != row\n\t\t|| topfr->fr_width != width || topfr->fr_win->w_wincol != col\n\t   )\n\t{\n\t    topfr->fr_win->w_winrow = row;\n\t    frame_new_height(topfr, height, FALSE, FALSE);\n\t    topfr->fr_win->w_wincol = col;\n\t    frame_new_width(topfr, width, FALSE, FALSE);\n\t    redraw_all_later(NOT_VALID);\n\t}\n    }\n    else if (topfr->fr_layout == FR_ROW)\n    {\n\ttopfr->fr_width = width;\n\ttopfr->fr_height = height;\n\n\tif (dir != 'v')\t\t\t// equalize frame widths\n\t{\n\t    // Compute the maximum number of windows horizontally in this\n\t    // frame.\n\t    n = frame_minwidth(topfr, NOWIN);\n\t    // add one for the rightmost window, it doesn't have a separator\n\t    if (col + width == Columns)\n\t\textra_sep = 1;\n\t    else\n\t\textra_sep = 0;\n\t    totwincount = (n + extra_sep) / (p_wmw + 1);\n\t    has_next_curwin = frame_has_win(topfr, next_curwin);\n\n\t    /*\n\t     * Compute width for \"next_curwin\" window and room available for\n\t     * other windows.\n\t     * \"m\" is the minimal width when counting p_wiw for \"next_curwin\".\n\t     */\n\t    m = frame_minwidth(topfr, next_curwin);\n\t    room = width - m;\n\t    if (room < 0)\n\t    {\n\t\tnext_curwin_size = p_wiw + room;\n\t\troom = 0;\n\t    }\n\t    else\n\t    {\n\t\tnext_curwin_size = -1;\n\t\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t\t{\n\t\t    // If 'winfixwidth' set keep the window width if\n\t\t    // possible.\n\t\t    // Watch out for this window being the next_curwin.\n\t\t    if (frame_fixed_width(fr))\n\t\t    {\n\t\t\tn = frame_minwidth(fr, NOWIN);\n\t\t\tnew_size = fr->fr_width;\n\t\t\tif (frame_has_win(fr, next_curwin))\n\t\t\t{\n\t\t\t    room += p_wiw - p_wmw;\n\t\t\t    next_curwin_size = 0;\n\t\t\t    if (new_size < p_wiw)\n\t\t\t\tnew_size = p_wiw;\n\t\t\t}\n\t\t\telse\n\t\t\t    // These windows don't use up room.\n\t\t\t    totwincount -= (n + (fr->fr_next == NULL\n\t\t\t\t\t      ? extra_sep : 0)) / (p_wmw + 1);\n\t\t\troom -= new_size - n;\n\t\t\tif (room < 0)\n\t\t\t{\n\t\t\t    new_size += room;\n\t\t\t    room = 0;\n\t\t\t}\n\t\t\tfr->fr_newwidth = new_size;\n\t\t    }\n\t\t}\n\t\tif (next_curwin_size == -1)\n\t\t{\n\t\t    if (!has_next_curwin)\n\t\t\tnext_curwin_size = 0;\n\t\t    else if (totwincount > 1\n\t\t\t    && (room + (totwincount - 2))\n\t\t\t\t\t\t  / (totwincount - 1) > p_wiw)\n\t\t    {\n\t\t\t// Can make all windows wider than 'winwidth', spread\n\t\t\t// the room equally.\n\t\t\tnext_curwin_size = (room + p_wiw\n\t\t\t\t\t    + (totwincount - 1) * p_wmw\n\t\t\t\t\t    + (totwincount - 1)) / totwincount;\n\t\t\troom -= next_curwin_size - p_wiw;\n\t\t    }\n\t\t    else\n\t\t\tnext_curwin_size = p_wiw;\n\t\t}\n\t    }\n\n\t    if (has_next_curwin)\n\t\t--totwincount;\t\t// don't count curwin\n\t}\n\n\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t{\n\t    wincount = 1;\n\t    if (fr->fr_next == NULL)\n\t\t// last frame gets all that remains (avoid roundoff error)\n\t\tnew_size = width;\n\t    else if (dir == 'v')\n\t\tnew_size = fr->fr_width;\n\t    else if (frame_fixed_width(fr))\n\t    {\n\t\tnew_size = fr->fr_newwidth;\n\t\twincount = 0;\t    // doesn't count as a sizeable window\n\t    }\n\t    else\n\t    {\n\t\t// Compute the maximum number of windows horiz. in \"fr\".\n\t\tn = frame_minwidth(fr, NOWIN);\n\t\twincount = (n + (fr->fr_next == NULL ? extra_sep : 0))\n\t\t\t\t\t\t\t\t/ (p_wmw + 1);\n\t\tm = frame_minwidth(fr, next_curwin);\n\t\tif (has_next_curwin)\n\t\t    hnc = frame_has_win(fr, next_curwin);\n\t\telse\n\t\t    hnc = FALSE;\n\t\tif (hnc)\t    // don't count next_curwin\n\t\t    --wincount;\n\t\tif (totwincount == 0)\n\t\t    new_size = room;\n\t\telse\n\t\t    new_size = (wincount * room + ((unsigned)totwincount >> 1))\n\t\t\t\t\t\t\t\t/ totwincount;\n\t\tif (hnc)\t    // add next_curwin size\n\t\t{\n\t\t    next_curwin_size -= p_wiw - (m - n);\n\t\t    new_size += next_curwin_size;\n\t\t    room -= new_size - next_curwin_size;\n\t\t}\n\t\telse\n\t\t    room -= new_size;\n\t\tnew_size += n;\n\t    }\n\n\t    // Skip frame that is full width when splitting or closing a\n\t    // window, unless equalizing all frames.\n\t    if (!current || dir != 'v' || topfr->fr_parent != NULL\n\t\t    || (new_size != fr->fr_width)\n\t\t    || frame_has_win(fr, next_curwin))\n\t\twin_equal_rec(next_curwin, current, fr, dir, col, row,\n\t\t\t\t\t\t\t    new_size, height);\n\t    col += new_size;\n\t    width -= new_size;\n\t    totwincount -= wincount;\n\t}\n    }\n    else // topfr->fr_layout == FR_COL\n    {\n\ttopfr->fr_width = width;\n\ttopfr->fr_height = height;\n\n\tif (dir != 'h')\t\t\t// equalize frame heights\n\t{\n\t    // Compute maximum number of windows vertically in this frame.\n\t    n = frame_minheight(topfr, NOWIN);\n\t    // add one for the bottom window if it doesn't have a statusline\n\t    if (row + height == cmdline_row && p_ls == 0)\n\t\textra_sep = 1;\n\t    else\n\t\textra_sep = 0;\n\t    totwincount = (n + extra_sep) / (p_wmh + 1);\n\t    has_next_curwin = frame_has_win(topfr, next_curwin);\n\n\t    /*\n\t     * Compute height for \"next_curwin\" window and room available for\n\t     * other windows.\n\t     * \"m\" is the minimal height when counting p_wh for \"next_curwin\".\n\t     */\n\t    m = frame_minheight(topfr, next_curwin);\n\t    room = height - m;\n\t    if (room < 0)\n\t    {\n\t\t// The room is less than 'winheight', use all space for the\n\t\t// current window.\n\t\tnext_curwin_size = p_wh + room;\n\t\troom = 0;\n\t    }\n\t    else\n\t    {\n\t\tnext_curwin_size = -1;\n\t\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t\t{\n\t\t    // If 'winfixheight' set keep the window height if\n\t\t    // possible.\n\t\t    // Watch out for this window being the next_curwin.\n\t\t    if (frame_fixed_height(fr))\n\t\t    {\n\t\t\tn = frame_minheight(fr, NOWIN);\n\t\t\tnew_size = fr->fr_height;\n\t\t\tif (frame_has_win(fr, next_curwin))\n\t\t\t{\n\t\t\t    room += p_wh - p_wmh;\n\t\t\t    next_curwin_size = 0;\n\t\t\t    if (new_size < p_wh)\n\t\t\t\tnew_size = p_wh;\n\t\t\t}\n\t\t\telse\n\t\t\t    // These windows don't use up room.\n\t\t\t    totwincount -= (n + (fr->fr_next == NULL\n\t\t\t\t\t      ? extra_sep : 0)) / (p_wmh + 1);\n\t\t\troom -= new_size - n;\n\t\t\tif (room < 0)\n\t\t\t{\n\t\t\t    new_size += room;\n\t\t\t    room = 0;\n\t\t\t}\n\t\t\tfr->fr_newheight = new_size;\n\t\t    }\n\t\t}\n\t\tif (next_curwin_size == -1)\n\t\t{\n\t\t    if (!has_next_curwin)\n\t\t\tnext_curwin_size = 0;\n\t\t    else if (totwincount > 1\n\t\t\t    && (room + (totwincount - 2))\n\t\t\t\t\t\t   / (totwincount - 1) > p_wh)\n\t\t    {\n\t\t\t// can make all windows higher than 'winheight',\n\t\t\t// spread the room equally.\n\t\t\tnext_curwin_size = (room + p_wh\n\t\t\t\t\t   + (totwincount - 1) * p_wmh\n\t\t\t\t\t   + (totwincount - 1)) / totwincount;\n\t\t\troom -= next_curwin_size - p_wh;\n\t\t    }\n\t\t    else\n\t\t\tnext_curwin_size = p_wh;\n\t\t}\n\t    }\n\n\t    if (has_next_curwin)\n\t\t--totwincount;\t\t// don't count curwin\n\t}\n\n\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t{\n\t    wincount = 1;\n\t    if (fr->fr_next == NULL)\n\t\t// last frame gets all that remains (avoid roundoff error)\n\t\tnew_size = height;\n\t    else if (dir == 'h')\n\t\tnew_size = fr->fr_height;\n\t    else if (frame_fixed_height(fr))\n\t    {\n\t\tnew_size = fr->fr_newheight;\n\t\twincount = 0;\t    // doesn't count as a sizeable window\n\t    }\n\t    else\n\t    {\n\t\t// Compute the maximum number of windows vert. in \"fr\".\n\t\tn = frame_minheight(fr, NOWIN);\n\t\twincount = (n + (fr->fr_next == NULL ? extra_sep : 0))\n\t\t\t\t\t\t\t\t/ (p_wmh + 1);\n\t\tm = frame_minheight(fr, next_curwin);\n\t\tif (has_next_curwin)\n\t\t    hnc = frame_has_win(fr, next_curwin);\n\t\telse\n\t\t    hnc = FALSE;\n\t\tif (hnc)\t    // don't count next_curwin\n\t\t    --wincount;\n\t\tif (totwincount == 0)\n\t\t    new_size = room;\n\t\telse\n\t\t    new_size = (wincount * room + ((unsigned)totwincount >> 1))\n\t\t\t\t\t\t\t\t/ totwincount;\n\t\tif (hnc)\t    // add next_curwin size\n\t\t{\n\t\t    next_curwin_size -= p_wh - (m - n);\n\t\t    new_size += next_curwin_size;\n\t\t    room -= new_size - next_curwin_size;\n\t\t}\n\t\telse\n\t\t    room -= new_size;\n\t\tnew_size += n;\n\t    }\n\t    // Skip frame that is full width when splitting or closing a\n\t    // window, unless equalizing all frames.\n\t    if (!current || dir != 'h' || topfr->fr_parent != NULL\n\t\t    || (new_size != fr->fr_height)\n\t\t    || frame_has_win(fr, next_curwin))\n\t\twin_equal_rec(next_curwin, current, fr, dir, col, row,\n\t\t\t\t\t\t\t     width, new_size);\n\t    row += new_size;\n\t    height -= new_size;\n\t    totwincount -= wincount;\n\t}\n    }\n}\n\n#ifdef FEAT_JOB_CHANNEL\n    static void\nleaving_window(win_T *win)\n{\n    // Only matters for a prompt window.\n    if (!bt_prompt(win->w_buffer))\n\treturn;\n\n    // When leaving a prompt window stop Insert mode and perhaps restart\n    // it when entering that window again.\n    win->w_buffer->b_prompt_insert = restart_edit;\n    if (restart_edit != 0 && mode_displayed)\n\tclear_cmdline = TRUE;\t\t// unshow mode later\n    restart_edit = NUL;\n\n    // When leaving the window (or closing the window) was done from a\n    // callback we need to break out of the Insert mode loop and restart Insert\n    // mode when entering the window again.\n    if (State & MODE_INSERT)\n    {\n\tstop_insert_mode = TRUE;\n\tif (win->w_buffer->b_prompt_insert == NUL)\n\t    win->w_buffer->b_prompt_insert = 'A';\n    }\n}\n\n    void\nentering_window(win_T *win)\n{\n    // Only matters for a prompt window.\n    if (!bt_prompt(win->w_buffer))\n\treturn;\n\n    // When switching to a prompt buffer that was in Insert mode, don't stop\n    // Insert mode, it may have been set in leaving_window().\n    if (win->w_buffer->b_prompt_insert != NUL)\n\tstop_insert_mode = FALSE;\n\n    // When entering the prompt window restart Insert mode if we were in Insert\n    // mode when we left it and not already in Insert mode.\n    if ((State & MODE_INSERT) == 0)\n\trestart_edit = win->w_buffer->b_prompt_insert;\n}\n#endif\n\n    static void\nwin_init_empty(win_T *wp)\n{\n    redraw_win_later(wp, NOT_VALID);\n    wp->w_lines_valid = 0;\n    wp->w_cursor.lnum = 1;\n    wp->w_curswant = wp->w_cursor.col = 0;\n    wp->w_cursor.coladd = 0;\n    wp->w_pcmark.lnum = 1;\t// pcmark not cleared but set to line 1\n    wp->w_pcmark.col = 0;\n    wp->w_prev_pcmark.lnum = 0;\n    wp->w_prev_pcmark.col = 0;\n    wp->w_topline = 1;\n#ifdef FEAT_DIFF\n    wp->w_topfill = 0;\n#endif\n    wp->w_botline = 2;\n#if defined(FEAT_SYN_HL) || defined(FEAT_SPELL)\n    wp->w_s = &wp->w_buffer->b_s;\n#endif\n#ifdef FEAT_TERMINAL\n    term_reset_wincolor(wp);\n#endif\n}\n\n/*\n * Init the current window \"curwin\".\n * Called when a new file is being edited.\n */\n    void\ncurwin_init(void)\n{\n    win_init_empty(curwin);\n}\n\n/*\n * Close all windows for buffer \"buf\".\n */\n    void\nclose_windows(\n    buf_T\t*buf,\n    int\t\tkeep_curwin)\t    // don't close \"curwin\"\n{\n    win_T\t*wp;\n    tabpage_T   *tp, *nexttp;\n    int\t\th = tabline_height();\n    int\t\tcount = tabpage_index(NULL);\n\n    ++RedrawingDisabled;\n\n    for (wp = firstwin; wp != NULL && !ONE_WINDOW; )\n    {\n\tif (wp->w_buffer == buf && (!keep_curwin || wp != curwin)\n\t\t&& !(wp->w_closing || wp->w_buffer->b_locked > 0))\n\t{\n\t    if (win_close(wp, FALSE) == FAIL)\n\t\t// If closing the window fails give up, to avoid looping\n\t\t// forever.\n\t\tbreak;\n\n\t    // Start all over, autocommands may change the window layout.\n\t    wp = firstwin;\n\t}\n\telse\n\t    wp = wp->w_next;\n    }\n\n    // Also check windows in other tab pages.\n    for (tp = first_tabpage; tp != NULL; tp = nexttp)\n    {\n\tnexttp = tp->tp_next;\n\tif (tp != curtab)\n\t    FOR_ALL_WINDOWS_IN_TAB(tp, wp)\n\t\tif (wp->w_buffer == buf\n\t\t    && !(wp->w_closing || wp->w_buffer->b_locked > 0))\n\t\t{\n\t\t    win_close_othertab(wp, FALSE, tp);\n\n\t\t    // Start all over, the tab page may be closed and\n\t\t    // autocommands may change the window layout.\n\t\t    nexttp = first_tabpage;\n\t\t    break;\n\t\t}\n    }\n\n    --RedrawingDisabled;\n\n    if (count != tabpage_index(NULL))\n\tapply_autocmds(EVENT_TABCLOSED, NULL, NULL, FALSE, curbuf);\n\n    redraw_tabline = TRUE;\n    if (h != tabline_height())\n\tshell_new_rows();\n}\n\n/*\n * Return TRUE if the current window is the only window that exists (ignoring\n * \"aucmd_win\").\n * Returns FALSE if there is a window, possibly in another tab page.\n */\n    static int\nlast_window(void)\n{\n    return (one_window() && first_tabpage->tp_next == NULL);\n}\n\n/*\n * Return TRUE if there is only one window other than \"aucmd_win\" in the\n * current tab page.\n */\n    int\none_window(void)\n{\n    win_T\t*wp;\n    int\t\tseen_one = FALSE;\n\n    FOR_ALL_WINDOWS(wp)\n    {\n\tif (wp != aucmd_win)\n\t{\n\t    if (seen_one)\n\t\treturn FALSE;\n\t    seen_one = TRUE;\n\t}\n    }\n    return TRUE;\n}\n\n/*\n * Close the possibly last window in a tab page.\n * Returns TRUE when the window was closed already.\n */\n    static int\nclose_last_window_tabpage(\n    win_T\t*win,\n    int\t\tfree_buf,\n    tabpage_T   *prev_curtab)\n{\n    if (ONE_WINDOW)\n    {\n\tbuf_T\t*old_curbuf = curbuf;\n\n\t/*\n\t * Closing the last window in a tab page.  First go to another tab\n\t * page and then close the window and the tab page.  This avoids that\n\t * curwin and curtab are invalid while we are freeing memory, they may\n\t * be used in GUI events.\n\t * Don't trigger autocommands yet, they may use wrong values, so do\n\t * that below.\n\t */\n\tgoto_tabpage_tp(alt_tabpage(), FALSE, TRUE);\n\tredraw_tabline = TRUE;\n\n\t// Safety check: Autocommands may have closed the window when jumping\n\t// to the other tab page.\n\tif (valid_tabpage(prev_curtab) && prev_curtab->tp_firstwin == win)\n\t{\n\t    int\t    h = tabline_height();\n\n\t    win_close_othertab(win, free_buf, prev_curtab);\n\t    if (h != tabline_height())\n\t\tshell_new_rows();\n\t}\n#ifdef FEAT_JOB_CHANNEL\n\tentering_window(curwin);\n#endif\n\t// Since goto_tabpage_tp above did not trigger *Enter autocommands, do\n\t// that now.\n\tapply_autocmds(EVENT_TABCLOSED, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);\n\tif (old_curbuf != curbuf)\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Close the buffer of \"win\" and unload it if \"action\" is DOBUF_UNLOAD.\n * \"action\" can also be zero (do nothing) or DOBUF_WIPE.\n * \"abort_if_last\" is passed to close_buffer(): abort closing if all other\n * windows are closed.\n */\n    static void\nwin_close_buffer(win_T *win, int action, int abort_if_last)\n{\n#ifdef FEAT_SYN_HL\n    // Free independent synblock before the buffer is freed.\n    if (win->w_buffer != NULL)\n\treset_synblock(win);\n#endif\n\n#ifdef FEAT_QUICKFIX\n    // When a quickfix/location list window is closed and the buffer is\n    // displayed in only one window, then unlist the buffer.\n    if (win->w_buffer != NULL && bt_quickfix(win->w_buffer)\n\t\t\t\t\t&& win->w_buffer->b_nwindows == 1)\n\twin->w_buffer->b_p_bl = FALSE;\n#endif\n\n    // Close the link to the buffer.\n    if (win->w_buffer != NULL)\n    {\n\tbufref_T    bufref;\n\n\tset_bufref(&bufref, curbuf);\n\twin->w_closing = TRUE;\n\tclose_buffer(win, win->w_buffer, action, abort_if_last, TRUE);\n\tif (win_valid_any_tab(win))\n\t    win->w_closing = FALSE;\n\t// Make sure curbuf is valid. It can become invalid if 'bufhidden' is\n\t// \"wipe\".\n\tif (!bufref_valid(&bufref))\n\t    curbuf = firstbuf;\n    }\n}\n\n/*\n * Close window \"win\".  Only works for the current tab page.\n * If \"free_buf\" is TRUE related buffer may be unloaded.\n *\n * Called by :quit, :close, :xit, :wq and findtag().\n * Returns FAIL when the window was not closed.\n */\n    int\nwin_close(win_T *win, int free_buf)\n{\n    win_T\t*wp;\n    int\t\tother_buffer = FALSE;\n    int\t\tclose_curwin = FALSE;\n    int\t\tdir;\n    int\t\thelp_window = FALSE;\n    tabpage_T   *prev_curtab = curtab;\n    frame_T\t*win_frame = win->w_frame->fr_parent;\n#ifdef FEAT_DIFF\n    int\t\thad_diffmode = win->w_p_diff;\n#endif\n#ifdef MESSAGE_QUEUE\n    int\t\tdid_decrement = FALSE;\n#endif\n\n#if defined(FEAT_TERMINAL) && defined(FEAT_PROP_POPUP)\n    // Can close a popup window with a terminal if the job has finished.\n    if (may_close_term_popup() == OK)\n\treturn OK;\n#endif\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn FAIL;\n\n    if (last_window())\n    {\n\temsg(_(e_cannot_close_last_window));\n\treturn FAIL;\n    }\n\n    if (win->w_closing || (win->w_buffer != NULL\n\t\t\t\t\t       && win->w_buffer->b_locked > 0))\n\treturn FAIL; // window is already being closed\n    if (win_unlisted(win))\n    {\n\temsg(_(e_cannot_close_autocmd_or_popup_window));\n\treturn FAIL;\n    }\n    if ((firstwin == aucmd_win || lastwin == aucmd_win) && one_window())\n    {\n\temsg(_(e_cannot_close_window_only_autocmd_window_would_remain));\n\treturn FAIL;\n    }\n\n    // When closing the last window in a tab page first go to another tab page\n    // and then close the window and the tab page to avoid that curwin and\n    // curtab are invalid while we are freeing memory.\n    if (close_last_window_tabpage(win, free_buf, prev_curtab))\n      return FAIL;\n\n    // When closing the help window, try restoring a snapshot after closing\n    // the window.  Otherwise clear the snapshot, it's now invalid.\n    if (bt_help(win->w_buffer))\n\thelp_window = TRUE;\n    else\n\tclear_snapshot(curtab, SNAP_HELP_IDX);\n\n    if (win == curwin)\n    {\n#ifdef FEAT_JOB_CHANNEL\n\tleaving_window(curwin);\n#endif\n\t/*\n\t * Guess which window is going to be the new current window.\n\t * This may change because of the autocommands (sigh).\n\t */\n\twp = frame2win(win_altframe(win, NULL));\n\n\t/*\n\t * Be careful: If autocommands delete the window or cause this window\n\t * to be the last one left, return now.\n\t */\n\tif (wp->w_buffer != curbuf)\n\t{\n\t    reset_VIsual_and_resel();\t// stop Visual mode\n\n\t    other_buffer = TRUE;\n\t    win->w_closing = TRUE;\n\t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n\t    if (!win_valid(win))\n\t\treturn FAIL;\n\t    win->w_closing = FALSE;\n\t    if (last_window())\n\t\treturn FAIL;\n\t}\n\twin->w_closing = TRUE;\n\tapply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (!win_valid(win))\n\t    return FAIL;\n\twin->w_closing = FALSE;\n\tif (last_window())\n\t    return FAIL;\n#ifdef FEAT_EVAL\n\t// autocmds may abort script processing\n\tif (aborting())\n\t    return FAIL;\n#endif\n    }\n\n#ifdef FEAT_GUI\n    // Avoid trouble with scrollbars that are going to be deleted in\n    // win_free().\n    if (gui.in_use)\n\tout_flush();\n#endif\n\n#ifdef FEAT_PROP_POPUP\n    if (popup_win_closed(win) && !win_valid(win))\n\treturn FAIL;\n#endif\n\n    // Trigger WinClosed just before starting to free window-related resources.\n    trigger_winclosed(win);\n    // autocmd may have freed the window already.\n    if (!win_valid_any_tab(win))\n\treturn OK;\n\n    win_close_buffer(win, free_buf ? DOBUF_UNLOAD : 0, TRUE);\n\n    if (only_one_window() && win_valid(win) && win->w_buffer == NULL\n\t    && (last_window() || curtab != prev_curtab\n\t\t|| close_last_window_tabpage(win, free_buf, prev_curtab)))\n    {\n\t// Autocommands have closed all windows, quit now.  Restore\n\t// curwin->w_buffer, otherwise writing viminfo may fail.\n\tif (curwin->w_buffer == NULL)\n\t    curwin->w_buffer = curbuf;\n\tgetout(0);\n    }\n\n    // Autocommands may have moved to another tab page.\n    if (curtab != prev_curtab && win_valid_any_tab(win)\n\t\t\t\t\t\t      && win->w_buffer == NULL)\n    {\n\t// Need to close the window anyway, since the buffer is NULL.\n\twin_close_othertab(win, FALSE, prev_curtab);\n\treturn FAIL;\n    }\n\n    // Autocommands may have closed the window already or closed the only\n    // other window.\n    if (!win_valid(win) || last_window()\n\t    || close_last_window_tabpage(win, free_buf, prev_curtab))\n\treturn FAIL;\n\n    // Now we are really going to close the window.  Disallow any autocommand\n    // to split a window to avoid trouble.\n    // Also bail out of parse_queued_messages() to avoid it tries to update the\n    // screen.\n    ++split_disallowed;\n#ifdef MESSAGE_QUEUE\n    ++dont_parse_messages;\n#endif\n\n    // Free the memory used for the window and get the window that received\n    // the screen space.\n    wp = win_free_mem(win, &dir, NULL);\n\n    if (help_window)\n    {\n\t// Closing the help window moves the cursor back to the current window\n\t// of the snapshot.\n\twin_T *prev_win = get_snapshot_curwin(SNAP_HELP_IDX);\n\n\tif (win_valid(prev_win))\n\t    wp = prev_win;\n    }\n\n    // Make sure curwin isn't invalid.  It can cause severe trouble when\n    // printing an error message.  For win_equal() curbuf needs to be valid\n    // too.\n    if (win == curwin)\n    {\n\tcurwin = wp;\n#ifdef FEAT_QUICKFIX\n\tif (wp->w_p_pvw || bt_quickfix(wp->w_buffer))\n\t{\n\t    /*\n\t     * If the cursor goes to the preview or the quickfix window, try\n\t     * finding another window to go to.\n\t     */\n\t    for (;;)\n\t    {\n\t\tif (wp->w_next == NULL)\n\t\t    wp = firstwin;\n\t\telse\n\t\t    wp = wp->w_next;\n\t\tif (wp == curwin)\n\t\t    break;\n\t\tif (!wp->w_p_pvw && !bt_quickfix(wp->w_buffer))\n\t\t{\n\t\t    curwin = wp;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n#endif\n\tcurbuf = curwin->w_buffer;\n\tclose_curwin = TRUE;\n\n\t// The cursor position may be invalid if the buffer changed after last\n\t// using the window.\n\tcheck_cursor();\n    }\n    if (p_ea && (*p_ead == 'b' || *p_ead == dir))\n\t// If the frame of the closed window contains the new current window,\n\t// only resize that frame.  Otherwise resize all windows.\n\twin_equal(curwin, curwin->w_frame->fr_parent == win_frame, dir);\n    else\n\twin_comp_pos();\n    if (close_curwin)\n    {\n\t// Pass WEE_ALLOW_PARSE_MESSAGES to decrement dont_parse_messages\n\t// before autocommands.\n#ifdef MESSAGE_QUEUE\n\tdid_decrement =\n#else\n\t(void)\n#endif\n\t    win_enter_ext(wp,\n\t\tWEE_CURWIN_INVALID | WEE_TRIGGER_ENTER_AUTOCMDS\n\t\t      | WEE_TRIGGER_LEAVE_AUTOCMDS | WEE_ALLOW_PARSE_MESSAGES);\n\tif (other_buffer)\n\t    // careful: after this wp and win may be invalid!\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n    --split_disallowed;\n#ifdef MESSAGE_QUEUE\n    if (!did_decrement)\n\t--dont_parse_messages;\n#endif\n\n    /*\n     * If last window has a status line now and we don't want one,\n     * remove the status line.\n     */\n    last_status(FALSE);\n\n    // After closing the help window, try restoring the window layout from\n    // before it was opened.\n    if (help_window)\n\trestore_snapshot(SNAP_HELP_IDX, close_curwin);\n\n#ifdef FEAT_DIFF\n    // If the window had 'diff' set and now there is only one window left in\n    // the tab page with 'diff' set, and \"closeoff\" is in 'diffopt', then\n    // execute \":diffoff!\".\n    if (diffopt_closeoff() && had_diffmode && curtab == prev_curtab)\n    {\n\tint\tdiffcount = 0;\n\twin_T\t*dwin;\n\n\tFOR_ALL_WINDOWS(dwin)\n\t    if (dwin->w_p_diff)\n\t\t++diffcount;\n\tif (diffcount == 1)\n\t    do_cmdline_cmd((char_u *)\"diffoff!\");\n    }\n#endif\n\n#if defined(FEAT_GUI)\n    // When 'guioptions' includes 'L' or 'R' may have to remove scrollbars.\n    if (gui.in_use && !win_hasvertsplit())\n\tgui_init_which_components(NULL);\n#endif\n\n    redraw_all_later(NOT_VALID);\n    return OK;\n}\n\n    static void\ntrigger_winclosed(win_T *win)\n{\n    static int\trecursive = FALSE;\n    char_u\twinid[NUMBUFLEN];\n\n    if (recursive)\n\treturn;\n    recursive = TRUE;\n    vim_snprintf((char *)winid, sizeof(winid), \"%d\", win->w_id);\n    apply_autocmds(EVENT_WINCLOSED, winid, winid, FALSE, win->w_buffer);\n    recursive = FALSE;\n}\n\n/*\n * Trigger WinScrolled for \"curwin\" if needed.\n */\n    void\nmay_trigger_winscrolled(void)\n{\n    win_T\t    *wp = curwin;\n    static int\t    recursive = FALSE;\n    char_u\t    winid[NUMBUFLEN];\n\n    if (recursive || !has_winscrolled())\n\treturn;\n\n    if (wp->w_last_topline != wp->w_topline\n\t    || wp->w_last_leftcol != wp->w_leftcol\n\t    || wp->w_last_width != wp->w_width\n\t    || wp->w_last_height != wp->w_height)\n    {\n\tvim_snprintf((char *)winid, sizeof(winid), \"%d\", wp->w_id);\n\n\trecursive = TRUE;\n\tapply_autocmds(EVENT_WINSCROLLED, winid, winid, FALSE, wp->w_buffer);\n\trecursive = FALSE;\n\n\t// an autocmd may close the window, \"wp\" may be invalid now\n\tif (win_valid_any_tab(wp))\n\t{\n\t    wp->w_last_topline = wp->w_topline;\n\t    wp->w_last_leftcol = wp->w_leftcol;\n\t    wp->w_last_width = wp->w_width;\n\t    wp->w_last_height = wp->w_height;\n\t}\n    }\n}\n\n/*\n * Close window \"win\" in tab page \"tp\", which is not the current tab page.\n * This may be the last window in that tab page and result in closing the tab,\n * thus \"tp\" may become invalid!\n * Caller must check if buffer is hidden and whether the tabline needs to be\n * updated.\n */\n    void\nwin_close_othertab(win_T *win, int free_buf, tabpage_T *tp)\n{\n    win_T\t*wp;\n    int\t\tdir;\n    tabpage_T   *ptp = NULL;\n    int\t\tfree_tp = FALSE;\n\n    // Get here with win->w_buffer == NULL when win_close() detects the tab\n    // page changed.\n    if (win->w_closing || (win->w_buffer != NULL\n\t\t\t\t\t       && win->w_buffer->b_locked > 0))\n\treturn; // window is already being closed\n\n    // Trigger WinClosed just before starting to free window-related resources.\n    trigger_winclosed(win);\n    // autocmd may have freed the window already.\n    if (!win_valid_any_tab(win))\n\treturn;\n\n    if (win->w_buffer != NULL)\n\t// Close the link to the buffer.\n\tclose_buffer(win, win->w_buffer, free_buf ? DOBUF_UNLOAD : 0,\n\t\t\t\t\t\t\t\t FALSE, TRUE);\n\n    // Careful: Autocommands may have closed the tab page or made it the\n    // current tab page.\n    for (ptp = first_tabpage; ptp != NULL && ptp != tp; ptp = ptp->tp_next)\n\t;\n    if (ptp == NULL || tp == curtab)\n    {\n\t// If the buffer was removed from the window we have to give it any\n\t// buffer.\n\tif (win_valid_any_tab(win) && win->w_buffer == NULL)\n\t{\n\t    win->w_buffer = firstbuf;\n\t    ++firstbuf->b_nwindows;\n\t    win_init_empty(win);\n\t}\n\treturn;\n    }\n\n    // Autocommands may have closed the window already.\n    for (wp = tp->tp_firstwin; wp != NULL && wp != win; wp = wp->w_next)\n\t;\n    if (wp == NULL)\n\treturn;\n\n    // When closing the last window in a tab page remove the tab page.\n    if (tp->tp_firstwin == tp->tp_lastwin)\n    {\n\tif (tp == first_tabpage)\n\t    first_tabpage = tp->tp_next;\n\telse\n\t{\n\t    for (ptp = first_tabpage; ptp != NULL && ptp->tp_next != tp;\n\t\t\t\t\t\t\t   ptp = ptp->tp_next)\n\t\t;\n\t    if (ptp == NULL)\n\t    {\n\t\tinternal_error(\"win_close_othertab()\");\n\t\treturn;\n\t    }\n\t    ptp->tp_next = tp->tp_next;\n\t}\n\tfree_tp = TRUE;\n    }\n\n    // Free the memory used for the window.\n    win_free_mem(win, &dir, tp);\n\n    if (free_tp)\n\tfree_tabpage(tp);\n}\n\n/*\n * Free the memory used for a window.\n * Returns a pointer to the window that got the freed up space.\n */\n    static win_T *\nwin_free_mem(\n    win_T\t*win,\n    int\t\t*dirp,\t\t// set to 'v' or 'h' for direction if 'ea'\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    frame_T\t*frp;\n    win_T\t*wp;\n    tabpage_T\t*win_tp = tp == NULL ? curtab : tp;\n\n    // Remove the window and its frame from the tree of frames.\n    frp = win->w_frame;\n    wp = winframe_remove(win, dirp, tp);\n    vim_free(frp);\n    win_free(win, tp);\n\n    // When deleting the current window in the tab, select a new current\n    // window.\n    if (win == win_tp->tp_curwin)\n\twin_tp->tp_curwin = wp;\n\n    return wp;\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nwin_free_all(void)\n{\n    int\t\tdummy;\n\n#ifdef FEAT_CMDWIN\n    // avoid an error for switching tabpage with the cmdline window open\n    cmdwin_type = 0;\n#endif\n    while (first_tabpage->tp_next != NULL)\n\ttabpage_close(TRUE);\n\n    if (aucmd_win != NULL)\n    {\n\t(void)win_free_mem(aucmd_win, &dummy, NULL);\n\taucmd_win = NULL;\n    }\n\n    while (firstwin != NULL)\n\t(void)win_free_mem(firstwin, &dummy, NULL);\n\n    // No window should be used after this. Set curwin to NULL to crash\n    // instead of using freed memory.\n    curwin = NULL;\n}\n#endif\n\n/*\n * Remove a window and its frame from the tree of frames.\n * Returns a pointer to the window that got the freed up space.\n */\n    win_T *\nwinframe_remove(\n    win_T\t*win,\n    int\t\t*dirp UNUSED,\t// set to 'v' or 'h' for direction if 'ea'\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    frame_T\t*frp, *frp2, *frp3;\n    frame_T\t*frp_close = win->w_frame;\n    win_T\t*wp;\n\n    /*\n     * If there is only one window there is nothing to remove.\n     */\n    if (tp == NULL ? ONE_WINDOW : tp->tp_firstwin == tp->tp_lastwin)\n\treturn NULL;\n\n    /*\n     * Remove the window from its frame.\n     */\n    frp2 = win_altframe(win, tp);\n    wp = frame2win(frp2);\n\n    // Remove this frame from the list of frames.\n    frame_remove(frp_close);\n\n    if (frp_close->fr_parent->fr_layout == FR_COL)\n    {\n\t// When 'winfixheight' is set, try to find another frame in the column\n\t// (as close to the closed frame as possible) to distribute the height\n\t// to.\n\tif (frp2->fr_win != NULL && frp2->fr_win->w_p_wfh)\n\t{\n\t    frp = frp_close->fr_prev;\n\t    frp3 = frp_close->fr_next;\n\t    while (frp != NULL || frp3 != NULL)\n\t    {\n\t\tif (frp != NULL)\n\t\t{\n\t\t    if (!frame_fixed_height(frp))\n\t\t    {\n\t\t\tfrp2 = frp;\n\t\t\twp = frame2win(frp2);\n\t\t\tbreak;\n\t\t    }\n\t\t    frp = frp->fr_prev;\n\t\t}\n\t\tif (frp3 != NULL)\n\t\t{\n\t\t    if (frp3->fr_win != NULL && !frp3->fr_win->w_p_wfh)\n\t\t    {\n\t\t\tfrp2 = frp3;\n\t\t\twp = frp3->fr_win;\n\t\t\tbreak;\n\t\t    }\n\t\t    frp3 = frp3->fr_next;\n\t\t}\n\t    }\n\t}\n\tframe_new_height(frp2, frp2->fr_height + frp_close->fr_height,\n\t\t\t    frp2 == frp_close->fr_next ? TRUE : FALSE, FALSE);\n\t*dirp = 'v';\n    }\n    else\n    {\n\t// When 'winfixwidth' is set, try to find another frame in the column\n\t// (as close to the closed frame as possible) to distribute the width\n\t// to.\n\tif (frp2->fr_win != NULL && frp2->fr_win->w_p_wfw)\n\t{\n\t    frp = frp_close->fr_prev;\n\t    frp3 = frp_close->fr_next;\n\t    while (frp != NULL || frp3 != NULL)\n\t    {\n\t\tif (frp != NULL)\n\t\t{\n\t\t    if (!frame_fixed_width(frp))\n\t\t    {\n\t\t\tfrp2 = frp;\n\t\t\twp = frame2win(frp2);\n\t\t\tbreak;\n\t\t    }\n\t\t    frp = frp->fr_prev;\n\t\t}\n\t\tif (frp3 != NULL)\n\t\t{\n\t\t    if (frp3->fr_win != NULL && !frp3->fr_win->w_p_wfw)\n\t\t    {\n\t\t\tfrp2 = frp3;\n\t\t\twp = frp3->fr_win;\n\t\t\tbreak;\n\t\t    }\n\t\t    frp3 = frp3->fr_next;\n\t\t}\n\t    }\n\t}\n\tframe_new_width(frp2, frp2->fr_width + frp_close->fr_width,\n\t\t\t    frp2 == frp_close->fr_next ? TRUE : FALSE, FALSE);\n\t*dirp = 'h';\n    }\n\n    // If rows/columns go to a window below/right its positions need to be\n    // updated.  Can only be done after the sizes have been updated.\n    if (frp2 == frp_close->fr_next)\n    {\n\tint row = win->w_winrow;\n\tint col = win->w_wincol;\n\n\tframe_comp_pos(frp2, &row, &col);\n    }\n\n    if (frp2->fr_next == NULL && frp2->fr_prev == NULL)\n    {\n\t// There is no other frame in this list, move its info to the parent\n\t// and remove it.\n\tfrp2->fr_parent->fr_layout = frp2->fr_layout;\n\tfrp2->fr_parent->fr_child = frp2->fr_child;\n\tFOR_ALL_FRAMES(frp, frp2->fr_child)\n\t    frp->fr_parent = frp2->fr_parent;\n\tfrp2->fr_parent->fr_win = frp2->fr_win;\n\tif (frp2->fr_win != NULL)\n\t    frp2->fr_win->w_frame = frp2->fr_parent;\n\tfrp = frp2->fr_parent;\n\tif (topframe->fr_child == frp2)\n\t    topframe->fr_child = frp;\n\tvim_free(frp2);\n\n\tfrp2 = frp->fr_parent;\n\tif (frp2 != NULL && frp2->fr_layout == frp->fr_layout)\n\t{\n\t    // The frame above the parent has the same layout, have to merge\n\t    // the frames into this list.\n\t    if (frp2->fr_child == frp)\n\t\tfrp2->fr_child = frp->fr_child;\n\t    frp->fr_child->fr_prev = frp->fr_prev;\n\t    if (frp->fr_prev != NULL)\n\t\tfrp->fr_prev->fr_next = frp->fr_child;\n\t    for (frp3 = frp->fr_child; ; frp3 = frp3->fr_next)\n\t    {\n\t\tfrp3->fr_parent = frp2;\n\t\tif (frp3->fr_next == NULL)\n\t\t{\n\t\t    frp3->fr_next = frp->fr_next;\n\t\t    if (frp->fr_next != NULL)\n\t\t\tfrp->fr_next->fr_prev = frp3;\n\t\t    break;\n\t\t}\n\t    }\n\t    if (topframe->fr_child == frp)\n\t\ttopframe->fr_child = frp2;\n\t    vim_free(frp);\n\t}\n    }\n\n    return wp;\n}\n\n/*\n * Return a pointer to the frame that will receive the empty screen space that\n * is left over after \"win\" is closed.\n *\n * If 'splitbelow' or 'splitright' is set, the space goes above or to the left\n * by default.  Otherwise, the free space goes below or to the right.  The\n * result is that opening a window and then immediately closing it will\n * preserve the initial window layout.  The 'wfh' and 'wfw' settings are\n * respected when possible.\n */\n    static frame_T *\nwin_altframe(\n    win_T\t*win,\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    frame_T\t*frp;\n    frame_T\t*other_fr, *target_fr;\n\n    if (tp == NULL ? ONE_WINDOW : tp->tp_firstwin == tp->tp_lastwin)\n\treturn alt_tabpage()->tp_curwin->w_frame;\n\n    frp = win->w_frame;\n\n    if (frp->fr_prev == NULL)\n\treturn frp->fr_next;\n    if (frp->fr_next == NULL)\n\treturn frp->fr_prev;\n\n    // By default the next window will get the space that was abandoned by this\n    // window\n    target_fr = frp->fr_next;\n    other_fr  = frp->fr_prev;\n\n    // If this is part of a column of windows and 'splitbelow' is true then the\n    // previous window will get the space.\n    if (frp->fr_parent != NULL && frp->fr_parent->fr_layout == FR_COL && p_sb)\n    {\n\ttarget_fr = frp->fr_prev;\n\tother_fr  = frp->fr_next;\n    }\n\n    // If this is part of a row of windows, and 'splitright' is true then the\n    // previous window will get the space.\n    if (frp->fr_parent != NULL && frp->fr_parent->fr_layout == FR_ROW && p_spr)\n    {\n\ttarget_fr = frp->fr_prev;\n\tother_fr  = frp->fr_next;\n    }\n\n    // If 'wfh' or 'wfw' is set for the target and not for the alternate\n    // window, reverse the selection.\n    if (frp->fr_parent != NULL && frp->fr_parent->fr_layout == FR_ROW)\n    {\n\tif (frame_fixed_width(target_fr) && !frame_fixed_width(other_fr))\n\t    target_fr = other_fr;\n    }\n    else\n    {\n\tif (frame_fixed_height(target_fr) && !frame_fixed_height(other_fr))\n\t    target_fr = other_fr;\n    }\n\n    return target_fr;\n}\n\n/*\n * Return the tabpage that will be used if the current one is closed.\n */\n    static tabpage_T *\nalt_tabpage(void)\n{\n    tabpage_T\t*tp;\n\n    // Use the next tab page if possible.\n    if (curtab->tp_next != NULL)\n\treturn curtab->tp_next;\n\n    // Find the last but one tab page.\n    for (tp = first_tabpage; tp->tp_next != curtab; tp = tp->tp_next)\n\t;\n    return tp;\n}\n\n/*\n * Find the left-upper window in frame \"frp\".\n */\n    static win_T *\nframe2win(frame_T *frp)\n{\n    while (frp->fr_win == NULL)\n\tfrp = frp->fr_child;\n    return frp->fr_win;\n}\n\n/*\n * Return TRUE if frame \"frp\" contains window \"wp\".\n */\n    static int\nframe_has_win(frame_T *frp, win_T *wp)\n{\n    frame_T\t*p;\n\n    if (frp->fr_layout == FR_LEAF)\n\treturn frp->fr_win == wp;\n\n    FOR_ALL_FRAMES(p, frp->fr_child)\n\tif (frame_has_win(p, wp))\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * Set a new height for a frame.  Recursively sets the height for contained\n * frames and windows.  Caller must take care of positions.\n */\n    static void\nframe_new_height(\n    frame_T\t*topfrp,\n    int\t\theight,\n    int\t\ttopfirst,\t// resize topmost contained frame first\n    int\t\twfh)\t\t// obey 'winfixheight' when there is a choice;\n\t\t\t\t// may cause the height not to be set\n{\n    frame_T\t*frp;\n    int\t\textra_lines;\n    int\t\th;\n\n    if (topfrp->fr_win != NULL)\n    {\n\t// Simple case: just one window.\n\twin_new_height(topfrp->fr_win,\n\t\t\t\t    height - topfrp->fr_win->w_status_height\n\t\t\t\t\t      - WINBAR_HEIGHT(topfrp->fr_win));\n    }\n    else if (topfrp->fr_layout == FR_ROW)\n    {\n\tdo\n\t{\n\t    // All frames in this row get the same new height.\n\t    FOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    {\n\t\tframe_new_height(frp, height, topfirst, wfh);\n\t\tif (frp->fr_height > height)\n\t\t{\n\t\t    // Could not fit the windows, make the whole row higher.\n\t\t    height = frp->fr_height;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\twhile (frp != NULL);\n    }\n    else    // fr_layout == FR_COL\n    {\n\t// Complicated case: Resize a column of frames.  Resize the bottom\n\t// frame first, frames above that when needed.\n\n\tfrp = topfrp->fr_child;\n\tif (wfh)\n\t    // Advance past frames with one window with 'wfh' set.\n\t    while (frame_fixed_height(frp))\n\t    {\n\t\tfrp = frp->fr_next;\n\t\tif (frp == NULL)\n\t\t    return;\t    // no frame without 'wfh', give up\n\t    }\n\tif (!topfirst)\n\t{\n\t    // Find the bottom frame of this column\n\t    while (frp->fr_next != NULL)\n\t\tfrp = frp->fr_next;\n\t    if (wfh)\n\t\t// Advance back for frames with one window with 'wfh' set.\n\t\twhile (frame_fixed_height(frp))\n\t\t    frp = frp->fr_prev;\n\t}\n\n\textra_lines = height - topfrp->fr_height;\n\tif (extra_lines < 0)\n\t{\n\t    // reduce height of contained frames, bottom or top frame first\n\t    while (frp != NULL)\n\t    {\n\t\th = frame_minheight(frp, NULL);\n\t\tif (frp->fr_height + extra_lines < h)\n\t\t{\n\t\t    extra_lines += frp->fr_height - h;\n\t\t    frame_new_height(frp, h, topfirst, wfh);\n\t\t}\n\t\telse\n\t\t{\n\t\t    frame_new_height(frp, frp->fr_height + extra_lines,\n\t\t\t\t\t\t\t       topfirst, wfh);\n\t\t    break;\n\t\t}\n\t\tif (topfirst)\n\t\t{\n\t\t    do\n\t\t\tfrp = frp->fr_next;\n\t\t    while (wfh && frp != NULL && frame_fixed_height(frp));\n\t\t}\n\t\telse\n\t\t{\n\t\t    do\n\t\t\tfrp = frp->fr_prev;\n\t\t    while (wfh && frp != NULL && frame_fixed_height(frp));\n\t\t}\n\t\t// Increase \"height\" if we could not reduce enough frames.\n\t\tif (frp == NULL)\n\t\t    height -= extra_lines;\n\t    }\n\t}\n\telse if (extra_lines > 0)\n\t{\n\t    // increase height of bottom or top frame\n\t    frame_new_height(frp, frp->fr_height + extra_lines, topfirst, wfh);\n\t}\n    }\n    topfrp->fr_height = height;\n}\n\n/*\n * Return TRUE if height of frame \"frp\" should not be changed because of\n * the 'winfixheight' option.\n */\n    static int\nframe_fixed_height(frame_T *frp)\n{\n    // frame with one window: fixed height if 'winfixheight' set.\n    if (frp->fr_win != NULL)\n\treturn frp->fr_win->w_p_wfh;\n\n    if (frp->fr_layout == FR_ROW)\n    {\n\t// The frame is fixed height if one of the frames in the row is fixed\n\t// height.\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    if (frame_fixed_height(frp))\n\t\treturn TRUE;\n\treturn FALSE;\n    }\n\n    // frp->fr_layout == FR_COL: The frame is fixed height if all of the\n    // frames in the row are fixed height.\n    FOR_ALL_FRAMES(frp, frp->fr_child)\n\tif (!frame_fixed_height(frp))\n\t    return FALSE;\n    return TRUE;\n}\n\n/*\n * Return TRUE if width of frame \"frp\" should not be changed because of\n * the 'winfixwidth' option.\n */\n    static int\nframe_fixed_width(frame_T *frp)\n{\n    // frame with one window: fixed width if 'winfixwidth' set.\n    if (frp->fr_win != NULL)\n\treturn frp->fr_win->w_p_wfw;\n\n    if (frp->fr_layout == FR_COL)\n    {\n\t// The frame is fixed width if one of the frames in the row is fixed\n\t// width.\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    if (frame_fixed_width(frp))\n\t\treturn TRUE;\n\treturn FALSE;\n    }\n\n    // frp->fr_layout == FR_ROW: The frame is fixed width if all of the\n    // frames in the row are fixed width.\n    FOR_ALL_FRAMES(frp, frp->fr_child)\n\tif (!frame_fixed_width(frp))\n\t    return FALSE;\n    return TRUE;\n}\n\n/*\n * Add a status line to windows at the bottom of \"frp\".\n * Note: Does not check if there is room!\n */\n    static void\nframe_add_statusline(frame_T *frp)\n{\n    win_T\t*wp;\n\n    if (frp->fr_layout == FR_LEAF)\n    {\n\twp = frp->fr_win;\n\tif (wp->w_status_height == 0)\n\t{\n\t    if (wp->w_height > 0)\t// don't make it negative\n\t\t--wp->w_height;\n\t    wp->w_status_height = STATUS_HEIGHT;\n\t}\n    }\n    else if (frp->fr_layout == FR_ROW)\n    {\n\t// Handle all the frames in the row.\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    frame_add_statusline(frp);\n    }\n    else // frp->fr_layout == FR_COL\n    {\n\t// Only need to handle the last frame in the column.\n\tfor (frp = frp->fr_child; frp->fr_next != NULL; frp = frp->fr_next)\n\t    ;\n\tframe_add_statusline(frp);\n    }\n}\n\n/*\n * Set width of a frame.  Handles recursively going through contained frames.\n * May remove separator line for windows at the right side (for win_close()).\n */\n    static void\nframe_new_width(\n    frame_T\t*topfrp,\n    int\t\twidth,\n    int\t\tleftfirst,\t// resize leftmost contained frame first\n    int\t\twfw)\t\t// obey 'winfixwidth' when there is a choice;\n\t\t\t\t// may cause the width not to be set\n{\n    frame_T\t*frp;\n    int\t\textra_cols;\n    int\t\tw;\n    win_T\t*wp;\n\n    if (topfrp->fr_layout == FR_LEAF)\n    {\n\t// Simple case: just one window.\n\twp = topfrp->fr_win;\n\t// Find out if there are any windows right of this one.\n\tfor (frp = topfrp; frp->fr_parent != NULL; frp = frp->fr_parent)\n\t    if (frp->fr_parent->fr_layout == FR_ROW && frp->fr_next != NULL)\n\t\tbreak;\n\tif (frp->fr_parent == NULL)\n\t    wp->w_vsep_width = 0;\n\twin_new_width(wp, width - wp->w_vsep_width);\n    }\n    else if (topfrp->fr_layout == FR_COL)\n    {\n\tdo\n\t{\n\t    // All frames in this column get the same new width.\n\t    FOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    {\n\t\tframe_new_width(frp, width, leftfirst, wfw);\n\t\tif (frp->fr_width > width)\n\t\t{\n\t\t    // Could not fit the windows, make whole column wider.\n\t\t    width = frp->fr_width;\n\t\t    break;\n\t\t}\n\t    }\n\t} while (frp != NULL);\n    }\n    else    // fr_layout == FR_ROW\n    {\n\t// Complicated case: Resize a row of frames.  Resize the rightmost\n\t// frame first, frames left of it when needed.\n\n\tfrp = topfrp->fr_child;\n\tif (wfw)\n\t    // Advance past frames with one window with 'wfw' set.\n\t    while (frame_fixed_width(frp))\n\t    {\n\t\tfrp = frp->fr_next;\n\t\tif (frp == NULL)\n\t\t    return;\t    // no frame without 'wfw', give up\n\t    }\n\tif (!leftfirst)\n\t{\n\t    // Find the rightmost frame of this row\n\t    while (frp->fr_next != NULL)\n\t\tfrp = frp->fr_next;\n\t    if (wfw)\n\t\t// Advance back for frames with one window with 'wfw' set.\n\t\twhile (frame_fixed_width(frp))\n\t\t    frp = frp->fr_prev;\n\t}\n\n\textra_cols = width - topfrp->fr_width;\n\tif (extra_cols < 0)\n\t{\n\t    // reduce frame width, rightmost frame first\n\t    while (frp != NULL)\n\t    {\n\t\tw = frame_minwidth(frp, NULL);\n\t\tif (frp->fr_width + extra_cols < w)\n\t\t{\n\t\t    extra_cols += frp->fr_width - w;\n\t\t    frame_new_width(frp, w, leftfirst, wfw);\n\t\t}\n\t\telse\n\t\t{\n\t\t    frame_new_width(frp, frp->fr_width + extra_cols,\n\t\t\t\t\t\t\t      leftfirst, wfw);\n\t\t    break;\n\t\t}\n\t\tif (leftfirst)\n\t\t{\n\t\t    do\n\t\t\tfrp = frp->fr_next;\n\t\t    while (wfw && frp != NULL && frame_fixed_width(frp));\n\t\t}\n\t\telse\n\t\t{\n\t\t    do\n\t\t\tfrp = frp->fr_prev;\n\t\t    while (wfw && frp != NULL && frame_fixed_width(frp));\n\t\t}\n\t\t// Increase \"width\" if we could not reduce enough frames.\n\t\tif (frp == NULL)\n\t\t    width -= extra_cols;\n\t    }\n\t}\n\telse if (extra_cols > 0)\n\t{\n\t    // increase width of rightmost frame\n\t    frame_new_width(frp, frp->fr_width + extra_cols, leftfirst, wfw);\n\t}\n    }\n    topfrp->fr_width = width;\n}\n\n/*\n * Add the vertical separator to windows at the right side of \"frp\".\n * Note: Does not check if there is room!\n */\n    static void\nframe_add_vsep(frame_T *frp)\n{\n    win_T\t*wp;\n\n    if (frp->fr_layout == FR_LEAF)\n    {\n\twp = frp->fr_win;\n\tif (wp->w_vsep_width == 0)\n\t{\n\t    if (wp->w_width > 0)\t// don't make it negative\n\t\t--wp->w_width;\n\t    wp->w_vsep_width = 1;\n\t}\n    }\n    else if (frp->fr_layout == FR_COL)\n    {\n\t// Handle all the frames in the column.\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    frame_add_vsep(frp);\n    }\n    else // frp->fr_layout == FR_ROW\n    {\n\t// Only need to handle the last frame in the row.\n\tfrp = frp->fr_child;\n\twhile (frp->fr_next != NULL)\n\t    frp = frp->fr_next;\n\tframe_add_vsep(frp);\n    }\n}\n\n/*\n * Set frame width from the window it contains.\n */\n    static void\nframe_fix_width(win_T *wp)\n{\n    wp->w_frame->fr_width = wp->w_width + wp->w_vsep_width;\n}\n\n/*\n * Set frame height from the window it contains.\n */\n    static void\nframe_fix_height(win_T *wp)\n{\n    wp->w_frame->fr_height = VISIBLE_HEIGHT(wp) + wp->w_status_height;\n}\n\n/*\n * Compute the minimal height for frame \"topfrp\".\n * Uses the 'winminheight' option.\n * When \"next_curwin\" isn't NULL, use p_wh for this window.\n * When \"next_curwin\" is NOWIN, don't use at least one line for the current\n * window.\n */\n    static int\nframe_minheight(frame_T *topfrp, win_T *next_curwin)\n{\n    frame_T\t*frp;\n    int\t\tm;\n    int\t\tn;\n\n    if (topfrp->fr_win != NULL)\n    {\n\tif (topfrp->fr_win == next_curwin)\n\t    m = p_wh + topfrp->fr_win->w_status_height;\n\telse\n\t{\n\t    // window: minimal height of the window plus status line\n\t    m = p_wmh + topfrp->fr_win->w_status_height;\n\t    if (topfrp->fr_win == curwin && next_curwin == NULL)\n\t    {\n\t\t// Current window is minimal one line high and WinBar is\n\t\t// visible.\n\t\tif (p_wmh == 0)\n\t\t    ++m;\n\t\tm += WINBAR_HEIGHT(curwin);\n\t    }\n\t}\n    }\n    else if (topfrp->fr_layout == FR_ROW)\n    {\n\t// get the minimal height from each frame in this row\n\tm = 0;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t{\n\t    n = frame_minheight(frp, next_curwin);\n\t    if (n > m)\n\t\tm = n;\n\t}\n    }\n    else\n    {\n\t// Add up the minimal heights for all frames in this column.\n\tm = 0;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    m += frame_minheight(frp, next_curwin);\n    }\n\n    return m;\n}\n\n/*\n * Compute the minimal width for frame \"topfrp\".\n * When \"next_curwin\" isn't NULL, use p_wiw for this window.\n * When \"next_curwin\" is NOWIN, don't use at least one column for the current\n * window.\n */\n    static int\nframe_minwidth(\n    frame_T\t*topfrp,\n    win_T\t*next_curwin)\t// use p_wh and p_wiw for next_curwin\n{\n    frame_T\t*frp;\n    int\t\tm, n;\n\n    if (topfrp->fr_win != NULL)\n    {\n\tif (topfrp->fr_win == next_curwin)\n\t    m = p_wiw + topfrp->fr_win->w_vsep_width;\n\telse\n\t{\n\t    // window: minimal width of the window plus separator column\n\t    m = p_wmw + topfrp->fr_win->w_vsep_width;\n\t    // Current window is minimal one column wide\n\t    if (p_wmw == 0 && topfrp->fr_win == curwin && next_curwin == NULL)\n\t\t++m;\n\t}\n    }\n    else if (topfrp->fr_layout == FR_COL)\n    {\n\t// get the minimal width from each frame in this column\n\tm = 0;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t{\n\t    n = frame_minwidth(frp, next_curwin);\n\t    if (n > m)\n\t\tm = n;\n\t}\n    }\n    else\n    {\n\t// Add up the minimal widths for all frames in this row.\n\tm = 0;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    m += frame_minwidth(frp, next_curwin);\n    }\n\n    return m;\n}\n\n\n/*\n * Try to close all windows except current one.\n * Buffers in the other windows become hidden if 'hidden' is set, or '!' is\n * used and the buffer was modified.\n *\n * Used by \":bdel\" and \":only\".\n */\n    void\nclose_others(\n    int\t\tmessage,\n    int\t\tforceit)\t    // always hide all other windows\n{\n    win_T\t*wp;\n    win_T\t*nextwp;\n    int\t\tr;\n\n    if (one_window())\n    {\n\tif (message && !autocmd_busy)\n\t    msg(_(m_onlyone));\n\treturn;\n    }\n\n    // Be very careful here: autocommands may change the window layout.\n    for (wp = firstwin; win_valid(wp); wp = nextwp)\n    {\n\tnextwp = wp->w_next;\n\tif (wp != curwin)\t\t// don't close current window\n\t{\n\n\t    // Check if it's allowed to abandon this window\n\t    r = can_abandon(wp->w_buffer, forceit);\n\t    if (!win_valid(wp))\t\t// autocommands messed wp up\n\t    {\n\t\tnextwp = firstwin;\n\t\tcontinue;\n\t    }\n\t    if (!r)\n\t    {\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t\tif (message && (p_confirm\n\t\t\t     || (cmdmod.cmod_flags & CMOD_CONFIRM)) && p_write)\n\t\t{\n\t\t    dialog_changed(wp->w_buffer, FALSE);\n\t\t    if (!win_valid(wp))\t\t// autocommands messed wp up\n\t\t    {\n\t\t\tnextwp = firstwin;\n\t\t\tcontinue;\n\t\t    }\n\t\t}\n\t\tif (bufIsChanged(wp->w_buffer))\n#endif\n\t\t    continue;\n\t    }\n\t    win_close(wp, !buf_hide(wp->w_buffer)\n\t\t\t\t\t       && !bufIsChanged(wp->w_buffer));\n\t}\n    }\n\n    if (message && !ONE_WINDOW)\n\temsg(_(e_other_window_contains_changes));\n}\n\n/*\n * Allocate the first window and put an empty buffer in it.\n * Called from main().\n * Return FAIL when something goes wrong (out of memory).\n */\n    int\nwin_alloc_first(void)\n{\n    if (win_alloc_firstwin(NULL) == FAIL)\n\treturn FAIL;\n\n    first_tabpage = alloc_tabpage();\n    if (first_tabpage == NULL)\n\treturn FAIL;\n    first_tabpage->tp_topframe = topframe;\n    curtab = first_tabpage;\n    curtab->tp_firstwin = firstwin;\n    curtab->tp_lastwin = lastwin;\n    curtab->tp_curwin = curwin;\n\n    return OK;\n}\n\n/*\n * Allocate and init a window that is not a regular window.\n * This can only be done after the first window is fully initialized, thus it\n * can't be in win_alloc_first().\n */\n    win_T *\nwin_alloc_popup_win(void)\n{\n    win_T *wp;\n\n    wp = win_alloc(NULL, TRUE);\n    if (wp != NULL)\n    {\n\t// We need to initialize options with something, using the current\n\t// window makes most sense.\n\twin_init_some(wp, curwin);\n\n\tRESET_BINDING(wp);\n\tnew_frame(wp);\n    }\n    return wp;\n}\n\n/*\n * Initialize window \"wp\" to display buffer \"buf\".\n */\n    void\nwin_init_popup_win(win_T *wp, buf_T *buf)\n{\n    wp->w_buffer = buf;\n    ++buf->b_nwindows;\n    win_init_empty(wp); // set cursor and topline to safe values\n\n    // Make sure w_localdir and globaldir are NULL to avoid a chdir() in\n    // win_enter_ext().\n    VIM_CLEAR(wp->w_localdir);\n}\n\n/*\n * Allocate the first window or the first window in a new tab page.\n * When \"oldwin\" is NULL create an empty buffer for it.\n * When \"oldwin\" is not NULL copy info from it to the new window.\n * Return FAIL when something goes wrong (out of memory).\n */\n    static int\nwin_alloc_firstwin(win_T *oldwin)\n{\n    curwin = win_alloc(NULL, FALSE);\n    if (curwin == NULL)\n\treturn FAIL;\n    if (oldwin == NULL)\n    {\n\t// Very first window, need to create an empty buffer for it and\n\t// initialize from scratch.\n\tcurbuf = buflist_new(NULL, NULL, 1L, BLN_LISTED);\n\tif (curwin == NULL || curbuf == NULL)\n\t    return FAIL;\n\tcurwin->w_buffer = curbuf;\n#ifdef FEAT_SYN_HL\n\tcurwin->w_s = &(curbuf->b_s);\n#endif\n\tcurbuf->b_nwindows = 1;\t// there is one window\n\tcurwin->w_alist = &global_alist;\n\tcurwin_init();\t\t// init current window\n    }\n    else\n    {\n\t// First window in new tab page, initialize it from \"oldwin\".\n\twin_init(curwin, oldwin, 0);\n\n\t// We don't want cursor- and scroll-binding in the first window.\n\tRESET_BINDING(curwin);\n    }\n\n    new_frame(curwin);\n    if (curwin->w_frame == NULL)\n\treturn FAIL;\n    topframe = curwin->w_frame;\n    topframe->fr_width = Columns;\n    topframe->fr_height = Rows - p_ch;\n\n    return OK;\n}\n\n/*\n * Create a frame for window \"wp\".\n */\n    static void\nnew_frame(win_T *wp)\n{\n    frame_T *frp = ALLOC_CLEAR_ONE(frame_T);\n\n    wp->w_frame = frp;\n    if (frp != NULL)\n    {\n\tfrp->fr_layout = FR_LEAF;\n\tfrp->fr_win = wp;\n    }\n}\n\n/*\n * Initialize the window and frame size to the maximum.\n */\n    void\nwin_init_size(void)\n{\n    firstwin->w_height = ROWS_AVAIL;\n    topframe->fr_height = ROWS_AVAIL;\n    firstwin->w_width = Columns;\n    topframe->fr_width = Columns;\n}\n\n/*\n * Allocate a new tabpage_T and init the values.\n * Returns NULL when out of memory.\n */\n    static tabpage_T *\nalloc_tabpage(void)\n{\n    tabpage_T\t*tp;\n# ifdef FEAT_GUI\n    int\t\ti;\n# endif\n\n\n    tp = ALLOC_CLEAR_ONE(tabpage_T);\n    if (tp == NULL)\n\treturn NULL;\n\n# ifdef FEAT_EVAL\n    // init t: variables\n    tp->tp_vars = dict_alloc_id(aid_newtabpage_tvars);\n    if (tp->tp_vars == NULL)\n    {\n\tvim_free(tp);\n\treturn NULL;\n    }\n    init_var_dict(tp->tp_vars, &tp->tp_winvar, VAR_SCOPE);\n# endif\n\n# ifdef FEAT_GUI\n    for (i = 0; i < 3; i++)\n\ttp->tp_prev_which_scrollbars[i] = -1;\n# endif\n# ifdef FEAT_DIFF\n    tp->tp_diff_invalid = TRUE;\n# endif\n    tp->tp_ch_used = p_ch;\n\n    return tp;\n}\n\n    void\nfree_tabpage(tabpage_T *tp)\n{\n    int idx;\n\n# ifdef FEAT_DIFF\n    diff_clear(tp);\n# endif\n# ifdef FEAT_PROP_POPUP\n    while (tp->tp_first_popupwin != NULL)\n\tpopup_close_tabpage(tp, tp->tp_first_popupwin->w_id, TRUE);\n#endif\n    for (idx = 0; idx < SNAP_COUNT; ++idx)\n\tclear_snapshot(tp, idx);\n#ifdef FEAT_EVAL\n    vars_clear(&tp->tp_vars->dv_hashtab);\t// free all t: variables\n    hash_init(&tp->tp_vars->dv_hashtab);\n    unref_var_dict(tp->tp_vars);\n#endif\n\n    if (tp == lastused_tabpage)\n\tlastused_tabpage = NULL;\n\n    vim_free(tp->tp_localdir);\n    vim_free(tp->tp_prevdir);\n\n#ifdef FEAT_PYTHON\n    python_tabpage_free(tp);\n#endif\n\n#ifdef FEAT_PYTHON3\n    python3_tabpage_free(tp);\n#endif\n\n    vim_free(tp);\n}\n\n/*\n * Create a new Tab page with one window.\n * It will edit the current buffer, like after \":split\".\n * When \"after\" is 0 put it just after the current Tab page.\n * Otherwise put it just before tab page \"after\".\n * Return FAIL or OK.\n */\n    int\nwin_new_tabpage(int after)\n{\n    tabpage_T\t*tp = curtab;\n    tabpage_T\t*prev_tp = curtab;\n    tabpage_T\t*newtp;\n    int\t\tn;\n\n#ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n    {\n\temsg(_(e_invalid_in_cmdline_window));\n\treturn FAIL;\n    }\n#endif\n\n    newtp = alloc_tabpage();\n    if (newtp == NULL)\n\treturn FAIL;\n\n    // Remember the current windows in this Tab page.\n    if (leave_tabpage(curbuf, TRUE) == FAIL)\n    {\n\tvim_free(newtp);\n\treturn FAIL;\n    }\n    curtab = newtp;\n\n    newtp->tp_localdir = (tp->tp_localdir == NULL)\n\t\t\t\t    ? NULL : vim_strsave(tp->tp_localdir);\n    // Create a new empty window.\n    if (win_alloc_firstwin(tp->tp_curwin) == OK)\n    {\n\t// Make the new Tab page the new topframe.\n\tif (after == 1)\n\t{\n\t    // New tab page becomes the first one.\n\t    newtp->tp_next = first_tabpage;\n\t    first_tabpage = newtp;\n\t}\n\telse\n\t{\n\t    if (after > 0)\n\t    {\n\t\t// Put new tab page before tab page \"after\".\n\t\tn = 2;\n\t\tfor (tp = first_tabpage; tp->tp_next != NULL\n\t\t\t\t\t       && n < after; tp = tp->tp_next)\n\t\t    ++n;\n\t    }\n\t    newtp->tp_next = tp->tp_next;\n\t    tp->tp_next = newtp;\n\t}\n\tnewtp->tp_firstwin = newtp->tp_lastwin = newtp->tp_curwin = curwin;\n\n\twin_init_size();\n\tfirstwin->w_winrow = tabline_height();\n\twin_comp_scroll(curwin);\n\n\tnewtp->tp_topframe = topframe;\n\tlast_status(FALSE);\n\n\tlastused_tabpage = prev_tp;\n\n#if defined(FEAT_GUI)\n\t// When 'guioptions' includes 'L' or 'R' may have to remove or add\n\t// scrollbars.  Have to update them anyway.\n\tgui_may_update_scrollbars();\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\tentering_window(curwin);\n#endif\n\n\tredraw_all_later(NOT_VALID);\n\tapply_autocmds(EVENT_WINNEW, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABNEW, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);\n\treturn OK;\n    }\n\n    // Failed, get back the previous Tab page\n    enter_tabpage(curtab, curbuf, TRUE, TRUE);\n    return FAIL;\n}\n\n/*\n * Open a new tab page if \":tab cmd\" was used.  It will edit the same buffer,\n * like with \":split\".\n * Returns OK if a new tab page was created, FAIL otherwise.\n */\n    static int\nmay_open_tabpage(void)\n{\n    int\t\tn = (cmdmod.cmod_tab == 0)\n\t\t\t\t       ? postponed_split_tab : cmdmod.cmod_tab;\n\n    if (n != 0)\n    {\n\tcmdmod.cmod_tab = 0;\t    // reset it to avoid doing it twice\n\tpostponed_split_tab = 0;\n\treturn win_new_tabpage(n);\n    }\n    return FAIL;\n}\n\n/*\n * Create up to \"maxcount\" tabpages with empty windows.\n * Returns the number of resulting tab pages.\n */\n    int\nmake_tabpages(int maxcount)\n{\n    int\t\tcount = maxcount;\n    int\t\ttodo;\n\n    // Limit to 'tabpagemax' tabs.\n    if (count > p_tpm)\n\tcount = p_tpm;\n\n    /*\n     * Don't execute autocommands while creating the tab pages.  Must do that\n     * when putting the buffers in the windows.\n     */\n    block_autocmds();\n\n    for (todo = count - 1; todo > 0; --todo)\n\tif (win_new_tabpage(0) == FAIL)\n\t    break;\n\n    unblock_autocmds();\n\n    // return actual number of tab pages\n    return (count - todo);\n}\n\n/*\n * Return TRUE when \"tpc\" points to a valid tab page.\n */\n    int\nvalid_tabpage(tabpage_T *tpc)\n{\n    tabpage_T\t*tp;\n\n    FOR_ALL_TABPAGES(tp)\n\tif (tp == tpc)\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * Return TRUE when \"tpc\" points to a valid tab page and at least one window is\n * valid.\n */\n    int\nvalid_tabpage_win(tabpage_T *tpc)\n{\n    tabpage_T\t*tp;\n    win_T\t*wp;\n\n    FOR_ALL_TABPAGES(tp)\n    {\n\tif (tp == tpc)\n\t{\n\t    FOR_ALL_WINDOWS_IN_TAB(tp, wp)\n\t    {\n\t\tif (win_valid_any_tab(wp))\n\t\t    return TRUE;\n\t    }\n\t    return FALSE;\n\t}\n    }\n    // shouldn't happen\n    return FALSE;\n}\n\n/*\n * Close tabpage \"tab\", assuming it has no windows in it.\n * There must be another tabpage or this will crash.\n */\n    void\nclose_tabpage(tabpage_T *tab)\n{\n    tabpage_T\t*ptp;\n\n    if (tab == first_tabpage)\n    {\n\tfirst_tabpage = tab->tp_next;\n\tptp = first_tabpage;\n    }\n    else\n    {\n\tfor (ptp = first_tabpage; ptp != NULL && ptp->tp_next != tab;\n\t\t\t\t\t\t\t    ptp = ptp->tp_next)\n\t    ;\n\tassert(ptp != NULL);\n\tptp->tp_next = tab->tp_next;\n    }\n\n    goto_tabpage_tp(ptp, FALSE, FALSE);\n    free_tabpage(tab);\n}\n\n/*\n * Find tab page \"n\" (first one is 1).  Returns NULL when not found.\n */\n    tabpage_T *\nfind_tabpage(int n)\n{\n    tabpage_T\t*tp;\n    int\t\ti = 1;\n\n    if (n == 0)\n\treturn curtab;\n\n    for (tp = first_tabpage; tp != NULL && i != n; tp = tp->tp_next)\n\t++i;\n    return tp;\n}\n\n/*\n * Get index of tab page \"tp\".  First one has index 1.\n * When not found returns number of tab pages plus one.\n */\n    int\ntabpage_index(tabpage_T *ftp)\n{\n    int\t\ti = 1;\n    tabpage_T\t*tp;\n\n    for (tp = first_tabpage; tp != NULL && tp != ftp; tp = tp->tp_next)\n\t++i;\n    return i;\n}\n\n/*\n * Prepare for leaving the current tab page.\n * When autocommands change \"curtab\" we don't leave the tab page and return\n * FAIL.\n * Careful: When OK is returned need to get a new tab page very very soon!\n */\n    static int\nleave_tabpage(\n    buf_T\t*new_curbuf UNUSED,    // what is going to be the new curbuf,\n\t\t\t\t       // NULL if unknown\n    int\t\ttrigger_leave_autocmds UNUSED)\n{\n    tabpage_T\t*tp = curtab;\n\n#ifdef FEAT_JOB_CHANNEL\n    leaving_window(curwin);\n#endif\n    reset_VIsual_and_resel();\t// stop Visual mode\n    if (trigger_leave_autocmds)\n    {\n\tif (new_curbuf != curbuf)\n\t{\n\t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n\t    if (curtab != tp)\n\t\treturn FAIL;\n\t}\n\tapply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (curtab != tp)\n\t    return FAIL;\n\tapply_autocmds(EVENT_TABLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (curtab != tp)\n\t    return FAIL;\n    }\n#if defined(FEAT_GUI)\n    // Remove the scrollbars.  They may be added back later.\n    if (gui.in_use)\n\tgui_remove_scrollbars();\n#endif\n    tp->tp_curwin = curwin;\n    tp->tp_prevwin = prevwin;\n    tp->tp_firstwin = firstwin;\n    tp->tp_lastwin = lastwin;\n    tp->tp_old_Rows = Rows;\n    if (tp->tp_old_Columns != -1)\n\ttp->tp_old_Columns = Columns;\n    firstwin = NULL;\n    lastwin = NULL;\n    return OK;\n}\n\n/*\n * Start using tab page \"tp\".\n * Only to be used after leave_tabpage() or freeing the current tab page.\n * Only trigger *Enter autocommands when trigger_enter_autocmds is TRUE.\n * Only trigger *Leave autocommands when trigger_leave_autocmds is TRUE.\n */\n    static void\nenter_tabpage(\n    tabpage_T\t*tp,\n    buf_T\t*old_curbuf UNUSED,\n    int\t\ttrigger_enter_autocmds,\n    int\t\ttrigger_leave_autocmds)\n{\n    int\t\trow;\n    int\t\told_off = tp->tp_firstwin->w_winrow;\n    win_T\t*next_prevwin = tp->tp_prevwin;\n    tabpage_T\t*last_tab = curtab;\n\n    curtab = tp;\n    firstwin = tp->tp_firstwin;\n    lastwin = tp->tp_lastwin;\n    topframe = tp->tp_topframe;\n\n    // We would like doing the TabEnter event first, but we don't have a\n    // valid current window yet, which may break some commands.\n    // This triggers autocommands, thus may make \"tp\" invalid.\n    (void)win_enter_ext(tp->tp_curwin, WEE_CURWIN_INVALID\n\t\t  | (trigger_enter_autocmds ? WEE_TRIGGER_ENTER_AUTOCMDS : 0)\n\t\t  | (trigger_leave_autocmds ? WEE_TRIGGER_LEAVE_AUTOCMDS : 0));\n    prevwin = next_prevwin;\n\n    last_status(FALSE);\t\t// status line may appear or disappear\n    row = win_comp_pos();\t// recompute w_winrow for all windows\n#ifdef FEAT_DIFF\n    diff_need_scrollbind = TRUE;\n#endif\n\n    // The tabpage line may have appeared or disappeared, may need to resize\n    // the frames for that.  When the Vim window was resized need to update\n    // frame sizes too.  Use the stored value of p_ch, so that it can be\n    // different for each tab page.\n    if (p_ch != curtab->tp_ch_used)\n\tclear_cmdline = TRUE;\n    p_ch = curtab->tp_ch_used;\n\n    // When cmdheight is changed in a tab page with '<C-w>-', cmdline_row is\n    // changed but p_ch and tp_ch_used are not changed. Thus we also need to\n    // check cmdline_row.\n    if ((row < cmdline_row) && (cmdline_row <= Rows - p_ch))\n\tclear_cmdline = TRUE;\n\n    if (curtab->tp_old_Rows != Rows || (old_off != firstwin->w_winrow\n#ifdef FEAT_GUI_TABLINE\n\t\t\t    && !gui_use_tabline()\n#endif\n\t\t))\n\tshell_new_rows();\n    if (curtab->tp_old_Columns != Columns)\n    {\n\tif (starting == 0)\n\t{\n\t    shell_new_columns();\t// update window widths\n\t    curtab->tp_old_Columns = Columns;\n\t}\n\telse\n\t    curtab->tp_old_Columns = -1;  // update window widths later\n    }\n\n    lastused_tabpage = last_tab;\n\n#if defined(FEAT_GUI)\n    // When 'guioptions' includes 'L' or 'R' may have to remove or add\n    // scrollbars.  Have to update them anyway.\n    gui_may_update_scrollbars();\n#endif\n\n    // Apply autocommands after updating the display, when 'rows' and\n    // 'columns' have been set correctly.\n    if (trigger_enter_autocmds)\n    {\n\tapply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);\n\tif (old_curbuf != curbuf)\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * Go to tab page \"n\".  For \":tab N\" and \"Ngt\".\n * When \"n\" is 9999 go to the last tab page.\n */\n    void\ngoto_tabpage(int n)\n{\n    tabpage_T\t*tp = NULL;  // shut up compiler\n    tabpage_T\t*ttp;\n    int\t\ti;\n\n    if (text_locked())\n    {\n\t// Not allowed when editing the command line.\n\ttext_locked_msg();\n\treturn;\n    }\n\n    // If there is only one it can't work.\n    if (first_tabpage->tp_next == NULL)\n    {\n\tif (n > 1)\n\t    beep_flush();\n\treturn;\n    }\n\n    if (n == 0)\n    {\n\t// No count, go to next tab page, wrap around end.\n\tif (curtab->tp_next == NULL)\n\t    tp = first_tabpage;\n\telse\n\t    tp = curtab->tp_next;\n    }\n    else if (n < 0)\n    {\n\t// \"gT\": go to previous tab page, wrap around end.  \"N gT\" repeats\n\t// this N times.\n\tttp = curtab;\n\tfor (i = n; i < 0; ++i)\n\t{\n\t    for (tp = first_tabpage; tp->tp_next != ttp && tp->tp_next != NULL;\n\t\t    tp = tp->tp_next)\n\t\t;\n\t    ttp = tp;\n\t}\n    }\n    else if (n == 9999)\n    {\n\t// Go to last tab page.\n\tfor (tp = first_tabpage; tp->tp_next != NULL; tp = tp->tp_next)\n\t    ;\n    }\n    else\n    {\n\t// Go to tab page \"n\".\n\ttp = find_tabpage(n);\n\tif (tp == NULL)\n\t{\n\t    beep_flush();\n\t    return;\n\t}\n    }\n\n    goto_tabpage_tp(tp, TRUE, TRUE);\n\n#ifdef FEAT_GUI_TABLINE\n    if (gui_use_tabline())\n\tgui_mch_set_curtab(tabpage_index(curtab));\n#endif\n}\n\n/*\n * Go to tabpage \"tp\".\n * Only trigger *Enter autocommands when trigger_enter_autocmds is TRUE.\n * Only trigger *Leave autocommands when trigger_leave_autocmds is TRUE.\n * Note: doesn't update the GUI tab.\n */\n    void\ngoto_tabpage_tp(\n    tabpage_T\t*tp,\n    int\t\ttrigger_enter_autocmds,\n    int\t\ttrigger_leave_autocmds)\n{\n    if (trigger_enter_autocmds || trigger_leave_autocmds)\n\tCHECK_CMDWIN;\n\n    // Don't repeat a message in another tab page.\n    set_keep_msg(NULL, 0);\n\n    if (tp != curtab && leave_tabpage(tp->tp_curwin->w_buffer,\n\t\t\t\t\ttrigger_leave_autocmds) == OK)\n    {\n\tif (valid_tabpage(tp))\n\t    enter_tabpage(tp, curbuf, trigger_enter_autocmds,\n\t\t    trigger_leave_autocmds);\n\telse\n\t    enter_tabpage(curtab, curbuf, trigger_enter_autocmds,\n\t\t    trigger_leave_autocmds);\n    }\n}\n\n/*\n * Go to the last accessed tab page, if there is one.\n * Return OK or FAIL\n */\n    int\ngoto_tabpage_lastused(void)\n{\n    if (valid_tabpage(lastused_tabpage))\n    {\n\tgoto_tabpage_tp(lastused_tabpage, TRUE, TRUE);\n\treturn OK;\n    }\n    return FAIL;\n}\n\n/*\n * Enter window \"wp\" in tab page \"tp\".\n * Also updates the GUI tab.\n */\n    void\ngoto_tabpage_win(tabpage_T *tp, win_T *wp)\n{\n    goto_tabpage_tp(tp, TRUE, TRUE);\n    if (curtab == tp && win_valid(wp))\n    {\n\twin_enter(wp, TRUE);\n# ifdef FEAT_GUI_TABLINE\n\tif (gui_use_tabline())\n\t    gui_mch_set_curtab(tabpage_index(curtab));\n# endif\n    }\n}\n\n/*\n * Move the current tab page to after tab page \"nr\".\n */\n    void\ntabpage_move(int nr)\n{\n    int\t\tn = 1;\n    tabpage_T\t*tp, *tp_dst;\n\n    if (first_tabpage->tp_next == NULL)\n\treturn;\n\n    for (tp = first_tabpage; tp->tp_next != NULL && n < nr; tp = tp->tp_next)\n\t++n;\n\n    if (tp == curtab || (nr > 0 && tp->tp_next != NULL\n\t\t\t\t\t\t    && tp->tp_next == curtab))\n\treturn;\n\n    tp_dst = tp;\n\n    // Remove the current tab page from the list of tab pages.\n    if (curtab == first_tabpage)\n\tfirst_tabpage = curtab->tp_next;\n    else\n    {\n\tFOR_ALL_TABPAGES(tp)\n\t    if (tp->tp_next == curtab)\n\t\tbreak;\n\tif (tp == NULL)\t// \"cannot happen\"\n\t    return;\n\ttp->tp_next = curtab->tp_next;\n    }\n\n    // Re-insert it at the specified position.\n    if (nr <= 0)\n    {\n\tcurtab->tp_next = first_tabpage;\n\tfirst_tabpage = curtab;\n    }\n    else\n    {\n\tcurtab->tp_next = tp_dst->tp_next;\n\ttp_dst->tp_next = curtab;\n    }\n\n    // Need to redraw the tabline.  Tab page contents doesn't change.\n    redraw_tabline = TRUE;\n}\n\n\n/*\n * Go to another window.\n * When jumping to another buffer, stop Visual mode.  Do this before\n * changing windows so we can yank the selection into the '*' register.\n * When jumping to another window on the same buffer, adjust its cursor\n * position to keep the same Visual area.\n */\n    void\nwin_goto(win_T *wp)\n{\n#ifdef FEAT_CONCEAL\n    win_T\t*owp = curwin;\n#endif\n\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n    if (popup_is_popup(wp))\n    {\n\temsg(_(e_not_allowed_to_enter_popup_window));\n\treturn;\n    }\n#endif\n    if (text_or_buf_locked())\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n    if (wp->w_buffer != curbuf)\n\treset_VIsual_and_resel();\n    else if (VIsual_active)\n\twp->w_cursor = curwin->w_cursor;\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n    win_enter(wp, TRUE);\n\n#ifdef FEAT_CONCEAL\n    // Conceal cursor line in previous window, unconceal in current window.\n    if (win_valid(owp) && owp->w_p_cole > 0 && !msg_scrolled)\n\tredrawWinline(owp, owp->w_cursor.lnum);\n    if (curwin->w_p_cole > 0 && !msg_scrolled)\n\tneed_cursor_line_redraw = TRUE;\n#endif\n}\n\n#if defined(FEAT_PERL) || defined(PROTO)\n/*\n * Find window number \"winnr\" (counting top to bottom).\n */\n    win_T *\nwin_find_nr(int winnr)\n{\n    win_T\t*wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (--winnr == 0)\n\t    break;\n    return wp;\n}\n#endif\n\n#if ((defined(FEAT_PYTHON) || defined(FEAT_PYTHON3))) || defined(PROTO)\n/*\n * Find the tabpage for window \"win\".\n */\n    tabpage_T *\nwin_find_tabpage(win_T *win)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\t    if (wp == win)\n\t\treturn tp;\n    return NULL;\n}\n#endif\n\n/*\n * Get the above or below neighbor window of the specified window.\n *   up - TRUE for the above neighbor\n *   count - nth neighbor window\n * Returns the specified window if the neighbor is not found.\n */\n    win_T *\nwin_vert_neighbor(tabpage_T *tp, win_T *wp, int up, long count)\n{\n    frame_T\t*fr;\n    frame_T\t*nfr;\n    frame_T\t*foundfr;\n\n#ifdef FEAT_PROP_POPUP\n    if (popup_is_popup(wp))\n\t// popups don't have neighbors.\n\treturn NULL;\n#endif\n    foundfr = wp->w_frame;\n    while (count--)\n    {\n\t/*\n\t * First go upwards in the tree of frames until we find a upwards or\n\t * downwards neighbor.\n\t */\n\tfr = foundfr;\n\tfor (;;)\n\t{\n\t    if (fr == tp->tp_topframe)\n\t\tgoto end;\n\t    if (up)\n\t\tnfr = fr->fr_prev;\n\t    else\n\t\tnfr = fr->fr_next;\n\t    if (fr->fr_parent->fr_layout == FR_COL && nfr != NULL)\n\t\tbreak;\n\t    fr = fr->fr_parent;\n\t}\n\n\t/*\n\t * Now go downwards to find the bottom or top frame in it.\n\t */\n\tfor (;;)\n\t{\n\t    if (nfr->fr_layout == FR_LEAF)\n\t    {\n\t\tfoundfr = nfr;\n\t\tbreak;\n\t    }\n\t    fr = nfr->fr_child;\n\t    if (nfr->fr_layout == FR_ROW)\n\t    {\n\t\t// Find the frame at the cursor row.\n\t\twhile (fr->fr_next != NULL\n\t\t\t&& frame2win(fr)->w_wincol + fr->fr_width\n\t\t\t\t\t <= wp->w_wincol + wp->w_wcol)\n\t\t    fr = fr->fr_next;\n\t    }\n\t    if (nfr->fr_layout == FR_COL && up)\n\t\twhile (fr->fr_next != NULL)\n\t\t    fr = fr->fr_next;\n\t    nfr = fr;\n\t}\n    }\nend:\n    return foundfr != NULL ? foundfr->fr_win : NULL;\n}\n\n/*\n * Move to window above or below \"count\" times.\n */\n    static void\nwin_goto_ver(\n    int\t\tup,\t\t// TRUE to go to win above\n    long\tcount)\n{\n    win_T\t*win;\n\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_TERM_POPUP_WINDOW)\n\treturn;\n#endif\n    win = win_vert_neighbor(curtab, curwin, up, count);\n    if (win != NULL)\n\twin_goto(win);\n}\n\n/*\n * Get the left or right neighbor window of the specified window.\n *   left - TRUE for the left neighbor\n *   count - nth neighbor window\n * Returns the specified window if the neighbor is not found.\n */\n    win_T *\nwin_horz_neighbor(tabpage_T *tp, win_T *wp, int left, long count)\n{\n    frame_T\t*fr;\n    frame_T\t*nfr;\n    frame_T\t*foundfr;\n\n#ifdef FEAT_PROP_POPUP\n    if (popup_is_popup(wp))\n\t// popups don't have neighbors.\n\treturn NULL;\n#endif\n    foundfr = wp->w_frame;\n    while (count--)\n    {\n\t/*\n\t * First go upwards in the tree of frames until we find a left or\n\t * right neighbor.\n\t */\n\tfr = foundfr;\n\tfor (;;)\n\t{\n\t    if (fr == tp->tp_topframe)\n\t\tgoto end;\n\t    if (left)\n\t\tnfr = fr->fr_prev;\n\t    else\n\t\tnfr = fr->fr_next;\n\t    if (fr->fr_parent->fr_layout == FR_ROW && nfr != NULL)\n\t\tbreak;\n\t    fr = fr->fr_parent;\n\t}\n\n\t/*\n\t * Now go downwards to find the leftmost or rightmost frame in it.\n\t */\n\tfor (;;)\n\t{\n\t    if (nfr->fr_layout == FR_LEAF)\n\t    {\n\t\tfoundfr = nfr;\n\t\tbreak;\n\t    }\n\t    fr = nfr->fr_child;\n\t    if (nfr->fr_layout == FR_COL)\n\t    {\n\t\t// Find the frame at the cursor row.\n\t\twhile (fr->fr_next != NULL\n\t\t\t&& frame2win(fr)->w_winrow + fr->fr_height\n\t\t\t\t\t <= wp->w_winrow + wp->w_wrow)\n\t\t    fr = fr->fr_next;\n\t    }\n\t    if (nfr->fr_layout == FR_ROW && left)\n\t\twhile (fr->fr_next != NULL)\n\t\t    fr = fr->fr_next;\n\t    nfr = fr;\n\t}\n    }\nend:\n    return foundfr != NULL ? foundfr->fr_win : NULL;\n}\n\n/*\n * Move to left or right window.\n */\n    static void\nwin_goto_hor(\n    int\t\tleft,\t\t// TRUE to go to left win\n    long\tcount)\n{\n    win_T\t*win;\n\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_TERM_POPUP_WINDOW)\n\treturn;\n#endif\n    win = win_horz_neighbor(curtab, curwin, left, count);\n    if (win != NULL)\n\twin_goto(win);\n}\n\n/*\n * Make window \"wp\" the current window.\n */\n    void\nwin_enter(win_T *wp, int undo_sync)\n{\n    (void)win_enter_ext(wp, (undo_sync ? WEE_UNDO_SYNC : 0)\n\t\t    | WEE_TRIGGER_ENTER_AUTOCMDS | WEE_TRIGGER_LEAVE_AUTOCMDS);\n}\n\n/*\n * Used after making another window the current one: change directory if\n * needed.\n */\n    static void\nfix_current_dir(void)\n{\n    if (curwin->w_localdir != NULL || curtab->tp_localdir != NULL)\n    {\n\tchar_u\t*dirname;\n\n\t// Window or tab has a local directory: Save current directory as\n\t// global directory (unless that was done already) and change to the\n\t// local directory.\n\tif (globaldir == NULL)\n\t{\n\t    char_u\tcwd[MAXPATHL];\n\n\t    if (mch_dirname(cwd, MAXPATHL) == OK)\n\t\tglobaldir = vim_strsave(cwd);\n\t}\n\tif (curwin->w_localdir != NULL)\n\t    dirname = curwin->w_localdir;\n\telse\n\t    dirname = curtab->tp_localdir;\n\n\tif (mch_chdir((char *)dirname) == 0)\n\t{\n\t    last_chdir_reason = NULL;\n\t    shorten_fnames(TRUE);\n\t}\n    }\n    else if (globaldir != NULL)\n    {\n\t// Window doesn't have a local directory and we are not in the global\n\t// directory: Change to the global directory.\n\tvim_ignored = mch_chdir((char *)globaldir);\n\tVIM_CLEAR(globaldir);\n\tlast_chdir_reason = NULL;\n\tshorten_fnames(TRUE);\n    }\n}\n\n/*\n * Make window \"wp\" the current window.\n * Can be called with \"flags\" containing WEE_CURWIN_INVALID, which means that\n * curwin has just been closed and isn't valid.\n * Returns TRUE when dont_parse_messages was decremented.\n */\n    static int\nwin_enter_ext(win_T *wp, int flags)\n{\n    int\t\tother_buffer = FALSE;\n    int\t\tcurwin_invalid = (flags & WEE_CURWIN_INVALID);\n    int\t\tdid_decrement = FALSE;\n\n    if (wp == curwin && !curwin_invalid)\t// nothing to do\n\treturn FALSE;\n\n#ifdef FEAT_JOB_CHANNEL\n    if (!curwin_invalid)\n\tleaving_window(curwin);\n#endif\n\n    if (!curwin_invalid && (flags & WEE_TRIGGER_LEAVE_AUTOCMDS))\n    {\n\t/*\n\t * Be careful: If autocommands delete the window, return now.\n\t */\n\tif (wp->w_buffer != curbuf)\n\t{\n\t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n\t    other_buffer = TRUE;\n\t    if (!win_valid(wp))\n\t\treturn FALSE;\n\t}\n\tapply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (!win_valid(wp))\n\t    return FALSE;\n#ifdef FEAT_EVAL\n\t// autocmds may abort script processing\n\tif (aborting())\n\t    return FALSE;\n#endif\n    }\n\n    // sync undo before leaving the current buffer\n    if ((flags & WEE_UNDO_SYNC) && curbuf != wp->w_buffer)\n\tu_sync(FALSE);\n\n    // Might need to scroll the old window before switching, e.g., when the\n    // cursor was moved.\n    update_topline();\n\n    // may have to copy the buffer options when 'cpo' contains 'S'\n    if (wp->w_buffer != curbuf)\n\tbuf_copy_options(wp->w_buffer, BCO_ENTER | BCO_NOHELP);\n    if (!curwin_invalid)\n    {\n\tprevwin = curwin;\t// remember for CTRL-W p\n\tcurwin->w_redr_status = TRUE;\n    }\n    curwin = wp;\n    curbuf = wp->w_buffer;\n    check_cursor();\n    if (!virtual_active())\n\tcurwin->w_cursor.coladd = 0;\n    changed_line_abv_curs();\t// assume cursor position needs updating\n\n    // Now it is OK to parse messages again, which may be needed in\n    // autocommands.\n#ifdef MESSAGE_QUEUE\n    if (flags & WEE_ALLOW_PARSE_MESSAGES)\n    {\n\t--dont_parse_messages;\n\tdid_decrement = TRUE;\n    }\n#endif\n\n    fix_current_dir();\n\n#ifdef FEAT_JOB_CHANNEL\n    entering_window(curwin);\n#endif\n    // Careful: autocommands may close the window and make \"wp\" invalid\n    if (flags & WEE_TRIGGER_NEW_AUTOCMDS)\n\tapply_autocmds(EVENT_WINNEW, NULL, NULL, FALSE, curbuf);\n    if (flags & WEE_TRIGGER_ENTER_AUTOCMDS)\n    {\n\tapply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);\n\tif (other_buffer)\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n    maketitle();\n    curwin->w_redr_status = TRUE;\n#ifdef FEAT_TERMINAL\n    if (bt_terminal(curwin->w_buffer))\n\t// terminal is likely in another mode\n\tredraw_mode = TRUE;\n#endif\n    redraw_tabline = TRUE;\n    if (restart_edit)\n\tredraw_later(VALID);\t// causes status line redraw\n\n    // set window height to desired minimal value\n    if (curwin->w_height < p_wh && !curwin->w_p_wfh\n#ifdef FEAT_PROP_POPUP\n\t    && !popup_is_popup(curwin)\n#endif\n\t    )\n\twin_setheight((int)p_wh);\n    else if (curwin->w_height == 0)\n\twin_setheight(1);\n\n    // set window width to desired minimal value\n    if (curwin->w_width < p_wiw && !curwin->w_p_wfw)\n\twin_setwidth((int)p_wiw);\n\n    setmouse();\t\t\t// in case jumped to/from help buffer\n\n    // Change directories when the 'acd' option is set.\n    DO_AUTOCHDIR;\n\n    return did_decrement;\n}\n\n/*\n * Jump to the first open window that contains buffer \"buf\", if one exists.\n * Returns a pointer to the window found, otherwise NULL.\n */\n    win_T *\nbuf_jump_open_win(buf_T *buf)\n{\n    win_T\t*wp = NULL;\n\n    if (curwin->w_buffer == buf)\n\twp = curwin;\n    else\n\tFOR_ALL_WINDOWS(wp)\n\t    if (wp->w_buffer == buf)\n\t\tbreak;\n    if (wp != NULL)\n\twin_enter(wp, FALSE);\n    return wp;\n}\n\n/*\n * Jump to the first open window in any tab page that contains buffer \"buf\",\n * if one exists. First search in the windows present in the current tab page.\n * Returns a pointer to the window found, otherwise NULL.\n */\n    win_T *\nbuf_jump_open_tab(buf_T *buf)\n{\n    win_T\t*wp = buf_jump_open_win(buf);\n    tabpage_T\t*tp;\n\n    if (wp != NULL)\n\treturn wp;\n\n    FOR_ALL_TABPAGES(tp)\n\tif (tp != curtab)\n\t{\n\t    FOR_ALL_WINDOWS_IN_TAB(tp, wp)\n\t\tif (wp->w_buffer == buf)\n\t\t    break;\n\t    if (wp != NULL)\n\t    {\n\t\tgoto_tabpage_win(tp, wp);\n\t\tif (curwin != wp)\n\t\t    wp = NULL;\t// something went wrong\n\t\tbreak;\n\t    }\n\t}\n    return wp;\n}\n\nstatic int last_win_id = LOWEST_WIN_ID - 1;\n\n/*\n * Allocate a window structure and link it in the window list when \"hidden\" is\n * FALSE.\n */\n    static win_T *\nwin_alloc(win_T *after UNUSED, int hidden UNUSED)\n{\n    win_T\t*new_wp;\n\n    /*\n     * allocate window structure and linesizes arrays\n     */\n    new_wp = ALLOC_CLEAR_ONE(win_T);\n    if (new_wp == NULL)\n\treturn NULL;\n\n    if (win_alloc_lines(new_wp) == FAIL)\n    {\n\tvim_free(new_wp);\n\treturn NULL;\n    }\n\n    new_wp->w_id = ++last_win_id;\n\n#ifdef FEAT_EVAL\n    // init w: variables\n    new_wp->w_vars = dict_alloc_id(aid_newwin_wvars);\n    if (new_wp->w_vars == NULL)\n    {\n\twin_free_lsize(new_wp);\n\tvim_free(new_wp);\n\treturn NULL;\n    }\n    init_var_dict(new_wp->w_vars, &new_wp->w_winvar, VAR_SCOPE);\n#endif\n\n    // Don't execute autocommands while the window is not properly\n    // initialized yet.  gui_create_scrollbar() may trigger a FocusGained\n    // event.\n    block_autocmds();\n\n    /*\n     * link the window in the window list\n     */\n    if (!hidden)\n\twin_append(after, new_wp);\n    new_wp->w_wincol = 0;\n    new_wp->w_width = Columns;\n\n    // position the display and the cursor at the top of the file.\n    new_wp->w_topline = 1;\n#ifdef FEAT_DIFF\n    new_wp->w_topfill = 0;\n#endif\n    new_wp->w_botline = 2;\n    new_wp->w_cursor.lnum = 1;\n    new_wp->w_scbind_pos = 1;\n\n    // use global option value for global-local options\n    new_wp->w_p_so = -1;\n    new_wp->w_p_siso = -1;\n\n    // We won't calculate w_fraction until resizing the window\n    new_wp->w_fraction = 0;\n    new_wp->w_prev_fraction_row = -1;\n\n#ifdef FEAT_GUI\n    if (gui.in_use)\n    {\n\tgui_create_scrollbar(&new_wp->w_scrollbars[SBAR_LEFT],\n\t\tSBAR_LEFT, new_wp);\n\tgui_create_scrollbar(&new_wp->w_scrollbars[SBAR_RIGHT],\n\t\tSBAR_RIGHT, new_wp);\n    }\n#endif\n#ifdef FEAT_FOLDING\n    foldInitWin(new_wp);\n#endif\n    unblock_autocmds();\n#ifdef FEAT_SEARCH_EXTRA\n    new_wp->w_match_head = NULL;\n    new_wp->w_next_match_id = 4;\n#endif\n    return new_wp;\n}\n\n/*\n * Remove window 'wp' from the window list and free the structure.\n */\n    static void\nwin_free(\n    win_T\t*wp,\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    int\t\ti;\n    buf_T\t*buf;\n    wininfo_T\t*wip;\n\n#ifdef FEAT_FOLDING\n    clearFolding(wp);\n#endif\n\n    // reduce the reference count to the argument list.\n    alist_unlink(wp->w_alist);\n\n    // Don't execute autocommands while the window is halfway being deleted.\n    // gui_mch_destroy_scrollbar() may trigger a FocusGained event.\n    block_autocmds();\n\n#ifdef FEAT_LUA\n    lua_window_free(wp);\n#endif\n\n#ifdef FEAT_MZSCHEME\n    mzscheme_window_free(wp);\n#endif\n\n#ifdef FEAT_PERL\n    perl_win_free(wp);\n#endif\n\n#ifdef FEAT_PYTHON\n    python_window_free(wp);\n#endif\n\n#ifdef FEAT_PYTHON3\n    python3_window_free(wp);\n#endif\n\n#ifdef FEAT_TCL\n    tcl_window_free(wp);\n#endif\n\n#ifdef FEAT_RUBY\n    ruby_window_free(wp);\n#endif\n\n    clear_winopt(&wp->w_onebuf_opt);\n    clear_winopt(&wp->w_allbuf_opt);\n\n    vim_free(wp->w_lcs_chars.multispace);\n    vim_free(wp->w_lcs_chars.leadmultispace);\n\n#ifdef FEAT_EVAL\n    vars_clear(&wp->w_vars->dv_hashtab);\t// free all w: variables\n    hash_init(&wp->w_vars->dv_hashtab);\n    unref_var_dict(wp->w_vars);\n#endif\n\n    {\n\ttabpage_T\t*ttp;\n\n\tif (prevwin == wp)\n\t    prevwin = NULL;\n\tFOR_ALL_TABPAGES(ttp)\n\t    if (ttp->tp_prevwin == wp)\n\t\tttp->tp_prevwin = NULL;\n    }\n    win_free_lsize(wp);\n\n    for (i = 0; i < wp->w_tagstacklen; ++i)\n    {\n\tvim_free(wp->w_tagstack[i].tagname);\n\tvim_free(wp->w_tagstack[i].user_data);\n    }\n    vim_free(wp->w_localdir);\n    vim_free(wp->w_prevdir);\n\n    // Remove the window from the b_wininfo lists, it may happen that the\n    // freed memory is re-used for another window.\n    FOR_ALL_BUFFERS(buf)\n\tFOR_ALL_BUF_WININFO(buf, wip)\n\t    if (wip->wi_win == wp)\n\t    {\n\t\twininfo_T\t*wip2;\n\n\t\t// If there already is an entry with \"wi_win\" set to NULL it\n\t\t// must be removed, it would never be used.\n\t\t// Skip \"wip\" itself, otherwise Coverity complains.\n\t\tfor (wip2 = buf->b_wininfo; wip2 != NULL; wip2 = wip2->wi_next)\n\t\t    if (wip2 != wip && wip2->wi_win == NULL)\n\t\t    {\n\t\t\tif (wip2->wi_next != NULL)\n\t\t\t    wip2->wi_next->wi_prev = wip2->wi_prev;\n\t\t\tif (wip2->wi_prev == NULL)\n\t\t\t    buf->b_wininfo = wip2->wi_next;\n\t\t\telse\n\t\t\t    wip2->wi_prev->wi_next = wip2->wi_next;\n\t\t\tfree_wininfo(wip2);\n\t\t\tbreak;\n\t\t    }\n\n\t\twip->wi_win = NULL;\n\t    }\n\n#ifdef FEAT_SEARCH_EXTRA\n    clear_matches(wp);\n#endif\n\n    free_jumplist(wp);\n\n#ifdef FEAT_QUICKFIX\n    qf_free_all(wp);\n#endif\n\n#ifdef FEAT_GUI\n    if (gui.in_use)\n    {\n\tgui_mch_destroy_scrollbar(&wp->w_scrollbars[SBAR_LEFT]);\n\tgui_mch_destroy_scrollbar(&wp->w_scrollbars[SBAR_RIGHT]);\n    }\n#endif // FEAT_GUI\n\n#ifdef FEAT_MENU\n    remove_winbar(wp);\n#endif\n#ifdef FEAT_PROP_POPUP\n    free_callback(&wp->w_close_cb);\n    free_callback(&wp->w_filter_cb);\n    for (i = 0; i < 4; ++i)\n\tVIM_CLEAR(wp->w_border_highlight[i]);\n    vim_free(wp->w_scrollbar_highlight);\n    vim_free(wp->w_thumb_highlight);\n    vim_free(wp->w_popup_title);\n    list_unref(wp->w_popup_mask);\n    vim_free(wp->w_popup_mask_cells);\n#endif\n\n#ifdef FEAT_SYN_HL\n    vim_free(wp->w_p_cc_cols);\n#endif\n\n    if (win_valid_any_tab(wp))\n\twin_remove(wp, tp);\n    if (autocmd_busy)\n    {\n\twp->w_next = au_pending_free_win;\n\tau_pending_free_win = wp;\n    }\n    else\n\tvim_free(wp);\n\n    unblock_autocmds();\n}\n\n/*\n * Return TRUE if \"wp\" is not in the list of windows: the autocmd window or a\n * popup window.\n */\n    int\nwin_unlisted(win_T *wp)\n{\n    return wp == aucmd_win || WIN_IS_POPUP(wp);\n}\n\n#if defined(FEAT_PROP_POPUP) || defined(PROTO)\n/*\n * Free a popup window.  This does not take the window out of the window list\n * and assumes there is only one toplevel frame, no split.\n */\n    void\nwin_free_popup(win_T *win)\n{\n    if (win->w_buffer != NULL)\n    {\n\tif (bt_popup(win->w_buffer))\n\t    win_close_buffer(win, DOBUF_WIPE_REUSE, FALSE);\n\telse\n\t    close_buffer(win, win->w_buffer, 0, FALSE, FALSE);\n    }\n# if defined(FEAT_TIMERS)\n    if (win->w_popup_timer != NULL)\n\tstop_timer(win->w_popup_timer);\n# endif\n    vim_free(win->w_frame);\n    win_free(win, NULL);\n}\n#endif\n\n/*\n * Append window \"wp\" in the window list after window \"after\".\n */\n    static void\nwin_append(win_T *after, win_T *wp)\n{\n    win_T\t*before;\n\n    if (after == NULL)\t    // after NULL is in front of the first\n\tbefore = firstwin;\n    else\n\tbefore = after->w_next;\n\n    wp->w_next = before;\n    wp->w_prev = after;\n    if (after == NULL)\n\tfirstwin = wp;\n    else\n\tafter->w_next = wp;\n    if (before == NULL)\n\tlastwin = wp;\n    else\n\tbefore->w_prev = wp;\n}\n\n/*\n * Remove a window from the window list.\n */\n    void\nwin_remove(\n    win_T\t*wp,\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    if (wp->w_prev != NULL)\n\twp->w_prev->w_next = wp->w_next;\n    else if (tp == NULL)\n\tfirstwin = curtab->tp_firstwin = wp->w_next;\n    else\n\ttp->tp_firstwin = wp->w_next;\n\n    if (wp->w_next != NULL)\n\twp->w_next->w_prev = wp->w_prev;\n    else if (tp == NULL)\n\tlastwin = curtab->tp_lastwin = wp->w_prev;\n    else\n\ttp->tp_lastwin = wp->w_prev;\n}\n\n/*\n * Append frame \"frp\" in a frame list after frame \"after\".\n */\n    static void\nframe_append(frame_T *after, frame_T *frp)\n{\n    frp->fr_next = after->fr_next;\n    after->fr_next = frp;\n    if (frp->fr_next != NULL)\n\tfrp->fr_next->fr_prev = frp;\n    frp->fr_prev = after;\n}\n\n/*\n * Insert frame \"frp\" in a frame list before frame \"before\".\n */\n    static void\nframe_insert(frame_T *before, frame_T *frp)\n{\n    frp->fr_next = before;\n    frp->fr_prev = before->fr_prev;\n    before->fr_prev = frp;\n    if (frp->fr_prev != NULL)\n\tfrp->fr_prev->fr_next = frp;\n    else\n\tfrp->fr_parent->fr_child = frp;\n}\n\n/*\n * Remove a frame from a frame list.\n */\n    static void\nframe_remove(frame_T *frp)\n{\n    if (frp->fr_prev != NULL)\n\tfrp->fr_prev->fr_next = frp->fr_next;\n    else\n\tfrp->fr_parent->fr_child = frp->fr_next;\n    if (frp->fr_next != NULL)\n\tfrp->fr_next->fr_prev = frp->fr_prev;\n}\n\n/*\n * Allocate w_lines[] for window \"wp\".\n * Return FAIL for failure, OK for success.\n */\n    int\nwin_alloc_lines(win_T *wp)\n{\n    wp->w_lines_valid = 0;\n    wp->w_lines = ALLOC_CLEAR_MULT(wline_T, Rows);\n    if (wp->w_lines == NULL)\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * free lsize arrays for a window\n */\n    void\nwin_free_lsize(win_T *wp)\n{\n    // TODO: why would wp be NULL here?\n    if (wp != NULL)\n\tVIM_CLEAR(wp->w_lines);\n}\n\n/*\n * Called from win_new_shellsize() after Rows changed.\n * This only does the current tab page, others must be done when made active.\n */\n    void\nshell_new_rows(void)\n{\n    int\t\th = (int)ROWS_AVAIL;\n\n    if (firstwin == NULL)\t// not initialized yet\n\treturn;\n    if (h < frame_minheight(topframe, NULL))\n\th = frame_minheight(topframe, NULL);\n\n    // First try setting the heights of windows with 'winfixheight'.  If\n    // that doesn't result in the right height, forget about that option.\n    frame_new_height(topframe, h, FALSE, TRUE);\n    if (!frame_check_height(topframe, h))\n\tframe_new_height(topframe, h, FALSE, FALSE);\n\n    (void)win_comp_pos();\t\t// recompute w_winrow and w_wincol\n    compute_cmdrow();\n    curtab->tp_ch_used = p_ch;\n\n#if 0\n    // Disabled: don't want making the screen smaller make a window larger.\n    if (p_ea)\n\twin_equal(curwin, FALSE, 'v');\n#endif\n}\n\n/*\n * Called from win_new_shellsize() after Columns changed.\n */\n    void\nshell_new_columns(void)\n{\n    if (firstwin == NULL)\t// not initialized yet\n\treturn;\n\n    // First try setting the widths of windows with 'winfixwidth'.  If that\n    // doesn't result in the right width, forget about that option.\n    frame_new_width(topframe, (int)Columns, FALSE, TRUE);\n    if (!frame_check_width(topframe, Columns))\n\tframe_new_width(topframe, (int)Columns, FALSE, FALSE);\n\n    (void)win_comp_pos();\t\t// recompute w_winrow and w_wincol\n#if 0\n    // Disabled: don't want making the screen smaller make a window larger.\n    if (p_ea)\n\twin_equal(curwin, FALSE, 'h');\n#endif\n}\n\n#if defined(FEAT_CMDWIN) || defined(PROTO)\n/*\n * Save the size of all windows in \"gap\".\n */\n    void\nwin_size_save(garray_T *gap)\n\n{\n    win_T\t*wp;\n\n    ga_init2(gap, sizeof(int), 1);\n    if (ga_grow(gap, win_count() * 2 + 1) == OK)\n    {\n\t// first entry is value of 'lines'\n\t((int *)gap->ga_data)[gap->ga_len++] = Rows;\n\n\tFOR_ALL_WINDOWS(wp)\n\t{\n\t    ((int *)gap->ga_data)[gap->ga_len++] =\n\t\t\t\t\t       wp->w_width + wp->w_vsep_width;\n\t    ((int *)gap->ga_data)[gap->ga_len++] = wp->w_height;\n\t}\n    }\n}\n\n/*\n * Restore window sizes, but only if the number of windows is still the same\n * and 'lines' didn't change.\n * Does not free the growarray.\n */\n    void\nwin_size_restore(garray_T *gap)\n{\n    win_T\t*wp;\n    int\t\ti, j;\n\n    if (win_count() * 2 + 1 == gap->ga_len\n\t    && ((int *)gap->ga_data)[0] == Rows)\n    {\n\t// The order matters, because frames contain other frames, but it's\n\t// difficult to get right. The easy way out is to do it twice.\n\tfor (j = 0; j < 2; ++j)\n\t{\n\t    i = 1;\n\t    FOR_ALL_WINDOWS(wp)\n\t    {\n\t\tframe_setwidth(wp->w_frame, ((int *)gap->ga_data)[i++]);\n\t\twin_setheight_win(((int *)gap->ga_data)[i++], wp);\n\t    }\n\t}\n\t// recompute the window positions\n\t(void)win_comp_pos();\n    }\n}\n#endif // FEAT_CMDWIN\n\n/*\n * Update the position for all windows, using the width and height of the\n * frames.\n * Returns the row just after the last window.\n */\n    int\nwin_comp_pos(void)\n{\n    int\t\trow = tabline_height();\n    int\t\tcol = 0;\n\n    frame_comp_pos(topframe, &row, &col);\n    return row;\n}\n\n/*\n * Update the position of the windows in frame \"topfrp\", using the width and\n * height of the frames.\n * \"*row\" and \"*col\" are the top-left position of the frame.  They are updated\n * to the bottom-right position plus one.\n */\n    static void\nframe_comp_pos(frame_T *topfrp, int *row, int *col)\n{\n    win_T\t*wp;\n    frame_T\t*frp;\n    int\t\tstartcol;\n    int\t\tstartrow;\n    int\t\th;\n\n    wp = topfrp->fr_win;\n    if (wp != NULL)\n    {\n\tif (wp->w_winrow != *row || wp->w_wincol != *col)\n\t{\n\t    // position changed, redraw\n\t    wp->w_winrow = *row;\n\t    wp->w_wincol = *col;\n\t    redraw_win_later(wp, NOT_VALID);\n\t    wp->w_redr_status = TRUE;\n\t}\n\t// WinBar will not show if the window height is zero\n\th = VISIBLE_HEIGHT(wp) + wp->w_status_height;\n\t*row += h > topfrp->fr_height ? topfrp->fr_height : h;\n\t*col += wp->w_width + wp->w_vsep_width;\n    }\n    else\n    {\n\tstartrow = *row;\n\tstartcol = *col;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t{\n\t    if (topfrp->fr_layout == FR_ROW)\n\t\t*row = startrow;\t// all frames are at the same row\n\t    else\n\t\t*col = startcol;\t// all frames are at the same col\n\t    frame_comp_pos(frp, row, col);\n\t}\n    }\n}\n\n/*\n * Make the current window show at least one line and one column.\n */\n    void\nwin_ensure_size()\n{\n    if (curwin->w_height == 0)\n\twin_setheight(1);\n    if (curwin->w_width == 0)\n\twin_setwidth(1);\n}\n\n/*\n * Set current window height and take care of repositioning other windows to\n * fit around it.\n */\n    void\nwin_setheight(int height)\n{\n    win_setheight_win(height, curwin);\n}\n\n/*\n * Set the window height of window \"win\" and take care of repositioning other\n * windows to fit around it.\n */\n    void\nwin_setheight_win(int height, win_T *win)\n{\n    int\t\trow;\n\n    if (win == curwin)\n    {\n\t// Always keep current window at least one line high, even when\n\t// 'winminheight' is zero.\n\tif (height < p_wmh)\n\t    height = p_wmh;\n\tif (height == 0)\n\t    height = 1;\n\theight += WINBAR_HEIGHT(curwin);\n    }\n\n    frame_setheight(win->w_frame, height + win->w_status_height);\n\n    // recompute the window positions\n    row = win_comp_pos();\n\n    /*\n     * If there is extra space created between the last window and the command\n     * line, clear it.\n     */\n    if (full_screen && msg_scrolled == 0 && row < cmdline_row)\n\tscreen_fill(row, cmdline_row, 0, (int)Columns, ' ', ' ', 0);\n    cmdline_row = row;\n    msg_row = row;\n    msg_col = 0;\n\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * Set the height of a frame to \"height\" and take care that all frames and\n * windows inside it are resized.  Also resize frames on the left and right if\n * the are in the same FR_ROW frame.\n *\n * Strategy:\n * If the frame is part of a FR_COL frame, try fitting the frame in that\n * frame.  If that doesn't work (the FR_COL frame is too small), recursively\n * go to containing frames to resize them and make room.\n * If the frame is part of a FR_ROW frame, all frames must be resized as well.\n * Check for the minimal height of the FR_ROW frame.\n * At the top level we can also use change the command line height.\n */\n    static void\nframe_setheight(frame_T *curfrp, int height)\n{\n    int\t\troom;\t\t// total number of lines available\n    int\t\ttake;\t\t// number of lines taken from other windows\n    int\t\troom_cmdline;\t// lines available from cmdline\n    int\t\trun;\n    frame_T\t*frp;\n    int\t\th;\n    int\t\troom_reserved;\n\n    // If the height already is the desired value, nothing to do.\n    if (curfrp->fr_height == height)\n\treturn;\n\n    if (curfrp->fr_parent == NULL)\n    {\n\t// topframe: can only change the command line\n\tif (height > ROWS_AVAIL)\n\t    height = ROWS_AVAIL;\n\tif (height > 0)\n\t    frame_new_height(curfrp, height, FALSE, FALSE);\n    }\n    else if (curfrp->fr_parent->fr_layout == FR_ROW)\n    {\n\t// Row of frames: Also need to resize frames left and right of this\n\t// one.  First check for the minimal height of these.\n\th = frame_minheight(curfrp->fr_parent, NULL);\n\tif (height < h)\n\t    height = h;\n\tframe_setheight(curfrp->fr_parent, height);\n    }\n    else\n    {\n\t/*\n\t * Column of frames: try to change only frames in this column.\n\t */\n\t/*\n\t * Do this twice:\n\t * 1: compute room available, if it's not enough try resizing the\n\t *    containing frame.\n\t * 2: compute the room available and adjust the height to it.\n\t * Try not to reduce the height of a window with 'winfixheight' set.\n\t */\n\tfor (run = 1; run <= 2; ++run)\n\t{\n\t    room = 0;\n\t    room_reserved = 0;\n\t    FOR_ALL_FRAMES(frp, curfrp->fr_parent->fr_child)\n\t    {\n\t\tif (frp != curfrp\n\t\t\t&& frp->fr_win != NULL\n\t\t\t&& frp->fr_win->w_p_wfh)\n\t\t    room_reserved += frp->fr_height;\n\t\troom += frp->fr_height;\n\t\tif (frp != curfrp)\n\t\t    room -= frame_minheight(frp, NULL);\n\t    }\n\t    if (curfrp->fr_width != Columns)\n\t\troom_cmdline = 0;\n\t    else\n\t    {\n\t\troom_cmdline = Rows - p_ch - (lastwin->w_winrow\n\t\t\t\t\t\t+ VISIBLE_HEIGHT(lastwin)\n\t\t\t\t\t\t+ lastwin->w_status_height);\n\t\tif (room_cmdline < 0)\n\t\t    room_cmdline = 0;\n\t    }\n\n\t    if (height <= room + room_cmdline)\n\t\tbreak;\n\t    if (run == 2 || curfrp->fr_width == Columns)\n\t    {\n\t\theight = room + room_cmdline;\n\t\tbreak;\n\t    }\n\t    frame_setheight(curfrp->fr_parent, height\n\t\t+ frame_minheight(curfrp->fr_parent, NOWIN) - (int)p_wmh - 1);\n\t}\n\n\t/*\n\t * Compute the number of lines we will take from others frames (can be\n\t * negative!).\n\t */\n\ttake = height - curfrp->fr_height;\n\n\t// If there is not enough room, also reduce the height of a window\n\t// with 'winfixheight' set.\n\tif (height > room + room_cmdline - room_reserved)\n\t    room_reserved = room + room_cmdline - height;\n\t// If there is only a 'winfixheight' window and making the\n\t// window smaller, need to make the other window taller.\n\tif (take < 0 && room - curfrp->fr_height < room_reserved)\n\t    room_reserved = 0;\n\n\tif (take > 0 && room_cmdline > 0)\n\t{\n\t    // use lines from cmdline first\n\t    if (take < room_cmdline)\n\t\troom_cmdline = take;\n\t    take -= room_cmdline;\n\t    topframe->fr_height += room_cmdline;\n\t}\n\n\t/*\n\t * set the current frame to the new height\n\t */\n\tframe_new_height(curfrp, height, FALSE, FALSE);\n\n\t/*\n\t * First take lines from the frames after the current frame.  If\n\t * that is not enough, takes lines from frames above the current\n\t * frame.\n\t */\n\tfor (run = 0; run < 2; ++run)\n\t{\n\t    if (run == 0)\n\t\tfrp = curfrp->fr_next;\t// 1st run: start with next window\n\t    else\n\t\tfrp = curfrp->fr_prev;\t// 2nd run: start with prev window\n\t    while (frp != NULL && take != 0)\n\t    {\n\t\th = frame_minheight(frp, NULL);\n\t\tif (room_reserved > 0\n\t\t\t&& frp->fr_win != NULL\n\t\t\t&& frp->fr_win->w_p_wfh)\n\t\t{\n\t\t    if (room_reserved >= frp->fr_height)\n\t\t\troom_reserved -= frp->fr_height;\n\t\t    else\n\t\t    {\n\t\t\tif (frp->fr_height - room_reserved > take)\n\t\t\t    room_reserved = frp->fr_height - take;\n\t\t\ttake -= frp->fr_height - room_reserved;\n\t\t\tframe_new_height(frp, room_reserved, FALSE, FALSE);\n\t\t\troom_reserved = 0;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (frp->fr_height - take < h)\n\t\t    {\n\t\t\ttake -= frp->fr_height - h;\n\t\t\tframe_new_height(frp, h, FALSE, FALSE);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tframe_new_height(frp, frp->fr_height - take,\n\t\t\t\t\t\t\t\tFALSE, FALSE);\n\t\t\ttake = 0;\n\t\t    }\n\t\t}\n\t\tif (run == 0)\n\t\t    frp = frp->fr_next;\n\t\telse\n\t\t    frp = frp->fr_prev;\n\t    }\n\t}\n    }\n}\n\n/*\n * Set current window width and take care of repositioning other windows to\n * fit around it.\n */\n    void\nwin_setwidth(int width)\n{\n    win_setwidth_win(width, curwin);\n}\n\n    void\nwin_setwidth_win(int width, win_T *wp)\n{\n    // Always keep current window at least one column wide, even when\n    // 'winminwidth' is zero.\n    if (wp == curwin)\n    {\n\tif (width < p_wmw)\n\t    width = p_wmw;\n\tif (width == 0)\n\t    width = 1;\n    }\n    else if (width < 0)\n\twidth = 0;\n\n    frame_setwidth(wp->w_frame, width + wp->w_vsep_width);\n\n    // recompute the window positions\n    (void)win_comp_pos();\n\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * Set the width of a frame to \"width\" and take care that all frames and\n * windows inside it are resized.  Also resize frames above and below if the\n * are in the same FR_ROW frame.\n *\n * Strategy is similar to frame_setheight().\n */\n    static void\nframe_setwidth(frame_T *curfrp, int width)\n{\n    int\t\troom;\t\t// total number of lines available\n    int\t\ttake;\t\t// number of lines taken from other windows\n    int\t\trun;\n    frame_T\t*frp;\n    int\t\tw;\n    int\t\troom_reserved;\n\n    // If the width already is the desired value, nothing to do.\n    if (curfrp->fr_width == width)\n\treturn;\n\n    if (curfrp->fr_parent == NULL)\n\t// topframe: can't change width\n\treturn;\n\n    if (curfrp->fr_parent->fr_layout == FR_COL)\n    {\n\t// Column of frames: Also need to resize frames above and below of\n\t// this one.  First check for the minimal width of these.\n\tw = frame_minwidth(curfrp->fr_parent, NULL);\n\tif (width < w)\n\t    width = w;\n\tframe_setwidth(curfrp->fr_parent, width);\n    }\n    else\n    {\n\t/*\n\t * Row of frames: try to change only frames in this row.\n\t *\n\t * Do this twice:\n\t * 1: compute room available, if it's not enough try resizing the\n\t *    containing frame.\n\t * 2: compute the room available and adjust the width to it.\n\t */\n\tfor (run = 1; run <= 2; ++run)\n\t{\n\t    room = 0;\n\t    room_reserved = 0;\n\t    FOR_ALL_FRAMES(frp, curfrp->fr_parent->fr_child)\n\t    {\n\t\tif (frp != curfrp\n\t\t\t&& frp->fr_win != NULL\n\t\t\t&& frp->fr_win->w_p_wfw)\n\t\t    room_reserved += frp->fr_width;\n\t\troom += frp->fr_width;\n\t\tif (frp != curfrp)\n\t\t    room -= frame_minwidth(frp, NULL);\n\t    }\n\n\t    if (width <= room)\n\t\tbreak;\n\t    if (run == 2 || curfrp->fr_height >= ROWS_AVAIL)\n\t    {\n\t\twidth = room;\n\t\tbreak;\n\t    }\n\t    frame_setwidth(curfrp->fr_parent, width\n\t\t + frame_minwidth(curfrp->fr_parent, NOWIN) - (int)p_wmw - 1);\n\t}\n\n\t/*\n\t * Compute the number of lines we will take from others frames (can be\n\t * negative!).\n\t */\n\ttake = width - curfrp->fr_width;\n\n\t// If there is not enough room, also reduce the width of a window\n\t// with 'winfixwidth' set.\n\tif (width > room - room_reserved)\n\t    room_reserved = room - width;\n\t// If there is only a 'winfixwidth' window and making the\n\t// window smaller, need to make the other window narrower.\n\tif (take < 0 && room - curfrp->fr_width < room_reserved)\n\t    room_reserved = 0;\n\n\t/*\n\t * set the current frame to the new width\n\t */\n\tframe_new_width(curfrp, width, FALSE, FALSE);\n\n\t/*\n\t * First take lines from the frames right of the current frame.  If\n\t * that is not enough, takes lines from frames left of the current\n\t * frame.\n\t */\n\tfor (run = 0; run < 2; ++run)\n\t{\n\t    if (run == 0)\n\t\tfrp = curfrp->fr_next;\t// 1st run: start with next window\n\t    else\n\t\tfrp = curfrp->fr_prev;\t// 2nd run: start with prev window\n\t    while (frp != NULL && take != 0)\n\t    {\n\t\tw = frame_minwidth(frp, NULL);\n\t\tif (room_reserved > 0\n\t\t\t&& frp->fr_win != NULL\n\t\t\t&& frp->fr_win->w_p_wfw)\n\t\t{\n\t\t    if (room_reserved >= frp->fr_width)\n\t\t\troom_reserved -= frp->fr_width;\n\t\t    else\n\t\t    {\n\t\t\tif (frp->fr_width - room_reserved > take)\n\t\t\t    room_reserved = frp->fr_width - take;\n\t\t\ttake -= frp->fr_width - room_reserved;\n\t\t\tframe_new_width(frp, room_reserved, FALSE, FALSE);\n\t\t\troom_reserved = 0;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (frp->fr_width - take < w)\n\t\t    {\n\t\t\ttake -= frp->fr_width - w;\n\t\t\tframe_new_width(frp, w, FALSE, FALSE);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tframe_new_width(frp, frp->fr_width - take,\n\t\t\t\t\t\t\t\tFALSE, FALSE);\n\t\t\ttake = 0;\n\t\t    }\n\t\t}\n\t\tif (run == 0)\n\t\t    frp = frp->fr_next;\n\t\telse\n\t\t    frp = frp->fr_prev;\n\t    }\n\t}\n    }\n}\n\n/*\n * Check 'winminheight' for a valid value and reduce it if needed.\n */\n    void\nwin_setminheight(void)\n{\n    int\t\troom;\n    int\t\tneeded;\n    int\t\tfirst = TRUE;\n\n    // loop until there is a 'winminheight' that is possible\n    while (p_wmh > 0)\n    {\n\troom = Rows - p_ch;\n\tneeded = min_rows() - 1;  // 1 was added for the cmdline\n\tif (room >= needed)\n\t    break;\n\t--p_wmh;\n\tif (first)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    first = FALSE;\n\t}\n    }\n}\n\n/*\n * Check 'winminwidth' for a valid value and reduce it if needed.\n */\n    void\nwin_setminwidth(void)\n{\n    int\t\troom;\n    int\t\tneeded;\n    int\t\tfirst = TRUE;\n\n    // loop until there is a 'winminheight' that is possible\n    while (p_wmw > 0)\n    {\n\troom = Columns;\n\tneeded = frame_minwidth(topframe, NULL);\n\tif (room >= needed)\n\t    break;\n\t--p_wmw;\n\tif (first)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    first = FALSE;\n\t}\n    }\n}\n\n/*\n * Status line of dragwin is dragged \"offset\" lines down (negative is up).\n */\n    void\nwin_drag_status_line(win_T *dragwin, int offset)\n{\n    frame_T\t*curfr;\n    frame_T\t*fr;\n    int\t\troom;\n    int\t\trow;\n    int\t\tup;\t// if TRUE, drag status line up, otherwise down\n    int\t\tn;\n\n    fr = dragwin->w_frame;\n    curfr = fr;\n    if (fr != topframe)\t\t// more than one window\n    {\n\tfr = fr->fr_parent;\n\t// When the parent frame is not a column of frames, its parent should\n\t// be.\n\tif (fr->fr_layout != FR_COL)\n\t{\n\t    curfr = fr;\n\t    if (fr != topframe)\t// only a row of windows, may drag statusline\n\t\tfr = fr->fr_parent;\n\t}\n    }\n\n    // If this is the last frame in a column, may want to resize the parent\n    // frame instead (go two up to skip a row of frames).\n    while (curfr != topframe && curfr->fr_next == NULL)\n    {\n\tif (fr != topframe)\n\t    fr = fr->fr_parent;\n\tcurfr = fr;\n\tif (fr != topframe)\n\t    fr = fr->fr_parent;\n    }\n\n    if (offset < 0) // drag up\n    {\n\tup = TRUE;\n\toffset = -offset;\n\t// sum up the room of the current frame and above it\n\tif (fr == curfr)\n\t{\n\t    // only one window\n\t    room = fr->fr_height - frame_minheight(fr, NULL);\n\t}\n\telse\n\t{\n\t    room = 0;\n\t    for (fr = fr->fr_child; ; fr = fr->fr_next)\n\t    {\n\t\troom += fr->fr_height - frame_minheight(fr, NULL);\n\t\tif (fr == curfr)\n\t\t    break;\n\t    }\n\t}\n\tfr = curfr->fr_next;\t\t// put fr at frame that grows\n    }\n    else    // drag down\n    {\n\tup = FALSE;\n\t/*\n\t * Only dragging the last status line can reduce p_ch.\n\t */\n\troom = Rows - cmdline_row;\n\tif (curfr->fr_next == NULL)\n\t    room -= 1;\n\telse\n\t    room -= p_ch;\n\tif (room < 0)\n\t    room = 0;\n\t// sum up the room of frames below of the current one\n\tFOR_ALL_FRAMES(fr, curfr->fr_next)\n\t    room += fr->fr_height - frame_minheight(fr, NULL);\n\tfr = curfr;\t\t\t// put fr at window that grows\n    }\n\n    if (room < offset)\t\t// Not enough room\n\toffset = room;\t\t// Move as far as we can\n    if (offset <= 0)\n\treturn;\n\n    /*\n     * Grow frame fr by \"offset\" lines.\n     * Doesn't happen when dragging the last status line up.\n     */\n    if (fr != NULL)\n\tframe_new_height(fr, fr->fr_height + offset, up, FALSE);\n\n    if (up)\n\tfr = curfr;\t\t// current frame gets smaller\n    else\n\tfr = curfr->fr_next;\t// next frame gets smaller\n\n    /*\n     * Now make the other frames smaller.\n     */\n    while (fr != NULL && offset > 0)\n    {\n\tn = frame_minheight(fr, NULL);\n\tif (fr->fr_height - offset <= n)\n\t{\n\t    offset -= fr->fr_height - n;\n\t    frame_new_height(fr, n, !up, FALSE);\n\t}\n\telse\n\t{\n\t    frame_new_height(fr, fr->fr_height - offset, !up, FALSE);\n\t    break;\n\t}\n\tif (up)\n\t    fr = fr->fr_prev;\n\telse\n\t    fr = fr->fr_next;\n    }\n    row = win_comp_pos();\n    screen_fill(row, cmdline_row, 0, (int)Columns, ' ', ' ', 0);\n    cmdline_row = row;\n    p_ch = Rows - cmdline_row;\n    if (p_ch < 1)\n\tp_ch = 1;\n    curtab->tp_ch_used = p_ch;\n    redraw_all_later(SOME_VALID);\n    showmode();\n}\n\n/*\n * Separator line of dragwin is dragged \"offset\" lines right (negative is left).\n */\n    void\nwin_drag_vsep_line(win_T *dragwin, int offset)\n{\n    frame_T\t*curfr;\n    frame_T\t*fr;\n    int\t\troom;\n    int\t\tleft;\t// if TRUE, drag separator line left, otherwise right\n    int\t\tn;\n\n    fr = dragwin->w_frame;\n    if (fr == topframe)\t\t// only one window (cannot happen?)\n\treturn;\n    curfr = fr;\n    fr = fr->fr_parent;\n    // When the parent frame is not a row of frames, its parent should be.\n    if (fr->fr_layout != FR_ROW)\n    {\n\tif (fr == topframe)\t// only a column of windows (cannot happen?)\n\t    return;\n\tcurfr = fr;\n\tfr = fr->fr_parent;\n    }\n\n    // If this is the last frame in a row, may want to resize a parent\n    // frame instead.\n    while (curfr->fr_next == NULL)\n    {\n\tif (fr == topframe)\n\t    break;\n\tcurfr = fr;\n\tfr = fr->fr_parent;\n\tif (fr != topframe)\n\t{\n\t    curfr = fr;\n\t    fr = fr->fr_parent;\n\t}\n    }\n\n    if (offset < 0) // drag left\n    {\n\tleft = TRUE;\n\toffset = -offset;\n\t// sum up the room of the current frame and left of it\n\troom = 0;\n\tfor (fr = fr->fr_child; ; fr = fr->fr_next)\n\t{\n\t    room += fr->fr_width - frame_minwidth(fr, NULL);\n\t    if (fr == curfr)\n\t\tbreak;\n\t}\n\tfr = curfr->fr_next;\t\t// put fr at frame that grows\n    }\n    else    // drag right\n    {\n\tleft = FALSE;\n\t// sum up the room of frames right of the current one\n\troom = 0;\n\tFOR_ALL_FRAMES(fr, curfr->fr_next)\n\t    room += fr->fr_width - frame_minwidth(fr, NULL);\n\tfr = curfr;\t\t\t// put fr at window that grows\n    }\n\n    if (room < offset)\t\t// Not enough room\n\toffset = room;\t\t// Move as far as we can\n    if (offset <= 0)\t\t// No room at all, quit.\n\treturn;\n    if (fr == NULL)\n\t// This can happen when calling win_move_separator() on the rightmost\n\t// window.  Just don't do anything.\n\treturn;\t\t\t\n\n    // grow frame fr by offset lines\n    frame_new_width(fr, fr->fr_width + offset, left, FALSE);\n\n    // shrink other frames: current and at the left or at the right\n    if (left)\n\tfr = curfr;\t\t// current frame gets smaller\n    else\n\tfr = curfr->fr_next;\t// next frame gets smaller\n\n    while (fr != NULL && offset > 0)\n    {\n\tn = frame_minwidth(fr, NULL);\n\tif (fr->fr_width - offset <= n)\n\t{\n\t    offset -= fr->fr_width - n;\n\t    frame_new_width(fr, n, !left, FALSE);\n\t}\n\telse\n\t{\n\t    frame_new_width(fr, fr->fr_width - offset, !left, FALSE);\n\t    break;\n\t}\n\tif (left)\n\t    fr = fr->fr_prev;\n\telse\n\t    fr = fr->fr_next;\n    }\n    (void)win_comp_pos();\n    redraw_all_later(NOT_VALID);\n}\n\n#define FRACTION_MULT\t16384L\n\n/*\n * Set wp->w_fraction for the current w_wrow and w_height.\n * Has no effect when the window is less than two lines.\n */\n    void\nset_fraction(win_T *wp)\n{\n    if (wp->w_height > 1)\n\t// When cursor is in the first line the percentage is computed as if\n\t// it's halfway that line.  Thus with two lines it is 25%, with three\n\t// lines 17%, etc.  Similarly for the last line: 75%, 83%, etc.\n\twp->w_fraction = ((long)wp->w_wrow * FRACTION_MULT\n\t\t\t\t     + FRACTION_MULT / 2) / (long)wp->w_height;\n}\n\n/*\n * Set the height of a window.\n * \"height\" excludes any window toolbar.\n * This takes care of the things inside the window, not what happens to the\n * window position, the frame or to other windows.\n */\n    void\nwin_new_height(win_T *wp, int height)\n{\n    int\t\tprev_height = wp->w_height;\n\n    // Don't want a negative height.  Happens when splitting a tiny window.\n    // Will equalize heights soon to fix it.\n    if (height < 0)\n\theight = 0;\n    if (wp->w_height == height)\n\treturn;\t    // nothing to do\n\n    if (wp->w_height > 0)\n    {\n\tif (wp == curwin)\n\t    // w_wrow needs to be valid. When setting 'laststatus' this may\n\t    // call win_new_height() recursively.\n\t    validate_cursor();\n\tif (wp->w_height != prev_height)\n\t    return;  // Recursive call already changed the size, bail out here\n\t\t     //\tto avoid the following to mess things up.\n\tif (wp->w_wrow != wp->w_prev_fraction_row)\n\t    set_fraction(wp);\n    }\n\n    wp->w_height = height;\n    wp->w_skipcol = 0;\n\n    // There is no point in adjusting the scroll position when exiting.  Some\n    // values might be invalid.\n    if (!exiting)\n\tscroll_to_fraction(wp, prev_height);\n}\n\n    void\nscroll_to_fraction(win_T *wp, int prev_height)\n{\n    linenr_T\tlnum;\n    int\t\tsline, line_size;\n    int\t\theight = wp->w_height;\n\n    // Don't change w_topline in any of these cases:\n    // - window height is 0\n    // - 'scrollbind' is set and this isn't the current window\n    // - window height is sufficient to display the whole buffer and first line\n    //   is visible.\n    if (height > 0\n\t   && (!wp->w_p_scb || wp == curwin)\n\t   && (height < wp->w_buffer->b_ml.ml_line_count || wp->w_topline > 1))\n    {\n\t/*\n\t * Find a value for w_topline that shows the cursor at the same\n\t * relative position in the window as before (more or less).\n\t */\n\tlnum = wp->w_cursor.lnum;\n\tif (lnum < 1)\t\t// can happen when starting up\n\t    lnum = 1;\n\twp->w_wrow = ((long)wp->w_fraction * (long)height - 1L)\n\t\t\t\t\t\t\t       / FRACTION_MULT;\n\tline_size = plines_win_col(wp, lnum, (long)(wp->w_cursor.col)) - 1;\n\tsline = wp->w_wrow - line_size;\n\n\tif (sline >= 0)\n\t{\n\t    // Make sure the whole cursor line is visible, if possible.\n\t    int rows = plines_win(wp, lnum, FALSE);\n\n\t    if (sline > wp->w_height - rows)\n\t    {\n\t\tsline = wp->w_height - rows;\n\t\twp->w_wrow -= rows - line_size;\n\t    }\n\t}\n\n\tif (sline < 0)\n\t{\n\t    /*\n\t     * Cursor line would go off top of screen if w_wrow was this high.\n\t     * Make cursor line the first line in the window.  If not enough\n\t     * room use w_skipcol;\n\t     */\n\t    wp->w_wrow = line_size;\n\t    if (wp->w_wrow >= wp->w_height\n\t\t\t\t       && (wp->w_width - win_col_off(wp)) > 0)\n\t    {\n\t\twp->w_skipcol += wp->w_width - win_col_off(wp);\n\t\t--wp->w_wrow;\n\t\twhile (wp->w_wrow >= wp->w_height)\n\t\t{\n\t\t    wp->w_skipcol += wp->w_width - win_col_off(wp)\n\t\t\t\t\t\t\t   + win_col_off2(wp);\n\t\t    --wp->w_wrow;\n\t\t}\n\t    }\n\t}\n\telse if (sline > 0)\n\t{\n\t    while (sline > 0 && lnum > 1)\n\t    {\n#ifdef FEAT_FOLDING\n\t\thasFoldingWin(wp, lnum, &lnum, NULL, TRUE, NULL);\n\t\tif (lnum == 1)\n\t\t{\n\t\t    // first line in buffer is folded\n\t\t    line_size = 1;\n\t\t    --sline;\n\t\t    break;\n\t\t}\n#endif\n\t\t--lnum;\n#ifdef FEAT_DIFF\n\t\tif (lnum == wp->w_topline)\n\t\t    line_size = plines_win_nofill(wp, lnum, TRUE)\n\t\t\t\t\t\t\t      + wp->w_topfill;\n\t\telse\n#endif\n\t\t    line_size = plines_win(wp, lnum, TRUE);\n\t\tsline -= line_size;\n\t    }\n\n\t    if (sline < 0)\n\t    {\n\t\t/*\n\t\t * Line we want at top would go off top of screen.  Use next\n\t\t * line instead.\n\t\t */\n#ifdef FEAT_FOLDING\n\t\thasFoldingWin(wp, lnum, NULL, &lnum, TRUE, NULL);\n#endif\n\t\tlnum++;\n\t\twp->w_wrow -= line_size + sline;\n\t    }\n\t    else if (sline > 0)\n\t    {\n\t\t// First line of file reached, use that as topline.\n\t\tlnum = 1;\n\t\twp->w_wrow -= sline;\n\t    }\n\t}\n\tset_topline(wp, lnum);\n    }\n\n    if (wp == curwin)\n    {\n\tif (get_scrolloff_value())\n\t    update_topline();\n\tcurs_columns(FALSE);\t// validate w_wrow\n    }\n    if (prev_height > 0)\n\twp->w_prev_fraction_row = wp->w_wrow;\n\n    win_comp_scroll(wp);\n    redraw_win_later(wp, SOME_VALID);\n    wp->w_redr_status = TRUE;\n    invalidate_botline_win(wp);\n}\n\n/*\n * Set the width of a window.\n */\n    void\nwin_new_width(win_T *wp, int width)\n{\n    wp->w_width = width;\n    wp->w_lines_valid = 0;\n    changed_line_abv_curs_win(wp);\n    invalidate_botline_win(wp);\n    if (wp == curwin)\n    {\n\tupdate_topline();\n\tcurs_columns(TRUE);\t// validate w_wrow\n    }\n    redraw_win_later(wp, NOT_VALID);\n    wp->w_redr_status = TRUE;\n}\n\n    void\nwin_comp_scroll(win_T *wp)\n{\n#if defined(FEAT_EVAL)\n    int old_w_p_scr = wp->w_p_scr;\n#endif\n\n    wp->w_p_scr = ((unsigned)wp->w_height >> 1);\n    if (wp->w_p_scr == 0)\n\twp->w_p_scr = 1;\n#if defined(FEAT_EVAL)\n    if (wp->w_p_scr != old_w_p_scr)\n    {\n\t// Used by \"verbose set scroll\".\n\twp->w_p_script_ctx[WV_SCROLL].sc_sid = SID_WINLAYOUT;\n\twp->w_p_script_ctx[WV_SCROLL].sc_lnum = 0;\n    }\n#endif\n}\n\n/*\n * command_height: called whenever p_ch has been changed\n */\n    void\ncommand_height(void)\n{\n    int\t\th;\n    frame_T\t*frp;\n    int\t\told_p_ch = curtab->tp_ch_used;\n\n    // Use the value of p_ch that we remembered.  This is needed for when the\n    // GUI starts up, we can't be sure in what order things happen.  And when\n    // p_ch was changed in another tab page.\n    curtab->tp_ch_used = p_ch;\n\n    // Find bottom frame with width of screen.\n    frp = lastwin->w_frame;\n    while (frp->fr_width != Columns && frp->fr_parent != NULL)\n\tfrp = frp->fr_parent;\n\n    // Avoid changing the height of a window with 'winfixheight' set.\n    while (frp->fr_prev != NULL && frp->fr_layout == FR_LEAF\n\t\t\t\t\t\t      && frp->fr_win->w_p_wfh)\n\tfrp = frp->fr_prev;\n\n    if (starting != NO_SCREEN)\n    {\n\tcmdline_row = Rows - p_ch;\n\n\tif (p_ch > old_p_ch)\t\t    // p_ch got bigger\n\t{\n\t    while (p_ch > old_p_ch)\n\t    {\n\t\tif (frp == NULL)\n\t\t{\n\t\t    emsg(_(e_not_enough_room));\n\t\t    p_ch = old_p_ch;\n\t\t    curtab->tp_ch_used = p_ch;\n\t\t    cmdline_row = Rows - p_ch;\n\t\t    break;\n\t\t}\n\t\th = frp->fr_height - frame_minheight(frp, NULL);\n\t\tif (h > p_ch - old_p_ch)\n\t\t    h = p_ch - old_p_ch;\n\t\told_p_ch += h;\n\t\tframe_add_height(frp, -h);\n\t\tfrp = frp->fr_prev;\n\t    }\n\n\t    // Recompute window positions.\n\t    (void)win_comp_pos();\n\n\t    // clear the lines added to cmdline\n\t    if (full_screen)\n\t\tscreen_fill(cmdline_row, (int)Rows, 0,\n\t\t\t\t\t\t   (int)Columns, ' ', ' ', 0);\n\t    msg_row = cmdline_row;\n\t    redraw_cmdline = TRUE;\n\t    return;\n\t}\n\n\tif (msg_row < cmdline_row)\n\t    msg_row = cmdline_row;\n\tredraw_cmdline = TRUE;\n    }\n    frame_add_height(frp, (int)(old_p_ch - p_ch));\n\n    // Recompute window positions.\n    if (frp != lastwin->w_frame)\n\t(void)win_comp_pos();\n}\n\n/*\n * Resize frame \"frp\" to be \"n\" lines higher (negative for less high).\n * Also resize the frames it is contained in.\n */\n    static void\nframe_add_height(frame_T *frp, int n)\n{\n    frame_new_height(frp, frp->fr_height + n, FALSE, FALSE);\n    for (;;)\n    {\n\tfrp = frp->fr_parent;\n\tif (frp == NULL)\n\t    break;\n\tfrp->fr_height += n;\n    }\n}\n\n/*\n * Add or remove a status line for the bottom window(s), according to the\n * value of 'laststatus'.\n */\n    void\nlast_status(\n    int\t\tmorewin)\t// pretend there are two or more windows\n{\n    // Don't make a difference between horizontal or vertical split.\n    last_status_rec(topframe, (p_ls == 2\n\t\t\t  || (p_ls == 1 && (morewin || !ONE_WINDOW))));\n}\n\n    static void\nlast_status_rec(frame_T *fr, int statusline)\n{\n    frame_T\t*fp;\n    win_T\t*wp;\n\n    if (fr->fr_layout == FR_LEAF)\n    {\n\twp = fr->fr_win;\n\tif (wp->w_status_height != 0 && !statusline)\n\t{\n\t    // remove status line\n\t    win_new_height(wp, wp->w_height + 1);\n\t    wp->w_status_height = 0;\n\t    comp_col();\n\t}\n\telse if (wp->w_status_height == 0 && statusline)\n\t{\n\t    // Find a frame to take a line from.\n\t    fp = fr;\n\t    while (fp->fr_height <= frame_minheight(fp, NULL))\n\t    {\n\t\tif (fp == topframe)\n\t\t{\n\t\t    emsg(_(e_not_enough_room));\n\t\t    return;\n\t\t}\n\t\t// In a column of frames: go to frame above.  If already at\n\t\t// the top or in a row of frames: go to parent.\n\t\tif (fp->fr_parent->fr_layout == FR_COL && fp->fr_prev != NULL)\n\t\t    fp = fp->fr_prev;\n\t\telse\n\t\t    fp = fp->fr_parent;\n\t    }\n\t    wp->w_status_height = 1;\n\t    if (fp != fr)\n\t    {\n\t\tframe_new_height(fp, fp->fr_height - 1, FALSE, FALSE);\n\t\tframe_fix_height(wp);\n\t\t(void)win_comp_pos();\n\t    }\n\t    else\n\t\twin_new_height(wp, wp->w_height - 1);\n\t    comp_col();\n\t    redraw_all_later(SOME_VALID);\n\t}\n    }\n    else if (fr->fr_layout == FR_ROW)\n    {\n\t// vertically split windows, set status line for each one\n\tFOR_ALL_FRAMES(fp, fr->fr_child)\n\t    last_status_rec(fp, statusline);\n    }\n    else\n    {\n\t// horizontally split window, set status line for last one\n\tfor (fp = fr->fr_child; fp->fr_next != NULL; fp = fp->fr_next)\n\t    ;\n\tlast_status_rec(fp, statusline);\n    }\n}\n\n/*\n * Return the number of lines used by the tab page line.\n */\n    int\ntabline_height(void)\n{\n#ifdef FEAT_GUI_TABLINE\n    // When the GUI has the tabline then this always returns zero.\n    if (gui_use_tabline())\n\treturn 0;\n#endif\n    switch (p_stal)\n    {\n\tcase 0: return 0;\n\tcase 1: return (first_tabpage->tp_next == NULL) ? 0 : 1;\n    }\n    return 1;\n}\n\n/*\n * Return the minimal number of rows that is needed on the screen to display\n * the current number of windows.\n */\n    int\nmin_rows(void)\n{\n    int\t\ttotal;\n    tabpage_T\t*tp;\n    int\t\tn;\n\n    if (firstwin == NULL)\t// not initialized yet\n\treturn MIN_LINES;\n\n    total = 0;\n    FOR_ALL_TABPAGES(tp)\n    {\n\tn = frame_minheight(tp->tp_topframe, NULL);\n\tif (total < n)\n\t    total = n;\n    }\n    total += tabline_height();\n    total += 1;\t\t// count the room for the command line\n    return total;\n}\n\n/*\n * Return TRUE if there is only one window and only one tab page, not\n * counting a help or preview window, unless it is the current window.\n * Does not count unlisted windows.\n */\n    int\nonly_one_window(void)\n{\n    int\t\tcount = 0;\n    win_T\t*wp;\n\n#if defined(FEAT_PROP_POPUP)\n    // If the current window is a popup then there always is another window.\n    if (popup_is_popup(curwin))\n\treturn FALSE;\n#endif\n\n    // If there is another tab page there always is another window.\n    if (first_tabpage->tp_next != NULL)\n\treturn FALSE;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (wp->w_buffer != NULL\n\t\t&& (!((bt_help(wp->w_buffer) && !bt_help(curbuf))\n# ifdef FEAT_QUICKFIX\n\t\t    || wp->w_p_pvw\n# endif\n\t     ) || wp == curwin) && wp != aucmd_win)\n\t    ++count;\n    return (count <= 1);\n}\n\n/*\n * Correct the cursor line number in other windows.  Used after changing the\n * current buffer, and before applying autocommands.\n * When \"do_curwin\" is TRUE, also check current window.\n */\n    void\ncheck_lnums(int do_curwin)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\tif ((do_curwin || wp != curwin) && wp->w_buffer == curbuf)\n\t{\n\t    // save the original cursor position and topline\n\t    wp->w_save_cursor.w_cursor_save = wp->w_cursor;\n\t    wp->w_save_cursor.w_topline_save = wp->w_topline;\n\n\t    if (wp->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t\twp->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t    if (wp->w_topline > curbuf->b_ml.ml_line_count)\n\t\twp->w_topline = curbuf->b_ml.ml_line_count;\n\n\t    // save the corrected cursor position and topline\n\t    wp->w_save_cursor.w_cursor_corr = wp->w_cursor;\n\t    wp->w_save_cursor.w_topline_corr = wp->w_topline;\n\t}\n}\n\n/*\n * Reset cursor and topline to its stored values from check_lnums().\n * check_lnums() must have been called first!\n */\n    void\nreset_lnums()\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\tif (wp->w_buffer == curbuf)\n\t{\n\t    // Restore the value if the autocommand didn't change it.\n\t    if (EQUAL_POS(wp->w_save_cursor.w_cursor_corr, wp->w_cursor))\n\t\twp->w_cursor = wp->w_save_cursor.w_cursor_save;\n\t    if (wp->w_save_cursor.w_topline_corr == wp->w_topline)\n\t\twp->w_topline = wp->w_save_cursor.w_topline_save;\n\t}\n}\n\n/*\n * A snapshot of the window sizes, to restore them after closing the help\n * window.\n * Only these fields are used:\n * fr_layout\n * fr_width\n * fr_height\n * fr_next\n * fr_child\n * fr_win (only valid for the old curwin, NULL otherwise)\n */\n\n/*\n * Create a snapshot of the current frame sizes.\n */\n    void\nmake_snapshot(int idx)\n{\n    clear_snapshot(curtab, idx);\n    make_snapshot_rec(topframe, &curtab->tp_snapshot[idx]);\n}\n\n    static void\nmake_snapshot_rec(frame_T *fr, frame_T **frp)\n{\n    *frp = ALLOC_CLEAR_ONE(frame_T);\n    if (*frp == NULL)\n\treturn;\n    (*frp)->fr_layout = fr->fr_layout;\n    (*frp)->fr_width = fr->fr_width;\n    (*frp)->fr_height = fr->fr_height;\n    if (fr->fr_next != NULL)\n\tmake_snapshot_rec(fr->fr_next, &((*frp)->fr_next));\n    if (fr->fr_child != NULL)\n\tmake_snapshot_rec(fr->fr_child, &((*frp)->fr_child));\n    if (fr->fr_layout == FR_LEAF && fr->fr_win == curwin)\n\t(*frp)->fr_win = curwin;\n}\n\n/*\n * Remove any existing snapshot.\n */\n    static void\nclear_snapshot(tabpage_T *tp, int idx)\n{\n    clear_snapshot_rec(tp->tp_snapshot[idx]);\n    tp->tp_snapshot[idx] = NULL;\n}\n\n    static void\nclear_snapshot_rec(frame_T *fr)\n{\n    if (fr != NULL)\n    {\n\tclear_snapshot_rec(fr->fr_next);\n\tclear_snapshot_rec(fr->fr_child);\n\tvim_free(fr);\n    }\n}\n\n/*\n * Traverse a snapshot to find the previous curwin.\n */\n    static win_T *\nget_snapshot_curwin_rec(frame_T *ft)\n{\n    win_T\t*wp;\n\n    if (ft->fr_next != NULL)\n    {\n\tif ((wp = get_snapshot_curwin_rec(ft->fr_next)) != NULL)\n\t    return wp;\n    }\n    if (ft->fr_child != NULL)\n    {\n\tif ((wp = get_snapshot_curwin_rec(ft->fr_child)) != NULL)\n\t    return wp;\n    }\n\n    return ft->fr_win;\n}\n\n/*\n * Return the current window stored in the snapshot or NULL.\n */\n    static win_T *\nget_snapshot_curwin(int idx)\n{\n    if (curtab->tp_snapshot[idx] == NULL)\n\treturn NULL;\n\n    return get_snapshot_curwin_rec(curtab->tp_snapshot[idx]);\n}\n\n/*\n * Restore a previously created snapshot, if there is any.\n * This is only done if the screen size didn't change and the window layout is\n * still the same.\n */\n    void\nrestore_snapshot(\n    int\t\tidx,\n    int\t\tclose_curwin)\t    // closing current window\n{\n    win_T\t*wp;\n\n    if (curtab->tp_snapshot[idx] != NULL\n\t    && curtab->tp_snapshot[idx]->fr_width == topframe->fr_width\n\t    && curtab->tp_snapshot[idx]->fr_height == topframe->fr_height\n\t    && check_snapshot_rec(curtab->tp_snapshot[idx], topframe) == OK)\n    {\n\twp = restore_snapshot_rec(curtab->tp_snapshot[idx], topframe);\n\twin_comp_pos();\n\tif (wp != NULL && close_curwin)\n\t    win_goto(wp);\n\tredraw_all_later(NOT_VALID);\n    }\n    clear_snapshot(curtab, idx);\n}\n\n/*\n * Check if frames \"sn\" and \"fr\" have the same layout, same following frames\n * and same children.  And the window pointer is valid.\n */\n    static int\ncheck_snapshot_rec(frame_T *sn, frame_T *fr)\n{\n    if (sn->fr_layout != fr->fr_layout\n\t    || (sn->fr_next == NULL) != (fr->fr_next == NULL)\n\t    || (sn->fr_child == NULL) != (fr->fr_child == NULL)\n\t    || (sn->fr_next != NULL\n\t\t&& check_snapshot_rec(sn->fr_next, fr->fr_next) == FAIL)\n\t    || (sn->fr_child != NULL\n\t\t&& check_snapshot_rec(sn->fr_child, fr->fr_child) == FAIL)\n\t    || (sn->fr_win != NULL && !win_valid(sn->fr_win)))\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * Copy the size of snapshot frame \"sn\" to frame \"fr\".  Do the same for all\n * following frames and children.\n * Returns a pointer to the old current window, or NULL.\n */\n    static win_T *\nrestore_snapshot_rec(frame_T *sn, frame_T *fr)\n{\n    win_T\t*wp = NULL;\n    win_T\t*wp2;\n\n    fr->fr_height = sn->fr_height;\n    fr->fr_width = sn->fr_width;\n    if (fr->fr_layout == FR_LEAF)\n    {\n\tframe_new_height(fr, fr->fr_height, FALSE, FALSE);\n\tframe_new_width(fr, fr->fr_width, FALSE, FALSE);\n\twp = sn->fr_win;\n    }\n    if (sn->fr_next != NULL)\n    {\n\twp2 = restore_snapshot_rec(sn->fr_next, fr->fr_next);\n\tif (wp2 != NULL)\n\t    wp = wp2;\n    }\n    if (sn->fr_child != NULL)\n    {\n\twp2 = restore_snapshot_rec(sn->fr_child, fr->fr_child);\n\tif (wp2 != NULL)\n\t    wp = wp2;\n    }\n    return wp;\n}\n\n#if defined(FEAT_GUI) || defined(PROTO)\n/*\n * Return TRUE if there is any vertically split window.\n */\n    int\nwin_hasvertsplit(void)\n{\n    frame_T\t*fr;\n\n    if (topframe->fr_layout == FR_ROW)\n\treturn TRUE;\n\n    if (topframe->fr_layout == FR_COL)\n\tFOR_ALL_FRAMES(fr, topframe->fr_child)\n\t    if (fr->fr_layout == FR_ROW)\n\t\treturn TRUE;\n\n    return FALSE;\n}\n#endif\n\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3) || defined(PROTO)\n    int\nget_win_number(win_T *wp, win_T *first_win)\n{\n    int\t\ti = 1;\n    win_T\t*w;\n\n    for (w = first_win; w != NULL && w != wp; w = W_NEXT(w))\n\t++i;\n\n    if (w == NULL)\n\treturn 0;\n    else\n\treturn i;\n}\n\n    int\nget_tab_number(tabpage_T *tp UNUSED)\n{\n    int\t\ti = 1;\n    tabpage_T\t*t;\n\n    for (t = first_tabpage; t != NULL && t != tp; t = t->tp_next)\n\t++i;\n\n    if (t == NULL)\n\treturn 0;\n    else\n\treturn i;\n}\n#endif\n\n/*\n * Return TRUE if \"topfrp\" and its children are at the right height.\n */\n    static int\nframe_check_height(frame_T *topfrp, int height)\n{\n    frame_T *frp;\n\n    if (topfrp->fr_height != height)\n\treturn FALSE;\n\n    if (topfrp->fr_layout == FR_ROW)\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    if (frp->fr_height != height)\n\t\treturn FALSE;\n\n    return TRUE;\n}\n\n/*\n * Return TRUE if \"topfrp\" and its children are at the right width.\n */\n    static int\nframe_check_width(frame_T *topfrp, int width)\n{\n    frame_T *frp;\n\n    if (topfrp->fr_width != width)\n\treturn FALSE;\n\n    if (topfrp->fr_layout == FR_COL)\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    if (frp->fr_width != width)\n\t\treturn FALSE;\n\n    return TRUE;\n}\n\n#if defined(FEAT_SYN_HL) || defined(PROTO)\n/*\n * Simple int comparison function for use with qsort()\n */\n    static int\nint_cmp(const void *a, const void *b)\n{\n    return *(const int *)a - *(const int *)b;\n}\n\n/*\n * Handle setting 'colorcolumn' or 'textwidth' in window \"wp\".\n * Returns error message, NULL if it's OK.\n */\n    char *\ncheck_colorcolumn(win_T *wp)\n{\n    char_u\t*s;\n    int\t\tcol;\n    int\t\tcount = 0;\n    int\t\tcolor_cols[256];\n    int\t\ti;\n    int\t\tj = 0;\n\n    if (wp->w_buffer == NULL)\n\treturn NULL;  // buffer was closed\n\n    for (s = wp->w_p_cc; *s != NUL && count < 255;)\n    {\n\tif (*s == '-' || *s == '+')\n\t{\n\t    // -N and +N: add to 'textwidth'\n\t    col = (*s == '-') ? -1 : 1;\n\t    ++s;\n\t    if (!VIM_ISDIGIT(*s))\n\t\treturn e_invalid_argument;\n\t    col = col * getdigits(&s);\n\t    if (wp->w_buffer->b_p_tw == 0)\n\t\tgoto skip;  // 'textwidth' not set, skip this item\n\t    col += wp->w_buffer->b_p_tw;\n\t    if (col < 0)\n\t\tgoto skip;\n\t}\n\telse if (VIM_ISDIGIT(*s))\n\t    col = getdigits(&s);\n\telse\n\t    return e_invalid_argument;\n\tcolor_cols[count++] = col - 1;  // 1-based to 0-based\nskip:\n\tif (*s == NUL)\n\t    break;\n\tif (*s != ',')\n\t    return e_invalid_argument;\n\tif (*++s == NUL)\n\t    return e_invalid_argument;  // illegal trailing comma as in \"set cc=80,\"\n    }\n\n    vim_free(wp->w_p_cc_cols);\n    if (count == 0)\n\twp->w_p_cc_cols = NULL;\n    else\n    {\n\twp->w_p_cc_cols = ALLOC_MULT(int, count + 1);\n\tif (wp->w_p_cc_cols != NULL)\n\t{\n\t    // sort the columns for faster usage on screen redraw inside\n\t    // win_line()\n\t    qsort(color_cols, count, sizeof(int), int_cmp);\n\n\t    for (i = 0; i < count; ++i)\n\t\t// skip duplicates\n\t\tif (j == 0 || wp->w_p_cc_cols[j - 1] != color_cols[i])\n\t\t    wp->w_p_cc_cols[j++] = color_cols[i];\n\t    wp->w_p_cc_cols[j] = -1;  // end marker\n\t}\n    }\n\n    return NULL;  // no error\n}\n#endif\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * autocmd.c: Autocommand related functions\n */\n\n#include \"vim.h\"\n\n/*\n * The autocommands are stored in a list for each event.\n * Autocommands for the same pattern, that are consecutive, are joined\n * together, to avoid having to match the pattern too often.\n * The result is an array of Autopat lists, which point to AutoCmd lists:\n *\n * last_autopat[0]  -----------------------------+\n *\t\t\t\t\t\t V\n * first_autopat[0] --> Autopat.next  -->  Autopat.next -->  NULL\n *\t\t\tAutopat.cmds\t   Autopat.cmds\n *\t\t\t    |\t\t\t |\n *\t\t\t    V\t\t\t V\n *\t\t\tAutoCmd.next\t   AutoCmd.next\n *\t\t\t    |\t\t\t |\n *\t\t\t    V\t\t\t V\n *\t\t\tAutoCmd.next\t\tNULL\n *\t\t\t    |\n *\t\t\t    V\n *\t\t\t   NULL\n *\n * last_autopat[1]  --------+\n *\t\t\t    V\n * first_autopat[1] --> Autopat.next  -->  NULL\n *\t\t\tAutopat.cmds\n *\t\t\t    |\n *\t\t\t    V\n *\t\t\tAutoCmd.next\n *\t\t\t    |\n *\t\t\t    V\n *\t\t\t   NULL\n *   etc.\n *\n *   The order of AutoCmds is important, this is the order in which they were\n *   defined and will have to be executed.\n */\ntypedef struct AutoCmd\n{\n    char_u\t    *cmd;\t\t// The command to be executed (NULL\n\t\t\t\t\t// when command has been removed).\n    char\t    once;\t\t// \"One shot\": removed after execution\n    char\t    nested;\t\t// If autocommands nest here.\n    char\t    last;\t\t// last command in list\n    sctx_T\t    script_ctx;\t\t// script context where it is defined\n    struct AutoCmd  *next;\t\t// next AutoCmd in list\n} AutoCmd;\n\ntypedef struct AutoPat\n{\n    struct AutoPat  *next;\t\t// Next AutoPat in AutoPat list; MUST\n\t\t\t\t\t// be the first entry.\n    char_u\t    *pat;\t\t// pattern as typed (NULL when pattern\n\t\t\t\t\t// has been removed)\n    regprog_T\t    *reg_prog;\t\t// compiled regprog for pattern\n    AutoCmd\t    *cmds;\t\t// list of commands to do\n    int\t\t    group;\t\t// group ID\n    int\t\t    patlen;\t\t// strlen() of pat\n    int\t\t    buflocal_nr;\t// !=0 for buffer-local AutoPat\n    char\t    allow_dirs;\t\t// Pattern may match whole path\n    char\t    last;\t\t// last pattern for apply_autocmds()\n} AutoPat;\n\nstatic struct event_name\n{\n    char\t*name;\t// event name\n    event_T\tevent;\t// event number\n} event_names[] =\n{\n    {\"BufAdd\",\t\tEVENT_BUFADD},\n    {\"BufCreate\",\tEVENT_BUFADD},\n    {\"BufDelete\",\tEVENT_BUFDELETE},\n    {\"BufEnter\",\tEVENT_BUFENTER},\n    {\"BufFilePost\",\tEVENT_BUFFILEPOST},\n    {\"BufFilePre\",\tEVENT_BUFFILEPRE},\n    {\"BufHidden\",\tEVENT_BUFHIDDEN},\n    {\"BufLeave\",\tEVENT_BUFLEAVE},\n    {\"BufNew\",\t\tEVENT_BUFNEW},\n    {\"BufNewFile\",\tEVENT_BUFNEWFILE},\n    {\"BufRead\",\t\tEVENT_BUFREADPOST},\n    {\"BufReadCmd\",\tEVENT_BUFREADCMD},\n    {\"BufReadPost\",\tEVENT_BUFREADPOST},\n    {\"BufReadPre\",\tEVENT_BUFREADPRE},\n    {\"BufUnload\",\tEVENT_BUFUNLOAD},\n    {\"BufWinEnter\",\tEVENT_BUFWINENTER},\n    {\"BufWinLeave\",\tEVENT_BUFWINLEAVE},\n    {\"BufWipeout\",\tEVENT_BUFWIPEOUT},\n    {\"BufWrite\",\tEVENT_BUFWRITEPRE},\n    {\"BufWritePost\",\tEVENT_BUFWRITEPOST},\n    {\"BufWritePre\",\tEVENT_BUFWRITEPRE},\n    {\"BufWriteCmd\",\tEVENT_BUFWRITECMD},\n    {\"CmdlineChanged\",\tEVENT_CMDLINECHANGED},\n    {\"CmdlineEnter\",\tEVENT_CMDLINEENTER},\n    {\"CmdlineLeave\",\tEVENT_CMDLINELEAVE},\n    {\"CmdwinEnter\",\tEVENT_CMDWINENTER},\n    {\"CmdwinLeave\",\tEVENT_CMDWINLEAVE},\n    {\"CmdUndefined\",\tEVENT_CMDUNDEFINED},\n    {\"ColorScheme\",\tEVENT_COLORSCHEME},\n    {\"ColorSchemePre\",\tEVENT_COLORSCHEMEPRE},\n    {\"CompleteChanged\",\tEVENT_COMPLETECHANGED},\n    {\"CompleteDone\",\tEVENT_COMPLETEDONE},\n    {\"CompleteDonePre\",\tEVENT_COMPLETEDONEPRE},\n    {\"CursorHold\",\tEVENT_CURSORHOLD},\n    {\"CursorHoldI\",\tEVENT_CURSORHOLDI},\n    {\"CursorMoved\",\tEVENT_CURSORMOVED},\n    {\"CursorMovedI\",\tEVENT_CURSORMOVEDI},\n    {\"DiffUpdated\",\tEVENT_DIFFUPDATED},\n    {\"DirChanged\",\tEVENT_DIRCHANGED},\n    {\"DirChangedPre\",\tEVENT_DIRCHANGEDPRE},\n    {\"EncodingChanged\",\tEVENT_ENCODINGCHANGED},\n    {\"ExitPre\",\t\tEVENT_EXITPRE},\n    {\"FileEncoding\",\tEVENT_ENCODINGCHANGED},\n    {\"FileAppendPost\",\tEVENT_FILEAPPENDPOST},\n    {\"FileAppendPre\",\tEVENT_FILEAPPENDPRE},\n    {\"FileAppendCmd\",\tEVENT_FILEAPPENDCMD},\n    {\"FileChangedShell\",EVENT_FILECHANGEDSHELL},\n    {\"FileChangedShellPost\",EVENT_FILECHANGEDSHELLPOST},\n    {\"FileChangedRO\",\tEVENT_FILECHANGEDRO},\n    {\"FileReadPost\",\tEVENT_FILEREADPOST},\n    {\"FileReadPre\",\tEVENT_FILEREADPRE},\n    {\"FileReadCmd\",\tEVENT_FILEREADCMD},\n    {\"FileType\",\tEVENT_FILETYPE},\n    {\"FileWritePost\",\tEVENT_FILEWRITEPOST},\n    {\"FileWritePre\",\tEVENT_FILEWRITEPRE},\n    {\"FileWriteCmd\",\tEVENT_FILEWRITECMD},\n    {\"FilterReadPost\",\tEVENT_FILTERREADPOST},\n    {\"FilterReadPre\",\tEVENT_FILTERREADPRE},\n    {\"FilterWritePost\",\tEVENT_FILTERWRITEPOST},\n    {\"FilterWritePre\",\tEVENT_FILTERWRITEPRE},\n    {\"FocusGained\",\tEVENT_FOCUSGAINED},\n    {\"FocusLost\",\tEVENT_FOCUSLOST},\n    {\"FuncUndefined\",\tEVENT_FUNCUNDEFINED},\n    {\"GUIEnter\",\tEVENT_GUIENTER},\n    {\"GUIFailed\",\tEVENT_GUIFAILED},\n    {\"InsertChange\",\tEVENT_INSERTCHANGE},\n    {\"InsertEnter\",\tEVENT_INSERTENTER},\n    {\"InsertLeave\",\tEVENT_INSERTLEAVE},\n    {\"InsertLeavePre\",\tEVENT_INSERTLEAVEPRE},\n    {\"InsertCharPre\",\tEVENT_INSERTCHARPRE},\n    {\"MenuPopup\",\tEVENT_MENUPOPUP},\n    {\"ModeChanged\",\tEVENT_MODECHANGED},\n    {\"OptionSet\",\tEVENT_OPTIONSET},\n    {\"QuickFixCmdPost\",\tEVENT_QUICKFIXCMDPOST},\n    {\"QuickFixCmdPre\",\tEVENT_QUICKFIXCMDPRE},\n    {\"QuitPre\",\t\tEVENT_QUITPRE},\n    {\"RemoteReply\",\tEVENT_REMOTEREPLY},\n    {\"SafeState\",\tEVENT_SAFESTATE},\n    {\"SafeStateAgain\",\tEVENT_SAFESTATEAGAIN},\n    {\"SessionLoadPost\",\tEVENT_SESSIONLOADPOST},\n    {\"ShellCmdPost\",\tEVENT_SHELLCMDPOST},\n    {\"ShellFilterPost\",\tEVENT_SHELLFILTERPOST},\n    {\"SigUSR1\",\t\tEVENT_SIGUSR1},\n    {\"SourceCmd\",\tEVENT_SOURCECMD},\n    {\"SourcePre\",\tEVENT_SOURCEPRE},\n    {\"SourcePost\",\tEVENT_SOURCEPOST},\n    {\"SpellFileMissing\",EVENT_SPELLFILEMISSING},\n    {\"StdinReadPost\",\tEVENT_STDINREADPOST},\n    {\"StdinReadPre\",\tEVENT_STDINREADPRE},\n    {\"SwapExists\",\tEVENT_SWAPEXISTS},\n    {\"Syntax\",\t\tEVENT_SYNTAX},\n    {\"TabNew\",\t\tEVENT_TABNEW},\n    {\"TabClosed\",\tEVENT_TABCLOSED},\n    {\"TabEnter\",\tEVENT_TABENTER},\n    {\"TabLeave\",\tEVENT_TABLEAVE},\n    {\"TermChanged\",\tEVENT_TERMCHANGED},\n    {\"TerminalOpen\",\tEVENT_TERMINALOPEN},\n    {\"TerminalWinOpen\", EVENT_TERMINALWINOPEN},\n    {\"TermResponse\",\tEVENT_TERMRESPONSE},\n    {\"TextChanged\",\tEVENT_TEXTCHANGED},\n    {\"TextChangedI\",\tEVENT_TEXTCHANGEDI},\n    {\"TextChangedP\",\tEVENT_TEXTCHANGEDP},\n    {\"User\",\t\tEVENT_USER},\n    {\"VimEnter\",\tEVENT_VIMENTER},\n    {\"VimLeave\",\tEVENT_VIMLEAVE},\n    {\"VimLeavePre\",\tEVENT_VIMLEAVEPRE},\n    {\"WinNew\",\t\tEVENT_WINNEW},\n    {\"WinClosed\",\tEVENT_WINCLOSED},\n    {\"WinEnter\",\tEVENT_WINENTER},\n    {\"WinLeave\",\tEVENT_WINLEAVE},\n    {\"WinScrolled\",\tEVENT_WINSCROLLED},\n    {\"VimResized\",\tEVENT_VIMRESIZED},\n    {\"TextYankPost\",\tEVENT_TEXTYANKPOST},\n    {\"VimSuspend\",\tEVENT_VIMSUSPEND},\n    {\"VimResume\",\tEVENT_VIMRESUME},\n    {NULL,\t\t(event_T)0}\n};\n\nstatic AutoPat *first_autopat[NUM_EVENTS] =\n{\n    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL\n};\n\nstatic AutoPat *last_autopat[NUM_EVENTS] =\n{\n    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL\n};\n\n#define AUGROUP_DEFAULT    (-1)\t    // default autocmd group\n#define AUGROUP_ERROR\t   (-2)\t    // erroneous autocmd group\n#define AUGROUP_ALL\t   (-3)\t    // all autocmd groups\n\n/*\n * struct used to keep status while executing autocommands for an event.\n */\nstruct AutoPatCmd_S\n{\n    AutoPat\t*curpat;\t// next AutoPat to examine\n    AutoCmd\t*nextcmd;\t// next AutoCmd to execute\n    int\t\tgroup;\t\t// group being used\n    char_u\t*fname;\t\t// fname to match with\n    char_u\t*sfname;\t// sfname to match with\n    char_u\t*tail;\t\t// tail of fname\n    event_T\tevent;\t\t// current event\n    sctx_T\tscript_ctx;\t// script context where it is defined\n    int\t\targ_bufnr;\t// Initially equal to <abuf>, set to zero when\n\t\t\t\t// buf is deleted.\n    AutoPatCmd_T *next;\t\t// chain of active apc-s for auto-invalidation\n};\n\nstatic AutoPatCmd_T *active_apc_list = NULL; // stack of active autocommands\n\n// Macro to loop over all the patterns for an autocmd event\n#define FOR_ALL_AUTOCMD_PATTERNS(event, ap) \\\n    for ((ap) = first_autopat[(int)(event)]; (ap) != NULL; (ap) = (ap)->next)\n\n/*\n * augroups stores a list of autocmd group names.\n */\nstatic garray_T augroups = {0, 0, sizeof(char_u *), 10, NULL};\n#define AUGROUP_NAME(i) (((char_u **)augroups.ga_data)[i])\n// use get_deleted_augroup() to get this\nstatic char_u *deleted_augroup = NULL;\n\n/*\n * The ID of the current group.  Group 0 is the default one.\n */\nstatic int current_augroup = AUGROUP_DEFAULT;\n\nstatic int au_need_clean = FALSE;   // need to delete marked patterns\n\nstatic char_u *event_nr2name(event_T event);\nstatic int au_get_grouparg(char_u **argp);\nstatic int do_autocmd_event(event_T event, char_u *pat, int once, int nested, char_u *cmd, int forceit, int group, int flags);\nstatic int apply_autocmds_group(event_T event, char_u *fname, char_u *fname_io, int force, int group, buf_T *buf, exarg_T *eap);\nstatic void auto_next_pat(AutoPatCmd_T *apc, int stop_at_last);\nstatic int au_find_group(char_u *name);\n\nstatic event_T\tlast_event;\nstatic int\tlast_group;\nstatic int\tautocmd_blocked = 0;\t// block all autocmds\n\n    static char_u *\nget_deleted_augroup(void)\n{\n    if (deleted_augroup == NULL)\n\tdeleted_augroup = (char_u *)_(\"--Deleted--\");\n    return deleted_augroup;\n}\n\n/*\n * Show the autocommands for one AutoPat.\n */\n    static void\nshow_autocmd(AutoPat *ap, event_T event)\n{\n    AutoCmd *ac;\n\n    // Check for \"got_int\" (here and at various places below), which is set\n    // when \"q\" has been hit for the \"--more--\" prompt\n    if (got_int)\n\treturn;\n    if (ap->pat == NULL)\t\t// pattern has been removed\n\treturn;\n\n    msg_putchar('\\n');\n    if (got_int)\n\treturn;\n    if (event != last_event || ap->group != last_group)\n    {\n\tif (ap->group != AUGROUP_DEFAULT)\n\t{\n\t    if (AUGROUP_NAME(ap->group) == NULL)\n\t\tmsg_puts_attr((char *)get_deleted_augroup(), HL_ATTR(HLF_E));\n\t    else\n\t\tmsg_puts_attr((char *)AUGROUP_NAME(ap->group), HL_ATTR(HLF_T));\n\t    msg_puts(\"  \");\n\t}\n\tmsg_puts_attr((char *)event_nr2name(event), HL_ATTR(HLF_T));\n\tlast_event = event;\n\tlast_group = ap->group;\n\tmsg_putchar('\\n');\n\tif (got_int)\n\t    return;\n    }\n    msg_col = 4;\n    msg_outtrans(ap->pat);\n\n    for (ac = ap->cmds; ac != NULL; ac = ac->next)\n    {\n\tif (ac->cmd != NULL)\t\t// skip removed commands\n\t{\n\t    if (msg_col >= 14)\n\t\tmsg_putchar('\\n');\n\t    msg_col = 14;\n\t    if (got_int)\n\t\treturn;\n\t    msg_outtrans(ac->cmd);\n#ifdef FEAT_EVAL\n\t    if (p_verbose > 0)\n\t\tlast_set_msg(ac->script_ctx);\n#endif\n\t    if (got_int)\n\t\treturn;\n\t    if (ac->next != NULL)\n\t    {\n\t\tmsg_putchar('\\n');\n\t\tif (got_int)\n\t\t    return;\n\t    }\n\t}\n    }\n}\n\n/*\n * Mark an autocommand pattern for deletion.\n */\n    static void\nau_remove_pat(AutoPat *ap)\n{\n    VIM_CLEAR(ap->pat);\n    ap->buflocal_nr = -1;\n    au_need_clean = TRUE;\n}\n\n/*\n * Mark all commands for a pattern for deletion.\n */\n    static void\nau_remove_cmds(AutoPat *ap)\n{\n    AutoCmd *ac;\n\n    for (ac = ap->cmds; ac != NULL; ac = ac->next)\n\tVIM_CLEAR(ac->cmd);\n    au_need_clean = TRUE;\n}\n\n// Delete one command from an autocmd pattern.\nstatic void au_del_cmd(AutoCmd *ac)\n{\n    VIM_CLEAR(ac->cmd);\n    au_need_clean = TRUE;\n}\n\n/*\n * Cleanup autocommands and patterns that have been deleted.\n * This is only done when not executing autocommands.\n */\n    static void\nau_cleanup(void)\n{\n    AutoPat\t*ap, **prev_ap;\n    AutoCmd\t*ac, **prev_ac;\n    event_T\tevent;\n\n    if (autocmd_busy || !au_need_clean)\n\treturn;\n\n    // loop over all events\n    for (event = (event_T)0; (int)event < NUM_EVENTS;\n\t\t\t\t\t    event = (event_T)((int)event + 1))\n    {\n\t// loop over all autocommand patterns\n\tprev_ap = &(first_autopat[(int)event]);\n\tfor (ap = *prev_ap; ap != NULL; ap = *prev_ap)\n\t{\n\t    int has_cmd = FALSE;\n\n\t    // loop over all commands for this pattern\n\t    prev_ac = &(ap->cmds);\n\t    for (ac = *prev_ac; ac != NULL; ac = *prev_ac)\n\t    {\n\t\t// remove the command if the pattern is to be deleted or when\n\t\t// the command has been marked for deletion\n\t\tif (ap->pat == NULL || ac->cmd == NULL)\n\t\t{\n\t\t    *prev_ac = ac->next;\n\t\t    vim_free(ac->cmd);\n\t\t    vim_free(ac);\n\t\t}\n\t\telse\n\t\t{\n\t\t    has_cmd = TRUE;\n\t\t    prev_ac = &(ac->next);\n\t\t}\n\t    }\n\n\t    if (ap->pat != NULL && !has_cmd)\n\t\t// Pattern was not marked for deletion, but all of its\n\t\t// commands were.  So mark the pattern for deletion.\n\t\tau_remove_pat(ap);\n\n\t    // remove the pattern if it has been marked for deletion\n\t    if (ap->pat == NULL)\n\t    {\n\t\tif (ap->next == NULL)\n\t\t{\n\t\t    if (prev_ap == &(first_autopat[(int)event]))\n\t\t\tlast_autopat[(int)event] = NULL;\n\t\t    else\n\t\t\t// this depends on the \"next\" field being the first in\n\t\t\t// the struct\n\t\t\tlast_autopat[(int)event] = (AutoPat *)prev_ap;\n\t\t}\n\t\t*prev_ap = ap->next;\n\t\tvim_regfree(ap->reg_prog);\n\t\tvim_free(ap);\n\t    }\n\t    else\n\t\tprev_ap = &(ap->next);\n\t}\n    }\n\n    au_need_clean = FALSE;\n}\n\n/*\n * Called when buffer is freed, to remove/invalidate related buffer-local\n * autocmds.\n */\n    void\naubuflocal_remove(buf_T *buf)\n{\n    AutoPat\t    *ap;\n    event_T\t    event;\n    AutoPatCmd_T    *apc;\n\n    // invalidate currently executing autocommands\n    for (apc = active_apc_list; apc; apc = apc->next)\n\tif (buf->b_fnum == apc->arg_bufnr)\n\t    apc->arg_bufnr = 0;\n\n    // invalidate buflocals looping through events\n    for (event = (event_T)0; (int)event < NUM_EVENTS;\n\t\t\t\t\t    event = (event_T)((int)event + 1))\n\t// loop over all autocommand patterns\n\tFOR_ALL_AUTOCMD_PATTERNS(event, ap)\n\t    if (ap->buflocal_nr == buf->b_fnum)\n\t    {\n\t\tau_remove_pat(ap);\n\t\tif (p_verbose >= 6)\n\t\t{\n\t\t    verbose_enter();\n\t\t    smsg(_(\"auto-removing autocommand: %s <buffer=%d>\"),\n\t\t\t\t\t   event_nr2name(event), buf->b_fnum);\n\t\t    verbose_leave();\n\t\t}\n\t    }\n    au_cleanup();\n}\n\n/*\n * Add an autocmd group name.\n * Return its ID.  Returns AUGROUP_ERROR (< 0) for error.\n */\n    static int\nau_new_group(char_u *name)\n{\n    int\t\ti;\n\n    i = au_find_group(name);\n    if (i == AUGROUP_ERROR)\t// the group doesn't exist yet, add it\n    {\n\t// First try using a free entry.\n\tfor (i = 0; i < augroups.ga_len; ++i)\n\t    if (AUGROUP_NAME(i) == NULL)\n\t\tbreak;\n\tif (i == augroups.ga_len && ga_grow(&augroups, 1) == FAIL)\n\t    return AUGROUP_ERROR;\n\n\tAUGROUP_NAME(i) = vim_strsave(name);\n\tif (AUGROUP_NAME(i) == NULL)\n\t    return AUGROUP_ERROR;\n\tif (i == augroups.ga_len)\n\t    ++augroups.ga_len;\n    }\n\n    return i;\n}\n\n    static void\nau_del_group(char_u *name)\n{\n    int\t    i;\n\n    i = au_find_group(name);\n    if (i == AUGROUP_ERROR)\t// the group doesn't exist\n\tsemsg(_(e_no_such_group_str), name);\n    else if (i == current_augroup)\n\temsg(_(e_cannot_delete_current_group));\n    else\n    {\n\tevent_T\tevent;\n\tAutoPat\t*ap;\n\tint\tin_use = FALSE;\n\n\tfor (event = (event_T)0; (int)event < NUM_EVENTS;\n\t\t\t\t\t    event = (event_T)((int)event + 1))\n\t{\n\t    FOR_ALL_AUTOCMD_PATTERNS(event, ap)\n\t\tif (ap->group == i && ap->pat != NULL)\n\t\t{\n\t\t    give_warning((char_u *)_(\"W19: Deleting augroup that is still in use\"), TRUE);\n\t\t    in_use = TRUE;\n\t\t    event = NUM_EVENTS;\n\t\t    break;\n\t\t}\n\t}\n\tvim_free(AUGROUP_NAME(i));\n\tif (in_use)\n\t    AUGROUP_NAME(i) = get_deleted_augroup();\n\telse\n\t    AUGROUP_NAME(i) = NULL;\n    }\n}\n\n/*\n * Find the ID of an autocmd group name.\n * Return its ID.  Returns AUGROUP_ERROR (< 0) for error.\n */\n    static int\nau_find_group(char_u *name)\n{\n    int\t    i;\n\n    for (i = 0; i < augroups.ga_len; ++i)\n\tif (AUGROUP_NAME(i) != NULL && AUGROUP_NAME(i) != get_deleted_augroup()\n\t\t&& STRCMP(AUGROUP_NAME(i), name) == 0)\n\t    return i;\n    return AUGROUP_ERROR;\n}\n\n/*\n * Return TRUE if augroup \"name\" exists.\n */\n    int\nau_has_group(char_u *name)\n{\n    return au_find_group(name) != AUGROUP_ERROR;\n}\n\n/*\n * \":augroup {name}\".\n */\n    void\ndo_augroup(char_u *arg, int del_group)\n{\n    int\t    i;\n\n    if (del_group)\n    {\n\tif (*arg == NUL)\n\t    emsg(_(e_argument_required));\n\telse\n\t    au_del_group(arg);\n    }\n    else if (STRICMP(arg, \"end\") == 0)   // \":aug end\": back to group 0\n\tcurrent_augroup = AUGROUP_DEFAULT;\n    else if (*arg)\t\t    // \":aug xxx\": switch to group xxx\n    {\n\ti = au_new_group(arg);\n\tif (i != AUGROUP_ERROR)\n\t    current_augroup = i;\n    }\n    else\t\t\t    // \":aug\": list the group names\n    {\n\tmsg_start();\n\tfor (i = 0; i < augroups.ga_len; ++i)\n\t{\n\t    if (AUGROUP_NAME(i) != NULL)\n\t    {\n\t\tmsg_puts((char *)AUGROUP_NAME(i));\n\t\tmsg_puts(\"  \");\n\t    }\n\t}\n\tmsg_clr_eos();\n\tmsg_end();\n    }\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_all_autocmds(void)\n{\n    int\t\ti;\n    char_u\t*s;\n\n    for (current_augroup = -1; current_augroup < augroups.ga_len;\n\t\t\t\t\t\t\t    ++current_augroup)\n\tdo_autocmd(NULL, (char_u *)\"\", TRUE);\n\n    for (i = 0; i < augroups.ga_len; ++i)\n    {\n\ts = ((char_u **)(augroups.ga_data))[i];\n\tif (s != get_deleted_augroup())\n\t    vim_free(s);\n    }\n    ga_clear(&augroups);\n}\n#endif\n\n/*\n * Return the event number for event name \"start\".\n * Return NUM_EVENTS if the event name was not found.\n * Return a pointer to the next event name in \"end\".\n */\n    static event_T\nevent_name2nr(char_u *start, char_u **end)\n{\n    char_u\t*p;\n    int\t\ti;\n    int\t\tlen;\n\n    // the event name ends with end of line, '|', a blank or a comma\n    for (p = start; *p && !VIM_ISWHITE(*p) && *p != ',' && *p != '|'; ++p)\n\t;\n    for (i = 0; event_names[i].name != NULL; ++i)\n    {\n\tlen = (int)STRLEN(event_names[i].name);\n\tif (len == p - start && STRNICMP(event_names[i].name, start, len) == 0)\n\t    break;\n    }\n    if (*p == ',')\n\t++p;\n    *end = p;\n    if (event_names[i].name == NULL)\n\treturn NUM_EVENTS;\n    return event_names[i].event;\n}\n\n/*\n * Return the name for event \"event\".\n */\n    static char_u *\nevent_nr2name(event_T event)\n{\n    int\t    i;\n\n    for (i = 0; event_names[i].name != NULL; ++i)\n\tif (event_names[i].event == event)\n\t    return (char_u *)event_names[i].name;\n    return (char_u *)\"Unknown\";\n}\n\n/*\n * Scan over the events.  \"*\" stands for all events.\n */\n    static char_u *\nfind_end_event(\n    char_u  *arg,\n    int\t    have_group)\t    // TRUE when group name was found\n{\n    char_u  *pat;\n    char_u  *p;\n\n    if (*arg == '*')\n    {\n\tif (arg[1] && !VIM_ISWHITE(arg[1]))\n\t{\n\t    semsg(_(e_illegal_character_after_star_str), arg);\n\t    return NULL;\n\t}\n\tpat = arg + 1;\n    }\n    else\n    {\n\tfor (pat = arg; *pat && *pat != '|' && !VIM_ISWHITE(*pat); pat = p)\n\t{\n\t    if ((int)event_name2nr(pat, &p) >= NUM_EVENTS)\n\t    {\n\t\tif (have_group)\n\t\t    semsg(_(e_no_such_event_str), pat);\n\t\telse\n\t\t    semsg(_(e_no_such_group_or_event_str), pat);\n\t\treturn NULL;\n\t    }\n\t}\n    }\n    return pat;\n}\n\n/*\n * Return TRUE if \"event\" is included in 'eventignore'.\n */\n    static int\nevent_ignored(event_T event)\n{\n    char_u\t*p = p_ei;\n\n    while (*p != NUL)\n    {\n\tif (STRNICMP(p, \"all\", 3) == 0 && (p[3] == NUL || p[3] == ','))\n\t    return TRUE;\n\tif (event_name2nr(p, &p) == event)\n\t    return TRUE;\n    }\n\n    return FALSE;\n}\n\n/*\n * Return OK when the contents of p_ei is valid, FAIL otherwise.\n */\n    int\ncheck_ei(void)\n{\n    char_u\t*p = p_ei;\n\n    while (*p)\n    {\n\tif (STRNICMP(p, \"all\", 3) == 0 && (p[3] == NUL || p[3] == ','))\n\t{\n\t    p += 3;\n\t    if (*p == ',')\n\t\t++p;\n\t}\n\telse if (event_name2nr(p, &p) == NUM_EVENTS)\n\t    return FAIL;\n    }\n\n    return OK;\n}\n\n# if defined(FEAT_SYN_HL) || defined(PROTO)\n\n/*\n * Add \"what\" to 'eventignore' to skip loading syntax highlighting for every\n * buffer loaded into the window.  \"what\" must start with a comma.\n * Returns the old value of 'eventignore' in allocated memory.\n */\n    char_u *\nau_event_disable(char *what)\n{\n    char_u\t*new_ei;\n    char_u\t*save_ei;\n\n    save_ei = vim_strsave(p_ei);\n    if (save_ei != NULL)\n    {\n\tnew_ei = vim_strnsave(p_ei, STRLEN(p_ei) + STRLEN(what));\n\tif (new_ei != NULL)\n\t{\n\t    if (*what == ',' && *p_ei == NUL)\n\t\tSTRCPY(new_ei, what + 1);\n\t    else\n\t\tSTRCAT(new_ei, what);\n\t    set_string_option_direct((char_u *)\"ei\", -1, new_ei,\n\t\t\t\t\t\t\t  OPT_FREE, SID_NONE);\n\t    vim_free(new_ei);\n\t}\n    }\n    return save_ei;\n}\n\n    void\nau_event_restore(char_u *old_ei)\n{\n    if (old_ei != NULL)\n    {\n\tset_string_option_direct((char_u *)\"ei\", -1, old_ei,\n\t\t\t\t\t\t\t  OPT_FREE, SID_NONE);\n\tvim_free(old_ei);\n    }\n}\n# endif  // FEAT_SYN_HL\n\n/*\n * do_autocmd() -- implements the :autocmd command.  Can be used in the\n *  following ways:\n *\n * :autocmd <event> <pat> <cmd>\t    Add <cmd> to the list of commands that\n *\t\t\t\t    will be automatically executed for <event>\n *\t\t\t\t    when editing a file matching <pat>, in\n *\t\t\t\t    the current group.\n * :autocmd <event> <pat>\t    Show the autocommands associated with\n *\t\t\t\t    <event> and <pat>.\n * :autocmd <event>\t\t    Show the autocommands associated with\n *\t\t\t\t    <event>.\n * :autocmd\t\t\t    Show all autocommands.\n * :autocmd! <event> <pat> <cmd>    Remove all autocommands associated with\n *\t\t\t\t    <event> and <pat>, and add the command\n *\t\t\t\t    <cmd>, for the current group.\n * :autocmd! <event> <pat>\t    Remove all autocommands associated with\n *\t\t\t\t    <event> and <pat> for the current group.\n * :autocmd! <event>\t\t    Remove all autocommands associated with\n *\t\t\t\t    <event> for the current group.\n * :autocmd!\t\t\t    Remove ALL autocommands for the current\n *\t\t\t\t    group.\n *\n *  Multiple events and patterns may be given separated by commas.  Here are\n *  some examples:\n * :autocmd bufread,bufenter *.c,*.h\tset tw=0 smartindent noic\n * :autocmd bufleave\t     *\t\tset tw=79 nosmartindent ic infercase\n *\n * :autocmd * *.c\t\tshow all autocommands for *.c files.\n *\n * Mostly a {group} argument can optionally appear before <event>.\n * \"eap\" can be NULL.\n */\n    void\ndo_autocmd(exarg_T *eap, char_u *arg_in, int forceit)\n{\n    char_u\t*arg = arg_in;\n    char_u\t*pat;\n    char_u\t*envpat = NULL;\n    char_u\t*cmd;\n    int\t\tcmd_need_free = FALSE;\n    event_T\tevent;\n    char_u\t*tofree = NULL;\n    int\t\tnested = FALSE;\n    int\t\tonce = FALSE;\n    int\t\tgroup;\n    int\t\ti;\n    int\t\tflags = 0;\n\n    if (*arg == '|')\n    {\n\teap->nextcmd = arg + 1;\n\targ = (char_u *)\"\";\n\tgroup = AUGROUP_ALL;\t// no argument, use all groups\n    }\n    else\n    {\n\t/*\n\t * Check for a legal group name.  If not, use AUGROUP_ALL.\n\t */\n\tgroup = au_get_grouparg(&arg);\n\tif (arg == NULL)\t    // out of memory\n\t    return;\n    }\n\n    /*\n     * Scan over the events.\n     * If we find an illegal name, return here, don't do anything.\n     */\n    pat = find_end_event(arg, group != AUGROUP_ALL);\n    if (pat == NULL)\n\treturn;\n\n    pat = skipwhite(pat);\n    if (*pat == '|')\n    {\n\teap->nextcmd = pat + 1;\n\tpat = (char_u *)\"\";\n\tcmd = (char_u *)\"\";\n    }\n    else\n    {\n\t/*\n\t * Scan over the pattern.  Put a NUL at the end.\n\t */\n\tcmd = pat;\n\twhile (*cmd && (!VIM_ISWHITE(*cmd) || cmd[-1] == '\\\\'))\n\t    cmd++;\n\tif (*cmd)\n\t    *cmd++ = NUL;\n\n\t// Expand environment variables in the pattern.  Set 'shellslash', we\n\t// want forward slashes here.\n\tif (vim_strchr(pat, '$') != NULL || vim_strchr(pat, '~') != NULL)\n\t{\n#ifdef BACKSLASH_IN_FILENAME\n\t    int\tp_ssl_save = p_ssl;\n\n\t    p_ssl = TRUE;\n#endif\n\t    envpat = expand_env_save(pat);\n#ifdef BACKSLASH_IN_FILENAME\n\t    p_ssl = p_ssl_save;\n#endif\n\t    if (envpat != NULL)\n\t\tpat = envpat;\n\t}\n\n\tcmd = skipwhite(cmd);\n\tfor (i = 0; i < 2; i++)\n\t{\n\t    if (*cmd != NUL)\n\t    {\n\t\t// Check for \"++once\" flag.\n\t\tif (STRNCMP(cmd, \"++once\", 6) == 0 && VIM_ISWHITE(cmd[6]))\n\t\t{\n\t\t    if (once)\n\t\t\tsemsg(_(e_duplicate_argument_str), \"++once\");\n\t\t    once = TRUE;\n\t\t    cmd = skipwhite(cmd + 6);\n\t\t}\n\n\t\t// Check for \"++nested\" flag.\n\t\tif ((STRNCMP(cmd, \"++nested\", 8) == 0 && VIM_ISWHITE(cmd[8])))\n\t\t{\n\t\t    if (nested)\n\t\t    {\n\t\t\tsemsg(_(e_duplicate_argument_str), \"++nested\");\n\t\t\treturn;\n\t\t    }\n\t\t    nested = TRUE;\n\t\t    cmd = skipwhite(cmd + 8);\n\t\t}\n\n\t\t// Check for the old \"nested\" flag in legacy script.\n\t\tif (STRNCMP(cmd, \"nested\", 6) == 0 && VIM_ISWHITE(cmd[6]))\n\t\t{\n\t\t    if (in_vim9script())\n\t\t    {\n\t\t\t// If there ever is a :nested command this error should\n\t\t\t// be removed and \"nested\" accepted as the start of the\n\t\t\t// command.\n\t\t\temsg(_(e_invalid_command_nested_did_you_mean_plusplus_nested));\n\t\t\treturn;\n\t\t    }\n\t\t    if (nested)\n\t\t    {\n\t\t\tsemsg(_(e_duplicate_argument_str), \"nested\");\n\t\t\treturn;\n\t\t    }\n\t\t    nested = TRUE;\n\t\t    cmd = skipwhite(cmd + 6);\n\t\t}\n\t    }\n\t}\n\n\t/*\n\t * Find the start of the commands.\n\t * Expand <sfile> in it.\n\t */\n\tif (*cmd != NUL)\n\t{\n\t    if (eap != NULL)\n\t\t// Read a {} block if it follows.\n\t\tcmd = may_get_cmd_block(eap, cmd, &tofree, &flags);\n\n\t    cmd = expand_sfile(cmd);\n\t    if (cmd == NULL)\t    // some error\n\t\treturn;\n\t    cmd_need_free = TRUE;\n\t}\n    }\n\n    /*\n     * Print header when showing autocommands.\n     */\n    if (!forceit && *cmd == NUL)\n\t// Highlight title\n\tmsg_puts_title(_(\"\\n--- Autocommands ---\"));\n\n    /*\n     * Loop over the events.\n     */\n    last_event = (event_T)-1;\t\t// for listing the event name\n    last_group = AUGROUP_ERROR;\t\t// for listing the group name\n    if (*arg == '*' || *arg == NUL || *arg == '|')\n    {\n\tif (*cmd != NUL)\n\t    emsg(_(e_cannot_define_autocommands_for_all_events));\n\telse\n\t    for (event = (event_T)0; (int)event < NUM_EVENTS;\n\t\t\t\t\t     event = (event_T)((int)event + 1))\n\t\tif (do_autocmd_event(event, pat,\n\t\t\t     once, nested, cmd, forceit, group, flags) == FAIL)\n\t\t    break;\n    }\n    else\n    {\n\twhile (*arg && *arg != '|' && !VIM_ISWHITE(*arg))\n\t    if (do_autocmd_event(event_name2nr(arg, &arg), pat,\n\t\t\t  once, nested,\tcmd, forceit, group, flags) == FAIL)\n\t\tbreak;\n    }\n\n    if (cmd_need_free)\n\tvim_free(cmd);\n    vim_free(tofree);\n    vim_free(envpat);\n}\n\n/*\n * Find the group ID in a \":autocmd\" or \":doautocmd\" argument.\n * The \"argp\" argument is advanced to the following argument.\n *\n * Returns the group ID, AUGROUP_ERROR for error (out of memory).\n */\n    static int\nau_get_grouparg(char_u **argp)\n{\n    char_u\t*group_name;\n    char_u\t*p;\n    char_u\t*arg = *argp;\n    int\t\tgroup = AUGROUP_ALL;\n\n    for (p = arg; *p && !VIM_ISWHITE(*p) && *p != '|'; ++p)\n\t;\n    if (p > arg)\n    {\n\tgroup_name = vim_strnsave(arg, p - arg);\n\tif (group_name == NULL)\t\t// out of memory\n\t    return AUGROUP_ERROR;\n\tgroup = au_find_group(group_name);\n\tif (group == AUGROUP_ERROR)\n\t    group = AUGROUP_ALL;\t// no match, use all groups\n\telse\n\t    *argp = skipwhite(p);\t// match, skip over group name\n\tvim_free(group_name);\n    }\n    return group;\n}\n\n/*\n * do_autocmd() for one event.\n * If *pat == NUL do for all patterns.\n * If *cmd == NUL show entries.\n * If forceit == TRUE delete entries.\n * If group is not AUGROUP_ALL, only use this group.\n */\n    static int\ndo_autocmd_event(\n    event_T\tevent,\n    char_u\t*pat,\n    int\t\tonce,\n    int\t\tnested,\n    char_u\t*cmd,\n    int\t\tforceit,\n    int\t\tgroup,\n    int\t\tflags)\n{\n    AutoPat\t*ap;\n    AutoPat\t**prev_ap;\n    AutoCmd\t*ac;\n    AutoCmd\t**prev_ac;\n    int\t\tbrace_level;\n    char_u\t*endpat;\n    int\t\tfindgroup;\n    int\t\tallgroups;\n    int\t\tpatlen;\n    int\t\tis_buflocal;\n    int\t\tbuflocal_nr;\n    char_u\tbuflocal_pat[25];\t// for \"<buffer=X>\"\n\n    if (group == AUGROUP_ALL)\n\tfindgroup = current_augroup;\n    else\n\tfindgroup = group;\n    allgroups = (group == AUGROUP_ALL && !forceit && *cmd == NUL);\n\n    /*\n     * Show or delete all patterns for an event.\n     */\n    if (*pat == NUL)\n    {\n\tFOR_ALL_AUTOCMD_PATTERNS(event, ap)\n\t{\n\t    if (forceit)  // delete the AutoPat, if it's in the current group\n\t    {\n\t\tif (ap->group == findgroup)\n\t\t    au_remove_pat(ap);\n\t    }\n\t    else if (group == AUGROUP_ALL || ap->group == group)\n\t\tshow_autocmd(ap, event);\n\t}\n    }\n\n    /*\n     * Loop through all the specified patterns.\n     */\n    for ( ; *pat; pat = (*endpat == ',' ? endpat + 1 : endpat))\n    {\n\t/*\n\t * Find end of the pattern.\n\t * Watch out for a comma in braces, like \"*.\\{obj,o\\}\".\n\t */\n\tbrace_level = 0;\n\tfor (endpat = pat; *endpat && (*endpat != ',' || brace_level\n\t\t\t   || (endpat > pat && endpat[-1] == '\\\\')); ++endpat)\n\t{\n\t    if (*endpat == '{')\n\t\tbrace_level++;\n\t    else if (*endpat == '}')\n\t\tbrace_level--;\n\t}\n\tif (pat == endpat)\t\t// ignore single comma\n\t    continue;\n\tpatlen = (int)(endpat - pat);\n\n\t/*\n\t * detect special <buflocal[=X]> buffer-local patterns\n\t */\n\tis_buflocal = FALSE;\n\tbuflocal_nr = 0;\n\n\tif (patlen >= 8 && STRNCMP(pat, \"<buffer\", 7) == 0\n\t\t\t\t\t\t    && pat[patlen - 1] == '>')\n\t{\n\t    // \"<buffer...>\": Error will be printed only for addition.\n\t    // printing and removing will proceed silently.\n\t    is_buflocal = TRUE;\n\t    if (patlen == 8)\n\t\t// \"<buffer>\"\n\t\tbuflocal_nr = curbuf->b_fnum;\n\t    else if (patlen > 9 && pat[7] == '=')\n\t    {\n\t\tif (patlen == 13 && STRNICMP(pat, \"<buffer=abuf>\", 13) == 0)\n\t\t    // \"<buffer=abuf>\"\n\t\t    buflocal_nr = autocmd_bufnr;\n\t\telse if (skipdigits(pat + 8) == pat + patlen - 1)\n\t\t    // \"<buffer=123>\"\n\t\t    buflocal_nr = atoi((char *)pat + 8);\n\t    }\n\t}\n\n\tif (is_buflocal)\n\t{\n\t    // normalize pat into standard \"<buffer>#N\" form\n\t    sprintf((char *)buflocal_pat, \"<buffer=%d>\", buflocal_nr);\n\t    pat = buflocal_pat;\t\t\t// can modify pat and patlen\n\t    patlen = (int)STRLEN(buflocal_pat);\t//   but not endpat\n\t}\n\n\t/*\n\t * Find AutoPat entries with this pattern.  When adding a command it\n\t * always goes at or after the last one, so start at the end.\n\t */\n\tif (!forceit && *cmd != NUL && last_autopat[(int)event] != NULL)\n\t    prev_ap = &last_autopat[(int)event];\n\telse\n\t    prev_ap = &first_autopat[(int)event];\n\twhile ((ap = *prev_ap) != NULL)\n\t{\n\t    if (ap->pat != NULL)\n\t    {\n\t\t/*\n\t\t * Accept a pattern when:\n\t\t * - a group was specified and it's that group, or a group was\n\t\t *   not specified and it's the current group, or a group was\n\t\t *   not specified and we are listing\n\t\t * - the length of the pattern matches\n\t\t * - the pattern matches.\n\t\t * For <buffer[=X]>, this condition works because we normalize\n\t\t * all buffer-local patterns.\n\t\t */\n\t\tif ((allgroups || ap->group == findgroup)\n\t\t\t&& ap->patlen == patlen\n\t\t\t&& STRNCMP(pat, ap->pat, patlen) == 0)\n\t\t{\n\t\t    /*\n\t\t     * Remove existing autocommands.\n\t\t     * If adding any new autocmd's for this AutoPat, don't\n\t\t     * delete the pattern from the autopat list, append to\n\t\t     * this list.\n\t\t     */\n\t\t    if (forceit)\n\t\t    {\n\t\t\tif (*cmd != NUL && ap->next == NULL)\n\t\t\t{\n\t\t\t    au_remove_cmds(ap);\n\t\t\t    break;\n\t\t\t}\n\t\t\tau_remove_pat(ap);\n\t\t    }\n\n\t\t    /*\n\t\t     * Show autocmd's for this autopat, or buflocals <buffer=X>\n\t\t     */\n\t\t    else if (*cmd == NUL)\n\t\t\tshow_autocmd(ap, event);\n\n\t\t    /*\n\t\t     * Add autocmd to this autopat, if it's the last one.\n\t\t     */\n\t\t    else if (ap->next == NULL)\n\t\t\tbreak;\n\t\t}\n\t    }\n\t    prev_ap = &ap->next;\n\t}\n\n\t/*\n\t * Add a new command.\n\t */\n\tif (*cmd != NUL)\n\t{\n\t    /*\n\t     * If the pattern we want to add a command to does appear at the\n\t     * end of the list (or not is not in the list at all), add the\n\t     * pattern at the end of the list.\n\t     */\n\t    if (ap == NULL)\n\t    {\n\t\t// refuse to add buffer-local ap if buffer number is invalid\n\t\tif (is_buflocal && (buflocal_nr == 0\n\t\t\t\t      || buflist_findnr(buflocal_nr) == NULL))\n\t\t{\n\t\t    semsg(_(e_buffer_nr_invalid_buffer_number), buflocal_nr);\n\t\t    return FAIL;\n\t\t}\n\n\t\tap = ALLOC_ONE(AutoPat);\n\t\tif (ap == NULL)\n\t\t    return FAIL;\n\t\tap->pat = vim_strnsave(pat, patlen);\n\t\tap->patlen = patlen;\n\t\tif (ap->pat == NULL)\n\t\t{\n\t\t    vim_free(ap);\n\t\t    return FAIL;\n\t\t}\n\n#ifdef FEAT_EVAL\n\t\t// need to initialize last_mode for the first ModeChanged\n\t\t// autocmd\n\t\tif (event == EVENT_MODECHANGED && !has_modechanged())\n\t\t    get_mode(last_mode);\n#endif\n\t\t// Initialize the fields checked by the WinScrolled trigger to\n\t\t// stop it from firing right after the first autocmd is defined.\n\t\tif (event == EVENT_WINSCROLLED && !has_winscrolled())\n\t\t{\n\t\t    curwin->w_last_topline = curwin->w_topline;\n\t\t    curwin->w_last_leftcol = curwin->w_leftcol;\n\t\t    curwin->w_last_width = curwin->w_width;\n\t\t    curwin->w_last_height = curwin->w_height;\n\t\t}\n\n\t\tif (is_buflocal)\n\t\t{\n\t\t    ap->buflocal_nr = buflocal_nr;\n\t\t    ap->reg_prog = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t    char_u\t*reg_pat;\n\n\t\t    ap->buflocal_nr = 0;\n\t\t    reg_pat = file_pat_to_reg_pat(pat, endpat,\n\t\t\t\t\t\t\t &ap->allow_dirs, TRUE);\n\t\t    if (reg_pat != NULL)\n\t\t\tap->reg_prog = vim_regcomp(reg_pat, RE_MAGIC);\n\t\t    vim_free(reg_pat);\n\t\t    if (reg_pat == NULL || ap->reg_prog == NULL)\n\t\t    {\n\t\t\tvim_free(ap->pat);\n\t\t\tvim_free(ap);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t}\n\t\tap->cmds = NULL;\n\t\t*prev_ap = ap;\n\t\tlast_autopat[(int)event] = ap;\n\t\tap->next = NULL;\n\t\tif (group == AUGROUP_ALL)\n\t\t    ap->group = current_augroup;\n\t\telse\n\t\t    ap->group = group;\n\t    }\n\n\t    /*\n\t     * Add the autocmd at the end of the AutoCmd list.\n\t     */\n\t    prev_ac = &(ap->cmds);\n\t    while ((ac = *prev_ac) != NULL)\n\t\tprev_ac = &ac->next;\n\t    ac = ALLOC_ONE(AutoCmd);\n\t    if (ac == NULL)\n\t\treturn FAIL;\n\t    ac->cmd = vim_strsave(cmd);\n\t    ac->script_ctx = current_sctx;\n\t    if (flags & UC_VIM9)\n\t\tac->script_ctx.sc_version = SCRIPT_VERSION_VIM9;\n#ifdef FEAT_EVAL\n\t    ac->script_ctx.sc_lnum += SOURCING_LNUM;\n#endif\n\t    if (ac->cmd == NULL)\n\t    {\n\t\tvim_free(ac);\n\t\treturn FAIL;\n\t    }\n\t    ac->next = NULL;\n\t    *prev_ac = ac;\n\t    ac->once = once;\n\t    ac->nested = nested;\n\t}\n    }\n\n    au_cleanup();\t// may really delete removed patterns/commands now\n    return OK;\n}\n\n/*\n * Implementation of \":doautocmd [group] event [fname]\".\n * Return OK for success, FAIL for failure;\n */\n    int\ndo_doautocmd(\n    char_u\t*arg_start,\n    int\t\tdo_msg,\t    // give message for no matching autocmds?\n    int\t\t*did_something)\n{\n    char_u\t*arg = arg_start;\n    char_u\t*fname;\n    int\t\tnothing_done = TRUE;\n    int\t\tgroup;\n\n    if (did_something != NULL)\n\t*did_something = FALSE;\n\n    /*\n     * Check for a legal group name.  If not, use AUGROUP_ALL.\n     */\n    group = au_get_grouparg(&arg);\n    if (arg == NULL)\t    // out of memory\n\treturn FAIL;\n\n    if (*arg == '*')\n    {\n\temsg(_(e_cant_execute_autocommands_for_all_events));\n\treturn FAIL;\n    }\n\n    /*\n     * Scan over the events.\n     * If we find an illegal name, return here, don't do anything.\n     */\n    fname = find_end_event(arg, group != AUGROUP_ALL);\n    if (fname == NULL)\n\treturn FAIL;\n\n    fname = skipwhite(fname);\n\n    /*\n     * Loop over the events.\n     */\n    while (*arg && !ends_excmd(*arg) && !VIM_ISWHITE(*arg))\n\tif (apply_autocmds_group(event_name2nr(arg, &arg),\n\t\t\t\t      fname, NULL, TRUE, group, curbuf, NULL))\n\t    nothing_done = FALSE;\n\n    if (nothing_done && do_msg\n#ifdef FEAT_EVAL\n\t\t&& !aborting()\n#endif\n\t       )\n\tsmsg(_(\"No matching autocommands: %s\"), arg_start);\n    if (did_something != NULL)\n\t*did_something = !nothing_done;\n\n#ifdef FEAT_EVAL\n    return aborting() ? FAIL : OK;\n#else\n    return OK;\n#endif\n}\n\n/*\n * \":doautoall\": execute autocommands for each loaded buffer.\n */\n    void\nex_doautoall(exarg_T *eap)\n{\n    int\t\tretval = OK;\n    aco_save_T\taco;\n    buf_T\t*buf;\n    bufref_T\tbufref;\n    char_u\t*arg = eap->arg;\n    int\t\tcall_do_modelines = check_nomodeline(&arg);\n    int\t\tdid_aucmd;\n\n    /*\n     * This is a bit tricky: For some commands curwin->w_buffer needs to be\n     * equal to curbuf, but for some buffers there may not be a window.\n     * So we change the buffer for the current window for a moment.  This\n     * gives problems when the autocommands make changes to the list of\n     * buffers or windows...\n     */\n    FOR_ALL_BUFFERS(buf)\n    {\n\t// Only do loaded buffers and skip the current buffer, it's done last.\n\tif (buf->b_ml.ml_mfp != NULL && buf != curbuf)\n\t{\n\t    // find a window for this buffer and save some values\n\t    aucmd_prepbuf(&aco, buf);\n\t    set_bufref(&bufref, buf);\n\n\t    // execute the autocommands for this buffer\n\t    retval = do_doautocmd(arg, FALSE, &did_aucmd);\n\n\t    if (call_do_modelines && did_aucmd)\n\t\t// Execute the modeline settings, but don't set window-local\n\t\t// options if we are using the current window for another\n\t\t// buffer.\n\t\tdo_modelines(curwin == aucmd_win ? OPT_NOWIN : 0);\n\n\t    // restore the current window\n\t    aucmd_restbuf(&aco);\n\n\t    // stop if there is some error or buffer was deleted\n\t    if (retval == FAIL || !bufref_valid(&bufref))\n\t    {\n\t\tretval = FAIL;\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    // Execute autocommands for the current buffer last.\n    if (retval == OK)\n    {\n\tdo_doautocmd(arg, FALSE, &did_aucmd);\n\tif (call_do_modelines && did_aucmd)\n\t    do_modelines(0);\n    }\n}\n\n/*\n * Check *argp for <nomodeline>.  When it is present return FALSE, otherwise\n * return TRUE and advance *argp to after it.\n * Thus return TRUE when do_modelines() should be called.\n */\n    int\ncheck_nomodeline(char_u **argp)\n{\n    if (STRNCMP(*argp, \"<nomodeline>\", 12) == 0)\n    {\n\t*argp = skipwhite(*argp + 12);\n\treturn FALSE;\n    }\n    return TRUE;\n}\n\n/*\n * Prepare for executing autocommands for (hidden) buffer \"buf\".\n * Search for a visible window containing the current buffer.  If there isn't\n * one then use \"aucmd_win\".\n * Set \"curbuf\" and \"curwin\" to match \"buf\".\n */\n    void\naucmd_prepbuf(\n    aco_save_T\t*aco,\t\t// structure to save values in\n    buf_T\t*buf)\t\t// new curbuf\n{\n    win_T\t*win;\n    int\t\tsave_ea;\n#ifdef FEAT_AUTOCHDIR\n    int\t\tsave_acd;\n#endif\n\n    // Find a window that is for the new buffer\n    if (buf == curbuf)\t\t// be quick when buf is curbuf\n\twin = curwin;\n    else\n\tFOR_ALL_WINDOWS(win)\n\t    if (win->w_buffer == buf)\n\t\tbreak;\n\n    // Allocate \"aucmd_win\" when needed.  If this fails (out of memory) fall\n    // back to using the current window.\n    if (win == NULL && aucmd_win == NULL)\n    {\n\taucmd_win = win_alloc_popup_win();\n\tif (aucmd_win == NULL)\n\t    win = curwin;\n    }\n    if (win == NULL && aucmd_win_used)\n\t// Strange recursive autocommand, fall back to using the current\n\t// window.  Expect a few side effects...\n\twin = curwin;\n\n    aco->save_curwin_id = curwin->w_id;\n    aco->save_curbuf = curbuf;\n    aco->save_prevwin_id = prevwin == NULL ? 0 : prevwin->w_id;\n    if (win != NULL)\n    {\n\t// There is a window for \"buf\" in the current tab page, make it the\n\t// curwin.  This is preferred, it has the least side effects (esp. if\n\t// \"buf\" is curbuf).\n\taco->use_aucmd_win = FALSE;\n\tcurwin = win;\n    }\n    else\n    {\n\t// There is no window for \"buf\", use \"aucmd_win\".  To minimize the side\n\t// effects, insert it in the current tab page.\n\t// Anything related to a window (e.g., setting folds) may have\n\t// unexpected results.\n\taco->use_aucmd_win = TRUE;\n\taucmd_win_used = TRUE;\n\n\twin_init_popup_win(aucmd_win, buf);\n\n\taco->globaldir = globaldir;\n\tglobaldir = NULL;\n\n\t// Split the current window, put the aucmd_win in the upper half.\n\t// We don't want the BufEnter or WinEnter autocommands.\n\tblock_autocmds();\n\tmake_snapshot(SNAP_AUCMD_IDX);\n\tsave_ea = p_ea;\n\tp_ea = FALSE;\n\n#ifdef FEAT_AUTOCHDIR\n\t// Prevent chdir() call in win_enter_ext(), through do_autochdir().\n\tsave_acd = p_acd;\n\tp_acd = FALSE;\n#endif\n\n\t// no redrawing and don't set the window title\n\t++RedrawingDisabled;\n\t(void)win_split_ins(0, WSP_TOP, aucmd_win, 0);\n\t--RedrawingDisabled;\n\t(void)win_comp_pos();   // recompute window positions\n\tp_ea = save_ea;\n#ifdef FEAT_AUTOCHDIR\n\tp_acd = save_acd;\n#endif\n\tunblock_autocmds();\n\tcurwin = aucmd_win;\n    }\n    curbuf = buf;\n    aco->new_curwin_id = curwin->w_id;\n    set_bufref(&aco->new_curbuf, curbuf);\n\n    // disable the Visual area, the position may be invalid in another buffer\n    aco->save_VIsual_active = VIsual_active;\n    VIsual_active = FALSE;\n}\n\n/*\n * Cleanup after executing autocommands for a (hidden) buffer.\n * Restore the window as it was (if possible).\n */\n    void\naucmd_restbuf(\n    aco_save_T\t*aco)\t\t// structure holding saved values\n{\n    int\t    dummy;\n    win_T   *save_curwin;\n\n    if (aco->use_aucmd_win)\n    {\n\t--curbuf->b_nwindows;\n\t// Find \"aucmd_win\", it can't be closed, but it may be in another tab\n\t// page. Do not trigger autocommands here.\n\tblock_autocmds();\n\tif (curwin != aucmd_win)\n\t{\n\t    tabpage_T\t*tp;\n\t    win_T\t*wp;\n\n\t    FOR_ALL_TAB_WINDOWS(tp, wp)\n\t    {\n\t\tif (wp == aucmd_win)\n\t\t{\n\t\t    if (tp != curtab)\n\t\t\tgoto_tabpage_tp(tp, TRUE, TRUE);\n\t\t    win_goto(aucmd_win);\n\t\t    goto win_found;\n\t\t}\n\t    }\n\t}\nwin_found:\n\n\t// Remove the window and frame from the tree of frames.\n\t(void)winframe_remove(curwin, &dummy, NULL);\n\twin_remove(curwin, NULL);\n\taucmd_win_used = FALSE;\n\tlast_status(FALSE);\t    // may need to remove last status line\n\n\tif (!valid_tabpage_win(curtab))\n\t    // no valid window in current tabpage\n\t    close_tabpage(curtab);\n\n\trestore_snapshot(SNAP_AUCMD_IDX, FALSE);\n\t(void)win_comp_pos();   // recompute window positions\n\tunblock_autocmds();\n\n\tsave_curwin = win_find_by_id(aco->save_curwin_id);\n\tif (save_curwin != NULL)\n\t    curwin = save_curwin;\n\telse\n\t    // Hmm, original window disappeared.  Just use the first one.\n\t    curwin = firstwin;\n\tcurbuf = curwin->w_buffer;\n#ifdef FEAT_JOB_CHANNEL\n\t// May need to restore insert mode for a prompt buffer.\n\tentering_window(curwin);\n#endif\n\tprevwin = win_find_by_id(aco->save_prevwin_id);\n#ifdef FEAT_EVAL\n\tvars_clear(&aucmd_win->w_vars->dv_hashtab);  // free all w: variables\n\thash_init(&aucmd_win->w_vars->dv_hashtab);   // re-use the hashtab\n#endif\n\tvim_free(globaldir);\n\tglobaldir = aco->globaldir;\n\n\t// the buffer contents may have changed\n\tcheck_cursor();\n\tif (curwin->w_topline > curbuf->b_ml.ml_line_count)\n\t{\n\t    curwin->w_topline = curbuf->b_ml.ml_line_count;\n#ifdef FEAT_DIFF\n\t    curwin->w_topfill = 0;\n#endif\n\t}\n#if defined(FEAT_GUI)\n\tif (gui.in_use)\n\t{\n\t    // Hide the scrollbars from the aucmd_win and update.\n\t    gui_mch_enable_scrollbar(\n\t\t\t\t   &aucmd_win->w_scrollbars[SBAR_LEFT], FALSE);\n\t    gui_mch_enable_scrollbar(\n\t\t\t\t  &aucmd_win->w_scrollbars[SBAR_RIGHT], FALSE);\n\t    gui_may_update_scrollbars();\n\t}\n#endif\n    }\n    else\n    {\n\t// Restore curwin.  Use the window ID, a window may have been closed\n\t// and the memory re-used for another one.\n\tsave_curwin = win_find_by_id(aco->save_curwin_id);\n\tif (save_curwin != NULL)\n\t{\n\t    // Restore the buffer which was previously edited by curwin, if\n\t    // it was changed, we are still the same window and the buffer is\n\t    // valid.\n\t    if (curwin->w_id == aco->new_curwin_id\n\t\t    && curbuf != aco->new_curbuf.br_buf\n\t\t    && bufref_valid(&aco->new_curbuf)\n\t\t    && aco->new_curbuf.br_buf->b_ml.ml_mfp != NULL)\n\t    {\n# if defined(FEAT_SYN_HL) || defined(FEAT_SPELL)\n\t\tif (curwin->w_s == &curbuf->b_s)\n\t\t    curwin->w_s = &aco->new_curbuf.br_buf->b_s;\n# endif\n\t\t--curbuf->b_nwindows;\n\t\tcurbuf = aco->new_curbuf.br_buf;\n\t\tcurwin->w_buffer = curbuf;\n\t\t++curbuf->b_nwindows;\n\t    }\n\n\t    curwin = save_curwin;\n\t    curbuf = curwin->w_buffer;\n\t    prevwin = win_find_by_id(aco->save_prevwin_id);\n\t    // In case the autocommand moves the cursor to a position that\n\t    // does not exist in curbuf.\n\t    check_cursor();\n\t}\n    }\n\n    check_cursor();\t    // just in case lines got deleted\n    VIsual_active = aco->save_VIsual_active;\n    if (VIsual_active)\n\tcheck_pos(curbuf, &VIsual);\n}\n\nstatic int\tautocmd_nested = FALSE;\n\n/*\n * Execute autocommands for \"event\" and file name \"fname\".\n * Return TRUE if some commands were executed.\n */\n    int\napply_autocmds(\n    event_T\tevent,\n    char_u\t*fname,\t    // NULL or empty means use actual file name\n    char_u\t*fname_io,  // fname to use for <afile> on cmdline\n    int\t\tforce,\t    // when TRUE, ignore autocmd_busy\n    buf_T\t*buf)\t    // buffer for <abuf>\n{\n    return apply_autocmds_group(event, fname, fname_io, force,\n\t\t\t\t\t\t      AUGROUP_ALL, buf, NULL);\n}\n\n/*\n * Like apply_autocmds(), but with extra \"eap\" argument.  This takes care of\n * setting v:filearg.\n */\n    int\napply_autocmds_exarg(\n    event_T\tevent,\n    char_u\t*fname,\n    char_u\t*fname_io,\n    int\t\tforce,\n    buf_T\t*buf,\n    exarg_T\t*eap)\n{\n    return apply_autocmds_group(event, fname, fname_io, force,\n\t\t\t\t\t\t       AUGROUP_ALL, buf, eap);\n}\n\n/*\n * Like apply_autocmds(), but handles the caller's retval.  If the script\n * processing is being aborted or if retval is FAIL when inside a try\n * conditional, no autocommands are executed.  If otherwise the autocommands\n * cause the script to be aborted, retval is set to FAIL.\n */\n    int\napply_autocmds_retval(\n    event_T\tevent,\n    char_u\t*fname,\t    // NULL or empty means use actual file name\n    char_u\t*fname_io,  // fname to use for <afile> on cmdline\n    int\t\tforce,\t    // when TRUE, ignore autocmd_busy\n    buf_T\t*buf,\t    // buffer for <abuf>\n    int\t\t*retval)    // pointer to caller's retval\n{\n    int\t\tdid_cmd;\n\n#ifdef FEAT_EVAL\n    if (should_abort(*retval))\n\treturn FALSE;\n#endif\n\n    did_cmd = apply_autocmds_group(event, fname, fname_io, force,\n\t\t\t\t\t\t      AUGROUP_ALL, buf, NULL);\n    if (did_cmd\n#ifdef FEAT_EVAL\n\t    && aborting()\n#endif\n\t    )\n\t*retval = FAIL;\n    return did_cmd;\n}\n\n/*\n * Return TRUE when there is a CursorHold autocommand defined.\n */\n    static int\nhas_cursorhold(void)\n{\n    return (first_autopat[(int)(get_real_state() == MODE_NORMAL_BUSY\n\t\t\t    ? EVENT_CURSORHOLD : EVENT_CURSORHOLDI)] != NULL);\n}\n\n/*\n * Return TRUE if the CursorHold event can be triggered.\n */\n    int\ntrigger_cursorhold(void)\n{\n    int\t\tstate;\n\n    if (!did_cursorhold\n\t    && has_cursorhold()\n\t    && reg_recording == 0\n\t    && typebuf.tb_len == 0\n\t    && !ins_compl_active())\n    {\n\tstate = get_real_state();\n\tif (state == MODE_NORMAL_BUSY || (state & MODE_INSERT) != 0)\n\t    return TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Return TRUE when there is a WinScrolled autocommand defined.\n */\n    int\nhas_winscrolled(void)\n{\n    return (first_autopat[(int)EVENT_WINSCROLLED] != NULL);\n}\n\n/*\n * Return TRUE when there is a CursorMoved autocommand defined.\n */\n    int\nhas_cursormoved(void)\n{\n    return (first_autopat[(int)EVENT_CURSORMOVED] != NULL);\n}\n\n/*\n * Return TRUE when there is a CursorMovedI autocommand defined.\n */\n    int\nhas_cursormovedI(void)\n{\n    return (first_autopat[(int)EVENT_CURSORMOVEDI] != NULL);\n}\n\n/*\n * Return TRUE when there is a TextChanged autocommand defined.\n */\n    int\nhas_textchanged(void)\n{\n    return (first_autopat[(int)EVENT_TEXTCHANGED] != NULL);\n}\n\n/*\n * Return TRUE when there is a TextChangedI autocommand defined.\n */\n    int\nhas_textchangedI(void)\n{\n    return (first_autopat[(int)EVENT_TEXTCHANGEDI] != NULL);\n}\n\n/*\n * Return TRUE when there is a TextChangedP autocommand defined.\n */\n    int\nhas_textchangedP(void)\n{\n    return (first_autopat[(int)EVENT_TEXTCHANGEDP] != NULL);\n}\n\n/*\n * Return TRUE when there is an InsertCharPre autocommand defined.\n */\n    int\nhas_insertcharpre(void)\n{\n    return (first_autopat[(int)EVENT_INSERTCHARPRE] != NULL);\n}\n\n/*\n * Return TRUE when there is an CmdUndefined autocommand defined.\n */\n    int\nhas_cmdundefined(void)\n{\n    return (first_autopat[(int)EVENT_CMDUNDEFINED] != NULL);\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE when there is a TextYankPost autocommand defined.\n */\n    int\nhas_textyankpost(void)\n{\n    return (first_autopat[(int)EVENT_TEXTYANKPOST] != NULL);\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE when there is a CompleteChanged autocommand defined.\n */\n    int\nhas_completechanged(void)\n{\n    return (first_autopat[(int)EVENT_COMPLETECHANGED] != NULL);\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE when there is a ModeChanged autocommand defined.\n */\n    int\nhas_modechanged(void)\n{\n    return (first_autopat[(int)EVENT_MODECHANGED] != NULL);\n}\n#endif\n\n/*\n * Execute autocommands for \"event\" and file name \"fname\".\n * Return TRUE if some commands were executed.\n */\n    static int\napply_autocmds_group(\n    event_T\tevent,\n    char_u\t*fname,\t     // NULL or empty means use actual file name\n    char_u\t*fname_io,   // fname to use for <afile> on cmdline, NULL means\n\t\t\t     // use fname\n    int\t\tforce,\t     // when TRUE, ignore autocmd_busy\n    int\t\tgroup,\t     // group ID, or AUGROUP_ALL\n    buf_T\t*buf,\t     // buffer for <abuf>\n    exarg_T\t*eap UNUSED) // command arguments\n{\n    char_u\t*sfname = NULL;\t// short file name\n    char_u\t*tail;\n    int\t\tsave_changed;\n    buf_T\t*old_curbuf;\n    int\t\tretval = FALSE;\n    char_u\t*save_autocmd_fname;\n    int\t\tsave_autocmd_fname_full;\n    int\t\tsave_autocmd_bufnr;\n    char_u\t*save_autocmd_match;\n    int\t\tsave_autocmd_busy;\n    int\t\tsave_autocmd_nested;\n    static int\tnesting = 0;\n    AutoPatCmd_T patcmd;\n    AutoPat\t*ap;\n    sctx_T\tsave_current_sctx;\n#ifdef FEAT_EVAL\n    funccal_entry_T funccal_entry;\n    char_u\t*save_cmdarg;\n    long\tsave_cmdbang;\n#endif\n    static int\tfilechangeshell_busy = FALSE;\n#ifdef FEAT_PROFILE\n    proftime_T\twait_time;\n#endif\n    int\t\tdid_save_redobuff = FALSE;\n    save_redo_T\tsave_redo;\n    int\t\tsave_KeyTyped = KeyTyped;\n    int\t\tsave_did_emsg;\n    ESTACK_CHECK_DECLARATION\n\n    /*\n     * Quickly return if there are no autocommands for this event or\n     * autocommands are blocked.\n     */\n    if (event == NUM_EVENTS || first_autopat[(int)event] == NULL\n\t    || autocmd_blocked > 0)\n\tgoto BYPASS_AU;\n\n    /*\n     * When autocommands are busy, new autocommands are only executed when\n     * explicitly enabled with the \"nested\" flag.\n     */\n    if (autocmd_busy && !(force || autocmd_nested))\n\tgoto BYPASS_AU;\n\n#ifdef FEAT_EVAL\n    /*\n     * Quickly return when immediately aborting on error, or when an interrupt\n     * occurred or an exception was thrown but not caught.\n     */\n    if (aborting())\n\tgoto BYPASS_AU;\n#endif\n\n    /*\n     * FileChangedShell never nests, because it can create an endless loop.\n     */\n    if (filechangeshell_busy && (event == EVENT_FILECHANGEDSHELL\n\t\t\t\t      || event == EVENT_FILECHANGEDSHELLPOST))\n\tgoto BYPASS_AU;\n\n    /*\n     * Ignore events in 'eventignore'.\n     */\n    if (event_ignored(event))\n\tgoto BYPASS_AU;\n\n    /*\n     * Allow nesting of autocommands, but restrict the depth, because it's\n     * possible to create an endless loop.\n     */\n    if (nesting == 10)\n    {\n\temsg(_(e_autocommand_nesting_too_deep));\n\tgoto BYPASS_AU;\n    }\n\n    /*\n     * Check if these autocommands are disabled.  Used when doing \":all\" or\n     * \":ball\".\n     */\n    if (       (autocmd_no_enter\n\t\t&& (event == EVENT_WINENTER || event == EVENT_BUFENTER))\n\t    || (autocmd_no_leave\n\t\t&& (event == EVENT_WINLEAVE || event == EVENT_BUFLEAVE)))\n\tgoto BYPASS_AU;\n\n    /*\n     * Save the autocmd_* variables and info about the current buffer.\n     */\n    save_autocmd_fname = autocmd_fname;\n    save_autocmd_fname_full = autocmd_fname_full;\n    save_autocmd_bufnr = autocmd_bufnr;\n    save_autocmd_match = autocmd_match;\n    save_autocmd_busy = autocmd_busy;\n    save_autocmd_nested = autocmd_nested;\n    save_changed = curbuf->b_changed;\n    old_curbuf = curbuf;\n\n    /*\n     * Set the file name to be used for <afile>.\n     * Make a copy to avoid that changing a buffer name or directory makes it\n     * invalid.\n     */\n    if (fname_io == NULL)\n    {\n\tif (event == EVENT_COLORSCHEME || event == EVENT_COLORSCHEMEPRE\n\t\t\t\t\t\t   || event == EVENT_OPTIONSET\n\t\t\t\t\t\t   || event == EVENT_MODECHANGED)\n\t    autocmd_fname = NULL;\n\telse if (fname != NULL && !ends_excmd(*fname))\n\t    autocmd_fname = fname;\n\telse if (buf != NULL)\n\t    autocmd_fname = buf->b_ffname;\n\telse\n\t    autocmd_fname = NULL;\n    }\n    else\n\tautocmd_fname = fname_io;\n    if (autocmd_fname != NULL)\n\tautocmd_fname = vim_strsave(autocmd_fname);\n    autocmd_fname_full = FALSE; // call FullName_save() later\n\n    /*\n     * Set the buffer number to be used for <abuf>.\n     */\n    if (buf == NULL)\n\tautocmd_bufnr = 0;\n    else\n\tautocmd_bufnr = buf->b_fnum;\n\n    /*\n     * When the file name is NULL or empty, use the file name of buffer \"buf\".\n     * Always use the full path of the file name to match with, in case\n     * \"allow_dirs\" is set.\n     */\n    if (fname == NULL || *fname == NUL)\n    {\n\tif (buf == NULL)\n\t    fname = NULL;\n\telse\n\t{\n#ifdef FEAT_SYN_HL\n\t    if (event == EVENT_SYNTAX)\n\t\tfname = buf->b_p_syn;\n\t    else\n#endif\n\t\tif (event == EVENT_FILETYPE)\n\t\t    fname = buf->b_p_ft;\n\t\telse\n\t\t{\n\t\t    if (buf->b_sfname != NULL)\n\t\t\tsfname = vim_strsave(buf->b_sfname);\n\t\t    fname = buf->b_ffname;\n\t\t}\n\t}\n\tif (fname == NULL)\n\t    fname = (char_u *)\"\";\n\tfname = vim_strsave(fname);\t// make a copy, so we can change it\n    }\n    else\n    {\n\tsfname = vim_strsave(fname);\n\t// Don't try expanding FileType, Syntax, FuncUndefined, WindowID,\n\t// ColorScheme, QuickFixCmd*, DirChanged and similar.\n\tif (event == EVENT_FILETYPE\n\t\t|| event == EVENT_SYNTAX\n\t\t|| event == EVENT_CMDLINECHANGED\n\t\t|| event == EVENT_CMDLINEENTER\n\t\t|| event == EVENT_CMDLINELEAVE\n\t\t|| event == EVENT_CMDWINENTER\n\t\t|| event == EVENT_CMDWINLEAVE\n\t\t|| event == EVENT_CMDUNDEFINED\n\t\t|| event == EVENT_FUNCUNDEFINED\n\t\t|| event == EVENT_REMOTEREPLY\n\t\t|| event == EVENT_SPELLFILEMISSING\n\t\t|| event == EVENT_QUICKFIXCMDPRE\n\t\t|| event == EVENT_COLORSCHEME\n\t\t|| event == EVENT_COLORSCHEMEPRE\n\t\t|| event == EVENT_OPTIONSET\n\t\t|| event == EVENT_QUICKFIXCMDPOST\n\t\t|| event == EVENT_DIRCHANGED\n\t\t|| event == EVENT_DIRCHANGEDPRE\n\t\t|| event == EVENT_MODECHANGED\n\t\t|| event == EVENT_USER\n\t\t|| event == EVENT_WINCLOSED\n\t\t|| event == EVENT_WINSCROLLED)\n\t{\n\t    fname = vim_strsave(fname);\n\t    autocmd_fname_full = TRUE; // don't expand it later\n\t}\n\telse\n\t    fname = FullName_save(fname, FALSE);\n    }\n    if (fname == NULL)\t    // out of memory\n    {\n\tvim_free(sfname);\n\tretval = FALSE;\n\tgoto BYPASS_AU;\n    }\n\n#ifdef BACKSLASH_IN_FILENAME\n    /*\n     * Replace all backslashes with forward slashes.  This makes the\n     * autocommand patterns portable between Unix and MS-DOS.\n     */\n    if (sfname != NULL)\n\tforward_slash(sfname);\n    forward_slash(fname);\n#endif\n\n#ifdef VMS\n    // remove version for correct match\n    if (sfname != NULL)\n\tvms_remove_version(sfname);\n    vms_remove_version(fname);\n#endif\n\n    /*\n     * Set the name to be used for <amatch>.\n     */\n    autocmd_match = fname;\n\n\n    // Don't redraw while doing autocommands.\n    ++RedrawingDisabled;\n\n    // name and lnum are filled in later\n    estack_push(ETYPE_AUCMD, NULL, 0);\n    ESTACK_CHECK_SETUP\n\n    save_current_sctx = current_sctx;\n\n#ifdef FEAT_EVAL\n# ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n\tprof_child_enter(&wait_time); // doesn't count for the caller itself\n# endif\n\n    // Don't use local function variables, if called from a function.\n    save_funccal(&funccal_entry);\n#endif\n\n    /*\n     * When starting to execute autocommands, save the search patterns.\n     */\n    if (!autocmd_busy)\n    {\n\tsave_search_patterns();\n\tif (!ins_compl_active())\n\t{\n\t    saveRedobuff(&save_redo);\n\t    did_save_redobuff = TRUE;\n\t}\n\tdid_filetype = keep_filetype;\n    }\n\n    /*\n     * Note that we are applying autocmds.  Some commands need to know.\n     */\n    autocmd_busy = TRUE;\n    filechangeshell_busy = (event == EVENT_FILECHANGEDSHELL);\n    ++nesting;\t\t// see matching decrement below\n\n    // Remember that FileType was triggered.  Used for did_filetype().\n    if (event == EVENT_FILETYPE)\n\tdid_filetype = TRUE;\n\n    tail = gettail(fname);\n\n    // Find first autocommand that matches\n    CLEAR_FIELD(patcmd);\n    patcmd.curpat = first_autopat[(int)event];\n    patcmd.group = group;\n    patcmd.fname = fname;\n    patcmd.sfname = sfname;\n    patcmd.tail = tail;\n    patcmd.event = event;\n    patcmd.arg_bufnr = autocmd_bufnr;\n    auto_next_pat(&patcmd, FALSE);\n\n    // found one, start executing the autocommands\n    if (patcmd.curpat != NULL)\n    {\n\t// add to active_apc_list\n\tpatcmd.next = active_apc_list;\n\tactive_apc_list = &patcmd;\n\n#ifdef FEAT_EVAL\n\t// set v:cmdarg (only when there is a matching pattern)\n\tsave_cmdbang = (long)get_vim_var_nr(VV_CMDBANG);\n\tif (eap != NULL)\n\t{\n\t    save_cmdarg = set_cmdarg(eap, NULL);\n\t    set_vim_var_nr(VV_CMDBANG, (long)eap->forceit);\n\t}\n\telse\n\t    save_cmdarg = NULL;\t// avoid gcc warning\n#endif\n\tretval = TRUE;\n\t// mark the last pattern, to avoid an endless loop when more patterns\n\t// are added when executing autocommands\n\tfor (ap = patcmd.curpat; ap->next != NULL; ap = ap->next)\n\t    ap->last = FALSE;\n\tap->last = TRUE;\n\n\t// Make sure cursor and topline are valid.  The first time the current\n\t// values are saved, restored by reset_lnums().  When nested only the\n\t// values are corrected when needed.\n\tif (nesting == 1)\n\t    check_lnums(TRUE);\n\telse\n\t    check_lnums_nested(TRUE);\n\n\tsave_did_emsg = did_emsg;\n\n\tdo_cmdline(NULL, getnextac, (void *)&patcmd,\n\t\t\t\t     DOCMD_NOWAIT|DOCMD_VERBOSE|DOCMD_REPEAT);\n\n\tdid_emsg += save_did_emsg;\n\n\tif (nesting == 1)\n\t    // restore cursor and topline, unless they were changed\n\t    reset_lnums();\n\n#ifdef FEAT_EVAL\n\tif (eap != NULL)\n\t{\n\t    (void)set_cmdarg(NULL, save_cmdarg);\n\t    set_vim_var_nr(VV_CMDBANG, save_cmdbang);\n\t}\n#endif\n\t// delete from active_apc_list\n\tif (active_apc_list == &patcmd)\t    // just in case\n\t    active_apc_list = patcmd.next;\n    }\n\n    --RedrawingDisabled;\n    autocmd_busy = save_autocmd_busy;\n    filechangeshell_busy = FALSE;\n    autocmd_nested = save_autocmd_nested;\n    vim_free(SOURCING_NAME);\n    ESTACK_CHECK_NOW\n    estack_pop();\n    vim_free(autocmd_fname);\n    autocmd_fname = save_autocmd_fname;\n    autocmd_fname_full = save_autocmd_fname_full;\n    autocmd_bufnr = save_autocmd_bufnr;\n    autocmd_match = save_autocmd_match;\n    current_sctx = save_current_sctx;\n#ifdef FEAT_EVAL\n    restore_funccal();\n# ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n\tprof_child_exit(&wait_time);\n# endif\n#endif\n    KeyTyped = save_KeyTyped;\n    vim_free(fname);\n    vim_free(sfname);\n    --nesting;\t\t// see matching increment above\n\n    /*\n     * When stopping to execute autocommands, restore the search patterns and\n     * the redo buffer.  Free any buffers in the au_pending_free_buf list and\n     * free any windows in the au_pending_free_win list.\n     */\n    if (!autocmd_busy)\n    {\n\trestore_search_patterns();\n\tif (did_save_redobuff)\n\t    restoreRedobuff(&save_redo);\n\tdid_filetype = FALSE;\n\twhile (au_pending_free_buf != NULL)\n\t{\n\t    buf_T *b = au_pending_free_buf->b_next;\n\n\t    vim_free(au_pending_free_buf);\n\t    au_pending_free_buf = b;\n\t}\n\twhile (au_pending_free_win != NULL)\n\t{\n\t    win_T *w = au_pending_free_win->w_next;\n\n\t    vim_free(au_pending_free_win);\n\t    au_pending_free_win = w;\n\t}\n    }\n\n    /*\n     * Some events don't set or reset the Changed flag.\n     * Check if still in the same buffer!\n     */\n    if (curbuf == old_curbuf\n\t    && (event == EVENT_BUFREADPOST\n\t\t|| event == EVENT_BUFWRITEPOST\n\t\t|| event == EVENT_FILEAPPENDPOST\n\t\t|| event == EVENT_VIMLEAVE\n\t\t|| event == EVENT_VIMLEAVEPRE))\n    {\n\tif (curbuf->b_changed != save_changed)\n\t    need_maketitle = TRUE;\n\tcurbuf->b_changed = save_changed;\n    }\n\n    au_cleanup();\t// may really delete removed patterns/commands now\n\nBYPASS_AU:\n    // When wiping out a buffer make sure all its buffer-local autocommands\n    // are deleted.\n    if (event == EVENT_BUFWIPEOUT && buf != NULL)\n\taubuflocal_remove(buf);\n\n    if (retval == OK && event == EVENT_FILETYPE)\n\tau_did_filetype = TRUE;\n\n    return retval;\n}\n\n# ifdef FEAT_EVAL\nstatic char_u\t*old_termresponse = NULL;\n# endif\n\n/*\n * Block triggering autocommands until unblock_autocmd() is called.\n * Can be used recursively, so long as it's symmetric.\n */\n    void\nblock_autocmds(void)\n{\n# ifdef FEAT_EVAL\n    // Remember the value of v:termresponse.\n    if (autocmd_blocked == 0)\n\told_termresponse = get_vim_var_str(VV_TERMRESPONSE);\n# endif\n    ++autocmd_blocked;\n}\n\n    void\nunblock_autocmds(void)\n{\n    --autocmd_blocked;\n\n# ifdef FEAT_EVAL\n    // When v:termresponse was set while autocommands were blocked, trigger\n    // the autocommands now.  Esp. useful when executing a shell command\n    // during startup (vimdiff).\n    if (autocmd_blocked == 0\n\t\t      && get_vim_var_str(VV_TERMRESPONSE) != old_termresponse)\n\tapply_autocmds(EVENT_TERMRESPONSE, NULL, NULL, FALSE, curbuf);\n# endif\n}\n\n    int\nis_autocmd_blocked(void)\n{\n    return autocmd_blocked != 0;\n}\n\n/*\n * Find next autocommand pattern that matches.\n */\n    static void\nauto_next_pat(\n    AutoPatCmd_T *apc,\n    int\t\tstop_at_last)\t    // stop when 'last' flag is set\n{\n    AutoPat\t*ap;\n    AutoCmd\t*cp;\n    char_u\t*name;\n    char\t*s;\n    estack_T\t*entry;\n    char_u\t*namep;\n\n    entry = ((estack_T *)exestack.ga_data) + exestack.ga_len - 1;\n\n    // Clear the exestack entry for this ETYPE_AUCMD entry.\n    VIM_CLEAR(entry->es_name);\n    entry->es_info.aucmd = NULL;\n\n    for (ap = apc->curpat; ap != NULL && !got_int; ap = ap->next)\n    {\n\tapc->curpat = NULL;\n\n\t// Only use a pattern when it has not been removed, has commands and\n\t// the group matches. For buffer-local autocommands only check the\n\t// buffer number.\n\tif (ap->pat != NULL && ap->cmds != NULL\n\t\t&& (apc->group == AUGROUP_ALL || apc->group == ap->group))\n\t{\n\t    // execution-condition\n\t    if (ap->buflocal_nr == 0\n\t\t    ? (match_file_pat(NULL, &ap->reg_prog, apc->fname,\n\t\t\t\t      apc->sfname, apc->tail, ap->allow_dirs))\n\t\t    : ap->buflocal_nr == apc->arg_bufnr)\n\t    {\n\t\tname = event_nr2name(apc->event);\n\t\ts = _(\"%s Autocommands for \\\"%s\\\"\");\n\t\tnamep = alloc(STRLEN(s) + STRLEN(name) + ap->patlen + 1);\n\t\tif (namep != NULL)\n\t\t{\n\t\t    sprintf((char *)namep, s, (char *)name, (char *)ap->pat);\n\t\t    if (p_verbose >= 8)\n\t\t    {\n\t\t\tverbose_enter();\n\t\t\tsmsg(_(\"Executing %s\"), namep);\n\t\t\tverbose_leave();\n\t\t    }\n\t\t}\n\n\t\t// Update the exestack entry for this autocmd.\n\t\tentry->es_name = namep;\n\t\tentry->es_info.aucmd = apc;\n\n\t\tapc->curpat = ap;\n\t\tapc->nextcmd = ap->cmds;\n\t\t// mark last command\n\t\tfor (cp = ap->cmds; cp->next != NULL; cp = cp->next)\n\t\t    cp->last = FALSE;\n\t\tcp->last = TRUE;\n\t    }\n\t    line_breakcheck();\n\t    if (apc->curpat != NULL)\t    // found a match\n\t\tbreak;\n\t}\n\tif (stop_at_last && ap->last)\n\t    break;\n    }\n}\n\n/*\n * Get the script context where autocommand \"acp\" is defined.\n */\n    sctx_T *\nacp_script_ctx(AutoPatCmd_T *acp)\n{\n    return &acp->script_ctx;\n}\n\n/*\n * Get next autocommand command.\n * Called by do_cmdline() to get the next line for \":if\".\n * Returns allocated string, or NULL for end of autocommands.\n */\n    char_u *\ngetnextac(\n\tint c UNUSED,\n\tvoid *cookie,\n\tint indent UNUSED,\n\tgetline_opt_T options UNUSED)\n{\n    AutoPatCmd_T    *acp = (AutoPatCmd_T *)cookie;\n    char_u\t    *retval;\n    AutoCmd\t    *ac;\n\n    // Can be called again after returning the last line.\n    if (acp->curpat == NULL)\n\treturn NULL;\n\n    // repeat until we find an autocommand to execute\n    for (;;)\n    {\n\t// skip removed commands\n\twhile (acp->nextcmd != NULL && acp->nextcmd->cmd == NULL)\n\t    if (acp->nextcmd->last)\n\t\tacp->nextcmd = NULL;\n\t    else\n\t\tacp->nextcmd = acp->nextcmd->next;\n\n\tif (acp->nextcmd != NULL)\n\t    break;\n\n\t// at end of commands, find next pattern that matches\n\tif (acp->curpat->last)\n\t    acp->curpat = NULL;\n\telse\n\t    acp->curpat = acp->curpat->next;\n\tif (acp->curpat != NULL)\n\t    auto_next_pat(acp, TRUE);\n\tif (acp->curpat == NULL)\n\t    return NULL;\n    }\n\n    ac = acp->nextcmd;\n\n    if (p_verbose >= 9)\n    {\n\tverbose_enter_scroll();\n\tsmsg(_(\"autocommand %s\"), ac->cmd);\n\tmsg_puts(\"\\n\");   // don't overwrite this either\n\tverbose_leave_scroll();\n    }\n    retval = vim_strsave(ac->cmd);\n    // Remove one-shot (\"once\") autocmd in anticipation of its execution.\n    if (ac->once)\n\tau_del_cmd(ac);\n    autocmd_nested = ac->nested;\n    current_sctx = ac->script_ctx;\n    acp->script_ctx = current_sctx;\n    if (ac->last)\n\tacp->nextcmd = NULL;\n    else\n\tacp->nextcmd = ac->next;\n    return retval;\n}\n\n/*\n * Return TRUE if there is a matching autocommand for \"fname\".\n * To account for buffer-local autocommands, function needs to know\n * in which buffer the file will be opened.\n */\n    int\nhas_autocmd(event_T event, char_u *sfname, buf_T *buf)\n{\n    AutoPat\t*ap;\n    char_u\t*fname;\n    char_u\t*tail = gettail(sfname);\n    int\t\tretval = FALSE;\n\n    fname = FullName_save(sfname, FALSE);\n    if (fname == NULL)\n\treturn FALSE;\n\n#ifdef BACKSLASH_IN_FILENAME\n    /*\n     * Replace all backslashes with forward slashes.  This makes the\n     * autocommand patterns portable between Unix and MS-DOS.\n     */\n    sfname = vim_strsave(sfname);\n    if (sfname != NULL)\n\tforward_slash(sfname);\n    forward_slash(fname);\n#endif\n\n    FOR_ALL_AUTOCMD_PATTERNS(event, ap)\n\tif (ap->pat != NULL && ap->cmds != NULL\n\t      && (ap->buflocal_nr == 0\n\t\t? match_file_pat(NULL, &ap->reg_prog,\n\t\t\t\t\t  fname, sfname, tail, ap->allow_dirs)\n\t\t: buf != NULL && ap->buflocal_nr == buf->b_fnum\n\t   ))\n\t{\n\t    retval = TRUE;\n\t    break;\n\t}\n\n    vim_free(fname);\n#ifdef BACKSLASH_IN_FILENAME\n    vim_free(sfname);\n#endif\n\n    return retval;\n}\n\n/*\n * Function given to ExpandGeneric() to obtain the list of autocommand group\n * names.\n */\n    char_u *\nget_augroup_name(expand_T *xp UNUSED, int idx)\n{\n    if (idx == augroups.ga_len)\t\t// add \"END\" add the end\n\treturn (char_u *)\"END\";\n    if (idx < 0 || idx >= augroups.ga_len)\t// end of list\n\treturn NULL;\n    if (AUGROUP_NAME(idx) == NULL || AUGROUP_NAME(idx) == get_deleted_augroup())\n\t// skip deleted entries\n\treturn (char_u *)\"\";\n    return AUGROUP_NAME(idx);\t\t// return a name\n}\n\nstatic int include_groups = FALSE;\n\n    char_u  *\nset_context_in_autocmd(\n    expand_T\t*xp,\n    char_u\t*arg,\n    int\t\tdoautocmd)\t// TRUE for :doauto*, FALSE for :autocmd\n{\n    char_u\t*p;\n    int\t\tgroup;\n\n    // check for a group name, skip it if present\n    include_groups = FALSE;\n    p = arg;\n    group = au_get_grouparg(&arg);\n    if (group == AUGROUP_ERROR)\n\treturn NULL;\n    // If there only is a group name that's what we expand.\n    if (*arg == NUL && group != AUGROUP_ALL && !VIM_ISWHITE(arg[-1]))\n    {\n\targ = p;\n\tgroup = AUGROUP_ALL;\n    }\n\n    // skip over event name\n    for (p = arg; *p != NUL && !VIM_ISWHITE(*p); ++p)\n\tif (*p == ',')\n\t    arg = p + 1;\n    if (*p == NUL)\n    {\n\tif (group == AUGROUP_ALL)\n\t    include_groups = TRUE;\n\txp->xp_context = EXPAND_EVENTS;\t    // expand event name\n\txp->xp_pattern = arg;\n\treturn NULL;\n    }\n\n    // skip over pattern\n    arg = skipwhite(p);\n    while (*arg && (!VIM_ISWHITE(*arg) || arg[-1] == '\\\\'))\n\targ++;\n    if (*arg)\n\treturn arg;\t\t\t    // expand (next) command\n\n    if (doautocmd)\n\txp->xp_context = EXPAND_FILES;\t    // expand file names\n    else\n\txp->xp_context = EXPAND_NOTHING;    // pattern is not expanded\n    return NULL;\n}\n\n/*\n * Function given to ExpandGeneric() to obtain the list of event names.\n */\n    char_u *\nget_event_name(expand_T *xp UNUSED, int idx)\n{\n    if (idx < augroups.ga_len)\t\t// First list group names, if wanted\n    {\n\tif (!include_groups || AUGROUP_NAME(idx) == NULL\n\t\t\t\t || AUGROUP_NAME(idx) == get_deleted_augroup())\n\t    return (char_u *)\"\";\t// skip deleted entries\n\treturn AUGROUP_NAME(idx);\t// return a name\n    }\n    return (char_u *)event_names[idx - augroups.ga_len].name;\n}\n\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if autocmd is supported.\n */\n    int\nautocmd_supported(char_u *name)\n{\n    char_u *p;\n\n    return (event_name2nr(name, &p) != NUM_EVENTS);\n}\n\n/*\n * Return TRUE if an autocommand is defined for a group, event and\n * pattern:  The group can be omitted to accept any group. \"event\" and \"pattern\"\n * can be NULL to accept any event and pattern. \"pattern\" can be NULL to accept\n * any pattern. Buffer-local patterns <buffer> or <buffer=N> are accepted.\n * Used for:\n *\texists(\"#Group\") or\n *\texists(\"#Group#Event\") or\n *\texists(\"#Group#Event#pat\") or\n *\texists(\"#Event\") or\n *\texists(\"#Event#pat\")\n */\n    int\nau_exists(char_u *arg)\n{\n    char_u\t*arg_save;\n    char_u\t*pattern = NULL;\n    char_u\t*event_name;\n    char_u\t*p;\n    event_T\tevent;\n    AutoPat\t*ap;\n    buf_T\t*buflocal_buf = NULL;\n    int\t\tgroup;\n    int\t\tretval = FALSE;\n\n    // Make a copy so that we can change the '#' chars to a NUL.\n    arg_save = vim_strsave(arg);\n    if (arg_save == NULL)\n\treturn FALSE;\n    p = vim_strchr(arg_save, '#');\n    if (p != NULL)\n\t*p++ = NUL;\n\n    // First, look for an autocmd group name\n    group = au_find_group(arg_save);\n    if (group == AUGROUP_ERROR)\n    {\n\t// Didn't match a group name, assume the first argument is an event.\n\tgroup = AUGROUP_ALL;\n\tevent_name = arg_save;\n    }\n    else\n    {\n\tif (p == NULL)\n\t{\n\t    // \"Group\": group name is present and it's recognized\n\t    retval = TRUE;\n\t    goto theend;\n\t}\n\n\t// Must be \"Group#Event\" or \"Group#Event#pat\".\n\tevent_name = p;\n\tp = vim_strchr(event_name, '#');\n\tif (p != NULL)\n\t    *p++ = NUL;\t    // \"Group#Event#pat\"\n    }\n\n    pattern = p;\t    // \"pattern\" is NULL when there is no pattern\n\n    // find the index (enum) for the event name\n    event = event_name2nr(event_name, &p);\n\n    // return FALSE if the event name is not recognized\n    if (event == NUM_EVENTS)\n\tgoto theend;\n\n    // Find the first autocommand for this event.\n    // If there isn't any, return FALSE;\n    // If there is one and no pattern given, return TRUE;\n    ap = first_autopat[(int)event];\n    if (ap == NULL)\n\tgoto theend;\n\n    // if pattern is \"<buffer>\", special handling is needed which uses curbuf\n    // for pattern \"<buffer=N>, fnamecmp() will work fine\n    if (pattern != NULL && STRICMP(pattern, \"<buffer>\") == 0)\n\tbuflocal_buf = curbuf;\n\n    // Check if there is an autocommand with the given pattern.\n    for ( ; ap != NULL; ap = ap->next)\n\t// only use a pattern when it has not been removed and has commands.\n\t// For buffer-local autocommands, fnamecmp() works fine.\n\tif (ap->pat != NULL && ap->cmds != NULL\n\t    && (group == AUGROUP_ALL || ap->group == group)\n\t    && (pattern == NULL\n\t\t|| (buflocal_buf == NULL\n\t\t    ? fnamecmp(ap->pat, pattern) == 0\n\t\t    : ap->buflocal_nr == buflocal_buf->b_fnum)))\n\t{\n\t    retval = TRUE;\n\t    break;\n\t}\n\ntheend:\n    vim_free(arg_save);\n    return retval;\n}\n\n/*\n * autocmd_add() and autocmd_delete() functions\n */\n    static void\nautocmd_add_or_delete(typval_T *argvars, typval_T *rettv, int delete)\n{\n    list_T\t*aucmd_list;\n    listitem_T\t*li;\n    dict_T\t*event_dict;\n    dictitem_T\t*di;\n    char_u\t*event_name = NULL;\n    list_T\t*event_list;\n    listitem_T\t*eli;\n    event_T\tevent;\n    char_u\t*group_name = NULL;\n    int\t\tgroup;\n    char_u\t*pat = NULL;\n    list_T\t*pat_list;\n    listitem_T\t*pli;\n    char_u\t*cmd = NULL;\n    char_u\t*end;\n    int\t\tonce;\n    int\t\tnested;\n    int\t\treplace;\t\t// replace the cmd for a group/event\n    int\t\tretval = VVAL_TRUE;\n    int\t\tsave_augroup = current_augroup;\n\n    rettv->v_type = VAR_BOOL;\n    rettv->vval.v_number = VVAL_FALSE;\n\n    if (check_for_list_arg(argvars, 0) == FAIL)\n\treturn;\n\n    aucmd_list = argvars[0].vval.v_list;\n    if (aucmd_list == NULL)\n\treturn;\n\n    FOR_ALL_LIST_ITEMS(aucmd_list, li)\n    {\n\tVIM_CLEAR(group_name);\n\tVIM_CLEAR(cmd);\n\tevent_name = NULL;\n\tevent_list = NULL;\n\tpat = NULL;\n\tpat_list = NULL;\n\n\tif (li->li_tv.v_type != VAR_DICT)\n\t    continue;\n\n\tevent_dict = li->li_tv.vval.v_dict;\n\tif (event_dict == NULL)\n\t    continue;\n\n\tdi = dict_find(event_dict, (char_u *)\"event\", -1);\n\tif (di != NULL)\n\t{\n\t    if (di->di_tv.v_type == VAR_STRING)\n\t    {\n\t\tevent_name = di->di_tv.vval.v_string;\n\t\tif (event_name == NULL)\n\t\t{\n\t\t    emsg(_(e_string_required));\n\t\t    continue;\n\t\t}\n\t    }\n\t    else if (di->di_tv.v_type == VAR_LIST)\n\t    {\n\t\tevent_list = di->di_tv.vval.v_list;\n\t\tif (event_list == NULL)\n\t\t{\n\t\t    emsg(_(e_list_required));\n\t\t    continue;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\temsg(_(e_string_or_list_expected));\n\t\tcontinue;\n\t    }\n\t}\n\n\tgroup_name = dict_get_string(event_dict, (char_u *)\"group\", TRUE);\n\tif (group_name == NULL || *group_name == NUL)\n\t    // if the autocmd group name is not specified, then use the current\n\t    // autocmd group\n\t    group = current_augroup;\n\telse\n\t{\n\t    group = au_find_group(group_name);\n\t    if (group == AUGROUP_ERROR)\n\t    {\n\t\tif (delete)\n\t\t{\n\t\t    semsg(_(e_no_such_group_str), group_name);\n\t\t    retval = VVAL_FALSE;\n\t\t    break;\n\t\t}\n\t\t// group is not found, create it now\n\t\tgroup = au_new_group(group_name);\n\t\tif (group == AUGROUP_ERROR)\n\t\t{\n\t\t    semsg(_(e_no_such_group_str), group_name);\n\t\t    retval = VVAL_FALSE;\n\t\t    break;\n\t\t}\n\n\t\tcurrent_augroup = group;\n\t    }\n\t}\n\n\t// if a buffer number is specified, then generate a pattern of the form\n\t// \"<buffer=n>. Otherwise, use the pattern supplied by the user.\n\tif (dict_has_key(event_dict, \"bufnr\"))\n\t{\n\t    varnumber_T\tbnum;\n\n\t    bnum = dict_get_number_def(event_dict, (char_u *)\"bufnr\", -1);\n\t    if (bnum == -1)\n\t\tcontinue;\n\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"<buffer=%d>\", (int)bnum);\n\t    pat = IObuff;\n\t}\n\telse\n\t{\n\t    di = dict_find(event_dict, (char_u *)\"pattern\", -1);\n\t    if (di != NULL)\n\t    {\n\t\tif (di->di_tv.v_type == VAR_STRING)\n\t\t{\n\t\t    pat = di->di_tv.vval.v_string;\n\t\t    if (pat == NULL)\n\t\t    {\n\t\t\temsg(_(e_string_required));\n\t\t\tcontinue;\n\t\t    }\n\t\t}\n\t\telse if (di->di_tv.v_type == VAR_LIST)\n\t\t{\n\t\t    pat_list = di->di_tv.vval.v_list;\n\t\t    if (pat_list == NULL)\n\t\t    {\n\t\t\temsg(_(e_list_required));\n\t\t\tcontinue;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    emsg(_(e_string_or_list_expected));\n\t\t    continue;\n\t\t}\n\t    }\n\t    else if (delete)\n\t\tpat = (char_u *)\"\";\n\t}\n\n\tonce = dict_get_bool(event_dict, (char_u *)\"once\", FALSE);\n\tnested = dict_get_bool(event_dict, (char_u *)\"nested\", FALSE);\n\t// if 'replace' is true, then remove all the commands associated with\n\t// this autocmd event/group and add the new command.\n\treplace = dict_get_bool(event_dict, (char_u *)\"replace\", FALSE);\n\n\tcmd = dict_get_string(event_dict, (char_u *)\"cmd\", TRUE);\n\tif (cmd == NULL)\n\t{\n\t    if (delete)\n\t\tcmd = vim_strsave((char_u *)\"\");\n\t    else\n\t\tcontinue;\n\t}\n\n\tif (delete && (event_name == NULL\n\t\t    || (event_name[0] == '*' && event_name[1] == NUL)))\n\t{\n\t    // if the event name is not specified or '*', delete all the events\n\t    for (event = (event_T)0; (int)event < NUM_EVENTS;\n\t\t    event = (event_T)((int)event + 1))\n\t    {\n\t\tif (do_autocmd_event(event, pat, once, nested, cmd, delete,\n\t\t\t\t\t\t\tgroup, 0) == FAIL)\n\t\t{\n\t\t    retval = VVAL_FALSE;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    char_u *p = NULL;\n\n\t    eli = NULL;\n\t    end = NULL;\n\t    while (TRUE)\n\t    {\n\t\tif (event_list != NULL)\n\t\t{\n\t\t    if (eli == NULL)\n\t\t\teli = event_list->lv_first;\n\t\t    else\n\t\t\teli = eli->li_next;\n\t\t    if (eli == NULL)\n\t\t\tbreak;\n\t\t    if (eli->li_tv.v_type != VAR_STRING\n\t\t\t    || (p = eli->li_tv.vval.v_string) == NULL)\n\t\t    {\n\t\t\temsg(_(e_string_required));\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (p == NULL)\n\t\t\tp = event_name;\n\t\t    if (p == NULL || *p == NUL)\n\t\t\tbreak;\n\t\t}\n\n\t\tevent = event_name2nr(p, &end);\n\t\tif (event == NUM_EVENTS || *end != NUL)\n\t\t{\n\t\t    // this also catches something following a valid event name\n\t\t    semsg(_(e_no_such_event_str), p);\n\t\t    retval = VVAL_FALSE;\n\t\t    break;\n\t\t}\n\t\tif (pat != NULL)\n\t\t{\n\t\t    if (do_autocmd_event(event, pat, once, nested, cmd,\n\t\t\t\tdelete | replace, group, 0) == FAIL)\n\t\t    {\n\t\t\tretval = VVAL_FALSE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\telse if (pat_list != NULL)\n\t\t{\n\t\t    FOR_ALL_LIST_ITEMS(pat_list, pli)\n\t\t    {\n\t\t\tif (pli->li_tv.v_type != VAR_STRING\n\t\t\t\t|| pli->li_tv.vval.v_string == NULL)\n\t\t\t{\n\t\t\t    emsg(_(e_string_required));\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (do_autocmd_event(event,\n\t\t\t\t    pli->li_tv.vval.v_string, once, nested,\n\t\t\t\t    cmd, delete | replace, group, 0) ==\n\t\t\t\tFAIL)\n\t\t\t{\n\t\t\t    retval = VVAL_FALSE;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    if (retval == VVAL_FALSE)\n\t\t\tbreak;\n\t\t}\n\t\tif (event_name != NULL)\n\t\t    p = end;\n\t    }\n\t}\n\n\t// if only the autocmd group name is specified for delete and the\n\t// autocmd event, pattern and cmd are not specified, then delete the\n\t// autocmd group.\n\tif (delete && group_name != NULL &&\n\t\t(event_name == NULL || event_name[0] == NUL)\n\t\t&& (pat == NULL || pat[0] == NUL)\n\t\t&& (cmd == NULL || cmd[0] == NUL))\n\t    au_del_group(group_name);\n    }\n\n    VIM_CLEAR(group_name);\n    VIM_CLEAR(cmd);\n\n    current_augroup = save_augroup;\n    rettv->vval.v_number = retval;\n}\n\n/*\n * autocmd_add() function\n */\n    void\nf_autocmd_add(typval_T *argvars, typval_T *rettv)\n{\n    autocmd_add_or_delete(argvars, rettv, FALSE);\n}\n\n/*\n * autocmd_delete() function\n */\n    void\nf_autocmd_delete(typval_T *argvars, typval_T *rettv)\n{\n    autocmd_add_or_delete(argvars, rettv, TRUE);\n}\n\n/*\n * autocmd_get() function\n * Returns a List of autocmds.\n */\n    void\nf_autocmd_get(typval_T *argvars, typval_T *rettv)\n{\n    event_T\tevent_arg = NUM_EVENTS;\n    event_T\tevent;\n    AutoPat\t*ap;\n    AutoCmd\t*ac;\n    list_T\t*event_list;\n    dict_T\t*event_dict;\n    char_u\t*event_name = NULL;\n    char_u\t*pat = NULL;\n    char_u\t*name = NULL;\n    int\t\tgroup = AUGROUP_ALL;\n\n    if (rettv_list_alloc(rettv) == FAIL)\n\treturn;\n    if (check_for_opt_dict_arg(argvars, 0) == FAIL)\n\treturn;\n\n    if (argvars[0].v_type == VAR_DICT)\n    {\n\t// return only the autocmds in the specified group\n\tif (dict_has_key(argvars[0].vval.v_dict, \"group\"))\n\t{\n\t    name = dict_get_string(argvars[0].vval.v_dict,\n\t\t\t\t\t\t      (char_u *)\"group\", TRUE);\n\t    if (name == NULL)\n\t\treturn;\n\n\t    if (*name == NUL)\n\t\tgroup = AUGROUP_DEFAULT;\n\t    else\n\t    {\n\t\tgroup = au_find_group(name);\n\t\tif (group == AUGROUP_ERROR)\n\t\t{\n\t\t    semsg(_(e_no_such_group_str), name);\n\t\t    vim_free(name);\n\t\t    return;\n\t\t}\n\t    }\n\t    vim_free(name);\n\t}\n\n\t// return only the autocmds for the specified event\n\tif (dict_has_key(argvars[0].vval.v_dict, \"event\"))\n\t{\n\t    int\t\ti;\n\n\t    name = dict_get_string(argvars[0].vval.v_dict,\n\t\t\t\t\t\t      (char_u *)\"event\", TRUE);\n\t    if (name == NULL)\n\t\treturn;\n\n\t    if (name[0] == '*' && name[1] == NUL)\n\t\tevent_arg = NUM_EVENTS;\n\t    else\n\t    {\n\t\tfor (i = 0; event_names[i].name != NULL; i++)\n\t\t    if (STRICMP(event_names[i].name, name) == 0)\n\t\t\tbreak;\n\t\tif (event_names[i].name == NULL)\n\t\t{\n\t\t    semsg(_(e_no_such_event_str), name);\n\t\t    vim_free(name);\n\t\t    return;\n\t\t}\n\t\tevent_arg = event_names[i].event;\n\t    }\n\t    vim_free(name);\n\t}\n\n\t// return only the autocmds for the specified pattern\n\tif (dict_has_key(argvars[0].vval.v_dict, \"pattern\"))\n\t{\n\t    pat = dict_get_string(argvars[0].vval.v_dict,\n\t\t\t\t\t\t    (char_u *)\"pattern\", TRUE);\n\t    if (pat == NULL)\n\t\treturn;\n\t}\n    }\n\n    event_list = rettv->vval.v_list;\n\n    // iterate through all the autocmd events\n    for (event = (event_T)0; (int)event < NUM_EVENTS;\n\t    event = (event_T)((int)event + 1))\n    {\n\tif (event_arg != NUM_EVENTS && event != event_arg)\n\t    continue;\n\n\tevent_name = event_nr2name(event);\n\n\t// iterate through all the patterns for this autocmd event\n\tFOR_ALL_AUTOCMD_PATTERNS(event, ap)\n\t{\n\t    char_u\t*group_name;\n\n\t    if (group != AUGROUP_ALL && group != ap->group)\n\t\tcontinue;\n\n\t    if (pat != NULL && STRCMP(pat, ap->pat) != 0)\n\t\tcontinue;\n\n\t    group_name = get_augroup_name(NULL, ap->group);\n\n\t    // iterate through all the commands for this pattern and add one\n\t    // item for each cmd.\n\t    for (ac = ap->cmds; ac != NULL; ac = ac->next)\n\t    {\n\t\tevent_dict = dict_alloc();\n\t\tif (event_dict == NULL\n\t\t\t|| list_append_dict(event_list, event_dict) == FAIL)\n\t\t    return;\n\n\t\tif (dict_add_string(event_dict, \"event\", event_name) == FAIL\n\t\t\t|| dict_add_string(event_dict, \"group\",\n\t\t\t\t\tgroup_name == NULL ? (char_u *)\"\"\n\t\t\t\t\t\t\t  : group_name) == FAIL\n\t\t\t|| (ap->buflocal_nr != 0\n\t\t\t\t&& (dict_add_number(event_dict, \"bufnr\",\n\t\t\t\t\t\t    ap->buflocal_nr) == FAIL))\n\t\t\t|| dict_add_string(event_dict, \"pattern\",\n\t\t\t\t\t\t\t      ap->pat) == FAIL\n\t\t\t|| dict_add_string(event_dict, \"cmd\", ac->cmd) == FAIL\n\t\t\t|| dict_add_bool(event_dict, \"once\", ac->once) == FAIL\n\t\t\t|| dict_add_bool(event_dict, \"nested\",\n\t\t\t\t\t\t\t   ac->nested) == FAIL)\n\t\t    return;\n\t    }\n\t}\n    }\n\n    vim_free(pat);\n}\n\n#endif\n", "/* window.c */\nwin_T *prevwin_curwin(void);\nvoid do_window(int nchar, long Prenum, int xchar);\nvoid get_wincmd_addr_type(char_u *arg, exarg_T *eap);\nint win_split(int size, int flags);\nint win_split_ins(int size, int flags, win_T *new_wp, int dir);\nint win_valid_popup(win_T *win);\nint win_valid(win_T *win);\nwin_T *win_find_by_id(int id);\nint win_valid_any_tab(win_T *win);\nint win_count(void);\nint make_windows(int count, int vertical);\nvoid win_move_after(win_T *win1, win_T *win2);\nvoid win_equal(win_T *next_curwin, int current, int dir);\nvoid entering_window(win_T *win);\nvoid curwin_init(void);\nvoid close_windows(buf_T *buf, int keep_curwin);\nint one_window(void);\nint win_close(win_T *win, int free_buf);\nvoid may_trigger_winscrolled(void);\nvoid win_close_othertab(win_T *win, int free_buf, tabpage_T *tp);\nvoid win_free_all(void);\nwin_T *winframe_remove(win_T *win, int *dirp, tabpage_T *tp);\nvoid close_others(int message, int forceit);\nint win_alloc_first(void);\nwin_T *win_alloc_popup_win(void);\nvoid win_init_popup_win(win_T *wp, buf_T *buf);\nvoid win_init_size(void);\nvoid free_tabpage(tabpage_T *tp);\nint win_new_tabpage(int after);\nint make_tabpages(int maxcount);\nint valid_tabpage(tabpage_T *tpc);\nint valid_tabpage_win(tabpage_T *tpc);\nvoid close_tabpage(tabpage_T *tab);\ntabpage_T *find_tabpage(int n);\nint tabpage_index(tabpage_T *ftp);\nvoid goto_tabpage(int n);\nvoid goto_tabpage_tp(tabpage_T *tp, int trigger_enter_autocmds, int trigger_leave_autocmds);\nint goto_tabpage_lastused(void);\nvoid goto_tabpage_win(tabpage_T *tp, win_T *wp);\nvoid tabpage_move(int nr);\nvoid win_goto(win_T *wp);\nwin_T *win_find_nr(int winnr);\ntabpage_T *win_find_tabpage(win_T *win);\nwin_T *win_vert_neighbor(tabpage_T *tp, win_T *wp, int up, long count);\nwin_T *win_horz_neighbor(tabpage_T *tp, win_T *wp, int left, long count);\nvoid win_enter(win_T *wp, int undo_sync);\nwin_T *buf_jump_open_win(buf_T *buf);\nwin_T *buf_jump_open_tab(buf_T *buf);\nint win_unlisted(win_T *wp);\nvoid win_free_popup(win_T *win);\nvoid win_remove(win_T *wp, tabpage_T *tp);\nint win_alloc_lines(win_T *wp);\nvoid win_free_lsize(win_T *wp);\nvoid shell_new_rows(void);\nvoid shell_new_columns(void);\nvoid win_size_save(garray_T *gap);\nvoid win_size_restore(garray_T *gap);\nint win_comp_pos(void);\nvoid win_ensure_size(void);\nvoid win_setheight(int height);\nvoid win_setheight_win(int height, win_T *win);\nvoid win_setwidth(int width);\nvoid win_setwidth_win(int width, win_T *wp);\nvoid win_setminheight(void);\nvoid win_setminwidth(void);\nvoid win_drag_status_line(win_T *dragwin, int offset);\nvoid win_drag_vsep_line(win_T *dragwin, int offset);\nvoid set_fraction(win_T *wp);\nvoid win_new_height(win_T *wp, int height);\nvoid scroll_to_fraction(win_T *wp, int prev_height);\nvoid win_new_width(win_T *wp, int width);\nvoid win_comp_scroll(win_T *wp);\nvoid command_height(void);\nvoid last_status(int morewin);\nint tabline_height(void);\nint min_rows(void);\nint only_one_window(void);\nvoid check_lnums(int do_curwin);\nvoid check_lnums_nested(int do_curwin);\nvoid reset_lnums(void);\nvoid make_snapshot(int idx);\nvoid restore_snapshot(int idx, int close_curwin);\nint win_hasvertsplit(void);\nint get_win_number(win_T *wp, win_T *first_win);\nint get_tab_number(tabpage_T *tp);\nchar *check_colorcolumn(win_T *wp);\n/* vim: set ft=c : */\n", "\" Tests for autocommands\n\nsource shared.vim\nsource check.vim\nsource term_util.vim\nsource screendump.vim\nimport './vim9.vim' as v9\n\nfunc s:cleanup_buffers() abort\n  for bnr in range(1, bufnr('$'))\n    if bufloaded(bnr) && bufnr('%') != bnr\n      execute 'bd! ' . bnr\n    endif\n  endfor\nendfunc\n\nfunc Test_vim_did_enter()\n  call assert_false(v:vim_did_enter)\n\n  \" This script will never reach the main loop, can't check if v:vim_did_enter\n  \" becomes one.\nendfunc\n\n\" Test for the CursorHold autocmd\nfunc Test_CursorHold_autocmd()\n  CheckRunVimInTerminal\n  call writefile(['one', 'two', 'three'], 'Xfile')\n  let before =<< trim END\n    set updatetime=10\n    au CursorHold * call writefile([line('.')], 'Xoutput', 'a')\n  END\n  call writefile(before, 'Xinit')\n  let buf = RunVimInTerminal('-S Xinit Xfile', {})\n  call term_sendkeys(buf, \"G\")\n  call term_wait(buf, 50)\n  call term_sendkeys(buf, \"gg\")\n  call term_wait(buf)\n  call WaitForAssert({-> assert_equal(['1'], readfile('Xoutput')[-1:-1])})\n  call term_sendkeys(buf, \"j\")\n  call term_wait(buf)\n  call WaitForAssert({-> assert_equal(['1', '2'], readfile('Xoutput')[-2:-1])})\n  call term_sendkeys(buf, \"j\")\n  call term_wait(buf)\n  call WaitForAssert({-> assert_equal(['1', '2', '3'], readfile('Xoutput')[-3:-1])})\n  call StopVimInTerminal(buf)\n\n  call delete('Xinit')\n  call delete('Xoutput')\n  call delete('Xfile')\nendfunc\n\nif has('timers')\n\n  func ExitInsertMode(id)\n    call feedkeys(\"\\<Esc>\")\n  endfunc\n\n  func Test_cursorhold_insert()\n    \" Need to move the cursor.\n    call feedkeys(\"ggG\", \"xt\")\n\n    let g:triggered = 0\n    au CursorHoldI * let g:triggered += 1\n    set updatetime=20\n    call timer_start(200, 'ExitInsertMode')\n    call feedkeys('a', 'x!')\n    call assert_equal(1, g:triggered)\n    unlet g:triggered\n    au! CursorHoldI\n    set updatetime&\n  endfunc\n\n  func Test_cursorhold_insert_with_timer_interrupt()\n    CheckFeature job\n    \" Need to move the cursor.\n    call feedkeys(\"ggG\", \"xt\")\n\n    \" Confirm the timer invoked in exit_cb of the job doesn't disturb\n    \" CursorHoldI event.\n    let g:triggered = 0\n    au CursorHoldI * let g:triggered += 1\n    set updatetime=100\n    call job_start(has('win32') ? 'cmd /c echo:' : 'echo',\n          \\ {'exit_cb': {-> timer_start(200, 'ExitInsertMode')}})\n    call feedkeys('a', 'x!')\n    call assert_equal(1, g:triggered)\n    unlet g:triggered\n    au! CursorHoldI\n    set updatetime&\n  endfunc\n\n  func Test_cursorhold_insert_ctrl_x()\n    let g:triggered = 0\n    au CursorHoldI * let g:triggered += 1\n    set updatetime=20\n    call timer_start(100, 'ExitInsertMode')\n    \" CursorHoldI does not trigger after CTRL-X\n    call feedkeys(\"a\\<C-X>\", 'x!')\n    call assert_equal(0, g:triggered)\n    unlet g:triggered\n    au! CursorHoldI\n    set updatetime&\n  endfunc\n\n  func Test_cursorhold_insert_ctrl_g_U()\n    au CursorHoldI * :\n    set updatetime=20\n    new\n    call timer_start(100, { -> feedkeys(\"\\<Left>foo\\<Esc>\", 't') })\n    call feedkeys(\"i()\\<C-g>U\", 'tx!')\n    sleep 200m\n    call assert_equal('(foo)', getline(1))\n    undo\n    call assert_equal('', getline(1))\n\n    bwipe!\n    au! CursorHoldI\n    set updatetime&\n  endfunc\n\n  func Test_OptionSet_modeline()\n    call test_override('starting', 1)\n    au! OptionSet\n    augroup set_tabstop\n      au OptionSet tabstop call timer_start(1, {-> execute(\"echo 'Handler called'\", \"\")})\n    augroup END\n    call writefile(['vim: set ts=7 sw=5 :', 'something'], 'XoptionsetModeline')\n    set modeline\n    let v:errmsg = ''\n    call assert_fails('split XoptionsetModeline', 'E12:')\n    call assert_equal(7, &ts)\n    call assert_equal('', v:errmsg)\n\n    augroup set_tabstop\n      au!\n    augroup END\n    bwipe!\n    set ts&\n    call delete('XoptionsetModeline')\n    call test_override('starting', 0)\n  endfunc\n\nendif \"has('timers')\n\nfunc Test_bufunload()\n  augroup test_bufunload_group\n    autocmd!\n    autocmd BufUnload * call add(s:li, \"bufunload\")\n    autocmd BufDelete * call add(s:li, \"bufdelete\")\n    autocmd BufWipeout * call add(s:li, \"bufwipeout\")\n  augroup END\n\n  let s:li = []\n  new\n  setlocal bufhidden=\n  bunload\n  call assert_equal([\"bufunload\", \"bufdelete\"], s:li)\n\n  let s:li = []\n  new\n  setlocal bufhidden=delete\n  bunload\n  call assert_equal([\"bufunload\", \"bufdelete\"], s:li)\n\n  let s:li = []\n  new\n  setlocal bufhidden=unload\n  bwipeout\n  call assert_equal([\"bufunload\", \"bufdelete\", \"bufwipeout\"], s:li)\n\n  au! test_bufunload_group\n  augroup! test_bufunload_group\nendfunc\n\n\" SEGV occurs in older versions.  (At least 7.4.2005 or older)\nfunc Test_autocmd_bufunload_with_tabnext()\n  tabedit\n  tabfirst\n\n  augroup test_autocmd_bufunload_with_tabnext_group\n    autocmd!\n    autocmd BufUnload <buffer> tabnext\n  augroup END\n\n  quit\n  call assert_equal(2, tabpagenr('$'))\n\n  autocmd! test_autocmd_bufunload_with_tabnext_group\n  augroup! test_autocmd_bufunload_with_tabnext_group\n  tablast\n  quit\nendfunc\n\nfunc Test_argdelete_in_next()\n  au BufNew,BufEnter,BufLeave,BufWinEnter * argdel\n  call assert_fails('next a b', 'E1156:')\n  au! BufNew,BufEnter,BufLeave,BufWinEnter *\nendfunc\n\nfunc Test_autocmd_bufwinleave_with_tabfirst()\n  tabedit\n  augroup sample\n    autocmd!\n    autocmd BufWinLeave <buffer> tabfirst\n  augroup END\n  call setline(1, ['a', 'b', 'c'])\n  edit! a.txt\n  tabclose\nendfunc\n\n\" SEGV occurs in older versions.  (At least 7.4.2321 or older)\nfunc Test_autocmd_bufunload_avoiding_SEGV_01()\n  split aa.txt\n  let lastbuf = bufnr('$')\n\n  augroup test_autocmd_bufunload\n    autocmd!\n    exe 'autocmd BufUnload <buffer> ' . (lastbuf + 1) . 'bwipeout!'\n  augroup END\n\n  call assert_fails('edit bb.txt', 'E937:')\n\n  autocmd! test_autocmd_bufunload\n  augroup! test_autocmd_bufunload\n  bwipe! aa.txt\n  bwipe! bb.txt\nendfunc\n\n\" SEGV occurs in older versions.  (At least 7.4.2321 or older)\nfunc Test_autocmd_bufunload_avoiding_SEGV_02()\n  setlocal buftype=nowrite\n  let lastbuf = bufnr('$')\n\n  augroup test_autocmd_bufunload\n    autocmd!\n    exe 'autocmd BufUnload <buffer> ' . (lastbuf + 1) . 'bwipeout!'\n  augroup END\n\n  normal! i1\n  call assert_fails('edit a.txt', 'E517:')\n\n  autocmd! test_autocmd_bufunload\n  augroup! test_autocmd_bufunload\n  bwipe! a.txt\nendfunc\n\nfunc Test_autocmd_dummy_wipeout()\n  \" prepare files\n  call writefile([''], 'Xdummywipetest1.txt')\n  call writefile([''], 'Xdummywipetest2.txt')\n  augroup test_bufunload_group\n    autocmd!\n    autocmd BufUnload * call add(s:li, \"bufunload\")\n    autocmd BufDelete * call add(s:li, \"bufdelete\")\n    autocmd BufWipeout * call add(s:li, \"bufwipeout\")\n  augroup END\n\n  let s:li = []\n  split Xdummywipetest1.txt\n  silent! vimgrep /notmatched/ Xdummywipetest*\n  call assert_equal([\"bufunload\", \"bufwipeout\"], s:li)\n\n  bwipeout\n  call delete('Xdummywipetest1.txt')\n  call delete('Xdummywipetest2.txt')\n  au! test_bufunload_group\n  augroup! test_bufunload_group\nendfunc\n\nfunc Test_win_tab_autocmd()\n  let g:record = []\n\n  augroup testing\n    au WinNew * call add(g:record, 'WinNew')\n    au WinClosed * call add(g:record, 'WinClosed')\n    au WinEnter * call add(g:record, 'WinEnter') \n    au WinLeave * call add(g:record, 'WinLeave') \n    au TabNew * call add(g:record, 'TabNew')\n    au TabClosed * call add(g:record, 'TabClosed')\n    au TabEnter * call add(g:record, 'TabEnter')\n    au TabLeave * call add(g:record, 'TabLeave')\n  augroup END\n\n  split\n  tabnew\n  close\n  close\n\n  call assert_equal([\n\t\\ 'WinLeave', 'WinNew', 'WinEnter',\n\t\\ 'WinLeave', 'TabLeave', 'WinNew', 'WinEnter', 'TabNew', 'TabEnter',\n\t\\ 'WinLeave', 'TabLeave', 'WinClosed', 'TabClosed', 'WinEnter', 'TabEnter',\n\t\\ 'WinLeave', 'WinClosed', 'WinEnter'\n\t\\ ], g:record)\n\n  let g:record = []\n  tabnew somefile\n  tabnext\n  bwipe somefile\n\n  call assert_equal([\n\t\\ 'WinLeave', 'TabLeave', 'WinNew', 'WinEnter', 'TabNew', 'TabEnter',\n\t\\ 'WinLeave', 'TabLeave', 'WinEnter', 'TabEnter',\n\t\\ 'WinClosed', 'TabClosed'\n\t\\ ], g:record)\n\n  augroup testing\n    au!\n  augroup END\n  unlet g:record\nendfunc\n\nfunc Test_WinScrolled()\n  CheckRunVimInTerminal\n\n  let lines =<< trim END\n    set nowrap scrolloff=0\n    for ii in range(1, 18)\n      call setline(ii, repeat(nr2char(96 + ii), ii * 2))\n    endfor\n    let win_id = win_getid()\n    let g:matched = v:false\n    execute 'au WinScrolled' win_id 'let g:matched = v:true'\n    let g:scrolled = 0\n    au WinScrolled * let g:scrolled += 1\n    au WinScrolled * let g:amatch = str2nr(expand('<amatch>'))\n    au WinScrolled * let g:afile = str2nr(expand('<afile>'))\n  END\n  call writefile(lines, 'Xtest_winscrolled')\n  let buf = RunVimInTerminal('-S Xtest_winscrolled', {'rows': 6})\n\n  call term_sendkeys(buf, \":echo g:scrolled\\<CR>\")\n  call WaitForAssert({-> assert_match('^0 ', term_getline(buf, 6))}, 1000)\n\n  \" Scroll left/right in Normal mode.\n  call term_sendkeys(buf, \"zlzh:echo g:scrolled\\<CR>\")\n  call WaitForAssert({-> assert_match('^2 ', term_getline(buf, 6))}, 1000)\n\n  \" Scroll up/down in Normal mode.\n  call term_sendkeys(buf, \"\\<c-e>\\<c-y>:echo g:scrolled\\<CR>\")\n  call WaitForAssert({-> assert_match('^4 ', term_getline(buf, 6))}, 1000)\n\n  \" Scroll up/down in Insert mode.\n  call term_sendkeys(buf, \"Mi\\<c-x>\\<c-e>\\<Esc>i\\<c-x>\\<c-y>\\<Esc>\")\n  call term_sendkeys(buf, \":echo g:scrolled\\<CR>\")\n  call WaitForAssert({-> assert_match('^6 ', term_getline(buf, 6))}, 1000)\n\n  \" Scroll the window horizontally to focus the last letter of the third line\n  \" containing only six characters. Moving to the previous and shorter lines\n  \" should trigger another autocommand as Vim has to make them visible.\n  call term_sendkeys(buf, \"5zl2k\")\n  call term_sendkeys(buf, \":echo g:scrolled\\<CR>\")\n  call WaitForAssert({-> assert_match('^8 ', term_getline(buf, 6))}, 1000)\n\n  \" Ensure the command was triggered for the specified window ID.\n  call term_sendkeys(buf, \":echo g:matched\\<CR>\")\n  call WaitForAssert({-> assert_match('^v:true ', term_getline(buf, 6))}, 1000)\n\n  \" Ensure the expansion of <amatch> and <afile> matches the window ID.\n  call term_sendkeys(buf, \":echo g:amatch == win_id && g:afile == win_id\\<CR>\")\n  call WaitForAssert({-> assert_match('^v:true ', term_getline(buf, 6))}, 1000)\n\n  call StopVimInTerminal(buf)\n  call delete('Xtest_winscrolled')\nendfunc\n\nfunc Test_WinScrolled_mouse()\n  CheckRunVimInTerminal\n\n  let lines =<< trim END\n    set nowrap scrolloff=0\n    set mouse=a term=xterm ttymouse=sgr mousetime=200 clipboard=\n    call setline(1, ['foo']->repeat(32))\n    split\n    let g:scrolled = 0\n    au WinScrolled * let g:scrolled += 1\n  END\n  call writefile(lines, 'Xtest_winscrolled_mouse')\n  let buf = RunVimInTerminal('-S Xtest_winscrolled_mouse', {'rows': 10})\n\n  \" With the upper split focused, send a scroll-down event to the unfocused one.\n  call test_setmouse(7, 1)\n  call term_sendkeys(buf, \"\\<ScrollWheelDown>\")\n  call TermWait(buf)\n  call term_sendkeys(buf, \":echo g:scrolled\\<CR>\")\n  call WaitForAssert({-> assert_match('^1', term_getline(buf, 10))}, 1000)\n\n  \" Again, but this time while we're in insert mode.\n  call term_sendkeys(buf, \"i\\<ScrollWheelDown>\\<Esc>\")\n  call TermWait(buf)\n  call term_sendkeys(buf, \":echo g:scrolled\\<CR>\")\n  call WaitForAssert({-> assert_match('^2', term_getline(buf, 10))}, 1000)\n\n  call StopVimInTerminal(buf)\n  call delete('Xtest_winscrolled_mouse')\nendfunc\n\nfunc Test_WinScrolled_close_curwin()\n  CheckRunVimInTerminal\n\n  let lines =<< trim END\n    set nowrap scrolloff=0\n    call setline(1, ['aaa', 'bbb'])\n    vsplit\n    au WinScrolled * close\n    au VimLeave * call writefile(['123456'], 'Xtestout')\n  END\n  call writefile(lines, 'Xtest_winscrolled_close_curwin')\n  let buf = RunVimInTerminal('-S Xtest_winscrolled_close_curwin', {'rows': 6})\n\n  \" This was using freed memory\n  call term_sendkeys(buf, \"\\<C-E>\")\n  call TermWait(buf)\n  call StopVimInTerminal(buf)\n\n  call assert_equal(['123456'], readfile('Xtestout'))\n\n  call delete('Xtest_winscrolled_close_curwin')\n  call delete('Xtestout')\nendfunc\n\nfunc Test_WinClosed()\n  \" Test that the pattern is matched against the closed window's ID, and both\n  \" <amatch> and <afile> are set to it.\n  new\n  let winid = win_getid()\n  let g:matched = v:false\n  augroup test-WinClosed\n    autocmd!\n    execute 'autocmd WinClosed' winid 'let g:matched = v:true'\n    autocmd WinClosed * let g:amatch = str2nr(expand('<amatch>'))\n    autocmd WinClosed * let g:afile = str2nr(expand('<afile>'))\n  augroup END\n  close\n  call assert_true(g:matched)\n  call assert_equal(winid, g:amatch)\n  call assert_equal(winid, g:afile)\n\n  \" Test that WinClosed is non-recursive.\n  new\n  new\n  call assert_equal(3, winnr('$'))\n  let g:triggered = 0\n  augroup test-WinClosed\n    autocmd!\n    autocmd WinClosed * let g:triggered += 1\n    autocmd WinClosed * 2 wincmd c\n  augroup END\n  close\n  call assert_equal(1, winnr('$'))\n  call assert_equal(1, g:triggered)\n\n  autocmd! test-WinClosed\n  augroup! test-WinClosed\n  unlet g:matched\n  unlet g:amatch\n  unlet g:afile\n  unlet g:triggered\nendfunc\n\nfunc Test_WinClosed_throws()\n  vnew\n  let bnr = bufnr()\n  call assert_equal(1, bufloaded(bnr))\n  augroup test-WinClosed\n    autocmd WinClosed * throw 'foo'\n  augroup END\n  try\n    close\n  catch /.*/\n  endtry\n  call assert_equal(0, bufloaded(bnr))\n\n  autocmd! test-WinClosed\n  augroup! test-WinClosed\nendfunc\n\nfunc Test_WinClosed_throws_with_tabs()\n  tabnew\n  let bnr = bufnr()\n  call assert_equal(1, bufloaded(bnr))\n  augroup test-WinClosed\n    autocmd WinClosed * throw 'foo'\n  augroup END\n  try\n    close\n  catch /.*/\n  endtry\n  call assert_equal(0, bufloaded(bnr))\n\n  autocmd! test-WinClosed\n  augroup! test-WinClosed\nendfunc\n\nfunc s:AddAnAutocmd()\n  augroup vimBarTest\n    au BufReadCmd * echo 'hello'\n  augroup END\n  call assert_equal(3, len(split(execute('au vimBarTest'), \"\\n\")))\nendfunc\n\nfunc Test_early_bar()\n  \" test that a bar is recognized before the {event}\n  call s:AddAnAutocmd()\n  augroup vimBarTest | au! | let done = 77 | augroup END\n  call assert_equal(1, len(split(execute('au vimBarTest'), \"\\n\")))\n  call assert_equal(77, done)\n\n  call s:AddAnAutocmd()\n  augroup vimBarTest| au!| let done = 88 | augroup END\n  call assert_equal(1, len(split(execute('au vimBarTest'), \"\\n\")))\n  call assert_equal(88, done)\n\n  \" test that a bar is recognized after the {event}\n  call s:AddAnAutocmd()\n  augroup vimBarTest| au!BufReadCmd| let done = 99 | augroup END\n  call assert_equal(1, len(split(execute('au vimBarTest'), \"\\n\")))\n  call assert_equal(99, done)\n\n  \" test that a bar is recognized after the {group}\n  call s:AddAnAutocmd()\n  au! vimBarTest|echo 'hello'\n  call assert_equal(1, len(split(execute('au vimBarTest'), \"\\n\")))\nendfunc\n\nfunc RemoveGroup()\n  autocmd! StartOK\n  augroup! StartOK\nendfunc\n\nfunc Test_augroup_warning()\n  augroup TheWarning\n    au VimEnter * echo 'entering'\n  augroup END\n  call assert_match(\"TheWarning.*VimEnter\", execute('au VimEnter'))\n  redir => res\n  augroup! TheWarning\n  redir END\n  call assert_match(\"W19:\", res)\n  call assert_match(\"-Deleted-.*VimEnter\", execute('au VimEnter'))\n\n  \" check \"Another\" does not take the pace of the deleted entry\n  augroup Another\n  augroup END\n  call assert_match(\"-Deleted-.*VimEnter\", execute('au VimEnter'))\n  augroup! Another\n\n  \" no warning for postpone aucmd delete\n  augroup StartOK\n    au VimEnter * call RemoveGroup()\n  augroup END\n  call assert_match(\"StartOK.*VimEnter\", execute('au VimEnter'))\n  redir => res\n  doautocmd VimEnter\n  redir END\n  call assert_notmatch(\"W19:\", res)\n  au! VimEnter\n\n  call assert_fails('augroup!', 'E471:')\nendfunc\n\nfunc Test_BufReadCmdHelp()\n  \" This used to cause access to free memory\n  au BufReadCmd * e +h\n  help\n\n  au! BufReadCmd\nendfunc\n\nfunc Test_BufReadCmdHelpJump()\n  \" This used to cause access to free memory\n  au BufReadCmd * e +h{\n  \" } to fix highlighting\n  call assert_fails('help', 'E434:')\n\n  au! BufReadCmd\nendfunc\n\nfunc Test_augroup_deleted()\n  \" This caused a crash before E936 was introduced\n  augroup x\n    call assert_fails('augroup! x', 'E936:')\n    au VimEnter * echo\n  augroup end\n  augroup! x\n  call assert_match(\"-Deleted-.*VimEnter\", execute('au VimEnter'))\n  au! VimEnter\nendfunc\n\n\" Tests for autocommands on :close command.\n\" This used to be in test13.\nfunc Test_three_windows()\n  \" Clean up buffers, because in some cases this function fails.\n  call s:cleanup_buffers()\n\n  \" Write three files and open them, each in a window.\n  \" Then go to next window, with autocommand that deletes the previous one.\n  \" Do this twice, writing the file.\n  e! Xtestje1\n  call setline(1, 'testje1')\n  w\n  sp Xtestje2\n  call setline(1, 'testje2')\n  w\n  sp Xtestje3\n  call setline(1, 'testje3')\n  w\n  wincmd w\n  au WinLeave Xtestje2 bwipe\n  wincmd w\n  call assert_equal('Xtestje1', expand('%'))\n\n  au WinLeave Xtestje1 bwipe Xtestje3\n  close\n  call assert_equal('Xtestje1', expand('%'))\n\n  \" Test deleting the buffer on a Unload event.  If this goes wrong there\n  \" will be the ATTENTION prompt.\n  e Xtestje1\n  au!\n  au! BufUnload Xtestje1 bwipe\n  call assert_fails('e Xtestje3', 'E937:')\n  call assert_equal('Xtestje3', expand('%'))\n\n  e Xtestje2\n  sp Xtestje1\n  call assert_fails('e', 'E937:')\n  call assert_equal('Xtestje1', expand('%'))\n\n  \" Test changing buffers in a BufWipeout autocommand.  If this goes wrong\n  \" there are ml_line errors and/or a Crash.\n  au!\n  only\n  e Xanother\n  e Xtestje1\n  bwipe Xtestje2\n  bwipe Xtestje3\n  au BufWipeout Xtestje1 buf Xtestje1\n  bwipe\n  call assert_equal('Xanother', expand('%'))\n\n  only\n  help\n  wincmd w\n  1quit\n  call assert_equal('Xanother', expand('%'))\n\n  au!\n  enew\n  call delete('Xtestje1')\n  call delete('Xtestje2')\n  call delete('Xtestje3')\nendfunc\n\nfunc Test_BufEnter()\n  au! BufEnter\n  au Bufenter * let val = val . '+'\n  let g:val = ''\n  split NewFile\n  call assert_equal('+', g:val)\n  bwipe!\n  call assert_equal('++', g:val)\n\n  \" Also get BufEnter when editing a directory\n  call mkdir('Xdir')\n  split Xdir\n  call assert_equal('+++', g:val)\n\n  \" On MS-Windows we can't edit the directory, make sure we wipe the right\n  \" buffer.\n  bwipe! Xdir\n\n  call delete('Xdir', 'd')\n  au! BufEnter\nendfunc\n\n\" Closing a window might cause an endless loop\n\" E814 for older Vims\nfunc Test_autocmd_bufwipe_in_SessLoadPost()\n  edit Xtest\n  tabnew\n  file Xsomething\n  set noswapfile\n  mksession!\n\n  let content =<< trim [CODE]\n    call test_override('ui_delay', 10)\n    set nocp noswapfile\n    let v:swapchoice = \"e\"\n    augroup test_autocmd_sessionload\n    autocmd!\n    autocmd SessionLoadPost * exe bufnr(\"Xsomething\") . \"bw!\"\n    augroup END\n\n    func WriteErrors()\n      call writefile([execute(\"messages\")], \"Xerrors\")\n    endfunc\n    au VimLeave * call WriteErrors()\n  [CODE]\n\n  call writefile(content, 'Xvimrc')\n  call system(GetVimCommand('Xvimrc') .. ' --not-a-term --noplugins -S Session.vim -c cq')\n  let errors = join(readfile('Xerrors'))\n  call assert_match('E814:', errors)\n\n  set swapfile\n  for file in ['Session.vim', 'Xvimrc', 'Xerrors']\n    call delete(file)\n  endfor\nendfunc\n\n\" Using :blast and :ball for many events caused a crash, because b_nwindows was\n\" not incremented correctly.\nfunc Test_autocmd_blast_badd()\n  let content =<< trim [CODE]\n      au BufNew,BufAdd,BufWinEnter,BufEnter,BufLeave,BufWinLeave,BufUnload,VimEnter foo* blast\n      edit foo1\n      au BufNew,BufAdd,BufWinEnter,BufEnter,BufLeave,BufWinLeave,BufUnload,VimEnter foo* ball\n      edit foo2\n      call writefile(['OK'], 'Xerrors')\n      qall\n  [CODE]\n\n  call writefile(content, 'XblastBall')\n  call system(GetVimCommand() .. ' --clean -S XblastBall')\n  call assert_match('OK', readfile('Xerrors')->join())\n\n  call delete('XblastBall')\n  call delete('Xerrors')\nendfunc\n\n\" SEGV occurs in older versions.\nfunc Test_autocmd_bufwipe_in_SessLoadPost2()\n  tabnew\n  set noswapfile\n  mksession!\n\n  let content =<< trim [CODE]\n    set nocp noswapfile\n    function! DeleteInactiveBufs()\n      tabfirst\n      let tabblist = []\n      for i in range(1, tabpagenr(''$''))\n        call extend(tabblist, tabpagebuflist(i))\n      endfor\n      for b in range(1, bufnr(''$''))\n        if bufexists(b) && buflisted(b) && (index(tabblist, b) == -1 || bufname(b) =~# ''^$'')\n          exec ''bwipeout '' . b\n        endif\n      endfor\n      echomsg \"SessionLoadPost DONE\"\n    endfunction\n    au SessionLoadPost * call DeleteInactiveBufs()\n\n    func WriteErrors()\n      call writefile([execute(\"messages\")], \"Xerrors\")\n    endfunc\n    au VimLeave * call WriteErrors()\n  [CODE]\n\n  call writefile(content, 'Xvimrc')\n  call system(GetVimCommand('Xvimrc') .. ' --not-a-term --noplugins -S Session.vim -c cq')\n  let errors = join(readfile('Xerrors'))\n  \" This probably only ever matches on unix.\n  call assert_notmatch('Caught deadly signal SEGV', errors)\n  call assert_match('SessionLoadPost DONE', errors)\n\n  set swapfile\n  for file in ['Session.vim', 'Xvimrc', 'Xerrors']\n    call delete(file)\n  endfor\nendfunc\n\nfunc Test_empty_doau()\n  doau \\|\nendfunc\n\nfunc s:AutoCommandOptionSet(match)\n  let template = \"Option: <%s>, OldVal: <%s>, OldValLocal: <%s>, OldValGlobal: <%s>, NewVal: <%s>, Scope: <%s>, Command: <%s>\\n\"\n  let item     = remove(g:options, 0)\n  let expected = printf(template, item[0], item[1], item[2], item[3], item[4], item[5], item[6])\n  let actual   = printf(template, a:match, v:option_old, v:option_oldlocal, v:option_oldglobal, v:option_new, v:option_type, v:option_command)\n  let g:opt    = [expected, actual]\n  \"call assert_equal(expected, actual)\nendfunc\n\nfunc Test_OptionSet()\n  CheckOption autochdir\n\n  badd test_autocmd.vim\n\n  call test_override('starting', 1)\n  set nocp\n  au OptionSet * :call s:AutoCommandOptionSet(expand(\"<amatch>\"))\n\n  \" 1: Setting number option\"\n  let g:options = [['number', 0, 0, 0, 1, 'global', 'set']]\n  set nu\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 2: Setting local number option\"\n  let g:options = [['number', 1, 1, '', 0, 'local', 'setlocal']]\n  setlocal nonu\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 3: Setting global number option\"\n  let g:options = [['number', 1, '', 1, 0, 'global', 'setglobal']]\n  setglobal nonu\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 4: Setting local autoindent option\"\n  let g:options = [['autoindent', 0, 0, '', 1, 'local', 'setlocal']]\n  setlocal ai\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 5: Setting global autoindent option\"\n  let g:options = [['autoindent', 0, '', 0, 1, 'global', 'setglobal']]\n  setglobal ai\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 6: Setting global autoindent option\"\n  let g:options = [['autoindent', 1, 1, 1, 0, 'global', 'set']]\n  set ai!\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 6a: Setting global autoindent option\"\n  let g:options = [['autoindent', 1, 1, 0, 0, 'global', 'set']]\n  noa setlocal ai\n  noa setglobal noai\n  set ai!\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" Should not print anything, use :noa\n  \" 7: don't trigger OptionSet\"\n  let g:options = [['invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid']]\n  noa set nonu\n  call assert_equal([['invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid']], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 8: Setting several global list and number option\"\n  let g:options = [['list', 0, 0, 0, 1, 'global', 'set'], ['number', 0, 0, 0, 1, 'global', 'set']]\n  set list nu\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 9: don't trigger OptionSet\"\n  let g:options = [['invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid'], ['invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid']]\n  noa set nolist nonu\n  call assert_equal([['invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid'], ['invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid', 'invalid']], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 10: Setting global acd\"\n  let g:options = [['autochdir', 0, 0, '', 1, 'local', 'setlocal']]\n  setlocal acd\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 11: Setting global autoread (also sets local value)\"\n  let g:options = [['autoread', 0, 0, 0, 1, 'global', 'set']]\n  set ar\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 12: Setting local autoread\"\n  let g:options = [['autoread', 1, 1, '', 1, 'local', 'setlocal']]\n  setlocal ar\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 13: Setting global autoread\"\n  let g:options = [['autoread', 1, '', 1, 0, 'global', 'setglobal']]\n  setglobal invar\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 14: Setting option backspace through :let\"\n  let g:options = [['backspace', '', '', '', 'eol,indent,start', 'global', 'set']]\n  let &bs = \"eol,indent,start\"\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 15: Setting option backspace through setbufvar()\"\n  let g:options = [['backup', 0, 0, '', 1, 'local', 'setlocal']]\n  \" try twice, first time, shouldn't trigger because option name is invalid,\n  \" second time, it should trigger\n  let bnum = bufnr('%')\n  call assert_fails(\"call setbufvar(bnum, '&l:bk', 1)\", 'E355:')\n  \" should trigger, use correct option name\n  call setbufvar(bnum, '&backup', 1)\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 16: Setting number option using setwinvar\"\n  let g:options = [['number', 0, 0, '', 1, 'local', 'setlocal']]\n  call setwinvar(0, '&number', 1)\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 17: Setting key option, shouldn't trigger\"\n  let g:options = [['key', 'invalid', 'invalid1', 'invalid2', 'invalid3', 'invalid4', 'invalid5']]\n  setlocal key=blah\n  setlocal key=\n  call assert_equal([['key', 'invalid', 'invalid1', 'invalid2', 'invalid3', 'invalid4', 'invalid5']], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 18a: Setting string global option\"\n  let oldval = &backupext\n  let g:options = [['backupext', oldval, oldval, oldval, 'foo', 'global', 'set']]\n  set backupext=foo\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 18b: Resetting string global option\"\n  let g:options = [['backupext', 'foo', 'foo', 'foo', oldval, 'global', 'set']]\n  set backupext&\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 18c: Setting global string global option\"\n  let g:options = [['backupext', oldval, '', oldval, 'bar', 'global', 'setglobal']]\n  setglobal backupext=bar\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 18d: Setting local string global option\"\n  \" As this is a global option this sets the global value even though\n  \" :setlocal is used!\n  noa set backupext& \" Reset global and local value (without triggering autocmd)\n  let g:options = [['backupext', oldval, oldval, '', 'baz', 'local', 'setlocal']]\n  setlocal backupext=baz\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 18e: Setting again string global option\"\n  noa setglobal backupext=ext_global \" Reset global and local value (without triggering autocmd)\n  noa setlocal backupext=ext_local \" Sets the global(!) value!\n  let g:options = [['backupext', 'ext_local', 'ext_local', 'ext_local', 'fuu', 'global', 'set']]\n  set backupext=fuu\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 19a: Setting string global-local (to buffer) option\"\n  let oldval = &tags\n  let g:options = [['tags', oldval, oldval, oldval, 'tagpath', 'global', 'set']]\n  set tags=tagpath\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 19b: Resetting string global-local (to buffer) option\"\n  let g:options = [['tags', 'tagpath', 'tagpath', 'tagpath', oldval, 'global', 'set']]\n  set tags&\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 19c: Setting global string global-local (to buffer) option \"\n  let g:options = [['tags', oldval, '', oldval, 'tagpath1', 'global', 'setglobal']]\n  setglobal tags=tagpath1\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 19d: Setting local string global-local (to buffer) option\"\n  let g:options = [['tags', 'tagpath1', 'tagpath1', '', 'tagpath2', 'local', 'setlocal']]\n  setlocal tags=tagpath2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 19e: Setting again string global-local (to buffer) option\"\n  \" Note: v:option_old is the old global value for global-local string options\n  \" but the old local value for all other kinds of options.\n  noa setglobal tags=tag_global \" Reset global and local value (without triggering autocmd)\n  noa setlocal tags=tag_local\n  let g:options = [['tags', 'tag_global', 'tag_local', 'tag_global', 'tagpath', 'global', 'set']]\n  set tags=tagpath\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 19f: Setting string global-local (to buffer) option to an empty string\"\n  \" Note: v:option_old is the old global value for global-local string options\n  \" but the old local value for all other kinds of options.\n  noa set tags=tag_global \" Reset global and local value (without triggering autocmd)\n  noa setlocal tags= \" empty string\n  let g:options = [['tags', 'tag_global', '', 'tag_global', 'tagpath', 'global', 'set']]\n  set tags=tagpath\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 20a: Setting string local (to buffer) option\"\n  let oldval = &spelllang\n  let g:options = [['spelllang', oldval, oldval, oldval, 'elvish,klingon', 'global', 'set']]\n  set spelllang=elvish,klingon\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 20b: Resetting string local (to buffer) option\"\n  let g:options = [['spelllang', 'elvish,klingon', 'elvish,klingon', 'elvish,klingon', oldval, 'global', 'set']]\n  set spelllang&\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 20c: Setting global string local (to buffer) option\"\n  let g:options = [['spelllang', oldval, '', oldval, 'elvish', 'global', 'setglobal']]\n  setglobal spelllang=elvish\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 20d: Setting local string local (to buffer) option\"\n  noa set spelllang& \" Reset global and local value (without triggering autocmd)\n  let g:options = [['spelllang', oldval, oldval, '', 'klingon', 'local', 'setlocal']]\n  setlocal spelllang=klingon\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 20e: Setting again string local (to buffer) option\"\n  \" Note: v:option_old is the old global value for global-local string options\n  \" but the old local value for all other kinds of options.\n  noa setglobal spelllang=spellglobal \" Reset global and local value (without triggering autocmd)\n  noa setlocal spelllang=spelllocal\n  let g:options = [['spelllang', 'spelllocal', 'spelllocal', 'spellglobal', 'foo', 'global', 'set']]\n  set spelllang=foo\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 21a: Setting string global-local (to window) option\"\n  let oldval = &statusline\n  let g:options = [['statusline', oldval, oldval, oldval, 'foo', 'global', 'set']]\n  set statusline=foo\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 21b: Resetting string global-local (to window) option\"\n  \" Note: v:option_old is the old global value for global-local string options\n  \" but the old local value for all other kinds of options.\n  let g:options = [['statusline', 'foo', 'foo', 'foo', oldval, 'global', 'set']]\n  set statusline&\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 21c: Setting global string global-local (to window) option\"\n  let g:options = [['statusline', oldval, '', oldval, 'bar', 'global', 'setglobal']]\n  setglobal statusline=bar\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 21d: Setting local string global-local (to window) option\"\n  noa set statusline& \" Reset global and local value (without triggering autocmd)\n  let g:options = [['statusline', oldval, oldval, '', 'baz', 'local', 'setlocal']]\n  setlocal statusline=baz\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 21e: Setting again string global-local (to window) option\"\n  \" Note: v:option_old is the old global value for global-local string options\n  \" but the old local value for all other kinds of options.\n  noa setglobal statusline=bar \" Reset global and local value (without triggering autocmd)\n  noa setlocal statusline=baz\n  let g:options = [['statusline', 'bar', 'baz', 'bar', 'foo', 'global', 'set']]\n  set statusline=foo\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 22a: Setting string local (to window) option\"\n  let oldval = &foldignore\n  let g:options = [['foldignore', oldval, oldval, oldval, 'fo', 'global', 'set']]\n  set foldignore=fo\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 22b: Resetting string local (to window) option\"\n  let g:options = [['foldignore', 'fo', 'fo', 'fo', oldval, 'global', 'set']]\n  set foldignore&\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 22c: Setting global string local (to window) option\"\n  let g:options = [['foldignore', oldval, '', oldval, 'bar', 'global', 'setglobal']]\n  setglobal foldignore=bar\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 22d: Setting local string local (to window) option\"\n  noa set foldignore& \" Reset global and local value (without triggering autocmd)\n  let g:options = [['foldignore', oldval, oldval, '', 'baz', 'local', 'setlocal']]\n  setlocal foldignore=baz\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 22e: Setting again string local (to window) option\"\n  noa setglobal foldignore=glob \" Reset global and local value (without triggering autocmd)\n  noa setlocal foldignore=loc\n  let g:options = [['foldignore', 'loc', 'loc', 'glob', 'fo', 'global', 'set']]\n  set foldignore=fo\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 23a: Setting global number global option\"\n  noa setglobal cmdheight=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal cmdheight=1 \" Sets the global(!) value!\n  let g:options = [['cmdheight', '1', '', '1', '2', 'global', 'setglobal']]\n  setglobal cmdheight=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 23b: Setting local number global option\"\n  noa setglobal cmdheight=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal cmdheight=1 \" Sets the global(!) value!\n  let g:options = [['cmdheight', '1', '1', '', '2', 'local', 'setlocal']]\n  setlocal cmdheight=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 23c: Setting again number global option\"\n  noa setglobal cmdheight=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal cmdheight=1 \" Sets the global(!) value!\n  let g:options = [['cmdheight', '1', '1', '1', '2', 'global', 'set']]\n  set cmdheight=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 23d: Setting again number global option\"\n  noa set cmdheight=8 \" Reset global and local value (without triggering autocmd)\n  let g:options = [['cmdheight', '8', '8', '8', '2', 'global', 'set']]\n  set cmdheight=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 24a: Setting global number global-local (to buffer) option\"\n  noa setglobal undolevels=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal undolevels=1\n  let g:options = [['undolevels', '8', '', '8', '2', 'global', 'setglobal']]\n  setglobal undolevels=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 24b: Setting local number global-local (to buffer) option\"\n  noa setglobal undolevels=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal undolevels=1\n  let g:options = [['undolevels', '1', '1', '', '2', 'local', 'setlocal']]\n  setlocal undolevels=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 24c: Setting again number global-local (to buffer) option\"\n  noa setglobal undolevels=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal undolevels=1\n  let g:options = [['undolevels', '1', '1', '8', '2', 'global', 'set']]\n  set undolevels=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 24d: Setting again global number global-local (to buffer) option\"\n  noa set undolevels=8 \" Reset global and local value (without triggering autocmd)\n  let g:options = [['undolevels', '8', '8', '8', '2', 'global', 'set']]\n  set undolevels=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 25a: Setting global number local (to buffer) option\"\n  noa setglobal wrapmargin=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal wrapmargin=1\n  let g:options = [['wrapmargin', '8', '', '8', '2', 'global', 'setglobal']]\n  setglobal wrapmargin=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 25b: Setting local number local (to buffer) option\"\n  noa setglobal wrapmargin=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal wrapmargin=1\n  let g:options = [['wrapmargin', '1', '1', '', '2', 'local', 'setlocal']]\n  setlocal wrapmargin=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 25c: Setting again number local (to buffer) option\"\n  noa setglobal wrapmargin=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal wrapmargin=1\n  let g:options = [['wrapmargin', '1', '1', '8', '2', 'global', 'set']]\n  set wrapmargin=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 25d: Setting again global number local (to buffer) option\"\n  noa set wrapmargin=8 \" Reset global and local value (without triggering autocmd)\n  let g:options = [['wrapmargin', '8', '8', '8', '2', 'global', 'set']]\n  set wrapmargin=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 26: Setting number global-local (to window) option.\n  \" Such option does currently not exist.\n\n\n  \" 27a: Setting global number local (to window) option\"\n  noa setglobal foldcolumn=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal foldcolumn=1\n  let g:options = [['foldcolumn', '8', '', '8', '2', 'global', 'setglobal']]\n  setglobal foldcolumn=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 27b: Setting local number local (to window) option\"\n  noa setglobal foldcolumn=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal foldcolumn=1\n  let g:options = [['foldcolumn', '1', '1', '', '2', 'local', 'setlocal']]\n  setlocal foldcolumn=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 27c: Setting again number local (to window) option\"\n  noa setglobal foldcolumn=8 \" Reset global and local value (without triggering autocmd)\n  noa setlocal foldcolumn=1\n  let g:options = [['foldcolumn', '1', '1', '8', '2', 'global', 'set']]\n  set foldcolumn=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 27d: Setting again global number local (to window) option\"\n  noa set foldcolumn=8 \" Reset global and local value (without triggering autocmd)\n  let g:options = [['foldcolumn', '8', '8', '8', '2', 'global', 'set']]\n  set foldcolumn=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 28a: Setting global boolean global option\"\n  noa setglobal nowrapscan \" Reset global and local value (without triggering autocmd)\n  noa setlocal wrapscan \" Sets the global(!) value!\n  let g:options = [['wrapscan', '1', '', '1', '0', 'global', 'setglobal']]\n  setglobal nowrapscan\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 28b: Setting local boolean global option\"\n  noa setglobal nowrapscan \" Reset global and local value (without triggering autocmd)\n  noa setlocal wrapscan \" Sets the global(!) value!\n  let g:options = [['wrapscan', '1', '1', '', '0', 'local', 'setlocal']]\n  setlocal nowrapscan\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 28c: Setting again boolean global option\"\n  noa setglobal nowrapscan \" Reset global and local value (without triggering autocmd)\n  noa setlocal wrapscan \" Sets the global(!) value!\n  let g:options = [['wrapscan', '1', '1', '1', '0', 'global', 'set']]\n  set nowrapscan\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 28d: Setting again global boolean global option\"\n  noa set nowrapscan \" Reset global and local value (without triggering autocmd)\n  let g:options = [['wrapscan', '0', '0', '0', '1', 'global', 'set']]\n  set wrapscan\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 29a: Setting global boolean global-local (to buffer) option\"\n  noa setglobal noautoread \" Reset global and local value (without triggering autocmd)\n  noa setlocal autoread\n  let g:options = [['autoread', '0', '', '0', '1', 'global', 'setglobal']]\n  setglobal autoread\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 29b: Setting local boolean global-local (to buffer) option\"\n  noa setglobal noautoread \" Reset global and local value (without triggering autocmd)\n  noa setlocal autoread\n  let g:options = [['autoread', '1', '1', '', '0', 'local', 'setlocal']]\n  setlocal noautoread\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 29c: Setting again boolean global-local (to buffer) option\"\n  noa setglobal noautoread \" Reset global and local value (without triggering autocmd)\n  noa setlocal autoread\n  let g:options = [['autoread', '1', '1', '0', '1', 'global', 'set']]\n  set autoread\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 29d: Setting again global boolean global-local (to buffer) option\"\n  noa set noautoread \" Reset global and local value (without triggering autocmd)\n  let g:options = [['autoread', '0', '0', '0', '1', 'global', 'set']]\n  set autoread\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 30a: Setting global boolean local (to buffer) option\"\n  noa setglobal nocindent \" Reset global and local value (without triggering autocmd)\n  noa setlocal cindent\n  let g:options = [['cindent', '0', '', '0', '1', 'global', 'setglobal']]\n  setglobal cindent\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 30b: Setting local boolean local (to buffer) option\"\n  noa setglobal nocindent \" Reset global and local value (without triggering autocmd)\n  noa setlocal cindent\n  let g:options = [['cindent', '1', '1', '', '0', 'local', 'setlocal']]\n  setlocal nocindent\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 30c: Setting again boolean local (to buffer) option\"\n  noa setglobal nocindent \" Reset global and local value (without triggering autocmd)\n  noa setlocal cindent\n  let g:options = [['cindent', '1', '1', '0', '1', 'global', 'set']]\n  set cindent\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 30d: Setting again global boolean local (to buffer) option\"\n  noa set nocindent \" Reset global and local value (without triggering autocmd)\n  let g:options = [['cindent', '0', '0', '0', '1', 'global', 'set']]\n  set cindent\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 31: Setting boolean global-local (to window) option\n  \" Currently no such option exists.\n\n\n  \" 32a: Setting global boolean local (to window) option\"\n  noa setglobal nocursorcolumn \" Reset global and local value (without triggering autocmd)\n  noa setlocal cursorcolumn\n  let g:options = [['cursorcolumn', '0', '', '0', '1', 'global', 'setglobal']]\n  setglobal cursorcolumn\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 32b: Setting local boolean local (to window) option\"\n  noa setglobal nocursorcolumn \" Reset global and local value (without triggering autocmd)\n  noa setlocal cursorcolumn\n  let g:options = [['cursorcolumn', '1', '1', '', '0', 'local', 'setlocal']]\n  setlocal nocursorcolumn\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 32c: Setting again boolean local (to window) option\"\n  noa setglobal nocursorcolumn \" Reset global and local value (without triggering autocmd)\n  noa setlocal cursorcolumn\n  let g:options = [['cursorcolumn', '1', '1', '0', '1', 'global', 'set']]\n  set cursorcolumn\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n  \" 32d: Setting again global boolean local (to window) option\"\n  noa set nocursorcolumn \" Reset global and local value (without triggering autocmd)\n  let g:options = [['cursorcolumn', '0', '0', '0', '1', 'global', 'set']]\n  set cursorcolumn\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" 33: Test autocommands when an option value is converted internally.\n  noa set backspace=1 \" Reset global and local value (without triggering autocmd)\n  let g:options = [['backspace', 'indent,eol', 'indent,eol', 'indent,eol', '2', 'global', 'set']]\n  set backspace=2\n  call assert_equal([], g:options)\n  call assert_equal(g:opt[0], g:opt[1])\n\n\n  \" Cleanup\n  au! OptionSet\n  \" set tags&\n  for opt in ['nu', 'ai', 'acd', 'ar', 'bs', 'backup', 'cul', 'cp', 'backupext', 'tags', 'spelllang', 'statusline', 'foldignore', 'cmdheight', 'undolevels', 'wrapmargin', 'foldcolumn', 'wrapscan', 'autoread', 'cindent', 'cursorcolumn']\n    exe printf(\":set %s&vim\", opt)\n  endfor\n  call test_override('starting', 0)\n  delfunc! AutoCommandOptionSet\nendfunc\n\nfunc Test_OptionSet_diffmode()\n  call test_override('starting', 1)\n  \" 18: Changing an option when entering diff mode\n  new\n  au OptionSet diff :let &l:cul = v:option_new\n\n  call setline(1, ['buffer 1', 'line2', 'line3', 'line4'])\n  call assert_equal(0, &l:cul)\n  diffthis\n  call assert_equal(1, &l:cul)\n\n  vnew\n  call setline(1, ['buffer 2', 'line 2', 'line 3', 'line4'])\n  call assert_equal(0, &l:cul)\n  diffthis\n  call assert_equal(1, &l:cul)\n\n  diffoff\n  call assert_equal(0, &l:cul)\n  call assert_equal(1, getwinvar(2, '&l:cul'))\n  bw!\n\n  call assert_equal(1, &l:cul)\n  diffoff!\n  call assert_equal(0, &l:cul)\n  call assert_equal(0, getwinvar(1, '&l:cul'))\n  bw!\n\n  \" Cleanup\n  au! OptionSet\n  call test_override('starting', 0)\nendfunc\n\nfunc Test_OptionSet_diffmode_close()\n  call test_override('starting', 1)\n  \" 19: Try to close the current window when entering diff mode\n  \" should not segfault\n  new\n  au OptionSet diff close\n\n  call setline(1, ['buffer 1', 'line2', 'line3', 'line4'])\n  call assert_fails(':diffthis', 'E788:')\n  call assert_equal(1, &diff)\n  vnew\n  call setline(1, ['buffer 2', 'line 2', 'line 3', 'line4'])\n  call assert_fails(':diffthis', 'E788:')\n  call assert_equal(1, &diff)\n  set diffopt-=closeoff\n  bw!\n  call assert_fails(':diffoff!', 'E788:')\n  bw!\n\n  \" Cleanup\n  au! OptionSet\n  call test_override('starting', 0)\n  \"delfunc! AutoCommandOptionSet\nendfunc\n\n\" Test for Bufleave autocommand that deletes the buffer we are about to edit.\nfunc Test_BufleaveWithDelete()\n  new | edit Xfile1\n\n  augroup test_bufleavewithdelete\n      autocmd!\n      autocmd BufLeave Xfile1 bwipe Xfile2\n  augroup END\n\n  call assert_fails('edit Xfile2', 'E143:')\n  call assert_equal('Xfile1', bufname('%'))\n\n  autocmd! test_bufleavewithdelete BufLeave Xfile1\n  augroup! test_bufleavewithdelete\n\n  new\n  bwipe! Xfile1\nendfunc\n\n\" Test for autocommand that changes the buffer list, when doing \":ball\".\nfunc Test_Acmd_BufAll()\n  enew!\n  %bwipe!\n  call writefile(['Test file Xxx1'], 'Xxx1')\n  call writefile(['Test file Xxx2'], 'Xxx2')\n  call writefile(['Test file Xxx3'], 'Xxx3')\n\n  \" Add three files to the buffer list\n  split Xxx1\n  close\n  split Xxx2\n  close\n  split Xxx3\n  close\n\n  \" Wipe the buffer when the buffer is opened\n  au BufReadPost Xxx2 bwipe\n\n  call append(0, 'Test file Xxx4')\n  ball\n\n  call assert_equal(2, winnr('$'))\n  call assert_equal('Xxx1', bufname(winbufnr(winnr('$'))))\n  wincmd t\n\n  au! BufReadPost\n  %bwipe!\n  call delete('Xxx1')\n  call delete('Xxx2')\n  call delete('Xxx3')\n  enew! | only\nendfunc\n\n\" Test for autocommand that changes current buffer on BufEnter event.\n\" Check if modelines are interpreted for the correct buffer.\nfunc Test_Acmd_BufEnter()\n  %bwipe!\n  call writefile(['start of test file Xxx1',\n\t      \\ \"\\<Tab>this is a test\",\n\t      \\ 'end of test file Xxx1'], 'Xxx1')\n  call writefile(['start of test file Xxx2',\n\t      \\ 'vim: set noai :',\n\t      \\ \"\\<Tab>this is a test\",\n\t      \\ 'end of test file Xxx2'], 'Xxx2')\n\n  au BufEnter Xxx2 brew\n  set ai modeline modelines=3\n  edit Xxx1\n  \" edit Xxx2, autocmd will do :brew\n  edit Xxx2\n  exe \"normal G?this is a\\<CR>\"\n  \" Append text with autoindent to this file\n  normal othis should be auto-indented\n  call assert_equal(\"\\<Tab>this should be auto-indented\", getline('.'))\n  call assert_equal(3, line('.'))\n  \" Remove autocmd and edit Xxx2 again\n  au! BufEnter Xxx2\n  buf! Xxx2\n  exe \"normal G?this is a\\<CR>\"\n  \" append text without autoindent to Xxx\n  normal othis should be in column 1\n  call assert_equal(\"this should be in column 1\", getline('.'))\n  call assert_equal(4, line('.'))\n\n  %bwipe!\n  call delete('Xxx1')\n  call delete('Xxx2')\n  set ai&vim modeline&vim modelines&vim\nendfunc\n\n\" Test for issue #57\n\" do not move cursor on <c-o> when autoindent is set\nfunc Test_ai_CTRL_O()\n  enew!\n  set ai\n  let save_fo = &fo\n  set fo+=r\n  exe \"normal o# abcdef\\<Esc>2hi\\<CR>\\<C-O>d0\\<Esc>\"\n  exe \"normal o# abcdef\\<Esc>2hi\\<C-O>d0\\<Esc>\"\n  call assert_equal(['# abc', 'def', 'def'], getline(2, 4))\n\n  set ai&vim\n  let &fo = save_fo\n  enew!\nendfunc\n\n\" Test for autocommand that deletes the current buffer on BufLeave event.\n\" Also test deleting the last buffer, should give a new, empty buffer.\nfunc Test_BufLeave_Wipe()\n  %bwipe!\n  let content = ['start of test file Xxx',\n\t      \\ 'this is a test',\n\t      \\ 'end of test file Xxx']\n  call writefile(content, 'Xxx1')\n  call writefile(content, 'Xxx2')\n\n  au BufLeave Xxx2 bwipe\n  edit Xxx1\n  split Xxx2\n  \" delete buffer Xxx2, we should be back to Xxx1\n  bwipe\n  call assert_equal('Xxx1', bufname('%'))\n  call assert_equal(1, winnr('$'))\n\n  \" Create an alternate buffer\n  %write! test.out\n  call assert_equal('test.out', bufname('#'))\n  \" delete alternate buffer\n  bwipe test.out\n  call assert_equal('Xxx1', bufname('%'))\n  call assert_equal('', bufname('#'))\n\n  au BufLeave Xxx1 bwipe\n  \" delete current buffer, get an empty one\n  bwipe!\n  call assert_equal(1, line('$'))\n  call assert_equal('', bufname('%'))\n  let g:bufinfo = getbufinfo()\n  call assert_equal(1, len(g:bufinfo))\n\n  call delete('Xxx1')\n  call delete('Xxx2')\n  call delete('test.out')\n  %bwipe\n  au! BufLeave\n\n  \" check that bufinfo doesn't contain a pointer to freed memory\n  call test_garbagecollect_now()\nendfunc\n\nfunc Test_QuitPre()\n  edit Xfoo\n  let winid = win_getid(winnr())\n  split Xbar\n  au! QuitPre * let g:afile = expand('<afile>')\n  \" Close the other window, <afile> should be correct.\n  exe win_id2win(winid) . 'q'\n  call assert_equal('Xfoo', g:afile)\n\n  unlet g:afile\n  bwipe Xfoo\n  bwipe Xbar\nendfunc\n\nfunc Test_Cmdline()\n  au! CmdlineChanged : let g:text = getcmdline()\n  let g:text = 0\n  call feedkeys(\":echom 'hello'\\<CR>\", 'xt')\n  call assert_equal(\"echom 'hello'\", g:text)\n  au! CmdlineChanged\n\n  au! CmdlineChanged : let g:entered = expand('<afile>')\n  let g:entered = 0\n  call feedkeys(\":echom 'hello'\\<CR>\", 'xt')\n  call assert_equal(':', g:entered)\n  au! CmdlineChanged\n\n  au! CmdlineEnter : let g:entered = expand('<afile>')\n  au! CmdlineLeave : let g:left = expand('<afile>')\n  let g:entered = 0\n  let g:left = 0\n  call feedkeys(\":echo 'hello'\\<CR>\", 'xt')\n  call assert_equal(':', g:entered)\n  call assert_equal(':', g:left)\n  au! CmdlineEnter\n  au! CmdlineLeave\n\n  let save_shellslash = &shellslash\n  set noshellslash\n  au! CmdlineEnter / let g:entered = expand('<afile>')\n  au! CmdlineLeave / let g:left = expand('<afile>')\n  let g:entered = 0\n  let g:left = 0\n  new\n  call setline(1, 'hello')\n  call feedkeys(\"/hello\\<CR>\", 'xt')\n  call assert_equal('/', g:entered)\n  call assert_equal('/', g:left)\n  bwipe!\n  au! CmdlineEnter\n  au! CmdlineLeave\n  let &shellslash = save_shellslash\nendfunc\n\n\" Test for BufWritePre autocommand that deletes or unloads the buffer.\nfunc Test_BufWritePre()\n  %bwipe\n  au BufWritePre Xxx1 bunload\n  au BufWritePre Xxx2 bwipe\n\n  call writefile(['start of Xxx1', 'test', 'end of Xxx1'], 'Xxx1')\n  call writefile(['start of Xxx2', 'test', 'end of Xxx2'], 'Xxx2')\n\n  edit Xtest\n  e! Xxx2\n  bdel Xtest\n  e Xxx1\n  \" write it, will unload it and give an error msg\n  call assert_fails('w', 'E203:')\n  call assert_equal('Xxx2', bufname('%'))\n  edit Xtest\n  e! Xxx2\n  bwipe Xtest\n  \" write it, will delete the buffer and give an error msg\n  call assert_fails('w', 'E203:')\n  call assert_equal('Xxx1', bufname('%'))\n  au! BufWritePre\n  call delete('Xxx1')\n  call delete('Xxx2')\nendfunc\n\n\" Test for BufUnload autocommand that unloads all the other buffers\nfunc Test_bufunload_all()\n  let g:test_is_flaky = 1\n  call writefile(['Test file Xxx1'], 'Xxx1')\"\n  call writefile(['Test file Xxx2'], 'Xxx2')\"\n\n  let content =<< trim [CODE]\n    func UnloadAllBufs()\n      let i = 1\n      while i <= bufnr('$')\n        if i != bufnr('%') && bufloaded(i)\n          exe  i . 'bunload'\n        endif\n        let i += 1\n      endwhile\n    endfunc\n    au BufUnload * call UnloadAllBufs()\n    au VimLeave * call writefile(['Test Finished'], 'Xout')\n    edit Xxx1\n    split Xxx2\n    q\n  [CODE]\n\n  call writefile(content, 'Xtest')\n\n  call delete('Xout')\n  call system(GetVimCommandClean() .. ' -N --not-a-term -S Xtest')\n  call assert_true(filereadable('Xout'))\n\n  call delete('Xxx1')\n  call delete('Xxx2')\n  call delete('Xtest')\n  call delete('Xout')\nendfunc\n\n\" Some tests for buffer-local autocommands\nfunc Test_buflocal_autocmd()\n  let g:bname = ''\n  edit xx\n  au BufLeave <buffer> let g:bname = expand(\"%\")\n  \" here, autocommand for xx should trigger.\n  \" but autocommand shall not apply to buffer named <buffer>.\n  edit somefile\n  call assert_equal('xx', g:bname)\n  let g:bname = ''\n  \" here, autocommand shall be auto-deleted\n  bwipe xx\n  \" autocmd should not trigger\n  edit xx\n  call assert_equal('', g:bname)\n  \" autocmd should not trigger\n  edit somefile\n  call assert_equal('', g:bname)\n  enew\n  unlet g:bname\nendfunc\n\n\" Test for \"*Cmd\" autocommands\nfunc Test_Cmd_Autocmds()\n  call writefile(['start of Xxx', \"\\tabc2\", 'end of Xxx'], 'Xxx')\n\n  enew!\n  au BufReadCmd XtestA 0r Xxx|$del\n  edit XtestA\t\t\t\" will read text of Xxd instead\n  call assert_equal('start of Xxx', getline(1))\n\n  au BufWriteCmd XtestA call append(line(\"$\"), \"write\")\n  write\t\t\t\t\" will append a line to the file\n  call assert_equal('write', getline('$'))\n  call assert_fails('read XtestA', 'E484:')\t\" should not read anything\n  call assert_equal('write', getline(4))\n\n  \" now we have:\n  \" 1\tstart of Xxx\n  \" 2\t\tabc2\n  \" 3\tend of Xxx\n  \" 4\twrite\n\n  au FileReadCmd XtestB '[r Xxx\n  2r XtestB\t\t\t\" will read Xxx below line 2 instead\n  call assert_equal('start of Xxx', getline(3))\n\n  \" now we have:\n  \" 1\tstart of Xxx\n  \" 2\t\tabc2\n  \" 3\tstart of Xxx\n  \" 4\t\tabc2\n  \" 5\tend of Xxx\n  \" 6\tend of Xxx\n  \" 7\twrite\n\n  au FileWriteCmd XtestC '[,']copy $\n  normal 4GA1\n  4,5w XtestC\t\t\t\" will copy lines 4 and 5 to the end\n  call assert_equal(\"\\tabc21\", getline(8))\n  call assert_fails('r XtestC', 'E484:')\t\" should not read anything\n  call assert_equal(\"end of Xxx\", getline(9))\n\n  \" now we have:\n  \" 1\tstart of Xxx\n  \" 2\t\tabc2\n  \" 3\tstart of Xxx\n  \" 4\t\tabc21\n  \" 5\tend of Xxx\n  \" 6\tend of Xxx\n  \" 7\twrite\n  \" 8\t\tabc21\n  \" 9\tend of Xxx\n\n  let g:lines = []\n  au FileAppendCmd XtestD call extend(g:lines, getline(line(\"'[\"), line(\"']\")))\n  w >>XtestD\t\t\t\" will add lines to 'lines'\n  call assert_equal(9, len(g:lines))\n  call assert_fails('$r XtestD', 'E484:')\t\" should not read anything\n  call assert_equal(9, line('$'))\n  call assert_equal('end of Xxx', getline('$'))\n\n  au BufReadCmd XtestE 0r Xxx|$del\n  sp XtestE\t\t\t\" split window with test.out\n  call assert_equal('end of Xxx', getline(3))\n\n  let g:lines = []\n  exe \"normal 2Goasdf\\<Esc>\\<C-W>\\<C-W>\"\n  au BufWriteCmd XtestE call extend(g:lines, getline(0, '$'))\n  wall\t\t\t\t\" will write other window to 'lines'\n  call assert_equal(4, len(g:lines), g:lines)\n  call assert_equal('asdf', g:lines[2])\n\n  au! BufReadCmd\n  au! BufWriteCmd\n  au! FileReadCmd\n  au! FileWriteCmd\n  au! FileAppendCmd\n  %bwipe!\n  call delete('Xxx')\n  enew!\nendfunc\n\nfunc s:ReadFile()\n  setl noswapfile nomodified\n  let filename = resolve(expand(\"<afile>:p\"))\n  execute 'read' fnameescape(filename)\n  1d_\n  exe 'file' fnameescape(filename)\n  setl buftype=acwrite\nendfunc\n\nfunc s:WriteFile()\n  let filename = resolve(expand(\"<afile>:p\"))\n  setl buftype=\n  noautocmd execute 'write' fnameescape(filename)\n  setl buftype=acwrite\n  setl nomodified\nendfunc\n\nfunc Test_BufReadCmd()\n  autocmd BufReadCmd *.test call s:ReadFile()\n  autocmd BufWriteCmd *.test call s:WriteFile()\n\n  call writefile(['one', 'two', 'three'], 'Xcmd.test')\n  edit Xcmd.test\n  call assert_match('Xcmd.test\" line 1 of 3', execute('file'))\n  normal! Gofour\n  write\n  call assert_equal(['one', 'two', 'three', 'four'], readfile('Xcmd.test'))\n\n  bwipe!\n  call delete('Xcmd.test')\n  au! BufReadCmd\n  au! BufWriteCmd\nendfunc\n\nfunc SetChangeMarks(start, end)\n  exe a:start .. 'mark ['\n  exe a:end .. 'mark ]'\nendfunc\n\n\" Verify the effects of autocmds on '[ and ']\nfunc Test_change_mark_in_autocmds()\n  edit! Xtest\n  call feedkeys(\"ia\\<CR>b\\<CR>c\\<CR>d\\<C-g>u\\<Esc>\", 'xtn')\n\n  call SetChangeMarks(2, 3)\n  write\n  call assert_equal([1, 4], [line(\"'[\"), line(\"']\")])\n\n  call SetChangeMarks(2, 3)\n  au BufWritePre * call assert_equal([1, 4], [line(\"'[\"), line(\"']\")])\n  write\n  au! BufWritePre\n\n  if has('unix')\n    write XtestFilter\n    write >> XtestFilter\n\n    call SetChangeMarks(2, 3)\n    \" Marks are set to the entire range of the write\n    au FilterWritePre * call assert_equal([1, 4], [line(\"'[\"), line(\"']\")])\n    \" '[ is adjusted to just before the line that will receive the filtered\n    \" data\n    au FilterReadPre * call assert_equal([4, 4], [line(\"'[\"), line(\"']\")])\n    \" The filtered data is read into the buffer, and the source lines are\n    \" still present, so the range is after the source lines\n    au FilterReadPost * call assert_equal([5, 12], [line(\"'[\"), line(\"']\")])\n    %!cat XtestFilter\n    \" After the filtered data is read, the original lines are deleted\n    call assert_equal([1, 8], [line(\"'[\"), line(\"']\")])\n    au! FilterWritePre,FilterReadPre,FilterReadPost\n    undo\n\n    call SetChangeMarks(1, 4)\n    au FilterWritePre * call assert_equal([2, 3], [line(\"'[\"), line(\"']\")])\n    au FilterReadPre * call assert_equal([3, 3], [line(\"'[\"), line(\"']\")])\n    au FilterReadPost * call assert_equal([4, 11], [line(\"'[\"), line(\"']\")])\n    2,3!cat XtestFilter\n    call assert_equal([2, 9], [line(\"'[\"), line(\"']\")])\n    au! FilterWritePre,FilterReadPre,FilterReadPost\n    undo\n\n    call delete('XtestFilter')\n  endif\n\n  call SetChangeMarks(1, 4)\n  au FileWritePre * call assert_equal([2, 3], [line(\"'[\"), line(\"']\")])\n  2,3write Xtest2\n  au! FileWritePre\n\n  call SetChangeMarks(2, 3)\n  au FileAppendPre * call assert_equal([1, 4], [line(\"'[\"), line(\"']\")])\n  write >> Xtest2\n  au! FileAppendPre\n\n  call SetChangeMarks(1, 4)\n  au FileAppendPre * call assert_equal([2, 3], [line(\"'[\"), line(\"']\")])\n  2,3write >> Xtest2\n  au! FileAppendPre\n\n  call SetChangeMarks(1, 1)\n  au FileReadPre * call assert_equal([3, 1], [line(\"'[\"), line(\"']\")])\n  au FileReadPost * call assert_equal([4, 11], [line(\"'[\"), line(\"']\")])\n  3read Xtest2\n  au! FileReadPre,FileReadPost\n  undo\n\n  call SetChangeMarks(4, 4)\n  \" When the line is 0, it's adjusted to 1\n  au FileReadPre * call assert_equal([1, 4], [line(\"'[\"), line(\"']\")])\n  au FileReadPost * call assert_equal([1, 8], [line(\"'[\"), line(\"']\")])\n  0read Xtest2\n  au! FileReadPre,FileReadPost\n  undo\n\n  call SetChangeMarks(4, 4)\n  \" When the line is 0, it's adjusted to 1\n  au FileReadPre * call assert_equal([1, 4], [line(\"'[\"), line(\"']\")])\n  au FileReadPost * call assert_equal([2, 9], [line(\"'[\"), line(\"']\")])\n  1read Xtest2\n  au! FileReadPre,FileReadPost\n  undo\n\n  bwipe!\n  call delete('Xtest')\n  call delete('Xtest2')\nendfunc\n\nfunc Test_Filter_noshelltemp()\n  CheckExecutable cat\n\n  enew!\n  call setline(1, ['a', 'b', 'c', 'd'])\n\n  let shelltemp = &shelltemp\n  set shelltemp\n\n  let g:filter_au = 0\n  au FilterWritePre * let g:filter_au += 1\n  au FilterReadPre * let g:filter_au += 1\n  au FilterReadPost * let g:filter_au += 1\n  %!cat\n  call assert_equal(3, g:filter_au)\n\n  if has('filterpipe')\n    set noshelltemp\n\n    let g:filter_au = 0\n    au FilterWritePre * let g:filter_au += 1\n    au FilterReadPre * let g:filter_au += 1\n    au FilterReadPost * let g:filter_au += 1\n    %!cat\n    call assert_equal(0, g:filter_au)\n  endif\n\n  au! FilterWritePre,FilterReadPre,FilterReadPost\n  let &shelltemp = shelltemp\n  bwipe!\nendfunc\n\nfunc Test_TextYankPost()\n  enew!\n  call setline(1, ['foo'])\n\n  let g:event = []\n  au TextYankPost * let g:event = copy(v:event)\n\n  call assert_equal({}, v:event)\n  call assert_fails('let v:event = {}', 'E46:')\n  call assert_fails('let v:event.mykey = 0', 'E742:')\n\n  norm \"ayiw\n  call assert_equal(\n        \\ #{regcontents: ['foo'], regname: 'a', operator: 'y',\n        \\   regtype: 'v', visual: v:false, inclusive: v:true},\n        \\ g:event)\n  norm y_\n  call assert_equal(\n        \\ #{regcontents: ['foo'], regname: '',  operator: 'y', regtype: 'V',\n        \\   visual: v:false, inclusive: v:false},\n        \\ g:event)\n  norm Vy\n  call assert_equal(\n        \\ #{regcontents: ['foo'], regname: '',  operator: 'y', regtype: 'V',\n        \\   visual: v:true, inclusive: v:true},\n        \\ g:event)\n  call feedkeys(\"\\<C-V>y\", 'x')\n  call assert_equal(\n        \\ #{regcontents: ['f'], regname: '',  operator: 'y', regtype: \"\\x161\",\n        \\   visual: v:true, inclusive: v:true},\n        \\ g:event)\n  norm \"xciwbar\n  call assert_equal(\n        \\ #{regcontents: ['foo'], regname: 'x', operator: 'c', regtype: 'v',\n        \\   visual: v:false, inclusive: v:true},\n        \\ g:event)\n  norm \"bdiw\n  call assert_equal(\n        \\ #{regcontents: ['bar'], regname: 'b', operator: 'd', regtype: 'v',\n        \\   visual: v:false, inclusive: v:true},\n        \\ g:event)\n\n  call setline(1, 'foobar')\n  \" exclusive motion\n  norm $\"ay0\n  call assert_equal(\n        \\ #{regcontents: ['fooba'], regname: 'a', operator: 'y', regtype: 'v',\n        \\   visual: v:false, inclusive: v:false},\n        \\ g:event)\n  \" inclusive motion\n  norm 0\"ay$\n  call assert_equal(\n        \\ #{regcontents: ['foobar'], regname: 'a', operator: 'y', regtype: 'v',\n        \\   visual: v:false, inclusive: v:true},\n        \\ g:event)\n\n  call assert_equal({}, v:event)\n\n  if has('clipboard_working') && !has('gui_running')\n    \" Test that when the visual selection is automatically copied to clipboard\n    \" register a TextYankPost is emitted\n    call setline(1, ['foobar'])\n\n    let @* = ''\n    set clipboard=autoselect\n    exe \"norm! ggviw\\<Esc>\"\n    call assert_equal(\n          \\ #{regcontents: ['foobar'], regname: '*', operator: 'y',\n          \\   regtype: 'v', visual: v:true, inclusive: v:false},\n          \\ g:event)\n\n    let @+ = ''\n    set clipboard=autoselectplus\n    exe \"norm! ggviw\\<Esc>\"\n    call assert_equal(\n          \\ #{regcontents: ['foobar'], regname: '+', operator: 'y',\n          \\   regtype: 'v', visual: v:true, inclusive: v:false},\n          \\ g:event)\n\n    set clipboard&vim\n  endif\n\n  au! TextYankPost\n  unlet g:event\n  bwipe!\nendfunc\n\nfunc Test_autocommand_all_events()\n  call assert_fails('au * * bwipe', 'E1155:')\n  call assert_fails('au * x bwipe', 'E1155:')\n  call assert_fails('au! * x bwipe', 'E1155:')\nendfunc\n\nfunc Test_autocmd_user()\n  au User MyEvent let s:res = [expand(\"<afile>\"), expand(\"<amatch>\")]\n  doautocmd User MyEvent\n  call assert_equal(['MyEvent', 'MyEvent'], s:res)\n  au! User\n  unlet s:res\nendfunc\n\nfunction s:Before_test_dirchanged()\n  augroup test_dirchanged\n    autocmd!\n  augroup END\n  let s:li = []\n  let s:dir_this = getcwd()\n  let s:dir_foo = s:dir_this . '/Xfoo'\n  call mkdir(s:dir_foo)\n  let s:dir_bar = s:dir_this . '/Xbar'\n  call mkdir(s:dir_bar)\nendfunc\n\nfunction s:After_test_dirchanged()\n  call chdir(s:dir_this)\n  call delete(s:dir_foo, 'd')\n  call delete(s:dir_bar, 'd')\n  augroup test_dirchanged\n    autocmd!\n  augroup END\nendfunc\n\nfunction Test_dirchanged_global()\n  call s:Before_test_dirchanged()\n  autocmd test_dirchanged DirChangedPre global call add(s:li, expand(\"<amatch>\") .. \" pre cd \" .. v:event.directory)\n  autocmd test_dirchanged DirChanged global call add(s:li, \"cd:\")\n  autocmd test_dirchanged DirChanged global call add(s:li, expand(\"<afile>\"))\n  call chdir(s:dir_foo)\n  let expected = [\"global pre cd \" .. s:dir_foo, \"cd:\", s:dir_foo]\n  call assert_equal(expected, s:li)\n  call chdir(s:dir_foo)\n  call assert_equal(expected, s:li)\n  exe 'lcd ' .. fnameescape(s:dir_bar)\n  call assert_equal(expected, s:li)\n\n  exe 'cd ' .. s:dir_foo\n  exe 'cd ' .. s:dir_bar\n  autocmd! test_dirchanged DirChanged global let g:result = expand(\"<afile>\")\n  cd -\n  call assert_equal(s:dir_foo, substitute(g:result, '\\\\', '/', 'g'))\n\n  call s:After_test_dirchanged()\nendfunc\n\nfunction Test_dirchanged_local()\n  call s:Before_test_dirchanged()\n  autocmd test_dirchanged DirChanged window call add(s:li, \"lcd:\")\n  autocmd test_dirchanged DirChanged window call add(s:li, expand(\"<afile>\"))\n  call chdir(s:dir_foo)\n  call assert_equal([], s:li)\n  exe 'lcd ' .. fnameescape(s:dir_bar)\n  call assert_equal([\"lcd:\", s:dir_bar], s:li)\n  exe 'lcd ' .. fnameescape(s:dir_bar)\n  call assert_equal([\"lcd:\", s:dir_bar], s:li)\n  call s:After_test_dirchanged()\nendfunc\n\nfunction Test_dirchanged_auto()\n  CheckOption autochdir\n  call s:Before_test_dirchanged()\n  call test_autochdir()\n  autocmd test_dirchanged DirChangedPre auto call add(s:li, \"pre cd \" .. v:event.directory)\n  autocmd test_dirchanged DirChanged auto call add(s:li, \"auto:\")\n  autocmd test_dirchanged DirChanged auto call add(s:li, expand(\"<afile>\"))\n  set acd\n  cd ..\n  call assert_equal([], s:li)\n  exe 'edit ' . s:dir_foo . '/Xfile'\n  call assert_equal(s:dir_foo, getcwd())\n  let expected = [\"pre cd \" .. s:dir_foo, \"auto:\", s:dir_foo]\n  call assert_equal(expected, s:li)\n  set noacd\n  bwipe!\n  call s:After_test_dirchanged()\nendfunc\n\n\" Test TextChangedI and TextChangedP\nfunc Test_ChangedP()\n  new\n  call setline(1, ['foo', 'bar', 'foobar'])\n  call test_override(\"char_avail\", 1)\n  set complete=. completeopt=menuone\n\n  func! TextChangedAutocmd(char)\n    let g:autocmd .= a:char\n  endfunc\n\n  \" TextChanged will not be triggered, only check that it isn't.\n  au! TextChanged <buffer> :call TextChangedAutocmd('N')\n  au! TextChangedI <buffer> :call TextChangedAutocmd('I')\n  au! TextChangedP <buffer> :call TextChangedAutocmd('P')\n\n  call cursor(3, 1)\n  let g:autocmd = ''\n  call feedkeys(\"o\\<esc>\", 'tnix')\n  call assert_equal('I', g:autocmd)\n\n  let g:autocmd = ''\n  call feedkeys(\"Sf\", 'tnix')\n  call assert_equal('II', g:autocmd)\n\n  let g:autocmd = ''\n  call feedkeys(\"Sf\\<C-N>\", 'tnix')\n  call assert_equal('IIP', g:autocmd)\n\n  let g:autocmd = ''\n  call feedkeys(\"Sf\\<C-N>\\<C-N>\", 'tnix')\n  call assert_equal('IIPP', g:autocmd)\n\n  let g:autocmd = ''\n  call feedkeys(\"Sf\\<C-N>\\<C-N>\\<C-N>\", 'tnix')\n  call assert_equal('IIPPP', g:autocmd)\n\n  let g:autocmd = ''\n  call feedkeys(\"Sf\\<C-N>\\<C-N>\\<C-N>\\<C-N>\", 'tnix')\n  call assert_equal('IIPPPP', g:autocmd)\n\n  call assert_equal(['foo', 'bar', 'foobar', 'foo'], getline(1, '$'))\n  \" TODO: how should it handle completeopt=noinsert,noselect?\n\n  \" CleanUp\n  call test_override(\"char_avail\", 0)\n  au! TextChanged\n  au! TextChangedI\n  au! TextChangedP\n  delfu TextChangedAutocmd\n  unlet! g:autocmd\n  set complete&vim completeopt&vim\n\n  bw!\nendfunc\n\nlet g:setline_handled = v:false\nfunc SetLineOne()\n  if !g:setline_handled\n    call setline(1, \"(x)\")\n    let g:setline_handled = v:true\n  endif\nendfunc\n\nfunc Test_TextChangedI_with_setline()\n  new\n  call test_override('char_avail', 1)\n  autocmd TextChangedI <buffer> call SetLineOne()\n  call feedkeys(\"i(\\<CR>\\<Esc>\", 'tx')\n  call assert_equal('(', getline(1))\n  call assert_equal('x)', getline(2))\n  undo\n  call assert_equal('', getline(1))\n  call assert_equal('', getline(2))\n\n  call test_override('char_avail', 0)\n  bwipe!\nendfunc\n\nfunc Test_Changed_FirstTime()\n  CheckFeature terminal\n  CheckNotGui\n  \" Starting a terminal to run Vim is always considered flaky.\n  let g:test_is_flaky = 1\n\n  \" Prepare file for TextChanged event.\n  call writefile([''], 'Xchanged.txt')\n  let buf = term_start([GetVimProg(), '--clean', '-c', 'set noswapfile'], {'term_rows': 3})\n  call assert_equal('running', term_getstatus(buf))\n  \" Wait for the ruler (in the status line) to be shown.\n  \" In ConPTY, there is additional character which is drawn up to the width of\n  \" the screen.\n  if has('conpty')\n    call WaitForAssert({-> assert_match('\\<All.*$', term_getline(buf, 3))})\n  else\n    call WaitForAssert({-> assert_match('\\<All$', term_getline(buf, 3))})\n  endif\n  \" It's only adding autocmd, so that no event occurs.\n  call term_sendkeys(buf, \":au! TextChanged <buffer> call writefile(['No'], 'Xchanged.txt')\\<cr>\")\n  call term_sendkeys(buf, \"\\<C-\\\\>\\<C-N>:qa!\\<cr>\")\n  call WaitForAssert({-> assert_equal('finished', term_getstatus(buf))})\n  call assert_equal([''], readfile('Xchanged.txt'))\n\n  \" clean up\n  call delete('Xchanged.txt')\n  bwipe!\nendfunc\n\nfunc Test_autocmd_nested()\n  let g:did_nested = 0\n  augroup Testing\n    au WinNew * edit somefile\n    au BufNew * let g:did_nested = 1\n  augroup END\n  split\n  call assert_equal(0, g:did_nested)\n  close\n  bwipe! somefile\n\n  \" old nested argument still works\n  augroup Testing\n    au!\n    au WinNew * nested edit somefile\n    au BufNew * let g:did_nested = 1\n  augroup END\n  split\n  call assert_equal(1, g:did_nested)\n  close\n  bwipe! somefile\n\n  \" New ++nested argument works\n  augroup Testing\n    au!\n    au WinNew * ++nested edit somefile\n    au BufNew * let g:did_nested = 1\n  augroup END\n  split\n  call assert_equal(1, g:did_nested)\n  close\n  bwipe! somefile\n\n  \" nested without ++ does not work in Vim9 script\n  call assert_fails('vim9cmd au WinNew * nested echo fails', 'E1078:')\n\n  augroup Testing\n    au!\n  augroup END\n\n  call assert_fails('au WinNew * ++nested ++nested echo bad', 'E983:')\n  call assert_fails('au WinNew * nested nested echo bad', 'E983:')\nendfunc\n\nfunc Test_autocmd_nested_cursor_invalid()\n  set laststatus=0\n  copen\n  cclose\n  call setline(1, ['foo', 'bar', 'baz'])\n  3\n  augroup nested_inv\n    autocmd User foo ++nested copen\n    autocmd BufAdd * let &laststatus = 2 - &laststatus\n  augroup END\n  doautocmd User foo\n\n  augroup nested_inv\n    au!\n  augroup END\n  set laststatus&\n  bwipe!\nendfunc\n\nfunc Test_autocmd_once()\n  \" Without ++once WinNew triggers twice\n  let g:did_split = 0\n  augroup Testing\n    au WinNew * let g:did_split += 1\n  augroup END\n  split\n  split\n  call assert_equal(2, g:did_split)\n  call assert_true(exists('#WinNew'))\n  close\n  close\n\n  \" With ++once WinNew triggers once\n  let g:did_split = 0\n  augroup Testing\n    au!\n    au WinNew * ++once let g:did_split += 1\n  augroup END\n  split\n  split\n  call assert_equal(1, g:did_split)\n  call assert_false(exists('#WinNew'))\n  close\n  close\n\n  call assert_fails('au WinNew * ++once ++once echo bad', 'E983:')\nendfunc\n\nfunc Test_autocmd_bufreadpre()\n  new\n  let b:bufreadpre = 1\n  call append(0, range(1000))\n  w! XAutocmdBufReadPre.txt\n  autocmd BufReadPre <buffer> :let b:bufreadpre += 1\n  norm! 500gg\n  sp\n  norm! 1000gg\n  wincmd p\n  let g:wsv1 = winsaveview()\n  wincmd p\n  let g:wsv2 = winsaveview()\n  \" triggers BufReadPre, should not move the cursor in either window\n  \" The topline may change one line in a large window.\n  edit\n  call assert_inrange(g:wsv2.topline - 1, g:wsv2.topline + 1, winsaveview().topline)\n  call assert_equal(g:wsv2.lnum, winsaveview().lnum)\n  call assert_equal(2, b:bufreadpre)\n  wincmd p\n  call assert_equal(g:wsv1.topline, winsaveview().topline)\n  call assert_equal(g:wsv1.lnum, winsaveview().lnum)\n  call assert_equal(2, b:bufreadpre)\n  \" Now set the cursor position in an BufReadPre autocommand\n  \" (even though the position will be invalid, this should make Vim reset the\n  \" cursor position in the other window.\n  wincmd p\n  set cpo+=g\n  \" won't do anything, but try to set the cursor on an invalid lnum\n  autocmd BufReadPre <buffer> :norm! 70gg\n  \" triggers BufReadPre, should not move the cursor in either window\n  e\n  call assert_equal(1, winsaveview().topline)\n  call assert_equal(1, winsaveview().lnum)\n  call assert_equal(3, b:bufreadpre)\n  wincmd p\n  call assert_equal(g:wsv1.topline, winsaveview().topline)\n  call assert_equal(g:wsv1.lnum, winsaveview().lnum)\n  call assert_equal(3, b:bufreadpre)\n  close\n  close\n  call delete('XAutocmdBufReadPre.txt')\n  set cpo-=g\nendfunc\n\n\" FileChangedShell tested in test_filechanged.vim\n\n\" Tests for the following autocommands:\n\" - FileWritePre\twriting a compressed file\n\" - FileReadPost\treading a compressed file\n\" - BufNewFile\t\treading a file template\n\" - BufReadPre\t\tdecompressing the file to be read\n\" - FilterReadPre\tsubstituting characters in the temp file\n\" - FilterReadPost\tsubstituting characters after filtering\n\" - FileReadPre\t\tset options for decompression\n\" - FileReadPost\tdecompress the file\nfunc Test_ReadWrite_Autocmds()\n  \" Run this test only on Unix-like systems and if gzip is available\n  CheckUnix\n  CheckExecutable gzip\n\n  \" Make $GZIP empty, \"-v\" would cause trouble.\n  let $GZIP = \"\"\n\n  \" Use a FileChangedShell autocommand to avoid a prompt for 'Xtestfile.gz'\n  \" being modified outside of Vim (noticed on Solaris).\n  au FileChangedShell * echo 'caught FileChangedShell'\n\n  \" Test for the FileReadPost, FileWritePre and FileWritePost autocmds\n  augroup Test1\n    au!\n    au FileWritePre    *.gz   '[,']!gzip\n    au FileWritePost   *.gz   undo\n    au FileReadPost    *.gz   '[,']!gzip -d\n  augroup END\n\n  new\n  set bin\n  call append(0, [\n\t      \\ 'line 2\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 3\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 4\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 5\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 6\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 7\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 8\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 9\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 10 Abcdefghijklmnopqrstuvwxyz'\n\t      \\ ])\n  1,9write! Xtestfile.gz\n  enew! | close\n\n  new\n  \" Read and decompress the testfile\n  0read Xtestfile.gz\n  call assert_equal([\n\t      \\ 'line 2\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 3\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 4\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 5\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 6\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 7\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 8\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 9\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 10 Abcdefghijklmnopqrstuvwxyz'\n\t      \\ ], getline(1, 9))\n  enew! | close\n\n  augroup Test1\n    au!\n  augroup END\n\n  \" Test for the FileAppendPre and FileAppendPost autocmds\n  augroup Test2\n    au!\n    au BufNewFile      *.c    read Xtest.c\n    au FileAppendPre   *.out  '[,']s/new/NEW/\n    au FileAppendPost  *.out  !cat Xtest.c >> test.out\n  augroup END\n\n  call writefile(['/*', ' * Here is a new .c file', ' */'], 'Xtest.c')\n  new foo.c\t\t\t\" should load Xtest.c\n  call assert_equal(['/*', ' * Here is a new .c file', ' */'], getline(2, 4))\n  w! >> test.out\t\t\" append it to the output file\n\n  let contents = readfile('test.out')\n  call assert_equal(' * Here is a NEW .c file', contents[2])\n  call assert_equal(' * Here is a new .c file', contents[5])\n\n  call delete('test.out')\n  enew! | close\n  augroup Test2\n    au!\n  augroup END\n\n  \" Test for the BufReadPre and BufReadPost autocmds\n  augroup Test3\n    au!\n    \" setup autocommands to decompress before reading and re-compress\n    \" afterwards\n    au BufReadPre  *.gz  exe '!gzip -d ' . shellescape(expand(\"<afile>\"))\n    au BufReadPre  *.gz  call rename(expand(\"<afile>:r\"), expand(\"<afile>\"))\n    au BufReadPost *.gz  call rename(expand(\"<afile>\"), expand(\"<afile>:r\"))\n    au BufReadPost *.gz  exe '!gzip ' . shellescape(expand(\"<afile>:r\"))\n  augroup END\n\n  e! Xtestfile.gz\t\t\" Edit compressed file\n  call assert_equal([\n\t      \\ 'line 2\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 3\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 4\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 5\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 6\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 7\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 8\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 9\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 10 Abcdefghijklmnopqrstuvwxyz'\n\t      \\ ], getline(1, 9))\n\n  w! >> test.out\t\t\" Append it to the output file\n\n  augroup Test3\n    au!\n  augroup END\n\n  \" Test for the FilterReadPre and FilterReadPost autocmds.\n  set shelltemp\t\t\t\" need temp files here\n  augroup Test4\n    au!\n    au FilterReadPre   *.out  call rename(expand(\"<afile>\"), expand(\"<afile>\") . \".t\")\n    au FilterReadPre   *.out  exe 'silent !sed s/e/E/ ' . shellescape(expand(\"<afile>\")) . \".t >\" . shellescape(expand(\"<afile>\"))\n    au FilterReadPre   *.out  exe 'silent !rm ' . shellescape(expand(\"<afile>\")) . '.t'\n    au FilterReadPost  *.out  '[,']s/x/X/g\n  augroup END\n\n  e! test.out\t\t\t\" Edit the output file\n  1,$!cat\n  call assert_equal([\n\t      \\ 'linE 2\tAbcdefghijklmnopqrstuvwXyz',\n\t      \\ 'linE 3\tXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX',\n\t      \\ 'linE 4\tAbcdefghijklmnopqrstuvwXyz',\n\t      \\ 'linE 5\tXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX',\n\t      \\ 'linE 6\tAbcdefghijklmnopqrstuvwXyz',\n\t      \\ 'linE 7\tXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX',\n\t      \\ 'linE 8\tAbcdefghijklmnopqrstuvwXyz',\n\t      \\ 'linE 9\tXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX',\n\t      \\ 'linE 10 AbcdefghijklmnopqrstuvwXyz'\n\t      \\ ], getline(1, 9))\n  call assert_equal([\n\t      \\ 'line 2\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 3\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 4\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 5\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 6\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 7\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 8\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 9\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 10 Abcdefghijklmnopqrstuvwxyz'\n\t      \\ ], readfile('test.out'))\n\n  augroup Test4\n    au!\n  augroup END\n  set shelltemp&vim\n\n  \" Test for the FileReadPre and FileReadPost autocmds.\n  augroup Test5\n    au!\n    au FileReadPre *.gz exe 'silent !gzip -d ' . shellescape(expand(\"<afile>\"))\n    au FileReadPre *.gz call rename(expand(\"<afile>:r\"), expand(\"<afile>\"))\n    au FileReadPost *.gz '[,']s/l/L/\n  augroup END\n\n  new\n  0r Xtestfile.gz\t\t\" Read compressed file\n  call assert_equal([\n\t      \\ 'Line 2\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'Line 3\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'Line 4\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'Line 5\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'Line 6\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'Line 7\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'Line 8\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'Line 9\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'Line 10 Abcdefghijklmnopqrstuvwxyz'\n\t      \\ ], getline(1, 9))\n  call assert_equal([\n\t      \\ 'line 2\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 3\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 4\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 5\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 6\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 7\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 8\tAbcdefghijklmnopqrstuvwxyz',\n\t      \\ 'line 9\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n\t      \\ 'line 10 Abcdefghijklmnopqrstuvwxyz'\n\t      \\ ], readfile('Xtestfile.gz'))\n\n  augroup Test5\n    au!\n  augroup END\n\n  au! FileChangedShell\n  call delete('Xtestfile.gz')\n  call delete('Xtest.c')\n  call delete('test.out')\nendfunc\n\nfunc Test_throw_in_BufWritePre()\n  new\n  call setline(1, ['one', 'two', 'three'])\n  call assert_false(filereadable('Xthefile'))\n  augroup throwing\n    au BufWritePre X* throw 'do not write'\n  augroup END\n  try\n    w Xthefile\n  catch\n    let caught = 1\n  endtry\n  call assert_equal(1, caught)\n  call assert_false(filereadable('Xthefile'))\n\n  bwipe!\n  au! throwing\nendfunc\n\nfunc Test_autocmd_in_try_block()\n  call mkdir('Xdir')\n  au BufEnter * let g:fname = expand('%')\n  try\n    edit Xdir/\n  endtry\n  call assert_match('Xdir', g:fname)\n\n  unlet g:fname\n  au! BufEnter\n  call delete('Xdir', 'rf')\nendfunc\n\nfunc Test_autocmd_SafeState()\n  CheckRunVimInTerminal\n  let g:test_is_flaky = 1\n\n  let lines =<< trim END\n\tlet g:safe = 0\n\tlet g:again = ''\n\tau SafeState * let g:safe += 1\n\tau SafeStateAgain * let g:again ..= 'x'\n\tfunc CallTimer()\n\t  call timer_start(10, {id -> execute('let g:again ..= \"t\"')})\n\tendfunc\n  END\n  call writefile(lines, 'XSafeState')\n  let buf = RunVimInTerminal('-S XSafeState', #{rows: 6})\n\n  \" Sometimes we loop to handle a K_IGNORE, SafeState may be triggered once or\n  \" more often.\n  call term_sendkeys(buf, \":echo g:safe\\<CR>\")\n  call WaitForAssert({-> assert_match('^\\d ', term_getline(buf, 6))}, 1000)\n\n  \" SafeStateAgain should be invoked at least three times\n  call term_sendkeys(buf, \":echo g:again\\<CR>\")\n  call WaitForAssert({-> assert_match('^xxx', term_getline(buf, 6))}, 1000)\n\n  call term_sendkeys(buf, \":let g:again = ''\\<CR>:call CallTimer()\\<CR>\")\n  call TermWait(buf, 50)\n  call term_sendkeys(buf, \":\\<CR>\")\n  call TermWait(buf, 50)\n  call term_sendkeys(buf, \":echo g:again\\<CR>\")\n  call WaitForAssert({-> assert_match('xtx', term_getline(buf, 6))}, 1000)\n\n  call StopVimInTerminal(buf)\n  call delete('XSafeState')\nendfunc\n\nfunc Test_autocmd_CmdWinEnter()\n  CheckRunVimInTerminal\n  CheckFeature cmdwin\n\n  let lines =<< trim END\n    augroup vimHints | au! | augroup END\n    let b:dummy_var = 'This is a dummy'\n    autocmd CmdWinEnter * quit\n    let winnr = winnr('$')\n  END\n  let filename = 'XCmdWinEnter'\n  call writefile(lines, filename)\n  let buf = RunVimInTerminal('-S '.filename, #{rows: 6})\n\n  call term_sendkeys(buf, \"q:\")\n  call TermWait(buf)\n  call term_sendkeys(buf, \":echo b:dummy_var\\<cr>\")\n  call WaitForAssert({-> assert_match('^This is a dummy', term_getline(buf, 6))}, 2000)\n  call term_sendkeys(buf, \":echo &buftype\\<cr>\")\n  call WaitForAssert({-> assert_notmatch('^nofile', term_getline(buf, 6))}, 1000)\n  call term_sendkeys(buf, \":echo winnr\\<cr>\")\n  call WaitForAssert({-> assert_match('^1', term_getline(buf, 6))}, 1000)\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete(filename)\nendfunc\n\nfunc Test_autocmd_was_using_freed_memory()\n  CheckFeature quickfix\n\n  pedit xx\n  n x\n  augroup winenter\n    au WinEnter * if winnr('$') > 2 | quit | endif\n  augroup END\n  split\n\n  augroup winenter\n    au! WinEnter\n  augroup END\n\n  bwipe xx\n  bwipe x\n  pclose\nendfunc\n\nfunc Test_BufWrite_lockmarks()\n  let g:test_is_flaky = 1\n  edit! Xtest\n  call setline(1, ['a', 'b', 'c', 'd'])\n\n  \" :lockmarks preserves the marks\n  call SetChangeMarks(2, 3)\n  lockmarks write\n  call assert_equal([2, 3], [line(\"'[\"), line(\"']\")])\n\n  \" *WritePre autocmds get the correct line range, but lockmarks preserves the\n  \" original values for the user\n  augroup lockmarks\n    au!\n    au BufWritePre,FilterWritePre * call assert_equal([1, 4], [line(\"'[\"), line(\"']\")])\n    au FileWritePre * call assert_equal([3, 4], [line(\"'[\"), line(\"']\")])\n  augroup END\n\n  lockmarks write\n  call assert_equal([2, 3], [line(\"'[\"), line(\"']\")])\n\n  if executable('cat')\n    lockmarks %!cat\n    call assert_equal([2, 3], [line(\"'[\"), line(\"']\")])\n  endif\n\n  lockmarks 3,4write Xtest2\n  call assert_equal([2, 3], [line(\"'[\"), line(\"']\")])\n\n  au! lockmarks\n  augroup! lockmarks\n  call delete('Xtest')\n  call delete('Xtest2')\nendfunc\n\nfunc Test_FileType_spell()\n  if !isdirectory('/tmp')\n    throw \"Skipped: requires /tmp directory\"\n  endif\n\n  \" this was crashing with an invalid free()\n  setglobal spellfile=/tmp/en.utf-8.add\n  augroup crash\n    autocmd!\n    autocmd BufNewFile,BufReadPost crashfile setf somefiletype\n    autocmd BufNewFile,BufReadPost crashfile set ft=anotherfiletype\n    autocmd FileType anotherfiletype setlocal spell\n  augroup END\n  func! NoCrash() abort\n    edit /tmp/crashfile\n  endfunc\n  call NoCrash()\n\n  au! crash\n  setglobal spellfile=\nendfunc\n\n\" Test closing a window or editing another buffer from a FileChangedRO handler\n\" in a readonly buffer\nfunc Test_FileChangedRO_winclose()\n  call test_override('ui_delay', 10)\n\n  augroup FileChangedROTest\n    au!\n    autocmd FileChangedRO * quit\n  augroup END\n  new\n  set readonly\n  call assert_fails('normal i', 'E788:')\n  close\n  augroup! FileChangedROTest\n\n  augroup FileChangedROTest\n    au!\n    autocmd FileChangedRO * edit Xfile\n  augroup END\n  new\n  set readonly\n  call assert_fails('normal i', 'E788:')\n  close\n  augroup! FileChangedROTest\n  call test_override('ALL', 0)\nendfunc\n\nfunc LogACmd()\n  call add(g:logged, line('$'))\nendfunc\n\nfunc Test_TermChanged()\n  CheckNotGui\n\n  enew!\n  tabnew\n  call setline(1, ['a', 'b', 'c', 'd'])\n  $\n  au TermChanged * call LogACmd()\n  let g:logged = []\n  let term_save = &term\n  set term=xterm\n  call assert_equal([1, 4], g:logged)\n\n  au! TermChanged\n  let &term = term_save\n  bwipe!\nendfunc\n\n\" Test for FileReadCmd autocmd\nfunc Test_autocmd_FileReadCmd()\n  func ReadFileCmd()\n    call append(line('$'), \"v:cmdarg = \" .. v:cmdarg)\n  endfunc\n  augroup FileReadCmdTest\n    au!\n    au FileReadCmd Xtest call ReadFileCmd()\n  augroup END\n\n  new\n  read ++bin Xtest\n  read ++nobin Xtest\n  read ++edit Xtest\n  read ++bad=keep Xtest\n  read ++bad=drop Xtest\n  read ++bad=- Xtest\n  read ++ff=unix Xtest\n  read ++ff=dos Xtest\n  read ++ff=mac Xtest\n  read ++enc=utf-8 Xtest\n\n  call assert_equal(['',\n        \\ 'v:cmdarg =  ++bin',\n        \\ 'v:cmdarg =  ++nobin',\n        \\ 'v:cmdarg =  ++edit',\n        \\ 'v:cmdarg =  ++bad=keep',\n        \\ 'v:cmdarg =  ++bad=drop',\n        \\ 'v:cmdarg =  ++bad=-',\n        \\ 'v:cmdarg =  ++ff=unix',\n        \\ 'v:cmdarg =  ++ff=dos',\n        \\ 'v:cmdarg =  ++ff=mac',\n        \\ 'v:cmdarg =  ++enc=utf-8'], getline(1, '$'))\n\n  close!\n  augroup FileReadCmdTest\n    au!\n  augroup END\n  delfunc ReadFileCmd\nendfunc\n\n\" Test for passing invalid arguments to autocmd\nfunc Test_autocmd_invalid_args()\n  \" Additional character after * for event\n  call assert_fails('autocmd *a Xfile set ff=unix', 'E215:')\n  augroup Test\n  augroup END\n  \" Invalid autocmd event\n  call assert_fails('autocmd Bufabc Xfile set ft=vim', 'E216:')\n  \" Invalid autocmd event in a autocmd group\n  call assert_fails('autocmd Test Bufabc Xfile set ft=vim', 'E216:')\n  augroup! Test\n  \" Execute all autocmds\n  call assert_fails('doautocmd * BufEnter', 'E217:')\n  call assert_fails('augroup! x1a2b3', 'E367:')\n  call assert_fails('autocmd BufNew <buffer=999> pwd', 'E680:')\n  call assert_fails('autocmd BufNew \\) set ff=unix', 'E55:')\nendfunc\n\n\" Test for deep nesting of autocmds\nfunc Test_autocmd_deep_nesting()\n  autocmd BufEnter Xfile doautocmd BufEnter Xfile\n  call assert_fails('doautocmd BufEnter Xfile', 'E218:')\n  autocmd! BufEnter Xfile\nendfunc\n\n\" Tests for SigUSR1 autocmd event, which is only available on posix systems.\nfunc Test_autocmd_sigusr1()\n  CheckUnix\n  CheckExecutable /bin/kill\n\n  let g:sigusr1_passed = 0\n  au SigUSR1 * let g:sigusr1_passed = 1\n  call system('/bin/kill -s usr1 ' . getpid())\n  call WaitForAssert({-> assert_true(g:sigusr1_passed)})\n\n  au! SigUSR1\n  unlet g:sigusr1_passed\nendfunc\n\n\" Test for BufReadPre autocmd deleting the file\nfunc Test_BufReadPre_delfile()\n  augroup TestAuCmd\n    au!\n    autocmd BufReadPre Xfile call delete('Xfile')\n  augroup END\n  call writefile([], 'Xfile')\n  call assert_fails('new Xfile', 'E200:')\n  call assert_equal('Xfile', @%)\n  call assert_equal(1, &readonly)\n  call delete('Xfile')\n  augroup TestAuCmd\n    au!\n  augroup END\n  close!\nendfunc\n\n\" Test for BufReadPre autocmd changing the current buffer\nfunc Test_BufReadPre_changebuf()\n  augroup TestAuCmd\n    au!\n    autocmd BufReadPre Xfile edit Xsomeotherfile\n  augroup END\n  call writefile([], 'Xfile')\n  call assert_fails('new Xfile', 'E201:')\n  call assert_equal('Xsomeotherfile', @%)\n  call assert_equal(1, &readonly)\n  call delete('Xfile')\n  augroup TestAuCmd\n    au!\n  augroup END\n  close!\nendfunc\n\n\" Test for BufWipeouti autocmd changing the current buffer when reading a file\n\" in an empty buffer with 'f' flag in 'cpo'\nfunc Test_BufDelete_changebuf()\n  new\n  augroup TestAuCmd\n    au!\n    autocmd BufWipeout * let bufnr = bufadd('somefile') | exe \"b \" .. bufnr\n  augroup END\n  let save_cpo = &cpo\n  set cpo+=f\n  call assert_fails('r Xfile', ['E812:', 'E484:'])\n  call assert_equal('somefile', @%)\n  let &cpo = save_cpo\n  augroup TestAuCmd\n    au!\n  augroup END\n  close!\nendfunc\n\n\" Test for the temporary internal window used to execute autocmds\nfunc Test_autocmd_window()\n  %bw!\n  edit one.txt\n  tabnew two.txt\n  vnew three.txt\n  tabnew four.txt\n  tabprevious\n  let g:blist = []\n  augroup aucmd_win_test1\n    au!\n    au BufEnter * call add(g:blist, [expand('<afile>'),\n          \\ win_gettype(bufwinnr(expand('<afile>')))])\n  augroup END\n\n  doautoall BufEnter\n  call assert_equal([\n        \\ ['one.txt', 'autocmd'],\n        \\ ['two.txt', ''],\n        \\ ['four.txt', 'autocmd'],\n        \\ ['three.txt', ''],\n        \\ ], g:blist)\n\n  augroup aucmd_win_test1\n    au!\n  augroup END\n  augroup! aucmd_win_test1\n  %bw!\nendfunc\n\n\" Test for trying to close the temporary window used for executing an autocmd\nfunc Test_close_autocmd_window()\n  %bw!\n  edit one.txt\n  tabnew two.txt\n  augroup aucmd_win_test2\n    au!\n    au BufEnter * if expand('<afile>') == 'one.txt' | 1close | endif\n  augroup END\n\n  call assert_fails('doautoall BufEnter', 'E813:')\n\n  augroup aucmd_win_test2\n    au!\n  augroup END\n  augroup! aucmd_win_test2\n  %bwipe!\nendfunc\n\n\" Test for trying to close the tab that has the temporary window for exeucing\n\" an autocmd.\nfunc Test_close_autocmd_tab()\n  edit one.txt\n  tabnew two.txt\n   augroup aucmd_win_test\n    au!\n    au BufEnter * if expand('<afile>') == 'one.txt' | tabfirst | tabonly | endif\n  augroup END\n\n  call assert_fails('doautoall BufEnter', 'E813:')\n\n  tabonly\n  augroup aucmd_win_test\n    au!\n  augroup END\n  augroup! aucmd_win_test\n  %bwipe!\nendfunc\n\nfunc Test_Visual_doautoall_redraw()\n  call setline(1, ['a', 'b'])\n  new \n  wincmd p\n  call feedkeys(\"G\\<C-V>\", 'txn')\n  autocmd User Explode ++once redraw\n  doautoall User Explode\n  %bwipe!\nendfunc\n\n\" This was using freed memory.\nfunc Test_BufNew_arglocal()\n  arglocal\n  au BufNew * arglocal\n  call assert_fails('drop xx', 'E1156:')\n\n  au! BufNew\nendfunc\n\nfunc Test_autocmd_closes_window()\n  au BufNew,BufWinLeave * e %e\n  file yyy\n  au BufNew,BufWinLeave * ball\n  n xxx\n\n  %bwipe\n  au! BufNew\n  au! BufWinLeave\nendfunc\n\nfunc Test_autocmd_quit_psearch()\n  sn aa bb\n  augroup aucmd_win_test\n    au!\n    au BufEnter,BufLeave,BufNew,WinEnter,WinLeave,WinNew * if winnr('$') > 1 | q | endif\n  augroup END\n  ps /\n\n  augroup aucmd_win_test\n    au!\n  augroup END\n  new\n  pclose\nendfunc\n\n\" Fuzzer found some strange combination that caused a crash.\nfunc Test_autocmd_normal_mess()\n  \" For unknown reason this hangs on MS-Windows\n  CheckNotMSWindows\n\n  augroup aucmd_normal_test\n    au BufLeave,BufWinLeave,BufHidden,BufUnload,BufDelete,BufWipeout * norm 7q/qc\n  augroup END\n  call assert_fails('o4', 'E1159')\n  silent! H\n  call assert_fails('e xx', 'E1159')\n  normal G\n\n  augroup aucmd_normal_test\n    au!\n  augroup END\nendfunc\n\nfunc Test_autocmd_closing_cmdwin()\n  \" For unknown reason this hangs on MS-Windows\n  CheckNotMSWindows\n\n  au BufWinLeave * nested q\n  call assert_fails(\"norm 7q?\\n\", 'E855:')\n\n  au! BufWinLeave\n  new\n  only\nendfunc\n\nfunc Test_autocmd_vimgrep()\n  augroup aucmd_vimgrep\n    au QuickfixCmdPre,BufNew,BufReadCmd * sb\n    au QuickfixCmdPre,BufNew,BufReadCmd * q9\n  augroup END\n  call assert_fails('lv ?a? foo', 'E926:')\n\n  augroup aucmd_vimgrep\n    au!\n  augroup END\nendfunc\n\nfunc Test_autocmd_with_block()\n  augroup block_testing\n    au BufReadPost *.xml {\n            setlocal matchpairs+=<:>\n            /<start\n          }\n    au CursorHold * {\n        autocmd BufReadPre * ++once echo 'one' | echo 'two'\n        g:gotSafeState = 77\n      }\n  augroup END\n\n  let expected = \"\\n--- Autocommands ---\\nblock_testing  BufRead\\n    *.xml     {^@            setlocal matchpairs+=<:>^@            /<start^@          }\"\n  call assert_equal(expected, execute('au BufReadPost *.xml'))\n\n  doautocmd CursorHold\n  call assert_equal(77, g:gotSafeState)\n  unlet g:gotSafeState\n\n  augroup block_testing\n    au!\n    autocmd CursorHold * {\n      if true\n        # comment\n        && true\n\n        && true\n        g:done = 'yes'\n      endif\n      }\n  augroup END\n  doautocmd CursorHold\n  call assert_equal('yes', g:done)\n\n  unlet g:done\n  augroup block_testing\n    au!\n  augroup END\nendfunc\n\n\" Test TextChangedI and TextChanged\nfunc Test_Changed_ChangedI()\n  new\n  call test_override(\"char_avail\", 1)\n  let [g:autocmd_i, g:autocmd_n] = ['','']\n\n  func! TextChangedAutocmdI(char)\n    let g:autocmd_{tolower(a:char)} = a:char .. b:changedtick\n  endfunc\n\n  augroup Test_TextChanged\n    au!\n    au TextChanged  <buffer> :call TextChangedAutocmdI('N')\n    au TextChangedI <buffer> :call TextChangedAutocmdI('I')\n  augroup END\n\n  call feedkeys(\"ifoo\\<esc>\", 'tnix')\n  \" TODO: Test test does not seem to trigger TextChanged autocommand, this\n  \" requires running Vim in a terminal window.\n  \" call assert_equal('N3', g:autocmd_n)\n  call assert_equal('I3', g:autocmd_i)\n\n  call feedkeys(\"yyp\", 'tnix')\n  \" TODO: Test test does not seem to trigger TextChanged autocommand.\n  \" call assert_equal('N4', g:autocmd_n)\n  call assert_equal('I3', g:autocmd_i)\n\n  \" CleanUp\n  call test_override(\"char_avail\", 0)\n  au! TextChanged  <buffer>\n  au! TextChangedI <buffer>\n  augroup! Test_TextChanged\n  delfu TextChangedAutocmdI\n  unlet! g:autocmd_i g:autocmd_n\n\n  bw!\nendfunc\n\nfunc Test_closing_autocmd_window()\n  let lines =<< trim END\n      edit Xa.txt\n      tabnew Xb.txt\n      autocmd BufEnter Xa.txt unhide 1\n      doautoall BufEnter\n  END\n  call v9.CheckScriptFailure(lines, 'E814:')\n  au! BufEnter\n  only!\n  bwipe Xa.txt\n  bwipe Xb.txt\nendfunc\n\nfunc Test_bufwipeout_changes_window()\n  \" This should not crash, but we don't have any expectations about what\n  \" happens, changing window in BufWipeout has unpredictable results.\n  tabedit\n  let g:window_id = win_getid()\n  topleft new\n  setlocal bufhidden=wipe\n  autocmd BufWipeout <buffer> call win_gotoid(g:window_id)\n  tabprevious\n  +tabclose\n\n  unlet g:window_id\n  au! BufWipeout\n  %bwipe!\nendfunc\n\nfunc Test_v_event_readonly()\n  autocmd CompleteChanged * let v:event.width = 0\n  call assert_fails(\"normal! i\\<C-X>\\<C-V>\", 'E46:')\n  au! CompleteChanged\n\n  autocmd DirChangedPre * let v:event.directory = ''\n  call assert_fails('cd .', 'E46:')\n  au! DirChangedPre\n\n  autocmd ModeChanged * let v:event.new_mode = ''\n  call assert_fails('normal! cc', 'E46:')\n  au! ModeChanged\n\n  autocmd TextYankPost * let v:event.operator = ''\n  call assert_fails('normal! yy', 'E46:')\n  au! TextYankPost\nendfunc\n\n\nfunc Test_noname_autocmd()\n  augroup test_noname_autocmd_group\n    autocmd!\n    autocmd BufEnter * call add(s:li, [\"BufEnter\", expand(\"<afile>\")])\n    autocmd BufDelete * call add(s:li, [\"BufDelete\", expand(\"<afile>\")])\n    autocmd BufLeave * call add(s:li, [\"BufLeave\", expand(\"<afile>\")])\n    autocmd BufUnload * call add(s:li, [\"BufUnload\", expand(\"<afile>\")])\n    autocmd BufWipeout * call add(s:li, [\"BufWipeout\", expand(\"<afile>\")])\n  augroup END\n\n  let s:li = []\n  edit foo\n  call assert_equal([['BufUnload', ''], ['BufDelete', ''], ['BufWipeout', ''], ['BufEnter', 'foo']], s:li)\n\n  au! test_noname_autocmd_group\n  augroup! test_noname_autocmd_group\nendfunc\n\n\" Test for the autocmd_get() function\nfunc Test_autocmd_get()\n  augroup TestAutoCmdFns\n    au!\n    autocmd BufAdd *.vim echo \"bufadd-vim\"\n    autocmd BufAdd *.py echo \"bufadd-py\"\n    autocmd BufHidden *.vim echo \"bufhidden\"\n  augroup END\n  augroup TestAutoCmdFns2\n    autocmd BufAdd *.vim echo \"bufadd-vim-2\"\n    autocmd BufRead *.a1b2c3 echo \"bufadd-vim-2\"\n  augroup END\n\n  let l = autocmd_get()\n  call assert_true(l->len() > 0)\n\n  \" Test for getting all the autocmds in a group\n  let expected = [\n        \\ #{cmd: 'echo \"bufadd-vim\"', group: 'TestAutoCmdFns',\n        \\  pattern: '*.vim', nested: v:false, once: v:false,\n        \\  event: 'BufAdd'},\n        \\ #{cmd: 'echo \"bufadd-py\"', group: 'TestAutoCmdFns',\n        \\  pattern: '*.py', nested: v:false, once: v:false,\n        \\  event: 'BufAdd'},\n        \\ #{cmd: 'echo \"bufhidden\"', group: 'TestAutoCmdFns',\n        \\  pattern: '*.vim', nested: v:false,\n        \\  once: v:false, event: 'BufHidden'}]\n  call assert_equal(expected, autocmd_get(#{group: 'TestAutoCmdFns'}))\n\n  \" Test for getting autocmds for all the patterns in a group\n  call assert_equal(expected, autocmd_get(#{group: 'TestAutoCmdFns',\n        \\ event: '*'}))\n\n  \" Test for getting autocmds for an event in a group\n  let expected = [\n        \\ #{cmd: 'echo \"bufadd-vim\"', group: 'TestAutoCmdFns',\n        \\  pattern: '*.vim', nested: v:false, once: v:false,\n        \\  event: 'BufAdd'},\n        \\ #{cmd: 'echo \"bufadd-py\"', group: 'TestAutoCmdFns',\n        \\  pattern: '*.py', nested: v:false, once: v:false,\n        \\  event: 'BufAdd'}]\n  call assert_equal(expected, autocmd_get(#{group: 'TestAutoCmdFns',\n        \\ event: 'BufAdd'}))\n\n  \" Test for getting the autocmds for all the events in a group for particular\n  \" pattern\n  call assert_equal([{'cmd': 'echo \"bufadd-py\"', 'group': 'TestAutoCmdFns',\n        \\ 'pattern': '*.py', 'nested': v:false, 'once': v:false,\n        \\ 'event': 'BufAdd'}],\n        \\ autocmd_get(#{group: 'TestAutoCmdFns', event: '*', pattern: '*.py'}))\n\n  \" Test for getting the autocmds for an events in a group for particular\n  \" pattern\n  let l = autocmd_get(#{group: 'TestAutoCmdFns', event: 'BufAdd',\n        \\ pattern: '*.vim'})\n  call assert_equal([\n        \\ #{cmd: 'echo \"bufadd-vim\"', group: 'TestAutoCmdFns',\n        \\  pattern: '*.vim', nested: v:false, once: v:false,\n        \\  event: 'BufAdd'}], l)\n\n  \" Test for getting the autocmds for a pattern in a group\n  let l = autocmd_get(#{group: 'TestAutoCmdFns', pattern: '*.vim'})\n  call assert_equal([\n        \\ #{cmd: 'echo \"bufadd-vim\"', group: 'TestAutoCmdFns',\n        \\  pattern: '*.vim', nested: v:false, once: v:false,\n        \\  event: 'BufAdd'},\n        \\ #{cmd: 'echo \"bufhidden\"', group: 'TestAutoCmdFns',\n        \\  pattern: '*.vim', nested: v:false,\n        \\  once: v:false, event: 'BufHidden'}], l)\n\n  \" Test for getting the autocmds for a pattern in all the groups\n  let l = autocmd_get(#{pattern: '*.a1b2c3'})\n  call assert_equal([{'cmd': 'echo \"bufadd-vim-2\"', 'group': 'TestAutoCmdFns2',\n        \\ 'pattern': '*.a1b2c3', 'nested': v:false, 'once': v:false,\n        \\ 'event': 'BufRead'}], l)\n\n  \" Test for getting autocmds for a pattern without any autocmds\n  call assert_equal([], autocmd_get(#{group: 'TestAutoCmdFns',\n        \\ pattern: '*.abc'}))\n  call assert_equal([], autocmd_get(#{group: 'TestAutoCmdFns',\n        \\ event: 'BufAdd', pattern: '*.abc'}))\n  call assert_equal([], autocmd_get(#{group: 'TestAutoCmdFns',\n        \\ event: 'BufWipeout'}))\n  call assert_fails(\"call autocmd_get(#{group: 'abc', event: 'BufAdd'})\",\n        \\ 'E367:')\n  let cmd = \"echo autocmd_get(#{group: 'TestAutoCmdFns', event: 'abc'})\"\n  call assert_fails(cmd, 'E216:')\n  call assert_fails(\"call autocmd_get(#{group: 'abc'})\", 'E367:')\n  call assert_fails(\"echo autocmd_get(#{event: 'abc'})\", 'E216:')\n\n  augroup TestAutoCmdFns\n    au!\n  augroup END\n  call assert_equal([], autocmd_get(#{group: 'TestAutoCmdFns'}))\n\n  \" Test for nested and once autocmds\n  augroup TestAutoCmdFns\n    au!\n    autocmd VimSuspend * ++nested echo \"suspend\"\n    autocmd VimResume * ++once echo \"resume\"\n  augroup END\n\n  let expected = [\n        \\ {'cmd': 'echo \"suspend\"', 'group': 'TestAutoCmdFns', 'pattern': '*',\n        \\ 'nested': v:true, 'once': v:false, 'event': 'VimSuspend'},\n        \\ {'cmd': 'echo \"resume\"', 'group': 'TestAutoCmdFns', 'pattern': '*',\n        \\  'nested': v:false, 'once': v:true, 'event': 'VimResume'}]\n  call assert_equal(expected, autocmd_get(#{group: 'TestAutoCmdFns'}))\n\n  \" Test for buffer-local autocmd\n  augroup TestAutoCmdFns\n    au!\n    autocmd TextYankPost <buffer> echo \"textyankpost\"\n  augroup END\n\n  let expected = [\n        \\ {'cmd': 'echo \"textyankpost\"', 'group': 'TestAutoCmdFns',\n        \\  'pattern': '<buffer=' .. bufnr() .. '>', 'nested': v:false,\n        \\  'once': v:false, 'bufnr': bufnr(), 'event': 'TextYankPost'}]\n  call assert_equal(expected, autocmd_get(#{group: 'TestAutoCmdFns'}))\n\n  augroup TestAutoCmdFns\n    au!\n  augroup END\n  augroup! TestAutoCmdFns\n  augroup TestAutoCmdFns2\n    au!\n  augroup END\n  augroup! TestAutoCmdFns2\n\n  call assert_fails(\"echo autocmd_get(#{group: []})\", 'E730:')\n  call assert_fails(\"echo autocmd_get(#{event: {}})\", 'E731:')\n  call assert_fails(\"echo autocmd_get([])\", 'E1206:')\nendfunc\n\n\" Test for the autocmd_add() function\nfunc Test_autocmd_add()\n  \" Define a single autocmd in a group\n  call autocmd_add([#{group: 'TestAcSet', event: 'BufAdd', pattern: '*.sh',\n        \\ cmd: 'echo \"bufadd\"', once: v:true, nested: v:true}])\n  call assert_equal([#{cmd: 'echo \"bufadd\"', group: 'TestAcSet',\n        \\ pattern: '*.sh', nested: v:true, once: v:true,\n        \\ event: 'BufAdd'}], autocmd_get(#{group: 'TestAcSet'}))\n\n  \" Define two autocmds in the same group\n  call autocmd_delete([#{group: 'TestAcSet'}])\n  call autocmd_add([#{group: 'TestAcSet', event: 'BufAdd', pattern: '*.sh',\n        \\ cmd: 'echo \"bufadd\"'},\n        \\ #{group: 'TestAcSet', event: 'BufEnter', pattern: '*.sh',\n        \\   cmd: 'echo \"bufenter\"'}])\n  call assert_equal([\n        \\ #{cmd: 'echo \"bufadd\"', group: 'TestAcSet', pattern: '*.sh',\n        \\   nested: v:false, once: v:false, event: 'BufAdd'},\n        \\ #{cmd: 'echo \"bufenter\"', group: 'TestAcSet', pattern: '*.sh',\n        \\   nested: v:false, once: v:false, event: 'BufEnter'}],\n        \\   autocmd_get(#{group: 'TestAcSet'}))\n\n  \" Define a buffer-local autocmd\n  call autocmd_delete([#{group: 'TestAcSet'}])\n  call autocmd_add([#{group: 'TestAcSet', event: 'CursorHold',\n        \\ bufnr: bufnr(), cmd: 'echo \"cursorhold\"'}])\n  call assert_equal([\n        \\ #{cmd: 'echo \"cursorhold\"', group: 'TestAcSet',\n        \\   pattern: '<buffer=' .. bufnr() .. '>', nested: v:false,\n        \\   once: v:false, bufnr: bufnr(), event: 'CursorHold'}],\n        \\   autocmd_get(#{group: 'TestAcSet'}))\n\n  \" Use an invalid buffer number\n  call autocmd_delete([#{group: 'TestAcSet'}])\n  call autocmd_add([#{group: 'TestAcSet', event: 'BufEnter',\n        \\ bufnr: -1, cmd: 'echo \"bufenter\"'}])\n  let l = [#{group: 'TestAcSet', event: 'BufAdd', bufnr: 9999,\n        \\ cmd: 'echo \"bufadd\"'}]\n  call assert_fails(\"echo autocmd_add(l)\", 'E680:')\n  let l = [#{group: 'TestAcSet', event: 'BufAdd', bufnr: 9999,\n        \\ pattern: '*.py', cmd: 'echo \"bufadd\"'}]\n  call assert_fails(\"echo autocmd_add(l)\", 'E680:')\n  let l = [#{group: 'TestAcSet', event: 'BufAdd', bufnr: 9999,\n        \\ pattern: ['*.py', '*.c'], cmd: 'echo \"bufadd\"'}]\n  call assert_fails(\"echo autocmd_add(l)\", 'E680:')\n  let l = [#{group: 'TestAcSet', event: 'BufRead', bufnr: [],\n        \\ cmd: 'echo \"bufread\"'}]\n  call assert_fails(\"echo autocmd_add(l)\", 'E745:')\n  call assert_equal([], autocmd_get(#{group: 'TestAcSet'}))\n\n  \" Add two commands to the same group, event and pattern\n  call autocmd_delete([#{group: 'TestAcSet'}])\n  call autocmd_add([#{group: 'TestAcSet', event: 'BufUnload',\n        \\ pattern: 'abc', cmd: 'echo \"cmd1\"'}])\n  call autocmd_add([#{group: 'TestAcSet', event: 'BufUnload',\n        \\ pattern: 'abc', cmd: 'echo \"cmd2\"'}])\n  call assert_equal([\n        \\ #{cmd: 'echo \"cmd1\"', group: 'TestAcSet', pattern: 'abc',\n        \\   nested: v:false,  once: v:false, event: 'BufUnload'},\n        \\ #{cmd: 'echo \"cmd2\"', group: 'TestAcSet', pattern: 'abc',\n        \\   nested: v:false,  once: v:false, event: 'BufUnload'}],\n        \\   autocmd_get(#{group: 'TestAcSet'}))\n\n  \" When adding a new autocmd, if the autocmd 'group' is not specified, then\n  \" the current autocmd group should be used.\n  call autocmd_delete([#{group: 'TestAcSet'}])\n  augroup TestAcSet\n    call autocmd_add([#{event: 'BufHidden', pattern: 'abc', cmd: 'echo \"abc\"'}])\n  augroup END\n  call assert_equal([\n        \\ #{cmd: 'echo \"abc\"', group: 'TestAcSet', pattern: 'abc',\n        \\   nested: v:false,  once: v:false, event: 'BufHidden'}],\n        \\   autocmd_get(#{group: 'TestAcSet'}))\n\n  \" Test for replacing a cmd for an event in a group\n  call autocmd_delete([#{group: 'TestAcSet'}])\n  call autocmd_add([#{replace: v:true, group: 'TestAcSet', event: 'BufEnter',\n        \\ pattern: '*.py', cmd: 'echo \"bufenter\"'}])\n  call autocmd_add([#{replace: v:true, group: 'TestAcSet', event: 'BufEnter',\n        \\ pattern: '*.py', cmd: 'echo \"bufenter\"'}])\n  call assert_equal([\n        \\ #{cmd: 'echo \"bufenter\"', group: 'TestAcSet', pattern: '*.py',\n        \\   nested: v:false,  once: v:false, event: 'BufEnter'}],\n        \\   autocmd_get(#{group: 'TestAcSet'}))\n\n  \" Test for adding a command for an unsupported autocmd event\n  let l = [#{group: 'TestAcSet', event: 'abc', pattern: '*.sh',\n        \\ cmd: 'echo \"bufadd\"'}]\n  call assert_fails('call autocmd_add(l)', 'E216:')\n\n  \" Test for using a list of events and patterns\n  call autocmd_delete([#{group: 'TestAcSet'}])\n  let l = [#{group: 'TestAcSet', event: ['BufEnter', 'BufLeave'],\n        \\ pattern: ['*.py', '*.sh'], cmd: 'echo \"bufcmds\"'}]\n  call autocmd_add(l)\n  call assert_equal([\n        \\ #{cmd: 'echo \"bufcmds\"', group: 'TestAcSet', pattern: '*.py',\n        \\   nested: v:false,  once: v:false, event: 'BufEnter'},\n        \\ #{cmd: 'echo \"bufcmds\"', group: 'TestAcSet', pattern: '*.sh',\n        \\   nested: v:false,  once: v:false, event: 'BufEnter'},\n        \\ #{cmd: 'echo \"bufcmds\"', group: 'TestAcSet', pattern: '*.py',\n        \\   nested: v:false,  once: v:false, event: 'BufLeave'},\n        \\ #{cmd: 'echo \"bufcmds\"', group: 'TestAcSet', pattern: '*.sh',\n        \\   nested: v:false,  once: v:false, event: 'BufLeave'}],\n        \\   autocmd_get(#{group: 'TestAcSet'}))\n\n  \" Test for invalid values for 'event' item\n  call autocmd_delete([#{group: 'TestAcSet'}])\n  let l = [#{group: 'TestAcSet', event: test_null_string(),\n        \\ pattern: \"*.py\", cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E928:')\n  let l = [#{group: 'TestAcSet', event: test_null_list(),\n        \\ pattern: \"*.py\", cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E714:')\n  let l = [#{group: 'TestAcSet', event: {},\n        \\ pattern: \"*.py\", cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E777:')\n  let l = [#{group: 'TestAcSet', event: [{}],\n        \\ pattern: \"*.py\", cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E928:')\n  let l = [#{group: 'TestAcSet', event: [test_null_string()],\n        \\ pattern: \"*.py\", cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E928:')\n  let l = [#{group: 'TestAcSet', event: 'BufEnter,BufLeave',\n        \\ pattern: '*.py', cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E216:')\n  let l = [#{group: 'TestAcSet', event: [],\n        \\ pattern: \"*.py\", cmd: 'echo \"bufcmds\"'}]\n  call autocmd_add(l)\n  let l = [#{group: 'TestAcSet', event: [\"\"],\n        \\ pattern: \"*.py\", cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E216:')\n  let l = [#{group: 'TestAcSet', event: \"\",\n        \\ pattern: \"*.py\", cmd: 'echo \"bufcmds\"'}]\n  call autocmd_add(l)\n  call assert_equal([], autocmd_get(#{group: 'TestAcSet'}))\n\n  \" Test for invalid values for 'pattern' item\n  let l = [#{group: 'TestAcSet', event: \"BufEnter\",\n        \\ pattern: test_null_string(), cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E928:')\n  let l = [#{group: 'TestAcSet', event: \"BufEnter\",\n        \\ pattern: test_null_list(), cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E714:')\n  let l = [#{group: 'TestAcSet', event: \"BufEnter\",\n        \\ pattern: {}, cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E777:')\n  let l = [#{group: 'TestAcSet', event: \"BufEnter\",\n        \\ pattern: [{}], cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E928:')\n  let l = [#{group: 'TestAcSet', event: \"BufEnter\",\n        \\ pattern: [test_null_string()], cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E928:')\n  let l = [#{group: 'TestAcSet', event: \"BufEnter\",\n        \\ pattern: [], cmd: 'echo \"bufcmds\"'}]\n  call autocmd_add(l)\n  let l = [#{group: 'TestAcSet', event: \"BufEnter\",\n        \\ pattern: [\"\"], cmd: 'echo \"bufcmds\"'}]\n  call autocmd_add(l)\n  let l = [#{group: 'TestAcSet', event: \"BufEnter\",\n        \\ pattern: \"\", cmd: 'echo \"bufcmds\"'}]\n  call autocmd_add(l)\n  call assert_equal([], autocmd_get(#{group: 'TestAcSet'}))\n\n  let l = [#{group: 'TestAcSet', event: 'BufEnter,abc,BufLeave',\n        \\ pattern: '*.py', cmd: 'echo \"bufcmds\"'}]\n  call assert_fails('call autocmd_add(l)', 'E216:')\n\n  call assert_fails(\"call autocmd_add({})\", 'E1211:')\n  call assert_equal(v:false,  autocmd_add(test_null_list()))\n  call assert_true(autocmd_add([[]]))\n  call assert_true(autocmd_add([test_null_dict()]))\n\n  augroup TestAcSet\n    au!\n  augroup END\n\n  call autocmd_add([#{group: 'TestAcSet'}])\n  call autocmd_add([#{group: 'TestAcSet', event: 'BufAdd'}])\n  call autocmd_add([#{group: 'TestAcSet', pat: '*.sh'}])\n  call autocmd_add([#{group: 'TestAcSet', cmd: 'echo \"a\"'}])\n  call autocmd_add([#{group: 'TestAcSet', event: 'BufAdd', pat: '*.sh'}])\n  call autocmd_add([#{group: 'TestAcSet', event: 'BufAdd', cmd: 'echo \"a\"'}])\n  call autocmd_add([#{group: 'TestAcSet', pat: '*.sh', cmd: 'echo \"a\"'}])\n  call assert_equal([], autocmd_get(#{group: 'TestAcSet'}))\n\n  augroup! TestAcSet\nendfunc\n\n\" Test for deleting autocmd events and groups\nfunc Test_autocmd_delete()\n  \" Delete an event in an autocmd group\n  augroup TestAcSet\n    au!\n    au BufAdd *.sh echo \"bufadd\"\n    au BufEnter *.sh echo \"bufenter\"\n  augroup END\n  call autocmd_delete([#{group: 'TestAcSet', event: 'BufAdd'}])\n  call assert_equal([#{cmd: 'echo \"bufenter\"', group: 'TestAcSet',\n        \\ pattern: '*.sh', nested: v:false, once: v:false,\n        \\ event: 'BufEnter'}], autocmd_get(#{group: 'TestAcSet'}))\n\n  \" Delete all the events in an autocmd group\n  augroup TestAcSet\n    au BufAdd *.sh echo \"bufadd\"\n  augroup END\n  call autocmd_delete([#{group: 'TestAcSet', event: '*'}])\n  call assert_equal([], autocmd_get(#{group: 'TestAcSet'}))\n\n  \" Delete a non-existing autocmd group\n  call assert_fails(\"call autocmd_delete([#{group: 'abc'}])\", 'E367:')\n  \" Delete a non-existing autocmd event\n  let l = [#{group: 'TestAcSet', event: 'abc'}]\n  call assert_fails(\"call autocmd_delete(l)\", 'E216:')\n  \" Delete a non-existing autocmd pattern\n  let l = [#{group: 'TestAcSet', event: 'BufAdd', pat: 'abc'}]\n  call assert_true(autocmd_delete(l))\n  \" Delete an autocmd for a non-existing buffer\n  let l = [#{event: '*', bufnr: 9999, cmd: 'echo \"x\"'}]\n  call assert_fails('call autocmd_delete(l)', 'E680:')\n\n  \" Delete an autocmd group\n  augroup TestAcSet\n    au!\n    au BufAdd *.sh echo \"bufadd\"\n    au BufEnter *.sh echo \"bufenter\"\n  augroup END\n  call autocmd_delete([#{group: 'TestAcSet'}])\n  call assert_fails(\"call autocmd_get(#{group: 'TestAcSet'})\", 'E367:')\n\n  call assert_true(autocmd_delete([[]]))\n  call assert_true(autocmd_delete([test_null_dict()]))\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read a list of people who contributed.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\nstatic void cmd_with_count(char *cmd, char_u *bufp, size_t bufsize, long Prenum);\nstatic void win_init(win_T *newp, win_T *oldp, int flags);\nstatic void win_init_some(win_T *newp, win_T *oldp);\nstatic void frame_comp_pos(frame_T *topfrp, int *row, int *col);\nstatic void frame_setheight(frame_T *curfrp, int height);\nstatic void frame_setwidth(frame_T *curfrp, int width);\nstatic void win_exchange(long);\nstatic void win_rotate(int, int);\nstatic void win_totop(int size, int flags);\nstatic void win_equal_rec(win_T *next_curwin, int current, frame_T *topfr, int dir, int col, int row, int width, int height);\nstatic void trigger_winclosed(win_T *win);\nstatic win_T *win_free_mem(win_T *win, int *dirp, tabpage_T *tp);\nstatic frame_T *win_altframe(win_T *win, tabpage_T *tp);\nstatic tabpage_T *alt_tabpage(void);\nstatic win_T *frame2win(frame_T *frp);\nstatic int frame_has_win(frame_T *frp, win_T *wp);\nstatic void frame_new_height(frame_T *topfrp, int height, int topfirst, int wfh);\nstatic int frame_fixed_height(frame_T *frp);\nstatic int frame_fixed_width(frame_T *frp);\nstatic void frame_add_statusline(frame_T *frp);\nstatic void frame_new_width(frame_T *topfrp, int width, int leftfirst, int wfw);\nstatic void frame_add_vsep(frame_T *frp);\nstatic int frame_minwidth(frame_T *topfrp, win_T *next_curwin);\nstatic void frame_fix_width(win_T *wp);\nstatic int win_alloc_firstwin(win_T *oldwin);\nstatic void new_frame(win_T *wp);\nstatic tabpage_T *alloc_tabpage(void);\nstatic int leave_tabpage(buf_T *new_curbuf, int trigger_leave_autocmds);\nstatic void enter_tabpage(tabpage_T *tp, buf_T *old_curbuf, int trigger_enter_autocmds, int trigger_leave_autocmds);\nstatic void frame_fix_height(win_T *wp);\nstatic int frame_minheight(frame_T *topfrp, win_T *next_curwin);\nstatic int may_open_tabpage(void);\nstatic int win_enter_ext(win_T *wp, int flags);\nstatic void win_free(win_T *wp, tabpage_T *tp);\nstatic void win_append(win_T *after, win_T *wp);\nstatic void frame_append(frame_T *after, frame_T *frp);\nstatic void frame_insert(frame_T *before, frame_T *frp);\nstatic void frame_remove(frame_T *frp);\nstatic void win_goto_ver(int up, long count);\nstatic void win_goto_hor(int left, long count);\nstatic void frame_add_height(frame_T *frp, int n);\nstatic void last_status_rec(frame_T *fr, int statusline);\n\nstatic void make_snapshot_rec(frame_T *fr, frame_T **frp);\nstatic void clear_snapshot(tabpage_T *tp, int idx);\nstatic void clear_snapshot_rec(frame_T *fr);\nstatic int check_snapshot_rec(frame_T *sn, frame_T *fr);\nstatic win_T *restore_snapshot_rec(frame_T *sn, frame_T *fr);\nstatic win_T *get_snapshot_curwin(int idx);\n\nstatic int frame_check_height(frame_T *topfrp, int height);\nstatic int frame_check_width(frame_T *topfrp, int width);\n\nstatic win_T *win_alloc(win_T *after, int hidden);\n\n#define NOWIN\t\t((win_T *)-1)\t// non-existing window\n\n#define ROWS_AVAIL (Rows - p_ch - tabline_height())\n\n// flags for win_enter_ext()\n#define WEE_UNDO_SYNC\t\t\t0x01\n#define WEE_CURWIN_INVALID\t\t0x02\n#define WEE_TRIGGER_NEW_AUTOCMDS\t0x04\n#define WEE_TRIGGER_ENTER_AUTOCMDS\t0x08\n#define WEE_TRIGGER_LEAVE_AUTOCMDS\t0x10\n#define WEE_ALLOW_PARSE_MESSAGES\t0x20\n\nstatic char *m_onlyone = N_(\"Already only one window\");\n\n// When non-zero splitting a window is forbidden.  Used to avoid that nasty\n// autocommands mess up the window structure.\nstatic int split_disallowed = 0;\n\n// #define WIN_DEBUG\n#ifdef WIN_DEBUG\n/*\n * Call this method to log the current window layout.\n */\n    static void\nlog_frame_layout(frame_T *frame)\n{\n    ch_log(NULL, \"layout %s, wi: %d, he: %d, wwi: %d, whe: %d, id: %d\",\n\t    frame->fr_layout == FR_LEAF ? \"LEAF\"\n\t\t\t\t  : frame->fr_layout == FR_ROW ? \"ROW\" : \"COL\",\n\t    frame->fr_width,\n\t    frame->fr_height,\n\t    frame->fr_win == NULL ? -1 : frame->fr_win->w_width,\n\t    frame->fr_win == NULL ? -1 : frame->fr_win->w_height,\n\t    frame->fr_win == NULL ? -1 : frame->fr_win->w_id);\n    if (frame->fr_child != NULL)\n    {\n\tch_log(NULL, \"children\");\n\tlog_frame_layout(frame->fr_child);\n\tif (frame->fr_next != NULL)\n\t    ch_log(NULL, \"END of children\");\n    }\n    if (frame->fr_next != NULL)\n\tlog_frame_layout(frame->fr_next);\n}\n#endif\n\n/*\n * Return the current window, unless in the cmdline window and \"prevwin\" is\n * set, then return \"prevwin\".\n */\n    win_T *\nprevwin_curwin(void)\n{\n    return\n#ifdef FEAT_CMDWIN\n\t// In cmdwin, the alternative buffer should be used.\n\tis_in_cmdwin() && prevwin != NULL ? prevwin :\n#endif\n\tcurwin;\n}\n\n/*\n * All CTRL-W window commands are handled here, called from normal_cmd().\n */\n    void\ndo_window(\n    int\t\tnchar,\n    long\tPrenum,\n    int\t\txchar)\t    // extra char from \":wincmd gx\" or NUL\n{\n    long\tPrenum1;\n    win_T\t*wp;\n#if defined(FEAT_SEARCHPATH) || defined(FEAT_FIND_ID)\n    char_u\t*ptr;\n    linenr_T    lnum = -1;\n#endif\n#ifdef FEAT_FIND_ID\n    int\t\ttype = FIND_DEFINE;\n    int\t\tlen;\n#endif\n    char_u\tcbuf[40];\n\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n#ifdef FEAT_CMDWIN\n# define CHECK_CMDWIN \\\n    do { \\\n\tif (cmdwin_type != 0) \\\n\t{ \\\n\t    emsg(_(e_invalid_in_cmdline_window)); \\\n\t    return; \\\n\t} \\\n    } while (0)\n#else\n# define CHECK_CMDWIN do { /**/ } while (0)\n#endif\n\n    Prenum1 = Prenum == 0 ? 1 : Prenum;\n\n    switch (nchar)\n    {\n// split current window in two parts, horizontally\n    case 'S':\n    case Ctrl_S:\n    case 's':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n#ifdef FEAT_QUICKFIX\n\t\t// When splitting the quickfix window open a new buffer in it,\n\t\t// don't replicate the quickfix buffer.\n\t\tif (bt_quickfix(curbuf))\n\t\t    goto newwindow;\n#endif\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\t(void)win_split((int)Prenum, 0);\n\t\tbreak;\n\n// split current window in two parts, vertically\n    case Ctrl_V:\n    case 'v':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n#ifdef FEAT_QUICKFIX\n\t\t// When splitting the quickfix window open a new buffer in it,\n\t\t// don't replicate the quickfix buffer.\n\t\tif (bt_quickfix(curbuf))\n\t\t    goto newwindow;\n#endif\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\t(void)win_split((int)Prenum, WSP_VERT);\n\t\tbreak;\n\n// split current window and edit alternate file\n    case Ctrl_HAT:\n    case '^':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\n\t\tif (buflist_findnr(Prenum == 0\n\t\t\t\t\t? curwin->w_alt_fnum : Prenum) == NULL)\n\t\t{\n\t\t    if (Prenum == 0)\n\t\t\temsg(_(e_no_alternate_file));\n\t\t    else\n\t\t\tsemsg(_(e_buffer_nr_not_found), Prenum);\n\t\t    break;\n\t\t}\n\n\t\tif (!curbuf_locked() && win_split(0, 0) == OK)\n\t\t    (void)buflist_getfile(\n\t\t\t    Prenum == 0 ? curwin->w_alt_fnum : Prenum,\n\t\t\t    (linenr_T)0, GETF_ALT, FALSE);\n\t\tbreak;\n\n// open new window\n    case Ctrl_N:\n    case 'n':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n#ifdef FEAT_QUICKFIX\nnewwindow:\n#endif\n\t\tif (Prenum)\n\t\t    // window height\n\t\t    vim_snprintf((char *)cbuf, sizeof(cbuf) - 5, \"%ld\", Prenum);\n\t\telse\n\t\t    cbuf[0] = NUL;\n#if defined(FEAT_QUICKFIX)\n\t\tif (nchar == 'v' || nchar == Ctrl_V)\n\t\t    STRCAT(cbuf, \"v\");\n#endif\n\t\tSTRCAT(cbuf, \"new\");\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n// quit current window\n    case Ctrl_Q:\n    case 'q':\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tcmd_with_count(\"quit\", cbuf, sizeof(cbuf), Prenum);\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n// close current window\n    case Ctrl_C:\n    case 'c':\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tcmd_with_count(\"close\", cbuf, sizeof(cbuf), Prenum);\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n#if defined(FEAT_QUICKFIX)\n// close preview window\n    case Ctrl_Z:\n    case 'z':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tdo_cmdline_cmd((char_u *)\"pclose\");\n\t\tbreak;\n\n// cursor to preview window\n    case 'P':\n\t\tFOR_ALL_WINDOWS(wp)\n\t\t    if (wp->w_p_pvw)\n\t\t\tbreak;\n\t\tif (wp == NULL)\n\t\t    emsg(_(e_there_is_no_preview_window));\n\t\telse\n\t\t    win_goto(wp);\n\t\tbreak;\n#endif\n\n// close all but current window\n    case Ctrl_O:\n    case 'o':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tcmd_with_count(\"only\", cbuf, sizeof(cbuf), Prenum);\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n// cursor to next window with wrap around\n    case Ctrl_W:\n    case 'w':\n// cursor to previous window with wrap around\n    case 'W':\n\t\tCHECK_CMDWIN;\n\t\tif (ONE_WINDOW && Prenum != 1)\t// just one window\n\t\t    beep_flush();\n\t\telse\n\t\t{\n\t\t    if (Prenum)\t\t\t// go to specified window\n\t\t    {\n\t\t\tfor (wp = firstwin; --Prenum > 0; )\n\t\t\t{\n\t\t\t    if (wp->w_next == NULL)\n\t\t\t\tbreak;\n\t\t\t    else\n\t\t\t\twp = wp->w_next;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (nchar == 'W')\t    // go to previous window\n\t\t\t{\n\t\t\t    wp = curwin->w_prev;\n\t\t\t    if (wp == NULL)\n\t\t\t\twp = lastwin;\t    // wrap around\n\t\t\t}\n\t\t\telse\t\t\t    // go to next window\n\t\t\t{\n\t\t\t    wp = curwin->w_next;\n\t\t\t    if (wp == NULL)\n\t\t\t\twp = firstwin;\t    // wrap around\n\t\t\t}\n\t\t    }\n\t\t    win_goto(wp);\n\t\t}\n\t\tbreak;\n\n// cursor to window below\n    case 'j':\n    case K_DOWN:\n    case Ctrl_J:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_ver(FALSE, Prenum1);\n\t\tbreak;\n\n// cursor to window above\n    case 'k':\n    case K_UP:\n    case Ctrl_K:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_ver(TRUE, Prenum1);\n\t\tbreak;\n\n// cursor to left window\n    case 'h':\n    case K_LEFT:\n    case Ctrl_H:\n    case K_BS:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_hor(TRUE, Prenum1);\n\t\tbreak;\n\n// cursor to right window\n    case 'l':\n    case K_RIGHT:\n    case Ctrl_L:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_hor(FALSE, Prenum1);\n\t\tbreak;\n\n// move window to new tab page\n    case 'T':\n\t\tCHECK_CMDWIN;\n\t\tif (one_window())\n\t\t    msg(_(m_onlyone));\n\t\telse\n\t\t{\n\t\t    tabpage_T\t*oldtab = curtab;\n\t\t    tabpage_T\t*newtab;\n\n\t\t    // First create a new tab with the window, then go back to\n\t\t    // the old tab and close the window there.\n\t\t    wp = curwin;\n\t\t    if (win_new_tabpage((int)Prenum) == OK\n\t\t\t\t\t\t     && valid_tabpage(oldtab))\n\t\t    {\n\t\t\tnewtab = curtab;\n\t\t\tgoto_tabpage_tp(oldtab, TRUE, TRUE);\n\t\t\tif (curwin == wp)\n\t\t\t    win_close(curwin, FALSE);\n\t\t\tif (valid_tabpage(newtab))\n\t\t\t    goto_tabpage_tp(newtab, TRUE, TRUE);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n// cursor to top-left window\n    case 't':\n    case Ctrl_T:\n\t\twin_goto(firstwin);\n\t\tbreak;\n\n// cursor to bottom-right window\n    case 'b':\n    case Ctrl_B:\n\t\twin_goto(lastwin);\n\t\tbreak;\n\n// cursor to last accessed (previous) window\n    case 'p':\n    case Ctrl_P:\n\t\tif (!win_valid(prevwin))\n\t\t    beep_flush();\n\t\telse\n\t\t    win_goto(prevwin);\n\t\tbreak;\n\n// exchange current and next window\n    case 'x':\n    case Ctrl_X:\n\t\tCHECK_CMDWIN;\n\t\twin_exchange(Prenum);\n\t\tbreak;\n\n// rotate windows downwards\n    case Ctrl_R:\n    case 'r':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\twin_rotate(FALSE, (int)Prenum1);    // downwards\n\t\tbreak;\n\n// rotate windows upwards\n    case 'R':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\twin_rotate(TRUE, (int)Prenum1);\t    // upwards\n\t\tbreak;\n\n// move window to the very top/bottom/left/right\n    case 'K':\n    case 'J':\n    case 'H':\n    case 'L':\n\t\tCHECK_CMDWIN;\n\t\twin_totop((int)Prenum,\n\t\t\t((nchar == 'H' || nchar == 'L') ? WSP_VERT : 0)\n\t\t\t| ((nchar == 'H' || nchar == 'K') ? WSP_TOP : WSP_BOT));\n\t\tbreak;\n\n// make all windows the same height\n    case '=':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_equal(NULL, FALSE, 'b');\n\t\tbreak;\n\n// increase current window height\n    case '+':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight(curwin->w_height + (int)Prenum1);\n\t\tbreak;\n\n// decrease current window height\n    case '-':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight(curwin->w_height - (int)Prenum1);\n\t\tbreak;\n\n// set current window height\n    case Ctrl__:\n    case '_':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight(Prenum ? (int)Prenum : 9999);\n\t\tbreak;\n\n// increase current window width\n    case '>':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setwidth(curwin->w_width + (int)Prenum1);\n\t\tbreak;\n\n// decrease current window width\n    case '<':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setwidth(curwin->w_width - (int)Prenum1);\n\t\tbreak;\n\n// set current window width\n    case '|':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setwidth(Prenum != 0 ? (int)Prenum : 9999);\n\t\tbreak;\n\n// jump to tag and split window if tag exists (in preview window)\n#if defined(FEAT_QUICKFIX)\n    case '}':\n\t\tCHECK_CMDWIN;\n\t\tif (Prenum)\n\t\t    g_do_tagpreview = Prenum;\n\t\telse\n\t\t    g_do_tagpreview = p_pvh;\n#endif\n\t\t// FALLTHROUGH\n    case ']':\n    case Ctrl_RSB:\n\t\tCHECK_CMDWIN;\n\t\t// keep Visual mode, can select words to use as a tag\n\t\tif (Prenum)\n\t\t    postponed_split = Prenum;\n\t\telse\n\t\t    postponed_split = -1;\n#ifdef FEAT_QUICKFIX\n\t\tif (nchar != '}')\n\t\t    g_do_tagpreview = 0;\n#endif\n\n\t\t// Execute the command right here, required when \"wincmd ]\"\n\t\t// was used in a function.\n\t\tdo_nv_ident(Ctrl_RSB, NUL);\n\t\tbreak;\n\n#ifdef FEAT_SEARCHPATH\n// edit file name under cursor in a new window\n    case 'f':\n    case 'F':\n    case Ctrl_F:\nwingotofile:\n\t\tCHECK_CMDWIN;\n\n\t\tptr = grab_file_name(Prenum1, &lnum);\n\t\tif (ptr != NULL)\n\t\t{\n\t\t    tabpage_T\t*oldtab = curtab;\n\t\t    win_T\t*oldwin = curwin;\n# ifdef FEAT_GUI\n\t\t    need_mouse_correct = TRUE;\n# endif\n\t\t    setpcmark();\n\t\t    if (win_split(0, 0) == OK)\n\t\t    {\n\t\t\tRESET_BINDING(curwin);\n\t\t\tif (do_ecmd(0, ptr, NULL, NULL, ECMD_LASTL,\n\t\t\t\t\t\t   ECMD_HIDE, NULL) == FAIL)\n\t\t\t{\n\t\t\t    // Failed to open the file, close the window\n\t\t\t    // opened for it.\n\t\t\t    win_close(curwin, FALSE);\n\t\t\t    goto_tabpage_win(oldtab, oldwin);\n\t\t\t}\n\t\t\telse if (nchar == 'F' && lnum >= 0)\n\t\t\t{\n\t\t\t    curwin->w_cursor.lnum = lnum;\n\t\t\t    check_cursor_lnum();\n\t\t\t    beginline(BL_SOL | BL_FIX);\n\t\t\t}\n\t\t    }\n\t\t    vim_free(ptr);\n\t\t}\n\t\tbreak;\n#endif\n\n#ifdef FEAT_FIND_ID\n// Go to the first occurrence of the identifier under cursor along path in a\n// new window -- webb\n    case 'i':\t\t\t    // Go to any match\n    case Ctrl_I:\n\t\ttype = FIND_ANY;\n\t\t// FALLTHROUGH\n    case 'd':\t\t\t    // Go to definition, using 'define'\n    case Ctrl_D:\n\t\tCHECK_CMDWIN;\n\t\tif ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)\n\t\t    break;\n\n\t\t// Make a copy, if the line was changed it will be freed.\n\t\tptr = vim_strnsave(ptr, len);\n\t\tif (ptr == NULL)\n\t\t    break;\n\n\t\tfind_pattern_in_path(ptr, 0, len, TRUE,\n\t\t\tPrenum == 0 ? TRUE : FALSE, type,\n\t\t\tPrenum1, ACTION_SPLIT, (linenr_T)1, (linenr_T)MAXLNUM);\n\t\tvim_free(ptr);\n\t\tcurwin->w_set_curswant = TRUE;\n\t\tbreak;\n#endif\n\n// Quickfix window only: view the result under the cursor in a new split.\n#if defined(FEAT_QUICKFIX)\n    case K_KENTER:\n    case CAR:\n\t\tif (bt_quickfix(curbuf))\n\t\t    qf_view_result(TRUE);\n\t\tbreak;\n#endif\n\n// CTRL-W g  extended commands\n    case 'g':\n    case Ctrl_G:\n\t\tCHECK_CMDWIN;\n#ifdef USE_ON_FLY_SCROLL\n\t\tdont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n\t\t++no_mapping;\n\t\t++allow_keys;   // no mapping for xchar, but allow key codes\n\t\tif (xchar == NUL)\n\t\t    xchar = plain_vgetc();\n\t\tLANGMAP_ADJUST(xchar, TRUE);\n\t\t--no_mapping;\n\t\t--allow_keys;\n#ifdef FEAT_CMDL_INFO\n\t\t(void)add_to_showcmd(xchar);\n#endif\n\t\tswitch (xchar)\n\t\t{\n#if defined(FEAT_QUICKFIX)\n\t\t    case '}':\n\t\t\txchar = Ctrl_RSB;\n\t\t\tif (Prenum)\n\t\t\t    g_do_tagpreview = Prenum;\n\t\t\telse\n\t\t\t    g_do_tagpreview = p_pvh;\n#endif\n\t\t\t// FALLTHROUGH\n\t\t    case ']':\n\t\t    case Ctrl_RSB:\n\t\t\t// keep Visual mode, can select words to use as a tag\n\t\t\tif (Prenum)\n\t\t\t    postponed_split = Prenum;\n\t\t\telse\n\t\t\t    postponed_split = -1;\n\n\t\t\t// Execute the command right here, required when\n\t\t\t// \"wincmd g}\" was used in a function.\n\t\t\tdo_nv_ident('g', xchar);\n\t\t\tbreak;\n\n#ifdef FEAT_SEARCHPATH\n\t\t    case 'f':\t    // CTRL-W gf: \"gf\" in a new tab page\n\t\t    case 'F':\t    // CTRL-W gF: \"gF\" in a new tab page\n\t\t\tcmdmod.cmod_tab = tabpage_index(curtab) + 1;\n\t\t\tnchar = xchar;\n\t\t\tgoto wingotofile;\n#endif\n\t\t    case 't':\t    // CTRL-W gt: go to next tab page\n\t\t\tgoto_tabpage((int)Prenum);\n\t\t\tbreak;\n\n\t\t    case 'T':\t    // CTRL-W gT: go to previous tab page\n\t\t\tgoto_tabpage(-(int)Prenum1);\n\t\t\tbreak;\n\n\t\t    case TAB:\t    // CTRL-W g<Tab>: go to last used tab page\n\t\t\tif (goto_tabpage_lastused() == FAIL)\n\t\t\t    beep_flush();\n\t\t\tbreak;\n\n\t\t    default:\n\t\t\tbeep_flush();\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n    default:\tbeep_flush();\n\t\tbreak;\n    }\n}\n\n/*\n * Figure out the address type for \":wincmd\".\n */\n    void\nget_wincmd_addr_type(char_u *arg, exarg_T *eap)\n{\n    switch (*arg)\n    {\n    case 'S':\n    case Ctrl_S:\n    case 's':\n    case Ctrl_N:\n    case 'n':\n    case 'j':\n    case Ctrl_J:\n    case 'k':\n    case Ctrl_K:\n    case 'T':\n    case Ctrl_R:\n    case 'r':\n    case 'R':\n    case 'K':\n    case 'J':\n    case '+':\n    case '-':\n    case Ctrl__:\n    case '_':\n    case '|':\n    case ']':\n    case Ctrl_RSB:\n    case 'g':\n    case Ctrl_G:\n    case Ctrl_V:\n    case 'v':\n    case 'h':\n    case Ctrl_H:\n    case 'l':\n    case Ctrl_L:\n    case 'H':\n    case 'L':\n    case '>':\n    case '<':\n#if defined(FEAT_QUICKFIX)\n    case '}':\n#endif\n#ifdef FEAT_SEARCHPATH\n    case 'f':\n    case 'F':\n    case Ctrl_F:\n#endif\n#ifdef FEAT_FIND_ID\n    case 'i':\n    case Ctrl_I:\n    case 'd':\n    case Ctrl_D:\n#endif\n\t\t// window size or any count\n\t\teap->addr_type = ADDR_OTHER;\n\t\tbreak;\n\n    case Ctrl_HAT:\n    case '^':\n\t\t// buffer number\n\t\teap->addr_type = ADDR_BUFFERS;\n\t\tbreak;\n\n    case Ctrl_Q:\n    case 'q':\n    case Ctrl_C:\n    case 'c':\n    case Ctrl_O:\n    case 'o':\n    case Ctrl_W:\n    case 'w':\n    case 'W':\n    case 'x':\n    case Ctrl_X:\n\t\t// window number\n\t\teap->addr_type = ADDR_WINDOWS;\n\t\tbreak;\n\n#if defined(FEAT_QUICKFIX)\n    case Ctrl_Z:\n    case 'z':\n    case 'P':\n#endif\n    case 't':\n    case Ctrl_T:\n    case 'b':\n    case Ctrl_B:\n    case 'p':\n    case Ctrl_P:\n    case '=':\n    case CAR:\n\t\t// no count\n\t\teap->addr_type = ADDR_NONE;\n\t\tbreak;\n    }\n}\n\n    static void\ncmd_with_count(\n    char\t*cmd,\n    char_u\t*bufp,\n    size_t\tbufsize,\n    long\tPrenum)\n{\n    if (Prenum > 0)\n\tvim_snprintf((char *)bufp, bufsize, \"%s %ld\", cmd, Prenum);\n    else\n\tSTRCPY(bufp, cmd);\n}\n\n/*\n * If \"split_disallowed\" is set give an error and return FAIL.\n * Otherwise return OK.\n */\n    static int\ncheck_split_disallowed()\n{\n    if (split_disallowed > 0)\n    {\n\temsg(_(e_cant_split_window_while_closing_another));\n\treturn FAIL;\n    }\n    if (curwin->w_buffer->b_locked_split)\n    {\n\temsg(_(e_cannot_split_window_when_closing_buffer));\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * split the current window, implements CTRL-W s and :split\n *\n * \"size\" is the height or width for the new window, 0 to use half of current\n * height or width.\n *\n * \"flags\":\n * WSP_ROOM: require enough room for new window\n * WSP_VERT: vertical split.\n * WSP_TOP:  open window at the top-left of the shell (help window).\n * WSP_BOT:  open window at the bottom-right of the shell (quickfix window).\n * WSP_HELP: creating the help window, keep layout snapshot\n *\n * return FAIL for failure, OK otherwise\n */\n    int\nwin_split(int size, int flags)\n{\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn FAIL;\n\n    if (check_split_disallowed() == FAIL)\n\treturn FAIL;\n\n    // When the \":tab\" modifier was used open a new tab page instead.\n    if (may_open_tabpage() == OK)\n\treturn OK;\n\n    // Add flags from \":vertical\", \":topleft\" and \":botright\".\n    flags |= cmdmod.cmod_split;\n    if ((flags & WSP_TOP) && (flags & WSP_BOT))\n    {\n\temsg(_(e_cant_split_topleft_and_botright_at_the_same_time));\n\treturn FAIL;\n    }\n\n    // When creating the help window make a snapshot of the window layout.\n    // Otherwise clear the snapshot, it's now invalid.\n    if (flags & WSP_HELP)\n\tmake_snapshot(SNAP_HELP_IDX);\n    else\n\tclear_snapshot(curtab, SNAP_HELP_IDX);\n\n    return win_split_ins(size, flags, NULL, 0);\n}\n\n/*\n * When \"new_wp\" is NULL: split the current window in two.\n * When \"new_wp\" is not NULL: insert this window at the far\n * top/left/right/bottom.\n * return FAIL for failure, OK otherwise\n */\n    int\nwin_split_ins(\n    int\t\tsize,\n    int\t\tflags,\n    win_T\t*new_wp,\n    int\t\tdir)\n{\n    win_T\t*wp = new_wp;\n    win_T\t*oldwin;\n    int\t\tnew_size = size;\n    int\t\ti;\n    int\t\tneed_status = 0;\n    int\t\tdo_equal = FALSE;\n    int\t\tneeded;\n    int\t\tavailable;\n    int\t\toldwin_height = 0;\n    int\t\tlayout;\n    frame_T\t*frp, *curfrp, *frp2, *prevfrp;\n    int\t\tbefore;\n    int\t\tminheight;\n    int\t\twmh1;\n    int\t\tdid_set_fraction = FALSE;\n\n    if (flags & WSP_TOP)\n\toldwin = firstwin;\n    else if (flags & WSP_BOT)\n\toldwin = lastwin;\n    else\n\toldwin = curwin;\n\n    // add a status line when p_ls == 1 and splitting the first window\n    if (ONE_WINDOW && p_ls == 1 && oldwin->w_status_height == 0)\n    {\n\tif (VISIBLE_HEIGHT(oldwin) <= p_wmh && new_wp == NULL)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    return FAIL;\n\t}\n\tneed_status = STATUS_HEIGHT;\n    }\n\n#ifdef FEAT_GUI\n    // May be needed for the scrollbars that are going to change.\n    if (gui.in_use)\n\tout_flush();\n#endif\n\n    if (flags & WSP_VERT)\n    {\n\tint\twmw1;\n\tint\tminwidth;\n\n\tlayout = FR_ROW;\n\n\t/*\n\t * Check if we are able to split the current window and compute its\n\t * width.\n\t */\n\t// Current window requires at least 1 space.\n\twmw1 = (p_wmw == 0 ? 1 : p_wmw);\n\tneeded = wmw1 + 1;\n\tif (flags & WSP_ROOM)\n\t    needed += p_wiw - wmw1;\n\tif (flags & (WSP_BOT | WSP_TOP))\n\t{\n\t    minwidth = frame_minwidth(topframe, NOWIN);\n\t    available = topframe->fr_width;\n\t    needed += minwidth;\n\t}\n\telse if (p_ea)\n\t{\n\t    minwidth = frame_minwidth(oldwin->w_frame, NOWIN);\n\t    prevfrp = oldwin->w_frame;\n\t    for (frp = oldwin->w_frame->fr_parent; frp != NULL;\n\t\t\t\t\t\t\tfrp = frp->fr_parent)\n\t    {\n\t\tif (frp->fr_layout == FR_ROW)\n\t\t    FOR_ALL_FRAMES(frp2, frp->fr_child)\n\t\t\tif (frp2 != prevfrp)\n\t\t\t    minwidth += frame_minwidth(frp2, NOWIN);\n\t\tprevfrp = frp;\n\t    }\n\t    available = topframe->fr_width;\n\t    needed += minwidth;\n\t}\n\telse\n\t{\n\t    minwidth = frame_minwidth(oldwin->w_frame, NOWIN);\n\t    available = oldwin->w_frame->fr_width;\n\t    needed += minwidth;\n\t}\n\tif (available < needed && new_wp == NULL)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    return FAIL;\n\t}\n\tif (new_size == 0)\n\t    new_size = oldwin->w_width / 2;\n\tif (new_size > available - minwidth - 1)\n\t    new_size = available - minwidth - 1;\n\tif (new_size < wmw1)\n\t    new_size = wmw1;\n\n\t// if it doesn't fit in the current window, need win_equal()\n\tif (oldwin->w_width - new_size - 1 < p_wmw)\n\t    do_equal = TRUE;\n\n\t// We don't like to take lines for the new window from a\n\t// 'winfixwidth' window.  Take them from a window to the left or right\n\t// instead, if possible. Add one for the separator.\n\tif (oldwin->w_p_wfw)\n\t    win_setwidth_win(oldwin->w_width + new_size + 1, oldwin);\n\n\t// Only make all windows the same width if one of them (except oldwin)\n\t// is wider than one of the split windows.\n\tif (!do_equal && p_ea && size == 0 && *p_ead != 'v'\n\t\t\t\t\t && oldwin->w_frame->fr_parent != NULL)\n\t{\n\t    frp = oldwin->w_frame->fr_parent->fr_child;\n\t    while (frp != NULL)\n\t    {\n\t\tif (frp->fr_win != oldwin && frp->fr_win != NULL\n\t\t\t&& (frp->fr_win->w_width > new_size\n\t\t\t    || frp->fr_win->w_width > oldwin->w_width\n\t\t\t\t\t\t\t      - new_size - 1))\n\t\t{\n\t\t    do_equal = TRUE;\n\t\t    break;\n\t\t}\n\t\tfrp = frp->fr_next;\n\t    }\n\t}\n    }\n    else\n    {\n\tlayout = FR_COL;\n\n\t/*\n\t * Check if we are able to split the current window and compute its\n\t * height.\n\t */\n\t// Current window requires at least 1 space.\n\twmh1 = (p_wmh == 0 ? 1 : p_wmh) + WINBAR_HEIGHT(curwin);\n\tneeded = wmh1 + STATUS_HEIGHT;\n\tif (flags & WSP_ROOM)\n\t    needed += p_wh - wmh1;\n\tif (flags & (WSP_BOT | WSP_TOP))\n\t{\n\t    minheight = frame_minheight(topframe, NOWIN) + need_status;\n\t    available = topframe->fr_height;\n\t    needed += minheight;\n\t}\n\telse if (p_ea)\n\t{\n\t    minheight = frame_minheight(oldwin->w_frame, NOWIN) + need_status;\n\t    prevfrp = oldwin->w_frame;\n\t    for (frp = oldwin->w_frame->fr_parent; frp != NULL;\n\t\t\t\t\t\t\tfrp = frp->fr_parent)\n\t    {\n\t\tif (frp->fr_layout == FR_COL)\n\t\t    FOR_ALL_FRAMES(frp2, frp->fr_child)\n\t\t\tif (frp2 != prevfrp)\n\t\t\t    minheight += frame_minheight(frp2, NOWIN);\n\t\tprevfrp = frp;\n\t    }\n\t    available = topframe->fr_height;\n\t    needed += minheight;\n\t}\n\telse\n\t{\n\t    minheight = frame_minheight(oldwin->w_frame, NOWIN) + need_status;\n\t    available = oldwin->w_frame->fr_height;\n\t    needed += minheight;\n\t}\n\tif (available < needed && new_wp == NULL)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    return FAIL;\n\t}\n\toldwin_height = oldwin->w_height;\n\tif (need_status)\n\t{\n\t    oldwin->w_status_height = STATUS_HEIGHT;\n\t    oldwin_height -= STATUS_HEIGHT;\n\t}\n\tif (new_size == 0)\n\t    new_size = oldwin_height / 2;\n\tif (new_size > available - minheight - STATUS_HEIGHT)\n\t    new_size = available - minheight - STATUS_HEIGHT;\n\tif (new_size < wmh1)\n\t    new_size = wmh1;\n\n\t// if it doesn't fit in the current window, need win_equal()\n\tif (oldwin_height - new_size - STATUS_HEIGHT < p_wmh)\n\t    do_equal = TRUE;\n\n\t// We don't like to take lines for the new window from a\n\t// 'winfixheight' window.  Take them from a window above or below\n\t// instead, if possible.\n\tif (oldwin->w_p_wfh)\n\t{\n\t    // Set w_fraction now so that the cursor keeps the same relative\n\t    // vertical position using the old height.\n\t    set_fraction(oldwin);\n\t    did_set_fraction = TRUE;\n\n\t    win_setheight_win(oldwin->w_height + new_size + STATUS_HEIGHT,\n\t\t\t\t\t\t\t\t      oldwin);\n\t    oldwin_height = oldwin->w_height;\n\t    if (need_status)\n\t\toldwin_height -= STATUS_HEIGHT;\n\t}\n\n\t// Only make all windows the same height if one of them (except oldwin)\n\t// is higher than one of the split windows.\n\tif (!do_equal && p_ea && size == 0 && *p_ead != 'h'\n\t   && oldwin->w_frame->fr_parent != NULL)\n\t{\n\t    frp = oldwin->w_frame->fr_parent->fr_child;\n\t    while (frp != NULL)\n\t    {\n\t\tif (frp->fr_win != oldwin && frp->fr_win != NULL\n\t\t\t&& (frp->fr_win->w_height > new_size\n\t\t\t    || frp->fr_win->w_height > oldwin_height - new_size\n\t\t\t\t\t\t\t      - STATUS_HEIGHT))\n\t\t{\n\t\t    do_equal = TRUE;\n\t\t    break;\n\t\t}\n\t\tfrp = frp->fr_next;\n\t    }\n\t}\n    }\n\n    /*\n     * allocate new window structure and link it in the window list\n     */\n    if ((flags & WSP_TOP) == 0\n\t    && ((flags & WSP_BOT)\n\t\t|| (flags & WSP_BELOW)\n\t\t|| (!(flags & WSP_ABOVE)\n\t\t    && ( (flags & WSP_VERT) ? p_spr : p_sb))))\n    {\n\t// new window below/right of current one\n\tif (new_wp == NULL)\n\t    wp = win_alloc(oldwin, FALSE);\n\telse\n\t    win_append(oldwin, wp);\n    }\n    else\n    {\n\tif (new_wp == NULL)\n\t    wp = win_alloc(oldwin->w_prev, FALSE);\n\telse\n\t    win_append(oldwin->w_prev, wp);\n    }\n\n    if (new_wp == NULL)\n    {\n\tif (wp == NULL)\n\t    return FAIL;\n\n\tnew_frame(wp);\n\tif (wp->w_frame == NULL)\n\t{\n\t    win_free(wp, NULL);\n\t    return FAIL;\n\t}\n\n\t// make the contents of the new window the same as the current one\n\twin_init(wp, curwin, flags);\n    }\n\n    /*\n     * Reorganise the tree of frames to insert the new window.\n     */\n    if (flags & (WSP_TOP | WSP_BOT))\n    {\n\tif ((topframe->fr_layout == FR_COL && (flags & WSP_VERT) == 0)\n\t    || (topframe->fr_layout == FR_ROW && (flags & WSP_VERT) != 0))\n\t{\n\t    curfrp = topframe->fr_child;\n\t    if (flags & WSP_BOT)\n\t\twhile (curfrp->fr_next != NULL)\n\t\t    curfrp = curfrp->fr_next;\n\t}\n\telse\n\t    curfrp = topframe;\n\tbefore = (flags & WSP_TOP);\n    }\n    else\n    {\n\tcurfrp = oldwin->w_frame;\n\tif (flags & WSP_BELOW)\n\t    before = FALSE;\n\telse if (flags & WSP_ABOVE)\n\t    before = TRUE;\n\telse if (flags & WSP_VERT)\n\t    before = !p_spr;\n\telse\n\t    before = !p_sb;\n    }\n    if (curfrp->fr_parent == NULL || curfrp->fr_parent->fr_layout != layout)\n    {\n\t// Need to create a new frame in the tree to make a branch.\n\tfrp = ALLOC_CLEAR_ONE(frame_T);\n\t*frp = *curfrp;\n\tcurfrp->fr_layout = layout;\n\tfrp->fr_parent = curfrp;\n\tfrp->fr_next = NULL;\n\tfrp->fr_prev = NULL;\n\tcurfrp->fr_child = frp;\n\tcurfrp->fr_win = NULL;\n\tcurfrp = frp;\n\tif (frp->fr_win != NULL)\n\t    oldwin->w_frame = frp;\n\telse\n\t    FOR_ALL_FRAMES(frp, frp->fr_child)\n\t\tfrp->fr_parent = curfrp;\n    }\n\n    if (new_wp == NULL)\n\tfrp = wp->w_frame;\n    else\n\tfrp = new_wp->w_frame;\n    frp->fr_parent = curfrp->fr_parent;\n\n    // Insert the new frame at the right place in the frame list.\n    if (before)\n\tframe_insert(curfrp, frp);\n    else\n\tframe_append(curfrp, frp);\n\n    // Set w_fraction now so that the cursor keeps the same relative\n    // vertical position.\n    if (!did_set_fraction)\n\tset_fraction(oldwin);\n    wp->w_fraction = oldwin->w_fraction;\n\n    if (flags & WSP_VERT)\n    {\n\twp->w_p_scr = curwin->w_p_scr;\n\n\tif (need_status)\n\t{\n\t    win_new_height(oldwin, oldwin->w_height - 1);\n\t    oldwin->w_status_height = need_status;\n\t}\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    // set height and row of new window to full height\n\t    wp->w_winrow = tabline_height();\n\t    win_new_height(wp, curfrp->fr_height - (p_ls > 0)\n\t\t\t\t\t\t\t  - WINBAR_HEIGHT(wp));\n\t    wp->w_status_height = (p_ls > 0);\n\t}\n\telse\n\t{\n\t    // height and row of new window is same as current window\n\t    wp->w_winrow = oldwin->w_winrow;\n\t    win_new_height(wp, VISIBLE_HEIGHT(oldwin));\n\t    wp->w_status_height = oldwin->w_status_height;\n\t}\n\tfrp->fr_height = curfrp->fr_height;\n\n\t// \"new_size\" of the current window goes to the new window, use\n\t// one column for the vertical separator\n\twin_new_width(wp, new_size);\n\tif (before)\n\t    wp->w_vsep_width = 1;\n\telse\n\t{\n\t    wp->w_vsep_width = oldwin->w_vsep_width;\n\t    oldwin->w_vsep_width = 1;\n\t}\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    if (flags & WSP_BOT)\n\t\tframe_add_vsep(curfrp);\n\t    // Set width of neighbor frame\n\t    frame_new_width(curfrp, curfrp->fr_width\n\t\t     - (new_size + ((flags & WSP_TOP) != 0)), flags & WSP_TOP,\n\t\t\t\t\t\t\t\t       FALSE);\n\t}\n\telse\n\t    win_new_width(oldwin, oldwin->w_width - (new_size + 1));\n\tif (before)\t// new window left of current one\n\t{\n\t    wp->w_wincol = oldwin->w_wincol;\n\t    oldwin->w_wincol += new_size + 1;\n\t}\n\telse\t\t// new window right of current one\n\t    wp->w_wincol = oldwin->w_wincol + oldwin->w_width + 1;\n\tframe_fix_width(oldwin);\n\tframe_fix_width(wp);\n    }\n    else\n    {\n\t// width and column of new window is same as current window\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    wp->w_wincol = 0;\n\t    win_new_width(wp, Columns);\n\t    wp->w_vsep_width = 0;\n\t}\n\telse\n\t{\n\t    wp->w_wincol = oldwin->w_wincol;\n\t    win_new_width(wp, oldwin->w_width);\n\t    wp->w_vsep_width = oldwin->w_vsep_width;\n\t}\n\tfrp->fr_width = curfrp->fr_width;\n\n\t// \"new_size\" of the current window goes to the new window, use\n\t// one row for the status line\n\twin_new_height(wp, new_size);\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    int new_fr_height = curfrp->fr_height - new_size\n\t\t\t\t\t\t\t  + WINBAR_HEIGHT(wp) ;\n\n\t    if (!((flags & WSP_BOT) && p_ls == 0))\n\t\tnew_fr_height -= STATUS_HEIGHT;\n\t    frame_new_height(curfrp, new_fr_height, flags & WSP_TOP, FALSE);\n\t}\n\telse\n\t    win_new_height(oldwin, oldwin_height - (new_size + STATUS_HEIGHT));\n\tif (before)\t// new window above current one\n\t{\n\t    wp->w_winrow = oldwin->w_winrow;\n\t    wp->w_status_height = STATUS_HEIGHT;\n\t    oldwin->w_winrow += wp->w_height + STATUS_HEIGHT;\n\t}\n\telse\t\t// new window below current one\n\t{\n\t    wp->w_winrow = oldwin->w_winrow + VISIBLE_HEIGHT(oldwin)\n\t\t\t\t\t\t\t       + STATUS_HEIGHT;\n\t    wp->w_status_height = oldwin->w_status_height;\n\t    if (!(flags & WSP_BOT))\n\t\toldwin->w_status_height = STATUS_HEIGHT;\n\t}\n\tif (flags & WSP_BOT)\n\t    frame_add_statusline(curfrp);\n\tframe_fix_height(wp);\n\tframe_fix_height(oldwin);\n    }\n\n    if (flags & (WSP_TOP | WSP_BOT))\n\t(void)win_comp_pos();\n\n     // Both windows need redrawing.  Update all status lines, in case they\n     // show something related to the window count or position.\n    redraw_win_later(wp, NOT_VALID);\n    redraw_win_later(oldwin, NOT_VALID);\n    status_redraw_all();\n\n    if (need_status)\n    {\n\tmsg_row = Rows - 1;\n\tmsg_col = sc_col;\n\tmsg_clr_eos_force();\t// Old command/ruler may still be there\n\tcomp_col();\n\tmsg_row = Rows - 1;\n\tmsg_col = 0;\t// put position back at start of line\n    }\n\n    /*\n     * equalize the window sizes.\n     */\n    if (do_equal || dir != 0)\n\twin_equal(wp, TRUE,\n\t\t(flags & WSP_VERT) ? (dir == 'v' ? 'b' : 'h')\n\t\t: dir == 'h' ? 'b' : 'v');\n\n    // Don't change the window height/width to 'winheight' / 'winwidth' if a\n    // size was given.\n    if (flags & WSP_VERT)\n    {\n\ti = p_wiw;\n\tif (size != 0)\n\t    p_wiw = size;\n\n# ifdef FEAT_GUI\n\t// When 'guioptions' includes 'L' or 'R' may have to add scrollbars.\n\tif (gui.in_use)\n\t    gui_init_which_components(NULL);\n# endif\n    }\n    else\n    {\n\ti = p_wh;\n\tif (size != 0)\n\t    p_wh = size;\n    }\n\n    /*\n     * make the new window the current window\n     */\n    (void)win_enter_ext(wp, WEE_TRIGGER_NEW_AUTOCMDS\n\t\t    | WEE_TRIGGER_ENTER_AUTOCMDS | WEE_TRIGGER_LEAVE_AUTOCMDS);\n    if (flags & WSP_VERT)\n\tp_wiw = i;\n    else\n\tp_wh = i;\n\n    return OK;\n}\n\n\n/*\n * Initialize window \"newp\" from window \"oldp\".\n * Used when splitting a window and when creating a new tab page.\n * The windows will both edit the same buffer.\n * WSP_NEWLOC may be specified in flags to prevent the location list from\n * being copied.\n */\n    static void\nwin_init(win_T *newp, win_T *oldp, int flags UNUSED)\n{\n    int\t\ti;\n\n    newp->w_buffer = oldp->w_buffer;\n#ifdef FEAT_SYN_HL\n    newp->w_s = &(oldp->w_buffer->b_s);\n#endif\n    oldp->w_buffer->b_nwindows++;\n    newp->w_cursor = oldp->w_cursor;\n    newp->w_valid = 0;\n    newp->w_curswant = oldp->w_curswant;\n    newp->w_set_curswant = oldp->w_set_curswant;\n    newp->w_topline = oldp->w_topline;\n#ifdef FEAT_DIFF\n    newp->w_topfill = oldp->w_topfill;\n#endif\n    newp->w_leftcol = oldp->w_leftcol;\n    newp->w_pcmark = oldp->w_pcmark;\n    newp->w_prev_pcmark = oldp->w_prev_pcmark;\n    newp->w_alt_fnum = oldp->w_alt_fnum;\n    newp->w_wrow = oldp->w_wrow;\n    newp->w_fraction = oldp->w_fraction;\n    newp->w_prev_fraction_row = oldp->w_prev_fraction_row;\n    copy_jumplist(oldp, newp);\n#ifdef FEAT_QUICKFIX\n    if (flags & WSP_NEWLOC)\n    {\n\t// Don't copy the location list.\n\tnewp->w_llist = NULL;\n\tnewp->w_llist_ref = NULL;\n    }\n    else\n\tcopy_loclist_stack(oldp, newp);\n#endif\n    newp->w_localdir = (oldp->w_localdir == NULL)\n\t\t\t\t    ? NULL : vim_strsave(oldp->w_localdir);\n    newp->w_prevdir = (oldp->w_prevdir == NULL)\n\t\t\t\t    ? NULL : vim_strsave(oldp->w_prevdir);\n\n    // copy tagstack and folds\n    for (i = 0; i < oldp->w_tagstacklen; i++)\n    {\n\ttaggy_T\t*tag = &newp->w_tagstack[i];\n\t*tag = oldp->w_tagstack[i];\n\tif (tag->tagname != NULL)\n\t    tag->tagname = vim_strsave(tag->tagname);\n\tif (tag->user_data != NULL)\n\t    tag->user_data = vim_strsave(tag->user_data);\n    }\n    newp->w_tagstackidx = oldp->w_tagstackidx;\n    newp->w_tagstacklen = oldp->w_tagstacklen;\n\n    // Keep same changelist position in new window.\n    newp->w_changelistidx = oldp->w_changelistidx;\n\n#ifdef FEAT_FOLDING\n    copyFoldingState(oldp, newp);\n#endif\n\n    win_init_some(newp, oldp);\n#ifdef FEAT_TERMINAL\n    term_update_wincolor(newp);\n#endif\n}\n\n/*\n * Initialize window \"newp\" from window \"old\".\n * Only the essential things are copied.\n */\n    static void\nwin_init_some(win_T *newp, win_T *oldp)\n{\n    // Use the same argument list.\n    newp->w_alist = oldp->w_alist;\n    ++newp->w_alist->al_refcount;\n    newp->w_arg_idx = oldp->w_arg_idx;\n\n    // copy options from existing window\n    win_copy_options(oldp, newp);\n}\n\n/*\n * Return TRUE if \"win\" is a global popup or a popup in the current tab page.\n */\n    int\nwin_valid_popup(win_T *win UNUSED)\n{\n#ifdef FEAT_PROP_POPUP\n    win_T\t*wp;\n\n    FOR_ALL_POPUPWINS(wp)\n\tif (wp == win)\n\t    return TRUE;\n    FOR_ALL_POPUPWINS_IN_TAB(curtab, wp)\n\tif (wp == win)\n\t    return TRUE;\n#endif\n    return FALSE;\n}\n\n/*\n * Check if \"win\" is a pointer to an existing window in the current tab page.\n */\n    int\nwin_valid(win_T *win)\n{\n    win_T\t*wp;\n\n    if (win == NULL)\n\treturn FALSE;\n    FOR_ALL_WINDOWS(wp)\n\tif (wp == win)\n\t    return TRUE;\n    return win_valid_popup(win);\n}\n\n/*\n * Find window \"id\" in the current tab page.\n * Also find popup windows.\n * Return NULL if not found.\n */\n    win_T *\nwin_find_by_id(int id)\n{\n    win_T   *wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (wp->w_id == id)\n\t    return wp;\n#ifdef FEAT_PROP_POPUP\n    FOR_ALL_POPUPWINS(wp)\n\tif (wp->w_id == id)\n\t    return wp;\n    FOR_ALL_POPUPWINS_IN_TAB(curtab, wp)\n\tif (wp->w_id == id)\n\t    return wp;\n#endif\n    return NULL;\n}\n\n/*\n * Check if \"win\" is a pointer to an existing window in any tab page.\n */\n    int\nwin_valid_any_tab(win_T *win)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    if (win == NULL)\n\treturn FALSE;\n    FOR_ALL_TABPAGES(tp)\n    {\n\tFOR_ALL_WINDOWS_IN_TAB(tp, wp)\n\t{\n\t    if (wp == win)\n\t\treturn TRUE;\n\t}\n#ifdef FEAT_PROP_POPUP\n\tFOR_ALL_POPUPWINS_IN_TAB(tp, wp)\n\t    if (wp == win)\n\t\treturn TRUE;\n#endif\n    }\n    return win_valid_popup(win);\n}\n\n/*\n * Return the number of windows.\n */\n    int\nwin_count(void)\n{\n    win_T\t*wp;\n    int\t\tcount = 0;\n\n    FOR_ALL_WINDOWS(wp)\n\t++count;\n    return count;\n}\n\n/*\n * Make \"count\" windows on the screen.\n * Return actual number of windows on the screen.\n * Must be called when there is just one window, filling the whole screen\n * (excluding the command line).\n */\n    int\nmake_windows(\n    int\t\tcount,\n    int\t\tvertical UNUSED)  // split windows vertically if TRUE\n{\n    int\t\tmaxcount;\n    int\t\ttodo;\n\n    if (vertical)\n    {\n\t// Each window needs at least 'winminwidth' lines and a separator\n\t// column.\n\tmaxcount = (curwin->w_width + curwin->w_vsep_width\n\t\t\t\t\t     - (p_wiw - p_wmw)) / (p_wmw + 1);\n    }\n    else\n    {\n\t// Each window needs at least 'winminheight' lines and a status line.\n\tmaxcount = (VISIBLE_HEIGHT(curwin) + curwin->w_status_height\n\t\t\t\t  - (p_wh - p_wmh)) / (p_wmh + STATUS_HEIGHT);\n    }\n\n    if (maxcount < 2)\n\tmaxcount = 2;\n    if (count > maxcount)\n\tcount = maxcount;\n\n    /*\n     * add status line now, otherwise first window will be too big\n     */\n    if (count > 1)\n\tlast_status(TRUE);\n\n    /*\n     * Don't execute autocommands while creating the windows.  Must do that\n     * when putting the buffers in the windows.\n     */\n    block_autocmds();\n\n    // todo is number of windows left to create\n    for (todo = count - 1; todo > 0; --todo)\n\tif (vertical)\n\t{\n\t    if (win_split(curwin->w_width - (curwin->w_width - todo)\n\t\t\t/ (todo + 1) - 1, WSP_VERT | WSP_ABOVE) == FAIL)\n\t\tbreak;\n\t}\n\telse\n\t{\n\t    if (win_split(curwin->w_height - (curwin->w_height - todo\n\t\t\t    * STATUS_HEIGHT) / (todo + 1)\n\t\t\t- STATUS_HEIGHT, WSP_ABOVE) == FAIL)\n\t\tbreak;\n\t}\n\n    unblock_autocmds();\n\n    // return actual number of windows\n    return (count - todo);\n}\n\n/*\n * Exchange current and next window\n */\n    static void\nwin_exchange(long Prenum)\n{\n    frame_T\t*frp;\n    frame_T\t*frp2;\n    win_T\t*wp;\n    win_T\t*wp2;\n    int\t\ttemp;\n\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n    if (ONE_WINDOW)\t    // just one window\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    /*\n     * find window to exchange with\n     */\n    if (Prenum)\n    {\n\tfrp = curwin->w_frame->fr_parent->fr_child;\n\twhile (frp != NULL && --Prenum > 0)\n\t    frp = frp->fr_next;\n    }\n    else if (curwin->w_frame->fr_next != NULL)\t// Swap with next\n\tfrp = curwin->w_frame->fr_next;\n    else    // Swap last window in row/col with previous\n\tfrp = curwin->w_frame->fr_prev;\n\n    // We can only exchange a window with another window, not with a frame\n    // containing windows.\n    if (frp == NULL || frp->fr_win == NULL || frp->fr_win == curwin)\n\treturn;\n    wp = frp->fr_win;\n\n/*\n * 1. remove curwin from the list. Remember after which window it was in wp2\n * 2. insert curwin before wp in the list\n * if wp != wp2\n *    3. remove wp from the list\n *    4. insert wp after wp2\n * 5. exchange the status line height and vsep width.\n */\n    wp2 = curwin->w_prev;\n    frp2 = curwin->w_frame->fr_prev;\n    if (wp->w_prev != curwin)\n    {\n\twin_remove(curwin, NULL);\n\tframe_remove(curwin->w_frame);\n\twin_append(wp->w_prev, curwin);\n\tframe_insert(frp, curwin->w_frame);\n    }\n    if (wp != wp2)\n    {\n\twin_remove(wp, NULL);\n\tframe_remove(wp->w_frame);\n\twin_append(wp2, wp);\n\tif (frp2 == NULL)\n\t    frame_insert(wp->w_frame->fr_parent->fr_child, wp->w_frame);\n\telse\n\t    frame_append(frp2, wp->w_frame);\n    }\n    temp = curwin->w_status_height;\n    curwin->w_status_height = wp->w_status_height;\n    wp->w_status_height = temp;\n    temp = curwin->w_vsep_width;\n    curwin->w_vsep_width = wp->w_vsep_width;\n    wp->w_vsep_width = temp;\n\n    frame_fix_height(curwin);\n    frame_fix_height(wp);\n    frame_fix_width(curwin);\n    frame_fix_width(wp);\n\n    (void)win_comp_pos();\t\t// recompute window positions\n\n    if (wp->w_buffer != curbuf)\n\treset_VIsual_and_resel();\n    else if (VIsual_active)\n\twp->w_cursor = curwin->w_cursor;\n\n    win_enter(wp, TRUE);\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * rotate windows: if upwards TRUE the second window becomes the first one\n *\t\t   if upwards FALSE the first window becomes the second one\n */\n    static void\nwin_rotate(int upwards, int count)\n{\n    win_T\t*wp1;\n    win_T\t*wp2;\n    frame_T\t*frp;\n    int\t\tn;\n\n    if (ONE_WINDOW)\t\t// nothing to do\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    // Check if all frames in this row/col have one window.\n    FOR_ALL_FRAMES(frp, curwin->w_frame->fr_parent->fr_child)\n\tif (frp->fr_win == NULL)\n\t{\n\t    emsg(_(e_cannot_rotate_when_another_window_is_split));\n\t    return;\n\t}\n\n    while (count--)\n    {\n\tif (upwards)\t\t// first window becomes last window\n\t{\n\t    // remove first window/frame from the list\n\t    frp = curwin->w_frame->fr_parent->fr_child;\n\t    wp1 = frp->fr_win;\n\t    win_remove(wp1, NULL);\n\t    frame_remove(frp);\n\n\t    // find last frame and append removed window/frame after it\n\t    for ( ; frp->fr_next != NULL; frp = frp->fr_next)\n\t\t;\n\t    win_append(frp->fr_win, wp1);\n\t    frame_append(frp, wp1->w_frame);\n\n\t    wp2 = frp->fr_win;\t\t// previously last window\n\t}\n\telse\t\t\t// last window becomes first window\n\t{\n\t    // find last window/frame in the list and remove it\n\t    for (frp = curwin->w_frame; frp->fr_next != NULL;\n\t\t\t\t\t\t\t   frp = frp->fr_next)\n\t\t;\n\t    wp1 = frp->fr_win;\n\t    wp2 = wp1->w_prev;\t\t    // will become last window\n\t    win_remove(wp1, NULL);\n\t    frame_remove(frp);\n\n\t    // append the removed window/frame before the first in the list\n\t    win_append(frp->fr_parent->fr_child->fr_win->w_prev, wp1);\n\t    frame_insert(frp->fr_parent->fr_child, frp);\n\t}\n\n\t// exchange status height and vsep width of old and new last window\n\tn = wp2->w_status_height;\n\twp2->w_status_height = wp1->w_status_height;\n\twp1->w_status_height = n;\n\tframe_fix_height(wp1);\n\tframe_fix_height(wp2);\n\tn = wp2->w_vsep_width;\n\twp2->w_vsep_width = wp1->w_vsep_width;\n\twp1->w_vsep_width = n;\n\tframe_fix_width(wp1);\n\tframe_fix_width(wp2);\n\n\t// recompute w_winrow and w_wincol for all windows\n\t(void)win_comp_pos();\n    }\n\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * Move the current window to the very top/bottom/left/right of the screen.\n */\n    static void\nwin_totop(int size, int flags)\n{\n    int\t\tdir;\n    int\t\theight = curwin->w_height;\n\n    if (ONE_WINDOW)\n    {\n\tbeep_flush();\n\treturn;\n    }\n    if (check_split_disallowed() == FAIL)\n\treturn;\n\n    // Remove the window and frame from the tree of frames.\n    (void)winframe_remove(curwin, &dir, NULL);\n    win_remove(curwin, NULL);\n    last_status(FALSE);\t    // may need to remove last status line\n    (void)win_comp_pos();   // recompute window positions\n\n    // Split a window on the desired side and put the window there.\n    (void)win_split_ins(size, flags, curwin, dir);\n    if (!(flags & WSP_VERT))\n    {\n\twin_setheight(height);\n\tif (p_ea)\n\t    win_equal(curwin, TRUE, 'v');\n    }\n\n#if defined(FEAT_GUI)\n    // When 'guioptions' includes 'L' or 'R' may have to remove or add\n    // scrollbars.  Have to update them anyway.\n    gui_may_update_scrollbars();\n#endif\n}\n\n/*\n * Move window \"win1\" to below/right of \"win2\" and make \"win1\" the current\n * window.  Only works within the same frame!\n */\n    void\nwin_move_after(win_T *win1, win_T *win2)\n{\n    int\t\theight;\n\n    // check if the arguments are reasonable\n    if (win1 == win2)\n\treturn;\n\n    // check if there is something to do\n    if (win2->w_next != win1)\n    {\n\tif (win1->w_frame->fr_parent != win2->w_frame->fr_parent)\n\t{\n\t    iemsg(\"INTERNAL: trying to move a window into another frame\");\n\t    return;\n\t}\n\n\t// may need to move the status line/vertical separator of the last\n\t// window\n\tif (win1 == lastwin)\n\t{\n\t    height = win1->w_prev->w_status_height;\n\t    win1->w_prev->w_status_height = win1->w_status_height;\n\t    win1->w_status_height = height;\n\t    if (win1->w_prev->w_vsep_width == 1)\n\t    {\n\t\t// Remove the vertical separator from the last-but-one window,\n\t\t// add it to the last window.  Adjust the frame widths.\n\t\twin1->w_prev->w_vsep_width = 0;\n\t\twin1->w_prev->w_frame->fr_width -= 1;\n\t\twin1->w_vsep_width = 1;\n\t\twin1->w_frame->fr_width += 1;\n\t    }\n\t}\n\telse if (win2 == lastwin)\n\t{\n\t    height = win1->w_status_height;\n\t    win1->w_status_height = win2->w_status_height;\n\t    win2->w_status_height = height;\n\t    if (win1->w_vsep_width == 1)\n\t    {\n\t\t// Remove the vertical separator from win1, add it to the last\n\t\t// window, win2.  Adjust the frame widths.\n\t\twin2->w_vsep_width = 1;\n\t\twin2->w_frame->fr_width += 1;\n\t\twin1->w_vsep_width = 0;\n\t\twin1->w_frame->fr_width -= 1;\n\t    }\n\t}\n\twin_remove(win1, NULL);\n\tframe_remove(win1->w_frame);\n\twin_append(win2, win1);\n\tframe_append(win2->w_frame, win1->w_frame);\n\n\t(void)win_comp_pos();\t// recompute w_winrow for all windows\n\tredraw_later(NOT_VALID);\n    }\n    win_enter(win1, FALSE);\n}\n\n/*\n * Make all windows the same height.\n * 'next_curwin' will soon be the current window, make sure it has enough\n * rows.\n */\n    void\nwin_equal(\n    win_T\t*next_curwin,\t// pointer to current window to be or NULL\n    int\t\tcurrent,\t// do only frame with current window\n    int\t\tdir)\t\t// 'v' for vertically, 'h' for horizontally,\n\t\t\t\t// 'b' for both, 0 for using p_ead\n{\n    if (dir == 0)\n\tdir = *p_ead;\n    win_equal_rec(next_curwin == NULL ? curwin : next_curwin, current,\n\t\t      topframe, dir, 0, tabline_height(),\n\t\t\t\t\t   (int)Columns, topframe->fr_height);\n}\n\n/*\n * Set a frame to a new position and height, spreading the available room\n * equally over contained frames.\n * The window \"next_curwin\" (if not NULL) should at least get the size from\n * 'winheight' and 'winwidth' if possible.\n */\n    static void\nwin_equal_rec(\n    win_T\t*next_curwin,\t// pointer to current window to be or NULL\n    int\t\tcurrent,\t// do only frame with current window\n    frame_T\t*topfr,\t\t// frame to set size off\n    int\t\tdir,\t\t// 'v', 'h' or 'b', see win_equal()\n    int\t\tcol,\t\t// horizontal position for frame\n    int\t\trow,\t\t// vertical position for frame\n    int\t\twidth,\t\t// new width of frame\n    int\t\theight)\t\t// new height of frame\n{\n    int\t\tn, m;\n    int\t\textra_sep = 0;\n    int\t\twincount, totwincount = 0;\n    frame_T\t*fr;\n    int\t\tnext_curwin_size = 0;\n    int\t\troom = 0;\n    int\t\tnew_size;\n    int\t\thas_next_curwin = 0;\n    int\t\thnc;\n\n    if (topfr->fr_layout == FR_LEAF)\n    {\n\t// Set the width/height of this frame.\n\t// Redraw when size or position changes\n\tif (topfr->fr_height != height || topfr->fr_win->w_winrow != row\n\t\t|| topfr->fr_width != width || topfr->fr_win->w_wincol != col\n\t   )\n\t{\n\t    topfr->fr_win->w_winrow = row;\n\t    frame_new_height(topfr, height, FALSE, FALSE);\n\t    topfr->fr_win->w_wincol = col;\n\t    frame_new_width(topfr, width, FALSE, FALSE);\n\t    redraw_all_later(NOT_VALID);\n\t}\n    }\n    else if (topfr->fr_layout == FR_ROW)\n    {\n\ttopfr->fr_width = width;\n\ttopfr->fr_height = height;\n\n\tif (dir != 'v')\t\t\t// equalize frame widths\n\t{\n\t    // Compute the maximum number of windows horizontally in this\n\t    // frame.\n\t    n = frame_minwidth(topfr, NOWIN);\n\t    // add one for the rightmost window, it doesn't have a separator\n\t    if (col + width == Columns)\n\t\textra_sep = 1;\n\t    else\n\t\textra_sep = 0;\n\t    totwincount = (n + extra_sep) / (p_wmw + 1);\n\t    has_next_curwin = frame_has_win(topfr, next_curwin);\n\n\t    /*\n\t     * Compute width for \"next_curwin\" window and room available for\n\t     * other windows.\n\t     * \"m\" is the minimal width when counting p_wiw for \"next_curwin\".\n\t     */\n\t    m = frame_minwidth(topfr, next_curwin);\n\t    room = width - m;\n\t    if (room < 0)\n\t    {\n\t\tnext_curwin_size = p_wiw + room;\n\t\troom = 0;\n\t    }\n\t    else\n\t    {\n\t\tnext_curwin_size = -1;\n\t\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t\t{\n\t\t    // If 'winfixwidth' set keep the window width if\n\t\t    // possible.\n\t\t    // Watch out for this window being the next_curwin.\n\t\t    if (frame_fixed_width(fr))\n\t\t    {\n\t\t\tn = frame_minwidth(fr, NOWIN);\n\t\t\tnew_size = fr->fr_width;\n\t\t\tif (frame_has_win(fr, next_curwin))\n\t\t\t{\n\t\t\t    room += p_wiw - p_wmw;\n\t\t\t    next_curwin_size = 0;\n\t\t\t    if (new_size < p_wiw)\n\t\t\t\tnew_size = p_wiw;\n\t\t\t}\n\t\t\telse\n\t\t\t    // These windows don't use up room.\n\t\t\t    totwincount -= (n + (fr->fr_next == NULL\n\t\t\t\t\t      ? extra_sep : 0)) / (p_wmw + 1);\n\t\t\troom -= new_size - n;\n\t\t\tif (room < 0)\n\t\t\t{\n\t\t\t    new_size += room;\n\t\t\t    room = 0;\n\t\t\t}\n\t\t\tfr->fr_newwidth = new_size;\n\t\t    }\n\t\t}\n\t\tif (next_curwin_size == -1)\n\t\t{\n\t\t    if (!has_next_curwin)\n\t\t\tnext_curwin_size = 0;\n\t\t    else if (totwincount > 1\n\t\t\t    && (room + (totwincount - 2))\n\t\t\t\t\t\t  / (totwincount - 1) > p_wiw)\n\t\t    {\n\t\t\t// Can make all windows wider than 'winwidth', spread\n\t\t\t// the room equally.\n\t\t\tnext_curwin_size = (room + p_wiw\n\t\t\t\t\t    + (totwincount - 1) * p_wmw\n\t\t\t\t\t    + (totwincount - 1)) / totwincount;\n\t\t\troom -= next_curwin_size - p_wiw;\n\t\t    }\n\t\t    else\n\t\t\tnext_curwin_size = p_wiw;\n\t\t}\n\t    }\n\n\t    if (has_next_curwin)\n\t\t--totwincount;\t\t// don't count curwin\n\t}\n\n\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t{\n\t    wincount = 1;\n\t    if (fr->fr_next == NULL)\n\t\t// last frame gets all that remains (avoid roundoff error)\n\t\tnew_size = width;\n\t    else if (dir == 'v')\n\t\tnew_size = fr->fr_width;\n\t    else if (frame_fixed_width(fr))\n\t    {\n\t\tnew_size = fr->fr_newwidth;\n\t\twincount = 0;\t    // doesn't count as a sizeable window\n\t    }\n\t    else\n\t    {\n\t\t// Compute the maximum number of windows horiz. in \"fr\".\n\t\tn = frame_minwidth(fr, NOWIN);\n\t\twincount = (n + (fr->fr_next == NULL ? extra_sep : 0))\n\t\t\t\t\t\t\t\t/ (p_wmw + 1);\n\t\tm = frame_minwidth(fr, next_curwin);\n\t\tif (has_next_curwin)\n\t\t    hnc = frame_has_win(fr, next_curwin);\n\t\telse\n\t\t    hnc = FALSE;\n\t\tif (hnc)\t    // don't count next_curwin\n\t\t    --wincount;\n\t\tif (totwincount == 0)\n\t\t    new_size = room;\n\t\telse\n\t\t    new_size = (wincount * room + ((unsigned)totwincount >> 1))\n\t\t\t\t\t\t\t\t/ totwincount;\n\t\tif (hnc)\t    // add next_curwin size\n\t\t{\n\t\t    next_curwin_size -= p_wiw - (m - n);\n\t\t    new_size += next_curwin_size;\n\t\t    room -= new_size - next_curwin_size;\n\t\t}\n\t\telse\n\t\t    room -= new_size;\n\t\tnew_size += n;\n\t    }\n\n\t    // Skip frame that is full width when splitting or closing a\n\t    // window, unless equalizing all frames.\n\t    if (!current || dir != 'v' || topfr->fr_parent != NULL\n\t\t    || (new_size != fr->fr_width)\n\t\t    || frame_has_win(fr, next_curwin))\n\t\twin_equal_rec(next_curwin, current, fr, dir, col, row,\n\t\t\t\t\t\t\t    new_size, height);\n\t    col += new_size;\n\t    width -= new_size;\n\t    totwincount -= wincount;\n\t}\n    }\n    else // topfr->fr_layout == FR_COL\n    {\n\ttopfr->fr_width = width;\n\ttopfr->fr_height = height;\n\n\tif (dir != 'h')\t\t\t// equalize frame heights\n\t{\n\t    // Compute maximum number of windows vertically in this frame.\n\t    n = frame_minheight(topfr, NOWIN);\n\t    // add one for the bottom window if it doesn't have a statusline\n\t    if (row + height == cmdline_row && p_ls == 0)\n\t\textra_sep = 1;\n\t    else\n\t\textra_sep = 0;\n\t    totwincount = (n + extra_sep) / (p_wmh + 1);\n\t    has_next_curwin = frame_has_win(topfr, next_curwin);\n\n\t    /*\n\t     * Compute height for \"next_curwin\" window and room available for\n\t     * other windows.\n\t     * \"m\" is the minimal height when counting p_wh for \"next_curwin\".\n\t     */\n\t    m = frame_minheight(topfr, next_curwin);\n\t    room = height - m;\n\t    if (room < 0)\n\t    {\n\t\t// The room is less than 'winheight', use all space for the\n\t\t// current window.\n\t\tnext_curwin_size = p_wh + room;\n\t\troom = 0;\n\t    }\n\t    else\n\t    {\n\t\tnext_curwin_size = -1;\n\t\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t\t{\n\t\t    // If 'winfixheight' set keep the window height if\n\t\t    // possible.\n\t\t    // Watch out for this window being the next_curwin.\n\t\t    if (frame_fixed_height(fr))\n\t\t    {\n\t\t\tn = frame_minheight(fr, NOWIN);\n\t\t\tnew_size = fr->fr_height;\n\t\t\tif (frame_has_win(fr, next_curwin))\n\t\t\t{\n\t\t\t    room += p_wh - p_wmh;\n\t\t\t    next_curwin_size = 0;\n\t\t\t    if (new_size < p_wh)\n\t\t\t\tnew_size = p_wh;\n\t\t\t}\n\t\t\telse\n\t\t\t    // These windows don't use up room.\n\t\t\t    totwincount -= (n + (fr->fr_next == NULL\n\t\t\t\t\t      ? extra_sep : 0)) / (p_wmh + 1);\n\t\t\troom -= new_size - n;\n\t\t\tif (room < 0)\n\t\t\t{\n\t\t\t    new_size += room;\n\t\t\t    room = 0;\n\t\t\t}\n\t\t\tfr->fr_newheight = new_size;\n\t\t    }\n\t\t}\n\t\tif (next_curwin_size == -1)\n\t\t{\n\t\t    if (!has_next_curwin)\n\t\t\tnext_curwin_size = 0;\n\t\t    else if (totwincount > 1\n\t\t\t    && (room + (totwincount - 2))\n\t\t\t\t\t\t   / (totwincount - 1) > p_wh)\n\t\t    {\n\t\t\t// can make all windows higher than 'winheight',\n\t\t\t// spread the room equally.\n\t\t\tnext_curwin_size = (room + p_wh\n\t\t\t\t\t   + (totwincount - 1) * p_wmh\n\t\t\t\t\t   + (totwincount - 1)) / totwincount;\n\t\t\troom -= next_curwin_size - p_wh;\n\t\t    }\n\t\t    else\n\t\t\tnext_curwin_size = p_wh;\n\t\t}\n\t    }\n\n\t    if (has_next_curwin)\n\t\t--totwincount;\t\t// don't count curwin\n\t}\n\n\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t{\n\t    wincount = 1;\n\t    if (fr->fr_next == NULL)\n\t\t// last frame gets all that remains (avoid roundoff error)\n\t\tnew_size = height;\n\t    else if (dir == 'h')\n\t\tnew_size = fr->fr_height;\n\t    else if (frame_fixed_height(fr))\n\t    {\n\t\tnew_size = fr->fr_newheight;\n\t\twincount = 0;\t    // doesn't count as a sizeable window\n\t    }\n\t    else\n\t    {\n\t\t// Compute the maximum number of windows vert. in \"fr\".\n\t\tn = frame_minheight(fr, NOWIN);\n\t\twincount = (n + (fr->fr_next == NULL ? extra_sep : 0))\n\t\t\t\t\t\t\t\t/ (p_wmh + 1);\n\t\tm = frame_minheight(fr, next_curwin);\n\t\tif (has_next_curwin)\n\t\t    hnc = frame_has_win(fr, next_curwin);\n\t\telse\n\t\t    hnc = FALSE;\n\t\tif (hnc)\t    // don't count next_curwin\n\t\t    --wincount;\n\t\tif (totwincount == 0)\n\t\t    new_size = room;\n\t\telse\n\t\t    new_size = (wincount * room + ((unsigned)totwincount >> 1))\n\t\t\t\t\t\t\t\t/ totwincount;\n\t\tif (hnc)\t    // add next_curwin size\n\t\t{\n\t\t    next_curwin_size -= p_wh - (m - n);\n\t\t    new_size += next_curwin_size;\n\t\t    room -= new_size - next_curwin_size;\n\t\t}\n\t\telse\n\t\t    room -= new_size;\n\t\tnew_size += n;\n\t    }\n\t    // Skip frame that is full width when splitting or closing a\n\t    // window, unless equalizing all frames.\n\t    if (!current || dir != 'h' || topfr->fr_parent != NULL\n\t\t    || (new_size != fr->fr_height)\n\t\t    || frame_has_win(fr, next_curwin))\n\t\twin_equal_rec(next_curwin, current, fr, dir, col, row,\n\t\t\t\t\t\t\t     width, new_size);\n\t    row += new_size;\n\t    height -= new_size;\n\t    totwincount -= wincount;\n\t}\n    }\n}\n\n#ifdef FEAT_JOB_CHANNEL\n    static void\nleaving_window(win_T *win)\n{\n    // Only matters for a prompt window.\n    if (!bt_prompt(win->w_buffer))\n\treturn;\n\n    // When leaving a prompt window stop Insert mode and perhaps restart\n    // it when entering that window again.\n    win->w_buffer->b_prompt_insert = restart_edit;\n    if (restart_edit != 0 && mode_displayed)\n\tclear_cmdline = TRUE;\t\t// unshow mode later\n    restart_edit = NUL;\n\n    // When leaving the window (or closing the window) was done from a\n    // callback we need to break out of the Insert mode loop and restart Insert\n    // mode when entering the window again.\n    if (State & MODE_INSERT)\n    {\n\tstop_insert_mode = TRUE;\n\tif (win->w_buffer->b_prompt_insert == NUL)\n\t    win->w_buffer->b_prompt_insert = 'A';\n    }\n}\n\n    void\nentering_window(win_T *win)\n{\n    // Only matters for a prompt window.\n    if (!bt_prompt(win->w_buffer))\n\treturn;\n\n    // When switching to a prompt buffer that was in Insert mode, don't stop\n    // Insert mode, it may have been set in leaving_window().\n    if (win->w_buffer->b_prompt_insert != NUL)\n\tstop_insert_mode = FALSE;\n\n    // When entering the prompt window restart Insert mode if we were in Insert\n    // mode when we left it and not already in Insert mode.\n    if ((State & MODE_INSERT) == 0)\n\trestart_edit = win->w_buffer->b_prompt_insert;\n}\n#endif\n\n    static void\nwin_init_empty(win_T *wp)\n{\n    redraw_win_later(wp, NOT_VALID);\n    wp->w_lines_valid = 0;\n    wp->w_cursor.lnum = 1;\n    wp->w_curswant = wp->w_cursor.col = 0;\n    wp->w_cursor.coladd = 0;\n    wp->w_pcmark.lnum = 1;\t// pcmark not cleared but set to line 1\n    wp->w_pcmark.col = 0;\n    wp->w_prev_pcmark.lnum = 0;\n    wp->w_prev_pcmark.col = 0;\n    wp->w_topline = 1;\n#ifdef FEAT_DIFF\n    wp->w_topfill = 0;\n#endif\n    wp->w_botline = 2;\n#if defined(FEAT_SYN_HL) || defined(FEAT_SPELL)\n    wp->w_s = &wp->w_buffer->b_s;\n#endif\n#ifdef FEAT_TERMINAL\n    term_reset_wincolor(wp);\n#endif\n}\n\n/*\n * Init the current window \"curwin\".\n * Called when a new file is being edited.\n */\n    void\ncurwin_init(void)\n{\n    win_init_empty(curwin);\n}\n\n/*\n * Close all windows for buffer \"buf\".\n */\n    void\nclose_windows(\n    buf_T\t*buf,\n    int\t\tkeep_curwin)\t    // don't close \"curwin\"\n{\n    win_T\t*wp;\n    tabpage_T   *tp, *nexttp;\n    int\t\th = tabline_height();\n    int\t\tcount = tabpage_index(NULL);\n\n    ++RedrawingDisabled;\n\n    for (wp = firstwin; wp != NULL && !ONE_WINDOW; )\n    {\n\tif (wp->w_buffer == buf && (!keep_curwin || wp != curwin)\n\t\t&& !(wp->w_closing || wp->w_buffer->b_locked > 0))\n\t{\n\t    if (win_close(wp, FALSE) == FAIL)\n\t\t// If closing the window fails give up, to avoid looping\n\t\t// forever.\n\t\tbreak;\n\n\t    // Start all over, autocommands may change the window layout.\n\t    wp = firstwin;\n\t}\n\telse\n\t    wp = wp->w_next;\n    }\n\n    // Also check windows in other tab pages.\n    for (tp = first_tabpage; tp != NULL; tp = nexttp)\n    {\n\tnexttp = tp->tp_next;\n\tif (tp != curtab)\n\t    FOR_ALL_WINDOWS_IN_TAB(tp, wp)\n\t\tif (wp->w_buffer == buf\n\t\t    && !(wp->w_closing || wp->w_buffer->b_locked > 0))\n\t\t{\n\t\t    win_close_othertab(wp, FALSE, tp);\n\n\t\t    // Start all over, the tab page may be closed and\n\t\t    // autocommands may change the window layout.\n\t\t    nexttp = first_tabpage;\n\t\t    break;\n\t\t}\n    }\n\n    --RedrawingDisabled;\n\n    if (count != tabpage_index(NULL))\n\tapply_autocmds(EVENT_TABCLOSED, NULL, NULL, FALSE, curbuf);\n\n    redraw_tabline = TRUE;\n    if (h != tabline_height())\n\tshell_new_rows();\n}\n\n/*\n * Return TRUE if the current window is the only window that exists (ignoring\n * \"aucmd_win\").\n * Returns FALSE if there is a window, possibly in another tab page.\n */\n    static int\nlast_window(void)\n{\n    return (one_window() && first_tabpage->tp_next == NULL);\n}\n\n/*\n * Return TRUE if there is only one window other than \"aucmd_win\" in the\n * current tab page.\n */\n    int\none_window(void)\n{\n    win_T\t*wp;\n    int\t\tseen_one = FALSE;\n\n    FOR_ALL_WINDOWS(wp)\n    {\n\tif (wp != aucmd_win)\n\t{\n\t    if (seen_one)\n\t\treturn FALSE;\n\t    seen_one = TRUE;\n\t}\n    }\n    return TRUE;\n}\n\n/*\n * Close the possibly last window in a tab page.\n * Returns TRUE when the window was closed already.\n */\n    static int\nclose_last_window_tabpage(\n    win_T\t*win,\n    int\t\tfree_buf,\n    tabpage_T   *prev_curtab)\n{\n    if (ONE_WINDOW)\n    {\n\tbuf_T\t*old_curbuf = curbuf;\n\n\t/*\n\t * Closing the last window in a tab page.  First go to another tab\n\t * page and then close the window and the tab page.  This avoids that\n\t * curwin and curtab are invalid while we are freeing memory, they may\n\t * be used in GUI events.\n\t * Don't trigger autocommands yet, they may use wrong values, so do\n\t * that below.\n\t */\n\tgoto_tabpage_tp(alt_tabpage(), FALSE, TRUE);\n\tredraw_tabline = TRUE;\n\n\t// Safety check: Autocommands may have closed the window when jumping\n\t// to the other tab page.\n\tif (valid_tabpage(prev_curtab) && prev_curtab->tp_firstwin == win)\n\t{\n\t    int\t    h = tabline_height();\n\n\t    win_close_othertab(win, free_buf, prev_curtab);\n\t    if (h != tabline_height())\n\t\tshell_new_rows();\n\t}\n#ifdef FEAT_JOB_CHANNEL\n\tentering_window(curwin);\n#endif\n\t// Since goto_tabpage_tp above did not trigger *Enter autocommands, do\n\t// that now.\n\tapply_autocmds(EVENT_TABCLOSED, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);\n\tif (old_curbuf != curbuf)\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Close the buffer of \"win\" and unload it if \"action\" is DOBUF_UNLOAD.\n * \"action\" can also be zero (do nothing) or DOBUF_WIPE.\n * \"abort_if_last\" is passed to close_buffer(): abort closing if all other\n * windows are closed.\n */\n    static void\nwin_close_buffer(win_T *win, int action, int abort_if_last)\n{\n#ifdef FEAT_SYN_HL\n    // Free independent synblock before the buffer is freed.\n    if (win->w_buffer != NULL)\n\treset_synblock(win);\n#endif\n\n#ifdef FEAT_QUICKFIX\n    // When a quickfix/location list window is closed and the buffer is\n    // displayed in only one window, then unlist the buffer.\n    if (win->w_buffer != NULL && bt_quickfix(win->w_buffer)\n\t\t\t\t\t&& win->w_buffer->b_nwindows == 1)\n\twin->w_buffer->b_p_bl = FALSE;\n#endif\n\n    // Close the link to the buffer.\n    if (win->w_buffer != NULL)\n    {\n\tbufref_T    bufref;\n\n\tset_bufref(&bufref, curbuf);\n\twin->w_closing = TRUE;\n\tclose_buffer(win, win->w_buffer, action, abort_if_last, TRUE);\n\tif (win_valid_any_tab(win))\n\t    win->w_closing = FALSE;\n\t// Make sure curbuf is valid. It can become invalid if 'bufhidden' is\n\t// \"wipe\".\n\tif (!bufref_valid(&bufref))\n\t    curbuf = firstbuf;\n    }\n}\n\n/*\n * Close window \"win\".  Only works for the current tab page.\n * If \"free_buf\" is TRUE related buffer may be unloaded.\n *\n * Called by :quit, :close, :xit, :wq and findtag().\n * Returns FAIL when the window was not closed.\n */\n    int\nwin_close(win_T *win, int free_buf)\n{\n    win_T\t*wp;\n    int\t\tother_buffer = FALSE;\n    int\t\tclose_curwin = FALSE;\n    int\t\tdir;\n    int\t\thelp_window = FALSE;\n    tabpage_T   *prev_curtab = curtab;\n    frame_T\t*win_frame = win->w_frame->fr_parent;\n#ifdef FEAT_DIFF\n    int\t\thad_diffmode = win->w_p_diff;\n#endif\n#ifdef MESSAGE_QUEUE\n    int\t\tdid_decrement = FALSE;\n#endif\n\n#if defined(FEAT_TERMINAL) && defined(FEAT_PROP_POPUP)\n    // Can close a popup window with a terminal if the job has finished.\n    if (may_close_term_popup() == OK)\n\treturn OK;\n#endif\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn FAIL;\n\n    if (last_window())\n    {\n\temsg(_(e_cannot_close_last_window));\n\treturn FAIL;\n    }\n\n    if (win->w_closing || (win->w_buffer != NULL\n\t\t\t\t\t       && win->w_buffer->b_locked > 0))\n\treturn FAIL; // window is already being closed\n    if (win_unlisted(win))\n    {\n\temsg(_(e_cannot_close_autocmd_or_popup_window));\n\treturn FAIL;\n    }\n    if ((firstwin == aucmd_win || lastwin == aucmd_win) && one_window())\n    {\n\temsg(_(e_cannot_close_window_only_autocmd_window_would_remain));\n\treturn FAIL;\n    }\n\n    // When closing the last window in a tab page first go to another tab page\n    // and then close the window and the tab page to avoid that curwin and\n    // curtab are invalid while we are freeing memory.\n    if (close_last_window_tabpage(win, free_buf, prev_curtab))\n      return FAIL;\n\n    // When closing the help window, try restoring a snapshot after closing\n    // the window.  Otherwise clear the snapshot, it's now invalid.\n    if (bt_help(win->w_buffer))\n\thelp_window = TRUE;\n    else\n\tclear_snapshot(curtab, SNAP_HELP_IDX);\n\n    if (win == curwin)\n    {\n#ifdef FEAT_JOB_CHANNEL\n\tleaving_window(curwin);\n#endif\n\t/*\n\t * Guess which window is going to be the new current window.\n\t * This may change because of the autocommands (sigh).\n\t */\n\twp = frame2win(win_altframe(win, NULL));\n\n\t/*\n\t * Be careful: If autocommands delete the window or cause this window\n\t * to be the last one left, return now.\n\t */\n\tif (wp->w_buffer != curbuf)\n\t{\n\t    reset_VIsual_and_resel();\t// stop Visual mode\n\n\t    other_buffer = TRUE;\n\t    win->w_closing = TRUE;\n\t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n\t    if (!win_valid(win))\n\t\treturn FAIL;\n\t    win->w_closing = FALSE;\n\t    if (last_window())\n\t\treturn FAIL;\n\t}\n\twin->w_closing = TRUE;\n\tapply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (!win_valid(win))\n\t    return FAIL;\n\twin->w_closing = FALSE;\n\tif (last_window())\n\t    return FAIL;\n#ifdef FEAT_EVAL\n\t// autocmds may abort script processing\n\tif (aborting())\n\t    return FAIL;\n#endif\n    }\n\n#ifdef FEAT_GUI\n    // Avoid trouble with scrollbars that are going to be deleted in\n    // win_free().\n    if (gui.in_use)\n\tout_flush();\n#endif\n\n#ifdef FEAT_PROP_POPUP\n    if (popup_win_closed(win) && !win_valid(win))\n\treturn FAIL;\n#endif\n\n    // Trigger WinClosed just before starting to free window-related resources.\n    trigger_winclosed(win);\n    // autocmd may have freed the window already.\n    if (!win_valid_any_tab(win))\n\treturn OK;\n\n    win_close_buffer(win, free_buf ? DOBUF_UNLOAD : 0, TRUE);\n\n    if (only_one_window() && win_valid(win) && win->w_buffer == NULL\n\t    && (last_window() || curtab != prev_curtab\n\t\t|| close_last_window_tabpage(win, free_buf, prev_curtab)))\n    {\n\t// Autocommands have closed all windows, quit now.  Restore\n\t// curwin->w_buffer, otherwise writing viminfo may fail.\n\tif (curwin->w_buffer == NULL)\n\t    curwin->w_buffer = curbuf;\n\tgetout(0);\n    }\n\n    // Autocommands may have moved to another tab page.\n    if (curtab != prev_curtab && win_valid_any_tab(win)\n\t\t\t\t\t\t      && win->w_buffer == NULL)\n    {\n\t// Need to close the window anyway, since the buffer is NULL.\n\twin_close_othertab(win, FALSE, prev_curtab);\n\treturn FAIL;\n    }\n\n    // Autocommands may have closed the window already or closed the only\n    // other window.\n    if (!win_valid(win) || last_window()\n\t    || close_last_window_tabpage(win, free_buf, prev_curtab))\n\treturn FAIL;\n\n    // Now we are really going to close the window.  Disallow any autocommand\n    // to split a window to avoid trouble.\n    // Also bail out of parse_queued_messages() to avoid it tries to update the\n    // screen.\n    ++split_disallowed;\n#ifdef MESSAGE_QUEUE\n    ++dont_parse_messages;\n#endif\n\n    // Free the memory used for the window and get the window that received\n    // the screen space.\n    wp = win_free_mem(win, &dir, NULL);\n\n    if (help_window)\n    {\n\t// Closing the help window moves the cursor back to the current window\n\t// of the snapshot.\n\twin_T *prev_win = get_snapshot_curwin(SNAP_HELP_IDX);\n\n\tif (win_valid(prev_win))\n\t    wp = prev_win;\n    }\n\n    // Make sure curwin isn't invalid.  It can cause severe trouble when\n    // printing an error message.  For win_equal() curbuf needs to be valid\n    // too.\n    if (win == curwin)\n    {\n\tcurwin = wp;\n#ifdef FEAT_QUICKFIX\n\tif (wp->w_p_pvw || bt_quickfix(wp->w_buffer))\n\t{\n\t    /*\n\t     * If the cursor goes to the preview or the quickfix window, try\n\t     * finding another window to go to.\n\t     */\n\t    for (;;)\n\t    {\n\t\tif (wp->w_next == NULL)\n\t\t    wp = firstwin;\n\t\telse\n\t\t    wp = wp->w_next;\n\t\tif (wp == curwin)\n\t\t    break;\n\t\tif (!wp->w_p_pvw && !bt_quickfix(wp->w_buffer))\n\t\t{\n\t\t    curwin = wp;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n#endif\n\tcurbuf = curwin->w_buffer;\n\tclose_curwin = TRUE;\n\n\t// The cursor position may be invalid if the buffer changed after last\n\t// using the window.\n\tcheck_cursor();\n    }\n    if (p_ea && (*p_ead == 'b' || *p_ead == dir))\n\t// If the frame of the closed window contains the new current window,\n\t// only resize that frame.  Otherwise resize all windows.\n\twin_equal(curwin, curwin->w_frame->fr_parent == win_frame, dir);\n    else\n\twin_comp_pos();\n    if (close_curwin)\n    {\n\t// Pass WEE_ALLOW_PARSE_MESSAGES to decrement dont_parse_messages\n\t// before autocommands.\n#ifdef MESSAGE_QUEUE\n\tdid_decrement =\n#else\n\t(void)\n#endif\n\t    win_enter_ext(wp,\n\t\tWEE_CURWIN_INVALID | WEE_TRIGGER_ENTER_AUTOCMDS\n\t\t      | WEE_TRIGGER_LEAVE_AUTOCMDS | WEE_ALLOW_PARSE_MESSAGES);\n\tif (other_buffer)\n\t    // careful: after this wp and win may be invalid!\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n    --split_disallowed;\n#ifdef MESSAGE_QUEUE\n    if (!did_decrement)\n\t--dont_parse_messages;\n#endif\n\n    /*\n     * If last window has a status line now and we don't want one,\n     * remove the status line.\n     */\n    last_status(FALSE);\n\n    // After closing the help window, try restoring the window layout from\n    // before it was opened.\n    if (help_window)\n\trestore_snapshot(SNAP_HELP_IDX, close_curwin);\n\n#ifdef FEAT_DIFF\n    // If the window had 'diff' set and now there is only one window left in\n    // the tab page with 'diff' set, and \"closeoff\" is in 'diffopt', then\n    // execute \":diffoff!\".\n    if (diffopt_closeoff() && had_diffmode && curtab == prev_curtab)\n    {\n\tint\tdiffcount = 0;\n\twin_T\t*dwin;\n\n\tFOR_ALL_WINDOWS(dwin)\n\t    if (dwin->w_p_diff)\n\t\t++diffcount;\n\tif (diffcount == 1)\n\t    do_cmdline_cmd((char_u *)\"diffoff!\");\n    }\n#endif\n\n#if defined(FEAT_GUI)\n    // When 'guioptions' includes 'L' or 'R' may have to remove scrollbars.\n    if (gui.in_use && !win_hasvertsplit())\n\tgui_init_which_components(NULL);\n#endif\n\n    redraw_all_later(NOT_VALID);\n    return OK;\n}\n\n    static void\ntrigger_winclosed(win_T *win)\n{\n    static int\trecursive = FALSE;\n    char_u\twinid[NUMBUFLEN];\n\n    if (recursive)\n\treturn;\n    recursive = TRUE;\n    vim_snprintf((char *)winid, sizeof(winid), \"%d\", win->w_id);\n    apply_autocmds(EVENT_WINCLOSED, winid, winid, FALSE, win->w_buffer);\n    recursive = FALSE;\n}\n\n/*\n * Trigger WinScrolled for \"curwin\" if needed.\n */\n    void\nmay_trigger_winscrolled(void)\n{\n    win_T\t    *wp = curwin;\n    static int\t    recursive = FALSE;\n    char_u\t    winid[NUMBUFLEN];\n\n    if (recursive || !has_winscrolled())\n\treturn;\n\n    if (wp->w_last_topline != wp->w_topline\n\t    || wp->w_last_leftcol != wp->w_leftcol\n\t    || wp->w_last_width != wp->w_width\n\t    || wp->w_last_height != wp->w_height)\n    {\n\tvim_snprintf((char *)winid, sizeof(winid), \"%d\", wp->w_id);\n\n\trecursive = TRUE;\n\tapply_autocmds(EVENT_WINSCROLLED, winid, winid, FALSE, wp->w_buffer);\n\trecursive = FALSE;\n\n\t// an autocmd may close the window, \"wp\" may be invalid now\n\tif (win_valid_any_tab(wp))\n\t{\n\t    wp->w_last_topline = wp->w_topline;\n\t    wp->w_last_leftcol = wp->w_leftcol;\n\t    wp->w_last_width = wp->w_width;\n\t    wp->w_last_height = wp->w_height;\n\t}\n    }\n}\n\n/*\n * Close window \"win\" in tab page \"tp\", which is not the current tab page.\n * This may be the last window in that tab page and result in closing the tab,\n * thus \"tp\" may become invalid!\n * Caller must check if buffer is hidden and whether the tabline needs to be\n * updated.\n */\n    void\nwin_close_othertab(win_T *win, int free_buf, tabpage_T *tp)\n{\n    win_T\t*wp;\n    int\t\tdir;\n    tabpage_T   *ptp = NULL;\n    int\t\tfree_tp = FALSE;\n\n    // Get here with win->w_buffer == NULL when win_close() detects the tab\n    // page changed.\n    if (win->w_closing || (win->w_buffer != NULL\n\t\t\t\t\t       && win->w_buffer->b_locked > 0))\n\treturn; // window is already being closed\n\n    // Trigger WinClosed just before starting to free window-related resources.\n    trigger_winclosed(win);\n    // autocmd may have freed the window already.\n    if (!win_valid_any_tab(win))\n\treturn;\n\n    if (win->w_buffer != NULL)\n\t// Close the link to the buffer.\n\tclose_buffer(win, win->w_buffer, free_buf ? DOBUF_UNLOAD : 0,\n\t\t\t\t\t\t\t\t FALSE, TRUE);\n\n    // Careful: Autocommands may have closed the tab page or made it the\n    // current tab page.\n    for (ptp = first_tabpage; ptp != NULL && ptp != tp; ptp = ptp->tp_next)\n\t;\n    if (ptp == NULL || tp == curtab)\n    {\n\t// If the buffer was removed from the window we have to give it any\n\t// buffer.\n\tif (win_valid_any_tab(win) && win->w_buffer == NULL)\n\t{\n\t    win->w_buffer = firstbuf;\n\t    ++firstbuf->b_nwindows;\n\t    win_init_empty(win);\n\t}\n\treturn;\n    }\n\n    // Autocommands may have closed the window already.\n    for (wp = tp->tp_firstwin; wp != NULL && wp != win; wp = wp->w_next)\n\t;\n    if (wp == NULL)\n\treturn;\n\n    // When closing the last window in a tab page remove the tab page.\n    if (tp->tp_firstwin == tp->tp_lastwin)\n    {\n\tif (tp == first_tabpage)\n\t    first_tabpage = tp->tp_next;\n\telse\n\t{\n\t    for (ptp = first_tabpage; ptp != NULL && ptp->tp_next != tp;\n\t\t\t\t\t\t\t   ptp = ptp->tp_next)\n\t\t;\n\t    if (ptp == NULL)\n\t    {\n\t\tinternal_error(\"win_close_othertab()\");\n\t\treturn;\n\t    }\n\t    ptp->tp_next = tp->tp_next;\n\t}\n\tfree_tp = TRUE;\n    }\n\n    // Free the memory used for the window.\n    win_free_mem(win, &dir, tp);\n\n    if (free_tp)\n\tfree_tabpage(tp);\n}\n\n/*\n * Free the memory used for a window.\n * Returns a pointer to the window that got the freed up space.\n */\n    static win_T *\nwin_free_mem(\n    win_T\t*win,\n    int\t\t*dirp,\t\t// set to 'v' or 'h' for direction if 'ea'\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    frame_T\t*frp;\n    win_T\t*wp;\n    tabpage_T\t*win_tp = tp == NULL ? curtab : tp;\n\n    // Remove the window and its frame from the tree of frames.\n    frp = win->w_frame;\n    wp = winframe_remove(win, dirp, tp);\n    vim_free(frp);\n    win_free(win, tp);\n\n    // When deleting the current window in the tab, select a new current\n    // window.\n    if (win == win_tp->tp_curwin)\n\twin_tp->tp_curwin = wp;\n\n    return wp;\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nwin_free_all(void)\n{\n    int\t\tdummy;\n\n#ifdef FEAT_CMDWIN\n    // avoid an error for switching tabpage with the cmdline window open\n    cmdwin_type = 0;\n#endif\n    while (first_tabpage->tp_next != NULL)\n\ttabpage_close(TRUE);\n\n    if (aucmd_win != NULL)\n    {\n\t(void)win_free_mem(aucmd_win, &dummy, NULL);\n\taucmd_win = NULL;\n    }\n\n    while (firstwin != NULL)\n\t(void)win_free_mem(firstwin, &dummy, NULL);\n\n    // No window should be used after this. Set curwin to NULL to crash\n    // instead of using freed memory.\n    curwin = NULL;\n}\n#endif\n\n/*\n * Remove a window and its frame from the tree of frames.\n * Returns a pointer to the window that got the freed up space.\n */\n    win_T *\nwinframe_remove(\n    win_T\t*win,\n    int\t\t*dirp UNUSED,\t// set to 'v' or 'h' for direction if 'ea'\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    frame_T\t*frp, *frp2, *frp3;\n    frame_T\t*frp_close = win->w_frame;\n    win_T\t*wp;\n\n    /*\n     * If there is only one window there is nothing to remove.\n     */\n    if (tp == NULL ? ONE_WINDOW : tp->tp_firstwin == tp->tp_lastwin)\n\treturn NULL;\n\n    /*\n     * Remove the window from its frame.\n     */\n    frp2 = win_altframe(win, tp);\n    wp = frame2win(frp2);\n\n    // Remove this frame from the list of frames.\n    frame_remove(frp_close);\n\n    if (frp_close->fr_parent->fr_layout == FR_COL)\n    {\n\t// When 'winfixheight' is set, try to find another frame in the column\n\t// (as close to the closed frame as possible) to distribute the height\n\t// to.\n\tif (frp2->fr_win != NULL && frp2->fr_win->w_p_wfh)\n\t{\n\t    frp = frp_close->fr_prev;\n\t    frp3 = frp_close->fr_next;\n\t    while (frp != NULL || frp3 != NULL)\n\t    {\n\t\tif (frp != NULL)\n\t\t{\n\t\t    if (!frame_fixed_height(frp))\n\t\t    {\n\t\t\tfrp2 = frp;\n\t\t\twp = frame2win(frp2);\n\t\t\tbreak;\n\t\t    }\n\t\t    frp = frp->fr_prev;\n\t\t}\n\t\tif (frp3 != NULL)\n\t\t{\n\t\t    if (frp3->fr_win != NULL && !frp3->fr_win->w_p_wfh)\n\t\t    {\n\t\t\tfrp2 = frp3;\n\t\t\twp = frp3->fr_win;\n\t\t\tbreak;\n\t\t    }\n\t\t    frp3 = frp3->fr_next;\n\t\t}\n\t    }\n\t}\n\tframe_new_height(frp2, frp2->fr_height + frp_close->fr_height,\n\t\t\t    frp2 == frp_close->fr_next ? TRUE : FALSE, FALSE);\n\t*dirp = 'v';\n    }\n    else\n    {\n\t// When 'winfixwidth' is set, try to find another frame in the column\n\t// (as close to the closed frame as possible) to distribute the width\n\t// to.\n\tif (frp2->fr_win != NULL && frp2->fr_win->w_p_wfw)\n\t{\n\t    frp = frp_close->fr_prev;\n\t    frp3 = frp_close->fr_next;\n\t    while (frp != NULL || frp3 != NULL)\n\t    {\n\t\tif (frp != NULL)\n\t\t{\n\t\t    if (!frame_fixed_width(frp))\n\t\t    {\n\t\t\tfrp2 = frp;\n\t\t\twp = frame2win(frp2);\n\t\t\tbreak;\n\t\t    }\n\t\t    frp = frp->fr_prev;\n\t\t}\n\t\tif (frp3 != NULL)\n\t\t{\n\t\t    if (frp3->fr_win != NULL && !frp3->fr_win->w_p_wfw)\n\t\t    {\n\t\t\tfrp2 = frp3;\n\t\t\twp = frp3->fr_win;\n\t\t\tbreak;\n\t\t    }\n\t\t    frp3 = frp3->fr_next;\n\t\t}\n\t    }\n\t}\n\tframe_new_width(frp2, frp2->fr_width + frp_close->fr_width,\n\t\t\t    frp2 == frp_close->fr_next ? TRUE : FALSE, FALSE);\n\t*dirp = 'h';\n    }\n\n    // If rows/columns go to a window below/right its positions need to be\n    // updated.  Can only be done after the sizes have been updated.\n    if (frp2 == frp_close->fr_next)\n    {\n\tint row = win->w_winrow;\n\tint col = win->w_wincol;\n\n\tframe_comp_pos(frp2, &row, &col);\n    }\n\n    if (frp2->fr_next == NULL && frp2->fr_prev == NULL)\n    {\n\t// There is no other frame in this list, move its info to the parent\n\t// and remove it.\n\tfrp2->fr_parent->fr_layout = frp2->fr_layout;\n\tfrp2->fr_parent->fr_child = frp2->fr_child;\n\tFOR_ALL_FRAMES(frp, frp2->fr_child)\n\t    frp->fr_parent = frp2->fr_parent;\n\tfrp2->fr_parent->fr_win = frp2->fr_win;\n\tif (frp2->fr_win != NULL)\n\t    frp2->fr_win->w_frame = frp2->fr_parent;\n\tfrp = frp2->fr_parent;\n\tif (topframe->fr_child == frp2)\n\t    topframe->fr_child = frp;\n\tvim_free(frp2);\n\n\tfrp2 = frp->fr_parent;\n\tif (frp2 != NULL && frp2->fr_layout == frp->fr_layout)\n\t{\n\t    // The frame above the parent has the same layout, have to merge\n\t    // the frames into this list.\n\t    if (frp2->fr_child == frp)\n\t\tfrp2->fr_child = frp->fr_child;\n\t    frp->fr_child->fr_prev = frp->fr_prev;\n\t    if (frp->fr_prev != NULL)\n\t\tfrp->fr_prev->fr_next = frp->fr_child;\n\t    for (frp3 = frp->fr_child; ; frp3 = frp3->fr_next)\n\t    {\n\t\tfrp3->fr_parent = frp2;\n\t\tif (frp3->fr_next == NULL)\n\t\t{\n\t\t    frp3->fr_next = frp->fr_next;\n\t\t    if (frp->fr_next != NULL)\n\t\t\tfrp->fr_next->fr_prev = frp3;\n\t\t    break;\n\t\t}\n\t    }\n\t    if (topframe->fr_child == frp)\n\t\ttopframe->fr_child = frp2;\n\t    vim_free(frp);\n\t}\n    }\n\n    return wp;\n}\n\n/*\n * Return a pointer to the frame that will receive the empty screen space that\n * is left over after \"win\" is closed.\n *\n * If 'splitbelow' or 'splitright' is set, the space goes above or to the left\n * by default.  Otherwise, the free space goes below or to the right.  The\n * result is that opening a window and then immediately closing it will\n * preserve the initial window layout.  The 'wfh' and 'wfw' settings are\n * respected when possible.\n */\n    static frame_T *\nwin_altframe(\n    win_T\t*win,\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    frame_T\t*frp;\n    frame_T\t*other_fr, *target_fr;\n\n    if (tp == NULL ? ONE_WINDOW : tp->tp_firstwin == tp->tp_lastwin)\n\treturn alt_tabpage()->tp_curwin->w_frame;\n\n    frp = win->w_frame;\n\n    if (frp->fr_prev == NULL)\n\treturn frp->fr_next;\n    if (frp->fr_next == NULL)\n\treturn frp->fr_prev;\n\n    // By default the next window will get the space that was abandoned by this\n    // window\n    target_fr = frp->fr_next;\n    other_fr  = frp->fr_prev;\n\n    // If this is part of a column of windows and 'splitbelow' is true then the\n    // previous window will get the space.\n    if (frp->fr_parent != NULL && frp->fr_parent->fr_layout == FR_COL && p_sb)\n    {\n\ttarget_fr = frp->fr_prev;\n\tother_fr  = frp->fr_next;\n    }\n\n    // If this is part of a row of windows, and 'splitright' is true then the\n    // previous window will get the space.\n    if (frp->fr_parent != NULL && frp->fr_parent->fr_layout == FR_ROW && p_spr)\n    {\n\ttarget_fr = frp->fr_prev;\n\tother_fr  = frp->fr_next;\n    }\n\n    // If 'wfh' or 'wfw' is set for the target and not for the alternate\n    // window, reverse the selection.\n    if (frp->fr_parent != NULL && frp->fr_parent->fr_layout == FR_ROW)\n    {\n\tif (frame_fixed_width(target_fr) && !frame_fixed_width(other_fr))\n\t    target_fr = other_fr;\n    }\n    else\n    {\n\tif (frame_fixed_height(target_fr) && !frame_fixed_height(other_fr))\n\t    target_fr = other_fr;\n    }\n\n    return target_fr;\n}\n\n/*\n * Return the tabpage that will be used if the current one is closed.\n */\n    static tabpage_T *\nalt_tabpage(void)\n{\n    tabpage_T\t*tp;\n\n    // Use the next tab page if possible.\n    if (curtab->tp_next != NULL)\n\treturn curtab->tp_next;\n\n    // Find the last but one tab page.\n    for (tp = first_tabpage; tp->tp_next != curtab; tp = tp->tp_next)\n\t;\n    return tp;\n}\n\n/*\n * Find the left-upper window in frame \"frp\".\n */\n    static win_T *\nframe2win(frame_T *frp)\n{\n    while (frp->fr_win == NULL)\n\tfrp = frp->fr_child;\n    return frp->fr_win;\n}\n\n/*\n * Return TRUE if frame \"frp\" contains window \"wp\".\n */\n    static int\nframe_has_win(frame_T *frp, win_T *wp)\n{\n    frame_T\t*p;\n\n    if (frp->fr_layout == FR_LEAF)\n\treturn frp->fr_win == wp;\n\n    FOR_ALL_FRAMES(p, frp->fr_child)\n\tif (frame_has_win(p, wp))\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * Set a new height for a frame.  Recursively sets the height for contained\n * frames and windows.  Caller must take care of positions.\n */\n    static void\nframe_new_height(\n    frame_T\t*topfrp,\n    int\t\theight,\n    int\t\ttopfirst,\t// resize topmost contained frame first\n    int\t\twfh)\t\t// obey 'winfixheight' when there is a choice;\n\t\t\t\t// may cause the height not to be set\n{\n    frame_T\t*frp;\n    int\t\textra_lines;\n    int\t\th;\n\n    if (topfrp->fr_win != NULL)\n    {\n\t// Simple case: just one window.\n\twin_new_height(topfrp->fr_win,\n\t\t\t\t    height - topfrp->fr_win->w_status_height\n\t\t\t\t\t      - WINBAR_HEIGHT(topfrp->fr_win));\n    }\n    else if (topfrp->fr_layout == FR_ROW)\n    {\n\tdo\n\t{\n\t    // All frames in this row get the same new height.\n\t    FOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    {\n\t\tframe_new_height(frp, height, topfirst, wfh);\n\t\tif (frp->fr_height > height)\n\t\t{\n\t\t    // Could not fit the windows, make the whole row higher.\n\t\t    height = frp->fr_height;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\twhile (frp != NULL);\n    }\n    else    // fr_layout == FR_COL\n    {\n\t// Complicated case: Resize a column of frames.  Resize the bottom\n\t// frame first, frames above that when needed.\n\n\tfrp = topfrp->fr_child;\n\tif (wfh)\n\t    // Advance past frames with one window with 'wfh' set.\n\t    while (frame_fixed_height(frp))\n\t    {\n\t\tfrp = frp->fr_next;\n\t\tif (frp == NULL)\n\t\t    return;\t    // no frame without 'wfh', give up\n\t    }\n\tif (!topfirst)\n\t{\n\t    // Find the bottom frame of this column\n\t    while (frp->fr_next != NULL)\n\t\tfrp = frp->fr_next;\n\t    if (wfh)\n\t\t// Advance back for frames with one window with 'wfh' set.\n\t\twhile (frame_fixed_height(frp))\n\t\t    frp = frp->fr_prev;\n\t}\n\n\textra_lines = height - topfrp->fr_height;\n\tif (extra_lines < 0)\n\t{\n\t    // reduce height of contained frames, bottom or top frame first\n\t    while (frp != NULL)\n\t    {\n\t\th = frame_minheight(frp, NULL);\n\t\tif (frp->fr_height + extra_lines < h)\n\t\t{\n\t\t    extra_lines += frp->fr_height - h;\n\t\t    frame_new_height(frp, h, topfirst, wfh);\n\t\t}\n\t\telse\n\t\t{\n\t\t    frame_new_height(frp, frp->fr_height + extra_lines,\n\t\t\t\t\t\t\t       topfirst, wfh);\n\t\t    break;\n\t\t}\n\t\tif (topfirst)\n\t\t{\n\t\t    do\n\t\t\tfrp = frp->fr_next;\n\t\t    while (wfh && frp != NULL && frame_fixed_height(frp));\n\t\t}\n\t\telse\n\t\t{\n\t\t    do\n\t\t\tfrp = frp->fr_prev;\n\t\t    while (wfh && frp != NULL && frame_fixed_height(frp));\n\t\t}\n\t\t// Increase \"height\" if we could not reduce enough frames.\n\t\tif (frp == NULL)\n\t\t    height -= extra_lines;\n\t    }\n\t}\n\telse if (extra_lines > 0)\n\t{\n\t    // increase height of bottom or top frame\n\t    frame_new_height(frp, frp->fr_height + extra_lines, topfirst, wfh);\n\t}\n    }\n    topfrp->fr_height = height;\n}\n\n/*\n * Return TRUE if height of frame \"frp\" should not be changed because of\n * the 'winfixheight' option.\n */\n    static int\nframe_fixed_height(frame_T *frp)\n{\n    // frame with one window: fixed height if 'winfixheight' set.\n    if (frp->fr_win != NULL)\n\treturn frp->fr_win->w_p_wfh;\n\n    if (frp->fr_layout == FR_ROW)\n    {\n\t// The frame is fixed height if one of the frames in the row is fixed\n\t// height.\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    if (frame_fixed_height(frp))\n\t\treturn TRUE;\n\treturn FALSE;\n    }\n\n    // frp->fr_layout == FR_COL: The frame is fixed height if all of the\n    // frames in the row are fixed height.\n    FOR_ALL_FRAMES(frp, frp->fr_child)\n\tif (!frame_fixed_height(frp))\n\t    return FALSE;\n    return TRUE;\n}\n\n/*\n * Return TRUE if width of frame \"frp\" should not be changed because of\n * the 'winfixwidth' option.\n */\n    static int\nframe_fixed_width(frame_T *frp)\n{\n    // frame with one window: fixed width if 'winfixwidth' set.\n    if (frp->fr_win != NULL)\n\treturn frp->fr_win->w_p_wfw;\n\n    if (frp->fr_layout == FR_COL)\n    {\n\t// The frame is fixed width if one of the frames in the row is fixed\n\t// width.\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    if (frame_fixed_width(frp))\n\t\treturn TRUE;\n\treturn FALSE;\n    }\n\n    // frp->fr_layout == FR_ROW: The frame is fixed width if all of the\n    // frames in the row are fixed width.\n    FOR_ALL_FRAMES(frp, frp->fr_child)\n\tif (!frame_fixed_width(frp))\n\t    return FALSE;\n    return TRUE;\n}\n\n/*\n * Add a status line to windows at the bottom of \"frp\".\n * Note: Does not check if there is room!\n */\n    static void\nframe_add_statusline(frame_T *frp)\n{\n    win_T\t*wp;\n\n    if (frp->fr_layout == FR_LEAF)\n    {\n\twp = frp->fr_win;\n\tif (wp->w_status_height == 0)\n\t{\n\t    if (wp->w_height > 0)\t// don't make it negative\n\t\t--wp->w_height;\n\t    wp->w_status_height = STATUS_HEIGHT;\n\t}\n    }\n    else if (frp->fr_layout == FR_ROW)\n    {\n\t// Handle all the frames in the row.\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    frame_add_statusline(frp);\n    }\n    else // frp->fr_layout == FR_COL\n    {\n\t// Only need to handle the last frame in the column.\n\tfor (frp = frp->fr_child; frp->fr_next != NULL; frp = frp->fr_next)\n\t    ;\n\tframe_add_statusline(frp);\n    }\n}\n\n/*\n * Set width of a frame.  Handles recursively going through contained frames.\n * May remove separator line for windows at the right side (for win_close()).\n */\n    static void\nframe_new_width(\n    frame_T\t*topfrp,\n    int\t\twidth,\n    int\t\tleftfirst,\t// resize leftmost contained frame first\n    int\t\twfw)\t\t// obey 'winfixwidth' when there is a choice;\n\t\t\t\t// may cause the width not to be set\n{\n    frame_T\t*frp;\n    int\t\textra_cols;\n    int\t\tw;\n    win_T\t*wp;\n\n    if (topfrp->fr_layout == FR_LEAF)\n    {\n\t// Simple case: just one window.\n\twp = topfrp->fr_win;\n\t// Find out if there are any windows right of this one.\n\tfor (frp = topfrp; frp->fr_parent != NULL; frp = frp->fr_parent)\n\t    if (frp->fr_parent->fr_layout == FR_ROW && frp->fr_next != NULL)\n\t\tbreak;\n\tif (frp->fr_parent == NULL)\n\t    wp->w_vsep_width = 0;\n\twin_new_width(wp, width - wp->w_vsep_width);\n    }\n    else if (topfrp->fr_layout == FR_COL)\n    {\n\tdo\n\t{\n\t    // All frames in this column get the same new width.\n\t    FOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    {\n\t\tframe_new_width(frp, width, leftfirst, wfw);\n\t\tif (frp->fr_width > width)\n\t\t{\n\t\t    // Could not fit the windows, make whole column wider.\n\t\t    width = frp->fr_width;\n\t\t    break;\n\t\t}\n\t    }\n\t} while (frp != NULL);\n    }\n    else    // fr_layout == FR_ROW\n    {\n\t// Complicated case: Resize a row of frames.  Resize the rightmost\n\t// frame first, frames left of it when needed.\n\n\tfrp = topfrp->fr_child;\n\tif (wfw)\n\t    // Advance past frames with one window with 'wfw' set.\n\t    while (frame_fixed_width(frp))\n\t    {\n\t\tfrp = frp->fr_next;\n\t\tif (frp == NULL)\n\t\t    return;\t    // no frame without 'wfw', give up\n\t    }\n\tif (!leftfirst)\n\t{\n\t    // Find the rightmost frame of this row\n\t    while (frp->fr_next != NULL)\n\t\tfrp = frp->fr_next;\n\t    if (wfw)\n\t\t// Advance back for frames with one window with 'wfw' set.\n\t\twhile (frame_fixed_width(frp))\n\t\t    frp = frp->fr_prev;\n\t}\n\n\textra_cols = width - topfrp->fr_width;\n\tif (extra_cols < 0)\n\t{\n\t    // reduce frame width, rightmost frame first\n\t    while (frp != NULL)\n\t    {\n\t\tw = frame_minwidth(frp, NULL);\n\t\tif (frp->fr_width + extra_cols < w)\n\t\t{\n\t\t    extra_cols += frp->fr_width - w;\n\t\t    frame_new_width(frp, w, leftfirst, wfw);\n\t\t}\n\t\telse\n\t\t{\n\t\t    frame_new_width(frp, frp->fr_width + extra_cols,\n\t\t\t\t\t\t\t      leftfirst, wfw);\n\t\t    break;\n\t\t}\n\t\tif (leftfirst)\n\t\t{\n\t\t    do\n\t\t\tfrp = frp->fr_next;\n\t\t    while (wfw && frp != NULL && frame_fixed_width(frp));\n\t\t}\n\t\telse\n\t\t{\n\t\t    do\n\t\t\tfrp = frp->fr_prev;\n\t\t    while (wfw && frp != NULL && frame_fixed_width(frp));\n\t\t}\n\t\t// Increase \"width\" if we could not reduce enough frames.\n\t\tif (frp == NULL)\n\t\t    width -= extra_cols;\n\t    }\n\t}\n\telse if (extra_cols > 0)\n\t{\n\t    // increase width of rightmost frame\n\t    frame_new_width(frp, frp->fr_width + extra_cols, leftfirst, wfw);\n\t}\n    }\n    topfrp->fr_width = width;\n}\n\n/*\n * Add the vertical separator to windows at the right side of \"frp\".\n * Note: Does not check if there is room!\n */\n    static void\nframe_add_vsep(frame_T *frp)\n{\n    win_T\t*wp;\n\n    if (frp->fr_layout == FR_LEAF)\n    {\n\twp = frp->fr_win;\n\tif (wp->w_vsep_width == 0)\n\t{\n\t    if (wp->w_width > 0)\t// don't make it negative\n\t\t--wp->w_width;\n\t    wp->w_vsep_width = 1;\n\t}\n    }\n    else if (frp->fr_layout == FR_COL)\n    {\n\t// Handle all the frames in the column.\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    frame_add_vsep(frp);\n    }\n    else // frp->fr_layout == FR_ROW\n    {\n\t// Only need to handle the last frame in the row.\n\tfrp = frp->fr_child;\n\twhile (frp->fr_next != NULL)\n\t    frp = frp->fr_next;\n\tframe_add_vsep(frp);\n    }\n}\n\n/*\n * Set frame width from the window it contains.\n */\n    static void\nframe_fix_width(win_T *wp)\n{\n    wp->w_frame->fr_width = wp->w_width + wp->w_vsep_width;\n}\n\n/*\n * Set frame height from the window it contains.\n */\n    static void\nframe_fix_height(win_T *wp)\n{\n    wp->w_frame->fr_height = VISIBLE_HEIGHT(wp) + wp->w_status_height;\n}\n\n/*\n * Compute the minimal height for frame \"topfrp\".\n * Uses the 'winminheight' option.\n * When \"next_curwin\" isn't NULL, use p_wh for this window.\n * When \"next_curwin\" is NOWIN, don't use at least one line for the current\n * window.\n */\n    static int\nframe_minheight(frame_T *topfrp, win_T *next_curwin)\n{\n    frame_T\t*frp;\n    int\t\tm;\n    int\t\tn;\n\n    if (topfrp->fr_win != NULL)\n    {\n\tif (topfrp->fr_win == next_curwin)\n\t    m = p_wh + topfrp->fr_win->w_status_height;\n\telse\n\t{\n\t    // window: minimal height of the window plus status line\n\t    m = p_wmh + topfrp->fr_win->w_status_height;\n\t    if (topfrp->fr_win == curwin && next_curwin == NULL)\n\t    {\n\t\t// Current window is minimal one line high and WinBar is\n\t\t// visible.\n\t\tif (p_wmh == 0)\n\t\t    ++m;\n\t\tm += WINBAR_HEIGHT(curwin);\n\t    }\n\t}\n    }\n    else if (topfrp->fr_layout == FR_ROW)\n    {\n\t// get the minimal height from each frame in this row\n\tm = 0;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t{\n\t    n = frame_minheight(frp, next_curwin);\n\t    if (n > m)\n\t\tm = n;\n\t}\n    }\n    else\n    {\n\t// Add up the minimal heights for all frames in this column.\n\tm = 0;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    m += frame_minheight(frp, next_curwin);\n    }\n\n    return m;\n}\n\n/*\n * Compute the minimal width for frame \"topfrp\".\n * When \"next_curwin\" isn't NULL, use p_wiw for this window.\n * When \"next_curwin\" is NOWIN, don't use at least one column for the current\n * window.\n */\n    static int\nframe_minwidth(\n    frame_T\t*topfrp,\n    win_T\t*next_curwin)\t// use p_wh and p_wiw for next_curwin\n{\n    frame_T\t*frp;\n    int\t\tm, n;\n\n    if (topfrp->fr_win != NULL)\n    {\n\tif (topfrp->fr_win == next_curwin)\n\t    m = p_wiw + topfrp->fr_win->w_vsep_width;\n\telse\n\t{\n\t    // window: minimal width of the window plus separator column\n\t    m = p_wmw + topfrp->fr_win->w_vsep_width;\n\t    // Current window is minimal one column wide\n\t    if (p_wmw == 0 && topfrp->fr_win == curwin && next_curwin == NULL)\n\t\t++m;\n\t}\n    }\n    else if (topfrp->fr_layout == FR_COL)\n    {\n\t// get the minimal width from each frame in this column\n\tm = 0;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t{\n\t    n = frame_minwidth(frp, next_curwin);\n\t    if (n > m)\n\t\tm = n;\n\t}\n    }\n    else\n    {\n\t// Add up the minimal widths for all frames in this row.\n\tm = 0;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    m += frame_minwidth(frp, next_curwin);\n    }\n\n    return m;\n}\n\n\n/*\n * Try to close all windows except current one.\n * Buffers in the other windows become hidden if 'hidden' is set, or '!' is\n * used and the buffer was modified.\n *\n * Used by \":bdel\" and \":only\".\n */\n    void\nclose_others(\n    int\t\tmessage,\n    int\t\tforceit)\t    // always hide all other windows\n{\n    win_T\t*wp;\n    win_T\t*nextwp;\n    int\t\tr;\n\n    if (one_window())\n    {\n\tif (message && !autocmd_busy)\n\t    msg(_(m_onlyone));\n\treturn;\n    }\n\n    // Be very careful here: autocommands may change the window layout.\n    for (wp = firstwin; win_valid(wp); wp = nextwp)\n    {\n\tnextwp = wp->w_next;\n\tif (wp != curwin)\t\t// don't close current window\n\t{\n\n\t    // Check if it's allowed to abandon this window\n\t    r = can_abandon(wp->w_buffer, forceit);\n\t    if (!win_valid(wp))\t\t// autocommands messed wp up\n\t    {\n\t\tnextwp = firstwin;\n\t\tcontinue;\n\t    }\n\t    if (!r)\n\t    {\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t\tif (message && (p_confirm\n\t\t\t     || (cmdmod.cmod_flags & CMOD_CONFIRM)) && p_write)\n\t\t{\n\t\t    dialog_changed(wp->w_buffer, FALSE);\n\t\t    if (!win_valid(wp))\t\t// autocommands messed wp up\n\t\t    {\n\t\t\tnextwp = firstwin;\n\t\t\tcontinue;\n\t\t    }\n\t\t}\n\t\tif (bufIsChanged(wp->w_buffer))\n#endif\n\t\t    continue;\n\t    }\n\t    win_close(wp, !buf_hide(wp->w_buffer)\n\t\t\t\t\t       && !bufIsChanged(wp->w_buffer));\n\t}\n    }\n\n    if (message && !ONE_WINDOW)\n\temsg(_(e_other_window_contains_changes));\n}\n\n/*\n * Allocate the first window and put an empty buffer in it.\n * Called from main().\n * Return FAIL when something goes wrong (out of memory).\n */\n    int\nwin_alloc_first(void)\n{\n    if (win_alloc_firstwin(NULL) == FAIL)\n\treturn FAIL;\n\n    first_tabpage = alloc_tabpage();\n    if (first_tabpage == NULL)\n\treturn FAIL;\n    first_tabpage->tp_topframe = topframe;\n    curtab = first_tabpage;\n    curtab->tp_firstwin = firstwin;\n    curtab->tp_lastwin = lastwin;\n    curtab->tp_curwin = curwin;\n\n    return OK;\n}\n\n/*\n * Allocate and init a window that is not a regular window.\n * This can only be done after the first window is fully initialized, thus it\n * can't be in win_alloc_first().\n */\n    win_T *\nwin_alloc_popup_win(void)\n{\n    win_T *wp;\n\n    wp = win_alloc(NULL, TRUE);\n    if (wp != NULL)\n    {\n\t// We need to initialize options with something, using the current\n\t// window makes most sense.\n\twin_init_some(wp, curwin);\n\n\tRESET_BINDING(wp);\n\tnew_frame(wp);\n    }\n    return wp;\n}\n\n/*\n * Initialize window \"wp\" to display buffer \"buf\".\n */\n    void\nwin_init_popup_win(win_T *wp, buf_T *buf)\n{\n    wp->w_buffer = buf;\n    ++buf->b_nwindows;\n    win_init_empty(wp); // set cursor and topline to safe values\n\n    // Make sure w_localdir and globaldir are NULL to avoid a chdir() in\n    // win_enter_ext().\n    VIM_CLEAR(wp->w_localdir);\n}\n\n/*\n * Allocate the first window or the first window in a new tab page.\n * When \"oldwin\" is NULL create an empty buffer for it.\n * When \"oldwin\" is not NULL copy info from it to the new window.\n * Return FAIL when something goes wrong (out of memory).\n */\n    static int\nwin_alloc_firstwin(win_T *oldwin)\n{\n    curwin = win_alloc(NULL, FALSE);\n    if (curwin == NULL)\n\treturn FAIL;\n    if (oldwin == NULL)\n    {\n\t// Very first window, need to create an empty buffer for it and\n\t// initialize from scratch.\n\tcurbuf = buflist_new(NULL, NULL, 1L, BLN_LISTED);\n\tif (curwin == NULL || curbuf == NULL)\n\t    return FAIL;\n\tcurwin->w_buffer = curbuf;\n#ifdef FEAT_SYN_HL\n\tcurwin->w_s = &(curbuf->b_s);\n#endif\n\tcurbuf->b_nwindows = 1;\t// there is one window\n\tcurwin->w_alist = &global_alist;\n\tcurwin_init();\t\t// init current window\n    }\n    else\n    {\n\t// First window in new tab page, initialize it from \"oldwin\".\n\twin_init(curwin, oldwin, 0);\n\n\t// We don't want cursor- and scroll-binding in the first window.\n\tRESET_BINDING(curwin);\n    }\n\n    new_frame(curwin);\n    if (curwin->w_frame == NULL)\n\treturn FAIL;\n    topframe = curwin->w_frame;\n    topframe->fr_width = Columns;\n    topframe->fr_height = Rows - p_ch;\n\n    return OK;\n}\n\n/*\n * Create a frame for window \"wp\".\n */\n    static void\nnew_frame(win_T *wp)\n{\n    frame_T *frp = ALLOC_CLEAR_ONE(frame_T);\n\n    wp->w_frame = frp;\n    if (frp != NULL)\n    {\n\tfrp->fr_layout = FR_LEAF;\n\tfrp->fr_win = wp;\n    }\n}\n\n/*\n * Initialize the window and frame size to the maximum.\n */\n    void\nwin_init_size(void)\n{\n    firstwin->w_height = ROWS_AVAIL;\n    topframe->fr_height = ROWS_AVAIL;\n    firstwin->w_width = Columns;\n    topframe->fr_width = Columns;\n}\n\n/*\n * Allocate a new tabpage_T and init the values.\n * Returns NULL when out of memory.\n */\n    static tabpage_T *\nalloc_tabpage(void)\n{\n    tabpage_T\t*tp;\n# ifdef FEAT_GUI\n    int\t\ti;\n# endif\n\n\n    tp = ALLOC_CLEAR_ONE(tabpage_T);\n    if (tp == NULL)\n\treturn NULL;\n\n# ifdef FEAT_EVAL\n    // init t: variables\n    tp->tp_vars = dict_alloc_id(aid_newtabpage_tvars);\n    if (tp->tp_vars == NULL)\n    {\n\tvim_free(tp);\n\treturn NULL;\n    }\n    init_var_dict(tp->tp_vars, &tp->tp_winvar, VAR_SCOPE);\n# endif\n\n# ifdef FEAT_GUI\n    for (i = 0; i < 3; i++)\n\ttp->tp_prev_which_scrollbars[i] = -1;\n# endif\n# ifdef FEAT_DIFF\n    tp->tp_diff_invalid = TRUE;\n# endif\n    tp->tp_ch_used = p_ch;\n\n    return tp;\n}\n\n    void\nfree_tabpage(tabpage_T *tp)\n{\n    int idx;\n\n# ifdef FEAT_DIFF\n    diff_clear(tp);\n# endif\n# ifdef FEAT_PROP_POPUP\n    while (tp->tp_first_popupwin != NULL)\n\tpopup_close_tabpage(tp, tp->tp_first_popupwin->w_id, TRUE);\n#endif\n    for (idx = 0; idx < SNAP_COUNT; ++idx)\n\tclear_snapshot(tp, idx);\n#ifdef FEAT_EVAL\n    vars_clear(&tp->tp_vars->dv_hashtab);\t// free all t: variables\n    hash_init(&tp->tp_vars->dv_hashtab);\n    unref_var_dict(tp->tp_vars);\n#endif\n\n    if (tp == lastused_tabpage)\n\tlastused_tabpage = NULL;\n\n    vim_free(tp->tp_localdir);\n    vim_free(tp->tp_prevdir);\n\n#ifdef FEAT_PYTHON\n    python_tabpage_free(tp);\n#endif\n\n#ifdef FEAT_PYTHON3\n    python3_tabpage_free(tp);\n#endif\n\n    vim_free(tp);\n}\n\n/*\n * Create a new Tab page with one window.\n * It will edit the current buffer, like after \":split\".\n * When \"after\" is 0 put it just after the current Tab page.\n * Otherwise put it just before tab page \"after\".\n * Return FAIL or OK.\n */\n    int\nwin_new_tabpage(int after)\n{\n    tabpage_T\t*tp = curtab;\n    tabpage_T\t*prev_tp = curtab;\n    tabpage_T\t*newtp;\n    int\t\tn;\n\n#ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n    {\n\temsg(_(e_invalid_in_cmdline_window));\n\treturn FAIL;\n    }\n#endif\n\n    newtp = alloc_tabpage();\n    if (newtp == NULL)\n\treturn FAIL;\n\n    // Remember the current windows in this Tab page.\n    if (leave_tabpage(curbuf, TRUE) == FAIL)\n    {\n\tvim_free(newtp);\n\treturn FAIL;\n    }\n    curtab = newtp;\n\n    newtp->tp_localdir = (tp->tp_localdir == NULL)\n\t\t\t\t    ? NULL : vim_strsave(tp->tp_localdir);\n    // Create a new empty window.\n    if (win_alloc_firstwin(tp->tp_curwin) == OK)\n    {\n\t// Make the new Tab page the new topframe.\n\tif (after == 1)\n\t{\n\t    // New tab page becomes the first one.\n\t    newtp->tp_next = first_tabpage;\n\t    first_tabpage = newtp;\n\t}\n\telse\n\t{\n\t    if (after > 0)\n\t    {\n\t\t// Put new tab page before tab page \"after\".\n\t\tn = 2;\n\t\tfor (tp = first_tabpage; tp->tp_next != NULL\n\t\t\t\t\t       && n < after; tp = tp->tp_next)\n\t\t    ++n;\n\t    }\n\t    newtp->tp_next = tp->tp_next;\n\t    tp->tp_next = newtp;\n\t}\n\tnewtp->tp_firstwin = newtp->tp_lastwin = newtp->tp_curwin = curwin;\n\n\twin_init_size();\n\tfirstwin->w_winrow = tabline_height();\n\twin_comp_scroll(curwin);\n\n\tnewtp->tp_topframe = topframe;\n\tlast_status(FALSE);\n\n\tlastused_tabpage = prev_tp;\n\n#if defined(FEAT_GUI)\n\t// When 'guioptions' includes 'L' or 'R' may have to remove or add\n\t// scrollbars.  Have to update them anyway.\n\tgui_may_update_scrollbars();\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\tentering_window(curwin);\n#endif\n\n\tredraw_all_later(NOT_VALID);\n\tapply_autocmds(EVENT_WINNEW, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABNEW, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);\n\treturn OK;\n    }\n\n    // Failed, get back the previous Tab page\n    enter_tabpage(curtab, curbuf, TRUE, TRUE);\n    return FAIL;\n}\n\n/*\n * Open a new tab page if \":tab cmd\" was used.  It will edit the same buffer,\n * like with \":split\".\n * Returns OK if a new tab page was created, FAIL otherwise.\n */\n    static int\nmay_open_tabpage(void)\n{\n    int\t\tn = (cmdmod.cmod_tab == 0)\n\t\t\t\t       ? postponed_split_tab : cmdmod.cmod_tab;\n\n    if (n != 0)\n    {\n\tcmdmod.cmod_tab = 0;\t    // reset it to avoid doing it twice\n\tpostponed_split_tab = 0;\n\treturn win_new_tabpage(n);\n    }\n    return FAIL;\n}\n\n/*\n * Create up to \"maxcount\" tabpages with empty windows.\n * Returns the number of resulting tab pages.\n */\n    int\nmake_tabpages(int maxcount)\n{\n    int\t\tcount = maxcount;\n    int\t\ttodo;\n\n    // Limit to 'tabpagemax' tabs.\n    if (count > p_tpm)\n\tcount = p_tpm;\n\n    /*\n     * Don't execute autocommands while creating the tab pages.  Must do that\n     * when putting the buffers in the windows.\n     */\n    block_autocmds();\n\n    for (todo = count - 1; todo > 0; --todo)\n\tif (win_new_tabpage(0) == FAIL)\n\t    break;\n\n    unblock_autocmds();\n\n    // return actual number of tab pages\n    return (count - todo);\n}\n\n/*\n * Return TRUE when \"tpc\" points to a valid tab page.\n */\n    int\nvalid_tabpage(tabpage_T *tpc)\n{\n    tabpage_T\t*tp;\n\n    FOR_ALL_TABPAGES(tp)\n\tif (tp == tpc)\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * Return TRUE when \"tpc\" points to a valid tab page and at least one window is\n * valid.\n */\n    int\nvalid_tabpage_win(tabpage_T *tpc)\n{\n    tabpage_T\t*tp;\n    win_T\t*wp;\n\n    FOR_ALL_TABPAGES(tp)\n    {\n\tif (tp == tpc)\n\t{\n\t    FOR_ALL_WINDOWS_IN_TAB(tp, wp)\n\t    {\n\t\tif (win_valid_any_tab(wp))\n\t\t    return TRUE;\n\t    }\n\t    return FALSE;\n\t}\n    }\n    // shouldn't happen\n    return FALSE;\n}\n\n/*\n * Close tabpage \"tab\", assuming it has no windows in it.\n * There must be another tabpage or this will crash.\n */\n    void\nclose_tabpage(tabpage_T *tab)\n{\n    tabpage_T\t*ptp;\n\n    if (tab == first_tabpage)\n    {\n\tfirst_tabpage = tab->tp_next;\n\tptp = first_tabpage;\n    }\n    else\n    {\n\tfor (ptp = first_tabpage; ptp != NULL && ptp->tp_next != tab;\n\t\t\t\t\t\t\t    ptp = ptp->tp_next)\n\t    ;\n\tassert(ptp != NULL);\n\tptp->tp_next = tab->tp_next;\n    }\n\n    goto_tabpage_tp(ptp, FALSE, FALSE);\n    free_tabpage(tab);\n}\n\n/*\n * Find tab page \"n\" (first one is 1).  Returns NULL when not found.\n */\n    tabpage_T *\nfind_tabpage(int n)\n{\n    tabpage_T\t*tp;\n    int\t\ti = 1;\n\n    if (n == 0)\n\treturn curtab;\n\n    for (tp = first_tabpage; tp != NULL && i != n; tp = tp->tp_next)\n\t++i;\n    return tp;\n}\n\n/*\n * Get index of tab page \"tp\".  First one has index 1.\n * When not found returns number of tab pages plus one.\n */\n    int\ntabpage_index(tabpage_T *ftp)\n{\n    int\t\ti = 1;\n    tabpage_T\t*tp;\n\n    for (tp = first_tabpage; tp != NULL && tp != ftp; tp = tp->tp_next)\n\t++i;\n    return i;\n}\n\n/*\n * Prepare for leaving the current tab page.\n * When autocommands change \"curtab\" we don't leave the tab page and return\n * FAIL.\n * Careful: When OK is returned need to get a new tab page very very soon!\n */\n    static int\nleave_tabpage(\n    buf_T\t*new_curbuf UNUSED,    // what is going to be the new curbuf,\n\t\t\t\t       // NULL if unknown\n    int\t\ttrigger_leave_autocmds UNUSED)\n{\n    tabpage_T\t*tp = curtab;\n\n#ifdef FEAT_JOB_CHANNEL\n    leaving_window(curwin);\n#endif\n    reset_VIsual_and_resel();\t// stop Visual mode\n    if (trigger_leave_autocmds)\n    {\n\tif (new_curbuf != curbuf)\n\t{\n\t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n\t    if (curtab != tp)\n\t\treturn FAIL;\n\t}\n\tapply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (curtab != tp)\n\t    return FAIL;\n\tapply_autocmds(EVENT_TABLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (curtab != tp)\n\t    return FAIL;\n    }\n#if defined(FEAT_GUI)\n    // Remove the scrollbars.  They may be added back later.\n    if (gui.in_use)\n\tgui_remove_scrollbars();\n#endif\n    tp->tp_curwin = curwin;\n    tp->tp_prevwin = prevwin;\n    tp->tp_firstwin = firstwin;\n    tp->tp_lastwin = lastwin;\n    tp->tp_old_Rows = Rows;\n    if (tp->tp_old_Columns != -1)\n\ttp->tp_old_Columns = Columns;\n    firstwin = NULL;\n    lastwin = NULL;\n    return OK;\n}\n\n/*\n * Start using tab page \"tp\".\n * Only to be used after leave_tabpage() or freeing the current tab page.\n * Only trigger *Enter autocommands when trigger_enter_autocmds is TRUE.\n * Only trigger *Leave autocommands when trigger_leave_autocmds is TRUE.\n */\n    static void\nenter_tabpage(\n    tabpage_T\t*tp,\n    buf_T\t*old_curbuf UNUSED,\n    int\t\ttrigger_enter_autocmds,\n    int\t\ttrigger_leave_autocmds)\n{\n    int\t\trow;\n    int\t\told_off = tp->tp_firstwin->w_winrow;\n    win_T\t*next_prevwin = tp->tp_prevwin;\n    tabpage_T\t*last_tab = curtab;\n\n    curtab = tp;\n    firstwin = tp->tp_firstwin;\n    lastwin = tp->tp_lastwin;\n    topframe = tp->tp_topframe;\n\n    // We would like doing the TabEnter event first, but we don't have a\n    // valid current window yet, which may break some commands.\n    // This triggers autocommands, thus may make \"tp\" invalid.\n    (void)win_enter_ext(tp->tp_curwin, WEE_CURWIN_INVALID\n\t\t  | (trigger_enter_autocmds ? WEE_TRIGGER_ENTER_AUTOCMDS : 0)\n\t\t  | (trigger_leave_autocmds ? WEE_TRIGGER_LEAVE_AUTOCMDS : 0));\n    prevwin = next_prevwin;\n\n    last_status(FALSE);\t\t// status line may appear or disappear\n    row = win_comp_pos();\t// recompute w_winrow for all windows\n#ifdef FEAT_DIFF\n    diff_need_scrollbind = TRUE;\n#endif\n\n    // The tabpage line may have appeared or disappeared, may need to resize\n    // the frames for that.  When the Vim window was resized need to update\n    // frame sizes too.  Use the stored value of p_ch, so that it can be\n    // different for each tab page.\n    if (p_ch != curtab->tp_ch_used)\n\tclear_cmdline = TRUE;\n    p_ch = curtab->tp_ch_used;\n\n    // When cmdheight is changed in a tab page with '<C-w>-', cmdline_row is\n    // changed but p_ch and tp_ch_used are not changed. Thus we also need to\n    // check cmdline_row.\n    if ((row < cmdline_row) && (cmdline_row <= Rows - p_ch))\n\tclear_cmdline = TRUE;\n\n    if (curtab->tp_old_Rows != Rows || (old_off != firstwin->w_winrow\n#ifdef FEAT_GUI_TABLINE\n\t\t\t    && !gui_use_tabline()\n#endif\n\t\t))\n\tshell_new_rows();\n    if (curtab->tp_old_Columns != Columns)\n    {\n\tif (starting == 0)\n\t{\n\t    shell_new_columns();\t// update window widths\n\t    curtab->tp_old_Columns = Columns;\n\t}\n\telse\n\t    curtab->tp_old_Columns = -1;  // update window widths later\n    }\n\n    lastused_tabpage = last_tab;\n\n#if defined(FEAT_GUI)\n    // When 'guioptions' includes 'L' or 'R' may have to remove or add\n    // scrollbars.  Have to update them anyway.\n    gui_may_update_scrollbars();\n#endif\n\n    // Apply autocommands after updating the display, when 'rows' and\n    // 'columns' have been set correctly.\n    if (trigger_enter_autocmds)\n    {\n\tapply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);\n\tif (old_curbuf != curbuf)\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * Go to tab page \"n\".  For \":tab N\" and \"Ngt\".\n * When \"n\" is 9999 go to the last tab page.\n */\n    void\ngoto_tabpage(int n)\n{\n    tabpage_T\t*tp = NULL;  // shut up compiler\n    tabpage_T\t*ttp;\n    int\t\ti;\n\n    if (text_locked())\n    {\n\t// Not allowed when editing the command line.\n\ttext_locked_msg();\n\treturn;\n    }\n\n    // If there is only one it can't work.\n    if (first_tabpage->tp_next == NULL)\n    {\n\tif (n > 1)\n\t    beep_flush();\n\treturn;\n    }\n\n    if (n == 0)\n    {\n\t// No count, go to next tab page, wrap around end.\n\tif (curtab->tp_next == NULL)\n\t    tp = first_tabpage;\n\telse\n\t    tp = curtab->tp_next;\n    }\n    else if (n < 0)\n    {\n\t// \"gT\": go to previous tab page, wrap around end.  \"N gT\" repeats\n\t// this N times.\n\tttp = curtab;\n\tfor (i = n; i < 0; ++i)\n\t{\n\t    for (tp = first_tabpage; tp->tp_next != ttp && tp->tp_next != NULL;\n\t\t    tp = tp->tp_next)\n\t\t;\n\t    ttp = tp;\n\t}\n    }\n    else if (n == 9999)\n    {\n\t// Go to last tab page.\n\tfor (tp = first_tabpage; tp->tp_next != NULL; tp = tp->tp_next)\n\t    ;\n    }\n    else\n    {\n\t// Go to tab page \"n\".\n\ttp = find_tabpage(n);\n\tif (tp == NULL)\n\t{\n\t    beep_flush();\n\t    return;\n\t}\n    }\n\n    goto_tabpage_tp(tp, TRUE, TRUE);\n\n#ifdef FEAT_GUI_TABLINE\n    if (gui_use_tabline())\n\tgui_mch_set_curtab(tabpage_index(curtab));\n#endif\n}\n\n/*\n * Go to tabpage \"tp\".\n * Only trigger *Enter autocommands when trigger_enter_autocmds is TRUE.\n * Only trigger *Leave autocommands when trigger_leave_autocmds is TRUE.\n * Note: doesn't update the GUI tab.\n */\n    void\ngoto_tabpage_tp(\n    tabpage_T\t*tp,\n    int\t\ttrigger_enter_autocmds,\n    int\t\ttrigger_leave_autocmds)\n{\n    if (trigger_enter_autocmds || trigger_leave_autocmds)\n\tCHECK_CMDWIN;\n\n    // Don't repeat a message in another tab page.\n    set_keep_msg(NULL, 0);\n\n    if (tp != curtab && leave_tabpage(tp->tp_curwin->w_buffer,\n\t\t\t\t\ttrigger_leave_autocmds) == OK)\n    {\n\tif (valid_tabpage(tp))\n\t    enter_tabpage(tp, curbuf, trigger_enter_autocmds,\n\t\t    trigger_leave_autocmds);\n\telse\n\t    enter_tabpage(curtab, curbuf, trigger_enter_autocmds,\n\t\t    trigger_leave_autocmds);\n    }\n}\n\n/*\n * Go to the last accessed tab page, if there is one.\n * Return OK or FAIL\n */\n    int\ngoto_tabpage_lastused(void)\n{\n    if (valid_tabpage(lastused_tabpage))\n    {\n\tgoto_tabpage_tp(lastused_tabpage, TRUE, TRUE);\n\treturn OK;\n    }\n    return FAIL;\n}\n\n/*\n * Enter window \"wp\" in tab page \"tp\".\n * Also updates the GUI tab.\n */\n    void\ngoto_tabpage_win(tabpage_T *tp, win_T *wp)\n{\n    goto_tabpage_tp(tp, TRUE, TRUE);\n    if (curtab == tp && win_valid(wp))\n    {\n\twin_enter(wp, TRUE);\n# ifdef FEAT_GUI_TABLINE\n\tif (gui_use_tabline())\n\t    gui_mch_set_curtab(tabpage_index(curtab));\n# endif\n    }\n}\n\n/*\n * Move the current tab page to after tab page \"nr\".\n */\n    void\ntabpage_move(int nr)\n{\n    int\t\tn = 1;\n    tabpage_T\t*tp, *tp_dst;\n\n    if (first_tabpage->tp_next == NULL)\n\treturn;\n\n    for (tp = first_tabpage; tp->tp_next != NULL && n < nr; tp = tp->tp_next)\n\t++n;\n\n    if (tp == curtab || (nr > 0 && tp->tp_next != NULL\n\t\t\t\t\t\t    && tp->tp_next == curtab))\n\treturn;\n\n    tp_dst = tp;\n\n    // Remove the current tab page from the list of tab pages.\n    if (curtab == first_tabpage)\n\tfirst_tabpage = curtab->tp_next;\n    else\n    {\n\tFOR_ALL_TABPAGES(tp)\n\t    if (tp->tp_next == curtab)\n\t\tbreak;\n\tif (tp == NULL)\t// \"cannot happen\"\n\t    return;\n\ttp->tp_next = curtab->tp_next;\n    }\n\n    // Re-insert it at the specified position.\n    if (nr <= 0)\n    {\n\tcurtab->tp_next = first_tabpage;\n\tfirst_tabpage = curtab;\n    }\n    else\n    {\n\tcurtab->tp_next = tp_dst->tp_next;\n\ttp_dst->tp_next = curtab;\n    }\n\n    // Need to redraw the tabline.  Tab page contents doesn't change.\n    redraw_tabline = TRUE;\n}\n\n\n/*\n * Go to another window.\n * When jumping to another buffer, stop Visual mode.  Do this before\n * changing windows so we can yank the selection into the '*' register.\n * When jumping to another window on the same buffer, adjust its cursor\n * position to keep the same Visual area.\n */\n    void\nwin_goto(win_T *wp)\n{\n#ifdef FEAT_CONCEAL\n    win_T\t*owp = curwin;\n#endif\n\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n    if (popup_is_popup(wp))\n    {\n\temsg(_(e_not_allowed_to_enter_popup_window));\n\treturn;\n    }\n#endif\n    if (text_or_buf_locked())\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n    if (wp->w_buffer != curbuf)\n\treset_VIsual_and_resel();\n    else if (VIsual_active)\n\twp->w_cursor = curwin->w_cursor;\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n    win_enter(wp, TRUE);\n\n#ifdef FEAT_CONCEAL\n    // Conceal cursor line in previous window, unconceal in current window.\n    if (win_valid(owp) && owp->w_p_cole > 0 && !msg_scrolled)\n\tredrawWinline(owp, owp->w_cursor.lnum);\n    if (curwin->w_p_cole > 0 && !msg_scrolled)\n\tneed_cursor_line_redraw = TRUE;\n#endif\n}\n\n#if defined(FEAT_PERL) || defined(PROTO)\n/*\n * Find window number \"winnr\" (counting top to bottom).\n */\n    win_T *\nwin_find_nr(int winnr)\n{\n    win_T\t*wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (--winnr == 0)\n\t    break;\n    return wp;\n}\n#endif\n\n#if ((defined(FEAT_PYTHON) || defined(FEAT_PYTHON3))) || defined(PROTO)\n/*\n * Find the tabpage for window \"win\".\n */\n    tabpage_T *\nwin_find_tabpage(win_T *win)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\t    if (wp == win)\n\t\treturn tp;\n    return NULL;\n}\n#endif\n\n/*\n * Get the above or below neighbor window of the specified window.\n *   up - TRUE for the above neighbor\n *   count - nth neighbor window\n * Returns the specified window if the neighbor is not found.\n */\n    win_T *\nwin_vert_neighbor(tabpage_T *tp, win_T *wp, int up, long count)\n{\n    frame_T\t*fr;\n    frame_T\t*nfr;\n    frame_T\t*foundfr;\n\n#ifdef FEAT_PROP_POPUP\n    if (popup_is_popup(wp))\n\t// popups don't have neighbors.\n\treturn NULL;\n#endif\n    foundfr = wp->w_frame;\n    while (count--)\n    {\n\t/*\n\t * First go upwards in the tree of frames until we find a upwards or\n\t * downwards neighbor.\n\t */\n\tfr = foundfr;\n\tfor (;;)\n\t{\n\t    if (fr == tp->tp_topframe)\n\t\tgoto end;\n\t    if (up)\n\t\tnfr = fr->fr_prev;\n\t    else\n\t\tnfr = fr->fr_next;\n\t    if (fr->fr_parent->fr_layout == FR_COL && nfr != NULL)\n\t\tbreak;\n\t    fr = fr->fr_parent;\n\t}\n\n\t/*\n\t * Now go downwards to find the bottom or top frame in it.\n\t */\n\tfor (;;)\n\t{\n\t    if (nfr->fr_layout == FR_LEAF)\n\t    {\n\t\tfoundfr = nfr;\n\t\tbreak;\n\t    }\n\t    fr = nfr->fr_child;\n\t    if (nfr->fr_layout == FR_ROW)\n\t    {\n\t\t// Find the frame at the cursor row.\n\t\twhile (fr->fr_next != NULL\n\t\t\t&& frame2win(fr)->w_wincol + fr->fr_width\n\t\t\t\t\t <= wp->w_wincol + wp->w_wcol)\n\t\t    fr = fr->fr_next;\n\t    }\n\t    if (nfr->fr_layout == FR_COL && up)\n\t\twhile (fr->fr_next != NULL)\n\t\t    fr = fr->fr_next;\n\t    nfr = fr;\n\t}\n    }\nend:\n    return foundfr != NULL ? foundfr->fr_win : NULL;\n}\n\n/*\n * Move to window above or below \"count\" times.\n */\n    static void\nwin_goto_ver(\n    int\t\tup,\t\t// TRUE to go to win above\n    long\tcount)\n{\n    win_T\t*win;\n\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_TERM_POPUP_WINDOW)\n\treturn;\n#endif\n    win = win_vert_neighbor(curtab, curwin, up, count);\n    if (win != NULL)\n\twin_goto(win);\n}\n\n/*\n * Get the left or right neighbor window of the specified window.\n *   left - TRUE for the left neighbor\n *   count - nth neighbor window\n * Returns the specified window if the neighbor is not found.\n */\n    win_T *\nwin_horz_neighbor(tabpage_T *tp, win_T *wp, int left, long count)\n{\n    frame_T\t*fr;\n    frame_T\t*nfr;\n    frame_T\t*foundfr;\n\n#ifdef FEAT_PROP_POPUP\n    if (popup_is_popup(wp))\n\t// popups don't have neighbors.\n\treturn NULL;\n#endif\n    foundfr = wp->w_frame;\n    while (count--)\n    {\n\t/*\n\t * First go upwards in the tree of frames until we find a left or\n\t * right neighbor.\n\t */\n\tfr = foundfr;\n\tfor (;;)\n\t{\n\t    if (fr == tp->tp_topframe)\n\t\tgoto end;\n\t    if (left)\n\t\tnfr = fr->fr_prev;\n\t    else\n\t\tnfr = fr->fr_next;\n\t    if (fr->fr_parent->fr_layout == FR_ROW && nfr != NULL)\n\t\tbreak;\n\t    fr = fr->fr_parent;\n\t}\n\n\t/*\n\t * Now go downwards to find the leftmost or rightmost frame in it.\n\t */\n\tfor (;;)\n\t{\n\t    if (nfr->fr_layout == FR_LEAF)\n\t    {\n\t\tfoundfr = nfr;\n\t\tbreak;\n\t    }\n\t    fr = nfr->fr_child;\n\t    if (nfr->fr_layout == FR_COL)\n\t    {\n\t\t// Find the frame at the cursor row.\n\t\twhile (fr->fr_next != NULL\n\t\t\t&& frame2win(fr)->w_winrow + fr->fr_height\n\t\t\t\t\t <= wp->w_winrow + wp->w_wrow)\n\t\t    fr = fr->fr_next;\n\t    }\n\t    if (nfr->fr_layout == FR_ROW && left)\n\t\twhile (fr->fr_next != NULL)\n\t\t    fr = fr->fr_next;\n\t    nfr = fr;\n\t}\n    }\nend:\n    return foundfr != NULL ? foundfr->fr_win : NULL;\n}\n\n/*\n * Move to left or right window.\n */\n    static void\nwin_goto_hor(\n    int\t\tleft,\t\t// TRUE to go to left win\n    long\tcount)\n{\n    win_T\t*win;\n\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_TERM_POPUP_WINDOW)\n\treturn;\n#endif\n    win = win_horz_neighbor(curtab, curwin, left, count);\n    if (win != NULL)\n\twin_goto(win);\n}\n\n/*\n * Make window \"wp\" the current window.\n */\n    void\nwin_enter(win_T *wp, int undo_sync)\n{\n    (void)win_enter_ext(wp, (undo_sync ? WEE_UNDO_SYNC : 0)\n\t\t    | WEE_TRIGGER_ENTER_AUTOCMDS | WEE_TRIGGER_LEAVE_AUTOCMDS);\n}\n\n/*\n * Used after making another window the current one: change directory if\n * needed.\n */\n    static void\nfix_current_dir(void)\n{\n    if (curwin->w_localdir != NULL || curtab->tp_localdir != NULL)\n    {\n\tchar_u\t*dirname;\n\n\t// Window or tab has a local directory: Save current directory as\n\t// global directory (unless that was done already) and change to the\n\t// local directory.\n\tif (globaldir == NULL)\n\t{\n\t    char_u\tcwd[MAXPATHL];\n\n\t    if (mch_dirname(cwd, MAXPATHL) == OK)\n\t\tglobaldir = vim_strsave(cwd);\n\t}\n\tif (curwin->w_localdir != NULL)\n\t    dirname = curwin->w_localdir;\n\telse\n\t    dirname = curtab->tp_localdir;\n\n\tif (mch_chdir((char *)dirname) == 0)\n\t{\n\t    last_chdir_reason = NULL;\n\t    shorten_fnames(TRUE);\n\t}\n    }\n    else if (globaldir != NULL)\n    {\n\t// Window doesn't have a local directory and we are not in the global\n\t// directory: Change to the global directory.\n\tvim_ignored = mch_chdir((char *)globaldir);\n\tVIM_CLEAR(globaldir);\n\tlast_chdir_reason = NULL;\n\tshorten_fnames(TRUE);\n    }\n}\n\n/*\n * Make window \"wp\" the current window.\n * Can be called with \"flags\" containing WEE_CURWIN_INVALID, which means that\n * curwin has just been closed and isn't valid.\n * Returns TRUE when dont_parse_messages was decremented.\n */\n    static int\nwin_enter_ext(win_T *wp, int flags)\n{\n    int\t\tother_buffer = FALSE;\n    int\t\tcurwin_invalid = (flags & WEE_CURWIN_INVALID);\n    int\t\tdid_decrement = FALSE;\n\n    if (wp == curwin && !curwin_invalid)\t// nothing to do\n\treturn FALSE;\n\n#ifdef FEAT_JOB_CHANNEL\n    if (!curwin_invalid)\n\tleaving_window(curwin);\n#endif\n\n    if (!curwin_invalid && (flags & WEE_TRIGGER_LEAVE_AUTOCMDS))\n    {\n\t/*\n\t * Be careful: If autocommands delete the window, return now.\n\t */\n\tif (wp->w_buffer != curbuf)\n\t{\n\t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n\t    other_buffer = TRUE;\n\t    if (!win_valid(wp))\n\t\treturn FALSE;\n\t}\n\tapply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (!win_valid(wp))\n\t    return FALSE;\n#ifdef FEAT_EVAL\n\t// autocmds may abort script processing\n\tif (aborting())\n\t    return FALSE;\n#endif\n    }\n\n    // sync undo before leaving the current buffer\n    if ((flags & WEE_UNDO_SYNC) && curbuf != wp->w_buffer)\n\tu_sync(FALSE);\n\n    // Might need to scroll the old window before switching, e.g., when the\n    // cursor was moved.\n    update_topline();\n\n    // may have to copy the buffer options when 'cpo' contains 'S'\n    if (wp->w_buffer != curbuf)\n\tbuf_copy_options(wp->w_buffer, BCO_ENTER | BCO_NOHELP);\n    if (!curwin_invalid)\n    {\n\tprevwin = curwin;\t// remember for CTRL-W p\n\tcurwin->w_redr_status = TRUE;\n    }\n    curwin = wp;\n    curbuf = wp->w_buffer;\n    check_cursor();\n    if (!virtual_active())\n\tcurwin->w_cursor.coladd = 0;\n    changed_line_abv_curs();\t// assume cursor position needs updating\n\n    // Now it is OK to parse messages again, which may be needed in\n    // autocommands.\n#ifdef MESSAGE_QUEUE\n    if (flags & WEE_ALLOW_PARSE_MESSAGES)\n    {\n\t--dont_parse_messages;\n\tdid_decrement = TRUE;\n    }\n#endif\n\n    fix_current_dir();\n\n#ifdef FEAT_JOB_CHANNEL\n    entering_window(curwin);\n#endif\n    // Careful: autocommands may close the window and make \"wp\" invalid\n    if (flags & WEE_TRIGGER_NEW_AUTOCMDS)\n\tapply_autocmds(EVENT_WINNEW, NULL, NULL, FALSE, curbuf);\n    if (flags & WEE_TRIGGER_ENTER_AUTOCMDS)\n    {\n\tapply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);\n\tif (other_buffer)\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n    maketitle();\n    curwin->w_redr_status = TRUE;\n#ifdef FEAT_TERMINAL\n    if (bt_terminal(curwin->w_buffer))\n\t// terminal is likely in another mode\n\tredraw_mode = TRUE;\n#endif\n    redraw_tabline = TRUE;\n    if (restart_edit)\n\tredraw_later(VALID);\t// causes status line redraw\n\n    // set window height to desired minimal value\n    if (curwin->w_height < p_wh && !curwin->w_p_wfh\n#ifdef FEAT_PROP_POPUP\n\t    && !popup_is_popup(curwin)\n#endif\n\t    )\n\twin_setheight((int)p_wh);\n    else if (curwin->w_height == 0)\n\twin_setheight(1);\n\n    // set window width to desired minimal value\n    if (curwin->w_width < p_wiw && !curwin->w_p_wfw)\n\twin_setwidth((int)p_wiw);\n\n    setmouse();\t\t\t// in case jumped to/from help buffer\n\n    // Change directories when the 'acd' option is set.\n    DO_AUTOCHDIR;\n\n    return did_decrement;\n}\n\n/*\n * Jump to the first open window that contains buffer \"buf\", if one exists.\n * Returns a pointer to the window found, otherwise NULL.\n */\n    win_T *\nbuf_jump_open_win(buf_T *buf)\n{\n    win_T\t*wp = NULL;\n\n    if (curwin->w_buffer == buf)\n\twp = curwin;\n    else\n\tFOR_ALL_WINDOWS(wp)\n\t    if (wp->w_buffer == buf)\n\t\tbreak;\n    if (wp != NULL)\n\twin_enter(wp, FALSE);\n    return wp;\n}\n\n/*\n * Jump to the first open window in any tab page that contains buffer \"buf\",\n * if one exists. First search in the windows present in the current tab page.\n * Returns a pointer to the window found, otherwise NULL.\n */\n    win_T *\nbuf_jump_open_tab(buf_T *buf)\n{\n    win_T\t*wp = buf_jump_open_win(buf);\n    tabpage_T\t*tp;\n\n    if (wp != NULL)\n\treturn wp;\n\n    FOR_ALL_TABPAGES(tp)\n\tif (tp != curtab)\n\t{\n\t    FOR_ALL_WINDOWS_IN_TAB(tp, wp)\n\t\tif (wp->w_buffer == buf)\n\t\t    break;\n\t    if (wp != NULL)\n\t    {\n\t\tgoto_tabpage_win(tp, wp);\n\t\tif (curwin != wp)\n\t\t    wp = NULL;\t// something went wrong\n\t\tbreak;\n\t    }\n\t}\n    return wp;\n}\n\nstatic int last_win_id = LOWEST_WIN_ID - 1;\n\n/*\n * Allocate a window structure and link it in the window list when \"hidden\" is\n * FALSE.\n */\n    static win_T *\nwin_alloc(win_T *after UNUSED, int hidden UNUSED)\n{\n    win_T\t*new_wp;\n\n    /*\n     * allocate window structure and linesizes arrays\n     */\n    new_wp = ALLOC_CLEAR_ONE(win_T);\n    if (new_wp == NULL)\n\treturn NULL;\n\n    if (win_alloc_lines(new_wp) == FAIL)\n    {\n\tvim_free(new_wp);\n\treturn NULL;\n    }\n\n    new_wp->w_id = ++last_win_id;\n\n#ifdef FEAT_EVAL\n    // init w: variables\n    new_wp->w_vars = dict_alloc_id(aid_newwin_wvars);\n    if (new_wp->w_vars == NULL)\n    {\n\twin_free_lsize(new_wp);\n\tvim_free(new_wp);\n\treturn NULL;\n    }\n    init_var_dict(new_wp->w_vars, &new_wp->w_winvar, VAR_SCOPE);\n#endif\n\n    // Don't execute autocommands while the window is not properly\n    // initialized yet.  gui_create_scrollbar() may trigger a FocusGained\n    // event.\n    block_autocmds();\n\n    /*\n     * link the window in the window list\n     */\n    if (!hidden)\n\twin_append(after, new_wp);\n    new_wp->w_wincol = 0;\n    new_wp->w_width = Columns;\n\n    // position the display and the cursor at the top of the file.\n    new_wp->w_topline = 1;\n#ifdef FEAT_DIFF\n    new_wp->w_topfill = 0;\n#endif\n    new_wp->w_botline = 2;\n    new_wp->w_cursor.lnum = 1;\n    new_wp->w_scbind_pos = 1;\n\n    // use global option value for global-local options\n    new_wp->w_p_so = -1;\n    new_wp->w_p_siso = -1;\n\n    // We won't calculate w_fraction until resizing the window\n    new_wp->w_fraction = 0;\n    new_wp->w_prev_fraction_row = -1;\n\n#ifdef FEAT_GUI\n    if (gui.in_use)\n    {\n\tgui_create_scrollbar(&new_wp->w_scrollbars[SBAR_LEFT],\n\t\tSBAR_LEFT, new_wp);\n\tgui_create_scrollbar(&new_wp->w_scrollbars[SBAR_RIGHT],\n\t\tSBAR_RIGHT, new_wp);\n    }\n#endif\n#ifdef FEAT_FOLDING\n    foldInitWin(new_wp);\n#endif\n    unblock_autocmds();\n#ifdef FEAT_SEARCH_EXTRA\n    new_wp->w_match_head = NULL;\n    new_wp->w_next_match_id = 4;\n#endif\n    return new_wp;\n}\n\n/*\n * Remove window 'wp' from the window list and free the structure.\n */\n    static void\nwin_free(\n    win_T\t*wp,\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    int\t\ti;\n    buf_T\t*buf;\n    wininfo_T\t*wip;\n\n#ifdef FEAT_FOLDING\n    clearFolding(wp);\n#endif\n\n    // reduce the reference count to the argument list.\n    alist_unlink(wp->w_alist);\n\n    // Don't execute autocommands while the window is halfway being deleted.\n    // gui_mch_destroy_scrollbar() may trigger a FocusGained event.\n    block_autocmds();\n\n#ifdef FEAT_LUA\n    lua_window_free(wp);\n#endif\n\n#ifdef FEAT_MZSCHEME\n    mzscheme_window_free(wp);\n#endif\n\n#ifdef FEAT_PERL\n    perl_win_free(wp);\n#endif\n\n#ifdef FEAT_PYTHON\n    python_window_free(wp);\n#endif\n\n#ifdef FEAT_PYTHON3\n    python3_window_free(wp);\n#endif\n\n#ifdef FEAT_TCL\n    tcl_window_free(wp);\n#endif\n\n#ifdef FEAT_RUBY\n    ruby_window_free(wp);\n#endif\n\n    clear_winopt(&wp->w_onebuf_opt);\n    clear_winopt(&wp->w_allbuf_opt);\n\n    vim_free(wp->w_lcs_chars.multispace);\n    vim_free(wp->w_lcs_chars.leadmultispace);\n\n#ifdef FEAT_EVAL\n    vars_clear(&wp->w_vars->dv_hashtab);\t// free all w: variables\n    hash_init(&wp->w_vars->dv_hashtab);\n    unref_var_dict(wp->w_vars);\n#endif\n\n    {\n\ttabpage_T\t*ttp;\n\n\tif (prevwin == wp)\n\t    prevwin = NULL;\n\tFOR_ALL_TABPAGES(ttp)\n\t    if (ttp->tp_prevwin == wp)\n\t\tttp->tp_prevwin = NULL;\n    }\n    win_free_lsize(wp);\n\n    for (i = 0; i < wp->w_tagstacklen; ++i)\n    {\n\tvim_free(wp->w_tagstack[i].tagname);\n\tvim_free(wp->w_tagstack[i].user_data);\n    }\n    vim_free(wp->w_localdir);\n    vim_free(wp->w_prevdir);\n\n    // Remove the window from the b_wininfo lists, it may happen that the\n    // freed memory is re-used for another window.\n    FOR_ALL_BUFFERS(buf)\n\tFOR_ALL_BUF_WININFO(buf, wip)\n\t    if (wip->wi_win == wp)\n\t    {\n\t\twininfo_T\t*wip2;\n\n\t\t// If there already is an entry with \"wi_win\" set to NULL it\n\t\t// must be removed, it would never be used.\n\t\t// Skip \"wip\" itself, otherwise Coverity complains.\n\t\tfor (wip2 = buf->b_wininfo; wip2 != NULL; wip2 = wip2->wi_next)\n\t\t    if (wip2 != wip && wip2->wi_win == NULL)\n\t\t    {\n\t\t\tif (wip2->wi_next != NULL)\n\t\t\t    wip2->wi_next->wi_prev = wip2->wi_prev;\n\t\t\tif (wip2->wi_prev == NULL)\n\t\t\t    buf->b_wininfo = wip2->wi_next;\n\t\t\telse\n\t\t\t    wip2->wi_prev->wi_next = wip2->wi_next;\n\t\t\tfree_wininfo(wip2);\n\t\t\tbreak;\n\t\t    }\n\n\t\twip->wi_win = NULL;\n\t    }\n\n#ifdef FEAT_SEARCH_EXTRA\n    clear_matches(wp);\n#endif\n\n    free_jumplist(wp);\n\n#ifdef FEAT_QUICKFIX\n    qf_free_all(wp);\n#endif\n\n#ifdef FEAT_GUI\n    if (gui.in_use)\n    {\n\tgui_mch_destroy_scrollbar(&wp->w_scrollbars[SBAR_LEFT]);\n\tgui_mch_destroy_scrollbar(&wp->w_scrollbars[SBAR_RIGHT]);\n    }\n#endif // FEAT_GUI\n\n#ifdef FEAT_MENU\n    remove_winbar(wp);\n#endif\n#ifdef FEAT_PROP_POPUP\n    free_callback(&wp->w_close_cb);\n    free_callback(&wp->w_filter_cb);\n    for (i = 0; i < 4; ++i)\n\tVIM_CLEAR(wp->w_border_highlight[i]);\n    vim_free(wp->w_scrollbar_highlight);\n    vim_free(wp->w_thumb_highlight);\n    vim_free(wp->w_popup_title);\n    list_unref(wp->w_popup_mask);\n    vim_free(wp->w_popup_mask_cells);\n#endif\n\n#ifdef FEAT_SYN_HL\n    vim_free(wp->w_p_cc_cols);\n#endif\n\n    if (win_valid_any_tab(wp))\n\twin_remove(wp, tp);\n    if (autocmd_busy)\n    {\n\twp->w_next = au_pending_free_win;\n\tau_pending_free_win = wp;\n    }\n    else\n\tvim_free(wp);\n\n    unblock_autocmds();\n}\n\n/*\n * Return TRUE if \"wp\" is not in the list of windows: the autocmd window or a\n * popup window.\n */\n    int\nwin_unlisted(win_T *wp)\n{\n    return wp == aucmd_win || WIN_IS_POPUP(wp);\n}\n\n#if defined(FEAT_PROP_POPUP) || defined(PROTO)\n/*\n * Free a popup window.  This does not take the window out of the window list\n * and assumes there is only one toplevel frame, no split.\n */\n    void\nwin_free_popup(win_T *win)\n{\n    if (win->w_buffer != NULL)\n    {\n\tif (bt_popup(win->w_buffer))\n\t    win_close_buffer(win, DOBUF_WIPE_REUSE, FALSE);\n\telse\n\t    close_buffer(win, win->w_buffer, 0, FALSE, FALSE);\n    }\n# if defined(FEAT_TIMERS)\n    if (win->w_popup_timer != NULL)\n\tstop_timer(win->w_popup_timer);\n# endif\n    vim_free(win->w_frame);\n    win_free(win, NULL);\n}\n#endif\n\n/*\n * Append window \"wp\" in the window list after window \"after\".\n */\n    static void\nwin_append(win_T *after, win_T *wp)\n{\n    win_T\t*before;\n\n    if (after == NULL)\t    // after NULL is in front of the first\n\tbefore = firstwin;\n    else\n\tbefore = after->w_next;\n\n    wp->w_next = before;\n    wp->w_prev = after;\n    if (after == NULL)\n\tfirstwin = wp;\n    else\n\tafter->w_next = wp;\n    if (before == NULL)\n\tlastwin = wp;\n    else\n\tbefore->w_prev = wp;\n}\n\n/*\n * Remove a window from the window list.\n */\n    void\nwin_remove(\n    win_T\t*wp,\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    if (wp->w_prev != NULL)\n\twp->w_prev->w_next = wp->w_next;\n    else if (tp == NULL)\n\tfirstwin = curtab->tp_firstwin = wp->w_next;\n    else\n\ttp->tp_firstwin = wp->w_next;\n\n    if (wp->w_next != NULL)\n\twp->w_next->w_prev = wp->w_prev;\n    else if (tp == NULL)\n\tlastwin = curtab->tp_lastwin = wp->w_prev;\n    else\n\ttp->tp_lastwin = wp->w_prev;\n}\n\n/*\n * Append frame \"frp\" in a frame list after frame \"after\".\n */\n    static void\nframe_append(frame_T *after, frame_T *frp)\n{\n    frp->fr_next = after->fr_next;\n    after->fr_next = frp;\n    if (frp->fr_next != NULL)\n\tfrp->fr_next->fr_prev = frp;\n    frp->fr_prev = after;\n}\n\n/*\n * Insert frame \"frp\" in a frame list before frame \"before\".\n */\n    static void\nframe_insert(frame_T *before, frame_T *frp)\n{\n    frp->fr_next = before;\n    frp->fr_prev = before->fr_prev;\n    before->fr_prev = frp;\n    if (frp->fr_prev != NULL)\n\tfrp->fr_prev->fr_next = frp;\n    else\n\tfrp->fr_parent->fr_child = frp;\n}\n\n/*\n * Remove a frame from a frame list.\n */\n    static void\nframe_remove(frame_T *frp)\n{\n    if (frp->fr_prev != NULL)\n\tfrp->fr_prev->fr_next = frp->fr_next;\n    else\n\tfrp->fr_parent->fr_child = frp->fr_next;\n    if (frp->fr_next != NULL)\n\tfrp->fr_next->fr_prev = frp->fr_prev;\n}\n\n/*\n * Allocate w_lines[] for window \"wp\".\n * Return FAIL for failure, OK for success.\n */\n    int\nwin_alloc_lines(win_T *wp)\n{\n    wp->w_lines_valid = 0;\n    wp->w_lines = ALLOC_CLEAR_MULT(wline_T, Rows);\n    if (wp->w_lines == NULL)\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * free lsize arrays for a window\n */\n    void\nwin_free_lsize(win_T *wp)\n{\n    // TODO: why would wp be NULL here?\n    if (wp != NULL)\n\tVIM_CLEAR(wp->w_lines);\n}\n\n/*\n * Called from win_new_shellsize() after Rows changed.\n * This only does the current tab page, others must be done when made active.\n */\n    void\nshell_new_rows(void)\n{\n    int\t\th = (int)ROWS_AVAIL;\n\n    if (firstwin == NULL)\t// not initialized yet\n\treturn;\n    if (h < frame_minheight(topframe, NULL))\n\th = frame_minheight(topframe, NULL);\n\n    // First try setting the heights of windows with 'winfixheight'.  If\n    // that doesn't result in the right height, forget about that option.\n    frame_new_height(topframe, h, FALSE, TRUE);\n    if (!frame_check_height(topframe, h))\n\tframe_new_height(topframe, h, FALSE, FALSE);\n\n    (void)win_comp_pos();\t\t// recompute w_winrow and w_wincol\n    compute_cmdrow();\n    curtab->tp_ch_used = p_ch;\n\n#if 0\n    // Disabled: don't want making the screen smaller make a window larger.\n    if (p_ea)\n\twin_equal(curwin, FALSE, 'v');\n#endif\n}\n\n/*\n * Called from win_new_shellsize() after Columns changed.\n */\n    void\nshell_new_columns(void)\n{\n    if (firstwin == NULL)\t// not initialized yet\n\treturn;\n\n    // First try setting the widths of windows with 'winfixwidth'.  If that\n    // doesn't result in the right width, forget about that option.\n    frame_new_width(topframe, (int)Columns, FALSE, TRUE);\n    if (!frame_check_width(topframe, Columns))\n\tframe_new_width(topframe, (int)Columns, FALSE, FALSE);\n\n    (void)win_comp_pos();\t\t// recompute w_winrow and w_wincol\n#if 0\n    // Disabled: don't want making the screen smaller make a window larger.\n    if (p_ea)\n\twin_equal(curwin, FALSE, 'h');\n#endif\n}\n\n#if defined(FEAT_CMDWIN) || defined(PROTO)\n/*\n * Save the size of all windows in \"gap\".\n */\n    void\nwin_size_save(garray_T *gap)\n\n{\n    win_T\t*wp;\n\n    ga_init2(gap, sizeof(int), 1);\n    if (ga_grow(gap, win_count() * 2 + 1) == OK)\n    {\n\t// first entry is value of 'lines'\n\t((int *)gap->ga_data)[gap->ga_len++] = Rows;\n\n\tFOR_ALL_WINDOWS(wp)\n\t{\n\t    ((int *)gap->ga_data)[gap->ga_len++] =\n\t\t\t\t\t       wp->w_width + wp->w_vsep_width;\n\t    ((int *)gap->ga_data)[gap->ga_len++] = wp->w_height;\n\t}\n    }\n}\n\n/*\n * Restore window sizes, but only if the number of windows is still the same\n * and 'lines' didn't change.\n * Does not free the growarray.\n */\n    void\nwin_size_restore(garray_T *gap)\n{\n    win_T\t*wp;\n    int\t\ti, j;\n\n    if (win_count() * 2 + 1 == gap->ga_len\n\t    && ((int *)gap->ga_data)[0] == Rows)\n    {\n\t// The order matters, because frames contain other frames, but it's\n\t// difficult to get right. The easy way out is to do it twice.\n\tfor (j = 0; j < 2; ++j)\n\t{\n\t    i = 1;\n\t    FOR_ALL_WINDOWS(wp)\n\t    {\n\t\tframe_setwidth(wp->w_frame, ((int *)gap->ga_data)[i++]);\n\t\twin_setheight_win(((int *)gap->ga_data)[i++], wp);\n\t    }\n\t}\n\t// recompute the window positions\n\t(void)win_comp_pos();\n    }\n}\n#endif // FEAT_CMDWIN\n\n/*\n * Update the position for all windows, using the width and height of the\n * frames.\n * Returns the row just after the last window.\n */\n    int\nwin_comp_pos(void)\n{\n    int\t\trow = tabline_height();\n    int\t\tcol = 0;\n\n    frame_comp_pos(topframe, &row, &col);\n    return row;\n}\n\n/*\n * Update the position of the windows in frame \"topfrp\", using the width and\n * height of the frames.\n * \"*row\" and \"*col\" are the top-left position of the frame.  They are updated\n * to the bottom-right position plus one.\n */\n    static void\nframe_comp_pos(frame_T *topfrp, int *row, int *col)\n{\n    win_T\t*wp;\n    frame_T\t*frp;\n    int\t\tstartcol;\n    int\t\tstartrow;\n    int\t\th;\n\n    wp = topfrp->fr_win;\n    if (wp != NULL)\n    {\n\tif (wp->w_winrow != *row || wp->w_wincol != *col)\n\t{\n\t    // position changed, redraw\n\t    wp->w_winrow = *row;\n\t    wp->w_wincol = *col;\n\t    redraw_win_later(wp, NOT_VALID);\n\t    wp->w_redr_status = TRUE;\n\t}\n\t// WinBar will not show if the window height is zero\n\th = VISIBLE_HEIGHT(wp) + wp->w_status_height;\n\t*row += h > topfrp->fr_height ? topfrp->fr_height : h;\n\t*col += wp->w_width + wp->w_vsep_width;\n    }\n    else\n    {\n\tstartrow = *row;\n\tstartcol = *col;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t{\n\t    if (topfrp->fr_layout == FR_ROW)\n\t\t*row = startrow;\t// all frames are at the same row\n\t    else\n\t\t*col = startcol;\t// all frames are at the same col\n\t    frame_comp_pos(frp, row, col);\n\t}\n    }\n}\n\n/*\n * Make the current window show at least one line and one column.\n */\n    void\nwin_ensure_size()\n{\n    if (curwin->w_height == 0)\n\twin_setheight(1);\n    if (curwin->w_width == 0)\n\twin_setwidth(1);\n}\n\n/*\n * Set current window height and take care of repositioning other windows to\n * fit around it.\n */\n    void\nwin_setheight(int height)\n{\n    win_setheight_win(height, curwin);\n}\n\n/*\n * Set the window height of window \"win\" and take care of repositioning other\n * windows to fit around it.\n */\n    void\nwin_setheight_win(int height, win_T *win)\n{\n    int\t\trow;\n\n    if (win == curwin)\n    {\n\t// Always keep current window at least one line high, even when\n\t// 'winminheight' is zero.\n\tif (height < p_wmh)\n\t    height = p_wmh;\n\tif (height == 0)\n\t    height = 1;\n\theight += WINBAR_HEIGHT(curwin);\n    }\n\n    frame_setheight(win->w_frame, height + win->w_status_height);\n\n    // recompute the window positions\n    row = win_comp_pos();\n\n    /*\n     * If there is extra space created between the last window and the command\n     * line, clear it.\n     */\n    if (full_screen && msg_scrolled == 0 && row < cmdline_row)\n\tscreen_fill(row, cmdline_row, 0, (int)Columns, ' ', ' ', 0);\n    cmdline_row = row;\n    msg_row = row;\n    msg_col = 0;\n\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * Set the height of a frame to \"height\" and take care that all frames and\n * windows inside it are resized.  Also resize frames on the left and right if\n * the are in the same FR_ROW frame.\n *\n * Strategy:\n * If the frame is part of a FR_COL frame, try fitting the frame in that\n * frame.  If that doesn't work (the FR_COL frame is too small), recursively\n * go to containing frames to resize them and make room.\n * If the frame is part of a FR_ROW frame, all frames must be resized as well.\n * Check for the minimal height of the FR_ROW frame.\n * At the top level we can also use change the command line height.\n */\n    static void\nframe_setheight(frame_T *curfrp, int height)\n{\n    int\t\troom;\t\t// total number of lines available\n    int\t\ttake;\t\t// number of lines taken from other windows\n    int\t\troom_cmdline;\t// lines available from cmdline\n    int\t\trun;\n    frame_T\t*frp;\n    int\t\th;\n    int\t\troom_reserved;\n\n    // If the height already is the desired value, nothing to do.\n    if (curfrp->fr_height == height)\n\treturn;\n\n    if (curfrp->fr_parent == NULL)\n    {\n\t// topframe: can only change the command line\n\tif (height > ROWS_AVAIL)\n\t    height = ROWS_AVAIL;\n\tif (height > 0)\n\t    frame_new_height(curfrp, height, FALSE, FALSE);\n    }\n    else if (curfrp->fr_parent->fr_layout == FR_ROW)\n    {\n\t// Row of frames: Also need to resize frames left and right of this\n\t// one.  First check for the minimal height of these.\n\th = frame_minheight(curfrp->fr_parent, NULL);\n\tif (height < h)\n\t    height = h;\n\tframe_setheight(curfrp->fr_parent, height);\n    }\n    else\n    {\n\t/*\n\t * Column of frames: try to change only frames in this column.\n\t */\n\t/*\n\t * Do this twice:\n\t * 1: compute room available, if it's not enough try resizing the\n\t *    containing frame.\n\t * 2: compute the room available and adjust the height to it.\n\t * Try not to reduce the height of a window with 'winfixheight' set.\n\t */\n\tfor (run = 1; run <= 2; ++run)\n\t{\n\t    room = 0;\n\t    room_reserved = 0;\n\t    FOR_ALL_FRAMES(frp, curfrp->fr_parent->fr_child)\n\t    {\n\t\tif (frp != curfrp\n\t\t\t&& frp->fr_win != NULL\n\t\t\t&& frp->fr_win->w_p_wfh)\n\t\t    room_reserved += frp->fr_height;\n\t\troom += frp->fr_height;\n\t\tif (frp != curfrp)\n\t\t    room -= frame_minheight(frp, NULL);\n\t    }\n\t    if (curfrp->fr_width != Columns)\n\t\troom_cmdline = 0;\n\t    else\n\t    {\n\t\troom_cmdline = Rows - p_ch - (lastwin->w_winrow\n\t\t\t\t\t\t+ VISIBLE_HEIGHT(lastwin)\n\t\t\t\t\t\t+ lastwin->w_status_height);\n\t\tif (room_cmdline < 0)\n\t\t    room_cmdline = 0;\n\t    }\n\n\t    if (height <= room + room_cmdline)\n\t\tbreak;\n\t    if (run == 2 || curfrp->fr_width == Columns)\n\t    {\n\t\theight = room + room_cmdline;\n\t\tbreak;\n\t    }\n\t    frame_setheight(curfrp->fr_parent, height\n\t\t+ frame_minheight(curfrp->fr_parent, NOWIN) - (int)p_wmh - 1);\n\t}\n\n\t/*\n\t * Compute the number of lines we will take from others frames (can be\n\t * negative!).\n\t */\n\ttake = height - curfrp->fr_height;\n\n\t// If there is not enough room, also reduce the height of a window\n\t// with 'winfixheight' set.\n\tif (height > room + room_cmdline - room_reserved)\n\t    room_reserved = room + room_cmdline - height;\n\t// If there is only a 'winfixheight' window and making the\n\t// window smaller, need to make the other window taller.\n\tif (take < 0 && room - curfrp->fr_height < room_reserved)\n\t    room_reserved = 0;\n\n\tif (take > 0 && room_cmdline > 0)\n\t{\n\t    // use lines from cmdline first\n\t    if (take < room_cmdline)\n\t\troom_cmdline = take;\n\t    take -= room_cmdline;\n\t    topframe->fr_height += room_cmdline;\n\t}\n\n\t/*\n\t * set the current frame to the new height\n\t */\n\tframe_new_height(curfrp, height, FALSE, FALSE);\n\n\t/*\n\t * First take lines from the frames after the current frame.  If\n\t * that is not enough, takes lines from frames above the current\n\t * frame.\n\t */\n\tfor (run = 0; run < 2; ++run)\n\t{\n\t    if (run == 0)\n\t\tfrp = curfrp->fr_next;\t// 1st run: start with next window\n\t    else\n\t\tfrp = curfrp->fr_prev;\t// 2nd run: start with prev window\n\t    while (frp != NULL && take != 0)\n\t    {\n\t\th = frame_minheight(frp, NULL);\n\t\tif (room_reserved > 0\n\t\t\t&& frp->fr_win != NULL\n\t\t\t&& frp->fr_win->w_p_wfh)\n\t\t{\n\t\t    if (room_reserved >= frp->fr_height)\n\t\t\troom_reserved -= frp->fr_height;\n\t\t    else\n\t\t    {\n\t\t\tif (frp->fr_height - room_reserved > take)\n\t\t\t    room_reserved = frp->fr_height - take;\n\t\t\ttake -= frp->fr_height - room_reserved;\n\t\t\tframe_new_height(frp, room_reserved, FALSE, FALSE);\n\t\t\troom_reserved = 0;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (frp->fr_height - take < h)\n\t\t    {\n\t\t\ttake -= frp->fr_height - h;\n\t\t\tframe_new_height(frp, h, FALSE, FALSE);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tframe_new_height(frp, frp->fr_height - take,\n\t\t\t\t\t\t\t\tFALSE, FALSE);\n\t\t\ttake = 0;\n\t\t    }\n\t\t}\n\t\tif (run == 0)\n\t\t    frp = frp->fr_next;\n\t\telse\n\t\t    frp = frp->fr_prev;\n\t    }\n\t}\n    }\n}\n\n/*\n * Set current window width and take care of repositioning other windows to\n * fit around it.\n */\n    void\nwin_setwidth(int width)\n{\n    win_setwidth_win(width, curwin);\n}\n\n    void\nwin_setwidth_win(int width, win_T *wp)\n{\n    // Always keep current window at least one column wide, even when\n    // 'winminwidth' is zero.\n    if (wp == curwin)\n    {\n\tif (width < p_wmw)\n\t    width = p_wmw;\n\tif (width == 0)\n\t    width = 1;\n    }\n    else if (width < 0)\n\twidth = 0;\n\n    frame_setwidth(wp->w_frame, width + wp->w_vsep_width);\n\n    // recompute the window positions\n    (void)win_comp_pos();\n\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * Set the width of a frame to \"width\" and take care that all frames and\n * windows inside it are resized.  Also resize frames above and below if the\n * are in the same FR_ROW frame.\n *\n * Strategy is similar to frame_setheight().\n */\n    static void\nframe_setwidth(frame_T *curfrp, int width)\n{\n    int\t\troom;\t\t// total number of lines available\n    int\t\ttake;\t\t// number of lines taken from other windows\n    int\t\trun;\n    frame_T\t*frp;\n    int\t\tw;\n    int\t\troom_reserved;\n\n    // If the width already is the desired value, nothing to do.\n    if (curfrp->fr_width == width)\n\treturn;\n\n    if (curfrp->fr_parent == NULL)\n\t// topframe: can't change width\n\treturn;\n\n    if (curfrp->fr_parent->fr_layout == FR_COL)\n    {\n\t// Column of frames: Also need to resize frames above and below of\n\t// this one.  First check for the minimal width of these.\n\tw = frame_minwidth(curfrp->fr_parent, NULL);\n\tif (width < w)\n\t    width = w;\n\tframe_setwidth(curfrp->fr_parent, width);\n    }\n    else\n    {\n\t/*\n\t * Row of frames: try to change only frames in this row.\n\t *\n\t * Do this twice:\n\t * 1: compute room available, if it's not enough try resizing the\n\t *    containing frame.\n\t * 2: compute the room available and adjust the width to it.\n\t */\n\tfor (run = 1; run <= 2; ++run)\n\t{\n\t    room = 0;\n\t    room_reserved = 0;\n\t    FOR_ALL_FRAMES(frp, curfrp->fr_parent->fr_child)\n\t    {\n\t\tif (frp != curfrp\n\t\t\t&& frp->fr_win != NULL\n\t\t\t&& frp->fr_win->w_p_wfw)\n\t\t    room_reserved += frp->fr_width;\n\t\troom += frp->fr_width;\n\t\tif (frp != curfrp)\n\t\t    room -= frame_minwidth(frp, NULL);\n\t    }\n\n\t    if (width <= room)\n\t\tbreak;\n\t    if (run == 2 || curfrp->fr_height >= ROWS_AVAIL)\n\t    {\n\t\twidth = room;\n\t\tbreak;\n\t    }\n\t    frame_setwidth(curfrp->fr_parent, width\n\t\t + frame_minwidth(curfrp->fr_parent, NOWIN) - (int)p_wmw - 1);\n\t}\n\n\t/*\n\t * Compute the number of lines we will take from others frames (can be\n\t * negative!).\n\t */\n\ttake = width - curfrp->fr_width;\n\n\t// If there is not enough room, also reduce the width of a window\n\t// with 'winfixwidth' set.\n\tif (width > room - room_reserved)\n\t    room_reserved = room - width;\n\t// If there is only a 'winfixwidth' window and making the\n\t// window smaller, need to make the other window narrower.\n\tif (take < 0 && room - curfrp->fr_width < room_reserved)\n\t    room_reserved = 0;\n\n\t/*\n\t * set the current frame to the new width\n\t */\n\tframe_new_width(curfrp, width, FALSE, FALSE);\n\n\t/*\n\t * First take lines from the frames right of the current frame.  If\n\t * that is not enough, takes lines from frames left of the current\n\t * frame.\n\t */\n\tfor (run = 0; run < 2; ++run)\n\t{\n\t    if (run == 0)\n\t\tfrp = curfrp->fr_next;\t// 1st run: start with next window\n\t    else\n\t\tfrp = curfrp->fr_prev;\t// 2nd run: start with prev window\n\t    while (frp != NULL && take != 0)\n\t    {\n\t\tw = frame_minwidth(frp, NULL);\n\t\tif (room_reserved > 0\n\t\t\t&& frp->fr_win != NULL\n\t\t\t&& frp->fr_win->w_p_wfw)\n\t\t{\n\t\t    if (room_reserved >= frp->fr_width)\n\t\t\troom_reserved -= frp->fr_width;\n\t\t    else\n\t\t    {\n\t\t\tif (frp->fr_width - room_reserved > take)\n\t\t\t    room_reserved = frp->fr_width - take;\n\t\t\ttake -= frp->fr_width - room_reserved;\n\t\t\tframe_new_width(frp, room_reserved, FALSE, FALSE);\n\t\t\troom_reserved = 0;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (frp->fr_width - take < w)\n\t\t    {\n\t\t\ttake -= frp->fr_width - w;\n\t\t\tframe_new_width(frp, w, FALSE, FALSE);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tframe_new_width(frp, frp->fr_width - take,\n\t\t\t\t\t\t\t\tFALSE, FALSE);\n\t\t\ttake = 0;\n\t\t    }\n\t\t}\n\t\tif (run == 0)\n\t\t    frp = frp->fr_next;\n\t\telse\n\t\t    frp = frp->fr_prev;\n\t    }\n\t}\n    }\n}\n\n/*\n * Check 'winminheight' for a valid value and reduce it if needed.\n */\n    void\nwin_setminheight(void)\n{\n    int\t\troom;\n    int\t\tneeded;\n    int\t\tfirst = TRUE;\n\n    // loop until there is a 'winminheight' that is possible\n    while (p_wmh > 0)\n    {\n\troom = Rows - p_ch;\n\tneeded = min_rows() - 1;  // 1 was added for the cmdline\n\tif (room >= needed)\n\t    break;\n\t--p_wmh;\n\tif (first)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    first = FALSE;\n\t}\n    }\n}\n\n/*\n * Check 'winminwidth' for a valid value and reduce it if needed.\n */\n    void\nwin_setminwidth(void)\n{\n    int\t\troom;\n    int\t\tneeded;\n    int\t\tfirst = TRUE;\n\n    // loop until there is a 'winminheight' that is possible\n    while (p_wmw > 0)\n    {\n\troom = Columns;\n\tneeded = frame_minwidth(topframe, NULL);\n\tif (room >= needed)\n\t    break;\n\t--p_wmw;\n\tif (first)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    first = FALSE;\n\t}\n    }\n}\n\n/*\n * Status line of dragwin is dragged \"offset\" lines down (negative is up).\n */\n    void\nwin_drag_status_line(win_T *dragwin, int offset)\n{\n    frame_T\t*curfr;\n    frame_T\t*fr;\n    int\t\troom;\n    int\t\trow;\n    int\t\tup;\t// if TRUE, drag status line up, otherwise down\n    int\t\tn;\n\n    fr = dragwin->w_frame;\n    curfr = fr;\n    if (fr != topframe)\t\t// more than one window\n    {\n\tfr = fr->fr_parent;\n\t// When the parent frame is not a column of frames, its parent should\n\t// be.\n\tif (fr->fr_layout != FR_COL)\n\t{\n\t    curfr = fr;\n\t    if (fr != topframe)\t// only a row of windows, may drag statusline\n\t\tfr = fr->fr_parent;\n\t}\n    }\n\n    // If this is the last frame in a column, may want to resize the parent\n    // frame instead (go two up to skip a row of frames).\n    while (curfr != topframe && curfr->fr_next == NULL)\n    {\n\tif (fr != topframe)\n\t    fr = fr->fr_parent;\n\tcurfr = fr;\n\tif (fr != topframe)\n\t    fr = fr->fr_parent;\n    }\n\n    if (offset < 0) // drag up\n    {\n\tup = TRUE;\n\toffset = -offset;\n\t// sum up the room of the current frame and above it\n\tif (fr == curfr)\n\t{\n\t    // only one window\n\t    room = fr->fr_height - frame_minheight(fr, NULL);\n\t}\n\telse\n\t{\n\t    room = 0;\n\t    for (fr = fr->fr_child; ; fr = fr->fr_next)\n\t    {\n\t\troom += fr->fr_height - frame_minheight(fr, NULL);\n\t\tif (fr == curfr)\n\t\t    break;\n\t    }\n\t}\n\tfr = curfr->fr_next;\t\t// put fr at frame that grows\n    }\n    else    // drag down\n    {\n\tup = FALSE;\n\t/*\n\t * Only dragging the last status line can reduce p_ch.\n\t */\n\troom = Rows - cmdline_row;\n\tif (curfr->fr_next == NULL)\n\t    room -= 1;\n\telse\n\t    room -= p_ch;\n\tif (room < 0)\n\t    room = 0;\n\t// sum up the room of frames below of the current one\n\tFOR_ALL_FRAMES(fr, curfr->fr_next)\n\t    room += fr->fr_height - frame_minheight(fr, NULL);\n\tfr = curfr;\t\t\t// put fr at window that grows\n    }\n\n    if (room < offset)\t\t// Not enough room\n\toffset = room;\t\t// Move as far as we can\n    if (offset <= 0)\n\treturn;\n\n    /*\n     * Grow frame fr by \"offset\" lines.\n     * Doesn't happen when dragging the last status line up.\n     */\n    if (fr != NULL)\n\tframe_new_height(fr, fr->fr_height + offset, up, FALSE);\n\n    if (up)\n\tfr = curfr;\t\t// current frame gets smaller\n    else\n\tfr = curfr->fr_next;\t// next frame gets smaller\n\n    /*\n     * Now make the other frames smaller.\n     */\n    while (fr != NULL && offset > 0)\n    {\n\tn = frame_minheight(fr, NULL);\n\tif (fr->fr_height - offset <= n)\n\t{\n\t    offset -= fr->fr_height - n;\n\t    frame_new_height(fr, n, !up, FALSE);\n\t}\n\telse\n\t{\n\t    frame_new_height(fr, fr->fr_height - offset, !up, FALSE);\n\t    break;\n\t}\n\tif (up)\n\t    fr = fr->fr_prev;\n\telse\n\t    fr = fr->fr_next;\n    }\n    row = win_comp_pos();\n    screen_fill(row, cmdline_row, 0, (int)Columns, ' ', ' ', 0);\n    cmdline_row = row;\n    p_ch = Rows - cmdline_row;\n    if (p_ch < 1)\n\tp_ch = 1;\n    curtab->tp_ch_used = p_ch;\n    redraw_all_later(SOME_VALID);\n    showmode();\n}\n\n/*\n * Separator line of dragwin is dragged \"offset\" lines right (negative is left).\n */\n    void\nwin_drag_vsep_line(win_T *dragwin, int offset)\n{\n    frame_T\t*curfr;\n    frame_T\t*fr;\n    int\t\troom;\n    int\t\tleft;\t// if TRUE, drag separator line left, otherwise right\n    int\t\tn;\n\n    fr = dragwin->w_frame;\n    if (fr == topframe)\t\t// only one window (cannot happen?)\n\treturn;\n    curfr = fr;\n    fr = fr->fr_parent;\n    // When the parent frame is not a row of frames, its parent should be.\n    if (fr->fr_layout != FR_ROW)\n    {\n\tif (fr == topframe)\t// only a column of windows (cannot happen?)\n\t    return;\n\tcurfr = fr;\n\tfr = fr->fr_parent;\n    }\n\n    // If this is the last frame in a row, may want to resize a parent\n    // frame instead.\n    while (curfr->fr_next == NULL)\n    {\n\tif (fr == topframe)\n\t    break;\n\tcurfr = fr;\n\tfr = fr->fr_parent;\n\tif (fr != topframe)\n\t{\n\t    curfr = fr;\n\t    fr = fr->fr_parent;\n\t}\n    }\n\n    if (offset < 0) // drag left\n    {\n\tleft = TRUE;\n\toffset = -offset;\n\t// sum up the room of the current frame and left of it\n\troom = 0;\n\tfor (fr = fr->fr_child; ; fr = fr->fr_next)\n\t{\n\t    room += fr->fr_width - frame_minwidth(fr, NULL);\n\t    if (fr == curfr)\n\t\tbreak;\n\t}\n\tfr = curfr->fr_next;\t\t// put fr at frame that grows\n    }\n    else    // drag right\n    {\n\tleft = FALSE;\n\t// sum up the room of frames right of the current one\n\troom = 0;\n\tFOR_ALL_FRAMES(fr, curfr->fr_next)\n\t    room += fr->fr_width - frame_minwidth(fr, NULL);\n\tfr = curfr;\t\t\t// put fr at window that grows\n    }\n\n    if (room < offset)\t\t// Not enough room\n\toffset = room;\t\t// Move as far as we can\n    if (offset <= 0)\t\t// No room at all, quit.\n\treturn;\n    if (fr == NULL)\n\t// This can happen when calling win_move_separator() on the rightmost\n\t// window.  Just don't do anything.\n\treturn;\t\t\t\n\n    // grow frame fr by offset lines\n    frame_new_width(fr, fr->fr_width + offset, left, FALSE);\n\n    // shrink other frames: current and at the left or at the right\n    if (left)\n\tfr = curfr;\t\t// current frame gets smaller\n    else\n\tfr = curfr->fr_next;\t// next frame gets smaller\n\n    while (fr != NULL && offset > 0)\n    {\n\tn = frame_minwidth(fr, NULL);\n\tif (fr->fr_width - offset <= n)\n\t{\n\t    offset -= fr->fr_width - n;\n\t    frame_new_width(fr, n, !left, FALSE);\n\t}\n\telse\n\t{\n\t    frame_new_width(fr, fr->fr_width - offset, !left, FALSE);\n\t    break;\n\t}\n\tif (left)\n\t    fr = fr->fr_prev;\n\telse\n\t    fr = fr->fr_next;\n    }\n    (void)win_comp_pos();\n    redraw_all_later(NOT_VALID);\n}\n\n#define FRACTION_MULT\t16384L\n\n/*\n * Set wp->w_fraction for the current w_wrow and w_height.\n * Has no effect when the window is less than two lines.\n */\n    void\nset_fraction(win_T *wp)\n{\n    if (wp->w_height > 1)\n\t// When cursor is in the first line the percentage is computed as if\n\t// it's halfway that line.  Thus with two lines it is 25%, with three\n\t// lines 17%, etc.  Similarly for the last line: 75%, 83%, etc.\n\twp->w_fraction = ((long)wp->w_wrow * FRACTION_MULT\n\t\t\t\t     + FRACTION_MULT / 2) / (long)wp->w_height;\n}\n\n/*\n * Set the height of a window.\n * \"height\" excludes any window toolbar.\n * This takes care of the things inside the window, not what happens to the\n * window position, the frame or to other windows.\n */\n    void\nwin_new_height(win_T *wp, int height)\n{\n    int\t\tprev_height = wp->w_height;\n\n    // Don't want a negative height.  Happens when splitting a tiny window.\n    // Will equalize heights soon to fix it.\n    if (height < 0)\n\theight = 0;\n    if (wp->w_height == height)\n\treturn;\t    // nothing to do\n\n    if (wp->w_height > 0)\n    {\n\tif (wp == curwin)\n\t    // w_wrow needs to be valid. When setting 'laststatus' this may\n\t    // call win_new_height() recursively.\n\t    validate_cursor();\n\tif (wp->w_height != prev_height)\n\t    return;  // Recursive call already changed the size, bail out here\n\t\t     //\tto avoid the following to mess things up.\n\tif (wp->w_wrow != wp->w_prev_fraction_row)\n\t    set_fraction(wp);\n    }\n\n    wp->w_height = height;\n    wp->w_skipcol = 0;\n\n    // There is no point in adjusting the scroll position when exiting.  Some\n    // values might be invalid.\n    if (!exiting)\n\tscroll_to_fraction(wp, prev_height);\n}\n\n    void\nscroll_to_fraction(win_T *wp, int prev_height)\n{\n    linenr_T\tlnum;\n    int\t\tsline, line_size;\n    int\t\theight = wp->w_height;\n\n    // Don't change w_topline in any of these cases:\n    // - window height is 0\n    // - 'scrollbind' is set and this isn't the current window\n    // - window height is sufficient to display the whole buffer and first line\n    //   is visible.\n    if (height > 0\n\t   && (!wp->w_p_scb || wp == curwin)\n\t   && (height < wp->w_buffer->b_ml.ml_line_count || wp->w_topline > 1))\n    {\n\t/*\n\t * Find a value for w_topline that shows the cursor at the same\n\t * relative position in the window as before (more or less).\n\t */\n\tlnum = wp->w_cursor.lnum;\n\tif (lnum < 1)\t\t// can happen when starting up\n\t    lnum = 1;\n\twp->w_wrow = ((long)wp->w_fraction * (long)height - 1L)\n\t\t\t\t\t\t\t       / FRACTION_MULT;\n\tline_size = plines_win_col(wp, lnum, (long)(wp->w_cursor.col)) - 1;\n\tsline = wp->w_wrow - line_size;\n\n\tif (sline >= 0)\n\t{\n\t    // Make sure the whole cursor line is visible, if possible.\n\t    int rows = plines_win(wp, lnum, FALSE);\n\n\t    if (sline > wp->w_height - rows)\n\t    {\n\t\tsline = wp->w_height - rows;\n\t\twp->w_wrow -= rows - line_size;\n\t    }\n\t}\n\n\tif (sline < 0)\n\t{\n\t    /*\n\t     * Cursor line would go off top of screen if w_wrow was this high.\n\t     * Make cursor line the first line in the window.  If not enough\n\t     * room use w_skipcol;\n\t     */\n\t    wp->w_wrow = line_size;\n\t    if (wp->w_wrow >= wp->w_height\n\t\t\t\t       && (wp->w_width - win_col_off(wp)) > 0)\n\t    {\n\t\twp->w_skipcol += wp->w_width - win_col_off(wp);\n\t\t--wp->w_wrow;\n\t\twhile (wp->w_wrow >= wp->w_height)\n\t\t{\n\t\t    wp->w_skipcol += wp->w_width - win_col_off(wp)\n\t\t\t\t\t\t\t   + win_col_off2(wp);\n\t\t    --wp->w_wrow;\n\t\t}\n\t    }\n\t}\n\telse if (sline > 0)\n\t{\n\t    while (sline > 0 && lnum > 1)\n\t    {\n#ifdef FEAT_FOLDING\n\t\thasFoldingWin(wp, lnum, &lnum, NULL, TRUE, NULL);\n\t\tif (lnum == 1)\n\t\t{\n\t\t    // first line in buffer is folded\n\t\t    line_size = 1;\n\t\t    --sline;\n\t\t    break;\n\t\t}\n#endif\n\t\t--lnum;\n#ifdef FEAT_DIFF\n\t\tif (lnum == wp->w_topline)\n\t\t    line_size = plines_win_nofill(wp, lnum, TRUE)\n\t\t\t\t\t\t\t      + wp->w_topfill;\n\t\telse\n#endif\n\t\t    line_size = plines_win(wp, lnum, TRUE);\n\t\tsline -= line_size;\n\t    }\n\n\t    if (sline < 0)\n\t    {\n\t\t/*\n\t\t * Line we want at top would go off top of screen.  Use next\n\t\t * line instead.\n\t\t */\n#ifdef FEAT_FOLDING\n\t\thasFoldingWin(wp, lnum, NULL, &lnum, TRUE, NULL);\n#endif\n\t\tlnum++;\n\t\twp->w_wrow -= line_size + sline;\n\t    }\n\t    else if (sline > 0)\n\t    {\n\t\t// First line of file reached, use that as topline.\n\t\tlnum = 1;\n\t\twp->w_wrow -= sline;\n\t    }\n\t}\n\tset_topline(wp, lnum);\n    }\n\n    if (wp == curwin)\n    {\n\tif (get_scrolloff_value())\n\t    update_topline();\n\tcurs_columns(FALSE);\t// validate w_wrow\n    }\n    if (prev_height > 0)\n\twp->w_prev_fraction_row = wp->w_wrow;\n\n    win_comp_scroll(wp);\n    redraw_win_later(wp, SOME_VALID);\n    wp->w_redr_status = TRUE;\n    invalidate_botline_win(wp);\n}\n\n/*\n * Set the width of a window.\n */\n    void\nwin_new_width(win_T *wp, int width)\n{\n    wp->w_width = width;\n    wp->w_lines_valid = 0;\n    changed_line_abv_curs_win(wp);\n    invalidate_botline_win(wp);\n    if (wp == curwin)\n    {\n\tupdate_topline();\n\tcurs_columns(TRUE);\t// validate w_wrow\n    }\n    redraw_win_later(wp, NOT_VALID);\n    wp->w_redr_status = TRUE;\n}\n\n    void\nwin_comp_scroll(win_T *wp)\n{\n#if defined(FEAT_EVAL)\n    int old_w_p_scr = wp->w_p_scr;\n#endif\n\n    wp->w_p_scr = ((unsigned)wp->w_height >> 1);\n    if (wp->w_p_scr == 0)\n\twp->w_p_scr = 1;\n#if defined(FEAT_EVAL)\n    if (wp->w_p_scr != old_w_p_scr)\n    {\n\t// Used by \"verbose set scroll\".\n\twp->w_p_script_ctx[WV_SCROLL].sc_sid = SID_WINLAYOUT;\n\twp->w_p_script_ctx[WV_SCROLL].sc_lnum = 0;\n    }\n#endif\n}\n\n/*\n * command_height: called whenever p_ch has been changed\n */\n    void\ncommand_height(void)\n{\n    int\t\th;\n    frame_T\t*frp;\n    int\t\told_p_ch = curtab->tp_ch_used;\n\n    // Use the value of p_ch that we remembered.  This is needed for when the\n    // GUI starts up, we can't be sure in what order things happen.  And when\n    // p_ch was changed in another tab page.\n    curtab->tp_ch_used = p_ch;\n\n    // Find bottom frame with width of screen.\n    frp = lastwin->w_frame;\n    while (frp->fr_width != Columns && frp->fr_parent != NULL)\n\tfrp = frp->fr_parent;\n\n    // Avoid changing the height of a window with 'winfixheight' set.\n    while (frp->fr_prev != NULL && frp->fr_layout == FR_LEAF\n\t\t\t\t\t\t      && frp->fr_win->w_p_wfh)\n\tfrp = frp->fr_prev;\n\n    if (starting != NO_SCREEN)\n    {\n\tcmdline_row = Rows - p_ch;\n\n\tif (p_ch > old_p_ch)\t\t    // p_ch got bigger\n\t{\n\t    while (p_ch > old_p_ch)\n\t    {\n\t\tif (frp == NULL)\n\t\t{\n\t\t    emsg(_(e_not_enough_room));\n\t\t    p_ch = old_p_ch;\n\t\t    curtab->tp_ch_used = p_ch;\n\t\t    cmdline_row = Rows - p_ch;\n\t\t    break;\n\t\t}\n\t\th = frp->fr_height - frame_minheight(frp, NULL);\n\t\tif (h > p_ch - old_p_ch)\n\t\t    h = p_ch - old_p_ch;\n\t\told_p_ch += h;\n\t\tframe_add_height(frp, -h);\n\t\tfrp = frp->fr_prev;\n\t    }\n\n\t    // Recompute window positions.\n\t    (void)win_comp_pos();\n\n\t    // clear the lines added to cmdline\n\t    if (full_screen)\n\t\tscreen_fill(cmdline_row, (int)Rows, 0,\n\t\t\t\t\t\t   (int)Columns, ' ', ' ', 0);\n\t    msg_row = cmdline_row;\n\t    redraw_cmdline = TRUE;\n\t    return;\n\t}\n\n\tif (msg_row < cmdline_row)\n\t    msg_row = cmdline_row;\n\tredraw_cmdline = TRUE;\n    }\n    frame_add_height(frp, (int)(old_p_ch - p_ch));\n\n    // Recompute window positions.\n    if (frp != lastwin->w_frame)\n\t(void)win_comp_pos();\n}\n\n/*\n * Resize frame \"frp\" to be \"n\" lines higher (negative for less high).\n * Also resize the frames it is contained in.\n */\n    static void\nframe_add_height(frame_T *frp, int n)\n{\n    frame_new_height(frp, frp->fr_height + n, FALSE, FALSE);\n    for (;;)\n    {\n\tfrp = frp->fr_parent;\n\tif (frp == NULL)\n\t    break;\n\tfrp->fr_height += n;\n    }\n}\n\n/*\n * Add or remove a status line for the bottom window(s), according to the\n * value of 'laststatus'.\n */\n    void\nlast_status(\n    int\t\tmorewin)\t// pretend there are two or more windows\n{\n    // Don't make a difference between horizontal or vertical split.\n    last_status_rec(topframe, (p_ls == 2\n\t\t\t  || (p_ls == 1 && (morewin || !ONE_WINDOW))));\n}\n\n    static void\nlast_status_rec(frame_T *fr, int statusline)\n{\n    frame_T\t*fp;\n    win_T\t*wp;\n\n    if (fr->fr_layout == FR_LEAF)\n    {\n\twp = fr->fr_win;\n\tif (wp->w_status_height != 0 && !statusline)\n\t{\n\t    // remove status line\n\t    win_new_height(wp, wp->w_height + 1);\n\t    wp->w_status_height = 0;\n\t    comp_col();\n\t}\n\telse if (wp->w_status_height == 0 && statusline)\n\t{\n\t    // Find a frame to take a line from.\n\t    fp = fr;\n\t    while (fp->fr_height <= frame_minheight(fp, NULL))\n\t    {\n\t\tif (fp == topframe)\n\t\t{\n\t\t    emsg(_(e_not_enough_room));\n\t\t    return;\n\t\t}\n\t\t// In a column of frames: go to frame above.  If already at\n\t\t// the top or in a row of frames: go to parent.\n\t\tif (fp->fr_parent->fr_layout == FR_COL && fp->fr_prev != NULL)\n\t\t    fp = fp->fr_prev;\n\t\telse\n\t\t    fp = fp->fr_parent;\n\t    }\n\t    wp->w_status_height = 1;\n\t    if (fp != fr)\n\t    {\n\t\tframe_new_height(fp, fp->fr_height - 1, FALSE, FALSE);\n\t\tframe_fix_height(wp);\n\t\t(void)win_comp_pos();\n\t    }\n\t    else\n\t\twin_new_height(wp, wp->w_height - 1);\n\t    comp_col();\n\t    redraw_all_later(SOME_VALID);\n\t}\n    }\n    else if (fr->fr_layout == FR_ROW)\n    {\n\t// vertically split windows, set status line for each one\n\tFOR_ALL_FRAMES(fp, fr->fr_child)\n\t    last_status_rec(fp, statusline);\n    }\n    else\n    {\n\t// horizontally split window, set status line for last one\n\tfor (fp = fr->fr_child; fp->fr_next != NULL; fp = fp->fr_next)\n\t    ;\n\tlast_status_rec(fp, statusline);\n    }\n}\n\n/*\n * Return the number of lines used by the tab page line.\n */\n    int\ntabline_height(void)\n{\n#ifdef FEAT_GUI_TABLINE\n    // When the GUI has the tabline then this always returns zero.\n    if (gui_use_tabline())\n\treturn 0;\n#endif\n    switch (p_stal)\n    {\n\tcase 0: return 0;\n\tcase 1: return (first_tabpage->tp_next == NULL) ? 0 : 1;\n    }\n    return 1;\n}\n\n/*\n * Return the minimal number of rows that is needed on the screen to display\n * the current number of windows.\n */\n    int\nmin_rows(void)\n{\n    int\t\ttotal;\n    tabpage_T\t*tp;\n    int\t\tn;\n\n    if (firstwin == NULL)\t// not initialized yet\n\treturn MIN_LINES;\n\n    total = 0;\n    FOR_ALL_TABPAGES(tp)\n    {\n\tn = frame_minheight(tp->tp_topframe, NULL);\n\tif (total < n)\n\t    total = n;\n    }\n    total += tabline_height();\n    total += 1;\t\t// count the room for the command line\n    return total;\n}\n\n/*\n * Return TRUE if there is only one window and only one tab page, not\n * counting a help or preview window, unless it is the current window.\n * Does not count unlisted windows.\n */\n    int\nonly_one_window(void)\n{\n    int\t\tcount = 0;\n    win_T\t*wp;\n\n#if defined(FEAT_PROP_POPUP)\n    // If the current window is a popup then there always is another window.\n    if (popup_is_popup(curwin))\n\treturn FALSE;\n#endif\n\n    // If there is another tab page there always is another window.\n    if (first_tabpage->tp_next != NULL)\n\treturn FALSE;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (wp->w_buffer != NULL\n\t\t&& (!((bt_help(wp->w_buffer) && !bt_help(curbuf))\n# ifdef FEAT_QUICKFIX\n\t\t    || wp->w_p_pvw\n# endif\n\t     ) || wp == curwin) && wp != aucmd_win)\n\t    ++count;\n    return (count <= 1);\n}\n\n/*\n * Implementation of check_lnums() and check_lnums_nested().\n */\n    static void\ncheck_lnums_both(int do_curwin, int nested)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\tif ((do_curwin || wp != curwin) && wp->w_buffer == curbuf)\n\t{\n\t    if (!nested)\n\t    {\n\t\t// save the original cursor position and topline\n\t\twp->w_save_cursor.w_cursor_save = wp->w_cursor;\n\t\twp->w_save_cursor.w_topline_save = wp->w_topline;\n\t    }\n\n\t    if (wp->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t\twp->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t    if (wp->w_topline > curbuf->b_ml.ml_line_count)\n\t\twp->w_topline = curbuf->b_ml.ml_line_count;\n\n\t    // save the (corrected) cursor position and topline\n\t    wp->w_save_cursor.w_cursor_corr = wp->w_cursor;\n\t    wp->w_save_cursor.w_topline_corr = wp->w_topline;\n\t}\n}\n\n/*\n * Correct the cursor line number in other windows.  Used after changing the\n * current buffer, and before applying autocommands.\n * When \"do_curwin\" is TRUE, also check current window.\n */\n    void\ncheck_lnums(int do_curwin)\n{\n    check_lnums_both(do_curwin, FALSE);\n}\n\n/*\n * Like check_lnums() but for when check_lnums() was already called.\n */\n    void\ncheck_lnums_nested(int do_curwin)\n{\n    check_lnums_both(do_curwin, TRUE);\n}\n\n/*\n * Reset cursor and topline to its stored values from check_lnums().\n * check_lnums() must have been called first!\n */\n    void\nreset_lnums()\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\tif (wp->w_buffer == curbuf)\n\t{\n\t    // Restore the value if the autocommand didn't change it.\n\t    if (EQUAL_POS(wp->w_save_cursor.w_cursor_corr, wp->w_cursor))\n\t\twp->w_cursor = wp->w_save_cursor.w_cursor_save;\n\t    if (wp->w_save_cursor.w_topline_corr == wp->w_topline)\n\t\twp->w_topline = wp->w_save_cursor.w_topline_save;\n\t}\n}\n\n/*\n * A snapshot of the window sizes, to restore them after closing the help\n * window.\n * Only these fields are used:\n * fr_layout\n * fr_width\n * fr_height\n * fr_next\n * fr_child\n * fr_win (only valid for the old curwin, NULL otherwise)\n */\n\n/*\n * Create a snapshot of the current frame sizes.\n */\n    void\nmake_snapshot(int idx)\n{\n    clear_snapshot(curtab, idx);\n    make_snapshot_rec(topframe, &curtab->tp_snapshot[idx]);\n}\n\n    static void\nmake_snapshot_rec(frame_T *fr, frame_T **frp)\n{\n    *frp = ALLOC_CLEAR_ONE(frame_T);\n    if (*frp == NULL)\n\treturn;\n    (*frp)->fr_layout = fr->fr_layout;\n    (*frp)->fr_width = fr->fr_width;\n    (*frp)->fr_height = fr->fr_height;\n    if (fr->fr_next != NULL)\n\tmake_snapshot_rec(fr->fr_next, &((*frp)->fr_next));\n    if (fr->fr_child != NULL)\n\tmake_snapshot_rec(fr->fr_child, &((*frp)->fr_child));\n    if (fr->fr_layout == FR_LEAF && fr->fr_win == curwin)\n\t(*frp)->fr_win = curwin;\n}\n\n/*\n * Remove any existing snapshot.\n */\n    static void\nclear_snapshot(tabpage_T *tp, int idx)\n{\n    clear_snapshot_rec(tp->tp_snapshot[idx]);\n    tp->tp_snapshot[idx] = NULL;\n}\n\n    static void\nclear_snapshot_rec(frame_T *fr)\n{\n    if (fr != NULL)\n    {\n\tclear_snapshot_rec(fr->fr_next);\n\tclear_snapshot_rec(fr->fr_child);\n\tvim_free(fr);\n    }\n}\n\n/*\n * Traverse a snapshot to find the previous curwin.\n */\n    static win_T *\nget_snapshot_curwin_rec(frame_T *ft)\n{\n    win_T\t*wp;\n\n    if (ft->fr_next != NULL)\n    {\n\tif ((wp = get_snapshot_curwin_rec(ft->fr_next)) != NULL)\n\t    return wp;\n    }\n    if (ft->fr_child != NULL)\n    {\n\tif ((wp = get_snapshot_curwin_rec(ft->fr_child)) != NULL)\n\t    return wp;\n    }\n\n    return ft->fr_win;\n}\n\n/*\n * Return the current window stored in the snapshot or NULL.\n */\n    static win_T *\nget_snapshot_curwin(int idx)\n{\n    if (curtab->tp_snapshot[idx] == NULL)\n\treturn NULL;\n\n    return get_snapshot_curwin_rec(curtab->tp_snapshot[idx]);\n}\n\n/*\n * Restore a previously created snapshot, if there is any.\n * This is only done if the screen size didn't change and the window layout is\n * still the same.\n */\n    void\nrestore_snapshot(\n    int\t\tidx,\n    int\t\tclose_curwin)\t    // closing current window\n{\n    win_T\t*wp;\n\n    if (curtab->tp_snapshot[idx] != NULL\n\t    && curtab->tp_snapshot[idx]->fr_width == topframe->fr_width\n\t    && curtab->tp_snapshot[idx]->fr_height == topframe->fr_height\n\t    && check_snapshot_rec(curtab->tp_snapshot[idx], topframe) == OK)\n    {\n\twp = restore_snapshot_rec(curtab->tp_snapshot[idx], topframe);\n\twin_comp_pos();\n\tif (wp != NULL && close_curwin)\n\t    win_goto(wp);\n\tredraw_all_later(NOT_VALID);\n    }\n    clear_snapshot(curtab, idx);\n}\n\n/*\n * Check if frames \"sn\" and \"fr\" have the same layout, same following frames\n * and same children.  And the window pointer is valid.\n */\n    static int\ncheck_snapshot_rec(frame_T *sn, frame_T *fr)\n{\n    if (sn->fr_layout != fr->fr_layout\n\t    || (sn->fr_next == NULL) != (fr->fr_next == NULL)\n\t    || (sn->fr_child == NULL) != (fr->fr_child == NULL)\n\t    || (sn->fr_next != NULL\n\t\t&& check_snapshot_rec(sn->fr_next, fr->fr_next) == FAIL)\n\t    || (sn->fr_child != NULL\n\t\t&& check_snapshot_rec(sn->fr_child, fr->fr_child) == FAIL)\n\t    || (sn->fr_win != NULL && !win_valid(sn->fr_win)))\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * Copy the size of snapshot frame \"sn\" to frame \"fr\".  Do the same for all\n * following frames and children.\n * Returns a pointer to the old current window, or NULL.\n */\n    static win_T *\nrestore_snapshot_rec(frame_T *sn, frame_T *fr)\n{\n    win_T\t*wp = NULL;\n    win_T\t*wp2;\n\n    fr->fr_height = sn->fr_height;\n    fr->fr_width = sn->fr_width;\n    if (fr->fr_layout == FR_LEAF)\n    {\n\tframe_new_height(fr, fr->fr_height, FALSE, FALSE);\n\tframe_new_width(fr, fr->fr_width, FALSE, FALSE);\n\twp = sn->fr_win;\n    }\n    if (sn->fr_next != NULL)\n    {\n\twp2 = restore_snapshot_rec(sn->fr_next, fr->fr_next);\n\tif (wp2 != NULL)\n\t    wp = wp2;\n    }\n    if (sn->fr_child != NULL)\n    {\n\twp2 = restore_snapshot_rec(sn->fr_child, fr->fr_child);\n\tif (wp2 != NULL)\n\t    wp = wp2;\n    }\n    return wp;\n}\n\n#if defined(FEAT_GUI) || defined(PROTO)\n/*\n * Return TRUE if there is any vertically split window.\n */\n    int\nwin_hasvertsplit(void)\n{\n    frame_T\t*fr;\n\n    if (topframe->fr_layout == FR_ROW)\n\treturn TRUE;\n\n    if (topframe->fr_layout == FR_COL)\n\tFOR_ALL_FRAMES(fr, topframe->fr_child)\n\t    if (fr->fr_layout == FR_ROW)\n\t\treturn TRUE;\n\n    return FALSE;\n}\n#endif\n\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3) || defined(PROTO)\n    int\nget_win_number(win_T *wp, win_T *first_win)\n{\n    int\t\ti = 1;\n    win_T\t*w;\n\n    for (w = first_win; w != NULL && w != wp; w = W_NEXT(w))\n\t++i;\n\n    if (w == NULL)\n\treturn 0;\n    else\n\treturn i;\n}\n\n    int\nget_tab_number(tabpage_T *tp UNUSED)\n{\n    int\t\ti = 1;\n    tabpage_T\t*t;\n\n    for (t = first_tabpage; t != NULL && t != tp; t = t->tp_next)\n\t++i;\n\n    if (t == NULL)\n\treturn 0;\n    else\n\treturn i;\n}\n#endif\n\n/*\n * Return TRUE if \"topfrp\" and its children are at the right height.\n */\n    static int\nframe_check_height(frame_T *topfrp, int height)\n{\n    frame_T *frp;\n\n    if (topfrp->fr_height != height)\n\treturn FALSE;\n\n    if (topfrp->fr_layout == FR_ROW)\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    if (frp->fr_height != height)\n\t\treturn FALSE;\n\n    return TRUE;\n}\n\n/*\n * Return TRUE if \"topfrp\" and its children are at the right width.\n */\n    static int\nframe_check_width(frame_T *topfrp, int width)\n{\n    frame_T *frp;\n\n    if (topfrp->fr_width != width)\n\treturn FALSE;\n\n    if (topfrp->fr_layout == FR_COL)\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    if (frp->fr_width != width)\n\t\treturn FALSE;\n\n    return TRUE;\n}\n\n#if defined(FEAT_SYN_HL) || defined(PROTO)\n/*\n * Simple int comparison function for use with qsort()\n */\n    static int\nint_cmp(const void *a, const void *b)\n{\n    return *(const int *)a - *(const int *)b;\n}\n\n/*\n * Handle setting 'colorcolumn' or 'textwidth' in window \"wp\".\n * Returns error message, NULL if it's OK.\n */\n    char *\ncheck_colorcolumn(win_T *wp)\n{\n    char_u\t*s;\n    int\t\tcol;\n    int\t\tcount = 0;\n    int\t\tcolor_cols[256];\n    int\t\ti;\n    int\t\tj = 0;\n\n    if (wp->w_buffer == NULL)\n\treturn NULL;  // buffer was closed\n\n    for (s = wp->w_p_cc; *s != NUL && count < 255;)\n    {\n\tif (*s == '-' || *s == '+')\n\t{\n\t    // -N and +N: add to 'textwidth'\n\t    col = (*s == '-') ? -1 : 1;\n\t    ++s;\n\t    if (!VIM_ISDIGIT(*s))\n\t\treturn e_invalid_argument;\n\t    col = col * getdigits(&s);\n\t    if (wp->w_buffer->b_p_tw == 0)\n\t\tgoto skip;  // 'textwidth' not set, skip this item\n\t    col += wp->w_buffer->b_p_tw;\n\t    if (col < 0)\n\t\tgoto skip;\n\t}\n\telse if (VIM_ISDIGIT(*s))\n\t    col = getdigits(&s);\n\telse\n\t    return e_invalid_argument;\n\tcolor_cols[count++] = col - 1;  // 1-based to 0-based\nskip:\n\tif (*s == NUL)\n\t    break;\n\tif (*s != ',')\n\t    return e_invalid_argument;\n\tif (*++s == NUL)\n\t    return e_invalid_argument;  // illegal trailing comma as in \"set cc=80,\"\n    }\n\n    vim_free(wp->w_p_cc_cols);\n    if (count == 0)\n\twp->w_p_cc_cols = NULL;\n    else\n    {\n\twp->w_p_cc_cols = ALLOC_MULT(int, count + 1);\n\tif (wp->w_p_cc_cols != NULL)\n\t{\n\t    // sort the columns for faster usage on screen redraw inside\n\t    // win_line()\n\t    qsort(color_cols, count, sizeof(int), int_cmp);\n\n\t    for (i = 0; i < count; ++i)\n\t\t// skip duplicates\n\t\tif (j == 0 || wp->w_p_cc_cols[j - 1] != color_cols[i])\n\t\t    wp->w_p_cc_cols[j++] = color_cols[i];\n\t    wp->w_p_cc_cols[j] = -1;  // end marker\n\t}\n    }\n\n    return NULL;  // no error\n}\n#endif\n"], "filenames": ["src/autocmd.c", "src/proto/window.pro", "src/testdir/test_autocmd.vim", "src/version.c", "src/window.c"], "buggy_code_start_loc": [2211, 79, 2301, 737, 6773], "buggy_code_end_loc": [2214, 79, 2301, 737, 6798], "fixing_code_start_loc": [2212, 80, 2302, 738, 6773], "fixing_code_end_loc": [2219, 81, 2321, 740, 6820], "type": "CWE-122", "message": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0061.", "other": {"cve": {"id": "CVE-2022-2522", "sourceIdentifier": "security@huntr.dev", "published": "2022-07-25T14:15:10.930", "lastModified": "2023-05-03T12:16:00.763", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0061."}, {"lang": "es", "value": "Un Desbordamiento de B\u00fafer en la regi\u00f3n Heap de la Memoria en el repositorio de GitHub vim/vim versiones anteriores a 9.0.0061."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-122"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.0.0061", "matchCriteriaId": "CD18C140-EEEC-44D3-9C13-58611C3E7D99"}]}]}], "references": [{"url": "https://github.com/vim/vim/commit/5fa9f23a63651a8abdb074b4fc2ec9b1adc6b089", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/vim/vim/commit/b9e717367c395490149495cf375911b5d9de889e", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/3a2d83af-9542-4d93-8784-98b115135a22", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/3a2d83af-9542-4d93-8784-98b115135a22/", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202305-16", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/vim/vim/commit/5fa9f23a63651a8abdb074b4fc2ec9b1adc6b089"}}