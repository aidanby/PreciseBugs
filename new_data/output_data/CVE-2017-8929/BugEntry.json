{"buggy_code": ["/*\nCopyright (c) 2013. The YARA Authors. All Rights Reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\nlist of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\n\nThis module implements a structure I've called \"arena\". An arena is a data\ncontainer composed of a set of pages. The arena grows automatically when\nneeded by adding new pages to hold new data. Arenas can be saved and loaded\nfrom files.\n\n*/\n\n#include <string.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <time.h>\n\n\n#include <yara/arena.h>\n#include <yara/mem.h>\n#include <yara/error.h>\n#include <yara/limits.h>\n\n#pragma pack(push)\n#pragma pack(1)\n\ntypedef struct _ARENA_FILE_HEADER\n{\n  char      magic[4];\n  uint32_t  size;\n  uint32_t  version;\n\n} ARENA_FILE_HEADER;\n\n#pragma pack(pop)\n\n\n#define free_space(page) \\\n    ((page)->size - (page)->used)\n\n\n//\n// _yr_arena_new_page\n//\n// Creates a new arena page of a given size\n//\n// Args:\n//    size_t size  - Size of the page\n//\n// Returns:\n//    A pointer to the newly created YR_ARENA_PAGE structure\n//\n\nYR_ARENA_PAGE* _yr_arena_new_page(\n    size_t size)\n{\n  YR_ARENA_PAGE* new_page;\n\n  new_page = (YR_ARENA_PAGE*) yr_malloc(sizeof(YR_ARENA_PAGE));\n\n  if (new_page == NULL)\n    return NULL;\n\n  new_page->address = (uint8_t*) yr_malloc(size);\n\n  if (new_page->address == NULL)\n  {\n    yr_free(new_page);\n    return NULL;\n  }\n\n  new_page->size = size;\n  new_page->used = 0;\n  new_page->next = NULL;\n  new_page->prev = NULL;\n  new_page->reloc_list_head = NULL;\n  new_page->reloc_list_tail = NULL;\n\n  return new_page;\n}\n\n\n//\n// _yr_arena_page_for_address\n//\n// Returns the page within the arena where an address reside.\n//\n// Args:\n//    YR_ARENA* arena   - Pointer to the arena\n//    void* address  - Address to be located\n//\n// Returns:\n//    A pointer the corresponding YR_ARENA_PAGE structure where the address\n//    resides.\n//\n\nYR_ARENA_PAGE* _yr_arena_page_for_address(\n    YR_ARENA* arena,\n    void* address)\n{\n  YR_ARENA_PAGE* page;\n\n  // Most of the times this function is called with an address within\n  // the current page, let's check the current page first to avoid\n  // looping through the page list.\n\n  page = arena->current_page;\n\n  if (page != NULL &&\n      (uint8_t*) address >= page->address &&\n      (uint8_t*) address < page->address + page->used)\n    return page;\n\n  page = arena->page_list_head;\n\n  while (page != NULL)\n  {\n    if ((uint8_t*) address >= page->address &&\n        (uint8_t*) address < page->address + page->used)\n      return page;\n    page = page->next;\n  }\n\n  return NULL;\n}\n\n\n//\n// _yr_arena_make_relocatable\n//\n// Tells the arena that certain addresses contains a relocatable pointer.\n//\n// Args:\n//    YR_ARENA* arena    - Pointer the arena\n//    void* address      - Base address\n//    va_list offsets    - List of offsets relative to base address\n//\n// Returns:\n//    ERROR_SUCCESS if succeed or the corresponding error code otherwise.\n//\n\nint _yr_arena_make_relocatable(\n    YR_ARENA* arena,\n    void* base,\n    va_list offsets)\n{\n  YR_RELOC* reloc;\n  YR_ARENA_PAGE* page;\n\n  size_t offset;\n  size_t base_offset;\n\n  int result = ERROR_SUCCESS;\n\n  page = _yr_arena_page_for_address(arena, base);\n\n  assert(page != NULL);\n\n  base_offset = (uint8_t*) base - page->address;\n  offset = va_arg(offsets, size_t);\n\n  while (offset != -1)\n  {\n    assert(page->used >= sizeof(int64_t));\n    assert(base_offset + offset <= page->used - sizeof(int64_t));\n\n    reloc = (YR_RELOC*) yr_malloc(sizeof(YR_RELOC));\n\n    if (reloc == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    reloc->offset = (uint32_t) (base_offset + offset);\n    reloc->next = NULL;\n\n    if (page->reloc_list_head == NULL)\n      page->reloc_list_head = reloc;\n\n    if (page->reloc_list_tail != NULL)\n      page->reloc_list_tail->next = reloc;\n\n    page->reloc_list_tail = reloc;\n    offset = va_arg(offsets, size_t);\n  }\n\n  return result;\n}\n\n\n//\n// yr_arena_create\n//\n// Creates a new arena.\n//\n// Args:\n//    size_t initial_size  - Initial size\n//    int flags            - Flags\n//    YR_ARENA** arena     - Address where a pointer to the new arena will be\n//                           written to.\n//\n// Returns:\n//    ERROR_SUCCESS if succeed or the corresponding error code otherwise.\n//\n\nint yr_arena_create(\n    size_t initial_size,\n    int flags,\n    YR_ARENA** arena)\n{\n  YR_ARENA* new_arena;\n  YR_ARENA_PAGE* new_page;\n\n  *arena = NULL;\n  new_arena = (YR_ARENA*) yr_malloc(sizeof(YR_ARENA));\n\n  if (new_arena == NULL)\n    return ERROR_INSUFFICIENT_MEMORY;\n\n  new_page = _yr_arena_new_page(initial_size);\n\n  if (new_page == NULL)\n  {\n    yr_free(new_arena);\n    return ERROR_INSUFFICIENT_MEMORY;\n  }\n\n  new_arena->page_list_head = new_page;\n  new_arena->current_page = new_page;\n  new_arena->flags = flags | ARENA_FLAGS_COALESCED;\n\n  *arena = new_arena;\n  return ERROR_SUCCESS;\n}\n\n\n//\n// yr_arena_destroy\n//\n// Destroys an arena releasing its resource.\n//\n// Args:\n//    YR_ARENA* arena  - Pointer to the arena.\n//\n// Returns:\n//    ERROR_SUCCESS if succeed or the corresponding error code otherwise.\n//\n\nvoid yr_arena_destroy(\n    YR_ARENA* arena)\n{\n  YR_RELOC* reloc;\n  YR_RELOC* next_reloc;\n  YR_ARENA_PAGE* page;\n  YR_ARENA_PAGE* next_page;\n\n  if (arena == NULL)\n    return;\n\n  page = arena->page_list_head;\n\n  while(page != NULL)\n  {\n    next_page = page->next;\n    reloc = page->reloc_list_head;\n\n    while (reloc != NULL)\n    {\n      next_reloc = reloc->next;\n      yr_free(reloc);\n      reloc = next_reloc;\n    }\n\n    yr_free(page->address);\n    yr_free(page);\n\n    page = next_page;\n  }\n\n  yr_free(arena);\n}\n\n\n//\n// yr_arena_base_address\n//\n// Returns the base address for the arena.\n//\n// Args:\n//    YR_ARENA* arena  - Pointer to the arena.\n//\n// Returns:\n//    A pointer to the arena's data. NULL if the no data has been written to\n//    the arena yet.\n//\n\nvoid* yr_arena_base_address(\n  YR_ARENA* arena)\n{\n  if (arena->page_list_head->used == 0)\n    return NULL;\n\n  return arena->page_list_head->address;\n}\n\n\n//\n// yr_arena_next_address\n//\n// Given an address and an offset, returns the address where\n// address + offset resides. The arena is a collection of non-contiguous\n// regions of memory (pages), if address is pointing at the end of a page,\n// address + offset could cross the page boundary and point at somewhere\n// within the next page, this function handles these situations. It works\n// also with negative offsets.\n//\n// Args:\n//    YR_ARENA* arena  - Pointer to the arena.\n//    void* address    - Base address.\n//    int offset       - Offset.\n//\n// Returns:\n//    A pointer\n//\n\n\nvoid* yr_arena_next_address(\n  YR_ARENA* arena,\n  void* address,\n  size_t offset)\n{\n  YR_ARENA_PAGE* page;\n\n  page = _yr_arena_page_for_address(arena, address);\n\n  assert(page != NULL);\n\n  if ((uint8_t*) address + offset >= page->address &&\n      (uint8_t*) address + offset < page->address + page->used)\n  {\n    return (uint8_t*) address + offset;\n  }\n\n  if (offset > 0)\n  {\n    offset -= page->address + page->used - (uint8_t*) address;\n    page = page->next;\n\n    while (page != NULL)\n    {\n      if (offset < page->used)\n        return page->address + offset;\n\n      offset -= page->used;\n      page = page->next;\n    }\n  }\n  else\n  {\n    offset += page->used;\n    page = page->prev;\n\n    while (page != NULL)\n    {\n      if (offset < page->used)\n        return page->address + page->used + offset;\n\n      offset += page->used;\n      page = page->prev;\n    }\n  }\n\n  return NULL;\n}\n\n\n//\n// yr_arena_coalesce\n//\n// Coalesce the arena into a single page. This is a required step before\n// saving the arena to a file.\n//\n// Args:\n//    YR_ARENA* arena  - Pointer to the arena.\n//\n// Returns:\n//    ERROR_SUCCESS if succeed or the corresponding error code otherwise.\n//\n\nint yr_arena_coalesce(\n    YR_ARENA* arena)\n{\n  YR_ARENA_PAGE* page;\n  YR_ARENA_PAGE* big_page;\n  YR_ARENA_PAGE* next_page;\n  YR_RELOC* reloc;\n\n  uint8_t** reloc_address;\n  uint8_t* reloc_target;\n  size_t total_size = 0;\n\n  page = arena->page_list_head;\n\n  while(page != NULL)\n  {\n    total_size += page->used;\n    page = page->next;\n  }\n\n  // Create a new page that will contain the entire arena.\n  big_page = _yr_arena_new_page(total_size);\n\n  if (big_page == NULL)\n    return ERROR_INSUFFICIENT_MEMORY;\n\n  // Copy data from current pages to the big page and adjust relocs.\n  page = arena->page_list_head;\n\n  while (page != NULL)\n  {\n    page->new_address = big_page->address + big_page->used;\n    memcpy(page->new_address, page->address, page->used);\n\n    reloc = page->reloc_list_head;\n\n    while(reloc != NULL)\n    {\n      reloc->offset += (uint32_t) big_page->used;\n      reloc = reloc->next;\n    }\n\n    if (big_page->reloc_list_head == NULL)\n      big_page->reloc_list_head = page->reloc_list_head;\n\n    if (big_page->reloc_list_tail != NULL)\n      big_page->reloc_list_tail->next = page->reloc_list_head;\n\n    if (page->reloc_list_tail != NULL)\n      big_page->reloc_list_tail = page->reloc_list_tail;\n\n    big_page->used += page->used;\n    page = page->next;\n  }\n\n  // Relocate pointers.\n  reloc = big_page->reloc_list_head;\n\n  while (reloc != NULL)\n  {\n    reloc_address = (uint8_t**) (big_page->address + reloc->offset);\n    reloc_target = *reloc_address;\n\n    if (reloc_target != NULL)\n    {\n      page = _yr_arena_page_for_address(arena, reloc_target);\n      assert(page != NULL);\n      *reloc_address = page->new_address + (reloc_target - page->address);\n    }\n\n    reloc = reloc->next;\n  }\n\n  // Release current pages.\n  page = arena->page_list_head;\n\n  while(page != NULL)\n  {\n    next_page = page->next;\n    yr_free(page->address);\n    yr_free(page);\n    page = next_page;\n  }\n\n  arena->page_list_head = big_page;\n  arena->current_page = big_page;\n  arena->flags |= ARENA_FLAGS_COALESCED;\n\n  return ERROR_SUCCESS;\n}\n\n\n//\n// yr_arena_reserve_memory\n//\n// Ensures that the arena have enough contiguous memory for future allocations.\n// if the available space in the current page is lower than \"size\", a new page\n// is allocated.\n//\n// Args:\n//    YR_ARENA* arena         - Pointer to the arena.\n//    size_t size             - Size of the region to be reserved.\n//\n// Returns:\n//    ERROR_SUCCESS if succeed or the corresponding error code otherwise.\n//\n\n\nint yr_arena_reserve_memory(\n    YR_ARENA* arena,\n    size_t size)\n{\n  YR_ARENA_PAGE* new_page;\n  size_t new_page_size;\n  uint8_t* new_page_address;\n\n  if (size > free_space(arena->current_page))\n  {\n    if (arena->flags & ARENA_FLAGS_FIXED_SIZE)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    // Requested space is bigger than current page's empty space,\n    // lets calculate the size for a new page.\n\n    new_page_size = arena->current_page->size * 2;\n\n    while (new_page_size < size)\n      new_page_size *= 2;\n\n    if (arena->current_page->used == 0)\n    {\n      // Current page is not used at all, it can be reallocated.\n\n      new_page_address = (uint8_t*) yr_realloc(\n          arena->current_page->address,\n          new_page_size);\n\n      if (new_page_address == NULL)\n        return ERROR_INSUFFICIENT_MEMORY;\n\n      arena->current_page->address = new_page_address;\n      arena->current_page->size = new_page_size;\n    }\n    else\n    {\n      new_page = _yr_arena_new_page(new_page_size);\n\n      if (new_page == NULL)\n        return ERROR_INSUFFICIENT_MEMORY;\n\n      new_page->prev = arena->current_page;\n      arena->current_page->next = new_page;\n      arena->current_page = new_page;\n      arena->flags &= ~ARENA_FLAGS_COALESCED;\n    }\n  }\n\n  return ERROR_SUCCESS;\n}\n\n\n//\n// yr_arena_allocate_memory\n//\n// Allocates memory within the arena.\n//\n// Args:\n//    YR_ARENA* arena         - Pointer to the arena.\n//    size_t size             - Size of the region to be allocated.\n//    void** allocated_memory - Address of a pointer to newly allocated\n//                              region.\n// Returns:\n//    ERROR_SUCCESS if succeed or the corresponding error code otherwise.\n//\n\nint yr_arena_allocate_memory(\n    YR_ARENA* arena,\n    size_t size,\n    void** allocated_memory)\n{\n  FAIL_ON_ERROR(yr_arena_reserve_memory(arena, size));\n\n  *allocated_memory = arena->current_page->address + \\\n                      arena->current_page->used;\n\n  arena->current_page->used += size;\n\n  return ERROR_SUCCESS;\n}\n\n\n//\n// yr_arena_allocate_struct\n//\n// Allocates a structure within the arena. This function is similar to\n// yr_arena_allocate_memory but additionally receives a variable-length\n// list of offsets within the structure where pointers reside. This allows\n// the arena to keep track of pointers that must be adjusted when memory\n// is relocated. This is an example on how to invoke this function:\n//\n//  yr_arena_allocate_struct(\n//        arena,\n//        sizeof(MY_STRUCTURE),\n//        (void**) &my_structure_ptr,\n//        offsetof(MY_STRUCTURE, field_1),\n//        offsetof(MY_STRUCTURE, field_2),\n//        ..\n//        offsetof(MY_STRUCTURE, field_N),\n//        EOL);\n//\n// Args:\n//    YR_ARENA* arena         - Pointer to the arena.\n//    size_t size             - Size of the region to be allocated.\n//    void** allocated_memory - Address of a pointer to newly allocated\n//                              region.\n//    ...                     - Variable number of offsets relative to the\n//                              beginning of the struct. Offsets are of type\n//                              size_t.\n//\n// Returns:\n//    ERROR_SUCCESS if succeed or the corresponding error code otherwise.\n//\n\nint yr_arena_allocate_struct(\n    YR_ARENA* arena,\n    size_t size,\n    void** allocated_memory,\n    ...)\n{\n  int result;\n\n  va_list offsets;\n  va_start(offsets, allocated_memory);\n\n  result = yr_arena_allocate_memory(arena, size, allocated_memory);\n\n  if (result == ERROR_SUCCESS)\n    result = _yr_arena_make_relocatable(arena, *allocated_memory, offsets);\n\n  va_end(offsets);\n\n  if (result == ERROR_SUCCESS)\n    memset(*allocated_memory, 0, size);\n\n  return result;\n}\n\n\n//\n// yr_arena_make_relocatable\n//\n// Tells the arena that certain addresses contains a relocatable pointer.\n//\n// Args:\n//    YR_ARENA* arena    - Pointer to the arena.\n//    void* base         - Address within the arena.\n//    ...                - Variable number of size_t arguments with offsets\n//                         relative to base.\n//\n// Returns:\n//    ERROR_SUCCESS if succeed or the corresponding error code otherwise.\n//\n\nint yr_arena_make_relocatable(\n    YR_ARENA* arena,\n    void* base,\n    ...)\n{\n  int result;\n\n  va_list offsets;\n  va_start(offsets, base);\n\n  result = _yr_arena_make_relocatable(arena, base, offsets);\n\n  va_end(offsets);\n\n  return result;\n}\n\n\n//\n// yr_arena_write_data\n//\n// Writes data to the arena.\n//\n// Args:\n//    YR_ARENA* arena        - Pointer to the arena.\n//    void* data             - Pointer to data to be written.\n//    size_t size            - Size of data.\n//    void** written_data    - Address where a pointer to the written data will\n//                             be returned.\n//\n// Returns:\n//    ERROR_SUCCESS if succeed or the corresponding error code otherwise.\n//\n\nint yr_arena_write_data(\n    YR_ARENA* arena,\n    void* data,\n    size_t size,\n    void** written_data)\n{\n  void* output;\n  int result;\n\n  if (size > free_space(arena->current_page))\n  {\n    result = yr_arena_allocate_memory(arena, size, &output);\n\n    if (result != ERROR_SUCCESS)\n      return result;\n  }\n  else\n  {\n    output = arena->current_page->address + arena->current_page->used;\n    arena->current_page->used += size;\n  }\n\n  memcpy(output, data, size);\n\n  if (written_data != NULL)\n    *written_data = output;\n\n  return ERROR_SUCCESS;\n}\n\n\n//\n// yr_arena_write_string\n//\n// Writes string to the arena.\n//\n// Args:\n//    YR_ARENA* arena        - Pointer to the arena.\n//    const char* string     - Pointer to string to be written.\n//    char** written_string  - Address where a pointer to the written data will\n//                             be returned.\n//\n// Returns:\n//    ERROR_SUCCESS if succeed or the corresponding error code otherwise.\n//\n\nint yr_arena_write_string(\n    YR_ARENA* arena,\n    const char* string,\n    char** written_string)\n{\n  return yr_arena_write_data(\n      arena,\n      (void*) string,\n      strlen(string) + 1,\n      (void**) written_string);\n}\n\n\n//\n// yr_arena_append\n//\n// Appends source_arena to target_arena. This operation destroys source_arena,\n// after returning any pointer to source_arena is no longer valid. The data\n// from source_arena is guaranteed to be aligned to a 16 bytes boundary when\n// written to the source_arena\n//\n// Args:\n//    YR_ARENA* target_arena    - Pointer to target the arena.\n//    YR_ARENA* source_arena    - Pointer to source arena.\n//\n// Returns:\n//    ERROR_SUCCESS if succeed or the corresponding error code otherwise.\n//\n\nint yr_arena_append(\n    YR_ARENA* target_arena,\n    YR_ARENA* source_arena)\n{\n  uint8_t padding_data[15];\n  size_t padding_size = 16 - target_arena->current_page->used % 16;\n\n  if (padding_size < 16)\n  {\n    memset(&padding_data, 0xCC, padding_size);\n\n    FAIL_ON_ERROR(yr_arena_write_data(\n        target_arena,\n        padding_data,\n        padding_size,\n        NULL));\n  }\n\n  target_arena->current_page->next = source_arena->page_list_head;\n  source_arena->page_list_head->prev = target_arena->current_page;\n  target_arena->current_page = source_arena->current_page;\n\n  yr_free(source_arena);\n\n  return ERROR_SUCCESS;\n}\n\n\n//\n// yr_arena_duplicate\n//\n// Duplicates the arena, making an exact copy. This function requires the\n// arena to be coalesced.\n//\n// Args:\n//    YR_ARENA* arena        - Pointer to the arena.\n//    YR_ARENA** duplicated  - Address where a pointer to the new arena arena\n//                             will be returned.\n//\n// Returns:\n//    ERROR_SUCCESS if succeed or the corresponding error code otherwise.\n//\n\nint yr_arena_duplicate(\n    YR_ARENA* arena,\n    YR_ARENA** duplicated)\n{\n  YR_RELOC* reloc;\n  YR_RELOC* new_reloc;\n  YR_ARENA_PAGE* page;\n  YR_ARENA_PAGE* new_page;\n  YR_ARENA* new_arena;\n  uint8_t** reloc_address;\n  uint8_t* reloc_target;\n\n  // Only coalesced arenas can be duplicated.\n  assert(arena->flags & ARENA_FLAGS_COALESCED);\n\n  page = arena->page_list_head;\n\n  FAIL_ON_ERROR(yr_arena_create(page->size, arena->flags, &new_arena));\n\n  new_page = new_arena->current_page;\n  new_page->used = page->used;\n\n  memcpy(new_page->address, page->address, page->size);\n\n  reloc = page->reloc_list_head;\n\n  while (reloc != NULL)\n  {\n    new_reloc = (YR_RELOC*) yr_malloc(sizeof(YR_RELOC));\n\n    if (new_reloc == NULL)\n    {\n      yr_arena_destroy(new_arena);\n      return ERROR_INSUFFICIENT_MEMORY;\n    }\n\n    new_reloc->offset = reloc->offset;\n    new_reloc->next = NULL;\n\n    if (new_page->reloc_list_head == NULL)\n      new_page->reloc_list_head = new_reloc;\n\n    if (new_page->reloc_list_tail != NULL)\n      new_page->reloc_list_tail->next = new_reloc;\n\n    new_page->reloc_list_tail = new_reloc;\n\n    reloc_address = (uint8_t**) (new_page->address + new_reloc->offset);\n    reloc_target = *reloc_address;\n\n    if (reloc_target != NULL)\n    {\n      assert(reloc_target >= page->address);\n      assert(reloc_target < page->address + page->used);\n\n      *reloc_address = reloc_target - \\\n                       page->address + \\\n                       new_page->address;\n    }\n\n    reloc = reloc->next;\n  }\n\n  *duplicated = new_arena;\n\n  return ERROR_SUCCESS;\n}\n\n\n//\n// yr_arena_load_stream\n//\n// Loads an arena from a stream.\n//\n// Args:\n//    YR_STREAM* stream  - Pointer to stream object\n//    YR_ARENA**         - Address where a pointer to the loaded arena\n//                         will be returned\n//\n// Returns:\n//    ERROR_SUCCESS if successful, appropriate error code otherwise.\n//\n\nint yr_arena_load_stream(\n    YR_STREAM* stream,\n    YR_ARENA** arena)\n{\n  YR_ARENA_PAGE* page;\n  YR_ARENA* new_arena;\n  ARENA_FILE_HEADER header;\n\n  uint32_t reloc_offset;\n  uint8_t** reloc_address;\n  uint8_t* reloc_target;\n\n  int result;\n\n  if (yr_stream_read(&header, sizeof(header), 1, stream) != 1)\n    return ERROR_INVALID_FILE;\n\n  if (header.magic[0] != 'Y' ||\n      header.magic[1] != 'A' ||\n      header.magic[2] != 'R' ||\n      header.magic[3] != 'A')\n  {\n    return ERROR_INVALID_FILE;\n  }\n\n  if (header.size < 2048)       // compiled rules are always larger than 2KB\n    return ERROR_CORRUPT_FILE;\n\n  if (header.version != ARENA_FILE_VERSION)\n    return ERROR_UNSUPPORTED_FILE_VERSION;\n\n  result = yr_arena_create(header.size, 0, &new_arena);\n\n  if (result != ERROR_SUCCESS)\n    return result;\n\n  page = new_arena->current_page;\n\n  if (yr_stream_read(page->address, header.size, 1, stream) != 1)\n  {\n    yr_arena_destroy(new_arena);\n    return ERROR_CORRUPT_FILE;\n  }\n\n  page->used = header.size;\n\n  if (yr_stream_read(&reloc_offset, sizeof(reloc_offset), 1, stream) != 1)\n  {\n    yr_arena_destroy(new_arena);\n    return ERROR_CORRUPT_FILE;\n  }\n\n  while (reloc_offset != 0xFFFFFFFF)\n  {\n    if (reloc_offset > header.size - sizeof(uint8_t*))\n    {\n      yr_arena_destroy(new_arena);\n      return ERROR_CORRUPT_FILE;\n    }\n\n    yr_arena_make_relocatable(new_arena, page->address, reloc_offset, EOL);\n\n    reloc_address = (uint8_t**) (page->address + reloc_offset);\n    reloc_target = *reloc_address;\n\n    if (reloc_target != (uint8_t*) (size_t) 0xFFFABADA)\n      *reloc_address += (size_t) page->address;\n    else\n      *reloc_address = 0;\n\n    if (yr_stream_read(&reloc_offset, sizeof(reloc_offset), 1, stream) != 1)\n    {\n      yr_arena_destroy(new_arena);\n      return ERROR_CORRUPT_FILE;\n    }\n  }\n\n  *arena = new_arena;\n\n  return ERROR_SUCCESS;\n}\n\n\n//\n// yr_arena_save_stream\n//\n// Saves the arena into a stream. If the file exists its overwritten. This\n// function requires the arena to be coalesced.\n//\n// Args:\n//    YR_ARENA* arena         - Pointer to the arena.\n//    YR_STREAM* stream       - Pointer to stream object.\n//\n// Returns:\n//    ERROR_SUCCESS if succeed or the corresponding error code otherwise.\n//\n\nint yr_arena_save_stream(\n  YR_ARENA* arena,\n  YR_STREAM* stream)\n{\n  YR_ARENA_PAGE* page;\n  YR_RELOC* reloc;\n  ARENA_FILE_HEADER header;\n\n  uint32_t end_marker = 0xFFFFFFFF;\n  uint8_t** reloc_address;\n  uint8_t* reloc_target;\n\n  // Only coalesced arenas can be saved.\n  assert(arena->flags & ARENA_FLAGS_COALESCED);\n\n  page = arena->page_list_head;\n  reloc = page->reloc_list_head;\n\n  // Convert pointers to offsets before saving.\n  while (reloc != NULL)\n  {\n    reloc_address = (uint8_t**) (page->address + reloc->offset);\n    reloc_target = *reloc_address;\n\n    if (reloc_target != NULL)\n    {\n      assert(reloc_target >= page->address);\n      assert(reloc_target < page->address + page->used);\n      *reloc_address = (uint8_t*) (*reloc_address - page->address);\n    }\n    else\n    {\n      *reloc_address = (uint8_t*) (size_t) 0xFFFABADA;\n    }\n\n    reloc = reloc->next;\n  }\n\n  assert(page->size < 0x80000000);  // 2GB\n\n  header.magic[0] = 'Y';\n  header.magic[1] = 'A';\n  header.magic[2] = 'R';\n  header.magic[3] = 'A';\n  header.size = (int32_t) page->size;\n  header.version = ARENA_FILE_VERSION;\n\n  yr_stream_write(&header, sizeof(header), 1, stream);\n  yr_stream_write(page->address, header.size, 1, stream);\n\n  reloc = page->reloc_list_head;\n\n  // Convert offsets back to pointers.\n  while (reloc != NULL)\n  {\n    yr_stream_write(&reloc->offset, sizeof(reloc->offset), 1, stream);\n\n    reloc_address = (uint8_t**) (page->address + reloc->offset);\n    reloc_target = *reloc_address;\n\n    if (reloc_target != (void*) (size_t) 0xFFFABADA)\n      *reloc_address += (size_t) page->address;\n    else\n      *reloc_address = 0;\n\n    reloc = reloc->next;\n  }\n\n  yr_stream_write(&end_marker, sizeof(end_marker), 1, stream);\n\n  return ERROR_SUCCESS;\n}\n", "/*\nCopyright (c) 2013-2014. The YARA Authors. All Rights Reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\nlist of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#define _GNU_SOURCE\n\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n#include <math.h>\n\n#include <yara/endian.h>\n#include <yara/exec.h>\n#include <yara/limits.h>\n#include <yara/error.h>\n#include <yara/object.h>\n#include <yara/modules.h>\n#include <yara/re.h>\n#include <yara/strutils.h>\n#include <yara/utils.h>\n#include <yara/mem.h>\n\n#include <yara.h>\n\n\n#define MEM_SIZE   MAX_LOOP_NESTING * LOOP_LOCAL_VARS\n\n\n#define push(x)  \\\n    if (sp < stack_size) \\\n    { \\\n      stack[sp++] = (x); \\\n    } \\\n    else \\\n    { \\\n      result = ERROR_EXEC_STACK_OVERFLOW; \\\n      stop = TRUE; \\\n      break; \\\n    } \\\n\n\n#define pop(x)  x = stack[--sp]\n\n#define is_undef(x) IS_UNDEFINED((x).i)\n\n#define ensure_defined(x) \\\n    if (is_undef(x)) \\\n    { \\\n      r1.i = UNDEFINED; \\\n      push(r1); \\\n      break; \\\n    }\n\n\n#define little_endian_uint8_t(x)     (x)\n#define little_endian_int8_t(x)      (x)\n#define little_endian_uint16_t(x)    yr_le16toh(x)\n#define little_endian_int16_t(x)     yr_le16toh(x)\n#define little_endian_uint32_t(x)    yr_le32toh(x)\n#define little_endian_int32_t(x)     yr_le32toh(x)\n\n#define big_endian_uint8_t(x)        (x)\n#define big_endian_int8_t(x)         (x)\n#define big_endian_uint16_t(x)       yr_be16toh(x)\n#define big_endian_int16_t(x)        yr_be16toh(x)\n#define big_endian_uint32_t(x)       yr_be32toh(x)\n#define big_endian_int32_t(x)        yr_be32toh(x)\n\n\n#define function_read(type, endianess) \\\n    int64_t read_##type##_##endianess(YR_MEMORY_BLOCK_ITERATOR* iterator, size_t offset) \\\n    { \\\n      YR_MEMORY_BLOCK* block = iterator->first(iterator); \\\n      while (block != NULL) \\\n      { \\\n        if (offset >= block->base && \\\n            block->size >= sizeof(type) && \\\n            offset <= block->base + block->size - sizeof(type)) \\\n        { \\\n          type result; \\\n          uint8_t* data = block->fetch_data(block); \\\n          if (data == NULL) \\\n            return UNDEFINED; \\\n          result = *(type *)(data + offset - block->base); \\\n          result = endianess##_##type(result); \\\n          return result; \\\n        } \\\n        block = iterator->next(iterator); \\\n      } \\\n      return UNDEFINED; \\\n    };\n\n\nfunction_read(uint8_t, little_endian)\nfunction_read(uint16_t, little_endian)\nfunction_read(uint32_t, little_endian)\nfunction_read(int8_t, little_endian)\nfunction_read(int16_t, little_endian)\nfunction_read(int32_t, little_endian)\nfunction_read(uint8_t, big_endian)\nfunction_read(uint16_t, big_endian)\nfunction_read(uint32_t, big_endian)\nfunction_read(int8_t, big_endian)\nfunction_read(int16_t, big_endian)\nfunction_read(int32_t, big_endian)\n\n\nstatic uint8_t* jmp_if(\n    int condition,\n    uint8_t* ip)\n{\n  uint8_t* result;\n\n  if (condition)\n  {\n    result = *(uint8_t**)(ip + 1);\n\n    // ip will be incremented at the end of the execution loop,\n    // decrement it here to compensate.\n\n    result--;\n  }\n  else\n  {\n    result = ip + sizeof(uint64_t);\n  }\n\n  return result;\n}\n\n\nint yr_execute_code(\n    YR_RULES* rules,\n    YR_SCAN_CONTEXT* context,\n    int timeout,\n    time_t start_time)\n{\n  int64_t mem[MEM_SIZE];\n  int32_t sp = 0;\n  uint8_t* ip = rules->code_start;\n\n  YR_VALUE args[MAX_FUNCTION_ARGS];\n  YR_VALUE *stack;\n  YR_VALUE r1;\n  YR_VALUE r2;\n  YR_VALUE r3;\n\n  #ifdef PROFILING_ENABLED\n  YR_RULE* current_rule = NULL;\n  #endif\n\n  YR_RULE* rule;\n  YR_MATCH* match;\n  YR_OBJECT_FUNCTION* function;\n\n  char* identifier;\n  char* args_fmt;\n\n  int i;\n  int found;\n  int count;\n  int result = ERROR_SUCCESS;\n  int stop = FALSE;\n  int cycle = 0;\n  int tidx = context->tidx;\n  int stack_size;\n\n  #ifdef PROFILING_ENABLED\n  clock_t start = clock();\n  #endif\n\n  yr_get_configuration(YR_CONFIG_STACK_SIZE, (void*) &stack_size);\n\n  stack = (YR_VALUE*) yr_malloc(stack_size * sizeof(YR_VALUE));\n\n  if (stack == NULL)\n    return ERROR_INSUFFICIENT_MEMORY;\n\n  while(!stop)\n  {\n    switch(*ip)\n    {\n      case OP_NOP:\n        break;\n        \n      case OP_HALT:\n        assert(sp == 0); // When HALT is reached the stack should be empty.\n        stop = TRUE;\n        break;\n\n      case OP_PUSH:\n        r1.i = *(uint64_t*)(ip + 1);\n        ip += sizeof(uint64_t);\n        push(r1);\n        break;\n\n      case OP_POP:\n        pop(r1);\n        break;\n\n      case OP_CLEAR_M:\n        r1.i = *(uint64_t*)(ip + 1);\n        ip += sizeof(uint64_t);\n        mem[r1.i] = 0;\n        break;\n\n      case OP_ADD_M:\n        r1.i = *(uint64_t*)(ip + 1);\n        ip += sizeof(uint64_t);\n        pop(r2);\n        if (!is_undef(r2))\n          mem[r1.i] += r2.i;\n        break;\n\n      case OP_INCR_M:\n        r1.i = *(uint64_t*)(ip + 1);\n        ip += sizeof(uint64_t);\n        mem[r1.i]++;\n        break;\n\n      case OP_PUSH_M:\n        r1.i = *(uint64_t*)(ip + 1);\n        ip += sizeof(uint64_t);\n        r1.i = mem[r1.i];\n        push(r1);\n        break;\n\n      case OP_POP_M:\n        r1.i = *(uint64_t*)(ip + 1);\n        ip += sizeof(uint64_t);\n        pop(r2);\n        mem[r1.i] = r2.i;\n        break;\n\n      case OP_SWAPUNDEF:\n        r1.i = *(uint64_t*)(ip + 1);\n        ip += sizeof(uint64_t);\n        pop(r2);\n\n        if (is_undef(r2))\n        {\n          r1.i = mem[r1.i];\n          push(r1);\n        }\n        else\n        {\n          push(r2);\n        }\n        break;\n\n      case OP_JNUNDEF:\n        pop(r1);\n        push(r1);\n\n        ip = jmp_if(!is_undef(r1), ip);\n        break;\n\n      case OP_JLE:\n        pop(r2);\n        pop(r1);\n        push(r1);\n        push(r2);\n\n        ip = jmp_if(r1.i <= r2.i, ip);\n        break;\n\n      case OP_JTRUE:\n        pop(r1);\n        push(r1);\n\n        ip = jmp_if(!is_undef(r1) && r1.i, ip);\n        break;\n\n      case OP_JFALSE:\n        pop(r1);\n        push(r1);\n\n        ip = jmp_if(is_undef(r1) || !r1.i, ip);\n        break;\n\n      case OP_AND:\n        pop(r2);\n        pop(r1);\n\n        if (is_undef(r1) || is_undef(r2))\n          r1.i = 0;\n        else\n          r1.i = r1.i && r2.i;\n\n        push(r1);\n        break;\n\n      case OP_OR:\n        pop(r2);\n        pop(r1);\n\n        if (is_undef(r1))\n        {\n          push(r2);\n        }\n        else if (is_undef(r2))\n        {\n          push(r1);\n        }\n        else\n        {\n          r1.i = r1.i || r2.i;\n          push(r1);\n        }\n        break;\n\n      case OP_NOT:\n        pop(r1);\n\n        if (is_undef(r1))\n          r1.i = UNDEFINED;\n        else\n          r1.i= !r1.i;\n\n        push(r1);\n        break;\n\n      case OP_MOD:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        if (r2.i != 0)\n          r1.i = r1.i % r2.i;\n        else\n          r1.i = UNDEFINED;\n        push(r1);\n        break;\n\n      case OP_SHR:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i >> r2.i;\n        push(r1);\n        break;\n\n      case OP_SHL:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i << r2.i;\n        push(r1);\n        break;\n\n      case OP_BITWISE_NOT:\n        pop(r1);\n        ensure_defined(r1);\n        r1.i = ~r1.i;\n        push(r1);\n        break;\n\n      case OP_BITWISE_AND:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i & r2.i;\n        push(r1);\n        break;\n\n      case OP_BITWISE_OR:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i | r2.i;\n        push(r1);\n        break;\n\n      case OP_BITWISE_XOR:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i ^ r2.i;\n        push(r1);\n        break;\n\n      case OP_PUSH_RULE:\n        rule = *(YR_RULE**)(ip + 1);\n        ip += sizeof(uint64_t);\n        r1.i = rule->t_flags[tidx] & RULE_TFLAGS_MATCH ? 1 : 0;\n        push(r1);\n        break;\n\n      case OP_INIT_RULE:\n        #ifdef PROFILING_ENABLED\n        current_rule = *(YR_RULE**)(ip + 1);\n        #endif\n        ip += sizeof(uint64_t);\n        break;\n\n      case OP_MATCH_RULE:\n        pop(r1);\n        rule = *(YR_RULE**)(ip + 1);\n        ip += sizeof(uint64_t);\n\n        if (!is_undef(r1) && r1.i)\n          rule->t_flags[tidx] |= RULE_TFLAGS_MATCH;\n        else if (RULE_IS_GLOBAL(rule))\n          rule->ns->t_flags[tidx] |= NAMESPACE_TFLAGS_UNSATISFIED_GLOBAL;\n\n        #ifdef PROFILING_ENABLED\n        rule->clock_ticks += clock() - start;\n        start = clock();\n        #endif\n        break;\n\n      case OP_OBJ_LOAD:\n        identifier = *(char**)(ip + 1);\n        ip += sizeof(uint64_t);\n\n        r1.o = (YR_OBJECT*) yr_hash_table_lookup(\n            context->objects_table,\n            identifier,\n            NULL);\n\n        assert(r1.o != NULL);\n        push(r1);\n        break;\n\n      case OP_OBJ_FIELD:\n        identifier = *(char**)(ip + 1);\n        ip += sizeof(uint64_t);\n\n        pop(r1);\n        ensure_defined(r1);\n\n        r1.o = yr_object_lookup_field(r1.o, identifier);\n\n        assert(r1.o != NULL);\n        push(r1);\n        break;\n\n      case OP_OBJ_VALUE:\n        pop(r1);\n        ensure_defined(r1);\n\n        switch(r1.o->type)\n        {\n          case OBJECT_TYPE_INTEGER:\n            r1.i = ((YR_OBJECT_INTEGER*) r1.o)->value;\n            break;\n\n          case OBJECT_TYPE_FLOAT:\n            if (isnan(((YR_OBJECT_DOUBLE*) r1.o)->value))\n              r1.i = UNDEFINED;\n            else\n              r1.d = ((YR_OBJECT_DOUBLE*) r1.o)->value;\n            break;\n\n          case OBJECT_TYPE_STRING:\n            if (((YR_OBJECT_STRING*) r1.o)->value == NULL)\n              r1.i = UNDEFINED;\n            else\n              r1.p = ((YR_OBJECT_STRING*) r1.o)->value;\n            break;\n\n          default:\n            assert(FALSE);\n        }\n\n        push(r1);\n        break;\n\n      case OP_INDEX_ARRAY:\n        pop(r1);  // index\n        pop(r2);  // array\n\n        ensure_defined(r1);\n        ensure_defined(r2);\n        assert(r2.o->type == OBJECT_TYPE_ARRAY);\n\n        r1.o = yr_object_array_get_item(r2.o, 0, (int) r1.i);\n\n        if (r1.o == NULL)\n          r1.i = UNDEFINED;\n\n        push(r1);\n        break;\n\n      case OP_LOOKUP_DICT:\n        pop(r1);  // key\n        pop(r2);  // dictionary\n\n        ensure_defined(r1);\n        ensure_defined(r2);\n        assert(r2.o->type == OBJECT_TYPE_DICTIONARY);\n\n        r1.o = yr_object_dict_get_item(\n            r2.o, 0, r1.ss->c_string);\n\n        if (r1.o == NULL)\n          r1.i = UNDEFINED;\n\n        push(r1);\n        break;\n\n      case OP_CALL:\n        args_fmt = *(char**)(ip + 1);\n        ip += sizeof(uint64_t);\n\n        i = (int) strlen(args_fmt);\n        count = 0;\n\n        // pop arguments from stack and copy them to args array\n\n        while (i > 0)\n        {\n          pop(r1);\n\n          if (is_undef(r1))  // count the number of undefined args\n            count++;\n\n          args[i - 1] = r1;\n          i--;\n        }\n\n        pop(r2);\n        ensure_defined(r2);\n\n        if (count > 0)\n        {\n          // if there are undefined args, result for function call\n          // is undefined as well.\n\n          r1.i = UNDEFINED;\n          push(r1);\n          break;\n        }\n\n        function = (YR_OBJECT_FUNCTION*) r2.o;\n        result = ERROR_INTERNAL_FATAL_ERROR;\n\n        for (i = 0; i < MAX_OVERLOADED_FUNCTIONS; i++)\n        {\n          if (function->prototypes[i].arguments_fmt == NULL)\n            break;\n\n          if (strcmp(function->prototypes[i].arguments_fmt, args_fmt) == 0)\n          {\n            result = function->prototypes[i].code(args, context, function);\n            break;\n          }\n        }\n\n        assert(i < MAX_OVERLOADED_FUNCTIONS);\n\n        if (result == ERROR_SUCCESS)\n        {\n          r1.o = function->return_obj;\n          push(r1);\n        }\n        else\n        {\n          stop = TRUE;\n        }\n\n        break;\n\n      case OP_FOUND:\n        pop(r1);\n        r1.i = r1.s->matches[tidx].tail != NULL ? 1 : 0;\n        push(r1);\n        break;\n\n      case OP_FOUND_AT:\n        pop(r2);\n        pop(r1);\n\n        if (is_undef(r1))\n        {\n          r1.i = 0;\n          push(r1);\n          break;\n        }\n\n        match = r2.s->matches[tidx].head;\n        r3.i = FALSE;\n\n        while (match != NULL)\n        {\n          if (r1.i == match->base + match->offset)\n          {\n            r3.i = TRUE;\n            break;\n          }\n\n          if (r1.i < match->base + match->offset)\n            break;\n\n          match = match->next;\n        }\n\n        push(r3);\n        break;\n\n      case OP_FOUND_IN:\n        pop(r3);\n        pop(r2);\n        pop(r1);\n\n        ensure_defined(r1);\n        ensure_defined(r2);\n\n        match = r3.s->matches[tidx].head;\n        r3.i = FALSE;\n\n        while (match != NULL && !r3.i)\n        {\n          if (match->base + match->offset >= r1.i &&\n              match->base + match->offset <= r2.i)\n          {\n            r3.i = TRUE;\n          }\n\n          if (match->base + match->offset > r2.i)\n            break;\n\n          match = match->next;\n        }\n\n        push(r3);\n        break;\n\n      case OP_COUNT:\n        pop(r1);\n        r1.i = r1.s->matches[tidx].count;\n        push(r1);\n        break;\n\n      case OP_OFFSET:\n        pop(r2);\n        pop(r1);\n\n        ensure_defined(r1);\n\n        match = r2.s->matches[tidx].head;\n        i = 1;\n        r3.i = UNDEFINED;\n\n        while (match != NULL && r3.i == UNDEFINED)\n        {\n          if (r1.i == i)\n            r3.i = match->base + match->offset;\n\n          i++;\n          match = match->next;\n        }\n\n        push(r3);\n        break;\n\n      case OP_LENGTH:\n        pop(r2);\n        pop(r1);\n\n        ensure_defined(r1);\n\n        match = r2.s->matches[tidx].head;\n        i = 1;\n        r3.i = UNDEFINED;\n\n        while (match != NULL && r3.i == UNDEFINED)\n        {\n          if (r1.i == i)\n            r3.i = match->match_length;\n\n          i++;\n          match = match->next;\n        }\n\n        push(r3);\n        break;\n\n      case OP_OF:\n        found = 0;\n        count = 0;\n        pop(r1);\n\n        while (!is_undef(r1))\n        {\n          if (r1.s->matches[tidx].tail != NULL)\n            found++;\n          count++;\n          pop(r1);\n        }\n\n        pop(r2);\n\n        if (is_undef(r2))\n          r1.i = found >= count ? 1 : 0;\n        else\n          r1.i = found >= r2.i ? 1 : 0;\n\n        push(r1);\n        break;\n\n      case OP_FILESIZE:\n        r1.i = context->file_size;\n        push(r1);\n        break;\n\n      case OP_ENTRYPOINT:\n        r1.i = context->entry_point;\n        push(r1);\n        break;\n\n      case OP_INT8:\n        pop(r1);\n        r1.i = read_int8_t_little_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_INT16:\n        pop(r1);\n        r1.i = read_int16_t_little_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_INT32:\n        pop(r1);\n        r1.i = read_int32_t_little_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_UINT8:\n        pop(r1);\n        r1.i = read_uint8_t_little_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_UINT16:\n        pop(r1);\n        r1.i = read_uint16_t_little_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_UINT32:\n        pop(r1);\n        r1.i = read_uint32_t_little_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_INT8BE:\n        pop(r1);\n        r1.i = read_int8_t_big_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_INT16BE:\n        pop(r1);\n        r1.i = read_int16_t_big_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_INT32BE:\n        pop(r1);\n        r1.i = read_int32_t_big_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_UINT8BE:\n        pop(r1);\n        r1.i = read_uint8_t_big_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_UINT16BE:\n        pop(r1);\n        r1.i = read_uint16_t_big_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_UINT32BE:\n        pop(r1);\n        r1.i = read_uint32_t_big_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_CONTAINS:\n        pop(r2);\n        pop(r1);\n\n        ensure_defined(r1);\n        ensure_defined(r2);\n\n        r1.i = memmem(r1.ss->c_string, r1.ss->length,\n                      r2.ss->c_string, r2.ss->length) != NULL;\n        push(r1);\n        break;\n\n      case OP_IMPORT:\n        r1.i = *(uint64_t*)(ip + 1);\n        ip += sizeof(uint64_t);\n\n        result = yr_modules_load((char*) r1.p, context);\n\n        if (result != ERROR_SUCCESS)\n          stop = TRUE;\n\n        break;\n\n      case OP_MATCHES:\n\n        pop(r2);\n        pop(r1);\n\n        ensure_defined(r2);\n        ensure_defined(r1);\n\n        if (r1.ss->length == 0)\n        {\n          r1.i = FALSE;\n          push(r1);\n          break;\n        }\n\n        result = yr_re_exec(\n          (uint8_t*) r2.re->code,\n          (uint8_t*) r1.ss->c_string,\n          r1.ss->length,\n          0,\n          r2.re->flags | RE_FLAGS_SCAN,\n          NULL,\n          NULL,\n          &found);\n\n        if (result != ERROR_SUCCESS)\n          stop = TRUE;\n\n        r1.i = found >= 0;\n        push(r1);\n        break;\n\n      case OP_INT_TO_DBL:\n        r1.i = *(uint64_t*)(ip + 1);\n        ip += sizeof(uint64_t);\n        r2 = stack[sp - r1.i];\n        if (is_undef(r2))\n          stack[sp - r1.i].i = UNDEFINED;\n        else\n          stack[sp - r1.i].d = (double) r2.i;\n        break;\n\n      case OP_STR_TO_BOOL:\n        pop(r1);\n        ensure_defined(r1);\n        r1.i = r1.ss->length > 0;\n        push(r1);\n        break;\n\n      case OP_INT_EQ:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i == r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_NEQ:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i != r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_LT:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i < r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_GT:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i > r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_LE:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i <= r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_GE:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i >= r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_ADD:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i + r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_SUB:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i - r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_MUL:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i * r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_DIV:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        if (r2.i != 0)\n          r1.i = r1.i / r2.i;\n        else\n          r1.i = UNDEFINED;\n        push(r1);\n        break;\n\n      case OP_INT_MINUS:\n        pop(r1);\n        ensure_defined(r1);\n        r1.i = -r1.i;\n        push(r1);\n        break;\n\n      case OP_DBL_LT:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.d < r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_GT:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.d > r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_LE:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.d <= r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_GE:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.d >= r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_EQ:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.d == r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_NEQ:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.d != r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_ADD:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.d = r1.d + r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_SUB:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.d = r1.d - r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_MUL:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.d = r1.d * r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_DIV:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.d = r1.d / r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_MINUS:\n        pop(r1);\n        ensure_defined(r1);\n        r1.d = -r1.d;\n        push(r1);\n        break;\n\n      case OP_STR_EQ:\n      case OP_STR_NEQ:\n      case OP_STR_LT:\n      case OP_STR_LE:\n      case OP_STR_GT:\n      case OP_STR_GE:\n\n        pop(r2);\n        pop(r1);\n\n        ensure_defined(r1);\n        ensure_defined(r2);\n\n        switch(*ip)\n        {\n          case OP_STR_EQ:\n            r1.i = (sized_string_cmp(r1.ss, r2.ss) == 0);\n            break;\n          case OP_STR_NEQ:\n            r1.i = (sized_string_cmp(r1.ss, r2.ss) != 0);\n            break;\n          case OP_STR_LT:\n            r1.i = (sized_string_cmp(r1.ss, r2.ss) < 0);\n            break;\n          case OP_STR_LE:\n            r1.i = (sized_string_cmp(r1.ss, r2.ss) <= 0);\n            break;\n          case OP_STR_GT:\n            r1.i = (sized_string_cmp(r1.ss, r2.ss) > 0);\n            break;\n          case OP_STR_GE:\n            r1.i = (sized_string_cmp(r1.ss, r2.ss) >= 0);\n            break;\n        }\n\n        push(r1);\n        break;\n\n      default:\n        // Unknown instruction, this shouldn't happen.\n        assert(FALSE);\n    }\n\n    if (timeout > 0)  // timeout == 0 means no timeout\n    {\n      // Check for timeout every 10 instruction cycles.\n\n      if (++cycle == 10)\n      {\n        if (difftime(time(NULL), start_time) > timeout)\n        {\n          #ifdef PROFILING_ENABLED\n          assert(current_rule != NULL);\n          current_rule->clock_ticks += clock() - start;\n          #endif\n          result = ERROR_SCAN_TIMEOUT;\n          stop = TRUE;\n        }\n\n        cycle = 0;\n      }\n    }\n\n    ip++;\n  }\n\n  yr_modules_unload_all(context);\n  yr_free(stack);\n\n  return result;\n}\n", "/*\nCopyright (c) 2014. The YARA Authors. All Rights Reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\nlist of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#ifndef YR_OBJECT_H\n#define YR_OBJECT_H\n\n#ifdef _MSC_VER\n\n#include <float.h>\n#ifndef isnan\n#define isnan _isnan\n#endif\n\n#ifndef INFINITY\n#define INFINITY (DBL_MAX + DBL_MAX)\n#endif\n\n#ifndef NAN\n#define NAN (INFINITY-INFINITY)\n#endif\n\n#endif\n\n#include <yara/types.h>\n\n\n#define OBJECT_CREATE           1\n\n#define OBJECT_TYPE_INTEGER     1\n#define OBJECT_TYPE_STRING      2\n#define OBJECT_TYPE_STRUCTURE   3\n#define OBJECT_TYPE_ARRAY       4\n#define OBJECT_TYPE_FUNCTION    5\n#define OBJECT_TYPE_DICTIONARY  6\n#define OBJECT_TYPE_FLOAT       7\n\n\nint yr_object_create(\n    int8_t type,\n    const char* identifier,\n    YR_OBJECT* parent,\n    YR_OBJECT** object);\n\n\nint yr_object_function_create(\n    const char* identifier,\n    const char* arguments_fmt,\n    const char* return_fmt,\n    YR_MODULE_FUNC func,\n    YR_OBJECT* parent,\n    YR_OBJECT** function);\n\n\nint yr_object_from_external_variable(\n    YR_EXTERNAL_VARIABLE* external,\n    YR_OBJECT** object);\n\n\nvoid yr_object_destroy(\n    YR_OBJECT* object);\n\n\nYR_OBJECT* yr_object_lookup_field(\n    YR_OBJECT* object,\n    const char* field_name);\n\n\nYR_OBJECT* yr_object_lookup(\n    YR_OBJECT* root,\n    int flags,\n    const char* pattern,\n    ...);\n\n\nint yr_object_has_undefined_value(\n    YR_OBJECT* object,\n    const char* field,\n    ...);\n\nint64_t yr_object_get_integer(\n    YR_OBJECT* object,\n    const char* field,\n    ...);\n\n\nSIZED_STRING* yr_object_get_string(\n    YR_OBJECT* object,\n    const char* field,\n    ...);\n\n\nint yr_object_set_integer(\n    int64_t value,\n    YR_OBJECT* object,\n    const char* field,\n    ...);\n\n\nint yr_object_set_float(\n    double value,\n    YR_OBJECT* object,\n    const char* field,\n    ...);\n\n\nint yr_object_set_string(\n    const char* value,\n    size_t len,\n    YR_OBJECT* object,\n    const char* field,\n    ...);\n\n\nYR_OBJECT* yr_object_array_get_item(\n    YR_OBJECT* object,\n    int flags,\n    int index);\n\n\nint yr_object_array_set_item(\n    YR_OBJECT* object,\n    YR_OBJECT* item,\n    int index);\n\n\nYR_OBJECT* yr_object_dict_get_item(\n    YR_OBJECT* object,\n    int flags,\n    const char* key);\n\n\nint yr_object_dict_set_item(\n    YR_OBJECT* object,\n    YR_OBJECT* item,\n    const char* key);\n\n\nint yr_object_structure_set_member(\n    YR_OBJECT* object,\n    YR_OBJECT* member);\n\n\nYR_OBJECT* yr_object_get_root(\n    YR_OBJECT* object);\n\n\nYR_API void yr_object_print_data(\n    YR_OBJECT* object,\n    int indent,\n    int print_identifier);\n\n\n#endif\n", "/*\nCopyright (c) 2007-2014. The YARA Authors. All Rights Reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\nlist of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#ifndef _SIZEDSTR_H\n#define _SIZEDSTR_H\n\n#include <stddef.h>\n\n#include <yara/integers.h>\n\n//\n// This struct is used to support strings containing null chars. The length of\n// the string is stored along the string data. However the string data is also\n// terminated with a null char.\n//\n\n#define SIZED_STRING_FLAGS_NO_CASE  1\n#define SIZED_STRING_FLAGS_DOT_ALL  2\n\n#pragma pack(push)\n#pragma pack(8)\n\n\ntypedef struct _SIZED_STRING\n{\n  uint32_t length;\n  uint32_t flags;\n  \n  char c_string[1];\n\n} SIZED_STRING;\n\n#pragma pack(pop)\n\n\nint sized_string_cmp(\n  SIZED_STRING* s1,\n  SIZED_STRING* s2);\n\n#endif\n", "/*\nCopyright (c) 2014. The YARA Authors. All Rights Reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\nlist of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#include <yara/modules.h>\n\n#define MODULE_NAME tests\n\n\ndefine_function(fsum_2)\n{\n  double a = float_argument(1);\n  double b = float_argument(2);\n\n  return_float(a + b);\n}\n\ndefine_function(fsum_3)\n{\n  double a = float_argument(1);\n  double b = float_argument(2);\n  double c = float_argument(3);\n\n  return_float(a + b + c);\n}\n\ndefine_function(isum_2)\n{\n  int64_t a = integer_argument(1);\n  int64_t b = integer_argument(2);\n\n  return_integer(a + b);\n}\n\n\ndefine_function(isum_3)\n{\n  int64_t a = integer_argument(1);\n  int64_t b = integer_argument(2);\n  int64_t c = integer_argument(3);\n\n  return_integer(a + b + c);\n}\n\n\ndefine_function(length)\n{\n  char* s = string_argument(1);\n\n  return_integer(strlen(s));\n}\n\n\ndefine_function(empty)\n{\n  return_string(\"\");\n}\n\n\ndefine_function(match)\n{\n  return_integer(yr_re_match(regexp_argument(1), string_argument(2)));\n}\n\n\nbegin_declarations;\n\n  begin_struct(\"constants\");\n    declare_integer(\"one\");\n    declare_integer(\"two\");\n    declare_string(\"foo\");\n    declare_string(\"empty\");\n  end_struct(\"constants\");\n\n  begin_struct(\"undefined\");\n    declare_integer(\"i\");\n    declare_float(\"f\");\n  end_struct(\"undefined\");\n\n  declare_integer_array(\"integer_array\");\n  declare_string_array(\"string_array\");\n\n  declare_integer_dictionary(\"integer_dict\");\n  declare_string_dictionary(\"string_dict\");\n\n  begin_struct_array(\"struct_array\");\n    declare_integer(\"i\");\n    declare_string(\"s\");\n  end_struct_array(\"struct_array\");\n\n  begin_struct_dictionary(\"struct_dict\");\n    declare_integer(\"i\");\n    declare_string(\"s\");\n  end_struct_dictionary(\"struct_dict\");\n\n  declare_function(\"match\", \"rs\", \"i\", match);\n  declare_function(\"isum\", \"ii\", \"i\", isum_2);\n  declare_function(\"isum\", \"iii\", \"i\", isum_3);\n  declare_function(\"fsum\", \"ff\", \"f\", fsum_2);\n  declare_function(\"fsum\", \"fff\", \"f\", fsum_3);\n  declare_function(\"length\", \"s\", \"i\", length);\n  declare_function(\"empty\", \"\", \"s\", empty);\n\nend_declarations;\n\n\nint module_initialize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}\n\n\nint module_finalize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}\n\nint module_load(\n    YR_SCAN_CONTEXT* context,\n    YR_OBJECT* module_object,\n    void* module_data,\n    size_t module_data_size)\n{\n  set_integer(1, module_object, \"constants.one\");\n  set_integer(2, module_object, \"constants.two\");\n  set_string(\"foo\", module_object, \"constants.foo\");\n  set_string(\"\", module_object, \"constants.empty\");\n\n  set_integer(1, module_object, \"struct_array[1].i\");\n\n  set_integer(0, module_object, \"integer_array[%i]\", 0);\n  set_integer(1, module_object, \"integer_array[%i]\", 1);\n  set_integer(2, module_object, \"integer_array[%i]\", 2);\n\n  set_string(\"foo\", module_object, \"string_array[%i]\", 0);\n  set_string(\"bar\", module_object, \"string_array[%i]\", 1);\n  set_string(\"baz\", module_object, \"string_array[%i]\", 2);\n\n  set_sized_string(\"foo\\0bar\", 7, module_object, \"string_array[%i]\", 3);\n\n  set_string(\"foo\", module_object, \"string_dict[%s]\", \"foo\");\n  set_string(\"bar\", module_object, \"string_dict[\\\"bar\\\"]\");\n\n  set_string(\"foo\", module_object, \"struct_dict[%s].s\", \"foo\");\n  set_integer(1, module_object, \"struct_dict[%s].i\", \"foo\");\n\n  return ERROR_SUCCESS;\n}\n\n\nint module_unload(\n    YR_OBJECT* module_object)\n{\n  return ERROR_SUCCESS;\n}\n", "/*\nCopyright (c) 2014. The YARA Authors. All Rights Reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\nlist of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\n#include <assert.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#if _WIN32 || __CYGWIN__\n#define PRIu64 \"I64d\"\n#else\n#include <inttypes.h>\n#endif\n\n#include <yara/mem.h>\n#include <yara/error.h>\n#include <yara/object.h>\n#include <yara/exec.h>\n#include <yara/utils.h>\n\n\nint yr_object_create(\n    int8_t type,\n    const char* identifier,\n    YR_OBJECT* parent,\n    YR_OBJECT** object)\n{\n  YR_OBJECT* obj;\n  int i;\n  size_t object_size = 0;\n\n  assert(parent != NULL || object != NULL);\n\n  switch (type)\n  {\n    case OBJECT_TYPE_STRUCTURE:\n      object_size = sizeof(YR_OBJECT_STRUCTURE);\n      break;\n    case OBJECT_TYPE_ARRAY:\n      object_size = sizeof(YR_OBJECT_ARRAY);\n      break;\n    case OBJECT_TYPE_DICTIONARY:\n      object_size = sizeof(YR_OBJECT_DICTIONARY);\n      break;\n    case OBJECT_TYPE_INTEGER:\n      object_size = sizeof(YR_OBJECT_INTEGER);\n      break;\n    case OBJECT_TYPE_FLOAT:\n      object_size = sizeof(YR_OBJECT_DOUBLE);\n      break;\n    case OBJECT_TYPE_STRING:\n      object_size = sizeof(YR_OBJECT_STRING);\n      break;\n    case OBJECT_TYPE_FUNCTION:\n      object_size = sizeof(YR_OBJECT_FUNCTION);\n      break;\n    default:\n      assert(FALSE);\n  }\n\n  obj = (YR_OBJECT*) yr_malloc(object_size);\n\n  if (obj == NULL)\n    return ERROR_INSUFFICIENT_MEMORY;\n\n  obj->type = type;\n  obj->identifier = yr_strdup(identifier);\n  obj->parent = parent;\n  obj->data = NULL;\n\n  switch(type)\n  {\n    case OBJECT_TYPE_STRUCTURE:\n      ((YR_OBJECT_STRUCTURE*) obj)->members = NULL;\n      break;\n    case OBJECT_TYPE_ARRAY:\n      ((YR_OBJECT_ARRAY*) obj)->items = NULL;\n      ((YR_OBJECT_ARRAY*) obj)->prototype_item = NULL;\n      break;\n    case OBJECT_TYPE_DICTIONARY:\n      ((YR_OBJECT_DICTIONARY*) obj)->items = NULL;\n      ((YR_OBJECT_DICTIONARY*) obj)->prototype_item = NULL;\n      break;\n    case OBJECT_TYPE_INTEGER:\n      ((YR_OBJECT_INTEGER*) obj)->value = UNDEFINED;\n      break;\n    case OBJECT_TYPE_FLOAT:\n      ((YR_OBJECT_DOUBLE*) obj)->value = NAN;\n      break;\n    case OBJECT_TYPE_STRING:\n      ((YR_OBJECT_STRING*) obj)->value = NULL;\n      break;\n    case OBJECT_TYPE_FUNCTION:\n      ((YR_OBJECT_FUNCTION*) obj)->return_obj = NULL;\n      for (i = 0; i < MAX_OVERLOADED_FUNCTIONS; i++)\n      {\n        ((YR_OBJECT_FUNCTION*) obj)->prototypes[i].arguments_fmt = NULL;\n        ((YR_OBJECT_FUNCTION*) obj)->prototypes[i].code = NULL;\n      }\n      break;\n  }\n\n  if (obj->identifier == NULL)\n  {\n    yr_free(obj);\n    return ERROR_INSUFFICIENT_MEMORY;\n  }\n\n  if (parent != NULL)\n  {\n    assert(parent->type == OBJECT_TYPE_STRUCTURE ||\n           parent->type == OBJECT_TYPE_ARRAY ||\n           parent->type == OBJECT_TYPE_DICTIONARY ||\n           parent->type == OBJECT_TYPE_FUNCTION);\n\n    switch(parent->type)\n    {\n      case OBJECT_TYPE_STRUCTURE:\n        FAIL_ON_ERROR_WITH_CLEANUP(\n            yr_object_structure_set_member(parent, obj),\n            {\n              yr_free((void*) obj->identifier);\n              yr_free(obj);\n            });\n        break;\n\n      case OBJECT_TYPE_ARRAY:\n        ((YR_OBJECT_ARRAY*) parent)->prototype_item = obj;\n        break;\n\n      case OBJECT_TYPE_DICTIONARY:\n        ((YR_OBJECT_DICTIONARY*) parent)->prototype_item = obj;\n        break;\n\n      case OBJECT_TYPE_FUNCTION:\n        ((YR_OBJECT_FUNCTION*) parent)->return_obj = obj;\n        break;\n    }\n  }\n\n  if (object != NULL)\n    *object = obj;\n\n  return ERROR_SUCCESS;\n}\n\n\nint yr_object_function_create(\n    const char* identifier,\n    const char* arguments_fmt,\n    const char* return_fmt,\n    YR_MODULE_FUNC code,\n    YR_OBJECT* parent,\n    YR_OBJECT** function)\n{\n  YR_OBJECT* return_obj;\n  YR_OBJECT* o = NULL;\n  YR_OBJECT_FUNCTION* f = NULL;\n\n  int8_t return_type;\n  int i;\n\n  switch (*return_fmt)\n  {\n    case 'i':\n      return_type = OBJECT_TYPE_INTEGER;\n      break;\n    case 's':\n      return_type = OBJECT_TYPE_STRING;\n      break;\n    case 'f':\n      return_type = OBJECT_TYPE_FLOAT;\n      break;\n    default:\n      return ERROR_INVALID_FORMAT;\n  }\n\n  if (parent != NULL)\n  {\n    // The parent of a function must be a structure.\n\n    assert(parent->type == OBJECT_TYPE_STRUCTURE);\n\n    // Try to find if the structure already has a function\n    // with that name. In that case this is a function overload.\n\n    f = (YR_OBJECT_FUNCTION*) yr_object_lookup_field(parent, identifier);\n\n    // Overloaded functions must have the same return type.\n\n    if (f != NULL && return_type != f->return_obj->type)\n      return ERROR_WRONG_RETURN_TYPE;\n  }\n\n  if (f == NULL) // Function doesn't exist yet\n  {\n    FAIL_ON_ERROR(\n        yr_object_create(\n            OBJECT_TYPE_FUNCTION,\n            identifier,\n            parent,\n            &o));\n\n    FAIL_ON_ERROR_WITH_CLEANUP(\n        yr_object_create(\n            return_type,\n            \"result\",\n            o,\n            &return_obj),\n        yr_object_destroy(o));\n\n    f = (YR_OBJECT_FUNCTION*) o;\n  }\n\n  for (i = 0; i < MAX_OVERLOADED_FUNCTIONS; i++)\n  {\n    if (f->prototypes[i].arguments_fmt == NULL)\n    {\n      f->prototypes[i].arguments_fmt = arguments_fmt;\n      f->prototypes[i].code = code;\n\n      break;\n    }\n  }\n\n  if (function != NULL)\n    *function = (YR_OBJECT*) f;\n\n  return ERROR_SUCCESS;\n}\n\n\nint yr_object_from_external_variable(\n    YR_EXTERNAL_VARIABLE* external,\n    YR_OBJECT** object)\n{\n  YR_OBJECT* obj;\n  int result;\n  uint8_t obj_type = 0;\n\n  switch(external->type)\n  {\n    case EXTERNAL_VARIABLE_TYPE_INTEGER:\n    case EXTERNAL_VARIABLE_TYPE_BOOLEAN:\n      obj_type = OBJECT_TYPE_INTEGER;\n      break;\n\n    case EXTERNAL_VARIABLE_TYPE_FLOAT:\n      obj_type = OBJECT_TYPE_FLOAT;\n      break;\n\n    case EXTERNAL_VARIABLE_TYPE_STRING:\n    case EXTERNAL_VARIABLE_TYPE_MALLOC_STRING:\n      obj_type = OBJECT_TYPE_STRING;\n      break;\n\n    default:\n      assert(FALSE);\n  }\n\n  result = yr_object_create(\n      obj_type,\n      external->identifier,\n      NULL,\n      &obj);\n\n  if (result == ERROR_SUCCESS)\n  {\n    switch(external->type)\n    {\n      case EXTERNAL_VARIABLE_TYPE_INTEGER:\n      case EXTERNAL_VARIABLE_TYPE_BOOLEAN:\n        yr_object_set_integer(external->value.i, obj, NULL);\n        break;\n\n      case EXTERNAL_VARIABLE_TYPE_FLOAT:\n        yr_object_set_float(external->value.f, obj, NULL);\n        break;\n\n      case EXTERNAL_VARIABLE_TYPE_STRING:\n      case EXTERNAL_VARIABLE_TYPE_MALLOC_STRING:\n        yr_object_set_string(\n            external->value.s, strlen(external->value.s), obj, NULL);\n        break;\n    }\n\n    *object = obj;\n  }\n\n  return result;\n}\n\n\nvoid yr_object_destroy(\n    YR_OBJECT* object)\n{\n  YR_STRUCTURE_MEMBER* member;\n  YR_STRUCTURE_MEMBER* next_member;\n  YR_ARRAY_ITEMS* array_items;\n  YR_DICTIONARY_ITEMS* dict_items;\n\n  SIZED_STRING* str;\n  int i;\n\n  if (object == NULL)\n    return;\n\n  switch(object->type)\n  {\n    case OBJECT_TYPE_STRUCTURE:\n      member = ((YR_OBJECT_STRUCTURE*) object)->members;\n\n      while (member != NULL)\n      {\n        next_member = member->next;\n        yr_object_destroy(member->object);\n        yr_free(member);\n        member = next_member;\n      }\n      break;\n\n    case OBJECT_TYPE_STRING:\n      str = ((YR_OBJECT_STRING*) object)->value;\n      if (str != NULL)\n        yr_free(str);\n      break;\n\n    case OBJECT_TYPE_ARRAY:\n      if (((YR_OBJECT_ARRAY*) object)->prototype_item != NULL)\n        yr_object_destroy(((YR_OBJECT_ARRAY*) object)->prototype_item);\n\n      array_items = ((YR_OBJECT_ARRAY*) object)->items;\n\n      if (array_items != NULL)\n      {\n        for (i = 0; i < array_items->count; i++)\n          if (array_items->objects[i] != NULL)\n            yr_object_destroy(array_items->objects[i]);\n      }\n\n      yr_free(array_items);\n      break;\n\n    case OBJECT_TYPE_DICTIONARY:\n      if (((YR_OBJECT_DICTIONARY*) object)->prototype_item != NULL)\n        yr_object_destroy(((YR_OBJECT_DICTIONARY*) object)->prototype_item);\n\n      dict_items = ((YR_OBJECT_DICTIONARY*) object)->items;\n\n      if (dict_items != NULL)\n      {\n        for (i = 0; i < dict_items->used; i++)\n        {\n          if (dict_items->objects[i].key != NULL)\n            yr_free(dict_items->objects[i].key);\n\n          if (dict_items->objects[i].obj != NULL)\n            yr_object_destroy(dict_items->objects[i].obj);\n        }\n      }\n\n      yr_free(dict_items);\n      break;\n\n    case OBJECT_TYPE_FUNCTION:\n      yr_object_destroy(((YR_OBJECT_FUNCTION*) object)->return_obj);\n      break;\n  }\n\n  yr_free((void*) object->identifier);\n  yr_free(object);\n}\n\n\nYR_OBJECT* yr_object_lookup_field(\n    YR_OBJECT* object,\n    const char* field_name)\n{\n  YR_STRUCTURE_MEMBER* member;\n\n  assert(object != NULL);\n  assert(object->type == OBJECT_TYPE_STRUCTURE);\n\n  member = ((YR_OBJECT_STRUCTURE*) object)->members;\n\n  while (member != NULL)\n  {\n    if (strcmp(member->object->identifier, field_name) == 0)\n      return member->object;\n\n    member = member->next;\n  }\n\n  return NULL;\n}\n\n\nYR_OBJECT* _yr_object_lookup(\n    YR_OBJECT* object,\n    int flags,\n    const char* pattern,\n    va_list args)\n{\n  YR_OBJECT* obj = object;\n\n  const char* p = pattern;\n  const char* key = NULL;\n\n  char str[256];\n\n  int i;\n  int index = -1;\n\n  while (obj != NULL)\n  {\n    i = 0;\n\n    while(*p != '\\0' && *p != '.' && *p != '[' && i < sizeof(str) - 1)\n    {\n      str[i++] = *p++;\n    }\n\n    str[i] = '\\0';\n\n    if (obj->type != OBJECT_TYPE_STRUCTURE)\n      return NULL;\n\n    obj = yr_object_lookup_field(obj, str);\n\n    if (obj == NULL)\n      return NULL;\n\n    if (*p == '[')\n    {\n      p++;\n\n      if (*p == '%')\n      {\n        p++;\n\n        switch(*p++)\n        {\n          case 'i':\n            index = va_arg(args, int);\n            break;\n          case 's':\n            key = va_arg(args, const char*);\n            break;\n\n          default:\n            return NULL;\n        }\n      }\n      else if (*p >= '0' && *p <= '9')\n      {\n        index = (int) strtol(p, (char**) &p, 10);\n      }\n      else if (*p == '\"')\n      {\n        i = 0;\n        p++;              // skip the opening quotation mark\n\n        while (*p != '\"' && *p != '\\0' && i < sizeof(str))\n          str[i++] = *p++;\n\n        str[i] = '\\0';\n        p++;              // skip the closing quotation mark\n        key = str;\n      }\n      else\n      {\n        return NULL;\n      }\n\n      assert(*p == ']');\n      p++;\n      assert(*p == '.' || *p == '\\0');\n\n      switch(obj->type)\n      {\n        case OBJECT_TYPE_ARRAY:\n          assert(index != -1);\n          obj = yr_object_array_get_item(obj, flags, index);\n          break;\n\n        case OBJECT_TYPE_DICTIONARY:\n          assert(key != NULL);\n          obj = yr_object_dict_get_item(obj, flags, key);\n          break;\n      }\n    }\n\n    if (*p == '\\0')\n      break;\n\n    p++;\n  }\n\n  return obj;\n}\n\n\nYR_OBJECT* yr_object_lookup(\n    YR_OBJECT* object,\n    int flags,\n    const char* pattern,\n    ...)\n{\n  YR_OBJECT* result;\n\n  va_list args;\n  va_start(args, pattern);\n\n  result = _yr_object_lookup(object, flags, pattern, args);\n\n  va_end(args);\n\n  return result;\n\n}\n\n\nint yr_object_copy(\n    YR_OBJECT* object,\n    YR_OBJECT** object_copy)\n{\n  YR_OBJECT* copy;\n  YR_OBJECT* o;\n\n  YR_STRUCTURE_MEMBER* structure_member;\n  YR_OBJECT_FUNCTION* func;\n  YR_OBJECT_FUNCTION* func_copy;\n\n  int i;\n\n  *object_copy = NULL;\n\n  FAIL_ON_ERROR(yr_object_create(\n      object->type,\n      object->identifier,\n      NULL,\n      &copy));\n\n  switch(object->type)\n  {\n    case OBJECT_TYPE_INTEGER:\n      ((YR_OBJECT_INTEGER*) copy)->value = UNDEFINED;\n      break;\n\n    case OBJECT_TYPE_STRING:\n      ((YR_OBJECT_STRING*) copy)->value = NULL;\n      break;\n\n    case OBJECT_TYPE_FUNCTION:\n\n      func = (YR_OBJECT_FUNCTION*) object;\n      func_copy = (YR_OBJECT_FUNCTION*) copy;\n\n      FAIL_ON_ERROR_WITH_CLEANUP(\n        yr_object_copy(func->return_obj, &func_copy->return_obj),\n        yr_object_destroy(copy));\n\n      for (i = 0; i < MAX_OVERLOADED_FUNCTIONS; i++)\n        func_copy->prototypes[i] = func->prototypes[i];\n\n      break;\n\n    case OBJECT_TYPE_STRUCTURE:\n\n      structure_member = ((YR_OBJECT_STRUCTURE*) object)->members;\n\n      while (structure_member != NULL)\n      {\n        FAIL_ON_ERROR_WITH_CLEANUP(\n            yr_object_copy(structure_member->object, &o),\n            yr_object_destroy(copy));\n\n        FAIL_ON_ERROR_WITH_CLEANUP(\n            yr_object_structure_set_member(copy, o),\n            yr_free(o);\n            yr_object_destroy(copy));\n\n        structure_member = structure_member->next;\n      }\n\n      break;\n\n    case OBJECT_TYPE_ARRAY:\n\n      yr_object_copy(\n        ((YR_OBJECT_ARRAY *) object)->prototype_item,\n        &o);\n\n      ((YR_OBJECT_ARRAY *)copy)->prototype_item = o;\n\n      break;\n\n    case OBJECT_TYPE_DICTIONARY:\n\n      yr_object_copy(\n        ((YR_OBJECT_DICTIONARY *) object)->prototype_item,\n        &o);\n\n      ((YR_OBJECT_DICTIONARY *)copy)->prototype_item = o;\n\n      break;\n\n    default:\n      assert(FALSE);\n\n  }\n\n  *object_copy = copy;\n\n  return ERROR_SUCCESS;\n}\n\n\nint yr_object_structure_set_member(\n    YR_OBJECT* object,\n    YR_OBJECT* member)\n{\n  YR_STRUCTURE_MEMBER* sm;\n\n  assert(object->type == OBJECT_TYPE_STRUCTURE);\n\n  // Check if the object already have a member with the same identifier\n\n  if (yr_object_lookup_field(object,  member->identifier) != NULL)\n    return ERROR_DUPLICATED_STRUCTURE_MEMBER;\n\n  sm = (YR_STRUCTURE_MEMBER*) yr_malloc(sizeof(YR_STRUCTURE_MEMBER));\n\n  if (sm == NULL)\n    return ERROR_INSUFFICIENT_MEMORY;\n\n  member->parent = object;\n  sm->object = member;\n  sm->next = ((YR_OBJECT_STRUCTURE*) object)->members;\n\n  ((YR_OBJECT_STRUCTURE*) object)->members = sm;\n\n  return ERROR_SUCCESS;\n}\n\n\nYR_OBJECT* yr_object_array_get_item(\n    YR_OBJECT* object,\n    int flags,\n    int index)\n{\n  YR_OBJECT* result = NULL;\n  YR_OBJECT_ARRAY* array;\n\n  assert(object->type == OBJECT_TYPE_ARRAY);\n\n  if (index < 0)\n    return NULL;\n\n  array = (YR_OBJECT_ARRAY*) object;\n\n  if (array->items != NULL && array->items->count > index)\n      result = array->items->objects[index];\n\n  if (result == NULL && flags & OBJECT_CREATE)\n  {\n    yr_object_copy(array->prototype_item, &result);\n\n    if (result != NULL)\n      yr_object_array_set_item(object, result, index);\n  }\n\n  return result;\n}\n\n\nint yr_object_array_set_item(\n    YR_OBJECT* object,\n    YR_OBJECT* item,\n    int index)\n{\n  YR_OBJECT_ARRAY* array;\n\n  int i;\n  int count;\n\n  assert(index >= 0);\n  assert(object->type == OBJECT_TYPE_ARRAY);\n\n  array = ((YR_OBJECT_ARRAY*) object);\n\n  if (array->items == NULL)\n  {\n    count = yr_max(64, (index + 1) * 2);\n\n    array->items = (YR_ARRAY_ITEMS*) yr_malloc(\n        sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));\n\n    if (array->items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    memset(array->items->objects, 0, count * sizeof(YR_OBJECT*));\n\n    array->items->count = count;\n  }\n  else if (index >= array->items->count)\n  {\n    count = array->items->count * 2;\n    array->items = (YR_ARRAY_ITEMS*) yr_realloc(\n        array->items,\n        sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));\n\n    if (array->items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    for (i = array->items->count; i < count; i++)\n      array->items->objects[i] = NULL;\n\n    array->items->count = count;\n  }\n\n  item->parent = object;\n  array->items->objects[index] = item;\n\n  return ERROR_SUCCESS;\n}\n\n\nYR_OBJECT* yr_object_dict_get_item(\n    YR_OBJECT* object,\n    int flags,\n    const char* key)\n{\n  int i;\n\n  YR_OBJECT* result = NULL;\n  YR_OBJECT_DICTIONARY* dict;\n\n  assert(object->type == OBJECT_TYPE_DICTIONARY);\n\n  dict = (YR_OBJECT_DICTIONARY*) object;\n\n  if (dict->items != NULL)\n  {\n    for (i = 0; i < dict->items->used; i++)\n    {\n      if (strcmp(dict->items->objects[i].key, key) == 0)\n        result = dict->items->objects[i].obj;\n    }\n  }\n\n  if (result == NULL && flags & OBJECT_CREATE)\n  {\n    yr_object_copy(dict->prototype_item, &result);\n\n    if (result != NULL)\n      yr_object_dict_set_item(object, result, key);\n  }\n\n  return result;\n}\n\n\nint yr_object_dict_set_item(\n    YR_OBJECT* object,\n    YR_OBJECT* item,\n    const char* key)\n{\n  YR_OBJECT_DICTIONARY* dict;\n\n  int i;\n  int count;\n\n  assert(object->type == OBJECT_TYPE_DICTIONARY);\n\n  dict = ((YR_OBJECT_DICTIONARY*) object);\n\n  if (dict->items == NULL)\n  {\n    count = 64;\n\n    dict->items = (YR_DICTIONARY_ITEMS*) yr_malloc(\n        sizeof(YR_DICTIONARY_ITEMS) + count * sizeof(dict->items->objects[0]));\n\n    if (dict->items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    memset(dict->items->objects, 0, count * sizeof(dict->items->objects[0]));\n\n    dict->items->free = count;\n    dict->items->used = 0;\n  }\n  else if (dict->items->free == 0)\n  {\n    count = dict->items->used * 2;\n    dict->items = (YR_DICTIONARY_ITEMS*) yr_realloc(\n        dict->items,\n        sizeof(YR_DICTIONARY_ITEMS) + count * sizeof(dict->items->objects[0]));\n\n    if (dict->items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    for (i = dict->items->used; i < count; i++)\n    {\n      dict->items->objects[i].key = NULL;\n      dict->items->objects[i].obj = NULL;\n    }\n\n    dict->items->free = dict->items->used;\n  }\n\n  item->parent = object;\n\n  dict->items->objects[dict->items->used].key = yr_strdup(key);\n  dict->items->objects[dict->items->used].obj = item;\n\n  dict->items->used++;\n  dict->items->free--;\n\n  return ERROR_SUCCESS;\n}\n\n\nint yr_object_has_undefined_value(\n    YR_OBJECT* object,\n    const char* field,\n    ...)\n{\n  YR_OBJECT* field_obj;\n\n  va_list args;\n  va_start(args, field);\n\n  if (field != NULL)\n    field_obj = _yr_object_lookup(object, 0, field, args);\n  else\n    field_obj = object;\n\n  va_end(args);\n\n  if (field_obj == NULL)\n    return TRUE;\n\n  switch(field_obj->type)\n  {\n    case OBJECT_TYPE_FLOAT:\n      return isnan(((YR_OBJECT_DOUBLE*) field_obj)->value);\n    case OBJECT_TYPE_STRING:\n      return ((YR_OBJECT_STRING*) field_obj)->value == NULL;\n    case OBJECT_TYPE_INTEGER:\n      return ((YR_OBJECT_INTEGER*) field_obj)->value == UNDEFINED;\n  }\n\n  return FALSE;\n}\n\n\nint64_t yr_object_get_integer(\n    YR_OBJECT* object,\n    const char* field,\n    ...)\n{\n  YR_OBJECT* integer_obj;\n\n  va_list args;\n  va_start(args, field);\n\n  if (field != NULL)\n    integer_obj = _yr_object_lookup(object, 0, field, args);\n  else\n    integer_obj = object;\n\n  va_end(args);\n\n  if (integer_obj == NULL)\n    return UNDEFINED;\n\n  assertf(integer_obj->type == OBJECT_TYPE_INTEGER,\n          \"type of \\\"%s\\\" is not integer\\n\", field);\n\n  return ((YR_OBJECT_INTEGER*) integer_obj)->value;\n}\n\n\ndouble yr_object_get_float(\n    YR_OBJECT* object,\n    const char* field,\n    ...)\n{\n  YR_OBJECT* double_obj;\n\n  va_list args;\n  va_start(args, field);\n\n  if (field != NULL)\n    double_obj = _yr_object_lookup(object, 0, field, args);\n  else\n    double_obj = object;\n\n  va_end(args);\n\n  if (double_obj == NULL)\n    return NAN;\n\n  assertf(double_obj->type == OBJECT_TYPE_FLOAT,\n          \"type of \\\"%s\\\" is not double\\n\", field);\n\n  return ((YR_OBJECT_DOUBLE*) double_obj)->value;\n}\n\n\nSIZED_STRING* yr_object_get_string(\n    YR_OBJECT* object,\n    const char* field,\n    ...)\n{\n  YR_OBJECT* string_obj;\n\n  va_list args;\n  va_start(args, field);\n\n  if (field != NULL)\n    string_obj = _yr_object_lookup(object, 0, field, args);\n  else\n    string_obj = object;\n\n  va_end(args);\n\n  if (string_obj == NULL)\n    return NULL;\n\n  assertf(string_obj->type == OBJECT_TYPE_STRING,\n          \"type of \\\"%s\\\" is not string\\n\", field);\n\n  return ((YR_OBJECT_STRING*) string_obj)->value;\n}\n\n\nint yr_object_set_integer(\n    int64_t value,\n    YR_OBJECT* object,\n    const char* field,\n    ...)\n{\n  YR_OBJECT* integer_obj;\n\n  va_list args;\n  va_start(args, field);\n\n  if (field != NULL)\n    integer_obj = _yr_object_lookup(\n        object, OBJECT_CREATE, field, args);\n  else\n    integer_obj = object;\n\n  va_end(args);\n\n  assert(integer_obj != NULL);\n  assert(integer_obj->type == OBJECT_TYPE_INTEGER);\n\n  ((YR_OBJECT_INTEGER*) integer_obj)->value = value;\n\n  return ERROR_SUCCESS;\n}\n\n\nint yr_object_set_float(\n    double value,\n    YR_OBJECT* object,\n    const char* field,\n    ...)\n{\n  YR_OBJECT* double_obj;\n\n  va_list args;\n  va_start(args, field);\n\n  if (field != NULL)\n    double_obj = _yr_object_lookup(\n        object, OBJECT_CREATE, field, args);\n  else\n    double_obj = object;\n\n  va_end(args);\n\n  assert(double_obj != NULL);\n  assert(double_obj->type == OBJECT_TYPE_FLOAT);\n\n  ((YR_OBJECT_DOUBLE*) double_obj)->value = value;\n\n  return ERROR_SUCCESS;\n}\n\n\nint yr_object_set_string(\n    const char* value,\n    size_t len,\n    YR_OBJECT* object,\n    const char* field,\n    ...)\n{\n  YR_OBJECT_STRING* string_obj;\n\n  va_list args;\n  va_start(args, field);\n\n  if (field != NULL)\n    string_obj = (YR_OBJECT_STRING*) _yr_object_lookup(\n        object, OBJECT_CREATE, field, args);\n  else\n    string_obj = (YR_OBJECT_STRING*) object;\n\n  va_end(args);\n\n  assert(string_obj != NULL);\n  assert(string_obj->type == OBJECT_TYPE_STRING);\n\n  if (string_obj->value != NULL)\n    yr_free(string_obj->value);\n\n  if (value != NULL)\n  {\n    string_obj->value = (SIZED_STRING*) yr_malloc(len + sizeof(SIZED_STRING));\n\n    if (string_obj->value == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    string_obj->value->length = (uint32_t) len;\n    string_obj->value->flags = 0;\n\n    memcpy(string_obj->value->c_string, value, len);\n    string_obj->value->c_string[len] = '\\0';\n  }\n  else\n  {\n    string_obj->value = NULL;\n  }\n\n  return ERROR_SUCCESS;\n}\n\n\nYR_OBJECT* yr_object_get_root(\n    YR_OBJECT* object)\n{\n  YR_OBJECT* o = object;\n\n  while (o->parent != NULL)\n    o = o->parent;\n\n  return o;\n}\n\nYR_API void yr_object_print_data(\n    YR_OBJECT* object,\n    int indent,\n    int print_identifier)\n{\n  YR_DICTIONARY_ITEMS* dict_items;\n  YR_ARRAY_ITEMS* array_items;\n  YR_STRUCTURE_MEMBER* member;\n\n  char indent_spaces[32];\n  int i;\n\n  indent = yr_min(indent, sizeof(indent_spaces) - 1);\n\n  memset(indent_spaces, '\\t', indent);\n  indent_spaces[indent] = '\\0';\n\n  if (print_identifier && object->type != OBJECT_TYPE_FUNCTION)\n    printf(\"%s%s\", indent_spaces, object->identifier);\n\n  switch(object->type)\n  {\n    case OBJECT_TYPE_INTEGER:\n      if (((YR_OBJECT_INTEGER*) object)->value != UNDEFINED)\n        printf(\" = %\" PRIu64, ((YR_OBJECT_INTEGER*) object)->value);\n      else\n        printf(\" = UNDEFINED\");\n      break;\n\n    case OBJECT_TYPE_STRING:\n      if (((YR_OBJECT_STRING*) object)->value != NULL)\n      {\n        size_t l;\n        printf(\" = \\\"\");\n\n        for (l = 0; l < ((YR_OBJECT_STRING*) object)->value->length; l++)\n        {\n          char c = ((YR_OBJECT_STRING*) object)->value->c_string[l];\n\n          if (isprint((unsigned char) c))\n            printf(\"%c\", c);\n          else\n            printf(\"\\\\x%02x\", (unsigned char) c);\n        }\n\n        printf(\"\\\"\");\n      }\n      else\n      {\n        printf(\" = UNDEFINED\");\n      }\n\n      break;\n\n    case OBJECT_TYPE_STRUCTURE:\n\n      member = ((YR_OBJECT_STRUCTURE*) object)->members;\n\n      while (member != NULL)\n      {\n        if (member->object->type != OBJECT_TYPE_FUNCTION)\n        {\n          printf(\"\\n\");\n          yr_object_print_data(member->object, indent + 1, 1);\n        }\n        member = member->next;\n      }\n\n      break;\n\n    case OBJECT_TYPE_ARRAY:\n      array_items = ((YR_OBJECT_ARRAY*) object)->items;\n\n      if (array_items != NULL)\n      {\n        for (i = 0; i < array_items->count; i++)\n        {\n          if (array_items->objects[i] != NULL)\n          {\n            printf(\"\\n%s\\t[%d]\", indent_spaces, i);\n            yr_object_print_data(array_items->objects[i], indent + 1, 0);\n          }\n        }\n      }\n\n      break;\n\n    case OBJECT_TYPE_DICTIONARY:\n\n      dict_items = ((YR_OBJECT_DICTIONARY*) object)->items;\n\n      if (dict_items != NULL)\n      {\n        for (i = 0; i < dict_items->used; i++)\n        {\n          printf(\"\\n%s\\t%s\", indent_spaces, dict_items->objects[i].key);\n          yr_object_print_data(dict_items->objects[i].obj, indent + 1, 0);\n        }\n      }\n\n      break;\n  }\n}\n", "/*\nCopyright (c) 2014. The YARA Authors. All Rights Reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\nlist of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#include <yara/sizedstr.h>\n\n\nint sized_string_cmp(\n  SIZED_STRING* s1,\n  SIZED_STRING* s2)\n{\n  size_t i = 0;\n\n  while (s1->length > i &&\n         s2->length > i &&\n         s1->c_string[i] == s2->c_string[i])\n  {\n    i++;\n  }\n\n  if (i == s1->length && i == s2->length)\n    return 0;\n  else if (i == s1->length)\n    return -1;\n  else if (i == s2->length)\n    return 1;\n  else if (s1->c_string[i] < s2->c_string[i])\n    return -1;\n  else\n    return 1;\n}\n", "/*\nCopyright (c) 2016. The YARA Authors. All Rights Reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\nlist of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#include <yara.h>\n#include \"blob.h\"\n#include \"util.h\"\n\n#if defined(_WIN32) || defined(__CYGWIN__)\n#include <fileapi.h>\n#else\n#include <unistd.h>\n#endif\n#include <fcntl.h>\n\nstatic void test_boolean_operators()\n{\n  assert_true_rule(\n      \"rule test { condition: true }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: true or false }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: true and true }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 0x1 and 0x2}\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: false }\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: true and false }\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: false or false }\", NULL);\n}\n\n\nstatic void test_comparison_operators()\n{\n  assert_true_rule(\n      \"rule test { condition: 2 > 1 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1 < 2 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 2 >= 1 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1 <= 1 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1 == 1 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1.5 == 1.5}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1.0 == 1}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1.5 >= 1.0}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1.5 >= 1}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1.0 >= 1}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 0.5 < 1}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 0.5 <= 1}\", NULL);\n\n  assert_true_rule(\n      \"rule rest { condition: 1.0 <= 1}\", NULL);\n\n  assert_true_rule(\n      \"rule rest { condition: \\\"abc\\\" == \\\"abc\\\"}\", NULL);\n\n  assert_true_rule(\n      \"rule rest { condition: \\\"abc\\\" <= \\\"abc\\\"}\", NULL);\n\n  assert_true_rule(\n      \"rule rest { condition: \\\"abc\\\" >= \\\"abc\\\"}\", NULL);\n\n  assert_true_rule(\n      \"rule rest { condition: \\\"ab\\\" < \\\"abc\\\"}\", NULL);\n\n  assert_true_rule(\n      \"rule rest { condition: \\\"abc\\\" > \\\"ab\\\"}\", NULL);\n\n  assert_true_rule(\n      \"rule rest { condition: \\\"abc\\\" < \\\"abd\\\"}\", NULL);\n\n  assert_true_rule(\n      \"rule rest { condition: \\\"abd\\\" > \\\"abc\\\"}\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: 1 != 1}\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: 1 != 1.0}\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: 2 > 3}\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: 2.1 < 2}\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: \\\"abc\\\" != \\\"abc\\\"}\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: \\\"abc\\\" > \\\"abc\\\"}\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: \\\"abc\\\" < \\\"abc\\\"}\", NULL);\n\n}\n\nstatic void test_arithmetic_operators()\n{\n  assert_true_rule(\n      \"rule test { condition: (1 + 1) * 2 == (9 - 1) \\\\ 2 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 5 % 2 == 1 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1.5 + 1.5 == 3}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 3 \\\\ 2 == 1}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 3.0 \\\\ 2 == 1.5}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1 + -1 == 0}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: -1 + -1 == -2}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 4 --2 * 2 == 8}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: -1.0 * 1 == -1.0}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1-1 == 0}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: -2.0-3.0 == -5}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: --1 == 1}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1--1 == 2}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: -0x01 == -1}\", NULL);\n\n}\n\n\nstatic void test_bitwise_operators()\n{\n  assert_true_rule(\n      \"rule test { condition: 0x55 | 0xAA == 0xFF }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: ~0xAA ^ 0x5A & 0xFF == (~0xAA) ^ (0x5A & 0xFF) }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: ~0x55 & 0xFF == 0xAA }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 8 >> 2 == 2 }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1 << 3 == 8 }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1 | 3 ^ 3 == 1 | (3 ^ 3) }\",\n      NULL);\n\n  assert_false_rule(\n      \"rule test { condition: ~0xAA ^ 0x5A & 0xFF == 0x0F }\",\n      NULL);\n\n  assert_false_rule(\n      \"rule test { condition: 1 | 3 ^ 3 == (1 | 3) ^ 3}\",\n      NULL);\n\n}\n\n\nstatic void test_syntax()\n{\n  assert_error(\n      \"rule test { strings: $a = \\\"a\\\" $a = \\\"a\\\" condition: all of them }\",\n      ERROR_DUPLICATED_STRING_IDENTIFIER);\n}\n\n\nstatic void test_anonymous_strings()\n{\n  assert_true_rule(\n      \"rule test { strings: $ = \\\"a\\\" $ = \\\"b\\\" condition: all of them }\",\n      \"ab\");\n}\n\n\nstatic void test_strings()\n{\n  char* str = \"---- abc ---- xyz\";\n  uint8_t blob[] = \"---- a\\0b\\0c\\0 -\\0-\\0-\\0-\\0x\\0y\\0z\\0\";\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"a\\\" condition: $a }\",\n      str);\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ab\\\" condition: $a }\",\n      str);\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"abc\\\" condition: $a }\",\n      str);\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"xyz\\\" condition: $a }\",\n      str);\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"abc\\\" nocase fullword condition: $a }\",\n      str);\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"aBc\\\" nocase  condition: $a }\",\n      str);\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"abc\\\" fullword condition: $a }\",\n      str);\n\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"a\\\" fullword condition: $a }\",\n      str);\n\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"ab\\\" fullword condition: $a }\",\n      str);\n\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"abc\\\" wide fullword condition: $a }\",\n      str);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"a\\\" wide condition: $a }\",\n      blob);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"a\\\" wide ascii condition: $a }\",\n      blob);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"ab\\\" wide condition: $a }\",\n      blob);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"ab\\\" wide ascii condition: $a }\",\n      blob);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" wide condition: $a }\",\n      blob);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" wide nocase fullword condition: $a }\",\n      blob);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"aBc\\\" wide nocase condition: $a }\",\n      blob);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"aBc\\\" wide ascii nocase condition: $a }\",\n      blob);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"---xyz\\\" wide nocase condition: $a }\",\n      blob);\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"abc\\\" fullword condition: $a }\",\n      \"abc\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"abc\\\" fullword condition: $a }\",\n      \"xabcx\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"abc\\\" fullword condition: $a }\",\n      \"xabc\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"abc\\\" fullword condition: $a }\",\n      \"abcx\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"abc\\\" ascii wide fullword condition: $a }\",\n      \"abcx\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" ascii wide fullword condition: $a }\",\n      \"a\\0abc\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" wide fullword condition: $a }\",\n      \"a\\0b\\0c\\0\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" wide fullword condition: $a }\",\n      \"x\\0a\\0b\\0c\\0x\\0\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = \\\"ab\\\" wide fullword condition: $a }\",\n      \"x\\0a\\0b\\0\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" wide fullword condition: $a }\",\n      \"x\\0a\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" wide fullword condition: $a }\",\n      \"x\\001a\\0b\\0c\\0\");\n\n  assert_true_rule(\n      \"rule test {\\n\\\n         strings:\\n\\\n             $a = \\\"abcdef\\\"\\n\\\n             $b = \\\"cdef\\\"\\n\\\n             $c = \\\"ef\\\"\\n\\\n         condition:\\n\\\n             all of them\\n\\\n       }\", \"abcdef\");\n}\n\n\nstatic void test_wildcard_strings()\n{\n  assert_true_rule_blob(\n      \"rule test {\\n\\\n         strings:\\n\\\n             $s1 = \\\"abc\\\"\\n\\\n             $s2 = \\\"xyz\\\"\\n\\\n         condition:\\n\\\n             for all of ($*) : ($)\\n\\\n      }\",\n      \"---- abc ---- A\\x00\"\"B\\x00\"\"C\\x00 ---- xyz\");\n}\n\n\nstatic void test_hex_strings()\n{\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 64 01 00 00 60 01 } \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 64 0? 00 00 ?0 01 } \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\\\n\n      \"rule test { \\\n        strings: $a = { 6? 01 00 00 60 0? } \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 64 01 [1-3] 60 01 } \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 64 01 [1-3] (60|61) 01 } \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 4D 5A [-] 6A 2A [-] 58 C3} \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 4D 5A [300-] 6A 2A [-] 58 C3} \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 2e 7? (65 | ?? ) 78 } \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_false_rule_blob(\n      \"rule test { \\\n        strings: $a = { 4D 5A [0-300] 6A 2A } \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_false_rule_blob(\n      \"rule test { \\\n        strings: $a = { 4D 5A [0-128] 45 [0-128] 01 [0-128]  C3 } \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [-] 38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [-] // Inline comment\\n\\r \\\n          38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 /* Inline comment */ [-] 38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 /* Inline multi-line\\n\\r \\\n                                 comment */ [-] 38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = {\\n 31 32 [-] 38 39 \\n\\r} \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [-] 33 34 [-] 38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [1] 34 35 [2] 38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test {\\\n         strings: $a = { 31 32 [1-] 34 35 [1-] 38 39 } \\\n         condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-3] 34 35 [1-] 38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-2] 35 [1-] 37 38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-1] 33 } \\\n        condition: !a == 3}\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-1] 34 } \\\n        condition: !a == 4}\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-2] 34 } \\\n        condition: !a == 4 }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [-] 38 39 } \\\n        condition: all of them }\",\n      \"1234567890\");\n\n  assert_false_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [-] 32 33 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_false_rule(\n      \"rule test { \\\n        strings: $a = { 35 36 [-] 31 32 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_false_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [2-] 34 35 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-1] 33 34 [0-2] 36 37 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-1] 34 35 [0-2] 36 37 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_false_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-3] 37 38 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [1] 33 34 } \\\n        condition: $a }\",\n      \"12\\n34\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = {31 32 [3-6] 32} \\\n        condition: !a == 6 }\",\n      \"12111222\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = {31 [0-3] (32|33)} \\\n        condition: !a == 2 }\",\n      \"122222222\");\n\n  assert_error(\n      \"rule test { \\\n        strings: $a = { 01 [0] 02 } \\\n        condition: $a }\",\n      ERROR_INVALID_HEX_STRING);\n\n  assert_error(\n      \"rule test { \\\n        strings: $a = { [-] 01 02 } condition: $a }\",\n      ERROR_INVALID_HEX_STRING);\n\n  assert_error(\n      \"rule test { \\\n        strings: $a = { 01 02 [-] } \\\n        condition: $a }\",\n      ERROR_INVALID_HEX_STRING);\n\n  assert_error(\n      \"rule test { \\\n        strings: $a = { 01 02 ([-] 03 | 04) } \\\n        condition: $a }\",\n      ERROR_INVALID_HEX_STRING);\n\n  assert_error(\n      \"rule test { \\\n        strings: $a = { 01 02 (03 [-] | 04) } \\\n        condition: $a }\",\n      ERROR_INVALID_HEX_STRING);\n\n  assert_error(\n      \"rule test { \\\n        strings: $a = { 01 02 (03 | 04 [-]) } \\\n        condition: $a \",\n      ERROR_INVALID_HEX_STRING);\n\n  /* TODO: tests.py:551 ff. */\n}\n\n\nstatic void test_count()\n{\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ssi\\\" condition: #a == 2 }\",\n      \"mississippi\");\n}\n\n\nstatic void test_at()\n{\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = \\\"ssi\\\" \\\n        condition: $a at 2 and $a at 5 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = \\\"mis\\\" \\\n        condition: $a at ~0xFF & 0xFF }\",\n      \"mississippi\");\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 00 00 00 00 ?? 74 65 78 74 } \\\n        condition: $a at 308}\",\n      PE32_FILE);\n}\n\n\nstatic void test_in()\n{\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 6a 2a 58 c3 } \\\n        condition: $a in (entrypoint .. entrypoint + 1) }\",\n      PE32_FILE);\n}\n\n\nstatic void test_offset()\n{\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ssi\\\" condition: @a == 2 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ssi\\\" condition: @a == @a[1] }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ssi\\\" condition: @a[2] == 5 }\",\n      \"mississippi\");\n}\n\n\nstatic void test_length()\n{\n  assert_true_rule(\n      \"rule test { strings: $a = /m.*?ssi/ condition: !a == 5 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /m.*?ssi/ condition: !a[1] == 5 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /m.*ssi/ condition: !a == 8 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /m.*ssi/ condition: !a[1] == 8 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ssi.*ppi/ condition: !a[1] == 9 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ssi.*ppi/ condition: !a[2] == 6 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = { 6D [1-3] 73 73 69 } condition: !a == 5}\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = { 6D [-] 73 73 69 } condition: !a == 5}\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = { 6D [-] 70 70 69 } condition: !a == 11}\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = { 6D 69 73 73 [-] 70 69 } condition: !a == 11}\",\n      \"mississippi\");\n}\n\n\nstatic void test_of()\n{\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ssi\\\" $b = \\\"mis\\\" $c = \\\"oops\\\" \"\n      \"condition: any of them }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ssi\\\" $b = \\\"mis\\\" $c = \\\"oops\\\" \"\n      \"condition: 1 of them }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ssi\\\" $b = \\\"mis\\\" $c = \\\"oops\\\" \"\n      \"condition: 2 of them }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a1 = \\\"dummy1\\\" $b1 = \\\"dummy1\\\" $b2 = \\\"ssi\\\"\"\n      \"condition: any of ($a*, $b*) }\",\n      \"mississippi\");\n\n  assert_true_rule_blob(\n      \"rule test { \\\n         strings: \\\n           $ = /abc/ \\\n           $ = /def/ \\\n           $ = /ghi/ \\\n         condition: \\\n           for any of ($*) : ( for any i in (1..#): (uint8(@[i] - 1) == 0x00) )\\\n       }\",\n       \"abc\\000def\\000ghi\");\n\n  assert_false_rule(\n      \"rule test { \\\n        strings: \\\n          $a = \\\"ssi\\\" \\\n          $b = \\\"mis\\\" \\\n          $c = \\\"oops\\\" \\\n        condition: \\\n          all of them \\\n      }\",\n      \"mississippi\");\n\n  assert_error(\n      \"rule test { condition: all of ($a*) }\",\n      ERROR_UNDEFINED_STRING);\n\n  assert_error(\n      \"rule test { condition: all of them }\",\n      ERROR_UNDEFINED_STRING);\n}\n\n\nvoid test_for()\n{\n  assert_true_rule(\n      \"rule test { \\\n        strings: \\\n          $a = \\\"ssi\\\" \\\n        condition: \\\n          for all i in (1..#a) : (@a[i] >= 2 and @a[i] <= 5) \\\n      }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: \\\n          $a = \\\"ssi\\\" \\\n          $b = \\\"mi\\\" \\\n        condition: \\\n          for all i in (1..#a) : ( for all j in (1..#b) : (@a[i] >= @b[j])) \\\n      }\",\n      \"mississippi\");\n\n  assert_false_rule(\n      \"rule test { \\\n        strings: \\\n          $a = \\\"ssi\\\" \\\n        condition: \\\n          for all i in (1..#a) : (@a[i] == 5) \\\n      }\",\n      \"mississippi\");\n}\n\n\nvoid test_re()\n{\n  assert_true_rule(\n      \"rule test { strings: $a = /ssi/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ssi(s|p)/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ssim*/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ssa?/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /Miss/ nocase condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /(M|N)iss/ nocase condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /[M-N]iss/ nocase condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /(Mi|ssi)ssippi/ nocase condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ppi\\\\tmi/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ppi\\\\.mi/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /^mississippi/ fullword condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /mississippi.*mississippi$/s condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /^ssi/ condition: $a }\",\n      \"mississippi\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /ssi$/ condition: $a }\",\n      \"mississippi\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /ssissi/ fullword condition: $a }\",\n      \"mississippi\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /^[isp]+/ condition: $a }\",\n      \"mississippi\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /a.{1,2}b/ wide condition: !a == 6 }\",\n      \"a\\0x\\0b\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /a.{1,2}b/ wide condition: !a == 8 }\",\n      \"a\\0x\\0x\\0b\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"a\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"\\0a\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"\\ta\\0b\\0c\\0\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"x\\0a\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"x\\ta\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0\\t\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0x\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0b\\t\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = /\\\\b/ wide condition: $a }\",\n      \"abc\");\n\n  assert_regexp_syntax_error(\")\");\n  assert_true_regexp(\"abc\", \"abc\", \"abc\");\n  assert_false_regexp(\"abc\", \"xbc\");\n  assert_false_regexp(\"abc\", \"axc\");\n  assert_false_regexp(\"abc\", \"abx\");\n  assert_true_regexp(\"abc\", \"xabcx\", \"abc\");\n  assert_true_regexp(\"abc\", \"ababc\", \"abc\");\n  assert_true_regexp(\"a.c\", \"abc\", \"abc\");\n  assert_false_regexp(\"a.b\", \"a\\nb\");\n  assert_false_regexp(\"a.*b\", \"acc\\nccb\");\n  assert_false_regexp(\"a.{4,5}b\", \"acc\\nccb\");\n  assert_true_regexp(\"a.b\", \"a\\rb\", \"a\\rb\");\n  assert_true_regexp(\"ab*c\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab*c\", \"ac\", \"ac\");\n  assert_true_regexp(\"ab*bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab*bc\", \"abbc\", \"abbc\");\n  assert_true_regexp(\"a.*bb\", \"abbbb\", \"abbbb\");\n  assert_true_regexp(\"a.*?bbb\", \"abbbbbb\", \"abbb\");\n  assert_true_regexp(\"a.*c\", \"ac\", \"ac\");\n  assert_true_regexp(\"a.*c\", \"axyzc\", \"axyzc\");\n  assert_true_regexp(\"ab+c\", \"abbc\", \"abbc\");\n  assert_false_regexp(\"ab+c\", \"ac\");\n  assert_true_regexp(\"ab+\", \"abbbb\", \"abbbb\");\n  assert_true_regexp(\"ab+?\", \"abbbb\", \"ab\");\n  assert_false_regexp(\"ab+bc\", \"abc\");\n  assert_false_regexp(\"ab+bc\", \"abq\");\n  assert_true_regexp(\"a+b+c\", \"aabbabc\", \"abc\");\n  assert_false_regexp(\"ab?bc\", \"abbbbc\");\n  assert_true_regexp(\"ab?c\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab*?\", \"abbb\", \"a\");\n  assert_true_regexp(\"ab?c\", \"ac\", \"ac\");\n  assert_true_regexp(\"ab??\", \"ab\", \"a\");\n  assert_true_regexp(\"a(b|x)c\", \"abc\", \"abc\");\n  assert_true_regexp(\"a(b|x)c\", \"axc\", \"axc\");\n  assert_true_regexp(\"a(b|.)c\", \"axc\", \"axc\");\n  assert_true_regexp(\"a(b|x|y)c\", \"ayc\", \"ayc\");\n  assert_true_regexp(\"(a+|b)*\", \"ab\", \"ab\");\n  assert_true_regexp(\"a|b|c|d|e\", \"e\", \"e\");\n  assert_true_regexp(\"(a|b|c|d|e)f\", \"ef\", \"ef\");\n  assert_true_regexp(\".b{2}\", \"abb\", \"abb\");\n  assert_true_regexp(\".b{2,3}\", \"abbb\", \"abbb\");\n  assert_true_regexp(\".b{2,3}?\", \"abbb\", \"abb\");\n  assert_true_regexp(\"ab{2,3}c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\"ab{2,3}?c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\".b{2,3}cccc\", \"abbbcccc\", \"abbbcccc\");\n  assert_true_regexp(\".b{2,3}?cccc\", \"abbbcccc\", \"bbbcccc\");\n  assert_true_regexp(\"a.b{2,3}cccc\", \"aabbbcccc\", \"aabbbcccc\");\n  assert_true_regexp(\"ab{2,3}c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\"ab{2,3}?c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\"ab{0,1}?c\", \"abc\", \"abc\");\n  assert_true_regexp(\"a{0,1}?bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"a{0,1}bc\", \"bbc\", \"bc\");\n  assert_true_regexp(\"a{0,1}?bc\", \"abc\", \"bc\");\n  assert_true_regexp(\"aa{0,1}?bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"aa{0,1}?bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"aa{0,1}bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab{1}c\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab{1,2}c\", \"abbc\", \"abbc\");\n  assert_true_regexp(\"ab{1,}c\", \"abbbc\", \"abbbc\");\n  assert_false_regexp(\"ab{1,}b\", \"ab\");\n  assert_false_regexp(\"ab{1}c\", \"abbc\");\n  assert_true_regexp(\"ab{0,}c\", \"ac\", \"ac\");\n  assert_true_regexp(\"ab{1,1}c\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab{0,}c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\"ab{,3}c\", \"abbbc\", \"abbbc\");\n  assert_false_regexp(\"ab{,2}c\", \"abbbc\");\n  assert_false_regexp(\"ab{4,5}bc\", \"abbbbc\");\n  assert_true_regexp(\"ab{0,1}\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{0,2}\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"ab{0,3}\", \"abbbbb\", \"abbb\");\n  assert_true_regexp(\"ab{0,4}\", \"abbbbb\", \"abbbb\");\n  assert_true_regexp(\"ab{1,1}\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{1,2}\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"ab{1,3}\", \"abbbbb\", \"abbb\");\n  assert_true_regexp(\"ab{2,2}\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"ab{2,3}\", \"abbbbb\", \"abbb\");\n  assert_true_regexp(\"ab{1,3}?\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{0,1}?\", \"abbbbb\", \"a\");\n  assert_true_regexp(\"ab{0,2}?\", \"abbbbb\", \"a\");\n  assert_true_regexp(\"ab{0,3}?\", \"abbbbb\", \"a\");\n  assert_true_regexp(\"ab{0,4}?\", \"abbbbb\", \"a\");\n  assert_true_regexp(\"ab{1,1}?\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{1,2}?\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{1,3}?\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{2,2}?\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"ab{2,3}?\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\".(abc){0,1}\", \"xabcabcabcabc\", \"xabc\");\n  assert_true_regexp(\".(abc){0,2}\", \"xabcabcabcabc\", \"xabcabc\");\n  assert_true_regexp(\"x{1,2}abcd\", \"xxxxabcd\", \"xxabcd\");\n  assert_true_regexp(\"x{1,2}abcd\", \"xxxxabcd\", \"xxabcd\");\n  assert_true_regexp(\"ab{.*}\", \"ab{c}\", \"ab{c}\");\n  assert_true_regexp(\".(aa){1,2}\", \"aaaaaaaaaa\", \"aaaaa\");\n  assert_true_regexp(\"a.(bc.){2}\", \"aabcabca\", \"aabcabca\");\n  assert_true_regexp(\"(ab{1,2}c){1,3}\", \"abbcabc\", \"abbcabc\");\n  assert_true_regexp(\"ab(c|cc){1,3}d\", \"abccccccd\", \"abccccccd\");\n  assert_true_regexp(\"a[bx]c\", \"abc\", \"abc\");\n  assert_true_regexp(\"a[bx]c\", \"axc\", \"axc\");\n  assert_true_regexp(\"a[0-9]*b\", \"ab\", \"ab\");\n  assert_true_regexp(\"a[0-9]*b\", \"a0123456789b\", \"a0123456789b\");\n  assert_true_regexp(\"[0-9a-f]+\", \"0123456789abcdef\", \"0123456789abcdef\");\n  assert_true_regexp(\"[0-9a-f]+\", \"xyz0123456789xyz\", \"0123456789\");\n  assert_true_regexp(\"a[\\\\s\\\\S]b\", \"a b\", \"a b\");\n  assert_true_regexp(\"a[\\\\d\\\\D]b\", \"a1b\", \"a1b\");\n  assert_false_regexp(\"[x-z]+\", \"abc\");\n  assert_true_regexp(\"a[-]?c\", \"ac\", \"ac\");\n  assert_true_regexp(\"a[-b]\", \"a-\", \"a-\");\n  assert_true_regexp(\"a[-b]\", \"ab\", \"ab\");\n  assert_true_regexp(\"a[b-]\", \"a-\", \"a-\");\n  assert_true_regexp(\"a[b-]\", \"ab\", \"ab\");\n  assert_true_regexp(\"[a-c-e]\", \"b\", \"b\");\n  assert_true_regexp(\"[a-c-e]\", \"-\", \"-\");\n  assert_false_regexp(\"[a-c-e]\", \"d\");\n  assert_regexp_syntax_error(\"[b-a]\");\n  assert_regexp_syntax_error(\"(abc\");\n  assert_regexp_syntax_error(\"abc)\");\n  assert_regexp_syntax_error(\"a[]b\");\n  assert_true_regexp(\"a[\\\\-b]\", \"a-\", \"a-\");\n  assert_true_regexp(\"a[\\\\-b]\", \"ab\", \"ab\");\n  assert_true_regexp(\"a]\", \"a]\", \"a]\");\n  assert_true_regexp(\"a[]]b\", \"a]b\", \"a]b\");\n  assert_true_regexp(\"a[\\\\]]b\", \"a]b\", \"a]b\");\n  assert_true_regexp(\"a[^bc]d\", \"aed\", \"aed\");\n  assert_false_regexp(\"a[^bc]d\", \"abd\");\n  assert_true_regexp(\"a[^-b]c\", \"adc\", \"adc\");\n  assert_false_regexp(\"a[^-b]c\", \"a-c\");\n  assert_false_regexp(\"a[^]b]c\", \"a]c\");\n  assert_true_regexp(\"a[^]b]c\", \"adc\", \"adc\");\n  assert_true_regexp(\"[^ab]*\", \"cde\", \"cde\");\n  assert_regexp_syntax_error(\")(\");\n  assert_true_regexp(\"a\\\\sb\", \"a b\", \"a b\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\tb\", \"a\\tb\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\rb\", \"a\\rb\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\nb\", \"a\\nb\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\vb\", \"a\\vb\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\fb\", \"a\\fb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a b\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\tb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\rb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\nb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\vb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\fb\");\n  assert_true_regexp(\"\\\\n\\\\r\\\\t\\\\f\\\\a\", \"\\n\\r\\t\\f\\a\", \"\\n\\r\\t\\f\\a\");\n  assert_true_regexp(\"[\\\\n][\\\\r][\\\\t][\\\\f][\\\\a]\", \"\\n\\r\\t\\f\\a\", \"\\n\\r\\t\\f\\a\");\n  assert_true_regexp(\"\\\\x01\\\\x02\\\\x03\", \"\\x01\\x02\\x03\", \"\\x01\\x02\\x03\");\n  assert_true_regexp(\"[\\\\x01-\\\\x03]+\", \"\\x01\\x02\\x03\", \"\\x01\\x02\\x03\");\n  assert_false_regexp(\"[\\\\x00-\\\\x02]+\", \"\\x03\\x04\\x05\");\n  assert_true_regexp(\"[\\\\x5D]\", \"]\", \"]\");\n  assert_true_regexp(\"[\\\\0x5A-\\\\x5D]\", \"\\x5B\", \"\\x5B\");\n  assert_true_regexp(\"[\\\\x5D-\\\\x5F]\", \"\\x5E\", \"\\x5E\");\n  assert_true_regexp(\"[\\\\x5C-\\\\x5F]\", \"\\x5E\", \"\\x5E\");\n  assert_true_regexp(\"[\\\\x5D-\\\\x5F]\", \"\\x5E\", \"\\x5E\");\n  assert_true_regexp(\"a\\\\wc\", \"abc\", \"abc\");\n  assert_true_regexp(\"a\\\\wc\", \"a_c\", \"a_c\");\n  assert_true_regexp(\"a\\\\wc\", \"a0c\", \"a0c\");\n  assert_false_regexp(\"a\\\\wc\", \"a*c\");\n  assert_true_regexp(\"\\\\w+\", \"--ab_cd0123--\", \"ab_cd0123\");\n  assert_true_regexp(\"[\\\\w]+\", \"--ab_cd0123--\", \"ab_cd0123\");\n  assert_true_regexp(\"\\\\D+\", \"1234abc5678\", \"abc\");\n  assert_true_regexp(\"[\\\\d]+\", \"0123456789\", \"0123456789\");\n  assert_true_regexp(\"[\\\\D]+\", \"1234abc5678\", \"abc\");\n  assert_true_regexp(\"[\\\\da-fA-F]+\", \"123abc\", \"123abc\");\n  assert_false_regexp(\"^(ab|cd)e\", \"abcde\");\n  assert_true_regexp(\"(abc|)ef\", \"abcdef\", \"ef\");\n  assert_true_regexp(\"(abc|)ef\", \"abcef\", \"abcef\");\n  assert_true_regexp(\"\\\\babc\", \"abc\", \"abc\");\n  assert_true_regexp(\"abc\\\\b\", \"abc\", \"abc\");\n  assert_false_regexp(\"\\\\babc\", \"1abc\");\n  assert_false_regexp(\"abc\\\\b\", \"abc1\");\n  assert_true_regexp(\"abc\\\\s\\\\b\", \"abc x\", \"abc \");\n  assert_false_regexp(\"abc\\\\s\\\\b\", \"abc  \");\n  assert_true_regexp(\"\\\\babc\\\\b\", \" abc \", \"abc\");\n  assert_true_regexp(\"\\\\b\\\\w\\\\w\\\\w\\\\b\", \" abc \", \"abc\");\n  assert_true_regexp(\"\\\\w\\\\w\\\\w\\\\b\", \"abcd\", \"bcd\");\n  assert_true_regexp(\"\\\\b\\\\w\\\\w\\\\w\", \"abcd\", \"abc\");\n  assert_false_regexp(\"\\\\b\\\\w\\\\w\\\\w\\\\b\", \"abcd\");\n  assert_false_regexp(\"\\\\Babc\", \"abc\");\n  assert_false_regexp(\"abc\\\\B\", \"abc\");\n  assert_true_regexp(\"\\\\Babc\", \"1abc\", \"abc\");\n  assert_true_regexp(\"abc\\\\B\", \"abc1\", \"abc\");\n  assert_false_regexp(\"abc\\\\s\\\\B\", \"abc x\");\n  assert_true_regexp(\"abc\\\\s\\\\B\", \"abc  \", \"abc \");\n  assert_true_regexp(\"\\\\w\\\\w\\\\w\\\\B\", \"abcd\", \"abc\");\n  assert_true_regexp(\"\\\\B\\\\w\\\\w\\\\w\", \"abcd\", \"bcd\");\n  assert_false_regexp(\"\\\\B\\\\w\\\\w\\\\w\\\\B\", \"abcd\");\n\n  // This is allowed in most regexp engines but in order to keep the\n  // grammar free of shift/reduce conflicts I've decided not supporting\n  // it. Users can use the (abc|) form instead.\n  assert_regexp_syntax_error(\"(|abc)ef\");\n\n  assert_true_regexp(\"((a)(b)c)(d)\", \"abcd\", \"abcd\");\n  assert_true_regexp(\"(a|b)c*d\", \"abcd\", \"bcd\");\n  assert_true_regexp(\"(ab|ab*)bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"a([bc]*)c*\", \"abc\", \"abc\");\n  assert_true_regexp(\"a([bc]*)c*\", \"ac\", \"ac\");\n  assert_true_regexp(\"a([bc]*)c*\", \"a\", \"a\");\n  assert_true_regexp(\"a([bc]*)(c*d)\", \"abcd\", \"abcd\");\n  assert_true_regexp(\"a([bc]+)(c*d)\", \"abcd\", \"abcd\");\n  assert_true_regexp(\"a([bc]*)(c+d)\", \"abcd\", \"abcd\");\n  assert_true_regexp(\"a[bcd]*dcdcde\", \"adcdcde\", \"adcdcde\");\n  assert_false_regexp(\"a[bcd]+dcdcde\", \"adcdcde\");\n  assert_true_regexp(\"\\\\((.*), (.*)\\\\)\", \"(a, b)\", \"(a, b)\");\n  assert_true_regexp(\"abc|123$\", \"abcx\", \"abc\");\n  assert_false_regexp(\"abc|123$\", \"123x\");\n  assert_true_regexp(\"abc|^123\", \"123\", \"123\");\n  assert_false_regexp(\"abc|^123\", \"x123\");\n  assert_true_regexp(\"^abc$\", \"abc\", \"abc\");\n  assert_false_regexp(\"^abc$\", \"abcc\");\n  assert_true_regexp(\"^abc\", \"abcc\", \"abc\");\n  assert_false_regexp(\"^abc$\", \"aabc\");\n  assert_false_regexp(\"abc^\", \"abc\");\n  assert_false_regexp(\"ab^c\", \"abc\");\n  assert_false_regexp(\"a^bcdef\", \"abcdef\")\n  assert_true_regexp(\"abc$\", \"aabc\", \"abc\");\n  assert_false_regexp(\"$abc\", \"abc\");\n  assert_true_regexp(\"(a|a$)bcd\", \"abcd\", \"abcd\");\n  assert_false_regexp(\"(a$|a$)bcd\", \"abcd\");\n  assert_false_regexp(\"(abc$|ab$)\", \"abcd\");\n  assert_true_regexp(\"^a(bc+|b[eh])g|.h$\", \"abhg\", \"abhg\");\n  assert_true_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"effgz\", \"effgz\");\n  assert_true_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"ij\", \"ij\");\n  assert_false_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"effg\");\n  assert_false_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"bcdd\");\n  assert_true_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"reffgz\", \"effgz\");\n\n  // Test case for issue #324\n  assert_true_regexp(\"whatever|   x.   x\", \"   xy   x\", \"   xy   x\");\n\n  // test case for issue #503, \\x without two following hex-digits\n  assert_regexp_syntax_error(\"\\\\x0\");\n  assert_regexp_syntax_error(\"\\\\x\");\n\n  assert_regexp_syntax_error(\"x{0,0}\");\n  assert_regexp_syntax_error(\"x{0}\");\n\n  assert_regexp_syntax_error(\"\\\\xxy\");\n\n  assert_error(\n      \"rule test { strings: $a = /a\\\\/ condition: $a }\",\n      ERROR_SYNTAX_ERROR);\n\n  assert_error(\n      \"rule test { strings: $a = /[a\\\\/ condition: $a }\",\n      ERROR_SYNTAX_ERROR);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = /MZ.{300,}t/ \\\n        condition: !a == 317 }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = /MZ.{300,}?t/ \\\n        condition: !a == 314 }\",\n      PE32_FILE);\n}\n\n\nstatic void test_entrypoint()\n{\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 6a 2a 58 c3 } \\\n        condition: $a at entrypoint }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { b8 01 00 00 00 bb 2a } \\\n        condition: $a at entrypoint }\",\n      ELF32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { b8 01 00 00 00 bb 2a } \\\n        condition: $a at entrypoint }\",\n      ELF64_FILE);\n\n  assert_false_rule(\n      \"rule test { condition: entrypoint >= 0 }\",\n      NULL);\n}\n\n\nstatic void test_filesize()\n{\n  char rule[80];\n\n  snprintf(\n      rule,\n      sizeof(rule),\n      \"rule test { condition: filesize == %zd }\",\n      sizeof(PE32_FILE));\n\n  assert_true_rule_blob(\n      rule,\n      PE32_FILE);\n}\n\n\nstatic void test_comments()\n{\n  assert_true_rule(\n      \"rule test {\\n\\\n         condition:\\n\\\n             //  this is a comment\\n\\\n             /*** this is a comment ***/\\n\\\n             /* /* /*\\n\\\n                 this is a comment\\n\\\n             */\\n\\\n             true\\n\\\n      }\",\n      NULL);\n}\n\nstatic void test_matches_operator()\n{\n  assert_true_rule(\n      \"rule test { condition: \\\"foo\\\" matches /foo/ }\",\n      NULL);\n\n  assert_false_rule(\n      \"rule test { condition: \\\"foo\\\" matches /bar/ }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: \\\"FoO\\\" matches /fOo/i }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: \\\"xxFoOxx\\\" matches /fOo/i }\",\n      NULL);\n\n  assert_false_rule(\n      \"rule test { condition: \\\"xxFoOxx\\\" matches /^fOo/i }\",\n      NULL);\n\n  assert_false_rule(\n      \"rule test { condition: \\\"xxFoOxx\\\" matches /fOo$/i }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: \\\"foo\\\" matches /^foo$/i }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: \\\"foo\\\\nbar\\\" matches /foo.*bar/s }\",\n      NULL);\n\n  assert_false_rule(\n      \"rule test { condition: \\\"foo\\\\nbar\\\" matches /foo.*bar/ }\",\n      NULL);\n}\n\n\nstatic void test_global_rules()\n{\n  assert_true_rule(\n      \"global private rule global_rule { \\\n        condition: \\\n          true \\\n      } \\\n      rule test { \\\n        condition: true \\\n      }\",\n      NULL);\n\n  assert_false_rule(\n      \"global private rule global_rule { \\\n        condition: \\\n          false \\\n      } \\\n      rule test { \\\n        condition: true \\\n      }\",\n      NULL);\n}\n\n\nstatic void test_modules()\n{\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.constants.one + 1 == tests.constants.two \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.constants.foo == \\\"foo\\\" \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.constants.empty == \\\"\\\"  \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.empty() == \\\"\\\"  \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.struct_array[1].i == 1  \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.struct_array[0].i == 1 or true \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.integer_array[0] == 0 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.integer_array[1] == 1 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.string_array[0] == \\\"foo\\\" \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.string_array[2] == \\\"baz\\\" \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.string_dict[\\\"foo\\\"] == \\\"foo\\\" \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.string_dict[\\\"bar\\\"] == \\\"bar\\\" \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.isum(1,2) == 3 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.isum(1,2,3) == 6 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.fsum(1.0,2.0) == 3.0 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.fsum(1.0,2.0,3.0) == 6.0 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.length(\\\"dummy\\\") == 5 \\\n      }\",\n      NULL);\n\n\n  assert_false_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.struct_array[0].i == 1  \\\n      }\",\n      NULL);\n\n  assert_false_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.isum(1,1) == 3 \\\n      }\",\n      NULL);\n\n  assert_false_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.fsum(1.0,1.0) == 3.0 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.match(/foo/,\\\"foo\\\") == 3 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.match(/foo/,\\\"bar\\\") == -1\\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.match(/foo.bar/i,\\\"FOO\\\\nBAR\\\") == -1\\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.match(/foo.bar/is,\\\"FOO\\\\nBAR\\\") == 7\\\n      }\",\n      NULL);\n\n  assert_error(\n      \"import \\\"\\\\x00\\\"\",\n      ERROR_INVALID_MODULE_NAME);\n\n  assert_error(\n      \"import \\\"\\\"\",\n      ERROR_INVALID_MODULE_NAME);\n}\n\n#if defined(HASH_MODULE)\nstatic void test_hash_module()\n{\n  uint8_t blob[] = {0x61, 0x62, 0x63, 0x64, 0x65};\n\n  assert_true_rule_blob(\n      \"import \\\"hash\\\" \\\n       rule test { \\\n        condition: \\\n          hash.md5(0, filesize) == \\\n            \\\"ab56b4d92b40713acc5af89985d4b786\\\" \\\n            and \\\n          hash.md5(1, filesize) == \\\n            \\\"e02cfbe5502b64aa5ae9f2d0d69eaa8d\\\" \\\n            and \\\n          hash.sha1(0, filesize) == \\\n            \\\"03de6c570bfe24bfc328ccd7ca46b76eadaf4334\\\" \\\n            and \\\n          hash.sha1(1, filesize) == \\\n            \\\"a302d65ae4d9e768a1538d53605f203fd8e2d6e2\\\" \\\n            and \\\n          hash.sha256(0, filesize) == \\\n            \\\"36bbe50ed96841d10443bcb670d6554f0a34b761be67ec9c4a8ad2c0c44ca42c\\\" \\\n            and \\\n          hash.sha256(1, filesize) == \\\n            \\\"aaaaf2863e043b9df604158ad5c16ff1adaf3fd7e9fcea5dcb322b6762b3b59a\\\" \\\n      }\",\n      blob);\n\n  // Test hash caching mechanism\n\n  assert_true_rule_blob(\n      \"import \\\"hash\\\" \\\n       rule test { \\\n        condition: \\\n          hash.md5(0, filesize) == \\\n            \\\"ab56b4d92b40713acc5af89985d4b786\\\" \\\n            and \\\n          hash.md5(1, filesize) == \\\n            \\\"e02cfbe5502b64aa5ae9f2d0d69eaa8d\\\" \\\n            and \\\n          hash.md5(0, filesize) == \\\n            \\\"ab56b4d92b40713acc5af89985d4b786\\\" \\\n            and \\\n          hash.md5(1, filesize) == \\\n            \\\"e02cfbe5502b64aa5ae9f2d0d69eaa8d\\\" \\\n      }\",\n      blob);\n}\n#endif\n\n\nvoid test_integer_functions()\n{\n  assert_true_rule(\n      \"rule test { condition: uint8(0) == 0xAA}\",\n      \"\\xaa\\xbb\\xcc\\xdd\");\n\n  assert_true_rule(\n      \"rule test { condition: uint16(0) == 0xBBAA}\",\n      \"\\xaa\\xbb\\xcc\\xdd\");\n\n  assert_true_rule(\n      \"rule test { condition: uint32(0) == 0xDDCCBBAA}\",\n      \"\\xaa\\xbb\\xcc\\xdd\");\n\n  assert_true_rule(\n      \"rule test { condition: uint8be(0) == 0xAA}\",\n      \"\\xaa\\xbb\\xcc\\xdd\");\n\n  assert_true_rule(\n      \"rule test { condition: uint16be(0) == 0xAABB}\",\n      \"\\xaa\\xbb\\xcc\\xdd\");\n\n  assert_true_rule(\n      \"rule test { condition: uint32be(0) == 0xAABBCCDD}\",\n      \"\\xaa\\xbb\\xcc\\xdd\");\n}\n\n\nvoid test_file_descriptor()\n{\n  YR_COMPILER* compiler = NULL;\n  YR_RULES* rules = NULL;\n\n#if defined(_WIN32) || defined(__CYGWIN__)\n  HANDLE fd = CreateFile(\"tests/data/true.yar\", GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);\n  if (fd == INVALID_HANDLE_VALUE)\n  {\n    fputs(\"CreateFile failed\", stderr);\n    exit(1);\n  }\n#else\n  int fd = open(\"tests/data/true.yar\", O_RDONLY);\n  if (fd < 0)\n  {\n    perror(\"open\");\n    exit(EXIT_FAILURE);\n  }\n#endif\n  if (yr_compiler_create(&compiler) != ERROR_SUCCESS)\n  {\n    perror(\"yr_compiler_create\");\n    exit(EXIT_FAILURE);\n  }\n\n  if (yr_compiler_add_fd(compiler, fd, NULL, NULL) != 0) {\n    perror(\"yr_compiler_add_fd\");\n    exit(EXIT_FAILURE);\n  }\n\n#if defined(_WIN32) || defined(__CYGWIN__)\n  CloseHandle(fd);\n#else\n  close(fd);\n#endif\n\n  if (yr_compiler_get_rules(compiler, &rules) != ERROR_SUCCESS) {\n    perror(\"yr_compiler_add_fd\");\n    exit(EXIT_FAILURE);\n  }\n\n  if (compiler)\n  {\n    yr_compiler_destroy(compiler);\n  }\n  if (rules)\n  {\n    yr_rules_destroy(rules);\n  }\n\n  return;\n}\n\n\nint main(int argc, char** argv)\n{\n  yr_initialize();\n\n  test_boolean_operators();\n  test_comparison_operators();\n  test_arithmetic_operators();\n  test_bitwise_operators();\n  test_matches_operator();\n  test_syntax();\n  test_anonymous_strings();\n  test_strings();\n  test_wildcard_strings();\n  test_hex_strings();\n  test_count();\n  test_at();\n  test_in();\n  test_offset();\n  test_length();\n  test_of();\n  test_for();\n  test_re();\n  test_filesize();\n  // test_compile_file();\n  // test_compile_files();\n  // test_include_files();\n  // test_externals();\n  // test_callback();\n  // test_compare();\n  test_comments();\n  test_modules();\n  test_integer_functions();\n  // test_string_io();\n  test_entrypoint();\n  test_global_rules();\n\n  #if defined(HASH_MODULE)\n  test_hash_module();\n  #endif\n\n  test_file_descriptor();\n\n  yr_finalize();\n\n  return 0;\n}\n"], "fixing_code": ["/*\nCopyright (c) 2013. The YARA Authors. All Rights Reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\nlist of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*\n\nThis module implements a structure I've called \"arena\". An arena is a data\ncontainer composed of a set of pages. The arena grows automatically when\nneeded by adding new pages to hold new data. Arenas can be saved and loaded\nfrom files.\n\n*/\n\n#include <string.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <time.h>\n\n\n#include <yara/arena.h>\n#include <yara/mem.h>\n#include <yara/error.h>\n#include <yara/limits.h>\n\n#pragma pack(push)\n#pragma pack(1)\n\ntypedef struct _ARENA_FILE_HEADER\n{\n  char      magic[4];\n  uint32_t  size;\n  uint32_t  version;\n\n} ARENA_FILE_HEADER;\n\n#pragma pack(pop)\n\n\n#define free_space(page) \\\n    ((page)->size - (page)->used)\n\n\n//\n// _yr_arena_new_page\n//\n// Creates a new arena page of a given size\n//\n// Args:\n//    size_t size  - Size of the page\n//\n// Returns:\n//    A pointer to the newly created YR_ARENA_PAGE structure\n//\n\nYR_ARENA_PAGE* _yr_arena_new_page(\n    size_t size)\n{\n  YR_ARENA_PAGE* new_page;\n\n  new_page = (YR_ARENA_PAGE*) yr_malloc(sizeof(YR_ARENA_PAGE));\n\n  if (new_page == NULL)\n    return NULL;\n\n  new_page->address = (uint8_t*) yr_malloc(size);\n\n  if (new_page->address == NULL)\n  {\n    yr_free(new_page);\n    return NULL;\n  }\n\n  new_page->size = size;\n  new_page->used = 0;\n  new_page->next = NULL;\n  new_page->prev = NULL;\n  new_page->reloc_list_head = NULL;\n  new_page->reloc_list_tail = NULL;\n\n  return new_page;\n}\n\n\n//\n// _yr_arena_page_for_address\n//\n// Returns the page within the arena where an address reside.\n//\n// Args:\n//    YR_ARENA* arena   - Pointer to the arena\n//    void* address  - Address to be located\n//\n// Returns:\n//    A pointer the corresponding YR_ARENA_PAGE structure where the address\n//    resides.\n//\n\nYR_ARENA_PAGE* _yr_arena_page_for_address(\n    YR_ARENA* arena,\n    void* address)\n{\n  YR_ARENA_PAGE* page;\n\n  // Most of the times this function is called with an address within\n  // the current page, let's check the current page first to avoid\n  // looping through the page list.\n\n  page = arena->current_page;\n\n  if (page != NULL &&\n      (uint8_t*) address >= page->address &&\n      (uint8_t*) address < page->address + page->used)\n    return page;\n\n  page = arena->page_list_head;\n\n  while (page != NULL)\n  {\n    if ((uint8_t*) address >= page->address &&\n        (uint8_t*) address < page->address + page->used)\n      return page;\n    page = page->next;\n  }\n\n  return NULL;\n}\n\n\n//\n// _yr_arena_make_relocatable\n//\n// Tells the arena that certain addresses contains a relocatable pointer.\n//\n// Args:\n//    YR_ARENA* arena    - Pointer the arena\n//    void* address      - Base address\n//    va_list offsets    - List of offsets relative to base address\n//\n// Returns:\n//    ERROR_SUCCESS if succeed or the corresponding error code otherwise.\n//\n\nint _yr_arena_make_relocatable(\n    YR_ARENA* arena,\n    void* base,\n    va_list offsets)\n{\n  YR_RELOC* reloc;\n  YR_ARENA_PAGE* page;\n\n  size_t offset;\n  size_t base_offset;\n\n  int result = ERROR_SUCCESS;\n\n  page = _yr_arena_page_for_address(arena, base);\n\n  assert(page != NULL);\n\n  base_offset = (uint8_t*) base - page->address;\n  offset = va_arg(offsets, size_t);\n\n  while (offset != -1)\n  {\n    assert(page->used >= sizeof(int64_t));\n    assert(base_offset + offset <= page->used - sizeof(int64_t));\n\n    reloc = (YR_RELOC*) yr_malloc(sizeof(YR_RELOC));\n\n    if (reloc == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    reloc->offset = (uint32_t) (base_offset + offset);\n    reloc->next = NULL;\n\n    if (page->reloc_list_head == NULL)\n      page->reloc_list_head = reloc;\n\n    if (page->reloc_list_tail != NULL)\n      page->reloc_list_tail->next = reloc;\n\n    page->reloc_list_tail = reloc;\n    offset = va_arg(offsets, size_t);\n  }\n\n  return result;\n}\n\n\n//\n// yr_arena_create\n//\n// Creates a new arena.\n//\n// Args:\n//    size_t initial_size  - Initial size\n//    int flags            - Flags\n//    YR_ARENA** arena     - Address where a pointer to the new arena will be\n//                           written to.\n//\n// Returns:\n//    ERROR_SUCCESS if succeed or the corresponding error code otherwise.\n//\n\nint yr_arena_create(\n    size_t initial_size,\n    int flags,\n    YR_ARENA** arena)\n{\n  YR_ARENA* new_arena;\n  YR_ARENA_PAGE* new_page;\n\n  *arena = NULL;\n  new_arena = (YR_ARENA*) yr_malloc(sizeof(YR_ARENA));\n\n  if (new_arena == NULL)\n    return ERROR_INSUFFICIENT_MEMORY;\n\n  new_page = _yr_arena_new_page(initial_size);\n\n  if (new_page == NULL)\n  {\n    yr_free(new_arena);\n    return ERROR_INSUFFICIENT_MEMORY;\n  }\n\n  new_arena->page_list_head = new_page;\n  new_arena->current_page = new_page;\n  new_arena->flags = flags | ARENA_FLAGS_COALESCED;\n\n  *arena = new_arena;\n  return ERROR_SUCCESS;\n}\n\n\n//\n// yr_arena_destroy\n//\n// Destroys an arena releasing its resource.\n//\n// Args:\n//    YR_ARENA* arena  - Pointer to the arena.\n//\n// Returns:\n//    ERROR_SUCCESS if succeed or the corresponding error code otherwise.\n//\n\nvoid yr_arena_destroy(\n    YR_ARENA* arena)\n{\n  YR_RELOC* reloc;\n  YR_RELOC* next_reloc;\n  YR_ARENA_PAGE* page;\n  YR_ARENA_PAGE* next_page;\n\n  if (arena == NULL)\n    return;\n\n  page = arena->page_list_head;\n\n  while(page != NULL)\n  {\n    next_page = page->next;\n    reloc = page->reloc_list_head;\n\n    while (reloc != NULL)\n    {\n      next_reloc = reloc->next;\n      yr_free(reloc);\n      reloc = next_reloc;\n    }\n\n    yr_free(page->address);\n    yr_free(page);\n\n    page = next_page;\n  }\n\n  yr_free(arena);\n}\n\n\n//\n// yr_arena_base_address\n//\n// Returns the base address for the arena.\n//\n// Args:\n//    YR_ARENA* arena  - Pointer to the arena.\n//\n// Returns:\n//    A pointer to the arena's data. NULL if no data has been written to\n//    the arena yet.\n//\n\nvoid* yr_arena_base_address(\n  YR_ARENA* arena)\n{\n  if (arena->page_list_head->used == 0)\n    return NULL;\n\n  return arena->page_list_head->address;\n}\n\n\n//\n// yr_arena_next_address\n//\n// Given an address and an offset, returns the address where\n// address + offset resides. The arena is a collection of non-contiguous\n// regions of memory (pages), if address is pointing at the end of a page,\n// address + offset could cross the page boundary and point at somewhere\n// within the next page, this function handles these situations. It works\n// also with negative offsets.\n//\n// Args:\n//    YR_ARENA* arena  - Pointer to the arena.\n//    void* address    - Base address.\n//    int offset       - Offset.\n//\n// Returns:\n//    A pointer\n//\n\n\nvoid* yr_arena_next_address(\n  YR_ARENA* arena,\n  void* address,\n  size_t offset)\n{\n  YR_ARENA_PAGE* page;\n\n  page = _yr_arena_page_for_address(arena, address);\n\n  assert(page != NULL);\n\n  if ((uint8_t*) address + offset >= page->address &&\n      (uint8_t*) address + offset < page->address + page->used)\n  {\n    return (uint8_t*) address + offset;\n  }\n\n  if (offset > 0)\n  {\n    offset -= page->address + page->used - (uint8_t*) address;\n    page = page->next;\n\n    while (page != NULL)\n    {\n      if (offset < page->used)\n        return page->address + offset;\n\n      offset -= page->used;\n      page = page->next;\n    }\n  }\n  else\n  {\n    offset += page->used;\n    page = page->prev;\n\n    while (page != NULL)\n    {\n      if (offset < page->used)\n        return page->address + page->used + offset;\n\n      offset += page->used;\n      page = page->prev;\n    }\n  }\n\n  return NULL;\n}\n\n\n//\n// yr_arena_coalesce\n//\n// Coalesce the arena into a single page. This is a required step before\n// saving the arena to a file.\n//\n// Args:\n//    YR_ARENA* arena  - Pointer to the arena.\n//\n// Returns:\n//    ERROR_SUCCESS if succeed or the corresponding error code otherwise.\n//\n\nint yr_arena_coalesce(\n    YR_ARENA* arena)\n{\n  YR_ARENA_PAGE* page;\n  YR_ARENA_PAGE* big_page;\n  YR_ARENA_PAGE* next_page;\n  YR_RELOC* reloc;\n\n  uint8_t** reloc_address;\n  uint8_t* reloc_target;\n  size_t total_size = 0;\n\n  page = arena->page_list_head;\n\n  while(page != NULL)\n  {\n    total_size += page->used;\n    page = page->next;\n  }\n\n  // Create a new page that will contain the entire arena.\n  big_page = _yr_arena_new_page(total_size);\n\n  if (big_page == NULL)\n    return ERROR_INSUFFICIENT_MEMORY;\n\n  // Copy data from current pages to the big page and adjust relocs.\n  page = arena->page_list_head;\n\n  while (page != NULL)\n  {\n    page->new_address = big_page->address + big_page->used;\n    memcpy(page->new_address, page->address, page->used);\n\n    reloc = page->reloc_list_head;\n\n    while(reloc != NULL)\n    {\n      reloc->offset += (uint32_t) big_page->used;\n      reloc = reloc->next;\n    }\n\n    if (big_page->reloc_list_head == NULL)\n      big_page->reloc_list_head = page->reloc_list_head;\n\n    if (big_page->reloc_list_tail != NULL)\n      big_page->reloc_list_tail->next = page->reloc_list_head;\n\n    if (page->reloc_list_tail != NULL)\n      big_page->reloc_list_tail = page->reloc_list_tail;\n\n    big_page->used += page->used;\n    page = page->next;\n  }\n\n  // Relocate pointers.\n  reloc = big_page->reloc_list_head;\n\n  while (reloc != NULL)\n  {\n    reloc_address = (uint8_t**) (big_page->address + reloc->offset);\n    reloc_target = *reloc_address;\n\n    if (reloc_target != NULL)\n    {\n      page = _yr_arena_page_for_address(arena, reloc_target);\n      assert(page != NULL);\n      *reloc_address = page->new_address + (reloc_target - page->address);\n    }\n\n    reloc = reloc->next;\n  }\n\n  // Release current pages.\n  page = arena->page_list_head;\n\n  while(page != NULL)\n  {\n    next_page = page->next;\n    yr_free(page->address);\n    yr_free(page);\n    page = next_page;\n  }\n\n  arena->page_list_head = big_page;\n  arena->current_page = big_page;\n  arena->flags |= ARENA_FLAGS_COALESCED;\n\n  return ERROR_SUCCESS;\n}\n\n\n//\n// yr_arena_reserve_memory\n//\n// Ensures that the arena have enough contiguous memory for future allocations.\n// if the available space in the current page is lower than \"size\", a new page\n// is allocated.\n//\n// Args:\n//    YR_ARENA* arena         - Pointer to the arena.\n//    size_t size             - Size of the region to be reserved.\n//\n// Returns:\n//    ERROR_SUCCESS if succeed or the corresponding error code otherwise.\n//\n\n\nint yr_arena_reserve_memory(\n    YR_ARENA* arena,\n    size_t size)\n{\n  YR_ARENA_PAGE* new_page;\n  size_t new_page_size;\n  uint8_t* new_page_address;\n\n  if (size > free_space(arena->current_page))\n  {\n    if (arena->flags & ARENA_FLAGS_FIXED_SIZE)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    // Requested space is bigger than current page's empty space,\n    // lets calculate the size for a new page.\n\n    new_page_size = arena->current_page->size * 2;\n\n    while (new_page_size < size)\n      new_page_size *= 2;\n\n    if (arena->current_page->used == 0)\n    {\n      // Current page is not used at all, it can be reallocated.\n\n      new_page_address = (uint8_t*) yr_realloc(\n          arena->current_page->address,\n          new_page_size);\n\n      if (new_page_address == NULL)\n        return ERROR_INSUFFICIENT_MEMORY;\n\n      arena->current_page->address = new_page_address;\n      arena->current_page->size = new_page_size;\n    }\n    else\n    {\n      new_page = _yr_arena_new_page(new_page_size);\n\n      if (new_page == NULL)\n        return ERROR_INSUFFICIENT_MEMORY;\n\n      new_page->prev = arena->current_page;\n      arena->current_page->next = new_page;\n      arena->current_page = new_page;\n      arena->flags &= ~ARENA_FLAGS_COALESCED;\n    }\n  }\n\n  return ERROR_SUCCESS;\n}\n\n\n//\n// yr_arena_allocate_memory\n//\n// Allocates memory within the arena.\n//\n// Args:\n//    YR_ARENA* arena         - Pointer to the arena.\n//    size_t size             - Size of the region to be allocated.\n//    void** allocated_memory - Address of a pointer to newly allocated\n//                              region.\n// Returns:\n//    ERROR_SUCCESS if succeed or the corresponding error code otherwise.\n//\n\nint yr_arena_allocate_memory(\n    YR_ARENA* arena,\n    size_t size,\n    void** allocated_memory)\n{\n  FAIL_ON_ERROR(yr_arena_reserve_memory(arena, size));\n\n  *allocated_memory = arena->current_page->address + \\\n                      arena->current_page->used;\n\n  arena->current_page->used += size;\n\n  return ERROR_SUCCESS;\n}\n\n\n//\n// yr_arena_allocate_struct\n//\n// Allocates a structure within the arena. This function is similar to\n// yr_arena_allocate_memory but additionally receives a variable-length\n// list of offsets within the structure where pointers reside. This allows\n// the arena to keep track of pointers that must be adjusted when memory\n// is relocated. This is an example on how to invoke this function:\n//\n//  yr_arena_allocate_struct(\n//        arena,\n//        sizeof(MY_STRUCTURE),\n//        (void**) &my_structure_ptr,\n//        offsetof(MY_STRUCTURE, field_1),\n//        offsetof(MY_STRUCTURE, field_2),\n//        ..\n//        offsetof(MY_STRUCTURE, field_N),\n//        EOL);\n//\n// Args:\n//    YR_ARENA* arena         - Pointer to the arena.\n//    size_t size             - Size of the region to be allocated.\n//    void** allocated_memory - Address of a pointer to newly allocated\n//                              region.\n//    ...                     - Variable number of offsets relative to the\n//                              beginning of the struct. Offsets are of type\n//                              size_t.\n//\n// Returns:\n//    ERROR_SUCCESS if succeed or the corresponding error code otherwise.\n//\n\nint yr_arena_allocate_struct(\n    YR_ARENA* arena,\n    size_t size,\n    void** allocated_memory,\n    ...)\n{\n  int result;\n\n  va_list offsets;\n  va_start(offsets, allocated_memory);\n\n  result = yr_arena_allocate_memory(arena, size, allocated_memory);\n\n  if (result == ERROR_SUCCESS)\n    result = _yr_arena_make_relocatable(arena, *allocated_memory, offsets);\n\n  va_end(offsets);\n\n  if (result == ERROR_SUCCESS)\n    memset(*allocated_memory, 0, size);\n\n  return result;\n}\n\n\n//\n// yr_arena_make_relocatable\n//\n// Tells the arena that certain addresses contains a relocatable pointer.\n//\n// Args:\n//    YR_ARENA* arena    - Pointer to the arena.\n//    void* base         - Address within the arena.\n//    ...                - Variable number of size_t arguments with offsets\n//                         relative to base.\n//\n// Returns:\n//    ERROR_SUCCESS if succeed or the corresponding error code otherwise.\n//\n\nint yr_arena_make_relocatable(\n    YR_ARENA* arena,\n    void* base,\n    ...)\n{\n  int result;\n\n  va_list offsets;\n  va_start(offsets, base);\n\n  result = _yr_arena_make_relocatable(arena, base, offsets);\n\n  va_end(offsets);\n\n  return result;\n}\n\n\n//\n// yr_arena_write_data\n//\n// Writes data to the arena.\n//\n// Args:\n//    YR_ARENA* arena        - Pointer to the arena.\n//    void* data             - Pointer to data to be written.\n//    size_t size            - Size of data.\n//    void** written_data    - Address where a pointer to the written data will\n//                             be returned.\n//\n// Returns:\n//    ERROR_SUCCESS if succeed or the corresponding error code otherwise.\n//\n\nint yr_arena_write_data(\n    YR_ARENA* arena,\n    void* data,\n    size_t size,\n    void** written_data)\n{\n  void* output;\n  int result;\n\n  if (size > free_space(arena->current_page))\n  {\n    result = yr_arena_allocate_memory(arena, size, &output);\n\n    if (result != ERROR_SUCCESS)\n      return result;\n  }\n  else\n  {\n    output = arena->current_page->address + arena->current_page->used;\n    arena->current_page->used += size;\n  }\n\n  memcpy(output, data, size);\n\n  if (written_data != NULL)\n    *written_data = output;\n\n  return ERROR_SUCCESS;\n}\n\n\n//\n// yr_arena_write_string\n//\n// Writes string to the arena.\n//\n// Args:\n//    YR_ARENA* arena        - Pointer to the arena.\n//    const char* string     - Pointer to string to be written.\n//    char** written_string  - Address where a pointer to the written data will\n//                             be returned.\n//\n// Returns:\n//    ERROR_SUCCESS if succeed or the corresponding error code otherwise.\n//\n\nint yr_arena_write_string(\n    YR_ARENA* arena,\n    const char* string,\n    char** written_string)\n{\n  return yr_arena_write_data(\n      arena,\n      (void*) string,\n      strlen(string) + 1,\n      (void**) written_string);\n}\n\n\n//\n// yr_arena_append\n//\n// Appends source_arena to target_arena. This operation destroys source_arena,\n// after returning any pointer to source_arena is no longer valid. The data\n// from source_arena is guaranteed to be aligned to a 16 bytes boundary when\n// written to the source_arena\n//\n// Args:\n//    YR_ARENA* target_arena    - Pointer to target the arena.\n//    YR_ARENA* source_arena    - Pointer to source arena.\n//\n// Returns:\n//    ERROR_SUCCESS if succeed or the corresponding error code otherwise.\n//\n\nint yr_arena_append(\n    YR_ARENA* target_arena,\n    YR_ARENA* source_arena)\n{\n  uint8_t padding_data[15];\n  size_t padding_size = 16 - target_arena->current_page->used % 16;\n\n  if (padding_size < 16)\n  {\n    memset(&padding_data, 0xCC, padding_size);\n\n    FAIL_ON_ERROR(yr_arena_write_data(\n        target_arena,\n        padding_data,\n        padding_size,\n        NULL));\n  }\n\n  target_arena->current_page->next = source_arena->page_list_head;\n  source_arena->page_list_head->prev = target_arena->current_page;\n  target_arena->current_page = source_arena->current_page;\n\n  yr_free(source_arena);\n\n  return ERROR_SUCCESS;\n}\n\n\n//\n// yr_arena_duplicate\n//\n// Duplicates the arena, making an exact copy. This function requires the\n// arena to be coalesced.\n//\n// Args:\n//    YR_ARENA* arena        - Pointer to the arena.\n//    YR_ARENA** duplicated  - Address where a pointer to the new arena arena\n//                             will be returned.\n//\n// Returns:\n//    ERROR_SUCCESS if succeed or the corresponding error code otherwise.\n//\n\nint yr_arena_duplicate(\n    YR_ARENA* arena,\n    YR_ARENA** duplicated)\n{\n  YR_RELOC* reloc;\n  YR_RELOC* new_reloc;\n  YR_ARENA_PAGE* page;\n  YR_ARENA_PAGE* new_page;\n  YR_ARENA* new_arena;\n  uint8_t** reloc_address;\n  uint8_t* reloc_target;\n\n  // Only coalesced arenas can be duplicated.\n  assert(arena->flags & ARENA_FLAGS_COALESCED);\n\n  page = arena->page_list_head;\n\n  FAIL_ON_ERROR(yr_arena_create(page->size, arena->flags, &new_arena));\n\n  new_page = new_arena->current_page;\n  new_page->used = page->used;\n\n  memcpy(new_page->address, page->address, page->size);\n\n  reloc = page->reloc_list_head;\n\n  while (reloc != NULL)\n  {\n    new_reloc = (YR_RELOC*) yr_malloc(sizeof(YR_RELOC));\n\n    if (new_reloc == NULL)\n    {\n      yr_arena_destroy(new_arena);\n      return ERROR_INSUFFICIENT_MEMORY;\n    }\n\n    new_reloc->offset = reloc->offset;\n    new_reloc->next = NULL;\n\n    if (new_page->reloc_list_head == NULL)\n      new_page->reloc_list_head = new_reloc;\n\n    if (new_page->reloc_list_tail != NULL)\n      new_page->reloc_list_tail->next = new_reloc;\n\n    new_page->reloc_list_tail = new_reloc;\n\n    reloc_address = (uint8_t**) (new_page->address + new_reloc->offset);\n    reloc_target = *reloc_address;\n\n    if (reloc_target != NULL)\n    {\n      assert(reloc_target >= page->address);\n      assert(reloc_target < page->address + page->used);\n\n      *reloc_address = reloc_target - \\\n                       page->address + \\\n                       new_page->address;\n    }\n\n    reloc = reloc->next;\n  }\n\n  *duplicated = new_arena;\n\n  return ERROR_SUCCESS;\n}\n\n\n//\n// yr_arena_load_stream\n//\n// Loads an arena from a stream.\n//\n// Args:\n//    YR_STREAM* stream  - Pointer to stream object\n//    YR_ARENA**         - Address where a pointer to the loaded arena\n//                         will be returned\n//\n// Returns:\n//    ERROR_SUCCESS if successful, appropriate error code otherwise.\n//\n\nint yr_arena_load_stream(\n    YR_STREAM* stream,\n    YR_ARENA** arena)\n{\n  YR_ARENA_PAGE* page;\n  YR_ARENA* new_arena;\n  ARENA_FILE_HEADER header;\n\n  uint32_t reloc_offset;\n  uint8_t** reloc_address;\n  uint8_t* reloc_target;\n\n  int result;\n\n  if (yr_stream_read(&header, sizeof(header), 1, stream) != 1)\n    return ERROR_INVALID_FILE;\n\n  if (header.magic[0] != 'Y' ||\n      header.magic[1] != 'A' ||\n      header.magic[2] != 'R' ||\n      header.magic[3] != 'A')\n  {\n    return ERROR_INVALID_FILE;\n  }\n\n  if (header.size < 2048)       // compiled rules are always larger than 2KB\n    return ERROR_CORRUPT_FILE;\n\n  if (header.version != ARENA_FILE_VERSION)\n    return ERROR_UNSUPPORTED_FILE_VERSION;\n\n  result = yr_arena_create(header.size, 0, &new_arena);\n\n  if (result != ERROR_SUCCESS)\n    return result;\n\n  page = new_arena->current_page;\n\n  if (yr_stream_read(page->address, header.size, 1, stream) != 1)\n  {\n    yr_arena_destroy(new_arena);\n    return ERROR_CORRUPT_FILE;\n  }\n\n  page->used = header.size;\n\n  if (yr_stream_read(&reloc_offset, sizeof(reloc_offset), 1, stream) != 1)\n  {\n    yr_arena_destroy(new_arena);\n    return ERROR_CORRUPT_FILE;\n  }\n\n  while (reloc_offset != 0xFFFFFFFF)\n  {\n    if (reloc_offset > header.size - sizeof(uint8_t*))\n    {\n      yr_arena_destroy(new_arena);\n      return ERROR_CORRUPT_FILE;\n    }\n\n    yr_arena_make_relocatable(new_arena, page->address, reloc_offset, EOL);\n\n    reloc_address = (uint8_t**) (page->address + reloc_offset);\n    reloc_target = *reloc_address;\n\n    if (reloc_target != (uint8_t*) (size_t) 0xFFFABADA)\n      *reloc_address += (size_t) page->address;\n    else\n      *reloc_address = 0;\n\n    if (yr_stream_read(&reloc_offset, sizeof(reloc_offset), 1, stream) != 1)\n    {\n      yr_arena_destroy(new_arena);\n      return ERROR_CORRUPT_FILE;\n    }\n  }\n\n  *arena = new_arena;\n\n  return ERROR_SUCCESS;\n}\n\n\n//\n// yr_arena_save_stream\n//\n// Saves the arena into a stream. If the file exists its overwritten. This\n// function requires the arena to be coalesced.\n//\n// Args:\n//    YR_ARENA* arena         - Pointer to the arena.\n//    YR_STREAM* stream       - Pointer to stream object.\n//\n// Returns:\n//    ERROR_SUCCESS if succeed or the corresponding error code otherwise.\n//\n\nint yr_arena_save_stream(\n  YR_ARENA* arena,\n  YR_STREAM* stream)\n{\n  YR_ARENA_PAGE* page;\n  YR_RELOC* reloc;\n  ARENA_FILE_HEADER header;\n\n  uint32_t end_marker = 0xFFFFFFFF;\n  uint8_t** reloc_address;\n  uint8_t* reloc_target;\n\n  // Only coalesced arenas can be saved.\n  assert(arena->flags & ARENA_FLAGS_COALESCED);\n\n  page = arena->page_list_head;\n  reloc = page->reloc_list_head;\n\n  // Convert pointers to offsets before saving.\n  while (reloc != NULL)\n  {\n    reloc_address = (uint8_t**) (page->address + reloc->offset);\n    reloc_target = *reloc_address;\n\n    if (reloc_target != NULL)\n    {\n      assert(reloc_target >= page->address);\n      assert(reloc_target < page->address + page->used);\n      *reloc_address = (uint8_t*) (*reloc_address - page->address);\n    }\n    else\n    {\n      *reloc_address = (uint8_t*) (size_t) 0xFFFABADA;\n    }\n\n    reloc = reloc->next;\n  }\n\n  assert(page->size < 0x80000000);  // 2GB\n\n  header.magic[0] = 'Y';\n  header.magic[1] = 'A';\n  header.magic[2] = 'R';\n  header.magic[3] = 'A';\n  header.size = (int32_t) page->size;\n  header.version = ARENA_FILE_VERSION;\n\n  yr_stream_write(&header, sizeof(header), 1, stream);\n  yr_stream_write(page->address, header.size, 1, stream);\n\n  reloc = page->reloc_list_head;\n\n  // Convert offsets back to pointers.\n  while (reloc != NULL)\n  {\n    yr_stream_write(&reloc->offset, sizeof(reloc->offset), 1, stream);\n\n    reloc_address = (uint8_t**) (page->address + reloc->offset);\n    reloc_target = *reloc_address;\n\n    if (reloc_target != (void*) (size_t) 0xFFFABADA)\n      *reloc_address += (size_t) page->address;\n    else\n      *reloc_address = 0;\n\n    reloc = reloc->next;\n  }\n\n  yr_stream_write(&end_marker, sizeof(end_marker), 1, stream);\n\n  return ERROR_SUCCESS;\n}\n", "/*\nCopyright (c) 2013-2014. The YARA Authors. All Rights Reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\nlist of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#define _GNU_SOURCE\n\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n#include <math.h>\n\n#include <yara/arena.h>\n#include <yara/endian.h>\n#include <yara/exec.h>\n#include <yara/limits.h>\n#include <yara/error.h>\n#include <yara/object.h>\n#include <yara/modules.h>\n#include <yara/re.h>\n#include <yara/strutils.h>\n#include <yara/utils.h>\n#include <yara/mem.h>\n\n#include <yara.h>\n\n\n#define MEM_SIZE   MAX_LOOP_NESTING * LOOP_LOCAL_VARS\n\n\n#define push(x)  \\\n    if (sp < stack_size) \\\n    { \\\n      stack[sp++] = (x); \\\n    } \\\n    else \\\n    { \\\n      result = ERROR_EXEC_STACK_OVERFLOW; \\\n      stop = TRUE; \\\n      break; \\\n    } \\\n\n\n#define pop(x)  x = stack[--sp]\n\n#define is_undef(x) IS_UNDEFINED((x).i)\n\n#define ensure_defined(x) \\\n    if (is_undef(x)) \\\n    { \\\n      r1.i = UNDEFINED; \\\n      push(r1); \\\n      break; \\\n    }\n\n\n#define little_endian_uint8_t(x)     (x)\n#define little_endian_int8_t(x)      (x)\n#define little_endian_uint16_t(x)    yr_le16toh(x)\n#define little_endian_int16_t(x)     yr_le16toh(x)\n#define little_endian_uint32_t(x)    yr_le32toh(x)\n#define little_endian_int32_t(x)     yr_le32toh(x)\n\n#define big_endian_uint8_t(x)        (x)\n#define big_endian_int8_t(x)         (x)\n#define big_endian_uint16_t(x)       yr_be16toh(x)\n#define big_endian_int16_t(x)        yr_be16toh(x)\n#define big_endian_uint32_t(x)       yr_be32toh(x)\n#define big_endian_int32_t(x)        yr_be32toh(x)\n\n\n#define function_read(type, endianess) \\\n    int64_t read_##type##_##endianess(YR_MEMORY_BLOCK_ITERATOR* iterator, size_t offset) \\\n    { \\\n      YR_MEMORY_BLOCK* block = iterator->first(iterator); \\\n      while (block != NULL) \\\n      { \\\n        if (offset >= block->base && \\\n            block->size >= sizeof(type) && \\\n            offset <= block->base + block->size - sizeof(type)) \\\n        { \\\n          type result; \\\n          uint8_t* data = block->fetch_data(block); \\\n          if (data == NULL) \\\n            return UNDEFINED; \\\n          result = *(type *)(data + offset - block->base); \\\n          result = endianess##_##type(result); \\\n          return result; \\\n        } \\\n        block = iterator->next(iterator); \\\n      } \\\n      return UNDEFINED; \\\n    };\n\n\nfunction_read(uint8_t, little_endian)\nfunction_read(uint16_t, little_endian)\nfunction_read(uint32_t, little_endian)\nfunction_read(int8_t, little_endian)\nfunction_read(int16_t, little_endian)\nfunction_read(int32_t, little_endian)\nfunction_read(uint8_t, big_endian)\nfunction_read(uint16_t, big_endian)\nfunction_read(uint32_t, big_endian)\nfunction_read(int8_t, big_endian)\nfunction_read(int16_t, big_endian)\nfunction_read(int32_t, big_endian)\n\n\nstatic uint8_t* jmp_if(\n    int condition,\n    uint8_t* ip)\n{\n  uint8_t* result;\n\n  if (condition)\n  {\n    result = *(uint8_t**)(ip + 1);\n\n    // ip will be incremented at the end of the execution loop,\n    // decrement it here to compensate.\n\n    result--;\n  }\n  else\n  {\n    result = ip + sizeof(uint64_t);\n  }\n\n  return result;\n}\n\n\nint yr_execute_code(\n    YR_RULES* rules,\n    YR_SCAN_CONTEXT* context,\n    int timeout,\n    time_t start_time)\n{\n  int64_t mem[MEM_SIZE];\n  int32_t sp = 0;\n  uint8_t* ip = rules->code_start;\n\n  YR_VALUE args[MAX_FUNCTION_ARGS];\n  YR_VALUE *stack;\n  YR_VALUE r1;\n  YR_VALUE r2;\n  YR_VALUE r3;\n\n  #ifdef PROFILING_ENABLED\n  YR_RULE* current_rule = NULL;\n  #endif\n\n  YR_RULE* rule;\n  YR_MATCH* match;\n  YR_OBJECT_FUNCTION* function;\n  YR_OBJECT** obj_ptr;\n  YR_ARENA* obj_arena;\n\n  char* identifier;\n  char* args_fmt;\n\n  int i;\n  int found;\n  int count;\n  int result = ERROR_SUCCESS;\n  int stop = FALSE;\n  int cycle = 0;\n  int tidx = context->tidx;\n  int stack_size;\n\n  #ifdef PROFILING_ENABLED\n  clock_t start = clock();\n  #endif\n\n  yr_get_configuration(YR_CONFIG_STACK_SIZE, (void*) &stack_size);\n\n  stack = (YR_VALUE*) yr_malloc(stack_size * sizeof(YR_VALUE));\n\n  if (stack == NULL)\n    return ERROR_INSUFFICIENT_MEMORY;\n\n  FAIL_ON_ERROR_WITH_CLEANUP(\n      yr_arena_create(1024, 0, &obj_arena),\n      yr_free(stack));\n\n  while(!stop)\n  {\n    switch(*ip)\n    {\n      case OP_NOP:\n        break;\n        \n      case OP_HALT:\n        assert(sp == 0); // When HALT is reached the stack should be empty.\n        stop = TRUE;\n        break;\n\n      case OP_PUSH:\n        r1.i = *(uint64_t*)(ip + 1);\n        ip += sizeof(uint64_t);\n        push(r1);\n        break;\n\n      case OP_POP:\n        pop(r1);\n        break;\n\n      case OP_CLEAR_M:\n        r1.i = *(uint64_t*)(ip + 1);\n        ip += sizeof(uint64_t);\n        mem[r1.i] = 0;\n        break;\n\n      case OP_ADD_M:\n        r1.i = *(uint64_t*)(ip + 1);\n        ip += sizeof(uint64_t);\n        pop(r2);\n        if (!is_undef(r2))\n          mem[r1.i] += r2.i;\n        break;\n\n      case OP_INCR_M:\n        r1.i = *(uint64_t*)(ip + 1);\n        ip += sizeof(uint64_t);\n        mem[r1.i]++;\n        break;\n\n      case OP_PUSH_M:\n        r1.i = *(uint64_t*)(ip + 1);\n        ip += sizeof(uint64_t);\n        r1.i = mem[r1.i];\n        push(r1);\n        break;\n\n      case OP_POP_M:\n        r1.i = *(uint64_t*)(ip + 1);\n        ip += sizeof(uint64_t);\n        pop(r2);\n        mem[r1.i] = r2.i;\n        break;\n\n      case OP_SWAPUNDEF:\n        r1.i = *(uint64_t*)(ip + 1);\n        ip += sizeof(uint64_t);\n        pop(r2);\n\n        if (is_undef(r2))\n        {\n          r1.i = mem[r1.i];\n          push(r1);\n        }\n        else\n        {\n          push(r2);\n        }\n        break;\n\n      case OP_JNUNDEF:\n        pop(r1);\n        push(r1);\n\n        ip = jmp_if(!is_undef(r1), ip);\n        break;\n\n      case OP_JLE:\n        pop(r2);\n        pop(r1);\n        push(r1);\n        push(r2);\n\n        ip = jmp_if(r1.i <= r2.i, ip);\n        break;\n\n      case OP_JTRUE:\n        pop(r1);\n        push(r1);\n\n        ip = jmp_if(!is_undef(r1) && r1.i, ip);\n        break;\n\n      case OP_JFALSE:\n        pop(r1);\n        push(r1);\n\n        ip = jmp_if(is_undef(r1) || !r1.i, ip);\n        break;\n\n      case OP_AND:\n        pop(r2);\n        pop(r1);\n\n        if (is_undef(r1) || is_undef(r2))\n          r1.i = 0;\n        else\n          r1.i = r1.i && r2.i;\n\n        push(r1);\n        break;\n\n      case OP_OR:\n        pop(r2);\n        pop(r1);\n\n        if (is_undef(r1))\n        {\n          push(r2);\n        }\n        else if (is_undef(r2))\n        {\n          push(r1);\n        }\n        else\n        {\n          r1.i = r1.i || r2.i;\n          push(r1);\n        }\n        break;\n\n      case OP_NOT:\n        pop(r1);\n\n        if (is_undef(r1))\n          r1.i = UNDEFINED;\n        else\n          r1.i= !r1.i;\n\n        push(r1);\n        break;\n\n      case OP_MOD:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        if (r2.i != 0)\n          r1.i = r1.i % r2.i;\n        else\n          r1.i = UNDEFINED;\n        push(r1);\n        break;\n\n      case OP_SHR:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i >> r2.i;\n        push(r1);\n        break;\n\n      case OP_SHL:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i << r2.i;\n        push(r1);\n        break;\n\n      case OP_BITWISE_NOT:\n        pop(r1);\n        ensure_defined(r1);\n        r1.i = ~r1.i;\n        push(r1);\n        break;\n\n      case OP_BITWISE_AND:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i & r2.i;\n        push(r1);\n        break;\n\n      case OP_BITWISE_OR:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i | r2.i;\n        push(r1);\n        break;\n\n      case OP_BITWISE_XOR:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i ^ r2.i;\n        push(r1);\n        break;\n\n      case OP_PUSH_RULE:\n        rule = *(YR_RULE**)(ip + 1);\n        ip += sizeof(uint64_t);\n        r1.i = rule->t_flags[tidx] & RULE_TFLAGS_MATCH ? 1 : 0;\n        push(r1);\n        break;\n\n      case OP_INIT_RULE:\n        #ifdef PROFILING_ENABLED\n        current_rule = *(YR_RULE**)(ip + 1);\n        #endif\n        ip += sizeof(uint64_t);\n        break;\n\n      case OP_MATCH_RULE:\n        pop(r1);\n        rule = *(YR_RULE**)(ip + 1);\n        ip += sizeof(uint64_t);\n\n        if (!is_undef(r1) && r1.i)\n          rule->t_flags[tidx] |= RULE_TFLAGS_MATCH;\n        else if (RULE_IS_GLOBAL(rule))\n          rule->ns->t_flags[tidx] |= NAMESPACE_TFLAGS_UNSATISFIED_GLOBAL;\n\n        #ifdef PROFILING_ENABLED\n        rule->clock_ticks += clock() - start;\n        start = clock();\n        #endif\n\n        assert(sp == 0);\n        break;\n\n      case OP_OBJ_LOAD:\n        identifier = *(char**)(ip + 1);\n        ip += sizeof(uint64_t);\n\n        r1.o = (YR_OBJECT*) yr_hash_table_lookup(\n            context->objects_table,\n            identifier,\n            NULL);\n\n        assert(r1.o != NULL);\n        push(r1);\n        break;\n\n      case OP_OBJ_FIELD:\n        identifier = *(char**)(ip + 1);\n        ip += sizeof(uint64_t);\n\n        pop(r1);\n        ensure_defined(r1);\n\n        r1.o = yr_object_lookup_field(r1.o, identifier);\n\n        assert(r1.o != NULL);\n        push(r1);\n        break;\n\n      case OP_OBJ_VALUE:\n        pop(r1);\n        ensure_defined(r1);\n\n        switch(r1.o->type)\n        {\n          case OBJECT_TYPE_INTEGER:\n            r1.i = ((YR_OBJECT_INTEGER*) r1.o)->value;\n            break;\n\n          case OBJECT_TYPE_FLOAT:\n            if (isnan(((YR_OBJECT_DOUBLE*) r1.o)->value))\n              r1.i = UNDEFINED;\n            else\n              r1.d = ((YR_OBJECT_DOUBLE*) r1.o)->value;\n            break;\n\n          case OBJECT_TYPE_STRING:\n            if (((YR_OBJECT_STRING*) r1.o)->value == NULL)\n              r1.i = UNDEFINED;\n            else\n              r1.p = ((YR_OBJECT_STRING*) r1.o)->value;\n            break;\n\n          default:\n            assert(FALSE);\n        }\n\n        push(r1);\n        break;\n\n      case OP_INDEX_ARRAY:\n        pop(r1);  // index\n        pop(r2);  // array\n\n        ensure_defined(r1);\n        ensure_defined(r2);\n        assert(r2.o->type == OBJECT_TYPE_ARRAY);\n\n        r1.o = yr_object_array_get_item(r2.o, 0, (int) r1.i);\n\n        if (r1.o == NULL)\n          r1.i = UNDEFINED;\n\n        push(r1);\n        break;\n\n      case OP_LOOKUP_DICT:\n        pop(r1);  // key\n        pop(r2);  // dictionary\n\n        ensure_defined(r1);\n        ensure_defined(r2);\n        assert(r2.o->type == OBJECT_TYPE_DICTIONARY);\n\n        r1.o = yr_object_dict_get_item(\n            r2.o, 0, r1.ss->c_string);\n\n        if (r1.o == NULL)\n          r1.i = UNDEFINED;\n\n        push(r1);\n        break;\n\n      case OP_CALL:\n        args_fmt = *(char**)(ip + 1);\n        ip += sizeof(uint64_t);\n\n        i = (int) strlen(args_fmt);\n        count = 0;\n\n        // pop arguments from stack and copy them to args array\n\n        while (i > 0)\n        {\n          pop(r1);\n\n          if (is_undef(r1))  // count the number of undefined args\n            count++;\n\n          args[i - 1] = r1;\n          i--;\n        }\n\n        pop(r2);\n        ensure_defined(r2);\n\n        if (count > 0)\n        {\n          // if there are undefined args, result for function call\n          // is undefined as well.\n\n          r1.i = UNDEFINED;\n          push(r1);\n          break;\n        }\n\n        function = (YR_OBJECT_FUNCTION*) r2.o;\n        result = ERROR_INTERNAL_FATAL_ERROR;\n\n        for (i = 0; i < MAX_OVERLOADED_FUNCTIONS; i++)\n        {\n          if (function->prototypes[i].arguments_fmt == NULL)\n            break;\n\n          if (strcmp(function->prototypes[i].arguments_fmt, args_fmt) == 0)\n          {\n            result = function->prototypes[i].code(args, context, function);\n            break;\n          }\n        }\n\n        // if i == MAX_OVERLOADED_FUNCTIONS at this point no matching\n        // prototype was found, but this shouldn't happen.\n\n        assert(i < MAX_OVERLOADED_FUNCTIONS);\n\n        // make a copy of the returned object and push the copy into the stack\n        // function->return_obj can't be pushed because it can change in\n        // subsequent calls to the same function.\n\n        if (result == ERROR_SUCCESS)\n          result = yr_object_copy(function->return_obj, &r1.o);\n\n        // a pointer to the copied object is stored in a arena in order to\n        // free the object before exiting yr_execute_code\n\n        if (result == ERROR_SUCCESS)\n          result = yr_arena_write_data(obj_arena, &r1.o, sizeof(r1.o), NULL);\n\n        stop = (result != ERROR_SUCCESS);\n        push(r1);\n        break;\n\n      case OP_FOUND:\n        pop(r1);\n        r1.i = r1.s->matches[tidx].tail != NULL ? 1 : 0;\n        push(r1);\n        break;\n\n      case OP_FOUND_AT:\n        pop(r2);\n        pop(r1);\n\n        if (is_undef(r1))\n        {\n          r1.i = 0;\n          push(r1);\n          break;\n        }\n\n        match = r2.s->matches[tidx].head;\n        r3.i = FALSE;\n\n        while (match != NULL)\n        {\n          if (r1.i == match->base + match->offset)\n          {\n            r3.i = TRUE;\n            break;\n          }\n\n          if (r1.i < match->base + match->offset)\n            break;\n\n          match = match->next;\n        }\n\n        push(r3);\n        break;\n\n      case OP_FOUND_IN:\n        pop(r3);\n        pop(r2);\n        pop(r1);\n\n        ensure_defined(r1);\n        ensure_defined(r2);\n\n        match = r3.s->matches[tidx].head;\n        r3.i = FALSE;\n\n        while (match != NULL && !r3.i)\n        {\n          if (match->base + match->offset >= r1.i &&\n              match->base + match->offset <= r2.i)\n          {\n            r3.i = TRUE;\n          }\n\n          if (match->base + match->offset > r2.i)\n            break;\n\n          match = match->next;\n        }\n\n        push(r3);\n        break;\n\n      case OP_COUNT:\n        pop(r1);\n        r1.i = r1.s->matches[tidx].count;\n        push(r1);\n        break;\n\n      case OP_OFFSET:\n        pop(r2);\n        pop(r1);\n\n        ensure_defined(r1);\n\n        match = r2.s->matches[tidx].head;\n        i = 1;\n        r3.i = UNDEFINED;\n\n        while (match != NULL && r3.i == UNDEFINED)\n        {\n          if (r1.i == i)\n            r3.i = match->base + match->offset;\n\n          i++;\n          match = match->next;\n        }\n\n        push(r3);\n        break;\n\n      case OP_LENGTH:\n        pop(r2);\n        pop(r1);\n\n        ensure_defined(r1);\n\n        match = r2.s->matches[tidx].head;\n        i = 1;\n        r3.i = UNDEFINED;\n\n        while (match != NULL && r3.i == UNDEFINED)\n        {\n          if (r1.i == i)\n            r3.i = match->match_length;\n\n          i++;\n          match = match->next;\n        }\n\n        push(r3);\n        break;\n\n      case OP_OF:\n        found = 0;\n        count = 0;\n        pop(r1);\n\n        while (!is_undef(r1))\n        {\n          if (r1.s->matches[tidx].tail != NULL)\n            found++;\n          count++;\n          pop(r1);\n        }\n\n        pop(r2);\n\n        if (is_undef(r2))\n          r1.i = found >= count ? 1 : 0;\n        else\n          r1.i = found >= r2.i ? 1 : 0;\n\n        push(r1);\n        break;\n\n      case OP_FILESIZE:\n        r1.i = context->file_size;\n        push(r1);\n        break;\n\n      case OP_ENTRYPOINT:\n        r1.i = context->entry_point;\n        push(r1);\n        break;\n\n      case OP_INT8:\n        pop(r1);\n        r1.i = read_int8_t_little_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_INT16:\n        pop(r1);\n        r1.i = read_int16_t_little_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_INT32:\n        pop(r1);\n        r1.i = read_int32_t_little_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_UINT8:\n        pop(r1);\n        r1.i = read_uint8_t_little_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_UINT16:\n        pop(r1);\n        r1.i = read_uint16_t_little_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_UINT32:\n        pop(r1);\n        r1.i = read_uint32_t_little_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_INT8BE:\n        pop(r1);\n        r1.i = read_int8_t_big_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_INT16BE:\n        pop(r1);\n        r1.i = read_int16_t_big_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_INT32BE:\n        pop(r1);\n        r1.i = read_int32_t_big_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_UINT8BE:\n        pop(r1);\n        r1.i = read_uint8_t_big_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_UINT16BE:\n        pop(r1);\n        r1.i = read_uint16_t_big_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_UINT32BE:\n        pop(r1);\n        r1.i = read_uint32_t_big_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_CONTAINS:\n        pop(r2);\n        pop(r1);\n\n        ensure_defined(r1);\n        ensure_defined(r2);\n\n        r1.i = memmem(r1.ss->c_string, r1.ss->length,\n                      r2.ss->c_string, r2.ss->length) != NULL;\n        push(r1);\n        break;\n\n      case OP_IMPORT:\n        r1.i = *(uint64_t*)(ip + 1);\n        ip += sizeof(uint64_t);\n\n        result = yr_modules_load((char*) r1.p, context);\n\n        if (result != ERROR_SUCCESS)\n          stop = TRUE;\n\n        break;\n\n      case OP_MATCHES:\n\n        pop(r2);\n        pop(r1);\n\n        ensure_defined(r2);\n        ensure_defined(r1);\n\n        if (r1.ss->length == 0)\n        {\n          r1.i = FALSE;\n          push(r1);\n          break;\n        }\n\n        result = yr_re_exec(\n          (uint8_t*) r2.re->code,\n          (uint8_t*) r1.ss->c_string,\n          r1.ss->length,\n          0,\n          r2.re->flags | RE_FLAGS_SCAN,\n          NULL,\n          NULL,\n          &found);\n\n        if (result != ERROR_SUCCESS)\n          stop = TRUE;\n\n        r1.i = found >= 0;\n        push(r1);\n        break;\n\n      case OP_INT_TO_DBL:\n        r1.i = *(uint64_t*)(ip + 1);\n        ip += sizeof(uint64_t);\n        r2 = stack[sp - r1.i];\n        if (is_undef(r2))\n          stack[sp - r1.i].i = UNDEFINED;\n        else\n          stack[sp - r1.i].d = (double) r2.i;\n        break;\n\n      case OP_STR_TO_BOOL:\n        pop(r1);\n        ensure_defined(r1);\n        r1.i = r1.ss->length > 0;\n        push(r1);\n        break;\n\n      case OP_INT_EQ:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i == r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_NEQ:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i != r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_LT:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i < r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_GT:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i > r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_LE:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i <= r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_GE:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i >= r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_ADD:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i + r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_SUB:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i - r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_MUL:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i * r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_DIV:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        if (r2.i != 0)\n          r1.i = r1.i / r2.i;\n        else\n          r1.i = UNDEFINED;\n        push(r1);\n        break;\n\n      case OP_INT_MINUS:\n        pop(r1);\n        ensure_defined(r1);\n        r1.i = -r1.i;\n        push(r1);\n        break;\n\n      case OP_DBL_LT:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.d < r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_GT:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.d > r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_LE:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.d <= r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_GE:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.d >= r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_EQ:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.d == r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_NEQ:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.d != r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_ADD:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.d = r1.d + r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_SUB:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.d = r1.d - r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_MUL:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.d = r1.d * r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_DIV:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.d = r1.d / r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_MINUS:\n        pop(r1);\n        ensure_defined(r1);\n        r1.d = -r1.d;\n        push(r1);\n        break;\n\n      case OP_STR_EQ:\n      case OP_STR_NEQ:\n      case OP_STR_LT:\n      case OP_STR_LE:\n      case OP_STR_GT:\n      case OP_STR_GE:\n\n        pop(r2);\n        pop(r1);\n\n        ensure_defined(r1);\n        ensure_defined(r2);\n\n        switch(*ip)\n        {\n          case OP_STR_EQ:\n            r1.i = (sized_string_cmp(r1.ss, r2.ss) == 0);\n            break;\n          case OP_STR_NEQ:\n            r1.i = (sized_string_cmp(r1.ss, r2.ss) != 0);\n            break;\n          case OP_STR_LT:\n            r1.i = (sized_string_cmp(r1.ss, r2.ss) < 0);\n            break;\n          case OP_STR_LE:\n            r1.i = (sized_string_cmp(r1.ss, r2.ss) <= 0);\n            break;\n          case OP_STR_GT:\n            r1.i = (sized_string_cmp(r1.ss, r2.ss) > 0);\n            break;\n          case OP_STR_GE:\n            r1.i = (sized_string_cmp(r1.ss, r2.ss) >= 0);\n            break;\n        }\n\n        push(r1);\n        break;\n\n      default:\n        // Unknown instruction, this shouldn't happen.\n        assert(FALSE);\n    }\n\n    if (timeout > 0)  // timeout == 0 means no timeout\n    {\n      // Check for timeout every 10 instruction cycles.\n\n      if (++cycle == 10)\n      {\n        if (difftime(time(NULL), start_time) > timeout)\n        {\n          #ifdef PROFILING_ENABLED\n          assert(current_rule != NULL);\n          current_rule->clock_ticks += clock() - start;\n          #endif\n          result = ERROR_SCAN_TIMEOUT;\n          stop = TRUE;\n        }\n\n        cycle = 0;\n      }\n    }\n\n    ip++;\n  }\n\n  obj_ptr = (YR_OBJECT**) yr_arena_base_address(obj_arena);\n\n  while (obj_ptr != NULL)\n  {\n    yr_object_destroy(*obj_ptr);\n\n    obj_ptr = (YR_OBJECT**) yr_arena_next_address(\n        obj_arena, obj_ptr, sizeof(YR_OBJECT*));\n  }\n\n  yr_arena_destroy(obj_arena);\n  yr_modules_unload_all(context);\n  yr_free(stack);\n\n  return result;\n}\n", "/*\nCopyright (c) 2014. The YARA Authors. All Rights Reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\nlist of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#ifndef YR_OBJECT_H\n#define YR_OBJECT_H\n\n#ifdef _MSC_VER\n\n#include <float.h>\n#ifndef isnan\n#define isnan _isnan\n#endif\n\n#ifndef INFINITY\n#define INFINITY (DBL_MAX + DBL_MAX)\n#endif\n\n#ifndef NAN\n#define NAN (INFINITY-INFINITY)\n#endif\n\n#endif\n\n#include <yara/types.h>\n\n\n#define OBJECT_CREATE           1\n\n#define OBJECT_TYPE_INTEGER     1\n#define OBJECT_TYPE_STRING      2\n#define OBJECT_TYPE_STRUCTURE   3\n#define OBJECT_TYPE_ARRAY       4\n#define OBJECT_TYPE_FUNCTION    5\n#define OBJECT_TYPE_DICTIONARY  6\n#define OBJECT_TYPE_FLOAT       7\n\n\nint yr_object_create(\n    int8_t type,\n    const char* identifier,\n    YR_OBJECT* parent,\n    YR_OBJECT** object);\n\n\nint yr_object_function_create(\n    const char* identifier,\n    const char* arguments_fmt,\n    const char* return_fmt,\n    YR_MODULE_FUNC func,\n    YR_OBJECT* parent,\n    YR_OBJECT** function);\n\n\nint yr_object_from_external_variable(\n    YR_EXTERNAL_VARIABLE* external,\n    YR_OBJECT** object);\n\n\nvoid yr_object_destroy(\n    YR_OBJECT* object);\n\n\nint yr_object_copy(\n    YR_OBJECT* object,\n    YR_OBJECT** object_copy);\n\n\nYR_OBJECT* yr_object_lookup_field(\n    YR_OBJECT* object,\n    const char* field_name);\n\n\nYR_OBJECT* yr_object_lookup(\n    YR_OBJECT* root,\n    int flags,\n    const char* pattern,\n    ...);\n\n\nint yr_object_has_undefined_value(\n    YR_OBJECT* object,\n    const char* field,\n    ...);\n\nint64_t yr_object_get_integer(\n    YR_OBJECT* object,\n    const char* field,\n    ...);\n\n\nSIZED_STRING* yr_object_get_string(\n    YR_OBJECT* object,\n    const char* field,\n    ...);\n\n\nint yr_object_set_integer(\n    int64_t value,\n    YR_OBJECT* object,\n    const char* field,\n    ...);\n\n\nint yr_object_set_float(\n    double value,\n    YR_OBJECT* object,\n    const char* field,\n    ...);\n\n\nint yr_object_set_string(\n    const char* value,\n    size_t len,\n    YR_OBJECT* object,\n    const char* field,\n    ...);\n\n\nYR_OBJECT* yr_object_array_get_item(\n    YR_OBJECT* object,\n    int flags,\n    int index);\n\n\nint yr_object_array_set_item(\n    YR_OBJECT* object,\n    YR_OBJECT* item,\n    int index);\n\n\nYR_OBJECT* yr_object_dict_get_item(\n    YR_OBJECT* object,\n    int flags,\n    const char* key);\n\n\nint yr_object_dict_set_item(\n    YR_OBJECT* object,\n    YR_OBJECT* item,\n    const char* key);\n\n\nint yr_object_structure_set_member(\n    YR_OBJECT* object,\n    YR_OBJECT* member);\n\n\nYR_OBJECT* yr_object_get_root(\n    YR_OBJECT* object);\n\n\nYR_API void yr_object_print_data(\n    YR_OBJECT* object,\n    int indent,\n    int print_identifier);\n\n\n#endif\n", "/*\nCopyright (c) 2007-2014. The YARA Authors. All Rights Reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\nlist of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#ifndef _SIZEDSTR_H\n#define _SIZEDSTR_H\n\n#include <stddef.h>\n\n#include <yara/integers.h>\n\n//\n// This struct is used to support strings containing null chars. The length of\n// the string is stored along the string data. However the string data is also\n// terminated with a null char.\n//\n\n#define SIZED_STRING_FLAGS_NO_CASE  1\n#define SIZED_STRING_FLAGS_DOT_ALL  2\n\n#pragma pack(push)\n#pragma pack(8)\n\n\ntypedef struct _SIZED_STRING\n{\n  uint32_t length;\n  uint32_t flags;\n\n  char c_string[1];\n\n} SIZED_STRING;\n\n#pragma pack(pop)\n\n\nint sized_string_cmp(\n    SIZED_STRING* s1,\n    SIZED_STRING* s2);\n\n\nSIZED_STRING* sized_string_dup(\n    SIZED_STRING* s);\n\n#endif\n", "/*\nCopyright (c) 2014. The YARA Authors. All Rights Reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\nlist of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#include <yara/modules.h>\n\n#define MODULE_NAME tests\n\n\ndefine_function(fsum_2)\n{\n  double a = float_argument(1);\n  double b = float_argument(2);\n\n  return_float(a + b);\n}\n\ndefine_function(fsum_3)\n{\n  double a = float_argument(1);\n  double b = float_argument(2);\n  double c = float_argument(3);\n\n  return_float(a + b + c);\n}\n\ndefine_function(isum_2)\n{\n  int64_t a = integer_argument(1);\n  int64_t b = integer_argument(2);\n\n  return_integer(a + b);\n}\n\n\ndefine_function(isum_3)\n{\n  int64_t a = integer_argument(1);\n  int64_t b = integer_argument(2);\n  int64_t c = integer_argument(3);\n\n  return_integer(a + b + c);\n}\n\n\ndefine_function(length)\n{\n  char* s = string_argument(1);\n\n  return_integer(strlen(s));\n}\n\n\ndefine_function(empty)\n{\n  return_string(\"\");\n}\n\n\ndefine_function(match)\n{\n  return_integer(yr_re_match(regexp_argument(1), string_argument(2)));\n}\n\n\ndefine_function(foobar)\n{\n  int64_t arg = integer_argument(1);\n\n  switch (arg)\n  {\n    case 1:\n      return_string(\"foo\");\n      break;\n    case 2:\n      return_string(\"bar\");\n      break;\n  }\n\n  return_string(\"oops\")\n}\n\nbegin_declarations;\n\n  begin_struct(\"constants\");\n    declare_integer(\"one\");\n    declare_integer(\"two\");\n    declare_string(\"foo\");\n    declare_string(\"empty\");\n  end_struct(\"constants\");\n\n  begin_struct(\"undefined\");\n    declare_integer(\"i\");\n    declare_float(\"f\");\n  end_struct(\"undefined\");\n\n  declare_integer_array(\"integer_array\");\n  declare_string_array(\"string_array\");\n\n  declare_integer_dictionary(\"integer_dict\");\n  declare_string_dictionary(\"string_dict\");\n\n  begin_struct_array(\"struct_array\");\n    declare_integer(\"i\");\n    declare_string(\"s\");\n  end_struct_array(\"struct_array\");\n\n  begin_struct_dictionary(\"struct_dict\");\n    declare_integer(\"i\");\n    declare_string(\"s\");\n  end_struct_dictionary(\"struct_dict\");\n\n  declare_function(\"match\", \"rs\", \"i\", match);\n  declare_function(\"isum\", \"ii\", \"i\", isum_2);\n  declare_function(\"isum\", \"iii\", \"i\", isum_3);\n  declare_function(\"fsum\", \"ff\", \"f\", fsum_2);\n  declare_function(\"fsum\", \"fff\", \"f\", fsum_3);\n  declare_function(\"length\", \"s\", \"i\", length);\n  declare_function(\"empty\", \"\", \"s\", empty);\n  declare_function(\"foobar\", \"i\", \"s\", foobar);\n\nend_declarations;\n\n\nint module_initialize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}\n\n\nint module_finalize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}\n\nint module_load(\n    YR_SCAN_CONTEXT* context,\n    YR_OBJECT* module_object,\n    void* module_data,\n    size_t module_data_size)\n{\n  set_integer(1, module_object, \"constants.one\");\n  set_integer(2, module_object, \"constants.two\");\n  set_string(\"foo\", module_object, \"constants.foo\");\n  set_string(\"\", module_object, \"constants.empty\");\n\n  set_integer(1, module_object, \"struct_array[1].i\");\n\n  set_integer(0, module_object, \"integer_array[%i]\", 0);\n  set_integer(1, module_object, \"integer_array[%i]\", 1);\n  set_integer(2, module_object, \"integer_array[%i]\", 2);\n\n  set_string(\"foo\", module_object, \"string_array[%i]\", 0);\n  set_string(\"bar\", module_object, \"string_array[%i]\", 1);\n  set_string(\"baz\", module_object, \"string_array[%i]\", 2);\n\n  set_sized_string(\"foo\\0bar\", 7, module_object, \"string_array[%i]\", 3);\n\n  set_string(\"foo\", module_object, \"string_dict[%s]\", \"foo\");\n  set_string(\"bar\", module_object, \"string_dict[\\\"bar\\\"]\");\n\n  set_string(\"foo\", module_object, \"struct_dict[%s].s\", \"foo\");\n  set_integer(1, module_object, \"struct_dict[%s].i\", \"foo\");\n\n  return ERROR_SUCCESS;\n}\n\n\nint module_unload(\n    YR_OBJECT* module_object)\n{\n  return ERROR_SUCCESS;\n}\n", "/*\nCopyright (c) 2014. The YARA Authors. All Rights Reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\nlist of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\n#include <assert.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#if _WIN32 || __CYGWIN__\n#define PRIu64 \"I64d\"\n#else\n#include <inttypes.h>\n#endif\n\n#include <yara/mem.h>\n#include <yara/error.h>\n#include <yara/object.h>\n#include <yara/exec.h>\n#include <yara/utils.h>\n\n\nint yr_object_create(\n    int8_t type,\n    const char* identifier,\n    YR_OBJECT* parent,\n    YR_OBJECT** object)\n{\n  YR_OBJECT* obj;\n  int i;\n  size_t object_size = 0;\n\n  assert(parent != NULL || object != NULL);\n\n  switch (type)\n  {\n    case OBJECT_TYPE_STRUCTURE:\n      object_size = sizeof(YR_OBJECT_STRUCTURE);\n      break;\n    case OBJECT_TYPE_ARRAY:\n      object_size = sizeof(YR_OBJECT_ARRAY);\n      break;\n    case OBJECT_TYPE_DICTIONARY:\n      object_size = sizeof(YR_OBJECT_DICTIONARY);\n      break;\n    case OBJECT_TYPE_INTEGER:\n      object_size = sizeof(YR_OBJECT_INTEGER);\n      break;\n    case OBJECT_TYPE_FLOAT:\n      object_size = sizeof(YR_OBJECT_DOUBLE);\n      break;\n    case OBJECT_TYPE_STRING:\n      object_size = sizeof(YR_OBJECT_STRING);\n      break;\n    case OBJECT_TYPE_FUNCTION:\n      object_size = sizeof(YR_OBJECT_FUNCTION);\n      break;\n    default:\n      assert(FALSE);\n  }\n\n  obj = (YR_OBJECT*) yr_malloc(object_size);\n\n  if (obj == NULL)\n    return ERROR_INSUFFICIENT_MEMORY;\n\n  obj->type = type;\n  obj->identifier = yr_strdup(identifier);\n  obj->parent = parent;\n  obj->data = NULL;\n\n  switch(type)\n  {\n    case OBJECT_TYPE_STRUCTURE:\n      ((YR_OBJECT_STRUCTURE*) obj)->members = NULL;\n      break;\n    case OBJECT_TYPE_ARRAY:\n      ((YR_OBJECT_ARRAY*) obj)->items = NULL;\n      ((YR_OBJECT_ARRAY*) obj)->prototype_item = NULL;\n      break;\n    case OBJECT_TYPE_DICTIONARY:\n      ((YR_OBJECT_DICTIONARY*) obj)->items = NULL;\n      ((YR_OBJECT_DICTIONARY*) obj)->prototype_item = NULL;\n      break;\n    case OBJECT_TYPE_INTEGER:\n      ((YR_OBJECT_INTEGER*) obj)->value = UNDEFINED;\n      break;\n    case OBJECT_TYPE_FLOAT:\n      ((YR_OBJECT_DOUBLE*) obj)->value = NAN;\n      break;\n    case OBJECT_TYPE_STRING:\n      ((YR_OBJECT_STRING*) obj)->value = NULL;\n      break;\n    case OBJECT_TYPE_FUNCTION:\n      ((YR_OBJECT_FUNCTION*) obj)->return_obj = NULL;\n      for (i = 0; i < MAX_OVERLOADED_FUNCTIONS; i++)\n      {\n        ((YR_OBJECT_FUNCTION*) obj)->prototypes[i].arguments_fmt = NULL;\n        ((YR_OBJECT_FUNCTION*) obj)->prototypes[i].code = NULL;\n      }\n      break;\n  }\n\n  if (obj->identifier == NULL)\n  {\n    yr_free(obj);\n    return ERROR_INSUFFICIENT_MEMORY;\n  }\n\n  if (parent != NULL)\n  {\n    assert(parent->type == OBJECT_TYPE_STRUCTURE ||\n           parent->type == OBJECT_TYPE_ARRAY ||\n           parent->type == OBJECT_TYPE_DICTIONARY ||\n           parent->type == OBJECT_TYPE_FUNCTION);\n\n    switch(parent->type)\n    {\n      case OBJECT_TYPE_STRUCTURE:\n        FAIL_ON_ERROR_WITH_CLEANUP(\n            yr_object_structure_set_member(parent, obj),\n            {\n              yr_free((void*) obj->identifier);\n              yr_free(obj);\n            });\n        break;\n\n      case OBJECT_TYPE_ARRAY:\n        ((YR_OBJECT_ARRAY*) parent)->prototype_item = obj;\n        break;\n\n      case OBJECT_TYPE_DICTIONARY:\n        ((YR_OBJECT_DICTIONARY*) parent)->prototype_item = obj;\n        break;\n\n      case OBJECT_TYPE_FUNCTION:\n        ((YR_OBJECT_FUNCTION*) parent)->return_obj = obj;\n        break;\n    }\n  }\n\n  if (object != NULL)\n    *object = obj;\n\n  return ERROR_SUCCESS;\n}\n\n\nint yr_object_function_create(\n    const char* identifier,\n    const char* arguments_fmt,\n    const char* return_fmt,\n    YR_MODULE_FUNC code,\n    YR_OBJECT* parent,\n    YR_OBJECT** function)\n{\n  YR_OBJECT* return_obj;\n  YR_OBJECT* o = NULL;\n  YR_OBJECT_FUNCTION* f = NULL;\n\n  int8_t return_type;\n  int i;\n\n  switch (*return_fmt)\n  {\n    case 'i':\n      return_type = OBJECT_TYPE_INTEGER;\n      break;\n    case 's':\n      return_type = OBJECT_TYPE_STRING;\n      break;\n    case 'f':\n      return_type = OBJECT_TYPE_FLOAT;\n      break;\n    default:\n      return ERROR_INVALID_FORMAT;\n  }\n\n  if (parent != NULL)\n  {\n    // The parent of a function must be a structure.\n\n    assert(parent->type == OBJECT_TYPE_STRUCTURE);\n\n    // Try to find if the structure already has a function\n    // with that name. In that case this is a function overload.\n\n    f = (YR_OBJECT_FUNCTION*) yr_object_lookup_field(parent, identifier);\n\n    // Overloaded functions must have the same return type.\n\n    if (f != NULL && return_type != f->return_obj->type)\n      return ERROR_WRONG_RETURN_TYPE;\n  }\n\n  if (f == NULL) // Function doesn't exist yet\n  {\n    FAIL_ON_ERROR(\n        yr_object_create(\n            OBJECT_TYPE_FUNCTION,\n            identifier,\n            parent,\n            &o));\n\n    FAIL_ON_ERROR_WITH_CLEANUP(\n        yr_object_create(\n            return_type,\n            \"result\",\n            o,\n            &return_obj),\n        yr_object_destroy(o));\n\n    f = (YR_OBJECT_FUNCTION*) o;\n  }\n\n  for (i = 0; i < MAX_OVERLOADED_FUNCTIONS; i++)\n  {\n    if (f->prototypes[i].arguments_fmt == NULL)\n    {\n      f->prototypes[i].arguments_fmt = arguments_fmt;\n      f->prototypes[i].code = code;\n\n      break;\n    }\n  }\n\n  if (function != NULL)\n    *function = (YR_OBJECT*) f;\n\n  return ERROR_SUCCESS;\n}\n\n\nint yr_object_from_external_variable(\n    YR_EXTERNAL_VARIABLE* external,\n    YR_OBJECT** object)\n{\n  YR_OBJECT* obj;\n  int result;\n  uint8_t obj_type = 0;\n\n  switch(external->type)\n  {\n    case EXTERNAL_VARIABLE_TYPE_INTEGER:\n    case EXTERNAL_VARIABLE_TYPE_BOOLEAN:\n      obj_type = OBJECT_TYPE_INTEGER;\n      break;\n\n    case EXTERNAL_VARIABLE_TYPE_FLOAT:\n      obj_type = OBJECT_TYPE_FLOAT;\n      break;\n\n    case EXTERNAL_VARIABLE_TYPE_STRING:\n    case EXTERNAL_VARIABLE_TYPE_MALLOC_STRING:\n      obj_type = OBJECT_TYPE_STRING;\n      break;\n\n    default:\n      assert(FALSE);\n  }\n\n  result = yr_object_create(\n      obj_type,\n      external->identifier,\n      NULL,\n      &obj);\n\n  if (result == ERROR_SUCCESS)\n  {\n    switch(external->type)\n    {\n      case EXTERNAL_VARIABLE_TYPE_INTEGER:\n      case EXTERNAL_VARIABLE_TYPE_BOOLEAN:\n        yr_object_set_integer(external->value.i, obj, NULL);\n        break;\n\n      case EXTERNAL_VARIABLE_TYPE_FLOAT:\n        yr_object_set_float(external->value.f, obj, NULL);\n        break;\n\n      case EXTERNAL_VARIABLE_TYPE_STRING:\n      case EXTERNAL_VARIABLE_TYPE_MALLOC_STRING:\n        yr_object_set_string(\n            external->value.s, strlen(external->value.s), obj, NULL);\n        break;\n    }\n\n    *object = obj;\n  }\n\n  return result;\n}\n\n\nvoid yr_object_destroy(\n    YR_OBJECT* object)\n{\n  YR_STRUCTURE_MEMBER* member;\n  YR_STRUCTURE_MEMBER* next_member;\n  YR_ARRAY_ITEMS* array_items;\n  YR_DICTIONARY_ITEMS* dict_items;\n\n  SIZED_STRING* str;\n  int i;\n\n  if (object == NULL)\n    return;\n\n  switch(object->type)\n  {\n    case OBJECT_TYPE_STRUCTURE:\n      member = ((YR_OBJECT_STRUCTURE*) object)->members;\n\n      while (member != NULL)\n      {\n        next_member = member->next;\n        yr_object_destroy(member->object);\n        yr_free(member);\n        member = next_member;\n      }\n      break;\n\n    case OBJECT_TYPE_STRING:\n      str = ((YR_OBJECT_STRING*) object)->value;\n      if (str != NULL)\n        yr_free(str);\n      break;\n\n    case OBJECT_TYPE_ARRAY:\n      if (((YR_OBJECT_ARRAY*) object)->prototype_item != NULL)\n        yr_object_destroy(((YR_OBJECT_ARRAY*) object)->prototype_item);\n\n      array_items = ((YR_OBJECT_ARRAY*) object)->items;\n\n      if (array_items != NULL)\n      {\n        for (i = 0; i < array_items->count; i++)\n          if (array_items->objects[i] != NULL)\n            yr_object_destroy(array_items->objects[i]);\n      }\n\n      yr_free(array_items);\n      break;\n\n    case OBJECT_TYPE_DICTIONARY:\n      if (((YR_OBJECT_DICTIONARY*) object)->prototype_item != NULL)\n        yr_object_destroy(((YR_OBJECT_DICTIONARY*) object)->prototype_item);\n\n      dict_items = ((YR_OBJECT_DICTIONARY*) object)->items;\n\n      if (dict_items != NULL)\n      {\n        for (i = 0; i < dict_items->used; i++)\n        {\n          if (dict_items->objects[i].key != NULL)\n            yr_free(dict_items->objects[i].key);\n\n          if (dict_items->objects[i].obj != NULL)\n            yr_object_destroy(dict_items->objects[i].obj);\n        }\n      }\n\n      yr_free(dict_items);\n      break;\n\n    case OBJECT_TYPE_FUNCTION:\n      yr_object_destroy(((YR_OBJECT_FUNCTION*) object)->return_obj);\n      break;\n  }\n\n  yr_free((void*) object->identifier);\n  yr_free(object);\n}\n\n\nYR_OBJECT* yr_object_lookup_field(\n    YR_OBJECT* object,\n    const char* field_name)\n{\n  YR_STRUCTURE_MEMBER* member;\n\n  assert(object != NULL);\n  assert(object->type == OBJECT_TYPE_STRUCTURE);\n\n  member = ((YR_OBJECT_STRUCTURE*) object)->members;\n\n  while (member != NULL)\n  {\n    if (strcmp(member->object->identifier, field_name) == 0)\n      return member->object;\n\n    member = member->next;\n  }\n\n  return NULL;\n}\n\n\nYR_OBJECT* _yr_object_lookup(\n    YR_OBJECT* object,\n    int flags,\n    const char* pattern,\n    va_list args)\n{\n  YR_OBJECT* obj = object;\n\n  const char* p = pattern;\n  const char* key = NULL;\n\n  char str[256];\n\n  int i;\n  int index = -1;\n\n  while (obj != NULL)\n  {\n    i = 0;\n\n    while(*p != '\\0' && *p != '.' && *p != '[' && i < sizeof(str) - 1)\n    {\n      str[i++] = *p++;\n    }\n\n    str[i] = '\\0';\n\n    if (obj->type != OBJECT_TYPE_STRUCTURE)\n      return NULL;\n\n    obj = yr_object_lookup_field(obj, str);\n\n    if (obj == NULL)\n      return NULL;\n\n    if (*p == '[')\n    {\n      p++;\n\n      if (*p == '%')\n      {\n        p++;\n\n        switch(*p++)\n        {\n          case 'i':\n            index = va_arg(args, int);\n            break;\n          case 's':\n            key = va_arg(args, const char*);\n            break;\n\n          default:\n            return NULL;\n        }\n      }\n      else if (*p >= '0' && *p <= '9')\n      {\n        index = (int) strtol(p, (char**) &p, 10);\n      }\n      else if (*p == '\"')\n      {\n        i = 0;\n        p++;              // skip the opening quotation mark\n\n        while (*p != '\"' && *p != '\\0' && i < sizeof(str))\n          str[i++] = *p++;\n\n        str[i] = '\\0';\n        p++;              // skip the closing quotation mark\n        key = str;\n      }\n      else\n      {\n        return NULL;\n      }\n\n      assert(*p == ']');\n      p++;\n      assert(*p == '.' || *p == '\\0');\n\n      switch(obj->type)\n      {\n        case OBJECT_TYPE_ARRAY:\n          assert(index != -1);\n          obj = yr_object_array_get_item(obj, flags, index);\n          break;\n\n        case OBJECT_TYPE_DICTIONARY:\n          assert(key != NULL);\n          obj = yr_object_dict_get_item(obj, flags, key);\n          break;\n      }\n    }\n\n    if (*p == '\\0')\n      break;\n\n    p++;\n  }\n\n  return obj;\n}\n\n\nYR_OBJECT* yr_object_lookup(\n    YR_OBJECT* object,\n    int flags,\n    const char* pattern,\n    ...)\n{\n  YR_OBJECT* result;\n\n  va_list args;\n  va_start(args, pattern);\n\n  result = _yr_object_lookup(object, flags, pattern, args);\n\n  va_end(args);\n\n  return result;\n\n}\n\n\nint yr_object_copy(\n    YR_OBJECT* object,\n    YR_OBJECT** object_copy)\n{\n  YR_OBJECT* copy;\n  YR_OBJECT* o;\n\n  YR_STRUCTURE_MEMBER* structure_member;\n  YR_OBJECT_FUNCTION* func;\n  YR_OBJECT_FUNCTION* func_copy;\n\n  int i;\n\n  *object_copy = NULL;\n\n  FAIL_ON_ERROR(yr_object_create(\n      object->type,\n      object->identifier,\n      NULL,\n      &copy));\n\n  switch(object->type)\n  {\n    case OBJECT_TYPE_INTEGER:\n      ((YR_OBJECT_INTEGER*) copy)->value = ((YR_OBJECT_INTEGER*) object)->value;\n      break;\n\n    case OBJECT_TYPE_STRING:\n      if (((YR_OBJECT_STRING*) object)->value != NULL)\n      {\n        ((YR_OBJECT_STRING*) copy)->value = sized_string_dup(\n            ((YR_OBJECT_STRING*) object)->value);\n      }\n      else\n      {\n        ((YR_OBJECT_STRING*) copy)->value = NULL;\n      }\n      break;\n\n    case OBJECT_TYPE_FLOAT:\n      ((YR_OBJECT_DOUBLE*) copy)->value = ((YR_OBJECT_DOUBLE*) object)->value;\n      break;\n\n    case OBJECT_TYPE_FUNCTION:\n\n      func = (YR_OBJECT_FUNCTION*) object;\n      func_copy = (YR_OBJECT_FUNCTION*) copy;\n\n      FAIL_ON_ERROR_WITH_CLEANUP(\n        yr_object_copy(func->return_obj, &func_copy->return_obj),\n        yr_object_destroy(copy));\n\n      for (i = 0; i < MAX_OVERLOADED_FUNCTIONS; i++)\n        func_copy->prototypes[i] = func->prototypes[i];\n\n      break;\n\n    case OBJECT_TYPE_STRUCTURE:\n\n      structure_member = ((YR_OBJECT_STRUCTURE*) object)->members;\n\n      while (structure_member != NULL)\n      {\n        FAIL_ON_ERROR_WITH_CLEANUP(\n            yr_object_copy(structure_member->object, &o),\n            yr_object_destroy(copy));\n\n        FAIL_ON_ERROR_WITH_CLEANUP(\n            yr_object_structure_set_member(copy, o),\n            yr_free(o);\n            yr_object_destroy(copy));\n\n        structure_member = structure_member->next;\n      }\n\n      break;\n\n    case OBJECT_TYPE_ARRAY:\n\n      yr_object_copy(\n        ((YR_OBJECT_ARRAY *) object)->prototype_item,\n        &o);\n\n      ((YR_OBJECT_ARRAY *)copy)->prototype_item = o;\n\n      break;\n\n    case OBJECT_TYPE_DICTIONARY:\n\n      yr_object_copy(\n        ((YR_OBJECT_DICTIONARY *) object)->prototype_item,\n        &o);\n\n      ((YR_OBJECT_DICTIONARY *)copy)->prototype_item = o;\n\n      break;\n\n    default:\n      assert(FALSE);\n\n  }\n\n  *object_copy = copy;\n\n  return ERROR_SUCCESS;\n}\n\n\nint yr_object_structure_set_member(\n    YR_OBJECT* object,\n    YR_OBJECT* member)\n{\n  YR_STRUCTURE_MEMBER* sm;\n\n  assert(object->type == OBJECT_TYPE_STRUCTURE);\n\n  // Check if the object already have a member with the same identifier\n\n  if (yr_object_lookup_field(object,  member->identifier) != NULL)\n    return ERROR_DUPLICATED_STRUCTURE_MEMBER;\n\n  sm = (YR_STRUCTURE_MEMBER*) yr_malloc(sizeof(YR_STRUCTURE_MEMBER));\n\n  if (sm == NULL)\n    return ERROR_INSUFFICIENT_MEMORY;\n\n  member->parent = object;\n  sm->object = member;\n  sm->next = ((YR_OBJECT_STRUCTURE*) object)->members;\n\n  ((YR_OBJECT_STRUCTURE*) object)->members = sm;\n\n  return ERROR_SUCCESS;\n}\n\n\nYR_OBJECT* yr_object_array_get_item(\n    YR_OBJECT* object,\n    int flags,\n    int index)\n{\n  YR_OBJECT* result = NULL;\n  YR_OBJECT_ARRAY* array;\n\n  assert(object->type == OBJECT_TYPE_ARRAY);\n\n  if (index < 0)\n    return NULL;\n\n  array = (YR_OBJECT_ARRAY*) object;\n\n  if (array->items != NULL && array->items->count > index)\n      result = array->items->objects[index];\n\n  if (result == NULL && flags & OBJECT_CREATE)\n  {\n    yr_object_copy(array->prototype_item, &result);\n\n    if (result != NULL)\n      yr_object_array_set_item(object, result, index);\n  }\n\n  return result;\n}\n\n\nint yr_object_array_set_item(\n    YR_OBJECT* object,\n    YR_OBJECT* item,\n    int index)\n{\n  YR_OBJECT_ARRAY* array;\n\n  int i;\n  int count;\n\n  assert(index >= 0);\n  assert(object->type == OBJECT_TYPE_ARRAY);\n\n  array = ((YR_OBJECT_ARRAY*) object);\n\n  if (array->items == NULL)\n  {\n    count = yr_max(64, (index + 1) * 2);\n\n    array->items = (YR_ARRAY_ITEMS*) yr_malloc(\n        sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));\n\n    if (array->items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    memset(array->items->objects, 0, count * sizeof(YR_OBJECT*));\n\n    array->items->count = count;\n  }\n  else if (index >= array->items->count)\n  {\n    count = array->items->count * 2;\n    array->items = (YR_ARRAY_ITEMS*) yr_realloc(\n        array->items,\n        sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));\n\n    if (array->items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    for (i = array->items->count; i < count; i++)\n      array->items->objects[i] = NULL;\n\n    array->items->count = count;\n  }\n\n  item->parent = object;\n  array->items->objects[index] = item;\n\n  return ERROR_SUCCESS;\n}\n\n\nYR_OBJECT* yr_object_dict_get_item(\n    YR_OBJECT* object,\n    int flags,\n    const char* key)\n{\n  int i;\n\n  YR_OBJECT* result = NULL;\n  YR_OBJECT_DICTIONARY* dict;\n\n  assert(object->type == OBJECT_TYPE_DICTIONARY);\n\n  dict = (YR_OBJECT_DICTIONARY*) object;\n\n  if (dict->items != NULL)\n  {\n    for (i = 0; i < dict->items->used; i++)\n    {\n      if (strcmp(dict->items->objects[i].key, key) == 0)\n        result = dict->items->objects[i].obj;\n    }\n  }\n\n  if (result == NULL && flags & OBJECT_CREATE)\n  {\n    yr_object_copy(dict->prototype_item, &result);\n\n    if (result != NULL)\n      yr_object_dict_set_item(object, result, key);\n  }\n\n  return result;\n}\n\n\nint yr_object_dict_set_item(\n    YR_OBJECT* object,\n    YR_OBJECT* item,\n    const char* key)\n{\n  YR_OBJECT_DICTIONARY* dict;\n\n  int i;\n  int count;\n\n  assert(object->type == OBJECT_TYPE_DICTIONARY);\n\n  dict = ((YR_OBJECT_DICTIONARY*) object);\n\n  if (dict->items == NULL)\n  {\n    count = 64;\n\n    dict->items = (YR_DICTIONARY_ITEMS*) yr_malloc(\n        sizeof(YR_DICTIONARY_ITEMS) + count * sizeof(dict->items->objects[0]));\n\n    if (dict->items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    memset(dict->items->objects, 0, count * sizeof(dict->items->objects[0]));\n\n    dict->items->free = count;\n    dict->items->used = 0;\n  }\n  else if (dict->items->free == 0)\n  {\n    count = dict->items->used * 2;\n    dict->items = (YR_DICTIONARY_ITEMS*) yr_realloc(\n        dict->items,\n        sizeof(YR_DICTIONARY_ITEMS) + count * sizeof(dict->items->objects[0]));\n\n    if (dict->items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    for (i = dict->items->used; i < count; i++)\n    {\n      dict->items->objects[i].key = NULL;\n      dict->items->objects[i].obj = NULL;\n    }\n\n    dict->items->free = dict->items->used;\n  }\n\n  item->parent = object;\n\n  dict->items->objects[dict->items->used].key = yr_strdup(key);\n  dict->items->objects[dict->items->used].obj = item;\n\n  dict->items->used++;\n  dict->items->free--;\n\n  return ERROR_SUCCESS;\n}\n\n\nint yr_object_has_undefined_value(\n    YR_OBJECT* object,\n    const char* field,\n    ...)\n{\n  YR_OBJECT* field_obj;\n\n  va_list args;\n  va_start(args, field);\n\n  if (field != NULL)\n    field_obj = _yr_object_lookup(object, 0, field, args);\n  else\n    field_obj = object;\n\n  va_end(args);\n\n  if (field_obj == NULL)\n    return TRUE;\n\n  switch(field_obj->type)\n  {\n    case OBJECT_TYPE_FLOAT:\n      return isnan(((YR_OBJECT_DOUBLE*) field_obj)->value);\n    case OBJECT_TYPE_STRING:\n      return ((YR_OBJECT_STRING*) field_obj)->value == NULL;\n    case OBJECT_TYPE_INTEGER:\n      return ((YR_OBJECT_INTEGER*) field_obj)->value == UNDEFINED;\n  }\n\n  return FALSE;\n}\n\n\nint64_t yr_object_get_integer(\n    YR_OBJECT* object,\n    const char* field,\n    ...)\n{\n  YR_OBJECT* integer_obj;\n\n  va_list args;\n  va_start(args, field);\n\n  if (field != NULL)\n    integer_obj = _yr_object_lookup(object, 0, field, args);\n  else\n    integer_obj = object;\n\n  va_end(args);\n\n  if (integer_obj == NULL)\n    return UNDEFINED;\n\n  assertf(integer_obj->type == OBJECT_TYPE_INTEGER,\n          \"type of \\\"%s\\\" is not integer\\n\", field);\n\n  return ((YR_OBJECT_INTEGER*) integer_obj)->value;\n}\n\n\ndouble yr_object_get_float(\n    YR_OBJECT* object,\n    const char* field,\n    ...)\n{\n  YR_OBJECT* double_obj;\n\n  va_list args;\n  va_start(args, field);\n\n  if (field != NULL)\n    double_obj = _yr_object_lookup(object, 0, field, args);\n  else\n    double_obj = object;\n\n  va_end(args);\n\n  if (double_obj == NULL)\n    return NAN;\n\n  assertf(double_obj->type == OBJECT_TYPE_FLOAT,\n          \"type of \\\"%s\\\" is not double\\n\", field);\n\n  return ((YR_OBJECT_DOUBLE*) double_obj)->value;\n}\n\n\nSIZED_STRING* yr_object_get_string(\n    YR_OBJECT* object,\n    const char* field,\n    ...)\n{\n  YR_OBJECT* string_obj;\n\n  va_list args;\n  va_start(args, field);\n\n  if (field != NULL)\n    string_obj = _yr_object_lookup(object, 0, field, args);\n  else\n    string_obj = object;\n\n  va_end(args);\n\n  if (string_obj == NULL)\n    return NULL;\n\n  assertf(string_obj->type == OBJECT_TYPE_STRING,\n          \"type of \\\"%s\\\" is not string\\n\", field);\n\n  return ((YR_OBJECT_STRING*) string_obj)->value;\n}\n\n\nint yr_object_set_integer(\n    int64_t value,\n    YR_OBJECT* object,\n    const char* field,\n    ...)\n{\n  YR_OBJECT* integer_obj;\n\n  va_list args;\n  va_start(args, field);\n\n  if (field != NULL)\n    integer_obj = _yr_object_lookup(\n        object, OBJECT_CREATE, field, args);\n  else\n    integer_obj = object;\n\n  va_end(args);\n\n  assert(integer_obj != NULL);\n  assert(integer_obj->type == OBJECT_TYPE_INTEGER);\n\n  ((YR_OBJECT_INTEGER*) integer_obj)->value = value;\n\n  return ERROR_SUCCESS;\n}\n\n\nint yr_object_set_float(\n    double value,\n    YR_OBJECT* object,\n    const char* field,\n    ...)\n{\n  YR_OBJECT* double_obj;\n\n  va_list args;\n  va_start(args, field);\n\n  if (field != NULL)\n    double_obj = _yr_object_lookup(\n        object, OBJECT_CREATE, field, args);\n  else\n    double_obj = object;\n\n  va_end(args);\n\n  assert(double_obj != NULL);\n  assert(double_obj->type == OBJECT_TYPE_FLOAT);\n\n  ((YR_OBJECT_DOUBLE*) double_obj)->value = value;\n\n  return ERROR_SUCCESS;\n}\n\n\nint yr_object_set_string(\n    const char* value,\n    size_t len,\n    YR_OBJECT* object,\n    const char* field,\n    ...)\n{\n  YR_OBJECT_STRING* string_obj;\n\n  va_list args;\n  va_start(args, field);\n\n  if (field != NULL)\n    string_obj = (YR_OBJECT_STRING*) _yr_object_lookup(\n        object, OBJECT_CREATE, field, args);\n  else\n    string_obj = (YR_OBJECT_STRING*) object;\n\n  va_end(args);\n\n  assert(string_obj != NULL);\n  assert(string_obj->type == OBJECT_TYPE_STRING);\n\n  if (string_obj->value != NULL)\n    yr_free(string_obj->value);\n\n  if (value != NULL)\n  {\n    string_obj->value = (SIZED_STRING*) yr_malloc(len + sizeof(SIZED_STRING));\n\n    if (string_obj->value == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    string_obj->value->length = (uint32_t) len;\n    string_obj->value->flags = 0;\n\n    memcpy(string_obj->value->c_string, value, len);\n    string_obj->value->c_string[len] = '\\0';\n  }\n  else\n  {\n    string_obj->value = NULL;\n  }\n\n  return ERROR_SUCCESS;\n}\n\n\nYR_OBJECT* yr_object_get_root(\n    YR_OBJECT* object)\n{\n  YR_OBJECT* o = object;\n\n  while (o->parent != NULL)\n    o = o->parent;\n\n  return o;\n}\n\nYR_API void yr_object_print_data(\n    YR_OBJECT* object,\n    int indent,\n    int print_identifier)\n{\n  YR_DICTIONARY_ITEMS* dict_items;\n  YR_ARRAY_ITEMS* array_items;\n  YR_STRUCTURE_MEMBER* member;\n\n  char indent_spaces[32];\n  int i;\n\n  indent = yr_min(indent, sizeof(indent_spaces) - 1);\n\n  memset(indent_spaces, '\\t', indent);\n  indent_spaces[indent] = '\\0';\n\n  if (print_identifier && object->type != OBJECT_TYPE_FUNCTION)\n    printf(\"%s%s\", indent_spaces, object->identifier);\n\n  switch(object->type)\n  {\n    case OBJECT_TYPE_INTEGER:\n      if (((YR_OBJECT_INTEGER*) object)->value != UNDEFINED)\n        printf(\" = %\" PRIu64, ((YR_OBJECT_INTEGER*) object)->value);\n      else\n        printf(\" = UNDEFINED\");\n      break;\n\n    case OBJECT_TYPE_STRING:\n      if (((YR_OBJECT_STRING*) object)->value != NULL)\n      {\n        size_t l;\n        printf(\" = \\\"\");\n\n        for (l = 0; l < ((YR_OBJECT_STRING*) object)->value->length; l++)\n        {\n          char c = ((YR_OBJECT_STRING*) object)->value->c_string[l];\n\n          if (isprint((unsigned char) c))\n            printf(\"%c\", c);\n          else\n            printf(\"\\\\x%02x\", (unsigned char) c);\n        }\n\n        printf(\"\\\"\");\n      }\n      else\n      {\n        printf(\" = UNDEFINED\");\n      }\n\n      break;\n\n    case OBJECT_TYPE_STRUCTURE:\n\n      member = ((YR_OBJECT_STRUCTURE*) object)->members;\n\n      while (member != NULL)\n      {\n        if (member->object->type != OBJECT_TYPE_FUNCTION)\n        {\n          printf(\"\\n\");\n          yr_object_print_data(member->object, indent + 1, 1);\n        }\n        member = member->next;\n      }\n\n      break;\n\n    case OBJECT_TYPE_ARRAY:\n      array_items = ((YR_OBJECT_ARRAY*) object)->items;\n\n      if (array_items != NULL)\n      {\n        for (i = 0; i < array_items->count; i++)\n        {\n          if (array_items->objects[i] != NULL)\n          {\n            printf(\"\\n%s\\t[%d]\", indent_spaces, i);\n            yr_object_print_data(array_items->objects[i], indent + 1, 0);\n          }\n        }\n      }\n\n      break;\n\n    case OBJECT_TYPE_DICTIONARY:\n\n      dict_items = ((YR_OBJECT_DICTIONARY*) object)->items;\n\n      if (dict_items != NULL)\n      {\n        for (i = 0; i < dict_items->used; i++)\n        {\n          printf(\"\\n%s\\t%s\", indent_spaces, dict_items->objects[i].key);\n          yr_object_print_data(dict_items->objects[i].obj, indent + 1, 0);\n        }\n      }\n\n      break;\n  }\n}\n", "/*\nCopyright (c) 2014. The YARA Authors. All Rights Reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\nlist of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#include <string.h>\n#include <yara/mem.h>\n#include <yara/sizedstr.h>\n\n\nint sized_string_cmp(\n  SIZED_STRING* s1,\n  SIZED_STRING* s2)\n{\n  size_t i = 0;\n\n  while (s1->length > i &&\n         s2->length > i &&\n         s1->c_string[i] == s2->c_string[i])\n  {\n    i++;\n  }\n\n  if (i == s1->length && i == s2->length)\n    return 0;\n  else if (i == s1->length)\n    return -1;\n  else if (i == s2->length)\n    return 1;\n  else if (s1->c_string[i] < s2->c_string[i])\n    return -1;\n  else\n    return 1;\n}\n\n\nSIZED_STRING* sized_string_dup(\n    SIZED_STRING* s)\n{\n  SIZED_STRING* result = (SIZED_STRING*) yr_malloc(\n      sizeof(SIZED_STRING) + s->length);\n\n  if (result == NULL)\n    return NULL;\n\n  result->length = s->length;\n  result->flags = s->flags;\n\n  strncpy(result->c_string, s->c_string, s->length + 1);\n\n  return result;\n}\n", "/*\nCopyright (c) 2016. The YARA Authors. All Rights Reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\nlist of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#include <yara.h>\n#include \"blob.h\"\n#include \"util.h\"\n\n#if defined(_WIN32) || defined(__CYGWIN__)\n#include <fileapi.h>\n#else\n#include <unistd.h>\n#endif\n#include <fcntl.h>\n\nstatic void test_boolean_operators()\n{\n  assert_true_rule(\n      \"rule test { condition: true }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: true or false }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: true and true }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 0x1 and 0x2}\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: false }\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: true and false }\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: false or false }\", NULL);\n}\n\n\nstatic void test_comparison_operators()\n{\n  assert_true_rule(\n      \"rule test { condition: 2 > 1 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1 < 2 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 2 >= 1 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1 <= 1 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1 == 1 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1.5 == 1.5}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1.0 == 1}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1.5 >= 1.0}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1.5 >= 1}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1.0 >= 1}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 0.5 < 1}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 0.5 <= 1}\", NULL);\n\n  assert_true_rule(\n      \"rule rest { condition: 1.0 <= 1}\", NULL);\n\n  assert_true_rule(\n      \"rule rest { condition: \\\"abc\\\" == \\\"abc\\\"}\", NULL);\n\n  assert_true_rule(\n      \"rule rest { condition: \\\"abc\\\" <= \\\"abc\\\"}\", NULL);\n\n  assert_true_rule(\n      \"rule rest { condition: \\\"abc\\\" >= \\\"abc\\\"}\", NULL);\n\n  assert_true_rule(\n      \"rule rest { condition: \\\"ab\\\" < \\\"abc\\\"}\", NULL);\n\n  assert_true_rule(\n      \"rule rest { condition: \\\"abc\\\" > \\\"ab\\\"}\", NULL);\n\n  assert_true_rule(\n      \"rule rest { condition: \\\"abc\\\" < \\\"abd\\\"}\", NULL);\n\n  assert_true_rule(\n      \"rule rest { condition: \\\"abd\\\" > \\\"abc\\\"}\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: 1 != 1}\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: 1 != 1.0}\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: 2 > 3}\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: 2.1 < 2}\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: \\\"abc\\\" != \\\"abc\\\"}\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: \\\"abc\\\" > \\\"abc\\\"}\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: \\\"abc\\\" < \\\"abc\\\"}\", NULL);\n\n}\n\nstatic void test_arithmetic_operators()\n{\n  assert_true_rule(\n      \"rule test { condition: (1 + 1) * 2 == (9 - 1) \\\\ 2 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 5 % 2 == 1 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1.5 + 1.5 == 3}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 3 \\\\ 2 == 1}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 3.0 \\\\ 2 == 1.5}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1 + -1 == 0}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: -1 + -1 == -2}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 4 --2 * 2 == 8}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: -1.0 * 1 == -1.0}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1-1 == 0}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: -2.0-3.0 == -5}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: --1 == 1}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1--1 == 2}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: -0x01 == -1}\", NULL);\n\n}\n\n\nstatic void test_bitwise_operators()\n{\n  assert_true_rule(\n      \"rule test { condition: 0x55 | 0xAA == 0xFF }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: ~0xAA ^ 0x5A & 0xFF == (~0xAA) ^ (0x5A & 0xFF) }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: ~0x55 & 0xFF == 0xAA }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 8 >> 2 == 2 }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1 << 3 == 8 }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1 | 3 ^ 3 == 1 | (3 ^ 3) }\",\n      NULL);\n\n  assert_false_rule(\n      \"rule test { condition: ~0xAA ^ 0x5A & 0xFF == 0x0F }\",\n      NULL);\n\n  assert_false_rule(\n      \"rule test { condition: 1 | 3 ^ 3 == (1 | 3) ^ 3}\",\n      NULL);\n\n}\n\n\nstatic void test_syntax()\n{\n  assert_error(\n      \"rule test { strings: $a = \\\"a\\\" $a = \\\"a\\\" condition: all of them }\",\n      ERROR_DUPLICATED_STRING_IDENTIFIER);\n}\n\n\nstatic void test_anonymous_strings()\n{\n  assert_true_rule(\n      \"rule test { strings: $ = \\\"a\\\" $ = \\\"b\\\" condition: all of them }\",\n      \"ab\");\n}\n\n\nstatic void test_strings()\n{\n  char* str = \"---- abc ---- xyz\";\n  uint8_t blob[] = \"---- a\\0b\\0c\\0 -\\0-\\0-\\0-\\0x\\0y\\0z\\0\";\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"a\\\" condition: $a }\",\n      str);\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ab\\\" condition: $a }\",\n      str);\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"abc\\\" condition: $a }\",\n      str);\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"xyz\\\" condition: $a }\",\n      str);\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"abc\\\" nocase fullword condition: $a }\",\n      str);\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"aBc\\\" nocase  condition: $a }\",\n      str);\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"abc\\\" fullword condition: $a }\",\n      str);\n\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"a\\\" fullword condition: $a }\",\n      str);\n\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"ab\\\" fullword condition: $a }\",\n      str);\n\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"abc\\\" wide fullword condition: $a }\",\n      str);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"a\\\" wide condition: $a }\",\n      blob);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"a\\\" wide ascii condition: $a }\",\n      blob);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"ab\\\" wide condition: $a }\",\n      blob);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"ab\\\" wide ascii condition: $a }\",\n      blob);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" wide condition: $a }\",\n      blob);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" wide nocase fullword condition: $a }\",\n      blob);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"aBc\\\" wide nocase condition: $a }\",\n      blob);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"aBc\\\" wide ascii nocase condition: $a }\",\n      blob);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"---xyz\\\" wide nocase condition: $a }\",\n      blob);\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"abc\\\" fullword condition: $a }\",\n      \"abc\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"abc\\\" fullword condition: $a }\",\n      \"xabcx\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"abc\\\" fullword condition: $a }\",\n      \"xabc\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"abc\\\" fullword condition: $a }\",\n      \"abcx\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"abc\\\" ascii wide fullword condition: $a }\",\n      \"abcx\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" ascii wide fullword condition: $a }\",\n      \"a\\0abc\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" wide fullword condition: $a }\",\n      \"a\\0b\\0c\\0\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" wide fullword condition: $a }\",\n      \"x\\0a\\0b\\0c\\0x\\0\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = \\\"ab\\\" wide fullword condition: $a }\",\n      \"x\\0a\\0b\\0\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" wide fullword condition: $a }\",\n      \"x\\0a\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" wide fullword condition: $a }\",\n      \"x\\001a\\0b\\0c\\0\");\n\n  assert_true_rule(\n      \"rule test {\\n\\\n         strings:\\n\\\n             $a = \\\"abcdef\\\"\\n\\\n             $b = \\\"cdef\\\"\\n\\\n             $c = \\\"ef\\\"\\n\\\n         condition:\\n\\\n             all of them\\n\\\n       }\", \"abcdef\");\n}\n\n\nstatic void test_wildcard_strings()\n{\n  assert_true_rule_blob(\n      \"rule test {\\n\\\n         strings:\\n\\\n             $s1 = \\\"abc\\\"\\n\\\n             $s2 = \\\"xyz\\\"\\n\\\n         condition:\\n\\\n             for all of ($*) : ($)\\n\\\n      }\",\n      \"---- abc ---- A\\x00\"\"B\\x00\"\"C\\x00 ---- xyz\");\n}\n\n\nstatic void test_hex_strings()\n{\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 64 01 00 00 60 01 } \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 64 0? 00 00 ?0 01 } \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\\\n\n      \"rule test { \\\n        strings: $a = { 6? 01 00 00 60 0? } \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 64 01 [1-3] 60 01 } \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 64 01 [1-3] (60|61) 01 } \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 4D 5A [-] 6A 2A [-] 58 C3} \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 4D 5A [300-] 6A 2A [-] 58 C3} \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 2e 7? (65 | ?? ) 78 } \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_false_rule_blob(\n      \"rule test { \\\n        strings: $a = { 4D 5A [0-300] 6A 2A } \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_false_rule_blob(\n      \"rule test { \\\n        strings: $a = { 4D 5A [0-128] 45 [0-128] 01 [0-128]  C3 } \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [-] 38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [-] // Inline comment\\n\\r \\\n          38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 /* Inline comment */ [-] 38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 /* Inline multi-line\\n\\r \\\n                                 comment */ [-] 38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = {\\n 31 32 [-] 38 39 \\n\\r} \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [-] 33 34 [-] 38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [1] 34 35 [2] 38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test {\\\n         strings: $a = { 31 32 [1-] 34 35 [1-] 38 39 } \\\n         condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-3] 34 35 [1-] 38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-2] 35 [1-] 37 38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-1] 33 } \\\n        condition: !a == 3}\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-1] 34 } \\\n        condition: !a == 4}\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-2] 34 } \\\n        condition: !a == 4 }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [-] 38 39 } \\\n        condition: all of them }\",\n      \"1234567890\");\n\n  assert_false_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [-] 32 33 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_false_rule(\n      \"rule test { \\\n        strings: $a = { 35 36 [-] 31 32 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_false_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [2-] 34 35 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-1] 33 34 [0-2] 36 37 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-1] 34 35 [0-2] 36 37 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_false_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-3] 37 38 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [1] 33 34 } \\\n        condition: $a }\",\n      \"12\\n34\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = {31 32 [3-6] 32} \\\n        condition: !a == 6 }\",\n      \"12111222\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = {31 [0-3] (32|33)} \\\n        condition: !a == 2 }\",\n      \"122222222\");\n\n  assert_error(\n      \"rule test { \\\n        strings: $a = { 01 [0] 02 } \\\n        condition: $a }\",\n      ERROR_INVALID_HEX_STRING);\n\n  assert_error(\n      \"rule test { \\\n        strings: $a = { [-] 01 02 } condition: $a }\",\n      ERROR_INVALID_HEX_STRING);\n\n  assert_error(\n      \"rule test { \\\n        strings: $a = { 01 02 [-] } \\\n        condition: $a }\",\n      ERROR_INVALID_HEX_STRING);\n\n  assert_error(\n      \"rule test { \\\n        strings: $a = { 01 02 ([-] 03 | 04) } \\\n        condition: $a }\",\n      ERROR_INVALID_HEX_STRING);\n\n  assert_error(\n      \"rule test { \\\n        strings: $a = { 01 02 (03 [-] | 04) } \\\n        condition: $a }\",\n      ERROR_INVALID_HEX_STRING);\n\n  assert_error(\n      \"rule test { \\\n        strings: $a = { 01 02 (03 | 04 [-]) } \\\n        condition: $a \",\n      ERROR_INVALID_HEX_STRING);\n\n  /* TODO: tests.py:551 ff. */\n}\n\n\nstatic void test_count()\n{\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ssi\\\" condition: #a == 2 }\",\n      \"mississippi\");\n}\n\n\nstatic void test_at()\n{\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = \\\"ssi\\\" \\\n        condition: $a at 2 and $a at 5 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = \\\"mis\\\" \\\n        condition: $a at ~0xFF & 0xFF }\",\n      \"mississippi\");\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 00 00 00 00 ?? 74 65 78 74 } \\\n        condition: $a at 308}\",\n      PE32_FILE);\n}\n\n\nstatic void test_in()\n{\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 6a 2a 58 c3 } \\\n        condition: $a in (entrypoint .. entrypoint + 1) }\",\n      PE32_FILE);\n}\n\n\nstatic void test_offset()\n{\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ssi\\\" condition: @a == 2 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ssi\\\" condition: @a == @a[1] }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ssi\\\" condition: @a[2] == 5 }\",\n      \"mississippi\");\n}\n\n\nstatic void test_length()\n{\n  assert_true_rule(\n      \"rule test { strings: $a = /m.*?ssi/ condition: !a == 5 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /m.*?ssi/ condition: !a[1] == 5 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /m.*ssi/ condition: !a == 8 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /m.*ssi/ condition: !a[1] == 8 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ssi.*ppi/ condition: !a[1] == 9 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ssi.*ppi/ condition: !a[2] == 6 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = { 6D [1-3] 73 73 69 } condition: !a == 5}\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = { 6D [-] 73 73 69 } condition: !a == 5}\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = { 6D [-] 70 70 69 } condition: !a == 11}\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = { 6D 69 73 73 [-] 70 69 } condition: !a == 11}\",\n      \"mississippi\");\n}\n\n\nstatic void test_of()\n{\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ssi\\\" $b = \\\"mis\\\" $c = \\\"oops\\\" \"\n      \"condition: any of them }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ssi\\\" $b = \\\"mis\\\" $c = \\\"oops\\\" \"\n      \"condition: 1 of them }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ssi\\\" $b = \\\"mis\\\" $c = \\\"oops\\\" \"\n      \"condition: 2 of them }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a1 = \\\"dummy1\\\" $b1 = \\\"dummy1\\\" $b2 = \\\"ssi\\\"\"\n      \"condition: any of ($a*, $b*) }\",\n      \"mississippi\");\n\n  assert_true_rule_blob(\n      \"rule test { \\\n         strings: \\\n           $ = /abc/ \\\n           $ = /def/ \\\n           $ = /ghi/ \\\n         condition: \\\n           for any of ($*) : ( for any i in (1..#): (uint8(@[i] - 1) == 0x00) )\\\n       }\",\n       \"abc\\000def\\000ghi\");\n\n  assert_false_rule(\n      \"rule test { \\\n        strings: \\\n          $a = \\\"ssi\\\" \\\n          $b = \\\"mis\\\" \\\n          $c = \\\"oops\\\" \\\n        condition: \\\n          all of them \\\n      }\",\n      \"mississippi\");\n\n  assert_error(\n      \"rule test { condition: all of ($a*) }\",\n      ERROR_UNDEFINED_STRING);\n\n  assert_error(\n      \"rule test { condition: all of them }\",\n      ERROR_UNDEFINED_STRING);\n}\n\n\nvoid test_for()\n{\n  assert_true_rule(\n      \"rule test { \\\n        strings: \\\n          $a = \\\"ssi\\\" \\\n        condition: \\\n          for all i in (1..#a) : (@a[i] >= 2 and @a[i] <= 5) \\\n      }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: \\\n          $a = \\\"ssi\\\" \\\n          $b = \\\"mi\\\" \\\n        condition: \\\n          for all i in (1..#a) : ( for all j in (1..#b) : (@a[i] >= @b[j])) \\\n      }\",\n      \"mississippi\");\n\n  assert_false_rule(\n      \"rule test { \\\n        strings: \\\n          $a = \\\"ssi\\\" \\\n        condition: \\\n          for all i in (1..#a) : (@a[i] == 5) \\\n      }\",\n      \"mississippi\");\n}\n\n\nvoid test_re()\n{\n  assert_true_rule(\n      \"rule test { strings: $a = /ssi/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ssi(s|p)/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ssim*/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ssa?/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /Miss/ nocase condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /(M|N)iss/ nocase condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /[M-N]iss/ nocase condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /(Mi|ssi)ssippi/ nocase condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ppi\\\\tmi/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ppi\\\\.mi/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /^mississippi/ fullword condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /mississippi.*mississippi$/s condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /^ssi/ condition: $a }\",\n      \"mississippi\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /ssi$/ condition: $a }\",\n      \"mississippi\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /ssissi/ fullword condition: $a }\",\n      \"mississippi\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /^[isp]+/ condition: $a }\",\n      \"mississippi\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /a.{1,2}b/ wide condition: !a == 6 }\",\n      \"a\\0x\\0b\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /a.{1,2}b/ wide condition: !a == 8 }\",\n      \"a\\0x\\0x\\0b\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"a\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"\\0a\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"\\ta\\0b\\0c\\0\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"x\\0a\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"x\\ta\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0\\t\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0x\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0b\\t\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = /\\\\b/ wide condition: $a }\",\n      \"abc\");\n\n  assert_regexp_syntax_error(\")\");\n  assert_true_regexp(\"abc\", \"abc\", \"abc\");\n  assert_false_regexp(\"abc\", \"xbc\");\n  assert_false_regexp(\"abc\", \"axc\");\n  assert_false_regexp(\"abc\", \"abx\");\n  assert_true_regexp(\"abc\", \"xabcx\", \"abc\");\n  assert_true_regexp(\"abc\", \"ababc\", \"abc\");\n  assert_true_regexp(\"a.c\", \"abc\", \"abc\");\n  assert_false_regexp(\"a.b\", \"a\\nb\");\n  assert_false_regexp(\"a.*b\", \"acc\\nccb\");\n  assert_false_regexp(\"a.{4,5}b\", \"acc\\nccb\");\n  assert_true_regexp(\"a.b\", \"a\\rb\", \"a\\rb\");\n  assert_true_regexp(\"ab*c\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab*c\", \"ac\", \"ac\");\n  assert_true_regexp(\"ab*bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab*bc\", \"abbc\", \"abbc\");\n  assert_true_regexp(\"a.*bb\", \"abbbb\", \"abbbb\");\n  assert_true_regexp(\"a.*?bbb\", \"abbbbbb\", \"abbb\");\n  assert_true_regexp(\"a.*c\", \"ac\", \"ac\");\n  assert_true_regexp(\"a.*c\", \"axyzc\", \"axyzc\");\n  assert_true_regexp(\"ab+c\", \"abbc\", \"abbc\");\n  assert_false_regexp(\"ab+c\", \"ac\");\n  assert_true_regexp(\"ab+\", \"abbbb\", \"abbbb\");\n  assert_true_regexp(\"ab+?\", \"abbbb\", \"ab\");\n  assert_false_regexp(\"ab+bc\", \"abc\");\n  assert_false_regexp(\"ab+bc\", \"abq\");\n  assert_true_regexp(\"a+b+c\", \"aabbabc\", \"abc\");\n  assert_false_regexp(\"ab?bc\", \"abbbbc\");\n  assert_true_regexp(\"ab?c\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab*?\", \"abbb\", \"a\");\n  assert_true_regexp(\"ab?c\", \"ac\", \"ac\");\n  assert_true_regexp(\"ab??\", \"ab\", \"a\");\n  assert_true_regexp(\"a(b|x)c\", \"abc\", \"abc\");\n  assert_true_regexp(\"a(b|x)c\", \"axc\", \"axc\");\n  assert_true_regexp(\"a(b|.)c\", \"axc\", \"axc\");\n  assert_true_regexp(\"a(b|x|y)c\", \"ayc\", \"ayc\");\n  assert_true_regexp(\"(a+|b)*\", \"ab\", \"ab\");\n  assert_true_regexp(\"a|b|c|d|e\", \"e\", \"e\");\n  assert_true_regexp(\"(a|b|c|d|e)f\", \"ef\", \"ef\");\n  assert_true_regexp(\".b{2}\", \"abb\", \"abb\");\n  assert_true_regexp(\".b{2,3}\", \"abbb\", \"abbb\");\n  assert_true_regexp(\".b{2,3}?\", \"abbb\", \"abb\");\n  assert_true_regexp(\"ab{2,3}c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\"ab{2,3}?c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\".b{2,3}cccc\", \"abbbcccc\", \"abbbcccc\");\n  assert_true_regexp(\".b{2,3}?cccc\", \"abbbcccc\", \"bbbcccc\");\n  assert_true_regexp(\"a.b{2,3}cccc\", \"aabbbcccc\", \"aabbbcccc\");\n  assert_true_regexp(\"ab{2,3}c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\"ab{2,3}?c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\"ab{0,1}?c\", \"abc\", \"abc\");\n  assert_true_regexp(\"a{0,1}?bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"a{0,1}bc\", \"bbc\", \"bc\");\n  assert_true_regexp(\"a{0,1}?bc\", \"abc\", \"bc\");\n  assert_true_regexp(\"aa{0,1}?bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"aa{0,1}?bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"aa{0,1}bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab{1}c\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab{1,2}c\", \"abbc\", \"abbc\");\n  assert_true_regexp(\"ab{1,}c\", \"abbbc\", \"abbbc\");\n  assert_false_regexp(\"ab{1,}b\", \"ab\");\n  assert_false_regexp(\"ab{1}c\", \"abbc\");\n  assert_true_regexp(\"ab{0,}c\", \"ac\", \"ac\");\n  assert_true_regexp(\"ab{1,1}c\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab{0,}c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\"ab{,3}c\", \"abbbc\", \"abbbc\");\n  assert_false_regexp(\"ab{,2}c\", \"abbbc\");\n  assert_false_regexp(\"ab{4,5}bc\", \"abbbbc\");\n  assert_true_regexp(\"ab{0,1}\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{0,2}\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"ab{0,3}\", \"abbbbb\", \"abbb\");\n  assert_true_regexp(\"ab{0,4}\", \"abbbbb\", \"abbbb\");\n  assert_true_regexp(\"ab{1,1}\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{1,2}\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"ab{1,3}\", \"abbbbb\", \"abbb\");\n  assert_true_regexp(\"ab{2,2}\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"ab{2,3}\", \"abbbbb\", \"abbb\");\n  assert_true_regexp(\"ab{1,3}?\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{0,1}?\", \"abbbbb\", \"a\");\n  assert_true_regexp(\"ab{0,2}?\", \"abbbbb\", \"a\");\n  assert_true_regexp(\"ab{0,3}?\", \"abbbbb\", \"a\");\n  assert_true_regexp(\"ab{0,4}?\", \"abbbbb\", \"a\");\n  assert_true_regexp(\"ab{1,1}?\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{1,2}?\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{1,3}?\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{2,2}?\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"ab{2,3}?\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\".(abc){0,1}\", \"xabcabcabcabc\", \"xabc\");\n  assert_true_regexp(\".(abc){0,2}\", \"xabcabcabcabc\", \"xabcabc\");\n  assert_true_regexp(\"x{1,2}abcd\", \"xxxxabcd\", \"xxabcd\");\n  assert_true_regexp(\"x{1,2}abcd\", \"xxxxabcd\", \"xxabcd\");\n  assert_true_regexp(\"ab{.*}\", \"ab{c}\", \"ab{c}\");\n  assert_true_regexp(\".(aa){1,2}\", \"aaaaaaaaaa\", \"aaaaa\");\n  assert_true_regexp(\"a.(bc.){2}\", \"aabcabca\", \"aabcabca\");\n  assert_true_regexp(\"(ab{1,2}c){1,3}\", \"abbcabc\", \"abbcabc\");\n  assert_true_regexp(\"ab(c|cc){1,3}d\", \"abccccccd\", \"abccccccd\");\n  assert_true_regexp(\"a[bx]c\", \"abc\", \"abc\");\n  assert_true_regexp(\"a[bx]c\", \"axc\", \"axc\");\n  assert_true_regexp(\"a[0-9]*b\", \"ab\", \"ab\");\n  assert_true_regexp(\"a[0-9]*b\", \"a0123456789b\", \"a0123456789b\");\n  assert_true_regexp(\"[0-9a-f]+\", \"0123456789abcdef\", \"0123456789abcdef\");\n  assert_true_regexp(\"[0-9a-f]+\", \"xyz0123456789xyz\", \"0123456789\");\n  assert_true_regexp(\"a[\\\\s\\\\S]b\", \"a b\", \"a b\");\n  assert_true_regexp(\"a[\\\\d\\\\D]b\", \"a1b\", \"a1b\");\n  assert_false_regexp(\"[x-z]+\", \"abc\");\n  assert_true_regexp(\"a[-]?c\", \"ac\", \"ac\");\n  assert_true_regexp(\"a[-b]\", \"a-\", \"a-\");\n  assert_true_regexp(\"a[-b]\", \"ab\", \"ab\");\n  assert_true_regexp(\"a[b-]\", \"a-\", \"a-\");\n  assert_true_regexp(\"a[b-]\", \"ab\", \"ab\");\n  assert_true_regexp(\"[a-c-e]\", \"b\", \"b\");\n  assert_true_regexp(\"[a-c-e]\", \"-\", \"-\");\n  assert_false_regexp(\"[a-c-e]\", \"d\");\n  assert_regexp_syntax_error(\"[b-a]\");\n  assert_regexp_syntax_error(\"(abc\");\n  assert_regexp_syntax_error(\"abc)\");\n  assert_regexp_syntax_error(\"a[]b\");\n  assert_true_regexp(\"a[\\\\-b]\", \"a-\", \"a-\");\n  assert_true_regexp(\"a[\\\\-b]\", \"ab\", \"ab\");\n  assert_true_regexp(\"a]\", \"a]\", \"a]\");\n  assert_true_regexp(\"a[]]b\", \"a]b\", \"a]b\");\n  assert_true_regexp(\"a[\\\\]]b\", \"a]b\", \"a]b\");\n  assert_true_regexp(\"a[^bc]d\", \"aed\", \"aed\");\n  assert_false_regexp(\"a[^bc]d\", \"abd\");\n  assert_true_regexp(\"a[^-b]c\", \"adc\", \"adc\");\n  assert_false_regexp(\"a[^-b]c\", \"a-c\");\n  assert_false_regexp(\"a[^]b]c\", \"a]c\");\n  assert_true_regexp(\"a[^]b]c\", \"adc\", \"adc\");\n  assert_true_regexp(\"[^ab]*\", \"cde\", \"cde\");\n  assert_regexp_syntax_error(\")(\");\n  assert_true_regexp(\"a\\\\sb\", \"a b\", \"a b\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\tb\", \"a\\tb\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\rb\", \"a\\rb\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\nb\", \"a\\nb\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\vb\", \"a\\vb\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\fb\", \"a\\fb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a b\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\tb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\rb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\nb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\vb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\fb\");\n  assert_true_regexp(\"\\\\n\\\\r\\\\t\\\\f\\\\a\", \"\\n\\r\\t\\f\\a\", \"\\n\\r\\t\\f\\a\");\n  assert_true_regexp(\"[\\\\n][\\\\r][\\\\t][\\\\f][\\\\a]\", \"\\n\\r\\t\\f\\a\", \"\\n\\r\\t\\f\\a\");\n  assert_true_regexp(\"\\\\x01\\\\x02\\\\x03\", \"\\x01\\x02\\x03\", \"\\x01\\x02\\x03\");\n  assert_true_regexp(\"[\\\\x01-\\\\x03]+\", \"\\x01\\x02\\x03\", \"\\x01\\x02\\x03\");\n  assert_false_regexp(\"[\\\\x00-\\\\x02]+\", \"\\x03\\x04\\x05\");\n  assert_true_regexp(\"[\\\\x5D]\", \"]\", \"]\");\n  assert_true_regexp(\"[\\\\0x5A-\\\\x5D]\", \"\\x5B\", \"\\x5B\");\n  assert_true_regexp(\"[\\\\x5D-\\\\x5F]\", \"\\x5E\", \"\\x5E\");\n  assert_true_regexp(\"[\\\\x5C-\\\\x5F]\", \"\\x5E\", \"\\x5E\");\n  assert_true_regexp(\"[\\\\x5D-\\\\x5F]\", \"\\x5E\", \"\\x5E\");\n  assert_true_regexp(\"a\\\\wc\", \"abc\", \"abc\");\n  assert_true_regexp(\"a\\\\wc\", \"a_c\", \"a_c\");\n  assert_true_regexp(\"a\\\\wc\", \"a0c\", \"a0c\");\n  assert_false_regexp(\"a\\\\wc\", \"a*c\");\n  assert_true_regexp(\"\\\\w+\", \"--ab_cd0123--\", \"ab_cd0123\");\n  assert_true_regexp(\"[\\\\w]+\", \"--ab_cd0123--\", \"ab_cd0123\");\n  assert_true_regexp(\"\\\\D+\", \"1234abc5678\", \"abc\");\n  assert_true_regexp(\"[\\\\d]+\", \"0123456789\", \"0123456789\");\n  assert_true_regexp(\"[\\\\D]+\", \"1234abc5678\", \"abc\");\n  assert_true_regexp(\"[\\\\da-fA-F]+\", \"123abc\", \"123abc\");\n  assert_false_regexp(\"^(ab|cd)e\", \"abcde\");\n  assert_true_regexp(\"(abc|)ef\", \"abcdef\", \"ef\");\n  assert_true_regexp(\"(abc|)ef\", \"abcef\", \"abcef\");\n  assert_true_regexp(\"\\\\babc\", \"abc\", \"abc\");\n  assert_true_regexp(\"abc\\\\b\", \"abc\", \"abc\");\n  assert_false_regexp(\"\\\\babc\", \"1abc\");\n  assert_false_regexp(\"abc\\\\b\", \"abc1\");\n  assert_true_regexp(\"abc\\\\s\\\\b\", \"abc x\", \"abc \");\n  assert_false_regexp(\"abc\\\\s\\\\b\", \"abc  \");\n  assert_true_regexp(\"\\\\babc\\\\b\", \" abc \", \"abc\");\n  assert_true_regexp(\"\\\\b\\\\w\\\\w\\\\w\\\\b\", \" abc \", \"abc\");\n  assert_true_regexp(\"\\\\w\\\\w\\\\w\\\\b\", \"abcd\", \"bcd\");\n  assert_true_regexp(\"\\\\b\\\\w\\\\w\\\\w\", \"abcd\", \"abc\");\n  assert_false_regexp(\"\\\\b\\\\w\\\\w\\\\w\\\\b\", \"abcd\");\n  assert_false_regexp(\"\\\\Babc\", \"abc\");\n  assert_false_regexp(\"abc\\\\B\", \"abc\");\n  assert_true_regexp(\"\\\\Babc\", \"1abc\", \"abc\");\n  assert_true_regexp(\"abc\\\\B\", \"abc1\", \"abc\");\n  assert_false_regexp(\"abc\\\\s\\\\B\", \"abc x\");\n  assert_true_regexp(\"abc\\\\s\\\\B\", \"abc  \", \"abc \");\n  assert_true_regexp(\"\\\\w\\\\w\\\\w\\\\B\", \"abcd\", \"abc\");\n  assert_true_regexp(\"\\\\B\\\\w\\\\w\\\\w\", \"abcd\", \"bcd\");\n  assert_false_regexp(\"\\\\B\\\\w\\\\w\\\\w\\\\B\", \"abcd\");\n\n  // This is allowed in most regexp engines but in order to keep the\n  // grammar free of shift/reduce conflicts I've decided not supporting\n  // it. Users can use the (abc|) form instead.\n  assert_regexp_syntax_error(\"(|abc)ef\");\n\n  assert_true_regexp(\"((a)(b)c)(d)\", \"abcd\", \"abcd\");\n  assert_true_regexp(\"(a|b)c*d\", \"abcd\", \"bcd\");\n  assert_true_regexp(\"(ab|ab*)bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"a([bc]*)c*\", \"abc\", \"abc\");\n  assert_true_regexp(\"a([bc]*)c*\", \"ac\", \"ac\");\n  assert_true_regexp(\"a([bc]*)c*\", \"a\", \"a\");\n  assert_true_regexp(\"a([bc]*)(c*d)\", \"abcd\", \"abcd\");\n  assert_true_regexp(\"a([bc]+)(c*d)\", \"abcd\", \"abcd\");\n  assert_true_regexp(\"a([bc]*)(c+d)\", \"abcd\", \"abcd\");\n  assert_true_regexp(\"a[bcd]*dcdcde\", \"adcdcde\", \"adcdcde\");\n  assert_false_regexp(\"a[bcd]+dcdcde\", \"adcdcde\");\n  assert_true_regexp(\"\\\\((.*), (.*)\\\\)\", \"(a, b)\", \"(a, b)\");\n  assert_true_regexp(\"abc|123$\", \"abcx\", \"abc\");\n  assert_false_regexp(\"abc|123$\", \"123x\");\n  assert_true_regexp(\"abc|^123\", \"123\", \"123\");\n  assert_false_regexp(\"abc|^123\", \"x123\");\n  assert_true_regexp(\"^abc$\", \"abc\", \"abc\");\n  assert_false_regexp(\"^abc$\", \"abcc\");\n  assert_true_regexp(\"^abc\", \"abcc\", \"abc\");\n  assert_false_regexp(\"^abc$\", \"aabc\");\n  assert_false_regexp(\"abc^\", \"abc\");\n  assert_false_regexp(\"ab^c\", \"abc\");\n  assert_false_regexp(\"a^bcdef\", \"abcdef\")\n  assert_true_regexp(\"abc$\", \"aabc\", \"abc\");\n  assert_false_regexp(\"$abc\", \"abc\");\n  assert_true_regexp(\"(a|a$)bcd\", \"abcd\", \"abcd\");\n  assert_false_regexp(\"(a$|a$)bcd\", \"abcd\");\n  assert_false_regexp(\"(abc$|ab$)\", \"abcd\");\n  assert_true_regexp(\"^a(bc+|b[eh])g|.h$\", \"abhg\", \"abhg\");\n  assert_true_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"effgz\", \"effgz\");\n  assert_true_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"ij\", \"ij\");\n  assert_false_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"effg\");\n  assert_false_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"bcdd\");\n  assert_true_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"reffgz\", \"effgz\");\n\n  // Test case for issue #324\n  assert_true_regexp(\"whatever|   x.   x\", \"   xy   x\", \"   xy   x\");\n\n  // test case for issue #503, \\x without two following hex-digits\n  assert_regexp_syntax_error(\"\\\\x0\");\n  assert_regexp_syntax_error(\"\\\\x\");\n\n  assert_regexp_syntax_error(\"x{0,0}\");\n  assert_regexp_syntax_error(\"x{0}\");\n\n  assert_regexp_syntax_error(\"\\\\xxy\");\n\n  assert_error(\n      \"rule test { strings: $a = /a\\\\/ condition: $a }\",\n      ERROR_SYNTAX_ERROR);\n\n  assert_error(\n      \"rule test { strings: $a = /[a\\\\/ condition: $a }\",\n      ERROR_SYNTAX_ERROR);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = /MZ.{300,}t/ \\\n        condition: !a == 317 }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = /MZ.{300,}?t/ \\\n        condition: !a == 314 }\",\n      PE32_FILE);\n}\n\n\nstatic void test_entrypoint()\n{\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 6a 2a 58 c3 } \\\n        condition: $a at entrypoint }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { b8 01 00 00 00 bb 2a } \\\n        condition: $a at entrypoint }\",\n      ELF32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { b8 01 00 00 00 bb 2a } \\\n        condition: $a at entrypoint }\",\n      ELF64_FILE);\n\n  assert_false_rule(\n      \"rule test { condition: entrypoint >= 0 }\",\n      NULL);\n}\n\n\nstatic void test_filesize()\n{\n  char rule[80];\n\n  snprintf(\n      rule,\n      sizeof(rule),\n      \"rule test { condition: filesize == %zd }\",\n      sizeof(PE32_FILE));\n\n  assert_true_rule_blob(\n      rule,\n      PE32_FILE);\n}\n\n\nstatic void test_comments()\n{\n  assert_true_rule(\n      \"rule test {\\n\\\n         condition:\\n\\\n             //  this is a comment\\n\\\n             /*** this is a comment ***/\\n\\\n             /* /* /*\\n\\\n                 this is a comment\\n\\\n             */\\n\\\n             true\\n\\\n      }\",\n      NULL);\n}\n\nstatic void test_matches_operator()\n{\n  assert_true_rule(\n      \"rule test { condition: \\\"foo\\\" matches /foo/ }\",\n      NULL);\n\n  assert_false_rule(\n      \"rule test { condition: \\\"foo\\\" matches /bar/ }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: \\\"FoO\\\" matches /fOo/i }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: \\\"xxFoOxx\\\" matches /fOo/i }\",\n      NULL);\n\n  assert_false_rule(\n      \"rule test { condition: \\\"xxFoOxx\\\" matches /^fOo/i }\",\n      NULL);\n\n  assert_false_rule(\n      \"rule test { condition: \\\"xxFoOxx\\\" matches /fOo$/i }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: \\\"foo\\\" matches /^foo$/i }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: \\\"foo\\\\nbar\\\" matches /foo.*bar/s }\",\n      NULL);\n\n  assert_false_rule(\n      \"rule test { condition: \\\"foo\\\\nbar\\\" matches /foo.*bar/ }\",\n      NULL);\n}\n\n\nstatic void test_global_rules()\n{\n  assert_true_rule(\n      \"global private rule global_rule { \\\n        condition: \\\n          true \\\n      } \\\n      rule test { \\\n        condition: true \\\n      }\",\n      NULL);\n\n  assert_false_rule(\n      \"global private rule global_rule { \\\n        condition: \\\n          false \\\n      } \\\n      rule test { \\\n        condition: true \\\n      }\",\n      NULL);\n}\n\n\nstatic void test_modules()\n{\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.constants.one + 1 == tests.constants.two \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.constants.foo == \\\"foo\\\" \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.constants.empty == \\\"\\\"  \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.empty() == \\\"\\\"  \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.struct_array[1].i == 1  \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.struct_array[0].i == 1 or true \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.integer_array[0] == 0 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.integer_array[1] == 1 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.string_array[0] == \\\"foo\\\" \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.string_array[2] == \\\"baz\\\" \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.string_dict[\\\"foo\\\"] == \\\"foo\\\" \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.string_dict[\\\"bar\\\"] == \\\"bar\\\" \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.isum(1,2) == 3 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.isum(1,2,3) == 6 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.fsum(1.0,2.0) == 3.0 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.fsum(1.0,2.0,3.0) == 6.0 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.foobar(1) == tests.foobar(1) \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.foobar(1) != tests.foobar(2) \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.length(\\\"dummy\\\") == 5 \\\n      }\",\n      NULL);\n\n\n  assert_false_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.struct_array[0].i == 1  \\\n      }\",\n      NULL);\n\n  assert_false_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.isum(1,1) == 3 \\\n      }\",\n      NULL);\n\n  assert_false_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.fsum(1.0,1.0) == 3.0 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.match(/foo/,\\\"foo\\\") == 3 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.match(/foo/,\\\"bar\\\") == -1\\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.match(/foo.bar/i,\\\"FOO\\\\nBAR\\\") == -1\\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.match(/foo.bar/is,\\\"FOO\\\\nBAR\\\") == 7\\\n      }\",\n      NULL);\n\n  assert_error(\n      \"import \\\"\\\\x00\\\"\",\n      ERROR_INVALID_MODULE_NAME);\n\n  assert_error(\n      \"import \\\"\\\"\",\n      ERROR_INVALID_MODULE_NAME);\n}\n\n#if defined(HASH_MODULE)\nstatic void test_hash_module()\n{\n  uint8_t blob[] = {0x61, 0x62, 0x63, 0x64, 0x65};\n\n  assert_true_rule_blob(\n      \"import \\\"hash\\\" \\\n       rule test { \\\n        condition: \\\n          hash.md5(0, filesize) == \\\n            \\\"ab56b4d92b40713acc5af89985d4b786\\\" \\\n            and \\\n          hash.md5(1, filesize) == \\\n            \\\"e02cfbe5502b64aa5ae9f2d0d69eaa8d\\\" \\\n            and \\\n          hash.sha1(0, filesize) == \\\n            \\\"03de6c570bfe24bfc328ccd7ca46b76eadaf4334\\\" \\\n            and \\\n          hash.sha1(1, filesize) == \\\n            \\\"a302d65ae4d9e768a1538d53605f203fd8e2d6e2\\\" \\\n            and \\\n          hash.sha256(0, filesize) == \\\n            \\\"36bbe50ed96841d10443bcb670d6554f0a34b761be67ec9c4a8ad2c0c44ca42c\\\" \\\n            and \\\n          hash.sha256(1, filesize) == \\\n            \\\"aaaaf2863e043b9df604158ad5c16ff1adaf3fd7e9fcea5dcb322b6762b3b59a\\\" \\\n      }\",\n      blob);\n\n  // Test hash caching mechanism\n\n  assert_true_rule_blob(\n      \"import \\\"hash\\\" \\\n       rule test { \\\n        condition: \\\n          hash.md5(0, filesize) == \\\n            \\\"ab56b4d92b40713acc5af89985d4b786\\\" \\\n            and \\\n          hash.md5(1, filesize) == \\\n            \\\"e02cfbe5502b64aa5ae9f2d0d69eaa8d\\\" \\\n            and \\\n          hash.md5(0, filesize) == \\\n            \\\"ab56b4d92b40713acc5af89985d4b786\\\" \\\n            and \\\n          hash.md5(1, filesize) == \\\n            \\\"e02cfbe5502b64aa5ae9f2d0d69eaa8d\\\" \\\n      }\",\n      blob);\n}\n#endif\n\n\nvoid test_integer_functions()\n{\n  assert_true_rule(\n      \"rule test { condition: uint8(0) == 0xAA}\",\n      \"\\xaa\\xbb\\xcc\\xdd\");\n\n  assert_true_rule(\n      \"rule test { condition: uint16(0) == 0xBBAA}\",\n      \"\\xaa\\xbb\\xcc\\xdd\");\n\n  assert_true_rule(\n      \"rule test { condition: uint32(0) == 0xDDCCBBAA}\",\n      \"\\xaa\\xbb\\xcc\\xdd\");\n\n  assert_true_rule(\n      \"rule test { condition: uint8be(0) == 0xAA}\",\n      \"\\xaa\\xbb\\xcc\\xdd\");\n\n  assert_true_rule(\n      \"rule test { condition: uint16be(0) == 0xAABB}\",\n      \"\\xaa\\xbb\\xcc\\xdd\");\n\n  assert_true_rule(\n      \"rule test { condition: uint32be(0) == 0xAABBCCDD}\",\n      \"\\xaa\\xbb\\xcc\\xdd\");\n}\n\n\nvoid test_file_descriptor()\n{\n  YR_COMPILER* compiler = NULL;\n  YR_RULES* rules = NULL;\n\n#if defined(_WIN32) || defined(__CYGWIN__)\n  HANDLE fd = CreateFile(\"tests/data/true.yar\", GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);\n  if (fd == INVALID_HANDLE_VALUE)\n  {\n    fputs(\"CreateFile failed\", stderr);\n    exit(1);\n  }\n#else\n  int fd = open(\"tests/data/true.yar\", O_RDONLY);\n  if (fd < 0)\n  {\n    perror(\"open\");\n    exit(EXIT_FAILURE);\n  }\n#endif\n  if (yr_compiler_create(&compiler) != ERROR_SUCCESS)\n  {\n    perror(\"yr_compiler_create\");\n    exit(EXIT_FAILURE);\n  }\n\n  if (yr_compiler_add_fd(compiler, fd, NULL, NULL) != 0) {\n    perror(\"yr_compiler_add_fd\");\n    exit(EXIT_FAILURE);\n  }\n\n#if defined(_WIN32) || defined(__CYGWIN__)\n  CloseHandle(fd);\n#else\n  close(fd);\n#endif\n\n  if (yr_compiler_get_rules(compiler, &rules) != ERROR_SUCCESS) {\n    perror(\"yr_compiler_add_fd\");\n    exit(EXIT_FAILURE);\n  }\n\n  if (compiler)\n  {\n    yr_compiler_destroy(compiler);\n  }\n  if (rules)\n  {\n    yr_rules_destroy(rules);\n  }\n\n  return;\n}\n\n\nint main(int argc, char** argv)\n{\n  yr_initialize();\n\n  test_boolean_operators();\n  test_comparison_operators();\n  test_arithmetic_operators();\n  test_bitwise_operators();\n  test_matches_operator();\n  test_syntax();\n  test_anonymous_strings();\n  test_strings();\n  test_wildcard_strings();\n  test_hex_strings();\n  test_count();\n  test_at();\n  test_in();\n  test_offset();\n  test_length();\n  test_of();\n  test_for();\n  test_re();\n  test_filesize();\n  // test_compile_file();\n  // test_compile_files();\n  // test_include_files();\n  // test_externals();\n  // test_callback();\n  // test_compare();\n  test_comments();\n  test_modules();\n  test_integer_functions();\n  // test_string_io();\n  test_entrypoint();\n  test_global_rules();\n\n  #if defined(HASH_MODULE)\n  test_hash_module();\n  #endif\n\n  test_file_descriptor();\n\n  yr_finalize();\n\n  return 0;\n}\n"], "filenames": ["libyara/arena.c", "libyara/exec.c", "libyara/include/yara/object.h", "libyara/include/yara/sizedstr.h", "libyara/modules/tests.c", "libyara/object.c", "libyara/sizedstr.c", "tests/test-rules.c"], "buggy_code_start_loc": [319, 36, 86, 54, 90, 576, 29, 1444], "buggy_code_end_loc": [320, 1148, 86, 65, 127, 581, 56, 1444], "fixing_code_start_loc": [319, 37, 87, 54, 91, 576, 30, 1445], "fixing_code_end_loc": [320, 1177, 92, 69, 146, 593, 77, 1459], "type": "CWE-416", "message": "The sized_string_cmp function in libyara/sizedstr.c in YARA 3.5.0 allows remote attackers to cause a denial of service (use-after-free and application crash) via a crafted rule.", "other": {"cve": {"id": "CVE-2017-8929", "sourceIdentifier": "cve@mitre.org", "published": "2017-05-14T22:29:00.227", "lastModified": "2017-05-23T18:22:03.960", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The sized_string_cmp function in libyara/sizedstr.c in YARA 3.5.0 allows remote attackers to cause a denial of service (use-after-free and application crash) via a crafted rule."}, {"lang": "es", "value": "La funci\u00f3n sized_string_cmp en YARA 3.5.0 permite a los atacantes remotos provocar una denegaci\u00f3n de servicio (uso de memoria previamente liberada y cierre inesperado de la aplicaci\u00f3n) mediante una regla manipulada."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:virustotal:yara:3.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "0254F781-4B89-4557-8F17-1F228A3A8216"}]}]}], "references": [{"url": "https://github.com/VirusTotal/yara/commit/053e67e3ec81cc9268ce30eaf0d6663d8639ed1e", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/VirusTotal/yara/issues/658", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}]}, "github_commit_url": "https://github.com/VirusTotal/yara/commit/053e67e3ec81cc9268ce30eaf0d6663d8639ed1e"}}