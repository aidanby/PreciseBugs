{"buggy_code": ["/*\n * Copyright (c) 2002 - 2003\n * NetGroup, Politecnico di Torino (Italy)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the Politecnico di Torino nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include \"ftmacros.h\"\n#include \"varattrs.h\"\n\n#include <errno.h>\t\t// for the errno variable\n#include <stdlib.h>\t\t// for malloc(), free(), ...\n#include <string.h>\t\t// for strlen(), ...\n\n#ifdef _WIN32\n  #include <process.h>\t\t// for threads\n#else\n  #include <unistd.h>\n  #include <pthread.h>\n  #include <signal.h>\n  #include <sys/time.h>\n  #include <sys/types.h>\t// for select() and such\n  #include <pwd.h>\t\t// for password management\n#endif\n\n#ifdef HAVE_GETSPNAM\n#include <shadow.h>\t\t// for password management\n#endif\n\n#include <pcap.h>\t\t// for libpcap/WinPcap calls\n\n#include \"fmtutils.h\"\n#include \"sockutils.h\"\t\t// for socket calls\n#include \"portability.h\"\n#include \"rpcap-protocol.h\"\n#include \"daemon.h\"\n#include \"log.h\"\n\n//\n// Timeout, in seconds, when we're waiting for a client to send us an\n// authentication request; if they don't send us a request within that\n// interval, we drop the connection, so we don't stay stuck forever.\n//\n#define RPCAP_TIMEOUT_INIT 90\n\n//\n// Timeout, in seconds, when we're waiting for an authenticated client\n// to send us a request, if a capture isn't in progress; if they don't\n// send us a request within that interval, we drop the connection, so\n// we don't stay stuck forever.\n//\n#define RPCAP_TIMEOUT_RUNTIME 180\n\n//\n// Time, in seconds, that we wait after a failed authentication attempt\n// before processing the next request; this prevents a client from\n// rapidly trying different accounts or passwords.\n//\n#define RPCAP_SUSPEND_WRONGAUTH 1\n\n// Parameters for the service loop.\nstruct daemon_slpars\n{\n\tSOCKET sockctrl;\t//!< SOCKET ID of the control connection\n\tint isactive;\t\t//!< Not null if the daemon has to run in active mode\n\tint nullAuthAllowed;\t//!< '1' if we permit NULL authentication, '0' otherwise\n};\n\n//\n// Data for a session managed by a thread.\n// It includes both a Boolean indicating whether we *have* a thread,\n// and a platform-dependent (UN*X vs. Windows) identifier for the\n// thread; on Windows, we could use an invalid handle to indicate\n// that we don't have a thread, but there *is* no portable \"no thread\"\n// value for a pthread_t on UN*X.\n//\nstruct session {\n\tSOCKET sockctrl;\n\tSOCKET sockdata;\n\tuint8 protocol_version;\n\tpcap_t *fp;\n\tunsigned int TotCapt;\n\tint\thave_thread;\n#ifdef _WIN32\n\tHANDLE thread;\n#else\n\tpthread_t thread;\n#endif\n};\n\n// Locally defined functions\nstatic int daemon_msg_err(SOCKET sockctrl, uint32 plen);\nstatic int daemon_msg_auth_req(struct daemon_slpars *pars, uint32 plen);\nstatic int daemon_AuthUserPwd(char *username, char *password, char *errbuf);\n\nstatic int daemon_msg_findallif_req(uint8 ver, struct daemon_slpars *pars,\n    uint32 plen);\n\nstatic int daemon_msg_open_req(uint8 ver, struct daemon_slpars *pars,\n    uint32 plen, char *source, size_t sourcelen);\nstatic int daemon_msg_startcap_req(uint8 ver, struct daemon_slpars *pars,\n    uint32 plen, char *source, struct session **sessionp,\n    struct rpcap_sampling *samp_param);\nstatic int daemon_msg_endcap_req(uint8 ver, struct daemon_slpars *pars,\n    struct session *session);\n\nstatic int daemon_msg_updatefilter_req(uint8 ver, struct daemon_slpars *pars,\n    struct session *session, uint32 plen);\nstatic int daemon_unpackapplyfilter(SOCKET sockctrl, struct session *session, uint32 *plenp, char *errbuf);\n\nstatic int daemon_msg_stats_req(uint8 ver, struct daemon_slpars *pars,\n    struct session *session, uint32 plen, struct pcap_stat *stats,\n    unsigned int svrcapt);\n\nstatic int daemon_msg_setsampling_req(uint8 ver, struct daemon_slpars *pars,\n    uint32 plen, struct rpcap_sampling *samp_param);\n\nstatic void daemon_seraddr(struct sockaddr_storage *sockaddrin, struct rpcap_sockaddr *sockaddrout);\n#ifdef _WIN32\nstatic unsigned __stdcall daemon_thrdatamain(void *ptr);\n#else\nstatic void *daemon_thrdatamain(void *ptr);\nstatic void noop_handler(int sign);\n#endif\n\nstatic int rpcapd_recv_msg_header(SOCKET sock, struct rpcap_header *headerp);\nstatic int rpcapd_recv(SOCKET sock, char *buffer, size_t toread, uint32 *plen, char *errmsgbuf);\nstatic int rpcapd_discard(SOCKET sock, uint32 len);\nstatic void session_close(struct session *);\n\nint\ndaemon_serviceloop(SOCKET sockctrl, int isactive, char *passiveClients,\n    int nullAuthAllowed)\n{\n\tstruct daemon_slpars pars;\t\t// service loop parameters\n\tchar errbuf[PCAP_ERRBUF_SIZE + 1];\t// keeps the error string, prior to be printed\n\tchar errmsgbuf[PCAP_ERRBUF_SIZE + 1];\t// buffer for errors to send to the client\n\tint host_port_check_status;\n\tint nrecv;\n\tstruct rpcap_header header;\t\t// RPCAP message general header\n\tuint32 plen;\t\t\t\t// payload length from header\n\tint authenticated = 0;\t\t\t// 1 if the client has successfully authenticated\n\tchar source[PCAP_BUF_SIZE+1];\t\t// keeps the string that contains the interface to open\n\tint got_source = 0;\t\t\t// 1 if we've gotten the source from an open request\n#ifndef _WIN32\n\tstruct sigaction action;\n#endif\n\tstruct session *session = NULL;\t\t// struct session main variable\n\tconst char *msg_type_string;\t\t// string for message type\n\tint client_told_us_to_close = 0;\t// 1 if the client told us to close the capture\n\n\t// needed to save the values of the statistics\n\tstruct pcap_stat stats;\n\tunsigned int svrcapt;\n\n\tstruct rpcap_sampling samp_param;\t// in case sampling has been requested\n\n\t// Structures needed for the select() call\n\tfd_set rfds;\t\t\t\t// set of socket descriptors we have to check\n\tstruct timeval tv;\t\t\t// maximum time the select() can block waiting for data\n\tint retval;\t\t\t\t// select() return value\n\n\t*errbuf = 0;\t// Initialize errbuf\n\n\t// Set parameters structure\n\tpars.sockctrl = sockctrl;\n\tpars.isactive = isactive;\t\t// active mode\n\tpars.nullAuthAllowed = nullAuthAllowed;\n\n\t//\n\t// We have a connection.\n\t//\n\t// If it's a passive mode connection, check whether the connecting\n\t// host is among the ones allowed.\n\t//\n\t// In either case, we were handed a copy of the host list; free it\n\t// as soon as we're done with it.\n\t//\n\tif (pars.isactive)\n\t{\n\t\t// Nothing to do.\n\t\tfree(passiveClients);\n\t\tpassiveClients = NULL;\n\t}\n\telse\n\t{\n\t\tstruct sockaddr_storage from;\n\t\tsocklen_t fromlen;\n\n\t\t//\n\t\t// Get the address of the other end of the connection.\n\t\t//\n\t\tfromlen = sizeof(struct sockaddr_storage);\n\t\tif (getpeername(pars.sockctrl, (struct sockaddr *)&from,\n\t\t    &fromlen) == -1)\n\t\t{\n\t\t\tsock_geterror(\"getpeername()\", errmsgbuf, PCAP_ERRBUF_SIZE);\n\t\t\tif (rpcap_senderror(pars.sockctrl, 0, PCAP_ERR_NETW, errmsgbuf, errbuf) == -1)\n\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\tgoto end;\n\t\t}\n\n\t\t//\n\t\t// Are they in the list of host/port combinations we allow?\n\t\t//\n\t\thost_port_check_status = sock_check_hostlist(passiveClients, RPCAP_HOSTLIST_SEP, &from, errmsgbuf, PCAP_ERRBUF_SIZE);\n\t\tfree(passiveClients);\n\t\tpassiveClients = NULL;\n\t\tif (host_port_check_status < 0)\n\t\t{\n\t\t\tif (host_port_check_status == -2) {\n\t\t\t\t//\n\t\t\t\t// We got an error; log it.\n\t\t\t\t//\n\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"%s\", errmsgbuf);\n\t\t\t}\n\n\t\t\t//\n\t\t\t// Sorry, we can't let you in.\n\t\t\t//\n\t\t\tif (rpcap_senderror(pars.sockctrl, 0, PCAP_ERR_HOSTNOAUTH, errmsgbuf, errbuf) == -1)\n\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\tgoto end;\n\t\t}\n\t}\n\n#ifndef _WIN32\n\t//\n\t// Catch SIGUSR1, but do nothing.  We use it to interrupt the\n\t// capture thread to break it out of a loop in which it's\n\t// blocked waiting for packets to arrive.\n\t//\n\t// We don't want interrupted system calls to restart, so that\n\t// the read routine for the pcap_t gets EINTR rather than\n\t// restarting if it's blocked in a system call.\n\t//\n\tmemset(&action, 0, sizeof (action));\n\taction.sa_handler = noop_handler;\n\taction.sa_flags = 0;\n\tsigemptyset(&action.sa_mask);\n\tsigaction(SIGUSR1, &action, NULL);\n#endif\n\n\t//\n\t// The client must first authenticate; loop until they send us a\n\t// message with a version we support and credentials we accept,\n\t// they send us a close message indicating that they're giving up,\n\t// or we get a network error or other fatal error.\n\t//\n\twhile (!authenticated)\n\t{\n\t\t//\n\t\t// If we're not in active mode, we use select(), with a\n\t\t// timeout, to wait for an authentication request; if\n\t\t// the timeout expires, we drop the connection, so that\n\t\t// a client can't just connect to us and leave us\n\t\t// waiting forever.\n\t\t//\n\t\tif (!pars.isactive)\n\t\t{\n\t\t\tFD_ZERO(&rfds);\n\t\t\t// We do not have to block here\n\t\t\ttv.tv_sec = RPCAP_TIMEOUT_INIT;\n\t\t\ttv.tv_usec = 0;\n\n\t\t\tFD_SET(pars.sockctrl, &rfds);\n\n\t\t\tretval = select(pars.sockctrl + 1, &rfds, NULL, NULL, &tv);\n\t\t\tif (retval == -1)\n\t\t\t{\n\t\t\t\tsock_geterror(\"select() failed\", errmsgbuf, PCAP_ERRBUF_SIZE);\n\t\t\t\tif (rpcap_senderror(pars.sockctrl, 0, PCAP_ERR_NETW, errmsgbuf, errbuf) == -1)\n\t\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\t// The timeout has expired\n\t\t\t// So, this was a fake connection. Drop it down\n\t\t\tif (retval == 0)\n\t\t\t{\n\t\t\t\tif (rpcap_senderror(pars.sockctrl, 0, PCAP_ERR_INITTIMEOUT, \"The RPCAP initial timeout has expired\", errbuf) == -1)\n\t\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\n\t\t//\n\t\t// Read the message header from the client.\n\t\t//\n\t\tnrecv = rpcapd_recv_msg_header(pars.sockctrl, &header);\n\t\tif (nrecv == -1)\n\t\t{\n\t\t\t// Fatal error.\n\t\t\tgoto end;\n\t\t}\n\t\tif (nrecv == -2)\n\t\t{\n\t\t\t// Client closed the connection.\n\t\t\tgoto end;\n\t\t}\n\n\t\tplen = header.plen;\n\n\t\t//\n\t\t// While we're in the authentication pharse, all requests\n\t\t// must use version 0.\n\t\t//\n\t\tif (header.ver != 0)\n\t\t{\n\t\t\t//\n\t\t\t// Send it back to them with their version.\n\t\t\t//\n\t\t\tif (rpcap_senderror(pars.sockctrl, header.ver,\n\t\t\t    PCAP_ERR_WRONGVER,\n\t\t\t    \"RPCAP version in requests in the authentication phase must be 0\",\n\t\t\t    errbuf) == -1)\n\t\t\t{\n\t\t\t\t// That failed; log a message and give up.\n\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\t// Discard the rest of the message and drop the\n\t\t\t// connection.\n\t\t\t(void)rpcapd_discard(pars.sockctrl, plen);\n\t\t\tgoto end;\n\t\t}\n\n\t\tswitch (header.type)\n\t\t{\n\t\t\tcase RPCAP_MSG_AUTH_REQ:\n\t\t\t\tretval = daemon_msg_auth_req(&pars, plen);\n\t\t\t\tif (retval == -1)\n\t\t\t\t{\n\t\t\t\t\t// Fatal error; a message has\n\t\t\t\t\t// been logged, so just give up.\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tif (retval == -2)\n\t\t\t\t{\n\t\t\t\t\t// Non-fatal error; we sent back\n\t\t\t\t\t// an error message, so let them\n\t\t\t\t\t// try again.\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// OK, we're authenticated; we sent back\n\t\t\t\t// a reply, so start serving requests.\n\t\t\t\tauthenticated = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase RPCAP_MSG_CLOSE:\n\t\t\t\t//\n\t\t\t\t// The client is giving up.\n\t\t\t\t// Discard the rest of the message, if\n\t\t\t\t// there is anything more.\n\t\t\t\t//\n\t\t\t\t(void)rpcapd_discard(pars.sockctrl, plen);\n\t\t\t\t// We're done with this client.\n\t\t\t\tgoto end;\n\n\t\t\tcase RPCAP_MSG_ERROR:\n\t\t\t\t// Log this and close the connection?\n\t\t\t\t// XXX - is this what happens in active\n\t\t\t\t// mode, where *we* initiate the\n\t\t\t\t// connection, and the client gives us\n\t\t\t\t// an error message rather than a \"let\n\t\t\t\t// me log in\" message, indicating that\n\t\t\t\t// we're not allowed to connect to them?\n\t\t\t\t(void)daemon_msg_err(pars.sockctrl, plen);\n\t\t\t\tgoto end;\n\n\t\t\tcase RPCAP_MSG_FINDALLIF_REQ:\n\t\t\tcase RPCAP_MSG_OPEN_REQ:\n\t\t\tcase RPCAP_MSG_STARTCAP_REQ:\n\t\t\tcase RPCAP_MSG_UPDATEFILTER_REQ:\n\t\t\tcase RPCAP_MSG_STATS_REQ:\n\t\t\tcase RPCAP_MSG_ENDCAP_REQ:\n\t\t\tcase RPCAP_MSG_SETSAMPLING_REQ:\n\t\t\t\t//\n\t\t\t\t// These requests can't be sent until\n\t\t\t\t// the client is authenticated.\n\t\t\t\t//\n\t\t\t\tmsg_type_string = rpcap_msg_type_string(header.type);\n\t\t\t\tif (msg_type_string != NULL)\n\t\t\t\t{\n\t\t\t\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"%s request sent before authentication was completed\", msg_type_string);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Message of type %u sent before authentication was completed\", header.type);\n\t\t\t\t}\n\t\t\t\tif (rpcap_senderror(pars.sockctrl, header.ver,\n\t\t\t\t    PCAP_ERR_WRONGMSG, errmsgbuf, errbuf) == -1)\n\t\t\t\t{\n\t\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\t// Discard the rest of the message.\n\t\t\t\tif (rpcapd_discard(pars.sockctrl, plen) == -1)\n\t\t\t\t{\n\t\t\t\t\t// Network error.\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase RPCAP_MSG_PACKET:\n\t\t\tcase RPCAP_MSG_FINDALLIF_REPLY:\n\t\t\tcase RPCAP_MSG_OPEN_REPLY:\n\t\t\tcase RPCAP_MSG_STARTCAP_REPLY:\n\t\t\tcase RPCAP_MSG_UPDATEFILTER_REPLY:\n\t\t\tcase RPCAP_MSG_AUTH_REPLY:\n\t\t\tcase RPCAP_MSG_STATS_REPLY:\n\t\t\tcase RPCAP_MSG_ENDCAP_REPLY:\n\t\t\tcase RPCAP_MSG_SETSAMPLING_REPLY:\n\t\t\t\t//\n\t\t\t\t// These are server-to-client messages.\n\t\t\t\t//\n\t\t\t\tmsg_type_string = rpcap_msg_type_string(header.type);\n\t\t\t\tif (msg_type_string != NULL)\n\t\t\t\t{\n\t\t\t\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Server-to-client message %s received from client\", msg_type_string);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Server-to-client message of type %u received from client\", header.type);\n\t\t\t\t}\n\t\t\t\tif (rpcap_senderror(pars.sockctrl, header.ver,\n\t\t\t\t    PCAP_ERR_WRONGMSG, errmsgbuf, errbuf) == -1)\n\t\t\t\t{\n\t\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\t// Discard the rest of the message.\n\t\t\t\tif (rpcapd_discard(pars.sockctrl, plen) == -1)\n\t\t\t\t{\n\t\t\t\t\t// Fatal error.\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t//\n\t\t\t\t// Unknown message type.\n\t\t\t\t//\n\t\t\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Unknown message type %u\", header.type);\n\t\t\t\tif (rpcap_senderror(pars.sockctrl, header.ver,\n\t\t\t\t    PCAP_ERR_WRONGMSG, errmsgbuf, errbuf) == -1)\n\t\t\t\t{\n\t\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\t// Discard the rest of the message.\n\t\t\t\tif (rpcapd_discard(pars.sockctrl, plen) == -1)\n\t\t\t\t{\n\t\t\t\t\t// Fatal error.\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t//\n\t// OK, the client has authenticated itself, and we can start\n\t// processing regular requests from it.\n\t//\n\n\t//\n\t// We don't have any statistics yet.\n\t//\n\tstats.ps_ifdrop = 0;\n\tstats.ps_recv = 0;\n\tstats.ps_drop = 0;\n\tsvrcapt = 0;\n\n\t//\n\t// Service requests.\n\t//\n\tfor (;;)\n\t{\n\t\terrbuf[0] = 0;\t// clear errbuf\n\n\t\t// Avoid zombies connections; check if the connection is opens but no commands are performed\n\t\t// from more than RPCAP_TIMEOUT_RUNTIME\n\t\t// Conditions:\n\t\t// - I have to be in normal mode (no active mode)\n\t\t// - if the device is open, I don't have to be in the middle of a capture (session->sockdata)\n\t\t// - if the device is closed, I have always to check if a new command arrives\n\t\t//\n\t\t// Be carefully: the capture can have been started, but an error occurred (so session != NULL, but\n\t\t//  sockdata is 0\n\t\tif ((!pars.isactive) &&  ((session == NULL) || ((session != NULL) && (session->sockdata == 0))))\n\t\t{\n\t\t\t// Check for the initial timeout\n\t\t\tFD_ZERO(&rfds);\n\t\t\t// We do not have to block here\n\t\t\ttv.tv_sec = RPCAP_TIMEOUT_RUNTIME;\n\t\t\ttv.tv_usec = 0;\n\n\t\t\tFD_SET(pars.sockctrl, &rfds);\n\n\t\t\tretval = select(pars.sockctrl + 1, &rfds, NULL, NULL, &tv);\n\t\t\tif (retval == -1)\n\t\t\t{\n\t\t\t\tsock_geterror(\"select() failed\", errmsgbuf, PCAP_ERRBUF_SIZE);\n\t\t\t\tif (rpcap_senderror(pars.sockctrl, 0,\n\t\t\t\t    PCAP_ERR_NETW, errmsgbuf, errbuf) == -1)\n\t\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\t// The timeout has expired\n\t\t\t// So, this was a fake connection. Drop it down\n\t\t\tif (retval == 0)\n\t\t\t{\n\t\t\t\tif (rpcap_senderror(pars.sockctrl, 0,\n\t\t\t\t    PCAP_ERR_INITTIMEOUT,\n\t\t\t\t    \"The RPCAP initial timeout has expired\",\n\t\t\t\t    errbuf) == -1)\n\t\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\n\t\t//\n\t\t// Read the message header from the client.\n\t\t//\n\t\tnrecv = rpcapd_recv_msg_header(pars.sockctrl, &header);\n\t\tif (nrecv == -1)\n\t\t{\n\t\t\t// Fatal error.\n\t\t\tgoto end;\n\t\t}\n\t\tif (nrecv == -2)\n\t\t{\n\t\t\t// Client closed the connection.\n\t\t\tgoto end;\n\t\t}\n\n\t\tplen = header.plen;\n\n\t\t//\n\t\t// Did the client specify a protocol version that we\n\t\t// support?\n\t\t//\n\t\tif (!RPCAP_VERSION_IS_SUPPORTED(header.ver))\n\t\t{\n\t\t\t//\n\t\t\t// Tell them it's not a supported version.\n\t\t\t// Send the error message with their version,\n\t\t\t// so they don't reject it as having the wrong\n\t\t\t// version.\n\t\t\t//\n\t\t\tif (rpcap_senderror(pars.sockctrl,\n\t\t\t    header.ver, PCAP_ERR_WRONGVER,\n\t\t\t    \"RPCAP version in message isn't supported by the server\",\n\t\t\t    errbuf) == -1)\n\t\t\t{\n\t\t\t\t// That failed; log a message and give up.\n\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\t// Discard the rest of the message.\n\t\t\t(void)rpcapd_discard(pars.sockctrl, plen);\n\t\t\t// Give up on them.\n\t\t\tgoto end;\n\t\t}\n\n\t\tswitch (header.type)\n\t\t{\n\t\t\tcase RPCAP_MSG_ERROR:\t\t// The other endpoint reported an error\n\t\t\t{\n\t\t\t\t(void)daemon_msg_err(pars.sockctrl, plen);\n\t\t\t\t// Do nothing; just exit; the error code is already into the errbuf\n\t\t\t\t// XXX - actually exit....\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase RPCAP_MSG_FINDALLIF_REQ:\n\t\t\t{\n\t\t\t\tif (daemon_msg_findallif_req(header.ver, &pars, plen) == -1)\n\t\t\t\t{\n\t\t\t\t\t// Fatal error; a message has\n\t\t\t\t\t// been logged, so just give up.\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase RPCAP_MSG_OPEN_REQ:\n\t\t\t{\n\t\t\t\t//\n\t\t\t\t// Process the open request, and keep\n\t\t\t\t// the source from it, for use later\n\t\t\t\t// when the capture is started.\n\t\t\t\t//\n\t\t\t\t// XXX - we don't care if the client sends\n\t\t\t\t// us multiple open requests, the last\n\t\t\t\t// one wins.\n\t\t\t\t//\n\t\t\t\tretval = daemon_msg_open_req(header.ver, &pars,\n\t\t\t\t    plen, source, sizeof(source));\n\t\t\t\tif (retval == -1)\n\t\t\t\t{\n\t\t\t\t\t// Fatal error; a message has\n\t\t\t\t\t// been logged, so just give up.\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tgot_source = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase RPCAP_MSG_STARTCAP_REQ:\n\t\t\t{\n\t\t\t\tif (!got_source)\n\t\t\t\t{\n\t\t\t\t\t// They never told us what device\n\t\t\t\t\t// to capture on!\n\t\t\t\t\tif (rpcap_senderror(pars.sockctrl,\n\t\t\t\t\t    header.ver,\n\t\t\t\t\t    PCAP_ERR_STARTCAPTURE,\n\t\t\t\t\t    \"No capture device was specified\",\n\t\t\t\t\t    errbuf) == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Fatal error; log an\n\t\t\t\t\t\t// error and  give up.\n\t\t\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t\tif (rpcapd_discard(pars.sockctrl, plen) == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (daemon_msg_startcap_req(header.ver, &pars,\n\t\t\t\t    plen, source, &session, &samp_param) == -1)\n\t\t\t\t{\n\t\t\t\t\t// Fatal error; a message has\n\t\t\t\t\t// been logged, so just give up.\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase RPCAP_MSG_UPDATEFILTER_REQ:\n\t\t\t{\n\t\t\t\tif (session)\n\t\t\t\t{\n\t\t\t\t\tif (daemon_msg_updatefilter_req(header.ver,\n\t\t\t\t\t    &pars, session, plen) == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Fatal error; a message has\n\t\t\t\t\t\t// been logged, so just give up.\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (rpcap_senderror(pars.sockctrl,\n\t\t\t\t\t    header.ver, PCAP_ERR_UPDATEFILTER,\n\t\t\t\t\t    \"Device not opened. Cannot update filter\",\n\t\t\t\t\t    errbuf) == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\t// That failed; log a message and give up.\n\t\t\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase RPCAP_MSG_CLOSE:\t\t// The other endpoint close the pcap session\n\t\t\t{\n\t\t\t\t//\n\t\t\t\t// Indicate to our caller that the client\n\t\t\t\t// closed the control connection.\n\t\t\t\t// This is used only in case of active mode.\n\t\t\t\t//\n\t\t\t\tclient_told_us_to_close = 1;\n\t\t\t\trpcapd_log(LOGPRIO_DEBUG, \"The other end system asked to close the connection.\");\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\tcase RPCAP_MSG_STATS_REQ:\n\t\t\t{\n\t\t\t\tif (daemon_msg_stats_req(header.ver, &pars,\n\t\t\t\t    session, plen, &stats, svrcapt) == -1)\n\t\t\t\t{\n\t\t\t\t\t// Fatal error; a message has\n\t\t\t\t\t// been logged, so just give up.\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase RPCAP_MSG_ENDCAP_REQ:\t\t// The other endpoint close the current capture session\n\t\t\t{\n\t\t\t\tif (session)\n\t\t\t\t{\n\t\t\t\t\t// Save statistics (we can need them in the future)\n\t\t\t\t\tif (pcap_stats(session->fp, &stats))\n\t\t\t\t\t{\n\t\t\t\t\t\tsvrcapt = session->TotCapt;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tstats.ps_ifdrop = 0;\n\t\t\t\t\t\tstats.ps_recv = 0;\n\t\t\t\t\t\tstats.ps_drop = 0;\n\t\t\t\t\t\tsvrcapt = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (daemon_msg_endcap_req(header.ver,\n\t\t\t\t\t    &pars, session) == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tfree(session);\n\t\t\t\t\t\tsession = NULL;\n\t\t\t\t\t\t// Fatal error; a message has\n\t\t\t\t\t\t// been logged, so just give up.\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t\tfree(session);\n\t\t\t\t\tsession = NULL;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\trpcap_senderror(pars.sockctrl,\n\t\t\t\t\t    header.ver, PCAP_ERR_ENDCAPTURE,\n\t\t\t\t\t    \"Device not opened. Cannot close the capture\",\n\t\t\t\t\t    errbuf);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase RPCAP_MSG_SETSAMPLING_REQ:\n\t\t\t{\n\t\t\t\tif (daemon_msg_setsampling_req(header.ver,\n\t\t\t\t    &pars, plen, &samp_param) == -1)\n\t\t\t\t{\n\t\t\t\t\t// Fatal error; a message has\n\t\t\t\t\t// been logged, so just give up.\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase RPCAP_MSG_AUTH_REQ:\n\t\t\t{\n\t\t\t\t//\n\t\t\t\t// We're already authenticated; you don't\n\t\t\t\t// get to reauthenticate.\n\t\t\t\t//\n\t\t\t\trpcapd_log(LOGPRIO_INFO, \"The client sent an RPCAP_MSG_AUTH_REQ message after authentication was completed\");\n\t\t\t\tif (rpcap_senderror(pars.sockctrl, header.ver,\n\t\t\t\t    PCAP_ERR_WRONGMSG,\n\t\t\t\t    \"RPCAP_MSG_AUTH_REQ request sent after authentication was completed\",\n\t\t\t\t    errbuf) == -1)\n\t\t\t\t{\n\t\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\t// Discard the rest of the message.\n\t\t\t\tif (rpcapd_discard(pars.sockctrl, plen) == -1)\n\t\t\t\t{\n\t\t\t\t\t// Fatal error.\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tgoto end;\n\n\t\t\tcase RPCAP_MSG_PACKET:\n\t\t\tcase RPCAP_MSG_FINDALLIF_REPLY:\n\t\t\tcase RPCAP_MSG_OPEN_REPLY:\n\t\t\tcase RPCAP_MSG_STARTCAP_REPLY:\n\t\t\tcase RPCAP_MSG_UPDATEFILTER_REPLY:\n\t\t\tcase RPCAP_MSG_AUTH_REPLY:\n\t\t\tcase RPCAP_MSG_STATS_REPLY:\n\t\t\tcase RPCAP_MSG_ENDCAP_REPLY:\n\t\t\tcase RPCAP_MSG_SETSAMPLING_REPLY:\n\t\t\t\t//\n\t\t\t\t// These are server-to-client messages.\n\t\t\t\t//\n\t\t\t\tmsg_type_string = rpcap_msg_type_string(header.type);\n\t\t\t\tif (msg_type_string != NULL)\n\t\t\t\t{\n\t\t\t\t\trpcapd_log(LOGPRIO_INFO, \"The client sent a %s server-to-client message\", msg_type_string);\n\t\t\t\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Server-to-client message %s received from client\", msg_type_string);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\trpcapd_log(LOGPRIO_INFO, \"The client sent a server-to-client message of type %u\", header.type);\n\t\t\t\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Server-to-client message of type %u received from client\", header.type);\n\t\t\t\t}\n\t\t\t\tif (rpcap_senderror(pars.sockctrl, header.ver,\n\t\t\t\t    PCAP_ERR_WRONGMSG, errmsgbuf, errbuf) == -1)\n\t\t\t\t{\n\t\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\t// Discard the rest of the message.\n\t\t\t\tif (rpcapd_discard(pars.sockctrl, plen) == -1)\n\t\t\t\t{\n\t\t\t\t\t// Fatal error.\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tgoto end;\n\n\t\t\tdefault:\n\t\t\t\t//\n\t\t\t\t// Unknown message type.\n\t\t\t\t//\n\t\t\t\trpcapd_log(LOGPRIO_INFO, \"The client sent a message of type %u\", header.type);\n\t\t\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Unknown message type %u\", header.type);\n\t\t\t\tif (rpcap_senderror(pars.sockctrl, header.ver,\n\t\t\t\t    PCAP_ERR_WRONGMSG, errbuf, errmsgbuf) == -1)\n\t\t\t\t{\n\t\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\t// Discard the rest of the message.\n\t\t\t\tif (rpcapd_discard(pars.sockctrl, plen) == -1)\n\t\t\t\t{\n\t\t\t\t\t// Fatal error.\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\t}\n\nend:\n\t// The service loop is finishing up.\n\t// If we have a capture session running, close it.\n\tif (session)\n\t{\n\t\tsession_close(session);\n\t\tfree(session);\n\t\tsession = NULL;\n\t}\n\n\tsock_close(sockctrl, NULL, 0);\n\n\t// Print message and return\n\trpcapd_log(LOGPRIO_DEBUG, \"I'm exiting from the child loop\");\n\n\treturn client_told_us_to_close;\n}\n\n/*\n * This handles the RPCAP_MSG_ERR message.\n */\nstatic int\ndaemon_msg_err(SOCKET sockctrl, uint32 plen)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE];\n\tchar remote_errbuf[PCAP_ERRBUF_SIZE];\n\n\tif (plen >= PCAP_ERRBUF_SIZE)\n\t{\n\t\t/*\n\t\t * Message is too long; just read as much of it as we\n\t\t * can into the buffer provided, and discard the rest.\n\t\t */\n\t\tif (sock_recv(sockctrl, remote_errbuf, PCAP_ERRBUF_SIZE - 1,\n\t\t    SOCK_RECEIVEALL_YES|SOCK_EOF_IS_ERROR, errbuf,\n\t\t    PCAP_ERRBUF_SIZE) == -1)\n\t\t{\n\t\t\t// Network error.\n\t\t\trpcapd_log(LOGPRIO_ERROR, \"Read from client failed: %s\", errbuf);\n\t\t\treturn -1;\n\t\t}\n\t\tif (rpcapd_discard(sockctrl, plen - (PCAP_ERRBUF_SIZE - 1)) == -1)\n\t\t{\n\t\t\t// Network error.\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * Null-terminate it.\n\t\t */\n\t\tremote_errbuf[PCAP_ERRBUF_SIZE - 1] = '\\0';\n\t}\n\telse if (plen == 0)\n\t{\n\t\t/* Empty error string. */\n\t\tremote_errbuf[0] = '\\0';\n\t}\n\telse\n\t{\n\t\tif (sock_recv(sockctrl, remote_errbuf, plen,\n\t\t    SOCK_RECEIVEALL_YES|SOCK_EOF_IS_ERROR, errbuf,\n\t\t    PCAP_ERRBUF_SIZE) == -1)\n\t\t{\n\t\t\t// Network error.\n\t\t\trpcapd_log(LOGPRIO_ERROR, \"Read from client failed: %s\", errbuf);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * Null-terminate it.\n\t\t */\n\t\tremote_errbuf[plen] = '\\0';\n\t}\n\t// Log the message\n\trpcapd_log(LOGPRIO_ERROR, \"Error from client: %s\", remote_errbuf);\n\treturn 0;\n}\n\n/*\n * This handles the RPCAP_MSG_AUTH_REQ message.\n * It checks if the authentication credentials supplied by the user are valid.\n *\n * This function is called if the daemon receives a RPCAP_MSG_AUTH_REQ\n * message in its authentication loop.  It reads the body of the\n * authentication message from the network and checks whether the\n * credentials are valid.\n *\n * \\param sockctrl: the socket for the control connection.\n *\n * \\param nullAuthAllowed: '1' if the NULL authentication is allowed.\n *\n * \\param errbuf: a user-allocated buffer in which the error message\n * (if one) has to be written.  It must be at least PCAP_ERRBUF_SIZE\n * bytes long.\n *\n * \\return '0' if everything is fine, '-1' if an unrecoverable error occurred,\n * or '-2' if the authentication failed.  For errors, an error message is\n * returned in the 'errbuf' variable; this gives a message for the\n * unrecoverable error or for the authentication failure.\n */\nstatic int\ndaemon_msg_auth_req(struct daemon_slpars *pars, uint32 plen)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE];\t\t// buffer for network errors\n\tchar errmsgbuf[PCAP_ERRBUF_SIZE];\t// buffer for errors to send to the client\n\tint status;\n\tstruct rpcap_auth auth;\t\t\t// RPCAP authentication header\n\tchar sendbuf[RPCAP_NETBUF_SIZE];\t// temporary buffer in which data to be sent is buffered\n\tint sendbufidx = 0;\t\t\t// index which keeps the number of bytes currently buffered\n\tstruct rpcap_authreply *authreply;\t// authentication reply message\n\n\tstatus = rpcapd_recv(pars->sockctrl, (char *) &auth, sizeof(struct rpcap_auth), &plen, errmsgbuf);\n\tif (status == -1)\n\t{\n\t\treturn -1;\n\t}\n\tif (status == -2)\n\t{\n\t\tgoto error;\n\t}\n\n\tswitch (ntohs(auth.type))\n\t{\n\t\tcase RPCAP_RMTAUTH_NULL:\n\t\t{\n\t\t\tif (!pars->nullAuthAllowed)\n\t\t\t{\n\t\t\t\t// Send the client an error reply.\n\t\t\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"Authentication failed; NULL authentication not permitted.\");\n\t\t\t\tif (rpcap_senderror(pars->sockctrl, 0,\n\t\t\t\t    PCAP_ERR_AUTH_FAILED, errmsgbuf, errbuf) == -1)\n\t\t\t\t{\n\t\t\t\t\t// That failed; log a message and give up.\n\t\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tgoto error_noreply;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase RPCAP_RMTAUTH_PWD:\n\t\t{\n\t\t\tchar *username, *passwd;\n\t\t\tuint32 usernamelen, passwdlen;\n\n\t\t\tusernamelen = ntohs(auth.slen1);\n\t\t\tusername = (char *) malloc (usernamelen + 1);\n\t\t\tif (username == NULL)\n\t\t\t{\n\t\t\t\tpcap_fmt_errmsg_for_errno(errmsgbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno, \"malloc() failed\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tstatus = rpcapd_recv(pars->sockctrl, username, usernamelen, &plen, errmsgbuf);\n\t\t\tif (status == -1)\n\t\t\t{\n\t\t\t\tfree(username);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (status == -2)\n\t\t\t{\n\t\t\t\tfree(username);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tusername[usernamelen] = '\\0';\n\n\t\t\tpasswdlen = ntohs(auth.slen2);\n\t\t\tpasswd = (char *) malloc (passwdlen + 1);\n\t\t\tif (passwd == NULL)\n\t\t\t{\n\t\t\t\tpcap_fmt_errmsg_for_errno(errmsgbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno, \"malloc() failed\");\n\t\t\t\tfree(username);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tstatus = rpcapd_recv(pars->sockctrl, passwd, passwdlen, &plen, errmsgbuf);\n\t\t\tif (status == -1)\n\t\t\t{\n\t\t\t\tfree(username);\n\t\t\t\tfree(passwd);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (status == -2)\n\t\t\t{\n\t\t\t\tfree(username);\n\t\t\t\tfree(passwd);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tpasswd[passwdlen] = '\\0';\n\n\t\t\tif (daemon_AuthUserPwd(username, passwd, errmsgbuf))\n\t\t\t{\n\t\t\t\t//\n\t\t\t\t// Authentication failed.  Let the client\n\t\t\t\t// know.\n\t\t\t\t//\n\t\t\t\tfree(username);\n\t\t\t\tfree(passwd);\n\t\t\t\tif (rpcap_senderror(pars->sockctrl, 0,\n\t\t\t\t    PCAP_ERR_AUTH_FAILED, errmsgbuf, errbuf) == -1)\n\t\t\t\t{\n\t\t\t\t\t// That failed; log a message and give up.\n\t\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\t//\n\t\t\t\t// Suspend for 1 second, so that they can't\n\t\t\t\t// hammer us with repeated tries with an\n\t\t\t\t// attack such as a dictionary attack.\n\t\t\t\t//\n\t\t\t\t// WARNING: this delay is inserted only\n\t\t\t\t// at this point; if the client closes the\n\t\t\t\t// connection and reconnects, the suspension\n\t\t\t\t// time does not have any effect.\n\t\t\t\t//\n\t\t\t\tsleep_secs(RPCAP_SUSPEND_WRONGAUTH);\n\t\t\t\tgoto error_noreply;\n\t\t\t}\n\n\t\t\tfree(username);\n\t\t\tfree(passwd);\n\t\t\tbreak;\n\t\t\t}\n\n\t\tdefault:\n\t\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"Authentication type not recognized.\");\n\t\t\tif (rpcap_senderror(pars->sockctrl, 0,\n\t\t\t    PCAP_ERR_AUTH_TYPE_NOTSUP, errmsgbuf, errbuf) == -1)\n\t\t\t{\n\t\t\t\t// That failed; log a message and give up.\n\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tgoto error_noreply;\n\t}\n\n\t// The authentication succeeded; let the client know.\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL, &sendbufidx,\n\t    RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\trpcap_createhdr((struct rpcap_header *) sendbuf, 0,\n\t    RPCAP_MSG_AUTH_REPLY, 0, sizeof(struct rpcap_authreply));\n\n\tauthreply = (struct rpcap_authreply *) &sendbuf[sendbufidx];\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_authreply), NULL, &sendbufidx,\n\t    RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\t//\n\t// Indicate to our peer what versions we support.\n\t//\n\tmemset(authreply, 0, sizeof(struct rpcap_authreply));\n\tauthreply->minvers = RPCAP_MIN_VERSION;\n\tauthreply->maxvers = RPCAP_MAX_VERSION;\n\n\t// Send the reply.\n\tif (sock_send(pars->sockctrl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t{\n\t\t// That failed; log a messsage and give up.\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\n\t// Check if all the data has been read; if not, discard the data in excess\n\tif (rpcapd_discard(pars->sockctrl, plen) == -1)\n\t{\n\t\treturn -1;\n\t}\n\n\treturn 0;\n\nerror:\n\tif (rpcap_senderror(pars->sockctrl, 0, PCAP_ERR_AUTH, errmsgbuf,\n\t    errbuf) == -1)\n\t{\n\t\t// That failed; log a message and give up.\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\nerror_noreply:\n\t// Check if all the data has been read; if not, discard the data in excess\n\tif (rpcapd_discard(pars->sockctrl, plen) == -1)\n\t{\n\t\treturn -1;\n\t}\n\n\treturn -2;\n}\n\nstatic int\ndaemon_AuthUserPwd(char *username, char *password, char *errbuf)\n{\n#ifdef _WIN32\n\t/*\n\t * Warning: the user which launches the process must have the\n\t * SE_TCB_NAME right.\n\t * This corresponds to have the \"Act as part of the Operating System\"\n\t * turned on (administrative tools, local security settings, local\n\t * policies, user right assignment)\n\t * However, it seems to me that if you run it as a service, this\n\t * right should be provided by default.\n\t *\n\t * XXX - hopefully, this returns errors such as ERROR_LOGON_FAILURE,\n\t * which merely indicates that the user name or password is\n\t * incorrect, not whether it's the user name or the password\n\t * that's incorrect, so a client that's trying to brute-force\n\t * accounts doesn't know whether it's the user name or the\n\t * password that's incorrect, so it doesn't know whether to\n\t * stop trying to log in with a given user name and move on\n\t * to another user name.\n\t */\n\tDWORD error;\n\tHANDLE Token;\n\tchar errmsgbuf[PCAP_ERRBUF_SIZE];\t// buffer for errors to log\n\n\tif (LogonUser(username, \".\", password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &Token) == 0)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed\");\n\t\terror = GetLastError();\n\t\tif (error != ERROR_LOGON_FAILURE)\n\t\t{\n\t\t\t// Some error other than an authentication error;\n\t\t\t// log it.\n\t\t\tpcap_fmt_errmsg_for_win32_err(errmsgbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, error, \"LogonUser() failed\");\n\t\t\trpcapd_log(LOGPRIO_ERROR, \"%s\", errmsgbuf);\n\t\t}\t\t\t    \n\t\treturn -1;\n\t}\n\n\t// This call should change the current thread to the selected user.\n\t// I didn't test it.\n\tif (ImpersonateLoggedOnUser(Token) == 0)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed\");\n\t\tpcap_fmt_errmsg_for_win32_err(errmsgbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"ImpersonateLoggedOnUser() failed\");\n\t\trpcapd_log(LOGPRIO_ERROR, \"%s\", errmsgbuf);\n\t\tCloseHandle(Token);\n\t\treturn -1;\n\t}\n\n\tCloseHandle(Token);\n\treturn 0;\n\n#else\n\t/*\n\t * See\n\t *\n\t *\thttp://www.unixpapa.com/incnote/passwd.html\n\t *\n\t * We use the Solaris/Linux shadow password authentication if\n\t * we have getspnam(), otherwise we just do traditional\n\t * authentication, which, on some platforms, might work, even\n\t * with shadow passwords, if we're running as root.  Traditional\n\t * authenticaion won't work if we're not running as root, as\n\t * I think these days all UN*Xes either won't return the password\n\t * at all with getpwnam() or will only do so if you're root.\n\t *\n\t * XXX - perhaps what we *should* be using is PAM, if we have\n\t * it.  That might hide all the details of username/password\n\t * authentication, whether it's done with a visible-to-root-\n\t * only password database or some other authentication mechanism,\n\t * behind its API.\n\t */\n\tint error;\n\tstruct passwd *user;\n\tchar *user_password;\n#ifdef HAVE_GETSPNAM\n\tstruct spwd *usersp;\n#endif\n\tchar *crypt_password;\n\n\t// This call is needed to get the uid\n\tif ((user = getpwnam(username)) == NULL)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed\");\n\t\treturn -1;\n\t}\n\n#ifdef HAVE_GETSPNAM\n\t// This call is needed to get the password; otherwise 'x' is returned\n\tif ((usersp = getspnam(username)) == NULL)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed\");\n\t\treturn -1;\n\t}\n\tuser_password = usersp->sp_pwdp;\n#else\n\t/*\n\t * XXX - what about other platforms?\n\t * The unixpapa.com page claims this Just Works on *BSD if you're\n\t * running as root - it's from 2000, so it doesn't indicate whether\n\t * macOS (which didn't come out until 2001, under the name Mac OS\n\t * X) behaves like the *BSDs or not, and might also work on AIX.\n\t * HP-UX does something else.\n\t *\n\t * Again, hopefully PAM hides all that.\n\t */\n\tuser_password = user->pw_passwd;\n#endif\n\n\t//\n\t// The Single UNIX Specification says that if crypt() fails it\n\t// sets errno, but some implementatons that haven't been run\n\t// through the SUS test suite might not do so.\n\t//\n\terrno = 0;\n\tcrypt_password = crypt(password, user_password);\n\tif (crypt_password == NULL)\n\t{\n\t\terror = errno;\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed\");\n\t\tif (error == 0)\n\t\t{\n\t\t\t// It didn't set errno.\n\t\t\trpcapd_log(LOGPRIO_ERROR, \"crypt() failed\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\trpcapd_log(LOGPRIO_ERROR, \"crypt() failed: %s\",\n\t\t\t    strerror(error));\n\t\t}\n\t\treturn -1;\n\t}\n\tif (strcmp(user_password, crypt_password) != 0)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed\");\n\t\treturn -1;\n\t}\n\n\tif (setuid(user->pw_uid))\n\t{\n\t\terror = errno;\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    error, \"setuid\");\n\t\trpcapd_log(LOGPRIO_ERROR, \"setuid() failed: %s\",\n\t\t    strerror(error));\n\t\treturn -1;\n\t}\n\n/*\tif (setgid(user->pw_gid))\n\t{\n\t\terror = errno;\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"setgid\");\n\t\trpcapd_log(LOGPRIO_ERROR, \"setgid() failed: %s\",\n\t\t    strerror(error));\n\t\treturn -1;\n\t}\n*/\n\treturn 0;\n\n#endif\n\n}\n\nstatic int\ndaemon_msg_findallif_req(uint8 ver, struct daemon_slpars *pars, uint32 plen)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE];\t\t// buffer for network errors\n\tchar errmsgbuf[PCAP_ERRBUF_SIZE];\t// buffer for errors to send to the client\n\tchar sendbuf[RPCAP_NETBUF_SIZE];\t// temporary buffer in which data to be sent is buffered\n\tint sendbufidx = 0;\t\t\t// index which keeps the number of bytes currently buffered\n\tpcap_if_t *alldevs = NULL;\t\t// pointer to the header of the interface chain\n\tpcap_if_t *d;\t\t\t\t// temp pointer needed to scan the interface chain\n\tstruct pcap_addr *address;\t\t// pcap structure that keeps a network address of an interface\n\tstruct rpcap_findalldevs_if *findalldevs_if;// rpcap structure that packet all the data of an interface together\n\tuint16 nif = 0;\t\t\t\t// counts the number of interface listed\n\n\t// Discard the rest of the message; there shouldn't be any payload.\n\tif (rpcapd_discard(pars->sockctrl, plen) == -1)\n\t{\n\t\t// Network error.\n\t\treturn -1;\n\t}\n\n\t// Retrieve the device list\n\tif (pcap_findalldevs(&alldevs, errmsgbuf) == -1)\n\t\tgoto error;\n\n\tif (alldevs == NULL)\n\t{\n\t\tif (rpcap_senderror(pars->sockctrl, ver, PCAP_ERR_NOREMOTEIF,\n\t\t\t\"No interfaces found! Make sure libpcap/WinPcap is properly installed\"\n\t\t\t\" and you have the right to access to the remote device.\",\n\t\t\terrbuf) == -1)\n\t\t{\n\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t// checks the number of interfaces and it computes the total length of the payload\n\tfor (d = alldevs; d != NULL; d = d->next)\n\t{\n\t\tnif++;\n\n\t\tif (d->description)\n\t\t\tplen+= strlen(d->description);\n\t\tif (d->name)\n\t\t\tplen+= strlen(d->name);\n\n\t\tplen+= sizeof(struct rpcap_findalldevs_if);\n\n\t\tfor (address = d->addresses; address != NULL; address = address->next)\n\t\t{\n\t\t\t/*\n\t\t\t * Send only IPv4 and IPv6 addresses over the wire.\n\t\t\t */\n\t\t\tswitch (address->addr->sa_family)\n\t\t\t{\n\t\t\tcase AF_INET:\n#ifdef AF_INET6\n\t\t\tcase AF_INET6:\n#endif\n\t\t\t\tplen+= (sizeof(struct rpcap_sockaddr) * 4);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// RPCAP findalldevs command\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL,\n\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf,\n\t    PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\trpcap_createhdr((struct rpcap_header *) sendbuf, ver,\n\t    RPCAP_MSG_FINDALLIF_REPLY, nif, plen);\n\n\t// send the interface list\n\tfor (d = alldevs; d != NULL; d = d->next)\n\t{\n\t\tuint16 lname, ldescr;\n\n\t\tfindalldevs_if = (struct rpcap_findalldevs_if *) &sendbuf[sendbufidx];\n\n\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_findalldevs_if), NULL,\n\t\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\tgoto error;\n\n\t\tmemset(findalldevs_if, 0, sizeof(struct rpcap_findalldevs_if));\n\n\t\tif (d->description) ldescr = (short) strlen(d->description);\n\t\telse ldescr = 0;\n\t\tif (d->name) lname = (short) strlen(d->name);\n\t\telse lname = 0;\n\n\t\tfindalldevs_if->desclen = htons(ldescr);\n\t\tfindalldevs_if->namelen = htons(lname);\n\t\tfindalldevs_if->flags = htonl(d->flags);\n\n\t\tfor (address = d->addresses; address != NULL; address = address->next)\n\t\t{\n\t\t\t/*\n\t\t\t * Send only IPv4 and IPv6 addresses over the wire.\n\t\t\t */\n\t\t\tswitch (address->addr->sa_family)\n\t\t\t{\n\t\t\tcase AF_INET:\n#ifdef AF_INET6\n\t\t\tcase AF_INET6:\n#endif\n\t\t\t\tfindalldevs_if->naddr++;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfindalldevs_if->naddr = htons(findalldevs_if->naddr);\n\n\t\tif (sock_bufferize(d->name, lname, sendbuf, &sendbufidx,\n\t\t    RPCAP_NETBUF_SIZE, SOCKBUF_BUFFERIZE, errmsgbuf,\n\t\t    PCAP_ERRBUF_SIZE) == -1)\n\t\t\tgoto error;\n\n\t\tif (sock_bufferize(d->description, ldescr, sendbuf, &sendbufidx,\n\t\t    RPCAP_NETBUF_SIZE, SOCKBUF_BUFFERIZE, errmsgbuf,\n\t\t    PCAP_ERRBUF_SIZE) == -1)\n\t\t\tgoto error;\n\n\t\t// send all addresses\n\t\tfor (address = d->addresses; address != NULL; address = address->next)\n\t\t{\n\t\t\tstruct rpcap_sockaddr *sockaddr;\n\n\t\t\t/*\n\t\t\t * Send only IPv4 and IPv6 addresses over the wire.\n\t\t\t */\n\t\t\tswitch (address->addr->sa_family)\n\t\t\t{\n\t\t\tcase AF_INET:\n#ifdef AF_INET6\n\t\t\tcase AF_INET6:\n#endif\n\t\t\t\tsockaddr = (struct rpcap_sockaddr *) &sendbuf[sendbufidx];\n\t\t\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_sockaddr), NULL,\n\t\t\t\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\t\t\tgoto error;\n\t\t\t\tdaemon_seraddr((struct sockaddr_storage *) address->addr, sockaddr);\n\n\t\t\t\tsockaddr = (struct rpcap_sockaddr *) &sendbuf[sendbufidx];\n\t\t\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_sockaddr), NULL,\n\t\t\t\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\t\t\tgoto error;\n\t\t\t\tdaemon_seraddr((struct sockaddr_storage *) address->netmask, sockaddr);\n\n\t\t\t\tsockaddr = (struct rpcap_sockaddr *) &sendbuf[sendbufidx];\n\t\t\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_sockaddr), NULL,\n\t\t\t\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\t\t\tgoto error;\n\t\t\t\tdaemon_seraddr((struct sockaddr_storage *) address->broadaddr, sockaddr);\n\n\t\t\t\tsockaddr = (struct rpcap_sockaddr *) &sendbuf[sendbufidx];\n\t\t\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_sockaddr), NULL,\n\t\t\t\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\t\t\tgoto error;\n\t\t\t\tdaemon_seraddr((struct sockaddr_storage *) address->dstaddr, sockaddr);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// We no longer need the device list. Free it.\n\tpcap_freealldevs(alldevs);\n\n\t// Send a final command that says \"now send it!\"\n\tif (sock_send(pars->sockctrl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n\nerror:\n\tif (alldevs)\n\t\tpcap_freealldevs(alldevs);\n\n\tif (rpcap_senderror(pars->sockctrl, ver, PCAP_ERR_FINDALLIF,\n\t    errmsgbuf, errbuf) == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/*\n\t\\param plen: the length of the current message (needed in order to be able\n\tto discard excess data in the message, if present)\n*/\nstatic int\ndaemon_msg_open_req(uint8 ver, struct daemon_slpars *pars, uint32 plen,\n    char *source, size_t sourcelen)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE];\t\t// buffer for network errors\n\tchar errmsgbuf[PCAP_ERRBUF_SIZE];\t// buffer for errors to send to the client\n\tpcap_t *fp;\t\t\t\t// pcap_t main variable\n\tint nread;\n\tchar sendbuf[RPCAP_NETBUF_SIZE];\t// temporary buffer in which data to be sent is buffered\n\tint sendbufidx = 0;\t\t\t// index which keeps the number of bytes currently buffered\n\tstruct rpcap_openreply *openreply;\t// open reply message\n\n\tif (plen > sourcelen - 1)\n\t{\n\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Source string too long\");\n\t\tgoto error;\n\t}\n\n\tnread = sock_recv(pars->sockctrl, source, plen,\n\t    SOCK_RECEIVEALL_YES|SOCK_EOF_IS_ERROR, errbuf, PCAP_ERRBUF_SIZE);\n\tif (nread == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Read from client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\tsource[nread] = '\\0';\n\tplen -= nread;\n\n\t// XXX - make sure it's *not* a URL; we don't support opening\n\t// remote devices here.\n\n\t// Open the selected device\n\t// This is a fake open, since we do that only to get the needed parameters, then we close the device again\n\tif ((fp = pcap_open_live(source,\n\t\t\t1500 /* fake snaplen */,\n\t\t\t0 /* no promis */,\n\t\t\t1000 /* fake timeout */,\n\t\t\terrmsgbuf)) == NULL)\n\t\tgoto error;\n\n\t// Now, I can send a RPCAP open reply message\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL, &sendbufidx,\n\t    RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\trpcap_createhdr((struct rpcap_header *) sendbuf, ver,\n\t    RPCAP_MSG_OPEN_REPLY, 0, sizeof(struct rpcap_openreply));\n\n\topenreply = (struct rpcap_openreply *) &sendbuf[sendbufidx];\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_openreply), NULL, &sendbufidx,\n\t    RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\tmemset(openreply, 0, sizeof(struct rpcap_openreply));\n\topenreply->linktype = htonl(pcap_datalink(fp));\n\topenreply->tzoff = 0; /* This is always 0 for live captures */\n\n\t// We're done with the pcap_t.\n\tpcap_close(fp);\n\n\t// Send the reply.\n\tif (sock_send(pars->sockctrl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\treturn 0;\n\nerror:\n\tif (rpcap_senderror(pars->sockctrl, ver, PCAP_ERR_OPEN,\n\t    errmsgbuf, errbuf) == -1)\n\t{\n\t\t// That failed; log a message and give up.\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\n\t// Check if all the data has been read; if not, discard the data in excess\n\tif (rpcapd_discard(pars->sockctrl, plen) == -1)\n\t{\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/*\n\t\\param plen: the length of the current message (needed in order to be able\n\tto discard excess data in the message, if present)\n*/\nstatic int\ndaemon_msg_startcap_req(uint8 ver, struct daemon_slpars *pars, uint32 plen,\n    char *source, struct session **sessionp,\n    struct rpcap_sampling *samp_param _U_)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE];\t\t// buffer for network errors\n\tchar errmsgbuf[PCAP_ERRBUF_SIZE];\t// buffer for errors to send to the client\n\tchar portdata[PCAP_BUF_SIZE];\t\t// temp variable needed to derive the data port\n\tchar peerhost[PCAP_BUF_SIZE];\t\t// temp variable needed to derive the host name of our peer\n\tstruct session *session = NULL;\t\t// saves state of session\n\tint status;\n\tchar sendbuf[RPCAP_NETBUF_SIZE];\t// temporary buffer in which data to be sent is buffered\n\tint sendbufidx = 0;\t\t\t// index which keeps the number of bytes currently buffered\n\n\t// socket-related variables\n\tstruct addrinfo hints;\t\t\t// temp, needed to open a socket connection\n\tstruct addrinfo *addrinfo;\t\t// temp, needed to open a socket connection\n\tstruct sockaddr_storage saddr;\t\t// temp, needed to retrieve the network data port chosen on the local machine\n\tsocklen_t saddrlen;\t\t\t// temp, needed to retrieve the network data port chosen on the local machine\n\tint ret;\t\t\t\t// return value from functions\n\n\t// RPCAP-related variables\n\tstruct rpcap_startcapreq startcapreq;\t\t// start capture request message\n\tstruct rpcap_startcapreply *startcapreply;\t// start capture reply message\n\tint serveropen_dp;\t\t\t\t\t\t\t// keeps who is going to open the data connection\n\n\taddrinfo = NULL;\n\n\tstatus = rpcapd_recv(pars->sockctrl, (char *) &startcapreq,\n\t    sizeof(struct rpcap_startcapreq), &plen, errmsgbuf);\n\tif (status == -1)\n\t{\n\t\tgoto fatal_error;\n\t}\n\tif (status == -2)\n\t{\n\t\tgoto error;\n\t}\n\n\tstartcapreq.flags = ntohs(startcapreq.flags);\n\n\t// Create a session structure\n\tsession = malloc(sizeof(struct session));\n\tif (session == NULL)\n\t{\n\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Can't allocate session structure\");\n\t\tgoto error;\n\t}\n\n\tsession->sockdata = INVALID_SOCKET;\n\t// We don't have a thread yet.\n\tsession->have_thread = 0;\n\t//\n\t// We *shouldn't* have to initialize the thread indicator\n\t// itself, because the compiler *should* realize that we\n\t// only use this if have_thread isn't 0, but we *do* have\n\t// to do it, because not all compilers *do* realize that.\n\t//\n\t// There is no \"invalid thread handle\" value for a UN*X\n\t// pthread_t, so we just zero it out.\n\t//\n#ifdef _WIN32\n\tsession->thread = INVALID_HANDLE_VALUE;\n#else\n\tmemset(&session->thread, 0, sizeof(session->thread));\n#endif\n\n\t// Open the selected device\n\tif ((session->fp = pcap_open_live(source,\n\t\t\tntohl(startcapreq.snaplen),\n\t\t\t(startcapreq.flags & RPCAP_STARTCAPREQ_FLAG_PROMISC) ? 1 : 0 /* local device, other flags not needed */,\n\t\t\tntohl(startcapreq.read_timeout),\n\t\t\terrmsgbuf)) == NULL)\n\t\tgoto error;\n\n#if 0\n\t// Apply sampling parameters\n\tfp->rmt_samp.method = samp_param->method;\n\tfp->rmt_samp.value = samp_param->value;\n#endif\n\n\t/*\n\tWe're in active mode if:\n\t- we're using TCP, and the user wants us to be in active mode\n\t- we're using UDP\n\t*/\n\tserveropen_dp = (startcapreq.flags & RPCAP_STARTCAPREQ_FLAG_SERVEROPEN) || (startcapreq.flags & RPCAP_STARTCAPREQ_FLAG_DGRAM) || pars->isactive;\n\n\t/*\n\tGets the sockaddr structure referred to the other peer in the ctrl connection\n\n\tWe need that because:\n\t- if we're in passive mode, we need to know the address family we want to use\n\t(the same used for the ctrl socket)\n\t- if we're in active mode, we need to know the network address of the other host\n\twe want to connect to\n\t*/\n\tsaddrlen = sizeof(struct sockaddr_storage);\n\tif (getpeername(pars->sockctrl, (struct sockaddr *) &saddr, &saddrlen) == -1)\n\t{\n\t\tsock_geterror(\"getpeername()\", errmsgbuf, PCAP_ERRBUF_SIZE);\n\t\tgoto error;\n\t}\n\n\tmemset(&hints, 0, sizeof(struct addrinfo));\n\thints.ai_socktype = (startcapreq.flags & RPCAP_STARTCAPREQ_FLAG_DGRAM) ? SOCK_DGRAM : SOCK_STREAM;\n\thints.ai_family = saddr.ss_family;\n\n\t// Now we have to create a new socket to send packets\n\tif (serveropen_dp)\t\t// Data connection is opened by the server toward the client\n\t{\n\t\tpcap_snprintf(portdata, sizeof portdata, \"%d\", ntohs(startcapreq.portdata));\n\n\t\t// Get the name of the other peer (needed to connect to that specific network address)\n\t\tif (getnameinfo((struct sockaddr *) &saddr, saddrlen, peerhost,\n\t\t\t\tsizeof(peerhost), NULL, 0, NI_NUMERICHOST))\n\t\t{\n\t\t\tsock_geterror(\"getnameinfo()\", errmsgbuf, PCAP_ERRBUF_SIZE);\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (sock_initaddress(peerhost, portdata, &hints, &addrinfo, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\tgoto error;\n\n\t\tif ((session->sockdata = sock_open(addrinfo, SOCKOPEN_CLIENT, 0, errmsgbuf, PCAP_ERRBUF_SIZE)) == INVALID_SOCKET)\n\t\t\tgoto error;\n\t}\n\telse\t\t// Data connection is opened by the client toward the server\n\t{\n\t\thints.ai_flags = AI_PASSIVE;\n\n\t\t// Let's the server socket pick up a free network port for us\n\t\tif (sock_initaddress(NULL, \"0\", &hints, &addrinfo, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\tgoto error;\n\n\t\tif ((session->sockdata = sock_open(addrinfo, SOCKOPEN_SERVER, 1 /* max 1 connection in queue */, errmsgbuf, PCAP_ERRBUF_SIZE)) == INVALID_SOCKET)\n\t\t\tgoto error;\n\n\t\t// get the complete sockaddr structure used in the data connection\n\t\tsaddrlen = sizeof(struct sockaddr_storage);\n\t\tif (getsockname(session->sockdata, (struct sockaddr *) &saddr, &saddrlen) == -1)\n\t\t{\n\t\t\tsock_geterror(\"getsockname()\", errmsgbuf, PCAP_ERRBUF_SIZE);\n\t\t\tgoto error;\n\t\t}\n\n\t\t// Get the local port the system picked up\n\t\tif (getnameinfo((struct sockaddr *) &saddr, saddrlen, NULL,\n\t\t\t\t0, portdata, sizeof(portdata), NI_NUMERICSERV))\n\t\t{\n\t\t\tsock_geterror(\"getnameinfo()\", errmsgbuf, PCAP_ERRBUF_SIZE);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t// addrinfo is no longer used\n\tfreeaddrinfo(addrinfo);\n\taddrinfo = NULL;\n\n\t// Needed to send an error on the ctrl connection\n\tsession->sockctrl = pars->sockctrl;\n\tsession->protocol_version = ver;\n\n\t// Now I can set the filter\n\tret = daemon_unpackapplyfilter(pars->sockctrl, session, &plen, errmsgbuf);\n\tif (ret == -1)\n\t{\n\t\t// Fatal error.  A message has been logged; just give up.\n\t\tgoto fatal_error;\n\t}\n\tif (ret == -2)\n\t{\n\t\t// Non-fatal error.  Send an error message to the client.\n\t\tgoto error;\n\t}\n\n\t// Now, I can send a RPCAP start capture reply message\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL, &sendbufidx,\n\t    RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\trpcap_createhdr((struct rpcap_header *) sendbuf, ver,\n\t    RPCAP_MSG_STARTCAP_REPLY, 0, sizeof(struct rpcap_startcapreply));\n\n\tstartcapreply = (struct rpcap_startcapreply *) &sendbuf[sendbufidx];\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_startcapreply), NULL,\n\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\tmemset(startcapreply, 0, sizeof(struct rpcap_startcapreply));\n\tstartcapreply->bufsize = htonl(pcap_bufsize(session->fp));\n\n\tif (!serveropen_dp)\n\t{\n\t\tunsigned short port = (unsigned short)strtoul(portdata,NULL,10);\n\t\tstartcapreply->portdata = htons(port);\n\t}\n\n\tif (sock_send(pars->sockctrl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t{\n\t\t// That failed; log a message and give up.\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\tgoto fatal_error;\n\t}\n\n\tif (!serveropen_dp)\n\t{\n\t\tSOCKET socktemp;\t// We need another socket, since we're going to accept() a connection\n\n\t\t// Connection creation\n\t\tsaddrlen = sizeof(struct sockaddr_storage);\n\n\t\tsocktemp = accept(session->sockdata, (struct sockaddr *) &saddr, &saddrlen);\n\n\t\tif (socktemp == INVALID_SOCKET)\n\t\t{\n\t\t\tsock_geterror(\"accept()\", errbuf, PCAP_ERRBUF_SIZE);\n\t\t\trpcapd_log(LOGPRIO_ERROR, \"Accept of data connection failed: %s\",\n\t\t\t    errbuf);\n\t\t\tgoto error;\n\t\t}\n\n\t\t// Now that I accepted the connection, the server socket is no longer needed\n\t\tsock_close(session->sockdata, NULL, 0);\n\t\tsession->sockdata = socktemp;\n\t}\n\n\t// Now we have to create a new thread to receive packets\n#ifdef _WIN32\n\tsession->thread = (HANDLE)_beginthreadex(NULL, 0, daemon_thrdatamain,\n\t    (void *) session, 0, NULL);\n\tif (session->thread == 0)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Error creating the data thread\");\n\t\tgoto error;\n\t}\n#else\n\tret = pthread_create(&session->thread, NULL, daemon_thrdatamain,\n\t    (void *) session);\n\tif (ret != 0)\n\t{\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    ret, \"Error creating the data thread\");\n\t\tgoto error;\n\t}\n#endif\n\tsession->have_thread = 1;\n\n\t// Check if all the data has been read; if not, discard the data in excess\n\tif (rpcapd_discard(pars->sockctrl, plen) == -1)\n\t\tgoto fatal_error;\n\n\t*sessionp = session;\n\treturn 0;\n\nerror:\n\t//\n\t// Not a fatal error, so send the client an error message and\n\t// keep serving client requests.\n\t//\n\t*sessionp = NULL;\n\n\tif (addrinfo)\n\t\tfreeaddrinfo(addrinfo);\n\n\tif (session)\n\t{\n\t\tsession_close(session);\n\t\tfree(session);\n\t}\n\n\tif (rpcap_senderror(pars->sockctrl, ver, PCAP_ERR_STARTCAPTURE,\n\t    errmsgbuf, errbuf) == -1)\n\t{\n\t\t// That failed; log a message and give up.\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\n\t// Check if all the data has been read; if not, discard the data in excess\n\tif (rpcapd_discard(pars->sockctrl, plen) == -1)\n\t{\n\t\t// Network error.\n\t\treturn -1;\n\t}\n\n\treturn 0;\n\nfatal_error:\n\t//\n\t// Fatal network error, so don't try to communicate with\n\t// the client, just give up.\n\t//\n\t*sessionp = NULL;\n\n\tif (session)\n\t{\n\t\tsession_close(session);\n\t\tfree(session);\n\t}\n\n\treturn -1;\n}\n\nstatic int\ndaemon_msg_endcap_req(uint8 ver, struct daemon_slpars *pars,\n    struct session *session)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE];\t\t// buffer for network errors\n\tstruct rpcap_header header;\n\n\tsession_close(session);\n\n\trpcap_createhdr(&header, ver, RPCAP_MSG_ENDCAP_REPLY, 0, 0);\n\n\tif (sock_send(pars->sockctrl, (char *) &header, sizeof(struct rpcap_header), errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t{\n\t\t// That failed; log a message and give up.\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int\ndaemon_unpackapplyfilter(SOCKET sockctrl, struct session *session, uint32 *plenp, char *errmsgbuf)\n{\n\tint status;\n\tstruct rpcap_filter filter;\n\tstruct rpcap_filterbpf_insn insn;\n\tstruct bpf_insn *bf_insn;\n\tstruct bpf_program bf_prog;\n\tunsigned int i;\n\n\tstatus = rpcapd_recv(sockctrl, (char *) &filter,\n\t    sizeof(struct rpcap_filter), plenp, errmsgbuf);\n\tif (status == -1)\n\t{\n\t\treturn -1;\n\t}\n\tif (status == -2)\n\t{\n\t\treturn -2;\n\t}\n\n\tbf_prog.bf_len = ntohl(filter.nitems);\n\n\tif (ntohs(filter.filtertype) != RPCAP_UPDATEFILTER_BPF)\n\t{\n\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Only BPF/NPF filters are currently supported\");\n\t\treturn -2;\n\t}\n\n\tbf_insn = (struct bpf_insn *) malloc (sizeof(struct bpf_insn) * bf_prog.bf_len);\n\tif (bf_insn == NULL)\n\t{\n\t\tpcap_fmt_errmsg_for_errno(errmsgbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc() failed\");\n\t\treturn -2;\n\t}\n\n\tbf_prog.bf_insns = bf_insn;\n\n\tfor (i = 0; i < bf_prog.bf_len; i++)\n\t{\n\t\tstatus = rpcapd_recv(sockctrl, (char *) &insn,\n\t\t    sizeof(struct rpcap_filterbpf_insn), plenp, errmsgbuf);\n\t\tif (status == -1)\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\t\tif (status == -2)\n\t\t{\n\t\t\treturn -2;\n\t\t}\n\n\t\tbf_insn->code = ntohs(insn.code);\n\t\tbf_insn->jf = insn.jf;\n\t\tbf_insn->jt = insn.jt;\n\t\tbf_insn->k = ntohl(insn.k);\n\n\t\tbf_insn++;\n\t}\n\n\tif (bpf_validate(bf_prog.bf_insns, bf_prog.bf_len) == 0)\n\t{\n\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"The filter contains bogus instructions\");\n\t\treturn -2;\n\t}\n\n\tif (pcap_setfilter(session->fp, &bf_prog))\n\t{\n\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"RPCAP error: %s\", pcap_geterr(session->fp));\n\t\treturn -2;\n\t}\n\n\treturn 0;\n}\n\nstatic int\ndaemon_msg_updatefilter_req(uint8 ver, struct daemon_slpars *pars,\n    struct session *session, uint32 plen)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE];\n\tchar errmsgbuf[PCAP_ERRBUF_SIZE];\t// buffer for errors to send to the client\n\tint ret;\t\t\t\t// status of daemon_unpackapplyfilter()\n\tstruct rpcap_header header;\t\t// keeps the answer to the updatefilter command\n\n\tret = daemon_unpackapplyfilter(pars->sockctrl, session, &plen, errmsgbuf);\n\tif (ret == -1)\n\t{\n\t\t// Fatal error.  A message has been logged; just give up.\n\t\treturn -1;\n\t}\n\tif (ret == -2)\n\t{\n\t\t// Non-fatal error.  Send an error reply to the client.\n\t\tgoto error;\n\t}\n\n\t// Check if all the data has been read; if not, discard the data in excess\n\tif (rpcapd_discard(pars->sockctrl, plen) == -1)\n\t{\n\t\t// Network error.\n\t\treturn -1;\n\t}\n\n\t// A response is needed, otherwise the other host does not know that everything went well\n\trpcap_createhdr(&header, ver, RPCAP_MSG_UPDATEFILTER_REPLY, 0, 0);\n\n\tif (sock_send(pars->sockctrl, (char *) &header, sizeof (struct rpcap_header), pcap_geterr(session->fp), PCAP_ERRBUF_SIZE))\n\t{\n\t\t// That failed; log a messsage and give up.\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n\nerror:\n\tif (rpcapd_discard(pars->sockctrl, plen) == -1)\n\t{\n\t\treturn -1;\n\t}\n\trpcap_senderror(pars->sockctrl, ver, PCAP_ERR_UPDATEFILTER,\n\t    errmsgbuf, NULL);\n\n\treturn 0;\n}\n\n/*!\n\t\\brief Received the sampling parameters from remote host and it stores in the pcap_t structure.\n*/\nstatic int\ndaemon_msg_setsampling_req(uint8 ver, struct daemon_slpars *pars, uint32 plen,\n    struct rpcap_sampling *samp_param)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE];\t\t// buffer for network errors\n\tchar errmsgbuf[PCAP_ERRBUF_SIZE];\n\tstruct rpcap_header header;\n\tstruct rpcap_sampling rpcap_samp;\n\tint status;\n\n\tstatus = rpcapd_recv(pars->sockctrl, (char *) &rpcap_samp, sizeof(struct rpcap_sampling), &plen, errmsgbuf);\n\tif (status == -1)\n\t{\n\t\treturn -1;\n\t}\n\tif (status == -2)\n\t{\n\t\tgoto error;\n\t}\n\n\t// Save these settings in the pcap_t\n\tsamp_param->method = rpcap_samp.method;\n\tsamp_param->value = ntohl(rpcap_samp.value);\n\n\t// A response is needed, otherwise the other host does not know that everything went well\n\trpcap_createhdr(&header, ver, RPCAP_MSG_SETSAMPLING_REPLY, 0, 0);\n\n\tif (sock_send(pars->sockctrl, (char *) &header, sizeof (struct rpcap_header), errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t{\n\t\t// That failed; log a messsage and give up.\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\n\tif (rpcapd_discard(pars->sockctrl, plen) == -1)\n\t{\n\t\treturn -1;\n\t}\n\n\treturn 0;\n\nerror:\n\tif (rpcap_senderror(pars->sockctrl, ver, PCAP_ERR_SETSAMPLING,\n\t    errmsgbuf, errbuf) == -1)\n\t{\n\t\t// That failed; log a message and give up.\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\n\t// Check if all the data has been read; if not, discard the data in excess\n\tif (rpcapd_discard(pars->sockctrl, plen) == -1)\n\t{\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int\ndaemon_msg_stats_req(uint8 ver, struct daemon_slpars *pars,\n    struct session *session, uint32 plen, struct pcap_stat *stats,\n    unsigned int svrcapt)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE];\t\t// buffer for network errors\n\tchar errmsgbuf[PCAP_ERRBUF_SIZE];\t// buffer for errors to send to the client\n\tchar sendbuf[RPCAP_NETBUF_SIZE];\t// temporary buffer in which data to be sent is buffered\n\tint sendbufidx = 0;\t\t\t// index which keeps the number of bytes currently buffered\n\tstruct rpcap_stats *netstats;\t\t// statistics sent on the network\n\n\t// Checks that the header does not contain other data; if so, discard it\n\tif (rpcapd_discard(pars->sockctrl, plen) == -1)\n\t{\n\t\t// Network error.\n\t\treturn -1;\n\t}\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL,\n\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\trpcap_createhdr((struct rpcap_header *) sendbuf, ver,\n\t    RPCAP_MSG_STATS_REPLY, 0, (uint16) sizeof(struct rpcap_stats));\n\n\tnetstats = (struct rpcap_stats *) &sendbuf[sendbufidx];\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_stats), NULL,\n\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\tif (session && session->fp)\n\t{\n\t\tif (pcap_stats(session->fp, stats) == -1)\n\t\t{\n\t\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"%s\", pcap_geterr(session->fp));\n\t\t\tgoto error;\n\t\t}\n\n\t\tnetstats->ifdrop = htonl(stats->ps_ifdrop);\n\t\tnetstats->ifrecv = htonl(stats->ps_recv);\n\t\tnetstats->krnldrop = htonl(stats->ps_drop);\n\t\tnetstats->svrcapt = htonl(session->TotCapt);\n\t}\n\telse\n\t{\n\t\t// We have to keep compatibility with old applications,\n\t\t// which ask for statistics also when the capture has\n\t\t// already stopped.\n\t\tnetstats->ifdrop = htonl(stats->ps_ifdrop);\n\t\tnetstats->ifrecv = htonl(stats->ps_recv);\n\t\tnetstats->krnldrop = htonl(stats->ps_drop);\n\t\tnetstats->svrcapt = htonl(svrcapt);\n\t}\n\n\t// Send the packet\n\tif (sock_send(pars->sockctrl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n\nerror:\n\trpcap_senderror(pars->sockctrl, ver, PCAP_ERR_GETSTATS,\n\t    errmsgbuf, NULL);\n\treturn 0;\n}\n\n#ifdef _WIN32\nstatic unsigned __stdcall\n#else\nstatic void *\n#endif\ndaemon_thrdatamain(void *ptr)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE + 1];\t// error buffer\n\tstruct session *session;\t\t// pointer to the struct session for this session\n\tint retval;\t\t\t\t\t\t\t// general variable used to keep the return value of other functions\n\tstruct rpcap_pkthdr *net_pkt_header;// header of the packet\n\tstruct pcap_pkthdr *pkt_header;\t\t// pointer to the buffer that contains the header of the current packet\n\tu_char *pkt_data;\t\t\t\t\t// pointer to the buffer that contains the current packet\n\tsize_t sendbufsize;\t\t\t// size for the send buffer\n\tchar *sendbuf;\t\t\t\t\t\t// temporary buffer in which data to be sent is buffered\n\tint sendbufidx;\t\t\t\t\t\t// index which keeps the number of bytes currently buffered\n\tint status;\n#ifndef _WIN32\n\tsigset_t sigusr1;\t\t\t// signal set with just SIGUSR1\n#endif\n\n\tsession = (struct session *) ptr;\n\n\tsession->TotCapt = 0;\t\t\t// counter which is incremented each time a packet is received\n\n\t// Initialize errbuf\n\tmemset(errbuf, 0, sizeof(errbuf));\n\n\t//\n\t// We need a buffer large enough to hold a buffer large enough\n\t// for a maximum-size packet for this pcap_t.\n\t//\n\tif (pcap_snapshot(session->fp) < 0)\n\t{\n\t\t//\n\t\t// The snapshot length is negative.\n\t\t// This \"should not happen\".\n\t\t//\n\t\trpcapd_log(LOGPRIO_ERROR,\n\t\t    \"Unable to allocate the buffer for this child thread: snapshot length of %d is negative\",\n\t\t        pcap_snapshot(session->fp));\n\t\tsendbuf = NULL;\t// we can't allocate a buffer, so nothing to free\n\t\tgoto error;\n\t}\n\t//\n\t// size_t is unsigned, and the result of pcap_snapshot() is signed;\n\t// on no platform that we support is int larger than size_t.\n\t// This means that, unless the extra information we prepend to\n\t// a maximum-sized packet is impossibly large, the sum of the\n\t// snapshot length and the size of that extra information will\n\t// fit in a size_t.\n\t//\n\t// So we don't need to make sure that sendbufsize will overflow.\n\t//\n\tsendbufsize = sizeof(struct rpcap_header) + sizeof(struct rpcap_pkthdr) + pcap_snapshot(session->fp);\n\tsendbuf = (char *) malloc (sendbufsize);\n\tif (sendbuf == NULL)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR,\n\t\t    \"Unable to allocate the buffer for this child thread\");\n\t\tgoto error;\n\t}\n\n#ifndef _WIN32\n\t//\n\t// Set the signal set to include just SIGUSR1, and block that\n\t// signal; we only want it unblocked when we're reading\n\t// packets - we dn't want any other system calls, such as\n\t// ones being used to send to the client or to log messages,\n\t// to be interrupted.\n\t//\n\tsigemptyset(&sigusr1);\n\tsigaddset(&sigusr1, SIGUSR1);\n\tpthread_sigmask(SIG_BLOCK, &sigusr1, NULL);\n#endif\n\n\t// Retrieve the packets\n\tfor (;;)\n\t{\n#ifndef _WIN32\n\t\t//\n\t\t// Unblock SIGUSR1 while we might be waiting for packets.\n\t\t//\n\t\tpthread_sigmask(SIG_UNBLOCK, &sigusr1, NULL);\n#endif\n\t\tretval = pcap_next_ex(session->fp, &pkt_header, (const u_char **) &pkt_data);\t// cast to avoid a compiler warning\n#ifndef _WIN32\n\t\t//\n\t\t// Now block it again.\n\t\t//\n\t\tpthread_sigmask(SIG_BLOCK, &sigusr1, NULL);\n#endif\n\t\tif (retval < 0)\n\t\t\tbreak;\t\t// error\n\t\tif (retval == 0)\t// Read timeout elapsed\n\t\t\tcontinue;\n\n\t\tsendbufidx = 0;\n\n\t\t// Bufferize the general header\n\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL,\n\t\t    &sendbufidx, sendbufsize, SOCKBUF_CHECKONLY, errbuf,\n\t\t    PCAP_ERRBUF_SIZE) == -1)\n\t\t{\n\t\t\trpcapd_log(LOGPRIO_ERROR,\n\t\t\t    \"sock_bufferize() error sending packet message: %s\",\n\t\t\t    errbuf);\n\t\t\tgoto error;\n\t\t}\n\n\t\trpcap_createhdr((struct rpcap_header *) sendbuf,\n\t\t    session->protocol_version, RPCAP_MSG_PACKET, 0,\n\t\t    (uint16) (sizeof(struct rpcap_pkthdr) + pkt_header->caplen));\n\n\t\tnet_pkt_header = (struct rpcap_pkthdr *) &sendbuf[sendbufidx];\n\n\t\t// Bufferize the pkt header\n\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_pkthdr), NULL,\n\t\t    &sendbufidx, sendbufsize, SOCKBUF_CHECKONLY, errbuf,\n\t\t    PCAP_ERRBUF_SIZE) == -1)\n\t\t{\n\t\t\trpcapd_log(LOGPRIO_ERROR,\n\t\t\t    \"sock_bufferize() error sending packet message: %s\",\n\t\t\t    errbuf);\n\t\t\tgoto error;\n\t\t}\n\n\t\tnet_pkt_header->caplen = htonl(pkt_header->caplen);\n\t\tnet_pkt_header->len = htonl(pkt_header->len);\n\t\tnet_pkt_header->npkt = htonl(++(session->TotCapt));\n\t\tnet_pkt_header->timestamp_sec = htonl(pkt_header->ts.tv_sec);\n\t\tnet_pkt_header->timestamp_usec = htonl(pkt_header->ts.tv_usec);\n\n\t\t// Bufferize the pkt data\n\t\tif (sock_bufferize((char *) pkt_data, pkt_header->caplen,\n\t\t    sendbuf, &sendbufidx, sendbufsize, SOCKBUF_BUFFERIZE,\n\t\t    errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t{\n\t\t\trpcapd_log(LOGPRIO_ERROR,\n\t\t\t    \"sock_bufferize() error sending packet message: %s\",\n\t\t\t    errbuf);\n\t\t\tgoto error;\n\t\t}\n\n\t\t// Send the packet\n\t\t// If the client dropped the connection, don't report an\n\t\t// error, just quit.\n\t\tstatus = sock_send(session->sockdata, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE);\n\t\tif (status < 0)\n\t\t{\n\t\t\tif (status == -1)\n\t\t\t{\n\t\t\t\t//\n\t\t\t\t// Error other than \"client closed the\n\t\t\t\t// connection out from under us\"; report\n\t\t\t\t// it.\n\t\t\t\t//\n\t\t\t\trpcapd_log(LOGPRIO_ERROR,\n\t\t\t\t    \"Send of packet to client failed: %s\",\n\t\t\t\t    errbuf);\n\t\t\t}\n\n\t\t\t//\n\t\t\t// Give up in either case.\n\t\t\t//\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (retval < 0 && retval != PCAP_ERROR_BREAK)\n\t{\n\t\t//\n\t\t// Failed with an error other than \"we were told to break\n\t\t// out of the loop\".\n\t\t//\n\t\t// The latter just means that the client told us to stop\n\t\t// capturing, so there's no error to report.\n\t\t//\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Error reading the packets: %s\", pcap_geterr(session->fp));\n\t\trpcap_senderror(session->sockctrl, session->protocol_version,\n\t\t    PCAP_ERR_READEX, errbuf, NULL);\n\t}\n\nerror:\n\t//\n\t// The main thread will clean up the session structure.\n\t//\n\tfree(sendbuf);\n\n\treturn 0;\n}\n\n#ifndef _WIN32\n//\n// Do-nothing handler for SIGUSR1; the sole purpose of SIGUSR1 is to\n// interrupt the data thread if it's blocked in a system call waiting\n// for packets to arrive.\n//\nstatic void noop_handler(int sign _U_)\n{\n}\n#endif\n\n/*!\n\t\\brief It serializes a network address.\n\n\tIt accepts a 'sockaddr_storage' structure as input, and it converts it appropriately into a format\n\tthat can be used to be sent on the network. Basically, it applies all the hton()\n\tconversion required to the input variable.\n\n\t\\param sockaddrin a 'sockaddr_storage' pointer to the variable that has to be\n\tserialized. This variable can be both a 'sockaddr_in' and 'sockaddr_in6'.\n\n\t\\param sockaddrout an 'rpcap_sockaddr' pointer to the variable that will contain\n\tthe serialized data. This variable has to be allocated by the user.\n\n\t\\warning This function supports only AF_INET and AF_INET6 address families.\n*/\nstatic void\ndaemon_seraddr(struct sockaddr_storage *sockaddrin, struct rpcap_sockaddr *sockaddrout)\n{\n\tmemset(sockaddrout, 0, sizeof(struct sockaddr_storage));\n\n\t// There can be the case in which the sockaddrin is not available\n\tif (sockaddrin == NULL) return;\n\n\t// Warning: we support only AF_INET and AF_INET6\n\tswitch (sockaddrin->ss_family)\n\t{\n\tcase AF_INET:\n\t\t{\n\t\tstruct sockaddr_in *sockaddrin_ipv4;\n\t\tstruct rpcap_sockaddr_in *sockaddrout_ipv4;\n\n\t\tsockaddrin_ipv4 = (struct sockaddr_in *) sockaddrin;\n\t\tsockaddrout_ipv4 = (struct rpcap_sockaddr_in *) sockaddrout;\n\t\tsockaddrout_ipv4->family = htons(RPCAP_AF_INET);\n\t\tsockaddrout_ipv4->port = htons(sockaddrin_ipv4->sin_port);\n\t\tmemcpy(&sockaddrout_ipv4->addr, &sockaddrin_ipv4->sin_addr, sizeof(sockaddrout_ipv4->addr));\n\t\tmemset(sockaddrout_ipv4->zero, 0, sizeof(sockaddrout_ipv4->zero));\n\t\tbreak;\n\t\t}\n\n#ifdef AF_INET6\n\tcase AF_INET6:\n\t\t{\n\t\tstruct sockaddr_in6 *sockaddrin_ipv6;\n\t\tstruct rpcap_sockaddr_in6 *sockaddrout_ipv6;\n\n\t\tsockaddrin_ipv6 = (struct sockaddr_in6 *) sockaddrin;\n\t\tsockaddrout_ipv6 = (struct rpcap_sockaddr_in6 *) sockaddrout;\n\t\tsockaddrout_ipv6->family = htons(RPCAP_AF_INET6);\n\t\tsockaddrout_ipv6->port = htons(sockaddrin_ipv6->sin6_port);\n\t\tsockaddrout_ipv6->flowinfo = htonl(sockaddrin_ipv6->sin6_flowinfo);\n\t\tmemcpy(&sockaddrout_ipv6->addr, &sockaddrin_ipv6->sin6_addr, sizeof(sockaddrout_ipv6->addr));\n\t\tsockaddrout_ipv6->scope_id = htonl(sockaddrin_ipv6->sin6_scope_id);\n\t\tbreak;\n\t\t}\n#endif\n\t}\n}\n\n\n/*!\n\t\\brief Suspends a thread for secs seconds.\n*/\nvoid sleep_secs(int secs)\n{\n#ifdef _WIN32\n\tSleep(secs*1000);\n#else\n\tunsigned secs_remaining;\n\n\tif (secs <= 0)\n\t\treturn;\n\tsecs_remaining = secs;\n\twhile (secs_remaining != 0)\n\t\tsecs_remaining = sleep(secs_remaining);\n#endif\n}\n\n/*\n * Read the header of a message.\n */\nstatic int\nrpcapd_recv_msg_header(SOCKET sock, struct rpcap_header *headerp)\n{\n\tint nread;\n\tchar errbuf[PCAP_ERRBUF_SIZE];\t\t// buffer for network errors\n\n\tnread = sock_recv(sock, (char *) headerp, sizeof(struct rpcap_header),\n\t    SOCK_RECEIVEALL_YES|SOCK_EOF_ISNT_ERROR, errbuf, PCAP_ERRBUF_SIZE);\n\tif (nread == -1)\n\t{\n\t\t// Network error.\n\t\trpcapd_log(LOGPRIO_ERROR, \"Read from client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\tif (nread == 0)\n\t{\n\t\t// Immediate EOF; that's treated like a close message.\n\t\treturn -2;\n\t}\n\theaderp->plen = ntohl(headerp->plen);\n\treturn 0;\n}\n\n/*\n * Read data from a message.\n * If we're trying to read more data that remains, puts an error\n * message into errmsgbuf and returns -2.  Otherwise, tries to read\n * the data and, if that succeeds, subtracts the amount read from\n * the number of bytes of data that remains.\n * Returns 0 on success, logs a message and returns -1 on a network\n * error.\n */\nstatic int\nrpcapd_recv(SOCKET sock, char *buffer, size_t toread, uint32 *plen, char *errmsgbuf)\n{\n\tint nread;\n\tchar errbuf[PCAP_ERRBUF_SIZE];\t\t// buffer for network errors\n\n\tif (toread > *plen)\n\t{\n\t\t// Tell the client and continue.\n\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Message payload is too short\");\n\t\treturn -2;\n\t}\n\tnread = sock_recv(sock, buffer, toread,\n\t    SOCK_RECEIVEALL_YES|SOCK_EOF_IS_ERROR, errbuf, PCAP_ERRBUF_SIZE);\n\tif (nread == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Read from client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\t*plen -= nread;\n\treturn 0;\n}\n\n/*\n * Discard data from a connection.\n * Mostly used to discard wrong-sized messages.\n * Returns 0 on success, logs a message and returns -1 on a network\n * error.\n */\nstatic int\nrpcapd_discard(SOCKET sock, uint32 len)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE + 1];\t// keeps the error string, prior to be printed\n\n\tif (len != 0)\n\t{\n\t\tif (sock_discard(sock, len, errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t{\n\t\t\t// Network error.\n\t\t\trpcapd_log(LOGPRIO_ERROR, \"Read from client failed: %s\", errbuf);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n//\n// Shut down any packet-capture thread associated with the session,\n// close the SSL handle for the data socket if we have one, close\n// the data socket if we have one, and close the underlying packet\n// capture handle if we have one.\n//\n// We do not, of course, touch the controlling socket that's also\n// copied into the session, as the service loop might still use it.\n//\nstatic void session_close(struct session *session)\n{\n\tif (session->have_thread)\n\t{\n\t\t//\n\t\t// Tell the data connection thread main capture loop to\n\t\t// break out of that loop.\n\t\t//\n\t\t// This may be sufficient to wake up a blocked thread,\n\t\t// but it's not guaranteed to be sufficient.\n\t\t//\n\t\tpcap_breakloop(session->fp);\n\n#ifdef _WIN32\n\t\t//\n\t\t// Set the event on which a read would block, so that,\n\t\t// if it's currently blocked waiting for packets to\n\t\t// arrive, it'll wake up, so it can see the \"break\n\t\t// out of the loop\" indication.  (pcap_breakloop()\n\t\t// might do this, but older versions don't.  Setting\n\t\t// it twice should, at worst, cause an extra wakeup,\n\t\t// which shouldn't be a problem.)\n\t\t//\n\t\t// XXX - what about modules other than NPF?\n\t\t//\n\t\tSetEvent(pcap_getevent(session->fp));\n\n\t\t//\n\t\t// Wait for the thread to exit, so we don't close\n\t\t// sockets out from under it.\n\t\t//\n\t\t// XXX - have a timeout, so we don't wait forever?\n\t\t//\n\t\tWaitForSingleObject(session->thread, INFINITE);\n\n\t\t//\n\t\t// Release the thread handle, as we're done with\n\t\t// it.\n\t\t//\n\t\tCloseHandle(session->thread);\n\t\tsession->have_thread = 0;\n\t\tsession->thread = INVALID_HANDLE_VALUE;\n#else\n\t\t//\n\t\t// Send a SIGUSR1 signal to the thread, so that, if\n\t\t// it's currently blocked waiting for packets to arrive,\n\t\t// it'll wake up (we've turned off SA_RESTART for\n\t\t// SIGUSR1, so that the system call in which it's blocked\n\t\t// should return EINTR rather than restarting).\n\t\t//\n\t\tpthread_kill(session->thread, SIGUSR1);\n\n\t\t//\n\t\t// Wait for the thread to exit, so we don't close\n\t\t// sockets out from under it.\n\t\t//\n\t\t// XXX - have a timeout, so we don't wait forever?\n\t\t//\n\t\tpthread_join(session->thread, NULL);\n\t\tsession->have_thread = 0;\n\t\tmemset(&session->thread, 0, sizeof(session->thread));\n#endif\n\t}\n\n\tif (session->sockdata != INVALID_SOCKET)\n\t{\n\t\tsock_close(session->sockdata, NULL, 0);\n\t\tsession->sockdata = INVALID_SOCKET;\n\t}\n\n\tif (session->fp)\n\t{\n\t\tpcap_close(session->fp);\n\t\tsession->fp = NULL;\n\t}\n}\n"], "fixing_code": ["/*\n * Copyright (c) 2002 - 2003\n * NetGroup, Politecnico di Torino (Italy)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the Politecnico di Torino nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include \"ftmacros.h\"\n#include \"varattrs.h\"\n\n#include <errno.h>\t\t// for the errno variable\n#include <stdlib.h>\t\t// for malloc(), free(), ...\n#include <string.h>\t\t// for strlen(), ...\n\n#ifdef _WIN32\n  #include <process.h>\t\t// for threads\n#else\n  #include <unistd.h>\n  #include <pthread.h>\n  #include <signal.h>\n  #include <sys/time.h>\n  #include <sys/types.h>\t// for select() and such\n  #include <pwd.h>\t\t// for password management\n#endif\n\n#ifdef HAVE_GETSPNAM\n#include <shadow.h>\t\t// for password management\n#endif\n\n#include <pcap.h>\t\t// for libpcap/WinPcap calls\n\n#include \"fmtutils.h\"\n#include \"sockutils.h\"\t\t// for socket calls\n#include \"portability.h\"\n#include \"rpcap-protocol.h\"\n#include \"daemon.h\"\n#include \"log.h\"\n\n//\n// Timeout, in seconds, when we're waiting for a client to send us an\n// authentication request; if they don't send us a request within that\n// interval, we drop the connection, so we don't stay stuck forever.\n//\n#define RPCAP_TIMEOUT_INIT 90\n\n//\n// Timeout, in seconds, when we're waiting for an authenticated client\n// to send us a request, if a capture isn't in progress; if they don't\n// send us a request within that interval, we drop the connection, so\n// we don't stay stuck forever.\n//\n#define RPCAP_TIMEOUT_RUNTIME 180\n\n//\n// Time, in seconds, that we wait after a failed authentication attempt\n// before processing the next request; this prevents a client from\n// rapidly trying different accounts or passwords.\n//\n#define RPCAP_SUSPEND_WRONGAUTH 1\n\n// Parameters for the service loop.\nstruct daemon_slpars\n{\n\tSOCKET sockctrl;\t//!< SOCKET ID of the control connection\n\tint isactive;\t\t//!< Not null if the daemon has to run in active mode\n\tint nullAuthAllowed;\t//!< '1' if we permit NULL authentication, '0' otherwise\n};\n\n//\n// Data for a session managed by a thread.\n// It includes both a Boolean indicating whether we *have* a thread,\n// and a platform-dependent (UN*X vs. Windows) identifier for the\n// thread; on Windows, we could use an invalid handle to indicate\n// that we don't have a thread, but there *is* no portable \"no thread\"\n// value for a pthread_t on UN*X.\n//\nstruct session {\n\tSOCKET sockctrl;\n\tSOCKET sockdata;\n\tuint8 protocol_version;\n\tpcap_t *fp;\n\tunsigned int TotCapt;\n\tint\thave_thread;\n#ifdef _WIN32\n\tHANDLE thread;\n#else\n\tpthread_t thread;\n#endif\n};\n\n// Locally defined functions\nstatic int daemon_msg_err(SOCKET sockctrl, uint32 plen);\nstatic int daemon_msg_auth_req(struct daemon_slpars *pars, uint32 plen);\nstatic int daemon_AuthUserPwd(char *username, char *password, char *errbuf);\n\nstatic int daemon_msg_findallif_req(uint8 ver, struct daemon_slpars *pars,\n    uint32 plen);\n\nstatic int daemon_msg_open_req(uint8 ver, struct daemon_slpars *pars,\n    uint32 plen, char *source, size_t sourcelen);\nstatic int daemon_msg_startcap_req(uint8 ver, struct daemon_slpars *pars,\n    uint32 plen, char *source, struct session **sessionp,\n    struct rpcap_sampling *samp_param);\nstatic int daemon_msg_endcap_req(uint8 ver, struct daemon_slpars *pars,\n    struct session *session);\n\nstatic int daemon_msg_updatefilter_req(uint8 ver, struct daemon_slpars *pars,\n    struct session *session, uint32 plen);\nstatic int daemon_unpackapplyfilter(SOCKET sockctrl, struct session *session, uint32 *plenp, char *errbuf);\n\nstatic int daemon_msg_stats_req(uint8 ver, struct daemon_slpars *pars,\n    struct session *session, uint32 plen, struct pcap_stat *stats,\n    unsigned int svrcapt);\n\nstatic int daemon_msg_setsampling_req(uint8 ver, struct daemon_slpars *pars,\n    uint32 plen, struct rpcap_sampling *samp_param);\n\nstatic void daemon_seraddr(struct sockaddr_storage *sockaddrin, struct rpcap_sockaddr *sockaddrout);\n#ifdef _WIN32\nstatic unsigned __stdcall daemon_thrdatamain(void *ptr);\n#else\nstatic void *daemon_thrdatamain(void *ptr);\nstatic void noop_handler(int sign);\n#endif\n\nstatic int rpcapd_recv_msg_header(SOCKET sock, struct rpcap_header *headerp);\nstatic int rpcapd_recv(SOCKET sock, char *buffer, size_t toread, uint32 *plen, char *errmsgbuf);\nstatic int rpcapd_discard(SOCKET sock, uint32 len);\nstatic void session_close(struct session *);\n\nstatic int is_url(const char *source);\n\nint\ndaemon_serviceloop(SOCKET sockctrl, int isactive, char *passiveClients,\n    int nullAuthAllowed)\n{\n\tstruct daemon_slpars pars;\t\t// service loop parameters\n\tchar errbuf[PCAP_ERRBUF_SIZE + 1];\t// keeps the error string, prior to be printed\n\tchar errmsgbuf[PCAP_ERRBUF_SIZE + 1];\t// buffer for errors to send to the client\n\tint host_port_check_status;\n\tint nrecv;\n\tstruct rpcap_header header;\t\t// RPCAP message general header\n\tuint32 plen;\t\t\t\t// payload length from header\n\tint authenticated = 0;\t\t\t// 1 if the client has successfully authenticated\n\tchar source[PCAP_BUF_SIZE+1];\t\t// keeps the string that contains the interface to open\n\tint got_source = 0;\t\t\t// 1 if we've gotten the source from an open request\n#ifndef _WIN32\n\tstruct sigaction action;\n#endif\n\tstruct session *session = NULL;\t\t// struct session main variable\n\tconst char *msg_type_string;\t\t// string for message type\n\tint client_told_us_to_close = 0;\t// 1 if the client told us to close the capture\n\n\t// needed to save the values of the statistics\n\tstruct pcap_stat stats;\n\tunsigned int svrcapt;\n\n\tstruct rpcap_sampling samp_param;\t// in case sampling has been requested\n\n\t// Structures needed for the select() call\n\tfd_set rfds;\t\t\t\t// set of socket descriptors we have to check\n\tstruct timeval tv;\t\t\t// maximum time the select() can block waiting for data\n\tint retval;\t\t\t\t// select() return value\n\n\t*errbuf = 0;\t// Initialize errbuf\n\n\t// Set parameters structure\n\tpars.sockctrl = sockctrl;\n\tpars.isactive = isactive;\t\t// active mode\n\tpars.nullAuthAllowed = nullAuthAllowed;\n\n\t//\n\t// We have a connection.\n\t//\n\t// If it's a passive mode connection, check whether the connecting\n\t// host is among the ones allowed.\n\t//\n\t// In either case, we were handed a copy of the host list; free it\n\t// as soon as we're done with it.\n\t//\n\tif (pars.isactive)\n\t{\n\t\t// Nothing to do.\n\t\tfree(passiveClients);\n\t\tpassiveClients = NULL;\n\t}\n\telse\n\t{\n\t\tstruct sockaddr_storage from;\n\t\tsocklen_t fromlen;\n\n\t\t//\n\t\t// Get the address of the other end of the connection.\n\t\t//\n\t\tfromlen = sizeof(struct sockaddr_storage);\n\t\tif (getpeername(pars.sockctrl, (struct sockaddr *)&from,\n\t\t    &fromlen) == -1)\n\t\t{\n\t\t\tsock_geterror(\"getpeername()\", errmsgbuf, PCAP_ERRBUF_SIZE);\n\t\t\tif (rpcap_senderror(pars.sockctrl, 0, PCAP_ERR_NETW, errmsgbuf, errbuf) == -1)\n\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\tgoto end;\n\t\t}\n\n\t\t//\n\t\t// Are they in the list of host/port combinations we allow?\n\t\t//\n\t\thost_port_check_status = sock_check_hostlist(passiveClients, RPCAP_HOSTLIST_SEP, &from, errmsgbuf, PCAP_ERRBUF_SIZE);\n\t\tfree(passiveClients);\n\t\tpassiveClients = NULL;\n\t\tif (host_port_check_status < 0)\n\t\t{\n\t\t\tif (host_port_check_status == -2) {\n\t\t\t\t//\n\t\t\t\t// We got an error; log it.\n\t\t\t\t//\n\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"%s\", errmsgbuf);\n\t\t\t}\n\n\t\t\t//\n\t\t\t// Sorry, we can't let you in.\n\t\t\t//\n\t\t\tif (rpcap_senderror(pars.sockctrl, 0, PCAP_ERR_HOSTNOAUTH, errmsgbuf, errbuf) == -1)\n\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\tgoto end;\n\t\t}\n\t}\n\n#ifndef _WIN32\n\t//\n\t// Catch SIGUSR1, but do nothing.  We use it to interrupt the\n\t// capture thread to break it out of a loop in which it's\n\t// blocked waiting for packets to arrive.\n\t//\n\t// We don't want interrupted system calls to restart, so that\n\t// the read routine for the pcap_t gets EINTR rather than\n\t// restarting if it's blocked in a system call.\n\t//\n\tmemset(&action, 0, sizeof (action));\n\taction.sa_handler = noop_handler;\n\taction.sa_flags = 0;\n\tsigemptyset(&action.sa_mask);\n\tsigaction(SIGUSR1, &action, NULL);\n#endif\n\n\t//\n\t// The client must first authenticate; loop until they send us a\n\t// message with a version we support and credentials we accept,\n\t// they send us a close message indicating that they're giving up,\n\t// or we get a network error or other fatal error.\n\t//\n\twhile (!authenticated)\n\t{\n\t\t//\n\t\t// If we're not in active mode, we use select(), with a\n\t\t// timeout, to wait for an authentication request; if\n\t\t// the timeout expires, we drop the connection, so that\n\t\t// a client can't just connect to us and leave us\n\t\t// waiting forever.\n\t\t//\n\t\tif (!pars.isactive)\n\t\t{\n\t\t\tFD_ZERO(&rfds);\n\t\t\t// We do not have to block here\n\t\t\ttv.tv_sec = RPCAP_TIMEOUT_INIT;\n\t\t\ttv.tv_usec = 0;\n\n\t\t\tFD_SET(pars.sockctrl, &rfds);\n\n\t\t\tretval = select(pars.sockctrl + 1, &rfds, NULL, NULL, &tv);\n\t\t\tif (retval == -1)\n\t\t\t{\n\t\t\t\tsock_geterror(\"select() failed\", errmsgbuf, PCAP_ERRBUF_SIZE);\n\t\t\t\tif (rpcap_senderror(pars.sockctrl, 0, PCAP_ERR_NETW, errmsgbuf, errbuf) == -1)\n\t\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\t// The timeout has expired\n\t\t\t// So, this was a fake connection. Drop it down\n\t\t\tif (retval == 0)\n\t\t\t{\n\t\t\t\tif (rpcap_senderror(pars.sockctrl, 0, PCAP_ERR_INITTIMEOUT, \"The RPCAP initial timeout has expired\", errbuf) == -1)\n\t\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\n\t\t//\n\t\t// Read the message header from the client.\n\t\t//\n\t\tnrecv = rpcapd_recv_msg_header(pars.sockctrl, &header);\n\t\tif (nrecv == -1)\n\t\t{\n\t\t\t// Fatal error.\n\t\t\tgoto end;\n\t\t}\n\t\tif (nrecv == -2)\n\t\t{\n\t\t\t// Client closed the connection.\n\t\t\tgoto end;\n\t\t}\n\n\t\tplen = header.plen;\n\n\t\t//\n\t\t// While we're in the authentication pharse, all requests\n\t\t// must use version 0.\n\t\t//\n\t\tif (header.ver != 0)\n\t\t{\n\t\t\t//\n\t\t\t// Send it back to them with their version.\n\t\t\t//\n\t\t\tif (rpcap_senderror(pars.sockctrl, header.ver,\n\t\t\t    PCAP_ERR_WRONGVER,\n\t\t\t    \"RPCAP version in requests in the authentication phase must be 0\",\n\t\t\t    errbuf) == -1)\n\t\t\t{\n\t\t\t\t// That failed; log a message and give up.\n\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\t// Discard the rest of the message and drop the\n\t\t\t// connection.\n\t\t\t(void)rpcapd_discard(pars.sockctrl, plen);\n\t\t\tgoto end;\n\t\t}\n\n\t\tswitch (header.type)\n\t\t{\n\t\t\tcase RPCAP_MSG_AUTH_REQ:\n\t\t\t\tretval = daemon_msg_auth_req(&pars, plen);\n\t\t\t\tif (retval == -1)\n\t\t\t\t{\n\t\t\t\t\t// Fatal error; a message has\n\t\t\t\t\t// been logged, so just give up.\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tif (retval == -2)\n\t\t\t\t{\n\t\t\t\t\t// Non-fatal error; we sent back\n\t\t\t\t\t// an error message, so let them\n\t\t\t\t\t// try again.\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// OK, we're authenticated; we sent back\n\t\t\t\t// a reply, so start serving requests.\n\t\t\t\tauthenticated = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase RPCAP_MSG_CLOSE:\n\t\t\t\t//\n\t\t\t\t// The client is giving up.\n\t\t\t\t// Discard the rest of the message, if\n\t\t\t\t// there is anything more.\n\t\t\t\t//\n\t\t\t\t(void)rpcapd_discard(pars.sockctrl, plen);\n\t\t\t\t// We're done with this client.\n\t\t\t\tgoto end;\n\n\t\t\tcase RPCAP_MSG_ERROR:\n\t\t\t\t// Log this and close the connection?\n\t\t\t\t// XXX - is this what happens in active\n\t\t\t\t// mode, where *we* initiate the\n\t\t\t\t// connection, and the client gives us\n\t\t\t\t// an error message rather than a \"let\n\t\t\t\t// me log in\" message, indicating that\n\t\t\t\t// we're not allowed to connect to them?\n\t\t\t\t(void)daemon_msg_err(pars.sockctrl, plen);\n\t\t\t\tgoto end;\n\n\t\t\tcase RPCAP_MSG_FINDALLIF_REQ:\n\t\t\tcase RPCAP_MSG_OPEN_REQ:\n\t\t\tcase RPCAP_MSG_STARTCAP_REQ:\n\t\t\tcase RPCAP_MSG_UPDATEFILTER_REQ:\n\t\t\tcase RPCAP_MSG_STATS_REQ:\n\t\t\tcase RPCAP_MSG_ENDCAP_REQ:\n\t\t\tcase RPCAP_MSG_SETSAMPLING_REQ:\n\t\t\t\t//\n\t\t\t\t// These requests can't be sent until\n\t\t\t\t// the client is authenticated.\n\t\t\t\t//\n\t\t\t\tmsg_type_string = rpcap_msg_type_string(header.type);\n\t\t\t\tif (msg_type_string != NULL)\n\t\t\t\t{\n\t\t\t\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"%s request sent before authentication was completed\", msg_type_string);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Message of type %u sent before authentication was completed\", header.type);\n\t\t\t\t}\n\t\t\t\tif (rpcap_senderror(pars.sockctrl, header.ver,\n\t\t\t\t    PCAP_ERR_WRONGMSG, errmsgbuf, errbuf) == -1)\n\t\t\t\t{\n\t\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\t// Discard the rest of the message.\n\t\t\t\tif (rpcapd_discard(pars.sockctrl, plen) == -1)\n\t\t\t\t{\n\t\t\t\t\t// Network error.\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase RPCAP_MSG_PACKET:\n\t\t\tcase RPCAP_MSG_FINDALLIF_REPLY:\n\t\t\tcase RPCAP_MSG_OPEN_REPLY:\n\t\t\tcase RPCAP_MSG_STARTCAP_REPLY:\n\t\t\tcase RPCAP_MSG_UPDATEFILTER_REPLY:\n\t\t\tcase RPCAP_MSG_AUTH_REPLY:\n\t\t\tcase RPCAP_MSG_STATS_REPLY:\n\t\t\tcase RPCAP_MSG_ENDCAP_REPLY:\n\t\t\tcase RPCAP_MSG_SETSAMPLING_REPLY:\n\t\t\t\t//\n\t\t\t\t// These are server-to-client messages.\n\t\t\t\t//\n\t\t\t\tmsg_type_string = rpcap_msg_type_string(header.type);\n\t\t\t\tif (msg_type_string != NULL)\n\t\t\t\t{\n\t\t\t\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Server-to-client message %s received from client\", msg_type_string);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Server-to-client message of type %u received from client\", header.type);\n\t\t\t\t}\n\t\t\t\tif (rpcap_senderror(pars.sockctrl, header.ver,\n\t\t\t\t    PCAP_ERR_WRONGMSG, errmsgbuf, errbuf) == -1)\n\t\t\t\t{\n\t\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\t// Discard the rest of the message.\n\t\t\t\tif (rpcapd_discard(pars.sockctrl, plen) == -1)\n\t\t\t\t{\n\t\t\t\t\t// Fatal error.\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t//\n\t\t\t\t// Unknown message type.\n\t\t\t\t//\n\t\t\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Unknown message type %u\", header.type);\n\t\t\t\tif (rpcap_senderror(pars.sockctrl, header.ver,\n\t\t\t\t    PCAP_ERR_WRONGMSG, errmsgbuf, errbuf) == -1)\n\t\t\t\t{\n\t\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\t// Discard the rest of the message.\n\t\t\t\tif (rpcapd_discard(pars.sockctrl, plen) == -1)\n\t\t\t\t{\n\t\t\t\t\t// Fatal error.\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t//\n\t// OK, the client has authenticated itself, and we can start\n\t// processing regular requests from it.\n\t//\n\n\t//\n\t// We don't have any statistics yet.\n\t//\n\tstats.ps_ifdrop = 0;\n\tstats.ps_recv = 0;\n\tstats.ps_drop = 0;\n\tsvrcapt = 0;\n\n\t//\n\t// Service requests.\n\t//\n\tfor (;;)\n\t{\n\t\terrbuf[0] = 0;\t// clear errbuf\n\n\t\t// Avoid zombies connections; check if the connection is opens but no commands are performed\n\t\t// from more than RPCAP_TIMEOUT_RUNTIME\n\t\t// Conditions:\n\t\t// - I have to be in normal mode (no active mode)\n\t\t// - if the device is open, I don't have to be in the middle of a capture (session->sockdata)\n\t\t// - if the device is closed, I have always to check if a new command arrives\n\t\t//\n\t\t// Be carefully: the capture can have been started, but an error occurred (so session != NULL, but\n\t\t//  sockdata is 0\n\t\tif ((!pars.isactive) &&  ((session == NULL) || ((session != NULL) && (session->sockdata == 0))))\n\t\t{\n\t\t\t// Check for the initial timeout\n\t\t\tFD_ZERO(&rfds);\n\t\t\t// We do not have to block here\n\t\t\ttv.tv_sec = RPCAP_TIMEOUT_RUNTIME;\n\t\t\ttv.tv_usec = 0;\n\n\t\t\tFD_SET(pars.sockctrl, &rfds);\n\n\t\t\tretval = select(pars.sockctrl + 1, &rfds, NULL, NULL, &tv);\n\t\t\tif (retval == -1)\n\t\t\t{\n\t\t\t\tsock_geterror(\"select() failed\", errmsgbuf, PCAP_ERRBUF_SIZE);\n\t\t\t\tif (rpcap_senderror(pars.sockctrl, 0,\n\t\t\t\t    PCAP_ERR_NETW, errmsgbuf, errbuf) == -1)\n\t\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\t// The timeout has expired\n\t\t\t// So, this was a fake connection. Drop it down\n\t\t\tif (retval == 0)\n\t\t\t{\n\t\t\t\tif (rpcap_senderror(pars.sockctrl, 0,\n\t\t\t\t    PCAP_ERR_INITTIMEOUT,\n\t\t\t\t    \"The RPCAP initial timeout has expired\",\n\t\t\t\t    errbuf) == -1)\n\t\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\n\t\t//\n\t\t// Read the message header from the client.\n\t\t//\n\t\tnrecv = rpcapd_recv_msg_header(pars.sockctrl, &header);\n\t\tif (nrecv == -1)\n\t\t{\n\t\t\t// Fatal error.\n\t\t\tgoto end;\n\t\t}\n\t\tif (nrecv == -2)\n\t\t{\n\t\t\t// Client closed the connection.\n\t\t\tgoto end;\n\t\t}\n\n\t\tplen = header.plen;\n\n\t\t//\n\t\t// Did the client specify a protocol version that we\n\t\t// support?\n\t\t//\n\t\tif (!RPCAP_VERSION_IS_SUPPORTED(header.ver))\n\t\t{\n\t\t\t//\n\t\t\t// Tell them it's not a supported version.\n\t\t\t// Send the error message with their version,\n\t\t\t// so they don't reject it as having the wrong\n\t\t\t// version.\n\t\t\t//\n\t\t\tif (rpcap_senderror(pars.sockctrl,\n\t\t\t    header.ver, PCAP_ERR_WRONGVER,\n\t\t\t    \"RPCAP version in message isn't supported by the server\",\n\t\t\t    errbuf) == -1)\n\t\t\t{\n\t\t\t\t// That failed; log a message and give up.\n\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\t// Discard the rest of the message.\n\t\t\t(void)rpcapd_discard(pars.sockctrl, plen);\n\t\t\t// Give up on them.\n\t\t\tgoto end;\n\t\t}\n\n\t\tswitch (header.type)\n\t\t{\n\t\t\tcase RPCAP_MSG_ERROR:\t\t// The other endpoint reported an error\n\t\t\t{\n\t\t\t\t(void)daemon_msg_err(pars.sockctrl, plen);\n\t\t\t\t// Do nothing; just exit; the error code is already into the errbuf\n\t\t\t\t// XXX - actually exit....\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase RPCAP_MSG_FINDALLIF_REQ:\n\t\t\t{\n\t\t\t\tif (daemon_msg_findallif_req(header.ver, &pars, plen) == -1)\n\t\t\t\t{\n\t\t\t\t\t// Fatal error; a message has\n\t\t\t\t\t// been logged, so just give up.\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase RPCAP_MSG_OPEN_REQ:\n\t\t\t{\n\t\t\t\t//\n\t\t\t\t// Process the open request, and keep\n\t\t\t\t// the source from it, for use later\n\t\t\t\t// when the capture is started.\n\t\t\t\t//\n\t\t\t\t// XXX - we don't care if the client sends\n\t\t\t\t// us multiple open requests, the last\n\t\t\t\t// one wins.\n\t\t\t\t//\n\t\t\t\tretval = daemon_msg_open_req(header.ver, &pars,\n\t\t\t\t    plen, source, sizeof(source));\n\t\t\t\tif (retval == -1)\n\t\t\t\t{\n\t\t\t\t\t// Fatal error; a message has\n\t\t\t\t\t// been logged, so just give up.\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tgot_source = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase RPCAP_MSG_STARTCAP_REQ:\n\t\t\t{\n\t\t\t\tif (!got_source)\n\t\t\t\t{\n\t\t\t\t\t// They never told us what device\n\t\t\t\t\t// to capture on!\n\t\t\t\t\tif (rpcap_senderror(pars.sockctrl,\n\t\t\t\t\t    header.ver,\n\t\t\t\t\t    PCAP_ERR_STARTCAPTURE,\n\t\t\t\t\t    \"No capture device was specified\",\n\t\t\t\t\t    errbuf) == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Fatal error; log an\n\t\t\t\t\t\t// error and  give up.\n\t\t\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t\tif (rpcapd_discard(pars.sockctrl, plen) == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (daemon_msg_startcap_req(header.ver, &pars,\n\t\t\t\t    plen, source, &session, &samp_param) == -1)\n\t\t\t\t{\n\t\t\t\t\t// Fatal error; a message has\n\t\t\t\t\t// been logged, so just give up.\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase RPCAP_MSG_UPDATEFILTER_REQ:\n\t\t\t{\n\t\t\t\tif (session)\n\t\t\t\t{\n\t\t\t\t\tif (daemon_msg_updatefilter_req(header.ver,\n\t\t\t\t\t    &pars, session, plen) == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Fatal error; a message has\n\t\t\t\t\t\t// been logged, so just give up.\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (rpcap_senderror(pars.sockctrl,\n\t\t\t\t\t    header.ver, PCAP_ERR_UPDATEFILTER,\n\t\t\t\t\t    \"Device not opened. Cannot update filter\",\n\t\t\t\t\t    errbuf) == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\t// That failed; log a message and give up.\n\t\t\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase RPCAP_MSG_CLOSE:\t\t// The other endpoint close the pcap session\n\t\t\t{\n\t\t\t\t//\n\t\t\t\t// Indicate to our caller that the client\n\t\t\t\t// closed the control connection.\n\t\t\t\t// This is used only in case of active mode.\n\t\t\t\t//\n\t\t\t\tclient_told_us_to_close = 1;\n\t\t\t\trpcapd_log(LOGPRIO_DEBUG, \"The other end system asked to close the connection.\");\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\tcase RPCAP_MSG_STATS_REQ:\n\t\t\t{\n\t\t\t\tif (daemon_msg_stats_req(header.ver, &pars,\n\t\t\t\t    session, plen, &stats, svrcapt) == -1)\n\t\t\t\t{\n\t\t\t\t\t// Fatal error; a message has\n\t\t\t\t\t// been logged, so just give up.\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase RPCAP_MSG_ENDCAP_REQ:\t\t// The other endpoint close the current capture session\n\t\t\t{\n\t\t\t\tif (session)\n\t\t\t\t{\n\t\t\t\t\t// Save statistics (we can need them in the future)\n\t\t\t\t\tif (pcap_stats(session->fp, &stats))\n\t\t\t\t\t{\n\t\t\t\t\t\tsvrcapt = session->TotCapt;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tstats.ps_ifdrop = 0;\n\t\t\t\t\t\tstats.ps_recv = 0;\n\t\t\t\t\t\tstats.ps_drop = 0;\n\t\t\t\t\t\tsvrcapt = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (daemon_msg_endcap_req(header.ver,\n\t\t\t\t\t    &pars, session) == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tfree(session);\n\t\t\t\t\t\tsession = NULL;\n\t\t\t\t\t\t// Fatal error; a message has\n\t\t\t\t\t\t// been logged, so just give up.\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t\tfree(session);\n\t\t\t\t\tsession = NULL;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\trpcap_senderror(pars.sockctrl,\n\t\t\t\t\t    header.ver, PCAP_ERR_ENDCAPTURE,\n\t\t\t\t\t    \"Device not opened. Cannot close the capture\",\n\t\t\t\t\t    errbuf);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase RPCAP_MSG_SETSAMPLING_REQ:\n\t\t\t{\n\t\t\t\tif (daemon_msg_setsampling_req(header.ver,\n\t\t\t\t    &pars, plen, &samp_param) == -1)\n\t\t\t\t{\n\t\t\t\t\t// Fatal error; a message has\n\t\t\t\t\t// been logged, so just give up.\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase RPCAP_MSG_AUTH_REQ:\n\t\t\t{\n\t\t\t\t//\n\t\t\t\t// We're already authenticated; you don't\n\t\t\t\t// get to reauthenticate.\n\t\t\t\t//\n\t\t\t\trpcapd_log(LOGPRIO_INFO, \"The client sent an RPCAP_MSG_AUTH_REQ message after authentication was completed\");\n\t\t\t\tif (rpcap_senderror(pars.sockctrl, header.ver,\n\t\t\t\t    PCAP_ERR_WRONGMSG,\n\t\t\t\t    \"RPCAP_MSG_AUTH_REQ request sent after authentication was completed\",\n\t\t\t\t    errbuf) == -1)\n\t\t\t\t{\n\t\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\t// Discard the rest of the message.\n\t\t\t\tif (rpcapd_discard(pars.sockctrl, plen) == -1)\n\t\t\t\t{\n\t\t\t\t\t// Fatal error.\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tgoto end;\n\n\t\t\tcase RPCAP_MSG_PACKET:\n\t\t\tcase RPCAP_MSG_FINDALLIF_REPLY:\n\t\t\tcase RPCAP_MSG_OPEN_REPLY:\n\t\t\tcase RPCAP_MSG_STARTCAP_REPLY:\n\t\t\tcase RPCAP_MSG_UPDATEFILTER_REPLY:\n\t\t\tcase RPCAP_MSG_AUTH_REPLY:\n\t\t\tcase RPCAP_MSG_STATS_REPLY:\n\t\t\tcase RPCAP_MSG_ENDCAP_REPLY:\n\t\t\tcase RPCAP_MSG_SETSAMPLING_REPLY:\n\t\t\t\t//\n\t\t\t\t// These are server-to-client messages.\n\t\t\t\t//\n\t\t\t\tmsg_type_string = rpcap_msg_type_string(header.type);\n\t\t\t\tif (msg_type_string != NULL)\n\t\t\t\t{\n\t\t\t\t\trpcapd_log(LOGPRIO_INFO, \"The client sent a %s server-to-client message\", msg_type_string);\n\t\t\t\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Server-to-client message %s received from client\", msg_type_string);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\trpcapd_log(LOGPRIO_INFO, \"The client sent a server-to-client message of type %u\", header.type);\n\t\t\t\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Server-to-client message of type %u received from client\", header.type);\n\t\t\t\t}\n\t\t\t\tif (rpcap_senderror(pars.sockctrl, header.ver,\n\t\t\t\t    PCAP_ERR_WRONGMSG, errmsgbuf, errbuf) == -1)\n\t\t\t\t{\n\t\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\t// Discard the rest of the message.\n\t\t\t\tif (rpcapd_discard(pars.sockctrl, plen) == -1)\n\t\t\t\t{\n\t\t\t\t\t// Fatal error.\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tgoto end;\n\n\t\t\tdefault:\n\t\t\t\t//\n\t\t\t\t// Unknown message type.\n\t\t\t\t//\n\t\t\t\trpcapd_log(LOGPRIO_INFO, \"The client sent a message of type %u\", header.type);\n\t\t\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Unknown message type %u\", header.type);\n\t\t\t\tif (rpcap_senderror(pars.sockctrl, header.ver,\n\t\t\t\t    PCAP_ERR_WRONGMSG, errbuf, errmsgbuf) == -1)\n\t\t\t\t{\n\t\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\t// Discard the rest of the message.\n\t\t\t\tif (rpcapd_discard(pars.sockctrl, plen) == -1)\n\t\t\t\t{\n\t\t\t\t\t// Fatal error.\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\t}\n\nend:\n\t// The service loop is finishing up.\n\t// If we have a capture session running, close it.\n\tif (session)\n\t{\n\t\tsession_close(session);\n\t\tfree(session);\n\t\tsession = NULL;\n\t}\n\n\tsock_close(sockctrl, NULL, 0);\n\n\t// Print message and return\n\trpcapd_log(LOGPRIO_DEBUG, \"I'm exiting from the child loop\");\n\n\treturn client_told_us_to_close;\n}\n\n/*\n * This handles the RPCAP_MSG_ERR message.\n */\nstatic int\ndaemon_msg_err(SOCKET sockctrl, uint32 plen)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE];\n\tchar remote_errbuf[PCAP_ERRBUF_SIZE];\n\n\tif (plen >= PCAP_ERRBUF_SIZE)\n\t{\n\t\t/*\n\t\t * Message is too long; just read as much of it as we\n\t\t * can into the buffer provided, and discard the rest.\n\t\t */\n\t\tif (sock_recv(sockctrl, remote_errbuf, PCAP_ERRBUF_SIZE - 1,\n\t\t    SOCK_RECEIVEALL_YES|SOCK_EOF_IS_ERROR, errbuf,\n\t\t    PCAP_ERRBUF_SIZE) == -1)\n\t\t{\n\t\t\t// Network error.\n\t\t\trpcapd_log(LOGPRIO_ERROR, \"Read from client failed: %s\", errbuf);\n\t\t\treturn -1;\n\t\t}\n\t\tif (rpcapd_discard(sockctrl, plen - (PCAP_ERRBUF_SIZE - 1)) == -1)\n\t\t{\n\t\t\t// Network error.\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * Null-terminate it.\n\t\t */\n\t\tremote_errbuf[PCAP_ERRBUF_SIZE - 1] = '\\0';\n\t}\n\telse if (plen == 0)\n\t{\n\t\t/* Empty error string. */\n\t\tremote_errbuf[0] = '\\0';\n\t}\n\telse\n\t{\n\t\tif (sock_recv(sockctrl, remote_errbuf, plen,\n\t\t    SOCK_RECEIVEALL_YES|SOCK_EOF_IS_ERROR, errbuf,\n\t\t    PCAP_ERRBUF_SIZE) == -1)\n\t\t{\n\t\t\t// Network error.\n\t\t\trpcapd_log(LOGPRIO_ERROR, \"Read from client failed: %s\", errbuf);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * Null-terminate it.\n\t\t */\n\t\tremote_errbuf[plen] = '\\0';\n\t}\n\t// Log the message\n\trpcapd_log(LOGPRIO_ERROR, \"Error from client: %s\", remote_errbuf);\n\treturn 0;\n}\n\n/*\n * This handles the RPCAP_MSG_AUTH_REQ message.\n * It checks if the authentication credentials supplied by the user are valid.\n *\n * This function is called if the daemon receives a RPCAP_MSG_AUTH_REQ\n * message in its authentication loop.  It reads the body of the\n * authentication message from the network and checks whether the\n * credentials are valid.\n *\n * \\param sockctrl: the socket for the control connection.\n *\n * \\param nullAuthAllowed: '1' if the NULL authentication is allowed.\n *\n * \\param errbuf: a user-allocated buffer in which the error message\n * (if one) has to be written.  It must be at least PCAP_ERRBUF_SIZE\n * bytes long.\n *\n * \\return '0' if everything is fine, '-1' if an unrecoverable error occurred,\n * or '-2' if the authentication failed.  For errors, an error message is\n * returned in the 'errbuf' variable; this gives a message for the\n * unrecoverable error or for the authentication failure.\n */\nstatic int\ndaemon_msg_auth_req(struct daemon_slpars *pars, uint32 plen)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE];\t\t// buffer for network errors\n\tchar errmsgbuf[PCAP_ERRBUF_SIZE];\t// buffer for errors to send to the client\n\tint status;\n\tstruct rpcap_auth auth;\t\t\t// RPCAP authentication header\n\tchar sendbuf[RPCAP_NETBUF_SIZE];\t// temporary buffer in which data to be sent is buffered\n\tint sendbufidx = 0;\t\t\t// index which keeps the number of bytes currently buffered\n\tstruct rpcap_authreply *authreply;\t// authentication reply message\n\n\tstatus = rpcapd_recv(pars->sockctrl, (char *) &auth, sizeof(struct rpcap_auth), &plen, errmsgbuf);\n\tif (status == -1)\n\t{\n\t\treturn -1;\n\t}\n\tif (status == -2)\n\t{\n\t\tgoto error;\n\t}\n\n\tswitch (ntohs(auth.type))\n\t{\n\t\tcase RPCAP_RMTAUTH_NULL:\n\t\t{\n\t\t\tif (!pars->nullAuthAllowed)\n\t\t\t{\n\t\t\t\t// Send the client an error reply.\n\t\t\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"Authentication failed; NULL authentication not permitted.\");\n\t\t\t\tif (rpcap_senderror(pars->sockctrl, 0,\n\t\t\t\t    PCAP_ERR_AUTH_FAILED, errmsgbuf, errbuf) == -1)\n\t\t\t\t{\n\t\t\t\t\t// That failed; log a message and give up.\n\t\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tgoto error_noreply;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase RPCAP_RMTAUTH_PWD:\n\t\t{\n\t\t\tchar *username, *passwd;\n\t\t\tuint32 usernamelen, passwdlen;\n\n\t\t\tusernamelen = ntohs(auth.slen1);\n\t\t\tusername = (char *) malloc (usernamelen + 1);\n\t\t\tif (username == NULL)\n\t\t\t{\n\t\t\t\tpcap_fmt_errmsg_for_errno(errmsgbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno, \"malloc() failed\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tstatus = rpcapd_recv(pars->sockctrl, username, usernamelen, &plen, errmsgbuf);\n\t\t\tif (status == -1)\n\t\t\t{\n\t\t\t\tfree(username);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (status == -2)\n\t\t\t{\n\t\t\t\tfree(username);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tusername[usernamelen] = '\\0';\n\n\t\t\tpasswdlen = ntohs(auth.slen2);\n\t\t\tpasswd = (char *) malloc (passwdlen + 1);\n\t\t\tif (passwd == NULL)\n\t\t\t{\n\t\t\t\tpcap_fmt_errmsg_for_errno(errmsgbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno, \"malloc() failed\");\n\t\t\t\tfree(username);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tstatus = rpcapd_recv(pars->sockctrl, passwd, passwdlen, &plen, errmsgbuf);\n\t\t\tif (status == -1)\n\t\t\t{\n\t\t\t\tfree(username);\n\t\t\t\tfree(passwd);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (status == -2)\n\t\t\t{\n\t\t\t\tfree(username);\n\t\t\t\tfree(passwd);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tpasswd[passwdlen] = '\\0';\n\n\t\t\tif (daemon_AuthUserPwd(username, passwd, errmsgbuf))\n\t\t\t{\n\t\t\t\t//\n\t\t\t\t// Authentication failed.  Let the client\n\t\t\t\t// know.\n\t\t\t\t//\n\t\t\t\tfree(username);\n\t\t\t\tfree(passwd);\n\t\t\t\tif (rpcap_senderror(pars->sockctrl, 0,\n\t\t\t\t    PCAP_ERR_AUTH_FAILED, errmsgbuf, errbuf) == -1)\n\t\t\t\t{\n\t\t\t\t\t// That failed; log a message and give up.\n\t\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\t//\n\t\t\t\t// Suspend for 1 second, so that they can't\n\t\t\t\t// hammer us with repeated tries with an\n\t\t\t\t// attack such as a dictionary attack.\n\t\t\t\t//\n\t\t\t\t// WARNING: this delay is inserted only\n\t\t\t\t// at this point; if the client closes the\n\t\t\t\t// connection and reconnects, the suspension\n\t\t\t\t// time does not have any effect.\n\t\t\t\t//\n\t\t\t\tsleep_secs(RPCAP_SUSPEND_WRONGAUTH);\n\t\t\t\tgoto error_noreply;\n\t\t\t}\n\n\t\t\tfree(username);\n\t\t\tfree(passwd);\n\t\t\tbreak;\n\t\t\t}\n\n\t\tdefault:\n\t\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"Authentication type not recognized.\");\n\t\t\tif (rpcap_senderror(pars->sockctrl, 0,\n\t\t\t    PCAP_ERR_AUTH_TYPE_NOTSUP, errmsgbuf, errbuf) == -1)\n\t\t\t{\n\t\t\t\t// That failed; log a message and give up.\n\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tgoto error_noreply;\n\t}\n\n\t// The authentication succeeded; let the client know.\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL, &sendbufidx,\n\t    RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\trpcap_createhdr((struct rpcap_header *) sendbuf, 0,\n\t    RPCAP_MSG_AUTH_REPLY, 0, sizeof(struct rpcap_authreply));\n\n\tauthreply = (struct rpcap_authreply *) &sendbuf[sendbufidx];\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_authreply), NULL, &sendbufidx,\n\t    RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\t//\n\t// Indicate to our peer what versions we support.\n\t//\n\tmemset(authreply, 0, sizeof(struct rpcap_authreply));\n\tauthreply->minvers = RPCAP_MIN_VERSION;\n\tauthreply->maxvers = RPCAP_MAX_VERSION;\n\n\t// Send the reply.\n\tif (sock_send(pars->sockctrl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t{\n\t\t// That failed; log a messsage and give up.\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\n\t// Check if all the data has been read; if not, discard the data in excess\n\tif (rpcapd_discard(pars->sockctrl, plen) == -1)\n\t{\n\t\treturn -1;\n\t}\n\n\treturn 0;\n\nerror:\n\tif (rpcap_senderror(pars->sockctrl, 0, PCAP_ERR_AUTH, errmsgbuf,\n\t    errbuf) == -1)\n\t{\n\t\t// That failed; log a message and give up.\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\nerror_noreply:\n\t// Check if all the data has been read; if not, discard the data in excess\n\tif (rpcapd_discard(pars->sockctrl, plen) == -1)\n\t{\n\t\treturn -1;\n\t}\n\n\treturn -2;\n}\n\nstatic int\ndaemon_AuthUserPwd(char *username, char *password, char *errbuf)\n{\n#ifdef _WIN32\n\t/*\n\t * Warning: the user which launches the process must have the\n\t * SE_TCB_NAME right.\n\t * This corresponds to have the \"Act as part of the Operating System\"\n\t * turned on (administrative tools, local security settings, local\n\t * policies, user right assignment)\n\t * However, it seems to me that if you run it as a service, this\n\t * right should be provided by default.\n\t *\n\t * XXX - hopefully, this returns errors such as ERROR_LOGON_FAILURE,\n\t * which merely indicates that the user name or password is\n\t * incorrect, not whether it's the user name or the password\n\t * that's incorrect, so a client that's trying to brute-force\n\t * accounts doesn't know whether it's the user name or the\n\t * password that's incorrect, so it doesn't know whether to\n\t * stop trying to log in with a given user name and move on\n\t * to another user name.\n\t */\n\tDWORD error;\n\tHANDLE Token;\n\tchar errmsgbuf[PCAP_ERRBUF_SIZE];\t// buffer for errors to log\n\n\tif (LogonUser(username, \".\", password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &Token) == 0)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed\");\n\t\terror = GetLastError();\n\t\tif (error != ERROR_LOGON_FAILURE)\n\t\t{\n\t\t\t// Some error other than an authentication error;\n\t\t\t// log it.\n\t\t\tpcap_fmt_errmsg_for_win32_err(errmsgbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, error, \"LogonUser() failed\");\n\t\t\trpcapd_log(LOGPRIO_ERROR, \"%s\", errmsgbuf);\n\t\t}\t\t\t    \n\t\treturn -1;\n\t}\n\n\t// This call should change the current thread to the selected user.\n\t// I didn't test it.\n\tif (ImpersonateLoggedOnUser(Token) == 0)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed\");\n\t\tpcap_fmt_errmsg_for_win32_err(errmsgbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"ImpersonateLoggedOnUser() failed\");\n\t\trpcapd_log(LOGPRIO_ERROR, \"%s\", errmsgbuf);\n\t\tCloseHandle(Token);\n\t\treturn -1;\n\t}\n\n\tCloseHandle(Token);\n\treturn 0;\n\n#else\n\t/*\n\t * See\n\t *\n\t *\thttp://www.unixpapa.com/incnote/passwd.html\n\t *\n\t * We use the Solaris/Linux shadow password authentication if\n\t * we have getspnam(), otherwise we just do traditional\n\t * authentication, which, on some platforms, might work, even\n\t * with shadow passwords, if we're running as root.  Traditional\n\t * authenticaion won't work if we're not running as root, as\n\t * I think these days all UN*Xes either won't return the password\n\t * at all with getpwnam() or will only do so if you're root.\n\t *\n\t * XXX - perhaps what we *should* be using is PAM, if we have\n\t * it.  That might hide all the details of username/password\n\t * authentication, whether it's done with a visible-to-root-\n\t * only password database or some other authentication mechanism,\n\t * behind its API.\n\t */\n\tint error;\n\tstruct passwd *user;\n\tchar *user_password;\n#ifdef HAVE_GETSPNAM\n\tstruct spwd *usersp;\n#endif\n\tchar *crypt_password;\n\n\t// This call is needed to get the uid\n\tif ((user = getpwnam(username)) == NULL)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed\");\n\t\treturn -1;\n\t}\n\n#ifdef HAVE_GETSPNAM\n\t// This call is needed to get the password; otherwise 'x' is returned\n\tif ((usersp = getspnam(username)) == NULL)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed\");\n\t\treturn -1;\n\t}\n\tuser_password = usersp->sp_pwdp;\n#else\n\t/*\n\t * XXX - what about other platforms?\n\t * The unixpapa.com page claims this Just Works on *BSD if you're\n\t * running as root - it's from 2000, so it doesn't indicate whether\n\t * macOS (which didn't come out until 2001, under the name Mac OS\n\t * X) behaves like the *BSDs or not, and might also work on AIX.\n\t * HP-UX does something else.\n\t *\n\t * Again, hopefully PAM hides all that.\n\t */\n\tuser_password = user->pw_passwd;\n#endif\n\n\t//\n\t// The Single UNIX Specification says that if crypt() fails it\n\t// sets errno, but some implementatons that haven't been run\n\t// through the SUS test suite might not do so.\n\t//\n\terrno = 0;\n\tcrypt_password = crypt(password, user_password);\n\tif (crypt_password == NULL)\n\t{\n\t\terror = errno;\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed\");\n\t\tif (error == 0)\n\t\t{\n\t\t\t// It didn't set errno.\n\t\t\trpcapd_log(LOGPRIO_ERROR, \"crypt() failed\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\trpcapd_log(LOGPRIO_ERROR, \"crypt() failed: %s\",\n\t\t\t    strerror(error));\n\t\t}\n\t\treturn -1;\n\t}\n\tif (strcmp(user_password, crypt_password) != 0)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed\");\n\t\treturn -1;\n\t}\n\n\tif (setuid(user->pw_uid))\n\t{\n\t\terror = errno;\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    error, \"setuid\");\n\t\trpcapd_log(LOGPRIO_ERROR, \"setuid() failed: %s\",\n\t\t    strerror(error));\n\t\treturn -1;\n\t}\n\n/*\tif (setgid(user->pw_gid))\n\t{\n\t\terror = errno;\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"setgid\");\n\t\trpcapd_log(LOGPRIO_ERROR, \"setgid() failed: %s\",\n\t\t    strerror(error));\n\t\treturn -1;\n\t}\n*/\n\treturn 0;\n\n#endif\n\n}\n\nstatic int\ndaemon_msg_findallif_req(uint8 ver, struct daemon_slpars *pars, uint32 plen)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE];\t\t// buffer for network errors\n\tchar errmsgbuf[PCAP_ERRBUF_SIZE];\t// buffer for errors to send to the client\n\tchar sendbuf[RPCAP_NETBUF_SIZE];\t// temporary buffer in which data to be sent is buffered\n\tint sendbufidx = 0;\t\t\t// index which keeps the number of bytes currently buffered\n\tpcap_if_t *alldevs = NULL;\t\t// pointer to the header of the interface chain\n\tpcap_if_t *d;\t\t\t\t// temp pointer needed to scan the interface chain\n\tstruct pcap_addr *address;\t\t// pcap structure that keeps a network address of an interface\n\tstruct rpcap_findalldevs_if *findalldevs_if;// rpcap structure that packet all the data of an interface together\n\tuint16 nif = 0;\t\t\t\t// counts the number of interface listed\n\n\t// Discard the rest of the message; there shouldn't be any payload.\n\tif (rpcapd_discard(pars->sockctrl, plen) == -1)\n\t{\n\t\t// Network error.\n\t\treturn -1;\n\t}\n\n\t// Retrieve the device list\n\tif (pcap_findalldevs(&alldevs, errmsgbuf) == -1)\n\t\tgoto error;\n\n\tif (alldevs == NULL)\n\t{\n\t\tif (rpcap_senderror(pars->sockctrl, ver, PCAP_ERR_NOREMOTEIF,\n\t\t\t\"No interfaces found! Make sure libpcap/WinPcap is properly installed\"\n\t\t\t\" and you have the right to access to the remote device.\",\n\t\t\terrbuf) == -1)\n\t\t{\n\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t// checks the number of interfaces and it computes the total length of the payload\n\tfor (d = alldevs; d != NULL; d = d->next)\n\t{\n\t\tnif++;\n\n\t\tif (d->description)\n\t\t\tplen+= strlen(d->description);\n\t\tif (d->name)\n\t\t\tplen+= strlen(d->name);\n\n\t\tplen+= sizeof(struct rpcap_findalldevs_if);\n\n\t\tfor (address = d->addresses; address != NULL; address = address->next)\n\t\t{\n\t\t\t/*\n\t\t\t * Send only IPv4 and IPv6 addresses over the wire.\n\t\t\t */\n\t\t\tswitch (address->addr->sa_family)\n\t\t\t{\n\t\t\tcase AF_INET:\n#ifdef AF_INET6\n\t\t\tcase AF_INET6:\n#endif\n\t\t\t\tplen+= (sizeof(struct rpcap_sockaddr) * 4);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// RPCAP findalldevs command\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL,\n\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf,\n\t    PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\trpcap_createhdr((struct rpcap_header *) sendbuf, ver,\n\t    RPCAP_MSG_FINDALLIF_REPLY, nif, plen);\n\n\t// send the interface list\n\tfor (d = alldevs; d != NULL; d = d->next)\n\t{\n\t\tuint16 lname, ldescr;\n\n\t\tfindalldevs_if = (struct rpcap_findalldevs_if *) &sendbuf[sendbufidx];\n\n\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_findalldevs_if), NULL,\n\t\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\tgoto error;\n\n\t\tmemset(findalldevs_if, 0, sizeof(struct rpcap_findalldevs_if));\n\n\t\tif (d->description) ldescr = (short) strlen(d->description);\n\t\telse ldescr = 0;\n\t\tif (d->name) lname = (short) strlen(d->name);\n\t\telse lname = 0;\n\n\t\tfindalldevs_if->desclen = htons(ldescr);\n\t\tfindalldevs_if->namelen = htons(lname);\n\t\tfindalldevs_if->flags = htonl(d->flags);\n\n\t\tfor (address = d->addresses; address != NULL; address = address->next)\n\t\t{\n\t\t\t/*\n\t\t\t * Send only IPv4 and IPv6 addresses over the wire.\n\t\t\t */\n\t\t\tswitch (address->addr->sa_family)\n\t\t\t{\n\t\t\tcase AF_INET:\n#ifdef AF_INET6\n\t\t\tcase AF_INET6:\n#endif\n\t\t\t\tfindalldevs_if->naddr++;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfindalldevs_if->naddr = htons(findalldevs_if->naddr);\n\n\t\tif (sock_bufferize(d->name, lname, sendbuf, &sendbufidx,\n\t\t    RPCAP_NETBUF_SIZE, SOCKBUF_BUFFERIZE, errmsgbuf,\n\t\t    PCAP_ERRBUF_SIZE) == -1)\n\t\t\tgoto error;\n\n\t\tif (sock_bufferize(d->description, ldescr, sendbuf, &sendbufidx,\n\t\t    RPCAP_NETBUF_SIZE, SOCKBUF_BUFFERIZE, errmsgbuf,\n\t\t    PCAP_ERRBUF_SIZE) == -1)\n\t\t\tgoto error;\n\n\t\t// send all addresses\n\t\tfor (address = d->addresses; address != NULL; address = address->next)\n\t\t{\n\t\t\tstruct rpcap_sockaddr *sockaddr;\n\n\t\t\t/*\n\t\t\t * Send only IPv4 and IPv6 addresses over the wire.\n\t\t\t */\n\t\t\tswitch (address->addr->sa_family)\n\t\t\t{\n\t\t\tcase AF_INET:\n#ifdef AF_INET6\n\t\t\tcase AF_INET6:\n#endif\n\t\t\t\tsockaddr = (struct rpcap_sockaddr *) &sendbuf[sendbufidx];\n\t\t\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_sockaddr), NULL,\n\t\t\t\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\t\t\tgoto error;\n\t\t\t\tdaemon_seraddr((struct sockaddr_storage *) address->addr, sockaddr);\n\n\t\t\t\tsockaddr = (struct rpcap_sockaddr *) &sendbuf[sendbufidx];\n\t\t\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_sockaddr), NULL,\n\t\t\t\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\t\t\tgoto error;\n\t\t\t\tdaemon_seraddr((struct sockaddr_storage *) address->netmask, sockaddr);\n\n\t\t\t\tsockaddr = (struct rpcap_sockaddr *) &sendbuf[sendbufidx];\n\t\t\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_sockaddr), NULL,\n\t\t\t\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\t\t\tgoto error;\n\t\t\t\tdaemon_seraddr((struct sockaddr_storage *) address->broadaddr, sockaddr);\n\n\t\t\t\tsockaddr = (struct rpcap_sockaddr *) &sendbuf[sendbufidx];\n\t\t\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_sockaddr), NULL,\n\t\t\t\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\t\t\tgoto error;\n\t\t\t\tdaemon_seraddr((struct sockaddr_storage *) address->dstaddr, sockaddr);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// We no longer need the device list. Free it.\n\tpcap_freealldevs(alldevs);\n\n\t// Send a final command that says \"now send it!\"\n\tif (sock_send(pars->sockctrl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n\nerror:\n\tif (alldevs)\n\t\tpcap_freealldevs(alldevs);\n\n\tif (rpcap_senderror(pars->sockctrl, ver, PCAP_ERR_FINDALLIF,\n\t    errmsgbuf, errbuf) == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/*\n\t\\param plen: the length of the current message (needed in order to be able\n\tto discard excess data in the message, if present)\n*/\nstatic int\ndaemon_msg_open_req(uint8 ver, struct daemon_slpars *pars, uint32 plen,\n    char *source, size_t sourcelen)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE];\t\t// buffer for network errors\n\tchar errmsgbuf[PCAP_ERRBUF_SIZE];\t// buffer for errors to send to the client\n\tpcap_t *fp;\t\t\t\t// pcap_t main variable\n\tint nread;\n\tchar sendbuf[RPCAP_NETBUF_SIZE];\t// temporary buffer in which data to be sent is buffered\n\tint sendbufidx = 0;\t\t\t// index which keeps the number of bytes currently buffered\n\tstruct rpcap_openreply *openreply;\t// open reply message\n\n\tif (plen > sourcelen - 1)\n\t{\n\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Source string too long\");\n\t\tgoto error;\n\t}\n\n\tnread = sock_recv(pars->sockctrl, source, plen,\n\t    SOCK_RECEIVEALL_YES|SOCK_EOF_IS_ERROR, errbuf, PCAP_ERRBUF_SIZE);\n\tif (nread == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Read from client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\tsource[nread] = '\\0';\n\tplen -= nread;\n\n\t// Is this a URL rather than a device?\n\t// If so, reject it.\n\tif (is_url(source))\n\t{\n\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Source string refers to a remote device\");\n\t\tgoto error;\n\t}\n\n\t// Open the selected device\n\t// This is a fake open, since we do that only to get the needed parameters, then we close the device again\n\tif ((fp = pcap_open_live(source,\n\t\t\t1500 /* fake snaplen */,\n\t\t\t0 /* no promis */,\n\t\t\t1000 /* fake timeout */,\n\t\t\terrmsgbuf)) == NULL)\n\t\tgoto error;\n\n\t// Now, I can send a RPCAP open reply message\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL, &sendbufidx,\n\t    RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\trpcap_createhdr((struct rpcap_header *) sendbuf, ver,\n\t    RPCAP_MSG_OPEN_REPLY, 0, sizeof(struct rpcap_openreply));\n\n\topenreply = (struct rpcap_openreply *) &sendbuf[sendbufidx];\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_openreply), NULL, &sendbufidx,\n\t    RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\tmemset(openreply, 0, sizeof(struct rpcap_openreply));\n\topenreply->linktype = htonl(pcap_datalink(fp));\n\topenreply->tzoff = 0; /* This is always 0 for live captures */\n\n\t// We're done with the pcap_t.\n\tpcap_close(fp);\n\n\t// Send the reply.\n\tif (sock_send(pars->sockctrl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\treturn 0;\n\nerror:\n\tif (rpcap_senderror(pars->sockctrl, ver, PCAP_ERR_OPEN,\n\t    errmsgbuf, errbuf) == -1)\n\t{\n\t\t// That failed; log a message and give up.\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\n\t// Check if all the data has been read; if not, discard the data in excess\n\tif (rpcapd_discard(pars->sockctrl, plen) == -1)\n\t{\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/*\n\t\\param plen: the length of the current message (needed in order to be able\n\tto discard excess data in the message, if present)\n*/\nstatic int\ndaemon_msg_startcap_req(uint8 ver, struct daemon_slpars *pars, uint32 plen,\n    char *source, struct session **sessionp,\n    struct rpcap_sampling *samp_param _U_)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE];\t\t// buffer for network errors\n\tchar errmsgbuf[PCAP_ERRBUF_SIZE];\t// buffer for errors to send to the client\n\tchar portdata[PCAP_BUF_SIZE];\t\t// temp variable needed to derive the data port\n\tchar peerhost[PCAP_BUF_SIZE];\t\t// temp variable needed to derive the host name of our peer\n\tstruct session *session = NULL;\t\t// saves state of session\n\tint status;\n\tchar sendbuf[RPCAP_NETBUF_SIZE];\t// temporary buffer in which data to be sent is buffered\n\tint sendbufidx = 0;\t\t\t// index which keeps the number of bytes currently buffered\n\n\t// socket-related variables\n\tstruct addrinfo hints;\t\t\t// temp, needed to open a socket connection\n\tstruct addrinfo *addrinfo;\t\t// temp, needed to open a socket connection\n\tstruct sockaddr_storage saddr;\t\t// temp, needed to retrieve the network data port chosen on the local machine\n\tsocklen_t saddrlen;\t\t\t// temp, needed to retrieve the network data port chosen on the local machine\n\tint ret;\t\t\t\t// return value from functions\n\n\t// RPCAP-related variables\n\tstruct rpcap_startcapreq startcapreq;\t\t// start capture request message\n\tstruct rpcap_startcapreply *startcapreply;\t// start capture reply message\n\tint serveropen_dp;\t\t\t\t\t\t\t// keeps who is going to open the data connection\n\n\taddrinfo = NULL;\n\n\tstatus = rpcapd_recv(pars->sockctrl, (char *) &startcapreq,\n\t    sizeof(struct rpcap_startcapreq), &plen, errmsgbuf);\n\tif (status == -1)\n\t{\n\t\tgoto fatal_error;\n\t}\n\tif (status == -2)\n\t{\n\t\tgoto error;\n\t}\n\n\tstartcapreq.flags = ntohs(startcapreq.flags);\n\n\t// Create a session structure\n\tsession = malloc(sizeof(struct session));\n\tif (session == NULL)\n\t{\n\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Can't allocate session structure\");\n\t\tgoto error;\n\t}\n\n\tsession->sockdata = INVALID_SOCKET;\n\t// We don't have a thread yet.\n\tsession->have_thread = 0;\n\t//\n\t// We *shouldn't* have to initialize the thread indicator\n\t// itself, because the compiler *should* realize that we\n\t// only use this if have_thread isn't 0, but we *do* have\n\t// to do it, because not all compilers *do* realize that.\n\t//\n\t// There is no \"invalid thread handle\" value for a UN*X\n\t// pthread_t, so we just zero it out.\n\t//\n#ifdef _WIN32\n\tsession->thread = INVALID_HANDLE_VALUE;\n#else\n\tmemset(&session->thread, 0, sizeof(session->thread));\n#endif\n\n\t// Open the selected device\n\tif ((session->fp = pcap_open_live(source,\n\t\t\tntohl(startcapreq.snaplen),\n\t\t\t(startcapreq.flags & RPCAP_STARTCAPREQ_FLAG_PROMISC) ? 1 : 0 /* local device, other flags not needed */,\n\t\t\tntohl(startcapreq.read_timeout),\n\t\t\terrmsgbuf)) == NULL)\n\t\tgoto error;\n\n#if 0\n\t// Apply sampling parameters\n\tfp->rmt_samp.method = samp_param->method;\n\tfp->rmt_samp.value = samp_param->value;\n#endif\n\n\t/*\n\tWe're in active mode if:\n\t- we're using TCP, and the user wants us to be in active mode\n\t- we're using UDP\n\t*/\n\tserveropen_dp = (startcapreq.flags & RPCAP_STARTCAPREQ_FLAG_SERVEROPEN) || (startcapreq.flags & RPCAP_STARTCAPREQ_FLAG_DGRAM) || pars->isactive;\n\n\t/*\n\tGets the sockaddr structure referred to the other peer in the ctrl connection\n\n\tWe need that because:\n\t- if we're in passive mode, we need to know the address family we want to use\n\t(the same used for the ctrl socket)\n\t- if we're in active mode, we need to know the network address of the other host\n\twe want to connect to\n\t*/\n\tsaddrlen = sizeof(struct sockaddr_storage);\n\tif (getpeername(pars->sockctrl, (struct sockaddr *) &saddr, &saddrlen) == -1)\n\t{\n\t\tsock_geterror(\"getpeername()\", errmsgbuf, PCAP_ERRBUF_SIZE);\n\t\tgoto error;\n\t}\n\n\tmemset(&hints, 0, sizeof(struct addrinfo));\n\thints.ai_socktype = (startcapreq.flags & RPCAP_STARTCAPREQ_FLAG_DGRAM) ? SOCK_DGRAM : SOCK_STREAM;\n\thints.ai_family = saddr.ss_family;\n\n\t// Now we have to create a new socket to send packets\n\tif (serveropen_dp)\t\t// Data connection is opened by the server toward the client\n\t{\n\t\tpcap_snprintf(portdata, sizeof portdata, \"%d\", ntohs(startcapreq.portdata));\n\n\t\t// Get the name of the other peer (needed to connect to that specific network address)\n\t\tif (getnameinfo((struct sockaddr *) &saddr, saddrlen, peerhost,\n\t\t\t\tsizeof(peerhost), NULL, 0, NI_NUMERICHOST))\n\t\t{\n\t\t\tsock_geterror(\"getnameinfo()\", errmsgbuf, PCAP_ERRBUF_SIZE);\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (sock_initaddress(peerhost, portdata, &hints, &addrinfo, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\tgoto error;\n\n\t\tif ((session->sockdata = sock_open(addrinfo, SOCKOPEN_CLIENT, 0, errmsgbuf, PCAP_ERRBUF_SIZE)) == INVALID_SOCKET)\n\t\t\tgoto error;\n\t}\n\telse\t\t// Data connection is opened by the client toward the server\n\t{\n\t\thints.ai_flags = AI_PASSIVE;\n\n\t\t// Let's the server socket pick up a free network port for us\n\t\tif (sock_initaddress(NULL, \"0\", &hints, &addrinfo, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\tgoto error;\n\n\t\tif ((session->sockdata = sock_open(addrinfo, SOCKOPEN_SERVER, 1 /* max 1 connection in queue */, errmsgbuf, PCAP_ERRBUF_SIZE)) == INVALID_SOCKET)\n\t\t\tgoto error;\n\n\t\t// get the complete sockaddr structure used in the data connection\n\t\tsaddrlen = sizeof(struct sockaddr_storage);\n\t\tif (getsockname(session->sockdata, (struct sockaddr *) &saddr, &saddrlen) == -1)\n\t\t{\n\t\t\tsock_geterror(\"getsockname()\", errmsgbuf, PCAP_ERRBUF_SIZE);\n\t\t\tgoto error;\n\t\t}\n\n\t\t// Get the local port the system picked up\n\t\tif (getnameinfo((struct sockaddr *) &saddr, saddrlen, NULL,\n\t\t\t\t0, portdata, sizeof(portdata), NI_NUMERICSERV))\n\t\t{\n\t\t\tsock_geterror(\"getnameinfo()\", errmsgbuf, PCAP_ERRBUF_SIZE);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t// addrinfo is no longer used\n\tfreeaddrinfo(addrinfo);\n\taddrinfo = NULL;\n\n\t// Needed to send an error on the ctrl connection\n\tsession->sockctrl = pars->sockctrl;\n\tsession->protocol_version = ver;\n\n\t// Now I can set the filter\n\tret = daemon_unpackapplyfilter(pars->sockctrl, session, &plen, errmsgbuf);\n\tif (ret == -1)\n\t{\n\t\t// Fatal error.  A message has been logged; just give up.\n\t\tgoto fatal_error;\n\t}\n\tif (ret == -2)\n\t{\n\t\t// Non-fatal error.  Send an error message to the client.\n\t\tgoto error;\n\t}\n\n\t// Now, I can send a RPCAP start capture reply message\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL, &sendbufidx,\n\t    RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\trpcap_createhdr((struct rpcap_header *) sendbuf, ver,\n\t    RPCAP_MSG_STARTCAP_REPLY, 0, sizeof(struct rpcap_startcapreply));\n\n\tstartcapreply = (struct rpcap_startcapreply *) &sendbuf[sendbufidx];\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_startcapreply), NULL,\n\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\tmemset(startcapreply, 0, sizeof(struct rpcap_startcapreply));\n\tstartcapreply->bufsize = htonl(pcap_bufsize(session->fp));\n\n\tif (!serveropen_dp)\n\t{\n\t\tunsigned short port = (unsigned short)strtoul(portdata,NULL,10);\n\t\tstartcapreply->portdata = htons(port);\n\t}\n\n\tif (sock_send(pars->sockctrl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t{\n\t\t// That failed; log a message and give up.\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\tgoto fatal_error;\n\t}\n\n\tif (!serveropen_dp)\n\t{\n\t\tSOCKET socktemp;\t// We need another socket, since we're going to accept() a connection\n\n\t\t// Connection creation\n\t\tsaddrlen = sizeof(struct sockaddr_storage);\n\n\t\tsocktemp = accept(session->sockdata, (struct sockaddr *) &saddr, &saddrlen);\n\n\t\tif (socktemp == INVALID_SOCKET)\n\t\t{\n\t\t\tsock_geterror(\"accept()\", errbuf, PCAP_ERRBUF_SIZE);\n\t\t\trpcapd_log(LOGPRIO_ERROR, \"Accept of data connection failed: %s\",\n\t\t\t    errbuf);\n\t\t\tgoto error;\n\t\t}\n\n\t\t// Now that I accepted the connection, the server socket is no longer needed\n\t\tsock_close(session->sockdata, NULL, 0);\n\t\tsession->sockdata = socktemp;\n\t}\n\n\t// Now we have to create a new thread to receive packets\n#ifdef _WIN32\n\tsession->thread = (HANDLE)_beginthreadex(NULL, 0, daemon_thrdatamain,\n\t    (void *) session, 0, NULL);\n\tif (session->thread == 0)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Error creating the data thread\");\n\t\tgoto error;\n\t}\n#else\n\tret = pthread_create(&session->thread, NULL, daemon_thrdatamain,\n\t    (void *) session);\n\tif (ret != 0)\n\t{\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    ret, \"Error creating the data thread\");\n\t\tgoto error;\n\t}\n#endif\n\tsession->have_thread = 1;\n\n\t// Check if all the data has been read; if not, discard the data in excess\n\tif (rpcapd_discard(pars->sockctrl, plen) == -1)\n\t\tgoto fatal_error;\n\n\t*sessionp = session;\n\treturn 0;\n\nerror:\n\t//\n\t// Not a fatal error, so send the client an error message and\n\t// keep serving client requests.\n\t//\n\t*sessionp = NULL;\n\n\tif (addrinfo)\n\t\tfreeaddrinfo(addrinfo);\n\n\tif (session)\n\t{\n\t\tsession_close(session);\n\t\tfree(session);\n\t}\n\n\tif (rpcap_senderror(pars->sockctrl, ver, PCAP_ERR_STARTCAPTURE,\n\t    errmsgbuf, errbuf) == -1)\n\t{\n\t\t// That failed; log a message and give up.\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\n\t// Check if all the data has been read; if not, discard the data in excess\n\tif (rpcapd_discard(pars->sockctrl, plen) == -1)\n\t{\n\t\t// Network error.\n\t\treturn -1;\n\t}\n\n\treturn 0;\n\nfatal_error:\n\t//\n\t// Fatal network error, so don't try to communicate with\n\t// the client, just give up.\n\t//\n\t*sessionp = NULL;\n\n\tif (session)\n\t{\n\t\tsession_close(session);\n\t\tfree(session);\n\t}\n\n\treturn -1;\n}\n\nstatic int\ndaemon_msg_endcap_req(uint8 ver, struct daemon_slpars *pars,\n    struct session *session)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE];\t\t// buffer for network errors\n\tstruct rpcap_header header;\n\n\tsession_close(session);\n\n\trpcap_createhdr(&header, ver, RPCAP_MSG_ENDCAP_REPLY, 0, 0);\n\n\tif (sock_send(pars->sockctrl, (char *) &header, sizeof(struct rpcap_header), errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t{\n\t\t// That failed; log a message and give up.\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int\ndaemon_unpackapplyfilter(SOCKET sockctrl, struct session *session, uint32 *plenp, char *errmsgbuf)\n{\n\tint status;\n\tstruct rpcap_filter filter;\n\tstruct rpcap_filterbpf_insn insn;\n\tstruct bpf_insn *bf_insn;\n\tstruct bpf_program bf_prog;\n\tunsigned int i;\n\n\tstatus = rpcapd_recv(sockctrl, (char *) &filter,\n\t    sizeof(struct rpcap_filter), plenp, errmsgbuf);\n\tif (status == -1)\n\t{\n\t\treturn -1;\n\t}\n\tif (status == -2)\n\t{\n\t\treturn -2;\n\t}\n\n\tbf_prog.bf_len = ntohl(filter.nitems);\n\n\tif (ntohs(filter.filtertype) != RPCAP_UPDATEFILTER_BPF)\n\t{\n\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Only BPF/NPF filters are currently supported\");\n\t\treturn -2;\n\t}\n\n\tbf_insn = (struct bpf_insn *) malloc (sizeof(struct bpf_insn) * bf_prog.bf_len);\n\tif (bf_insn == NULL)\n\t{\n\t\tpcap_fmt_errmsg_for_errno(errmsgbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc() failed\");\n\t\treturn -2;\n\t}\n\n\tbf_prog.bf_insns = bf_insn;\n\n\tfor (i = 0; i < bf_prog.bf_len; i++)\n\t{\n\t\tstatus = rpcapd_recv(sockctrl, (char *) &insn,\n\t\t    sizeof(struct rpcap_filterbpf_insn), plenp, errmsgbuf);\n\t\tif (status == -1)\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\t\tif (status == -2)\n\t\t{\n\t\t\treturn -2;\n\t\t}\n\n\t\tbf_insn->code = ntohs(insn.code);\n\t\tbf_insn->jf = insn.jf;\n\t\tbf_insn->jt = insn.jt;\n\t\tbf_insn->k = ntohl(insn.k);\n\n\t\tbf_insn++;\n\t}\n\n\tif (bpf_validate(bf_prog.bf_insns, bf_prog.bf_len) == 0)\n\t{\n\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"The filter contains bogus instructions\");\n\t\treturn -2;\n\t}\n\n\tif (pcap_setfilter(session->fp, &bf_prog))\n\t{\n\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"RPCAP error: %s\", pcap_geterr(session->fp));\n\t\treturn -2;\n\t}\n\n\treturn 0;\n}\n\nstatic int\ndaemon_msg_updatefilter_req(uint8 ver, struct daemon_slpars *pars,\n    struct session *session, uint32 plen)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE];\n\tchar errmsgbuf[PCAP_ERRBUF_SIZE];\t// buffer for errors to send to the client\n\tint ret;\t\t\t\t// status of daemon_unpackapplyfilter()\n\tstruct rpcap_header header;\t\t// keeps the answer to the updatefilter command\n\n\tret = daemon_unpackapplyfilter(pars->sockctrl, session, &plen, errmsgbuf);\n\tif (ret == -1)\n\t{\n\t\t// Fatal error.  A message has been logged; just give up.\n\t\treturn -1;\n\t}\n\tif (ret == -2)\n\t{\n\t\t// Non-fatal error.  Send an error reply to the client.\n\t\tgoto error;\n\t}\n\n\t// Check if all the data has been read; if not, discard the data in excess\n\tif (rpcapd_discard(pars->sockctrl, plen) == -1)\n\t{\n\t\t// Network error.\n\t\treturn -1;\n\t}\n\n\t// A response is needed, otherwise the other host does not know that everything went well\n\trpcap_createhdr(&header, ver, RPCAP_MSG_UPDATEFILTER_REPLY, 0, 0);\n\n\tif (sock_send(pars->sockctrl, (char *) &header, sizeof (struct rpcap_header), pcap_geterr(session->fp), PCAP_ERRBUF_SIZE))\n\t{\n\t\t// That failed; log a messsage and give up.\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n\nerror:\n\tif (rpcapd_discard(pars->sockctrl, plen) == -1)\n\t{\n\t\treturn -1;\n\t}\n\trpcap_senderror(pars->sockctrl, ver, PCAP_ERR_UPDATEFILTER,\n\t    errmsgbuf, NULL);\n\n\treturn 0;\n}\n\n/*!\n\t\\brief Received the sampling parameters from remote host and it stores in the pcap_t structure.\n*/\nstatic int\ndaemon_msg_setsampling_req(uint8 ver, struct daemon_slpars *pars, uint32 plen,\n    struct rpcap_sampling *samp_param)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE];\t\t// buffer for network errors\n\tchar errmsgbuf[PCAP_ERRBUF_SIZE];\n\tstruct rpcap_header header;\n\tstruct rpcap_sampling rpcap_samp;\n\tint status;\n\n\tstatus = rpcapd_recv(pars->sockctrl, (char *) &rpcap_samp, sizeof(struct rpcap_sampling), &plen, errmsgbuf);\n\tif (status == -1)\n\t{\n\t\treturn -1;\n\t}\n\tif (status == -2)\n\t{\n\t\tgoto error;\n\t}\n\n\t// Save these settings in the pcap_t\n\tsamp_param->method = rpcap_samp.method;\n\tsamp_param->value = ntohl(rpcap_samp.value);\n\n\t// A response is needed, otherwise the other host does not know that everything went well\n\trpcap_createhdr(&header, ver, RPCAP_MSG_SETSAMPLING_REPLY, 0, 0);\n\n\tif (sock_send(pars->sockctrl, (char *) &header, sizeof (struct rpcap_header), errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t{\n\t\t// That failed; log a messsage and give up.\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\n\tif (rpcapd_discard(pars->sockctrl, plen) == -1)\n\t{\n\t\treturn -1;\n\t}\n\n\treturn 0;\n\nerror:\n\tif (rpcap_senderror(pars->sockctrl, ver, PCAP_ERR_SETSAMPLING,\n\t    errmsgbuf, errbuf) == -1)\n\t{\n\t\t// That failed; log a message and give up.\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\n\t// Check if all the data has been read; if not, discard the data in excess\n\tif (rpcapd_discard(pars->sockctrl, plen) == -1)\n\t{\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int\ndaemon_msg_stats_req(uint8 ver, struct daemon_slpars *pars,\n    struct session *session, uint32 plen, struct pcap_stat *stats,\n    unsigned int svrcapt)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE];\t\t// buffer for network errors\n\tchar errmsgbuf[PCAP_ERRBUF_SIZE];\t// buffer for errors to send to the client\n\tchar sendbuf[RPCAP_NETBUF_SIZE];\t// temporary buffer in which data to be sent is buffered\n\tint sendbufidx = 0;\t\t\t// index which keeps the number of bytes currently buffered\n\tstruct rpcap_stats *netstats;\t\t// statistics sent on the network\n\n\t// Checks that the header does not contain other data; if so, discard it\n\tif (rpcapd_discard(pars->sockctrl, plen) == -1)\n\t{\n\t\t// Network error.\n\t\treturn -1;\n\t}\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL,\n\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\trpcap_createhdr((struct rpcap_header *) sendbuf, ver,\n\t    RPCAP_MSG_STATS_REPLY, 0, (uint16) sizeof(struct rpcap_stats));\n\n\tnetstats = (struct rpcap_stats *) &sendbuf[sendbufidx];\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_stats), NULL,\n\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\tif (session && session->fp)\n\t{\n\t\tif (pcap_stats(session->fp, stats) == -1)\n\t\t{\n\t\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"%s\", pcap_geterr(session->fp));\n\t\t\tgoto error;\n\t\t}\n\n\t\tnetstats->ifdrop = htonl(stats->ps_ifdrop);\n\t\tnetstats->ifrecv = htonl(stats->ps_recv);\n\t\tnetstats->krnldrop = htonl(stats->ps_drop);\n\t\tnetstats->svrcapt = htonl(session->TotCapt);\n\t}\n\telse\n\t{\n\t\t// We have to keep compatibility with old applications,\n\t\t// which ask for statistics also when the capture has\n\t\t// already stopped.\n\t\tnetstats->ifdrop = htonl(stats->ps_ifdrop);\n\t\tnetstats->ifrecv = htonl(stats->ps_recv);\n\t\tnetstats->krnldrop = htonl(stats->ps_drop);\n\t\tnetstats->svrcapt = htonl(svrcapt);\n\t}\n\n\t// Send the packet\n\tif (sock_send(pars->sockctrl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n\nerror:\n\trpcap_senderror(pars->sockctrl, ver, PCAP_ERR_GETSTATS,\n\t    errmsgbuf, NULL);\n\treturn 0;\n}\n\n#ifdef _WIN32\nstatic unsigned __stdcall\n#else\nstatic void *\n#endif\ndaemon_thrdatamain(void *ptr)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE + 1];\t// error buffer\n\tstruct session *session;\t\t// pointer to the struct session for this session\n\tint retval;\t\t\t\t\t\t\t// general variable used to keep the return value of other functions\n\tstruct rpcap_pkthdr *net_pkt_header;// header of the packet\n\tstruct pcap_pkthdr *pkt_header;\t\t// pointer to the buffer that contains the header of the current packet\n\tu_char *pkt_data;\t\t\t\t\t// pointer to the buffer that contains the current packet\n\tsize_t sendbufsize;\t\t\t// size for the send buffer\n\tchar *sendbuf;\t\t\t\t\t\t// temporary buffer in which data to be sent is buffered\n\tint sendbufidx;\t\t\t\t\t\t// index which keeps the number of bytes currently buffered\n\tint status;\n#ifndef _WIN32\n\tsigset_t sigusr1;\t\t\t// signal set with just SIGUSR1\n#endif\n\n\tsession = (struct session *) ptr;\n\n\tsession->TotCapt = 0;\t\t\t// counter which is incremented each time a packet is received\n\n\t// Initialize errbuf\n\tmemset(errbuf, 0, sizeof(errbuf));\n\n\t//\n\t// We need a buffer large enough to hold a buffer large enough\n\t// for a maximum-size packet for this pcap_t.\n\t//\n\tif (pcap_snapshot(session->fp) < 0)\n\t{\n\t\t//\n\t\t// The snapshot length is negative.\n\t\t// This \"should not happen\".\n\t\t//\n\t\trpcapd_log(LOGPRIO_ERROR,\n\t\t    \"Unable to allocate the buffer for this child thread: snapshot length of %d is negative\",\n\t\t        pcap_snapshot(session->fp));\n\t\tsendbuf = NULL;\t// we can't allocate a buffer, so nothing to free\n\t\tgoto error;\n\t}\n\t//\n\t// size_t is unsigned, and the result of pcap_snapshot() is signed;\n\t// on no platform that we support is int larger than size_t.\n\t// This means that, unless the extra information we prepend to\n\t// a maximum-sized packet is impossibly large, the sum of the\n\t// snapshot length and the size of that extra information will\n\t// fit in a size_t.\n\t//\n\t// So we don't need to make sure that sendbufsize will overflow.\n\t//\n\tsendbufsize = sizeof(struct rpcap_header) + sizeof(struct rpcap_pkthdr) + pcap_snapshot(session->fp);\n\tsendbuf = (char *) malloc (sendbufsize);\n\tif (sendbuf == NULL)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR,\n\t\t    \"Unable to allocate the buffer for this child thread\");\n\t\tgoto error;\n\t}\n\n#ifndef _WIN32\n\t//\n\t// Set the signal set to include just SIGUSR1, and block that\n\t// signal; we only want it unblocked when we're reading\n\t// packets - we dn't want any other system calls, such as\n\t// ones being used to send to the client or to log messages,\n\t// to be interrupted.\n\t//\n\tsigemptyset(&sigusr1);\n\tsigaddset(&sigusr1, SIGUSR1);\n\tpthread_sigmask(SIG_BLOCK, &sigusr1, NULL);\n#endif\n\n\t// Retrieve the packets\n\tfor (;;)\n\t{\n#ifndef _WIN32\n\t\t//\n\t\t// Unblock SIGUSR1 while we might be waiting for packets.\n\t\t//\n\t\tpthread_sigmask(SIG_UNBLOCK, &sigusr1, NULL);\n#endif\n\t\tretval = pcap_next_ex(session->fp, &pkt_header, (const u_char **) &pkt_data);\t// cast to avoid a compiler warning\n#ifndef _WIN32\n\t\t//\n\t\t// Now block it again.\n\t\t//\n\t\tpthread_sigmask(SIG_BLOCK, &sigusr1, NULL);\n#endif\n\t\tif (retval < 0)\n\t\t\tbreak;\t\t// error\n\t\tif (retval == 0)\t// Read timeout elapsed\n\t\t\tcontinue;\n\n\t\tsendbufidx = 0;\n\n\t\t// Bufferize the general header\n\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL,\n\t\t    &sendbufidx, sendbufsize, SOCKBUF_CHECKONLY, errbuf,\n\t\t    PCAP_ERRBUF_SIZE) == -1)\n\t\t{\n\t\t\trpcapd_log(LOGPRIO_ERROR,\n\t\t\t    \"sock_bufferize() error sending packet message: %s\",\n\t\t\t    errbuf);\n\t\t\tgoto error;\n\t\t}\n\n\t\trpcap_createhdr((struct rpcap_header *) sendbuf,\n\t\t    session->protocol_version, RPCAP_MSG_PACKET, 0,\n\t\t    (uint16) (sizeof(struct rpcap_pkthdr) + pkt_header->caplen));\n\n\t\tnet_pkt_header = (struct rpcap_pkthdr *) &sendbuf[sendbufidx];\n\n\t\t// Bufferize the pkt header\n\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_pkthdr), NULL,\n\t\t    &sendbufidx, sendbufsize, SOCKBUF_CHECKONLY, errbuf,\n\t\t    PCAP_ERRBUF_SIZE) == -1)\n\t\t{\n\t\t\trpcapd_log(LOGPRIO_ERROR,\n\t\t\t    \"sock_bufferize() error sending packet message: %s\",\n\t\t\t    errbuf);\n\t\t\tgoto error;\n\t\t}\n\n\t\tnet_pkt_header->caplen = htonl(pkt_header->caplen);\n\t\tnet_pkt_header->len = htonl(pkt_header->len);\n\t\tnet_pkt_header->npkt = htonl(++(session->TotCapt));\n\t\tnet_pkt_header->timestamp_sec = htonl(pkt_header->ts.tv_sec);\n\t\tnet_pkt_header->timestamp_usec = htonl(pkt_header->ts.tv_usec);\n\n\t\t// Bufferize the pkt data\n\t\tif (sock_bufferize((char *) pkt_data, pkt_header->caplen,\n\t\t    sendbuf, &sendbufidx, sendbufsize, SOCKBUF_BUFFERIZE,\n\t\t    errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t{\n\t\t\trpcapd_log(LOGPRIO_ERROR,\n\t\t\t    \"sock_bufferize() error sending packet message: %s\",\n\t\t\t    errbuf);\n\t\t\tgoto error;\n\t\t}\n\n\t\t// Send the packet\n\t\t// If the client dropped the connection, don't report an\n\t\t// error, just quit.\n\t\tstatus = sock_send(session->sockdata, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE);\n\t\tif (status < 0)\n\t\t{\n\t\t\tif (status == -1)\n\t\t\t{\n\t\t\t\t//\n\t\t\t\t// Error other than \"client closed the\n\t\t\t\t// connection out from under us\"; report\n\t\t\t\t// it.\n\t\t\t\t//\n\t\t\t\trpcapd_log(LOGPRIO_ERROR,\n\t\t\t\t    \"Send of packet to client failed: %s\",\n\t\t\t\t    errbuf);\n\t\t\t}\n\n\t\t\t//\n\t\t\t// Give up in either case.\n\t\t\t//\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (retval < 0 && retval != PCAP_ERROR_BREAK)\n\t{\n\t\t//\n\t\t// Failed with an error other than \"we were told to break\n\t\t// out of the loop\".\n\t\t//\n\t\t// The latter just means that the client told us to stop\n\t\t// capturing, so there's no error to report.\n\t\t//\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Error reading the packets: %s\", pcap_geterr(session->fp));\n\t\trpcap_senderror(session->sockctrl, session->protocol_version,\n\t\t    PCAP_ERR_READEX, errbuf, NULL);\n\t}\n\nerror:\n\t//\n\t// The main thread will clean up the session structure.\n\t//\n\tfree(sendbuf);\n\n\treturn 0;\n}\n\n#ifndef _WIN32\n//\n// Do-nothing handler for SIGUSR1; the sole purpose of SIGUSR1 is to\n// interrupt the data thread if it's blocked in a system call waiting\n// for packets to arrive.\n//\nstatic void noop_handler(int sign _U_)\n{\n}\n#endif\n\n/*!\n\t\\brief It serializes a network address.\n\n\tIt accepts a 'sockaddr_storage' structure as input, and it converts it appropriately into a format\n\tthat can be used to be sent on the network. Basically, it applies all the hton()\n\tconversion required to the input variable.\n\n\t\\param sockaddrin a 'sockaddr_storage' pointer to the variable that has to be\n\tserialized. This variable can be both a 'sockaddr_in' and 'sockaddr_in6'.\n\n\t\\param sockaddrout an 'rpcap_sockaddr' pointer to the variable that will contain\n\tthe serialized data. This variable has to be allocated by the user.\n\n\t\\warning This function supports only AF_INET and AF_INET6 address families.\n*/\nstatic void\ndaemon_seraddr(struct sockaddr_storage *sockaddrin, struct rpcap_sockaddr *sockaddrout)\n{\n\tmemset(sockaddrout, 0, sizeof(struct sockaddr_storage));\n\n\t// There can be the case in which the sockaddrin is not available\n\tif (sockaddrin == NULL) return;\n\n\t// Warning: we support only AF_INET and AF_INET6\n\tswitch (sockaddrin->ss_family)\n\t{\n\tcase AF_INET:\n\t\t{\n\t\tstruct sockaddr_in *sockaddrin_ipv4;\n\t\tstruct rpcap_sockaddr_in *sockaddrout_ipv4;\n\n\t\tsockaddrin_ipv4 = (struct sockaddr_in *) sockaddrin;\n\t\tsockaddrout_ipv4 = (struct rpcap_sockaddr_in *) sockaddrout;\n\t\tsockaddrout_ipv4->family = htons(RPCAP_AF_INET);\n\t\tsockaddrout_ipv4->port = htons(sockaddrin_ipv4->sin_port);\n\t\tmemcpy(&sockaddrout_ipv4->addr, &sockaddrin_ipv4->sin_addr, sizeof(sockaddrout_ipv4->addr));\n\t\tmemset(sockaddrout_ipv4->zero, 0, sizeof(sockaddrout_ipv4->zero));\n\t\tbreak;\n\t\t}\n\n#ifdef AF_INET6\n\tcase AF_INET6:\n\t\t{\n\t\tstruct sockaddr_in6 *sockaddrin_ipv6;\n\t\tstruct rpcap_sockaddr_in6 *sockaddrout_ipv6;\n\n\t\tsockaddrin_ipv6 = (struct sockaddr_in6 *) sockaddrin;\n\t\tsockaddrout_ipv6 = (struct rpcap_sockaddr_in6 *) sockaddrout;\n\t\tsockaddrout_ipv6->family = htons(RPCAP_AF_INET6);\n\t\tsockaddrout_ipv6->port = htons(sockaddrin_ipv6->sin6_port);\n\t\tsockaddrout_ipv6->flowinfo = htonl(sockaddrin_ipv6->sin6_flowinfo);\n\t\tmemcpy(&sockaddrout_ipv6->addr, &sockaddrin_ipv6->sin6_addr, sizeof(sockaddrout_ipv6->addr));\n\t\tsockaddrout_ipv6->scope_id = htonl(sockaddrin_ipv6->sin6_scope_id);\n\t\tbreak;\n\t\t}\n#endif\n\t}\n}\n\n\n/*!\n\t\\brief Suspends a thread for secs seconds.\n*/\nvoid sleep_secs(int secs)\n{\n#ifdef _WIN32\n\tSleep(secs*1000);\n#else\n\tunsigned secs_remaining;\n\n\tif (secs <= 0)\n\t\treturn;\n\tsecs_remaining = secs;\n\twhile (secs_remaining != 0)\n\t\tsecs_remaining = sleep(secs_remaining);\n#endif\n}\n\n/*\n * Read the header of a message.\n */\nstatic int\nrpcapd_recv_msg_header(SOCKET sock, struct rpcap_header *headerp)\n{\n\tint nread;\n\tchar errbuf[PCAP_ERRBUF_SIZE];\t\t// buffer for network errors\n\n\tnread = sock_recv(sock, (char *) headerp, sizeof(struct rpcap_header),\n\t    SOCK_RECEIVEALL_YES|SOCK_EOF_ISNT_ERROR, errbuf, PCAP_ERRBUF_SIZE);\n\tif (nread == -1)\n\t{\n\t\t// Network error.\n\t\trpcapd_log(LOGPRIO_ERROR, \"Read from client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\tif (nread == 0)\n\t{\n\t\t// Immediate EOF; that's treated like a close message.\n\t\treturn -2;\n\t}\n\theaderp->plen = ntohl(headerp->plen);\n\treturn 0;\n}\n\n/*\n * Read data from a message.\n * If we're trying to read more data that remains, puts an error\n * message into errmsgbuf and returns -2.  Otherwise, tries to read\n * the data and, if that succeeds, subtracts the amount read from\n * the number of bytes of data that remains.\n * Returns 0 on success, logs a message and returns -1 on a network\n * error.\n */\nstatic int\nrpcapd_recv(SOCKET sock, char *buffer, size_t toread, uint32 *plen, char *errmsgbuf)\n{\n\tint nread;\n\tchar errbuf[PCAP_ERRBUF_SIZE];\t\t// buffer for network errors\n\n\tif (toread > *plen)\n\t{\n\t\t// Tell the client and continue.\n\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Message payload is too short\");\n\t\treturn -2;\n\t}\n\tnread = sock_recv(sock, buffer, toread,\n\t    SOCK_RECEIVEALL_YES|SOCK_EOF_IS_ERROR, errbuf, PCAP_ERRBUF_SIZE);\n\tif (nread == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Read from client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\t*plen -= nread;\n\treturn 0;\n}\n\n/*\n * Discard data from a connection.\n * Mostly used to discard wrong-sized messages.\n * Returns 0 on success, logs a message and returns -1 on a network\n * error.\n */\nstatic int\nrpcapd_discard(SOCKET sock, uint32 len)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE + 1];\t// keeps the error string, prior to be printed\n\n\tif (len != 0)\n\t{\n\t\tif (sock_discard(sock, len, errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t{\n\t\t\t// Network error.\n\t\t\trpcapd_log(LOGPRIO_ERROR, \"Read from client failed: %s\", errbuf);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n//\n// Shut down any packet-capture thread associated with the session,\n// close the SSL handle for the data socket if we have one, close\n// the data socket if we have one, and close the underlying packet\n// capture handle if we have one.\n//\n// We do not, of course, touch the controlling socket that's also\n// copied into the session, as the service loop might still use it.\n//\nstatic void session_close(struct session *session)\n{\n\tif (session->have_thread)\n\t{\n\t\t//\n\t\t// Tell the data connection thread main capture loop to\n\t\t// break out of that loop.\n\t\t//\n\t\t// This may be sufficient to wake up a blocked thread,\n\t\t// but it's not guaranteed to be sufficient.\n\t\t//\n\t\tpcap_breakloop(session->fp);\n\n#ifdef _WIN32\n\t\t//\n\t\t// Set the event on which a read would block, so that,\n\t\t// if it's currently blocked waiting for packets to\n\t\t// arrive, it'll wake up, so it can see the \"break\n\t\t// out of the loop\" indication.  (pcap_breakloop()\n\t\t// might do this, but older versions don't.  Setting\n\t\t// it twice should, at worst, cause an extra wakeup,\n\t\t// which shouldn't be a problem.)\n\t\t//\n\t\t// XXX - what about modules other than NPF?\n\t\t//\n\t\tSetEvent(pcap_getevent(session->fp));\n\n\t\t//\n\t\t// Wait for the thread to exit, so we don't close\n\t\t// sockets out from under it.\n\t\t//\n\t\t// XXX - have a timeout, so we don't wait forever?\n\t\t//\n\t\tWaitForSingleObject(session->thread, INFINITE);\n\n\t\t//\n\t\t// Release the thread handle, as we're done with\n\t\t// it.\n\t\t//\n\t\tCloseHandle(session->thread);\n\t\tsession->have_thread = 0;\n\t\tsession->thread = INVALID_HANDLE_VALUE;\n#else\n\t\t//\n\t\t// Send a SIGUSR1 signal to the thread, so that, if\n\t\t// it's currently blocked waiting for packets to arrive,\n\t\t// it'll wake up (we've turned off SA_RESTART for\n\t\t// SIGUSR1, so that the system call in which it's blocked\n\t\t// should return EINTR rather than restarting).\n\t\t//\n\t\tpthread_kill(session->thread, SIGUSR1);\n\n\t\t//\n\t\t// Wait for the thread to exit, so we don't close\n\t\t// sockets out from under it.\n\t\t//\n\t\t// XXX - have a timeout, so we don't wait forever?\n\t\t//\n\t\tpthread_join(session->thread, NULL);\n\t\tsession->have_thread = 0;\n\t\tmemset(&session->thread, 0, sizeof(session->thread));\n#endif\n\t}\n\n\tif (session->sockdata != INVALID_SOCKET)\n\t{\n\t\tsock_close(session->sockdata, NULL, 0);\n\t\tsession->sockdata = INVALID_SOCKET;\n\t}\n\n\tif (session->fp)\n\t{\n\t\tpcap_close(session->fp);\n\t\tsession->fp = NULL;\n\t}\n}\n\n// Check whether a capture source string is a URL or not.\n// This includes URLs that refer to a local device; a scheme, followed\n// by ://, followed by *another* scheme and ://, is just silly, and\n// anybody who supplies that will get an error.\n//\nstatic int\nis_url(const char *source)\n{\n\tchar *colonp;\n\n\t/*\n\t * RFC 3986 says:\n\t *\n\t *   URI         = scheme \":\" hier-part [ \"?\" query ] [ \"#\" fragment ]\n\t *\n\t *   hier-part   = \"//\" authority path-abempty\n\t *               / path-absolute\n\t *               / path-rootless\n\t *               / path-empty\n\t *\n\t *   authority   = [ userinfo \"@\" ] host [ \":\" port ]\n\t *\n\t *   userinfo    = *( unreserved / pct-encoded / sub-delims / \":\" )\n\t *\n\t * Step 1: look for the \":\" at the end of the scheme.\n\t * A colon in the source is *NOT* sufficient to indicate that\n\t * this is a URL, as interface names on some platforms might\n\t * include colons (e.g., I think some Solaris interfaces\n\t * might).\n\t */\n\tcolonp = strchr(source, ':');\n\tif (colonp == NULL)\n\t{\n\t\t/*\n\t\t * The source is the device to open.  It's not a URL.\n\t\t */\n\t\treturn (0);\n\t}\n\n\t/*\n\t * All schemes must have \"//\" after them, i.e. we only support\n\t * hier-part   = \"//\" authority path-abempty, not\n\t * hier-part   = path-absolute\n\t * hier-part   = path-rootless\n\t * hier-part   = path-empty\n\t *\n\t * We need that in order to distinguish between a local device\n\t * name that happens to contain a colon and a URI.\n\t */\n\tif (strncmp(colonp + 1, \"//\", 2) != 0)\n\t{\n\t\t/*\n\t\t * The source is the device to open.  It's not a URL.\n\t\t */\n\t\treturn (0);\n\t}\n\n\t/*\n\t * It's a URL.\n\t */\n\treturn (1);\n}\n"], "filenames": ["rpcapd/daemon.c"], "buggy_code_start_loc": [157], "buggy_code_end_loc": [2649], "fixing_code_start_loc": [158], "fixing_code_end_loc": [2720], "type": "CWE-918", "message": "rpcapd/daemon.c in libpcap before 1.9.1 allows SSRF because a URL may be provided as a capture source.", "other": {"cve": {"id": "CVE-2019-15164", "sourceIdentifier": "cve@mitre.org", "published": "2019-10-03T19:15:09.410", "lastModified": "2019-10-27T03:15:12.503", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "rpcapd/daemon.c in libpcap before 1.9.1 allows SSRF because a URL may be provided as a capture source."}, {"lang": "es", "value": "El archivo rpcapd/daemon.c en libpcap versiones anteriores a 1.9.1, permite un ataque de tipo SSRF porque puede ser proporcionada una URL como una fuente de captura."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-918"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tcpdump:libpcap:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.9.1", "matchCriteriaId": "11619557-69F9-455F-ADAA-86AC753BBC9C"}]}]}], "references": [{"url": "http://seclists.org/fulldisclosure/2019/Dec/26", "source": "cve@mitre.org"}, {"url": "https://github.com/the-tcpdump-group/libpcap/blob/libpcap-1.9/CHANGES", "source": "cve@mitre.org", "tags": ["Product", "Release Notes"]}, {"url": "https://github.com/the-tcpdump-group/libpcap/commit/33834cb2a4d035b52aa2a26742f832a112e90a0a", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/5P5K3DQ4TFSZBDB3XN4CZNJNQ3UIF3D3/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/GBIEKWLNIR62KZ5GA7EDXZS52HU6OE5F/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/UZTIPUWABYUE5KQOLCKAW65AUUSB7QO6/", "source": "cve@mitre.org"}, {"url": "https://seclists.org/bugtraq/2019/Dec/23", "source": "cve@mitre.org"}, {"url": "https://support.apple.com/kb/HT210785", "source": "cve@mitre.org"}, {"url": "https://support.apple.com/kb/HT210788", "source": "cve@mitre.org"}, {"url": "https://support.apple.com/kb/HT210789", "source": "cve@mitre.org"}, {"url": "https://support.apple.com/kb/HT210790", "source": "cve@mitre.org"}, {"url": "https://www.oracle.com/security-alerts/cpuapr2020.html", "source": "cve@mitre.org"}, {"url": "https://www.tcpdump.org/public-cve-list.txt", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/the-tcpdump-group/libpcap/commit/33834cb2a4d035b52aa2a26742f832a112e90a0a"}}