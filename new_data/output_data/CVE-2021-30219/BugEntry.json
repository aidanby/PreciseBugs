{"buggy_code": ["#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"env.h\"\n#include \"graph.h\"\n#include \"parse.h\"\n#include \"scan.h\"\n#include \"util.h\"\n\nstruct parseoptions parseopts;\nstatic struct node **deftarg;\nstatic size_t ndeftarg;\n\nvoid\nparseinit(void)\n{\n\tfree(deftarg);\n\tdeftarg = NULL;\n\tndeftarg = 0;\n}\n\nstatic void\nparselet(struct scanner *s, struct evalstring **val)\n{\n\tscanchar(s, '=');\n\t*val = scanstring(s, false);\n\tscannewline(s);\n}\n\nstatic void\nparserule(struct scanner *s, struct environment *env)\n{\n\tstruct rule *r;\n\tchar *var;\n\tstruct evalstring *val;\n\tbool hascommand = false, hasrspfile = false, hasrspcontent = false;\n\n\tr = mkrule(scanname(s));\n\tscannewline(s);\n\twhile (scanindent(s)) {\n\t\tvar = scanname(s);\n\t\tparselet(s, &val);\n\t\truleaddvar(r, var, val);\n\t\tif (strcmp(var, \"command\") == 0)\n\t\t\thascommand = true;\n\t\telse if (strcmp(var, \"rspfile\") == 0)\n\t\t\thasrspfile = true;\n\t\telse if (strcmp(var, \"rspfile_content\") == 0)\n\t\t\thasrspcontent = true;\n\t}\n\tif (!hascommand)\n\t\tfatal(\"rule '%s' has no command\", r->name);\n\tif (hasrspfile != hasrspcontent)\n\t\tfatal(\"rule '%s' has rspfile and no rspfile_content or vice versa\", r->name);\n\tenvaddrule(env, r);\n}\n\nstatic void\npushstr(struct evalstring ***end, struct evalstring *str)\n{\n\tstr->next = NULL;\n\t**end = str;\n\t*end = &str->next;\n}\n\nstatic void\nparseedge(struct scanner *s, struct environment *env)\n{\n\tstruct edge *e;\n\tstruct evalstring *out, *in, *str, **end;\n\tchar *name;\n\tstruct string *val;\n\tstruct node *n;\n\tsize_t i;\n\tint p;\n\n\te = mkedge(env);\n\n\tfor (out = NULL, end = &out; (str = scanstring(s, true)); ++e->nout)\n\t\tpushstr(&end, str);\n\te->outimpidx = e->nout;\n\tif (scanpipe(s, 1)) {\n\t\tfor (; (str = scanstring(s, true)); ++e->nout)\n\t\t\tpushstr(&end, str);\n\t}\n\tif (e->nout == 0)\n\t\tscanerror(s, \"expected output path\");\n\tscanchar(s, ':');\n\tname = scanname(s);\n\te->rule = envrule(env, name);\n\tif (!e->rule)\n\t\tfatal(\"undefined rule '%s'\", name);\n\tfree(name);\n\tfor (in = NULL, end = &in; (str = scanstring(s, true)); ++e->nin)\n\t\tpushstr(&end, str);\n\te->inimpidx = e->nin;\n\tp = scanpipe(s, 1 | 2);\n\tif (p == 1) {\n\t\tfor (; (str = scanstring(s, true)); ++e->nin)\n\t\t\tpushstr(&end, str);\n\t\tp = scanpipe(s, 2);\n\t}\n\te->inorderidx = e->nin;\n\tif (p == 2) {\n\t\tfor (; (str = scanstring(s, true)); ++e->nin)\n\t\t\tpushstr(&end, str);\n\t}\n\tscannewline(s);\n\twhile (scanindent(s)) {\n\t\tname = scanname(s);\n\t\tparselet(s, &str);\n\t\tval = enveval(env, str);\n\t\tenvaddvar(e->env, name, val);\n\t}\n\n\te->out = xreallocarray(NULL, e->nout, sizeof(e->out[0]));\n\tfor (i = 0; i < e->nout; out = str) {\n\t\tstr = out->next;\n\t\tval = enveval(e->env, out);\n\t\tcanonpath(val);\n\t\tn = mknode(val);\n\t\tif (n->gen) {\n\t\t\tif (!parseopts.dupbuildwarn)\n\t\t\t\tfatal(\"multiple rules generate '%s'\", n->path->s);\n\t\t\twarn(\"multiple rules generate '%s'\", n->path->s);\n\t\t\t--e->nout;\n\t\t\tif (i < e->outimpidx)\n\t\t\t\t--e->outimpidx;\n\t\t} else {\n\t\t\tn->gen = e;\n\t\t\te->out[i] = n;\n\t\t\t++i;\n\t\t}\n\t}\n\n\te->in = xreallocarray(NULL, e->nin, sizeof(e->in[0]));\n\tfor (i = 0; i < e->nin; in = str, ++i) {\n\t\tstr = in->next;\n\t\tval = enveval(e->env, in);\n\t\tcanonpath(val);\n\t\tn = mknode(val);\n\t\te->in[i] = n;\n\t\tnodeuse(n, e);\n\t}\n\n\tval = edgevar(e, \"pool\", true);\n\tif (val)\n\t\te->pool = poolget(val->s);\n}\n\nstatic void\nparseinclude(struct scanner *s, struct environment *env, bool newscope)\n{\n\tstruct evalstring *str;\n\tstruct string *path;\n\n\tstr = scanstring(s, true);\n\tif (!str)\n\t\tscanerror(s, \"expected include path\");\n\tscannewline(s);\n\tpath = enveval(env, str);\n\n\tif (newscope)\n\t\tenv = mkenv(env);\n\tparse(path->s, env);\n\tfree(path);\n}\n\nstatic void\nparsedefault(struct scanner *s, struct environment *env)\n{\n\tstruct evalstring *targ, *str, **end;\n\tstruct string *path;\n\tstruct node *n;\n\tsize_t ntarg;\n\n\tfor (targ = NULL, ntarg = 0, end = &targ; (str = scanstring(s, true)); ++ntarg)\n\t\tpushstr(&end, str);\n\tdeftarg = xreallocarray(deftarg, ndeftarg + ntarg, sizeof(*deftarg));\n\tfor (; targ; targ = str) {\n\t\tstr = targ->next;\n\t\tpath = enveval(env, targ);\n\t\tcanonpath(path);\n\t\tn = nodeget(path->s, path->n);\n\t\tif (!n)\n\t\t\tfatal(\"unknown target '%s'\", path->s);\n\t\tfree(path);\n\t\tdeftarg[ndeftarg++] = n;\n\t}\n\tscannewline(s);\n}\n\nstatic void\nparsepool(struct scanner *s, struct environment *env)\n{\n\tstruct pool *p;\n\tstruct evalstring *val;\n\tstruct string *str;\n\tchar *var, *end;\n\n\tp = mkpool(scanname(s));\n\tscannewline(s);\n\twhile (scanindent(s)) {\n\t\tvar = scanname(s);\n\t\tparselet(s, &val);\n\t\tif (strcmp(var, \"depth\") == 0) {\n\t\t\tstr = enveval(env, val);\n\t\t\tp->maxjobs = strtol(str->s, &end, 10);\n\t\t\tif (*end)\n\t\t\t\tfatal(\"invalid pool depth '%s'\", str->s);\n\t\t\tfree(str);\n\t\t} else {\n\t\t\tfatal(\"unexpected pool variable '%s'\", var);\n\t\t}\n\t}\n\tif (!p->maxjobs)\n\t\tfatal(\"pool '%s' has no depth\", p->name);\n}\n\nstatic void\ncheckversion(const char *ver)\n{\n\tint major, minor = 0;\n\n\tif (sscanf(ver, \"%d.%d\", &major, &minor) < 1)\n\t\tfatal(\"invalid ninja_required_version\");\n\tif (major > ninjamajor || (major == ninjamajor && minor > ninjaminor))\n\t\tfatal(\"ninja_required_version %s is newer than %d.%d\", ver, ninjamajor, ninjaminor);\n}\n\nvoid\nparse(const char *name, struct environment *env)\n{\n\tstruct scanner s;\n\tchar *var;\n\tstruct string *val;\n\tstruct evalstring *str;\n\n\tscaninit(&s, name);\n\tfor (;;) {\n\t\tswitch (scankeyword(&s, &var)) {\n\t\tcase RULE:\n\t\t\tparserule(&s, env);\n\t\t\tbreak;\n\t\tcase BUILD:\n\t\t\tparseedge(&s, env);\n\t\t\tbreak;\n\t\tcase INCLUDE:\n\t\t\tparseinclude(&s, env, false);\n\t\t\tbreak;\n\t\tcase SUBNINJA:\n\t\t\tparseinclude(&s, env, true);\n\t\t\tbreak;\n\t\tcase DEFAULT:\n\t\t\tparsedefault(&s, env);\n\t\t\tbreak;\n\t\tcase POOL:\n\t\t\tparsepool(&s, env);\n\t\t\tbreak;\n\t\tcase VARIABLE:\n\t\t\tparselet(&s, &str);\n\t\t\tval = enveval(env, str);\n\t\t\tif (strcmp(var, \"ninja_required_version\") == 0)\n\t\t\t\tcheckversion(val->s);\n\t\t\tenvaddvar(env, var, val);\n\t\t\tbreak;\n\t\tcase EOF:\n\t\t\tscanclose(&s);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nvoid\ndefaultnodes(void fn(struct node *))\n{\n\tstruct edge *e;\n\tstruct node *n;\n\tsize_t i;\n\n\tif (ndeftarg > 0) {\n\t\tfor (i = 0; i < ndeftarg; ++i)\n\t\t\tfn(deftarg[i]);\n\t} else {\n\t\t/* by default build all nodes which are not used by any edges */\n\t\tfor (e = alledges; e; e = e->allnext) {\n\t\t\tfor (i = 0; i < e->nout; ++i) {\n\t\t\t\tn = e->out[i];\n\t\t\t\tif (n->nuse == 0)\n\t\t\t\t\tfn(n);\n\t\t\t}\n\t\t}\n\t}\n}\n"], "fixing_code": ["#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"env.h\"\n#include \"graph.h\"\n#include \"parse.h\"\n#include \"scan.h\"\n#include \"util.h\"\n\nstruct parseoptions parseopts;\nstatic struct node **deftarg;\nstatic size_t ndeftarg;\n\nvoid\nparseinit(void)\n{\n\tfree(deftarg);\n\tdeftarg = NULL;\n\tndeftarg = 0;\n}\n\nstatic void\nparselet(struct scanner *s, struct evalstring **val)\n{\n\tscanchar(s, '=');\n\t*val = scanstring(s, false);\n\tscannewline(s);\n}\n\nstatic void\nparserule(struct scanner *s, struct environment *env)\n{\n\tstruct rule *r;\n\tchar *var;\n\tstruct evalstring *val;\n\tbool hascommand = false, hasrspfile = false, hasrspcontent = false;\n\n\tr = mkrule(scanname(s));\n\tscannewline(s);\n\twhile (scanindent(s)) {\n\t\tvar = scanname(s);\n\t\tparselet(s, &val);\n\t\truleaddvar(r, var, val);\n\t\tif (!val)\n\t\t\tcontinue;\n\t\tif (strcmp(var, \"command\") == 0)\n\t\t\thascommand = true;\n\t\telse if (strcmp(var, \"rspfile\") == 0)\n\t\t\thasrspfile = true;\n\t\telse if (strcmp(var, \"rspfile_content\") == 0)\n\t\t\thasrspcontent = true;\n\t}\n\tif (!hascommand)\n\t\tfatal(\"rule '%s' has no command\", r->name);\n\tif (hasrspfile != hasrspcontent)\n\t\tfatal(\"rule '%s' has rspfile and no rspfile_content or vice versa\", r->name);\n\tenvaddrule(env, r);\n}\n\nstatic void\npushstr(struct evalstring ***end, struct evalstring *str)\n{\n\tstr->next = NULL;\n\t**end = str;\n\t*end = &str->next;\n}\n\nstatic void\nparseedge(struct scanner *s, struct environment *env)\n{\n\tstruct edge *e;\n\tstruct evalstring *out, *in, *str, **end;\n\tchar *name;\n\tstruct string *val;\n\tstruct node *n;\n\tsize_t i;\n\tint p;\n\n\te = mkedge(env);\n\n\tfor (out = NULL, end = &out; (str = scanstring(s, true)); ++e->nout)\n\t\tpushstr(&end, str);\n\te->outimpidx = e->nout;\n\tif (scanpipe(s, 1)) {\n\t\tfor (; (str = scanstring(s, true)); ++e->nout)\n\t\t\tpushstr(&end, str);\n\t}\n\tif (e->nout == 0)\n\t\tscanerror(s, \"expected output path\");\n\tscanchar(s, ':');\n\tname = scanname(s);\n\te->rule = envrule(env, name);\n\tif (!e->rule)\n\t\tfatal(\"undefined rule '%s'\", name);\n\tfree(name);\n\tfor (in = NULL, end = &in; (str = scanstring(s, true)); ++e->nin)\n\t\tpushstr(&end, str);\n\te->inimpidx = e->nin;\n\tp = scanpipe(s, 1 | 2);\n\tif (p == 1) {\n\t\tfor (; (str = scanstring(s, true)); ++e->nin)\n\t\t\tpushstr(&end, str);\n\t\tp = scanpipe(s, 2);\n\t}\n\te->inorderidx = e->nin;\n\tif (p == 2) {\n\t\tfor (; (str = scanstring(s, true)); ++e->nin)\n\t\t\tpushstr(&end, str);\n\t}\n\tscannewline(s);\n\twhile (scanindent(s)) {\n\t\tname = scanname(s);\n\t\tparselet(s, &str);\n\t\tval = enveval(env, str);\n\t\tenvaddvar(e->env, name, val);\n\t}\n\n\te->out = xreallocarray(NULL, e->nout, sizeof(e->out[0]));\n\tfor (i = 0; i < e->nout; out = str) {\n\t\tstr = out->next;\n\t\tval = enveval(e->env, out);\n\t\tcanonpath(val);\n\t\tn = mknode(val);\n\t\tif (n->gen) {\n\t\t\tif (!parseopts.dupbuildwarn)\n\t\t\t\tfatal(\"multiple rules generate '%s'\", n->path->s);\n\t\t\twarn(\"multiple rules generate '%s'\", n->path->s);\n\t\t\t--e->nout;\n\t\t\tif (i < e->outimpidx)\n\t\t\t\t--e->outimpidx;\n\t\t} else {\n\t\t\tn->gen = e;\n\t\t\te->out[i] = n;\n\t\t\t++i;\n\t\t}\n\t}\n\n\te->in = xreallocarray(NULL, e->nin, sizeof(e->in[0]));\n\tfor (i = 0; i < e->nin; in = str, ++i) {\n\t\tstr = in->next;\n\t\tval = enveval(e->env, in);\n\t\tcanonpath(val);\n\t\tn = mknode(val);\n\t\te->in[i] = n;\n\t\tnodeuse(n, e);\n\t}\n\n\tval = edgevar(e, \"pool\", true);\n\tif (val)\n\t\te->pool = poolget(val->s);\n}\n\nstatic void\nparseinclude(struct scanner *s, struct environment *env, bool newscope)\n{\n\tstruct evalstring *str;\n\tstruct string *path;\n\n\tstr = scanstring(s, true);\n\tif (!str)\n\t\tscanerror(s, \"expected include path\");\n\tscannewline(s);\n\tpath = enveval(env, str);\n\n\tif (newscope)\n\t\tenv = mkenv(env);\n\tparse(path->s, env);\n\tfree(path);\n}\n\nstatic void\nparsedefault(struct scanner *s, struct environment *env)\n{\n\tstruct evalstring *targ, *str, **end;\n\tstruct string *path;\n\tstruct node *n;\n\tsize_t ntarg;\n\n\tfor (targ = NULL, ntarg = 0, end = &targ; (str = scanstring(s, true)); ++ntarg)\n\t\tpushstr(&end, str);\n\tdeftarg = xreallocarray(deftarg, ndeftarg + ntarg, sizeof(*deftarg));\n\tfor (; targ; targ = str) {\n\t\tstr = targ->next;\n\t\tpath = enveval(env, targ);\n\t\tcanonpath(path);\n\t\tn = nodeget(path->s, path->n);\n\t\tif (!n)\n\t\t\tfatal(\"unknown target '%s'\", path->s);\n\t\tfree(path);\n\t\tdeftarg[ndeftarg++] = n;\n\t}\n\tscannewline(s);\n}\n\nstatic void\nparsepool(struct scanner *s, struct environment *env)\n{\n\tstruct pool *p;\n\tstruct evalstring *val;\n\tstruct string *str;\n\tchar *var, *end;\n\n\tp = mkpool(scanname(s));\n\tscannewline(s);\n\twhile (scanindent(s)) {\n\t\tvar = scanname(s);\n\t\tparselet(s, &val);\n\t\tif (strcmp(var, \"depth\") == 0) {\n\t\t\tstr = enveval(env, val);\n\t\t\tp->maxjobs = strtol(str->s, &end, 10);\n\t\t\tif (*end)\n\t\t\t\tfatal(\"invalid pool depth '%s'\", str->s);\n\t\t\tfree(str);\n\t\t} else {\n\t\t\tfatal(\"unexpected pool variable '%s'\", var);\n\t\t}\n\t}\n\tif (!p->maxjobs)\n\t\tfatal(\"pool '%s' has no depth\", p->name);\n}\n\nstatic void\ncheckversion(const char *ver)\n{\n\tint major, minor = 0;\n\n\tif (sscanf(ver, \"%d.%d\", &major, &minor) < 1)\n\t\tfatal(\"invalid ninja_required_version\");\n\tif (major > ninjamajor || (major == ninjamajor && minor > ninjaminor))\n\t\tfatal(\"ninja_required_version %s is newer than %d.%d\", ver, ninjamajor, ninjaminor);\n}\n\nvoid\nparse(const char *name, struct environment *env)\n{\n\tstruct scanner s;\n\tchar *var;\n\tstruct string *val;\n\tstruct evalstring *str;\n\n\tscaninit(&s, name);\n\tfor (;;) {\n\t\tswitch (scankeyword(&s, &var)) {\n\t\tcase RULE:\n\t\t\tparserule(&s, env);\n\t\t\tbreak;\n\t\tcase BUILD:\n\t\t\tparseedge(&s, env);\n\t\t\tbreak;\n\t\tcase INCLUDE:\n\t\t\tparseinclude(&s, env, false);\n\t\t\tbreak;\n\t\tcase SUBNINJA:\n\t\t\tparseinclude(&s, env, true);\n\t\t\tbreak;\n\t\tcase DEFAULT:\n\t\t\tparsedefault(&s, env);\n\t\t\tbreak;\n\t\tcase POOL:\n\t\t\tparsepool(&s, env);\n\t\t\tbreak;\n\t\tcase VARIABLE:\n\t\t\tparselet(&s, &str);\n\t\t\tval = enveval(env, str);\n\t\t\tif (strcmp(var, \"ninja_required_version\") == 0)\n\t\t\t\tcheckversion(val->s);\n\t\t\tenvaddvar(env, var, val);\n\t\t\tbreak;\n\t\tcase EOF:\n\t\t\tscanclose(&s);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nvoid\ndefaultnodes(void fn(struct node *))\n{\n\tstruct edge *e;\n\tstruct node *n;\n\tsize_t i;\n\n\tif (ndeftarg > 0) {\n\t\tfor (i = 0; i < ndeftarg; ++i)\n\t\t\tfn(deftarg[i]);\n\t} else {\n\t\t/* by default build all nodes which are not used by any edges */\n\t\tfor (e = alledges; e; e = e->allnext) {\n\t\t\tfor (i = 0; i < e->nout; ++i) {\n\t\t\t\tn = e->out[i];\n\t\t\t\tif (n->nuse == 0)\n\t\t\t\t\tfn(n);\n\t\t\t}\n\t\t}\n\t}\n}\n"], "filenames": ["parse.c"], "buggy_code_start_loc": [44], "buggy_code_end_loc": [44], "fixing_code_start_loc": [45], "fixing_code_end_loc": [47], "type": "CWE-476", "message": "samurai 1.2 has a NULL pointer dereference in printstatus() function in build.c via a crafted build file.", "other": {"cve": {"id": "CVE-2021-30219", "sourceIdentifier": "cve@mitre.org", "published": "2021-04-29T15:15:11.077", "lastModified": "2021-05-03T18:01:38.917", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "samurai 1.2 has a NULL pointer dereference in printstatus() function in build.c via a crafted build file."}, {"lang": "es", "value": "samurai versi\u00f3n 1.2, presenta una desreferencia de puntero NULL en la funci\u00f3n printstatus() en el archivo build.c por medio de un archivo de construcci\u00f3n dise\u00f1ado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:samurai_project:samurai:1.2:*:*:*:*:*:*:*", "matchCriteriaId": "6EAE8155-445A-4338-A9C0-A6BB5928821D"}]}]}], "references": [{"url": "https://github.com/michaelforney/samurai/commit/d2af3bc375e2a77139c3a28d6128c60cd8d08655", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/michaelforney/samurai/issues/68", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/michaelforney/samurai/commit/d2af3bc375e2a77139c3a28d6128c60cd8d08655"}}