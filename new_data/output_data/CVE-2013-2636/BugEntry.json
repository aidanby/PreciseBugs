{"buggy_code": ["#include <linux/err.h>\n#include <linux/igmp.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/rculist.h>\n#include <linux/skbuff.h>\n#include <linux/if_ether.h>\n#include <net/ip.h>\n#include <net/netlink.h>\n#if IS_ENABLED(CONFIG_IPV6)\n#include <net/ipv6.h>\n#endif\n\n#include \"br_private.h\"\n\nstatic int br_rports_fill_info(struct sk_buff *skb, struct netlink_callback *cb,\n\t\t\t       struct net_device *dev)\n{\n\tstruct net_bridge *br = netdev_priv(dev);\n\tstruct net_bridge_port *p;\n\tstruct nlattr *nest;\n\n\tif (!br->multicast_router || hlist_empty(&br->router_list))\n\t\treturn 0;\n\n\tnest = nla_nest_start(skb, MDBA_ROUTER);\n\tif (nest == NULL)\n\t\treturn -EMSGSIZE;\n\n\thlist_for_each_entry_rcu(p, &br->router_list, rlist) {\n\t\tif (p && nla_put_u32(skb, MDBA_ROUTER_PORT, p->dev->ifindex))\n\t\t\tgoto fail;\n\t}\n\n\tnla_nest_end(skb, nest);\n\treturn 0;\nfail:\n\tnla_nest_cancel(skb, nest);\n\treturn -EMSGSIZE;\n}\n\nstatic int br_mdb_fill_info(struct sk_buff *skb, struct netlink_callback *cb,\n\t\t\t    struct net_device *dev)\n{\n\tstruct net_bridge *br = netdev_priv(dev);\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct nlattr *nest, *nest2;\n\tint i, err = 0;\n\tint idx = 0, s_idx = cb->args[1];\n\n\tif (br->multicast_disabled)\n\t\treturn 0;\n\n\tmdb = rcu_dereference(br->mdb);\n\tif (!mdb)\n\t\treturn 0;\n\n\tnest = nla_nest_start(skb, MDBA_MDB);\n\tif (nest == NULL)\n\t\treturn -EMSGSIZE;\n\n\tfor (i = 0; i < mdb->max; i++) {\n\t\tstruct net_bridge_mdb_entry *mp;\n\t\tstruct net_bridge_port_group *p, **pp;\n\t\tstruct net_bridge_port *port;\n\n\t\thlist_for_each_entry_rcu(mp, &mdb->mhash[i], hlist[mdb->ver]) {\n\t\t\tif (idx < s_idx)\n\t\t\t\tgoto skip;\n\n\t\t\tnest2 = nla_nest_start(skb, MDBA_MDB_ENTRY);\n\t\t\tif (nest2 == NULL) {\n\t\t\t\terr = -EMSGSIZE;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tfor (pp = &mp->ports;\n\t\t\t     (p = rcu_dereference(*pp)) != NULL;\n\t\t\t      pp = &p->next) {\n\t\t\t\tport = p->port;\n\t\t\t\tif (port) {\n\t\t\t\t\tstruct br_mdb_entry e;\n\t\t\t\t\te.ifindex = port->dev->ifindex;\n\t\t\t\t\te.state = p->state;\n\t\t\t\t\tif (p->addr.proto == htons(ETH_P_IP))\n\t\t\t\t\t\te.addr.u.ip4 = p->addr.u.ip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t\t\t\tif (p->addr.proto == htons(ETH_P_IPV6))\n\t\t\t\t\t\te.addr.u.ip6 = p->addr.u.ip6;\n#endif\n\t\t\t\t\te.addr.proto = p->addr.proto;\n\t\t\t\t\tif (nla_put(skb, MDBA_MDB_ENTRY_INFO, sizeof(e), &e)) {\n\t\t\t\t\t\tnla_nest_cancel(skb, nest2);\n\t\t\t\t\t\terr = -EMSGSIZE;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tnla_nest_end(skb, nest2);\n\t\tskip:\n\t\t\tidx++;\n\t\t}\n\t}\n\nout:\n\tcb->args[1] = idx;\n\tnla_nest_end(skb, nest);\n\treturn err;\n}\n\nstatic int br_mdb_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net_device *dev;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlmsghdr *nlh = NULL;\n\tint idx = 0, s_idx;\n\n\ts_idx = cb->args[0];\n\n\trcu_read_lock();\n\n\t/* In theory this could be wrapped to 0... */\n\tcb->seq = net->dev_base_seq + br_mdb_rehash_seq;\n\n\tfor_each_netdev_rcu(net, dev) {\n\t\tif (dev->priv_flags & IFF_EBRIDGE) {\n\t\t\tstruct br_port_msg *bpm;\n\n\t\t\tif (idx < s_idx)\n\t\t\t\tgoto skip;\n\n\t\t\tnlh = nlmsg_put(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\tcb->nlh->nlmsg_seq, RTM_GETMDB,\n\t\t\t\t\tsizeof(*bpm), NLM_F_MULTI);\n\t\t\tif (nlh == NULL)\n\t\t\t\tbreak;\n\n\t\t\tbpm = nlmsg_data(nlh);\n\t\t\tbpm->ifindex = dev->ifindex;\n\t\t\tif (br_mdb_fill_info(skb, cb, dev) < 0)\n\t\t\t\tgoto out;\n\t\t\tif (br_rports_fill_info(skb, cb, dev) < 0)\n\t\t\t\tgoto out;\n\n\t\t\tcb->args[1] = 0;\n\t\t\tnlmsg_end(skb, nlh);\n\t\tskip:\n\t\t\tidx++;\n\t\t}\n\t}\n\nout:\n\tif (nlh)\n\t\tnlmsg_end(skb, nlh);\n\trcu_read_unlock();\n\tcb->args[0] = idx;\n\treturn skb->len;\n}\n\nstatic int nlmsg_populate_mdb_fill(struct sk_buff *skb,\n\t\t\t\t   struct net_device *dev,\n\t\t\t\t   struct br_mdb_entry *entry, u32 pid,\n\t\t\t\t   u32 seq, int type, unsigned int flags)\n{\n\tstruct nlmsghdr *nlh;\n\tstruct br_port_msg *bpm;\n\tstruct nlattr *nest, *nest2;\n\n\tnlh = nlmsg_put(skb, pid, seq, type, sizeof(*bpm), NLM_F_MULTI);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\tbpm = nlmsg_data(nlh);\n\tbpm->family  = AF_BRIDGE;\n\tbpm->ifindex = dev->ifindex;\n\tnest = nla_nest_start(skb, MDBA_MDB);\n\tif (nest == NULL)\n\t\tgoto cancel;\n\tnest2 = nla_nest_start(skb, MDBA_MDB_ENTRY);\n\tif (nest2 == NULL)\n\t\tgoto end;\n\n\tif (nla_put(skb, MDBA_MDB_ENTRY_INFO, sizeof(*entry), entry))\n\t\tgoto end;\n\n\tnla_nest_end(skb, nest2);\n\tnla_nest_end(skb, nest);\n\treturn nlmsg_end(skb, nlh);\n\nend:\n\tnla_nest_end(skb, nest);\ncancel:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic inline size_t rtnl_mdb_nlmsg_size(void)\n{\n\treturn NLMSG_ALIGN(sizeof(struct br_port_msg))\n\t\t+ nla_total_size(sizeof(struct br_mdb_entry));\n}\n\nstatic void __br_mdb_notify(struct net_device *dev, struct br_mdb_entry *entry,\n\t\t\t    int type)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct sk_buff *skb;\n\tint err = -ENOBUFS;\n\n\tskb = nlmsg_new(rtnl_mdb_nlmsg_size(), GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto errout;\n\n\terr = nlmsg_populate_mdb_fill(skb, dev, entry, 0, 0, type, NTF_SELF);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\n\trtnl_notify(skb, net, 0, RTNLGRP_MDB, NULL, GFP_ATOMIC);\n\treturn;\nerrout:\n\trtnl_set_sk_err(net, RTNLGRP_MDB, err);\n}\n\nvoid br_mdb_notify(struct net_device *dev, struct net_bridge_port *port,\n\t\t   struct br_ip *group, int type)\n{\n\tstruct br_mdb_entry entry;\n\n\tentry.ifindex = port->dev->ifindex;\n\tentry.addr.proto = group->proto;\n\tentry.addr.u.ip4 = group->u.ip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\tentry.addr.u.ip6 = group->u.ip6;\n#endif\n\t__br_mdb_notify(dev, &entry, type);\n}\n\nstatic bool is_valid_mdb_entry(struct br_mdb_entry *entry)\n{\n\tif (entry->ifindex == 0)\n\t\treturn false;\n\n\tif (entry->addr.proto == htons(ETH_P_IP)) {\n\t\tif (!ipv4_is_multicast(entry->addr.u.ip4))\n\t\t\treturn false;\n\t\tif (ipv4_is_local_multicast(entry->addr.u.ip4))\n\t\t\treturn false;\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (entry->addr.proto == htons(ETH_P_IPV6)) {\n\t\tif (!ipv6_is_transient_multicast(&entry->addr.u.ip6))\n\t\t\treturn false;\n#endif\n\t} else\n\t\treturn false;\n\tif (entry->state != MDB_PERMANENT && entry->state != MDB_TEMPORARY)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int br_mdb_parse(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\tstruct net_device **pdev, struct br_mdb_entry **pentry)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct br_mdb_entry *entry;\n\tstruct br_port_msg *bpm;\n\tstruct nlattr *tb[MDBA_SET_ENTRY_MAX+1];\n\tstruct net_device *dev;\n\tint err;\n\n\terr = nlmsg_parse(nlh, sizeof(*bpm), tb, MDBA_SET_ENTRY, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tbpm = nlmsg_data(nlh);\n\tif (bpm->ifindex == 0) {\n\t\tpr_info(\"PF_BRIDGE: br_mdb_parse() with invalid ifindex\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = __dev_get_by_index(net, bpm->ifindex);\n\tif (dev == NULL) {\n\t\tpr_info(\"PF_BRIDGE: br_mdb_parse() with unknown ifindex\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!(dev->priv_flags & IFF_EBRIDGE)) {\n\t\tpr_info(\"PF_BRIDGE: br_mdb_parse() with non-bridge\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t*pdev = dev;\n\n\tif (!tb[MDBA_SET_ENTRY] ||\n\t    nla_len(tb[MDBA_SET_ENTRY]) != sizeof(struct br_mdb_entry)) {\n\t\tpr_info(\"PF_BRIDGE: br_mdb_parse() with invalid attr\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tentry = nla_data(tb[MDBA_SET_ENTRY]);\n\tif (!is_valid_mdb_entry(entry)) {\n\t\tpr_info(\"PF_BRIDGE: br_mdb_parse() with invalid entry\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t*pentry = entry;\n\treturn 0;\n}\n\nstatic int br_mdb_add_group(struct net_bridge *br, struct net_bridge_port *port,\n\t\t\t    struct br_ip *group, unsigned char state)\n{\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tstruct net_bridge_mdb_htable *mdb;\n\tint err;\n\n\tmdb = mlock_dereference(br->mdb, br);\n\tmp = br_mdb_ip_get(mdb, group);\n\tif (!mp) {\n\t\tmp = br_multicast_new_group(br, port, group);\n\t\terr = PTR_ERR(mp);\n\t\tif (IS_ERR(mp))\n\t\t\treturn err;\n\t}\n\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (p->port == port)\n\t\t\treturn -EEXIST;\n\t\tif ((unsigned long)p->port < (unsigned long)port)\n\t\t\tbreak;\n\t}\n\n\tp = br_multicast_new_port_group(port, group, *pp, state);\n\tif (unlikely(!p))\n\t\treturn -ENOMEM;\n\trcu_assign_pointer(*pp, p);\n\n\tbr_mdb_notify(br->dev, port, group, RTM_NEWMDB);\n\treturn 0;\n}\n\nstatic int __br_mdb_add(struct net *net, struct net_bridge *br,\n\t\t\tstruct br_mdb_entry *entry)\n{\n\tstruct br_ip ip;\n\tstruct net_device *dev;\n\tstruct net_bridge_port *p;\n\tint ret;\n\n\tif (!netif_running(br->dev) || br->multicast_disabled)\n\t\treturn -EINVAL;\n\n\tdev = __dev_get_by_index(net, entry->ifindex);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tp = br_port_get_rtnl(dev);\n\tif (!p || p->br != br || p->state == BR_STATE_DISABLED)\n\t\treturn -EINVAL;\n\n\tip.proto = entry->addr.proto;\n\tif (ip.proto == htons(ETH_P_IP))\n\t\tip.u.ip4 = entry->addr.u.ip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\telse\n\t\tip.u.ip6 = entry->addr.u.ip6;\n#endif\n\n\tspin_lock_bh(&br->multicast_lock);\n\tret = br_mdb_add_group(br, p, &ip, entry->state);\n\tspin_unlock_bh(&br->multicast_lock);\n\treturn ret;\n}\n\nstatic int br_mdb_add(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct br_mdb_entry *entry;\n\tstruct net_device *dev;\n\tstruct net_bridge *br;\n\tint err;\n\n\terr = br_mdb_parse(skb, nlh, &dev, &entry);\n\tif (err < 0)\n\t\treturn err;\n\n\tbr = netdev_priv(dev);\n\n\terr = __br_mdb_add(net, br, entry);\n\tif (!err)\n\t\t__br_mdb_notify(dev, entry, RTM_NEWMDB);\n\treturn err;\n}\n\nstatic int __br_mdb_del(struct net_bridge *br, struct br_mdb_entry *entry)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tstruct br_ip ip;\n\tint err = -EINVAL;\n\n\tif (!netif_running(br->dev) || br->multicast_disabled)\n\t\treturn -EINVAL;\n\n\tif (timer_pending(&br->multicast_querier_timer))\n\t\treturn -EBUSY;\n\n\tip.proto = entry->addr.proto;\n\tif (ip.proto == htons(ETH_P_IP))\n\t\tip.u.ip4 = entry->addr.u.ip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\telse\n\t\tip.u.ip6 = entry->addr.u.ip6;\n#endif\n\n\tspin_lock_bh(&br->multicast_lock);\n\tmdb = mlock_dereference(br->mdb, br);\n\n\tmp = br_mdb_ip_get(mdb, &ip);\n\tif (!mp)\n\t\tgoto unlock;\n\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (!p->port || p->port->dev->ifindex != entry->ifindex)\n\t\t\tcontinue;\n\n\t\tif (p->port->state == BR_STATE_DISABLED)\n\t\t\tgoto unlock;\n\n\t\trcu_assign_pointer(*pp, p->next);\n\t\thlist_del_init(&p->mglist);\n\t\tdel_timer(&p->timer);\n\t\tcall_rcu_bh(&p->rcu, br_multicast_free_pg);\n\t\terr = 0;\n\n\t\tif (!mp->ports && !mp->mglist &&\n\t\t    netif_running(br->dev))\n\t\t\tmod_timer(&mp->timer, jiffies);\n\t\tbreak;\n\t}\n\nunlock:\n\tspin_unlock_bh(&br->multicast_lock);\n\treturn err;\n}\n\nstatic int br_mdb_del(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg)\n{\n\tstruct net_device *dev;\n\tstruct br_mdb_entry *entry;\n\tstruct net_bridge *br;\n\tint err;\n\n\terr = br_mdb_parse(skb, nlh, &dev, &entry);\n\tif (err < 0)\n\t\treturn err;\n\n\tbr = netdev_priv(dev);\n\n\terr = __br_mdb_del(br, entry);\n\tif (!err)\n\t\t__br_mdb_notify(dev, entry, RTM_DELMDB);\n\treturn err;\n}\n\nvoid br_mdb_init(void)\n{\n\trtnl_register(PF_BRIDGE, RTM_GETMDB, NULL, br_mdb_dump, NULL);\n\trtnl_register(PF_BRIDGE, RTM_NEWMDB, br_mdb_add, NULL, NULL);\n\trtnl_register(PF_BRIDGE, RTM_DELMDB, br_mdb_del, NULL, NULL);\n}\n\nvoid br_mdb_uninit(void)\n{\n\trtnl_unregister(PF_BRIDGE, RTM_GETMDB);\n\trtnl_unregister(PF_BRIDGE, RTM_NEWMDB);\n\trtnl_unregister(PF_BRIDGE, RTM_DELMDB);\n}\n"], "fixing_code": ["#include <linux/err.h>\n#include <linux/igmp.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/rculist.h>\n#include <linux/skbuff.h>\n#include <linux/if_ether.h>\n#include <net/ip.h>\n#include <net/netlink.h>\n#if IS_ENABLED(CONFIG_IPV6)\n#include <net/ipv6.h>\n#endif\n\n#include \"br_private.h\"\n\nstatic int br_rports_fill_info(struct sk_buff *skb, struct netlink_callback *cb,\n\t\t\t       struct net_device *dev)\n{\n\tstruct net_bridge *br = netdev_priv(dev);\n\tstruct net_bridge_port *p;\n\tstruct nlattr *nest;\n\n\tif (!br->multicast_router || hlist_empty(&br->router_list))\n\t\treturn 0;\n\n\tnest = nla_nest_start(skb, MDBA_ROUTER);\n\tif (nest == NULL)\n\t\treturn -EMSGSIZE;\n\n\thlist_for_each_entry_rcu(p, &br->router_list, rlist) {\n\t\tif (p && nla_put_u32(skb, MDBA_ROUTER_PORT, p->dev->ifindex))\n\t\t\tgoto fail;\n\t}\n\n\tnla_nest_end(skb, nest);\n\treturn 0;\nfail:\n\tnla_nest_cancel(skb, nest);\n\treturn -EMSGSIZE;\n}\n\nstatic int br_mdb_fill_info(struct sk_buff *skb, struct netlink_callback *cb,\n\t\t\t    struct net_device *dev)\n{\n\tstruct net_bridge *br = netdev_priv(dev);\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct nlattr *nest, *nest2;\n\tint i, err = 0;\n\tint idx = 0, s_idx = cb->args[1];\n\n\tif (br->multicast_disabled)\n\t\treturn 0;\n\n\tmdb = rcu_dereference(br->mdb);\n\tif (!mdb)\n\t\treturn 0;\n\n\tnest = nla_nest_start(skb, MDBA_MDB);\n\tif (nest == NULL)\n\t\treturn -EMSGSIZE;\n\n\tfor (i = 0; i < mdb->max; i++) {\n\t\tstruct net_bridge_mdb_entry *mp;\n\t\tstruct net_bridge_port_group *p, **pp;\n\t\tstruct net_bridge_port *port;\n\n\t\thlist_for_each_entry_rcu(mp, &mdb->mhash[i], hlist[mdb->ver]) {\n\t\t\tif (idx < s_idx)\n\t\t\t\tgoto skip;\n\n\t\t\tnest2 = nla_nest_start(skb, MDBA_MDB_ENTRY);\n\t\t\tif (nest2 == NULL) {\n\t\t\t\terr = -EMSGSIZE;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tfor (pp = &mp->ports;\n\t\t\t     (p = rcu_dereference(*pp)) != NULL;\n\t\t\t      pp = &p->next) {\n\t\t\t\tport = p->port;\n\t\t\t\tif (port) {\n\t\t\t\t\tstruct br_mdb_entry e;\n\t\t\t\t\tmemset(&e, 0, sizeof(e));\n\t\t\t\t\te.ifindex = port->dev->ifindex;\n\t\t\t\t\te.state = p->state;\n\t\t\t\t\tif (p->addr.proto == htons(ETH_P_IP))\n\t\t\t\t\t\te.addr.u.ip4 = p->addr.u.ip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t\t\t\tif (p->addr.proto == htons(ETH_P_IPV6))\n\t\t\t\t\t\te.addr.u.ip6 = p->addr.u.ip6;\n#endif\n\t\t\t\t\te.addr.proto = p->addr.proto;\n\t\t\t\t\tif (nla_put(skb, MDBA_MDB_ENTRY_INFO, sizeof(e), &e)) {\n\t\t\t\t\t\tnla_nest_cancel(skb, nest2);\n\t\t\t\t\t\terr = -EMSGSIZE;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tnla_nest_end(skb, nest2);\n\t\tskip:\n\t\t\tidx++;\n\t\t}\n\t}\n\nout:\n\tcb->args[1] = idx;\n\tnla_nest_end(skb, nest);\n\treturn err;\n}\n\nstatic int br_mdb_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net_device *dev;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlmsghdr *nlh = NULL;\n\tint idx = 0, s_idx;\n\n\ts_idx = cb->args[0];\n\n\trcu_read_lock();\n\n\t/* In theory this could be wrapped to 0... */\n\tcb->seq = net->dev_base_seq + br_mdb_rehash_seq;\n\n\tfor_each_netdev_rcu(net, dev) {\n\t\tif (dev->priv_flags & IFF_EBRIDGE) {\n\t\t\tstruct br_port_msg *bpm;\n\n\t\t\tif (idx < s_idx)\n\t\t\t\tgoto skip;\n\n\t\t\tnlh = nlmsg_put(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\tcb->nlh->nlmsg_seq, RTM_GETMDB,\n\t\t\t\t\tsizeof(*bpm), NLM_F_MULTI);\n\t\t\tif (nlh == NULL)\n\t\t\t\tbreak;\n\n\t\t\tbpm = nlmsg_data(nlh);\n\t\t\tmemset(bpm, 0, sizeof(*bpm));\n\t\t\tbpm->ifindex = dev->ifindex;\n\t\t\tif (br_mdb_fill_info(skb, cb, dev) < 0)\n\t\t\t\tgoto out;\n\t\t\tif (br_rports_fill_info(skb, cb, dev) < 0)\n\t\t\t\tgoto out;\n\n\t\t\tcb->args[1] = 0;\n\t\t\tnlmsg_end(skb, nlh);\n\t\tskip:\n\t\t\tidx++;\n\t\t}\n\t}\n\nout:\n\tif (nlh)\n\t\tnlmsg_end(skb, nlh);\n\trcu_read_unlock();\n\tcb->args[0] = idx;\n\treturn skb->len;\n}\n\nstatic int nlmsg_populate_mdb_fill(struct sk_buff *skb,\n\t\t\t\t   struct net_device *dev,\n\t\t\t\t   struct br_mdb_entry *entry, u32 pid,\n\t\t\t\t   u32 seq, int type, unsigned int flags)\n{\n\tstruct nlmsghdr *nlh;\n\tstruct br_port_msg *bpm;\n\tstruct nlattr *nest, *nest2;\n\n\tnlh = nlmsg_put(skb, pid, seq, type, sizeof(*bpm), NLM_F_MULTI);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\tbpm = nlmsg_data(nlh);\n\tmemset(bpm, 0, sizeof(*bpm));\n\tbpm->family  = AF_BRIDGE;\n\tbpm->ifindex = dev->ifindex;\n\tnest = nla_nest_start(skb, MDBA_MDB);\n\tif (nest == NULL)\n\t\tgoto cancel;\n\tnest2 = nla_nest_start(skb, MDBA_MDB_ENTRY);\n\tif (nest2 == NULL)\n\t\tgoto end;\n\n\tif (nla_put(skb, MDBA_MDB_ENTRY_INFO, sizeof(*entry), entry))\n\t\tgoto end;\n\n\tnla_nest_end(skb, nest2);\n\tnla_nest_end(skb, nest);\n\treturn nlmsg_end(skb, nlh);\n\nend:\n\tnla_nest_end(skb, nest);\ncancel:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic inline size_t rtnl_mdb_nlmsg_size(void)\n{\n\treturn NLMSG_ALIGN(sizeof(struct br_port_msg))\n\t\t+ nla_total_size(sizeof(struct br_mdb_entry));\n}\n\nstatic void __br_mdb_notify(struct net_device *dev, struct br_mdb_entry *entry,\n\t\t\t    int type)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct sk_buff *skb;\n\tint err = -ENOBUFS;\n\n\tskb = nlmsg_new(rtnl_mdb_nlmsg_size(), GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto errout;\n\n\terr = nlmsg_populate_mdb_fill(skb, dev, entry, 0, 0, type, NTF_SELF);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\n\trtnl_notify(skb, net, 0, RTNLGRP_MDB, NULL, GFP_ATOMIC);\n\treturn;\nerrout:\n\trtnl_set_sk_err(net, RTNLGRP_MDB, err);\n}\n\nvoid br_mdb_notify(struct net_device *dev, struct net_bridge_port *port,\n\t\t   struct br_ip *group, int type)\n{\n\tstruct br_mdb_entry entry;\n\n\tmemset(&entry, 0, sizeof(entry));\n\tentry.ifindex = port->dev->ifindex;\n\tentry.addr.proto = group->proto;\n\tentry.addr.u.ip4 = group->u.ip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\tentry.addr.u.ip6 = group->u.ip6;\n#endif\n\t__br_mdb_notify(dev, &entry, type);\n}\n\nstatic bool is_valid_mdb_entry(struct br_mdb_entry *entry)\n{\n\tif (entry->ifindex == 0)\n\t\treturn false;\n\n\tif (entry->addr.proto == htons(ETH_P_IP)) {\n\t\tif (!ipv4_is_multicast(entry->addr.u.ip4))\n\t\t\treturn false;\n\t\tif (ipv4_is_local_multicast(entry->addr.u.ip4))\n\t\t\treturn false;\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (entry->addr.proto == htons(ETH_P_IPV6)) {\n\t\tif (!ipv6_is_transient_multicast(&entry->addr.u.ip6))\n\t\t\treturn false;\n#endif\n\t} else\n\t\treturn false;\n\tif (entry->state != MDB_PERMANENT && entry->state != MDB_TEMPORARY)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int br_mdb_parse(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\tstruct net_device **pdev, struct br_mdb_entry **pentry)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct br_mdb_entry *entry;\n\tstruct br_port_msg *bpm;\n\tstruct nlattr *tb[MDBA_SET_ENTRY_MAX+1];\n\tstruct net_device *dev;\n\tint err;\n\n\terr = nlmsg_parse(nlh, sizeof(*bpm), tb, MDBA_SET_ENTRY, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tbpm = nlmsg_data(nlh);\n\tif (bpm->ifindex == 0) {\n\t\tpr_info(\"PF_BRIDGE: br_mdb_parse() with invalid ifindex\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = __dev_get_by_index(net, bpm->ifindex);\n\tif (dev == NULL) {\n\t\tpr_info(\"PF_BRIDGE: br_mdb_parse() with unknown ifindex\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!(dev->priv_flags & IFF_EBRIDGE)) {\n\t\tpr_info(\"PF_BRIDGE: br_mdb_parse() with non-bridge\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t*pdev = dev;\n\n\tif (!tb[MDBA_SET_ENTRY] ||\n\t    nla_len(tb[MDBA_SET_ENTRY]) != sizeof(struct br_mdb_entry)) {\n\t\tpr_info(\"PF_BRIDGE: br_mdb_parse() with invalid attr\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tentry = nla_data(tb[MDBA_SET_ENTRY]);\n\tif (!is_valid_mdb_entry(entry)) {\n\t\tpr_info(\"PF_BRIDGE: br_mdb_parse() with invalid entry\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t*pentry = entry;\n\treturn 0;\n}\n\nstatic int br_mdb_add_group(struct net_bridge *br, struct net_bridge_port *port,\n\t\t\t    struct br_ip *group, unsigned char state)\n{\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tstruct net_bridge_mdb_htable *mdb;\n\tint err;\n\n\tmdb = mlock_dereference(br->mdb, br);\n\tmp = br_mdb_ip_get(mdb, group);\n\tif (!mp) {\n\t\tmp = br_multicast_new_group(br, port, group);\n\t\terr = PTR_ERR(mp);\n\t\tif (IS_ERR(mp))\n\t\t\treturn err;\n\t}\n\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (p->port == port)\n\t\t\treturn -EEXIST;\n\t\tif ((unsigned long)p->port < (unsigned long)port)\n\t\t\tbreak;\n\t}\n\n\tp = br_multicast_new_port_group(port, group, *pp, state);\n\tif (unlikely(!p))\n\t\treturn -ENOMEM;\n\trcu_assign_pointer(*pp, p);\n\n\tbr_mdb_notify(br->dev, port, group, RTM_NEWMDB);\n\treturn 0;\n}\n\nstatic int __br_mdb_add(struct net *net, struct net_bridge *br,\n\t\t\tstruct br_mdb_entry *entry)\n{\n\tstruct br_ip ip;\n\tstruct net_device *dev;\n\tstruct net_bridge_port *p;\n\tint ret;\n\n\tif (!netif_running(br->dev) || br->multicast_disabled)\n\t\treturn -EINVAL;\n\n\tdev = __dev_get_by_index(net, entry->ifindex);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tp = br_port_get_rtnl(dev);\n\tif (!p || p->br != br || p->state == BR_STATE_DISABLED)\n\t\treturn -EINVAL;\n\n\tip.proto = entry->addr.proto;\n\tif (ip.proto == htons(ETH_P_IP))\n\t\tip.u.ip4 = entry->addr.u.ip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\telse\n\t\tip.u.ip6 = entry->addr.u.ip6;\n#endif\n\n\tspin_lock_bh(&br->multicast_lock);\n\tret = br_mdb_add_group(br, p, &ip, entry->state);\n\tspin_unlock_bh(&br->multicast_lock);\n\treturn ret;\n}\n\nstatic int br_mdb_add(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct br_mdb_entry *entry;\n\tstruct net_device *dev;\n\tstruct net_bridge *br;\n\tint err;\n\n\terr = br_mdb_parse(skb, nlh, &dev, &entry);\n\tif (err < 0)\n\t\treturn err;\n\n\tbr = netdev_priv(dev);\n\n\terr = __br_mdb_add(net, br, entry);\n\tif (!err)\n\t\t__br_mdb_notify(dev, entry, RTM_NEWMDB);\n\treturn err;\n}\n\nstatic int __br_mdb_del(struct net_bridge *br, struct br_mdb_entry *entry)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tstruct br_ip ip;\n\tint err = -EINVAL;\n\n\tif (!netif_running(br->dev) || br->multicast_disabled)\n\t\treturn -EINVAL;\n\n\tif (timer_pending(&br->multicast_querier_timer))\n\t\treturn -EBUSY;\n\n\tip.proto = entry->addr.proto;\n\tif (ip.proto == htons(ETH_P_IP))\n\t\tip.u.ip4 = entry->addr.u.ip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\telse\n\t\tip.u.ip6 = entry->addr.u.ip6;\n#endif\n\n\tspin_lock_bh(&br->multicast_lock);\n\tmdb = mlock_dereference(br->mdb, br);\n\n\tmp = br_mdb_ip_get(mdb, &ip);\n\tif (!mp)\n\t\tgoto unlock;\n\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (!p->port || p->port->dev->ifindex != entry->ifindex)\n\t\t\tcontinue;\n\n\t\tif (p->port->state == BR_STATE_DISABLED)\n\t\t\tgoto unlock;\n\n\t\trcu_assign_pointer(*pp, p->next);\n\t\thlist_del_init(&p->mglist);\n\t\tdel_timer(&p->timer);\n\t\tcall_rcu_bh(&p->rcu, br_multicast_free_pg);\n\t\terr = 0;\n\n\t\tif (!mp->ports && !mp->mglist &&\n\t\t    netif_running(br->dev))\n\t\t\tmod_timer(&mp->timer, jiffies);\n\t\tbreak;\n\t}\n\nunlock:\n\tspin_unlock_bh(&br->multicast_lock);\n\treturn err;\n}\n\nstatic int br_mdb_del(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg)\n{\n\tstruct net_device *dev;\n\tstruct br_mdb_entry *entry;\n\tstruct net_bridge *br;\n\tint err;\n\n\terr = br_mdb_parse(skb, nlh, &dev, &entry);\n\tif (err < 0)\n\t\treturn err;\n\n\tbr = netdev_priv(dev);\n\n\terr = __br_mdb_del(br, entry);\n\tif (!err)\n\t\t__br_mdb_notify(dev, entry, RTM_DELMDB);\n\treturn err;\n}\n\nvoid br_mdb_init(void)\n{\n\trtnl_register(PF_BRIDGE, RTM_GETMDB, NULL, br_mdb_dump, NULL);\n\trtnl_register(PF_BRIDGE, RTM_NEWMDB, br_mdb_add, NULL, NULL);\n\trtnl_register(PF_BRIDGE, RTM_DELMDB, br_mdb_del, NULL, NULL);\n}\n\nvoid br_mdb_uninit(void)\n{\n\trtnl_unregister(PF_BRIDGE, RTM_GETMDB);\n\trtnl_unregister(PF_BRIDGE, RTM_NEWMDB);\n\trtnl_unregister(PF_BRIDGE, RTM_DELMDB);\n}\n"], "filenames": ["net/bridge/br_mdb.c"], "buggy_code_start_loc": [82], "buggy_code_end_loc": [230], "fixing_code_start_loc": [83], "fixing_code_end_loc": [235], "type": "CWE-399", "message": "net/bridge/br_mdb.c in the Linux kernel before 3.8.4 does not initialize certain structures, which allows local users to obtain sensitive information from kernel memory via a crafted application.", "other": {"cve": {"id": "CVE-2013-2636", "sourceIdentifier": "cve@mitre.org", "published": "2013-03-22T11:59:12.017", "lastModified": "2013-04-05T04:00:00.000", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "net/bridge/br_mdb.c in the Linux kernel before 3.8.4 does not initialize certain structures, which allows local users to obtain sensitive information from kernel memory via a crafted application."}, {"lang": "es", "value": "net/bridge/br_mdb.c en el kernel de Linux anterior a v3.8.4 no inicializa determinadas estructuras, lo que permite a atacantes locales obtener informaci\u00f3n sensible desde la memoria del kernel mediante una aplicaci\u00f3n especialmente dise\u00f1ada."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 1.9}, "baseSeverity": "LOW", "exploitabilityScore": 3.4, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-399"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.8.3", "matchCriteriaId": "7A40E2A8-BBC3-4763-B150-9193F30E9DF0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "1A6E41FB-38CE-49F2-B796-9A5AA648E73F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "93523FE1-5993-46CB-9299-7C8C1A04E873"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "27ADC356-6BE9-43A3-9E0B-393DC4B1559A"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=c085c49920b2f900ba716b4ca1c1a55ece9872cc", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.8.4", "source": "cve@mitre.org"}, {"url": "http://www.openwall.com/lists/oss-security/2013/03/20/1", "source": "cve@mitre.org"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=923652", "source": "cve@mitre.org"}, {"url": "https://github.com/torvalds/linux/commit/c085c49920b2f900ba716b4ca1c1a55ece9872cc", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/c085c49920b2f900ba716b4ca1c1a55ece9872cc"}}