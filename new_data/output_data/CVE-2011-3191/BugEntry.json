{"buggy_code": ["/*\n *   fs/cifs/cifssmb.c\n *\n *   Copyright (C) International Business Machines  Corp., 2002,2010\n *   Author(s): Steve French (sfrench@us.ibm.com)\n *\n *   Contains the routines for constructing the SMB PDUs themselves\n *\n *   This library is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published\n *   by the Free Software Foundation; either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This library is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See\n *   the GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this library; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n */\n\n /* SMB/CIFS PDU handling routines here - except for leftovers in connect.c   */\n /* These are mostly routines that operate on a pathname, or on a tree id     */\n /* (mounted volume), but there are eight handle based routines which must be */\n /* treated slightly differently for reconnection purposes since we never     */\n /* want to reuse a stale file handle and only the caller knows the file info */\n\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/pagemap.h>\n#include <asm/uaccess.h>\n#include \"cifspdu.h\"\n#include \"cifsglob.h\"\n#include \"cifsacl.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n\n#ifdef CONFIG_CIFS_POSIX\nstatic struct {\n\tint index;\n\tchar *name;\n} protocols[] = {\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\n\t{LANMAN_PROT, \"\\2LM1.2X002\"},\n\t{LANMAN2_PROT, \"\\2LANMAN2.1\"},\n#endif /* weak password hashing for legacy clients */\n\t{CIFS_PROT, \"\\2NT LM 0.12\"},\n\t{POSIX_PROT, \"\\2POSIX 2\"},\n\t{BAD_PROT, \"\\2\"}\n};\n#else\nstatic struct {\n\tint index;\n\tchar *name;\n} protocols[] = {\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\n\t{LANMAN_PROT, \"\\2LM1.2X002\"},\n\t{LANMAN2_PROT, \"\\2LANMAN2.1\"},\n#endif /* weak password hashing for legacy clients */\n\t{CIFS_PROT, \"\\2NT LM 0.12\"},\n\t{BAD_PROT, \"\\2\"}\n};\n#endif\n\n/* define the number of elements in the cifs dialect array */\n#ifdef CONFIG_CIFS_POSIX\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\n#define CIFS_NUM_PROT 4\n#else\n#define CIFS_NUM_PROT 2\n#endif /* CIFS_WEAK_PW_HASH */\n#else /* not posix */\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\n#define CIFS_NUM_PROT 3\n#else\n#define CIFS_NUM_PROT 1\n#endif /* CONFIG_CIFS_WEAK_PW_HASH */\n#endif /* CIFS_POSIX */\n\n/* Mark as invalid, all open files on tree connections since they\n   were closed when session to server was lost */\nstatic void mark_open_files_invalid(struct cifs_tcon *pTcon)\n{\n\tstruct cifsFileInfo *open_file = NULL;\n\tstruct list_head *tmp;\n\tstruct list_head *tmp1;\n\n/* list all files open on tree connection and mark them invalid */\n\tspin_lock(&cifs_file_list_lock);\n\tlist_for_each_safe(tmp, tmp1, &pTcon->openFileList) {\n\t\topen_file = list_entry(tmp, struct cifsFileInfo, tlist);\n\t\topen_file->invalidHandle = true;\n\t\topen_file->oplock_break_cancelled = true;\n\t}\n\tspin_unlock(&cifs_file_list_lock);\n\t/* BB Add call to invalidate_inodes(sb) for all superblocks mounted\n\t   to this tcon */\n}\n\n/* reconnect the socket, tcon, and smb session if needed */\nstatic int\ncifs_reconnect_tcon(struct cifs_tcon *tcon, int smb_command)\n{\n\tint rc;\n\tstruct cifs_ses *ses;\n\tstruct TCP_Server_Info *server;\n\tstruct nls_table *nls_codepage;\n\n\t/*\n\t * SMBs NegProt, SessSetup, uLogoff do not have tcon yet so check for\n\t * tcp and smb session status done differently for those three - in the\n\t * calling routine\n\t */\n\tif (!tcon)\n\t\treturn 0;\n\n\tses = tcon->ses;\n\tserver = ses->server;\n\n\t/*\n\t * only tree disconnect, open, and write, (and ulogoff which does not\n\t * have tcon) are allowed as we start force umount\n\t */\n\tif (tcon->tidStatus == CifsExiting) {\n\t\tif (smb_command != SMB_COM_WRITE_ANDX &&\n\t\t    smb_command != SMB_COM_OPEN_ANDX &&\n\t\t    smb_command != SMB_COM_TREE_DISCONNECT) {\n\t\t\tcFYI(1, \"can not send cmd %d while umounting\",\n\t\t\t\tsmb_command);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\t/*\n\t * Give demultiplex thread up to 10 seconds to reconnect, should be\n\t * greater than cifs socket timeout which is 7 seconds\n\t */\n\twhile (server->tcpStatus == CifsNeedReconnect) {\n\t\twait_event_interruptible_timeout(server->response_q,\n\t\t\t(server->tcpStatus != CifsNeedReconnect), 10 * HZ);\n\n\t\t/* are we still trying to reconnect? */\n\t\tif (server->tcpStatus != CifsNeedReconnect)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * on \"soft\" mounts we wait once. Hard mounts keep\n\t\t * retrying until process is killed or server comes\n\t\t * back on-line\n\t\t */\n\t\tif (!tcon->retry) {\n\t\t\tcFYI(1, \"gave up waiting on reconnect in smb_init\");\n\t\t\treturn -EHOSTDOWN;\n\t\t}\n\t}\n\n\tif (!ses->need_reconnect && !tcon->need_reconnect)\n\t\treturn 0;\n\n\tnls_codepage = load_nls_default();\n\n\t/*\n\t * need to prevent multiple threads trying to simultaneously\n\t * reconnect the same SMB session\n\t */\n\tmutex_lock(&ses->session_mutex);\n\trc = cifs_negotiate_protocol(0, ses);\n\tif (rc == 0 && ses->need_reconnect)\n\t\trc = cifs_setup_session(0, ses, nls_codepage);\n\n\t/* do we need to reconnect tcon? */\n\tif (rc || !tcon->need_reconnect) {\n\t\tmutex_unlock(&ses->session_mutex);\n\t\tgoto out;\n\t}\n\n\tmark_open_files_invalid(tcon);\n\trc = CIFSTCon(0, ses, tcon->treeName, tcon, nls_codepage);\n\tmutex_unlock(&ses->session_mutex);\n\tcFYI(1, \"reconnect tcon rc = %d\", rc);\n\n\tif (rc)\n\t\tgoto out;\n\n\t/*\n\t * FIXME: check if wsize needs updated due to negotiated smb buffer\n\t * \t  size shrinking\n\t */\n\tatomic_inc(&tconInfoReconnectCount);\n\n\t/* tell server Unix caps we support */\n\tif (ses->capabilities & CAP_UNIX)\n\t\treset_cifs_unix_caps(0, tcon, NULL, NULL);\n\n\t/*\n\t * Removed call to reopen open files here. It is safer (and faster) to\n\t * reopen files one at a time as needed in read and write.\n\t *\n\t * FIXME: what about file locks? don't we need to reclaim them ASAP?\n\t */\n\nout:\n\t/*\n\t * Check if handle based operation so we know whether we can continue\n\t * or not without returning to caller to reset file handle\n\t */\n\tswitch (smb_command) {\n\tcase SMB_COM_READ_ANDX:\n\tcase SMB_COM_WRITE_ANDX:\n\tcase SMB_COM_CLOSE:\n\tcase SMB_COM_FIND_CLOSE2:\n\tcase SMB_COM_LOCKING_ANDX:\n\t\trc = -EAGAIN;\n\t}\n\n\tunload_nls(nls_codepage);\n\treturn rc;\n}\n\n/* Allocate and return pointer to an SMB request buffer, and set basic\n   SMB information in the SMB header.  If the return code is zero, this\n   function must have filled in request_buf pointer */\nstatic int\nsmall_smb_init(int smb_command, int wct, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc;\n\n\trc = cifs_reconnect_tcon(tcon, smb_command);\n\tif (rc)\n\t\treturn rc;\n\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\theader_assemble((struct smb_hdr *) *request_buf, smb_command,\n\t\t\ttcon, wct);\n\n\tif (tcon != NULL)\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\n\treturn 0;\n}\n\nint\nsmall_smb_init_no_tc(const int smb_command, const int wct,\n\t\t     struct cifs_ses *ses, void **request_buf)\n{\n\tint rc;\n\tstruct smb_hdr *buffer;\n\n\trc = small_smb_init(smb_command, wct, NULL, request_buf);\n\tif (rc)\n\t\treturn rc;\n\n\tbuffer = (struct smb_hdr *)*request_buf;\n\tbuffer->Mid = GetNextMid(ses->server);\n\tif (ses->capabilities & CAP_UNICODE)\n\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t/* uid, tid can stay at zero as set in header assemble */\n\n\t/* BB add support for turning on the signing when\n\tthis function is used after 1st of session setup requests */\n\n\treturn rc;\n}\n\n/* If the return code is zero, this function must fill in request_buf pointer */\nstatic int\n__smb_init(int smb_command, int wct, struct cifs_tcon *tcon,\n\t\t\tvoid **request_buf, void **response_buf)\n{\n\t*request_buf = cifs_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n    /* Although the original thought was we needed the response buf for  */\n    /* potential retries of smb operations it turns out we can determine */\n    /* from the mid flags when the request buffer can be resent without  */\n    /* having to use a second distinct buffer for the response */\n\tif (response_buf)\n\t\t*response_buf = *request_buf;\n\n\theader_assemble((struct smb_hdr *) *request_buf, smb_command, tcon,\n\t\t\twct);\n\n\tif (tcon != NULL)\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\n\treturn 0;\n}\n\n/* If the return code is zero, this function must fill in request_buf pointer */\nstatic int\nsmb_init(int smb_command, int wct, struct cifs_tcon *tcon,\n\t void **request_buf, void **response_buf)\n{\n\tint rc;\n\n\trc = cifs_reconnect_tcon(tcon, smb_command);\n\tif (rc)\n\t\treturn rc;\n\n\treturn __smb_init(smb_command, wct, tcon, request_buf, response_buf);\n}\n\nstatic int\nsmb_init_no_reconnect(int smb_command, int wct, struct cifs_tcon *tcon,\n\t\t\tvoid **request_buf, void **response_buf)\n{\n\tif (tcon->ses->need_reconnect || tcon->need_reconnect)\n\t\treturn -EHOSTDOWN;\n\n\treturn __smb_init(smb_command, wct, tcon, request_buf, response_buf);\n}\n\nstatic int validate_t2(struct smb_t2_rsp *pSMB)\n{\n\tunsigned int total_size;\n\n\t/* check for plausible wct */\n\tif (pSMB->hdr.WordCount < 10)\n\t\tgoto vt2_err;\n\n\t/* check for parm and data offset going beyond end of smb */\n\tif (get_unaligned_le16(&pSMB->t2_rsp.ParameterOffset) > 1024 ||\n\t    get_unaligned_le16(&pSMB->t2_rsp.DataOffset) > 1024)\n\t\tgoto vt2_err;\n\n\ttotal_size = get_unaligned_le16(&pSMB->t2_rsp.ParameterCount);\n\tif (total_size >= 512)\n\t\tgoto vt2_err;\n\n\t/* check that bcc is at least as big as parms + data, and that it is\n\t * less than negotiated smb buffer\n\t */\n\ttotal_size += get_unaligned_le16(&pSMB->t2_rsp.DataCount);\n\tif (total_size > get_bcc(&pSMB->hdr) ||\n\t    total_size >= CIFSMaxBufSize + MAX_CIFS_HDR_SIZE)\n\t\tgoto vt2_err;\n\n\treturn 0;\nvt2_err:\n\tcifs_dump_mem(\"Invalid transact2 SMB: \", (char *)pSMB,\n\t\tsizeof(struct smb_t2_rsp) + 16);\n\treturn -EINVAL;\n}\n\nstatic inline void inc_rfc1001_len(void *pSMB, int count)\n{\n\tstruct smb_hdr *hdr = (struct smb_hdr *)pSMB;\n\n\tbe32_add_cpu(&hdr->smb_buf_length, count);\n}\n\nint\nCIFSSMBNegotiate(unsigned int xid, struct cifs_ses *ses)\n{\n\tNEGOTIATE_REQ *pSMB;\n\tNEGOTIATE_RSP *pSMBr;\n\tint rc = 0;\n\tint bytes_returned;\n\tint i;\n\tstruct TCP_Server_Info *server;\n\tu16 count;\n\tunsigned int secFlags;\n\n\tif (ses->server)\n\t\tserver = ses->server;\n\telse {\n\t\trc = -EIO;\n\t\treturn rc;\n\t}\n\trc = smb_init(SMB_COM_NEGOTIATE, 0, NULL /* no tcon yet */ ,\n\t\t      (void **) &pSMB, (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\t/* if any of auth flags (ie not sign or seal) are overriden use them */\n\tif (ses->overrideSecFlg & (~(CIFSSEC_MUST_SIGN | CIFSSEC_MUST_SEAL)))\n\t\tsecFlags = ses->overrideSecFlg;  /* BB FIXME fix sign flags? */\n\telse /* if override flags set only sign/seal OR them with global auth */\n\t\tsecFlags = global_secflags | ses->overrideSecFlg;\n\n\tcFYI(1, \"secFlags 0x%x\", secFlags);\n\n\tpSMB->hdr.Mid = GetNextMid(server);\n\tpSMB->hdr.Flags2 |= (SMBFLG2_UNICODE | SMBFLG2_ERR_STATUS);\n\n\tif ((secFlags & CIFSSEC_MUST_KRB5) == CIFSSEC_MUST_KRB5)\n\t\tpSMB->hdr.Flags2 |= SMBFLG2_EXT_SEC;\n\telse if ((secFlags & CIFSSEC_AUTH_MASK) == CIFSSEC_MAY_KRB5) {\n\t\tcFYI(1, \"Kerberos only mechanism, enable extended security\");\n\t\tpSMB->hdr.Flags2 |= SMBFLG2_EXT_SEC;\n\t} else if ((secFlags & CIFSSEC_MUST_NTLMSSP) == CIFSSEC_MUST_NTLMSSP)\n\t\tpSMB->hdr.Flags2 |= SMBFLG2_EXT_SEC;\n\telse if ((secFlags & CIFSSEC_AUTH_MASK) == CIFSSEC_MAY_NTLMSSP) {\n\t\tcFYI(1, \"NTLMSSP only mechanism, enable extended security\");\n\t\tpSMB->hdr.Flags2 |= SMBFLG2_EXT_SEC;\n\t}\n\n\tcount = 0;\n\tfor (i = 0; i < CIFS_NUM_PROT; i++) {\n\t\tstrncpy(pSMB->DialectsArray+count, protocols[i].name, 16);\n\t\tcount += strlen(protocols[i].name) + 1;\n\t\t/* null at end of source and target buffers anyway */\n\t}\n\tinc_rfc1001_len(pSMB, count);\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\trc = SendReceive(xid, ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc != 0)\n\t\tgoto neg_err_exit;\n\n\tserver->dialect = le16_to_cpu(pSMBr->DialectIndex);\n\tcFYI(1, \"Dialect: %d\", server->dialect);\n\t/* Check wct = 1 error case */\n\tif ((pSMBr->hdr.WordCount < 13) || (server->dialect == BAD_PROT)) {\n\t\t/* core returns wct = 1, but we do not ask for core - otherwise\n\t\tsmall wct just comes when dialect index is -1 indicating we\n\t\tcould not negotiate a common dialect */\n\t\trc = -EOPNOTSUPP;\n\t\tgoto neg_err_exit;\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\n\t} else if ((pSMBr->hdr.WordCount == 13)\n\t\t\t&& ((server->dialect == LANMAN_PROT)\n\t\t\t\t|| (server->dialect == LANMAN2_PROT))) {\n\t\t__s16 tmp;\n\t\tstruct lanman_neg_rsp *rsp = (struct lanman_neg_rsp *)pSMBr;\n\n\t\tif ((secFlags & CIFSSEC_MAY_LANMAN) ||\n\t\t\t(secFlags & CIFSSEC_MAY_PLNTXT))\n\t\t\tserver->secType = LANMAN;\n\t\telse {\n\t\t\tcERROR(1, \"mount failed weak security disabled\"\n\t\t\t\t   \" in /proc/fs/cifs/SecurityFlags\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto neg_err_exit;\n\t\t}\n\t\tserver->sec_mode = (__u8)le16_to_cpu(rsp->SecurityMode);\n\t\tserver->maxReq = le16_to_cpu(rsp->MaxMpxCount);\n\t\tserver->maxBuf = min((__u32)le16_to_cpu(rsp->MaxBufSize),\n\t\t\t\t(__u32)CIFSMaxBufSize + MAX_CIFS_HDR_SIZE);\n\t\tserver->max_vcs = le16_to_cpu(rsp->MaxNumberVcs);\n\t\t/* even though we do not use raw we might as well set this\n\t\taccurately, in case we ever find a need for it */\n\t\tif ((le16_to_cpu(rsp->RawMode) & RAW_ENABLE) == RAW_ENABLE) {\n\t\t\tserver->max_rw = 0xFF00;\n\t\t\tserver->capabilities = CAP_MPX_MODE | CAP_RAW_MODE;\n\t\t} else {\n\t\t\tserver->max_rw = 0;/* do not need to use raw anyway */\n\t\t\tserver->capabilities = CAP_MPX_MODE;\n\t\t}\n\t\ttmp = (__s16)le16_to_cpu(rsp->ServerTimeZone);\n\t\tif (tmp == -1) {\n\t\t\t/* OS/2 often does not set timezone therefore\n\t\t\t * we must use server time to calc time zone.\n\t\t\t * Could deviate slightly from the right zone.\n\t\t\t * Smallest defined timezone difference is 15 minutes\n\t\t\t * (i.e. Nepal).  Rounding up/down is done to match\n\t\t\t * this requirement.\n\t\t\t */\n\t\t\tint val, seconds, remain, result;\n\t\t\tstruct timespec ts, utc;\n\t\t\tutc = CURRENT_TIME;\n\t\t\tts = cnvrtDosUnixTm(rsp->SrvTime.Date,\n\t\t\t\t\t    rsp->SrvTime.Time, 0);\n\t\t\tcFYI(1, \"SrvTime %d sec since 1970 (utc: %d) diff: %d\",\n\t\t\t\t(int)ts.tv_sec, (int)utc.tv_sec,\n\t\t\t\t(int)(utc.tv_sec - ts.tv_sec));\n\t\t\tval = (int)(utc.tv_sec - ts.tv_sec);\n\t\t\tseconds = abs(val);\n\t\t\tresult = (seconds / MIN_TZ_ADJ) * MIN_TZ_ADJ;\n\t\t\tremain = seconds % MIN_TZ_ADJ;\n\t\t\tif (remain >= (MIN_TZ_ADJ / 2))\n\t\t\t\tresult += MIN_TZ_ADJ;\n\t\t\tif (val < 0)\n\t\t\t\tresult = -result;\n\t\t\tserver->timeAdj = result;\n\t\t} else {\n\t\t\tserver->timeAdj = (int)tmp;\n\t\t\tserver->timeAdj *= 60; /* also in seconds */\n\t\t}\n\t\tcFYI(1, \"server->timeAdj: %d seconds\", server->timeAdj);\n\n\n\t\t/* BB get server time for time conversions and add\n\t\tcode to use it and timezone since this is not UTC */\n\n\t\tif (rsp->EncryptionKeyLength ==\n\t\t\t\tcpu_to_le16(CIFS_CRYPTO_KEY_SIZE)) {\n\t\t\tmemcpy(ses->server->cryptkey, rsp->EncryptionKey,\n\t\t\t\tCIFS_CRYPTO_KEY_SIZE);\n\t\t} else if (server->sec_mode & SECMODE_PW_ENCRYPT) {\n\t\t\trc = -EIO; /* need cryptkey unless plain text */\n\t\t\tgoto neg_err_exit;\n\t\t}\n\n\t\tcFYI(1, \"LANMAN negotiated\");\n\t\t/* we will not end up setting signing flags - as no signing\n\t\twas in LANMAN and server did not return the flags on */\n\t\tgoto signing_check;\n#else /* weak security disabled */\n\t} else if (pSMBr->hdr.WordCount == 13) {\n\t\tcERROR(1, \"mount failed, cifs module not built \"\n\t\t\t  \"with CIFS_WEAK_PW_HASH support\");\n\t\trc = -EOPNOTSUPP;\n#endif /* WEAK_PW_HASH */\n\t\tgoto neg_err_exit;\n\t} else if (pSMBr->hdr.WordCount != 17) {\n\t\t/* unknown wct */\n\t\trc = -EOPNOTSUPP;\n\t\tgoto neg_err_exit;\n\t}\n\t/* else wct == 17 NTLM */\n\tserver->sec_mode = pSMBr->SecurityMode;\n\tif ((server->sec_mode & SECMODE_USER) == 0)\n\t\tcFYI(1, \"share mode security\");\n\n\tif ((server->sec_mode & SECMODE_PW_ENCRYPT) == 0)\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\n\t\tif ((secFlags & CIFSSEC_MAY_PLNTXT) == 0)\n#endif /* CIFS_WEAK_PW_HASH */\n\t\t\tcERROR(1, \"Server requests plain text password\"\n\t\t\t\t  \" but client support disabled\");\n\n\tif ((secFlags & CIFSSEC_MUST_NTLMV2) == CIFSSEC_MUST_NTLMV2)\n\t\tserver->secType = NTLMv2;\n\telse if (secFlags & CIFSSEC_MAY_NTLM)\n\t\tserver->secType = NTLM;\n\telse if (secFlags & CIFSSEC_MAY_NTLMV2)\n\t\tserver->secType = NTLMv2;\n\telse if (secFlags & CIFSSEC_MAY_KRB5)\n\t\tserver->secType = Kerberos;\n\telse if (secFlags & CIFSSEC_MAY_NTLMSSP)\n\t\tserver->secType = RawNTLMSSP;\n\telse if (secFlags & CIFSSEC_MAY_LANMAN)\n\t\tserver->secType = LANMAN;\n\telse {\n\t\trc = -EOPNOTSUPP;\n\t\tcERROR(1, \"Invalid security type\");\n\t\tgoto neg_err_exit;\n\t}\n\t/* else ... any others ...? */\n\n\t/* one byte, so no need to convert this or EncryptionKeyLen from\n\t   little endian */\n\tserver->maxReq = le16_to_cpu(pSMBr->MaxMpxCount);\n\t/* probably no need to store and check maxvcs */\n\tserver->maxBuf = min(le32_to_cpu(pSMBr->MaxBufferSize),\n\t\t\t(__u32) CIFSMaxBufSize + MAX_CIFS_HDR_SIZE);\n\tserver->max_rw = le32_to_cpu(pSMBr->MaxRawSize);\n\tcFYI(DBG2, \"Max buf = %d\", ses->server->maxBuf);\n\tserver->capabilities = le32_to_cpu(pSMBr->Capabilities);\n\tserver->timeAdj = (int)(__s16)le16_to_cpu(pSMBr->ServerTimeZone);\n\tserver->timeAdj *= 60;\n\tif (pSMBr->EncryptionKeyLength == CIFS_CRYPTO_KEY_SIZE) {\n\t\tmemcpy(ses->server->cryptkey, pSMBr->u.EncryptionKey,\n\t\t       CIFS_CRYPTO_KEY_SIZE);\n\t} else if ((pSMBr->hdr.Flags2 & SMBFLG2_EXT_SEC ||\n\t\t\tserver->capabilities & CAP_EXTENDED_SECURITY) &&\n\t\t\t\t(pSMBr->EncryptionKeyLength == 0)) {\n\t\t/* decode security blob */\n\t\tcount = get_bcc(&pSMBr->hdr);\n\t\tif (count < 16) {\n\t\t\trc = -EIO;\n\t\t\tgoto neg_err_exit;\n\t\t}\n\t\tspin_lock(&cifs_tcp_ses_lock);\n\t\tif (server->srv_count > 1) {\n\t\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\t\tif (memcmp(server->server_GUID,\n\t\t\t\t   pSMBr->u.extended_response.\n\t\t\t\t   GUID, 16) != 0) {\n\t\t\t\tcFYI(1, \"server UID changed\");\n\t\t\t\tmemcpy(server->server_GUID,\n\t\t\t\t\tpSMBr->u.extended_response.GUID,\n\t\t\t\t\t16);\n\t\t\t}\n\t\t} else {\n\t\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\t\tmemcpy(server->server_GUID,\n\t\t\t       pSMBr->u.extended_response.GUID, 16);\n\t\t}\n\n\t\tif (count == 16) {\n\t\t\tserver->secType = RawNTLMSSP;\n\t\t} else {\n\t\t\trc = decode_negTokenInit(pSMBr->u.extended_response.\n\t\t\t\t\t\t SecurityBlob, count - 16,\n\t\t\t\t\t\t server);\n\t\t\tif (rc == 1)\n\t\t\t\trc = 0;\n\t\t\telse\n\t\t\t\trc = -EINVAL;\n\t\t\tif (server->secType == Kerberos) {\n\t\t\t\tif (!server->sec_kerberos &&\n\t\t\t\t\t\t!server->sec_mskerberos)\n\t\t\t\t\trc = -EOPNOTSUPP;\n\t\t\t} else if (server->secType == RawNTLMSSP) {\n\t\t\t\tif (!server->sec_ntlmssp)\n\t\t\t\t\trc = -EOPNOTSUPP;\n\t\t\t} else\n\t\t\t\t\trc = -EOPNOTSUPP;\n\t\t}\n\t} else if (server->sec_mode & SECMODE_PW_ENCRYPT) {\n\t\trc = -EIO; /* no crypt key only if plain text pwd */\n\t\tgoto neg_err_exit;\n\t} else\n\t\tserver->capabilities &= ~CAP_EXTENDED_SECURITY;\n\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\nsigning_check:\n#endif\n\tif ((secFlags & CIFSSEC_MAY_SIGN) == 0) {\n\t\t/* MUST_SIGN already includes the MAY_SIGN FLAG\n\t\t   so if this is zero it means that signing is disabled */\n\t\tcFYI(1, \"Signing disabled\");\n\t\tif (server->sec_mode & SECMODE_SIGN_REQUIRED) {\n\t\t\tcERROR(1, \"Server requires \"\n\t\t\t\t   \"packet signing to be enabled in \"\n\t\t\t\t   \"/proc/fs/cifs/SecurityFlags.\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t}\n\t\tserver->sec_mode &=\n\t\t\t~(SECMODE_SIGN_ENABLED | SECMODE_SIGN_REQUIRED);\n\t} else if ((secFlags & CIFSSEC_MUST_SIGN) == CIFSSEC_MUST_SIGN) {\n\t\t/* signing required */\n\t\tcFYI(1, \"Must sign - secFlags 0x%x\", secFlags);\n\t\tif ((server->sec_mode &\n\t\t\t(SECMODE_SIGN_ENABLED | SECMODE_SIGN_REQUIRED)) == 0) {\n\t\t\tcERROR(1, \"signing required but server lacks support\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t} else\n\t\t\tserver->sec_mode |= SECMODE_SIGN_REQUIRED;\n\t} else {\n\t\t/* signing optional ie CIFSSEC_MAY_SIGN */\n\t\tif ((server->sec_mode & SECMODE_SIGN_REQUIRED) == 0)\n\t\t\tserver->sec_mode &=\n\t\t\t\t~(SECMODE_SIGN_ENABLED | SECMODE_SIGN_REQUIRED);\n\t}\n\nneg_err_exit:\n\tcifs_buf_release(pSMB);\n\n\tcFYI(1, \"negprot rc %d\", rc);\n\treturn rc;\n}\n\nint\nCIFSSMBTDis(const int xid, struct cifs_tcon *tcon)\n{\n\tstruct smb_hdr *smb_buffer;\n\tint rc = 0;\n\n\tcFYI(1, \"In tree disconnect\");\n\n\t/* BB: do we need to check this? These should never be NULL. */\n\tif ((tcon->ses == NULL) || (tcon->ses->server == NULL))\n\t\treturn -EIO;\n\n\t/*\n\t * No need to return error on this operation if tid invalidated and\n\t * closed on server already e.g. due to tcp session crashing. Also,\n\t * the tcon is no longer on the list, so no need to take lock before\n\t * checking this.\n\t */\n\tif ((tcon->need_reconnect) || (tcon->ses->need_reconnect))\n\t\treturn 0;\n\n\trc = small_smb_init(SMB_COM_TREE_DISCONNECT, 0, tcon,\n\t\t\t    (void **)&smb_buffer);\n\tif (rc)\n\t\treturn rc;\n\n\trc = SendReceiveNoRsp(xid, tcon->ses, smb_buffer, 0);\n\tif (rc)\n\t\tcFYI(1, \"Tree disconnect failed %d\", rc);\n\n\t/* No need to return error on this operation if tid invalidated and\n\t   closed on server already e.g. due to tcp session crashing */\n\tif (rc == -EAGAIN)\n\t\trc = 0;\n\n\treturn rc;\n}\n\n/*\n * This is a no-op for now. We're not really interested in the reply, but\n * rather in the fact that the server sent one and that server->lstrp\n * gets updated.\n *\n * FIXME: maybe we should consider checking that the reply matches request?\n */\nstatic void\ncifs_echo_callback(struct mid_q_entry *mid)\n{\n\tstruct TCP_Server_Info *server = mid->callback_data;\n\n\tDeleteMidQEntry(mid);\n\tatomic_dec(&server->inFlight);\n\twake_up(&server->request_q);\n}\n\nint\nCIFSSMBEcho(struct TCP_Server_Info *server)\n{\n\tECHO_REQ *smb;\n\tint rc = 0;\n\tstruct kvec iov;\n\n\tcFYI(1, \"In echo request\");\n\n\trc = small_smb_init(SMB_COM_ECHO, 0, NULL, (void **)&smb);\n\tif (rc)\n\t\treturn rc;\n\n\t/* set up echo request */\n\tsmb->hdr.Tid = 0xffff;\n\tsmb->hdr.WordCount = 1;\n\tput_unaligned_le16(1, &smb->EchoCount);\n\tput_bcc(1, &smb->hdr);\n\tsmb->Data[0] = 'a';\n\tinc_rfc1001_len(smb, 3);\n\tiov.iov_base = smb;\n\tiov.iov_len = be32_to_cpu(smb->hdr.smb_buf_length) + 4;\n\n\trc = cifs_call_async(server, &iov, 1, cifs_echo_callback, server, true);\n\tif (rc)\n\t\tcFYI(1, \"Echo request failed: %d\", rc);\n\n\tcifs_small_buf_release(smb);\n\n\treturn rc;\n}\n\nint\nCIFSSMBLogoff(const int xid, struct cifs_ses *ses)\n{\n\tLOGOFF_ANDX_REQ *pSMB;\n\tint rc = 0;\n\n\tcFYI(1, \"In SMBLogoff for session disconnect\");\n\n\t/*\n\t * BB: do we need to check validity of ses and server? They should\n\t * always be valid since we have an active reference. If not, that\n\t * should probably be a BUG()\n\t */\n\tif (!ses || !ses->server)\n\t\treturn -EIO;\n\n\tmutex_lock(&ses->session_mutex);\n\tif (ses->need_reconnect)\n\t\tgoto session_already_dead; /* no need to send SMBlogoff if uid\n\t\t\t\t\t      already closed due to reconnect */\n\trc = small_smb_init(SMB_COM_LOGOFF_ANDX, 2, NULL, (void **)&pSMB);\n\tif (rc) {\n\t\tmutex_unlock(&ses->session_mutex);\n\t\treturn rc;\n\t}\n\n\tpSMB->hdr.Mid = GetNextMid(ses->server);\n\n\tif (ses->server->sec_mode &\n\t\t   (SECMODE_SIGN_REQUIRED | SECMODE_SIGN_ENABLED))\n\t\t\tpSMB->hdr.Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\n\tpSMB->hdr.Uid = ses->Suid;\n\n\tpSMB->AndXCommand = 0xFF;\n\trc = SendReceiveNoRsp(xid, ses, (struct smb_hdr *) pSMB, 0);\nsession_already_dead:\n\tmutex_unlock(&ses->session_mutex);\n\n\t/* if session dead then we do not need to do ulogoff,\n\t\tsince server closed smb session, no sense reporting\n\t\terror */\n\tif (rc == -EAGAIN)\n\t\trc = 0;\n\treturn rc;\n}\n\nint\nCIFSPOSIXDelFile(const int xid, struct cifs_tcon *tcon, const char *fileName,\n\t\t __u16 type, const struct nls_table *nls_codepage, int remap)\n{\n\tTRANSACTION2_SPI_REQ *pSMB = NULL;\n\tTRANSACTION2_SPI_RSP *pSMBr = NULL;\n\tstruct unlink_psx_rq *pRqD;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, param_offset, offset, byte_count;\n\n\tcFYI(1, \"In POSIX delete\");\nPsxDelete:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUCS((__le16 *) pSMB->FileName, fileName,\n\t\t\t\t     PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else { /* BB add path length overrun check */\n\t\tname_len = strnlen(fileName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, fileName, name_len);\n\t}\n\n\tparams = 6 + name_len;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = 0; /* BB double check this with jra */\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\n\t/* Setup pointer to Request Data (inode type) */\n\tpRqD = (struct unlink_psx_rq *)(((char *)&pSMB->hdr.Protocol) + offset);\n\tpRqD->type = cpu_to_le16(type);\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + sizeof(struct unlink_psx_rq);\n\n\tpSMB->DataCount = cpu_to_le16(sizeof(struct unlink_psx_rq));\n\tpSMB->TotalDataCount = cpu_to_le16(sizeof(struct unlink_psx_rq));\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_POSIX_UNLINK);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcFYI(1, \"Posix delete returned %d\", rc);\n\tcifs_buf_release(pSMB);\n\n\tcifs_stats_inc(&tcon->num_deletes);\n\n\tif (rc == -EAGAIN)\n\t\tgoto PsxDelete;\n\n\treturn rc;\n}\n\nint\nCIFSSMBDelFile(const int xid, struct cifs_tcon *tcon, const char *fileName,\n\t       const struct nls_table *nls_codepage, int remap)\n{\n\tDELETE_FILE_REQ *pSMB = NULL;\n\tDELETE_FILE_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\nDelFileRetry:\n\trc = smb_init(SMB_COM_DELETE, 1, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUCS((__le16 *) pSMB->fileName, fileName,\n\t\t\t\t     PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t\t/* BB improve check for buffer overruns BB */\n\t\tname_len = strnlen(fileName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->fileName, fileName, name_len);\n\t}\n\tpSMB->SearchAttributes =\n\t    cpu_to_le16(ATTR_READONLY | ATTR_HIDDEN | ATTR_SYSTEM);\n\tpSMB->BufferFormat = 0x04;\n\tinc_rfc1001_len(pSMB, name_len + 1);\n\tpSMB->ByteCount = cpu_to_le16(name_len + 1);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->num_deletes);\n\tif (rc)\n\t\tcFYI(1, \"Error in RMFile = %d\", rc);\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto DelFileRetry;\n\n\treturn rc;\n}\n\nint\nCIFSSMBRmDir(const int xid, struct cifs_tcon *tcon, const char *dirName,\n\t     const struct nls_table *nls_codepage, int remap)\n{\n\tDELETE_DIRECTORY_REQ *pSMB = NULL;\n\tDELETE_DIRECTORY_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\n\tcFYI(1, \"In CIFSSMBRmDir\");\nRmDirRetry:\n\trc = smb_init(SMB_COM_DELETE_DIRECTORY, 0, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len = cifsConvertToUCS((__le16 *) pSMB->DirName, dirName,\n\t\t\t\t\t PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t\t/* BB improve check for buffer overruns BB */\n\t\tname_len = strnlen(dirName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->DirName, dirName, name_len);\n\t}\n\n\tpSMB->BufferFormat = 0x04;\n\tinc_rfc1001_len(pSMB, name_len + 1);\n\tpSMB->ByteCount = cpu_to_le16(name_len + 1);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->num_rmdirs);\n\tif (rc)\n\t\tcFYI(1, \"Error in RMDir = %d\", rc);\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto RmDirRetry;\n\treturn rc;\n}\n\nint\nCIFSSMBMkDir(const int xid, struct cifs_tcon *tcon,\n\t     const char *name, const struct nls_table *nls_codepage, int remap)\n{\n\tint rc = 0;\n\tCREATE_DIRECTORY_REQ *pSMB = NULL;\n\tCREATE_DIRECTORY_RSP *pSMBr = NULL;\n\tint bytes_returned;\n\tint name_len;\n\n\tcFYI(1, \"In CIFSSMBMkDir\");\nMkDirRetry:\n\trc = smb_init(SMB_COM_CREATE_DIRECTORY, 0, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len = cifsConvertToUCS((__le16 *) pSMB->DirName, name,\n\t\t\t\t\t    PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t\t/* BB improve check for buffer overruns BB */\n\t\tname_len = strnlen(name, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->DirName, name, name_len);\n\t}\n\n\tpSMB->BufferFormat = 0x04;\n\tinc_rfc1001_len(pSMB, name_len + 1);\n\tpSMB->ByteCount = cpu_to_le16(name_len + 1);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->num_mkdirs);\n\tif (rc)\n\t\tcFYI(1, \"Error in Mkdir = %d\", rc);\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto MkDirRetry;\n\treturn rc;\n}\n\nint\nCIFSPOSIXCreate(const int xid, struct cifs_tcon *tcon, __u32 posix_flags,\n\t\t__u64 mode, __u16 *netfid, FILE_UNIX_BASIC_INFO *pRetData,\n\t\t__u32 *pOplock, const char *name,\n\t\tconst struct nls_table *nls_codepage, int remap)\n{\n\tTRANSACTION2_SPI_REQ *pSMB = NULL;\n\tTRANSACTION2_SPI_RSP *pSMBr = NULL;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, param_offset, offset, byte_count, count;\n\tOPEN_PSX_REQ *pdata;\n\tOPEN_PSX_RSP *psx_rsp;\n\n\tcFYI(1, \"In POSIX Create\");\nPsxCreat:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUCS((__le16 *) pSMB->FileName, name,\n\t\t\t\t     PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(name, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, name, name_len);\n\t}\n\n\tparams = 6 + name_len;\n\tcount = sizeof(OPEN_PSX_REQ);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\t/* large enough */\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\tpdata = (OPEN_PSX_REQ *)(((char *)&pSMB->hdr.Protocol) + offset);\n\tpdata->Level = cpu_to_le16(SMB_QUERY_FILE_UNIX_BASIC);\n\tpdata->Permissions = cpu_to_le64(mode);\n\tpdata->PosixOpenFlags = cpu_to_le32(posix_flags);\n\tpdata->OpenFlags =  cpu_to_le32(*pOplock);\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_POSIX_OPEN);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcFYI(1, \"Posix create returned %d\", rc);\n\t\tgoto psx_create_err;\n\t}\n\n\tcFYI(1, \"copying inode info\");\n\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\tif (rc || get_bcc(&pSMBr->hdr) < sizeof(OPEN_PSX_RSP)) {\n\t\trc = -EIO;\t/* bad smb */\n\t\tgoto psx_create_err;\n\t}\n\n\t/* copy return information to pRetData */\n\tpsx_rsp = (OPEN_PSX_RSP *)((char *) &pSMBr->hdr.Protocol\n\t\t\t+ le16_to_cpu(pSMBr->t2.DataOffset));\n\n\t*pOplock = le16_to_cpu(psx_rsp->OplockFlags);\n\tif (netfid)\n\t\t*netfid = psx_rsp->Fid;   /* cifs fid stays in le */\n\t/* Let caller know file was created so we can set the mode. */\n\t/* Do we care about the CreateAction in any other cases? */\n\tif (cpu_to_le32(FILE_CREATE) == psx_rsp->CreateAction)\n\t\t*pOplock |= CIFS_CREATE_ACTION;\n\t/* check to make sure response data is there */\n\tif (psx_rsp->ReturnedLevel != cpu_to_le16(SMB_QUERY_FILE_UNIX_BASIC)) {\n\t\tpRetData->Type = cpu_to_le32(-1); /* unknown */\n\t\tcFYI(DBG2, \"unknown type\");\n\t} else {\n\t\tif (get_bcc(&pSMBr->hdr) < sizeof(OPEN_PSX_RSP)\n\t\t\t\t\t+ sizeof(FILE_UNIX_BASIC_INFO)) {\n\t\t\tcERROR(1, \"Open response data too small\");\n\t\t\tpRetData->Type = cpu_to_le32(-1);\n\t\t\tgoto psx_create_err;\n\t\t}\n\t\tmemcpy((char *) pRetData,\n\t\t\t(char *)psx_rsp + sizeof(OPEN_PSX_RSP),\n\t\t\tsizeof(FILE_UNIX_BASIC_INFO));\n\t}\n\npsx_create_err:\n\tcifs_buf_release(pSMB);\n\n\tif (posix_flags & SMB_O_DIRECTORY)\n\t\tcifs_stats_inc(&tcon->num_posixmkdirs);\n\telse\n\t\tcifs_stats_inc(&tcon->num_posixopens);\n\n\tif (rc == -EAGAIN)\n\t\tgoto PsxCreat;\n\n\treturn rc;\n}\n\nstatic __u16 convert_disposition(int disposition)\n{\n\t__u16 ofun = 0;\n\n\tswitch (disposition) {\n\t\tcase FILE_SUPERSEDE:\n\t\t\tofun = SMBOPEN_OCREATE | SMBOPEN_OTRUNC;\n\t\t\tbreak;\n\t\tcase FILE_OPEN:\n\t\t\tofun = SMBOPEN_OAPPEND;\n\t\t\tbreak;\n\t\tcase FILE_CREATE:\n\t\t\tofun = SMBOPEN_OCREATE;\n\t\t\tbreak;\n\t\tcase FILE_OPEN_IF:\n\t\t\tofun = SMBOPEN_OCREATE | SMBOPEN_OAPPEND;\n\t\t\tbreak;\n\t\tcase FILE_OVERWRITE:\n\t\t\tofun = SMBOPEN_OTRUNC;\n\t\t\tbreak;\n\t\tcase FILE_OVERWRITE_IF:\n\t\t\tofun = SMBOPEN_OCREATE | SMBOPEN_OTRUNC;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcFYI(1, \"unknown disposition %d\", disposition);\n\t\t\tofun =  SMBOPEN_OAPPEND; /* regular open */\n\t}\n\treturn ofun;\n}\n\nstatic int\naccess_flags_to_smbopen_mode(const int access_flags)\n{\n\tint masked_flags = access_flags & (GENERIC_READ | GENERIC_WRITE);\n\n\tif (masked_flags == GENERIC_READ)\n\t\treturn SMBOPEN_READ;\n\telse if (masked_flags == GENERIC_WRITE)\n\t\treturn SMBOPEN_WRITE;\n\n\t/* just go for read/write */\n\treturn SMBOPEN_READWRITE;\n}\n\nint\nSMBLegacyOpen(const int xid, struct cifs_tcon *tcon,\n\t    const char *fileName, const int openDisposition,\n\t    const int access_flags, const int create_options, __u16 *netfid,\n\t    int *pOplock, FILE_ALL_INFO *pfile_info,\n\t    const struct nls_table *nls_codepage, int remap)\n{\n\tint rc = -EACCES;\n\tOPENX_REQ *pSMB = NULL;\n\tOPENX_RSP *pSMBr = NULL;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 count;\n\nOldOpenRetry:\n\trc = smb_init(SMB_COM_OPEN_ANDX, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->AndXCommand = 0xFF;       /* none */\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tcount = 1;      /* account for one byte pad to word boundary */\n\t\tname_len =\n\t\t   cifsConvertToUCS((__le16 *) (pSMB->fileName + 1),\n\t\t\t\t    fileName, PATH_MAX, nls_codepage, remap);\n\t\tname_len++;     /* trailing null */\n\t\tname_len *= 2;\n\t} else {                /* BB improve check for buffer overruns BB */\n\t\tcount = 0;      /* no pad */\n\t\tname_len = strnlen(fileName, PATH_MAX);\n\t\tname_len++;     /* trailing null */\n\t\tstrncpy(pSMB->fileName, fileName, name_len);\n\t}\n\tif (*pOplock & REQ_OPLOCK)\n\t\tpSMB->OpenFlags = cpu_to_le16(REQ_OPLOCK);\n\telse if (*pOplock & REQ_BATCHOPLOCK)\n\t\tpSMB->OpenFlags = cpu_to_le16(REQ_BATCHOPLOCK);\n\n\tpSMB->OpenFlags |= cpu_to_le16(REQ_MORE_INFO);\n\tpSMB->Mode = cpu_to_le16(access_flags_to_smbopen_mode(access_flags));\n\tpSMB->Mode |= cpu_to_le16(0x40); /* deny none */\n\t/* set file as system file if special file such\n\t   as fifo and server expecting SFU style and\n\t   no Unix extensions */\n\n\tif (create_options & CREATE_OPTION_SPECIAL)\n\t\tpSMB->FileAttributes = cpu_to_le16(ATTR_SYSTEM);\n\telse /* BB FIXME BB */\n\t\tpSMB->FileAttributes = cpu_to_le16(0/*ATTR_NORMAL*/);\n\n\tif (create_options & CREATE_OPTION_READONLY)\n\t\tpSMB->FileAttributes |= cpu_to_le16(ATTR_READONLY);\n\n\t/* BB FIXME BB */\n/*\tpSMB->CreateOptions = cpu_to_le32(create_options &\n\t\t\t\t\t\t CREATE_OPTIONS_MASK); */\n\t/* BB FIXME END BB */\n\n\tpSMB->Sattr = cpu_to_le16(ATTR_HIDDEN | ATTR_SYSTEM | ATTR_DIRECTORY);\n\tpSMB->OpenFunction = cpu_to_le16(convert_disposition(openDisposition));\n\tcount += name_len;\n\tinc_rfc1001_len(pSMB, count);\n\n\tpSMB->ByteCount = cpu_to_le16(count);\n\t/* long_op set to 1 to allow for oplock break timeouts */\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *)pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->num_opens);\n\tif (rc) {\n\t\tcFYI(1, \"Error in Open = %d\", rc);\n\t} else {\n\t/* BB verify if wct == 15 */\n\n/*\t\t*pOplock = pSMBr->OplockLevel; */ /* BB take from action field*/\n\n\t\t*netfid = pSMBr->Fid;   /* cifs fid stays in le */\n\t\t/* Let caller know file was created so we can set the mode. */\n\t\t/* Do we care about the CreateAction in any other cases? */\n\t/* BB FIXME BB */\n/*\t\tif (cpu_to_le32(FILE_CREATE) == pSMBr->CreateAction)\n\t\t\t*pOplock |= CIFS_CREATE_ACTION; */\n\t/* BB FIXME END */\n\n\t\tif (pfile_info) {\n\t\t\tpfile_info->CreationTime = 0; /* BB convert CreateTime*/\n\t\t\tpfile_info->LastAccessTime = 0; /* BB fixme */\n\t\t\tpfile_info->LastWriteTime = 0; /* BB fixme */\n\t\t\tpfile_info->ChangeTime = 0;  /* BB fixme */\n\t\t\tpfile_info->Attributes =\n\t\t\t\tcpu_to_le32(le16_to_cpu(pSMBr->FileAttributes));\n\t\t\t/* the file_info buf is endian converted by caller */\n\t\t\tpfile_info->AllocationSize =\n\t\t\t\tcpu_to_le64(le32_to_cpu(pSMBr->EndOfFile));\n\t\t\tpfile_info->EndOfFile = pfile_info->AllocationSize;\n\t\t\tpfile_info->NumberOfLinks = cpu_to_le32(1);\n\t\t\tpfile_info->DeletePending = 0;\n\t\t}\n\t}\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto OldOpenRetry;\n\treturn rc;\n}\n\nint\nCIFSSMBOpen(const int xid, struct cifs_tcon *tcon,\n\t    const char *fileName, const int openDisposition,\n\t    const int access_flags, const int create_options, __u16 *netfid,\n\t    int *pOplock, FILE_ALL_INFO *pfile_info,\n\t    const struct nls_table *nls_codepage, int remap)\n{\n\tint rc = -EACCES;\n\tOPEN_REQ *pSMB = NULL;\n\tOPEN_RSP *pSMBr = NULL;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 count;\n\nopenRetry:\n\trc = smb_init(SMB_COM_NT_CREATE_ANDX, 24, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->AndXCommand = 0xFF;\t/* none */\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tcount = 1;\t/* account for one byte pad to word boundary */\n\t\tname_len =\n\t\t    cifsConvertToUCS((__le16 *) (pSMB->fileName + 1),\n\t\t\t\t     fileName, PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t\tpSMB->NameLength = cpu_to_le16(name_len);\n\t} else {\t\t/* BB improve check for buffer overruns BB */\n\t\tcount = 0;\t/* no pad */\n\t\tname_len = strnlen(fileName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tpSMB->NameLength = cpu_to_le16(name_len);\n\t\tstrncpy(pSMB->fileName, fileName, name_len);\n\t}\n\tif (*pOplock & REQ_OPLOCK)\n\t\tpSMB->OpenFlags = cpu_to_le32(REQ_OPLOCK);\n\telse if (*pOplock & REQ_BATCHOPLOCK)\n\t\tpSMB->OpenFlags = cpu_to_le32(REQ_BATCHOPLOCK);\n\tpSMB->DesiredAccess = cpu_to_le32(access_flags);\n\tpSMB->AllocationSize = 0;\n\t/* set file as system file if special file such\n\t   as fifo and server expecting SFU style and\n\t   no Unix extensions */\n\tif (create_options & CREATE_OPTION_SPECIAL)\n\t\tpSMB->FileAttributes = cpu_to_le32(ATTR_SYSTEM);\n\telse\n\t\tpSMB->FileAttributes = cpu_to_le32(ATTR_NORMAL);\n\n\t/* XP does not handle ATTR_POSIX_SEMANTICS */\n\t/* but it helps speed up case sensitive checks for other\n\tservers such as Samba */\n\tif (tcon->ses->capabilities & CAP_UNIX)\n\t\tpSMB->FileAttributes |= cpu_to_le32(ATTR_POSIX_SEMANTICS);\n\n\tif (create_options & CREATE_OPTION_READONLY)\n\t\tpSMB->FileAttributes |= cpu_to_le32(ATTR_READONLY);\n\n\tpSMB->ShareAccess = cpu_to_le32(FILE_SHARE_ALL);\n\tpSMB->CreateDisposition = cpu_to_le32(openDisposition);\n\tpSMB->CreateOptions = cpu_to_le32(create_options & CREATE_OPTIONS_MASK);\n\t/* BB Expirement with various impersonation levels and verify */\n\tpSMB->ImpersonationLevel = cpu_to_le32(SECURITY_IMPERSONATION);\n\tpSMB->SecurityFlags =\n\t    SECURITY_CONTEXT_TRACKING | SECURITY_EFFECTIVE_ONLY;\n\n\tcount += name_len;\n\tinc_rfc1001_len(pSMB, count);\n\n\tpSMB->ByteCount = cpu_to_le16(count);\n\t/* long_op set to 1 to allow for oplock break timeouts */\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *)pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->num_opens);\n\tif (rc) {\n\t\tcFYI(1, \"Error in Open = %d\", rc);\n\t} else {\n\t\t*pOplock = pSMBr->OplockLevel; /* 1 byte no need to le_to_cpu */\n\t\t*netfid = pSMBr->Fid;\t/* cifs fid stays in le */\n\t\t/* Let caller know file was created so we can set the mode. */\n\t\t/* Do we care about the CreateAction in any other cases? */\n\t\tif (cpu_to_le32(FILE_CREATE) == pSMBr->CreateAction)\n\t\t\t*pOplock |= CIFS_CREATE_ACTION;\n\t\tif (pfile_info) {\n\t\t\tmemcpy((char *)pfile_info, (char *)&pSMBr->CreationTime,\n\t\t\t\t36 /* CreationTime to Attributes */);\n\t\t\t/* the file_info buf is endian converted by caller */\n\t\t\tpfile_info->AllocationSize = pSMBr->AllocationSize;\n\t\t\tpfile_info->EndOfFile = pSMBr->EndOfFile;\n\t\t\tpfile_info->NumberOfLinks = cpu_to_le32(1);\n\t\t\tpfile_info->DeletePending = 0;\n\t\t}\n\t}\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto openRetry;\n\treturn rc;\n}\n\nint\nCIFSSMBRead(const int xid, struct cifs_io_parms *io_parms, unsigned int *nbytes,\n\t    char **buf, int *pbuf_type)\n{\n\tint rc = -EACCES;\n\tREAD_REQ *pSMB = NULL;\n\tREAD_RSP *pSMBr = NULL;\n\tchar *pReadData = NULL;\n\tint wct;\n\tint resp_buf_type = 0;\n\tstruct kvec iov[1];\n\t__u32 pid = io_parms->pid;\n\t__u16 netfid = io_parms->netfid;\n\t__u64 offset = io_parms->offset;\n\tstruct cifs_tcon *tcon = io_parms->tcon;\n\tunsigned int count = io_parms->length;\n\n\tcFYI(1, \"Reading %d bytes on fid %d\", count, netfid);\n\tif (tcon->ses->capabilities & CAP_LARGE_FILES)\n\t\twct = 12;\n\telse {\n\t\twct = 10; /* old style read */\n\t\tif ((offset >> 32) > 0)  {\n\t\t\t/* can not handle this big offset for old */\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\t*nbytes = 0;\n\trc = small_smb_init(SMB_COM_READ_ANDX, wct, tcon, (void **) &pSMB);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid >> 16));\n\n\t/* tcon and ses pointer are checked in smb_init */\n\tif (tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\tpSMB->AndXCommand = 0xFF;       /* none */\n\tpSMB->Fid = netfid;\n\tpSMB->OffsetLow = cpu_to_le32(offset & 0xFFFFFFFF);\n\tif (wct == 12)\n\t\tpSMB->OffsetHigh = cpu_to_le32(offset >> 32);\n\n\tpSMB->Remaining = 0;\n\tpSMB->MaxCount = cpu_to_le16(count & 0xFFFF);\n\tpSMB->MaxCountHigh = cpu_to_le32(count >> 16);\n\tif (wct == 12)\n\t\tpSMB->ByteCount = 0;  /* no need to do le conversion since 0 */\n\telse {\n\t\t/* old style read */\n\t\tstruct smb_com_readx_req *pSMBW =\n\t\t\t(struct smb_com_readx_req *)pSMB;\n\t\tpSMBW->ByteCount = 0;\n\t}\n\n\tiov[0].iov_base = (char *)pSMB;\n\tiov[0].iov_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 4;\n\trc = SendReceive2(xid, tcon->ses, iov, 1 /* num iovecs */,\n\t\t\t &resp_buf_type, CIFS_LOG_ERROR);\n\tcifs_stats_inc(&tcon->num_reads);\n\tpSMBr = (READ_RSP *)iov[0].iov_base;\n\tif (rc) {\n\t\tcERROR(1, \"Send error in read = %d\", rc);\n\t} else {\n\t\tint data_length = le16_to_cpu(pSMBr->DataLengthHigh);\n\t\tdata_length = data_length << 16;\n\t\tdata_length += le16_to_cpu(pSMBr->DataLength);\n\t\t*nbytes = data_length;\n\n\t\t/*check that DataLength would not go beyond end of SMB */\n\t\tif ((data_length > CIFSMaxBufSize)\n\t\t\t\t|| (data_length > count)) {\n\t\t\tcFYI(1, \"bad length %d for count %d\",\n\t\t\t\t data_length, count);\n\t\t\trc = -EIO;\n\t\t\t*nbytes = 0;\n\t\t} else {\n\t\t\tpReadData = (char *) (&pSMBr->hdr.Protocol) +\n\t\t\t\t\tle16_to_cpu(pSMBr->DataOffset);\n/*\t\t\tif (rc = copy_to_user(buf, pReadData, data_length)) {\n\t\t\t\tcERROR(1, \"Faulting on read rc = %d\",rc);\n\t\t\t\trc = -EFAULT;\n\t\t\t}*/ /* can not use copy_to_user when using page cache*/\n\t\t\tif (*buf)\n\t\t\t\tmemcpy(*buf, pReadData, data_length);\n\t\t}\n\t}\n\n/*\tcifs_small_buf_release(pSMB); */ /* Freed earlier now in SendReceive2 */\n\tif (*buf) {\n\t\tif (resp_buf_type == CIFS_SMALL_BUFFER)\n\t\t\tcifs_small_buf_release(iov[0].iov_base);\n\t\telse if (resp_buf_type == CIFS_LARGE_BUFFER)\n\t\t\tcifs_buf_release(iov[0].iov_base);\n\t} else if (resp_buf_type != CIFS_NO_BUFFER) {\n\t\t/* return buffer to caller to free */\n\t\t*buf = iov[0].iov_base;\n\t\tif (resp_buf_type == CIFS_SMALL_BUFFER)\n\t\t\t*pbuf_type = CIFS_SMALL_BUFFER;\n\t\telse if (resp_buf_type == CIFS_LARGE_BUFFER)\n\t\t\t*pbuf_type = CIFS_LARGE_BUFFER;\n\t} /* else no valid buffer on return - leave as null */\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\treturn rc;\n}\n\n\nint\nCIFSSMBWrite(const int xid, struct cifs_io_parms *io_parms,\n\t     unsigned int *nbytes, const char *buf,\n\t     const char __user *ubuf, const int long_op)\n{\n\tint rc = -EACCES;\n\tWRITE_REQ *pSMB = NULL;\n\tWRITE_RSP *pSMBr = NULL;\n\tint bytes_returned, wct;\n\t__u32 bytes_sent;\n\t__u16 byte_count;\n\t__u32 pid = io_parms->pid;\n\t__u16 netfid = io_parms->netfid;\n\t__u64 offset = io_parms->offset;\n\tstruct cifs_tcon *tcon = io_parms->tcon;\n\tunsigned int count = io_parms->length;\n\n\t*nbytes = 0;\n\n\t/* cFYI(1, \"write at %lld %d bytes\", offset, count);*/\n\tif (tcon->ses == NULL)\n\t\treturn -ECONNABORTED;\n\n\tif (tcon->ses->capabilities & CAP_LARGE_FILES)\n\t\twct = 14;\n\telse {\n\t\twct = 12;\n\t\tif ((offset >> 32) > 0) {\n\t\t\t/* can not handle big offset for old srv */\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\trc = smb_init(SMB_COM_WRITE_ANDX, wct, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid >> 16));\n\n\t/* tcon and ses pointer are checked in smb_init */\n\tif (tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\tpSMB->AndXCommand = 0xFF;\t/* none */\n\tpSMB->Fid = netfid;\n\tpSMB->OffsetLow = cpu_to_le32(offset & 0xFFFFFFFF);\n\tif (wct == 14)\n\t\tpSMB->OffsetHigh = cpu_to_le32(offset >> 32);\n\n\tpSMB->Reserved = 0xFFFFFFFF;\n\tpSMB->WriteMode = 0;\n\tpSMB->Remaining = 0;\n\n\t/* Can increase buffer size if buffer is big enough in some cases ie we\n\tcan send more if LARGE_WRITE_X capability returned by the server and if\n\tour buffer is big enough or if we convert to iovecs on socket writes\n\tand eliminate the copy to the CIFS buffer */\n\tif (tcon->ses->capabilities & CAP_LARGE_WRITE_X) {\n\t\tbytes_sent = min_t(const unsigned int, CIFSMaxBufSize, count);\n\t} else {\n\t\tbytes_sent = (tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE)\n\t\t\t & ~0xFF;\n\t}\n\n\tif (bytes_sent > count)\n\t\tbytes_sent = count;\n\tpSMB->DataOffset =\n\t\tcpu_to_le16(offsetof(struct smb_com_write_req, Data) - 4);\n\tif (buf)\n\t\tmemcpy(pSMB->Data, buf, bytes_sent);\n\telse if (ubuf) {\n\t\tif (copy_from_user(pSMB->Data, ubuf, bytes_sent)) {\n\t\t\tcifs_buf_release(pSMB);\n\t\t\treturn -EFAULT;\n\t\t}\n\t} else if (count != 0) {\n\t\t/* No buffer */\n\t\tcifs_buf_release(pSMB);\n\t\treturn -EINVAL;\n\t} /* else setting file size with write of zero bytes */\n\tif (wct == 14)\n\t\tbyte_count = bytes_sent + 1; /* pad */\n\telse /* wct == 12 */\n\t\tbyte_count = bytes_sent + 5; /* bigger pad, smaller smb hdr */\n\n\tpSMB->DataLengthLow = cpu_to_le16(bytes_sent & 0xFFFF);\n\tpSMB->DataLengthHigh = cpu_to_le16(bytes_sent >> 16);\n\tinc_rfc1001_len(pSMB, byte_count);\n\n\tif (wct == 14)\n\t\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\telse { /* old style write has byte count 4 bytes earlier\n\t\t  so 4 bytes pad  */\n\t\tstruct smb_com_writex_req *pSMBW =\n\t\t\t(struct smb_com_writex_req *)pSMB;\n\t\tpSMBW->ByteCount = cpu_to_le16(byte_count);\n\t}\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, long_op);\n\tcifs_stats_inc(&tcon->num_writes);\n\tif (rc) {\n\t\tcFYI(1, \"Send error in write = %d\", rc);\n\t} else {\n\t\t*nbytes = le16_to_cpu(pSMBr->CountHigh);\n\t\t*nbytes = (*nbytes) << 16;\n\t\t*nbytes += le16_to_cpu(pSMBr->Count);\n\n\t\t/*\n\t\t * Mask off high 16 bits when bytes written as returned by the\n\t\t * server is greater than bytes requested by the client. Some\n\t\t * OS/2 servers are known to set incorrect CountHigh values.\n\t\t */\n\t\tif (*nbytes > count)\n\t\t\t*nbytes &= 0xFFFF;\n\t}\n\n\tcifs_buf_release(pSMB);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\n\treturn rc;\n}\n\nvoid\ncifs_writedata_release(struct kref *refcount)\n{\n\tstruct cifs_writedata *wdata = container_of(refcount,\n\t\t\t\t\tstruct cifs_writedata, refcount);\n\n\tif (wdata->cfile)\n\t\tcifsFileInfo_put(wdata->cfile);\n\n\tkfree(wdata);\n}\n\n/*\n * Write failed with a retryable error. Resend the write request. It's also\n * possible that the page was redirtied so re-clean the page.\n */\nstatic void\ncifs_writev_requeue(struct cifs_writedata *wdata)\n{\n\tint i, rc;\n\tstruct inode *inode = wdata->cfile->dentry->d_inode;\n\n\tfor (i = 0; i < wdata->nr_pages; i++) {\n\t\tlock_page(wdata->pages[i]);\n\t\tclear_page_dirty_for_io(wdata->pages[i]);\n\t}\n\n\tdo {\n\t\trc = cifs_async_writev(wdata);\n\t} while (rc == -EAGAIN);\n\n\tfor (i = 0; i < wdata->nr_pages; i++) {\n\t\tif (rc != 0)\n\t\t\tSetPageError(wdata->pages[i]);\n\t\tunlock_page(wdata->pages[i]);\n\t}\n\n\tmapping_set_error(inode->i_mapping, rc);\n\tkref_put(&wdata->refcount, cifs_writedata_release);\n}\n\nstatic void\ncifs_writev_complete(struct work_struct *work)\n{\n\tstruct cifs_writedata *wdata = container_of(work,\n\t\t\t\t\t\tstruct cifs_writedata, work);\n\tstruct inode *inode = wdata->cfile->dentry->d_inode;\n\tint i = 0;\n\n\tif (wdata->result == 0) {\n\t\tcifs_update_eof(CIFS_I(inode), wdata->offset, wdata->bytes);\n\t\tcifs_stats_bytes_written(tlink_tcon(wdata->cfile->tlink),\n\t\t\t\t\t wdata->bytes);\n\t} else if (wdata->sync_mode == WB_SYNC_ALL && wdata->result == -EAGAIN)\n\t\treturn cifs_writev_requeue(wdata);\n\n\tfor (i = 0; i < wdata->nr_pages; i++) {\n\t\tstruct page *page = wdata->pages[i];\n\t\tif (wdata->result == -EAGAIN)\n\t\t\t__set_page_dirty_nobuffers(page);\n\t\telse if (wdata->result < 0)\n\t\t\tSetPageError(page);\n\t\tend_page_writeback(page);\n\t\tpage_cache_release(page);\n\t}\n\tif (wdata->result != -EAGAIN)\n\t\tmapping_set_error(inode->i_mapping, wdata->result);\n\tkref_put(&wdata->refcount, cifs_writedata_release);\n}\n\nstruct cifs_writedata *\ncifs_writedata_alloc(unsigned int nr_pages)\n{\n\tstruct cifs_writedata *wdata;\n\n\t/* this would overflow */\n\tif (nr_pages == 0) {\n\t\tcERROR(1, \"%s: called with nr_pages == 0!\", __func__);\n\t\treturn NULL;\n\t}\n\n\t/* writedata + number of page pointers */\n\twdata = kzalloc(sizeof(*wdata) +\n\t\t\tsizeof(struct page *) * (nr_pages - 1), GFP_NOFS);\n\tif (wdata != NULL) {\n\t\tINIT_WORK(&wdata->work, cifs_writev_complete);\n\t\tkref_init(&wdata->refcount);\n\t}\n\treturn wdata;\n}\n\n/*\n * Check the midState and signature on received buffer (if any), and queue the\n * workqueue completion task.\n */\nstatic void\ncifs_writev_callback(struct mid_q_entry *mid)\n{\n\tstruct cifs_writedata *wdata = mid->callback_data;\n\tstruct cifs_tcon *tcon = tlink_tcon(wdata->cfile->tlink);\n\tunsigned int written;\n\tWRITE_RSP *smb = (WRITE_RSP *)mid->resp_buf;\n\n\tswitch (mid->midState) {\n\tcase MID_RESPONSE_RECEIVED:\n\t\twdata->result = cifs_check_receive(mid, tcon->ses->server, 0);\n\t\tif (wdata->result != 0)\n\t\t\tbreak;\n\n\t\twritten = le16_to_cpu(smb->CountHigh);\n\t\twritten <<= 16;\n\t\twritten += le16_to_cpu(smb->Count);\n\t\t/*\n\t\t * Mask off high 16 bits when bytes written as returned\n\t\t * by the server is greater than bytes requested by the\n\t\t * client. OS/2 servers are known to set incorrect\n\t\t * CountHigh values.\n\t\t */\n\t\tif (written > wdata->bytes)\n\t\t\twritten &= 0xFFFF;\n\n\t\tif (written < wdata->bytes)\n\t\t\twdata->result = -ENOSPC;\n\t\telse\n\t\t\twdata->bytes = written;\n\t\tbreak;\n\tcase MID_REQUEST_SUBMITTED:\n\tcase MID_RETRY_NEEDED:\n\t\twdata->result = -EAGAIN;\n\t\tbreak;\n\tdefault:\n\t\twdata->result = -EIO;\n\t\tbreak;\n\t}\n\n\tqueue_work(system_nrt_wq, &wdata->work);\n\tDeleteMidQEntry(mid);\n\tatomic_dec(&tcon->ses->server->inFlight);\n\twake_up(&tcon->ses->server->request_q);\n}\n\n/* cifs_async_writev - send an async write, and set up mid to handle result */\nint\ncifs_async_writev(struct cifs_writedata *wdata)\n{\n\tint i, rc = -EACCES;\n\tWRITE_REQ *smb = NULL;\n\tint wct;\n\tstruct cifs_tcon *tcon = tlink_tcon(wdata->cfile->tlink);\n\tstruct inode *inode = wdata->cfile->dentry->d_inode;\n\tstruct kvec *iov = NULL;\n\n\tif (tcon->ses->capabilities & CAP_LARGE_FILES) {\n\t\twct = 14;\n\t} else {\n\t\twct = 12;\n\t\tif (wdata->offset >> 32 > 0) {\n\t\t\t/* can not handle big offset for old srv */\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\trc = small_smb_init(SMB_COM_WRITE_ANDX, wct, tcon, (void **)&smb);\n\tif (rc)\n\t\tgoto async_writev_out;\n\n\t/* 1 iov per page + 1 for header */\n\tiov = kzalloc((wdata->nr_pages + 1) * sizeof(*iov), GFP_NOFS);\n\tif (iov == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto async_writev_out;\n\t}\n\n\tsmb->hdr.Pid = cpu_to_le16((__u16)wdata->cfile->pid);\n\tsmb->hdr.PidHigh = cpu_to_le16((__u16)(wdata->cfile->pid >> 16));\n\n\tsmb->AndXCommand = 0xFF;\t/* none */\n\tsmb->Fid = wdata->cfile->netfid;\n\tsmb->OffsetLow = cpu_to_le32(wdata->offset & 0xFFFFFFFF);\n\tif (wct == 14)\n\t\tsmb->OffsetHigh = cpu_to_le32(wdata->offset >> 32);\n\tsmb->Reserved = 0xFFFFFFFF;\n\tsmb->WriteMode = 0;\n\tsmb->Remaining = 0;\n\n\tsmb->DataOffset =\n\t    cpu_to_le16(offsetof(struct smb_com_write_req, Data) - 4);\n\n\t/* 4 for RFC1001 length + 1 for BCC */\n\tiov[0].iov_len = be32_to_cpu(smb->hdr.smb_buf_length) + 4 + 1;\n\tiov[0].iov_base = smb;\n\n\t/* marshal up the pages into iov array */\n\twdata->bytes = 0;\n\tfor (i = 0; i < wdata->nr_pages; i++) {\n\t\tiov[i + 1].iov_len = min(inode->i_size -\n\t\t\t\t      page_offset(wdata->pages[i]),\n\t\t\t\t\t(loff_t)PAGE_CACHE_SIZE);\n\t\tiov[i + 1].iov_base = kmap(wdata->pages[i]);\n\t\twdata->bytes += iov[i + 1].iov_len;\n\t}\n\n\tcFYI(1, \"async write at %llu %u bytes\", wdata->offset, wdata->bytes);\n\n\tsmb->DataLengthLow = cpu_to_le16(wdata->bytes & 0xFFFF);\n\tsmb->DataLengthHigh = cpu_to_le16(wdata->bytes >> 16);\n\n\tif (wct == 14) {\n\t\tinc_rfc1001_len(&smb->hdr, wdata->bytes + 1);\n\t\tput_bcc(wdata->bytes + 1, &smb->hdr);\n\t} else {\n\t\t/* wct == 12 */\n\t\tstruct smb_com_writex_req *smbw =\n\t\t\t\t(struct smb_com_writex_req *)smb;\n\t\tinc_rfc1001_len(&smbw->hdr, wdata->bytes + 5);\n\t\tput_bcc(wdata->bytes + 5, &smbw->hdr);\n\t\tiov[0].iov_len += 4; /* pad bigger by four bytes */\n\t}\n\n\tkref_get(&wdata->refcount);\n\trc = cifs_call_async(tcon->ses->server, iov, wdata->nr_pages + 1,\n\t\t\t     cifs_writev_callback, wdata, false);\n\n\tif (rc == 0)\n\t\tcifs_stats_inc(&tcon->num_writes);\n\telse\n\t\tkref_put(&wdata->refcount, cifs_writedata_release);\n\n\t/* send is done, unmap pages */\n\tfor (i = 0; i < wdata->nr_pages; i++)\n\t\tkunmap(wdata->pages[i]);\n\nasync_writev_out:\n\tcifs_small_buf_release(smb);\n\tkfree(iov);\n\treturn rc;\n}\n\nint\nCIFSSMBWrite2(const int xid, struct cifs_io_parms *io_parms,\n\t      unsigned int *nbytes, struct kvec *iov, int n_vec,\n\t      const int long_op)\n{\n\tint rc = -EACCES;\n\tWRITE_REQ *pSMB = NULL;\n\tint wct;\n\tint smb_hdr_len;\n\tint resp_buf_type = 0;\n\t__u32 pid = io_parms->pid;\n\t__u16 netfid = io_parms->netfid;\n\t__u64 offset = io_parms->offset;\n\tstruct cifs_tcon *tcon = io_parms->tcon;\n\tunsigned int count = io_parms->length;\n\n\t*nbytes = 0;\n\n\tcFYI(1, \"write2 at %lld %d bytes\", (long long)offset, count);\n\n\tif (tcon->ses->capabilities & CAP_LARGE_FILES) {\n\t\twct = 14;\n\t} else {\n\t\twct = 12;\n\t\tif ((offset >> 32) > 0) {\n\t\t\t/* can not handle big offset for old srv */\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\trc = small_smb_init(SMB_COM_WRITE_ANDX, wct, tcon, (void **) &pSMB);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid >> 16));\n\n\t/* tcon and ses pointer are checked in smb_init */\n\tif (tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\tpSMB->AndXCommand = 0xFF;\t/* none */\n\tpSMB->Fid = netfid;\n\tpSMB->OffsetLow = cpu_to_le32(offset & 0xFFFFFFFF);\n\tif (wct == 14)\n\t\tpSMB->OffsetHigh = cpu_to_le32(offset >> 32);\n\tpSMB->Reserved = 0xFFFFFFFF;\n\tpSMB->WriteMode = 0;\n\tpSMB->Remaining = 0;\n\n\tpSMB->DataOffset =\n\t    cpu_to_le16(offsetof(struct smb_com_write_req, Data) - 4);\n\n\tpSMB->DataLengthLow = cpu_to_le16(count & 0xFFFF);\n\tpSMB->DataLengthHigh = cpu_to_le16(count >> 16);\n\t/* header + 1 byte pad */\n\tsmb_hdr_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 1;\n\tif (wct == 14)\n\t\tinc_rfc1001_len(pSMB, count + 1);\n\telse /* wct == 12 */\n\t\tinc_rfc1001_len(pSMB, count + 5); /* smb data starts later */\n\tif (wct == 14)\n\t\tpSMB->ByteCount = cpu_to_le16(count + 1);\n\telse /* wct == 12 */ /* bigger pad, smaller smb hdr, keep offset ok */ {\n\t\tstruct smb_com_writex_req *pSMBW =\n\t\t\t\t(struct smb_com_writex_req *)pSMB;\n\t\tpSMBW->ByteCount = cpu_to_le16(count + 5);\n\t}\n\tiov[0].iov_base = pSMB;\n\tif (wct == 14)\n\t\tiov[0].iov_len = smb_hdr_len + 4;\n\telse /* wct == 12 pad bigger by four bytes */\n\t\tiov[0].iov_len = smb_hdr_len + 8;\n\n\n\trc = SendReceive2(xid, tcon->ses, iov, n_vec + 1, &resp_buf_type,\n\t\t\t  long_op);\n\tcifs_stats_inc(&tcon->num_writes);\n\tif (rc) {\n\t\tcFYI(1, \"Send error Write2 = %d\", rc);\n\t} else if (resp_buf_type == 0) {\n\t\t/* presumably this can not happen, but best to be safe */\n\t\trc = -EIO;\n\t} else {\n\t\tWRITE_RSP *pSMBr = (WRITE_RSP *)iov[0].iov_base;\n\t\t*nbytes = le16_to_cpu(pSMBr->CountHigh);\n\t\t*nbytes = (*nbytes) << 16;\n\t\t*nbytes += le16_to_cpu(pSMBr->Count);\n\n\t\t/*\n\t\t * Mask off high 16 bits when bytes written as returned by the\n\t\t * server is greater than bytes requested by the client. OS/2\n\t\t * servers are known to set incorrect CountHigh values.\n\t\t */\n\t\tif (*nbytes > count)\n\t\t\t*nbytes &= 0xFFFF;\n\t}\n\n/*\tcifs_small_buf_release(pSMB); */ /* Freed earlier now in SendReceive2 */\n\tif (resp_buf_type == CIFS_SMALL_BUFFER)\n\t\tcifs_small_buf_release(iov[0].iov_base);\n\telse if (resp_buf_type == CIFS_LARGE_BUFFER)\n\t\tcifs_buf_release(iov[0].iov_base);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\n\treturn rc;\n}\n\n\nint\nCIFSSMBLock(const int xid, struct cifs_tcon *tcon,\n\t    const __u16 smb_file_id, const __u64 len,\n\t    const __u64 offset, const __u32 numUnlock,\n\t    const __u32 numLock, const __u8 lockType,\n\t    const bool waitFlag, const __u8 oplock_level)\n{\n\tint rc = 0;\n\tLOCK_REQ *pSMB = NULL;\n/*\tLOCK_RSP *pSMBr = NULL; */ /* No response data other than rc to parse */\n\tint bytes_returned;\n\tint timeout = 0;\n\t__u16 count;\n\n\tcFYI(1, \"CIFSSMBLock timeout %d numLock %d\", (int)waitFlag, numLock);\n\trc = small_smb_init(SMB_COM_LOCKING_ANDX, 8, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tif (lockType == LOCKING_ANDX_OPLOCK_RELEASE) {\n\t\ttimeout = CIFS_ASYNC_OP; /* no response expected */\n\t\tpSMB->Timeout = 0;\n\t} else if (waitFlag) {\n\t\ttimeout = CIFS_BLOCKING_OP; /* blocking operation, no timeout */\n\t\tpSMB->Timeout = cpu_to_le32(-1);/* blocking - do not time out */\n\t} else {\n\t\tpSMB->Timeout = 0;\n\t}\n\n\tpSMB->NumberOfLocks = cpu_to_le16(numLock);\n\tpSMB->NumberOfUnlocks = cpu_to_le16(numUnlock);\n\tpSMB->LockType = lockType;\n\tpSMB->OplockLevel = oplock_level;\n\tpSMB->AndXCommand = 0xFF;\t/* none */\n\tpSMB->Fid = smb_file_id; /* netfid stays le */\n\n\tif ((numLock != 0) || (numUnlock != 0)) {\n\t\tpSMB->Locks[0].Pid = cpu_to_le16(current->tgid);\n\t\t/* BB where to store pid high? */\n\t\tpSMB->Locks[0].LengthLow = cpu_to_le32((u32)len);\n\t\tpSMB->Locks[0].LengthHigh = cpu_to_le32((u32)(len>>32));\n\t\tpSMB->Locks[0].OffsetLow = cpu_to_le32((u32)offset);\n\t\tpSMB->Locks[0].OffsetHigh = cpu_to_le32((u32)(offset>>32));\n\t\tcount = sizeof(LOCKING_ANDX_RANGE);\n\t} else {\n\t\t/* oplock break */\n\t\tcount = 0;\n\t}\n\tinc_rfc1001_len(pSMB, count);\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\tif (waitFlag) {\n\t\trc = SendReceiveBlockingLock(xid, tcon, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *) pSMB, &bytes_returned);\n\t\tcifs_small_buf_release(pSMB);\n\t} else {\n\t\trc = SendReceiveNoRsp(xid, tcon->ses, (struct smb_hdr *)pSMB,\n\t\t\t\t      timeout);\n\t\t/* SMB buffer freed by function above */\n\t}\n\tcifs_stats_inc(&tcon->num_locks);\n\tif (rc)\n\t\tcFYI(1, \"Send error in Lock = %d\", rc);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\tsince file handle passed in no longer valid */\n\treturn rc;\n}\n\nint\nCIFSSMBPosixLock(const int xid, struct cifs_tcon *tcon,\n\t\tconst __u16 smb_file_id, const int get_flag, const __u64 len,\n\t\tstruct file_lock *pLockData, const __u16 lock_type,\n\t\tconst bool waitFlag)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tstruct smb_com_transaction2_sfi_rsp *pSMBr = NULL;\n\tstruct cifs_posix_lock *parm_data;\n\tint rc = 0;\n\tint timeout = 0;\n\tint bytes_returned = 0;\n\tint resp_buf_type = 0;\n\t__u16 params, param_offset, offset, byte_count, count;\n\tstruct kvec iov[1];\n\n\tcFYI(1, \"Posix Lock\");\n\n\tif (pLockData == NULL)\n\t\treturn -EINVAL;\n\n\trc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tpSMBr = (struct smb_com_transaction2_sfi_rsp *)pSMB;\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tcount = sizeof(struct cifs_posix_lock);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(1000); /* BB find max SMB from sess */\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tif (get_flag)\n\t\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FILE_INFORMATION);\n\telse\n\t\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tparm_data = (struct cifs_posix_lock *)\n\t\t\t(((char *) &pSMB->hdr.Protocol) + offset);\n\n\tparm_data->lock_type = cpu_to_le16(lock_type);\n\tif (waitFlag) {\n\t\ttimeout = CIFS_BLOCKING_OP; /* blocking operation, no timeout */\n\t\tparm_data->lock_flags = cpu_to_le16(1);\n\t\tpSMB->Timeout = cpu_to_le32(-1);\n\t} else\n\t\tpSMB->Timeout = 0;\n\n\tparm_data->pid = cpu_to_le32(current->tgid);\n\tparm_data->start = cpu_to_le64(pLockData->fl_start);\n\tparm_data->length = cpu_to_le64(len);  /* normalize negative numbers */\n\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->Fid = smb_file_id;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_POSIX_LOCK);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\tif (waitFlag) {\n\t\trc = SendReceiveBlockingLock(xid, tcon, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *) pSMBr, &bytes_returned);\n\t} else {\n\t\tiov[0].iov_base = (char *)pSMB;\n\t\tiov[0].iov_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 4;\n\t\trc = SendReceive2(xid, tcon->ses, iov, 1 /* num iovecs */,\n\t\t\t\t&resp_buf_type, timeout);\n\t\tpSMB = NULL; /* request buf already freed by SendReceive2. Do\n\t\t\t\tnot try to free it twice below on exit */\n\t\tpSMBr = (struct smb_com_transaction2_sfi_rsp *)iov[0].iov_base;\n\t}\n\n\tif (rc) {\n\t\tcFYI(1, \"Send error in Posix Lock = %d\", rc);\n\t} else if (get_flag) {\n\t\t/* lock structure can be returned on get */\n\t\t__u16 data_offset;\n\t\t__u16 data_count;\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < sizeof(*parm_data)) {\n\t\t\trc = -EIO;      /* bad smb */\n\t\t\tgoto plk_err_exit;\n\t\t}\n\t\tdata_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\tdata_count  = le16_to_cpu(pSMBr->t2.DataCount);\n\t\tif (data_count < sizeof(struct cifs_posix_lock)) {\n\t\t\trc = -EIO;\n\t\t\tgoto plk_err_exit;\n\t\t}\n\t\tparm_data = (struct cifs_posix_lock *)\n\t\t\t((char *)&pSMBr->hdr.Protocol + data_offset);\n\t\tif (parm_data->lock_type == __constant_cpu_to_le16(CIFS_UNLCK))\n\t\t\tpLockData->fl_type = F_UNLCK;\n\t\telse {\n\t\t\tif (parm_data->lock_type ==\n\t\t\t\t\t__constant_cpu_to_le16(CIFS_RDLCK))\n\t\t\t\tpLockData->fl_type = F_RDLCK;\n\t\t\telse if (parm_data->lock_type ==\n\t\t\t\t\t__constant_cpu_to_le16(CIFS_WRLCK))\n\t\t\t\tpLockData->fl_type = F_WRLCK;\n\n\t\t\tpLockData->fl_start = le64_to_cpu(parm_data->start);\n\t\t\tpLockData->fl_end = pLockData->fl_start +\n\t\t\t\t\tle64_to_cpu(parm_data->length) - 1;\n\t\t\tpLockData->fl_pid = le32_to_cpu(parm_data->pid);\n\t\t}\n\t}\n\nplk_err_exit:\n\tif (pSMB)\n\t\tcifs_small_buf_release(pSMB);\n\n\tif (resp_buf_type == CIFS_SMALL_BUFFER)\n\t\tcifs_small_buf_release(iov[0].iov_base);\n\telse if (resp_buf_type == CIFS_LARGE_BUFFER)\n\t\tcifs_buf_release(iov[0].iov_base);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t   since file handle passed in no longer valid */\n\n\treturn rc;\n}\n\n\nint\nCIFSSMBClose(const int xid, struct cifs_tcon *tcon, int smb_file_id)\n{\n\tint rc = 0;\n\tCLOSE_REQ *pSMB = NULL;\n\tcFYI(1, \"In CIFSSMBClose\");\n\n/* do not retry on dead session on close */\n\trc = small_smb_init(SMB_COM_CLOSE, 3, tcon, (void **) &pSMB);\n\tif (rc == -EAGAIN)\n\t\treturn 0;\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->FileID = (__u16) smb_file_id;\n\tpSMB->LastWriteTime = 0xFFFFFFFF;\n\tpSMB->ByteCount = 0;\n\trc = SendReceiveNoRsp(xid, tcon->ses, (struct smb_hdr *) pSMB, 0);\n\tcifs_stats_inc(&tcon->num_closes);\n\tif (rc) {\n\t\tif (rc != -EINTR) {\n\t\t\t/* EINTR is expected when user ctl-c to kill app */\n\t\t\tcERROR(1, \"Send error in Close = %d\", rc);\n\t\t}\n\t}\n\n\t/* Since session is dead, file will be closed on server already */\n\tif (rc == -EAGAIN)\n\t\trc = 0;\n\n\treturn rc;\n}\n\nint\nCIFSSMBFlush(const int xid, struct cifs_tcon *tcon, int smb_file_id)\n{\n\tint rc = 0;\n\tFLUSH_REQ *pSMB = NULL;\n\tcFYI(1, \"In CIFSSMBFlush\");\n\n\trc = small_smb_init(SMB_COM_FLUSH, 1, tcon, (void **) &pSMB);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->FileID = (__u16) smb_file_id;\n\tpSMB->ByteCount = 0;\n\trc = SendReceiveNoRsp(xid, tcon->ses, (struct smb_hdr *) pSMB, 0);\n\tcifs_stats_inc(&tcon->num_flushes);\n\tif (rc)\n\t\tcERROR(1, \"Send error in Flush = %d\", rc);\n\n\treturn rc;\n}\n\nint\nCIFSSMBRename(const int xid, struct cifs_tcon *tcon,\n\t      const char *fromName, const char *toName,\n\t      const struct nls_table *nls_codepage, int remap)\n{\n\tint rc = 0;\n\tRENAME_REQ *pSMB = NULL;\n\tRENAME_RSP *pSMBr = NULL;\n\tint bytes_returned;\n\tint name_len, name_len2;\n\t__u16 count;\n\n\tcFYI(1, \"In CIFSSMBRename\");\nrenameRetry:\n\trc = smb_init(SMB_COM_RENAME, 1, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->BufferFormat = 0x04;\n\tpSMB->SearchAttributes =\n\t    cpu_to_le16(ATTR_READONLY | ATTR_HIDDEN | ATTR_SYSTEM |\n\t\t\tATTR_DIRECTORY);\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUCS((__le16 *) pSMB->OldFileName, fromName,\n\t\t\t\t     PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t\tpSMB->OldFileName[name_len] = 0x04;\t/* pad */\n\t/* protocol requires ASCII signature byte on Unicode string */\n\t\tpSMB->OldFileName[name_len + 1] = 0x00;\n\t\tname_len2 =\n\t\t    cifsConvertToUCS((__le16 *)&pSMB->OldFileName[name_len + 2],\n\t\t\t\t     toName, PATH_MAX, nls_codepage, remap);\n\t\tname_len2 += 1 /* trailing null */  + 1 /* Signature word */ ;\n\t\tname_len2 *= 2;\t/* convert to bytes */\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(fromName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->OldFileName, fromName, name_len);\n\t\tname_len2 = strnlen(toName, PATH_MAX);\n\t\tname_len2++;\t/* trailing null */\n\t\tpSMB->OldFileName[name_len] = 0x04;  /* 2nd buffer format */\n\t\tstrncpy(&pSMB->OldFileName[name_len + 1], toName, name_len2);\n\t\tname_len2++;\t/* trailing null */\n\t\tname_len2++;\t/* signature byte */\n\t}\n\n\tcount = 1 /* 1st signature byte */  + name_len + name_len2;\n\tinc_rfc1001_len(pSMB, count);\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->num_renames);\n\tif (rc)\n\t\tcFYI(1, \"Send error in rename = %d\", rc);\n\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto renameRetry;\n\n\treturn rc;\n}\n\nint CIFSSMBRenameOpenFile(const int xid, struct cifs_tcon *pTcon,\n\t\tint netfid, const char *target_name,\n\t\tconst struct nls_table *nls_codepage, int remap)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tstruct smb_com_transaction2_sfi_rsp *pSMBr = NULL;\n\tstruct set_file_rename *rename_info;\n\tchar *data_offset;\n\tchar dummy_string[30];\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tint len_of_str;\n\t__u16 params, param_offset, offset, count, byte_count;\n\n\tcFYI(1, \"Rename to File by handle\");\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, pTcon, (void **) &pSMB,\n\t\t\t(void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tdata_offset = (char *) (&pSMB->hdr.Protocol) + offset;\n\trename_info = (struct set_file_rename *) data_offset;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(1000); /* BB find max SMB from sess */\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3 /* pad */  + params;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\t/* construct random name \".cifs_tmp<inodenum><mid>\" */\n\trename_info->overwrite = cpu_to_le32(1);\n\trename_info->root_fid  = 0;\n\t/* unicode only call */\n\tif (target_name == NULL) {\n\t\tsprintf(dummy_string, \"cifs%x\", pSMB->hdr.Mid);\n\t\tlen_of_str = cifsConvertToUCS((__le16 *)rename_info->target_name,\n\t\t\t\t\tdummy_string, 24, nls_codepage, remap);\n\t} else {\n\t\tlen_of_str = cifsConvertToUCS((__le16 *)rename_info->target_name,\n\t\t\t\t\ttarget_name, PATH_MAX, nls_codepage,\n\t\t\t\t\tremap);\n\t}\n\trename_info->target_name_len = cpu_to_le32(2 * len_of_str);\n\tcount = 12 /* sizeof(struct set_file_rename) */ + (2 * len_of_str);\n\tbyte_count += count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->Fid = netfid;\n\tpSMB->InformationLevel =\n\t\tcpu_to_le16(SMB_SET_FILE_RENAME_INFORMATION);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, pTcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&pTcon->num_t2renames);\n\tif (rc)\n\t\tcFYI(1, \"Send error in Rename (by file handle) = %d\", rc);\n\n\tcifs_buf_release(pSMB);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\n\treturn rc;\n}\n\nint\nCIFSSMBCopy(const int xid, struct cifs_tcon *tcon, const char *fromName,\n\t    const __u16 target_tid, const char *toName, const int flags,\n\t    const struct nls_table *nls_codepage, int remap)\n{\n\tint rc = 0;\n\tCOPY_REQ *pSMB = NULL;\n\tCOPY_RSP *pSMBr = NULL;\n\tint bytes_returned;\n\tint name_len, name_len2;\n\t__u16 count;\n\n\tcFYI(1, \"In CIFSSMBCopy\");\ncopyRetry:\n\trc = smb_init(SMB_COM_COPY, 1, tcon, (void **) &pSMB,\n\t\t\t(void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->BufferFormat = 0x04;\n\tpSMB->Tid2 = target_tid;\n\n\tpSMB->Flags = cpu_to_le16(flags & COPY_TREE);\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len = cifsConvertToUCS((__le16 *) pSMB->OldFileName,\n\t\t\t\t\t    fromName, PATH_MAX, nls_codepage,\n\t\t\t\t\t    remap);\n\t\tname_len++;     /* trailing null */\n\t\tname_len *= 2;\n\t\tpSMB->OldFileName[name_len] = 0x04;     /* pad */\n\t\t/* protocol requires ASCII signature byte on Unicode string */\n\t\tpSMB->OldFileName[name_len + 1] = 0x00;\n\t\tname_len2 =\n\t\t    cifsConvertToUCS((__le16 *)&pSMB->OldFileName[name_len + 2],\n\t\t\t\ttoName, PATH_MAX, nls_codepage, remap);\n\t\tname_len2 += 1 /* trailing null */  + 1 /* Signature word */ ;\n\t\tname_len2 *= 2; /* convert to bytes */\n\t} else { \t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(fromName, PATH_MAX);\n\t\tname_len++;     /* trailing null */\n\t\tstrncpy(pSMB->OldFileName, fromName, name_len);\n\t\tname_len2 = strnlen(toName, PATH_MAX);\n\t\tname_len2++;    /* trailing null */\n\t\tpSMB->OldFileName[name_len] = 0x04;  /* 2nd buffer format */\n\t\tstrncpy(&pSMB->OldFileName[name_len + 1], toName, name_len2);\n\t\tname_len2++;    /* trailing null */\n\t\tname_len2++;    /* signature byte */\n\t}\n\n\tcount = 1 /* 1st signature byte */  + name_len + name_len2;\n\tinc_rfc1001_len(pSMB, count);\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcFYI(1, \"Send error in copy = %d with %d files copied\",\n\t\t\trc, le16_to_cpu(pSMBr->CopyCount));\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto copyRetry;\n\n\treturn rc;\n}\n\nint\nCIFSUnixCreateSymLink(const int xid, struct cifs_tcon *tcon,\n\t\t      const char *fromName, const char *toName,\n\t\t      const struct nls_table *nls_codepage)\n{\n\tTRANSACTION2_SPI_REQ *pSMB = NULL;\n\tTRANSACTION2_SPI_RSP *pSMBr = NULL;\n\tchar *data_offset;\n\tint name_len;\n\tint name_len_target;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, param_offset, offset, byte_count;\n\n\tcFYI(1, \"In Symlink Unix style\");\ncreateSymLinkRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifs_strtoUCS((__le16 *) pSMB->FileName, fromName, PATH_MAX\n\t\t\t\t  /* find define for this maxpathcomponent */\n\t\t\t\t  , nls_codepage);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(fromName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, fromName, name_len);\n\t}\n\tparams = 6 + name_len;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\n\tdata_offset = (char *) (&pSMB->hdr.Protocol) + offset;\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len_target =\n\t\t    cifs_strtoUCS((__le16 *) data_offset, toName, PATH_MAX\n\t\t\t\t  /* find define for this maxpathcomponent */\n\t\t\t\t  , nls_codepage);\n\t\tname_len_target++;\t/* trailing null */\n\t\tname_len_target *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len_target = strnlen(toName, PATH_MAX);\n\t\tname_len_target++;\t/* trailing null */\n\t\tstrncpy(data_offset, toName, name_len_target);\n\t}\n\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max on data count below from sess */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + name_len_target;\n\tpSMB->DataCount = cpu_to_le16(name_len_target);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_UNIX_LINK);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->num_symlinks);\n\tif (rc)\n\t\tcFYI(1, \"Send error in SetPathInfo create symlink = %d\", rc);\n\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto createSymLinkRetry;\n\n\treturn rc;\n}\n\nint\nCIFSUnixCreateHardLink(const int xid, struct cifs_tcon *tcon,\n\t\t       const char *fromName, const char *toName,\n\t\t       const struct nls_table *nls_codepage, int remap)\n{\n\tTRANSACTION2_SPI_REQ *pSMB = NULL;\n\tTRANSACTION2_SPI_RSP *pSMBr = NULL;\n\tchar *data_offset;\n\tint name_len;\n\tint name_len_target;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, param_offset, offset, byte_count;\n\n\tcFYI(1, \"In Create Hard link Unix style\");\ncreateHardLinkRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len = cifsConvertToUCS((__le16 *) pSMB->FileName, toName,\n\t\t\t\t\t    PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(toName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, toName, name_len);\n\t}\n\tparams = 6 + name_len;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\n\tdata_offset = (char *) (&pSMB->hdr.Protocol) + offset;\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len_target =\n\t\t    cifsConvertToUCS((__le16 *) data_offset, fromName, PATH_MAX,\n\t\t\t\t     nls_codepage, remap);\n\t\tname_len_target++;\t/* trailing null */\n\t\tname_len_target *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len_target = strnlen(fromName, PATH_MAX);\n\t\tname_len_target++;\t/* trailing null */\n\t\tstrncpy(data_offset, fromName, name_len_target);\n\t}\n\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max on data count below from sess*/\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + name_len_target;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->DataCount = cpu_to_le16(name_len_target);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_UNIX_HLINK);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->num_hardlinks);\n\tif (rc)\n\t\tcFYI(1, \"Send error in SetPathInfo (hard link) = %d\", rc);\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto createHardLinkRetry;\n\n\treturn rc;\n}\n\nint\nCIFSCreateHardLink(const int xid, struct cifs_tcon *tcon,\n\t\t   const char *fromName, const char *toName,\n\t\t   const struct nls_table *nls_codepage, int remap)\n{\n\tint rc = 0;\n\tNT_RENAME_REQ *pSMB = NULL;\n\tRENAME_RSP *pSMBr = NULL;\n\tint bytes_returned;\n\tint name_len, name_len2;\n\t__u16 count;\n\n\tcFYI(1, \"In CIFSCreateHardLink\");\nwinCreateHardLinkRetry:\n\n\trc = smb_init(SMB_COM_NT_RENAME, 4, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->SearchAttributes =\n\t    cpu_to_le16(ATTR_READONLY | ATTR_HIDDEN | ATTR_SYSTEM |\n\t\t\tATTR_DIRECTORY);\n\tpSMB->Flags = cpu_to_le16(CREATE_HARD_LINK);\n\tpSMB->ClusterCount = 0;\n\n\tpSMB->BufferFormat = 0x04;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUCS((__le16 *) pSMB->OldFileName, fromName,\n\t\t\t\t     PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\n\t\t/* protocol specifies ASCII buffer format (0x04) for unicode */\n\t\tpSMB->OldFileName[name_len] = 0x04;\n\t\tpSMB->OldFileName[name_len + 1] = 0x00; /* pad */\n\t\tname_len2 =\n\t\t    cifsConvertToUCS((__le16 *)&pSMB->OldFileName[name_len + 2],\n\t\t\t\t     toName, PATH_MAX, nls_codepage, remap);\n\t\tname_len2 += 1 /* trailing null */  + 1 /* Signature word */ ;\n\t\tname_len2 *= 2;\t/* convert to bytes */\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(fromName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->OldFileName, fromName, name_len);\n\t\tname_len2 = strnlen(toName, PATH_MAX);\n\t\tname_len2++;\t/* trailing null */\n\t\tpSMB->OldFileName[name_len] = 0x04;\t/* 2nd buffer format */\n\t\tstrncpy(&pSMB->OldFileName[name_len + 1], toName, name_len2);\n\t\tname_len2++;\t/* trailing null */\n\t\tname_len2++;\t/* signature byte */\n\t}\n\n\tcount = 1 /* string type byte */  + name_len + name_len2;\n\tinc_rfc1001_len(pSMB, count);\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->num_hardlinks);\n\tif (rc)\n\t\tcFYI(1, \"Send error in hard link (NT rename) = %d\", rc);\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto winCreateHardLinkRetry;\n\n\treturn rc;\n}\n\nint\nCIFSSMBUnixQuerySymLink(const int xid, struct cifs_tcon *tcon,\n\t\t\tconst unsigned char *searchName, char **symlinkinfo,\n\t\t\tconst struct nls_table *nls_codepage)\n{\n/* SMB_QUERY_FILE_UNIX_LINK */\n\tTRANSACTION2_QPI_REQ *pSMB = NULL;\n\tTRANSACTION2_QPI_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 params, byte_count;\n\tchar *data_start;\n\n\tcFYI(1, \"In QPathSymLinkInfo (Unix) for path %s\", searchName);\n\nquerySymLinkRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifs_strtoUCS((__le16 *) pSMB->FileName, searchName,\n\t\t\t\t  PATH_MAX, nls_codepage);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(searchName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, searchName, name_len);\n\t}\n\n\tparams = 2 /* level */  + 4 /* rsrvd */  + name_len /* incl null */ ;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(CIFSMaxBufSize);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\tstruct smb_com_transaction2_qpi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_PATH_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_UNIX_LINK);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcFYI(1, \"Send error in QuerySymLinkInfo = %d\", rc);\n\t} else {\n\t\t/* decode response */\n\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\t\t/* BB also check enough total bytes returned */\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 2)\n\t\t\trc = -EIO;\n\t\telse {\n\t\t\tbool is_unicode;\n\t\t\tu16 count = le16_to_cpu(pSMBr->t2.DataCount);\n\n\t\t\tdata_start = ((char *) &pSMBr->hdr.Protocol) +\n\t\t\t\t\t   le16_to_cpu(pSMBr->t2.DataOffset);\n\n\t\t\tif (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE)\n\t\t\t\tis_unicode = true;\n\t\t\telse\n\t\t\t\tis_unicode = false;\n\n\t\t\t/* BB FIXME investigate remapping reserved chars here */\n\t\t\t*symlinkinfo = cifs_strndup_from_ucs(data_start, count,\n\t\t\t\t\t\t    is_unicode, nls_codepage);\n\t\t\tif (!*symlinkinfo)\n\t\t\t\trc = -ENOMEM;\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto querySymLinkRetry;\n\treturn rc;\n}\n\n#ifdef CONFIG_CIFS_SYMLINK_EXPERIMENTAL\n/*\n *\tRecent Windows versions now create symlinks more frequently\n *\tand they use the \"reparse point\" mechanism below.  We can of course\n *\tdo symlinks nicely to Samba and other servers which support the\n *\tCIFS Unix Extensions and we can also do SFU symlinks and \"client only\"\n *\t\"MF\" symlinks optionally, but for recent Windows we really need to\n *\treenable the code below and fix the cifs_symlink callers to handle this.\n *\tIn the interim this code has been moved to its own config option so\n *\tit is not compiled in by default until callers fixed up and more tested.\n */\nint\nCIFSSMBQueryReparseLinkInfo(const int xid, struct cifs_tcon *tcon,\n\t\t\tconst unsigned char *searchName,\n\t\t\tchar *symlinkinfo, const int buflen, __u16 fid,\n\t\t\tconst struct nls_table *nls_codepage)\n{\n\tint rc = 0;\n\tint bytes_returned;\n\tstruct smb_com_transaction_ioctl_req *pSMB;\n\tstruct smb_com_transaction_ioctl_rsp *pSMBr;\n\n\tcFYI(1, \"In Windows reparse style QueryLink for path %s\", searchName);\n\trc = smb_init(SMB_COM_NT_TRANSACT, 23, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->TotalParameterCount = 0 ;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le32(2);\n\t/* BB find exact data count max from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le32((tcon->ses->server->maxBuf -\n\t\t\t\t\t  MAX_CIFS_HDR_SIZE) & 0xFFFFFF00);\n\tpSMB->MaxSetupCount = 4;\n\tpSMB->Reserved = 0;\n\tpSMB->ParameterOffset = 0;\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 4;\n\tpSMB->SubCommand = cpu_to_le16(NT_TRANSACT_IOCTL);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->FunctionCode = cpu_to_le32(FSCTL_GET_REPARSE_POINT);\n\tpSMB->IsFsctl = 1; /* FSCTL */\n\tpSMB->IsRootFlag = 0;\n\tpSMB->Fid = fid; /* file handle always le */\n\tpSMB->ByteCount = 0;\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcFYI(1, \"Send error in QueryReparseLinkInfo = %d\", rc);\n\t} else {\t\t/* decode response */\n\t\t__u32 data_offset = le32_to_cpu(pSMBr->DataOffset);\n\t\t__u32 data_count = le32_to_cpu(pSMBr->DataCount);\n\t\tif (get_bcc(&pSMBr->hdr) < 2 || data_offset > 512) {\n\t\t\t/* BB also check enough total bytes returned */\n\t\t\trc = -EIO;\t/* bad smb */\n\t\t\tgoto qreparse_out;\n\t\t}\n\t\tif (data_count && (data_count < 2048)) {\n\t\t\tchar *end_of_smb = 2 /* sizeof byte count */ +\n\t\t\t       get_bcc(&pSMBr->hdr) + (char *)&pSMBr->ByteCount;\n\n\t\t\tstruct reparse_data *reparse_buf =\n\t\t\t\t\t\t(struct reparse_data *)\n\t\t\t\t\t\t((char *)&pSMBr->hdr.Protocol\n\t\t\t\t\t\t\t\t + data_offset);\n\t\t\tif ((char *)reparse_buf >= end_of_smb) {\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto qreparse_out;\n\t\t\t}\n\t\t\tif ((reparse_buf->LinkNamesBuf +\n\t\t\t\treparse_buf->TargetNameOffset +\n\t\t\t\treparse_buf->TargetNameLen) > end_of_smb) {\n\t\t\t\tcFYI(1, \"reparse buf beyond SMB\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto qreparse_out;\n\t\t\t}\n\n\t\t\tif (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\t\t\tcifs_from_ucs2(symlinkinfo, (__le16 *)\n\t\t\t\t\t\t(reparse_buf->LinkNamesBuf +\n\t\t\t\t\t\treparse_buf->TargetNameOffset),\n\t\t\t\t\t\tbuflen,\n\t\t\t\t\t\treparse_buf->TargetNameLen,\n\t\t\t\t\t\tnls_codepage, 0);\n\t\t\t} else { /* ASCII names */\n\t\t\t\tstrncpy(symlinkinfo,\n\t\t\t\t\treparse_buf->LinkNamesBuf +\n\t\t\t\t\treparse_buf->TargetNameOffset,\n\t\t\t\t\tmin_t(const int, buflen,\n\t\t\t\t\t   reparse_buf->TargetNameLen));\n\t\t\t}\n\t\t} else {\n\t\t\trc = -EIO;\n\t\t\tcFYI(1, \"Invalid return data count on \"\n\t\t\t\t \"get reparse info ioctl\");\n\t\t}\n\t\tsymlinkinfo[buflen] = 0; /* just in case so the caller\n\t\t\t\t\tdoes not go off the end of the buffer */\n\t\tcFYI(1, \"readlink result - %s\", symlinkinfo);\n\t}\n\nqreparse_out:\n\tcifs_buf_release(pSMB);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\n\treturn rc;\n}\n#endif /* CIFS_SYMLINK_EXPERIMENTAL */ /* BB temporarily unused */\n\n#ifdef CONFIG_CIFS_POSIX\n\n/*Convert an Access Control Entry from wire format to local POSIX xattr format*/\nstatic void cifs_convert_ace(posix_acl_xattr_entry *ace,\n\t\t\t     struct cifs_posix_ace *cifs_ace)\n{\n\t/* u8 cifs fields do not need le conversion */\n\tace->e_perm = cpu_to_le16(cifs_ace->cifs_e_perm);\n\tace->e_tag  = cpu_to_le16(cifs_ace->cifs_e_tag);\n\tace->e_id   = cpu_to_le32(le64_to_cpu(cifs_ace->cifs_uid));\n\t/* cFYI(1, \"perm %d tag %d id %d\",ace->e_perm,ace->e_tag,ace->e_id); */\n\n\treturn;\n}\n\n/* Convert ACL from CIFS POSIX wire format to local Linux POSIX ACL xattr */\nstatic int cifs_copy_posix_acl(char *trgt, char *src, const int buflen,\n\t\t\t       const int acl_type, const int size_of_data_area)\n{\n\tint size =  0;\n\tint i;\n\t__u16 count;\n\tstruct cifs_posix_ace *pACE;\n\tstruct cifs_posix_acl *cifs_acl = (struct cifs_posix_acl *)src;\n\tposix_acl_xattr_header *local_acl = (posix_acl_xattr_header *)trgt;\n\n\tif (le16_to_cpu(cifs_acl->version) != CIFS_ACL_VERSION)\n\t\treturn -EOPNOTSUPP;\n\n\tif (acl_type & ACL_TYPE_ACCESS) {\n\t\tcount = le16_to_cpu(cifs_acl->access_entry_count);\n\t\tpACE = &cifs_acl->ace_array[0];\n\t\tsize = sizeof(struct cifs_posix_acl);\n\t\tsize += sizeof(struct cifs_posix_ace) * count;\n\t\t/* check if we would go beyond end of SMB */\n\t\tif (size_of_data_area < size) {\n\t\t\tcFYI(1, \"bad CIFS POSIX ACL size %d vs. %d\",\n\t\t\t\tsize_of_data_area, size);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (acl_type & ACL_TYPE_DEFAULT) {\n\t\tcount = le16_to_cpu(cifs_acl->access_entry_count);\n\t\tsize = sizeof(struct cifs_posix_acl);\n\t\tsize += sizeof(struct cifs_posix_ace) * count;\n/* skip past access ACEs to get to default ACEs */\n\t\tpACE = &cifs_acl->ace_array[count];\n\t\tcount = le16_to_cpu(cifs_acl->default_entry_count);\n\t\tsize += sizeof(struct cifs_posix_ace) * count;\n\t\t/* check if we would go beyond end of SMB */\n\t\tif (size_of_data_area < size)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t/* illegal type */\n\t\treturn -EINVAL;\n\t}\n\n\tsize = posix_acl_xattr_size(count);\n\tif ((buflen == 0) || (local_acl == NULL)) {\n\t\t/* used to query ACL EA size */\n\t} else if (size > buflen) {\n\t\treturn -ERANGE;\n\t} else /* buffer big enough */ {\n\t\tlocal_acl->a_version = cpu_to_le32(POSIX_ACL_XATTR_VERSION);\n\t\tfor (i = 0; i < count ; i++) {\n\t\t\tcifs_convert_ace(&local_acl->a_entries[i], pACE);\n\t\t\tpACE++;\n\t\t}\n\t}\n\treturn size;\n}\n\nstatic __u16 convert_ace_to_cifs_ace(struct cifs_posix_ace *cifs_ace,\n\t\t\t\t     const posix_acl_xattr_entry *local_ace)\n{\n\t__u16 rc = 0; /* 0 = ACL converted ok */\n\n\tcifs_ace->cifs_e_perm = le16_to_cpu(local_ace->e_perm);\n\tcifs_ace->cifs_e_tag =  le16_to_cpu(local_ace->e_tag);\n\t/* BB is there a better way to handle the large uid? */\n\tif (local_ace->e_id == cpu_to_le32(-1)) {\n\t/* Probably no need to le convert -1 on any arch but can not hurt */\n\t\tcifs_ace->cifs_uid = cpu_to_le64(-1);\n\t} else\n\t\tcifs_ace->cifs_uid = cpu_to_le64(le32_to_cpu(local_ace->e_id));\n\t/*cFYI(1, \"perm %d tag %d id %d\",ace->e_perm,ace->e_tag,ace->e_id);*/\n\treturn rc;\n}\n\n/* Convert ACL from local Linux POSIX xattr to CIFS POSIX ACL wire format */\nstatic __u16 ACL_to_cifs_posix(char *parm_data, const char *pACL,\n\t\t\t       const int buflen, const int acl_type)\n{\n\t__u16 rc = 0;\n\tstruct cifs_posix_acl *cifs_acl = (struct cifs_posix_acl *)parm_data;\n\tposix_acl_xattr_header *local_acl = (posix_acl_xattr_header *)pACL;\n\tint count;\n\tint i;\n\n\tif ((buflen == 0) || (pACL == NULL) || (cifs_acl == NULL))\n\t\treturn 0;\n\n\tcount = posix_acl_xattr_count((size_t)buflen);\n\tcFYI(1, \"setting acl with %d entries from buf of length %d and \"\n\t\t\"version of %d\",\n\t\tcount, buflen, le32_to_cpu(local_acl->a_version));\n\tif (le32_to_cpu(local_acl->a_version) != 2) {\n\t\tcFYI(1, \"unknown POSIX ACL version %d\",\n\t\t     le32_to_cpu(local_acl->a_version));\n\t\treturn 0;\n\t}\n\tcifs_acl->version = cpu_to_le16(1);\n\tif (acl_type == ACL_TYPE_ACCESS)\n\t\tcifs_acl->access_entry_count = cpu_to_le16(count);\n\telse if (acl_type == ACL_TYPE_DEFAULT)\n\t\tcifs_acl->default_entry_count = cpu_to_le16(count);\n\telse {\n\t\tcFYI(1, \"unknown ACL type %d\", acl_type);\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < count; i++) {\n\t\trc = convert_ace_to_cifs_ace(&cifs_acl->ace_array[i],\n\t\t\t\t\t&local_acl->a_entries[i]);\n\t\tif (rc != 0) {\n\t\t\t/* ACE not converted */\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (rc == 0) {\n\t\trc = (__u16)(count * sizeof(struct cifs_posix_ace));\n\t\trc += sizeof(struct cifs_posix_acl);\n\t\t/* BB add check to make sure ACL does not overflow SMB */\n\t}\n\treturn rc;\n}\n\nint\nCIFSSMBGetPosixACL(const int xid, struct cifs_tcon *tcon,\n\t\t   const unsigned char *searchName,\n\t\t   char *acl_inf, const int buflen, const int acl_type,\n\t\t   const struct nls_table *nls_codepage, int remap)\n{\n/* SMB_QUERY_POSIX_ACL */\n\tTRANSACTION2_QPI_REQ *pSMB = NULL;\n\tTRANSACTION2_QPI_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 params, byte_count;\n\n\tcFYI(1, \"In GetPosixACL (Unix) for path %s\", searchName);\n\nqueryAclRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t(void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t\tcifsConvertToUCS((__le16 *) pSMB->FileName, searchName,\n\t\t\t\t\t PATH_MAX, nls_codepage, remap);\n\t\tname_len++;     /* trailing null */\n\t\tname_len *= 2;\n\t\tpSMB->FileName[name_len] = 0;\n\t\tpSMB->FileName[name_len+1] = 0;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(searchName, PATH_MAX);\n\t\tname_len++;     /* trailing null */\n\t\tstrncpy(pSMB->FileName, searchName, name_len);\n\t}\n\n\tparams = 2 /* level */  + 4 /* rsrvd */  + name_len /* incl null */ ;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max data count below from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(4000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset = cpu_to_le16(\n\t\toffsetof(struct smb_com_transaction2_qpi_req,\n\t\t\t InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_PATH_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_POSIX_ACL);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->num_acl_get);\n\tif (rc) {\n\t\tcFYI(1, \"Send error in Query POSIX ACL = %d\", rc);\n\t} else {\n\t\t/* decode response */\n\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\t\t/* BB also check enough total bytes returned */\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 2)\n\t\t\trc = -EIO;      /* bad smb */\n\t\telse {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\t__u16 count = le16_to_cpu(pSMBr->t2.DataCount);\n\t\t\trc = cifs_copy_posix_acl(acl_inf,\n\t\t\t\t(char *)&pSMBr->hdr.Protocol+data_offset,\n\t\t\t\tbuflen, acl_type, count);\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto queryAclRetry;\n\treturn rc;\n}\n\nint\nCIFSSMBSetPosixACL(const int xid, struct cifs_tcon *tcon,\n\t\t   const unsigned char *fileName,\n\t\t   const char *local_acl, const int buflen,\n\t\t   const int acl_type,\n\t\t   const struct nls_table *nls_codepage, int remap)\n{\n\tstruct smb_com_transaction2_spi_req *pSMB = NULL;\n\tstruct smb_com_transaction2_spi_rsp *pSMBr = NULL;\n\tchar *parm_data;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count, data_count, param_offset, offset;\n\n\tcFYI(1, \"In SetPosixACL (Unix) for path %s\", fileName);\nsetAclRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t\tcifsConvertToUCS((__le16 *) pSMB->FileName, fileName,\n\t\t\t\t      PATH_MAX, nls_codepage, remap);\n\t\tname_len++;     /* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(fileName, PATH_MAX);\n\t\tname_len++;     /* trailing null */\n\t\tstrncpy(pSMB->FileName, fileName, name_len);\n\t}\n\tparams = 6 + name_len;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find max SMB size from sess */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\tparm_data = ((char *) &pSMB->hdr.Protocol) + offset;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\n\t/* convert to on the wire format for POSIX ACL */\n\tdata_count = ACL_to_cifs_posix(parm_data, local_acl, buflen, acl_type);\n\n\tif (data_count == 0) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto setACLerrorExit;\n\t}\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_POSIX_ACL);\n\tbyte_count = 3 /* pad */  + params + data_count;\n\tpSMB->DataCount = cpu_to_le16(data_count);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcFYI(1, \"Set POSIX ACL returned %d\", rc);\n\nsetACLerrorExit:\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto setAclRetry;\n\treturn rc;\n}\n\n/* BB fix tabs in this function FIXME BB */\nint\nCIFSGetExtAttr(const int xid, struct cifs_tcon *tcon,\n\t       const int netfid, __u64 *pExtAttrBits, __u64 *pMask)\n{\n\tint rc = 0;\n\tstruct smb_t2_qfi_req *pSMB = NULL;\n\tstruct smb_t2_qfi_rsp *pSMBr = NULL;\n\tint bytes_returned;\n\t__u16 params, byte_count;\n\n\tcFYI(1, \"In GetExtAttr\");\n\tif (tcon == NULL)\n\t\treturn -ENODEV;\n\nGetExtAttrRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t\t(void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2 /* level */ + 2 /* fid */;\n\tpSMB->t2.TotalDataCount = 0;\n\tpSMB->t2.MaxParameterCount = cpu_to_le16(4);\n\t/* BB find exact max data count below from sess structure BB */\n\tpSMB->t2.MaxDataCount = cpu_to_le16(4000);\n\tpSMB->t2.MaxSetupCount = 0;\n\tpSMB->t2.Reserved = 0;\n\tpSMB->t2.Flags = 0;\n\tpSMB->t2.Timeout = 0;\n\tpSMB->t2.Reserved2 = 0;\n\tpSMB->t2.ParameterOffset = cpu_to_le16(offsetof(struct smb_t2_qfi_req,\n\t\t\t\t\t       Fid) - 4);\n\tpSMB->t2.DataCount = 0;\n\tpSMB->t2.DataOffset = 0;\n\tpSMB->t2.SetupCount = 1;\n\tpSMB->t2.Reserved3 = 0;\n\tpSMB->t2.SubCommand = cpu_to_le16(TRANS2_QUERY_FILE_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->t2.TotalParameterCount = cpu_to_le16(params);\n\tpSMB->t2.ParameterCount = pSMB->t2.TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_ATTR_FLAGS);\n\tpSMB->Pad = 0;\n\tpSMB->Fid = netfid;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->t2.ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcFYI(1, \"error %d in GetExtAttr\", rc);\n\t} else {\n\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\t\t/* BB also check enough total bytes returned */\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 2)\n\t\t\t/* If rc should we check for EOPNOSUPP and\n\t\t\t   disable the srvino flag? or in caller? */\n\t\t\trc = -EIO;      /* bad smb */\n\t\telse {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\t__u16 count = le16_to_cpu(pSMBr->t2.DataCount);\n\t\t\tstruct file_chattr_info *pfinfo;\n\t\t\t/* BB Do we need a cast or hash here ? */\n\t\t\tif (count != 16) {\n\t\t\t\tcFYI(1, \"Illegal size ret in GetExtAttr\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto GetExtAttrOut;\n\t\t\t}\n\t\t\tpfinfo = (struct file_chattr_info *)\n\t\t\t\t (data_offset + (char *) &pSMBr->hdr.Protocol);\n\t\t\t*pExtAttrBits = le64_to_cpu(pfinfo->mode);\n\t\t\t*pMask = le64_to_cpu(pfinfo->mask);\n\t\t}\n\t}\nGetExtAttrOut:\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto GetExtAttrRetry;\n\treturn rc;\n}\n\n#endif /* CONFIG_POSIX */\n\n#ifdef CONFIG_CIFS_ACL\n/*\n * Initialize NT TRANSACT SMB into small smb request buffer.  This assumes that\n * all NT TRANSACTS that we init here have total parm and data under about 400\n * bytes (to fit in small cifs buffer size), which is the case so far, it\n * easily fits. NB: Setup words themselves and ByteCount MaxSetupCount (size of\n * returned setup area) and MaxParameterCount (returned parms size) must be set\n * by caller\n */\nstatic int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32((tcon->ses->server->maxBuf -\n\t\t\t\t\t  MAX_CIFS_HDR_SIZE) & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}\n\nstatic int\nvalidate_ntransact(char *buf, char **ppparm, char **ppdata,\n\t\t   __u32 *pparmlen, __u32 *pdatalen)\n{\n\tchar *end_of_smb;\n\t__u32 data_count, data_offset, parm_count, parm_offset;\n\tstruct smb_com_ntransact_rsp *pSMBr;\n\tu16 bcc;\n\n\t*pdatalen = 0;\n\t*pparmlen = 0;\n\n\tif (buf == NULL)\n\t\treturn -EINVAL;\n\n\tpSMBr = (struct smb_com_ntransact_rsp *)buf;\n\n\tbcc = get_bcc(&pSMBr->hdr);\n\tend_of_smb = 2 /* sizeof byte count */ + bcc +\n\t\t\t(char *)&pSMBr->ByteCount;\n\n\tdata_offset = le32_to_cpu(pSMBr->DataOffset);\n\tdata_count = le32_to_cpu(pSMBr->DataCount);\n\tparm_offset = le32_to_cpu(pSMBr->ParameterOffset);\n\tparm_count = le32_to_cpu(pSMBr->ParameterCount);\n\n\t*ppparm = (char *)&pSMBr->hdr.Protocol + parm_offset;\n\t*ppdata = (char *)&pSMBr->hdr.Protocol + data_offset;\n\n\t/* should we also check that parm and data areas do not overlap? */\n\tif (*ppparm > end_of_smb) {\n\t\tcFYI(1, \"parms start after end of smb\");\n\t\treturn -EINVAL;\n\t} else if (parm_count + *ppparm > end_of_smb) {\n\t\tcFYI(1, \"parm end after end of smb\");\n\t\treturn -EINVAL;\n\t} else if (*ppdata > end_of_smb) {\n\t\tcFYI(1, \"data starts after end of smb\");\n\t\treturn -EINVAL;\n\t} else if (data_count + *ppdata > end_of_smb) {\n\t\tcFYI(1, \"data %p + count %d (%p) past smb end %p start %p\",\n\t\t\t*ppdata, data_count, (data_count + *ppdata),\n\t\t\tend_of_smb, pSMBr);\n\t\treturn -EINVAL;\n\t} else if (parm_count + data_count > bcc) {\n\t\tcFYI(1, \"parm count and data count larger than SMB\");\n\t\treturn -EINVAL;\n\t}\n\t*pdatalen = data_count;\n\t*pparmlen = parm_count;\n\treturn 0;\n}\n\n/* Get Security Descriptor (by handle) from remote server for a file or dir */\nint\nCIFSSMBGetCIFSACL(const int xid, struct cifs_tcon *tcon, __u16 fid,\n\t\t  struct cifs_ntsd **acl_inf, __u32 *pbuflen)\n{\n\tint rc = 0;\n\tint buf_type = 0;\n\tQUERY_SEC_DESC_REQ *pSMB;\n\tstruct kvec iov[1];\n\n\tcFYI(1, \"GetCifsACL\");\n\n\t*pbuflen = 0;\n\t*acl_inf = NULL;\n\n\trc = smb_init_nttransact(NT_TRANSACT_QUERY_SECURITY_DESC, 0,\n\t\t\t8 /* parm len */, tcon, (void **) &pSMB);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->MaxParameterCount = cpu_to_le32(4);\n\t/* BB TEST with big acls that might need to be e.g. larger than 16K */\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Fid = fid; /* file handle always le */\n\tpSMB->AclFlags = cpu_to_le32(CIFS_ACL_OWNER | CIFS_ACL_GROUP |\n\t\t\t\t     CIFS_ACL_DACL);\n\tpSMB->ByteCount = cpu_to_le16(11); /* 3 bytes pad + 8 bytes parm */\n\tinc_rfc1001_len(pSMB, 11);\n\tiov[0].iov_base = (char *)pSMB;\n\tiov[0].iov_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 4;\n\n\trc = SendReceive2(xid, tcon->ses, iov, 1 /* num iovec */, &buf_type,\n\t\t\t 0);\n\tcifs_stats_inc(&tcon->num_acl_get);\n\tif (rc) {\n\t\tcFYI(1, \"Send error in QuerySecDesc = %d\", rc);\n\t} else {                /* decode response */\n\t\t__le32 *parm;\n\t\t__u32 parm_len;\n\t\t__u32 acl_len;\n\t\tstruct smb_com_ntransact_rsp *pSMBr;\n\t\tchar *pdata;\n\n/* validate_nttransact */\n\t\trc = validate_ntransact(iov[0].iov_base, (char **)&parm,\n\t\t\t\t\t&pdata, &parm_len, pbuflen);\n\t\tif (rc)\n\t\t\tgoto qsec_out;\n\t\tpSMBr = (struct smb_com_ntransact_rsp *)iov[0].iov_base;\n\n\t\tcFYI(1, \"smb %p parm %p data %p\", pSMBr, parm, *acl_inf);\n\n\t\tif (le32_to_cpu(pSMBr->ParameterCount) != 4) {\n\t\t\trc = -EIO;      /* bad smb */\n\t\t\t*pbuflen = 0;\n\t\t\tgoto qsec_out;\n\t\t}\n\n/* BB check that data area is minimum length and as big as acl_len */\n\n\t\tacl_len = le32_to_cpu(*parm);\n\t\tif (acl_len != *pbuflen) {\n\t\t\tcERROR(1, \"acl length %d does not match %d\",\n\t\t\t\t   acl_len, *pbuflen);\n\t\t\tif (*pbuflen > acl_len)\n\t\t\t\t*pbuflen = acl_len;\n\t\t}\n\n\t\t/* check if buffer is big enough for the acl\n\t\t   header followed by the smallest SID */\n\t\tif ((*pbuflen < sizeof(struct cifs_ntsd) + 8) ||\n\t\t    (*pbuflen >= 64 * 1024)) {\n\t\t\tcERROR(1, \"bad acl length %d\", *pbuflen);\n\t\t\trc = -EINVAL;\n\t\t\t*pbuflen = 0;\n\t\t} else {\n\t\t\t*acl_inf = kmalloc(*pbuflen, GFP_KERNEL);\n\t\t\tif (*acl_inf == NULL) {\n\t\t\t\t*pbuflen = 0;\n\t\t\t\trc = -ENOMEM;\n\t\t\t}\n\t\t\tmemcpy(*acl_inf, pdata, *pbuflen);\n\t\t}\n\t}\nqsec_out:\n\tif (buf_type == CIFS_SMALL_BUFFER)\n\t\tcifs_small_buf_release(iov[0].iov_base);\n\telse if (buf_type == CIFS_LARGE_BUFFER)\n\t\tcifs_buf_release(iov[0].iov_base);\n/*\tcifs_small_buf_release(pSMB); */ /* Freed earlier now in SendReceive2 */\n\treturn rc;\n}\n\nint\nCIFSSMBSetCIFSACL(const int xid, struct cifs_tcon *tcon, __u16 fid,\n\t\t\tstruct cifs_ntsd *pntsd, __u32 acllen)\n{\n\t__u16 byte_count, param_count, data_count, param_offset, data_offset;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tSET_SEC_DESC_REQ *pSMB = NULL;\n\tNTRANSACT_RSP *pSMBr = NULL;\n\nsetCifsAclRetry:\n\trc = smb_init(SMB_COM_NT_TRANSACT, 19, tcon, (void **) &pSMB,\n\t\t\t(void **) &pSMBr);\n\tif (rc)\n\t\t\treturn (rc);\n\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\n\tparam_count = 8;\n\tparam_offset = offsetof(struct smb_com_transaction_ssec_req, Fid) - 4;\n\tdata_count = acllen;\n\tdata_offset = param_offset + param_count;\n\tbyte_count = 3 /* pad */  + param_count;\n\n\tpSMB->DataCount = cpu_to_le32(data_count);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->MaxParameterCount = cpu_to_le32(4);\n\tpSMB->MaxDataCount = cpu_to_le32(16384);\n\tpSMB->ParameterCount = cpu_to_le32(param_count);\n\tpSMB->ParameterOffset = cpu_to_le32(param_offset);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->DataOffset = cpu_to_le32(data_offset);\n\tpSMB->SetupCount = 0;\n\tpSMB->SubCommand = cpu_to_le16(NT_TRANSACT_SET_SECURITY_DESC);\n\tpSMB->ByteCount = cpu_to_le16(byte_count+data_count);\n\n\tpSMB->Fid = fid; /* file handle always le */\n\tpSMB->Reserved2 = 0;\n\tpSMB->AclFlags = cpu_to_le32(CIFS_ACL_DACL);\n\n\tif (pntsd && acllen) {\n\t\tmemcpy((char *) &pSMBr->hdr.Protocol + data_offset,\n\t\t\t(char *) pntsd,\n\t\t\tacllen);\n\t\tinc_rfc1001_len(pSMB, byte_count + data_count);\n\t} else\n\t\tinc_rfc1001_len(pSMB, byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\n\tcFYI(1, \"SetCIFSACL bytes_returned: %d, rc: %d\", bytes_returned, rc);\n\tif (rc)\n\t\tcFYI(1, \"Set CIFS ACL returned %d\", rc);\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto setCifsAclRetry;\n\n\treturn (rc);\n}\n\n#endif /* CONFIG_CIFS_ACL */\n\n/* Legacy Query Path Information call for lookup to old servers such\n   as Win9x/WinME */\nint SMBQueryInformation(const int xid, struct cifs_tcon *tcon,\n\t\t\tconst unsigned char *searchName,\n\t\t\tFILE_ALL_INFO *pFinfo,\n\t\t\tconst struct nls_table *nls_codepage, int remap)\n{\n\tQUERY_INFORMATION_REQ *pSMB;\n\tQUERY_INFORMATION_RSP *pSMBr;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\n\tcFYI(1, \"In SMBQPath path %s\", searchName);\nQInfRetry:\n\trc = smb_init(SMB_COM_QUERY_INFORMATION, 0, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t\tcifsConvertToUCS((__le16 *) pSMB->FileName, searchName,\n\t\t\t\t\tPATH_MAX, nls_codepage, remap);\n\t\tname_len++;     /* trailing null */\n\t\tname_len *= 2;\n\t} else {\n\t\tname_len = strnlen(searchName, PATH_MAX);\n\t\tname_len++;     /* trailing null */\n\t\tstrncpy(pSMB->FileName, searchName, name_len);\n\t}\n\tpSMB->BufferFormat = 0x04;\n\tname_len++; /* account for buffer type byte */\n\tinc_rfc1001_len(pSMB, (__u16)name_len);\n\tpSMB->ByteCount = cpu_to_le16(name_len);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcFYI(1, \"Send error in QueryInfo = %d\", rc);\n\t} else if (pFinfo) {\n\t\tstruct timespec ts;\n\t\t__u32 time = le32_to_cpu(pSMBr->last_write_time);\n\n\t\t/* decode response */\n\t\t/* BB FIXME - add time zone adjustment BB */\n\t\tmemset(pFinfo, 0, sizeof(FILE_ALL_INFO));\n\t\tts.tv_nsec = 0;\n\t\tts.tv_sec = time;\n\t\t/* decode time fields */\n\t\tpFinfo->ChangeTime = cpu_to_le64(cifs_UnixTimeToNT(ts));\n\t\tpFinfo->LastWriteTime = pFinfo->ChangeTime;\n\t\tpFinfo->LastAccessTime = 0;\n\t\tpFinfo->AllocationSize =\n\t\t\tcpu_to_le64(le32_to_cpu(pSMBr->size));\n\t\tpFinfo->EndOfFile = pFinfo->AllocationSize;\n\t\tpFinfo->Attributes =\n\t\t\tcpu_to_le32(le16_to_cpu(pSMBr->attr));\n\t} else\n\t\trc = -EIO; /* bad buffer passed in */\n\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QInfRetry;\n\n\treturn rc;\n}\n\nint\nCIFSSMBQFileInfo(const int xid, struct cifs_tcon *tcon,\n\t\t u16 netfid, FILE_ALL_INFO *pFindData)\n{\n\tstruct smb_t2_qfi_req *pSMB = NULL;\n\tstruct smb_t2_qfi_rsp *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\t__u16 params, byte_count;\n\nQFileInfoRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2 /* level */ + 2 /* fid */;\n\tpSMB->t2.TotalDataCount = 0;\n\tpSMB->t2.MaxParameterCount = cpu_to_le16(4);\n\t/* BB find exact max data count below from sess structure BB */\n\tpSMB->t2.MaxDataCount = cpu_to_le16(CIFSMaxBufSize);\n\tpSMB->t2.MaxSetupCount = 0;\n\tpSMB->t2.Reserved = 0;\n\tpSMB->t2.Flags = 0;\n\tpSMB->t2.Timeout = 0;\n\tpSMB->t2.Reserved2 = 0;\n\tpSMB->t2.ParameterOffset = cpu_to_le16(offsetof(struct smb_t2_qfi_req,\n\t\t\t\t\t       Fid) - 4);\n\tpSMB->t2.DataCount = 0;\n\tpSMB->t2.DataOffset = 0;\n\tpSMB->t2.SetupCount = 1;\n\tpSMB->t2.Reserved3 = 0;\n\tpSMB->t2.SubCommand = cpu_to_le16(TRANS2_QUERY_FILE_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->t2.TotalParameterCount = cpu_to_le16(params);\n\tpSMB->t2.ParameterCount = pSMB->t2.TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_ALL_INFO);\n\tpSMB->Pad = 0;\n\tpSMB->Fid = netfid;\n\tinc_rfc1001_len(pSMB, byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcFYI(1, \"Send error in QPathInfo = %d\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc) /* BB add auto retry on EOPNOTSUPP? */\n\t\t\trc = -EIO;\n\t\telse if (get_bcc(&pSMBr->hdr) < 40)\n\t\t\trc = -EIO;\t/* bad smb */\n\t\telse if (pFindData) {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tmemcpy((char *) pFindData,\n\t\t\t       (char *) &pSMBr->hdr.Protocol +\n\t\t\t       data_offset, sizeof(FILE_ALL_INFO));\n\t\t} else\n\t\t    rc = -ENOMEM;\n\t}\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto QFileInfoRetry;\n\n\treturn rc;\n}\n\nint\nCIFSSMBQPathInfo(const int xid, struct cifs_tcon *tcon,\n\t\t const unsigned char *searchName,\n\t\t FILE_ALL_INFO *pFindData,\n\t\t int legacy /* old style infolevel */,\n\t\t const struct nls_table *nls_codepage, int remap)\n{\n/* level 263 SMB_QUERY_FILE_ALL_INFO */\n\tTRANSACTION2_QPI_REQ *pSMB = NULL;\n\tTRANSACTION2_QPI_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 params, byte_count;\n\n/* cFYI(1, \"In QPathInfo path %s\", searchName); */\nQPathInfoRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUCS((__le16 *) pSMB->FileName, searchName,\n\t\t\t\t     PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(searchName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, searchName, name_len);\n\t}\n\n\tparams = 2 /* level */ + 4 /* reserved */ + name_len /* includes NUL */;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(4000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\tstruct smb_com_transaction2_qpi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_PATH_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tif (legacy)\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_INFO_STANDARD);\n\telse\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_ALL_INFO);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcFYI(1, \"Send error in QPathInfo = %d\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc) /* BB add auto retry on EOPNOTSUPP? */\n\t\t\trc = -EIO;\n\t\telse if (!legacy && get_bcc(&pSMBr->hdr) < 40)\n\t\t\trc = -EIO;\t/* bad smb */\n\t\telse if (legacy && get_bcc(&pSMBr->hdr) < 24)\n\t\t\trc = -EIO;  /* 24 or 26 expected but we do not read\n\t\t\t\t\tlast field */\n\t\telse if (pFindData) {\n\t\t\tint size;\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\n\t\t\t/* On legacy responses we do not read the last field,\n\t\t\tEAsize, fortunately since it varies by subdialect and\n\t\t\talso note it differs on Set vs. Get, ie two bytes or 4\n\t\t\tbytes depending but we don't care here */\n\t\t\tif (legacy)\n\t\t\t\tsize = sizeof(FILE_INFO_STANDARD);\n\t\t\telse\n\t\t\t\tsize = sizeof(FILE_ALL_INFO);\n\t\t\tmemcpy((char *) pFindData,\n\t\t\t       (char *) &pSMBr->hdr.Protocol +\n\t\t\t       data_offset, size);\n\t\t} else\n\t\t    rc = -ENOMEM;\n\t}\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto QPathInfoRetry;\n\n\treturn rc;\n}\n\nint\nCIFSSMBUnixQFileInfo(const int xid, struct cifs_tcon *tcon,\n\t\t u16 netfid, FILE_UNIX_BASIC_INFO *pFindData)\n{\n\tstruct smb_t2_qfi_req *pSMB = NULL;\n\tstruct smb_t2_qfi_rsp *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\t__u16 params, byte_count;\n\nUnixQFileInfoRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2 /* level */ + 2 /* fid */;\n\tpSMB->t2.TotalDataCount = 0;\n\tpSMB->t2.MaxParameterCount = cpu_to_le16(4);\n\t/* BB find exact max data count below from sess structure BB */\n\tpSMB->t2.MaxDataCount = cpu_to_le16(CIFSMaxBufSize);\n\tpSMB->t2.MaxSetupCount = 0;\n\tpSMB->t2.Reserved = 0;\n\tpSMB->t2.Flags = 0;\n\tpSMB->t2.Timeout = 0;\n\tpSMB->t2.Reserved2 = 0;\n\tpSMB->t2.ParameterOffset = cpu_to_le16(offsetof(struct smb_t2_qfi_req,\n\t\t\t\t\t       Fid) - 4);\n\tpSMB->t2.DataCount = 0;\n\tpSMB->t2.DataOffset = 0;\n\tpSMB->t2.SetupCount = 1;\n\tpSMB->t2.Reserved3 = 0;\n\tpSMB->t2.SubCommand = cpu_to_le16(TRANS2_QUERY_FILE_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->t2.TotalParameterCount = cpu_to_le16(params);\n\tpSMB->t2.ParameterCount = pSMB->t2.TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_UNIX_BASIC);\n\tpSMB->Pad = 0;\n\tpSMB->Fid = netfid;\n\tinc_rfc1001_len(pSMB, byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcFYI(1, \"Send error in QPathInfo = %d\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < sizeof(FILE_UNIX_BASIC_INFO)) {\n\t\t\tcERROR(1, \"Malformed FILE_UNIX_BASIC_INFO response.\\n\"\n\t\t\t\t   \"Unix Extensions can be disabled on mount \"\n\t\t\t\t   \"by specifying the nosfu mount option.\");\n\t\t\trc = -EIO;\t/* bad smb */\n\t\t} else {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tmemcpy((char *) pFindData,\n\t\t\t       (char *) &pSMBr->hdr.Protocol +\n\t\t\t       data_offset,\n\t\t\t       sizeof(FILE_UNIX_BASIC_INFO));\n\t\t}\n\t}\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto UnixQFileInfoRetry;\n\n\treturn rc;\n}\n\nint\nCIFSSMBUnixQPathInfo(const int xid, struct cifs_tcon *tcon,\n\t\t     const unsigned char *searchName,\n\t\t     FILE_UNIX_BASIC_INFO *pFindData,\n\t\t     const struct nls_table *nls_codepage, int remap)\n{\n/* SMB_QUERY_FILE_UNIX_BASIC */\n\tTRANSACTION2_QPI_REQ *pSMB = NULL;\n\tTRANSACTION2_QPI_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tint name_len;\n\t__u16 params, byte_count;\n\n\tcFYI(1, \"In QPathInfo (Unix) the path %s\", searchName);\nUnixQPathInfoRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUCS((__le16 *) pSMB->FileName, searchName,\n\t\t\t\t  PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(searchName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, searchName, name_len);\n\t}\n\n\tparams = 2 /* level */ + 4 /* reserved */ + name_len /* includes NUL */;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(4000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\tstruct smb_com_transaction2_qpi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_PATH_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_UNIX_BASIC);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcFYI(1, \"Send error in QPathInfo = %d\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < sizeof(FILE_UNIX_BASIC_INFO)) {\n\t\t\tcERROR(1, \"Malformed FILE_UNIX_BASIC_INFO response.\\n\"\n\t\t\t\t   \"Unix Extensions can be disabled on mount \"\n\t\t\t\t   \"by specifying the nosfu mount option.\");\n\t\t\trc = -EIO;\t/* bad smb */\n\t\t} else {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tmemcpy((char *) pFindData,\n\t\t\t       (char *) &pSMBr->hdr.Protocol +\n\t\t\t       data_offset,\n\t\t\t       sizeof(FILE_UNIX_BASIC_INFO));\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto UnixQPathInfoRetry;\n\n\treturn rc;\n}\n\n/* xid, tcon, searchName and codepage are input parms, rest are returned */\nint\nCIFSFindFirst(const int xid, struct cifs_tcon *tcon,\n\t      const char *searchName,\n\t      const struct nls_table *nls_codepage,\n\t      __u16 *pnetfid,\n\t      struct cifs_search_info *psrch_inf, int remap, const char dirsep)\n{\n/* level 257 SMB_ */\n\tTRANSACTION2_FFIRST_REQ *pSMB = NULL;\n\tTRANSACTION2_FFIRST_RSP *pSMBr = NULL;\n\tT2_FFIRST_RSP_PARMS *parms;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tint name_len;\n\t__u16 params, byte_count;\n\n\tcFYI(1, \"In FindFirst for %s\", searchName);\n\nfindFirstRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUCS((__le16 *) pSMB->FileName, searchName,\n\t\t\t\t PATH_MAX, nls_codepage, remap);\n\t\t/* We can not add the asterik earlier in case\n\t\tit got remapped to 0xF03A as if it were part of the\n\t\tdirectory name instead of a wildcard */\n\t\tname_len *= 2;\n\t\tpSMB->FileName[name_len] = dirsep;\n\t\tpSMB->FileName[name_len+1] = 0;\n\t\tpSMB->FileName[name_len+2] = '*';\n\t\tpSMB->FileName[name_len+3] = 0;\n\t\tname_len += 4; /* now the trailing null */\n\t\tpSMB->FileName[name_len] = 0; /* null terminate just in case */\n\t\tpSMB->FileName[name_len+1] = 0;\n\t\tname_len += 2;\n\t} else {\t/* BB add check for overrun of SMB buf BB */\n\t\tname_len = strnlen(searchName, PATH_MAX);\n/* BB fix here and in unicode clause above ie\n\t\tif (name_len > buffersize-header)\n\t\t\tfree buffer exit; BB */\n\t\tstrncpy(pSMB->FileName, searchName, name_len);\n\t\tpSMB->FileName[name_len] = dirsep;\n\t\tpSMB->FileName[name_len+1] = '*';\n\t\tpSMB->FileName[name_len+2] = 0;\n\t\tname_len += 3;\n\t}\n\n\tparams = 12 + name_len /* includes null */ ;\n\tpSMB->TotalDataCount = 0;\t/* no EAs */\n\tpSMB->MaxParameterCount = cpu_to_le16(10);\n\tpSMB->MaxDataCount = cpu_to_le16((tcon->ses->server->maxBuf -\n\t\t\t\t\t  MAX_CIFS_HDR_SIZE) & 0xFFFFFF00);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(\n\t      offsetof(struct smb_com_transaction2_ffirst_req, SearchAttributes)\n\t\t- 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\t/* one byte, no need to make endian neutral */\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_FIND_FIRST);\n\tpSMB->SearchAttributes =\n\t    cpu_to_le16(ATTR_READONLY | ATTR_HIDDEN | ATTR_SYSTEM |\n\t\t\tATTR_DIRECTORY);\n\tpSMB->SearchCount = cpu_to_le16(CIFSMaxBufSize/sizeof(FILE_UNIX_INFO));\n\tpSMB->SearchFlags = cpu_to_le16(CIFS_SEARCH_CLOSE_AT_END |\n\t\tCIFS_SEARCH_RETURN_RESUME);\n\tpSMB->InformationLevel = cpu_to_le16(psrch_inf->info_level);\n\n\t/* BB what should we set StorageType to? Does it matter? BB */\n\tpSMB->SearchStorageType = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->num_ffirst);\n\n\tif (rc) {/* BB add logic to retry regular search if Unix search\n\t\t\trejected unexpectedly by server */\n\t\t/* BB Add code to handle unsupported level rc */\n\t\tcFYI(1, \"Error in FindFirst = %d\", rc);\n\n\t\tcifs_buf_release(pSMB);\n\n\t\t/* BB eventually could optimize out free and realloc of buf */\n\t\t/*    for this case */\n\t\tif (rc == -EAGAIN)\n\t\t\tgoto findFirstRetry;\n\t} else { /* decode response */\n\t\t/* BB remember to free buffer if error BB */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\t\tif (rc == 0) {\n\t\t\tunsigned int lnoff;\n\n\t\t\tif (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE)\n\t\t\t\tpsrch_inf->unicode = true;\n\t\t\telse\n\t\t\t\tpsrch_inf->unicode = false;\n\n\t\t\tpsrch_inf->ntwrk_buf_start = (char *)pSMBr;\n\t\t\tpsrch_inf->smallBuf = 0;\n\t\t\tpsrch_inf->srch_entries_start =\n\t\t\t\t(char *) &pSMBr->hdr.Protocol +\n\t\t\t\t\tle16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tparms = (T2_FFIRST_RSP_PARMS *)((char *) &pSMBr->hdr.Protocol +\n\t\t\t       le16_to_cpu(pSMBr->t2.ParameterOffset));\n\n\t\t\tif (parms->EndofSearch)\n\t\t\t\tpsrch_inf->endOfSearch = true;\n\t\t\telse\n\t\t\t\tpsrch_inf->endOfSearch = false;\n\n\t\t\tpsrch_inf->entries_in_buffer =\n\t\t\t\t\tle16_to_cpu(parms->SearchCount);\n\t\t\tpsrch_inf->index_of_last_entry = 2 /* skip . and .. */ +\n\t\t\t\tpsrch_inf->entries_in_buffer;\n\t\t\tlnoff = le16_to_cpu(parms->LastNameOffset);\n\t\t\tif (tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE <\n\t\t\t      lnoff) {\n\t\t\t\tcERROR(1, \"ignoring corrupt resume name\");\n\t\t\t\tpsrch_inf->last_entry = NULL;\n\t\t\t\treturn rc;\n\t\t\t}\n\n\t\t\tpsrch_inf->last_entry = psrch_inf->srch_entries_start +\n\t\t\t\t\t\t\tlnoff;\n\n\t\t\t*pnetfid = parms->SearchHandle;\n\t\t} else {\n\t\t\tcifs_buf_release(pSMB);\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nint CIFSFindNext(const int xid, struct cifs_tcon *tcon,\n\t\t __u16 searchHandle, struct cifs_search_info *psrch_inf)\n{\n\tTRANSACTION2_FNEXT_REQ *pSMB = NULL;\n\tTRANSACTION2_FNEXT_RSP *pSMBr = NULL;\n\tT2_FNEXT_RSP_PARMS *parms;\n\tchar *response_data;\n\tint rc = 0;\n\tint bytes_returned, name_len;\n\t__u16 params, byte_count;\n\n\tcFYI(1, \"In FindNext\");\n\n\tif (psrch_inf->endOfSearch)\n\t\treturn -ENOENT;\n\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t(void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 14; /* includes 2 bytes of null string, converted to LE below*/\n\tbyte_count = 0;\n\tpSMB->TotalDataCount = 0;       /* no EAs */\n\tpSMB->MaxParameterCount = cpu_to_le16(8);\n\tpSMB->MaxDataCount =\n\t\tcpu_to_le16((tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE) &\n\t\t\t\t0xFFFFFF00);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset =  cpu_to_le16(\n\t      offsetof(struct smb_com_transaction2_fnext_req,SearchHandle) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_FIND_NEXT);\n\tpSMB->SearchHandle = searchHandle;      /* always kept as le */\n\tpSMB->SearchCount =\n\t\tcpu_to_le16(CIFSMaxBufSize / sizeof(FILE_UNIX_INFO));\n\tpSMB->InformationLevel = cpu_to_le16(psrch_inf->info_level);\n\tpSMB->ResumeKey = psrch_inf->resume_key;\n\tpSMB->SearchFlags =\n\t      cpu_to_le16(CIFS_SEARCH_CLOSE_AT_END | CIFS_SEARCH_RETURN_RESUME);\n\n\tname_len = psrch_inf->resume_name_len;\n\tparams += name_len;\n\tif (name_len < PATH_MAX) {\n\t\tmemcpy(pSMB->ResumeFileName, psrch_inf->presume_name, name_len);\n\t\tbyte_count += name_len;\n\t\t/* 14 byte parm len above enough for 2 byte null terminator */\n\t\tpSMB->ResumeFileName[name_len] = 0;\n\t\tpSMB->ResumeFileName[name_len+1] = 0;\n\t} else {\n\t\trc = -EINVAL;\n\t\tgoto FNext2_err_exit;\n\t}\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->num_fnext);\n\tif (rc) {\n\t\tif (rc == -EBADF) {\n\t\t\tpsrch_inf->endOfSearch = true;\n\t\t\tcifs_buf_release(pSMB);\n\t\t\trc = 0; /* search probably was closed at end of search*/\n\t\t} else\n\t\t\tcFYI(1, \"FindNext returned = %d\", rc);\n\t} else {                /* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc == 0) {\n\t\t\tunsigned int lnoff;\n\n\t\t\t/* BB fixme add lock for file (srch_info) struct here */\n\t\t\tif (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE)\n\t\t\t\tpsrch_inf->unicode = true;\n\t\t\telse\n\t\t\t\tpsrch_inf->unicode = false;\n\t\t\tresponse_data = (char *) &pSMBr->hdr.Protocol +\n\t\t\t       le16_to_cpu(pSMBr->t2.ParameterOffset);\n\t\t\tparms = (T2_FNEXT_RSP_PARMS *)response_data;\n\t\t\tresponse_data = (char *)&pSMBr->hdr.Protocol +\n\t\t\t\tle16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tif (psrch_inf->smallBuf)\n\t\t\t\tcifs_small_buf_release(\n\t\t\t\t\tpsrch_inf->ntwrk_buf_start);\n\t\t\telse\n\t\t\t\tcifs_buf_release(psrch_inf->ntwrk_buf_start);\n\t\t\tpsrch_inf->srch_entries_start = response_data;\n\t\t\tpsrch_inf->ntwrk_buf_start = (char *)pSMB;\n\t\t\tpsrch_inf->smallBuf = 0;\n\t\t\tif (parms->EndofSearch)\n\t\t\t\tpsrch_inf->endOfSearch = true;\n\t\t\telse\n\t\t\t\tpsrch_inf->endOfSearch = false;\n\t\t\tpsrch_inf->entries_in_buffer =\n\t\t\t\t\t\tle16_to_cpu(parms->SearchCount);\n\t\t\tpsrch_inf->index_of_last_entry +=\n\t\t\t\tpsrch_inf->entries_in_buffer;\n\t\t\tlnoff = le16_to_cpu(parms->LastNameOffset);\n\t\t\tif (tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE <\n\t\t\t      lnoff) {\n\t\t\t\tcERROR(1, \"ignoring corrupt resume name\");\n\t\t\t\tpsrch_inf->last_entry = NULL;\n\t\t\t\treturn rc;\n\t\t\t} else\n\t\t\t\tpsrch_inf->last_entry =\n\t\t\t\t\tpsrch_inf->srch_entries_start + lnoff;\n\n/*  cFYI(1, \"fnxt2 entries in buf %d index_of_last %d\",\n\t    psrch_inf->entries_in_buffer, psrch_inf->index_of_last_entry); */\n\n\t\t\t/* BB fixme add unlock here */\n\t\t}\n\n\t}\n\n\t/* BB On error, should we leave previous search buf (and count and\n\tlast entry fields) intact or free the previous one? */\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\tsince file handle passed in no longer valid */\nFNext2_err_exit:\n\tif (rc != 0)\n\t\tcifs_buf_release(pSMB);\n\treturn rc;\n}\n\nint\nCIFSFindClose(const int xid, struct cifs_tcon *tcon,\n\t      const __u16 searchHandle)\n{\n\tint rc = 0;\n\tFINDCLOSE_REQ *pSMB = NULL;\n\n\tcFYI(1, \"In CIFSSMBFindClose\");\n\trc = small_smb_init(SMB_COM_FIND_CLOSE2, 1, tcon, (void **)&pSMB);\n\n\t/* no sense returning error if session restarted\n\t\tas file handle has been closed */\n\tif (rc == -EAGAIN)\n\t\treturn 0;\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->FileID = searchHandle;\n\tpSMB->ByteCount = 0;\n\trc = SendReceiveNoRsp(xid, tcon->ses, (struct smb_hdr *) pSMB, 0);\n\tif (rc)\n\t\tcERROR(1, \"Send error in FindClose = %d\", rc);\n\n\tcifs_stats_inc(&tcon->num_fclose);\n\n\t/* Since session is dead, search handle closed on server already */\n\tif (rc == -EAGAIN)\n\t\trc = 0;\n\n\treturn rc;\n}\n\nint\nCIFSGetSrvInodeNumber(const int xid, struct cifs_tcon *tcon,\n\t\t      const unsigned char *searchName,\n\t\t      __u64 *inode_number,\n\t\t      const struct nls_table *nls_codepage, int remap)\n{\n\tint rc = 0;\n\tTRANSACTION2_QPI_REQ *pSMB = NULL;\n\tTRANSACTION2_QPI_RSP *pSMBr = NULL;\n\tint name_len, bytes_returned;\n\t__u16 params, byte_count;\n\n\tcFYI(1, \"In GetSrvInodeNum for %s\", searchName);\n\tif (tcon == NULL)\n\t\treturn -ENODEV;\n\nGetInodeNumberRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t\tcifsConvertToUCS((__le16 *) pSMB->FileName, searchName,\n\t\t\t\t\t PATH_MAX, nls_codepage, remap);\n\t\tname_len++;     /* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(searchName, PATH_MAX);\n\t\tname_len++;     /* trailing null */\n\t\tstrncpy(pSMB->FileName, searchName, name_len);\n\t}\n\n\tparams = 2 /* level */  + 4 /* rsrvd */  + name_len /* incl null */ ;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max data count below from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(4000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\t\tstruct smb_com_transaction2_qpi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_PATH_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_INTERNAL_INFO);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcFYI(1, \"error %d in QueryInternalInfo\", rc);\n\t} else {\n\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\t\t/* BB also check enough total bytes returned */\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 2)\n\t\t\t/* If rc should we check for EOPNOSUPP and\n\t\t\tdisable the srvino flag? or in caller? */\n\t\t\trc = -EIO;      /* bad smb */\n\t\telse {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\t__u16 count = le16_to_cpu(pSMBr->t2.DataCount);\n\t\t\tstruct file_internal_info *pfinfo;\n\t\t\t/* BB Do we need a cast or hash here ? */\n\t\t\tif (count < 8) {\n\t\t\t\tcFYI(1, \"Illegal size ret in QryIntrnlInf\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto GetInodeNumOut;\n\t\t\t}\n\t\t\tpfinfo = (struct file_internal_info *)\n\t\t\t\t(data_offset + (char *) &pSMBr->hdr.Protocol);\n\t\t\t*inode_number = le64_to_cpu(pfinfo->UniqueId);\n\t\t}\n\t}\nGetInodeNumOut:\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto GetInodeNumberRetry;\n\treturn rc;\n}\n\n/* parses DFS refferal V3 structure\n * caller is responsible for freeing target_nodes\n * returns:\n * \ton success - 0\n *\ton failure - errno\n */\nstatic int\nparse_DFS_referrals(TRANSACTION2_GET_DFS_REFER_RSP *pSMBr,\n\t\tunsigned int *num_of_nodes,\n\t\tstruct dfs_info3_param **target_nodes,\n\t\tconst struct nls_table *nls_codepage, int remap,\n\t\tconst char *searchName)\n{\n\tint i, rc = 0;\n\tchar *data_end;\n\tbool is_unicode;\n\tstruct dfs_referral_level_3 *ref;\n\n\tif (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE)\n\t\tis_unicode = true;\n\telse\n\t\tis_unicode = false;\n\t*num_of_nodes = le16_to_cpu(pSMBr->NumberOfReferrals);\n\n\tif (*num_of_nodes < 1) {\n\t\tcERROR(1, \"num_referrals: must be at least > 0,\"\n\t\t\t\"but we get num_referrals = %d\\n\", *num_of_nodes);\n\t\trc = -EINVAL;\n\t\tgoto parse_DFS_referrals_exit;\n\t}\n\n\tref = (struct dfs_referral_level_3 *) &(pSMBr->referrals);\n\tif (ref->VersionNumber != cpu_to_le16(3)) {\n\t\tcERROR(1, \"Referrals of V%d version are not supported,\"\n\t\t\t\"should be V3\", le16_to_cpu(ref->VersionNumber));\n\t\trc = -EINVAL;\n\t\tgoto parse_DFS_referrals_exit;\n\t}\n\n\t/* get the upper boundary of the resp buffer */\n\tdata_end = (char *)(&(pSMBr->PathConsumed)) +\n\t\t\t\tle16_to_cpu(pSMBr->t2.DataCount);\n\n\tcFYI(1, \"num_referrals: %d dfs flags: 0x%x ...\\n\",\n\t\t\t*num_of_nodes,\n\t\t\tle32_to_cpu(pSMBr->DFSFlags));\n\n\t*target_nodes = kzalloc(sizeof(struct dfs_info3_param) *\n\t\t\t*num_of_nodes, GFP_KERNEL);\n\tif (*target_nodes == NULL) {\n\t\tcERROR(1, \"Failed to allocate buffer for target_nodes\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto parse_DFS_referrals_exit;\n\t}\n\n\t/* collect necessary data from referrals */\n\tfor (i = 0; i < *num_of_nodes; i++) {\n\t\tchar *temp;\n\t\tint max_len;\n\t\tstruct dfs_info3_param *node = (*target_nodes)+i;\n\n\t\tnode->flags = le32_to_cpu(pSMBr->DFSFlags);\n\t\tif (is_unicode) {\n\t\t\t__le16 *tmp = kmalloc(strlen(searchName)*2 + 2,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (tmp == NULL) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto parse_DFS_referrals_exit;\n\t\t\t}\n\t\t\tcifsConvertToUCS((__le16 *) tmp, searchName,\n\t\t\t\t\tPATH_MAX, nls_codepage, remap);\n\t\t\tnode->path_consumed = cifs_ucs2_bytes(tmp,\n\t\t\t\t\tle16_to_cpu(pSMBr->PathConsumed),\n\t\t\t\t\tnls_codepage);\n\t\t\tkfree(tmp);\n\t\t} else\n\t\t\tnode->path_consumed = le16_to_cpu(pSMBr->PathConsumed);\n\n\t\tnode->server_type = le16_to_cpu(ref->ServerType);\n\t\tnode->ref_flag = le16_to_cpu(ref->ReferralEntryFlags);\n\n\t\t/* copy DfsPath */\n\t\ttemp = (char *)ref + le16_to_cpu(ref->DfsPathOffset);\n\t\tmax_len = data_end - temp;\n\t\tnode->path_name = cifs_strndup_from_ucs(temp, max_len,\n\t\t\t\t\t\t      is_unicode, nls_codepage);\n\t\tif (!node->path_name) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto parse_DFS_referrals_exit;\n\t\t}\n\n\t\t/* copy link target UNC */\n\t\ttemp = (char *)ref + le16_to_cpu(ref->NetworkAddressOffset);\n\t\tmax_len = data_end - temp;\n\t\tnode->node_name = cifs_strndup_from_ucs(temp, max_len,\n\t\t\t\t\t\t      is_unicode, nls_codepage);\n\t\tif (!node->node_name)\n\t\t\trc = -ENOMEM;\n\t}\n\nparse_DFS_referrals_exit:\n\tif (rc) {\n\t\tfree_dfs_info_array(*target_nodes, *num_of_nodes);\n\t\t*target_nodes = NULL;\n\t\t*num_of_nodes = 0;\n\t}\n\treturn rc;\n}\n\nint\nCIFSGetDFSRefer(const int xid, struct cifs_ses *ses,\n\t\tconst unsigned char *searchName,\n\t\tstruct dfs_info3_param **target_nodes,\n\t\tunsigned int *num_of_nodes,\n\t\tconst struct nls_table *nls_codepage, int remap)\n{\n/* TRANS2_GET_DFS_REFERRAL */\n\tTRANSACTION2_GET_DFS_REFER_REQ *pSMB = NULL;\n\tTRANSACTION2_GET_DFS_REFER_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 params, byte_count;\n\t*num_of_nodes = 0;\n\t*target_nodes = NULL;\n\n\tcFYI(1, \"In GetDFSRefer the path %s\", searchName);\n\tif (ses == NULL)\n\t\treturn -ENODEV;\ngetDFSRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, NULL, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\t/* server pointer checked in called function,\n\tbut should never be null here anyway */\n\tpSMB->hdr.Mid = GetNextMid(ses->server);\n\tpSMB->hdr.Tid = ses->ipc_tid;\n\tpSMB->hdr.Uid = ses->Suid;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tpSMB->hdr.Flags2 |= SMBFLG2_ERR_STATUS;\n\tif (ses->capabilities & CAP_DFS)\n\t\tpSMB->hdr.Flags2 |= SMBFLG2_DFS;\n\n\tif (ses->capabilities & CAP_UNICODE) {\n\t\tpSMB->hdr.Flags2 |= SMBFLG2_UNICODE;\n\t\tname_len =\n\t\t    cifsConvertToUCS((__le16 *) pSMB->RequestFileName,\n\t\t\t\t     searchName, PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(searchName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->RequestFileName, searchName, name_len);\n\t}\n\n\tif (ses->server) {\n\t\tif (ses->server->sec_mode &\n\t\t   (SECMODE_SIGN_REQUIRED | SECMODE_SIGN_ENABLED))\n\t\t\tpSMB->hdr.Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\t}\n\n\tpSMB->hdr.Uid = ses->Suid;\n\n\tparams = 2 /* level */  + name_len /*includes null */ ;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->MaxParameterCount = 0;\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(4000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\t  struct smb_com_transaction2_get_dfs_refer_req, MaxReferralLevel) - 4);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_GET_DFS_REFERRAL);\n\tbyte_count = params + 3 /* pad */ ;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->MaxReferralLevel = cpu_to_le16(3);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcFYI(1, \"Send error in GetDFSRefer = %d\", rc);\n\t\tgoto GetDFSRefExit;\n\t}\n\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t/* BB Also check if enough total bytes returned? */\n\tif (rc || get_bcc(&pSMBr->hdr) < 17) {\n\t\trc = -EIO;      /* bad smb */\n\t\tgoto GetDFSRefExit;\n\t}\n\n\tcFYI(1, \"Decoding GetDFSRefer response BCC: %d  Offset %d\",\n\t\t\t\tget_bcc(&pSMBr->hdr),\n\t\t\t\tle16_to_cpu(pSMBr->t2.DataOffset));\n\n\t/* parse returned result into more usable form */\n\trc = parse_DFS_referrals(pSMBr, num_of_nodes,\n\t\t\t\t target_nodes, nls_codepage, remap,\n\t\t\t\t searchName);\n\nGetDFSRefExit:\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto getDFSRetry;\n\n\treturn rc;\n}\n\n/* Query File System Info such as free space to old servers such as Win 9x */\nint\nSMBOldQFSInfo(const int xid, struct cifs_tcon *tcon, struct kstatfs *FSData)\n{\n/* level 0x01 SMB_QUERY_FILE_SYSTEM_INFO */\n\tTRANSACTION2_QFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_QFSI_RSP *pSMBr = NULL;\n\tFILE_SYSTEM_ALLOC_INFO *response_data;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count;\n\n\tcFYI(1, \"OldQFSInfo\");\noldQFSInfoRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t(void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2;     /* level */\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\tstruct smb_com_transaction2_qfsi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_INFO_ALLOCATION);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcFYI(1, \"Send error in QFSInfo = %d\", rc);\n\t} else {                /* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 18)\n\t\t\trc = -EIO;      /* bad smb */\n\t\telse {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tcFYI(1, \"qfsinf resp BCC: %d  Offset %d\",\n\t\t\t\t get_bcc(&pSMBr->hdr), data_offset);\n\n\t\t\tresponse_data = (FILE_SYSTEM_ALLOC_INFO *)\n\t\t\t\t(((char *) &pSMBr->hdr.Protocol) + data_offset);\n\t\t\tFSData->f_bsize =\n\t\t\t\tle16_to_cpu(response_data->BytesPerSector) *\n\t\t\t\tle32_to_cpu(response_data->\n\t\t\t\t\tSectorsPerAllocationUnit);\n\t\t\tFSData->f_blocks =\n\t\t\t       le32_to_cpu(response_data->TotalAllocationUnits);\n\t\t\tFSData->f_bfree = FSData->f_bavail =\n\t\t\t\tle32_to_cpu(response_data->FreeAllocationUnits);\n\t\t\tcFYI(1, \"Blocks: %lld  Free: %lld Block size %ld\",\n\t\t\t     (unsigned long long)FSData->f_blocks,\n\t\t\t     (unsigned long long)FSData->f_bfree,\n\t\t\t     FSData->f_bsize);\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto oldQFSInfoRetry;\n\n\treturn rc;\n}\n\nint\nCIFSSMBQFSInfo(const int xid, struct cifs_tcon *tcon, struct kstatfs *FSData)\n{\n/* level 0x103 SMB_QUERY_FILE_SYSTEM_INFO */\n\tTRANSACTION2_QFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_QFSI_RSP *pSMBr = NULL;\n\tFILE_SYSTEM_INFO *response_data;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count;\n\n\tcFYI(1, \"In QFSInfo\");\nQFSInfoRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2;\t/* level */\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\t\tstruct smb_com_transaction2_qfsi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FS_SIZE_INFO);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcFYI(1, \"Send error in QFSInfo = %d\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 24)\n\t\t\trc = -EIO;\t/* bad smb */\n\t\telse {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\n\t\t\tresponse_data =\n\t\t\t    (FILE_SYSTEM_INFO\n\t\t\t     *) (((char *) &pSMBr->hdr.Protocol) +\n\t\t\t\t data_offset);\n\t\t\tFSData->f_bsize =\n\t\t\t    le32_to_cpu(response_data->BytesPerSector) *\n\t\t\t    le32_to_cpu(response_data->\n\t\t\t\t\tSectorsPerAllocationUnit);\n\t\t\tFSData->f_blocks =\n\t\t\t    le64_to_cpu(response_data->TotalAllocationUnits);\n\t\t\tFSData->f_bfree = FSData->f_bavail =\n\t\t\t    le64_to_cpu(response_data->FreeAllocationUnits);\n\t\t\tcFYI(1, \"Blocks: %lld  Free: %lld Block size %ld\",\n\t\t\t     (unsigned long long)FSData->f_blocks,\n\t\t\t     (unsigned long long)FSData->f_bfree,\n\t\t\t     FSData->f_bsize);\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QFSInfoRetry;\n\n\treturn rc;\n}\n\nint\nCIFSSMBQFSAttributeInfo(const int xid, struct cifs_tcon *tcon)\n{\n/* level 0x105  SMB_QUERY_FILE_SYSTEM_INFO */\n\tTRANSACTION2_QFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_QFSI_RSP *pSMBr = NULL;\n\tFILE_SYSTEM_ATTRIBUTE_INFO *response_data;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count;\n\n\tcFYI(1, \"In QFSAttributeInfo\");\nQFSAttributeRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2;\t/* level */\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\t\tstruct smb_com_transaction2_qfsi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FS_ATTRIBUTE_INFO);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcERROR(1, \"Send error in QFSAttributeInfo = %d\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 13) {\n\t\t\t/* BB also check if enough bytes returned */\n\t\t\trc = -EIO;\t/* bad smb */\n\t\t} else {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tresponse_data =\n\t\t\t    (FILE_SYSTEM_ATTRIBUTE_INFO\n\t\t\t     *) (((char *) &pSMBr->hdr.Protocol) +\n\t\t\t\t data_offset);\n\t\t\tmemcpy(&tcon->fsAttrInfo, response_data,\n\t\t\t       sizeof(FILE_SYSTEM_ATTRIBUTE_INFO));\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QFSAttributeRetry;\n\n\treturn rc;\n}\n\nint\nCIFSSMBQFSDeviceInfo(const int xid, struct cifs_tcon *tcon)\n{\n/* level 0x104 SMB_QUERY_FILE_SYSTEM_INFO */\n\tTRANSACTION2_QFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_QFSI_RSP *pSMBr = NULL;\n\tFILE_SYSTEM_DEVICE_INFO *response_data;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count;\n\n\tcFYI(1, \"In QFSDeviceInfo\");\nQFSDeviceRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2;\t/* level */\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\t\tstruct smb_com_transaction2_qfsi_req, InformationLevel) - 4);\n\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FS_DEVICE_INFO);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcFYI(1, \"Send error in QFSDeviceInfo = %d\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) <\n\t\t\t  sizeof(FILE_SYSTEM_DEVICE_INFO))\n\t\t\trc = -EIO;\t/* bad smb */\n\t\telse {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tresponse_data =\n\t\t\t    (FILE_SYSTEM_DEVICE_INFO *)\n\t\t\t\t(((char *) &pSMBr->hdr.Protocol) +\n\t\t\t\t data_offset);\n\t\t\tmemcpy(&tcon->fsDevInfo, response_data,\n\t\t\t       sizeof(FILE_SYSTEM_DEVICE_INFO));\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QFSDeviceRetry;\n\n\treturn rc;\n}\n\nint\nCIFSSMBQFSUnixInfo(const int xid, struct cifs_tcon *tcon)\n{\n/* level 0x200  SMB_QUERY_CIFS_UNIX_INFO */\n\tTRANSACTION2_QFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_QFSI_RSP *pSMBr = NULL;\n\tFILE_SYSTEM_UNIX_INFO *response_data;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count;\n\n\tcFYI(1, \"In QFSUnixInfo\");\nQFSUnixRetry:\n\trc = smb_init_no_reconnect(SMB_COM_TRANSACTION2, 15, tcon,\n\t\t\t\t   (void **) &pSMB, (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2;\t/* level */\n\tpSMB->TotalDataCount = 0;\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(100);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(struct\n\t\t\tsmb_com_transaction2_qfsi_req, InformationLevel) - 4);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_CIFS_UNIX_INFO);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcERROR(1, \"Send error in QFSUnixInfo = %d\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 13) {\n\t\t\trc = -EIO;\t/* bad smb */\n\t\t} else {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tresponse_data =\n\t\t\t    (FILE_SYSTEM_UNIX_INFO\n\t\t\t     *) (((char *) &pSMBr->hdr.Protocol) +\n\t\t\t\t data_offset);\n\t\t\tmemcpy(&tcon->fsUnixInfo, response_data,\n\t\t\t       sizeof(FILE_SYSTEM_UNIX_INFO));\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QFSUnixRetry;\n\n\n\treturn rc;\n}\n\nint\nCIFSSMBSetFSUnixInfo(const int xid, struct cifs_tcon *tcon, __u64 cap)\n{\n/* level 0x200  SMB_SET_CIFS_UNIX_INFO */\n\tTRANSACTION2_SETFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_SETFSI_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, param_offset, offset, byte_count;\n\n\tcFYI(1, \"In SETFSUnixInfo\");\nSETFSUnixRetry:\n\t/* BB switch to small buf init to save memory */\n\trc = smb_init_no_reconnect(SMB_COM_TRANSACTION2, 15, tcon,\n\t\t\t\t\t(void **) &pSMB, (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 4;\t/* 2 bytes zero followed by info level. */\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_setfsi_req, FileNum)\n\t\t\t\t- 4;\n\toffset = param_offset + params;\n\n\tpSMB->MaxParameterCount = cpu_to_le16(4);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(100);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FS_INFORMATION);\n\tbyte_count = 1 /* pad */ + params + 12;\n\n\tpSMB->DataCount = cpu_to_le16(12);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\n\t/* Params. */\n\tpSMB->FileNum = 0;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_CIFS_UNIX_INFO);\n\n\t/* Data. */\n\tpSMB->ClientUnixMajor = cpu_to_le16(CIFS_UNIX_MAJOR_VERSION);\n\tpSMB->ClientUnixMinor = cpu_to_le16(CIFS_UNIX_MINOR_VERSION);\n\tpSMB->ClientUnixCap = cpu_to_le64(cap);\n\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcERROR(1, \"Send error in SETFSUnixInfo = %d\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\t\tif (rc)\n\t\t\trc = -EIO;\t/* bad smb */\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto SETFSUnixRetry;\n\n\treturn rc;\n}\n\n\n\nint\nCIFSSMBQFSPosixInfo(const int xid, struct cifs_tcon *tcon,\n\t\t   struct kstatfs *FSData)\n{\n/* level 0x201  SMB_QUERY_CIFS_POSIX_INFO */\n\tTRANSACTION2_QFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_QFSI_RSP *pSMBr = NULL;\n\tFILE_SYSTEM_POSIX_INFO *response_data;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count;\n\n\tcFYI(1, \"In QFSPosixInfo\");\nQFSPosixRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2;\t/* level */\n\tpSMB->TotalDataCount = 0;\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(100);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(struct\n\t\t\tsmb_com_transaction2_qfsi_req, InformationLevel) - 4);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_POSIX_FS_INFO);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcFYI(1, \"Send error in QFSUnixInfo = %d\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 13) {\n\t\t\trc = -EIO;\t/* bad smb */\n\t\t} else {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tresponse_data =\n\t\t\t    (FILE_SYSTEM_POSIX_INFO\n\t\t\t     *) (((char *) &pSMBr->hdr.Protocol) +\n\t\t\t\t data_offset);\n\t\t\tFSData->f_bsize =\n\t\t\t\t\tle32_to_cpu(response_data->BlockSize);\n\t\t\tFSData->f_blocks =\n\t\t\t\t\tle64_to_cpu(response_data->TotalBlocks);\n\t\t\tFSData->f_bfree =\n\t\t\t    le64_to_cpu(response_data->BlocksAvail);\n\t\t\tif (response_data->UserBlocksAvail == cpu_to_le64(-1)) {\n\t\t\t\tFSData->f_bavail = FSData->f_bfree;\n\t\t\t} else {\n\t\t\t\tFSData->f_bavail =\n\t\t\t\t    le64_to_cpu(response_data->UserBlocksAvail);\n\t\t\t}\n\t\t\tif (response_data->TotalFileNodes != cpu_to_le64(-1))\n\t\t\t\tFSData->f_files =\n\t\t\t\t     le64_to_cpu(response_data->TotalFileNodes);\n\t\t\tif (response_data->FreeFileNodes != cpu_to_le64(-1))\n\t\t\t\tFSData->f_ffree =\n\t\t\t\t      le64_to_cpu(response_data->FreeFileNodes);\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QFSPosixRetry;\n\n\treturn rc;\n}\n\n\n/* We can not use write of zero bytes trick to\n   set file size due to need for large file support.  Also note that\n   this SetPathInfo is preferred to SetFileInfo based method in next\n   routine which is only needed to work around a sharing violation bug\n   in Samba which this routine can run into */\n\nint\nCIFSSMBSetEOF(const int xid, struct cifs_tcon *tcon, const char *fileName,\n\t      __u64 size, bool SetAllocation,\n\t      const struct nls_table *nls_codepage, int remap)\n{\n\tstruct smb_com_transaction2_spi_req *pSMB = NULL;\n\tstruct smb_com_transaction2_spi_rsp *pSMBr = NULL;\n\tstruct file_end_of_file_info *parm_data;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count, data_count, param_offset, offset;\n\n\tcFYI(1, \"In SetEOF\");\nSetEOFRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUCS((__le16 *) pSMB->FileName, fileName,\n\t\t\t\t     PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(fileName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, fileName, name_len);\n\t}\n\tparams = 6 + name_len;\n\tdata_count = sizeof(struct file_end_of_file_info);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(4100);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\tif (SetAllocation) {\n\t\tif (tcon->ses->capabilities & CAP_INFOLEVEL_PASSTHRU)\n\t\t\tpSMB->InformationLevel =\n\t\t\t\tcpu_to_le16(SMB_SET_FILE_ALLOCATION_INFO2);\n\t\telse\n\t\t\tpSMB->InformationLevel =\n\t\t\t\tcpu_to_le16(SMB_SET_FILE_ALLOCATION_INFO);\n\t} else /* Set File Size */  {\n\t    if (tcon->ses->capabilities & CAP_INFOLEVEL_PASSTHRU)\n\t\t    pSMB->InformationLevel =\n\t\t\t\tcpu_to_le16(SMB_SET_FILE_END_OF_FILE_INFO2);\n\t    else\n\t\t    pSMB->InformationLevel =\n\t\t\t\tcpu_to_le16(SMB_SET_FILE_END_OF_FILE_INFO);\n\t}\n\n\tparm_data =\n\t    (struct file_end_of_file_info *) (((char *) &pSMB->hdr.Protocol) +\n\t\t\t\t       offset);\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + data_count;\n\tpSMB->DataCount = cpu_to_le16(data_count);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tparm_data->FileSize = cpu_to_le64(size);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcFYI(1, \"SetPathInfo (file size) returned %d\", rc);\n\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto SetEOFRetry;\n\n\treturn rc;\n}\n\nint\nCIFSSMBSetFileSize(const int xid, struct cifs_tcon *tcon, __u64 size,\n\t\t   __u16 fid, __u32 pid_of_opener, bool SetAllocation)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tstruct file_end_of_file_info *parm_data;\n\tint rc = 0;\n\t__u16 params, param_offset, offset, byte_count, count;\n\n\tcFYI(1, \"SetFileSize (via SetFileInfo) %lld\",\n\t\t\t(long long)size);\n\trc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid_of_opener);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid_of_opener >> 16));\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tcount = sizeof(struct file_end_of_file_info);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tparm_data =\n\t\t(struct file_end_of_file_info *) (((char *) &pSMB->hdr.Protocol)\n\t\t\t\t+ offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tparm_data->FileSize = cpu_to_le64(size);\n\tpSMB->Fid = fid;\n\tif (SetAllocation) {\n\t\tif (tcon->ses->capabilities & CAP_INFOLEVEL_PASSTHRU)\n\t\t\tpSMB->InformationLevel =\n\t\t\t\tcpu_to_le16(SMB_SET_FILE_ALLOCATION_INFO2);\n\t\telse\n\t\t\tpSMB->InformationLevel =\n\t\t\t\tcpu_to_le16(SMB_SET_FILE_ALLOCATION_INFO);\n\t} else /* Set File Size */  {\n\t    if (tcon->ses->capabilities & CAP_INFOLEVEL_PASSTHRU)\n\t\t    pSMB->InformationLevel =\n\t\t\t\tcpu_to_le16(SMB_SET_FILE_END_OF_FILE_INFO2);\n\t    else\n\t\t    pSMB->InformationLevel =\n\t\t\t\tcpu_to_le16(SMB_SET_FILE_END_OF_FILE_INFO);\n\t}\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceiveNoRsp(xid, tcon->ses, (struct smb_hdr *) pSMB, 0);\n\tif (rc) {\n\t\tcFYI(1, \"Send error in SetFileInfo (SetFileSize) = %d\", rc);\n\t}\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\n\treturn rc;\n}\n\n/* Some legacy servers such as NT4 require that the file times be set on\n   an open handle, rather than by pathname - this is awkward due to\n   potential access conflicts on the open, but it is unavoidable for these\n   old servers since the only other choice is to go from 100 nanosecond DCE\n   time and resort to the original setpathinfo level which takes the ancient\n   DOS time format with 2 second granularity */\nint\nCIFSSMBSetFileInfo(const int xid, struct cifs_tcon *tcon,\n\t\t    const FILE_BASIC_INFO *data, __u16 fid, __u32 pid_of_opener)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tchar *data_offset;\n\tint rc = 0;\n\t__u16 params, param_offset, offset, byte_count, count;\n\n\tcFYI(1, \"Set Times (via SetFileInfo)\");\n\trc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid_of_opener);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid_of_opener >> 16));\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tdata_offset = (char *) (&pSMB->hdr.Protocol) + offset;\n\n\tcount = sizeof(FILE_BASIC_INFO);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find max SMB PDU from sess */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->Fid = fid;\n\tif (tcon->ses->capabilities & CAP_INFOLEVEL_PASSTHRU)\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_BASIC_INFO2);\n\telse\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_BASIC_INFO);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\tmemcpy(data_offset, data, sizeof(FILE_BASIC_INFO));\n\trc = SendReceiveNoRsp(xid, tcon->ses, (struct smb_hdr *) pSMB, 0);\n\tif (rc)\n\t\tcFYI(1, \"Send error in Set Time (SetFileInfo) = %d\", rc);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\n\treturn rc;\n}\n\nint\nCIFSSMBSetFileDisposition(const int xid, struct cifs_tcon *tcon,\n\t\t\t  bool delete_file, __u16 fid, __u32 pid_of_opener)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tchar *data_offset;\n\tint rc = 0;\n\t__u16 params, param_offset, offset, byte_count, count;\n\n\tcFYI(1, \"Set File Disposition (via SetFileInfo)\");\n\trc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid_of_opener);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid_of_opener >> 16));\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tdata_offset = (char *) (&pSMB->hdr.Protocol) + offset;\n\n\tcount = 1;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find max SMB PDU from sess */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->Fid = fid;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_DISPOSITION_INFO);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\t*data_offset = delete_file ? 1 : 0;\n\trc = SendReceiveNoRsp(xid, tcon->ses, (struct smb_hdr *) pSMB, 0);\n\tif (rc)\n\t\tcFYI(1, \"Send error in SetFileDisposition = %d\", rc);\n\n\treturn rc;\n}\n\nint\nCIFSSMBSetPathInfo(const int xid, struct cifs_tcon *tcon,\n\t\t   const char *fileName, const FILE_BASIC_INFO *data,\n\t\t   const struct nls_table *nls_codepage, int remap)\n{\n\tTRANSACTION2_SPI_REQ *pSMB = NULL;\n\tTRANSACTION2_SPI_RSP *pSMBr = NULL;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tchar *data_offset;\n\t__u16 params, param_offset, offset, byte_count, count;\n\n\tcFYI(1, \"In SetTimes\");\n\nSetTimesRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUCS((__le16 *) pSMB->FileName, fileName,\n\t\t\t\t     PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(fileName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, fileName, name_len);\n\t}\n\n\tparams = 6 + name_len;\n\tcount = sizeof(FILE_BASIC_INFO);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\tdata_offset = (char *) (&pSMB->hdr.Protocol) + offset;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tif (tcon->ses->capabilities & CAP_INFOLEVEL_PASSTHRU)\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_BASIC_INFO2);\n\telse\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_BASIC_INFO);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tmemcpy(data_offset, data, sizeof(FILE_BASIC_INFO));\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcFYI(1, \"SetPathInfo (times) returned %d\", rc);\n\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto SetTimesRetry;\n\n\treturn rc;\n}\n\n/* Can not be used to set time stamps yet (due to old DOS time format) */\n/* Can be used to set attributes */\n#if 0  /* Possibly not needed - since it turns out that strangely NT4 has a bug\n\t  handling it anyway and NT4 was what we thought it would be needed for\n\t  Do not delete it until we prove whether needed for Win9x though */\nint\nCIFSSMBSetAttrLegacy(int xid, struct cifs_tcon *tcon, char *fileName,\n\t\t__u16 dos_attrs, const struct nls_table *nls_codepage)\n{\n\tSETATTR_REQ *pSMB = NULL;\n\tSETATTR_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\n\tcFYI(1, \"In SetAttrLegacy\");\n\nSetAttrLgcyRetry:\n\trc = smb_init(SMB_COM_SETATTR, 8, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t\tConvertToUCS((__le16 *) pSMB->fileName, fileName,\n\t\t\t\tPATH_MAX, nls_codepage);\n\t\tname_len++;     /* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(fileName, PATH_MAX);\n\t\tname_len++;     /* trailing null */\n\t\tstrncpy(pSMB->fileName, fileName, name_len);\n\t}\n\tpSMB->attr = cpu_to_le16(dos_attrs);\n\tpSMB->BufferFormat = 0x04;\n\tinc_rfc1001_len(pSMB, name_len + 1);\n\tpSMB->ByteCount = cpu_to_le16(name_len + 1);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcFYI(1, \"Error in LegacySetAttr = %d\", rc);\n\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto SetAttrLgcyRetry;\n\n\treturn rc;\n}\n#endif /* temporarily unneeded SetAttr legacy function */\n\nstatic void\ncifs_fill_unix_set_info(FILE_UNIX_BASIC_INFO *data_offset,\n\t\t\tconst struct cifs_unix_set_info_args *args)\n{\n\tu64 mode = args->mode;\n\n\t/*\n\t * Samba server ignores set of file size to zero due to bugs in some\n\t * older clients, but we should be precise - we use SetFileSize to\n\t * set file size and do not want to truncate file size to zero\n\t * accidentally as happened on one Samba server beta by putting\n\t * zero instead of -1 here\n\t */\n\tdata_offset->EndOfFile = cpu_to_le64(NO_CHANGE_64);\n\tdata_offset->NumOfBytes = cpu_to_le64(NO_CHANGE_64);\n\tdata_offset->LastStatusChange = cpu_to_le64(args->ctime);\n\tdata_offset->LastAccessTime = cpu_to_le64(args->atime);\n\tdata_offset->LastModificationTime = cpu_to_le64(args->mtime);\n\tdata_offset->Uid = cpu_to_le64(args->uid);\n\tdata_offset->Gid = cpu_to_le64(args->gid);\n\t/* better to leave device as zero when it is  */\n\tdata_offset->DevMajor = cpu_to_le64(MAJOR(args->device));\n\tdata_offset->DevMinor = cpu_to_le64(MINOR(args->device));\n\tdata_offset->Permissions = cpu_to_le64(mode);\n\n\tif (S_ISREG(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_FILE);\n\telse if (S_ISDIR(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_DIR);\n\telse if (S_ISLNK(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_SYMLINK);\n\telse if (S_ISCHR(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_CHARDEV);\n\telse if (S_ISBLK(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_BLOCKDEV);\n\telse if (S_ISFIFO(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_FIFO);\n\telse if (S_ISSOCK(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_SOCKET);\n}\n\nint\nCIFSSMBUnixSetFileInfo(const int xid, struct cifs_tcon *tcon,\n\t\t       const struct cifs_unix_set_info_args *args,\n\t\t       u16 fid, u32 pid_of_opener)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tFILE_UNIX_BASIC_INFO *data_offset;\n\tint rc = 0;\n\tu16 params, param_offset, offset, byte_count, count;\n\n\tcFYI(1, \"Set Unix Info (via SetFileInfo)\");\n\trc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid_of_opener);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid_of_opener >> 16));\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tdata_offset = (FILE_UNIX_BASIC_INFO *)\n\t\t\t\t((char *)(&pSMB->hdr.Protocol) + offset);\n\tcount = sizeof(FILE_UNIX_BASIC_INFO);\n\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find max SMB PDU from sess */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->Fid = fid;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_UNIX_BASIC);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\tcifs_fill_unix_set_info(data_offset, args);\n\n\trc = SendReceiveNoRsp(xid, tcon->ses, (struct smb_hdr *) pSMB, 0);\n\tif (rc)\n\t\tcFYI(1, \"Send error in Set Time (SetFileInfo) = %d\", rc);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\n\treturn rc;\n}\n\nint\nCIFSSMBUnixSetPathInfo(const int xid, struct cifs_tcon *tcon, char *fileName,\n\t\t       const struct cifs_unix_set_info_args *args,\n\t\t       const struct nls_table *nls_codepage, int remap)\n{\n\tTRANSACTION2_SPI_REQ *pSMB = NULL;\n\tTRANSACTION2_SPI_RSP *pSMBr = NULL;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tFILE_UNIX_BASIC_INFO *data_offset;\n\t__u16 params, param_offset, offset, count, byte_count;\n\n\tcFYI(1, \"In SetUID/GID/Mode\");\nsetPermsRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUCS((__le16 *) pSMB->FileName, fileName,\n\t\t\t\t     PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(fileName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, fileName, name_len);\n\t}\n\n\tparams = 6 + name_len;\n\tcount = sizeof(FILE_UNIX_BASIC_INFO);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\tdata_offset =\n\t    (FILE_UNIX_BASIC_INFO *) ((char *) &pSMB->hdr.Protocol +\n\t\t\t\t      offset);\n\tmemset(data_offset, 0, count);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_UNIX_BASIC);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\n\tcifs_fill_unix_set_info(data_offset, args);\n\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcFYI(1, \"SetPathInfo (perms) returned %d\", rc);\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto setPermsRetry;\n\treturn rc;\n}\n\n#ifdef CONFIG_CIFS_XATTR\n/*\n * Do a path-based QUERY_ALL_EAS call and parse the result. This is a common\n * function used by listxattr and getxattr type calls. When ea_name is set,\n * it looks for that attribute name and stuffs that value into the EAData\n * buffer. When ea_name is NULL, it stuffs a list of attribute names into the\n * buffer. In both cases, the return value is either the length of the\n * resulting data or a negative error code. If EAData is a NULL pointer then\n * the data isn't copied to it, but the length is returned.\n */\nssize_t\nCIFSSMBQAllEAs(const int xid, struct cifs_tcon *tcon,\n\t\tconst unsigned char *searchName, const unsigned char *ea_name,\n\t\tchar *EAData, size_t buf_size,\n\t\tconst struct nls_table *nls_codepage, int remap)\n{\n\t\t/* BB assumes one setup word */\n\tTRANSACTION2_QPI_REQ *pSMB = NULL;\n\tTRANSACTION2_QPI_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\tint list_len;\n\tstruct fealist *ea_response_data;\n\tstruct fea *temp_fea;\n\tchar *temp_ptr;\n\tchar *end_of_smb;\n\t__u16 params, byte_count, data_offset;\n\tunsigned int ea_name_len = ea_name ? strlen(ea_name) : 0;\n\n\tcFYI(1, \"In Query All EAs path %s\", searchName);\nQAllEAsRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tlist_len =\n\t\t    cifsConvertToUCS((__le16 *) pSMB->FileName, searchName,\n\t\t\t\t     PATH_MAX, nls_codepage, remap);\n\t\tlist_len++;\t/* trailing null */\n\t\tlist_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tlist_len = strnlen(searchName, PATH_MAX);\n\t\tlist_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, searchName, list_len);\n\t}\n\n\tparams = 2 /* level */ + 4 /* reserved */ + list_len /* includes NUL */;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(CIFSMaxBufSize);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\tstruct smb_com_transaction2_qpi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_PATH_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_INFO_QUERY_ALL_EAS);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcFYI(1, \"Send error in QueryAllEAs = %d\", rc);\n\t\tgoto QAllEAsOut;\n\t}\n\n\n\t/* BB also check enough total bytes returned */\n\t/* BB we need to improve the validity checking\n\tof these trans2 responses */\n\n\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\tif (rc || get_bcc(&pSMBr->hdr) < 4) {\n\t\trc = -EIO;\t/* bad smb */\n\t\tgoto QAllEAsOut;\n\t}\n\n\t/* check that length of list is not more than bcc */\n\t/* check that each entry does not go beyond length\n\t   of list */\n\t/* check that each element of each entry does not\n\t   go beyond end of list */\n\t/* validate_trans2_offsets() */\n\t/* BB check if start of smb + data_offset > &bcc+ bcc */\n\n\tdata_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\tea_response_data = (struct fealist *)\n\t\t\t\t(((char *) &pSMBr->hdr.Protocol) + data_offset);\n\n\tlist_len = le32_to_cpu(ea_response_data->list_len);\n\tcFYI(1, \"ea length %d\", list_len);\n\tif (list_len <= 8) {\n\t\tcFYI(1, \"empty EA list returned from server\");\n\t\tgoto QAllEAsOut;\n\t}\n\n\t/* make sure list_len doesn't go past end of SMB */\n\tend_of_smb = (char *)pByteArea(&pSMBr->hdr) + get_bcc(&pSMBr->hdr);\n\tif ((char *)ea_response_data + list_len > end_of_smb) {\n\t\tcFYI(1, \"EA list appears to go beyond SMB\");\n\t\trc = -EIO;\n\t\tgoto QAllEAsOut;\n\t}\n\n\t/* account for ea list len */\n\tlist_len -= 4;\n\ttemp_fea = ea_response_data->list;\n\ttemp_ptr = (char *)temp_fea;\n\twhile (list_len > 0) {\n\t\tunsigned int name_len;\n\t\t__u16 value_len;\n\n\t\tlist_len -= 4;\n\t\ttemp_ptr += 4;\n\t\t/* make sure we can read name_len and value_len */\n\t\tif (list_len < 0) {\n\t\t\tcFYI(1, \"EA entry goes beyond length of list\");\n\t\t\trc = -EIO;\n\t\t\tgoto QAllEAsOut;\n\t\t}\n\n\t\tname_len = temp_fea->name_len;\n\t\tvalue_len = le16_to_cpu(temp_fea->value_len);\n\t\tlist_len -= name_len + 1 + value_len;\n\t\tif (list_len < 0) {\n\t\t\tcFYI(1, \"EA entry goes beyond length of list\");\n\t\t\trc = -EIO;\n\t\t\tgoto QAllEAsOut;\n\t\t}\n\n\t\tif (ea_name) {\n\t\t\tif (ea_name_len == name_len &&\n\t\t\t    strncmp(ea_name, temp_ptr, name_len) == 0) {\n\t\t\t\ttemp_ptr += name_len + 1;\n\t\t\t\trc = value_len;\n\t\t\t\tif (buf_size == 0)\n\t\t\t\t\tgoto QAllEAsOut;\n\t\t\t\tif ((size_t)value_len > buf_size) {\n\t\t\t\t\trc = -ERANGE;\n\t\t\t\t\tgoto QAllEAsOut;\n\t\t\t\t}\n\t\t\t\tmemcpy(EAData, temp_ptr, value_len);\n\t\t\t\tgoto QAllEAsOut;\n\t\t\t}\n\t\t} else {\n\t\t\t/* account for prefix user. and trailing null */\n\t\t\trc += (5 + 1 + name_len);\n\t\t\tif (rc < (int) buf_size) {\n\t\t\t\tmemcpy(EAData, \"user.\", 5);\n\t\t\t\tEAData += 5;\n\t\t\t\tmemcpy(EAData, temp_ptr, name_len);\n\t\t\t\tEAData += name_len;\n\t\t\t\t/* null terminate name */\n\t\t\t\t*EAData = 0;\n\t\t\t\t++EAData;\n\t\t\t} else if (buf_size == 0) {\n\t\t\t\t/* skip copy - calc size only */\n\t\t\t} else {\n\t\t\t\t/* stop before overrun buffer */\n\t\t\t\trc = -ERANGE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ttemp_ptr += name_len + 1 + value_len;\n\t\ttemp_fea = (struct fea *)temp_ptr;\n\t}\n\n\t/* didn't find the named attribute */\n\tif (ea_name)\n\t\trc = -ENODATA;\n\nQAllEAsOut:\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto QAllEAsRetry;\n\n\treturn (ssize_t)rc;\n}\n\nint\nCIFSSMBSetEA(const int xid, struct cifs_tcon *tcon, const char *fileName,\n\t     const char *ea_name, const void *ea_value,\n\t     const __u16 ea_value_len, const struct nls_table *nls_codepage,\n\t     int remap)\n{\n\tstruct smb_com_transaction2_spi_req *pSMB = NULL;\n\tstruct smb_com_transaction2_spi_rsp *pSMBr = NULL;\n\tstruct fealist *parm_data;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, param_offset, byte_count, offset, count;\n\n\tcFYI(1, \"In SetEA\");\nSetEARetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUCS((__le16 *) pSMB->FileName, fileName,\n\t\t\t\t     PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(fileName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, fileName, name_len);\n\t}\n\n\tparams = 6 + name_len;\n\n\t/* done calculating parms using name_len of file name,\n\tnow use name_len to calculate length of ea name\n\twe are going to create in the inode xattrs */\n\tif (ea_name == NULL)\n\t\tname_len = 0;\n\telse\n\t\tname_len = strnlen(ea_name, 255);\n\n\tcount = sizeof(*parm_data) + ea_value_len + name_len;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find max SMB PDU from sess */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\tpSMB->InformationLevel =\n\t\tcpu_to_le16(SMB_SET_FILE_EA);\n\n\tparm_data =\n\t\t(struct fealist *) (((char *) &pSMB->hdr.Protocol) +\n\t\t\t\t       offset);\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tparm_data->list_len = cpu_to_le32(count);\n\tparm_data->list[0].EA_flags = 0;\n\t/* we checked above that name len is less than 255 */\n\tparm_data->list[0].name_len = (__u8)name_len;\n\t/* EA names are always ASCII */\n\tif (ea_name)\n\t\tstrncpy(parm_data->list[0].name, ea_name, name_len);\n\tparm_data->list[0].name[name_len] = 0;\n\tparm_data->list[0].value_len = cpu_to_le16(ea_value_len);\n\t/* caller ensures that ea_value_len is less than 64K but\n\twe need to ensure that it fits within the smb */\n\n\t/*BB add length check to see if it would fit in\n\t     negotiated SMB buffer size BB */\n\t/* if (ea_value_len > buffer_size - 512 (enough for header)) */\n\tif (ea_value_len)\n\t\tmemcpy(parm_data->list[0].name+name_len+1,\n\t\t       ea_value, ea_value_len);\n\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcFYI(1, \"SetPathInfo (EA) returned %d\", rc);\n\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto SetEARetry;\n\n\treturn rc;\n}\n#endif\n\n#ifdef CONFIG_CIFS_DNOTIFY_EXPERIMENTAL /* BB unused temporarily */\n/*\n *\tYears ago the kernel added a \"dnotify\" function for Samba server,\n *\tto allow network clients (such as Windows) to display updated\n *\tlists of files in directory listings automatically when\n *\tfiles are added by one user when another user has the\n *\tsame directory open on their desktop.  The Linux cifs kernel\n *\tclient hooked into the kernel side of this interface for\n *\tthe same reason, but ironically when the VFS moved from\n *\t\"dnotify\" to \"inotify\" it became harder to plug in Linux\n *\tnetwork file system clients (the most obvious use case\n *\tfor notify interfaces is when multiple users can update\n *\tthe contents of the same directory - exactly what network\n *\tfile systems can do) although the server (Samba) could\n *\tstill use it.  For the short term we leave the worker\n *\tfunction ifdeffed out (below) until inotify is fixed\n *\tin the VFS to make it easier to plug in network file\n *\tsystem clients.  If inotify turns out to be permanently\n *\tincompatible for network fs clients, we could instead simply\n *\texpose this config flag by adding a future cifs (and smb2) notify ioctl.\n */\nint CIFSSMBNotify(const int xid, struct cifs_tcon *tcon,\n\t\t  const int notify_subdirs, const __u16 netfid,\n\t\t  __u32 filter, struct file *pfile, int multishot,\n\t\t  const struct nls_table *nls_codepage)\n{\n\tint rc = 0;\n\tstruct smb_com_transaction_change_notify_req *pSMB = NULL;\n\tstruct smb_com_ntransaction_change_notify_rsp *pSMBr = NULL;\n\tstruct dir_notify_req *dnotify_req;\n\tint bytes_returned;\n\n\tcFYI(1, \"In CIFSSMBNotify for file handle %d\", (int)netfid);\n\trc = smb_init(SMB_COM_NT_TRANSACT, 23, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->TotalParameterCount = 0 ;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le32(2);\n\t/* BB find exact data count max from sess structure BB */\n\tpSMB->MaxDataCount = 0; /* same in little endian or be */\n/* BB VERIFY verify which is correct for above BB */\n\tpSMB->MaxDataCount = cpu_to_le32((tcon->ses->server->maxBuf -\n\t\t\t\t\t     MAX_CIFS_HDR_SIZE) & 0xFFFFFF00);\n\n\tpSMB->MaxSetupCount = 4;\n\tpSMB->Reserved = 0;\n\tpSMB->ParameterOffset = 0;\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 4; /* single byte does not need le conversion */\n\tpSMB->SubCommand = cpu_to_le16(NT_TRANSACT_NOTIFY_CHANGE);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tif (notify_subdirs)\n\t\tpSMB->WatchTree = 1; /* one byte - no le conversion needed */\n\tpSMB->Reserved2 = 0;\n\tpSMB->CompletionFilter = cpu_to_le32(filter);\n\tpSMB->Fid = netfid; /* file handle always le */\n\tpSMB->ByteCount = 0;\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *)pSMBr, &bytes_returned,\n\t\t\t CIFS_ASYNC_OP);\n\tif (rc) {\n\t\tcFYI(1, \"Error in Notify = %d\", rc);\n\t} else {\n\t\t/* Add file to outstanding requests */\n\t\t/* BB change to kmem cache alloc */\n\t\tdnotify_req = kmalloc(\n\t\t\t\t\t\tsizeof(struct dir_notify_req),\n\t\t\t\t\t\t GFP_KERNEL);\n\t\tif (dnotify_req) {\n\t\t\tdnotify_req->Pid = pSMB->hdr.Pid;\n\t\t\tdnotify_req->PidHigh = pSMB->hdr.PidHigh;\n\t\t\tdnotify_req->Mid = pSMB->hdr.Mid;\n\t\t\tdnotify_req->Tid = pSMB->hdr.Tid;\n\t\t\tdnotify_req->Uid = pSMB->hdr.Uid;\n\t\t\tdnotify_req->netfid = netfid;\n\t\t\tdnotify_req->pfile = pfile;\n\t\t\tdnotify_req->filter = filter;\n\t\t\tdnotify_req->multishot = multishot;\n\t\t\tspin_lock(&GlobalMid_Lock);\n\t\t\tlist_add_tail(&dnotify_req->lhead,\n\t\t\t\t\t&GlobalDnotifyReqList);\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t} else\n\t\t\trc = -ENOMEM;\n\t}\n\tcifs_buf_release(pSMB);\n\treturn rc;\n}\n#endif /* was needed for dnotify, and will be needed for inotify when VFS fix */\n"], "fixing_code": ["/*\n *   fs/cifs/cifssmb.c\n *\n *   Copyright (C) International Business Machines  Corp., 2002,2010\n *   Author(s): Steve French (sfrench@us.ibm.com)\n *\n *   Contains the routines for constructing the SMB PDUs themselves\n *\n *   This library is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published\n *   by the Free Software Foundation; either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This library is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See\n *   the GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this library; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n */\n\n /* SMB/CIFS PDU handling routines here - except for leftovers in connect.c   */\n /* These are mostly routines that operate on a pathname, or on a tree id     */\n /* (mounted volume), but there are eight handle based routines which must be */\n /* treated slightly differently for reconnection purposes since we never     */\n /* want to reuse a stale file handle and only the caller knows the file info */\n\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/pagemap.h>\n#include <asm/uaccess.h>\n#include \"cifspdu.h\"\n#include \"cifsglob.h\"\n#include \"cifsacl.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n\n#ifdef CONFIG_CIFS_POSIX\nstatic struct {\n\tint index;\n\tchar *name;\n} protocols[] = {\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\n\t{LANMAN_PROT, \"\\2LM1.2X002\"},\n\t{LANMAN2_PROT, \"\\2LANMAN2.1\"},\n#endif /* weak password hashing for legacy clients */\n\t{CIFS_PROT, \"\\2NT LM 0.12\"},\n\t{POSIX_PROT, \"\\2POSIX 2\"},\n\t{BAD_PROT, \"\\2\"}\n};\n#else\nstatic struct {\n\tint index;\n\tchar *name;\n} protocols[] = {\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\n\t{LANMAN_PROT, \"\\2LM1.2X002\"},\n\t{LANMAN2_PROT, \"\\2LANMAN2.1\"},\n#endif /* weak password hashing for legacy clients */\n\t{CIFS_PROT, \"\\2NT LM 0.12\"},\n\t{BAD_PROT, \"\\2\"}\n};\n#endif\n\n/* define the number of elements in the cifs dialect array */\n#ifdef CONFIG_CIFS_POSIX\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\n#define CIFS_NUM_PROT 4\n#else\n#define CIFS_NUM_PROT 2\n#endif /* CIFS_WEAK_PW_HASH */\n#else /* not posix */\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\n#define CIFS_NUM_PROT 3\n#else\n#define CIFS_NUM_PROT 1\n#endif /* CONFIG_CIFS_WEAK_PW_HASH */\n#endif /* CIFS_POSIX */\n\n/* Mark as invalid, all open files on tree connections since they\n   were closed when session to server was lost */\nstatic void mark_open_files_invalid(struct cifs_tcon *pTcon)\n{\n\tstruct cifsFileInfo *open_file = NULL;\n\tstruct list_head *tmp;\n\tstruct list_head *tmp1;\n\n/* list all files open on tree connection and mark them invalid */\n\tspin_lock(&cifs_file_list_lock);\n\tlist_for_each_safe(tmp, tmp1, &pTcon->openFileList) {\n\t\topen_file = list_entry(tmp, struct cifsFileInfo, tlist);\n\t\topen_file->invalidHandle = true;\n\t\topen_file->oplock_break_cancelled = true;\n\t}\n\tspin_unlock(&cifs_file_list_lock);\n\t/* BB Add call to invalidate_inodes(sb) for all superblocks mounted\n\t   to this tcon */\n}\n\n/* reconnect the socket, tcon, and smb session if needed */\nstatic int\ncifs_reconnect_tcon(struct cifs_tcon *tcon, int smb_command)\n{\n\tint rc;\n\tstruct cifs_ses *ses;\n\tstruct TCP_Server_Info *server;\n\tstruct nls_table *nls_codepage;\n\n\t/*\n\t * SMBs NegProt, SessSetup, uLogoff do not have tcon yet so check for\n\t * tcp and smb session status done differently for those three - in the\n\t * calling routine\n\t */\n\tif (!tcon)\n\t\treturn 0;\n\n\tses = tcon->ses;\n\tserver = ses->server;\n\n\t/*\n\t * only tree disconnect, open, and write, (and ulogoff which does not\n\t * have tcon) are allowed as we start force umount\n\t */\n\tif (tcon->tidStatus == CifsExiting) {\n\t\tif (smb_command != SMB_COM_WRITE_ANDX &&\n\t\t    smb_command != SMB_COM_OPEN_ANDX &&\n\t\t    smb_command != SMB_COM_TREE_DISCONNECT) {\n\t\t\tcFYI(1, \"can not send cmd %d while umounting\",\n\t\t\t\tsmb_command);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\t/*\n\t * Give demultiplex thread up to 10 seconds to reconnect, should be\n\t * greater than cifs socket timeout which is 7 seconds\n\t */\n\twhile (server->tcpStatus == CifsNeedReconnect) {\n\t\twait_event_interruptible_timeout(server->response_q,\n\t\t\t(server->tcpStatus != CifsNeedReconnect), 10 * HZ);\n\n\t\t/* are we still trying to reconnect? */\n\t\tif (server->tcpStatus != CifsNeedReconnect)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * on \"soft\" mounts we wait once. Hard mounts keep\n\t\t * retrying until process is killed or server comes\n\t\t * back on-line\n\t\t */\n\t\tif (!tcon->retry) {\n\t\t\tcFYI(1, \"gave up waiting on reconnect in smb_init\");\n\t\t\treturn -EHOSTDOWN;\n\t\t}\n\t}\n\n\tif (!ses->need_reconnect && !tcon->need_reconnect)\n\t\treturn 0;\n\n\tnls_codepage = load_nls_default();\n\n\t/*\n\t * need to prevent multiple threads trying to simultaneously\n\t * reconnect the same SMB session\n\t */\n\tmutex_lock(&ses->session_mutex);\n\trc = cifs_negotiate_protocol(0, ses);\n\tif (rc == 0 && ses->need_reconnect)\n\t\trc = cifs_setup_session(0, ses, nls_codepage);\n\n\t/* do we need to reconnect tcon? */\n\tif (rc || !tcon->need_reconnect) {\n\t\tmutex_unlock(&ses->session_mutex);\n\t\tgoto out;\n\t}\n\n\tmark_open_files_invalid(tcon);\n\trc = CIFSTCon(0, ses, tcon->treeName, tcon, nls_codepage);\n\tmutex_unlock(&ses->session_mutex);\n\tcFYI(1, \"reconnect tcon rc = %d\", rc);\n\n\tif (rc)\n\t\tgoto out;\n\n\t/*\n\t * FIXME: check if wsize needs updated due to negotiated smb buffer\n\t * \t  size shrinking\n\t */\n\tatomic_inc(&tconInfoReconnectCount);\n\n\t/* tell server Unix caps we support */\n\tif (ses->capabilities & CAP_UNIX)\n\t\treset_cifs_unix_caps(0, tcon, NULL, NULL);\n\n\t/*\n\t * Removed call to reopen open files here. It is safer (and faster) to\n\t * reopen files one at a time as needed in read and write.\n\t *\n\t * FIXME: what about file locks? don't we need to reclaim them ASAP?\n\t */\n\nout:\n\t/*\n\t * Check if handle based operation so we know whether we can continue\n\t * or not without returning to caller to reset file handle\n\t */\n\tswitch (smb_command) {\n\tcase SMB_COM_READ_ANDX:\n\tcase SMB_COM_WRITE_ANDX:\n\tcase SMB_COM_CLOSE:\n\tcase SMB_COM_FIND_CLOSE2:\n\tcase SMB_COM_LOCKING_ANDX:\n\t\trc = -EAGAIN;\n\t}\n\n\tunload_nls(nls_codepage);\n\treturn rc;\n}\n\n/* Allocate and return pointer to an SMB request buffer, and set basic\n   SMB information in the SMB header.  If the return code is zero, this\n   function must have filled in request_buf pointer */\nstatic int\nsmall_smb_init(int smb_command, int wct, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc;\n\n\trc = cifs_reconnect_tcon(tcon, smb_command);\n\tif (rc)\n\t\treturn rc;\n\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\theader_assemble((struct smb_hdr *) *request_buf, smb_command,\n\t\t\ttcon, wct);\n\n\tif (tcon != NULL)\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\n\treturn 0;\n}\n\nint\nsmall_smb_init_no_tc(const int smb_command, const int wct,\n\t\t     struct cifs_ses *ses, void **request_buf)\n{\n\tint rc;\n\tstruct smb_hdr *buffer;\n\n\trc = small_smb_init(smb_command, wct, NULL, request_buf);\n\tif (rc)\n\t\treturn rc;\n\n\tbuffer = (struct smb_hdr *)*request_buf;\n\tbuffer->Mid = GetNextMid(ses->server);\n\tif (ses->capabilities & CAP_UNICODE)\n\t\tbuffer->Flags2 |= SMBFLG2_UNICODE;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\n\t/* uid, tid can stay at zero as set in header assemble */\n\n\t/* BB add support for turning on the signing when\n\tthis function is used after 1st of session setup requests */\n\n\treturn rc;\n}\n\n/* If the return code is zero, this function must fill in request_buf pointer */\nstatic int\n__smb_init(int smb_command, int wct, struct cifs_tcon *tcon,\n\t\t\tvoid **request_buf, void **response_buf)\n{\n\t*request_buf = cifs_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n    /* Although the original thought was we needed the response buf for  */\n    /* potential retries of smb operations it turns out we can determine */\n    /* from the mid flags when the request buffer can be resent without  */\n    /* having to use a second distinct buffer for the response */\n\tif (response_buf)\n\t\t*response_buf = *request_buf;\n\n\theader_assemble((struct smb_hdr *) *request_buf, smb_command, tcon,\n\t\t\twct);\n\n\tif (tcon != NULL)\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\n\treturn 0;\n}\n\n/* If the return code is zero, this function must fill in request_buf pointer */\nstatic int\nsmb_init(int smb_command, int wct, struct cifs_tcon *tcon,\n\t void **request_buf, void **response_buf)\n{\n\tint rc;\n\n\trc = cifs_reconnect_tcon(tcon, smb_command);\n\tif (rc)\n\t\treturn rc;\n\n\treturn __smb_init(smb_command, wct, tcon, request_buf, response_buf);\n}\n\nstatic int\nsmb_init_no_reconnect(int smb_command, int wct, struct cifs_tcon *tcon,\n\t\t\tvoid **request_buf, void **response_buf)\n{\n\tif (tcon->ses->need_reconnect || tcon->need_reconnect)\n\t\treturn -EHOSTDOWN;\n\n\treturn __smb_init(smb_command, wct, tcon, request_buf, response_buf);\n}\n\nstatic int validate_t2(struct smb_t2_rsp *pSMB)\n{\n\tunsigned int total_size;\n\n\t/* check for plausible wct */\n\tif (pSMB->hdr.WordCount < 10)\n\t\tgoto vt2_err;\n\n\t/* check for parm and data offset going beyond end of smb */\n\tif (get_unaligned_le16(&pSMB->t2_rsp.ParameterOffset) > 1024 ||\n\t    get_unaligned_le16(&pSMB->t2_rsp.DataOffset) > 1024)\n\t\tgoto vt2_err;\n\n\ttotal_size = get_unaligned_le16(&pSMB->t2_rsp.ParameterCount);\n\tif (total_size >= 512)\n\t\tgoto vt2_err;\n\n\t/* check that bcc is at least as big as parms + data, and that it is\n\t * less than negotiated smb buffer\n\t */\n\ttotal_size += get_unaligned_le16(&pSMB->t2_rsp.DataCount);\n\tif (total_size > get_bcc(&pSMB->hdr) ||\n\t    total_size >= CIFSMaxBufSize + MAX_CIFS_HDR_SIZE)\n\t\tgoto vt2_err;\n\n\treturn 0;\nvt2_err:\n\tcifs_dump_mem(\"Invalid transact2 SMB: \", (char *)pSMB,\n\t\tsizeof(struct smb_t2_rsp) + 16);\n\treturn -EINVAL;\n}\n\nstatic inline void inc_rfc1001_len(void *pSMB, int count)\n{\n\tstruct smb_hdr *hdr = (struct smb_hdr *)pSMB;\n\n\tbe32_add_cpu(&hdr->smb_buf_length, count);\n}\n\nint\nCIFSSMBNegotiate(unsigned int xid, struct cifs_ses *ses)\n{\n\tNEGOTIATE_REQ *pSMB;\n\tNEGOTIATE_RSP *pSMBr;\n\tint rc = 0;\n\tint bytes_returned;\n\tint i;\n\tstruct TCP_Server_Info *server;\n\tu16 count;\n\tunsigned int secFlags;\n\n\tif (ses->server)\n\t\tserver = ses->server;\n\telse {\n\t\trc = -EIO;\n\t\treturn rc;\n\t}\n\trc = smb_init(SMB_COM_NEGOTIATE, 0, NULL /* no tcon yet */ ,\n\t\t      (void **) &pSMB, (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\t/* if any of auth flags (ie not sign or seal) are overriden use them */\n\tif (ses->overrideSecFlg & (~(CIFSSEC_MUST_SIGN | CIFSSEC_MUST_SEAL)))\n\t\tsecFlags = ses->overrideSecFlg;  /* BB FIXME fix sign flags? */\n\telse /* if override flags set only sign/seal OR them with global auth */\n\t\tsecFlags = global_secflags | ses->overrideSecFlg;\n\n\tcFYI(1, \"secFlags 0x%x\", secFlags);\n\n\tpSMB->hdr.Mid = GetNextMid(server);\n\tpSMB->hdr.Flags2 |= (SMBFLG2_UNICODE | SMBFLG2_ERR_STATUS);\n\n\tif ((secFlags & CIFSSEC_MUST_KRB5) == CIFSSEC_MUST_KRB5)\n\t\tpSMB->hdr.Flags2 |= SMBFLG2_EXT_SEC;\n\telse if ((secFlags & CIFSSEC_AUTH_MASK) == CIFSSEC_MAY_KRB5) {\n\t\tcFYI(1, \"Kerberos only mechanism, enable extended security\");\n\t\tpSMB->hdr.Flags2 |= SMBFLG2_EXT_SEC;\n\t} else if ((secFlags & CIFSSEC_MUST_NTLMSSP) == CIFSSEC_MUST_NTLMSSP)\n\t\tpSMB->hdr.Flags2 |= SMBFLG2_EXT_SEC;\n\telse if ((secFlags & CIFSSEC_AUTH_MASK) == CIFSSEC_MAY_NTLMSSP) {\n\t\tcFYI(1, \"NTLMSSP only mechanism, enable extended security\");\n\t\tpSMB->hdr.Flags2 |= SMBFLG2_EXT_SEC;\n\t}\n\n\tcount = 0;\n\tfor (i = 0; i < CIFS_NUM_PROT; i++) {\n\t\tstrncpy(pSMB->DialectsArray+count, protocols[i].name, 16);\n\t\tcount += strlen(protocols[i].name) + 1;\n\t\t/* null at end of source and target buffers anyway */\n\t}\n\tinc_rfc1001_len(pSMB, count);\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\trc = SendReceive(xid, ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc != 0)\n\t\tgoto neg_err_exit;\n\n\tserver->dialect = le16_to_cpu(pSMBr->DialectIndex);\n\tcFYI(1, \"Dialect: %d\", server->dialect);\n\t/* Check wct = 1 error case */\n\tif ((pSMBr->hdr.WordCount < 13) || (server->dialect == BAD_PROT)) {\n\t\t/* core returns wct = 1, but we do not ask for core - otherwise\n\t\tsmall wct just comes when dialect index is -1 indicating we\n\t\tcould not negotiate a common dialect */\n\t\trc = -EOPNOTSUPP;\n\t\tgoto neg_err_exit;\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\n\t} else if ((pSMBr->hdr.WordCount == 13)\n\t\t\t&& ((server->dialect == LANMAN_PROT)\n\t\t\t\t|| (server->dialect == LANMAN2_PROT))) {\n\t\t__s16 tmp;\n\t\tstruct lanman_neg_rsp *rsp = (struct lanman_neg_rsp *)pSMBr;\n\n\t\tif ((secFlags & CIFSSEC_MAY_LANMAN) ||\n\t\t\t(secFlags & CIFSSEC_MAY_PLNTXT))\n\t\t\tserver->secType = LANMAN;\n\t\telse {\n\t\t\tcERROR(1, \"mount failed weak security disabled\"\n\t\t\t\t   \" in /proc/fs/cifs/SecurityFlags\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto neg_err_exit;\n\t\t}\n\t\tserver->sec_mode = (__u8)le16_to_cpu(rsp->SecurityMode);\n\t\tserver->maxReq = le16_to_cpu(rsp->MaxMpxCount);\n\t\tserver->maxBuf = min((__u32)le16_to_cpu(rsp->MaxBufSize),\n\t\t\t\t(__u32)CIFSMaxBufSize + MAX_CIFS_HDR_SIZE);\n\t\tserver->max_vcs = le16_to_cpu(rsp->MaxNumberVcs);\n\t\t/* even though we do not use raw we might as well set this\n\t\taccurately, in case we ever find a need for it */\n\t\tif ((le16_to_cpu(rsp->RawMode) & RAW_ENABLE) == RAW_ENABLE) {\n\t\t\tserver->max_rw = 0xFF00;\n\t\t\tserver->capabilities = CAP_MPX_MODE | CAP_RAW_MODE;\n\t\t} else {\n\t\t\tserver->max_rw = 0;/* do not need to use raw anyway */\n\t\t\tserver->capabilities = CAP_MPX_MODE;\n\t\t}\n\t\ttmp = (__s16)le16_to_cpu(rsp->ServerTimeZone);\n\t\tif (tmp == -1) {\n\t\t\t/* OS/2 often does not set timezone therefore\n\t\t\t * we must use server time to calc time zone.\n\t\t\t * Could deviate slightly from the right zone.\n\t\t\t * Smallest defined timezone difference is 15 minutes\n\t\t\t * (i.e. Nepal).  Rounding up/down is done to match\n\t\t\t * this requirement.\n\t\t\t */\n\t\t\tint val, seconds, remain, result;\n\t\t\tstruct timespec ts, utc;\n\t\t\tutc = CURRENT_TIME;\n\t\t\tts = cnvrtDosUnixTm(rsp->SrvTime.Date,\n\t\t\t\t\t    rsp->SrvTime.Time, 0);\n\t\t\tcFYI(1, \"SrvTime %d sec since 1970 (utc: %d) diff: %d\",\n\t\t\t\t(int)ts.tv_sec, (int)utc.tv_sec,\n\t\t\t\t(int)(utc.tv_sec - ts.tv_sec));\n\t\t\tval = (int)(utc.tv_sec - ts.tv_sec);\n\t\t\tseconds = abs(val);\n\t\t\tresult = (seconds / MIN_TZ_ADJ) * MIN_TZ_ADJ;\n\t\t\tremain = seconds % MIN_TZ_ADJ;\n\t\t\tif (remain >= (MIN_TZ_ADJ / 2))\n\t\t\t\tresult += MIN_TZ_ADJ;\n\t\t\tif (val < 0)\n\t\t\t\tresult = -result;\n\t\t\tserver->timeAdj = result;\n\t\t} else {\n\t\t\tserver->timeAdj = (int)tmp;\n\t\t\tserver->timeAdj *= 60; /* also in seconds */\n\t\t}\n\t\tcFYI(1, \"server->timeAdj: %d seconds\", server->timeAdj);\n\n\n\t\t/* BB get server time for time conversions and add\n\t\tcode to use it and timezone since this is not UTC */\n\n\t\tif (rsp->EncryptionKeyLength ==\n\t\t\t\tcpu_to_le16(CIFS_CRYPTO_KEY_SIZE)) {\n\t\t\tmemcpy(ses->server->cryptkey, rsp->EncryptionKey,\n\t\t\t\tCIFS_CRYPTO_KEY_SIZE);\n\t\t} else if (server->sec_mode & SECMODE_PW_ENCRYPT) {\n\t\t\trc = -EIO; /* need cryptkey unless plain text */\n\t\t\tgoto neg_err_exit;\n\t\t}\n\n\t\tcFYI(1, \"LANMAN negotiated\");\n\t\t/* we will not end up setting signing flags - as no signing\n\t\twas in LANMAN and server did not return the flags on */\n\t\tgoto signing_check;\n#else /* weak security disabled */\n\t} else if (pSMBr->hdr.WordCount == 13) {\n\t\tcERROR(1, \"mount failed, cifs module not built \"\n\t\t\t  \"with CIFS_WEAK_PW_HASH support\");\n\t\trc = -EOPNOTSUPP;\n#endif /* WEAK_PW_HASH */\n\t\tgoto neg_err_exit;\n\t} else if (pSMBr->hdr.WordCount != 17) {\n\t\t/* unknown wct */\n\t\trc = -EOPNOTSUPP;\n\t\tgoto neg_err_exit;\n\t}\n\t/* else wct == 17 NTLM */\n\tserver->sec_mode = pSMBr->SecurityMode;\n\tif ((server->sec_mode & SECMODE_USER) == 0)\n\t\tcFYI(1, \"share mode security\");\n\n\tif ((server->sec_mode & SECMODE_PW_ENCRYPT) == 0)\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\n\t\tif ((secFlags & CIFSSEC_MAY_PLNTXT) == 0)\n#endif /* CIFS_WEAK_PW_HASH */\n\t\t\tcERROR(1, \"Server requests plain text password\"\n\t\t\t\t  \" but client support disabled\");\n\n\tif ((secFlags & CIFSSEC_MUST_NTLMV2) == CIFSSEC_MUST_NTLMV2)\n\t\tserver->secType = NTLMv2;\n\telse if (secFlags & CIFSSEC_MAY_NTLM)\n\t\tserver->secType = NTLM;\n\telse if (secFlags & CIFSSEC_MAY_NTLMV2)\n\t\tserver->secType = NTLMv2;\n\telse if (secFlags & CIFSSEC_MAY_KRB5)\n\t\tserver->secType = Kerberos;\n\telse if (secFlags & CIFSSEC_MAY_NTLMSSP)\n\t\tserver->secType = RawNTLMSSP;\n\telse if (secFlags & CIFSSEC_MAY_LANMAN)\n\t\tserver->secType = LANMAN;\n\telse {\n\t\trc = -EOPNOTSUPP;\n\t\tcERROR(1, \"Invalid security type\");\n\t\tgoto neg_err_exit;\n\t}\n\t/* else ... any others ...? */\n\n\t/* one byte, so no need to convert this or EncryptionKeyLen from\n\t   little endian */\n\tserver->maxReq = le16_to_cpu(pSMBr->MaxMpxCount);\n\t/* probably no need to store and check maxvcs */\n\tserver->maxBuf = min(le32_to_cpu(pSMBr->MaxBufferSize),\n\t\t\t(__u32) CIFSMaxBufSize + MAX_CIFS_HDR_SIZE);\n\tserver->max_rw = le32_to_cpu(pSMBr->MaxRawSize);\n\tcFYI(DBG2, \"Max buf = %d\", ses->server->maxBuf);\n\tserver->capabilities = le32_to_cpu(pSMBr->Capabilities);\n\tserver->timeAdj = (int)(__s16)le16_to_cpu(pSMBr->ServerTimeZone);\n\tserver->timeAdj *= 60;\n\tif (pSMBr->EncryptionKeyLength == CIFS_CRYPTO_KEY_SIZE) {\n\t\tmemcpy(ses->server->cryptkey, pSMBr->u.EncryptionKey,\n\t\t       CIFS_CRYPTO_KEY_SIZE);\n\t} else if ((pSMBr->hdr.Flags2 & SMBFLG2_EXT_SEC ||\n\t\t\tserver->capabilities & CAP_EXTENDED_SECURITY) &&\n\t\t\t\t(pSMBr->EncryptionKeyLength == 0)) {\n\t\t/* decode security blob */\n\t\tcount = get_bcc(&pSMBr->hdr);\n\t\tif (count < 16) {\n\t\t\trc = -EIO;\n\t\t\tgoto neg_err_exit;\n\t\t}\n\t\tspin_lock(&cifs_tcp_ses_lock);\n\t\tif (server->srv_count > 1) {\n\t\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\t\tif (memcmp(server->server_GUID,\n\t\t\t\t   pSMBr->u.extended_response.\n\t\t\t\t   GUID, 16) != 0) {\n\t\t\t\tcFYI(1, \"server UID changed\");\n\t\t\t\tmemcpy(server->server_GUID,\n\t\t\t\t\tpSMBr->u.extended_response.GUID,\n\t\t\t\t\t16);\n\t\t\t}\n\t\t} else {\n\t\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\t\tmemcpy(server->server_GUID,\n\t\t\t       pSMBr->u.extended_response.GUID, 16);\n\t\t}\n\n\t\tif (count == 16) {\n\t\t\tserver->secType = RawNTLMSSP;\n\t\t} else {\n\t\t\trc = decode_negTokenInit(pSMBr->u.extended_response.\n\t\t\t\t\t\t SecurityBlob, count - 16,\n\t\t\t\t\t\t server);\n\t\t\tif (rc == 1)\n\t\t\t\trc = 0;\n\t\t\telse\n\t\t\t\trc = -EINVAL;\n\t\t\tif (server->secType == Kerberos) {\n\t\t\t\tif (!server->sec_kerberos &&\n\t\t\t\t\t\t!server->sec_mskerberos)\n\t\t\t\t\trc = -EOPNOTSUPP;\n\t\t\t} else if (server->secType == RawNTLMSSP) {\n\t\t\t\tif (!server->sec_ntlmssp)\n\t\t\t\t\trc = -EOPNOTSUPP;\n\t\t\t} else\n\t\t\t\t\trc = -EOPNOTSUPP;\n\t\t}\n\t} else if (server->sec_mode & SECMODE_PW_ENCRYPT) {\n\t\trc = -EIO; /* no crypt key only if plain text pwd */\n\t\tgoto neg_err_exit;\n\t} else\n\t\tserver->capabilities &= ~CAP_EXTENDED_SECURITY;\n\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\nsigning_check:\n#endif\n\tif ((secFlags & CIFSSEC_MAY_SIGN) == 0) {\n\t\t/* MUST_SIGN already includes the MAY_SIGN FLAG\n\t\t   so if this is zero it means that signing is disabled */\n\t\tcFYI(1, \"Signing disabled\");\n\t\tif (server->sec_mode & SECMODE_SIGN_REQUIRED) {\n\t\t\tcERROR(1, \"Server requires \"\n\t\t\t\t   \"packet signing to be enabled in \"\n\t\t\t\t   \"/proc/fs/cifs/SecurityFlags.\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t}\n\t\tserver->sec_mode &=\n\t\t\t~(SECMODE_SIGN_ENABLED | SECMODE_SIGN_REQUIRED);\n\t} else if ((secFlags & CIFSSEC_MUST_SIGN) == CIFSSEC_MUST_SIGN) {\n\t\t/* signing required */\n\t\tcFYI(1, \"Must sign - secFlags 0x%x\", secFlags);\n\t\tif ((server->sec_mode &\n\t\t\t(SECMODE_SIGN_ENABLED | SECMODE_SIGN_REQUIRED)) == 0) {\n\t\t\tcERROR(1, \"signing required but server lacks support\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t} else\n\t\t\tserver->sec_mode |= SECMODE_SIGN_REQUIRED;\n\t} else {\n\t\t/* signing optional ie CIFSSEC_MAY_SIGN */\n\t\tif ((server->sec_mode & SECMODE_SIGN_REQUIRED) == 0)\n\t\t\tserver->sec_mode &=\n\t\t\t\t~(SECMODE_SIGN_ENABLED | SECMODE_SIGN_REQUIRED);\n\t}\n\nneg_err_exit:\n\tcifs_buf_release(pSMB);\n\n\tcFYI(1, \"negprot rc %d\", rc);\n\treturn rc;\n}\n\nint\nCIFSSMBTDis(const int xid, struct cifs_tcon *tcon)\n{\n\tstruct smb_hdr *smb_buffer;\n\tint rc = 0;\n\n\tcFYI(1, \"In tree disconnect\");\n\n\t/* BB: do we need to check this? These should never be NULL. */\n\tif ((tcon->ses == NULL) || (tcon->ses->server == NULL))\n\t\treturn -EIO;\n\n\t/*\n\t * No need to return error on this operation if tid invalidated and\n\t * closed on server already e.g. due to tcp session crashing. Also,\n\t * the tcon is no longer on the list, so no need to take lock before\n\t * checking this.\n\t */\n\tif ((tcon->need_reconnect) || (tcon->ses->need_reconnect))\n\t\treturn 0;\n\n\trc = small_smb_init(SMB_COM_TREE_DISCONNECT, 0, tcon,\n\t\t\t    (void **)&smb_buffer);\n\tif (rc)\n\t\treturn rc;\n\n\trc = SendReceiveNoRsp(xid, tcon->ses, smb_buffer, 0);\n\tif (rc)\n\t\tcFYI(1, \"Tree disconnect failed %d\", rc);\n\n\t/* No need to return error on this operation if tid invalidated and\n\t   closed on server already e.g. due to tcp session crashing */\n\tif (rc == -EAGAIN)\n\t\trc = 0;\n\n\treturn rc;\n}\n\n/*\n * This is a no-op for now. We're not really interested in the reply, but\n * rather in the fact that the server sent one and that server->lstrp\n * gets updated.\n *\n * FIXME: maybe we should consider checking that the reply matches request?\n */\nstatic void\ncifs_echo_callback(struct mid_q_entry *mid)\n{\n\tstruct TCP_Server_Info *server = mid->callback_data;\n\n\tDeleteMidQEntry(mid);\n\tatomic_dec(&server->inFlight);\n\twake_up(&server->request_q);\n}\n\nint\nCIFSSMBEcho(struct TCP_Server_Info *server)\n{\n\tECHO_REQ *smb;\n\tint rc = 0;\n\tstruct kvec iov;\n\n\tcFYI(1, \"In echo request\");\n\n\trc = small_smb_init(SMB_COM_ECHO, 0, NULL, (void **)&smb);\n\tif (rc)\n\t\treturn rc;\n\n\t/* set up echo request */\n\tsmb->hdr.Tid = 0xffff;\n\tsmb->hdr.WordCount = 1;\n\tput_unaligned_le16(1, &smb->EchoCount);\n\tput_bcc(1, &smb->hdr);\n\tsmb->Data[0] = 'a';\n\tinc_rfc1001_len(smb, 3);\n\tiov.iov_base = smb;\n\tiov.iov_len = be32_to_cpu(smb->hdr.smb_buf_length) + 4;\n\n\trc = cifs_call_async(server, &iov, 1, cifs_echo_callback, server, true);\n\tif (rc)\n\t\tcFYI(1, \"Echo request failed: %d\", rc);\n\n\tcifs_small_buf_release(smb);\n\n\treturn rc;\n}\n\nint\nCIFSSMBLogoff(const int xid, struct cifs_ses *ses)\n{\n\tLOGOFF_ANDX_REQ *pSMB;\n\tint rc = 0;\n\n\tcFYI(1, \"In SMBLogoff for session disconnect\");\n\n\t/*\n\t * BB: do we need to check validity of ses and server? They should\n\t * always be valid since we have an active reference. If not, that\n\t * should probably be a BUG()\n\t */\n\tif (!ses || !ses->server)\n\t\treturn -EIO;\n\n\tmutex_lock(&ses->session_mutex);\n\tif (ses->need_reconnect)\n\t\tgoto session_already_dead; /* no need to send SMBlogoff if uid\n\t\t\t\t\t      already closed due to reconnect */\n\trc = small_smb_init(SMB_COM_LOGOFF_ANDX, 2, NULL, (void **)&pSMB);\n\tif (rc) {\n\t\tmutex_unlock(&ses->session_mutex);\n\t\treturn rc;\n\t}\n\n\tpSMB->hdr.Mid = GetNextMid(ses->server);\n\n\tif (ses->server->sec_mode &\n\t\t   (SECMODE_SIGN_REQUIRED | SECMODE_SIGN_ENABLED))\n\t\t\tpSMB->hdr.Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\n\tpSMB->hdr.Uid = ses->Suid;\n\n\tpSMB->AndXCommand = 0xFF;\n\trc = SendReceiveNoRsp(xid, ses, (struct smb_hdr *) pSMB, 0);\nsession_already_dead:\n\tmutex_unlock(&ses->session_mutex);\n\n\t/* if session dead then we do not need to do ulogoff,\n\t\tsince server closed smb session, no sense reporting\n\t\terror */\n\tif (rc == -EAGAIN)\n\t\trc = 0;\n\treturn rc;\n}\n\nint\nCIFSPOSIXDelFile(const int xid, struct cifs_tcon *tcon, const char *fileName,\n\t\t __u16 type, const struct nls_table *nls_codepage, int remap)\n{\n\tTRANSACTION2_SPI_REQ *pSMB = NULL;\n\tTRANSACTION2_SPI_RSP *pSMBr = NULL;\n\tstruct unlink_psx_rq *pRqD;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, param_offset, offset, byte_count;\n\n\tcFYI(1, \"In POSIX delete\");\nPsxDelete:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUCS((__le16 *) pSMB->FileName, fileName,\n\t\t\t\t     PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else { /* BB add path length overrun check */\n\t\tname_len = strnlen(fileName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, fileName, name_len);\n\t}\n\n\tparams = 6 + name_len;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = 0; /* BB double check this with jra */\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\n\t/* Setup pointer to Request Data (inode type) */\n\tpRqD = (struct unlink_psx_rq *)(((char *)&pSMB->hdr.Protocol) + offset);\n\tpRqD->type = cpu_to_le16(type);\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + sizeof(struct unlink_psx_rq);\n\n\tpSMB->DataCount = cpu_to_le16(sizeof(struct unlink_psx_rq));\n\tpSMB->TotalDataCount = cpu_to_le16(sizeof(struct unlink_psx_rq));\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_POSIX_UNLINK);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcFYI(1, \"Posix delete returned %d\", rc);\n\tcifs_buf_release(pSMB);\n\n\tcifs_stats_inc(&tcon->num_deletes);\n\n\tif (rc == -EAGAIN)\n\t\tgoto PsxDelete;\n\n\treturn rc;\n}\n\nint\nCIFSSMBDelFile(const int xid, struct cifs_tcon *tcon, const char *fileName,\n\t       const struct nls_table *nls_codepage, int remap)\n{\n\tDELETE_FILE_REQ *pSMB = NULL;\n\tDELETE_FILE_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\nDelFileRetry:\n\trc = smb_init(SMB_COM_DELETE, 1, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUCS((__le16 *) pSMB->fileName, fileName,\n\t\t\t\t     PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t\t/* BB improve check for buffer overruns BB */\n\t\tname_len = strnlen(fileName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->fileName, fileName, name_len);\n\t}\n\tpSMB->SearchAttributes =\n\t    cpu_to_le16(ATTR_READONLY | ATTR_HIDDEN | ATTR_SYSTEM);\n\tpSMB->BufferFormat = 0x04;\n\tinc_rfc1001_len(pSMB, name_len + 1);\n\tpSMB->ByteCount = cpu_to_le16(name_len + 1);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->num_deletes);\n\tif (rc)\n\t\tcFYI(1, \"Error in RMFile = %d\", rc);\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto DelFileRetry;\n\n\treturn rc;\n}\n\nint\nCIFSSMBRmDir(const int xid, struct cifs_tcon *tcon, const char *dirName,\n\t     const struct nls_table *nls_codepage, int remap)\n{\n\tDELETE_DIRECTORY_REQ *pSMB = NULL;\n\tDELETE_DIRECTORY_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\n\tcFYI(1, \"In CIFSSMBRmDir\");\nRmDirRetry:\n\trc = smb_init(SMB_COM_DELETE_DIRECTORY, 0, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len = cifsConvertToUCS((__le16 *) pSMB->DirName, dirName,\n\t\t\t\t\t PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t\t/* BB improve check for buffer overruns BB */\n\t\tname_len = strnlen(dirName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->DirName, dirName, name_len);\n\t}\n\n\tpSMB->BufferFormat = 0x04;\n\tinc_rfc1001_len(pSMB, name_len + 1);\n\tpSMB->ByteCount = cpu_to_le16(name_len + 1);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->num_rmdirs);\n\tif (rc)\n\t\tcFYI(1, \"Error in RMDir = %d\", rc);\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto RmDirRetry;\n\treturn rc;\n}\n\nint\nCIFSSMBMkDir(const int xid, struct cifs_tcon *tcon,\n\t     const char *name, const struct nls_table *nls_codepage, int remap)\n{\n\tint rc = 0;\n\tCREATE_DIRECTORY_REQ *pSMB = NULL;\n\tCREATE_DIRECTORY_RSP *pSMBr = NULL;\n\tint bytes_returned;\n\tint name_len;\n\n\tcFYI(1, \"In CIFSSMBMkDir\");\nMkDirRetry:\n\trc = smb_init(SMB_COM_CREATE_DIRECTORY, 0, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len = cifsConvertToUCS((__le16 *) pSMB->DirName, name,\n\t\t\t\t\t    PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t\t/* BB improve check for buffer overruns BB */\n\t\tname_len = strnlen(name, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->DirName, name, name_len);\n\t}\n\n\tpSMB->BufferFormat = 0x04;\n\tinc_rfc1001_len(pSMB, name_len + 1);\n\tpSMB->ByteCount = cpu_to_le16(name_len + 1);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->num_mkdirs);\n\tif (rc)\n\t\tcFYI(1, \"Error in Mkdir = %d\", rc);\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto MkDirRetry;\n\treturn rc;\n}\n\nint\nCIFSPOSIXCreate(const int xid, struct cifs_tcon *tcon, __u32 posix_flags,\n\t\t__u64 mode, __u16 *netfid, FILE_UNIX_BASIC_INFO *pRetData,\n\t\t__u32 *pOplock, const char *name,\n\t\tconst struct nls_table *nls_codepage, int remap)\n{\n\tTRANSACTION2_SPI_REQ *pSMB = NULL;\n\tTRANSACTION2_SPI_RSP *pSMBr = NULL;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, param_offset, offset, byte_count, count;\n\tOPEN_PSX_REQ *pdata;\n\tOPEN_PSX_RSP *psx_rsp;\n\n\tcFYI(1, \"In POSIX Create\");\nPsxCreat:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUCS((__le16 *) pSMB->FileName, name,\n\t\t\t\t     PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(name, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, name, name_len);\n\t}\n\n\tparams = 6 + name_len;\n\tcount = sizeof(OPEN_PSX_REQ);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\t/* large enough */\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\tpdata = (OPEN_PSX_REQ *)(((char *)&pSMB->hdr.Protocol) + offset);\n\tpdata->Level = cpu_to_le16(SMB_QUERY_FILE_UNIX_BASIC);\n\tpdata->Permissions = cpu_to_le64(mode);\n\tpdata->PosixOpenFlags = cpu_to_le32(posix_flags);\n\tpdata->OpenFlags =  cpu_to_le32(*pOplock);\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_POSIX_OPEN);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcFYI(1, \"Posix create returned %d\", rc);\n\t\tgoto psx_create_err;\n\t}\n\n\tcFYI(1, \"copying inode info\");\n\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\tif (rc || get_bcc(&pSMBr->hdr) < sizeof(OPEN_PSX_RSP)) {\n\t\trc = -EIO;\t/* bad smb */\n\t\tgoto psx_create_err;\n\t}\n\n\t/* copy return information to pRetData */\n\tpsx_rsp = (OPEN_PSX_RSP *)((char *) &pSMBr->hdr.Protocol\n\t\t\t+ le16_to_cpu(pSMBr->t2.DataOffset));\n\n\t*pOplock = le16_to_cpu(psx_rsp->OplockFlags);\n\tif (netfid)\n\t\t*netfid = psx_rsp->Fid;   /* cifs fid stays in le */\n\t/* Let caller know file was created so we can set the mode. */\n\t/* Do we care about the CreateAction in any other cases? */\n\tif (cpu_to_le32(FILE_CREATE) == psx_rsp->CreateAction)\n\t\t*pOplock |= CIFS_CREATE_ACTION;\n\t/* check to make sure response data is there */\n\tif (psx_rsp->ReturnedLevel != cpu_to_le16(SMB_QUERY_FILE_UNIX_BASIC)) {\n\t\tpRetData->Type = cpu_to_le32(-1); /* unknown */\n\t\tcFYI(DBG2, \"unknown type\");\n\t} else {\n\t\tif (get_bcc(&pSMBr->hdr) < sizeof(OPEN_PSX_RSP)\n\t\t\t\t\t+ sizeof(FILE_UNIX_BASIC_INFO)) {\n\t\t\tcERROR(1, \"Open response data too small\");\n\t\t\tpRetData->Type = cpu_to_le32(-1);\n\t\t\tgoto psx_create_err;\n\t\t}\n\t\tmemcpy((char *) pRetData,\n\t\t\t(char *)psx_rsp + sizeof(OPEN_PSX_RSP),\n\t\t\tsizeof(FILE_UNIX_BASIC_INFO));\n\t}\n\npsx_create_err:\n\tcifs_buf_release(pSMB);\n\n\tif (posix_flags & SMB_O_DIRECTORY)\n\t\tcifs_stats_inc(&tcon->num_posixmkdirs);\n\telse\n\t\tcifs_stats_inc(&tcon->num_posixopens);\n\n\tif (rc == -EAGAIN)\n\t\tgoto PsxCreat;\n\n\treturn rc;\n}\n\nstatic __u16 convert_disposition(int disposition)\n{\n\t__u16 ofun = 0;\n\n\tswitch (disposition) {\n\t\tcase FILE_SUPERSEDE:\n\t\t\tofun = SMBOPEN_OCREATE | SMBOPEN_OTRUNC;\n\t\t\tbreak;\n\t\tcase FILE_OPEN:\n\t\t\tofun = SMBOPEN_OAPPEND;\n\t\t\tbreak;\n\t\tcase FILE_CREATE:\n\t\t\tofun = SMBOPEN_OCREATE;\n\t\t\tbreak;\n\t\tcase FILE_OPEN_IF:\n\t\t\tofun = SMBOPEN_OCREATE | SMBOPEN_OAPPEND;\n\t\t\tbreak;\n\t\tcase FILE_OVERWRITE:\n\t\t\tofun = SMBOPEN_OTRUNC;\n\t\t\tbreak;\n\t\tcase FILE_OVERWRITE_IF:\n\t\t\tofun = SMBOPEN_OCREATE | SMBOPEN_OTRUNC;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcFYI(1, \"unknown disposition %d\", disposition);\n\t\t\tofun =  SMBOPEN_OAPPEND; /* regular open */\n\t}\n\treturn ofun;\n}\n\nstatic int\naccess_flags_to_smbopen_mode(const int access_flags)\n{\n\tint masked_flags = access_flags & (GENERIC_READ | GENERIC_WRITE);\n\n\tif (masked_flags == GENERIC_READ)\n\t\treturn SMBOPEN_READ;\n\telse if (masked_flags == GENERIC_WRITE)\n\t\treturn SMBOPEN_WRITE;\n\n\t/* just go for read/write */\n\treturn SMBOPEN_READWRITE;\n}\n\nint\nSMBLegacyOpen(const int xid, struct cifs_tcon *tcon,\n\t    const char *fileName, const int openDisposition,\n\t    const int access_flags, const int create_options, __u16 *netfid,\n\t    int *pOplock, FILE_ALL_INFO *pfile_info,\n\t    const struct nls_table *nls_codepage, int remap)\n{\n\tint rc = -EACCES;\n\tOPENX_REQ *pSMB = NULL;\n\tOPENX_RSP *pSMBr = NULL;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 count;\n\nOldOpenRetry:\n\trc = smb_init(SMB_COM_OPEN_ANDX, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->AndXCommand = 0xFF;       /* none */\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tcount = 1;      /* account for one byte pad to word boundary */\n\t\tname_len =\n\t\t   cifsConvertToUCS((__le16 *) (pSMB->fileName + 1),\n\t\t\t\t    fileName, PATH_MAX, nls_codepage, remap);\n\t\tname_len++;     /* trailing null */\n\t\tname_len *= 2;\n\t} else {                /* BB improve check for buffer overruns BB */\n\t\tcount = 0;      /* no pad */\n\t\tname_len = strnlen(fileName, PATH_MAX);\n\t\tname_len++;     /* trailing null */\n\t\tstrncpy(pSMB->fileName, fileName, name_len);\n\t}\n\tif (*pOplock & REQ_OPLOCK)\n\t\tpSMB->OpenFlags = cpu_to_le16(REQ_OPLOCK);\n\telse if (*pOplock & REQ_BATCHOPLOCK)\n\t\tpSMB->OpenFlags = cpu_to_le16(REQ_BATCHOPLOCK);\n\n\tpSMB->OpenFlags |= cpu_to_le16(REQ_MORE_INFO);\n\tpSMB->Mode = cpu_to_le16(access_flags_to_smbopen_mode(access_flags));\n\tpSMB->Mode |= cpu_to_le16(0x40); /* deny none */\n\t/* set file as system file if special file such\n\t   as fifo and server expecting SFU style and\n\t   no Unix extensions */\n\n\tif (create_options & CREATE_OPTION_SPECIAL)\n\t\tpSMB->FileAttributes = cpu_to_le16(ATTR_SYSTEM);\n\telse /* BB FIXME BB */\n\t\tpSMB->FileAttributes = cpu_to_le16(0/*ATTR_NORMAL*/);\n\n\tif (create_options & CREATE_OPTION_READONLY)\n\t\tpSMB->FileAttributes |= cpu_to_le16(ATTR_READONLY);\n\n\t/* BB FIXME BB */\n/*\tpSMB->CreateOptions = cpu_to_le32(create_options &\n\t\t\t\t\t\t CREATE_OPTIONS_MASK); */\n\t/* BB FIXME END BB */\n\n\tpSMB->Sattr = cpu_to_le16(ATTR_HIDDEN | ATTR_SYSTEM | ATTR_DIRECTORY);\n\tpSMB->OpenFunction = cpu_to_le16(convert_disposition(openDisposition));\n\tcount += name_len;\n\tinc_rfc1001_len(pSMB, count);\n\n\tpSMB->ByteCount = cpu_to_le16(count);\n\t/* long_op set to 1 to allow for oplock break timeouts */\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *)pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->num_opens);\n\tif (rc) {\n\t\tcFYI(1, \"Error in Open = %d\", rc);\n\t} else {\n\t/* BB verify if wct == 15 */\n\n/*\t\t*pOplock = pSMBr->OplockLevel; */ /* BB take from action field*/\n\n\t\t*netfid = pSMBr->Fid;   /* cifs fid stays in le */\n\t\t/* Let caller know file was created so we can set the mode. */\n\t\t/* Do we care about the CreateAction in any other cases? */\n\t/* BB FIXME BB */\n/*\t\tif (cpu_to_le32(FILE_CREATE) == pSMBr->CreateAction)\n\t\t\t*pOplock |= CIFS_CREATE_ACTION; */\n\t/* BB FIXME END */\n\n\t\tif (pfile_info) {\n\t\t\tpfile_info->CreationTime = 0; /* BB convert CreateTime*/\n\t\t\tpfile_info->LastAccessTime = 0; /* BB fixme */\n\t\t\tpfile_info->LastWriteTime = 0; /* BB fixme */\n\t\t\tpfile_info->ChangeTime = 0;  /* BB fixme */\n\t\t\tpfile_info->Attributes =\n\t\t\t\tcpu_to_le32(le16_to_cpu(pSMBr->FileAttributes));\n\t\t\t/* the file_info buf is endian converted by caller */\n\t\t\tpfile_info->AllocationSize =\n\t\t\t\tcpu_to_le64(le32_to_cpu(pSMBr->EndOfFile));\n\t\t\tpfile_info->EndOfFile = pfile_info->AllocationSize;\n\t\t\tpfile_info->NumberOfLinks = cpu_to_le32(1);\n\t\t\tpfile_info->DeletePending = 0;\n\t\t}\n\t}\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto OldOpenRetry;\n\treturn rc;\n}\n\nint\nCIFSSMBOpen(const int xid, struct cifs_tcon *tcon,\n\t    const char *fileName, const int openDisposition,\n\t    const int access_flags, const int create_options, __u16 *netfid,\n\t    int *pOplock, FILE_ALL_INFO *pfile_info,\n\t    const struct nls_table *nls_codepage, int remap)\n{\n\tint rc = -EACCES;\n\tOPEN_REQ *pSMB = NULL;\n\tOPEN_RSP *pSMBr = NULL;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 count;\n\nopenRetry:\n\trc = smb_init(SMB_COM_NT_CREATE_ANDX, 24, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->AndXCommand = 0xFF;\t/* none */\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tcount = 1;\t/* account for one byte pad to word boundary */\n\t\tname_len =\n\t\t    cifsConvertToUCS((__le16 *) (pSMB->fileName + 1),\n\t\t\t\t     fileName, PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t\tpSMB->NameLength = cpu_to_le16(name_len);\n\t} else {\t\t/* BB improve check for buffer overruns BB */\n\t\tcount = 0;\t/* no pad */\n\t\tname_len = strnlen(fileName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tpSMB->NameLength = cpu_to_le16(name_len);\n\t\tstrncpy(pSMB->fileName, fileName, name_len);\n\t}\n\tif (*pOplock & REQ_OPLOCK)\n\t\tpSMB->OpenFlags = cpu_to_le32(REQ_OPLOCK);\n\telse if (*pOplock & REQ_BATCHOPLOCK)\n\t\tpSMB->OpenFlags = cpu_to_le32(REQ_BATCHOPLOCK);\n\tpSMB->DesiredAccess = cpu_to_le32(access_flags);\n\tpSMB->AllocationSize = 0;\n\t/* set file as system file if special file such\n\t   as fifo and server expecting SFU style and\n\t   no Unix extensions */\n\tif (create_options & CREATE_OPTION_SPECIAL)\n\t\tpSMB->FileAttributes = cpu_to_le32(ATTR_SYSTEM);\n\telse\n\t\tpSMB->FileAttributes = cpu_to_le32(ATTR_NORMAL);\n\n\t/* XP does not handle ATTR_POSIX_SEMANTICS */\n\t/* but it helps speed up case sensitive checks for other\n\tservers such as Samba */\n\tif (tcon->ses->capabilities & CAP_UNIX)\n\t\tpSMB->FileAttributes |= cpu_to_le32(ATTR_POSIX_SEMANTICS);\n\n\tif (create_options & CREATE_OPTION_READONLY)\n\t\tpSMB->FileAttributes |= cpu_to_le32(ATTR_READONLY);\n\n\tpSMB->ShareAccess = cpu_to_le32(FILE_SHARE_ALL);\n\tpSMB->CreateDisposition = cpu_to_le32(openDisposition);\n\tpSMB->CreateOptions = cpu_to_le32(create_options & CREATE_OPTIONS_MASK);\n\t/* BB Expirement with various impersonation levels and verify */\n\tpSMB->ImpersonationLevel = cpu_to_le32(SECURITY_IMPERSONATION);\n\tpSMB->SecurityFlags =\n\t    SECURITY_CONTEXT_TRACKING | SECURITY_EFFECTIVE_ONLY;\n\n\tcount += name_len;\n\tinc_rfc1001_len(pSMB, count);\n\n\tpSMB->ByteCount = cpu_to_le16(count);\n\t/* long_op set to 1 to allow for oplock break timeouts */\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *)pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->num_opens);\n\tif (rc) {\n\t\tcFYI(1, \"Error in Open = %d\", rc);\n\t} else {\n\t\t*pOplock = pSMBr->OplockLevel; /* 1 byte no need to le_to_cpu */\n\t\t*netfid = pSMBr->Fid;\t/* cifs fid stays in le */\n\t\t/* Let caller know file was created so we can set the mode. */\n\t\t/* Do we care about the CreateAction in any other cases? */\n\t\tif (cpu_to_le32(FILE_CREATE) == pSMBr->CreateAction)\n\t\t\t*pOplock |= CIFS_CREATE_ACTION;\n\t\tif (pfile_info) {\n\t\t\tmemcpy((char *)pfile_info, (char *)&pSMBr->CreationTime,\n\t\t\t\t36 /* CreationTime to Attributes */);\n\t\t\t/* the file_info buf is endian converted by caller */\n\t\t\tpfile_info->AllocationSize = pSMBr->AllocationSize;\n\t\t\tpfile_info->EndOfFile = pSMBr->EndOfFile;\n\t\t\tpfile_info->NumberOfLinks = cpu_to_le32(1);\n\t\t\tpfile_info->DeletePending = 0;\n\t\t}\n\t}\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto openRetry;\n\treturn rc;\n}\n\nint\nCIFSSMBRead(const int xid, struct cifs_io_parms *io_parms, unsigned int *nbytes,\n\t    char **buf, int *pbuf_type)\n{\n\tint rc = -EACCES;\n\tREAD_REQ *pSMB = NULL;\n\tREAD_RSP *pSMBr = NULL;\n\tchar *pReadData = NULL;\n\tint wct;\n\tint resp_buf_type = 0;\n\tstruct kvec iov[1];\n\t__u32 pid = io_parms->pid;\n\t__u16 netfid = io_parms->netfid;\n\t__u64 offset = io_parms->offset;\n\tstruct cifs_tcon *tcon = io_parms->tcon;\n\tunsigned int count = io_parms->length;\n\n\tcFYI(1, \"Reading %d bytes on fid %d\", count, netfid);\n\tif (tcon->ses->capabilities & CAP_LARGE_FILES)\n\t\twct = 12;\n\telse {\n\t\twct = 10; /* old style read */\n\t\tif ((offset >> 32) > 0)  {\n\t\t\t/* can not handle this big offset for old */\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\t*nbytes = 0;\n\trc = small_smb_init(SMB_COM_READ_ANDX, wct, tcon, (void **) &pSMB);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid >> 16));\n\n\t/* tcon and ses pointer are checked in smb_init */\n\tif (tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\tpSMB->AndXCommand = 0xFF;       /* none */\n\tpSMB->Fid = netfid;\n\tpSMB->OffsetLow = cpu_to_le32(offset & 0xFFFFFFFF);\n\tif (wct == 12)\n\t\tpSMB->OffsetHigh = cpu_to_le32(offset >> 32);\n\n\tpSMB->Remaining = 0;\n\tpSMB->MaxCount = cpu_to_le16(count & 0xFFFF);\n\tpSMB->MaxCountHigh = cpu_to_le32(count >> 16);\n\tif (wct == 12)\n\t\tpSMB->ByteCount = 0;  /* no need to do le conversion since 0 */\n\telse {\n\t\t/* old style read */\n\t\tstruct smb_com_readx_req *pSMBW =\n\t\t\t(struct smb_com_readx_req *)pSMB;\n\t\tpSMBW->ByteCount = 0;\n\t}\n\n\tiov[0].iov_base = (char *)pSMB;\n\tiov[0].iov_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 4;\n\trc = SendReceive2(xid, tcon->ses, iov, 1 /* num iovecs */,\n\t\t\t &resp_buf_type, CIFS_LOG_ERROR);\n\tcifs_stats_inc(&tcon->num_reads);\n\tpSMBr = (READ_RSP *)iov[0].iov_base;\n\tif (rc) {\n\t\tcERROR(1, \"Send error in read = %d\", rc);\n\t} else {\n\t\tint data_length = le16_to_cpu(pSMBr->DataLengthHigh);\n\t\tdata_length = data_length << 16;\n\t\tdata_length += le16_to_cpu(pSMBr->DataLength);\n\t\t*nbytes = data_length;\n\n\t\t/*check that DataLength would not go beyond end of SMB */\n\t\tif ((data_length > CIFSMaxBufSize)\n\t\t\t\t|| (data_length > count)) {\n\t\t\tcFYI(1, \"bad length %d for count %d\",\n\t\t\t\t data_length, count);\n\t\t\trc = -EIO;\n\t\t\t*nbytes = 0;\n\t\t} else {\n\t\t\tpReadData = (char *) (&pSMBr->hdr.Protocol) +\n\t\t\t\t\tle16_to_cpu(pSMBr->DataOffset);\n/*\t\t\tif (rc = copy_to_user(buf, pReadData, data_length)) {\n\t\t\t\tcERROR(1, \"Faulting on read rc = %d\",rc);\n\t\t\t\trc = -EFAULT;\n\t\t\t}*/ /* can not use copy_to_user when using page cache*/\n\t\t\tif (*buf)\n\t\t\t\tmemcpy(*buf, pReadData, data_length);\n\t\t}\n\t}\n\n/*\tcifs_small_buf_release(pSMB); */ /* Freed earlier now in SendReceive2 */\n\tif (*buf) {\n\t\tif (resp_buf_type == CIFS_SMALL_BUFFER)\n\t\t\tcifs_small_buf_release(iov[0].iov_base);\n\t\telse if (resp_buf_type == CIFS_LARGE_BUFFER)\n\t\t\tcifs_buf_release(iov[0].iov_base);\n\t} else if (resp_buf_type != CIFS_NO_BUFFER) {\n\t\t/* return buffer to caller to free */\n\t\t*buf = iov[0].iov_base;\n\t\tif (resp_buf_type == CIFS_SMALL_BUFFER)\n\t\t\t*pbuf_type = CIFS_SMALL_BUFFER;\n\t\telse if (resp_buf_type == CIFS_LARGE_BUFFER)\n\t\t\t*pbuf_type = CIFS_LARGE_BUFFER;\n\t} /* else no valid buffer on return - leave as null */\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\treturn rc;\n}\n\n\nint\nCIFSSMBWrite(const int xid, struct cifs_io_parms *io_parms,\n\t     unsigned int *nbytes, const char *buf,\n\t     const char __user *ubuf, const int long_op)\n{\n\tint rc = -EACCES;\n\tWRITE_REQ *pSMB = NULL;\n\tWRITE_RSP *pSMBr = NULL;\n\tint bytes_returned, wct;\n\t__u32 bytes_sent;\n\t__u16 byte_count;\n\t__u32 pid = io_parms->pid;\n\t__u16 netfid = io_parms->netfid;\n\t__u64 offset = io_parms->offset;\n\tstruct cifs_tcon *tcon = io_parms->tcon;\n\tunsigned int count = io_parms->length;\n\n\t*nbytes = 0;\n\n\t/* cFYI(1, \"write at %lld %d bytes\", offset, count);*/\n\tif (tcon->ses == NULL)\n\t\treturn -ECONNABORTED;\n\n\tif (tcon->ses->capabilities & CAP_LARGE_FILES)\n\t\twct = 14;\n\telse {\n\t\twct = 12;\n\t\tif ((offset >> 32) > 0) {\n\t\t\t/* can not handle big offset for old srv */\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\trc = smb_init(SMB_COM_WRITE_ANDX, wct, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid >> 16));\n\n\t/* tcon and ses pointer are checked in smb_init */\n\tif (tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\tpSMB->AndXCommand = 0xFF;\t/* none */\n\tpSMB->Fid = netfid;\n\tpSMB->OffsetLow = cpu_to_le32(offset & 0xFFFFFFFF);\n\tif (wct == 14)\n\t\tpSMB->OffsetHigh = cpu_to_le32(offset >> 32);\n\n\tpSMB->Reserved = 0xFFFFFFFF;\n\tpSMB->WriteMode = 0;\n\tpSMB->Remaining = 0;\n\n\t/* Can increase buffer size if buffer is big enough in some cases ie we\n\tcan send more if LARGE_WRITE_X capability returned by the server and if\n\tour buffer is big enough or if we convert to iovecs on socket writes\n\tand eliminate the copy to the CIFS buffer */\n\tif (tcon->ses->capabilities & CAP_LARGE_WRITE_X) {\n\t\tbytes_sent = min_t(const unsigned int, CIFSMaxBufSize, count);\n\t} else {\n\t\tbytes_sent = (tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE)\n\t\t\t & ~0xFF;\n\t}\n\n\tif (bytes_sent > count)\n\t\tbytes_sent = count;\n\tpSMB->DataOffset =\n\t\tcpu_to_le16(offsetof(struct smb_com_write_req, Data) - 4);\n\tif (buf)\n\t\tmemcpy(pSMB->Data, buf, bytes_sent);\n\telse if (ubuf) {\n\t\tif (copy_from_user(pSMB->Data, ubuf, bytes_sent)) {\n\t\t\tcifs_buf_release(pSMB);\n\t\t\treturn -EFAULT;\n\t\t}\n\t} else if (count != 0) {\n\t\t/* No buffer */\n\t\tcifs_buf_release(pSMB);\n\t\treturn -EINVAL;\n\t} /* else setting file size with write of zero bytes */\n\tif (wct == 14)\n\t\tbyte_count = bytes_sent + 1; /* pad */\n\telse /* wct == 12 */\n\t\tbyte_count = bytes_sent + 5; /* bigger pad, smaller smb hdr */\n\n\tpSMB->DataLengthLow = cpu_to_le16(bytes_sent & 0xFFFF);\n\tpSMB->DataLengthHigh = cpu_to_le16(bytes_sent >> 16);\n\tinc_rfc1001_len(pSMB, byte_count);\n\n\tif (wct == 14)\n\t\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\telse { /* old style write has byte count 4 bytes earlier\n\t\t  so 4 bytes pad  */\n\t\tstruct smb_com_writex_req *pSMBW =\n\t\t\t(struct smb_com_writex_req *)pSMB;\n\t\tpSMBW->ByteCount = cpu_to_le16(byte_count);\n\t}\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, long_op);\n\tcifs_stats_inc(&tcon->num_writes);\n\tif (rc) {\n\t\tcFYI(1, \"Send error in write = %d\", rc);\n\t} else {\n\t\t*nbytes = le16_to_cpu(pSMBr->CountHigh);\n\t\t*nbytes = (*nbytes) << 16;\n\t\t*nbytes += le16_to_cpu(pSMBr->Count);\n\n\t\t/*\n\t\t * Mask off high 16 bits when bytes written as returned by the\n\t\t * server is greater than bytes requested by the client. Some\n\t\t * OS/2 servers are known to set incorrect CountHigh values.\n\t\t */\n\t\tif (*nbytes > count)\n\t\t\t*nbytes &= 0xFFFF;\n\t}\n\n\tcifs_buf_release(pSMB);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\n\treturn rc;\n}\n\nvoid\ncifs_writedata_release(struct kref *refcount)\n{\n\tstruct cifs_writedata *wdata = container_of(refcount,\n\t\t\t\t\tstruct cifs_writedata, refcount);\n\n\tif (wdata->cfile)\n\t\tcifsFileInfo_put(wdata->cfile);\n\n\tkfree(wdata);\n}\n\n/*\n * Write failed with a retryable error. Resend the write request. It's also\n * possible that the page was redirtied so re-clean the page.\n */\nstatic void\ncifs_writev_requeue(struct cifs_writedata *wdata)\n{\n\tint i, rc;\n\tstruct inode *inode = wdata->cfile->dentry->d_inode;\n\n\tfor (i = 0; i < wdata->nr_pages; i++) {\n\t\tlock_page(wdata->pages[i]);\n\t\tclear_page_dirty_for_io(wdata->pages[i]);\n\t}\n\n\tdo {\n\t\trc = cifs_async_writev(wdata);\n\t} while (rc == -EAGAIN);\n\n\tfor (i = 0; i < wdata->nr_pages; i++) {\n\t\tif (rc != 0)\n\t\t\tSetPageError(wdata->pages[i]);\n\t\tunlock_page(wdata->pages[i]);\n\t}\n\n\tmapping_set_error(inode->i_mapping, rc);\n\tkref_put(&wdata->refcount, cifs_writedata_release);\n}\n\nstatic void\ncifs_writev_complete(struct work_struct *work)\n{\n\tstruct cifs_writedata *wdata = container_of(work,\n\t\t\t\t\t\tstruct cifs_writedata, work);\n\tstruct inode *inode = wdata->cfile->dentry->d_inode;\n\tint i = 0;\n\n\tif (wdata->result == 0) {\n\t\tcifs_update_eof(CIFS_I(inode), wdata->offset, wdata->bytes);\n\t\tcifs_stats_bytes_written(tlink_tcon(wdata->cfile->tlink),\n\t\t\t\t\t wdata->bytes);\n\t} else if (wdata->sync_mode == WB_SYNC_ALL && wdata->result == -EAGAIN)\n\t\treturn cifs_writev_requeue(wdata);\n\n\tfor (i = 0; i < wdata->nr_pages; i++) {\n\t\tstruct page *page = wdata->pages[i];\n\t\tif (wdata->result == -EAGAIN)\n\t\t\t__set_page_dirty_nobuffers(page);\n\t\telse if (wdata->result < 0)\n\t\t\tSetPageError(page);\n\t\tend_page_writeback(page);\n\t\tpage_cache_release(page);\n\t}\n\tif (wdata->result != -EAGAIN)\n\t\tmapping_set_error(inode->i_mapping, wdata->result);\n\tkref_put(&wdata->refcount, cifs_writedata_release);\n}\n\nstruct cifs_writedata *\ncifs_writedata_alloc(unsigned int nr_pages)\n{\n\tstruct cifs_writedata *wdata;\n\n\t/* this would overflow */\n\tif (nr_pages == 0) {\n\t\tcERROR(1, \"%s: called with nr_pages == 0!\", __func__);\n\t\treturn NULL;\n\t}\n\n\t/* writedata + number of page pointers */\n\twdata = kzalloc(sizeof(*wdata) +\n\t\t\tsizeof(struct page *) * (nr_pages - 1), GFP_NOFS);\n\tif (wdata != NULL) {\n\t\tINIT_WORK(&wdata->work, cifs_writev_complete);\n\t\tkref_init(&wdata->refcount);\n\t}\n\treturn wdata;\n}\n\n/*\n * Check the midState and signature on received buffer (if any), and queue the\n * workqueue completion task.\n */\nstatic void\ncifs_writev_callback(struct mid_q_entry *mid)\n{\n\tstruct cifs_writedata *wdata = mid->callback_data;\n\tstruct cifs_tcon *tcon = tlink_tcon(wdata->cfile->tlink);\n\tunsigned int written;\n\tWRITE_RSP *smb = (WRITE_RSP *)mid->resp_buf;\n\n\tswitch (mid->midState) {\n\tcase MID_RESPONSE_RECEIVED:\n\t\twdata->result = cifs_check_receive(mid, tcon->ses->server, 0);\n\t\tif (wdata->result != 0)\n\t\t\tbreak;\n\n\t\twritten = le16_to_cpu(smb->CountHigh);\n\t\twritten <<= 16;\n\t\twritten += le16_to_cpu(smb->Count);\n\t\t/*\n\t\t * Mask off high 16 bits when bytes written as returned\n\t\t * by the server is greater than bytes requested by the\n\t\t * client. OS/2 servers are known to set incorrect\n\t\t * CountHigh values.\n\t\t */\n\t\tif (written > wdata->bytes)\n\t\t\twritten &= 0xFFFF;\n\n\t\tif (written < wdata->bytes)\n\t\t\twdata->result = -ENOSPC;\n\t\telse\n\t\t\twdata->bytes = written;\n\t\tbreak;\n\tcase MID_REQUEST_SUBMITTED:\n\tcase MID_RETRY_NEEDED:\n\t\twdata->result = -EAGAIN;\n\t\tbreak;\n\tdefault:\n\t\twdata->result = -EIO;\n\t\tbreak;\n\t}\n\n\tqueue_work(system_nrt_wq, &wdata->work);\n\tDeleteMidQEntry(mid);\n\tatomic_dec(&tcon->ses->server->inFlight);\n\twake_up(&tcon->ses->server->request_q);\n}\n\n/* cifs_async_writev - send an async write, and set up mid to handle result */\nint\ncifs_async_writev(struct cifs_writedata *wdata)\n{\n\tint i, rc = -EACCES;\n\tWRITE_REQ *smb = NULL;\n\tint wct;\n\tstruct cifs_tcon *tcon = tlink_tcon(wdata->cfile->tlink);\n\tstruct inode *inode = wdata->cfile->dentry->d_inode;\n\tstruct kvec *iov = NULL;\n\n\tif (tcon->ses->capabilities & CAP_LARGE_FILES) {\n\t\twct = 14;\n\t} else {\n\t\twct = 12;\n\t\tif (wdata->offset >> 32 > 0) {\n\t\t\t/* can not handle big offset for old srv */\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\trc = small_smb_init(SMB_COM_WRITE_ANDX, wct, tcon, (void **)&smb);\n\tif (rc)\n\t\tgoto async_writev_out;\n\n\t/* 1 iov per page + 1 for header */\n\tiov = kzalloc((wdata->nr_pages + 1) * sizeof(*iov), GFP_NOFS);\n\tif (iov == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto async_writev_out;\n\t}\n\n\tsmb->hdr.Pid = cpu_to_le16((__u16)wdata->cfile->pid);\n\tsmb->hdr.PidHigh = cpu_to_le16((__u16)(wdata->cfile->pid >> 16));\n\n\tsmb->AndXCommand = 0xFF;\t/* none */\n\tsmb->Fid = wdata->cfile->netfid;\n\tsmb->OffsetLow = cpu_to_le32(wdata->offset & 0xFFFFFFFF);\n\tif (wct == 14)\n\t\tsmb->OffsetHigh = cpu_to_le32(wdata->offset >> 32);\n\tsmb->Reserved = 0xFFFFFFFF;\n\tsmb->WriteMode = 0;\n\tsmb->Remaining = 0;\n\n\tsmb->DataOffset =\n\t    cpu_to_le16(offsetof(struct smb_com_write_req, Data) - 4);\n\n\t/* 4 for RFC1001 length + 1 for BCC */\n\tiov[0].iov_len = be32_to_cpu(smb->hdr.smb_buf_length) + 4 + 1;\n\tiov[0].iov_base = smb;\n\n\t/* marshal up the pages into iov array */\n\twdata->bytes = 0;\n\tfor (i = 0; i < wdata->nr_pages; i++) {\n\t\tiov[i + 1].iov_len = min(inode->i_size -\n\t\t\t\t      page_offset(wdata->pages[i]),\n\t\t\t\t\t(loff_t)PAGE_CACHE_SIZE);\n\t\tiov[i + 1].iov_base = kmap(wdata->pages[i]);\n\t\twdata->bytes += iov[i + 1].iov_len;\n\t}\n\n\tcFYI(1, \"async write at %llu %u bytes\", wdata->offset, wdata->bytes);\n\n\tsmb->DataLengthLow = cpu_to_le16(wdata->bytes & 0xFFFF);\n\tsmb->DataLengthHigh = cpu_to_le16(wdata->bytes >> 16);\n\n\tif (wct == 14) {\n\t\tinc_rfc1001_len(&smb->hdr, wdata->bytes + 1);\n\t\tput_bcc(wdata->bytes + 1, &smb->hdr);\n\t} else {\n\t\t/* wct == 12 */\n\t\tstruct smb_com_writex_req *smbw =\n\t\t\t\t(struct smb_com_writex_req *)smb;\n\t\tinc_rfc1001_len(&smbw->hdr, wdata->bytes + 5);\n\t\tput_bcc(wdata->bytes + 5, &smbw->hdr);\n\t\tiov[0].iov_len += 4; /* pad bigger by four bytes */\n\t}\n\n\tkref_get(&wdata->refcount);\n\trc = cifs_call_async(tcon->ses->server, iov, wdata->nr_pages + 1,\n\t\t\t     cifs_writev_callback, wdata, false);\n\n\tif (rc == 0)\n\t\tcifs_stats_inc(&tcon->num_writes);\n\telse\n\t\tkref_put(&wdata->refcount, cifs_writedata_release);\n\n\t/* send is done, unmap pages */\n\tfor (i = 0; i < wdata->nr_pages; i++)\n\t\tkunmap(wdata->pages[i]);\n\nasync_writev_out:\n\tcifs_small_buf_release(smb);\n\tkfree(iov);\n\treturn rc;\n}\n\nint\nCIFSSMBWrite2(const int xid, struct cifs_io_parms *io_parms,\n\t      unsigned int *nbytes, struct kvec *iov, int n_vec,\n\t      const int long_op)\n{\n\tint rc = -EACCES;\n\tWRITE_REQ *pSMB = NULL;\n\tint wct;\n\tint smb_hdr_len;\n\tint resp_buf_type = 0;\n\t__u32 pid = io_parms->pid;\n\t__u16 netfid = io_parms->netfid;\n\t__u64 offset = io_parms->offset;\n\tstruct cifs_tcon *tcon = io_parms->tcon;\n\tunsigned int count = io_parms->length;\n\n\t*nbytes = 0;\n\n\tcFYI(1, \"write2 at %lld %d bytes\", (long long)offset, count);\n\n\tif (tcon->ses->capabilities & CAP_LARGE_FILES) {\n\t\twct = 14;\n\t} else {\n\t\twct = 12;\n\t\tif ((offset >> 32) > 0) {\n\t\t\t/* can not handle big offset for old srv */\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\trc = small_smb_init(SMB_COM_WRITE_ANDX, wct, tcon, (void **) &pSMB);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid >> 16));\n\n\t/* tcon and ses pointer are checked in smb_init */\n\tif (tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\tpSMB->AndXCommand = 0xFF;\t/* none */\n\tpSMB->Fid = netfid;\n\tpSMB->OffsetLow = cpu_to_le32(offset & 0xFFFFFFFF);\n\tif (wct == 14)\n\t\tpSMB->OffsetHigh = cpu_to_le32(offset >> 32);\n\tpSMB->Reserved = 0xFFFFFFFF;\n\tpSMB->WriteMode = 0;\n\tpSMB->Remaining = 0;\n\n\tpSMB->DataOffset =\n\t    cpu_to_le16(offsetof(struct smb_com_write_req, Data) - 4);\n\n\tpSMB->DataLengthLow = cpu_to_le16(count & 0xFFFF);\n\tpSMB->DataLengthHigh = cpu_to_le16(count >> 16);\n\t/* header + 1 byte pad */\n\tsmb_hdr_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 1;\n\tif (wct == 14)\n\t\tinc_rfc1001_len(pSMB, count + 1);\n\telse /* wct == 12 */\n\t\tinc_rfc1001_len(pSMB, count + 5); /* smb data starts later */\n\tif (wct == 14)\n\t\tpSMB->ByteCount = cpu_to_le16(count + 1);\n\telse /* wct == 12 */ /* bigger pad, smaller smb hdr, keep offset ok */ {\n\t\tstruct smb_com_writex_req *pSMBW =\n\t\t\t\t(struct smb_com_writex_req *)pSMB;\n\t\tpSMBW->ByteCount = cpu_to_le16(count + 5);\n\t}\n\tiov[0].iov_base = pSMB;\n\tif (wct == 14)\n\t\tiov[0].iov_len = smb_hdr_len + 4;\n\telse /* wct == 12 pad bigger by four bytes */\n\t\tiov[0].iov_len = smb_hdr_len + 8;\n\n\n\trc = SendReceive2(xid, tcon->ses, iov, n_vec + 1, &resp_buf_type,\n\t\t\t  long_op);\n\tcifs_stats_inc(&tcon->num_writes);\n\tif (rc) {\n\t\tcFYI(1, \"Send error Write2 = %d\", rc);\n\t} else if (resp_buf_type == 0) {\n\t\t/* presumably this can not happen, but best to be safe */\n\t\trc = -EIO;\n\t} else {\n\t\tWRITE_RSP *pSMBr = (WRITE_RSP *)iov[0].iov_base;\n\t\t*nbytes = le16_to_cpu(pSMBr->CountHigh);\n\t\t*nbytes = (*nbytes) << 16;\n\t\t*nbytes += le16_to_cpu(pSMBr->Count);\n\n\t\t/*\n\t\t * Mask off high 16 bits when bytes written as returned by the\n\t\t * server is greater than bytes requested by the client. OS/2\n\t\t * servers are known to set incorrect CountHigh values.\n\t\t */\n\t\tif (*nbytes > count)\n\t\t\t*nbytes &= 0xFFFF;\n\t}\n\n/*\tcifs_small_buf_release(pSMB); */ /* Freed earlier now in SendReceive2 */\n\tif (resp_buf_type == CIFS_SMALL_BUFFER)\n\t\tcifs_small_buf_release(iov[0].iov_base);\n\telse if (resp_buf_type == CIFS_LARGE_BUFFER)\n\t\tcifs_buf_release(iov[0].iov_base);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\n\treturn rc;\n}\n\n\nint\nCIFSSMBLock(const int xid, struct cifs_tcon *tcon,\n\t    const __u16 smb_file_id, const __u64 len,\n\t    const __u64 offset, const __u32 numUnlock,\n\t    const __u32 numLock, const __u8 lockType,\n\t    const bool waitFlag, const __u8 oplock_level)\n{\n\tint rc = 0;\n\tLOCK_REQ *pSMB = NULL;\n/*\tLOCK_RSP *pSMBr = NULL; */ /* No response data other than rc to parse */\n\tint bytes_returned;\n\tint timeout = 0;\n\t__u16 count;\n\n\tcFYI(1, \"CIFSSMBLock timeout %d numLock %d\", (int)waitFlag, numLock);\n\trc = small_smb_init(SMB_COM_LOCKING_ANDX, 8, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tif (lockType == LOCKING_ANDX_OPLOCK_RELEASE) {\n\t\ttimeout = CIFS_ASYNC_OP; /* no response expected */\n\t\tpSMB->Timeout = 0;\n\t} else if (waitFlag) {\n\t\ttimeout = CIFS_BLOCKING_OP; /* blocking operation, no timeout */\n\t\tpSMB->Timeout = cpu_to_le32(-1);/* blocking - do not time out */\n\t} else {\n\t\tpSMB->Timeout = 0;\n\t}\n\n\tpSMB->NumberOfLocks = cpu_to_le16(numLock);\n\tpSMB->NumberOfUnlocks = cpu_to_le16(numUnlock);\n\tpSMB->LockType = lockType;\n\tpSMB->OplockLevel = oplock_level;\n\tpSMB->AndXCommand = 0xFF;\t/* none */\n\tpSMB->Fid = smb_file_id; /* netfid stays le */\n\n\tif ((numLock != 0) || (numUnlock != 0)) {\n\t\tpSMB->Locks[0].Pid = cpu_to_le16(current->tgid);\n\t\t/* BB where to store pid high? */\n\t\tpSMB->Locks[0].LengthLow = cpu_to_le32((u32)len);\n\t\tpSMB->Locks[0].LengthHigh = cpu_to_le32((u32)(len>>32));\n\t\tpSMB->Locks[0].OffsetLow = cpu_to_le32((u32)offset);\n\t\tpSMB->Locks[0].OffsetHigh = cpu_to_le32((u32)(offset>>32));\n\t\tcount = sizeof(LOCKING_ANDX_RANGE);\n\t} else {\n\t\t/* oplock break */\n\t\tcount = 0;\n\t}\n\tinc_rfc1001_len(pSMB, count);\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\tif (waitFlag) {\n\t\trc = SendReceiveBlockingLock(xid, tcon, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *) pSMB, &bytes_returned);\n\t\tcifs_small_buf_release(pSMB);\n\t} else {\n\t\trc = SendReceiveNoRsp(xid, tcon->ses, (struct smb_hdr *)pSMB,\n\t\t\t\t      timeout);\n\t\t/* SMB buffer freed by function above */\n\t}\n\tcifs_stats_inc(&tcon->num_locks);\n\tif (rc)\n\t\tcFYI(1, \"Send error in Lock = %d\", rc);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\tsince file handle passed in no longer valid */\n\treturn rc;\n}\n\nint\nCIFSSMBPosixLock(const int xid, struct cifs_tcon *tcon,\n\t\tconst __u16 smb_file_id, const int get_flag, const __u64 len,\n\t\tstruct file_lock *pLockData, const __u16 lock_type,\n\t\tconst bool waitFlag)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tstruct smb_com_transaction2_sfi_rsp *pSMBr = NULL;\n\tstruct cifs_posix_lock *parm_data;\n\tint rc = 0;\n\tint timeout = 0;\n\tint bytes_returned = 0;\n\tint resp_buf_type = 0;\n\t__u16 params, param_offset, offset, byte_count, count;\n\tstruct kvec iov[1];\n\n\tcFYI(1, \"Posix Lock\");\n\n\tif (pLockData == NULL)\n\t\treturn -EINVAL;\n\n\trc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tpSMBr = (struct smb_com_transaction2_sfi_rsp *)pSMB;\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tcount = sizeof(struct cifs_posix_lock);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(1000); /* BB find max SMB from sess */\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tif (get_flag)\n\t\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FILE_INFORMATION);\n\telse\n\t\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tparm_data = (struct cifs_posix_lock *)\n\t\t\t(((char *) &pSMB->hdr.Protocol) + offset);\n\n\tparm_data->lock_type = cpu_to_le16(lock_type);\n\tif (waitFlag) {\n\t\ttimeout = CIFS_BLOCKING_OP; /* blocking operation, no timeout */\n\t\tparm_data->lock_flags = cpu_to_le16(1);\n\t\tpSMB->Timeout = cpu_to_le32(-1);\n\t} else\n\t\tpSMB->Timeout = 0;\n\n\tparm_data->pid = cpu_to_le32(current->tgid);\n\tparm_data->start = cpu_to_le64(pLockData->fl_start);\n\tparm_data->length = cpu_to_le64(len);  /* normalize negative numbers */\n\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->Fid = smb_file_id;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_POSIX_LOCK);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\tif (waitFlag) {\n\t\trc = SendReceiveBlockingLock(xid, tcon, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *) pSMBr, &bytes_returned);\n\t} else {\n\t\tiov[0].iov_base = (char *)pSMB;\n\t\tiov[0].iov_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 4;\n\t\trc = SendReceive2(xid, tcon->ses, iov, 1 /* num iovecs */,\n\t\t\t\t&resp_buf_type, timeout);\n\t\tpSMB = NULL; /* request buf already freed by SendReceive2. Do\n\t\t\t\tnot try to free it twice below on exit */\n\t\tpSMBr = (struct smb_com_transaction2_sfi_rsp *)iov[0].iov_base;\n\t}\n\n\tif (rc) {\n\t\tcFYI(1, \"Send error in Posix Lock = %d\", rc);\n\t} else if (get_flag) {\n\t\t/* lock structure can be returned on get */\n\t\t__u16 data_offset;\n\t\t__u16 data_count;\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < sizeof(*parm_data)) {\n\t\t\trc = -EIO;      /* bad smb */\n\t\t\tgoto plk_err_exit;\n\t\t}\n\t\tdata_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\tdata_count  = le16_to_cpu(pSMBr->t2.DataCount);\n\t\tif (data_count < sizeof(struct cifs_posix_lock)) {\n\t\t\trc = -EIO;\n\t\t\tgoto plk_err_exit;\n\t\t}\n\t\tparm_data = (struct cifs_posix_lock *)\n\t\t\t((char *)&pSMBr->hdr.Protocol + data_offset);\n\t\tif (parm_data->lock_type == __constant_cpu_to_le16(CIFS_UNLCK))\n\t\t\tpLockData->fl_type = F_UNLCK;\n\t\telse {\n\t\t\tif (parm_data->lock_type ==\n\t\t\t\t\t__constant_cpu_to_le16(CIFS_RDLCK))\n\t\t\t\tpLockData->fl_type = F_RDLCK;\n\t\t\telse if (parm_data->lock_type ==\n\t\t\t\t\t__constant_cpu_to_le16(CIFS_WRLCK))\n\t\t\t\tpLockData->fl_type = F_WRLCK;\n\n\t\t\tpLockData->fl_start = le64_to_cpu(parm_data->start);\n\t\t\tpLockData->fl_end = pLockData->fl_start +\n\t\t\t\t\tle64_to_cpu(parm_data->length) - 1;\n\t\t\tpLockData->fl_pid = le32_to_cpu(parm_data->pid);\n\t\t}\n\t}\n\nplk_err_exit:\n\tif (pSMB)\n\t\tcifs_small_buf_release(pSMB);\n\n\tif (resp_buf_type == CIFS_SMALL_BUFFER)\n\t\tcifs_small_buf_release(iov[0].iov_base);\n\telse if (resp_buf_type == CIFS_LARGE_BUFFER)\n\t\tcifs_buf_release(iov[0].iov_base);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t   since file handle passed in no longer valid */\n\n\treturn rc;\n}\n\n\nint\nCIFSSMBClose(const int xid, struct cifs_tcon *tcon, int smb_file_id)\n{\n\tint rc = 0;\n\tCLOSE_REQ *pSMB = NULL;\n\tcFYI(1, \"In CIFSSMBClose\");\n\n/* do not retry on dead session on close */\n\trc = small_smb_init(SMB_COM_CLOSE, 3, tcon, (void **) &pSMB);\n\tif (rc == -EAGAIN)\n\t\treturn 0;\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->FileID = (__u16) smb_file_id;\n\tpSMB->LastWriteTime = 0xFFFFFFFF;\n\tpSMB->ByteCount = 0;\n\trc = SendReceiveNoRsp(xid, tcon->ses, (struct smb_hdr *) pSMB, 0);\n\tcifs_stats_inc(&tcon->num_closes);\n\tif (rc) {\n\t\tif (rc != -EINTR) {\n\t\t\t/* EINTR is expected when user ctl-c to kill app */\n\t\t\tcERROR(1, \"Send error in Close = %d\", rc);\n\t\t}\n\t}\n\n\t/* Since session is dead, file will be closed on server already */\n\tif (rc == -EAGAIN)\n\t\trc = 0;\n\n\treturn rc;\n}\n\nint\nCIFSSMBFlush(const int xid, struct cifs_tcon *tcon, int smb_file_id)\n{\n\tint rc = 0;\n\tFLUSH_REQ *pSMB = NULL;\n\tcFYI(1, \"In CIFSSMBFlush\");\n\n\trc = small_smb_init(SMB_COM_FLUSH, 1, tcon, (void **) &pSMB);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->FileID = (__u16) smb_file_id;\n\tpSMB->ByteCount = 0;\n\trc = SendReceiveNoRsp(xid, tcon->ses, (struct smb_hdr *) pSMB, 0);\n\tcifs_stats_inc(&tcon->num_flushes);\n\tif (rc)\n\t\tcERROR(1, \"Send error in Flush = %d\", rc);\n\n\treturn rc;\n}\n\nint\nCIFSSMBRename(const int xid, struct cifs_tcon *tcon,\n\t      const char *fromName, const char *toName,\n\t      const struct nls_table *nls_codepage, int remap)\n{\n\tint rc = 0;\n\tRENAME_REQ *pSMB = NULL;\n\tRENAME_RSP *pSMBr = NULL;\n\tint bytes_returned;\n\tint name_len, name_len2;\n\t__u16 count;\n\n\tcFYI(1, \"In CIFSSMBRename\");\nrenameRetry:\n\trc = smb_init(SMB_COM_RENAME, 1, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->BufferFormat = 0x04;\n\tpSMB->SearchAttributes =\n\t    cpu_to_le16(ATTR_READONLY | ATTR_HIDDEN | ATTR_SYSTEM |\n\t\t\tATTR_DIRECTORY);\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUCS((__le16 *) pSMB->OldFileName, fromName,\n\t\t\t\t     PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t\tpSMB->OldFileName[name_len] = 0x04;\t/* pad */\n\t/* protocol requires ASCII signature byte on Unicode string */\n\t\tpSMB->OldFileName[name_len + 1] = 0x00;\n\t\tname_len2 =\n\t\t    cifsConvertToUCS((__le16 *)&pSMB->OldFileName[name_len + 2],\n\t\t\t\t     toName, PATH_MAX, nls_codepage, remap);\n\t\tname_len2 += 1 /* trailing null */  + 1 /* Signature word */ ;\n\t\tname_len2 *= 2;\t/* convert to bytes */\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(fromName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->OldFileName, fromName, name_len);\n\t\tname_len2 = strnlen(toName, PATH_MAX);\n\t\tname_len2++;\t/* trailing null */\n\t\tpSMB->OldFileName[name_len] = 0x04;  /* 2nd buffer format */\n\t\tstrncpy(&pSMB->OldFileName[name_len + 1], toName, name_len2);\n\t\tname_len2++;\t/* trailing null */\n\t\tname_len2++;\t/* signature byte */\n\t}\n\n\tcount = 1 /* 1st signature byte */  + name_len + name_len2;\n\tinc_rfc1001_len(pSMB, count);\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->num_renames);\n\tif (rc)\n\t\tcFYI(1, \"Send error in rename = %d\", rc);\n\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto renameRetry;\n\n\treturn rc;\n}\n\nint CIFSSMBRenameOpenFile(const int xid, struct cifs_tcon *pTcon,\n\t\tint netfid, const char *target_name,\n\t\tconst struct nls_table *nls_codepage, int remap)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tstruct smb_com_transaction2_sfi_rsp *pSMBr = NULL;\n\tstruct set_file_rename *rename_info;\n\tchar *data_offset;\n\tchar dummy_string[30];\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tint len_of_str;\n\t__u16 params, param_offset, offset, count, byte_count;\n\n\tcFYI(1, \"Rename to File by handle\");\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, pTcon, (void **) &pSMB,\n\t\t\t(void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tdata_offset = (char *) (&pSMB->hdr.Protocol) + offset;\n\trename_info = (struct set_file_rename *) data_offset;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(1000); /* BB find max SMB from sess */\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3 /* pad */  + params;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\t/* construct random name \".cifs_tmp<inodenum><mid>\" */\n\trename_info->overwrite = cpu_to_le32(1);\n\trename_info->root_fid  = 0;\n\t/* unicode only call */\n\tif (target_name == NULL) {\n\t\tsprintf(dummy_string, \"cifs%x\", pSMB->hdr.Mid);\n\t\tlen_of_str = cifsConvertToUCS((__le16 *)rename_info->target_name,\n\t\t\t\t\tdummy_string, 24, nls_codepage, remap);\n\t} else {\n\t\tlen_of_str = cifsConvertToUCS((__le16 *)rename_info->target_name,\n\t\t\t\t\ttarget_name, PATH_MAX, nls_codepage,\n\t\t\t\t\tremap);\n\t}\n\trename_info->target_name_len = cpu_to_le32(2 * len_of_str);\n\tcount = 12 /* sizeof(struct set_file_rename) */ + (2 * len_of_str);\n\tbyte_count += count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->Fid = netfid;\n\tpSMB->InformationLevel =\n\t\tcpu_to_le16(SMB_SET_FILE_RENAME_INFORMATION);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, pTcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&pTcon->num_t2renames);\n\tif (rc)\n\t\tcFYI(1, \"Send error in Rename (by file handle) = %d\", rc);\n\n\tcifs_buf_release(pSMB);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\n\treturn rc;\n}\n\nint\nCIFSSMBCopy(const int xid, struct cifs_tcon *tcon, const char *fromName,\n\t    const __u16 target_tid, const char *toName, const int flags,\n\t    const struct nls_table *nls_codepage, int remap)\n{\n\tint rc = 0;\n\tCOPY_REQ *pSMB = NULL;\n\tCOPY_RSP *pSMBr = NULL;\n\tint bytes_returned;\n\tint name_len, name_len2;\n\t__u16 count;\n\n\tcFYI(1, \"In CIFSSMBCopy\");\ncopyRetry:\n\trc = smb_init(SMB_COM_COPY, 1, tcon, (void **) &pSMB,\n\t\t\t(void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->BufferFormat = 0x04;\n\tpSMB->Tid2 = target_tid;\n\n\tpSMB->Flags = cpu_to_le16(flags & COPY_TREE);\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len = cifsConvertToUCS((__le16 *) pSMB->OldFileName,\n\t\t\t\t\t    fromName, PATH_MAX, nls_codepage,\n\t\t\t\t\t    remap);\n\t\tname_len++;     /* trailing null */\n\t\tname_len *= 2;\n\t\tpSMB->OldFileName[name_len] = 0x04;     /* pad */\n\t\t/* protocol requires ASCII signature byte on Unicode string */\n\t\tpSMB->OldFileName[name_len + 1] = 0x00;\n\t\tname_len2 =\n\t\t    cifsConvertToUCS((__le16 *)&pSMB->OldFileName[name_len + 2],\n\t\t\t\ttoName, PATH_MAX, nls_codepage, remap);\n\t\tname_len2 += 1 /* trailing null */  + 1 /* Signature word */ ;\n\t\tname_len2 *= 2; /* convert to bytes */\n\t} else { \t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(fromName, PATH_MAX);\n\t\tname_len++;     /* trailing null */\n\t\tstrncpy(pSMB->OldFileName, fromName, name_len);\n\t\tname_len2 = strnlen(toName, PATH_MAX);\n\t\tname_len2++;    /* trailing null */\n\t\tpSMB->OldFileName[name_len] = 0x04;  /* 2nd buffer format */\n\t\tstrncpy(&pSMB->OldFileName[name_len + 1], toName, name_len2);\n\t\tname_len2++;    /* trailing null */\n\t\tname_len2++;    /* signature byte */\n\t}\n\n\tcount = 1 /* 1st signature byte */  + name_len + name_len2;\n\tinc_rfc1001_len(pSMB, count);\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcFYI(1, \"Send error in copy = %d with %d files copied\",\n\t\t\trc, le16_to_cpu(pSMBr->CopyCount));\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto copyRetry;\n\n\treturn rc;\n}\n\nint\nCIFSUnixCreateSymLink(const int xid, struct cifs_tcon *tcon,\n\t\t      const char *fromName, const char *toName,\n\t\t      const struct nls_table *nls_codepage)\n{\n\tTRANSACTION2_SPI_REQ *pSMB = NULL;\n\tTRANSACTION2_SPI_RSP *pSMBr = NULL;\n\tchar *data_offset;\n\tint name_len;\n\tint name_len_target;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, param_offset, offset, byte_count;\n\n\tcFYI(1, \"In Symlink Unix style\");\ncreateSymLinkRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifs_strtoUCS((__le16 *) pSMB->FileName, fromName, PATH_MAX\n\t\t\t\t  /* find define for this maxpathcomponent */\n\t\t\t\t  , nls_codepage);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(fromName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, fromName, name_len);\n\t}\n\tparams = 6 + name_len;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\n\tdata_offset = (char *) (&pSMB->hdr.Protocol) + offset;\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len_target =\n\t\t    cifs_strtoUCS((__le16 *) data_offset, toName, PATH_MAX\n\t\t\t\t  /* find define for this maxpathcomponent */\n\t\t\t\t  , nls_codepage);\n\t\tname_len_target++;\t/* trailing null */\n\t\tname_len_target *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len_target = strnlen(toName, PATH_MAX);\n\t\tname_len_target++;\t/* trailing null */\n\t\tstrncpy(data_offset, toName, name_len_target);\n\t}\n\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max on data count below from sess */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + name_len_target;\n\tpSMB->DataCount = cpu_to_le16(name_len_target);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_UNIX_LINK);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->num_symlinks);\n\tif (rc)\n\t\tcFYI(1, \"Send error in SetPathInfo create symlink = %d\", rc);\n\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto createSymLinkRetry;\n\n\treturn rc;\n}\n\nint\nCIFSUnixCreateHardLink(const int xid, struct cifs_tcon *tcon,\n\t\t       const char *fromName, const char *toName,\n\t\t       const struct nls_table *nls_codepage, int remap)\n{\n\tTRANSACTION2_SPI_REQ *pSMB = NULL;\n\tTRANSACTION2_SPI_RSP *pSMBr = NULL;\n\tchar *data_offset;\n\tint name_len;\n\tint name_len_target;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, param_offset, offset, byte_count;\n\n\tcFYI(1, \"In Create Hard link Unix style\");\ncreateHardLinkRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len = cifsConvertToUCS((__le16 *) pSMB->FileName, toName,\n\t\t\t\t\t    PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(toName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, toName, name_len);\n\t}\n\tparams = 6 + name_len;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\n\tdata_offset = (char *) (&pSMB->hdr.Protocol) + offset;\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len_target =\n\t\t    cifsConvertToUCS((__le16 *) data_offset, fromName, PATH_MAX,\n\t\t\t\t     nls_codepage, remap);\n\t\tname_len_target++;\t/* trailing null */\n\t\tname_len_target *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len_target = strnlen(fromName, PATH_MAX);\n\t\tname_len_target++;\t/* trailing null */\n\t\tstrncpy(data_offset, fromName, name_len_target);\n\t}\n\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max on data count below from sess*/\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + name_len_target;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->DataCount = cpu_to_le16(name_len_target);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_UNIX_HLINK);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->num_hardlinks);\n\tif (rc)\n\t\tcFYI(1, \"Send error in SetPathInfo (hard link) = %d\", rc);\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto createHardLinkRetry;\n\n\treturn rc;\n}\n\nint\nCIFSCreateHardLink(const int xid, struct cifs_tcon *tcon,\n\t\t   const char *fromName, const char *toName,\n\t\t   const struct nls_table *nls_codepage, int remap)\n{\n\tint rc = 0;\n\tNT_RENAME_REQ *pSMB = NULL;\n\tRENAME_RSP *pSMBr = NULL;\n\tint bytes_returned;\n\tint name_len, name_len2;\n\t__u16 count;\n\n\tcFYI(1, \"In CIFSCreateHardLink\");\nwinCreateHardLinkRetry:\n\n\trc = smb_init(SMB_COM_NT_RENAME, 4, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->SearchAttributes =\n\t    cpu_to_le16(ATTR_READONLY | ATTR_HIDDEN | ATTR_SYSTEM |\n\t\t\tATTR_DIRECTORY);\n\tpSMB->Flags = cpu_to_le16(CREATE_HARD_LINK);\n\tpSMB->ClusterCount = 0;\n\n\tpSMB->BufferFormat = 0x04;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUCS((__le16 *) pSMB->OldFileName, fromName,\n\t\t\t\t     PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\n\t\t/* protocol specifies ASCII buffer format (0x04) for unicode */\n\t\tpSMB->OldFileName[name_len] = 0x04;\n\t\tpSMB->OldFileName[name_len + 1] = 0x00; /* pad */\n\t\tname_len2 =\n\t\t    cifsConvertToUCS((__le16 *)&pSMB->OldFileName[name_len + 2],\n\t\t\t\t     toName, PATH_MAX, nls_codepage, remap);\n\t\tname_len2 += 1 /* trailing null */  + 1 /* Signature word */ ;\n\t\tname_len2 *= 2;\t/* convert to bytes */\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(fromName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->OldFileName, fromName, name_len);\n\t\tname_len2 = strnlen(toName, PATH_MAX);\n\t\tname_len2++;\t/* trailing null */\n\t\tpSMB->OldFileName[name_len] = 0x04;\t/* 2nd buffer format */\n\t\tstrncpy(&pSMB->OldFileName[name_len + 1], toName, name_len2);\n\t\tname_len2++;\t/* trailing null */\n\t\tname_len2++;\t/* signature byte */\n\t}\n\n\tcount = 1 /* string type byte */  + name_len + name_len2;\n\tinc_rfc1001_len(pSMB, count);\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->num_hardlinks);\n\tif (rc)\n\t\tcFYI(1, \"Send error in hard link (NT rename) = %d\", rc);\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto winCreateHardLinkRetry;\n\n\treturn rc;\n}\n\nint\nCIFSSMBUnixQuerySymLink(const int xid, struct cifs_tcon *tcon,\n\t\t\tconst unsigned char *searchName, char **symlinkinfo,\n\t\t\tconst struct nls_table *nls_codepage)\n{\n/* SMB_QUERY_FILE_UNIX_LINK */\n\tTRANSACTION2_QPI_REQ *pSMB = NULL;\n\tTRANSACTION2_QPI_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 params, byte_count;\n\tchar *data_start;\n\n\tcFYI(1, \"In QPathSymLinkInfo (Unix) for path %s\", searchName);\n\nquerySymLinkRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifs_strtoUCS((__le16 *) pSMB->FileName, searchName,\n\t\t\t\t  PATH_MAX, nls_codepage);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(searchName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, searchName, name_len);\n\t}\n\n\tparams = 2 /* level */  + 4 /* rsrvd */  + name_len /* incl null */ ;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(CIFSMaxBufSize);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\tstruct smb_com_transaction2_qpi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_PATH_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_UNIX_LINK);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcFYI(1, \"Send error in QuerySymLinkInfo = %d\", rc);\n\t} else {\n\t\t/* decode response */\n\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\t\t/* BB also check enough total bytes returned */\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 2)\n\t\t\trc = -EIO;\n\t\telse {\n\t\t\tbool is_unicode;\n\t\t\tu16 count = le16_to_cpu(pSMBr->t2.DataCount);\n\n\t\t\tdata_start = ((char *) &pSMBr->hdr.Protocol) +\n\t\t\t\t\t   le16_to_cpu(pSMBr->t2.DataOffset);\n\n\t\t\tif (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE)\n\t\t\t\tis_unicode = true;\n\t\t\telse\n\t\t\t\tis_unicode = false;\n\n\t\t\t/* BB FIXME investigate remapping reserved chars here */\n\t\t\t*symlinkinfo = cifs_strndup_from_ucs(data_start, count,\n\t\t\t\t\t\t    is_unicode, nls_codepage);\n\t\t\tif (!*symlinkinfo)\n\t\t\t\trc = -ENOMEM;\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto querySymLinkRetry;\n\treturn rc;\n}\n\n#ifdef CONFIG_CIFS_SYMLINK_EXPERIMENTAL\n/*\n *\tRecent Windows versions now create symlinks more frequently\n *\tand they use the \"reparse point\" mechanism below.  We can of course\n *\tdo symlinks nicely to Samba and other servers which support the\n *\tCIFS Unix Extensions and we can also do SFU symlinks and \"client only\"\n *\t\"MF\" symlinks optionally, but for recent Windows we really need to\n *\treenable the code below and fix the cifs_symlink callers to handle this.\n *\tIn the interim this code has been moved to its own config option so\n *\tit is not compiled in by default until callers fixed up and more tested.\n */\nint\nCIFSSMBQueryReparseLinkInfo(const int xid, struct cifs_tcon *tcon,\n\t\t\tconst unsigned char *searchName,\n\t\t\tchar *symlinkinfo, const int buflen, __u16 fid,\n\t\t\tconst struct nls_table *nls_codepage)\n{\n\tint rc = 0;\n\tint bytes_returned;\n\tstruct smb_com_transaction_ioctl_req *pSMB;\n\tstruct smb_com_transaction_ioctl_rsp *pSMBr;\n\n\tcFYI(1, \"In Windows reparse style QueryLink for path %s\", searchName);\n\trc = smb_init(SMB_COM_NT_TRANSACT, 23, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->TotalParameterCount = 0 ;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le32(2);\n\t/* BB find exact data count max from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le32((tcon->ses->server->maxBuf -\n\t\t\t\t\t  MAX_CIFS_HDR_SIZE) & 0xFFFFFF00);\n\tpSMB->MaxSetupCount = 4;\n\tpSMB->Reserved = 0;\n\tpSMB->ParameterOffset = 0;\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 4;\n\tpSMB->SubCommand = cpu_to_le16(NT_TRANSACT_IOCTL);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->FunctionCode = cpu_to_le32(FSCTL_GET_REPARSE_POINT);\n\tpSMB->IsFsctl = 1; /* FSCTL */\n\tpSMB->IsRootFlag = 0;\n\tpSMB->Fid = fid; /* file handle always le */\n\tpSMB->ByteCount = 0;\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcFYI(1, \"Send error in QueryReparseLinkInfo = %d\", rc);\n\t} else {\t\t/* decode response */\n\t\t__u32 data_offset = le32_to_cpu(pSMBr->DataOffset);\n\t\t__u32 data_count = le32_to_cpu(pSMBr->DataCount);\n\t\tif (get_bcc(&pSMBr->hdr) < 2 || data_offset > 512) {\n\t\t\t/* BB also check enough total bytes returned */\n\t\t\trc = -EIO;\t/* bad smb */\n\t\t\tgoto qreparse_out;\n\t\t}\n\t\tif (data_count && (data_count < 2048)) {\n\t\t\tchar *end_of_smb = 2 /* sizeof byte count */ +\n\t\t\t       get_bcc(&pSMBr->hdr) + (char *)&pSMBr->ByteCount;\n\n\t\t\tstruct reparse_data *reparse_buf =\n\t\t\t\t\t\t(struct reparse_data *)\n\t\t\t\t\t\t((char *)&pSMBr->hdr.Protocol\n\t\t\t\t\t\t\t\t + data_offset);\n\t\t\tif ((char *)reparse_buf >= end_of_smb) {\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto qreparse_out;\n\t\t\t}\n\t\t\tif ((reparse_buf->LinkNamesBuf +\n\t\t\t\treparse_buf->TargetNameOffset +\n\t\t\t\treparse_buf->TargetNameLen) > end_of_smb) {\n\t\t\t\tcFYI(1, \"reparse buf beyond SMB\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto qreparse_out;\n\t\t\t}\n\n\t\t\tif (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\t\t\tcifs_from_ucs2(symlinkinfo, (__le16 *)\n\t\t\t\t\t\t(reparse_buf->LinkNamesBuf +\n\t\t\t\t\t\treparse_buf->TargetNameOffset),\n\t\t\t\t\t\tbuflen,\n\t\t\t\t\t\treparse_buf->TargetNameLen,\n\t\t\t\t\t\tnls_codepage, 0);\n\t\t\t} else { /* ASCII names */\n\t\t\t\tstrncpy(symlinkinfo,\n\t\t\t\t\treparse_buf->LinkNamesBuf +\n\t\t\t\t\treparse_buf->TargetNameOffset,\n\t\t\t\t\tmin_t(const int, buflen,\n\t\t\t\t\t   reparse_buf->TargetNameLen));\n\t\t\t}\n\t\t} else {\n\t\t\trc = -EIO;\n\t\t\tcFYI(1, \"Invalid return data count on \"\n\t\t\t\t \"get reparse info ioctl\");\n\t\t}\n\t\tsymlinkinfo[buflen] = 0; /* just in case so the caller\n\t\t\t\t\tdoes not go off the end of the buffer */\n\t\tcFYI(1, \"readlink result - %s\", symlinkinfo);\n\t}\n\nqreparse_out:\n\tcifs_buf_release(pSMB);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\n\treturn rc;\n}\n#endif /* CIFS_SYMLINK_EXPERIMENTAL */ /* BB temporarily unused */\n\n#ifdef CONFIG_CIFS_POSIX\n\n/*Convert an Access Control Entry from wire format to local POSIX xattr format*/\nstatic void cifs_convert_ace(posix_acl_xattr_entry *ace,\n\t\t\t     struct cifs_posix_ace *cifs_ace)\n{\n\t/* u8 cifs fields do not need le conversion */\n\tace->e_perm = cpu_to_le16(cifs_ace->cifs_e_perm);\n\tace->e_tag  = cpu_to_le16(cifs_ace->cifs_e_tag);\n\tace->e_id   = cpu_to_le32(le64_to_cpu(cifs_ace->cifs_uid));\n\t/* cFYI(1, \"perm %d tag %d id %d\",ace->e_perm,ace->e_tag,ace->e_id); */\n\n\treturn;\n}\n\n/* Convert ACL from CIFS POSIX wire format to local Linux POSIX ACL xattr */\nstatic int cifs_copy_posix_acl(char *trgt, char *src, const int buflen,\n\t\t\t       const int acl_type, const int size_of_data_area)\n{\n\tint size =  0;\n\tint i;\n\t__u16 count;\n\tstruct cifs_posix_ace *pACE;\n\tstruct cifs_posix_acl *cifs_acl = (struct cifs_posix_acl *)src;\n\tposix_acl_xattr_header *local_acl = (posix_acl_xattr_header *)trgt;\n\n\tif (le16_to_cpu(cifs_acl->version) != CIFS_ACL_VERSION)\n\t\treturn -EOPNOTSUPP;\n\n\tif (acl_type & ACL_TYPE_ACCESS) {\n\t\tcount = le16_to_cpu(cifs_acl->access_entry_count);\n\t\tpACE = &cifs_acl->ace_array[0];\n\t\tsize = sizeof(struct cifs_posix_acl);\n\t\tsize += sizeof(struct cifs_posix_ace) * count;\n\t\t/* check if we would go beyond end of SMB */\n\t\tif (size_of_data_area < size) {\n\t\t\tcFYI(1, \"bad CIFS POSIX ACL size %d vs. %d\",\n\t\t\t\tsize_of_data_area, size);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (acl_type & ACL_TYPE_DEFAULT) {\n\t\tcount = le16_to_cpu(cifs_acl->access_entry_count);\n\t\tsize = sizeof(struct cifs_posix_acl);\n\t\tsize += sizeof(struct cifs_posix_ace) * count;\n/* skip past access ACEs to get to default ACEs */\n\t\tpACE = &cifs_acl->ace_array[count];\n\t\tcount = le16_to_cpu(cifs_acl->default_entry_count);\n\t\tsize += sizeof(struct cifs_posix_ace) * count;\n\t\t/* check if we would go beyond end of SMB */\n\t\tif (size_of_data_area < size)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t/* illegal type */\n\t\treturn -EINVAL;\n\t}\n\n\tsize = posix_acl_xattr_size(count);\n\tif ((buflen == 0) || (local_acl == NULL)) {\n\t\t/* used to query ACL EA size */\n\t} else if (size > buflen) {\n\t\treturn -ERANGE;\n\t} else /* buffer big enough */ {\n\t\tlocal_acl->a_version = cpu_to_le32(POSIX_ACL_XATTR_VERSION);\n\t\tfor (i = 0; i < count ; i++) {\n\t\t\tcifs_convert_ace(&local_acl->a_entries[i], pACE);\n\t\t\tpACE++;\n\t\t}\n\t}\n\treturn size;\n}\n\nstatic __u16 convert_ace_to_cifs_ace(struct cifs_posix_ace *cifs_ace,\n\t\t\t\t     const posix_acl_xattr_entry *local_ace)\n{\n\t__u16 rc = 0; /* 0 = ACL converted ok */\n\n\tcifs_ace->cifs_e_perm = le16_to_cpu(local_ace->e_perm);\n\tcifs_ace->cifs_e_tag =  le16_to_cpu(local_ace->e_tag);\n\t/* BB is there a better way to handle the large uid? */\n\tif (local_ace->e_id == cpu_to_le32(-1)) {\n\t/* Probably no need to le convert -1 on any arch but can not hurt */\n\t\tcifs_ace->cifs_uid = cpu_to_le64(-1);\n\t} else\n\t\tcifs_ace->cifs_uid = cpu_to_le64(le32_to_cpu(local_ace->e_id));\n\t/*cFYI(1, \"perm %d tag %d id %d\",ace->e_perm,ace->e_tag,ace->e_id);*/\n\treturn rc;\n}\n\n/* Convert ACL from local Linux POSIX xattr to CIFS POSIX ACL wire format */\nstatic __u16 ACL_to_cifs_posix(char *parm_data, const char *pACL,\n\t\t\t       const int buflen, const int acl_type)\n{\n\t__u16 rc = 0;\n\tstruct cifs_posix_acl *cifs_acl = (struct cifs_posix_acl *)parm_data;\n\tposix_acl_xattr_header *local_acl = (posix_acl_xattr_header *)pACL;\n\tint count;\n\tint i;\n\n\tif ((buflen == 0) || (pACL == NULL) || (cifs_acl == NULL))\n\t\treturn 0;\n\n\tcount = posix_acl_xattr_count((size_t)buflen);\n\tcFYI(1, \"setting acl with %d entries from buf of length %d and \"\n\t\t\"version of %d\",\n\t\tcount, buflen, le32_to_cpu(local_acl->a_version));\n\tif (le32_to_cpu(local_acl->a_version) != 2) {\n\t\tcFYI(1, \"unknown POSIX ACL version %d\",\n\t\t     le32_to_cpu(local_acl->a_version));\n\t\treturn 0;\n\t}\n\tcifs_acl->version = cpu_to_le16(1);\n\tif (acl_type == ACL_TYPE_ACCESS)\n\t\tcifs_acl->access_entry_count = cpu_to_le16(count);\n\telse if (acl_type == ACL_TYPE_DEFAULT)\n\t\tcifs_acl->default_entry_count = cpu_to_le16(count);\n\telse {\n\t\tcFYI(1, \"unknown ACL type %d\", acl_type);\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < count; i++) {\n\t\trc = convert_ace_to_cifs_ace(&cifs_acl->ace_array[i],\n\t\t\t\t\t&local_acl->a_entries[i]);\n\t\tif (rc != 0) {\n\t\t\t/* ACE not converted */\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (rc == 0) {\n\t\trc = (__u16)(count * sizeof(struct cifs_posix_ace));\n\t\trc += sizeof(struct cifs_posix_acl);\n\t\t/* BB add check to make sure ACL does not overflow SMB */\n\t}\n\treturn rc;\n}\n\nint\nCIFSSMBGetPosixACL(const int xid, struct cifs_tcon *tcon,\n\t\t   const unsigned char *searchName,\n\t\t   char *acl_inf, const int buflen, const int acl_type,\n\t\t   const struct nls_table *nls_codepage, int remap)\n{\n/* SMB_QUERY_POSIX_ACL */\n\tTRANSACTION2_QPI_REQ *pSMB = NULL;\n\tTRANSACTION2_QPI_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 params, byte_count;\n\n\tcFYI(1, \"In GetPosixACL (Unix) for path %s\", searchName);\n\nqueryAclRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t(void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t\tcifsConvertToUCS((__le16 *) pSMB->FileName, searchName,\n\t\t\t\t\t PATH_MAX, nls_codepage, remap);\n\t\tname_len++;     /* trailing null */\n\t\tname_len *= 2;\n\t\tpSMB->FileName[name_len] = 0;\n\t\tpSMB->FileName[name_len+1] = 0;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(searchName, PATH_MAX);\n\t\tname_len++;     /* trailing null */\n\t\tstrncpy(pSMB->FileName, searchName, name_len);\n\t}\n\n\tparams = 2 /* level */  + 4 /* rsrvd */  + name_len /* incl null */ ;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max data count below from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(4000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset = cpu_to_le16(\n\t\toffsetof(struct smb_com_transaction2_qpi_req,\n\t\t\t InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_PATH_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_POSIX_ACL);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->num_acl_get);\n\tif (rc) {\n\t\tcFYI(1, \"Send error in Query POSIX ACL = %d\", rc);\n\t} else {\n\t\t/* decode response */\n\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\t\t/* BB also check enough total bytes returned */\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 2)\n\t\t\trc = -EIO;      /* bad smb */\n\t\telse {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\t__u16 count = le16_to_cpu(pSMBr->t2.DataCount);\n\t\t\trc = cifs_copy_posix_acl(acl_inf,\n\t\t\t\t(char *)&pSMBr->hdr.Protocol+data_offset,\n\t\t\t\tbuflen, acl_type, count);\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto queryAclRetry;\n\treturn rc;\n}\n\nint\nCIFSSMBSetPosixACL(const int xid, struct cifs_tcon *tcon,\n\t\t   const unsigned char *fileName,\n\t\t   const char *local_acl, const int buflen,\n\t\t   const int acl_type,\n\t\t   const struct nls_table *nls_codepage, int remap)\n{\n\tstruct smb_com_transaction2_spi_req *pSMB = NULL;\n\tstruct smb_com_transaction2_spi_rsp *pSMBr = NULL;\n\tchar *parm_data;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count, data_count, param_offset, offset;\n\n\tcFYI(1, \"In SetPosixACL (Unix) for path %s\", fileName);\nsetAclRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t\tcifsConvertToUCS((__le16 *) pSMB->FileName, fileName,\n\t\t\t\t      PATH_MAX, nls_codepage, remap);\n\t\tname_len++;     /* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(fileName, PATH_MAX);\n\t\tname_len++;     /* trailing null */\n\t\tstrncpy(pSMB->FileName, fileName, name_len);\n\t}\n\tparams = 6 + name_len;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find max SMB size from sess */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\tparm_data = ((char *) &pSMB->hdr.Protocol) + offset;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\n\t/* convert to on the wire format for POSIX ACL */\n\tdata_count = ACL_to_cifs_posix(parm_data, local_acl, buflen, acl_type);\n\n\tif (data_count == 0) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto setACLerrorExit;\n\t}\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_POSIX_ACL);\n\tbyte_count = 3 /* pad */  + params + data_count;\n\tpSMB->DataCount = cpu_to_le16(data_count);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcFYI(1, \"Set POSIX ACL returned %d\", rc);\n\nsetACLerrorExit:\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto setAclRetry;\n\treturn rc;\n}\n\n/* BB fix tabs in this function FIXME BB */\nint\nCIFSGetExtAttr(const int xid, struct cifs_tcon *tcon,\n\t       const int netfid, __u64 *pExtAttrBits, __u64 *pMask)\n{\n\tint rc = 0;\n\tstruct smb_t2_qfi_req *pSMB = NULL;\n\tstruct smb_t2_qfi_rsp *pSMBr = NULL;\n\tint bytes_returned;\n\t__u16 params, byte_count;\n\n\tcFYI(1, \"In GetExtAttr\");\n\tif (tcon == NULL)\n\t\treturn -ENODEV;\n\nGetExtAttrRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t\t(void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2 /* level */ + 2 /* fid */;\n\tpSMB->t2.TotalDataCount = 0;\n\tpSMB->t2.MaxParameterCount = cpu_to_le16(4);\n\t/* BB find exact max data count below from sess structure BB */\n\tpSMB->t2.MaxDataCount = cpu_to_le16(4000);\n\tpSMB->t2.MaxSetupCount = 0;\n\tpSMB->t2.Reserved = 0;\n\tpSMB->t2.Flags = 0;\n\tpSMB->t2.Timeout = 0;\n\tpSMB->t2.Reserved2 = 0;\n\tpSMB->t2.ParameterOffset = cpu_to_le16(offsetof(struct smb_t2_qfi_req,\n\t\t\t\t\t       Fid) - 4);\n\tpSMB->t2.DataCount = 0;\n\tpSMB->t2.DataOffset = 0;\n\tpSMB->t2.SetupCount = 1;\n\tpSMB->t2.Reserved3 = 0;\n\tpSMB->t2.SubCommand = cpu_to_le16(TRANS2_QUERY_FILE_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->t2.TotalParameterCount = cpu_to_le16(params);\n\tpSMB->t2.ParameterCount = pSMB->t2.TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_ATTR_FLAGS);\n\tpSMB->Pad = 0;\n\tpSMB->Fid = netfid;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->t2.ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcFYI(1, \"error %d in GetExtAttr\", rc);\n\t} else {\n\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\t\t/* BB also check enough total bytes returned */\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 2)\n\t\t\t/* If rc should we check for EOPNOSUPP and\n\t\t\t   disable the srvino flag? or in caller? */\n\t\t\trc = -EIO;      /* bad smb */\n\t\telse {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\t__u16 count = le16_to_cpu(pSMBr->t2.DataCount);\n\t\t\tstruct file_chattr_info *pfinfo;\n\t\t\t/* BB Do we need a cast or hash here ? */\n\t\t\tif (count != 16) {\n\t\t\t\tcFYI(1, \"Illegal size ret in GetExtAttr\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto GetExtAttrOut;\n\t\t\t}\n\t\t\tpfinfo = (struct file_chattr_info *)\n\t\t\t\t (data_offset + (char *) &pSMBr->hdr.Protocol);\n\t\t\t*pExtAttrBits = le64_to_cpu(pfinfo->mode);\n\t\t\t*pMask = le64_to_cpu(pfinfo->mask);\n\t\t}\n\t}\nGetExtAttrOut:\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto GetExtAttrRetry;\n\treturn rc;\n}\n\n#endif /* CONFIG_POSIX */\n\n#ifdef CONFIG_CIFS_ACL\n/*\n * Initialize NT TRANSACT SMB into small smb request buffer.  This assumes that\n * all NT TRANSACTS that we init here have total parm and data under about 400\n * bytes (to fit in small cifs buffer size), which is the case so far, it\n * easily fits. NB: Setup words themselves and ByteCount MaxSetupCount (size of\n * returned setup area) and MaxParameterCount (returned parms size) must be set\n * by caller\n */\nstatic int\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\n\t\t   const int parm_len, struct cifs_tcon *tcon,\n\t\t   void **ret_buf)\n{\n\tint rc;\n\t__u32 temp_offset;\n\tstruct smb_com_ntransact_req *pSMB;\n\n\trc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\n\t\t\t\t(void **)&pSMB);\n\tif (rc)\n\t\treturn rc;\n\t*ret_buf = (void *)pSMB;\n\tpSMB->Reserved = 0;\n\tpSMB->TotalParameterCount = cpu_to_le32(parm_len);\n\tpSMB->TotalDataCount  = 0;\n\tpSMB->MaxDataCount = cpu_to_le32((tcon->ses->server->maxBuf -\n\t\t\t\t\t  MAX_CIFS_HDR_SIZE) & 0xFFFFFF00);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->DataCount  = pSMB->TotalDataCount;\n\ttemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\n\t\t\t(setup_count * 2) - 4 /* for rfc1001 length itself */;\n\tpSMB->ParameterOffset = cpu_to_le32(temp_offset);\n\tpSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\n\tpSMB->SetupCount = setup_count; /* no need to le convert byte fields */\n\tpSMB->SubCommand = cpu_to_le16(sub_command);\n\treturn 0;\n}\n\nstatic int\nvalidate_ntransact(char *buf, char **ppparm, char **ppdata,\n\t\t   __u32 *pparmlen, __u32 *pdatalen)\n{\n\tchar *end_of_smb;\n\t__u32 data_count, data_offset, parm_count, parm_offset;\n\tstruct smb_com_ntransact_rsp *pSMBr;\n\tu16 bcc;\n\n\t*pdatalen = 0;\n\t*pparmlen = 0;\n\n\tif (buf == NULL)\n\t\treturn -EINVAL;\n\n\tpSMBr = (struct smb_com_ntransact_rsp *)buf;\n\n\tbcc = get_bcc(&pSMBr->hdr);\n\tend_of_smb = 2 /* sizeof byte count */ + bcc +\n\t\t\t(char *)&pSMBr->ByteCount;\n\n\tdata_offset = le32_to_cpu(pSMBr->DataOffset);\n\tdata_count = le32_to_cpu(pSMBr->DataCount);\n\tparm_offset = le32_to_cpu(pSMBr->ParameterOffset);\n\tparm_count = le32_to_cpu(pSMBr->ParameterCount);\n\n\t*ppparm = (char *)&pSMBr->hdr.Protocol + parm_offset;\n\t*ppdata = (char *)&pSMBr->hdr.Protocol + data_offset;\n\n\t/* should we also check that parm and data areas do not overlap? */\n\tif (*ppparm > end_of_smb) {\n\t\tcFYI(1, \"parms start after end of smb\");\n\t\treturn -EINVAL;\n\t} else if (parm_count + *ppparm > end_of_smb) {\n\t\tcFYI(1, \"parm end after end of smb\");\n\t\treturn -EINVAL;\n\t} else if (*ppdata > end_of_smb) {\n\t\tcFYI(1, \"data starts after end of smb\");\n\t\treturn -EINVAL;\n\t} else if (data_count + *ppdata > end_of_smb) {\n\t\tcFYI(1, \"data %p + count %d (%p) past smb end %p start %p\",\n\t\t\t*ppdata, data_count, (data_count + *ppdata),\n\t\t\tend_of_smb, pSMBr);\n\t\treturn -EINVAL;\n\t} else if (parm_count + data_count > bcc) {\n\t\tcFYI(1, \"parm count and data count larger than SMB\");\n\t\treturn -EINVAL;\n\t}\n\t*pdatalen = data_count;\n\t*pparmlen = parm_count;\n\treturn 0;\n}\n\n/* Get Security Descriptor (by handle) from remote server for a file or dir */\nint\nCIFSSMBGetCIFSACL(const int xid, struct cifs_tcon *tcon, __u16 fid,\n\t\t  struct cifs_ntsd **acl_inf, __u32 *pbuflen)\n{\n\tint rc = 0;\n\tint buf_type = 0;\n\tQUERY_SEC_DESC_REQ *pSMB;\n\tstruct kvec iov[1];\n\n\tcFYI(1, \"GetCifsACL\");\n\n\t*pbuflen = 0;\n\t*acl_inf = NULL;\n\n\trc = smb_init_nttransact(NT_TRANSACT_QUERY_SECURITY_DESC, 0,\n\t\t\t8 /* parm len */, tcon, (void **) &pSMB);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->MaxParameterCount = cpu_to_le32(4);\n\t/* BB TEST with big acls that might need to be e.g. larger than 16K */\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Fid = fid; /* file handle always le */\n\tpSMB->AclFlags = cpu_to_le32(CIFS_ACL_OWNER | CIFS_ACL_GROUP |\n\t\t\t\t     CIFS_ACL_DACL);\n\tpSMB->ByteCount = cpu_to_le16(11); /* 3 bytes pad + 8 bytes parm */\n\tinc_rfc1001_len(pSMB, 11);\n\tiov[0].iov_base = (char *)pSMB;\n\tiov[0].iov_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 4;\n\n\trc = SendReceive2(xid, tcon->ses, iov, 1 /* num iovec */, &buf_type,\n\t\t\t 0);\n\tcifs_stats_inc(&tcon->num_acl_get);\n\tif (rc) {\n\t\tcFYI(1, \"Send error in QuerySecDesc = %d\", rc);\n\t} else {                /* decode response */\n\t\t__le32 *parm;\n\t\t__u32 parm_len;\n\t\t__u32 acl_len;\n\t\tstruct smb_com_ntransact_rsp *pSMBr;\n\t\tchar *pdata;\n\n/* validate_nttransact */\n\t\trc = validate_ntransact(iov[0].iov_base, (char **)&parm,\n\t\t\t\t\t&pdata, &parm_len, pbuflen);\n\t\tif (rc)\n\t\t\tgoto qsec_out;\n\t\tpSMBr = (struct smb_com_ntransact_rsp *)iov[0].iov_base;\n\n\t\tcFYI(1, \"smb %p parm %p data %p\", pSMBr, parm, *acl_inf);\n\n\t\tif (le32_to_cpu(pSMBr->ParameterCount) != 4) {\n\t\t\trc = -EIO;      /* bad smb */\n\t\t\t*pbuflen = 0;\n\t\t\tgoto qsec_out;\n\t\t}\n\n/* BB check that data area is minimum length and as big as acl_len */\n\n\t\tacl_len = le32_to_cpu(*parm);\n\t\tif (acl_len != *pbuflen) {\n\t\t\tcERROR(1, \"acl length %d does not match %d\",\n\t\t\t\t   acl_len, *pbuflen);\n\t\t\tif (*pbuflen > acl_len)\n\t\t\t\t*pbuflen = acl_len;\n\t\t}\n\n\t\t/* check if buffer is big enough for the acl\n\t\t   header followed by the smallest SID */\n\t\tif ((*pbuflen < sizeof(struct cifs_ntsd) + 8) ||\n\t\t    (*pbuflen >= 64 * 1024)) {\n\t\t\tcERROR(1, \"bad acl length %d\", *pbuflen);\n\t\t\trc = -EINVAL;\n\t\t\t*pbuflen = 0;\n\t\t} else {\n\t\t\t*acl_inf = kmalloc(*pbuflen, GFP_KERNEL);\n\t\t\tif (*acl_inf == NULL) {\n\t\t\t\t*pbuflen = 0;\n\t\t\t\trc = -ENOMEM;\n\t\t\t}\n\t\t\tmemcpy(*acl_inf, pdata, *pbuflen);\n\t\t}\n\t}\nqsec_out:\n\tif (buf_type == CIFS_SMALL_BUFFER)\n\t\tcifs_small_buf_release(iov[0].iov_base);\n\telse if (buf_type == CIFS_LARGE_BUFFER)\n\t\tcifs_buf_release(iov[0].iov_base);\n/*\tcifs_small_buf_release(pSMB); */ /* Freed earlier now in SendReceive2 */\n\treturn rc;\n}\n\nint\nCIFSSMBSetCIFSACL(const int xid, struct cifs_tcon *tcon, __u16 fid,\n\t\t\tstruct cifs_ntsd *pntsd, __u32 acllen)\n{\n\t__u16 byte_count, param_count, data_count, param_offset, data_offset;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tSET_SEC_DESC_REQ *pSMB = NULL;\n\tNTRANSACT_RSP *pSMBr = NULL;\n\nsetCifsAclRetry:\n\trc = smb_init(SMB_COM_NT_TRANSACT, 19, tcon, (void **) &pSMB,\n\t\t\t(void **) &pSMBr);\n\tif (rc)\n\t\t\treturn (rc);\n\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\n\tparam_count = 8;\n\tparam_offset = offsetof(struct smb_com_transaction_ssec_req, Fid) - 4;\n\tdata_count = acllen;\n\tdata_offset = param_offset + param_count;\n\tbyte_count = 3 /* pad */  + param_count;\n\n\tpSMB->DataCount = cpu_to_le32(data_count);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->MaxParameterCount = cpu_to_le32(4);\n\tpSMB->MaxDataCount = cpu_to_le32(16384);\n\tpSMB->ParameterCount = cpu_to_le32(param_count);\n\tpSMB->ParameterOffset = cpu_to_le32(param_offset);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->DataOffset = cpu_to_le32(data_offset);\n\tpSMB->SetupCount = 0;\n\tpSMB->SubCommand = cpu_to_le16(NT_TRANSACT_SET_SECURITY_DESC);\n\tpSMB->ByteCount = cpu_to_le16(byte_count+data_count);\n\n\tpSMB->Fid = fid; /* file handle always le */\n\tpSMB->Reserved2 = 0;\n\tpSMB->AclFlags = cpu_to_le32(CIFS_ACL_DACL);\n\n\tif (pntsd && acllen) {\n\t\tmemcpy((char *) &pSMBr->hdr.Protocol + data_offset,\n\t\t\t(char *) pntsd,\n\t\t\tacllen);\n\t\tinc_rfc1001_len(pSMB, byte_count + data_count);\n\t} else\n\t\tinc_rfc1001_len(pSMB, byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\n\tcFYI(1, \"SetCIFSACL bytes_returned: %d, rc: %d\", bytes_returned, rc);\n\tif (rc)\n\t\tcFYI(1, \"Set CIFS ACL returned %d\", rc);\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto setCifsAclRetry;\n\n\treturn (rc);\n}\n\n#endif /* CONFIG_CIFS_ACL */\n\n/* Legacy Query Path Information call for lookup to old servers such\n   as Win9x/WinME */\nint SMBQueryInformation(const int xid, struct cifs_tcon *tcon,\n\t\t\tconst unsigned char *searchName,\n\t\t\tFILE_ALL_INFO *pFinfo,\n\t\t\tconst struct nls_table *nls_codepage, int remap)\n{\n\tQUERY_INFORMATION_REQ *pSMB;\n\tQUERY_INFORMATION_RSP *pSMBr;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\n\tcFYI(1, \"In SMBQPath path %s\", searchName);\nQInfRetry:\n\trc = smb_init(SMB_COM_QUERY_INFORMATION, 0, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t\tcifsConvertToUCS((__le16 *) pSMB->FileName, searchName,\n\t\t\t\t\tPATH_MAX, nls_codepage, remap);\n\t\tname_len++;     /* trailing null */\n\t\tname_len *= 2;\n\t} else {\n\t\tname_len = strnlen(searchName, PATH_MAX);\n\t\tname_len++;     /* trailing null */\n\t\tstrncpy(pSMB->FileName, searchName, name_len);\n\t}\n\tpSMB->BufferFormat = 0x04;\n\tname_len++; /* account for buffer type byte */\n\tinc_rfc1001_len(pSMB, (__u16)name_len);\n\tpSMB->ByteCount = cpu_to_le16(name_len);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcFYI(1, \"Send error in QueryInfo = %d\", rc);\n\t} else if (pFinfo) {\n\t\tstruct timespec ts;\n\t\t__u32 time = le32_to_cpu(pSMBr->last_write_time);\n\n\t\t/* decode response */\n\t\t/* BB FIXME - add time zone adjustment BB */\n\t\tmemset(pFinfo, 0, sizeof(FILE_ALL_INFO));\n\t\tts.tv_nsec = 0;\n\t\tts.tv_sec = time;\n\t\t/* decode time fields */\n\t\tpFinfo->ChangeTime = cpu_to_le64(cifs_UnixTimeToNT(ts));\n\t\tpFinfo->LastWriteTime = pFinfo->ChangeTime;\n\t\tpFinfo->LastAccessTime = 0;\n\t\tpFinfo->AllocationSize =\n\t\t\tcpu_to_le64(le32_to_cpu(pSMBr->size));\n\t\tpFinfo->EndOfFile = pFinfo->AllocationSize;\n\t\tpFinfo->Attributes =\n\t\t\tcpu_to_le32(le16_to_cpu(pSMBr->attr));\n\t} else\n\t\trc = -EIO; /* bad buffer passed in */\n\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QInfRetry;\n\n\treturn rc;\n}\n\nint\nCIFSSMBQFileInfo(const int xid, struct cifs_tcon *tcon,\n\t\t u16 netfid, FILE_ALL_INFO *pFindData)\n{\n\tstruct smb_t2_qfi_req *pSMB = NULL;\n\tstruct smb_t2_qfi_rsp *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\t__u16 params, byte_count;\n\nQFileInfoRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2 /* level */ + 2 /* fid */;\n\tpSMB->t2.TotalDataCount = 0;\n\tpSMB->t2.MaxParameterCount = cpu_to_le16(4);\n\t/* BB find exact max data count below from sess structure BB */\n\tpSMB->t2.MaxDataCount = cpu_to_le16(CIFSMaxBufSize);\n\tpSMB->t2.MaxSetupCount = 0;\n\tpSMB->t2.Reserved = 0;\n\tpSMB->t2.Flags = 0;\n\tpSMB->t2.Timeout = 0;\n\tpSMB->t2.Reserved2 = 0;\n\tpSMB->t2.ParameterOffset = cpu_to_le16(offsetof(struct smb_t2_qfi_req,\n\t\t\t\t\t       Fid) - 4);\n\tpSMB->t2.DataCount = 0;\n\tpSMB->t2.DataOffset = 0;\n\tpSMB->t2.SetupCount = 1;\n\tpSMB->t2.Reserved3 = 0;\n\tpSMB->t2.SubCommand = cpu_to_le16(TRANS2_QUERY_FILE_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->t2.TotalParameterCount = cpu_to_le16(params);\n\tpSMB->t2.ParameterCount = pSMB->t2.TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_ALL_INFO);\n\tpSMB->Pad = 0;\n\tpSMB->Fid = netfid;\n\tinc_rfc1001_len(pSMB, byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcFYI(1, \"Send error in QPathInfo = %d\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc) /* BB add auto retry on EOPNOTSUPP? */\n\t\t\trc = -EIO;\n\t\telse if (get_bcc(&pSMBr->hdr) < 40)\n\t\t\trc = -EIO;\t/* bad smb */\n\t\telse if (pFindData) {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tmemcpy((char *) pFindData,\n\t\t\t       (char *) &pSMBr->hdr.Protocol +\n\t\t\t       data_offset, sizeof(FILE_ALL_INFO));\n\t\t} else\n\t\t    rc = -ENOMEM;\n\t}\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto QFileInfoRetry;\n\n\treturn rc;\n}\n\nint\nCIFSSMBQPathInfo(const int xid, struct cifs_tcon *tcon,\n\t\t const unsigned char *searchName,\n\t\t FILE_ALL_INFO *pFindData,\n\t\t int legacy /* old style infolevel */,\n\t\t const struct nls_table *nls_codepage, int remap)\n{\n/* level 263 SMB_QUERY_FILE_ALL_INFO */\n\tTRANSACTION2_QPI_REQ *pSMB = NULL;\n\tTRANSACTION2_QPI_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 params, byte_count;\n\n/* cFYI(1, \"In QPathInfo path %s\", searchName); */\nQPathInfoRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUCS((__le16 *) pSMB->FileName, searchName,\n\t\t\t\t     PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(searchName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, searchName, name_len);\n\t}\n\n\tparams = 2 /* level */ + 4 /* reserved */ + name_len /* includes NUL */;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(4000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\tstruct smb_com_transaction2_qpi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_PATH_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tif (legacy)\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_INFO_STANDARD);\n\telse\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_ALL_INFO);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcFYI(1, \"Send error in QPathInfo = %d\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc) /* BB add auto retry on EOPNOTSUPP? */\n\t\t\trc = -EIO;\n\t\telse if (!legacy && get_bcc(&pSMBr->hdr) < 40)\n\t\t\trc = -EIO;\t/* bad smb */\n\t\telse if (legacy && get_bcc(&pSMBr->hdr) < 24)\n\t\t\trc = -EIO;  /* 24 or 26 expected but we do not read\n\t\t\t\t\tlast field */\n\t\telse if (pFindData) {\n\t\t\tint size;\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\n\t\t\t/* On legacy responses we do not read the last field,\n\t\t\tEAsize, fortunately since it varies by subdialect and\n\t\t\talso note it differs on Set vs. Get, ie two bytes or 4\n\t\t\tbytes depending but we don't care here */\n\t\t\tif (legacy)\n\t\t\t\tsize = sizeof(FILE_INFO_STANDARD);\n\t\t\telse\n\t\t\t\tsize = sizeof(FILE_ALL_INFO);\n\t\t\tmemcpy((char *) pFindData,\n\t\t\t       (char *) &pSMBr->hdr.Protocol +\n\t\t\t       data_offset, size);\n\t\t} else\n\t\t    rc = -ENOMEM;\n\t}\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto QPathInfoRetry;\n\n\treturn rc;\n}\n\nint\nCIFSSMBUnixQFileInfo(const int xid, struct cifs_tcon *tcon,\n\t\t u16 netfid, FILE_UNIX_BASIC_INFO *pFindData)\n{\n\tstruct smb_t2_qfi_req *pSMB = NULL;\n\tstruct smb_t2_qfi_rsp *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\t__u16 params, byte_count;\n\nUnixQFileInfoRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2 /* level */ + 2 /* fid */;\n\tpSMB->t2.TotalDataCount = 0;\n\tpSMB->t2.MaxParameterCount = cpu_to_le16(4);\n\t/* BB find exact max data count below from sess structure BB */\n\tpSMB->t2.MaxDataCount = cpu_to_le16(CIFSMaxBufSize);\n\tpSMB->t2.MaxSetupCount = 0;\n\tpSMB->t2.Reserved = 0;\n\tpSMB->t2.Flags = 0;\n\tpSMB->t2.Timeout = 0;\n\tpSMB->t2.Reserved2 = 0;\n\tpSMB->t2.ParameterOffset = cpu_to_le16(offsetof(struct smb_t2_qfi_req,\n\t\t\t\t\t       Fid) - 4);\n\tpSMB->t2.DataCount = 0;\n\tpSMB->t2.DataOffset = 0;\n\tpSMB->t2.SetupCount = 1;\n\tpSMB->t2.Reserved3 = 0;\n\tpSMB->t2.SubCommand = cpu_to_le16(TRANS2_QUERY_FILE_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->t2.TotalParameterCount = cpu_to_le16(params);\n\tpSMB->t2.ParameterCount = pSMB->t2.TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_UNIX_BASIC);\n\tpSMB->Pad = 0;\n\tpSMB->Fid = netfid;\n\tinc_rfc1001_len(pSMB, byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcFYI(1, \"Send error in QPathInfo = %d\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < sizeof(FILE_UNIX_BASIC_INFO)) {\n\t\t\tcERROR(1, \"Malformed FILE_UNIX_BASIC_INFO response.\\n\"\n\t\t\t\t   \"Unix Extensions can be disabled on mount \"\n\t\t\t\t   \"by specifying the nosfu mount option.\");\n\t\t\trc = -EIO;\t/* bad smb */\n\t\t} else {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tmemcpy((char *) pFindData,\n\t\t\t       (char *) &pSMBr->hdr.Protocol +\n\t\t\t       data_offset,\n\t\t\t       sizeof(FILE_UNIX_BASIC_INFO));\n\t\t}\n\t}\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto UnixQFileInfoRetry;\n\n\treturn rc;\n}\n\nint\nCIFSSMBUnixQPathInfo(const int xid, struct cifs_tcon *tcon,\n\t\t     const unsigned char *searchName,\n\t\t     FILE_UNIX_BASIC_INFO *pFindData,\n\t\t     const struct nls_table *nls_codepage, int remap)\n{\n/* SMB_QUERY_FILE_UNIX_BASIC */\n\tTRANSACTION2_QPI_REQ *pSMB = NULL;\n\tTRANSACTION2_QPI_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tint name_len;\n\t__u16 params, byte_count;\n\n\tcFYI(1, \"In QPathInfo (Unix) the path %s\", searchName);\nUnixQPathInfoRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUCS((__le16 *) pSMB->FileName, searchName,\n\t\t\t\t  PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(searchName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, searchName, name_len);\n\t}\n\n\tparams = 2 /* level */ + 4 /* reserved */ + name_len /* includes NUL */;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(4000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\tstruct smb_com_transaction2_qpi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_PATH_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_UNIX_BASIC);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcFYI(1, \"Send error in QPathInfo = %d\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < sizeof(FILE_UNIX_BASIC_INFO)) {\n\t\t\tcERROR(1, \"Malformed FILE_UNIX_BASIC_INFO response.\\n\"\n\t\t\t\t   \"Unix Extensions can be disabled on mount \"\n\t\t\t\t   \"by specifying the nosfu mount option.\");\n\t\t\trc = -EIO;\t/* bad smb */\n\t\t} else {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tmemcpy((char *) pFindData,\n\t\t\t       (char *) &pSMBr->hdr.Protocol +\n\t\t\t       data_offset,\n\t\t\t       sizeof(FILE_UNIX_BASIC_INFO));\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto UnixQPathInfoRetry;\n\n\treturn rc;\n}\n\n/* xid, tcon, searchName and codepage are input parms, rest are returned */\nint\nCIFSFindFirst(const int xid, struct cifs_tcon *tcon,\n\t      const char *searchName,\n\t      const struct nls_table *nls_codepage,\n\t      __u16 *pnetfid,\n\t      struct cifs_search_info *psrch_inf, int remap, const char dirsep)\n{\n/* level 257 SMB_ */\n\tTRANSACTION2_FFIRST_REQ *pSMB = NULL;\n\tTRANSACTION2_FFIRST_RSP *pSMBr = NULL;\n\tT2_FFIRST_RSP_PARMS *parms;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tint name_len;\n\t__u16 params, byte_count;\n\n\tcFYI(1, \"In FindFirst for %s\", searchName);\n\nfindFirstRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUCS((__le16 *) pSMB->FileName, searchName,\n\t\t\t\t PATH_MAX, nls_codepage, remap);\n\t\t/* We can not add the asterik earlier in case\n\t\tit got remapped to 0xF03A as if it were part of the\n\t\tdirectory name instead of a wildcard */\n\t\tname_len *= 2;\n\t\tpSMB->FileName[name_len] = dirsep;\n\t\tpSMB->FileName[name_len+1] = 0;\n\t\tpSMB->FileName[name_len+2] = '*';\n\t\tpSMB->FileName[name_len+3] = 0;\n\t\tname_len += 4; /* now the trailing null */\n\t\tpSMB->FileName[name_len] = 0; /* null terminate just in case */\n\t\tpSMB->FileName[name_len+1] = 0;\n\t\tname_len += 2;\n\t} else {\t/* BB add check for overrun of SMB buf BB */\n\t\tname_len = strnlen(searchName, PATH_MAX);\n/* BB fix here and in unicode clause above ie\n\t\tif (name_len > buffersize-header)\n\t\t\tfree buffer exit; BB */\n\t\tstrncpy(pSMB->FileName, searchName, name_len);\n\t\tpSMB->FileName[name_len] = dirsep;\n\t\tpSMB->FileName[name_len+1] = '*';\n\t\tpSMB->FileName[name_len+2] = 0;\n\t\tname_len += 3;\n\t}\n\n\tparams = 12 + name_len /* includes null */ ;\n\tpSMB->TotalDataCount = 0;\t/* no EAs */\n\tpSMB->MaxParameterCount = cpu_to_le16(10);\n\tpSMB->MaxDataCount = cpu_to_le16((tcon->ses->server->maxBuf -\n\t\t\t\t\t  MAX_CIFS_HDR_SIZE) & 0xFFFFFF00);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(\n\t      offsetof(struct smb_com_transaction2_ffirst_req, SearchAttributes)\n\t\t- 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\t/* one byte, no need to make endian neutral */\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_FIND_FIRST);\n\tpSMB->SearchAttributes =\n\t    cpu_to_le16(ATTR_READONLY | ATTR_HIDDEN | ATTR_SYSTEM |\n\t\t\tATTR_DIRECTORY);\n\tpSMB->SearchCount = cpu_to_le16(CIFSMaxBufSize/sizeof(FILE_UNIX_INFO));\n\tpSMB->SearchFlags = cpu_to_le16(CIFS_SEARCH_CLOSE_AT_END |\n\t\tCIFS_SEARCH_RETURN_RESUME);\n\tpSMB->InformationLevel = cpu_to_le16(psrch_inf->info_level);\n\n\t/* BB what should we set StorageType to? Does it matter? BB */\n\tpSMB->SearchStorageType = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->num_ffirst);\n\n\tif (rc) {/* BB add logic to retry regular search if Unix search\n\t\t\trejected unexpectedly by server */\n\t\t/* BB Add code to handle unsupported level rc */\n\t\tcFYI(1, \"Error in FindFirst = %d\", rc);\n\n\t\tcifs_buf_release(pSMB);\n\n\t\t/* BB eventually could optimize out free and realloc of buf */\n\t\t/*    for this case */\n\t\tif (rc == -EAGAIN)\n\t\t\tgoto findFirstRetry;\n\t} else { /* decode response */\n\t\t/* BB remember to free buffer if error BB */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\t\tif (rc == 0) {\n\t\t\tunsigned int lnoff;\n\n\t\t\tif (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE)\n\t\t\t\tpsrch_inf->unicode = true;\n\t\t\telse\n\t\t\t\tpsrch_inf->unicode = false;\n\n\t\t\tpsrch_inf->ntwrk_buf_start = (char *)pSMBr;\n\t\t\tpsrch_inf->smallBuf = 0;\n\t\t\tpsrch_inf->srch_entries_start =\n\t\t\t\t(char *) &pSMBr->hdr.Protocol +\n\t\t\t\t\tle16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tparms = (T2_FFIRST_RSP_PARMS *)((char *) &pSMBr->hdr.Protocol +\n\t\t\t       le16_to_cpu(pSMBr->t2.ParameterOffset));\n\n\t\t\tif (parms->EndofSearch)\n\t\t\t\tpsrch_inf->endOfSearch = true;\n\t\t\telse\n\t\t\t\tpsrch_inf->endOfSearch = false;\n\n\t\t\tpsrch_inf->entries_in_buffer =\n\t\t\t\t\tle16_to_cpu(parms->SearchCount);\n\t\t\tpsrch_inf->index_of_last_entry = 2 /* skip . and .. */ +\n\t\t\t\tpsrch_inf->entries_in_buffer;\n\t\t\tlnoff = le16_to_cpu(parms->LastNameOffset);\n\t\t\tif (tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE <\n\t\t\t      lnoff) {\n\t\t\t\tcERROR(1, \"ignoring corrupt resume name\");\n\t\t\t\tpsrch_inf->last_entry = NULL;\n\t\t\t\treturn rc;\n\t\t\t}\n\n\t\t\tpsrch_inf->last_entry = psrch_inf->srch_entries_start +\n\t\t\t\t\t\t\tlnoff;\n\n\t\t\t*pnetfid = parms->SearchHandle;\n\t\t} else {\n\t\t\tcifs_buf_release(pSMB);\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nint CIFSFindNext(const int xid, struct cifs_tcon *tcon,\n\t\t __u16 searchHandle, struct cifs_search_info *psrch_inf)\n{\n\tTRANSACTION2_FNEXT_REQ *pSMB = NULL;\n\tTRANSACTION2_FNEXT_RSP *pSMBr = NULL;\n\tT2_FNEXT_RSP_PARMS *parms;\n\tchar *response_data;\n\tint rc = 0;\n\tint bytes_returned;\n\tunsigned int name_len;\n\t__u16 params, byte_count;\n\n\tcFYI(1, \"In FindNext\");\n\n\tif (psrch_inf->endOfSearch)\n\t\treturn -ENOENT;\n\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t(void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 14; /* includes 2 bytes of null string, converted to LE below*/\n\tbyte_count = 0;\n\tpSMB->TotalDataCount = 0;       /* no EAs */\n\tpSMB->MaxParameterCount = cpu_to_le16(8);\n\tpSMB->MaxDataCount =\n\t\tcpu_to_le16((tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE) &\n\t\t\t\t0xFFFFFF00);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset =  cpu_to_le16(\n\t      offsetof(struct smb_com_transaction2_fnext_req,SearchHandle) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_FIND_NEXT);\n\tpSMB->SearchHandle = searchHandle;      /* always kept as le */\n\tpSMB->SearchCount =\n\t\tcpu_to_le16(CIFSMaxBufSize / sizeof(FILE_UNIX_INFO));\n\tpSMB->InformationLevel = cpu_to_le16(psrch_inf->info_level);\n\tpSMB->ResumeKey = psrch_inf->resume_key;\n\tpSMB->SearchFlags =\n\t      cpu_to_le16(CIFS_SEARCH_CLOSE_AT_END | CIFS_SEARCH_RETURN_RESUME);\n\n\tname_len = psrch_inf->resume_name_len;\n\tparams += name_len;\n\tif (name_len < PATH_MAX) {\n\t\tmemcpy(pSMB->ResumeFileName, psrch_inf->presume_name, name_len);\n\t\tbyte_count += name_len;\n\t\t/* 14 byte parm len above enough for 2 byte null terminator */\n\t\tpSMB->ResumeFileName[name_len] = 0;\n\t\tpSMB->ResumeFileName[name_len+1] = 0;\n\t} else {\n\t\trc = -EINVAL;\n\t\tgoto FNext2_err_exit;\n\t}\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->num_fnext);\n\tif (rc) {\n\t\tif (rc == -EBADF) {\n\t\t\tpsrch_inf->endOfSearch = true;\n\t\t\tcifs_buf_release(pSMB);\n\t\t\trc = 0; /* search probably was closed at end of search*/\n\t\t} else\n\t\t\tcFYI(1, \"FindNext returned = %d\", rc);\n\t} else {                /* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc == 0) {\n\t\t\tunsigned int lnoff;\n\n\t\t\t/* BB fixme add lock for file (srch_info) struct here */\n\t\t\tif (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE)\n\t\t\t\tpsrch_inf->unicode = true;\n\t\t\telse\n\t\t\t\tpsrch_inf->unicode = false;\n\t\t\tresponse_data = (char *) &pSMBr->hdr.Protocol +\n\t\t\t       le16_to_cpu(pSMBr->t2.ParameterOffset);\n\t\t\tparms = (T2_FNEXT_RSP_PARMS *)response_data;\n\t\t\tresponse_data = (char *)&pSMBr->hdr.Protocol +\n\t\t\t\tle16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tif (psrch_inf->smallBuf)\n\t\t\t\tcifs_small_buf_release(\n\t\t\t\t\tpsrch_inf->ntwrk_buf_start);\n\t\t\telse\n\t\t\t\tcifs_buf_release(psrch_inf->ntwrk_buf_start);\n\t\t\tpsrch_inf->srch_entries_start = response_data;\n\t\t\tpsrch_inf->ntwrk_buf_start = (char *)pSMB;\n\t\t\tpsrch_inf->smallBuf = 0;\n\t\t\tif (parms->EndofSearch)\n\t\t\t\tpsrch_inf->endOfSearch = true;\n\t\t\telse\n\t\t\t\tpsrch_inf->endOfSearch = false;\n\t\t\tpsrch_inf->entries_in_buffer =\n\t\t\t\t\t\tle16_to_cpu(parms->SearchCount);\n\t\t\tpsrch_inf->index_of_last_entry +=\n\t\t\t\tpsrch_inf->entries_in_buffer;\n\t\t\tlnoff = le16_to_cpu(parms->LastNameOffset);\n\t\t\tif (tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE <\n\t\t\t      lnoff) {\n\t\t\t\tcERROR(1, \"ignoring corrupt resume name\");\n\t\t\t\tpsrch_inf->last_entry = NULL;\n\t\t\t\treturn rc;\n\t\t\t} else\n\t\t\t\tpsrch_inf->last_entry =\n\t\t\t\t\tpsrch_inf->srch_entries_start + lnoff;\n\n/*  cFYI(1, \"fnxt2 entries in buf %d index_of_last %d\",\n\t    psrch_inf->entries_in_buffer, psrch_inf->index_of_last_entry); */\n\n\t\t\t/* BB fixme add unlock here */\n\t\t}\n\n\t}\n\n\t/* BB On error, should we leave previous search buf (and count and\n\tlast entry fields) intact or free the previous one? */\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\tsince file handle passed in no longer valid */\nFNext2_err_exit:\n\tif (rc != 0)\n\t\tcifs_buf_release(pSMB);\n\treturn rc;\n}\n\nint\nCIFSFindClose(const int xid, struct cifs_tcon *tcon,\n\t      const __u16 searchHandle)\n{\n\tint rc = 0;\n\tFINDCLOSE_REQ *pSMB = NULL;\n\n\tcFYI(1, \"In CIFSSMBFindClose\");\n\trc = small_smb_init(SMB_COM_FIND_CLOSE2, 1, tcon, (void **)&pSMB);\n\n\t/* no sense returning error if session restarted\n\t\tas file handle has been closed */\n\tif (rc == -EAGAIN)\n\t\treturn 0;\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->FileID = searchHandle;\n\tpSMB->ByteCount = 0;\n\trc = SendReceiveNoRsp(xid, tcon->ses, (struct smb_hdr *) pSMB, 0);\n\tif (rc)\n\t\tcERROR(1, \"Send error in FindClose = %d\", rc);\n\n\tcifs_stats_inc(&tcon->num_fclose);\n\n\t/* Since session is dead, search handle closed on server already */\n\tif (rc == -EAGAIN)\n\t\trc = 0;\n\n\treturn rc;\n}\n\nint\nCIFSGetSrvInodeNumber(const int xid, struct cifs_tcon *tcon,\n\t\t      const unsigned char *searchName,\n\t\t      __u64 *inode_number,\n\t\t      const struct nls_table *nls_codepage, int remap)\n{\n\tint rc = 0;\n\tTRANSACTION2_QPI_REQ *pSMB = NULL;\n\tTRANSACTION2_QPI_RSP *pSMBr = NULL;\n\tint name_len, bytes_returned;\n\t__u16 params, byte_count;\n\n\tcFYI(1, \"In GetSrvInodeNum for %s\", searchName);\n\tif (tcon == NULL)\n\t\treturn -ENODEV;\n\nGetInodeNumberRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t\tcifsConvertToUCS((__le16 *) pSMB->FileName, searchName,\n\t\t\t\t\t PATH_MAX, nls_codepage, remap);\n\t\tname_len++;     /* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(searchName, PATH_MAX);\n\t\tname_len++;     /* trailing null */\n\t\tstrncpy(pSMB->FileName, searchName, name_len);\n\t}\n\n\tparams = 2 /* level */  + 4 /* rsrvd */  + name_len /* incl null */ ;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max data count below from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(4000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\t\tstruct smb_com_transaction2_qpi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_PATH_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_INTERNAL_INFO);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcFYI(1, \"error %d in QueryInternalInfo\", rc);\n\t} else {\n\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\t\t/* BB also check enough total bytes returned */\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 2)\n\t\t\t/* If rc should we check for EOPNOSUPP and\n\t\t\tdisable the srvino flag? or in caller? */\n\t\t\trc = -EIO;      /* bad smb */\n\t\telse {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\t__u16 count = le16_to_cpu(pSMBr->t2.DataCount);\n\t\t\tstruct file_internal_info *pfinfo;\n\t\t\t/* BB Do we need a cast or hash here ? */\n\t\t\tif (count < 8) {\n\t\t\t\tcFYI(1, \"Illegal size ret in QryIntrnlInf\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto GetInodeNumOut;\n\t\t\t}\n\t\t\tpfinfo = (struct file_internal_info *)\n\t\t\t\t(data_offset + (char *) &pSMBr->hdr.Protocol);\n\t\t\t*inode_number = le64_to_cpu(pfinfo->UniqueId);\n\t\t}\n\t}\nGetInodeNumOut:\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto GetInodeNumberRetry;\n\treturn rc;\n}\n\n/* parses DFS refferal V3 structure\n * caller is responsible for freeing target_nodes\n * returns:\n * \ton success - 0\n *\ton failure - errno\n */\nstatic int\nparse_DFS_referrals(TRANSACTION2_GET_DFS_REFER_RSP *pSMBr,\n\t\tunsigned int *num_of_nodes,\n\t\tstruct dfs_info3_param **target_nodes,\n\t\tconst struct nls_table *nls_codepage, int remap,\n\t\tconst char *searchName)\n{\n\tint i, rc = 0;\n\tchar *data_end;\n\tbool is_unicode;\n\tstruct dfs_referral_level_3 *ref;\n\n\tif (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE)\n\t\tis_unicode = true;\n\telse\n\t\tis_unicode = false;\n\t*num_of_nodes = le16_to_cpu(pSMBr->NumberOfReferrals);\n\n\tif (*num_of_nodes < 1) {\n\t\tcERROR(1, \"num_referrals: must be at least > 0,\"\n\t\t\t\"but we get num_referrals = %d\\n\", *num_of_nodes);\n\t\trc = -EINVAL;\n\t\tgoto parse_DFS_referrals_exit;\n\t}\n\n\tref = (struct dfs_referral_level_3 *) &(pSMBr->referrals);\n\tif (ref->VersionNumber != cpu_to_le16(3)) {\n\t\tcERROR(1, \"Referrals of V%d version are not supported,\"\n\t\t\t\"should be V3\", le16_to_cpu(ref->VersionNumber));\n\t\trc = -EINVAL;\n\t\tgoto parse_DFS_referrals_exit;\n\t}\n\n\t/* get the upper boundary of the resp buffer */\n\tdata_end = (char *)(&(pSMBr->PathConsumed)) +\n\t\t\t\tle16_to_cpu(pSMBr->t2.DataCount);\n\n\tcFYI(1, \"num_referrals: %d dfs flags: 0x%x ...\\n\",\n\t\t\t*num_of_nodes,\n\t\t\tle32_to_cpu(pSMBr->DFSFlags));\n\n\t*target_nodes = kzalloc(sizeof(struct dfs_info3_param) *\n\t\t\t*num_of_nodes, GFP_KERNEL);\n\tif (*target_nodes == NULL) {\n\t\tcERROR(1, \"Failed to allocate buffer for target_nodes\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto parse_DFS_referrals_exit;\n\t}\n\n\t/* collect necessary data from referrals */\n\tfor (i = 0; i < *num_of_nodes; i++) {\n\t\tchar *temp;\n\t\tint max_len;\n\t\tstruct dfs_info3_param *node = (*target_nodes)+i;\n\n\t\tnode->flags = le32_to_cpu(pSMBr->DFSFlags);\n\t\tif (is_unicode) {\n\t\t\t__le16 *tmp = kmalloc(strlen(searchName)*2 + 2,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (tmp == NULL) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto parse_DFS_referrals_exit;\n\t\t\t}\n\t\t\tcifsConvertToUCS((__le16 *) tmp, searchName,\n\t\t\t\t\tPATH_MAX, nls_codepage, remap);\n\t\t\tnode->path_consumed = cifs_ucs2_bytes(tmp,\n\t\t\t\t\tle16_to_cpu(pSMBr->PathConsumed),\n\t\t\t\t\tnls_codepage);\n\t\t\tkfree(tmp);\n\t\t} else\n\t\t\tnode->path_consumed = le16_to_cpu(pSMBr->PathConsumed);\n\n\t\tnode->server_type = le16_to_cpu(ref->ServerType);\n\t\tnode->ref_flag = le16_to_cpu(ref->ReferralEntryFlags);\n\n\t\t/* copy DfsPath */\n\t\ttemp = (char *)ref + le16_to_cpu(ref->DfsPathOffset);\n\t\tmax_len = data_end - temp;\n\t\tnode->path_name = cifs_strndup_from_ucs(temp, max_len,\n\t\t\t\t\t\t      is_unicode, nls_codepage);\n\t\tif (!node->path_name) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto parse_DFS_referrals_exit;\n\t\t}\n\n\t\t/* copy link target UNC */\n\t\ttemp = (char *)ref + le16_to_cpu(ref->NetworkAddressOffset);\n\t\tmax_len = data_end - temp;\n\t\tnode->node_name = cifs_strndup_from_ucs(temp, max_len,\n\t\t\t\t\t\t      is_unicode, nls_codepage);\n\t\tif (!node->node_name)\n\t\t\trc = -ENOMEM;\n\t}\n\nparse_DFS_referrals_exit:\n\tif (rc) {\n\t\tfree_dfs_info_array(*target_nodes, *num_of_nodes);\n\t\t*target_nodes = NULL;\n\t\t*num_of_nodes = 0;\n\t}\n\treturn rc;\n}\n\nint\nCIFSGetDFSRefer(const int xid, struct cifs_ses *ses,\n\t\tconst unsigned char *searchName,\n\t\tstruct dfs_info3_param **target_nodes,\n\t\tunsigned int *num_of_nodes,\n\t\tconst struct nls_table *nls_codepage, int remap)\n{\n/* TRANS2_GET_DFS_REFERRAL */\n\tTRANSACTION2_GET_DFS_REFER_REQ *pSMB = NULL;\n\tTRANSACTION2_GET_DFS_REFER_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 params, byte_count;\n\t*num_of_nodes = 0;\n\t*target_nodes = NULL;\n\n\tcFYI(1, \"In GetDFSRefer the path %s\", searchName);\n\tif (ses == NULL)\n\t\treturn -ENODEV;\ngetDFSRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, NULL, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\t/* server pointer checked in called function,\n\tbut should never be null here anyway */\n\tpSMB->hdr.Mid = GetNextMid(ses->server);\n\tpSMB->hdr.Tid = ses->ipc_tid;\n\tpSMB->hdr.Uid = ses->Suid;\n\tif (ses->capabilities & CAP_STATUS32)\n\t\tpSMB->hdr.Flags2 |= SMBFLG2_ERR_STATUS;\n\tif (ses->capabilities & CAP_DFS)\n\t\tpSMB->hdr.Flags2 |= SMBFLG2_DFS;\n\n\tif (ses->capabilities & CAP_UNICODE) {\n\t\tpSMB->hdr.Flags2 |= SMBFLG2_UNICODE;\n\t\tname_len =\n\t\t    cifsConvertToUCS((__le16 *) pSMB->RequestFileName,\n\t\t\t\t     searchName, PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(searchName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->RequestFileName, searchName, name_len);\n\t}\n\n\tif (ses->server) {\n\t\tif (ses->server->sec_mode &\n\t\t   (SECMODE_SIGN_REQUIRED | SECMODE_SIGN_ENABLED))\n\t\t\tpSMB->hdr.Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\t}\n\n\tpSMB->hdr.Uid = ses->Suid;\n\n\tparams = 2 /* level */  + name_len /*includes null */ ;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->MaxParameterCount = 0;\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(4000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\t  struct smb_com_transaction2_get_dfs_refer_req, MaxReferralLevel) - 4);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_GET_DFS_REFERRAL);\n\tbyte_count = params + 3 /* pad */ ;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->MaxReferralLevel = cpu_to_le16(3);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcFYI(1, \"Send error in GetDFSRefer = %d\", rc);\n\t\tgoto GetDFSRefExit;\n\t}\n\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t/* BB Also check if enough total bytes returned? */\n\tif (rc || get_bcc(&pSMBr->hdr) < 17) {\n\t\trc = -EIO;      /* bad smb */\n\t\tgoto GetDFSRefExit;\n\t}\n\n\tcFYI(1, \"Decoding GetDFSRefer response BCC: %d  Offset %d\",\n\t\t\t\tget_bcc(&pSMBr->hdr),\n\t\t\t\tle16_to_cpu(pSMBr->t2.DataOffset));\n\n\t/* parse returned result into more usable form */\n\trc = parse_DFS_referrals(pSMBr, num_of_nodes,\n\t\t\t\t target_nodes, nls_codepage, remap,\n\t\t\t\t searchName);\n\nGetDFSRefExit:\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto getDFSRetry;\n\n\treturn rc;\n}\n\n/* Query File System Info such as free space to old servers such as Win 9x */\nint\nSMBOldQFSInfo(const int xid, struct cifs_tcon *tcon, struct kstatfs *FSData)\n{\n/* level 0x01 SMB_QUERY_FILE_SYSTEM_INFO */\n\tTRANSACTION2_QFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_QFSI_RSP *pSMBr = NULL;\n\tFILE_SYSTEM_ALLOC_INFO *response_data;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count;\n\n\tcFYI(1, \"OldQFSInfo\");\noldQFSInfoRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t(void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2;     /* level */\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\tstruct smb_com_transaction2_qfsi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_INFO_ALLOCATION);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcFYI(1, \"Send error in QFSInfo = %d\", rc);\n\t} else {                /* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 18)\n\t\t\trc = -EIO;      /* bad smb */\n\t\telse {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tcFYI(1, \"qfsinf resp BCC: %d  Offset %d\",\n\t\t\t\t get_bcc(&pSMBr->hdr), data_offset);\n\n\t\t\tresponse_data = (FILE_SYSTEM_ALLOC_INFO *)\n\t\t\t\t(((char *) &pSMBr->hdr.Protocol) + data_offset);\n\t\t\tFSData->f_bsize =\n\t\t\t\tle16_to_cpu(response_data->BytesPerSector) *\n\t\t\t\tle32_to_cpu(response_data->\n\t\t\t\t\tSectorsPerAllocationUnit);\n\t\t\tFSData->f_blocks =\n\t\t\t       le32_to_cpu(response_data->TotalAllocationUnits);\n\t\t\tFSData->f_bfree = FSData->f_bavail =\n\t\t\t\tle32_to_cpu(response_data->FreeAllocationUnits);\n\t\t\tcFYI(1, \"Blocks: %lld  Free: %lld Block size %ld\",\n\t\t\t     (unsigned long long)FSData->f_blocks,\n\t\t\t     (unsigned long long)FSData->f_bfree,\n\t\t\t     FSData->f_bsize);\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto oldQFSInfoRetry;\n\n\treturn rc;\n}\n\nint\nCIFSSMBQFSInfo(const int xid, struct cifs_tcon *tcon, struct kstatfs *FSData)\n{\n/* level 0x103 SMB_QUERY_FILE_SYSTEM_INFO */\n\tTRANSACTION2_QFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_QFSI_RSP *pSMBr = NULL;\n\tFILE_SYSTEM_INFO *response_data;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count;\n\n\tcFYI(1, \"In QFSInfo\");\nQFSInfoRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2;\t/* level */\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\t\tstruct smb_com_transaction2_qfsi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FS_SIZE_INFO);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcFYI(1, \"Send error in QFSInfo = %d\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 24)\n\t\t\trc = -EIO;\t/* bad smb */\n\t\telse {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\n\t\t\tresponse_data =\n\t\t\t    (FILE_SYSTEM_INFO\n\t\t\t     *) (((char *) &pSMBr->hdr.Protocol) +\n\t\t\t\t data_offset);\n\t\t\tFSData->f_bsize =\n\t\t\t    le32_to_cpu(response_data->BytesPerSector) *\n\t\t\t    le32_to_cpu(response_data->\n\t\t\t\t\tSectorsPerAllocationUnit);\n\t\t\tFSData->f_blocks =\n\t\t\t    le64_to_cpu(response_data->TotalAllocationUnits);\n\t\t\tFSData->f_bfree = FSData->f_bavail =\n\t\t\t    le64_to_cpu(response_data->FreeAllocationUnits);\n\t\t\tcFYI(1, \"Blocks: %lld  Free: %lld Block size %ld\",\n\t\t\t     (unsigned long long)FSData->f_blocks,\n\t\t\t     (unsigned long long)FSData->f_bfree,\n\t\t\t     FSData->f_bsize);\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QFSInfoRetry;\n\n\treturn rc;\n}\n\nint\nCIFSSMBQFSAttributeInfo(const int xid, struct cifs_tcon *tcon)\n{\n/* level 0x105  SMB_QUERY_FILE_SYSTEM_INFO */\n\tTRANSACTION2_QFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_QFSI_RSP *pSMBr = NULL;\n\tFILE_SYSTEM_ATTRIBUTE_INFO *response_data;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count;\n\n\tcFYI(1, \"In QFSAttributeInfo\");\nQFSAttributeRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2;\t/* level */\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\t\tstruct smb_com_transaction2_qfsi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FS_ATTRIBUTE_INFO);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcERROR(1, \"Send error in QFSAttributeInfo = %d\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 13) {\n\t\t\t/* BB also check if enough bytes returned */\n\t\t\trc = -EIO;\t/* bad smb */\n\t\t} else {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tresponse_data =\n\t\t\t    (FILE_SYSTEM_ATTRIBUTE_INFO\n\t\t\t     *) (((char *) &pSMBr->hdr.Protocol) +\n\t\t\t\t data_offset);\n\t\t\tmemcpy(&tcon->fsAttrInfo, response_data,\n\t\t\t       sizeof(FILE_SYSTEM_ATTRIBUTE_INFO));\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QFSAttributeRetry;\n\n\treturn rc;\n}\n\nint\nCIFSSMBQFSDeviceInfo(const int xid, struct cifs_tcon *tcon)\n{\n/* level 0x104 SMB_QUERY_FILE_SYSTEM_INFO */\n\tTRANSACTION2_QFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_QFSI_RSP *pSMBr = NULL;\n\tFILE_SYSTEM_DEVICE_INFO *response_data;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count;\n\n\tcFYI(1, \"In QFSDeviceInfo\");\nQFSDeviceRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2;\t/* level */\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\t\tstruct smb_com_transaction2_qfsi_req, InformationLevel) - 4);\n\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FS_DEVICE_INFO);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcFYI(1, \"Send error in QFSDeviceInfo = %d\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) <\n\t\t\t  sizeof(FILE_SYSTEM_DEVICE_INFO))\n\t\t\trc = -EIO;\t/* bad smb */\n\t\telse {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tresponse_data =\n\t\t\t    (FILE_SYSTEM_DEVICE_INFO *)\n\t\t\t\t(((char *) &pSMBr->hdr.Protocol) +\n\t\t\t\t data_offset);\n\t\t\tmemcpy(&tcon->fsDevInfo, response_data,\n\t\t\t       sizeof(FILE_SYSTEM_DEVICE_INFO));\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QFSDeviceRetry;\n\n\treturn rc;\n}\n\nint\nCIFSSMBQFSUnixInfo(const int xid, struct cifs_tcon *tcon)\n{\n/* level 0x200  SMB_QUERY_CIFS_UNIX_INFO */\n\tTRANSACTION2_QFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_QFSI_RSP *pSMBr = NULL;\n\tFILE_SYSTEM_UNIX_INFO *response_data;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count;\n\n\tcFYI(1, \"In QFSUnixInfo\");\nQFSUnixRetry:\n\trc = smb_init_no_reconnect(SMB_COM_TRANSACTION2, 15, tcon,\n\t\t\t\t   (void **) &pSMB, (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2;\t/* level */\n\tpSMB->TotalDataCount = 0;\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(100);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(struct\n\t\t\tsmb_com_transaction2_qfsi_req, InformationLevel) - 4);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_CIFS_UNIX_INFO);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcERROR(1, \"Send error in QFSUnixInfo = %d\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 13) {\n\t\t\trc = -EIO;\t/* bad smb */\n\t\t} else {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tresponse_data =\n\t\t\t    (FILE_SYSTEM_UNIX_INFO\n\t\t\t     *) (((char *) &pSMBr->hdr.Protocol) +\n\t\t\t\t data_offset);\n\t\t\tmemcpy(&tcon->fsUnixInfo, response_data,\n\t\t\t       sizeof(FILE_SYSTEM_UNIX_INFO));\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QFSUnixRetry;\n\n\n\treturn rc;\n}\n\nint\nCIFSSMBSetFSUnixInfo(const int xid, struct cifs_tcon *tcon, __u64 cap)\n{\n/* level 0x200  SMB_SET_CIFS_UNIX_INFO */\n\tTRANSACTION2_SETFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_SETFSI_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, param_offset, offset, byte_count;\n\n\tcFYI(1, \"In SETFSUnixInfo\");\nSETFSUnixRetry:\n\t/* BB switch to small buf init to save memory */\n\trc = smb_init_no_reconnect(SMB_COM_TRANSACTION2, 15, tcon,\n\t\t\t\t\t(void **) &pSMB, (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 4;\t/* 2 bytes zero followed by info level. */\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_setfsi_req, FileNum)\n\t\t\t\t- 4;\n\toffset = param_offset + params;\n\n\tpSMB->MaxParameterCount = cpu_to_le16(4);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(100);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FS_INFORMATION);\n\tbyte_count = 1 /* pad */ + params + 12;\n\n\tpSMB->DataCount = cpu_to_le16(12);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\n\t/* Params. */\n\tpSMB->FileNum = 0;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_CIFS_UNIX_INFO);\n\n\t/* Data. */\n\tpSMB->ClientUnixMajor = cpu_to_le16(CIFS_UNIX_MAJOR_VERSION);\n\tpSMB->ClientUnixMinor = cpu_to_le16(CIFS_UNIX_MINOR_VERSION);\n\tpSMB->ClientUnixCap = cpu_to_le64(cap);\n\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcERROR(1, \"Send error in SETFSUnixInfo = %d\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\t\tif (rc)\n\t\t\trc = -EIO;\t/* bad smb */\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto SETFSUnixRetry;\n\n\treturn rc;\n}\n\n\n\nint\nCIFSSMBQFSPosixInfo(const int xid, struct cifs_tcon *tcon,\n\t\t   struct kstatfs *FSData)\n{\n/* level 0x201  SMB_QUERY_CIFS_POSIX_INFO */\n\tTRANSACTION2_QFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_QFSI_RSP *pSMBr = NULL;\n\tFILE_SYSTEM_POSIX_INFO *response_data;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count;\n\n\tcFYI(1, \"In QFSPosixInfo\");\nQFSPosixRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2;\t/* level */\n\tpSMB->TotalDataCount = 0;\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(100);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(struct\n\t\t\tsmb_com_transaction2_qfsi_req, InformationLevel) - 4);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_POSIX_FS_INFO);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcFYI(1, \"Send error in QFSUnixInfo = %d\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 13) {\n\t\t\trc = -EIO;\t/* bad smb */\n\t\t} else {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tresponse_data =\n\t\t\t    (FILE_SYSTEM_POSIX_INFO\n\t\t\t     *) (((char *) &pSMBr->hdr.Protocol) +\n\t\t\t\t data_offset);\n\t\t\tFSData->f_bsize =\n\t\t\t\t\tle32_to_cpu(response_data->BlockSize);\n\t\t\tFSData->f_blocks =\n\t\t\t\t\tle64_to_cpu(response_data->TotalBlocks);\n\t\t\tFSData->f_bfree =\n\t\t\t    le64_to_cpu(response_data->BlocksAvail);\n\t\t\tif (response_data->UserBlocksAvail == cpu_to_le64(-1)) {\n\t\t\t\tFSData->f_bavail = FSData->f_bfree;\n\t\t\t} else {\n\t\t\t\tFSData->f_bavail =\n\t\t\t\t    le64_to_cpu(response_data->UserBlocksAvail);\n\t\t\t}\n\t\t\tif (response_data->TotalFileNodes != cpu_to_le64(-1))\n\t\t\t\tFSData->f_files =\n\t\t\t\t     le64_to_cpu(response_data->TotalFileNodes);\n\t\t\tif (response_data->FreeFileNodes != cpu_to_le64(-1))\n\t\t\t\tFSData->f_ffree =\n\t\t\t\t      le64_to_cpu(response_data->FreeFileNodes);\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QFSPosixRetry;\n\n\treturn rc;\n}\n\n\n/* We can not use write of zero bytes trick to\n   set file size due to need for large file support.  Also note that\n   this SetPathInfo is preferred to SetFileInfo based method in next\n   routine which is only needed to work around a sharing violation bug\n   in Samba which this routine can run into */\n\nint\nCIFSSMBSetEOF(const int xid, struct cifs_tcon *tcon, const char *fileName,\n\t      __u64 size, bool SetAllocation,\n\t      const struct nls_table *nls_codepage, int remap)\n{\n\tstruct smb_com_transaction2_spi_req *pSMB = NULL;\n\tstruct smb_com_transaction2_spi_rsp *pSMBr = NULL;\n\tstruct file_end_of_file_info *parm_data;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count, data_count, param_offset, offset;\n\n\tcFYI(1, \"In SetEOF\");\nSetEOFRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUCS((__le16 *) pSMB->FileName, fileName,\n\t\t\t\t     PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(fileName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, fileName, name_len);\n\t}\n\tparams = 6 + name_len;\n\tdata_count = sizeof(struct file_end_of_file_info);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(4100);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\tif (SetAllocation) {\n\t\tif (tcon->ses->capabilities & CAP_INFOLEVEL_PASSTHRU)\n\t\t\tpSMB->InformationLevel =\n\t\t\t\tcpu_to_le16(SMB_SET_FILE_ALLOCATION_INFO2);\n\t\telse\n\t\t\tpSMB->InformationLevel =\n\t\t\t\tcpu_to_le16(SMB_SET_FILE_ALLOCATION_INFO);\n\t} else /* Set File Size */  {\n\t    if (tcon->ses->capabilities & CAP_INFOLEVEL_PASSTHRU)\n\t\t    pSMB->InformationLevel =\n\t\t\t\tcpu_to_le16(SMB_SET_FILE_END_OF_FILE_INFO2);\n\t    else\n\t\t    pSMB->InformationLevel =\n\t\t\t\tcpu_to_le16(SMB_SET_FILE_END_OF_FILE_INFO);\n\t}\n\n\tparm_data =\n\t    (struct file_end_of_file_info *) (((char *) &pSMB->hdr.Protocol) +\n\t\t\t\t       offset);\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + data_count;\n\tpSMB->DataCount = cpu_to_le16(data_count);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tparm_data->FileSize = cpu_to_le64(size);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcFYI(1, \"SetPathInfo (file size) returned %d\", rc);\n\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto SetEOFRetry;\n\n\treturn rc;\n}\n\nint\nCIFSSMBSetFileSize(const int xid, struct cifs_tcon *tcon, __u64 size,\n\t\t   __u16 fid, __u32 pid_of_opener, bool SetAllocation)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tstruct file_end_of_file_info *parm_data;\n\tint rc = 0;\n\t__u16 params, param_offset, offset, byte_count, count;\n\n\tcFYI(1, \"SetFileSize (via SetFileInfo) %lld\",\n\t\t\t(long long)size);\n\trc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid_of_opener);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid_of_opener >> 16));\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tcount = sizeof(struct file_end_of_file_info);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tparm_data =\n\t\t(struct file_end_of_file_info *) (((char *) &pSMB->hdr.Protocol)\n\t\t\t\t+ offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tparm_data->FileSize = cpu_to_le64(size);\n\tpSMB->Fid = fid;\n\tif (SetAllocation) {\n\t\tif (tcon->ses->capabilities & CAP_INFOLEVEL_PASSTHRU)\n\t\t\tpSMB->InformationLevel =\n\t\t\t\tcpu_to_le16(SMB_SET_FILE_ALLOCATION_INFO2);\n\t\telse\n\t\t\tpSMB->InformationLevel =\n\t\t\t\tcpu_to_le16(SMB_SET_FILE_ALLOCATION_INFO);\n\t} else /* Set File Size */  {\n\t    if (tcon->ses->capabilities & CAP_INFOLEVEL_PASSTHRU)\n\t\t    pSMB->InformationLevel =\n\t\t\t\tcpu_to_le16(SMB_SET_FILE_END_OF_FILE_INFO2);\n\t    else\n\t\t    pSMB->InformationLevel =\n\t\t\t\tcpu_to_le16(SMB_SET_FILE_END_OF_FILE_INFO);\n\t}\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceiveNoRsp(xid, tcon->ses, (struct smb_hdr *) pSMB, 0);\n\tif (rc) {\n\t\tcFYI(1, \"Send error in SetFileInfo (SetFileSize) = %d\", rc);\n\t}\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\n\treturn rc;\n}\n\n/* Some legacy servers such as NT4 require that the file times be set on\n   an open handle, rather than by pathname - this is awkward due to\n   potential access conflicts on the open, but it is unavoidable for these\n   old servers since the only other choice is to go from 100 nanosecond DCE\n   time and resort to the original setpathinfo level which takes the ancient\n   DOS time format with 2 second granularity */\nint\nCIFSSMBSetFileInfo(const int xid, struct cifs_tcon *tcon,\n\t\t    const FILE_BASIC_INFO *data, __u16 fid, __u32 pid_of_opener)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tchar *data_offset;\n\tint rc = 0;\n\t__u16 params, param_offset, offset, byte_count, count;\n\n\tcFYI(1, \"Set Times (via SetFileInfo)\");\n\trc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid_of_opener);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid_of_opener >> 16));\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tdata_offset = (char *) (&pSMB->hdr.Protocol) + offset;\n\n\tcount = sizeof(FILE_BASIC_INFO);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find max SMB PDU from sess */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->Fid = fid;\n\tif (tcon->ses->capabilities & CAP_INFOLEVEL_PASSTHRU)\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_BASIC_INFO2);\n\telse\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_BASIC_INFO);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\tmemcpy(data_offset, data, sizeof(FILE_BASIC_INFO));\n\trc = SendReceiveNoRsp(xid, tcon->ses, (struct smb_hdr *) pSMB, 0);\n\tif (rc)\n\t\tcFYI(1, \"Send error in Set Time (SetFileInfo) = %d\", rc);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\n\treturn rc;\n}\n\nint\nCIFSSMBSetFileDisposition(const int xid, struct cifs_tcon *tcon,\n\t\t\t  bool delete_file, __u16 fid, __u32 pid_of_opener)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tchar *data_offset;\n\tint rc = 0;\n\t__u16 params, param_offset, offset, byte_count, count;\n\n\tcFYI(1, \"Set File Disposition (via SetFileInfo)\");\n\trc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid_of_opener);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid_of_opener >> 16));\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tdata_offset = (char *) (&pSMB->hdr.Protocol) + offset;\n\n\tcount = 1;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find max SMB PDU from sess */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->Fid = fid;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_DISPOSITION_INFO);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\t*data_offset = delete_file ? 1 : 0;\n\trc = SendReceiveNoRsp(xid, tcon->ses, (struct smb_hdr *) pSMB, 0);\n\tif (rc)\n\t\tcFYI(1, \"Send error in SetFileDisposition = %d\", rc);\n\n\treturn rc;\n}\n\nint\nCIFSSMBSetPathInfo(const int xid, struct cifs_tcon *tcon,\n\t\t   const char *fileName, const FILE_BASIC_INFO *data,\n\t\t   const struct nls_table *nls_codepage, int remap)\n{\n\tTRANSACTION2_SPI_REQ *pSMB = NULL;\n\tTRANSACTION2_SPI_RSP *pSMBr = NULL;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tchar *data_offset;\n\t__u16 params, param_offset, offset, byte_count, count;\n\n\tcFYI(1, \"In SetTimes\");\n\nSetTimesRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUCS((__le16 *) pSMB->FileName, fileName,\n\t\t\t\t     PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(fileName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, fileName, name_len);\n\t}\n\n\tparams = 6 + name_len;\n\tcount = sizeof(FILE_BASIC_INFO);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\tdata_offset = (char *) (&pSMB->hdr.Protocol) + offset;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tif (tcon->ses->capabilities & CAP_INFOLEVEL_PASSTHRU)\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_BASIC_INFO2);\n\telse\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_BASIC_INFO);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tmemcpy(data_offset, data, sizeof(FILE_BASIC_INFO));\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcFYI(1, \"SetPathInfo (times) returned %d\", rc);\n\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto SetTimesRetry;\n\n\treturn rc;\n}\n\n/* Can not be used to set time stamps yet (due to old DOS time format) */\n/* Can be used to set attributes */\n#if 0  /* Possibly not needed - since it turns out that strangely NT4 has a bug\n\t  handling it anyway and NT4 was what we thought it would be needed for\n\t  Do not delete it until we prove whether needed for Win9x though */\nint\nCIFSSMBSetAttrLegacy(int xid, struct cifs_tcon *tcon, char *fileName,\n\t\t__u16 dos_attrs, const struct nls_table *nls_codepage)\n{\n\tSETATTR_REQ *pSMB = NULL;\n\tSETATTR_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\n\tcFYI(1, \"In SetAttrLegacy\");\n\nSetAttrLgcyRetry:\n\trc = smb_init(SMB_COM_SETATTR, 8, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t\tConvertToUCS((__le16 *) pSMB->fileName, fileName,\n\t\t\t\tPATH_MAX, nls_codepage);\n\t\tname_len++;     /* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(fileName, PATH_MAX);\n\t\tname_len++;     /* trailing null */\n\t\tstrncpy(pSMB->fileName, fileName, name_len);\n\t}\n\tpSMB->attr = cpu_to_le16(dos_attrs);\n\tpSMB->BufferFormat = 0x04;\n\tinc_rfc1001_len(pSMB, name_len + 1);\n\tpSMB->ByteCount = cpu_to_le16(name_len + 1);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcFYI(1, \"Error in LegacySetAttr = %d\", rc);\n\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto SetAttrLgcyRetry;\n\n\treturn rc;\n}\n#endif /* temporarily unneeded SetAttr legacy function */\n\nstatic void\ncifs_fill_unix_set_info(FILE_UNIX_BASIC_INFO *data_offset,\n\t\t\tconst struct cifs_unix_set_info_args *args)\n{\n\tu64 mode = args->mode;\n\n\t/*\n\t * Samba server ignores set of file size to zero due to bugs in some\n\t * older clients, but we should be precise - we use SetFileSize to\n\t * set file size and do not want to truncate file size to zero\n\t * accidentally as happened on one Samba server beta by putting\n\t * zero instead of -1 here\n\t */\n\tdata_offset->EndOfFile = cpu_to_le64(NO_CHANGE_64);\n\tdata_offset->NumOfBytes = cpu_to_le64(NO_CHANGE_64);\n\tdata_offset->LastStatusChange = cpu_to_le64(args->ctime);\n\tdata_offset->LastAccessTime = cpu_to_le64(args->atime);\n\tdata_offset->LastModificationTime = cpu_to_le64(args->mtime);\n\tdata_offset->Uid = cpu_to_le64(args->uid);\n\tdata_offset->Gid = cpu_to_le64(args->gid);\n\t/* better to leave device as zero when it is  */\n\tdata_offset->DevMajor = cpu_to_le64(MAJOR(args->device));\n\tdata_offset->DevMinor = cpu_to_le64(MINOR(args->device));\n\tdata_offset->Permissions = cpu_to_le64(mode);\n\n\tif (S_ISREG(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_FILE);\n\telse if (S_ISDIR(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_DIR);\n\telse if (S_ISLNK(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_SYMLINK);\n\telse if (S_ISCHR(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_CHARDEV);\n\telse if (S_ISBLK(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_BLOCKDEV);\n\telse if (S_ISFIFO(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_FIFO);\n\telse if (S_ISSOCK(mode))\n\t\tdata_offset->Type = cpu_to_le32(UNIX_SOCKET);\n}\n\nint\nCIFSSMBUnixSetFileInfo(const int xid, struct cifs_tcon *tcon,\n\t\t       const struct cifs_unix_set_info_args *args,\n\t\t       u16 fid, u32 pid_of_opener)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tFILE_UNIX_BASIC_INFO *data_offset;\n\tint rc = 0;\n\tu16 params, param_offset, offset, byte_count, count;\n\n\tcFYI(1, \"Set Unix Info (via SetFileInfo)\");\n\trc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid_of_opener);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid_of_opener >> 16));\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tdata_offset = (FILE_UNIX_BASIC_INFO *)\n\t\t\t\t((char *)(&pSMB->hdr.Protocol) + offset);\n\tcount = sizeof(FILE_UNIX_BASIC_INFO);\n\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find max SMB PDU from sess */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->Fid = fid;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_UNIX_BASIC);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\tcifs_fill_unix_set_info(data_offset, args);\n\n\trc = SendReceiveNoRsp(xid, tcon->ses, (struct smb_hdr *) pSMB, 0);\n\tif (rc)\n\t\tcFYI(1, \"Send error in Set Time (SetFileInfo) = %d\", rc);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\n\treturn rc;\n}\n\nint\nCIFSSMBUnixSetPathInfo(const int xid, struct cifs_tcon *tcon, char *fileName,\n\t\t       const struct cifs_unix_set_info_args *args,\n\t\t       const struct nls_table *nls_codepage, int remap)\n{\n\tTRANSACTION2_SPI_REQ *pSMB = NULL;\n\tTRANSACTION2_SPI_RSP *pSMBr = NULL;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tFILE_UNIX_BASIC_INFO *data_offset;\n\t__u16 params, param_offset, offset, count, byte_count;\n\n\tcFYI(1, \"In SetUID/GID/Mode\");\nsetPermsRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUCS((__le16 *) pSMB->FileName, fileName,\n\t\t\t\t     PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(fileName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, fileName, name_len);\n\t}\n\n\tparams = 6 + name_len;\n\tcount = sizeof(FILE_UNIX_BASIC_INFO);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\tdata_offset =\n\t    (FILE_UNIX_BASIC_INFO *) ((char *) &pSMB->hdr.Protocol +\n\t\t\t\t      offset);\n\tmemset(data_offset, 0, count);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_UNIX_BASIC);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\n\tcifs_fill_unix_set_info(data_offset, args);\n\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcFYI(1, \"SetPathInfo (perms) returned %d\", rc);\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto setPermsRetry;\n\treturn rc;\n}\n\n#ifdef CONFIG_CIFS_XATTR\n/*\n * Do a path-based QUERY_ALL_EAS call and parse the result. This is a common\n * function used by listxattr and getxattr type calls. When ea_name is set,\n * it looks for that attribute name and stuffs that value into the EAData\n * buffer. When ea_name is NULL, it stuffs a list of attribute names into the\n * buffer. In both cases, the return value is either the length of the\n * resulting data or a negative error code. If EAData is a NULL pointer then\n * the data isn't copied to it, but the length is returned.\n */\nssize_t\nCIFSSMBQAllEAs(const int xid, struct cifs_tcon *tcon,\n\t\tconst unsigned char *searchName, const unsigned char *ea_name,\n\t\tchar *EAData, size_t buf_size,\n\t\tconst struct nls_table *nls_codepage, int remap)\n{\n\t\t/* BB assumes one setup word */\n\tTRANSACTION2_QPI_REQ *pSMB = NULL;\n\tTRANSACTION2_QPI_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\tint list_len;\n\tstruct fealist *ea_response_data;\n\tstruct fea *temp_fea;\n\tchar *temp_ptr;\n\tchar *end_of_smb;\n\t__u16 params, byte_count, data_offset;\n\tunsigned int ea_name_len = ea_name ? strlen(ea_name) : 0;\n\n\tcFYI(1, \"In Query All EAs path %s\", searchName);\nQAllEAsRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tlist_len =\n\t\t    cifsConvertToUCS((__le16 *) pSMB->FileName, searchName,\n\t\t\t\t     PATH_MAX, nls_codepage, remap);\n\t\tlist_len++;\t/* trailing null */\n\t\tlist_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tlist_len = strnlen(searchName, PATH_MAX);\n\t\tlist_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, searchName, list_len);\n\t}\n\n\tparams = 2 /* level */ + 4 /* reserved */ + list_len /* includes NUL */;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(CIFSMaxBufSize);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\tstruct smb_com_transaction2_qpi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_PATH_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_INFO_QUERY_ALL_EAS);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcFYI(1, \"Send error in QueryAllEAs = %d\", rc);\n\t\tgoto QAllEAsOut;\n\t}\n\n\n\t/* BB also check enough total bytes returned */\n\t/* BB we need to improve the validity checking\n\tof these trans2 responses */\n\n\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\tif (rc || get_bcc(&pSMBr->hdr) < 4) {\n\t\trc = -EIO;\t/* bad smb */\n\t\tgoto QAllEAsOut;\n\t}\n\n\t/* check that length of list is not more than bcc */\n\t/* check that each entry does not go beyond length\n\t   of list */\n\t/* check that each element of each entry does not\n\t   go beyond end of list */\n\t/* validate_trans2_offsets() */\n\t/* BB check if start of smb + data_offset > &bcc+ bcc */\n\n\tdata_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\tea_response_data = (struct fealist *)\n\t\t\t\t(((char *) &pSMBr->hdr.Protocol) + data_offset);\n\n\tlist_len = le32_to_cpu(ea_response_data->list_len);\n\tcFYI(1, \"ea length %d\", list_len);\n\tif (list_len <= 8) {\n\t\tcFYI(1, \"empty EA list returned from server\");\n\t\tgoto QAllEAsOut;\n\t}\n\n\t/* make sure list_len doesn't go past end of SMB */\n\tend_of_smb = (char *)pByteArea(&pSMBr->hdr) + get_bcc(&pSMBr->hdr);\n\tif ((char *)ea_response_data + list_len > end_of_smb) {\n\t\tcFYI(1, \"EA list appears to go beyond SMB\");\n\t\trc = -EIO;\n\t\tgoto QAllEAsOut;\n\t}\n\n\t/* account for ea list len */\n\tlist_len -= 4;\n\ttemp_fea = ea_response_data->list;\n\ttemp_ptr = (char *)temp_fea;\n\twhile (list_len > 0) {\n\t\tunsigned int name_len;\n\t\t__u16 value_len;\n\n\t\tlist_len -= 4;\n\t\ttemp_ptr += 4;\n\t\t/* make sure we can read name_len and value_len */\n\t\tif (list_len < 0) {\n\t\t\tcFYI(1, \"EA entry goes beyond length of list\");\n\t\t\trc = -EIO;\n\t\t\tgoto QAllEAsOut;\n\t\t}\n\n\t\tname_len = temp_fea->name_len;\n\t\tvalue_len = le16_to_cpu(temp_fea->value_len);\n\t\tlist_len -= name_len + 1 + value_len;\n\t\tif (list_len < 0) {\n\t\t\tcFYI(1, \"EA entry goes beyond length of list\");\n\t\t\trc = -EIO;\n\t\t\tgoto QAllEAsOut;\n\t\t}\n\n\t\tif (ea_name) {\n\t\t\tif (ea_name_len == name_len &&\n\t\t\t    strncmp(ea_name, temp_ptr, name_len) == 0) {\n\t\t\t\ttemp_ptr += name_len + 1;\n\t\t\t\trc = value_len;\n\t\t\t\tif (buf_size == 0)\n\t\t\t\t\tgoto QAllEAsOut;\n\t\t\t\tif ((size_t)value_len > buf_size) {\n\t\t\t\t\trc = -ERANGE;\n\t\t\t\t\tgoto QAllEAsOut;\n\t\t\t\t}\n\t\t\t\tmemcpy(EAData, temp_ptr, value_len);\n\t\t\t\tgoto QAllEAsOut;\n\t\t\t}\n\t\t} else {\n\t\t\t/* account for prefix user. and trailing null */\n\t\t\trc += (5 + 1 + name_len);\n\t\t\tif (rc < (int) buf_size) {\n\t\t\t\tmemcpy(EAData, \"user.\", 5);\n\t\t\t\tEAData += 5;\n\t\t\t\tmemcpy(EAData, temp_ptr, name_len);\n\t\t\t\tEAData += name_len;\n\t\t\t\t/* null terminate name */\n\t\t\t\t*EAData = 0;\n\t\t\t\t++EAData;\n\t\t\t} else if (buf_size == 0) {\n\t\t\t\t/* skip copy - calc size only */\n\t\t\t} else {\n\t\t\t\t/* stop before overrun buffer */\n\t\t\t\trc = -ERANGE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ttemp_ptr += name_len + 1 + value_len;\n\t\ttemp_fea = (struct fea *)temp_ptr;\n\t}\n\n\t/* didn't find the named attribute */\n\tif (ea_name)\n\t\trc = -ENODATA;\n\nQAllEAsOut:\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto QAllEAsRetry;\n\n\treturn (ssize_t)rc;\n}\n\nint\nCIFSSMBSetEA(const int xid, struct cifs_tcon *tcon, const char *fileName,\n\t     const char *ea_name, const void *ea_value,\n\t     const __u16 ea_value_len, const struct nls_table *nls_codepage,\n\t     int remap)\n{\n\tstruct smb_com_transaction2_spi_req *pSMB = NULL;\n\tstruct smb_com_transaction2_spi_rsp *pSMBr = NULL;\n\tstruct fealist *parm_data;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, param_offset, byte_count, offset, count;\n\n\tcFYI(1, \"In SetEA\");\nSetEARetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUCS((__le16 *) pSMB->FileName, fileName,\n\t\t\t\t     PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(fileName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, fileName, name_len);\n\t}\n\n\tparams = 6 + name_len;\n\n\t/* done calculating parms using name_len of file name,\n\tnow use name_len to calculate length of ea name\n\twe are going to create in the inode xattrs */\n\tif (ea_name == NULL)\n\t\tname_len = 0;\n\telse\n\t\tname_len = strnlen(ea_name, 255);\n\n\tcount = sizeof(*parm_data) + ea_value_len + name_len;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find max SMB PDU from sess */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\tpSMB->InformationLevel =\n\t\tcpu_to_le16(SMB_SET_FILE_EA);\n\n\tparm_data =\n\t\t(struct fealist *) (((char *) &pSMB->hdr.Protocol) +\n\t\t\t\t       offset);\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tparm_data->list_len = cpu_to_le32(count);\n\tparm_data->list[0].EA_flags = 0;\n\t/* we checked above that name len is less than 255 */\n\tparm_data->list[0].name_len = (__u8)name_len;\n\t/* EA names are always ASCII */\n\tif (ea_name)\n\t\tstrncpy(parm_data->list[0].name, ea_name, name_len);\n\tparm_data->list[0].name[name_len] = 0;\n\tparm_data->list[0].value_len = cpu_to_le16(ea_value_len);\n\t/* caller ensures that ea_value_len is less than 64K but\n\twe need to ensure that it fits within the smb */\n\n\t/*BB add length check to see if it would fit in\n\t     negotiated SMB buffer size BB */\n\t/* if (ea_value_len > buffer_size - 512 (enough for header)) */\n\tif (ea_value_len)\n\t\tmemcpy(parm_data->list[0].name+name_len+1,\n\t\t       ea_value, ea_value_len);\n\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcFYI(1, \"SetPathInfo (EA) returned %d\", rc);\n\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto SetEARetry;\n\n\treturn rc;\n}\n#endif\n\n#ifdef CONFIG_CIFS_DNOTIFY_EXPERIMENTAL /* BB unused temporarily */\n/*\n *\tYears ago the kernel added a \"dnotify\" function for Samba server,\n *\tto allow network clients (such as Windows) to display updated\n *\tlists of files in directory listings automatically when\n *\tfiles are added by one user when another user has the\n *\tsame directory open on their desktop.  The Linux cifs kernel\n *\tclient hooked into the kernel side of this interface for\n *\tthe same reason, but ironically when the VFS moved from\n *\t\"dnotify\" to \"inotify\" it became harder to plug in Linux\n *\tnetwork file system clients (the most obvious use case\n *\tfor notify interfaces is when multiple users can update\n *\tthe contents of the same directory - exactly what network\n *\tfile systems can do) although the server (Samba) could\n *\tstill use it.  For the short term we leave the worker\n *\tfunction ifdeffed out (below) until inotify is fixed\n *\tin the VFS to make it easier to plug in network file\n *\tsystem clients.  If inotify turns out to be permanently\n *\tincompatible for network fs clients, we could instead simply\n *\texpose this config flag by adding a future cifs (and smb2) notify ioctl.\n */\nint CIFSSMBNotify(const int xid, struct cifs_tcon *tcon,\n\t\t  const int notify_subdirs, const __u16 netfid,\n\t\t  __u32 filter, struct file *pfile, int multishot,\n\t\t  const struct nls_table *nls_codepage)\n{\n\tint rc = 0;\n\tstruct smb_com_transaction_change_notify_req *pSMB = NULL;\n\tstruct smb_com_ntransaction_change_notify_rsp *pSMBr = NULL;\n\tstruct dir_notify_req *dnotify_req;\n\tint bytes_returned;\n\n\tcFYI(1, \"In CIFSSMBNotify for file handle %d\", (int)netfid);\n\trc = smb_init(SMB_COM_NT_TRANSACT, 23, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->TotalParameterCount = 0 ;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le32(2);\n\t/* BB find exact data count max from sess structure BB */\n\tpSMB->MaxDataCount = 0; /* same in little endian or be */\n/* BB VERIFY verify which is correct for above BB */\n\tpSMB->MaxDataCount = cpu_to_le32((tcon->ses->server->maxBuf -\n\t\t\t\t\t     MAX_CIFS_HDR_SIZE) & 0xFFFFFF00);\n\n\tpSMB->MaxSetupCount = 4;\n\tpSMB->Reserved = 0;\n\tpSMB->ParameterOffset = 0;\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 4; /* single byte does not need le conversion */\n\tpSMB->SubCommand = cpu_to_le16(NT_TRANSACT_NOTIFY_CHANGE);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tif (notify_subdirs)\n\t\tpSMB->WatchTree = 1; /* one byte - no le conversion needed */\n\tpSMB->Reserved2 = 0;\n\tpSMB->CompletionFilter = cpu_to_le32(filter);\n\tpSMB->Fid = netfid; /* file handle always le */\n\tpSMB->ByteCount = 0;\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *)pSMBr, &bytes_returned,\n\t\t\t CIFS_ASYNC_OP);\n\tif (rc) {\n\t\tcFYI(1, \"Error in Notify = %d\", rc);\n\t} else {\n\t\t/* Add file to outstanding requests */\n\t\t/* BB change to kmem cache alloc */\n\t\tdnotify_req = kmalloc(\n\t\t\t\t\t\tsizeof(struct dir_notify_req),\n\t\t\t\t\t\t GFP_KERNEL);\n\t\tif (dnotify_req) {\n\t\t\tdnotify_req->Pid = pSMB->hdr.Pid;\n\t\t\tdnotify_req->PidHigh = pSMB->hdr.PidHigh;\n\t\t\tdnotify_req->Mid = pSMB->hdr.Mid;\n\t\t\tdnotify_req->Tid = pSMB->hdr.Tid;\n\t\t\tdnotify_req->Uid = pSMB->hdr.Uid;\n\t\t\tdnotify_req->netfid = netfid;\n\t\t\tdnotify_req->pfile = pfile;\n\t\t\tdnotify_req->filter = filter;\n\t\t\tdnotify_req->multishot = multishot;\n\t\t\tspin_lock(&GlobalMid_Lock);\n\t\t\tlist_add_tail(&dnotify_req->lhead,\n\t\t\t\t\t&GlobalDnotifyReqList);\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t} else\n\t\t\trc = -ENOMEM;\n\t}\n\tcifs_buf_release(pSMB);\n\treturn rc;\n}\n#endif /* was needed for dnotify, and will be needed for inotify when VFS fix */\n"], "filenames": ["fs/cifs/cifssmb.c"], "buggy_code_start_loc": [4082], "buggy_code_end_loc": [4083], "fixing_code_start_loc": [4082], "fixing_code_end_loc": [4084], "type": "CWE-119", "message": "Integer signedness error in the CIFSFindNext function in fs/cifs/cifssmb.c in the Linux kernel before 3.1 allows remote CIFS servers to cause a denial of service (memory corruption) or possibly have unspecified other impact via a large length value in a response to a read request for a directory.", "other": {"cve": {"id": "CVE-2011-3191", "sourceIdentifier": "secalert@redhat.com", "published": "2012-05-24T23:55:02.260", "lastModified": "2023-02-13T04:32:37.470", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Integer signedness error in the CIFSFindNext function in fs/cifs/cifssmb.c in the Linux kernel before 3.1 allows remote CIFS servers to cause a denial of service (memory corruption) or possibly have unspecified other impact via a large length value in a response to a read request for a directory."}, {"lang": "es", "value": "Error de signo de entero en la funci\u00f3n CIFSFindNext en fs/cifs/cifssmb.c en el kernel de Linux antes de v3.1 permite a los servidores CIFS remotos provocar una denegaci\u00f3n de servicio (corrupci\u00f3n de memoria) o posiblemente tener un impacto no especificado a trav\u00e9s de un valor de gran longitud en una respuesta a una petici\u00f3n de lectura de un directorio."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:A/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 8.3}, "baseSeverity": "HIGH", "exploitabilityScore": 6.5, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.0.5", "matchCriteriaId": "CF999D08-E96F-45C9-8FEE-07907A1BB6E6"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:4.0:*:*:*:*:*:*:*", "matchCriteriaId": "6172AF57-B26D-45F8-BE3A-F75ABDF28F49"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=9438fabb73eb48055b58b89fc51e0bc4db22fabd", "source": "secalert@redhat.com"}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.1", "source": "secalert@redhat.com", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2011/08/24/2", "source": "secalert@redhat.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=732869", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/9438fabb73eb48055b58b89fc51e0bc4db22fabd", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/9438fabb73eb48055b58b89fc51e0bc4db22fabd"}}