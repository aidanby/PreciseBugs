{"buggy_code": ["requests==2.28.1\n", "# This holds all the things that do stuff for code scanning API\n\n# Imports\nimport csv\nimport requests\n\n\ndef list_repo_code_scanning_alerts(api_endpoint, github_pat, repo_name):\n    \"\"\"\n    Get a list of all code scanning alerts on a given repository.\n\n    Inputs:\n    - API endpoint (for GHES/GHAE compatibility)\n    - PAT of appropriate scope\n    - Repository name\n\n    Outputs:\n    - List of _all_ code scanning alerts on the repository\n    \"\"\"\n\n    # Get code scanning alerts\n    url = \"{}/repos/{}/code-scanning/alerts?per_page=100&page=1\".format(\n        api_endpoint, repo_name\n    )\n    headers = {\n        \"Authorization\": \"token {}\".format(github_pat),\n        \"Accept\": \"application/vnd.github.v3+json\",\n    }\n    response = requests.get(url, headers=headers)\n    if response.status_code == 404:\n        return \"need permission to access,{}\".format(repo_name)  # don't have permission\n    if response.status_code == 403:\n        return \"need to enable GHAS,{}\".format(repo_name)  # no GHAS\n    response_json = response.json()\n    while \"next\" in response.links.keys():\n        response = requests.get(response.links[\"next\"][\"url\"], headers=headers)\n        response_json.extend(response.json())\n\n    # Return code scanning alerts\n    return response_json\n\n\ndef write_repo_cs_list(cs_list):\n    \"\"\"\n    Write a list of code scanning alerts to a csv file.\n\n    Inputs:\n    - List of code scanning alerts\n\n    Outputs:\n    - CSV file of code scanning alerts\n    \"\"\"\n\n    # Write code scanning alerts to csv file\n    with open(\"cs_list.csv\", \"w\") as f:\n        writer = csv.writer(f)\n        writer.writerow(\n            [\n                \"number\",\n                \"created_at\",\n                \"html_url\",\n                \"state\",\n                \"fixed_at\",\n                \"dismissed_by\",\n                \"dismissed_at\",\n                \"dismissed_reason\",\n                \"rule_id\",\n                \"rule_severity\",\n                \"rule_tags\",\n                \"rule_description\",\n                \"rule_name\",\n                \"tool_name\",\n                \"tool_version\",\n                \"most_recent_instance_ref\",\n                \"most_recent_instance_state\",\n                \"most_recent_instance_sha\",\n                \"instances_url\",\n            ]\n        )\n        for cs in cs_list:\n            if cs[\"state\"] == \"open\":\n                cs[\"fixed_at\"] = \"none\"\n                cs[\"dismissed_by\"] = \"none\"\n                cs[\"dismissed_at\"] = \"none\"\n                cs[\"dismissed_reason\"] = \"none\"\n            writer.writerow(\n                [\n                    cs[\"number\"],\n                    cs[\"created_at\"],\n                    cs[\"html_url\"],\n                    cs[\"state\"],\n                    cs[\"fixed_at\"],\n                    cs[\"dismissed_by\"],\n                    cs[\"dismissed_at\"],\n                    cs[\"dismissed_reason\"],\n                    cs[\"rule\"][\"id\"],\n                    cs[\"rule\"][\"severity\"],\n                    cs[\"rule\"][\"tags\"],\n                    cs[\"rule\"][\"description\"],\n                    cs[\"rule\"][\"name\"],\n                    cs[\"tool\"][\"name\"],\n                    cs[\"tool\"][\"version\"],\n                    cs[\"most_recent_instance\"][\"ref\"],\n                    cs[\"most_recent_instance\"][\"state\"],\n                    cs[\"most_recent_instance\"][\"commit_sha\"],\n                    cs[\"instances_url\"],\n                ]\n            )\n\n\ndef list_org_code_scanning_alerts(api_endpoint, github_pat, org_name):\n    \"\"\"\n    Get a list of all code scanning alerts on a given organization.\n\n    Inputs:\n    - API endpoint (for GHES/GHAE compatibility)\n    - PAT of appropriate scope\n    - Organization name\n\n    Outputs:\n    - List of _all_ code scanning alerts on the organization\n    \"\"\"\n\n    # Get code scanning alerts\n    url = \"{}/orgs/{}/code-scanning/alerts?per_page=100&page=1\".format(\n        api_endpoint, org_name\n    )\n    headers = {\n        \"Authorization\": \"token {}\".format(github_pat),\n        \"Accept\": \"application/vnd.github.v3+json\",\n    }\n    response = requests.get(url, headers=headers)\n    response_json = response.json()\n    while \"next\" in response.links.keys():\n        response = requests.get(response.links[\"next\"][\"url\"], headers=headers)\n        response_json.extend(response.json())\n\n    print(\"Found {} code scanning alerts in {}\".format(len(response_json), org_name))\n\n    # Return code scanning alerts\n    return response_json\n\n\ndef write_org_cs_list(cs_list):\n    \"\"\"\n    Write a list of code scanning alerts to a csv file.\n\n    Inputs:\n    - List of code scanning alerts\n\n    Outputs:\n    - CSV file of code scanning alerts\n    \"\"\"\n\n    # Write code scanning alerts to csv file\n    with open(\"cs_list.csv\", \"w\") as f:\n        writer = csv.writer(f)\n        writer.writerow(\n            [\n                \"number\",\n                \"created_at\",\n                \"html_url\",\n                \"state\",\n                \"fixed_at\",\n                \"dismissed_by\",\n                \"dismissed_at\",\n                \"dismissed_reason\",\n                \"rule_id\",\n                \"rule_severity\",\n                \"rule_tags\",\n                \"rule_description\",\n                \"rule_name\",\n                \"tool_name\",\n                \"tool_version\",\n                \"most_recent_instance_ref\",\n                \"most_recent_instance_state\",\n                \"most_recent_instance_sha\",\n                \"instances_url\",\n                \"repo_name\",\n                \"repo_owner\",\n                \"repo_owner_type\",\n                \"repo_owner_isadmin\",\n                \"repo_url\",\n                \"repo_isfork\",\n                \"repo_isprivate\",\n            ]\n        )\n        for cs in cs_list:\n            if cs[\"state\"] == \"open\":\n                cs[\"fixed_at\"] = \"none\"\n                cs[\"dismissed_by\"] = \"none\"\n                cs[\"dismissed_at\"] = \"none\"\n                cs[\"dismissed_reason\"] = \"none\"\n            writer.writerow(\n                [\n                    cs[\"number\"],\n                    cs[\"created_at\"],\n                    cs[\"html_url\"],\n                    cs[\"state\"],\n                    cs[\"fixed_at\"],\n                    cs[\"dismissed_by\"],\n                    cs[\"dismissed_at\"],\n                    cs[\"dismissed_reason\"],\n                    cs[\"rule\"][\"id\"],\n                    cs[\"rule\"][\"severity\"],\n                    cs[\"rule\"][\"tags\"],\n                    cs[\"rule\"][\"description\"],\n                    cs[\"rule\"][\"name\"],\n                    cs[\"tool\"][\"name\"],\n                    cs[\"tool\"][\"version\"],\n                    cs[\"most_recent_instance\"][\"ref\"],\n                    cs[\"most_recent_instance\"][\"state\"],\n                    cs[\"most_recent_instance\"][\"commit_sha\"],\n                    cs[\"instances_url\"],\n                    cs[\"repository\"][\"full_name\"],\n                    cs[\"repository\"][\"owner\"][\"login\"],\n                    cs[\"repository\"][\"owner\"][\"type\"],\n                    cs[\"repository\"][\"owner\"][\"site_admin\"],\n                    cs[\"repository\"][\"html_url\"],\n                    str(cs[\"repository\"][\"fork\"]),\n                    str(cs[\"repository\"][\"private\"]),\n                ]\n            )\n\n\ndef list_enterprise_server_code_scanning_alerts(api_endpoint, github_pat, repo_list):\n    \"\"\"\n    Get a list of all code scanning alerts on a given enterprise.\n\n    Inputs:\n    - API endpoint (for GHES/GHAE compatibility)\n    - PAT of appropriate scope\n    - Repository list in \"org/repo\" format (from enterprise.get_repo_report)\n\n    Outputs:\n    - List of _all_ code scanning alerts in enterprise that PAT user can access\n\n    Notes:\n    - Use `ghe-org-admin-promote` to gain ownership of all organizations.\n    - Personal repos will not be reported on, as they cannot use code scanning.\n    \"\"\"\n\n    alerts = []\n    while True:\n        try:\n            repo_name = next(repo_list)  # skip the header by putting this up front\n            alerts.append(\n                list_repo_code_scanning_alerts(api_endpoint, github_pat, repo_name)\n            )\n        except StopIteration:\n            break\n        except Exception as e:\n            print(e)\n    return alerts\n\n\ndef write_enterprise_server_cs_list(cs_list):\n    \"\"\"\n    Write a list of code scanning alerts to a csv file.\n\n    Inputs:\n    - List from list_enterprise_code_scanning_alerts function, which contains\n        strings and lists of dictionaries for the alerts.\n\n    Outputs:\n    - CSV file of code scanning alerts\n    - CSV file of repositories not accessible or without code scanning enabled\n    \"\"\"\n\n    for alert_list in cs_list:\n        if type(alert_list) == list:\n            print(alert_list)\n            with open(\"cs_list.csv\", \"a\") as f:\n                writer = csv.writer(f)\n                writer.writerow(\n                    [\n                        \"repository\",\n                        \"repo_id\",\n                        \"number\",\n                        \"created_at\",\n                        \"html_url\",\n                        \"state\",\n                        \"fixed_at\",\n                        \"dismissed_by\",\n                        \"dismissed_at\",\n                        \"dismissed_reason\",\n                        \"rule_id\",\n                        \"rule_severity\",\n                        \"rule_tags\",\n                        \"rule_description\",\n                        \"rule_name\",\n                        \"tool_name\",\n                        \"tool_version\",\n                        \"most_recent_instance_ref\",\n                        \"most_recent_instance_state\",\n                        \"most_recent_instance_sha\",\n                        \"instances_url\",\n                    ]\n                )\n                for cs in alert_list:  # loop through each alert in the list\n                    if cs[\"state\"] == \"open\":\n                        cs[\"fixed_at\"] = \"none\"\n                        cs[\"dismissed_by\"] = \"none\"\n                        cs[\"dismissed_at\"] = \"none\"\n                        cs[\"dismissed_reason\"] = \"none\"\n                    writer.writerow(\n                        [\n                            cs[\"repository\"][\"full_name\"],\n                            cs[\"repository\"][\"id\"],\n                            cs[\"number\"],\n                            cs[\"created_at\"],\n                            cs[\"html_url\"],\n                            cs[\"state\"],\n                            cs[\"fixed_at\"],\n                            cs[\"dismissed_by\"],\n                            cs[\"dismissed_at\"],\n                            cs[\"dismissed_reason\"],\n                            cs[\"rule\"][\"id\"],\n                            cs[\"rule\"][\"severity\"],\n                            cs[\"rule\"][\"tags\"],\n                            cs[\"rule\"][\"description\"],\n                            cs[\"rule\"][\"name\"],\n                            cs[\"tool\"][\"name\"],\n                            cs[\"tool\"][\"version\"],\n                            cs[\"most_recent_instance\"][\"ref\"],\n                            cs[\"most_recent_instance\"][\"state\"],\n                            cs[\"most_recent_instance\"][\"commit_sha\"],\n                            cs[\"instances_url\"],\n                        ]\n                    )\n        else:\n            with open(\"excluded_repos.csv\", \"a\") as g:\n                writer = csv.writer(g)\n                writer.writerow([alert_list])\n\n\ndef list_enterprise_cloud_code_scanning_alerts(\n    api_endpoint, github_pat, enterprise_slug\n):\n    \"\"\"\n    Get a list of all code scanning alerts on a given enterprise.\n\n    Inputs:\n    - API endpoint (for GHES/GHAE compatibility)\n    - PAT of appropriate scope\n\n    Outputs:\n    - List of _all_ code scanning alerts in enterprise that PAT user can access\n    \"\"\"\n\n    # Get code scanning alerts\n    url = \"{}/enterprises/{}/code-scanning/alerts?per_page=100&page=1\".format(\n        api_endpoint, enterprise_slug\n    )\n    headers = {\n        \"Authorization\": \"token {}\".format(github_pat),\n        \"Accept\": \"application/vnd.github.v3+json\",\n    }\n    response = requests.get(url, headers=headers)\n    response_json = response.json()\n    while \"next\" in response.links.keys():\n        response = requests.get(response.links[\"next\"][\"url\"], headers=headers)\n        response_json.extend(response.json())\n\n    print(\n        \"Found {} code scanning alerts in {}\".format(\n            len(response_json), enterprise_slug\n        )\n    )\n\n    # Return code scanning alerts\n    return response_json\n\n\ndef write_enterprise_cloud_cs_list(cs_list):\n    \"\"\"\n    Write a list of code scanning alerts to a csv file.\n\n    Inputs:\n    - List from list_enterprise_code_scanning_alerts function, which contains\n        strings and lists of dictionaries for the alerts.\n\n    Outputs:\n    - CSV file of code scanning alerts\n    - CSV file of repositories not accessible or without code scanning enabled\n    \"\"\"\n\n    with open(\"cs_list.csv\", \"a\") as f:\n        writer = csv.writer(f)\n        writer.writerow(\n            [\n                \"repository\",\n                \"repo_id\",\n                \"number\",\n                \"created_at\",\n                \"html_url\",\n                \"state\",\n                \"fixed_at\",\n                \"dismissed_by\",\n                \"dismissed_at\",\n                \"dismissed_reason\",\n                \"rule_id\",\n                \"rule_severity\",\n                \"rule_tags\",\n                \"rule_description\",\n                \"rule_name\",\n                \"tool_name\",\n                \"tool_version\",\n                \"most_recent_instance_ref\",\n                \"most_recent_instance_state\",\n                \"most_recent_instance_sha\",\n                \"instances_url\",\n            ]\n        )\n        for cs in cs_list:  # loop through each alert in the list\n            if cs[\"state\"] == \"open\":\n                cs[\"fixed_at\"] = \"none\"\n                cs[\"dismissed_by\"] = \"none\"\n                cs[\"dismissed_at\"] = \"none\"\n                cs[\"dismissed_reason\"] = \"none\"\n            writer.writerow(\n                [\n                    cs[\"repository\"][\"full_name\"],\n                    cs[\"repository\"][\"id\"],\n                    cs[\"number\"],\n                    cs[\"created_at\"],\n                    cs[\"html_url\"],\n                    cs[\"state\"],\n                    cs[\"fixed_at\"],\n                    cs[\"dismissed_by\"],\n                    cs[\"dismissed_at\"],\n                    cs[\"dismissed_reason\"],\n                    cs[\"rule\"][\"id\"],\n                    cs[\"rule\"][\"severity\"],\n                    cs[\"rule\"][\"tags\"],\n                    cs[\"rule\"][\"description\"],\n                    cs[\"rule\"][\"name\"],\n                    cs[\"tool\"][\"name\"],\n                    cs[\"tool\"][\"version\"],\n                    cs[\"most_recent_instance\"][\"ref\"],\n                    cs[\"most_recent_instance\"][\"state\"],\n                    cs[\"most_recent_instance\"][\"commit_sha\"],\n                    cs[\"instances_url\"],\n                ]\n            )\n        else:\n            with open(\"excluded_repos.csv\", \"a\") as g:\n                writer = csv.writer(g)\n                writer.writerow([cs])\n", "# This holds all the logic for the various enterprise differences.\n\n# Imports\nimport csv\nfrom time import sleep\nimport requests\n\n\ndef get_enterprise_version(api_endpoint):\n    \"\"\"\n    Get the version of GitHub Enterprise.  It'll be used to account for\n    differences between GHES and GHAE and GHEC, like the organization secret\n    scanning API not existing outside GHEC.\n\n    GitHub AE returns \"GitHub AE\" as of M2\n    GHES returns the version of GHES that's installed (e.g. \"3.4.0\")\n    \"\"\"\n    if api_endpoint != \"https://api.github.com\":\n        url = \"{}/meta\".format(api_endpoint)\n        response = requests.get(url)\n        if \"installed_version\" in response.json():\n            return response.json()[\"installed_version\"]\n        else:\n            return \"unknown version of GitHub\"\n    else:\n        return \"GHEC\"\n\n\ndef get_repo_report(url, github_pat):\n    \"\"\"\n    Get the `all_repositories.csv` report from GHES / GHAE.\n    \"\"\"\n    headers = {\n        \"Accept\": \"application/vnd.github.v3+json\",\n        \"Authorization\": \"token {}\".format(github_pat),\n    }\n    url = \"{}/stafftools/reports/all_repositories.csv\".format(url)\n    response = requests.get(url, headers=headers)\n    if response.status_code == 202:  # report needs to be generated\n        while response.status_code == 202:\n            print(\"Waiting a minute for the report to be generated ...\")\n            sleep(60)\n            response = requests.get(url, headers=headers)\n    elif response.status_code == 200:  # report is ready\n        print(\"Report is ready!  Reading it now ...\")\n        for row in csv.reader(response.text.splitlines()):  # skip user repos\n            if row[2] == \"Organization\":\n                yield \"{}/{}\".format(row[3], row[5])\n            else:\n                pass\n    else:  # something went wrong with fetching the report\n        exit(\"Error: {}\".format(response.status_code))\n", "# This holds all the things that do stuff for secret scanning API\n\n# Imports\nimport csv\nimport requests\n\n\ndef get_repo_secret_scanning_alerts(api_endpoint, github_pat, repo_name):\n    \"\"\"\n    Get all the secret scanning alerts on a given repository.\n\n    Inputs:\n    - API endpoint (for GHES/GHAE compatibility)\n    - PAT of appropriate scope\n    - Repository name\n\n    Outputs:\n    - List of _all_ secret scanning alerts on the repository\n    \"\"\"\n\n    # Get secret scanning alerts\n    url = \"{}/repos/{}/secret-scanning/alerts?per_page=100&page=1\".format(\n        api_endpoint, repo_name\n    )\n    response = requests.get(\n        url,\n        headers={\n            \"Authorization\": \"token {}\".format(github_pat),\n            \"Accept\": \"application/vnd.github.v3+json\",\n        },\n    )\n    response_json = response.json()\n    # The secret scanning API returns a code of 404 if there are no alerts,\n    # secret scanning is disabled, or the repository is public.\n    if response.status_code == 404:\n        return [\"not found\"]\n    while \"next\" in response.links.keys():\n        response = requests.get(\n            response.links[\"next\"][\"url\"],\n            headers={\n                \"Authorization\": \"token {}\".format(github_pat),\n                \"Accept\": \"application/vnd.github.v3+json\",\n            },\n        )\n        response_json.extend(response.json())\n\n    print(\"Found {} secret scanning alerts in {}\".format(len(response_json), repo_name))\n\n    # Return secret scanning alerts\n    return response_json\n\n\ndef write_repo_secrets_list(secrets_list):\n    \"\"\"\n    Write the list of repository secret scanning alerts to a csv file.\n\n    Inputs:\n    - List of secret scanning alerts\n\n    Outputs:\n    - CSV file of secret scanning alerts\n    \"\"\"\n\n    if secrets_list == [\"not found\"]:\n        print(\"No secret scanning alerts found\")\n        return\n    # Write secret scanning alerts to csv file\n    with open(\"secrets_list.csv\", \"w\") as f:\n        writer = csv.writer(f)\n        writer.writerow(\n            [\n                \"number\",\n                \"created_at\",\n                \"html_url\",\n                \"state\",\n                \"resolution\",\n                \"resolved_at\",\n                \"resolved_by_username\",\n                \"resolved_by_type\",\n                \"resolved_by_isadmin\",\n                \"secret_type\",\n                \"secret_type_display_name\",\n            ]\n        )\n        for alert in secrets_list:\n            if alert[\"state\"] == \"open\":\n                alert[\"resolution\"] = \"none\"\n                alert[\"resolved_at\"] = \"none\"\n                alert[\"resolved_by\"] = {\n                    \"login\": \"none\",\n                    \"type\": \"none\",\n                    \"site_admin\": \"none\",\n                }\n            writer.writerow(\n                [\n                    alert[\"number\"],\n                    alert[\"created_at\"],\n                    alert[\"html_url\"],\n                    alert[\"state\"],\n                    alert[\"resolution\"],\n                    alert[\"resolved_at\"],\n                    alert[\"resolved_by\"][\"login\"],\n                    alert[\"resolved_by\"][\"type\"],\n                    alert[\"resolved_by\"][\"site_admin\"],\n                    alert[\"secret_type\"],\n                    alert[\"secret_type_display_name\"],\n                ]\n            )\n\n\ndef get_org_secret_scanning_alerts(api_endpoint, github_pat, org_name):\n    \"\"\"\n    Get all the secret scanning alerts on a given organization.\n\n    Inputs:\n    - API endpoint (for GHES/GHAE compatibility)\n    - PAT of appropriate scope\n    - Organization name\n\n    Outputs:\n    - List of _all_ secret scanning alerts on the organization\n    \"\"\"\n\n    # Get secret scanning alerts\n    url = \"{}/orgs/{}/secret-scanning/alerts?per_page=100&page=1\".format(\n        api_endpoint, org_name\n    )\n    response = requests.get(\n        url,\n        headers={\n            \"Authorization\": \"token {}\".format(github_pat),\n            \"Accept\": \"application/vnd.github.v3+json\",\n        },\n    )\n    response_json = response.json()\n    # The secret scanning API returns a code of 404 if there are no alerts,\n    # secret scanning is disabled, or the repository is public.\n    if response.status_code == 404:\n        return [\"not found\"]\n    while \"next\" in response.links.keys():\n        response = requests.get(\n            response.links[\"next\"][\"url\"],\n            headers={\n                \"Authorization\": \"token {}\".format(github_pat),\n                \"Accept\": \"application/vnd.github.v3+json\",\n            },\n        )\n        response_json.extend(response.json())\n\n    print(\"Found {} secret scanning alerts in {}\".format(len(response_json), org_name))\n\n    # Return secret scanning alerts\n    return response_json\n\n\ndef write_org_secrets_list(secrets_list):\n    \"\"\"\n    Write the list of organization secret scanning alerts to a csv file.\n\n    Inputs:\n    - List of secret scanning alerts\n\n    Outputs:\n    - CSV file of secret scanning alerts\n    \"\"\"\n\n    if secrets_list == [\"not found\"]:\n        print(\"No secret scanning alerts found\")\n        return\n    # Write secret scanning alerts to csv file\n    with open(\"secrets_list.csv\", \"w\") as f:\n        writer = csv.writer(f)\n        writer.writerow(\n            [\n                \"number\",\n                \"created_at\",\n                \"html_url\",\n                \"state\",\n                \"resolution\",\n                \"resolved_at\",\n                \"resolved_by_username\",\n                \"resolved_by_type\",\n                \"resolved_by_isadmin\",\n                \"secret_type\",\n                \"secret_type_display_name\",\n                \"repo_name\",\n                \"repo_owner\",\n                \"repo_owner_type\",\n                \"repo_owner_isadmin\",\n                \"repo_url\",\n                \"repo_isfork\",\n                \"repo_isprivate\",\n            ]\n        )\n        for alert in secrets_list:\n            if alert[\"state\"] == \"open\":\n                alert[\"resolution\"] = \"none\"\n                alert[\"resolved_at\"] = \"none\"\n                alert[\"resolved_by\"] = {\n                    \"login\": \"none\",\n                    \"type\": \"none\",\n                    \"site_admin\": \"none\",\n                }\n            writer.writerow(\n                [\n                    alert[\"number\"],\n                    alert[\"created_at\"],\n                    alert[\"html_url\"],\n                    alert[\"state\"],\n                    alert[\"resolution\"],\n                    alert[\"resolved_at\"],\n                    alert[\"resolved_by\"][\"login\"],\n                    alert[\"resolved_by\"][\"type\"],\n                    alert[\"resolved_by\"][\"site_admin\"],\n                    alert[\"secret_type\"],\n                    alert[\"secret_type_display_name\"],\n                    alert[\"repository\"][\"full_name\"],\n                    alert[\"repository\"][\"owner\"][\"login\"],\n                    alert[\"repository\"][\"owner\"][\"type\"],\n                    alert[\"repository\"][\"owner\"][\"site_admin\"],\n                    alert[\"repository\"][\"html_url\"],\n                    str(alert[\"repository\"][\"fork\"]),\n                    str(alert[\"repository\"][\"private\"]),\n                ]\n            )\n\n\ndef get_enterprise_secret_scanning_alerts(api_endpoint, github_pat, enterprise_slug):\n    \"\"\"\n    Get all the secret scanning alerts on a given enterprise.\n\n    Inputs:\n    - API endpoint (for GHES/GHAE compatibility)\n    - PAT of appropriate scope\n    - Enterprise slug (enterprise name URL, documented below)\n        - https://docs.github.com/en/rest/reference/enterprise-admin\n\n    Outputs:\n    - List of _all_ secret scanning alerts on the enterprise\n    \"\"\"\n\n    # Get secret scanning alerts\n    url = \"{}/enterprises/{}/secret-scanning/alerts?per_page=100&page=1\".format(\n        api_endpoint, enterprise_slug\n    )\n    response = requests.get(\n        url,\n        headers={\n            \"Authorization\": \"token {}\".format(github_pat),\n            \"Accept\": \"application/vnd.github.v3+json\",\n        },\n    )\n    response_json = response.json()\n    # The secret scanning API returns a code of 404 if there are no alerts,\n    # secret scanning is disabled, or the repository is public.\n    if response.status_code == 404:\n        return [\"not found\"]\n    while \"next\" in response.links.keys():\n        response = requests.get(\n            response.links[\"next\"][\"url\"],\n            headers={\n                \"Authorization\": \"token {}\".format(github_pat),\n                \"Accept\": \"application/vnd.github.v3+json\",\n            },\n        )\n        response_json.extend(response.json())\n\n    print(\n        \"Found {} secret scanning alerts in {} enterprise\".format(\n            len(response_json), enterprise_slug\n        )\n    )\n\n    # Return secret scanning alerts\n    return response_json\n\n\ndef write_enterprise_secrets_list(secrets_list):\n    \"\"\"\n    Write the list of enterprise secret scanning alerts to a csv file.\n\n    Inputs:\n    - List of secret scanning alerts\n\n    Outputs:\n    - CSV file of secret scanning alerts\n    \"\"\"\n\n    if secrets_list == [\"not found\"]:\n        print(\"No secret scanning alerts found\")\n        return\n    # Write secret scanning alerts to csv file\n    with open(\"secrets_list.csv\", \"w\") as f:\n        writer = csv.writer(f)\n        writer.writerow(\n            [\n                \"number\",\n                \"created_at\",\n                \"html_url\",\n                \"state\",\n                \"resolution\",\n                \"resolved_at\",\n                \"resolved_by_username\",\n                \"resolved_by_type\",\n                \"resolved_by_isadmin\",\n                \"secret_type\",\n                \"secret_type_display_name\",\n                \"repo_name\",\n                \"repo_owner\",\n                \"repo_owner_type\",\n                \"repo_owner_isadmin\",\n                \"repo_url\",\n                \"repo_isfork\",\n                \"repo_isprivate\",\n            ]\n        )\n        for alert in secrets_list:\n            if alert[\"state\"] == \"open\":\n                alert[\"resolution\"] = \"none\"\n                alert[\"resolved_at\"] = \"none\"\n                alert[\"resolved_by\"] = {\n                    \"login\": \"none\",\n                    \"type\": \"none\",\n                    \"site_admin\": \"none\",\n                }\n                writer.writerow(\n                    [\n                        alert[\"number\"],\n                        alert[\"created_at\"],\n                        alert[\"html_url\"],\n                        alert[\"state\"],\n                        alert[\"resolution\"],\n                        alert[\"resolved_at\"],\n                        alert[\"resolved_by\"][\"login\"],\n                        alert[\"resolved_by\"][\"type\"],\n                        alert[\"resolved_by\"][\"site_admin\"],\n                        alert[\"secret_type\"],\n                        alert[\"secret_type_display_name\"],\n                        alert[\"repository\"][\"full_name\"],\n                        alert[\"repository\"][\"owner\"][\"login\"],\n                        alert[\"repository\"][\"owner\"][\"type\"],\n                        alert[\"repository\"][\"owner\"][\"site_admin\"],\n                        alert[\"repository\"][\"html_url\"],\n                        str(alert[\"repository\"][\"fork\"]),\n                        str(alert[\"repository\"][\"private\"]),\n                    ]\n                )\n"], "fixing_code": ["defusedcsv==2.0.0\nrequests==2.28.1\n", "# This holds all the things that do stuff for code scanning API\n\n# Imports\nfrom defusedcsv import csv\nimport requests\n\n\ndef list_repo_code_scanning_alerts(api_endpoint, github_pat, repo_name):\n    \"\"\"\n    Get a list of all code scanning alerts on a given repository.\n\n    Inputs:\n    - API endpoint (for GHES/GHAE compatibility)\n    - PAT of appropriate scope\n    - Repository name\n\n    Outputs:\n    - List of _all_ code scanning alerts on the repository\n    \"\"\"\n\n    # Get code scanning alerts\n    url = \"{}/repos/{}/code-scanning/alerts?per_page=100&page=1\".format(\n        api_endpoint, repo_name\n    )\n    headers = {\n        \"Authorization\": \"token {}\".format(github_pat),\n        \"Accept\": \"application/vnd.github.v3+json\",\n    }\n    response = requests.get(url, headers=headers)\n    if response.status_code == 404:\n        return \"need permission to access,{}\".format(repo_name)  # don't have permission\n    if response.status_code == 403:\n        return \"need to enable GHAS,{}\".format(repo_name)  # no GHAS\n    response_json = response.json()\n    while \"next\" in response.links.keys():\n        response = requests.get(response.links[\"next\"][\"url\"], headers=headers)\n        response_json.extend(response.json())\n\n    # Return code scanning alerts\n    return response_json\n\n\ndef write_repo_cs_list(cs_list):\n    \"\"\"\n    Write a list of code scanning alerts to a csv file.\n\n    Inputs:\n    - List of code scanning alerts\n\n    Outputs:\n    - CSV file of code scanning alerts\n    \"\"\"\n\n    # Write code scanning alerts to csv file\n    with open(\"cs_list.csv\", \"w\") as f:\n        writer = csv.writer(f)\n        writer.writerow(\n            [\n                \"number\",\n                \"created_at\",\n                \"html_url\",\n                \"state\",\n                \"fixed_at\",\n                \"dismissed_by\",\n                \"dismissed_at\",\n                \"dismissed_reason\",\n                \"rule_id\",\n                \"rule_severity\",\n                \"rule_tags\",\n                \"rule_description\",\n                \"rule_name\",\n                \"tool_name\",\n                \"tool_version\",\n                \"most_recent_instance_ref\",\n                \"most_recent_instance_state\",\n                \"most_recent_instance_sha\",\n                \"instances_url\",\n            ]\n        )\n        for cs in cs_list:\n            if cs[\"state\"] == \"open\":\n                cs[\"fixed_at\"] = \"none\"\n                cs[\"dismissed_by\"] = \"none\"\n                cs[\"dismissed_at\"] = \"none\"\n                cs[\"dismissed_reason\"] = \"none\"\n            writer.writerow(\n                [\n                    cs[\"number\"],\n                    cs[\"created_at\"],\n                    cs[\"html_url\"],\n                    cs[\"state\"],\n                    cs[\"fixed_at\"],\n                    cs[\"dismissed_by\"],\n                    cs[\"dismissed_at\"],\n                    cs[\"dismissed_reason\"],\n                    cs[\"rule\"][\"id\"],\n                    cs[\"rule\"][\"severity\"],\n                    cs[\"rule\"][\"tags\"],\n                    cs[\"rule\"][\"description\"],\n                    cs[\"rule\"][\"name\"],\n                    cs[\"tool\"][\"name\"],\n                    cs[\"tool\"][\"version\"],\n                    cs[\"most_recent_instance\"][\"ref\"],\n                    cs[\"most_recent_instance\"][\"state\"],\n                    cs[\"most_recent_instance\"][\"commit_sha\"],\n                    cs[\"instances_url\"],\n                ]\n            )\n\n\ndef list_org_code_scanning_alerts(api_endpoint, github_pat, org_name):\n    \"\"\"\n    Get a list of all code scanning alerts on a given organization.\n\n    Inputs:\n    - API endpoint (for GHES/GHAE compatibility)\n    - PAT of appropriate scope\n    - Organization name\n\n    Outputs:\n    - List of _all_ code scanning alerts on the organization\n    \"\"\"\n\n    # Get code scanning alerts\n    url = \"{}/orgs/{}/code-scanning/alerts?per_page=100&page=1\".format(\n        api_endpoint, org_name\n    )\n    headers = {\n        \"Authorization\": \"token {}\".format(github_pat),\n        \"Accept\": \"application/vnd.github.v3+json\",\n    }\n    response = requests.get(url, headers=headers)\n    response_json = response.json()\n    while \"next\" in response.links.keys():\n        response = requests.get(response.links[\"next\"][\"url\"], headers=headers)\n        response_json.extend(response.json())\n\n    print(\"Found {} code scanning alerts in {}\".format(len(response_json), org_name))\n\n    # Return code scanning alerts\n    return response_json\n\n\ndef write_org_cs_list(cs_list):\n    \"\"\"\n    Write a list of code scanning alerts to a csv file.\n\n    Inputs:\n    - List of code scanning alerts\n\n    Outputs:\n    - CSV file of code scanning alerts\n    \"\"\"\n\n    # Write code scanning alerts to csv file\n    with open(\"cs_list.csv\", \"w\") as f:\n        writer = csv.writer(f)\n        writer.writerow(\n            [\n                \"number\",\n                \"created_at\",\n                \"html_url\",\n                \"state\",\n                \"fixed_at\",\n                \"dismissed_by\",\n                \"dismissed_at\",\n                \"dismissed_reason\",\n                \"rule_id\",\n                \"rule_severity\",\n                \"rule_tags\",\n                \"rule_description\",\n                \"rule_name\",\n                \"tool_name\",\n                \"tool_version\",\n                \"most_recent_instance_ref\",\n                \"most_recent_instance_state\",\n                \"most_recent_instance_sha\",\n                \"instances_url\",\n                \"repo_name\",\n                \"repo_owner\",\n                \"repo_owner_type\",\n                \"repo_owner_isadmin\",\n                \"repo_url\",\n                \"repo_isfork\",\n                \"repo_isprivate\",\n            ]\n        )\n        for cs in cs_list:\n            if cs[\"state\"] == \"open\":\n                cs[\"fixed_at\"] = \"none\"\n                cs[\"dismissed_by\"] = \"none\"\n                cs[\"dismissed_at\"] = \"none\"\n                cs[\"dismissed_reason\"] = \"none\"\n            writer.writerow(\n                [\n                    cs[\"number\"],\n                    cs[\"created_at\"],\n                    cs[\"html_url\"],\n                    cs[\"state\"],\n                    cs[\"fixed_at\"],\n                    cs[\"dismissed_by\"],\n                    cs[\"dismissed_at\"],\n                    cs[\"dismissed_reason\"],\n                    cs[\"rule\"][\"id\"],\n                    cs[\"rule\"][\"severity\"],\n                    cs[\"rule\"][\"tags\"],\n                    cs[\"rule\"][\"description\"],\n                    cs[\"rule\"][\"name\"],\n                    cs[\"tool\"][\"name\"],\n                    cs[\"tool\"][\"version\"],\n                    cs[\"most_recent_instance\"][\"ref\"],\n                    cs[\"most_recent_instance\"][\"state\"],\n                    cs[\"most_recent_instance\"][\"commit_sha\"],\n                    cs[\"instances_url\"],\n                    cs[\"repository\"][\"full_name\"],\n                    cs[\"repository\"][\"owner\"][\"login\"],\n                    cs[\"repository\"][\"owner\"][\"type\"],\n                    cs[\"repository\"][\"owner\"][\"site_admin\"],\n                    cs[\"repository\"][\"html_url\"],\n                    str(cs[\"repository\"][\"fork\"]),\n                    str(cs[\"repository\"][\"private\"]),\n                ]\n            )\n\n\ndef list_enterprise_server_code_scanning_alerts(api_endpoint, github_pat, repo_list):\n    \"\"\"\n    Get a list of all code scanning alerts on a given enterprise.\n\n    Inputs:\n    - API endpoint (for GHES/GHAE compatibility)\n    - PAT of appropriate scope\n    - Repository list in \"org/repo\" format (from enterprise.get_repo_report)\n\n    Outputs:\n    - List of _all_ code scanning alerts in enterprise that PAT user can access\n\n    Notes:\n    - Use `ghe-org-admin-promote` to gain ownership of all organizations.\n    - Personal repos will not be reported on, as they cannot use code scanning.\n    \"\"\"\n\n    alerts = []\n    while True:\n        try:\n            repo_name = next(repo_list)  # skip the header by putting this up front\n            alerts.append(\n                list_repo_code_scanning_alerts(api_endpoint, github_pat, repo_name)\n            )\n        except StopIteration:\n            break\n        except Exception as e:\n            print(e)\n    return alerts\n\n\ndef write_enterprise_server_cs_list(cs_list):\n    \"\"\"\n    Write a list of code scanning alerts to a csv file.\n\n    Inputs:\n    - List from list_enterprise_code_scanning_alerts function, which contains\n        strings and lists of dictionaries for the alerts.\n\n    Outputs:\n    - CSV file of code scanning alerts\n    - CSV file of repositories not accessible or without code scanning enabled\n    \"\"\"\n\n    for alert_list in cs_list:\n        if type(alert_list) == list:\n            print(alert_list)\n            with open(\"cs_list.csv\", \"a\") as f:\n                writer = csv.writer(f)\n                writer.writerow(\n                    [\n                        \"repository\",\n                        \"repo_id\",\n                        \"number\",\n                        \"created_at\",\n                        \"html_url\",\n                        \"state\",\n                        \"fixed_at\",\n                        \"dismissed_by\",\n                        \"dismissed_at\",\n                        \"dismissed_reason\",\n                        \"rule_id\",\n                        \"rule_severity\",\n                        \"rule_tags\",\n                        \"rule_description\",\n                        \"rule_name\",\n                        \"tool_name\",\n                        \"tool_version\",\n                        \"most_recent_instance_ref\",\n                        \"most_recent_instance_state\",\n                        \"most_recent_instance_sha\",\n                        \"instances_url\",\n                    ]\n                )\n                for cs in alert_list:  # loop through each alert in the list\n                    if cs[\"state\"] == \"open\":\n                        cs[\"fixed_at\"] = \"none\"\n                        cs[\"dismissed_by\"] = \"none\"\n                        cs[\"dismissed_at\"] = \"none\"\n                        cs[\"dismissed_reason\"] = \"none\"\n                    writer.writerow(\n                        [\n                            cs[\"repository\"][\"full_name\"],\n                            cs[\"repository\"][\"id\"],\n                            cs[\"number\"],\n                            cs[\"created_at\"],\n                            cs[\"html_url\"],\n                            cs[\"state\"],\n                            cs[\"fixed_at\"],\n                            cs[\"dismissed_by\"],\n                            cs[\"dismissed_at\"],\n                            cs[\"dismissed_reason\"],\n                            cs[\"rule\"][\"id\"],\n                            cs[\"rule\"][\"severity\"],\n                            cs[\"rule\"][\"tags\"],\n                            cs[\"rule\"][\"description\"],\n                            cs[\"rule\"][\"name\"],\n                            cs[\"tool\"][\"name\"],\n                            cs[\"tool\"][\"version\"],\n                            cs[\"most_recent_instance\"][\"ref\"],\n                            cs[\"most_recent_instance\"][\"state\"],\n                            cs[\"most_recent_instance\"][\"commit_sha\"],\n                            cs[\"instances_url\"],\n                        ]\n                    )\n        else:\n            with open(\"excluded_repos.csv\", \"a\") as g:\n                writer = csv.writer(g)\n                writer.writerow([alert_list])\n\n\ndef list_enterprise_cloud_code_scanning_alerts(\n    api_endpoint, github_pat, enterprise_slug\n):\n    \"\"\"\n    Get a list of all code scanning alerts on a given enterprise.\n\n    Inputs:\n    - API endpoint (for GHES/GHAE compatibility)\n    - PAT of appropriate scope\n\n    Outputs:\n    - List of _all_ code scanning alerts in enterprise that PAT user can access\n    \"\"\"\n\n    # Get code scanning alerts\n    url = \"{}/enterprises/{}/code-scanning/alerts?per_page=100&page=1\".format(\n        api_endpoint, enterprise_slug\n    )\n    headers = {\n        \"Authorization\": \"token {}\".format(github_pat),\n        \"Accept\": \"application/vnd.github.v3+json\",\n    }\n    response = requests.get(url, headers=headers)\n    response_json = response.json()\n    while \"next\" in response.links.keys():\n        response = requests.get(response.links[\"next\"][\"url\"], headers=headers)\n        response_json.extend(response.json())\n\n    print(\n        \"Found {} code scanning alerts in {}\".format(\n            len(response_json), enterprise_slug\n        )\n    )\n\n    # Return code scanning alerts\n    return response_json\n\n\ndef write_enterprise_cloud_cs_list(cs_list):\n    \"\"\"\n    Write a list of code scanning alerts to a csv file.\n\n    Inputs:\n    - List from list_enterprise_code_scanning_alerts function, which contains\n        strings and lists of dictionaries for the alerts.\n\n    Outputs:\n    - CSV file of code scanning alerts\n    - CSV file of repositories not accessible or without code scanning enabled\n    \"\"\"\n\n    with open(\"cs_list.csv\", \"a\") as f:\n        writer = csv.writer(f)\n        writer.writerow(\n            [\n                \"repository\",\n                \"repo_id\",\n                \"number\",\n                \"created_at\",\n                \"html_url\",\n                \"state\",\n                \"fixed_at\",\n                \"dismissed_by\",\n                \"dismissed_at\",\n                \"dismissed_reason\",\n                \"rule_id\",\n                \"rule_severity\",\n                \"rule_tags\",\n                \"rule_description\",\n                \"rule_name\",\n                \"tool_name\",\n                \"tool_version\",\n                \"most_recent_instance_ref\",\n                \"most_recent_instance_state\",\n                \"most_recent_instance_sha\",\n                \"instances_url\",\n            ]\n        )\n        for cs in cs_list:  # loop through each alert in the list\n            if cs[\"state\"] == \"open\":\n                cs[\"fixed_at\"] = \"none\"\n                cs[\"dismissed_by\"] = \"none\"\n                cs[\"dismissed_at\"] = \"none\"\n                cs[\"dismissed_reason\"] = \"none\"\n            writer.writerow(\n                [\n                    cs[\"repository\"][\"full_name\"],\n                    cs[\"repository\"][\"id\"],\n                    cs[\"number\"],\n                    cs[\"created_at\"],\n                    cs[\"html_url\"],\n                    cs[\"state\"],\n                    cs[\"fixed_at\"],\n                    cs[\"dismissed_by\"],\n                    cs[\"dismissed_at\"],\n                    cs[\"dismissed_reason\"],\n                    cs[\"rule\"][\"id\"],\n                    cs[\"rule\"][\"severity\"],\n                    cs[\"rule\"][\"tags\"],\n                    cs[\"rule\"][\"description\"],\n                    cs[\"rule\"][\"name\"],\n                    cs[\"tool\"][\"name\"],\n                    cs[\"tool\"][\"version\"],\n                    cs[\"most_recent_instance\"][\"ref\"],\n                    cs[\"most_recent_instance\"][\"state\"],\n                    cs[\"most_recent_instance\"][\"commit_sha\"],\n                    cs[\"instances_url\"],\n                ]\n            )\n        else:\n            with open(\"excluded_repos.csv\", \"a\") as g:\n                writer = csv.writer(g)\n                writer.writerow([cs])\n", "# This holds all the logic for the various enterprise differences.\n\n# Imports\nfrom defusedcsv import csv\nfrom time import sleep\nimport requests\n\n\ndef get_enterprise_version(api_endpoint):\n    \"\"\"\n    Get the version of GitHub Enterprise.  It'll be used to account for\n    differences between GHES and GHAE and GHEC, like the organization secret\n    scanning API not existing outside GHEC.\n\n    GitHub AE returns \"GitHub AE\" as of M2\n    GHES returns the version of GHES that's installed (e.g. \"3.4.0\")\n    \"\"\"\n    if api_endpoint != \"https://api.github.com\":\n        url = \"{}/meta\".format(api_endpoint)\n        response = requests.get(url)\n        if \"installed_version\" in response.json():\n            return response.json()[\"installed_version\"]\n        else:\n            return \"unknown version of GitHub\"\n    else:\n        return \"GHEC\"\n\n\ndef get_repo_report(url, github_pat):\n    \"\"\"\n    Get the `all_repositories.csv` report from GHES / GHAE.\n    \"\"\"\n    headers = {\n        \"Accept\": \"application/vnd.github.v3+json\",\n        \"Authorization\": \"token {}\".format(github_pat),\n    }\n    url = \"{}/stafftools/reports/all_repositories.csv\".format(url)\n    response = requests.get(url, headers=headers)\n    if response.status_code == 202:  # report needs to be generated\n        while response.status_code == 202:\n            print(\"Waiting a minute for the report to be generated ...\")\n            sleep(60)\n            response = requests.get(url, headers=headers)\n    elif response.status_code == 200:  # report is ready\n        print(\"Report is ready!  Reading it now ...\")\n        for row in csv.reader(response.text.splitlines()):  # skip user repos\n            if row[2] == \"Organization\":\n                yield \"{}/{}\".format(row[3], row[5])\n            else:\n                pass\n    else:  # something went wrong with fetching the report\n        exit(\"Error: {}\".format(response.status_code))\n", "# This holds all the things that do stuff for secret scanning API\n\n# Imports\nfrom defusedcsv import csv\nimport requests\n\n\ndef get_repo_secret_scanning_alerts(api_endpoint, github_pat, repo_name):\n    \"\"\"\n    Get all the secret scanning alerts on a given repository.\n\n    Inputs:\n    - API endpoint (for GHES/GHAE compatibility)\n    - PAT of appropriate scope\n    - Repository name\n\n    Outputs:\n    - List of _all_ secret scanning alerts on the repository\n    \"\"\"\n\n    # Get secret scanning alerts\n    url = \"{}/repos/{}/secret-scanning/alerts?per_page=100&page=1\".format(\n        api_endpoint, repo_name\n    )\n    response = requests.get(\n        url,\n        headers={\n            \"Authorization\": \"token {}\".format(github_pat),\n            \"Accept\": \"application/vnd.github.v3+json\",\n        },\n    )\n    response_json = response.json()\n    # The secret scanning API returns a code of 404 if there are no alerts,\n    # secret scanning is disabled, or the repository is public.\n    if response.status_code == 404:\n        return [\"not found\"]\n    while \"next\" in response.links.keys():\n        response = requests.get(\n            response.links[\"next\"][\"url\"],\n            headers={\n                \"Authorization\": \"token {}\".format(github_pat),\n                \"Accept\": \"application/vnd.github.v3+json\",\n            },\n        )\n        response_json.extend(response.json())\n\n    print(\"Found {} secret scanning alerts in {}\".format(len(response_json), repo_name))\n\n    # Return secret scanning alerts\n    return response_json\n\n\ndef write_repo_secrets_list(secrets_list):\n    \"\"\"\n    Write the list of repository secret scanning alerts to a csv file.\n\n    Inputs:\n    - List of secret scanning alerts\n\n    Outputs:\n    - CSV file of secret scanning alerts\n    \"\"\"\n\n    if secrets_list == [\"not found\"]:\n        print(\"No secret scanning alerts found\")\n        return\n    # Write secret scanning alerts to csv file\n    with open(\"secrets_list.csv\", \"w\") as f:\n        writer = csv.writer(f)\n        writer.writerow(\n            [\n                \"number\",\n                \"created_at\",\n                \"html_url\",\n                \"state\",\n                \"resolution\",\n                \"resolved_at\",\n                \"resolved_by_username\",\n                \"resolved_by_type\",\n                \"resolved_by_isadmin\",\n                \"secret_type\",\n                \"secret_type_display_name\",\n            ]\n        )\n        for alert in secrets_list:\n            if alert[\"state\"] == \"open\":\n                alert[\"resolution\"] = \"none\"\n                alert[\"resolved_at\"] = \"none\"\n                alert[\"resolved_by\"] = {\n                    \"login\": \"none\",\n                    \"type\": \"none\",\n                    \"site_admin\": \"none\",\n                }\n            writer.writerow(\n                [\n                    alert[\"number\"],\n                    alert[\"created_at\"],\n                    alert[\"html_url\"],\n                    alert[\"state\"],\n                    alert[\"resolution\"],\n                    alert[\"resolved_at\"],\n                    alert[\"resolved_by\"][\"login\"],\n                    alert[\"resolved_by\"][\"type\"],\n                    alert[\"resolved_by\"][\"site_admin\"],\n                    alert[\"secret_type\"],\n                    alert[\"secret_type_display_name\"],\n                ]\n            )\n\n\ndef get_org_secret_scanning_alerts(api_endpoint, github_pat, org_name):\n    \"\"\"\n    Get all the secret scanning alerts on a given organization.\n\n    Inputs:\n    - API endpoint (for GHES/GHAE compatibility)\n    - PAT of appropriate scope\n    - Organization name\n\n    Outputs:\n    - List of _all_ secret scanning alerts on the organization\n    \"\"\"\n\n    # Get secret scanning alerts\n    url = \"{}/orgs/{}/secret-scanning/alerts?per_page=100&page=1\".format(\n        api_endpoint, org_name\n    )\n    response = requests.get(\n        url,\n        headers={\n            \"Authorization\": \"token {}\".format(github_pat),\n            \"Accept\": \"application/vnd.github.v3+json\",\n        },\n    )\n    response_json = response.json()\n    # The secret scanning API returns a code of 404 if there are no alerts,\n    # secret scanning is disabled, or the repository is public.\n    if response.status_code == 404:\n        return [\"not found\"]\n    while \"next\" in response.links.keys():\n        response = requests.get(\n            response.links[\"next\"][\"url\"],\n            headers={\n                \"Authorization\": \"token {}\".format(github_pat),\n                \"Accept\": \"application/vnd.github.v3+json\",\n            },\n        )\n        response_json.extend(response.json())\n\n    print(\"Found {} secret scanning alerts in {}\".format(len(response_json), org_name))\n\n    # Return secret scanning alerts\n    return response_json\n\n\ndef write_org_secrets_list(secrets_list):\n    \"\"\"\n    Write the list of organization secret scanning alerts to a csv file.\n\n    Inputs:\n    - List of secret scanning alerts\n\n    Outputs:\n    - CSV file of secret scanning alerts\n    \"\"\"\n\n    if secrets_list == [\"not found\"]:\n        print(\"No secret scanning alerts found\")\n        return\n    # Write secret scanning alerts to csv file\n    with open(\"secrets_list.csv\", \"w\") as f:\n        writer = csv.writer(f)\n        writer.writerow(\n            [\n                \"number\",\n                \"created_at\",\n                \"html_url\",\n                \"state\",\n                \"resolution\",\n                \"resolved_at\",\n                \"resolved_by_username\",\n                \"resolved_by_type\",\n                \"resolved_by_isadmin\",\n                \"secret_type\",\n                \"secret_type_display_name\",\n                \"repo_name\",\n                \"repo_owner\",\n                \"repo_owner_type\",\n                \"repo_owner_isadmin\",\n                \"repo_url\",\n                \"repo_isfork\",\n                \"repo_isprivate\",\n            ]\n        )\n        for alert in secrets_list:\n            if alert[\"state\"] == \"open\":\n                alert[\"resolution\"] = \"none\"\n                alert[\"resolved_at\"] = \"none\"\n                alert[\"resolved_by\"] = {\n                    \"login\": \"none\",\n                    \"type\": \"none\",\n                    \"site_admin\": \"none\",\n                }\n            writer.writerow(\n                [\n                    alert[\"number\"],\n                    alert[\"created_at\"],\n                    alert[\"html_url\"],\n                    alert[\"state\"],\n                    alert[\"resolution\"],\n                    alert[\"resolved_at\"],\n                    alert[\"resolved_by\"][\"login\"],\n                    alert[\"resolved_by\"][\"type\"],\n                    alert[\"resolved_by\"][\"site_admin\"],\n                    alert[\"secret_type\"],\n                    alert[\"secret_type_display_name\"],\n                    alert[\"repository\"][\"full_name\"],\n                    alert[\"repository\"][\"owner\"][\"login\"],\n                    alert[\"repository\"][\"owner\"][\"type\"],\n                    alert[\"repository\"][\"owner\"][\"site_admin\"],\n                    alert[\"repository\"][\"html_url\"],\n                    str(alert[\"repository\"][\"fork\"]),\n                    str(alert[\"repository\"][\"private\"]),\n                ]\n            )\n\n\ndef get_enterprise_secret_scanning_alerts(api_endpoint, github_pat, enterprise_slug):\n    \"\"\"\n    Get all the secret scanning alerts on a given enterprise.\n\n    Inputs:\n    - API endpoint (for GHES/GHAE compatibility)\n    - PAT of appropriate scope\n    - Enterprise slug (enterprise name URL, documented below)\n        - https://docs.github.com/en/rest/reference/enterprise-admin\n\n    Outputs:\n    - List of _all_ secret scanning alerts on the enterprise\n    \"\"\"\n\n    # Get secret scanning alerts\n    url = \"{}/enterprises/{}/secret-scanning/alerts?per_page=100&page=1\".format(\n        api_endpoint, enterprise_slug\n    )\n    response = requests.get(\n        url,\n        headers={\n            \"Authorization\": \"token {}\".format(github_pat),\n            \"Accept\": \"application/vnd.github.v3+json\",\n        },\n    )\n    response_json = response.json()\n    # The secret scanning API returns a code of 404 if there are no alerts,\n    # secret scanning is disabled, or the repository is public.\n    if response.status_code == 404:\n        return [\"not found\"]\n    while \"next\" in response.links.keys():\n        response = requests.get(\n            response.links[\"next\"][\"url\"],\n            headers={\n                \"Authorization\": \"token {}\".format(github_pat),\n                \"Accept\": \"application/vnd.github.v3+json\",\n            },\n        )\n        response_json.extend(response.json())\n\n    print(\n        \"Found {} secret scanning alerts in {} enterprise\".format(\n            len(response_json), enterprise_slug\n        )\n    )\n\n    # Return secret scanning alerts\n    return response_json\n\n\ndef write_enterprise_secrets_list(secrets_list):\n    \"\"\"\n    Write the list of enterprise secret scanning alerts to a csv file.\n\n    Inputs:\n    - List of secret scanning alerts\n\n    Outputs:\n    - CSV file of secret scanning alerts\n    \"\"\"\n\n    if secrets_list == [\"not found\"]:\n        print(\"No secret scanning alerts found\")\n        return\n    # Write secret scanning alerts to csv file\n    with open(\"secrets_list.csv\", \"w\") as f:\n        writer = csv.writer(f)\n        writer.writerow(\n            [\n                \"number\",\n                \"created_at\",\n                \"html_url\",\n                \"state\",\n                \"resolution\",\n                \"resolved_at\",\n                \"resolved_by_username\",\n                \"resolved_by_type\",\n                \"resolved_by_isadmin\",\n                \"secret_type\",\n                \"secret_type_display_name\",\n                \"repo_name\",\n                \"repo_owner\",\n                \"repo_owner_type\",\n                \"repo_owner_isadmin\",\n                \"repo_url\",\n                \"repo_isfork\",\n                \"repo_isprivate\",\n            ]\n        )\n        for alert in secrets_list:\n            if alert[\"state\"] == \"open\":\n                alert[\"resolution\"] = \"none\"\n                alert[\"resolved_at\"] = \"none\"\n                alert[\"resolved_by\"] = {\n                    \"login\": \"none\",\n                    \"type\": \"none\",\n                    \"site_admin\": \"none\",\n                }\n                writer.writerow(\n                    [\n                        alert[\"number\"],\n                        alert[\"created_at\"],\n                        alert[\"html_url\"],\n                        alert[\"state\"],\n                        alert[\"resolution\"],\n                        alert[\"resolved_at\"],\n                        alert[\"resolved_by\"][\"login\"],\n                        alert[\"resolved_by\"][\"type\"],\n                        alert[\"resolved_by\"][\"site_admin\"],\n                        alert[\"secret_type\"],\n                        alert[\"secret_type_display_name\"],\n                        alert[\"repository\"][\"full_name\"],\n                        alert[\"repository\"][\"owner\"][\"login\"],\n                        alert[\"repository\"][\"owner\"][\"type\"],\n                        alert[\"repository\"][\"owner\"][\"site_admin\"],\n                        alert[\"repository\"][\"html_url\"],\n                        str(alert[\"repository\"][\"fork\"]),\n                        str(alert[\"repository\"][\"private\"]),\n                    ]\n                )\n"], "filenames": ["requirements.txt", "src/code_scanning.py", "src/enterprise.py", "src/secret_scanning.py"], "buggy_code_start_loc": [0, 4, 4, 4], "buggy_code_end_loc": [0, 5, 5, 5], "fixing_code_start_loc": [1, 4, 4, 4], "fixing_code_end_loc": [2, 5, 5, 5], "type": "NVD-CWE-Other", "message": "some-natalie/ghas-to-csv (GitHub Advanced Security to CSV) is a GitHub action which scrapes the GitHub Advanced Security API and shoves it into a CSV. In affected versions this GitHub Action creates a CSV file without sanitizing the output of the APIs. If an alert is dismissed or any other custom field contains executable code / formulas, it might be run when an endpoint opens that CSV file in a spreadsheet program. This issue has been addressed in version `v1`. Users are advised to use `v1` or later. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-39217", "sourceIdentifier": "security-advisories@github.com", "published": "2022-09-17T00:15:10.017", "lastModified": "2022-09-21T16:22:16.260", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "some-natalie/ghas-to-csv (GitHub Advanced Security to CSV) is a GitHub action which scrapes the GitHub Advanced Security API and shoves it into a CSV. In affected versions this GitHub Action creates a CSV file without sanitizing the output of the APIs. If an alert is dismissed or any other custom field contains executable code / formulas, it might be run when an endpoint opens that CSV file in a spreadsheet program. This issue has been addressed in version `v1`. Users are advised to use `v1` or later. There are no known workarounds for this issue."}, {"lang": "es", "value": "some-natalie/ghas-to-csv (GitHub Advanced Security to CSV) es una acci\u00f3n de GitHub que raspa la API de GitHub Advanced Security y la mete en un CSV. En las versiones afectadas, esta acci\u00f3n de GitHub crea un archivo CSV sin sanear la salida de las API. Si es descartada una alerta o cualquier otro campo personalizado contiene c\u00f3digo ejecutable / f\u00f3rmulas, podr\u00eda ejecutarse cuando un endpoint abre ese archivo CSV en un programa de hoja de c\u00e1lculo. Este problema ha sido abordado en versi\u00f3n \"v1\". Es recomendado a usuarios usar la versi\u00f3n \"v1\" o posterior. No se presentan mitigaciones conocidas para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:C/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 3.7}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-74"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ghas-to-csv_project:ghas-to-csv:*:*:*:*:*:*:*:*", "versionEndExcluding": "1", "matchCriteriaId": "C1954504-14CD-4938-8502-F005E75D0A00"}]}]}], "references": [{"url": "https://github.com/some-natalie/ghas-to-csv/commit/d0b521928fa734513b5cd9c7d9d8e09db50e884a", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/some-natalie/ghas-to-csv/security/advisories/GHSA-634p-93h9-92vh", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/some-natalie/ghas-to-csv/commit/d0b521928fa734513b5cd9c7d9d8e09db50e884a"}}