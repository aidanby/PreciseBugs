{"buggy_code": ["// Copyright 2020 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// Package rbac implements authorization.\npackage rbac\n\nimport (\n\t\"database/sql/driver\"\n\t\"fmt\"\n\t\"sort\"\n)\n\nvar (\n\t// PermissionMap is the list of permissions mapped to their name and\n\t// description.\n\tPermissionMap = map[Permission][2]string{\n\t\tAuditRead:      {\"AuditRead\", \"read event and audit logs\"},\n\t\tAPIKeyRead:     {\"APIKeyRead\", \"view information about API keys, including statistics\"},\n\t\tAPIKeyWrite:    {\"APIKeyWrite\", \"create, update, and delete API keys\"},\n\t\tCodeIssue:      {\"CodeIssue\", \"issue codes\"},\n\t\tCodeBulkIssue:  {\"CodeBulkIssue\", \"issue codes in bulk, if bulk issue is enabled on the realm\"},\n\t\tCodeRead:       {\"CodeRead\", \"lookup code status\"},\n\t\tCodeExpire:     {\"CodeExpire\", \"expire codes\"},\n\t\tSettingsRead:   {\"SettingsRead\", \"read realm settings\"},\n\t\tSettingsWrite:  {\"SettingsWrite\", \"update realm settings\"},\n\t\tStatsRead:      {\"StatsRead\", \"view realm statistics\"},\n\t\tMobileAppRead:  {\"MobileAppRead\", \"view mobile app information\"},\n\t\tMobileAppWrite: {\"MobileAppWrite\", \"create, update, and delete mobile apps\"},\n\t\tUserRead:       {\"UserRead\", \"view user information\"},\n\t\tUserWrite:      {\"UserWrite\", \"create, update, and delete users\"},\n\t}\n\n\t// NamePermissionMap is the map of permission names to their value.\n\tNamePermissionMap map[string]Permission\n)\n\nfunc init() {\n\tNamePermissionMap = make(map[string]Permission, len(PermissionMap))\n\tfor k, v := range PermissionMap {\n\t\tNamePermissionMap[v[0]] = k\n\t}\n}\n\n// Can returns true if the given resource has permission to perform the provided\n// permissions.\nfunc Can(given Permission, target Permission) bool {\n\treturn int64(given)&int64(target) != 0\n}\n\n// CompileAndAuthorize compiles a new permission bit from the given toUpdate\n// permissions. It verifies that the calling permission has a superset of all\n// provided permissions (to prevent privilege escalation).\nfunc CompileAndAuthorize(actorPermission Permission, toUpdate []Permission) (Permission, error) {\n\tvar permission Permission\n\tfor _, update := range toUpdate {\n\t\t// Verify that the user making changes has the permissions they are trying\n\t\t// to grant. It is not valid for someone to grant permissions larger than\n\t\t// they currently have.\n\t\tif !Can(actorPermission, update) {\n\t\t\treturn 0, fmt.Errorf(\"actor does not have all scopes which are being granted\")\n\t\t}\n\t\tpermission = permission | update\n\t}\n\n\t// Ensure implied permissions. The actor must also have the implied\n\t// permissions by definition.\n\tpermission = AddImplied(permission)\n\treturn permission, nil\n}\n\n// AddImplied adds any missing implied permissions.\nfunc AddImplied(target Permission) Permission {\n\tfor has, needs := range requiredPermission {\n\t\t// If granted has, ensure that we have all needs.\n\t\tif Can(target, has) {\n\t\t\tfor _, required := range needs {\n\t\t\t\ttarget = target | required\n\t\t\t}\n\t\t}\n\t}\n\treturn target\n}\n\n// ImpliedBy returns any permissions that cause this permission to be added\n// automatically. The return may be nil.\nfunc ImpliedBy(permission Permission) []Permission {\n\treturn impliedBy[permission]\n}\n\n// PermissionNames returns the list of permissions included in the given\n// permission.\nfunc PermissionNames(p Permission) []string {\n\tnames := make([]string, 0, len(PermissionMap))\n\tfor v, k := range PermissionMap {\n\t\tif Can(p, v) {\n\t\t\tnames = append(names, k[0])\n\t\t}\n\t}\n\tsort.Strings(names)\n\treturn names\n}\n\n// Permission is a granular permission. It is an integer instead of a uint\n// because most database systems lack unsigned integer types.\ntype Permission int64\n\n// String implements stringer.\nfunc (p Permission) String() string {\n\tif v, ok := PermissionMap[p]; ok {\n\t\treturn v[0]\n\t}\n\treturn fmt.Sprintf(\"Permission(%d)\", int64(p))\n}\n\n// Value returns the permissions value as an integer for sql drivers.\nfunc (p Permission) Value() (driver.Value, error) {\n\treturn int64(p), nil\n}\n\n// Description returns the description.\nfunc (p Permission) Description() (string, error) {\n\tif v, ok := PermissionMap[p]; ok {\n\t\treturn v[1], nil\n\t}\n\treturn \"\", fmt.Errorf(\"missing description for %s\", p)\n}\n\n// Implied returns the additional implied permissions, if any.\nfunc (p Permission) Implied() []Permission {\n\treturn requiredPermission[p]\n}\n\nconst (\n\t_ Permission = 1 << iota\n\n\t// Audit\n\tAuditRead\n\n\t// API keys\n\tAPIKeyRead\n\tAPIKeyWrite\n\n\t// Codes\n\tCodeIssue\n\tCodeBulkIssue\n\tCodeRead\n\tCodeExpire\n\n\t// Realm settings\n\tSettingsRead\n\tSettingsWrite\n\n\t// Realm statistics\n\tStatsRead\n\n\t// Mobile apps\n\tMobileAppRead\n\tMobileAppWrite\n\n\t// Users\n\tUserRead\n\tUserWrite\n)\n\n// --\n// Required / Implied permissions.\n// Write permissions require subordinate read.\n// --\n\nvar (\n\t// requiredPermissions is not exported since maps cannot be constant.\n\trequiredPermission = map[Permission][]Permission{\n\t\tAPIKeyWrite:    {APIKeyRead},\n\t\tCodeBulkIssue:  {CodeIssue},\n\t\tSettingsWrite:  {SettingsRead},\n\t\tMobileAppWrite: {MobileAppRead},\n\t\tUserWrite:      {UserRead},\n\t}\n\n\t// This is the inverse of the above map, set by the init() func.\n\t// Done in code to ensure it always stays in sync with requiredPermission.\n\timpliedBy = make(map[Permission][]Permission)\n)\n\n// Note: there are multiple init functions in this file. They are organized to be\n// near the thing they are initializing.\n// Yes, go allows multiple init functions in the same module.\nfunc init() {\n\tfor has, needs := range requiredPermission {\n\t\tfor _, perm := range needs {\n\t\t\tif _, ok := impliedBy[perm]; !ok {\n\t\t\t\timpliedBy[perm] = make([]Permission, 0, 1)\n\t\t\t}\n\t\t\timpliedBy[perm] = append(impliedBy[perm], has)\n\t\t}\n\t}\n}\n\n// --\n// Legacy permissions\n// --\n\nconst (\n\t// LegacyRealmUser is a quick reference to the old \"user\" permissions.\n\tLegacyRealmUser Permission = CodeIssue | CodeBulkIssue | CodeRead | CodeExpire\n\n\t// LegacyRealmAdmin is a quick reference to the old \"realm admin\" permissions.\n\tLegacyRealmAdmin Permission = AuditRead |\n\t\tAPIKeyRead | APIKeyWrite |\n\t\tCodeIssue | CodeBulkIssue | CodeRead | CodeExpire |\n\t\tSettingsRead | SettingsWrite |\n\t\tStatsRead |\n\t\tMobileAppRead | MobileAppWrite |\n\t\tUserRead | UserWrite\n)\n", "// Copyright 2020 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage rbac\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestRequiredPermissions(t *testing.T) {\n\tt.Parallel()\n\n\tfor perm, needs := range requiredPermission {\n\t\tperm := perm\n\t\tneeds := needs\n\t\tname := fmt.Sprintf(\"implied_by_%s\", PermissionMap[perm][0])\n\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tactorPermission := perm\n\t\t\tfor _, n := range needs {\n\t\t\t\tactorPermission |= n\n\t\t\t}\n\n\t\t\tgot, err := CompileAndAuthorize(actorPermission, []Permission{perm})\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"missing all required permissions for %v\", PermissionNames(perm))\n\t\t\t}\n\n\t\t\tfor _, n := range needs {\n\t\t\t\tif !Can(got, n) {\n\t\t\t\t\tt.Errorf(\"%v did not imply %v as expected\", PermissionNames(perm), PermissionNames(n))\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"missing\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tif _, err := CompileAndAuthorize(0, []Permission{APIKeyRead}); err == nil {\n\t\t\tt.Errorf(\"expected error\")\n\t\t}\n\t})\n}\n\nfunc TestImpliedBy(t *testing.T) {\n\tt.Parallel()\n\n\tif got := ImpliedBy(APIKeyRead); !reflect.DeepEqual(got, []Permission{APIKeyWrite}) {\n\t\tt.Errorf(\"expected %q to imply %q\", APIKeyRead, APIKeyWrite)\n\t}\n\n\tif got := ImpliedBy(APIKeyWrite); len(got) != 0 {\n\t\tt.Errorf(\"expected no implications, got %q\", got)\n\t}\n}\n\nfunc TestPermission_Implied(t *testing.T) {\n\tt.Parallel()\n\n\tif got := APIKeyWrite.Implied(); !reflect.DeepEqual(got, []Permission{APIKeyRead}) {\n\t\tt.Errorf(\"expected %q to imply %q\", APIKeyRead, APIKeyWrite)\n\t}\n}\n\nfunc TestPermissionNames(t *testing.T) {\n\tt.Parallel()\n\n\tcases := []struct {\n\t\tp   Permission\n\t\texp string\n\t}{\n\t\t{0, \"\"},\n\t\t{APIKeyWrite, \"APIKeyWrite\"},\n\t\t{LegacyRealmUser, \"CodeBulkIssue,CodeExpire,CodeIssue,CodeRead\"},\n\t}\n\n\tfor _, tc := range cases {\n\t\ttc := tc\n\n\t\tt.Run(tc.p.String(), func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tif got, want := strings.Join(PermissionNames(tc.p), \",\"), tc.exp; !reflect.DeepEqual(got, want) {\n\t\t\t\tt.Errorf(\"Expected %q to be %q\", got, want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestPermission_String(t *testing.T) {\n\tt.Parallel()\n\n\tcases := []struct {\n\t\tp   Permission\n\t\texp string\n\t}{\n\t\t{0, \"Permission(0)\"},\n\t\t{APIKeyWrite, \"APIKeyWrite\"},\n\t}\n\n\tfor _, tc := range cases {\n\t\ttc := tc\n\n\t\tt.Run(tc.p.String(), func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tif got, want := tc.p.String(), tc.exp; got != want {\n\t\t\t\tt.Errorf(\"Expected %q to be %q\", got, want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestPermission_Value(t *testing.T) {\n\tt.Parallel()\n\n\tcases := []struct {\n\t\tp   Permission\n\t\texp int64\n\t}{\n\t\t{0, 0},\n\t\t{APIKeyWrite, 8},\n\t}\n\n\tfor _, tc := range cases {\n\t\ttc := tc\n\n\t\tt.Run(tc.p.String(), func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tresult, err := tc.p.Value()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tgot, ok := result.(int64)\n\t\t\tif !ok {\n\t\t\t\tt.Fatalf(\"%T is not int64\", result)\n\t\t\t}\n\n\t\t\tif got, want := got, tc.exp; got != want {\n\t\t\t\tt.Errorf(\"expected %v to be %v\", got, want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestPermission_Description(t *testing.T) {\n\tt.Parallel()\n\n\tcases := []struct {\n\t\tp   Permission\n\t\texp string\n\t\terr bool\n\t}{\n\t\t{0, \"\", true},\n\t\t{APIKeyWrite, \"create, update, and delete API keys\", false},\n\t}\n\n\tfor _, tc := range cases {\n\t\ttc := tc\n\n\t\tt.Run(tc.p.String(), func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tresult, err := tc.p.Description()\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tif got, want := result, tc.exp; got != want {\n\t\t\t\tt.Errorf(\"Expected %q to be %q\", got, want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRBAC_Permissions(t *testing.T) {\n\tt.Parallel()\n\n\t// This test might seem like it's redundant with the content in rbac.go, but\n\t// it's designed to ensure that the exact values for existing RBAC permissions\n\t// remain unchanged.\n\tcases := []struct {\n\t\tp   Permission\n\t\texp int64\n\t}{\n\t\t{AuditRead, 2},\n\t\t{APIKeyRead, 4},\n\t\t{APIKeyWrite, 8},\n\t\t{CodeIssue, 16},\n\t\t{CodeBulkIssue, 32},\n\t\t{CodeRead, 64},\n\t\t{CodeExpire, 128},\n\t\t{SettingsRead, 256},\n\t\t{SettingsWrite, 512},\n\t\t{StatsRead, 1024},\n\t\t{MobileAppRead, 2048},\n\t\t{MobileAppWrite, 4096},\n\t\t{UserRead, 8192},\n\t\t{UserWrite, 16384},\n\t}\n\n\tfor _, tc := range cases {\n\t\ttc := tc\n\n\t\tt.Run(tc.p.String(), func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tif got, want := int64(tc.p), tc.exp; got != want {\n\t\t\t\tt.Errorf(\"Expected %d to be %d\", got, want)\n\t\t\t}\n\t\t})\n\t}\n}\n"], "fixing_code": ["// Copyright 2020 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// Package rbac implements authorization.\npackage rbac\n\nimport (\n\t\"database/sql/driver\"\n\t\"fmt\"\n\t\"sort\"\n)\n\nvar (\n\t// PermissionMap is the list of permissions mapped to their name and\n\t// description.\n\tPermissionMap = map[Permission][2]string{\n\t\tAuditRead:      {\"AuditRead\", \"read event and audit logs\"},\n\t\tAPIKeyRead:     {\"APIKeyRead\", \"view information about API keys, including statistics\"},\n\t\tAPIKeyWrite:    {\"APIKeyWrite\", \"create, update, and delete API keys\"},\n\t\tCodeIssue:      {\"CodeIssue\", \"issue codes\"},\n\t\tCodeBulkIssue:  {\"CodeBulkIssue\", \"issue codes in bulk, if bulk issue is enabled on the realm\"},\n\t\tCodeRead:       {\"CodeRead\", \"lookup code status\"},\n\t\tCodeExpire:     {\"CodeExpire\", \"expire codes\"},\n\t\tSettingsRead:   {\"SettingsRead\", \"read realm settings\"},\n\t\tSettingsWrite:  {\"SettingsWrite\", \"update realm settings\"},\n\t\tStatsRead:      {\"StatsRead\", \"view realm statistics\"},\n\t\tMobileAppRead:  {\"MobileAppRead\", \"view mobile app information\"},\n\t\tMobileAppWrite: {\"MobileAppWrite\", \"create, update, and delete mobile apps\"},\n\t\tUserRead:       {\"UserRead\", \"view user information\"},\n\t\tUserWrite:      {\"UserWrite\", \"create, update, and delete users\"},\n\t}\n\n\t// NamePermissionMap is the map of permission names to their value.\n\tNamePermissionMap map[string]Permission\n)\n\nfunc init() {\n\tNamePermissionMap = make(map[string]Permission, len(PermissionMap))\n\tfor k, v := range PermissionMap {\n\t\tNamePermissionMap[v[0]] = k\n\t}\n}\n\n// Can returns true if the given resource has permission to perform the provided\n// permissions.\nfunc Can(given Permission, target Permission) bool {\n\treturn int64(given)&int64(target) != 0\n}\n\n// CompileAndAuthorize compiles a new permission bit from the given toUpdate\n// permissions. It verifies that the calling permission has a superset of all\n// provided permissions (to prevent privilege escalation).\nfunc CompileAndAuthorize(actorPermission Permission, toUpdate []Permission) (Permission, error) {\n\tvar permission Permission\n\tfor _, update := range toUpdate {\n\t\t// Verify the provided permission is a known permission. This prevents a\n\t\t// security vulnerability whereby a carefully crafted request is able to\n\t\t// provide a value that correctly passes an the bitwise AND check and then\n\t\t// modifies the target permission using OR to escalate privilege.\n\t\tif _, ok := PermissionMap[update]; !ok {\n\t\t\tif update != LegacyRealmAdmin && update != LegacyRealmUser {\n\t\t\t\treturn 0, fmt.Errorf(\"provided permission %v is unknown\", update)\n\t\t\t}\n\t\t}\n\n\t\t// Verify that the user making changes has the permissions they are trying\n\t\t// to grant. It is not valid for someone to grant permissions larger than\n\t\t// they currently have.\n\t\tif !Can(actorPermission, update) {\n\t\t\treturn 0, fmt.Errorf(\"actor does not have all scopes which are being granted\")\n\t\t}\n\t\tpermission = permission | update\n\t}\n\n\t// Ensure implied permissions. The actor must also have the implied\n\t// permissions by definition.\n\tpermission = AddImplied(permission)\n\treturn permission, nil\n}\n\n// AddImplied adds any missing implied permissions.\nfunc AddImplied(target Permission) Permission {\n\tfor has, needs := range requiredPermission {\n\t\t// If granted has, ensure that we have all needs.\n\t\tif Can(target, has) {\n\t\t\tfor _, required := range needs {\n\t\t\t\ttarget = target | required\n\t\t\t}\n\t\t}\n\t}\n\treturn target\n}\n\n// ImpliedBy returns any permissions that cause this permission to be added\n// automatically. The return may be nil.\nfunc ImpliedBy(permission Permission) []Permission {\n\treturn impliedBy[permission]\n}\n\n// PermissionNames returns the list of permissions included in the given\n// permission.\nfunc PermissionNames(p Permission) []string {\n\tnames := make([]string, 0, len(PermissionMap))\n\tfor v, k := range PermissionMap {\n\t\tif Can(p, v) {\n\t\t\tnames = append(names, k[0])\n\t\t}\n\t}\n\tsort.Strings(names)\n\treturn names\n}\n\n// Permission is a granular permission. It is an integer instead of a uint\n// because most database systems lack unsigned integer types.\ntype Permission int64\n\n// String implements stringer.\nfunc (p Permission) String() string {\n\tif v, ok := PermissionMap[p]; ok {\n\t\treturn v[0]\n\t}\n\treturn fmt.Sprintf(\"Permission(%d)\", int64(p))\n}\n\n// Value returns the permissions value as an integer for sql drivers.\nfunc (p Permission) Value() (driver.Value, error) {\n\treturn int64(p), nil\n}\n\n// Description returns the description.\nfunc (p Permission) Description() (string, error) {\n\tif v, ok := PermissionMap[p]; ok {\n\t\treturn v[1], nil\n\t}\n\treturn \"\", fmt.Errorf(\"missing description for %s\", p)\n}\n\n// Implied returns the additional implied permissions, if any.\nfunc (p Permission) Implied() []Permission {\n\treturn requiredPermission[p]\n}\n\nconst (\n\t_ Permission = 1 << iota\n\n\t// Audit\n\tAuditRead\n\n\t// API keys\n\tAPIKeyRead\n\tAPIKeyWrite\n\n\t// Codes\n\tCodeIssue\n\tCodeBulkIssue\n\tCodeRead\n\tCodeExpire\n\n\t// Realm settings\n\tSettingsRead\n\tSettingsWrite\n\n\t// Realm statistics\n\tStatsRead\n\n\t// Mobile apps\n\tMobileAppRead\n\tMobileAppWrite\n\n\t// Users\n\tUserRead\n\tUserWrite\n)\n\n// --\n// Required / Implied permissions.\n// Write permissions require subordinate read.\n// --\n\nvar (\n\t// requiredPermissions is not exported since maps cannot be constant.\n\trequiredPermission = map[Permission][]Permission{\n\t\tAPIKeyWrite:    {APIKeyRead},\n\t\tCodeBulkIssue:  {CodeIssue},\n\t\tSettingsWrite:  {SettingsRead},\n\t\tMobileAppWrite: {MobileAppRead},\n\t\tUserWrite:      {UserRead},\n\t}\n\n\t// This is the inverse of the above map, set by the init() func.\n\t// Done in code to ensure it always stays in sync with requiredPermission.\n\timpliedBy = make(map[Permission][]Permission)\n)\n\n// Note: there are multiple init functions in this file. They are organized to be\n// near the thing they are initializing.\n// Yes, go allows multiple init functions in the same module.\nfunc init() {\n\tfor has, needs := range requiredPermission {\n\t\tfor _, perm := range needs {\n\t\t\tif _, ok := impliedBy[perm]; !ok {\n\t\t\t\timpliedBy[perm] = make([]Permission, 0, 1)\n\t\t\t}\n\t\t\timpliedBy[perm] = append(impliedBy[perm], has)\n\t\t}\n\t}\n}\n\n// --\n// Legacy permissions\n// --\n\nconst (\n\t// LegacyRealmUser is a quick reference to the old \"user\" permissions.\n\tLegacyRealmUser Permission = CodeIssue | CodeBulkIssue | CodeRead | CodeExpire\n\n\t// LegacyRealmAdmin is a quick reference to the old \"realm admin\" permissions.\n\tLegacyRealmAdmin Permission = AuditRead |\n\t\tAPIKeyRead | APIKeyWrite |\n\t\tCodeIssue | CodeBulkIssue | CodeRead | CodeExpire |\n\t\tSettingsRead | SettingsWrite |\n\t\tStatsRead |\n\t\tMobileAppRead | MobileAppWrite |\n\t\tUserRead | UserWrite\n)\n", "// Copyright 2020 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage rbac\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestRequiredPermissions(t *testing.T) {\n\tt.Parallel()\n\n\tfor perm, needs := range requiredPermission {\n\t\tperm := perm\n\t\tneeds := needs\n\t\tname := fmt.Sprintf(\"implied_by_%s\", PermissionMap[perm][0])\n\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tactorPermission := perm\n\t\t\tfor _, n := range needs {\n\t\t\t\tactorPermission |= n\n\t\t\t}\n\n\t\t\tgot, err := CompileAndAuthorize(actorPermission, []Permission{perm})\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"missing all required permissions for %v\", PermissionNames(perm))\n\t\t\t}\n\n\t\t\tfor _, n := range needs {\n\t\t\t\tif !Can(got, n) {\n\t\t\t\t\tt.Errorf(\"%v did not imply %v as expected\", PermissionNames(perm), PermissionNames(n))\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"missing\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tif _, err := CompileAndAuthorize(0, []Permission{APIKeyRead}); err == nil {\n\t\t\tt.Errorf(\"expected error\")\n\t\t}\n\t})\n\n\tt.Run(\"legacy_admin\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tif _, err := CompileAndAuthorize(LegacyRealmAdmin, []Permission{LegacyRealmAdmin}); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t})\n\n\tt.Run(\"legacy_user\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tif _, err := CompileAndAuthorize(LegacyRealmAdmin, []Permission{LegacyRealmUser}); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t})\n\n\tt.Run(\"escalate\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tif _, err := CompileAndAuthorize(UserRead|UserWrite, []Permission{16383}); err == nil {\n\t\t\tt.Errorf(\"expected error\")\n\t\t}\n\t})\n}\n\nfunc TestImpliedBy(t *testing.T) {\n\tt.Parallel()\n\n\tif got := ImpliedBy(APIKeyRead); !reflect.DeepEqual(got, []Permission{APIKeyWrite}) {\n\t\tt.Errorf(\"expected %q to imply %q\", APIKeyRead, APIKeyWrite)\n\t}\n\n\tif got := ImpliedBy(APIKeyWrite); len(got) != 0 {\n\t\tt.Errorf(\"expected no implications, got %q\", got)\n\t}\n}\n\nfunc TestPermission_Implied(t *testing.T) {\n\tt.Parallel()\n\n\tif got := APIKeyWrite.Implied(); !reflect.DeepEqual(got, []Permission{APIKeyRead}) {\n\t\tt.Errorf(\"expected %q to imply %q\", APIKeyRead, APIKeyWrite)\n\t}\n}\n\nfunc TestPermissionNames(t *testing.T) {\n\tt.Parallel()\n\n\tcases := []struct {\n\t\tp   Permission\n\t\texp string\n\t}{\n\t\t{0, \"\"},\n\t\t{APIKeyWrite, \"APIKeyWrite\"},\n\t\t{LegacyRealmUser, \"CodeBulkIssue,CodeExpire,CodeIssue,CodeRead\"},\n\t}\n\n\tfor _, tc := range cases {\n\t\ttc := tc\n\n\t\tt.Run(tc.p.String(), func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tif got, want := strings.Join(PermissionNames(tc.p), \",\"), tc.exp; !reflect.DeepEqual(got, want) {\n\t\t\t\tt.Errorf(\"Expected %q to be %q\", got, want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestPermission_String(t *testing.T) {\n\tt.Parallel()\n\n\tcases := []struct {\n\t\tp   Permission\n\t\texp string\n\t}{\n\t\t{0, \"Permission(0)\"},\n\t\t{APIKeyWrite, \"APIKeyWrite\"},\n\t}\n\n\tfor _, tc := range cases {\n\t\ttc := tc\n\n\t\tt.Run(tc.p.String(), func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tif got, want := tc.p.String(), tc.exp; got != want {\n\t\t\t\tt.Errorf(\"Expected %q to be %q\", got, want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestPermission_Value(t *testing.T) {\n\tt.Parallel()\n\n\tcases := []struct {\n\t\tp   Permission\n\t\texp int64\n\t}{\n\t\t{0, 0},\n\t\t{APIKeyWrite, 8},\n\t}\n\n\tfor _, tc := range cases {\n\t\ttc := tc\n\n\t\tt.Run(tc.p.String(), func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tresult, err := tc.p.Value()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tgot, ok := result.(int64)\n\t\t\tif !ok {\n\t\t\t\tt.Fatalf(\"%T is not int64\", result)\n\t\t\t}\n\n\t\t\tif got, want := got, tc.exp; got != want {\n\t\t\t\tt.Errorf(\"expected %v to be %v\", got, want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestPermission_Description(t *testing.T) {\n\tt.Parallel()\n\n\tcases := []struct {\n\t\tp   Permission\n\t\texp string\n\t\terr bool\n\t}{\n\t\t{0, \"\", true},\n\t\t{APIKeyWrite, \"create, update, and delete API keys\", false},\n\t}\n\n\tfor _, tc := range cases {\n\t\ttc := tc\n\n\t\tt.Run(tc.p.String(), func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tresult, err := tc.p.Description()\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tif got, want := result, tc.exp; got != want {\n\t\t\t\tt.Errorf(\"Expected %q to be %q\", got, want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRBAC_Permissions(t *testing.T) {\n\tt.Parallel()\n\n\t// This test might seem like it's redundant with the content in rbac.go, but\n\t// it's designed to ensure that the exact values for existing RBAC permissions\n\t// remain unchanged.\n\tcases := []struct {\n\t\tp   Permission\n\t\texp int64\n\t}{\n\t\t{AuditRead, 2},\n\t\t{APIKeyRead, 4},\n\t\t{APIKeyWrite, 8},\n\t\t{CodeIssue, 16},\n\t\t{CodeBulkIssue, 32},\n\t\t{CodeRead, 64},\n\t\t{CodeExpire, 128},\n\t\t{SettingsRead, 256},\n\t\t{SettingsWrite, 512},\n\t\t{StatsRead, 1024},\n\t\t{MobileAppRead, 2048},\n\t\t{MobileAppWrite, 4096},\n\t\t{UserRead, 8192},\n\t\t{UserWrite, 16384},\n\t}\n\n\tfor _, tc := range cases {\n\t\ttc := tc\n\n\t\tt.Run(tc.p.String(), func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tif got, want := int64(tc.p), tc.exp; got != want {\n\t\t\t\tt.Errorf(\"Expected %d to be %d\", got, want)\n\t\t\t}\n\t\t})\n\t}\n}\n"], "filenames": ["pkg/rbac/rbac.go", "pkg/rbac/rbac_test.go"], "buggy_code_start_loc": [66, 56], "buggy_code_end_loc": [66, 56], "fixing_code_start_loc": [67, 57], "fixing_code_end_loc": [77, 81], "type": "CWE-276", "message": "A privilege escalation vulnerability impacting the Google Exposure Notification Verification Server (versions prior to 0.23.1), allows an attacker who (1) has UserWrite permissions and (2) is using a carefully crafted request or malicious proxy, to create another user with higher privileges than their own. This occurs due to insufficient checks on the allowed set of permissions. The new user creation event would be captured in the Event Log.", "other": {"cve": {"id": "CVE-2021-22538", "sourceIdentifier": "cve-coordination@google.com", "published": "2021-03-31T21:15:16.057", "lastModified": "2021-04-06T14:11:52.257", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A privilege escalation vulnerability impacting the Google Exposure Notification Verification Server (versions prior to 0.23.1), allows an attacker who (1) has UserWrite permissions and (2) is using a carefully crafted request or malicious proxy, to create another user with higher privileges than their own. This occurs due to insufficient checks on the allowed set of permissions. The new user creation event would be captured in the Event Log."}, {"lang": "es", "value": "Una vulnerabilidad de escalada de privilegios que afecta al Google Exposure Notification Verification Server (versiones anteriores a 0.23.1), permite a un atacante que (1) tenga permisos de UserWrite y (2) est\u00e9 usando una petici\u00f3n cuidadosamente dise\u00f1ada o un proxy malicioso, crear otro usuario con un nivel de privilegios mayores que los suyos.&#xa0;Esto se presenta debido a controles insuficientes sobre el conjunto permitido de permisos.&#xa0;El evento de creaci\u00f3n de nuevo usuario se capturar\u00eda en el Registro de Eventos."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "cve-coordination@google.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-276"}]}, {"source": "cve-coordination@google.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:exposure_notifications_verification_server:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.23.1", "matchCriteriaId": "4AB50BC0-EC62-473B-8550-917FB077D093"}]}]}], "references": [{"url": "https://github.com/google/exposure-notifications-verification-server/commit/eb8cf40b12dbe79304f1133c06fb73419383cd95", "source": "cve-coordination@google.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/google/exposure-notifications-verification-server/releases/tag/v0.23.1", "source": "cve-coordination@google.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/google/exposure-notifications-verification-server/releases/tag/v0.24.0", "source": "cve-coordination@google.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/google/exposure-notifications-verification-server/security/advisories/GHSA-5v95-v8c8-3rh6", "source": "cve-coordination@google.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/google/exposure-notifications-verification-server/commit/eb8cf40b12dbe79304f1133c06fb73419383cd95"}}