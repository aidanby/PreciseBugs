{"buggy_code": ["package graphql_test\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/graph-gophers/graphql-go\"\n\tgqlerrors \"github.com/graph-gophers/graphql-go/errors\"\n\t\"github.com/graph-gophers/graphql-go/example/starwars\"\n\t\"github.com/graph-gophers/graphql-go/gqltesting\"\n\t\"github.com/graph-gophers/graphql-go/introspection\"\n\t\"github.com/graph-gophers/graphql-go/trace\"\n)\n\ntype helloWorldResolver1 struct{}\n\nfunc (r *helloWorldResolver1) Hello() string {\n\treturn \"Hello world!\"\n}\n\ntype helloWorldResolver2 struct{}\n\nfunc (r *helloWorldResolver2) Hello(ctx context.Context) (string, error) {\n\treturn \"Hello world!\", nil\n}\n\ntype helloSnakeResolver1 struct{}\n\nfunc (r *helloSnakeResolver1) HelloHTML() string {\n\treturn \"Hello snake!\"\n}\n\nfunc (r *helloSnakeResolver1) SayHello(args struct{ FullName string }) string {\n\treturn \"Hello \" + args.FullName + \"!\"\n}\n\ntype helloSnakeResolver2 struct{}\n\nfunc (r *helloSnakeResolver2) HelloHTML(ctx context.Context) (string, error) {\n\treturn \"Hello snake!\", nil\n}\n\nfunc (r *helloSnakeResolver2) SayHello(ctx context.Context, args struct{ FullName string }) (string, error) {\n\treturn \"Hello \" + args.FullName + \"!\", nil\n}\n\ntype theNumberResolver struct {\n\tnumber int32\n}\n\nfunc (r *theNumberResolver) TheNumber() int32 {\n\treturn r.number\n}\n\nfunc (r *theNumberResolver) ChangeTheNumber(args struct{ NewNumber int32 }) *theNumberResolver {\n\tr.number = args.NewNumber\n\treturn r\n}\n\ntype timeResolver struct{}\n\nfunc (r *timeResolver) AddHour(args struct{ Time graphql.Time }) graphql.Time {\n\treturn graphql.Time{Time: args.Time.Add(time.Hour)}\n}\n\ntype echoResolver struct{}\n\nfunc (r *echoResolver) Echo(args struct{ Value *string }) *string {\n\treturn args.Value\n}\n\nvar starwarsSchema = graphql.MustParseSchema(starwars.Schema, &starwars.Resolver{})\n\ntype ResolverError interface {\n\terror\n\tExtensions() map[string]interface{}\n}\n\ntype resolverNotFoundError struct {\n\tCode    string `json:\"code\"`\n\tMessage string `json:\"message\"`\n}\n\nfunc (e resolverNotFoundError) Error() string {\n\treturn fmt.Sprintf(\"Error [%s]: %s\", e.Code, e.Message)\n}\n\nfunc (e resolverNotFoundError) Extensions() map[string]interface{} {\n\treturn map[string]interface{}{\n\t\t\"code\":    e.Code,\n\t\t\"message\": e.Message,\n\t}\n}\n\ntype findDroidResolver struct{}\n\nfunc (r *findDroidResolver) FindDroid(ctx context.Context) (string, error) {\n\treturn \"\", resolverNotFoundError{\n\t\tCode:    \"NotFound\",\n\t\tMessage: \"This is not the droid you are looking for\",\n\t}\n}\n\nvar (\n\tdroidNotFoundError = resolverNotFoundError{\n\t\tCode:    \"NotFound\",\n\t\tMessage: \"This is not the droid you are looking for\",\n\t}\n\tquoteError = errors.New(\"Bleep bloop\")\n\n\tr2d2          = &droidResolver{name: \"R2-D2\"}\n\tc3po          = &droidResolver{name: \"C-3PO\"}\n\tnotFoundDroid = &droidResolver{err: droidNotFoundError}\n)\n\ntype findDroidsResolver struct{}\n\nfunc (r *findDroidsResolver) FindDroids(ctx context.Context) []*droidResolver {\n\treturn []*droidResolver{r2d2, notFoundDroid, c3po}\n}\n\nfunc (r *findDroidsResolver) FindNilDroids(ctx context.Context) *[]*droidResolver {\n\treturn &[]*droidResolver{r2d2, nil, c3po}\n}\n\ntype findDroidOrHumanResolver struct{}\n\nfunc (r *findDroidOrHumanResolver) FindHuman(ctx context.Context) (*string, error) {\n\thuman := \"human\"\n\treturn &human, nil\n}\n\nfunc (r *findDroidOrHumanResolver) FindDroid(ctx context.Context) (*droidResolver, error) {\n\treturn nil, notFoundDroid.err\n}\n\ntype droidResolver struct {\n\tname string\n\terr  error\n}\n\nfunc (d *droidResolver) Name() (string, error) {\n\tif d.err != nil {\n\t\treturn \"\", d.err\n\t}\n\treturn d.name, nil\n}\n\nfunc (d *droidResolver) Quotes() ([]string, error) {\n\tswitch d.name {\n\tcase r2d2.name:\n\t\treturn nil, quoteError\n\tcase c3po.name:\n\t\treturn []string{\"We're doomed!\", \"R2-D2, where are you?\"}, nil\n\t}\n\treturn nil, nil\n}\n\ntype discussPlanResolver struct{}\n\nfunc (r *discussPlanResolver) DismissVader(ctx context.Context) (string, error) {\n\treturn \"\", errors.New(\"I find your lack of faith disturbing\")\n}\n\nfunc TestHelloWorld(t *testing.T) {\n\tt.Parallel()\n\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\thello: String!\n\t\t\t\t}\n\t\t\t`, &helloWorldResolver1{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\thello\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hello\": \"Hello world!\"\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\thello: String!\n\t\t\t\t}\n\t\t\t`, &helloWorldResolver2{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\thello\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hello\": \"Hello world!\"\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nfunc TestHelloSnake(t *testing.T) {\n\tt.Parallel()\n\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\thello_html: String!\n\t\t\t\t}\n\t\t\t`, &helloSnakeResolver1{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\thello_html\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hello_html\": \"Hello snake!\"\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\thello_html: String!\n\t\t\t\t}\n\t\t\t`, &helloSnakeResolver2{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\thello_html\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hello_html\": \"Hello snake!\"\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nfunc TestHelloSnakeArguments(t *testing.T) {\n\tt.Parallel()\n\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tsay_hello(full_name: String!): String!\n\t\t\t\t}\n\t\t\t`, &helloSnakeResolver1{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tsay_hello(full_name: \"Rob Pike\")\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"say_hello\": \"Hello Rob Pike!\"\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tsay_hello(full_name: String!): String!\n\t\t\t\t}\n\t\t\t`, &helloSnakeResolver2{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tsay_hello(full_name: \"Rob Pike\")\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"say_hello\": \"Hello Rob Pike!\"\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nfunc TestRootOperations_invalidSchema(t *testing.T) {\n\ttype args struct {\n\t\tSchema string\n\t}\n\ttype want struct {\n\t\tError string\n\t}\n\ttestTable := map[string]struct {\n\t\tArgs args\n\t\tWant want\n\t}{\n\t\t\"Empty schema\": {\n\t\t\tWant: want{Error: `root operation \"query\" must be defined`},\n\t\t},\n\t\t\"Query declared by schema, but type not present\": {\n\t\t\tArgs: args{\n\t\t\t\tSchema: `\n\t\t\t\t\tschema {\n\t\t\t\t\t\tquery: Query\n\t\t\t\t\t}\n\t\t\t\t`,\n\t\t\t},\n\t\t\tWant: want{Error: `graphql: type \"Query\" not found`},\n\t\t},\n\t\t\"Query as incorrect type\": {\n\t\t\tArgs: args{\n\t\t\t\tSchema: `\n\t\t\t\t\tschema {\n\t\t\t\t\t\tquery: String\n\t\t\t\t\t}\n\t\t\t\t`,\n\t\t\t},\n\t\t\tWant: want{Error: `root operation \"query\" must be an OBJECT`},\n\t\t},\n\t\t\"Query with custom name, schema omitted\": {\n\t\t\tArgs: args{\n\t\t\t\tSchema: `\n\t\t\t\t\ttype QueryType {\n\t\t\t\t\t\thello: String!\n\t\t\t\t\t}\n\t\t\t\t`,\n\t\t\t},\n\t\t\tWant: want{Error: `root operation \"query\" must be defined`},\n\t\t},\n\t\t\"Mutation as incorrect type\": {\n\t\t\tArgs: args{\n\t\t\t\tSchema: `\n\t\t\t\t\tschema {\n\t\t\t\t\t\tquery: Query\n\t\t\t\t\t\tmutation: String\n\t\t\t\t\t}\n\t\t\t\t\ttype Query {\n\t\t\t\t\t\tthing: String\n\t\t\t\t\t}\n\t\t\t\t`,\n\t\t\t},\n\t\t\tWant: want{Error: `root operation \"mutation\" must be an OBJECT`},\n\t\t},\n\t\t\"Mutation declared by schema, but type not present\": {\n\t\t\tArgs: args{\n\t\t\t\tSchema: `\n\t\t\t\t\tschema {\n\t\t\t\t\t\tquery: Query\n\t\t\t\t\t\tmutation: Mutation\n\t\t\t\t\t}\n\t\t\t\t\ttype Query {\n\t\t\t\t\t\thello: String!\n\t\t\t\t\t}\n\t\t\t\t`,\n\t\t\t},\n\t\t\tWant: want{Error: `graphql: type \"Mutation\" not found`},\n\t\t},\n\t}\n\n\tfor name, tt := range testTable {\n\t\ttt := tt\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\t_, err := graphql.ParseSchema(tt.Args.Schema, nil)\n\t\t\tif err == nil || err.Error() != tt.Want.Error {\n\t\t\t\tt.Logf(\"got:  %v\", err)\n\t\t\t\tt.Logf(\"want: %s\", tt.Want.Error)\n\t\t\t\tt.Fail()\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRootOperations_validSchema(t *testing.T) {\n\ttype resolver struct {\n\t\thelloSaidResolver\n\t\thelloWorldResolver1\n\t\ttheNumberResolver\n\t}\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\t// Query only, default name with `schema` omitted\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\ttype Query {\n\t\t\t\t\thello: String!\n\t\t\t\t}\n\t\t\t`, &resolver{}),\n\t\t\tQuery:          `{ hello }`,\n\t\t\tExpectedResult: `{\"hello\": \"Hello world!\"}`,\n\t\t},\n\t\t{\n\t\t\t// Query only, default name with `schema` present\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\t\t\t\ttype Query {\n\t\t\t\t\thello: String!\n\t\t\t\t}\n\t\t\t`, &resolver{}),\n\t\t\tQuery:          `{ hello }`,\n\t\t\tExpectedResult: `{\"hello\": \"Hello world!\"}`,\n\t\t},\n\t\t{\n\t\t\t// Query only, custom name\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: QueryType\n\t\t\t\t}\n\t\t\t\ttype QueryType {\n\t\t\t\t\thello: String!\n\t\t\t\t}\n\t\t\t`, &resolver{}),\n\t\t\tQuery:          `{ hello }`,\n\t\t\tExpectedResult: `{\"hello\": \"Hello world!\"}`,\n\t\t},\n\t\t{\n\t\t\t// Query+Mutation, default names with `schema` omitted\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\ttype Query {\n\t\t\t\t\thello: String!\n\t\t\t\t}\n\t\t\t\ttype Mutation {\n\t\t\t\t\tchangeTheNumber(newNumber: Int!): ChangedNumber!\n\t\t\t\t}\n\t\t\t\ttype ChangedNumber {\n\t\t\t\t\ttheNumber: Int!\n\t\t\t\t}\n\t\t\t`, &resolver{}),\n\t\t\tQuery: `\n\t\t\t\tmutation {\n\t\t\t\t\tchangeTheNumber(newNumber: 1) {\n\t\t\t\t\t\ttheNumber\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `{\"changeTheNumber\": {\"theNumber\": 1}}`,\n\t\t},\n\t\t{\n\t\t\t// Query+Mutation, custom names\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: QueryType\n\t\t\t\t\tmutation: MutationType\n\t\t\t\t}\n\t\t\t\ttype QueryType {\n\t\t\t\t\thello: String!\n\t\t\t\t}\n\t\t\t\ttype MutationType {\n\t\t\t\t\tchangeTheNumber(newNumber: Int!): ChangedNumber!\n\t\t\t\t}\n\t\t\t\ttype ChangedNumber {\n\t\t\t\t\ttheNumber: Int!\n\t\t\t\t}\n\t\t\t`, &resolver{}),\n\t\t\tQuery: `\n\t\t\t\tmutation {\n\t\t\t\t\tchangeTheNumber(newNumber: 1) {\n\t\t\t\t\t\ttheNumber\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `{\"changeTheNumber\": {\"theNumber\": 1}}`,\n\t\t},\n\t\t{\n\t\t\t// Mutation with custom name, schema omitted\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\ttype Query {\n\t\t\t\t\thello: String!\n\t\t\t\t}\n\t\t\t\ttype MutationType {\n\t\t\t\t\tchangeTheNumber(newNumber: Int!): ChangedNumber!\n\t\t\t\t}\n\t\t\t\ttype ChangedNumber {\n\t\t\t\t\ttheNumber: Int!\n\t\t\t\t}\n\t\t\t`, &resolver{}),\n\t\t\tQuery: `\n\t\t\t\tmutation {\n\t\t\t\t\tchangeTheNumber(newNumber: 1) {\n\t\t\t\t\t\ttheNumber\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{{Message: \"no mutations are offered by the schema\"}},\n\t\t},\n\t\t{\n\t\t\t// Explicit schema without mutation field\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\t\t\t\ttype Query {\n\t\t\t\t\thello: String!\n\t\t\t\t}\n\t\t\t\ttype Mutation {\n\t\t\t\t\tchangeTheNumber(newNumber: Int!): ChangedNumber!\n\t\t\t\t}\n\t\t\t\ttype ChangedNumber {\n\t\t\t\t\ttheNumber: Int!\n\t\t\t\t}\n\t\t\t`, &resolver{}),\n\t\t\tQuery: `\n\t\t\t\tmutation {\n\t\t\t\t\tchangeTheNumber(newNumber: 1) {\n\t\t\t\t\t\ttheNumber\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{{Message: \"no mutations are offered by the schema\"}},\n\t\t},\n\t})\n}\n\nfunc TestBasic(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\thero {\n\t\t\t\t\t\tid\n\t\t\t\t\t\tname\n\t\t\t\t\t\tfriends {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hero\": {\n\t\t\t\t\t\t\"id\": \"2001\",\n\t\t\t\t\t\t\"name\": \"R2-D2\",\n\t\t\t\t\t\t\"friends\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Luke Skywalker\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Han Solo\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Leia Organa\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\ntype testEmbeddedStructResolver struct{}\n\nfunc (_ *testEmbeddedStructResolver) Course() courseResolver {\n\treturn courseResolver{\n\t\tCourseMeta: CourseMeta{\n\t\t\tName:       \"Biology\",\n\t\t\tTimestamps: Timestamps{CreatedAt: \"yesterday\", UpdatedAt: \"today\"},\n\t\t},\n\t\tInstructor: Instructor{Name: \"Socrates\"},\n\t}\n}\n\ntype courseResolver struct {\n\tCourseMeta\n\tInstructor Instructor\n}\n\ntype CourseMeta struct {\n\tName string\n\tTimestamps\n}\n\ntype Instructor struct {\n\tName string\n}\n\ntype Timestamps struct {\n\tCreatedAt string\n\tUpdatedAt string\n}\n\nfunc TestEmbeddedStruct(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tcourse: Course!\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ttype Course {\n\t\t\t\t\tname: String!\n\t\t\t\t\tcreatedAt: String!\n\t\t\t\t\tupdatedAt: String!\n\t\t\t\t\tinstructor: Instructor!\n\t\t\t\t}\n\n\t\t\t\ttype Instructor {\n\t\t\t\t\tname: String!\n\t\t\t\t}\n\t\t\t`, &testEmbeddedStructResolver{}, graphql.UseFieldResolvers()),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tcourse{\n\t\t\t\t\t\tname\n\t\t\t\t\t\tcreatedAt\n\t\t\t\t\t\tupdatedAt\n\t\t\t\t\t\tinstructor {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"course\": {\n\t\t\t\t\t\t\"name\": \"Biology\",\n\t\t\t\t\t\t\"createdAt\": \"yesterday\",\n\t\t\t\t\t\t\"updatedAt\": \"today\",\n\t\t\t\t\t\t\"instructor\": {\n\t\t\t\t\t\t\t\"name\":\"Socrates\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\ntype testNilInterfaceResolver struct{}\n\nfunc (r *testNilInterfaceResolver) A() interface{ Z() int32 } {\n\treturn nil\n}\n\nfunc (r *testNilInterfaceResolver) B() (interface{ Z() int32 }, error) {\n\treturn nil, errors.New(\"x\")\n}\n\nfunc (r *testNilInterfaceResolver) C() (interface{ Z() int32 }, error) {\n\treturn nil, nil\n}\n\nfunc TestNilInterface(t *testing.T) {\n\tt.Parallel()\n\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\ta: T\n\t\t\t\t\tb: T\n\t\t\t\t\tc: T\n\t\t\t\t}\n\n\t\t\t\ttype T {\n\t\t\t\t\tz: Int!\n\t\t\t\t}\n\t\t\t`, &testNilInterfaceResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\ta { z }\n\t\t\t\t\tb { z }\n\t\t\t\t\tc { z }\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"a\": null,\n\t\t\t\t\t\"b\": null,\n\t\t\t\t\t\"c\": null\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage:       \"x\",\n\t\t\t\t\tPath:          []interface{}{\"b\"},\n\t\t\t\t\tResolverError: errors.New(\"x\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t})\n}\n\nfunc TestErrorPropagationInLists(t *testing.T) {\n\tt.Parallel()\n\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tfindDroids: [Droid!]!\n\t\t\t\t}\n\t\t\t\ttype Droid {\n\t\t\t\t\tname: String!\n\t\t\t\t}\n\t\t\t`, &findDroidsResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tfindDroids {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\tnull\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage:       droidNotFoundError.Error(),\n\t\t\t\t\tPath:          []interface{}{\"findDroids\", 1, \"name\"},\n\t\t\t\t\tResolverError: droidNotFoundError,\n\t\t\t\t\tExtensions:    map[string]interface{}{\"code\": droidNotFoundError.Code, \"message\": droidNotFoundError.Message},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tfindDroids: [Droid]!\n\t\t\t\t}\n\t\t\t\ttype Droid {\n\t\t\t\t\tname: String!\n\t\t\t\t}\n\t\t\t`, &findDroidsResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tfindDroids {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"findDroids\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"name\": \"R2-D2\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"name\": \"C-3PO\"\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage:       droidNotFoundError.Error(),\n\t\t\t\t\tPath:          []interface{}{\"findDroids\", 1, \"name\"},\n\t\t\t\t\tResolverError: droidNotFoundError,\n\t\t\t\t\tExtensions:    map[string]interface{}{\"code\": droidNotFoundError.Code, \"message\": droidNotFoundError.Message},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tfindNilDroids: [Droid!]\n\t\t\t\t}\n\t\t\t\ttype Droid {\n\t\t\t\t\tname: String!\n\t\t\t\t}\n\t\t\t`, &findDroidsResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tfindNilDroids {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"findNilDroids\": null\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage: `graphql: got nil for non-null \"Droid\"`,\n\t\t\t\t\tPath:    []interface{}{\"findNilDroids\", 1},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tfindNilDroids: [Droid]\n\t\t\t\t}\n\t\t\t\ttype Droid {\n\t\t\t\t\tname: String!\n\t\t\t\t}\n\t\t\t`, &findDroidsResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tfindNilDroids {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"findNilDroids\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"name\": \"R2-D2\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"name\": \"C-3PO\"\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tfindDroids: [Droid]!\n\t\t\t\t}\n\t\t\t\ttype Droid {\n\t\t\t\t\tquotes: [String!]!\n\t\t\t\t}\n\t\t\t`, &findDroidsResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tfindDroids {\n\t\t\t\t\t\tquotes\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"findDroids\": [\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"quotes\": []\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"quotes\": [\n\t\t\t\t\t\t\t\t\"We're doomed!\",\n\t\t\t\t\t\t\t\t\"R2-D2, where are you?\"\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage:       quoteError.Error(),\n\t\t\t\t\tResolverError: quoteError,\n\t\t\t\t\tPath:          []interface{}{\"findDroids\", 0, \"quotes\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tfindNilDroids: [Droid!]\n\t\t\t\t}\n\t\t\t\ttype Droid {\n\t\t\t\t\tname: String!\n\t\t\t\t\tquotes: [String!]!\n\t\t\t\t}\n\t\t\t`, &findDroidsResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tfindNilDroids {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tquotes\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"findNilDroids\": null\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage:       quoteError.Error(),\n\t\t\t\t\tResolverError: quoteError,\n\t\t\t\t\tPath:          []interface{}{\"findNilDroids\", 0, \"quotes\"},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tMessage: `graphql: got nil for non-null \"Droid\"`,\n\t\t\t\t\tPath:    []interface{}{\"findNilDroids\", 1},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t})\n}\n\nfunc TestErrorWithExtensions(t *testing.T) {\n\tt.Parallel()\n\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tFindDroid: Droid!\n\t\t\t\t\tFindHuman: String\n\t\t\t\t}\n\t\t\t\ttype Droid {\n\t\t\t\t\tName: String!\n\t\t\t\t}\n\t\t\t`, &findDroidOrHumanResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tFindDroid {\n\t\t\t\t\t\tName\n\t\t\t\t\t}\n\t\t\t\t\tFindHuman\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\tnull\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage:       droidNotFoundError.Error(),\n\t\t\t\t\tPath:          []interface{}{\"FindDroid\"},\n\t\t\t\t\tResolverError: droidNotFoundError,\n\t\t\t\t\tExtensions:    map[string]interface{}{\"code\": droidNotFoundError.Code, \"message\": droidNotFoundError.Message},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t})\n}\n\nfunc TestErrorWithNoExtensions(t *testing.T) {\n\tt.Parallel()\n\n\terr := errors.New(\"I find your lack of faith disturbing\")\n\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tDismissVader: String!\n\t\t\t\t}\n\t\t\t`, &discussPlanResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tDismissVader\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\tnull\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage:       err.Error(),\n\t\t\t\t\tPath:          []interface{}{\"DismissVader\"},\n\t\t\t\t\tResolverError: err,\n\t\t\t\t\tExtensions:    nil,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t})\n}\n\nfunc TestArguments(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\thuman(id: \"1000\") {\n\t\t\t\t\t\tname\n\t\t\t\t\t\theight\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"human\": {\n\t\t\t\t\t\t\"name\": \"Luke Skywalker\",\n\t\t\t\t\t\t\"height\": 1.72\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\thuman(id: \"1000\") {\n\t\t\t\t\t\tname\n\t\t\t\t\t\theight(unit: FOOT)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"human\": {\n\t\t\t\t\t\t\"name\": \"Luke Skywalker\",\n\t\t\t\t\t\t\"height\": 5.6430448\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nfunc TestAliases(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tempireHero: hero(episode: EMPIRE) {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t\tjediHero: hero(episode: JEDI) {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"empireHero\": {\n\t\t\t\t\t\t\"name\": \"Luke Skywalker\"\n\t\t\t\t\t},\n\t\t\t\t\t\"jediHero\": {\n\t\t\t\t\t\t\"name\": \"R2-D2\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nfunc TestFragments(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tleftComparison: hero(episode: EMPIRE) {\n\t\t\t\t\t\t...comparisonFields\n\t\t\t\t\t\t...height\n\t\t\t\t\t}\n\t\t\t\t\trightComparison: hero(episode: JEDI) {\n\t\t\t\t\t\t...comparisonFields\n\t\t\t\t\t\t...height\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfragment comparisonFields on Character {\n\t\t\t\t\tname\n\t\t\t\t\tappearsIn\n\t\t\t\t\tfriends {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfragment height on Human {\n\t\t\t\t\theight\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"leftComparison\": {\n\t\t\t\t\t\t\"name\": \"Luke Skywalker\",\n\t\t\t\t\t\t\"appearsIn\": [\n\t\t\t\t\t\t\t\"NEWHOPE\",\n\t\t\t\t\t\t\t\"EMPIRE\",\n\t\t\t\t\t\t\t\"JEDI\"\n\t\t\t\t\t\t],\n\t\t\t\t\t\t\"friends\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Han Solo\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Leia Organa\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"C-3PO\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"R2-D2\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t],\n\t\t\t\t\t\t\"height\": 1.72\n\t\t\t\t\t},\n\t\t\t\t\t\"rightComparison\": {\n\t\t\t\t\t\t\"name\": \"R2-D2\",\n\t\t\t\t\t\t\"appearsIn\": [\n\t\t\t\t\t\t\t\"NEWHOPE\",\n\t\t\t\t\t\t\t\"EMPIRE\",\n\t\t\t\t\t\t\t\"JEDI\"\n\t\t\t\t\t\t],\n\t\t\t\t\t\t\"friends\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Luke Skywalker\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Han Solo\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Leia Organa\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nfunc TestVariables(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tquery HeroNameAndFriends($episode: Episode) {\n\t\t\t\t\thero(episode: $episode) {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tVariables: map[string]interface{}{\n\t\t\t\t\"episode\": \"JEDI\",\n\t\t\t},\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hero\": {\n\t\t\t\t\t\t\"name\": \"R2-D2\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tquery HeroNameAndFriends($episode: Episode) {\n\t\t\t\t\thero(episode: $episode) {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tVariables: map[string]interface{}{\n\t\t\t\t\"episode\": \"EMPIRE\",\n\t\t\t},\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hero\": {\n\t\t\t\t\t\t\"name\": \"Luke Skywalker\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\techo(value: String): String\n\t\t\t\t}\n\t\t\t`, &echoResolver{}),\n\t\t\tQuery: `\n\t\t\t\tquery Echo($value:String = \"default\"){\n\t\t\t\t\techo(value:$value)\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"echo\": \"default\"\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nfunc TestSkipDirective(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tquery Hero($episode: Episode, $withoutFriends: Boolean!) {\n\t\t\t\t\thero(episode: $episode) {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tfriends @skip(if: $withoutFriends) {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tVariables: map[string]interface{}{\n\t\t\t\t\"episode\":        \"JEDI\",\n\t\t\t\t\"withoutFriends\": true,\n\t\t\t},\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hero\": {\n\t\t\t\t\t\t\"name\": \"R2-D2\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tquery Hero($episode: Episode, $withoutFriends: Boolean!) {\n\t\t\t\t\thero(episode: $episode) {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tfriends @skip(if: $withoutFriends) {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tVariables: map[string]interface{}{\n\t\t\t\t\"episode\":        \"JEDI\",\n\t\t\t\t\"withoutFriends\": false,\n\t\t\t},\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hero\": {\n\t\t\t\t\t\t\"name\": \"R2-D2\",\n\t\t\t\t\t\t\"friends\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Luke Skywalker\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Han Solo\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Leia Organa\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nfunc TestIncludeDirective(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tquery Hero($episode: Episode, $withFriends: Boolean!) {\n\t\t\t\t\thero(episode: $episode) {\n\t\t\t\t\t\tname\n\t\t\t\t\t\t...friendsFragment @include(if: $withFriends)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfragment friendsFragment on Character {\n\t\t\t\t\tfriends {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tVariables: map[string]interface{}{\n\t\t\t\t\"episode\":     \"JEDI\",\n\t\t\t\t\"withFriends\": false,\n\t\t\t},\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hero\": {\n\t\t\t\t\t\t\"name\": \"R2-D2\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tquery Hero($episode: Episode, $withFriends: Boolean!) {\n\t\t\t\t\thero(episode: $episode) {\n\t\t\t\t\t\tname\n\t\t\t\t\t\t...friendsFragment @include(if: $withFriends)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfragment friendsFragment on Character {\n\t\t\t\t\tfriends {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tVariables: map[string]interface{}{\n\t\t\t\t\"episode\":     \"JEDI\",\n\t\t\t\t\"withFriends\": true,\n\t\t\t},\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hero\": {\n\t\t\t\t\t\t\"name\": \"R2-D2\",\n\t\t\t\t\t\t\"friends\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Luke Skywalker\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Han Solo\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Leia Organa\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\ntype testDeprecatedDirectiveResolver struct{}\n\nfunc (r *testDeprecatedDirectiveResolver) A() int32 {\n\treturn 0\n}\n\nfunc (r *testDeprecatedDirectiveResolver) B() int32 {\n\treturn 0\n}\n\nfunc (r *testDeprecatedDirectiveResolver) C() int32 {\n\treturn 0\n}\n\nfunc TestDeprecatedDirective(t *testing.T) {\n\tt.Parallel()\n\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\ta: Int!\n\t\t\t\t\tb: Int! @deprecated\n\t\t\t\t\tc: Int! @deprecated(reason: \"We don't like it\")\n\t\t\t\t}\n\t\t\t`, &testDeprecatedDirectiveResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\t__type(name: \"Query\") {\n\t\t\t\t\t\tfields {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t\tallFields: fields(includeDeprecated: true) {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\tisDeprecated\n\t\t\t\t\t\t\tdeprecationReason\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"__type\": {\n\t\t\t\t\t\t\"fields\": [\n\t\t\t\t\t\t\t{ \"name\": \"a\" }\n\t\t\t\t\t\t],\n\t\t\t\t\t\t\"allFields\": [\n\t\t\t\t\t\t\t{ \"name\": \"a\", \"isDeprecated\": false, \"deprecationReason\": null },\n\t\t\t\t\t\t\t{ \"name\": \"b\", \"isDeprecated\": true, \"deprecationReason\": \"No longer supported\" },\n\t\t\t\t\t\t\t{ \"name\": \"c\", \"isDeprecated\": true, \"deprecationReason\": \"We don't like it\" }\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t}\n\n\t\t\t\tenum Test {\n\t\t\t\t\tA\n\t\t\t\t\tB @deprecated\n\t\t\t\t\tC @deprecated(reason: \"We don't like it\")\n\t\t\t\t}\n\t\t\t`, &testDeprecatedDirectiveResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\t__type(name: \"Test\") {\n\t\t\t\t\t\tenumValues {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t\tallEnumValues: enumValues(includeDeprecated: true) {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\tisDeprecated\n\t\t\t\t\t\t\tdeprecationReason\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"__type\": {\n\t\t\t\t\t\t\"enumValues\": [\n\t\t\t\t\t\t\t{ \"name\": \"A\" }\n\t\t\t\t\t\t],\n\t\t\t\t\t\t\"allEnumValues\": [\n\t\t\t\t\t\t\t{ \"name\": \"A\", \"isDeprecated\": false, \"deprecationReason\": null },\n\t\t\t\t\t\t\t{ \"name\": \"B\", \"isDeprecated\": true, \"deprecationReason\": \"No longer supported\" },\n\t\t\t\t\t\t\t{ \"name\": \"C\", \"isDeprecated\": true, \"deprecationReason\": \"We don't like it\" }\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\ntype testBadEnumResolver struct{}\n\nfunc (r *testBadEnumResolver) Hero() *testBadEnumCharacterResolver {\n\treturn &testBadEnumCharacterResolver{}\n}\n\ntype testBadEnumCharacterResolver struct{}\n\nfunc (r *testBadEnumCharacterResolver) Name() string {\n\treturn \"Spock\"\n}\n\nfunc (r *testBadEnumCharacterResolver) AppearsIn() []string {\n\treturn []string{\"STAR_TREK\"}\n}\n\nfunc TestEnums(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t// Valid input enum supplied in query text\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tquery HeroForEpisode {\n\t\t\t\t\thero(episode: EMPIRE) {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hero\": {\n\t\t\t\t\t\t\"name\": \"Luke Skywalker\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t\t// Invalid input enum supplied in query text\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tquery HeroForEpisode {\n\t\t\t\t\thero(episode: WRATH_OF_KHAN) {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage:   \"Argument \\\"episode\\\" has invalid value WRATH_OF_KHAN.\\nExpected type \\\"Episode\\\", found WRATH_OF_KHAN.\",\n\t\t\t\t\tLocations: []gqlerrors.Location{{Column: 20, Line: 3}},\n\t\t\t\t\tRule:      \"ArgumentsOfCorrectType\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t// Valid input enum supplied in variables\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tquery HeroForEpisode($episode: Episode!) {\n\t\t\t\t\thero(episode: $episode) {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tVariables: map[string]interface{}{\"episode\": \"JEDI\"},\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hero\": {\n\t\t\t\t\t\t\"name\": \"R2-D2\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t\t// Invalid input enum supplied in variables\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tquery HeroForEpisode($episode: Episode!) {\n\t\t\t\t\thero(episode: $episode) {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tVariables: map[string]interface{}{\"episode\": \"FINAL_FRONTIER\"},\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage:   \"Variable \\\"episode\\\" has invalid value FINAL_FRONTIER.\\nExpected type \\\"Episode\\\", found FINAL_FRONTIER.\",\n\t\t\t\t\tLocations: []gqlerrors.Location{{Column: 26, Line: 2}},\n\t\t\t\t\tRule:      \"VariablesOfCorrectType\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t// Valid enum value in response\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tquery Hero {\n\t\t\t\t\thero {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tappearsIn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hero\": {\n\t\t\t\t\t\t\"name\": \"R2-D2\",\n\t\t\t\t\t\t\"appearsIn\": [\"NEWHOPE\",\"EMPIRE\",\"JEDI\"]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t\t// Invalid enum value in response\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\thero: Character\n\t\t\t\t}\n\n\t\t\t\tenum Episode {\n\t\t\t\t\tNEWHOPE\n\t\t\t\t\tEMPIRE\n\t\t\t\t\tJEDI\n\t\t\t\t}\n\n\t\t\t\ttype Character {\n\t\t\t\t\tname: String!\n\t\t\t\t\tappearsIn: [Episode!]!\n\t\t\t\t}\n\t\t\t`, &testBadEnumResolver{}),\n\t\t\tQuery: `\n\t\t\t\tquery Hero {\n\t\t\t\t\thero {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tappearsIn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `{\n\t\t\t\t\"hero\": null\n\t\t\t}`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage: \"Invalid value STAR_TREK.\\nExpected type Episode, found STAR_TREK.\",\n\t\t\t\t\tPath:    []interface{}{\"hero\", \"appearsIn\", 0},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t})\n}\n\nfunc TestInlineFragments(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tquery HeroForEpisode($episode: Episode!) {\n\t\t\t\t\thero(episode: $episode) {\n\t\t\t\t\t\tname\n\t\t\t\t\t\t... on Droid {\n\t\t\t\t\t\t\tprimaryFunction\n\t\t\t\t\t\t}\n\t\t\t\t\t\t... on Human {\n\t\t\t\t\t\t\theight\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tVariables: map[string]interface{}{\n\t\t\t\t\"episode\": \"JEDI\",\n\t\t\t},\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hero\": {\n\t\t\t\t\t\t\"name\": \"R2-D2\",\n\t\t\t\t\t\t\"primaryFunction\": \"Astromech\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tquery HeroForEpisode($episode: Episode!) {\n\t\t\t\t\thero(episode: $episode) {\n\t\t\t\t\t\tname\n\t\t\t\t\t\t... on Droid {\n\t\t\t\t\t\t\tprimaryFunction\n\t\t\t\t\t\t}\n\t\t\t\t\t\t... on Human {\n\t\t\t\t\t\t\theight\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tVariables: map[string]interface{}{\n\t\t\t\t\"episode\": \"EMPIRE\",\n\t\t\t},\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hero\": {\n\t\t\t\t\t\t\"name\": \"Luke Skywalker\",\n\t\t\t\t\t\t\"height\": 1.72\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tquery CharacterSearch {\n\t\t\t\t\tsearch(text: \"C-3PO\") {\n\t\t\t\t\t\t... on Character {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"search\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"name\": \"C-3PO\"\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tquery CharacterSearch {\n\t\t\t\t\thero {\n\t\t\t\t\t\t... on Character {\n\t\t\t\t\t\t\t... on Human {\n\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t... on Droid {\n\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hero\": {\n\t\t\t\t\t\t\"name\": \"R2-D2\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: socialSchema,\n\t\t\tQuery: `\n\t\t\t\tquery {\n\t\t\t\t\tadmin(id: \"0x01\") {\n\t\t\t\t\t\t... on User {\n\t\t\t\t\t\t\temail\n\t\t\t\t\t\t}\n\t\t\t\t\t\t... on Person {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"admin\": {\n\t\t\t\t\t\t\"email\": \"Albus@hogwarts.com\",\n\t\t\t\t\t\t\"name\": \"Albus Dumbledore\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nfunc TestTypeName(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tsearch(text: \"an\") {\n\t\t\t\t\t\t__typename\n\t\t\t\t\t\t... on Human {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t\t... on Droid {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t\t... on Starship {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"search\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"__typename\": \"Human\",\n\t\t\t\t\t\t\t\"name\": \"Han Solo\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"__typename\": \"Human\",\n\t\t\t\t\t\t\t\"name\": \"Leia Organa\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"__typename\": \"Starship\",\n\t\t\t\t\t\t\t\"name\": \"TIE Advanced x1\"\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\thuman(id: \"1000\") {\n\t\t\t\t\t\t__typename\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"human\": {\n\t\t\t\t\t\t\"__typename\": \"Human\",\n\t\t\t\t\t\t\"name\": \"Luke Skywalker\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\thero {\n\t\t\t\t\t\t__typename\n\t\t\t\t\t\tname\n\t\t\t\t\t\t... on Character {\n\t\t\t\t\t\t\t...Droid\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t__typename\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfragment Droid on Droid {\n\t\t\t\t\tname\n\t\t\t\t\t__typename\n\t\t\t\t}\t\t\t  \n\t\t\t`,\n\t\t\tRawResponse:    true,\n\t\t\tExpectedResult: `{\"hero\":{\"__typename\":\"Droid\",\"name\":\"R2-D2\"}}`,\n\t\t},\n\t})\n}\n\nfunc TestConnections(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\thero {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tfriendsConnection {\n\t\t\t\t\t\t\ttotalCount\n\t\t\t\t\t\t\tpageInfo {\n\t\t\t\t\t\t\t\tstartCursor\n\t\t\t\t\t\t\t\tendCursor\n\t\t\t\t\t\t\t\thasNextPage\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tedges {\n\t\t\t\t\t\t\t\tcursor\n\t\t\t\t\t\t\t\tnode {\n\t\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hero\": {\n\t\t\t\t\t\t\"name\": \"R2-D2\",\n\t\t\t\t\t\t\"friendsConnection\": {\n\t\t\t\t\t\t\t\"totalCount\": 3,\n\t\t\t\t\t\t\t\"pageInfo\": {\n\t\t\t\t\t\t\t\t\"startCursor\": \"Y3Vyc29yMQ==\",\n\t\t\t\t\t\t\t\t\"endCursor\": \"Y3Vyc29yMw==\",\n\t\t\t\t\t\t\t\t\"hasNextPage\": false\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"edges\": [\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\"cursor\": \"Y3Vyc29yMQ==\",\n\t\t\t\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\t\t\t\"name\": \"Luke Skywalker\"\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\"cursor\": \"Y3Vyc29yMg==\",\n\t\t\t\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\t\t\t\"name\": \"Han Solo\"\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\"cursor\": \"Y3Vyc29yMw==\",\n\t\t\t\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\t\t\t\"name\": \"Leia Organa\"\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\thero {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tfriendsConnection(first: 1, after: \"Y3Vyc29yMQ==\") {\n\t\t\t\t\t\t\ttotalCount\n\t\t\t\t\t\t\tpageInfo {\n\t\t\t\t\t\t\t\tstartCursor\n\t\t\t\t\t\t\t\tendCursor\n\t\t\t\t\t\t\t\thasNextPage\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tedges {\n\t\t\t\t\t\t\t\tcursor\n\t\t\t\t\t\t\t\tnode {\n\t\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tmoreFriends: hero {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tfriendsConnection(first: 1, after: \"Y3Vyc29yMg==\") {\n\t\t\t\t\t\t\ttotalCount\n\t\t\t\t\t\t\tpageInfo {\n\t\t\t\t\t\t\t\tstartCursor\n\t\t\t\t\t\t\t\tendCursor\n\t\t\t\t\t\t\t\thasNextPage\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tedges {\n\t\t\t\t\t\t\t\tcursor\n\t\t\t\t\t\t\t\tnode {\n\t\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hero\": {\n\t\t\t\t\t\t\"name\": \"R2-D2\",\n\t\t\t\t\t\t\"friendsConnection\": {\n\t\t\t\t\t\t\t\"totalCount\": 3,\n\t\t\t\t\t\t\t\"pageInfo\": {\n\t\t\t\t\t\t\t\t\"startCursor\": \"Y3Vyc29yMg==\",\n\t\t\t\t\t\t\t\t\"endCursor\": \"Y3Vyc29yMg==\",\n\t\t\t\t\t\t\t\t\"hasNextPage\": true\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"edges\": [\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\"cursor\": \"Y3Vyc29yMg==\",\n\t\t\t\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\t\t\t\"name\": \"Han Solo\"\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t\"moreFriends\": {\n\t\t\t\t\t\t\"name\": \"R2-D2\",\n\t\t\t\t\t\t\"friendsConnection\": {\n\t\t\t\t\t\t\t\"totalCount\": 3,\n\t\t\t\t\t\t\t\"pageInfo\": {\n\t\t\t\t\t\t\t\t\"startCursor\": \"Y3Vyc29yMw==\",\n\t\t\t\t\t\t\t\t\"endCursor\": \"Y3Vyc29yMw==\",\n\t\t\t\t\t\t\t\t\"hasNextPage\": false\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"edges\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"cursor\": \"Y3Vyc29yMw==\",\n\t\t\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\t\t\"name\": \"Leia Organa\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nfunc TestMutation(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\treviews(episode: JEDI) {\n\t\t\t\t\t\tstars\n\t\t\t\t\t\tcommentary\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"reviews\": []\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tmutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) {\n\t\t\t\t\tcreateReview(episode: $ep, review: $review) {\n\t\t\t\t\t\tstars\n\t\t\t\t\t\tcommentary\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tVariables: map[string]interface{}{\n\t\t\t\t\"ep\": \"JEDI\",\n\t\t\t\t\"review\": map[string]interface{}{\n\t\t\t\t\t\"stars\":      5,\n\t\t\t\t\t\"commentary\": \"This is a great movie!\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"createReview\": {\n\t\t\t\t\t\t\"stars\": 5,\n\t\t\t\t\t\t\"commentary\": \"This is a great movie!\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tmutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) {\n\t\t\t\t\tcreateReview(episode: $ep, review: $review) {\n\t\t\t\t\t\tstars\n\t\t\t\t\t\tcommentary\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tVariables: map[string]interface{}{\n\t\t\t\t\"ep\": \"EMPIRE\",\n\t\t\t\t\"review\": map[string]interface{}{\n\t\t\t\t\t\"stars\": float64(4),\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"createReview\": {\n\t\t\t\t\t\t\"stars\": 4,\n\t\t\t\t\t\t\"commentary\": null\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\treviews(episode: JEDI) {\n\t\t\t\t\t\tstars\n\t\t\t\t\t\tcommentary\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"reviews\": [{\n\t\t\t\t\t\t\"stars\": 5,\n\t\t\t\t\t\t\"commentary\": \"This is a great movie!\"\n\t\t\t\t\t}]\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nfunc TestIntrospection(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\t__schema {\n\t\t\t\t\t\ttypes {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"__schema\": {\n\t\t\t\t\t\t\"types\": [\n\t\t\t\t\t\t\t{ \"name\": \"Boolean\" },\n\t\t\t\t\t\t\t{ \"name\": \"Character\" },\n\t\t\t\t\t\t\t{ \"name\": \"Droid\" },\n\t\t\t\t\t\t\t{ \"name\": \"Episode\" },\n\t\t\t\t\t\t\t{ \"name\": \"Float\" },\n\t\t\t\t\t\t\t{ \"name\": \"FriendsConnection\" },\n\t\t\t\t\t\t\t{ \"name\": \"FriendsEdge\" },\n\t\t\t\t\t\t\t{ \"name\": \"Human\" },\n\t\t\t\t\t\t\t{ \"name\": \"ID\" },\n\t\t\t\t\t\t\t{ \"name\": \"Int\" },\n\t\t\t\t\t\t\t{ \"name\": \"LengthUnit\" },\n\t\t\t\t\t\t\t{ \"name\": \"Mutation\" },\n\t\t\t\t\t\t\t{ \"name\": \"PageInfo\" },\n\t\t\t\t\t\t\t{ \"name\": \"Query\" },\n\t\t\t\t\t\t\t{ \"name\": \"Review\" },\n\t\t\t\t\t\t\t{ \"name\": \"ReviewInput\" },\n\t\t\t\t\t\t\t{ \"name\": \"SearchResult\" },\n\t\t\t\t\t\t\t{ \"name\": \"Starship\" },\n\t\t\t\t\t\t\t{ \"name\": \"String\" },\n\t\t\t\t\t\t\t{ \"name\": \"__Directive\" },\n\t\t\t\t\t\t\t{ \"name\": \"__DirectiveLocation\" },\n\t\t\t\t\t\t\t{ \"name\": \"__EnumValue\" },\n\t\t\t\t\t\t\t{ \"name\": \"__Field\" },\n\t\t\t\t\t\t\t{ \"name\": \"__InputValue\" },\n\t\t\t\t\t\t\t{ \"name\": \"__Schema\" },\n\t\t\t\t\t\t\t{ \"name\": \"__Type\" },\n\t\t\t\t\t\t\t{ \"name\": \"__TypeKind\" }\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\t__schema {\n\t\t\t\t\t\tqueryType {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"__schema\": {\n\t\t\t\t\t\t\"queryType\": {\n\t\t\t\t\t\t\t\"name\": \"Query\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\ta: __type(name: \"Droid\") {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tkind\n\t\t\t\t\t\tinterfaces {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpossibleTypes {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tb: __type(name: \"Character\") {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tkind\n\t\t\t\t\t\tinterfaces {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpossibleTypes {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tc: __type(name: \"SearchResult\") {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tkind\n\t\t\t\t\t\tinterfaces {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpossibleTypes {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"a\": {\n\t\t\t\t\t\t\"name\": \"Droid\",\n\t\t\t\t\t\t\"kind\": \"OBJECT\",\n\t\t\t\t\t\t\"interfaces\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Character\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t],\n\t\t\t\t\t\t\"possibleTypes\": null\n\t\t\t\t\t},\n\t\t\t\t\t\"b\": {\n\t\t\t\t\t\t\"name\": \"Character\",\n\t\t\t\t\t\t\"kind\": \"INTERFACE\",\n\t\t\t\t\t\t\"interfaces\": null,\n\t\t\t\t\t\t\"possibleTypes\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Human\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Droid\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\t\"c\": {\n\t\t\t\t\t\t\"name\": \"SearchResult\",\n\t\t\t\t\t\t\"kind\": \"UNION\",\n\t\t\t\t\t\t\"interfaces\": null,\n\t\t\t\t\t\t\"possibleTypes\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Human\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Droid\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Starship\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\t__type(name: \"Droid\") {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tfields {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\targs {\n\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t\ttype {\n\t\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdefaultValue\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttype {\n\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t\tkind\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"__type\": {\n\t\t\t\t\t\t\"name\": \"Droid\",\n\t\t\t\t\t\t\"fields\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"id\",\n\t\t\t\t\t\t\t\t\"args\": [],\n\t\t\t\t\t\t\t\t\"type\": {\n\t\t\t\t\t\t\t\t\t\"name\": null,\n\t\t\t\t\t\t\t\t\t\"kind\": \"NON_NULL\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"name\",\n\t\t\t\t\t\t\t\t\"args\": [],\n\t\t\t\t\t\t\t\t\"type\": {\n\t\t\t\t\t\t\t\t\t\"name\": null,\n\t\t\t\t\t\t\t\t\t\"kind\": \"NON_NULL\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"friends\",\n\t\t\t\t\t\t\t\t\"args\": [],\n\t\t\t\t\t\t\t\t\"type\": {\n\t\t\t\t\t\t\t\t\t\"name\": null,\n\t\t\t\t\t\t\t\t\t\"kind\": \"LIST\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"friendsConnection\",\n\t\t\t\t\t\t\t\t\"args\": [\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\"name\": \"first\",\n\t\t\t\t\t\t\t\t\t\t\"type\": {\n\t\t\t\t\t\t\t\t\t\t\t\"name\": \"Int\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\"defaultValue\": null\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\"name\": \"after\",\n\t\t\t\t\t\t\t\t\t\t\"type\": {\n\t\t\t\t\t\t\t\t\t\t\t\"name\": \"ID\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\"defaultValue\": null\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\"type\": {\n\t\t\t\t\t\t\t\t\t\"name\": null,\n\t\t\t\t\t\t\t\t\t\"kind\": \"NON_NULL\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"appearsIn\",\n\t\t\t\t\t\t\t\t\"args\": [],\n\t\t\t\t\t\t\t\t\"type\": {\n\t\t\t\t\t\t\t\t\t\"name\": null,\n\t\t\t\t\t\t\t\t\t\"kind\": \"NON_NULL\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"primaryFunction\",\n\t\t\t\t\t\t\t\t\"args\": [],\n\t\t\t\t\t\t\t\t\"type\": {\n\t\t\t\t\t\t\t\t\t\"name\": \"String\",\n\t\t\t\t\t\t\t\t\t\"kind\": \"SCALAR\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\t__type(name: \"Episode\") {\n\t\t\t\t\t\tenumValues {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"__type\": {\n\t\t\t\t\t\t\"enumValues\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"NEWHOPE\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"EMPIRE\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"JEDI\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\t__schema {\n\t\t\t\t\t\tdirectives {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\tdescription\n\t\t\t\t\t\t\tlocations\n\t\t\t\t\t\t\targs {\n\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t\tdescription\n\t\t\t\t\t\t\t\ttype {\n\t\t\t\t\t\t\t\t\tkind\n\t\t\t\t\t\t\t\t\tofType {\n\t\t\t\t\t\t\t\t\t\tkind\n\t\t\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\t\"__schema\": {\n\t\t\t\t\t\t\t\"directives\": [\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\"name\": \"deprecated\",\n\t\t\t\t\t\t\t\t\t\"description\": \"Marks an element of a GraphQL schema as no longer supported.\",\n\t\t\t\t\t\t\t\t\t\"locations\": [\n\t\t\t\t\t\t\t\t\t\t\"FIELD_DEFINITION\",\n\t\t\t\t\t\t\t\t\t\t\"ENUM_VALUE\"\n\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\t\"args\": [\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\"name\": \"reason\",\n\t\t\t\t\t\t\t\t\t\t\t\"description\": \"Explains why this element was deprecated, usually also including a suggestion\\nfor how to access supported similar data. Formatted in\\n[Markdown](https://daringfireball.net/projects/markdown/).\",\n\t\t\t\t\t\t\t\t\t\t\t\"type\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\"kind\": \"SCALAR\",\n\t\t\t\t\t\t\t\t\t\t\t\t\"ofType\": null\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\"name\": \"include\",\n\t\t\t\t\t\t\t\t\t\"description\": \"Directs the executor to include this field or fragment only when the ` + \"`\" + `if` + \"`\" + ` argument is true.\",\n\t\t\t\t\t\t\t\t\t\"locations\": [\n\t\t\t\t\t\t\t\t\t\t\"FIELD\",\n\t\t\t\t\t\t\t\t\t\t\"FRAGMENT_SPREAD\",\n\t\t\t\t\t\t\t\t\t\t\"INLINE_FRAGMENT\"\n\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\t\"args\": [\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\"name\": \"if\",\n\t\t\t\t\t\t\t\t\t\t\t\"description\": \"Included when true.\",\n\t\t\t\t\t\t\t\t\t\t\t\"type\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\"kind\": \"NON_NULL\",\n\t\t\t\t\t\t\t\t\t\t\t\t\"ofType\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"kind\": \"SCALAR\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"name\": \"Boolean\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\"name\": \"skip\",\n\t\t\t\t\t\t\t\t\t\"description\": \"Directs the executor to skip this field or fragment when the ` + \"`\" + `if` + \"`\" + ` argument is true.\",\n\t\t\t\t\t\t\t\t\t\"locations\": [\n\t\t\t\t\t\t\t\t\t\t\"FIELD\",\n\t\t\t\t\t\t\t\t\t\t\"FRAGMENT_SPREAD\",\n\t\t\t\t\t\t\t\t\t\t\"INLINE_FRAGMENT\"\n\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\t\"args\": [\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\"name\": \"if\",\n\t\t\t\t\t\t\t\t\t\t\t\"description\": \"Skipped when true.\",\n\t\t\t\t\t\t\t\t\t\t\t\"type\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\"kind\": \"NON_NULL\",\n\t\t\t\t\t\t\t\t\t\t\t\t\"ofType\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"kind\": \"SCALAR\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"name\": \"Boolean\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nvar starwarsSchemaNoIntrospection = graphql.MustParseSchema(starwars.Schema, &starwars.Resolver{}, []graphql.SchemaOpt{graphql.DisableIntrospection()}...)\n\nfunc TestIntrospectionDisableIntrospection(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: starwarsSchemaNoIntrospection,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\t__schema {\n\t\t\t\t\t\ttypes {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchemaNoIntrospection,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\t__schema {\n\t\t\t\t\t\tqueryType {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchemaNoIntrospection,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\ta: __type(name: \"Droid\") {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tkind\n\t\t\t\t\t\tinterfaces {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpossibleTypes {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tb: __type(name: \"Character\") {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tkind\n\t\t\t\t\t\tinterfaces {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpossibleTypes {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tc: __type(name: \"SearchResult\") {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tkind\n\t\t\t\t\t\tinterfaces {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpossibleTypes {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchemaNoIntrospection,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\t__type(name: \"Droid\") {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tfields {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\targs {\n\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t\ttype {\n\t\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdefaultValue\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttype {\n\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t\tkind\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchemaNoIntrospection,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\t__type(name: \"Episode\") {\n\t\t\t\t\t\tenumValues {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchemaNoIntrospection,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\t__schema {\n\t\t\t\t\t\tdirectives {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\tdescription\n\t\t\t\t\t\t\tlocations\n\t\t\t\t\t\t\targs {\n\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t\tdescription\n\t\t\t\t\t\t\t\ttype {\n\t\t\t\t\t\t\t\t\tkind\n\t\t\t\t\t\t\t\t\tofType {\n\t\t\t\t\t\t\t\t\t\tkind\n\t\t\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchemaNoIntrospection,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tsearch(text: \"an\") {\n\t\t\t\t\t\t__typename\n\t\t\t\t\t\t... on Human {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t\t... on Droid {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t\t... on Starship {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"search\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"__typename\": \"Human\",\n\t\t\t\t\t\t\t\"name\": \"Han Solo\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"__typename\": \"Human\",\n\t\t\t\t\t\t\t\"name\": \"Leia Organa\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"__typename\": \"Starship\",\n\t\t\t\t\t\t\t\"name\": \"TIE Advanced x1\"\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nfunc TestMutationOrder(t *testing.T) {\n\tt.Parallel()\n\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t\tmutation: Mutation\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\ttheNumber: Int!\n\t\t\t\t}\n\n\t\t\t\ttype Mutation {\n\t\t\t\t\tchangeTheNumber(newNumber: Int!): Query\n\t\t\t\t}\n\t\t\t`, &theNumberResolver{}),\n\t\t\tQuery: `\n\t\t\t\tmutation {\n\t\t\t\t\tfirst: changeTheNumber(newNumber: 1) {\n\t\t\t\t\t\ttheNumber\n\t\t\t\t\t}\n\t\t\t\t\tsecond: changeTheNumber(newNumber: 3) {\n\t\t\t\t\t\ttheNumber\n\t\t\t\t\t}\n\t\t\t\t\tthird: changeTheNumber(newNumber: 2) {\n\t\t\t\t\t\ttheNumber\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"first\": {\n\t\t\t\t\t\t\"theNumber\": 1\n\t\t\t\t\t},\n\t\t\t\t\t\"second\": {\n\t\t\t\t\t\t\"theNumber\": 3\n\t\t\t\t\t},\n\t\t\t\t\t\"third\": {\n\t\t\t\t\t\t\"theNumber\": 2\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nfunc TestTime(t *testing.T) {\n\tt.Parallel()\n\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\taddHour(time: Time = \"2001-02-03T04:05:06Z\"): Time!\n\t\t\t\t}\n\n\t\t\t\tscalar Time\n\t\t\t`, &timeResolver{}),\n\t\t\tQuery: `\n\t\t\t\tquery($t: Time!) {\n\t\t\t\t\ta: addHour(time: $t)\n\t\t\t\t\tb: addHour\n\t\t\t\t}\n\t\t\t`,\n\t\t\tVariables: map[string]interface{}{\n\t\t\t\t\"t\": time.Date(2000, 2, 3, 4, 5, 6, 0, time.UTC),\n\t\t\t},\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"a\": \"2000-02-03T05:05:06Z\",\n\t\t\t\t\t\"b\": \"2001-02-03T05:05:06Z\"\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\ntype resolverWithUnexportedMethod struct{}\n\nfunc (r *resolverWithUnexportedMethod) changeTheNumber(args struct{ NewNumber int32 }) int32 {\n\treturn args.NewNumber\n}\n\nfunc TestUnexportedMethod(t *testing.T) {\n\tt.Parallel()\n\n\t_, err := graphql.ParseSchema(`\n\t\tschema {\n\t\t\tmutation: Mutation\n\t\t}\n\n\t\ttype Mutation {\n\t\t\tchangeTheNumber(newNumber: Int!): Int!\n\t\t}\n\t`, &resolverWithUnexportedMethod{})\n\tif err == nil {\n\t\tt.Error(\"error expected\")\n\t}\n}\n\ntype resolverWithUnexportedField struct{}\n\nfunc (r *resolverWithUnexportedField) ChangeTheNumber(args struct{ newNumber int32 }) int32 {\n\treturn args.newNumber\n}\n\nfunc TestUnexportedField(t *testing.T) {\n\tt.Parallel()\n\n\t_, err := graphql.ParseSchema(`\n\t\tschema {\n\t\t\tmutation: Mutation\n\t\t}\n\n\t\ttype Mutation {\n\t\t\tchangeTheNumber(newNumber: Int!): Int!\n\t\t}\n\t`, &resolverWithUnexportedField{})\n\tif err == nil {\n\t\tt.Error(\"error expected\")\n\t}\n}\n\ntype StringEnum string\n\nconst (\n\tEnumOption1 StringEnum = \"Option1\"\n\tEnumOption2 StringEnum = \"Option2\"\n)\n\ntype IntEnum int\n\nconst (\n\tIntEnum0 IntEnum = iota\n\tIntEnum1\n)\n\nfunc (e IntEnum) String() string {\n\tswitch int(e) {\n\tcase 0:\n\t\treturn \"Int0\"\n\tcase 1:\n\t\treturn \"Int1\"\n\tdefault:\n\t\treturn \"IntN\"\n\t}\n}\n\nfunc (IntEnum) ImplementsGraphQLType(name string) bool {\n\treturn name == \"IntEnum\"\n}\n\nfunc (e *IntEnum) UnmarshalGraphQL(input interface{}) error {\n\tif str, ok := input.(string); ok {\n\t\tswitch str {\n\t\tcase \"Int0\":\n\t\t\t*e = IntEnum(0)\n\t\tcase \"Int1\":\n\t\t\t*e = IntEnum(1)\n\t\tdefault:\n\t\t\t*e = IntEnum(-1)\n\t\t}\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"wrong type for IntEnum: %T\", input)\n}\n\ntype inputResolver struct{}\n\nfunc (r *inputResolver) Int(args struct{ Value int32 }) int32 {\n\treturn args.Value\n}\n\nfunc (r *inputResolver) Float(args struct{ Value float64 }) float64 {\n\treturn args.Value\n}\n\nfunc (r *inputResolver) String(args struct{ Value string }) string {\n\treturn args.Value\n}\n\nfunc (r *inputResolver) Boolean(args struct{ Value bool }) bool {\n\treturn args.Value\n}\n\nfunc (r *inputResolver) Nullable(args struct{ Value *int32 }) *int32 {\n\treturn args.Value\n}\n\nfunc (r *inputResolver) List(args struct{ Value []*struct{ V int32 } }) []int32 {\n\tl := make([]int32, len(args.Value))\n\tfor i, entry := range args.Value {\n\t\tl[i] = entry.V\n\t}\n\treturn l\n}\n\nfunc (r *inputResolver) NullableList(args struct{ Value *[]*struct{ V int32 } }) *[]*int32 {\n\tif args.Value == nil {\n\t\treturn nil\n\t}\n\tl := make([]*int32, len(*args.Value))\n\tfor i, entry := range *args.Value {\n\t\tif entry != nil {\n\t\t\tl[i] = &entry.V\n\t\t}\n\t}\n\treturn &l\n}\n\nfunc (r *inputResolver) StringEnumValue(args struct{ Value string }) string {\n\treturn args.Value\n}\n\nfunc (r *inputResolver) NullableStringEnumValue(args struct{ Value *string }) *string {\n\treturn args.Value\n}\n\nfunc (r *inputResolver) StringEnum(args struct{ Value StringEnum }) StringEnum {\n\treturn args.Value\n}\n\nfunc (r *inputResolver) NullableStringEnum(args struct{ Value *StringEnum }) *StringEnum {\n\treturn args.Value\n}\n\nfunc (r *inputResolver) IntEnumValue(args struct{ Value string }) string {\n\treturn args.Value\n}\n\nfunc (r *inputResolver) NullableIntEnumValue(args struct{ Value *string }) *string {\n\treturn args.Value\n}\n\nfunc (r *inputResolver) IntEnum(args struct{ Value IntEnum }) IntEnum {\n\treturn args.Value\n}\n\nfunc (r *inputResolver) NullableIntEnum(args struct{ Value *IntEnum }) *IntEnum {\n\treturn args.Value\n}\n\ntype recursive struct {\n\tNext *recursive\n}\n\nfunc (r *inputResolver) Recursive(args struct{ Value *recursive }) int32 {\n\tn := int32(0)\n\tv := args.Value\n\tfor v != nil {\n\t\tv = v.Next\n\t\tn++\n\t}\n\treturn n\n}\n\nfunc (r *inputResolver) ID(args struct{ Value graphql.ID }) graphql.ID {\n\treturn args.Value\n}\n\nfunc TestInput(t *testing.T) {\n\tt.Parallel()\n\n\tcoercionSchema := graphql.MustParseSchema(`\n\t\tschema {\n\t\t\tquery: Query\n\t\t}\n\n\t\ttype Query {\n\t\t\tint(value: Int!): Int!\n\t\t\tfloat(value: Float!): Float!\n\t\t\tstring(value: String!): String!\n\t\t\tboolean(value: Boolean!): Boolean!\n\t\t\tnullable(value: Int): Int\n\t\t\tlist(value: [Input!]!): [Int!]!\n\t\t\tnullableList(value: [Input]): [Int]\n\t\t\tstringEnumValue(value: StringEnum!): StringEnum!\n\t\t\tnullableStringEnumValue(value: StringEnum): StringEnum\n\t\t\tstringEnum(value: StringEnum!): StringEnum!\n\t\t\tnullableStringEnum(value: StringEnum): StringEnum\n\t\t\tintEnumValue(value: IntEnum!): IntEnum!\n\t\t\tnullableIntEnumValue(value: IntEnum): IntEnum\n\t\t\tintEnum(value: IntEnum!): IntEnum!\n\t\t\tnullableIntEnum(value: IntEnum): IntEnum\n\t\t\trecursive(value: RecursiveInput!): Int!\n\t\t\tid(value: ID!): ID!\n\t\t}\n\n\t\tinput Input {\n\t\t\tv: Int!\n\t\t}\n\n\t\tinput RecursiveInput {\n\t\t\tnext: RecursiveInput\n\t\t}\n\n\t\tenum StringEnum {\n\t\t\tOption1\n\t\t\tOption2\n\t\t}\n\n\t\tenum IntEnum {\n\t\t\tInt0\n\t\t\tInt1\n\t\t}\n\t`, &inputResolver{})\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: coercionSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tint(value: 42)\n\t\t\t\t\tfloat1: float(value: 42)\n\t\t\t\t\tfloat2: float(value: 42.5)\n\t\t\t\t\tstring(value: \"foo\")\n\t\t\t\t\tboolean(value: true)\n\t\t\t\t\tnullable1: nullable(value: 42)\n\t\t\t\t\tnullable2: nullable(value: null)\n\t\t\t\t\tlist1: list(value: [{v: 41}, {v: 42}, {v: 43}])\n\t\t\t\t\tlist2: list(value: {v: 42})\n\t\t\t\t\tnullableList1: nullableList(value: [{v: 41}, null, {v: 43}])\n\t\t\t\t\tnullableList2: nullableList(value: null)\n\t\t\t\t\tstringEnumValue(value: Option1)\n\t\t\t\t\tnullableStringEnumValue1: nullableStringEnum(value: Option1)\n\t\t\t\t\tnullableStringEnumValue2: nullableStringEnum(value: null)\n\t\t\t\t\tstringEnum(value: Option2)\n\t\t\t\t\tnullableStringEnum1: nullableStringEnum(value: Option2)\n\t\t\t\t\tnullableStringEnum2: nullableStringEnum(value: null)\n\t\t\t\t\tintEnumValue(value: Int1)\n\t\t\t\t\tnullableIntEnumValue1: nullableIntEnumValue(value: Int1)\n\t\t\t\t\tnullableIntEnumValue2: nullableIntEnumValue(value: null)\n\t\t\t\t\tintEnum(value: Int1)\n\t\t\t\t\tnullableIntEnum1: nullableIntEnum(value: Int1)\n\t\t\t\t\tnullableIntEnum2: nullableIntEnum(value: null)\n\t\t\t\t\trecursive(value: {next: {next: {}}})\n\t\t\t\t\tintID: id(value: 1234)\n\t\t\t\t\tstrID: id(value: \"1234\")\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"int\": 42,\n\t\t\t\t\t\"float1\": 42,\n\t\t\t\t\t\"float2\": 42.5,\n\t\t\t\t\t\"string\": \"foo\",\n\t\t\t\t\t\"boolean\": true,\n\t\t\t\t\t\"nullable1\": 42,\n\t\t\t\t\t\"nullable2\": null,\n\t\t\t\t\t\"list1\": [41, 42, 43],\n\t\t\t\t\t\"list2\": [42],\n\t\t\t\t\t\"nullableList1\": [41, null, 43],\n\t\t\t\t\t\"nullableList2\": null,\n\t\t\t\t\t\"stringEnumValue\": \"Option1\",\n\t\t\t\t\t\"nullableStringEnumValue1\": \"Option1\",\n\t\t\t\t\t\"nullableStringEnumValue2\": null,\n\t\t\t\t\t\"stringEnum\": \"Option2\",\n\t\t\t\t\t\"nullableStringEnum1\": \"Option2\",\n\t\t\t\t\t\"nullableStringEnum2\": null,\n\t\t\t\t\t\"intEnumValue\": \"Int1\",\n\t\t\t\t\t\"nullableIntEnumValue1\": \"Int1\",\n\t\t\t\t\t\"nullableIntEnumValue2\": null,\n\t\t\t\t\t\"intEnum\": \"Int1\",\n\t\t\t\t\t\"nullableIntEnum1\": \"Int1\",\n\t\t\t\t\t\"nullableIntEnum2\": null,\n\t\t\t\t\t\"recursive\": 3,\n\t\t\t\t\t\"intID\": \"1234\",\n\t\t\t\t\t\"strID\": \"1234\"\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\ntype inputArgumentsHello struct{}\n\ntype inputArgumentsScalarMismatch1 struct{}\n\ntype inputArgumentsScalarMismatch2 struct{}\n\ntype inputArgumentsObjectMismatch1 struct{}\n\ntype inputArgumentsObjectMismatch2 struct{}\n\ntype inputArgumentsObjectMismatch3 struct{}\n\ntype fieldNameMismatch struct{}\n\ntype helloInput struct {\n\tName string\n}\n\ntype helloOutput struct {\n\tName string\n}\n\nfunc (*fieldNameMismatch) Hello() helloOutput {\n\treturn helloOutput{}\n}\n\ntype helloInputMismatch struct {\n\tWorld string\n}\n\nfunc (r *inputArgumentsHello) Hello(args struct{ Input *helloInput }) string {\n\treturn \"Hello \" + args.Input.Name + \"!\"\n}\n\nfunc (r *inputArgumentsScalarMismatch1) Hello(name string) string {\n\treturn \"Hello \" + name + \"!\"\n}\n\nfunc (r *inputArgumentsScalarMismatch2) Hello(args struct{ World string }) string {\n\treturn \"Hello \" + args.World + \"!\"\n}\n\nfunc (r *inputArgumentsObjectMismatch1) Hello(in helloInput) string {\n\treturn \"Hello \" + in.Name + \"!\"\n}\n\nfunc (r *inputArgumentsObjectMismatch2) Hello(args struct{ Input *helloInputMismatch }) string {\n\treturn \"Hello \" + args.Input.World + \"!\"\n}\n\nfunc (r *inputArgumentsObjectMismatch3) Hello(args struct{ Input *struct{ Thing string } }) string {\n\treturn \"Hello \" + args.Input.Thing + \"!\"\n}\n\nfunc TestInputArguments_failSchemaParsing(t *testing.T) {\n\ttype args struct {\n\t\tResolver interface{}\n\t\tSchema   string\n\t\tOpts     []graphql.SchemaOpt\n\t}\n\ttype want struct {\n\t\tError string\n\t}\n\ttestTable := map[string]struct {\n\t\tArgs args\n\t\tWant want\n\t}{\n\t\t\"Non-input type used with field arguments\": {\n\t\t\tArgs: args{\n\t\t\t\tResolver: &inputArgumentsHello{},\n\t\t\t\tSchema: `\n\t\t\t\t\tschema {\n\t\t\t\t\t\tquery: Query\n\t\t\t\t\t}\n\t\t\t\t\ttype Query {\n\t\t\t\t\t\thello(input: HelloInput): String!\n\t\t\t\t\t}\n\t\t\t\t\ttype HelloInput {\n\t\t\t\t\t\tname: String\n\t\t\t\t\t}\n\t\t\t\t`,\n\t\t\t},\n\t\t\tWant: want{Error: \"field \\\"Input\\\": type of kind OBJECT can not be used as input\\n\\tused by (*graphql_test.inputArgumentsHello).Hello\"},\n\t\t},\n\t\t\"Missing Args Wrapper for scalar input\": {\n\t\t\tArgs: args{\n\t\t\t\tResolver: &inputArgumentsScalarMismatch1{},\n\t\t\t\tSchema: `\n\t\t\t\t\tschema {\n\t\t\t\t\t\tquery: Query\n\t\t\t\t\t}\n\t\t\t\t\ttype Query {\n\t\t\t\t\t\thello(name: String): String!\n\t\t\t\t\t}\n\t\t\t\t\tinput HelloInput {\n\t\t\t\t\t\tname: String\n\t\t\t\t\t}\n\t\t\t\t`,\n\t\t\t},\n\t\t\tWant: want{Error: \"expected struct or pointer to struct, got string (hint: missing `args struct { ... }` wrapper for field arguments?)\\n\\tused by (*graphql_test.inputArgumentsScalarMismatch1).Hello\"},\n\t\t},\n\t\t\"Mismatching field name for scalar input\": {\n\t\t\tArgs: args{\n\t\t\t\tResolver: &inputArgumentsScalarMismatch2{},\n\t\t\t\tSchema: `\n\t\t\t\t\tschema {\n\t\t\t\t\t\tquery: Query\n\t\t\t\t\t}\n\t\t\t\t\ttype Query {\n\t\t\t\t\t\thello(name: String): String!\n\t\t\t\t\t}\n\t\t\t\t`,\n\t\t\t},\n\t\t\tWant: want{Error: \"struct { World string } does not define field \\\"name\\\" (hint: missing `args struct { ... }` wrapper for field arguments, or missing field on input struct)\\n\\tused by (*graphql_test.inputArgumentsScalarMismatch2).Hello\"},\n\t\t},\n\t\t\"Missing Args Wrapper for Input type\": {\n\t\t\tArgs: args{\n\t\t\t\tResolver: &inputArgumentsObjectMismatch1{},\n\t\t\t\tSchema: `\n\t\t\t\t\tschema {\n\t\t\t\t\t\tquery: Query\n\t\t\t\t\t}\n\t\t\t\t\ttype Query {\n\t\t\t\t\t\thello(input: HelloInput): String!\n\t\t\t\t\t}\n\t\t\t\t\tinput HelloInput {\n\t\t\t\t\t\tname: String\n\t\t\t\t\t}\n\t\t\t\t`,\n\t\t\t},\n\t\t\tWant: want{Error: \"graphql_test.helloInput does not define field \\\"input\\\" (hint: missing `args struct { ... }` wrapper for field arguments, or missing field on input struct)\\n\\tused by (*graphql_test.inputArgumentsObjectMismatch1).Hello\"},\n\t\t},\n\t\t\"Input struct missing field\": {\n\t\t\tArgs: args{\n\t\t\t\tResolver: &inputArgumentsObjectMismatch2{},\n\t\t\t\tSchema: `\n\t\t\t\t\tschema {\n\t\t\t\t\t\tquery: Query\n\t\t\t\t\t}\n\t\t\t\t\ttype Query {\n\t\t\t\t\t\thello(input: HelloInput): String!\n\t\t\t\t\t}\n\t\t\t\t\tinput HelloInput {\n\t\t\t\t\t\tname: String\n\t\t\t\t\t}\n\t\t\t\t`,\n\t\t\t},\n\t\t\tWant: want{Error: \"field \\\"Input\\\": *graphql_test.helloInputMismatch does not define field \\\"name\\\" (hint: missing `args struct { ... }` wrapper for field arguments, or missing field on input struct)\\n\\tused by (*graphql_test.inputArgumentsObjectMismatch2).Hello\"},\n\t\t},\n\t\t\"Inline Input struct missing field\": {\n\t\t\tArgs: args{\n\t\t\t\tResolver: &inputArgumentsObjectMismatch3{},\n\t\t\t\tSchema: `\n\t\t\t\t\tschema {\n\t\t\t\t\t\tquery: Query\n\t\t\t\t\t}\n\t\t\t\t\ttype Query {\n\t\t\t\t\t\thello(input: HelloInput): String!\n\t\t\t\t\t}\n\t\t\t\t\tinput HelloInput {\n\t\t\t\t\t\tname: String\n\t\t\t\t\t}\n\t\t\t\t`,\n\t\t\t},\n\t\t\tWant: want{Error: \"field \\\"Input\\\": *struct { Thing string } does not define field \\\"name\\\" (hint: missing `args struct { ... }` wrapper for field arguments, or missing field on input struct)\\n\\tused by (*graphql_test.inputArgumentsObjectMismatch3).Hello\"},\n\t\t},\n\t\t\"Struct field name inclusion\": {\n\t\t\tArgs: args{\n\t\t\t\tResolver: &fieldNameMismatch{},\n\t\t\t\tOpts:     []graphql.SchemaOpt{graphql.UseFieldResolvers()},\n\t\t\t\tSchema: `\n\t\t\t\t\ttype Query {\n\t\t\t\t\t\thello(): HelloOutput!\n\t\t\t\t\t}\n\t\t\t\t\ttype HelloOutput {\n\t\t\t\t\t\tname: Int\n\t\t\t\t\t}\n\t\t\t\t`,\n\t\t\t},\n\t\t\tWant: want{Error: \"string is not a pointer\\n\\tused by (graphql_test.helloOutput).Name\\n\\tused by (*graphql_test.fieldNameMismatch).Hello\"},\n\t\t},\n\t}\n\n\tfor name, tt := range testTable {\n\t\ttt := tt\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\t_, err := graphql.ParseSchema(tt.Args.Schema, tt.Args.Resolver, tt.Args.Opts...)\n\t\t\tif err == nil || err.Error() != tt.Want.Error {\n\t\t\t\tt.Log(\"Schema parsing error mismatch\")\n\t\t\t\tt.Logf(\"got: %s\", err)\n\t\t\t\tt.Logf(\"exp: %s\", tt.Want.Error)\n\t\t\t\tt.Fail()\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestComposedFragments(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tcomposed: hero(episode: EMPIRE) {\n\t\t\t\t\t\tname\n\t\t\t\t\t\t...friendsNames\n\t\t\t\t\t\t...friendsIds\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfragment friendsNames on Character {\n\t\t\t\t\tname\n\t\t\t\t\tfriends {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfragment friendsIds on Character {\n\t\t\t\t\tname\n\t\t\t\t\tfriends {\n\t\t\t\t\t\tid\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"composed\": {\n\t\t\t\t\t\t\"name\": \"Luke Skywalker\",\n\t\t\t\t\t\t\"friends\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"id\": \"1002\",\n\t\t\t\t\t\t\t\t\"name\": \"Han Solo\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"id\": \"1003\",\n\t\t\t\t\t\t\t\t\"name\": \"Leia Organa\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"id\": \"2000\",\n\t\t\t\t\t\t\t\t\"name\": \"C-3PO\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"id\": \"2001\",\n\t\t\t\t\t\t\t\t\"name\": \"R2-D2\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nvar (\n\texampleError = fmt.Errorf(\"This is an error\")\n\n\tnilChildErrorString = `graphql: got nil for non-null \"Child\"`\n)\n\ntype childResolver struct{}\n\nfunc (r *childResolver) TriggerError() (string, error) {\n\treturn \"This will never be returned to the client\", exampleError\n}\nfunc (r *childResolver) NoError() string {\n\treturn \"no error\"\n}\nfunc (r *childResolver) Child() *childResolver {\n\treturn &childResolver{}\n}\nfunc (r *childResolver) NilChild() *childResolver {\n\treturn nil\n}\n\nfunc TestErrorPropagation(t *testing.T) {\n\tt.Parallel()\n\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tnoError: String!\n\t\t\t\t\ttriggerError: String!\n\t\t\t\t}\n\t\t\t`, &childResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tnoError\n\t\t\t\t\ttriggerError\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\tnull\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage:       exampleError.Error(),\n\t\t\t\t\tResolverError: exampleError,\n\t\t\t\t\tPath:          []interface{}{\"triggerError\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tnoError: String!\n\t\t\t\t\tchild: Child\n\t\t\t\t}\n\n\t\t\t\ttype Child {\n\t\t\t\t\tnoError: String!\n\t\t\t\t\ttriggerError: String!\n\t\t\t\t}\n\t\t\t`, &childResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tnoError\n\t\t\t\t\tchild {\n\t\t\t\t\t\tnoError\n\t\t\t\t\t\ttriggerError\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"noError\": \"no error\",\n\t\t\t\t\t\"child\": null\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage:       exampleError.Error(),\n\t\t\t\t\tResolverError: exampleError,\n\t\t\t\t\tPath:          []interface{}{\"child\", \"triggerError\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tnoError: String!\n\t\t\t\t\tchild: Child\n\t\t\t\t}\n\n\t\t\t\ttype Child {\n\t\t\t\t\tnoError: String!\n\t\t\t\t\ttriggerError: String!\n\t\t\t\t\tchild: Child!\n\t\t\t\t}\n\t\t\t`, &childResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tnoError\n\t\t\t\t\tchild {\n\t\t\t\t\t\tnoError\n\t\t\t\t\t\tchild {\n\t\t\t\t\t\t\tnoError\n\t\t\t\t\t\t\ttriggerError\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"noError\": \"no error\",\n\t\t\t\t\t\"child\": null\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage:       exampleError.Error(),\n\t\t\t\t\tResolverError: exampleError,\n\t\t\t\t\tPath:          []interface{}{\"child\", \"child\", \"triggerError\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tnoError: String!\n\t\t\t\t\tchild: Child\n\t\t\t\t}\n\n\t\t\t\ttype Child {\n\t\t\t\t\tnoError: String!\n\t\t\t\t\ttriggerError: String!\n\t\t\t\t\tchild: Child\n\t\t\t\t}\n\t\t\t`, &childResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tnoError\n\t\t\t\t\tchild {\n\t\t\t\t\t\tnoError\n\t\t\t\t\t\tchild {\n\t\t\t\t\t\t\tnoError\n\t\t\t\t\t\t\ttriggerError\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"noError\": \"no error\",\n\t\t\t\t\t\"child\": {\n\t\t\t\t\t\t\"noError\": \"no error\",\n\t\t\t\t\t\t\"child\": null\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage:       exampleError.Error(),\n\t\t\t\t\tResolverError: exampleError,\n\t\t\t\t\tPath:          []interface{}{\"child\", \"child\", \"triggerError\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tnoError: String!\n\t\t\t\t\tchild: Child!\n\t\t\t\t}\n\n\t\t\t\ttype Child {\n\t\t\t\t\tnoError: String!\n\t\t\t\t\tnilChild: Child!\n\t\t\t\t}\n\t\t\t`, &childResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tnoError\n\t\t\t\t\tchild {\n\t\t\t\t\t\tnilChild {\n\t\t\t\t\t\t\tnoError\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\tnull\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage: nilChildErrorString,\n\t\t\t\t\tPath:    []interface{}{\"child\", \"nilChild\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tnoError: String!\n\t\t\t\t\tchild: Child\n\t\t\t\t}\n\n\t\t\t\ttype Child {\n\t\t\t\t\tnoError: String!\n\t\t\t\t\tnilChild: Child!\n\t\t\t\t}\n\t\t\t`, &childResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tnoError\n\t\t\t\t\tchild {\n\t\t\t\t\t\tnoError\n\t\t\t\t\t\tnilChild {\n\t\t\t\t\t\t\tnoError\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t{\n\t\t\t\t\"noError\": \"no error\",\n\t\t\t\t\"child\": null\n\t\t\t}\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage: nilChildErrorString,\n\t\t\t\t\tPath:    []interface{}{\"child\", \"nilChild\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tchild: Child\n\t\t\t\t}\n\n\t\t\t\ttype Child {\n\t\t\t\t\ttriggerError: String!\n\t\t\t\t\tchild: Child\n\t\t\t\t\tnilChild: Child!\n\t\t\t\t}\n\t\t\t`, &childResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tchild {\n\t\t\t\t\t\tchild {\n\t\t\t\t\t\t\ttriggerError\n\t\t\t\t\t\t\tchild {\n\t\t\t\t\t\t\t\tnilChild {\n\t\t\t\t\t\t\t\t\ttriggerError\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t{\n\t\t\t\t\"child\": {\n\t\t\t\t\t\"child\": null\n\t\t\t\t}\n\t\t\t}\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage: nilChildErrorString,\n\t\t\t\t\tPath:    []interface{}{\"child\", \"child\", \"child\", \"nilChild\"},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tMessage:       exampleError.Error(),\n\t\t\t\t\tResolverError: exampleError,\n\t\t\t\t\tPath:          []interface{}{\"child\", \"child\", \"triggerError\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tchild: Child\n\t\t\t\t}\n\n\t\t\t\ttype Child {\n\t\t\t\t\tnoError: String!\n\t\t\t\t\tchild: Child!\n\t\t\t\t\tnilChild: Child!\n\t\t\t\t}\n\t\t\t`, &childResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tchild {\n\t\t\t\t\t\tchild {\n\t\t\t\t\t\t\tnilChild {\n\t\t\t\t\t\t\t\tnoError\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t{\n\t\t\t\t\"child\": null\n\t\t\t}\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage: nilChildErrorString,\n\t\t\t\t\tPath:    []interface{}{\"child\", \"child\", \"nilChild\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t})\n}\n\ntype ambiguousResolver struct {\n\tName string // ambiguous\n\tUniversity\n}\n\ntype University struct {\n\tName string // ambiguous\n}\n\nfunc TestPanicAmbiguity(t *testing.T) {\n\tpanicMessage := `*graphql_test.ambiguousResolver does not resolve \"Query\": ambiguous field \"name\"`\n\n\tdefer func() {\n\t\tr := recover()\n\t\tif r == nil {\n\t\t\tt.Fatal(\"expected schema parse to panic\")\n\t\t}\n\n\t\tif r.(error).Error() != panicMessage {\n\t\t\tt.Logf(\"got:  %s\", r)\n\t\t\tt.Logf(\"want: %s\", panicMessage)\n\t\t\tt.Fail()\n\t\t}\n\t}()\n\n\tschema := `\n\t\tschema {\n\t\t\tquery: Query\n\t\t}\n\n\t\ttype Query {\n\t\t\tname: String!\n\t\t\tuniversity: University!\n\t\t}\n\t\t\n\t\ttype University {\n\t\t\tname: String!\n\t\t}\n\t`\n\tgraphql.MustParseSchema(schema, &ambiguousResolver{}, graphql.UseFieldResolvers())\n}\n\nfunc TestSchema_Exec_without_resolver(t *testing.T) {\n\tt.Parallel()\n\n\ttype args struct {\n\t\tQuery  string\n\t\tSchema string\n\t}\n\ttype want struct {\n\t\tPanic interface{}\n\t}\n\ttestTable := []struct {\n\t\tName string\n\t\tArgs args\n\t\tWant want\n\t}{\n\t\t{\n\t\t\tName: \"schema_without_resolver_errors\",\n\t\t\tArgs: args{\n\t\t\t\tQuery: `\n\t\t\t\t\tquery {\n\t\t\t\t\t\thero {\n\t\t\t\t\t\t\tid\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\tfriends {\n\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t`,\n\t\t\t\tSchema: starwars.Schema,\n\t\t\t},\n\t\t\tWant: want{Panic: \"schema created without resolver, can not exec\"},\n\t\t},\n\t}\n\n\tfor _, tt := range testTable {\n\t\tt.Run(tt.Name, func(t *testing.T) {\n\t\t\ts := graphql.MustParseSchema(tt.Args.Schema, nil)\n\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif r == nil {\n\t\t\t\t\tt.Fatal(\"expected query to panic\")\n\t\t\t\t}\n\t\t\t\tif r != tt.Want.Panic {\n\t\t\t\t\tt.Logf(\"got:  %s\", r)\n\t\t\t\t\tt.Logf(\"want: %s\", tt.Want.Panic)\n\t\t\t\t\tt.Fail()\n\t\t\t\t}\n\t\t\t}()\n\t\t\t_ = s.Exec(context.Background(), tt.Args.Query, \"\", map[string]interface{}{})\n\t\t})\n\t}\n}\n\ntype subscriptionsInExecResolver struct{}\n\nfunc (r *subscriptionsInExecResolver) AppUpdated() <-chan string {\n\treturn make(chan string)\n}\n\nfunc TestSubscriptions_In_Exec(t *testing.T) {\n\tr := &struct {\n\t\t*helloResolver\n\t\t*subscriptionsInExecResolver\n\t}{\n\t\thelloResolver:               &helloResolver{},\n\t\tsubscriptionsInExecResolver: &subscriptionsInExecResolver{},\n\t}\n\tgqltesting.RunTest(t, &gqltesting.Test{\n\t\tSchema: graphql.MustParseSchema(`\n\t\t\ttype Query {\n\t\t\t\thello: String!\n\t\t\t}\n\t\t\ttype Subscription {\n\t\t\t\tappUpdated : String!\n\t\t\t}\n\t\t`, r),\n\t\tQuery: `\n\t\t\tsubscription {\n\t\t\t\tappUpdated\n\t\t  \t}\n\t\t`,\n\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t{\n\t\t\t\tMessage: \"graphql-ws protocol header is missing\",\n\t\t\t},\n\t\t},\n\t})\n}\n\ntype nilPointerReturnValue struct{}\n\nfunc (r *nilPointerReturnValue) Value() *string {\n\treturn nil\n}\n\ntype nilPointerReturnResolver struct{}\n\nfunc (r *nilPointerReturnResolver) PointerReturn() *nilPointerReturnValue {\n\treturn &nilPointerReturnValue{}\n}\n\nfunc TestPointerReturnForNonNull(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\ttype Query {\n\t\t\t\tpointerReturn: PointerReturnValue\n\t\t\t}\n\n\t\t\ttype PointerReturnValue {\n\t\t\t\tvalue: Hello!\n\t\t\t}\n\t\t\tenum Hello {\n\t\t\t\tWORLD\n\t\t\t}\n\t\t`, &nilPointerReturnResolver{}),\n\t\t\tQuery: `\n\t\t\t\tquery {\n\t\t\t\t\tpointerReturn {\n\t\t\t\t\t\tvalue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"pointerReturn\": null\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage: `graphql: got nil for non-null \"Hello\"`,\n\t\t\t\t\tPath:    []interface{}{\"pointerReturn\", \"value\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t})\n}\n\ntype nullableInput struct {\n\tString graphql.NullString\n\tInt    graphql.NullInt\n\tBool   graphql.NullBool\n\tTime   graphql.NullTime\n\tFloat  graphql.NullFloat\n}\n\ntype nullableResult struct {\n\tString string\n\tInt    string\n\tBool   string\n\tTime   string\n\tFloat  string\n}\n\ntype nullableResolver struct {\n}\n\nfunc (r *nullableResolver) TestNullables(args struct {\n\tInput *nullableInput\n}) nullableResult {\n\tvar res nullableResult\n\tif args.Input.String.Set {\n\t\tif args.Input.String.Value == nil {\n\t\t\tres.String = \"<nil>\"\n\t\t} else {\n\t\t\tres.String = *args.Input.String.Value\n\t\t}\n\t}\n\n\tif args.Input.Int.Set {\n\t\tif args.Input.Int.Value == nil {\n\t\t\tres.Int = \"<nil>\"\n\t\t} else {\n\t\t\tres.Int = fmt.Sprintf(\"%d\", *args.Input.Int.Value)\n\t\t}\n\t}\n\n\tif args.Input.Float.Set {\n\t\tif args.Input.Float.Value == nil {\n\t\t\tres.Float = \"<nil>\"\n\t\t} else {\n\t\t\tres.Float = fmt.Sprintf(\"%.2f\", *args.Input.Float.Value)\n\t\t}\n\t}\n\n\tif args.Input.Bool.Set {\n\t\tif args.Input.Bool.Value == nil {\n\t\t\tres.Bool = \"<nil>\"\n\t\t} else {\n\t\t\tres.Bool = fmt.Sprintf(\"%t\", *args.Input.Bool.Value)\n\t\t}\n\t}\n\n\tif args.Input.Time.Set {\n\t\tif args.Input.Time.Value == nil {\n\t\t\tres.Time = \"<nil>\"\n\t\t} else {\n\t\t\tres.Time = args.Input.Time.Value.Format(time.RFC3339)\n\t\t}\n\t}\n\n\treturn res\n}\n\nfunc TestNullable(t *testing.T) {\n\tschema := `\n\tscalar Time\n\n\tinput MyInput {\n\t\tstring: String\n\t\tint: Int\n\t\tfloat: Float\n\t\tbool: Boolean\n\t\ttime: Time\n\t}\n\n\ttype Result {\n\t\tstring: String!\n\t\tint: String!\n\t\tfloat: String!\n\t\tbool: String!\n\t\ttime: String!\n\t}\n\n\ttype Query {\n\t\ttestNullables(input: MyInput): Result!\n\t}\n\t`\n\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(schema, &nullableResolver{}, graphql.UseFieldResolvers()),\n\t\t\tQuery: `\n\t\t\t\tquery {\n\t\t\t\t\ttestNullables(input: {\n\t\t\t\t\t\tstring: \"test\"\n\t\t\t\t\t\tint: 1234\n\t\t\t\t\t\tfloat: 42.42\n\t\t\t\t\t\tbool: true\n\t\t\t\t\t\ttime: \"2021-01-02T15:04:05Z\"\n\t\t\t\t\t}) {\n\t\t\t\t\t\tstring\n\t\t\t\t\t\tint\n\t\t\t\t\t\tfloat\n\t\t\t\t\t\tbool\n\t\t\t\t\t\ttime\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"testNullables\": {\n\t\t\t\t\t\t\"string\": \"test\",\n\t\t\t\t\t\t\"int\": \"1234\",\n\t\t\t\t\t\t\"float\": \"42.42\",\n\t\t\t\t\t\t\"bool\": \"true\",\n\t\t\t\t\t\t\"time\": \"2021-01-02T15:04:05Z\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(schema, &nullableResolver{}, graphql.UseFieldResolvers()),\n\t\t\tQuery: `\n\t\t\t\tquery {\n\t\t\t\t\ttestNullables(input: {\n\t\t\t\t\t\tstring: null\n\t\t\t\t\t\tint: null\n\t\t\t\t\t\tfloat: null\n\t\t\t\t\t\tbool: null\n\t\t\t\t\t\ttime: null\n\t\t\t\t\t}) {\n\t\t\t\t\t\tstring\n\t\t\t\t\t\tint\n\t\t\t\t\t\tfloat\n\t\t\t\t\t\tbool\n\t\t\t\t\t\ttime\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"testNullables\": {\n\t\t\t\t\t\t\"string\": \"<nil>\",\n\t\t\t\t\t\t\"int\": \"<nil>\",\n\t\t\t\t\t\t\"float\": \"<nil>\",\n\t\t\t\t\t\t\"bool\": \"<nil>\",\n\t\t\t\t\t\t\"time\": \"<nil>\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(schema, &nullableResolver{}, graphql.UseFieldResolvers()),\n\t\t\tQuery: `\n\t\t\t\tquery {\n\t\t\t\t\ttestNullables(input: {}) {\n\t\t\t\t\t\tstring\n\t\t\t\t\t\tint\n\t\t\t\t\t\tfloat\n\t\t\t\t\t\tbool\n\t\t\t\t\t\ttime\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"testNullables\": {\n\t\t\t\t\t\t\"string\": \"\",\n\t\t\t\t\t\t\"int\": \"\",\n\t\t\t\t\t\t\"float\": \"\",\n\t\t\t\t\t\t\"bool\": \"\",\n\t\t\t\t\t\t\"time\": \"\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\ntype testTracer struct {\n\tmu      *sync.Mutex\n\tfields  []fieldTrace\n\tqueries []queryTrace\n}\n\ntype fieldTrace struct {\n\tlabel     string\n\ttypeName  string\n\tfieldName string\n\tisTrivial bool\n\targs      map[string]interface{}\n\terr       *gqlerrors.QueryError\n}\n\ntype queryTrace struct {\n\tdocument  string\n\topName    string\n\tvariables map[string]interface{}\n\tvarTypes  map[string]*introspection.Type\n\terrors    []*gqlerrors.QueryError\n}\n\nfunc (t *testTracer) TraceField(ctx context.Context, label, typeName, fieldName string, trivial bool, args map[string]interface{}) (context.Context, trace.TraceFieldFinishFunc) {\n\treturn ctx, func(qe *gqlerrors.QueryError) {\n\t\tt.mu.Lock()\n\t\tdefer t.mu.Unlock()\n\n\t\tft := fieldTrace{\n\t\t\tlabel:     label,\n\t\t\ttypeName:  typeName,\n\t\t\tfieldName: fieldName,\n\t\t\tisTrivial: trivial,\n\t\t\targs:      args,\n\t\t\terr:       qe,\n\t\t}\n\n\t\tt.fields = append(t.fields, ft)\n\t}\n}\n\nfunc (t *testTracer) TraceQuery(ctx context.Context, document string, opName string, vars map[string]interface{}, varTypes map[string]*introspection.Type) (context.Context, trace.TraceQueryFinishFunc) {\n\treturn ctx, func(qe []*gqlerrors.QueryError) {\n\t\tt.mu.Lock()\n\t\tdefer t.mu.Unlock()\n\n\t\tqt := queryTrace{\n\t\t\tdocument:  document,\n\t\t\topName:    opName,\n\t\t\tvariables: vars,\n\t\t\tvarTypes:  varTypes,\n\t\t\terrors:    qe,\n\t\t}\n\n\t\tt.queries = append(t.queries, qt)\n\t}\n}\n\nvar _ trace.Tracer = (*testTracer)(nil)\n\nfunc TestTracer(t *testing.T) {\n\tt.Parallel()\n\n\ttracer := &testTracer{mu: &sync.Mutex{}}\n\n\tschema, err := graphql.ParseSchema(starwars.Schema, &starwars.Resolver{}, graphql.Tracer(tracer))\n\tif err != nil {\n\t\tt.Fatalf(\"graphql.ParseSchema: %s\", err)\n\t}\n\n\tctx := context.Background()\n\tdoc := `\n\tquery TestTracer($id: ID!) {\n\t\tHanSolo: human(id: $id) {\n\t\t\t__typename\n\t\t\tname\n\t\t}\n\t}\n\t`\n\topName := \"TestTracer\"\n\tvariables := map[string]interface{}{\n\t\t\"id\": \"1002\",\n\t}\n\n\t_ = schema.Exec(ctx, doc, opName, variables)\n\n\ttracer.mu.Lock()\n\tdefer tracer.mu.Unlock()\n\n\tif len(tracer.queries) != 1 {\n\t\tt.Fatalf(\"expected one query trace, but got %d: %#v\", len(tracer.queries), tracer.queries)\n\t}\n\n\tqt := tracer.queries[0]\n\tif qt.document != doc {\n\t\tt.Errorf(\"mismatched query trace document:\\nwant: %q\\ngot : %q\", doc, qt.document)\n\t}\n\tif qt.opName != opName {\n\t\tt.Errorf(\"mismated query trace operationName:\\nwant: %q\\ngot : %q\", opName, qt.opName)\n\t}\n\n\texpectedFieldTraces := []fieldTrace{\n\t\t{fieldName: \"human\", typeName: \"Query\"},\n\t\t{fieldName: \"__typename\", typeName: \"Human\"},\n\t\t{fieldName: \"name\", typeName: \"Human\"},\n\t}\n\n\tcheckFieldTraces(t, expectedFieldTraces, tracer.fields)\n}\n\nfunc checkFieldTraces(t *testing.T, want, have []fieldTrace) {\n\tif len(want) != len(have) {\n\t\tt.Errorf(\"mismatched field traces: expected %d but got %d: %#v\", len(want), len(have), have)\n\t}\n\n\ttype comparison struct {\n\t\twant fieldTrace\n\t\thave fieldTrace\n\t}\n\n\tm := map[string]comparison{}\n\n\tfor _, ft := range want {\n\t\tm[ft.fieldName] = comparison{want: ft}\n\t}\n\n\tfor _, ft := range have {\n\t\tc := m[ft.fieldName]\n\t\tc.have = ft\n\t\tm[ft.fieldName] = c\n\t}\n\n\tfor _, c := range m {\n\t\tif err := stringsEqual(c.want.fieldName, c.have.fieldName); err != \"\" {\n\t\t\tt.Error(\"mismatched field name:\", err)\n\t\t}\n\t\tif err := stringsEqual(c.want.typeName, c.have.typeName); err != \"\" {\n\t\t\tt.Error(\"mismatched field parent type:\", err)\n\t\t}\n\t}\n}\n\nfunc stringsEqual(want, have string) string {\n\tif want != have {\n\t\treturn fmt.Sprintf(\"mismatched values:\\nwant: %q\\nhave: %q\", want, have)\n\t}\n\n\treturn \"\"\n}\n\ntype queryVarResolver struct{}\ntype filterArgs struct {\n\tRequired string\n\tOptional *string\n}\ntype filterSearchResults struct {\n\tMatch *string\n}\n\nfunc (r *queryVarResolver) Search(ctx context.Context, args *struct{ Filter filterArgs }) []filterSearchResults {\n\treturn []filterSearchResults{}\n}\n\nfunc TestQueryVariablesValidation(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{{\n\t\tSchema: graphql.MustParseSchema(`\n\t\t\tinput SearchFilter {\n\t\t\t  \trequired: String!\n\t\t\t  \toptional: String\n\t\t\t}\n\t\t\t\n\t\t\ttype SearchResults {\n\t\t\t\tmatch: String\n\t\t\t}\n\t\t\t\n\t\t\ttype Query {\n\t\t\t\tsearch(filter: SearchFilter!): [SearchResults!]!\n\t\t\t}`, &queryVarResolver{}, graphql.UseFieldResolvers()),\n\t\tQuery: `\n        \t\tquery {\n        \t\t\tsearch(filter: {}) {\n        \t\t\t\tmatch\n        \t\t\t}\n        \t\t}`,\n\t\tExpectedErrors: []*gqlerrors.QueryError{{\n\t\t\tMessage:   \"Argument \\\"filter\\\" has invalid value {}.\\nIn field \\\"required\\\": Expected \\\"String!\\\", found null.\",\n\t\t\tLocations: []gqlerrors.Location{{Line: 3, Column: 27}},\n\t\t\tRule:      \"ArgumentsOfCorrectType\",\n\t\t}},\n\t}, {\n\t\tSchema: graphql.MustParseSchema(`\n\t\t\tinput SearchFilter {\n\t\t\t\trequired: String!\n\t\t\t\toptional: String\n\t\t\t}\n\t\t\t\n\t\t\ttype SearchResults {\n\t\t\t\tmatch: String\n\t\t\t}\n\t\t\t\n\t\t\ttype Query {\n\t\t\t\tsearch(filter: SearchFilter!): [SearchResults!]!\n\t\t\t}`, &queryVarResolver{}, graphql.UseFieldResolvers()),\n\t\tQuery: `\n\t\t\tquery q($filter: SearchFilter!) {\n\t\t\t\tsearch(filter: $filter) {\n\t\t\t\t\tmatch\n\t\t\t\t}\n\t\t\t}`,\n\t\tVariables: map[string]interface{}{\"filter\": map[string]interface{}{}},\n\t\tExpectedErrors: []*gqlerrors.QueryError{{\n\t\t\tMessage:   \"Variable \\\"required\\\" has invalid value null.\\nExpected type \\\"String!\\\", found null.\",\n\t\t\tLocations: []gqlerrors.Location{{Line: 3, Column: 5}},\n\t\t\tRule:      \"VariablesOfCorrectType\",\n\t\t}},\n\t}})\n}\n\ntype interfaceImplementingInterfaceResolver struct{}\ntype interfaceImplementingInterfaceExample struct {\n\tA string\n\tB string\n\tC bool\n}\n\nfunc (r *interfaceImplementingInterfaceResolver) Hey() *interfaceImplementingInterfaceExample {\n\treturn &interfaceImplementingInterfaceExample{\n\t\tA: \"testing\",\n\t\tB: \"test\",\n\t\tC: true,\n\t}\n}\n\nfunc TestInterfaceImplementingInterface(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{{\n\t\tSchema: graphql.MustParseSchema(`\n        interface A {\n          a: String!\n        }\n        interface B implements A {\n          a: String!\n          b: String!\n        }\n        interface C implements B & A {\n          a: String!\n          b: String!\n          c: Boolean!\n        }\n        type ABC implements C {\n          a: String!\n          b: String!\n          c: Boolean!\n        }\n        type Query {\n          hey: ABC\n        }`, &interfaceImplementingInterfaceResolver{}, graphql.UseFieldResolvers(), graphql.UseFieldResolvers()),\n\t\tQuery: `query {hey { a b c }}`,\n\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hey\": {\n\t\t\t\t\t\t\"a\": \"testing\",\n\t\t\t\t\t\t\"b\": \"test\",\n\t\t\t\t\t\t\"c\": true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t}})\n}\n", "package validation\n\nimport (\n\t\"testing\"\n\n\t\"github.com/graph-gophers/graphql-go/internal/query\"\n\t\"github.com/graph-gophers/graphql-go/internal/schema\"\n\t\"github.com/graph-gophers/graphql-go/types\"\n)\n\nconst (\n\tsimpleSchema = `schema {\n\t\tquery: Query\n\t}\n\n\ttype Query {\n\t\tcharacters: [Character]!\n\t}\n\n\ttype Character {\n\t\tid: ID!\n\t\tname: String!\n\t\tfriends: [Character]!\n\t}`\n\tinterfaceSimple = `schema {\n\t\tquery: Query\n\t}\n\n\ttype Query {\n\t\tcharacters: [Character]\n\t}\n\n\tinterface Character {\n\t\tid: ID!\n\t\tname: String!\n\t\tfriends: [Character]\n\t\tappearsIn: [Episode]!\n\t}\n\n\tenum Episode {\n\t\tNEWHOPE\n\t\tEMPIRE\n\t\tJEDI\n\t}\n\n\ttype Starship {}\n\n\ttype Human implements Character {\n\t\tid: ID!\n\t\tname: String!\n\t\tfriends: [Character]\n\t\tappearsIn: [Episode]!\n\t\tstarships: [Starship]\n\t\ttotalCredits: Int\n\t}\n\n\ttype Droid implements Character {\n\t\tid: ID!\n\t\tname: String!\n\t\tfriends: [Character]\n\t\tappearsIn: [Episode]!\n\t\tprimaryFunction: String\n\t}`\n)\n\ntype maxDepthTestCase struct {\n\tname           string\n\tquery          string\n\tdepth          int\n\tfailure        bool\n\texpectedErrors []string\n}\n\nfunc (tc maxDepthTestCase) Run(t *testing.T, s *types.Schema) {\n\tt.Run(tc.name, func(t *testing.T) {\n\t\tdoc, qErr := query.Parse(tc.query)\n\t\tif qErr != nil {\n\t\t\tt.Fatal(qErr)\n\t\t}\n\n\t\terrs := Validate(s, doc, nil, tc.depth)\n\t\tif len(tc.expectedErrors) > 0 {\n\t\t\tif len(errs) > 0 {\n\t\t\t\tfor _, expected := range tc.expectedErrors {\n\t\t\t\t\tfound := false\n\t\t\t\t\tfor _, err := range errs {\n\t\t\t\t\t\tif err.Rule == expected {\n\t\t\t\t\t\t\tfound = true\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif !found {\n\t\t\t\t\t\tt.Errorf(\"expected error %v is missing\", expected)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tt.Errorf(\"expected errors [%v] are missing\", tc.expectedErrors)\n\t\t\t}\n\t\t}\n\t\tif (len(errs) > 0) != tc.failure {\n\t\t\tt.Errorf(\"expected failure: %t, actual errors (%d): %v\", tc.failure, len(errs), errs)\n\t\t}\n\t})\n}\n\nfunc TestMaxDepth(t *testing.T) {\n\ts, err := schema.ParseSchema(simpleSchema, false)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfor _, tc := range []maxDepthTestCase{\n\t\t{\n\t\t\tname: \"off\",\n\t\t\tquery: `query Okay {        # depth 0\n\t\t\tcharacters {         # depth 1\n\t\t\t  id                 # depth 2\n\t\t\t  name               # depth 2\n\t\t\t  friends {          # depth 2\n\t\t\t\t\tfriends {    # depth 3\n\t\t\t\t\t  friends {  # depth 4\n\t\t\t\t\t\t  id       # depth 5\n\t\t\t\t\t\t  name     # depth 5\n\t\t\t\t\t  }\n\t\t\t\t  }\n\t\t\t  }\n\t\t\t}\n\t\t}`,\n\t\t\tdepth: 0,\n\t\t}, {\n\t\t\tname: \"maxDepth-1\",\n\t\t\tquery: `query Fine {        # depth 0\n\t\t\t\tcharacters {         # depth 1\n\t\t\t\t  id                 # depth 2\n\t\t\t\t  name               # depth 2\n\t\t\t\t  friends {          # depth 2\n\t\t\t\t\t  id               # depth 3\n\t\t\t\t\t  name             # depth 3\n\t\t\t\t  }\n\t\t\t\t}\n\t\t\t}`,\n\t\t\tdepth: 4,\n\t\t}, {\n\t\t\tname: \"maxDepth\",\n\t\t\tquery: `query Deep {        # depth 0\n\t\t\t\tcharacters {         # depth 1\n\t\t\t\t  id                 # depth 2\n\t\t\t\t  name               # depth 2\n\t\t\t\t  friends {          # depth 2\n\t\t\t\t\t  id               # depth 3\n\t\t\t\t\t  name             # depth 3\n\t\t\t\t  }\n\t\t\t\t}\n\t\t\t}`,\n\t\t\tdepth: 3,\n\t\t}, {\n\t\t\tname: \"maxDepth+1\",\n\t\t\tquery: `query TooDeep {        # depth 0\n\t\t\t\tcharacters {         # depth 1\n\t\t\t\t  id                 # depth 2\n\t\t\t\t  name               # depth 2\n\t\t\t\t  friends {          # depth 2\n\t\t\t\t\t\tfriends {    # depth 3\n\t\t\t\t\t\t  friends {  # depth 4\n\t\t\t\t\t\t\tid       # depth 5\n\t\t\t\t\t\t\tname     # depth 5\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}`,\n\t\t\tdepth:   4,\n\t\t\tfailure: true,\n\t\t},\n\t} {\n\t\ttc.Run(t, s)\n\t}\n}\n\nfunc TestMaxDepthInlineFragments(t *testing.T) {\n\ts, err := schema.ParseSchema(interfaceSimple, false)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfor _, tc := range []maxDepthTestCase{\n\t\t{\n\t\t\tname: \"maxDepth-1\",\n\t\t\tquery: `query { # depth 0\n\t\t\t\tcharacters { # depth 1\n\t\t\t\t  name # depth 2\n\t\t\t\t  ... on Human { # depth 2\n\t\t\t\t\ttotalCredits # depth 2\n\t\t\t\t  }\n\t\t\t\t}\n\t\t\t  }`,\n\t\t\tdepth: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"maxDepth\",\n\t\t\tquery: `query { # depth 0\n\t\t\t\tcharacters { # depth 1\n\t\t\t\t  ... on Droid { # depth 2\n\t\t\t\t\tprimaryFunction # depth 2\n\t\t\t\t  }\n\t\t\t\t}\n\t\t\t  }`,\n\t\t\tdepth: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"maxDepth+1\",\n\t\t\tquery: `query { # depth 0\n\t\t\t\tcharacters { # depth 1\n\t\t\t\t  ... on Droid { # depth 2\n\t\t\t\t\tprimaryFunction # depth 2\n\t\t\t\t  }\n\t\t\t\t}\n\t\t\t  }`,\n\t\t\tdepth:   1,\n\t\t\tfailure: true,\n\t\t},\n\t} {\n\t\ttc.Run(t, s)\n\t}\n}\n\nfunc TestMaxDepthFragmentSpreads(t *testing.T) {\n\ts, err := schema.ParseSchema(interfaceSimple, false)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfor _, tc := range []maxDepthTestCase{\n\t\t{\n\t\t\tname: \"maxDepth-1\",\n\t\t\tquery: `fragment friend on Character {\n\t\t\t\tid  # depth 5\n\t\t\t\tname\n\t\t\t\tfriends {\n\t\t\t\t\tname  # depth 6\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tquery {        # depth 0\n\t\t\t\tcharacters {         # depth 1\n\t\t\t\t  id                 # depth 2\n\t\t\t\t  name               # depth 2\n\t\t\t\t  friends {          # depth 2\n\t\t\t\t\tfriends {        # depth 3\n\t\t\t\t\t\tfriends {    # depth 4\n\t\t\t\t\t\t\t...friend # depth 5\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t  }\n\t\t\t\t}\n\t\t\t}`,\n\t\t\tdepth: 7,\n\t\t},\n\t\t{\n\t\t\tname: \"maxDepth\",\n\t\t\tquery: `fragment friend on Character {\n\t\t\t\tid # depth 5\n\t\t\t\tname\n\t\t\t}\n\t\t\tquery {        # depth 0\n\t\t\t\tcharacters {         # depth 1\n\t\t\t\t  id                 # depth 2\n\t\t\t\t  name               # depth 2\n\t\t\t\t  friends {          # depth 2\n\t\t\t\t\tfriends {        # depth 3\n\t\t\t\t\t\tfriends {    # depth 4\n\t\t\t\t\t\t\t...friend # depth 5\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t  }\n\t\t\t\t}\n\t\t\t}`,\n\t\t\tdepth: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"maxDepth+1\",\n\t\t\tquery: `fragment friend on Character {\n\t\t\t\tid # depth 6\n\t\t\t\tname\n\t\t\t\tfriends {\n\t\t\t\t\tname # depth 7\n\t\t\t\t}\n\t\t\t}\n\t\t\tquery {        # depth 0\n\t\t\t\tcharacters {         # depth 1\n\t\t\t\t  id                 # depth 2\n\t\t\t\t  name               # depth 2\n\t\t\t\t  friends {          # depth 2\n\t\t\t\t\tfriends {        # depth 3\n\t\t\t\t\t\tfriends {    # depth 4\n\t\t\t\t\t\t  friends {  # depth 5\n\t\t\t\t\t\t\t...friend # depth 6\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t  }\n\t\t\t\t}\n\t\t\t}`,\n\t\t\tdepth:   6,\n\t\t\tfailure: true,\n\t\t},\n\t} {\n\t\ttc.Run(t, s)\n\t}\n}\n\nfunc TestMaxDepthUnknownFragmentSpreads(t *testing.T) {\n\ts, err := schema.ParseSchema(interfaceSimple, false)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfor _, tc := range []maxDepthTestCase{\n\t\t{\n\t\t\tname: \"maxDepthUnknownFragment\",\n\t\t\tquery: `query {        # depth 0\n\t\t\t\tcharacters {         # depth 1\n\t\t\t\t  id                 # depth 2\n\t\t\t\t  name               # depth 2\n\t\t\t\t  friends {          # depth 2\n\t\t\t\t\tfriends {        # depth 3\n\t\t\t\t\t\tfriends {    # depth 4\n\t\t\t\t\t\t  friends {  # depth 5\n\t\t\t\t\t\t\t...unknownFragment # depth 6\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t  }\n\t\t\t\t}\n\t\t\t}`,\n\t\t\tdepth:          6,\n\t\t\tfailure:        true,\n\t\t\texpectedErrors: []string{\"MaxDepthEvaluationError\"},\n\t\t},\n\t} {\n\t\ttc.Run(t, s)\n\t}\n}\n\nfunc TestMaxDepthValidation(t *testing.T) {\n\ts, err := schema.ParseSchema(interfaceSimple, false)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfor _, tc := range []struct {\n\t\tname     string\n\t\tquery    string\n\t\tmaxDepth int\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname: \"off\",\n\t\t\tquery: `query Fine {        # depth 0\n\t\t\t\tcharacters {         # depth 1\n\t\t\t\t  id                 # depth 2\n\t\t\t\t  name               # depth 2\n\t\t\t\t  friends {          # depth 2\n\t\t\t\t\t  id               # depth 3\n\t\t\t\t\t  name             # depth 3\n\t\t\t\t  }\n\t\t\t\t}\n\t\t\t}`,\n\t\t\tmaxDepth: 0,\n\t\t}, {\n\t\t\tname: \"fields\",\n\t\t\tquery: `query Fine {        # depth 0\n\t\t\t\tcharacters {         # depth 1\n\t\t\t\t  id                 # depth 2\n\t\t\t\t  name               # depth 2\n\t\t\t\t  friends {          # depth 2\n\t\t\t\t\t  id               # depth 3\n\t\t\t\t\t  name             # depth 3\n\t\t\t\t  }\n\t\t\t\t}\n\t\t\t}`,\n\t\t\tmaxDepth: 2,\n\t\t\texpected: true,\n\t\t}, {\n\t\t\tname: \"fragment\",\n\t\t\tquery: `fragment friend on Character {\n\t\t\t\tid # depth 6\n\t\t\t\tname\n\t\t\t\tfriends {\n\t\t\t\t\tname # depth 7\n\t\t\t\t}\n\t\t\t}\n\t\t\tquery {        # depth 0\n\t\t\t\tcharacters {         # depth 1\n\t\t\t\t  id                 # depth 2\n\t\t\t\t  name               # depth 2\n\t\t\t\t  friends {          # depth 2\n\t\t\t\t\tfriends {        # depth 3\n\t\t\t\t\t\tfriends {    # depth 4\n\t\t\t\t\t\t  friends {  # depth 5\n\t\t\t\t\t\t\t...friend # depth 6\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t  }\n\t\t\t\t}\n\t\t\t}`,\n\t\t\tmaxDepth: 5,\n\t\t\texpected: true,\n\t\t}, {\n\t\t\tname: \"inlinefragment\",\n\t\t\tquery: `query { # depth 0\n\t\t\t\tcharacters { # depth 1\n\t\t\t\t  ... on Droid { # depth 2\n\t\t\t\t\tprimaryFunction # depth 2\n\t\t\t\t  }\n\t\t\t\t}\n\t\t\t  }`,\n\t\t\tmaxDepth: 1,\n\t\t\texpected: true,\n\t\t},\n\t} {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdoc, err := query.Parse(tc.query)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tcontext := newContext(s, doc, tc.maxDepth)\n\t\t\top := doc.Operations[0]\n\n\t\t\topc := &opContext{context: context, ops: doc.Operations}\n\n\t\t\tactual := validateMaxDepth(opc, op.Selections, 1)\n\t\t\tif actual != tc.expected {\n\t\t\t\tt.Errorf(\"expected %t, actual %t\", tc.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "package validation\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"text/scanner\"\n\n\t\"github.com/graph-gophers/graphql-go/errors\"\n\t\"github.com/graph-gophers/graphql-go/internal/common\"\n\t\"github.com/graph-gophers/graphql-go/internal/query\"\n\t\"github.com/graph-gophers/graphql-go/types\"\n)\n\ntype varSet map[*types.InputValueDefinition]struct{}\n\ntype selectionPair struct{ a, b types.Selection }\n\ntype nameSet map[string]errors.Location\n\ntype fieldInfo struct {\n\tsf     *types.FieldDefinition\n\tparent types.NamedType\n}\n\ntype context struct {\n\tschema           *types.Schema\n\tdoc              *types.ExecutableDefinition\n\terrs             []*errors.QueryError\n\topErrs           map[*types.OperationDefinition][]*errors.QueryError\n\tusedVars         map[*types.OperationDefinition]varSet\n\tfieldMap         map[*types.Field]fieldInfo\n\toverlapValidated map[selectionPair]struct{}\n\tmaxDepth         int\n}\n\nfunc (c *context) addErr(loc errors.Location, rule string, format string, a ...interface{}) {\n\tc.addErrMultiLoc([]errors.Location{loc}, rule, format, a...)\n}\n\nfunc (c *context) addErrMultiLoc(locs []errors.Location, rule string, format string, a ...interface{}) {\n\tc.errs = append(c.errs, &errors.QueryError{\n\t\tMessage:   fmt.Sprintf(format, a...),\n\t\tLocations: locs,\n\t\tRule:      rule,\n\t})\n}\n\ntype opContext struct {\n\t*context\n\tops []*types.OperationDefinition\n}\n\nfunc newContext(s *types.Schema, doc *types.ExecutableDefinition, maxDepth int) *context {\n\treturn &context{\n\t\tschema:           s,\n\t\tdoc:              doc,\n\t\topErrs:           make(map[*types.OperationDefinition][]*errors.QueryError),\n\t\tusedVars:         make(map[*types.OperationDefinition]varSet),\n\t\tfieldMap:         make(map[*types.Field]fieldInfo),\n\t\toverlapValidated: make(map[selectionPair]struct{}),\n\t\tmaxDepth:         maxDepth,\n\t}\n}\n\nfunc Validate(s *types.Schema, doc *types.ExecutableDefinition, variables map[string]interface{}, maxDepth int) []*errors.QueryError {\n\tc := newContext(s, doc, maxDepth)\n\n\topNames := make(nameSet)\n\tfragUsedBy := make(map[*types.FragmentDefinition][]*types.OperationDefinition)\n\tfor _, op := range doc.Operations {\n\t\tc.usedVars[op] = make(varSet)\n\t\topc := &opContext{c, []*types.OperationDefinition{op}}\n\n\t\t// Check if max depth is exceeded, if it's set. If max depth is exceeded,\n\t\t// don't continue to validate the document and exit early.\n\t\tif validateMaxDepth(opc, op.Selections, 1) {\n\t\t\treturn c.errs\n\t\t}\n\n\t\tif op.Name.Name == \"\" && len(doc.Operations) != 1 {\n\t\t\tc.addErr(op.Loc, \"LoneAnonymousOperation\", \"This anonymous operation must be the only defined operation.\")\n\t\t}\n\t\tif op.Name.Name != \"\" {\n\t\t\tvalidateName(c, opNames, op.Name, \"UniqueOperationNames\", \"operation\")\n\t\t}\n\n\t\tvalidateDirectives(opc, string(op.Type), op.Directives)\n\n\t\tvarNames := make(nameSet)\n\t\tfor _, v := range op.Vars {\n\t\t\tvalidateName(c, varNames, v.Name, \"UniqueVariableNames\", \"variable\")\n\n\t\t\tt := resolveType(c, v.Type)\n\t\t\tif !canBeInput(t) {\n\t\t\t\tc.addErr(v.TypeLoc, \"VariablesAreInputTypes\", \"Variable %q cannot be non-input type %q.\", \"$\"+v.Name.Name, t)\n\t\t\t}\n\t\t\tvalidateValue(opc, v, variables[v.Name.Name], t)\n\n\t\t\tif v.Default != nil {\n\t\t\t\tvalidateLiteral(opc, v.Default)\n\n\t\t\t\tif t != nil {\n\t\t\t\t\tif nn, ok := t.(*types.NonNull); ok {\n\t\t\t\t\t\tc.addErr(v.Default.Location(), \"DefaultValuesOfCorrectType\", \"Variable %q of type %q is required and will not use the default value. Perhaps you meant to use type %q.\", \"$\"+v.Name.Name, t, nn.OfType)\n\t\t\t\t\t}\n\n\t\t\t\t\tif ok, reason := validateValueType(opc, v.Default, t); !ok {\n\t\t\t\t\t\tc.addErr(v.Default.Location(), \"DefaultValuesOfCorrectType\", \"Variable %q of type %q has invalid default value %s.\\n%s\", \"$\"+v.Name.Name, t, v.Default, reason)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar entryPoint types.NamedType\n\t\tswitch op.Type {\n\t\tcase query.Query:\n\t\t\tentryPoint = s.EntryPoints[\"query\"]\n\t\tcase query.Mutation:\n\t\t\tentryPoint = s.EntryPoints[\"mutation\"]\n\t\tcase query.Subscription:\n\t\t\tentryPoint = s.EntryPoints[\"subscription\"]\n\t\tdefault:\n\t\t\tpanic(\"unreachable\")\n\t\t}\n\n\t\tvalidateSelectionSet(opc, op.Selections, entryPoint)\n\n\t\tfragUsed := make(map[*types.FragmentDefinition]struct{})\n\t\tmarkUsedFragments(c, op.Selections, fragUsed)\n\t\tfor frag := range fragUsed {\n\t\t\tfragUsedBy[frag] = append(fragUsedBy[frag], op)\n\t\t}\n\t}\n\n\tfragNames := make(nameSet)\n\tfragVisited := make(map[*types.FragmentDefinition]struct{})\n\tfor _, frag := range doc.Fragments {\n\t\topc := &opContext{c, fragUsedBy[frag]}\n\n\t\tvalidateName(c, fragNames, frag.Name, \"UniqueFragmentNames\", \"fragment\")\n\t\tvalidateDirectives(opc, \"FRAGMENT_DEFINITION\", frag.Directives)\n\n\t\tt := unwrapType(resolveType(c, &frag.On))\n\t\t// continue even if t is nil\n\t\tif t != nil && !canBeFragment(t) {\n\t\t\tc.addErr(frag.On.Loc, \"FragmentsOnCompositeTypes\", \"Fragment %q cannot condition on non composite type %q.\", frag.Name.Name, t)\n\t\t\tcontinue\n\t\t}\n\n\t\tvalidateSelectionSet(opc, frag.Selections, t)\n\n\t\tif _, ok := fragVisited[frag]; !ok {\n\t\t\tdetectFragmentCycle(c, frag.Selections, fragVisited, nil, map[string]int{frag.Name.Name: 0})\n\t\t}\n\t}\n\n\tfor _, frag := range doc.Fragments {\n\t\tif len(fragUsedBy[frag]) == 0 {\n\t\t\tc.addErr(frag.Loc, \"NoUnusedFragments\", \"Fragment %q is never used.\", frag.Name.Name)\n\t\t}\n\t}\n\n\tfor _, op := range doc.Operations {\n\t\tc.errs = append(c.errs, c.opErrs[op]...)\n\n\t\topUsedVars := c.usedVars[op]\n\t\tfor _, v := range op.Vars {\n\t\t\tif _, ok := opUsedVars[v]; !ok {\n\t\t\t\topSuffix := \"\"\n\t\t\t\tif op.Name.Name != \"\" {\n\t\t\t\t\topSuffix = fmt.Sprintf(\" in operation %q\", op.Name.Name)\n\t\t\t\t}\n\t\t\t\tc.addErr(v.Loc, \"NoUnusedVariables\", \"Variable %q is never used%s.\", \"$\"+v.Name.Name, opSuffix)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn c.errs\n}\n\nfunc validateValue(c *opContext, v *types.InputValueDefinition, val interface{}, t types.Type) {\n\tswitch t := t.(type) {\n\tcase *types.NonNull:\n\t\tif val == nil {\n\t\t\tc.addErr(v.Loc, \"VariablesOfCorrectType\", \"Variable \\\"%s\\\" has invalid value null.\\nExpected type \\\"%s\\\", found null.\", v.Name.Name, t)\n\t\t\treturn\n\t\t}\n\t\tvalidateValue(c, v, val, t.OfType)\n\tcase *types.List:\n\t\tif val == nil {\n\t\t\treturn\n\t\t}\n\t\tvv, ok := val.([]interface{})\n\t\tif !ok {\n\t\t\t// Input coercion rules allow single items without wrapping array\n\t\t\tvalidateValue(c, v, val, t.OfType)\n\t\t\treturn\n\t\t}\n\t\tfor _, elem := range vv {\n\t\t\tvalidateValue(c, v, elem, t.OfType)\n\t\t}\n\tcase *types.EnumTypeDefinition:\n\t\tif val == nil {\n\t\t\treturn\n\t\t}\n\t\te, ok := val.(string)\n\t\tif !ok {\n\t\t\tc.addErr(v.Loc, \"VariablesOfCorrectType\", \"Variable \\\"%s\\\" has invalid type %T.\\nExpected type \\\"%s\\\", found %v.\", v.Name.Name, val, t, val)\n\t\t\treturn\n\t\t}\n\t\tfor _, option := range t.EnumValuesDefinition {\n\t\t\tif option.EnumValue == e {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tc.addErr(v.Loc, \"VariablesOfCorrectType\", \"Variable \\\"%s\\\" has invalid value %s.\\nExpected type \\\"%s\\\", found %s.\", v.Name.Name, e, t, e)\n\tcase *types.InputObject:\n\t\tif val == nil {\n\t\t\treturn\n\t\t}\n\t\tin, ok := val.(map[string]interface{})\n\t\tif !ok {\n\t\t\tc.addErr(v.Loc, \"VariablesOfCorrectType\", \"Variable \\\"%s\\\" has invalid type %T.\\nExpected type \\\"%s\\\", found %s.\", v.Name.Name, val, t, val)\n\t\t\treturn\n\t\t}\n\t\tfor _, f := range t.Values {\n\t\t\tfieldVal := in[f.Name.Name]\n\t\t\tvalidateValue(c, f, fieldVal, f.Type)\n\t\t}\n\t}\n}\n\n// validates the query doesn't go deeper than maxDepth (if set). Returns whether\n// or not query validated max depth to avoid excessive recursion.\nfunc validateMaxDepth(c *opContext, sels []types.Selection, depth int) bool {\n\t// maxDepth checking is turned off when maxDepth is 0\n\tif c.maxDepth == 0 {\n\t\treturn false\n\t}\n\n\texceededMaxDepth := false\n\n\tfor _, sel := range sels {\n\t\tswitch sel := sel.(type) {\n\t\tcase *types.Field:\n\t\t\tif depth > c.maxDepth {\n\t\t\t\texceededMaxDepth = true\n\t\t\t\tc.addErr(sel.Alias.Loc, \"MaxDepthExceeded\", \"Field %q has depth %d that exceeds max depth %d\", sel.Name.Name, depth, c.maxDepth)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\texceededMaxDepth = exceededMaxDepth || validateMaxDepth(c, sel.SelectionSet, depth+1)\n\t\tcase *types.InlineFragment:\n\t\t\t// Depth is not checked because inline fragments resolve to other fields which are checked.\n\t\t\t// Depth is not incremented because inline fragments have the same depth as neighboring fields\n\t\t\texceededMaxDepth = exceededMaxDepth || validateMaxDepth(c, sel.Selections, depth)\n\t\tcase *types.FragmentSpread:\n\t\t\t// Depth is not checked because fragments resolve to other fields which are checked.\n\t\t\tfrag := c.doc.Fragments.Get(sel.Name.Name)\n\t\t\tif frag == nil {\n\t\t\t\t// In case of unknown fragment (invalid request), ignore max depth evaluation\n\t\t\t\tc.addErr(sel.Loc, \"MaxDepthEvaluationError\", \"Unknown fragment %q. Unable to evaluate depth.\", sel.Name.Name)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Depth is not incremented because fragments have the same depth as surrounding fields\n\t\t\texceededMaxDepth = exceededMaxDepth || validateMaxDepth(c, frag.Selections, depth)\n\t\t}\n\t}\n\n\treturn exceededMaxDepth\n}\n\nfunc validateSelectionSet(c *opContext, sels []types.Selection, t types.NamedType) {\n\tfor _, sel := range sels {\n\t\tvalidateSelection(c, sel, t)\n\t}\n\n\tfor i, a := range sels {\n\t\tfor _, b := range sels[i+1:] {\n\t\t\tc.validateOverlap(a, b, nil, nil)\n\t\t}\n\t}\n}\n\nfunc validateSelection(c *opContext, sel types.Selection, t types.NamedType) {\n\tswitch sel := sel.(type) {\n\tcase *types.Field:\n\t\tvalidateDirectives(c, \"FIELD\", sel.Directives)\n\n\t\tfieldName := sel.Name.Name\n\t\tvar f *types.FieldDefinition\n\t\tswitch fieldName {\n\t\tcase \"__typename\":\n\t\t\tf = &types.FieldDefinition{\n\t\t\t\tName: \"__typename\",\n\t\t\t\tType: c.schema.Types[\"String\"],\n\t\t\t}\n\t\tcase \"__schema\":\n\t\t\tf = &types.FieldDefinition{\n\t\t\t\tName: \"__schema\",\n\t\t\t\tType: c.schema.Types[\"__Schema\"],\n\t\t\t}\n\t\tcase \"__type\":\n\t\t\tf = &types.FieldDefinition{\n\t\t\t\tName: \"__type\",\n\t\t\t\tArguments: types.ArgumentsDefinition{\n\t\t\t\t\t&types.InputValueDefinition{\n\t\t\t\t\t\tName: types.Ident{Name: \"name\"},\n\t\t\t\t\t\tType: &types.NonNull{OfType: c.schema.Types[\"String\"]},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tType: c.schema.Types[\"__Type\"],\n\t\t\t}\n\t\tdefault:\n\t\t\tf = fields(t).Get(fieldName)\n\t\t\tif f == nil && t != nil {\n\t\t\t\tsuggestion := makeSuggestion(\"Did you mean\", fields(t).Names(), fieldName)\n\t\t\t\tc.addErr(sel.Alias.Loc, \"FieldsOnCorrectType\", \"Cannot query field %q on type %q.%s\", fieldName, t, suggestion)\n\t\t\t}\n\t\t}\n\t\tc.fieldMap[sel] = fieldInfo{sf: f, parent: t}\n\n\t\tvalidateArgumentLiterals(c, sel.Arguments)\n\t\tif f != nil {\n\t\t\tvalidateArgumentTypes(c, sel.Arguments, f.Arguments, sel.Alias.Loc,\n\t\t\t\tfunc() string { return fmt.Sprintf(\"field %q of type %q\", fieldName, t) },\n\t\t\t\tfunc() string { return fmt.Sprintf(\"Field %q\", fieldName) },\n\t\t\t)\n\t\t}\n\n\t\tvar ft types.Type\n\t\tif f != nil {\n\t\t\tft = f.Type\n\t\t\tsf := hasSubfields(ft)\n\t\t\tif sf && sel.SelectionSet == nil {\n\t\t\t\tc.addErr(sel.Alias.Loc, \"ScalarLeafs\", \"Field %q of type %q must have a selection of subfields. Did you mean \\\"%s { ... }\\\"?\", fieldName, ft, fieldName)\n\t\t\t}\n\t\t\tif !sf && sel.SelectionSet != nil {\n\t\t\t\tc.addErr(sel.SelectionSetLoc, \"ScalarLeafs\", \"Field %q must not have a selection since type %q has no subfields.\", fieldName, ft)\n\t\t\t}\n\t\t}\n\t\tif sel.SelectionSet != nil {\n\t\t\tvalidateSelectionSet(c, sel.SelectionSet, unwrapType(ft))\n\t\t}\n\n\tcase *types.InlineFragment:\n\t\tvalidateDirectives(c, \"INLINE_FRAGMENT\", sel.Directives)\n\t\tif sel.On.Name != \"\" {\n\t\t\tfragTyp := unwrapType(resolveType(c.context, &sel.On))\n\t\t\tif fragTyp != nil && !compatible(t, fragTyp) {\n\t\t\t\tc.addErr(sel.Loc, \"PossibleFragmentSpreads\", \"Fragment cannot be spread here as objects of type %q can never be of type %q.\", t, fragTyp)\n\t\t\t}\n\t\t\tt = fragTyp\n\t\t\t// continue even if t is nil\n\t\t}\n\t\tif t != nil && !canBeFragment(t) {\n\t\t\tc.addErr(sel.On.Loc, \"FragmentsOnCompositeTypes\", \"Fragment cannot condition on non composite type %q.\", t)\n\t\t\treturn\n\t\t}\n\t\tvalidateSelectionSet(c, sel.Selections, unwrapType(t))\n\n\tcase *types.FragmentSpread:\n\t\tvalidateDirectives(c, \"FRAGMENT_SPREAD\", sel.Directives)\n\t\tfrag := c.doc.Fragments.Get(sel.Name.Name)\n\t\tif frag == nil {\n\t\t\tc.addErr(sel.Name.Loc, \"KnownFragmentNames\", \"Unknown fragment %q.\", sel.Name.Name)\n\t\t\treturn\n\t\t}\n\t\tfragTyp := c.schema.Types[frag.On.Name]\n\t\tif !compatible(t, fragTyp) {\n\t\t\tc.addErr(sel.Loc, \"PossibleFragmentSpreads\", \"Fragment %q cannot be spread here as objects of type %q can never be of type %q.\", frag.Name.Name, t, fragTyp)\n\t\t}\n\n\tdefault:\n\t\tpanic(\"unreachable\")\n\t}\n}\n\nfunc compatible(a, b types.Type) bool {\n\tfor _, pta := range possibleTypes(a) {\n\t\tfor _, ptb := range possibleTypes(b) {\n\t\t\tif pta == ptb {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\nfunc possibleTypes(t types.Type) []*types.ObjectTypeDefinition {\n\tswitch t := t.(type) {\n\tcase *types.ObjectTypeDefinition:\n\t\treturn []*types.ObjectTypeDefinition{t}\n\tcase *types.InterfaceTypeDefinition:\n\t\treturn t.PossibleTypes\n\tcase *types.Union:\n\t\treturn t.UnionMemberTypes\n\tdefault:\n\t\treturn nil\n\t}\n}\n\nfunc markUsedFragments(c *context, sels []types.Selection, fragUsed map[*types.FragmentDefinition]struct{}) {\n\tfor _, sel := range sels {\n\t\tswitch sel := sel.(type) {\n\t\tcase *types.Field:\n\t\t\tif sel.SelectionSet != nil {\n\t\t\t\tmarkUsedFragments(c, sel.SelectionSet, fragUsed)\n\t\t\t}\n\n\t\tcase *types.InlineFragment:\n\t\t\tmarkUsedFragments(c, sel.Selections, fragUsed)\n\n\t\tcase *types.FragmentSpread:\n\t\t\tfrag := c.doc.Fragments.Get(sel.Name.Name)\n\t\t\tif frag == nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif _, ok := fragUsed[frag]; ok {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfragUsed[frag] = struct{}{}\n\t\t\tmarkUsedFragments(c, frag.Selections, fragUsed)\n\n\t\tdefault:\n\t\t\tpanic(\"unreachable\")\n\t\t}\n\t}\n}\n\nfunc detectFragmentCycle(c *context, sels []types.Selection, fragVisited map[*types.FragmentDefinition]struct{}, spreadPath []*types.FragmentSpread, spreadPathIndex map[string]int) {\n\tfor _, sel := range sels {\n\t\tdetectFragmentCycleSel(c, sel, fragVisited, spreadPath, spreadPathIndex)\n\t}\n}\n\nfunc detectFragmentCycleSel(c *context, sel types.Selection, fragVisited map[*types.FragmentDefinition]struct{}, spreadPath []*types.FragmentSpread, spreadPathIndex map[string]int) {\n\tswitch sel := sel.(type) {\n\tcase *types.Field:\n\t\tif sel.SelectionSet != nil {\n\t\t\tdetectFragmentCycle(c, sel.SelectionSet, fragVisited, spreadPath, spreadPathIndex)\n\t\t}\n\n\tcase *types.InlineFragment:\n\t\tdetectFragmentCycle(c, sel.Selections, fragVisited, spreadPath, spreadPathIndex)\n\n\tcase *types.FragmentSpread:\n\t\tfrag := c.doc.Fragments.Get(sel.Name.Name)\n\t\tif frag == nil {\n\t\t\treturn\n\t\t}\n\n\t\tspreadPath = append(spreadPath, sel)\n\t\tif i, ok := spreadPathIndex[frag.Name.Name]; ok {\n\t\t\tcyclePath := spreadPath[i:]\n\t\t\tvia := \"\"\n\t\t\tif len(cyclePath) > 1 {\n\t\t\t\tnames := make([]string, len(cyclePath)-1)\n\t\t\t\tfor i, frag := range cyclePath[:len(cyclePath)-1] {\n\t\t\t\t\tnames[i] = frag.Name.Name\n\t\t\t\t}\n\t\t\t\tvia = \" via \" + strings.Join(names, \", \")\n\t\t\t}\n\n\t\t\tlocs := make([]errors.Location, len(cyclePath))\n\t\t\tfor i, frag := range cyclePath {\n\t\t\t\tlocs[i] = frag.Loc\n\t\t\t}\n\t\t\tc.addErrMultiLoc(locs, \"NoFragmentCycles\", \"Cannot spread fragment %q within itself%s.\", frag.Name.Name, via)\n\t\t\treturn\n\t\t}\n\n\t\tif _, ok := fragVisited[frag]; ok {\n\t\t\treturn\n\t\t}\n\t\tfragVisited[frag] = struct{}{}\n\n\t\tspreadPathIndex[frag.Name.Name] = len(spreadPath)\n\t\tdetectFragmentCycle(c, frag.Selections, fragVisited, spreadPath, spreadPathIndex)\n\t\tdelete(spreadPathIndex, frag.Name.Name)\n\n\tdefault:\n\t\tpanic(\"unreachable\")\n\t}\n}\n\nfunc (c *context) validateOverlap(a, b types.Selection, reasons *[]string, locs *[]errors.Location) {\n\tif a == b {\n\t\treturn\n\t}\n\n\tif _, ok := c.overlapValidated[selectionPair{a, b}]; ok {\n\t\treturn\n\t}\n\tc.overlapValidated[selectionPair{a, b}] = struct{}{}\n\tc.overlapValidated[selectionPair{b, a}] = struct{}{}\n\n\tswitch a := a.(type) {\n\tcase *types.Field:\n\t\tswitch b := b.(type) {\n\t\tcase *types.Field:\n\t\t\tif b.Alias.Loc.Before(a.Alias.Loc) {\n\t\t\t\ta, b = b, a\n\t\t\t}\n\t\t\tif reasons2, locs2 := c.validateFieldOverlap(a, b); len(reasons2) != 0 {\n\t\t\t\tlocs2 = append(locs2, a.Alias.Loc, b.Alias.Loc)\n\t\t\t\tif reasons == nil {\n\t\t\t\t\tc.addErrMultiLoc(locs2, \"OverlappingFieldsCanBeMerged\", \"Fields %q conflict because %s. Use different aliases on the fields to fetch both if this was intentional.\", a.Alias.Name, strings.Join(reasons2, \" and \"))\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tfor _, r := range reasons2 {\n\t\t\t\t\t*reasons = append(*reasons, fmt.Sprintf(\"subfields %q conflict because %s\", a.Alias.Name, r))\n\t\t\t\t}\n\t\t\t\t*locs = append(*locs, locs2...)\n\t\t\t}\n\n\t\tcase *types.InlineFragment:\n\t\t\tfor _, sel := range b.Selections {\n\t\t\t\tc.validateOverlap(a, sel, reasons, locs)\n\t\t\t}\n\n\t\tcase *types.FragmentSpread:\n\t\t\tif frag := c.doc.Fragments.Get(b.Name.Name); frag != nil {\n\t\t\t\tfor _, sel := range frag.Selections {\n\t\t\t\t\tc.validateOverlap(a, sel, reasons, locs)\n\t\t\t\t}\n\t\t\t}\n\n\t\tdefault:\n\t\t\tpanic(\"unreachable\")\n\t\t}\n\n\tcase *types.InlineFragment:\n\t\tfor _, sel := range a.Selections {\n\t\t\tc.validateOverlap(sel, b, reasons, locs)\n\t\t}\n\n\tcase *types.FragmentSpread:\n\t\tif frag := c.doc.Fragments.Get(a.Name.Name); frag != nil {\n\t\t\tfor _, sel := range frag.Selections {\n\t\t\t\tc.validateOverlap(sel, b, reasons, locs)\n\t\t\t}\n\t\t}\n\n\tdefault:\n\t\tpanic(\"unreachable\")\n\t}\n}\n\nfunc (c *context) validateFieldOverlap(a, b *types.Field) ([]string, []errors.Location) {\n\tif a.Alias.Name != b.Alias.Name {\n\t\treturn nil, nil\n\t}\n\n\tif asf := c.fieldMap[a].sf; asf != nil {\n\t\tif bsf := c.fieldMap[b].sf; bsf != nil {\n\t\t\tif !typesCompatible(asf.Type, bsf.Type) {\n\t\t\t\treturn []string{fmt.Sprintf(\"they return conflicting types %s and %s\", asf.Type, bsf.Type)}, nil\n\t\t\t}\n\t\t}\n\t}\n\n\tat := c.fieldMap[a].parent\n\tbt := c.fieldMap[b].parent\n\tif at == nil || bt == nil || at == bt {\n\t\tif a.Name.Name != b.Name.Name {\n\t\t\treturn []string{fmt.Sprintf(\"%s and %s are different fields\", a.Name.Name, b.Name.Name)}, nil\n\t\t}\n\n\t\tif argumentsConflict(a.Arguments, b.Arguments) {\n\t\t\treturn []string{\"they have differing arguments\"}, nil\n\t\t}\n\t}\n\n\tvar reasons []string\n\tvar locs []errors.Location\n\tfor _, a2 := range a.SelectionSet {\n\t\tfor _, b2 := range b.SelectionSet {\n\t\t\tc.validateOverlap(a2, b2, &reasons, &locs)\n\t\t}\n\t}\n\treturn reasons, locs\n}\n\nfunc argumentsConflict(a, b types.ArgumentList) bool {\n\tif len(a) != len(b) {\n\t\treturn true\n\t}\n\tfor _, argA := range a {\n\t\tvalB, ok := b.Get(argA.Name.Name)\n\t\tif !ok || !reflect.DeepEqual(argA.Value.Deserialize(nil), valB.Deserialize(nil)) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc fields(t types.Type) types.FieldsDefinition {\n\tswitch t := t.(type) {\n\tcase *types.ObjectTypeDefinition:\n\t\treturn t.Fields\n\tcase *types.InterfaceTypeDefinition:\n\t\treturn t.Fields\n\tdefault:\n\t\treturn nil\n\t}\n}\n\nfunc unwrapType(t types.Type) types.NamedType {\n\tif t == nil {\n\t\treturn nil\n\t}\n\tfor {\n\t\tswitch t2 := t.(type) {\n\t\tcase types.NamedType:\n\t\t\treturn t2\n\t\tcase *types.List:\n\t\t\tt = t2.OfType\n\t\tcase *types.NonNull:\n\t\t\tt = t2.OfType\n\t\tdefault:\n\t\t\tpanic(\"unreachable\")\n\t\t}\n\t}\n}\n\nfunc resolveType(c *context, t types.Type) types.Type {\n\tt2, err := common.ResolveType(t, c.schema.Resolve)\n\tif err != nil {\n\t\tc.errs = append(c.errs, err)\n\t}\n\treturn t2\n}\n\nfunc validateDirectives(c *opContext, loc string, directives types.DirectiveList) {\n\tdirectiveNames := make(nameSet)\n\tfor _, d := range directives {\n\t\tdirName := d.Name.Name\n\t\tvalidateNameCustomMsg(c.context, directiveNames, d.Name, \"UniqueDirectivesPerLocation\", func() string {\n\t\t\treturn fmt.Sprintf(\"The directive %q can only be used once at this location.\", dirName)\n\t\t})\n\n\t\tvalidateArgumentLiterals(c, d.Arguments)\n\n\t\tdd, ok := c.schema.Directives[dirName]\n\t\tif !ok {\n\t\t\tc.addErr(d.Name.Loc, \"KnownDirectives\", \"Unknown directive %q.\", dirName)\n\t\t\tcontinue\n\t\t}\n\n\t\tlocOK := false\n\t\tfor _, allowedLoc := range dd.Locations {\n\t\t\tif loc == allowedLoc {\n\t\t\t\tlocOK = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !locOK {\n\t\t\tc.addErr(d.Name.Loc, \"KnownDirectives\", \"Directive %q may not be used on %s.\", dirName, loc)\n\t\t}\n\n\t\tvalidateArgumentTypes(c, d.Arguments, dd.Arguments, d.Name.Loc,\n\t\t\tfunc() string { return fmt.Sprintf(\"directive %q\", \"@\"+dirName) },\n\t\t\tfunc() string { return fmt.Sprintf(\"Directive %q\", \"@\"+dirName) },\n\t\t)\n\t}\n}\n\nfunc validateName(c *context, set nameSet, name types.Ident, rule string, kind string) {\n\tvalidateNameCustomMsg(c, set, name, rule, func() string {\n\t\treturn fmt.Sprintf(\"There can be only one %s named %q.\", kind, name.Name)\n\t})\n}\n\nfunc validateNameCustomMsg(c *context, set nameSet, name types.Ident, rule string, msg func() string) {\n\tif loc, ok := set[name.Name]; ok {\n\t\tc.addErrMultiLoc([]errors.Location{loc, name.Loc}, rule, msg())\n\t\treturn\n\t}\n\tset[name.Name] = name.Loc\n}\n\nfunc validateArgumentTypes(c *opContext, args types.ArgumentList, argDecls types.ArgumentsDefinition, loc errors.Location, owner1, owner2 func() string) {\n\tfor _, selArg := range args {\n\t\targ := argDecls.Get(selArg.Name.Name)\n\t\tif arg == nil {\n\t\t\tc.addErr(selArg.Name.Loc, \"KnownArgumentNames\", \"Unknown argument %q on %s.\", selArg.Name.Name, owner1())\n\t\t\tcontinue\n\t\t}\n\t\tvalue := selArg.Value\n\t\tif ok, reason := validateValueType(c, value, arg.Type); !ok {\n\t\t\tc.addErr(value.Location(), \"ArgumentsOfCorrectType\", \"Argument %q has invalid value %s.\\n%s\", arg.Name.Name, value, reason)\n\t\t}\n\t}\n\tfor _, decl := range argDecls {\n\t\tif _, ok := decl.Type.(*types.NonNull); ok {\n\t\t\tif _, ok := args.Get(decl.Name.Name); !ok {\n\t\t\t\tc.addErr(loc, \"ProvidedNonNullArguments\", \"%s argument %q of type %q is required but not provided.\", owner2(), decl.Name.Name, decl.Type)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc validateArgumentLiterals(c *opContext, args types.ArgumentList) {\n\targNames := make(nameSet)\n\tfor _, arg := range args {\n\t\tvalidateName(c.context, argNames, arg.Name, \"UniqueArgumentNames\", \"argument\")\n\t\tvalidateLiteral(c, arg.Value)\n\t}\n}\n\nfunc validateLiteral(c *opContext, l types.Value) {\n\tswitch l := l.(type) {\n\tcase *types.ObjectValue:\n\t\tfieldNames := make(nameSet)\n\t\tfor _, f := range l.Fields {\n\t\t\tvalidateName(c.context, fieldNames, f.Name, \"UniqueInputFieldNames\", \"input field\")\n\t\t\tvalidateLiteral(c, f.Value)\n\t\t}\n\tcase *types.ListValue:\n\t\tfor _, entry := range l.Values {\n\t\t\tvalidateLiteral(c, entry)\n\t\t}\n\tcase *types.Variable:\n\t\tfor _, op := range c.ops {\n\t\t\tv := op.Vars.Get(l.Name)\n\t\t\tif v == nil {\n\t\t\t\tbyOp := \"\"\n\t\t\t\tif op.Name.Name != \"\" {\n\t\t\t\t\tbyOp = fmt.Sprintf(\" by operation %q\", op.Name.Name)\n\t\t\t\t}\n\t\t\t\tc.opErrs[op] = append(c.opErrs[op], &errors.QueryError{\n\t\t\t\t\tMessage:   fmt.Sprintf(\"Variable %q is not defined%s.\", \"$\"+l.Name, byOp),\n\t\t\t\t\tLocations: []errors.Location{l.Loc, op.Loc},\n\t\t\t\t\tRule:      \"NoUndefinedVariables\",\n\t\t\t\t})\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tvalidateValueType(c, l, resolveType(c.context, v.Type))\n\t\t\tc.usedVars[op][v] = struct{}{}\n\t\t}\n\t}\n}\n\nfunc validateValueType(c *opContext, v types.Value, t types.Type) (bool, string) {\n\tif v, ok := v.(*types.Variable); ok {\n\t\tfor _, op := range c.ops {\n\t\t\tif v2 := op.Vars.Get(v.Name); v2 != nil {\n\t\t\t\tt2, err := common.ResolveType(v2.Type, c.schema.Resolve)\n\t\t\t\tif _, ok := t2.(*types.NonNull); !ok && v2.Default != nil {\n\t\t\t\t\tt2 = &types.NonNull{OfType: t2}\n\t\t\t\t}\n\t\t\t\tif err == nil && !typeCanBeUsedAs(t2, t) {\n\t\t\t\t\tc.addErrMultiLoc([]errors.Location{v2.Loc, v.Loc}, \"VariablesInAllowedPosition\", \"Variable %q of type %q used in position expecting type %q.\", \"$\"+v.Name, t2, t)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true, \"\"\n\t}\n\n\tif nn, ok := t.(*types.NonNull); ok {\n\t\tif isNull(v) {\n\t\t\treturn false, fmt.Sprintf(\"Expected %q, found null.\", t)\n\t\t}\n\t\tt = nn.OfType\n\t}\n\tif isNull(v) {\n\t\treturn true, \"\"\n\t}\n\n\tswitch t := t.(type) {\n\tcase *types.ScalarTypeDefinition, *types.EnumTypeDefinition:\n\t\tif lit, ok := v.(*types.PrimitiveValue); ok {\n\t\t\tif validateBasicLit(lit, t) {\n\t\t\t\treturn true, \"\"\n\t\t\t}\n\t\t\treturn false, fmt.Sprintf(\"Expected type %q, found %s.\", t, v)\n\t\t}\n\t\treturn true, \"\"\n\n\tcase *types.List:\n\t\tlist, ok := v.(*types.ListValue)\n\t\tif !ok {\n\t\t\treturn validateValueType(c, v, t.OfType) // single value instead of list\n\t\t}\n\t\tfor i, entry := range list.Values {\n\t\t\tif ok, reason := validateValueType(c, entry, t.OfType); !ok {\n\t\t\t\treturn false, fmt.Sprintf(\"In element #%d: %s\", i, reason)\n\t\t\t}\n\t\t}\n\t\treturn true, \"\"\n\n\tcase *types.InputObject:\n\t\tv, ok := v.(*types.ObjectValue)\n\t\tif !ok {\n\t\t\treturn false, fmt.Sprintf(\"Expected %q, found not an object.\", t)\n\t\t}\n\t\tfor _, f := range v.Fields {\n\t\t\tname := f.Name.Name\n\t\t\tiv := t.Values.Get(name)\n\t\t\tif iv == nil {\n\t\t\t\treturn false, fmt.Sprintf(\"In field %q: Unknown field.\", name)\n\t\t\t}\n\t\t\tif ok, reason := validateValueType(c, f.Value, iv.Type); !ok {\n\t\t\t\treturn false, fmt.Sprintf(\"In field %q: %s\", name, reason)\n\t\t\t}\n\t\t}\n\t\tfor _, iv := range t.Values {\n\t\t\tfound := false\n\t\t\tfor _, f := range v.Fields {\n\t\t\t\tif f.Name.Name == iv.Name.Name {\n\t\t\t\t\tfound = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !found {\n\t\t\t\tif _, ok := iv.Type.(*types.NonNull); ok && iv.Default == nil {\n\t\t\t\t\treturn false, fmt.Sprintf(\"In field %q: Expected %q, found null.\", iv.Name.Name, iv.Type)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true, \"\"\n\t}\n\n\treturn false, fmt.Sprintf(\"Expected type %q, found %s.\", t, v)\n}\n\nfunc validateBasicLit(v *types.PrimitiveValue, t types.Type) bool {\n\tswitch t := t.(type) {\n\tcase *types.ScalarTypeDefinition:\n\t\tswitch t.Name {\n\t\tcase \"Int\":\n\t\t\tif v.Type != scanner.Int {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tf, err := strconv.ParseFloat(v.Text, 64)\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\treturn f >= math.MinInt32 && f <= math.MaxInt32\n\t\tcase \"Float\":\n\t\t\treturn v.Type == scanner.Int || v.Type == scanner.Float\n\t\tcase \"String\":\n\t\t\treturn v.Type == scanner.String\n\t\tcase \"Boolean\":\n\t\t\treturn v.Type == scanner.Ident && (v.Text == \"true\" || v.Text == \"false\")\n\t\tcase \"ID\":\n\t\t\treturn v.Type == scanner.Int || v.Type == scanner.String\n\t\tdefault:\n\t\t\t//TODO: Type-check against expected type by Unmarshalling\n\t\t\treturn true\n\t\t}\n\n\tcase *types.EnumTypeDefinition:\n\t\tif v.Type != scanner.Ident {\n\t\t\treturn false\n\t\t}\n\t\tfor _, option := range t.EnumValuesDefinition {\n\t\t\tif option.EnumValue == v.Text {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\n\treturn false\n}\n\nfunc canBeFragment(t types.Type) bool {\n\tswitch t.(type) {\n\tcase *types.ObjectTypeDefinition, *types.InterfaceTypeDefinition, *types.Union:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc canBeInput(t types.Type) bool {\n\tswitch t := t.(type) {\n\tcase *types.InputObject, *types.ScalarTypeDefinition, *types.EnumTypeDefinition:\n\t\treturn true\n\tcase *types.List:\n\t\treturn canBeInput(t.OfType)\n\tcase *types.NonNull:\n\t\treturn canBeInput(t.OfType)\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc hasSubfields(t types.Type) bool {\n\tswitch t := t.(type) {\n\tcase *types.ObjectTypeDefinition, *types.InterfaceTypeDefinition, *types.Union:\n\t\treturn true\n\tcase *types.List:\n\t\treturn hasSubfields(t.OfType)\n\tcase *types.NonNull:\n\t\treturn hasSubfields(t.OfType)\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc isLeaf(t types.Type) bool {\n\tswitch t.(type) {\n\tcase *types.ScalarTypeDefinition, *types.EnumTypeDefinition:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc isNull(lit interface{}) bool {\n\t_, ok := lit.(*types.NullValue)\n\treturn ok\n}\n\nfunc typesCompatible(a, b types.Type) bool {\n\tal, aIsList := a.(*types.List)\n\tbl, bIsList := b.(*types.List)\n\tif aIsList || bIsList {\n\t\treturn aIsList && bIsList && typesCompatible(al.OfType, bl.OfType)\n\t}\n\n\tann, aIsNN := a.(*types.NonNull)\n\tbnn, bIsNN := b.(*types.NonNull)\n\tif aIsNN || bIsNN {\n\t\treturn aIsNN && bIsNN && typesCompatible(ann.OfType, bnn.OfType)\n\t}\n\n\tif isLeaf(a) || isLeaf(b) {\n\t\treturn a == b\n\t}\n\n\treturn true\n}\n\nfunc typeCanBeUsedAs(t, as types.Type) bool {\n\tnnT, okT := t.(*types.NonNull)\n\tif okT {\n\t\tt = nnT.OfType\n\t}\n\n\tnnAs, okAs := as.(*types.NonNull)\n\tif okAs {\n\t\tas = nnAs.OfType\n\t\tif !okT {\n\t\t\treturn false // nullable can not be used as non-null\n\t\t}\n\t}\n\n\tif t == as {\n\t\treturn true\n\t}\n\n\tif lT, ok := t.(*types.List); ok {\n\t\tif lAs, ok := as.(*types.List); ok {\n\t\t\treturn typeCanBeUsedAs(lT.OfType, lAs.OfType)\n\t\t}\n\t}\n\treturn false\n}\n"], "fixing_code": ["package graphql_test\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/graph-gophers/graphql-go\"\n\tgqlerrors \"github.com/graph-gophers/graphql-go/errors\"\n\t\"github.com/graph-gophers/graphql-go/example/starwars\"\n\t\"github.com/graph-gophers/graphql-go/gqltesting\"\n\t\"github.com/graph-gophers/graphql-go/introspection\"\n\t\"github.com/graph-gophers/graphql-go/trace\"\n)\n\ntype helloWorldResolver1 struct{}\n\nfunc (r *helloWorldResolver1) Hello() string {\n\treturn \"Hello world!\"\n}\n\ntype helloWorldResolver2 struct{}\n\nfunc (r *helloWorldResolver2) Hello(ctx context.Context) (string, error) {\n\treturn \"Hello world!\", nil\n}\n\ntype helloSnakeResolver1 struct{}\n\nfunc (r *helloSnakeResolver1) HelloHTML() string {\n\treturn \"Hello snake!\"\n}\n\nfunc (r *helloSnakeResolver1) SayHello(args struct{ FullName string }) string {\n\treturn \"Hello \" + args.FullName + \"!\"\n}\n\ntype helloSnakeResolver2 struct{}\n\nfunc (r *helloSnakeResolver2) HelloHTML(ctx context.Context) (string, error) {\n\treturn \"Hello snake!\", nil\n}\n\nfunc (r *helloSnakeResolver2) SayHello(ctx context.Context, args struct{ FullName string }) (string, error) {\n\treturn \"Hello \" + args.FullName + \"!\", nil\n}\n\ntype theNumberResolver struct {\n\tnumber int32\n}\n\nfunc (r *theNumberResolver) TheNumber() int32 {\n\treturn r.number\n}\n\nfunc (r *theNumberResolver) ChangeTheNumber(args struct{ NewNumber int32 }) *theNumberResolver {\n\tr.number = args.NewNumber\n\treturn r\n}\n\ntype timeResolver struct{}\n\nfunc (r *timeResolver) AddHour(args struct{ Time graphql.Time }) graphql.Time {\n\treturn graphql.Time{Time: args.Time.Add(time.Hour)}\n}\n\ntype echoResolver struct{}\n\nfunc (r *echoResolver) Echo(args struct{ Value *string }) *string {\n\treturn args.Value\n}\n\nvar starwarsSchema = graphql.MustParseSchema(starwars.Schema, &starwars.Resolver{})\n\ntype ResolverError interface {\n\terror\n\tExtensions() map[string]interface{}\n}\n\ntype resolverNotFoundError struct {\n\tCode    string `json:\"code\"`\n\tMessage string `json:\"message\"`\n}\n\nfunc (e resolverNotFoundError) Error() string {\n\treturn fmt.Sprintf(\"Error [%s]: %s\", e.Code, e.Message)\n}\n\nfunc (e resolverNotFoundError) Extensions() map[string]interface{} {\n\treturn map[string]interface{}{\n\t\t\"code\":    e.Code,\n\t\t\"message\": e.Message,\n\t}\n}\n\ntype findDroidResolver struct{}\n\nfunc (r *findDroidResolver) FindDroid(ctx context.Context) (string, error) {\n\treturn \"\", resolverNotFoundError{\n\t\tCode:    \"NotFound\",\n\t\tMessage: \"This is not the droid you are looking for\",\n\t}\n}\n\nvar (\n\tdroidNotFoundError = resolverNotFoundError{\n\t\tCode:    \"NotFound\",\n\t\tMessage: \"This is not the droid you are looking for\",\n\t}\n\tquoteError = errors.New(\"Bleep bloop\")\n\n\tr2d2          = &droidResolver{name: \"R2-D2\"}\n\tc3po          = &droidResolver{name: \"C-3PO\"}\n\tnotFoundDroid = &droidResolver{err: droidNotFoundError}\n)\n\ntype findDroidsResolver struct{}\n\nfunc (r *findDroidsResolver) FindDroids(ctx context.Context) []*droidResolver {\n\treturn []*droidResolver{r2d2, notFoundDroid, c3po}\n}\n\nfunc (r *findDroidsResolver) FindNilDroids(ctx context.Context) *[]*droidResolver {\n\treturn &[]*droidResolver{r2d2, nil, c3po}\n}\n\ntype findDroidOrHumanResolver struct{}\n\nfunc (r *findDroidOrHumanResolver) FindHuman(ctx context.Context) (*string, error) {\n\thuman := \"human\"\n\treturn &human, nil\n}\n\nfunc (r *findDroidOrHumanResolver) FindDroid(ctx context.Context) (*droidResolver, error) {\n\treturn nil, notFoundDroid.err\n}\n\ntype droidResolver struct {\n\tname string\n\terr  error\n}\n\nfunc (d *droidResolver) Name() (string, error) {\n\tif d.err != nil {\n\t\treturn \"\", d.err\n\t}\n\treturn d.name, nil\n}\n\nfunc (d *droidResolver) Quotes() ([]string, error) {\n\tswitch d.name {\n\tcase r2d2.name:\n\t\treturn nil, quoteError\n\tcase c3po.name:\n\t\treturn []string{\"We're doomed!\", \"R2-D2, where are you?\"}, nil\n\t}\n\treturn nil, nil\n}\n\ntype discussPlanResolver struct{}\n\nfunc (r *discussPlanResolver) DismissVader(ctx context.Context) (string, error) {\n\treturn \"\", errors.New(\"I find your lack of faith disturbing\")\n}\n\nfunc TestHelloWorld(t *testing.T) {\n\tt.Parallel()\n\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\thello: String!\n\t\t\t\t}\n\t\t\t`, &helloWorldResolver1{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\thello\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hello\": \"Hello world!\"\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\thello: String!\n\t\t\t\t}\n\t\t\t`, &helloWorldResolver2{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\thello\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hello\": \"Hello world!\"\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nfunc TestHelloSnake(t *testing.T) {\n\tt.Parallel()\n\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\thello_html: String!\n\t\t\t\t}\n\t\t\t`, &helloSnakeResolver1{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\thello_html\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hello_html\": \"Hello snake!\"\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\thello_html: String!\n\t\t\t\t}\n\t\t\t`, &helloSnakeResolver2{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\thello_html\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hello_html\": \"Hello snake!\"\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nfunc TestHelloSnakeArguments(t *testing.T) {\n\tt.Parallel()\n\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tsay_hello(full_name: String!): String!\n\t\t\t\t}\n\t\t\t`, &helloSnakeResolver1{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tsay_hello(full_name: \"Rob Pike\")\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"say_hello\": \"Hello Rob Pike!\"\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tsay_hello(full_name: String!): String!\n\t\t\t\t}\n\t\t\t`, &helloSnakeResolver2{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tsay_hello(full_name: \"Rob Pike\")\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"say_hello\": \"Hello Rob Pike!\"\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nfunc TestRootOperations_invalidSchema(t *testing.T) {\n\ttype args struct {\n\t\tSchema string\n\t}\n\ttype want struct {\n\t\tError string\n\t}\n\ttestTable := map[string]struct {\n\t\tArgs args\n\t\tWant want\n\t}{\n\t\t\"Empty schema\": {\n\t\t\tWant: want{Error: `root operation \"query\" must be defined`},\n\t\t},\n\t\t\"Query declared by schema, but type not present\": {\n\t\t\tArgs: args{\n\t\t\t\tSchema: `\n\t\t\t\t\tschema {\n\t\t\t\t\t\tquery: Query\n\t\t\t\t\t}\n\t\t\t\t`,\n\t\t\t},\n\t\t\tWant: want{Error: `graphql: type \"Query\" not found`},\n\t\t},\n\t\t\"Query as incorrect type\": {\n\t\t\tArgs: args{\n\t\t\t\tSchema: `\n\t\t\t\t\tschema {\n\t\t\t\t\t\tquery: String\n\t\t\t\t\t}\n\t\t\t\t`,\n\t\t\t},\n\t\t\tWant: want{Error: `root operation \"query\" must be an OBJECT`},\n\t\t},\n\t\t\"Query with custom name, schema omitted\": {\n\t\t\tArgs: args{\n\t\t\t\tSchema: `\n\t\t\t\t\ttype QueryType {\n\t\t\t\t\t\thello: String!\n\t\t\t\t\t}\n\t\t\t\t`,\n\t\t\t},\n\t\t\tWant: want{Error: `root operation \"query\" must be defined`},\n\t\t},\n\t\t\"Mutation as incorrect type\": {\n\t\t\tArgs: args{\n\t\t\t\tSchema: `\n\t\t\t\t\tschema {\n\t\t\t\t\t\tquery: Query\n\t\t\t\t\t\tmutation: String\n\t\t\t\t\t}\n\t\t\t\t\ttype Query {\n\t\t\t\t\t\tthing: String\n\t\t\t\t\t}\n\t\t\t\t`,\n\t\t\t},\n\t\t\tWant: want{Error: `root operation \"mutation\" must be an OBJECT`},\n\t\t},\n\t\t\"Mutation declared by schema, but type not present\": {\n\t\t\tArgs: args{\n\t\t\t\tSchema: `\n\t\t\t\t\tschema {\n\t\t\t\t\t\tquery: Query\n\t\t\t\t\t\tmutation: Mutation\n\t\t\t\t\t}\n\t\t\t\t\ttype Query {\n\t\t\t\t\t\thello: String!\n\t\t\t\t\t}\n\t\t\t\t`,\n\t\t\t},\n\t\t\tWant: want{Error: `graphql: type \"Mutation\" not found`},\n\t\t},\n\t}\n\n\tfor name, tt := range testTable {\n\t\ttt := tt\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\t_, err := graphql.ParseSchema(tt.Args.Schema, nil)\n\t\t\tif err == nil || err.Error() != tt.Want.Error {\n\t\t\t\tt.Logf(\"got:  %v\", err)\n\t\t\t\tt.Logf(\"want: %s\", tt.Want.Error)\n\t\t\t\tt.Fail()\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRootOperations_validSchema(t *testing.T) {\n\ttype resolver struct {\n\t\thelloSaidResolver\n\t\thelloWorldResolver1\n\t\ttheNumberResolver\n\t}\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\t// Query only, default name with `schema` omitted\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\ttype Query {\n\t\t\t\t\thello: String!\n\t\t\t\t}\n\t\t\t`, &resolver{}),\n\t\t\tQuery:          `{ hello }`,\n\t\t\tExpectedResult: `{\"hello\": \"Hello world!\"}`,\n\t\t},\n\t\t{\n\t\t\t// Query only, default name with `schema` present\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\t\t\t\ttype Query {\n\t\t\t\t\thello: String!\n\t\t\t\t}\n\t\t\t`, &resolver{}),\n\t\t\tQuery:          `{ hello }`,\n\t\t\tExpectedResult: `{\"hello\": \"Hello world!\"}`,\n\t\t},\n\t\t{\n\t\t\t// Query only, custom name\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: QueryType\n\t\t\t\t}\n\t\t\t\ttype QueryType {\n\t\t\t\t\thello: String!\n\t\t\t\t}\n\t\t\t`, &resolver{}),\n\t\t\tQuery:          `{ hello }`,\n\t\t\tExpectedResult: `{\"hello\": \"Hello world!\"}`,\n\t\t},\n\t\t{\n\t\t\t// Query+Mutation, default names with `schema` omitted\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\ttype Query {\n\t\t\t\t\thello: String!\n\t\t\t\t}\n\t\t\t\ttype Mutation {\n\t\t\t\t\tchangeTheNumber(newNumber: Int!): ChangedNumber!\n\t\t\t\t}\n\t\t\t\ttype ChangedNumber {\n\t\t\t\t\ttheNumber: Int!\n\t\t\t\t}\n\t\t\t`, &resolver{}),\n\t\t\tQuery: `\n\t\t\t\tmutation {\n\t\t\t\t\tchangeTheNumber(newNumber: 1) {\n\t\t\t\t\t\ttheNumber\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `{\"changeTheNumber\": {\"theNumber\": 1}}`,\n\t\t},\n\t\t{\n\t\t\t// Query+Mutation, custom names\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: QueryType\n\t\t\t\t\tmutation: MutationType\n\t\t\t\t}\n\t\t\t\ttype QueryType {\n\t\t\t\t\thello: String!\n\t\t\t\t}\n\t\t\t\ttype MutationType {\n\t\t\t\t\tchangeTheNumber(newNumber: Int!): ChangedNumber!\n\t\t\t\t}\n\t\t\t\ttype ChangedNumber {\n\t\t\t\t\ttheNumber: Int!\n\t\t\t\t}\n\t\t\t`, &resolver{}),\n\t\t\tQuery: `\n\t\t\t\tmutation {\n\t\t\t\t\tchangeTheNumber(newNumber: 1) {\n\t\t\t\t\t\ttheNumber\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `{\"changeTheNumber\": {\"theNumber\": 1}}`,\n\t\t},\n\t\t{\n\t\t\t// Mutation with custom name, schema omitted\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\ttype Query {\n\t\t\t\t\thello: String!\n\t\t\t\t}\n\t\t\t\ttype MutationType {\n\t\t\t\t\tchangeTheNumber(newNumber: Int!): ChangedNumber!\n\t\t\t\t}\n\t\t\t\ttype ChangedNumber {\n\t\t\t\t\ttheNumber: Int!\n\t\t\t\t}\n\t\t\t`, &resolver{}),\n\t\t\tQuery: `\n\t\t\t\tmutation {\n\t\t\t\t\tchangeTheNumber(newNumber: 1) {\n\t\t\t\t\t\ttheNumber\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{{Message: \"no mutations are offered by the schema\"}},\n\t\t},\n\t\t{\n\t\t\t// Explicit schema without mutation field\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\t\t\t\ttype Query {\n\t\t\t\t\thello: String!\n\t\t\t\t}\n\t\t\t\ttype Mutation {\n\t\t\t\t\tchangeTheNumber(newNumber: Int!): ChangedNumber!\n\t\t\t\t}\n\t\t\t\ttype ChangedNumber {\n\t\t\t\t\ttheNumber: Int!\n\t\t\t\t}\n\t\t\t`, &resolver{}),\n\t\t\tQuery: `\n\t\t\t\tmutation {\n\t\t\t\t\tchangeTheNumber(newNumber: 1) {\n\t\t\t\t\t\ttheNumber\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{{Message: \"no mutations are offered by the schema\"}},\n\t\t},\n\t})\n}\n\nfunc TestBasic(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\thero {\n\t\t\t\t\t\tid\n\t\t\t\t\t\tname\n\t\t\t\t\t\tfriends {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hero\": {\n\t\t\t\t\t\t\"id\": \"2001\",\n\t\t\t\t\t\t\"name\": \"R2-D2\",\n\t\t\t\t\t\t\"friends\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Luke Skywalker\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Han Solo\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Leia Organa\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\ntype testEmbeddedStructResolver struct{}\n\nfunc (_ *testEmbeddedStructResolver) Course() courseResolver {\n\treturn courseResolver{\n\t\tCourseMeta: CourseMeta{\n\t\t\tName:       \"Biology\",\n\t\t\tTimestamps: Timestamps{CreatedAt: \"yesterday\", UpdatedAt: \"today\"},\n\t\t},\n\t\tInstructor: Instructor{Name: \"Socrates\"},\n\t}\n}\n\ntype courseResolver struct {\n\tCourseMeta\n\tInstructor Instructor\n}\n\ntype CourseMeta struct {\n\tName string\n\tTimestamps\n}\n\ntype Instructor struct {\n\tName string\n}\n\ntype Timestamps struct {\n\tCreatedAt string\n\tUpdatedAt string\n}\n\nfunc TestEmbeddedStruct(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tcourse: Course!\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ttype Course {\n\t\t\t\t\tname: String!\n\t\t\t\t\tcreatedAt: String!\n\t\t\t\t\tupdatedAt: String!\n\t\t\t\t\tinstructor: Instructor!\n\t\t\t\t}\n\n\t\t\t\ttype Instructor {\n\t\t\t\t\tname: String!\n\t\t\t\t}\n\t\t\t`, &testEmbeddedStructResolver{}, graphql.UseFieldResolvers()),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tcourse{\n\t\t\t\t\t\tname\n\t\t\t\t\t\tcreatedAt\n\t\t\t\t\t\tupdatedAt\n\t\t\t\t\t\tinstructor {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"course\": {\n\t\t\t\t\t\t\"name\": \"Biology\",\n\t\t\t\t\t\t\"createdAt\": \"yesterday\",\n\t\t\t\t\t\t\"updatedAt\": \"today\",\n\t\t\t\t\t\t\"instructor\": {\n\t\t\t\t\t\t\t\"name\":\"Socrates\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\ntype testNilInterfaceResolver struct{}\n\nfunc (r *testNilInterfaceResolver) A() interface{ Z() int32 } {\n\treturn nil\n}\n\nfunc (r *testNilInterfaceResolver) B() (interface{ Z() int32 }, error) {\n\treturn nil, errors.New(\"x\")\n}\n\nfunc (r *testNilInterfaceResolver) C() (interface{ Z() int32 }, error) {\n\treturn nil, nil\n}\n\nfunc TestNilInterface(t *testing.T) {\n\tt.Parallel()\n\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\ta: T\n\t\t\t\t\tb: T\n\t\t\t\t\tc: T\n\t\t\t\t}\n\n\t\t\t\ttype T {\n\t\t\t\t\tz: Int!\n\t\t\t\t}\n\t\t\t`, &testNilInterfaceResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\ta { z }\n\t\t\t\t\tb { z }\n\t\t\t\t\tc { z }\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"a\": null,\n\t\t\t\t\t\"b\": null,\n\t\t\t\t\t\"c\": null\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage:       \"x\",\n\t\t\t\t\tPath:          []interface{}{\"b\"},\n\t\t\t\t\tResolverError: errors.New(\"x\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t})\n}\n\nfunc TestErrorPropagationInLists(t *testing.T) {\n\tt.Parallel()\n\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tfindDroids: [Droid!]!\n\t\t\t\t}\n\t\t\t\ttype Droid {\n\t\t\t\t\tname: String!\n\t\t\t\t}\n\t\t\t`, &findDroidsResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tfindDroids {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\tnull\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage:       droidNotFoundError.Error(),\n\t\t\t\t\tPath:          []interface{}{\"findDroids\", 1, \"name\"},\n\t\t\t\t\tResolverError: droidNotFoundError,\n\t\t\t\t\tExtensions:    map[string]interface{}{\"code\": droidNotFoundError.Code, \"message\": droidNotFoundError.Message},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tfindDroids: [Droid]!\n\t\t\t\t}\n\t\t\t\ttype Droid {\n\t\t\t\t\tname: String!\n\t\t\t\t}\n\t\t\t`, &findDroidsResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tfindDroids {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"findDroids\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"name\": \"R2-D2\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"name\": \"C-3PO\"\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage:       droidNotFoundError.Error(),\n\t\t\t\t\tPath:          []interface{}{\"findDroids\", 1, \"name\"},\n\t\t\t\t\tResolverError: droidNotFoundError,\n\t\t\t\t\tExtensions:    map[string]interface{}{\"code\": droidNotFoundError.Code, \"message\": droidNotFoundError.Message},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tfindNilDroids: [Droid!]\n\t\t\t\t}\n\t\t\t\ttype Droid {\n\t\t\t\t\tname: String!\n\t\t\t\t}\n\t\t\t`, &findDroidsResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tfindNilDroids {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"findNilDroids\": null\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage: `graphql: got nil for non-null \"Droid\"`,\n\t\t\t\t\tPath:    []interface{}{\"findNilDroids\", 1},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tfindNilDroids: [Droid]\n\t\t\t\t}\n\t\t\t\ttype Droid {\n\t\t\t\t\tname: String!\n\t\t\t\t}\n\t\t\t`, &findDroidsResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tfindNilDroids {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"findNilDroids\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"name\": \"R2-D2\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"name\": \"C-3PO\"\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tfindDroids: [Droid]!\n\t\t\t\t}\n\t\t\t\ttype Droid {\n\t\t\t\t\tquotes: [String!]!\n\t\t\t\t}\n\t\t\t`, &findDroidsResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tfindDroids {\n\t\t\t\t\t\tquotes\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"findDroids\": [\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"quotes\": []\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"quotes\": [\n\t\t\t\t\t\t\t\t\"We're doomed!\",\n\t\t\t\t\t\t\t\t\"R2-D2, where are you?\"\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage:       quoteError.Error(),\n\t\t\t\t\tResolverError: quoteError,\n\t\t\t\t\tPath:          []interface{}{\"findDroids\", 0, \"quotes\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tfindNilDroids: [Droid!]\n\t\t\t\t}\n\t\t\t\ttype Droid {\n\t\t\t\t\tname: String!\n\t\t\t\t\tquotes: [String!]!\n\t\t\t\t}\n\t\t\t`, &findDroidsResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tfindNilDroids {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tquotes\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"findNilDroids\": null\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage:       quoteError.Error(),\n\t\t\t\t\tResolverError: quoteError,\n\t\t\t\t\tPath:          []interface{}{\"findNilDroids\", 0, \"quotes\"},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tMessage: `graphql: got nil for non-null \"Droid\"`,\n\t\t\t\t\tPath:    []interface{}{\"findNilDroids\", 1},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t})\n}\n\nfunc TestErrorWithExtensions(t *testing.T) {\n\tt.Parallel()\n\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tFindDroid: Droid!\n\t\t\t\t\tFindHuman: String\n\t\t\t\t}\n\t\t\t\ttype Droid {\n\t\t\t\t\tName: String!\n\t\t\t\t}\n\t\t\t`, &findDroidOrHumanResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tFindDroid {\n\t\t\t\t\t\tName\n\t\t\t\t\t}\n\t\t\t\t\tFindHuman\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\tnull\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage:       droidNotFoundError.Error(),\n\t\t\t\t\tPath:          []interface{}{\"FindDroid\"},\n\t\t\t\t\tResolverError: droidNotFoundError,\n\t\t\t\t\tExtensions:    map[string]interface{}{\"code\": droidNotFoundError.Code, \"message\": droidNotFoundError.Message},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t})\n}\n\nfunc TestErrorWithNoExtensions(t *testing.T) {\n\tt.Parallel()\n\n\terr := errors.New(\"I find your lack of faith disturbing\")\n\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tDismissVader: String!\n\t\t\t\t}\n\t\t\t`, &discussPlanResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tDismissVader\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\tnull\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage:       err.Error(),\n\t\t\t\t\tPath:          []interface{}{\"DismissVader\"},\n\t\t\t\t\tResolverError: err,\n\t\t\t\t\tExtensions:    nil,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t})\n}\n\nfunc TestArguments(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\thuman(id: \"1000\") {\n\t\t\t\t\t\tname\n\t\t\t\t\t\theight\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"human\": {\n\t\t\t\t\t\t\"name\": \"Luke Skywalker\",\n\t\t\t\t\t\t\"height\": 1.72\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\thuman(id: \"1000\") {\n\t\t\t\t\t\tname\n\t\t\t\t\t\theight(unit: FOOT)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"human\": {\n\t\t\t\t\t\t\"name\": \"Luke Skywalker\",\n\t\t\t\t\t\t\"height\": 5.6430448\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nfunc TestAliases(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tempireHero: hero(episode: EMPIRE) {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t\tjediHero: hero(episode: JEDI) {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"empireHero\": {\n\t\t\t\t\t\t\"name\": \"Luke Skywalker\"\n\t\t\t\t\t},\n\t\t\t\t\t\"jediHero\": {\n\t\t\t\t\t\t\"name\": \"R2-D2\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nfunc TestFragments(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tleftComparison: hero(episode: EMPIRE) {\n\t\t\t\t\t\t...comparisonFields\n\t\t\t\t\t\t...height\n\t\t\t\t\t}\n\t\t\t\t\trightComparison: hero(episode: JEDI) {\n\t\t\t\t\t\t...comparisonFields\n\t\t\t\t\t\t...height\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfragment comparisonFields on Character {\n\t\t\t\t\tname\n\t\t\t\t\tappearsIn\n\t\t\t\t\tfriends {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfragment height on Human {\n\t\t\t\t\theight\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"leftComparison\": {\n\t\t\t\t\t\t\"name\": \"Luke Skywalker\",\n\t\t\t\t\t\t\"appearsIn\": [\n\t\t\t\t\t\t\t\"NEWHOPE\",\n\t\t\t\t\t\t\t\"EMPIRE\",\n\t\t\t\t\t\t\t\"JEDI\"\n\t\t\t\t\t\t],\n\t\t\t\t\t\t\"friends\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Han Solo\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Leia Organa\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"C-3PO\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"R2-D2\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t],\n\t\t\t\t\t\t\"height\": 1.72\n\t\t\t\t\t},\n\t\t\t\t\t\"rightComparison\": {\n\t\t\t\t\t\t\"name\": \"R2-D2\",\n\t\t\t\t\t\t\"appearsIn\": [\n\t\t\t\t\t\t\t\"NEWHOPE\",\n\t\t\t\t\t\t\t\"EMPIRE\",\n\t\t\t\t\t\t\t\"JEDI\"\n\t\t\t\t\t\t],\n\t\t\t\t\t\t\"friends\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Luke Skywalker\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Han Solo\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Leia Organa\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nfunc TestVariables(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tquery HeroNameAndFriends($episode: Episode) {\n\t\t\t\t\thero(episode: $episode) {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tVariables: map[string]interface{}{\n\t\t\t\t\"episode\": \"JEDI\",\n\t\t\t},\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hero\": {\n\t\t\t\t\t\t\"name\": \"R2-D2\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tquery HeroNameAndFriends($episode: Episode) {\n\t\t\t\t\thero(episode: $episode) {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tVariables: map[string]interface{}{\n\t\t\t\t\"episode\": \"EMPIRE\",\n\t\t\t},\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hero\": {\n\t\t\t\t\t\t\"name\": \"Luke Skywalker\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\techo(value: String): String\n\t\t\t\t}\n\t\t\t`, &echoResolver{}),\n\t\t\tQuery: `\n\t\t\t\tquery Echo($value:String = \"default\"){\n\t\t\t\t\techo(value:$value)\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"echo\": \"default\"\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nfunc TestSkipDirective(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tquery Hero($episode: Episode, $withoutFriends: Boolean!) {\n\t\t\t\t\thero(episode: $episode) {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tfriends @skip(if: $withoutFriends) {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tVariables: map[string]interface{}{\n\t\t\t\t\"episode\":        \"JEDI\",\n\t\t\t\t\"withoutFriends\": true,\n\t\t\t},\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hero\": {\n\t\t\t\t\t\t\"name\": \"R2-D2\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tquery Hero($episode: Episode, $withoutFriends: Boolean!) {\n\t\t\t\t\thero(episode: $episode) {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tfriends @skip(if: $withoutFriends) {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tVariables: map[string]interface{}{\n\t\t\t\t\"episode\":        \"JEDI\",\n\t\t\t\t\"withoutFriends\": false,\n\t\t\t},\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hero\": {\n\t\t\t\t\t\t\"name\": \"R2-D2\",\n\t\t\t\t\t\t\"friends\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Luke Skywalker\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Han Solo\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Leia Organa\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nfunc TestIncludeDirective(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tquery Hero($episode: Episode, $withFriends: Boolean!) {\n\t\t\t\t\thero(episode: $episode) {\n\t\t\t\t\t\tname\n\t\t\t\t\t\t...friendsFragment @include(if: $withFriends)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfragment friendsFragment on Character {\n\t\t\t\t\tfriends {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tVariables: map[string]interface{}{\n\t\t\t\t\"episode\":     \"JEDI\",\n\t\t\t\t\"withFriends\": false,\n\t\t\t},\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hero\": {\n\t\t\t\t\t\t\"name\": \"R2-D2\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tquery Hero($episode: Episode, $withFriends: Boolean!) {\n\t\t\t\t\thero(episode: $episode) {\n\t\t\t\t\t\tname\n\t\t\t\t\t\t...friendsFragment @include(if: $withFriends)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfragment friendsFragment on Character {\n\t\t\t\t\tfriends {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tVariables: map[string]interface{}{\n\t\t\t\t\"episode\":     \"JEDI\",\n\t\t\t\t\"withFriends\": true,\n\t\t\t},\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hero\": {\n\t\t\t\t\t\t\"name\": \"R2-D2\",\n\t\t\t\t\t\t\"friends\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Luke Skywalker\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Han Solo\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Leia Organa\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\ntype testDeprecatedDirectiveResolver struct{}\n\nfunc (r *testDeprecatedDirectiveResolver) A() int32 {\n\treturn 0\n}\n\nfunc (r *testDeprecatedDirectiveResolver) B() int32 {\n\treturn 0\n}\n\nfunc (r *testDeprecatedDirectiveResolver) C() int32 {\n\treturn 0\n}\n\nfunc TestDeprecatedDirective(t *testing.T) {\n\tt.Parallel()\n\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\ta: Int!\n\t\t\t\t\tb: Int! @deprecated\n\t\t\t\t\tc: Int! @deprecated(reason: \"We don't like it\")\n\t\t\t\t}\n\t\t\t`, &testDeprecatedDirectiveResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\t__type(name: \"Query\") {\n\t\t\t\t\t\tfields {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t\tallFields: fields(includeDeprecated: true) {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\tisDeprecated\n\t\t\t\t\t\t\tdeprecationReason\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"__type\": {\n\t\t\t\t\t\t\"fields\": [\n\t\t\t\t\t\t\t{ \"name\": \"a\" }\n\t\t\t\t\t\t],\n\t\t\t\t\t\t\"allFields\": [\n\t\t\t\t\t\t\t{ \"name\": \"a\", \"isDeprecated\": false, \"deprecationReason\": null },\n\t\t\t\t\t\t\t{ \"name\": \"b\", \"isDeprecated\": true, \"deprecationReason\": \"No longer supported\" },\n\t\t\t\t\t\t\t{ \"name\": \"c\", \"isDeprecated\": true, \"deprecationReason\": \"We don't like it\" }\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t}\n\n\t\t\t\tenum Test {\n\t\t\t\t\tA\n\t\t\t\t\tB @deprecated\n\t\t\t\t\tC @deprecated(reason: \"We don't like it\")\n\t\t\t\t}\n\t\t\t`, &testDeprecatedDirectiveResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\t__type(name: \"Test\") {\n\t\t\t\t\t\tenumValues {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t\tallEnumValues: enumValues(includeDeprecated: true) {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\tisDeprecated\n\t\t\t\t\t\t\tdeprecationReason\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"__type\": {\n\t\t\t\t\t\t\"enumValues\": [\n\t\t\t\t\t\t\t{ \"name\": \"A\" }\n\t\t\t\t\t\t],\n\t\t\t\t\t\t\"allEnumValues\": [\n\t\t\t\t\t\t\t{ \"name\": \"A\", \"isDeprecated\": false, \"deprecationReason\": null },\n\t\t\t\t\t\t\t{ \"name\": \"B\", \"isDeprecated\": true, \"deprecationReason\": \"No longer supported\" },\n\t\t\t\t\t\t\t{ \"name\": \"C\", \"isDeprecated\": true, \"deprecationReason\": \"We don't like it\" }\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\ntype testBadEnumResolver struct{}\n\nfunc (r *testBadEnumResolver) Hero() *testBadEnumCharacterResolver {\n\treturn &testBadEnumCharacterResolver{}\n}\n\ntype testBadEnumCharacterResolver struct{}\n\nfunc (r *testBadEnumCharacterResolver) Name() string {\n\treturn \"Spock\"\n}\n\nfunc (r *testBadEnumCharacterResolver) AppearsIn() []string {\n\treturn []string{\"STAR_TREK\"}\n}\n\nfunc TestEnums(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t// Valid input enum supplied in query text\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tquery HeroForEpisode {\n\t\t\t\t\thero(episode: EMPIRE) {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hero\": {\n\t\t\t\t\t\t\"name\": \"Luke Skywalker\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t\t// Invalid input enum supplied in query text\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tquery HeroForEpisode {\n\t\t\t\t\thero(episode: WRATH_OF_KHAN) {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage:   \"Argument \\\"episode\\\" has invalid value WRATH_OF_KHAN.\\nExpected type \\\"Episode\\\", found WRATH_OF_KHAN.\",\n\t\t\t\t\tLocations: []gqlerrors.Location{{Column: 20, Line: 3}},\n\t\t\t\t\tRule:      \"ArgumentsOfCorrectType\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t// Valid input enum supplied in variables\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tquery HeroForEpisode($episode: Episode!) {\n\t\t\t\t\thero(episode: $episode) {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tVariables: map[string]interface{}{\"episode\": \"JEDI\"},\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hero\": {\n\t\t\t\t\t\t\"name\": \"R2-D2\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t\t// Invalid input enum supplied in variables\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tquery HeroForEpisode($episode: Episode!) {\n\t\t\t\t\thero(episode: $episode) {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tVariables: map[string]interface{}{\"episode\": \"FINAL_FRONTIER\"},\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage:   \"Variable \\\"episode\\\" has invalid value FINAL_FRONTIER.\\nExpected type \\\"Episode\\\", found FINAL_FRONTIER.\",\n\t\t\t\t\tLocations: []gqlerrors.Location{{Column: 26, Line: 2}},\n\t\t\t\t\tRule:      \"VariablesOfCorrectType\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t// Valid enum value in response\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tquery Hero {\n\t\t\t\t\thero {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tappearsIn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hero\": {\n\t\t\t\t\t\t\"name\": \"R2-D2\",\n\t\t\t\t\t\t\"appearsIn\": [\"NEWHOPE\",\"EMPIRE\",\"JEDI\"]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t\t// Invalid enum value in response\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\thero: Character\n\t\t\t\t}\n\n\t\t\t\tenum Episode {\n\t\t\t\t\tNEWHOPE\n\t\t\t\t\tEMPIRE\n\t\t\t\t\tJEDI\n\t\t\t\t}\n\n\t\t\t\ttype Character {\n\t\t\t\t\tname: String!\n\t\t\t\t\tappearsIn: [Episode!]!\n\t\t\t\t}\n\t\t\t`, &testBadEnumResolver{}),\n\t\t\tQuery: `\n\t\t\t\tquery Hero {\n\t\t\t\t\thero {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tappearsIn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `{\n\t\t\t\t\"hero\": null\n\t\t\t}`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage: \"Invalid value STAR_TREK.\\nExpected type Episode, found STAR_TREK.\",\n\t\t\t\t\tPath:    []interface{}{\"hero\", \"appearsIn\", 0},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t})\n}\n\nfunc TestInlineFragments(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tquery HeroForEpisode($episode: Episode!) {\n\t\t\t\t\thero(episode: $episode) {\n\t\t\t\t\t\tname\n\t\t\t\t\t\t... on Droid {\n\t\t\t\t\t\t\tprimaryFunction\n\t\t\t\t\t\t}\n\t\t\t\t\t\t... on Human {\n\t\t\t\t\t\t\theight\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tVariables: map[string]interface{}{\n\t\t\t\t\"episode\": \"JEDI\",\n\t\t\t},\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hero\": {\n\t\t\t\t\t\t\"name\": \"R2-D2\",\n\t\t\t\t\t\t\"primaryFunction\": \"Astromech\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tquery HeroForEpisode($episode: Episode!) {\n\t\t\t\t\thero(episode: $episode) {\n\t\t\t\t\t\tname\n\t\t\t\t\t\t... on Droid {\n\t\t\t\t\t\t\tprimaryFunction\n\t\t\t\t\t\t}\n\t\t\t\t\t\t... on Human {\n\t\t\t\t\t\t\theight\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tVariables: map[string]interface{}{\n\t\t\t\t\"episode\": \"EMPIRE\",\n\t\t\t},\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hero\": {\n\t\t\t\t\t\t\"name\": \"Luke Skywalker\",\n\t\t\t\t\t\t\"height\": 1.72\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tquery CharacterSearch {\n\t\t\t\t\tsearch(text: \"C-3PO\") {\n\t\t\t\t\t\t... on Character {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"search\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"name\": \"C-3PO\"\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tquery CharacterSearch {\n\t\t\t\t\thero {\n\t\t\t\t\t\t... on Character {\n\t\t\t\t\t\t\t... on Human {\n\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t... on Droid {\n\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hero\": {\n\t\t\t\t\t\t\"name\": \"R2-D2\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: socialSchema,\n\t\t\tQuery: `\n\t\t\t\tquery {\n\t\t\t\t\tadmin(id: \"0x01\") {\n\t\t\t\t\t\t... on User {\n\t\t\t\t\t\t\temail\n\t\t\t\t\t\t}\n\t\t\t\t\t\t... on Person {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"admin\": {\n\t\t\t\t\t\t\"email\": \"Albus@hogwarts.com\",\n\t\t\t\t\t\t\"name\": \"Albus Dumbledore\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nfunc TestTypeName(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tsearch(text: \"an\") {\n\t\t\t\t\t\t__typename\n\t\t\t\t\t\t... on Human {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t\t... on Droid {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t\t... on Starship {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"search\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"__typename\": \"Human\",\n\t\t\t\t\t\t\t\"name\": \"Han Solo\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"__typename\": \"Human\",\n\t\t\t\t\t\t\t\"name\": \"Leia Organa\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"__typename\": \"Starship\",\n\t\t\t\t\t\t\t\"name\": \"TIE Advanced x1\"\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\thuman(id: \"1000\") {\n\t\t\t\t\t\t__typename\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"human\": {\n\t\t\t\t\t\t\"__typename\": \"Human\",\n\t\t\t\t\t\t\"name\": \"Luke Skywalker\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\thero {\n\t\t\t\t\t\t__typename\n\t\t\t\t\t\tname\n\t\t\t\t\t\t... on Character {\n\t\t\t\t\t\t\t...Droid\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t__typename\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfragment Droid on Droid {\n\t\t\t\t\tname\n\t\t\t\t\t__typename\n\t\t\t\t}\t\t\t  \n\t\t\t`,\n\t\t\tRawResponse:    true,\n\t\t\tExpectedResult: `{\"hero\":{\"__typename\":\"Droid\",\"name\":\"R2-D2\"}}`,\n\t\t},\n\t})\n}\n\nfunc TestConnections(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\thero {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tfriendsConnection {\n\t\t\t\t\t\t\ttotalCount\n\t\t\t\t\t\t\tpageInfo {\n\t\t\t\t\t\t\t\tstartCursor\n\t\t\t\t\t\t\t\tendCursor\n\t\t\t\t\t\t\t\thasNextPage\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tedges {\n\t\t\t\t\t\t\t\tcursor\n\t\t\t\t\t\t\t\tnode {\n\t\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hero\": {\n\t\t\t\t\t\t\"name\": \"R2-D2\",\n\t\t\t\t\t\t\"friendsConnection\": {\n\t\t\t\t\t\t\t\"totalCount\": 3,\n\t\t\t\t\t\t\t\"pageInfo\": {\n\t\t\t\t\t\t\t\t\"startCursor\": \"Y3Vyc29yMQ==\",\n\t\t\t\t\t\t\t\t\"endCursor\": \"Y3Vyc29yMw==\",\n\t\t\t\t\t\t\t\t\"hasNextPage\": false\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"edges\": [\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\"cursor\": \"Y3Vyc29yMQ==\",\n\t\t\t\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\t\t\t\"name\": \"Luke Skywalker\"\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\"cursor\": \"Y3Vyc29yMg==\",\n\t\t\t\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\t\t\t\"name\": \"Han Solo\"\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\"cursor\": \"Y3Vyc29yMw==\",\n\t\t\t\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\t\t\t\"name\": \"Leia Organa\"\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\thero {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tfriendsConnection(first: 1, after: \"Y3Vyc29yMQ==\") {\n\t\t\t\t\t\t\ttotalCount\n\t\t\t\t\t\t\tpageInfo {\n\t\t\t\t\t\t\t\tstartCursor\n\t\t\t\t\t\t\t\tendCursor\n\t\t\t\t\t\t\t\thasNextPage\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tedges {\n\t\t\t\t\t\t\t\tcursor\n\t\t\t\t\t\t\t\tnode {\n\t\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tmoreFriends: hero {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tfriendsConnection(first: 1, after: \"Y3Vyc29yMg==\") {\n\t\t\t\t\t\t\ttotalCount\n\t\t\t\t\t\t\tpageInfo {\n\t\t\t\t\t\t\t\tstartCursor\n\t\t\t\t\t\t\t\tendCursor\n\t\t\t\t\t\t\t\thasNextPage\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tedges {\n\t\t\t\t\t\t\t\tcursor\n\t\t\t\t\t\t\t\tnode {\n\t\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hero\": {\n\t\t\t\t\t\t\"name\": \"R2-D2\",\n\t\t\t\t\t\t\"friendsConnection\": {\n\t\t\t\t\t\t\t\"totalCount\": 3,\n\t\t\t\t\t\t\t\"pageInfo\": {\n\t\t\t\t\t\t\t\t\"startCursor\": \"Y3Vyc29yMg==\",\n\t\t\t\t\t\t\t\t\"endCursor\": \"Y3Vyc29yMg==\",\n\t\t\t\t\t\t\t\t\"hasNextPage\": true\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"edges\": [\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\"cursor\": \"Y3Vyc29yMg==\",\n\t\t\t\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\t\t\t\"name\": \"Han Solo\"\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t\"moreFriends\": {\n\t\t\t\t\t\t\"name\": \"R2-D2\",\n\t\t\t\t\t\t\"friendsConnection\": {\n\t\t\t\t\t\t\t\"totalCount\": 3,\n\t\t\t\t\t\t\t\"pageInfo\": {\n\t\t\t\t\t\t\t\t\"startCursor\": \"Y3Vyc29yMw==\",\n\t\t\t\t\t\t\t\t\"endCursor\": \"Y3Vyc29yMw==\",\n\t\t\t\t\t\t\t\t\"hasNextPage\": false\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"edges\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"cursor\": \"Y3Vyc29yMw==\",\n\t\t\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\t\t\"name\": \"Leia Organa\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nfunc TestMutation(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\treviews(episode: JEDI) {\n\t\t\t\t\t\tstars\n\t\t\t\t\t\tcommentary\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"reviews\": []\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tmutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) {\n\t\t\t\t\tcreateReview(episode: $ep, review: $review) {\n\t\t\t\t\t\tstars\n\t\t\t\t\t\tcommentary\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tVariables: map[string]interface{}{\n\t\t\t\t\"ep\": \"JEDI\",\n\t\t\t\t\"review\": map[string]interface{}{\n\t\t\t\t\t\"stars\":      5,\n\t\t\t\t\t\"commentary\": \"This is a great movie!\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"createReview\": {\n\t\t\t\t\t\t\"stars\": 5,\n\t\t\t\t\t\t\"commentary\": \"This is a great movie!\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\tmutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) {\n\t\t\t\t\tcreateReview(episode: $ep, review: $review) {\n\t\t\t\t\t\tstars\n\t\t\t\t\t\tcommentary\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tVariables: map[string]interface{}{\n\t\t\t\t\"ep\": \"EMPIRE\",\n\t\t\t\t\"review\": map[string]interface{}{\n\t\t\t\t\t\"stars\": float64(4),\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"createReview\": {\n\t\t\t\t\t\t\"stars\": 4,\n\t\t\t\t\t\t\"commentary\": null\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\treviews(episode: JEDI) {\n\t\t\t\t\t\tstars\n\t\t\t\t\t\tcommentary\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"reviews\": [{\n\t\t\t\t\t\t\"stars\": 5,\n\t\t\t\t\t\t\"commentary\": \"This is a great movie!\"\n\t\t\t\t\t}]\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nfunc TestIntrospection(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\t__schema {\n\t\t\t\t\t\ttypes {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"__schema\": {\n\t\t\t\t\t\t\"types\": [\n\t\t\t\t\t\t\t{ \"name\": \"Boolean\" },\n\t\t\t\t\t\t\t{ \"name\": \"Character\" },\n\t\t\t\t\t\t\t{ \"name\": \"Droid\" },\n\t\t\t\t\t\t\t{ \"name\": \"Episode\" },\n\t\t\t\t\t\t\t{ \"name\": \"Float\" },\n\t\t\t\t\t\t\t{ \"name\": \"FriendsConnection\" },\n\t\t\t\t\t\t\t{ \"name\": \"FriendsEdge\" },\n\t\t\t\t\t\t\t{ \"name\": \"Human\" },\n\t\t\t\t\t\t\t{ \"name\": \"ID\" },\n\t\t\t\t\t\t\t{ \"name\": \"Int\" },\n\t\t\t\t\t\t\t{ \"name\": \"LengthUnit\" },\n\t\t\t\t\t\t\t{ \"name\": \"Mutation\" },\n\t\t\t\t\t\t\t{ \"name\": \"PageInfo\" },\n\t\t\t\t\t\t\t{ \"name\": \"Query\" },\n\t\t\t\t\t\t\t{ \"name\": \"Review\" },\n\t\t\t\t\t\t\t{ \"name\": \"ReviewInput\" },\n\t\t\t\t\t\t\t{ \"name\": \"SearchResult\" },\n\t\t\t\t\t\t\t{ \"name\": \"Starship\" },\n\t\t\t\t\t\t\t{ \"name\": \"String\" },\n\t\t\t\t\t\t\t{ \"name\": \"__Directive\" },\n\t\t\t\t\t\t\t{ \"name\": \"__DirectiveLocation\" },\n\t\t\t\t\t\t\t{ \"name\": \"__EnumValue\" },\n\t\t\t\t\t\t\t{ \"name\": \"__Field\" },\n\t\t\t\t\t\t\t{ \"name\": \"__InputValue\" },\n\t\t\t\t\t\t\t{ \"name\": \"__Schema\" },\n\t\t\t\t\t\t\t{ \"name\": \"__Type\" },\n\t\t\t\t\t\t\t{ \"name\": \"__TypeKind\" }\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\t__schema {\n\t\t\t\t\t\tqueryType {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"__schema\": {\n\t\t\t\t\t\t\"queryType\": {\n\t\t\t\t\t\t\t\"name\": \"Query\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\ta: __type(name: \"Droid\") {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tkind\n\t\t\t\t\t\tinterfaces {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpossibleTypes {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tb: __type(name: \"Character\") {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tkind\n\t\t\t\t\t\tinterfaces {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpossibleTypes {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tc: __type(name: \"SearchResult\") {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tkind\n\t\t\t\t\t\tinterfaces {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpossibleTypes {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"a\": {\n\t\t\t\t\t\t\"name\": \"Droid\",\n\t\t\t\t\t\t\"kind\": \"OBJECT\",\n\t\t\t\t\t\t\"interfaces\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Character\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t],\n\t\t\t\t\t\t\"possibleTypes\": null\n\t\t\t\t\t},\n\t\t\t\t\t\"b\": {\n\t\t\t\t\t\t\"name\": \"Character\",\n\t\t\t\t\t\t\"kind\": \"INTERFACE\",\n\t\t\t\t\t\t\"interfaces\": null,\n\t\t\t\t\t\t\"possibleTypes\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Human\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Droid\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\t\"c\": {\n\t\t\t\t\t\t\"name\": \"SearchResult\",\n\t\t\t\t\t\t\"kind\": \"UNION\",\n\t\t\t\t\t\t\"interfaces\": null,\n\t\t\t\t\t\t\"possibleTypes\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Human\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Droid\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"Starship\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\t__type(name: \"Droid\") {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tfields {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\targs {\n\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t\ttype {\n\t\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdefaultValue\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttype {\n\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t\tkind\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"__type\": {\n\t\t\t\t\t\t\"name\": \"Droid\",\n\t\t\t\t\t\t\"fields\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"id\",\n\t\t\t\t\t\t\t\t\"args\": [],\n\t\t\t\t\t\t\t\t\"type\": {\n\t\t\t\t\t\t\t\t\t\"name\": null,\n\t\t\t\t\t\t\t\t\t\"kind\": \"NON_NULL\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"name\",\n\t\t\t\t\t\t\t\t\"args\": [],\n\t\t\t\t\t\t\t\t\"type\": {\n\t\t\t\t\t\t\t\t\t\"name\": null,\n\t\t\t\t\t\t\t\t\t\"kind\": \"NON_NULL\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"friends\",\n\t\t\t\t\t\t\t\t\"args\": [],\n\t\t\t\t\t\t\t\t\"type\": {\n\t\t\t\t\t\t\t\t\t\"name\": null,\n\t\t\t\t\t\t\t\t\t\"kind\": \"LIST\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"friendsConnection\",\n\t\t\t\t\t\t\t\t\"args\": [\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\"name\": \"first\",\n\t\t\t\t\t\t\t\t\t\t\"type\": {\n\t\t\t\t\t\t\t\t\t\t\t\"name\": \"Int\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\"defaultValue\": null\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\"name\": \"after\",\n\t\t\t\t\t\t\t\t\t\t\"type\": {\n\t\t\t\t\t\t\t\t\t\t\t\"name\": \"ID\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\"defaultValue\": null\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\"type\": {\n\t\t\t\t\t\t\t\t\t\"name\": null,\n\t\t\t\t\t\t\t\t\t\"kind\": \"NON_NULL\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"appearsIn\",\n\t\t\t\t\t\t\t\t\"args\": [],\n\t\t\t\t\t\t\t\t\"type\": {\n\t\t\t\t\t\t\t\t\t\"name\": null,\n\t\t\t\t\t\t\t\t\t\"kind\": \"NON_NULL\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"primaryFunction\",\n\t\t\t\t\t\t\t\t\"args\": [],\n\t\t\t\t\t\t\t\t\"type\": {\n\t\t\t\t\t\t\t\t\t\"name\": \"String\",\n\t\t\t\t\t\t\t\t\t\"kind\": \"SCALAR\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\t__type(name: \"Episode\") {\n\t\t\t\t\t\tenumValues {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"__type\": {\n\t\t\t\t\t\t\"enumValues\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"NEWHOPE\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"EMPIRE\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"name\": \"JEDI\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\t__schema {\n\t\t\t\t\t\tdirectives {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\tdescription\n\t\t\t\t\t\t\tlocations\n\t\t\t\t\t\t\targs {\n\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t\tdescription\n\t\t\t\t\t\t\t\ttype {\n\t\t\t\t\t\t\t\t\tkind\n\t\t\t\t\t\t\t\t\tofType {\n\t\t\t\t\t\t\t\t\t\tkind\n\t\t\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\t\"__schema\": {\n\t\t\t\t\t\t\t\"directives\": [\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\"name\": \"deprecated\",\n\t\t\t\t\t\t\t\t\t\"description\": \"Marks an element of a GraphQL schema as no longer supported.\",\n\t\t\t\t\t\t\t\t\t\"locations\": [\n\t\t\t\t\t\t\t\t\t\t\"FIELD_DEFINITION\",\n\t\t\t\t\t\t\t\t\t\t\"ENUM_VALUE\"\n\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\t\"args\": [\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\"name\": \"reason\",\n\t\t\t\t\t\t\t\t\t\t\t\"description\": \"Explains why this element was deprecated, usually also including a suggestion\\nfor how to access supported similar data. Formatted in\\n[Markdown](https://daringfireball.net/projects/markdown/).\",\n\t\t\t\t\t\t\t\t\t\t\t\"type\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\"kind\": \"SCALAR\",\n\t\t\t\t\t\t\t\t\t\t\t\t\"ofType\": null\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\"name\": \"include\",\n\t\t\t\t\t\t\t\t\t\"description\": \"Directs the executor to include this field or fragment only when the ` + \"`\" + `if` + \"`\" + ` argument is true.\",\n\t\t\t\t\t\t\t\t\t\"locations\": [\n\t\t\t\t\t\t\t\t\t\t\"FIELD\",\n\t\t\t\t\t\t\t\t\t\t\"FRAGMENT_SPREAD\",\n\t\t\t\t\t\t\t\t\t\t\"INLINE_FRAGMENT\"\n\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\t\"args\": [\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\"name\": \"if\",\n\t\t\t\t\t\t\t\t\t\t\t\"description\": \"Included when true.\",\n\t\t\t\t\t\t\t\t\t\t\t\"type\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\"kind\": \"NON_NULL\",\n\t\t\t\t\t\t\t\t\t\t\t\t\"ofType\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"kind\": \"SCALAR\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"name\": \"Boolean\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\"name\": \"skip\",\n\t\t\t\t\t\t\t\t\t\"description\": \"Directs the executor to skip this field or fragment when the ` + \"`\" + `if` + \"`\" + ` argument is true.\",\n\t\t\t\t\t\t\t\t\t\"locations\": [\n\t\t\t\t\t\t\t\t\t\t\"FIELD\",\n\t\t\t\t\t\t\t\t\t\t\"FRAGMENT_SPREAD\",\n\t\t\t\t\t\t\t\t\t\t\"INLINE_FRAGMENT\"\n\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\t\"args\": [\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\"name\": \"if\",\n\t\t\t\t\t\t\t\t\t\t\t\"description\": \"Skipped when true.\",\n\t\t\t\t\t\t\t\t\t\t\t\"type\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\"kind\": \"NON_NULL\",\n\t\t\t\t\t\t\t\t\t\t\t\t\"ofType\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"kind\": \"SCALAR\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"name\": \"Boolean\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nvar starwarsSchemaNoIntrospection = graphql.MustParseSchema(starwars.Schema, &starwars.Resolver{}, []graphql.SchemaOpt{graphql.DisableIntrospection()}...)\n\nfunc TestIntrospectionDisableIntrospection(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: starwarsSchemaNoIntrospection,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\t__schema {\n\t\t\t\t\t\ttypes {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchemaNoIntrospection,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\t__schema {\n\t\t\t\t\t\tqueryType {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchemaNoIntrospection,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\ta: __type(name: \"Droid\") {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tkind\n\t\t\t\t\t\tinterfaces {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpossibleTypes {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tb: __type(name: \"Character\") {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tkind\n\t\t\t\t\t\tinterfaces {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpossibleTypes {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tc: __type(name: \"SearchResult\") {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tkind\n\t\t\t\t\t\tinterfaces {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpossibleTypes {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchemaNoIntrospection,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\t__type(name: \"Droid\") {\n\t\t\t\t\t\tname\n\t\t\t\t\t\tfields {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\targs {\n\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t\ttype {\n\t\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdefaultValue\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttype {\n\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t\tkind\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchemaNoIntrospection,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\t__type(name: \"Episode\") {\n\t\t\t\t\t\tenumValues {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchemaNoIntrospection,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\t__schema {\n\t\t\t\t\t\tdirectives {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\tdescription\n\t\t\t\t\t\t\tlocations\n\t\t\t\t\t\t\targs {\n\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t\tdescription\n\t\t\t\t\t\t\t\ttype {\n\t\t\t\t\t\t\t\t\tkind\n\t\t\t\t\t\t\t\t\tofType {\n\t\t\t\t\t\t\t\t\t\tkind\n\t\t\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\n\t\t{\n\t\t\tSchema: starwarsSchemaNoIntrospection,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tsearch(text: \"an\") {\n\t\t\t\t\t\t__typename\n\t\t\t\t\t\t... on Human {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t\t... on Droid {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t\t... on Starship {\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"search\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"__typename\": \"Human\",\n\t\t\t\t\t\t\t\"name\": \"Han Solo\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"__typename\": \"Human\",\n\t\t\t\t\t\t\t\"name\": \"Leia Organa\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"__typename\": \"Starship\",\n\t\t\t\t\t\t\t\"name\": \"TIE Advanced x1\"\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nfunc TestMutationOrder(t *testing.T) {\n\tt.Parallel()\n\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t\tmutation: Mutation\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\ttheNumber: Int!\n\t\t\t\t}\n\n\t\t\t\ttype Mutation {\n\t\t\t\t\tchangeTheNumber(newNumber: Int!): Query\n\t\t\t\t}\n\t\t\t`, &theNumberResolver{}),\n\t\t\tQuery: `\n\t\t\t\tmutation {\n\t\t\t\t\tfirst: changeTheNumber(newNumber: 1) {\n\t\t\t\t\t\ttheNumber\n\t\t\t\t\t}\n\t\t\t\t\tsecond: changeTheNumber(newNumber: 3) {\n\t\t\t\t\t\ttheNumber\n\t\t\t\t\t}\n\t\t\t\t\tthird: changeTheNumber(newNumber: 2) {\n\t\t\t\t\t\ttheNumber\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"first\": {\n\t\t\t\t\t\t\"theNumber\": 1\n\t\t\t\t\t},\n\t\t\t\t\t\"second\": {\n\t\t\t\t\t\t\"theNumber\": 3\n\t\t\t\t\t},\n\t\t\t\t\t\"third\": {\n\t\t\t\t\t\t\"theNumber\": 2\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nfunc TestTime(t *testing.T) {\n\tt.Parallel()\n\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\taddHour(time: Time = \"2001-02-03T04:05:06Z\"): Time!\n\t\t\t\t}\n\n\t\t\t\tscalar Time\n\t\t\t`, &timeResolver{}),\n\t\t\tQuery: `\n\t\t\t\tquery($t: Time!) {\n\t\t\t\t\ta: addHour(time: $t)\n\t\t\t\t\tb: addHour\n\t\t\t\t}\n\t\t\t`,\n\t\t\tVariables: map[string]interface{}{\n\t\t\t\t\"t\": time.Date(2000, 2, 3, 4, 5, 6, 0, time.UTC),\n\t\t\t},\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"a\": \"2000-02-03T05:05:06Z\",\n\t\t\t\t\t\"b\": \"2001-02-03T05:05:06Z\"\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\ntype resolverWithUnexportedMethod struct{}\n\nfunc (r *resolverWithUnexportedMethod) changeTheNumber(args struct{ NewNumber int32 }) int32 {\n\treturn args.NewNumber\n}\n\nfunc TestUnexportedMethod(t *testing.T) {\n\tt.Parallel()\n\n\t_, err := graphql.ParseSchema(`\n\t\tschema {\n\t\t\tmutation: Mutation\n\t\t}\n\n\t\ttype Mutation {\n\t\t\tchangeTheNumber(newNumber: Int!): Int!\n\t\t}\n\t`, &resolverWithUnexportedMethod{})\n\tif err == nil {\n\t\tt.Error(\"error expected\")\n\t}\n}\n\ntype resolverWithUnexportedField struct{}\n\nfunc (r *resolverWithUnexportedField) ChangeTheNumber(args struct{ newNumber int32 }) int32 {\n\treturn args.newNumber\n}\n\nfunc TestUnexportedField(t *testing.T) {\n\tt.Parallel()\n\n\t_, err := graphql.ParseSchema(`\n\t\tschema {\n\t\t\tmutation: Mutation\n\t\t}\n\n\t\ttype Mutation {\n\t\t\tchangeTheNumber(newNumber: Int!): Int!\n\t\t}\n\t`, &resolverWithUnexportedField{})\n\tif err == nil {\n\t\tt.Error(\"error expected\")\n\t}\n}\n\ntype StringEnum string\n\nconst (\n\tEnumOption1 StringEnum = \"Option1\"\n\tEnumOption2 StringEnum = \"Option2\"\n)\n\ntype IntEnum int\n\nconst (\n\tIntEnum0 IntEnum = iota\n\tIntEnum1\n)\n\nfunc (e IntEnum) String() string {\n\tswitch int(e) {\n\tcase 0:\n\t\treturn \"Int0\"\n\tcase 1:\n\t\treturn \"Int1\"\n\tdefault:\n\t\treturn \"IntN\"\n\t}\n}\n\nfunc (IntEnum) ImplementsGraphQLType(name string) bool {\n\treturn name == \"IntEnum\"\n}\n\nfunc (e *IntEnum) UnmarshalGraphQL(input interface{}) error {\n\tif str, ok := input.(string); ok {\n\t\tswitch str {\n\t\tcase \"Int0\":\n\t\t\t*e = IntEnum(0)\n\t\tcase \"Int1\":\n\t\t\t*e = IntEnum(1)\n\t\tdefault:\n\t\t\t*e = IntEnum(-1)\n\t\t}\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"wrong type for IntEnum: %T\", input)\n}\n\ntype inputResolver struct{}\n\nfunc (r *inputResolver) Int(args struct{ Value int32 }) int32 {\n\treturn args.Value\n}\n\nfunc (r *inputResolver) Float(args struct{ Value float64 }) float64 {\n\treturn args.Value\n}\n\nfunc (r *inputResolver) String(args struct{ Value string }) string {\n\treturn args.Value\n}\n\nfunc (r *inputResolver) Boolean(args struct{ Value bool }) bool {\n\treturn args.Value\n}\n\nfunc (r *inputResolver) Nullable(args struct{ Value *int32 }) *int32 {\n\treturn args.Value\n}\n\nfunc (r *inputResolver) List(args struct{ Value []*struct{ V int32 } }) []int32 {\n\tl := make([]int32, len(args.Value))\n\tfor i, entry := range args.Value {\n\t\tl[i] = entry.V\n\t}\n\treturn l\n}\n\nfunc (r *inputResolver) NullableList(args struct{ Value *[]*struct{ V int32 } }) *[]*int32 {\n\tif args.Value == nil {\n\t\treturn nil\n\t}\n\tl := make([]*int32, len(*args.Value))\n\tfor i, entry := range *args.Value {\n\t\tif entry != nil {\n\t\t\tl[i] = &entry.V\n\t\t}\n\t}\n\treturn &l\n}\n\nfunc (r *inputResolver) StringEnumValue(args struct{ Value string }) string {\n\treturn args.Value\n}\n\nfunc (r *inputResolver) NullableStringEnumValue(args struct{ Value *string }) *string {\n\treturn args.Value\n}\n\nfunc (r *inputResolver) StringEnum(args struct{ Value StringEnum }) StringEnum {\n\treturn args.Value\n}\n\nfunc (r *inputResolver) NullableStringEnum(args struct{ Value *StringEnum }) *StringEnum {\n\treturn args.Value\n}\n\nfunc (r *inputResolver) IntEnumValue(args struct{ Value string }) string {\n\treturn args.Value\n}\n\nfunc (r *inputResolver) NullableIntEnumValue(args struct{ Value *string }) *string {\n\treturn args.Value\n}\n\nfunc (r *inputResolver) IntEnum(args struct{ Value IntEnum }) IntEnum {\n\treturn args.Value\n}\n\nfunc (r *inputResolver) NullableIntEnum(args struct{ Value *IntEnum }) *IntEnum {\n\treturn args.Value\n}\n\ntype recursive struct {\n\tNext *recursive\n}\n\nfunc (r *inputResolver) Recursive(args struct{ Value *recursive }) int32 {\n\tn := int32(0)\n\tv := args.Value\n\tfor v != nil {\n\t\tv = v.Next\n\t\tn++\n\t}\n\treturn n\n}\n\nfunc (r *inputResolver) ID(args struct{ Value graphql.ID }) graphql.ID {\n\treturn args.Value\n}\n\nfunc TestInput(t *testing.T) {\n\tt.Parallel()\n\n\tcoercionSchema := graphql.MustParseSchema(`\n\t\tschema {\n\t\t\tquery: Query\n\t\t}\n\n\t\ttype Query {\n\t\t\tint(value: Int!): Int!\n\t\t\tfloat(value: Float!): Float!\n\t\t\tstring(value: String!): String!\n\t\t\tboolean(value: Boolean!): Boolean!\n\t\t\tnullable(value: Int): Int\n\t\t\tlist(value: [Input!]!): [Int!]!\n\t\t\tnullableList(value: [Input]): [Int]\n\t\t\tstringEnumValue(value: StringEnum!): StringEnum!\n\t\t\tnullableStringEnumValue(value: StringEnum): StringEnum\n\t\t\tstringEnum(value: StringEnum!): StringEnum!\n\t\t\tnullableStringEnum(value: StringEnum): StringEnum\n\t\t\tintEnumValue(value: IntEnum!): IntEnum!\n\t\t\tnullableIntEnumValue(value: IntEnum): IntEnum\n\t\t\tintEnum(value: IntEnum!): IntEnum!\n\t\t\tnullableIntEnum(value: IntEnum): IntEnum\n\t\t\trecursive(value: RecursiveInput!): Int!\n\t\t\tid(value: ID!): ID!\n\t\t}\n\n\t\tinput Input {\n\t\t\tv: Int!\n\t\t}\n\n\t\tinput RecursiveInput {\n\t\t\tnext: RecursiveInput\n\t\t}\n\n\t\tenum StringEnum {\n\t\t\tOption1\n\t\t\tOption2\n\t\t}\n\n\t\tenum IntEnum {\n\t\t\tInt0\n\t\t\tInt1\n\t\t}\n\t`, &inputResolver{})\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: coercionSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tint(value: 42)\n\t\t\t\t\tfloat1: float(value: 42)\n\t\t\t\t\tfloat2: float(value: 42.5)\n\t\t\t\t\tstring(value: \"foo\")\n\t\t\t\t\tboolean(value: true)\n\t\t\t\t\tnullable1: nullable(value: 42)\n\t\t\t\t\tnullable2: nullable(value: null)\n\t\t\t\t\tlist1: list(value: [{v: 41}, {v: 42}, {v: 43}])\n\t\t\t\t\tlist2: list(value: {v: 42})\n\t\t\t\t\tnullableList1: nullableList(value: [{v: 41}, null, {v: 43}])\n\t\t\t\t\tnullableList2: nullableList(value: null)\n\t\t\t\t\tstringEnumValue(value: Option1)\n\t\t\t\t\tnullableStringEnumValue1: nullableStringEnum(value: Option1)\n\t\t\t\t\tnullableStringEnumValue2: nullableStringEnum(value: null)\n\t\t\t\t\tstringEnum(value: Option2)\n\t\t\t\t\tnullableStringEnum1: nullableStringEnum(value: Option2)\n\t\t\t\t\tnullableStringEnum2: nullableStringEnum(value: null)\n\t\t\t\t\tintEnumValue(value: Int1)\n\t\t\t\t\tnullableIntEnumValue1: nullableIntEnumValue(value: Int1)\n\t\t\t\t\tnullableIntEnumValue2: nullableIntEnumValue(value: null)\n\t\t\t\t\tintEnum(value: Int1)\n\t\t\t\t\tnullableIntEnum1: nullableIntEnum(value: Int1)\n\t\t\t\t\tnullableIntEnum2: nullableIntEnum(value: null)\n\t\t\t\t\trecursive(value: {next: {next: {}}})\n\t\t\t\t\tintID: id(value: 1234)\n\t\t\t\t\tstrID: id(value: \"1234\")\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"int\": 42,\n\t\t\t\t\t\"float1\": 42,\n\t\t\t\t\t\"float2\": 42.5,\n\t\t\t\t\t\"string\": \"foo\",\n\t\t\t\t\t\"boolean\": true,\n\t\t\t\t\t\"nullable1\": 42,\n\t\t\t\t\t\"nullable2\": null,\n\t\t\t\t\t\"list1\": [41, 42, 43],\n\t\t\t\t\t\"list2\": [42],\n\t\t\t\t\t\"nullableList1\": [41, null, 43],\n\t\t\t\t\t\"nullableList2\": null,\n\t\t\t\t\t\"stringEnumValue\": \"Option1\",\n\t\t\t\t\t\"nullableStringEnumValue1\": \"Option1\",\n\t\t\t\t\t\"nullableStringEnumValue2\": null,\n\t\t\t\t\t\"stringEnum\": \"Option2\",\n\t\t\t\t\t\"nullableStringEnum1\": \"Option2\",\n\t\t\t\t\t\"nullableStringEnum2\": null,\n\t\t\t\t\t\"intEnumValue\": \"Int1\",\n\t\t\t\t\t\"nullableIntEnumValue1\": \"Int1\",\n\t\t\t\t\t\"nullableIntEnumValue2\": null,\n\t\t\t\t\t\"intEnum\": \"Int1\",\n\t\t\t\t\t\"nullableIntEnum1\": \"Int1\",\n\t\t\t\t\t\"nullableIntEnum2\": null,\n\t\t\t\t\t\"recursive\": 3,\n\t\t\t\t\t\"intID\": \"1234\",\n\t\t\t\t\t\"strID\": \"1234\"\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\ntype inputArgumentsHello struct{}\n\ntype inputArgumentsScalarMismatch1 struct{}\n\ntype inputArgumentsScalarMismatch2 struct{}\n\ntype inputArgumentsObjectMismatch1 struct{}\n\ntype inputArgumentsObjectMismatch2 struct{}\n\ntype inputArgumentsObjectMismatch3 struct{}\n\ntype fieldNameMismatch struct{}\n\ntype helloInput struct {\n\tName string\n}\n\ntype helloOutput struct {\n\tName string\n}\n\nfunc (*fieldNameMismatch) Hello() helloOutput {\n\treturn helloOutput{}\n}\n\ntype helloInputMismatch struct {\n\tWorld string\n}\n\nfunc (r *inputArgumentsHello) Hello(args struct{ Input *helloInput }) string {\n\treturn \"Hello \" + args.Input.Name + \"!\"\n}\n\nfunc (r *inputArgumentsScalarMismatch1) Hello(name string) string {\n\treturn \"Hello \" + name + \"!\"\n}\n\nfunc (r *inputArgumentsScalarMismatch2) Hello(args struct{ World string }) string {\n\treturn \"Hello \" + args.World + \"!\"\n}\n\nfunc (r *inputArgumentsObjectMismatch1) Hello(in helloInput) string {\n\treturn \"Hello \" + in.Name + \"!\"\n}\n\nfunc (r *inputArgumentsObjectMismatch2) Hello(args struct{ Input *helloInputMismatch }) string {\n\treturn \"Hello \" + args.Input.World + \"!\"\n}\n\nfunc (r *inputArgumentsObjectMismatch3) Hello(args struct{ Input *struct{ Thing string } }) string {\n\treturn \"Hello \" + args.Input.Thing + \"!\"\n}\n\nfunc TestInputArguments_failSchemaParsing(t *testing.T) {\n\ttype args struct {\n\t\tResolver interface{}\n\t\tSchema   string\n\t\tOpts     []graphql.SchemaOpt\n\t}\n\ttype want struct {\n\t\tError string\n\t}\n\ttestTable := map[string]struct {\n\t\tArgs args\n\t\tWant want\n\t}{\n\t\t\"Non-input type used with field arguments\": {\n\t\t\tArgs: args{\n\t\t\t\tResolver: &inputArgumentsHello{},\n\t\t\t\tSchema: `\n\t\t\t\t\tschema {\n\t\t\t\t\t\tquery: Query\n\t\t\t\t\t}\n\t\t\t\t\ttype Query {\n\t\t\t\t\t\thello(input: HelloInput): String!\n\t\t\t\t\t}\n\t\t\t\t\ttype HelloInput {\n\t\t\t\t\t\tname: String\n\t\t\t\t\t}\n\t\t\t\t`,\n\t\t\t},\n\t\t\tWant: want{Error: \"field \\\"Input\\\": type of kind OBJECT can not be used as input\\n\\tused by (*graphql_test.inputArgumentsHello).Hello\"},\n\t\t},\n\t\t\"Missing Args Wrapper for scalar input\": {\n\t\t\tArgs: args{\n\t\t\t\tResolver: &inputArgumentsScalarMismatch1{},\n\t\t\t\tSchema: `\n\t\t\t\t\tschema {\n\t\t\t\t\t\tquery: Query\n\t\t\t\t\t}\n\t\t\t\t\ttype Query {\n\t\t\t\t\t\thello(name: String): String!\n\t\t\t\t\t}\n\t\t\t\t\tinput HelloInput {\n\t\t\t\t\t\tname: String\n\t\t\t\t\t}\n\t\t\t\t`,\n\t\t\t},\n\t\t\tWant: want{Error: \"expected struct or pointer to struct, got string (hint: missing `args struct { ... }` wrapper for field arguments?)\\n\\tused by (*graphql_test.inputArgumentsScalarMismatch1).Hello\"},\n\t\t},\n\t\t\"Mismatching field name for scalar input\": {\n\t\t\tArgs: args{\n\t\t\t\tResolver: &inputArgumentsScalarMismatch2{},\n\t\t\t\tSchema: `\n\t\t\t\t\tschema {\n\t\t\t\t\t\tquery: Query\n\t\t\t\t\t}\n\t\t\t\t\ttype Query {\n\t\t\t\t\t\thello(name: String): String!\n\t\t\t\t\t}\n\t\t\t\t`,\n\t\t\t},\n\t\t\tWant: want{Error: \"struct { World string } does not define field \\\"name\\\" (hint: missing `args struct { ... }` wrapper for field arguments, or missing field on input struct)\\n\\tused by (*graphql_test.inputArgumentsScalarMismatch2).Hello\"},\n\t\t},\n\t\t\"Missing Args Wrapper for Input type\": {\n\t\t\tArgs: args{\n\t\t\t\tResolver: &inputArgumentsObjectMismatch1{},\n\t\t\t\tSchema: `\n\t\t\t\t\tschema {\n\t\t\t\t\t\tquery: Query\n\t\t\t\t\t}\n\t\t\t\t\ttype Query {\n\t\t\t\t\t\thello(input: HelloInput): String!\n\t\t\t\t\t}\n\t\t\t\t\tinput HelloInput {\n\t\t\t\t\t\tname: String\n\t\t\t\t\t}\n\t\t\t\t`,\n\t\t\t},\n\t\t\tWant: want{Error: \"graphql_test.helloInput does not define field \\\"input\\\" (hint: missing `args struct { ... }` wrapper for field arguments, or missing field on input struct)\\n\\tused by (*graphql_test.inputArgumentsObjectMismatch1).Hello\"},\n\t\t},\n\t\t\"Input struct missing field\": {\n\t\t\tArgs: args{\n\t\t\t\tResolver: &inputArgumentsObjectMismatch2{},\n\t\t\t\tSchema: `\n\t\t\t\t\tschema {\n\t\t\t\t\t\tquery: Query\n\t\t\t\t\t}\n\t\t\t\t\ttype Query {\n\t\t\t\t\t\thello(input: HelloInput): String!\n\t\t\t\t\t}\n\t\t\t\t\tinput HelloInput {\n\t\t\t\t\t\tname: String\n\t\t\t\t\t}\n\t\t\t\t`,\n\t\t\t},\n\t\t\tWant: want{Error: \"field \\\"Input\\\": *graphql_test.helloInputMismatch does not define field \\\"name\\\" (hint: missing `args struct { ... }` wrapper for field arguments, or missing field on input struct)\\n\\tused by (*graphql_test.inputArgumentsObjectMismatch2).Hello\"},\n\t\t},\n\t\t\"Inline Input struct missing field\": {\n\t\t\tArgs: args{\n\t\t\t\tResolver: &inputArgumentsObjectMismatch3{},\n\t\t\t\tSchema: `\n\t\t\t\t\tschema {\n\t\t\t\t\t\tquery: Query\n\t\t\t\t\t}\n\t\t\t\t\ttype Query {\n\t\t\t\t\t\thello(input: HelloInput): String!\n\t\t\t\t\t}\n\t\t\t\t\tinput HelloInput {\n\t\t\t\t\t\tname: String\n\t\t\t\t\t}\n\t\t\t\t`,\n\t\t\t},\n\t\t\tWant: want{Error: \"field \\\"Input\\\": *struct { Thing string } does not define field \\\"name\\\" (hint: missing `args struct { ... }` wrapper for field arguments, or missing field on input struct)\\n\\tused by (*graphql_test.inputArgumentsObjectMismatch3).Hello\"},\n\t\t},\n\t\t\"Struct field name inclusion\": {\n\t\t\tArgs: args{\n\t\t\t\tResolver: &fieldNameMismatch{},\n\t\t\t\tOpts:     []graphql.SchemaOpt{graphql.UseFieldResolvers()},\n\t\t\t\tSchema: `\n\t\t\t\t\ttype Query {\n\t\t\t\t\t\thello(): HelloOutput!\n\t\t\t\t\t}\n\t\t\t\t\ttype HelloOutput {\n\t\t\t\t\t\tname: Int\n\t\t\t\t\t}\n\t\t\t\t`,\n\t\t\t},\n\t\t\tWant: want{Error: \"string is not a pointer\\n\\tused by (graphql_test.helloOutput).Name\\n\\tused by (*graphql_test.fieldNameMismatch).Hello\"},\n\t\t},\n\t}\n\n\tfor name, tt := range testTable {\n\t\ttt := tt\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\t_, err := graphql.ParseSchema(tt.Args.Schema, tt.Args.Resolver, tt.Args.Opts...)\n\t\t\tif err == nil || err.Error() != tt.Want.Error {\n\t\t\t\tt.Log(\"Schema parsing error mismatch\")\n\t\t\t\tt.Logf(\"got: %s\", err)\n\t\t\t\tt.Logf(\"exp: %s\", tt.Want.Error)\n\t\t\t\tt.Fail()\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestComposedFragments(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: starwarsSchema,\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tcomposed: hero(episode: EMPIRE) {\n\t\t\t\t\t\tname\n\t\t\t\t\t\t...friendsNames\n\t\t\t\t\t\t...friendsIds\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfragment friendsNames on Character {\n\t\t\t\t\tname\n\t\t\t\t\tfriends {\n\t\t\t\t\t\tname\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfragment friendsIds on Character {\n\t\t\t\t\tname\n\t\t\t\t\tfriends {\n\t\t\t\t\t\tid\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"composed\": {\n\t\t\t\t\t\t\"name\": \"Luke Skywalker\",\n\t\t\t\t\t\t\"friends\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"id\": \"1002\",\n\t\t\t\t\t\t\t\t\"name\": \"Han Solo\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"id\": \"1003\",\n\t\t\t\t\t\t\t\t\"name\": \"Leia Organa\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"id\": \"2000\",\n\t\t\t\t\t\t\t\t\"name\": \"C-3PO\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"id\": \"2001\",\n\t\t\t\t\t\t\t\t\"name\": \"R2-D2\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\nvar (\n\texampleError = fmt.Errorf(\"This is an error\")\n\n\tnilChildErrorString = `graphql: got nil for non-null \"Child\"`\n)\n\ntype childResolver struct{}\n\nfunc (r *childResolver) TriggerError() (string, error) {\n\treturn \"This will never be returned to the client\", exampleError\n}\nfunc (r *childResolver) NoError() string {\n\treturn \"no error\"\n}\nfunc (r *childResolver) Child() *childResolver {\n\treturn &childResolver{}\n}\nfunc (r *childResolver) NilChild() *childResolver {\n\treturn nil\n}\n\nfunc TestErrorPropagation(t *testing.T) {\n\tt.Parallel()\n\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tnoError: String!\n\t\t\t\t\ttriggerError: String!\n\t\t\t\t}\n\t\t\t`, &childResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tnoError\n\t\t\t\t\ttriggerError\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\tnull\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage:       exampleError.Error(),\n\t\t\t\t\tResolverError: exampleError,\n\t\t\t\t\tPath:          []interface{}{\"triggerError\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tnoError: String!\n\t\t\t\t\tchild: Child\n\t\t\t\t}\n\n\t\t\t\ttype Child {\n\t\t\t\t\tnoError: String!\n\t\t\t\t\ttriggerError: String!\n\t\t\t\t}\n\t\t\t`, &childResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tnoError\n\t\t\t\t\tchild {\n\t\t\t\t\t\tnoError\n\t\t\t\t\t\ttriggerError\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"noError\": \"no error\",\n\t\t\t\t\t\"child\": null\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage:       exampleError.Error(),\n\t\t\t\t\tResolverError: exampleError,\n\t\t\t\t\tPath:          []interface{}{\"child\", \"triggerError\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tnoError: String!\n\t\t\t\t\tchild: Child\n\t\t\t\t}\n\n\t\t\t\ttype Child {\n\t\t\t\t\tnoError: String!\n\t\t\t\t\ttriggerError: String!\n\t\t\t\t\tchild: Child!\n\t\t\t\t}\n\t\t\t`, &childResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tnoError\n\t\t\t\t\tchild {\n\t\t\t\t\t\tnoError\n\t\t\t\t\t\tchild {\n\t\t\t\t\t\t\tnoError\n\t\t\t\t\t\t\ttriggerError\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"noError\": \"no error\",\n\t\t\t\t\t\"child\": null\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage:       exampleError.Error(),\n\t\t\t\t\tResolverError: exampleError,\n\t\t\t\t\tPath:          []interface{}{\"child\", \"child\", \"triggerError\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tnoError: String!\n\t\t\t\t\tchild: Child\n\t\t\t\t}\n\n\t\t\t\ttype Child {\n\t\t\t\t\tnoError: String!\n\t\t\t\t\ttriggerError: String!\n\t\t\t\t\tchild: Child\n\t\t\t\t}\n\t\t\t`, &childResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tnoError\n\t\t\t\t\tchild {\n\t\t\t\t\t\tnoError\n\t\t\t\t\t\tchild {\n\t\t\t\t\t\t\tnoError\n\t\t\t\t\t\t\ttriggerError\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"noError\": \"no error\",\n\t\t\t\t\t\"child\": {\n\t\t\t\t\t\t\"noError\": \"no error\",\n\t\t\t\t\t\t\"child\": null\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage:       exampleError.Error(),\n\t\t\t\t\tResolverError: exampleError,\n\t\t\t\t\tPath:          []interface{}{\"child\", \"child\", \"triggerError\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tnoError: String!\n\t\t\t\t\tchild: Child!\n\t\t\t\t}\n\n\t\t\t\ttype Child {\n\t\t\t\t\tnoError: String!\n\t\t\t\t\tnilChild: Child!\n\t\t\t\t}\n\t\t\t`, &childResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tnoError\n\t\t\t\t\tchild {\n\t\t\t\t\t\tnilChild {\n\t\t\t\t\t\t\tnoError\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\tnull\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage: nilChildErrorString,\n\t\t\t\t\tPath:    []interface{}{\"child\", \"nilChild\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tnoError: String!\n\t\t\t\t\tchild: Child\n\t\t\t\t}\n\n\t\t\t\ttype Child {\n\t\t\t\t\tnoError: String!\n\t\t\t\t\tnilChild: Child!\n\t\t\t\t}\n\t\t\t`, &childResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tnoError\n\t\t\t\t\tchild {\n\t\t\t\t\t\tnoError\n\t\t\t\t\t\tnilChild {\n\t\t\t\t\t\t\tnoError\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t{\n\t\t\t\t\"noError\": \"no error\",\n\t\t\t\t\"child\": null\n\t\t\t}\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage: nilChildErrorString,\n\t\t\t\t\tPath:    []interface{}{\"child\", \"nilChild\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tchild: Child\n\t\t\t\t}\n\n\t\t\t\ttype Child {\n\t\t\t\t\ttriggerError: String!\n\t\t\t\t\tchild: Child\n\t\t\t\t\tnilChild: Child!\n\t\t\t\t}\n\t\t\t`, &childResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tchild {\n\t\t\t\t\t\tchild {\n\t\t\t\t\t\t\ttriggerError\n\t\t\t\t\t\t\tchild {\n\t\t\t\t\t\t\t\tnilChild {\n\t\t\t\t\t\t\t\t\ttriggerError\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t{\n\t\t\t\t\"child\": {\n\t\t\t\t\t\"child\": null\n\t\t\t\t}\n\t\t\t}\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage: nilChildErrorString,\n\t\t\t\t\tPath:    []interface{}{\"child\", \"child\", \"child\", \"nilChild\"},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tMessage:       exampleError.Error(),\n\t\t\t\t\tResolverError: exampleError,\n\t\t\t\t\tPath:          []interface{}{\"child\", \"child\", \"triggerError\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\t\tschema {\n\t\t\t\t\tquery: Query\n\t\t\t\t}\n\n\t\t\t\ttype Query {\n\t\t\t\t\tchild: Child\n\t\t\t\t}\n\n\t\t\t\ttype Child {\n\t\t\t\t\tnoError: String!\n\t\t\t\t\tchild: Child!\n\t\t\t\t\tnilChild: Child!\n\t\t\t\t}\n\t\t\t`, &childResolver{}),\n\t\t\tQuery: `\n\t\t\t\t{\n\t\t\t\t\tchild {\n\t\t\t\t\t\tchild {\n\t\t\t\t\t\t\tnilChild {\n\t\t\t\t\t\t\t\tnoError\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t{\n\t\t\t\t\"child\": null\n\t\t\t}\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage: nilChildErrorString,\n\t\t\t\t\tPath:    []interface{}{\"child\", \"child\", \"nilChild\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t})\n}\n\ntype ambiguousResolver struct {\n\tName string // ambiguous\n\tUniversity\n}\n\ntype University struct {\n\tName string // ambiguous\n}\n\nfunc TestPanicAmbiguity(t *testing.T) {\n\tpanicMessage := `*graphql_test.ambiguousResolver does not resolve \"Query\": ambiguous field \"name\"`\n\n\tdefer func() {\n\t\tr := recover()\n\t\tif r == nil {\n\t\t\tt.Fatal(\"expected schema parse to panic\")\n\t\t}\n\n\t\tif r.(error).Error() != panicMessage {\n\t\t\tt.Logf(\"got:  %s\", r)\n\t\t\tt.Logf(\"want: %s\", panicMessage)\n\t\t\tt.Fail()\n\t\t}\n\t}()\n\n\tschema := `\n\t\tschema {\n\t\t\tquery: Query\n\t\t}\n\n\t\ttype Query {\n\t\t\tname: String!\n\t\t\tuniversity: University!\n\t\t}\n\t\t\n\t\ttype University {\n\t\t\tname: String!\n\t\t}\n\t`\n\tgraphql.MustParseSchema(schema, &ambiguousResolver{}, graphql.UseFieldResolvers())\n}\n\nfunc TestSchema_Exec_without_resolver(t *testing.T) {\n\tt.Parallel()\n\n\ttype args struct {\n\t\tQuery  string\n\t\tSchema string\n\t}\n\ttype want struct {\n\t\tPanic interface{}\n\t}\n\ttestTable := []struct {\n\t\tName string\n\t\tArgs args\n\t\tWant want\n\t}{\n\t\t{\n\t\t\tName: \"schema_without_resolver_errors\",\n\t\t\tArgs: args{\n\t\t\t\tQuery: `\n\t\t\t\t\tquery {\n\t\t\t\t\t\thero {\n\t\t\t\t\t\t\tid\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\tfriends {\n\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t`,\n\t\t\t\tSchema: starwars.Schema,\n\t\t\t},\n\t\t\tWant: want{Panic: \"schema created without resolver, can not exec\"},\n\t\t},\n\t}\n\n\tfor _, tt := range testTable {\n\t\tt.Run(tt.Name, func(t *testing.T) {\n\t\t\ts := graphql.MustParseSchema(tt.Args.Schema, nil)\n\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif r == nil {\n\t\t\t\t\tt.Fatal(\"expected query to panic\")\n\t\t\t\t}\n\t\t\t\tif r != tt.Want.Panic {\n\t\t\t\t\tt.Logf(\"got:  %s\", r)\n\t\t\t\t\tt.Logf(\"want: %s\", tt.Want.Panic)\n\t\t\t\t\tt.Fail()\n\t\t\t\t}\n\t\t\t}()\n\t\t\t_ = s.Exec(context.Background(), tt.Args.Query, \"\", map[string]interface{}{})\n\t\t})\n\t}\n}\n\ntype subscriptionsInExecResolver struct{}\n\nfunc (r *subscriptionsInExecResolver) AppUpdated() <-chan string {\n\treturn make(chan string)\n}\n\nfunc TestSubscriptions_In_Exec(t *testing.T) {\n\tr := &struct {\n\t\t*helloResolver\n\t\t*subscriptionsInExecResolver\n\t}{\n\t\thelloResolver:               &helloResolver{},\n\t\tsubscriptionsInExecResolver: &subscriptionsInExecResolver{},\n\t}\n\tgqltesting.RunTest(t, &gqltesting.Test{\n\t\tSchema: graphql.MustParseSchema(`\n\t\t\ttype Query {\n\t\t\t\thello: String!\n\t\t\t}\n\t\t\ttype Subscription {\n\t\t\t\tappUpdated : String!\n\t\t\t}\n\t\t`, r),\n\t\tQuery: `\n\t\t\tsubscription {\n\t\t\t\tappUpdated\n\t\t  \t}\n\t\t`,\n\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t{\n\t\t\t\tMessage: \"graphql-ws protocol header is missing\",\n\t\t\t},\n\t\t},\n\t})\n}\n\ntype nilPointerReturnValue struct{}\n\nfunc (r *nilPointerReturnValue) Value() *string {\n\treturn nil\n}\n\ntype nilPointerReturnResolver struct{}\n\nfunc (r *nilPointerReturnResolver) PointerReturn() *nilPointerReturnValue {\n\treturn &nilPointerReturnValue{}\n}\n\nfunc TestPointerReturnForNonNull(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(`\n\t\t\ttype Query {\n\t\t\t\tpointerReturn: PointerReturnValue\n\t\t\t}\n\n\t\t\ttype PointerReturnValue {\n\t\t\t\tvalue: Hello!\n\t\t\t}\n\t\t\tenum Hello {\n\t\t\t\tWORLD\n\t\t\t}\n\t\t`, &nilPointerReturnResolver{}),\n\t\t\tQuery: `\n\t\t\t\tquery {\n\t\t\t\t\tpointerReturn {\n\t\t\t\t\t\tvalue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"pointerReturn\": null\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{\n\t\t\t\t{\n\t\t\t\t\tMessage: `graphql: got nil for non-null \"Hello\"`,\n\t\t\t\t\tPath:    []interface{}{\"pointerReturn\", \"value\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t})\n}\n\ntype nullableInput struct {\n\tString graphql.NullString\n\tInt    graphql.NullInt\n\tBool   graphql.NullBool\n\tTime   graphql.NullTime\n\tFloat  graphql.NullFloat\n}\n\ntype nullableResult struct {\n\tString string\n\tInt    string\n\tBool   string\n\tTime   string\n\tFloat  string\n}\n\ntype nullableResolver struct {\n}\n\nfunc (r *nullableResolver) TestNullables(args struct {\n\tInput *nullableInput\n}) nullableResult {\n\tvar res nullableResult\n\tif args.Input.String.Set {\n\t\tif args.Input.String.Value == nil {\n\t\t\tres.String = \"<nil>\"\n\t\t} else {\n\t\t\tres.String = *args.Input.String.Value\n\t\t}\n\t}\n\n\tif args.Input.Int.Set {\n\t\tif args.Input.Int.Value == nil {\n\t\t\tres.Int = \"<nil>\"\n\t\t} else {\n\t\t\tres.Int = fmt.Sprintf(\"%d\", *args.Input.Int.Value)\n\t\t}\n\t}\n\n\tif args.Input.Float.Set {\n\t\tif args.Input.Float.Value == nil {\n\t\t\tres.Float = \"<nil>\"\n\t\t} else {\n\t\t\tres.Float = fmt.Sprintf(\"%.2f\", *args.Input.Float.Value)\n\t\t}\n\t}\n\n\tif args.Input.Bool.Set {\n\t\tif args.Input.Bool.Value == nil {\n\t\t\tres.Bool = \"<nil>\"\n\t\t} else {\n\t\t\tres.Bool = fmt.Sprintf(\"%t\", *args.Input.Bool.Value)\n\t\t}\n\t}\n\n\tif args.Input.Time.Set {\n\t\tif args.Input.Time.Value == nil {\n\t\t\tres.Time = \"<nil>\"\n\t\t} else {\n\t\t\tres.Time = args.Input.Time.Value.Format(time.RFC3339)\n\t\t}\n\t}\n\n\treturn res\n}\n\nfunc TestNullable(t *testing.T) {\n\tschema := `\n\tscalar Time\n\n\tinput MyInput {\n\t\tstring: String\n\t\tint: Int\n\t\tfloat: Float\n\t\tbool: Boolean\n\t\ttime: Time\n\t}\n\n\ttype Result {\n\t\tstring: String!\n\t\tint: String!\n\t\tfloat: String!\n\t\tbool: String!\n\t\ttime: String!\n\t}\n\n\ttype Query {\n\t\ttestNullables(input: MyInput): Result!\n\t}\n\t`\n\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(schema, &nullableResolver{}, graphql.UseFieldResolvers()),\n\t\t\tQuery: `\n\t\t\t\tquery {\n\t\t\t\t\ttestNullables(input: {\n\t\t\t\t\t\tstring: \"test\"\n\t\t\t\t\t\tint: 1234\n\t\t\t\t\t\tfloat: 42.42\n\t\t\t\t\t\tbool: true\n\t\t\t\t\t\ttime: \"2021-01-02T15:04:05Z\"\n\t\t\t\t\t}) {\n\t\t\t\t\t\tstring\n\t\t\t\t\t\tint\n\t\t\t\t\t\tfloat\n\t\t\t\t\t\tbool\n\t\t\t\t\t\ttime\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"testNullables\": {\n\t\t\t\t\t\t\"string\": \"test\",\n\t\t\t\t\t\t\"int\": \"1234\",\n\t\t\t\t\t\t\"float\": \"42.42\",\n\t\t\t\t\t\t\"bool\": \"true\",\n\t\t\t\t\t\t\"time\": \"2021-01-02T15:04:05Z\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(schema, &nullableResolver{}, graphql.UseFieldResolvers()),\n\t\t\tQuery: `\n\t\t\t\tquery {\n\t\t\t\t\ttestNullables(input: {\n\t\t\t\t\t\tstring: null\n\t\t\t\t\t\tint: null\n\t\t\t\t\t\tfloat: null\n\t\t\t\t\t\tbool: null\n\t\t\t\t\t\ttime: null\n\t\t\t\t\t}) {\n\t\t\t\t\t\tstring\n\t\t\t\t\t\tint\n\t\t\t\t\t\tfloat\n\t\t\t\t\t\tbool\n\t\t\t\t\t\ttime\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"testNullables\": {\n\t\t\t\t\t\t\"string\": \"<nil>\",\n\t\t\t\t\t\t\"int\": \"<nil>\",\n\t\t\t\t\t\t\"float\": \"<nil>\",\n\t\t\t\t\t\t\"bool\": \"<nil>\",\n\t\t\t\t\t\t\"time\": \"<nil>\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t\t{\n\t\t\tSchema: graphql.MustParseSchema(schema, &nullableResolver{}, graphql.UseFieldResolvers()),\n\t\t\tQuery: `\n\t\t\t\tquery {\n\t\t\t\t\ttestNullables(input: {}) {\n\t\t\t\t\t\tstring\n\t\t\t\t\t\tint\n\t\t\t\t\t\tfloat\n\t\t\t\t\t\tbool\n\t\t\t\t\t\ttime\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"testNullables\": {\n\t\t\t\t\t\t\"string\": \"\",\n\t\t\t\t\t\t\"int\": \"\",\n\t\t\t\t\t\t\"float\": \"\",\n\t\t\t\t\t\t\"bool\": \"\",\n\t\t\t\t\t\t\"time\": \"\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t\t},\n\t})\n}\n\ntype testTracer struct {\n\tmu      *sync.Mutex\n\tfields  []fieldTrace\n\tqueries []queryTrace\n}\n\ntype fieldTrace struct {\n\tlabel     string\n\ttypeName  string\n\tfieldName string\n\tisTrivial bool\n\targs      map[string]interface{}\n\terr       *gqlerrors.QueryError\n}\n\ntype queryTrace struct {\n\tdocument  string\n\topName    string\n\tvariables map[string]interface{}\n\tvarTypes  map[string]*introspection.Type\n\terrors    []*gqlerrors.QueryError\n}\n\nfunc (t *testTracer) TraceField(ctx context.Context, label, typeName, fieldName string, trivial bool, args map[string]interface{}) (context.Context, trace.TraceFieldFinishFunc) {\n\treturn ctx, func(qe *gqlerrors.QueryError) {\n\t\tt.mu.Lock()\n\t\tdefer t.mu.Unlock()\n\n\t\tft := fieldTrace{\n\t\t\tlabel:     label,\n\t\t\ttypeName:  typeName,\n\t\t\tfieldName: fieldName,\n\t\t\tisTrivial: trivial,\n\t\t\targs:      args,\n\t\t\terr:       qe,\n\t\t}\n\n\t\tt.fields = append(t.fields, ft)\n\t}\n}\n\nfunc (t *testTracer) TraceQuery(ctx context.Context, document string, opName string, vars map[string]interface{}, varTypes map[string]*introspection.Type) (context.Context, trace.TraceQueryFinishFunc) {\n\treturn ctx, func(qe []*gqlerrors.QueryError) {\n\t\tt.mu.Lock()\n\t\tdefer t.mu.Unlock()\n\n\t\tqt := queryTrace{\n\t\t\tdocument:  document,\n\t\t\topName:    opName,\n\t\t\tvariables: vars,\n\t\t\tvarTypes:  varTypes,\n\t\t\terrors:    qe,\n\t\t}\n\n\t\tt.queries = append(t.queries, qt)\n\t}\n}\n\nvar _ trace.Tracer = (*testTracer)(nil)\n\nfunc TestTracer(t *testing.T) {\n\tt.Parallel()\n\n\ttracer := &testTracer{mu: &sync.Mutex{}}\n\n\tschema, err := graphql.ParseSchema(starwars.Schema, &starwars.Resolver{}, graphql.Tracer(tracer))\n\tif err != nil {\n\t\tt.Fatalf(\"graphql.ParseSchema: %s\", err)\n\t}\n\n\tctx := context.Background()\n\tdoc := `\n\tquery TestTracer($id: ID!) {\n\t\tHanSolo: human(id: $id) {\n\t\t\t__typename\n\t\t\tname\n\t\t}\n\t}\n\t`\n\topName := \"TestTracer\"\n\tvariables := map[string]interface{}{\n\t\t\"id\": \"1002\",\n\t}\n\n\t_ = schema.Exec(ctx, doc, opName, variables)\n\n\ttracer.mu.Lock()\n\tdefer tracer.mu.Unlock()\n\n\tif len(tracer.queries) != 1 {\n\t\tt.Fatalf(\"expected one query trace, but got %d: %#v\", len(tracer.queries), tracer.queries)\n\t}\n\n\tqt := tracer.queries[0]\n\tif qt.document != doc {\n\t\tt.Errorf(\"mismatched query trace document:\\nwant: %q\\ngot : %q\", doc, qt.document)\n\t}\n\tif qt.opName != opName {\n\t\tt.Errorf(\"mismated query trace operationName:\\nwant: %q\\ngot : %q\", opName, qt.opName)\n\t}\n\n\texpectedFieldTraces := []fieldTrace{\n\t\t{fieldName: \"human\", typeName: \"Query\"},\n\t\t{fieldName: \"__typename\", typeName: \"Human\"},\n\t\t{fieldName: \"name\", typeName: \"Human\"},\n\t}\n\n\tcheckFieldTraces(t, expectedFieldTraces, tracer.fields)\n}\n\nfunc checkFieldTraces(t *testing.T, want, have []fieldTrace) {\n\tif len(want) != len(have) {\n\t\tt.Errorf(\"mismatched field traces: expected %d but got %d: %#v\", len(want), len(have), have)\n\t}\n\n\ttype comparison struct {\n\t\twant fieldTrace\n\t\thave fieldTrace\n\t}\n\n\tm := map[string]comparison{}\n\n\tfor _, ft := range want {\n\t\tm[ft.fieldName] = comparison{want: ft}\n\t}\n\n\tfor _, ft := range have {\n\t\tc := m[ft.fieldName]\n\t\tc.have = ft\n\t\tm[ft.fieldName] = c\n\t}\n\n\tfor _, c := range m {\n\t\tif err := stringsEqual(c.want.fieldName, c.have.fieldName); err != \"\" {\n\t\t\tt.Error(\"mismatched field name:\", err)\n\t\t}\n\t\tif err := stringsEqual(c.want.typeName, c.have.typeName); err != \"\" {\n\t\t\tt.Error(\"mismatched field parent type:\", err)\n\t\t}\n\t}\n}\n\nfunc stringsEqual(want, have string) string {\n\tif want != have {\n\t\treturn fmt.Sprintf(\"mismatched values:\\nwant: %q\\nhave: %q\", want, have)\n\t}\n\n\treturn \"\"\n}\n\ntype queryVarResolver struct{}\ntype filterArgs struct {\n\tRequired string\n\tOptional *string\n}\ntype filterSearchResults struct {\n\tMatch *string\n}\n\nfunc (r *queryVarResolver) Search(ctx context.Context, args *struct{ Filter filterArgs }) []filterSearchResults {\n\treturn []filterSearchResults{}\n}\n\nfunc TestQueryVariablesValidation(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{{\n\t\tSchema: graphql.MustParseSchema(`\n\t\t\tinput SearchFilter {\n\t\t\t  \trequired: String!\n\t\t\t  \toptional: String\n\t\t\t}\n\t\t\t\n\t\t\ttype SearchResults {\n\t\t\t\tmatch: String\n\t\t\t}\n\t\t\t\n\t\t\ttype Query {\n\t\t\t\tsearch(filter: SearchFilter!): [SearchResults!]!\n\t\t\t}`, &queryVarResolver{}, graphql.UseFieldResolvers()),\n\t\tQuery: `\n        \t\tquery {\n        \t\t\tsearch(filter: {}) {\n        \t\t\t\tmatch\n        \t\t\t}\n        \t\t}`,\n\t\tExpectedErrors: []*gqlerrors.QueryError{{\n\t\t\tMessage:   \"Argument \\\"filter\\\" has invalid value {}.\\nIn field \\\"required\\\": Expected \\\"String!\\\", found null.\",\n\t\t\tLocations: []gqlerrors.Location{{Line: 3, Column: 27}},\n\t\t\tRule:      \"ArgumentsOfCorrectType\",\n\t\t}},\n\t}, {\n\t\tSchema: graphql.MustParseSchema(`\n\t\t\tinput SearchFilter {\n\t\t\t\trequired: String!\n\t\t\t\toptional: String\n\t\t\t}\n\t\t\t\n\t\t\ttype SearchResults {\n\t\t\t\tmatch: String\n\t\t\t}\n\t\t\t\n\t\t\ttype Query {\n\t\t\t\tsearch(filter: SearchFilter!): [SearchResults!]!\n\t\t\t}`, &queryVarResolver{}, graphql.UseFieldResolvers()),\n\t\tQuery: `\n\t\t\tquery q($filter: SearchFilter!) {\n\t\t\t\tsearch(filter: $filter) {\n\t\t\t\t\tmatch\n\t\t\t\t}\n\t\t\t}`,\n\t\tVariables: map[string]interface{}{\"filter\": map[string]interface{}{}},\n\t\tExpectedErrors: []*gqlerrors.QueryError{{\n\t\t\tMessage:   \"Variable \\\"required\\\" has invalid value null.\\nExpected type \\\"String!\\\", found null.\",\n\t\t\tLocations: []gqlerrors.Location{{Line: 3, Column: 5}},\n\t\t\tRule:      \"VariablesOfCorrectType\",\n\t\t}},\n\t}})\n}\n\ntype interfaceImplementingInterfaceResolver struct{}\ntype interfaceImplementingInterfaceExample struct {\n\tA string\n\tB string\n\tC bool\n}\n\nfunc (r *interfaceImplementingInterfaceResolver) Hey() *interfaceImplementingInterfaceExample {\n\treturn &interfaceImplementingInterfaceExample{\n\t\tA: \"testing\",\n\t\tB: \"test\",\n\t\tC: true,\n\t}\n}\n\nfunc TestInterfaceImplementingInterface(t *testing.T) {\n\tgqltesting.RunTests(t, []*gqltesting.Test{{\n\t\tSchema: graphql.MustParseSchema(`\n        interface A {\n          a: String!\n        }\n        interface B implements A {\n          a: String!\n          b: String!\n        }\n        interface C implements B & A {\n          a: String!\n          b: String!\n          c: Boolean!\n        }\n        type ABC implements C {\n          a: String!\n          b: String!\n          c: Boolean!\n        }\n        type Query {\n          hey: ABC\n        }`, &interfaceImplementingInterfaceResolver{}, graphql.UseFieldResolvers(), graphql.UseFieldResolvers()),\n\t\tQuery: `query {hey { a b c }}`,\n\t\tExpectedResult: `\n\t\t\t\t{\n\t\t\t\t\t\"hey\": {\n\t\t\t\t\t\t\"a\": \"testing\",\n\t\t\t\t\t\t\"b\": \"test\",\n\t\t\t\t\t\t\"c\": true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t`,\n\t}})\n}\n\nfunc TestCircularFragmentMaxDepth(t *testing.T) {\n\twithMaxDepth := graphql.MustParseSchema(starwars.Schema, &starwars.Resolver{}, graphql.MaxDepth(2))\n\tgqltesting.RunTests(t, []*gqltesting.Test{\n\t\t{\n\t\t\tSchema: withMaxDepth,\n\t\t\tQuery: `\n\t              query {\n\t                  ...X\n\t              }\n\n\t              fragment X on Query {\n\t                  ...Y\n\t              }\n\t              fragment Y on Query {\n\t                  ...X\n\t              }\n\t          `,\n\t\t\tExpectedErrors: []*gqlerrors.QueryError{{\n\t\t\t\tMessage: `Cannot spread fragment \"X\" within itself via Y.`,\n\t\t\t\tRule:    \"NoFragmentCycles\",\n\t\t\t\tLocations: []gqlerrors.Location{\n\t\t\t\t\t{Line: 7, Column: 20},\n\t\t\t\t\t{Line: 10, Column: 20},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t})\n}\n", "package validation\n\nimport (\n\t\"testing\"\n\n\t\"github.com/graph-gophers/graphql-go/internal/query\"\n\t\"github.com/graph-gophers/graphql-go/internal/schema\"\n\t\"github.com/graph-gophers/graphql-go/types\"\n)\n\nconst (\n\tsimpleSchema = `schema {\n\t\tquery: Query\n\t}\n\n\ttype Query {\n\t\tcharacters: [Character]!\n\t}\n\n\ttype Character {\n\t\tid: ID!\n\t\tname: String!\n\t\tfriends: [Character]!\n\t}`\n\tinterfaceSimple = `schema {\n\t\tquery: Query\n\t}\n\n\ttype Query {\n\t\tcharacters: [Character]\n\t}\n\n\tinterface Character {\n\t\tid: ID!\n\t\tname: String!\n\t\tfriends: [Character]\n\t\tenemies: [Character]\n\t\tappearsIn: [Episode]!\n\t}\n\n\tenum Episode {\n\t\tNEWHOPE\n\t\tEMPIRE\n\t\tJEDI\n\t}\n\n\ttype Starship {\n\t\tid: ID!\n\t}\n\n\ttype Human implements Character {\n\t\tid: ID!\n\t\tname: String!\n\t\tfriends: [Character]\n\t\tenemies: [Character]\n\t\tappearsIn: [Episode]!\n\t\tstarships: [Starship]\n\t\ttotalCredits: Int\n\t}\n\n\ttype Droid implements Character {\n\t\tid: ID!\n\t\tname: String!\n\t\tfriends: [Character]\n\t\tenemies: [Character]\n\t\tappearsIn: [Episode]!\n\t\tprimaryFunction: String\n\t}`\n)\n\ntype maxDepthTestCase struct {\n\tname           string\n\tquery          string\n\tdepth          int\n\tfailure        bool\n\texpectedErrors []string\n}\n\nfunc (tc maxDepthTestCase) Run(t *testing.T, s *types.Schema) {\n\tt.Run(tc.name, func(t *testing.T) {\n\t\tdoc, qErr := query.Parse(tc.query)\n\t\tif qErr != nil {\n\t\t\tt.Fatal(qErr)\n\t\t}\n\n\t\terrs := Validate(s, doc, nil, tc.depth)\n\t\tif len(tc.expectedErrors) > 0 {\n\t\t\tif len(errs) > 0 {\n\t\t\t\tfor _, expected := range tc.expectedErrors {\n\t\t\t\t\tfound := false\n\t\t\t\t\tfor _, err := range errs {\n\t\t\t\t\t\tif err.Rule == expected {\n\t\t\t\t\t\t\tfound = true\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif !found {\n\t\t\t\t\t\tt.Errorf(\"expected error %v is missing\", expected)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tt.Errorf(\"expected errors [%v] are missing\", tc.expectedErrors)\n\t\t\t}\n\t\t}\n\t\tif (len(errs) > 0) != tc.failure {\n\t\t\tt.Errorf(\"expected failure: %t, actual errors (%d): %v\", tc.failure, len(errs), errs)\n\t\t}\n\t})\n}\n\nfunc TestMaxDepth(t *testing.T) {\n\ts, err := schema.ParseSchema(simpleSchema, false)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfor _, tc := range []maxDepthTestCase{\n\t\t{\n\t\t\tname: \"off\",\n\t\t\tquery: `query Okay {        # depth 0\n\t\t\tcharacters {         # depth 1\n\t\t\t  id                 # depth 2\n\t\t\t  name               # depth 2\n\t\t\t  friends {          # depth 2\n\t\t\t\t\tfriends {    # depth 3\n\t\t\t\t\t  friends {  # depth 4\n\t\t\t\t\t\t  id       # depth 5\n\t\t\t\t\t\t  name     # depth 5\n\t\t\t\t\t  }\n\t\t\t\t  }\n\t\t\t  }\n\t\t\t}\n\t\t}`,\n\t\t\tdepth: 0,\n\t\t}, {\n\t\t\tname: \"maxDepth-1\",\n\t\t\tquery: `query Fine {        # depth 0\n\t\t\t\tcharacters {         # depth 1\n\t\t\t\t  id                 # depth 2\n\t\t\t\t  name               # depth 2\n\t\t\t\t  friends {          # depth 2\n\t\t\t\t\t  id               # depth 3\n\t\t\t\t\t  name             # depth 3\n\t\t\t\t  }\n\t\t\t\t}\n\t\t\t}`,\n\t\t\tdepth: 4,\n\t\t}, {\n\t\t\tname: \"maxDepth\",\n\t\t\tquery: `query Deep {        # depth 0\n\t\t\t\tcharacters {         # depth 1\n\t\t\t\t  id                 # depth 2\n\t\t\t\t  name               # depth 2\n\t\t\t\t  friends {          # depth 2\n\t\t\t\t\t  id               # depth 3\n\t\t\t\t\t  name             # depth 3\n\t\t\t\t  }\n\t\t\t\t}\n\t\t\t}`,\n\t\t\tdepth: 3,\n\t\t}, {\n\t\t\tname: \"maxDepth+1\",\n\t\t\tquery: `query TooDeep {        # depth 0\n\t\t\t\tcharacters {         # depth 1\n\t\t\t\t  id                 # depth 2\n\t\t\t\t  name               # depth 2\n\t\t\t\t  friends {          # depth 2\n\t\t\t\t\t\tfriends {    # depth 3\n\t\t\t\t\t\t  friends {  # depth 4\n\t\t\t\t\t\t\tid       # depth 5\n\t\t\t\t\t\t\tname     # depth 5\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}`,\n\t\t\tdepth:   4,\n\t\t\tfailure: true,\n\t\t},\n\t} {\n\t\ttc.Run(t, s)\n\t}\n}\n\nfunc TestMaxDepthInlineFragments(t *testing.T) {\n\ts, err := schema.ParseSchema(interfaceSimple, false)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfor _, tc := range []maxDepthTestCase{\n\t\t{\n\t\t\tname: \"maxDepth-1\",\n\t\t\tquery: `query { # depth 0\n\t\t\t\tcharacters { # depth 1\n\t\t\t\t  name # depth 2\n\t\t\t\t  ... on Human { # depth 2\n\t\t\t\t\ttotalCredits # depth 2\n\t\t\t\t  }\n\t\t\t\t}\n\t\t\t  }`,\n\t\t\tdepth: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"maxDepth\",\n\t\t\tquery: `query { # depth 0\n\t\t\t\tcharacters { # depth 1\n\t\t\t\t  ... on Droid { # depth 2\n\t\t\t\t\tprimaryFunction # depth 2\n\t\t\t\t  }\n\t\t\t\t}\n\t\t\t  }`,\n\t\t\tdepth: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"maxDepth+1\",\n\t\t\tquery: `query { # depth 0\n\t\t\t\tcharacters { # depth 1\n\t\t\t\t  ... on Droid { # depth 2\n\t\t\t\t\tprimaryFunction # depth 2\n\t\t\t\t  }\n\t\t\t\t}\n\t\t\t  }`,\n\t\t\tdepth:   1,\n\t\t\tfailure: true,\n\t\t},\n\t} {\n\t\ttc.Run(t, s)\n\t}\n}\n\nfunc TestMaxDepthFragmentSpreads(t *testing.T) {\n\ts, err := schema.ParseSchema(interfaceSimple, false)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfor _, tc := range []maxDepthTestCase{\n\t\t{\n\t\t\tname: \"maxDepth-1\",\n\t\t\tquery: `fragment friend on Character {\n\t\t\t\tid  # depth 5\n\t\t\t\tname\n\t\t\t\tfriends {\n\t\t\t\t\tname  # depth 6\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tquery {        # depth 0\n\t\t\t\tcharacters {         # depth 1\n\t\t\t\t  id                 # depth 2\n\t\t\t\t  name               # depth 2\n\t\t\t\t  friends {          # depth 2\n\t\t\t\t\tfriends {        # depth 3\n\t\t\t\t\t\tfriends {    # depth 4\n\t\t\t\t\t\t\t...friend # depth 5\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t  }\n\t\t\t\t}\n\t\t\t}`,\n\t\t\tdepth: 7,\n\t\t},\n\t\t{\n\t\t\tname: \"maxDepth\",\n\t\t\tquery: `fragment friend on Character {\n\t\t\t\tid # depth 5\n\t\t\t\tname\n\t\t\t}\n\t\t\tquery {        # depth 0\n\t\t\t\tcharacters {         # depth 1\n\t\t\t\t  id                 # depth 2\n\t\t\t\t  name               # depth 2\n\t\t\t\t  friends {          # depth 2\n\t\t\t\t\tfriends {        # depth 3\n\t\t\t\t\t\tfriends {    # depth 4\n\t\t\t\t\t\t\t...friend # depth 5\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t  }\n\t\t\t\t}\n\t\t\t}`,\n\t\t\tdepth: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"maxDepth+1\",\n\t\t\tquery: `fragment friend on Character {\n\t\t\t\tid # depth 6\n\t\t\t\tname\n\t\t\t\tfriends {\n\t\t\t\t\tname # depth 7\n\t\t\t\t}\n\t\t\t}\n\t\t\tquery {        # depth 0\n\t\t\t\tcharacters {         # depth 1\n\t\t\t\t  id                 # depth 2\n\t\t\t\t  name               # depth 2\n\t\t\t\t  friends {          # depth 2\n\t\t\t\t\tfriends {        # depth 3\n\t\t\t\t\t\tfriends {    # depth 4\n\t\t\t\t\t\t  friends {  # depth 5\n\t\t\t\t\t\t\t...friend # depth 6\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t  }\n\t\t\t\t}\n\t\t\t}`,\n\t\t\tdepth:   6,\n\t\t\tfailure: true,\n\t\t},\n\t\t{\n\t\t\tname: \"spreadAtDifferentDepths\",\n\t\t\tquery: `\n\t\t\tfragment character on Character {\n\t\t\t\tname # depth + 0\n\t\t\t\tfriends { # depth + 0\n\t\t\t\t\tname # depth + 1\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tquery laterDepthValidated {\n\t\t\t\t...character # depth 1 (+1)\n\t\t\t\tenemies { # depth 1\n\t\t\t\t\tfriends { # depth 2\n\t\t\t\t\t\t...character # depth 2 (+1), should error!\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t`,\n\t\t\tdepth:   2,\n\t\t\tfailure: true,\n\t\t},\n\t\t{\n\t\t\tname: \"spreadAtSameDepth\",\n\t\t\tquery: `\n\t\t\tfragment character on Character {\n\t\t\t\tname # depth + 0\n\t\t\t\tfriends { # depth + 0\n\t\t\t\t\tname # depth + 1\n\t\t\t\t}\n\t\t\t}\n\t\t\tquery {\n\t\t\t\tcharacters { # depth 1\n\t\t\t\t\tfriends { # depth 2\n\t\t\t\t\t\t...character # depth 3 (+1)\n\t\t\t\t\t}\n\t\t\t\t\tenemies { # depth 2\n\t\t\t\t\t\t...character # depth 3 (+1)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t`,\n\t\t\tdepth: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"fragmentCycle\",\n\t\t\tquery: `\n\t\t\tfragment X on Query { ...Y }\n\t\t\tfragment Y on Query { ...Z }\n\t\t\tfragment Z on Query { ...X }\n\n\t\t\tquery {\n\t\t\t\t...X\n\t\t\t}\n\t\t\t`,\n\t\t\tdepth:   10,\n\t\t\tfailure: true,\n\t\t},\n\t} {\n\t\ttc.Run(t, s)\n\t}\n}\n\nfunc TestMaxDepthUnknownFragmentSpreads(t *testing.T) {\n\ts, err := schema.ParseSchema(interfaceSimple, false)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfor _, tc := range []maxDepthTestCase{\n\t\t{\n\t\t\tname: \"maxDepthUnknownFragment\",\n\t\t\tquery: `query {        # depth 0\n\t\t\t\tcharacters {         # depth 1\n\t\t\t\t  id                 # depth 2\n\t\t\t\t  name               # depth 2\n\t\t\t\t  friends {          # depth 2\n\t\t\t\t\tfriends {        # depth 3\n\t\t\t\t\t\tfriends {    # depth 4\n\t\t\t\t\t\t  friends {  # depth 5\n\t\t\t\t\t\t\t...unknownFragment # depth 6\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t  }\n\t\t\t\t}\n\t\t\t}`,\n\t\t\tdepth:          6,\n\t\t\tfailure:        true,\n\t\t\texpectedErrors: []string{\"MaxDepthEvaluationError\"},\n\t\t},\n\t} {\n\t\ttc.Run(t, s)\n\t}\n}\n\nfunc TestMaxDepthValidation(t *testing.T) {\n\ts, err := schema.ParseSchema(interfaceSimple, false)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfor _, tc := range []struct {\n\t\tname     string\n\t\tquery    string\n\t\tmaxDepth int\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname: \"off\",\n\t\t\tquery: `query Fine {        # depth 0\n\t\t\t\tcharacters {         # depth 1\n\t\t\t\t  id                 # depth 2\n\t\t\t\t  name               # depth 2\n\t\t\t\t  friends {          # depth 2\n\t\t\t\t\t  id               # depth 3\n\t\t\t\t\t  name             # depth 3\n\t\t\t\t  }\n\t\t\t\t}\n\t\t\t}`,\n\t\t\tmaxDepth: 0,\n\t\t}, {\n\t\t\tname: \"fields\",\n\t\t\tquery: `query Fine {        # depth 0\n\t\t\t\tcharacters {         # depth 1\n\t\t\t\t  id                 # depth 2\n\t\t\t\t  name               # depth 2\n\t\t\t\t  friends {          # depth 2\n\t\t\t\t\t  id               # depth 3\n\t\t\t\t\t  name             # depth 3\n\t\t\t\t  }\n\t\t\t\t}\n\t\t\t}`,\n\t\t\tmaxDepth: 2,\n\t\t\texpected: true,\n\t\t}, {\n\t\t\tname: \"fragment\",\n\t\t\tquery: `fragment friend on Character {\n\t\t\t\tid # depth 6\n\t\t\t\tname\n\t\t\t\tfriends {\n\t\t\t\t\tname # depth 7\n\t\t\t\t}\n\t\t\t}\n\t\t\tquery {        # depth 0\n\t\t\t\tcharacters {         # depth 1\n\t\t\t\t  id                 # depth 2\n\t\t\t\t  name               # depth 2\n\t\t\t\t  friends {          # depth 2\n\t\t\t\t\tfriends {        # depth 3\n\t\t\t\t\t\tfriends {    # depth 4\n\t\t\t\t\t\t  friends {  # depth 5\n\t\t\t\t\t\t\t...friend # depth 6\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t  }\n\t\t\t\t}\n\t\t\t}`,\n\t\t\tmaxDepth: 5,\n\t\t\texpected: true,\n\t\t}, {\n\t\t\tname: \"inlinefragment\",\n\t\t\tquery: `query { # depth 0\n\t\t\t\tcharacters { # depth 1\n\t\t\t\t  ... on Droid { # depth 2\n\t\t\t\t\tprimaryFunction # depth 2\n\t\t\t\t  }\n\t\t\t\t}\n\t\t\t  }`,\n\t\t\tmaxDepth: 1,\n\t\t\texpected: true,\n\t\t},\n\t} {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdoc, err := query.Parse(tc.query)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tcontext := newContext(s, doc, tc.maxDepth)\n\t\t\top := doc.Operations[0]\n\n\t\t\topc := &opContext{context: context, ops: doc.Operations}\n\n\t\t\tactual := validateMaxDepth(opc, op.Selections, nil, 1)\n\t\t\tif actual != tc.expected {\n\t\t\t\tt.Errorf(\"expected %t, actual %t\", tc.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}\n", "package validation\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"text/scanner\"\n\n\t\"github.com/graph-gophers/graphql-go/errors\"\n\t\"github.com/graph-gophers/graphql-go/internal/common\"\n\t\"github.com/graph-gophers/graphql-go/internal/query\"\n\t\"github.com/graph-gophers/graphql-go/types\"\n)\n\ntype varSet map[*types.InputValueDefinition]struct{}\n\ntype selectionPair struct{ a, b types.Selection }\n\ntype nameSet map[string]errors.Location\n\ntype fieldInfo struct {\n\tsf     *types.FieldDefinition\n\tparent types.NamedType\n}\n\ntype context struct {\n\tschema           *types.Schema\n\tdoc              *types.ExecutableDefinition\n\terrs             []*errors.QueryError\n\topErrs           map[*types.OperationDefinition][]*errors.QueryError\n\tusedVars         map[*types.OperationDefinition]varSet\n\tfieldMap         map[*types.Field]fieldInfo\n\toverlapValidated map[selectionPair]struct{}\n\tmaxDepth         int\n}\n\nfunc (c *context) addErr(loc errors.Location, rule string, format string, a ...interface{}) {\n\tc.addErrMultiLoc([]errors.Location{loc}, rule, format, a...)\n}\n\nfunc (c *context) addErrMultiLoc(locs []errors.Location, rule string, format string, a ...interface{}) {\n\tc.errs = append(c.errs, &errors.QueryError{\n\t\tMessage:   fmt.Sprintf(format, a...),\n\t\tLocations: locs,\n\t\tRule:      rule,\n\t})\n}\n\ntype opContext struct {\n\t*context\n\tops []*types.OperationDefinition\n}\n\nfunc newContext(s *types.Schema, doc *types.ExecutableDefinition, maxDepth int) *context {\n\treturn &context{\n\t\tschema:           s,\n\t\tdoc:              doc,\n\t\topErrs:           make(map[*types.OperationDefinition][]*errors.QueryError),\n\t\tusedVars:         make(map[*types.OperationDefinition]varSet),\n\t\tfieldMap:         make(map[*types.Field]fieldInfo),\n\t\toverlapValidated: make(map[selectionPair]struct{}),\n\t\tmaxDepth:         maxDepth,\n\t}\n}\n\nfunc Validate(s *types.Schema, doc *types.ExecutableDefinition, variables map[string]interface{}, maxDepth int) []*errors.QueryError {\n\tc := newContext(s, doc, maxDepth)\n\n\topNames := make(nameSet)\n\tfragUsedBy := make(map[*types.FragmentDefinition][]*types.OperationDefinition)\n\tfor _, op := range doc.Operations {\n\t\tc.usedVars[op] = make(varSet)\n\t\topc := &opContext{c, []*types.OperationDefinition{op}}\n\n\t\t// Check if max depth is exceeded, if it's set. If max depth is exceeded,\n\t\t// don't continue to validate the document and exit early.\n\t\tif validateMaxDepth(opc, op.Selections, nil, 1) {\n\t\t\treturn c.errs\n\t\t}\n\n\t\tif op.Name.Name == \"\" && len(doc.Operations) != 1 {\n\t\t\tc.addErr(op.Loc, \"LoneAnonymousOperation\", \"This anonymous operation must be the only defined operation.\")\n\t\t}\n\t\tif op.Name.Name != \"\" {\n\t\t\tvalidateName(c, opNames, op.Name, \"UniqueOperationNames\", \"operation\")\n\t\t}\n\n\t\tvalidateDirectives(opc, string(op.Type), op.Directives)\n\n\t\tvarNames := make(nameSet)\n\t\tfor _, v := range op.Vars {\n\t\t\tvalidateName(c, varNames, v.Name, \"UniqueVariableNames\", \"variable\")\n\n\t\t\tt := resolveType(c, v.Type)\n\t\t\tif !canBeInput(t) {\n\t\t\t\tc.addErr(v.TypeLoc, \"VariablesAreInputTypes\", \"Variable %q cannot be non-input type %q.\", \"$\"+v.Name.Name, t)\n\t\t\t}\n\t\t\tvalidateValue(opc, v, variables[v.Name.Name], t)\n\n\t\t\tif v.Default != nil {\n\t\t\t\tvalidateLiteral(opc, v.Default)\n\n\t\t\t\tif t != nil {\n\t\t\t\t\tif nn, ok := t.(*types.NonNull); ok {\n\t\t\t\t\t\tc.addErr(v.Default.Location(), \"DefaultValuesOfCorrectType\", \"Variable %q of type %q is required and will not use the default value. Perhaps you meant to use type %q.\", \"$\"+v.Name.Name, t, nn.OfType)\n\t\t\t\t\t}\n\n\t\t\t\t\tif ok, reason := validateValueType(opc, v.Default, t); !ok {\n\t\t\t\t\t\tc.addErr(v.Default.Location(), \"DefaultValuesOfCorrectType\", \"Variable %q of type %q has invalid default value %s.\\n%s\", \"$\"+v.Name.Name, t, v.Default, reason)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar entryPoint types.NamedType\n\t\tswitch op.Type {\n\t\tcase query.Query:\n\t\t\tentryPoint = s.EntryPoints[\"query\"]\n\t\tcase query.Mutation:\n\t\t\tentryPoint = s.EntryPoints[\"mutation\"]\n\t\tcase query.Subscription:\n\t\t\tentryPoint = s.EntryPoints[\"subscription\"]\n\t\tdefault:\n\t\t\tpanic(\"unreachable\")\n\t\t}\n\n\t\tvalidateSelectionSet(opc, op.Selections, entryPoint)\n\n\t\tfragUsed := make(map[*types.FragmentDefinition]struct{})\n\t\tmarkUsedFragments(c, op.Selections, fragUsed)\n\t\tfor frag := range fragUsed {\n\t\t\tfragUsedBy[frag] = append(fragUsedBy[frag], op)\n\t\t}\n\t}\n\n\tfragNames := make(nameSet)\n\tfragVisited := make(map[*types.FragmentDefinition]struct{})\n\tfor _, frag := range doc.Fragments {\n\t\topc := &opContext{c, fragUsedBy[frag]}\n\n\t\tvalidateName(c, fragNames, frag.Name, \"UniqueFragmentNames\", \"fragment\")\n\t\tvalidateDirectives(opc, \"FRAGMENT_DEFINITION\", frag.Directives)\n\n\t\tt := unwrapType(resolveType(c, &frag.On))\n\t\t// continue even if t is nil\n\t\tif t != nil && !canBeFragment(t) {\n\t\t\tc.addErr(frag.On.Loc, \"FragmentsOnCompositeTypes\", \"Fragment %q cannot condition on non composite type %q.\", frag.Name.Name, t)\n\t\t\tcontinue\n\t\t}\n\n\t\tvalidateSelectionSet(opc, frag.Selections, t)\n\n\t\tif _, ok := fragVisited[frag]; !ok {\n\t\t\tdetectFragmentCycle(c, frag.Selections, fragVisited, nil, map[string]int{frag.Name.Name: 0})\n\t\t}\n\t}\n\n\tfor _, frag := range doc.Fragments {\n\t\tif len(fragUsedBy[frag]) == 0 {\n\t\t\tc.addErr(frag.Loc, \"NoUnusedFragments\", \"Fragment %q is never used.\", frag.Name.Name)\n\t\t}\n\t}\n\n\tfor _, op := range doc.Operations {\n\t\tc.errs = append(c.errs, c.opErrs[op]...)\n\n\t\topUsedVars := c.usedVars[op]\n\t\tfor _, v := range op.Vars {\n\t\t\tif _, ok := opUsedVars[v]; !ok {\n\t\t\t\topSuffix := \"\"\n\t\t\t\tif op.Name.Name != \"\" {\n\t\t\t\t\topSuffix = fmt.Sprintf(\" in operation %q\", op.Name.Name)\n\t\t\t\t}\n\t\t\t\tc.addErr(v.Loc, \"NoUnusedVariables\", \"Variable %q is never used%s.\", \"$\"+v.Name.Name, opSuffix)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn c.errs\n}\n\nfunc validateValue(c *opContext, v *types.InputValueDefinition, val interface{}, t types.Type) {\n\tswitch t := t.(type) {\n\tcase *types.NonNull:\n\t\tif val == nil {\n\t\t\tc.addErr(v.Loc, \"VariablesOfCorrectType\", \"Variable \\\"%s\\\" has invalid value null.\\nExpected type \\\"%s\\\", found null.\", v.Name.Name, t)\n\t\t\treturn\n\t\t}\n\t\tvalidateValue(c, v, val, t.OfType)\n\tcase *types.List:\n\t\tif val == nil {\n\t\t\treturn\n\t\t}\n\t\tvv, ok := val.([]interface{})\n\t\tif !ok {\n\t\t\t// Input coercion rules allow single items without wrapping array\n\t\t\tvalidateValue(c, v, val, t.OfType)\n\t\t\treturn\n\t\t}\n\t\tfor _, elem := range vv {\n\t\t\tvalidateValue(c, v, elem, t.OfType)\n\t\t}\n\tcase *types.EnumTypeDefinition:\n\t\tif val == nil {\n\t\t\treturn\n\t\t}\n\t\te, ok := val.(string)\n\t\tif !ok {\n\t\t\tc.addErr(v.Loc, \"VariablesOfCorrectType\", \"Variable \\\"%s\\\" has invalid type %T.\\nExpected type \\\"%s\\\", found %v.\", v.Name.Name, val, t, val)\n\t\t\treturn\n\t\t}\n\t\tfor _, option := range t.EnumValuesDefinition {\n\t\t\tif option.EnumValue == e {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tc.addErr(v.Loc, \"VariablesOfCorrectType\", \"Variable \\\"%s\\\" has invalid value %s.\\nExpected type \\\"%s\\\", found %s.\", v.Name.Name, e, t, e)\n\tcase *types.InputObject:\n\t\tif val == nil {\n\t\t\treturn\n\t\t}\n\t\tin, ok := val.(map[string]interface{})\n\t\tif !ok {\n\t\t\tc.addErr(v.Loc, \"VariablesOfCorrectType\", \"Variable \\\"%s\\\" has invalid type %T.\\nExpected type \\\"%s\\\", found %s.\", v.Name.Name, val, t, val)\n\t\t\treturn\n\t\t}\n\t\tfor _, f := range t.Values {\n\t\t\tfieldVal := in[f.Name.Name]\n\t\t\tvalidateValue(c, f, fieldVal, f.Type)\n\t\t}\n\t}\n}\n\n// validates the query doesn't go deeper than maxDepth (if set). Returns whether\n// or not query validated max depth to avoid excessive recursion.\n//\n// The visited map is necessary to ensure that max depth validation does not get stuck in cyclical\n// fragment spreads.\nfunc validateMaxDepth(c *opContext, sels []types.Selection, visited map[*types.FragmentDefinition]struct{}, depth int) bool {\n\t// maxDepth checking is turned off when maxDepth is 0\n\tif c.maxDepth == 0 {\n\t\treturn false\n\t}\n\n\texceededMaxDepth := false\n\tif visited == nil {\n\t\tvisited = map[*types.FragmentDefinition]struct{}{}\n\t}\n\n\tfor _, sel := range sels {\n\t\tswitch sel := sel.(type) {\n\t\tcase *types.Field:\n\t\t\tif depth > c.maxDepth {\n\t\t\t\texceededMaxDepth = true\n\t\t\t\tc.addErr(sel.Alias.Loc, \"MaxDepthExceeded\", \"Field %q has depth %d that exceeds max depth %d\", sel.Name.Name, depth, c.maxDepth)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\texceededMaxDepth = exceededMaxDepth || validateMaxDepth(c, sel.SelectionSet, visited, depth+1)\n\n\t\tcase *types.InlineFragment:\n\t\t\t// Depth is not checked because inline fragments resolve to other fields which are checked.\n\t\t\t// Depth is not incremented because inline fragments have the same depth as neighboring fields\n\t\t\texceededMaxDepth = exceededMaxDepth || validateMaxDepth(c, sel.Selections, visited, depth)\n\t\tcase *types.FragmentSpread:\n\t\t\t// Depth is not checked because fragments resolve to other fields which are checked.\n\t\t\tfrag := c.doc.Fragments.Get(sel.Name.Name)\n\t\t\tif frag == nil {\n\t\t\t\t// In case of unknown fragment (invalid request), ignore max depth evaluation\n\t\t\t\tc.addErr(sel.Loc, \"MaxDepthEvaluationError\", \"Unknown fragment %q. Unable to evaluate depth.\", sel.Name.Name)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif _, ok := visited[frag]; ok {\n\t\t\t\t// we've already seen this fragment, don't check depth again.\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tvisited[frag] = struct{}{}\n\n\t\t\t// Depth is not incremented because fragments have the same depth as surrounding fields\n\t\t\texceededMaxDepth = exceededMaxDepth || validateMaxDepth(c, frag.Selections, visited, depth)\n\t\t}\n\t}\n\n\treturn exceededMaxDepth\n}\n\nfunc validateSelectionSet(c *opContext, sels []types.Selection, t types.NamedType) {\n\tfor _, sel := range sels {\n\t\tvalidateSelection(c, sel, t)\n\t}\n\n\tfor i, a := range sels {\n\t\tfor _, b := range sels[i+1:] {\n\t\t\tc.validateOverlap(a, b, nil, nil)\n\t\t}\n\t}\n}\n\nfunc validateSelection(c *opContext, sel types.Selection, t types.NamedType) {\n\tswitch sel := sel.(type) {\n\tcase *types.Field:\n\t\tvalidateDirectives(c, \"FIELD\", sel.Directives)\n\n\t\tfieldName := sel.Name.Name\n\t\tvar f *types.FieldDefinition\n\t\tswitch fieldName {\n\t\tcase \"__typename\":\n\t\t\tf = &types.FieldDefinition{\n\t\t\t\tName: \"__typename\",\n\t\t\t\tType: c.schema.Types[\"String\"],\n\t\t\t}\n\t\tcase \"__schema\":\n\t\t\tf = &types.FieldDefinition{\n\t\t\t\tName: \"__schema\",\n\t\t\t\tType: c.schema.Types[\"__Schema\"],\n\t\t\t}\n\t\tcase \"__type\":\n\t\t\tf = &types.FieldDefinition{\n\t\t\t\tName: \"__type\",\n\t\t\t\tArguments: types.ArgumentsDefinition{\n\t\t\t\t\t&types.InputValueDefinition{\n\t\t\t\t\t\tName: types.Ident{Name: \"name\"},\n\t\t\t\t\t\tType: &types.NonNull{OfType: c.schema.Types[\"String\"]},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tType: c.schema.Types[\"__Type\"],\n\t\t\t}\n\t\tdefault:\n\t\t\tf = fields(t).Get(fieldName)\n\t\t\tif f == nil && t != nil {\n\t\t\t\tsuggestion := makeSuggestion(\"Did you mean\", fields(t).Names(), fieldName)\n\t\t\t\tc.addErr(sel.Alias.Loc, \"FieldsOnCorrectType\", \"Cannot query field %q on type %q.%s\", fieldName, t, suggestion)\n\t\t\t}\n\t\t}\n\t\tc.fieldMap[sel] = fieldInfo{sf: f, parent: t}\n\n\t\tvalidateArgumentLiterals(c, sel.Arguments)\n\t\tif f != nil {\n\t\t\tvalidateArgumentTypes(c, sel.Arguments, f.Arguments, sel.Alias.Loc,\n\t\t\t\tfunc() string { return fmt.Sprintf(\"field %q of type %q\", fieldName, t) },\n\t\t\t\tfunc() string { return fmt.Sprintf(\"Field %q\", fieldName) },\n\t\t\t)\n\t\t}\n\n\t\tvar ft types.Type\n\t\tif f != nil {\n\t\t\tft = f.Type\n\t\t\tsf := hasSubfields(ft)\n\t\t\tif sf && sel.SelectionSet == nil {\n\t\t\t\tc.addErr(sel.Alias.Loc, \"ScalarLeafs\", \"Field %q of type %q must have a selection of subfields. Did you mean \\\"%s { ... }\\\"?\", fieldName, ft, fieldName)\n\t\t\t}\n\t\t\tif !sf && sel.SelectionSet != nil {\n\t\t\t\tc.addErr(sel.SelectionSetLoc, \"ScalarLeafs\", \"Field %q must not have a selection since type %q has no subfields.\", fieldName, ft)\n\t\t\t}\n\t\t}\n\t\tif sel.SelectionSet != nil {\n\t\t\tvalidateSelectionSet(c, sel.SelectionSet, unwrapType(ft))\n\t\t}\n\n\tcase *types.InlineFragment:\n\t\tvalidateDirectives(c, \"INLINE_FRAGMENT\", sel.Directives)\n\t\tif sel.On.Name != \"\" {\n\t\t\tfragTyp := unwrapType(resolveType(c.context, &sel.On))\n\t\t\tif fragTyp != nil && !compatible(t, fragTyp) {\n\t\t\t\tc.addErr(sel.Loc, \"PossibleFragmentSpreads\", \"Fragment cannot be spread here as objects of type %q can never be of type %q.\", t, fragTyp)\n\t\t\t}\n\t\t\tt = fragTyp\n\t\t\t// continue even if t is nil\n\t\t}\n\t\tif t != nil && !canBeFragment(t) {\n\t\t\tc.addErr(sel.On.Loc, \"FragmentsOnCompositeTypes\", \"Fragment cannot condition on non composite type %q.\", t)\n\t\t\treturn\n\t\t}\n\t\tvalidateSelectionSet(c, sel.Selections, unwrapType(t))\n\n\tcase *types.FragmentSpread:\n\t\tvalidateDirectives(c, \"FRAGMENT_SPREAD\", sel.Directives)\n\t\tfrag := c.doc.Fragments.Get(sel.Name.Name)\n\t\tif frag == nil {\n\t\t\tc.addErr(sel.Name.Loc, \"KnownFragmentNames\", \"Unknown fragment %q.\", sel.Name.Name)\n\t\t\treturn\n\t\t}\n\t\tfragTyp := c.schema.Types[frag.On.Name]\n\t\tif !compatible(t, fragTyp) {\n\t\t\tc.addErr(sel.Loc, \"PossibleFragmentSpreads\", \"Fragment %q cannot be spread here as objects of type %q can never be of type %q.\", frag.Name.Name, t, fragTyp)\n\t\t}\n\n\tdefault:\n\t\tpanic(\"unreachable\")\n\t}\n}\n\nfunc compatible(a, b types.Type) bool {\n\tfor _, pta := range possibleTypes(a) {\n\t\tfor _, ptb := range possibleTypes(b) {\n\t\t\tif pta == ptb {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\nfunc possibleTypes(t types.Type) []*types.ObjectTypeDefinition {\n\tswitch t := t.(type) {\n\tcase *types.ObjectTypeDefinition:\n\t\treturn []*types.ObjectTypeDefinition{t}\n\tcase *types.InterfaceTypeDefinition:\n\t\treturn t.PossibleTypes\n\tcase *types.Union:\n\t\treturn t.UnionMemberTypes\n\tdefault:\n\t\treturn nil\n\t}\n}\n\nfunc markUsedFragments(c *context, sels []types.Selection, fragUsed map[*types.FragmentDefinition]struct{}) {\n\tfor _, sel := range sels {\n\t\tswitch sel := sel.(type) {\n\t\tcase *types.Field:\n\t\t\tif sel.SelectionSet != nil {\n\t\t\t\tmarkUsedFragments(c, sel.SelectionSet, fragUsed)\n\t\t\t}\n\n\t\tcase *types.InlineFragment:\n\t\t\tmarkUsedFragments(c, sel.Selections, fragUsed)\n\n\t\tcase *types.FragmentSpread:\n\t\t\tfrag := c.doc.Fragments.Get(sel.Name.Name)\n\t\t\tif frag == nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif _, ok := fragUsed[frag]; ok {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfragUsed[frag] = struct{}{}\n\t\t\tmarkUsedFragments(c, frag.Selections, fragUsed)\n\n\t\tdefault:\n\t\t\tpanic(\"unreachable\")\n\t\t}\n\t}\n}\n\nfunc detectFragmentCycle(c *context, sels []types.Selection, fragVisited map[*types.FragmentDefinition]struct{}, spreadPath []*types.FragmentSpread, spreadPathIndex map[string]int) {\n\tfor _, sel := range sels {\n\t\tdetectFragmentCycleSel(c, sel, fragVisited, spreadPath, spreadPathIndex)\n\t}\n}\n\nfunc detectFragmentCycleSel(c *context, sel types.Selection, fragVisited map[*types.FragmentDefinition]struct{}, spreadPath []*types.FragmentSpread, spreadPathIndex map[string]int) {\n\tswitch sel := sel.(type) {\n\tcase *types.Field:\n\t\tif sel.SelectionSet != nil {\n\t\t\tdetectFragmentCycle(c, sel.SelectionSet, fragVisited, spreadPath, spreadPathIndex)\n\t\t}\n\n\tcase *types.InlineFragment:\n\t\tdetectFragmentCycle(c, sel.Selections, fragVisited, spreadPath, spreadPathIndex)\n\n\tcase *types.FragmentSpread:\n\t\tfrag := c.doc.Fragments.Get(sel.Name.Name)\n\t\tif frag == nil {\n\t\t\treturn\n\t\t}\n\n\t\tspreadPath = append(spreadPath, sel)\n\t\tif i, ok := spreadPathIndex[frag.Name.Name]; ok {\n\t\t\tcyclePath := spreadPath[i:]\n\t\t\tvia := \"\"\n\t\t\tif len(cyclePath) > 1 {\n\t\t\t\tnames := make([]string, len(cyclePath)-1)\n\t\t\t\tfor i, frag := range cyclePath[:len(cyclePath)-1] {\n\t\t\t\t\tnames[i] = frag.Name.Name\n\t\t\t\t}\n\t\t\t\tvia = \" via \" + strings.Join(names, \", \")\n\t\t\t}\n\n\t\t\tlocs := make([]errors.Location, len(cyclePath))\n\t\t\tfor i, frag := range cyclePath {\n\t\t\t\tlocs[i] = frag.Loc\n\t\t\t}\n\t\t\tc.addErrMultiLoc(locs, \"NoFragmentCycles\", \"Cannot spread fragment %q within itself%s.\", frag.Name.Name, via)\n\t\t\treturn\n\t\t}\n\n\t\tif _, ok := fragVisited[frag]; ok {\n\t\t\treturn\n\t\t}\n\t\tfragVisited[frag] = struct{}{}\n\n\t\tspreadPathIndex[frag.Name.Name] = len(spreadPath)\n\t\tdetectFragmentCycle(c, frag.Selections, fragVisited, spreadPath, spreadPathIndex)\n\t\tdelete(spreadPathIndex, frag.Name.Name)\n\n\tdefault:\n\t\tpanic(\"unreachable\")\n\t}\n}\n\nfunc (c *context) validateOverlap(a, b types.Selection, reasons *[]string, locs *[]errors.Location) {\n\tif a == b {\n\t\treturn\n\t}\n\n\tif _, ok := c.overlapValidated[selectionPair{a, b}]; ok {\n\t\treturn\n\t}\n\tc.overlapValidated[selectionPair{a, b}] = struct{}{}\n\tc.overlapValidated[selectionPair{b, a}] = struct{}{}\n\n\tswitch a := a.(type) {\n\tcase *types.Field:\n\t\tswitch b := b.(type) {\n\t\tcase *types.Field:\n\t\t\tif b.Alias.Loc.Before(a.Alias.Loc) {\n\t\t\t\ta, b = b, a\n\t\t\t}\n\t\t\tif reasons2, locs2 := c.validateFieldOverlap(a, b); len(reasons2) != 0 {\n\t\t\t\tlocs2 = append(locs2, a.Alias.Loc, b.Alias.Loc)\n\t\t\t\tif reasons == nil {\n\t\t\t\t\tc.addErrMultiLoc(locs2, \"OverlappingFieldsCanBeMerged\", \"Fields %q conflict because %s. Use different aliases on the fields to fetch both if this was intentional.\", a.Alias.Name, strings.Join(reasons2, \" and \"))\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tfor _, r := range reasons2 {\n\t\t\t\t\t*reasons = append(*reasons, fmt.Sprintf(\"subfields %q conflict because %s\", a.Alias.Name, r))\n\t\t\t\t}\n\t\t\t\t*locs = append(*locs, locs2...)\n\t\t\t}\n\n\t\tcase *types.InlineFragment:\n\t\t\tfor _, sel := range b.Selections {\n\t\t\t\tc.validateOverlap(a, sel, reasons, locs)\n\t\t\t}\n\n\t\tcase *types.FragmentSpread:\n\t\t\tif frag := c.doc.Fragments.Get(b.Name.Name); frag != nil {\n\t\t\t\tfor _, sel := range frag.Selections {\n\t\t\t\t\tc.validateOverlap(a, sel, reasons, locs)\n\t\t\t\t}\n\t\t\t}\n\n\t\tdefault:\n\t\t\tpanic(\"unreachable\")\n\t\t}\n\n\tcase *types.InlineFragment:\n\t\tfor _, sel := range a.Selections {\n\t\t\tc.validateOverlap(sel, b, reasons, locs)\n\t\t}\n\n\tcase *types.FragmentSpread:\n\t\tif frag := c.doc.Fragments.Get(a.Name.Name); frag != nil {\n\t\t\tfor _, sel := range frag.Selections {\n\t\t\t\tc.validateOverlap(sel, b, reasons, locs)\n\t\t\t}\n\t\t}\n\n\tdefault:\n\t\tpanic(\"unreachable\")\n\t}\n}\n\nfunc (c *context) validateFieldOverlap(a, b *types.Field) ([]string, []errors.Location) {\n\tif a.Alias.Name != b.Alias.Name {\n\t\treturn nil, nil\n\t}\n\n\tif asf := c.fieldMap[a].sf; asf != nil {\n\t\tif bsf := c.fieldMap[b].sf; bsf != nil {\n\t\t\tif !typesCompatible(asf.Type, bsf.Type) {\n\t\t\t\treturn []string{fmt.Sprintf(\"they return conflicting types %s and %s\", asf.Type, bsf.Type)}, nil\n\t\t\t}\n\t\t}\n\t}\n\n\tat := c.fieldMap[a].parent\n\tbt := c.fieldMap[b].parent\n\tif at == nil || bt == nil || at == bt {\n\t\tif a.Name.Name != b.Name.Name {\n\t\t\treturn []string{fmt.Sprintf(\"%s and %s are different fields\", a.Name.Name, b.Name.Name)}, nil\n\t\t}\n\n\t\tif argumentsConflict(a.Arguments, b.Arguments) {\n\t\t\treturn []string{\"they have differing arguments\"}, nil\n\t\t}\n\t}\n\n\tvar reasons []string\n\tvar locs []errors.Location\n\tfor _, a2 := range a.SelectionSet {\n\t\tfor _, b2 := range b.SelectionSet {\n\t\t\tc.validateOverlap(a2, b2, &reasons, &locs)\n\t\t}\n\t}\n\treturn reasons, locs\n}\n\nfunc argumentsConflict(a, b types.ArgumentList) bool {\n\tif len(a) != len(b) {\n\t\treturn true\n\t}\n\tfor _, argA := range a {\n\t\tvalB, ok := b.Get(argA.Name.Name)\n\t\tif !ok || !reflect.DeepEqual(argA.Value.Deserialize(nil), valB.Deserialize(nil)) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc fields(t types.Type) types.FieldsDefinition {\n\tswitch t := t.(type) {\n\tcase *types.ObjectTypeDefinition:\n\t\treturn t.Fields\n\tcase *types.InterfaceTypeDefinition:\n\t\treturn t.Fields\n\tdefault:\n\t\treturn nil\n\t}\n}\n\nfunc unwrapType(t types.Type) types.NamedType {\n\tif t == nil {\n\t\treturn nil\n\t}\n\tfor {\n\t\tswitch t2 := t.(type) {\n\t\tcase types.NamedType:\n\t\t\treturn t2\n\t\tcase *types.List:\n\t\t\tt = t2.OfType\n\t\tcase *types.NonNull:\n\t\t\tt = t2.OfType\n\t\tdefault:\n\t\t\tpanic(\"unreachable\")\n\t\t}\n\t}\n}\n\nfunc resolveType(c *context, t types.Type) types.Type {\n\tt2, err := common.ResolveType(t, c.schema.Resolve)\n\tif err != nil {\n\t\tc.errs = append(c.errs, err)\n\t}\n\treturn t2\n}\n\nfunc validateDirectives(c *opContext, loc string, directives types.DirectiveList) {\n\tdirectiveNames := make(nameSet)\n\tfor _, d := range directives {\n\t\tdirName := d.Name.Name\n\t\tvalidateNameCustomMsg(c.context, directiveNames, d.Name, \"UniqueDirectivesPerLocation\", func() string {\n\t\t\treturn fmt.Sprintf(\"The directive %q can only be used once at this location.\", dirName)\n\t\t})\n\n\t\tvalidateArgumentLiterals(c, d.Arguments)\n\n\t\tdd, ok := c.schema.Directives[dirName]\n\t\tif !ok {\n\t\t\tc.addErr(d.Name.Loc, \"KnownDirectives\", \"Unknown directive %q.\", dirName)\n\t\t\tcontinue\n\t\t}\n\n\t\tlocOK := false\n\t\tfor _, allowedLoc := range dd.Locations {\n\t\t\tif loc == allowedLoc {\n\t\t\t\tlocOK = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !locOK {\n\t\t\tc.addErr(d.Name.Loc, \"KnownDirectives\", \"Directive %q may not be used on %s.\", dirName, loc)\n\t\t}\n\n\t\tvalidateArgumentTypes(c, d.Arguments, dd.Arguments, d.Name.Loc,\n\t\t\tfunc() string { return fmt.Sprintf(\"directive %q\", \"@\"+dirName) },\n\t\t\tfunc() string { return fmt.Sprintf(\"Directive %q\", \"@\"+dirName) },\n\t\t)\n\t}\n}\n\nfunc validateName(c *context, set nameSet, name types.Ident, rule string, kind string) {\n\tvalidateNameCustomMsg(c, set, name, rule, func() string {\n\t\treturn fmt.Sprintf(\"There can be only one %s named %q.\", kind, name.Name)\n\t})\n}\n\nfunc validateNameCustomMsg(c *context, set nameSet, name types.Ident, rule string, msg func() string) {\n\tif loc, ok := set[name.Name]; ok {\n\t\tc.addErrMultiLoc([]errors.Location{loc, name.Loc}, rule, msg())\n\t\treturn\n\t}\n\tset[name.Name] = name.Loc\n}\n\nfunc validateArgumentTypes(c *opContext, args types.ArgumentList, argDecls types.ArgumentsDefinition, loc errors.Location, owner1, owner2 func() string) {\n\tfor _, selArg := range args {\n\t\targ := argDecls.Get(selArg.Name.Name)\n\t\tif arg == nil {\n\t\t\tc.addErr(selArg.Name.Loc, \"KnownArgumentNames\", \"Unknown argument %q on %s.\", selArg.Name.Name, owner1())\n\t\t\tcontinue\n\t\t}\n\t\tvalue := selArg.Value\n\t\tif ok, reason := validateValueType(c, value, arg.Type); !ok {\n\t\t\tc.addErr(value.Location(), \"ArgumentsOfCorrectType\", \"Argument %q has invalid value %s.\\n%s\", arg.Name.Name, value, reason)\n\t\t}\n\t}\n\tfor _, decl := range argDecls {\n\t\tif _, ok := decl.Type.(*types.NonNull); ok {\n\t\t\tif _, ok := args.Get(decl.Name.Name); !ok {\n\t\t\t\tc.addErr(loc, \"ProvidedNonNullArguments\", \"%s argument %q of type %q is required but not provided.\", owner2(), decl.Name.Name, decl.Type)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc validateArgumentLiterals(c *opContext, args types.ArgumentList) {\n\targNames := make(nameSet)\n\tfor _, arg := range args {\n\t\tvalidateName(c.context, argNames, arg.Name, \"UniqueArgumentNames\", \"argument\")\n\t\tvalidateLiteral(c, arg.Value)\n\t}\n}\n\nfunc validateLiteral(c *opContext, l types.Value) {\n\tswitch l := l.(type) {\n\tcase *types.ObjectValue:\n\t\tfieldNames := make(nameSet)\n\t\tfor _, f := range l.Fields {\n\t\t\tvalidateName(c.context, fieldNames, f.Name, \"UniqueInputFieldNames\", \"input field\")\n\t\t\tvalidateLiteral(c, f.Value)\n\t\t}\n\tcase *types.ListValue:\n\t\tfor _, entry := range l.Values {\n\t\t\tvalidateLiteral(c, entry)\n\t\t}\n\tcase *types.Variable:\n\t\tfor _, op := range c.ops {\n\t\t\tv := op.Vars.Get(l.Name)\n\t\t\tif v == nil {\n\t\t\t\tbyOp := \"\"\n\t\t\t\tif op.Name.Name != \"\" {\n\t\t\t\t\tbyOp = fmt.Sprintf(\" by operation %q\", op.Name.Name)\n\t\t\t\t}\n\t\t\t\tc.opErrs[op] = append(c.opErrs[op], &errors.QueryError{\n\t\t\t\t\tMessage:   fmt.Sprintf(\"Variable %q is not defined%s.\", \"$\"+l.Name, byOp),\n\t\t\t\t\tLocations: []errors.Location{l.Loc, op.Loc},\n\t\t\t\t\tRule:      \"NoUndefinedVariables\",\n\t\t\t\t})\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tvalidateValueType(c, l, resolveType(c.context, v.Type))\n\t\t\tc.usedVars[op][v] = struct{}{}\n\t\t}\n\t}\n}\n\nfunc validateValueType(c *opContext, v types.Value, t types.Type) (bool, string) {\n\tif v, ok := v.(*types.Variable); ok {\n\t\tfor _, op := range c.ops {\n\t\t\tif v2 := op.Vars.Get(v.Name); v2 != nil {\n\t\t\t\tt2, err := common.ResolveType(v2.Type, c.schema.Resolve)\n\t\t\t\tif _, ok := t2.(*types.NonNull); !ok && v2.Default != nil {\n\t\t\t\t\tt2 = &types.NonNull{OfType: t2}\n\t\t\t\t}\n\t\t\t\tif err == nil && !typeCanBeUsedAs(t2, t) {\n\t\t\t\t\tc.addErrMultiLoc([]errors.Location{v2.Loc, v.Loc}, \"VariablesInAllowedPosition\", \"Variable %q of type %q used in position expecting type %q.\", \"$\"+v.Name, t2, t)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true, \"\"\n\t}\n\n\tif nn, ok := t.(*types.NonNull); ok {\n\t\tif isNull(v) {\n\t\t\treturn false, fmt.Sprintf(\"Expected %q, found null.\", t)\n\t\t}\n\t\tt = nn.OfType\n\t}\n\tif isNull(v) {\n\t\treturn true, \"\"\n\t}\n\n\tswitch t := t.(type) {\n\tcase *types.ScalarTypeDefinition, *types.EnumTypeDefinition:\n\t\tif lit, ok := v.(*types.PrimitiveValue); ok {\n\t\t\tif validateBasicLit(lit, t) {\n\t\t\t\treturn true, \"\"\n\t\t\t}\n\t\t\treturn false, fmt.Sprintf(\"Expected type %q, found %s.\", t, v)\n\t\t}\n\t\treturn true, \"\"\n\n\tcase *types.List:\n\t\tlist, ok := v.(*types.ListValue)\n\t\tif !ok {\n\t\t\treturn validateValueType(c, v, t.OfType) // single value instead of list\n\t\t}\n\t\tfor i, entry := range list.Values {\n\t\t\tif ok, reason := validateValueType(c, entry, t.OfType); !ok {\n\t\t\t\treturn false, fmt.Sprintf(\"In element #%d: %s\", i, reason)\n\t\t\t}\n\t\t}\n\t\treturn true, \"\"\n\n\tcase *types.InputObject:\n\t\tv, ok := v.(*types.ObjectValue)\n\t\tif !ok {\n\t\t\treturn false, fmt.Sprintf(\"Expected %q, found not an object.\", t)\n\t\t}\n\t\tfor _, f := range v.Fields {\n\t\t\tname := f.Name.Name\n\t\t\tiv := t.Values.Get(name)\n\t\t\tif iv == nil {\n\t\t\t\treturn false, fmt.Sprintf(\"In field %q: Unknown field.\", name)\n\t\t\t}\n\t\t\tif ok, reason := validateValueType(c, f.Value, iv.Type); !ok {\n\t\t\t\treturn false, fmt.Sprintf(\"In field %q: %s\", name, reason)\n\t\t\t}\n\t\t}\n\t\tfor _, iv := range t.Values {\n\t\t\tfound := false\n\t\t\tfor _, f := range v.Fields {\n\t\t\t\tif f.Name.Name == iv.Name.Name {\n\t\t\t\t\tfound = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !found {\n\t\t\t\tif _, ok := iv.Type.(*types.NonNull); ok && iv.Default == nil {\n\t\t\t\t\treturn false, fmt.Sprintf(\"In field %q: Expected %q, found null.\", iv.Name.Name, iv.Type)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true, \"\"\n\t}\n\n\treturn false, fmt.Sprintf(\"Expected type %q, found %s.\", t, v)\n}\n\nfunc validateBasicLit(v *types.PrimitiveValue, t types.Type) bool {\n\tswitch t := t.(type) {\n\tcase *types.ScalarTypeDefinition:\n\t\tswitch t.Name {\n\t\tcase \"Int\":\n\t\t\tif v.Type != scanner.Int {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tf, err := strconv.ParseFloat(v.Text, 64)\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\treturn f >= math.MinInt32 && f <= math.MaxInt32\n\t\tcase \"Float\":\n\t\t\treturn v.Type == scanner.Int || v.Type == scanner.Float\n\t\tcase \"String\":\n\t\t\treturn v.Type == scanner.String\n\t\tcase \"Boolean\":\n\t\t\treturn v.Type == scanner.Ident && (v.Text == \"true\" || v.Text == \"false\")\n\t\tcase \"ID\":\n\t\t\treturn v.Type == scanner.Int || v.Type == scanner.String\n\t\tdefault:\n\t\t\t//TODO: Type-check against expected type by Unmarshalling\n\t\t\treturn true\n\t\t}\n\n\tcase *types.EnumTypeDefinition:\n\t\tif v.Type != scanner.Ident {\n\t\t\treturn false\n\t\t}\n\t\tfor _, option := range t.EnumValuesDefinition {\n\t\t\tif option.EnumValue == v.Text {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\n\treturn false\n}\n\nfunc canBeFragment(t types.Type) bool {\n\tswitch t.(type) {\n\tcase *types.ObjectTypeDefinition, *types.InterfaceTypeDefinition, *types.Union:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc canBeInput(t types.Type) bool {\n\tswitch t := t.(type) {\n\tcase *types.InputObject, *types.ScalarTypeDefinition, *types.EnumTypeDefinition:\n\t\treturn true\n\tcase *types.List:\n\t\treturn canBeInput(t.OfType)\n\tcase *types.NonNull:\n\t\treturn canBeInput(t.OfType)\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc hasSubfields(t types.Type) bool {\n\tswitch t := t.(type) {\n\tcase *types.ObjectTypeDefinition, *types.InterfaceTypeDefinition, *types.Union:\n\t\treturn true\n\tcase *types.List:\n\t\treturn hasSubfields(t.OfType)\n\tcase *types.NonNull:\n\t\treturn hasSubfields(t.OfType)\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc isLeaf(t types.Type) bool {\n\tswitch t.(type) {\n\tcase *types.ScalarTypeDefinition, *types.EnumTypeDefinition:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc isNull(lit interface{}) bool {\n\t_, ok := lit.(*types.NullValue)\n\treturn ok\n}\n\nfunc typesCompatible(a, b types.Type) bool {\n\tal, aIsList := a.(*types.List)\n\tbl, bIsList := b.(*types.List)\n\tif aIsList || bIsList {\n\t\treturn aIsList && bIsList && typesCompatible(al.OfType, bl.OfType)\n\t}\n\n\tann, aIsNN := a.(*types.NonNull)\n\tbnn, bIsNN := b.(*types.NonNull)\n\tif aIsNN || bIsNN {\n\t\treturn aIsNN && bIsNN && typesCompatible(ann.OfType, bnn.OfType)\n\t}\n\n\tif isLeaf(a) || isLeaf(b) {\n\t\treturn a == b\n\t}\n\n\treturn true\n}\n\nfunc typeCanBeUsedAs(t, as types.Type) bool {\n\tnnT, okT := t.(*types.NonNull)\n\tif okT {\n\t\tt = nnT.OfType\n\t}\n\n\tnnAs, okAs := as.(*types.NonNull)\n\tif okAs {\n\t\tas = nnAs.OfType\n\t\tif !okT {\n\t\t\treturn false // nullable can not be used as non-null\n\t\t}\n\t}\n\n\tif t == as {\n\t\treturn true\n\t}\n\n\tif lT, ok := t.(*types.List); ok {\n\t\tif lAs, ok := as.(*types.List); ok {\n\t\t\treturn typeCanBeUsedAs(lT.OfType, lAs.OfType)\n\t\t}\n\t}\n\treturn false\n}\n"], "filenames": ["graphql_test.go", "internal/validation/validate_max_depth_test.go", "internal/validation/validation.go"], "buggy_code_start_loc": [4299, 36, 79], "buggy_code_end_loc": [4299, 435, 269], "fixing_code_start_loc": [4300, 37, 79], "fixing_code_end_loc": [4329, 498, 283], "type": "CWE-400", "message": "graphql-go is a GraphQL server with a focus on ease of use. In versions prior to 1.3.0 there exists a DoS vulnerability that is possible due to a bug in the library that would allow an attacker with specifically designed queries to cause stack overflow panics. Any user with access to the GraphQL handler can send these queries and cause stack overflows. This in turn could potentially compromise the ability of the server to serve data to its users. The issue has been patched in version `v1.3.0`. The only known workaround for this issue is to disable the `graphql.MaxDepth` option from your schema which is not recommended.", "other": {"cve": {"id": "CVE-2022-21708", "sourceIdentifier": "security-advisories@github.com", "published": "2022-01-21T23:15:08.457", "lastModified": "2022-01-28T14:10:28.677", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "graphql-go is a GraphQL server with a focus on ease of use. In versions prior to 1.3.0 there exists a DoS vulnerability that is possible due to a bug in the library that would allow an attacker with specifically designed queries to cause stack overflow panics. Any user with access to the GraphQL handler can send these queries and cause stack overflows. This in turn could potentially compromise the ability of the server to serve data to its users. The issue has been patched in version `v1.3.0`. The only known workaround for this issue is to disable the `graphql.MaxDepth` option from your schema which is not recommended."}, {"lang": "es", "value": "graphql-go es un servidor GraphQL con un enfoque en la facilidad de uso. En versiones anteriores a 1.3.0, se presenta una vulnerabilidad DoS posible debido a un fallo en la librer\u00eda que permitir\u00eda a un atacante con consultas espec\u00edficamente dise\u00f1adas causar p\u00e1nicos de desbordamiento de pila. Cualquier usuario con acceso al handler de GraphQL puede enviar estas consultas y causar desbordamientos de pila. Esto, a su vez, podr\u00eda comprometer la capacidad del servidor para servir datos a sus usuarios. El problema ha sido parcheado en la versi\u00f3n \"v1.3.0\". La \u00fanica medida de mitigaci\u00f3n conocida para este problema es deshabilitar la opci\u00f3n \"graphql.MaxDepth\" de su esquema, lo que no es recomendado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:graphql-go_project:graphql-go:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.3.0", "matchCriteriaId": "862B5B19-45A0-4DD1-8A67-F585CE716B1D"}]}]}], "references": [{"url": "https://github.com/graph-gophers/graphql-go/commit/eae31ca73eb3473c544710955d1dbebc22605bfe", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/graph-gophers/graphql-go/security/advisories/GHSA-mh3m-8c74-74xh", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/graph-gophers/graphql-go/commit/eae31ca73eb3473c544710955d1dbebc22605bfe"}}