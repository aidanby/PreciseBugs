{"buggy_code": ["/*\n * uriparser - RFC 3986 URI parsing library\n *\n * Copyright (C) 2007, Weijia Song <songweijia@gmail.com>\n * Copyright (C) 2007, Sebastian Pipping <sebastian@pipping.org>\n * All rights reserved.\n *\n * Redistribution  and use in source and binary forms, with or without\n * modification,  are permitted provided that the following conditions\n * are met:\n *\n *     * Redistributions   of  source  code  must  retain  the   above\n *       copyright  notice, this list of conditions and the  following\n *       disclaimer.\n *\n *     * Redistributions  in  binary  form must  reproduce  the  above\n *       copyright  notice, this list of conditions and the  following\n *       disclaimer   in  the  documentation  and/or  other  materials\n *       provided with the distribution.\n *\n *     * Neither  the name of the <ORGANIZATION> nor the names of  its\n *       contributors  may  be  used to endorse  or  promote  products\n *       derived  from  this software without specific  prior  written\n *       permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS  IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT  NOT\n * LIMITED  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS\n * FOR  A  PARTICULAR  PURPOSE ARE DISCLAIMED. IN NO EVENT  SHALL  THE\n * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL,    SPECIAL,   EXEMPLARY,   OR   CONSEQUENTIAL   DAMAGES\n * (INCLUDING,  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT  LIABILITY,  OR  TORT (INCLUDING  NEGLIGENCE  OR  OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* What encodings are enabled? */\n#include <uriparser/UriDefsConfig.h>\n#if (!defined(URI_PASS_ANSI) && !defined(URI_PASS_UNICODE))\n/* Include SELF twice */\n# ifdef URI_ENABLE_ANSI\n#  define URI_PASS_ANSI 1\n#  include \"UriQuery.c\"\n#  undef URI_PASS_ANSI\n# endif\n# ifdef URI_ENABLE_UNICODE\n#  define URI_PASS_UNICODE 1\n#  include \"UriQuery.c\"\n#  undef URI_PASS_UNICODE\n# endif\n#else\n# ifdef URI_PASS_ANSI\n#  include <uriparser/UriDefsAnsi.h>\n# else\n#  include <uriparser/UriDefsUnicode.h>\n#  include <wchar.h>\n# endif\n\n\n\n#ifndef URI_DOXYGEN\n# include <uriparser/Uri.h>\n# include \"UriCommon.h\"\n#endif\n\n\n\nstatic int URI_FUNC(ComposeQueryEngine)(URI_CHAR * dest,\n\t\tconst URI_TYPE(QueryList) * queryList,\n\t\tint maxChars, int * charsWritten, int * charsRequired,\n\t\tUriBool spaceToPlus, UriBool normalizeBreaks);\n\nstatic UriBool URI_FUNC(AppendQueryItem)(URI_TYPE(QueryList) ** prevNext,\n\t\tint * itemCount, const URI_CHAR * keyFirst, const URI_CHAR * keyAfter,\n\t\tconst URI_CHAR * valueFirst, const URI_CHAR * valueAfter,\n\t\tUriBool plusToSpace, UriBreakConversion breakConversion);\n\n\n\nint URI_FUNC(ComposeQueryCharsRequired)(const URI_TYPE(QueryList) * queryList,\n\t\tint * charsRequired) {\n\tconst UriBool spaceToPlus = URI_TRUE;\n\tconst UriBool normalizeBreaks = URI_TRUE;\n\n\treturn URI_FUNC(ComposeQueryCharsRequiredEx)(queryList, charsRequired,\n\t\t\tspaceToPlus, normalizeBreaks);\n}\n\n\n\nint URI_FUNC(ComposeQueryCharsRequiredEx)(const URI_TYPE(QueryList) * queryList,\n\t\tint * charsRequired, UriBool spaceToPlus, UriBool normalizeBreaks) {\n\tif ((queryList == NULL) || (charsRequired == NULL)) {\n\t\treturn URI_ERROR_NULL;\n\t}\n\n\treturn URI_FUNC(ComposeQueryEngine)(NULL, queryList, 0, NULL,\n\t\t\tcharsRequired, spaceToPlus, normalizeBreaks);\n}\n\n\n\nint URI_FUNC(ComposeQuery)(URI_CHAR * dest,\n\t\t\t\t\t\t   const URI_TYPE(QueryList) * queryList, int maxChars, int * charsWritten) {\n\tconst UriBool spaceToPlus = URI_TRUE;\n\tconst UriBool normalizeBreaks = URI_TRUE;\n\n\treturn URI_FUNC(ComposeQueryEx)(dest, queryList, maxChars, charsWritten,\n\t\t\tspaceToPlus, normalizeBreaks);\n}\n\n\n\nint URI_FUNC(ComposeQueryEx)(URI_CHAR * dest,\n\t\tconst URI_TYPE(QueryList) * queryList, int maxChars, int * charsWritten,\n\t\tUriBool spaceToPlus, UriBool normalizeBreaks) {\n\tif ((dest == NULL) || (queryList == NULL)) {\n\t\treturn URI_ERROR_NULL;\n\t}\n\n\tif (maxChars < 1) {\n\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t}\n\n\treturn URI_FUNC(ComposeQueryEngine)(dest, queryList, maxChars,\n\t\t\tcharsWritten, NULL, spaceToPlus, normalizeBreaks);\n}\n\n\n\nint URI_FUNC(ComposeQueryMalloc)(URI_CHAR ** dest,\n\t\tconst URI_TYPE(QueryList) * queryList) {\n\tconst UriBool spaceToPlus = URI_TRUE;\n\tconst UriBool normalizeBreaks = URI_TRUE;\n\n\treturn URI_FUNC(ComposeQueryMallocEx)(dest, queryList,\n\t\t\tspaceToPlus, normalizeBreaks);\n}\n\n\n\nint URI_FUNC(ComposeQueryMallocEx)(URI_CHAR ** dest,\n\t\tconst URI_TYPE(QueryList) * queryList,\n\t\tUriBool spaceToPlus, UriBool normalizeBreaks) {\n\tint charsRequired;\n\tint res;\n\tURI_CHAR * queryString;\n\n\tif (dest == NULL) {\n\t\treturn URI_ERROR_NULL;\n\t}\n\n\t/* Calculate space */\n\tres = URI_FUNC(ComposeQueryCharsRequiredEx)(queryList, &charsRequired,\n\t\t\tspaceToPlus, normalizeBreaks);\n\tif (res != URI_SUCCESS) {\n\t\treturn res;\n\t}\n\tcharsRequired++;\n\n\t/* Allocate space */\n\tqueryString = malloc(charsRequired * sizeof(URI_CHAR));\n\tif (queryString == NULL) {\n\t\treturn URI_ERROR_MALLOC;\n\t}\n\n\t/* Put query in */\n\tres = URI_FUNC(ComposeQueryEx)(queryString, queryList, charsRequired,\n\t\t\tNULL, spaceToPlus, normalizeBreaks);\n\tif (res != URI_SUCCESS) {\n\t\tfree(queryString);\n\t\treturn res;\n\t}\n\n\t*dest = queryString;\n\treturn URI_SUCCESS;\n}\n\n\n\nint URI_FUNC(ComposeQueryEngine)(URI_CHAR * dest,\n\t\tconst URI_TYPE(QueryList) * queryList,\n\t\tint maxChars, int * charsWritten, int * charsRequired,\n\t\tUriBool spaceToPlus, UriBool normalizeBreaks) {\n\tUriBool firstItem = URI_TRUE;\n\tint ampersandLen = 0;  /* increased to 1 from second item on */\n\tURI_CHAR * write = dest;\n\n\t/* Subtract terminator */\n\tif (dest == NULL) {\n\t\t*charsRequired = 0;\n\t} else {\n\t\tmaxChars--;\n\t}\n\t\t\t\n\twhile (queryList != NULL) {\n\t\tconst URI_CHAR * const key = queryList->key;\n\t\tconst URI_CHAR * const value = queryList->value;\n\t\tconst int worstCase = (normalizeBreaks == URI_TRUE ? 6 : 3);\n\t\tconst int keyLen = (key == NULL) ? 0 : (int)URI_STRLEN(key);\n\t\tconst int keyRequiredChars = worstCase * keyLen;\n\t\tconst int valueLen = (value == NULL) ? 0 : (int)URI_STRLEN(value);\n\t\tconst int valueRequiredChars = worstCase * valueLen;\n\n\t\tif (dest == NULL) {\n\t\t\tif (firstItem == URI_TRUE) {\n\t\t\t\tampersandLen = 1;\n\t\t\t\tfirstItem = URI_FALSE;\n\t\t\t}\n\n\t\t\t(*charsRequired) += ampersandLen + keyRequiredChars + ((value == NULL)\n\t\t\t\t\t\t? 0\n\t\t\t\t\t\t: 1 + valueRequiredChars);\n\t\t} else {\n\t\t\tURI_CHAR * afterKey;\n\n\t\t\tif ((write - dest) + ampersandLen + keyRequiredChars > maxChars) {\n\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t\t}\n\n\t\t\t/* Copy key */\n\t\t\tif (firstItem == URI_TRUE) {\n\t\t\t\tfirstItem = URI_FALSE;\n\t\t\t} else {\n\t\t\t\twrite[0] = _UT('&');\n\t\t\t\twrite++;\n\t\t\t}\n\t\t\tafterKey = URI_FUNC(EscapeEx)(key, key + keyLen,\n\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);\n\t\t\twrite += (afterKey - write);\n\n\t\t\tif (value != NULL) {\n\t\t\t\tURI_CHAR * afterValue;\n\n\t\t\t\tif ((write - dest) + 1 + valueRequiredChars > maxChars) {\n\t\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t\t\t}\n\n\t\t\t\t/* Copy value */\n\t\t\t\twrite[0] = _UT('=');\n\t\t\t\twrite++;\n\t\t\t\tafterValue = URI_FUNC(EscapeEx)(value, value + valueLen,\n\t\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);\n\t\t\t\twrite += (afterValue - write);\n\t\t\t}\n\t\t}\n\n\t\tqueryList = queryList->next;\n\t}\n\n\tif (dest != NULL) {\n\t\twrite[0] = _UT('\\0');\n\t\tif (charsWritten != NULL) {\n\t\t\t*charsWritten = (int)(write - dest) + 1; /* .. for terminator */\n\t\t}\n\t}\n\n\treturn URI_SUCCESS;\n}\n\n\n\nUriBool URI_FUNC(AppendQueryItem)(URI_TYPE(QueryList) ** prevNext,\n\t\tint * itemCount, const URI_CHAR * keyFirst, const URI_CHAR * keyAfter,\n\t\tconst URI_CHAR * valueFirst, const URI_CHAR * valueAfter,\n\t\tUriBool plusToSpace, UriBreakConversion breakConversion) {\n\tconst int keyLen = (int)(keyAfter - keyFirst);\n\tconst int valueLen = (int)(valueAfter - valueFirst);\n\tURI_CHAR * key;\n\tURI_CHAR * value;\n\n\tif ((prevNext == NULL) || (itemCount == NULL)\n\t\t\t|| (keyFirst == NULL) || (keyAfter == NULL)\n\t\t\t|| (keyFirst > keyAfter) || (valueFirst > valueAfter)\n\t\t\t|| ((keyFirst == keyAfter)\n\t\t\t\t&& (valueFirst == NULL) && (valueAfter == NULL))) {\n\t\treturn URI_TRUE;\n\t}\n\n\t/* Append new empty item */\n\t*prevNext = malloc(1 * sizeof(URI_TYPE(QueryList)));\n\tif (*prevNext == NULL) {\n\t\treturn URI_FALSE; /* Raises malloc error */\n\t}\n\t(*prevNext)->next = NULL;\n\n\n\t/* Fill key */\n\tkey = malloc((keyLen + 1) * sizeof(URI_CHAR));\n\tif (key == NULL) {\n\t\tfree(*prevNext);\n\t\t*prevNext = NULL;\n\t\treturn URI_FALSE; /* Raises malloc error */\n\t}\n\n\tkey[keyLen] = _UT('\\0');\n\tif (keyLen > 0) {\n\t\t/* Copy 1:1 */\n\t\tmemcpy(key, keyFirst, keyLen * sizeof(URI_CHAR));\n\n\t\t/* Unescape */\n\t\tURI_FUNC(UnescapeInPlaceEx)(key, plusToSpace, breakConversion);\n\t}\n\t(*prevNext)->key = key;\n\n\n\t/* Fill value */\n\tif (valueFirst != NULL) {\n\t\tvalue = malloc((valueLen + 1) * sizeof(URI_CHAR));\n\t\tif (value == NULL) {\n\t\t\tfree(key);\n\t\t\tfree(*prevNext);\n\t\t\t*prevNext = NULL;\n\t\t\treturn URI_FALSE; /* Raises malloc error */\n\t\t}\n\n\t\tvalue[valueLen] = _UT('\\0');\n\t\tif (valueLen > 0) {\n\t\t\t/* Copy 1:1 */\n\t\t\tmemcpy(value, valueFirst, valueLen * sizeof(URI_CHAR));\n\n\t\t\t/* Unescape */\n\t\t\tURI_FUNC(UnescapeInPlaceEx)(value, plusToSpace, breakConversion);\n\t\t}\n\t\t(*prevNext)->value = value;\n\t} else {\n\t\tvalue = NULL;\n\t}\n\t(*prevNext)->value = value;\n\n\t(*itemCount)++;\n\treturn URI_TRUE;\n}\n\n\n\nvoid URI_FUNC(FreeQueryList)(URI_TYPE(QueryList) * queryList) {\n\twhile (queryList != NULL) {\n\t\tURI_TYPE(QueryList) * nextBackup = queryList->next;\n\t\tfree((URI_CHAR *)queryList->key); /* const cast */\n\t\tfree((URI_CHAR *)queryList->value); /* const cast */\n\t\tfree(queryList);\n\t\tqueryList = nextBackup;\n\t}\n}\n\n\n\nint URI_FUNC(DissectQueryMalloc)(URI_TYPE(QueryList) ** dest, int * itemCount,\n\t\tconst URI_CHAR * first, const URI_CHAR * afterLast) {\n\tconst UriBool plusToSpace = URI_TRUE;\n\tconst UriBreakConversion breakConversion = URI_BR_DONT_TOUCH;\n\n\treturn URI_FUNC(DissectQueryMallocEx)(dest, itemCount, first, afterLast,\n\t\t\tplusToSpace, breakConversion);\n}\n\n\n\nint URI_FUNC(DissectQueryMallocEx)(URI_TYPE(QueryList) ** dest, int * itemCount,\n\t\tconst URI_CHAR * first, const URI_CHAR * afterLast,\n\t\tUriBool plusToSpace, UriBreakConversion breakConversion) {\n\tconst URI_CHAR * walk = first;\n\tconst URI_CHAR * keyFirst = first;\n\tconst URI_CHAR * keyAfter = NULL;\n\tconst URI_CHAR * valueFirst = NULL;\n\tconst URI_CHAR * valueAfter = NULL;\n\tURI_TYPE(QueryList) ** prevNext = dest;\n\tint nullCounter;\n\tint * itemsAppended = (itemCount == NULL) ? &nullCounter : itemCount;\n\n\tif ((dest == NULL) || (first == NULL) || (afterLast == NULL)) {\n\t\treturn URI_ERROR_NULL;\n\t}\n\n\tif (first > afterLast) {\n\t\treturn URI_ERROR_RANGE_INVALID;\n\t}\n\n\t*dest = NULL;\n\t*itemsAppended = 0;\n\n\t/* Parse query string */\n\tfor (; walk < afterLast; walk++) {\n\t\tswitch (*walk) {\n\t\tcase _UT('&'):\n\t\t\tif (valueFirst != NULL) {\n\t\t\t\tvalueAfter = walk;\n\t\t\t} else {\n\t\t\t\tkeyAfter = walk;\n\t\t\t}\n\n\t\t\tif (URI_FUNC(AppendQueryItem)(prevNext, itemsAppended,\n\t\t\t\t\tkeyFirst, keyAfter, valueFirst, valueAfter,\n\t\t\t\t\tplusToSpace, breakConversion)\n\t\t\t\t\t== URI_FALSE) {\n\t\t\t\t/* Free list we built */\n\t\t\t\t*itemsAppended = 0;\n\t\t\t\tURI_FUNC(FreeQueryList)(*dest);\n\t\t\t\treturn URI_ERROR_MALLOC;\n\t\t\t}\n\n\t\t\t/* Make future items children of the current */\n\t\t\tif ((prevNext != NULL) && (*prevNext != NULL)) {\n\t\t\t\tprevNext = &((*prevNext)->next);\n\t\t\t}\n\n\t\t\tif (walk + 1 < afterLast) {\n\t\t\t\tkeyFirst = walk + 1;\n\t\t\t} else {\n\t\t\t\tkeyFirst = NULL;\n\t\t\t}\n\t\t\tkeyAfter = NULL;\n\t\t\tvalueFirst = NULL;\n\t\t\tvalueAfter = NULL;\n\t\t\tbreak;\n\n\t\tcase _UT('='):\n\t\t\t/* NOTE: WE treat the first '=' as a separator, */\n\t\t\t/*       all following go into the value part   */\n\t\t\tif (keyAfter == NULL) {\n\t\t\t\tkeyAfter = walk;\n\t\t\t\tif (walk + 1 <= afterLast) {\n\t\t\t\t\tvalueFirst = walk + 1;\n\t\t\t\t\tvalueAfter = walk + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (valueFirst != NULL) {\n\t\t/* Must be key/value pair */\n\t\tvalueAfter = walk;\n\t} else {\n\t\t/* Must be key only */\n\t\tkeyAfter = walk;\n\t}\n\n\tif (URI_FUNC(AppendQueryItem)(prevNext, itemsAppended, keyFirst, keyAfter,\n\t\t\tvalueFirst, valueAfter, plusToSpace, breakConversion)\n\t\t\t== URI_FALSE) {\n\t\t/* Free list we built */\n\t\t*itemsAppended = 0;\n\t\tURI_FUNC(FreeQueryList)(*dest);\n\t\treturn URI_ERROR_MALLOC;\n\t}\n\n\treturn URI_SUCCESS;\n}\n\n\n\n#endif\n", "/*\n * uriparser - RFC 3986 URI parsing library\n *\n * Copyright (C) 2007, Weijia Song <songweijia@gmail.com>\n * Copyright (C) 2007, Sebastian Pipping <sebastian@pipping.org>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#include <uriparser/Uri.h>\n#include <cpptest.h>\n#include <memory>\n#include <stdio.h>\n#include <stdlib.h>\n#include <wchar.h>\n\n#include \"FourSuite.h\"\n#include \"VersionSuite.h\"\n\nusing namespace Test;\nusing namespace std;\n\n\n\nextern \"C\" {\nUriBool uri_TESTING_ONLY_ParseIpSixA(const char * text);\nUriBool uri_TESTING_ONLY_ParseIpFourA(const char * text);\nint uriCompareRangeA(const UriTextRangeA * a, const UriTextRangeA * b);\n}\n\n\n\n#define URI_TEST_IP_FOUR_FAIL(x) TEST_ASSERT(URI_FALSE == uri_TESTING_ONLY_ParseIpFourA(x))\n#define URI_TEST_IP_FOUR_PASS(x) TEST_ASSERT(URI_TRUE == uri_TESTING_ONLY_ParseIpFourA(x))\n\n// Note the closing brackets! TODO\n#define URI_TEST_IP_SIX_FAIL(x) TEST_ASSERT(URI_FALSE == uri_TESTING_ONLY_ParseIpSixA(x \"]\"))\n#define URI_TEST_IP_SIX_PASS(x) TEST_ASSERT(URI_TRUE == uri_TESTING_ONLY_ParseIpSixA(x \"]\"))\n\n\n\nclass UriSuite : public Suite {\n\npublic:\n\tUriSuite() {\n\t\tTEST_ADD(UriSuite::testDistinction)\n\t\tTEST_ADD(UriSuite::testIpFour)\n\t\tTEST_ADD(UriSuite::testIpSixPass)\n\t\tTEST_ADD(UriSuite::testIpSixFail)\n\t\tTEST_ADD(UriSuite::testUri)\n\t\tTEST_ADD(UriSuite::testUriUserInfoHostPort1)\n\t\tTEST_ADD(UriSuite::testUriUserInfoHostPort2)\n\t\tTEST_ADD(UriSuite::testUriUserInfoHostPort22_Bug1948038)\n\t\tTEST_ADD(UriSuite::testUriUserInfoHostPort23_Bug3510198_1)\n\t\tTEST_ADD(UriSuite::testUriUserInfoHostPort23_Bug3510198_2)\n\t\tTEST_ADD(UriSuite::testUriUserInfoHostPort23_Bug3510198_3)\n\t\tTEST_ADD(UriSuite::testUriUserInfoHostPort23_Bug3510198_4)\n\t\tTEST_ADD(UriSuite::testUriUserInfoHostPort23_Bug3510198_related_1)\n\t\tTEST_ADD(UriSuite::testUriUserInfoHostPort23_Bug3510198_related_12)\n\t\tTEST_ADD(UriSuite::testUriUserInfoHostPort23_Bug3510198_related_2)\n\t\tTEST_ADD(UriSuite::testUriUserInfoHostPort3)\n\t\tTEST_ADD(UriSuite::testUriUserInfoHostPort4)\n\t\tTEST_ADD(UriSuite::testUriUserInfoHostPort5)\n\t\tTEST_ADD(UriSuite::testUriUserInfoHostPort6)\n\t\tTEST_ADD(UriSuite::testUriHostRegname)\n\t\tTEST_ADD(UriSuite::testUriHostIpFour1)\n\t\tTEST_ADD(UriSuite::testUriHostIpFour2)\n\t\tTEST_ADD(UriSuite::testUriHostIpSix1)\n\t\tTEST_ADD(UriSuite::testUriHostIpSix2)\n\t\tTEST_ADD(UriSuite::testUriHostIpFuture)\n\t\tTEST_ADD(UriSuite::testUriHostEmpty)\n\t\tTEST_ADD(UriSuite::testUriComponents)\n\t\tTEST_ADD(UriSuite::testUriComponents_Bug20070701)\n\t\tTEST_ADD(UriSuite::testEscaping)\n\t\tTEST_ADD(UriSuite::testUnescaping)\n\t\tTEST_ADD(UriSuite::testTrailingSlash)\n\t\tTEST_ADD(UriSuite::testAddBase)\n\t\tTEST_ADD(UriSuite::testToString)\n\t\tTEST_ADD(UriSuite::testToString_Bug1950126)\n\t\tTEST_ADD(UriSuite::testToStringCharsRequired)\n\t\tTEST_ADD(UriSuite::testToStringCharsRequired)\n\t\tTEST_ADD(UriSuite::testNormalizeSyntaxMaskRequired)\n\t\tTEST_ADD(UriSuite::testNormalizeSyntax)\n\t\tTEST_ADD(UriSuite::testNormalizeSyntaxComponents)\n\t\tTEST_ADD(UriSuite::testNormalizeCrash_Bug20080224)\n\t\tTEST_ADD(UriSuite::testFilenameUriConversion)\n\t\tTEST_ADD(UriSuite::testCrash_FreeUriMembers_Bug20080116)\n\t\tTEST_ADD(UriSuite::testCrash_Report2418192)\n\t\tTEST_ADD(UriSuite::testPervertedQueryString);\n\t\tTEST_ADD(UriSuite::testQueryStringEndingInEqualSign_NonBug32);\n\t\tTEST_ADD(UriSuite::testCrash_MakeOwner_Bug20080207)\n\t\tTEST_ADD(UriSuite::testQueryList)\n\t\tTEST_ADD(UriSuite::testQueryListPair)\n\t\tTEST_ADD(UriSuite::testQueryDissection_Bug3590761)\n\t\tTEST_ADD(UriSuite::testFreeCrash_Bug20080827)\n\t\tTEST_ADD(UriSuite::testParseInvalid_Bug16)\n\t\tTEST_ADD(UriSuite::testRangeComparison)\n\t\tTEST_ADD(UriSuite::testRangeComparison_RemoveBaseUri_Issue19)\n\t\tTEST_ADD(UriSuite::testEquals)\n\t\tTEST_ADD(UriSuite::testHostTextTermination_Issue15)\n\t}\n\nprivate:\n\tbool testDistinctionHelper(const char * uriText, bool expectedHostSet,\n\t\t\tbool expectedAbsPath, bool expectedEmptyTailSegment) {\n\t\tUriParserStateA state;\n\t\tUriUriA uri;\n\t\tstate.uri = &uri;\n\n\t\tint res = uriParseUriA(&state, uriText);\n\t\tif (res != URI_SUCCESS) {\n\t\t\turiFreeUriMembersA(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (expectedHostSet != (uri.hostText.first != NULL)) {\n\t\t\turiFreeUriMembersA(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (expectedAbsPath != (uri.absolutePath == URI_TRUE)) {\n\t\t\turiFreeUriMembersA(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (expectedEmptyTailSegment != ((uri.pathTail != NULL)\n\t\t\t\t&& (uri.pathTail->text.first == uri.pathTail->text.afterLast))) {\n\t\t\turiFreeUriMembersA(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\turiFreeUriMembersA(&uri);\n\t\treturn true;\n\t}\n\n\tvoid testDistinction() {\n\t\t/*\n============================================================================\nRule                                | Example | hostSet | absPath | emptySeg\n------------------------------------|---------|---------|---------|---------\n1) URI = scheme \":\" hier-part ...   |         |         |         |\n   1) \"//\" authority path-abempty   | \"s://\"  | true    |   false |   false\n                                    | \"s:///\" | true    |   false | true\n                                    | \"s://a\" | true    |   false |   false\n                                    | \"s://a/\"| true    |   false | true\n   2) path-absolute                 | \"s:/\"   |   false | true    |   false\n   3) path-rootless                 | \"s:a\"   |   false |   false |   false\n                                    | \"s:a/\"  |   false |   false | true\n   4) path-empty                    | \"s:\"    |   false |   false |   false\n------------------------------------|---------|---------|---------|---------\n2) relative-ref = relative-part ... |         |         |         |\n   1) \"//\" authority path-abempty   | \"//\"    | true    |   false |   false\n                                    | \"///\"   | true    |   false | true\n   2) path-absolute                 | \"/\"     |   false | true    |   false\n   3) path-noscheme                 | \"a\"     |   false |   false |   false\n                                    | \"a/\"    |   false |   false | true\n   4) path-empty                    | \"\"      |   false |   false |   false\n============================================================================\n\t\t*/\n\t\tTEST_ASSERT(testDistinctionHelper(\"s://\", true, false, false));\n\t\tTEST_ASSERT(testDistinctionHelper(\"s:///\", true, false, true));\n\t\tTEST_ASSERT(testDistinctionHelper(\"s://a\", true, false, false));\n\t\tTEST_ASSERT(testDistinctionHelper(\"s://a/\", true, false, true));\n\t\tTEST_ASSERT(testDistinctionHelper(\"s:/\", false, true, false));\n\t\tTEST_ASSERT(testDistinctionHelper(\"s:a\", false, false, false));\n\t\tTEST_ASSERT(testDistinctionHelper(\"s:a/\", false, false, true));\n\t\tTEST_ASSERT(testDistinctionHelper(\"s:\", false, false, false));\n\n\t\tTEST_ASSERT(testDistinctionHelper(\"//\", true, false, false));\n\t\tTEST_ASSERT(testDistinctionHelper(\"///\", true, false, true));\n\t\tTEST_ASSERT(testDistinctionHelper(\"/\", false, true, false));\n\t\tTEST_ASSERT(testDistinctionHelper(\"a\", false, false, false));\n\t\tTEST_ASSERT(testDistinctionHelper(\"a/\", false, false, true));\n\t\tTEST_ASSERT(testDistinctionHelper(\"\", false, false, false));\n\t}\n\n\tvoid testIpFour() {\n\t\tURI_TEST_IP_FOUR_FAIL(\"01.0.0.0\");\n\t\tURI_TEST_IP_FOUR_FAIL(\"001.0.0.0\");\n\t\tURI_TEST_IP_FOUR_FAIL(\"00.0.0.0\");\n\t\tURI_TEST_IP_FOUR_FAIL(\"000.0.0.0\");\n\t\tURI_TEST_IP_FOUR_FAIL(\"256.0.0.0\");\n\t\tURI_TEST_IP_FOUR_FAIL(\"300.0.0.0\");\n\t\tURI_TEST_IP_FOUR_FAIL(\"1111.0.0.0\");\n\t\tURI_TEST_IP_FOUR_FAIL(\"-1.0.0.0\");\n\t\tURI_TEST_IP_FOUR_FAIL(\"0.0.0\");\n\t\tURI_TEST_IP_FOUR_FAIL(\"0.0.0.\");\n\t\tURI_TEST_IP_FOUR_FAIL(\"0.0.0.0.\");\n\t\tURI_TEST_IP_FOUR_FAIL(\"0.0.0.0.0\");\n\t\tURI_TEST_IP_FOUR_FAIL(\"0.0..0\");\n\t\tURI_TEST_IP_FOUR_FAIL(\".0.0.0\");\n\n\t\tURI_TEST_IP_FOUR_PASS(\"255.0.0.0\");\n\t\tURI_TEST_IP_FOUR_PASS(\"0.0.0.0\");\n\t\tURI_TEST_IP_FOUR_PASS(\"1.0.0.0\");\n\t\tURI_TEST_IP_FOUR_PASS(\"2.0.0.0\");\n\t\tURI_TEST_IP_FOUR_PASS(\"3.0.0.0\");\n\t\tURI_TEST_IP_FOUR_PASS(\"30.0.0.0\");\n\t}\n\n\tvoid testIpSixPass() {\n\t\t// Quad length\n\t\tURI_TEST_IP_SIX_PASS(\"abcd::\");\n\n\t\tURI_TEST_IP_SIX_PASS(\"abcd::1\");\n\t\tURI_TEST_IP_SIX_PASS(\"abcd::12\");\n\t\tURI_TEST_IP_SIX_PASS(\"abcd::123\");\n\t\tURI_TEST_IP_SIX_PASS(\"abcd::1234\");\n\n\t\t// Full length\n\t\tURI_TEST_IP_SIX_PASS(\"2001:0db8:0100:f101:0210:a4ff:fee3:9566\"); // lower hex\n\t\tURI_TEST_IP_SIX_PASS(\"2001:0DB8:0100:F101:0210:A4FF:FEE3:9566\"); // Upper hex\n\t\tURI_TEST_IP_SIX_PASS(\"2001:db8:100:f101:210:a4ff:fee3:9566\");\n\t\tURI_TEST_IP_SIX_PASS(\"2001:0db8:100:f101:0:0:0:1\");\n\t\tURI_TEST_IP_SIX_PASS(\"1:2:3:4:5:6:255.255.255.255\");\n\n\t\t// Legal IPv4\n\t\tURI_TEST_IP_SIX_PASS(\"::1.2.3.4\");\n\t\tURI_TEST_IP_SIX_PASS(\"3:4::5:1.2.3.4\");\n\t\tURI_TEST_IP_SIX_PASS(\"::ffff:1.2.3.4\");\n\t\tURI_TEST_IP_SIX_PASS(\"::0.0.0.0\"); // Min IPv4\n\t\tURI_TEST_IP_SIX_PASS(\"::255.255.255.255\"); // Max IPv4\n\n\t\t// Zipper position\n\t\tURI_TEST_IP_SIX_PASS(\"::1:2:3:4:5:6:7\");\n\t\tURI_TEST_IP_SIX_PASS(\"1::1:2:3:4:5:6\");\n\t\tURI_TEST_IP_SIX_PASS(\"1:2::1:2:3:4:5\");\n\t\tURI_TEST_IP_SIX_PASS(\"1:2:3::1:2:3:4\");\n\t\tURI_TEST_IP_SIX_PASS(\"1:2:3:4::1:2:3\");\n\t\tURI_TEST_IP_SIX_PASS(\"1:2:3:4:5::1:2\");\n\t\tURI_TEST_IP_SIX_PASS(\"1:2:3:4:5:6::1\");\n\t\tURI_TEST_IP_SIX_PASS(\"1:2:3:4:5:6:7::\");\n\n\t\t// Zipper length\n\t\tURI_TEST_IP_SIX_PASS(\"1:1:1::1:1:1:1\");\n\t\tURI_TEST_IP_SIX_PASS(\"1:1:1::1:1:1\");\n\t\tURI_TEST_IP_SIX_PASS(\"1:1:1::1:1\");\n\t\tURI_TEST_IP_SIX_PASS(\"1:1::1:1\");\n\t\tURI_TEST_IP_SIX_PASS(\"1:1::1\");\n\t\tURI_TEST_IP_SIX_PASS(\"1::1\");\n\t\tURI_TEST_IP_SIX_PASS(\"::1\"); // == localhost\n\t\tURI_TEST_IP_SIX_PASS(\"::\"); // == all addresses\n\n\t\t// A few more variations\n\t\tURI_TEST_IP_SIX_PASS(\"21ff:abcd::1\");\n\t\tURI_TEST_IP_SIX_PASS(\"2001:db8:100:f101::1\");\n\t\tURI_TEST_IP_SIX_PASS(\"a:b:c::12:1\");\n\t\tURI_TEST_IP_SIX_PASS(\"a:b::0:1:2:3\");\n\t}\n\n\tvoid testIpSixFail() {\n\t\t// 5 char quad\n\t\tURI_TEST_IP_SIX_FAIL(\"::12345\");\n\n\t\t// Two zippers\n\t\tURI_TEST_IP_SIX_FAIL(\"abcd::abcd::abcd\");\n\n\t\t// Triple-colon zipper\n\t\tURI_TEST_IP_SIX_FAIL(\":::1234\");\n\t\tURI_TEST_IP_SIX_FAIL(\"1234:::1234:1234\");\n\t\tURI_TEST_IP_SIX_FAIL(\"1234:1234:::1234\");\n\t\tURI_TEST_IP_SIX_FAIL(\"1234:::\");\n\n\t\t// No quads, just IPv4\n\t\tURI_TEST_IP_SIX_FAIL(\"1.2.3.4\");\n\t\tURI_TEST_IP_SIX_FAIL(\"0001.0002.0003.0004\");\n\n\t\t// Five quads\n\t\tURI_TEST_IP_SIX_FAIL(\"0000:0000:0000:0000:0000:1.2.3.4\");\n\n\t\t// Seven quads\n\t\tURI_TEST_IP_SIX_FAIL(\"0:0:0:0:0:0:0\");\n\t\tURI_TEST_IP_SIX_FAIL(\"0:0:0:0:0:0:0:\");\n\t\tURI_TEST_IP_SIX_FAIL(\"0:0:0:0:0:0:0:1.2.3.4\");\n\n\t\t// Nine quads (or more)\n\t\tURI_TEST_IP_SIX_FAIL(\"1:2:3:4:5:6:7:8:9\");\n\t\tURI_TEST_IP_SIX_FAIL(\"::2:3:4:5:6:7:8:9\");\n\t\tURI_TEST_IP_SIX_FAIL(\"1:2:3:4::6:7:8:9\");\n\t\tURI_TEST_IP_SIX_FAIL(\"1:2:3:4:5:6:7:8::\");\n\n\t\t// Invalid IPv4 part\n\t\tURI_TEST_IP_SIX_FAIL(\"::ffff:001.02.03.004\"); // Leading zeros\n\t\tURI_TEST_IP_SIX_FAIL(\"::ffff:1.2.3.1111\"); // Four char octet\n\t\tURI_TEST_IP_SIX_FAIL(\"::ffff:1.2.3.256\"); // > 255\n\t\tURI_TEST_IP_SIX_FAIL(\"::ffff:311.2.3.4\"); // > 155\n\t\tURI_TEST_IP_SIX_FAIL(\"::ffff:1.2.3:4\"); // Not a dot\n\t\tURI_TEST_IP_SIX_FAIL(\"::ffff:1.2.3\"); // Missing octet\n\t\tURI_TEST_IP_SIX_FAIL(\"::ffff:1.2.3.\"); // Missing octet\n\t\tURI_TEST_IP_SIX_FAIL(\"::ffff:1.2.3a.4\"); // Hex in octet\n\t\tURI_TEST_IP_SIX_FAIL(\"::ffff:1.2.3.4:123\"); // Crap input\n\n\t\t// Nonhex\n\t\tURI_TEST_IP_SIX_FAIL(\"g:0:0:0:0:0:0\");\n\t}\n\n\tvoid testUri() {\n\t\tUriParserStateA stateA;\n\t\tUriParserStateW stateW;\n\t\tUriUriA uriA;\n\t\tUriUriW uriW;\n\n\t\tstateA.uri = &uriA;\n\t\tstateW.uri = &uriW;\n\n\t\t// On/off for each\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, \"//user:pass@[::1]:80/segment/index.html?query#frag\"));\n\t\turiFreeUriMembersA(&uriA);\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, \"http://[::1]:80/segment/index.html?query#frag\"));\n\t\turiFreeUriMembersA(&uriA);\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, \"http://user:pass@[::1]/segment/index.html?query#frag\"));\n\t\turiFreeUriMembersA(&uriA);\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, \"http://user:pass@[::1]:80?query#frag\"));\n\t\turiFreeUriMembersA(&uriA);\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, \"http://user:pass@[::1]:80/segment/index.html#frag\"));\n\t\turiFreeUriMembersA(&uriA);\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, \"http://user:pass@[::1]:80/segment/index.html?query\"));\n\t\turiFreeUriMembersA(&uriA);\n\n\t\t// Schema, port, one segment\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, \"ftp://host:21/gnu/\"));\n\t\turiFreeUriMembersA(&uriA);\n\n\t\t// Relative\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, \"one/two/three\"));\n\t\tTEST_ASSERT(!uriA.absolutePath);\n\t\turiFreeUriMembersA(&uriA);\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, \"/one/two/three\"));\n\t\tTEST_ASSERT(uriA.absolutePath);\n\t\turiFreeUriMembersA(&uriA);\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, \"//user:pass@localhost/one/two/three\"));\n\t\turiFreeUriMembersA(&uriA);\n\n\t\t// ANSI and Unicode\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, \"http://www.example.com/\"));\n\t\turiFreeUriMembersA(&uriA);\n\t\tTEST_ASSERT(0 == uriParseUriW(&stateW, L\"http://www.example.com/\"));\n\t\turiFreeUriMembersW(&uriW);\n\n\t\t// Real life examples\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, \"http://sourceforge.net/projects/uriparser/\"));\n\t\turiFreeUriMembersA(&uriA);\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, \"http://sourceforge.net/project/platformdownload.php?group_id=182840\"));\n\t\turiFreeUriMembersA(&uriA);\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, \"mailto:test@example.com\"));\n\t\turiFreeUriMembersA(&uriA);\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, \"../../\"));\n\t\turiFreeUriMembersA(&uriA);\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, \"/\"));\n\t\tTEST_ASSERT(uriA.absolutePath)\n\t\turiFreeUriMembersA(&uriA);\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, \"\"));\n\t\tTEST_ASSERT(!uriA.absolutePath)\n\t\turiFreeUriMembersA(&uriA);\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, \"file:///bin/bash\"));\n\t\turiFreeUriMembersA(&uriA);\n\n\t\t// Percent encoding\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, \"http://www.example.com/name%20with%20spaces/\"));\n\t\turiFreeUriMembersA(&uriA);\n\t\tTEST_ASSERT(0 != uriParseUriA(&stateA, \"http://www.example.com/name with spaces/\"));\n\t\turiFreeUriMembersA(&uriA);\n\t}\n\n\tvoid testUriComponents() {\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  0              15 01  0      7  01\n\t\tconst char * const input = \"http\" \"://\" \"sourceforge.net\" \"/\" \"project\" \"/\"\n\t\t//\t\t 0                   20 01  0              15\n\t\t\t\t\"platformdownload.php\" \"?\" \"group_id=182840\";\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, input));\n\n\t\tTEST_ASSERT(uriA.scheme.first == input);\n\t\tTEST_ASSERT(uriA.scheme.afterLast == input + 4);\n\t\tTEST_ASSERT(uriA.userInfo.first == NULL);\n\t\tTEST_ASSERT(uriA.userInfo.afterLast == NULL);\n\t\tTEST_ASSERT(uriA.hostText.first == input + 4 + 3);\n\t\tTEST_ASSERT(uriA.hostText.afterLast == input + 4 + 3 + 15);\n\t\tTEST_ASSERT(uriA.hostData.ipFuture.first == NULL);\n\t\tTEST_ASSERT(uriA.hostData.ipFuture.afterLast == NULL);\n\t\tTEST_ASSERT(uriA.portText.first == NULL);\n\t\tTEST_ASSERT(uriA.portText.afterLast == NULL);\n\n\t\tTEST_ASSERT(uriA.pathHead->text.first == input + 4 + 3 + 15 + 1);\n\t\tTEST_ASSERT(uriA.pathHead->text.afterLast == input + 4 + 3 + 15 + 1 + 7);\n\t\tTEST_ASSERT(uriA.pathHead->next->text.first == input + 4 + 3 + 15 + 1 + 7 + 1);\n\t\tTEST_ASSERT(uriA.pathHead->next->text.afterLast == input + 4 + 3 + 15 + 1 + 7 + 1 + 20);\n\t\tTEST_ASSERT(uriA.pathHead->next->next == NULL);\n\t\tTEST_ASSERT(uriA.pathTail == uriA.pathHead->next);\n\n\t\tTEST_ASSERT(uriA.query.first == input + 4 + 3 + 15 + 1 + 7 + 1 + 20 + 1);\n\t\tTEST_ASSERT(uriA.query.afterLast == input + 4 + 3 + 15 + 1 + 7 + 1 + 20 + 1 + 15);\n\t\tTEST_ASSERT(uriA.fragment.first == NULL);\n\t\tTEST_ASSERT(uriA.fragment.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n\t}\n\n\tvoid testUriComponents_Bug20070701() {\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          01  01  01\n\t\tconst char * const input = \"a\" \":\" \"b\";\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, input));\n\n\t\tTEST_ASSERT(uriA.scheme.first == input);\n\t\tTEST_ASSERT(uriA.scheme.afterLast == input + 1);\n\t\tTEST_ASSERT(uriA.userInfo.first == NULL);\n\t\tTEST_ASSERT(uriA.userInfo.afterLast == NULL);\n\t\tTEST_ASSERT(uriA.hostText.first == NULL);\n\t\tTEST_ASSERT(uriA.hostText.afterLast == NULL);\n\t\tTEST_ASSERT(uriA.hostData.ipFuture.first == NULL);\n\t\tTEST_ASSERT(uriA.hostData.ipFuture.afterLast == NULL);\n\t\tTEST_ASSERT(uriA.portText.first == NULL);\n\t\tTEST_ASSERT(uriA.portText.afterLast == NULL);\n\n\t\tTEST_ASSERT(uriA.pathHead->text.first == input + 1 + 1);\n\t\tTEST_ASSERT(uriA.pathHead->text.afterLast == input + 1 + 1 + 1);\n\t\tTEST_ASSERT(uriA.pathHead->next == NULL);\n\t\tTEST_ASSERT(uriA.pathTail == uriA.pathHead);\n\n\t\tTEST_ASSERT(uriA.query.first == NULL);\n\t\tTEST_ASSERT(uriA.query.afterLast == NULL);\n\t\tTEST_ASSERT(uriA.fragment.first == NULL);\n\t\tTEST_ASSERT(uriA.fragment.afterLast == NULL);\n\n\t\tTEST_ASSERT(!uriA.absolutePath);\n\t\turiFreeUriMembersA(&uriA);\n\t}\n\n\tvoid testUriUserInfoHostPort1() {\n\t\t// User info with \":\", no port\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  0      7  01  0        9\n\t\tconst char * const input = \"http\" \"://\" \"abc:def\" \"@\" \"localhost\";\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, input));\n\n\t\tTEST_ASSERT(uriA.userInfo.first == input + 4 + 3);\n\t\tTEST_ASSERT(uriA.userInfo.afterLast == input + 4 + 3 + 7);\n\t\tTEST_ASSERT(uriA.hostText.first == input + 4 + 3 + 7 + 1);\n\t\tTEST_ASSERT(uriA.hostText.afterLast == input + 4 + 3 + 7 + 1 + 9);\n\t\tTEST_ASSERT(uriA.portText.first == NULL);\n\t\tTEST_ASSERT(uriA.portText.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n\t}\n\n\tvoid testUriUserInfoHostPort2() {\n\t\t// User info with \":\", with port\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  0      7  01  0        9\n\t\tconst char * const input = \"http\" \"://\" \"abc:def\" \"@\" \"localhost\"\n\t\t//\t\t01   0  3\n\t\t\t\t\":\" \"123\";\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, input));\n\n\t\tTEST_ASSERT(uriA.userInfo.first == input + 4 + 3);\n\t\tTEST_ASSERT(uriA.userInfo.afterLast == input + 4 + 3 + 7);\n\t\tTEST_ASSERT(uriA.hostText.first == input + 4 + 3 + 7 + 1);\n\t\tTEST_ASSERT(uriA.hostText.afterLast == input + 4 + 3 + 7 + 1 + 9);\n\t\tTEST_ASSERT(uriA.portText.first == input + 4 + 3 + 7 + 1 + 9 + 1);\n\t\tTEST_ASSERT(uriA.portText.afterLast == input + 4 + 3 + 7 + 1 + 9 + 1 + 3);\n\t\turiFreeUriMembersA(&uriA);\n\t}\n\n\tvoid testUriUserInfoHostPort22_Bug1948038() {\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\n\t\tint res;\n\n\t\tres = uriParseUriA(&stateA, \"http://user:21@host/\");\n\t\tTEST_ASSERT(URI_SUCCESS == res);\n\t\tTEST_ASSERT(!memcmp(uriA.userInfo.first, \"user:21\", 7 * sizeof(char)));\n\t\tTEST_ASSERT(uriA.userInfo.afterLast - uriA.userInfo.first == 7);\n\t\tTEST_ASSERT(!memcmp(uriA.hostText.first, \"host\", 4 * sizeof(char)));\n\t\tTEST_ASSERT(uriA.hostText.afterLast - uriA.hostText.first == 4);\n\t\tTEST_ASSERT(uriA.portText.first == NULL);\n\t\tTEST_ASSERT(uriA.portText.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n\n\t\tres = uriParseUriA(&stateA, \"http://user:1234@192.168.0.1:1234/foo.com\");\n\t\tTEST_ASSERT(URI_SUCCESS == res);\n\t\turiFreeUriMembersA(&uriA);\n\n\t\tres = uriParseUriA(&stateA, \"http://moo:21@moo:21@moo/\");\n\t\tTEST_ASSERT(URI_ERROR_SYNTAX == res);\n\t\turiFreeUriMembersA(&uriA);\n\n\t\tres = uriParseUriA(&stateA, \"http://moo:21@moo:21@moo:21/\");\n\t\tTEST_ASSERT(URI_ERROR_SYNTAX == res);\n\t\turiFreeUriMembersA(&uriA);\n\t}\n\n\tvoid testUriUserInfoHostPort23_Bug3510198_1() {\n\t\t// User info with \":\", with port, with escaped chars in password\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\n\t\tint res;\n\t\t//                           0   4  0  3  0         10 01  0   4  01\n\t\tres = uriParseUriA(&stateA, \"http\" \"://\" \"user:%2F21\" \"@\" \"host\" \"/\");\n\t\tTEST_ASSERT(URI_SUCCESS == res);\n\t\tTEST_ASSERT(!memcmp(uriA.userInfo.first, \"user:%2F21\", 10 * sizeof(char)));\n\t\tTEST_ASSERT(uriA.userInfo.afterLast - uriA.userInfo.first == 10);\n\t\tTEST_ASSERT(!memcmp(uriA.hostText.first, \"host\", 4 * sizeof(char)));\n\t\tTEST_ASSERT(uriA.hostText.afterLast - uriA.hostText.first == 4);\n\t\tTEST_ASSERT(uriA.portText.first == NULL);\n\t\tTEST_ASSERT(uriA.portText.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n\n\t}\n\n\tvoid testUriUserInfoHostPort23_Bug3510198_2() {\n\t\t// User info with \":\", with port, with escaped chars in user name and password\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\n\t\tint res;\n\t\t//                           0   4  0  3  0            13 01  0   4  01\n\t\tres = uriParseUriA(&stateA, \"http\" \"://\" \"%2Fuser:%2F21\" \"@\" \"host\" \"/\");\n\t\tTEST_ASSERT(URI_SUCCESS == res);\n\t\tTEST_ASSERT(!memcmp(uriA.userInfo.first, \"%2Fuser:%2F21\", 13 * sizeof(char)));\n\t\tTEST_ASSERT(uriA.userInfo.afterLast - uriA.userInfo.first == 13);\n\t\tTEST_ASSERT(!memcmp(uriA.hostText.first, \"host\", 4 * sizeof(char)));\n\t\tTEST_ASSERT(uriA.hostText.afterLast - uriA.hostText.first == 4);\n\t\tTEST_ASSERT(uriA.portText.first == NULL);\n\t\tTEST_ASSERT(uriA.portText.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n\t}\n\n\tvoid testUriUserInfoHostPort23_Bug3510198_3() {\n\t\t// User info with \":\", with port, with escaped chars in password\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\n\t\tint res;\n\t\t//                           0   4  0  3  0               16 01  0   4  01\n\t\tres = uriParseUriA(&stateA, \"http\" \"://\" \"user:!$&'()*+,;=\" \"@\" \"host\" \"/\");\n\t\tTEST_ASSERT(URI_SUCCESS == res);\n\t\tTEST_ASSERT(!memcmp(uriA.userInfo.first, \"user:!$&'()*+,;=\", 16 * sizeof(char)));\n\t\tTEST_ASSERT(uriA.userInfo.afterLast - uriA.userInfo.first == 16);\n\t\tTEST_ASSERT(!memcmp(uriA.hostText.first, \"host\", 4 * sizeof(char)));\n\t\tTEST_ASSERT(uriA.hostText.afterLast - uriA.hostText.first == 4);\n\t\tTEST_ASSERT(uriA.portText.first == NULL);\n\t\tTEST_ASSERT(uriA.portText.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n\n\t}\n\n\tvoid testUriUserInfoHostPort23_Bug3510198_4() {\n\t\t// User info with \":\", with port, with escaped chars in user name and password\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\n\t\tint res;\n\t\t//                           0   4  0  3  0                   20 01  0   4  01\n\t\tres = uriParseUriA(&stateA, \"http\" \"://\" \"!$&'()*+,;=:password\" \"@\" \"host\" \"/\");\n\t\tTEST_ASSERT(URI_SUCCESS == res);\n\t\tTEST_ASSERT(!memcmp(uriA.userInfo.first, \"!$&'()*+,;=:password\", 20 * sizeof(char)));\n\t\tTEST_ASSERT(uriA.userInfo.afterLast - uriA.userInfo.first == 20);\n\t\tTEST_ASSERT(!memcmp(uriA.hostText.first, \"host\", 4 * sizeof(char)));\n\t\tTEST_ASSERT(uriA.hostText.afterLast - uriA.hostText.first == 4);\n\t\tTEST_ASSERT(uriA.portText.first == NULL);\n\t\tTEST_ASSERT(uriA.portText.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n\t}\n\n\tvoid testUriUserInfoHostPort23_Bug3510198_related_1() {\n\t\t// Empty user info\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\n\t\tint res;\n\t\t//                           0   4  0  3  01  0   4  01\n\t\tres = uriParseUriA(&stateA, \"http\" \"://\" \"@\" \"host\" \"/\");\n\t\tTEST_ASSERT(URI_SUCCESS == res);\n\t\tTEST_ASSERT(uriA.userInfo.afterLast != NULL);\n\t\tTEST_ASSERT(uriA.userInfo.first != NULL);\n\t\tTEST_ASSERT(uriA.userInfo.afterLast - uriA.userInfo.first == 0);\n\t\tTEST_ASSERT(!memcmp(uriA.hostText.first, \"host\", 4 * sizeof(char)));\n\t\tTEST_ASSERT(uriA.hostText.afterLast - uriA.hostText.first == 4);\n\t\tTEST_ASSERT(uriA.portText.first == NULL);\n\t\tTEST_ASSERT(uriA.portText.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n\t}\n\n\tvoid testUriUserInfoHostPort23_Bug3510198_related_12() {\n\t\t// Empty user info\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\n\t\tint res;\n\t\t//                           0   4  0  3  0      7  01\n\t\tres = uriParseUriA(&stateA, \"http\" \"://\" \"%2Fhost\" \"/\");\n\t\tTEST_ASSERT(URI_SUCCESS == res);\n\t\tTEST_ASSERT(uriA.userInfo.afterLast == NULL);\n\t\tTEST_ASSERT(uriA.userInfo.first == NULL);\n\t\tTEST_ASSERT(!memcmp(uriA.hostText.first, \"%2Fhost\", 7 * sizeof(char)));\n\t\tTEST_ASSERT(uriA.hostText.afterLast - uriA.hostText.first == 7);\n\t\tTEST_ASSERT(uriA.portText.first == NULL);\n\t\tTEST_ASSERT(uriA.portText.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n\t}\n\n\tvoid testUriUserInfoHostPort23_Bug3510198_related_2() {\n\t\t// Several colons in userinfo\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\n\t\tint res;\n\t\t//                           0   4  0  3  0 2  01  0   4  01\n\t\tres = uriParseUriA(&stateA, \"http\" \"://\" \"::\" \"@\" \"host\" \"/\");\n\t\tTEST_ASSERT(URI_SUCCESS == res);\n\t\tTEST_ASSERT(!memcmp(uriA.userInfo.first, \"::\", 2 * sizeof(char)));\n\t\tTEST_ASSERT(uriA.userInfo.afterLast - uriA.userInfo.first == 2);\n\t\tTEST_ASSERT(!memcmp(uriA.hostText.first, \"host\", 4 * sizeof(char)));\n\t\tTEST_ASSERT(uriA.hostText.afterLast - uriA.hostText.first == 4);\n\t\tTEST_ASSERT(uriA.portText.first == NULL);\n\t\tTEST_ASSERT(uriA.portText.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n\t}\n\n\tvoid testUriUserInfoHostPort3() {\n\t\t// User info without \":\", no port\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  0      7  01  0        9\n\t\tconst char * const input = \"http\" \"://\" \"abcdefg\" \"@\" \"localhost\";\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, input));\n\n\t\tTEST_ASSERT(uriA.userInfo.first == input + 4 + 3);\n\t\tTEST_ASSERT(uriA.userInfo.afterLast == input + 4 + 3 + 7);\n\t\tTEST_ASSERT(uriA.hostText.first == input + 4 + 3 + 7 + 1);\n\t\tTEST_ASSERT(uriA.hostText.afterLast == input + 4 + 3 + 7 + 1 + 9);\n\t\tTEST_ASSERT(uriA.portText.first == NULL);\n\t\tTEST_ASSERT(uriA.portText.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n\t}\n\n\tvoid testUriUserInfoHostPort4() {\n\t\t// User info without \":\", with port\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  0      7  01  0        9\n\t\tconst char * const input = \"http\" \"://\" \"abcdefg\" \"@\" \"localhost\"\n\t\t//\t\t01   0  3\n\t\t\t\t\":\" \"123\";\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, input));\n\n\t\tTEST_ASSERT(uriA.userInfo.first == input + 4 + 3);\n\t\tTEST_ASSERT(uriA.userInfo.afterLast == input + 4 + 3 + 7);\n\t\tTEST_ASSERT(uriA.hostText.first == input + 4 + 3 + 7 + 1);\n\t\tTEST_ASSERT(uriA.hostText.afterLast == input + 4 + 3 + 7 + 1 + 9);\n\t\tTEST_ASSERT(uriA.portText.first == input + 4 + 3 + 7 + 1 + 9 + 1);\n\t\tTEST_ASSERT(uriA.portText.afterLast == input + 4 + 3 + 7 + 1 + 9 + 1 + 3);\n\t\turiFreeUriMembersA(&uriA);\n\t}\n\n\tvoid testUriUserInfoHostPort5() {\n\t\t// No user info, no port\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  0        9\n\t\tconst char * const input = \"http\" \"://\" \"localhost\";\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, input));\n\n\t\tTEST_ASSERT(uriA.userInfo.first == NULL);\n\t\tTEST_ASSERT(uriA.userInfo.afterLast == NULL);\n\t\tTEST_ASSERT(uriA.hostText.first == input + 4 + 3);\n\t\tTEST_ASSERT(uriA.hostText.afterLast == input + 4 + 3 + 9);\n\t\tTEST_ASSERT(uriA.portText.first == NULL);\n\t\tTEST_ASSERT(uriA.portText.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n\t}\n\n\tvoid testUriUserInfoHostPort6() {\n\t\t// No user info, with port\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  0        9  01  0  3\n\t\tconst char * const input = \"http\" \"://\" \"localhost\" \":\" \"123\";\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, input));\n\n\t\tTEST_ASSERT(uriA.userInfo.first == NULL);\n\t\tTEST_ASSERT(uriA.userInfo.afterLast == NULL);\n\t\tTEST_ASSERT(uriA.hostText.first == input + 4 + 3);\n\t\tTEST_ASSERT(uriA.hostText.afterLast == input + 4 + 3 + 9);\n\t\tTEST_ASSERT(uriA.portText.first == input + 4 + 3 + 9 + 1);\n\t\tTEST_ASSERT(uriA.portText.afterLast == input + 4 + 3 + 9 + 1 + 3);\n\t\turiFreeUriMembersA(&uriA);\n\t}\n\n\tvoid testUriHostRegname() {\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  0          11\n\t\tconst char * const input = \"http\" \"://\" \"example.com\";\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, input));\n\n\t\tTEST_ASSERT(uriA.hostText.first == input + 4 + 3);\n\t\tTEST_ASSERT(uriA.hostText.afterLast == input + 4 + 3 + 11);\n\t\tTEST_ASSERT(uriA.hostData.ip4 == NULL);\n\t\tTEST_ASSERT(uriA.hostData.ip6 == NULL);\n\t\tTEST_ASSERT(uriA.hostData.ipFuture.first == NULL);\n\t\tTEST_ASSERT(uriA.hostData.ipFuture.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n\t}\n\n\tvoid testUriHostIpFour1() {\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  0      7  01  0 2\n\t\tconst char * const input = \"http\" \"://\" \"1.2.3.4\" \":\" \"80\";\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, input));\n\n\t\tTEST_ASSERT(uriA.hostText.first == input + 4 + 3);\n\t\tTEST_ASSERT(uriA.hostText.afterLast == input + 4 + 3 + 7);\n\t\tTEST_ASSERT(uriA.hostData.ip4 != NULL);\n\t\tTEST_ASSERT(uriA.hostData.ip6 == NULL);\n\t\tTEST_ASSERT(uriA.hostData.ipFuture.first == NULL);\n\t\tTEST_ASSERT(uriA.hostData.ipFuture.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n\t}\n\n\tvoid testUriHostIpFour2() {\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  0      7\n\t\tconst char * const input = \"http\" \"://\" \"1.2.3.4\";\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, input));\n\n\t\tTEST_ASSERT(uriA.hostText.first == input + 4 + 3);\n\t\tTEST_ASSERT(uriA.hostText.afterLast == input + 4 + 3 + 7);\n\t\tTEST_ASSERT(uriA.hostData.ip4 != NULL);\n\t\tTEST_ASSERT(uriA.hostData.ip6 == NULL);\n\t\tTEST_ASSERT(uriA.hostData.ipFuture.first == NULL);\n\t\tTEST_ASSERT(uriA.hostData.ipFuture.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n\t}\n\n\tvoid testUriHostIpSix1() {\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  01  45  01  0 2\n\t\tconst char * const input = \"http\" \"://\" \"[::1]\" \":\" \"80\";\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, input));\n\n\t\tTEST_ASSERT(uriA.hostText.first == input + 4 + 3 + 1);\n\t\tTEST_ASSERT(uriA.hostText.afterLast == input + 4 + 3 + 4);\n\t\tTEST_ASSERT(uriA.hostData.ip4 == NULL);\n\t\tTEST_ASSERT(uriA.hostData.ip6 != NULL);\n\t\tTEST_ASSERT(uriA.hostData.ipFuture.first == NULL);\n\t\tTEST_ASSERT(uriA.hostData.ipFuture.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n\t}\n\n\tvoid testUriHostIpSix2() {\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  01  45\n\t\tconst char * const input = \"http\" \"://\" \"[::1]\";\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, input));\n\n\t\tTEST_ASSERT(uriA.hostText.first == input + 4 + 3 + 1);\n\t\tTEST_ASSERT(uriA.hostText.afterLast == input + 4 + 3 + 4);\n\t\tTEST_ASSERT(uriA.hostData.ip4 == NULL);\n\t\tTEST_ASSERT(uriA.hostData.ip6 != NULL);\n\t\tTEST_ASSERT(uriA.hostData.ipFuture.first == NULL);\n\t\tTEST_ASSERT(uriA.hostData.ipFuture.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n\t}\n\n\tvoid testUriHostEmpty() {\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  01  0  3\n\t\tconst char * const input = \"http\" \"://\" \":\" \"123\";\n\t\tconst int res = uriParseUriA(&stateA, input);\n\t\tTEST_ASSERT(URI_SUCCESS == res);\n\t\tTEST_ASSERT(uriA.userInfo.first == NULL);\n\t\tTEST_ASSERT(uriA.userInfo.afterLast == NULL);\n\t\tTEST_ASSERT(uriA.hostText.first != NULL);\n\t\tTEST_ASSERT(uriA.hostText.afterLast != NULL);\n\t\tTEST_ASSERT(uriA.hostText.afterLast - uriA.hostText.first == 0);\n\t\tTEST_ASSERT(uriA.portText.first == input + 4 + 3 + 1);\n\t\tTEST_ASSERT(uriA.portText.afterLast == input + 4 + 3 + 1 + 3);\n\t\turiFreeUriMembersA(&uriA);\n\t}\n\n\tvoid testUriHostIpFuture() {\n\t\t// TODO\n\t}\n\n\tbool testEscapingHelper(const wchar_t * in, const wchar_t * expectedOut,\n\t\t\tbool spaceToPlus = false, bool normalizeBreaks = false) {\n\t\twchar_t * const buffer = new wchar_t[(normalizeBreaks ? 6 : 3)\n\t\t\t\t* wcslen(in) + 1];\n\t\tif (uriEscapeW(in, buffer, spaceToPlus, normalizeBreaks)\n\t\t\t!= buffer + wcslen(expectedOut)) {\n\t\t\tdelete [] buffer;\n\t\t\treturn false;\n\t\t}\n\n\t\tconst bool equal = !wcscmp(buffer, expectedOut);\n\t\tdelete [] buffer;\n\t\treturn equal;\n\t}\n\n\tvoid testEscaping() {\n\t\tconst bool SPACE_TO_PLUS = true;\n\t\tconst bool SPACE_TO_PERCENT = false;\n\t\tconst bool KEEP_UNMODIFIED = false;\n\t\tconst bool NORMALIZE = true;\n\n\t\t// '+' to ' '\n\t\tTEST_ASSERT(testEscapingHelper(L\"abc def\", L\"abc+def\", SPACE_TO_PLUS));\n\t\tTEST_ASSERT(testEscapingHelper(L\"abc def\", L\"abc%20def\", SPACE_TO_PERCENT));\n\n\t\t// Percent encoding\n\t\tTEST_ASSERT(testEscapingHelper(L\"\\x00\", L\"\\0\"));\n\t\tTEST_ASSERT(testEscapingHelper(L\"\\x01\", L\"%01\"));\n\t\tTEST_ASSERT(testEscapingHelper(L\"\\xff\", L\"%FF\"));\n\n\t\t// Linebreak normalization\n\t\tTEST_ASSERT(testEscapingHelper(L\"\\x0d\", L\"%0D%0A\", SPACE_TO_PLUS, NORMALIZE));\n\t\tTEST_ASSERT(testEscapingHelper(L\"g\\x0d\", L\"g%0D%0A\", SPACE_TO_PLUS, NORMALIZE));\n\t\tTEST_ASSERT(testEscapingHelper(L\"\\x0dg\", L\"%0D%0Ag\", SPACE_TO_PLUS, NORMALIZE));\n\t\tTEST_ASSERT(testEscapingHelper(L\"\\x0d\", L\"%0D\", SPACE_TO_PLUS, KEEP_UNMODIFIED));\n\t\tTEST_ASSERT(testEscapingHelper(L\"g\\x0d\", L\"g%0D\", SPACE_TO_PLUS, KEEP_UNMODIFIED));\n\t\tTEST_ASSERT(testEscapingHelper(L\"\\x0dg\", L\"%0Dg\", SPACE_TO_PLUS, KEEP_UNMODIFIED));\n\n\t\tTEST_ASSERT(testEscapingHelper(L\"\\x0a\", L\"%0D%0A\", SPACE_TO_PLUS, NORMALIZE));\n\t\tTEST_ASSERT(testEscapingHelper(L\"g\\x0a\", L\"g%0D%0A\", SPACE_TO_PLUS, NORMALIZE));\n\t\tTEST_ASSERT(testEscapingHelper(L\"\\x0ag\", L\"%0D%0Ag\", SPACE_TO_PLUS, NORMALIZE));\n\t\tTEST_ASSERT(testEscapingHelper(L\"\\x0a\", L\"%0A\", SPACE_TO_PLUS, KEEP_UNMODIFIED));\n\t\tTEST_ASSERT(testEscapingHelper(L\"g\\x0a\", L\"g%0A\", SPACE_TO_PLUS, KEEP_UNMODIFIED));\n\t\tTEST_ASSERT(testEscapingHelper(L\"\\x0ag\", L\"%0Ag\", SPACE_TO_PLUS, KEEP_UNMODIFIED));\n\n\t\tTEST_ASSERT(testEscapingHelper(L\"\\x0d\\x0a\", L\"%0D%0A\", SPACE_TO_PLUS, NORMALIZE));\n\t\tTEST_ASSERT(testEscapingHelper(L\"g\\x0d\\x0a\", L\"g%0D%0A\", SPACE_TO_PLUS, NORMALIZE));\n\t\tTEST_ASSERT(testEscapingHelper(L\"\\x0d\\x0ag\", L\"%0D%0Ag\", SPACE_TO_PLUS, NORMALIZE));\n\t\tTEST_ASSERT(testEscapingHelper(L\"\\x0d\\x0a\", L\"%0D%0A\", SPACE_TO_PLUS, KEEP_UNMODIFIED));\n\t\tTEST_ASSERT(testEscapingHelper(L\"g\\x0d\\x0a\", L\"g%0D%0A\", SPACE_TO_PLUS, KEEP_UNMODIFIED));\n\t\tTEST_ASSERT(testEscapingHelper(L\"\\x0d\\x0ag\", L\"%0D%0Ag\", SPACE_TO_PLUS, KEEP_UNMODIFIED));\n\n\t\tTEST_ASSERT(testEscapingHelper(L\"\\x0a\\x0d\", L\"%0D%0A%0D%0A\", SPACE_TO_PLUS, NORMALIZE));\n\t\tTEST_ASSERT(testEscapingHelper(L\"g\\x0a\\x0d\", L\"g%0D%0A%0D%0A\", SPACE_TO_PLUS, NORMALIZE));\n\t\tTEST_ASSERT(testEscapingHelper(L\"\\x0a\\x0dg\", L\"%0D%0A%0D%0Ag\", SPACE_TO_PLUS, NORMALIZE));\n\t\tTEST_ASSERT(testEscapingHelper(L\"\\x0a\\x0d\", L\"%0A%0D\", SPACE_TO_PLUS, KEEP_UNMODIFIED));\n\t\tTEST_ASSERT(testEscapingHelper(L\"g\\x0a\\x0d\", L\"g%0A%0D\", SPACE_TO_PLUS, KEEP_UNMODIFIED));\n\t\tTEST_ASSERT(testEscapingHelper(L\"\\x0a\\x0dg\", L\"%0A%0Dg\", SPACE_TO_PLUS, KEEP_UNMODIFIED));\n\t}\n\n\tbool testUnescapingHelper(const wchar_t * input, const wchar_t * output,\n\t\t\tbool plusToSpace = false, UriBreakConversion breakConversion = URI_BR_DONT_TOUCH) {\n\t\twchar_t * working = new wchar_t[URI_STRLEN(input) + 1];\n\t\twcscpy(working, input);\n\t\tconst wchar_t * newTermZero = uriUnescapeInPlaceExW(working,\n\t\t\t\tplusToSpace ? URI_TRUE : URI_FALSE, breakConversion);\n\t\tconst bool success = ((newTermZero == working + wcslen(output))\n\t\t\t\t&& !wcscmp(working, output));\n\t\tdelete[] working;\n\t\treturn success;\n\t}\n\n\tvoid testUnescaping() {\n\t\tconst bool PLUS_TO_SPACE = true;\n\t\tconst bool PLUS_DONT_TOUCH = false;\n\n\n\t\t// Proper\n\t\tTEST_ASSERT(testUnescapingHelper(L\"abc%20%41BC\", L\"abc ABC\"));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%20\", L\" \"));\n\n\t\t// Incomplete\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0\", L\"%0\"));\n\n\t\t// Nonhex\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0g\", L\"%0g\"));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%G0\", L\"%G0\"));\n\n\t\t// No double decoding\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%2520\", L\"%20\"));\n\n\t\t// Decoding of '+'\n\t\tTEST_ASSERT(testUnescapingHelper(L\"abc+def\", L\"abc+def\", PLUS_DONT_TOUCH));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"abc+def\", L\"abc def\", PLUS_TO_SPACE));\n\n\t\t// Line break conversion\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0d\", L\"\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_UNIX));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0d\", L\"\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_WINDOWS));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0d\", L\"\\x0d\", PLUS_DONT_TOUCH, URI_BR_TO_MAC));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0d\", L\"\\x0d\", PLUS_DONT_TOUCH, URI_BR_DONT_TOUCH));\n\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0d%0d\", L\"\\x0a\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_UNIX));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0d%0d\", L\"\\x0d\\x0a\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_WINDOWS));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0d%0d\", L\"\\x0d\\x0d\", PLUS_DONT_TOUCH, URI_BR_TO_MAC));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0d%0d\", L\"\\x0d\\x0d\", PLUS_DONT_TOUCH, URI_BR_DONT_TOUCH));\n\n\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0a\", L\"\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_UNIX));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0a\", L\"\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_WINDOWS));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0a\", L\"\\x0d\", PLUS_DONT_TOUCH, URI_BR_TO_MAC));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0a\", L\"\\x0a\", PLUS_DONT_TOUCH, URI_BR_DONT_TOUCH));\n\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0a%0a\", L\"\\x0a\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_UNIX));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0a%0a\", L\"\\x0d\\x0a\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_WINDOWS));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0a%0a\", L\"\\x0d\\x0d\", PLUS_DONT_TOUCH, URI_BR_TO_MAC));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0a%0a\", L\"\\x0a\\x0a\", PLUS_DONT_TOUCH, URI_BR_DONT_TOUCH));\n\n\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0d%0a\", L\"\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_UNIX));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0d%0a\", L\"\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_WINDOWS));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0d%0a\", L\"\\x0d\", PLUS_DONT_TOUCH, URI_BR_TO_MAC));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0d%0a\", L\"\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_DONT_TOUCH));\n\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0d%0a%0a\", L\"\\x0a\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_UNIX));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0d%0a%0a\", L\"\\x0d\\x0a\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_WINDOWS));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0d%0a%0a\", L\"\\x0d\\x0d\", PLUS_DONT_TOUCH, URI_BR_TO_MAC));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0d%0a%0a\", L\"\\x0d\\x0a\\x0a\", PLUS_DONT_TOUCH, URI_BR_DONT_TOUCH));\n\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0d%0a%0d\", L\"\\x0a\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_UNIX));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0d%0a%0d\", L\"\\x0d\\x0a\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_WINDOWS));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0d%0a%0d\", L\"\\x0d\\x0d\", PLUS_DONT_TOUCH, URI_BR_TO_MAC));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0d%0a%0d\", L\"\\x0d\\x0a\\x0d\", PLUS_DONT_TOUCH, URI_BR_DONT_TOUCH));\n\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0d%0a%0d%0a\", L\"\\x0a\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_UNIX));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0d%0a%0d%0a\", L\"\\x0d\\x0a\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_WINDOWS));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0d%0a%0d%0a\", L\"\\x0d\\x0d\", PLUS_DONT_TOUCH, URI_BR_TO_MAC));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0d%0a%0d%0a\", L\"\\x0d\\x0a\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_DONT_TOUCH));\n\n\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0a%0d\", L\"\\x0a\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_UNIX));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0a%0d\", L\"\\x0d\\x0a\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_WINDOWS));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0a%0d\", L\"\\x0d\\x0d\", PLUS_DONT_TOUCH, URI_BR_TO_MAC));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0a%0d\", L\"\\x0a\\x0d\", PLUS_DONT_TOUCH, URI_BR_DONT_TOUCH));\n\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0a%0d%0a\", L\"\\x0a\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_UNIX));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0a%0d%0a\", L\"\\x0d\\x0a\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_WINDOWS));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0a%0d%0a\", L\"\\x0d\\x0d\", PLUS_DONT_TOUCH, URI_BR_TO_MAC));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0a%0d%0a\", L\"\\x0a\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_DONT_TOUCH));\n\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0a%0d%0d\", L\"\\x0a\\x0a\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_UNIX));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0a%0d%0d\", L\"\\x0d\\x0a\\x0d\\x0a\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_WINDOWS));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0a%0d%0d\", L\"\\x0d\\x0d\\x0d\", PLUS_DONT_TOUCH, URI_BR_TO_MAC));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0a%0d%0d\", L\"\\x0a\\x0d\\x0d\", PLUS_DONT_TOUCH, URI_BR_DONT_TOUCH));\n\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0a%0d%0a%0d\", L\"\\x0a\\x0a\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_UNIX));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0a%0d%0a%0d\", L\"\\x0d\\x0a\\x0d\\x0a\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_WINDOWS));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0a%0d%0a%0d\", L\"\\x0d\\x0d\\x0d\", PLUS_DONT_TOUCH, URI_BR_TO_MAC));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0a%0d%0a%0d\", L\"\\x0a\\x0d\\x0a\\x0d\", PLUS_DONT_TOUCH, URI_BR_DONT_TOUCH));\n\t}\n\n\tbool testAddBaseHelper(const wchar_t * base, const wchar_t * rel, const wchar_t * expectedResult, bool backward_compatibility = false) {\n\t\tUriParserStateW stateW;\n\n\t\t// Base\n\t\tUriUriW baseUri;\n\t\tstateW.uri = &baseUri;\n\t\tint res = uriParseUriW(&stateW, base);\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&baseUri);\n\t\t\treturn false;\n\t\t}\n\n\t\t// Rel\n\t\tUriUriW relUri;\n\t\tstateW.uri = &relUri;\n\t\tres = uriParseUriW(&stateW, rel);\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&baseUri);\n\t\t\turiFreeUriMembersW(&relUri);\n\t\t\treturn false;\n\t\t}\n\n\t\t// Expected result\n\t\tUriUriW expectedUri;\n\t\tstateW.uri = &expectedUri;\n\t\tres = uriParseUriW(&stateW, expectedResult);\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&baseUri);\n\t\t\turiFreeUriMembersW(&relUri);\n\t\t\turiFreeUriMembersW(&expectedUri);\n\t\t\treturn false;\n\t\t}\n\n\t\t// Transform\n\t\tUriUriW transformedUri;\n\t\tif (backward_compatibility) {\n\t\t\tres = uriAddBaseUriExW(&transformedUri, &relUri, &baseUri, URI_RESOLVE_IDENTICAL_SCHEME_COMPAT);\n\t\t} else {\n\t\t\tres = uriAddBaseUriW(&transformedUri, &relUri, &baseUri);\n\t\t}\n\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&baseUri);\n\t\t\turiFreeUriMembersW(&relUri);\n\t\t\turiFreeUriMembersW(&expectedUri);\n\t\t\turiFreeUriMembersW(&transformedUri);\n\t\t\treturn false;\n\t\t}\n\n\t\tconst bool equal = (URI_TRUE == uriEqualsUriW(&transformedUri, &expectedUri));\n\t\tif (!equal) {\n\t\t\twchar_t transformedUriText[1024 * 8];\n\t\t\twchar_t expectedUriText[1024 * 8];\n\t\t\turiToStringW(transformedUriText, &transformedUri, 1024 * 8, NULL);\n\t\t\turiToStringW(expectedUriText, &expectedUri, 1024 * 8, NULL);\n#ifdef HAVE_WPRINTF\n\t\t\twprintf(L\"\\n\\n\\nExpected: \\\"%s\\\"\\nReceived: \\\"%s\\\"\\n\\n\\n\", expectedUriText, transformedUriText);\n#endif\n\t\t}\n\n\t\turiFreeUriMembersW(&baseUri);\n\t\turiFreeUriMembersW(&relUri);\n\t\turiFreeUriMembersW(&expectedUri);\n\t\turiFreeUriMembersW(&transformedUri);\n\t\treturn equal;\n\t}\n\n\tvoid testTrailingSlash() {\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0  3  01\n\t\tconst char * const input = \"abc\" \"/\";\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, input));\n\n\t\tTEST_ASSERT(uriA.pathHead->text.first == input);\n\t\tTEST_ASSERT(uriA.pathHead->text.afterLast == input + 3);\n\t\tTEST_ASSERT(uriA.pathHead->next->text.first == uriA.pathHead->next->text.afterLast);\n\t\tTEST_ASSERT(uriA.pathHead->next->next == NULL);\n\t\tTEST_ASSERT(uriA.pathTail == uriA.pathHead->next);\n\t\turiFreeUriMembersA(&uriA);\n\t}\n\n\tvoid testAddBase() {\n\t\t// 5.4.1. Normal Examples\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g:h\", L\"g:h\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g\", L\"http://a/b/c/g\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"./g\", L\"http://a/b/c/g\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g/\", L\"http://a/b/c/g/\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"/g\", L\"http://a/g\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"//g\", L\"http://g\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"?y\", L\"http://a/b/c/d;p?y\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g?y\", L\"http://a/b/c/g?y\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"#s\", L\"http://a/b/c/d;p?q#s\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g#s\", L\"http://a/b/c/g#s\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g?y#s\", L\"http://a/b/c/g?y#s\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\";x\", L\"http://a/b/c/;x\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g;x\", L\"http://a/b/c/g;x\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g;x?y#s\", L\"http://a/b/c/g;x?y#s\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"\", L\"http://a/b/c/d;p?q\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\".\", L\"http://a/b/c/\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"./\", L\"http://a/b/c/\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"..\", L\"http://a/b/\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"../\", L\"http://a/b/\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"../g\", L\"http://a/b/g\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"../..\", L\"http://a/\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"../../\", L\"http://a/\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"../../g\", L\"http://a/g\"));\n\n\t\t// 5.4.2. Abnormal Examples\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"../../../g\", L\"http://a/g\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"../../../../g\", L\"http://a/g\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"/./g\", L\"http://a/g\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"/../g\", L\"http://a/g\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g.\", L\"http://a/b/c/g.\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\".g\", L\"http://a/b/c/.g\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g..\", L\"http://a/b/c/g..\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"..g\", L\"http://a/b/c/..g\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"./../g\", L\"http://a/b/g\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"./g/.\", L\"http://a/b/c/g/\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g/./h\", L\"http://a/b/c/g/h\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g/../h\", L\"http://a/b/c/h\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g;x=1/./y\", L\"http://a/b/c/g;x=1/y\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g;x=1/../y\", L\"http://a/b/c/y\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g?y/./x\", L\"http://a/b/c/g?y/./x\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g?y/../x\", L\"http://a/b/c/g?y/../x\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g#s/./x\", L\"http://a/b/c/g#s/./x\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g#s/../x\", L\"http://a/b/c/g#s/../x\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"http:g\", L\"http:g\"));\n\n\t\t// Backward compatibility (feature request #4, RFC3986 5.4.2)\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"http:g\", L\"http:g\", false));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"http:g\", L\"http://a/b/c/g\", true));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"http:g?q#f\", L\"http://a/b/c/g?q#f\", true));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"other:g?q#f\", L\"other:g?q#f\", true));\n\n\t\t// Bug related to absolutePath flag set despite presence of host\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"/\", L\"http://a/\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"/g/\", L\"http://a/g/\"));\n\t}\n\n\tbool testToStringHelper(const wchar_t * text) {\n\t\t// Parse\n\t\tUriParserStateW state;\n\t\tUriUriW uri;\n\t\tstate.uri = &uri;\n\t\tint res = uriParseUriW(&state, text);\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\t// Back to string, _huge_ limit\n\t\twchar_t shouldbeTheSame[1024 * 8];\n\t\tres = uriToStringW(shouldbeTheSame, &uri, 1024 * 8, NULL);\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\t// Compare\n\t\tbool equals = (0 == wcscmp(shouldbeTheSame, text));\n\t\tif (!equals) {\n#ifdef HAVE_WPRINTF\n\t\t\twprintf(L\"\\n\\n\\nExpected: \\\"%s\\\"\\nReceived: \\\"%s\\\"\\n\\n\\n\", text, shouldbeTheSame);\n#endif\n\t\t}\n\n\t\t// Back to string, _exact_ limit\n\t\tconst int len = static_cast<int>(wcslen(text));\n\t\tint charsWritten;\n\t\tres = uriToStringW(shouldbeTheSame, &uri, len + 1, &charsWritten);\n\t\tif ((res != 0) || (charsWritten != len + 1)) {\n\t\t\turiFreeUriMembersW(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\t// Back to string, _too small_ limit\n\t\tres = uriToStringW(shouldbeTheSame, &uri, len, &charsWritten);\n\t\tif ((res == 0) || (charsWritten >= len + 1)) {\n\t\t\turiFreeUriMembersW(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\turiFreeUriMembersW(&uri);\n\t\treturn equals;\n\t}\n\n\tvoid testToString() {\n\t\t// Scheme\n\t\tTEST_ASSERT(testToStringHelper(L\"ftp://localhost/\"));\n\t\t// UserInfo\n\t\tTEST_ASSERT(testToStringHelper(L\"http://user:pass@localhost/\"));\n\t\t// IPv4\n\t\tTEST_ASSERT(testToStringHelper(L\"http://123.0.1.255/\"));\n\t\t// IPv6\n\t\tTEST_ASSERT(testToStringHelper(L\"http://[abcd:abcd:abcd:abcd:abcd:abcd:abcd:abcd]/\"));\n\t\t// IPvFuture\n\t\tTEST_ASSERT(testToStringHelper(L\"http://[vA.123456]/\"));\n\t\t// Port\n\t\tTEST_ASSERT(testToStringHelper(L\"http://example.com:123/\"));\n\t\t// Path\n\t\tTEST_ASSERT(testToStringHelper(L\"http://example.com\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"http://example.com/\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"http://example.com/abc/\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"http://example.com/abc/def\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"http://example.com/abc/def/\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"http://example.com//\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"http://example.com/./..\"));\n\t\t// Query\n\t\tTEST_ASSERT(testToStringHelper(L\"http://example.com/?abc\"));\n\t\t// Fragment\n\t\tTEST_ASSERT(testToStringHelper(L\"http://example.com/#abc\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"http://example.com/?def#abc\"));\n\n\t\t// Relative\n\t\tTEST_ASSERT(testToStringHelper(L\"a\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"a/\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"/a\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"/a/\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"abc\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"abc/\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"/abc\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"/abc/\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"a/def\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"a/def/\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"/a/def\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"/a/def/\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"abc/def\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"abc/def/\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"/abc/def\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"/abc/def/\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"/\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"//a/\"));\n\t\tTEST_ASSERT(testToStringHelper(L\".\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"./\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"/.\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"/./\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"./abc/def\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"?query\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"#fragment\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"?query#fragment\"));\n\n\t\t// Tests for bugs from the past\n\t\tTEST_ASSERT(testToStringHelper(L\"f:/.//g\"));\n\t}\n\n\tvoid testToString_Bug1950126() {\n\t\tUriParserStateW state;\n\t\tUriUriW uriOne;\n\t\tUriUriW uriTwo;\n\t\tconst wchar_t * const uriOneString = L\"http://e.com/\";\n\t\tconst wchar_t * const uriTwoString = L\"http://e.com\";\n\t\tstate.uri = &uriOne;\n\t\tTEST_ASSERT(URI_SUCCESS == uriParseUriW(&state, uriOneString));\n\t\tstate.uri = &uriTwo;\n\t\tTEST_ASSERT(URI_SUCCESS == uriParseUriW(&state, uriTwoString));\n\t\tTEST_ASSERT(URI_FALSE == uriEqualsUriW(&uriOne, &uriTwo));\n\t\turiFreeUriMembersW(&uriOne);\n\t\turiFreeUriMembersW(&uriTwo);\n\n\t\tTEST_ASSERT(testToStringHelper(uriOneString));\n\t\tTEST_ASSERT(testToStringHelper(uriTwoString));\n\t}\n\n\tbool testToStringCharsRequiredHelper(const wchar_t * text) {\n\t\t// Parse\n\t\tUriParserStateW state;\n\t\tUriUriW uri;\n\t\tstate.uri = &uri;\n\t\tint res = uriParseUriW(&state, text);\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\t// Required space?\n\t\tint charsRequired;\n\t\tif (uriToStringCharsRequiredW(&uri, &charsRequired) != 0) {\n\t\t\turiFreeUriMembersW(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\t// Minimum\n\t\twchar_t * buffer = new wchar_t[charsRequired + 1];\n\t\tif (uriToStringW(buffer, &uri, charsRequired + 1, NULL) != 0) {\n\t\t\turiFreeUriMembersW(&uri);\n\t\t\tdelete [] buffer;\n\t\t\treturn false;\n\t\t}\n\n\t\t// One less than minimum\n\t\tif (uriToStringW(buffer, &uri, charsRequired, NULL) == 0) {\n\t\t\turiFreeUriMembersW(&uri);\n\t\t\tdelete [] buffer;\n\t\t\treturn false;\n\t\t}\n\n\t\turiFreeUriMembersW(&uri);\n\t\tdelete [] buffer;\n\t\treturn true;\n\t}\n\n\tvoid testToStringCharsRequired() {\n\t\tTEST_ASSERT(testToStringCharsRequiredHelper(L\"http://www.example.com/\"));\n\t\tTEST_ASSERT(testToStringCharsRequiredHelper(L\"http://www.example.com:80/\"));\n\t\tTEST_ASSERT(testToStringCharsRequiredHelper(L\"http://user:pass@www.example.com/\"));\n\t\tTEST_ASSERT(testToStringCharsRequiredHelper(L\"http://www.example.com/index.html\"));\n\t\tTEST_ASSERT(testToStringCharsRequiredHelper(L\"http://www.example.com/?abc\"));\n\t\tTEST_ASSERT(testToStringCharsRequiredHelper(L\"http://www.example.com/#def\"));\n\t\tTEST_ASSERT(testToStringCharsRequiredHelper(L\"http://www.example.com/?abc#def\"));\n\t\tTEST_ASSERT(testToStringCharsRequiredHelper(L\"/test\"));\n\t\tTEST_ASSERT(testToStringCharsRequiredHelper(L\"test\"));\n\t}\n\n\tbool testNormalizeMaskHelper(const wchar_t * uriText, unsigned int expectedMask) {\n\t\tUriParserStateW state;\n\t\tUriUriW uri;\n\t\tstate.uri = &uri;\n\t\tint res = uriParseUriW(&state, uriText);\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\tconst unsigned int maskBefore = uriNormalizeSyntaxMaskRequiredW(&uri);\n\t\tif (maskBefore != expectedMask) {\n\t\t\turiFreeUriMembersW(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\tres = uriNormalizeSyntaxW(&uri);\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\tconst unsigned int maskAfter = uriNormalizeSyntaxMaskRequiredW(&uri);\n\t\turiFreeUriMembersW(&uri);\n\n\t\t// Second call should be no problem\n\t\turiFreeUriMembersW(&uri);\n\n\t\treturn (maskAfter == URI_NORMALIZED);\n\t}\n\n\tvoid testNormalizeSyntaxMaskRequired() {\n\t\tTEST_ASSERT(testNormalizeMaskHelper(L\"http://localhost/\", URI_NORMALIZED));\n\t\tTEST_ASSERT(testNormalizeMaskHelper(L\"httP://localhost/\", URI_NORMALIZE_SCHEME));\n\t\tTEST_ASSERT(testNormalizeMaskHelper(L\"http://%0d@localhost/\", URI_NORMALIZE_USER_INFO));\n\t\tTEST_ASSERT(testNormalizeMaskHelper(L\"http://localhosT/\", URI_NORMALIZE_HOST));\n\t\tTEST_ASSERT(testNormalizeMaskHelper(L\"http://localhost/./abc\", URI_NORMALIZE_PATH));\n\t\tTEST_ASSERT(testNormalizeMaskHelper(L\"http://localhost/?AB%43\", URI_NORMALIZE_QUERY));\n\t\tTEST_ASSERT(testNormalizeMaskHelper(L\"http://localhost/#AB%43\", URI_NORMALIZE_FRAGMENT));\n\t}\n\n\tbool testNormalizeSyntaxHelper(const wchar_t * uriText, const wchar_t * expectedNormalized,\n\t\t\tunsigned int mask = static_cast<unsigned int>(-1)) {\n\t\tUriParserStateW stateW;\n\t\tint res;\n\n\t\tUriUriW testUri;\n\t\tstateW.uri = &testUri;\n\t\tres = uriParseUriW(&stateW, uriText);\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&testUri);\n\t\t\treturn false;\n\t\t}\n\n\t\t// Expected result\n\t\tUriUriW expectedUri;\n\t\tstateW.uri = &expectedUri;\n\t\tres = uriParseUriW(&stateW, expectedNormalized);\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&testUri);\n\t\t\turiFreeUriMembersW(&expectedUri);\n\t\t\treturn false;\n\t\t}\n\n\t\t// First run\n\t\tres = uriNormalizeSyntaxExW(&testUri, mask);\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&testUri);\n\t\t\turiFreeUriMembersW(&expectedUri);\n\t\t\treturn false;\n\t\t}\n\n\t\tbool equalAfter = (URI_TRUE == uriEqualsUriW(&testUri, &expectedUri));\n\n\t\t// Second run\n\t\tres = uriNormalizeSyntaxExW(&testUri, mask);\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&testUri);\n\t\t\turiFreeUriMembersW(&expectedUri);\n\t\t\treturn false;\n\t\t}\n\n\t\tequalAfter = equalAfter\n\t\t\t\t&& (URI_TRUE == uriEqualsUriW(&testUri, &expectedUri));\n\n\t\turiFreeUriMembersW(&testUri);\n\t\turiFreeUriMembersW(&expectedUri);\n\t\treturn equalAfter;\n\t}\n\n\tvoid testNormalizeSyntax() {\n\t\tTEST_ASSERT(testNormalizeSyntaxHelper(\n\t\t\t\tL\"eXAMPLE://a/./b/../b/%63/%7bfoo%7d\",\n\t\t\t\tL\"example://a/b/c/%7Bfoo%7D\"));\n\n\t\t// Testcase by Adrian Manrique\n\t\tTEST_ASSERT(testNormalizeSyntaxHelper(\n\t\t\t\tL\"http://examp%4Ce.com/\",\n\t\t\t\tL\"http://example.com/\"));\n\n\t\t// Testcase by Adrian Manrique\n\t\tTEST_ASSERT(testNormalizeSyntaxHelper(\n\t\t\t\tL\"http://example.com/a/b/%2E%2E/\",\n\t\t\t\tL\"http://example.com/a/\"));\n\n\t\t// Reported by Adrian Manrique\n\t\tTEST_ASSERT(testNormalizeSyntaxHelper(\n\t\t\t\tL\"http://user:pass@SOMEHOST.COM:123\",\n\t\t\t\tL\"http://user:pass@somehost.com:123\"));\n\n\t\tTEST_ASSERT(testNormalizeSyntaxHelper(\n\t\t\t\tL\"HTTP://a:b@HOST:123/./1/2/../%41?abc#def\",\n\t\t\t\tL\"http://a:b@host:123/1/A?abc#def\"));\n\n\t\tTEST_ASSERT(testNormalizeSyntaxHelper(\n\t\t\t\tL\"../../abc\",\n\t\t\t\tL\"../../abc\"));\n\n\t\tTEST_ASSERT(testNormalizeSyntaxHelper(\n\t\t\t\tL\"../../abc/..\",\n\t\t\t\tL\"../../\"));\n\n\t\tTEST_ASSERT(testNormalizeSyntaxHelper(\n\t\t\t\tL\"../../abc/../def\",\n\t\t\t\tL\"../../def\"));\n\n\t\tTEST_ASSERT(testNormalizeSyntaxHelper(\n\t\t\t\tL\"abc/..\",\n\t\t\t\tL\"\"));\n\n\t\tTEST_ASSERT(testNormalizeSyntaxHelper(\n\t\t\t\tL\"abc/../\",\n\t\t\t\tL\"\"));\n\n\t\tTEST_ASSERT(testNormalizeSyntaxHelper(\n\t\t\t\tL\"../../abc/./def\",\n\t\t\t\tL\"../../abc/def\"));\n\n\t\tTEST_ASSERT(testNormalizeSyntaxHelper(\n\t\t\t\tL\"./def\",\n\t\t\t\tL\"def\"));\n\n\t\tTEST_ASSERT(testNormalizeSyntaxHelper(\n\t\t\t\tL\"def/.\",\n\t\t\t\tL\"def/\"));\n\n\t\tTEST_ASSERT(testNormalizeSyntaxHelper(\n\t\t\t\tL\"./abc:def\",\n\t\t\t\tL\"./abc:def\"));\n\t}\n\n\tvoid testNormalizeSyntaxComponents() {\n\t\tTEST_ASSERT(testNormalizeSyntaxHelper(\n\t\t\t\tL\"HTTP://%41@EXAMPLE.ORG/../a?%41#%41\",\n\t\t\t\tL\"http://%41@EXAMPLE.ORG/../a?%41#%41\",\n\t\t\t\tURI_NORMALIZE_SCHEME));\n\n\t\tTEST_ASSERT(testNormalizeSyntaxHelper(\n\t\t\t\tL\"HTTP://%41@EXAMPLE.ORG/../a?%41#%41\",\n\t\t\t\tL\"HTTP://A@EXAMPLE.ORG/../a?%41#%41\",\n\t\t\t\tURI_NORMALIZE_USER_INFO));\n\n\t\tTEST_ASSERT(testNormalizeSyntaxHelper(\n\t\t\t\tL\"HTTP://%41@EXAMPLE.ORG/../a?%41#%41\",\n\t\t\t\tL\"HTTP://%41@example.org/../a?%41#%41\",\n\t\t\t\tURI_NORMALIZE_HOST));\n\n\t\tTEST_ASSERT(testNormalizeSyntaxHelper(\n\t\t\t\tL\"HTTP://%41@EXAMPLE.ORG/../a?%41#%41\",\n\t\t\t\tL\"HTTP://%41@EXAMPLE.ORG/a?%41#%41\",\n\t\t\t\tURI_NORMALIZE_PATH));\n\n\t\tTEST_ASSERT(testNormalizeSyntaxHelper(\n\t\t\t\tL\"HTTP://%41@EXAMPLE.ORG/../a?%41#%41\",\n\t\t\t\tL\"HTTP://%41@EXAMPLE.ORG/../a?A#%41\",\n\t\t\t\tURI_NORMALIZE_QUERY));\n\n\t\tTEST_ASSERT(testNormalizeSyntaxHelper(\n\t\t\t\tL\"HTTP://%41@EXAMPLE.ORG/../a?%41#%41\",\n\t\t\t\tL\"HTTP://%41@EXAMPLE.ORG/../a?%41#A\",\n\t\t\t\tURI_NORMALIZE_FRAGMENT));\n\t}\n\n\tvoid testNormalizeCrash_Bug20080224() {\n\t\tUriParserStateW stateW;\n\t\tint res;\n\t\tUriUriW testUri;\n\t\tstateW.uri = &testUri;\n\n\t\tres = uriParseUriW(&stateW, L\"http://example.org/abc//../def\");\n\t\tTEST_ASSERT(res == 0);\n\n\t\t// First call will make us owner of copied memory\n\t\tres = uriNormalizeSyntaxExW(&testUri, URI_NORMALIZE_SCHEME);\n\t\tTEST_ASSERT(res == 0);\n\t\tres = uriNormalizeSyntaxExW(&testUri, URI_NORMALIZE_HOST);\n\t\tTEST_ASSERT(res == 0);\n\n\t\t// Frees empty path segment -> crash\n\t\tres = uriNormalizeSyntaxW(&testUri);\n\t\tTEST_ASSERT(res == 0);\n\n\t\turiFreeUriMembersW(&testUri);\n\t}\n\n\tvoid testFilenameUriConversionHelper(const wchar_t * filename,\n\t\t\tconst wchar_t * uriString, bool forUnix,\n\t\t\tconst wchar_t * expectedUriString = NULL) {\n\t\tconst int prefixLen = forUnix ? 7 : 8;\n\t\tif (! expectedUriString) {\n\t\t\texpectedUriString = uriString;\n\t\t}\n\n\t\t// Filename to URI string\n\t\tconst size_t uriBufferLen = prefixLen + 3 * wcslen(filename) + 1;\n\t\twchar_t * uriBuffer = new wchar_t[uriBufferLen];\n\t\tif (forUnix) {\n\t\t\turiUnixFilenameToUriStringW(filename, uriBuffer);\n\t\t} else {\n\t\t\turiWindowsFilenameToUriStringW(filename, uriBuffer);\n\t\t}\n#ifdef HAVE_WPRINTF\n\t\t// wprintf(L\"1 [%s][%s]\\n\", uriBuffer, expectedUriString);\n#endif\n\t\tTEST_ASSERT(!wcscmp(uriBuffer, expectedUriString));\n\t\tdelete [] uriBuffer;\n\n\t\t// URI string to filename\n\t\tconst size_t filenameBufferLen = wcslen(uriString) + 1;\n\t\twchar_t * filenameBuffer = new wchar_t[filenameBufferLen];\n\t\tif (forUnix) {\n\t\t\turiUriStringToUnixFilenameW(uriString, filenameBuffer);\n\t\t} else {\n\t\t\turiUriStringToWindowsFilenameW(uriString, filenameBuffer);\n\t\t}\n#ifdef HAVE_WPRINTF\n\t\t// wprintf(L\"2 [%s][%s]\\n\", filenameBuffer, filename);\n#endif\n\t\tTEST_ASSERT(!wcscmp(filenameBuffer, filename));\n\t\tdelete [] filenameBuffer;\n\t}\n\n\tvoid testFilenameUriConversion() {\n\t\tconst bool FOR_UNIX = true;\n\t\tconst bool FOR_WINDOWS = false;\n\t\ttestFilenameUriConversionHelper(L\"/bin/bash\", L\"file:///bin/bash\", FOR_UNIX);\n\t\ttestFilenameUriConversionHelper(L\"/bin/bash\", L\"file:/bin/bash\", FOR_UNIX, L\"file:///bin/bash\");\n\t\ttestFilenameUriConversionHelper(L\"./configure\", L\"./configure\", FOR_UNIX);\n\n\t\ttestFilenameUriConversionHelper(L\"E:\\\\Documents and Settings\", L\"file:///E:/Documents%20and%20Settings\", FOR_WINDOWS);\n\t\ttestFilenameUriConversionHelper(L\"c:\\\\path\\\\to\\\\file.txt\", L\"file:c:/path/to/file.txt\", FOR_WINDOWS, L\"file:///c:/path/to/file.txt\");\n\n\t\ttestFilenameUriConversionHelper(L\".\\\\Readme.txt\", L\"./Readme.txt\", FOR_WINDOWS);\n\n\t\ttestFilenameUriConversionHelper(L\"index.htm\", L\"index.htm\", FOR_WINDOWS);\n\t\ttestFilenameUriConversionHelper(L\"index.htm\", L\"index.htm\", FOR_UNIX);\n\n\t\ttestFilenameUriConversionHelper(L\"abc def\", L\"abc%20def\", FOR_WINDOWS);\n\t\ttestFilenameUriConversionHelper(L\"abc def\", L\"abc%20def\", FOR_UNIX);\n\n\t\ttestFilenameUriConversionHelper(L\"\\\\\\\\Server01\\\\user\\\\docs\\\\Letter.txt\", L\"file://Server01/user/docs/Letter.txt\", FOR_WINDOWS);\n\t}\n\n\tvoid testCrash_FreeUriMembers_Bug20080116() {\n\t\t// Testcase by Adrian Manrique\n\t\tUriParserStateA state;\n\t\tUriUriA uri;\n\t\tstate.uri = &uri;\n\t\turiParseUriA(&state, \"http://test/?\");\n\t\turiNormalizeSyntaxA(&uri);\n\t\turiFreeUriMembersA(&uri);\n\n\t\tTEST_ASSERT(true);\n\t}\n\n\tvoid testCrash_Report2418192() {\n\t\t// Testcase by Harvey Vrsalovic\n\t\thelperTestQueryString(\"http://svcs.cnn.com/weather/wrapper.jsp?&csiID=csi1\", 1);\n\t}\n\n\tvoid testPervertedQueryString() {\n\t\thelperTestQueryString(\"http://example.org/?&&=&&&=&&&&==&===&====\", 5);\n\t}\n\n\tvoid testQueryStringEndingInEqualSign_NonBug32() {\n\t\tconst char * queryString = \"firstname=sdsd&lastname=\";\n\n\t\tUriQueryListA * queryList = NULL;\n\t\tint itemCount = 0;\n\t\tconst int res = uriDissectQueryMallocA(&queryList, &itemCount,\n\t\t\t\tqueryString, queryString + strlen(queryString));\n\n\t\tTEST_ASSERT(res == URI_SUCCESS);\n\t\tTEST_ASSERT(itemCount == 2);\n\t\tTEST_ASSERT(queryList != NULL);\n\t\tTEST_ASSERT(strcmp(queryList->key, \"firstname\") == 0);\n\t\tTEST_ASSERT(strcmp(queryList->value, \"sdsd\") == 0);\n\t\tTEST_ASSERT(strcmp(queryList->next->key, \"lastname\") == 0);\n\t\tTEST_ASSERT(strcmp(queryList->next->value, \"\") == 0);\n\t\tTEST_ASSERT(queryList->next->next == NULL);\n\n\t\turiFreeQueryListA(queryList);\n\t}\n\n\tvoid helperTestQueryString(char const * uriString, int pairsExpected) {\n\t\tUriParserStateA state;\n\t\tUriUriA uri;\n\t\tstate.uri = &uri;\n\t\tint res = uriParseUriA(&state, uriString);\n\t\tTEST_ASSERT(res == URI_SUCCESS);\n\n\t\tUriQueryListA * queryList = NULL;\n\t\tint itemCount = 0;\n\n\t\tres = uriDissectQueryMallocA(&queryList, &itemCount,\n\t\t\t\turi.query.first, uri.query.afterLast);\n\t\tTEST_ASSERT(res == URI_SUCCESS);\n\t\tTEST_ASSERT(queryList != NULL);\n\t\tTEST_ASSERT(itemCount == pairsExpected);\n\t\turiFreeQueryListA(queryList);\n\t\turiFreeUriMembersA(&uri);\n\t}\n\n\tvoid testCrash_MakeOwner_Bug20080207() {\n\t\t// Testcase by Adrian Manrique\n\t\tUriParserStateA state;\n\t\tUriUriA sourceUri;\n\t\tstate.uri = &sourceUri;\n\t\tconst char * const sourceUriString = \"http://user:pass@somehost.com:80/\";\n\t\tif (uriParseUriA(&state, sourceUriString) != 0) {\n\t\t\tTEST_ASSERT(false);\n\t\t}\n\t\tif (uriNormalizeSyntaxA(&sourceUri) != 0) {\n\t\t\tTEST_ASSERT(false);\n\t\t}\n\t\turiFreeUriMembersA(&sourceUri);\n\t\tTEST_ASSERT(true);\n\t}\n\n\tvoid testQueryListHelper(const wchar_t * input, int expectedItemCount) {\n\t\tint res;\n\n\t\tUriBool spacePlusConversion = URI_TRUE;\n\t\tUriBool normalizeBreaks = URI_FALSE;\n\t\tUriBreakConversion breakConversion = URI_BR_DONT_TOUCH;\n\n\t\tint itemCount;\n\t\tUriQueryListW * queryList;\n\t\tres = uriDissectQueryMallocExW(&queryList, &itemCount,\n\t\t\t\tinput, input + wcslen(input), spacePlusConversion, breakConversion);\n\t\tTEST_ASSERT(res == URI_SUCCESS);\n\t\tTEST_ASSERT(itemCount == expectedItemCount);\n\t\tTEST_ASSERT((queryList == NULL) == (expectedItemCount == 0));\n\n\t\tif (expectedItemCount != 0) {\n\t\t\t// First\n\t\t\tint charsRequired;\n\t\t\tres = uriComposeQueryCharsRequiredExW(queryList, &charsRequired, spacePlusConversion,\n\t\t\t\t\tnormalizeBreaks);\n\t\t\tTEST_ASSERT(res == URI_SUCCESS);\n\t\t\tTEST_ASSERT(charsRequired >= (int)wcslen(input));\n\n\t\t\twchar_t * recomposed = new wchar_t[charsRequired + 1];\n\t\t\tint charsWritten;\n\t\t\tres = uriComposeQueryExW(recomposed, queryList, charsRequired + 1,\n\t\t\t\t\t&charsWritten, spacePlusConversion, normalizeBreaks);\n\t\t\tTEST_ASSERT(res == URI_SUCCESS);\n\t\t\tTEST_ASSERT(charsWritten <= charsRequired);\n\t\t\tTEST_ASSERT(charsWritten == (int)wcslen(input) + 1);\n\t\t\tTEST_ASSERT(!wcscmp(input, recomposed));\n\t\t\tdelete [] recomposed;\n\n\t\t\trecomposed = NULL;\n\t\t\tres = uriComposeQueryMallocW(&recomposed, queryList);\n\t\t\tTEST_ASSERT(res == URI_SUCCESS);\n\t\t\tTEST_ASSERT(recomposed != NULL);\n\t\t\tTEST_ASSERT(charsWritten == (int)wcslen(input) + 1);\n\t\t\tTEST_ASSERT(!wcscmp(input, recomposed));\n\t\t\tfree(recomposed);\n\t\t}\n\n\t\turiFreeQueryListW(queryList);\n\t}\n\n\tvoid testQueryList() {\n\t\ttestQueryListHelper(L\"one=ONE&two=TWO\", 2);\n\t\ttestQueryListHelper(L\"one=ONE&two=&three=THREE\", 3);\n\t\ttestQueryListHelper(L\"one=ONE&two&three=THREE\", 3);\n\t\ttestQueryListHelper(L\"one=ONE\", 1);\n\t\ttestQueryListHelper(L\"one\", 1);\n\t\ttestQueryListHelper(L\"\", 0);\n\t}\n\n\tvoid testQueryListPairHelper(const char * pair, const char * unescapedKey,\n\t\t\tconst char * unescapedValue, const char * fixed = NULL) {\n\t\tint res;\n\t\tUriQueryListA * queryList;\n\t\tint itemCount;\n\n\t\tres = uriDissectQueryMallocA(&queryList, &itemCount, pair, pair + strlen(pair));\n\t\tTEST_ASSERT(res == URI_SUCCESS);\n\t\tTEST_ASSERT(queryList != NULL);\n\t\tTEST_ASSERT(itemCount == 1);\n\t\tTEST_ASSERT(!strcmp(queryList->key, unescapedKey));\n\t\tTEST_ASSERT(!strcmp(queryList->value, unescapedValue));\n\n\t\tchar * recomposed;\n\t\tres = uriComposeQueryMallocA(&recomposed, queryList);\n\t\tTEST_ASSERT(res == URI_SUCCESS);\n\t\tTEST_ASSERT(recomposed != NULL);\n\t\tTEST_ASSERT(!strcmp(recomposed, (fixed != NULL) ? fixed : pair));\n\t\tfree(recomposed);\n\t\turiFreeQueryListA(queryList);\n\t}\n\n\tvoid testQueryListPair() {\n\t\ttestQueryListPairHelper(\"one+two+%26+three=%2B\", \"one two & three\", \"+\");\n\t\ttestQueryListPairHelper(\"one=two=three\", \"one\", \"two=three\", \"one=two%3Dthree\");\n\t\ttestQueryListPairHelper(\"one=two=three=four\", \"one\", \"two=three=four\", \"one=two%3Dthree%3Dfour\");\n\t}\n\n\tvoid testQueryDissection_Bug3590761() {\n\t\tint res;\n\t\tUriQueryListA * queryList;\n\t\tint itemCount;\n\t\tconst char * const pair = \"q=hello&x=&y=\";\n\n\t\tres = uriDissectQueryMallocA(&queryList, &itemCount, pair, pair + strlen(pair));\n\t\tTEST_ASSERT(res == URI_SUCCESS);\n\t\tTEST_ASSERT(queryList != NULL);\n\t\tTEST_ASSERT(itemCount == 3);\n\n\t\tTEST_ASSERT(!strcmp(queryList->key, \"q\"));\n\t\tTEST_ASSERT(!strcmp(queryList->value, \"hello\"));\n\n\t\tTEST_ASSERT(!strcmp(queryList->next->key, \"x\"));\n\t\tTEST_ASSERT(!strcmp(queryList->next->value, \"\"));\n\n\t\tTEST_ASSERT(!strcmp(queryList->next->next->key, \"y\"));\n\t\tTEST_ASSERT(!strcmp(queryList->next->next->value, \"\"));\n\n\t\tTEST_ASSERT(! queryList->next->next->next);\n\n\t\turiFreeQueryListA(queryList);\n\t}\n\n\tvoid testFreeCrash_Bug20080827() {\n\t\tchar const * const sourceUri = \"abc\";\n\t\tchar const * const baseUri = \"http://www.example.org/\";\n\n\t\tint res;\n\t\tUriParserStateA state;\n\t\tUriUriA absoluteDest;\n\t\tUriUriA relativeSource;\n\t\tUriUriA absoluteBase;\n\n\t\tstate.uri = &relativeSource;\n\t\tres = uriParseUriA(&state, sourceUri);\n\t\tTEST_ASSERT(res == URI_SUCCESS);\n\n\t\tstate.uri = &absoluteBase;\n\t\tres = uriParseUriA(&state, baseUri);\n\t\tTEST_ASSERT(res == URI_SUCCESS);\n\n\t\tres = uriRemoveBaseUriA(&absoluteDest, &relativeSource, &absoluteBase, URI_FALSE);\n\t\tTEST_ASSERT(res == URI_ERROR_REMOVEBASE_REL_SOURCE);\n\n\t\turiFreeUriMembersA(&relativeSource);\n\t\turiFreeUriMembersA(&absoluteBase);\n\t\turiFreeUriMembersA(&absoluteDest); // Crashed here\n\t}\n\n\tvoid testParseInvalid_Bug16() {\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\tconst char * const input = \"A>B\";\n\n\t\tconst int res = uriParseUriA(&stateA, input);\n\n\t\tTEST_ASSERT(res == URI_ERROR_SYNTAX);\n\t\tTEST_ASSERT(stateA.errorPos == input + 1);\n\t\tTEST_ASSERT(stateA.errorCode == URI_ERROR_SYNTAX);  /* failed previously */\n\n\t\turiFreeUriMembersA(&uriA);\n\t}\n\n\tvoid testEqualsHelper(const char * uri_to_test) {\n\t\tUriParserStateA state;\n\t\tUriUriA uriOne;\n\t\tUriUriA uriTwo;\n\t\tstate.uri = &uriOne;\n\t\tTEST_ASSERT(URI_SUCCESS == uriParseUriA(&state, uri_to_test));\n\t\tstate.uri = &uriTwo;\n\t\tTEST_ASSERT(URI_SUCCESS == uriParseUriA(&state, uri_to_test));\n\t\tTEST_ASSERT(URI_TRUE == uriEqualsUriA(&uriOne, &uriTwo));\n\t\turiFreeUriMembersA(&uriOne);\n\t\turiFreeUriMembersA(&uriTwo);\n\t}\n\n\tvoid testEquals() {\n\t\ttestEqualsHelper(\"http://host\");\n\t\ttestEqualsHelper(\"http://host:123\");\n\t\ttestEqualsHelper(\"http://foo:bar@host:123\");\n\t\ttestEqualsHelper(\"http://foo:bar@host:123/\");\n\t\ttestEqualsHelper(\"http://foo:bar@host:123/path\");\n\t\ttestEqualsHelper(\"http://foo:bar@host:123/path?query\");\n\t\ttestEqualsHelper(\"http://foo:bar@host:123/path?query#fragment\");\n\n\t\ttestEqualsHelper(\"path\");\n\t\ttestEqualsHelper(\"/path\");\n\t\ttestEqualsHelper(\"/path/\");\n\t\ttestEqualsHelper(\"//path/\");\n\t\ttestEqualsHelper(\"//host\");\n\t\ttestEqualsHelper(\"//host:123\");\n\t}\n\n\tvoid testHostTextTermination_Issue15() {\n\t\tUriParserStateA state;\n\t\tUriUriA uri;\n\t\tstate.uri = &uri;\n\n\t\t// Empty host and port\n\t\tconst char * const emptyHostWithPortUri = \"//:123\";\n\t\tTEST_ASSERT(URI_SUCCESS == uriParseUriA(&state, emptyHostWithPortUri));\n\t\tTEST_ASSERT(uri.hostText.first == emptyHostWithPortUri + strlen(\"//\"));\n\t\tTEST_ASSERT(uri.hostText.afterLast == uri.hostText.first + 0);\n\t\tTEST_ASSERT(uri.portText.first == emptyHostWithPortUri\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ strlen(\"//:\"));\n\t\tTEST_ASSERT(uri.portText.afterLast == uri.portText.first\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ strlen(\"123\"));\n\t\turiFreeUriMembersA(&uri);\n\n\t\t// Non-empty host and port\n\t\tconst char * const hostWithPortUri = \"//h:123\";\n\t\tTEST_ASSERT(URI_SUCCESS == uriParseUriA(&state, hostWithPortUri));\n\t\tTEST_ASSERT(uri.hostText.first == hostWithPortUri + strlen(\"//\"));\n\t\tTEST_ASSERT(uri.hostText.afterLast == uri.hostText.first\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ strlen(\"h\"));\n\t\tTEST_ASSERT(uri.portText.first == hostWithPortUri + strlen(\"//h:\"));\n\t\tTEST_ASSERT(uri.portText.afterLast == uri.portText.first\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ strlen(\"123\"));\n\t\turiFreeUriMembersA(&uri);\n\n\t\t// Empty host, empty user info\n\t\tconst char * const emptyHostEmptyUserInfoUri = \"//@\";\n\t\tTEST_ASSERT(URI_SUCCESS == uriParseUriA(&state,\n\t\t\t\t\t\t\t\t\t\t\t\temptyHostEmptyUserInfoUri));\n\t\tTEST_ASSERT(uri.userInfo.first == emptyHostEmptyUserInfoUri\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ strlen(\"//\"));\n\t\tTEST_ASSERT(uri.userInfo.afterLast == uri.userInfo.first + 0);\n\t\tTEST_ASSERT(uri.hostText.first == emptyHostEmptyUserInfoUri\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ strlen(\"//@\"));\n\t\tTEST_ASSERT(uri.hostText.afterLast == uri.hostText.first + 0);\n\t\turiFreeUriMembersA(&uri);\n\n\t\t// Non-empty host, empty user info\n\t\tconst char * const hostEmptyUserInfoUri = \"//@h\";\n\t\tTEST_ASSERT(URI_SUCCESS == uriParseUriA(&state, hostEmptyUserInfoUri));\n\t\tTEST_ASSERT(uri.userInfo.first == hostEmptyUserInfoUri + strlen(\"//\"));\n\t\tTEST_ASSERT(uri.userInfo.afterLast == uri.userInfo.first + 0);\n\t\tTEST_ASSERT(uri.hostText.first == hostEmptyUserInfoUri\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ strlen(\"//@\"));\n\t\tTEST_ASSERT(uri.hostText.afterLast == uri.hostText.first\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ strlen(\"h\"));\n\t\turiFreeUriMembersA(&uri);\n\n\t\t// Empty host, non-empty user info\n\t\tconst char * const emptyHostWithUserInfoUri = \"//:@\";\n\t\tTEST_ASSERT(URI_SUCCESS == uriParseUriA(&state,\n\t\t\t\t\t\t\t\t\t\t\t\temptyHostWithUserInfoUri));\n\t\tTEST_ASSERT(uri.userInfo.first == emptyHostWithUserInfoUri\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ strlen(\"//\"));\n\t\tTEST_ASSERT(uri.userInfo.afterLast == uri.userInfo.first + 1);\n\t\tTEST_ASSERT(uri.hostText.first == emptyHostWithUserInfoUri\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ strlen(\"//:@\"));\n\t\tTEST_ASSERT(uri.hostText.afterLast == uri.hostText.first + 0);\n\t\turiFreeUriMembersA(&uri);\n\n\t\t// Exact case from issue #15\n\t\tconst char * const issue15Uri = \"//:%aa@\";\n\t\tTEST_ASSERT(URI_SUCCESS == uriParseUriA(&state, issue15Uri));\n\t\tTEST_ASSERT(uri.userInfo.first == issue15Uri + strlen(\"//\"));\n\t\tTEST_ASSERT(uri.userInfo.afterLast == uri.userInfo.first\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ strlen(\":%aa\"));\n\t\tTEST_ASSERT(uri.hostText.first == issue15Uri + strlen(\"//:%aa@\"));\n\t\tTEST_ASSERT(uri.hostText.afterLast == uri.hostText.first + 0);\n\t\turiFreeUriMembersA(&uri);\n\t}\n\n\tvoid testCompareRangeHelper(const char * a, const char * b, int expected, bool avoidNullRange = true) {\n\t\tUriTextRangeA ra;\n\t\tUriTextRangeA rb;\n\n\t\tif (a) {\n\t\t\tra.first = a;\n\t\t\tra.afterLast = a + strlen(a);\n\t\t} else {\n\t\t\tra.first = NULL;\n\t\t\tra.afterLast = NULL;\n\t\t}\n\n\t\tif (b) {\n\t\t\trb.first = b;\n\t\t\trb.afterLast = b + strlen(b);\n\t\t} else {\n\t\t\trb.first = NULL;\n\t\t\trb.afterLast = NULL;\n\t\t}\n\n\t\tconst int received = uriCompareRangeA(\n\t\t\t\t((a == NULL) && avoidNullRange) ? NULL : &ra,\n\t\t\t\t((b == NULL) && avoidNullRange) ? NULL : &rb);\n\t\tif (received != expected) {\n\t\t\tprintf(\"Comparing <%s> to <%s> yields %d, expected %d.\\n\",\n\t\t\t\t\ta, b, received, expected);\n\t\t}\n\t\tTEST_ASSERT(received == expected);\n\t}\n\n\tvoid testRangeComparison() {\n\t\ttestCompareRangeHelper(\"\", \"\", 0);\n\t\ttestCompareRangeHelper(\"a\", \"\", 1);\n\t\ttestCompareRangeHelper(\"\", \"a\", -1);\n\n\t\ttestCompareRangeHelper(\"a\", \"a\", 0);\n\t\ttestCompareRangeHelper(\"a\", \"b\", -1);\n\t\ttestCompareRangeHelper(\"b\", \"a\", 1);\n\n\t\ttestCompareRangeHelper(\"a\", \"aa\", -1);\n\t\ttestCompareRangeHelper(\"aa\", \"a\", 1);\n\n\t\t// Fixed with 0.8.1:\n\t\ttestCompareRangeHelper(NULL, \"a\", -1);\n\t\ttestCompareRangeHelper(\"a\", NULL, 1);\n\t\ttestCompareRangeHelper(NULL, NULL, 0);\n\n\t\t// Fixed with 0.8.3\n\t\tconst bool KEEP_NULL_RANGE = false;\n\t\tconst bool AVOID_NULL_RANGE = true;\n\t\ttestCompareRangeHelper(NULL, \"\", -1, AVOID_NULL_RANGE);\n\t\ttestCompareRangeHelper(NULL, \"\", -1, KEEP_NULL_RANGE);\n\t\ttestCompareRangeHelper(\"\", NULL, 1, AVOID_NULL_RANGE);\n\t\ttestCompareRangeHelper(\"\", NULL, 1, KEEP_NULL_RANGE);\n\t}\n\n\tvoid testRemoveBaseUriHelper(const char * expected,\n\t\t\t\t\t\t\t\tconst char * absSourceStr,\n\t\t\t\t\t\t\t\tconst char * absBaseStr) {\n\t\tUriParserStateA state;\n\t\tUriUriA absSource;\n\t\tUriUriA absBase;\n\t\tUriUriA dest;\n\n\t\tstate.uri = &absSource;\n\t\tTEST_ASSERT(uriParseUriA(&state, absSourceStr) == URI_SUCCESS);\n\n\t\tstate.uri = &absBase;\n\t\tTEST_ASSERT(uriParseUriA(&state, absBaseStr) == URI_SUCCESS);\n\n\t\tTEST_ASSERT(uriRemoveBaseUriA(&dest, &absSource, &absBase, URI_FALSE)\n\t\t\t\t== URI_SUCCESS);\n\n\t\tint size = 0;\n\t\tTEST_ASSERT(uriToStringCharsRequiredA(&dest, &size) == URI_SUCCESS);\n\t\tchar * const buffer = (char *)malloc(size + 1);\n\t\tTEST_ASSERT(buffer);\n\t\tTEST_ASSERT(uriToStringA(buffer, &dest, size + 1, &size)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t== URI_SUCCESS);\n\t\tif (strcmp(buffer, expected)) {\n\t\t\tprintf(\"Expected \\\"%s\\\" but got \\\"%s\\\"\\n\", expected, buffer);\n\t\t\tTEST_ASSERT(0);\n\t\t}\n\t\tfree(buffer);\n\t}\n\n\tvoid testRangeComparison_RemoveBaseUri_Issue19() {\n\t\t// scheme\n\t\ttestRemoveBaseUriHelper(\"scheme://host/source\",\n\t\t\t\t\t\t\t\t\"scheme://host/source\",\n\t\t\t\t\t\t\t\t\"schemelonger://host/base\");\n\t\ttestRemoveBaseUriHelper(\"schemelonger://host/source\",\n\t\t\t\t\t\t\t\t\"schemelonger://host/source\",\n\t\t\t\t\t\t\t\t\"scheme://host/base\");\n\n\t\t// hostText\n\t\ttestRemoveBaseUriHelper(\"//host/source\",\n\t\t\t\t\t\t\t\t\"http://host/source\",\n\t\t\t\t\t\t\t\t\"http://hostlonger/base\");\n\t\ttestRemoveBaseUriHelper(\"//hostlonger/source\",\n\t\t\t\t\t\t\t\t\"http://hostlonger/source\",\n\t\t\t\t\t\t\t\t\"http://host/base\");\n\n\t\t// hostData.ipFuture\n\t\ttestRemoveBaseUriHelper(\"//[v7.host]/source\",\n\t\t\t\t\t\t\t\t\"http://[v7.host]/source\",\n\t\t\t\t\t\t\t\t\"http://[v7.hostlonger]/base\");\n\t\ttestRemoveBaseUriHelper(\"//[v7.hostlonger]/source\",\n\t\t\t\t\t\t\t\t\"http://[v7.hostlonger]/source\",\n\t\t\t\t\t\t\t\t\"http://host/base\");\n\n\t\t// path\n\t\ttestRemoveBaseUriHelper(\"path1\",\n\t\t\t\t\t\t\t\t\"http://host/path1\",\n\t\t\t\t\t\t\t\t\"http://host/path111\");\n\t\ttestRemoveBaseUriHelper(\"../path1/path2\",\n\t\t\t\t\t\t\t\t\"http://host/path1/path2\",\n\t\t\t\t\t\t\t\t\"http://host/path111/path222\");\n\t\ttestRemoveBaseUriHelper(\"path111\",\n\t\t\t\t\t\t\t\t\"http://host/path111\",\n\t\t\t\t\t\t\t\t\"http://host/path1\");\n\t\ttestRemoveBaseUriHelper(\"../path111/path222\",\n\t\t\t\t\t\t\t\t\"http://host/path111/path222\",\n\t\t\t\t\t\t\t\t\"http://host/path1/path2\");\n\n\t\t// Exact issue #19\n\t\ttestRemoveBaseUriHelper(\"//example/x/abc\",\n\t\t\t\t\t\t\t\t\"http://example/x/abc\",\n\t\t\t\t\t\t\t\t\"http://example2/x/y/z\");\n\t}\n};\n\n\nint main() {\n\tSuite suite;\n\tsuite.add(auto_ptr<Suite>(new UriSuite()));\n\tsuite.add(auto_ptr<Suite>(new FourSuite()));\n\tsuite.add(auto_ptr<Suite>(new VersionSuite()));\n\tTextOutput output(TextOutput::Verbose);\n\treturn suite.run(output, false) ? 0 : 1;\n}\n"], "fixing_code": ["/*\n * uriparser - RFC 3986 URI parsing library\n *\n * Copyright (C) 2007, Weijia Song <songweijia@gmail.com>\n * Copyright (C) 2007, Sebastian Pipping <sebastian@pipping.org>\n * All rights reserved.\n *\n * Redistribution  and use in source and binary forms, with or without\n * modification,  are permitted provided that the following conditions\n * are met:\n *\n *     * Redistributions   of  source  code  must  retain  the   above\n *       copyright  notice, this list of conditions and the  following\n *       disclaimer.\n *\n *     * Redistributions  in  binary  form must  reproduce  the  above\n *       copyright  notice, this list of conditions and the  following\n *       disclaimer   in  the  documentation  and/or  other  materials\n *       provided with the distribution.\n *\n *     * Neither  the name of the <ORGANIZATION> nor the names of  its\n *       contributors  may  be  used to endorse  or  promote  products\n *       derived  from  this software without specific  prior  written\n *       permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS  IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT  NOT\n * LIMITED  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS\n * FOR  A  PARTICULAR  PURPOSE ARE DISCLAIMED. IN NO EVENT  SHALL  THE\n * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL,    SPECIAL,   EXEMPLARY,   OR   CONSEQUENTIAL   DAMAGES\n * (INCLUDING,  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT  LIABILITY,  OR  TORT (INCLUDING  NEGLIGENCE  OR  OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* What encodings are enabled? */\n#include <uriparser/UriDefsConfig.h>\n#if (!defined(URI_PASS_ANSI) && !defined(URI_PASS_UNICODE))\n/* Include SELF twice */\n# ifdef URI_ENABLE_ANSI\n#  define URI_PASS_ANSI 1\n#  include \"UriQuery.c\"\n#  undef URI_PASS_ANSI\n# endif\n# ifdef URI_ENABLE_UNICODE\n#  define URI_PASS_UNICODE 1\n#  include \"UriQuery.c\"\n#  undef URI_PASS_UNICODE\n# endif\n#else\n# ifdef URI_PASS_ANSI\n#  include <uriparser/UriDefsAnsi.h>\n# else\n#  include <uriparser/UriDefsUnicode.h>\n#  include <wchar.h>\n# endif\n\n\n\n#ifndef URI_DOXYGEN\n# include <uriparser/Uri.h>\n# include \"UriCommon.h\"\n#endif\n\n\n\nstatic int URI_FUNC(ComposeQueryEngine)(URI_CHAR * dest,\n\t\tconst URI_TYPE(QueryList) * queryList,\n\t\tint maxChars, int * charsWritten, int * charsRequired,\n\t\tUriBool spaceToPlus, UriBool normalizeBreaks);\n\nstatic UriBool URI_FUNC(AppendQueryItem)(URI_TYPE(QueryList) ** prevNext,\n\t\tint * itemCount, const URI_CHAR * keyFirst, const URI_CHAR * keyAfter,\n\t\tconst URI_CHAR * valueFirst, const URI_CHAR * valueAfter,\n\t\tUriBool plusToSpace, UriBreakConversion breakConversion);\n\n\n\nint URI_FUNC(ComposeQueryCharsRequired)(const URI_TYPE(QueryList) * queryList,\n\t\tint * charsRequired) {\n\tconst UriBool spaceToPlus = URI_TRUE;\n\tconst UriBool normalizeBreaks = URI_TRUE;\n\n\treturn URI_FUNC(ComposeQueryCharsRequiredEx)(queryList, charsRequired,\n\t\t\tspaceToPlus, normalizeBreaks);\n}\n\n\n\nint URI_FUNC(ComposeQueryCharsRequiredEx)(const URI_TYPE(QueryList) * queryList,\n\t\tint * charsRequired, UriBool spaceToPlus, UriBool normalizeBreaks) {\n\tif ((queryList == NULL) || (charsRequired == NULL)) {\n\t\treturn URI_ERROR_NULL;\n\t}\n\n\treturn URI_FUNC(ComposeQueryEngine)(NULL, queryList, 0, NULL,\n\t\t\tcharsRequired, spaceToPlus, normalizeBreaks);\n}\n\n\n\nint URI_FUNC(ComposeQuery)(URI_CHAR * dest,\n\t\t\t\t\t\t   const URI_TYPE(QueryList) * queryList, int maxChars, int * charsWritten) {\n\tconst UriBool spaceToPlus = URI_TRUE;\n\tconst UriBool normalizeBreaks = URI_TRUE;\n\n\treturn URI_FUNC(ComposeQueryEx)(dest, queryList, maxChars, charsWritten,\n\t\t\tspaceToPlus, normalizeBreaks);\n}\n\n\n\nint URI_FUNC(ComposeQueryEx)(URI_CHAR * dest,\n\t\tconst URI_TYPE(QueryList) * queryList, int maxChars, int * charsWritten,\n\t\tUriBool spaceToPlus, UriBool normalizeBreaks) {\n\tif ((dest == NULL) || (queryList == NULL)) {\n\t\treturn URI_ERROR_NULL;\n\t}\n\n\tif (maxChars < 1) {\n\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t}\n\n\treturn URI_FUNC(ComposeQueryEngine)(dest, queryList, maxChars,\n\t\t\tcharsWritten, NULL, spaceToPlus, normalizeBreaks);\n}\n\n\n\nint URI_FUNC(ComposeQueryMalloc)(URI_CHAR ** dest,\n\t\tconst URI_TYPE(QueryList) * queryList) {\n\tconst UriBool spaceToPlus = URI_TRUE;\n\tconst UriBool normalizeBreaks = URI_TRUE;\n\n\treturn URI_FUNC(ComposeQueryMallocEx)(dest, queryList,\n\t\t\tspaceToPlus, normalizeBreaks);\n}\n\n\n\nint URI_FUNC(ComposeQueryMallocEx)(URI_CHAR ** dest,\n\t\tconst URI_TYPE(QueryList) * queryList,\n\t\tUriBool spaceToPlus, UriBool normalizeBreaks) {\n\tint charsRequired;\n\tint res;\n\tURI_CHAR * queryString;\n\n\tif (dest == NULL) {\n\t\treturn URI_ERROR_NULL;\n\t}\n\n\t/* Calculate space */\n\tres = URI_FUNC(ComposeQueryCharsRequiredEx)(queryList, &charsRequired,\n\t\t\tspaceToPlus, normalizeBreaks);\n\tif (res != URI_SUCCESS) {\n\t\treturn res;\n\t}\n\tcharsRequired++;\n\n\t/* Allocate space */\n\tqueryString = malloc(charsRequired * sizeof(URI_CHAR));\n\tif (queryString == NULL) {\n\t\treturn URI_ERROR_MALLOC;\n\t}\n\n\t/* Put query in */\n\tres = URI_FUNC(ComposeQueryEx)(queryString, queryList, charsRequired,\n\t\t\tNULL, spaceToPlus, normalizeBreaks);\n\tif (res != URI_SUCCESS) {\n\t\tfree(queryString);\n\t\treturn res;\n\t}\n\n\t*dest = queryString;\n\treturn URI_SUCCESS;\n}\n\n\n\nint URI_FUNC(ComposeQueryEngine)(URI_CHAR * dest,\n\t\tconst URI_TYPE(QueryList) * queryList,\n\t\tint maxChars, int * charsWritten, int * charsRequired,\n\t\tUriBool spaceToPlus, UriBool normalizeBreaks) {\n\tUriBool firstItem = URI_TRUE;\n\tint ampersandLen = 0;  /* increased to 1 from second item on */\n\tURI_CHAR * write = dest;\n\n\t/* Subtract terminator */\n\tif (dest == NULL) {\n\t\t*charsRequired = 0;\n\t} else {\n\t\tmaxChars--;\n\t}\n\t\t\t\n\twhile (queryList != NULL) {\n\t\tconst URI_CHAR * const key = queryList->key;\n\t\tconst URI_CHAR * const value = queryList->value;\n\t\tconst int worstCase = (normalizeBreaks == URI_TRUE ? 6 : 3);\n\t\tconst int keyLen = (key == NULL) ? 0 : (int)URI_STRLEN(key);\n\t\tconst int keyRequiredChars = worstCase * keyLen;\n\t\tconst int valueLen = (value == NULL) ? 0 : (int)URI_STRLEN(value);\n\t\tconst int valueRequiredChars = worstCase * valueLen;\n\n\t\tif (dest == NULL) {\n\t\t\tif (firstItem == URI_TRUE) {\n\t\t\t\tampersandLen = 1;\n\t\t\t\tfirstItem = URI_FALSE;\n\t\t\t}\n\n\t\t\t(*charsRequired) += ampersandLen + keyRequiredChars + ((value == NULL)\n\t\t\t\t\t\t? 0\n\t\t\t\t\t\t: 1 + valueRequiredChars);\n\t\t} else {\n\t\t\tURI_CHAR * afterKey;\n\n\t\t\tif ((write - dest) + ampersandLen + keyRequiredChars > maxChars) {\n\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t\t}\n\n\t\t\t/* Copy key */\n\t\t\tif (firstItem == URI_TRUE) {\n\t\t\t\tampersandLen = 1;\n\t\t\t\tfirstItem = URI_FALSE;\n\t\t\t} else {\n\t\t\t\twrite[0] = _UT('&');\n\t\t\t\twrite++;\n\t\t\t}\n\t\t\tafterKey = URI_FUNC(EscapeEx)(key, key + keyLen,\n\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);\n\t\t\twrite += (afterKey - write);\n\n\t\t\tif (value != NULL) {\n\t\t\t\tURI_CHAR * afterValue;\n\n\t\t\t\tif ((write - dest) + 1 + valueRequiredChars > maxChars) {\n\t\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t\t\t}\n\n\t\t\t\t/* Copy value */\n\t\t\t\twrite[0] = _UT('=');\n\t\t\t\twrite++;\n\t\t\t\tafterValue = URI_FUNC(EscapeEx)(value, value + valueLen,\n\t\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);\n\t\t\t\twrite += (afterValue - write);\n\t\t\t}\n\t\t}\n\n\t\tqueryList = queryList->next;\n\t}\n\n\tif (dest != NULL) {\n\t\twrite[0] = _UT('\\0');\n\t\tif (charsWritten != NULL) {\n\t\t\t*charsWritten = (int)(write - dest) + 1; /* .. for terminator */\n\t\t}\n\t}\n\n\treturn URI_SUCCESS;\n}\n\n\n\nUriBool URI_FUNC(AppendQueryItem)(URI_TYPE(QueryList) ** prevNext,\n\t\tint * itemCount, const URI_CHAR * keyFirst, const URI_CHAR * keyAfter,\n\t\tconst URI_CHAR * valueFirst, const URI_CHAR * valueAfter,\n\t\tUriBool plusToSpace, UriBreakConversion breakConversion) {\n\tconst int keyLen = (int)(keyAfter - keyFirst);\n\tconst int valueLen = (int)(valueAfter - valueFirst);\n\tURI_CHAR * key;\n\tURI_CHAR * value;\n\n\tif ((prevNext == NULL) || (itemCount == NULL)\n\t\t\t|| (keyFirst == NULL) || (keyAfter == NULL)\n\t\t\t|| (keyFirst > keyAfter) || (valueFirst > valueAfter)\n\t\t\t|| ((keyFirst == keyAfter)\n\t\t\t\t&& (valueFirst == NULL) && (valueAfter == NULL))) {\n\t\treturn URI_TRUE;\n\t}\n\n\t/* Append new empty item */\n\t*prevNext = malloc(1 * sizeof(URI_TYPE(QueryList)));\n\tif (*prevNext == NULL) {\n\t\treturn URI_FALSE; /* Raises malloc error */\n\t}\n\t(*prevNext)->next = NULL;\n\n\n\t/* Fill key */\n\tkey = malloc((keyLen + 1) * sizeof(URI_CHAR));\n\tif (key == NULL) {\n\t\tfree(*prevNext);\n\t\t*prevNext = NULL;\n\t\treturn URI_FALSE; /* Raises malloc error */\n\t}\n\n\tkey[keyLen] = _UT('\\0');\n\tif (keyLen > 0) {\n\t\t/* Copy 1:1 */\n\t\tmemcpy(key, keyFirst, keyLen * sizeof(URI_CHAR));\n\n\t\t/* Unescape */\n\t\tURI_FUNC(UnescapeInPlaceEx)(key, plusToSpace, breakConversion);\n\t}\n\t(*prevNext)->key = key;\n\n\n\t/* Fill value */\n\tif (valueFirst != NULL) {\n\t\tvalue = malloc((valueLen + 1) * sizeof(URI_CHAR));\n\t\tif (value == NULL) {\n\t\t\tfree(key);\n\t\t\tfree(*prevNext);\n\t\t\t*prevNext = NULL;\n\t\t\treturn URI_FALSE; /* Raises malloc error */\n\t\t}\n\n\t\tvalue[valueLen] = _UT('\\0');\n\t\tif (valueLen > 0) {\n\t\t\t/* Copy 1:1 */\n\t\t\tmemcpy(value, valueFirst, valueLen * sizeof(URI_CHAR));\n\n\t\t\t/* Unescape */\n\t\t\tURI_FUNC(UnescapeInPlaceEx)(value, plusToSpace, breakConversion);\n\t\t}\n\t\t(*prevNext)->value = value;\n\t} else {\n\t\tvalue = NULL;\n\t}\n\t(*prevNext)->value = value;\n\n\t(*itemCount)++;\n\treturn URI_TRUE;\n}\n\n\n\nvoid URI_FUNC(FreeQueryList)(URI_TYPE(QueryList) * queryList) {\n\twhile (queryList != NULL) {\n\t\tURI_TYPE(QueryList) * nextBackup = queryList->next;\n\t\tfree((URI_CHAR *)queryList->key); /* const cast */\n\t\tfree((URI_CHAR *)queryList->value); /* const cast */\n\t\tfree(queryList);\n\t\tqueryList = nextBackup;\n\t}\n}\n\n\n\nint URI_FUNC(DissectQueryMalloc)(URI_TYPE(QueryList) ** dest, int * itemCount,\n\t\tconst URI_CHAR * first, const URI_CHAR * afterLast) {\n\tconst UriBool plusToSpace = URI_TRUE;\n\tconst UriBreakConversion breakConversion = URI_BR_DONT_TOUCH;\n\n\treturn URI_FUNC(DissectQueryMallocEx)(dest, itemCount, first, afterLast,\n\t\t\tplusToSpace, breakConversion);\n}\n\n\n\nint URI_FUNC(DissectQueryMallocEx)(URI_TYPE(QueryList) ** dest, int * itemCount,\n\t\tconst URI_CHAR * first, const URI_CHAR * afterLast,\n\t\tUriBool plusToSpace, UriBreakConversion breakConversion) {\n\tconst URI_CHAR * walk = first;\n\tconst URI_CHAR * keyFirst = first;\n\tconst URI_CHAR * keyAfter = NULL;\n\tconst URI_CHAR * valueFirst = NULL;\n\tconst URI_CHAR * valueAfter = NULL;\n\tURI_TYPE(QueryList) ** prevNext = dest;\n\tint nullCounter;\n\tint * itemsAppended = (itemCount == NULL) ? &nullCounter : itemCount;\n\n\tif ((dest == NULL) || (first == NULL) || (afterLast == NULL)) {\n\t\treturn URI_ERROR_NULL;\n\t}\n\n\tif (first > afterLast) {\n\t\treturn URI_ERROR_RANGE_INVALID;\n\t}\n\n\t*dest = NULL;\n\t*itemsAppended = 0;\n\n\t/* Parse query string */\n\tfor (; walk < afterLast; walk++) {\n\t\tswitch (*walk) {\n\t\tcase _UT('&'):\n\t\t\tif (valueFirst != NULL) {\n\t\t\t\tvalueAfter = walk;\n\t\t\t} else {\n\t\t\t\tkeyAfter = walk;\n\t\t\t}\n\n\t\t\tif (URI_FUNC(AppendQueryItem)(prevNext, itemsAppended,\n\t\t\t\t\tkeyFirst, keyAfter, valueFirst, valueAfter,\n\t\t\t\t\tplusToSpace, breakConversion)\n\t\t\t\t\t== URI_FALSE) {\n\t\t\t\t/* Free list we built */\n\t\t\t\t*itemsAppended = 0;\n\t\t\t\tURI_FUNC(FreeQueryList)(*dest);\n\t\t\t\treturn URI_ERROR_MALLOC;\n\t\t\t}\n\n\t\t\t/* Make future items children of the current */\n\t\t\tif ((prevNext != NULL) && (*prevNext != NULL)) {\n\t\t\t\tprevNext = &((*prevNext)->next);\n\t\t\t}\n\n\t\t\tif (walk + 1 < afterLast) {\n\t\t\t\tkeyFirst = walk + 1;\n\t\t\t} else {\n\t\t\t\tkeyFirst = NULL;\n\t\t\t}\n\t\t\tkeyAfter = NULL;\n\t\t\tvalueFirst = NULL;\n\t\t\tvalueAfter = NULL;\n\t\t\tbreak;\n\n\t\tcase _UT('='):\n\t\t\t/* NOTE: WE treat the first '=' as a separator, */\n\t\t\t/*       all following go into the value part   */\n\t\t\tif (keyAfter == NULL) {\n\t\t\t\tkeyAfter = walk;\n\t\t\t\tif (walk + 1 <= afterLast) {\n\t\t\t\t\tvalueFirst = walk + 1;\n\t\t\t\t\tvalueAfter = walk + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (valueFirst != NULL) {\n\t\t/* Must be key/value pair */\n\t\tvalueAfter = walk;\n\t} else {\n\t\t/* Must be key only */\n\t\tkeyAfter = walk;\n\t}\n\n\tif (URI_FUNC(AppendQueryItem)(prevNext, itemsAppended, keyFirst, keyAfter,\n\t\t\tvalueFirst, valueAfter, plusToSpace, breakConversion)\n\t\t\t== URI_FALSE) {\n\t\t/* Free list we built */\n\t\t*itemsAppended = 0;\n\t\tURI_FUNC(FreeQueryList)(*dest);\n\t\treturn URI_ERROR_MALLOC;\n\t}\n\n\treturn URI_SUCCESS;\n}\n\n\n\n#endif\n", "/*\n * uriparser - RFC 3986 URI parsing library\n *\n * Copyright (C) 2007, Weijia Song <songweijia@gmail.com>\n * Copyright (C) 2007, Sebastian Pipping <sebastian@pipping.org>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#include <uriparser/Uri.h>\n#include <cpptest.h>\n#include <memory>\n#include <stdio.h>\n#include <stdlib.h>\n#include <wchar.h>\n\n#include \"FourSuite.h\"\n#include \"VersionSuite.h\"\n\nusing namespace Test;\nusing namespace std;\n\n\n\nextern \"C\" {\nUriBool uri_TESTING_ONLY_ParseIpSixA(const char * text);\nUriBool uri_TESTING_ONLY_ParseIpFourA(const char * text);\nint uriCompareRangeA(const UriTextRangeA * a, const UriTextRangeA * b);\n}\n\n\n\n#define URI_TEST_IP_FOUR_FAIL(x) TEST_ASSERT(URI_FALSE == uri_TESTING_ONLY_ParseIpFourA(x))\n#define URI_TEST_IP_FOUR_PASS(x) TEST_ASSERT(URI_TRUE == uri_TESTING_ONLY_ParseIpFourA(x))\n\n// Note the closing brackets! TODO\n#define URI_TEST_IP_SIX_FAIL(x) TEST_ASSERT(URI_FALSE == uri_TESTING_ONLY_ParseIpSixA(x \"]\"))\n#define URI_TEST_IP_SIX_PASS(x) TEST_ASSERT(URI_TRUE == uri_TESTING_ONLY_ParseIpSixA(x \"]\"))\n\n\n\nclass UriSuite : public Suite {\n\npublic:\n\tUriSuite() {\n\t\tTEST_ADD(UriSuite::testDistinction)\n\t\tTEST_ADD(UriSuite::testIpFour)\n\t\tTEST_ADD(UriSuite::testIpSixPass)\n\t\tTEST_ADD(UriSuite::testIpSixFail)\n\t\tTEST_ADD(UriSuite::testUri)\n\t\tTEST_ADD(UriSuite::testUriUserInfoHostPort1)\n\t\tTEST_ADD(UriSuite::testUriUserInfoHostPort2)\n\t\tTEST_ADD(UriSuite::testUriUserInfoHostPort22_Bug1948038)\n\t\tTEST_ADD(UriSuite::testUriUserInfoHostPort23_Bug3510198_1)\n\t\tTEST_ADD(UriSuite::testUriUserInfoHostPort23_Bug3510198_2)\n\t\tTEST_ADD(UriSuite::testUriUserInfoHostPort23_Bug3510198_3)\n\t\tTEST_ADD(UriSuite::testUriUserInfoHostPort23_Bug3510198_4)\n\t\tTEST_ADD(UriSuite::testUriUserInfoHostPort23_Bug3510198_related_1)\n\t\tTEST_ADD(UriSuite::testUriUserInfoHostPort23_Bug3510198_related_12)\n\t\tTEST_ADD(UriSuite::testUriUserInfoHostPort23_Bug3510198_related_2)\n\t\tTEST_ADD(UriSuite::testUriUserInfoHostPort3)\n\t\tTEST_ADD(UriSuite::testUriUserInfoHostPort4)\n\t\tTEST_ADD(UriSuite::testUriUserInfoHostPort5)\n\t\tTEST_ADD(UriSuite::testUriUserInfoHostPort6)\n\t\tTEST_ADD(UriSuite::testUriHostRegname)\n\t\tTEST_ADD(UriSuite::testUriHostIpFour1)\n\t\tTEST_ADD(UriSuite::testUriHostIpFour2)\n\t\tTEST_ADD(UriSuite::testUriHostIpSix1)\n\t\tTEST_ADD(UriSuite::testUriHostIpSix2)\n\t\tTEST_ADD(UriSuite::testUriHostIpFuture)\n\t\tTEST_ADD(UriSuite::testUriHostEmpty)\n\t\tTEST_ADD(UriSuite::testUriComponents)\n\t\tTEST_ADD(UriSuite::testUriComponents_Bug20070701)\n\t\tTEST_ADD(UriSuite::testEscaping)\n\t\tTEST_ADD(UriSuite::testUnescaping)\n\t\tTEST_ADD(UriSuite::testTrailingSlash)\n\t\tTEST_ADD(UriSuite::testAddBase)\n\t\tTEST_ADD(UriSuite::testToString)\n\t\tTEST_ADD(UriSuite::testToString_Bug1950126)\n\t\tTEST_ADD(UriSuite::testToStringCharsRequired)\n\t\tTEST_ADD(UriSuite::testToStringCharsRequired)\n\t\tTEST_ADD(UriSuite::testNormalizeSyntaxMaskRequired)\n\t\tTEST_ADD(UriSuite::testNormalizeSyntax)\n\t\tTEST_ADD(UriSuite::testNormalizeSyntaxComponents)\n\t\tTEST_ADD(UriSuite::testNormalizeCrash_Bug20080224)\n\t\tTEST_ADD(UriSuite::testFilenameUriConversion)\n\t\tTEST_ADD(UriSuite::testCrash_FreeUriMembers_Bug20080116)\n\t\tTEST_ADD(UriSuite::testCrash_Report2418192)\n\t\tTEST_ADD(UriSuite::testPervertedQueryString);\n\t\tTEST_ADD(UriSuite::testQueryStringEndingInEqualSign_NonBug32);\n\t\tTEST_ADD(UriSuite::testCrash_MakeOwner_Bug20080207)\n\t\tTEST_ADD(UriSuite::testQueryList)\n\t\tTEST_ADD(UriSuite::testQueryListPair)\n\t\tTEST_ADD(UriSuite::testQueryDissection_Bug3590761)\n\t\tTEST_ADD(UriSuite::testQueryCompositionMathWrite_GoogleAutofuzz113244572)\n\t\tTEST_ADD(UriSuite::testFreeCrash_Bug20080827)\n\t\tTEST_ADD(UriSuite::testParseInvalid_Bug16)\n\t\tTEST_ADD(UriSuite::testRangeComparison)\n\t\tTEST_ADD(UriSuite::testRangeComparison_RemoveBaseUri_Issue19)\n\t\tTEST_ADD(UriSuite::testEquals)\n\t\tTEST_ADD(UriSuite::testHostTextTermination_Issue15)\n\t}\n\nprivate:\n\tbool testDistinctionHelper(const char * uriText, bool expectedHostSet,\n\t\t\tbool expectedAbsPath, bool expectedEmptyTailSegment) {\n\t\tUriParserStateA state;\n\t\tUriUriA uri;\n\t\tstate.uri = &uri;\n\n\t\tint res = uriParseUriA(&state, uriText);\n\t\tif (res != URI_SUCCESS) {\n\t\t\turiFreeUriMembersA(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (expectedHostSet != (uri.hostText.first != NULL)) {\n\t\t\turiFreeUriMembersA(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (expectedAbsPath != (uri.absolutePath == URI_TRUE)) {\n\t\t\turiFreeUriMembersA(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (expectedEmptyTailSegment != ((uri.pathTail != NULL)\n\t\t\t\t&& (uri.pathTail->text.first == uri.pathTail->text.afterLast))) {\n\t\t\turiFreeUriMembersA(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\turiFreeUriMembersA(&uri);\n\t\treturn true;\n\t}\n\n\tvoid testDistinction() {\n\t\t/*\n============================================================================\nRule                                | Example | hostSet | absPath | emptySeg\n------------------------------------|---------|---------|---------|---------\n1) URI = scheme \":\" hier-part ...   |         |         |         |\n   1) \"//\" authority path-abempty   | \"s://\"  | true    |   false |   false\n                                    | \"s:///\" | true    |   false | true\n                                    | \"s://a\" | true    |   false |   false\n                                    | \"s://a/\"| true    |   false | true\n   2) path-absolute                 | \"s:/\"   |   false | true    |   false\n   3) path-rootless                 | \"s:a\"   |   false |   false |   false\n                                    | \"s:a/\"  |   false |   false | true\n   4) path-empty                    | \"s:\"    |   false |   false |   false\n------------------------------------|---------|---------|---------|---------\n2) relative-ref = relative-part ... |         |         |         |\n   1) \"//\" authority path-abempty   | \"//\"    | true    |   false |   false\n                                    | \"///\"   | true    |   false | true\n   2) path-absolute                 | \"/\"     |   false | true    |   false\n   3) path-noscheme                 | \"a\"     |   false |   false |   false\n                                    | \"a/\"    |   false |   false | true\n   4) path-empty                    | \"\"      |   false |   false |   false\n============================================================================\n\t\t*/\n\t\tTEST_ASSERT(testDistinctionHelper(\"s://\", true, false, false));\n\t\tTEST_ASSERT(testDistinctionHelper(\"s:///\", true, false, true));\n\t\tTEST_ASSERT(testDistinctionHelper(\"s://a\", true, false, false));\n\t\tTEST_ASSERT(testDistinctionHelper(\"s://a/\", true, false, true));\n\t\tTEST_ASSERT(testDistinctionHelper(\"s:/\", false, true, false));\n\t\tTEST_ASSERT(testDistinctionHelper(\"s:a\", false, false, false));\n\t\tTEST_ASSERT(testDistinctionHelper(\"s:a/\", false, false, true));\n\t\tTEST_ASSERT(testDistinctionHelper(\"s:\", false, false, false));\n\n\t\tTEST_ASSERT(testDistinctionHelper(\"//\", true, false, false));\n\t\tTEST_ASSERT(testDistinctionHelper(\"///\", true, false, true));\n\t\tTEST_ASSERT(testDistinctionHelper(\"/\", false, true, false));\n\t\tTEST_ASSERT(testDistinctionHelper(\"a\", false, false, false));\n\t\tTEST_ASSERT(testDistinctionHelper(\"a/\", false, false, true));\n\t\tTEST_ASSERT(testDistinctionHelper(\"\", false, false, false));\n\t}\n\n\tvoid testIpFour() {\n\t\tURI_TEST_IP_FOUR_FAIL(\"01.0.0.0\");\n\t\tURI_TEST_IP_FOUR_FAIL(\"001.0.0.0\");\n\t\tURI_TEST_IP_FOUR_FAIL(\"00.0.0.0\");\n\t\tURI_TEST_IP_FOUR_FAIL(\"000.0.0.0\");\n\t\tURI_TEST_IP_FOUR_FAIL(\"256.0.0.0\");\n\t\tURI_TEST_IP_FOUR_FAIL(\"300.0.0.0\");\n\t\tURI_TEST_IP_FOUR_FAIL(\"1111.0.0.0\");\n\t\tURI_TEST_IP_FOUR_FAIL(\"-1.0.0.0\");\n\t\tURI_TEST_IP_FOUR_FAIL(\"0.0.0\");\n\t\tURI_TEST_IP_FOUR_FAIL(\"0.0.0.\");\n\t\tURI_TEST_IP_FOUR_FAIL(\"0.0.0.0.\");\n\t\tURI_TEST_IP_FOUR_FAIL(\"0.0.0.0.0\");\n\t\tURI_TEST_IP_FOUR_FAIL(\"0.0..0\");\n\t\tURI_TEST_IP_FOUR_FAIL(\".0.0.0\");\n\n\t\tURI_TEST_IP_FOUR_PASS(\"255.0.0.0\");\n\t\tURI_TEST_IP_FOUR_PASS(\"0.0.0.0\");\n\t\tURI_TEST_IP_FOUR_PASS(\"1.0.0.0\");\n\t\tURI_TEST_IP_FOUR_PASS(\"2.0.0.0\");\n\t\tURI_TEST_IP_FOUR_PASS(\"3.0.0.0\");\n\t\tURI_TEST_IP_FOUR_PASS(\"30.0.0.0\");\n\t}\n\n\tvoid testIpSixPass() {\n\t\t// Quad length\n\t\tURI_TEST_IP_SIX_PASS(\"abcd::\");\n\n\t\tURI_TEST_IP_SIX_PASS(\"abcd::1\");\n\t\tURI_TEST_IP_SIX_PASS(\"abcd::12\");\n\t\tURI_TEST_IP_SIX_PASS(\"abcd::123\");\n\t\tURI_TEST_IP_SIX_PASS(\"abcd::1234\");\n\n\t\t// Full length\n\t\tURI_TEST_IP_SIX_PASS(\"2001:0db8:0100:f101:0210:a4ff:fee3:9566\"); // lower hex\n\t\tURI_TEST_IP_SIX_PASS(\"2001:0DB8:0100:F101:0210:A4FF:FEE3:9566\"); // Upper hex\n\t\tURI_TEST_IP_SIX_PASS(\"2001:db8:100:f101:210:a4ff:fee3:9566\");\n\t\tURI_TEST_IP_SIX_PASS(\"2001:0db8:100:f101:0:0:0:1\");\n\t\tURI_TEST_IP_SIX_PASS(\"1:2:3:4:5:6:255.255.255.255\");\n\n\t\t// Legal IPv4\n\t\tURI_TEST_IP_SIX_PASS(\"::1.2.3.4\");\n\t\tURI_TEST_IP_SIX_PASS(\"3:4::5:1.2.3.4\");\n\t\tURI_TEST_IP_SIX_PASS(\"::ffff:1.2.3.4\");\n\t\tURI_TEST_IP_SIX_PASS(\"::0.0.0.0\"); // Min IPv4\n\t\tURI_TEST_IP_SIX_PASS(\"::255.255.255.255\"); // Max IPv4\n\n\t\t// Zipper position\n\t\tURI_TEST_IP_SIX_PASS(\"::1:2:3:4:5:6:7\");\n\t\tURI_TEST_IP_SIX_PASS(\"1::1:2:3:4:5:6\");\n\t\tURI_TEST_IP_SIX_PASS(\"1:2::1:2:3:4:5\");\n\t\tURI_TEST_IP_SIX_PASS(\"1:2:3::1:2:3:4\");\n\t\tURI_TEST_IP_SIX_PASS(\"1:2:3:4::1:2:3\");\n\t\tURI_TEST_IP_SIX_PASS(\"1:2:3:4:5::1:2\");\n\t\tURI_TEST_IP_SIX_PASS(\"1:2:3:4:5:6::1\");\n\t\tURI_TEST_IP_SIX_PASS(\"1:2:3:4:5:6:7::\");\n\n\t\t// Zipper length\n\t\tURI_TEST_IP_SIX_PASS(\"1:1:1::1:1:1:1\");\n\t\tURI_TEST_IP_SIX_PASS(\"1:1:1::1:1:1\");\n\t\tURI_TEST_IP_SIX_PASS(\"1:1:1::1:1\");\n\t\tURI_TEST_IP_SIX_PASS(\"1:1::1:1\");\n\t\tURI_TEST_IP_SIX_PASS(\"1:1::1\");\n\t\tURI_TEST_IP_SIX_PASS(\"1::1\");\n\t\tURI_TEST_IP_SIX_PASS(\"::1\"); // == localhost\n\t\tURI_TEST_IP_SIX_PASS(\"::\"); // == all addresses\n\n\t\t// A few more variations\n\t\tURI_TEST_IP_SIX_PASS(\"21ff:abcd::1\");\n\t\tURI_TEST_IP_SIX_PASS(\"2001:db8:100:f101::1\");\n\t\tURI_TEST_IP_SIX_PASS(\"a:b:c::12:1\");\n\t\tURI_TEST_IP_SIX_PASS(\"a:b::0:1:2:3\");\n\t}\n\n\tvoid testIpSixFail() {\n\t\t// 5 char quad\n\t\tURI_TEST_IP_SIX_FAIL(\"::12345\");\n\n\t\t// Two zippers\n\t\tURI_TEST_IP_SIX_FAIL(\"abcd::abcd::abcd\");\n\n\t\t// Triple-colon zipper\n\t\tURI_TEST_IP_SIX_FAIL(\":::1234\");\n\t\tURI_TEST_IP_SIX_FAIL(\"1234:::1234:1234\");\n\t\tURI_TEST_IP_SIX_FAIL(\"1234:1234:::1234\");\n\t\tURI_TEST_IP_SIX_FAIL(\"1234:::\");\n\n\t\t// No quads, just IPv4\n\t\tURI_TEST_IP_SIX_FAIL(\"1.2.3.4\");\n\t\tURI_TEST_IP_SIX_FAIL(\"0001.0002.0003.0004\");\n\n\t\t// Five quads\n\t\tURI_TEST_IP_SIX_FAIL(\"0000:0000:0000:0000:0000:1.2.3.4\");\n\n\t\t// Seven quads\n\t\tURI_TEST_IP_SIX_FAIL(\"0:0:0:0:0:0:0\");\n\t\tURI_TEST_IP_SIX_FAIL(\"0:0:0:0:0:0:0:\");\n\t\tURI_TEST_IP_SIX_FAIL(\"0:0:0:0:0:0:0:1.2.3.4\");\n\n\t\t// Nine quads (or more)\n\t\tURI_TEST_IP_SIX_FAIL(\"1:2:3:4:5:6:7:8:9\");\n\t\tURI_TEST_IP_SIX_FAIL(\"::2:3:4:5:6:7:8:9\");\n\t\tURI_TEST_IP_SIX_FAIL(\"1:2:3:4::6:7:8:9\");\n\t\tURI_TEST_IP_SIX_FAIL(\"1:2:3:4:5:6:7:8::\");\n\n\t\t// Invalid IPv4 part\n\t\tURI_TEST_IP_SIX_FAIL(\"::ffff:001.02.03.004\"); // Leading zeros\n\t\tURI_TEST_IP_SIX_FAIL(\"::ffff:1.2.3.1111\"); // Four char octet\n\t\tURI_TEST_IP_SIX_FAIL(\"::ffff:1.2.3.256\"); // > 255\n\t\tURI_TEST_IP_SIX_FAIL(\"::ffff:311.2.3.4\"); // > 155\n\t\tURI_TEST_IP_SIX_FAIL(\"::ffff:1.2.3:4\"); // Not a dot\n\t\tURI_TEST_IP_SIX_FAIL(\"::ffff:1.2.3\"); // Missing octet\n\t\tURI_TEST_IP_SIX_FAIL(\"::ffff:1.2.3.\"); // Missing octet\n\t\tURI_TEST_IP_SIX_FAIL(\"::ffff:1.2.3a.4\"); // Hex in octet\n\t\tURI_TEST_IP_SIX_FAIL(\"::ffff:1.2.3.4:123\"); // Crap input\n\n\t\t// Nonhex\n\t\tURI_TEST_IP_SIX_FAIL(\"g:0:0:0:0:0:0\");\n\t}\n\n\tvoid testUri() {\n\t\tUriParserStateA stateA;\n\t\tUriParserStateW stateW;\n\t\tUriUriA uriA;\n\t\tUriUriW uriW;\n\n\t\tstateA.uri = &uriA;\n\t\tstateW.uri = &uriW;\n\n\t\t// On/off for each\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, \"//user:pass@[::1]:80/segment/index.html?query#frag\"));\n\t\turiFreeUriMembersA(&uriA);\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, \"http://[::1]:80/segment/index.html?query#frag\"));\n\t\turiFreeUriMembersA(&uriA);\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, \"http://user:pass@[::1]/segment/index.html?query#frag\"));\n\t\turiFreeUriMembersA(&uriA);\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, \"http://user:pass@[::1]:80?query#frag\"));\n\t\turiFreeUriMembersA(&uriA);\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, \"http://user:pass@[::1]:80/segment/index.html#frag\"));\n\t\turiFreeUriMembersA(&uriA);\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, \"http://user:pass@[::1]:80/segment/index.html?query\"));\n\t\turiFreeUriMembersA(&uriA);\n\n\t\t// Schema, port, one segment\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, \"ftp://host:21/gnu/\"));\n\t\turiFreeUriMembersA(&uriA);\n\n\t\t// Relative\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, \"one/two/three\"));\n\t\tTEST_ASSERT(!uriA.absolutePath);\n\t\turiFreeUriMembersA(&uriA);\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, \"/one/two/three\"));\n\t\tTEST_ASSERT(uriA.absolutePath);\n\t\turiFreeUriMembersA(&uriA);\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, \"//user:pass@localhost/one/two/three\"));\n\t\turiFreeUriMembersA(&uriA);\n\n\t\t// ANSI and Unicode\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, \"http://www.example.com/\"));\n\t\turiFreeUriMembersA(&uriA);\n\t\tTEST_ASSERT(0 == uriParseUriW(&stateW, L\"http://www.example.com/\"));\n\t\turiFreeUriMembersW(&uriW);\n\n\t\t// Real life examples\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, \"http://sourceforge.net/projects/uriparser/\"));\n\t\turiFreeUriMembersA(&uriA);\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, \"http://sourceforge.net/project/platformdownload.php?group_id=182840\"));\n\t\turiFreeUriMembersA(&uriA);\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, \"mailto:test@example.com\"));\n\t\turiFreeUriMembersA(&uriA);\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, \"../../\"));\n\t\turiFreeUriMembersA(&uriA);\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, \"/\"));\n\t\tTEST_ASSERT(uriA.absolutePath)\n\t\turiFreeUriMembersA(&uriA);\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, \"\"));\n\t\tTEST_ASSERT(!uriA.absolutePath)\n\t\turiFreeUriMembersA(&uriA);\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, \"file:///bin/bash\"));\n\t\turiFreeUriMembersA(&uriA);\n\n\t\t// Percent encoding\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, \"http://www.example.com/name%20with%20spaces/\"));\n\t\turiFreeUriMembersA(&uriA);\n\t\tTEST_ASSERT(0 != uriParseUriA(&stateA, \"http://www.example.com/name with spaces/\"));\n\t\turiFreeUriMembersA(&uriA);\n\t}\n\n\tvoid testUriComponents() {\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  0              15 01  0      7  01\n\t\tconst char * const input = \"http\" \"://\" \"sourceforge.net\" \"/\" \"project\" \"/\"\n\t\t//\t\t 0                   20 01  0              15\n\t\t\t\t\"platformdownload.php\" \"?\" \"group_id=182840\";\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, input));\n\n\t\tTEST_ASSERT(uriA.scheme.first == input);\n\t\tTEST_ASSERT(uriA.scheme.afterLast == input + 4);\n\t\tTEST_ASSERT(uriA.userInfo.first == NULL);\n\t\tTEST_ASSERT(uriA.userInfo.afterLast == NULL);\n\t\tTEST_ASSERT(uriA.hostText.first == input + 4 + 3);\n\t\tTEST_ASSERT(uriA.hostText.afterLast == input + 4 + 3 + 15);\n\t\tTEST_ASSERT(uriA.hostData.ipFuture.first == NULL);\n\t\tTEST_ASSERT(uriA.hostData.ipFuture.afterLast == NULL);\n\t\tTEST_ASSERT(uriA.portText.first == NULL);\n\t\tTEST_ASSERT(uriA.portText.afterLast == NULL);\n\n\t\tTEST_ASSERT(uriA.pathHead->text.first == input + 4 + 3 + 15 + 1);\n\t\tTEST_ASSERT(uriA.pathHead->text.afterLast == input + 4 + 3 + 15 + 1 + 7);\n\t\tTEST_ASSERT(uriA.pathHead->next->text.first == input + 4 + 3 + 15 + 1 + 7 + 1);\n\t\tTEST_ASSERT(uriA.pathHead->next->text.afterLast == input + 4 + 3 + 15 + 1 + 7 + 1 + 20);\n\t\tTEST_ASSERT(uriA.pathHead->next->next == NULL);\n\t\tTEST_ASSERT(uriA.pathTail == uriA.pathHead->next);\n\n\t\tTEST_ASSERT(uriA.query.first == input + 4 + 3 + 15 + 1 + 7 + 1 + 20 + 1);\n\t\tTEST_ASSERT(uriA.query.afterLast == input + 4 + 3 + 15 + 1 + 7 + 1 + 20 + 1 + 15);\n\t\tTEST_ASSERT(uriA.fragment.first == NULL);\n\t\tTEST_ASSERT(uriA.fragment.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n\t}\n\n\tvoid testUriComponents_Bug20070701() {\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          01  01  01\n\t\tconst char * const input = \"a\" \":\" \"b\";\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, input));\n\n\t\tTEST_ASSERT(uriA.scheme.first == input);\n\t\tTEST_ASSERT(uriA.scheme.afterLast == input + 1);\n\t\tTEST_ASSERT(uriA.userInfo.first == NULL);\n\t\tTEST_ASSERT(uriA.userInfo.afterLast == NULL);\n\t\tTEST_ASSERT(uriA.hostText.first == NULL);\n\t\tTEST_ASSERT(uriA.hostText.afterLast == NULL);\n\t\tTEST_ASSERT(uriA.hostData.ipFuture.first == NULL);\n\t\tTEST_ASSERT(uriA.hostData.ipFuture.afterLast == NULL);\n\t\tTEST_ASSERT(uriA.portText.first == NULL);\n\t\tTEST_ASSERT(uriA.portText.afterLast == NULL);\n\n\t\tTEST_ASSERT(uriA.pathHead->text.first == input + 1 + 1);\n\t\tTEST_ASSERT(uriA.pathHead->text.afterLast == input + 1 + 1 + 1);\n\t\tTEST_ASSERT(uriA.pathHead->next == NULL);\n\t\tTEST_ASSERT(uriA.pathTail == uriA.pathHead);\n\n\t\tTEST_ASSERT(uriA.query.first == NULL);\n\t\tTEST_ASSERT(uriA.query.afterLast == NULL);\n\t\tTEST_ASSERT(uriA.fragment.first == NULL);\n\t\tTEST_ASSERT(uriA.fragment.afterLast == NULL);\n\n\t\tTEST_ASSERT(!uriA.absolutePath);\n\t\turiFreeUriMembersA(&uriA);\n\t}\n\n\tvoid testUriUserInfoHostPort1() {\n\t\t// User info with \":\", no port\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  0      7  01  0        9\n\t\tconst char * const input = \"http\" \"://\" \"abc:def\" \"@\" \"localhost\";\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, input));\n\n\t\tTEST_ASSERT(uriA.userInfo.first == input + 4 + 3);\n\t\tTEST_ASSERT(uriA.userInfo.afterLast == input + 4 + 3 + 7);\n\t\tTEST_ASSERT(uriA.hostText.first == input + 4 + 3 + 7 + 1);\n\t\tTEST_ASSERT(uriA.hostText.afterLast == input + 4 + 3 + 7 + 1 + 9);\n\t\tTEST_ASSERT(uriA.portText.first == NULL);\n\t\tTEST_ASSERT(uriA.portText.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n\t}\n\n\tvoid testUriUserInfoHostPort2() {\n\t\t// User info with \":\", with port\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  0      7  01  0        9\n\t\tconst char * const input = \"http\" \"://\" \"abc:def\" \"@\" \"localhost\"\n\t\t//\t\t01   0  3\n\t\t\t\t\":\" \"123\";\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, input));\n\n\t\tTEST_ASSERT(uriA.userInfo.first == input + 4 + 3);\n\t\tTEST_ASSERT(uriA.userInfo.afterLast == input + 4 + 3 + 7);\n\t\tTEST_ASSERT(uriA.hostText.first == input + 4 + 3 + 7 + 1);\n\t\tTEST_ASSERT(uriA.hostText.afterLast == input + 4 + 3 + 7 + 1 + 9);\n\t\tTEST_ASSERT(uriA.portText.first == input + 4 + 3 + 7 + 1 + 9 + 1);\n\t\tTEST_ASSERT(uriA.portText.afterLast == input + 4 + 3 + 7 + 1 + 9 + 1 + 3);\n\t\turiFreeUriMembersA(&uriA);\n\t}\n\n\tvoid testUriUserInfoHostPort22_Bug1948038() {\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\n\t\tint res;\n\n\t\tres = uriParseUriA(&stateA, \"http://user:21@host/\");\n\t\tTEST_ASSERT(URI_SUCCESS == res);\n\t\tTEST_ASSERT(!memcmp(uriA.userInfo.first, \"user:21\", 7 * sizeof(char)));\n\t\tTEST_ASSERT(uriA.userInfo.afterLast - uriA.userInfo.first == 7);\n\t\tTEST_ASSERT(!memcmp(uriA.hostText.first, \"host\", 4 * sizeof(char)));\n\t\tTEST_ASSERT(uriA.hostText.afterLast - uriA.hostText.first == 4);\n\t\tTEST_ASSERT(uriA.portText.first == NULL);\n\t\tTEST_ASSERT(uriA.portText.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n\n\t\tres = uriParseUriA(&stateA, \"http://user:1234@192.168.0.1:1234/foo.com\");\n\t\tTEST_ASSERT(URI_SUCCESS == res);\n\t\turiFreeUriMembersA(&uriA);\n\n\t\tres = uriParseUriA(&stateA, \"http://moo:21@moo:21@moo/\");\n\t\tTEST_ASSERT(URI_ERROR_SYNTAX == res);\n\t\turiFreeUriMembersA(&uriA);\n\n\t\tres = uriParseUriA(&stateA, \"http://moo:21@moo:21@moo:21/\");\n\t\tTEST_ASSERT(URI_ERROR_SYNTAX == res);\n\t\turiFreeUriMembersA(&uriA);\n\t}\n\n\tvoid testUriUserInfoHostPort23_Bug3510198_1() {\n\t\t// User info with \":\", with port, with escaped chars in password\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\n\t\tint res;\n\t\t//                           0   4  0  3  0         10 01  0   4  01\n\t\tres = uriParseUriA(&stateA, \"http\" \"://\" \"user:%2F21\" \"@\" \"host\" \"/\");\n\t\tTEST_ASSERT(URI_SUCCESS == res);\n\t\tTEST_ASSERT(!memcmp(uriA.userInfo.first, \"user:%2F21\", 10 * sizeof(char)));\n\t\tTEST_ASSERT(uriA.userInfo.afterLast - uriA.userInfo.first == 10);\n\t\tTEST_ASSERT(!memcmp(uriA.hostText.first, \"host\", 4 * sizeof(char)));\n\t\tTEST_ASSERT(uriA.hostText.afterLast - uriA.hostText.first == 4);\n\t\tTEST_ASSERT(uriA.portText.first == NULL);\n\t\tTEST_ASSERT(uriA.portText.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n\n\t}\n\n\tvoid testUriUserInfoHostPort23_Bug3510198_2() {\n\t\t// User info with \":\", with port, with escaped chars in user name and password\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\n\t\tint res;\n\t\t//                           0   4  0  3  0            13 01  0   4  01\n\t\tres = uriParseUriA(&stateA, \"http\" \"://\" \"%2Fuser:%2F21\" \"@\" \"host\" \"/\");\n\t\tTEST_ASSERT(URI_SUCCESS == res);\n\t\tTEST_ASSERT(!memcmp(uriA.userInfo.first, \"%2Fuser:%2F21\", 13 * sizeof(char)));\n\t\tTEST_ASSERT(uriA.userInfo.afterLast - uriA.userInfo.first == 13);\n\t\tTEST_ASSERT(!memcmp(uriA.hostText.first, \"host\", 4 * sizeof(char)));\n\t\tTEST_ASSERT(uriA.hostText.afterLast - uriA.hostText.first == 4);\n\t\tTEST_ASSERT(uriA.portText.first == NULL);\n\t\tTEST_ASSERT(uriA.portText.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n\t}\n\n\tvoid testUriUserInfoHostPort23_Bug3510198_3() {\n\t\t// User info with \":\", with port, with escaped chars in password\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\n\t\tint res;\n\t\t//                           0   4  0  3  0               16 01  0   4  01\n\t\tres = uriParseUriA(&stateA, \"http\" \"://\" \"user:!$&'()*+,;=\" \"@\" \"host\" \"/\");\n\t\tTEST_ASSERT(URI_SUCCESS == res);\n\t\tTEST_ASSERT(!memcmp(uriA.userInfo.first, \"user:!$&'()*+,;=\", 16 * sizeof(char)));\n\t\tTEST_ASSERT(uriA.userInfo.afterLast - uriA.userInfo.first == 16);\n\t\tTEST_ASSERT(!memcmp(uriA.hostText.first, \"host\", 4 * sizeof(char)));\n\t\tTEST_ASSERT(uriA.hostText.afterLast - uriA.hostText.first == 4);\n\t\tTEST_ASSERT(uriA.portText.first == NULL);\n\t\tTEST_ASSERT(uriA.portText.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n\n\t}\n\n\tvoid testUriUserInfoHostPort23_Bug3510198_4() {\n\t\t// User info with \":\", with port, with escaped chars in user name and password\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\n\t\tint res;\n\t\t//                           0   4  0  3  0                   20 01  0   4  01\n\t\tres = uriParseUriA(&stateA, \"http\" \"://\" \"!$&'()*+,;=:password\" \"@\" \"host\" \"/\");\n\t\tTEST_ASSERT(URI_SUCCESS == res);\n\t\tTEST_ASSERT(!memcmp(uriA.userInfo.first, \"!$&'()*+,;=:password\", 20 * sizeof(char)));\n\t\tTEST_ASSERT(uriA.userInfo.afterLast - uriA.userInfo.first == 20);\n\t\tTEST_ASSERT(!memcmp(uriA.hostText.first, \"host\", 4 * sizeof(char)));\n\t\tTEST_ASSERT(uriA.hostText.afterLast - uriA.hostText.first == 4);\n\t\tTEST_ASSERT(uriA.portText.first == NULL);\n\t\tTEST_ASSERT(uriA.portText.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n\t}\n\n\tvoid testUriUserInfoHostPort23_Bug3510198_related_1() {\n\t\t// Empty user info\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\n\t\tint res;\n\t\t//                           0   4  0  3  01  0   4  01\n\t\tres = uriParseUriA(&stateA, \"http\" \"://\" \"@\" \"host\" \"/\");\n\t\tTEST_ASSERT(URI_SUCCESS == res);\n\t\tTEST_ASSERT(uriA.userInfo.afterLast != NULL);\n\t\tTEST_ASSERT(uriA.userInfo.first != NULL);\n\t\tTEST_ASSERT(uriA.userInfo.afterLast - uriA.userInfo.first == 0);\n\t\tTEST_ASSERT(!memcmp(uriA.hostText.first, \"host\", 4 * sizeof(char)));\n\t\tTEST_ASSERT(uriA.hostText.afterLast - uriA.hostText.first == 4);\n\t\tTEST_ASSERT(uriA.portText.first == NULL);\n\t\tTEST_ASSERT(uriA.portText.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n\t}\n\n\tvoid testUriUserInfoHostPort23_Bug3510198_related_12() {\n\t\t// Empty user info\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\n\t\tint res;\n\t\t//                           0   4  0  3  0      7  01\n\t\tres = uriParseUriA(&stateA, \"http\" \"://\" \"%2Fhost\" \"/\");\n\t\tTEST_ASSERT(URI_SUCCESS == res);\n\t\tTEST_ASSERT(uriA.userInfo.afterLast == NULL);\n\t\tTEST_ASSERT(uriA.userInfo.first == NULL);\n\t\tTEST_ASSERT(!memcmp(uriA.hostText.first, \"%2Fhost\", 7 * sizeof(char)));\n\t\tTEST_ASSERT(uriA.hostText.afterLast - uriA.hostText.first == 7);\n\t\tTEST_ASSERT(uriA.portText.first == NULL);\n\t\tTEST_ASSERT(uriA.portText.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n\t}\n\n\tvoid testUriUserInfoHostPort23_Bug3510198_related_2() {\n\t\t// Several colons in userinfo\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\n\t\tint res;\n\t\t//                           0   4  0  3  0 2  01  0   4  01\n\t\tres = uriParseUriA(&stateA, \"http\" \"://\" \"::\" \"@\" \"host\" \"/\");\n\t\tTEST_ASSERT(URI_SUCCESS == res);\n\t\tTEST_ASSERT(!memcmp(uriA.userInfo.first, \"::\", 2 * sizeof(char)));\n\t\tTEST_ASSERT(uriA.userInfo.afterLast - uriA.userInfo.first == 2);\n\t\tTEST_ASSERT(!memcmp(uriA.hostText.first, \"host\", 4 * sizeof(char)));\n\t\tTEST_ASSERT(uriA.hostText.afterLast - uriA.hostText.first == 4);\n\t\tTEST_ASSERT(uriA.portText.first == NULL);\n\t\tTEST_ASSERT(uriA.portText.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n\t}\n\n\tvoid testUriUserInfoHostPort3() {\n\t\t// User info without \":\", no port\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  0      7  01  0        9\n\t\tconst char * const input = \"http\" \"://\" \"abcdefg\" \"@\" \"localhost\";\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, input));\n\n\t\tTEST_ASSERT(uriA.userInfo.first == input + 4 + 3);\n\t\tTEST_ASSERT(uriA.userInfo.afterLast == input + 4 + 3 + 7);\n\t\tTEST_ASSERT(uriA.hostText.first == input + 4 + 3 + 7 + 1);\n\t\tTEST_ASSERT(uriA.hostText.afterLast == input + 4 + 3 + 7 + 1 + 9);\n\t\tTEST_ASSERT(uriA.portText.first == NULL);\n\t\tTEST_ASSERT(uriA.portText.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n\t}\n\n\tvoid testUriUserInfoHostPort4() {\n\t\t// User info without \":\", with port\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  0      7  01  0        9\n\t\tconst char * const input = \"http\" \"://\" \"abcdefg\" \"@\" \"localhost\"\n\t\t//\t\t01   0  3\n\t\t\t\t\":\" \"123\";\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, input));\n\n\t\tTEST_ASSERT(uriA.userInfo.first == input + 4 + 3);\n\t\tTEST_ASSERT(uriA.userInfo.afterLast == input + 4 + 3 + 7);\n\t\tTEST_ASSERT(uriA.hostText.first == input + 4 + 3 + 7 + 1);\n\t\tTEST_ASSERT(uriA.hostText.afterLast == input + 4 + 3 + 7 + 1 + 9);\n\t\tTEST_ASSERT(uriA.portText.first == input + 4 + 3 + 7 + 1 + 9 + 1);\n\t\tTEST_ASSERT(uriA.portText.afterLast == input + 4 + 3 + 7 + 1 + 9 + 1 + 3);\n\t\turiFreeUriMembersA(&uriA);\n\t}\n\n\tvoid testUriUserInfoHostPort5() {\n\t\t// No user info, no port\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  0        9\n\t\tconst char * const input = \"http\" \"://\" \"localhost\";\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, input));\n\n\t\tTEST_ASSERT(uriA.userInfo.first == NULL);\n\t\tTEST_ASSERT(uriA.userInfo.afterLast == NULL);\n\t\tTEST_ASSERT(uriA.hostText.first == input + 4 + 3);\n\t\tTEST_ASSERT(uriA.hostText.afterLast == input + 4 + 3 + 9);\n\t\tTEST_ASSERT(uriA.portText.first == NULL);\n\t\tTEST_ASSERT(uriA.portText.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n\t}\n\n\tvoid testUriUserInfoHostPort6() {\n\t\t// No user info, with port\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  0        9  01  0  3\n\t\tconst char * const input = \"http\" \"://\" \"localhost\" \":\" \"123\";\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, input));\n\n\t\tTEST_ASSERT(uriA.userInfo.first == NULL);\n\t\tTEST_ASSERT(uriA.userInfo.afterLast == NULL);\n\t\tTEST_ASSERT(uriA.hostText.first == input + 4 + 3);\n\t\tTEST_ASSERT(uriA.hostText.afterLast == input + 4 + 3 + 9);\n\t\tTEST_ASSERT(uriA.portText.first == input + 4 + 3 + 9 + 1);\n\t\tTEST_ASSERT(uriA.portText.afterLast == input + 4 + 3 + 9 + 1 + 3);\n\t\turiFreeUriMembersA(&uriA);\n\t}\n\n\tvoid testUriHostRegname() {\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  0          11\n\t\tconst char * const input = \"http\" \"://\" \"example.com\";\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, input));\n\n\t\tTEST_ASSERT(uriA.hostText.first == input + 4 + 3);\n\t\tTEST_ASSERT(uriA.hostText.afterLast == input + 4 + 3 + 11);\n\t\tTEST_ASSERT(uriA.hostData.ip4 == NULL);\n\t\tTEST_ASSERT(uriA.hostData.ip6 == NULL);\n\t\tTEST_ASSERT(uriA.hostData.ipFuture.first == NULL);\n\t\tTEST_ASSERT(uriA.hostData.ipFuture.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n\t}\n\n\tvoid testUriHostIpFour1() {\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  0      7  01  0 2\n\t\tconst char * const input = \"http\" \"://\" \"1.2.3.4\" \":\" \"80\";\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, input));\n\n\t\tTEST_ASSERT(uriA.hostText.first == input + 4 + 3);\n\t\tTEST_ASSERT(uriA.hostText.afterLast == input + 4 + 3 + 7);\n\t\tTEST_ASSERT(uriA.hostData.ip4 != NULL);\n\t\tTEST_ASSERT(uriA.hostData.ip6 == NULL);\n\t\tTEST_ASSERT(uriA.hostData.ipFuture.first == NULL);\n\t\tTEST_ASSERT(uriA.hostData.ipFuture.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n\t}\n\n\tvoid testUriHostIpFour2() {\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  0      7\n\t\tconst char * const input = \"http\" \"://\" \"1.2.3.4\";\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, input));\n\n\t\tTEST_ASSERT(uriA.hostText.first == input + 4 + 3);\n\t\tTEST_ASSERT(uriA.hostText.afterLast == input + 4 + 3 + 7);\n\t\tTEST_ASSERT(uriA.hostData.ip4 != NULL);\n\t\tTEST_ASSERT(uriA.hostData.ip6 == NULL);\n\t\tTEST_ASSERT(uriA.hostData.ipFuture.first == NULL);\n\t\tTEST_ASSERT(uriA.hostData.ipFuture.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n\t}\n\n\tvoid testUriHostIpSix1() {\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  01  45  01  0 2\n\t\tconst char * const input = \"http\" \"://\" \"[::1]\" \":\" \"80\";\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, input));\n\n\t\tTEST_ASSERT(uriA.hostText.first == input + 4 + 3 + 1);\n\t\tTEST_ASSERT(uriA.hostText.afterLast == input + 4 + 3 + 4);\n\t\tTEST_ASSERT(uriA.hostData.ip4 == NULL);\n\t\tTEST_ASSERT(uriA.hostData.ip6 != NULL);\n\t\tTEST_ASSERT(uriA.hostData.ipFuture.first == NULL);\n\t\tTEST_ASSERT(uriA.hostData.ipFuture.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n\t}\n\n\tvoid testUriHostIpSix2() {\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  01  45\n\t\tconst char * const input = \"http\" \"://\" \"[::1]\";\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, input));\n\n\t\tTEST_ASSERT(uriA.hostText.first == input + 4 + 3 + 1);\n\t\tTEST_ASSERT(uriA.hostText.afterLast == input + 4 + 3 + 4);\n\t\tTEST_ASSERT(uriA.hostData.ip4 == NULL);\n\t\tTEST_ASSERT(uriA.hostData.ip6 != NULL);\n\t\tTEST_ASSERT(uriA.hostData.ipFuture.first == NULL);\n\t\tTEST_ASSERT(uriA.hostData.ipFuture.afterLast == NULL);\n\t\turiFreeUriMembersA(&uriA);\n\t}\n\n\tvoid testUriHostEmpty() {\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0   4  0  3  01  0  3\n\t\tconst char * const input = \"http\" \"://\" \":\" \"123\";\n\t\tconst int res = uriParseUriA(&stateA, input);\n\t\tTEST_ASSERT(URI_SUCCESS == res);\n\t\tTEST_ASSERT(uriA.userInfo.first == NULL);\n\t\tTEST_ASSERT(uriA.userInfo.afterLast == NULL);\n\t\tTEST_ASSERT(uriA.hostText.first != NULL);\n\t\tTEST_ASSERT(uriA.hostText.afterLast != NULL);\n\t\tTEST_ASSERT(uriA.hostText.afterLast - uriA.hostText.first == 0);\n\t\tTEST_ASSERT(uriA.portText.first == input + 4 + 3 + 1);\n\t\tTEST_ASSERT(uriA.portText.afterLast == input + 4 + 3 + 1 + 3);\n\t\turiFreeUriMembersA(&uriA);\n\t}\n\n\tvoid testUriHostIpFuture() {\n\t\t// TODO\n\t}\n\n\tbool testEscapingHelper(const wchar_t * in, const wchar_t * expectedOut,\n\t\t\tbool spaceToPlus = false, bool normalizeBreaks = false) {\n\t\twchar_t * const buffer = new wchar_t[(normalizeBreaks ? 6 : 3)\n\t\t\t\t* wcslen(in) + 1];\n\t\tif (uriEscapeW(in, buffer, spaceToPlus, normalizeBreaks)\n\t\t\t!= buffer + wcslen(expectedOut)) {\n\t\t\tdelete [] buffer;\n\t\t\treturn false;\n\t\t}\n\n\t\tconst bool equal = !wcscmp(buffer, expectedOut);\n\t\tdelete [] buffer;\n\t\treturn equal;\n\t}\n\n\tvoid testEscaping() {\n\t\tconst bool SPACE_TO_PLUS = true;\n\t\tconst bool SPACE_TO_PERCENT = false;\n\t\tconst bool KEEP_UNMODIFIED = false;\n\t\tconst bool NORMALIZE = true;\n\n\t\t// '+' to ' '\n\t\tTEST_ASSERT(testEscapingHelper(L\"abc def\", L\"abc+def\", SPACE_TO_PLUS));\n\t\tTEST_ASSERT(testEscapingHelper(L\"abc def\", L\"abc%20def\", SPACE_TO_PERCENT));\n\n\t\t// Percent encoding\n\t\tTEST_ASSERT(testEscapingHelper(L\"\\x00\", L\"\\0\"));\n\t\tTEST_ASSERT(testEscapingHelper(L\"\\x01\", L\"%01\"));\n\t\tTEST_ASSERT(testEscapingHelper(L\"\\xff\", L\"%FF\"));\n\n\t\t// Linebreak normalization\n\t\tTEST_ASSERT(testEscapingHelper(L\"\\x0d\", L\"%0D%0A\", SPACE_TO_PLUS, NORMALIZE));\n\t\tTEST_ASSERT(testEscapingHelper(L\"g\\x0d\", L\"g%0D%0A\", SPACE_TO_PLUS, NORMALIZE));\n\t\tTEST_ASSERT(testEscapingHelper(L\"\\x0dg\", L\"%0D%0Ag\", SPACE_TO_PLUS, NORMALIZE));\n\t\tTEST_ASSERT(testEscapingHelper(L\"\\x0d\", L\"%0D\", SPACE_TO_PLUS, KEEP_UNMODIFIED));\n\t\tTEST_ASSERT(testEscapingHelper(L\"g\\x0d\", L\"g%0D\", SPACE_TO_PLUS, KEEP_UNMODIFIED));\n\t\tTEST_ASSERT(testEscapingHelper(L\"\\x0dg\", L\"%0Dg\", SPACE_TO_PLUS, KEEP_UNMODIFIED));\n\n\t\tTEST_ASSERT(testEscapingHelper(L\"\\x0a\", L\"%0D%0A\", SPACE_TO_PLUS, NORMALIZE));\n\t\tTEST_ASSERT(testEscapingHelper(L\"g\\x0a\", L\"g%0D%0A\", SPACE_TO_PLUS, NORMALIZE));\n\t\tTEST_ASSERT(testEscapingHelper(L\"\\x0ag\", L\"%0D%0Ag\", SPACE_TO_PLUS, NORMALIZE));\n\t\tTEST_ASSERT(testEscapingHelper(L\"\\x0a\", L\"%0A\", SPACE_TO_PLUS, KEEP_UNMODIFIED));\n\t\tTEST_ASSERT(testEscapingHelper(L\"g\\x0a\", L\"g%0A\", SPACE_TO_PLUS, KEEP_UNMODIFIED));\n\t\tTEST_ASSERT(testEscapingHelper(L\"\\x0ag\", L\"%0Ag\", SPACE_TO_PLUS, KEEP_UNMODIFIED));\n\n\t\tTEST_ASSERT(testEscapingHelper(L\"\\x0d\\x0a\", L\"%0D%0A\", SPACE_TO_PLUS, NORMALIZE));\n\t\tTEST_ASSERT(testEscapingHelper(L\"g\\x0d\\x0a\", L\"g%0D%0A\", SPACE_TO_PLUS, NORMALIZE));\n\t\tTEST_ASSERT(testEscapingHelper(L\"\\x0d\\x0ag\", L\"%0D%0Ag\", SPACE_TO_PLUS, NORMALIZE));\n\t\tTEST_ASSERT(testEscapingHelper(L\"\\x0d\\x0a\", L\"%0D%0A\", SPACE_TO_PLUS, KEEP_UNMODIFIED));\n\t\tTEST_ASSERT(testEscapingHelper(L\"g\\x0d\\x0a\", L\"g%0D%0A\", SPACE_TO_PLUS, KEEP_UNMODIFIED));\n\t\tTEST_ASSERT(testEscapingHelper(L\"\\x0d\\x0ag\", L\"%0D%0Ag\", SPACE_TO_PLUS, KEEP_UNMODIFIED));\n\n\t\tTEST_ASSERT(testEscapingHelper(L\"\\x0a\\x0d\", L\"%0D%0A%0D%0A\", SPACE_TO_PLUS, NORMALIZE));\n\t\tTEST_ASSERT(testEscapingHelper(L\"g\\x0a\\x0d\", L\"g%0D%0A%0D%0A\", SPACE_TO_PLUS, NORMALIZE));\n\t\tTEST_ASSERT(testEscapingHelper(L\"\\x0a\\x0dg\", L\"%0D%0A%0D%0Ag\", SPACE_TO_PLUS, NORMALIZE));\n\t\tTEST_ASSERT(testEscapingHelper(L\"\\x0a\\x0d\", L\"%0A%0D\", SPACE_TO_PLUS, KEEP_UNMODIFIED));\n\t\tTEST_ASSERT(testEscapingHelper(L\"g\\x0a\\x0d\", L\"g%0A%0D\", SPACE_TO_PLUS, KEEP_UNMODIFIED));\n\t\tTEST_ASSERT(testEscapingHelper(L\"\\x0a\\x0dg\", L\"%0A%0Dg\", SPACE_TO_PLUS, KEEP_UNMODIFIED));\n\t}\n\n\tbool testUnescapingHelper(const wchar_t * input, const wchar_t * output,\n\t\t\tbool plusToSpace = false, UriBreakConversion breakConversion = URI_BR_DONT_TOUCH) {\n\t\twchar_t * working = new wchar_t[URI_STRLEN(input) + 1];\n\t\twcscpy(working, input);\n\t\tconst wchar_t * newTermZero = uriUnescapeInPlaceExW(working,\n\t\t\t\tplusToSpace ? URI_TRUE : URI_FALSE, breakConversion);\n\t\tconst bool success = ((newTermZero == working + wcslen(output))\n\t\t\t\t&& !wcscmp(working, output));\n\t\tdelete[] working;\n\t\treturn success;\n\t}\n\n\tvoid testUnescaping() {\n\t\tconst bool PLUS_TO_SPACE = true;\n\t\tconst bool PLUS_DONT_TOUCH = false;\n\n\n\t\t// Proper\n\t\tTEST_ASSERT(testUnescapingHelper(L\"abc%20%41BC\", L\"abc ABC\"));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%20\", L\" \"));\n\n\t\t// Incomplete\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0\", L\"%0\"));\n\n\t\t// Nonhex\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0g\", L\"%0g\"));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%G0\", L\"%G0\"));\n\n\t\t// No double decoding\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%2520\", L\"%20\"));\n\n\t\t// Decoding of '+'\n\t\tTEST_ASSERT(testUnescapingHelper(L\"abc+def\", L\"abc+def\", PLUS_DONT_TOUCH));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"abc+def\", L\"abc def\", PLUS_TO_SPACE));\n\n\t\t// Line break conversion\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0d\", L\"\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_UNIX));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0d\", L\"\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_WINDOWS));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0d\", L\"\\x0d\", PLUS_DONT_TOUCH, URI_BR_TO_MAC));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0d\", L\"\\x0d\", PLUS_DONT_TOUCH, URI_BR_DONT_TOUCH));\n\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0d%0d\", L\"\\x0a\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_UNIX));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0d%0d\", L\"\\x0d\\x0a\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_WINDOWS));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0d%0d\", L\"\\x0d\\x0d\", PLUS_DONT_TOUCH, URI_BR_TO_MAC));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0d%0d\", L\"\\x0d\\x0d\", PLUS_DONT_TOUCH, URI_BR_DONT_TOUCH));\n\n\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0a\", L\"\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_UNIX));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0a\", L\"\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_WINDOWS));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0a\", L\"\\x0d\", PLUS_DONT_TOUCH, URI_BR_TO_MAC));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0a\", L\"\\x0a\", PLUS_DONT_TOUCH, URI_BR_DONT_TOUCH));\n\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0a%0a\", L\"\\x0a\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_UNIX));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0a%0a\", L\"\\x0d\\x0a\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_WINDOWS));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0a%0a\", L\"\\x0d\\x0d\", PLUS_DONT_TOUCH, URI_BR_TO_MAC));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0a%0a\", L\"\\x0a\\x0a\", PLUS_DONT_TOUCH, URI_BR_DONT_TOUCH));\n\n\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0d%0a\", L\"\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_UNIX));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0d%0a\", L\"\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_WINDOWS));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0d%0a\", L\"\\x0d\", PLUS_DONT_TOUCH, URI_BR_TO_MAC));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0d%0a\", L\"\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_DONT_TOUCH));\n\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0d%0a%0a\", L\"\\x0a\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_UNIX));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0d%0a%0a\", L\"\\x0d\\x0a\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_WINDOWS));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0d%0a%0a\", L\"\\x0d\\x0d\", PLUS_DONT_TOUCH, URI_BR_TO_MAC));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0d%0a%0a\", L\"\\x0d\\x0a\\x0a\", PLUS_DONT_TOUCH, URI_BR_DONT_TOUCH));\n\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0d%0a%0d\", L\"\\x0a\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_UNIX));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0d%0a%0d\", L\"\\x0d\\x0a\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_WINDOWS));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0d%0a%0d\", L\"\\x0d\\x0d\", PLUS_DONT_TOUCH, URI_BR_TO_MAC));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0d%0a%0d\", L\"\\x0d\\x0a\\x0d\", PLUS_DONT_TOUCH, URI_BR_DONT_TOUCH));\n\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0d%0a%0d%0a\", L\"\\x0a\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_UNIX));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0d%0a%0d%0a\", L\"\\x0d\\x0a\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_WINDOWS));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0d%0a%0d%0a\", L\"\\x0d\\x0d\", PLUS_DONT_TOUCH, URI_BR_TO_MAC));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0d%0a%0d%0a\", L\"\\x0d\\x0a\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_DONT_TOUCH));\n\n\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0a%0d\", L\"\\x0a\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_UNIX));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0a%0d\", L\"\\x0d\\x0a\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_WINDOWS));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0a%0d\", L\"\\x0d\\x0d\", PLUS_DONT_TOUCH, URI_BR_TO_MAC));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0a%0d\", L\"\\x0a\\x0d\", PLUS_DONT_TOUCH, URI_BR_DONT_TOUCH));\n\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0a%0d%0a\", L\"\\x0a\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_UNIX));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0a%0d%0a\", L\"\\x0d\\x0a\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_WINDOWS));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0a%0d%0a\", L\"\\x0d\\x0d\", PLUS_DONT_TOUCH, URI_BR_TO_MAC));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0a%0d%0a\", L\"\\x0a\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_DONT_TOUCH));\n\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0a%0d%0d\", L\"\\x0a\\x0a\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_UNIX));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0a%0d%0d\", L\"\\x0d\\x0a\\x0d\\x0a\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_WINDOWS));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0a%0d%0d\", L\"\\x0d\\x0d\\x0d\", PLUS_DONT_TOUCH, URI_BR_TO_MAC));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0a%0d%0d\", L\"\\x0a\\x0d\\x0d\", PLUS_DONT_TOUCH, URI_BR_DONT_TOUCH));\n\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0a%0d%0a%0d\", L\"\\x0a\\x0a\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_UNIX));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0a%0d%0a%0d\", L\"\\x0d\\x0a\\x0d\\x0a\\x0d\\x0a\", PLUS_DONT_TOUCH, URI_BR_TO_WINDOWS));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0a%0d%0a%0d\", L\"\\x0d\\x0d\\x0d\", PLUS_DONT_TOUCH, URI_BR_TO_MAC));\n\t\tTEST_ASSERT(testUnescapingHelper(L\"%0a%0d%0a%0d\", L\"\\x0a\\x0d\\x0a\\x0d\", PLUS_DONT_TOUCH, URI_BR_DONT_TOUCH));\n\t}\n\n\tbool testAddBaseHelper(const wchar_t * base, const wchar_t * rel, const wchar_t * expectedResult, bool backward_compatibility = false) {\n\t\tUriParserStateW stateW;\n\n\t\t// Base\n\t\tUriUriW baseUri;\n\t\tstateW.uri = &baseUri;\n\t\tint res = uriParseUriW(&stateW, base);\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&baseUri);\n\t\t\treturn false;\n\t\t}\n\n\t\t// Rel\n\t\tUriUriW relUri;\n\t\tstateW.uri = &relUri;\n\t\tres = uriParseUriW(&stateW, rel);\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&baseUri);\n\t\t\turiFreeUriMembersW(&relUri);\n\t\t\treturn false;\n\t\t}\n\n\t\t// Expected result\n\t\tUriUriW expectedUri;\n\t\tstateW.uri = &expectedUri;\n\t\tres = uriParseUriW(&stateW, expectedResult);\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&baseUri);\n\t\t\turiFreeUriMembersW(&relUri);\n\t\t\turiFreeUriMembersW(&expectedUri);\n\t\t\treturn false;\n\t\t}\n\n\t\t// Transform\n\t\tUriUriW transformedUri;\n\t\tif (backward_compatibility) {\n\t\t\tres = uriAddBaseUriExW(&transformedUri, &relUri, &baseUri, URI_RESOLVE_IDENTICAL_SCHEME_COMPAT);\n\t\t} else {\n\t\t\tres = uriAddBaseUriW(&transformedUri, &relUri, &baseUri);\n\t\t}\n\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&baseUri);\n\t\t\turiFreeUriMembersW(&relUri);\n\t\t\turiFreeUriMembersW(&expectedUri);\n\t\t\turiFreeUriMembersW(&transformedUri);\n\t\t\treturn false;\n\t\t}\n\n\t\tconst bool equal = (URI_TRUE == uriEqualsUriW(&transformedUri, &expectedUri));\n\t\tif (!equal) {\n\t\t\twchar_t transformedUriText[1024 * 8];\n\t\t\twchar_t expectedUriText[1024 * 8];\n\t\t\turiToStringW(transformedUriText, &transformedUri, 1024 * 8, NULL);\n\t\t\turiToStringW(expectedUriText, &expectedUri, 1024 * 8, NULL);\n#ifdef HAVE_WPRINTF\n\t\t\twprintf(L\"\\n\\n\\nExpected: \\\"%s\\\"\\nReceived: \\\"%s\\\"\\n\\n\\n\", expectedUriText, transformedUriText);\n#endif\n\t\t}\n\n\t\turiFreeUriMembersW(&baseUri);\n\t\turiFreeUriMembersW(&relUri);\n\t\turiFreeUriMembersW(&expectedUri);\n\t\turiFreeUriMembersW(&transformedUri);\n\t\treturn equal;\n\t}\n\n\tvoid testTrailingSlash() {\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\t//                          0  3  01\n\t\tconst char * const input = \"abc\" \"/\";\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, input));\n\n\t\tTEST_ASSERT(uriA.pathHead->text.first == input);\n\t\tTEST_ASSERT(uriA.pathHead->text.afterLast == input + 3);\n\t\tTEST_ASSERT(uriA.pathHead->next->text.first == uriA.pathHead->next->text.afterLast);\n\t\tTEST_ASSERT(uriA.pathHead->next->next == NULL);\n\t\tTEST_ASSERT(uriA.pathTail == uriA.pathHead->next);\n\t\turiFreeUriMembersA(&uriA);\n\t}\n\n\tvoid testAddBase() {\n\t\t// 5.4.1. Normal Examples\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g:h\", L\"g:h\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g\", L\"http://a/b/c/g\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"./g\", L\"http://a/b/c/g\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g/\", L\"http://a/b/c/g/\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"/g\", L\"http://a/g\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"//g\", L\"http://g\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"?y\", L\"http://a/b/c/d;p?y\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g?y\", L\"http://a/b/c/g?y\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"#s\", L\"http://a/b/c/d;p?q#s\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g#s\", L\"http://a/b/c/g#s\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g?y#s\", L\"http://a/b/c/g?y#s\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\";x\", L\"http://a/b/c/;x\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g;x\", L\"http://a/b/c/g;x\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g;x?y#s\", L\"http://a/b/c/g;x?y#s\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"\", L\"http://a/b/c/d;p?q\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\".\", L\"http://a/b/c/\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"./\", L\"http://a/b/c/\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"..\", L\"http://a/b/\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"../\", L\"http://a/b/\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"../g\", L\"http://a/b/g\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"../..\", L\"http://a/\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"../../\", L\"http://a/\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"../../g\", L\"http://a/g\"));\n\n\t\t// 5.4.2. Abnormal Examples\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"../../../g\", L\"http://a/g\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"../../../../g\", L\"http://a/g\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"/./g\", L\"http://a/g\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"/../g\", L\"http://a/g\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g.\", L\"http://a/b/c/g.\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\".g\", L\"http://a/b/c/.g\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g..\", L\"http://a/b/c/g..\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"..g\", L\"http://a/b/c/..g\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"./../g\", L\"http://a/b/g\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"./g/.\", L\"http://a/b/c/g/\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g/./h\", L\"http://a/b/c/g/h\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g/../h\", L\"http://a/b/c/h\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g;x=1/./y\", L\"http://a/b/c/g;x=1/y\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g;x=1/../y\", L\"http://a/b/c/y\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g?y/./x\", L\"http://a/b/c/g?y/./x\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g?y/../x\", L\"http://a/b/c/g?y/../x\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g#s/./x\", L\"http://a/b/c/g#s/./x\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"g#s/../x\", L\"http://a/b/c/g#s/../x\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"http:g\", L\"http:g\"));\n\n\t\t// Backward compatibility (feature request #4, RFC3986 5.4.2)\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"http:g\", L\"http:g\", false));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"http:g\", L\"http://a/b/c/g\", true));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"http:g?q#f\", L\"http://a/b/c/g?q#f\", true));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"other:g?q#f\", L\"other:g?q#f\", true));\n\n\t\t// Bug related to absolutePath flag set despite presence of host\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"/\", L\"http://a/\"));\n\t\tTEST_ASSERT(testAddBaseHelper(L\"http://a/b/c/d;p?q\", L\"/g/\", L\"http://a/g/\"));\n\t}\n\n\tbool testToStringHelper(const wchar_t * text) {\n\t\t// Parse\n\t\tUriParserStateW state;\n\t\tUriUriW uri;\n\t\tstate.uri = &uri;\n\t\tint res = uriParseUriW(&state, text);\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\t// Back to string, _huge_ limit\n\t\twchar_t shouldbeTheSame[1024 * 8];\n\t\tres = uriToStringW(shouldbeTheSame, &uri, 1024 * 8, NULL);\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\t// Compare\n\t\tbool equals = (0 == wcscmp(shouldbeTheSame, text));\n\t\tif (!equals) {\n#ifdef HAVE_WPRINTF\n\t\t\twprintf(L\"\\n\\n\\nExpected: \\\"%s\\\"\\nReceived: \\\"%s\\\"\\n\\n\\n\", text, shouldbeTheSame);\n#endif\n\t\t}\n\n\t\t// Back to string, _exact_ limit\n\t\tconst int len = static_cast<int>(wcslen(text));\n\t\tint charsWritten;\n\t\tres = uriToStringW(shouldbeTheSame, &uri, len + 1, &charsWritten);\n\t\tif ((res != 0) || (charsWritten != len + 1)) {\n\t\t\turiFreeUriMembersW(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\t// Back to string, _too small_ limit\n\t\tres = uriToStringW(shouldbeTheSame, &uri, len, &charsWritten);\n\t\tif ((res == 0) || (charsWritten >= len + 1)) {\n\t\t\turiFreeUriMembersW(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\turiFreeUriMembersW(&uri);\n\t\treturn equals;\n\t}\n\n\tvoid testToString() {\n\t\t// Scheme\n\t\tTEST_ASSERT(testToStringHelper(L\"ftp://localhost/\"));\n\t\t// UserInfo\n\t\tTEST_ASSERT(testToStringHelper(L\"http://user:pass@localhost/\"));\n\t\t// IPv4\n\t\tTEST_ASSERT(testToStringHelper(L\"http://123.0.1.255/\"));\n\t\t// IPv6\n\t\tTEST_ASSERT(testToStringHelper(L\"http://[abcd:abcd:abcd:abcd:abcd:abcd:abcd:abcd]/\"));\n\t\t// IPvFuture\n\t\tTEST_ASSERT(testToStringHelper(L\"http://[vA.123456]/\"));\n\t\t// Port\n\t\tTEST_ASSERT(testToStringHelper(L\"http://example.com:123/\"));\n\t\t// Path\n\t\tTEST_ASSERT(testToStringHelper(L\"http://example.com\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"http://example.com/\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"http://example.com/abc/\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"http://example.com/abc/def\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"http://example.com/abc/def/\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"http://example.com//\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"http://example.com/./..\"));\n\t\t// Query\n\t\tTEST_ASSERT(testToStringHelper(L\"http://example.com/?abc\"));\n\t\t// Fragment\n\t\tTEST_ASSERT(testToStringHelper(L\"http://example.com/#abc\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"http://example.com/?def#abc\"));\n\n\t\t// Relative\n\t\tTEST_ASSERT(testToStringHelper(L\"a\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"a/\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"/a\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"/a/\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"abc\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"abc/\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"/abc\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"/abc/\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"a/def\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"a/def/\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"/a/def\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"/a/def/\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"abc/def\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"abc/def/\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"/abc/def\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"/abc/def/\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"/\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"//a/\"));\n\t\tTEST_ASSERT(testToStringHelper(L\".\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"./\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"/.\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"/./\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"./abc/def\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"?query\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"#fragment\"));\n\t\tTEST_ASSERT(testToStringHelper(L\"?query#fragment\"));\n\n\t\t// Tests for bugs from the past\n\t\tTEST_ASSERT(testToStringHelper(L\"f:/.//g\"));\n\t}\n\n\tvoid testToString_Bug1950126() {\n\t\tUriParserStateW state;\n\t\tUriUriW uriOne;\n\t\tUriUriW uriTwo;\n\t\tconst wchar_t * const uriOneString = L\"http://e.com/\";\n\t\tconst wchar_t * const uriTwoString = L\"http://e.com\";\n\t\tstate.uri = &uriOne;\n\t\tTEST_ASSERT(URI_SUCCESS == uriParseUriW(&state, uriOneString));\n\t\tstate.uri = &uriTwo;\n\t\tTEST_ASSERT(URI_SUCCESS == uriParseUriW(&state, uriTwoString));\n\t\tTEST_ASSERT(URI_FALSE == uriEqualsUriW(&uriOne, &uriTwo));\n\t\turiFreeUriMembersW(&uriOne);\n\t\turiFreeUriMembersW(&uriTwo);\n\n\t\tTEST_ASSERT(testToStringHelper(uriOneString));\n\t\tTEST_ASSERT(testToStringHelper(uriTwoString));\n\t}\n\n\tbool testToStringCharsRequiredHelper(const wchar_t * text) {\n\t\t// Parse\n\t\tUriParserStateW state;\n\t\tUriUriW uri;\n\t\tstate.uri = &uri;\n\t\tint res = uriParseUriW(&state, text);\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\t// Required space?\n\t\tint charsRequired;\n\t\tif (uriToStringCharsRequiredW(&uri, &charsRequired) != 0) {\n\t\t\turiFreeUriMembersW(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\t// Minimum\n\t\twchar_t * buffer = new wchar_t[charsRequired + 1];\n\t\tif (uriToStringW(buffer, &uri, charsRequired + 1, NULL) != 0) {\n\t\t\turiFreeUriMembersW(&uri);\n\t\t\tdelete [] buffer;\n\t\t\treturn false;\n\t\t}\n\n\t\t// One less than minimum\n\t\tif (uriToStringW(buffer, &uri, charsRequired, NULL) == 0) {\n\t\t\turiFreeUriMembersW(&uri);\n\t\t\tdelete [] buffer;\n\t\t\treturn false;\n\t\t}\n\n\t\turiFreeUriMembersW(&uri);\n\t\tdelete [] buffer;\n\t\treturn true;\n\t}\n\n\tvoid testToStringCharsRequired() {\n\t\tTEST_ASSERT(testToStringCharsRequiredHelper(L\"http://www.example.com/\"));\n\t\tTEST_ASSERT(testToStringCharsRequiredHelper(L\"http://www.example.com:80/\"));\n\t\tTEST_ASSERT(testToStringCharsRequiredHelper(L\"http://user:pass@www.example.com/\"));\n\t\tTEST_ASSERT(testToStringCharsRequiredHelper(L\"http://www.example.com/index.html\"));\n\t\tTEST_ASSERT(testToStringCharsRequiredHelper(L\"http://www.example.com/?abc\"));\n\t\tTEST_ASSERT(testToStringCharsRequiredHelper(L\"http://www.example.com/#def\"));\n\t\tTEST_ASSERT(testToStringCharsRequiredHelper(L\"http://www.example.com/?abc#def\"));\n\t\tTEST_ASSERT(testToStringCharsRequiredHelper(L\"/test\"));\n\t\tTEST_ASSERT(testToStringCharsRequiredHelper(L\"test\"));\n\t}\n\n\tbool testNormalizeMaskHelper(const wchar_t * uriText, unsigned int expectedMask) {\n\t\tUriParserStateW state;\n\t\tUriUriW uri;\n\t\tstate.uri = &uri;\n\t\tint res = uriParseUriW(&state, uriText);\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\tconst unsigned int maskBefore = uriNormalizeSyntaxMaskRequiredW(&uri);\n\t\tif (maskBefore != expectedMask) {\n\t\t\turiFreeUriMembersW(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\tres = uriNormalizeSyntaxW(&uri);\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&uri);\n\t\t\treturn false;\n\t\t}\n\n\t\tconst unsigned int maskAfter = uriNormalizeSyntaxMaskRequiredW(&uri);\n\t\turiFreeUriMembersW(&uri);\n\n\t\t// Second call should be no problem\n\t\turiFreeUriMembersW(&uri);\n\n\t\treturn (maskAfter == URI_NORMALIZED);\n\t}\n\n\tvoid testNormalizeSyntaxMaskRequired() {\n\t\tTEST_ASSERT(testNormalizeMaskHelper(L\"http://localhost/\", URI_NORMALIZED));\n\t\tTEST_ASSERT(testNormalizeMaskHelper(L\"httP://localhost/\", URI_NORMALIZE_SCHEME));\n\t\tTEST_ASSERT(testNormalizeMaskHelper(L\"http://%0d@localhost/\", URI_NORMALIZE_USER_INFO));\n\t\tTEST_ASSERT(testNormalizeMaskHelper(L\"http://localhosT/\", URI_NORMALIZE_HOST));\n\t\tTEST_ASSERT(testNormalizeMaskHelper(L\"http://localhost/./abc\", URI_NORMALIZE_PATH));\n\t\tTEST_ASSERT(testNormalizeMaskHelper(L\"http://localhost/?AB%43\", URI_NORMALIZE_QUERY));\n\t\tTEST_ASSERT(testNormalizeMaskHelper(L\"http://localhost/#AB%43\", URI_NORMALIZE_FRAGMENT));\n\t}\n\n\tbool testNormalizeSyntaxHelper(const wchar_t * uriText, const wchar_t * expectedNormalized,\n\t\t\tunsigned int mask = static_cast<unsigned int>(-1)) {\n\t\tUriParserStateW stateW;\n\t\tint res;\n\n\t\tUriUriW testUri;\n\t\tstateW.uri = &testUri;\n\t\tres = uriParseUriW(&stateW, uriText);\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&testUri);\n\t\t\treturn false;\n\t\t}\n\n\t\t// Expected result\n\t\tUriUriW expectedUri;\n\t\tstateW.uri = &expectedUri;\n\t\tres = uriParseUriW(&stateW, expectedNormalized);\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&testUri);\n\t\t\turiFreeUriMembersW(&expectedUri);\n\t\t\treturn false;\n\t\t}\n\n\t\t// First run\n\t\tres = uriNormalizeSyntaxExW(&testUri, mask);\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&testUri);\n\t\t\turiFreeUriMembersW(&expectedUri);\n\t\t\treturn false;\n\t\t}\n\n\t\tbool equalAfter = (URI_TRUE == uriEqualsUriW(&testUri, &expectedUri));\n\n\t\t// Second run\n\t\tres = uriNormalizeSyntaxExW(&testUri, mask);\n\t\tif (res != 0) {\n\t\t\turiFreeUriMembersW(&testUri);\n\t\t\turiFreeUriMembersW(&expectedUri);\n\t\t\treturn false;\n\t\t}\n\n\t\tequalAfter = equalAfter\n\t\t\t\t&& (URI_TRUE == uriEqualsUriW(&testUri, &expectedUri));\n\n\t\turiFreeUriMembersW(&testUri);\n\t\turiFreeUriMembersW(&expectedUri);\n\t\treturn equalAfter;\n\t}\n\n\tvoid testNormalizeSyntax() {\n\t\tTEST_ASSERT(testNormalizeSyntaxHelper(\n\t\t\t\tL\"eXAMPLE://a/./b/../b/%63/%7bfoo%7d\",\n\t\t\t\tL\"example://a/b/c/%7Bfoo%7D\"));\n\n\t\t// Testcase by Adrian Manrique\n\t\tTEST_ASSERT(testNormalizeSyntaxHelper(\n\t\t\t\tL\"http://examp%4Ce.com/\",\n\t\t\t\tL\"http://example.com/\"));\n\n\t\t// Testcase by Adrian Manrique\n\t\tTEST_ASSERT(testNormalizeSyntaxHelper(\n\t\t\t\tL\"http://example.com/a/b/%2E%2E/\",\n\t\t\t\tL\"http://example.com/a/\"));\n\n\t\t// Reported by Adrian Manrique\n\t\tTEST_ASSERT(testNormalizeSyntaxHelper(\n\t\t\t\tL\"http://user:pass@SOMEHOST.COM:123\",\n\t\t\t\tL\"http://user:pass@somehost.com:123\"));\n\n\t\tTEST_ASSERT(testNormalizeSyntaxHelper(\n\t\t\t\tL\"HTTP://a:b@HOST:123/./1/2/../%41?abc#def\",\n\t\t\t\tL\"http://a:b@host:123/1/A?abc#def\"));\n\n\t\tTEST_ASSERT(testNormalizeSyntaxHelper(\n\t\t\t\tL\"../../abc\",\n\t\t\t\tL\"../../abc\"));\n\n\t\tTEST_ASSERT(testNormalizeSyntaxHelper(\n\t\t\t\tL\"../../abc/..\",\n\t\t\t\tL\"../../\"));\n\n\t\tTEST_ASSERT(testNormalizeSyntaxHelper(\n\t\t\t\tL\"../../abc/../def\",\n\t\t\t\tL\"../../def\"));\n\n\t\tTEST_ASSERT(testNormalizeSyntaxHelper(\n\t\t\t\tL\"abc/..\",\n\t\t\t\tL\"\"));\n\n\t\tTEST_ASSERT(testNormalizeSyntaxHelper(\n\t\t\t\tL\"abc/../\",\n\t\t\t\tL\"\"));\n\n\t\tTEST_ASSERT(testNormalizeSyntaxHelper(\n\t\t\t\tL\"../../abc/./def\",\n\t\t\t\tL\"../../abc/def\"));\n\n\t\tTEST_ASSERT(testNormalizeSyntaxHelper(\n\t\t\t\tL\"./def\",\n\t\t\t\tL\"def\"));\n\n\t\tTEST_ASSERT(testNormalizeSyntaxHelper(\n\t\t\t\tL\"def/.\",\n\t\t\t\tL\"def/\"));\n\n\t\tTEST_ASSERT(testNormalizeSyntaxHelper(\n\t\t\t\tL\"./abc:def\",\n\t\t\t\tL\"./abc:def\"));\n\t}\n\n\tvoid testNormalizeSyntaxComponents() {\n\t\tTEST_ASSERT(testNormalizeSyntaxHelper(\n\t\t\t\tL\"HTTP://%41@EXAMPLE.ORG/../a?%41#%41\",\n\t\t\t\tL\"http://%41@EXAMPLE.ORG/../a?%41#%41\",\n\t\t\t\tURI_NORMALIZE_SCHEME));\n\n\t\tTEST_ASSERT(testNormalizeSyntaxHelper(\n\t\t\t\tL\"HTTP://%41@EXAMPLE.ORG/../a?%41#%41\",\n\t\t\t\tL\"HTTP://A@EXAMPLE.ORG/../a?%41#%41\",\n\t\t\t\tURI_NORMALIZE_USER_INFO));\n\n\t\tTEST_ASSERT(testNormalizeSyntaxHelper(\n\t\t\t\tL\"HTTP://%41@EXAMPLE.ORG/../a?%41#%41\",\n\t\t\t\tL\"HTTP://%41@example.org/../a?%41#%41\",\n\t\t\t\tURI_NORMALIZE_HOST));\n\n\t\tTEST_ASSERT(testNormalizeSyntaxHelper(\n\t\t\t\tL\"HTTP://%41@EXAMPLE.ORG/../a?%41#%41\",\n\t\t\t\tL\"HTTP://%41@EXAMPLE.ORG/a?%41#%41\",\n\t\t\t\tURI_NORMALIZE_PATH));\n\n\t\tTEST_ASSERT(testNormalizeSyntaxHelper(\n\t\t\t\tL\"HTTP://%41@EXAMPLE.ORG/../a?%41#%41\",\n\t\t\t\tL\"HTTP://%41@EXAMPLE.ORG/../a?A#%41\",\n\t\t\t\tURI_NORMALIZE_QUERY));\n\n\t\tTEST_ASSERT(testNormalizeSyntaxHelper(\n\t\t\t\tL\"HTTP://%41@EXAMPLE.ORG/../a?%41#%41\",\n\t\t\t\tL\"HTTP://%41@EXAMPLE.ORG/../a?%41#A\",\n\t\t\t\tURI_NORMALIZE_FRAGMENT));\n\t}\n\n\tvoid testNormalizeCrash_Bug20080224() {\n\t\tUriParserStateW stateW;\n\t\tint res;\n\t\tUriUriW testUri;\n\t\tstateW.uri = &testUri;\n\n\t\tres = uriParseUriW(&stateW, L\"http://example.org/abc//../def\");\n\t\tTEST_ASSERT(res == 0);\n\n\t\t// First call will make us owner of copied memory\n\t\tres = uriNormalizeSyntaxExW(&testUri, URI_NORMALIZE_SCHEME);\n\t\tTEST_ASSERT(res == 0);\n\t\tres = uriNormalizeSyntaxExW(&testUri, URI_NORMALIZE_HOST);\n\t\tTEST_ASSERT(res == 0);\n\n\t\t// Frees empty path segment -> crash\n\t\tres = uriNormalizeSyntaxW(&testUri);\n\t\tTEST_ASSERT(res == 0);\n\n\t\turiFreeUriMembersW(&testUri);\n\t}\n\n\tvoid testFilenameUriConversionHelper(const wchar_t * filename,\n\t\t\tconst wchar_t * uriString, bool forUnix,\n\t\t\tconst wchar_t * expectedUriString = NULL) {\n\t\tconst int prefixLen = forUnix ? 7 : 8;\n\t\tif (! expectedUriString) {\n\t\t\texpectedUriString = uriString;\n\t\t}\n\n\t\t// Filename to URI string\n\t\tconst size_t uriBufferLen = prefixLen + 3 * wcslen(filename) + 1;\n\t\twchar_t * uriBuffer = new wchar_t[uriBufferLen];\n\t\tif (forUnix) {\n\t\t\turiUnixFilenameToUriStringW(filename, uriBuffer);\n\t\t} else {\n\t\t\turiWindowsFilenameToUriStringW(filename, uriBuffer);\n\t\t}\n#ifdef HAVE_WPRINTF\n\t\t// wprintf(L\"1 [%s][%s]\\n\", uriBuffer, expectedUriString);\n#endif\n\t\tTEST_ASSERT(!wcscmp(uriBuffer, expectedUriString));\n\t\tdelete [] uriBuffer;\n\n\t\t// URI string to filename\n\t\tconst size_t filenameBufferLen = wcslen(uriString) + 1;\n\t\twchar_t * filenameBuffer = new wchar_t[filenameBufferLen];\n\t\tif (forUnix) {\n\t\t\turiUriStringToUnixFilenameW(uriString, filenameBuffer);\n\t\t} else {\n\t\t\turiUriStringToWindowsFilenameW(uriString, filenameBuffer);\n\t\t}\n#ifdef HAVE_WPRINTF\n\t\t// wprintf(L\"2 [%s][%s]\\n\", filenameBuffer, filename);\n#endif\n\t\tTEST_ASSERT(!wcscmp(filenameBuffer, filename));\n\t\tdelete [] filenameBuffer;\n\t}\n\n\tvoid testFilenameUriConversion() {\n\t\tconst bool FOR_UNIX = true;\n\t\tconst bool FOR_WINDOWS = false;\n\t\ttestFilenameUriConversionHelper(L\"/bin/bash\", L\"file:///bin/bash\", FOR_UNIX);\n\t\ttestFilenameUriConversionHelper(L\"/bin/bash\", L\"file:/bin/bash\", FOR_UNIX, L\"file:///bin/bash\");\n\t\ttestFilenameUriConversionHelper(L\"./configure\", L\"./configure\", FOR_UNIX);\n\n\t\ttestFilenameUriConversionHelper(L\"E:\\\\Documents and Settings\", L\"file:///E:/Documents%20and%20Settings\", FOR_WINDOWS);\n\t\ttestFilenameUriConversionHelper(L\"c:\\\\path\\\\to\\\\file.txt\", L\"file:c:/path/to/file.txt\", FOR_WINDOWS, L\"file:///c:/path/to/file.txt\");\n\n\t\ttestFilenameUriConversionHelper(L\".\\\\Readme.txt\", L\"./Readme.txt\", FOR_WINDOWS);\n\n\t\ttestFilenameUriConversionHelper(L\"index.htm\", L\"index.htm\", FOR_WINDOWS);\n\t\ttestFilenameUriConversionHelper(L\"index.htm\", L\"index.htm\", FOR_UNIX);\n\n\t\ttestFilenameUriConversionHelper(L\"abc def\", L\"abc%20def\", FOR_WINDOWS);\n\t\ttestFilenameUriConversionHelper(L\"abc def\", L\"abc%20def\", FOR_UNIX);\n\n\t\ttestFilenameUriConversionHelper(L\"\\\\\\\\Server01\\\\user\\\\docs\\\\Letter.txt\", L\"file://Server01/user/docs/Letter.txt\", FOR_WINDOWS);\n\t}\n\n\tvoid testCrash_FreeUriMembers_Bug20080116() {\n\t\t// Testcase by Adrian Manrique\n\t\tUriParserStateA state;\n\t\tUriUriA uri;\n\t\tstate.uri = &uri;\n\t\turiParseUriA(&state, \"http://test/?\");\n\t\turiNormalizeSyntaxA(&uri);\n\t\turiFreeUriMembersA(&uri);\n\n\t\tTEST_ASSERT(true);\n\t}\n\n\tvoid testCrash_Report2418192() {\n\t\t// Testcase by Harvey Vrsalovic\n\t\thelperTestQueryString(\"http://svcs.cnn.com/weather/wrapper.jsp?&csiID=csi1\", 1);\n\t}\n\n\tvoid testPervertedQueryString() {\n\t\thelperTestQueryString(\"http://example.org/?&&=&&&=&&&&==&===&====\", 5);\n\t}\n\n\tvoid testQueryStringEndingInEqualSign_NonBug32() {\n\t\tconst char * queryString = \"firstname=sdsd&lastname=\";\n\n\t\tUriQueryListA * queryList = NULL;\n\t\tint itemCount = 0;\n\t\tconst int res = uriDissectQueryMallocA(&queryList, &itemCount,\n\t\t\t\tqueryString, queryString + strlen(queryString));\n\n\t\tTEST_ASSERT(res == URI_SUCCESS);\n\t\tTEST_ASSERT(itemCount == 2);\n\t\tTEST_ASSERT(queryList != NULL);\n\t\tTEST_ASSERT(strcmp(queryList->key, \"firstname\") == 0);\n\t\tTEST_ASSERT(strcmp(queryList->value, \"sdsd\") == 0);\n\t\tTEST_ASSERT(strcmp(queryList->next->key, \"lastname\") == 0);\n\t\tTEST_ASSERT(strcmp(queryList->next->value, \"\") == 0);\n\t\tTEST_ASSERT(queryList->next->next == NULL);\n\n\t\turiFreeQueryListA(queryList);\n\t}\n\n\tvoid helperTestQueryString(char const * uriString, int pairsExpected) {\n\t\tUriParserStateA state;\n\t\tUriUriA uri;\n\t\tstate.uri = &uri;\n\t\tint res = uriParseUriA(&state, uriString);\n\t\tTEST_ASSERT(res == URI_SUCCESS);\n\n\t\tUriQueryListA * queryList = NULL;\n\t\tint itemCount = 0;\n\n\t\tres = uriDissectQueryMallocA(&queryList, &itemCount,\n\t\t\t\turi.query.first, uri.query.afterLast);\n\t\tTEST_ASSERT(res == URI_SUCCESS);\n\t\tTEST_ASSERT(queryList != NULL);\n\t\tTEST_ASSERT(itemCount == pairsExpected);\n\t\turiFreeQueryListA(queryList);\n\t\turiFreeUriMembersA(&uri);\n\t}\n\n\tvoid testCrash_MakeOwner_Bug20080207() {\n\t\t// Testcase by Adrian Manrique\n\t\tUriParserStateA state;\n\t\tUriUriA sourceUri;\n\t\tstate.uri = &sourceUri;\n\t\tconst char * const sourceUriString = \"http://user:pass@somehost.com:80/\";\n\t\tif (uriParseUriA(&state, sourceUriString) != 0) {\n\t\t\tTEST_ASSERT(false);\n\t\t}\n\t\tif (uriNormalizeSyntaxA(&sourceUri) != 0) {\n\t\t\tTEST_ASSERT(false);\n\t\t}\n\t\turiFreeUriMembersA(&sourceUri);\n\t\tTEST_ASSERT(true);\n\t}\n\n\tvoid testQueryListHelper(const wchar_t * input, int expectedItemCount) {\n\t\tint res;\n\n\t\tUriBool spacePlusConversion = URI_TRUE;\n\t\tUriBool normalizeBreaks = URI_FALSE;\n\t\tUriBreakConversion breakConversion = URI_BR_DONT_TOUCH;\n\n\t\tint itemCount;\n\t\tUriQueryListW * queryList;\n\t\tres = uriDissectQueryMallocExW(&queryList, &itemCount,\n\t\t\t\tinput, input + wcslen(input), spacePlusConversion, breakConversion);\n\t\tTEST_ASSERT(res == URI_SUCCESS);\n\t\tTEST_ASSERT(itemCount == expectedItemCount);\n\t\tTEST_ASSERT((queryList == NULL) == (expectedItemCount == 0));\n\n\t\tif (expectedItemCount != 0) {\n\t\t\t// First\n\t\t\tint charsRequired;\n\t\t\tres = uriComposeQueryCharsRequiredExW(queryList, &charsRequired, spacePlusConversion,\n\t\t\t\t\tnormalizeBreaks);\n\t\t\tTEST_ASSERT(res == URI_SUCCESS);\n\t\t\tTEST_ASSERT(charsRequired >= (int)wcslen(input));\n\n\t\t\twchar_t * recomposed = new wchar_t[charsRequired + 1];\n\t\t\tint charsWritten;\n\t\t\tres = uriComposeQueryExW(recomposed, queryList, charsRequired + 1,\n\t\t\t\t\t&charsWritten, spacePlusConversion, normalizeBreaks);\n\t\t\tTEST_ASSERT(res == URI_SUCCESS);\n\t\t\tTEST_ASSERT(charsWritten <= charsRequired);\n\t\t\tTEST_ASSERT(charsWritten == (int)wcslen(input) + 1);\n\t\t\tTEST_ASSERT(!wcscmp(input, recomposed));\n\t\t\tdelete [] recomposed;\n\n\t\t\trecomposed = NULL;\n\t\t\tres = uriComposeQueryMallocW(&recomposed, queryList);\n\t\t\tTEST_ASSERT(res == URI_SUCCESS);\n\t\t\tTEST_ASSERT(recomposed != NULL);\n\t\t\tTEST_ASSERT(charsWritten == (int)wcslen(input) + 1);\n\t\t\tTEST_ASSERT(!wcscmp(input, recomposed));\n\t\t\tfree(recomposed);\n\t\t}\n\n\t\turiFreeQueryListW(queryList);\n\t}\n\n\tvoid testQueryList() {\n\t\ttestQueryListHelper(L\"one=ONE&two=TWO\", 2);\n\t\ttestQueryListHelper(L\"one=ONE&two=&three=THREE\", 3);\n\t\ttestQueryListHelper(L\"one=ONE&two&three=THREE\", 3);\n\t\ttestQueryListHelper(L\"one=ONE\", 1);\n\t\ttestQueryListHelper(L\"one\", 1);\n\t\ttestQueryListHelper(L\"\", 0);\n\t}\n\n\tvoid testQueryListPairHelper(const char * pair, const char * unescapedKey,\n\t\t\tconst char * unescapedValue, const char * fixed = NULL) {\n\t\tint res;\n\t\tUriQueryListA * queryList;\n\t\tint itemCount;\n\n\t\tres = uriDissectQueryMallocA(&queryList, &itemCount, pair, pair + strlen(pair));\n\t\tTEST_ASSERT(res == URI_SUCCESS);\n\t\tTEST_ASSERT(queryList != NULL);\n\t\tTEST_ASSERT(itemCount == 1);\n\t\tTEST_ASSERT(!strcmp(queryList->key, unescapedKey));\n\t\tTEST_ASSERT(!strcmp(queryList->value, unescapedValue));\n\n\t\tchar * recomposed;\n\t\tres = uriComposeQueryMallocA(&recomposed, queryList);\n\t\tTEST_ASSERT(res == URI_SUCCESS);\n\t\tTEST_ASSERT(recomposed != NULL);\n\t\tTEST_ASSERT(!strcmp(recomposed, (fixed != NULL) ? fixed : pair));\n\t\tfree(recomposed);\n\t\turiFreeQueryListA(queryList);\n\t}\n\n\tvoid testQueryListPair() {\n\t\ttestQueryListPairHelper(\"one+two+%26+three=%2B\", \"one two & three\", \"+\");\n\t\ttestQueryListPairHelper(\"one=two=three\", \"one\", \"two=three\", \"one=two%3Dthree\");\n\t\ttestQueryListPairHelper(\"one=two=three=four\", \"one\", \"two=three=four\", \"one=two%3Dthree%3Dfour\");\n\t}\n\n\tvoid testQueryDissection_Bug3590761() {\n\t\tint res;\n\t\tUriQueryListA * queryList;\n\t\tint itemCount;\n\t\tconst char * const pair = \"q=hello&x=&y=\";\n\n\t\tres = uriDissectQueryMallocA(&queryList, &itemCount, pair, pair + strlen(pair));\n\t\tTEST_ASSERT(res == URI_SUCCESS);\n\t\tTEST_ASSERT(queryList != NULL);\n\t\tTEST_ASSERT(itemCount == 3);\n\n\t\tTEST_ASSERT(!strcmp(queryList->key, \"q\"));\n\t\tTEST_ASSERT(!strcmp(queryList->value, \"hello\"));\n\n\t\tTEST_ASSERT(!strcmp(queryList->next->key, \"x\"));\n\t\tTEST_ASSERT(!strcmp(queryList->next->value, \"\"));\n\n\t\tTEST_ASSERT(!strcmp(queryList->next->next->key, \"y\"));\n\t\tTEST_ASSERT(!strcmp(queryList->next->next->value, \"\"));\n\n\t\tTEST_ASSERT(! queryList->next->next->next);\n\n\t\turiFreeQueryListA(queryList);\n\t}\n\n\tvoid testQueryCompositionMathWrite_GoogleAutofuzz113244572() {\n\t\tUriQueryListA second = { .key = \"\\x11\", .value = NULL, .next = NULL };\n\t\tUriQueryListA first = { .key = \"\\x01\", .value = \"\\x02\", .next = &second };\n\n\t\tconst UriBool spaceToPlus = URI_TRUE;\n\t\tconst UriBool normalizeBreaks = URI_FALSE;  /* for factor 3 but 6 */\n\n\t\tconst int charsRequired = (3 + 1 + 3) + 1 + (3);\n\n\t\t{\n\t\t\t// Minimum space to hold everything fine\n\t\t\tconst char * const expected = \"%01=%02\" \"&\" \"%11\";\n\t\t\tchar dest[charsRequired + 1];\n\t\t\tint charsWritten;\n\t\t\tTEST_ASSERT(uriComposeQueryExA(dest, &first, sizeof(dest),\n\t\t\t\t\t&charsWritten, spaceToPlus, normalizeBreaks)\n\t\t\t\t== URI_SUCCESS);\n\t\t\tTEST_ASSERT(! strcmp(dest, expected));\n\t\t\tTEST_ASSERT(charsWritten == strlen(expected) + 1);\n\t\t}\n\n\t\t{\n\t\t\t// Previous math failed to take ampersand into account\n\t\t\tchar dest[charsRequired + 1 - 1];\n\t\t\tint charsWritten;\n\t\t\tTEST_ASSERT(uriComposeQueryExA(dest, &first, sizeof(dest),\n\t\t\t\t\t&charsWritten, spaceToPlus, normalizeBreaks)\n\t\t\t\t== URI_ERROR_OUTPUT_TOO_LARGE);\n\t\t}\n\t}\n\n\tvoid testFreeCrash_Bug20080827() {\n\t\tchar const * const sourceUri = \"abc\";\n\t\tchar const * const baseUri = \"http://www.example.org/\";\n\n\t\tint res;\n\t\tUriParserStateA state;\n\t\tUriUriA absoluteDest;\n\t\tUriUriA relativeSource;\n\t\tUriUriA absoluteBase;\n\n\t\tstate.uri = &relativeSource;\n\t\tres = uriParseUriA(&state, sourceUri);\n\t\tTEST_ASSERT(res == URI_SUCCESS);\n\n\t\tstate.uri = &absoluteBase;\n\t\tres = uriParseUriA(&state, baseUri);\n\t\tTEST_ASSERT(res == URI_SUCCESS);\n\n\t\tres = uriRemoveBaseUriA(&absoluteDest, &relativeSource, &absoluteBase, URI_FALSE);\n\t\tTEST_ASSERT(res == URI_ERROR_REMOVEBASE_REL_SOURCE);\n\n\t\turiFreeUriMembersA(&relativeSource);\n\t\turiFreeUriMembersA(&absoluteBase);\n\t\turiFreeUriMembersA(&absoluteDest); // Crashed here\n\t}\n\n\tvoid testParseInvalid_Bug16() {\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\tconst char * const input = \"A>B\";\n\n\t\tconst int res = uriParseUriA(&stateA, input);\n\n\t\tTEST_ASSERT(res == URI_ERROR_SYNTAX);\n\t\tTEST_ASSERT(stateA.errorPos == input + 1);\n\t\tTEST_ASSERT(stateA.errorCode == URI_ERROR_SYNTAX);  /* failed previously */\n\n\t\turiFreeUriMembersA(&uriA);\n\t}\n\n\tvoid testEqualsHelper(const char * uri_to_test) {\n\t\tUriParserStateA state;\n\t\tUriUriA uriOne;\n\t\tUriUriA uriTwo;\n\t\tstate.uri = &uriOne;\n\t\tTEST_ASSERT(URI_SUCCESS == uriParseUriA(&state, uri_to_test));\n\t\tstate.uri = &uriTwo;\n\t\tTEST_ASSERT(URI_SUCCESS == uriParseUriA(&state, uri_to_test));\n\t\tTEST_ASSERT(URI_TRUE == uriEqualsUriA(&uriOne, &uriTwo));\n\t\turiFreeUriMembersA(&uriOne);\n\t\turiFreeUriMembersA(&uriTwo);\n\t}\n\n\tvoid testEquals() {\n\t\ttestEqualsHelper(\"http://host\");\n\t\ttestEqualsHelper(\"http://host:123\");\n\t\ttestEqualsHelper(\"http://foo:bar@host:123\");\n\t\ttestEqualsHelper(\"http://foo:bar@host:123/\");\n\t\ttestEqualsHelper(\"http://foo:bar@host:123/path\");\n\t\ttestEqualsHelper(\"http://foo:bar@host:123/path?query\");\n\t\ttestEqualsHelper(\"http://foo:bar@host:123/path?query#fragment\");\n\n\t\ttestEqualsHelper(\"path\");\n\t\ttestEqualsHelper(\"/path\");\n\t\ttestEqualsHelper(\"/path/\");\n\t\ttestEqualsHelper(\"//path/\");\n\t\ttestEqualsHelper(\"//host\");\n\t\ttestEqualsHelper(\"//host:123\");\n\t}\n\n\tvoid testHostTextTermination_Issue15() {\n\t\tUriParserStateA state;\n\t\tUriUriA uri;\n\t\tstate.uri = &uri;\n\n\t\t// Empty host and port\n\t\tconst char * const emptyHostWithPortUri = \"//:123\";\n\t\tTEST_ASSERT(URI_SUCCESS == uriParseUriA(&state, emptyHostWithPortUri));\n\t\tTEST_ASSERT(uri.hostText.first == emptyHostWithPortUri + strlen(\"//\"));\n\t\tTEST_ASSERT(uri.hostText.afterLast == uri.hostText.first + 0);\n\t\tTEST_ASSERT(uri.portText.first == emptyHostWithPortUri\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ strlen(\"//:\"));\n\t\tTEST_ASSERT(uri.portText.afterLast == uri.portText.first\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ strlen(\"123\"));\n\t\turiFreeUriMembersA(&uri);\n\n\t\t// Non-empty host and port\n\t\tconst char * const hostWithPortUri = \"//h:123\";\n\t\tTEST_ASSERT(URI_SUCCESS == uriParseUriA(&state, hostWithPortUri));\n\t\tTEST_ASSERT(uri.hostText.first == hostWithPortUri + strlen(\"//\"));\n\t\tTEST_ASSERT(uri.hostText.afterLast == uri.hostText.first\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ strlen(\"h\"));\n\t\tTEST_ASSERT(uri.portText.first == hostWithPortUri + strlen(\"//h:\"));\n\t\tTEST_ASSERT(uri.portText.afterLast == uri.portText.first\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ strlen(\"123\"));\n\t\turiFreeUriMembersA(&uri);\n\n\t\t// Empty host, empty user info\n\t\tconst char * const emptyHostEmptyUserInfoUri = \"//@\";\n\t\tTEST_ASSERT(URI_SUCCESS == uriParseUriA(&state,\n\t\t\t\t\t\t\t\t\t\t\t\temptyHostEmptyUserInfoUri));\n\t\tTEST_ASSERT(uri.userInfo.first == emptyHostEmptyUserInfoUri\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ strlen(\"//\"));\n\t\tTEST_ASSERT(uri.userInfo.afterLast == uri.userInfo.first + 0);\n\t\tTEST_ASSERT(uri.hostText.first == emptyHostEmptyUserInfoUri\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ strlen(\"//@\"));\n\t\tTEST_ASSERT(uri.hostText.afterLast == uri.hostText.first + 0);\n\t\turiFreeUriMembersA(&uri);\n\n\t\t// Non-empty host, empty user info\n\t\tconst char * const hostEmptyUserInfoUri = \"//@h\";\n\t\tTEST_ASSERT(URI_SUCCESS == uriParseUriA(&state, hostEmptyUserInfoUri));\n\t\tTEST_ASSERT(uri.userInfo.first == hostEmptyUserInfoUri + strlen(\"//\"));\n\t\tTEST_ASSERT(uri.userInfo.afterLast == uri.userInfo.first + 0);\n\t\tTEST_ASSERT(uri.hostText.first == hostEmptyUserInfoUri\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ strlen(\"//@\"));\n\t\tTEST_ASSERT(uri.hostText.afterLast == uri.hostText.first\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ strlen(\"h\"));\n\t\turiFreeUriMembersA(&uri);\n\n\t\t// Empty host, non-empty user info\n\t\tconst char * const emptyHostWithUserInfoUri = \"//:@\";\n\t\tTEST_ASSERT(URI_SUCCESS == uriParseUriA(&state,\n\t\t\t\t\t\t\t\t\t\t\t\temptyHostWithUserInfoUri));\n\t\tTEST_ASSERT(uri.userInfo.first == emptyHostWithUserInfoUri\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ strlen(\"//\"));\n\t\tTEST_ASSERT(uri.userInfo.afterLast == uri.userInfo.first + 1);\n\t\tTEST_ASSERT(uri.hostText.first == emptyHostWithUserInfoUri\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ strlen(\"//:@\"));\n\t\tTEST_ASSERT(uri.hostText.afterLast == uri.hostText.first + 0);\n\t\turiFreeUriMembersA(&uri);\n\n\t\t// Exact case from issue #15\n\t\tconst char * const issue15Uri = \"//:%aa@\";\n\t\tTEST_ASSERT(URI_SUCCESS == uriParseUriA(&state, issue15Uri));\n\t\tTEST_ASSERT(uri.userInfo.first == issue15Uri + strlen(\"//\"));\n\t\tTEST_ASSERT(uri.userInfo.afterLast == uri.userInfo.first\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ strlen(\":%aa\"));\n\t\tTEST_ASSERT(uri.hostText.first == issue15Uri + strlen(\"//:%aa@\"));\n\t\tTEST_ASSERT(uri.hostText.afterLast == uri.hostText.first + 0);\n\t\turiFreeUriMembersA(&uri);\n\t}\n\n\tvoid testCompareRangeHelper(const char * a, const char * b, int expected, bool avoidNullRange = true) {\n\t\tUriTextRangeA ra;\n\t\tUriTextRangeA rb;\n\n\t\tif (a) {\n\t\t\tra.first = a;\n\t\t\tra.afterLast = a + strlen(a);\n\t\t} else {\n\t\t\tra.first = NULL;\n\t\t\tra.afterLast = NULL;\n\t\t}\n\n\t\tif (b) {\n\t\t\trb.first = b;\n\t\t\trb.afterLast = b + strlen(b);\n\t\t} else {\n\t\t\trb.first = NULL;\n\t\t\trb.afterLast = NULL;\n\t\t}\n\n\t\tconst int received = uriCompareRangeA(\n\t\t\t\t((a == NULL) && avoidNullRange) ? NULL : &ra,\n\t\t\t\t((b == NULL) && avoidNullRange) ? NULL : &rb);\n\t\tif (received != expected) {\n\t\t\tprintf(\"Comparing <%s> to <%s> yields %d, expected %d.\\n\",\n\t\t\t\t\ta, b, received, expected);\n\t\t}\n\t\tTEST_ASSERT(received == expected);\n\t}\n\n\tvoid testRangeComparison() {\n\t\ttestCompareRangeHelper(\"\", \"\", 0);\n\t\ttestCompareRangeHelper(\"a\", \"\", 1);\n\t\ttestCompareRangeHelper(\"\", \"a\", -1);\n\n\t\ttestCompareRangeHelper(\"a\", \"a\", 0);\n\t\ttestCompareRangeHelper(\"a\", \"b\", -1);\n\t\ttestCompareRangeHelper(\"b\", \"a\", 1);\n\n\t\ttestCompareRangeHelper(\"a\", \"aa\", -1);\n\t\ttestCompareRangeHelper(\"aa\", \"a\", 1);\n\n\t\t// Fixed with 0.8.1:\n\t\ttestCompareRangeHelper(NULL, \"a\", -1);\n\t\ttestCompareRangeHelper(\"a\", NULL, 1);\n\t\ttestCompareRangeHelper(NULL, NULL, 0);\n\n\t\t// Fixed with 0.8.3\n\t\tconst bool KEEP_NULL_RANGE = false;\n\t\tconst bool AVOID_NULL_RANGE = true;\n\t\ttestCompareRangeHelper(NULL, \"\", -1, AVOID_NULL_RANGE);\n\t\ttestCompareRangeHelper(NULL, \"\", -1, KEEP_NULL_RANGE);\n\t\ttestCompareRangeHelper(\"\", NULL, 1, AVOID_NULL_RANGE);\n\t\ttestCompareRangeHelper(\"\", NULL, 1, KEEP_NULL_RANGE);\n\t}\n\n\tvoid testRemoveBaseUriHelper(const char * expected,\n\t\t\t\t\t\t\t\tconst char * absSourceStr,\n\t\t\t\t\t\t\t\tconst char * absBaseStr) {\n\t\tUriParserStateA state;\n\t\tUriUriA absSource;\n\t\tUriUriA absBase;\n\t\tUriUriA dest;\n\n\t\tstate.uri = &absSource;\n\t\tTEST_ASSERT(uriParseUriA(&state, absSourceStr) == URI_SUCCESS);\n\n\t\tstate.uri = &absBase;\n\t\tTEST_ASSERT(uriParseUriA(&state, absBaseStr) == URI_SUCCESS);\n\n\t\tTEST_ASSERT(uriRemoveBaseUriA(&dest, &absSource, &absBase, URI_FALSE)\n\t\t\t\t== URI_SUCCESS);\n\n\t\tint size = 0;\n\t\tTEST_ASSERT(uriToStringCharsRequiredA(&dest, &size) == URI_SUCCESS);\n\t\tchar * const buffer = (char *)malloc(size + 1);\n\t\tTEST_ASSERT(buffer);\n\t\tTEST_ASSERT(uriToStringA(buffer, &dest, size + 1, &size)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t== URI_SUCCESS);\n\t\tif (strcmp(buffer, expected)) {\n\t\t\tprintf(\"Expected \\\"%s\\\" but got \\\"%s\\\"\\n\", expected, buffer);\n\t\t\tTEST_ASSERT(0);\n\t\t}\n\t\tfree(buffer);\n\t}\n\n\tvoid testRangeComparison_RemoveBaseUri_Issue19() {\n\t\t// scheme\n\t\ttestRemoveBaseUriHelper(\"scheme://host/source\",\n\t\t\t\t\t\t\t\t\"scheme://host/source\",\n\t\t\t\t\t\t\t\t\"schemelonger://host/base\");\n\t\ttestRemoveBaseUriHelper(\"schemelonger://host/source\",\n\t\t\t\t\t\t\t\t\"schemelonger://host/source\",\n\t\t\t\t\t\t\t\t\"scheme://host/base\");\n\n\t\t// hostText\n\t\ttestRemoveBaseUriHelper(\"//host/source\",\n\t\t\t\t\t\t\t\t\"http://host/source\",\n\t\t\t\t\t\t\t\t\"http://hostlonger/base\");\n\t\ttestRemoveBaseUriHelper(\"//hostlonger/source\",\n\t\t\t\t\t\t\t\t\"http://hostlonger/source\",\n\t\t\t\t\t\t\t\t\"http://host/base\");\n\n\t\t// hostData.ipFuture\n\t\ttestRemoveBaseUriHelper(\"//[v7.host]/source\",\n\t\t\t\t\t\t\t\t\"http://[v7.host]/source\",\n\t\t\t\t\t\t\t\t\"http://[v7.hostlonger]/base\");\n\t\ttestRemoveBaseUriHelper(\"//[v7.hostlonger]/source\",\n\t\t\t\t\t\t\t\t\"http://[v7.hostlonger]/source\",\n\t\t\t\t\t\t\t\t\"http://host/base\");\n\n\t\t// path\n\t\ttestRemoveBaseUriHelper(\"path1\",\n\t\t\t\t\t\t\t\t\"http://host/path1\",\n\t\t\t\t\t\t\t\t\"http://host/path111\");\n\t\ttestRemoveBaseUriHelper(\"../path1/path2\",\n\t\t\t\t\t\t\t\t\"http://host/path1/path2\",\n\t\t\t\t\t\t\t\t\"http://host/path111/path222\");\n\t\ttestRemoveBaseUriHelper(\"path111\",\n\t\t\t\t\t\t\t\t\"http://host/path111\",\n\t\t\t\t\t\t\t\t\"http://host/path1\");\n\t\ttestRemoveBaseUriHelper(\"../path111/path222\",\n\t\t\t\t\t\t\t\t\"http://host/path111/path222\",\n\t\t\t\t\t\t\t\t\"http://host/path1/path2\");\n\n\t\t// Exact issue #19\n\t\ttestRemoveBaseUriHelper(\"//example/x/abc\",\n\t\t\t\t\t\t\t\t\"http://example/x/abc\",\n\t\t\t\t\t\t\t\t\"http://example2/x/y/z\");\n\t}\n};\n\n\nint main() {\n\tSuite suite;\n\tsuite.add(auto_ptr<Suite>(new UriSuite()));\n\tsuite.add(auto_ptr<Suite>(new FourSuite()));\n\tsuite.add(auto_ptr<Suite>(new VersionSuite()));\n\tTextOutput output(TextOutput::Verbose);\n\treturn suite.run(output, false) ? 0 : 1;\n}\n"], "filenames": ["src/UriQuery.c", "test/test.cpp"], "buggy_code_start_loc": [225, 106], "buggy_code_end_loc": [225, 1751], "fixing_code_start_loc": [226, 107], "fixing_code_end_loc": [227, 1784], "type": "CWE-787", "message": "An issue was discovered in uriparser before 0.9.0. UriQuery.c allows an out-of-bounds write via a uriComposeQuery* or uriComposeQueryEx* function because the '&' character is mishandled in certain contexts.", "other": {"cve": {"id": "CVE-2018-19198", "sourceIdentifier": "cve@mitre.org", "published": "2018-11-12T15:29:00.227", "lastModified": "2019-08-06T17:15:33.617", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An issue was discovered in uriparser before 0.9.0. UriQuery.c allows an out-of-bounds write via a uriComposeQuery* or uriComposeQueryEx* function because the '&' character is mishandled in certain contexts."}, {"lang": "es", "value": "Se ha descubierto un problema en versiones anteriores a la 0.9.0 de uriparser. UriQuery.c permite la escritura fuera de l\u00edmites mediante las funciones uriComposeQuery* o uriComposeQueryEx* debido a que el car\u00e1cter '' se gestiona de manera incorrecta en ciertos contextos."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:uriparser_project:uriparser:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.9.0", "matchCriteriaId": "2CDFDF1E-3FB8-4A74-875F-5F4857CE03E7"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "https://access.redhat.com/errata/RHSA-2019:2280", "source": "cve@mitre.org"}, {"url": "https://github.com/uriparser/uriparser/blob/uriparser-0.9.0/ChangeLog", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://github.com/uriparser/uriparser/commit/864f5d4c127def386dd5cc926ad96934b297f04e", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/11/msg00019.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/uriparser/uriparser/commit/864f5d4c127def386dd5cc926ad96934b297f04e"}}