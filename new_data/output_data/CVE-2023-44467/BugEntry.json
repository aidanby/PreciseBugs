{"buggy_code": ["\"\"\"Implements Program-Aided Language Models.\n\nThis module implements the Program-Aided Language Models (PAL) for generating code\nsolutions. PAL is a technique described in the paper \"Program-Aided Language Models\"\n(https://arxiv.org/pdf/2211.10435.pdf).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport ast\nfrom typing import Any, Dict, List, Optional\n\nfrom langchain.callbacks.manager import CallbackManagerForChainRun\nfrom langchain.chains.base import Chain\nfrom langchain.chains.llm import LLMChain\nfrom langchain.schema.language_model import BaseLanguageModel\nfrom langchain.utilities import PythonREPL\n\nfrom langchain_experimental.pal_chain.colored_object_prompt import COLORED_OBJECT_PROMPT\nfrom langchain_experimental.pal_chain.math_prompt import MATH_PROMPT\nfrom langchain_experimental.pydantic_v1 import Extra, Field\n\nCOMMAND_EXECUTION_FUNCTIONS = [\"system\", \"exec\", \"execfile\", \"eval\"]\n\n\nclass PALValidation:\n    SOLUTION_EXPRESSION_TYPE_FUNCTION = ast.FunctionDef\n    SOLUTION_EXPRESSION_TYPE_VARIABLE = ast.Name\n\n    def __init__(\n        self,\n        solution_expression_name: Optional[str] = None,\n        solution_expression_type: Optional[type] = None,\n        allow_imports: bool = False,\n        allow_command_exec: bool = False,\n    ):\n        \"\"\"Initialize a PALValidation instance.\n\n        Args:\n            solution_expression_name (str): Name of the expected solution expression.\n                If passed, solution_expression_type must be passed as well.\n            solution_expression_type (str): AST type of the expected solution\n                expression. If passed, solution_expression_name must be passed as well.\n                Must be one of PALValidation.SOLUTION_EXPRESSION_TYPE_FUNCTION,\n                PALValidation.SOLUTION_EXPRESSION_TYPE_VARIABLE.\n            allow_imports (bool): Allow import statements.\n            allow_command_exec (bool): Allow using known command execution functions.\n        \"\"\"\n        self.solution_expression_name = solution_expression_name\n        self.solution_expression_type = solution_expression_type\n\n        if solution_expression_name is not None:\n            if not isinstance(self.solution_expression_name, str):\n                raise ValueError(\n                    f\"Expected solution_expression_name to be str, \"\n                    f\"instead found {type(self.solution_expression_name)}\"\n                )\n        if solution_expression_type is not None:\n            if (\n                self.solution_expression_type\n                is not self.SOLUTION_EXPRESSION_TYPE_FUNCTION\n                and self.solution_expression_type\n                is not self.SOLUTION_EXPRESSION_TYPE_VARIABLE\n            ):\n                raise ValueError(\n                    f\"Expected solution_expression_type to be one of \"\n                    f\"({self.SOLUTION_EXPRESSION_TYPE_FUNCTION},\"\n                    f\"{self.SOLUTION_EXPRESSION_TYPE_VARIABLE}),\"\n                    f\"instead found {self.solution_expression_type}\"\n                )\n\n        if solution_expression_name is not None and solution_expression_type is None:\n            raise TypeError(\n                \"solution_expression_name \"\n                \"requires solution_expression_type to be passed as well\"\n            )\n        if solution_expression_name is None and solution_expression_type is not None:\n            raise TypeError(\n                \"solution_expression_type \"\n                \"requires solution_expression_name to be passed as well\"\n            )\n\n        self.allow_imports = allow_imports\n        self.allow_command_exec = allow_command_exec\n\n\nclass PALChain(Chain):\n    \"\"\"Implements Program-Aided Language Models (PAL).\n\n    This class implements the Program-Aided Language Models (PAL) for generating code\n    solutions. PAL is a technique described in the paper \"Program-Aided Language Models\"\n    (https://arxiv.org/pdf/2211.10435.pdf).\n\n    *Security note*: This class implements an AI technique that generates and evaluates\n        Python code, which can be dangerous and requires a specially sandboxed\n        environment to be safely used. While this class implements some basic guardrails\n        by limiting available locals/globals and by parsing and inspecting\n        the generated Python AST using `PALValidation`, those guardrails will not\n        deter sophisticated attackers and are not a replacement for a proper sandbox.\n        Do not use this class on untrusted inputs, with elevated permissions,\n        or without consulting your security team about proper sandboxing!\n    \"\"\"\n\n    llm_chain: LLMChain\n    stop: str = \"\\n\\n\"\n    \"\"\"Stop token to use when generating code.\"\"\"\n    get_answer_expr: str = \"print(solution())\"\n    \"\"\"Expression to use to get the answer from the generated code.\"\"\"\n    python_globals: Optional[Dict[str, Any]] = None\n    \"\"\"Python globals and locals to use when executing the generated code.\"\"\"\n    python_locals: Optional[Dict[str, Any]] = None\n    \"\"\"Python globals and locals to use when executing the generated code.\"\"\"\n    output_key: str = \"result\"  #: :meta private:\n    return_intermediate_steps: bool = False\n    \"\"\"Whether to return intermediate steps in the generated code.\"\"\"\n    code_validations: PALValidation = Field(default_factory=PALValidation)\n    \"\"\"Validations to perform on the generated code.\"\"\"\n    timeout: Optional[int] = 10\n    \"\"\"Timeout in seconds for the generated code to execute.\"\"\"\n\n    class Config:\n        \"\"\"Configuration for this pydantic object.\"\"\"\n\n        extra = Extra.forbid\n        arbitrary_types_allowed = True\n\n    @property\n    def input_keys(self) -> List[str]:\n        \"\"\"Return the singular input key.\n\n        :meta private:\n        \"\"\"\n        return self.llm_chain.prompt.input_variables\n\n    @property\n    def output_keys(self) -> List[str]:\n        \"\"\"Return the singular output key.\n\n        :meta private:\n        \"\"\"\n        if not self.return_intermediate_steps:\n            return [self.output_key]\n        else:\n            return [self.output_key, \"intermediate_steps\"]\n\n    def _call(\n        self,\n        inputs: Dict[str, Any],\n        run_manager: Optional[CallbackManagerForChainRun] = None,\n    ) -> Dict[str, str]:\n        _run_manager = run_manager or CallbackManagerForChainRun.get_noop_manager()\n        code = self.llm_chain.predict(\n            stop=[self.stop], callbacks=_run_manager.get_child(), **inputs\n        )\n        _run_manager.on_text(code, color=\"green\", end=\"\\n\", verbose=self.verbose)\n        PALChain.validate_code(code, self.code_validations)\n        repl = PythonREPL(_globals=self.python_globals, _locals=self.python_locals)\n        res = repl.run(code + f\"\\n{self.get_answer_expr}\", timeout=self.timeout)\n        output = {self.output_key: res.strip()}\n        if self.return_intermediate_steps:\n            output[\"intermediate_steps\"] = code\n        return output\n\n    @classmethod\n    def validate_code(cls, code: str, code_validations: PALValidation) -> None:\n        try:\n            code_tree = ast.parse(code)\n        except (SyntaxError, UnicodeDecodeError):\n            raise ValueError(f\"Generated code is not valid python code: {code}\")\n        except TypeError:\n            raise ValueError(\n                f\"Generated code is expected to be a string, \"\n                f\"instead found {type(code)}\"\n            )\n        except OverflowError:\n            raise ValueError(\n                f\"Generated code too long / complex to be parsed by ast: {code}\"\n            )\n\n        found_solution_expr = False\n        if code_validations.solution_expression_name is None:\n            # Skip validation if no solution_expression_name was given\n            found_solution_expr = True\n\n        has_imports = False\n        top_level_nodes = list(ast.iter_child_nodes(code_tree))\n        for node in top_level_nodes:\n            if (\n                code_validations.solution_expression_name is not None\n                and code_validations.solution_expression_type is not None\n            ):\n                # Check root nodes (like func def)\n                if (\n                    isinstance(node, code_validations.solution_expression_type)\n                    and hasattr(node, \"name\")\n                    and node.name == code_validations.solution_expression_name\n                ):\n                    found_solution_expr = True\n                # Check assigned nodes (like answer variable)\n                if isinstance(node, ast.Assign):\n                    for target_node in node.targets:\n                        if (\n                            isinstance(\n                                target_node, code_validations.solution_expression_type\n                            )\n                            and hasattr(target_node, \"id\")\n                            and target_node.id\n                            == code_validations.solution_expression_name\n                        ):\n                            found_solution_expr = True\n            if isinstance(node, ast.Import) or isinstance(node, ast.ImportFrom):\n                has_imports = True\n\n        if not found_solution_expr:\n            raise ValueError(\n                f\"Generated code is missing the solution expression: \"\n                f\"{code_validations.solution_expression_name} of type: \"\n                f\"{code_validations.solution_expression_type}\"\n            )\n\n        if not code_validations.allow_imports and has_imports:\n            raise ValueError(f\"Generated code has disallowed imports: {code}\")\n\n        if (\n            not code_validations.allow_command_exec\n            or not code_validations.allow_imports\n        ):\n            for node in ast.walk(code_tree):\n                if (\n                    (not code_validations.allow_command_exec)\n                    and isinstance(node, ast.Call)\n                    and (\n                        (\n                            hasattr(node.func, \"id\")\n                            and node.func.id in COMMAND_EXECUTION_FUNCTIONS\n                        )\n                        or (\n                            isinstance(node.func, ast.Attribute)\n                            and node.func.attr in COMMAND_EXECUTION_FUNCTIONS\n                        )\n                    )\n                ):\n                    raise ValueError(\n                        f\"Found illegal command execution function \"\n                        f\"{node.func.id} in code {code}\"\n                    )\n\n                if (not code_validations.allow_imports) and (\n                    isinstance(node, ast.Import) or isinstance(node, ast.ImportFrom)\n                ):\n                    raise ValueError(f\"Generated code has disallowed imports: {code}\")\n\n    @classmethod\n    def from_math_prompt(cls, llm: BaseLanguageModel, **kwargs: Any) -> PALChain:\n        \"\"\"Load PAL from math prompt.\n\n        Args:\n            llm (BaseLanguageModel): The language model to use for generating code.\n\n        Returns:\n            PALChain: An instance of PALChain.\n        \"\"\"\n        llm_chain = LLMChain(llm=llm, prompt=MATH_PROMPT)\n        code_validations = PALValidation(\n            solution_expression_name=\"solution\",\n            solution_expression_type=PALValidation.SOLUTION_EXPRESSION_TYPE_FUNCTION,\n        )\n\n        return cls(\n            llm_chain=llm_chain,\n            stop=\"\\n\\n\",\n            get_answer_expr=\"print(solution())\",\n            code_validations=code_validations,\n            **kwargs,\n        )\n\n    @classmethod\n    def from_colored_object_prompt(\n        cls, llm: BaseLanguageModel, **kwargs: Any\n    ) -> PALChain:\n        \"\"\"Load PAL from colored object prompt.\n\n        Args:\n            llm (BaseLanguageModel): The language model to use for generating code.\n\n        Returns:\n            PALChain: An instance of PALChain.\n        \"\"\"\n        llm_chain = LLMChain(llm=llm, prompt=COLORED_OBJECT_PROMPT)\n        code_validations = PALValidation(\n            solution_expression_name=\"answer\",\n            solution_expression_type=PALValidation.SOLUTION_EXPRESSION_TYPE_VARIABLE,\n        )\n        return cls(\n            llm_chain=llm_chain,\n            stop=\"\\n\\n\\n\",\n            get_answer_expr=\"print(answer)\",\n            code_validations=code_validations,\n            **kwargs,\n        )\n\n    @property\n    def _chain_type(self) -> str:\n        return \"pal_chain\"\n"], "fixing_code": ["\"\"\"Implements Program-Aided Language Models.\n\nThis module implements the Program-Aided Language Models (PAL) for generating code\nsolutions. PAL is a technique described in the paper \"Program-Aided Language Models\"\n(https://arxiv.org/pdf/2211.10435.pdf).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport ast\nfrom typing import Any, Dict, List, Optional\n\nfrom langchain.callbacks.manager import CallbackManagerForChainRun\nfrom langchain.chains.base import Chain\nfrom langchain.chains.llm import LLMChain\nfrom langchain.schema.language_model import BaseLanguageModel\nfrom langchain.utilities import PythonREPL\n\nfrom langchain_experimental.pal_chain.colored_object_prompt import COLORED_OBJECT_PROMPT\nfrom langchain_experimental.pal_chain.math_prompt import MATH_PROMPT\nfrom langchain_experimental.pydantic_v1 import Extra, Field\n\nCOMMAND_EXECUTION_FUNCTIONS = [\"system\", \"exec\", \"execfile\", \"eval\", \"__import__\"]\n\n\nclass PALValidation:\n    SOLUTION_EXPRESSION_TYPE_FUNCTION = ast.FunctionDef\n    SOLUTION_EXPRESSION_TYPE_VARIABLE = ast.Name\n\n    def __init__(\n        self,\n        solution_expression_name: Optional[str] = None,\n        solution_expression_type: Optional[type] = None,\n        allow_imports: bool = False,\n        allow_command_exec: bool = False,\n    ):\n        \"\"\"Initialize a PALValidation instance.\n\n        Args:\n            solution_expression_name (str): Name of the expected solution expression.\n                If passed, solution_expression_type must be passed as well.\n            solution_expression_type (str): AST type of the expected solution\n                expression. If passed, solution_expression_name must be passed as well.\n                Must be one of PALValidation.SOLUTION_EXPRESSION_TYPE_FUNCTION,\n                PALValidation.SOLUTION_EXPRESSION_TYPE_VARIABLE.\n            allow_imports (bool): Allow import statements.\n            allow_command_exec (bool): Allow using known command execution functions.\n        \"\"\"\n        self.solution_expression_name = solution_expression_name\n        self.solution_expression_type = solution_expression_type\n\n        if solution_expression_name is not None:\n            if not isinstance(self.solution_expression_name, str):\n                raise ValueError(\n                    f\"Expected solution_expression_name to be str, \"\n                    f\"instead found {type(self.solution_expression_name)}\"\n                )\n        if solution_expression_type is not None:\n            if (\n                self.solution_expression_type\n                is not self.SOLUTION_EXPRESSION_TYPE_FUNCTION\n                and self.solution_expression_type\n                is not self.SOLUTION_EXPRESSION_TYPE_VARIABLE\n            ):\n                raise ValueError(\n                    f\"Expected solution_expression_type to be one of \"\n                    f\"({self.SOLUTION_EXPRESSION_TYPE_FUNCTION},\"\n                    f\"{self.SOLUTION_EXPRESSION_TYPE_VARIABLE}),\"\n                    f\"instead found {self.solution_expression_type}\"\n                )\n\n        if solution_expression_name is not None and solution_expression_type is None:\n            raise TypeError(\n                \"solution_expression_name \"\n                \"requires solution_expression_type to be passed as well\"\n            )\n        if solution_expression_name is None and solution_expression_type is not None:\n            raise TypeError(\n                \"solution_expression_type \"\n                \"requires solution_expression_name to be passed as well\"\n            )\n\n        self.allow_imports = allow_imports\n        self.allow_command_exec = allow_command_exec\n\n\nclass PALChain(Chain):\n    \"\"\"Implements Program-Aided Language Models (PAL).\n\n    This class implements the Program-Aided Language Models (PAL) for generating code\n    solutions. PAL is a technique described in the paper \"Program-Aided Language Models\"\n    (https://arxiv.org/pdf/2211.10435.pdf).\n\n    *Security note*: This class implements an AI technique that generates and evaluates\n        Python code, which can be dangerous and requires a specially sandboxed\n        environment to be safely used. While this class implements some basic guardrails\n        by limiting available locals/globals and by parsing and inspecting\n        the generated Python AST using `PALValidation`, those guardrails will not\n        deter sophisticated attackers and are not a replacement for a proper sandbox.\n        Do not use this class on untrusted inputs, with elevated permissions,\n        or without consulting your security team about proper sandboxing!\n    \"\"\"\n\n    llm_chain: LLMChain\n    stop: str = \"\\n\\n\"\n    \"\"\"Stop token to use when generating code.\"\"\"\n    get_answer_expr: str = \"print(solution())\"\n    \"\"\"Expression to use to get the answer from the generated code.\"\"\"\n    python_globals: Optional[Dict[str, Any]] = None\n    \"\"\"Python globals and locals to use when executing the generated code.\"\"\"\n    python_locals: Optional[Dict[str, Any]] = None\n    \"\"\"Python globals and locals to use when executing the generated code.\"\"\"\n    output_key: str = \"result\"  #: :meta private:\n    return_intermediate_steps: bool = False\n    \"\"\"Whether to return intermediate steps in the generated code.\"\"\"\n    code_validations: PALValidation = Field(default_factory=PALValidation)\n    \"\"\"Validations to perform on the generated code.\"\"\"\n    timeout: Optional[int] = 10\n    \"\"\"Timeout in seconds for the generated code to execute.\"\"\"\n\n    class Config:\n        \"\"\"Configuration for this pydantic object.\"\"\"\n\n        extra = Extra.forbid\n        arbitrary_types_allowed = True\n\n    @property\n    def input_keys(self) -> List[str]:\n        \"\"\"Return the singular input key.\n\n        :meta private:\n        \"\"\"\n        return self.llm_chain.prompt.input_variables\n\n    @property\n    def output_keys(self) -> List[str]:\n        \"\"\"Return the singular output key.\n\n        :meta private:\n        \"\"\"\n        if not self.return_intermediate_steps:\n            return [self.output_key]\n        else:\n            return [self.output_key, \"intermediate_steps\"]\n\n    def _call(\n        self,\n        inputs: Dict[str, Any],\n        run_manager: Optional[CallbackManagerForChainRun] = None,\n    ) -> Dict[str, str]:\n        _run_manager = run_manager or CallbackManagerForChainRun.get_noop_manager()\n        code = self.llm_chain.predict(\n            stop=[self.stop], callbacks=_run_manager.get_child(), **inputs\n        )\n        _run_manager.on_text(code, color=\"green\", end=\"\\n\", verbose=self.verbose)\n        PALChain.validate_code(code, self.code_validations)\n        repl = PythonREPL(_globals=self.python_globals, _locals=self.python_locals)\n        res = repl.run(code + f\"\\n{self.get_answer_expr}\", timeout=self.timeout)\n        output = {self.output_key: res.strip()}\n        if self.return_intermediate_steps:\n            output[\"intermediate_steps\"] = code\n        return output\n\n    @classmethod\n    def validate_code(cls, code: str, code_validations: PALValidation) -> None:\n        try:\n            code_tree = ast.parse(code)\n        except (SyntaxError, UnicodeDecodeError):\n            raise ValueError(f\"Generated code is not valid python code: {code}\")\n        except TypeError:\n            raise ValueError(\n                f\"Generated code is expected to be a string, \"\n                f\"instead found {type(code)}\"\n            )\n        except OverflowError:\n            raise ValueError(\n                f\"Generated code too long / complex to be parsed by ast: {code}\"\n            )\n\n        found_solution_expr = False\n        if code_validations.solution_expression_name is None:\n            # Skip validation if no solution_expression_name was given\n            found_solution_expr = True\n\n        has_imports = False\n        top_level_nodes = list(ast.iter_child_nodes(code_tree))\n        for node in top_level_nodes:\n            if (\n                code_validations.solution_expression_name is not None\n                and code_validations.solution_expression_type is not None\n            ):\n                # Check root nodes (like func def)\n                if (\n                    isinstance(node, code_validations.solution_expression_type)\n                    and hasattr(node, \"name\")\n                    and node.name == code_validations.solution_expression_name\n                ):\n                    found_solution_expr = True\n                # Check assigned nodes (like answer variable)\n                if isinstance(node, ast.Assign):\n                    for target_node in node.targets:\n                        if (\n                            isinstance(\n                                target_node, code_validations.solution_expression_type\n                            )\n                            and hasattr(target_node, \"id\")\n                            and target_node.id\n                            == code_validations.solution_expression_name\n                        ):\n                            found_solution_expr = True\n            if isinstance(node, ast.Import) or isinstance(node, ast.ImportFrom):\n                has_imports = True\n\n        if not found_solution_expr:\n            raise ValueError(\n                f\"Generated code is missing the solution expression: \"\n                f\"{code_validations.solution_expression_name} of type: \"\n                f\"{code_validations.solution_expression_type}\"\n            )\n\n        if not code_validations.allow_imports and has_imports:\n            raise ValueError(f\"Generated code has disallowed imports: {code}\")\n\n        if (\n            not code_validations.allow_command_exec\n            or not code_validations.allow_imports\n        ):\n            for node in ast.walk(code_tree):\n                if (\n                    (not code_validations.allow_command_exec)\n                    and isinstance(node, ast.Call)\n                    and (\n                        (\n                            hasattr(node.func, \"id\")\n                            and node.func.id in COMMAND_EXECUTION_FUNCTIONS\n                        )\n                        or (\n                            isinstance(node.func, ast.Attribute)\n                            and node.func.attr in COMMAND_EXECUTION_FUNCTIONS\n                        )\n                    )\n                ):\n                    raise ValueError(\n                        f\"Found illegal command execution function \"\n                        f\"{node.func.id} in code {code}\"\n                    )\n\n                if (not code_validations.allow_imports) and (\n                    isinstance(node, ast.Import) or isinstance(node, ast.ImportFrom)\n                ):\n                    raise ValueError(f\"Generated code has disallowed imports: {code}\")\n\n    @classmethod\n    def from_math_prompt(cls, llm: BaseLanguageModel, **kwargs: Any) -> PALChain:\n        \"\"\"Load PAL from math prompt.\n\n        Args:\n            llm (BaseLanguageModel): The language model to use for generating code.\n\n        Returns:\n            PALChain: An instance of PALChain.\n        \"\"\"\n        llm_chain = LLMChain(llm=llm, prompt=MATH_PROMPT)\n        code_validations = PALValidation(\n            solution_expression_name=\"solution\",\n            solution_expression_type=PALValidation.SOLUTION_EXPRESSION_TYPE_FUNCTION,\n        )\n\n        return cls(\n            llm_chain=llm_chain,\n            stop=\"\\n\\n\",\n            get_answer_expr=\"print(solution())\",\n            code_validations=code_validations,\n            **kwargs,\n        )\n\n    @classmethod\n    def from_colored_object_prompt(\n        cls, llm: BaseLanguageModel, **kwargs: Any\n    ) -> PALChain:\n        \"\"\"Load PAL from colored object prompt.\n\n        Args:\n            llm (BaseLanguageModel): The language model to use for generating code.\n\n        Returns:\n            PALChain: An instance of PALChain.\n        \"\"\"\n        llm_chain = LLMChain(llm=llm, prompt=COLORED_OBJECT_PROMPT)\n        code_validations = PALValidation(\n            solution_expression_name=\"answer\",\n            solution_expression_type=PALValidation.SOLUTION_EXPRESSION_TYPE_VARIABLE,\n        )\n        return cls(\n            llm_chain=llm_chain,\n            stop=\"\\n\\n\\n\",\n            get_answer_expr=\"print(answer)\",\n            code_validations=code_validations,\n            **kwargs,\n        )\n\n    @property\n    def _chain_type(self) -> str:\n        return \"pal_chain\"\n"], "filenames": ["libs/experimental/langchain_experimental/pal_chain/base.py"], "buggy_code_start_loc": [23], "buggy_code_end_loc": [24], "fixing_code_start_loc": [23], "fixing_code_end_loc": [24], "type": "NVD-CWE-noinfo", "message": "langchain_experimental (aka LangChain Experimental) in LangChain before 0.0.306 allows an attacker to bypass the CVE-2023-36258 fix and execute arbitrary code via __import__ in Python code, which is not prohibited by pal_chain/base.py.", "other": {"cve": {"id": "CVE-2023-44467", "sourceIdentifier": "cve@mitre.org", "published": "2023-10-09T20:15:10.480", "lastModified": "2024-02-26T16:27:47.113", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "langchain_experimental (aka LangChain Experimental) in LangChain before 0.0.306 allows an attacker to bypass the CVE-2023-36258 fix and execute arbitrary code via __import__ in Python code, which is not prohibited by pal_chain/base.py."}, {"lang": "es", "value": "langchain_experimental 0.0.14 permite a un atacante omitir la correcci\u00f3n CVE-2023-36258 y ejecutar c\u00f3digo arbitrario a trav\u00e9s de PALChain en el m\u00e9todo python exec."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:langchain:langchain_experimental:0.0.14:*:*:*:*:python:*:*", "matchCriteriaId": "6E2A46AF-C374-4305-BCF3-A1DFFBB080F9"}]}]}], "references": [{"url": "https://github.com/langchain-ai/langchain/commit/4c97a10bd0d9385cfee234a63b5bd826a295e483", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/langchain-ai/langchain/commit/4c97a10bd0d9385cfee234a63b5bd826a295e483"}}