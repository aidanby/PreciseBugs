{"buggy_code": ["/*====================================================================*\n -  Copyright (C) 2001 Leptonica.  All rights reserved.\n -\n -  Redistribution and use in source and binary forms, with or without\n -  modification, are permitted provided that the following conditions\n -  are met:\n -  1. Redistributions of source code must retain the above copyright\n -     notice, this list of conditions and the following disclaimer.\n -  2. Redistributions in binary form must reproduce the above\n -     copyright notice, this list of conditions and the following\n -     disclaimer in the documentation and/or other materials\n -     provided with the distribution.\n -\n -  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n -  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n -  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n -  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ANY\n -  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n -  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n -  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n -  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n -  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n -  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n -  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *====================================================================*/\n\n/*\n * adaptmap_reg.c\n *\n *   Regression test demonstrating adaptive mappings in both gray and color\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config_auto.h>\n#endif  /* HAVE_CONFIG_H */\n\n#include \"allheaders.h\"\n\n   /* Location of image region in wet-day.jpg */\nstatic const l_int32  XS = 151;\nstatic const l_int32  YS = 225;\nstatic const l_int32  WS = 913;\nstatic const l_int32  HS = 1285;\n\nstatic const l_int32  SIZE_X = 10;\nstatic const l_int32  SIZE_Y = 30;\nstatic const l_int32  BINTHRESH = 50;\nstatic const l_int32  MINCOUNT = 30;\n\nstatic const l_int32  BGVAL = 200;\nstatic const l_int32  SMOOTH_X = 2;\nstatic const l_int32  SMOOTH_Y = 1;\n\nint main(int    argc,\n         char **argv)\n{\nl_int32       w, h;\nPIX          *pixs, *pixg, *pixim, *pixgm, *pixmi, *pix1, *pix2;\nPIX          *pixmr, *pixmg, *pixmb, *pixmri, *pixmgi, *pixmbi;\nPIXA         *pixa;\nL_REGPARAMS  *rp;\n\n    if (regTestSetup(argc, argv, &rp))\n        return 1;\n\n    lept_mkdir(\"lept/adapt\");  // REMOVE?\n\n    pixs = pixRead(\"wet-day.jpg\");\n    pixa = pixaCreate(0);\n    pixg = pixConvertRGBToGray(pixs, 0.33, 0.34, 0.33);\n    pixaAddPix(pixa, pixs, L_INSERT);\n    pixaAddPix(pixa, pixg, L_INSERT);\n    pixGetDimensions(pixs, &w, &h, NULL);\n\n        /* Process in grayscale */\n    startTimer();\n    pixim = pixCreate(w, h, 1);\n    pixRasterop(pixim, XS, YS, WS, HS, PIX_SET, NULL, 0, 0);\n    pixGetBackgroundGrayMap(pixg, pixim, SIZE_X, SIZE_Y,\n                            BINTHRESH, MINCOUNT, &pixgm);\n    fprintf(stderr, \"Time for gray adaptmap gen: %7.3f\\n\", stopTimer());\n    regTestWritePixAndCheck(rp, pixgm, IFF_PNG);  /* 0 */\n    pixaAddPix(pixa, pixgm, L_INSERT);\n\n    startTimer();\n    pixmi = pixGetInvBackgroundMap(pixgm, BGVAL, SMOOTH_X, SMOOTH_Y);\n    fprintf(stderr, \"Time for gray inv map generation: %7.3f\\n\", stopTimer());\n    regTestWritePixAndCheck(rp, pixmi, IFF_PNG);  /* 1 */\n    pixaAddPix(pixa, pixmi, L_INSERT);\n\n    startTimer();\n    pix1 = pixApplyInvBackgroundGrayMap(pixg, pixmi, SIZE_X, SIZE_Y);\n    fprintf(stderr, \"Time to apply gray inv map: %7.3f\\n\", stopTimer());\n    regTestWritePixAndCheck(rp, pix1, IFF_JFIF_JPEG);  /* 2 */\n    pixaAddPix(pixa, pix1, L_INSERT);\n\n    pix2 = pixGammaTRCMasked(NULL, pix1, pixim, 1.0, 0, 190);\n    pixInvert(pixim, pixim);\n    pixGammaTRCMasked(pix2, pix2, pixim, 1.0, 60, 190);\n    regTestWritePixAndCheck(rp, pix2, IFF_JFIF_JPEG);  /* 3 */\n    pixaAddPix(pixa, pix2, L_INSERT);\n    pixDestroy(&pixim);\n\n        /* Process in color */\n    startTimer();\n    pixim = pixCreate(w, h, 1);\n    pixRasterop(pixim, XS, YS, WS, HS, PIX_SET, NULL, 0, 0);\n    pixGetBackgroundRGBMap(pixs, pixim, NULL, SIZE_X, SIZE_Y,\n                           BINTHRESH, MINCOUNT,\n                           &pixmr, &pixmg, &pixmb);\n    fprintf(stderr, \"Time for color adaptmap gen: %7.3f\\n\", stopTimer());\n    regTestWritePixAndCheck(rp, pixmr, IFF_PNG);  /* 4 */\n    regTestWritePixAndCheck(rp, pixmg, IFF_PNG);  /* 5 */\n    regTestWritePixAndCheck(rp, pixmb, IFF_PNG);  /* 6 */\n    pixaAddPix(pixa, pixmr, L_INSERT);\n    pixaAddPix(pixa, pixmg, L_INSERT);\n    pixaAddPix(pixa, pixmb, L_INSERT);\n\n    startTimer();\n    pixmri = pixGetInvBackgroundMap(pixmr, BGVAL, SMOOTH_X, SMOOTH_Y);\n    pixmgi = pixGetInvBackgroundMap(pixmg, BGVAL, SMOOTH_X, SMOOTH_Y);\n    pixmbi = pixGetInvBackgroundMap(pixmb, BGVAL, SMOOTH_X, SMOOTH_Y);\n    fprintf(stderr, \"Time for color inv map generation: %7.3f\\n\", stopTimer());\n    regTestWritePixAndCheck(rp, pixmri, IFF_PNG);  /* 7 */\n    regTestWritePixAndCheck(rp, pixmgi, IFF_PNG);  /* 8 */\n    regTestWritePixAndCheck(rp, pixmbi, IFF_PNG);  /* 9 */\n    pixaAddPix(pixa, pixmri, L_INSERT);\n    pixaAddPix(pixa, pixmgi, L_INSERT);\n    pixaAddPix(pixa, pixmbi, L_INSERT);\n\n    startTimer();\n    pix1 = pixApplyInvBackgroundRGBMap(pixs, pixmri, pixmgi, pixmbi,\n                                       SIZE_X, SIZE_Y);\n    fprintf(stderr, \"Time to apply color inv maps: %7.3f\\n\", stopTimer());\n    regTestWritePixAndCheck(rp, pix1, IFF_JFIF_JPEG);  /* 10 */\n    pixaAddPix(pixa, pix1, L_INSERT);\n\n    pix2 = pixGammaTRCMasked(NULL, pix1, pixim, 1.0, 0, 190);\n    pixInvert(pixim, pixim);\n    pixGammaTRCMasked(pix2, pix2, pixim, 1.0, 60, 190);\n    regTestWritePixAndCheck(rp, pix2, IFF_JFIF_JPEG);  /* 11 */\n    pixaAddPix(pixa, pix2, L_INSERT);\n    pixDestroy(&pixim);\n\n        /* Process at higher level in color */\n    startTimer();\n    pixim = pixCreate(w, h, 1);\n    pixRasterop(pixim, XS, YS, WS, HS, PIX_SET, NULL, 0, 0);\n    pix1 = pixBackgroundNorm(pixs, pixim, NULL, 5, 10, BINTHRESH, 20,\n                             BGVAL, SMOOTH_X, SMOOTH_Y);\n    fprintf(stderr, \"Time for bg normalization: %7.3f\\n\", stopTimer());\n    regTestWritePixAndCheck(rp, pix1, IFF_JFIF_JPEG);  /* 12 */\n    pixaAddPix(pixa, pix1, L_INSERT);\n\n    pix2 = pixGammaTRCMasked(NULL, pix1, pixim, 1.0, 0, 190);\n    pixInvert(pixim, pixim);\n    pixGammaTRCMasked(pix2, pix2, pixim, 1.0, 60, 190);\n    regTestWritePixAndCheck(rp, pix2, IFF_JFIF_JPEG);  /* 13 */\n    pixaAddPix(pixa, pix2, L_INSERT);\n    pixDestroy(&pixim);\n\n        /* Display results */\n    pix1 = pixaDisplayTiledAndScaled(pixa, 32, 400, 4, 0, 20, 2);\n    pixWrite(\"/tmp/lept/adapt/results.jpg\", pix1, IFF_JFIF_JPEG);\n    pixDisplayWithTitle(pix1, 100, 0, NULL, rp->display);\n    pixDestroy(&pix1);\n    pixaDestroy(&pixa);\n\n    return regTestCleanup(rp);\n}\n\n", "/*====================================================================*\n -  Copyright (C) 2001 Leptonica.  All rights reserved.\n -\n -  Redistribution and use in source and binary forms, with or without\n -  modification, are permitted provided that the following conditions\n -  are met:\n -  1. Redistributions of source code must retain the above copyright\n -     notice, this list of conditions and the following disclaimer.\n -  2. Redistributions in binary form must reproduce the above\n -     copyright notice, this list of conditions and the following\n -     disclaimer in the documentation and/or other materials\n -     provided with the distribution.\n -\n -  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n -  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n -  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n -  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ANY\n -  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n -  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n -  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n -  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n -  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n -  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n -  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *====================================================================*/\n\n/*!\n * \\file adaptmap.c\n * <pre>\n *\n *  -------------------------------------------------------------------\n *\n *  Image binarization algorithms are found in:\n *     grayquant.c:   standard, simple, general grayscale quantization\n *     adaptmap.c:    local adaptive; mostly gray-to-gray in preparation\n *                    for binarization\n *     binarize.c:    special binarization methods, locally adaptive.\n *\n *  -------------------------------------------------------------------\n *\n *      Clean background to white using background normalization\n *          PIX       *pixCleanBackgroundToWhite()\n *\n *      Adaptive background normalization (top-level functions)\n *          PIX       *pixBackgroundNormSimple()     8 and 32 bpp\n *          PIX       *pixBackgroundNorm()           8 and 32 bpp\n *          PIX       *pixBackgroundNormMorph()      8 and 32 bpp\n *\n *      Arrays of inverted background values for normalization (16 bpp)\n *          l_int32    pixBackgroundNormGrayArray()   8 bpp input\n *          l_int32    pixBackgroundNormRGBArrays()   32 bpp input\n *          l_int32    pixBackgroundNormGrayArrayMorph()   8 bpp input\n *          l_int32    pixBackgroundNormRGBArraysMorph()   32 bpp input\n *\n *      Measurement of local background\n *          l_int32    pixGetBackgroundGrayMap()        8 bpp\n *          l_int32    pixGetBackgroundRGBMap()         32 bpp\n *          l_int32    pixGetBackgroundGrayMapMorph()   8 bpp\n *          l_int32    pixGetBackgroundRGBMapMorph()    32 bpp\n *          l_int32    pixFillMapHoles()\n *          PIX       *pixExtendByReplication()         8 bpp\n *          l_int32    pixSmoothConnectedRegions()      8 bpp\n *\n *      Measurement of local foreground\n *          l_int32    pixGetForegroundGrayMap()        8 bpp\n *\n *      Generate inverted background map for each component\n *          PIX       *pixGetInvBackgroundMap()   16 bpp\n *\n *      Apply inverse background map to image\n *          PIX       *pixApplyInvBackgroundGrayMap()   8 bpp\n *          PIX       *pixApplyInvBackgroundRGBMap()    32 bpp\n *\n *      Apply variable map\n *          PIX       *pixApplyVariableGrayMap()        8 bpp\n *\n *      Non-adaptive (global) mapping\n *          PIX       *pixGlobalNormRGB()               32 bpp or cmapped\n *          PIX       *pixGlobalNormNoSatRGB()          32 bpp\n *\n *      Adaptive threshold spread normalization\n *          l_int32    pixThresholdSpreadNorm()         8 bpp\n *\n *      Adaptive background normalization (flexible adaptaption)\n *          PIX       *pixBackgroundNormFlex()          8 bpp\n *\n *      Adaptive contrast normalization\n *          PIX             *pixContrastNorm()          8 bpp\n *          l_int32          pixMinMaxTiles()\n *          l_int32          pixSetLowContrast()\n *          PIX             *pixLinearTRCTiled()\n *          static l_int32  *iaaGetLinearTRC()\n *\n *  Background normalization is done by generating a reduced map (or set\n *  of maps) representing the estimated background value of the\n *  input image, and using this to shift the pixel values so that\n *  this background value is set to some constant value.\n *\n *  Specifically, normalization has 3 steps:\n *    (1) Generate a background map at a reduced scale.\n *    (2) Make the array of inverted background values by inverting\n *        the map.  The result is an array of local multiplicative factors.\n *    (3) Apply this inverse background map to the image\n *\n *  The inverse background arrays can be generated in two different ways here:\n *    (1) Remove the 'foreground' pixels and average over the remaining\n *        pixels in each tile.  Propagate values into tiles where\n *        values have not been assigned, either because there was not\n *        enough background in the tile or because the tile is covered\n *        by a foreground region described by an image mask.\n *        After the background map is made, the inverse map is generated by\n *        smoothing over some number of adjacent tiles\n *        (block convolution) and then inverting.\n *    (2) Remove the foreground pixels using a morphological closing\n *        on a subsampled version of the image.  Propagate values\n *        into pixels covered by an optional image mask.  Invert the\n *        background map without preconditioning by convolutional smoothing.\n *\n *  Other methods for adaptively normalizing the image are also given here.\n *\n *  (1) pixThresholdSpreadNorm() computes a local threshold over the image\n *      and normalizes the input pixel values so that this computed threshold\n *      is a constant across the entire image.\n *\n *  (2) pixContrastNorm() computes and applies a local TRC so that the\n *      local dynamic range is expanded to the full 8 bits, where the\n *      darkest pixels are mapped to 0 and the lightest to 255.  This is\n *      useful for improving the appearance of pages with very light\n *      foreground or very dark background, and where the local TRC\n *      function doesn't change rapidly with position.\n * </pre>\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config_auto.h>\n#endif  /* HAVE_CONFIG_H */\n\n#include \"allheaders.h\"\n\n    /* Default input parameters for pixBackgroundNormSimple()\n     * Notes:\n     *    (1) mincount must never exceed the tile area (width * height)\n     *    (2) bgval must be sufficiently below 255 to avoid accidental\n     *        saturation; otherwise it should be large to avoid\n     *        shrinking the dynamic range\n     *    (3) results should otherwise not be sensitive to these values\n     */\nstatic const l_int32  DefaultTileWidth = 10;    /*!< default tile width    */\nstatic const l_int32  DefaultTileHeight = 15;   /*!< default tile height   */\nstatic const l_int32  DefaultFgThreshold = 60;  /*!< default fg threshold  */\nstatic const l_int32  DefaultMinCount = 40;     /*!< default minimum count */\nstatic const l_int32  DefaultBgVal = 200;       /*!< default bg value      */\nstatic const l_int32  DefaultXSmoothSize = 2;  /*!< default x smooth size */\nstatic const l_int32  DefaultYSmoothSize = 1;  /*!< default y smooth size */\n\nstatic l_int32 *iaaGetLinearTRC(l_int32 **iaa, l_int32 diff);\n\n#ifndef  NO_CONSOLE_IO\n#define  DEBUG_GLOBAL    0    /*!< set to 1 to debug pixGlobalNormNoSatRGB() */\n#endif  /* ~NO_CONSOLE_IO */\n\n/*------------------------------------------------------------------*\n *      Clean background to white using background normalization    *\n *------------------------------------------------------------------*/\n/*!\n * \\brief   pixCleanBackgroundToWhite()\n *\n * \\param[in]    pixs       8 bpp grayscale or 32 bpp rgb\n * \\param[in]    pixim      [optional] 1 bpp 'image' mask; can be null\n * \\param[in]    pixg       [optional] 8 bpp grayscale version; can be null\n * \\param[in]    gamma      gamma correction; must be > 0.0; typically ~1.0\n * \\param[in]    blackval   dark value to set to black (0)\n * \\param[in]    whiteval   light value to set to white (255)\n * \\return  pixd 8 bpp or 32 bpp rgb, or NULL on error\n *\n * <pre>\n * Notes:\n *    (1) This is a simplified interface for cleaning an image.\n *        For comparison, see pixAdaptThresholdToBinaryGen().\n *    (2) The suggested default values for the input parameters are:\n *          gamma:    1.0  (reduce this to increase the contrast; e.g.,\n *                          for light text)\n *          blackval   70  (a bit more than 60)\n *          whiteval  190  (a bit less than 200)\n * </pre>\n */\nPIX *\npixCleanBackgroundToWhite(PIX       *pixs,\n                          PIX       *pixim,\n                          PIX       *pixg,\n                          l_float32  gamma,\n                          l_int32    blackval,\n                          l_int32    whiteval)\n{\nl_int32  d;\nPIX     *pixd;\n\n    PROCNAME(\"pixCleanBackgroundToWhite\");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    d = pixGetDepth(pixs);\n    if (d != 8 && d != 32)\n        return (PIX *)ERROR_PTR(\"depth not 8 or 32\", procName, NULL);\n\n    pixd = pixBackgroundNormSimple(pixs, pixim, pixg);\n    if (!pixd)\n        return (PIX *)ERROR_PTR(\"background norm failedd\", procName, NULL);\n    pixGammaTRC(pixd, pixd, gamma, blackval, whiteval);\n    return pixd;\n}\n\n\n/*------------------------------------------------------------------*\n *                Adaptive background normalization                 *\n *------------------------------------------------------------------*/\n/*!\n * \\brief   pixBackgroundNormSimple()\n *\n * \\param[in]    pixs     8 bpp grayscale or 32 bpp rgb\n * \\param[in]    pixim    [optional] 1 bpp 'image' mask; can be null\n * \\param[in]    pixg     [optional] 8 bpp grayscale version; can be null\n * \\return  pixd 8 bpp or 32 bpp rgb, or NULL on error\n *\n * <pre>\n * Notes:\n *    (1) This is a simplified interface to pixBackgroundNorm(),\n *        where seven parameters are defaulted.\n *    (2) The input image is either grayscale or rgb.\n *    (3) See pixBackgroundNorm() for usage and function.\n * </pre>\n */\nPIX *\npixBackgroundNormSimple(PIX  *pixs,\n                        PIX  *pixim,\n                        PIX  *pixg)\n{\n    return pixBackgroundNorm(pixs, pixim, pixg,\n                             DefaultTileWidth, DefaultTileHeight,\n                             DefaultFgThreshold, DefaultMinCount,\n                             DefaultBgVal, DefaultXSmoothSize,\n                             DefaultYSmoothSize);\n}\n\n\n/*!\n * \\brief   pixBackgroundNorm()\n *\n * \\param[in]    pixs        8 bpp grayscale or 32 bpp rgb\n * \\param[in]    pixim       [optional] 1 bpp 'image' mask; can be null\n * \\param[in]    pixg        [optional] 8 bpp grayscale version; can be null\n * \\param[in]    sx, sy      tile size in pixels\n * \\param[in]    thresh      threshold for determining foreground\n * \\param[in]    mincount    min threshold on counts in a tile\n * \\param[in]    bgval       target bg val; typ. > 128\n * \\param[in]    smoothx     half-width of block convolution kernel width\n * \\param[in]    smoothy     half-width of block convolution kernel height\n * \\return  pixd 8 bpp or 32 bpp rgb, or NULL on error\n *\n * <pre>\n * Notes:\n *    (1) This is a top-level interface for normalizing the image intensity\n *        by mapping the image so that the background is near the input\n *        value 'bgval'.\n *    (2) The input image is either grayscale or rgb.\n *    (3) For each component in the input image, the background value\n *        in each tile is estimated using the values in the tile that\n *        are not part of the foreground, where the foreground is\n *        determined by the input 'thresh' argument.\n *    (4) An optional binary mask can be specified, with the foreground\n *        pixels typically over image regions.  The resulting background\n *        map values will be determined by surrounding pixels that are\n *        not under the mask foreground.  The origin (0,0) of this mask\n *        is assumed to be aligned with the origin of the input image.\n *        This binary mask must not fully cover pixs, because then there\n *        will be no pixels in the input image available to compute\n *        the background.\n *    (5) An optional grayscale version of the input pixs can be supplied.\n *        The only reason to do this is if the input is RGB and this\n *        grayscale version can be used elsewhere.  If the input is RGB\n *        and this is not supplied, it is made internally using only\n *        the green component, and destroyed after use.\n *    (6) The dimensions of the pixel tile (sx, sy) give the amount by\n *        by which the map is reduced in size from the input image.\n *    (7) The threshold is used to binarize the input image, in order to\n *        locate the foreground components.  If this is set too low,\n *        some actual foreground may be used to determine the maps;\n *        if set too high, there may not be enough background\n *        to determine the map values accurately.  Typically, it's\n *        better to err by setting the threshold too high.\n *    (8) A 'mincount' threshold is a minimum count of pixels in a\n *        tile for which a background reading is made, in order for that\n *        pixel in the map to be valid.  This number should perhaps be\n *        at least 1/3 the size of the tile.\n *    (9) A 'bgval' target background value for the normalized image.  This\n *        should be at least 128.  If set too close to 255, some\n *        clipping will occur in the result.\n *    (10) Two factors, 'smoothx' and 'smoothy', are input for smoothing\n *        the map.  Each low-pass filter kernel dimension is\n *        is 2 * (smoothing factor) + 1, so a\n *        value of 0 means no smoothing. A value of 1 or 2 is recommended.\n * </pre>\n */\nPIX *\npixBackgroundNorm(PIX     *pixs,\n                  PIX     *pixim,\n                  PIX     *pixg,\n                  l_int32  sx,\n                  l_int32  sy,\n                  l_int32  thresh,\n                  l_int32  mincount,\n                  l_int32  bgval,\n                  l_int32  smoothx,\n                  l_int32  smoothy)\n{\nl_int32  d, allfg;\nPIX     *pixm, *pixmi, *pixd;\nPIX     *pixmr, *pixmg, *pixmb, *pixmri, *pixmgi, *pixmbi;\n\n    PROCNAME(\"pixBackgroundNorm\");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    d = pixGetDepth(pixs);\n    if (d != 8 && d != 32)\n        return (PIX *)ERROR_PTR(\"pixs not 8 or 32 bpp\", procName, NULL);\n    if (sx < 4 || sy < 4)\n        return (PIX *)ERROR_PTR(\"sx and sy must be >= 4\", procName, NULL);\n    if (mincount > sx * sy) {\n        L_WARNING(\"mincount too large for tile size\\n\", procName);\n        mincount = (sx * sy) / 3;\n    }\n\n        /* If pixim exists, verify that it is not all foreground. */\n    if (pixim) {\n        pixInvert(pixim, pixim);\n        pixZero(pixim, &allfg);\n        pixInvert(pixim, pixim);\n        if (allfg)\n            return (PIX *)ERROR_PTR(\"pixim all foreground\", procName, NULL);\n    }\n\n    pixd = NULL;\n    if (d == 8) {\n        pixm = NULL;\n        pixGetBackgroundGrayMap(pixs, pixim, sx, sy, thresh, mincount, &pixm);\n        if (!pixm) {\n            L_WARNING(\"map not made; return a copy of the source\\n\", procName);\n            return pixCopy(NULL, pixs);\n        }\n\n        pixmi = pixGetInvBackgroundMap(pixm, bgval, smoothx, smoothy);\n        if (!pixmi) {\n            L_WARNING(\"pixmi not made; return a copy of source\\n\", procName);\n            pixDestroy(&pixm);\n            return pixCopy(NULL, pixs);\n        } else {\n            pixd = pixApplyInvBackgroundGrayMap(pixs, pixmi, sx, sy);\n        }\n\n        pixDestroy(&pixm);\n        pixDestroy(&pixmi);\n    }\n    else {\n        pixmr = pixmg = pixmb = NULL;\n        pixGetBackgroundRGBMap(pixs, pixim, pixg, sx, sy, thresh,\n                               mincount, &pixmr, &pixmg, &pixmb);\n        if (!pixmr || !pixmg || !pixmb) {\n            pixDestroy(&pixmr);\n            pixDestroy(&pixmg);\n            pixDestroy(&pixmb);\n            L_WARNING(\"map not made; return a copy of the source\\n\", procName);\n            return pixCopy(NULL, pixs);\n        }\n\n        pixmri = pixGetInvBackgroundMap(pixmr, bgval, smoothx, smoothy);\n        pixmgi = pixGetInvBackgroundMap(pixmg, bgval, smoothx, smoothy);\n        pixmbi = pixGetInvBackgroundMap(pixmb, bgval, smoothx, smoothy);\n        if (!pixmri || !pixmgi || !pixmbi) {\n            L_WARNING(\"not all pixm*i are made; return src copy\\n\", procName);\n            pixd = pixCopy(NULL, pixs);\n        } else {\n            pixd = pixApplyInvBackgroundRGBMap(pixs, pixmri, pixmgi, pixmbi,\n                                               sx, sy);\n        }\n\n        pixDestroy(&pixmr);\n        pixDestroy(&pixmg);\n        pixDestroy(&pixmb);\n        pixDestroy(&pixmri);\n        pixDestroy(&pixmgi);\n        pixDestroy(&pixmbi);\n    }\n\n    if (!pixd)\n        ERROR_PTR(\"pixd not made\", procName, NULL);\n    pixCopyResolution(pixd, pixs);\n    return pixd;\n}\n\n\n/*!\n * \\brief   pixBackgroundNormMorph()\n *\n * \\param[in]    pixs        8 bpp grayscale or 32 bpp rgb\n * \\param[in]    pixim       [optional] 1 bpp 'image' mask; can be null\n * \\param[in]    reduction   at which morph closings are done; between 2 and 16\n * \\param[in]    size        of square Sel for the closing; use an odd number\n * \\param[in]    bgval       target bg val; typ. > 128\n * \\return  pixd 8 bpp, or NULL on error\n *\n * <pre>\n * Notes:\n *    (1) This is a top-level interface for normalizing the image intensity\n *        by mapping the image so that the background is near the input\n *        value 'bgval'.\n *    (2) The input image is either grayscale or rgb.\n *    (3) For each component in the input image, the background value\n *        is estimated using a grayscale closing; hence the 'Morph'\n *        in the function name.\n *    (4) An optional binary mask can be specified, with the foreground\n *        pixels typically over image regions.  The resulting background\n *        map values will be determined by surrounding pixels that are\n *        not under the mask foreground.  The origin (0,0) of this mask\n *        is assumed to be aligned with the origin of the input image.\n *        This binary mask must not fully cover pixs, because then there\n *        will be no pixels in the input image available to compute\n *        the background.\n *    (5) The map is computed at reduced size (given by 'reduction')\n *        from the input pixs and optional pixim.  At this scale,\n *        pixs is closed to remove the background, using a square Sel\n *        of odd dimension.  The product of reduction * size should be\n *        large enough to remove most of the text foreground.\n *    (6) No convolutional smoothing needs to be done on the map before\n *        inverting it.\n *    (7) A 'bgval' target background value for the normalized image.  This\n *        should be at least 128.  If set too close to 255, some\n *        clipping will occur in the result.\n * </pre>\n */\nPIX *\npixBackgroundNormMorph(PIX     *pixs,\n                       PIX     *pixim,\n                       l_int32  reduction,\n                       l_int32  size,\n                       l_int32  bgval)\n{\nl_int32    d, allfg;\nPIX       *pixm, *pixmi, *pixd;\nPIX       *pixmr, *pixmg, *pixmb, *pixmri, *pixmgi, *pixmbi;\n\n    PROCNAME(\"pixBackgroundNormMorph\");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    d = pixGetDepth(pixs);\n    if (d != 8 && d != 32)\n        return (PIX *)ERROR_PTR(\"pixs not 8 or 32 bpp\", procName, NULL);\n    if (reduction < 2 || reduction > 16)\n        return (PIX *)ERROR_PTR(\"reduction must be between 2 and 16\",\n                                procName, NULL);\n\n        /* If pixim exists, verify that it is not all foreground. */\n    if (pixim) {\n        pixInvert(pixim, pixim);\n        pixZero(pixim, &allfg);\n        pixInvert(pixim, pixim);\n        if (allfg)\n            return (PIX *)ERROR_PTR(\"pixim all foreground\", procName, NULL);\n    }\n\n    pixd = NULL;\n    if (d == 8) {\n        pixGetBackgroundGrayMapMorph(pixs, pixim, reduction, size, &pixm);\n        if (!pixm)\n            return (PIX *)ERROR_PTR(\"pixm not made\", procName, NULL);\n        pixmi = pixGetInvBackgroundMap(pixm, bgval, 0, 0);\n        if (!pixmi)\n            ERROR_PTR(\"pixmi not made\", procName, NULL);\n        else\n            pixd = pixApplyInvBackgroundGrayMap(pixs, pixmi,\n                                                reduction, reduction);\n        pixDestroy(&pixm);\n        pixDestroy(&pixmi);\n    }\n    else {  /* d == 32 */\n        pixmr = pixmg = pixmb = NULL;\n        pixGetBackgroundRGBMapMorph(pixs, pixim, reduction, size,\n                                    &pixmr, &pixmg, &pixmb);\n        if (!pixmr || !pixmg || !pixmb) {\n            pixDestroy(&pixmr);\n            pixDestroy(&pixmg);\n            pixDestroy(&pixmb);\n            return (PIX *)ERROR_PTR(\"not all pixm*\", procName, NULL);\n        }\n\n        pixmri = pixGetInvBackgroundMap(pixmr, bgval, 0, 0);\n        pixmgi = pixGetInvBackgroundMap(pixmg, bgval, 0, 0);\n        pixmbi = pixGetInvBackgroundMap(pixmb, bgval, 0, 0);\n        if (!pixmri || !pixmgi || !pixmbi)\n            ERROR_PTR(\"not all pixm*i are made\", procName, NULL);\n        else\n            pixd = pixApplyInvBackgroundRGBMap(pixs, pixmri, pixmgi, pixmbi,\n                                               reduction, reduction);\n\n        pixDestroy(&pixmr);\n        pixDestroy(&pixmg);\n        pixDestroy(&pixmb);\n        pixDestroy(&pixmri);\n        pixDestroy(&pixmgi);\n        pixDestroy(&pixmbi);\n    }\n\n    if (!pixd)\n        ERROR_PTR(\"pixd not made\", procName, NULL);\n    pixCopyResolution(pixd, pixs);\n    return pixd;\n}\n\n\n/*-------------------------------------------------------------------------*\n *      Arrays of inverted background values for normalization             *\n *-------------------------------------------------------------------------*\n *  Notes for these four functions:                                        *\n *      (1) They are useful if you need to save the actual mapping array.  *\n *      (2) They could be used in the top-level functions but are          *\n *          not because their use makes those functions less clear.        *\n *      (3) Each component in the input pixs generates a 16 bpp pix array. *\n *-------------------------------------------------------------------------*/\n/*!\n * \\brief   pixBackgroundNormGrayArray()\n *\n * \\param[in]    pixs       8 bpp grayscale\n * \\param[in]    pixim      [optional] 1 bpp 'image' mask; can be null\n * \\param[in]    sx, sy     tile size in pixels\n * \\param[in]    thresh     threshold for determining foreground\n * \\param[in]    mincount   min threshold on counts in a tile\n * \\param[in]    bgval      target bg val; typ. > 128\n * \\param[in]    smoothx    half-width of block convolution kernel width\n * \\param[in]    smoothy    half-width of block convolution kernel height\n * \\param[out]   ppixd      16 bpp array of inverted background value\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *    (1) See notes in pixBackgroundNorm().\n *    (2) This returns a 16 bpp pix that can be used by\n *        pixApplyInvBackgroundGrayMap() to generate a normalized version\n *        of the input pixs.\n * </pre>\n */\nl_ok\npixBackgroundNormGrayArray(PIX     *pixs,\n                           PIX     *pixim,\n                           l_int32  sx,\n                           l_int32  sy,\n                           l_int32  thresh,\n                           l_int32  mincount,\n                           l_int32  bgval,\n                           l_int32  smoothx,\n                           l_int32  smoothy,\n                           PIX    **ppixd)\n{\nl_int32  allfg;\nPIX     *pixm;\n\n    PROCNAME(\"pixBackgroundNormGrayArray\");\n\n    if (!ppixd)\n        return ERROR_INT(\"&pixd not defined\", procName, 1);\n    *ppixd = NULL;\n    if (!pixs || pixGetDepth(pixs) != 8)\n        return ERROR_INT(\"pixs not defined or not 8 bpp\", procName, 1);\n    if (pixGetColormap(pixs))\n        return ERROR_INT(\"pixs is colormapped\", procName, 1);\n    if (pixim && pixGetDepth(pixim) != 1)\n        return ERROR_INT(\"pixim not 1 bpp\", procName, 1);\n    if (sx < 4 || sy < 4)\n        return ERROR_INT(\"sx and sy must be >= 4\", procName, 1);\n    if (mincount > sx * sy) {\n        L_WARNING(\"mincount too large for tile size\\n\", procName);\n        mincount = (sx * sy) / 3;\n    }\n\n        /* If pixim exists, verify that it is not all foreground. */\n    if (pixim) {\n        pixInvert(pixim, pixim);\n        pixZero(pixim, &allfg);\n        pixInvert(pixim, pixim);\n        if (allfg)\n            return ERROR_INT(\"pixim all foreground\", procName, 1);\n    }\n\n    pixGetBackgroundGrayMap(pixs, pixim, sx, sy, thresh, mincount, &pixm);\n    if (!pixm)\n        return ERROR_INT(\"pixm not made\", procName, 1);\n    *ppixd = pixGetInvBackgroundMap(pixm, bgval, smoothx, smoothy);\n    pixCopyResolution(*ppixd, pixs);\n    pixDestroy(&pixm);\n    return 0;\n}\n\n\n/*!\n * \\brief   pixBackgroundNormRGBArrays()\n *\n * \\param[in]    pixs       32 bpp rgb\n * \\param[in]    pixim      [optional] 1 bpp 'image' mask; can be null\n * \\param[in]    pixg       [optional] 8 bpp grayscale version; can be null\n * \\param[in]    sx, sy     tile size in pixels\n * \\param[in]    thresh     threshold for determining foreground\n * \\param[in]    mincount   min threshold on counts in a tile\n * \\param[in]    bgval      target bg val; typ. > 128\n * \\param[in]    smoothx    half-width of block convolution kernel width\n * \\param[in]    smoothy    half-width of block convolution kernel height\n * \\param[out]   ppixr      16 bpp array of inverted R background value\n * \\param[out]   ppixg      16 bpp array of inverted G background value\n * \\param[out]   ppixb      16 bpp array of inverted B background value\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *    (1) See notes in pixBackgroundNorm().\n *    (2) This returns a set of three 16 bpp pix that can be used by\n *        pixApplyInvBackgroundGrayMap() to generate a normalized version\n *        of each component of the input pixs.\n * </pre>\n */\nl_ok\npixBackgroundNormRGBArrays(PIX     *pixs,\n                           PIX     *pixim,\n                           PIX     *pixg,\n                           l_int32  sx,\n                           l_int32  sy,\n                           l_int32  thresh,\n                           l_int32  mincount,\n                           l_int32  bgval,\n                           l_int32  smoothx,\n                           l_int32  smoothy,\n                           PIX    **ppixr,\n                           PIX    **ppixg,\n                           PIX    **ppixb)\n{\nl_int32  allfg;\nPIX     *pixmr, *pixmg, *pixmb;\n\n    PROCNAME(\"pixBackgroundNormRGBArrays\");\n\n    if (!ppixr || !ppixg || !ppixb)\n        return ERROR_INT(\"&pixr, &pixg, &pixb not all defined\", procName, 1);\n    *ppixr = *ppixg = *ppixb = NULL;\n    if (!pixs)\n        return ERROR_INT(\"pixs not defined\", procName, 1);\n    if (pixGetDepth(pixs) != 32)\n        return ERROR_INT(\"pixs not 32 bpp\", procName, 1);\n    if (pixim && pixGetDepth(pixim) != 1)\n        return ERROR_INT(\"pixim not 1 bpp\", procName, 1);\n    if (sx < 4 || sy < 4)\n        return ERROR_INT(\"sx and sy must be >= 4\", procName, 1);\n    if (mincount > sx * sy) {\n        L_WARNING(\"mincount too large for tile size\\n\", procName);\n        mincount = (sx * sy) / 3;\n    }\n\n        /* If pixim exists, verify that it is not all foreground. */\n    if (pixim) {\n        pixInvert(pixim, pixim);\n        pixZero(pixim, &allfg);\n        pixInvert(pixim, pixim);\n        if (allfg)\n            return ERROR_INT(\"pixim all foreground\", procName, 1);\n    }\n\n    pixGetBackgroundRGBMap(pixs, pixim, pixg, sx, sy, thresh, mincount,\n                           &pixmr, &pixmg, &pixmb);\n    if (!pixmr || !pixmg || !pixmb) {\n        pixDestroy(&pixmr);\n        pixDestroy(&pixmg);\n        pixDestroy(&pixmb);\n        return ERROR_INT(\"not all pixm* made\", procName, 1);\n    }\n\n    *ppixr = pixGetInvBackgroundMap(pixmr, bgval, smoothx, smoothy);\n    *ppixg = pixGetInvBackgroundMap(pixmg, bgval, smoothx, smoothy);\n    *ppixb = pixGetInvBackgroundMap(pixmb, bgval, smoothx, smoothy);\n    pixDestroy(&pixmr);\n    pixDestroy(&pixmg);\n    pixDestroy(&pixmb);\n    return 0;\n}\n\n\n/*!\n * \\brief   pixBackgroundNormGrayArrayMorph()\n *\n * \\param[in]    pixs        8 bpp grayscale\n * \\param[in]    pixim       [optional] 1 bpp 'image' mask; can be null\n * \\param[in]    reduction   at which morph closings are done; between 2 and 16\n * \\param[in]    size        of square Sel for the closing; use an odd number\n * \\param[in]    bgval       target bg val; typ. > 128\n * \\param[out]   ppixd       16 bpp array of inverted background value\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *    (1) See notes in pixBackgroundNormMorph().\n *    (2) This returns a 16 bpp pix that can be used by\n *        pixApplyInvBackgroundGrayMap() to generate a normalized version\n *        of the input pixs.\n * </pre>\n */\nl_ok\npixBackgroundNormGrayArrayMorph(PIX     *pixs,\n                                PIX     *pixim,\n                                l_int32  reduction,\n                                l_int32  size,\n                                l_int32  bgval,\n                                PIX    **ppixd)\n{\nl_int32  allfg;\nPIX     *pixm;\n\n    PROCNAME(\"pixBackgroundNormGrayArrayMorph\");\n\n    if (!ppixd)\n        return ERROR_INT(\"&pixd not defined\", procName, 1);\n    *ppixd = NULL;\n    if (!pixs)\n        return ERROR_INT(\"pixs not defined\", procName, 1);\n    if (pixGetDepth(pixs) != 8)\n        return ERROR_INT(\"pixs not 8 bpp\", procName, 1);\n    if (pixim && pixGetDepth(pixim) != 1)\n        return ERROR_INT(\"pixim not 1 bpp\", procName, 1);\n    if (reduction < 2 || reduction > 16)\n        return ERROR_INT(\"reduction must be between 2 and 16\", procName, 1);\n\n        /* If pixim exists, verify that it is not all foreground. */\n    if (pixim) {\n        pixInvert(pixim, pixim);\n        pixZero(pixim, &allfg);\n        pixInvert(pixim, pixim);\n        if (allfg)\n            return ERROR_INT(\"pixim all foreground\", procName, 1);\n    }\n\n    pixGetBackgroundGrayMapMorph(pixs, pixim, reduction, size, &pixm);\n    if (!pixm)\n        return ERROR_INT(\"pixm not made\", procName, 1);\n    *ppixd = pixGetInvBackgroundMap(pixm, bgval, 0, 0);\n    pixCopyResolution(*ppixd, pixs);\n    pixDestroy(&pixm);\n    return 0;\n}\n\n\n/*!\n * \\brief   pixBackgroundNormRGBArraysMorph()\n *\n * \\param[in]    pixs        32 bpp rgb\n * \\param[in]    pixim       [optional] 1 bpp 'image' mask; can be null\n * \\param[in]    reduction   at which morph closings are done; between 2 and 16\n * \\param[in]    size        of square Sel for the closing; use an odd number\n * \\param[in]    bgval       target bg val; typ. > 128\n * \\param[out]   ppixr       16 bpp array of inverted R background value\n * \\param[out]   ppixg       16 bpp array of inverted G background value\n * \\param[out]   ppixb       16 bpp array of inverted B background value\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *    (1) See notes in pixBackgroundNormMorph().\n *    (2) This returns a set of three 16 bpp pix that can be used by\n *        pixApplyInvBackgroundGrayMap() to generate a normalized version\n *        of each component of the input pixs.\n * </pre>\n */\nl_ok\npixBackgroundNormRGBArraysMorph(PIX     *pixs,\n                                PIX     *pixim,\n                                l_int32  reduction,\n                                l_int32  size,\n                                l_int32  bgval,\n                                PIX    **ppixr,\n                                PIX    **ppixg,\n                                PIX    **ppixb)\n{\nl_int32  allfg;\nPIX     *pixmr, *pixmg, *pixmb;\n\n    PROCNAME(\"pixBackgroundNormRGBArraysMorph\");\n\n    if (!ppixr || !ppixg || !ppixb)\n        return ERROR_INT(\"&pixr, &pixg, &pixb not all defined\", procName, 1);\n    *ppixr = *ppixg = *ppixb = NULL;\n    if (!pixs)\n        return ERROR_INT(\"pixs not defined\", procName, 1);\n    if (pixGetDepth(pixs) != 32)\n        return ERROR_INT(\"pixs not 32 bpp\", procName, 1);\n    if (pixim && pixGetDepth(pixim) != 1)\n        return ERROR_INT(\"pixim not 1 bpp\", procName, 1);\n    if (reduction < 2 || reduction > 16)\n        return ERROR_INT(\"reduction must be between 2 and 16\", procName, 1);\n\n        /* If pixim exists, verify that it is not all foreground. */\n    if (pixim) {\n        pixInvert(pixim, pixim);\n        pixZero(pixim, &allfg);\n        pixInvert(pixim, pixim);\n        if (allfg)\n            return ERROR_INT(\"pixim all foreground\", procName, 1);\n    }\n\n    pixGetBackgroundRGBMapMorph(pixs, pixim, reduction, size,\n                                &pixmr, &pixmg, &pixmb);\n    if (!pixmr || !pixmg || !pixmb) {\n        pixDestroy(&pixmr);\n        pixDestroy(&pixmg);\n        pixDestroy(&pixmb);\n        return ERROR_INT(\"not all pixm* made\", procName, 1);\n    }\n\n    *ppixr = pixGetInvBackgroundMap(pixmr, bgval, 0, 0);\n    *ppixg = pixGetInvBackgroundMap(pixmg, bgval, 0, 0);\n    *ppixb = pixGetInvBackgroundMap(pixmb, bgval, 0, 0);\n    pixDestroy(&pixmr);\n    pixDestroy(&pixmg);\n    pixDestroy(&pixmb);\n    return 0;\n}\n\n\n/*------------------------------------------------------------------*\n *                 Measurement of local background                  *\n *------------------------------------------------------------------*/\n/*!\n * \\brief   pixGetBackgroundGrayMap()\n *\n * \\param[in]    pixs       8 bpp grayscale; not cmapped\n * \\param[in]    pixim      [optional] 1 bpp 'image' mask; can be null;\n *                          it should not have only foreground pixels\n * \\param[in]    sx, sy     tile size in pixels\n * \\param[in]    thresh     threshold for determining foreground\n * \\param[in]    mincount   min threshold on counts in a tile\n * \\param[out]   ppixd      8 bpp grayscale map\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) The background is measured in regions that don't have\n *          images.  It is then propagated into the image regions,\n *          and finally smoothed in each image region.\n * </pre>\n */\nl_ok\npixGetBackgroundGrayMap(PIX     *pixs,\n                        PIX     *pixim,\n                        l_int32  sx,\n                        l_int32  sy,\n                        l_int32  thresh,\n                        l_int32  mincount,\n                        PIX    **ppixd)\n{\nl_int32    w, h, wd, hd, wim, him, wpls, wplim, wpld, wplf;\nl_int32    xim, yim, delx, nx, ny, i, j, k, m;\nl_int32    count, sum, val8;\nl_int32    empty, fgpixels;\nl_uint32  *datas, *dataim, *datad, *dataf, *lines, *lineim, *lined, *linef;\nl_float32  scalex, scaley;\nPIX       *pixd, *piximi, *pixb, *pixf, *pixims;\n\n    PROCNAME(\"pixGetBackgroundGrayMap\");\n\n    if (!ppixd)\n        return ERROR_INT(\"&pixd not defined\", procName, 1);\n    *ppixd = NULL;\n    if (!pixs || pixGetDepth(pixs) != 8)\n        return ERROR_INT(\"pixs not defined or not 8 bpp\", procName, 1);\n    if (pixGetColormap(pixs))\n        return ERROR_INT(\"pixs is colormapped\", procName, 1);\n    if (pixim && pixGetDepth(pixim) != 1)\n        return ERROR_INT(\"pixim not 1 bpp\", procName, 1);\n    if (sx < 4 || sy < 4)\n        return ERROR_INT(\"sx and sy must be >= 4\", procName, 1);\n    if (mincount > sx * sy) {\n        L_WARNING(\"mincount too large for tile size\\n\", procName);\n        mincount = (sx * sy) / 3;\n    }\n\n        /* Evaluate the 'image' mask, pixim, and make sure\n         * it is not all fg. */\n    fgpixels = 0;  /* boolean for existence of fg pixels in the image mask. */\n    if (pixim) {\n        piximi = pixInvert(NULL, pixim);  /* set non-'image' pixels to 1 */\n        pixZero(piximi, &empty);\n        pixDestroy(&piximi);\n        if (empty)\n            return ERROR_INT(\"pixim all fg; no background\", procName, 1);\n        pixZero(pixim, &empty);\n        if (!empty)  /* there are fg pixels in pixim */\n            fgpixels = 1;\n    }\n\n        /* Generate the foreground mask, pixf, which is at\n         * full resolution.  These pixels will be ignored when\n         * computing the background values. */\n    pixb = pixThresholdToBinary(pixs, thresh);\n    pixf = pixMorphSequence(pixb, \"d7.1 + d1.7\", 0);\n    pixDestroy(&pixb);\n\n\n    /* ------------- Set up the output map pixd --------------- */\n        /* Generate pixd, which is reduced by the factors (sx, sy). */\n    w = pixGetWidth(pixs);\n    h = pixGetHeight(pixs);\n    wd = (w + sx - 1) / sx;\n    hd = (h + sy - 1) / sy;\n    pixd = pixCreate(wd, hd, 8);\n\n        /* Note: we only compute map values in tiles that are complete.\n         * In general, tiles at right and bottom edges will not be\n         * complete, and we must fill them in later. */\n    nx = w / sx;\n    ny = h / sy;\n    wpls = pixGetWpl(pixs);\n    datas = pixGetData(pixs);\n    wpld = pixGetWpl(pixd);\n    datad = pixGetData(pixd);\n    wplf = pixGetWpl(pixf);\n    dataf = pixGetData(pixf);\n    for (i = 0; i < ny; i++) {\n        lines = datas + sy * i * wpls;\n        linef = dataf + sy * i * wplf;\n        lined = datad + i * wpld;\n        for (j = 0; j < nx; j++) {\n            delx = j * sx;\n            sum = 0;\n            count = 0;\n            for (k = 0; k < sy; k++) {\n                for (m = 0; m < sx; m++) {\n                    if (GET_DATA_BIT(linef + k * wplf, delx + m) == 0) {\n                        sum += GET_DATA_BYTE(lines + k * wpls, delx + m);\n                        count++;\n                    }\n                }\n            }\n            if (count >= mincount) {\n                val8 = sum / count;\n                SET_DATA_BYTE(lined, j, val8);\n            }\n        }\n    }\n    pixDestroy(&pixf);\n\n        /* If there is an optional mask with fg pixels, erase the previous\n         * calculation for the corresponding map pixels, setting the\n         * map values to 0.   Then, when all the map holes are filled,\n         * these erased pixels will be set by the surrounding map values.\n         *\n         * The calculation here is relatively efficient: for each pixel\n         * in pixd (which corresponds to a tile of mask pixels in pixim)\n         * we look only at the pixel in pixim that is at the center\n         * of the tile.  If the mask pixel is ON, we reset the map\n         * pixel in pixd to 0, so that it can later be filled in. */\n    pixims = NULL;\n    if (pixim && fgpixels) {\n        wim = pixGetWidth(pixim);\n        him = pixGetHeight(pixim);\n        dataim = pixGetData(pixim);\n        wplim = pixGetWpl(pixim);\n        for (i = 0; i < ny; i++) {\n            yim = i * sy + sy / 2;\n            if (yim >= him)\n                break;\n            lineim = dataim + yim * wplim;\n            for (j = 0; j < nx; j++) {\n                xim = j * sx + sx / 2;\n                if (xim >= wim)\n                    break;\n                if (GET_DATA_BIT(lineim, xim))\n                    pixSetPixel(pixd, j, i, 0);\n            }\n        }\n    }\n\n        /* Fill all the holes in the map. */\n    if (pixFillMapHoles(pixd, nx, ny, L_FILL_BLACK)) {\n        pixDestroy(&pixd);\n        L_WARNING(\"can't make the map\\n\", procName);\n        return 1;\n    }\n\n        /* Finally, for each connected region corresponding to the\n         * 'image' mask, reset all pixels to their average value.\n         * Each of these components represents an image (or part of one)\n         * in the input, and this smooths the background values\n         * in each of these regions. */\n    if (pixim && fgpixels) {\n        scalex = 1. / (l_float32)sx;\n        scaley = 1. / (l_float32)sy;\n        pixims = pixScaleBySampling(pixim, scalex, scaley);\n        pixSmoothConnectedRegions(pixd, pixims, 2);\n        pixDestroy(&pixims);\n    }\n\n    *ppixd = pixd;\n    pixCopyResolution(*ppixd, pixs);\n    return 0;\n}\n\n\n/*!\n * \\brief   pixGetBackgroundRGBMap()\n *\n * \\param[in]    pixs       32 bpp rgb\n * \\param[in]    pixim      [optional] 1 bpp 'image' mask; can be null; it\n *                          should not have all foreground pixels\n * \\param[in]    pixg       [optional] 8 bpp grayscale version; can be null\n * \\param[in]    sx, sy     tile size in pixels\n * \\param[in]    thresh     threshold for determining foreground\n * \\param[in]    mincount   min threshold on counts in a tile\n * \\param[out]   ppixmr     red component map\n * \\param[out]   ppixmg     green component map\n * \\param[out]   ppixmb     blue component map\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) If pixg, which is a grayscale version of pixs, is provided,\n *          use this internally to generate the foreground mask.\n *          Otherwise, a grayscale version of pixs will be generated\n *          from the green component only, used, and destroyed.\n * </pre>\n */\nl_ok\npixGetBackgroundRGBMap(PIX     *pixs,\n                       PIX     *pixim,\n                       PIX     *pixg,\n                       l_int32  sx,\n                       l_int32  sy,\n                       l_int32  thresh,\n                       l_int32  mincount,\n                       PIX    **ppixmr,\n                       PIX    **ppixmg,\n                       PIX    **ppixmb)\n{\nl_int32    w, h, wm, hm, wim, him, wpls, wplim, wplf;\nl_int32    xim, yim, delx, nx, ny, i, j, k, m;\nl_int32    count, rsum, gsum, bsum, rval, gval, bval;\nl_int32    empty, fgpixels;\nl_uint32   pixel;\nl_uint32  *datas, *dataim, *dataf, *lines, *lineim, *linef;\nl_float32  scalex, scaley;\nPIX       *piximi, *pixgc, *pixb, *pixf, *pixims;\nPIX       *pixmr, *pixmg, *pixmb;\n\n    PROCNAME(\"pixGetBackgroundRGBMap\");\n\n    if (!ppixmr || !ppixmg || !ppixmb)\n        return ERROR_INT(\"&pixm* not all defined\", procName, 1);\n    *ppixmr = *ppixmg = *ppixmb = NULL;\n    if (!pixs)\n        return ERROR_INT(\"pixs not defined\", procName, 1);\n    if (pixGetDepth(pixs) != 32)\n        return ERROR_INT(\"pixs not 32 bpp\", procName, 1);\n    if (pixim && pixGetDepth(pixim) != 1)\n        return ERROR_INT(\"pixim not 1 bpp\", procName, 1);\n    if (sx < 4 || sy < 4)\n        return ERROR_INT(\"sx and sy must be >= 4\", procName, 1);\n    if (mincount > sx * sy) {\n        L_WARNING(\"mincount too large for tile size\\n\", procName);\n        mincount = (sx * sy) / 3;\n    }\n\n        /* Evaluate the mask pixim and make sure it is not all foreground */\n    fgpixels = 0;  /* boolean for existence of fg mask pixels */\n    if (pixim) {\n        piximi = pixInvert(NULL, pixim);  /* set non-'image' pixels to 1 */\n        pixZero(piximi, &empty);\n        pixDestroy(&piximi);\n        if (empty)\n            return ERROR_INT(\"pixim all fg; no background\", procName, 1);\n        pixZero(pixim, &empty);\n        if (!empty)  /* there are fg pixels in pixim */\n            fgpixels = 1;\n    }\n\n        /* Generate the foreground mask.  These pixels will be\n         * ignored when computing the background values. */\n    if (pixg)  /* use the input grayscale version if it is provided */\n        pixgc = pixClone(pixg);\n    else\n        pixgc = pixConvertRGBToGrayFast(pixs);\n    pixb = pixThresholdToBinary(pixgc, thresh);\n    pixf = pixMorphSequence(pixb, \"d7.1 + d1.7\", 0);\n    pixDestroy(&pixgc);\n    pixDestroy(&pixb);\n\n        /* Generate the output mask images */\n    w = pixGetWidth(pixs);\n    h = pixGetHeight(pixs);\n    wm = (w + sx - 1) / sx;\n    hm = (h + sy - 1) / sy;\n    pixmr = pixCreate(wm, hm, 8);\n    pixmg = pixCreate(wm, hm, 8);\n    pixmb = pixCreate(wm, hm, 8);\n\n    /* ------------- Set up the mapping images --------------- */\n        /* Note: we only compute map values in tiles that are complete.\n         * In general, tiles at right and bottom edges will not be\n         * complete, and we must fill them in later. */\n    nx = w / sx;\n    ny = h / sy;\n    wpls = pixGetWpl(pixs);\n    datas = pixGetData(pixs);\n    wplf = pixGetWpl(pixf);\n    dataf = pixGetData(pixf);\n    for (i = 0; i < ny; i++) {\n        lines = datas + sy * i * wpls;\n        linef = dataf + sy * i * wplf;\n        for (j = 0; j < nx; j++) {\n            delx = j * sx;\n            rsum = gsum = bsum = 0;\n            count = 0;\n            for (k = 0; k < sy; k++) {\n                for (m = 0; m < sx; m++) {\n                    if (GET_DATA_BIT(linef + k * wplf, delx + m) == 0) {\n                        pixel = *(lines + k * wpls + delx + m);\n                        rsum += (pixel >> 24);\n                        gsum += ((pixel >> 16) & 0xff);\n                        bsum += ((pixel >> 8) & 0xff);\n                        count++;\n                    }\n                }\n            }\n            if (count >= mincount) {\n                rval = rsum / count;\n                gval = gsum / count;\n                bval = bsum / count;\n                pixSetPixel(pixmr, j, i, rval);\n                pixSetPixel(pixmg, j, i, gval);\n                pixSetPixel(pixmb, j, i, bval);\n            }\n        }\n    }\n    pixDestroy(&pixf);\n\n        /* If there is an optional mask with fg pixels, erase the previous\n         * calculation for the corresponding map pixels, setting the\n         * map values in each of the 3 color maps to 0.   Then, when\n         * all the map holes are filled, these erased pixels will\n         * be set by the surrounding map values. */\n    if (pixim) {\n        wim = pixGetWidth(pixim);\n        him = pixGetHeight(pixim);\n        dataim = pixGetData(pixim);\n        wplim = pixGetWpl(pixim);\n        for (i = 0; i < ny; i++) {\n            yim = i * sy + sy / 2;\n            if (yim >= him)\n                break;\n            lineim = dataim + yim * wplim;\n            for (j = 0; j < nx; j++) {\n                xim = j * sx + sx / 2;\n                if (xim >= wim)\n                    break;\n                if (GET_DATA_BIT(lineim, xim)) {\n                    pixSetPixel(pixmr, j, i, 0);\n                    pixSetPixel(pixmg, j, i, 0);\n                    pixSetPixel(pixmb, j, i, 0);\n                }\n            }\n        }\n    }\n\n    /* ----------------- Now fill in the holes ----------------------- */\n    if (pixFillMapHoles(pixmr, nx, ny, L_FILL_BLACK) ||\n        pixFillMapHoles(pixmg, nx, ny, L_FILL_BLACK) ||\n        pixFillMapHoles(pixmb, nx, ny, L_FILL_BLACK)) {\n        pixDestroy(&pixmr);\n        pixDestroy(&pixmg);\n        pixDestroy(&pixmb);\n        L_WARNING(\"can't make the maps\\n\", procName);\n        return 1;\n    }\n\n        /* Finally, for each connected region corresponding to the\n         * fg mask, reset all pixels to their average value. */\n    if (pixim && fgpixels) {\n        scalex = 1. / (l_float32)sx;\n        scaley = 1. / (l_float32)sy;\n        pixims = pixScaleBySampling(pixim, scalex, scaley);\n        pixSmoothConnectedRegions(pixmr, pixims, 2);\n        pixSmoothConnectedRegions(pixmg, pixims, 2);\n        pixSmoothConnectedRegions(pixmb, pixims, 2);\n        pixDestroy(&pixims);\n    }\n\n    *ppixmr = pixmr;\n    *ppixmg = pixmg;\n    *ppixmb = pixmb;\n    pixCopyResolution(*ppixmr, pixs);\n    pixCopyResolution(*ppixmg, pixs);\n    pixCopyResolution(*ppixmb, pixs);\n    return 0;\n}\n\n\n/*!\n * \\brief   pixGetBackgroundGrayMapMorph()\n *\n * \\param[in]    pixs        8 bpp grayscale; not cmapped\n * \\param[in]    pixim       [optional] 1 bpp 'image' mask; can be null; it\n *                           should not have all foreground pixels\n * \\param[in]    reduction   factor at which closing is performed\n * \\param[in]    size        of square Sel for the closing; use an odd number\n * \\param[out]   ppixm       grayscale map\n * \\return  0 if OK, 1 on error\n */\nl_ok\npixGetBackgroundGrayMapMorph(PIX     *pixs,\n                             PIX     *pixim,\n                             l_int32  reduction,\n                             l_int32  size,\n                             PIX    **ppixm)\n{\nl_int32    nx, ny, empty, fgpixels;\nl_float32  scale;\nPIX       *pixm, *pix1, *pix2, *pix3, *pixims;\n\n    PROCNAME(\"pixGetBackgroundGrayMapMorph\");\n\n    if (!ppixm)\n        return ERROR_INT(\"&pixm not defined\", procName, 1);\n    *ppixm = NULL;\n    if (!pixs || pixGetDepth(pixs) != 8)\n        return ERROR_INT(\"pixs not defined or not 8 bpp\", procName, 1);\n    if (pixGetColormap(pixs))\n        return ERROR_INT(\"pixs is colormapped\", procName, 1);\n    if (pixim && pixGetDepth(pixim) != 1)\n        return ERROR_INT(\"pixim not 1 bpp\", procName, 1);\n\n        /* Evaluate the mask pixim and make sure it is not all foreground. */\n    fgpixels = 0;  /* boolean for existence of fg mask pixels */\n    if (pixim) {\n        pixInvert(pixim, pixim);  /* set background pixels to 1 */\n        pixZero(pixim, &empty);\n        if (empty)\n            return ERROR_INT(\"pixim all fg; no background\", procName, 1);\n        pixInvert(pixim, pixim);  /* revert to original mask */\n        pixZero(pixim, &empty);\n        if (!empty)  /* there are fg pixels in pixim */\n            fgpixels = 1;\n    }\n\n        /* Downscale as requested and do the closing to get the background. */\n    scale = 1. / (l_float32)reduction;\n    pix1 = pixScaleBySampling(pixs, scale, scale);\n    pix2 = pixCloseGray(pix1, size, size);\n    pix3 = pixExtendByReplication(pix2, 1, 1);\n    pixDestroy(&pix1);\n    pixDestroy(&pix2);\n\n        /* Downscale the image mask, if any, and remove it from the\n         * background.  These pixels will be filled in (twice). */\n    pixims = NULL;\n    if (pixim) {\n        pixims = pixScale(pixim, scale, scale);\n        pixm = pixConvertTo8(pixims, FALSE);\n        pixAnd(pixm, pixm, pix3);\n    }\n    else\n        pixm = pixClone(pix3);\n    pixDestroy(&pix3);\n\n        /* Fill all the holes in the map. */\n    nx = pixGetWidth(pixs) / reduction;\n    ny = pixGetHeight(pixs) / reduction;\n    if (pixFillMapHoles(pixm, nx, ny, L_FILL_BLACK)) {\n        pixDestroy(&pixm);\n        pixDestroy(&pixims);\n        L_WARNING(\"can't make the map\\n\", procName);\n        return 1;\n    }\n\n        /* Finally, for each connected region corresponding to the\n         * fg mask, reset all pixels to their average value. */\n    if (pixim && fgpixels)\n        pixSmoothConnectedRegions(pixm, pixims, 2);\n    pixDestroy(&pixims);\n\n    *ppixm = pixm;\n    pixCopyResolution(*ppixm, pixs);\n    return 0;\n}\n\n\n/*!\n * \\brief   pixGetBackgroundRGBMapMorph()\n *\n * \\param[in]    pixs        32 bpp rgb\n * \\param[in]    pixim       [optional] 1 bpp 'image' mask; can be null; it\n *                           should not have all foreground pixels\n * \\param[in]    reduction   factor at which closing is performed\n * \\param[in]    size        of square Sel for the closing; use an odd number\n * \\param[out]   ppixmr      red component map\n * \\param[out]   ppixmg      green component map\n * \\param[out]   ppixmb      blue component map\n * \\return  0 if OK, 1 on error\n */\nl_ok\npixGetBackgroundRGBMapMorph(PIX     *pixs,\n                            PIX     *pixim,\n                            l_int32  reduction,\n                            l_int32  size,\n                            PIX    **ppixmr,\n                            PIX    **ppixmg,\n                            PIX    **ppixmb)\n{\nl_int32    nx, ny, empty, fgpixels;\nl_float32  scale;\nPIX       *pixm, *pixmr, *pixmg, *pixmb, *pix1, *pix2, *pix3, *pixims;\n\n    PROCNAME(\"pixGetBackgroundRGBMapMorph\");\n\n    if (!ppixmr || !ppixmg || !ppixmb)\n        return ERROR_INT(\"&pixm* not all defined\", procName, 1);\n    *ppixmr = *ppixmg = *ppixmb = NULL;\n    if (!pixs)\n        return ERROR_INT(\"pixs not defined\", procName, 1);\n    if (pixGetDepth(pixs) != 32)\n        return ERROR_INT(\"pixs not 32 bpp\", procName, 1);\n    if (pixim && pixGetDepth(pixim) != 1)\n        return ERROR_INT(\"pixim not 1 bpp\", procName, 1);\n\n        /* Evaluate the mask pixim and make sure it is not all foreground. */\n    fgpixels = 0;  /* boolean for existence of fg mask pixels */\n    if (pixim) {\n        pixInvert(pixim, pixim);  /* set background pixels to 1 */\n        pixZero(pixim, &empty);\n        if (empty)\n            return ERROR_INT(\"pixim all fg; no background\", procName, 1);\n        pixInvert(pixim, pixim);  /* revert to original mask */\n        pixZero(pixim, &empty);\n        if (!empty)  /* there are fg pixels in pixim */\n            fgpixels = 1;\n    }\n\n        /* Generate an 8 bpp version of the image mask, if it exists */\n    scale = 1. / (l_float32)reduction;\n    pixims = NULL;\n    pixm = NULL;\n    if (pixim) {\n        pixims = pixScale(pixim, scale, scale);\n        pixm = pixConvertTo8(pixims, FALSE);\n    }\n\n        /* Downscale as requested and do the closing to get the background.\n         * Then remove the image mask pixels from the background.  They\n         * will be filled in (twice) later.  Do this for all 3 components. */\n    pix1 = pixScaleRGBToGrayFast(pixs, reduction, COLOR_RED);\n    pix2 = pixCloseGray(pix1, size, size);\n    pix3 = pixExtendByReplication(pix2, 1, 1);\n    if (pixim)\n        pixmr = pixAnd(NULL, pixm, pix3);\n    else\n        pixmr = pixClone(pix3);\n    pixDestroy(&pix1);\n    pixDestroy(&pix2);\n    pixDestroy(&pix3);\n\n    pix1 = pixScaleRGBToGrayFast(pixs, reduction, COLOR_GREEN);\n    pix2 = pixCloseGray(pix1, size, size);\n    pix3 = pixExtendByReplication(pix2, 1, 1);\n    if (pixim)\n        pixmg = pixAnd(NULL, pixm, pix3);\n    else\n        pixmg = pixClone(pix3);\n    pixDestroy(&pix1);\n    pixDestroy(&pix2);\n    pixDestroy(&pix3);\n\n    pix1 = pixScaleRGBToGrayFast(pixs, reduction, COLOR_BLUE);\n    pix2 = pixCloseGray(pix1, size, size);\n    pix3 = pixExtendByReplication(pix2, 1, 1);\n    if (pixim)\n        pixmb = pixAnd(NULL, pixm, pix3);\n    else\n        pixmb = pixClone(pix3);\n    pixDestroy(&pixm);\n    pixDestroy(&pix1);\n    pixDestroy(&pix2);\n    pixDestroy(&pix3);\n\n        /* Fill all the holes in the three maps. */\n    nx = pixGetWidth(pixs) / reduction;\n    ny = pixGetHeight(pixs) / reduction;\n    if (pixFillMapHoles(pixmr, nx, ny, L_FILL_BLACK) ||\n        pixFillMapHoles(pixmg, nx, ny, L_FILL_BLACK) ||\n        pixFillMapHoles(pixmb, nx, ny, L_FILL_BLACK)) {\n        pixDestroy(&pixmr);\n        pixDestroy(&pixmg);\n        pixDestroy(&pixmb);\n        pixDestroy(&pixims);\n        L_WARNING(\"can't make the maps\\n\", procName);\n        return 1;\n    }\n\n        /* Finally, for each connected region corresponding to the\n         * fg mask in each component, reset all pixels to their\n         * average value. */\n    if (pixim && fgpixels) {\n        pixSmoothConnectedRegions(pixmr, pixims, 2);\n        pixSmoothConnectedRegions(pixmg, pixims, 2);\n        pixSmoothConnectedRegions(pixmb, pixims, 2);\n        pixDestroy(&pixims);\n    }\n\n    *ppixmr = pixmr;\n    *ppixmg = pixmg;\n    *ppixmb = pixmb;\n    pixCopyResolution(*ppixmr, pixs);\n    pixCopyResolution(*ppixmg, pixs);\n    pixCopyResolution(*ppixmb, pixs);\n    return 0;\n}\n\n\n/*!\n * \\brief   pixFillMapHoles()\n *\n * \\param[in]    pix        8 bpp; a map, with one pixel for each tile in\n *                          a larger image\n * \\param[in]    nx         number of horizontal pixel tiles that are entirely\n *                          covered with pixels in the original source image\n * \\param[in]    ny         ditto for the number of vertical pixel tiles\n * \\param[in]    filltype   L_FILL_WHITE or L_FILL_BLACK\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) This is an in-place operation on pix (the map).  pix is\n *          typically a low-resolution version of some other image\n *          from which it was derived, where each pixel in pix\n *          corresponds to a rectangular tile (say, m x n) of pixels\n *          in the larger image.  All we need to know about the larger\n *          image is whether or not the rightmost column and bottommost\n *          row of pixels in pix correspond to tiles that are\n *          only partially covered by pixels in the larger image.\n *      (2) Typically, some number of pixels in the input map are\n *          not known, and their values must be determined by near\n *          pixels that are known.  These unknown pixels are the 'holes'.\n *          They can take on only two values, 0 and 255, and the\n *          instruction about which to fill is given by the filltype flag.\n *      (3) The \"holes\" can come from two sources.  The first is when there\n *          are not enough foreground or background pixels in a tile;\n *          the second is when a tile is at least partially covered\n *          by an image mask.  If we're filling holes in a fg mask,\n *          the holes are initialized to black (0) and use L_FILL_BLACK.\n *          For filling holes in a bg mask, initialize the holes to\n *          white (255) and use L_FILL_WHITE.\n *      (4) If w is the map width, nx = w or nx = w - 1; ditto for h and ny.\n * </pre>\n */\nl_ok\npixFillMapHoles(PIX     *pix,\n                l_int32  nx,\n                l_int32  ny,\n                l_int32  filltype)\n{\nl_int32   w, h, y, nmiss, goodcol, i, j, found, ival, valtest;\nl_uint32  val, lastval;\nNUMA     *na;  /* indicates if there is any data in the column */\nPIX      *pixt;\n\n    PROCNAME(\"pixFillMapHoles\");\n\n    if (!pix || pixGetDepth(pix) != 8)\n        return ERROR_INT(\"pix not defined or not 8 bpp\", procName, 1);\n    if (pixGetColormap(pix))\n        return ERROR_INT(\"pix is colormapped\", procName, 1);\n\n    /* ------------- Fill holes in the mapping image columns ----------- */\n    pixGetDimensions(pix, &w, &h, NULL);\n    na = numaCreate(0);  /* holds flag for which columns have data */\n    nmiss = 0;\n    valtest = (filltype == L_FILL_WHITE) ? 255 : 0;\n    for (j = 0; j < nx; j++) {  /* do it by columns */\n        found = FALSE;\n        for (i = 0; i < ny; i++) {\n            pixGetPixel(pix, j, i, &val);\n            if (val != valtest) {\n                y = i;\n                found = TRUE;\n                break;\n            }\n        }\n        if (found == FALSE) {\n            numaAddNumber(na, 0);  /* no data in the column */\n            nmiss++;\n        }\n        else {\n            numaAddNumber(na, 1);  /* data in the column */\n            for (i = y - 1; i >= 0; i--)  /* replicate upwards to top */\n                pixSetPixel(pix, j, i, val);\n            pixGetPixel(pix, j, 0, &lastval);\n            for (i = 1; i < h; i++) {  /* set going down to bottom */\n                pixGetPixel(pix, j, i, &val);\n                if (val == valtest)\n                    pixSetPixel(pix, j, i, lastval);\n                else\n                    lastval = val;\n            }\n        }\n    }\n    numaAddNumber(na, 0);  /* last column */\n\n    if (nmiss == nx) {  /* no data in any column! */\n        numaDestroy(&na);\n        L_WARNING(\"no bg found; no data in any column\\n\", procName);\n        return 1;\n    }\n\n    /* ---------- Fill in missing columns by replication ----------- */\n    if (nmiss > 0) {  /* replicate columns */\n        pixt = pixCopy(NULL, pix);\n            /* Find the first good column */\n        goodcol = 0;\n        for (j = 0; j < w; j++) {\n            numaGetIValue(na, j, &ival);\n            if (ival == 1) {\n                goodcol = j;\n                break;\n            }\n        }\n        if (goodcol > 0) {  /* copy cols backward */\n            for (j = goodcol - 1; j >= 0; j--) {\n                pixRasterop(pix, j, 0, 1, h, PIX_SRC, pixt, j + 1, 0);\n                pixRasterop(pixt, j, 0, 1, h, PIX_SRC, pix, j, 0);\n            }\n        }\n        for (j = goodcol + 1; j < w; j++) {   /* copy cols forward */\n            numaGetIValue(na, j, &ival);\n            if (ival == 0) {\n                    /* Copy the column to the left of j */\n                pixRasterop(pix, j, 0, 1, h, PIX_SRC, pixt, j - 1, 0);\n                pixRasterop(pixt, j, 0, 1, h, PIX_SRC, pix, j, 0);\n            }\n        }\n        pixDestroy(&pixt);\n    }\n    if (w > nx) {  /* replicate the last column */\n        for (i = 0; i < h; i++) {\n            pixGetPixel(pix, w - 2, i, &val);\n            pixSetPixel(pix, w - 1, i, val);\n        }\n    }\n\n    numaDestroy(&na);\n    return 0;\n}\n\n\n/*!\n * \\brief   pixExtendByReplication()\n *\n * \\param[in]    pixs    8 bpp\n * \\param[in]    addw    number of extra pixels horizontally to add\n * \\param[in]    addh    number of extra pixels vertically to add\n * \\return  pixd extended with replicated pixel values, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) The pixel values are extended to the left and down, as required.\n * </pre>\n */\nPIX *\npixExtendByReplication(PIX     *pixs,\n                       l_int32  addw,\n                       l_int32  addh)\n{\nl_int32   w, h, i, j;\nl_uint32  val;\nPIX      *pixd;\n\n    PROCNAME(\"pixExtendByReplication\");\n\n    if (!pixs || pixGetDepth(pixs) != 8)\n        return (PIX *)ERROR_PTR(\"pixs undefined or not 8 bpp\", procName, NULL);\n\n    if (addw == 0 && addh == 0)\n        return pixCopy(NULL, pixs);\n\n    pixGetDimensions(pixs, &w, &h, NULL);\n    if ((pixd = pixCreate(w + addw, h + addh, 8)) == NULL)\n        return (PIX *)ERROR_PTR(\"pixd not made\", procName, NULL);\n    pixRasterop(pixd, 0, 0, w, h, PIX_SRC, pixs, 0, 0);\n\n    if (addw > 0) {\n        for (i = 0; i < h; i++) {\n            pixGetPixel(pixd, w - 1, i, &val);\n            for (j = 0; j < addw; j++)\n                pixSetPixel(pixd, w + j, i, val);\n        }\n    }\n\n    if (addh > 0) {\n        for (j = 0; j < w + addw; j++) {\n            pixGetPixel(pixd, j, h - 1, &val);\n            for (i = 0; i < addh; i++)\n                pixSetPixel(pixd, j, h + i, val);\n        }\n    }\n\n    pixCopyResolution(pixd, pixs);\n    return pixd;\n}\n\n\n/*!\n * \\brief   pixSmoothConnectedRegions()\n *\n * \\param[in]    pixs    8 bpp grayscale; no colormap\n * \\param[in]    pixm    [optional] 1 bpp; if null, this is a no-op\n * \\param[in]    factor  subsampling factor for getting average; >= 1\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) The pixels in pixs corresponding to those in each\n *          8-connected region in the mask are set to the average value.\n *      (2) This is required for adaptive mapping to avoid the\n *          generation of stripes in the background map, due to\n *          variations in the pixel values near the edges of mask regions.\n *      (3) This function is optimized for background smoothing, where\n *          there are a relatively small number of components.  It will\n *          be inefficient if used where there are many small components.\n * </pre>\n */\nl_ok\npixSmoothConnectedRegions(PIX     *pixs,\n                          PIX     *pixm,\n                          l_int32  factor)\n{\nl_int32    empty, i, n, x, y;\nl_float32  aveval;\nBOXA      *boxa;\nPIX       *pixmc;\nPIXA      *pixa;\n\n    PROCNAME(\"pixSmoothConnectedRegions\");\n\n    if (!pixs || pixGetDepth(pixs) != 8)\n        return ERROR_INT(\"pixs not defined or not 8 bpp\", procName, 1);\n    if (pixGetColormap(pixs))\n        return ERROR_INT(\"pixs has colormap\", procName, 1);\n    if (!pixm) {\n        L_INFO(\"pixm not defined\\n\", procName);\n        return 0;\n    }\n    if (pixGetDepth(pixm) != 1)\n        return ERROR_INT(\"pixm not 1 bpp\", procName, 1);\n    pixZero(pixm, &empty);\n    if (empty) {\n        L_INFO(\"pixm has no fg pixels; nothing to do\\n\", procName);\n        return 0;\n    }\n\n    boxa = pixConnComp(pixm, &pixa, 8);\n    n = boxaGetCount(boxa);\n    for (i = 0; i < n; i++) {\n        if ((pixmc = pixaGetPix(pixa, i, L_CLONE)) == NULL) {\n            L_WARNING(\"missing pixmc!\\n\", procName);\n            continue;\n        }\n        boxaGetBoxGeometry(boxa, i, &x, &y, NULL, NULL);\n        pixGetAverageMasked(pixs, pixmc, x, y, factor, L_MEAN_ABSVAL, &aveval);\n        pixPaintThroughMask(pixs, pixmc, x, y, (l_int32)aveval);\n        pixDestroy(&pixmc);\n    }\n\n    boxaDestroy(&boxa);\n    pixaDestroy(&pixa);\n    return 0;\n}\n\n\n/*------------------------------------------------------------------*\n *                 Measurement of local foreground                  *\n *------------------------------------------------------------------*/\n#if 0    /* Not working properly: do not use */\n\n/*!\n * \\brief   pixGetForegroundGrayMap()\n *\n * \\param[in]    pixs      8 bpp\n * \\param[in]    pixim     [optional] 1 bpp 'image' mask; can be null\n * \\param[in]    sx, sy    src tile size, in pixels\n * \\param[in]    thresh    threshold for determining foreground\n * \\param[out]   ppixd     8 bpp grayscale map\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) Each (sx, sy) tile of pixs gets mapped to one pixel in pixd.\n *      (2) pixd is the estimate of the fg (darkest) value within each tile.\n *      (3) All pixels in pixd that are in 'image' regions, as specified\n *          by pixim, are given the background value 0.\n *      (4) For pixels in pixd that can't directly be given a fg value,\n *          the value is inferred by propagating from neighboring pixels.\n *      (5) In practice, pixd can be used to normalize the fg, and\n *          it can be done after background normalization.\n *      (6) The overall procedure is:\n *            ~ reduce 2x by sampling\n *            ~ paint all 'image' pixels white, so that they don't\n *            ~ participate in the Min reduction\n *            ~ do a further (sx, sy) Min reduction -- think of\n *              it as a large opening followed by subsampling by the\n *              reduction factors\n *            ~ threshold the result to identify fg, and set the\n *              bg pixels to 255 (these are 'holes')\n *            ~ fill holes by propagation from fg values\n *            ~ replicatively expand by 2x, arriving at the final\n *              resolution of pixd\n *            ~ smooth with a 17x17 kernel\n *            ~ paint the 'image' regions black\n * </pre>\n */\nl_ok\npixGetForegroundGrayMap(PIX     *pixs,\n                        PIX     *pixim,\n                        l_int32  sx,\n                        l_int32  sy,\n                        l_int32  thresh,\n                        PIX    **ppixd)\n{\nl_int32  w, h, d, wd, hd;\nl_int32  empty, fgpixels;\nPIX     *pixd, *piximi, *pixim2, *pixims, *pixs2, *pixb, *pixt1, *pixt2, *pixt3;\n\n    PROCNAME(\"pixGetForegroundGrayMap\");\n\n    if (!ppixd)\n        return ERROR_INT(\"&pixd not defined\", procName, 1);\n    *ppixd = NULL;\n    if (!pixs)\n        return ERROR_INT(\"pixs not defined\", procName, 1);\n    pixGetDimensions(pixs, &w, &h, &d);\n    if (d != 8)\n        return ERROR_INT(\"pixs not 8 bpp\", procName, 1);\n    if (pixim && pixGetDepth(pixim) != 1)\n        return ERROR_INT(\"pixim not 1 bpp\", procName, 1);\n    if (sx < 2 || sy < 2)\n        return ERROR_INT(\"sx and sy must be >= 2\", procName, 1);\n\n        /* Generate pixd, which is reduced by the factors (sx, sy). */\n    wd = (w + sx - 1) / sx;\n    hd = (h + sy - 1) / sy;\n    pixd = pixCreate(wd, hd, 8);\n    *ppixd = pixd;\n\n        /* Evaluate the 'image' mask, pixim.  If it is all fg,\n         * the output pixd has all pixels with value 0. */\n    fgpixels = 0;  /* boolean for existence of fg pixels in the image mask. */\n    if (pixim) {\n        piximi = pixInvert(NULL, pixim);  /* set non-image pixels to 1 */\n        pixZero(piximi, &empty);\n        pixDestroy(&piximi);\n        if (empty)  /* all 'image'; return with all pixels set to 0 */\n            return 0;\n        pixZero(pixim, &empty);\n        if (!empty)  /* there are fg pixels in pixim */\n            fgpixels = 1;\n    }\n\n        /* 2x subsampling; paint white through 'image' mask. */\n    pixs2 = pixScaleBySampling(pixs, 0.5, 0.5);\n    if (pixim && fgpixels) {\n        pixim2 = pixReduceBinary2(pixim, NULL);\n        pixPaintThroughMask(pixs2, pixim2, 0, 0, 255);\n        pixDestroy(&pixim2);\n    }\n\n        /* Min (erosion) downscaling; total reduction (4 sx, 4 sy). */\n    pixt1 = pixScaleGrayMinMax(pixs2, sx, sy, L_CHOOSE_MIN);\n\n/*    pixDisplay(pixt1, 300, 200); */\n\n        /* Threshold to identify fg; paint bg pixels to white. */\n    pixb = pixThresholdToBinary(pixt1, thresh);  /* fg pixels */\n    pixInvert(pixb, pixb);\n    pixPaintThroughMask(pixt1, pixb, 0, 0, 255);\n    pixDestroy(&pixb);\n\n        /* Replicative expansion by 2x to (sx, sy). */\n    pixt2 = pixExpandReplicate(pixt1, 2);\n\n/*    pixDisplay(pixt2, 500, 200); */\n\n        /* Fill holes in the fg by propagation */\n    pixFillMapHoles(pixt2, w / sx, h / sy, L_FILL_WHITE);\n\n/*    pixDisplay(pixt2, 700, 200); */\n\n        /* Smooth with 17x17 kernel. */\n    pixt3 = pixBlockconv(pixt2, 8, 8);\n    pixRasterop(pixd, 0, 0, wd, hd, PIX_SRC, pixt3, 0, 0);\n\n        /* Paint the image parts black. */\n    pixims = pixScaleBySampling(pixim, 1. / sx, 1. / sy);\n    pixPaintThroughMask(pixd, pixims, 0, 0, 0);\n\n    pixDestroy(&pixs2);\n    pixDestroy(&pixt1);\n    pixDestroy(&pixt2);\n    pixDestroy(&pixt3);\n    return 0;\n}\n#endif   /* Not working properly: do not use */\n\n\n/*------------------------------------------------------------------*\n *                  Generate inverted background map                *\n *------------------------------------------------------------------*/\n/*!\n * \\brief   pixGetInvBackgroundMap()\n *\n * \\param[in]    pixs       8 bpp grayscale; no colormap\n * \\param[in]    bgval      target bg val; typ. > 128\n * \\param[in]    smoothx    half-width of block convolution kernel width\n * \\param[in]    smoothy    half-width of block convolution kernel height\n * \\return  pixd 16 bpp, or NULL on error\n *\n * <pre>\n * Notes:\n *     (1) bgval should typically be > 120 and < 240\n *     (2) pixd is a normalization image; the original image is\n *       multiplied by pixd and the result is divided by 256.\n * </pre>\n */\nPIX *\npixGetInvBackgroundMap(PIX     *pixs,\n                       l_int32  bgval,\n                       l_int32  smoothx,\n                       l_int32  smoothy)\n{\nl_int32    w, h, wplsm, wpld, i, j;\nl_int32    val, val16;\nl_uint32  *datasm, *datad, *linesm, *lined;\nPIX       *pixsm, *pixd;\n\n    PROCNAME(\"pixGetInvBackgroundMap\");\n\n    if (!pixs || pixGetDepth(pixs) != 8)\n        return (PIX *)ERROR_PTR(\"pixs undefined or not 8 bpp\", procName, NULL);\n    if (pixGetColormap(pixs))\n        return (PIX *)ERROR_PTR(\"pixs has colormap\", procName, NULL);\n    pixGetDimensions(pixs, &w, &h, NULL);\n    if (w < 5 || h < 5)\n        return (PIX *)ERROR_PTR(\"w and h must be >= 5\", procName, NULL);\n\n        /* smooth the map image */\n    pixsm = pixBlockconv(pixs, smoothx, smoothy);\n    datasm = pixGetData(pixsm);\n    wplsm = pixGetWpl(pixsm);\n\n        /* invert the map image, scaling up to preserve dynamic range */\n    pixd = pixCreate(w, h, 16);\n    datad = pixGetData(pixd);\n    wpld = pixGetWpl(pixd);\n    for (i = 0; i < h; i++) {\n        linesm = datasm + i * wplsm;\n        lined = datad + i * wpld;\n        for (j = 0; j < w; j++) {\n            val = GET_DATA_BYTE(linesm, j);\n            if (val > 0)\n                val16 = (256 * bgval) / val;\n            else {  /* shouldn't happen */\n                L_WARNING(\"smoothed bg has 0 pixel!\\n\", procName);\n                val16 = bgval / 2;\n            }\n            SET_DATA_TWO_BYTES(lined, j, val16);\n        }\n    }\n\n    pixDestroy(&pixsm);\n    pixCopyResolution(pixd, pixs);\n    return pixd;\n}\n\n\n/*------------------------------------------------------------------*\n *                    Apply background map to image                 *\n *------------------------------------------------------------------*/\n/*!\n * \\brief   pixApplyInvBackgroundGrayMap()\n *\n * \\param[in]    pixs    8 bpp grayscale; no colormap\n * \\param[in]    pixm    16 bpp, inverse background map\n * \\param[in]    sx      tile width in pixels\n * \\param[in]    sy      tile height in pixels\n * \\return  pixd 8 bpp, or NULL on error\n */\nPIX *\npixApplyInvBackgroundGrayMap(PIX     *pixs,\n                             PIX     *pixm,\n                             l_int32  sx,\n                             l_int32  sy)\n{\nl_int32    w, h, wm, hm, wpls, wpld, i, j, k, m, xoff, yoff;\nl_int32    vals, vald;\nl_uint32   val16;\nl_uint32  *datas, *datad, *lines, *lined, *flines, *flined;\nPIX       *pixd;\n\n    PROCNAME(\"pixApplyInvBackgroundGrayMap\");\n\n    if (!pixs || pixGetDepth(pixs) != 8)\n        return (PIX *)ERROR_PTR(\"pixs undefined or not 8 bpp\", procName, NULL);\n    if (pixGetColormap(pixs))\n        return (PIX *)ERROR_PTR(\"pixs has colormap\", procName, NULL);\n    if (!pixm || pixGetDepth(pixm) != 16)\n        return (PIX *)ERROR_PTR(\"pixm undefined or not 16 bpp\", procName, NULL);\n    if (sx == 0 || sy == 0)\n        return (PIX *)ERROR_PTR(\"invalid sx and/or sy\", procName, NULL);\n\n    datas = pixGetData(pixs);\n    wpls = pixGetWpl(pixs);\n    pixGetDimensions(pixs, &w, &h, NULL);\n    pixGetDimensions(pixm, &wm, &hm, NULL);\n    if ((pixd = pixCreateTemplate(pixs)) == NULL)\n        return (PIX *)ERROR_PTR(\"pixd not made\", procName, NULL);\n    datad = pixGetData(pixd);\n    wpld = pixGetWpl(pixd);\n    for (i = 0; i < hm; i++) {\n        lines = datas + sy * i * wpls;\n        lined = datad + sy * i * wpld;\n        yoff = sy * i;\n        for (j = 0; j < wm; j++) {\n            pixGetPixel(pixm, j, i, &val16);\n            xoff = sx * j;\n            for (k = 0; k < sy && yoff + k < h; k++) {\n                flines = lines + k * wpls;\n                flined = lined + k * wpld;\n                for (m = 0; m < sx && xoff + m < w; m++) {\n                    vals = GET_DATA_BYTE(flines, xoff + m);\n                    vald = (vals * val16) / 256;\n                    vald = L_MIN(vald, 255);\n                    SET_DATA_BYTE(flined, xoff + m, vald);\n                }\n            }\n        }\n    }\n\n    return pixd;\n}\n\n\n/*!\n * \\brief   pixApplyInvBackgroundRGBMap()\n *\n * \\param[in]    pixs    32 bpp rbg\n * \\param[in]    pixmr   16 bpp, red inverse background map\n * \\param[in]    pixmg   16 bpp, green inverse background map\n * \\param[in]    pixmb   16 bpp, blue inverse background map\n * \\param[in]    sx      tile width in pixels\n * \\param[in]    sy      tile height in pixels\n * \\return  pixd 32 bpp rbg, or NULL on error\n */\nPIX *\npixApplyInvBackgroundRGBMap(PIX     *pixs,\n                            PIX     *pixmr,\n                            PIX     *pixmg,\n                            PIX     *pixmb,\n                            l_int32  sx,\n                            l_int32  sy)\n{\nl_int32    w, h, wm, hm, wpls, wpld, i, j, k, m, xoff, yoff;\nl_int32    rvald, gvald, bvald;\nl_uint32   vals;\nl_uint32   rval16, gval16, bval16;\nl_uint32  *datas, *datad, *lines, *lined, *flines, *flined;\nPIX       *pixd;\n\n    PROCNAME(\"pixApplyInvBackgroundRGBMap\");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    if (pixGetDepth(pixs) != 32)\n        return (PIX *)ERROR_PTR(\"pixs not 32 bpp\", procName, NULL);\n    if (!pixmr || !pixmg || !pixmb)\n        return (PIX *)ERROR_PTR(\"pix maps not all defined\", procName, NULL);\n    if (pixGetDepth(pixmr) != 16 || pixGetDepth(pixmg) != 16 ||\n        pixGetDepth(pixmb) != 16)\n        return (PIX *)ERROR_PTR(\"pix maps not all 16 bpp\", procName, NULL);\n    if (sx == 0 || sy == 0)\n        return (PIX *)ERROR_PTR(\"invalid sx and/or sy\", procName, NULL);\n\n    datas = pixGetData(pixs);\n    wpls = pixGetWpl(pixs);\n    w = pixGetWidth(pixs);\n    h = pixGetHeight(pixs);\n    wm = pixGetWidth(pixmr);\n    hm = pixGetHeight(pixmr);\n    if ((pixd = pixCreateTemplate(pixs)) == NULL)\n        return (PIX *)ERROR_PTR(\"pixd not made\", procName, NULL);\n    datad = pixGetData(pixd);\n    wpld = pixGetWpl(pixd);\n    for (i = 0; i < hm; i++) {\n        lines = datas + sy * i * wpls;\n        lined = datad + sy * i * wpld;\n        yoff = sy * i;\n        for (j = 0; j < wm; j++) {\n            pixGetPixel(pixmr, j, i, &rval16);\n            pixGetPixel(pixmg, j, i, &gval16);\n            pixGetPixel(pixmb, j, i, &bval16);\n            xoff = sx * j;\n            for (k = 0; k < sy && yoff + k < h; k++) {\n                flines = lines + k * wpls;\n                flined = lined + k * wpld;\n                for (m = 0; m < sx && xoff + m < w; m++) {\n                    vals = *(flines + xoff + m);\n                    rvald = ((vals >> 24) * rval16) / 256;\n                    rvald = L_MIN(rvald, 255);\n                    gvald = (((vals >> 16) & 0xff) * gval16) / 256;\n                    gvald = L_MIN(gvald, 255);\n                    bvald = (((vals >> 8) & 0xff) * bval16) / 256;\n                    bvald = L_MIN(bvald, 255);\n                    composeRGBPixel(rvald, gvald, bvald, flined + xoff + m);\n                }\n            }\n        }\n    }\n\n    return pixd;\n}\n\n\n/*------------------------------------------------------------------*\n *                         Apply variable map                       *\n *------------------------------------------------------------------*/\n/*!\n * \\brief   pixApplyVariableGrayMap()\n *\n * \\param[in]    pixs     8 bpp\n * \\param[in]    pixg     8 bpp, variable map\n * \\param[in]    target   typ. 128 for threshold\n * \\return  pixd 8 bpp, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) Suppose you have an image that you want to transform based\n *          on some photometric measurement at each point, such as the\n *          threshold value for binarization.  Representing the photometric\n *          measurement as an image pixg, you can threshold in input image\n *          using pixVarThresholdToBinary().  Alternatively, you can map\n *          the input image pointwise so that the threshold over the\n *          entire image becomes a constant, such as 128.  For example,\n *          if a pixel in pixg is 150 and the target is 128, the\n *          corresponding pixel in pixs is mapped linearly to a value\n *          (128/150) of the input value.  If the resulting mapped image\n *          pixd were then thresholded at 128, you would obtain the\n *          same result as a direct binarization using pixg with\n *          pixVarThresholdToBinary().\n *      (2) The sizes of pixs and pixg must be equal.\n * </pre>\n */\nPIX *\npixApplyVariableGrayMap(PIX     *pixs,\n                        PIX     *pixg,\n                        l_int32  target)\n{\nl_int32    i, j, w, h, d, wpls, wplg, wpld, vals, valg, vald;\nl_uint8   *lut;\nl_uint32  *datas, *datag, *datad, *lines, *lineg, *lined;\nl_float32  fval;\nPIX       *pixd;\n\n    PROCNAME(\"pixApplyVariableGrayMap\");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    if (!pixg)\n        return (PIX *)ERROR_PTR(\"pixg not defined\", procName, NULL);\n    if (!pixSizesEqual(pixs, pixg))\n        return (PIX *)ERROR_PTR(\"pix sizes not equal\", procName, NULL);\n    pixGetDimensions(pixs, &w, &h, &d);\n    if (d != 8)\n        return (PIX *)ERROR_PTR(\"depth not 8 bpp\", procName, NULL);\n\n        /* Generate a LUT for the mapping if the image is large enough\n         * to warrant the overhead.  The LUT is of size 2^16.  For the\n         * index to the table, get the MSB from pixs and the LSB from pixg.\n         * Note: this LUT is bigger than the typical 32K L1 cache, so\n         * we expect cache misses.  L2 latencies are about 5ns.  But\n         * division is slooooow.  For large images, this function is about\n         * 4x faster when using the LUT.  C'est la vie.  */\n    lut = NULL;\n    if (w * h > 100000) {  /* more pixels than 2^16 */\n        if ((lut = (l_uint8 *)LEPT_CALLOC(0x10000, sizeof(l_uint8))) == NULL)\n            return (PIX *)ERROR_PTR(\"lut not made\", procName, NULL);\n        for (i = 0; i < 256; i++) {\n            for (j = 0; j < 256; j++) {\n                fval = (l_float32)(i * target) / (j + 0.5);\n                lut[(i << 8) + j] = L_MIN(255, (l_int32)(fval + 0.5));\n            }\n        }\n    }\n\n    if ((pixd = pixCreateNoInit(w, h, 8)) == NULL) {\n        LEPT_FREE(lut);\n        return (PIX *)ERROR_PTR(\"pixd not made\", procName, NULL);\n    }\n    pixCopyResolution(pixd, pixs);\n    datad = pixGetData(pixd);\n    wpld = pixGetWpl(pixd);\n    datas = pixGetData(pixs);\n    wpls = pixGetWpl(pixs);\n    datag = pixGetData(pixg);\n    wplg = pixGetWpl(pixg);\n    for (i = 0; i < h; i++) {\n        lines = datas + i * wpls;\n        lineg = datag + i * wplg;\n        lined = datad + i * wpld;\n        if (lut) {\n            for (j = 0; j < w; j++) {\n                vals = GET_DATA_BYTE(lines, j);\n                valg = GET_DATA_BYTE(lineg, j);\n                vald = lut[(vals << 8) + valg];\n                SET_DATA_BYTE(lined, j, vald);\n            }\n        }\n        else {\n            for (j = 0; j < w; j++) {\n                vals = GET_DATA_BYTE(lines, j);\n                valg = GET_DATA_BYTE(lineg, j);\n                fval = (l_float32)(vals * target) / (valg + 0.5);\n                vald = L_MIN(255, (l_int32)(fval + 0.5));\n                SET_DATA_BYTE(lined, j, vald);\n            }\n        }\n    }\n\n    LEPT_FREE(lut);\n    return pixd;\n}\n\n\n/*------------------------------------------------------------------*\n *                  Non-adaptive (global) mapping                   *\n *------------------------------------------------------------------*/\n/*!\n * \\brief   pixGlobalNormRGB()\n *\n * \\param[in]    pixd     [optional] null, existing or equal to pixs\n * \\param[in]    pixs     32 bpp rgb, or colormapped\n * \\param[in]    rval, gval, bval   pixel values in pixs that are\n *                                  linearly mapped to mapval\n * \\param[in]    mapval   use 255 for mapping to white\n * \\return  pixd 32 bpp rgb or colormapped, or NULL on error\n *\n * <pre>\n * Notes:\n *    (1) The value of pixd determines if the results are written to a\n *        new pix (use NULL), in-place to pixs (use pixs), or to some\n *        other existing pix.\n *    (2) This does a global normalization of an image where the\n *        r,g,b color components are not balanced.  Thus, white in pixs is\n *        represented by a set of r,g,b values that are not all 255.\n *    (3) The input values (rval, gval, bval) should be chosen to\n *        represent the gray color (mapval, mapval, mapval) in src.\n *        Thus, this function will map (rval, gval, bval) to that gray color.\n *    (4) Typically, mapval = 255, so that (rval, gval, bval)\n *        corresponds to the white point of src.  In that case, these\n *        parameters should be chosen so that few pixels have higher values.\n *    (5) In all cases, we do a linear TRC separately on each of the\n *        components, saturating at 255.\n *    (6) If the input pix is 8 bpp without a colormap, you can get\n *        this functionality with mapval = 255 by calling:\n *            pixGammaTRC(pixd, pixs, 1.0, 0, bgval);\n *        where bgval is the value you want to be mapped to 255.\n *        Or more generally, if you want bgval to be mapped to mapval:\n *            pixGammaTRC(pixd, pixs, 1.0, 0, 255 * bgval / mapval);\n * </pre>\n */\nPIX *\npixGlobalNormRGB(PIX     *pixd,\n                 PIX     *pixs,\n                 l_int32  rval,\n                 l_int32  gval,\n                 l_int32  bval,\n                 l_int32  mapval)\n{\nl_int32    w, h, d, i, j, ncolors, rv, gv, bv, wpl;\nl_int32   *rarray, *garray, *barray;\nl_uint32  *data, *line;\nNUMA      *nar, *nag, *nab;\nPIXCMAP   *cmap;\n\n    PROCNAME(\"pixGlobalNormRGB\");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    cmap = pixGetColormap(pixs);\n    pixGetDimensions(pixs, &w, &h, &d);\n    if (!cmap && d != 32)\n        return (PIX *)ERROR_PTR(\"pixs not cmapped or 32 bpp\", procName, NULL);\n    if (mapval <= 0) {\n        L_WARNING(\"mapval must be > 0; setting to 255\\n\", procName);\n        mapval = 255;\n    }\n\n        /* Prepare pixd to be a copy of pixs */\n    if ((pixd = pixCopy(pixd, pixs)) == NULL)\n        return (PIX *)ERROR_PTR(\"pixd not made\", procName, NULL);\n\n        /* Generate the TRC maps for each component.  Make sure the\n         * upper range for each color is greater than zero. */\n    nar = numaGammaTRC(1.0, 0, L_MAX(1, 255 * rval / mapval));\n    nag = numaGammaTRC(1.0, 0, L_MAX(1, 255 * gval / mapval));\n    nab = numaGammaTRC(1.0, 0, L_MAX(1, 255 * bval / mapval));\n\n        /* Extract copies of the internal arrays */\n    rarray = numaGetIArray(nar);\n    garray = numaGetIArray(nag);\n    barray = numaGetIArray(nab);\n    if (!nar || !nag || !nab || !rarray || !garray || !barray) {\n        L_ERROR(\"allocation failure in arrays\\n\", procName);\n        goto cleanup_arrays;\n    }\n\n    if (cmap) {\n        ncolors = pixcmapGetCount(cmap);\n        for (i = 0; i < ncolors; i++) {\n            pixcmapGetColor(cmap, i, &rv, &gv, &bv);\n            pixcmapResetColor(cmap, i, rarray[rv], garray[gv], barray[bv]);\n        }\n    }\n    else {\n        data = pixGetData(pixd);\n        wpl = pixGetWpl(pixd);\n        for (i = 0; i < h; i++) {\n            line = data + i * wpl;\n            for (j = 0; j < w; j++) {\n                extractRGBValues(line[j], &rv, &gv, &bv);\n                composeRGBPixel(rarray[rv], garray[gv], barray[bv], line + j);\n            }\n        }\n    }\n\ncleanup_arrays:\n    numaDestroy(&nar);\n    numaDestroy(&nag);\n    numaDestroy(&nab);\n    LEPT_FREE(rarray);\n    LEPT_FREE(garray);\n    LEPT_FREE(barray);\n    return pixd;\n}\n\n\n/*!\n * \\brief   pixGlobalNormNoSatRGB()\n *\n * \\param[in]    pixd       [optional] null, existing or equal to pixs\n * \\param[in]    pixs       32 bpp rgb\n * \\param[in]    rval, gval, bval   pixel values in pixs that are\n *                                  linearly mapped to mapval; but see below\n * \\param[in]    factor     subsampling factor; integer >= 1\n * \\param[in]    rank       between 0.0 and 1.0; typ. use a value near 1.0\n * \\return  pixd 32 bpp rgb, or NULL on error\n *\n * <pre>\n * Notes:\n *    (1) This is a version of pixGlobalNormRGB(), where the output\n *        intensity is scaled back so that a controlled fraction of\n *        pixel components is allowed to saturate.  See comments in\n *        pixGlobalNormRGB().\n *    (2) The value of pixd determines if the results are written to a\n *        new pix (use NULL), in-place to pixs (use pixs), or to some\n *        other existing pix.\n *    (3) This does a global normalization of an image where the\n *        r,g,b color components are not balanced.  Thus, white in pixs is\n *        represented by a set of r,g,b values that are not all 255.\n *    (4) The input values (rval, gval, bval) can be chosen to be the\n *        color that, after normalization, becomes white background.\n *        For images that are mostly background, the closer these values\n *        are to the median component values, the closer the resulting\n *        background will be to gray, becoming white at the brightest places.\n *    (5) The mapval used in pixGlobalNormRGB() is computed here to\n *        avoid saturation of any component in the image (save for a\n *        fraction of the pixels given by the input rank value).\n * </pre>\n */\nPIX *\npixGlobalNormNoSatRGB(PIX       *pixd,\n                      PIX       *pixs,\n                      l_int32    rval,\n                      l_int32    gval,\n                      l_int32    bval,\n                      l_int32    factor,\n                      l_float32  rank)\n{\nl_int32    mapval;\nl_float32  rankrval, rankgval, rankbval;\nl_float32  rfract, gfract, bfract, maxfract;\n\n    PROCNAME(\"pixGlobalNormNoSatRGB\");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    if (pixGetDepth(pixs) != 32)\n        return (PIX *)ERROR_PTR(\"pixs not 32 bpp\", procName, NULL);\n    if (factor < 1)\n        return (PIX *)ERROR_PTR(\"sampling factor < 1\", procName, NULL);\n    if (rank < 0.0 || rank > 1.0)\n        return (PIX *)ERROR_PTR(\"rank not in [0.0 ... 1.0]\", procName, NULL);\n    if (rval <= 0 || gval <= 0 || bval <= 0)\n        return (PIX *)ERROR_PTR(\"invalid estim. color values\", procName, NULL);\n\n        /* The max value for each component may be larger than the\n         * input estimated background value.  In that case, mapping\n         * for those pixels would saturate.  To prevent saturation,\n         * we compute the fraction for each component by which we\n         * would oversaturate.  Then take the max of these, and\n         * reduce, uniformly over all components, the output intensity\n         * by this value.  Then no component will saturate.\n         * In practice, if rank < 1.0, a fraction of pixels\n         * may have a component saturate.  By keeping rank close to 1.0,\n         * that fraction can be made arbitrarily small. */\n    pixGetRankValueMaskedRGB(pixs, NULL, 0, 0, factor, rank, &rankrval,\n                             &rankgval, &rankbval);\n    rfract = rankrval / (l_float32)rval;\n    gfract = rankgval / (l_float32)gval;\n    bfract = rankbval / (l_float32)bval;\n    maxfract = L_MAX(rfract, gfract);\n    maxfract = L_MAX(maxfract, bfract);\n#if  DEBUG_GLOBAL\n    lept_stderr(\"rankrval = %7.2f, rankgval = %7.2f, rankbval = %7.2f\\n\",\n                rankrval, rankgval, rankbval);\n    lept_stderr(\"rfract = %7.4f, gfract = %7.4f, bfract = %7.4f\\n\",\n                rfract, gfract, bfract);\n#endif  /* DEBUG_GLOBAL */\n\n    mapval = (l_int32)(255. / maxfract);\n    pixd = pixGlobalNormRGB(pixd, pixs, rval, gval, bval, mapval);\n    return pixd;\n}\n\n\n/*------------------------------------------------------------------*\n *              Adaptive threshold spread normalization             *\n *------------------------------------------------------------------*/\n/*!\n * \\brief   pixThresholdSpreadNorm()\n *\n * \\param[in]    pixs              8 bpp grayscale; not colormapped\n * \\param[in]    filtertype        L_SOBEL_EDGE or L_TWO_SIDED_EDGE;\n * \\param[in]    edgethresh        threshold on magnitude of edge filter;\n *                                 typ 10-20\n * \\param[in]    smoothx, smoothy  half-width of convolution kernel applied to\n *                                 spread threshold: use 0 for no smoothing\n * \\param[in]    gamma             gamma correction; typ. about 0.7\n * \\param[in]    minval            input value that gives 0 for output; typ. -25\n * \\param[in]    maxval            input value that gives 255 for output;\n *                                 typ. 255\n * \\param[in]    targetthresh      target threshold for normalization\n * \\param[out]   ppixth            [optional] computed local threshold value\n * \\param[out]   ppixb             [optional] thresholded normalized image\n * \\param[out]   ppixd             [optional] normalized image\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) The basis of this approach is the use of seed spreading\n *          on a (possibly) sparse set of estimates for the local threshold.\n *          The resulting dense estimates are smoothed by convolution\n *          and used to either threshold the input image or normalize it\n *          with a local transformation that linearly maps the pixels so\n *          that the local threshold estimate becomes constant over the\n *          resulting image.  This approach is one of several that\n *          have been suggested (and implemented) by Ray Smith.\n *      (2) You can use either the Sobel or TwoSided edge filters.\n *          The results appear to be similar, using typical values\n *          of edgethresh in the rang 10-20.\n *      (3) To skip the trc enhancement, use gamma = 1.0, minval = 0\n *          and maxval = 255.\n *      (4) For the normalized image pixd, each pixel is linearly mapped\n *          in such a way that the local threshold is equal to targetthresh.\n *      (5) The full width and height of the convolution kernel\n *          are (2 * smoothx + 1) and (2 * smoothy + 1).\n *      (6) This function can be used with the pixtiling utility if the\n *          images are too large.  See pixOtsuAdaptiveThreshold() for\n *          an example of this.\n * </pre>\n */\nl_ok\npixThresholdSpreadNorm(PIX       *pixs,\n                       l_int32    filtertype,\n                       l_int32    edgethresh,\n                       l_int32    smoothx,\n                       l_int32    smoothy,\n                       l_float32  gamma,\n                       l_int32    minval,\n                       l_int32    maxval,\n                       l_int32    targetthresh,\n                       PIX      **ppixth,\n                       PIX      **ppixb,\n                       PIX      **ppixd)\n{\nPIX  *pixe, *pixet, *pixsd, *pixg1, *pixg2, *pixth;\n\n    PROCNAME(\"pixThresholdSpreadNorm\");\n\n    if (ppixth) *ppixth = NULL;\n    if (ppixb) *ppixb = NULL;\n    if (ppixd) *ppixd = NULL;\n    if (!pixs || pixGetDepth(pixs) != 8)\n        return ERROR_INT(\"pixs not defined or not 8 bpp\", procName, 1);\n    if (pixGetColormap(pixs))\n        return ERROR_INT(\"pixs is colormapped\", procName, 1);\n    if (!ppixth && !ppixb && !ppixd)\n        return ERROR_INT(\"no output requested\", procName, 1);\n    if (filtertype != L_SOBEL_EDGE && filtertype != L_TWO_SIDED_EDGE)\n        return ERROR_INT(\"invalid filter type\", procName, 1);\n\n        /* Get the thresholded edge pixels.  These are the ones\n         * that have values in pixs near the local optimal fg/bg threshold. */\n    if (filtertype == L_SOBEL_EDGE)\n        pixe = pixSobelEdgeFilter(pixs, L_VERTICAL_EDGES);\n    else  /* L_TWO_SIDED_EDGE */\n        pixe = pixTwoSidedEdgeFilter(pixs, L_VERTICAL_EDGES);\n    pixet = pixThresholdToBinary(pixe, edgethresh);\n    pixInvert(pixet, pixet);\n\n        /* Build a seed image whose only nonzero values are those\n         * values of pixs corresponding to pixels in the fg of pixet. */\n    pixsd = pixCreateTemplate(pixs);\n    pixCombineMasked(pixsd, pixs, pixet);\n\n        /* Spread the seed and optionally smooth to reduce noise */\n    pixg1 = pixSeedspread(pixsd, 4);\n    pixg2 = pixBlockconv(pixg1, smoothx, smoothy);\n\n        /* Optionally do a gamma enhancement */\n    pixth = pixGammaTRC(NULL, pixg2, gamma, minval, maxval);\n\n        /* Do the mapping and thresholding */\n    if (ppixd) {\n        *ppixd = pixApplyVariableGrayMap(pixs, pixth, targetthresh);\n        if (ppixb)\n            *ppixb = pixThresholdToBinary(*ppixd, targetthresh);\n    }\n    else if (ppixb)\n        *ppixb = pixVarThresholdToBinary(pixs, pixth);\n\n    if (ppixth)\n        *ppixth = pixth;\n    else\n        pixDestroy(&pixth);\n\n    pixDestroy(&pixe);\n    pixDestroy(&pixet);\n    pixDestroy(&pixsd);\n    pixDestroy(&pixg1);\n    pixDestroy(&pixg2);\n    return 0;\n}\n\n\n/*------------------------------------------------------------------*\n *      Adaptive background normalization (flexible adaptaption)    *\n *------------------------------------------------------------------*/\n/*!\n * \\brief   pixBackgroundNormFlex()\n *\n * \\param[in]    pixs               8 bpp grayscale; not colormapped\n * \\param[in]    sx, sy             desired tile dimensions; size may vary;\n *                                  use values between 3 and 10\n * \\param[in]    smoothx, smoothy   half-width of convolution kernel applied to\n *                                  threshold array: use values between 1 and 3\n * \\param[in]    delta              difference parameter in basin filling;\n *                                  use 0 to skip\n * \\return  pixd 8 bpp, background-normalized), or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) This does adaptation flexibly to a quickly varying background.\n *          For that reason, all input parameters should be small.\n *      (2) sx and sy give the tile size; they should be in [5 - 7].\n *      (3) The full width and height of the convolution kernel\n *          are (2 * smoothx + 1) and (2 * smoothy + 1).  They\n *          should be in [1 - 2].\n *      (4) Basin filling is used to fill the large fg regions.  The\n *          parameter %delta measures the height that the black\n *          background is raised from the local minima.  By raising\n *          the background, it is possible to threshold the large\n *          fg regions to foreground.  If %delta is too large,\n *          bg regions will be lifted, causing thickening of\n *          the fg regions.  Use 0 to skip.\n * </pre>\n */\nPIX *\npixBackgroundNormFlex(PIX     *pixs,\n                      l_int32  sx,\n                      l_int32  sy,\n                      l_int32  smoothx,\n                      l_int32  smoothy,\n                      l_int32  delta)\n{\nl_float32  scalex, scaley;\nPIX       *pixt, *pixsd, *pixmin, *pixbg, *pixbgi, *pixd;\n\n    PROCNAME(\"pixBackgroundNormFlex\");\n\n    if (!pixs || pixGetDepth(pixs) != 8)\n        return (PIX *)ERROR_PTR(\"pixs undefined or not 8 bpp\", procName, NULL);\n    if (pixGetColormap(pixs))\n        return (PIX *)ERROR_PTR(\"pixs is colormapped\", procName, NULL);\n    if (sx < 3 || sy < 3)\n        return (PIX *)ERROR_PTR(\"sx and/or sy less than 3\", procName, NULL);\n    if (sx > 10 || sy > 10)\n        return (PIX *)ERROR_PTR(\"sx and/or sy exceed 10\", procName, NULL);\n    if (smoothx < 1 || smoothy < 1)\n        return (PIX *)ERROR_PTR(\"smooth params less than 1\", procName, NULL);\n    if (smoothx > 3 || smoothy > 3)\n        return (PIX *)ERROR_PTR(\"smooth params exceed 3\", procName, NULL);\n\n        /* Generate the bg estimate using smoothed average with subsampling */\n    scalex = 1. / (l_float32)sx;\n    scaley = 1. / (l_float32)sy;\n    pixt = pixScaleSmooth(pixs, scalex, scaley);\n\n        /* Do basin filling on the bg estimate if requested */\n    if (delta <= 0)\n        pixsd = pixClone(pixt);\n    else {\n        pixLocalExtrema(pixt, 0, 0, &pixmin, NULL);\n        pixsd = pixSeedfillGrayBasin(pixmin, pixt, delta, 4);\n        pixDestroy(&pixmin);\n    }\n    pixbg = pixExtendByReplication(pixsd, 1, 1);\n\n        /* Map the bg to 200 */\n    pixbgi = pixGetInvBackgroundMap(pixbg, 200, smoothx, smoothy);\n    pixd = pixApplyInvBackgroundGrayMap(pixs, pixbgi, sx, sy);\n\n    pixDestroy(&pixt);\n    pixDestroy(&pixsd);\n    pixDestroy(&pixbg);\n    pixDestroy(&pixbgi);\n    return pixd;\n}\n\n\n/*------------------------------------------------------------------*\n *                    Adaptive contrast normalization               *\n *------------------------------------------------------------------*/\n/*!\n * \\brief   pixContrastNorm()\n *\n * \\param[in]    pixd               [optional] 8 bpp; null or equal to pixs\n * \\param[in]    pixs               8 bpp grayscale; not colormapped\n * \\param[in]    sx, sy             tile dimensions\n * \\param[in]    mindiff            minimum difference to accept as valid\n * \\param[in]    smoothx, smoothy   half-width of convolution kernel applied to\n *                                  min and max arrays: use 0 for no smoothing\n * \\return  pixd always\n *\n * <pre>\n * Notes:\n *      (1) This function adaptively attempts to expand the contrast\n *          to the full dynamic range in each tile.  If the contrast in\n *          a tile is smaller than %mindiff, it uses the min and max\n *          pixel values from neighboring tiles.  It also can use\n *          convolution to smooth the min and max values from\n *          neighboring tiles.  After all that processing, it is\n *          possible that the actual pixel values in the tile are outside\n *          the computed [min ... max] range for local contrast\n *          normalization.  Such pixels are taken to be at either 0\n *          (if below the min) or 255 (if above the max).\n *      (2) pixd can be equal to pixs (in-place operation) or\n *          null (makes a new pixd).\n *      (3) sx and sy give the tile size; they are typically at least 20.\n *      (4) mindiff is used to eliminate results for tiles where it is\n *          likely that either fg or bg is missing.  A value around 50\n *          or more is reasonable.\n *      (5) The full width and height of the convolution kernel\n *          are (2 * smoothx + 1) and (2 * smoothy + 1).  Some smoothing\n *          is typically useful, and we limit the smoothing half-widths\n *          to the range from 0 to 8.\n *      (6) A linear TRC (gamma = 1.0) is applied to increase the contrast\n *          in each tile.  The result can subsequently be globally corrected,\n *          by applying pixGammaTRC() with arbitrary values of gamma\n *          and the 0 and 255 points of the mapping.\n * </pre>\n */\nPIX *\npixContrastNorm(PIX       *pixd,\n                PIX       *pixs,\n                l_int32    sx,\n                l_int32    sy,\n                l_int32    mindiff,\n                l_int32    smoothx,\n                l_int32    smoothy)\n{\nPIX  *pixmin, *pixmax;\n\n    PROCNAME(\"pixContrastNorm\");\n\n    if (!pixs || pixGetDepth(pixs) != 8)\n        return (PIX *)ERROR_PTR(\"pixs undefined or not 8 bpp\", procName, pixd);\n    if (pixd && pixd != pixs)\n        return (PIX *)ERROR_PTR(\"pixd not null or == pixs\", procName, pixd);\n    if (pixGetColormap(pixs))\n        return (PIX *)ERROR_PTR(\"pixs is colormapped\", procName, pixd);\n    if (sx < 5 || sy < 5)\n        return (PIX *)ERROR_PTR(\"sx and/or sy less than 5\", procName, pixd);\n    if (smoothx < 0 || smoothy < 0)\n        return (PIX *)ERROR_PTR(\"smooth params less than 0\", procName, pixd);\n    if (smoothx > 8 || smoothy > 8)\n        return (PIX *)ERROR_PTR(\"smooth params exceed 8\", procName, pixd);\n\n        /* Get the min and max pixel values in each tile, and represent\n         * each value as a pixel in pixmin and pixmax, respectively. */\n    pixMinMaxTiles(pixs, sx, sy, mindiff, smoothx, smoothy, &pixmin, &pixmax);\n\n        /* For each tile, do a linear expansion of the dynamic range\n         * of pixels so that the min value is mapped to 0 and the\n         * max value is mapped to 255.  */\n    pixd = pixLinearTRCTiled(pixd, pixs, sx, sy, pixmin, pixmax);\n\n    pixDestroy(&pixmin);\n    pixDestroy(&pixmax);\n    return pixd;\n}\n\n\n/*!\n * \\brief   pixMinMaxTiles()\n *\n * \\param[in]    pixs               8 bpp grayscale; not colormapped\n * \\param[in]    sx, sy             tile dimensions\n * \\param[in]    mindiff            minimum difference to accept as valid\n * \\param[in]    smoothx, smoothy   half-width of convolution kernel applied to\n *                                  min and max arrays: use 0 for no smoothing\n * \\param[out]   ppixmin            tiled minima\n * \\param[out]   ppixmax            tiled maxima\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) This computes filtered and smoothed values for the min and\n *          max pixel values in each tile of the image.\n *      (2) See pixContrastNorm() for usage.\n * </pre>\n */\nl_ok\npixMinMaxTiles(PIX     *pixs,\n               l_int32  sx,\n               l_int32  sy,\n               l_int32  mindiff,\n               l_int32  smoothx,\n               l_int32  smoothy,\n               PIX    **ppixmin,\n               PIX    **ppixmax)\n{\nl_int32  w, h;\nPIX     *pixmin1, *pixmax1, *pixmin2, *pixmax2;\n\n    PROCNAME(\"pixMinMaxTiles\");\n\n    if (ppixmin) *ppixmin = NULL;\n    if (ppixmax) *ppixmax = NULL;\n    if (!ppixmin || !ppixmax)\n        return ERROR_INT(\"&pixmin or &pixmax undefined\", procName, 1);\n    if (!pixs || pixGetDepth(pixs) != 8)\n        return ERROR_INT(\"pixs undefined or not 8 bpp\", procName, 1);\n    if (pixGetColormap(pixs))\n        return ERROR_INT(\"pixs is colormapped\", procName, 1);\n    if (sx < 5 || sy < 5)\n        return ERROR_INT(\"sx and/or sy less than 3\", procName, 1);\n    if (smoothx < 0 || smoothy < 0)\n        return ERROR_INT(\"smooth params less than 0\", procName, 1);\n    if (smoothx > 5 || smoothy > 5)\n        return ERROR_INT(\"smooth params exceed 5\", procName, 1);\n\n        /* Get the min and max values in each tile */\n    pixmin1 = pixScaleGrayMinMax(pixs, sx, sy, L_CHOOSE_MIN);\n    pixmax1 = pixScaleGrayMinMax(pixs, sx, sy, L_CHOOSE_MAX);\n\n    pixmin2 = pixExtendByReplication(pixmin1, 1, 1);\n    pixmax2 = pixExtendByReplication(pixmax1, 1, 1);\n    pixDestroy(&pixmin1);\n    pixDestroy(&pixmax1);\n\n        /* Make sure no value is 0 */\n    pixAddConstantGray(pixmin2, 1);\n    pixAddConstantGray(pixmax2, 1);\n\n        /* Generate holes where the contrast is too small */\n    pixSetLowContrast(pixmin2, pixmax2, mindiff);\n\n        /* Fill the holes (0 values) */\n    pixGetDimensions(pixmin2, &w, &h, NULL);\n    pixFillMapHoles(pixmin2, w, h, L_FILL_BLACK);\n    pixFillMapHoles(pixmax2, w, h, L_FILL_BLACK);\n\n        /* Smooth if requested */\n    if (smoothx > 0 || smoothy > 0) {\n        smoothx = L_MIN(smoothx, (w - 1) / 2);\n        smoothy = L_MIN(smoothy, (h - 1) / 2);\n        *ppixmin = pixBlockconv(pixmin2, smoothx, smoothy);\n        *ppixmax = pixBlockconv(pixmax2, smoothx, smoothy);\n    }\n    else {\n        *ppixmin = pixClone(pixmin2);\n        *ppixmax = pixClone(pixmax2);\n    }\n    pixCopyResolution(*ppixmin, pixs);\n    pixCopyResolution(*ppixmax, pixs);\n    pixDestroy(&pixmin2);\n    pixDestroy(&pixmax2);\n\n    return 0;\n}\n\n\n/*!\n * \\brief   pixSetLowContrast()\n *\n * \\param[in]    pixs1      8 bpp\n * \\param[in]    pixs2      8 bpp\n * \\param[in]    mindiff    minimum difference to accept as valid\n * \\return  0 if OK; 1 if no pixel diffs are large enough, or on error\n *\n * <pre>\n * Notes:\n *      (1) This compares corresponding pixels in pixs1 and pixs2.\n *          When they differ by less than %mindiff, set the pixel\n *          values to 0 in each.  Each pixel typically represents a tile\n *          in a larger image, and a very small difference between\n *          the min and max in the tile indicates that the min and max\n *          values are not to be trusted.\n *      (2) If contrast (pixel difference) detection is expected to fail,\n *          caller should check return value.\n * </pre>\n */\nl_ok\npixSetLowContrast(PIX     *pixs1,\n                  PIX     *pixs2,\n                  l_int32  mindiff)\n{\nl_int32    i, j, w, h, d, wpl, val1, val2, found;\nl_uint32  *data1, *data2, *line1, *line2;\n\n    PROCNAME(\"pixSetLowContrast\");\n\n    if (!pixs1 || !pixs2)\n        return ERROR_INT(\"pixs1 and pixs2 not both defined\", procName, 1);\n    if (pixSizesEqual(pixs1, pixs2) == 0)\n        return ERROR_INT(\"pixs1 and pixs2 not equal size\", procName, 1);\n    pixGetDimensions(pixs1, &w, &h, &d);\n    if (d != 8)\n        return ERROR_INT(\"depth not 8 bpp\", procName, 1);\n    if (mindiff > 254) return 0;\n\n    data1 = pixGetData(pixs1);\n    data2 = pixGetData(pixs2);\n    wpl = pixGetWpl(pixs1);\n    found = 0;  /* init to not finding any diffs >= mindiff */\n    for (i = 0; i < h; i++) {\n        line1 = data1 + i * wpl;\n        line2 = data2 + i * wpl;\n        for (j = 0; j < w; j++) {\n            val1 = GET_DATA_BYTE(line1, j);\n            val2 = GET_DATA_BYTE(line2, j);\n            if (L_ABS(val1 - val2) >= mindiff) {\n                found = 1;\n                break;\n            }\n        }\n        if (found) break;\n    }\n    if (!found) {\n        L_WARNING(\"no pixel pair diffs as large as mindiff\\n\", procName);\n        pixClearAll(pixs1);\n        pixClearAll(pixs2);\n        return 1;\n    }\n\n    for (i = 0; i < h; i++) {\n        line1 = data1 + i * wpl;\n        line2 = data2 + i * wpl;\n        for (j = 0; j < w; j++) {\n            val1 = GET_DATA_BYTE(line1, j);\n            val2 = GET_DATA_BYTE(line2, j);\n            if (L_ABS(val1 - val2) < mindiff) {\n                SET_DATA_BYTE(line1, j, 0);\n                SET_DATA_BYTE(line2, j, 0);\n            }\n        }\n    }\n\n    return 0;\n}\n\n\n/*!\n * \\brief   pixLinearTRCTiled()\n *\n * \\param[in]    pixd     [optional] 8 bpp\n * \\param[in]    pixs     8 bpp, not colormapped\n * \\param[in]    sx, sy   tile dimensions\n * \\param[in]    pixmin   pix of min values in tiles\n * \\param[in]    pixmax   pix of max values in tiles\n * \\return  pixd always\n *\n * <pre>\n * Notes:\n *      (1) pixd can be equal to pixs (in-place operation) or\n *          null (makes a new pixd).\n *      (2) sx and sy give the tile size; they are typically at least 20.\n *      (3) pixmin and pixmax are generated by pixMinMaxTiles()\n *      (4) For each tile, this does a linear expansion of the dynamic\n *          range so that the min value in the tile becomes 0 and the\n *          max value in the tile becomes 255.\n *      (5) The LUTs that do the mapping are generated as needed\n *          and stored for reuse in an integer array within the ptr array iaa[].\n * </pre>\n */\nPIX *\npixLinearTRCTiled(PIX       *pixd,\n                  PIX       *pixs,\n                  l_int32    sx,\n                  l_int32    sy,\n                  PIX       *pixmin,\n                  PIX       *pixmax)\n{\nl_int32    i, j, k, m, w, h, wt, ht, wpl, wplt, xoff, yoff;\nl_int32    minval, maxval, val, sval;\nl_int32   *ia;\nl_int32  **iaa;\nl_uint32  *data, *datamin, *datamax, *line, *tline, *linemin, *linemax;\n\n    PROCNAME(\"pixLinearTRCTiled\");\n\n    if (!pixs || pixGetDepth(pixs) != 8)\n        return (PIX *)ERROR_PTR(\"pixs undefined or not 8 bpp\", procName, pixd);\n    if (pixd && pixd != pixs)\n        return (PIX *)ERROR_PTR(\"pixd not null or == pixs\", procName, pixd);\n    if (pixGetColormap(pixs))\n        return (PIX *)ERROR_PTR(\"pixs is colormapped\", procName, pixd);\n    if (!pixmin || !pixmax)\n        return (PIX *)ERROR_PTR(\"pixmin & pixmax not defined\", procName, pixd);\n    if (sx < 5 || sy < 5)\n        return (PIX *)ERROR_PTR(\"sx and/or sy less than 5\", procName, pixd);\n\n    if ((iaa = (l_int32 **)LEPT_CALLOC(256, sizeof(l_int32 *))) == NULL)\n        return (PIX *)ERROR_PTR(\"iaa not made\", procName, NULL);\n    if ((pixd = pixCopy(pixd, pixs)) == NULL) {\n        LEPT_FREE(iaa);\n        return (PIX *)ERROR_PTR(\"pixd not made\", procName, NULL);\n    }\n    pixGetDimensions(pixd, &w, &h, NULL);\n\n    data = pixGetData(pixd);\n    wpl = pixGetWpl(pixd);\n    datamin = pixGetData(pixmin);\n    datamax = pixGetData(pixmax);\n    wplt = pixGetWpl(pixmin);\n    pixGetDimensions(pixmin, &wt, &ht, NULL);\n    for (i = 0; i < ht; i++) {\n        line = data + sy * i * wpl;\n        linemin = datamin + i * wplt;\n        linemax = datamax + i * wplt;\n        yoff = sy * i;\n        for (j = 0; j < wt; j++) {\n            xoff = sx * j;\n            minval = GET_DATA_BYTE(linemin, j);\n            maxval = GET_DATA_BYTE(linemax, j);\n            if (maxval == minval) {\n                L_ERROR(\"shouldn't happen! i,j = %d,%d, minval = %d\\n\",\n                        procName, i, j, minval);\n                continue;\n            }\n            if ((ia = iaaGetLinearTRC(iaa, maxval - minval)) == NULL) {\n                L_ERROR(\"failure to make ia for j = %d!\\n\", procName, j);\n                continue;\n            }\n            for (k = 0; k < sy && yoff + k < h; k++) {\n                tline = line + k * wpl;\n                for (m = 0; m < sx && xoff + m < w; m++) {\n                    val = GET_DATA_BYTE(tline, xoff + m);\n                    sval = val - minval;\n                    sval = L_MAX(0, sval);\n                    SET_DATA_BYTE(tline, xoff + m, ia[sval]);\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < 256; i++)\n        LEPT_FREE(iaa[i]);\n    LEPT_FREE(iaa);\n    return pixd;\n}\n\n\n/*!\n * \\brief   iaaGetLinearTRC()\n *\n * \\param[in]    iaa     bare array of ptrs to l_int32\n * \\param[in]    diff    between min and max pixel values that are\n *                       to be mapped to 0 and 255\n * \\return  ia LUT with input (val - minval) and output a\n *                  value between 0 and 255)\n */\nstatic l_int32 *\niaaGetLinearTRC(l_int32  **iaa,\n                l_int32    diff)\n{\nl_int32    i;\nl_int32   *ia;\nl_float32  factor;\n\n    PROCNAME(\"iaaGetLinearTRC\");\n\n    if (!iaa)\n        return (l_int32 *)ERROR_PTR(\"iaa not defined\", procName, NULL);\n\n    if (iaa[diff] != NULL)  /* already have it */\n       return iaa[diff];\n\n    if ((ia = (l_int32 *)LEPT_CALLOC(256, sizeof(l_int32))) == NULL)\n        return (l_int32 *)ERROR_PTR(\"ia not made\", procName, NULL);\n    iaa[diff] = ia;\n    if (diff == 0) {  /* shouldn't happen */\n        for (i = 0; i < 256; i++)\n            ia[i] = 128;\n    }\n    else {\n        factor = 255. / (l_float32)diff;\n        for (i = 0; i < diff + 1; i++)\n            ia[i] = (l_int32)(factor * i + 0.5);\n        for (i = diff + 1; i < 256; i++)\n            ia[i] = 255;\n    }\n\n    return ia;\n}\n"], "fixing_code": ["/*====================================================================*\n -  Copyright (C) 2001 Leptonica.  All rights reserved.\n -\n -  Redistribution and use in source and binary forms, with or without\n -  modification, are permitted provided that the following conditions\n -  are met:\n -  1. Redistributions of source code must retain the above copyright\n -     notice, this list of conditions and the following disclaimer.\n -  2. Redistributions in binary form must reproduce the above\n -     copyright notice, this list of conditions and the following\n -     disclaimer in the documentation and/or other materials\n -     provided with the distribution.\n -\n -  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n -  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n -  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n -  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ANY\n -  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n -  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n -  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n -  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n -  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n -  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n -  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *====================================================================*/\n\n/*\n * adaptmap_reg.c\n *\n *   Regression test demonstrating adaptive mappings in both gray and color\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config_auto.h>\n#endif  /* HAVE_CONFIG_H */\n\n#include \"allheaders.h\"\n\n   /* Location of image region in wet-day.jpg */\nstatic const l_int32  XS = 151;\nstatic const l_int32  YS = 225;\nstatic const l_int32  WS = 913;\nstatic const l_int32  HS = 1285;\n\nstatic const l_int32  SIZE_X = 10;\nstatic const l_int32  SIZE_Y = 30;\nstatic const l_int32  BINTHRESH = 50;\nstatic const l_int32  MINCOUNT = 30;\n\nstatic const l_int32  BGVAL = 200;\nstatic const l_int32  SMOOTH_X = 2;\nstatic const l_int32  SMOOTH_Y = 1;\n\nint main(int    argc,\n         char **argv)\n{\nl_int32       w, h;\nPIX          *pixs, *pixg, *pixim, *pixgm, *pixmi, *pix1, *pix2;\nPIX          *pixmr, *pixmg, *pixmb, *pixmri, *pixmgi, *pixmbi;\nPIXA         *pixa, *pixa2;\nL_REGPARAMS  *rp;\n\n    if (regTestSetup(argc, argv, &rp))\n        return 1;\n\n    lept_mkdir(\"lept/adapt\");  // REMOVE?\n\n    pixs = pixRead(\"wet-day.jpg\");\n    pixa = pixaCreate(0);\n    pixg = pixConvertRGBToGray(pixs, 0.33, 0.34, 0.33);\n    pixaAddPix(pixa, pixs, L_INSERT);\n    pixaAddPix(pixa, pixg, L_INSERT);\n    pixGetDimensions(pixs, &w, &h, NULL);\n\n        /* Process in grayscale */\n    startTimer();\n    pixim = pixCreate(w, h, 1);\n    pixRasterop(pixim, XS, YS, WS, HS, PIX_SET, NULL, 0, 0);\n    pixGetBackgroundGrayMap(pixg, pixim, SIZE_X, SIZE_Y,\n                            BINTHRESH, MINCOUNT, &pixgm);\n    fprintf(stderr, \"Time for gray adaptmap gen: %7.3f\\n\", stopTimer());\n    regTestWritePixAndCheck(rp, pixgm, IFF_PNG);  /* 0 */\n    pixaAddPix(pixa, pixgm, L_INSERT);\n\n    startTimer();\n    pixmi = pixGetInvBackgroundMap(pixgm, BGVAL, SMOOTH_X, SMOOTH_Y);\n    fprintf(stderr, \"Time for gray inv map generation: %7.3f\\n\", stopTimer());\n    regTestWritePixAndCheck(rp, pixmi, IFF_PNG);  /* 1 */\n    pixaAddPix(pixa, pixmi, L_INSERT);\n\n    startTimer();\n    pix1 = pixApplyInvBackgroundGrayMap(pixg, pixmi, SIZE_X, SIZE_Y);\n    fprintf(stderr, \"Time to apply gray inv map: %7.3f\\n\", stopTimer());\n    regTestWritePixAndCheck(rp, pix1, IFF_JFIF_JPEG);  /* 2 */\n    pixaAddPix(pixa, pix1, L_INSERT);\n\n    pix2 = pixGammaTRCMasked(NULL, pix1, pixim, 1.0, 0, 190);\n    pixInvert(pixim, pixim);\n    pixGammaTRCMasked(pix2, pix2, pixim, 1.0, 60, 190);\n    regTestWritePixAndCheck(rp, pix2, IFF_JFIF_JPEG);  /* 3 */\n    pixaAddPix(pixa, pix2, L_INSERT);\n    pixDestroy(&pixim);\n\n        /* Process in color */\n    startTimer();\n    pixim = pixCreate(w, h, 1);\n    pixRasterop(pixim, XS, YS, WS, HS, PIX_SET, NULL, 0, 0);\n    pixGetBackgroundRGBMap(pixs, pixim, NULL, SIZE_X, SIZE_Y,\n                           BINTHRESH, MINCOUNT,\n                           &pixmr, &pixmg, &pixmb);\n    fprintf(stderr, \"Time for color adaptmap gen: %7.3f\\n\", stopTimer());\n    regTestWritePixAndCheck(rp, pixmr, IFF_PNG);  /* 4 */\n    regTestWritePixAndCheck(rp, pixmg, IFF_PNG);  /* 5 */\n    regTestWritePixAndCheck(rp, pixmb, IFF_PNG);  /* 6 */\n    pixaAddPix(pixa, pixmr, L_INSERT);\n    pixaAddPix(pixa, pixmg, L_INSERT);\n    pixaAddPix(pixa, pixmb, L_INSERT);\n\n    startTimer();\n    pixmri = pixGetInvBackgroundMap(pixmr, BGVAL, SMOOTH_X, SMOOTH_Y);\n    pixmgi = pixGetInvBackgroundMap(pixmg, BGVAL, SMOOTH_X, SMOOTH_Y);\n    pixmbi = pixGetInvBackgroundMap(pixmb, BGVAL, SMOOTH_X, SMOOTH_Y);\n    fprintf(stderr, \"Time for color inv map generation: %7.3f\\n\", stopTimer());\n    regTestWritePixAndCheck(rp, pixmri, IFF_PNG);  /* 7 */\n    regTestWritePixAndCheck(rp, pixmgi, IFF_PNG);  /* 8 */\n    regTestWritePixAndCheck(rp, pixmbi, IFF_PNG);  /* 9 */\n    pixaAddPix(pixa, pixmri, L_INSERT);\n    pixaAddPix(pixa, pixmgi, L_INSERT);\n    pixaAddPix(pixa, pixmbi, L_INSERT);\n\n    startTimer();\n    pix1 = pixApplyInvBackgroundRGBMap(pixs, pixmri, pixmgi, pixmbi,\n                                       SIZE_X, SIZE_Y);\n    fprintf(stderr, \"Time to apply color inv maps: %7.3f\\n\", stopTimer());\n    regTestWritePixAndCheck(rp, pix1, IFF_JFIF_JPEG);  /* 10 */\n    pixaAddPix(pixa, pix1, L_INSERT);\n\n    pix2 = pixGammaTRCMasked(NULL, pix1, pixim, 1.0, 0, 190);\n    pixInvert(pixim, pixim);\n    pixGammaTRCMasked(pix2, pix2, pixim, 1.0, 60, 190);\n    regTestWritePixAndCheck(rp, pix2, IFF_JFIF_JPEG);  /* 11 */\n    pixaAddPix(pixa, pix2, L_INSERT);\n    pixDestroy(&pixim);\n\n        /* Process at higher level in color */\n    startTimer();\n    pixim = pixCreate(w, h, 1);\n    pixRasterop(pixim, XS, YS, WS, HS, PIX_SET, NULL, 0, 0);\n    pix1 = pixBackgroundNorm(pixs, pixim, NULL, 5, 10, BINTHRESH, 20,\n                             BGVAL, SMOOTH_X, SMOOTH_Y);\n    fprintf(stderr, \"Time for bg normalization: %7.3f\\n\", stopTimer());\n    regTestWritePixAndCheck(rp, pix1, IFF_JFIF_JPEG);  /* 12 */\n    pixaAddPix(pixa, pix1, L_INSERT);\n\n    pix2 = pixGammaTRCMasked(NULL, pix1, pixim, 1.0, 0, 190);\n    pixInvert(pixim, pixim);\n    pixGammaTRCMasked(pix2, pix2, pixim, 1.0, 60, 190);\n    regTestWritePixAndCheck(rp, pix2, IFF_JFIF_JPEG);  /* 13 */\n    pixaAddPix(pixa, pix2, L_INSERT);\n    pixDestroy(&pixim);\n\n        /* Check pixFillMapHoles() */\n    pixa2 = pixaCreate(3);\n    pix1 = pixRead(\"weasel8.png\");  /* use this as the map */\n    pixGammaTRC(pix1, pix1, 1.0, 0, 270);  /* darken white pixels */\n    pixaAddPix(pixa2, pix1, L_COPY);\n    pixGetDimensions(pix1, &w, &h, NULL);\n    pixRasterop(pix1, 0, 0, 5, h, PIX_SET, NULL, 0, 0);  /* add white holes */\n    pixRasterop(pix1, 20, 0, 2, h, PIX_SET, NULL, 0, 0);\n    pixRasterop(pix1, 40, 0, 3, h, PIX_SET, NULL, 0, 0);\n    pixRasterop(pix1, 0, 0, w, 3, PIX_SET, NULL, 0, 0);\n    pixRasterop(pix1, 0, 15, w, 3, PIX_SET, NULL, 0, 0);\n    pixRasterop(pix1, 0, 35, w, 2, PIX_SET, NULL, 0, 0);\n    pixaAddPix(pixa2, pix1, L_COPY);\n    pixFillMapHoles(pix1, w, h, L_FILL_WHITE);\n    pixaAddPix(pixa2, pix1, L_INSERT);\n    pix2 = pixaDisplayTiledInColumns(pixa2, 3, 1.0, 20, 1);\n    regTestWritePixAndCheck(rp, pix2, IFF_PNG);  /* 14 */\n    pixDisplayWithTitle(pix2, 50, 850, NULL, rp->display);\n    pixaDestroy(&pixa2);\n    pixDestroy(&pix2);\n    \n        /* Display results */\n    pix1 = pixaDisplayTiledAndScaled(pixa, 32, 400, 4, 0, 20, 2);\n    pixWrite(\"/tmp/lept/adapt/results.jpg\", pix1, IFF_JFIF_JPEG);\n    pixDisplayWithTitle(pix1, 50, 0, NULL, rp->display);\n    pixDestroy(&pix1);\n    pixaDestroy(&pixa);\n\n    return regTestCleanup(rp);\n}\n\n", "/*====================================================================*\n -  Copyright (C) 2001 Leptonica.  All rights reserved.\n -\n -  Redistribution and use in source and binary forms, with or without\n -  modification, are permitted provided that the following conditions\n -  are met:\n -  1. Redistributions of source code must retain the above copyright\n -     notice, this list of conditions and the following disclaimer.\n -  2. Redistributions in binary form must reproduce the above\n -     copyright notice, this list of conditions and the following\n -     disclaimer in the documentation and/or other materials\n -     provided with the distribution.\n -\n -  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n -  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n -  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n -  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ANY\n -  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n -  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n -  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n -  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n -  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n -  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n -  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *====================================================================*/\n\n/*!\n * \\file adaptmap.c\n * <pre>\n *\n *  -------------------------------------------------------------------\n *\n *  Image binarization algorithms are found in:\n *     grayquant.c:   standard, simple, general grayscale quantization\n *     adaptmap.c:    local adaptive; mostly gray-to-gray in preparation\n *                    for binarization\n *     binarize.c:    special binarization methods, locally adaptive.\n *\n *  -------------------------------------------------------------------\n *\n *      Clean background to white using background normalization\n *          PIX       *pixCleanBackgroundToWhite()\n *\n *      Adaptive background normalization (top-level functions)\n *          PIX       *pixBackgroundNormSimple()     8 and 32 bpp\n *          PIX       *pixBackgroundNorm()           8 and 32 bpp\n *          PIX       *pixBackgroundNormMorph()      8 and 32 bpp\n *\n *      Arrays of inverted background values for normalization (16 bpp)\n *          l_int32    pixBackgroundNormGrayArray()   8 bpp input\n *          l_int32    pixBackgroundNormRGBArrays()   32 bpp input\n *          l_int32    pixBackgroundNormGrayArrayMorph()   8 bpp input\n *          l_int32    pixBackgroundNormRGBArraysMorph()   32 bpp input\n *\n *      Measurement of local background\n *          l_int32    pixGetBackgroundGrayMap()        8 bpp\n *          l_int32    pixGetBackgroundRGBMap()         32 bpp\n *          l_int32    pixGetBackgroundGrayMapMorph()   8 bpp\n *          l_int32    pixGetBackgroundRGBMapMorph()    32 bpp\n *          l_int32    pixFillMapHoles()\n *          PIX       *pixExtendByReplication()         8 bpp\n *          l_int32    pixSmoothConnectedRegions()      8 bpp\n *\n *      Measurement of local foreground\n *          l_int32    pixGetForegroundGrayMap()        8 bpp\n *\n *      Generate inverted background map for each component\n *          PIX       *pixGetInvBackgroundMap()   16 bpp\n *\n *      Apply inverse background map to image\n *          PIX       *pixApplyInvBackgroundGrayMap()   8 bpp\n *          PIX       *pixApplyInvBackgroundRGBMap()    32 bpp\n *\n *      Apply variable map\n *          PIX       *pixApplyVariableGrayMap()        8 bpp\n *\n *      Non-adaptive (global) mapping\n *          PIX       *pixGlobalNormRGB()               32 bpp or cmapped\n *          PIX       *pixGlobalNormNoSatRGB()          32 bpp\n *\n *      Adaptive threshold spread normalization\n *          l_int32    pixThresholdSpreadNorm()         8 bpp\n *\n *      Adaptive background normalization (flexible adaptaption)\n *          PIX       *pixBackgroundNormFlex()          8 bpp\n *\n *      Adaptive contrast normalization\n *          PIX             *pixContrastNorm()          8 bpp\n *          l_int32          pixMinMaxTiles()\n *          l_int32          pixSetLowContrast()\n *          PIX             *pixLinearTRCTiled()\n *          static l_int32  *iaaGetLinearTRC()\n *\n *  Background normalization is done by generating a reduced map (or set\n *  of maps) representing the estimated background value of the\n *  input image, and using this to shift the pixel values so that\n *  this background value is set to some constant value.\n *\n *  Specifically, normalization has 3 steps:\n *    (1) Generate a background map at a reduced scale.\n *    (2) Make the array of inverted background values by inverting\n *        the map.  The result is an array of local multiplicative factors.\n *    (3) Apply this inverse background map to the image\n *\n *  The inverse background arrays can be generated in two different ways here:\n *    (1) Remove the 'foreground' pixels and average over the remaining\n *        pixels in each tile.  Propagate values into tiles where\n *        values have not been assigned, either because there was not\n *        enough background in the tile or because the tile is covered\n *        by a foreground region described by an image mask.\n *        After the background map is made, the inverse map is generated by\n *        smoothing over some number of adjacent tiles\n *        (block convolution) and then inverting.\n *    (2) Remove the foreground pixels using a morphological closing\n *        on a subsampled version of the image.  Propagate values\n *        into pixels covered by an optional image mask.  Invert the\n *        background map without preconditioning by convolutional smoothing.\n *\n *  Other methods for adaptively normalizing the image are also given here.\n *\n *  (1) pixThresholdSpreadNorm() computes a local threshold over the image\n *      and normalizes the input pixel values so that this computed threshold\n *      is a constant across the entire image.\n *\n *  (2) pixContrastNorm() computes and applies a local TRC so that the\n *      local dynamic range is expanded to the full 8 bits, where the\n *      darkest pixels are mapped to 0 and the lightest to 255.  This is\n *      useful for improving the appearance of pages with very light\n *      foreground or very dark background, and where the local TRC\n *      function doesn't change rapidly with position.\n * </pre>\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config_auto.h>\n#endif  /* HAVE_CONFIG_H */\n\n#include \"allheaders.h\"\n\n    /* Default input parameters for pixBackgroundNormSimple()\n     * Notes:\n     *    (1) mincount must never exceed the tile area (width * height)\n     *    (2) bgval must be sufficiently below 255 to avoid accidental\n     *        saturation; otherwise it should be large to avoid\n     *        shrinking the dynamic range\n     *    (3) results should otherwise not be sensitive to these values\n     */\nstatic const l_int32  DefaultTileWidth = 10;    /*!< default tile width    */\nstatic const l_int32  DefaultTileHeight = 15;   /*!< default tile height   */\nstatic const l_int32  DefaultFgThreshold = 60;  /*!< default fg threshold  */\nstatic const l_int32  DefaultMinCount = 40;     /*!< default minimum count */\nstatic const l_int32  DefaultBgVal = 200;       /*!< default bg value      */\nstatic const l_int32  DefaultXSmoothSize = 2;  /*!< default x smooth size */\nstatic const l_int32  DefaultYSmoothSize = 1;  /*!< default y smooth size */\n\nstatic l_int32 *iaaGetLinearTRC(l_int32 **iaa, l_int32 diff);\n\n#ifndef  NO_CONSOLE_IO\n#define  DEBUG_GLOBAL    0    /*!< set to 1 to debug pixGlobalNormNoSatRGB() */\n#endif  /* ~NO_CONSOLE_IO */\n\n/*------------------------------------------------------------------*\n *      Clean background to white using background normalization    *\n *------------------------------------------------------------------*/\n/*!\n * \\brief   pixCleanBackgroundToWhite()\n *\n * \\param[in]    pixs       8 bpp grayscale or 32 bpp rgb\n * \\param[in]    pixim      [optional] 1 bpp 'image' mask; can be null\n * \\param[in]    pixg       [optional] 8 bpp grayscale version; can be null\n * \\param[in]    gamma      gamma correction; must be > 0.0; typically ~1.0\n * \\param[in]    blackval   dark value to set to black (0)\n * \\param[in]    whiteval   light value to set to white (255)\n * \\return  pixd 8 bpp or 32 bpp rgb, or NULL on error\n *\n * <pre>\n * Notes:\n *    (1) This is a simplified interface for cleaning an image.\n *        For comparison, see pixAdaptThresholdToBinaryGen().\n *    (2) The suggested default values for the input parameters are:\n *          gamma:    1.0  (reduce this to increase the contrast; e.g.,\n *                          for light text)\n *          blackval   70  (a bit more than 60)\n *          whiteval  190  (a bit less than 200)\n * </pre>\n */\nPIX *\npixCleanBackgroundToWhite(PIX       *pixs,\n                          PIX       *pixim,\n                          PIX       *pixg,\n                          l_float32  gamma,\n                          l_int32    blackval,\n                          l_int32    whiteval)\n{\nl_int32  d;\nPIX     *pixd;\n\n    PROCNAME(\"pixCleanBackgroundToWhite\");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    d = pixGetDepth(pixs);\n    if (d != 8 && d != 32)\n        return (PIX *)ERROR_PTR(\"depth not 8 or 32\", procName, NULL);\n\n    pixd = pixBackgroundNormSimple(pixs, pixim, pixg);\n    if (!pixd)\n        return (PIX *)ERROR_PTR(\"background norm failedd\", procName, NULL);\n    pixGammaTRC(pixd, pixd, gamma, blackval, whiteval);\n    return pixd;\n}\n\n\n/*------------------------------------------------------------------*\n *                Adaptive background normalization                 *\n *------------------------------------------------------------------*/\n/*!\n * \\brief   pixBackgroundNormSimple()\n *\n * \\param[in]    pixs     8 bpp grayscale or 32 bpp rgb\n * \\param[in]    pixim    [optional] 1 bpp 'image' mask; can be null\n * \\param[in]    pixg     [optional] 8 bpp grayscale version; can be null\n * \\return  pixd 8 bpp or 32 bpp rgb, or NULL on error\n *\n * <pre>\n * Notes:\n *    (1) This is a simplified interface to pixBackgroundNorm(),\n *        where seven parameters are defaulted.\n *    (2) The input image is either grayscale or rgb.\n *    (3) See pixBackgroundNorm() for usage and function.\n * </pre>\n */\nPIX *\npixBackgroundNormSimple(PIX  *pixs,\n                        PIX  *pixim,\n                        PIX  *pixg)\n{\n    return pixBackgroundNorm(pixs, pixim, pixg,\n                             DefaultTileWidth, DefaultTileHeight,\n                             DefaultFgThreshold, DefaultMinCount,\n                             DefaultBgVal, DefaultXSmoothSize,\n                             DefaultYSmoothSize);\n}\n\n\n/*!\n * \\brief   pixBackgroundNorm()\n *\n * \\param[in]    pixs        8 bpp grayscale or 32 bpp rgb\n * \\param[in]    pixim       [optional] 1 bpp 'image' mask; can be null\n * \\param[in]    pixg        [optional] 8 bpp grayscale version; can be null\n * \\param[in]    sx, sy      tile size in pixels\n * \\param[in]    thresh      threshold for determining foreground\n * \\param[in]    mincount    min threshold on counts in a tile\n * \\param[in]    bgval       target bg val; typ. > 128\n * \\param[in]    smoothx     half-width of block convolution kernel width\n * \\param[in]    smoothy     half-width of block convolution kernel height\n * \\return  pixd 8 bpp or 32 bpp rgb, or NULL on error\n *\n * <pre>\n * Notes:\n *    (1) This is a top-level interface for normalizing the image intensity\n *        by mapping the image so that the background is near the input\n *        value 'bgval'.\n *    (2) The input image is either grayscale or rgb.\n *    (3) For each component in the input image, the background value\n *        in each tile is estimated using the values in the tile that\n *        are not part of the foreground, where the foreground is\n *        determined by the input 'thresh' argument.\n *    (4) An optional binary mask can be specified, with the foreground\n *        pixels typically over image regions.  The resulting background\n *        map values will be determined by surrounding pixels that are\n *        not under the mask foreground.  The origin (0,0) of this mask\n *        is assumed to be aligned with the origin of the input image.\n *        This binary mask must not fully cover pixs, because then there\n *        will be no pixels in the input image available to compute\n *        the background.\n *    (5) An optional grayscale version of the input pixs can be supplied.\n *        The only reason to do this is if the input is RGB and this\n *        grayscale version can be used elsewhere.  If the input is RGB\n *        and this is not supplied, it is made internally using only\n *        the green component, and destroyed after use.\n *    (6) The dimensions of the pixel tile (sx, sy) give the amount by\n *        by which the map is reduced in size from the input image.\n *    (7) The threshold is used to binarize the input image, in order to\n *        locate the foreground components.  If this is set too low,\n *        some actual foreground may be used to determine the maps;\n *        if set too high, there may not be enough background\n *        to determine the map values accurately.  Typically, it's\n *        better to err by setting the threshold too high.\n *    (8) A 'mincount' threshold is a minimum count of pixels in a\n *        tile for which a background reading is made, in order for that\n *        pixel in the map to be valid.  This number should perhaps be\n *        at least 1/3 the size of the tile.\n *    (9) A 'bgval' target background value for the normalized image.  This\n *        should be at least 128.  If set too close to 255, some\n *        clipping will occur in the result.\n *    (10) Two factors, 'smoothx' and 'smoothy', are input for smoothing\n *        the map.  Each low-pass filter kernel dimension is\n *        is 2 * (smoothing factor) + 1, so a\n *        value of 0 means no smoothing. A value of 1 or 2 is recommended.\n * </pre>\n */\nPIX *\npixBackgroundNorm(PIX     *pixs,\n                  PIX     *pixim,\n                  PIX     *pixg,\n                  l_int32  sx,\n                  l_int32  sy,\n                  l_int32  thresh,\n                  l_int32  mincount,\n                  l_int32  bgval,\n                  l_int32  smoothx,\n                  l_int32  smoothy)\n{\nl_int32  d, allfg;\nPIX     *pixm, *pixmi, *pixd;\nPIX     *pixmr, *pixmg, *pixmb, *pixmri, *pixmgi, *pixmbi;\n\n    PROCNAME(\"pixBackgroundNorm\");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    d = pixGetDepth(pixs);\n    if (d != 8 && d != 32)\n        return (PIX *)ERROR_PTR(\"pixs not 8 or 32 bpp\", procName, NULL);\n    if (sx < 4 || sy < 4)\n        return (PIX *)ERROR_PTR(\"sx and sy must be >= 4\", procName, NULL);\n    if (mincount > sx * sy) {\n        L_WARNING(\"mincount too large for tile size\\n\", procName);\n        mincount = (sx * sy) / 3;\n    }\n\n        /* If pixim exists, verify that it is not all foreground. */\n    if (pixim) {\n        pixInvert(pixim, pixim);\n        pixZero(pixim, &allfg);\n        pixInvert(pixim, pixim);\n        if (allfg)\n            return (PIX *)ERROR_PTR(\"pixim all foreground\", procName, NULL);\n    }\n\n    pixd = NULL;\n    if (d == 8) {\n        pixm = NULL;\n        pixGetBackgroundGrayMap(pixs, pixim, sx, sy, thresh, mincount, &pixm);\n        if (!pixm) {\n            L_WARNING(\"map not made; return a copy of the source\\n\", procName);\n            return pixCopy(NULL, pixs);\n        }\n\n        pixmi = pixGetInvBackgroundMap(pixm, bgval, smoothx, smoothy);\n        if (!pixmi) {\n            L_WARNING(\"pixmi not made; return a copy of source\\n\", procName);\n            pixDestroy(&pixm);\n            return pixCopy(NULL, pixs);\n        } else {\n            pixd = pixApplyInvBackgroundGrayMap(pixs, pixmi, sx, sy);\n        }\n\n        pixDestroy(&pixm);\n        pixDestroy(&pixmi);\n    }\n    else {\n        pixmr = pixmg = pixmb = NULL;\n        pixGetBackgroundRGBMap(pixs, pixim, pixg, sx, sy, thresh,\n                               mincount, &pixmr, &pixmg, &pixmb);\n        if (!pixmr || !pixmg || !pixmb) {\n            pixDestroy(&pixmr);\n            pixDestroy(&pixmg);\n            pixDestroy(&pixmb);\n            L_WARNING(\"map not made; return a copy of the source\\n\", procName);\n            return pixCopy(NULL, pixs);\n        }\n\n        pixmri = pixGetInvBackgroundMap(pixmr, bgval, smoothx, smoothy);\n        pixmgi = pixGetInvBackgroundMap(pixmg, bgval, smoothx, smoothy);\n        pixmbi = pixGetInvBackgroundMap(pixmb, bgval, smoothx, smoothy);\n        if (!pixmri || !pixmgi || !pixmbi) {\n            L_WARNING(\"not all pixm*i are made; return src copy\\n\", procName);\n            pixd = pixCopy(NULL, pixs);\n        } else {\n            pixd = pixApplyInvBackgroundRGBMap(pixs, pixmri, pixmgi, pixmbi,\n                                               sx, sy);\n        }\n\n        pixDestroy(&pixmr);\n        pixDestroy(&pixmg);\n        pixDestroy(&pixmb);\n        pixDestroy(&pixmri);\n        pixDestroy(&pixmgi);\n        pixDestroy(&pixmbi);\n    }\n\n    if (!pixd)\n        ERROR_PTR(\"pixd not made\", procName, NULL);\n    pixCopyResolution(pixd, pixs);\n    return pixd;\n}\n\n\n/*!\n * \\brief   pixBackgroundNormMorph()\n *\n * \\param[in]    pixs        8 bpp grayscale or 32 bpp rgb\n * \\param[in]    pixim       [optional] 1 bpp 'image' mask; can be null\n * \\param[in]    reduction   at which morph closings are done; between 2 and 16\n * \\param[in]    size        of square Sel for the closing; use an odd number\n * \\param[in]    bgval       target bg val; typ. > 128\n * \\return  pixd 8 bpp, or NULL on error\n *\n * <pre>\n * Notes:\n *    (1) This is a top-level interface for normalizing the image intensity\n *        by mapping the image so that the background is near the input\n *        value 'bgval'.\n *    (2) The input image is either grayscale or rgb.\n *    (3) For each component in the input image, the background value\n *        is estimated using a grayscale closing; hence the 'Morph'\n *        in the function name.\n *    (4) An optional binary mask can be specified, with the foreground\n *        pixels typically over image regions.  The resulting background\n *        map values will be determined by surrounding pixels that are\n *        not under the mask foreground.  The origin (0,0) of this mask\n *        is assumed to be aligned with the origin of the input image.\n *        This binary mask must not fully cover pixs, because then there\n *        will be no pixels in the input image available to compute\n *        the background.\n *    (5) The map is computed at reduced size (given by 'reduction')\n *        from the input pixs and optional pixim.  At this scale,\n *        pixs is closed to remove the background, using a square Sel\n *        of odd dimension.  The product of reduction * size should be\n *        large enough to remove most of the text foreground.\n *    (6) No convolutional smoothing needs to be done on the map before\n *        inverting it.\n *    (7) A 'bgval' target background value for the normalized image.  This\n *        should be at least 128.  If set too close to 255, some\n *        clipping will occur in the result.\n * </pre>\n */\nPIX *\npixBackgroundNormMorph(PIX     *pixs,\n                       PIX     *pixim,\n                       l_int32  reduction,\n                       l_int32  size,\n                       l_int32  bgval)\n{\nl_int32    d, allfg;\nPIX       *pixm, *pixmi, *pixd;\nPIX       *pixmr, *pixmg, *pixmb, *pixmri, *pixmgi, *pixmbi;\n\n    PROCNAME(\"pixBackgroundNormMorph\");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    d = pixGetDepth(pixs);\n    if (d != 8 && d != 32)\n        return (PIX *)ERROR_PTR(\"pixs not 8 or 32 bpp\", procName, NULL);\n    if (reduction < 2 || reduction > 16)\n        return (PIX *)ERROR_PTR(\"reduction must be between 2 and 16\",\n                                procName, NULL);\n\n        /* If pixim exists, verify that it is not all foreground. */\n    if (pixim) {\n        pixInvert(pixim, pixim);\n        pixZero(pixim, &allfg);\n        pixInvert(pixim, pixim);\n        if (allfg)\n            return (PIX *)ERROR_PTR(\"pixim all foreground\", procName, NULL);\n    }\n\n    pixd = NULL;\n    if (d == 8) {\n        pixGetBackgroundGrayMapMorph(pixs, pixim, reduction, size, &pixm);\n        if (!pixm)\n            return (PIX *)ERROR_PTR(\"pixm not made\", procName, NULL);\n        pixmi = pixGetInvBackgroundMap(pixm, bgval, 0, 0);\n        if (!pixmi)\n            ERROR_PTR(\"pixmi not made\", procName, NULL);\n        else\n            pixd = pixApplyInvBackgroundGrayMap(pixs, pixmi,\n                                                reduction, reduction);\n        pixDestroy(&pixm);\n        pixDestroy(&pixmi);\n    }\n    else {  /* d == 32 */\n        pixmr = pixmg = pixmb = NULL;\n        pixGetBackgroundRGBMapMorph(pixs, pixim, reduction, size,\n                                    &pixmr, &pixmg, &pixmb);\n        if (!pixmr || !pixmg || !pixmb) {\n            pixDestroy(&pixmr);\n            pixDestroy(&pixmg);\n            pixDestroy(&pixmb);\n            return (PIX *)ERROR_PTR(\"not all pixm*\", procName, NULL);\n        }\n\n        pixmri = pixGetInvBackgroundMap(pixmr, bgval, 0, 0);\n        pixmgi = pixGetInvBackgroundMap(pixmg, bgval, 0, 0);\n        pixmbi = pixGetInvBackgroundMap(pixmb, bgval, 0, 0);\n        if (!pixmri || !pixmgi || !pixmbi)\n            ERROR_PTR(\"not all pixm*i are made\", procName, NULL);\n        else\n            pixd = pixApplyInvBackgroundRGBMap(pixs, pixmri, pixmgi, pixmbi,\n                                               reduction, reduction);\n\n        pixDestroy(&pixmr);\n        pixDestroy(&pixmg);\n        pixDestroy(&pixmb);\n        pixDestroy(&pixmri);\n        pixDestroy(&pixmgi);\n        pixDestroy(&pixmbi);\n    }\n\n    if (!pixd)\n        ERROR_PTR(\"pixd not made\", procName, NULL);\n    pixCopyResolution(pixd, pixs);\n    return pixd;\n}\n\n\n/*-------------------------------------------------------------------------*\n *      Arrays of inverted background values for normalization             *\n *-------------------------------------------------------------------------*\n *  Notes for these four functions:                                        *\n *      (1) They are useful if you need to save the actual mapping array.  *\n *      (2) They could be used in the top-level functions but are          *\n *          not because their use makes those functions less clear.        *\n *      (3) Each component in the input pixs generates a 16 bpp pix array. *\n *-------------------------------------------------------------------------*/\n/*!\n * \\brief   pixBackgroundNormGrayArray()\n *\n * \\param[in]    pixs       8 bpp grayscale\n * \\param[in]    pixim      [optional] 1 bpp 'image' mask; can be null\n * \\param[in]    sx, sy     tile size in pixels\n * \\param[in]    thresh     threshold for determining foreground\n * \\param[in]    mincount   min threshold on counts in a tile\n * \\param[in]    bgval      target bg val; typ. > 128\n * \\param[in]    smoothx    half-width of block convolution kernel width\n * \\param[in]    smoothy    half-width of block convolution kernel height\n * \\param[out]   ppixd      16 bpp array of inverted background value\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *    (1) See notes in pixBackgroundNorm().\n *    (2) This returns a 16 bpp pix that can be used by\n *        pixApplyInvBackgroundGrayMap() to generate a normalized version\n *        of the input pixs.\n * </pre>\n */\nl_ok\npixBackgroundNormGrayArray(PIX     *pixs,\n                           PIX     *pixim,\n                           l_int32  sx,\n                           l_int32  sy,\n                           l_int32  thresh,\n                           l_int32  mincount,\n                           l_int32  bgval,\n                           l_int32  smoothx,\n                           l_int32  smoothy,\n                           PIX    **ppixd)\n{\nl_int32  allfg;\nPIX     *pixm;\n\n    PROCNAME(\"pixBackgroundNormGrayArray\");\n\n    if (!ppixd)\n        return ERROR_INT(\"&pixd not defined\", procName, 1);\n    *ppixd = NULL;\n    if (!pixs || pixGetDepth(pixs) != 8)\n        return ERROR_INT(\"pixs not defined or not 8 bpp\", procName, 1);\n    if (pixGetColormap(pixs))\n        return ERROR_INT(\"pixs is colormapped\", procName, 1);\n    if (pixim && pixGetDepth(pixim) != 1)\n        return ERROR_INT(\"pixim not 1 bpp\", procName, 1);\n    if (sx < 4 || sy < 4)\n        return ERROR_INT(\"sx and sy must be >= 4\", procName, 1);\n    if (mincount > sx * sy) {\n        L_WARNING(\"mincount too large for tile size\\n\", procName);\n        mincount = (sx * sy) / 3;\n    }\n\n        /* If pixim exists, verify that it is not all foreground. */\n    if (pixim) {\n        pixInvert(pixim, pixim);\n        pixZero(pixim, &allfg);\n        pixInvert(pixim, pixim);\n        if (allfg)\n            return ERROR_INT(\"pixim all foreground\", procName, 1);\n    }\n\n    pixGetBackgroundGrayMap(pixs, pixim, sx, sy, thresh, mincount, &pixm);\n    if (!pixm)\n        return ERROR_INT(\"pixm not made\", procName, 1);\n    *ppixd = pixGetInvBackgroundMap(pixm, bgval, smoothx, smoothy);\n    pixCopyResolution(*ppixd, pixs);\n    pixDestroy(&pixm);\n    return 0;\n}\n\n\n/*!\n * \\brief   pixBackgroundNormRGBArrays()\n *\n * \\param[in]    pixs       32 bpp rgb\n * \\param[in]    pixim      [optional] 1 bpp 'image' mask; can be null\n * \\param[in]    pixg       [optional] 8 bpp grayscale version; can be null\n * \\param[in]    sx, sy     tile size in pixels\n * \\param[in]    thresh     threshold for determining foreground\n * \\param[in]    mincount   min threshold on counts in a tile\n * \\param[in]    bgval      target bg val; typ. > 128\n * \\param[in]    smoothx    half-width of block convolution kernel width\n * \\param[in]    smoothy    half-width of block convolution kernel height\n * \\param[out]   ppixr      16 bpp array of inverted R background value\n * \\param[out]   ppixg      16 bpp array of inverted G background value\n * \\param[out]   ppixb      16 bpp array of inverted B background value\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *    (1) See notes in pixBackgroundNorm().\n *    (2) This returns a set of three 16 bpp pix that can be used by\n *        pixApplyInvBackgroundGrayMap() to generate a normalized version\n *        of each component of the input pixs.\n * </pre>\n */\nl_ok\npixBackgroundNormRGBArrays(PIX     *pixs,\n                           PIX     *pixim,\n                           PIX     *pixg,\n                           l_int32  sx,\n                           l_int32  sy,\n                           l_int32  thresh,\n                           l_int32  mincount,\n                           l_int32  bgval,\n                           l_int32  smoothx,\n                           l_int32  smoothy,\n                           PIX    **ppixr,\n                           PIX    **ppixg,\n                           PIX    **ppixb)\n{\nl_int32  allfg;\nPIX     *pixmr, *pixmg, *pixmb;\n\n    PROCNAME(\"pixBackgroundNormRGBArrays\");\n\n    if (!ppixr || !ppixg || !ppixb)\n        return ERROR_INT(\"&pixr, &pixg, &pixb not all defined\", procName, 1);\n    *ppixr = *ppixg = *ppixb = NULL;\n    if (!pixs)\n        return ERROR_INT(\"pixs not defined\", procName, 1);\n    if (pixGetDepth(pixs) != 32)\n        return ERROR_INT(\"pixs not 32 bpp\", procName, 1);\n    if (pixim && pixGetDepth(pixim) != 1)\n        return ERROR_INT(\"pixim not 1 bpp\", procName, 1);\n    if (sx < 4 || sy < 4)\n        return ERROR_INT(\"sx and sy must be >= 4\", procName, 1);\n    if (mincount > sx * sy) {\n        L_WARNING(\"mincount too large for tile size\\n\", procName);\n        mincount = (sx * sy) / 3;\n    }\n\n        /* If pixim exists, verify that it is not all foreground. */\n    if (pixim) {\n        pixInvert(pixim, pixim);\n        pixZero(pixim, &allfg);\n        pixInvert(pixim, pixim);\n        if (allfg)\n            return ERROR_INT(\"pixim all foreground\", procName, 1);\n    }\n\n    pixGetBackgroundRGBMap(pixs, pixim, pixg, sx, sy, thresh, mincount,\n                           &pixmr, &pixmg, &pixmb);\n    if (!pixmr || !pixmg || !pixmb) {\n        pixDestroy(&pixmr);\n        pixDestroy(&pixmg);\n        pixDestroy(&pixmb);\n        return ERROR_INT(\"not all pixm* made\", procName, 1);\n    }\n\n    *ppixr = pixGetInvBackgroundMap(pixmr, bgval, smoothx, smoothy);\n    *ppixg = pixGetInvBackgroundMap(pixmg, bgval, smoothx, smoothy);\n    *ppixb = pixGetInvBackgroundMap(pixmb, bgval, smoothx, smoothy);\n    pixDestroy(&pixmr);\n    pixDestroy(&pixmg);\n    pixDestroy(&pixmb);\n    return 0;\n}\n\n\n/*!\n * \\brief   pixBackgroundNormGrayArrayMorph()\n *\n * \\param[in]    pixs        8 bpp grayscale\n * \\param[in]    pixim       [optional] 1 bpp 'image' mask; can be null\n * \\param[in]    reduction   at which morph closings are done; between 2 and 16\n * \\param[in]    size        of square Sel for the closing; use an odd number\n * \\param[in]    bgval       target bg val; typ. > 128\n * \\param[out]   ppixd       16 bpp array of inverted background value\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *    (1) See notes in pixBackgroundNormMorph().\n *    (2) This returns a 16 bpp pix that can be used by\n *        pixApplyInvBackgroundGrayMap() to generate a normalized version\n *        of the input pixs.\n * </pre>\n */\nl_ok\npixBackgroundNormGrayArrayMorph(PIX     *pixs,\n                                PIX     *pixim,\n                                l_int32  reduction,\n                                l_int32  size,\n                                l_int32  bgval,\n                                PIX    **ppixd)\n{\nl_int32  allfg;\nPIX     *pixm;\n\n    PROCNAME(\"pixBackgroundNormGrayArrayMorph\");\n\n    if (!ppixd)\n        return ERROR_INT(\"&pixd not defined\", procName, 1);\n    *ppixd = NULL;\n    if (!pixs)\n        return ERROR_INT(\"pixs not defined\", procName, 1);\n    if (pixGetDepth(pixs) != 8)\n        return ERROR_INT(\"pixs not 8 bpp\", procName, 1);\n    if (pixim && pixGetDepth(pixim) != 1)\n        return ERROR_INT(\"pixim not 1 bpp\", procName, 1);\n    if (reduction < 2 || reduction > 16)\n        return ERROR_INT(\"reduction must be between 2 and 16\", procName, 1);\n\n        /* If pixim exists, verify that it is not all foreground. */\n    if (pixim) {\n        pixInvert(pixim, pixim);\n        pixZero(pixim, &allfg);\n        pixInvert(pixim, pixim);\n        if (allfg)\n            return ERROR_INT(\"pixim all foreground\", procName, 1);\n    }\n\n    pixGetBackgroundGrayMapMorph(pixs, pixim, reduction, size, &pixm);\n    if (!pixm)\n        return ERROR_INT(\"pixm not made\", procName, 1);\n    *ppixd = pixGetInvBackgroundMap(pixm, bgval, 0, 0);\n    pixCopyResolution(*ppixd, pixs);\n    pixDestroy(&pixm);\n    return 0;\n}\n\n\n/*!\n * \\brief   pixBackgroundNormRGBArraysMorph()\n *\n * \\param[in]    pixs        32 bpp rgb\n * \\param[in]    pixim       [optional] 1 bpp 'image' mask; can be null\n * \\param[in]    reduction   at which morph closings are done; between 2 and 16\n * \\param[in]    size        of square Sel for the closing; use an odd number\n * \\param[in]    bgval       target bg val; typ. > 128\n * \\param[out]   ppixr       16 bpp array of inverted R background value\n * \\param[out]   ppixg       16 bpp array of inverted G background value\n * \\param[out]   ppixb       16 bpp array of inverted B background value\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *    (1) See notes in pixBackgroundNormMorph().\n *    (2) This returns a set of three 16 bpp pix that can be used by\n *        pixApplyInvBackgroundGrayMap() to generate a normalized version\n *        of each component of the input pixs.\n * </pre>\n */\nl_ok\npixBackgroundNormRGBArraysMorph(PIX     *pixs,\n                                PIX     *pixim,\n                                l_int32  reduction,\n                                l_int32  size,\n                                l_int32  bgval,\n                                PIX    **ppixr,\n                                PIX    **ppixg,\n                                PIX    **ppixb)\n{\nl_int32  allfg;\nPIX     *pixmr, *pixmg, *pixmb;\n\n    PROCNAME(\"pixBackgroundNormRGBArraysMorph\");\n\n    if (!ppixr || !ppixg || !ppixb)\n        return ERROR_INT(\"&pixr, &pixg, &pixb not all defined\", procName, 1);\n    *ppixr = *ppixg = *ppixb = NULL;\n    if (!pixs)\n        return ERROR_INT(\"pixs not defined\", procName, 1);\n    if (pixGetDepth(pixs) != 32)\n        return ERROR_INT(\"pixs not 32 bpp\", procName, 1);\n    if (pixim && pixGetDepth(pixim) != 1)\n        return ERROR_INT(\"pixim not 1 bpp\", procName, 1);\n    if (reduction < 2 || reduction > 16)\n        return ERROR_INT(\"reduction must be between 2 and 16\", procName, 1);\n\n        /* If pixim exists, verify that it is not all foreground. */\n    if (pixim) {\n        pixInvert(pixim, pixim);\n        pixZero(pixim, &allfg);\n        pixInvert(pixim, pixim);\n        if (allfg)\n            return ERROR_INT(\"pixim all foreground\", procName, 1);\n    }\n\n    pixGetBackgroundRGBMapMorph(pixs, pixim, reduction, size,\n                                &pixmr, &pixmg, &pixmb);\n    if (!pixmr || !pixmg || !pixmb) {\n        pixDestroy(&pixmr);\n        pixDestroy(&pixmg);\n        pixDestroy(&pixmb);\n        return ERROR_INT(\"not all pixm* made\", procName, 1);\n    }\n\n    *ppixr = pixGetInvBackgroundMap(pixmr, bgval, 0, 0);\n    *ppixg = pixGetInvBackgroundMap(pixmg, bgval, 0, 0);\n    *ppixb = pixGetInvBackgroundMap(pixmb, bgval, 0, 0);\n    pixDestroy(&pixmr);\n    pixDestroy(&pixmg);\n    pixDestroy(&pixmb);\n    return 0;\n}\n\n\n/*------------------------------------------------------------------*\n *                 Measurement of local background                  *\n *------------------------------------------------------------------*/\n/*!\n * \\brief   pixGetBackgroundGrayMap()\n *\n * \\param[in]    pixs       8 bpp grayscale; not cmapped\n * \\param[in]    pixim      [optional] 1 bpp 'image' mask; can be null;\n *                          it should not have only foreground pixels\n * \\param[in]    sx, sy     tile size in pixels\n * \\param[in]    thresh     threshold for determining foreground\n * \\param[in]    mincount   min threshold on counts in a tile\n * \\param[out]   ppixd      8 bpp grayscale map\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) The background is measured in regions that don't have\n *          images.  It is then propagated into the image regions,\n *          and finally smoothed in each image region.\n * </pre>\n */\nl_ok\npixGetBackgroundGrayMap(PIX     *pixs,\n                        PIX     *pixim,\n                        l_int32  sx,\n                        l_int32  sy,\n                        l_int32  thresh,\n                        l_int32  mincount,\n                        PIX    **ppixd)\n{\nl_int32    w, h, wd, hd, wim, him, wpls, wplim, wpld, wplf;\nl_int32    xim, yim, delx, nx, ny, i, j, k, m;\nl_int32    count, sum, val8;\nl_int32    empty, fgpixels;\nl_uint32  *datas, *dataim, *datad, *dataf, *lines, *lineim, *lined, *linef;\nl_float32  scalex, scaley;\nPIX       *pixd, *piximi, *pixb, *pixf, *pixims;\n\n    PROCNAME(\"pixGetBackgroundGrayMap\");\n\n    if (!ppixd)\n        return ERROR_INT(\"&pixd not defined\", procName, 1);\n    *ppixd = NULL;\n    if (!pixs || pixGetDepth(pixs) != 8)\n        return ERROR_INT(\"pixs not defined or not 8 bpp\", procName, 1);\n    if (pixGetColormap(pixs))\n        return ERROR_INT(\"pixs is colormapped\", procName, 1);\n    if (pixim && pixGetDepth(pixim) != 1)\n        return ERROR_INT(\"pixim not 1 bpp\", procName, 1);\n    if (sx < 4 || sy < 4)\n        return ERROR_INT(\"sx and sy must be >= 4\", procName, 1);\n    if (mincount > sx * sy) {\n        L_WARNING(\"mincount too large for tile size\\n\", procName);\n        mincount = (sx * sy) / 3;\n    }\n\n        /* Evaluate the 'image' mask, pixim, and make sure\n         * it is not all fg. */\n    fgpixels = 0;  /* boolean for existence of fg pixels in the image mask. */\n    if (pixim) {\n        piximi = pixInvert(NULL, pixim);  /* set non-'image' pixels to 1 */\n        pixZero(piximi, &empty);\n        pixDestroy(&piximi);\n        if (empty)\n            return ERROR_INT(\"pixim all fg; no background\", procName, 1);\n        pixZero(pixim, &empty);\n        if (!empty)  /* there are fg pixels in pixim */\n            fgpixels = 1;\n    }\n\n        /* Generate the foreground mask, pixf, which is at\n         * full resolution.  These pixels will be ignored when\n         * computing the background values. */\n    pixb = pixThresholdToBinary(pixs, thresh);\n    pixf = pixMorphSequence(pixb, \"d7.1 + d1.7\", 0);\n    pixDestroy(&pixb);\n\n\n    /* ------------- Set up the output map pixd --------------- */\n        /* Generate pixd, which is reduced by the factors (sx, sy). */\n    w = pixGetWidth(pixs);\n    h = pixGetHeight(pixs);\n    wd = (w + sx - 1) / sx;\n    hd = (h + sy - 1) / sy;\n    pixd = pixCreate(wd, hd, 8);\n\n        /* Note: we only compute map values in tiles that are complete.\n         * In general, tiles at right and bottom edges will not be\n         * complete, and we must fill them in later. */\n    nx = w / sx;\n    ny = h / sy;\n    wpls = pixGetWpl(pixs);\n    datas = pixGetData(pixs);\n    wpld = pixGetWpl(pixd);\n    datad = pixGetData(pixd);\n    wplf = pixGetWpl(pixf);\n    dataf = pixGetData(pixf);\n    for (i = 0; i < ny; i++) {\n        lines = datas + sy * i * wpls;\n        linef = dataf + sy * i * wplf;\n        lined = datad + i * wpld;\n        for (j = 0; j < nx; j++) {\n            delx = j * sx;\n            sum = 0;\n            count = 0;\n            for (k = 0; k < sy; k++) {\n                for (m = 0; m < sx; m++) {\n                    if (GET_DATA_BIT(linef + k * wplf, delx + m) == 0) {\n                        sum += GET_DATA_BYTE(lines + k * wpls, delx + m);\n                        count++;\n                    }\n                }\n            }\n            if (count >= mincount) {\n                val8 = sum / count;\n                SET_DATA_BYTE(lined, j, val8);\n            }\n        }\n    }\n    pixDestroy(&pixf);\n\n        /* If there is an optional mask with fg pixels, erase the previous\n         * calculation for the corresponding map pixels, setting the\n         * map values to 0.   Then, when all the map holes are filled,\n         * these erased pixels will be set by the surrounding map values.\n         *\n         * The calculation here is relatively efficient: for each pixel\n         * in pixd (which corresponds to a tile of mask pixels in pixim)\n         * we look only at the pixel in pixim that is at the center\n         * of the tile.  If the mask pixel is ON, we reset the map\n         * pixel in pixd to 0, so that it can later be filled in. */\n    pixims = NULL;\n    if (pixim && fgpixels) {\n        wim = pixGetWidth(pixim);\n        him = pixGetHeight(pixim);\n        dataim = pixGetData(pixim);\n        wplim = pixGetWpl(pixim);\n        for (i = 0; i < ny; i++) {\n            yim = i * sy + sy / 2;\n            if (yim >= him)\n                break;\n            lineim = dataim + yim * wplim;\n            for (j = 0; j < nx; j++) {\n                xim = j * sx + sx / 2;\n                if (xim >= wim)\n                    break;\n                if (GET_DATA_BIT(lineim, xim))\n                    pixSetPixel(pixd, j, i, 0);\n            }\n        }\n    }\n\n        /* Fill all the holes in the map. */\n    if (pixFillMapHoles(pixd, nx, ny, L_FILL_BLACK)) {\n        pixDestroy(&pixd);\n        L_WARNING(\"can't make the map\\n\", procName);\n        return 1;\n    }\n\n        /* Finally, for each connected region corresponding to the\n         * 'image' mask, reset all pixels to their average value.\n         * Each of these components represents an image (or part of one)\n         * in the input, and this smooths the background values\n         * in each of these regions. */\n    if (pixim && fgpixels) {\n        scalex = 1. / (l_float32)sx;\n        scaley = 1. / (l_float32)sy;\n        pixims = pixScaleBySampling(pixim, scalex, scaley);\n        pixSmoothConnectedRegions(pixd, pixims, 2);\n        pixDestroy(&pixims);\n    }\n\n    *ppixd = pixd;\n    pixCopyResolution(*ppixd, pixs);\n    return 0;\n}\n\n\n/*!\n * \\brief   pixGetBackgroundRGBMap()\n *\n * \\param[in]    pixs       32 bpp rgb\n * \\param[in]    pixim      [optional] 1 bpp 'image' mask; can be null; it\n *                          should not have all foreground pixels\n * \\param[in]    pixg       [optional] 8 bpp grayscale version; can be null\n * \\param[in]    sx, sy     tile size in pixels\n * \\param[in]    thresh     threshold for determining foreground\n * \\param[in]    mincount   min threshold on counts in a tile\n * \\param[out]   ppixmr     red component map\n * \\param[out]   ppixmg     green component map\n * \\param[out]   ppixmb     blue component map\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) If pixg, which is a grayscale version of pixs, is provided,\n *          use this internally to generate the foreground mask.\n *          Otherwise, a grayscale version of pixs will be generated\n *          from the green component only, used, and destroyed.\n * </pre>\n */\nl_ok\npixGetBackgroundRGBMap(PIX     *pixs,\n                       PIX     *pixim,\n                       PIX     *pixg,\n                       l_int32  sx,\n                       l_int32  sy,\n                       l_int32  thresh,\n                       l_int32  mincount,\n                       PIX    **ppixmr,\n                       PIX    **ppixmg,\n                       PIX    **ppixmb)\n{\nl_int32    w, h, wm, hm, wim, him, wpls, wplim, wplf;\nl_int32    xim, yim, delx, nx, ny, i, j, k, m;\nl_int32    count, rsum, gsum, bsum, rval, gval, bval;\nl_int32    empty, fgpixels;\nl_uint32   pixel;\nl_uint32  *datas, *dataim, *dataf, *lines, *lineim, *linef;\nl_float32  scalex, scaley;\nPIX       *piximi, *pixgc, *pixb, *pixf, *pixims;\nPIX       *pixmr, *pixmg, *pixmb;\n\n    PROCNAME(\"pixGetBackgroundRGBMap\");\n\n    if (!ppixmr || !ppixmg || !ppixmb)\n        return ERROR_INT(\"&pixm* not all defined\", procName, 1);\n    *ppixmr = *ppixmg = *ppixmb = NULL;\n    if (!pixs)\n        return ERROR_INT(\"pixs not defined\", procName, 1);\n    if (pixGetDepth(pixs) != 32)\n        return ERROR_INT(\"pixs not 32 bpp\", procName, 1);\n    if (pixim && pixGetDepth(pixim) != 1)\n        return ERROR_INT(\"pixim not 1 bpp\", procName, 1);\n    if (sx < 4 || sy < 4)\n        return ERROR_INT(\"sx and sy must be >= 4\", procName, 1);\n    if (mincount > sx * sy) {\n        L_WARNING(\"mincount too large for tile size\\n\", procName);\n        mincount = (sx * sy) / 3;\n    }\n\n        /* Evaluate the mask pixim and make sure it is not all foreground */\n    fgpixels = 0;  /* boolean for existence of fg mask pixels */\n    if (pixim) {\n        piximi = pixInvert(NULL, pixim);  /* set non-'image' pixels to 1 */\n        pixZero(piximi, &empty);\n        pixDestroy(&piximi);\n        if (empty)\n            return ERROR_INT(\"pixim all fg; no background\", procName, 1);\n        pixZero(pixim, &empty);\n        if (!empty)  /* there are fg pixels in pixim */\n            fgpixels = 1;\n    }\n\n        /* Generate the foreground mask.  These pixels will be\n         * ignored when computing the background values. */\n    if (pixg)  /* use the input grayscale version if it is provided */\n        pixgc = pixClone(pixg);\n    else\n        pixgc = pixConvertRGBToGrayFast(pixs);\n    pixb = pixThresholdToBinary(pixgc, thresh);\n    pixf = pixMorphSequence(pixb, \"d7.1 + d1.7\", 0);\n    pixDestroy(&pixgc);\n    pixDestroy(&pixb);\n\n        /* Generate the output mask images */\n    w = pixGetWidth(pixs);\n    h = pixGetHeight(pixs);\n    wm = (w + sx - 1) / sx;\n    hm = (h + sy - 1) / sy;\n    pixmr = pixCreate(wm, hm, 8);\n    pixmg = pixCreate(wm, hm, 8);\n    pixmb = pixCreate(wm, hm, 8);\n\n    /* ------------- Set up the mapping images --------------- */\n        /* Note: we only compute map values in tiles that are complete.\n         * In general, tiles at right and bottom edges will not be\n         * complete, and we must fill them in later. */\n    nx = w / sx;\n    ny = h / sy;\n    wpls = pixGetWpl(pixs);\n    datas = pixGetData(pixs);\n    wplf = pixGetWpl(pixf);\n    dataf = pixGetData(pixf);\n    for (i = 0; i < ny; i++) {\n        lines = datas + sy * i * wpls;\n        linef = dataf + sy * i * wplf;\n        for (j = 0; j < nx; j++) {\n            delx = j * sx;\n            rsum = gsum = bsum = 0;\n            count = 0;\n            for (k = 0; k < sy; k++) {\n                for (m = 0; m < sx; m++) {\n                    if (GET_DATA_BIT(linef + k * wplf, delx + m) == 0) {\n                        pixel = *(lines + k * wpls + delx + m);\n                        rsum += (pixel >> 24);\n                        gsum += ((pixel >> 16) & 0xff);\n                        bsum += ((pixel >> 8) & 0xff);\n                        count++;\n                    }\n                }\n            }\n            if (count >= mincount) {\n                rval = rsum / count;\n                gval = gsum / count;\n                bval = bsum / count;\n                pixSetPixel(pixmr, j, i, rval);\n                pixSetPixel(pixmg, j, i, gval);\n                pixSetPixel(pixmb, j, i, bval);\n            }\n        }\n    }\n    pixDestroy(&pixf);\n\n        /* If there is an optional mask with fg pixels, erase the previous\n         * calculation for the corresponding map pixels, setting the\n         * map values in each of the 3 color maps to 0.   Then, when\n         * all the map holes are filled, these erased pixels will\n         * be set by the surrounding map values. */\n    if (pixim) {\n        wim = pixGetWidth(pixim);\n        him = pixGetHeight(pixim);\n        dataim = pixGetData(pixim);\n        wplim = pixGetWpl(pixim);\n        for (i = 0; i < ny; i++) {\n            yim = i * sy + sy / 2;\n            if (yim >= him)\n                break;\n            lineim = dataim + yim * wplim;\n            for (j = 0; j < nx; j++) {\n                xim = j * sx + sx / 2;\n                if (xim >= wim)\n                    break;\n                if (GET_DATA_BIT(lineim, xim)) {\n                    pixSetPixel(pixmr, j, i, 0);\n                    pixSetPixel(pixmg, j, i, 0);\n                    pixSetPixel(pixmb, j, i, 0);\n                }\n            }\n        }\n    }\n\n    /* ----------------- Now fill in the holes ----------------------- */\n    if (pixFillMapHoles(pixmr, nx, ny, L_FILL_BLACK) ||\n        pixFillMapHoles(pixmg, nx, ny, L_FILL_BLACK) ||\n        pixFillMapHoles(pixmb, nx, ny, L_FILL_BLACK)) {\n        pixDestroy(&pixmr);\n        pixDestroy(&pixmg);\n        pixDestroy(&pixmb);\n        L_WARNING(\"can't make the maps\\n\", procName);\n        return 1;\n    }\n\n        /* Finally, for each connected region corresponding to the\n         * fg mask, reset all pixels to their average value. */\n    if (pixim && fgpixels) {\n        scalex = 1. / (l_float32)sx;\n        scaley = 1. / (l_float32)sy;\n        pixims = pixScaleBySampling(pixim, scalex, scaley);\n        pixSmoothConnectedRegions(pixmr, pixims, 2);\n        pixSmoothConnectedRegions(pixmg, pixims, 2);\n        pixSmoothConnectedRegions(pixmb, pixims, 2);\n        pixDestroy(&pixims);\n    }\n\n    *ppixmr = pixmr;\n    *ppixmg = pixmg;\n    *ppixmb = pixmb;\n    pixCopyResolution(*ppixmr, pixs);\n    pixCopyResolution(*ppixmg, pixs);\n    pixCopyResolution(*ppixmb, pixs);\n    return 0;\n}\n\n\n/*!\n * \\brief   pixGetBackgroundGrayMapMorph()\n *\n * \\param[in]    pixs        8 bpp grayscale; not cmapped\n * \\param[in]    pixim       [optional] 1 bpp 'image' mask; can be null; it\n *                           should not have all foreground pixels\n * \\param[in]    reduction   factor at which closing is performed\n * \\param[in]    size        of square Sel for the closing; use an odd number\n * \\param[out]   ppixm       grayscale map\n * \\return  0 if OK, 1 on error\n */\nl_ok\npixGetBackgroundGrayMapMorph(PIX     *pixs,\n                             PIX     *pixim,\n                             l_int32  reduction,\n                             l_int32  size,\n                             PIX    **ppixm)\n{\nl_int32    nx, ny, empty, fgpixels;\nl_float32  scale;\nPIX       *pixm, *pix1, *pix2, *pix3, *pixims;\n\n    PROCNAME(\"pixGetBackgroundGrayMapMorph\");\n\n    if (!ppixm)\n        return ERROR_INT(\"&pixm not defined\", procName, 1);\n    *ppixm = NULL;\n    if (!pixs || pixGetDepth(pixs) != 8)\n        return ERROR_INT(\"pixs not defined or not 8 bpp\", procName, 1);\n    if (pixGetColormap(pixs))\n        return ERROR_INT(\"pixs is colormapped\", procName, 1);\n    if (pixim && pixGetDepth(pixim) != 1)\n        return ERROR_INT(\"pixim not 1 bpp\", procName, 1);\n\n        /* Evaluate the mask pixim and make sure it is not all foreground. */\n    fgpixels = 0;  /* boolean for existence of fg mask pixels */\n    if (pixim) {\n        pixInvert(pixim, pixim);  /* set background pixels to 1 */\n        pixZero(pixim, &empty);\n        if (empty)\n            return ERROR_INT(\"pixim all fg; no background\", procName, 1);\n        pixInvert(pixim, pixim);  /* revert to original mask */\n        pixZero(pixim, &empty);\n        if (!empty)  /* there are fg pixels in pixim */\n            fgpixels = 1;\n    }\n\n        /* Downscale as requested and do the closing to get the background. */\n    scale = 1. / (l_float32)reduction;\n    pix1 = pixScaleBySampling(pixs, scale, scale);\n    pix2 = pixCloseGray(pix1, size, size);\n    pix3 = pixExtendByReplication(pix2, 1, 1);\n    pixDestroy(&pix1);\n    pixDestroy(&pix2);\n\n        /* Downscale the image mask, if any, and remove it from the\n         * background.  These pixels will be filled in (twice). */\n    pixims = NULL;\n    if (pixim) {\n        pixims = pixScale(pixim, scale, scale);\n        pixm = pixConvertTo8(pixims, FALSE);\n        pixAnd(pixm, pixm, pix3);\n    }\n    else\n        pixm = pixClone(pix3);\n    pixDestroy(&pix3);\n\n        /* Fill all the holes in the map. */\n    nx = pixGetWidth(pixs) / reduction;\n    ny = pixGetHeight(pixs) / reduction;\n    if (pixFillMapHoles(pixm, nx, ny, L_FILL_BLACK)) {\n        pixDestroy(&pixm);\n        pixDestroy(&pixims);\n        L_WARNING(\"can't make the map\\n\", procName);\n        return 1;\n    }\n\n        /* Finally, for each connected region corresponding to the\n         * fg mask, reset all pixels to their average value. */\n    if (pixim && fgpixels)\n        pixSmoothConnectedRegions(pixm, pixims, 2);\n    pixDestroy(&pixims);\n\n    *ppixm = pixm;\n    pixCopyResolution(*ppixm, pixs);\n    return 0;\n}\n\n\n/*!\n * \\brief   pixGetBackgroundRGBMapMorph()\n *\n * \\param[in]    pixs        32 bpp rgb\n * \\param[in]    pixim       [optional] 1 bpp 'image' mask; can be null; it\n *                           should not have all foreground pixels\n * \\param[in]    reduction   factor at which closing is performed\n * \\param[in]    size        of square Sel for the closing; use an odd number\n * \\param[out]   ppixmr      red component map\n * \\param[out]   ppixmg      green component map\n * \\param[out]   ppixmb      blue component map\n * \\return  0 if OK, 1 on error\n */\nl_ok\npixGetBackgroundRGBMapMorph(PIX     *pixs,\n                            PIX     *pixim,\n                            l_int32  reduction,\n                            l_int32  size,\n                            PIX    **ppixmr,\n                            PIX    **ppixmg,\n                            PIX    **ppixmb)\n{\nl_int32    nx, ny, empty, fgpixels;\nl_float32  scale;\nPIX       *pixm, *pixmr, *pixmg, *pixmb, *pix1, *pix2, *pix3, *pixims;\n\n    PROCNAME(\"pixGetBackgroundRGBMapMorph\");\n\n    if (!ppixmr || !ppixmg || !ppixmb)\n        return ERROR_INT(\"&pixm* not all defined\", procName, 1);\n    *ppixmr = *ppixmg = *ppixmb = NULL;\n    if (!pixs)\n        return ERROR_INT(\"pixs not defined\", procName, 1);\n    if (pixGetDepth(pixs) != 32)\n        return ERROR_INT(\"pixs not 32 bpp\", procName, 1);\n    if (pixim && pixGetDepth(pixim) != 1)\n        return ERROR_INT(\"pixim not 1 bpp\", procName, 1);\n\n        /* Evaluate the mask pixim and make sure it is not all foreground. */\n    fgpixels = 0;  /* boolean for existence of fg mask pixels */\n    if (pixim) {\n        pixInvert(pixim, pixim);  /* set background pixels to 1 */\n        pixZero(pixim, &empty);\n        if (empty)\n            return ERROR_INT(\"pixim all fg; no background\", procName, 1);\n        pixInvert(pixim, pixim);  /* revert to original mask */\n        pixZero(pixim, &empty);\n        if (!empty)  /* there are fg pixels in pixim */\n            fgpixels = 1;\n    }\n\n        /* Generate an 8 bpp version of the image mask, if it exists */\n    scale = 1. / (l_float32)reduction;\n    pixims = NULL;\n    pixm = NULL;\n    if (pixim) {\n        pixims = pixScale(pixim, scale, scale);\n        pixm = pixConvertTo8(pixims, FALSE);\n    }\n\n        /* Downscale as requested and do the closing to get the background.\n         * Then remove the image mask pixels from the background.  They\n         * will be filled in (twice) later.  Do this for all 3 components. */\n    pix1 = pixScaleRGBToGrayFast(pixs, reduction, COLOR_RED);\n    pix2 = pixCloseGray(pix1, size, size);\n    pix3 = pixExtendByReplication(pix2, 1, 1);\n    if (pixim)\n        pixmr = pixAnd(NULL, pixm, pix3);\n    else\n        pixmr = pixClone(pix3);\n    pixDestroy(&pix1);\n    pixDestroy(&pix2);\n    pixDestroy(&pix3);\n\n    pix1 = pixScaleRGBToGrayFast(pixs, reduction, COLOR_GREEN);\n    pix2 = pixCloseGray(pix1, size, size);\n    pix3 = pixExtendByReplication(pix2, 1, 1);\n    if (pixim)\n        pixmg = pixAnd(NULL, pixm, pix3);\n    else\n        pixmg = pixClone(pix3);\n    pixDestroy(&pix1);\n    pixDestroy(&pix2);\n    pixDestroy(&pix3);\n\n    pix1 = pixScaleRGBToGrayFast(pixs, reduction, COLOR_BLUE);\n    pix2 = pixCloseGray(pix1, size, size);\n    pix3 = pixExtendByReplication(pix2, 1, 1);\n    if (pixim)\n        pixmb = pixAnd(NULL, pixm, pix3);\n    else\n        pixmb = pixClone(pix3);\n    pixDestroy(&pixm);\n    pixDestroy(&pix1);\n    pixDestroy(&pix2);\n    pixDestroy(&pix3);\n\n        /* Fill all the holes in the three maps. */\n    nx = pixGetWidth(pixs) / reduction;\n    ny = pixGetHeight(pixs) / reduction;\n    if (pixFillMapHoles(pixmr, nx, ny, L_FILL_BLACK) ||\n        pixFillMapHoles(pixmg, nx, ny, L_FILL_BLACK) ||\n        pixFillMapHoles(pixmb, nx, ny, L_FILL_BLACK)) {\n        pixDestroy(&pixmr);\n        pixDestroy(&pixmg);\n        pixDestroy(&pixmb);\n        pixDestroy(&pixims);\n        L_WARNING(\"can't make the maps\\n\", procName);\n        return 1;\n    }\n\n        /* Finally, for each connected region corresponding to the\n         * fg mask in each component, reset all pixels to their\n         * average value. */\n    if (pixim && fgpixels) {\n        pixSmoothConnectedRegions(pixmr, pixims, 2);\n        pixSmoothConnectedRegions(pixmg, pixims, 2);\n        pixSmoothConnectedRegions(pixmb, pixims, 2);\n        pixDestroy(&pixims);\n    }\n\n    *ppixmr = pixmr;\n    *ppixmg = pixmg;\n    *ppixmb = pixmb;\n    pixCopyResolution(*ppixmr, pixs);\n    pixCopyResolution(*ppixmg, pixs);\n    pixCopyResolution(*ppixmb, pixs);\n    return 0;\n}\n\n\n/*!\n * \\brief   pixFillMapHoles()\n *\n * \\param[in]    pix        8 bpp; a map, with one pixel for each tile in\n *                          a larger image\n * \\param[in]    nx         number of horizontal pixel tiles that are entirely\n *                          covered with pixels in the original source image\n * \\param[in]    ny         ditto for the number of vertical pixel tiles\n * \\param[in]    filltype   L_FILL_WHITE or L_FILL_BLACK\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) This is an in-place operation on pix (the map).  pix is\n *          typically a low-resolution version of some other image\n *          from which it was derived, where each pixel in pix\n *          corresponds to a rectangular tile (say, m x n) of pixels\n *          in the larger image.  All we need to know about the larger\n *          image is whether or not the rightmost column and bottommost\n *          row of pixels in pix correspond to tiles that are\n *          only partially covered by pixels in the larger image.\n *      (2) Typically, some number of pixels in the input map are\n *          not known, and their values must be determined by near\n *          pixels that are known.  These unknown pixels are the 'holes'.\n *          They can take on only two values, 0 and 255, and the\n *          instruction about which to fill is given by the filltype flag.\n *      (3) The \"holes\" can come from two sources.  The first is when there\n *          are not enough foreground or background pixels in a tile;\n *          the second is when a tile is at least partially covered\n *          by an image mask.  If we're filling holes in a fg mask,\n *          the holes are initialized to black (0) and use L_FILL_BLACK.\n *          For filling holes in a bg mask, initialize the holes to\n *          white (255) and use L_FILL_WHITE.\n *      (4) If w is the map width, nx = w or nx = w - 1; ditto for h and ny.\n * </pre>\n */\nl_ok\npixFillMapHoles(PIX     *pix,\n                l_int32  nx,\n                l_int32  ny,\n                l_int32  filltype)\n{\nl_int32   w, h, y, nmiss, goodcol, i, j, found, ival, valtest;\nl_uint32  val, lastval;\nNUMA     *na;  /* indicates if there is any data in the column */\n\n    PROCNAME(\"pixFillMapHoles\");\n\n    if (!pix || pixGetDepth(pix) != 8)\n        return ERROR_INT(\"pix not defined or not 8 bpp\", procName, 1);\n    if (pixGetColormap(pix))\n        return ERROR_INT(\"pix is colormapped\", procName, 1);\n\n    /* ------------- Fill holes in the mapping image columns ----------- */\n    pixGetDimensions(pix, &w, &h, NULL);\n    na = numaCreate(0);  /* holds flag for which columns have data */\n    nmiss = 0;\n    valtest = (filltype == L_FILL_WHITE) ? 255 : 0;\n    for (j = 0; j < nx; j++) {  /* do it by columns */\n        found = FALSE;\n        for (i = 0; i < ny; i++) {\n            pixGetPixel(pix, j, i, &val);\n            if (val != valtest) {\n                y = i;\n                found = TRUE;\n                break;\n            }\n        }\n        if (found == FALSE) {\n            numaAddNumber(na, 0);  /* no data in the column */\n            nmiss++;\n        }\n        else {\n            numaAddNumber(na, 1);  /* data in the column */\n            for (i = y - 1; i >= 0; i--)  /* replicate upwards to top */\n                pixSetPixel(pix, j, i, val);\n            pixGetPixel(pix, j, 0, &lastval);\n            for (i = 1; i < h; i++) {  /* set going down to bottom */\n                pixGetPixel(pix, j, i, &val);\n                if (val == valtest)\n                    pixSetPixel(pix, j, i, lastval);\n                else\n                    lastval = val;\n            }\n        }\n    }\n    numaAddNumber(na, 0);  /* last column */\n\n    if (nmiss == nx) {  /* no data in any column! */\n        numaDestroy(&na);\n        L_WARNING(\"no bg found; no data in any column\\n\", procName);\n        return 1;\n    }\n\n    /* ---------- Fill in missing columns by replication ----------- */\n    if (nmiss > 0) {  /* replicate columns */\n            /* Find the first good column */\n        goodcol = 0;\n        for (j = 0; j < w; j++) {\n            numaGetIValue(na, j, &ival);\n            if (ival == 1) {\n                goodcol = j;\n                break;\n            }\n        }\n        if (goodcol > 0) {  /* copy cols backward */\n            for (j = goodcol - 1; j >= 0; j--)\n                pixRasterop(pix, j, 0, 1, h, PIX_SRC, pix, j + 1, 0);\n        }\n        for (j = goodcol + 1; j < w; j++) {   /* copy cols forward */\n            numaGetIValue(na, j, &ival);\n            if (ival == 0) {\n                    /* Copy the column to the left of j */\n                pixRasterop(pix, j, 0, 1, h, PIX_SRC, pix, j - 1, 0);\n            }\n        }\n    }\n    if (w > nx) {  /* replicate the last column */\n        for (i = 0; i < h; i++) {\n            pixGetPixel(pix, w - 2, i, &val);\n            pixSetPixel(pix, w - 1, i, val);\n        }\n    }\n\n    numaDestroy(&na);\n    return 0;\n}\n\n\n/*!\n * \\brief   pixExtendByReplication()\n *\n * \\param[in]    pixs    8 bpp\n * \\param[in]    addw    number of extra pixels horizontally to add\n * \\param[in]    addh    number of extra pixels vertically to add\n * \\return  pixd extended with replicated pixel values, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) The pixel values are extended to the left and down, as required.\n * </pre>\n */\nPIX *\npixExtendByReplication(PIX     *pixs,\n                       l_int32  addw,\n                       l_int32  addh)\n{\nl_int32   w, h, i, j;\nl_uint32  val;\nPIX      *pixd;\n\n    PROCNAME(\"pixExtendByReplication\");\n\n    if (!pixs || pixGetDepth(pixs) != 8)\n        return (PIX *)ERROR_PTR(\"pixs undefined or not 8 bpp\", procName, NULL);\n\n    if (addw == 0 && addh == 0)\n        return pixCopy(NULL, pixs);\n\n    pixGetDimensions(pixs, &w, &h, NULL);\n    if ((pixd = pixCreate(w + addw, h + addh, 8)) == NULL)\n        return (PIX *)ERROR_PTR(\"pixd not made\", procName, NULL);\n    pixRasterop(pixd, 0, 0, w, h, PIX_SRC, pixs, 0, 0);\n\n    if (addw > 0) {\n        for (i = 0; i < h; i++) {\n            pixGetPixel(pixd, w - 1, i, &val);\n            for (j = 0; j < addw; j++)\n                pixSetPixel(pixd, w + j, i, val);\n        }\n    }\n\n    if (addh > 0) {\n        for (j = 0; j < w + addw; j++) {\n            pixGetPixel(pixd, j, h - 1, &val);\n            for (i = 0; i < addh; i++)\n                pixSetPixel(pixd, j, h + i, val);\n        }\n    }\n\n    pixCopyResolution(pixd, pixs);\n    return pixd;\n}\n\n\n/*!\n * \\brief   pixSmoothConnectedRegions()\n *\n * \\param[in]    pixs    8 bpp grayscale; no colormap\n * \\param[in]    pixm    [optional] 1 bpp; if null, this is a no-op\n * \\param[in]    factor  subsampling factor for getting average; >= 1\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) The pixels in pixs corresponding to those in each\n *          8-connected region in the mask are set to the average value.\n *      (2) This is required for adaptive mapping to avoid the\n *          generation of stripes in the background map, due to\n *          variations in the pixel values near the edges of mask regions.\n *      (3) This function is optimized for background smoothing, where\n *          there are a relatively small number of components.  It will\n *          be inefficient if used where there are many small components.\n * </pre>\n */\nl_ok\npixSmoothConnectedRegions(PIX     *pixs,\n                          PIX     *pixm,\n                          l_int32  factor)\n{\nl_int32    empty, i, n, x, y;\nl_float32  aveval;\nBOXA      *boxa;\nPIX       *pixmc;\nPIXA      *pixa;\n\n    PROCNAME(\"pixSmoothConnectedRegions\");\n\n    if (!pixs || pixGetDepth(pixs) != 8)\n        return ERROR_INT(\"pixs not defined or not 8 bpp\", procName, 1);\n    if (pixGetColormap(pixs))\n        return ERROR_INT(\"pixs has colormap\", procName, 1);\n    if (!pixm) {\n        L_INFO(\"pixm not defined\\n\", procName);\n        return 0;\n    }\n    if (pixGetDepth(pixm) != 1)\n        return ERROR_INT(\"pixm not 1 bpp\", procName, 1);\n    pixZero(pixm, &empty);\n    if (empty) {\n        L_INFO(\"pixm has no fg pixels; nothing to do\\n\", procName);\n        return 0;\n    }\n\n    boxa = pixConnComp(pixm, &pixa, 8);\n    n = boxaGetCount(boxa);\n    for (i = 0; i < n; i++) {\n        if ((pixmc = pixaGetPix(pixa, i, L_CLONE)) == NULL) {\n            L_WARNING(\"missing pixmc!\\n\", procName);\n            continue;\n        }\n        boxaGetBoxGeometry(boxa, i, &x, &y, NULL, NULL);\n        pixGetAverageMasked(pixs, pixmc, x, y, factor, L_MEAN_ABSVAL, &aveval);\n        pixPaintThroughMask(pixs, pixmc, x, y, (l_int32)aveval);\n        pixDestroy(&pixmc);\n    }\n\n    boxaDestroy(&boxa);\n    pixaDestroy(&pixa);\n    return 0;\n}\n\n\n/*------------------------------------------------------------------*\n *                 Measurement of local foreground                  *\n *------------------------------------------------------------------*/\n#if 0    /* Not working properly: do not use */\n\n/*!\n * \\brief   pixGetForegroundGrayMap()\n *\n * \\param[in]    pixs      8 bpp\n * \\param[in]    pixim     [optional] 1 bpp 'image' mask; can be null\n * \\param[in]    sx, sy    src tile size, in pixels\n * \\param[in]    thresh    threshold for determining foreground\n * \\param[out]   ppixd     8 bpp grayscale map\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) Each (sx, sy) tile of pixs gets mapped to one pixel in pixd.\n *      (2) pixd is the estimate of the fg (darkest) value within each tile.\n *      (3) All pixels in pixd that are in 'image' regions, as specified\n *          by pixim, are given the background value 0.\n *      (4) For pixels in pixd that can't directly be given a fg value,\n *          the value is inferred by propagating from neighboring pixels.\n *      (5) In practice, pixd can be used to normalize the fg, and\n *          it can be done after background normalization.\n *      (6) The overall procedure is:\n *            ~ reduce 2x by sampling\n *            ~ paint all 'image' pixels white, so that they don't\n *            ~ participate in the Min reduction\n *            ~ do a further (sx, sy) Min reduction -- think of\n *              it as a large opening followed by subsampling by the\n *              reduction factors\n *            ~ threshold the result to identify fg, and set the\n *              bg pixels to 255 (these are 'holes')\n *            ~ fill holes by propagation from fg values\n *            ~ replicatively expand by 2x, arriving at the final\n *              resolution of pixd\n *            ~ smooth with a 17x17 kernel\n *            ~ paint the 'image' regions black\n * </pre>\n */\nl_ok\npixGetForegroundGrayMap(PIX     *pixs,\n                        PIX     *pixim,\n                        l_int32  sx,\n                        l_int32  sy,\n                        l_int32  thresh,\n                        PIX    **ppixd)\n{\nl_int32  w, h, d, wd, hd;\nl_int32  empty, fgpixels;\nPIX     *pixd, *piximi, *pixim2, *pixims, *pixs2, *pixb, *pixt1, *pixt2, *pixt3;\n\n    PROCNAME(\"pixGetForegroundGrayMap\");\n\n    if (!ppixd)\n        return ERROR_INT(\"&pixd not defined\", procName, 1);\n    *ppixd = NULL;\n    if (!pixs)\n        return ERROR_INT(\"pixs not defined\", procName, 1);\n    pixGetDimensions(pixs, &w, &h, &d);\n    if (d != 8)\n        return ERROR_INT(\"pixs not 8 bpp\", procName, 1);\n    if (pixim && pixGetDepth(pixim) != 1)\n        return ERROR_INT(\"pixim not 1 bpp\", procName, 1);\n    if (sx < 2 || sy < 2)\n        return ERROR_INT(\"sx and sy must be >= 2\", procName, 1);\n\n        /* Generate pixd, which is reduced by the factors (sx, sy). */\n    wd = (w + sx - 1) / sx;\n    hd = (h + sy - 1) / sy;\n    pixd = pixCreate(wd, hd, 8);\n    *ppixd = pixd;\n\n        /* Evaluate the 'image' mask, pixim.  If it is all fg,\n         * the output pixd has all pixels with value 0. */\n    fgpixels = 0;  /* boolean for existence of fg pixels in the image mask. */\n    if (pixim) {\n        piximi = pixInvert(NULL, pixim);  /* set non-image pixels to 1 */\n        pixZero(piximi, &empty);\n        pixDestroy(&piximi);\n        if (empty)  /* all 'image'; return with all pixels set to 0 */\n            return 0;\n        pixZero(pixim, &empty);\n        if (!empty)  /* there are fg pixels in pixim */\n            fgpixels = 1;\n    }\n\n        /* 2x subsampling; paint white through 'image' mask. */\n    pixs2 = pixScaleBySampling(pixs, 0.5, 0.5);\n    if (pixim && fgpixels) {\n        pixim2 = pixReduceBinary2(pixim, NULL);\n        pixPaintThroughMask(pixs2, pixim2, 0, 0, 255);\n        pixDestroy(&pixim2);\n    }\n\n        /* Min (erosion) downscaling; total reduction (4 sx, 4 sy). */\n    pixt1 = pixScaleGrayMinMax(pixs2, sx, sy, L_CHOOSE_MIN);\n\n/*    pixDisplay(pixt1, 300, 200); */\n\n        /* Threshold to identify fg; paint bg pixels to white. */\n    pixb = pixThresholdToBinary(pixt1, thresh);  /* fg pixels */\n    pixInvert(pixb, pixb);\n    pixPaintThroughMask(pixt1, pixb, 0, 0, 255);\n    pixDestroy(&pixb);\n\n        /* Replicative expansion by 2x to (sx, sy). */\n    pixt2 = pixExpandReplicate(pixt1, 2);\n\n/*    pixDisplay(pixt2, 500, 200); */\n\n        /* Fill holes in the fg by propagation */\n    pixFillMapHoles(pixt2, w / sx, h / sy, L_FILL_WHITE);\n\n/*    pixDisplay(pixt2, 700, 200); */\n\n        /* Smooth with 17x17 kernel. */\n    pixt3 = pixBlockconv(pixt2, 8, 8);\n    pixRasterop(pixd, 0, 0, wd, hd, PIX_SRC, pixt3, 0, 0);\n\n        /* Paint the image parts black. */\n    pixims = pixScaleBySampling(pixim, 1. / sx, 1. / sy);\n    pixPaintThroughMask(pixd, pixims, 0, 0, 0);\n\n    pixDestroy(&pixs2);\n    pixDestroy(&pixt1);\n    pixDestroy(&pixt2);\n    pixDestroy(&pixt3);\n    return 0;\n}\n#endif   /* Not working properly: do not use */\n\n\n/*------------------------------------------------------------------*\n *                  Generate inverted background map                *\n *------------------------------------------------------------------*/\n/*!\n * \\brief   pixGetInvBackgroundMap()\n *\n * \\param[in]    pixs       8 bpp grayscale; no colormap\n * \\param[in]    bgval      target bg val; typ. > 128\n * \\param[in]    smoothx    half-width of block convolution kernel width\n * \\param[in]    smoothy    half-width of block convolution kernel height\n * \\return  pixd 16 bpp, or NULL on error\n *\n * <pre>\n * Notes:\n *     (1) bgval should typically be > 120 and < 240\n *     (2) pixd is a normalization image; the original image is\n *       multiplied by pixd and the result is divided by 256.\n * </pre>\n */\nPIX *\npixGetInvBackgroundMap(PIX     *pixs,\n                       l_int32  bgval,\n                       l_int32  smoothx,\n                       l_int32  smoothy)\n{\nl_int32    w, h, wplsm, wpld, i, j;\nl_int32    val, val16;\nl_uint32  *datasm, *datad, *linesm, *lined;\nPIX       *pixsm, *pixd;\n\n    PROCNAME(\"pixGetInvBackgroundMap\");\n\n    if (!pixs || pixGetDepth(pixs) != 8)\n        return (PIX *)ERROR_PTR(\"pixs undefined or not 8 bpp\", procName, NULL);\n    if (pixGetColormap(pixs))\n        return (PIX *)ERROR_PTR(\"pixs has colormap\", procName, NULL);\n    pixGetDimensions(pixs, &w, &h, NULL);\n    if (w < 5 || h < 5)\n        return (PIX *)ERROR_PTR(\"w and h must be >= 5\", procName, NULL);\n\n        /* smooth the map image */\n    pixsm = pixBlockconv(pixs, smoothx, smoothy);\n    datasm = pixGetData(pixsm);\n    wplsm = pixGetWpl(pixsm);\n\n        /* invert the map image, scaling up to preserve dynamic range */\n    pixd = pixCreate(w, h, 16);\n    datad = pixGetData(pixd);\n    wpld = pixGetWpl(pixd);\n    for (i = 0; i < h; i++) {\n        linesm = datasm + i * wplsm;\n        lined = datad + i * wpld;\n        for (j = 0; j < w; j++) {\n            val = GET_DATA_BYTE(linesm, j);\n            if (val > 0)\n                val16 = (256 * bgval) / val;\n            else {  /* shouldn't happen */\n                L_WARNING(\"smoothed bg has 0 pixel!\\n\", procName);\n                val16 = bgval / 2;\n            }\n            SET_DATA_TWO_BYTES(lined, j, val16);\n        }\n    }\n\n    pixDestroy(&pixsm);\n    pixCopyResolution(pixd, pixs);\n    return pixd;\n}\n\n\n/*------------------------------------------------------------------*\n *                    Apply background map to image                 *\n *------------------------------------------------------------------*/\n/*!\n * \\brief   pixApplyInvBackgroundGrayMap()\n *\n * \\param[in]    pixs    8 bpp grayscale; no colormap\n * \\param[in]    pixm    16 bpp, inverse background map\n * \\param[in]    sx      tile width in pixels\n * \\param[in]    sy      tile height in pixels\n * \\return  pixd 8 bpp, or NULL on error\n */\nPIX *\npixApplyInvBackgroundGrayMap(PIX     *pixs,\n                             PIX     *pixm,\n                             l_int32  sx,\n                             l_int32  sy)\n{\nl_int32    w, h, wm, hm, wpls, wpld, i, j, k, m, xoff, yoff;\nl_int32    vals, vald;\nl_uint32   val16;\nl_uint32  *datas, *datad, *lines, *lined, *flines, *flined;\nPIX       *pixd;\n\n    PROCNAME(\"pixApplyInvBackgroundGrayMap\");\n\n    if (!pixs || pixGetDepth(pixs) != 8)\n        return (PIX *)ERROR_PTR(\"pixs undefined or not 8 bpp\", procName, NULL);\n    if (pixGetColormap(pixs))\n        return (PIX *)ERROR_PTR(\"pixs has colormap\", procName, NULL);\n    if (!pixm || pixGetDepth(pixm) != 16)\n        return (PIX *)ERROR_PTR(\"pixm undefined or not 16 bpp\", procName, NULL);\n    if (sx == 0 || sy == 0)\n        return (PIX *)ERROR_PTR(\"invalid sx and/or sy\", procName, NULL);\n\n    datas = pixGetData(pixs);\n    wpls = pixGetWpl(pixs);\n    pixGetDimensions(pixs, &w, &h, NULL);\n    pixGetDimensions(pixm, &wm, &hm, NULL);\n    if ((pixd = pixCreateTemplate(pixs)) == NULL)\n        return (PIX *)ERROR_PTR(\"pixd not made\", procName, NULL);\n    datad = pixGetData(pixd);\n    wpld = pixGetWpl(pixd);\n    for (i = 0; i < hm; i++) {\n        lines = datas + sy * i * wpls;\n        lined = datad + sy * i * wpld;\n        yoff = sy * i;\n        for (j = 0; j < wm; j++) {\n            pixGetPixel(pixm, j, i, &val16);\n            xoff = sx * j;\n            for (k = 0; k < sy && yoff + k < h; k++) {\n                flines = lines + k * wpls;\n                flined = lined + k * wpld;\n                for (m = 0; m < sx && xoff + m < w; m++) {\n                    vals = GET_DATA_BYTE(flines, xoff + m);\n                    vald = (vals * val16) / 256;\n                    vald = L_MIN(vald, 255);\n                    SET_DATA_BYTE(flined, xoff + m, vald);\n                }\n            }\n        }\n    }\n\n    return pixd;\n}\n\n\n/*!\n * \\brief   pixApplyInvBackgroundRGBMap()\n *\n * \\param[in]    pixs    32 bpp rbg\n * \\param[in]    pixmr   16 bpp, red inverse background map\n * \\param[in]    pixmg   16 bpp, green inverse background map\n * \\param[in]    pixmb   16 bpp, blue inverse background map\n * \\param[in]    sx      tile width in pixels\n * \\param[in]    sy      tile height in pixels\n * \\return  pixd 32 bpp rbg, or NULL on error\n */\nPIX *\npixApplyInvBackgroundRGBMap(PIX     *pixs,\n                            PIX     *pixmr,\n                            PIX     *pixmg,\n                            PIX     *pixmb,\n                            l_int32  sx,\n                            l_int32  sy)\n{\nl_int32    w, h, wm, hm, wpls, wpld, i, j, k, m, xoff, yoff;\nl_int32    rvald, gvald, bvald;\nl_uint32   vals;\nl_uint32   rval16, gval16, bval16;\nl_uint32  *datas, *datad, *lines, *lined, *flines, *flined;\nPIX       *pixd;\n\n    PROCNAME(\"pixApplyInvBackgroundRGBMap\");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    if (pixGetDepth(pixs) != 32)\n        return (PIX *)ERROR_PTR(\"pixs not 32 bpp\", procName, NULL);\n    if (!pixmr || !pixmg || !pixmb)\n        return (PIX *)ERROR_PTR(\"pix maps not all defined\", procName, NULL);\n    if (pixGetDepth(pixmr) != 16 || pixGetDepth(pixmg) != 16 ||\n        pixGetDepth(pixmb) != 16)\n        return (PIX *)ERROR_PTR(\"pix maps not all 16 bpp\", procName, NULL);\n    if (sx == 0 || sy == 0)\n        return (PIX *)ERROR_PTR(\"invalid sx and/or sy\", procName, NULL);\n\n    datas = pixGetData(pixs);\n    wpls = pixGetWpl(pixs);\n    w = pixGetWidth(pixs);\n    h = pixGetHeight(pixs);\n    wm = pixGetWidth(pixmr);\n    hm = pixGetHeight(pixmr);\n    if ((pixd = pixCreateTemplate(pixs)) == NULL)\n        return (PIX *)ERROR_PTR(\"pixd not made\", procName, NULL);\n    datad = pixGetData(pixd);\n    wpld = pixGetWpl(pixd);\n    for (i = 0; i < hm; i++) {\n        lines = datas + sy * i * wpls;\n        lined = datad + sy * i * wpld;\n        yoff = sy * i;\n        for (j = 0; j < wm; j++) {\n            pixGetPixel(pixmr, j, i, &rval16);\n            pixGetPixel(pixmg, j, i, &gval16);\n            pixGetPixel(pixmb, j, i, &bval16);\n            xoff = sx * j;\n            for (k = 0; k < sy && yoff + k < h; k++) {\n                flines = lines + k * wpls;\n                flined = lined + k * wpld;\n                for (m = 0; m < sx && xoff + m < w; m++) {\n                    vals = *(flines + xoff + m);\n                    rvald = ((vals >> 24) * rval16) / 256;\n                    rvald = L_MIN(rvald, 255);\n                    gvald = (((vals >> 16) & 0xff) * gval16) / 256;\n                    gvald = L_MIN(gvald, 255);\n                    bvald = (((vals >> 8) & 0xff) * bval16) / 256;\n                    bvald = L_MIN(bvald, 255);\n                    composeRGBPixel(rvald, gvald, bvald, flined + xoff + m);\n                }\n            }\n        }\n    }\n\n    return pixd;\n}\n\n\n/*------------------------------------------------------------------*\n *                         Apply variable map                       *\n *------------------------------------------------------------------*/\n/*!\n * \\brief   pixApplyVariableGrayMap()\n *\n * \\param[in]    pixs     8 bpp\n * \\param[in]    pixg     8 bpp, variable map\n * \\param[in]    target   typ. 128 for threshold\n * \\return  pixd 8 bpp, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) Suppose you have an image that you want to transform based\n *          on some photometric measurement at each point, such as the\n *          threshold value for binarization.  Representing the photometric\n *          measurement as an image pixg, you can threshold in input image\n *          using pixVarThresholdToBinary().  Alternatively, you can map\n *          the input image pointwise so that the threshold over the\n *          entire image becomes a constant, such as 128.  For example,\n *          if a pixel in pixg is 150 and the target is 128, the\n *          corresponding pixel in pixs is mapped linearly to a value\n *          (128/150) of the input value.  If the resulting mapped image\n *          pixd were then thresholded at 128, you would obtain the\n *          same result as a direct binarization using pixg with\n *          pixVarThresholdToBinary().\n *      (2) The sizes of pixs and pixg must be equal.\n * </pre>\n */\nPIX *\npixApplyVariableGrayMap(PIX     *pixs,\n                        PIX     *pixg,\n                        l_int32  target)\n{\nl_int32    i, j, w, h, d, wpls, wplg, wpld, vals, valg, vald;\nl_uint8   *lut;\nl_uint32  *datas, *datag, *datad, *lines, *lineg, *lined;\nl_float32  fval;\nPIX       *pixd;\n\n    PROCNAME(\"pixApplyVariableGrayMap\");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    if (!pixg)\n        return (PIX *)ERROR_PTR(\"pixg not defined\", procName, NULL);\n    if (!pixSizesEqual(pixs, pixg))\n        return (PIX *)ERROR_PTR(\"pix sizes not equal\", procName, NULL);\n    pixGetDimensions(pixs, &w, &h, &d);\n    if (d != 8)\n        return (PIX *)ERROR_PTR(\"depth not 8 bpp\", procName, NULL);\n\n        /* Generate a LUT for the mapping if the image is large enough\n         * to warrant the overhead.  The LUT is of size 2^16.  For the\n         * index to the table, get the MSB from pixs and the LSB from pixg.\n         * Note: this LUT is bigger than the typical 32K L1 cache, so\n         * we expect cache misses.  L2 latencies are about 5ns.  But\n         * division is slooooow.  For large images, this function is about\n         * 4x faster when using the LUT.  C'est la vie.  */\n    lut = NULL;\n    if (w * h > 100000) {  /* more pixels than 2^16 */\n        if ((lut = (l_uint8 *)LEPT_CALLOC(0x10000, sizeof(l_uint8))) == NULL)\n            return (PIX *)ERROR_PTR(\"lut not made\", procName, NULL);\n        for (i = 0; i < 256; i++) {\n            for (j = 0; j < 256; j++) {\n                fval = (l_float32)(i * target) / (j + 0.5);\n                lut[(i << 8) + j] = L_MIN(255, (l_int32)(fval + 0.5));\n            }\n        }\n    }\n\n    if ((pixd = pixCreateNoInit(w, h, 8)) == NULL) {\n        LEPT_FREE(lut);\n        return (PIX *)ERROR_PTR(\"pixd not made\", procName, NULL);\n    }\n    pixCopyResolution(pixd, pixs);\n    datad = pixGetData(pixd);\n    wpld = pixGetWpl(pixd);\n    datas = pixGetData(pixs);\n    wpls = pixGetWpl(pixs);\n    datag = pixGetData(pixg);\n    wplg = pixGetWpl(pixg);\n    for (i = 0; i < h; i++) {\n        lines = datas + i * wpls;\n        lineg = datag + i * wplg;\n        lined = datad + i * wpld;\n        if (lut) {\n            for (j = 0; j < w; j++) {\n                vals = GET_DATA_BYTE(lines, j);\n                valg = GET_DATA_BYTE(lineg, j);\n                vald = lut[(vals << 8) + valg];\n                SET_DATA_BYTE(lined, j, vald);\n            }\n        }\n        else {\n            for (j = 0; j < w; j++) {\n                vals = GET_DATA_BYTE(lines, j);\n                valg = GET_DATA_BYTE(lineg, j);\n                fval = (l_float32)(vals * target) / (valg + 0.5);\n                vald = L_MIN(255, (l_int32)(fval + 0.5));\n                SET_DATA_BYTE(lined, j, vald);\n            }\n        }\n    }\n\n    LEPT_FREE(lut);\n    return pixd;\n}\n\n\n/*------------------------------------------------------------------*\n *                  Non-adaptive (global) mapping                   *\n *------------------------------------------------------------------*/\n/*!\n * \\brief   pixGlobalNormRGB()\n *\n * \\param[in]    pixd     [optional] null, existing or equal to pixs\n * \\param[in]    pixs     32 bpp rgb, or colormapped\n * \\param[in]    rval, gval, bval   pixel values in pixs that are\n *                                  linearly mapped to mapval\n * \\param[in]    mapval   use 255 for mapping to white\n * \\return  pixd 32 bpp rgb or colormapped, or NULL on error\n *\n * <pre>\n * Notes:\n *    (1) The value of pixd determines if the results are written to a\n *        new pix (use NULL), in-place to pixs (use pixs), or to some\n *        other existing pix.\n *    (2) This does a global normalization of an image where the\n *        r,g,b color components are not balanced.  Thus, white in pixs is\n *        represented by a set of r,g,b values that are not all 255.\n *    (3) The input values (rval, gval, bval) should be chosen to\n *        represent the gray color (mapval, mapval, mapval) in src.\n *        Thus, this function will map (rval, gval, bval) to that gray color.\n *    (4) Typically, mapval = 255, so that (rval, gval, bval)\n *        corresponds to the white point of src.  In that case, these\n *        parameters should be chosen so that few pixels have higher values.\n *    (5) In all cases, we do a linear TRC separately on each of the\n *        components, saturating at 255.\n *    (6) If the input pix is 8 bpp without a colormap, you can get\n *        this functionality with mapval = 255 by calling:\n *            pixGammaTRC(pixd, pixs, 1.0, 0, bgval);\n *        where bgval is the value you want to be mapped to 255.\n *        Or more generally, if you want bgval to be mapped to mapval:\n *            pixGammaTRC(pixd, pixs, 1.0, 0, 255 * bgval / mapval);\n * </pre>\n */\nPIX *\npixGlobalNormRGB(PIX     *pixd,\n                 PIX     *pixs,\n                 l_int32  rval,\n                 l_int32  gval,\n                 l_int32  bval,\n                 l_int32  mapval)\n{\nl_int32    w, h, d, i, j, ncolors, rv, gv, bv, wpl;\nl_int32   *rarray, *garray, *barray;\nl_uint32  *data, *line;\nNUMA      *nar, *nag, *nab;\nPIXCMAP   *cmap;\n\n    PROCNAME(\"pixGlobalNormRGB\");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    cmap = pixGetColormap(pixs);\n    pixGetDimensions(pixs, &w, &h, &d);\n    if (!cmap && d != 32)\n        return (PIX *)ERROR_PTR(\"pixs not cmapped or 32 bpp\", procName, NULL);\n    if (mapval <= 0) {\n        L_WARNING(\"mapval must be > 0; setting to 255\\n\", procName);\n        mapval = 255;\n    }\n\n        /* Prepare pixd to be a copy of pixs */\n    if ((pixd = pixCopy(pixd, pixs)) == NULL)\n        return (PIX *)ERROR_PTR(\"pixd not made\", procName, NULL);\n\n        /* Generate the TRC maps for each component.  Make sure the\n         * upper range for each color is greater than zero. */\n    nar = numaGammaTRC(1.0, 0, L_MAX(1, 255 * rval / mapval));\n    nag = numaGammaTRC(1.0, 0, L_MAX(1, 255 * gval / mapval));\n    nab = numaGammaTRC(1.0, 0, L_MAX(1, 255 * bval / mapval));\n\n        /* Extract copies of the internal arrays */\n    rarray = numaGetIArray(nar);\n    garray = numaGetIArray(nag);\n    barray = numaGetIArray(nab);\n    if (!nar || !nag || !nab || !rarray || !garray || !barray) {\n        L_ERROR(\"allocation failure in arrays\\n\", procName);\n        goto cleanup_arrays;\n    }\n\n    if (cmap) {\n        ncolors = pixcmapGetCount(cmap);\n        for (i = 0; i < ncolors; i++) {\n            pixcmapGetColor(cmap, i, &rv, &gv, &bv);\n            pixcmapResetColor(cmap, i, rarray[rv], garray[gv], barray[bv]);\n        }\n    }\n    else {\n        data = pixGetData(pixd);\n        wpl = pixGetWpl(pixd);\n        for (i = 0; i < h; i++) {\n            line = data + i * wpl;\n            for (j = 0; j < w; j++) {\n                extractRGBValues(line[j], &rv, &gv, &bv);\n                composeRGBPixel(rarray[rv], garray[gv], barray[bv], line + j);\n            }\n        }\n    }\n\ncleanup_arrays:\n    numaDestroy(&nar);\n    numaDestroy(&nag);\n    numaDestroy(&nab);\n    LEPT_FREE(rarray);\n    LEPT_FREE(garray);\n    LEPT_FREE(barray);\n    return pixd;\n}\n\n\n/*!\n * \\brief   pixGlobalNormNoSatRGB()\n *\n * \\param[in]    pixd       [optional] null, existing or equal to pixs\n * \\param[in]    pixs       32 bpp rgb\n * \\param[in]    rval, gval, bval   pixel values in pixs that are\n *                                  linearly mapped to mapval; but see below\n * \\param[in]    factor     subsampling factor; integer >= 1\n * \\param[in]    rank       between 0.0 and 1.0; typ. use a value near 1.0\n * \\return  pixd 32 bpp rgb, or NULL on error\n *\n * <pre>\n * Notes:\n *    (1) This is a version of pixGlobalNormRGB(), where the output\n *        intensity is scaled back so that a controlled fraction of\n *        pixel components is allowed to saturate.  See comments in\n *        pixGlobalNormRGB().\n *    (2) The value of pixd determines if the results are written to a\n *        new pix (use NULL), in-place to pixs (use pixs), or to some\n *        other existing pix.\n *    (3) This does a global normalization of an image where the\n *        r,g,b color components are not balanced.  Thus, white in pixs is\n *        represented by a set of r,g,b values that are not all 255.\n *    (4) The input values (rval, gval, bval) can be chosen to be the\n *        color that, after normalization, becomes white background.\n *        For images that are mostly background, the closer these values\n *        are to the median component values, the closer the resulting\n *        background will be to gray, becoming white at the brightest places.\n *    (5) The mapval used in pixGlobalNormRGB() is computed here to\n *        avoid saturation of any component in the image (save for a\n *        fraction of the pixels given by the input rank value).\n * </pre>\n */\nPIX *\npixGlobalNormNoSatRGB(PIX       *pixd,\n                      PIX       *pixs,\n                      l_int32    rval,\n                      l_int32    gval,\n                      l_int32    bval,\n                      l_int32    factor,\n                      l_float32  rank)\n{\nl_int32    mapval;\nl_float32  rankrval, rankgval, rankbval;\nl_float32  rfract, gfract, bfract, maxfract;\n\n    PROCNAME(\"pixGlobalNormNoSatRGB\");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    if (pixGetDepth(pixs) != 32)\n        return (PIX *)ERROR_PTR(\"pixs not 32 bpp\", procName, NULL);\n    if (factor < 1)\n        return (PIX *)ERROR_PTR(\"sampling factor < 1\", procName, NULL);\n    if (rank < 0.0 || rank > 1.0)\n        return (PIX *)ERROR_PTR(\"rank not in [0.0 ... 1.0]\", procName, NULL);\n    if (rval <= 0 || gval <= 0 || bval <= 0)\n        return (PIX *)ERROR_PTR(\"invalid estim. color values\", procName, NULL);\n\n        /* The max value for each component may be larger than the\n         * input estimated background value.  In that case, mapping\n         * for those pixels would saturate.  To prevent saturation,\n         * we compute the fraction for each component by which we\n         * would oversaturate.  Then take the max of these, and\n         * reduce, uniformly over all components, the output intensity\n         * by this value.  Then no component will saturate.\n         * In practice, if rank < 1.0, a fraction of pixels\n         * may have a component saturate.  By keeping rank close to 1.0,\n         * that fraction can be made arbitrarily small. */\n    pixGetRankValueMaskedRGB(pixs, NULL, 0, 0, factor, rank, &rankrval,\n                             &rankgval, &rankbval);\n    rfract = rankrval / (l_float32)rval;\n    gfract = rankgval / (l_float32)gval;\n    bfract = rankbval / (l_float32)bval;\n    maxfract = L_MAX(rfract, gfract);\n    maxfract = L_MAX(maxfract, bfract);\n#if  DEBUG_GLOBAL\n    lept_stderr(\"rankrval = %7.2f, rankgval = %7.2f, rankbval = %7.2f\\n\",\n                rankrval, rankgval, rankbval);\n    lept_stderr(\"rfract = %7.4f, gfract = %7.4f, bfract = %7.4f\\n\",\n                rfract, gfract, bfract);\n#endif  /* DEBUG_GLOBAL */\n\n    mapval = (l_int32)(255. / maxfract);\n    pixd = pixGlobalNormRGB(pixd, pixs, rval, gval, bval, mapval);\n    return pixd;\n}\n\n\n/*------------------------------------------------------------------*\n *              Adaptive threshold spread normalization             *\n *------------------------------------------------------------------*/\n/*!\n * \\brief   pixThresholdSpreadNorm()\n *\n * \\param[in]    pixs              8 bpp grayscale; not colormapped\n * \\param[in]    filtertype        L_SOBEL_EDGE or L_TWO_SIDED_EDGE;\n * \\param[in]    edgethresh        threshold on magnitude of edge filter;\n *                                 typ 10-20\n * \\param[in]    smoothx, smoothy  half-width of convolution kernel applied to\n *                                 spread threshold: use 0 for no smoothing\n * \\param[in]    gamma             gamma correction; typ. about 0.7\n * \\param[in]    minval            input value that gives 0 for output; typ. -25\n * \\param[in]    maxval            input value that gives 255 for output;\n *                                 typ. 255\n * \\param[in]    targetthresh      target threshold for normalization\n * \\param[out]   ppixth            [optional] computed local threshold value\n * \\param[out]   ppixb             [optional] thresholded normalized image\n * \\param[out]   ppixd             [optional] normalized image\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) The basis of this approach is the use of seed spreading\n *          on a (possibly) sparse set of estimates for the local threshold.\n *          The resulting dense estimates are smoothed by convolution\n *          and used to either threshold the input image or normalize it\n *          with a local transformation that linearly maps the pixels so\n *          that the local threshold estimate becomes constant over the\n *          resulting image.  This approach is one of several that\n *          have been suggested (and implemented) by Ray Smith.\n *      (2) You can use either the Sobel or TwoSided edge filters.\n *          The results appear to be similar, using typical values\n *          of edgethresh in the rang 10-20.\n *      (3) To skip the trc enhancement, use gamma = 1.0, minval = 0\n *          and maxval = 255.\n *      (4) For the normalized image pixd, each pixel is linearly mapped\n *          in such a way that the local threshold is equal to targetthresh.\n *      (5) The full width and height of the convolution kernel\n *          are (2 * smoothx + 1) and (2 * smoothy + 1).\n *      (6) This function can be used with the pixtiling utility if the\n *          images are too large.  See pixOtsuAdaptiveThreshold() for\n *          an example of this.\n * </pre>\n */\nl_ok\npixThresholdSpreadNorm(PIX       *pixs,\n                       l_int32    filtertype,\n                       l_int32    edgethresh,\n                       l_int32    smoothx,\n                       l_int32    smoothy,\n                       l_float32  gamma,\n                       l_int32    minval,\n                       l_int32    maxval,\n                       l_int32    targetthresh,\n                       PIX      **ppixth,\n                       PIX      **ppixb,\n                       PIX      **ppixd)\n{\nPIX  *pixe, *pixet, *pixsd, *pixg1, *pixg2, *pixth;\n\n    PROCNAME(\"pixThresholdSpreadNorm\");\n\n    if (ppixth) *ppixth = NULL;\n    if (ppixb) *ppixb = NULL;\n    if (ppixd) *ppixd = NULL;\n    if (!pixs || pixGetDepth(pixs) != 8)\n        return ERROR_INT(\"pixs not defined or not 8 bpp\", procName, 1);\n    if (pixGetColormap(pixs))\n        return ERROR_INT(\"pixs is colormapped\", procName, 1);\n    if (!ppixth && !ppixb && !ppixd)\n        return ERROR_INT(\"no output requested\", procName, 1);\n    if (filtertype != L_SOBEL_EDGE && filtertype != L_TWO_SIDED_EDGE)\n        return ERROR_INT(\"invalid filter type\", procName, 1);\n\n        /* Get the thresholded edge pixels.  These are the ones\n         * that have values in pixs near the local optimal fg/bg threshold. */\n    if (filtertype == L_SOBEL_EDGE)\n        pixe = pixSobelEdgeFilter(pixs, L_VERTICAL_EDGES);\n    else  /* L_TWO_SIDED_EDGE */\n        pixe = pixTwoSidedEdgeFilter(pixs, L_VERTICAL_EDGES);\n    pixet = pixThresholdToBinary(pixe, edgethresh);\n    pixInvert(pixet, pixet);\n\n        /* Build a seed image whose only nonzero values are those\n         * values of pixs corresponding to pixels in the fg of pixet. */\n    pixsd = pixCreateTemplate(pixs);\n    pixCombineMasked(pixsd, pixs, pixet);\n\n        /* Spread the seed and optionally smooth to reduce noise */\n    pixg1 = pixSeedspread(pixsd, 4);\n    pixg2 = pixBlockconv(pixg1, smoothx, smoothy);\n\n        /* Optionally do a gamma enhancement */\n    pixth = pixGammaTRC(NULL, pixg2, gamma, minval, maxval);\n\n        /* Do the mapping and thresholding */\n    if (ppixd) {\n        *ppixd = pixApplyVariableGrayMap(pixs, pixth, targetthresh);\n        if (ppixb)\n            *ppixb = pixThresholdToBinary(*ppixd, targetthresh);\n    }\n    else if (ppixb)\n        *ppixb = pixVarThresholdToBinary(pixs, pixth);\n\n    if (ppixth)\n        *ppixth = pixth;\n    else\n        pixDestroy(&pixth);\n\n    pixDestroy(&pixe);\n    pixDestroy(&pixet);\n    pixDestroy(&pixsd);\n    pixDestroy(&pixg1);\n    pixDestroy(&pixg2);\n    return 0;\n}\n\n\n/*------------------------------------------------------------------*\n *      Adaptive background normalization (flexible adaptaption)    *\n *------------------------------------------------------------------*/\n/*!\n * \\brief   pixBackgroundNormFlex()\n *\n * \\param[in]    pixs               8 bpp grayscale; not colormapped\n * \\param[in]    sx, sy             desired tile dimensions; size may vary;\n *                                  use values between 3 and 10\n * \\param[in]    smoothx, smoothy   half-width of convolution kernel applied to\n *                                  threshold array: use values between 1 and 3\n * \\param[in]    delta              difference parameter in basin filling;\n *                                  use 0 to skip\n * \\return  pixd 8 bpp, background-normalized), or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) This does adaptation flexibly to a quickly varying background.\n *          For that reason, all input parameters should be small.\n *      (2) sx and sy give the tile size; they should be in [5 - 7].\n *      (3) The full width and height of the convolution kernel\n *          are (2 * smoothx + 1) and (2 * smoothy + 1).  They\n *          should be in [1 - 2].\n *      (4) Basin filling is used to fill the large fg regions.  The\n *          parameter %delta measures the height that the black\n *          background is raised from the local minima.  By raising\n *          the background, it is possible to threshold the large\n *          fg regions to foreground.  If %delta is too large,\n *          bg regions will be lifted, causing thickening of\n *          the fg regions.  Use 0 to skip.\n * </pre>\n */\nPIX *\npixBackgroundNormFlex(PIX     *pixs,\n                      l_int32  sx,\n                      l_int32  sy,\n                      l_int32  smoothx,\n                      l_int32  smoothy,\n                      l_int32  delta)\n{\nl_float32  scalex, scaley;\nPIX       *pixt, *pixsd, *pixmin, *pixbg, *pixbgi, *pixd;\n\n    PROCNAME(\"pixBackgroundNormFlex\");\n\n    if (!pixs || pixGetDepth(pixs) != 8)\n        return (PIX *)ERROR_PTR(\"pixs undefined or not 8 bpp\", procName, NULL);\n    if (pixGetColormap(pixs))\n        return (PIX *)ERROR_PTR(\"pixs is colormapped\", procName, NULL);\n    if (sx < 3 || sy < 3)\n        return (PIX *)ERROR_PTR(\"sx and/or sy less than 3\", procName, NULL);\n    if (sx > 10 || sy > 10)\n        return (PIX *)ERROR_PTR(\"sx and/or sy exceed 10\", procName, NULL);\n    if (smoothx < 1 || smoothy < 1)\n        return (PIX *)ERROR_PTR(\"smooth params less than 1\", procName, NULL);\n    if (smoothx > 3 || smoothy > 3)\n        return (PIX *)ERROR_PTR(\"smooth params exceed 3\", procName, NULL);\n\n        /* Generate the bg estimate using smoothed average with subsampling */\n    scalex = 1. / (l_float32)sx;\n    scaley = 1. / (l_float32)sy;\n    pixt = pixScaleSmooth(pixs, scalex, scaley);\n\n        /* Do basin filling on the bg estimate if requested */\n    if (delta <= 0)\n        pixsd = pixClone(pixt);\n    else {\n        pixLocalExtrema(pixt, 0, 0, &pixmin, NULL);\n        pixsd = pixSeedfillGrayBasin(pixmin, pixt, delta, 4);\n        pixDestroy(&pixmin);\n    }\n    pixbg = pixExtendByReplication(pixsd, 1, 1);\n\n        /* Map the bg to 200 */\n    pixbgi = pixGetInvBackgroundMap(pixbg, 200, smoothx, smoothy);\n    pixd = pixApplyInvBackgroundGrayMap(pixs, pixbgi, sx, sy);\n\n    pixDestroy(&pixt);\n    pixDestroy(&pixsd);\n    pixDestroy(&pixbg);\n    pixDestroy(&pixbgi);\n    return pixd;\n}\n\n\n/*------------------------------------------------------------------*\n *                    Adaptive contrast normalization               *\n *------------------------------------------------------------------*/\n/*!\n * \\brief   pixContrastNorm()\n *\n * \\param[in]    pixd               [optional] 8 bpp; null or equal to pixs\n * \\param[in]    pixs               8 bpp grayscale; not colormapped\n * \\param[in]    sx, sy             tile dimensions\n * \\param[in]    mindiff            minimum difference to accept as valid\n * \\param[in]    smoothx, smoothy   half-width of convolution kernel applied to\n *                                  min and max arrays: use 0 for no smoothing\n * \\return  pixd always\n *\n * <pre>\n * Notes:\n *      (1) This function adaptively attempts to expand the contrast\n *          to the full dynamic range in each tile.  If the contrast in\n *          a tile is smaller than %mindiff, it uses the min and max\n *          pixel values from neighboring tiles.  It also can use\n *          convolution to smooth the min and max values from\n *          neighboring tiles.  After all that processing, it is\n *          possible that the actual pixel values in the tile are outside\n *          the computed [min ... max] range for local contrast\n *          normalization.  Such pixels are taken to be at either 0\n *          (if below the min) or 255 (if above the max).\n *      (2) pixd can be equal to pixs (in-place operation) or\n *          null (makes a new pixd).\n *      (3) sx and sy give the tile size; they are typically at least 20.\n *      (4) mindiff is used to eliminate results for tiles where it is\n *          likely that either fg or bg is missing.  A value around 50\n *          or more is reasonable.\n *      (5) The full width and height of the convolution kernel\n *          are (2 * smoothx + 1) and (2 * smoothy + 1).  Some smoothing\n *          is typically useful, and we limit the smoothing half-widths\n *          to the range from 0 to 8.\n *      (6) A linear TRC (gamma = 1.0) is applied to increase the contrast\n *          in each tile.  The result can subsequently be globally corrected,\n *          by applying pixGammaTRC() with arbitrary values of gamma\n *          and the 0 and 255 points of the mapping.\n * </pre>\n */\nPIX *\npixContrastNorm(PIX       *pixd,\n                PIX       *pixs,\n                l_int32    sx,\n                l_int32    sy,\n                l_int32    mindiff,\n                l_int32    smoothx,\n                l_int32    smoothy)\n{\nPIX  *pixmin, *pixmax;\n\n    PROCNAME(\"pixContrastNorm\");\n\n    if (!pixs || pixGetDepth(pixs) != 8)\n        return (PIX *)ERROR_PTR(\"pixs undefined or not 8 bpp\", procName, pixd);\n    if (pixd && pixd != pixs)\n        return (PIX *)ERROR_PTR(\"pixd not null or == pixs\", procName, pixd);\n    if (pixGetColormap(pixs))\n        return (PIX *)ERROR_PTR(\"pixs is colormapped\", procName, pixd);\n    if (sx < 5 || sy < 5)\n        return (PIX *)ERROR_PTR(\"sx and/or sy less than 5\", procName, pixd);\n    if (smoothx < 0 || smoothy < 0)\n        return (PIX *)ERROR_PTR(\"smooth params less than 0\", procName, pixd);\n    if (smoothx > 8 || smoothy > 8)\n        return (PIX *)ERROR_PTR(\"smooth params exceed 8\", procName, pixd);\n\n        /* Get the min and max pixel values in each tile, and represent\n         * each value as a pixel in pixmin and pixmax, respectively. */\n    pixMinMaxTiles(pixs, sx, sy, mindiff, smoothx, smoothy, &pixmin, &pixmax);\n\n        /* For each tile, do a linear expansion of the dynamic range\n         * of pixels so that the min value is mapped to 0 and the\n         * max value is mapped to 255.  */\n    pixd = pixLinearTRCTiled(pixd, pixs, sx, sy, pixmin, pixmax);\n\n    pixDestroy(&pixmin);\n    pixDestroy(&pixmax);\n    return pixd;\n}\n\n\n/*!\n * \\brief   pixMinMaxTiles()\n *\n * \\param[in]    pixs               8 bpp grayscale; not colormapped\n * \\param[in]    sx, sy             tile dimensions\n * \\param[in]    mindiff            minimum difference to accept as valid\n * \\param[in]    smoothx, smoothy   half-width of convolution kernel applied to\n *                                  min and max arrays: use 0 for no smoothing\n * \\param[out]   ppixmin            tiled minima\n * \\param[out]   ppixmax            tiled maxima\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) This computes filtered and smoothed values for the min and\n *          max pixel values in each tile of the image.\n *      (2) See pixContrastNorm() for usage.\n * </pre>\n */\nl_ok\npixMinMaxTiles(PIX     *pixs,\n               l_int32  sx,\n               l_int32  sy,\n               l_int32  mindiff,\n               l_int32  smoothx,\n               l_int32  smoothy,\n               PIX    **ppixmin,\n               PIX    **ppixmax)\n{\nl_int32  w, h;\nPIX     *pixmin1, *pixmax1, *pixmin2, *pixmax2;\n\n    PROCNAME(\"pixMinMaxTiles\");\n\n    if (ppixmin) *ppixmin = NULL;\n    if (ppixmax) *ppixmax = NULL;\n    if (!ppixmin || !ppixmax)\n        return ERROR_INT(\"&pixmin or &pixmax undefined\", procName, 1);\n    if (!pixs || pixGetDepth(pixs) != 8)\n        return ERROR_INT(\"pixs undefined or not 8 bpp\", procName, 1);\n    if (pixGetColormap(pixs))\n        return ERROR_INT(\"pixs is colormapped\", procName, 1);\n    if (sx < 5 || sy < 5)\n        return ERROR_INT(\"sx and/or sy less than 3\", procName, 1);\n    if (smoothx < 0 || smoothy < 0)\n        return ERROR_INT(\"smooth params less than 0\", procName, 1);\n    if (smoothx > 5 || smoothy > 5)\n        return ERROR_INT(\"smooth params exceed 5\", procName, 1);\n\n        /* Get the min and max values in each tile */\n    pixmin1 = pixScaleGrayMinMax(pixs, sx, sy, L_CHOOSE_MIN);\n    pixmax1 = pixScaleGrayMinMax(pixs, sx, sy, L_CHOOSE_MAX);\n\n    pixmin2 = pixExtendByReplication(pixmin1, 1, 1);\n    pixmax2 = pixExtendByReplication(pixmax1, 1, 1);\n    pixDestroy(&pixmin1);\n    pixDestroy(&pixmax1);\n\n        /* Make sure no value is 0 */\n    pixAddConstantGray(pixmin2, 1);\n    pixAddConstantGray(pixmax2, 1);\n\n        /* Generate holes where the contrast is too small */\n    pixSetLowContrast(pixmin2, pixmax2, mindiff);\n\n        /* Fill the holes (0 values) */\n    pixGetDimensions(pixmin2, &w, &h, NULL);\n    pixFillMapHoles(pixmin2, w, h, L_FILL_BLACK);\n    pixFillMapHoles(pixmax2, w, h, L_FILL_BLACK);\n\n        /* Smooth if requested */\n    if (smoothx > 0 || smoothy > 0) {\n        smoothx = L_MIN(smoothx, (w - 1) / 2);\n        smoothy = L_MIN(smoothy, (h - 1) / 2);\n        *ppixmin = pixBlockconv(pixmin2, smoothx, smoothy);\n        *ppixmax = pixBlockconv(pixmax2, smoothx, smoothy);\n    }\n    else {\n        *ppixmin = pixClone(pixmin2);\n        *ppixmax = pixClone(pixmax2);\n    }\n    pixCopyResolution(*ppixmin, pixs);\n    pixCopyResolution(*ppixmax, pixs);\n    pixDestroy(&pixmin2);\n    pixDestroy(&pixmax2);\n\n    return 0;\n}\n\n\n/*!\n * \\brief   pixSetLowContrast()\n *\n * \\param[in]    pixs1      8 bpp\n * \\param[in]    pixs2      8 bpp\n * \\param[in]    mindiff    minimum difference to accept as valid\n * \\return  0 if OK; 1 if no pixel diffs are large enough, or on error\n *\n * <pre>\n * Notes:\n *      (1) This compares corresponding pixels in pixs1 and pixs2.\n *          When they differ by less than %mindiff, set the pixel\n *          values to 0 in each.  Each pixel typically represents a tile\n *          in a larger image, and a very small difference between\n *          the min and max in the tile indicates that the min and max\n *          values are not to be trusted.\n *      (2) If contrast (pixel difference) detection is expected to fail,\n *          caller should check return value.\n * </pre>\n */\nl_ok\npixSetLowContrast(PIX     *pixs1,\n                  PIX     *pixs2,\n                  l_int32  mindiff)\n{\nl_int32    i, j, w, h, d, wpl, val1, val2, found;\nl_uint32  *data1, *data2, *line1, *line2;\n\n    PROCNAME(\"pixSetLowContrast\");\n\n    if (!pixs1 || !pixs2)\n        return ERROR_INT(\"pixs1 and pixs2 not both defined\", procName, 1);\n    if (pixSizesEqual(pixs1, pixs2) == 0)\n        return ERROR_INT(\"pixs1 and pixs2 not equal size\", procName, 1);\n    pixGetDimensions(pixs1, &w, &h, &d);\n    if (d != 8)\n        return ERROR_INT(\"depth not 8 bpp\", procName, 1);\n    if (mindiff > 254) return 0;\n\n    data1 = pixGetData(pixs1);\n    data2 = pixGetData(pixs2);\n    wpl = pixGetWpl(pixs1);\n    found = 0;  /* init to not finding any diffs >= mindiff */\n    for (i = 0; i < h; i++) {\n        line1 = data1 + i * wpl;\n        line2 = data2 + i * wpl;\n        for (j = 0; j < w; j++) {\n            val1 = GET_DATA_BYTE(line1, j);\n            val2 = GET_DATA_BYTE(line2, j);\n            if (L_ABS(val1 - val2) >= mindiff) {\n                found = 1;\n                break;\n            }\n        }\n        if (found) break;\n    }\n    if (!found) {\n        L_WARNING(\"no pixel pair diffs as large as mindiff\\n\", procName);\n        pixClearAll(pixs1);\n        pixClearAll(pixs2);\n        return 1;\n    }\n\n    for (i = 0; i < h; i++) {\n        line1 = data1 + i * wpl;\n        line2 = data2 + i * wpl;\n        for (j = 0; j < w; j++) {\n            val1 = GET_DATA_BYTE(line1, j);\n            val2 = GET_DATA_BYTE(line2, j);\n            if (L_ABS(val1 - val2) < mindiff) {\n                SET_DATA_BYTE(line1, j, 0);\n                SET_DATA_BYTE(line2, j, 0);\n            }\n        }\n    }\n\n    return 0;\n}\n\n\n/*!\n * \\brief   pixLinearTRCTiled()\n *\n * \\param[in]    pixd     [optional] 8 bpp\n * \\param[in]    pixs     8 bpp, not colormapped\n * \\param[in]    sx, sy   tile dimensions\n * \\param[in]    pixmin   pix of min values in tiles\n * \\param[in]    pixmax   pix of max values in tiles\n * \\return  pixd always\n *\n * <pre>\n * Notes:\n *      (1) pixd can be equal to pixs (in-place operation) or\n *          null (makes a new pixd).\n *      (2) sx and sy give the tile size; they are typically at least 20.\n *      (3) pixmin and pixmax are generated by pixMinMaxTiles()\n *      (4) For each tile, this does a linear expansion of the dynamic\n *          range so that the min value in the tile becomes 0 and the\n *          max value in the tile becomes 255.\n *      (5) The LUTs that do the mapping are generated as needed\n *          and stored for reuse in an integer array within the ptr array iaa[].\n * </pre>\n */\nPIX *\npixLinearTRCTiled(PIX       *pixd,\n                  PIX       *pixs,\n                  l_int32    sx,\n                  l_int32    sy,\n                  PIX       *pixmin,\n                  PIX       *pixmax)\n{\nl_int32    i, j, k, m, w, h, wt, ht, wpl, wplt, xoff, yoff;\nl_int32    minval, maxval, val, sval;\nl_int32   *ia;\nl_int32  **iaa;\nl_uint32  *data, *datamin, *datamax, *line, *tline, *linemin, *linemax;\n\n    PROCNAME(\"pixLinearTRCTiled\");\n\n    if (!pixs || pixGetDepth(pixs) != 8)\n        return (PIX *)ERROR_PTR(\"pixs undefined or not 8 bpp\", procName, pixd);\n    if (pixd && pixd != pixs)\n        return (PIX *)ERROR_PTR(\"pixd not null or == pixs\", procName, pixd);\n    if (pixGetColormap(pixs))\n        return (PIX *)ERROR_PTR(\"pixs is colormapped\", procName, pixd);\n    if (!pixmin || !pixmax)\n        return (PIX *)ERROR_PTR(\"pixmin & pixmax not defined\", procName, pixd);\n    if (sx < 5 || sy < 5)\n        return (PIX *)ERROR_PTR(\"sx and/or sy less than 5\", procName, pixd);\n\n    if ((iaa = (l_int32 **)LEPT_CALLOC(256, sizeof(l_int32 *))) == NULL)\n        return (PIX *)ERROR_PTR(\"iaa not made\", procName, NULL);\n    if ((pixd = pixCopy(pixd, pixs)) == NULL) {\n        LEPT_FREE(iaa);\n        return (PIX *)ERROR_PTR(\"pixd not made\", procName, NULL);\n    }\n    pixGetDimensions(pixd, &w, &h, NULL);\n\n    data = pixGetData(pixd);\n    wpl = pixGetWpl(pixd);\n    datamin = pixGetData(pixmin);\n    datamax = pixGetData(pixmax);\n    wplt = pixGetWpl(pixmin);\n    pixGetDimensions(pixmin, &wt, &ht, NULL);\n    for (i = 0; i < ht; i++) {\n        line = data + sy * i * wpl;\n        linemin = datamin + i * wplt;\n        linemax = datamax + i * wplt;\n        yoff = sy * i;\n        for (j = 0; j < wt; j++) {\n            xoff = sx * j;\n            minval = GET_DATA_BYTE(linemin, j);\n            maxval = GET_DATA_BYTE(linemax, j);\n            if (maxval == minval) {\n                L_ERROR(\"shouldn't happen! i,j = %d,%d, minval = %d\\n\",\n                        procName, i, j, minval);\n                continue;\n            }\n            if ((ia = iaaGetLinearTRC(iaa, maxval - minval)) == NULL) {\n                L_ERROR(\"failure to make ia for j = %d!\\n\", procName, j);\n                continue;\n            }\n            for (k = 0; k < sy && yoff + k < h; k++) {\n                tline = line + k * wpl;\n                for (m = 0; m < sx && xoff + m < w; m++) {\n                    val = GET_DATA_BYTE(tline, xoff + m);\n                    sval = val - minval;\n                    sval = L_MAX(0, sval);\n                    SET_DATA_BYTE(tline, xoff + m, ia[sval]);\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < 256; i++)\n        LEPT_FREE(iaa[i]);\n    LEPT_FREE(iaa);\n    return pixd;\n}\n\n\n/*!\n * \\brief   iaaGetLinearTRC()\n *\n * \\param[in]    iaa     bare array of ptrs to l_int32\n * \\param[in]    diff    between min and max pixel values that are\n *                       to be mapped to 0 and 255\n * \\return  ia LUT with input (val - minval) and output a\n *                  value between 0 and 255)\n */\nstatic l_int32 *\niaaGetLinearTRC(l_int32  **iaa,\n                l_int32    diff)\n{\nl_int32    i;\nl_int32   *ia;\nl_float32  factor;\n\n    PROCNAME(\"iaaGetLinearTRC\");\n\n    if (!iaa)\n        return (l_int32 *)ERROR_PTR(\"iaa not defined\", procName, NULL);\n\n    if (iaa[diff] != NULL)  /* already have it */\n       return iaa[diff];\n\n    if ((ia = (l_int32 *)LEPT_CALLOC(256, sizeof(l_int32))) == NULL)\n        return (l_int32 *)ERROR_PTR(\"ia not made\", procName, NULL);\n    iaa[diff] = ia;\n    if (diff == 0) {  /* shouldn't happen */\n        for (i = 0; i < 256; i++)\n            ia[i] = 128;\n    }\n    else {\n        factor = 255. / (l_float32)diff;\n        for (i = 0; i < diff + 1; i++)\n            ia[i] = (l_int32)(factor * i + 0.5);\n        for (i = diff + 1; i < 256; i++)\n            ia[i] = 255;\n    }\n\n    return ia;\n}\n"], "filenames": ["prog/adaptmap_reg.c", "src/adaptmap.c"], "buggy_code_start_loc": [60, 1473], "buggy_code_end_loc": [166, 1550], "fixing_code_start_loc": [60, 1472], "fixing_code_end_loc": [187, 1543], "type": "CWE-125", "message": "Leptonica before 1.80.0 allows a heap-based buffer over-read in rasteropGeneralLow, related to adaptmap_reg.c and adaptmap.c.", "other": {"cve": {"id": "CVE-2020-36279", "sourceIdentifier": "cve@mitre.org", "published": "2021-03-12T00:15:12.723", "lastModified": "2021-12-03T17:38:45.520", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Leptonica before 1.80.0 allows a heap-based buffer over-read in rasteropGeneralLow, related to adaptmap_reg.c and adaptmap.c."}, {"lang": "es", "value": "Leptonica versiones anteriores a 1.80.0, permite una lectura excesiva del b\u00fafer en la regi\u00f3n heap de la memoria en la funci\u00f3n rasteropGeneralLow, relacionada con los archivos adaptmap_reg.c y adaptmap.c"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:leptonica:leptonica:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.80.0", "matchCriteriaId": "1616069D-AF01-4FED-83F7-80566DF507D7"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:o:linux:linux_kernel:-:*:*:*:*:*:*:*", "matchCriteriaId": "703AF700-7A70-47E2-BC3A-7FD03B3CA9C1"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=22512", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/DanBloomberg/leptonica/commit/3c18c43b6a3f753f0dfff99610d46ad46b8bfac4", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/DanBloomberg/leptonica/compare/1.79.0...1.80.0", "source": "cve@mitre.org", "tags": ["Patch", "Release Notes", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/03/msg00037.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/JQUEA2X6UTH4DMYCMZAWE2QQLN5YANUA/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/RD5AIWHWE334HGYZJR2U3I3JYKSSO2LW/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202107-53", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/DanBloomberg/leptonica/commit/3c18c43b6a3f753f0dfff99610d46ad46b8bfac4"}}