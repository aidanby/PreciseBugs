{"buggy_code": ["/* radare - LGPL - Copyright 2010-2021 - nibble, alvaro, pancake */\n\n#include <r_anal.h>\n#include <r_parse.h>\n#include <r_util.h>\n\n#define READ_AHEAD 1\n#define SDB_KEY_BB \"bb.0x%\"PFMT64x \".0x%\"PFMT64x\n// XXX must be configurable by the user\n#define JMPTBLSZ 512\n#define JMPTBL_LEA_SEARCH_SZ 64\n#define JMPTBL_MAXFCNSIZE 4096\n#define R_ANAL_MAX_INCSTACK 8096\n#define BB_ALIGN 0x10\n#define MAX_SCAN_SIZE 0x7ffffff\n\n/* speedup analysis by removing some function overlapping checks */\n#define JAYRO_04 1\n\n// 16 KB is the maximum size for a basic block\n#define MAX_FLG_NAME_SIZE 64\n\n#define FIX_JMP_FWD 0\n#define D if (a->verbose)\n\n// 64KB max size\n// 256KB max function size\n#define MAX_FCN_SIZE (1024 * 256)\n\n// Max NOP count to stop analysis\n#define MAX_NOP_PREFIX_CNT 1024\n\n#define DB a->sdb_fcns\n#define EXISTS(x, ...) snprintf (key, sizeof (key) - 1, x, ## __VA_ARGS__), sdb_exists (DB, key)\n#define SETKEY(x, ...) snprintf (key, sizeof (key) - 1, x, ## __VA_ARGS__);\n\nR_API const char *r_anal_functiontype_tostring(int type) {\n\tswitch (type) {\n\tcase R_ANAL_FCN_TYPE_NULL: return \"null\";\n\tcase R_ANAL_FCN_TYPE_FCN: return \"fcn\";\n\tcase R_ANAL_FCN_TYPE_LOC: return \"loc\";\n\tcase R_ANAL_FCN_TYPE_SYM: return \"sym\";\n\tcase R_ANAL_FCN_TYPE_IMP: return \"imp\";\n\tcase R_ANAL_FCN_TYPE_INT: return \"int\"; // interrupt\n\tcase R_ANAL_FCN_TYPE_ROOT: return \"root\";\n\t}\n\treturn \"unk\";\n}\n\n#if READ_AHEAD\nstatic ut64 cache_addr = UT64_MAX;\n\n// TODO: move into io :?\nstatic int read_ahead(RAnal *anal, ut64 addr, ut8 *buf, int len) {\n\tstatic ut8 cache[1024];\n\tconst int cache_len = sizeof (cache);\n\n\tif (len < 1) {\n\t\treturn 0;\n\t}\n\tif (len > cache_len) {\n\t\tint a = anal->iob.read_at (anal->iob.io, addr, buf, len); // double read\n\t\tmemcpy (cache, buf, cache_len);\n\t\tcache_addr = addr;\n\t\treturn a;\n\t}\n\n\tut64 addr_end = UT64_ADD_OVFCHK (addr, len)? UT64_MAX: addr + len;\n\tut64 cache_addr_end = UT64_ADD_OVFCHK (cache_addr, cache_len)? UT64_MAX: cache_addr + cache_len;\n\tbool isCached = ((addr != UT64_MAX) && (addr >= cache_addr) && (addr_end < cache_addr_end));\n\tif (isCached) {\n\t\tmemcpy (buf, cache + (addr - cache_addr), len);\n\t} else {\n\t\tanal->iob.read_at (anal->iob.io, addr, cache, sizeof (cache));\n\t\tmemcpy (buf, cache, len);\n\t\tcache_addr = addr;\n\t}\n\treturn len;\n}\n#else\nstatic int read_ahead(RAnal *anal, ut64 addr, ut8 *buf, int len) {\n\treturn anal->iob.read_at (anal->iob.io, addr, buf, len);\n}\n#endif\n\nR_API void r_anal_function_invalidate_read_ahead_cache(void) {\n#if READ_AHEAD\n\tcache_addr = UT64_MAX;\n#endif\n}\n\nstatic int cmpaddr(const void *_a, const void *_b) {\n\tconst RAnalBlock *a = _a, *b = _b;\n\treturn a->addr > b->addr ? 1 : (a->addr < b->addr ? -1 : 0);\n}\n\nR_API int r_anal_function_resize(RAnalFunction *fcn, int newsize) {\n\tRAnal *anal = fcn->anal;\n\tRAnalBlock *bb;\n\tRListIter *iter, *iter2;\n\n\tr_return_val_if_fail (fcn, false);\n\n\tif (newsize < 1) {\n\t\treturn false;\n\t}\n\n\t// XXX this is something we should probably do for all the archs\n\tbool is_arm = anal->cur->arch && !strncmp (anal->cur->arch, \"arm\", 3);\n\tif (is_arm) {\n\t\treturn true;\n\t}\n\n\tut64 eof = fcn->addr + newsize;\n\tr_list_foreach_safe (fcn->bbs, iter, iter2, bb) {\n\t\tif (bb->addr >= eof) {\n\t\t\tr_anal_function_remove_block (fcn, bb);\n\t\t\tcontinue;\n\t\t}\n\t\tif (bb->addr + bb->size >= eof) {\n\t\t\tr_anal_block_set_size (bb, eof - bb->addr);\n\t\t\tr_anal_block_update_hash (bb);\n\t\t}\n\t\tif (bb->jump != UT64_MAX && bb->jump >= eof) {\n\t\t\tbb->jump = UT64_MAX;\n\t\t}\n\t\tif (bb->fail != UT64_MAX && bb->fail >= eof) {\n\t\t\tbb->fail = UT64_MAX;\n\t\t}\n\t}\n\treturn true;\n}\n\n// Create a new 0-sized basic block inside the function\nstatic RAnalBlock *fcn_append_basic_block(RAnal *anal, RAnalFunction *fcn, ut64 addr) {\n\tRAnalBlock *bb = r_anal_create_block (anal, addr, 0);\n\tif (!bb) {\n\t\treturn NULL;\n\t}\n\tr_anal_function_add_block (fcn, bb);\n\tbb->stackptr = fcn->stack;\n\tbb->parent_stackptr = fcn->stack;\n\treturn bb;\n}\n\n#define gotoBeach(x) ret = x; goto beach;\n\nstatic bool is_invalid_memory(RAnal *anal, const ut8 *buf, int len) {\n\tif (anal->opt.nonull > 0) {\n\t\tint i;\n\t\tconst int count = R_MIN (len, anal->opt.nonull);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tif (buf[i]) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == count) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn !memcmp (buf, \"\\xff\\xff\\xff\\xff\", R_MIN (len, 4));\n}\n\nstatic bool is_symbol_flag(const char *name) {\n\treturn strstr (name, \"imp.\")\n\t\t|| strstr (name, \"dbg.\")\n\t\t|| strstr (name, \"sym.\")\n\t\t|| !strncmp (name, \"entry\", 5)\n\t\t|| !strcmp (name, \"main\");\n}\n\nstatic bool next_instruction_is_symbol(RAnal *anal, RAnalOp *op) {\n\tr_return_val_if_fail (anal && op && anal->flb.get_at, false);\n\tRFlagItem *fi = anal->flb.get_at (anal->flb.f, op->addr + op->size, false);\n\treturn (fi && fi->name && is_symbol_flag (fi->name));\n}\n\nstatic bool is_delta_pointer_table(RAnal *anal, RAnalFunction *fcn, ut64 addr, ut64 lea_ptr, ut64 *jmptbl_addr, ut64 *casetbl_addr, RAnalOp *jmp_aop) {\n\tint i;\n\tut64 dst;\n\tst32 jmptbl[64] = {0};\n\t/* check if current instruction is followed by an ujmp */\n\tut8 buf[JMPTBL_LEA_SEARCH_SZ];\n\tRAnalOp *aop = jmp_aop;\n\tRAnalOp omov_aop = {0};\n\tRAnalOp mov_aop = {0};\n\tRAnalOp add_aop = {0};\n\tRRegItem *reg_src = NULL, *o_reg_dst = NULL;\n\tRAnalValue cur_scr, cur_dst = {0};\n\tread_ahead (anal, addr, (ut8*)buf, sizeof (buf));\n\tbool isValid = false;\n\tfor (i = 0; i + 8 < JMPTBL_LEA_SEARCH_SZ; i++) {\n\t\tut64 at = addr + i;\n\t\tint left = JMPTBL_LEA_SEARCH_SZ - i;\n\t\tint len = r_anal_op (anal, aop, at, buf + i, left, R_ANAL_OP_MASK_BASIC | R_ANAL_OP_MASK_HINT | R_ANAL_OP_MASK_VAL);\n\t\tif (len < 1) {\n\t\t\tlen = 1;\n\t\t}\n\t\tif (aop->type == R_ANAL_OP_TYPE_UJMP || aop->type == R_ANAL_OP_TYPE_RJMP) {\n\t\t\tisValid = true;\n\t\t\tbreak;\n\t\t}\n\t\tif (aop->type == R_ANAL_OP_TYPE_JMP || aop->type == R_ANAL_OP_TYPE_CJMP) {\n\t\t\tbreak;\n\t\t}\n\t\tif (aop->type == R_ANAL_OP_TYPE_MOV) {\n\t\t\tomov_aop = mov_aop;\n\t\t\tmov_aop = *aop;\n\t\t\to_reg_dst = cur_dst.reg;\n\t\t\tif (mov_aop.dst) {\n\t\t\t\tcur_dst = *mov_aop.dst;\n\t\t\t}\n\t\t\tif (mov_aop.src[0]) {\n\t\t\t\tcur_scr = *mov_aop.src[0];\n\t\t\t\treg_src = cur_scr.regdelta;\n\t\t\t}\n\t\t}\n\t\tif (aop->type == R_ANAL_OP_TYPE_ADD) {\n\t\t\tadd_aop = *aop;\n\t\t}\n\t\tr_anal_op_fini (aop);\n\t\ti += len - 1;\n\t}\n\tif (!isValid) {\n\t\treturn false;\n\t}\n\n\t// check if we have a msvc 19xx style jump table using rva table entries\n\t// lea reg1, [base_addr]\n\t// mov reg2, dword [reg1 + tbl_off*4 + tbl_loc_off]\n\t// add reg2, reg1\n\t// jmp reg2\n\tif (mov_aop.type && add_aop.type && mov_aop.addr < add_aop.addr && add_aop.addr < jmp_aop->addr\n\t    && mov_aop.disp && mov_aop.disp != UT64_MAX) {\n\t\t// disp in this case should be tbl_loc_off\n\t\t*jmptbl_addr += mov_aop.disp;\n\t\tif (o_reg_dst && reg_src && o_reg_dst->offset == reg_src->offset && omov_aop.disp != UT64_MAX) {\n\t\t\t// Special case for indirection\n\t\t\t// lea reg1, [base_addr]\n\t\t\t// movzx reg2, byte [reg1 + tbl_off + casetbl_loc_off]\n\t\t\t// mov reg3, dword [reg1 + reg2*4 + tbl_loc_off]\n\t\t\t// add reg3, reg1\n\t\t\t// jmp reg3\n\t\t\t*casetbl_addr += omov_aop.disp;\n\t\t}\n\t}\n#if 0\n\t// required for the last jmptbl.. but seems to work without it and breaks other tests\n\tif (mov_aop.type && mov_aop.ptr) {\n\t\t*jmptbl_addr += mov_aop.ptr;\n\t\t// absjmptbl\n\t\tlea_ptr = mov_aop.ptr;\n\t}\n#endif\n\t/* check if jump table contains valid deltas */\n\tread_ahead (anal, *jmptbl_addr, (ut8 *)&jmptbl, 64);\n\tfor (i = 0; i < 3; i++) {\n\t\tdst = lea_ptr + (st32)r_read_le32 (jmptbl);\n\t\tif (!anal->iob.is_valid_offset (anal->iob.io, dst, 0)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (dst > fcn->addr + JMPTBL_MAXFCNSIZE) {\n\t\t\treturn false;\n\t\t}\n\t\tif (anal->opt.jmpabove && dst < (fcn->addr < JMPTBL_MAXFCNSIZE ? 0 : fcn->addr - JMPTBL_MAXFCNSIZE)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic ut64 try_get_cmpval_from_parents(RAnal *anal, RAnalFunction *fcn, RAnalBlock *my_bb, const char *cmp_reg) {\n\tif (!cmp_reg) {\n\t\tif (anal->verbose) {\n\t\t\teprintf (\"try_get_cmpval_from_parents: cmp_reg not defined.\\n\");\n\t\t}\n\t\treturn UT64_MAX;\n\t}\n\tr_return_val_if_fail (fcn && fcn->bbs, UT64_MAX);\n\tRListIter *iter;\n\tRAnalBlock *tmp_bb;\n\tr_list_foreach (fcn->bbs, iter, tmp_bb) {\n\t\tif (tmp_bb->jump == my_bb->addr || tmp_bb->fail == my_bb->addr) {\n\t\t\tif (tmp_bb->cmpreg == cmp_reg) {\n\t\t\t\tif (tmp_bb->cond) {\n\t\t\t\t\tif (tmp_bb->cond->type == R_ANAL_COND_HI || tmp_bb->cond->type == R_ANAL_COND_GT) {\n\t\t\t\t\t\treturn tmp_bb->cmpval + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn tmp_bb->cmpval;\n\t\t\t}\n\t\t}\n\t}\n\treturn UT64_MAX;\n}\n\nstatic bool regs_exist(RAnalValue *src, RAnalValue *dst) {\n\tr_return_val_if_fail (src && dst, false);\n\treturn src->reg && dst->reg && src->reg->name && dst->reg->name;\n}\n\n// 0 if not skipped; 1 if skipped; 2 if skipped before\nstatic int skip_hp(RAnal *anal, RAnalFunction *fcn, RAnalOp *op, RAnalBlock *bb, ut64 addr, int oplen, int un_idx, int *idx) {\n\t// this step is required in order to prevent infinite recursion in some cases\n\tif ((addr + un_idx - oplen) == fcn->addr) {\n\t\t// use addr instead of op->addr to mark repeat\n\t\tif (!anal->flb.exist_at (anal->flb.f, \"skip\", 4, addr)) {\n\t\t\tchar *name = r_str_newf (\"skip.%\"PFMT64x,  addr);\n\t\t\tanal->flb.set (anal->flb.f, name, addr, oplen);\n\t\t\tfree (name);\n\t\t\tfcn->addr += oplen;\n\t\t\tr_anal_block_relocate (bb, bb->addr + oplen, bb->size - oplen);\n\t\t\t*idx = un_idx;\n\t\t\treturn 1;\n\t\t}\n\t\treturn 2;\n\t}\n\treturn 0;\n}\n\nstatic bool purity_checked(HtUP *ht, RAnalFunction *fcn) {\n\tbool checked;\n\tht_up_find (ht, fcn->addr, &checked);\n\treturn checked;\n}\n\n/*\n * Checks whether a given function is pure and sets its 'is_pure' field.\n * This function marks fcn 'not pure' if fcn, or any function called by fcn, accesses data\n * from outside, even if it only READS it.\n * Probably worth changing it in the future, so that it marks fcn 'impure' only when it\n * (or any function called by fcn) MODIFIES external data.\n */\nstatic void check_purity(HtUP *ht, RAnalFunction *fcn) {\n\tRListIter *iter;\n\tRList *refs = r_anal_function_get_refs (fcn);\n\tRAnalRef *ref;\n\tht_up_insert (ht, fcn->addr, NULL);\n\tfcn->is_pure = true;\n\tr_list_foreach (refs, iter, ref) {\n\t\tif (ref->type == R_ANAL_REF_TYPE_CALL || ref->type == R_ANAL_REF_TYPE_CODE) {\n\t\t\tRAnalFunction *called_fcn = r_anal_get_fcn_in (fcn->anal, ref->addr, 0);\n\t\t\tif (!called_fcn) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!purity_checked (ht, called_fcn)) {\n\t\t\t\tcheck_purity (ht, called_fcn);\n\t\t\t}\n\t\t\tif (!called_fcn->is_pure) {\n\t\t\t\tfcn->is_pure = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ref->type == R_ANAL_REF_TYPE_DATA) {\n\t\t\tfcn->is_pure = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tr_list_free (refs);\n}\n\ntypedef struct {\n\tut64 op_addr;\n\tut64 leaddr;\n\tchar *reg;\n} leaddr_pair;\n\nstatic void free_leaddr_pair(void *pair) {\n\tleaddr_pair *_pair = pair;\n\tfree (_pair->reg);\n\tfree (_pair);\n}\n\nstatic RAnalBlock *bbget(RAnal *anal, ut64 addr, bool jumpmid) {\n\tRList *intersecting = r_anal_get_blocks_in (anal, addr);\n\tRListIter *iter;\n\tRAnalBlock *bb;\n\n\tRAnalBlock *ret = NULL;\n\tr_list_foreach (intersecting, iter, bb) {\n\t\tut64 eaddr = bb->addr + bb->size;\n\t\tif (((bb->addr >= eaddr && addr == bb->addr)\n\t\t     || r_anal_block_contains (bb, addr))\n\t\t    && (!jumpmid || r_anal_block_op_starts_at (bb, addr))) {\n\t\t\tif (anal->opt.delay) {\n\t\t\t\tut8 *buf = malloc (bb->size);\n\t\t\t\tif (anal->iob.read_at (anal->iob.io, bb->addr, buf, bb->size)) {\n\t\t\t\t\tconst int last_instr_idx = bb->ninstr - 1;\n\t\t\t\t\tbool in_delay_slot = false;\n\t\t\t\t\tint i;\n\t\t\t\t\tfor (i = last_instr_idx; i >= 0; i--) {\n\t\t\t\t\t\tconst ut64 off = r_anal_bb_offset_inst (bb, i);\n\t\t\t\t\t\tconst ut64 at = bb->addr + off;\n\t\t\t\t\t\tif (addr <= at || off >= bb->size) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tRAnalOp op;\n\t\t\t\t\t\tint size = r_anal_op (anal, &op, at, buf + off, bb->size - off, R_ANAL_OP_MASK_BASIC);\n\t\t\t\t\t\tif (size > 0 && op.delay) {\n\t\t\t\t\t\t\tif (op.delay >= last_instr_idx - i) {\n\t\t\t\t\t\t\t\tin_delay_slot = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tr_anal_op_fini (&op);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_anal_op_fini (&op);\n\t\t\t\t\t}\n\t\t\t\t\tif (in_delay_slot) {\n\t\t\t\t\t\tfree (buf);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (buf);\n\t\t\t}\n\t\t\tret = bb;\n\t\t\tbreak;\n\t\t}\n\t}\n\tr_list_free (intersecting);\n\treturn ret;\n}\n\ntypedef struct {\n\tRAnalFunction *fcn;\n\tconst int stack_diff;\n} BlockTakeoverCtx;\n\nstatic bool fcn_takeover_block_recursive_followthrough_cb(RAnalBlock *block, void *user) {\n\tBlockTakeoverCtx *ctx = user;\n\tRAnalFunction *our_fcn = ctx->fcn;\n\tr_anal_block_ref (block);\n\twhile (!r_list_empty (block->fcns)) {\n\t\tRAnalFunction *other_fcn = r_list_first (block->fcns);\n\t\tif (other_fcn->addr == block->addr) {\n\t\t\treturn false;\n\t\t}\n\t\t// Steal vars from this block\n\t\tsize_t i;\n\t\tfor (i = 0; i < block->ninstr; i++) {\n\t\t\tconst ut64 addr = r_anal_bb_opaddr_i (block, i);\n\t\t\tRPVector *vars_used = r_anal_function_get_vars_used_at (other_fcn, addr);\n\t\t\tif (!vars_used) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// vars_used will get modified if r_anal_var_remove_access_at gets called\n\t\t\tRPVector *cloned_vars_used = (RPVector *)r_vector_clone ((RVector *)vars_used);\n\t\t\tvoid **it;\n\t\t\tr_pvector_foreach (cloned_vars_used, it) {\n\t\t\t\tRAnalVar *other_var = *it;\n\t\t\t\tconst int actual_delta = other_var->kind == R_ANAL_VAR_KIND_SPV\n\t\t\t\t\t? other_var->delta + ctx->stack_diff\n\t\t\t\t\t: other_var->delta + (other_fcn->bp_off - our_fcn->bp_off);\n\t\t\t\tRAnalVar *our_var = r_anal_function_get_var (our_fcn, other_var->kind, actual_delta);\n\t\t\t\tif (!our_var) {\n\t\t\t\t\tour_var = r_anal_function_set_var (our_fcn, actual_delta, other_var->kind, other_var->type, 0, other_var->isarg, other_var->name);\n\t\t\t\t}\n\t\t\t\tif (our_var) {\n\t\t\t\t\tRAnalVarAccess *acc = r_anal_var_get_access_at (other_var, addr);\n\t\t\t\t\tr_anal_var_set_access (our_var, acc->reg, addr, acc->type, acc->stackptr);\n\t\t\t\t}\n\t\t\t\tr_anal_var_remove_access_at (other_var, addr);\n\t\t\t\tif (r_vector_empty (&other_var->accesses)) {\n\t\t\t\t\tr_anal_function_delete_var (other_fcn, other_var);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_pvector_free (cloned_vars_used);\n\t\t}\n\n\t\t// TODO: remove block->ninstr from other_fcn considering delay slots\n\t\tr_anal_function_remove_block (other_fcn, block);\n\t}\n\tblock->stackptr -= ctx->stack_diff;\n\tblock->parent_stackptr -= ctx->stack_diff;\n\tr_anal_function_add_block (our_fcn, block);\n\t// TODO: add block->ninstr from our_fcn considering delay slots\n\tr_anal_block_unref (block);\n\treturn true;\n}\n\n// Remove block and all of its recursive successors from all its functions and add them only to fcn\nstatic void fcn_takeover_block_recursive(RAnalFunction *fcn, RAnalBlock *start_block) {\n\tBlockTakeoverCtx ctx = { fcn, start_block->parent_stackptr - fcn->stack};\n\tr_anal_block_recurse_followthrough (start_block, fcn_takeover_block_recursive_followthrough_cb, &ctx);\n}\n\nstatic const char *retpoline_reg(RAnal *anal, ut64 addr) {\n\tRFlagItem *flag = anal->flag_get (anal->flb.f, addr);\n\tif (flag) {\n\t\tconst char *token = \"x86_indirect_thunk_\";\n\t\tconst char *thunk = strstr (flag->name, token);\n\t\tif (thunk) {\n\t\t\treturn thunk + strlen (token);\n\t\t}\n\t}\n#if 0\n// TODO: implement following code analysis check for stripped binaries:\n// 1) op(addr).type == CALL\n// 2) call_dest = op(addr).addr\n// 3) op(call_dest).type == STORE\n// 4) op(call_dest + op(call_dest).size).type == RET\n[0x00000a65]> pid 6\n0x00000a65  sym.__x86_indirect_thunk_rax:\n0x00000a65  .------- e807000000  call 0xa71\n0x00000a6a  |              f390  pause\n0x00000a6c  |            0faee8  lfence\n0x00000a6f  |              ebf9  jmp 0xa6a\n0x00000a71  `---->     48890424  mov qword [rsp], rax\n0x00000a75                   c3  ret\n#endif\n\treturn NULL;\n}\n\nstatic void analyze_retpoline(RAnal *anal, RAnalOp *op) {\n\tif (anal->opt.retpoline) {\n\t\tconst char *rr = retpoline_reg (anal, op->jump);\n\t\tif (rr) {\n\t\t\top->type = R_ANAL_OP_TYPE_RJMP;\n\t\t\top->reg = rr;\n\t\t}\n\t}\n}\n\nstatic inline bool op_is_set_bp(const char *op_dst, const char *op_src, const char *bp_reg, const char *sp_reg) {\n\tif (op_dst && op_src) {\n\t\treturn !strcmp (bp_reg, op_dst) && !strcmp (sp_reg, op_src);\n\t}\n\treturn false;\n}\n\nstatic inline bool does_arch_destroys_dst(const char *arch) {\n\treturn arch && (!strncmp (arch, \"arm\", 3) || !strcmp (arch, \"riscv\") || !strcmp (arch, \"ppc\"));\n}\n\nstatic inline bool has_vars(RAnal *anal, ut64 addr) {\n\tRAnalFunction *tmp_fcn = r_anal_get_fcn_in (anal, addr, 0);\n\tif (tmp_fcn) {\n\t\treturn r_anal_var_count_all (tmp_fcn) > 0;\n\t}\n\treturn false;\n}\n\nstatic int fcn_recurse(RAnal *anal, RAnalFunction *fcn, ut64 addr, ut64 len, int depth) {\n\tchar *bp_reg = NULL;\n\tchar *sp_reg = NULL;\n\tchar *op_dst = NULL;\n\tchar *op_src = NULL;\n\tif (depth < 1) {\n\t\tif (anal->verbose) {\n\t\t\teprintf (\"Too deep fcn_recurse at 0x%\"PFMT64x \"\\n\", addr);\n\t\t}\n\t\treturn R_ANAL_RET_ERROR; // MUST BE TOO DEEP\n\t}\n\t// TODO Store all this stuff in the heap so we save memory in the stack\n\tRAnalOp *op = NULL;\n\tchar *movbasereg = NULL;\n\tconst int addrbytes = anal->iob.io ? anal->iob.io->addrbytes : 1;\n\tchar *last_reg_mov_lea_name = NULL;\n\tRAnalBlock *bb = NULL;\n\tRAnalBlock *bbg = NULL;\n\tint ret = R_ANAL_RET_END, skip_ret = 0;\n\tbool overlapped = false;\n\tint oplen, idx = 0;\n\tsize_t lea_cnt = 0;\n\tsize_t nop_prefix_cnt = 0;\n\tstatic ut64 cmpval = UT64_MAX; // inherited across functions, otherwise it breaks :?\n\tstruct {\n\t\tint cnt;\n\t\tint idx;\n\t\tint after;\n\t\tint pending;\n\t\tint adjust;\n\t\tint un_idx; // delay.un_idx\n\t} delay = {\n\t\t0\n\t};\n\tbool arch_destroys_dst = does_arch_destroys_dst (anal->cur->arch);\n\tconst bool is_arm = anal->cur->arch && !strncmp (anal->cur->arch, \"arm\", 3);\n\tconst bool is_v850 = is_arm ? false: (anal->cur->arch && (!strncmp (anal->cur->arch, \"v850\", 4) || !strncmp (anal->coreb.cfgGet (anal->coreb.core, \"asm.cpu\"), \"v850\", 4)));\n\tconst bool is_x86 = is_arm ? false: anal->cur->arch && !strncmp (anal->cur->arch, \"x86\", 3);\n\tconst bool is_amd64 = is_x86 ? fcn->cc && !strcmp (fcn->cc, \"amd64\") : false;\n\tconst bool is_dalvik = is_x86 ? false : anal->cur->arch && !strncmp (anal->cur->arch, \"dalvik\", 6);\n\tRRegItem *variadic_reg = NULL;\n\tif (is_amd64) {\n\t\tvariadic_reg = r_reg_get (anal->reg, \"rax\", R_REG_TYPE_GPR);\n\t}\n\tbool has_variadic_reg = !!variadic_reg;\n\n\tif (r_cons_is_breaked ()) {\n\t\treturn R_ANAL_RET_END;\n\t}\n\tif (anal->sleep) {\n\t\tr_sys_usleep (anal->sleep);\n\t}\n\n\t// check if address is readable //:\n\tif (!anal->iob.is_valid_offset (anal->iob.io, addr, 0)) {\n\t\tif (addr != UT64_MAX && !anal->iob.io->va) {\n\t\t\tif (anal->verbose) {\n\t\t\t\teprintf (\"Invalid address 0x%\"PFMT64x \". Try with io.va=true\\n\", addr);\n\t\t\t}\n\t\t}\n\t\treturn R_ANAL_RET_ERROR; // MUST BE TOO DEEP\n\t}\n\n\tRAnalFunction *fcn_at_addr = r_anal_get_function_at (anal, addr);\n\tif (fcn_at_addr && fcn_at_addr != fcn) {\n\t\treturn R_ANAL_RET_ERROR; // MUST BE NOT FOUND\n\t}\n\n\tRAnalBlock *existing_bb = bbget (anal, addr, anal->opt.jmpmid && is_x86);\n\tif (existing_bb) {\n\t\tbool existing_in_fcn = r_list_contains (existing_bb->fcns, fcn);\n\t\texisting_bb = r_anal_block_split (existing_bb, addr);\n\t\tif (!existing_in_fcn && existing_bb) {\n\t\t\tif (existing_bb->addr == fcn->addr) {\n\t\t\t\t// our function starts directly there, so we steal what is ours!\n\t\t\t\tfcn_takeover_block_recursive (fcn, existing_bb);\n\t\t\t}\n\t\t}\n\t\tif (existing_bb) {\n\t\t\tr_anal_block_unref (existing_bb);\n\t\t}\n\t\tif (anal->opt.recont) {\n\t\t\treturn R_ANAL_RET_END;\n\t\t}\n\t\tif (anal->verbose) {\n\t\t\teprintf (\"r_anal_function_bb() fails at 0x%\"PFMT64x \"\\n\", addr);\n\t\t}\n\t\treturn R_ANAL_RET_ERROR; // MUST BE NOT DUP\n\t}\n\n\tbb = fcn_append_basic_block (anal, fcn, addr);\n\t// we checked before whether there is a bb at addr, so the create should have succeeded\n\tr_return_val_if_fail (bb, R_ANAL_RET_ERROR);\n\n\tif (!anal->leaddrs) {\n\t\tanal->leaddrs = r_list_newf (free_leaddr_pair);\n\t\tif (!anal->leaddrs) {\n\t\t\teprintf (\"Cannot create leaddr list\\n\");\n\t\t\tgotoBeach (R_ANAL_RET_ERROR);\n\t\t}\n\t}\n\tstatic ut64 lea_jmptbl_ip = UT64_MAX;\n\tut64 last_reg_mov_lea_val = UT64_MAX;\n\tbool last_is_reg_mov_lea = false;\n\tbool last_is_push = false;\n\tbool last_is_mov_lr_pc = false;\n\tut64 last_push_addr = UT64_MAX;\n\tif (anal->limit && addr + idx < anal->limit->from) {\n\t\tgotoBeach (R_ANAL_RET_END);\n\t}\n\n\tbool varset = has_vars (anal, addr); // Checks if var is already analyzed at given addr\n\n\tut64 movdisp = UT64_MAX; // used by jmptbl when coded as \"mov Reg,[Reg*Scale+Disp]\"\n\tut64 movscale = 0;\n\tint maxlen = len * addrbytes;\n\tif (is_dalvik) {\n\t\tbool skipAnalysis = false;\n\t\tif (!strncmp (fcn->name, \"sym.\", 4)) {\n\t\t\tif (!strncmp (fcn->name + 4, \"imp.\", 4)) {\n\t\t\t\tskipAnalysis = true;\n\t\t\t} else if (strstr (fcn->name, \"field\")) {\n\t\t\t\tskipAnalysis = true;\n\t\t\t}\n\t\t}\n\t\tif (skipAnalysis) {\n\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t}\n\t}\n\tif ((maxlen - (addrbytes * idx)) > MAX_SCAN_SIZE) {\n\t\tif (anal->verbose) {\n\t\t\teprintf (\"Warning: Skipping large memory region.\\n\");\n\t\t}\n\t\tmaxlen = 0;\n\t}\n\tconst char *_bp_reg = anal->reg->name[R_REG_NAME_BP];\n\tconst char *_sp_reg = anal->reg->name[R_REG_NAME_SP];\n\tconst bool has_stack_regs = _bp_reg && _sp_reg;\n\tif (has_stack_regs) {\n\t\tbp_reg = strdup (_bp_reg);\n\t\tsp_reg = strdup (_sp_reg);\n\t}\n\n\top = r_anal_op_new ();\n\twhile (addrbytes * idx < maxlen) {\n\t\tif (!last_is_reg_mov_lea) {\n\t\t\tfree (last_reg_mov_lea_name);\n\t\t\tlast_reg_mov_lea_name = NULL;\n\t\t}\n\t\tif (anal->limit && anal->limit->to <= addr + idx) {\n\t\t\tbreak;\n\t\t}\nrepeat:\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\tut8 buf[32]; // 32 bytes is enough to hold any instruction.\n\t\tut32 at_delta = addrbytes * idx;\n\t\tut64 at = addr + at_delta;\n\t\tut64 bytes_read = R_MIN (len - at_delta, sizeof (buf));\n\t\tret = read_ahead (anal, at, buf, bytes_read);\n\n\t\tif (ret < 0) {\n\t\t\teprintf (\"Failed to read\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (is_invalid_memory (anal, buf, bytes_read)) {\n\t\t\tif (anal->verbose) {\n\t\t\t\teprintf (\"Warning: FFFF opcode at 0x%08\"PFMT64x \"\\n\", at);\n\t\t\t}\n\t\t\tgotoBeach (R_ANAL_RET_ERROR)\n\t\t}\n\t\tr_anal_op_fini (op);\n\t\tif ((oplen = r_anal_op (anal, op, at, buf, bytes_read, R_ANAL_OP_MASK_ESIL | R_ANAL_OP_MASK_VAL | R_ANAL_OP_MASK_HINT)) < 1) {\n\t\t\tif (anal->verbose) {\n\t\t\t\teprintf (\"Invalid instruction at 0x%\"PFMT64x\" with %d bits\\n\", at, anal->bits);\n\t\t\t}\n\t\t\t// gotoBeach (R_ANAL_RET_ERROR);\n\t\t\t// RET_END causes infinite loops somehow\n\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t}\n\t\tfree (op_dst);\n\t\top_dst = (op->dst && op->dst->reg && op->dst->reg->name)? strdup (op->dst->reg->name): NULL;\n\t\tfree (op_src);\n\t\top_src = (op->src[0] && op->src[0]->reg && op->src[0]->reg->name) ? strdup (op->src[0]->reg->name): NULL;\n\n\t\tif (anal->opt.nopskip && fcn->addr == at) {\n\t\t\tRFlagItem *fi = anal->flb.get_at (anal->flb.f, addr, false);\n\t\t\tif (!fi || strncmp (fi->name, \"sym.\", 4)) {\n\t\t\t\tif ((addr + delay.un_idx - oplen) == fcn->addr) {\n\t\t\t\t\tif (r_anal_block_relocate (bb, bb->addr + oplen, bb->size - oplen)) {\n\t\t\t\t\t\tfcn->addr += oplen;\n\t\t\t\t\t\tidx = delay.un_idx;\n\t\t\t\t\t\tgoto repeat;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch (op->type & R_ANAL_OP_TYPE_MASK) {\n\t\t\tcase R_ANAL_OP_TYPE_TRAP:\n\t\t\tcase R_ANAL_OP_TYPE_ILL:\n\t\t\tcase R_ANAL_OP_TYPE_NOP:\n\t\t\t\tnop_prefix_cnt++;\n\t\t\t\tif (nop_prefix_cnt > MAX_NOP_PREFIX_CNT) {\n\t\t\t\t\tgotoBeach (R_ANAL_RET_ERROR);\n\t\t\t\t}\n\t\t\t\tif (r_anal_block_relocate (bb, at + op->size, bb->size)) {\n\t\t\t\t\taddr = at + op->size;\n\t\t\t\t\tfcn->addr = addr;\n\t\t\t\t\tgoto repeat;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (op->hint.new_bits) {\n\t\t\tr_anal_hint_set_bits (anal, op->jump, op->hint.new_bits);\n\t\t}\n\t\tif (idx > 0 && !overlapped) {\n\t\t\tbbg = bbget (anal, at, anal->opt.jmpmid && is_x86);\n\t\t\tif (bbg && bbg != bb) {\n\t\t\t\tbb->jump = at;\n\t\t\t\tif (anal->opt.jmpmid && is_x86) {\n\t\t\t\t\t// This happens when we purposefully walked over another block and overlapped it\n\t\t\t\t\t// and now we hit an offset where the instructions match again.\n\t\t\t\t\t// So we need to split the overwalked block.\n\t\t\t\t\tRAnalBlock *split = r_anal_block_split (bbg, at);\n\t\t\t\t\tr_anal_block_unref (split);\n\t\t\t\t}\n\t\t\t\toverlapped = true;\n\t\t\t\tif (anal->verbose) {\n\t\t\t\t\teprintf (\"Overlapped at 0x%08\"PFMT64x \"\\n\", at);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!overlapped) {\n\t\t\tconst ut64 newbbsize = bb->size + oplen;\n\t\t\tif (newbbsize > MAX_FCN_SIZE) {\n\t\t\t\tgotoBeach (R_ANAL_RET_ERROR);\n\t\t\t}\n\t\t\tr_anal_bb_set_offset (bb, bb->ninstr++, at - bb->addr);\n\t\t\tr_anal_block_set_size (bb, newbbsize);\n\t\t\tfcn->ninstr++;\n\t\t}\n\t\tif (anal->opt.trycatch) {\n\t\t\tconst char *name = anal->coreb.getName (anal->coreb.core, at);\n\t\t\tif (name) {\n\t\t\t\tif (r_str_startswith (name, \"try.\") && r_str_endswith (name, \".from\")) {\n\t\t\t\t\tchar *handle = strdup (name);\n\t\t\t\t\t// handle = r_str_replace (handle, \".from\", \".to\", 0);\n\t\t\t\t\tut64 from_addr = anal->coreb.numGet (anal->coreb.core, handle);\n\t\t\t\t\thandle = r_str_replace (handle, \".from\", \".catch\", 0);\n\t\t\t\t\tut64 handle_addr = anal->coreb.numGet (anal->coreb.core, handle);\n\t\t\t\t\tbb->jump = at + oplen;\n\t\t\t\t\tif (from_addr != bb->addr) {\n\t\t\t\t\t\tbb->fail = handle_addr;\n\t\t\t\t\t\tret = r_anal_function_bb (anal, fcn, handle_addr, depth - 1);\n\t\t\t\t\t\teprintf (\"(%s) 0x%08\"PFMT64x\"\\n\", handle, handle_addr);\n\t\t\t\t\t\tif (bb->size == 0) {\n\t\t\t\t\t\t\tr_anal_function_remove_block (fcn, bb);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_anal_block_unref (bb);\n\t\t\t\t\t\tbb = fcn_append_basic_block (anal, fcn, addr);\n\t\t\t\t\t\tif (!bb) {\n\t\t\t\t\t\t\tgotoBeach (R_ANAL_RET_ERROR);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tidx += oplen;\n\t\tdelay.un_idx = idx;\n\t\tif (anal->opt.delay && op->delay > 0 && !delay.pending) {\n\t\t\t// Handle first pass through a branch delay jump:\n\t\t\t// Come back and handle the current instruction later.\n\t\t\t// Save the location of it in `delay.idx`\n\t\t\t// note, we have still increased size of basic block\n\t\t\t// (and function)\n\t\t\tif (anal->verbose) {\n\t\t\t\teprintf(\"Enter branch delay at 0x%08\"PFMT64x \". bb->sz=%\"PFMT64u\"\\n\", at - oplen, bb->size);\n\t\t\t}\n\t\t\tdelay.idx = idx - oplen;\n\t\t\tdelay.cnt = op->delay;\n\t\t\tdelay.pending = 1; // we need this in case the actual idx is zero...\n\t\t\tdelay.adjust = !overlapped; // adjustment is required later to avoid double count\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (delay.cnt > 0) {\n\t\t\t// if we had passed a branch delay instruction, keep\n\t\t\t// track of how many still to process.\n\t\t\tdelay.cnt--;\n\t\t\tif (!delay.cnt) {\n\t\t\t\tif (anal->verbose) {\n\t\t\t\t\teprintf (\"Last branch delayed opcode at 0x%08\"PFMT64x \". bb->sz=%\"PFMT64u\"\\n\", addr + idx - oplen, bb->size);\n\t\t\t\t}\n\t\t\t\tdelay.after = idx;\n\t\t\t\tidx = delay.idx;\n\t\t\t\t// At this point, we are still looking at the\n\t\t\t\t// last instruction in the branch delay group.\n\t\t\t\t// Next time, we will again be looking\n\t\t\t\t// at the original instruction that entered\n\t\t\t\t// the branch delay.\n\t\t\t}\n\t\t} else if (op->delay > 0 && delay.pending) {\n\t\t\tif (anal->verbose) {\n\t\t\t\teprintf (\"Revisit branch delay jump at 0x%08\"PFMT64x \". bb->sz=%\"PFMT64u\"\\n\", addr + idx - oplen, bb->size);\n\t\t\t}\n\t\t\t// This is the second pass of the branch delaying opcode\n\t\t\t// But we also already counted this instruction in the\n\t\t\t// size of the current basic block, so we need to fix that\n\t\t\tif (delay.adjust) {\n\t\t\t\tr_anal_block_set_size (bb, (ut64)addrbytes * (ut64)delay.after);\n\t\t\t\tfcn->ninstr--;\n\t\t\t\tif (anal->verbose) {\n\t\t\t\t\teprintf (\"Correct for branch delay @ %08\"PFMT64x \" bb.addr=%08\"PFMT64x \" corrected.bb=%\"PFMT64u\" f.uncorr=%\"PFMT64u\"\\n\",\n\t\t\t\t\taddr + idx - oplen, bb->addr, bb->size, r_anal_function_linear_size (fcn));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Next time, we go to the opcode after the delay count\n\t\t\t// Take care not to use this below, use delay.un_idx instead ...\n\t\t\tidx = delay.after;\n\t\t\tdelay.pending = delay.after = delay.idx = delay.adjust = 0;\n\t\t}\n\t\t// Note: if we got two branch delay instructions in a row due to an\n\t\t// compiler bug or junk or something it wont get treated as a delay\n\t\tswitch (op->stackop) {\n\t\tcase R_ANAL_STACK_INC:\n\t\t\tif (R_ABS (op->stackptr) < R_ANAL_MAX_INCSTACK) {\n\t\t\t\tfcn->stack += op->stackptr;\n\t\t\t\tif (fcn->stack > fcn->maxstack) {\n\t\t\t\t\tfcn->maxstack = fcn->stack;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbb->stackptr += op->stackptr;\n\t\t\tbreak;\n\t\tcase R_ANAL_STACK_RESET:\n\t\t\tbb->stackptr = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (op->ptr && op->ptr != UT64_MAX && op->ptr != UT32_MAX) {\n\t\t\t// swapped parameters wtf\n\t\t\tr_anal_xrefs_set (anal, op->addr, op->ptr, R_ANAL_REF_TYPE_DATA);\n\t\t}\n\t\tanalyze_retpoline (anal, op);\n\t\tswitch (op->type & R_ANAL_OP_TYPE_MASK) {\n\t\tcase R_ANAL_OP_TYPE_CMOV:\n\t\tcase R_ANAL_OP_TYPE_MOV:\n\t\t\tlast_is_reg_mov_lea = false;\n\t\t\tif (is_arm) { // mov lr, pc\n\t\t\t\tconst char *esil = r_strbuf_get (&op->esil);\n\t\t\t\tif (!r_str_cmp (esil, \"pc,lr,=\", -1)) {\n\t\t\t\t\tlast_is_mov_lr_pc = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (has_stack_regs && op_is_set_bp (op_dst, op_src, bp_reg, sp_reg)) {\n\t\t\t\tfcn->bp_off = fcn->stack;\n\t\t\t}\n\t\t\t// Is this a mov of immediate value into a register?\n\t\t\tif (op->dst && op->dst->reg && op->dst->reg->name && op->val > 0 && op->val != UT64_MAX) {\n\t\t\t\tfree (last_reg_mov_lea_name);\n\t\t\t\tif ((last_reg_mov_lea_name = strdup (op->dst->reg->name))) {\n\t\t\t\t\tlast_reg_mov_lea_val = op->val;\n\t\t\t\t\tlast_is_reg_mov_lea = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// skip mov reg, reg\n\t\t\tif (anal->opt.jmptbl && op->scale && op->ireg) {\n\t\t\t\tmovdisp = op->disp;\n\t\t\t\tmovscale = op->scale;\n\t\t\t\tif (op->src[0] && op->src[0]->reg) {\n\t\t\t\t\tfree (movbasereg);\n\t\t\t\t\tmovbasereg = strdup (op->src[0]->reg->name);\n\t\t\t\t} else {\n\t\t\t\t\tR_FREE (movbasereg);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (anal->opt.hpskip && regs_exist (op->src[0], op->dst) && !strcmp (op->src[0]->reg->name, op->dst->reg->name)) {\n\t\t\t\tskip_ret = skip_hp (anal, fcn, op, bb, addr, oplen, delay.un_idx, &idx);\n\t\t\t\tif (skip_ret == 1) {\n\t\t\t\t\tgoto repeat;\n\t\t\t\t}\n\t\t\t\tif (skip_ret == 2) {\n\t\t\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_LEA:\n\t\t\tlast_is_reg_mov_lea = false;\n\t\t\t// if first byte in op->ptr is 0xff, then set leaddr assuming its a jumptable\n#if 0\n\t\t\t{\n\t\t\t\tut8 buf[4];\n\t\t\t\tanal->iob.read_at (anal->iob.io, op->ptr, buf, sizeof (buf));\n\t\t\t\tif ((buf[2] == 0xff || buf[2] == 0xfe) && buf[3] == 0xff) {\n\t\t\t\t\tleaddr_pair *pair = R_NEW (leaddr_pair);\n\t\t\t\t\tif (!pair) {\n\t\t\t\t\t\teprintf (\"Cannot create leaddr_pair\\n\");\n\t\t\t\t\t\tgotoBeach (R_ANAL_RET_ERROR);\n\t\t\t\t\t}\n\t\t\t\t\tpair->op_addr = op->addr;\n\t\t\t\t\tpair->leaddr = op->ptr; // XXX movdisp is dupped but seems to be trashed sometimes(?), better track leaddr separately\n\t\t\t\t\tr_list_append (anal->leaddrs, pair);\n\t\t\t\t}\n\t\t\t\tif (has_stack_regs && op_is_set_bp (op, bp_reg, sp_reg)) {\n\t\t\t\t\tfcn->bp_off = fcn->stack - op->src[0]->delta;\n\t\t\t\t}\n\t\t\t\tif (op->dst && op->dst->reg && op->dst->reg->name && op->ptr > 0 && op->ptr != UT64_MAX) {\n\t\t\t\t\tfree (last_reg_mov_lea_name);\n\t\t\t\t\tif ((last_reg_mov_lea_name = strdup (op->dst->reg->name))) {\n\t\t\t\t\t\tlast_reg_mov_lea_val = op->ptr;\n\t\t\t\t\t\tlast_is_reg_mov_lea = true;\n\t\t\t\t\t}\n\t\t\t\t}\n#else\n\t\t\tif (op->ptr != UT64_MAX) {\n\t\t\t\tleaddr_pair *pair = R_NEW (leaddr_pair);\n\t\t\t\tif (!pair) {\n\t\t\t\t\teprintf (\"Cannot create leaddr_pair\\n\");\n\t\t\t\t\tgotoBeach (R_ANAL_RET_ERROR);\n\t\t\t\t}\n\t\t\t\tpair->op_addr = op->addr;\n\t\t\t\tpair->leaddr = op->ptr; // XXX movdisp is dupped but seems to be trashed sometimes(?), better track leaddr separately\n\t\t\t\tpair->reg = op->reg\n\t\t\t\t\t? strdup (op->reg)\n\t\t\t\t\t: op->dst && op->dst->reg\n\t\t\t\t\t? strdup (op->dst->reg->name)\n\t\t\t\t\t: NULL;\n\t\t\t\tlea_cnt++;\n\t\t\t\tr_list_append (anal->leaddrs, pair);\n\t\t\t}\n\t\t\tif (has_stack_regs && op_is_set_bp (op_dst, op_src, bp_reg, sp_reg)     ) {\n\t\t\t\tfcn->bp_off = fcn->stack - op->src[0]->delta;\n\t\t\t}\n\t\t\tif (op->dst && op->dst->reg && op->dst->reg->name && op->ptr > 0 && op->ptr != UT64_MAX) {\n\t\t\t\tfree(last_reg_mov_lea_name);\n\t\t\t\tif ((last_reg_mov_lea_name = strdup(op->dst->reg->name))) {\n\t\t\t\t\tlast_reg_mov_lea_val = op->ptr;\n\t\t\t\t\tlast_is_reg_mov_lea = true;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\t// skip lea reg,[reg]\n\t\t\tif (anal->opt.hpskip && regs_exist (op->src[0], op->dst)\n\t\t\t&& !strcmp (op->src[0]->reg->name, op->dst->reg->name)) {\n\t\t\t\tskip_ret = skip_hp (anal, fcn, op, bb, at, oplen, delay.un_idx, &idx);\n\t\t\t\tif (skip_ret == 1) {\n\t\t\t\t\tgoto repeat;\n\t\t\t\t}\n\t\t\t\tif (skip_ret == 2) {\n\t\t\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (anal->opt.jmptbl) {\n\t\t\t\tRAnalOp *jmp_aop = r_anal_op_new ();\n\t\t\t\tut64 jmptbl_addr = op->ptr;\n\t\t\t\tut64 casetbl_addr = op->ptr;\n\t\t\t\tif (is_delta_pointer_table (anal, fcn, op->addr, op->ptr, &jmptbl_addr, &casetbl_addr, jmp_aop)) {\n\t\t\t\t\tut64 table_size, default_case = 0;\n\t\t\t\t\tst64 case_shift = 0;\n\t\t\t\t\t// we require both checks here since try_get_jmptbl_info uses\n\t\t\t\t\t// BB info of the final jmptbl jump, which is no present with\n\t\t\t\t\t// is_delta_pointer_table just scanning ahead\n\t\t\t\t\t// try_get_delta_jmptbl_info doesn't work at times where the\n\t\t\t\t\t// lea comes after the cmp/default case cjmp, which can be\n\t\t\t\t\t// handled with try_get_jmptbl_info\n\t\t\t\t\tut64 addr = jmp_aop->addr;\n\t\t\t\t\tbool ready = false;\n\t\t\t\t\tif (try_get_jmptbl_info (anal, fcn, addr, bb, &table_size, &default_case, &case_shift)) {\n\t\t\t\t\t\tready = true;\n\t\t\t\t\t} else if (try_get_delta_jmptbl_info (anal, fcn, addr, op->addr, &table_size, &default_case, &case_shift)) {\n\t\t\t\t\t\tready = true;\n\t\t\t\t\t}\n// TODO: -1-\n\t\t\t\t\tif (ready) {\n\t\t\t\t\t\tret = casetbl_addr == op->ptr\n\t\t\t\t\t\t\t? try_walkthrough_jmptbl (anal, fcn, bb, depth, addr, case_shift, jmptbl_addr, op->ptr, 4, table_size, default_case, 4)\n\t\t\t\t\t\t\t: try_walkthrough_casetbl (anal, fcn, bb, depth, addr, case_shift, jmptbl_addr, casetbl_addr, op->ptr, 4, table_size, default_case, 4);\n\t\t\t\t\t\tif (ret) {\n\t\t\t\t\t\t\tlea_jmptbl_ip = addr;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr_anal_op_free (jmp_aop);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_LOAD:\n\t\t\tif (anal->opt.loads) {\n\t\t\t\tif (anal->iob.is_valid_offset (anal->iob.io, op->ptr, 0)) {\n\t\t\t\t\tr_meta_set (anal, R_META_TYPE_DATA, op->ptr, 4, \"\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\t// Case of valid but unused \"add [rax], al\"\n\t\tcase R_ANAL_OP_TYPE_ADD:\n\t\t\tif (anal->opt.ijmp) {\n\t\t\t\tif ((op->size + 4 <= bytes_read) && !memcmp (buf + op->size, \"\\x00\\x00\\x00\\x00\", 4)) {\n\t\t\t\t\tr_anal_block_set_size (bb, bb->size - oplen);\n\t\t\t\t\top->type = R_ANAL_OP_TYPE_RET;\n\t\t\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_ILL:\n\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\tcase R_ANAL_OP_TYPE_TRAP:\n\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\tcase R_ANAL_OP_TYPE_NOP:\n\t\t\t// do nothing, because the nopskip goes before this switch\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\tif (op->jump == UT64_MAX) {\n\t\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t\t}\n\t\t\t{\n\t\t\t\tRFlagItem *fi = anal->flb.get_at (anal->flb.f, op->jump, false);\n\t\t\t\tif (fi && strstr (fi->name, \"imp.\")) {\n\t\t\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t\t}\n\t\t\tif (anal->opt.jmpref) {\n\t\t\t\t(void) r_anal_xrefs_set (anal, op->addr, op->jump, R_ANAL_REF_TYPE_CODE);\n\t\t\t}\n\t\t\tif (!anal->opt.jmpabove && (op->jump < fcn->addr)) {\n\t\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t\t}\n\t\t\tif (r_anal_noreturn_at (anal, op->jump)) {\n\t\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t\t}\n\t\t\t{\n\t\t\t\tbool must_eob = true;\n\t\t\t\tRIOMap *map = anal->iob.map_get_at (anal->iob.io, addr);\n\t\t\t\tif (map) {\n\t\t\t\t\tmust_eob = ( ! r_io_map_contain (map, op->jump) );\n\t\t\t\t}\n\t\t\t\tif (must_eob) {\n\t\t\t\t\top->jump = UT64_MAX;\n\t\t\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t\t\t}\n\t\t\t}\n#if FIX_JMP_FWD\n\t\t\tbb->jump = op->jump;\n\t\t\tbb->fail = UT64_MAX;\n\t\t\tFITFCNSZ ();\n\t\t\tgotoBeach (R_ANAL_RET_END);\n#else\n\t\t\tif (!overlapped) {\n\t\t\t\tbb->jump = op->jump;\n\t\t\t\tbb->fail = UT64_MAX;\n\t\t\t}\n\t\t\t// -1\n\t\t\tret = r_anal_function_bb (anal, fcn, op->jump, depth);\n\t\t\tint tc = anal->opt.tailcall;\n\t\t\tif (tc) {\n\t\t\t\t// eprintf (\"TAIL CALL AT 0x%llx\\n\", op->addr);\n\t\t\t\tint diff = op->jump - op->addr;\n\t\t\t\tif (tc < 0) {\n\t\t\t\t\tut8 buf[32];\n\t\t\t\t\t(void)anal->iob.read_at (anal->iob.io, op->jump, (ut8 *) buf, sizeof (buf));\n\t\t\t\t\tif (r_anal_is_prelude (anal, buf, sizeof (buf))) {\n\t\t\t\t\t\tfcn_recurse (anal, fcn, op->jump, anal->opt.bb_max_size, depth - 1);\n\t\t\t\t\t}\n\t\t\t\t} else if (R_ABS (diff) > tc) {\n\t\t\t\t\t(void) r_anal_xrefs_set (anal, op->addr, op->jump, R_ANAL_REF_TYPE_CALL);\n\t\t\t\t\tfcn_recurse (anal, fcn, op->jump, anal->opt.bb_max_size, depth - 1);\n\t\t\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto beach;\n#endif\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_SUB:\n\t\t\tif (op->val != UT64_MAX && op->val > 0) {\n\t\t\t\t// if register is not stack\n\t\t\t\tcmpval = op->val;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_CMP: {\n\t\t\tut64 val = (is_x86 || is_v850)? op->val : op->ptr;\n\t\t\tif (val) {\n\t\t\t\tcmpval = val;\n\t\t\t\tbb->cmpval = cmpval;\n\t\t\t\tbb->cmpreg = op->reg;\n\t\t\t\tr_anal_cond_free (bb->cond);\n\t\t\t\tbb->cond = r_anal_cond_new_from_op (op);\n\t\t\t}\n\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_CJMP:\n\t\tcase R_ANAL_OP_TYPE_MCJMP:\n\t\tcase R_ANAL_OP_TYPE_RCJMP:\n\t\tcase R_ANAL_OP_TYPE_UCJMP:\n\t\t\tif (anal->opt.cjmpref) {\n\t\t\t\t(void) r_anal_xrefs_set (anal, op->addr, op->jump, R_ANAL_REF_TYPE_CODE);\n\t\t\t}\n\t\t\tif (!overlapped) {\n\t\t\t\tbb->jump = op->jump;\n\t\t\t\tbb->fail = op->fail;\n\t\t\t}\n\t\t\tif (bb->cond) {\n\t\t\t\tbb->cond->type = op->cond;\n\t\t\t}\n\t\t\tif (anal->opt.jmptbl) {\n\t\t\t\tif (op->ptr != UT64_MAX) {\n\t\t\t\t\tut64 table_size, default_case;\n\t\t\t\t\ttable_size = cmpval + 1;\n\t\t\t\t\tdefault_case = op->fail; // is this really default case?\n\t\t\t\t\tif (cmpval != UT64_MAX && default_case != UT64_MAX && (op->reg || op->ireg)) {\n\t\t\t\t\t\t// TODO -1\n\t\t\t\t\t\tif (op->ireg) {\n\t\t\t\t\t\t\tret = try_walkthrough_jmptbl (anal, fcn, bb, depth, op->addr, 0, op->ptr, op->ptr, anal->bits >> 3, table_size, default_case, ret);\n\t\t\t\t\t\t} else { // op->reg\n\t\t\t\t\t\t\tret = walkthrough_arm_jmptbl_style (anal, fcn, bb, depth, op->addr, op->ptr, anal->bits >> 3, table_size, default_case, ret);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// check if op->jump and op->fail contain jump table location\n\t\t\t\t\t\t// clear jump address, because it's jump table location\n\t\t\t\t\t\tif (op->jump == op->ptr) {\n\t\t\t\t\t\t\top->jump = UT64_MAX;\n\t\t\t\t\t\t} else if (op->fail == op->ptr) {\n\t\t\t\t\t\t\top->fail = UT64_MAX;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcmpval = UT64_MAX;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint saved_stack = fcn->stack;\n\t\t\t// TODO: depth -1 in here\n\t\t\tr_anal_function_bb (anal, fcn, op->jump, depth);\n\t\t\tfcn->stack = saved_stack;\n\t\t\tret = r_anal_function_bb (anal, fcn, op->fail, depth);\n\t\t\tfcn->stack = saved_stack;\n\n\t\t\t// XXX breaks mips analysis too !op->delay\n\t\t\t// this will be all x86, arm (at least)\n\t\t\t// without which the analysis is really slow,\n\t\t\t// presumably because each opcode would get revisited\n\t\t\t// (and already covered by a bb) many times\n\t\t\tgoto beach;\n\t\t\t// For some reason, branch delayed code (MIPS) needs to continue\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_UCALL:\n\t\tcase R_ANAL_OP_TYPE_RCALL:\n\t\tcase R_ANAL_OP_TYPE_ICALL:\n\t\tcase R_ANAL_OP_TYPE_IRCALL:\n\t\t\t/* call [dst] */\n\t\t\t// XXX: this is TYPE_MCALL or indirect-call\n\t\t\t(void) r_anal_xrefs_set (anal, op->addr, op->ptr, R_ANAL_REF_TYPE_CALL);\n\n\t\t\tif (r_anal_noreturn_at (anal, op->ptr)) {\n\t\t\t\tRAnalFunction *f = r_anal_get_function_at (anal, op->ptr);\n\t\t\t\tif (f) {\n\t\t\t\t\tf->is_noreturn = true;\n\t\t\t\t}\n\t\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_CCALL:\n\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\t\t/* call dst */\n\t\t\t(void) r_anal_xrefs_set (anal, op->addr, op->jump, R_ANAL_REF_TYPE_CALL);\n\n\t\t\tif (r_anal_noreturn_at (anal, op->jump)) {\n\t\t\t\tRAnalFunction *f = r_anal_get_function_at (anal, op->jump);\n\t\t\t\tif (f) {\n\t\t\t\t\tf->is_noreturn = true;\n\t\t\t\t}\n\t\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_UJMP:\n\t\tcase R_ANAL_OP_TYPE_RJMP:\n\t\t\tif (is_arm && last_is_mov_lr_pc) {\n\t\t\t\tbreak;\n\t\t\t} else if (is_v850 && anal->opt.jmptbl) {\n\t\t\t\tint ptsz = cmpval? cmpval + 1: 4;\n\t\t\t\tif ((int)cmpval > 0) {\n\t\t\t\t\tret = try_walkthrough_jmptbl (anal, fcn, bb, depth, op->addr,\n\t\t\t\t\t\t0, op->addr + 2, op->addr + 2, 2, ptsz, 0, ret);\n\t\t\t\t}\n\t\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* fall through */\n\t\tcase R_ANAL_OP_TYPE_MJMP:\n\t\tcase R_ANAL_OP_TYPE_IJMP:\n\t\tcase R_ANAL_OP_TYPE_IRJMP:\n\t\t\t// if the next instruction is a symbol\n\t\t\tif (anal->opt.ijmp && next_instruction_is_symbol (anal, op)) {\n\t\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t\t}\n\t\t\t// switch statement\n\t\t\tif (anal->opt.jmptbl && lea_jmptbl_ip != op->addr) {\n\t\t\t\tut8 buf[32]; // 32 bytes is enough to hold any instruction.\n\t\t\t\t// op->ireg since rip relative addressing produces way too many false positives otherwise\n\t\t\t\t// op->ireg is 0 for rip relative, \"rax\", etc otherwise\n\t\t\t\tif (op->ptr != UT64_MAX && op->ireg) { // direct jump\n\t\t\t\t\tut64 table_size, default_case;\n\t\t\t\t\tst64 case_shift = 0;\n\t\t\t\t\tif (try_get_jmptbl_info (anal, fcn, op->addr, bb, &table_size, &default_case, &case_shift)) {\n\t\t\t\t\t\tbool case_table = false;\n\t\t\t\t\t\tRAnalOp *prev_op = r_anal_op_new ();\n\t\t\t\t\t\tanal->iob.read_at (anal->iob.io, op->addr - op->size, buf, sizeof (buf));\n\t\t\t\t\t\tif (r_anal_op (anal, prev_op, op->addr - op->size, buf, sizeof (buf), R_ANAL_OP_MASK_VAL) > 0) {\n\t\t\t\t\t\t\tbool prev_op_has_dst_name = prev_op->dst && prev_op->dst->reg && prev_op->dst->reg->name;\n\t\t\t\t\t\t\tbool op_has_src_name = op->src[0] && op->src[0]->reg && op->src[0]->reg->name;\n\t\t\t\t\t\t\tbool same_reg = (op->ireg && prev_op_has_dst_name && !strcmp (op->ireg, prev_op->dst->reg->name))\n\t\t\t\t\t\t\t\t|| (op_has_src_name && prev_op_has_dst_name && !strcmp (op->src[0]->reg->name, prev_op->dst->reg->name));\n\t\t\t\t\t\t\tif (prev_op->type == R_ANAL_OP_TYPE_MOV && prev_op->disp && prev_op->disp != UT64_MAX && same_reg) {\n\t\t\t\t\t\t\t\t//\tmovzx reg, byte [reg + case_table]\n\t\t\t\t\t\t\t\t//\tjmp dword [reg*4 + jump_table]\n\t\t\t\t\t\t\t\tif (try_walkthrough_casetbl (anal, fcn, bb, depth - 1, op->addr, case_shift, op->ptr, prev_op->disp, op->ptr, anal->bits >> 3, table_size, default_case, ret)) {\n\t\t\t\t\t\t\t\t\tret = case_table = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_anal_op_free (prev_op);\n\t\t\t\t\t\tif (!case_table) {\n\t\t\t\t\t\t\tret = try_walkthrough_jmptbl (anal, fcn, bb, depth, op->addr, case_shift, op->ptr, op->ptr, anal->bits >> 3, table_size, default_case, ret);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (op->ptr != UT64_MAX && op->reg) { // direct jump\n\t\t\t\t\tut64 table_size, default_case;\n\t\t\t\t\tst64 case_shift = 0;\n\t\t\t\t\tif (try_get_jmptbl_info (anal, fcn, op->addr, bb, &table_size, &default_case, &case_shift)) {\n\t\t\t\t\t\tret = try_walkthrough_jmptbl (anal, fcn, bb, depth - 1, op->addr, case_shift, op->ptr, op->ptr, anal->bits >> 3, table_size, default_case, ret);\n\t\t\t\t\t}\n\t\t\t\t} else if (movdisp != UT64_MAX) {\n\t\t\t\t\tst64 case_shift = 0;\n\t\t\t\t\tut64 table_size, default_case;\n\t\t\t\t\tut64 jmptbl_base = 0; //UT64_MAX;\n\t\t\t\t\tut64 lea_op_off = UT64_MAX;\n\t\t\t\t\tRListIter *iter;\n\t\t\t\t\tleaddr_pair *pair;\n\t\t\t\t\tif (movbasereg) {\n\t\t\t\t\t\t// find nearest candidate leaddr before op.addr\n\t\t\t\t\t\tr_list_foreach_prev (anal->leaddrs, iter, pair) {\n\t\t\t\t\t\t\tif (pair->op_addr >= op->addr) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ((lea_op_off == UT64_MAX || lea_op_off > op->addr - pair->op_addr) && pair->reg && !strcmp (movbasereg, pair->reg)) {\n\t\t\t\t\t\t\t\tlea_op_off = op->addr - pair->op_addr;\n\t\t\t\t\t\t\t\tjmptbl_base = pair->leaddr;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!try_get_jmptbl_info (anal, fcn, op->addr, bb, &table_size, &default_case, &case_shift)) {\n\t\t\t\t\t\ttable_size = cmpval + 1;\n\t\t\t\t\t\tdefault_case = -1;\n\t\t\t\t\t}\n\t\t\t\t\tret = try_walkthrough_jmptbl (anal, fcn, bb, depth - 1, op->addr, case_shift, jmptbl_base + movdisp, jmptbl_base, movscale, table_size, default_case, ret);\n\t\t\t\t\tcmpval = UT64_MAX;\n#if 0\n\t\t\t\t} else if (movdisp != UT64_MAX) {\n\t\t\t\t\tut64 table_size, default_case;\n\t\t\t\t\tst64 case_shift;\n\t\t\t\t\tif (try_get_jmptbl_info (anal, fcn, op->addr, bb, &table_size, &default_case, &case_shift)) {\n\t\t\t\t\t\top->ptr = movdisp;\n\t\t\t\t\t\tret = try_walkthrough_jmptbl (anal, fcn, bb, depth - 1, op->addr, case_shift, op->ptr, op->ptr, anal->bits >> 3, table_size, default_case, ret);\n\t\t\t\t\t}\n\t\t\t\t\tmovdisp = UT64_MAX;\n#endif\n\t\t\t\t} else if (is_arm) {\n\t\t\t\t\tif (op->ptrsize == 1) { // TBB\n\t\t\t\t\t\tut64 pred_cmpval = try_get_cmpval_from_parents(anal, fcn, bb, op->ireg);\n\t\t\t\t\t\tut64 table_size = 0;\n\t\t\t\t\t\tif (pred_cmpval != UT64_MAX) {\n\t\t\t\t\t\t\ttable_size += pred_cmpval;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttable_size += cmpval;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tret = try_walkthrough_jmptbl (anal, fcn, bb, depth - 1, op->addr, 0, op->addr + op->size,\n\t\t\t\t\t\t\top->addr + 4, 1, table_size, UT64_MAX, ret);\n\t\t\t\t\t\t// skip inlined jumptable\n\t\t\t\t\t\tidx += table_size;\n\t\t\t\t\t}\n\t\t\t\t\tif (op->ptrsize == 2) { // LDRH on thumb/arm\n\t\t\t\t\t\tut64 pred_cmpval = try_get_cmpval_from_parents(anal, fcn, bb, op->ireg);\n\t\t\t\t\t\tint tablesize = 1;\n\t\t\t\t\t\tif (pred_cmpval != UT64_MAX) {\n\t\t\t\t\t\t\ttablesize += pred_cmpval;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttablesize += cmpval;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tret = try_walkthrough_jmptbl (anal, fcn, bb, depth - 1, op->addr, 0, op->addr + op->size,\n\t\t\t\t\t\t\top->addr + 4, 2, tablesize, UT64_MAX, ret);\n\t\t\t\t\t\t// skip inlined jumptable\n\t\t\t\t\t\tidx += (tablesize * 2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lea_jmptbl_ip == op->addr) {\n\t\t\t\tlea_jmptbl_ip = UT64_MAX;\n\t\t\t}\n\t\t\tif (anal->opt.ijmp) {\n\t\t\t\tr_anal_function_bb (anal, fcn, op->jump, depth - 1);\n\t\t\t\tret = r_anal_function_bb (anal, fcn, op->fail, depth - 1);\n\t\t\t\tif (overlapped) {\n\t\t\t\t\tgoto analopfinish;\n\t\t\t\t}\n\t\t\t\tif (r_anal_noreturn_at (anal, op->jump) || op->eob) {\n\t\t\t\t\tgoto analopfinish;\n\t\t\t\t}\n\t\t\t} else {\nanalopfinish:\n\t\t\t\tif (op->type == R_ANAL_OP_TYPE_RJMP) {\n\t\t\t\t\tgotoBeach (R_ANAL_RET_NOP);\n\t\t\t\t} else {\n\t\t\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t/* fallthru */\n\t\tcase R_ANAL_OP_TYPE_PUSH:\n\t\t\tlast_is_push = true;\n\t\t\tlast_push_addr = op->val;\n\t\t\tif (anal->iob.is_valid_offset (anal->iob.io, last_push_addr, 1)) {\n\t\t\t\t(void) r_anal_xrefs_set (anal, op->addr, last_push_addr, R_ANAL_REF_TYPE_DATA);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_UPUSH:\n\t\t\tif ((op->type & R_ANAL_OP_TYPE_REG) && last_is_reg_mov_lea && op->src[0] && op->src[0]->reg\n\t\t\t\t&& op->src[0]->reg->name && !strcmp (op->src[0]->reg->name, last_reg_mov_lea_name)) {\n\t\t\t\tlast_is_push = true;\n\t\t\t\tlast_push_addr = last_reg_mov_lea_val;\n\t\t\t\tif (anal->iob.is_valid_offset (anal->iob.io, last_push_addr, 1)) {\n\t\t\t\t\t(void) r_anal_xrefs_set (anal, op->addr, last_push_addr, R_ANAL_REF_TYPE_DATA);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_RET:\n\t\t\tif (op->family == R_ANAL_OP_FAMILY_PRIV) {\n\t\t\t\tfcn->type = R_ANAL_FCN_TYPE_INT;\n\t\t\t}\n\t\t\tif (last_is_push && anal->opt.pushret) {\n\t\t\t\top->type = R_ANAL_OP_TYPE_JMP;\n\t\t\t\top->jump = last_push_addr;\n\t\t\t\tbb->jump = op->jump;\n\t\t\t\tret = r_anal_function_bb (anal, fcn, op->jump, depth - 1);\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (!op->cond) {\n\t\t\t\tif (anal->verbose) {\n\t\t\t\t\teprintf (\"RET 0x%08\"PFMT64x \". overlap=%s %\"PFMT64u\" %\"PFMT64u\"\\n\",\n\t\t\t\t\t\taddr + delay.un_idx - oplen, r_str_bool (overlapped),\n\t\t\t\t\t\tbb->size, r_anal_function_linear_size (fcn));\n\t\t\t\t}\n\t\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (has_stack_regs && arch_destroys_dst) {\n\t\t\t// op->dst->reg->name is invalid pointer\n\t\t\tif (op_is_set_bp (op_dst, op_src, bp_reg, sp_reg) && op->src[1]) {\n\t\t\t\tswitch (op->type & R_ANAL_OP_TYPE_MASK) {\n\t\t\t\tcase R_ANAL_OP_TYPE_ADD:\n\t\t\t\t\tfcn->bp_off = fcn->stack - op->src[1]->imm;\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_OP_TYPE_SUB:\n\t\t\t\t\tfcn->bp_off = fcn->stack + op->src[1]->imm;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (anal->opt.vars && !varset) {\n\t\t\t// XXX uses op.src/dst and fails because regprofile invalidates the regitems\n\t\t\tr_anal_extract_vars (anal, fcn, op);\n\t\t}\n\t\tif (op->type != R_ANAL_OP_TYPE_MOV && op->type != R_ANAL_OP_TYPE_CMOV && op->type != R_ANAL_OP_TYPE_LEA) {\n\t\t\tlast_is_reg_mov_lea = false;\n\t\t}\n\t\tif (op->type != R_ANAL_OP_TYPE_PUSH && op->type != R_ANAL_OP_TYPE_RPUSH) {\n\t\t\tlast_is_push = false;\n\t\t}\n\t\tif (is_arm && op->type != R_ANAL_OP_TYPE_MOV) {\n\t\t\tlast_is_mov_lr_pc = false;\n\t\t}\n\t\tif (has_variadic_reg && !fcn->is_variadic) {\n\t\t\tvariadic_reg = r_reg_get (anal->reg, \"rax\", R_REG_TYPE_GPR);\n\t\t\tbool dst_is_variadic = op->dst && op->dst->reg\n\t\t\t\t\t&& variadic_reg && op->dst->reg->offset == variadic_reg->offset;\n\t\t\tbool op_is_cmp = (op->type == R_ANAL_OP_TYPE_CMP) || op->type == R_ANAL_OP_TYPE_ACMP;\n\t\t\tif (dst_is_variadic && !op_is_cmp) {\n\t\t\t\thas_variadic_reg = false;\n\t\t\t} else if (op_is_cmp) {\n\t\t\t\tif (op->src[0] && op->src[0]->reg && (op->dst->reg == op->src[0]->reg) && dst_is_variadic) {\n\t\t\t\t\tfcn->is_variadic = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nbeach:\n\tfree (op_src);\n\tfree (op_dst);\n\tfree (bp_reg);\n\tfree (sp_reg);\n\twhile (lea_cnt > 0) {\n\t\tr_list_delete (anal->leaddrs, r_list_tail (anal->leaddrs));\n\t\tlea_cnt--;\n\t}\n\tr_anal_op_free (op);\n\tR_FREE (last_reg_mov_lea_name);\n\tif (bb && bb->size == 0) {\n\t\tr_anal_function_remove_block (fcn, bb);\n\t}\n\tr_anal_block_update_hash (bb);\n\tr_anal_block_unref (bb);\n\tfree (movbasereg);\n\treturn ret;\n}\n\nR_API int r_anal_function_bb(RAnal *anal, RAnalFunction *fcn, ut64 addr, int depth) {\n\tr_return_val_if_fail (anal && fcn, -1);\n\treturn fcn_recurse (anal, fcn, addr, anal->opt.bb_max_size, depth - 1);\n}\n\nR_API bool r_anal_check_fcn(RAnal *anal, ut8 *buf, ut16 bufsz, ut64 addr, ut64 low, ut64 high) {\n\tr_return_val_if_fail (anal && buf, false);\n\tRAnalOp op = {\n\t\t0\n\t};\n\tint i, oplen, opcnt = 0, pushcnt = 0, movcnt = 0, brcnt = 0;\n\tif (r_anal_is_prelude (anal, buf, bufsz)) {\n\t\treturn true;\n\t}\n\tfor (i = 0; i < bufsz && opcnt < 10; i += oplen, opcnt++) {\n\t\tr_anal_op_fini (&op);\n\t\tif ((oplen = r_anal_op (anal, &op, addr + i, buf + i, bufsz - i, R_ANAL_OP_MASK_BASIC | R_ANAL_OP_MASK_HINT)) < 1) {\n\t\t\treturn false;\n\t\t}\n\t\tswitch (op.type) {\n\t\tcase R_ANAL_OP_TYPE_PUSH:\n\t\tcase R_ANAL_OP_TYPE_UPUSH:\n\t\tcase R_ANAL_OP_TYPE_RPUSH:\n\t\t\tpushcnt++;\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_MOV:\n\t\tcase R_ANAL_OP_TYPE_CMOV:\n\t\t\tmovcnt++;\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\tcase R_ANAL_OP_TYPE_CJMP:\n\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\t\tif (op.jump < low || op.jump >= high) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbrcnt++;\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_UNK:\n\t\t\treturn false;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (pushcnt + movcnt + brcnt > 5);\n}\n\nR_API void r_anal_trim_jmprefs(RAnal *anal, RAnalFunction *fcn) {\n\tr_return_if_fail (anal && fcn);\n\tRAnalRef *ref;\n\tRList *refs = r_anal_function_get_refs (fcn);\n\tRListIter *iter;\n\tconst bool is_x86 = anal->cur->arch && !strcmp (anal->cur->arch, \"x86\"); // HACK\n\n\tr_list_foreach (refs, iter, ref) {\n\t\tif (ref->type == R_ANAL_REF_TYPE_CODE && r_anal_function_contains (fcn, ref->addr)\n\t\t    && (!is_x86 || !r_anal_function_contains (fcn, ref->at))) {\n\t\t\tr_anal_xrefs_deln (anal, ref->at, ref->addr, ref->type);\n\t\t}\n\t}\n\tr_list_free (refs);\n}\n\nR_API void r_anal_del_jmprefs(RAnal *anal, RAnalFunction *fcn) {\n\tr_return_if_fail (anal && fcn);\n\tRAnalRef *ref;\n\tRList *refs = r_anal_function_get_refs (fcn);\n\tRListIter *iter;\n\n\tr_list_foreach (refs, iter, ref) {\n\t\tif (ref->type == R_ANAL_REF_TYPE_CODE) {\n\t\t\tr_anal_xrefs_deln (anal, ref->at, ref->addr, ref->type);\n\t\t}\n\t}\n\tr_list_free (refs);\n}\n\n/* Does NOT invalidate read-ahead cache. */\nR_API int r_anal_function(RAnal *anal, RAnalFunction *fcn, ut64 addr, ut64 len, int reftype) {\n\tr_return_val_if_fail (anal && fcn, 0);\n\tRPVector *metas = r_meta_get_all_in (anal, addr, R_META_TYPE_ANY);\n\tif (metas) {\n\t\tvoid **it;\n\t\tr_pvector_foreach (metas, it) {\n\t\t\tRAnalMetaItem *meta = ((RIntervalNode *)*it)->data;\n\t\t\tswitch (meta->type) {\n\t\t\tcase R_META_TYPE_DATA:\n\t\t\tcase R_META_TYPE_STRING:\n\t\t\tcase R_META_TYPE_FORMAT:\n\t\t\t\tr_pvector_free (metas);\n\t\t\t\treturn 0;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tr_pvector_free (metas);\n\t}\n\tif (anal->opt.norevisit) {\n\t\tif (!anal->visited) {\n\t\t\tanal->visited = set_u_new ();\n\t\t}\n\t\tif (set_u_contains (anal->visited, addr)) {\n\t\t\teprintf (\"r_anal_function: anal.norevisit at 0x%08\"PFMT64x\" %c\\n\", addr, reftype);\n\t\t\treturn R_ANAL_RET_END;\n\t\t}\n\t\tset_u_add (anal->visited, addr);\n\t} else {\n\t\tif (anal->visited) {\n\t\t\tset_u_free (anal->visited);\n\t\t\tanal->visited = NULL;\n\t\t}\n\t}\n\t/* defines fcn. or loc. prefix */\n\tfcn->type = (reftype == R_ANAL_REF_TYPE_CODE) ? R_ANAL_FCN_TYPE_LOC : R_ANAL_FCN_TYPE_FCN;\n\tif (fcn->addr == UT64_MAX) {\n\t\tfcn->addr = addr;\n\t}\n\tfcn->maxstack = 0;\n\tif (fcn->cc && !strcmp (fcn->cc, \"ms\")) {\n\t\t// Probably should put this on the cc sdb\n\t\tconst int shadow_store = 0x28; // First 4 args + retaddr\n\t\tfcn->stack = fcn->maxstack = fcn->reg_save_area = shadow_store;\n\t}\n\t// XXX -1 here results in lots of errors\n\tint ret = r_anal_function_bb (anal, fcn, addr, anal->opt.depth);\n\tif (ret < 0) {\n\t\tif (anal->verbose) {\n\t\t\teprintf (\"Failed to analyze basic block at 0x%\"PFMT64x\"\\n\", addr);\n\t\t}\n\t}\n\tif (anal->opt.endsize && ret == R_ANAL_RET_END && r_anal_function_realsize (fcn)) {   // cfg analysis completed\n\t\tRListIter *iter;\n\t\tRAnalBlock *bb;\n\t\tut64 endaddr = fcn->addr;\n\t\tconst bool is_x86 = anal->cur->arch && !strcmp (anal->cur->arch, \"x86\");\n\n\t\t// set function size as length of continuous sequence of bbs\n\t\tr_list_sort (fcn->bbs, &cmpaddr);\n\t\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\t\tif (endaddr == bb->addr) {\n\t\t\t\tendaddr += bb->size;\n\t\t\t} else if ((endaddr < bb->addr && bb->addr - endaddr < BB_ALIGN)\n\t\t\t\t\t|| (anal->opt.jmpmid && is_x86 && endaddr > bb->addr\n\t\t\t\t\t\t&& bb->addr + bb->size > endaddr)) {\n\t\t\t\tendaddr = bb->addr + bb->size;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#if JAYRO_04\n\t\t// fcn is not yet in anal => pass NULL\n\t\tr_anal_function_resize (fcn, endaddr - fcn->addr);\n#endif\n\t\tr_anal_trim_jmprefs (anal, fcn);\n\t}\n\treturn ret;\n}\n\n// XXX deprecate\nR_API int r_anal_function_del_locs(RAnal *anal, ut64 addr) {\n\tRListIter *iter, *iter2;\n\tRAnalFunction *fcn, *f = r_anal_get_fcn_in (anal, addr, R_ANAL_FCN_TYPE_ROOT);\n\tif (!f) {\n\t\treturn false;\n\t}\n\tr_list_foreach_safe (anal->fcns, iter, iter2, fcn) {\n\t\tif (fcn->type != R_ANAL_FCN_TYPE_LOC) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (r_anal_function_contains (fcn, addr)) {\n\t\t\tr_anal_function_delete (fcn);\n\t\t\tbreak;\n\t\t}\n\t}\n\tr_anal_function_del (anal, addr);\n\treturn true;\n}\n\nR_API int r_anal_function_del(RAnal *a, ut64 addr) {\n\tRAnalFunction *fcn = r_anal_get_function_at (a, addr);\n\tif (fcn) {\n\t\tr_anal_function_delete (fcn);\n\t\t// r_anal_function_free (fcn);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nR_API RAnalFunction *r_anal_get_fcn_in(RAnal *anal, ut64 addr, int type) {\n\tRList *list = r_anal_get_functions_in (anal, addr);\n\tRAnalFunction *ret = NULL;\n\tif (list && !r_list_empty (list)) {\n\t\tif (type == R_ANAL_FCN_TYPE_ROOT) {\n\t\t\tRAnalFunction *fcn;\n\t\t\tRListIter *iter;\n\t\t\tr_list_foreach (list, iter, fcn) {\n\t\t\t\tif (fcn->addr == addr) {\n\t\t\t\t\tret = fcn;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tret = r_list_first (list);\n\t\t}\n\t}\n\tr_list_free (list);\n\treturn ret;\n}\n\nR_API RAnalFunction *r_anal_get_fcn_in_bounds(RAnal *anal, ut64 addr, int type) {\n\tRAnalFunction *fcn, *ret = NULL;\n\tRListIter *iter;\n\tif (type == R_ANAL_FCN_TYPE_ROOT) {\n\t\tr_list_foreach (anal->fcns, iter, fcn) {\n\t\t\tif (addr == fcn->addr) {\n\t\t\t\treturn fcn;\n\t\t\t}\n\t\t}\n\t\treturn NULL;\n\t}\n\tr_list_foreach (anal->fcns, iter, fcn) {\n\t\tif (!type || (fcn && fcn->type & type)) {\n\t\t\tif (r_anal_function_contains (fcn, addr)) {\n\t\t\t\treturn fcn;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nR_API RAnalFunction *r_anal_get_function_byname(RAnal *a, const char *name) {\n\tbool found = false;\n\tRAnalFunction *f = ht_pp_find (a->ht_name_fun, name, &found);\n\tif (f && found) {\n\t\treturn f;\n\t}\n\treturn NULL;\n}\n\n/* rename RAnalFunctionBB.add() */\nR_API bool r_anal_function_add_bb(RAnal *a, RAnalFunction *fcn, ut64 addr, ut64 size, ut64 jump, ut64 fail, R_BORROW RAnalDiff *diff) {\n\tD eprintf (\"Add bb\\n\");\n\tif (size == 0) { // empty basic blocks allowed?\n\t\teprintf (\"Warning: empty basic block at 0x%08\"PFMT64x\" is not allowed. pending discussion.\\n\", addr);\n\t\tr_warn_if_reached ();\n\t\treturn false;\n\t}\n\tif (size > a->opt.bb_max_size) {\n\t\teprintf (\"Warning: can't allocate such big bb of %\"PFMT64d\" bytes at 0x%08\"PFMT64x\"\\n\", (st64)size, addr);\n\t\tr_warn_if_reached ();\n\t\treturn false;\n\t}\n\n\tRAnalBlock *block = r_anal_get_block_at (a, addr);\n\tif (block) {\n\t\tr_anal_delete_block (block);\n\t\tblock = NULL;\n\t}\n\n\tconst bool is_x86 = a->cur->arch && !strcmp (a->cur->arch, \"x86\");\n\t// TODO fix this x86-ism\n\tif (is_x86) {\n\t\tr_anal_function_invalidate_read_ahead_cache ();\n\t\tfcn_recurse (a, fcn, addr, size, 1);\n\t\tblock = r_anal_get_block_at (a, addr);\n\t\tif (block) {\n\t\t\tr_anal_block_set_size (block, size);\n\t\t}\n\t} else {\n\t\tblock = r_anal_create_block (a, addr, size);\n\t}\n\n\tif (!block) {\n\t\tD eprintf (\"Warning: r_anal_function_add_bb failed in fcn 0x%08\"PFMT64x\" at 0x%08\"PFMT64x\"\\n\", fcn->addr, addr);\n\t\treturn false;\n\t}\n\n\tr_anal_function_add_block (fcn, block);\n\n\tblock->jump = jump;\n\tblock->fail = fail;\n\tblock->fail = fail;\n\tif (diff) {\n\t\tif (!block->diff) {\n\t\t\tblock->diff = r_anal_diff_new ();\n\t\t}\n\t\tif (block->diff) {\n\t\t\tblock->diff->type = diff->type;\n\t\t\tblock->diff->addr = diff->addr;\n\t\t\tif (diff->name) {\n\t\t\t\tR_FREE (block->diff->name);\n\t\t\t\tblock->diff->name = strdup (diff->name);\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nR_API int r_anal_function_loops(RAnalFunction *fcn) {\n\tRListIter *iter;\n\tRAnalBlock *bb;\n\tut32 loops = 0;\n\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\tif (bb->jump != UT64_MAX && bb->jump < bb->addr) {\n\t\t\tloops ++;\n\t\t}\n\t\tif (bb->fail != UT64_MAX && bb->fail < bb->addr) {\n\t\t\tloops ++;\n\t\t}\n\t}\n\treturn loops;\n}\n\nR_API int r_anal_function_complexity(RAnalFunction *fcn) {\n\t/*\n\t * CC = E - N + 2P\n\t * E = the number of edges of the graph.\n\t * N = the number of nodes of the graph.\n\t * P = the number of connected components (exit nodes).\n\t */\n\tRAnal *anal = fcn->anal;\n\tint E = 0, N = 0, P = 0;\n\tRListIter *iter;\n\tRAnalBlock *bb;\n\n\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\tN++; // nodes\n\t\tif ((!anal || anal->verbose) && bb->jump == UT64_MAX && bb->fail != UT64_MAX) {\n\t\t\teprintf (\"Warning: invalid bb jump/fail pair at 0x%08\"PFMT64x\" (fcn 0x%08\"PFMT64x\"\\n\", bb->addr, fcn->addr);\n\t\t}\n\t\tif (bb->jump == UT64_MAX && bb->fail == UT64_MAX) {\n\t\t\tP++; // exit nodes\n\t\t} else {\n\t\t\tE++; // edges\n\t\t\tif (bb->fail != UT64_MAX) {\n\t\t\t\tE++;\n\t\t\t}\n\t\t}\n\t\tif (bb->switch_op && bb->switch_op->cases) {\n\t\t\tE += r_list_length (bb->switch_op->cases);\n\t\t}\n\t}\n\n\tint result = E - N + (2 * P);\n\tif (result < 1 && (!anal || anal->verbose)) {\n\t\teprintf (\"Warning: CC = E(%d) - N(%d) + (2 * P(%d)) < 1 at 0x%08\"PFMT64x\"\\n\", E, N, P, fcn->addr);\n\t}\n\t// r_return_val_if_fail (result > 0, 0);\n\treturn result;\n}\n\n// tfj and afsj call this function\nR_API char *r_anal_function_get_json(RAnalFunction *function) {\n\tRAnal *a = function->anal;\n\tPJ *pj = a->coreb.pjWithEncoding (a->coreb.core);\n\tconst char *realname = NULL, *import_substring = NULL;\n\n\tRFlagItem *flag = a->flag_get (a->flb.f, function->addr);\n\t// Can't access R_FLAGS_FS_IMPORTS, since it is defined in r_core.h\n\tif (flag && flag->space && !strcmp (flag->space->name, \"imports\")) {\n\t\t// Get substring after last dot\n\t\timport_substring = r_str_rchr (function->name, NULL, '.');\n\t\tif (import_substring) {\n\t\t\trealname = import_substring + 1;\n\t\t}\n\t} else {\n\t\trealname = function->name;\n\t}\n\t\n\tchar *args = strdup (\"\");\n\tchar *sdb_ret = r_str_newf (\"func.%s.ret\", realname);\n\tchar *sdb_args = r_str_newf (\"func.%s.args\", realname);\n\t// RList *args_list = r_list_newf ((RListFree) free);\n\tunsigned int i;\n\tconst char *ret_type = sdb_const_get (a->sdb_types, sdb_ret, 0);\n\tconst char *argc_str = sdb_const_get (a->sdb_types, sdb_args, 0);\n\n\tint argc = argc_str? atoi (argc_str): 0;\n\n\tpj_o (pj);\n\tpj_ks (pj, \"name\", function->name);\n\tconst bool no_return = r_anal_noreturn_at_addr (a, function->addr);\n\tpj_kb (pj, \"noreturn\", no_return);\n\tpj_ks (pj, \"ret\", r_str_get_fail (ret_type, \"void\"));\n\tif (function->cc) {\n\t\tpj_ks (pj, \"cc\", function->cc);\n\t}\n\tpj_kn (pj, \"argc\", argc);\n\tpj_k (pj, \"args\");\n\tpj_a (pj);\n\tfor (i = 0; i < argc; i++) {\n\t\tchar *sdb_arg_i = r_str_newf (\"func.%s.arg.%d\", realname, i);\n\t\tchar *arg_i = sdb_get (a->sdb_types, sdb_arg_i, 0);\n\t\tif (!arg_i) {\n\t\t\tcontinue;\n\t\t}\n\t\tpj_o (pj);\n\t\tchar *comma = strchr (arg_i, ',');\n\t\tif (comma) {\n\t\t\t*comma = 0;\n\t\t\tpj_ks (pj, \"name\", comma + 1);\n\t\t\tpj_ks (pj, \"type\", arg_i);\n\t\t\tr_strf_var (regname, 32, \"A%d\", i);\n\t\t\tconst char *cc_arg = r_reg_get_name (a->reg, r_reg_get_name_idx (regname));\n\t\t\tif (cc_arg) {\n\t\t\t\tpj_ks (pj, \"cc\", cc_arg);\n\t\t\t}\n\t\t}\n\t\tfree (arg_i);\n\t\tfree (sdb_arg_i);\n\t\tpj_end (pj);\n\t}\n\tpj_end (pj);\n\tfree (sdb_args);\n\tfree (sdb_ret);\n\tfree (args);\n\tpj_end (pj);\n\treturn pj_drain (pj);\n}\n\nR_API char *r_anal_function_get_signature(RAnalFunction *function) {\n\tRAnal *a = function->anal;\n\tconst char *realname = NULL, *import_substring = NULL;\n\n\tRFlagItem *flag = a->flag_get (a->flb.f, function->addr);\n\t// Can't access R_FLAGS_FS_IMPORTS, since it is defined in r_core.h\n\tif (flag && flag->space && !strcmp (flag->space->name, \"imports\")) {\n\t\t// Get substring after last dot\n\t\timport_substring = r_str_rchr (function->name, NULL, '.');\n\t\tif (import_substring) {\n\t\t\trealname = import_substring + 1;\n\t\t}\n\t} else {\n\t\trealname = function->name;\n\t}\n\n\tchar *ret = NULL, *args = strdup (\"\");\n\tchar *sdb_ret = r_str_newf (\"func.%s.ret\", realname);\n\tchar *sdb_args = r_str_newf (\"func.%s.args\", realname);\n\t// RList *args_list = r_list_newf ((RListFree) free);\n\tunsigned int i, j;\n\tconst char *ret_type = sdb_const_get (a->sdb_types, sdb_ret, 0);\n\tconst char *argc_str = sdb_const_get (a->sdb_types, sdb_args, 0);\n\n\tint argc = argc_str? atoi (argc_str): 0;\n\n\tfor (i = 0; i < argc; i++) {\n\t\tchar *sdb_arg_i = r_str_newf (\"func.%s.arg.%d\", realname, i);\n\t\tchar *arg_i = sdb_get (a->sdb_types, sdb_arg_i, 0);\n\t\tif (!arg_i) {\n\t\t\tfree (sdb_arg_i);\n\t\t\tbreak;\n\t\t}\n\t\t// parse commas\n\t\tint arg_i_len = strlen (arg_i);\n\t\tfor (j = 0; j < arg_i_len; j++) {\n\t\t\tif (j > 0 && arg_i[j] == ',') {\n\t\t\t\tif (arg_i[j - 1] == '*') {\n\t\t\t\t\t// remove whitespace\n\t\t\t\t\tmemmove (arg_i + j, arg_i + j + 1, strlen (arg_i) - j);\n\t\t\t\t} else {\n\t\t\t\t\targ_i[j] = ' ';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tchar *new_args = (i + 1 == argc)\n\t\t\t? r_str_newf (\"%s%s\", args, arg_i)\n\t\t\t: r_str_newf (\"%s%s, \", args, arg_i);\n\t\tfree (args);\n\t\targs = new_args;\n\t\tfree (arg_i);\n\t\tfree (sdb_arg_i);\n\t}\n\n\tchar *sane = r_name_filter2 (realname);\n\tif (sane) {\n\t\tr_str_replace_ch (sane, ':', '_', true);\n\t\trealname = sane;\n\t}\n\tret = r_str_newf (\"%s %s (%s);\", r_str_get_fail (ret_type, \"void\"), realname, args);\n\tfree (sane);\n\n\tfree (sdb_args);\n\tfree (sdb_ret);\n\tfree (args);\n\treturn ret;\n}\n\n/* set function signature from string */\nR_API int r_anal_str_to_fcn(RAnal *a, RAnalFunction *f, const char *sig) {\n\tr_return_val_if_fail (a || f || sig, false);\n\tchar *error_msg = NULL;\n\tconst char *out = r_parse_c_string (a, sig, &error_msg);\n\tif (out) {\n\t\tr_anal_save_parsed_type (a, out);\n\t}\n\tif (error_msg) {\n\t\teprintf (\"%s\", error_msg);\n\t\tfree (error_msg);\n\t}\n\n\treturn true;\n}\n\nR_API RAnalFunction *r_anal_function_next(RAnal *anal, ut64 addr) {\n\tRAnalFunction *fcni;\n\tRListIter *iter;\n\tRAnalFunction *closer = NULL;\n\tr_list_foreach (anal->fcns, iter, fcni) {\n\t\t// if (fcni->addr == addr)\n\t\tif (fcni->addr > addr && (!closer || fcni->addr < closer->addr)) {\n\t\t\tcloser = fcni;\n\t\t}\n\t}\n\treturn closer;\n}\n\nR_API int r_anal_function_count(RAnal *anal, ut64 from, ut64 to) {\n\tint n = 0;\n\tRAnalFunction *fcni;\n\tRListIter *iter;\n\tr_list_foreach (anal->fcns, iter, fcni) {\n\t\tif (fcni->addr >= from && fcni->addr < to) {\n\t\t\tn++;\n\t\t}\n\t}\n\treturn n;\n}\n\n/* return the basic block in fcn found at the given address.\n * NULL is returned if such basic block doesn't exist. */\nR_API RAnalBlock *r_anal_function_bbget_in(const RAnal *anal, RAnalFunction *fcn, ut64 addr) {\n\tr_return_val_if_fail (anal && fcn, NULL);\n\tif (addr == UT64_MAX) {\n\t\treturn NULL;\n\t}\n\tconst bool is_x86 = anal->cur->arch && !strcmp (anal->cur->arch, \"x86\");\n\tRListIter *iter;\n\tRAnalBlock *bb;\n\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\tif (addr >= bb->addr && addr < (bb->addr + bb->size)\n\t\t\t&& (!anal->opt.jmpmid || !is_x86 || r_anal_block_op_starts_at (bb, addr))) {\n\t\t\treturn bb;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API RAnalBlock *r_anal_function_bbget_at(RAnal *anal, RAnalFunction *fcn, ut64 addr) {\n\tr_return_val_if_fail (fcn && addr != UT64_MAX, NULL);\n\tRAnalBlock *b = r_anal_get_block_at (anal, addr);\n\tif (b) {\n\t\treturn b;\n\t}\n\tRListIter *iter;\n\tRAnalBlock *bb;\n\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\tif (addr == bb->addr) {\n\t\t\treturn bb;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n// compute the cyclomatic cost\nR_API ut32 r_anal_function_cost(RAnalFunction *fcn) {\n\tRListIter *iter;\n\tRAnalBlock *bb;\n\tut32 totalCycles = 0;\n\tif (!fcn) {\n\t\treturn 0;\n\t}\n\tRAnal *anal = fcn->anal;\n\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\tRAnalOp op;\n\t\tut64 at, end = bb->addr + bb->size;\n\t\tut8 *buf = malloc (bb->size);\n\t\tif (!buf) {\n\t\t\tcontinue;\n\t\t}\n\t\t(void)anal->iob.read_at (anal->iob.io, bb->addr, (ut8 *) buf, bb->size);\n\t\tint idx = 0;\n\t\tfor (at = bb->addr; at < end;) {\n\t\t\tmemset (&op, 0, sizeof (op));\n\t\t\t(void) r_anal_op (anal, &op, at, buf + idx, bb->size - idx, R_ANAL_OP_MASK_BASIC);\n\t\t\tif (op.size < 1) {\n\t\t\t\top.size = 1;\n\t\t\t}\n\t\t\tidx += op.size;\n\t\t\tat += op.size;\n\t\t\ttotalCycles += op.cycles;\n\t\t\tr_anal_op_fini (&op);\n\t\t}\n\t\tfree (buf);\n\t}\n\treturn totalCycles;\n}\n\nR_API int r_anal_function_count_edges(const RAnalFunction *fcn, R_NULLABLE int *ebbs) {\n\tr_return_val_if_fail (fcn, 0);\n\tRListIter *iter;\n\tRAnalBlock *bb;\n\tint edges = 0;\n\tif (ebbs) {\n\t\t*ebbs = 0;\n\t}\n\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\tif (ebbs && bb->jump == UT64_MAX && bb->fail == UT64_MAX) {\n\t\t\t*ebbs = *ebbs + 1;\n\t\t} else {\n\t\t\tif (bb->jump != UT64_MAX) {\n\t\t\t\tedges ++;\n\t\t\t}\n\t\t\tif (bb->fail != UT64_MAX) {\n\t\t\t\tedges ++;\n\t\t\t}\n\t\t}\n\t}\n\treturn edges;\n}\n\n\nR_API bool r_anal_function_purity(RAnalFunction *fcn) {\n\tif (fcn->has_changed) {\n\t\tHtUP *ht = ht_up_new (NULL, NULL, NULL);\n\t\tif (ht) {\n\t\t\tcheck_purity (ht, fcn);\n\t\t\tht_up_free (ht);\n\t\t}\n\t}\n\treturn fcn->is_pure;\n}\n\nstatic bool can_affect_bp(RAnal *anal, RAnalOp* op) {\n\tRAnalValue *dst = op->dst;\n\tRAnalValue *src = op->src[0];\n\tconst char *opdreg = (dst && dst->reg) ? dst->reg->name : NULL;\n\tconst char *opsreg = (src && src->reg) ? src->reg->name : NULL;\n\tconst char *bp_name = anal->reg->name[R_REG_NAME_BP];\n\tbool is_bp_dst = opdreg && !dst->memref && !strcmp (opdreg, bp_name);\n\tbool is_bp_src = opsreg && !src->memref && !strcmp (opsreg, bp_name);\n\tif (op->type == R_ANAL_OP_TYPE_XCHG) {\n\t\treturn is_bp_src || is_bp_dst;\n\t}\n\treturn is_bp_dst;\n}\n\n/*\n * This function checks whether any operation in a given function may change bp (excluding \"mov bp, sp\"\n * and \"pop bp\" at the end).\n */\nstatic void __anal_fcn_check_bp_use(RAnal *anal, RAnalFunction *fcn) {\n\tRListIter *iter;\n\tRAnalBlock *bb;\n\tchar *pos;\n\tchar str_to_find[40];\n\tsnprintf (str_to_find, sizeof (str_to_find),\n\t\t\"\\\"type\\\":\\\"reg\\\",\\\"value\\\":\\\"%s\", anal->reg->name[R_REG_NAME_BP]);\n\tif (!fcn) {\n\t\treturn;\n\t}\n\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\tRAnalOp op;\n\t\tut64 at, end = bb->addr + bb->size;\n\t\tut8 *buf = malloc (bb->size);\n\t\tif (!buf) {\n\t\t\tcontinue;\n\t\t}\n\t\t(void)anal->iob.read_at (anal->iob.io, bb->addr, (ut8 *) buf, bb->size);\n\t\tint idx = 0;\n\t\tfor (at = bb->addr; at < end;) {\n\t\t\tr_anal_op (anal, &op, at, buf + idx, bb->size - idx, R_ANAL_OP_MASK_VAL | R_ANAL_OP_MASK_OPEX);\n\t\t\tif (op.size < 1) {\n\t\t\t\top.size = 1;\n\t\t\t}\n\t\t\tswitch (op.type) {\n\t\t\tcase R_ANAL_OP_TYPE_MOV:\n\t\t\tcase R_ANAL_OP_TYPE_LEA:\n\t\t\t\tif (can_affect_bp (anal, &op) && op.src[0] && op.src[0]->reg && op.src[0]->reg->name\n\t\t\t\t&& strcmp (op.src[0]->reg->name, anal->reg->name[R_REG_NAME_SP])) {\n\t\t\t\t\tfcn->bp_frame = false;\n\t\t\t\t\tr_anal_op_fini (&op);\n\t\t\t\t\tfree (buf);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_OP_TYPE_ADD:\n\t\t\tcase R_ANAL_OP_TYPE_AND:\n\t\t\tcase R_ANAL_OP_TYPE_CMOV:\n\t\t\tcase R_ANAL_OP_TYPE_NOT:\n\t\t\tcase R_ANAL_OP_TYPE_OR:\n\t\t\tcase R_ANAL_OP_TYPE_ROL:\n\t\t\tcase R_ANAL_OP_TYPE_ROR:\n\t\t\tcase R_ANAL_OP_TYPE_SAL:\n\t\t\tcase R_ANAL_OP_TYPE_SAR:\n\t\t\tcase R_ANAL_OP_TYPE_SHR:\n\t\t\tcase R_ANAL_OP_TYPE_SUB:\n\t\t\tcase R_ANAL_OP_TYPE_XOR:\n\t\t\tcase R_ANAL_OP_TYPE_SHL:\n// op.dst is not filled for these operations, so for now, check for bp as dst looks like this; in the future it may be just replaced with call to can_affect_bp\n \t\t\t\tpos = op.opex.ptr ? strstr (op.opex.ptr, str_to_find) : NULL;\n\t\t\t\tif (pos && pos - op.opex.ptr < 60) {\n\t\t\t\t\tfcn->bp_frame = false;\n\t\t\t\t\tr_anal_op_fini (&op);\n\t\t\t\t\tfree (buf);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_OP_TYPE_XCHG:\n\t\t\t\tif (op.opex.ptr && strstr (op.opex.ptr, str_to_find)) {\n\t\t\t\t\tfcn->bp_frame = false;\n\t\t\t\t\tr_anal_op_fini (&op);\n\t\t\t\t\tfree (buf);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_OP_TYPE_POP:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tidx += op.size;\n\t\t\tat += op.size;\n\t\t\tr_anal_op_fini (&op);\n\t\t}\n\t\tfree (buf);\n\t}\n}\n\nR_API void r_anal_function_check_bp_use(RAnalFunction *fcn) {\n\tr_return_if_fail (fcn);\n\t__anal_fcn_check_bp_use (fcn->anal, fcn);\n}\n\ntypedef struct {\n\tRAnalFunction *fcn;\n\tHtUP *visited;\n} BlockRecurseCtx;\n\nstatic bool mark_as_visited(RAnalBlock *bb, void *user) {\n\tBlockRecurseCtx *ctx = user;\n\tht_up_insert (ctx->visited, bb->addr, NULL);\n\treturn true;\n}\n\nstatic bool analize_addr_cb(ut64 addr, void *user) {\n\tBlockRecurseCtx *ctx = user;\n\tRAnal *anal = ctx->fcn->anal;\n\tRAnalBlock *existing_bb = r_anal_get_block_at (anal, addr);\n\tif (!existing_bb || !r_list_contains (ctx->fcn->bbs, existing_bb)) {\n\t\tint old_len = r_list_length (ctx->fcn->bbs);\n\t\tr_anal_function_bb (ctx->fcn->anal, ctx->fcn, addr, anal->opt.depth);\n\t\tif (old_len != r_list_length (ctx->fcn->bbs)) {\n\t\t\tr_anal_block_recurse (r_anal_get_block_at (anal, addr), mark_as_visited, user);\n\t\t}\n\t}\n\tht_up_insert (ctx->visited, addr, NULL);\n\treturn true;\n}\n\nstatic bool analize_descendents(RAnalBlock *bb, void *user) {\n\treturn r_anal_block_successor_addrs_foreach (bb, analize_addr_cb, user);\n}\n\nstatic void free_ht_up(HtUPKv *kv) {\n\tht_up_free ((HtUP *)kv->value);\n}\n\nstatic void update_var_analysis(RAnalFunction *fcn, int align, ut64 from, ut64 to) {\n\tRAnal *anal = fcn->anal;\n\tut64 cur_addr;\n\tint opsz;\n\tfrom = align ? from - (from % align) : from;\n\tto = align ? R_ROUND (to, align) : to;\n\tif (UT64_SUB_OVFCHK (to, from)) {\n\t\treturn;\n\t}\n\tut64 len = to - from;\n\tut8 *buf = malloc (len);\n\tif (!buf) {\n\t\treturn;\n\t}\n\tif (anal->iob.read_at (anal->iob.io, from, buf, len) < len) {\n\t\treturn;\n\t}\n\tfor (cur_addr = from; cur_addr < to; cur_addr += opsz, len -= opsz) {\n\t\tRAnalOp op;\n\t\tint ret = r_anal_op (anal->coreb.core, &op, cur_addr, buf, len, R_ANAL_OP_MASK_ESIL | R_ANAL_OP_MASK_VAL);\n\t\tif (ret < 1 || op.size < 1) {\n\t\t\tr_anal_op_fini (&op);\n\t\t\tbreak;\n\t\t}\n\t\topsz = op.size;\n\t\tr_anal_extract_vars (anal, fcn, &op);\n\t\tr_anal_op_fini (&op);\n\t}\n\tfree (buf);\n}\n\n// Clear function variable acesses inside in a block\nstatic void clear_bb_vars(RAnalFunction *fcn, RAnalBlock *bb, ut64 from, ut64 to) {\n\tint i;\n\tif (r_pvector_empty (&fcn->vars)) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < bb->ninstr; i++) {\n\t\tconst ut64 addr = r_anal_bb_opaddr_i (bb, i);\n\t\tif (addr < from) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (addr >= to || addr == UT64_MAX) {\n\t\t\tbreak;\n\t\t}\n\t\tRPVector *vars = r_anal_function_get_vars_used_at (fcn, addr);\n\t\tif (vars) {\n\t\t\tRPVector *vars_clone = (RPVector *)r_vector_clone ((RVector *)vars);\n\t\t\tvoid **v;\n\t\t\tr_pvector_foreach (vars_clone, v) {\n\t\t\t\tr_anal_var_remove_access_at ((RAnalVar *)*v, addr);\n\t\t\t}\n\t\t\tr_pvector_clear (vars_clone);\n\t\t}\n\t}\n}\n\nstatic void update_analysis(RAnal *anal, RList *fcns, HtUP *reachable) {\n\t// huge slowdown\n\tRListIter *it, *it2, *tmp;\n\tRAnalFunction *fcn;\n\tbool old_jmpmid = anal->opt.jmpmid;\n\tanal->opt.jmpmid = true;\n\tr_anal_function_invalidate_read_ahead_cache ();\n\tr_list_foreach (fcns, it, fcn) {\n\t\t// Recurse through blocks of function, mark reachable,\n\t\t// analyze edges that don't have a block\n\t\tRAnalBlock *bb = r_anal_get_block_at (anal, fcn->addr);\n\t\tif (!bb) {\n\t\t\tr_anal_function_bb (anal, fcn, fcn->addr, anal->opt.depth);\n\t\t\tbb = r_anal_get_block_at (anal, fcn->addr);\n\t\t\tif (!bb) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tHtUP *ht = ht_up_new0 ();\n\t\tht_up_insert (ht, bb->addr, NULL);\n\t\tBlockRecurseCtx ctx = { fcn, ht };\n\t\tr_anal_block_recurse (bb, analize_descendents, &ctx);\n\n\t\t// Remove non-reachable blocks\n\t\tr_list_foreach_safe (fcn->bbs, it2, tmp, bb) {\n\t\t\tif (ht_up_find_kv (ht, bb->addr, NULL)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tHtUP *o_visited = ht_up_find (reachable, fcn->addr, NULL);\n\t\t\tif (!ht_up_find_kv (o_visited, bb->addr, NULL)) {\n\t\t\t\t// Avoid removing blocks that were already not reachable\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfcn->ninstr -= bb->ninstr;\n\t\t\tr_anal_function_remove_block (fcn, bb);\n\t\t}\n\t\t\n\t\tRList *bbs = r_list_clone (fcn->bbs);\n\t\tr_anal_block_automerge (bbs);\n\t\tr_anal_function_delete_unused_vars (fcn);\n\t\tr_list_free (bbs);\n\t}\n\tanal->opt.jmpmid = old_jmpmid;\n}\n\nstatic void calc_reachable_and_remove_block(RList *fcns, RAnalFunction *fcn, RAnalBlock *bb, HtUP *reachable) {\n\tclear_bb_vars (fcn, bb, bb->addr, bb->addr + bb->size);\n\tif (!r_list_contains (fcns, fcn)) {\n\t\tr_list_append (fcns, fcn);\n\t\t\n\t\t// Calculate reachable blocks from the start of function\n\t\tHtUP *ht = ht_up_new0 ();\n\t\tBlockRecurseCtx ctx = { fcn, ht };\n\t\tr_anal_block_recurse (r_anal_get_block_at (fcn->anal, fcn->addr), mark_as_visited, &ctx);\n\t\tht_up_insert (reachable, fcn->addr, ht);\n\t}\n\tfcn->ninstr -= bb->ninstr;\n\tr_anal_function_remove_block (fcn, bb);\n}\n\nR_API void r_anal_update_analysis_range(RAnal *anal, ut64 addr, int size) {\n\tr_return_if_fail (anal);\n\tRListIter *it, *it2, *tmp;\n\tRAnalBlock *bb;\n\tRAnalFunction *fcn;\n\tRList *blocks = r_anal_get_blocks_intersect (anal, addr, size);\n\tif (r_list_empty (blocks)) {\n\t\tr_list_free (blocks);\n\t\treturn;\n\t}\n\tRList *fcns = r_list_new ();\n\tHtUP *reachable = ht_up_new (NULL, free_ht_up, NULL);\n\tconst int align = r_anal_archinfo (anal, R_ANAL_ARCHINFO_ALIGN);\n\tconst ut64 end_write = addr + size;\n\t\n\tr_list_foreach (blocks, it, bb) {\n\t\tif (!r_anal_block_was_modified (bb)) {\n\t\t\tcontinue;\n\t\t}\n\t\tr_list_foreach_safe (bb->fcns, it2, tmp, fcn) {\t\t\t\n\t\t\tif (align > 1) {\n\t\t\t\tif ((end_write < r_anal_bb_opaddr_i (bb, bb->ninstr - 1))\n\t\t\t\t\t&& (!bb->switch_op || end_write < bb->switch_op->addr)) {\n\t\t\t\t\t// Special case when instructions are aligned and we don't\n\t\t\t\t\t// need to worry about a write messing with the jump instructions\n\t\t\t\t\tclear_bb_vars (fcn, bb, addr > bb->addr ? addr : bb->addr, end_write);\n\t\t\t\t\tupdate_var_analysis (fcn, align, addr > bb->addr ? addr : bb->addr, end_write);\n\t\t\t\t\tr_anal_function_delete_unused_vars (fcn);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcalc_reachable_and_remove_block (fcns, fcn, bb, reachable);\n\t\t}\n\t}\n\tr_list_free (blocks); // This will call r_anal_block_unref to actually remove blocks from RAnal\n\tupdate_analysis (anal, fcns, reachable);\n\tht_up_free (reachable);\n\tr_list_free (fcns);\n}\n\nR_API void r_anal_function_update_analysis(RAnalFunction *fcn) {\n\tr_return_if_fail (fcn);\n\tRListIter *it, *it2, *tmp, *tmp2;\n\tRAnalBlock *bb;\n\tRAnalFunction *f;\n\tRList *fcns = r_list_new ();\n\tHtUP *reachable = ht_up_new (NULL, free_ht_up, NULL);\n\tr_list_foreach_safe (fcn->bbs, it, tmp, bb) {\n\t\tif (r_anal_block_was_modified (bb)) {\n\t\t\tr_list_foreach_safe (bb->fcns, it2, tmp2, f) {\n\t\t\t\tcalc_reachable_and_remove_block (fcns, f, bb, reachable);\n\t\t\t}\n\t\t}\n\t}\n\tupdate_analysis (fcn->anal, fcns, reachable);\n\tht_up_free (reachable);\n\tr_list_free (fcns);\n}\n", "/* radare - LGPL - Copyright 2010-2020 - pancake, oddcoder */\n\n#include <r_anal.h>\n#include <r_util.h>\n#include <r_cons.h>\n#include <r_core.h>\n#include <r_list.h>\n\n#define ACCESS_CMP(x, y) ((st64)((ut64)(x) - ((RAnalVarAccess *)y)->offset))\n\nR_API bool r_anal_var_display(RAnal *anal, RAnalVar *var) {\n\tchar *fmt = r_type_format (anal->sdb_types, var->type);\n\tRRegItem *i;\n\tif (!fmt) {\n\t\teprintf (\"type:%s doesn't exist\\n\", var->type);\n\t\treturn false;\n\t}\n\tbool usePxr = !strcmp (var->type, \"int\"); // hacky but useful\n\tswitch (var->kind) {\n\tcase R_ANAL_VAR_KIND_REG:\n\t\ti = r_reg_index_get (anal->reg, var->delta);\n\t\tif (i) {\n\t\t\tif (usePxr) {\n\t\t\t\tanal->cb_printf (\"pxr $w @r:%s\\n\", i->name);\n\t\t\t} else {\n\t\t\t\tanal->cb_printf (\"pf r (%s)\\n\", i->name);\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"register not found\\n\");\n\t\t}\n\t\tbreak;\n\tcase R_ANAL_VAR_KIND_BPV: {\n\t\tconst st32 real_delta = var->delta + var->fcn->bp_off;\n\t\tconst ut32 udelta = R_ABS (real_delta);\n\t\tconst char sign = real_delta >= 0 ? '+' : '-';\n\t\tif (usePxr) {\n\t\t\tanal->cb_printf (\"pxr $w @%s%c0x%x\\n\", anal->reg->name[R_REG_NAME_BP], sign, udelta);\n\t\t} else {\n\t\t\tanal->cb_printf (\"pf %s @%s%c0x%x\\n\", fmt, anal->reg->name[R_REG_NAME_BP], sign, udelta);\n\t\t}\n\t}\n\t\tbreak;\n\tcase R_ANAL_VAR_KIND_SPV: {\n\t\tut32 udelta = R_ABS (var->delta + var->fcn->maxstack);\n\t\tif (usePxr) {\n\t\t\tanal->cb_printf (\"pxr $w @%s+0x%x\\n\", anal->reg->name[R_REG_NAME_SP], udelta);\n\t\t} else {\n\t\t\tanal->cb_printf (\"pf %s @ %s+0x%x\\n\", fmt, anal->reg->name[R_REG_NAME_SP], udelta);\n\t\t}\n\t\tbreak;\n\t}\n\t}\n\tfree (fmt);\n\treturn true;\n}\n\nstatic const char *__int_type_from_size(int size) {\n\tswitch (size) {\n\tcase 1: return \"int8_t\";\n\tcase 2: return \"int16_t\";\n\tcase 4: return \"int32_t\";\n\tcase 8: return \"int64_t\";\n\tdefault: return NULL;\n\t}\n}\n\nR_API bool r_anal_function_rebase_vars(RAnal *a, RAnalFunction *fcn) {\n\tr_return_val_if_fail (a && fcn, false);\n\tRListIter *it;\n\tRAnalVar *var;\n\tRList *var_list = r_anal_var_all_list (a, fcn);\n\tr_return_val_if_fail (var_list, false);\n\n\tr_list_foreach (var_list, it, var) {\n\t\t// Resync delta in case the registers list changed\n\t\tif (var->isarg && var->kind == 'r') {\n\t\t\tRRegItem *reg = r_reg_get (a->reg, var->regname, -1);\n\t\t\tif (reg) {\n\t\t\t\tif (var->delta != reg->index) {\n\t\t\t\t\tvar->delta = reg->index;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tr_list_free (var_list);\n\treturn true;\n}\n\n// If the type of var is a struct,\n// remove all other vars that are overlapped by var and are at the offset of one of its struct members\nstatic void shadow_var_struct_members(RAnalVar *var) {\n\tSdb *TDB = var->fcn->anal->sdb_types;\n\tconst char *type_kind = sdb_const_get (TDB, var->type, 0);\n\tif (type_kind && r_str_startswith (type_kind, \"struct\")) {\n\t\tchar *field;\n\t\tint field_n;\n\t\tchar *type_key = r_str_newf (\"%s.%s\", type_kind, var->type);\n\t\tfor (field_n = 0; (field = sdb_array_get (TDB, type_key, field_n, NULL)); field_n++) {\n\t\t\tchar field_key[0x300];\n\t\t\tif (snprintf (field_key, sizeof (field_key), \"%s.%s\", type_key, field) < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tchar *field_type = sdb_array_get (TDB, field_key, 0, NULL);\n\t\t\tut64 field_offset = sdb_array_get_num (TDB, field_key, 1, NULL);\n\t\t\tif (field_offset != 0) { // delete variables which are overlaid by structure\n\t\t\t\tRAnalVar *other = r_anal_function_get_var (var->fcn, var->kind, var->delta + field_offset);\n\t\t\t\tif (other && other != var) {\n\t\t\t\t\tr_anal_var_delete (other);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree (field_type);\n\t\t\tfree (field);\n\t\t}\n\t\tfree (type_key);\n\t}\n}\n\nstatic bool inline valid_var_kind(char kind) {\n\tswitch (kind) {\n\tcase R_ANAL_VAR_KIND_BPV: // base pointer var/args\n\tcase R_ANAL_VAR_KIND_SPV: // stack pointer var/args\n\tcase R_ANAL_VAR_KIND_REG: // registers args\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nR_API RAnalVar *r_anal_function_set_var(RAnalFunction *fcn, int delta, char kind, R_NULLABLE const char *type, int size, bool isarg, R_NONNULL const char *name) {\n\tr_return_val_if_fail (fcn && name, NULL);\n\tRAnalVar *existing = r_anal_function_get_var_byname (fcn, name);\n\tif (existing && (existing->kind != kind || existing->delta != delta)) {\n\t\t// var name already exists at a different kind+delta\n\t\treturn NULL;\n\t}\n\tRRegItem *reg = NULL;\n\tif (!kind) {\n\t\tkind = R_ANAL_VAR_KIND_BPV;\n\t}\n\tif (!type) {\n\t\ttype = __int_type_from_size (size);\n\t\tif (!type) {\n\t\t\ttype = __int_type_from_size (fcn->anal->bits);\n\t\t}\n\t\tif (!type) {\n\t\t\ttype = \"int32_t\";\n\t\t}\n\t}\n\tif (!valid_var_kind (kind)) {\n\t\teprintf (\"Invalid var kind '%c'\\n\", kind);\n\t\treturn NULL;\n\t}\n\tif (kind == R_ANAL_VAR_KIND_REG) {\n\t\treg = r_reg_index_get (fcn->anal->reg, R_ABS (delta));\n\t\tif (!reg) {\n\t\t\tif (fcn->anal->verbose) {\n\t\t\t\teprintf (\"No register at index %d\\n\", delta);\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tRAnalVar *var = r_anal_function_get_var (fcn, kind, delta);\n\tif (!var) {\n\t\tvar = R_NEW0 (RAnalVar);\n\t\tif (!var) {\n\t\t\treturn NULL;\n\t\t}\n\t\tr_pvector_push (&fcn->vars, var);\n\t\tvar->fcn = fcn;\n\t\tr_vector_init (&var->accesses, sizeof (RAnalVarAccess), NULL, NULL);\n\t\tr_vector_init (&var->constraints, sizeof (RAnalVarConstraint), NULL, NULL);\n\t} else {\n\t\tfree (var->name);\n\t\tfree (var->regname);\n\t\tfree (var->type);\n\t}\n\tR_DIRTY (fcn->anal);\n\tvar->name = strdup (name);\n\tvar->regname = reg? strdup (reg->name): NULL; // TODO: no strdup here? pool? or not keep regname at all?\n\tvar->type = strdup (type);\n\tvar->kind = kind;\n\tvar->isarg = isarg;\n\tvar->delta = delta;\n\tshadow_var_struct_members (var);\n\treturn var;\n}\n\nR_API bool r_anal_function_set_var_prot(RAnalFunction *fcn, RList *l) {\n\tRListIter *iter;\n\tRAnalVarProt *vp;\n\tr_list_foreach (l, iter, vp) {\n\t\tif (!r_anal_function_set_var (fcn, vp->delta, vp->kind, vp->type, -1, vp->isarg, vp->name)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tR_DIRTY (fcn->anal);\n\treturn true;\n}\n\nR_API void r_anal_var_set_type(RAnalVar *var, const char *type) {\n\tchar *nt = strdup (type);\n\tif (!nt) {\n\t\treturn;\n\t}\n\tfree (var->type);\n\tvar->type = nt;\n\tshadow_var_struct_members (var);\n}\n\nstatic void var_free(RAnalVar *var) {\n\tif (var) {\n\t\tr_anal_var_clear_accesses (var);\n\t\tr_vector_fini (&var->constraints);\n\t\tfree (var->name);\n\t\tfree (var->regname);\n\t\tfree (var->type);\n\t\tfree (var->comment);\n\t\tfree (var);\n\t}\n}\n\nstatic void r_anal_var_proto_free(RAnalVarProt *vp) {\n\tif (vp) {\n\t\tfree (vp->name);\n\t\tfree (vp->type);\n\t\tfree (vp);\n\t}\n}\n\nR_API void r_anal_var_delete(RAnalVar *var) {\n\tr_return_if_fail (var);\n\tRAnalFunction *fcn = var->fcn;\n\tsize_t i;\n\tfor (i = 0; i < r_pvector_len (&fcn->vars); i++) {\n\t\tRAnalVar *v = r_pvector_at (&fcn->vars, i);\n\t\tif (v == var) {\n\t\t\tr_pvector_remove_at (&fcn->vars, i);\n\t\t\tvar_free (v);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nR_API void r_anal_function_delete_vars_by_kind(RAnalFunction *fcn, RAnalVarKind kind) {\n\tr_return_if_fail (fcn);\n\tsize_t i;\n\tfor (i = 0; i < r_pvector_len (&fcn->vars);) {\n\t\tRAnalVar *var = r_pvector_at (&fcn->vars, i);\n\t\tif (var->kind == kind) {\n\t\t\tr_pvector_remove_at (&fcn->vars, i);\n\t\t\tvar_free (var);\n\t\t\tcontinue;\n\t\t}\n\t\ti++;\n\t}\n}\n\nR_API void r_anal_function_delete_all_vars(RAnalFunction *fcn) {\n\tr_return_if_fail (fcn);\n\tif (fcn->vars.v.len > 0) {\n\t\tvoid **it;\n\t\tr_pvector_foreach (&fcn->vars, it) {\n\t\t\tvar_free (*it);\n\t\t}\n\t}\n\tr_pvector_clear (&fcn->vars);\n}\n\nR_API void r_anal_function_delete_unused_vars(RAnalFunction *fcn) {\n\tr_return_if_fail (fcn);\n\tvoid **v;\n\tRPVector *vars_clone = (RPVector *)r_vector_clone ((RVector *)&fcn->vars);\n\tr_pvector_foreach (vars_clone, v) {\n\t\tRAnalVar *var = *v;\n\t\tif (r_vector_empty (&var->accesses)) {\n\t\t\tr_anal_function_delete_var (fcn, var);\n\t\t}\n\t}\n\tr_pvector_free (vars_clone);\n}\n\nR_API void r_anal_function_delete_var(RAnalFunction *fcn, RAnalVar *var) {\n\tr_return_if_fail (fcn && var);\n\tr_pvector_remove_data (&fcn->vars, var);\n\tvar_free (var);\n}\n\nR_API RList *r_anal_var_deserialize(const char *ser) {\n\tr_return_val_if_fail (ser, NULL);\n\tRList *ret = r_list_newf ((RListFree)r_anal_var_proto_free);\n\twhile (*ser) {\n\t\tRAnalVarProt *v = R_NEW0 (RAnalVarProt);\n\t\tr_list_append (ret, v);\n\t\tif (!v) {\n\t\t\tgoto bad_serial;\n\t\t}\n\n\t\t// isarg\n\t\tswitch (*ser) {\n\t\tcase 't':\n\t\t\tv->isarg = true;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tv->isarg = false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto bad_serial;\n\t\t}\n\t\tser++;\n\n\t\t// kind\n\t\tif (!valid_var_kind (*ser)) {\n\t\t\tgoto bad_serial;\n\t\t}\n\t\tv->kind = *ser++;\n\n\t\t// delta\n\t\tchar *nxt;\n\t\tv->delta = strtol (ser, &nxt, 10);\n\t\tif ((!v->delta && nxt == ser) || *nxt != ':') {\n\t\t\tgoto bad_serial;\n\t\t}\n\t\tser = ++nxt;\n\n\t\t// name\n\t\tint i;\n\t\tfor (i = 0; *nxt != ':'; i++) {\n\t\t\tif (*nxt == ',' || !*nxt) {\n\t\t\t\tgoto bad_serial;\n\t\t\t}\n\t\t\tnxt++;\n\t\t}\n\t\tv->name = r_str_newlen (ser, i);\n\t\tif (!v->name) {\n\t\t\tgoto bad_serial;\n\t\t}\n\t\tser = ++nxt;\n\n\t\t// type\n\t\tfor (i = 0; *nxt && *nxt != ','; i++) {\n\t\t\tnxt++;\n\t\t}\n\t\tv->type = r_str_newlen (ser, i);\n\t\tif (!v->type) {\n\t\t\tgoto bad_serial;\n\t\t}\n\t\tser = nxt;\n\t\tif (*ser == ',') {\n\t\t\tser++;\n\t\t}\n\t\twhile (*ser == ' ') {\n\t\t\tser++;\n\t\t}\n\t}\n\treturn ret;\nbad_serial:\n\tr_list_free (ret);\n\treturn NULL;\n}\n\nstatic inline void sanitize_var_serial(char *name, bool colon) {\n\tr_return_if_fail (name);\n\tfor (; *name; name++) {\n\t\tswitch (*name) {\n\t\tcase ':':\n\t\t\tif (colon) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase '`':\n\t\tcase '$':\n\t\tcase '{':\n\t\tcase '}':\n\t\tcase '~':\n\t\tcase '|':\n\t\tcase '#':\n\t\tcase '@':\n\t\tcase '&':\n\t\tcase '<':\n\t\tcase '>':\n\t\tcase ',':\n\t\t\t*name = '_';\n\t\t\tcontinue;\n\t\t}\n\t}\n}\n\nstatic inline bool serialize_single_var(RAnalVarProt *vp, RStrBuf *sb) {\n\tr_return_val_if_fail (vp && sb, false);\n\t// shouldn't have special chars in them anyways, so replace in place\n\tsanitize_var_serial (vp->name, false);\n\tsanitize_var_serial (vp->type, true);\n\tconst char b = vp->isarg? 't': 'f';\n\tif (!valid_var_kind (vp->kind)) {\n\t\treturn false;\n\t}\n\treturn r_strbuf_appendf (sb, \"%c%c%d:%s:%s\", b, vp->kind, vp->delta, vp->name, vp->type);\n}\n\nR_API char *r_anal_var_prot_serialize(RList *l, bool spaces) {\n\tr_return_val_if_fail (l, NULL);\n\tif (l->length == 0) {\n\t\treturn NULL;\n\t}\n\n\tRStrBuf *sb = r_strbuf_new (\"\");\n\tif (!sb) {\n\t\treturn NULL;\n\t}\n\tr_strbuf_reserve (sb, r_list_length (l) * 0x10);\n\n\tchar *sep = spaces? \", \": \",\";\n\tsize_t len = strlen (sep);\n\tRAnalVarProt *v;\n\tRAnalVarProt *top = (RAnalVarProt *)r_list_get_top (l);\n\tRListIter *iter;\n\tr_list_foreach (l, iter, v) {\n\t\tif (!serialize_single_var (v, sb) || (v != top && !r_strbuf_append_n (sb, sep, len))) {\n\t\t\tr_strbuf_free (sb);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn r_strbuf_drain (sb);\n}\n\nR_API RList *r_anal_var_get_prots(RAnalFunction *fcn) {\n\tr_return_val_if_fail (fcn, NULL);\n\tRList *ret = r_list_newf ((RListFree)r_anal_var_proto_free);\n\tif (ret) {\n\t\tvoid **p;\n\t\tr_pvector_foreach (&fcn->vars, p) {\n\t\t\tRAnalVar *var = *p;\n\t\t\tRAnalVarProt *vp = R_NEW0 (RAnalVarProt);\n\t\t\tif (vp) {\n\t\t\t\tvp->isarg = var->isarg;\n\t\t\t\tvp->name = strdup (var->name);\n\t\t\t\tvp->type = strdup (var->type);\n\t\t\t\tvp->kind = var->kind;\n\t\t\t\tvp->delta = var->delta;\n\t\t\t\tr_list_append (ret, vp);\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nR_API R_BORROW RAnalVar *r_anal_function_get_var_byname(RAnalFunction *fcn, const char *name) {\n\tr_return_val_if_fail (fcn && name, NULL);\n\tvoid **it;\n\tr_pvector_foreach (&fcn->vars, it) {\n\t\tRAnalVar *var = *it;\n\t\tif (!strcmp (var->name, name)) {\n\t\t\treturn var;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API RAnalVar *r_anal_function_get_var(RAnalFunction *fcn, char kind, int delta) {\n\tr_return_val_if_fail (fcn, NULL);\n\tvoid **it;\n\tr_pvector_foreach (&fcn->vars, it) {\n\t\tRAnalVar *var = *it;\n\t\tif (var->kind == kind && var->delta == delta) {\n\t\t\treturn var;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API ut64 r_anal_var_addr(RAnalVar *var) {\n\tr_return_val_if_fail (var, UT64_MAX);\n\tRAnal *anal = var->fcn->anal;\n\tconst char *regname = NULL;\n\tif (var->kind == R_ANAL_VAR_KIND_BPV) {\n\t\tregname = r_reg_get_name (anal->reg, R_REG_NAME_BP);\n\t\treturn r_reg_getv (anal->reg, regname) + var->delta + var->fcn->bp_off;\n\t} else if (var->kind == R_ANAL_VAR_KIND_SPV) {\n\t\tregname = r_reg_get_name (anal->reg, R_REG_NAME_SP);\n\t\treturn r_reg_getv (anal->reg, regname) + var->delta;\n\t}\n\treturn 0;\n}\n\nR_API st64 r_anal_function_get_var_stackptr_at(RAnalFunction *fcn, st64 delta, ut64 addr) {\n\tst64 offset = addr - fcn->addr;\n\tRPVector *inst_accesses = ht_up_find (fcn->inst_vars, offset, NULL);\n\tif (!inst_accesses) {\n\t\treturn ST64_MAX;\n\t}\n\tRAnalVar *var = NULL;\n\tvoid **it;\n\tr_pvector_foreach (inst_accesses, it) {\n\t\tRAnalVar *v = *it;\n\t\tif (v->delta == delta) {\n\t\t\tvar = v;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!var) {\n\t\treturn ST64_MAX;\n\t}\n\tsize_t index;\n\tr_vector_lower_bound (&var->accesses, offset, index, ACCESS_CMP);\n\tRAnalVarAccess *acc = NULL;\n\tif (index < var->accesses.len) {\n\t\tacc = r_vector_index_ptr (&var->accesses, index);\n\t}\n\tif (!acc || acc->offset != offset) {\n\t\treturn ST64_MAX;\n\t}\n\treturn acc->stackptr;\n}\n\nR_API const char *r_anal_function_get_var_reg_at(RAnalFunction *fcn, st64 delta, ut64 addr) {\n\tst64 offset = addr - fcn->addr;\n\tRPVector *inst_accesses = ht_up_find (fcn->inst_vars, offset, NULL);\n\tif (!inst_accesses) {\n\t\treturn NULL;\n\t}\n\tRAnalVar *var = NULL;\n\tvoid **it;\n\tr_pvector_foreach (inst_accesses, it) {\n\t\tRAnalVar *v = *it;\n\t\tif (v->delta == delta) {\n\t\t\tvar = v;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!var) {\n\t\treturn NULL;\n\t}\n\tsize_t index;\n\tr_vector_lower_bound (&var->accesses, offset, index, ACCESS_CMP);\n\tRAnalVarAccess *acc = NULL;\n\tif (index < var->accesses.len) {\n\t\tacc = r_vector_index_ptr (&var->accesses, index);\n\t}\n\tif (!acc || acc->offset != offset) {\n\t\treturn NULL;\n\t}\n\treturn acc->reg;\n}\n\nR_API bool r_anal_var_check_name(const char *name) {\n\treturn !isdigit ((unsigned char)*name) && strcspn (name, \"., =/\");\n}\n\nR_API bool r_anal_var_rename(RAnalVar *var, const char *new_name, bool verbose) {\n\tr_return_val_if_fail (var, false);\n\tif (!r_anal_var_check_name (new_name)) {\n\t\treturn false;\n\t}\n\tRAnalVar *v1 = r_anal_function_get_var_byname (var->fcn, new_name);\n\tif (v1) {\n\t\tif (verbose) {\n\t\t\teprintf (\"variable or arg with name `%s` already exist\\n\", new_name);\n\t\t}\n\t\treturn false;\n\t}\n\tchar *nn = strdup (new_name);\n\tif (!nn) {\n\t\treturn false;\n\t}\n\tfree (var->name);\n\tvar->name = nn;\n\treturn true;\n}\n\nR_API int r_anal_var_get_argnum(RAnalVar *var) {\n\tr_return_val_if_fail (var, -1);\n\tRAnal *anal = var->fcn->anal;\n\tif (!var->isarg || var->kind != R_ANAL_VAR_KIND_REG) { // TODO: support bp and sp too\n\t\treturn -1;\n\t}\n\tif (!var->regname) {\n\t\treturn -1;\n\t}\n\tRRegItem *reg = r_reg_get (anal->reg, var->regname, -1);\n\tif (!reg) {\n\t\treturn -1;\n\t}\n\tint i;\n\tint arg_max = var->fcn->cc ? r_anal_cc_max_arg (anal, var->fcn->cc) : 0;\n\tfor (i = 0; i < arg_max; i++) {\n\t\tconst char *reg_arg = r_anal_cc_arg (anal, var->fcn->cc, i);\n\t\tif (reg_arg && !strcmp (reg->name, reg_arg)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\nR_API R_BORROW RPVector *r_anal_function_get_vars_used_at(RAnalFunction *fcn, ut64 op_addr) {\n\tr_return_val_if_fail (fcn, NULL);\n\treturn ht_up_find (fcn->inst_vars, op_addr - fcn->addr, NULL);\n}\n\nR_API R_DEPRECATE RAnalVar *r_anal_get_used_function_var(RAnal *anal, ut64 addr) {\n\tRList *fcns = r_anal_get_functions_in (anal, addr);\n\tif (!fcns) {\n\t\treturn NULL;\n\t}\n\tRAnalVar *var = NULL;\n\tRListIter *it;\n\tRAnalFunction *fcn;\n\tr_list_foreach (fcns, it, fcn) {\n\t\tRPVector *used_vars = r_anal_function_get_vars_used_at (fcn, addr);\n\t\tif (used_vars && !r_pvector_empty (used_vars)) {\n\t\t\tvar = r_pvector_at (used_vars, 0);\n\t\t\tbreak;\n\t\t}\n\t}\n\tr_list_free (fcns);\n\treturn var;\n}\n\nR_API RAnalVar *r_anal_var_get_dst_var(RAnalVar *var) {\n\tr_return_val_if_fail (var, NULL);\n\tRAnalVarAccess *acc;\n\tr_vector_foreach (&var->accesses, acc) {\n\t\tif (!(acc->type & R_ANAL_VAR_ACCESS_TYPE_READ)) {\n\t\t\tcontinue;\n\t\t}\n\t\tut64 addr = var->fcn->addr + acc->offset;\n\t\tRPVector *used_vars = r_anal_function_get_vars_used_at (var->fcn, addr);\n\t\tvoid **it;\n\t\tr_pvector_foreach (used_vars, it) {\n\t\t\tRAnalVar *used_var = *it;\n\t\t\tif (used_var == var) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRAnalVarAccess *other_acc = r_anal_var_get_access_at (used_var, addr);\n\t\t\tif (other_acc && other_acc->type & R_ANAL_VAR_ACCESS_TYPE_WRITE) {\n\t\t\t\treturn used_var;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API void r_anal_var_set_access(RAnalVar *var, const char *reg, ut64 access_addr, int access_type, st64 stackptr) {\n\tr_return_if_fail (var);\n\tst64 offset = access_addr - var->fcn->addr;\n\n\t// accesses are stored ordered by offset, use binary search to get the matching existing or the index to insert a new one\n\tsize_t index;\n\tr_vector_lower_bound (&var->accesses, offset, index, ACCESS_CMP);\n\tRAnalVarAccess *acc = NULL;\n\tif (index < var->accesses.len) {\n\t\tacc = r_vector_index_ptr (&var->accesses, index);\n\t}\n\tif (!acc || acc->offset != offset) {\n\t\tacc = r_vector_insert (&var->accesses, index, NULL);\n\t\tacc->offset = offset;\n\t\tacc->type = 0;\n\t}\n\n\tacc->type |= (ut8)access_type;\n\tacc->stackptr = stackptr;\n\tacc->reg = r_str_constpool_get (&var->fcn->anal->constpool, reg);\n\n\t// add the inverse reference from the instruction to the var\n\tRPVector *inst_accesses = ht_up_find (var->fcn->inst_vars, (ut64)offset, NULL);\n\tif (!inst_accesses) {\n\t\tinst_accesses = r_pvector_new (NULL);\n\t\tif (!inst_accesses) {\n\t\t\treturn;\n\t\t}\n\t\tht_up_insert (var->fcn->inst_vars, (ut64)offset, inst_accesses);\n\t}\n\tif (!r_pvector_contains (inst_accesses, var)) {\n\t\tr_pvector_push (inst_accesses, var);\n\t}\n}\n\nR_API void r_anal_var_remove_access_at(RAnalVar *var, ut64 address) {\n\tr_return_if_fail (var);\n\tst64 offset = address - var->fcn->addr;\n\tsize_t index;\n\tr_vector_lower_bound (&var->accesses, offset, index, ACCESS_CMP);\n\tif (index >= var->accesses.len) {\n\t\treturn;\n\t}\n\tRAnalVarAccess *acc = r_vector_index_ptr (&var->accesses, index);\n\tif (acc->offset == offset) {\n\t\tr_vector_remove_at (&var->accesses, index, NULL);\n\t\tRPVector *inst_accesses = ht_up_find (var->fcn->inst_vars, (ut64)offset, NULL);\n\t\tr_pvector_remove_data (inst_accesses, var);\n\t}\n\tR_DIRTY (var->fcn->anal);\n}\n\nR_API void r_anal_var_clear_accesses(RAnalVar *var) {\n\tr_return_if_fail (var);\n\tRAnalFunction *fcn = var->fcn;\n\tif (fcn->inst_vars) {\n\t\t// remove all inverse references to the var's accesses\n\t\tRAnalVarAccess *acc;\n\t\tr_vector_foreach (&var->accesses, acc) {\n\t\t\tRPVector *inst_accesses = ht_up_find (fcn->inst_vars, (ut64)acc->offset, NULL);\n\t\t\tif (!inst_accesses) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tr_pvector_remove_data (inst_accesses, var);\n\t\t}\n\t}\n\tr_vector_clear (&var->accesses);\n\tR_DIRTY (var->fcn->anal);\n}\n\nR_API RAnalVarAccess *r_anal_var_get_access_at(RAnalVar *var, ut64 addr) {\n\tr_return_val_if_fail (var, NULL);\n\tst64 offset = addr - var->fcn->addr;\n\tsize_t index;\n\tr_vector_lower_bound (&var->accesses, offset, index, ACCESS_CMP);\n\tif (index >= var->accesses.len) {\n\t\treturn NULL;\n\t}\n\tRAnalVarAccess *acc = r_vector_index_ptr (&var->accesses, index);\n\tif (acc->offset == offset) {\n\t\treturn acc;\n\t}\n\treturn NULL;\n}\n\nR_API void r_anal_var_add_constraint(RAnalVar *var, R_BORROW RAnalVarConstraint *constraint) {\n\tr_vector_push (&var->constraints, constraint);\n}\n\nR_API char *r_anal_var_get_constraints_readable(RAnalVar *var) {\n\tsize_t n = var->constraints.len;\n\tif (!n) {\n\t\treturn NULL;\n\t}\n\tbool low = false, high = false;\n\tRStrBuf sb;\n\tr_strbuf_init (&sb);\n\tsize_t i;\n\tfor (i = 0; i < n; i += 1) {\n\t\tRAnalVarConstraint *constr = r_vector_index_ptr (&var->constraints, i);\n\t\tswitch (constr->cond) {\n\t\tcase R_ANAL_COND_LE:\n\t\t\tif (high) {\n\t\t\t\tr_strbuf_append (&sb, \" && \");\n\t\t\t}\n\t\t\tr_strbuf_appendf (&sb, \"<= 0x%\"PFMT64x \"\", constr->val);\n\t\t\tlow = true;\n\t\t\tbreak;\n\t\tcase R_ANAL_COND_LT:\n\t\t\tif (high) {\n\t\t\t\tr_strbuf_append (&sb, \" && \");\n\t\t\t}\n\t\t\tr_strbuf_appendf (&sb, \"< 0x%\"PFMT64x \"\", constr->val);\n\t\t\tlow = true;\n\t\t\tbreak;\n\t\tcase R_ANAL_COND_GE:\n\t\t\tr_strbuf_appendf (&sb, \">= 0x%\"PFMT64x \"\", constr->val);\n\t\t\thigh = true;\n\t\t\tbreak;\n\t\tcase R_ANAL_COND_GT:\n\t\t\tr_strbuf_appendf (&sb, \"> 0x%\"PFMT64x \"\", constr->val);\n\t\t\thigh = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (low && high && i != n - 1) {\n\t\t\tr_strbuf_append (&sb, \" || \");\n\t\t\tlow = false;\n\t\t\thigh = false;\n\t\t}\n\t}\n\treturn r_strbuf_drain_nofree (&sb);\n}\n\nR_API int r_anal_var_count(RAnal *a, RAnalFunction *fcn, int kind, int type) {\n\tr_return_val_if_fail (fcn && a && type >= 0 && type <= 1, -1);\n\t// type { local: 0, arg: 1 };\n\tRList *list = r_anal_var_list (a, fcn, kind);\n\tRAnalVar *var;\n\tRListIter *iter;\n\tint count[2] = {\n\t\t0\n\t};\n\tr_list_foreach (list, iter, var) {\n\t\tif (kind == R_ANAL_VAR_KIND_REG) {\n\t\t\tcount[1]++;\n\t\t\tcontinue;\n\t\t}\n\t\tcount[var->isarg]++;\n\t}\n\tr_list_free (list);\n\treturn count[type];\n}\n\nR_API int r_anal_var_count_all(RAnalFunction *fcn) {\n\tr_return_val_if_fail (fcn, 0);\n\treturn r_pvector_len (&fcn->vars);\n}\n\nR_API int r_anal_var_count_args(RAnalFunction *fcn) {\n\tr_return_val_if_fail (fcn, 0); // No function implies no variables, but probably mistake\n\tint args = 0;\n\tvoid **it;\n\tr_pvector_foreach (&fcn->vars, it) {\n\t\tRAnalVar *var = *it;\n\t\tif (var->isarg) {\n\t\t\targs++;\n\t\t}\n\t}\n\treturn args;\n}\n\nR_API int r_anal_var_count_locals(RAnalFunction *fcn) {\n\t// if it's not an arg then it's local\n\tint args = r_anal_var_count_args (fcn);\n\treturn r_anal_var_count_all (fcn) - args;\n}\n\nstatic bool var_add_structure_fields_to_list(RAnal *a, RAnalVar *av, RList *list) {\n\tSdb *TDB = a->sdb_types;\n\tconst char *type_kind = sdb_const_get (TDB, av->type, 0);\n\tif (type_kind && !strcmp (type_kind, \"struct\")) {\n\t\tchar *field_name, *new_name;\n\t\tint field_n;\n\t\tchar *type_key = r_str_newf (\"%s.%s\", type_kind, av->type);\n\t\tfor (field_n = 0; (field_name = sdb_array_get (TDB, type_key, field_n, NULL)); field_n++) {\n\t\t\tchar *field_key = r_str_newf (\"%s.%s\", type_key, field_name);\n\t\t\tchar *field_type = sdb_array_get (TDB, field_key, 0, NULL);\n\t\t\tut64 field_offset = sdb_array_get_num (TDB, field_key, 1, NULL);\n\t\t\tnew_name = r_str_newf (\"%s.%s\", av->name, field_name);\n\t\t\tRAnalVarField *field = R_NEW0 (RAnalVarField);\n\t\t\tfield->name = new_name;\n\t\t\tfield->delta = av->delta + field_offset;\n\t\t\tfield->field = true;\n\t\t\tr_list_append (list, field);\n\t\t\tfree (field_type);\n\t\t\tfree (field_key);\n\t\t\tfree (field_name);\n\t\t}\n\t\tfree (type_key);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic const char *get_regname(RAnal *anal, RAnalValue *value) {\n\tconst char *name = NULL;\n\tif (value && value->reg && value->reg->name) {\n\t\tname = value->reg->name;\n\t\tRRegItem *ri = r_reg_get (anal->reg, value->reg->name, -1);\n\t\tif (ri && (ri->size == 32) && (anal->bits == 64)) {\n\t\t\tname = r_reg_32_to_64 (anal->reg, value->reg->name);\n\t\t}\n\t}\n\treturn name;\n}\n\nR_API R_OWN char *r_anal_function_autoname_var(RAnalFunction *fcn, char kind, const char *pfx, int ptr) {\n\tvoid **it;\n\tconst ut32 uptr = R_ABS (ptr);\n\tchar *varname = r_str_newf (\"%s_%xh\", pfx, uptr);\n\tr_pvector_foreach (&fcn->vars, it) {\n\t\tRAnalVar *var = *it;\n\t\tif (!strcmp (varname, var->name)) {\n\t\t\tif (var->kind != kind) {\n\t\t\t\tconst char *k = kind == R_ANAL_VAR_KIND_SPV ? \"sp\" : \"bp\";\n\t\t\t\tfree (varname);\n\t\t\t\tvarname = r_str_newf (\"%s_%s_%xh\", pfx, k, uptr);\n\t\t\t\treturn varname;\n\t\t\t}\n\t\t\tint i = 2;\n\t\t\tdo {\n\t\t\t\tfree (varname);\n\t\t\t\tvarname = r_str_newf (\"%s_%xh_%u\", pfx, uptr, i++);\n\t\t\t} while (r_anal_function_get_var_byname (fcn, varname));\n\t\t\treturn varname;\n\t\t}\n\t}\n\treturn varname;\n}\n\nstatic RAnalVar *get_stack_var(RAnalFunction *fcn, int delta) {\n\tvoid **it;\n\tr_pvector_foreach (&fcn->vars, it) {\n\t\tRAnalVar *var = *it;\n\t\tbool is_stack = var->kind == R_ANAL_VAR_KIND_SPV || var->kind == R_ANAL_VAR_KIND_BPV;\n\t\tif (is_stack && var->delta == delta) {\n\t\t\treturn var;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void extract_arg(RAnal *anal, RAnalFunction *fcn, RAnalOp *op, const char *reg, const char *sign, char type) {\n\tst64 ptr = 0;\n\tchar *addr, *esil_buf = NULL;\n\tconst st64 maxstackframe = 1024 * 8; \n\n\tr_return_if_fail (anal && fcn && op && reg);\n\n\tsize_t i;\n\tfor (i = 0; i < R_ARRAY_SIZE (op->src); i++) {\n\t\tif (op->src[i] && op->src[i]->reg && op->src[i]->reg->name) {\n\t\t\tif (!strcmp (reg, op->src[i]->reg->name)) {\n\t\t\t\tst64 delta = op->src[i]->delta;\n\t\t\t\tif ((delta > 0 && *sign == '+') || (delta < 0 && *sign == '-')) {\n\t\t\t\t\tptr = R_ABS (op->src[i]->delta);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!ptr) {\n\t\tconst char *op_esil = r_strbuf_get (&op->esil);\n\t\tif (!op_esil) {\n\t\t\treturn;\n\t\t}\n\t\tesil_buf = strdup (op_esil);\n\t\tif (!esil_buf) {\n\t\t\treturn;\n\t\t}\n\t\tr_strf_var (esilexpr, 64, \",%s,%s,\", reg, sign);\n\t\tchar *ptr_end = strstr (esil_buf, esilexpr);\n\t\tif (!ptr_end) {\n\t\t\tfree (esil_buf);\n\t\t\treturn;\n\t\t}\n\t\t*ptr_end = 0;\n\t\taddr = ptr_end;\n\t\twhile ((addr[0] != '0' || addr[1] != 'x') && addr >= esil_buf + 1 && *addr != ',') {\n\t\t\taddr--;\n\t\t}\n\t\tif (strncmp (addr, \"0x\", 2)) {\n\t\t\t//XXX: This is a workaround for inconsistent esil\n\t\t\tif (!op->stackop && op->dst) {\n\t\t\t\tconst char *sp = r_reg_get_name (anal->reg, R_REG_NAME_SP);\n\t\t\t\tconst char *bp = r_reg_get_name (anal->reg, R_REG_NAME_BP);\n\t\t\t\tconst char *rn = op->dst->reg ? op->dst->reg->name : NULL;\n\t\t\t\tif (rn && ((bp && !strcmp (bp, rn)) || (sp && !strcmp (sp, rn)))) {\n\t\t\t\t\tif (anal->verbose) {\n\t\t\t\t\t\teprintf (\"Warning: Analysis didn't fill op->stackop for instruction that alters stack at 0x%\" PFMT64x \".\\n\", op->addr);\n\t\t\t\t\t}\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (*addr == ',') {\n\t\t\t\taddr++;\n\t\t\t}\n\t\t\tif (!op->stackop && op->type != R_ANAL_OP_TYPE_PUSH && op->type != R_ANAL_OP_TYPE_POP\n\t\t\t\t&& op->type != R_ANAL_OP_TYPE_RET && r_str_isnumber (addr)) {\n\t\t\t\tptr = (st64)r_num_get (NULL, addr);\n\t\t\t\tif (ptr && op->src[0] && ptr == op->src[0]->imm) {\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t} else if ((op->stackop == R_ANAL_STACK_SET) || (op->stackop == R_ANAL_STACK_GET)) {\n\t\t\t\tif (op->ptr % 4) {\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tptr = R_ABS (op->ptr);\n\t\t\t} else {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t} else {\n\t\t\tptr = (st64)r_num_get (NULL, addr);\n\t\t}\n\t}\n\n\tif (anal->verbose && (!op->src[0] || !op->dst)) {\n\t\teprintf (\"Warning: Analysis didn't fill op->src/dst at 0x%\" PFMT64x \".\\n\", op->addr);\n\t}\n\n\tint rw = (op->direction == R_ANAL_OP_DIR_WRITE) ? R_ANAL_VAR_ACCESS_TYPE_WRITE : R_ANAL_VAR_ACCESS_TYPE_READ;\n\tif (*sign == '+') {\n\t\tconst bool isarg = type == R_ANAL_VAR_KIND_SPV ? ptr >= fcn->stack : ptr >= fcn->bp_off;\n\t\tconst char *pfx = isarg ? ARGPREFIX : VARPREFIX;\n\t\tst64 frame_off;\n\t\tif (type == R_ANAL_VAR_KIND_SPV) {\n\t\t\tframe_off = ptr - fcn->stack;\n\t\t} else {\n\t\t\tframe_off = ptr - fcn->bp_off;\n\t\t}\n\t\tif (maxstackframe != 0 && (frame_off > maxstackframe || frame_off < -maxstackframe)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tRAnalVar *var = get_stack_var (fcn, frame_off);\n\t\tif (var) {\n\t\t\tr_anal_var_set_access (var, reg, op->addr, rw, ptr);\n\t\t\tgoto beach;\n\t\t}\n\t\tchar *varname = NULL, *vartype = NULL;\n\t\tif (isarg) {\n\t\t\tconst char *place = fcn->cc ? r_anal_cc_arg (anal, fcn->cc, ST32_MAX) : NULL;\n\t\t\tbool stack_rev = place ? !strcmp (place, \"stack_rev\") : false;\n\t\t\tchar *fname = r_type_func_guess (anal->sdb_types, fcn->name);\n\t\t\tif (fname) {\n\t\t\t\tut64 sum_sz = 0;\n\t\t\t\tsize_t from, to, i;\n\t\t\t\tif (stack_rev) {\n\t\t\t\t\tconst size_t cnt = r_type_func_args_count (anal->sdb_types, fname);\n\t\t\t\t\tfrom = cnt ? cnt - 1 : cnt;\n\t\t\t\t\tto = fcn->cc ? r_anal_cc_max_arg (anal, fcn->cc) : 0;\n\t\t\t\t} else {\n\t\t\t\t\tfrom = fcn->cc ? r_anal_cc_max_arg (anal, fcn->cc) : 0;\n\t\t\t\t\tto = r_type_func_args_count (anal->sdb_types, fname);\n\t\t\t\t}\n\t\t\t\tconst int bytes = (fcn->bits ? fcn->bits : anal->bits) / 8;\n\t\t\t\tfor (i = from; stack_rev ? i >= to : i < to; stack_rev ? i-- : i++) {\n\t\t\t\t\tchar *tp = r_type_func_args_type (anal->sdb_types, fname, i);\n\t\t\t\t\tif (!tp) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (sum_sz == frame_off) {\n\t\t\t\t\t\tvartype = tp;\n\t\t\t\t\t\tvarname = strdup (r_type_func_args_name (anal->sdb_types, fname, i));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tut64 bit_sz = r_type_get_bitsize (anal->sdb_types, tp);\n\t\t\t\t\tsum_sz += bit_sz ? bit_sz / 8 : bytes;\n\t\t\t\t\tsum_sz = R_ROUND (sum_sz, bytes);\n\t\t\t\t\tfree (tp);\n\t\t\t\t}\n\t\t\t\tfree (fname);\n\t\t\t}\n\t\t}\n\t\tif (!varname) {\n\t\t\tif (anal->opt.varname_stack) {\n\t\t\t\tvarname = r_str_newf (\"%s_%\" PFMT64x \"h\", pfx, R_ABS (frame_off));\n\t\t\t} else {\n\t\t\t\tvarname = r_anal_function_autoname_var (fcn, type, pfx, ptr);\n\t\t\t}\n\t\t}\n\t\tif (varname) {\n#if 0\n\t\t\tif (isarg && frame_off > 48) {\n\t\t\t\tfree (varname);\n\t\t\t\tgoto beach;\n\t\t\t}\n#endif\n\t\t\tRAnalVar *var = r_anal_function_set_var (fcn, frame_off, type, vartype, anal->bits / 8, isarg, varname);\n\t\t\tif (var) {\n\t\t\t\tr_anal_var_set_access (var, reg, op->addr, rw, ptr);\n\t\t\t}\n\t\t\tfree (varname);\n\t\t}\n\t\tfree (vartype);\n\t} else {\n\t\tst64 frame_off = -(ptr + fcn->bp_off);\n\t\tif (maxstackframe != 0 && (frame_off > maxstackframe || frame_off < -maxstackframe)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tRAnalVar *var = get_stack_var (fcn, frame_off);\n\t\tif (var) {\n\t\t\tr_anal_var_set_access (var, reg, op->addr, rw, -ptr);\n\t\t\tgoto beach;\n\t\t}\n\t\tchar *varname = anal->opt.varname_stack\n\t\t\t? r_str_newf (\"%s_%\" PFMT64x \"h\", VARPREFIX, R_ABS (frame_off))\n\t\t\t: r_anal_function_autoname_var (fcn, type, VARPREFIX, -ptr);\n\t\tif (varname) {\n\t\t\tRAnalVar *var = r_anal_function_set_var (fcn, frame_off, type, NULL, anal->bits / 8, false, varname);\n\t\t\tif (var) {\n\t\t\t\tr_anal_var_set_access (var, reg, op->addr, rw, -ptr);\n\t\t\t}\n\t\t\tfree (varname);\n\t\t}\n\t}\nbeach:\n\tfree (esil_buf);\n}\n\nstatic bool is_reg_in_src(const char *regname, RAnal *anal, RAnalOp *op);\n\nstatic inline bool op_affect_dst(RAnalOp* op) {\n\tswitch (op->type) {\n\tcase R_ANAL_OP_TYPE_ADD:\n\tcase R_ANAL_OP_TYPE_SUB:\n\tcase R_ANAL_OP_TYPE_MUL:\n\tcase R_ANAL_OP_TYPE_DIV:\n\tcase R_ANAL_OP_TYPE_SHR:\n\tcase R_ANAL_OP_TYPE_SHL:\n\tcase R_ANAL_OP_TYPE_SAL:\n\tcase R_ANAL_OP_TYPE_SAR:\n\tcase R_ANAL_OP_TYPE_OR:\n\tcase R_ANAL_OP_TYPE_AND:\n\tcase R_ANAL_OP_TYPE_XOR:\n\tcase R_ANAL_OP_TYPE_NOR:\n\tcase R_ANAL_OP_TYPE_NOT:\n\tcase R_ANAL_OP_TYPE_ROR:\n\tcase R_ANAL_OP_TYPE_ROL:\n\tcase R_ANAL_OP_TYPE_CAST:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n#define STR_EQUAL(s1, s2) (s1 && s2 && !strcmp (s1, s2))\n\nstatic inline bool arch_destroys_dst(const char *arch) {\n\treturn (STR_EQUAL (arch, \"arm\") || STR_EQUAL (arch, \"riscv\") || STR_EQUAL (arch, \"ppc\"));\n}\n\nstatic bool is_used_like_arg(const char *regname, const char *opsreg, const char *opdreg, RAnalOp *op, RAnal *anal) {\n\tRAnalValue *dst = op->dst;\n\tRAnalValue *src = op->src[0];\n\tswitch (op->type) {\n\tcase R_ANAL_OP_TYPE_POP:\n\t\treturn false;\n\tcase R_ANAL_OP_TYPE_MOV:\n\t\treturn (is_reg_in_src (regname, anal, op)) || (STR_EQUAL (opdreg, regname) && dst->memref);\n\tcase R_ANAL_OP_TYPE_CMOV:\n\t\tif (STR_EQUAL (opdreg, regname)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (is_reg_in_src (regname, anal, op)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\tcase R_ANAL_OP_TYPE_LEA:\n\tcase R_ANAL_OP_TYPE_LOAD:\n\t\tif (is_reg_in_src (regname, anal, op)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (STR_EQUAL (opdreg, regname)) {\n\t\t\treturn false;\n\t\t}\n    \t\treturn false;\n\tcase R_ANAL_OP_TYPE_XOR:\n\t\tif (STR_EQUAL (opsreg, opdreg) && !src->memref && !dst->memref) {\n\t\t\treturn false;\n\t\t}\n\t\t//fallthrough\n\tdefault:\n\t\tif (op_affect_dst (op) && arch_destroys_dst (anal->cur->arch)) {\n\t\t\tif (is_reg_in_src (regname, anal, op)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\treturn ((STR_EQUAL (opdreg, regname)) || (is_reg_in_src (regname, anal, op)));\n\t}\n}\n\nstatic bool is_reg_in_src(const char *regname, RAnal *anal, RAnalOp *op) {\n\tconst char* opsreg0 = op->src[0] ? get_regname (anal, op->src[0]) : NULL;\n\tconst char* opsreg1 = op->src[1] ? get_regname (anal, op->src[1]) : NULL;\n\tconst char* opsreg2 = op->src[2] ? get_regname (anal, op->src[2]) : NULL;\n\treturn (STR_EQUAL (regname, opsreg0)) || (STR_EQUAL (regname, opsreg1)) || (STR_EQUAL (regname, opsreg2));\n}\n\nR_API void r_anal_extract_rarg(RAnal *anal, RAnalOp *op, RAnalFunction *fcn, int *reg_set, int *count) {\n\tint i, argc = 0;\n\tr_return_if_fail (anal && op && fcn);\n\tconst char *opsreg = op->src[0] ? get_regname (anal, op->src[0]) : NULL;\n\tconst char *opdreg = op->dst ? get_regname (anal, op->dst) : NULL;\n\tconst int size = (fcn->bits ? fcn->bits : anal->bits) / 8;\n\tif (!fcn->cc) {\n\t\tR_LOG_DEBUG (\"No calling convention for function '%s' to extract register arguments\\n\", fcn->name);\n\t\treturn;\n\t}\n\tchar *fname = r_type_func_guess (anal->sdb_types, fcn->name);\n\tSdb *TDB = anal->sdb_types;\n\tint max_count = r_anal_cc_max_arg (anal, fcn->cc);\n\tif (!max_count || (*count >= max_count)) {\n\t\tfree (fname);\n\t\treturn;\n\t}\n\tif (fname) {\n\t\targc = r_type_func_args_count (TDB, fname);\n\t}\n\n\tbool is_call = (op->type & 0xf) == R_ANAL_OP_TYPE_CALL || (op->type & 0xf) == R_ANAL_OP_TYPE_UCALL;\n\tif (is_call && *count < max_count) {\n\t\tRList *callee_rargs_l = NULL;\n\t\tint callee_rargs = 0;\n\t\tchar *callee = NULL;\n\t\tut64 offset = op->jump == UT64_MAX ? op->ptr : op->jump;\n\t\tRAnalFunction *f = r_anal_get_function_at (anal, offset);\n\t\tif (!f) {\n\t\t\tRCore *core = (RCore *)anal->coreb.core;\n\t\t\tRFlagItem *flag = r_flag_get_by_spaces (core->flags, offset, R_FLAGS_FS_IMPORTS, NULL);\n\t\t\tif (flag) {\n\t\t\t\tcallee = r_type_func_guess (TDB, flag->name);\n\t\t\t\tif (callee) {\n\t\t\t\t\tconst char *cc = r_anal_cc_func (anal, callee);\n\t\t\t\t\tif (cc && !strcmp (fcn->cc, cc)) {\n\t\t\t\t\t\tcallee_rargs = R_MIN (max_count, r_type_func_args_count (TDB, callee));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (!f->is_variadic && !strcmp (fcn->cc, f->cc)) {\n\t\t\tcallee = r_type_func_guess (TDB, f->name);\n\t\t\tif (callee) {\n\t\t\t\tcallee_rargs = R_MIN (max_count, r_type_func_args_count (TDB, callee));\n\t\t\t}\n\t\t\tcallee_rargs = callee_rargs\n\t\t\t\t? callee_rargs\n\t\t\t\t: r_anal_var_count (anal, f, R_ANAL_VAR_KIND_REG, 1);\n\t\t\tcallee_rargs_l = r_anal_var_list (anal, f, R_ANAL_VAR_KIND_REG);\n\t\t}\n\t\tint i;\n\t\tfor (i = 0; i < callee_rargs; i++) {\n\t\t\tif (reg_set[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst char *vname = NULL;\n\t\t\tchar *type = NULL;\n\t\t\tchar *name = NULL;\n\t\t\tint delta = 0;\n\t\t\tconst char *regname = r_anal_cc_arg (anal, fcn->cc, i);\n\t\t\tRRegItem *ri = r_reg_get (anal->reg, regname, -1);\n\t\t\tif (ri) {\n\t\t\t\tdelta = ri->index;\n\t\t\t}\n\t\t\tif (fname) {\n\t\t\t\ttype = r_type_func_args_type (TDB, fname, i);\n\t\t\t\tvname = r_type_func_args_name (TDB, fname, i);\n\t\t\t}\n\t\t\tif (!vname && callee) {\n\t\t\t\ttype = r_type_func_args_type (TDB, callee, i);\n\t\t\t\tvname = r_type_func_args_name (TDB, callee, i);\n\t\t\t}\n\t\t\tif (vname) {\n\t\t\t\treg_set[i] = 1;\n\t\t\t} else {\n\t\t\t\tRListIter *it;\n\t\t\t\tRAnalVar *arg, *found_arg = NULL;\n\t\t\t\tr_list_foreach (callee_rargs_l, it, arg) {\n\t\t\t\t\tif (r_anal_var_get_argnum (arg) == i) {\n\t\t\t\t\t\tfound_arg = arg;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (found_arg) {\n\t\t\t\t\ttype = strdup (found_arg->type);\n\t\t\t\t\tvname = name = strdup (found_arg->name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!vname) {\n\t\t\t\tname = r_str_newf (\"arg%u\", (int)i + 1);\n\t\t\t\tvname = name;\n\t\t\t}\n\t\t\tr_anal_function_set_var (fcn, delta, R_ANAL_VAR_KIND_REG, type, size, true, vname);\n\t\t\t(*count)++;\n\t\t\tfree (name);\n\t\t\tfree (type);\n\t\t}\n\t\tfree (callee);\n\t\tr_list_free (callee_rargs_l);\n\t\tfree (fname);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < max_count; i++) {\n\t\tconst char *regname = r_anal_cc_arg (anal, fcn->cc, i);\n\t\tif (regname) {\n\t\t\tint delta = 0;\n\t\t\tRRegItem *ri = NULL;\n\t\t\tRAnalVar *var = NULL;\n\t\t\tbool is_used_like_an_arg = is_used_like_arg (regname, opsreg, opdreg, op, anal);\n\t\t\tif (reg_set[i] != 2 && is_used_like_an_arg) {\n\t\t\t\tri = r_reg_get (anal->reg, regname, -1);\n\t\t\t\tif (ri) {\n\t\t\t\t\tdelta = ri->index;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (reg_set[i] == 1 && is_used_like_an_arg) {\n\t\t\t\tvar = r_anal_function_get_var (fcn, R_ANAL_VAR_KIND_REG, delta);\n\t\t\t} else if (reg_set[i] != 2 && is_used_like_an_arg) {\n\t\t\t\tconst char *vname = NULL;\n\t\t\t\tchar *type = NULL;\n\t\t\t\tchar *name = NULL;\n\t\t\t\tif ((i < argc) && fname) {\n\t\t\t\t\ttype = r_type_func_args_type (TDB, fname, i);\n\t\t\t\t\tvname = r_type_func_args_name (TDB, fname, i);\n\t\t\t\t}\n\t\t\t\tif (!vname) {\n\t\t\t\t\tname = r_str_newf (\"arg%d\", i + 1);\n\t\t\t\t\tvname = name;\n\t\t\t\t}\n\t\t\t\tvar = r_anal_function_set_var (fcn, delta, R_ANAL_VAR_KIND_REG, type, size, true, vname);\n\t\t\t\tfree (name);\n\t\t\t\tfree (type);\n\t\t\t\t(*count)++;\n\t\t\t} else {\n\t\t\t\tif (is_reg_in_src (regname, anal, op) || STR_EQUAL (opdreg, regname)) {\n\t\t\t\t\treg_set[i] = 2;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (is_reg_in_src (regname, anal, op) || STR_EQUAL (regname, opdreg)) {\n\t\t\t\treg_set[i] = 1;\n\t\t\t}\n\t\t\tif (var) {\n\t\t\t\tr_anal_var_set_access (var, var->regname, op->addr, R_ANAL_VAR_ACCESS_TYPE_READ, 0);\n\t\t\t\tr_meta_set_string (anal, R_META_TYPE_VARTYPE, op->addr, var->name);\n\t\t\t}\n\t\t}\n\t}\n\n\tconst char *selfreg = r_anal_cc_self (anal, fcn->cc);\n\tif (selfreg) {\n\t\tbool is_used_like_an_arg = is_used_like_arg (selfreg, opsreg, opdreg, op, anal);\n\t\tif (reg_set[i] != 2 && is_used_like_an_arg) {\n\t\t\tint delta = 0;\n\t\t\tchar *vname = strdup (\"self\");\n\t\t\tRRegItem *ri = r_reg_get (anal->reg, selfreg, -1);\n\t\t\tif (ri) {\n\t\t\t\tdelta = ri->index;\n\t\t\t}\n\t\t\tRAnalVar *newvar = r_anal_function_set_var (fcn, delta, R_ANAL_VAR_KIND_REG, 0, size, true, vname);\n\t\t\tif (newvar) {\n\t\t\t\tr_anal_var_set_access (newvar, newvar->regname, op->addr, R_ANAL_VAR_ACCESS_TYPE_READ, 0);\n\t\t\t}\n\t\t\tr_meta_set_string (anal, R_META_TYPE_VARTYPE, op->addr, vname);\n\t\t\tfree (vname);\n\t\t\t(*count)++;\n\t\t} else {\n\t\t\tif (is_reg_in_src (selfreg, anal, op) || STR_EQUAL (opdreg, selfreg)) {\n\t\t\t\treg_set[i] = 2;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\n\tconst char *errorreg = r_anal_cc_error (anal, fcn->cc);\n\tif (errorreg) {\n\t\tif (reg_set[i] == 0 && STR_EQUAL (opdreg, errorreg)) {\n\t\t\tint delta = 0;\n\t\t\tchar *vname = strdup (\"error\");\n\t\t\tRRegItem *ri = r_reg_get (anal->reg, errorreg, -1);\n\t\t\tif (ri) {\n\t\t\t\tdelta = ri->index;\n\t\t\t}\n\t\t\tRAnalVar *newvar = r_anal_function_set_var (fcn, delta, R_ANAL_VAR_KIND_REG, 0, size, true, vname);\n\t\t\tif (newvar) {\n\t\t\t\tr_anal_var_set_access (newvar, newvar->regname, op->addr, R_ANAL_VAR_ACCESS_TYPE_READ, 0);\n\t\t\t}\n\t\t\tr_meta_set_string (anal, R_META_TYPE_VARTYPE, op->addr, vname);\n\t\t\tfree (vname);\n\t\t\t(*count)++;\n\t\t\treg_set[i] = 2;\n\t\t}\n\t}\n\tfree (fname);\n}\n\nR_API void r_anal_extract_vars(RAnal *anal, RAnalFunction *fcn, RAnalOp *op) {\n\tr_return_if_fail (anal && fcn && op);\n\n\tconst char *BP = anal->reg->name[R_REG_NAME_BP];\n\tif (BP) {\n\t\textract_arg (anal, fcn, op, BP, \"+\", R_ANAL_VAR_KIND_BPV);\n\t\textract_arg (anal, fcn, op, BP, \"-\", R_ANAL_VAR_KIND_BPV);\n\t}\n\tconst char *SP = anal->reg->name[R_REG_NAME_SP];\n\tif (SP) {\n\t\textract_arg (anal, fcn, op, SP, \"+\", R_ANAL_VAR_KIND_SPV);\n\t}\n}\n\nstatic RList *var_generate_list(RAnal *a, RAnalFunction *fcn, int kind) {\n\tif (!a || !fcn) {\n\t\treturn NULL;\n\t}\n\tRList *list = r_list_new ();\n\tif (kind < 1) {\n\t\tkind = R_ANAL_VAR_KIND_BPV; // by default show vars\n\t}\n\tif (fcn->vars.v.len > 0) {\n\t\tvoid **it;\n\t\tr_pvector_foreach (&fcn->vars, it) {\n\t\t\tRAnalVar *var = *it;\n\t\t\tif (var->kind == kind) {\n\t\t\t\tr_list_push (list, var);\n\t\t\t}\n\t\t}\n\t}\n\treturn list;\n}\n\nR_API RList *r_anal_var_all_list(RAnal *anal, RAnalFunction *fcn) {\n\t// r_anal_var_list if there are not vars with that kind returns a list with\n\t// zero element.. which is an unnecessary loss of cpu time\n\tRList *list = r_list_new ();\n\tif (!list) {\n\t\treturn NULL;\n\t}\n\tRList *reg_vars = r_anal_var_list (anal, fcn, R_ANAL_VAR_KIND_REG);\n\tRList *bpv_vars = r_anal_var_list (anal, fcn, R_ANAL_VAR_KIND_BPV);\n\tRList *spv_vars = r_anal_var_list (anal, fcn, R_ANAL_VAR_KIND_SPV);\n\tr_list_join (list, reg_vars);\n\tr_list_join (list, bpv_vars);\n\tr_list_join (list, spv_vars);\n\tr_list_free (reg_vars);\n\tr_list_free (bpv_vars);\n\tr_list_free (spv_vars);\n\treturn list;\n}\n\nR_API RList *r_anal_var_list(RAnal *a, RAnalFunction *fcn, int kind) {\n\treturn var_generate_list (a, fcn, kind);\n}\n\nstatic void var_field_free(RAnalVarField *field) {\n\tif (!field) {\n\t\treturn;\n\t}\n\tfree (field->name);\n\tfree (field);\n}\n\nR_API RList *r_anal_function_get_var_fields(RAnalFunction *fcn, int kind) {\n\tif (!fcn) {\n\t\treturn NULL;\n\t}\n\tRList *list = r_list_newf ((RListFree)var_field_free);\n\tif (kind < 1) {\n\t\tkind = R_ANAL_VAR_KIND_BPV; // by default show vars\n\t}\n\tvoid **it;\n\tr_pvector_foreach (&fcn->vars, it) {\n\t\tRAnalVar *var = *it;\n\t\tif (var->kind != kind) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (var_add_structure_fields_to_list (fcn->anal, var, list)) {\n\t\t\t// this var is a struct and var_add_structure_fields_to_list added all the fields\n\t\t\tcontinue;\n\t\t}\n\t\tRAnalVarField *field = R_NEW0 (RAnalVarField);\n\t\tif (!field) {\n\t\t\tbreak;\n\t\t}\n\t\tfield->name = strdup (var->name);\n\t\tif (!field->name) {\n\t\t\tvar_field_free (field);\n\t\t\tbreak;\n\t\t}\n\t\tfield->delta = var->delta;\n\t\tr_list_push (list, field);\n\t}\n\treturn list;\n}\n\nstatic int var_comparator(const RAnalVar *a, const RAnalVar *b){\n\t// avoid NULL dereference\n\treturn (a && b)? (a->delta > b->delta) - (a->delta < b->delta) : 0;\n}\n\nstatic int regvar_comparator(const RAnalVar *a, const RAnalVar *b){\n\t// avoid NULL dereference\n\treturn (a && b)? (a->argnum > b->argnum) - (a->argnum < b->argnum): 0;\n}\n\nR_API void r_anal_var_list_show(RAnal *anal, RAnalFunction *fcn, int kind, int mode, PJ *pj) {\n\tRList *list = r_anal_var_list (anal, fcn, kind);\n\tRAnalVar *var;\n\tRListIter *iter;\n\tif (!pj && mode == 'j') {\n\t\treturn;\n\t}\n\tif (mode == 'j') {\n\t\tpj_a (pj);\n\t}\n\tif (!list) {\n\t\tif (mode == 'j') {\n\t\t\tpj_end (pj);\n\t\t}\n\t\treturn;\n\t}\n\t//s- at the end of the loop\n\tif (mode == '*' && !r_list_empty (list)) {\n\t\tanal->cb_printf (\"s 0x%\" PFMT64x \"\\n\", fcn->addr);\n\t}\n\tr_list_sort (list, (RListComparator) var_comparator);\n\tr_list_foreach (list, iter, var) {\n\t\tif (var->kind != kind) {\n\t\t\tcontinue;\n\t\t}\n\t\tswitch (mode) {\n\t\tcase '*':\n\t\t\t// we can't express all type info here :(\n\t\t\tif (kind == R_ANAL_VAR_KIND_REG) { // registers\n\t\t\t\tRRegItem *i = r_reg_index_get (anal->reg, var->delta);\n\t\t\t\tif (!i) {\n\t\t\t\t\teprintf (\"Register not found\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tanal->cb_printf (\"\\\"afv%c %s %s %s\\\"\\n\",\n\t\t\t\t\tkind, i->name, var->name, var->type);\n\t\t\t} else {\n\t\t\t\tint delta = kind == R_ANAL_VAR_KIND_BPV\n\t\t\t\t\t? var->delta + fcn->bp_off\n\t\t\t\t\t: var->delta;\n\t\t\t\tanal->cb_printf (\"\\\"afv%c %d %s %s\\\"\\n\",\n\t\t\t\t\tkind, delta, var->name, var->type);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'j':\n\t\t\tswitch (var->kind) {\n\t\t\tcase R_ANAL_VAR_KIND_BPV: {\n\t\t\t\tst64 delta = (st64)var->delta + fcn->bp_off;\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_ks (pj, \"name\", var->name);\n\t\t\t\tif (var->isarg) {\n\t\t\t\t\tpj_ks (pj, \"kind\", \"arg\");\n\t\t\t\t} else {\n\t\t\t\t\tpj_ks (pj, \"kind\", \"var\");\n\t\t\t\t}\n\t\t\t\tpj_ks (pj, \"type\", var->type);\n\t\t\t\tpj_k (pj, \"ref\");\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_ks (pj, \"base\", anal->reg->name[R_REG_NAME_BP]);\n\t\t\t\tpj_kN (pj, \"offset\", delta);\n\t\t\t\tpj_end (pj);\n\t\t\t\tpj_end (pj);\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_VAR_KIND_REG: {\n\t\t\t\tRRegItem *i = r_reg_index_get (anal->reg, var->delta);\n\t\t\t\tif (!i) {\n\t\t\t\t\teprintf (\"Register not found\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_ks (pj, \"name\", var->name);\n\t\t\t\tpj_ks (pj, \"kind\", \"reg\");\n\t\t\t\tpj_ks (pj, \"type\", var->type);\n\t\t\t\tpj_ks (pj, \"ref\", i->name);\n\t\t\t\tpj_end (pj);\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_VAR_KIND_SPV: {\n\t\t\t\tst64 delta = (st64)var->delta + fcn->maxstack;\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_ks (pj, \"name\", var->name);\n\t\t\t\tif (var->isarg) {\n\t\t\t\t\tpj_ks (pj, \"kind\", \"arg\");\n\t\t\t\t} else {\t\t\t\t\n\t\t\t\t\tpj_ks (pj, \"kind\", \"var\");\t\t\t\n\t\t\t\t}\n\t\t\t\tpj_ks (pj, \"type\", var->type);\n\t\t\t\tpj_k (pj, \"ref\");\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_ks (pj, \"base\", anal->reg->name[R_REG_NAME_SP]);\n\t\t\t\tpj_kN (pj, \"offset\", delta);\n\t\t\t\tpj_end (pj);\n\t\t\t\tpj_end (pj);\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tswitch (kind) {\n\t\t\tcase R_ANAL_VAR_KIND_BPV:\n\t\t\t{\n\t\t\t\tint delta = var->delta + fcn->bp_off;\n\t\t\t\tif (var->isarg) {\n\t\t\t\t\tanal->cb_printf (\"arg %s %s @ %s+0x%x\\n\",\n\t\t\t\t\t\tvar->type, var->name,\n\t\t\t\t\t\tanal->reg->name[R_REG_NAME_BP],\n\t\t\t\t\t\tdelta);\n\t\t\t\t} else {\n\t\t\t\t\tchar sign = (-var->delta <= fcn->bp_off) ? '+' : '-';\n\t\t\t\t\tanal->cb_printf (\"var %s %s @ %s%c0x%x\\n\",\n\t\t\t\t\t\tvar->type, var->name,\n\t\t\t\t\t\tanal->reg->name[R_REG_NAME_BP],\n\t\t\t\t\t\tsign, R_ABS (delta));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_VAR_KIND_REG: {\n\t\t\t\tRRegItem *i = r_reg_index_get (anal->reg, var->delta);\n\t\t\t\tif (!i) {\n\t\t\t\t\teprintf (\"Register not found\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tanal->cb_printf (\"arg %s %s @ %s\\n\",\n\t\t\t\t\tvar->type, var->name, i->name);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_VAR_KIND_SPV:\n\t\t\t{\n\t\t\t\tint delta = fcn->maxstack + var->delta;\n\t\t\t\tif (!var->isarg) {\n\t\t\t\t\tchar sign = (-var->delta <= fcn->maxstack) ? '+' : '-';\n\t\t\t\t\tanal->cb_printf (\"var %s %s @ %s%c0x%x\\n\",\n\t\t\t\t\t\tvar->type, var->name,\n\t\t\t\t\t\tanal->reg->name[R_REG_NAME_SP],\n\t\t\t\t\t\tsign, R_ABS (delta));\n\t\t\t\t} else {\n\t\t\t\t\tanal->cb_printf (\"arg %s %s @ %s+0x%x\\n\",\n\t\t\t\t\t\tvar->type, var->name,\n\t\t\t\t\t\tanal->reg->name[R_REG_NAME_SP],\n\t\t\t\t\t\tdelta);\n\n\t\t\t\t}\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (mode == '*' && !r_list_empty (list)) {\n\t\tanal->cb_printf (\"s-\\n\");\n\t}\n\tif (mode == 'j') {\n\t\tpj_end (pj);\n\t}\n\tr_list_free (list);\n}\n\nR_API void r_anal_function_vars_cache_init(RAnal *anal, RAnalFcnVarsCache *cache, RAnalFunction *fcn) {\n\tcache->bvars = r_anal_var_list (anal, fcn, R_ANAL_VAR_KIND_BPV);\n\tcache->rvars = r_anal_var_list (anal, fcn, R_ANAL_VAR_KIND_REG);\n\tcache->svars = r_anal_var_list (anal, fcn, R_ANAL_VAR_KIND_SPV);\n\tr_list_sort (cache->bvars, (RListComparator)var_comparator);\n\tRListIter *it;\n\tRAnalVar *var;\n\tr_list_foreach (cache->rvars, it, var) {\n\t\tvar->argnum = r_anal_var_get_argnum (var);\n\t}\n\tr_list_sort (cache->rvars, (RListComparator)regvar_comparator);\n\tr_list_sort (cache->svars, (RListComparator)var_comparator);\n}\n\nR_API void r_anal_function_vars_cache_fini(RAnalFcnVarsCache *cache) {\n\tif (!cache) {\n\t\treturn;\n\t}\n\tr_list_free (cache->bvars);\n\tr_list_free (cache->rvars);\n\tr_list_free (cache->svars);\n}\n\nR_API char *r_anal_function_format_sig(R_NONNULL RAnal *anal, R_NONNULL RAnalFunction *fcn, R_NULLABLE char *fcn_name,\n\t\tR_NULLABLE RAnalFcnVarsCache *reuse_cache, R_NULLABLE const char *fcn_name_pre, R_NULLABLE const char *fcn_name_post) {\n\tRAnalFcnVarsCache *cache = NULL;\n\n\tif (!fcn_name) {\n\t\tfcn_name = fcn->name;\n\t\tif (!fcn_name) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tRStrBuf *buf = r_strbuf_new (NULL);\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\n\tSdb *TDB = anal->sdb_types;\n\tchar *type_fcn_name = r_type_func_guess (TDB, fcn_name);\n\tif (type_fcn_name && r_type_func_exist (TDB, type_fcn_name)) {\n\t\tconst char *fcn_type = r_type_func_ret (anal->sdb_types, type_fcn_name);\n\t\tif (R_STR_ISNOTEMPTY (fcn_type)) {\n\t\t\tconst char *sp = \" \";\n\t\t\tif (*fcn_type && (fcn_type[strlen (fcn_type) - 1] == '*')) {\n\t\t\t\tsp = \"\";\n\t\t\t}\n\t\t\tr_strbuf_appendf (buf, \"%s%s\", fcn_type, sp);\n\t\t}\n\t}\n\n\tif (fcn_name_pre) {\n\t\tr_strbuf_append (buf, fcn_name_pre);\n\t}\n\tr_strbuf_append (buf, fcn_name);\n\tif (fcn_name_post) {\n\t\tr_strbuf_append (buf, fcn_name_post);\n\t}\n\tr_strbuf_append (buf, \" (\");\n\n\tif (type_fcn_name && r_type_func_exist (TDB, type_fcn_name)) {\n\t\tint i, argc = r_type_func_args_count (TDB, type_fcn_name);\n\t\tbool comma = true;\n\t\t// This avoids false positives present in argument recovery\n\t\t// and straight away print arguments fetched from types db\n\t\tfor (i = 0; i < argc; i++) {\n\t\t\tchar *type = r_type_func_args_type (TDB, type_fcn_name, i);\n\t\t\tconst char *name = r_type_func_args_name (TDB, type_fcn_name, i);\n\t\t\tif (!type || !*type || !name) {\n\t\t\t\teprintf (\"Missing type for %s\\n\", type_fcn_name);\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (i == argc - 1) {\n\t\t\t\tcomma = false;\n\t\t\t}\n\t\t\tsize_t len = strlen (type);\n\t\t\tconst char *tc = len > 0 && type[len - 1] == '*'? \"\": \" \";\n\t\t\tr_strbuf_appendf (buf, \"%s%s%s%s\", type, tc, name, comma? \", \": \"\");\n\t\t\tfree (type);\n\t\t}\n\t\tgoto beach;\n\t}\n\tR_FREE (type_fcn_name);\n\n\n\tcache = reuse_cache;\n\tif (!cache) {\n\t\tcache = R_NEW0 (RAnalFcnVarsCache);\n\t\tif (!cache) {\n\t\t\ttype_fcn_name = NULL;\n\t\t\tgoto beach;\n\t\t}\n\t\tr_anal_function_vars_cache_init (anal, cache, fcn);\n\t}\n\n\tbool comma = true;\n\tbool arg_bp = false;\n\tsize_t tmp_len;\n\tRAnalVar *var;\n\tRListIter *iter;\n\n\tr_list_foreach (cache->rvars, iter, var) {\n\t\t// assume self, error are always the last\n\t\tif (!strcmp (var->name, \"self\") || !strcmp (var->name, \"error\")) {\n\t\t\tr_strbuf_slice (buf, 0, r_strbuf_length (buf) - 2);\n\t\t\tbreak;\n\t\t}\n\t\ttmp_len = strlen (var->type);\n\t\tif (tmp_len > 0) {\n\t\t\tr_strbuf_appendf (buf, \"%s%s%s%s\", var->type,\n\t\t\t\ttmp_len && var->type[tmp_len - 1] == '*' ? \"\" : \" \",\n\t\t\t\tvar->name, iter->n ? \", \" : \"\");\n\t\t}\n\t}\n\n\tr_list_foreach (cache->bvars, iter, var) {\n\t\tif (var->isarg) {\n\t\t\tif (!r_list_empty (cache->rvars) && comma) {\n\t\t\t\tr_strbuf_append (buf, \", \");\n\t\t\t\tcomma = false;\n\t\t\t}\n\t\t\targ_bp = true;\n\t\t\ttmp_len = strlen (var->type);\n\t\t\tif (tmp_len > 0) {\n\t\t\t\tr_strbuf_appendf (buf, \"%s%s%s%s\", var->type,\n\t\t\t\t\t\ttmp_len && var->type[tmp_len - 1] =='*' ? \"\" : \" \",\n\t\t\t\t\t\tvar->name, iter->n ? \", \" : \"\");\n\t\t\t}\n\t\t}\n\t}\n\n\tcomma = true;\n\tconst char *maybe_comma = \", \";\n\tr_list_foreach (cache->svars, iter, var) {\n\t\tif (var->isarg) {\n\t\t\tif (!*maybe_comma || ((arg_bp || !r_list_empty (cache->rvars)) && comma)) {\n\t\t\t\tcomma = false;\n\t\t\t\tr_strbuf_append (buf, \", \");\n\t\t\t}\n\t\t\ttmp_len = strlen (var->type);\n\t\t\tif (iter->n && ((RAnalVar *)iter->n->data)->isarg) {\n\t\t\t\tmaybe_comma = \", \";\n\t\t\t} else {\n\t\t\t\tmaybe_comma = \"\";\n\t\t\t}\n\t\t\tif (tmp_len > 0) {\n\t\t\t\tr_strbuf_appendf (buf, \"%s%s%s%s\", var->type,\n\t\t\t\t\ttmp_len && var->type[tmp_len - 1] == '*'? \"\": \" \",\n\t\t\t\t\tvar->name, maybe_comma);\n\t\t\t}\n\t\t}\n\t}\n\nbeach:\n\tr_strbuf_append (buf, \");\");\n\tR_FREE (type_fcn_name);\n\tif (!reuse_cache) {\n\t\t// !reuse_cache => we created our own cache\n\t\tr_anal_function_vars_cache_fini (cache);\n\t\tfree (cache);\n\t}\n\treturn r_strbuf_drain (buf);\n}\n"], "fixing_code": ["/* radare - LGPL - Copyright 2010-2021 - nibble, alvaro, pancake */\n\n#include <r_anal.h>\n#include <r_parse.h>\n#include <r_util.h>\n\n#define READ_AHEAD 1\n#define SDB_KEY_BB \"bb.0x%\"PFMT64x \".0x%\"PFMT64x\n// XXX must be configurable by the user\n#define JMPTBLSZ 512\n#define JMPTBL_LEA_SEARCH_SZ 64\n#define JMPTBL_MAXFCNSIZE 4096\n#define R_ANAL_MAX_INCSTACK 8096\n#define BB_ALIGN 0x10\n#define MAX_SCAN_SIZE 0x7ffffff\n\n/* speedup analysis by removing some function overlapping checks */\n#define JAYRO_04 1\n\n// 16 KB is the maximum size for a basic block\n#define MAX_FLG_NAME_SIZE 64\n\n#define FIX_JMP_FWD 0\n#define D if (a->verbose)\n\n// 64KB max size\n// 256KB max function size\n#define MAX_FCN_SIZE (1024 * 256)\n\n// Max NOP count to stop analysis\n#define MAX_NOP_PREFIX_CNT 1024\n\n#define DB a->sdb_fcns\n#define EXISTS(x, ...) snprintf (key, sizeof (key) - 1, x, ## __VA_ARGS__), sdb_exists (DB, key)\n#define SETKEY(x, ...) snprintf (key, sizeof (key) - 1, x, ## __VA_ARGS__);\n\nR_API const char *r_anal_functiontype_tostring(int type) {\n\tswitch (type) {\n\tcase R_ANAL_FCN_TYPE_NULL: return \"null\";\n\tcase R_ANAL_FCN_TYPE_FCN: return \"fcn\";\n\tcase R_ANAL_FCN_TYPE_LOC: return \"loc\";\n\tcase R_ANAL_FCN_TYPE_SYM: return \"sym\";\n\tcase R_ANAL_FCN_TYPE_IMP: return \"imp\";\n\tcase R_ANAL_FCN_TYPE_INT: return \"int\"; // interrupt\n\tcase R_ANAL_FCN_TYPE_ROOT: return \"root\";\n\t}\n\treturn \"unk\";\n}\n\n#if READ_AHEAD\nstatic ut64 cache_addr = UT64_MAX;\n\n// TODO: move into io :?\nstatic int read_ahead(RAnal *anal, ut64 addr, ut8 *buf, int len) {\n\tstatic ut8 cache[1024];\n\tconst int cache_len = sizeof (cache);\n\n\tif (len < 1) {\n\t\treturn 0;\n\t}\n\tif (len > cache_len) {\n\t\tint a = anal->iob.read_at (anal->iob.io, addr, buf, len); // double read\n\t\tmemcpy (cache, buf, cache_len);\n\t\tcache_addr = addr;\n\t\treturn a;\n\t}\n\n\tut64 addr_end = UT64_ADD_OVFCHK (addr, len)? UT64_MAX: addr + len;\n\tut64 cache_addr_end = UT64_ADD_OVFCHK (cache_addr, cache_len)? UT64_MAX: cache_addr + cache_len;\n\tbool isCached = ((addr != UT64_MAX) && (addr >= cache_addr) && (addr_end < cache_addr_end));\n\tif (isCached) {\n\t\tmemcpy (buf, cache + (addr - cache_addr), len);\n\t} else {\n\t\tanal->iob.read_at (anal->iob.io, addr, cache, sizeof (cache));\n\t\tmemcpy (buf, cache, len);\n\t\tcache_addr = addr;\n\t}\n\treturn len;\n}\n#else\nstatic int read_ahead(RAnal *anal, ut64 addr, ut8 *buf, int len) {\n\treturn anal->iob.read_at (anal->iob.io, addr, buf, len);\n}\n#endif\n\nR_API void r_anal_function_invalidate_read_ahead_cache(void) {\n#if READ_AHEAD\n\tcache_addr = UT64_MAX;\n#endif\n}\n\nstatic int cmpaddr(const void *_a, const void *_b) {\n\tconst RAnalBlock *a = _a, *b = _b;\n\treturn a->addr > b->addr ? 1 : (a->addr < b->addr ? -1 : 0);\n}\n\nR_API int r_anal_function_resize(RAnalFunction *fcn, int newsize) {\n\tRAnal *anal = fcn->anal;\n\tRAnalBlock *bb;\n\tRListIter *iter, *iter2;\n\n\tr_return_val_if_fail (fcn, false);\n\n\tif (newsize < 1) {\n\t\treturn false;\n\t}\n\n\t// XXX this is something we should probably do for all the archs\n\tbool is_arm = anal->cur->arch && !strncmp (anal->cur->arch, \"arm\", 3);\n\tif (is_arm) {\n\t\treturn true;\n\t}\n\n\tut64 eof = fcn->addr + newsize;\n\tr_list_foreach_safe (fcn->bbs, iter, iter2, bb) {\n\t\tif (bb->addr >= eof) {\n\t\t\tr_anal_function_remove_block (fcn, bb);\n\t\t\tcontinue;\n\t\t}\n\t\tif (bb->addr + bb->size >= eof) {\n\t\t\tr_anal_block_set_size (bb, eof - bb->addr);\n\t\t\tr_anal_block_update_hash (bb);\n\t\t}\n\t\tif (bb->jump != UT64_MAX && bb->jump >= eof) {\n\t\t\tbb->jump = UT64_MAX;\n\t\t}\n\t\tif (bb->fail != UT64_MAX && bb->fail >= eof) {\n\t\t\tbb->fail = UT64_MAX;\n\t\t}\n\t}\n\treturn true;\n}\n\n// Create a new 0-sized basic block inside the function\nstatic RAnalBlock *fcn_append_basic_block(RAnal *anal, RAnalFunction *fcn, ut64 addr) {\n\tRAnalBlock *bb = r_anal_create_block (anal, addr, 0);\n\tif (!bb) {\n\t\treturn NULL;\n\t}\n\tr_anal_function_add_block (fcn, bb);\n\tbb->stackptr = fcn->stack;\n\tbb->parent_stackptr = fcn->stack;\n\treturn bb;\n}\n\n#define gotoBeach(x) ret = x; goto beach;\n\nstatic bool is_invalid_memory(RAnal *anal, const ut8 *buf, int len) {\n\tif (anal->opt.nonull > 0) {\n\t\tint i;\n\t\tconst int count = R_MIN (len, anal->opt.nonull);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tif (buf[i]) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == count) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn !memcmp (buf, \"\\xff\\xff\\xff\\xff\", R_MIN (len, 4));\n}\n\nstatic bool is_symbol_flag(const char *name) {\n\treturn strstr (name, \"imp.\")\n\t\t|| strstr (name, \"dbg.\")\n\t\t|| strstr (name, \"sym.\")\n\t\t|| !strncmp (name, \"entry\", 5)\n\t\t|| !strcmp (name, \"main\");\n}\n\nstatic bool next_instruction_is_symbol(RAnal *anal, RAnalOp *op) {\n\tr_return_val_if_fail (anal && op && anal->flb.get_at, false);\n\tRFlagItem *fi = anal->flb.get_at (anal->flb.f, op->addr + op->size, false);\n\treturn (fi && fi->name && is_symbol_flag (fi->name));\n}\n\nstatic bool is_delta_pointer_table(RAnal *anal, RAnalFunction *fcn, ut64 addr, ut64 lea_ptr, ut64 *jmptbl_addr, ut64 *casetbl_addr, RAnalOp *jmp_aop) {\n\tint i;\n\tut64 dst;\n\tst32 jmptbl[64] = {0};\n\t/* check if current instruction is followed by an ujmp */\n\tut8 buf[JMPTBL_LEA_SEARCH_SZ];\n\tRAnalOp *aop = jmp_aop;\n\tRAnalOp omov_aop = {0};\n\tRAnalOp mov_aop = {0};\n\tRAnalOp add_aop = {0};\n\tRRegItem *reg_src = NULL, *o_reg_dst = NULL;\n\tRAnalValue cur_scr, cur_dst = {0};\n\tread_ahead (anal, addr, (ut8*)buf, sizeof (buf));\n\tbool isValid = false;\n\tfor (i = 0; i + 8 < JMPTBL_LEA_SEARCH_SZ; i++) {\n\t\tut64 at = addr + i;\n\t\tint left = JMPTBL_LEA_SEARCH_SZ - i;\n\t\tint len = r_anal_op (anal, aop, at, buf + i, left, R_ANAL_OP_MASK_BASIC | R_ANAL_OP_MASK_HINT | R_ANAL_OP_MASK_VAL);\n\t\tif (len < 1) {\n\t\t\tlen = 1;\n\t\t}\n\t\tif (aop->type == R_ANAL_OP_TYPE_UJMP || aop->type == R_ANAL_OP_TYPE_RJMP) {\n\t\t\tisValid = true;\n\t\t\tbreak;\n\t\t}\n\t\tif (aop->type == R_ANAL_OP_TYPE_JMP || aop->type == R_ANAL_OP_TYPE_CJMP) {\n\t\t\tbreak;\n\t\t}\n\t\tif (aop->type == R_ANAL_OP_TYPE_MOV) {\n\t\t\tomov_aop = mov_aop;\n\t\t\tmov_aop = *aop;\n\t\t\to_reg_dst = cur_dst.reg;\n\t\t\tif (mov_aop.dst) {\n\t\t\t\tcur_dst = *mov_aop.dst;\n\t\t\t}\n\t\t\tif (mov_aop.src[0]) {\n\t\t\t\tcur_scr = *mov_aop.src[0];\n\t\t\t\treg_src = cur_scr.regdelta;\n\t\t\t}\n\t\t}\n\t\tif (aop->type == R_ANAL_OP_TYPE_ADD) {\n\t\t\tadd_aop = *aop;\n\t\t}\n\t\tr_anal_op_fini (aop);\n\t\ti += len - 1;\n\t}\n\tif (!isValid) {\n\t\treturn false;\n\t}\n\n\t// check if we have a msvc 19xx style jump table using rva table entries\n\t// lea reg1, [base_addr]\n\t// mov reg2, dword [reg1 + tbl_off*4 + tbl_loc_off]\n\t// add reg2, reg1\n\t// jmp reg2\n\tif (mov_aop.type && add_aop.type && mov_aop.addr < add_aop.addr && add_aop.addr < jmp_aop->addr\n\t    && mov_aop.disp && mov_aop.disp != UT64_MAX) {\n\t\t// disp in this case should be tbl_loc_off\n\t\t*jmptbl_addr += mov_aop.disp;\n\t\tif (o_reg_dst && reg_src && o_reg_dst->offset == reg_src->offset && omov_aop.disp != UT64_MAX) {\n\t\t\t// Special case for indirection\n\t\t\t// lea reg1, [base_addr]\n\t\t\t// movzx reg2, byte [reg1 + tbl_off + casetbl_loc_off]\n\t\t\t// mov reg3, dword [reg1 + reg2*4 + tbl_loc_off]\n\t\t\t// add reg3, reg1\n\t\t\t// jmp reg3\n\t\t\t*casetbl_addr += omov_aop.disp;\n\t\t}\n\t}\n#if 0\n\t// required for the last jmptbl.. but seems to work without it and breaks other tests\n\tif (mov_aop.type && mov_aop.ptr) {\n\t\t*jmptbl_addr += mov_aop.ptr;\n\t\t// absjmptbl\n\t\tlea_ptr = mov_aop.ptr;\n\t}\n#endif\n\t/* check if jump table contains valid deltas */\n\tread_ahead (anal, *jmptbl_addr, (ut8 *)&jmptbl, 64);\n\tfor (i = 0; i < 3; i++) {\n\t\tdst = lea_ptr + (st32)r_read_le32 (jmptbl);\n\t\tif (!anal->iob.is_valid_offset (anal->iob.io, dst, 0)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (dst > fcn->addr + JMPTBL_MAXFCNSIZE) {\n\t\t\treturn false;\n\t\t}\n\t\tif (anal->opt.jmpabove && dst < (fcn->addr < JMPTBL_MAXFCNSIZE ? 0 : fcn->addr - JMPTBL_MAXFCNSIZE)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic ut64 try_get_cmpval_from_parents(RAnal *anal, RAnalFunction *fcn, RAnalBlock *my_bb, const char *cmp_reg) {\n\tif (!cmp_reg) {\n\t\tif (anal->verbose) {\n\t\t\teprintf (\"try_get_cmpval_from_parents: cmp_reg not defined.\\n\");\n\t\t}\n\t\treturn UT64_MAX;\n\t}\n\tr_return_val_if_fail (fcn && fcn->bbs, UT64_MAX);\n\tRListIter *iter;\n\tRAnalBlock *tmp_bb;\n\tr_list_foreach (fcn->bbs, iter, tmp_bb) {\n\t\tif (tmp_bb->jump == my_bb->addr || tmp_bb->fail == my_bb->addr) {\n\t\t\tif (tmp_bb->cmpreg == cmp_reg) {\n\t\t\t\tif (tmp_bb->cond) {\n\t\t\t\t\tif (tmp_bb->cond->type == R_ANAL_COND_HI || tmp_bb->cond->type == R_ANAL_COND_GT) {\n\t\t\t\t\t\treturn tmp_bb->cmpval + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn tmp_bb->cmpval;\n\t\t\t}\n\t\t}\n\t}\n\treturn UT64_MAX;\n}\n\nstatic bool regs_exist(RAnalValue *src, RAnalValue *dst) {\n\tr_return_val_if_fail (src && dst, false);\n\treturn src->reg && dst->reg && src->reg->name && dst->reg->name;\n}\n\n// 0 if not skipped; 1 if skipped; 2 if skipped before\nstatic int skip_hp(RAnal *anal, RAnalFunction *fcn, RAnalOp *op, RAnalBlock *bb, ut64 addr, int oplen, int un_idx, int *idx) {\n\t// this step is required in order to prevent infinite recursion in some cases\n\tif ((addr + un_idx - oplen) == fcn->addr) {\n\t\t// use addr instead of op->addr to mark repeat\n\t\tif (!anal->flb.exist_at (anal->flb.f, \"skip\", 4, addr)) {\n\t\t\tchar *name = r_str_newf (\"skip.%\"PFMT64x,  addr);\n\t\t\tanal->flb.set (anal->flb.f, name, addr, oplen);\n\t\t\tfree (name);\n\t\t\tfcn->addr += oplen;\n\t\t\tr_anal_block_relocate (bb, bb->addr + oplen, bb->size - oplen);\n\t\t\t*idx = un_idx;\n\t\t\treturn 1;\n\t\t}\n\t\treturn 2;\n\t}\n\treturn 0;\n}\n\nstatic bool purity_checked(HtUP *ht, RAnalFunction *fcn) {\n\tbool checked;\n\tht_up_find (ht, fcn->addr, &checked);\n\treturn checked;\n}\n\n/*\n * Checks whether a given function is pure and sets its 'is_pure' field.\n * This function marks fcn 'not pure' if fcn, or any function called by fcn, accesses data\n * from outside, even if it only READS it.\n * Probably worth changing it in the future, so that it marks fcn 'impure' only when it\n * (or any function called by fcn) MODIFIES external data.\n */\nstatic void check_purity(HtUP *ht, RAnalFunction *fcn) {\n\tRListIter *iter;\n\tRList *refs = r_anal_function_get_refs (fcn);\n\tRAnalRef *ref;\n\tht_up_insert (ht, fcn->addr, NULL);\n\tfcn->is_pure = true;\n\tr_list_foreach (refs, iter, ref) {\n\t\tif (ref->type == R_ANAL_REF_TYPE_CALL || ref->type == R_ANAL_REF_TYPE_CODE) {\n\t\t\tRAnalFunction *called_fcn = r_anal_get_fcn_in (fcn->anal, ref->addr, 0);\n\t\t\tif (!called_fcn) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!purity_checked (ht, called_fcn)) {\n\t\t\t\tcheck_purity (ht, called_fcn);\n\t\t\t}\n\t\t\tif (!called_fcn->is_pure) {\n\t\t\t\tfcn->is_pure = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ref->type == R_ANAL_REF_TYPE_DATA) {\n\t\t\tfcn->is_pure = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tr_list_free (refs);\n}\n\ntypedef struct {\n\tut64 op_addr;\n\tut64 leaddr;\n\tchar *reg;\n} leaddr_pair;\n\nstatic void free_leaddr_pair(void *pair) {\n\tleaddr_pair *_pair = pair;\n\tfree (_pair->reg);\n\tfree (_pair);\n}\n\nstatic RAnalBlock *bbget(RAnal *anal, ut64 addr, bool jumpmid) {\n\tRList *intersecting = r_anal_get_blocks_in (anal, addr);\n\tRListIter *iter;\n\tRAnalBlock *bb;\n\n\tRAnalBlock *ret = NULL;\n\tr_list_foreach (intersecting, iter, bb) {\n\t\tut64 eaddr = bb->addr + bb->size;\n\t\tif (((bb->addr >= eaddr && addr == bb->addr)\n\t\t     || r_anal_block_contains (bb, addr))\n\t\t    && (!jumpmid || r_anal_block_op_starts_at (bb, addr))) {\n\t\t\tif (anal->opt.delay) {\n\t\t\t\tut8 *buf = malloc (bb->size);\n\t\t\t\tif (anal->iob.read_at (anal->iob.io, bb->addr, buf, bb->size)) {\n\t\t\t\t\tconst int last_instr_idx = bb->ninstr - 1;\n\t\t\t\t\tbool in_delay_slot = false;\n\t\t\t\t\tint i;\n\t\t\t\t\tfor (i = last_instr_idx; i >= 0; i--) {\n\t\t\t\t\t\tconst ut64 off = r_anal_bb_offset_inst (bb, i);\n\t\t\t\t\t\tconst ut64 at = bb->addr + off;\n\t\t\t\t\t\tif (addr <= at || off >= bb->size) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tRAnalOp op;\n\t\t\t\t\t\tint size = r_anal_op (anal, &op, at, buf + off, bb->size - off, R_ANAL_OP_MASK_BASIC);\n\t\t\t\t\t\tif (size > 0 && op.delay) {\n\t\t\t\t\t\t\tif (op.delay >= last_instr_idx - i) {\n\t\t\t\t\t\t\t\tin_delay_slot = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tr_anal_op_fini (&op);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_anal_op_fini (&op);\n\t\t\t\t\t}\n\t\t\t\t\tif (in_delay_slot) {\n\t\t\t\t\t\tfree (buf);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (buf);\n\t\t\t}\n\t\t\tret = bb;\n\t\t\tbreak;\n\t\t}\n\t}\n\tr_list_free (intersecting);\n\treturn ret;\n}\n\ntypedef struct {\n\tRAnalFunction *fcn;\n\tconst int stack_diff;\n} BlockTakeoverCtx;\n\nstatic bool fcn_takeover_block_recursive_followthrough_cb(RAnalBlock *block, void *user) {\n\tBlockTakeoverCtx *ctx = user;\n\tRAnalFunction *our_fcn = ctx->fcn;\n\tr_anal_block_ref (block);\n\twhile (!r_list_empty (block->fcns)) {\n\t\tRAnalFunction *other_fcn = r_list_first (block->fcns);\n\t\tif (other_fcn->addr == block->addr) {\n\t\t\treturn false;\n\t\t}\n\t\t// Steal vars from this block\n\t\tsize_t i;\n\t\tfor (i = 0; i < block->ninstr; i++) {\n\t\t\tconst ut64 addr = r_anal_bb_opaddr_i (block, i);\n\t\t\tRPVector *vars_used = r_anal_function_get_vars_used_at (other_fcn, addr);\n\t\t\tif (!vars_used) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// vars_used will get modified if r_anal_var_remove_access_at gets called\n\t\t\tRPVector *cloned_vars_used = (RPVector *)r_vector_clone ((RVector *)vars_used);\n\t\t\tvoid **it;\n\t\t\tr_pvector_foreach (cloned_vars_used, it) {\n\t\t\t\tRAnalVar *other_var = *it;\n\t\t\t\tconst int actual_delta = other_var->kind == R_ANAL_VAR_KIND_SPV\n\t\t\t\t\t? other_var->delta + ctx->stack_diff\n\t\t\t\t\t: other_var->delta + (other_fcn->bp_off - our_fcn->bp_off);\n\t\t\t\tRAnalVar *our_var = r_anal_function_get_var (our_fcn, other_var->kind, actual_delta);\n\t\t\t\tif (!our_var) {\n\t\t\t\t\tour_var = r_anal_function_set_var (our_fcn, actual_delta, other_var->kind, other_var->type, 0, other_var->isarg, other_var->name);\n\t\t\t\t}\n\t\t\t\tif (our_var) {\n\t\t\t\t\tRAnalVarAccess *acc = r_anal_var_get_access_at (other_var, addr);\n\t\t\t\t\tr_anal_var_set_access (our_var, acc->reg, addr, acc->type, acc->stackptr);\n\t\t\t\t}\n\t\t\t\tr_anal_var_remove_access_at (other_var, addr);\n\t\t\t\tif (r_vector_empty (&other_var->accesses)) {\n\t\t\t\t\tr_anal_function_delete_var (other_fcn, other_var);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_pvector_free (cloned_vars_used);\n\t\t}\n\n\t\t// TODO: remove block->ninstr from other_fcn considering delay slots\n\t\tr_anal_function_remove_block (other_fcn, block);\n\t}\n\tblock->stackptr -= ctx->stack_diff;\n\tblock->parent_stackptr -= ctx->stack_diff;\n\tr_anal_function_add_block (our_fcn, block);\n\t// TODO: add block->ninstr from our_fcn considering delay slots\n\tr_anal_block_unref (block);\n\treturn true;\n}\n\n// Remove block and all of its recursive successors from all its functions and add them only to fcn\nstatic void fcn_takeover_block_recursive(RAnalFunction *fcn, RAnalBlock *start_block) {\n\tBlockTakeoverCtx ctx = { fcn, start_block->parent_stackptr - fcn->stack};\n\tr_anal_block_recurse_followthrough (start_block, fcn_takeover_block_recursive_followthrough_cb, &ctx);\n}\n\nstatic const char *retpoline_reg(RAnal *anal, ut64 addr) {\n\tRFlagItem *flag = anal->flag_get (anal->flb.f, addr);\n\tif (flag) {\n\t\tconst char *token = \"x86_indirect_thunk_\";\n\t\tconst char *thunk = strstr (flag->name, token);\n\t\tif (thunk) {\n\t\t\treturn thunk + strlen (token);\n\t\t}\n\t}\n#if 0\n// TODO: implement following code analysis check for stripped binaries:\n// 1) op(addr).type == CALL\n// 2) call_dest = op(addr).addr\n// 3) op(call_dest).type == STORE\n// 4) op(call_dest + op(call_dest).size).type == RET\n[0x00000a65]> pid 6\n0x00000a65  sym.__x86_indirect_thunk_rax:\n0x00000a65  .------- e807000000  call 0xa71\n0x00000a6a  |              f390  pause\n0x00000a6c  |            0faee8  lfence\n0x00000a6f  |              ebf9  jmp 0xa6a\n0x00000a71  `---->     48890424  mov qword [rsp], rax\n0x00000a75                   c3  ret\n#endif\n\treturn NULL;\n}\n\nstatic void analyze_retpoline(RAnal *anal, RAnalOp *op) {\n\tif (anal->opt.retpoline) {\n\t\tconst char *rr = retpoline_reg (anal, op->jump);\n\t\tif (rr) {\n\t\t\top->type = R_ANAL_OP_TYPE_RJMP;\n\t\t\top->reg = rr;\n\t\t}\n\t}\n}\n\nstatic inline bool op_is_set_bp(const char *op_dst, const char *op_src, const char *bp_reg, const char *sp_reg) {\n\tif (op_dst && op_src) {\n\t\treturn !strcmp (bp_reg, op_dst) && !strcmp (sp_reg, op_src);\n\t}\n\treturn false;\n}\n\nstatic inline bool does_arch_destroys_dst(const char *arch) {\n\treturn arch && (!strncmp (arch, \"arm\", 3) || !strcmp (arch, \"riscv\") || !strcmp (arch, \"ppc\"));\n}\n\nstatic inline bool has_vars(RAnal *anal, ut64 addr) {\n\tRAnalFunction *tmp_fcn = r_anal_get_fcn_in (anal, addr, 0);\n\tif (tmp_fcn) {\n\t\treturn r_anal_var_count_all (tmp_fcn) > 0;\n\t}\n\treturn false;\n}\n\nstatic int fcn_recurse(RAnal *anal, RAnalFunction *fcn, ut64 addr, ut64 len, int depth) {\n\tchar *bp_reg = NULL;\n\tchar *sp_reg = NULL;\n\tchar *op_dst = NULL;\n\tchar *op_src = NULL;\n\tif (depth < 1) {\n\t\tif (anal->verbose) {\n\t\t\teprintf (\"Too deep fcn_recurse at 0x%\"PFMT64x \"\\n\", addr);\n\t\t}\n\t\treturn R_ANAL_RET_ERROR; // MUST BE TOO DEEP\n\t}\n\t// TODO Store all this stuff in the heap so we save memory in the stack\n\tRAnalOp *op = NULL;\n\tchar *movbasereg = NULL;\n\tconst int addrbytes = anal->iob.io ? anal->iob.io->addrbytes : 1;\n\tchar *last_reg_mov_lea_name = NULL;\n\tRAnalBlock *bb = NULL;\n\tRAnalBlock *bbg = NULL;\n\tint ret = R_ANAL_RET_END, skip_ret = 0;\n\tbool overlapped = false;\n\tint oplen, idx = 0;\n\tsize_t lea_cnt = 0;\n\tsize_t nop_prefix_cnt = 0;\n\tstatic ut64 cmpval = UT64_MAX; // inherited across functions, otherwise it breaks :?\n\tstruct {\n\t\tint cnt;\n\t\tint idx;\n\t\tint after;\n\t\tint pending;\n\t\tint adjust;\n\t\tint un_idx; // delay.un_idx\n\t} delay = {\n\t\t0\n\t};\n\tbool arch_destroys_dst = does_arch_destroys_dst (anal->cur->arch);\n\tconst bool is_arm = anal->cur->arch && !strncmp (anal->cur->arch, \"arm\", 3);\n\tconst bool is_v850 = is_arm ? false: (anal->cur->arch && (!strncmp (anal->cur->arch, \"v850\", 4) || !strncmp (anal->coreb.cfgGet (anal->coreb.core, \"asm.cpu\"), \"v850\", 4)));\n\tconst bool is_x86 = is_arm ? false: anal->cur->arch && !strncmp (anal->cur->arch, \"x86\", 3);\n\tconst bool is_amd64 = is_x86 ? fcn->cc && !strcmp (fcn->cc, \"amd64\") : false;\n\tconst bool is_dalvik = is_x86 ? false : anal->cur->arch && !strncmp (anal->cur->arch, \"dalvik\", 6);\n\tRRegItem *variadic_reg = NULL;\n\tif (is_amd64) {\n\t\tvariadic_reg = r_reg_get (anal->reg, \"rax\", R_REG_TYPE_GPR);\n\t}\n\tbool has_variadic_reg = !!variadic_reg;\n\n\tif (r_cons_is_breaked ()) {\n\t\treturn R_ANAL_RET_END;\n\t}\n\tif (anal->sleep) {\n\t\tr_sys_usleep (anal->sleep);\n\t}\n\n\t// check if address is readable //:\n\tif (!anal->iob.is_valid_offset (anal->iob.io, addr, 0)) {\n\t\tif (addr != UT64_MAX && !anal->iob.io->va) {\n\t\t\tif (anal->verbose) {\n\t\t\t\teprintf (\"Invalid address 0x%\"PFMT64x \". Try with io.va=true\\n\", addr);\n\t\t\t}\n\t\t}\n\t\treturn R_ANAL_RET_ERROR; // MUST BE TOO DEEP\n\t}\n\n\tRAnalFunction *fcn_at_addr = r_anal_get_function_at (anal, addr);\n\tif (fcn_at_addr && fcn_at_addr != fcn) {\n\t\treturn R_ANAL_RET_ERROR; // MUST BE NOT FOUND\n\t}\n\n\tRAnalBlock *existing_bb = bbget (anal, addr, anal->opt.jmpmid && is_x86);\n\tif (existing_bb) {\n\t\tbool existing_in_fcn = r_list_contains (existing_bb->fcns, fcn);\n\t\texisting_bb = r_anal_block_split (existing_bb, addr);\n\t\tif (!existing_in_fcn && existing_bb) {\n\t\t\tif (existing_bb->addr == fcn->addr) {\n\t\t\t\t// our function starts directly there, so we steal what is ours!\n\t\t\t\tfcn_takeover_block_recursive (fcn, existing_bb);\n\t\t\t}\n\t\t}\n\t\tif (existing_bb) {\n\t\t\tr_anal_block_unref (existing_bb);\n\t\t}\n\t\tif (anal->opt.recont) {\n\t\t\treturn R_ANAL_RET_END;\n\t\t}\n\t\tif (anal->verbose) {\n\t\t\teprintf (\"r_anal_function_bb() fails at 0x%\"PFMT64x \"\\n\", addr);\n\t\t}\n\t\treturn R_ANAL_RET_ERROR; // MUST BE NOT DUP\n\t}\n\n\tbb = fcn_append_basic_block (anal, fcn, addr);\n\t// we checked before whether there is a bb at addr, so the create should have succeeded\n\tr_return_val_if_fail (bb, R_ANAL_RET_ERROR);\n\n\tif (!anal->leaddrs) {\n\t\tanal->leaddrs = r_list_newf (free_leaddr_pair);\n\t\tif (!anal->leaddrs) {\n\t\t\teprintf (\"Cannot create leaddr list\\n\");\n\t\t\tgotoBeach (R_ANAL_RET_ERROR);\n\t\t}\n\t}\n\tstatic ut64 lea_jmptbl_ip = UT64_MAX;\n\tut64 last_reg_mov_lea_val = UT64_MAX;\n\tbool last_is_reg_mov_lea = false;\n\tbool last_is_push = false;\n\tbool last_is_mov_lr_pc = false;\n\tut64 last_push_addr = UT64_MAX;\n\tif (anal->limit && addr + idx < anal->limit->from) {\n\t\tgotoBeach (R_ANAL_RET_END);\n\t}\n\n\tbool varset = has_vars (anal, addr); // Checks if var is already analyzed at given addr\n\n\tut64 movdisp = UT64_MAX; // used by jmptbl when coded as \"mov Reg,[Reg*Scale+Disp]\"\n\tut64 movscale = 0;\n\tint maxlen = len * addrbytes;\n\tif (is_dalvik) {\n\t\tbool skipAnalysis = false;\n\t\tif (!strncmp (fcn->name, \"sym.\", 4)) {\n\t\t\tif (!strncmp (fcn->name + 4, \"imp.\", 4)) {\n\t\t\t\tskipAnalysis = true;\n\t\t\t} else if (strstr (fcn->name, \"field\")) {\n\t\t\t\tskipAnalysis = true;\n\t\t\t}\n\t\t}\n\t\tif (skipAnalysis) {\n\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t}\n\t}\n\tif ((maxlen - (addrbytes * idx)) > MAX_SCAN_SIZE) {\n\t\tif (anal->verbose) {\n\t\t\teprintf (\"Warning: Skipping large memory region.\\n\");\n\t\t}\n\t\tmaxlen = 0;\n\t}\n\tconst char *_bp_reg = anal->reg->name[R_REG_NAME_BP];\n\tconst char *_sp_reg = anal->reg->name[R_REG_NAME_SP];\n\tconst bool has_stack_regs = _bp_reg && _sp_reg;\n\tif (has_stack_regs) {\n\t\tbp_reg = strdup (_bp_reg);\n\t\tsp_reg = strdup (_sp_reg);\n\t}\n\n\top = r_anal_op_new ();\n\twhile (addrbytes * idx < maxlen) {\n\t\tif (!last_is_reg_mov_lea) {\n\t\t\tfree (last_reg_mov_lea_name);\n\t\t\tlast_reg_mov_lea_name = NULL;\n\t\t}\n\t\tif (anal->limit && anal->limit->to <= addr + idx) {\n\t\t\tbreak;\n\t\t}\nrepeat:\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\tut8 buf[32]; // 32 bytes is enough to hold any instruction.\n\t\tut32 at_delta = addrbytes * idx;\n\t\tut64 at = addr + at_delta;\n\t\tut64 bytes_read = R_MIN (len - at_delta, sizeof (buf));\n\t\tret = read_ahead (anal, at, buf, bytes_read);\n\n\t\tif (ret < 0) {\n\t\t\teprintf (\"Failed to read\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (is_invalid_memory (anal, buf, bytes_read)) {\n\t\t\tif (anal->verbose) {\n\t\t\t\teprintf (\"Warning: FFFF opcode at 0x%08\"PFMT64x \"\\n\", at);\n\t\t\t}\n\t\t\tgotoBeach (R_ANAL_RET_ERROR)\n\t\t}\n\t\tr_anal_op_fini (op);\n\t\tif ((oplen = r_anal_op (anal, op, at, buf, bytes_read, R_ANAL_OP_MASK_ESIL | R_ANAL_OP_MASK_VAL | R_ANAL_OP_MASK_HINT)) < 1) {\n\t\t\tif (anal->verbose) {\n\t\t\t\teprintf (\"Invalid instruction at 0x%\"PFMT64x\" with %d bits\\n\", at, anal->bits);\n\t\t\t}\n\t\t\t// gotoBeach (R_ANAL_RET_ERROR);\n\t\t\t// RET_END causes infinite loops somehow\n\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t}\n\t\tfree (op_dst);\n\t\top_dst = (op->dst && op->dst->reg && op->dst->reg->name)? strdup (op->dst->reg->name): NULL;\n\t\tfree (op_src);\n\t\top_src = (op->src[0] && op->src[0]->reg && op->src[0]->reg->name) ? strdup (op->src[0]->reg->name): NULL;\n\n\t\tif (anal->opt.nopskip && fcn->addr == at) {\n\t\t\tRFlagItem *fi = anal->flb.get_at (anal->flb.f, addr, false);\n\t\t\tif (!fi || strncmp (fi->name, \"sym.\", 4)) {\n\t\t\t\tif ((addr + delay.un_idx - oplen) == fcn->addr) {\n\t\t\t\t\tif (r_anal_block_relocate (bb, bb->addr + oplen, bb->size - oplen)) {\n\t\t\t\t\t\tfcn->addr += oplen;\n\t\t\t\t\t\tidx = delay.un_idx;\n\t\t\t\t\t\tgoto repeat;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch (op->type & R_ANAL_OP_TYPE_MASK) {\n\t\t\tcase R_ANAL_OP_TYPE_TRAP:\n\t\t\tcase R_ANAL_OP_TYPE_ILL:\n\t\t\tcase R_ANAL_OP_TYPE_NOP:\n\t\t\t\tnop_prefix_cnt++;\n\t\t\t\tif (nop_prefix_cnt > MAX_NOP_PREFIX_CNT) {\n\t\t\t\t\tgotoBeach (R_ANAL_RET_ERROR);\n\t\t\t\t}\n\t\t\t\tif (r_anal_block_relocate (bb, at + op->size, bb->size)) {\n\t\t\t\t\taddr = at + op->size;\n\t\t\t\t\tfcn->addr = addr;\n\t\t\t\t\tgoto repeat;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (op->hint.new_bits) {\n\t\t\tr_anal_hint_set_bits (anal, op->jump, op->hint.new_bits);\n\t\t}\n\t\tif (idx > 0 && !overlapped) {\n\t\t\tbbg = bbget (anal, at, anal->opt.jmpmid && is_x86);\n\t\t\tif (bbg && bbg != bb) {\n\t\t\t\tbb->jump = at;\n\t\t\t\tif (anal->opt.jmpmid && is_x86) {\n\t\t\t\t\t// This happens when we purposefully walked over another block and overlapped it\n\t\t\t\t\t// and now we hit an offset where the instructions match again.\n\t\t\t\t\t// So we need to split the overwalked block.\n\t\t\t\t\tRAnalBlock *split = r_anal_block_split (bbg, at);\n\t\t\t\t\tr_anal_block_unref (split);\n\t\t\t\t}\n\t\t\t\toverlapped = true;\n\t\t\t\tif (anal->verbose) {\n\t\t\t\t\teprintf (\"Overlapped at 0x%08\"PFMT64x \"\\n\", at);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!overlapped) {\n\t\t\tconst ut64 newbbsize = bb->size + oplen;\n\t\t\tif (newbbsize > MAX_FCN_SIZE) {\n\t\t\t\tgotoBeach (R_ANAL_RET_ERROR);\n\t\t\t}\n\t\t\tr_anal_bb_set_offset (bb, bb->ninstr++, at - bb->addr);\n\t\t\tr_anal_block_set_size (bb, newbbsize);\n\t\t\tfcn->ninstr++;\n\t\t}\n\t\tif (anal->opt.trycatch) {\n\t\t\tconst char *name = anal->coreb.getName (anal->coreb.core, at);\n\t\t\tif (name) {\n\t\t\t\tif (r_str_startswith (name, \"try.\") && r_str_endswith (name, \".from\")) {\n\t\t\t\t\tchar *handle = strdup (name);\n\t\t\t\t\t// handle = r_str_replace (handle, \".from\", \".to\", 0);\n\t\t\t\t\tut64 from_addr = anal->coreb.numGet (anal->coreb.core, handle);\n\t\t\t\t\thandle = r_str_replace (handle, \".from\", \".catch\", 0);\n\t\t\t\t\tut64 handle_addr = anal->coreb.numGet (anal->coreb.core, handle);\n\t\t\t\t\tbb->jump = at + oplen;\n\t\t\t\t\tif (from_addr != bb->addr) {\n\t\t\t\t\t\tbb->fail = handle_addr;\n\t\t\t\t\t\tret = r_anal_function_bb (anal, fcn, handle_addr, depth - 1);\n\t\t\t\t\t\teprintf (\"(%s) 0x%08\"PFMT64x\"\\n\", handle, handle_addr);\n\t\t\t\t\t\tif (bb->size == 0) {\n\t\t\t\t\t\t\tr_anal_function_remove_block (fcn, bb);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_anal_block_unref (bb);\n\t\t\t\t\t\tbb = fcn_append_basic_block (anal, fcn, addr);\n\t\t\t\t\t\tif (!bb) {\n\t\t\t\t\t\t\tgotoBeach (R_ANAL_RET_ERROR);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tidx += oplen;\n\t\tdelay.un_idx = idx;\n\t\tif (anal->opt.delay && op->delay > 0 && !delay.pending) {\n\t\t\t// Handle first pass through a branch delay jump:\n\t\t\t// Come back and handle the current instruction later.\n\t\t\t// Save the location of it in `delay.idx`\n\t\t\t// note, we have still increased size of basic block\n\t\t\t// (and function)\n\t\t\tif (anal->verbose) {\n\t\t\t\teprintf (\"Enter branch delay at 0x%08\"PFMT64x \". bb->sz=%\"PFMT64u\"\\n\", at - oplen, bb->size);\n\t\t\t}\n\t\t\tdelay.idx = idx - oplen;\n\t\t\tdelay.cnt = op->delay;\n\t\t\tdelay.pending = 1; // we need this in case the actual idx is zero...\n\t\t\tdelay.adjust = !overlapped; // adjustment is required later to avoid double count\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (delay.cnt > 0) {\n\t\t\t// if we had passed a branch delay instruction, keep\n\t\t\t// track of how many still to process.\n\t\t\tdelay.cnt--;\n\t\t\tif (!delay.cnt) {\n\t\t\t\tif (anal->verbose) {\n\t\t\t\t\teprintf (\"Last branch delayed opcode at 0x%08\"PFMT64x \". bb->sz=%\"PFMT64u\"\\n\", addr + idx - oplen, bb->size);\n\t\t\t\t}\n\t\t\t\tdelay.after = idx;\n\t\t\t\tidx = delay.idx;\n\t\t\t\t// At this point, we are still looking at the\n\t\t\t\t// last instruction in the branch delay group.\n\t\t\t\t// Next time, we will again be looking\n\t\t\t\t// at the original instruction that entered\n\t\t\t\t// the branch delay.\n\t\t\t}\n\t\t} else if (op->delay > 0 && delay.pending) {\n\t\t\tif (anal->verbose) {\n\t\t\t\teprintf (\"Revisit branch delay jump at 0x%08\"PFMT64x \". bb->sz=%\"PFMT64u\"\\n\", addr + idx - oplen, bb->size);\n\t\t\t}\n\t\t\t// This is the second pass of the branch delaying opcode\n\t\t\t// But we also already counted this instruction in the\n\t\t\t// size of the current basic block, so we need to fix that\n\t\t\tif (delay.adjust) {\n\t\t\t\tr_anal_block_set_size (bb, (ut64)addrbytes * (ut64)delay.after);\n\t\t\t\tfcn->ninstr--;\n\t\t\t\tif (anal->verbose) {\n\t\t\t\t\teprintf (\"Correct for branch delay @ %08\"PFMT64x \" bb.addr=%08\"PFMT64x \" corrected.bb=%\"PFMT64u\" f.uncorr=%\"PFMT64u\"\\n\",\n\t\t\t\t\taddr + idx - oplen, bb->addr, bb->size, r_anal_function_linear_size (fcn));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Next time, we go to the opcode after the delay count\n\t\t\t// Take care not to use this below, use delay.un_idx instead ...\n\t\t\tidx = delay.after;\n\t\t\tdelay.pending = delay.after = delay.idx = delay.adjust = 0;\n\t\t}\n\t\t// Note: if we got two branch delay instructions in a row due to an\n\t\t// compiler bug or junk or something it wont get treated as a delay\n\t\tswitch (op->stackop) {\n\t\tcase R_ANAL_STACK_INC:\n\t\t\tif (R_ABS (op->stackptr) < R_ANAL_MAX_INCSTACK) {\n\t\t\t\tfcn->stack += op->stackptr;\n\t\t\t\tif (fcn->stack > fcn->maxstack) {\n\t\t\t\t\tfcn->maxstack = fcn->stack;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbb->stackptr += op->stackptr;\n\t\t\tbreak;\n\t\tcase R_ANAL_STACK_RESET:\n\t\t\tbb->stackptr = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (op->ptr && op->ptr != UT64_MAX && op->ptr != UT32_MAX) {\n\t\t\t// swapped parameters wtf\n\t\t\tr_anal_xrefs_set (anal, op->addr, op->ptr, R_ANAL_REF_TYPE_DATA);\n\t\t}\n\t\tif (anal->opt.vars && !varset) {\n\t\t\t// XXX uses op.src/dst and fails because regprofile invalidates the regitems\n\t\t\t// lets just call this BEFORE retpoline() to avoid such issue\n\t\t\tr_anal_extract_vars (anal, fcn, op);\n\t\t}\n\t\t// this call may cause regprofile changes which cause ranalop.regitem references to be invalid\n\t\tanalyze_retpoline (anal, op);\n\t\tswitch (op->type & R_ANAL_OP_TYPE_MASK) {\n\t\tcase R_ANAL_OP_TYPE_CMOV:\n\t\tcase R_ANAL_OP_TYPE_MOV:\n\t\t\tlast_is_reg_mov_lea = false;\n\t\t\tif (is_arm) { // mov lr, pc\n\t\t\t\tconst char *esil = r_strbuf_get (&op->esil);\n\t\t\t\tif (!r_str_cmp (esil, \"pc,lr,=\", -1)) {\n\t\t\t\t\tlast_is_mov_lr_pc = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (has_stack_regs && op_is_set_bp (op_dst, op_src, bp_reg, sp_reg)) {\n\t\t\t\tfcn->bp_off = fcn->stack;\n\t\t\t}\n\t\t\t// Is this a mov of immediate value into a register?\n\t\t\tif (op->dst && op->dst->reg && op->dst->reg->name && op->val > 0 && op->val != UT64_MAX) {\n\t\t\t\tfree (last_reg_mov_lea_name);\n\t\t\t\tif ((last_reg_mov_lea_name = strdup (op->dst->reg->name))) {\n\t\t\t\t\tlast_reg_mov_lea_val = op->val;\n\t\t\t\t\tlast_is_reg_mov_lea = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// skip mov reg, reg\n\t\t\tif (anal->opt.jmptbl && op->scale && op->ireg) {\n\t\t\t\tmovdisp = op->disp;\n\t\t\t\tmovscale = op->scale;\n\t\t\t\tif (op->src[0] && op->src[0]->reg) {\n\t\t\t\t\tfree (movbasereg);\n\t\t\t\t\tmovbasereg = strdup (op->src[0]->reg->name);\n\t\t\t\t} else {\n\t\t\t\t\tR_FREE (movbasereg);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (anal->opt.hpskip && regs_exist (op->src[0], op->dst) && !strcmp (op->src[0]->reg->name, op->dst->reg->name)) {\n\t\t\t\tskip_ret = skip_hp (anal, fcn, op, bb, addr, oplen, delay.un_idx, &idx);\n\t\t\t\tif (skip_ret == 1) {\n\t\t\t\t\tgoto repeat;\n\t\t\t\t}\n\t\t\t\tif (skip_ret == 2) {\n\t\t\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_LEA:\n\t\t\tlast_is_reg_mov_lea = false;\n\t\t\t// if first byte in op->ptr is 0xff, then set leaddr assuming its a jumptable\n#if 0\n\t\t\t{\n\t\t\t\tut8 buf[4];\n\t\t\t\tanal->iob.read_at (anal->iob.io, op->ptr, buf, sizeof (buf));\n\t\t\t\tif ((buf[2] == 0xff || buf[2] == 0xfe) && buf[3] == 0xff) {\n\t\t\t\t\tleaddr_pair *pair = R_NEW (leaddr_pair);\n\t\t\t\t\tif (!pair) {\n\t\t\t\t\t\teprintf (\"Cannot create leaddr_pair\\n\");\n\t\t\t\t\t\tgotoBeach (R_ANAL_RET_ERROR);\n\t\t\t\t\t}\n\t\t\t\t\tpair->op_addr = op->addr;\n\t\t\t\t\tpair->leaddr = op->ptr; // XXX movdisp is dupped but seems to be trashed sometimes(?), better track leaddr separately\n\t\t\t\t\tr_list_append (anal->leaddrs, pair);\n\t\t\t\t}\n\t\t\t\tif (has_stack_regs && op_is_set_bp (op, bp_reg, sp_reg)) {\n\t\t\t\t\tfcn->bp_off = fcn->stack - op->src[0]->delta;\n\t\t\t\t}\n\t\t\t\tif (op->dst && op->dst->reg && op->dst->reg->name && op->ptr > 0 && op->ptr != UT64_MAX) {\n\t\t\t\t\tfree (last_reg_mov_lea_name);\n\t\t\t\t\tif ((last_reg_mov_lea_name = strdup (op->dst->reg->name))) {\n\t\t\t\t\t\tlast_reg_mov_lea_val = op->ptr;\n\t\t\t\t\t\tlast_is_reg_mov_lea = true;\n\t\t\t\t\t}\n\t\t\t\t}\n#else\n\t\t\tif (op->ptr != UT64_MAX) {\n\t\t\t\tleaddr_pair *pair = R_NEW (leaddr_pair);\n\t\t\t\tif (!pair) {\n\t\t\t\t\teprintf (\"Cannot create leaddr_pair\\n\");\n\t\t\t\t\tgotoBeach (R_ANAL_RET_ERROR);\n\t\t\t\t}\n\t\t\t\tpair->op_addr = op->addr;\n\t\t\t\tpair->leaddr = op->ptr; // XXX movdisp is dupped but seems to be trashed sometimes(?), better track leaddr separately\n\t\t\t\tpair->reg = op->reg\n\t\t\t\t\t? strdup (op->reg)\n\t\t\t\t\t: op->dst && op->dst->reg\n\t\t\t\t\t? strdup (op->dst->reg->name)\n\t\t\t\t\t: NULL;\n\t\t\t\tlea_cnt++;\n\t\t\t\tr_list_append (anal->leaddrs, pair);\n\t\t\t}\n\t\t\tif (has_stack_regs && op_is_set_bp (op_dst, op_src, bp_reg, sp_reg)     ) {\n\t\t\t\tfcn->bp_off = fcn->stack - op->src[0]->delta;\n\t\t\t}\n\t\t\tif (op->dst && op->dst->reg && op->dst->reg->name && op->ptr > 0 && op->ptr != UT64_MAX) {\n\t\t\t\tfree (last_reg_mov_lea_name);\n\t\t\t\tif ((last_reg_mov_lea_name = strdup(op->dst->reg->name))) {\n\t\t\t\t\tlast_reg_mov_lea_val = op->ptr;\n\t\t\t\t\tlast_is_reg_mov_lea = true;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\t// skip lea reg,[reg]\n\t\t\tif (anal->opt.hpskip && regs_exist (op->src[0], op->dst)\n\t\t\t&& !strcmp (op->src[0]->reg->name, op->dst->reg->name)) {\n\t\t\t\tskip_ret = skip_hp (anal, fcn, op, bb, at, oplen, delay.un_idx, &idx);\n\t\t\t\tif (skip_ret == 1) {\n\t\t\t\t\tgoto repeat;\n\t\t\t\t}\n\t\t\t\tif (skip_ret == 2) {\n\t\t\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (anal->opt.jmptbl) {\n\t\t\t\tRAnalOp *jmp_aop = r_anal_op_new ();\n\t\t\t\tut64 jmptbl_addr = op->ptr;\n\t\t\t\tut64 casetbl_addr = op->ptr;\n\t\t\t\tif (is_delta_pointer_table (anal, fcn, op->addr, op->ptr, &jmptbl_addr, &casetbl_addr, jmp_aop)) {\n\t\t\t\t\tut64 table_size, default_case = 0;\n\t\t\t\t\tst64 case_shift = 0;\n\t\t\t\t\t// we require both checks here since try_get_jmptbl_info uses\n\t\t\t\t\t// BB info of the final jmptbl jump, which is no present with\n\t\t\t\t\t// is_delta_pointer_table just scanning ahead\n\t\t\t\t\t// try_get_delta_jmptbl_info doesn't work at times where the\n\t\t\t\t\t// lea comes after the cmp/default case cjmp, which can be\n\t\t\t\t\t// handled with try_get_jmptbl_info\n\t\t\t\t\tut64 addr = jmp_aop->addr;\n\t\t\t\t\tbool ready = false;\n\t\t\t\t\tif (try_get_jmptbl_info (anal, fcn, addr, bb, &table_size, &default_case, &case_shift)) {\n\t\t\t\t\t\tready = true;\n\t\t\t\t\t} else if (try_get_delta_jmptbl_info (anal, fcn, addr, op->addr, &table_size, &default_case, &case_shift)) {\n\t\t\t\t\t\tready = true;\n\t\t\t\t\t}\n// TODO: -1-\n\t\t\t\t\tif (ready) {\n\t\t\t\t\t\tret = casetbl_addr == op->ptr\n\t\t\t\t\t\t\t? try_walkthrough_jmptbl (anal, fcn, bb, depth, addr, case_shift, jmptbl_addr, op->ptr, 4, table_size, default_case, 4)\n\t\t\t\t\t\t\t: try_walkthrough_casetbl (anal, fcn, bb, depth, addr, case_shift, jmptbl_addr, casetbl_addr, op->ptr, 4, table_size, default_case, 4);\n\t\t\t\t\t\tif (ret) {\n\t\t\t\t\t\t\tlea_jmptbl_ip = addr;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr_anal_op_free (jmp_aop);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_LOAD:\n\t\t\tif (anal->opt.loads) {\n\t\t\t\tif (anal->iob.is_valid_offset (anal->iob.io, op->ptr, 0)) {\n\t\t\t\t\tr_meta_set (anal, R_META_TYPE_DATA, op->ptr, 4, \"\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\t// Case of valid but unused \"add [rax], al\"\n\t\tcase R_ANAL_OP_TYPE_ADD:\n\t\t\tif (anal->opt.ijmp) {\n\t\t\t\tif ((op->size + 4 <= bytes_read) && !memcmp (buf + op->size, \"\\x00\\x00\\x00\\x00\", 4)) {\n\t\t\t\t\tr_anal_block_set_size (bb, bb->size - oplen);\n\t\t\t\t\top->type = R_ANAL_OP_TYPE_RET;\n\t\t\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_ILL:\n\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\tcase R_ANAL_OP_TYPE_TRAP:\n\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\tcase R_ANAL_OP_TYPE_NOP:\n\t\t\t// do nothing, because the nopskip goes before this switch\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\tif (op->jump == UT64_MAX) {\n\t\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t\t}\n\t\t\t{\n\t\t\t\tRFlagItem *fi = anal->flb.get_at (anal->flb.f, op->jump, false);\n\t\t\t\tif (fi && strstr (fi->name, \"imp.\")) {\n\t\t\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t\t}\n\t\t\tif (anal->opt.jmpref) {\n\t\t\t\t(void) r_anal_xrefs_set (anal, op->addr, op->jump, R_ANAL_REF_TYPE_CODE);\n\t\t\t}\n\t\t\tif (!anal->opt.jmpabove && (op->jump < fcn->addr)) {\n\t\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t\t}\n\t\t\tif (r_anal_noreturn_at (anal, op->jump)) {\n\t\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t\t}\n\t\t\t{\n\t\t\t\tbool must_eob = true;\n\t\t\t\tRIOMap *map = anal->iob.map_get_at (anal->iob.io, addr);\n\t\t\t\tif (map) {\n\t\t\t\t\tmust_eob = ( ! r_io_map_contain (map, op->jump) );\n\t\t\t\t}\n\t\t\t\tif (must_eob) {\n\t\t\t\t\top->jump = UT64_MAX;\n\t\t\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t\t\t}\n\t\t\t}\n#if FIX_JMP_FWD\n\t\t\tbb->jump = op->jump;\n\t\t\tbb->fail = UT64_MAX;\n\t\t\tFITFCNSZ ();\n\t\t\tgotoBeach (R_ANAL_RET_END);\n#else\n\t\t\tif (!overlapped) {\n\t\t\t\tbb->jump = op->jump;\n\t\t\t\tbb->fail = UT64_MAX;\n\t\t\t}\n\t\t\t// -1\n\t\t\tret = r_anal_function_bb (anal, fcn, op->jump, depth);\n\t\t\tint tc = anal->opt.tailcall;\n\t\t\tif (tc) {\n\t\t\t\t// eprintf (\"TAIL CALL AT 0x%llx\\n\", op->addr);\n\t\t\t\tint diff = op->jump - op->addr;\n\t\t\t\tif (tc < 0) {\n\t\t\t\t\tut8 buf[32];\n\t\t\t\t\t(void)anal->iob.read_at (anal->iob.io, op->jump, (ut8 *) buf, sizeof (buf));\n\t\t\t\t\tif (r_anal_is_prelude (anal, buf, sizeof (buf))) {\n\t\t\t\t\t\tfcn_recurse (anal, fcn, op->jump, anal->opt.bb_max_size, depth - 1);\n\t\t\t\t\t}\n\t\t\t\t} else if (R_ABS (diff) > tc) {\n\t\t\t\t\t(void) r_anal_xrefs_set (anal, op->addr, op->jump, R_ANAL_REF_TYPE_CALL);\n\t\t\t\t\tfcn_recurse (anal, fcn, op->jump, anal->opt.bb_max_size, depth - 1);\n\t\t\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto beach;\n#endif\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_SUB:\n\t\t\tif (op->val != UT64_MAX && op->val > 0) {\n\t\t\t\t// if register is not stack\n\t\t\t\tcmpval = op->val;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_CMP: {\n\t\t\tut64 val = (is_x86 || is_v850)? op->val : op->ptr;\n\t\t\tif (val) {\n\t\t\t\tcmpval = val;\n\t\t\t\tbb->cmpval = cmpval;\n\t\t\t\tbb->cmpreg = op->reg;\n\t\t\t\tr_anal_cond_free (bb->cond);\n\t\t\t\tbb->cond = r_anal_cond_new_from_op (op);\n\t\t\t}\n\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_CJMP:\n\t\tcase R_ANAL_OP_TYPE_MCJMP:\n\t\tcase R_ANAL_OP_TYPE_RCJMP:\n\t\tcase R_ANAL_OP_TYPE_UCJMP:\n\t\t\tif (anal->opt.cjmpref) {\n\t\t\t\t(void) r_anal_xrefs_set (anal, op->addr, op->jump, R_ANAL_REF_TYPE_CODE);\n\t\t\t}\n\t\t\tif (!overlapped) {\n\t\t\t\tbb->jump = op->jump;\n\t\t\t\tbb->fail = op->fail;\n\t\t\t}\n\t\t\tif (bb->cond) {\n\t\t\t\tbb->cond->type = op->cond;\n\t\t\t}\n\t\t\tif (anal->opt.jmptbl) {\n\t\t\t\tif (op->ptr != UT64_MAX) {\n\t\t\t\t\tut64 table_size, default_case;\n\t\t\t\t\ttable_size = cmpval + 1;\n\t\t\t\t\tdefault_case = op->fail; // is this really default case?\n\t\t\t\t\tif (cmpval != UT64_MAX && default_case != UT64_MAX && (op->reg || op->ireg)) {\n\t\t\t\t\t\t// TODO -1\n\t\t\t\t\t\tif (op->ireg) {\n\t\t\t\t\t\t\tret = try_walkthrough_jmptbl (anal, fcn, bb, depth, op->addr, 0, op->ptr, op->ptr, anal->bits >> 3, table_size, default_case, ret);\n\t\t\t\t\t\t} else { // op->reg\n\t\t\t\t\t\t\tret = walkthrough_arm_jmptbl_style (anal, fcn, bb, depth, op->addr, op->ptr, anal->bits >> 3, table_size, default_case, ret);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// check if op->jump and op->fail contain jump table location\n\t\t\t\t\t\t// clear jump address, because it's jump table location\n\t\t\t\t\t\tif (op->jump == op->ptr) {\n\t\t\t\t\t\t\top->jump = UT64_MAX;\n\t\t\t\t\t\t} else if (op->fail == op->ptr) {\n\t\t\t\t\t\t\top->fail = UT64_MAX;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcmpval = UT64_MAX;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint saved_stack = fcn->stack;\n\t\t\t// TODO: depth -1 in here\n\t\t\tr_anal_function_bb (anal, fcn, op->jump, depth);\n\t\t\tfcn->stack = saved_stack;\n\t\t\tret = r_anal_function_bb (anal, fcn, op->fail, depth);\n\t\t\tfcn->stack = saved_stack;\n\n\t\t\t// XXX breaks mips analysis too !op->delay\n\t\t\t// this will be all x86, arm (at least)\n\t\t\t// without which the analysis is really slow,\n\t\t\t// presumably because each opcode would get revisited\n\t\t\t// (and already covered by a bb) many times\n\t\t\tgoto beach;\n\t\t\t// For some reason, branch delayed code (MIPS) needs to continue\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_UCALL:\n\t\tcase R_ANAL_OP_TYPE_RCALL:\n\t\tcase R_ANAL_OP_TYPE_ICALL:\n\t\tcase R_ANAL_OP_TYPE_IRCALL:\n\t\t\t/* call [dst] */\n\t\t\t// XXX: this is TYPE_MCALL or indirect-call\n\t\t\t(void) r_anal_xrefs_set (anal, op->addr, op->ptr, R_ANAL_REF_TYPE_CALL);\n\n\t\t\tif (r_anal_noreturn_at (anal, op->ptr)) {\n\t\t\t\tRAnalFunction *f = r_anal_get_function_at (anal, op->ptr);\n\t\t\t\tif (f) {\n\t\t\t\t\tf->is_noreturn = true;\n\t\t\t\t}\n\t\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_CCALL:\n\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\t\t/* call dst */\n\t\t\t(void) r_anal_xrefs_set (anal, op->addr, op->jump, R_ANAL_REF_TYPE_CALL);\n\n\t\t\tif (r_anal_noreturn_at (anal, op->jump)) {\n\t\t\t\tRAnalFunction *f = r_anal_get_function_at (anal, op->jump);\n\t\t\t\tif (f) {\n\t\t\t\t\tf->is_noreturn = true;\n\t\t\t\t}\n\t\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_UJMP:\n\t\tcase R_ANAL_OP_TYPE_RJMP:\n\t\t\tif (is_arm && last_is_mov_lr_pc) {\n\t\t\t\tbreak;\n\t\t\t} else if (is_v850 && anal->opt.jmptbl) {\n\t\t\t\tint ptsz = cmpval? cmpval + 1: 4;\n\t\t\t\tif ((int)cmpval > 0) {\n\t\t\t\t\tret = try_walkthrough_jmptbl (anal, fcn, bb, depth, op->addr,\n\t\t\t\t\t\t0, op->addr + 2, op->addr + 2, 2, ptsz, 0, ret);\n\t\t\t\t}\n\t\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* fall through */\n\t\tcase R_ANAL_OP_TYPE_MJMP:\n\t\tcase R_ANAL_OP_TYPE_IJMP:\n\t\tcase R_ANAL_OP_TYPE_IRJMP:\n\t\t\t// if the next instruction is a symbol\n\t\t\tif (anal->opt.ijmp && next_instruction_is_symbol (anal, op)) {\n\t\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t\t}\n\t\t\t// switch statement\n\t\t\tif (anal->opt.jmptbl && lea_jmptbl_ip != op->addr) {\n\t\t\t\tut8 buf[32]; // 32 bytes is enough to hold any instruction.\n\t\t\t\t// op->ireg since rip relative addressing produces way too many false positives otherwise\n\t\t\t\t// op->ireg is 0 for rip relative, \"rax\", etc otherwise\n\t\t\t\tif (op->ptr != UT64_MAX && op->ireg) { // direct jump\n\t\t\t\t\tut64 table_size, default_case;\n\t\t\t\t\tst64 case_shift = 0;\n\t\t\t\t\tif (try_get_jmptbl_info (anal, fcn, op->addr, bb, &table_size, &default_case, &case_shift)) {\n\t\t\t\t\t\tbool case_table = false;\n\t\t\t\t\t\tRAnalOp *prev_op = r_anal_op_new ();\n\t\t\t\t\t\tanal->iob.read_at (anal->iob.io, op->addr - op->size, buf, sizeof (buf));\n\t\t\t\t\t\tif (r_anal_op (anal, prev_op, op->addr - op->size, buf, sizeof (buf), R_ANAL_OP_MASK_VAL) > 0) {\n\t\t\t\t\t\t\tbool prev_op_has_dst_name = prev_op->dst && prev_op->dst->reg && prev_op->dst->reg->name;\n\t\t\t\t\t\t\tbool op_has_src_name = op->src[0] && op->src[0]->reg && op->src[0]->reg->name;\n\t\t\t\t\t\t\tbool same_reg = (op->ireg && prev_op_has_dst_name && !strcmp (op->ireg, prev_op->dst->reg->name))\n\t\t\t\t\t\t\t\t|| (op_has_src_name && prev_op_has_dst_name && !strcmp (op->src[0]->reg->name, prev_op->dst->reg->name));\n\t\t\t\t\t\t\tif (prev_op->type == R_ANAL_OP_TYPE_MOV && prev_op->disp && prev_op->disp != UT64_MAX && same_reg) {\n\t\t\t\t\t\t\t\t//\tmovzx reg, byte [reg + case_table]\n\t\t\t\t\t\t\t\t//\tjmp dword [reg*4 + jump_table]\n\t\t\t\t\t\t\t\tif (try_walkthrough_casetbl (anal, fcn, bb, depth - 1, op->addr, case_shift, op->ptr, prev_op->disp, op->ptr, anal->bits >> 3, table_size, default_case, ret)) {\n\t\t\t\t\t\t\t\t\tret = case_table = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_anal_op_free (prev_op);\n\t\t\t\t\t\tif (!case_table) {\n\t\t\t\t\t\t\tret = try_walkthrough_jmptbl (anal, fcn, bb, depth, op->addr, case_shift, op->ptr, op->ptr, anal->bits >> 3, table_size, default_case, ret);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (op->ptr != UT64_MAX && op->reg) { // direct jump\n\t\t\t\t\tut64 table_size, default_case;\n\t\t\t\t\tst64 case_shift = 0;\n\t\t\t\t\tif (try_get_jmptbl_info (anal, fcn, op->addr, bb, &table_size, &default_case, &case_shift)) {\n\t\t\t\t\t\tret = try_walkthrough_jmptbl (anal, fcn, bb, depth - 1, op->addr, case_shift, op->ptr, op->ptr, anal->bits >> 3, table_size, default_case, ret);\n\t\t\t\t\t}\n\t\t\t\t} else if (movdisp != UT64_MAX) {\n\t\t\t\t\tst64 case_shift = 0;\n\t\t\t\t\tut64 table_size, default_case;\n\t\t\t\t\tut64 jmptbl_base = 0; //UT64_MAX;\n\t\t\t\t\tut64 lea_op_off = UT64_MAX;\n\t\t\t\t\tRListIter *iter;\n\t\t\t\t\tleaddr_pair *pair;\n\t\t\t\t\tif (movbasereg) {\n\t\t\t\t\t\t// find nearest candidate leaddr before op.addr\n\t\t\t\t\t\tr_list_foreach_prev (anal->leaddrs, iter, pair) {\n\t\t\t\t\t\t\tif (pair->op_addr >= op->addr) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ((lea_op_off == UT64_MAX || lea_op_off > op->addr - pair->op_addr) && pair->reg && !strcmp (movbasereg, pair->reg)) {\n\t\t\t\t\t\t\t\tlea_op_off = op->addr - pair->op_addr;\n\t\t\t\t\t\t\t\tjmptbl_base = pair->leaddr;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!try_get_jmptbl_info (anal, fcn, op->addr, bb, &table_size, &default_case, &case_shift)) {\n\t\t\t\t\t\ttable_size = cmpval + 1;\n\t\t\t\t\t\tdefault_case = -1;\n\t\t\t\t\t}\n\t\t\t\t\tret = try_walkthrough_jmptbl (anal, fcn, bb, depth - 1, op->addr, case_shift, jmptbl_base + movdisp, jmptbl_base, movscale, table_size, default_case, ret);\n\t\t\t\t\tcmpval = UT64_MAX;\n#if 0\n\t\t\t\t} else if (movdisp != UT64_MAX) {\n\t\t\t\t\tut64 table_size, default_case;\n\t\t\t\t\tst64 case_shift;\n\t\t\t\t\tif (try_get_jmptbl_info (anal, fcn, op->addr, bb, &table_size, &default_case, &case_shift)) {\n\t\t\t\t\t\top->ptr = movdisp;\n\t\t\t\t\t\tret = try_walkthrough_jmptbl (anal, fcn, bb, depth - 1, op->addr, case_shift, op->ptr, op->ptr, anal->bits >> 3, table_size, default_case, ret);\n\t\t\t\t\t}\n\t\t\t\t\tmovdisp = UT64_MAX;\n#endif\n\t\t\t\t} else if (is_arm) {\n\t\t\t\t\tif (op->ptrsize == 1) { // TBB\n\t\t\t\t\t\tut64 pred_cmpval = try_get_cmpval_from_parents(anal, fcn, bb, op->ireg);\n\t\t\t\t\t\tut64 table_size = 0;\n\t\t\t\t\t\tif (pred_cmpval != UT64_MAX) {\n\t\t\t\t\t\t\ttable_size += pred_cmpval;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttable_size += cmpval;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tret = try_walkthrough_jmptbl (anal, fcn, bb, depth - 1, op->addr, 0, op->addr + op->size,\n\t\t\t\t\t\t\top->addr + 4, 1, table_size, UT64_MAX, ret);\n\t\t\t\t\t\t// skip inlined jumptable\n\t\t\t\t\t\tidx += table_size;\n\t\t\t\t\t}\n\t\t\t\t\tif (op->ptrsize == 2) { // LDRH on thumb/arm\n\t\t\t\t\t\tut64 pred_cmpval = try_get_cmpval_from_parents(anal, fcn, bb, op->ireg);\n\t\t\t\t\t\tint tablesize = 1;\n\t\t\t\t\t\tif (pred_cmpval != UT64_MAX) {\n\t\t\t\t\t\t\ttablesize += pred_cmpval;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttablesize += cmpval;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tret = try_walkthrough_jmptbl (anal, fcn, bb, depth - 1, op->addr, 0, op->addr + op->size,\n\t\t\t\t\t\t\top->addr + 4, 2, tablesize, UT64_MAX, ret);\n\t\t\t\t\t\t// skip inlined jumptable\n\t\t\t\t\t\tidx += (tablesize * 2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lea_jmptbl_ip == op->addr) {\n\t\t\t\tlea_jmptbl_ip = UT64_MAX;\n\t\t\t}\n\t\t\tif (anal->opt.ijmp) {\n\t\t\t\tr_anal_function_bb (anal, fcn, op->jump, depth - 1);\n\t\t\t\tret = r_anal_function_bb (anal, fcn, op->fail, depth - 1);\n\t\t\t\tif (overlapped) {\n\t\t\t\t\tgoto analopfinish;\n\t\t\t\t}\n\t\t\t\tif (r_anal_noreturn_at (anal, op->jump) || op->eob) {\n\t\t\t\t\tgoto analopfinish;\n\t\t\t\t}\n\t\t\t} else {\nanalopfinish:\n\t\t\t\tif (op->type == R_ANAL_OP_TYPE_RJMP) {\n\t\t\t\t\tgotoBeach (R_ANAL_RET_NOP);\n\t\t\t\t} else {\n\t\t\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t/* fallthru */\n\t\tcase R_ANAL_OP_TYPE_PUSH:\n\t\t\tlast_is_push = true;\n\t\t\tlast_push_addr = op->val;\n\t\t\tif (anal->iob.is_valid_offset (anal->iob.io, last_push_addr, 1)) {\n\t\t\t\t(void) r_anal_xrefs_set (anal, op->addr, last_push_addr, R_ANAL_REF_TYPE_DATA);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_UPUSH:\n\t\t\tif ((op->type & R_ANAL_OP_TYPE_REG) && last_is_reg_mov_lea && op->src[0] && op->src[0]->reg\n\t\t\t\t&& op->src[0]->reg->name && !strcmp (op->src[0]->reg->name, last_reg_mov_lea_name)) {\n\t\t\t\tlast_is_push = true;\n\t\t\t\tlast_push_addr = last_reg_mov_lea_val;\n\t\t\t\tif (anal->iob.is_valid_offset (anal->iob.io, last_push_addr, 1)) {\n\t\t\t\t\t(void) r_anal_xrefs_set (anal, op->addr, last_push_addr, R_ANAL_REF_TYPE_DATA);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_RET:\n\t\t\tif (op->family == R_ANAL_OP_FAMILY_PRIV) {\n\t\t\t\tfcn->type = R_ANAL_FCN_TYPE_INT;\n\t\t\t}\n\t\t\tif (last_is_push && anal->opt.pushret) {\n\t\t\t\top->type = R_ANAL_OP_TYPE_JMP;\n\t\t\t\top->jump = last_push_addr;\n\t\t\t\tbb->jump = op->jump;\n\t\t\t\tret = r_anal_function_bb (anal, fcn, op->jump, depth - 1);\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (!op->cond) {\n\t\t\t\tif (anal->verbose) {\n\t\t\t\t\teprintf (\"RET 0x%08\"PFMT64x \". overlap=%s %\"PFMT64u\" %\"PFMT64u\"\\n\",\n\t\t\t\t\t\taddr + delay.un_idx - oplen, r_str_bool (overlapped),\n\t\t\t\t\t\tbb->size, r_anal_function_linear_size (fcn));\n\t\t\t\t}\n\t\t\t\tgotoBeach (R_ANAL_RET_END);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (has_stack_regs && arch_destroys_dst) {\n\t\t\t// op->dst->reg->name is invalid pointer\n\t\t\tif (op_is_set_bp (op_dst, op_src, bp_reg, sp_reg) && op->src[1]) {\n\t\t\t\tswitch (op->type & R_ANAL_OP_TYPE_MASK) {\n\t\t\t\tcase R_ANAL_OP_TYPE_ADD:\n\t\t\t\t\tfcn->bp_off = fcn->stack - op->src[1]->imm;\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_OP_TYPE_SUB:\n\t\t\t\t\tfcn->bp_off = fcn->stack + op->src[1]->imm;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#if 0\n\t\tif (anal->opt.vars && !varset) {\n\t\t\t// XXX uses op.src/dst and fails because regprofile invalidates the regitems\n\t\t\t// we must ranalop in here to avoid uaf\n\t\t\tr_anal_extract_vars (anal, fcn, op);\n\t\t}\n#endif\n\t\tif (op->type != R_ANAL_OP_TYPE_MOV && op->type != R_ANAL_OP_TYPE_CMOV && op->type != R_ANAL_OP_TYPE_LEA) {\n\t\t\tlast_is_reg_mov_lea = false;\n\t\t}\n\t\tif (op->type != R_ANAL_OP_TYPE_PUSH && op->type != R_ANAL_OP_TYPE_RPUSH) {\n\t\t\tlast_is_push = false;\n\t\t}\n\t\tif (is_arm && op->type != R_ANAL_OP_TYPE_MOV) {\n\t\t\tlast_is_mov_lr_pc = false;\n\t\t}\n\t\tif (has_variadic_reg && !fcn->is_variadic) {\n\t\t\tvariadic_reg = r_reg_get (anal->reg, \"rax\", R_REG_TYPE_GPR);\n\t\t\tbool dst_is_variadic = op->dst && op->dst->reg\n\t\t\t\t\t&& variadic_reg && op->dst->reg->offset == variadic_reg->offset;\n\t\t\tbool op_is_cmp = (op->type == R_ANAL_OP_TYPE_CMP) || op->type == R_ANAL_OP_TYPE_ACMP;\n\t\t\tif (dst_is_variadic && !op_is_cmp) {\n\t\t\t\thas_variadic_reg = false;\n\t\t\t} else if (op_is_cmp) {\n\t\t\t\tif (op->src[0] && op->src[0]->reg && (op->dst->reg == op->src[0]->reg) && dst_is_variadic) {\n\t\t\t\t\tfcn->is_variadic = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nbeach:\n\tfree (op_src);\n\tfree (op_dst);\n\tfree (bp_reg);\n\tfree (sp_reg);\n\twhile (lea_cnt > 0) {\n\t\tr_list_delete (anal->leaddrs, r_list_tail (anal->leaddrs));\n\t\tlea_cnt--;\n\t}\n\tr_anal_op_free (op);\n\tR_FREE (last_reg_mov_lea_name);\n\tif (bb && bb->size == 0) {\n\t\tr_anal_function_remove_block (fcn, bb);\n\t}\n\tr_anal_block_update_hash (bb);\n\tr_anal_block_unref (bb);\n\tfree (movbasereg);\n\treturn ret;\n}\n\nR_API int r_anal_function_bb(RAnal *anal, RAnalFunction *fcn, ut64 addr, int depth) {\n\tr_return_val_if_fail (anal && fcn, -1);\n\treturn fcn_recurse (anal, fcn, addr, anal->opt.bb_max_size, depth - 1);\n}\n\nR_API bool r_anal_check_fcn(RAnal *anal, ut8 *buf, ut16 bufsz, ut64 addr, ut64 low, ut64 high) {\n\tr_return_val_if_fail (anal && buf, false);\n\tRAnalOp op = {\n\t\t0\n\t};\n\tint i, oplen, opcnt = 0, pushcnt = 0, movcnt = 0, brcnt = 0;\n\tif (r_anal_is_prelude (anal, buf, bufsz)) {\n\t\treturn true;\n\t}\n\tfor (i = 0; i < bufsz && opcnt < 10; i += oplen, opcnt++) {\n\t\tr_anal_op_fini (&op);\n\t\tif ((oplen = r_anal_op (anal, &op, addr + i, buf + i, bufsz - i, R_ANAL_OP_MASK_BASIC | R_ANAL_OP_MASK_HINT)) < 1) {\n\t\t\treturn false;\n\t\t}\n\t\tswitch (op.type) {\n\t\tcase R_ANAL_OP_TYPE_PUSH:\n\t\tcase R_ANAL_OP_TYPE_UPUSH:\n\t\tcase R_ANAL_OP_TYPE_RPUSH:\n\t\t\tpushcnt++;\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_MOV:\n\t\tcase R_ANAL_OP_TYPE_CMOV:\n\t\t\tmovcnt++;\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\tcase R_ANAL_OP_TYPE_CJMP:\n\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\t\tif (op.jump < low || op.jump >= high) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbrcnt++;\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_UNK:\n\t\t\treturn false;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (pushcnt + movcnt + brcnt > 5);\n}\n\nR_API void r_anal_trim_jmprefs(RAnal *anal, RAnalFunction *fcn) {\n\tr_return_if_fail (anal && fcn);\n\tRAnalRef *ref;\n\tRList *refs = r_anal_function_get_refs (fcn);\n\tRListIter *iter;\n\tconst bool is_x86 = anal->cur->arch && !strcmp (anal->cur->arch, \"x86\"); // HACK\n\n\tr_list_foreach (refs, iter, ref) {\n\t\tif (ref->type == R_ANAL_REF_TYPE_CODE && r_anal_function_contains (fcn, ref->addr)\n\t\t    && (!is_x86 || !r_anal_function_contains (fcn, ref->at))) {\n\t\t\tr_anal_xrefs_deln (anal, ref->at, ref->addr, ref->type);\n\t\t}\n\t}\n\tr_list_free (refs);\n}\n\nR_API void r_anal_del_jmprefs(RAnal *anal, RAnalFunction *fcn) {\n\tr_return_if_fail (anal && fcn);\n\tRAnalRef *ref;\n\tRList *refs = r_anal_function_get_refs (fcn);\n\tRListIter *iter;\n\n\tr_list_foreach (refs, iter, ref) {\n\t\tif (ref->type == R_ANAL_REF_TYPE_CODE) {\n\t\t\tr_anal_xrefs_deln (anal, ref->at, ref->addr, ref->type);\n\t\t}\n\t}\n\tr_list_free (refs);\n}\n\n/* Does NOT invalidate read-ahead cache. */\nR_API int r_anal_function(RAnal *anal, RAnalFunction *fcn, ut64 addr, ut64 len, int reftype) {\n\tr_return_val_if_fail (anal && fcn, 0);\n\tRPVector *metas = r_meta_get_all_in (anal, addr, R_META_TYPE_ANY);\n\tif (metas) {\n\t\tvoid **it;\n\t\tr_pvector_foreach (metas, it) {\n\t\t\tRAnalMetaItem *meta = ((RIntervalNode *)*it)->data;\n\t\t\tswitch (meta->type) {\n\t\t\tcase R_META_TYPE_DATA:\n\t\t\tcase R_META_TYPE_STRING:\n\t\t\tcase R_META_TYPE_FORMAT:\n\t\t\t\tr_pvector_free (metas);\n\t\t\t\treturn 0;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tr_pvector_free (metas);\n\t}\n\tif (anal->opt.norevisit) {\n\t\tif (!anal->visited) {\n\t\t\tanal->visited = set_u_new ();\n\t\t}\n\t\tif (set_u_contains (anal->visited, addr)) {\n\t\t\teprintf (\"r_anal_function: anal.norevisit at 0x%08\"PFMT64x\" %c\\n\", addr, reftype);\n\t\t\treturn R_ANAL_RET_END;\n\t\t}\n\t\tset_u_add (anal->visited, addr);\n\t} else {\n\t\tif (anal->visited) {\n\t\t\tset_u_free (anal->visited);\n\t\t\tanal->visited = NULL;\n\t\t}\n\t}\n\t/* defines fcn. or loc. prefix */\n\tfcn->type = (reftype == R_ANAL_REF_TYPE_CODE) ? R_ANAL_FCN_TYPE_LOC : R_ANAL_FCN_TYPE_FCN;\n\tif (fcn->addr == UT64_MAX) {\n\t\tfcn->addr = addr;\n\t}\n\tfcn->maxstack = 0;\n\tif (fcn->cc && !strcmp (fcn->cc, \"ms\")) {\n\t\t// Probably should put this on the cc sdb\n\t\tconst int shadow_store = 0x28; // First 4 args + retaddr\n\t\tfcn->stack = fcn->maxstack = fcn->reg_save_area = shadow_store;\n\t}\n\t// XXX -1 here results in lots of errors\n\tint ret = r_anal_function_bb (anal, fcn, addr, anal->opt.depth);\n\tif (ret < 0) {\n\t\tif (anal->verbose) {\n\t\t\teprintf (\"Failed to analyze basic block at 0x%\"PFMT64x\"\\n\", addr);\n\t\t}\n\t}\n\tif (anal->opt.endsize && ret == R_ANAL_RET_END && r_anal_function_realsize (fcn)) {   // cfg analysis completed\n\t\tRListIter *iter;\n\t\tRAnalBlock *bb;\n\t\tut64 endaddr = fcn->addr;\n\t\tconst bool is_x86 = anal->cur->arch && !strcmp (anal->cur->arch, \"x86\");\n\n\t\t// set function size as length of continuous sequence of bbs\n\t\tr_list_sort (fcn->bbs, &cmpaddr);\n\t\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\t\tif (endaddr == bb->addr) {\n\t\t\t\tendaddr += bb->size;\n\t\t\t} else if ((endaddr < bb->addr && bb->addr - endaddr < BB_ALIGN)\n\t\t\t\t\t|| (anal->opt.jmpmid && is_x86 && endaddr > bb->addr\n\t\t\t\t\t\t&& bb->addr + bb->size > endaddr)) {\n\t\t\t\tendaddr = bb->addr + bb->size;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#if JAYRO_04\n\t\t// fcn is not yet in anal => pass NULL\n\t\tr_anal_function_resize (fcn, endaddr - fcn->addr);\n#endif\n\t\tr_anal_trim_jmprefs (anal, fcn);\n\t}\n\treturn ret;\n}\n\n// XXX deprecate\nR_API int r_anal_function_del_locs(RAnal *anal, ut64 addr) {\n\tRListIter *iter, *iter2;\n\tRAnalFunction *fcn, *f = r_anal_get_fcn_in (anal, addr, R_ANAL_FCN_TYPE_ROOT);\n\tif (!f) {\n\t\treturn false;\n\t}\n\tr_list_foreach_safe (anal->fcns, iter, iter2, fcn) {\n\t\tif (fcn->type != R_ANAL_FCN_TYPE_LOC) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (r_anal_function_contains (fcn, addr)) {\n\t\t\tr_anal_function_delete (fcn);\n\t\t\tbreak;\n\t\t}\n\t}\n\tr_anal_function_del (anal, addr);\n\treturn true;\n}\n\nR_API int r_anal_function_del(RAnal *a, ut64 addr) {\n\tRAnalFunction *fcn = r_anal_get_function_at (a, addr);\n\tif (fcn) {\n\t\tr_anal_function_delete (fcn);\n\t\t// r_anal_function_free (fcn);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nR_API RAnalFunction *r_anal_get_fcn_in(RAnal *anal, ut64 addr, int type) {\n\tRList *list = r_anal_get_functions_in (anal, addr);\n\tRAnalFunction *ret = NULL;\n\tif (list && !r_list_empty (list)) {\n\t\tif (type == R_ANAL_FCN_TYPE_ROOT) {\n\t\t\tRAnalFunction *fcn;\n\t\t\tRListIter *iter;\n\t\t\tr_list_foreach (list, iter, fcn) {\n\t\t\t\tif (fcn->addr == addr) {\n\t\t\t\t\tret = fcn;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tret = r_list_first (list);\n\t\t}\n\t}\n\tr_list_free (list);\n\treturn ret;\n}\n\nR_API RAnalFunction *r_anal_get_fcn_in_bounds(RAnal *anal, ut64 addr, int type) {\n\tRAnalFunction *fcn, *ret = NULL;\n\tRListIter *iter;\n\tif (type == R_ANAL_FCN_TYPE_ROOT) {\n\t\tr_list_foreach (anal->fcns, iter, fcn) {\n\t\t\tif (addr == fcn->addr) {\n\t\t\t\treturn fcn;\n\t\t\t}\n\t\t}\n\t\treturn NULL;\n\t}\n\tr_list_foreach (anal->fcns, iter, fcn) {\n\t\tif (!type || (fcn && fcn->type & type)) {\n\t\t\tif (r_anal_function_contains (fcn, addr)) {\n\t\t\t\treturn fcn;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nR_API RAnalFunction *r_anal_get_function_byname(RAnal *a, const char *name) {\n\tbool found = false;\n\tRAnalFunction *f = ht_pp_find (a->ht_name_fun, name, &found);\n\tif (f && found) {\n\t\treturn f;\n\t}\n\treturn NULL;\n}\n\n/* rename RAnalFunctionBB.add() */\nR_API bool r_anal_function_add_bb(RAnal *a, RAnalFunction *fcn, ut64 addr, ut64 size, ut64 jump, ut64 fail, R_BORROW RAnalDiff *diff) {\n\tD eprintf (\"Add bb\\n\");\n\tif (size == 0) { // empty basic blocks allowed?\n\t\teprintf (\"Warning: empty basic block at 0x%08\"PFMT64x\" is not allowed. pending discussion.\\n\", addr);\n\t\tr_warn_if_reached ();\n\t\treturn false;\n\t}\n\tif (size > a->opt.bb_max_size) {\n\t\teprintf (\"Warning: can't allocate such big bb of %\"PFMT64d\" bytes at 0x%08\"PFMT64x\"\\n\", (st64)size, addr);\n\t\tr_warn_if_reached ();\n\t\treturn false;\n\t}\n\n\tRAnalBlock *block = r_anal_get_block_at (a, addr);\n\tif (block) {\n\t\tr_anal_delete_block (block);\n\t\tblock = NULL;\n\t}\n\n\tconst bool is_x86 = a->cur->arch && !strcmp (a->cur->arch, \"x86\");\n\t// TODO fix this x86-ism\n\tif (is_x86) {\n\t\tr_anal_function_invalidate_read_ahead_cache ();\n\t\tfcn_recurse (a, fcn, addr, size, 1);\n\t\tblock = r_anal_get_block_at (a, addr);\n\t\tif (block) {\n\t\t\tr_anal_block_set_size (block, size);\n\t\t}\n\t} else {\n\t\tblock = r_anal_create_block (a, addr, size);\n\t}\n\n\tif (!block) {\n\t\tD eprintf (\"Warning: r_anal_function_add_bb failed in fcn 0x%08\"PFMT64x\" at 0x%08\"PFMT64x\"\\n\", fcn->addr, addr);\n\t\treturn false;\n\t}\n\n\tr_anal_function_add_block (fcn, block);\n\n\tblock->jump = jump;\n\tblock->fail = fail;\n\tblock->fail = fail;\n\tif (diff) {\n\t\tif (!block->diff) {\n\t\t\tblock->diff = r_anal_diff_new ();\n\t\t}\n\t\tif (block->diff) {\n\t\t\tblock->diff->type = diff->type;\n\t\t\tblock->diff->addr = diff->addr;\n\t\t\tif (diff->name) {\n\t\t\t\tR_FREE (block->diff->name);\n\t\t\t\tblock->diff->name = strdup (diff->name);\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nR_API int r_anal_function_loops(RAnalFunction *fcn) {\n\tRListIter *iter;\n\tRAnalBlock *bb;\n\tut32 loops = 0;\n\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\tif (bb->jump != UT64_MAX && bb->jump < bb->addr) {\n\t\t\tloops ++;\n\t\t}\n\t\tif (bb->fail != UT64_MAX && bb->fail < bb->addr) {\n\t\t\tloops ++;\n\t\t}\n\t}\n\treturn loops;\n}\n\nR_API int r_anal_function_complexity(RAnalFunction *fcn) {\n\t/*\n\t * CC = E - N + 2P\n\t * E = the number of edges of the graph.\n\t * N = the number of nodes of the graph.\n\t * P = the number of connected components (exit nodes).\n\t */\n\tRAnal *anal = fcn->anal;\n\tint E = 0, N = 0, P = 0;\n\tRListIter *iter;\n\tRAnalBlock *bb;\n\n\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\tN++; // nodes\n\t\tif ((!anal || anal->verbose) && bb->jump == UT64_MAX && bb->fail != UT64_MAX) {\n\t\t\teprintf (\"Warning: invalid bb jump/fail pair at 0x%08\"PFMT64x\" (fcn 0x%08\"PFMT64x\"\\n\", bb->addr, fcn->addr);\n\t\t}\n\t\tif (bb->jump == UT64_MAX && bb->fail == UT64_MAX) {\n\t\t\tP++; // exit nodes\n\t\t} else {\n\t\t\tE++; // edges\n\t\t\tif (bb->fail != UT64_MAX) {\n\t\t\t\tE++;\n\t\t\t}\n\t\t}\n\t\tif (bb->switch_op && bb->switch_op->cases) {\n\t\t\tE += r_list_length (bb->switch_op->cases);\n\t\t}\n\t}\n\n\tint result = E - N + (2 * P);\n\tif (result < 1 && (!anal || anal->verbose)) {\n\t\teprintf (\"Warning: CC = E(%d) - N(%d) + (2 * P(%d)) < 1 at 0x%08\"PFMT64x\"\\n\", E, N, P, fcn->addr);\n\t}\n\t// r_return_val_if_fail (result > 0, 0);\n\treturn result;\n}\n\n// tfj and afsj call this function\nR_API char *r_anal_function_get_json(RAnalFunction *function) {\n\tRAnal *a = function->anal;\n\tPJ *pj = a->coreb.pjWithEncoding (a->coreb.core);\n\tconst char *realname = NULL, *import_substring = NULL;\n\n\tRFlagItem *flag = a->flag_get (a->flb.f, function->addr);\n\t// Can't access R_FLAGS_FS_IMPORTS, since it is defined in r_core.h\n\tif (flag && flag->space && !strcmp (flag->space->name, \"imports\")) {\n\t\t// Get substring after last dot\n\t\timport_substring = r_str_rchr (function->name, NULL, '.');\n\t\tif (import_substring) {\n\t\t\trealname = import_substring + 1;\n\t\t}\n\t} else {\n\t\trealname = function->name;\n\t}\n\t\n\tchar *args = strdup (\"\");\n\tchar *sdb_ret = r_str_newf (\"func.%s.ret\", realname);\n\tchar *sdb_args = r_str_newf (\"func.%s.args\", realname);\n\t// RList *args_list = r_list_newf ((RListFree) free);\n\tunsigned int i;\n\tconst char *ret_type = sdb_const_get (a->sdb_types, sdb_ret, 0);\n\tconst char *argc_str = sdb_const_get (a->sdb_types, sdb_args, 0);\n\n\tint argc = argc_str? atoi (argc_str): 0;\n\n\tpj_o (pj);\n\tpj_ks (pj, \"name\", function->name);\n\tconst bool no_return = r_anal_noreturn_at_addr (a, function->addr);\n\tpj_kb (pj, \"noreturn\", no_return);\n\tpj_ks (pj, \"ret\", r_str_get_fail (ret_type, \"void\"));\n\tif (function->cc) {\n\t\tpj_ks (pj, \"cc\", function->cc);\n\t}\n\tpj_kn (pj, \"argc\", argc);\n\tpj_k (pj, \"args\");\n\tpj_a (pj);\n\tfor (i = 0; i < argc; i++) {\n\t\tchar *sdb_arg_i = r_str_newf (\"func.%s.arg.%d\", realname, i);\n\t\tchar *arg_i = sdb_get (a->sdb_types, sdb_arg_i, 0);\n\t\tif (!arg_i) {\n\t\t\tcontinue;\n\t\t}\n\t\tpj_o (pj);\n\t\tchar *comma = strchr (arg_i, ',');\n\t\tif (comma) {\n\t\t\t*comma = 0;\n\t\t\tpj_ks (pj, \"name\", comma + 1);\n\t\t\tpj_ks (pj, \"type\", arg_i);\n\t\t\tr_strf_var (regname, 32, \"A%d\", i);\n\t\t\tconst char *cc_arg = r_reg_get_name (a->reg, r_reg_get_name_idx (regname));\n\t\t\tif (cc_arg) {\n\t\t\t\tpj_ks (pj, \"cc\", cc_arg);\n\t\t\t}\n\t\t}\n\t\tfree (arg_i);\n\t\tfree (sdb_arg_i);\n\t\tpj_end (pj);\n\t}\n\tpj_end (pj);\n\tfree (sdb_args);\n\tfree (sdb_ret);\n\tfree (args);\n\tpj_end (pj);\n\treturn pj_drain (pj);\n}\n\nR_API char *r_anal_function_get_signature(RAnalFunction *function) {\n\tRAnal *a = function->anal;\n\tconst char *realname = NULL, *import_substring = NULL;\n\n\tRFlagItem *flag = a->flag_get (a->flb.f, function->addr);\n\t// Can't access R_FLAGS_FS_IMPORTS, since it is defined in r_core.h\n\tif (flag && flag->space && !strcmp (flag->space->name, \"imports\")) {\n\t\t// Get substring after last dot\n\t\timport_substring = r_str_rchr (function->name, NULL, '.');\n\t\tif (import_substring) {\n\t\t\trealname = import_substring + 1;\n\t\t}\n\t} else {\n\t\trealname = function->name;\n\t}\n\n\tchar *ret = NULL, *args = strdup (\"\");\n\tchar *sdb_ret = r_str_newf (\"func.%s.ret\", realname);\n\tchar *sdb_args = r_str_newf (\"func.%s.args\", realname);\n\t// RList *args_list = r_list_newf ((RListFree) free);\n\tunsigned int i, j;\n\tconst char *ret_type = sdb_const_get (a->sdb_types, sdb_ret, 0);\n\tconst char *argc_str = sdb_const_get (a->sdb_types, sdb_args, 0);\n\n\tint argc = argc_str? atoi (argc_str): 0;\n\n\tfor (i = 0; i < argc; i++) {\n\t\tchar *sdb_arg_i = r_str_newf (\"func.%s.arg.%d\", realname, i);\n\t\tchar *arg_i = sdb_get (a->sdb_types, sdb_arg_i, 0);\n\t\tif (!arg_i) {\n\t\t\tfree (sdb_arg_i);\n\t\t\tbreak;\n\t\t}\n\t\t// parse commas\n\t\tint arg_i_len = strlen (arg_i);\n\t\tfor (j = 0; j < arg_i_len; j++) {\n\t\t\tif (j > 0 && arg_i[j] == ',') {\n\t\t\t\tif (arg_i[j - 1] == '*') {\n\t\t\t\t\t// remove whitespace\n\t\t\t\t\tmemmove (arg_i + j, arg_i + j + 1, strlen (arg_i) - j);\n\t\t\t\t} else {\n\t\t\t\t\targ_i[j] = ' ';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tchar *new_args = (i + 1 == argc)\n\t\t\t? r_str_newf (\"%s%s\", args, arg_i)\n\t\t\t: r_str_newf (\"%s%s, \", args, arg_i);\n\t\tfree (args);\n\t\targs = new_args;\n\t\tfree (arg_i);\n\t\tfree (sdb_arg_i);\n\t}\n\n\tchar *sane = r_name_filter2 (realname);\n\tif (sane) {\n\t\tr_str_replace_ch (sane, ':', '_', true);\n\t\trealname = sane;\n\t}\n\tret = r_str_newf (\"%s %s (%s);\", r_str_get_fail (ret_type, \"void\"), realname, args);\n\tfree (sane);\n\n\tfree (sdb_args);\n\tfree (sdb_ret);\n\tfree (args);\n\treturn ret;\n}\n\n/* set function signature from string */\nR_API int r_anal_str_to_fcn(RAnal *a, RAnalFunction *f, const char *sig) {\n\tr_return_val_if_fail (a || f || sig, false);\n\tchar *error_msg = NULL;\n\tconst char *out = r_parse_c_string (a, sig, &error_msg);\n\tif (out) {\n\t\tr_anal_save_parsed_type (a, out);\n\t}\n\tif (error_msg) {\n\t\teprintf (\"%s\", error_msg);\n\t\tfree (error_msg);\n\t}\n\n\treturn true;\n}\n\nR_API RAnalFunction *r_anal_function_next(RAnal *anal, ut64 addr) {\n\tRAnalFunction *fcni;\n\tRListIter *iter;\n\tRAnalFunction *closer = NULL;\n\tr_list_foreach (anal->fcns, iter, fcni) {\n\t\t// if (fcni->addr == addr)\n\t\tif (fcni->addr > addr && (!closer || fcni->addr < closer->addr)) {\n\t\t\tcloser = fcni;\n\t\t}\n\t}\n\treturn closer;\n}\n\nR_API int r_anal_function_count(RAnal *anal, ut64 from, ut64 to) {\n\tint n = 0;\n\tRAnalFunction *fcni;\n\tRListIter *iter;\n\tr_list_foreach (anal->fcns, iter, fcni) {\n\t\tif (fcni->addr >= from && fcni->addr < to) {\n\t\t\tn++;\n\t\t}\n\t}\n\treturn n;\n}\n\n/* return the basic block in fcn found at the given address.\n * NULL is returned if such basic block doesn't exist. */\nR_API RAnalBlock *r_anal_function_bbget_in(const RAnal *anal, RAnalFunction *fcn, ut64 addr) {\n\tr_return_val_if_fail (anal && fcn, NULL);\n\tif (addr == UT64_MAX) {\n\t\treturn NULL;\n\t}\n\tconst bool is_x86 = anal->cur->arch && !strcmp (anal->cur->arch, \"x86\");\n\tRListIter *iter;\n\tRAnalBlock *bb;\n\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\tif (addr >= bb->addr && addr < (bb->addr + bb->size)\n\t\t\t&& (!anal->opt.jmpmid || !is_x86 || r_anal_block_op_starts_at (bb, addr))) {\n\t\t\treturn bb;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API RAnalBlock *r_anal_function_bbget_at(RAnal *anal, RAnalFunction *fcn, ut64 addr) {\n\tr_return_val_if_fail (fcn && addr != UT64_MAX, NULL);\n\tRAnalBlock *b = r_anal_get_block_at (anal, addr);\n\tif (b) {\n\t\treturn b;\n\t}\n\tRListIter *iter;\n\tRAnalBlock *bb;\n\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\tif (addr == bb->addr) {\n\t\t\treturn bb;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n// compute the cyclomatic cost\nR_API ut32 r_anal_function_cost(RAnalFunction *fcn) {\n\tRListIter *iter;\n\tRAnalBlock *bb;\n\tut32 totalCycles = 0;\n\tif (!fcn) {\n\t\treturn 0;\n\t}\n\tRAnal *anal = fcn->anal;\n\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\tRAnalOp op;\n\t\tut64 at, end = bb->addr + bb->size;\n\t\tut8 *buf = malloc (bb->size);\n\t\tif (!buf) {\n\t\t\tcontinue;\n\t\t}\n\t\t(void)anal->iob.read_at (anal->iob.io, bb->addr, (ut8 *) buf, bb->size);\n\t\tint idx = 0;\n\t\tfor (at = bb->addr; at < end;) {\n\t\t\tmemset (&op, 0, sizeof (op));\n\t\t\t(void) r_anal_op (anal, &op, at, buf + idx, bb->size - idx, R_ANAL_OP_MASK_BASIC);\n\t\t\tif (op.size < 1) {\n\t\t\t\top.size = 1;\n\t\t\t}\n\t\t\tidx += op.size;\n\t\t\tat += op.size;\n\t\t\ttotalCycles += op.cycles;\n\t\t\tr_anal_op_fini (&op);\n\t\t}\n\t\tfree (buf);\n\t}\n\treturn totalCycles;\n}\n\nR_API int r_anal_function_count_edges(const RAnalFunction *fcn, R_NULLABLE int *ebbs) {\n\tr_return_val_if_fail (fcn, 0);\n\tRListIter *iter;\n\tRAnalBlock *bb;\n\tint edges = 0;\n\tif (ebbs) {\n\t\t*ebbs = 0;\n\t}\n\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\tif (ebbs && bb->jump == UT64_MAX && bb->fail == UT64_MAX) {\n\t\t\t*ebbs = *ebbs + 1;\n\t\t} else {\n\t\t\tif (bb->jump != UT64_MAX) {\n\t\t\t\tedges ++;\n\t\t\t}\n\t\t\tif (bb->fail != UT64_MAX) {\n\t\t\t\tedges ++;\n\t\t\t}\n\t\t}\n\t}\n\treturn edges;\n}\n\n\nR_API bool r_anal_function_purity(RAnalFunction *fcn) {\n\tif (fcn->has_changed) {\n\t\tHtUP *ht = ht_up_new (NULL, NULL, NULL);\n\t\tif (ht) {\n\t\t\tcheck_purity (ht, fcn);\n\t\t\tht_up_free (ht);\n\t\t}\n\t}\n\treturn fcn->is_pure;\n}\n\nstatic bool can_affect_bp(RAnal *anal, RAnalOp* op) {\n\tRAnalValue *dst = op->dst;\n\tRAnalValue *src = op->src[0];\n\tconst char *opdreg = (dst && dst->reg) ? dst->reg->name : NULL;\n\tconst char *opsreg = (src && src->reg) ? src->reg->name : NULL;\n\tconst char *bp_name = anal->reg->name[R_REG_NAME_BP];\n\tbool is_bp_dst = opdreg && !dst->memref && !strcmp (opdreg, bp_name);\n\tbool is_bp_src = opsreg && !src->memref && !strcmp (opsreg, bp_name);\n\tif (op->type == R_ANAL_OP_TYPE_XCHG) {\n\t\treturn is_bp_src || is_bp_dst;\n\t}\n\treturn is_bp_dst;\n}\n\n/*\n * This function checks whether any operation in a given function may change bp (excluding \"mov bp, sp\"\n * and \"pop bp\" at the end).\n */\nstatic void __anal_fcn_check_bp_use(RAnal *anal, RAnalFunction *fcn) {\n\tRListIter *iter;\n\tRAnalBlock *bb;\n\tchar *pos;\n\tchar str_to_find[40];\n\tsnprintf (str_to_find, sizeof (str_to_find),\n\t\t\"\\\"type\\\":\\\"reg\\\",\\\"value\\\":\\\"%s\", anal->reg->name[R_REG_NAME_BP]);\n\tif (!fcn) {\n\t\treturn;\n\t}\n\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\tRAnalOp op;\n\t\tut64 at, end = bb->addr + bb->size;\n\t\tut8 *buf = malloc (bb->size);\n\t\tif (!buf) {\n\t\t\tcontinue;\n\t\t}\n\t\t(void)anal->iob.read_at (anal->iob.io, bb->addr, (ut8 *) buf, bb->size);\n\t\tint idx = 0;\n\t\tfor (at = bb->addr; at < end;) {\n\t\t\tr_anal_op (anal, &op, at, buf + idx, bb->size - idx, R_ANAL_OP_MASK_VAL | R_ANAL_OP_MASK_OPEX);\n\t\t\tif (op.size < 1) {\n\t\t\t\top.size = 1;\n\t\t\t}\n\t\t\tswitch (op.type) {\n\t\t\tcase R_ANAL_OP_TYPE_MOV:\n\t\t\tcase R_ANAL_OP_TYPE_LEA:\n\t\t\t\tif (can_affect_bp (anal, &op) && op.src[0] && op.src[0]->reg && op.src[0]->reg->name\n\t\t\t\t&& strcmp (op.src[0]->reg->name, anal->reg->name[R_REG_NAME_SP])) {\n\t\t\t\t\tfcn->bp_frame = false;\n\t\t\t\t\tr_anal_op_fini (&op);\n\t\t\t\t\tfree (buf);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_OP_TYPE_ADD:\n\t\t\tcase R_ANAL_OP_TYPE_AND:\n\t\t\tcase R_ANAL_OP_TYPE_CMOV:\n\t\t\tcase R_ANAL_OP_TYPE_NOT:\n\t\t\tcase R_ANAL_OP_TYPE_OR:\n\t\t\tcase R_ANAL_OP_TYPE_ROL:\n\t\t\tcase R_ANAL_OP_TYPE_ROR:\n\t\t\tcase R_ANAL_OP_TYPE_SAL:\n\t\t\tcase R_ANAL_OP_TYPE_SAR:\n\t\t\tcase R_ANAL_OP_TYPE_SHR:\n\t\t\tcase R_ANAL_OP_TYPE_SUB:\n\t\t\tcase R_ANAL_OP_TYPE_XOR:\n\t\t\tcase R_ANAL_OP_TYPE_SHL:\n// op.dst is not filled for these operations, so for now, check for bp as dst looks like this; in the future it may be just replaced with call to can_affect_bp\n \t\t\t\tpos = op.opex.ptr ? strstr (op.opex.ptr, str_to_find) : NULL;\n\t\t\t\tif (pos && pos - op.opex.ptr < 60) {\n\t\t\t\t\tfcn->bp_frame = false;\n\t\t\t\t\tr_anal_op_fini (&op);\n\t\t\t\t\tfree (buf);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_OP_TYPE_XCHG:\n\t\t\t\tif (op.opex.ptr && strstr (op.opex.ptr, str_to_find)) {\n\t\t\t\t\tfcn->bp_frame = false;\n\t\t\t\t\tr_anal_op_fini (&op);\n\t\t\t\t\tfree (buf);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_OP_TYPE_POP:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tidx += op.size;\n\t\t\tat += op.size;\n\t\t\tr_anal_op_fini (&op);\n\t\t}\n\t\tfree (buf);\n\t}\n}\n\nR_API void r_anal_function_check_bp_use(RAnalFunction *fcn) {\n\tr_return_if_fail (fcn);\n\t__anal_fcn_check_bp_use (fcn->anal, fcn);\n}\n\ntypedef struct {\n\tRAnalFunction *fcn;\n\tHtUP *visited;\n} BlockRecurseCtx;\n\nstatic bool mark_as_visited(RAnalBlock *bb, void *user) {\n\tBlockRecurseCtx *ctx = user;\n\tht_up_insert (ctx->visited, bb->addr, NULL);\n\treturn true;\n}\n\nstatic bool analize_addr_cb(ut64 addr, void *user) {\n\tBlockRecurseCtx *ctx = user;\n\tRAnal *anal = ctx->fcn->anal;\n\tRAnalBlock *existing_bb = r_anal_get_block_at (anal, addr);\n\tif (!existing_bb || !r_list_contains (ctx->fcn->bbs, existing_bb)) {\n\t\tint old_len = r_list_length (ctx->fcn->bbs);\n\t\tr_anal_function_bb (ctx->fcn->anal, ctx->fcn, addr, anal->opt.depth);\n\t\tif (old_len != r_list_length (ctx->fcn->bbs)) {\n\t\t\tr_anal_block_recurse (r_anal_get_block_at (anal, addr), mark_as_visited, user);\n\t\t}\n\t}\n\tht_up_insert (ctx->visited, addr, NULL);\n\treturn true;\n}\n\nstatic bool analize_descendents(RAnalBlock *bb, void *user) {\n\treturn r_anal_block_successor_addrs_foreach (bb, analize_addr_cb, user);\n}\n\nstatic void free_ht_up(HtUPKv *kv) {\n\tht_up_free ((HtUP *)kv->value);\n}\n\nstatic void update_var_analysis(RAnalFunction *fcn, int align, ut64 from, ut64 to) {\n\tRAnal *anal = fcn->anal;\n\tut64 cur_addr;\n\tint opsz;\n\tfrom = align ? from - (from % align) : from;\n\tto = align ? R_ROUND (to, align) : to;\n\tif (UT64_SUB_OVFCHK (to, from)) {\n\t\treturn;\n\t}\n\tut64 len = to - from;\n\tut8 *buf = malloc (len);\n\tif (!buf) {\n\t\treturn;\n\t}\n\tif (anal->iob.read_at (anal->iob.io, from, buf, len) < len) {\n\t\treturn;\n\t}\n\tfor (cur_addr = from; cur_addr < to; cur_addr += opsz, len -= opsz) {\n\t\tRAnalOp op;\n\t\tint ret = r_anal_op (anal->coreb.core, &op, cur_addr, buf, len, R_ANAL_OP_MASK_ESIL | R_ANAL_OP_MASK_VAL);\n\t\tif (ret < 1 || op.size < 1) {\n\t\t\tr_anal_op_fini (&op);\n\t\t\tbreak;\n\t\t}\n\t\topsz = op.size;\n\t\tr_anal_extract_vars (anal, fcn, &op);\n\t\tr_anal_op_fini (&op);\n\t}\n\tfree (buf);\n}\n\n// Clear function variable acesses inside in a block\nstatic void clear_bb_vars(RAnalFunction *fcn, RAnalBlock *bb, ut64 from, ut64 to) {\n\tint i;\n\tif (r_pvector_empty (&fcn->vars)) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < bb->ninstr; i++) {\n\t\tconst ut64 addr = r_anal_bb_opaddr_i (bb, i);\n\t\tif (addr < from) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (addr >= to || addr == UT64_MAX) {\n\t\t\tbreak;\n\t\t}\n\t\tRPVector *vars = r_anal_function_get_vars_used_at (fcn, addr);\n\t\tif (vars) {\n\t\t\tRPVector *vars_clone = (RPVector *)r_vector_clone ((RVector *)vars);\n\t\t\tvoid **v;\n\t\t\tr_pvector_foreach (vars_clone, v) {\n\t\t\t\tr_anal_var_remove_access_at ((RAnalVar *)*v, addr);\n\t\t\t}\n\t\t\tr_pvector_clear (vars_clone);\n\t\t}\n\t}\n}\n\nstatic void update_analysis(RAnal *anal, RList *fcns, HtUP *reachable) {\n\t// huge slowdown\n\tRListIter *it, *it2, *tmp;\n\tRAnalFunction *fcn;\n\tbool old_jmpmid = anal->opt.jmpmid;\n\tanal->opt.jmpmid = true;\n\tr_anal_function_invalidate_read_ahead_cache ();\n\tr_list_foreach (fcns, it, fcn) {\n\t\t// Recurse through blocks of function, mark reachable,\n\t\t// analyze edges that don't have a block\n\t\tRAnalBlock *bb = r_anal_get_block_at (anal, fcn->addr);\n\t\tif (!bb) {\n\t\t\tr_anal_function_bb (anal, fcn, fcn->addr, anal->opt.depth);\n\t\t\tbb = r_anal_get_block_at (anal, fcn->addr);\n\t\t\tif (!bb) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tHtUP *ht = ht_up_new0 ();\n\t\tht_up_insert (ht, bb->addr, NULL);\n\t\tBlockRecurseCtx ctx = { fcn, ht };\n\t\tr_anal_block_recurse (bb, analize_descendents, &ctx);\n\n\t\t// Remove non-reachable blocks\n\t\tr_list_foreach_safe (fcn->bbs, it2, tmp, bb) {\n\t\t\tif (ht_up_find_kv (ht, bb->addr, NULL)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tHtUP *o_visited = ht_up_find (reachable, fcn->addr, NULL);\n\t\t\tif (!ht_up_find_kv (o_visited, bb->addr, NULL)) {\n\t\t\t\t// Avoid removing blocks that were already not reachable\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfcn->ninstr -= bb->ninstr;\n\t\t\tr_anal_function_remove_block (fcn, bb);\n\t\t}\n\t\t\n\t\tRList *bbs = r_list_clone (fcn->bbs);\n\t\tr_anal_block_automerge (bbs);\n\t\tr_anal_function_delete_unused_vars (fcn);\n\t\tr_list_free (bbs);\n\t}\n\tanal->opt.jmpmid = old_jmpmid;\n}\n\nstatic void calc_reachable_and_remove_block(RList *fcns, RAnalFunction *fcn, RAnalBlock *bb, HtUP *reachable) {\n\tclear_bb_vars (fcn, bb, bb->addr, bb->addr + bb->size);\n\tif (!r_list_contains (fcns, fcn)) {\n\t\tr_list_append (fcns, fcn);\n\t\t\n\t\t// Calculate reachable blocks from the start of function\n\t\tHtUP *ht = ht_up_new0 ();\n\t\tBlockRecurseCtx ctx = { fcn, ht };\n\t\tr_anal_block_recurse (r_anal_get_block_at (fcn->anal, fcn->addr), mark_as_visited, &ctx);\n\t\tht_up_insert (reachable, fcn->addr, ht);\n\t}\n\tfcn->ninstr -= bb->ninstr;\n\tr_anal_function_remove_block (fcn, bb);\n}\n\nR_API void r_anal_update_analysis_range(RAnal *anal, ut64 addr, int size) {\n\tr_return_if_fail (anal);\n\tRListIter *it, *it2, *tmp;\n\tRAnalBlock *bb;\n\tRAnalFunction *fcn;\n\tRList *blocks = r_anal_get_blocks_intersect (anal, addr, size);\n\tif (r_list_empty (blocks)) {\n\t\tr_list_free (blocks);\n\t\treturn;\n\t}\n\tRList *fcns = r_list_new ();\n\tHtUP *reachable = ht_up_new (NULL, free_ht_up, NULL);\n\tconst int align = r_anal_archinfo (anal, R_ANAL_ARCHINFO_ALIGN);\n\tconst ut64 end_write = addr + size;\n\t\n\tr_list_foreach (blocks, it, bb) {\n\t\tif (!r_anal_block_was_modified (bb)) {\n\t\t\tcontinue;\n\t\t}\n\t\tr_list_foreach_safe (bb->fcns, it2, tmp, fcn) {\t\t\t\n\t\t\tif (align > 1) {\n\t\t\t\tif ((end_write < r_anal_bb_opaddr_i (bb, bb->ninstr - 1))\n\t\t\t\t\t&& (!bb->switch_op || end_write < bb->switch_op->addr)) {\n\t\t\t\t\t// Special case when instructions are aligned and we don't\n\t\t\t\t\t// need to worry about a write messing with the jump instructions\n\t\t\t\t\tclear_bb_vars (fcn, bb, addr > bb->addr ? addr : bb->addr, end_write);\n\t\t\t\t\tupdate_var_analysis (fcn, align, addr > bb->addr ? addr : bb->addr, end_write);\n\t\t\t\t\tr_anal_function_delete_unused_vars (fcn);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcalc_reachable_and_remove_block (fcns, fcn, bb, reachable);\n\t\t}\n\t}\n\tr_list_free (blocks); // This will call r_anal_block_unref to actually remove blocks from RAnal\n\tupdate_analysis (anal, fcns, reachable);\n\tht_up_free (reachable);\n\tr_list_free (fcns);\n}\n\nR_API void r_anal_function_update_analysis(RAnalFunction *fcn) {\n\tr_return_if_fail (fcn);\n\tRListIter *it, *it2, *tmp, *tmp2;\n\tRAnalBlock *bb;\n\tRAnalFunction *f;\n\tRList *fcns = r_list_new ();\n\tHtUP *reachable = ht_up_new (NULL, free_ht_up, NULL);\n\tr_list_foreach_safe (fcn->bbs, it, tmp, bb) {\n\t\tif (r_anal_block_was_modified (bb)) {\n\t\t\tr_list_foreach_safe (bb->fcns, it2, tmp2, f) {\n\t\t\t\tcalc_reachable_and_remove_block (fcns, f, bb, reachable);\n\t\t\t}\n\t\t}\n\t}\n\tupdate_analysis (fcn->anal, fcns, reachable);\n\tht_up_free (reachable);\n\tr_list_free (fcns);\n}\n", "/* radare - LGPL - Copyright 2010-2020 - pancake, oddcoder */\n\n#include <r_anal.h>\n#include <r_util.h>\n#include <r_cons.h>\n#include <r_core.h>\n#include <r_list.h>\n\n#define ACCESS_CMP(x, y) ((st64)((ut64)(x) - ((RAnalVarAccess *)y)->offset))\n\nR_API bool r_anal_var_display(RAnal *anal, RAnalVar *var) {\n\tchar *fmt = r_type_format (anal->sdb_types, var->type);\n\tRRegItem *i;\n\tif (!fmt) {\n\t\teprintf (\"type:%s doesn't exist\\n\", var->type);\n\t\treturn false;\n\t}\n\tbool usePxr = !strcmp (var->type, \"int\"); // hacky but useful\n\tswitch (var->kind) {\n\tcase R_ANAL_VAR_KIND_REG:\n\t\ti = r_reg_index_get (anal->reg, var->delta);\n\t\tif (i) {\n\t\t\tif (usePxr) {\n\t\t\t\tanal->cb_printf (\"pxr $w @r:%s\\n\", i->name);\n\t\t\t} else {\n\t\t\t\tanal->cb_printf (\"pf r (%s)\\n\", i->name);\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"register not found\\n\");\n\t\t}\n\t\tbreak;\n\tcase R_ANAL_VAR_KIND_BPV: {\n\t\tconst st32 real_delta = var->delta + var->fcn->bp_off;\n\t\tconst ut32 udelta = R_ABS (real_delta);\n\t\tconst char sign = real_delta >= 0 ? '+' : '-';\n\t\tif (usePxr) {\n\t\t\tanal->cb_printf (\"pxr $w @%s%c0x%x\\n\", anal->reg->name[R_REG_NAME_BP], sign, udelta);\n\t\t} else {\n\t\t\tanal->cb_printf (\"pf %s @%s%c0x%x\\n\", fmt, anal->reg->name[R_REG_NAME_BP], sign, udelta);\n\t\t}\n\t}\n\t\tbreak;\n\tcase R_ANAL_VAR_KIND_SPV: {\n\t\tut32 udelta = R_ABS (var->delta + var->fcn->maxstack);\n\t\tif (usePxr) {\n\t\t\tanal->cb_printf (\"pxr $w @%s+0x%x\\n\", anal->reg->name[R_REG_NAME_SP], udelta);\n\t\t} else {\n\t\t\tanal->cb_printf (\"pf %s @ %s+0x%x\\n\", fmt, anal->reg->name[R_REG_NAME_SP], udelta);\n\t\t}\n\t\tbreak;\n\t}\n\t}\n\tfree (fmt);\n\treturn true;\n}\n\nstatic const char *__int_type_from_size(int size) {\n\tswitch (size) {\n\tcase 1: return \"int8_t\";\n\tcase 2: return \"int16_t\";\n\tcase 4: return \"int32_t\";\n\tcase 8: return \"int64_t\";\n\tdefault: return NULL;\n\t}\n}\n\nR_API bool r_anal_function_rebase_vars(RAnal *a, RAnalFunction *fcn) {\n\tr_return_val_if_fail (a && fcn, false);\n\tRListIter *it;\n\tRAnalVar *var;\n\tRList *var_list = r_anal_var_all_list (a, fcn);\n\tr_return_val_if_fail (var_list, false);\n\n\tr_list_foreach (var_list, it, var) {\n\t\t// Resync delta in case the registers list changed\n\t\tif (var->isarg && var->kind == 'r') {\n\t\t\tRRegItem *reg = r_reg_get (a->reg, var->regname, -1);\n\t\t\tif (reg) {\n\t\t\t\tif (var->delta != reg->index) {\n\t\t\t\t\tvar->delta = reg->index;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tr_list_free (var_list);\n\treturn true;\n}\n\n// If the type of var is a struct,\n// remove all other vars that are overlapped by var and are at the offset of one of its struct members\nstatic void shadow_var_struct_members(RAnalVar *var) {\n\tSdb *TDB = var->fcn->anal->sdb_types;\n\tconst char *type_kind = sdb_const_get (TDB, var->type, 0);\n\tif (type_kind && r_str_startswith (type_kind, \"struct\")) {\n\t\tchar *field;\n\t\tint field_n;\n\t\tchar *type_key = r_str_newf (\"%s.%s\", type_kind, var->type);\n\t\tfor (field_n = 0; (field = sdb_array_get (TDB, type_key, field_n, NULL)); field_n++) {\n\t\t\tchar field_key[0x300];\n\t\t\tif (snprintf (field_key, sizeof (field_key), \"%s.%s\", type_key, field) < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tchar *field_type = sdb_array_get (TDB, field_key, 0, NULL);\n\t\t\tut64 field_offset = sdb_array_get_num (TDB, field_key, 1, NULL);\n\t\t\tif (field_offset != 0) { // delete variables which are overlaid by structure\n\t\t\t\tRAnalVar *other = r_anal_function_get_var (var->fcn, var->kind, var->delta + field_offset);\n\t\t\t\tif (other && other != var) {\n\t\t\t\t\tr_anal_var_delete (other);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree (field_type);\n\t\t\tfree (field);\n\t\t}\n\t\tfree (type_key);\n\t}\n}\n\nstatic bool inline valid_var_kind(char kind) {\n\tswitch (kind) {\n\tcase R_ANAL_VAR_KIND_BPV: // base pointer var/args\n\tcase R_ANAL_VAR_KIND_SPV: // stack pointer var/args\n\tcase R_ANAL_VAR_KIND_REG: // registers args\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nR_API RAnalVar *r_anal_function_set_var(RAnalFunction *fcn, int delta, char kind, R_NULLABLE const char *type, int size, bool isarg, R_NONNULL const char *name) {\n\tr_return_val_if_fail (fcn && name, NULL);\n\tRAnalVar *existing = r_anal_function_get_var_byname (fcn, name);\n\tif (existing && (existing->kind != kind || existing->delta != delta)) {\n\t\t// var name already exists at a different kind+delta\n\t\treturn NULL;\n\t}\n\tRRegItem *reg = NULL;\n\tif (!kind) {\n\t\tkind = R_ANAL_VAR_KIND_BPV;\n\t}\n\tif (!type) {\n\t\ttype = __int_type_from_size (size);\n\t\tif (!type) {\n\t\t\ttype = __int_type_from_size (fcn->anal->bits);\n\t\t}\n\t\tif (!type) {\n\t\t\ttype = \"int32_t\";\n\t\t}\n\t}\n\tif (!valid_var_kind (kind)) {\n\t\teprintf (\"Invalid var kind '%c'\\n\", kind);\n\t\treturn NULL;\n\t}\n\tif (kind == R_ANAL_VAR_KIND_REG) {\n\t\treg = r_reg_index_get (fcn->anal->reg, R_ABS (delta));\n\t\tif (!reg) {\n\t\t\tif (fcn->anal->verbose) {\n\t\t\t\teprintf (\"No register at index %d\\n\", delta);\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tRAnalVar *var = r_anal_function_get_var (fcn, kind, delta);\n\tif (!var) {\n\t\tvar = R_NEW0 (RAnalVar);\n\t\tif (!var) {\n\t\t\treturn NULL;\n\t\t}\n\t\tr_pvector_push (&fcn->vars, var);\n\t\tvar->fcn = fcn;\n\t\tr_vector_init (&var->accesses, sizeof (RAnalVarAccess), NULL, NULL);\n\t\tr_vector_init (&var->constraints, sizeof (RAnalVarConstraint), NULL, NULL);\n\t} else {\n\t\tfree (var->name);\n\t\tfree (var->regname);\n\t\tfree (var->type);\n\t}\n\tR_DIRTY (fcn->anal);\n\tvar->name = strdup (name);\n\tvar->regname = reg? strdup (reg->name): NULL; // TODO: no strdup here? pool? or not keep regname at all?\n\tvar->type = strdup (type);\n\tvar->kind = kind;\n\tvar->isarg = isarg;\n\tvar->delta = delta;\n\tshadow_var_struct_members (var);\n\treturn var;\n}\n\nR_API bool r_anal_function_set_var_prot(RAnalFunction *fcn, RList *l) {\n\tRListIter *iter;\n\tRAnalVarProt *vp;\n\tr_list_foreach (l, iter, vp) {\n\t\tif (!r_anal_function_set_var (fcn, vp->delta, vp->kind, vp->type, -1, vp->isarg, vp->name)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tR_DIRTY (fcn->anal);\n\treturn true;\n}\n\nR_API void r_anal_var_set_type(RAnalVar *var, const char *type) {\n\tchar *nt = strdup (type);\n\tif (!nt) {\n\t\treturn;\n\t}\n\tfree (var->type);\n\tvar->type = nt;\n\tshadow_var_struct_members (var);\n}\n\nstatic void var_free(RAnalVar *var) {\n\tif (var) {\n\t\tr_anal_var_clear_accesses (var);\n\t\tr_vector_fini (&var->constraints);\n\t\tfree (var->name);\n\t\tfree (var->regname);\n\t\tfree (var->type);\n\t\tfree (var->comment);\n\t\tfree (var);\n\t}\n}\n\nstatic void r_anal_var_proto_free(RAnalVarProt *vp) {\n\tif (vp) {\n\t\tfree (vp->name);\n\t\tfree (vp->type);\n\t\tfree (vp);\n\t}\n}\n\nR_API void r_anal_var_delete(RAnalVar *var) {\n\tr_return_if_fail (var);\n\tRAnalFunction *fcn = var->fcn;\n\tsize_t i;\n\tfor (i = 0; i < r_pvector_len (&fcn->vars); i++) {\n\t\tRAnalVar *v = r_pvector_at (&fcn->vars, i);\n\t\tif (v == var) {\n\t\t\tr_pvector_remove_at (&fcn->vars, i);\n\t\t\tvar_free (v);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nR_API void r_anal_function_delete_vars_by_kind(RAnalFunction *fcn, RAnalVarKind kind) {\n\tr_return_if_fail (fcn);\n\tsize_t i;\n\tfor (i = 0; i < r_pvector_len (&fcn->vars);) {\n\t\tRAnalVar *var = r_pvector_at (&fcn->vars, i);\n\t\tif (var->kind == kind) {\n\t\t\tr_pvector_remove_at (&fcn->vars, i);\n\t\t\tvar_free (var);\n\t\t\tcontinue;\n\t\t}\n\t\ti++;\n\t}\n}\n\nR_API void r_anal_function_delete_all_vars(RAnalFunction *fcn) {\n\tr_return_if_fail (fcn);\n\tif (fcn->vars.v.len > 0) {\n\t\tvoid **it;\n\t\tr_pvector_foreach (&fcn->vars, it) {\n\t\t\tvar_free (*it);\n\t\t}\n\t}\n\tr_pvector_clear (&fcn->vars);\n}\n\nR_API void r_anal_function_delete_unused_vars(RAnalFunction *fcn) {\n\tr_return_if_fail (fcn);\n\tvoid **v;\n\tRPVector *vars_clone = (RPVector *)r_vector_clone ((RVector *)&fcn->vars);\n\tr_pvector_foreach (vars_clone, v) {\n\t\tRAnalVar *var = *v;\n\t\tif (r_vector_empty (&var->accesses)) {\n\t\t\tr_anal_function_delete_var (fcn, var);\n\t\t}\n\t}\n\tr_pvector_free (vars_clone);\n}\n\nR_API void r_anal_function_delete_var(RAnalFunction *fcn, RAnalVar *var) {\n\tr_return_if_fail (fcn && var);\n\tr_pvector_remove_data (&fcn->vars, var);\n\tvar_free (var);\n}\n\nR_API RList *r_anal_var_deserialize(const char *ser) {\n\tr_return_val_if_fail (ser, NULL);\n\tRList *ret = r_list_newf ((RListFree)r_anal_var_proto_free);\n\twhile (*ser) {\n\t\tRAnalVarProt *v = R_NEW0 (RAnalVarProt);\n\t\tr_list_append (ret, v);\n\t\tif (!v) {\n\t\t\tgoto bad_serial;\n\t\t}\n\n\t\t// isarg\n\t\tswitch (*ser) {\n\t\tcase 't':\n\t\t\tv->isarg = true;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tv->isarg = false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto bad_serial;\n\t\t}\n\t\tser++;\n\n\t\t// kind\n\t\tif (!valid_var_kind (*ser)) {\n\t\t\tgoto bad_serial;\n\t\t}\n\t\tv->kind = *ser++;\n\n\t\t// delta\n\t\tchar *nxt;\n\t\tv->delta = strtol (ser, &nxt, 10);\n\t\tif ((!v->delta && nxt == ser) || *nxt != ':') {\n\t\t\tgoto bad_serial;\n\t\t}\n\t\tser = ++nxt;\n\n\t\t// name\n\t\tint i;\n\t\tfor (i = 0; *nxt != ':'; i++) {\n\t\t\tif (*nxt == ',' || !*nxt) {\n\t\t\t\tgoto bad_serial;\n\t\t\t}\n\t\t\tnxt++;\n\t\t}\n\t\tv->name = r_str_newlen (ser, i);\n\t\tif (!v->name) {\n\t\t\tgoto bad_serial;\n\t\t}\n\t\tser = ++nxt;\n\n\t\t// type\n\t\tfor (i = 0; *nxt && *nxt != ','; i++) {\n\t\t\tnxt++;\n\t\t}\n\t\tv->type = r_str_newlen (ser, i);\n\t\tif (!v->type) {\n\t\t\tgoto bad_serial;\n\t\t}\n\t\tser = nxt;\n\t\tif (*ser == ',') {\n\t\t\tser++;\n\t\t}\n\t\twhile (*ser == ' ') {\n\t\t\tser++;\n\t\t}\n\t}\n\treturn ret;\nbad_serial:\n\tr_list_free (ret);\n\treturn NULL;\n}\n\nstatic inline void sanitize_var_serial(char *name, bool colon) {\n\tr_return_if_fail (name);\n\tfor (; *name; name++) {\n\t\tswitch (*name) {\n\t\tcase ':':\n\t\t\tif (colon) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase '`':\n\t\tcase '$':\n\t\tcase '{':\n\t\tcase '}':\n\t\tcase '~':\n\t\tcase '|':\n\t\tcase '#':\n\t\tcase '@':\n\t\tcase '&':\n\t\tcase '<':\n\t\tcase '>':\n\t\tcase ',':\n\t\t\t*name = '_';\n\t\t\tcontinue;\n\t\t}\n\t}\n}\n\nstatic inline bool serialize_single_var(RAnalVarProt *vp, RStrBuf *sb) {\n\tr_return_val_if_fail (vp && sb, false);\n\t// shouldn't have special chars in them anyways, so replace in place\n\tsanitize_var_serial (vp->name, false);\n\tsanitize_var_serial (vp->type, true);\n\tconst char b = vp->isarg? 't': 'f';\n\tif (!valid_var_kind (vp->kind)) {\n\t\treturn false;\n\t}\n\treturn r_strbuf_appendf (sb, \"%c%c%d:%s:%s\", b, vp->kind, vp->delta, vp->name, vp->type);\n}\n\nR_API char *r_anal_var_prot_serialize(RList *l, bool spaces) {\n\tr_return_val_if_fail (l, NULL);\n\tif (l->length == 0) {\n\t\treturn NULL;\n\t}\n\n\tRStrBuf *sb = r_strbuf_new (\"\");\n\tif (!sb) {\n\t\treturn NULL;\n\t}\n\tr_strbuf_reserve (sb, r_list_length (l) * 0x10);\n\n\tchar *sep = spaces? \", \": \",\";\n\tsize_t len = strlen (sep);\n\tRAnalVarProt *v;\n\tRAnalVarProt *top = (RAnalVarProt *)r_list_get_top (l);\n\tRListIter *iter;\n\tr_list_foreach (l, iter, v) {\n\t\tif (!serialize_single_var (v, sb) || (v != top && !r_strbuf_append_n (sb, sep, len))) {\n\t\t\tr_strbuf_free (sb);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn r_strbuf_drain (sb);\n}\n\nR_API RList *r_anal_var_get_prots(RAnalFunction *fcn) {\n\tr_return_val_if_fail (fcn, NULL);\n\tRList *ret = r_list_newf ((RListFree)r_anal_var_proto_free);\n\tif (ret) {\n\t\tvoid **p;\n\t\tr_pvector_foreach (&fcn->vars, p) {\n\t\t\tRAnalVar *var = *p;\n\t\t\tRAnalVarProt *vp = R_NEW0 (RAnalVarProt);\n\t\t\tif (vp) {\n\t\t\t\tvp->isarg = var->isarg;\n\t\t\t\tvp->name = strdup (var->name);\n\t\t\t\tvp->type = strdup (var->type);\n\t\t\t\tvp->kind = var->kind;\n\t\t\t\tvp->delta = var->delta;\n\t\t\t\tr_list_append (ret, vp);\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nR_API R_BORROW RAnalVar *r_anal_function_get_var_byname(RAnalFunction *fcn, const char *name) {\n\tr_return_val_if_fail (fcn && name, NULL);\n\tvoid **it;\n\tr_pvector_foreach (&fcn->vars, it) {\n\t\tRAnalVar *var = *it;\n\t\tif (!strcmp (var->name, name)) {\n\t\t\treturn var;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API RAnalVar *r_anal_function_get_var(RAnalFunction *fcn, char kind, int delta) {\n\tr_return_val_if_fail (fcn, NULL);\n\tvoid **it;\n\tr_pvector_foreach (&fcn->vars, it) {\n\t\tRAnalVar *var = *it;\n\t\tif (var->kind == kind && var->delta == delta) {\n\t\t\treturn var;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API ut64 r_anal_var_addr(RAnalVar *var) {\n\tr_return_val_if_fail (var, UT64_MAX);\n\tRAnal *anal = var->fcn->anal;\n\tconst char *regname = NULL;\n\tif (var->kind == R_ANAL_VAR_KIND_BPV) {\n\t\tregname = r_reg_get_name (anal->reg, R_REG_NAME_BP);\n\t\treturn r_reg_getv (anal->reg, regname) + var->delta + var->fcn->bp_off;\n\t} else if (var->kind == R_ANAL_VAR_KIND_SPV) {\n\t\tregname = r_reg_get_name (anal->reg, R_REG_NAME_SP);\n\t\treturn r_reg_getv (anal->reg, regname) + var->delta;\n\t}\n\treturn 0;\n}\n\nR_API st64 r_anal_function_get_var_stackptr_at(RAnalFunction *fcn, st64 delta, ut64 addr) {\n\tst64 offset = addr - fcn->addr;\n\tRPVector *inst_accesses = ht_up_find (fcn->inst_vars, offset, NULL);\n\tif (!inst_accesses) {\n\t\treturn ST64_MAX;\n\t}\n\tRAnalVar *var = NULL;\n\tvoid **it;\n\tr_pvector_foreach (inst_accesses, it) {\n\t\tRAnalVar *v = *it;\n\t\tif (v->delta == delta) {\n\t\t\tvar = v;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!var) {\n\t\treturn ST64_MAX;\n\t}\n\tsize_t index;\n\tr_vector_lower_bound (&var->accesses, offset, index, ACCESS_CMP);\n\tRAnalVarAccess *acc = NULL;\n\tif (index < var->accesses.len) {\n\t\tacc = r_vector_index_ptr (&var->accesses, index);\n\t}\n\tif (!acc || acc->offset != offset) {\n\t\treturn ST64_MAX;\n\t}\n\treturn acc->stackptr;\n}\n\nR_API const char *r_anal_function_get_var_reg_at(RAnalFunction *fcn, st64 delta, ut64 addr) {\n\tst64 offset = addr - fcn->addr;\n\tRPVector *inst_accesses = ht_up_find (fcn->inst_vars, offset, NULL);\n\tif (!inst_accesses) {\n\t\treturn NULL;\n\t}\n\tRAnalVar *var = NULL;\n\tvoid **it;\n\tr_pvector_foreach (inst_accesses, it) {\n\t\tRAnalVar *v = *it;\n\t\tif (v->delta == delta) {\n\t\t\tvar = v;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!var) {\n\t\treturn NULL;\n\t}\n\tsize_t index;\n\tr_vector_lower_bound (&var->accesses, offset, index, ACCESS_CMP);\n\tRAnalVarAccess *acc = NULL;\n\tif (index < var->accesses.len) {\n\t\tacc = r_vector_index_ptr (&var->accesses, index);\n\t}\n\tif (!acc || acc->offset != offset) {\n\t\treturn NULL;\n\t}\n\treturn acc->reg;\n}\n\nR_API bool r_anal_var_check_name(const char *name) {\n\treturn !isdigit ((unsigned char)*name) && strcspn (name, \"., =/\");\n}\n\nR_API bool r_anal_var_rename(RAnalVar *var, const char *new_name, bool verbose) {\n\tr_return_val_if_fail (var, false);\n\tif (!r_anal_var_check_name (new_name)) {\n\t\treturn false;\n\t}\n\tRAnalVar *v1 = r_anal_function_get_var_byname (var->fcn, new_name);\n\tif (v1) {\n\t\tif (verbose) {\n\t\t\teprintf (\"variable or arg with name `%s` already exist\\n\", new_name);\n\t\t}\n\t\treturn false;\n\t}\n\tchar *nn = strdup (new_name);\n\tif (!nn) {\n\t\treturn false;\n\t}\n\tfree (var->name);\n\tvar->name = nn;\n\treturn true;\n}\n\nR_API int r_anal_var_get_argnum(RAnalVar *var) {\n\tr_return_val_if_fail (var, -1);\n\tRAnal *anal = var->fcn->anal;\n\tif (!var->isarg || var->kind != R_ANAL_VAR_KIND_REG) { // TODO: support bp and sp too\n\t\treturn -1;\n\t}\n\tif (!var->regname) {\n\t\treturn -1;\n\t}\n\tRRegItem *reg = r_reg_get (anal->reg, var->regname, -1);\n\tif (!reg) {\n\t\treturn -1;\n\t}\n\tint i;\n\tint arg_max = var->fcn->cc ? r_anal_cc_max_arg (anal, var->fcn->cc) : 0;\n\tfor (i = 0; i < arg_max; i++) {\n\t\tconst char *reg_arg = r_anal_cc_arg (anal, var->fcn->cc, i);\n\t\tif (reg_arg && !strcmp (reg->name, reg_arg)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\nR_API R_BORROW RPVector *r_anal_function_get_vars_used_at(RAnalFunction *fcn, ut64 op_addr) {\n\tr_return_val_if_fail (fcn, NULL);\n\treturn ht_up_find (fcn->inst_vars, op_addr - fcn->addr, NULL);\n}\n\nR_API R_DEPRECATE RAnalVar *r_anal_get_used_function_var(RAnal *anal, ut64 addr) {\n\tRList *fcns = r_anal_get_functions_in (anal, addr);\n\tif (!fcns) {\n\t\treturn NULL;\n\t}\n\tRAnalVar *var = NULL;\n\tRListIter *it;\n\tRAnalFunction *fcn;\n\tr_list_foreach (fcns, it, fcn) {\n\t\tRPVector *used_vars = r_anal_function_get_vars_used_at (fcn, addr);\n\t\tif (used_vars && !r_pvector_empty (used_vars)) {\n\t\t\tvar = r_pvector_at (used_vars, 0);\n\t\t\tbreak;\n\t\t}\n\t}\n\tr_list_free (fcns);\n\treturn var;\n}\n\nR_API RAnalVar *r_anal_var_get_dst_var(RAnalVar *var) {\n\tr_return_val_if_fail (var, NULL);\n\tRAnalVarAccess *acc;\n\tr_vector_foreach (&var->accesses, acc) {\n\t\tif (!(acc->type & R_ANAL_VAR_ACCESS_TYPE_READ)) {\n\t\t\tcontinue;\n\t\t}\n\t\tut64 addr = var->fcn->addr + acc->offset;\n\t\tRPVector *used_vars = r_anal_function_get_vars_used_at (var->fcn, addr);\n\t\tvoid **it;\n\t\tr_pvector_foreach (used_vars, it) {\n\t\t\tRAnalVar *used_var = *it;\n\t\t\tif (used_var == var) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRAnalVarAccess *other_acc = r_anal_var_get_access_at (used_var, addr);\n\t\t\tif (other_acc && other_acc->type & R_ANAL_VAR_ACCESS_TYPE_WRITE) {\n\t\t\t\treturn used_var;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API void r_anal_var_set_access(RAnalVar *var, const char *reg, ut64 access_addr, int access_type, st64 stackptr) {\n\tr_return_if_fail (var);\n\tst64 offset = access_addr - var->fcn->addr;\n\n\t// accesses are stored ordered by offset, use binary search to get the matching existing or the index to insert a new one\n\tsize_t index;\n\tr_vector_lower_bound (&var->accesses, offset, index, ACCESS_CMP);\n\tRAnalVarAccess *acc = NULL;\n\tif (index < var->accesses.len) {\n\t\tacc = r_vector_index_ptr (&var->accesses, index);\n\t}\n\tif (!acc || acc->offset != offset) {\n\t\tacc = r_vector_insert (&var->accesses, index, NULL);\n\t\tacc->offset = offset;\n\t\tacc->type = 0;\n\t}\n\n\tacc->type |= (ut8)access_type;\n\tacc->stackptr = stackptr;\n\tacc->reg = r_str_constpool_get (&var->fcn->anal->constpool, reg);\n\n\t// add the inverse reference from the instruction to the var\n\tRPVector *inst_accesses = ht_up_find (var->fcn->inst_vars, (ut64)offset, NULL);\n\tif (!inst_accesses) {\n\t\tinst_accesses = r_pvector_new (NULL);\n\t\tif (!inst_accesses) {\n\t\t\treturn;\n\t\t}\n\t\tht_up_insert (var->fcn->inst_vars, (ut64)offset, inst_accesses);\n\t}\n\tif (!r_pvector_contains (inst_accesses, var)) {\n\t\tr_pvector_push (inst_accesses, var);\n\t}\n}\n\nR_API void r_anal_var_remove_access_at(RAnalVar *var, ut64 address) {\n\tr_return_if_fail (var);\n\tst64 offset = address - var->fcn->addr;\n\tsize_t index;\n\tr_vector_lower_bound (&var->accesses, offset, index, ACCESS_CMP);\n\tif (index >= var->accesses.len) {\n\t\treturn;\n\t}\n\tRAnalVarAccess *acc = r_vector_index_ptr (&var->accesses, index);\n\tif (acc->offset == offset) {\n\t\tr_vector_remove_at (&var->accesses, index, NULL);\n\t\tRPVector *inst_accesses = ht_up_find (var->fcn->inst_vars, (ut64)offset, NULL);\n\t\tr_pvector_remove_data (inst_accesses, var);\n\t}\n\tR_DIRTY (var->fcn->anal);\n}\n\nR_API void r_anal_var_clear_accesses(RAnalVar *var) {\n\tr_return_if_fail (var);\n\tRAnalFunction *fcn = var->fcn;\n\tif (fcn->inst_vars) {\n\t\t// remove all inverse references to the var's accesses\n\t\tRAnalVarAccess *acc;\n\t\tr_vector_foreach (&var->accesses, acc) {\n\t\t\tRPVector *inst_accesses = ht_up_find (fcn->inst_vars, (ut64)acc->offset, NULL);\n\t\t\tif (!inst_accesses) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tr_pvector_remove_data (inst_accesses, var);\n\t\t}\n\t}\n\tr_vector_clear (&var->accesses);\n\tR_DIRTY (var->fcn->anal);\n}\n\nR_API RAnalVarAccess *r_anal_var_get_access_at(RAnalVar *var, ut64 addr) {\n\tr_return_val_if_fail (var, NULL);\n\tst64 offset = addr - var->fcn->addr;\n\tsize_t index;\n\tr_vector_lower_bound (&var->accesses, offset, index, ACCESS_CMP);\n\tif (index >= var->accesses.len) {\n\t\treturn NULL;\n\t}\n\tRAnalVarAccess *acc = r_vector_index_ptr (&var->accesses, index);\n\tif (acc->offset == offset) {\n\t\treturn acc;\n\t}\n\treturn NULL;\n}\n\nR_API void r_anal_var_add_constraint(RAnalVar *var, R_BORROW RAnalVarConstraint *constraint) {\n\tr_vector_push (&var->constraints, constraint);\n}\n\nR_API char *r_anal_var_get_constraints_readable(RAnalVar *var) {\n\tsize_t n = var->constraints.len;\n\tif (!n) {\n\t\treturn NULL;\n\t}\n\tbool low = false, high = false;\n\tRStrBuf sb;\n\tr_strbuf_init (&sb);\n\tsize_t i;\n\tfor (i = 0; i < n; i += 1) {\n\t\tRAnalVarConstraint *constr = r_vector_index_ptr (&var->constraints, i);\n\t\tswitch (constr->cond) {\n\t\tcase R_ANAL_COND_LE:\n\t\t\tif (high) {\n\t\t\t\tr_strbuf_append (&sb, \" && \");\n\t\t\t}\n\t\t\tr_strbuf_appendf (&sb, \"<= 0x%\"PFMT64x \"\", constr->val);\n\t\t\tlow = true;\n\t\t\tbreak;\n\t\tcase R_ANAL_COND_LT:\n\t\t\tif (high) {\n\t\t\t\tr_strbuf_append (&sb, \" && \");\n\t\t\t}\n\t\t\tr_strbuf_appendf (&sb, \"< 0x%\"PFMT64x \"\", constr->val);\n\t\t\tlow = true;\n\t\t\tbreak;\n\t\tcase R_ANAL_COND_GE:\n\t\t\tr_strbuf_appendf (&sb, \">= 0x%\"PFMT64x \"\", constr->val);\n\t\t\thigh = true;\n\t\t\tbreak;\n\t\tcase R_ANAL_COND_GT:\n\t\t\tr_strbuf_appendf (&sb, \"> 0x%\"PFMT64x \"\", constr->val);\n\t\t\thigh = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (low && high && i != n - 1) {\n\t\t\tr_strbuf_append (&sb, \" || \");\n\t\t\tlow = false;\n\t\t\thigh = false;\n\t\t}\n\t}\n\treturn r_strbuf_drain_nofree (&sb);\n}\n\nR_API int r_anal_var_count(RAnal *a, RAnalFunction *fcn, int kind, int type) {\n\tr_return_val_if_fail (fcn && a && type >= 0 && type <= 1, -1);\n\t// type { local: 0, arg: 1 };\n\tRList *list = r_anal_var_list (a, fcn, kind);\n\tRAnalVar *var;\n\tRListIter *iter;\n\tint count[2] = {\n\t\t0\n\t};\n\tr_list_foreach (list, iter, var) {\n\t\tif (kind == R_ANAL_VAR_KIND_REG) {\n\t\t\tcount[1]++;\n\t\t\tcontinue;\n\t\t}\n\t\tcount[var->isarg]++;\n\t}\n\tr_list_free (list);\n\treturn count[type];\n}\n\nR_API int r_anal_var_count_all(RAnalFunction *fcn) {\n\tr_return_val_if_fail (fcn, 0);\n\treturn r_pvector_len (&fcn->vars);\n}\n\nR_API int r_anal_var_count_args(RAnalFunction *fcn) {\n\tr_return_val_if_fail (fcn, 0); // No function implies no variables, but probably mistake\n\tint args = 0;\n\tvoid **it;\n\tr_pvector_foreach (&fcn->vars, it) {\n\t\tRAnalVar *var = *it;\n\t\tif (var->isarg) {\n\t\t\targs++;\n\t\t}\n\t}\n\treturn args;\n}\n\nR_API int r_anal_var_count_locals(RAnalFunction *fcn) {\n\t// if it's not an arg then it's local\n\tint args = r_anal_var_count_args (fcn);\n\treturn r_anal_var_count_all (fcn) - args;\n}\n\nstatic bool var_add_structure_fields_to_list(RAnal *a, RAnalVar *av, RList *list) {\n\tSdb *TDB = a->sdb_types;\n\tconst char *type_kind = sdb_const_get (TDB, av->type, 0);\n\tif (type_kind && !strcmp (type_kind, \"struct\")) {\n\t\tchar *field_name, *new_name;\n\t\tint field_n;\n\t\tchar *type_key = r_str_newf (\"%s.%s\", type_kind, av->type);\n\t\tfor (field_n = 0; (field_name = sdb_array_get (TDB, type_key, field_n, NULL)); field_n++) {\n\t\t\tchar *field_key = r_str_newf (\"%s.%s\", type_key, field_name);\n\t\t\tchar *field_type = sdb_array_get (TDB, field_key, 0, NULL);\n\t\t\tut64 field_offset = sdb_array_get_num (TDB, field_key, 1, NULL);\n\t\t\tnew_name = r_str_newf (\"%s.%s\", av->name, field_name);\n\t\t\tRAnalVarField *field = R_NEW0 (RAnalVarField);\n\t\t\tfield->name = new_name;\n\t\t\tfield->delta = av->delta + field_offset;\n\t\t\tfield->field = true;\n\t\t\tr_list_append (list, field);\n\t\t\tfree (field_type);\n\t\t\tfree (field_key);\n\t\t\tfree (field_name);\n\t\t}\n\t\tfree (type_key);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic const char *get_regname(RAnal *anal, RAnalValue *value) {\n\tconst char *name = NULL;\n\tif (value && value->reg && value->reg->name) {\n\t\tname = value->reg->name;\n\t\tRRegItem *ri = r_reg_get (anal->reg, value->reg->name, -1);\n\t\tif (ri && (ri->size == 32) && (anal->bits == 64)) {\n\t\t\tname = r_reg_32_to_64 (anal->reg, value->reg->name);\n\t\t}\n\t}\n\treturn name;\n}\n\nR_API R_OWN char *r_anal_function_autoname_var(RAnalFunction *fcn, char kind, const char *pfx, int ptr) {\n\tvoid **it;\n\tconst ut32 uptr = R_ABS (ptr);\n\tchar *varname = r_str_newf (\"%s_%xh\", pfx, uptr);\n\tr_pvector_foreach (&fcn->vars, it) {\n\t\tRAnalVar *var = *it;\n\t\tif (!strcmp (varname, var->name)) {\n\t\t\tif (var->kind != kind) {\n\t\t\t\tconst char *k = kind == R_ANAL_VAR_KIND_SPV ? \"sp\" : \"bp\";\n\t\t\t\tfree (varname);\n\t\t\t\tvarname = r_str_newf (\"%s_%s_%xh\", pfx, k, uptr);\n\t\t\t\treturn varname;\n\t\t\t}\n\t\t\tint i = 2;\n\t\t\tdo {\n\t\t\t\tfree (varname);\n\t\t\t\tvarname = r_str_newf (\"%s_%xh_%u\", pfx, uptr, i++);\n\t\t\t} while (r_anal_function_get_var_byname (fcn, varname));\n\t\t\treturn varname;\n\t\t}\n\t}\n\treturn varname;\n}\n\nstatic RAnalVar *get_stack_var(RAnalFunction *fcn, int delta) {\n\tvoid **it;\n\tr_pvector_foreach (&fcn->vars, it) {\n\t\tRAnalVar *var = *it;\n\t\tbool is_stack = var->kind == R_ANAL_VAR_KIND_SPV || var->kind == R_ANAL_VAR_KIND_BPV;\n\t\tif (is_stack && var->delta == delta) {\n\t\t\treturn var;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void extract_arg(RAnal *anal, RAnalFunction *fcn, RAnalOp *op, const char *reg, const char *sign, char type) {\n\tst64 ptr = 0;\n\tchar *addr, *esil_buf = NULL;\n\tconst st64 maxstackframe = 1024 * 8; \n\n\tr_return_if_fail (anal && fcn && op && reg);\n\n\tsize_t i;\n\tfor (i = 0; i < R_ARRAY_SIZE (op->src); i++) {\n\t\tif (op->src[i] && op->src[i]->reg && op->src[i]->reg->name) {\n\t\t\tif (!strcmp (reg, op->src[i]->reg->name)) {\n\t\t\t\tst64 delta = op->src[i]->delta;\n\t\t\t\tif ((delta > 0 && *sign == '+') || (delta < 0 && *sign == '-')) {\n\t\t\t\t\tptr = R_ABS (op->src[i]->delta);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!ptr) {\n\t\tconst char *op_esil = r_strbuf_get (&op->esil);\n\t\tif (!op_esil) {\n\t\t\treturn;\n\t\t}\n\t\tesil_buf = strdup (op_esil);\n\t\tif (!esil_buf) {\n\t\t\treturn;\n\t\t}\n\t\tr_strf_var (esilexpr, 64, \",%s,%s,\", reg, sign);\n\t\tchar *ptr_end = strstr (esil_buf, esilexpr);\n\t\tif (!ptr_end) {\n\t\t\tfree (esil_buf);\n\t\t\treturn;\n\t\t}\n\t\t*ptr_end = 0;\n\t\taddr = ptr_end;\n\t\twhile ((addr[0] != '0' || addr[1] != 'x') && addr >= esil_buf + 1 && *addr != ',') {\n\t\t\taddr--;\n\t\t}\n\t\tif (strncmp (addr, \"0x\", 2)) {\n\t\t\t//XXX: This is a workaround for inconsistent esil\n\t\t\tif (!op->stackop && op->dst) {\n\t\t\t\tconst char *sp = r_reg_get_name (anal->reg, R_REG_NAME_SP);\n\t\t\t\tconst char *bp = r_reg_get_name (anal->reg, R_REG_NAME_BP);\n\t\t\t\tconst char *rn = op->dst->reg ? op->dst->reg->name : NULL;\n\t\t\t\tif (rn && ((bp && !strcmp (bp, rn)) || (sp && !strcmp (sp, rn)))) {\n\t\t\t\t\tif (anal->verbose) {\n\t\t\t\t\t\teprintf (\"Warning: Analysis didn't fill op->stackop for instruction that alters stack at 0x%\" PFMT64x \".\\n\", op->addr);\n\t\t\t\t\t}\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (*addr == ',') {\n\t\t\t\taddr++;\n\t\t\t}\n\t\t\tif (!op->stackop && op->type != R_ANAL_OP_TYPE_PUSH && op->type != R_ANAL_OP_TYPE_POP\n\t\t\t\t&& op->type != R_ANAL_OP_TYPE_RET && r_str_isnumber (addr)) {\n\t\t\t\tptr = (st64)r_num_get (NULL, addr);\n\t\t\t\tif (ptr && op->src[0] && ptr == op->src[0]->imm) {\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t} else if ((op->stackop == R_ANAL_STACK_SET) || (op->stackop == R_ANAL_STACK_GET)) {\n\t\t\t\tif (op->ptr % 4) {\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tptr = R_ABS (op->ptr);\n\t\t\t} else {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t} else {\n\t\t\tptr = (st64)r_num_get (NULL, addr);\n\t\t}\n\t}\n\n\tif (anal->verbose && (!op->src[0] || !op->dst)) {\n\t\teprintf (\"Warning: Analysis didn't fill op->src/dst at 0x%\" PFMT64x \".\\n\", op->addr);\n\t}\n\n\tint rw = (op->direction == R_ANAL_OP_DIR_WRITE) ? R_ANAL_VAR_ACCESS_TYPE_WRITE : R_ANAL_VAR_ACCESS_TYPE_READ;\n\tif (*sign == '+') {\n\t\tconst bool isarg = type == R_ANAL_VAR_KIND_SPV ? ptr >= fcn->stack : ptr >= fcn->bp_off;\n\t\tconst char *pfx = isarg ? ARGPREFIX : VARPREFIX;\n\t\tst64 frame_off;\n\t\tif (type == R_ANAL_VAR_KIND_SPV) {\n\t\t\tframe_off = ptr - fcn->stack;\n\t\t} else {\n\t\t\tframe_off = ptr - fcn->bp_off;\n\t\t}\n\t\tif (maxstackframe != 0 && (frame_off > maxstackframe || frame_off < -maxstackframe)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tRAnalVar *var = get_stack_var (fcn, frame_off);\n\t\tif (var) {\n\t\t\tr_anal_var_set_access (var, reg, op->addr, rw, ptr);\n\t\t\tgoto beach;\n\t\t}\n\t\tchar *varname = NULL, *vartype = NULL;\n\t\tif (isarg) {\n\t\t\tconst char *place = fcn->cc ? r_anal_cc_arg (anal, fcn->cc, ST32_MAX) : NULL;\n\t\t\tbool stack_rev = place ? !strcmp (place, \"stack_rev\") : false;\n\t\t\tchar *fname = r_type_func_guess (anal->sdb_types, fcn->name);\n\t\t\tif (fname) {\n\t\t\t\tut64 sum_sz = 0;\n\t\t\t\tsize_t from, to, i;\n\t\t\t\tif (stack_rev) {\n\t\t\t\t\tconst size_t cnt = r_type_func_args_count (anal->sdb_types, fname);\n\t\t\t\t\tfrom = cnt ? cnt - 1 : cnt;\n\t\t\t\t\tto = fcn->cc ? r_anal_cc_max_arg (anal, fcn->cc) : 0;\n\t\t\t\t} else {\n\t\t\t\t\tfrom = fcn->cc ? r_anal_cc_max_arg (anal, fcn->cc) : 0;\n\t\t\t\t\tto = r_type_func_args_count (anal->sdb_types, fname);\n\t\t\t\t}\n\t\t\t\tconst int bytes = (fcn->bits ? fcn->bits : anal->bits) / 8;\n\t\t\t\tfor (i = from; stack_rev ? i >= to : i < to; stack_rev ? i-- : i++) {\n\t\t\t\t\tchar *tp = r_type_func_args_type (anal->sdb_types, fname, i);\n\t\t\t\t\tif (!tp) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (sum_sz == frame_off) {\n\t\t\t\t\t\tvartype = tp;\n\t\t\t\t\t\tvarname = strdup (r_type_func_args_name (anal->sdb_types, fname, i));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tut64 bit_sz = r_type_get_bitsize (anal->sdb_types, tp);\n\t\t\t\t\tsum_sz += bit_sz ? bit_sz / 8 : bytes;\n\t\t\t\t\tsum_sz = R_ROUND (sum_sz, bytes);\n\t\t\t\t\tfree (tp);\n\t\t\t\t}\n\t\t\t\tfree (fname);\n\t\t\t}\n\t\t}\n\t\tif (!varname) {\n\t\t\tif (anal->opt.varname_stack) {\n\t\t\t\tvarname = r_str_newf (\"%s_%\" PFMT64x \"h\", pfx, R_ABS (frame_off));\n\t\t\t} else {\n\t\t\t\tvarname = r_anal_function_autoname_var (fcn, type, pfx, ptr);\n\t\t\t}\n\t\t}\n\t\tif (varname) {\n#if 0\n\t\t\tif (isarg && frame_off > 48) {\n\t\t\t\tfree (varname);\n\t\t\t\tgoto beach;\n\t\t\t}\n#endif\n\t\t\tRAnalVar *var = r_anal_function_set_var (fcn, frame_off, type, vartype, anal->bits / 8, isarg, varname);\n\t\t\tif (var) {\n\t\t\t\tr_anal_var_set_access (var, reg, op->addr, rw, ptr);\n\t\t\t}\n\t\t\tfree (varname);\n\t\t}\n\t\tfree (vartype);\n\t} else {\n\t\tst64 frame_off = -(ptr + fcn->bp_off);\n\t\tif (maxstackframe > 0 && (frame_off > maxstackframe || frame_off < -maxstackframe)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tRAnalVar *var = get_stack_var (fcn, frame_off);\n\t\tif (var) {\n\t\t\tr_anal_var_set_access (var, reg, op->addr, rw, -ptr);\n\t\t\tgoto beach;\n\t\t}\n\t\tchar *varname = anal->opt.varname_stack\n\t\t\t? r_str_newf (\"%s_%\" PFMT64x \"h\", VARPREFIX, R_ABS (frame_off))\n\t\t\t: r_anal_function_autoname_var (fcn, type, VARPREFIX, -ptr);\n\t\tif (varname) {\n\t\t\tRAnalVar *var = r_anal_function_set_var (fcn, frame_off, type, NULL, anal->bits / 8, false, varname);\n\t\t\tif (var) {\n\t\t\t\tr_anal_var_set_access (var, reg, op->addr, rw, -ptr);\n\t\t\t}\n\t\t\tfree (varname);\n\t\t}\n\t}\nbeach:\n\tfree (esil_buf);\n}\n\nstatic bool is_reg_in_src(const char *regname, RAnal *anal, RAnalOp *op);\n\nstatic inline bool op_affect_dst(RAnalOp* op) {\n\tswitch (op->type) {\n\tcase R_ANAL_OP_TYPE_ADD:\n\tcase R_ANAL_OP_TYPE_SUB:\n\tcase R_ANAL_OP_TYPE_MUL:\n\tcase R_ANAL_OP_TYPE_DIV:\n\tcase R_ANAL_OP_TYPE_SHR:\n\tcase R_ANAL_OP_TYPE_SHL:\n\tcase R_ANAL_OP_TYPE_SAL:\n\tcase R_ANAL_OP_TYPE_SAR:\n\tcase R_ANAL_OP_TYPE_OR:\n\tcase R_ANAL_OP_TYPE_AND:\n\tcase R_ANAL_OP_TYPE_XOR:\n\tcase R_ANAL_OP_TYPE_NOR:\n\tcase R_ANAL_OP_TYPE_NOT:\n\tcase R_ANAL_OP_TYPE_ROR:\n\tcase R_ANAL_OP_TYPE_ROL:\n\tcase R_ANAL_OP_TYPE_CAST:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n#define STR_EQUAL(s1, s2) (s1 && s2 && !strcmp (s1, s2))\n\nstatic inline bool arch_destroys_dst(const char *arch) {\n\treturn (STR_EQUAL (arch, \"arm\") || STR_EQUAL (arch, \"riscv\") || STR_EQUAL (arch, \"ppc\"));\n}\n\nstatic bool is_used_like_arg(const char *regname, const char *opsreg, const char *opdreg, RAnalOp *op, RAnal *anal) {\n\tRAnalValue *dst = op->dst;\n\tRAnalValue *src = op->src[0];\n\tswitch (op->type) {\n\tcase R_ANAL_OP_TYPE_POP:\n\t\treturn false;\n\tcase R_ANAL_OP_TYPE_MOV:\n\t\treturn (is_reg_in_src (regname, anal, op)) || (STR_EQUAL (opdreg, regname) && dst->memref);\n\tcase R_ANAL_OP_TYPE_CMOV:\n\t\tif (STR_EQUAL (opdreg, regname)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (is_reg_in_src (regname, anal, op)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\tcase R_ANAL_OP_TYPE_LEA:\n\tcase R_ANAL_OP_TYPE_LOAD:\n\t\tif (is_reg_in_src (regname, anal, op)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (STR_EQUAL (opdreg, regname)) {\n\t\t\treturn false;\n\t\t}\n    \t\treturn false;\n\tcase R_ANAL_OP_TYPE_XOR:\n\t\tif (STR_EQUAL (opsreg, opdreg) && !src->memref && !dst->memref) {\n\t\t\treturn false;\n\t\t}\n\t\t//fallthrough\n\tdefault:\n\t\tif (op_affect_dst (op) && arch_destroys_dst (anal->cur->arch)) {\n\t\t\tif (is_reg_in_src (regname, anal, op)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\treturn ((STR_EQUAL (opdreg, regname)) || (is_reg_in_src (regname, anal, op)));\n\t}\n}\n\nstatic bool is_reg_in_src(const char *regname, RAnal *anal, RAnalOp *op) {\n\tconst char* opsreg0 = op->src[0] ? get_regname (anal, op->src[0]) : NULL;\n\tconst char* opsreg1 = op->src[1] ? get_regname (anal, op->src[1]) : NULL;\n\tconst char* opsreg2 = op->src[2] ? get_regname (anal, op->src[2]) : NULL;\n\treturn (STR_EQUAL (regname, opsreg0)) || (STR_EQUAL (regname, opsreg1)) || (STR_EQUAL (regname, opsreg2));\n}\n\nR_API void r_anal_extract_rarg(RAnal *anal, RAnalOp *op, RAnalFunction *fcn, int *reg_set, int *count) {\n\tint i, argc = 0;\n\tr_return_if_fail (anal && op && fcn);\n\tconst char *opsreg = op->src[0] ? get_regname (anal, op->src[0]) : NULL;\n\tconst char *opdreg = op->dst ? get_regname (anal, op->dst) : NULL;\n\tconst int size = (fcn->bits ? fcn->bits : anal->bits) / 8;\n\tif (!fcn->cc) {\n\t\tR_LOG_DEBUG (\"No calling convention for function '%s' to extract register arguments\\n\", fcn->name);\n\t\treturn;\n\t}\n\tchar *fname = r_type_func_guess (anal->sdb_types, fcn->name);\n\tSdb *TDB = anal->sdb_types;\n\tint max_count = r_anal_cc_max_arg (anal, fcn->cc);\n\tif (!max_count || (*count >= max_count)) {\n\t\tfree (fname);\n\t\treturn;\n\t}\n\tif (fname) {\n\t\targc = r_type_func_args_count (TDB, fname);\n\t}\n\n\tbool is_call = (op->type & 0xf) == R_ANAL_OP_TYPE_CALL || (op->type & 0xf) == R_ANAL_OP_TYPE_UCALL;\n\tif (is_call && *count < max_count) {\n\t\tRList *callee_rargs_l = NULL;\n\t\tint callee_rargs = 0;\n\t\tchar *callee = NULL;\n\t\tut64 offset = op->jump == UT64_MAX ? op->ptr : op->jump;\n\t\tRAnalFunction *f = r_anal_get_function_at (anal, offset);\n\t\tif (!f) {\n\t\t\tRCore *core = (RCore *)anal->coreb.core;\n\t\t\tRFlagItem *flag = r_flag_get_by_spaces (core->flags, offset, R_FLAGS_FS_IMPORTS, NULL);\n\t\t\tif (flag) {\n\t\t\t\tcallee = r_type_func_guess (TDB, flag->name);\n\t\t\t\tif (callee) {\n\t\t\t\t\tconst char *cc = r_anal_cc_func (anal, callee);\n\t\t\t\t\tif (cc && !strcmp (fcn->cc, cc)) {\n\t\t\t\t\t\tcallee_rargs = R_MIN (max_count, r_type_func_args_count (TDB, callee));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (!f->is_variadic && !strcmp (fcn->cc, f->cc)) {\n\t\t\tcallee = r_type_func_guess (TDB, f->name);\n\t\t\tif (callee) {\n\t\t\t\tcallee_rargs = R_MIN (max_count, r_type_func_args_count (TDB, callee));\n\t\t\t}\n\t\t\tcallee_rargs = callee_rargs\n\t\t\t\t? callee_rargs\n\t\t\t\t: r_anal_var_count (anal, f, R_ANAL_VAR_KIND_REG, 1);\n\t\t\tcallee_rargs_l = r_anal_var_list (anal, f, R_ANAL_VAR_KIND_REG);\n\t\t}\n\t\tint i;\n\t\tfor (i = 0; i < callee_rargs; i++) {\n\t\t\tif (reg_set[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst char *vname = NULL;\n\t\t\tchar *type = NULL;\n\t\t\tchar *name = NULL;\n\t\t\tint delta = 0;\n\t\t\tconst char *regname = r_anal_cc_arg (anal, fcn->cc, i);\n\t\t\tRRegItem *ri = r_reg_get (anal->reg, regname, -1);\n\t\t\tif (ri) {\n\t\t\t\tdelta = ri->index;\n\t\t\t}\n\t\t\tif (fname) {\n\t\t\t\ttype = r_type_func_args_type (TDB, fname, i);\n\t\t\t\tvname = r_type_func_args_name (TDB, fname, i);\n\t\t\t}\n\t\t\tif (!vname && callee) {\n\t\t\t\ttype = r_type_func_args_type (TDB, callee, i);\n\t\t\t\tvname = r_type_func_args_name (TDB, callee, i);\n\t\t\t}\n\t\t\tif (vname) {\n\t\t\t\treg_set[i] = 1;\n\t\t\t} else {\n\t\t\t\tRListIter *it;\n\t\t\t\tRAnalVar *arg, *found_arg = NULL;\n\t\t\t\tr_list_foreach (callee_rargs_l, it, arg) {\n\t\t\t\t\tif (r_anal_var_get_argnum (arg) == i) {\n\t\t\t\t\t\tfound_arg = arg;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (found_arg) {\n\t\t\t\t\ttype = strdup (found_arg->type);\n\t\t\t\t\tvname = name = strdup (found_arg->name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!vname) {\n\t\t\t\tname = r_str_newf (\"arg%u\", (int)i + 1);\n\t\t\t\tvname = name;\n\t\t\t}\n\t\t\tr_anal_function_set_var (fcn, delta, R_ANAL_VAR_KIND_REG, type, size, true, vname);\n\t\t\t(*count)++;\n\t\t\tfree (name);\n\t\t\tfree (type);\n\t\t}\n\t\tfree (callee);\n\t\tr_list_free (callee_rargs_l);\n\t\tfree (fname);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < max_count; i++) {\n\t\tconst char *regname = r_anal_cc_arg (anal, fcn->cc, i);\n\t\tif (regname) {\n\t\t\tint delta = 0;\n\t\t\tRRegItem *ri = NULL;\n\t\t\tRAnalVar *var = NULL;\n\t\t\tbool is_used_like_an_arg = is_used_like_arg (regname, opsreg, opdreg, op, anal);\n\t\t\tif (reg_set[i] != 2 && is_used_like_an_arg) {\n\t\t\t\tri = r_reg_get (anal->reg, regname, -1);\n\t\t\t\tif (ri) {\n\t\t\t\t\tdelta = ri->index;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (reg_set[i] == 1 && is_used_like_an_arg) {\n\t\t\t\tvar = r_anal_function_get_var (fcn, R_ANAL_VAR_KIND_REG, delta);\n\t\t\t} else if (reg_set[i] != 2 && is_used_like_an_arg) {\n\t\t\t\tconst char *vname = NULL;\n\t\t\t\tchar *type = NULL;\n\t\t\t\tchar *name = NULL;\n\t\t\t\tif ((i < argc) && fname) {\n\t\t\t\t\ttype = r_type_func_args_type (TDB, fname, i);\n\t\t\t\t\tvname = r_type_func_args_name (TDB, fname, i);\n\t\t\t\t}\n\t\t\t\tif (!vname) {\n\t\t\t\t\tname = r_str_newf (\"arg%d\", i + 1);\n\t\t\t\t\tvname = name;\n\t\t\t\t}\n\t\t\t\tvar = r_anal_function_set_var (fcn, delta, R_ANAL_VAR_KIND_REG, type, size, true, vname);\n\t\t\t\tfree (name);\n\t\t\t\tfree (type);\n\t\t\t\t(*count)++;\n\t\t\t} else {\n\t\t\t\tif (is_reg_in_src (regname, anal, op) || STR_EQUAL (opdreg, regname)) {\n\t\t\t\t\treg_set[i] = 2;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (is_reg_in_src (regname, anal, op) || STR_EQUAL (regname, opdreg)) {\n\t\t\t\treg_set[i] = 1;\n\t\t\t}\n\t\t\tif (var) {\n\t\t\t\tr_anal_var_set_access (var, var->regname, op->addr, R_ANAL_VAR_ACCESS_TYPE_READ, 0);\n\t\t\t\tr_meta_set_string (anal, R_META_TYPE_VARTYPE, op->addr, var->name);\n\t\t\t}\n\t\t}\n\t}\n\n\tconst char *selfreg = r_anal_cc_self (anal, fcn->cc);\n\tif (selfreg) {\n\t\tbool is_used_like_an_arg = is_used_like_arg (selfreg, opsreg, opdreg, op, anal);\n\t\tif (reg_set[i] != 2 && is_used_like_an_arg) {\n\t\t\tint delta = 0;\n\t\t\tchar *vname = strdup (\"self\");\n\t\t\tRRegItem *ri = r_reg_get (anal->reg, selfreg, -1);\n\t\t\tif (ri) {\n\t\t\t\tdelta = ri->index;\n\t\t\t}\n\t\t\tRAnalVar *newvar = r_anal_function_set_var (fcn, delta, R_ANAL_VAR_KIND_REG, 0, size, true, vname);\n\t\t\tif (newvar) {\n\t\t\t\tr_anal_var_set_access (newvar, newvar->regname, op->addr, R_ANAL_VAR_ACCESS_TYPE_READ, 0);\n\t\t\t}\n\t\t\tr_meta_set_string (anal, R_META_TYPE_VARTYPE, op->addr, vname);\n\t\t\tfree (vname);\n\t\t\t(*count)++;\n\t\t} else {\n\t\t\tif (is_reg_in_src (selfreg, anal, op) || STR_EQUAL (opdreg, selfreg)) {\n\t\t\t\treg_set[i] = 2;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\n\tconst char *errorreg = r_anal_cc_error (anal, fcn->cc);\n\tif (errorreg) {\n\t\tif (reg_set[i] == 0 && STR_EQUAL (opdreg, errorreg)) {\n\t\t\tint delta = 0;\n\t\t\tchar *vname = strdup (\"error\");\n\t\t\tRRegItem *ri = r_reg_get (anal->reg, errorreg, -1);\n\t\t\tif (ri) {\n\t\t\t\tdelta = ri->index;\n\t\t\t}\n\t\t\tRAnalVar *newvar = r_anal_function_set_var (fcn, delta, R_ANAL_VAR_KIND_REG, 0, size, true, vname);\n\t\t\tif (newvar) {\n\t\t\t\tr_anal_var_set_access (newvar, newvar->regname, op->addr, R_ANAL_VAR_ACCESS_TYPE_READ, 0);\n\t\t\t}\n\t\t\tr_meta_set_string (anal, R_META_TYPE_VARTYPE, op->addr, vname);\n\t\t\tfree (vname);\n\t\t\t(*count)++;\n\t\t\treg_set[i] = 2;\n\t\t}\n\t}\n\tfree (fname);\n}\n\nR_API void r_anal_extract_vars(RAnal *anal, RAnalFunction *fcn, RAnalOp *op) {\n\tr_return_if_fail (anal && fcn && op);\n\n\tconst char *BP = anal->reg->name[R_REG_NAME_BP];\n\tif (BP) {\n\t\textract_arg (anal, fcn, op, BP, \"+\", R_ANAL_VAR_KIND_BPV);\n\t\textract_arg (anal, fcn, op, BP, \"-\", R_ANAL_VAR_KIND_BPV);\n\t}\n\tconst char *SP = anal->reg->name[R_REG_NAME_SP];\n\tif (SP) {\n\t\textract_arg (anal, fcn, op, SP, \"+\", R_ANAL_VAR_KIND_SPV);\n\t}\n}\n\nstatic RList *var_generate_list(RAnal *a, RAnalFunction *fcn, int kind) {\n\tif (!a || !fcn) {\n\t\treturn NULL;\n\t}\n\tRList *list = r_list_new ();\n\tif (kind < 1) {\n\t\tkind = R_ANAL_VAR_KIND_BPV; // by default show vars\n\t}\n\tif (fcn->vars.v.len > 0) {\n\t\tvoid **it;\n\t\tr_pvector_foreach (&fcn->vars, it) {\n\t\t\tRAnalVar *var = *it;\n\t\t\tif (var->kind == kind) {\n\t\t\t\tr_list_push (list, var);\n\t\t\t}\n\t\t}\n\t}\n\treturn list;\n}\n\nR_API RList *r_anal_var_all_list(RAnal *anal, RAnalFunction *fcn) {\n\t// r_anal_var_list if there are not vars with that kind returns a list with\n\t// zero element.. which is an unnecessary loss of cpu time\n\tRList *list = r_list_new ();\n\tif (!list) {\n\t\treturn NULL;\n\t}\n\tRList *reg_vars = r_anal_var_list (anal, fcn, R_ANAL_VAR_KIND_REG);\n\tRList *bpv_vars = r_anal_var_list (anal, fcn, R_ANAL_VAR_KIND_BPV);\n\tRList *spv_vars = r_anal_var_list (anal, fcn, R_ANAL_VAR_KIND_SPV);\n\tr_list_join (list, reg_vars);\n\tr_list_join (list, bpv_vars);\n\tr_list_join (list, spv_vars);\n\tr_list_free (reg_vars);\n\tr_list_free (bpv_vars);\n\tr_list_free (spv_vars);\n\treturn list;\n}\n\nR_API RList *r_anal_var_list(RAnal *a, RAnalFunction *fcn, int kind) {\n\treturn var_generate_list (a, fcn, kind);\n}\n\nstatic void var_field_free(RAnalVarField *field) {\n\tif (!field) {\n\t\treturn;\n\t}\n\tfree (field->name);\n\tfree (field);\n}\n\nR_API RList *r_anal_function_get_var_fields(RAnalFunction *fcn, int kind) {\n\tif (!fcn) {\n\t\treturn NULL;\n\t}\n\tRList *list = r_list_newf ((RListFree)var_field_free);\n\tif (kind < 1) {\n\t\tkind = R_ANAL_VAR_KIND_BPV; // by default show vars\n\t}\n\tvoid **it;\n\tr_pvector_foreach (&fcn->vars, it) {\n\t\tRAnalVar *var = *it;\n\t\tif (var->kind != kind) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (var_add_structure_fields_to_list (fcn->anal, var, list)) {\n\t\t\t// this var is a struct and var_add_structure_fields_to_list added all the fields\n\t\t\tcontinue;\n\t\t}\n\t\tRAnalVarField *field = R_NEW0 (RAnalVarField);\n\t\tif (!field) {\n\t\t\tbreak;\n\t\t}\n\t\tfield->name = strdup (var->name);\n\t\tif (!field->name) {\n\t\t\tvar_field_free (field);\n\t\t\tbreak;\n\t\t}\n\t\tfield->delta = var->delta;\n\t\tr_list_push (list, field);\n\t}\n\treturn list;\n}\n\nstatic int var_comparator(const RAnalVar *a, const RAnalVar *b){\n\t// avoid NULL dereference\n\treturn (a && b)? (a->delta > b->delta) - (a->delta < b->delta) : 0;\n}\n\nstatic int regvar_comparator(const RAnalVar *a, const RAnalVar *b){\n\t// avoid NULL dereference\n\treturn (a && b)? (a->argnum > b->argnum) - (a->argnum < b->argnum): 0;\n}\n\nR_API void r_anal_var_list_show(RAnal *anal, RAnalFunction *fcn, int kind, int mode, PJ *pj) {\n\tRList *list = r_anal_var_list (anal, fcn, kind);\n\tRAnalVar *var;\n\tRListIter *iter;\n\tif (!pj && mode == 'j') {\n\t\treturn;\n\t}\n\tif (mode == 'j') {\n\t\tpj_a (pj);\n\t}\n\tif (!list) {\n\t\tif (mode == 'j') {\n\t\t\tpj_end (pj);\n\t\t}\n\t\treturn;\n\t}\n\t//s- at the end of the loop\n\tif (mode == '*' && !r_list_empty (list)) {\n\t\tanal->cb_printf (\"s 0x%\" PFMT64x \"\\n\", fcn->addr);\n\t}\n\tr_list_sort (list, (RListComparator) var_comparator);\n\tr_list_foreach (list, iter, var) {\n\t\tif (var->kind != kind) {\n\t\t\tcontinue;\n\t\t}\n\t\tswitch (mode) {\n\t\tcase '*':\n\t\t\t// we can't express all type info here :(\n\t\t\tif (kind == R_ANAL_VAR_KIND_REG) { // registers\n\t\t\t\tRRegItem *i = r_reg_index_get (anal->reg, var->delta);\n\t\t\t\tif (!i) {\n\t\t\t\t\teprintf (\"Register not found\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tanal->cb_printf (\"\\\"afv%c %s %s %s\\\"\\n\",\n\t\t\t\t\tkind, i->name, var->name, var->type);\n\t\t\t} else {\n\t\t\t\tint delta = kind == R_ANAL_VAR_KIND_BPV\n\t\t\t\t\t? var->delta + fcn->bp_off\n\t\t\t\t\t: var->delta;\n\t\t\t\tanal->cb_printf (\"\\\"afv%c %d %s %s\\\"\\n\",\n\t\t\t\t\tkind, delta, var->name, var->type);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'j':\n\t\t\tswitch (var->kind) {\n\t\t\tcase R_ANAL_VAR_KIND_BPV: {\n\t\t\t\tst64 delta = (st64)var->delta + fcn->bp_off;\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_ks (pj, \"name\", var->name);\n\t\t\t\tif (var->isarg) {\n\t\t\t\t\tpj_ks (pj, \"kind\", \"arg\");\n\t\t\t\t} else {\n\t\t\t\t\tpj_ks (pj, \"kind\", \"var\");\n\t\t\t\t}\n\t\t\t\tpj_ks (pj, \"type\", var->type);\n\t\t\t\tpj_k (pj, \"ref\");\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_ks (pj, \"base\", anal->reg->name[R_REG_NAME_BP]);\n\t\t\t\tpj_kN (pj, \"offset\", delta);\n\t\t\t\tpj_end (pj);\n\t\t\t\tpj_end (pj);\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_VAR_KIND_REG: {\n\t\t\t\tRRegItem *i = r_reg_index_get (anal->reg, var->delta);\n\t\t\t\tif (!i) {\n\t\t\t\t\teprintf (\"Register not found\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_ks (pj, \"name\", var->name);\n\t\t\t\tpj_ks (pj, \"kind\", \"reg\");\n\t\t\t\tpj_ks (pj, \"type\", var->type);\n\t\t\t\tpj_ks (pj, \"ref\", i->name);\n\t\t\t\tpj_end (pj);\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_VAR_KIND_SPV: {\n\t\t\t\tst64 delta = (st64)var->delta + fcn->maxstack;\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_ks (pj, \"name\", var->name);\n\t\t\t\tif (var->isarg) {\n\t\t\t\t\tpj_ks (pj, \"kind\", \"arg\");\n\t\t\t\t} else {\t\t\t\t\n\t\t\t\t\tpj_ks (pj, \"kind\", \"var\");\t\t\t\n\t\t\t\t}\n\t\t\t\tpj_ks (pj, \"type\", var->type);\n\t\t\t\tpj_k (pj, \"ref\");\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_ks (pj, \"base\", anal->reg->name[R_REG_NAME_SP]);\n\t\t\t\tpj_kN (pj, \"offset\", delta);\n\t\t\t\tpj_end (pj);\n\t\t\t\tpj_end (pj);\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tswitch (kind) {\n\t\t\tcase R_ANAL_VAR_KIND_BPV:\n\t\t\t{\n\t\t\t\tint delta = var->delta + fcn->bp_off;\n\t\t\t\tif (var->isarg) {\n\t\t\t\t\tanal->cb_printf (\"arg %s %s @ %s+0x%x\\n\",\n\t\t\t\t\t\tvar->type, var->name,\n\t\t\t\t\t\tanal->reg->name[R_REG_NAME_BP],\n\t\t\t\t\t\tdelta);\n\t\t\t\t} else {\n\t\t\t\t\tchar sign = (-var->delta <= fcn->bp_off) ? '+' : '-';\n\t\t\t\t\tanal->cb_printf (\"var %s %s @ %s%c0x%x\\n\",\n\t\t\t\t\t\tvar->type, var->name,\n\t\t\t\t\t\tanal->reg->name[R_REG_NAME_BP],\n\t\t\t\t\t\tsign, R_ABS (delta));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_VAR_KIND_REG: {\n\t\t\t\tRRegItem *i = r_reg_index_get (anal->reg, var->delta);\n\t\t\t\tif (!i) {\n\t\t\t\t\teprintf (\"Register not found\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tanal->cb_printf (\"arg %s %s @ %s\\n\",\n\t\t\t\t\tvar->type, var->name, i->name);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_VAR_KIND_SPV:\n\t\t\t{\n\t\t\t\tint delta = fcn->maxstack + var->delta;\n\t\t\t\tif (!var->isarg) {\n\t\t\t\t\tchar sign = (-var->delta <= fcn->maxstack) ? '+' : '-';\n\t\t\t\t\tanal->cb_printf (\"var %s %s @ %s%c0x%x\\n\",\n\t\t\t\t\t\tvar->type, var->name,\n\t\t\t\t\t\tanal->reg->name[R_REG_NAME_SP],\n\t\t\t\t\t\tsign, R_ABS (delta));\n\t\t\t\t} else {\n\t\t\t\t\tanal->cb_printf (\"arg %s %s @ %s+0x%x\\n\",\n\t\t\t\t\t\tvar->type, var->name,\n\t\t\t\t\t\tanal->reg->name[R_REG_NAME_SP],\n\t\t\t\t\t\tdelta);\n\n\t\t\t\t}\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (mode == '*' && !r_list_empty (list)) {\n\t\tanal->cb_printf (\"s-\\n\");\n\t}\n\tif (mode == 'j') {\n\t\tpj_end (pj);\n\t}\n\tr_list_free (list);\n}\n\nR_API void r_anal_function_vars_cache_init(RAnal *anal, RAnalFcnVarsCache *cache, RAnalFunction *fcn) {\n\tcache->bvars = r_anal_var_list (anal, fcn, R_ANAL_VAR_KIND_BPV);\n\tcache->rvars = r_anal_var_list (anal, fcn, R_ANAL_VAR_KIND_REG);\n\tcache->svars = r_anal_var_list (anal, fcn, R_ANAL_VAR_KIND_SPV);\n\tr_list_sort (cache->bvars, (RListComparator)var_comparator);\n\tRListIter *it;\n\tRAnalVar *var;\n\tr_list_foreach (cache->rvars, it, var) {\n\t\tvar->argnum = r_anal_var_get_argnum (var);\n\t}\n\tr_list_sort (cache->rvars, (RListComparator)regvar_comparator);\n\tr_list_sort (cache->svars, (RListComparator)var_comparator);\n}\n\nR_API void r_anal_function_vars_cache_fini(RAnalFcnVarsCache *cache) {\n\tif (!cache) {\n\t\treturn;\n\t}\n\tr_list_free (cache->bvars);\n\tr_list_free (cache->rvars);\n\tr_list_free (cache->svars);\n}\n\nR_API char *r_anal_function_format_sig(R_NONNULL RAnal *anal, R_NONNULL RAnalFunction *fcn, R_NULLABLE char *fcn_name,\n\t\tR_NULLABLE RAnalFcnVarsCache *reuse_cache, R_NULLABLE const char *fcn_name_pre, R_NULLABLE const char *fcn_name_post) {\n\tRAnalFcnVarsCache *cache = NULL;\n\n\tif (!fcn_name) {\n\t\tfcn_name = fcn->name;\n\t\tif (!fcn_name) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tRStrBuf *buf = r_strbuf_new (NULL);\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\n\tSdb *TDB = anal->sdb_types;\n\tchar *type_fcn_name = r_type_func_guess (TDB, fcn_name);\n\tif (type_fcn_name && r_type_func_exist (TDB, type_fcn_name)) {\n\t\tconst char *fcn_type = r_type_func_ret (anal->sdb_types, type_fcn_name);\n\t\tif (R_STR_ISNOTEMPTY (fcn_type)) {\n\t\t\tconst char *sp = \" \";\n\t\t\tif (*fcn_type && (fcn_type[strlen (fcn_type) - 1] == '*')) {\n\t\t\t\tsp = \"\";\n\t\t\t}\n\t\t\tr_strbuf_appendf (buf, \"%s%s\", fcn_type, sp);\n\t\t}\n\t}\n\n\tif (fcn_name_pre) {\n\t\tr_strbuf_append (buf, fcn_name_pre);\n\t}\n\tr_strbuf_append (buf, fcn_name);\n\tif (fcn_name_post) {\n\t\tr_strbuf_append (buf, fcn_name_post);\n\t}\n\tr_strbuf_append (buf, \" (\");\n\n\tif (type_fcn_name && r_type_func_exist (TDB, type_fcn_name)) {\n\t\tint i, argc = r_type_func_args_count (TDB, type_fcn_name);\n\t\tbool comma = true;\n\t\t// This avoids false positives present in argument recovery\n\t\t// and straight away print arguments fetched from types db\n\t\tfor (i = 0; i < argc; i++) {\n\t\t\tchar *type = r_type_func_args_type (TDB, type_fcn_name, i);\n\t\t\tconst char *name = r_type_func_args_name (TDB, type_fcn_name, i);\n\t\t\tif (!type || !*type || !name) {\n\t\t\t\teprintf (\"Missing type for %s\\n\", type_fcn_name);\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (i == argc - 1) {\n\t\t\t\tcomma = false;\n\t\t\t}\n\t\t\tsize_t len = strlen (type);\n\t\t\tconst char *tc = len > 0 && type[len - 1] == '*'? \"\": \" \";\n\t\t\tr_strbuf_appendf (buf, \"%s%s%s%s\", type, tc, name, comma? \", \": \"\");\n\t\t\tfree (type);\n\t\t}\n\t\tgoto beach;\n\t}\n\tR_FREE (type_fcn_name);\n\n\n\tcache = reuse_cache;\n\tif (!cache) {\n\t\tcache = R_NEW0 (RAnalFcnVarsCache);\n\t\tif (!cache) {\n\t\t\ttype_fcn_name = NULL;\n\t\t\tgoto beach;\n\t\t}\n\t\tr_anal_function_vars_cache_init (anal, cache, fcn);\n\t}\n\n\tbool comma = true;\n\tbool arg_bp = false;\n\tsize_t tmp_len;\n\tRAnalVar *var;\n\tRListIter *iter;\n\n\tr_list_foreach (cache->rvars, iter, var) {\n\t\t// assume self, error are always the last\n\t\tif (!strcmp (var->name, \"self\") || !strcmp (var->name, \"error\")) {\n\t\t\tr_strbuf_slice (buf, 0, r_strbuf_length (buf) - 2);\n\t\t\tbreak;\n\t\t}\n\t\ttmp_len = strlen (var->type);\n\t\tif (tmp_len > 0) {\n\t\t\tr_strbuf_appendf (buf, \"%s%s%s%s\", var->type,\n\t\t\t\ttmp_len && var->type[tmp_len - 1] == '*' ? \"\" : \" \",\n\t\t\t\tvar->name, iter->n ? \", \" : \"\");\n\t\t}\n\t}\n\n\tr_list_foreach (cache->bvars, iter, var) {\n\t\tif (var->isarg) {\n\t\t\tif (!r_list_empty (cache->rvars) && comma) {\n\t\t\t\tr_strbuf_append (buf, \", \");\n\t\t\t\tcomma = false;\n\t\t\t}\n\t\t\targ_bp = true;\n\t\t\ttmp_len = strlen (var->type);\n\t\t\tif (tmp_len > 0) {\n\t\t\t\tr_strbuf_appendf (buf, \"%s%s%s%s\", var->type,\n\t\t\t\t\t\ttmp_len && var->type[tmp_len - 1] =='*' ? \"\" : \" \",\n\t\t\t\t\t\tvar->name, iter->n ? \", \" : \"\");\n\t\t\t}\n\t\t}\n\t}\n\n\tcomma = true;\n\tconst char *maybe_comma = \", \";\n\tr_list_foreach (cache->svars, iter, var) {\n\t\tif (var->isarg) {\n\t\t\tif (!*maybe_comma || ((arg_bp || !r_list_empty (cache->rvars)) && comma)) {\n\t\t\t\tcomma = false;\n\t\t\t\tr_strbuf_append (buf, \", \");\n\t\t\t}\n\t\t\ttmp_len = strlen (var->type);\n\t\t\tif (iter->n && ((RAnalVar *)iter->n->data)->isarg) {\n\t\t\t\tmaybe_comma = \", \";\n\t\t\t} else {\n\t\t\t\tmaybe_comma = \"\";\n\t\t\t}\n\t\t\tif (tmp_len > 0) {\n\t\t\t\tr_strbuf_appendf (buf, \"%s%s%s%s\", var->type,\n\t\t\t\t\ttmp_len && var->type[tmp_len - 1] == '*'? \"\": \" \",\n\t\t\t\t\tvar->name, maybe_comma);\n\t\t\t}\n\t\t}\n\t}\n\nbeach:\n\tr_strbuf_append (buf, \");\");\n\tR_FREE (type_fcn_name);\n\tif (!reuse_cache) {\n\t\t// !reuse_cache => we created our own cache\n\t\tr_anal_function_vars_cache_fini (cache);\n\t\tfree (cache);\n\t}\n\treturn r_strbuf_drain (buf);\n}\n"], "filenames": ["libr/anal/fcn.c", "libr/anal/var.c"], "buggy_code_start_loc": [818, 1051], "buggy_code_end_loc": [1410, 1052], "fixing_code_start_loc": [818, 1051], "fixing_code_end_loc": [1420, 1052], "type": "CWE-416", "message": "Use After Free in op_is_set_bp in GitHub repository radareorg/radare2 prior to 5.6.6.", "other": {"cve": {"id": "CVE-2022-1031", "sourceIdentifier": "security@huntr.dev", "published": "2022-03-22T20:15:07.593", "lastModified": "2022-03-28T20:11:43.127", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Use After Free in op_is_set_bp in GitHub repository radareorg/radare2 prior to 5.6.6."}, {"lang": "es", "value": "Un Uso de Memoria Previamente Liberada en la funci\u00f3n op_is_set_bp en el repositorio de GitHub radareorg/radare2 versiones anteriores a 5.6.6"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.6.6", "matchCriteriaId": "F3E05FE2-B40C-4EAB-B211-1CCEC2B73F98"}]}]}], "references": [{"url": "https://github.com/radareorg/radare2/commit/a7ce29647fcb38386d7439696375e16e093d6acb", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/37da2cd6-0b46-4878-a32e-acbfd8f6f457", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radareorg/radare2/commit/a7ce29647fcb38386d7439696375e16e093d6acb"}}