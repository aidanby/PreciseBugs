{"buggy_code": ["/*\n * Copyright (C) 2015-present ScyllaDB\n */\n\n/*\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n\n#include \"server.hh\"\n\n#include <boost/bimap/unordered_set_of.hpp>\n#include <boost/range/irange.hpp>\n#include <boost/bimap.hpp>\n#include <boost/assign.hpp>\n#include <boost/range/adaptor/sliced.hpp>\n\n#include \"cql3/statements/batch_statement.hh\"\n#include \"cql3/statements/modification_statement.hh\"\n#include \"types/collection.hh\"\n#include \"types/list.hh\"\n#include \"types/set.hh\"\n#include \"types/map.hh\"\n#include \"dht/token-sharding.hh\"\n#include \"service/migration_manager.hh\"\n#include \"service/memory_limiter.hh\"\n#include \"service/storage_proxy.hh\"\n#include \"db/consistency_level_type.hh\"\n#include \"db/write_type.hh\"\n#include <seastar/core/coroutine.hh>\n#include <seastar/core/future-util.hh>\n#include <seastar/core/seastar.hh>\n#include \"utils/UUID.hh\"\n#include <seastar/net/byteorder.hh>\n#include <seastar/core/metrics.hh>\n#include <seastar/net/byteorder.hh>\n#include <seastar/util/lazy.hh>\n#include <seastar/core/execution_stage.hh>\n#include \"utils/result_try.hh\"\n#include \"utils/result_combinators.hh\"\n#include \"db/operation_type.hh\"\n\n#include \"enum_set.hh\"\n#include \"service/query_state.hh\"\n#include \"service/client_state.hh\"\n#include \"exceptions/exceptions.hh\"\n#include \"client_data.hh\"\n#include \"cql3/query_processor.hh\"\n#include \"auth/authenticator.hh\"\n\n#include <cassert>\n#include <string>\n\n#include <snappy-c.h>\n#include <lz4.h>\n\n#include \"response.hh\"\n#include \"request.hh\"\n\n#include \"types/user.hh\"\n\n#include \"transport/cql_protocol_extension.hh\"\n#include \"utils/bit_cast.hh\"\n#include \"db/config.hh\"\n\ntemplate<typename T = void>\nusing coordinator_result = exceptions::coordinator_result<T>;\n\nnamespace cql_transport {\n\nstatic logging::logger clogger(\"cql_server\");\n\nstruct cql_frame_error : std::exception {\n    const char* what() const throw () override {\n        return \"bad cql binary frame\";\n    }\n};\n\ninline int16_t consistency_to_wire(db::consistency_level c)\n{\n    switch (c) {\n    case db::consistency_level::ANY:          return 0x0000;\n    case db::consistency_level::ONE:          return 0x0001;\n    case db::consistency_level::TWO:          return 0x0002;\n    case db::consistency_level::THREE:        return 0x0003;\n    case db::consistency_level::QUORUM:       return 0x0004;\n    case db::consistency_level::ALL:          return 0x0005;\n    case db::consistency_level::LOCAL_QUORUM: return 0x0006;\n    case db::consistency_level::EACH_QUORUM:  return 0x0007;\n    case db::consistency_level::SERIAL:       return 0x0008;\n    case db::consistency_level::LOCAL_SERIAL: return 0x0009;\n    case db::consistency_level::LOCAL_ONE:    return 0x000A;\n    default:                                  throw std::runtime_error(\"Invalid consistency level\");\n    }\n}\n\nsstring to_string(const event::topology_change::change_type t) {\n    using type = event::topology_change::change_type;\n    switch (t) {\n    case type::NEW_NODE:     return \"NEW_NODE\";\n    case type::REMOVED_NODE: return \"REMOVED_NODE\";\n    case type::MOVED_NODE:   return \"MOVED_NODE\";\n    }\n    throw std::invalid_argument(\"unknown change type\");\n}\n\nsstring to_string(const event::status_change::status_type t) {\n    using type = event::status_change::status_type;\n    switch (t) {\n    case type::UP:   return \"UP\";\n    case type::DOWN: return \"DOWN\";\n    }\n    throw std::invalid_argument(\"unknown change type\");\n}\n\nsstring to_string(const event::schema_change::change_type t) {\n    switch (t) {\n    case event::schema_change::change_type::CREATED: return \"CREATED\";\n    case event::schema_change::change_type::UPDATED: return \"UPDATED\";\n    case event::schema_change::change_type::DROPPED: return \"DROPPED\";\n    }\n    assert(false && \"unreachable\");\n}\n\nsstring to_string(const event::schema_change::target_type t) {\n    switch (t) {\n    case event::schema_change::target_type::KEYSPACE: return \"KEYSPACE\";\n    case event::schema_change::target_type::TABLE:    return \"TABLE\";\n    case event::schema_change::target_type::TYPE:     return \"TYPE\";\n    case event::schema_change::target_type::FUNCTION: return \"FUNCTION\";\n    case event::schema_change::target_type::AGGREGATE:return \"AGGREGATE\";\n    }\n    assert(false && \"unreachable\");\n}\n\nevent::event_type parse_event_type(const sstring& value)\n{\n    if (value == \"TOPOLOGY_CHANGE\") {\n        return event::event_type::TOPOLOGY_CHANGE;\n    } else if (value == \"STATUS_CHANGE\") {\n        return event::event_type::STATUS_CHANGE;\n    } else if (value == \"SCHEMA_CHANGE\") {\n        return event::event_type::SCHEMA_CHANGE;\n    } else {\n        throw exceptions::protocol_exception(format(\"Invalid value '{}' for Event.Type\", value));\n    }\n}\n\ncql_server::cql_server(distributed<cql3::query_processor>& qp, auth::service& auth_service,\n        service::memory_limiter& ml, cql_server_config config, const db::config& db_cfg,\n        qos::service_level_controller& sl_controller, gms::gossiper& g)\n    : server(\"CQLServer\", clogger)\n    , _query_processor(qp)\n    , _config(config)\n    , _max_request_size(config.max_request_size)\n    , _max_concurrent_requests(db_cfg.max_concurrent_requests_per_shard)\n    , _memory_available(ml.get_semaphore())\n    , _notifier(std::make_unique<event_notifier>(*this))\n    , _auth_service(auth_service)\n    , _sl_controller(sl_controller)\n    , _gossiper(g)\n{\n    namespace sm = seastar::metrics;\n\n    auto ls = {\n        sm::make_counter(\"startups\", _stats.startups,\n                        sm::description(\"Counts the total number of received CQL STARTUP messages.\")),\n\n        sm::make_counter(\"auth_responses\", _stats.auth_responses,\n                        sm::description(\"Counts the total number of received CQL AUTH messages.\")),\n        \n        sm::make_counter(\"options_requests\", _stats.options_requests,\n                        sm::description(\"Counts the total number of received CQL OPTIONS messages.\")),\n\n        sm::make_counter(\"query_requests\", _stats.query_requests,\n                        sm::description(\"Counts the total number of received CQL QUERY messages.\")),\n\n        sm::make_counter(\"prepare_requests\", _stats.prepare_requests,\n                        sm::description(\"Counts the total number of received CQL PREPARE messages.\")),\n\n        sm::make_counter(\"execute_requests\", _stats.execute_requests,\n                        sm::description(\"Counts the total number of received CQL EXECUTE messages.\")),\n\n        sm::make_counter(\"batch_requests\", _stats.batch_requests,\n                        sm::description(\"Counts the total number of received CQL BATCH messages.\")),\n\n        sm::make_counter(\"register_requests\", _stats.register_requests,\n                        sm::description(\"Counts the total number of received CQL REGISTER messages.\")),\n\n        sm::make_counter(\"cql-connections\", _stats.connects,\n                        sm::description(\"Counts a number of client connections.\")),\n\n        sm::make_gauge(\"current_connections\", _stats.connections,\n                        sm::description(\"Holds a current number of client connections.\")),\n\n        sm::make_counter(\"requests_served\", _stats.requests_served,\n                        sm::description(\"Counts a number of served requests.\")),\n\n        sm::make_gauge(\"requests_serving\", _stats.requests_serving,\n                        sm::description(\"Holds a number of requests that are being processed right now.\")),\n\n        sm::make_gauge(\"requests_blocked_memory_current\", [this] { return _memory_available.waiters(); },\n                        sm::description(\n                            seastar::format(\"Holds the number of requests that are currently blocked due to reaching the memory quota limit ({}B). \"\n                                            \"Non-zero value indicates that our bottleneck is memory and more specifically - the memory quota allocated for the \\\"CQL transport\\\" component.\", _max_request_size))),\n        sm::make_counter(\"requests_blocked_memory\", _stats.requests_blocked_memory,\n                        sm::description(\n                            seastar::format(\"Holds an incrementing counter with the requests that ever blocked due to reaching the memory quota limit ({}B). \"\n                                            \"The first derivative of this value shows how often we block due to memory exhaustion in the \\\"CQL transport\\\" component.\", _max_request_size))),\n        sm::make_counter(\"requests_shed\", _stats.requests_shed,\n                        sm::description(\"Holds an incrementing counter with the requests that were shed due to overload (threshold configured via max_concurrent_requests_per_shard). \"\n                                            \"The first derivative of this value shows how often we shed requests due to overload in the \\\"CQL transport\\\" component.\")),\n        sm::make_gauge(\"requests_memory_available\", [this] { return _memory_available.current(); },\n                        sm::description(\n                            seastar::format(\"Holds the amount of available memory for admitting new requests (max is {}B).\"\n                                            \"Zero value indicates that our bottleneck is memory and more specifically - the memory quota allocated for the \\\"CQL transport\\\" component.\", _max_request_size)))\n    };\n\n    std::vector<sm::metric_definition> transport_metrics;\n    for (auto& m : ls) {\n        transport_metrics.emplace_back(std::move(m));\n    }\n\n    sm::label cql_error_label(\"type\");\n    for (const auto& e : exceptions::exception_map()) {\n        _stats.errors.insert({e.first, 0});\n        auto label_instance = cql_error_label(e.second);\n\n        transport_metrics.emplace_back(\n            sm::make_counter(\"cql_errors_total\", sm::description(\"Counts the total number of returned CQL errors.\"),\n                        {label_instance},\n                        [this, code = e.first] { auto it = _stats.errors.find(code); return it != _stats.errors.end() ? it->second : 0; })\n        );\n    }\n\n    _metrics.add_group(\"transport\", std::move(transport_metrics));\n}\n\nshared_ptr<generic_server::connection>\ncql_server::make_connection(socket_address server_addr, connected_socket&& fd, socket_address addr) {\n    auto conn = make_shared<connection>(*this, server_addr, std::move(fd), std::move(addr));\n    ++_stats.connects;\n    ++_stats.connections;\n    return conn;\n}\n\nfuture<>\ncql_server::advertise_new_connection(shared_ptr<generic_server::connection> raw_conn) {\n    if (auto conn = dynamic_pointer_cast<connection>(raw_conn)) {\n        const auto ip = conn->get_client_state().get_client_address().addr();\n        const auto port = conn->get_client_state().get_client_port();\n        clogger.trace(\"Advertising new connection from CQL client {}:{}\", ip, port);\n    }\n    return make_ready_future<>();\n}\n\nfuture<>\ncql_server::unadvertise_connection(shared_ptr<generic_server::connection> raw_conn) {\n    --_stats.connections;\n    if (auto conn = dynamic_pointer_cast<connection>(raw_conn)) {\n        const auto ip = conn->get_client_state().get_client_address().addr();\n        const auto port = conn->get_client_state().get_client_port();\n        clogger.trace(\"Advertising disconnection of CQL client {}:{}\", ip, port);\n    }\n    return make_ready_future<>();\n}\n\nunsigned\ncql_server::connection::frame_size() const {\n    if (_version < 3) {\n        return 8;\n    } else {\n        return 9;\n    }\n}\n\ncql_binary_frame_v3\ncql_server::connection::parse_frame(temporary_buffer<char> buf) const {\n    if (buf.size() != frame_size()) {\n        throw cql_frame_error();\n    }\n    cql_binary_frame_v3 v3;\n    switch (_version) {\n    case 1:\n    case 2: {\n        cql_binary_frame_v1 raw = read_unaligned<cql_binary_frame_v1>(buf.get());\n        auto cooked = net::ntoh(raw);\n        v3.version = cooked.version;\n        v3.flags = cooked.flags;\n        v3.opcode = cooked.opcode;\n        v3.stream = cooked.stream;\n        v3.length = cooked.length;\n        break;\n    }\n    case 3:\n    case 4: {\n        cql_binary_frame_v3 raw = read_unaligned<cql_binary_frame_v3>(buf.get());\n        v3 = net::ntoh(raw);\n        break;\n    }\n    default:\n        throw exceptions::protocol_exception(format(\"Invalid or unsupported protocol version: {:d}\", _version));\n    }\n    if (v3.version != _version) {\n        throw exceptions::protocol_exception(format(\"Invalid message version. Got {:d} but previous messages on this connection had version {:d}\", v3.version, _version));\n\n    }\n    return v3;\n}\n\nfuture<std::optional<cql_binary_frame_v3>>\ncql_server::connection::read_frame() {\n    using ret_type = std::optional<cql_binary_frame_v3>;\n    if (!_version) {\n        // We don't know the frame size before reading the first frame,\n        // so read just one byte, and then read the rest of the frame.\n        return _read_buf.read_exactly(1).then([this] (temporary_buffer<char> buf) {\n            if (buf.empty()) {\n                return make_ready_future<ret_type>();\n            }\n            _version = buf[0];\n            init_cql_serialization_format();\n            if (_version < 1 || _version > current_version) {\n                auto client_version = _version;\n                _version = current_version;\n                throw exceptions::protocol_exception(format(\"Invalid or unsupported protocol version: {:d}\", client_version));\n            }\n\n\n            return _read_buf.read_exactly(frame_size() - 1).then([this] (temporary_buffer<char> tail) {\n                temporary_buffer<char> full(frame_size());\n                full.get_write()[0] = _version;\n                std::copy(tail.get(), tail.get() + tail.size(), full.get_write() + 1);\n                auto frame = parse_frame(std::move(full));\n                // This is the very first frame, so reject obviously incorrect frames, to\n                // avoid allocating large amounts of memory for the message body\n                if (frame.length > 100'000) {\n                    // The STARTUP message body is a [string map] containing just a few options,\n                    // so it should be smaller that 100kB. See #4366.\n                    throw exceptions::protocol_exception(format(\"Initial message size too large ({:d}), rejecting as invalid\", frame.length));\n                }\n                return make_ready_future<ret_type>(frame);\n            });\n        });\n    } else {\n        // Not the first frame, so we know the size.\n        return _read_buf.read_exactly(frame_size()).then([this] (temporary_buffer<char> buf) {\n            if (buf.empty()) {\n                return make_ready_future<ret_type>();\n            }\n            return make_ready_future<ret_type>(parse_frame(std::move(buf)));\n        });\n    }\n}\n\nfuture<foreign_ptr<std::unique_ptr<cql_server::response>>>\n    cql_server::connection::process_request_one(fragmented_temporary_buffer::istream fbuf, uint8_t op, uint16_t stream, service::client_state& client_state, tracing_request_type tracing_request, service_permit permit) {\n    using auth_state = service::client_state::auth_state;\n\n    auto cqlop = static_cast<cql_binary_opcode>(op);\n    tracing::trace_state_props_set trace_props;\n\n    trace_props.set_if<tracing::trace_state_props::log_slow_query>(tracing::tracing::get_local_tracing_instance().slow_query_tracing_enabled());\n    trace_props.set_if<tracing::trace_state_props::full_tracing>(tracing_request != tracing_request_type::not_requested);\n    tracing::trace_state_ptr trace_state;\n\n    if (trace_props) {\n        if (cqlop == cql_binary_opcode::QUERY ||\n            cqlop == cql_binary_opcode::PREPARE ||\n            cqlop == cql_binary_opcode::EXECUTE ||\n            cqlop == cql_binary_opcode::BATCH) {\n            trace_props.set_if<tracing::trace_state_props::write_on_close>(tracing_request == tracing_request_type::write_on_close);\n            trace_state = tracing::tracing::get_local_tracing_instance().create_session(tracing::trace_type::QUERY, trace_props);\n        }\n    }\n\n    tracing::set_request_size(trace_state, fbuf.bytes_left());\n\n    auto linearization_buffer = std::make_unique<bytes_ostream>();\n    auto linearization_buffer_ptr = linearization_buffer.get();\n    return futurize_invoke([this, cqlop, stream, &fbuf, &client_state, linearization_buffer_ptr, permit = std::move(permit), trace_state] () mutable {\n        // When using authentication, we need to ensure we are doing proper state transitions,\n        // i.e. we cannot simply accept any query/exec ops unless auth is complete\n        switch (client_state.get_auth_state()) {\n            case auth_state::UNINITIALIZED:\n                if (cqlop != cql_binary_opcode::STARTUP && cqlop != cql_binary_opcode::OPTIONS) {\n                    throw exceptions::protocol_exception(format(\"Unexpected message {:d}, expecting STARTUP or OPTIONS\", int(cqlop)));\n                }\n                break;\n            case auth_state::AUTHENTICATION:\n                // Support both SASL auth from protocol v2 and the older style Credentials auth from v1\n                if (cqlop != cql_binary_opcode::AUTH_RESPONSE && cqlop != cql_binary_opcode::CREDENTIALS) {\n                    throw exceptions::protocol_exception(format(\"Unexpected message {:d}, expecting {}\", int(cqlop), _version == 1 ? \"CREDENTIALS\" : \"SASL_RESPONSE\"));\n                }\n                break;\n            case auth_state::READY: default:\n                if (cqlop == cql_binary_opcode::STARTUP) {\n                    throw exceptions::protocol_exception(\"Unexpected message STARTUP, the connection is already initialized\");\n                }\n                break;\n        }\n\n        tracing::set_username(trace_state, client_state.user());\n\n        auto wrap_in_foreign = [] (future<std::unique_ptr<cql_server::response>> f) {\n            return f.then([] (std::unique_ptr<cql_server::response> p) {\n                return make_ready_future<result_with_foreign_response_ptr>(make_foreign(std::move(p)));\n            });\n        };\n        auto in = request_reader(std::move(fbuf), *linearization_buffer_ptr);\n        switch (cqlop) {\n        case cql_binary_opcode::STARTUP:       return wrap_in_foreign(process_startup(stream, std::move(in), client_state, trace_state));\n        case cql_binary_opcode::AUTH_RESPONSE: return wrap_in_foreign(process_auth_response(stream, std::move(in), client_state, trace_state));\n        case cql_binary_opcode::OPTIONS:       return wrap_in_foreign(process_options(stream, std::move(in), client_state, trace_state));\n        case cql_binary_opcode::QUERY:         return process_query(stream, std::move(in), client_state, std::move(permit), trace_state);\n        case cql_binary_opcode::PREPARE:       return wrap_in_foreign(process_prepare(stream, std::move(in), client_state, trace_state));\n        case cql_binary_opcode::EXECUTE:       return process_execute(stream, std::move(in), client_state, std::move(permit), trace_state);\n        case cql_binary_opcode::BATCH:         return process_batch(stream, std::move(in), client_state, std::move(permit), trace_state);\n        case cql_binary_opcode::REGISTER:      return wrap_in_foreign(process_register(stream, std::move(in), client_state, trace_state));\n        default:                               throw exceptions::protocol_exception(format(\"Unknown opcode {:d}\", int(cqlop)));\n        }\n    }).then_wrapped([this, cqlop, stream, &client_state, linearization_buffer = std::move(linearization_buffer), trace_state] (future<result_with_foreign_response_ptr> f) {\n        auto stop_trace = defer([&] {\n            tracing::stop_foreground(trace_state);\n        });\n        --_server._stats.requests_serving;\n\n        return utils::result_into_future<result_with_foreign_response_ptr>(utils::result_try([&] () -> result_with_foreign_response_ptr {\n            result_with_foreign_response_ptr res = f.get0();\n            if (!res) {\n                return res;\n            }\n\n            auto response = std::move(res).assume_value();\n            auto res_op = response->opcode();\n\n            // and modify state now that we've generated a response.\n            switch (client_state.get_auth_state()) {\n            case auth_state::UNINITIALIZED:\n                if (cqlop == cql_binary_opcode::STARTUP) {\n                    if (res_op == cql_binary_opcode::AUTHENTICATE) {\n                        client_state.set_auth_state(auth_state::AUTHENTICATION);\n                    } else if (res_op == cql_binary_opcode::READY) {\n                        client_state.set_auth_state(auth_state::READY);\n                    }\n                }\n                break;\n            case auth_state::AUTHENTICATION:\n                // Support both SASL auth from protocol v2 and the older style Credentials auth from v1\n                if (cqlop != cql_binary_opcode::AUTH_RESPONSE && cqlop != cql_binary_opcode::CREDENTIALS) {\n                    throw exceptions::protocol_exception(format(\"Unexpected message {:d}, expecting AUTH_RESPONSE or CREDENTIALS\", int(cqlop)));\n                }\n                if (res_op == cql_binary_opcode::READY || res_op == cql_binary_opcode::AUTH_SUCCESS) {\n                    client_state.set_auth_state(auth_state::READY);\n                }\n                break;\n            default:\n            case auth_state::READY:\n                break;\n            }\n\n            tracing::set_response_size(trace_state, response->size());\n            return response;\n        },  utils::result_catch<exceptions::unavailable_exception>([&] (const auto& ex) {\n            try { ++_server._stats.errors[ex.code()]; } catch(...) {}\n            return make_unavailable_error(stream, ex.code(), ex.what(), ex.consistency, ex.required, ex.alive, trace_state);\n        }), utils::result_catch<exceptions::read_timeout_exception>([&] (const auto& ex) {\n            try { ++_server._stats.errors[ex.code()]; } catch(...) {}\n            return make_read_timeout_error(stream, ex.code(), ex.what(), ex.consistency, ex.received, ex.block_for, ex.data_present, trace_state);\n        }), utils::result_catch<exceptions::read_failure_exception>([&] (const auto& ex) {\n            try { ++_server._stats.errors[ex.code()]; } catch(...) {}\n            return make_read_failure_error(stream, ex.code(), ex.what(), ex.consistency, ex.received, ex.failures, ex.block_for, ex.data_present, trace_state);\n        }), utils::result_catch<exceptions::mutation_write_timeout_exception>([&] (const auto& ex) {\n            try { ++_server._stats.errors[ex.code()]; } catch(...) {}\n            return make_mutation_write_timeout_error(stream, ex.code(), ex.what(), ex.consistency, ex.received, ex.block_for, ex.type, trace_state);\n        }), utils::result_catch<exceptions::mutation_write_failure_exception>([&] (const auto& ex) {\n            try { ++_server._stats.errors[ex.code()]; } catch(...) {}\n            return make_mutation_write_failure_error(stream, ex.code(), ex.what(), ex.consistency, ex.received, ex.failures, ex.block_for, ex.type, trace_state);\n        }), utils::result_catch<exceptions::already_exists_exception>([&] (const auto& ex) {\n            try { ++_server._stats.errors[ex.code()]; } catch(...) {}\n            return make_already_exists_error(stream, ex.code(), ex.what(), ex.ks_name, ex.cf_name, trace_state);\n        }), utils::result_catch<exceptions::prepared_query_not_found_exception>([&] (const auto& ex) {\n            try { ++_server._stats.errors[ex.code()]; } catch(...) {}\n            return make_unprepared_error(stream, ex.code(), ex.what(), ex.id, trace_state);\n        }), utils::result_catch<exceptions::function_execution_exception>([&] (const auto& ex) {\n            try { ++_server._stats.errors[ex.code()]; } catch(...) {}\n            return make_function_failure_error(stream, ex.code(), ex.what(), ex.ks_name, ex.func_name, ex.args, trace_state);\n        }), utils::result_catch<exceptions::rate_limit_exception>([&] (const auto& ex) {\n            try { ++_server._stats.errors[ex.code()]; } catch(...) {}\n            return make_rate_limit_error(stream, ex.code(), ex.what(), ex.op_type, ex.rejected_by_coordinator, trace_state, client_state);\n        }), utils::result_catch<exceptions::cassandra_exception>([&] (const auto& ex) {\n            // Note: the CQL protocol specifies that many types of errors have\n            // mandatory parameters. These cassandra_exception subclasses MUST\n            // be handled above. This default \"cassandra_exception\" case is\n            // only appropriate for the specific types of errors which do not have\n            // additional information, such as invalid_request_exception.\n            // TODO: consider listing those types explicitly, instead of the\n            // catch-all type cassandra_exception.\n            try { ++_server._stats.errors[ex.code()]; } catch(...) {}\n            return make_error(stream, ex.code(), ex.what(), trace_state);\n        }), utils::result_catch<std::exception>([&] (const auto& ex) {\n            try { ++_server._stats.errors[exceptions::exception_code::SERVER_ERROR]; } catch(...) {}\n            sstring msg = ex.what();\n            try {\n                std::rethrow_if_nested(ex);\n            } catch (...) {\n                std::ostringstream ss;\n                ss << msg << \": \" << std::current_exception();\n                msg = ss.str();\n            }\n            return make_error(stream, exceptions::exception_code::SERVER_ERROR, msg, trace_state);\n        }), utils::result_catch_dots([&] () {\n            try { ++_server._stats.errors[exceptions::exception_code::SERVER_ERROR]; } catch(...) {}\n            return make_error(stream, exceptions::exception_code::SERVER_ERROR, \"unknown error\", trace_state);\n        })));\n    });\n}\n\ncql_server::connection::connection(cql_server& server, socket_address server_addr, connected_socket&& fd, socket_address addr)\n    : generic_server::connection{server, std::move(fd)}\n    , _server(server)\n    , _server_addr(server_addr)\n    , _client_state(service::client_state::external_tag{}, server._auth_service, &server._sl_controller, server.timeout_config(), addr)\n{\n    _shedding_timer.set_callback([this] {\n        clogger.debug(\"Shedding all incoming requests due to overload\");\n        _shed_incoming_requests = true;\n    });\n}\n\ncql_server::connection::~connection() {\n}\n\nvoid cql_server::connection::on_connection_close()\n{\n    _server._notifier->unregister_connection(this);\n}\n\nstd::tuple<net::inet_address, int, client_type> cql_server::connection::make_client_key(const service::client_state& cli_state) {\n    return std::make_tuple(cli_state.get_client_address().addr(),\n            cli_state.get_client_port(),\n            cli_state.is_thrift() ? client_type::thrift : client_type::cql);\n}\n\nclient_data cql_server::connection::make_client_data() const {\n    client_data cd;\n    std::tie(cd.ip, cd.port, cd.ct) = make_client_key(_client_state);\n    cd.shard_id = this_shard_id();\n    cd.protocol_version = _version;\n    cd.driver_name = _client_state.get_driver_name();\n    cd.driver_version = _client_state.get_driver_version();\n    if (const auto user_ptr = _client_state.user(); user_ptr) {\n        cd.username = user_ptr->name;\n    }\n    if (_ready) {\n        cd.connection_stage = client_connection_stage::ready;\n    } else if (_authenticating) {\n        cd.connection_stage = client_connection_stage::authenticating;\n    }\n    return cd;\n}\n\nthread_local cql_server::connection::execution_stage_type\n        cql_server::connection::_process_request_stage{\"transport\", &connection::process_request_one};\n\nvoid cql_server::connection::handle_error(future<>&& f) {\n    try {\n        f.get();\n    } catch (const exceptions::cassandra_exception& ex) {\n        try { ++_server._stats.errors[ex.code()]; } catch(...) {}\n        write_response(make_error(0, ex.code(), ex.what(), tracing::trace_state_ptr()));\n    } catch (std::exception& ex) {\n        try { ++_server._stats.errors[exceptions::exception_code::SERVER_ERROR]; } catch(...) {}\n        write_response(make_error(0, exceptions::exception_code::SERVER_ERROR, ex.what(), tracing::trace_state_ptr()));\n    } catch (...) {\n        try { ++_server._stats.errors[exceptions::exception_code::SERVER_ERROR]; } catch(...) {}\n        write_response(make_error(0, exceptions::exception_code::SERVER_ERROR, \"unknown error\", tracing::trace_state_ptr()));\n    }\n}\n\nfuture<> cql_server::connection::process_request() {\n    return read_frame().then_wrapped([this] (future<std::optional<cql_binary_frame_v3>>&& v) {\n        auto maybe_frame = v.get0();\n        if (!maybe_frame) {\n            // eof\n            return make_ready_future<>();\n        }\n\n        auto& f = *maybe_frame;\n\n        const bool allow_shedding = _client_state.get_workload_type() == service::client_state::workload_type::interactive;\n        if (allow_shedding && _shed_incoming_requests) {\n            ++_server._stats.requests_shed;\n            return _read_buf.skip(f.length).then([this, stream = f.stream] {\n                write_response(make_error(stream, exceptions::exception_code::OVERLOADED,\n                        \"request shed due to coordinator overload\", tracing::trace_state_ptr()));\n                return make_ready_future<>();\n            });\n        }\n\n        tracing_request_type tracing_requested = tracing_request_type::not_requested;\n        if (f.flags & cql_frame_flags::tracing) {\n            // If tracing is requested for a specific CQL command - flush\n            // tracing info right after the command is over.\n            tracing_requested = tracing_request_type::write_on_close;\n        } else if (tracing::tracing::get_local_tracing_instance().trace_next_query()) {\n            tracing_requested = tracing_request_type::no_write_on_close;\n        }\n\n        auto op = f.opcode;\n        auto stream = f.stream;\n        auto mem_estimate = f.length * 2 + 8000; // Allow for extra copies and bookkeeping\n        if (mem_estimate > _server._max_request_size) {\n            write_response(make_error(stream, exceptions::exception_code::INVALID,\n                    format(\"request size too large (frame size {:d}; estimate {:d}; allowed {:d}\", f.length, mem_estimate, _server._max_request_size),\n                    tracing::trace_state_ptr()));\n            return std::exchange(_ready_to_respond, make_ready_future<>()).then([this] {\n                return _read_buf.close();\n            });\n        }\n\n        if (_server._stats.requests_serving > _server._max_concurrent_requests) {\n            ++_server._stats.requests_shed;\n            return _read_buf.skip(f.length).then([this, stream = f.stream] {\n                write_response(make_error(stream, exceptions::exception_code::OVERLOADED,\n                        format(\"too many in-flight requests (configured via max_concurrent_requests_per_shard): {}\", _server._stats.requests_serving),\n                        tracing::trace_state_ptr()));\n                return make_ready_future<>();\n            });\n        }\n\n        const auto shedding_timeout = std::chrono::milliseconds(50);\n        auto fut = allow_shedding\n                ? get_units(_server._memory_available, mem_estimate, shedding_timeout).then_wrapped([this, length = f.length] (auto f) {\n                    try {\n                        return make_ready_future<semaphore_units<>>(f.get0());\n                    } catch (semaphore_timed_out sto) {\n                        // Cancel shedding in case no more requests are going to do that on completion\n                        if (_pending_requests_gate.get_count() == 0) {\n                            _shed_incoming_requests = false;\n                        }\n                        return _read_buf.skip(length).then([sto = std::move(sto)] () mutable {\n                            return make_exception_future<semaphore_units<>>(std::move(sto));\n                        });\n                    }\n                })\n                : get_units(_server._memory_available, mem_estimate);\n        if (_server._memory_available.waiters()) {\n            if (allow_shedding && !_shedding_timer.armed()) {\n                _shedding_timer.arm(shedding_timeout);\n            }\n            ++_server._stats.requests_blocked_memory;\n        }\n\n        return fut.then_wrapped([this, length = f.length, flags = f.flags, op, stream, tracing_requested] (auto mem_permit_fut) {\n          if (mem_permit_fut.failed()) {\n              // Ignore semaphore errors - they are expected if load shedding took place\n              mem_permit_fut.ignore_ready_future();\n              return make_ready_future<>();\n          }\n          semaphore_units<> mem_permit = mem_permit_fut.get0();\n          return this->read_and_decompress_frame(length, flags).then([this, op, stream, tracing_requested, mem_permit = make_service_permit(std::move(mem_permit))] (fragmented_temporary_buffer buf) mutable {\n\n            ++_server._stats.requests_served;\n            ++_server._stats.requests_serving;\n\n            _pending_requests_gate.enter();\n            auto leave = defer([this] {\n                _shedding_timer.cancel();\n                _shed_incoming_requests = false;\n                _pending_requests_gate.leave();\n            });\n            auto istream = buf.get_istream();\n            (void)_process_request_stage(this, istream, op, stream, seastar::ref(_client_state), tracing_requested, mem_permit)\n                    .then_wrapped([this, buf = std::move(buf), mem_permit, leave = std::move(leave)] (future<foreign_ptr<std::unique_ptr<cql_server::response>>> response_f) mutable {\n                try {\n                    write_response(response_f.get0(), std::move(mem_permit), _compression);\n                    _ready_to_respond = _ready_to_respond.finally([leave = std::move(leave)] {});\n                } catch (...) {\n                    clogger.error(\"request processing failed: {}\", std::current_exception());\n                }\n            });\n\n            return make_ready_future<>();\n          });\n        });\n    });\n}\n\nnamespace compression_buffers {\n\n// Reusable buffers for compression and decompression. Cleared every\n// clear_buffers_trigger uses.\nstatic constexpr size_t clear_buffers_trigger = 100'000;\nstatic thread_local size_t buffer_use_count = 0;\nstatic thread_local utils::reusable_buffer input_buffer;\nstatic thread_local utils::reusable_buffer output_buffer;\n\nvoid on_compression_buffer_use() {\n    if (++buffer_use_count == clear_buffers_trigger) {\n        input_buffer.clear();\n        output_buffer.clear();\n        buffer_use_count = 0;\n    }\n}\n\n}\n\nfuture<fragmented_temporary_buffer> cql_server::connection::read_and_decompress_frame(size_t length, uint8_t flags)\n{\n    using namespace compression_buffers;\n    if (flags & cql_frame_flags::compression) {\n        if (_compression == cql_compression::lz4) {\n            if (length < 4) {\n                throw std::runtime_error(fmt::format(\"CQL frame truncated: expected to have at least 4 bytes, got {}\", length));\n            }\n            return _buffer_reader.read_exactly(_read_buf, length).then([this] (fragmented_temporary_buffer buf) {\n                auto linearization_buffer = bytes_ostream();\n                int32_t uncomp_len = request_reader(buf.get_istream(), linearization_buffer).read_int();\n                if (uncomp_len < 0) {\n                    throw std::runtime_error(\"CQL frame uncompressed length is negative: \" + std::to_string(uncomp_len));\n                }\n                buf.remove_prefix(4);\n                auto in = input_buffer.get_linearized_view(fragmented_temporary_buffer::view(buf));\n                auto uncomp = output_buffer.make_fragmented_temporary_buffer(uncomp_len, fragmented_temporary_buffer::default_fragment_size, [&] (bytes_mutable_view out) {\n                    auto ret = LZ4_decompress_safe(reinterpret_cast<const char*>(in.data()), reinterpret_cast<char*>(out.data()),\n                                                   in.size(), out.size());\n                    if (ret < 0) {\n                        throw std::runtime_error(\"CQL frame LZ4 uncompression failure\");\n                    }\n                    return out.size();\n                });\n                on_compression_buffer_use();\n                return uncomp;\n            });\n        } else if (_compression == cql_compression::snappy) {\n            return _buffer_reader.read_exactly(_read_buf, length).then([this] (fragmented_temporary_buffer buf) {\n                auto in = input_buffer.get_linearized_view(fragmented_temporary_buffer::view(buf));\n                size_t uncomp_len;\n                if (snappy_uncompressed_length(reinterpret_cast<const char*>(in.data()), in.size(), &uncomp_len) != SNAPPY_OK) {\n                    throw std::runtime_error(\"CQL frame Snappy uncompressed size is unknown\");\n                }\n                auto uncomp = output_buffer.make_fragmented_temporary_buffer(uncomp_len, fragmented_temporary_buffer::default_fragment_size, [&] (bytes_mutable_view out) {\n                    size_t output_len = out.size();\n                    if (snappy_uncompress(reinterpret_cast<const char*>(in.data()), in.size(), reinterpret_cast<char*>(out.data()), &output_len) != SNAPPY_OK) {\n                        throw std::runtime_error(\"CQL frame Snappy uncompression failure\");\n                    }\n                    return output_len;\n                });\n                on_compression_buffer_use();\n                return uncomp;\n            });\n        } else {\n            throw exceptions::protocol_exception(format(\"Unknown compression algorithm\"));\n        }\n    }\n    return _buffer_reader.read_exactly(_read_buf, length);\n}\n\nfuture<std::unique_ptr<cql_server::response>> cql_server::connection::process_startup(uint16_t stream, request_reader in, service::client_state& client_state,\n        tracing::trace_state_ptr trace_state) {\n    ++_server._stats.startups;\n    auto options = in.read_string_map();\n    auto compression_opt = options.find(\"COMPRESSION\");\n    if (compression_opt != options.end()) {\n         auto compression = compression_opt->second;\n         std::transform(compression.begin(), compression.end(), compression.begin(), ::tolower);\n         if (compression == \"lz4\") {\n             _compression = cql_compression::lz4;\n         } else if (compression == \"snappy\") {\n             _compression = cql_compression::snappy;\n         } else {\n             throw exceptions::protocol_exception(format(\"Unknown compression algorithm: {}\", compression));\n         }\n    }\n\n    if (auto driver_ver_opt = options.find(\"DRIVER_VERSION\"); driver_ver_opt != options.end()) {\n        _client_state.set_driver_version(driver_ver_opt->second);\n    }\n    if (auto driver_name_opt = options.find(\"DRIVER_NAME\"); driver_name_opt != options.end()) {\n        _client_state.set_driver_name(driver_name_opt->second);\n    }\n\n    cql_protocol_extension_enum_set cql_proto_exts;\n    for (cql_protocol_extension ext : supported_cql_protocol_extensions()) {\n        if (options.contains(protocol_extension_name(ext))) {\n            cql_proto_exts.set(ext);\n        }\n    }\n    _client_state.set_protocol_extensions(std::move(cql_proto_exts));\n    std::unique_ptr<cql_server::response> res;\n    if (auto& a = client_state.get_auth_service()->underlying_authenticator(); a.require_authentication()) {\n        _authenticating = true;\n        res = make_autheticate(stream, a.qualified_java_name(), trace_state);\n    } else {\n        _ready = true;\n        res = make_ready(stream, trace_state);\n    }\n\n    return make_ready_future<decltype(res)>(std::move(res));\n}\n\nfuture<std::unique_ptr<cql_server::response>> cql_server::connection::process_auth_response(uint16_t stream, request_reader in, service::client_state& client_state,\n        tracing::trace_state_ptr trace_state) {\n    ++_server._stats.auth_responses;\n    auto sasl_challenge = client_state.get_auth_service()->underlying_authenticator().new_sasl_challenge();\n    auto buf = in.read_raw_bytes_view(in.bytes_left());\n    auto challenge = sasl_challenge->evaluate_response(buf);\n    if (sasl_challenge->is_complete()) {\n        return sasl_challenge->get_authenticated_user().then([this, sasl_challenge, stream, &client_state, challenge = std::move(challenge), trace_state](auth::authenticated_user user) mutable {\n            client_state.set_login(std::move(user));\n            auto f = client_state.check_user_can_login();\n            f = f.then([&client_state] {\n                return client_state.maybe_update_per_service_level_params();\n            });\n            return f.then([this, stream, &client_state, challenge = std::move(challenge), trace_state]() mutable {\n                return make_ready_future<std::unique_ptr<cql_server::response>>(make_auth_success(stream, std::move(challenge), trace_state));\n            });\n        });\n    }\n    return make_ready_future<std::unique_ptr<cql_server::response>>(make_auth_challenge(stream, std::move(challenge), trace_state));\n}\n\nfuture<std::unique_ptr<cql_server::response>> cql_server::connection::process_options(uint16_t stream, request_reader in, service::client_state& client_state,\n        tracing::trace_state_ptr trace_state) {\n    ++_server._stats.options_requests;\n    return make_ready_future<std::unique_ptr<cql_server::response>>(make_supported(stream, std::move(trace_state)));\n}\n\nvoid\ncql_server::connection::init_cql_serialization_format() {\n    _cql_serialization_format = cql_serialization_format(_version);\n}\n\nstd::unique_ptr<cql_server::response>\nmake_result(int16_t stream, messages::result_message& msg, const tracing::trace_state_ptr& tr_state,\n        cql_protocol_version_type version, bool skip_metadata = false);\n\ntemplate<typename Process>\nfuture<cql_server::result_with_foreign_response_ptr>\ncql_server::connection::process_on_shard(::shared_ptr<messages::result_message::bounce_to_shard> bounce_msg, uint16_t stream, fragmented_temporary_buffer::istream is,\n        service::client_state& cs, service_permit permit, tracing::trace_state_ptr trace_state, Process process_fn) {\n    return _server.container().invoke_on(*bounce_msg->move_to_shard(), _server._config.bounce_request_smp_service_group,\n            [this, is = std::move(is), cs = cs.move_to_other_shard(), stream, permit = std::move(permit), process_fn,\n             gt = tracing::global_trace_state_ptr(std::move(trace_state)),\n             cached_vals = std::move(bounce_msg->take_cached_pk_function_calls())] (cql_server& server) {\n        service::client_state client_state = cs.get();\n        return do_with(bytes_ostream(), std::move(client_state), std::move(cached_vals),\n                [this, &server, is = std::move(is), stream, process_fn,\n                 trace_state = tracing::trace_state_ptr(gt)] (bytes_ostream& linearization_buffer,\n                    service::client_state& client_state,\n                    cql3::computed_function_values& cached_vals) mutable {\n            request_reader in(is, linearization_buffer);\n            return process_fn(client_state, server._query_processor, in, stream, _version, _cql_serialization_format,\n                    /* FIXME */empty_service_permit(), std::move(trace_state), false, std::move(cached_vals)).then([] (auto msg) {\n                // result here has to be foreign ptr\n                return std::get<cql_server::result_with_foreign_response_ptr>(std::move(msg));\n            });\n        });\n    });\n}\n\nusing process_fn_return_type = std::variant<\n    cql_server::result_with_foreign_response_ptr,\n    ::shared_ptr<messages::result_message::bounce_to_shard>>;\n\nstatic inline cql_server::result_with_foreign_response_ptr convert_error_message_to_coordinator_result(messages::result_message* msg) {\n    return std::move(*dynamic_cast<messages::result_message::exception*>(msg)).get_exception();\n}\n\ntemplate<typename Process>\nfuture<cql_server::result_with_foreign_response_ptr>\ncql_server::connection::process(uint16_t stream, request_reader in, service::client_state& client_state, service_permit permit,\n        tracing::trace_state_ptr trace_state, Process process_fn) {\n    fragmented_temporary_buffer::istream is = in.get_stream();\n\n    return process_fn(client_state, _server._query_processor, in, stream,\n            _version, _cql_serialization_format, permit, trace_state, true, {})\n            .then([stream, &client_state, this, is, permit, process_fn, trace_state]\n                   (process_fn_return_type msg) mutable {\n        auto* bounce_msg = std::get_if<shared_ptr<messages::result_message::bounce_to_shard>>(&msg);\n        if (bounce_msg) {\n            return process_on_shard(*bounce_msg, stream, is, client_state, std::move(permit), trace_state, process_fn);\n        }\n        auto ptr = std::get<cql_server::result_with_foreign_response_ptr>(std::move(msg));\n        return make_ready_future<cql_server::result_with_foreign_response_ptr>(std::move(ptr));\n    });\n}\n\nstatic future<process_fn_return_type>\nprocess_query_internal(service::client_state& client_state, distributed<cql3::query_processor>& qp, request_reader in,\n        uint16_t stream, cql_protocol_version_type version, cql_serialization_format serialization_format,\n        service_permit permit, tracing::trace_state_ptr trace_state, bool init_trace, cql3::computed_function_values cached_pk_fn_calls) {\n    auto query = in.read_long_string_view();\n    auto q_state = std::make_unique<cql_query_state>(client_state, trace_state, std::move(permit));\n    auto& query_state = q_state->query_state;\n    q_state->options = in.read_options(version, serialization_format, qp.local().get_cql_config());\n    auto& options = *q_state->options;\n    if (!cached_pk_fn_calls.empty()) {\n        options.set_cached_pk_function_calls(std::move(cached_pk_fn_calls));\n    }\n    auto skip_metadata = options.skip_metadata();\n\n    if (init_trace) {\n        tracing::set_page_size(trace_state, options.get_page_size());\n        tracing::set_consistency_level(trace_state, options.get_consistency());\n        tracing::set_optional_serial_consistency_level(trace_state, options.get_serial_consistency());\n        tracing::add_query(trace_state, query);\n        tracing::set_user_timestamp(trace_state, options.get_specific_options().timestamp);\n\n        tracing::begin(trace_state, \"Execute CQL3 query\", client_state.get_client_address());\n    }\n\n    return qp.local().execute_direct_without_checking_exception_message(query, query_state, options).then([q_state = std::move(q_state), stream, skip_metadata, version] (auto msg) {\n        if (msg->move_to_shard()) {\n            return process_fn_return_type(dynamic_pointer_cast<messages::result_message::bounce_to_shard>(msg));\n        } else if (msg->is_exception()) {\n            return process_fn_return_type(convert_error_message_to_coordinator_result(msg.get()));\n        } else {\n            tracing::trace(q_state->query_state.get_trace_state(), \"Done processing - preparing a result\");\n            return process_fn_return_type(make_foreign(make_result(stream, *msg, q_state->query_state.get_trace_state(), version, skip_metadata)));\n        }\n    });\n}\n\nfuture<cql_server::result_with_foreign_response_ptr>\ncql_server::connection::process_query(uint16_t stream, request_reader in, service::client_state& client_state, service_permit permit, tracing::trace_state_ptr trace_state) {\n    ++_server._stats.query_requests;\n    return process(stream, in, client_state, std::move(permit), std::move(trace_state), process_query_internal);\n}\n\nfuture<std::unique_ptr<cql_server::response>> cql_server::connection::process_prepare(uint16_t stream, request_reader in, service::client_state& client_state,\n        tracing::trace_state_ptr trace_state) {\n    ++_server._stats.prepare_requests;\n\n    auto query = sstring(in.read_long_string_view());\n\n    tracing::add_query(trace_state, query);\n    tracing::begin(trace_state, \"Preparing CQL3 query\", client_state.get_client_address());\n\n    auto cpu_id = this_shard_id();\n    auto cpus = boost::irange(0u, smp::count);\n    return parallel_for_each(cpus.begin(), cpus.end(), [this, query, cpu_id, &client_state] (unsigned int c) mutable {\n        if (c != cpu_id) {\n            return smp::submit_to(c, [this, query, &client_state] () mutable {\n                return _server._query_processor.local().prepare(std::move(query), client_state, false).discard_result();\n            });\n        } else {\n            return make_ready_future<>();\n        }\n    }).then([this, query, stream, &client_state, trace_state] () mutable {\n        tracing::trace(trace_state, \"Done preparing on remote shards\");\n        return _server._query_processor.local().prepare(std::move(query), client_state, false).then([this, stream, &client_state, trace_state] (auto msg) {\n            tracing::trace(trace_state, \"Done preparing on a local shard - preparing a result. ID is [{}]\", seastar::value_of([&msg] {\n                return messages::result_message::prepared::cql::get_id(msg);\n            }));\n            return make_result(stream, *msg, trace_state, _version);\n        });\n    });\n}\n\nstatic future<process_fn_return_type>\nprocess_execute_internal(service::client_state& client_state, distributed<cql3::query_processor>& qp, request_reader in,\n        uint16_t stream, cql_protocol_version_type version, cql_serialization_format serialization_format,\n        service_permit permit, tracing::trace_state_ptr trace_state, bool init_trace, cql3::computed_function_values cached_pk_fn_calls) {\n    cql3::prepared_cache_key_type cache_key(in.read_short_bytes());\n    auto& id = cql3::prepared_cache_key_type::cql_id(cache_key);\n    bool needs_authorization = false;\n\n    // First, try to lookup in the cache of already authorized statements. If the corresponding entry is not found there\n    // look for the prepared statement and then authorize it.\n    auto prepared = qp.local().get_prepared(client_state.user(), cache_key);\n    if (!prepared) {\n        needs_authorization = true;\n        prepared = qp.local().get_prepared(cache_key);\n    }\n\n    if (!prepared) {\n        throw exceptions::prepared_query_not_found_exception(id);\n    }\n\n    auto q_state = std::make_unique<cql_query_state>(client_state, trace_state, std::move(permit));\n    auto& query_state = q_state->query_state;\n    if (version == 1) {\n        std::vector<cql3::raw_value_view> values;\n        in.read_value_view_list(version, values);\n        auto consistency = in.read_consistency();\n        q_state->options = std::make_unique<cql3::query_options>(qp.local().get_cql_config(), consistency, std::nullopt, values, false,\n                                                                 cql3::query_options::specific_options::DEFAULT, serialization_format);\n    } else {\n        q_state->options = in.read_options(version, serialization_format, qp.local().get_cql_config());\n    }\n    auto& options = *q_state->options;\n    if (!cached_pk_fn_calls.empty()) {\n        options.set_cached_pk_function_calls(std::move(cached_pk_fn_calls));\n    }\n    auto skip_metadata = options.skip_metadata();\n\n    if (init_trace) {\n        tracing::set_page_size(trace_state, options.get_page_size());\n        tracing::set_consistency_level(trace_state, options.get_consistency());\n        tracing::set_optional_serial_consistency_level(trace_state, options.get_serial_consistency());\n        tracing::add_query(trace_state, prepared->statement->raw_cql_statement);\n        tracing::add_prepared_statement(trace_state, prepared);\n\n        tracing::begin(trace_state, seastar::value_of([&id] { return seastar::format(\"Execute CQL3 prepared query [{}]\", id); }),\n                client_state.get_client_address());\n    }\n\n    auto stmt = prepared->statement;\n    tracing::trace(query_state.get_trace_state(), \"Checking bounds\");\n    if (stmt->get_bound_terms() != options.get_values_count()) {\n        const auto msg = format(\"Invalid amount of bind variables: expected {:d} received {:d}\",\n                stmt->get_bound_terms(),\n                options.get_values_count());\n        tracing::trace(query_state.get_trace_state(), msg);\n        throw exceptions::invalid_request_exception(msg);\n    }\n\n    options.prepare(prepared->bound_names);\n\n    if (init_trace) {\n        tracing::add_prepared_query_options(trace_state, options);\n    }\n\n    tracing::trace(trace_state, \"Processing a statement\");\n    return qp.local().execute_prepared_without_checking_exception_message(std::move(prepared), std::move(cache_key), query_state, options, needs_authorization)\n            .then([trace_state = query_state.get_trace_state(), skip_metadata, q_state = std::move(q_state), stream, version] (auto msg) {\n        if (msg->move_to_shard()) {\n            return process_fn_return_type(dynamic_pointer_cast<messages::result_message::bounce_to_shard>(msg));\n        } else if (msg->is_exception()) {\n            return process_fn_return_type(convert_error_message_to_coordinator_result(msg.get()));\n        } else {\n            tracing::trace(q_state->query_state.get_trace_state(), \"Done processing - preparing a result\");\n            return process_fn_return_type(make_foreign(make_result(stream, *msg, q_state->query_state.get_trace_state(), version, skip_metadata)));\n        }\n    });\n}\n\nfuture<cql_server::result_with_foreign_response_ptr> cql_server::connection::process_execute(uint16_t stream, request_reader in,\n        service::client_state& client_state, service_permit permit, tracing::trace_state_ptr trace_state) {\n    ++_server._stats.execute_requests;\n    return process(stream, in, client_state, std::move(permit), std::move(trace_state), process_execute_internal);\n}\n\nstatic future<process_fn_return_type>\nprocess_batch_internal(service::client_state& client_state, distributed<cql3::query_processor>& qp, request_reader in,\n        uint16_t stream, cql_protocol_version_type version, cql_serialization_format serialization_format,\n        service_permit permit, tracing::trace_state_ptr trace_state, bool init_trace, cql3::computed_function_values cached_pk_fn_calls) {\n    if (version == 1) {\n        throw exceptions::protocol_exception(\"BATCH messages are not support in version 1 of the protocol\");\n    }\n\n    const auto type = in.read_byte();\n    const unsigned n = in.read_short();\n\n    std::vector<cql3::statements::batch_statement::single_statement> modifications;\n    std::vector<std::vector<cql3::raw_value_view>> values;\n    std::unordered_map<cql3::prepared_cache_key_type, cql3::authorized_prepared_statements_cache::value_type> pending_authorization_entries;\n\n    modifications.reserve(n);\n    values.reserve(n);\n\n    if (init_trace) {\n        tracing::begin(trace_state, \"Execute batch of CQL3 queries\", client_state.get_client_address());\n    }\n\n    for ([[gnu::unused]] auto i : boost::irange(0u, n)) {\n        const auto kind = in.read_byte();\n\n        std::unique_ptr<cql3::statements::prepared_statement> stmt_ptr;\n        cql3::statements::prepared_statement::checked_weak_ptr ps;\n        bool needs_authorization(kind == 0);\n\n        switch (kind) {\n        case 0: {\n            auto query = in.read_long_string_view();\n            stmt_ptr = qp.local().get_statement(query, client_state);\n            ps = stmt_ptr->checked_weak_from_this();\n            if (init_trace) {\n                tracing::add_query(trace_state, query);\n            }\n            break;\n        }\n        case 1: {\n            cql3::prepared_cache_key_type cache_key(in.read_short_bytes());\n            auto& id = cql3::prepared_cache_key_type::cql_id(cache_key);\n\n            // First, try to lookup in the cache of already authorized statements. If the corresponding entry is not found there\n            // look for the prepared statement and then authorize it.\n            ps = qp.local().get_prepared(client_state.user(), cache_key);\n            if (!ps) {\n                ps = qp.local().get_prepared(cache_key);\n                if (!ps) {\n                    throw exceptions::prepared_query_not_found_exception(id);\n                }\n                // authorize a particular prepared statement only once\n                needs_authorization = pending_authorization_entries.emplace(std::move(cache_key), ps->checked_weak_from_this()).second;\n            }\n            if (init_trace) {\n                tracing::add_query(trace_state, ps->statement->raw_cql_statement);\n            }\n            break;\n        }\n        default:\n            throw exceptions::protocol_exception(\n                    \"Invalid query kind in BATCH messages. Must be 0 or 1 but got \"\n                            + std::to_string(int(kind)));\n        }\n\n        if (dynamic_cast<cql3::statements::modification_statement*>(ps->statement.get()) == nullptr) {\n            throw exceptions::invalid_request_exception(\"Invalid statement in batch: only UPDATE, INSERT and DELETE statements are allowed.\");\n        }\n\n        ::shared_ptr<cql3::statements::modification_statement> modif_statement_ptr = static_pointer_cast<cql3::statements::modification_statement>(ps->statement);\n        if (init_trace) {\n            tracing::add_table_name(trace_state, modif_statement_ptr->keyspace(), modif_statement_ptr->column_family());\n            tracing::add_prepared_statement(trace_state, ps);\n        }\n\n        modifications.emplace_back(std::move(modif_statement_ptr), needs_authorization);\n\n        std::vector<cql3::raw_value_view> tmp;\n        in.read_value_view_list(version, tmp);\n\n        auto stmt = ps->statement;\n        if (stmt->get_bound_terms() != tmp.size()) {\n            throw exceptions::invalid_request_exception(format(\"There were {:d} markers(?) in CQL but {:d} bound variables\",\n                            stmt->get_bound_terms(), tmp.size()));\n        }\n        values.emplace_back(std::move(tmp));\n    }\n\n    auto q_state = std::make_unique<cql_query_state>(client_state, trace_state, std::move(permit));\n    auto& query_state = q_state->query_state;\n    // #563. CQL v2 encodes query_options in v1 format for batch requests.\n    q_state->options = std::make_unique<cql3::query_options>(cql3::query_options::make_batch_options(std::move(*in.read_options(version < 3 ? 1 : version, serialization_format,\n                                                                     qp.local().get_cql_config())), std::move(values)));\n    auto& options = *q_state->options;\n    if (!cached_pk_fn_calls.empty()) {\n        options.set_cached_pk_function_calls(std::move(cached_pk_fn_calls));\n    }\n\n    if (init_trace) {\n        tracing::set_consistency_level(trace_state, options.get_consistency());\n        tracing::set_optional_serial_consistency_level(trace_state, options.get_serial_consistency());\n        tracing::add_prepared_query_options(trace_state, options);\n        tracing::trace(trace_state, \"Creating a batch statement\");\n    }\n\n    auto batch = ::make_shared<cql3::statements::batch_statement>(cql3::statements::batch_statement::type(type), std::move(modifications), cql3::attributes::none(), qp.local().get_cql_stats());\n    return qp.local().execute_batch_without_checking_exception_message(batch, query_state, options, std::move(pending_authorization_entries))\n            .then([stream, batch, q_state = std::move(q_state), trace_state = query_state.get_trace_state(), version] (auto msg) {\n        if (msg->move_to_shard()) {\n            return process_fn_return_type(dynamic_pointer_cast<messages::result_message::bounce_to_shard>(msg));\n        } else if (msg->is_exception()) {\n            return process_fn_return_type(convert_error_message_to_coordinator_result(msg.get()));\n        } else {\n            tracing::trace(q_state->query_state.get_trace_state(), \"Done processing - preparing a result\");\n            return process_fn_return_type(make_foreign(make_result(stream, *msg, trace_state, version)));\n        }\n    });\n}\n\nfuture<cql_server::result_with_foreign_response_ptr>\ncql_server::connection::process_batch(uint16_t stream, request_reader in, service::client_state& client_state, service_permit permit,\n        tracing::trace_state_ptr trace_state) {\n    ++_server._stats.batch_requests;\n    return process(stream, in, client_state, permit, std::move(trace_state), process_batch_internal);\n}\n\nfuture<std::unique_ptr<cql_server::response>>\ncql_server::connection::process_register(uint16_t stream, request_reader in, service::client_state& client_state,\n        tracing::trace_state_ptr trace_state) {\n    ++_server._stats.register_requests;\n    std::vector<sstring> event_types;\n    in.read_string_list(event_types);\n    for (auto&& event_type : event_types) {\n        auto et = parse_event_type(event_type);\n        _server._notifier->register_event(et, this);\n    }\n    _ready = true;\n    return make_ready_future<std::unique_ptr<cql_server::response>>(make_ready(stream, std::move(trace_state)));\n}\n\nstd::unique_ptr<cql_server::response> cql_server::connection::make_unavailable_error(int16_t stream, exceptions::exception_code err, sstring msg, db::consistency_level cl, int32_t required, int32_t alive, const tracing::trace_state_ptr& tr_state) const\n{\n    auto response = std::make_unique<cql_server::response>(stream, cql_binary_opcode::ERROR, tr_state);\n    response->write_int(static_cast<int32_t>(err));\n    response->write_string(msg);\n    response->write_consistency(cl);\n    response->write_int(required);\n    response->write_int(alive);\n    return response;\n}\n\nstd::unique_ptr<cql_server::response> cql_server::connection::make_read_timeout_error(int16_t stream, exceptions::exception_code err, sstring msg, db::consistency_level cl, int32_t received, int32_t blockfor, bool data_present, const tracing::trace_state_ptr& tr_state) const\n{\n    auto response = std::make_unique<cql_server::response>(stream, cql_binary_opcode::ERROR, tr_state);\n    response->write_int(static_cast<int32_t>(err));\n    response->write_string(msg);\n    response->write_consistency(cl);\n    response->write_int(received);\n    response->write_int(blockfor);\n    response->write_byte(data_present);\n    return response;\n}\n\nstd::unique_ptr<cql_server::response> cql_server::connection::make_read_failure_error(int16_t stream, exceptions::exception_code err, sstring msg, db::consistency_level cl, int32_t received, int32_t numfailures, int32_t blockfor, bool data_present, const tracing::trace_state_ptr& tr_state) const\n{\n    if (_version < 4) {\n        return make_read_timeout_error(stream, exceptions::exception_code::READ_TIMEOUT, std::move(msg), cl, received, blockfor, data_present, tr_state);\n    }\n    auto response = std::make_unique<cql_server::response>(stream, cql_binary_opcode::ERROR, tr_state);\n    response->write_int(static_cast<int32_t>(err));\n    response->write_string(msg);\n    response->write_consistency(cl);\n    response->write_int(received);\n    response->write_int(blockfor);\n    response->write_int(numfailures);\n    response->write_byte(data_present);\n    return response;\n}\n\nstd::unique_ptr<cql_server::response> cql_server::connection::make_mutation_write_timeout_error(int16_t stream, exceptions::exception_code err, sstring msg, db::consistency_level cl, int32_t received, int32_t blockfor, db::write_type type, const tracing::trace_state_ptr& tr_state) const\n{\n    auto response = std::make_unique<cql_server::response>(stream, cql_binary_opcode::ERROR, tr_state);\n    response->write_int(static_cast<int32_t>(err));\n    response->write_string(msg);\n    response->write_consistency(cl);\n    response->write_int(received);\n    response->write_int(blockfor);\n    response->write_string(format(\"{}\", type));\n    return response;\n}\n\nstd::unique_ptr<cql_server::response> cql_server::connection::make_mutation_write_failure_error(int16_t stream, exceptions::exception_code err, sstring msg, db::consistency_level cl, int32_t received, int32_t numfailures, int32_t blockfor, db::write_type type, const tracing::trace_state_ptr& tr_state) const\n{\n    if (_version < 4) {\n        return make_mutation_write_timeout_error(stream, exceptions::exception_code::WRITE_TIMEOUT, std::move(msg), cl, received, blockfor, type, tr_state);\n    }\n    auto response = std::make_unique<cql_server::response>(stream, cql_binary_opcode::ERROR, tr_state);\n    response->write_int(static_cast<int32_t>(err));\n    response->write_string(msg);\n    response->write_consistency(cl);\n    response->write_int(received);\n    response->write_int(blockfor);\n    response->write_int(numfailures);\n    response->write_string(format(\"{}\", type));\n    return response;\n}\n\nstd::unique_ptr<cql_server::response> cql_server::connection::make_already_exists_error(int16_t stream, exceptions::exception_code err, sstring msg, sstring ks_name, sstring cf_name, const tracing::trace_state_ptr& tr_state) const\n{\n    auto response = std::make_unique<cql_server::response>(stream, cql_binary_opcode::ERROR, tr_state);\n    response->write_int(static_cast<int32_t>(err));\n    response->write_string(msg);\n    response->write_string(ks_name);\n    response->write_string(cf_name);\n    return response;\n}\n\nstd::unique_ptr<cql_server::response> cql_server::connection::make_unprepared_error(int16_t stream, exceptions::exception_code err, sstring msg, bytes id, const tracing::trace_state_ptr& tr_state) const\n{\n    auto response = std::make_unique<cql_server::response>(stream, cql_binary_opcode::ERROR, tr_state);\n    response->write_int(static_cast<int32_t>(err));\n    response->write_string(msg);\n    response->write_short_bytes(id);\n    return response;\n}\n\nstd::unique_ptr<cql_server::response> cql_server::connection::make_function_failure_error(int16_t stream, exceptions::exception_code err, sstring msg, sstring ks_name, sstring func_name, std::vector<sstring> args, const tracing::trace_state_ptr& tr_state) const\n{\n    auto response = std::make_unique<cql_server::response>(stream, cql_binary_opcode::ERROR, tr_state);\n    response->write_int(static_cast<int32_t>(err));\n    response->write_string(msg);\n    response->write_string(ks_name);\n    response->write_string(func_name);\n    response->write_string_list(args);\n    return response;\n}\n\nstd::unique_ptr<cql_server::response> cql_server::connection::make_rate_limit_error(int16_t stream, exceptions::exception_code err, sstring msg, db::operation_type op_type, bool rejected_by_coordinator, const tracing::trace_state_ptr& tr_state, const service::client_state& client_state) const\n{\n    if (!client_state.is_protocol_extension_set(cql_protocol_extension::RATE_LIMIT_ERROR)) {\n        return make_error(stream, exceptions::exception_code::CONFIG_ERROR, std::move(msg), tr_state);\n    }\n\n    auto response = std::make_unique<cql_server::response>(stream, cql_binary_opcode::ERROR, tr_state);\n    response->write_int(static_cast<int32_t>(err));\n    response->write_string(msg);\n    response->write_byte(static_cast<uint8_t>(op_type));\n    response->write_byte(static_cast<uint8_t>(rejected_by_coordinator));\n    return response;\n}\n\nstd::unique_ptr<cql_server::response> cql_server::connection::make_error(int16_t stream, exceptions::exception_code err, sstring msg, const tracing::trace_state_ptr& tr_state) const\n{\n    auto response = std::make_unique<cql_server::response>(stream, cql_binary_opcode::ERROR, tr_state);\n    response->write_int(static_cast<int32_t>(err));\n    response->write_string(msg);\n    return response;\n}\n\nstd::unique_ptr<cql_server::response> cql_server::connection::make_ready(int16_t stream, const tracing::trace_state_ptr& tr_state) const\n{\n    return std::make_unique<cql_server::response>(stream, cql_binary_opcode::READY, tr_state);\n}\n\nstd::unique_ptr<cql_server::response> cql_server::connection::make_autheticate(int16_t stream, std::string_view clz, const tracing::trace_state_ptr& tr_state) const\n{\n    auto response = std::make_unique<cql_server::response>(stream, cql_binary_opcode::AUTHENTICATE, tr_state);\n    response->write_string(clz);\n    return response;\n}\n\nstd::unique_ptr<cql_server::response> cql_server::connection::make_auth_success(int16_t stream, bytes b, const tracing::trace_state_ptr& tr_state) const {\n    auto response = std::make_unique<cql_server::response>(stream, cql_binary_opcode::AUTH_SUCCESS, tr_state);\n    response->write_bytes(std::move(b));\n    return response;\n}\n\nstd::unique_ptr<cql_server::response> cql_server::connection::make_auth_challenge(int16_t stream, bytes b, const tracing::trace_state_ptr& tr_state) const {\n    auto response = std::make_unique<cql_server::response>(stream, cql_binary_opcode::AUTH_CHALLENGE, tr_state);\n    response->write_bytes(std::move(b));\n    return response;\n}\n\nstd::unique_ptr<cql_server::response> cql_server::connection::make_supported(int16_t stream, const tracing::trace_state_ptr& tr_state) const\n{\n    std::multimap<sstring, sstring> opts;\n    opts.insert({\"CQL_VERSION\", cql3::query_processor::CQL_VERSION});\n    opts.insert({\"COMPRESSION\", \"lz4\"});\n    opts.insert({\"COMPRESSION\", \"snappy\"});\n    if (_server._config.allow_shard_aware_drivers) {\n        opts.insert({\"SCYLLA_SHARD\", format(\"{:d}\", this_shard_id())});\n        opts.insert({\"SCYLLA_NR_SHARDS\", format(\"{:d}\", smp::count)});\n        opts.insert({\"SCYLLA_SHARDING_ALGORITHM\", dht::cpu_sharding_algorithm_name()});\n        if (_server._config.shard_aware_transport_port) {\n            opts.insert({\"SCYLLA_SHARD_AWARE_PORT\", format(\"{:d}\", *_server._config.shard_aware_transport_port)});\n        }\n        if (_server._config.shard_aware_transport_port_ssl) {\n            opts.insert({\"SCYLLA_SHARD_AWARE_PORT_SSL\", format(\"{:d}\", *_server._config.shard_aware_transport_port_ssl)});\n        }\n        opts.insert({\"SCYLLA_SHARDING_IGNORE_MSB\", format(\"{:d}\", _server._config.sharding_ignore_msb)});\n        opts.insert({\"SCYLLA_PARTITIONER\", _server._config.partitioner_name});\n    }\n    for (cql_protocol_extension ext : supported_cql_protocol_extensions()) {\n        const sstring ext_key_name = protocol_extension_name(ext);\n        std::vector<sstring> params = additional_options_for_proto_ext(ext);\n        if (params.empty()) {\n            opts.emplace(ext_key_name, \"\");\n        } else {\n            for (sstring val : params) {\n                opts.emplace(ext_key_name, std::move(val));\n            }\n        }\n    }\n    auto response = std::make_unique<cql_server::response>(stream, cql_binary_opcode::SUPPORTED, tr_state);\n    response->write_string_multimap(std::move(opts));\n    return response;\n}\n\nclass cql_server::fmt_visitor : public messages::result_message::visitor_base {\nprivate:\n    uint8_t _version;\n    cql_server::response& _response;\n    bool _skip_metadata;\npublic:\n    fmt_visitor(uint8_t version, cql_server::response& response, bool skip_metadata)\n        : _version{version}\n        , _response{response}\n        , _skip_metadata{skip_metadata}\n    { }\n\n    virtual void visit(const messages::result_message::void_message&) override {\n        _response.write_int(0x0001);\n    }\n\n    virtual void visit(const messages::result_message::set_keyspace& m) override {\n        _response.write_int(0x0003);\n        _response.write_string(m.get_keyspace());\n    }\n\n    virtual void visit(const messages::result_message::prepared::cql& m) override {\n        _response.write_int(0x0004);\n        _response.write_short_bytes(m.get_id());\n        _response.write(m.metadata(), _version);\n        if (_version > 1) {\n            _response.write(*m.result_metadata());\n        }\n    }\n\n    virtual void visit(const messages::result_message::schema_change& m) override {\n        auto change = m.get_change();\n        switch (change->type) {\n        case event::event_type::SCHEMA_CHANGE: {\n            auto sc = static_pointer_cast<event::schema_change>(change);\n            _response.write_int(0x0005);\n            _response.serialize(*sc, _version);\n            break;\n        }\n        default:\n            assert(0);\n        }\n    }\n\n    virtual void visit(const messages::result_message::rows& m) override {\n        _response.write_int(0x0002);\n        auto& rs = m.rs();\n        _response.write(rs.get_metadata(), _skip_metadata);\n        auto row_count_plhldr = _response.write_int_placeholder();\n\n        class visitor {\n            cql_server::response& _response;\n            int64_t _row_count = 0;\n        public:\n            visitor(cql_server::response& r) : _response(r) { }\n\n            void start_row() {\n                _row_count++;\n            }\n            void accept_value(std::optional<query::result_bytes_view> cell) {\n                _response.write_value(cell);\n            }\n            void end_row() { }\n\n            int64_t row_count() const { return _row_count; }\n        };\n\n        auto v = visitor(_response);\n        rs.visit(v);\n        row_count_plhldr.write(v.row_count()); // even though the placeholder is for int32_t we won't overflow because of memory limits\n    }\n};\n\nstd::unique_ptr<cql_server::response>\nmake_result(int16_t stream, messages::result_message& msg, const tracing::trace_state_ptr& tr_state,\n        cql_protocol_version_type version, bool skip_metadata) {\n    auto response = std::make_unique<cql_server::response>(stream, cql_binary_opcode::RESULT, tr_state);\n    if (__builtin_expect(!msg.warnings().empty() && version > 3, false)) {\n        response->set_frame_flag(cql_frame_flags::warning);\n        response->write_string_list(msg.warnings());\n    }\n    cql_server::fmt_visitor fmt{version, *response, skip_metadata};\n    msg.accept(fmt);\n    return response;\n}\n\nstd::unique_ptr<cql_server::response>\ncql_server::connection::make_topology_change_event(const event::topology_change& event) const\n{\n    auto response = std::make_unique<cql_server::response>(-1, cql_binary_opcode::EVENT, tracing::trace_state_ptr());\n    response->write_string(\"TOPOLOGY_CHANGE\");\n    response->write_string(to_string(event.change));\n    response->write_inet(event.node);\n    return response;\n}\n\nstd::unique_ptr<cql_server::response>\ncql_server::connection::make_status_change_event(const event::status_change& event) const\n{\n    auto response = std::make_unique<cql_server::response>(-1, cql_binary_opcode::EVENT, tracing::trace_state_ptr());\n    response->write_string(\"STATUS_CHANGE\");\n    response->write_string(to_string(event.status));\n    response->write_inet(event.node);\n    return response;\n}\n\nstd::unique_ptr<cql_server::response>\ncql_server::connection::make_schema_change_event(const event::schema_change& event) const\n{\n    auto response = std::make_unique<cql_server::response>(-1, cql_binary_opcode::EVENT, tracing::trace_state_ptr());\n    response->write_string(\"SCHEMA_CHANGE\");\n    response->serialize(event, _version);\n    return response;\n}\n\nvoid cql_server::connection::write_response(foreign_ptr<std::unique_ptr<cql_server::response>>&& response, service_permit permit, cql_compression compression)\n{\n    _ready_to_respond = _ready_to_respond.then([this, compression, response = std::move(response), permit = std::move(permit)] () mutable {\n        auto message = response->make_message(_version, compression);\n        message.on_delete([response = std::move(response)] { });\n        return _write_buf.write(std::move(message)).then([this] {\n            return _write_buf.flush();\n        });\n    });\n}\n\nscattered_message<char> cql_server::response::make_message(uint8_t version, cql_compression compression) {\n    if (compression != cql_compression::none) {\n        compress(compression);\n    }\n    scattered_message<char> msg;\n    auto frame = make_frame(version, _body.size());\n    msg.append(std::move(frame));\n    for (auto&& fragment : _body.fragments()) {\n        msg.append_static(reinterpret_cast<const char*>(fragment.data()), fragment.size());\n    }\n    return msg;\n}\n\nvoid cql_server::response::compress(cql_compression compression)\n{\n    switch (compression) {\n    case cql_compression::lz4:\n        compress_lz4();\n        break;\n    case cql_compression::snappy:\n        compress_snappy();\n        break;\n    default:\n        throw std::invalid_argument(\"Invalid CQL compression algorithm\");\n    }\n    set_frame_flag(cql_frame_flags::compression);\n}\n\nvoid cql_server::response::compress_lz4()\n{\n    using namespace compression_buffers;\n    auto view = input_buffer.get_linearized_view(_body);\n    const char* input = reinterpret_cast<const char*>(view.data());\n    size_t input_len = view.size();\n\n    size_t output_len = LZ4_COMPRESSBOUND(input_len) + 4;\n    _body = output_buffer.make_buffer(output_len, [&] (bytes_mutable_view output_view) {\n        char* output = reinterpret_cast<char*>(output_view.data());\n        output[0] = (input_len >> 24) & 0xFF;\n        output[1] = (input_len >> 16) & 0xFF;\n        output[2] = (input_len >> 8) & 0xFF;\n        output[3] = input_len & 0xFF;\n#ifdef HAVE_LZ4_COMPRESS_DEFAULT\n        auto ret = LZ4_compress_default(input, output + 4, input_len, LZ4_compressBound(input_len));\n#else\n        auto ret = LZ4_compress(input, output + 4, input_len);\n#endif\n        if (ret == 0) {\n            throw std::runtime_error(\"CQL frame LZ4 compression failure\");\n        }\n        return ret + 4;\n    });\n    on_compression_buffer_use();\n}\n\nvoid cql_server::response::compress_snappy()\n{\n    using namespace compression_buffers;\n    auto view = input_buffer.get_linearized_view(_body);\n    const char* input = reinterpret_cast<const char*>(view.data());\n    size_t input_len = view.size();\n\n    size_t output_len = snappy_max_compressed_length(input_len);\n    _body = output_buffer.make_buffer(output_len, [&] (bytes_mutable_view output_view) {\n        char* output = reinterpret_cast<char*>(output_view.data());\n        if (snappy_compress(input, input_len, output, &output_len) != SNAPPY_OK) {\n            throw std::runtime_error(\"CQL frame Snappy compression failure\");\n        }\n        return output_len;\n    });\n    on_compression_buffer_use();\n}\n\nvoid cql_server::response::serialize(const event::schema_change& event, uint8_t version)\n{\n    if (version >= 3) {\n        write_string(to_string(event.change));\n        write_string(to_string(event.target));\n        write_string(event.keyspace);\n        switch (event.target) {\n        case event::schema_change::target_type::KEYSPACE:\n            break;\n        case event::schema_change::target_type::TYPE:\n        case event::schema_change::target_type::TABLE:\n            write_string(event.arguments[0]);\n            break;\n        case event::schema_change::target_type::FUNCTION:\n        case event::schema_change::target_type::AGGREGATE:\n            write_string(event.arguments[0]);\n            write_string_list(std::vector<sstring>(event.arguments.begin() + 1, event.arguments.end()));\n            break;\n        }\n    } else {\n        switch (event.target) {\n        // FIXME: Should we handle FUNCTION and AGGREGATE the same way as type?\n        // FIXME: How do we get here? Can a client using v2 know about UDF?\n        case event::schema_change::target_type::TYPE:\n        case event::schema_change::target_type::FUNCTION:\n        case event::schema_change::target_type::AGGREGATE:\n            // The v1/v2 protocol is unable to represent these changes. Tell the\n            // client that the keyspace was updated instead.\n            write_string(to_string(event::schema_change::change_type::UPDATED));\n            write_string(event.keyspace);\n            write_string(\"\");\n            break;\n        case event::schema_change::target_type::TABLE:\n        case event::schema_change::target_type::KEYSPACE:\n            write_string(to_string(event.change));\n            write_string(event.keyspace);\n            if (event.target == event::schema_change::target_type::TABLE) {\n                write_string(event.arguments[0]);\n            } else {\n                write_string(\"\");\n            }\n        }\n    }\n}\n\nvoid cql_server::response::write_byte(uint8_t b)\n{\n    auto s = reinterpret_cast<const int8_t*>(&b);\n    _body.write(bytes_view(s, sizeof(b)));\n}\n\nvoid cql_server::response::write_int(int32_t n)\n{\n    auto u = htonl(n);\n    auto *s = reinterpret_cast<const int8_t*>(&u);\n    _body.write(bytes_view(s, sizeof(u)));\n}\n\ncql_server::response::placeholder<int32_t> cql_server::response::write_int_placeholder() {\n    return placeholder<int32_t>(_body.write_place_holder(sizeof(int32_t)));\n}\n\nvoid cql_server::response::write_long(int64_t n)\n{\n    auto u = htonq(n);\n    auto *s = reinterpret_cast<const int8_t*>(&u);\n    _body.write(bytes_view(s, sizeof(u)));\n}\n\nvoid cql_server::response::write_short(uint16_t n)\n{\n    auto u = htons(n);\n    auto *s = reinterpret_cast<const int8_t*>(&u);\n    _body.write(bytes_view(s, sizeof(u)));\n}\n\ntemplate<typename T>\ninline\nT cast_if_fits(size_t v) {\n    size_t max = std::numeric_limits<T>::max();\n    if (v > max) {\n        throw std::runtime_error(format(\"Value too large, {:d} > {:d}\", v, max));\n    }\n    return static_cast<T>(v);\n}\n\nvoid cql_server::response::write_string(std::string_view s)\n{\n    write_short(cast_if_fits<uint16_t>(s.size()));\n    _body.write(bytes_view(reinterpret_cast<const int8_t*>(s.data()), s.size()));\n}\n\nvoid cql_server::response::write_bytes_as_string(bytes_view s)\n{\n    write_short(cast_if_fits<uint16_t>(s.size()));\n    _body.write(s);\n}\n\nvoid cql_server::response::write_long_string(const sstring& s)\n{\n    write_int(cast_if_fits<int32_t>(s.size()));\n    _body.write(bytes_view(reinterpret_cast<const int8_t*>(s.data()), s.size()));\n}\n\nvoid cql_server::response::write_string_list(std::vector<sstring> string_list)\n{\n    write_short(cast_if_fits<uint16_t>(string_list.size()));\n    for (auto&& s : string_list) {\n        write_string(s);\n    }\n}\n\nvoid cql_server::response::write_bytes(bytes b)\n{\n    write_int(cast_if_fits<int32_t>(b.size()));\n    _body.write(b);\n}\n\nvoid cql_server::response::write_short_bytes(bytes b)\n{\n    write_short(cast_if_fits<uint16_t>(b.size()));\n    _body.write(b);\n}\n\nvoid cql_server::response::write_inet(socket_address inet)\n{\n    auto addr = inet.addr();\n    write_byte(uint8_t(addr.size()));\n    auto * p = static_cast<const int8_t*>(addr.data());\n    _body.write(bytes_view(p, addr.size()));\n    write_int(inet.port());\n}\n\nvoid cql_server::response::write_consistency(db::consistency_level c)\n{\n    write_short(consistency_to_wire(c));\n}\n\nvoid cql_server::response::write_string_map(std::map<sstring, sstring> string_map)\n{\n    write_short(cast_if_fits<uint16_t>(string_map.size()));\n    for (auto&& s : string_map) {\n        write_string(s.first);\n        write_string(s.second);\n    }\n}\n\nvoid cql_server::response::write_string_multimap(std::multimap<sstring, sstring> string_map)\n{\n    std::vector<sstring> keys;\n    for (auto it = string_map.begin(), end = string_map.end(); it != end; it = string_map.upper_bound(it->first)) {\n        keys.push_back(it->first);\n    }\n    write_short(cast_if_fits<uint16_t>(keys.size()));\n    for (auto&& key : keys) {\n        std::vector<sstring> values;\n        auto range = string_map.equal_range(key);\n        for (auto it = range.first; it != range.second; ++it) {\n            values.push_back(it->second);\n        }\n        write_string(key);\n        write_string_list(values);\n    }\n}\n\nvoid cql_server::response::write_value(bytes_opt value)\n{\n    if (!value) {\n        write_int(-1);\n        return;\n    }\n\n    write_int(value->size());\n    _body.write(*value);\n}\n\nvoid cql_server::response::write_value(std::optional<query::result_bytes_view> value)\n{\n    if (!value) {\n        write_int(-1);\n        return;\n    }\n\n    write_int(value->size_bytes());\n    using boost::range::for_each;\n    for_each(*value, [&] (bytes_view fragment) {\n        _body.write(fragment);\n    });\n}\n\nclass type_codec {\nprivate:\n    enum class type_id : int16_t {\n        CUSTOM    = 0x0000,\n        ASCII     = 0x0001,\n        BIGINT    = 0x0002,\n        BLOB      = 0x0003,\n        BOOLEAN   = 0x0004,\n        COUNTER   = 0x0005,\n        DECIMAL   = 0x0006,\n        DOUBLE    = 0x0007,\n        FLOAT     = 0x0008,\n        INT       = 0x0009,\n        TIMESTAMP = 0x000B,\n        UUID      = 0x000C,\n        VARCHAR   = 0x000D,\n        VARINT    = 0x000E,\n        TIMEUUID  = 0x000F,\n        INET      = 0x0010,\n        DATE      = 0x0011,\n        TIME      = 0x0012,\n        SMALLINT  = 0x0013,\n        TINYINT   = 0x0014,\n        DURATION  = 0x0015,\n        LIST      = 0x0020,\n        MAP       = 0x0021,\n        SET       = 0x0022,\n        UDT       = 0x0030,\n        TUPLE     = 0x0031,\n    };\n\n    using type_id_to_type_type = std::unordered_map<data_type, type_id>;\n\n    static thread_local const type_id_to_type_type type_id_to_type;\npublic:\n    static void encode(cql_server::response& r, data_type type) {\n        type = type->underlying_type();\n\n        // For compatibility sake, we still return DateType as the timestamp type in resultSet metadata (#5723)\n        if (type == date_type) {\n            type = timestamp_type;\n        }\n\n        auto i = type_id_to_type.find(type);\n        if (i != type_id_to_type.end()) {\n            r.write_short(static_cast<std::underlying_type<type_id>::type>(i->second));\n            return;\n        }\n\n        if (type->is_reversed()) {\n            fail(unimplemented::cause::REVERSED);\n        }\n        if (type->is_user_type()) {\n            r.write_short(uint16_t(type_id::UDT));\n            auto udt = static_pointer_cast<const user_type_impl>(type);\n            r.write_string(udt->_keyspace);\n            r.write_bytes_as_string(udt->_name);\n            r.write_short(udt->size());\n            for (auto&& i : boost::irange<size_t>(0, udt->size())) {\n                r.write_bytes_as_string(udt->field_name(i));\n                encode(r, udt->field_type(i));\n            }\n            return;\n        }\n        if (type->is_tuple()) {\n            r.write_short(uint16_t(type_id::TUPLE));\n            auto ttype = static_pointer_cast<const tuple_type_impl>(type);\n            r.write_short(ttype->size());\n            for (auto&& t : ttype->all_types()) {\n                encode(r, t);\n            }\n            return;\n        }\n        if (type->is_collection()) {\n            auto&& ctype = static_cast<const collection_type_impl*>(type.get());\n            if (ctype->get_kind() == abstract_type::kind::map) {\n                r.write_short(uint16_t(type_id::MAP));\n                auto&& mtype = static_cast<const map_type_impl*>(ctype);\n                encode(r, mtype->get_keys_type());\n                encode(r, mtype->get_values_type());\n            } else if (ctype->get_kind() == abstract_type::kind::set) {\n                r.write_short(uint16_t(type_id::SET));\n                auto&& stype = static_cast<const set_type_impl*>(ctype);\n                encode(r, stype->get_elements_type());\n            } else if (ctype->get_kind() == abstract_type::kind::list) {\n                r.write_short(uint16_t(type_id::LIST));\n                auto&& ltype = static_cast<const list_type_impl*>(ctype);\n                encode(r, ltype->get_elements_type());\n            } else {\n                abort();\n            }\n            return;\n        }\n        abort();\n    }\n};\n\nthread_local const type_codec::type_id_to_type_type type_codec::type_id_to_type {\n    { ascii_type, type_id::ASCII },\n    { long_type, type_id::BIGINT },\n    { bytes_type, type_id::BLOB },\n    { boolean_type, type_id::BOOLEAN },\n    { counter_type, type_id::COUNTER },\n    { decimal_type, type_id::DECIMAL },\n    { double_type, type_id::DOUBLE },\n    { float_type, type_id::FLOAT },\n    { int32_type, type_id::INT },\n    { byte_type, type_id::TINYINT },\n    { duration_type, type_id::DURATION },\n    { short_type, type_id::SMALLINT },\n    { timestamp_type, type_id::TIMESTAMP },\n    { uuid_type, type_id::UUID },\n    { utf8_type, type_id::VARCHAR },\n    { varint_type, type_id::VARINT },\n    { timeuuid_type, type_id::TIMEUUID },\n    { simple_date_type, type_id::DATE },\n    { time_type, type_id::TIME },\n    { inet_addr_type, type_id::INET },\n};\n\nvoid cql_server::response::write(const cql3::metadata& m, bool no_metadata) {\n    auto flags = m.flags();\n    bool global_tables_spec = m.flags().contains<cql3::metadata::flag::GLOBAL_TABLES_SPEC>();\n    bool has_more_pages = m.flags().contains<cql3::metadata::flag::HAS_MORE_PAGES>();\n\n    if (no_metadata) {\n        flags.set<cql3::metadata::flag::NO_METADATA>();\n    }\n\n    write_int(flags.mask());\n    write_int(m.column_count());\n\n    if (has_more_pages) {\n        write_value(m.paging_state()->serialize());\n    }\n\n    if (no_metadata) {\n        return;\n    }\n\n    auto names_i = m.get_names().begin();\n\n    if (global_tables_spec) {\n        auto first_spec = *names_i;\n        write_string(first_spec->ks_name);\n        write_string(first_spec->cf_name);\n    }\n\n    for (uint32_t i = 0; i < m.column_count(); ++i, ++names_i) {\n        lw_shared_ptr<cql3::column_specification> name = *names_i;\n        if (!global_tables_spec) {\n            write_string(name->ks_name);\n            write_string(name->cf_name);\n        }\n        write_string(name->name->text());\n        type_codec::encode(*this, name->type);\n    }\n}\n\nvoid cql_server::response::write(const cql3::prepared_metadata& m, uint8_t version)\n{\n    bool global_tables_spec = m.flags().contains<cql3::prepared_metadata::flag::GLOBAL_TABLES_SPEC>();\n\n    write_int(m.flags().mask());\n    write_int(m.names().size());\n\n    if (version >= 4) {\n        if (!global_tables_spec) {\n            write_int(0);\n        } else {\n            write_int(m.partition_key_bind_indices().size());\n            for (uint16_t bind_index : m.partition_key_bind_indices()) {\n                write_short(bind_index);\n            }\n        }\n    }\n\n    if (global_tables_spec) {\n        write_string(m.names()[0]->ks_name);\n        write_string(m.names()[0]->cf_name);\n    }\n\n    for (auto const& name : m.names()) {\n        if (!global_tables_spec) {\n            write_string(name->ks_name);\n            write_string(name->cf_name);\n        }\n        write_string(name->name->text());\n        type_codec::encode(*this, name->type);\n    }\n}\n\nfuture<utils::chunked_vector<client_data>> cql_server::get_client_data() {\n    utils::chunked_vector<client_data> ret;\n    co_await for_each_gently([&ret] (const generic_server::connection& c) {\n        const connection& conn = dynamic_cast<const connection&>(c);\n        ret.emplace_back(conn.make_client_data());\n    });\n    co_return ret;\n}\n\n}\n"], "fixing_code": ["/*\n * Copyright (C) 2015-present ScyllaDB\n */\n\n/*\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n\n#include \"server.hh\"\n\n#include <boost/bimap/unordered_set_of.hpp>\n#include <boost/range/irange.hpp>\n#include <boost/bimap.hpp>\n#include <boost/assign.hpp>\n#include <boost/range/adaptor/sliced.hpp>\n\n#include \"cql3/statements/batch_statement.hh\"\n#include \"cql3/statements/modification_statement.hh\"\n#include \"types/collection.hh\"\n#include \"types/list.hh\"\n#include \"types/set.hh\"\n#include \"types/map.hh\"\n#include \"dht/token-sharding.hh\"\n#include \"service/migration_manager.hh\"\n#include \"service/memory_limiter.hh\"\n#include \"service/storage_proxy.hh\"\n#include \"db/consistency_level_type.hh\"\n#include \"db/write_type.hh\"\n#include <seastar/core/coroutine.hh>\n#include <seastar/core/future-util.hh>\n#include <seastar/core/seastar.hh>\n#include \"utils/UUID.hh\"\n#include <seastar/net/byteorder.hh>\n#include <seastar/core/metrics.hh>\n#include <seastar/net/byteorder.hh>\n#include <seastar/util/lazy.hh>\n#include <seastar/core/execution_stage.hh>\n#include \"utils/result_try.hh\"\n#include \"utils/result_combinators.hh\"\n#include \"db/operation_type.hh\"\n\n#include \"enum_set.hh\"\n#include \"service/query_state.hh\"\n#include \"service/client_state.hh\"\n#include \"exceptions/exceptions.hh\"\n#include \"client_data.hh\"\n#include \"cql3/query_processor.hh\"\n#include \"auth/authenticator.hh\"\n\n#include <cassert>\n#include <string>\n\n#include <snappy-c.h>\n#include <lz4.h>\n\n#include \"response.hh\"\n#include \"request.hh\"\n\n#include \"types/user.hh\"\n\n#include \"transport/cql_protocol_extension.hh\"\n#include \"utils/bit_cast.hh\"\n#include \"db/config.hh\"\n\ntemplate<typename T = void>\nusing coordinator_result = exceptions::coordinator_result<T>;\n\nnamespace cql_transport {\n\nstatic logging::logger clogger(\"cql_server\");\n\nstruct cql_frame_error : std::exception {\n    const char* what() const throw () override {\n        return \"bad cql binary frame\";\n    }\n};\n\ninline int16_t consistency_to_wire(db::consistency_level c)\n{\n    switch (c) {\n    case db::consistency_level::ANY:          return 0x0000;\n    case db::consistency_level::ONE:          return 0x0001;\n    case db::consistency_level::TWO:          return 0x0002;\n    case db::consistency_level::THREE:        return 0x0003;\n    case db::consistency_level::QUORUM:       return 0x0004;\n    case db::consistency_level::ALL:          return 0x0005;\n    case db::consistency_level::LOCAL_QUORUM: return 0x0006;\n    case db::consistency_level::EACH_QUORUM:  return 0x0007;\n    case db::consistency_level::SERIAL:       return 0x0008;\n    case db::consistency_level::LOCAL_SERIAL: return 0x0009;\n    case db::consistency_level::LOCAL_ONE:    return 0x000A;\n    default:                                  throw std::runtime_error(\"Invalid consistency level\");\n    }\n}\n\nsstring to_string(const event::topology_change::change_type t) {\n    using type = event::topology_change::change_type;\n    switch (t) {\n    case type::NEW_NODE:     return \"NEW_NODE\";\n    case type::REMOVED_NODE: return \"REMOVED_NODE\";\n    case type::MOVED_NODE:   return \"MOVED_NODE\";\n    }\n    throw std::invalid_argument(\"unknown change type\");\n}\n\nsstring to_string(const event::status_change::status_type t) {\n    using type = event::status_change::status_type;\n    switch (t) {\n    case type::UP:   return \"UP\";\n    case type::DOWN: return \"DOWN\";\n    }\n    throw std::invalid_argument(\"unknown change type\");\n}\n\nsstring to_string(const event::schema_change::change_type t) {\n    switch (t) {\n    case event::schema_change::change_type::CREATED: return \"CREATED\";\n    case event::schema_change::change_type::UPDATED: return \"UPDATED\";\n    case event::schema_change::change_type::DROPPED: return \"DROPPED\";\n    }\n    assert(false && \"unreachable\");\n}\n\nsstring to_string(const event::schema_change::target_type t) {\n    switch (t) {\n    case event::schema_change::target_type::KEYSPACE: return \"KEYSPACE\";\n    case event::schema_change::target_type::TABLE:    return \"TABLE\";\n    case event::schema_change::target_type::TYPE:     return \"TYPE\";\n    case event::schema_change::target_type::FUNCTION: return \"FUNCTION\";\n    case event::schema_change::target_type::AGGREGATE:return \"AGGREGATE\";\n    }\n    assert(false && \"unreachable\");\n}\n\nevent::event_type parse_event_type(const sstring& value)\n{\n    if (value == \"TOPOLOGY_CHANGE\") {\n        return event::event_type::TOPOLOGY_CHANGE;\n    } else if (value == \"STATUS_CHANGE\") {\n        return event::event_type::STATUS_CHANGE;\n    } else if (value == \"SCHEMA_CHANGE\") {\n        return event::event_type::SCHEMA_CHANGE;\n    } else {\n        throw exceptions::protocol_exception(format(\"Invalid value '{}' for Event.Type\", value));\n    }\n}\n\ncql_server::cql_server(distributed<cql3::query_processor>& qp, auth::service& auth_service,\n        service::memory_limiter& ml, cql_server_config config, const db::config& db_cfg,\n        qos::service_level_controller& sl_controller, gms::gossiper& g)\n    : server(\"CQLServer\", clogger)\n    , _query_processor(qp)\n    , _config(config)\n    , _max_request_size(config.max_request_size)\n    , _max_concurrent_requests(db_cfg.max_concurrent_requests_per_shard)\n    , _memory_available(ml.get_semaphore())\n    , _notifier(std::make_unique<event_notifier>(*this))\n    , _auth_service(auth_service)\n    , _sl_controller(sl_controller)\n    , _gossiper(g)\n{\n    namespace sm = seastar::metrics;\n\n    auto ls = {\n        sm::make_counter(\"startups\", _stats.startups,\n                        sm::description(\"Counts the total number of received CQL STARTUP messages.\")),\n\n        sm::make_counter(\"auth_responses\", _stats.auth_responses,\n                        sm::description(\"Counts the total number of received CQL AUTH messages.\")),\n        \n        sm::make_counter(\"options_requests\", _stats.options_requests,\n                        sm::description(\"Counts the total number of received CQL OPTIONS messages.\")),\n\n        sm::make_counter(\"query_requests\", _stats.query_requests,\n                        sm::description(\"Counts the total number of received CQL QUERY messages.\")),\n\n        sm::make_counter(\"prepare_requests\", _stats.prepare_requests,\n                        sm::description(\"Counts the total number of received CQL PREPARE messages.\")),\n\n        sm::make_counter(\"execute_requests\", _stats.execute_requests,\n                        sm::description(\"Counts the total number of received CQL EXECUTE messages.\")),\n\n        sm::make_counter(\"batch_requests\", _stats.batch_requests,\n                        sm::description(\"Counts the total number of received CQL BATCH messages.\")),\n\n        sm::make_counter(\"register_requests\", _stats.register_requests,\n                        sm::description(\"Counts the total number of received CQL REGISTER messages.\")),\n\n        sm::make_counter(\"cql-connections\", _stats.connects,\n                        sm::description(\"Counts a number of client connections.\")),\n\n        sm::make_gauge(\"current_connections\", _stats.connections,\n                        sm::description(\"Holds a current number of client connections.\")),\n\n        sm::make_counter(\"requests_served\", _stats.requests_served,\n                        sm::description(\"Counts a number of served requests.\")),\n\n        sm::make_gauge(\"requests_serving\", _stats.requests_serving,\n                        sm::description(\"Holds a number of requests that are being processed right now.\")),\n\n        sm::make_gauge(\"requests_blocked_memory_current\", [this] { return _memory_available.waiters(); },\n                        sm::description(\n                            seastar::format(\"Holds the number of requests that are currently blocked due to reaching the memory quota limit ({}B). \"\n                                            \"Non-zero value indicates that our bottleneck is memory and more specifically - the memory quota allocated for the \\\"CQL transport\\\" component.\", _max_request_size))),\n        sm::make_counter(\"requests_blocked_memory\", _stats.requests_blocked_memory,\n                        sm::description(\n                            seastar::format(\"Holds an incrementing counter with the requests that ever blocked due to reaching the memory quota limit ({}B). \"\n                                            \"The first derivative of this value shows how often we block due to memory exhaustion in the \\\"CQL transport\\\" component.\", _max_request_size))),\n        sm::make_counter(\"requests_shed\", _stats.requests_shed,\n                        sm::description(\"Holds an incrementing counter with the requests that were shed due to overload (threshold configured via max_concurrent_requests_per_shard). \"\n                                            \"The first derivative of this value shows how often we shed requests due to overload in the \\\"CQL transport\\\" component.\")),\n        sm::make_gauge(\"requests_memory_available\", [this] { return _memory_available.current(); },\n                        sm::description(\n                            seastar::format(\"Holds the amount of available memory for admitting new requests (max is {}B).\"\n                                            \"Zero value indicates that our bottleneck is memory and more specifically - the memory quota allocated for the \\\"CQL transport\\\" component.\", _max_request_size)))\n    };\n\n    std::vector<sm::metric_definition> transport_metrics;\n    for (auto& m : ls) {\n        transport_metrics.emplace_back(std::move(m));\n    }\n\n    sm::label cql_error_label(\"type\");\n    for (const auto& e : exceptions::exception_map()) {\n        _stats.errors.insert({e.first, 0});\n        auto label_instance = cql_error_label(e.second);\n\n        transport_metrics.emplace_back(\n            sm::make_counter(\"cql_errors_total\", sm::description(\"Counts the total number of returned CQL errors.\"),\n                        {label_instance},\n                        [this, code = e.first] { auto it = _stats.errors.find(code); return it != _stats.errors.end() ? it->second : 0; })\n        );\n    }\n\n    _metrics.add_group(\"transport\", std::move(transport_metrics));\n}\n\nshared_ptr<generic_server::connection>\ncql_server::make_connection(socket_address server_addr, connected_socket&& fd, socket_address addr) {\n    auto conn = make_shared<connection>(*this, server_addr, std::move(fd), std::move(addr));\n    ++_stats.connects;\n    ++_stats.connections;\n    return conn;\n}\n\nfuture<>\ncql_server::advertise_new_connection(shared_ptr<generic_server::connection> raw_conn) {\n    if (auto conn = dynamic_pointer_cast<connection>(raw_conn)) {\n        const auto ip = conn->get_client_state().get_client_address().addr();\n        const auto port = conn->get_client_state().get_client_port();\n        clogger.trace(\"Advertising new connection from CQL client {}:{}\", ip, port);\n    }\n    return make_ready_future<>();\n}\n\nfuture<>\ncql_server::unadvertise_connection(shared_ptr<generic_server::connection> raw_conn) {\n    --_stats.connections;\n    if (auto conn = dynamic_pointer_cast<connection>(raw_conn)) {\n        const auto ip = conn->get_client_state().get_client_address().addr();\n        const auto port = conn->get_client_state().get_client_port();\n        clogger.trace(\"Advertising disconnection of CQL client {}:{}\", ip, port);\n    }\n    return make_ready_future<>();\n}\n\nunsigned\ncql_server::connection::frame_size() const {\n    if (_version < 3) {\n        return 8;\n    } else {\n        return 9;\n    }\n}\n\ncql_binary_frame_v3\ncql_server::connection::parse_frame(temporary_buffer<char> buf) const {\n    if (buf.size() != frame_size()) {\n        throw cql_frame_error();\n    }\n    cql_binary_frame_v3 v3;\n    switch (_version) {\n    case 1:\n    case 2: {\n        cql_binary_frame_v1 raw = read_unaligned<cql_binary_frame_v1>(buf.get());\n        auto cooked = net::ntoh(raw);\n        v3.version = cooked.version;\n        v3.flags = cooked.flags;\n        v3.opcode = cooked.opcode;\n        v3.stream = cooked.stream;\n        v3.length = cooked.length;\n        break;\n    }\n    case 3:\n    case 4: {\n        cql_binary_frame_v3 raw = read_unaligned<cql_binary_frame_v3>(buf.get());\n        v3 = net::ntoh(raw);\n        break;\n    }\n    default:\n        throw exceptions::protocol_exception(format(\"Invalid or unsupported protocol version: {:d}\", _version));\n    }\n    if (v3.version != _version) {\n        throw exceptions::protocol_exception(format(\"Invalid message version. Got {:d} but previous messages on this connection had version {:d}\", v3.version, _version));\n\n    }\n    return v3;\n}\n\nfuture<std::optional<cql_binary_frame_v3>>\ncql_server::connection::read_frame() {\n    using ret_type = std::optional<cql_binary_frame_v3>;\n    if (!_version) {\n        // We don't know the frame size before reading the first frame,\n        // so read just one byte, and then read the rest of the frame.\n        return _read_buf.read_exactly(1).then([this] (temporary_buffer<char> buf) {\n            if (buf.empty()) {\n                return make_ready_future<ret_type>();\n            }\n            _version = buf[0];\n            init_cql_serialization_format();\n            if (_version < 1 || _version > current_version) {\n                auto client_version = _version;\n                _version = current_version;\n                throw exceptions::protocol_exception(format(\"Invalid or unsupported protocol version: {:d}\", client_version));\n            }\n\n\n            return _read_buf.read_exactly(frame_size() - 1).then([this] (temporary_buffer<char> tail) {\n                temporary_buffer<char> full(frame_size());\n                full.get_write()[0] = _version;\n                std::copy(tail.get(), tail.get() + tail.size(), full.get_write() + 1);\n                auto frame = parse_frame(std::move(full));\n                // This is the very first frame, so reject obviously incorrect frames, to\n                // avoid allocating large amounts of memory for the message body\n                if (frame.length > 100'000) {\n                    // The STARTUP message body is a [string map] containing just a few options,\n                    // so it should be smaller that 100kB. See #4366.\n                    throw exceptions::protocol_exception(format(\"Initial message size too large ({:d}), rejecting as invalid\", frame.length));\n                }\n                return make_ready_future<ret_type>(frame);\n            });\n        });\n    } else {\n        // Not the first frame, so we know the size.\n        return _read_buf.read_exactly(frame_size()).then([this] (temporary_buffer<char> buf) {\n            if (buf.empty()) {\n                return make_ready_future<ret_type>();\n            }\n            return make_ready_future<ret_type>(parse_frame(std::move(buf)));\n        });\n    }\n}\n\nfuture<foreign_ptr<std::unique_ptr<cql_server::response>>>\n    cql_server::connection::process_request_one(fragmented_temporary_buffer::istream fbuf, uint8_t op, uint16_t stream, service::client_state& client_state, tracing_request_type tracing_request, service_permit permit) {\n    using auth_state = service::client_state::auth_state;\n\n    auto cqlop = static_cast<cql_binary_opcode>(op);\n    tracing::trace_state_props_set trace_props;\n\n    trace_props.set_if<tracing::trace_state_props::log_slow_query>(tracing::tracing::get_local_tracing_instance().slow_query_tracing_enabled());\n    trace_props.set_if<tracing::trace_state_props::full_tracing>(tracing_request != tracing_request_type::not_requested);\n    tracing::trace_state_ptr trace_state;\n\n    if (trace_props) {\n        if (cqlop == cql_binary_opcode::QUERY ||\n            cqlop == cql_binary_opcode::PREPARE ||\n            cqlop == cql_binary_opcode::EXECUTE ||\n            cqlop == cql_binary_opcode::BATCH) {\n            trace_props.set_if<tracing::trace_state_props::write_on_close>(tracing_request == tracing_request_type::write_on_close);\n            trace_state = tracing::tracing::get_local_tracing_instance().create_session(tracing::trace_type::QUERY, trace_props);\n        }\n    }\n\n    tracing::set_request_size(trace_state, fbuf.bytes_left());\n\n    auto linearization_buffer = std::make_unique<bytes_ostream>();\n    auto linearization_buffer_ptr = linearization_buffer.get();\n    return futurize_invoke([this, cqlop, stream, &fbuf, &client_state, linearization_buffer_ptr, permit = std::move(permit), trace_state] () mutable {\n        // When using authentication, we need to ensure we are doing proper state transitions,\n        // i.e. we cannot simply accept any query/exec ops unless auth is complete\n        switch (client_state.get_auth_state()) {\n            case auth_state::UNINITIALIZED:\n                if (cqlop != cql_binary_opcode::STARTUP && cqlop != cql_binary_opcode::OPTIONS) {\n                    throw exceptions::protocol_exception(format(\"Unexpected message {:d}, expecting STARTUP or OPTIONS\", int(cqlop)));\n                }\n                break;\n            case auth_state::AUTHENTICATION:\n                // Support both SASL auth from protocol v2 and the older style Credentials auth from v1\n                if (cqlop != cql_binary_opcode::AUTH_RESPONSE && cqlop != cql_binary_opcode::CREDENTIALS) {\n                    throw exceptions::protocol_exception(format(\"Unexpected message {:d}, expecting {}\", int(cqlop), _version == 1 ? \"CREDENTIALS\" : \"SASL_RESPONSE\"));\n                }\n                break;\n            case auth_state::READY: default:\n                if (cqlop == cql_binary_opcode::STARTUP) {\n                    throw exceptions::protocol_exception(\"Unexpected message STARTUP, the connection is already initialized\");\n                }\n                break;\n        }\n\n        tracing::set_username(trace_state, client_state.user());\n\n        auto wrap_in_foreign = [] (future<std::unique_ptr<cql_server::response>> f) {\n            return f.then([] (std::unique_ptr<cql_server::response> p) {\n                return make_ready_future<result_with_foreign_response_ptr>(make_foreign(std::move(p)));\n            });\n        };\n        auto in = request_reader(std::move(fbuf), *linearization_buffer_ptr);\n        switch (cqlop) {\n        case cql_binary_opcode::STARTUP:       return wrap_in_foreign(process_startup(stream, std::move(in), client_state, trace_state));\n        case cql_binary_opcode::AUTH_RESPONSE: return wrap_in_foreign(process_auth_response(stream, std::move(in), client_state, trace_state));\n        case cql_binary_opcode::OPTIONS:       return wrap_in_foreign(process_options(stream, std::move(in), client_state, trace_state));\n        case cql_binary_opcode::QUERY:         return process_query(stream, std::move(in), client_state, std::move(permit), trace_state);\n        case cql_binary_opcode::PREPARE:       return wrap_in_foreign(process_prepare(stream, std::move(in), client_state, trace_state));\n        case cql_binary_opcode::EXECUTE:       return process_execute(stream, std::move(in), client_state, std::move(permit), trace_state);\n        case cql_binary_opcode::BATCH:         return process_batch(stream, std::move(in), client_state, std::move(permit), trace_state);\n        case cql_binary_opcode::REGISTER:      return wrap_in_foreign(process_register(stream, std::move(in), client_state, trace_state));\n        default:                               throw exceptions::protocol_exception(format(\"Unknown opcode {:d}\", int(cqlop)));\n        }\n    }).then_wrapped([this, cqlop, stream, &client_state, linearization_buffer = std::move(linearization_buffer), trace_state] (future<result_with_foreign_response_ptr> f) {\n        auto stop_trace = defer([&] {\n            tracing::stop_foreground(trace_state);\n        });\n        --_server._stats.requests_serving;\n\n        return utils::result_into_future<result_with_foreign_response_ptr>(utils::result_try([&] () -> result_with_foreign_response_ptr {\n            result_with_foreign_response_ptr res = f.get0();\n            if (!res) {\n                return res;\n            }\n\n            auto response = std::move(res).assume_value();\n            auto res_op = response->opcode();\n\n            // and modify state now that we've generated a response.\n            switch (client_state.get_auth_state()) {\n            case auth_state::UNINITIALIZED:\n                if (cqlop == cql_binary_opcode::STARTUP) {\n                    if (res_op == cql_binary_opcode::AUTHENTICATE) {\n                        client_state.set_auth_state(auth_state::AUTHENTICATION);\n                    } else if (res_op == cql_binary_opcode::READY) {\n                        client_state.set_auth_state(auth_state::READY);\n                    }\n                }\n                break;\n            case auth_state::AUTHENTICATION:\n                // Support both SASL auth from protocol v2 and the older style Credentials auth from v1\n                if (cqlop != cql_binary_opcode::AUTH_RESPONSE && cqlop != cql_binary_opcode::CREDENTIALS) {\n                    throw exceptions::protocol_exception(format(\"Unexpected message {:d}, expecting AUTH_RESPONSE or CREDENTIALS\", int(cqlop)));\n                }\n                if (res_op == cql_binary_opcode::READY || res_op == cql_binary_opcode::AUTH_SUCCESS) {\n                    client_state.set_auth_state(auth_state::READY);\n                }\n                break;\n            default:\n            case auth_state::READY:\n                break;\n            }\n\n            tracing::set_response_size(trace_state, response->size());\n            return response;\n        },  utils::result_catch<exceptions::unavailable_exception>([&] (const auto& ex) {\n            try { ++_server._stats.errors[ex.code()]; } catch(...) {}\n            return make_unavailable_error(stream, ex.code(), ex.what(), ex.consistency, ex.required, ex.alive, trace_state);\n        }), utils::result_catch<exceptions::read_timeout_exception>([&] (const auto& ex) {\n            try { ++_server._stats.errors[ex.code()]; } catch(...) {}\n            return make_read_timeout_error(stream, ex.code(), ex.what(), ex.consistency, ex.received, ex.block_for, ex.data_present, trace_state);\n        }), utils::result_catch<exceptions::read_failure_exception>([&] (const auto& ex) {\n            try { ++_server._stats.errors[ex.code()]; } catch(...) {}\n            return make_read_failure_error(stream, ex.code(), ex.what(), ex.consistency, ex.received, ex.failures, ex.block_for, ex.data_present, trace_state);\n        }), utils::result_catch<exceptions::mutation_write_timeout_exception>([&] (const auto& ex) {\n            try { ++_server._stats.errors[ex.code()]; } catch(...) {}\n            return make_mutation_write_timeout_error(stream, ex.code(), ex.what(), ex.consistency, ex.received, ex.block_for, ex.type, trace_state);\n        }), utils::result_catch<exceptions::mutation_write_failure_exception>([&] (const auto& ex) {\n            try { ++_server._stats.errors[ex.code()]; } catch(...) {}\n            return make_mutation_write_failure_error(stream, ex.code(), ex.what(), ex.consistency, ex.received, ex.failures, ex.block_for, ex.type, trace_state);\n        }), utils::result_catch<exceptions::already_exists_exception>([&] (const auto& ex) {\n            try { ++_server._stats.errors[ex.code()]; } catch(...) {}\n            return make_already_exists_error(stream, ex.code(), ex.what(), ex.ks_name, ex.cf_name, trace_state);\n        }), utils::result_catch<exceptions::prepared_query_not_found_exception>([&] (const auto& ex) {\n            try { ++_server._stats.errors[ex.code()]; } catch(...) {}\n            return make_unprepared_error(stream, ex.code(), ex.what(), ex.id, trace_state);\n        }), utils::result_catch<exceptions::function_execution_exception>([&] (const auto& ex) {\n            try { ++_server._stats.errors[ex.code()]; } catch(...) {}\n            return make_function_failure_error(stream, ex.code(), ex.what(), ex.ks_name, ex.func_name, ex.args, trace_state);\n        }), utils::result_catch<exceptions::rate_limit_exception>([&] (const auto& ex) {\n            try { ++_server._stats.errors[ex.code()]; } catch(...) {}\n            return make_rate_limit_error(stream, ex.code(), ex.what(), ex.op_type, ex.rejected_by_coordinator, trace_state, client_state);\n        }), utils::result_catch<exceptions::cassandra_exception>([&] (const auto& ex) {\n            // Note: the CQL protocol specifies that many types of errors have\n            // mandatory parameters. These cassandra_exception subclasses MUST\n            // be handled above. This default \"cassandra_exception\" case is\n            // only appropriate for the specific types of errors which do not have\n            // additional information, such as invalid_request_exception.\n            // TODO: consider listing those types explicitly, instead of the\n            // catch-all type cassandra_exception.\n            try { ++_server._stats.errors[ex.code()]; } catch(...) {}\n            return make_error(stream, ex.code(), ex.what(), trace_state);\n        }), utils::result_catch<std::exception>([&] (const auto& ex) {\n            try { ++_server._stats.errors[exceptions::exception_code::SERVER_ERROR]; } catch(...) {}\n            sstring msg = ex.what();\n            try {\n                std::rethrow_if_nested(ex);\n            } catch (...) {\n                std::ostringstream ss;\n                ss << msg << \": \" << std::current_exception();\n                msg = ss.str();\n            }\n            return make_error(stream, exceptions::exception_code::SERVER_ERROR, msg, trace_state);\n        }), utils::result_catch_dots([&] () {\n            try { ++_server._stats.errors[exceptions::exception_code::SERVER_ERROR]; } catch(...) {}\n            return make_error(stream, exceptions::exception_code::SERVER_ERROR, \"unknown error\", trace_state);\n        })));\n    });\n}\n\ncql_server::connection::connection(cql_server& server, socket_address server_addr, connected_socket&& fd, socket_address addr)\n    : generic_server::connection{server, std::move(fd)}\n    , _server(server)\n    , _server_addr(server_addr)\n    , _client_state(service::client_state::external_tag{}, server._auth_service, &server._sl_controller, server.timeout_config(), addr)\n{\n    _shedding_timer.set_callback([this] {\n        clogger.debug(\"Shedding all incoming requests due to overload\");\n        _shed_incoming_requests = true;\n    });\n}\n\ncql_server::connection::~connection() {\n}\n\nvoid cql_server::connection::on_connection_close()\n{\n    _server._notifier->unregister_connection(this);\n}\n\nstd::tuple<net::inet_address, int, client_type> cql_server::connection::make_client_key(const service::client_state& cli_state) {\n    return std::make_tuple(cli_state.get_client_address().addr(),\n            cli_state.get_client_port(),\n            cli_state.is_thrift() ? client_type::thrift : client_type::cql);\n}\n\nclient_data cql_server::connection::make_client_data() const {\n    client_data cd;\n    std::tie(cd.ip, cd.port, cd.ct) = make_client_key(_client_state);\n    cd.shard_id = this_shard_id();\n    cd.protocol_version = _version;\n    cd.driver_name = _client_state.get_driver_name();\n    cd.driver_version = _client_state.get_driver_version();\n    if (const auto user_ptr = _client_state.user(); user_ptr) {\n        cd.username = user_ptr->name;\n    }\n    if (_ready) {\n        cd.connection_stage = client_connection_stage::ready;\n    } else if (_authenticating) {\n        cd.connection_stage = client_connection_stage::authenticating;\n    }\n    return cd;\n}\n\nthread_local cql_server::connection::execution_stage_type\n        cql_server::connection::_process_request_stage{\"transport\", &connection::process_request_one};\n\nvoid cql_server::connection::handle_error(future<>&& f) {\n    try {\n        f.get();\n    } catch (const exceptions::cassandra_exception& ex) {\n        try { ++_server._stats.errors[ex.code()]; } catch(...) {}\n        write_response(make_error(0, ex.code(), ex.what(), tracing::trace_state_ptr()));\n    } catch (std::exception& ex) {\n        try { ++_server._stats.errors[exceptions::exception_code::SERVER_ERROR]; } catch(...) {}\n        write_response(make_error(0, exceptions::exception_code::SERVER_ERROR, ex.what(), tracing::trace_state_ptr()));\n    } catch (...) {\n        try { ++_server._stats.errors[exceptions::exception_code::SERVER_ERROR]; } catch(...) {}\n        write_response(make_error(0, exceptions::exception_code::SERVER_ERROR, \"unknown error\", tracing::trace_state_ptr()));\n    }\n}\n\nfuture<> cql_server::connection::process_request() {\n    return read_frame().then_wrapped([this] (future<std::optional<cql_binary_frame_v3>>&& v) {\n        auto maybe_frame = v.get0();\n        if (!maybe_frame) {\n            // eof\n            return make_ready_future<>();\n        }\n\n        auto& f = *maybe_frame;\n\n        const bool allow_shedding = _client_state.get_workload_type() == service::client_state::workload_type::interactive;\n        if (allow_shedding && _shed_incoming_requests) {\n            ++_server._stats.requests_shed;\n            return _read_buf.skip(f.length).then([this, stream = f.stream] {\n                write_response(make_error(stream, exceptions::exception_code::OVERLOADED,\n                        \"request shed due to coordinator overload\", tracing::trace_state_ptr()));\n                return make_ready_future<>();\n            });\n        }\n\n        tracing_request_type tracing_requested = tracing_request_type::not_requested;\n        if (f.flags & cql_frame_flags::tracing) {\n            // If tracing is requested for a specific CQL command - flush\n            // tracing info right after the command is over.\n            tracing_requested = tracing_request_type::write_on_close;\n        } else if (tracing::tracing::get_local_tracing_instance().trace_next_query()) {\n            tracing_requested = tracing_request_type::no_write_on_close;\n        }\n\n        auto op = f.opcode;\n        auto stream = f.stream;\n        auto mem_estimate = f.length * 2 + 8000; // Allow for extra copies and bookkeeping\n        if (mem_estimate > _server._max_request_size) {\n            write_response(make_error(stream, exceptions::exception_code::INVALID,\n                    format(\"request size too large (frame size {:d}; estimate {:d}; allowed {:d}\", f.length, mem_estimate, _server._max_request_size),\n                    tracing::trace_state_ptr()));\n            return std::exchange(_ready_to_respond, make_ready_future<>()).then([this] {\n                return _read_buf.close();\n            });\n        }\n\n        if (_server._stats.requests_serving > _server._max_concurrent_requests) {\n            ++_server._stats.requests_shed;\n            return _read_buf.skip(f.length).then([this, stream = f.stream] {\n                write_response(make_error(stream, exceptions::exception_code::OVERLOADED,\n                        format(\"too many in-flight requests (configured via max_concurrent_requests_per_shard): {}\", _server._stats.requests_serving),\n                        tracing::trace_state_ptr()));\n                return make_ready_future<>();\n            });\n        }\n\n        const auto shedding_timeout = std::chrono::milliseconds(50);\n        auto fut = allow_shedding\n                ? get_units(_server._memory_available, mem_estimate, shedding_timeout).then_wrapped([this, length = f.length] (auto f) {\n                    try {\n                        return make_ready_future<semaphore_units<>>(f.get0());\n                    } catch (semaphore_timed_out sto) {\n                        // Cancel shedding in case no more requests are going to do that on completion\n                        if (_pending_requests_gate.get_count() == 0) {\n                            _shed_incoming_requests = false;\n                        }\n                        return _read_buf.skip(length).then([sto = std::move(sto)] () mutable {\n                            return make_exception_future<semaphore_units<>>(std::move(sto));\n                        });\n                    }\n                })\n                : get_units(_server._memory_available, mem_estimate);\n        if (_server._memory_available.waiters()) {\n            if (allow_shedding && !_shedding_timer.armed()) {\n                _shedding_timer.arm(shedding_timeout);\n            }\n            ++_server._stats.requests_blocked_memory;\n        }\n\n        return fut.then_wrapped([this, length = f.length, flags = f.flags, op, stream, tracing_requested] (auto mem_permit_fut) {\n          if (mem_permit_fut.failed()) {\n              // Ignore semaphore errors - they are expected if load shedding took place\n              mem_permit_fut.ignore_ready_future();\n              return make_ready_future<>();\n          }\n          semaphore_units<> mem_permit = mem_permit_fut.get0();\n          return this->read_and_decompress_frame(length, flags).then([this, op, stream, tracing_requested, mem_permit = make_service_permit(std::move(mem_permit))] (fragmented_temporary_buffer buf) mutable {\n\n            ++_server._stats.requests_served;\n            ++_server._stats.requests_serving;\n\n            _pending_requests_gate.enter();\n            auto leave = defer([this] {\n                _shedding_timer.cancel();\n                _shed_incoming_requests = false;\n                _pending_requests_gate.leave();\n            });\n            auto istream = buf.get_istream();\n            (void)_process_request_stage(this, istream, op, stream, seastar::ref(_client_state), tracing_requested, mem_permit)\n                    .then_wrapped([this, buf = std::move(buf), mem_permit, leave = std::move(leave)] (future<foreign_ptr<std::unique_ptr<cql_server::response>>> response_f) mutable {\n                try {\n                    write_response(response_f.get0(), std::move(mem_permit), _compression);\n                    _ready_to_respond = _ready_to_respond.finally([leave = std::move(leave)] {});\n                } catch (...) {\n                    clogger.error(\"request processing failed: {}\", std::current_exception());\n                }\n            });\n\n            return make_ready_future<>();\n          });\n        });\n    });\n}\n\nnamespace compression_buffers {\n\n// Reusable buffers for compression and decompression. Cleared every\n// clear_buffers_trigger uses.\nstatic constexpr size_t clear_buffers_trigger = 100'000;\nstatic thread_local size_t buffer_use_count = 0;\nstatic thread_local utils::reusable_buffer input_buffer;\nstatic thread_local utils::reusable_buffer output_buffer;\n\nvoid on_compression_buffer_use() {\n    if (++buffer_use_count == clear_buffers_trigger) {\n        input_buffer.clear();\n        output_buffer.clear();\n        buffer_use_count = 0;\n    }\n}\n\n}\n\nfuture<fragmented_temporary_buffer> cql_server::connection::read_and_decompress_frame(size_t length, uint8_t flags)\n{\n    using namespace compression_buffers;\n    if (flags & cql_frame_flags::compression) {\n        if (_compression == cql_compression::lz4) {\n            if (length < 4) {\n                throw std::runtime_error(fmt::format(\"CQL frame truncated: expected to have at least 4 bytes, got {}\", length));\n            }\n            return _buffer_reader.read_exactly(_read_buf, length).then([this] (fragmented_temporary_buffer buf) {\n                auto linearization_buffer = bytes_ostream();\n                int32_t uncomp_len = request_reader(buf.get_istream(), linearization_buffer).read_int();\n                if (uncomp_len < 0) {\n                    throw std::runtime_error(\"CQL frame uncompressed length is negative: \" + std::to_string(uncomp_len));\n                }\n                buf.remove_prefix(4);\n                auto in = input_buffer.get_linearized_view(fragmented_temporary_buffer::view(buf));\n                auto uncomp = output_buffer.make_fragmented_temporary_buffer(uncomp_len, fragmented_temporary_buffer::default_fragment_size, [&] (bytes_mutable_view out) {\n                    auto ret = LZ4_decompress_safe(reinterpret_cast<const char*>(in.data()), reinterpret_cast<char*>(out.data()),\n                                                   in.size(), out.size());\n                    if (ret < 0) {\n                        throw std::runtime_error(\"CQL frame LZ4 uncompression failure\");\n                    }\n                    if (ret != out.size()) {\n                        throw std::runtime_error(\"Malformed CQL frame - provided uncompressed size different than real uncompressed size\");\n                    }\n                    return static_cast<size_t>(ret);\n                });\n                on_compression_buffer_use();\n                return uncomp;\n            });\n        } else if (_compression == cql_compression::snappy) {\n            return _buffer_reader.read_exactly(_read_buf, length).then([this] (fragmented_temporary_buffer buf) {\n                auto in = input_buffer.get_linearized_view(fragmented_temporary_buffer::view(buf));\n                size_t uncomp_len;\n                if (snappy_uncompressed_length(reinterpret_cast<const char*>(in.data()), in.size(), &uncomp_len) != SNAPPY_OK) {\n                    throw std::runtime_error(\"CQL frame Snappy uncompressed size is unknown\");\n                }\n                auto uncomp = output_buffer.make_fragmented_temporary_buffer(uncomp_len, fragmented_temporary_buffer::default_fragment_size, [&] (bytes_mutable_view out) {\n                    size_t output_len = out.size();\n                    if (snappy_uncompress(reinterpret_cast<const char*>(in.data()), in.size(), reinterpret_cast<char*>(out.data()), &output_len) != SNAPPY_OK) {\n                        throw std::runtime_error(\"CQL frame Snappy uncompression failure\");\n                    }\n                    return output_len;\n                });\n                on_compression_buffer_use();\n                return uncomp;\n            });\n        } else {\n            throw exceptions::protocol_exception(format(\"Unknown compression algorithm\"));\n        }\n    }\n    return _buffer_reader.read_exactly(_read_buf, length);\n}\n\nfuture<std::unique_ptr<cql_server::response>> cql_server::connection::process_startup(uint16_t stream, request_reader in, service::client_state& client_state,\n        tracing::trace_state_ptr trace_state) {\n    ++_server._stats.startups;\n    auto options = in.read_string_map();\n    auto compression_opt = options.find(\"COMPRESSION\");\n    if (compression_opt != options.end()) {\n         auto compression = compression_opt->second;\n         std::transform(compression.begin(), compression.end(), compression.begin(), ::tolower);\n         if (compression == \"lz4\") {\n             _compression = cql_compression::lz4;\n         } else if (compression == \"snappy\") {\n             _compression = cql_compression::snappy;\n         } else {\n             throw exceptions::protocol_exception(format(\"Unknown compression algorithm: {}\", compression));\n         }\n    }\n\n    if (auto driver_ver_opt = options.find(\"DRIVER_VERSION\"); driver_ver_opt != options.end()) {\n        _client_state.set_driver_version(driver_ver_opt->second);\n    }\n    if (auto driver_name_opt = options.find(\"DRIVER_NAME\"); driver_name_opt != options.end()) {\n        _client_state.set_driver_name(driver_name_opt->second);\n    }\n\n    cql_protocol_extension_enum_set cql_proto_exts;\n    for (cql_protocol_extension ext : supported_cql_protocol_extensions()) {\n        if (options.contains(protocol_extension_name(ext))) {\n            cql_proto_exts.set(ext);\n        }\n    }\n    _client_state.set_protocol_extensions(std::move(cql_proto_exts));\n    std::unique_ptr<cql_server::response> res;\n    if (auto& a = client_state.get_auth_service()->underlying_authenticator(); a.require_authentication()) {\n        _authenticating = true;\n        res = make_autheticate(stream, a.qualified_java_name(), trace_state);\n    } else {\n        _ready = true;\n        res = make_ready(stream, trace_state);\n    }\n\n    return make_ready_future<decltype(res)>(std::move(res));\n}\n\nfuture<std::unique_ptr<cql_server::response>> cql_server::connection::process_auth_response(uint16_t stream, request_reader in, service::client_state& client_state,\n        tracing::trace_state_ptr trace_state) {\n    ++_server._stats.auth_responses;\n    auto sasl_challenge = client_state.get_auth_service()->underlying_authenticator().new_sasl_challenge();\n    auto buf = in.read_raw_bytes_view(in.bytes_left());\n    auto challenge = sasl_challenge->evaluate_response(buf);\n    if (sasl_challenge->is_complete()) {\n        return sasl_challenge->get_authenticated_user().then([this, sasl_challenge, stream, &client_state, challenge = std::move(challenge), trace_state](auth::authenticated_user user) mutable {\n            client_state.set_login(std::move(user));\n            auto f = client_state.check_user_can_login();\n            f = f.then([&client_state] {\n                return client_state.maybe_update_per_service_level_params();\n            });\n            return f.then([this, stream, &client_state, challenge = std::move(challenge), trace_state]() mutable {\n                return make_ready_future<std::unique_ptr<cql_server::response>>(make_auth_success(stream, std::move(challenge), trace_state));\n            });\n        });\n    }\n    return make_ready_future<std::unique_ptr<cql_server::response>>(make_auth_challenge(stream, std::move(challenge), trace_state));\n}\n\nfuture<std::unique_ptr<cql_server::response>> cql_server::connection::process_options(uint16_t stream, request_reader in, service::client_state& client_state,\n        tracing::trace_state_ptr trace_state) {\n    ++_server._stats.options_requests;\n    return make_ready_future<std::unique_ptr<cql_server::response>>(make_supported(stream, std::move(trace_state)));\n}\n\nvoid\ncql_server::connection::init_cql_serialization_format() {\n    _cql_serialization_format = cql_serialization_format(_version);\n}\n\nstd::unique_ptr<cql_server::response>\nmake_result(int16_t stream, messages::result_message& msg, const tracing::trace_state_ptr& tr_state,\n        cql_protocol_version_type version, bool skip_metadata = false);\n\ntemplate<typename Process>\nfuture<cql_server::result_with_foreign_response_ptr>\ncql_server::connection::process_on_shard(::shared_ptr<messages::result_message::bounce_to_shard> bounce_msg, uint16_t stream, fragmented_temporary_buffer::istream is,\n        service::client_state& cs, service_permit permit, tracing::trace_state_ptr trace_state, Process process_fn) {\n    return _server.container().invoke_on(*bounce_msg->move_to_shard(), _server._config.bounce_request_smp_service_group,\n            [this, is = std::move(is), cs = cs.move_to_other_shard(), stream, permit = std::move(permit), process_fn,\n             gt = tracing::global_trace_state_ptr(std::move(trace_state)),\n             cached_vals = std::move(bounce_msg->take_cached_pk_function_calls())] (cql_server& server) {\n        service::client_state client_state = cs.get();\n        return do_with(bytes_ostream(), std::move(client_state), std::move(cached_vals),\n                [this, &server, is = std::move(is), stream, process_fn,\n                 trace_state = tracing::trace_state_ptr(gt)] (bytes_ostream& linearization_buffer,\n                    service::client_state& client_state,\n                    cql3::computed_function_values& cached_vals) mutable {\n            request_reader in(is, linearization_buffer);\n            return process_fn(client_state, server._query_processor, in, stream, _version, _cql_serialization_format,\n                    /* FIXME */empty_service_permit(), std::move(trace_state), false, std::move(cached_vals)).then([] (auto msg) {\n                // result here has to be foreign ptr\n                return std::get<cql_server::result_with_foreign_response_ptr>(std::move(msg));\n            });\n        });\n    });\n}\n\nusing process_fn_return_type = std::variant<\n    cql_server::result_with_foreign_response_ptr,\n    ::shared_ptr<messages::result_message::bounce_to_shard>>;\n\nstatic inline cql_server::result_with_foreign_response_ptr convert_error_message_to_coordinator_result(messages::result_message* msg) {\n    return std::move(*dynamic_cast<messages::result_message::exception*>(msg)).get_exception();\n}\n\ntemplate<typename Process>\nfuture<cql_server::result_with_foreign_response_ptr>\ncql_server::connection::process(uint16_t stream, request_reader in, service::client_state& client_state, service_permit permit,\n        tracing::trace_state_ptr trace_state, Process process_fn) {\n    fragmented_temporary_buffer::istream is = in.get_stream();\n\n    return process_fn(client_state, _server._query_processor, in, stream,\n            _version, _cql_serialization_format, permit, trace_state, true, {})\n            .then([stream, &client_state, this, is, permit, process_fn, trace_state]\n                   (process_fn_return_type msg) mutable {\n        auto* bounce_msg = std::get_if<shared_ptr<messages::result_message::bounce_to_shard>>(&msg);\n        if (bounce_msg) {\n            return process_on_shard(*bounce_msg, stream, is, client_state, std::move(permit), trace_state, process_fn);\n        }\n        auto ptr = std::get<cql_server::result_with_foreign_response_ptr>(std::move(msg));\n        return make_ready_future<cql_server::result_with_foreign_response_ptr>(std::move(ptr));\n    });\n}\n\nstatic future<process_fn_return_type>\nprocess_query_internal(service::client_state& client_state, distributed<cql3::query_processor>& qp, request_reader in,\n        uint16_t stream, cql_protocol_version_type version, cql_serialization_format serialization_format,\n        service_permit permit, tracing::trace_state_ptr trace_state, bool init_trace, cql3::computed_function_values cached_pk_fn_calls) {\n    auto query = in.read_long_string_view();\n    auto q_state = std::make_unique<cql_query_state>(client_state, trace_state, std::move(permit));\n    auto& query_state = q_state->query_state;\n    q_state->options = in.read_options(version, serialization_format, qp.local().get_cql_config());\n    auto& options = *q_state->options;\n    if (!cached_pk_fn_calls.empty()) {\n        options.set_cached_pk_function_calls(std::move(cached_pk_fn_calls));\n    }\n    auto skip_metadata = options.skip_metadata();\n\n    if (init_trace) {\n        tracing::set_page_size(trace_state, options.get_page_size());\n        tracing::set_consistency_level(trace_state, options.get_consistency());\n        tracing::set_optional_serial_consistency_level(trace_state, options.get_serial_consistency());\n        tracing::add_query(trace_state, query);\n        tracing::set_user_timestamp(trace_state, options.get_specific_options().timestamp);\n\n        tracing::begin(trace_state, \"Execute CQL3 query\", client_state.get_client_address());\n    }\n\n    return qp.local().execute_direct_without_checking_exception_message(query, query_state, options).then([q_state = std::move(q_state), stream, skip_metadata, version] (auto msg) {\n        if (msg->move_to_shard()) {\n            return process_fn_return_type(dynamic_pointer_cast<messages::result_message::bounce_to_shard>(msg));\n        } else if (msg->is_exception()) {\n            return process_fn_return_type(convert_error_message_to_coordinator_result(msg.get()));\n        } else {\n            tracing::trace(q_state->query_state.get_trace_state(), \"Done processing - preparing a result\");\n            return process_fn_return_type(make_foreign(make_result(stream, *msg, q_state->query_state.get_trace_state(), version, skip_metadata)));\n        }\n    });\n}\n\nfuture<cql_server::result_with_foreign_response_ptr>\ncql_server::connection::process_query(uint16_t stream, request_reader in, service::client_state& client_state, service_permit permit, tracing::trace_state_ptr trace_state) {\n    ++_server._stats.query_requests;\n    return process(stream, in, client_state, std::move(permit), std::move(trace_state), process_query_internal);\n}\n\nfuture<std::unique_ptr<cql_server::response>> cql_server::connection::process_prepare(uint16_t stream, request_reader in, service::client_state& client_state,\n        tracing::trace_state_ptr trace_state) {\n    ++_server._stats.prepare_requests;\n\n    auto query = sstring(in.read_long_string_view());\n\n    tracing::add_query(trace_state, query);\n    tracing::begin(trace_state, \"Preparing CQL3 query\", client_state.get_client_address());\n\n    auto cpu_id = this_shard_id();\n    auto cpus = boost::irange(0u, smp::count);\n    return parallel_for_each(cpus.begin(), cpus.end(), [this, query, cpu_id, &client_state] (unsigned int c) mutable {\n        if (c != cpu_id) {\n            return smp::submit_to(c, [this, query, &client_state] () mutable {\n                return _server._query_processor.local().prepare(std::move(query), client_state, false).discard_result();\n            });\n        } else {\n            return make_ready_future<>();\n        }\n    }).then([this, query, stream, &client_state, trace_state] () mutable {\n        tracing::trace(trace_state, \"Done preparing on remote shards\");\n        return _server._query_processor.local().prepare(std::move(query), client_state, false).then([this, stream, &client_state, trace_state] (auto msg) {\n            tracing::trace(trace_state, \"Done preparing on a local shard - preparing a result. ID is [{}]\", seastar::value_of([&msg] {\n                return messages::result_message::prepared::cql::get_id(msg);\n            }));\n            return make_result(stream, *msg, trace_state, _version);\n        });\n    });\n}\n\nstatic future<process_fn_return_type>\nprocess_execute_internal(service::client_state& client_state, distributed<cql3::query_processor>& qp, request_reader in,\n        uint16_t stream, cql_protocol_version_type version, cql_serialization_format serialization_format,\n        service_permit permit, tracing::trace_state_ptr trace_state, bool init_trace, cql3::computed_function_values cached_pk_fn_calls) {\n    cql3::prepared_cache_key_type cache_key(in.read_short_bytes());\n    auto& id = cql3::prepared_cache_key_type::cql_id(cache_key);\n    bool needs_authorization = false;\n\n    // First, try to lookup in the cache of already authorized statements. If the corresponding entry is not found there\n    // look for the prepared statement and then authorize it.\n    auto prepared = qp.local().get_prepared(client_state.user(), cache_key);\n    if (!prepared) {\n        needs_authorization = true;\n        prepared = qp.local().get_prepared(cache_key);\n    }\n\n    if (!prepared) {\n        throw exceptions::prepared_query_not_found_exception(id);\n    }\n\n    auto q_state = std::make_unique<cql_query_state>(client_state, trace_state, std::move(permit));\n    auto& query_state = q_state->query_state;\n    if (version == 1) {\n        std::vector<cql3::raw_value_view> values;\n        in.read_value_view_list(version, values);\n        auto consistency = in.read_consistency();\n        q_state->options = std::make_unique<cql3::query_options>(qp.local().get_cql_config(), consistency, std::nullopt, values, false,\n                                                                 cql3::query_options::specific_options::DEFAULT, serialization_format);\n    } else {\n        q_state->options = in.read_options(version, serialization_format, qp.local().get_cql_config());\n    }\n    auto& options = *q_state->options;\n    if (!cached_pk_fn_calls.empty()) {\n        options.set_cached_pk_function_calls(std::move(cached_pk_fn_calls));\n    }\n    auto skip_metadata = options.skip_metadata();\n\n    if (init_trace) {\n        tracing::set_page_size(trace_state, options.get_page_size());\n        tracing::set_consistency_level(trace_state, options.get_consistency());\n        tracing::set_optional_serial_consistency_level(trace_state, options.get_serial_consistency());\n        tracing::add_query(trace_state, prepared->statement->raw_cql_statement);\n        tracing::add_prepared_statement(trace_state, prepared);\n\n        tracing::begin(trace_state, seastar::value_of([&id] { return seastar::format(\"Execute CQL3 prepared query [{}]\", id); }),\n                client_state.get_client_address());\n    }\n\n    auto stmt = prepared->statement;\n    tracing::trace(query_state.get_trace_state(), \"Checking bounds\");\n    if (stmt->get_bound_terms() != options.get_values_count()) {\n        const auto msg = format(\"Invalid amount of bind variables: expected {:d} received {:d}\",\n                stmt->get_bound_terms(),\n                options.get_values_count());\n        tracing::trace(query_state.get_trace_state(), msg);\n        throw exceptions::invalid_request_exception(msg);\n    }\n\n    options.prepare(prepared->bound_names);\n\n    if (init_trace) {\n        tracing::add_prepared_query_options(trace_state, options);\n    }\n\n    tracing::trace(trace_state, \"Processing a statement\");\n    return qp.local().execute_prepared_without_checking_exception_message(std::move(prepared), std::move(cache_key), query_state, options, needs_authorization)\n            .then([trace_state = query_state.get_trace_state(), skip_metadata, q_state = std::move(q_state), stream, version] (auto msg) {\n        if (msg->move_to_shard()) {\n            return process_fn_return_type(dynamic_pointer_cast<messages::result_message::bounce_to_shard>(msg));\n        } else if (msg->is_exception()) {\n            return process_fn_return_type(convert_error_message_to_coordinator_result(msg.get()));\n        } else {\n            tracing::trace(q_state->query_state.get_trace_state(), \"Done processing - preparing a result\");\n            return process_fn_return_type(make_foreign(make_result(stream, *msg, q_state->query_state.get_trace_state(), version, skip_metadata)));\n        }\n    });\n}\n\nfuture<cql_server::result_with_foreign_response_ptr> cql_server::connection::process_execute(uint16_t stream, request_reader in,\n        service::client_state& client_state, service_permit permit, tracing::trace_state_ptr trace_state) {\n    ++_server._stats.execute_requests;\n    return process(stream, in, client_state, std::move(permit), std::move(trace_state), process_execute_internal);\n}\n\nstatic future<process_fn_return_type>\nprocess_batch_internal(service::client_state& client_state, distributed<cql3::query_processor>& qp, request_reader in,\n        uint16_t stream, cql_protocol_version_type version, cql_serialization_format serialization_format,\n        service_permit permit, tracing::trace_state_ptr trace_state, bool init_trace, cql3::computed_function_values cached_pk_fn_calls) {\n    if (version == 1) {\n        throw exceptions::protocol_exception(\"BATCH messages are not support in version 1 of the protocol\");\n    }\n\n    const auto type = in.read_byte();\n    const unsigned n = in.read_short();\n\n    std::vector<cql3::statements::batch_statement::single_statement> modifications;\n    std::vector<std::vector<cql3::raw_value_view>> values;\n    std::unordered_map<cql3::prepared_cache_key_type, cql3::authorized_prepared_statements_cache::value_type> pending_authorization_entries;\n\n    modifications.reserve(n);\n    values.reserve(n);\n\n    if (init_trace) {\n        tracing::begin(trace_state, \"Execute batch of CQL3 queries\", client_state.get_client_address());\n    }\n\n    for ([[gnu::unused]] auto i : boost::irange(0u, n)) {\n        const auto kind = in.read_byte();\n\n        std::unique_ptr<cql3::statements::prepared_statement> stmt_ptr;\n        cql3::statements::prepared_statement::checked_weak_ptr ps;\n        bool needs_authorization(kind == 0);\n\n        switch (kind) {\n        case 0: {\n            auto query = in.read_long_string_view();\n            stmt_ptr = qp.local().get_statement(query, client_state);\n            ps = stmt_ptr->checked_weak_from_this();\n            if (init_trace) {\n                tracing::add_query(trace_state, query);\n            }\n            break;\n        }\n        case 1: {\n            cql3::prepared_cache_key_type cache_key(in.read_short_bytes());\n            auto& id = cql3::prepared_cache_key_type::cql_id(cache_key);\n\n            // First, try to lookup in the cache of already authorized statements. If the corresponding entry is not found there\n            // look for the prepared statement and then authorize it.\n            ps = qp.local().get_prepared(client_state.user(), cache_key);\n            if (!ps) {\n                ps = qp.local().get_prepared(cache_key);\n                if (!ps) {\n                    throw exceptions::prepared_query_not_found_exception(id);\n                }\n                // authorize a particular prepared statement only once\n                needs_authorization = pending_authorization_entries.emplace(std::move(cache_key), ps->checked_weak_from_this()).second;\n            }\n            if (init_trace) {\n                tracing::add_query(trace_state, ps->statement->raw_cql_statement);\n            }\n            break;\n        }\n        default:\n            throw exceptions::protocol_exception(\n                    \"Invalid query kind in BATCH messages. Must be 0 or 1 but got \"\n                            + std::to_string(int(kind)));\n        }\n\n        if (dynamic_cast<cql3::statements::modification_statement*>(ps->statement.get()) == nullptr) {\n            throw exceptions::invalid_request_exception(\"Invalid statement in batch: only UPDATE, INSERT and DELETE statements are allowed.\");\n        }\n\n        ::shared_ptr<cql3::statements::modification_statement> modif_statement_ptr = static_pointer_cast<cql3::statements::modification_statement>(ps->statement);\n        if (init_trace) {\n            tracing::add_table_name(trace_state, modif_statement_ptr->keyspace(), modif_statement_ptr->column_family());\n            tracing::add_prepared_statement(trace_state, ps);\n        }\n\n        modifications.emplace_back(std::move(modif_statement_ptr), needs_authorization);\n\n        std::vector<cql3::raw_value_view> tmp;\n        in.read_value_view_list(version, tmp);\n\n        auto stmt = ps->statement;\n        if (stmt->get_bound_terms() != tmp.size()) {\n            throw exceptions::invalid_request_exception(format(\"There were {:d} markers(?) in CQL but {:d} bound variables\",\n                            stmt->get_bound_terms(), tmp.size()));\n        }\n        values.emplace_back(std::move(tmp));\n    }\n\n    auto q_state = std::make_unique<cql_query_state>(client_state, trace_state, std::move(permit));\n    auto& query_state = q_state->query_state;\n    // #563. CQL v2 encodes query_options in v1 format for batch requests.\n    q_state->options = std::make_unique<cql3::query_options>(cql3::query_options::make_batch_options(std::move(*in.read_options(version < 3 ? 1 : version, serialization_format,\n                                                                     qp.local().get_cql_config())), std::move(values)));\n    auto& options = *q_state->options;\n    if (!cached_pk_fn_calls.empty()) {\n        options.set_cached_pk_function_calls(std::move(cached_pk_fn_calls));\n    }\n\n    if (init_trace) {\n        tracing::set_consistency_level(trace_state, options.get_consistency());\n        tracing::set_optional_serial_consistency_level(trace_state, options.get_serial_consistency());\n        tracing::add_prepared_query_options(trace_state, options);\n        tracing::trace(trace_state, \"Creating a batch statement\");\n    }\n\n    auto batch = ::make_shared<cql3::statements::batch_statement>(cql3::statements::batch_statement::type(type), std::move(modifications), cql3::attributes::none(), qp.local().get_cql_stats());\n    return qp.local().execute_batch_without_checking_exception_message(batch, query_state, options, std::move(pending_authorization_entries))\n            .then([stream, batch, q_state = std::move(q_state), trace_state = query_state.get_trace_state(), version] (auto msg) {\n        if (msg->move_to_shard()) {\n            return process_fn_return_type(dynamic_pointer_cast<messages::result_message::bounce_to_shard>(msg));\n        } else if (msg->is_exception()) {\n            return process_fn_return_type(convert_error_message_to_coordinator_result(msg.get()));\n        } else {\n            tracing::trace(q_state->query_state.get_trace_state(), \"Done processing - preparing a result\");\n            return process_fn_return_type(make_foreign(make_result(stream, *msg, trace_state, version)));\n        }\n    });\n}\n\nfuture<cql_server::result_with_foreign_response_ptr>\ncql_server::connection::process_batch(uint16_t stream, request_reader in, service::client_state& client_state, service_permit permit,\n        tracing::trace_state_ptr trace_state) {\n    ++_server._stats.batch_requests;\n    return process(stream, in, client_state, permit, std::move(trace_state), process_batch_internal);\n}\n\nfuture<std::unique_ptr<cql_server::response>>\ncql_server::connection::process_register(uint16_t stream, request_reader in, service::client_state& client_state,\n        tracing::trace_state_ptr trace_state) {\n    ++_server._stats.register_requests;\n    std::vector<sstring> event_types;\n    in.read_string_list(event_types);\n    for (auto&& event_type : event_types) {\n        auto et = parse_event_type(event_type);\n        _server._notifier->register_event(et, this);\n    }\n    _ready = true;\n    return make_ready_future<std::unique_ptr<cql_server::response>>(make_ready(stream, std::move(trace_state)));\n}\n\nstd::unique_ptr<cql_server::response> cql_server::connection::make_unavailable_error(int16_t stream, exceptions::exception_code err, sstring msg, db::consistency_level cl, int32_t required, int32_t alive, const tracing::trace_state_ptr& tr_state) const\n{\n    auto response = std::make_unique<cql_server::response>(stream, cql_binary_opcode::ERROR, tr_state);\n    response->write_int(static_cast<int32_t>(err));\n    response->write_string(msg);\n    response->write_consistency(cl);\n    response->write_int(required);\n    response->write_int(alive);\n    return response;\n}\n\nstd::unique_ptr<cql_server::response> cql_server::connection::make_read_timeout_error(int16_t stream, exceptions::exception_code err, sstring msg, db::consistency_level cl, int32_t received, int32_t blockfor, bool data_present, const tracing::trace_state_ptr& tr_state) const\n{\n    auto response = std::make_unique<cql_server::response>(stream, cql_binary_opcode::ERROR, tr_state);\n    response->write_int(static_cast<int32_t>(err));\n    response->write_string(msg);\n    response->write_consistency(cl);\n    response->write_int(received);\n    response->write_int(blockfor);\n    response->write_byte(data_present);\n    return response;\n}\n\nstd::unique_ptr<cql_server::response> cql_server::connection::make_read_failure_error(int16_t stream, exceptions::exception_code err, sstring msg, db::consistency_level cl, int32_t received, int32_t numfailures, int32_t blockfor, bool data_present, const tracing::trace_state_ptr& tr_state) const\n{\n    if (_version < 4) {\n        return make_read_timeout_error(stream, exceptions::exception_code::READ_TIMEOUT, std::move(msg), cl, received, blockfor, data_present, tr_state);\n    }\n    auto response = std::make_unique<cql_server::response>(stream, cql_binary_opcode::ERROR, tr_state);\n    response->write_int(static_cast<int32_t>(err));\n    response->write_string(msg);\n    response->write_consistency(cl);\n    response->write_int(received);\n    response->write_int(blockfor);\n    response->write_int(numfailures);\n    response->write_byte(data_present);\n    return response;\n}\n\nstd::unique_ptr<cql_server::response> cql_server::connection::make_mutation_write_timeout_error(int16_t stream, exceptions::exception_code err, sstring msg, db::consistency_level cl, int32_t received, int32_t blockfor, db::write_type type, const tracing::trace_state_ptr& tr_state) const\n{\n    auto response = std::make_unique<cql_server::response>(stream, cql_binary_opcode::ERROR, tr_state);\n    response->write_int(static_cast<int32_t>(err));\n    response->write_string(msg);\n    response->write_consistency(cl);\n    response->write_int(received);\n    response->write_int(blockfor);\n    response->write_string(format(\"{}\", type));\n    return response;\n}\n\nstd::unique_ptr<cql_server::response> cql_server::connection::make_mutation_write_failure_error(int16_t stream, exceptions::exception_code err, sstring msg, db::consistency_level cl, int32_t received, int32_t numfailures, int32_t blockfor, db::write_type type, const tracing::trace_state_ptr& tr_state) const\n{\n    if (_version < 4) {\n        return make_mutation_write_timeout_error(stream, exceptions::exception_code::WRITE_TIMEOUT, std::move(msg), cl, received, blockfor, type, tr_state);\n    }\n    auto response = std::make_unique<cql_server::response>(stream, cql_binary_opcode::ERROR, tr_state);\n    response->write_int(static_cast<int32_t>(err));\n    response->write_string(msg);\n    response->write_consistency(cl);\n    response->write_int(received);\n    response->write_int(blockfor);\n    response->write_int(numfailures);\n    response->write_string(format(\"{}\", type));\n    return response;\n}\n\nstd::unique_ptr<cql_server::response> cql_server::connection::make_already_exists_error(int16_t stream, exceptions::exception_code err, sstring msg, sstring ks_name, sstring cf_name, const tracing::trace_state_ptr& tr_state) const\n{\n    auto response = std::make_unique<cql_server::response>(stream, cql_binary_opcode::ERROR, tr_state);\n    response->write_int(static_cast<int32_t>(err));\n    response->write_string(msg);\n    response->write_string(ks_name);\n    response->write_string(cf_name);\n    return response;\n}\n\nstd::unique_ptr<cql_server::response> cql_server::connection::make_unprepared_error(int16_t stream, exceptions::exception_code err, sstring msg, bytes id, const tracing::trace_state_ptr& tr_state) const\n{\n    auto response = std::make_unique<cql_server::response>(stream, cql_binary_opcode::ERROR, tr_state);\n    response->write_int(static_cast<int32_t>(err));\n    response->write_string(msg);\n    response->write_short_bytes(id);\n    return response;\n}\n\nstd::unique_ptr<cql_server::response> cql_server::connection::make_function_failure_error(int16_t stream, exceptions::exception_code err, sstring msg, sstring ks_name, sstring func_name, std::vector<sstring> args, const tracing::trace_state_ptr& tr_state) const\n{\n    auto response = std::make_unique<cql_server::response>(stream, cql_binary_opcode::ERROR, tr_state);\n    response->write_int(static_cast<int32_t>(err));\n    response->write_string(msg);\n    response->write_string(ks_name);\n    response->write_string(func_name);\n    response->write_string_list(args);\n    return response;\n}\n\nstd::unique_ptr<cql_server::response> cql_server::connection::make_rate_limit_error(int16_t stream, exceptions::exception_code err, sstring msg, db::operation_type op_type, bool rejected_by_coordinator, const tracing::trace_state_ptr& tr_state, const service::client_state& client_state) const\n{\n    if (!client_state.is_protocol_extension_set(cql_protocol_extension::RATE_LIMIT_ERROR)) {\n        return make_error(stream, exceptions::exception_code::CONFIG_ERROR, std::move(msg), tr_state);\n    }\n\n    auto response = std::make_unique<cql_server::response>(stream, cql_binary_opcode::ERROR, tr_state);\n    response->write_int(static_cast<int32_t>(err));\n    response->write_string(msg);\n    response->write_byte(static_cast<uint8_t>(op_type));\n    response->write_byte(static_cast<uint8_t>(rejected_by_coordinator));\n    return response;\n}\n\nstd::unique_ptr<cql_server::response> cql_server::connection::make_error(int16_t stream, exceptions::exception_code err, sstring msg, const tracing::trace_state_ptr& tr_state) const\n{\n    auto response = std::make_unique<cql_server::response>(stream, cql_binary_opcode::ERROR, tr_state);\n    response->write_int(static_cast<int32_t>(err));\n    response->write_string(msg);\n    return response;\n}\n\nstd::unique_ptr<cql_server::response> cql_server::connection::make_ready(int16_t stream, const tracing::trace_state_ptr& tr_state) const\n{\n    return std::make_unique<cql_server::response>(stream, cql_binary_opcode::READY, tr_state);\n}\n\nstd::unique_ptr<cql_server::response> cql_server::connection::make_autheticate(int16_t stream, std::string_view clz, const tracing::trace_state_ptr& tr_state) const\n{\n    auto response = std::make_unique<cql_server::response>(stream, cql_binary_opcode::AUTHENTICATE, tr_state);\n    response->write_string(clz);\n    return response;\n}\n\nstd::unique_ptr<cql_server::response> cql_server::connection::make_auth_success(int16_t stream, bytes b, const tracing::trace_state_ptr& tr_state) const {\n    auto response = std::make_unique<cql_server::response>(stream, cql_binary_opcode::AUTH_SUCCESS, tr_state);\n    response->write_bytes(std::move(b));\n    return response;\n}\n\nstd::unique_ptr<cql_server::response> cql_server::connection::make_auth_challenge(int16_t stream, bytes b, const tracing::trace_state_ptr& tr_state) const {\n    auto response = std::make_unique<cql_server::response>(stream, cql_binary_opcode::AUTH_CHALLENGE, tr_state);\n    response->write_bytes(std::move(b));\n    return response;\n}\n\nstd::unique_ptr<cql_server::response> cql_server::connection::make_supported(int16_t stream, const tracing::trace_state_ptr& tr_state) const\n{\n    std::multimap<sstring, sstring> opts;\n    opts.insert({\"CQL_VERSION\", cql3::query_processor::CQL_VERSION});\n    opts.insert({\"COMPRESSION\", \"lz4\"});\n    opts.insert({\"COMPRESSION\", \"snappy\"});\n    if (_server._config.allow_shard_aware_drivers) {\n        opts.insert({\"SCYLLA_SHARD\", format(\"{:d}\", this_shard_id())});\n        opts.insert({\"SCYLLA_NR_SHARDS\", format(\"{:d}\", smp::count)});\n        opts.insert({\"SCYLLA_SHARDING_ALGORITHM\", dht::cpu_sharding_algorithm_name()});\n        if (_server._config.shard_aware_transport_port) {\n            opts.insert({\"SCYLLA_SHARD_AWARE_PORT\", format(\"{:d}\", *_server._config.shard_aware_transport_port)});\n        }\n        if (_server._config.shard_aware_transport_port_ssl) {\n            opts.insert({\"SCYLLA_SHARD_AWARE_PORT_SSL\", format(\"{:d}\", *_server._config.shard_aware_transport_port_ssl)});\n        }\n        opts.insert({\"SCYLLA_SHARDING_IGNORE_MSB\", format(\"{:d}\", _server._config.sharding_ignore_msb)});\n        opts.insert({\"SCYLLA_PARTITIONER\", _server._config.partitioner_name});\n    }\n    for (cql_protocol_extension ext : supported_cql_protocol_extensions()) {\n        const sstring ext_key_name = protocol_extension_name(ext);\n        std::vector<sstring> params = additional_options_for_proto_ext(ext);\n        if (params.empty()) {\n            opts.emplace(ext_key_name, \"\");\n        } else {\n            for (sstring val : params) {\n                opts.emplace(ext_key_name, std::move(val));\n            }\n        }\n    }\n    auto response = std::make_unique<cql_server::response>(stream, cql_binary_opcode::SUPPORTED, tr_state);\n    response->write_string_multimap(std::move(opts));\n    return response;\n}\n\nclass cql_server::fmt_visitor : public messages::result_message::visitor_base {\nprivate:\n    uint8_t _version;\n    cql_server::response& _response;\n    bool _skip_metadata;\npublic:\n    fmt_visitor(uint8_t version, cql_server::response& response, bool skip_metadata)\n        : _version{version}\n        , _response{response}\n        , _skip_metadata{skip_metadata}\n    { }\n\n    virtual void visit(const messages::result_message::void_message&) override {\n        _response.write_int(0x0001);\n    }\n\n    virtual void visit(const messages::result_message::set_keyspace& m) override {\n        _response.write_int(0x0003);\n        _response.write_string(m.get_keyspace());\n    }\n\n    virtual void visit(const messages::result_message::prepared::cql& m) override {\n        _response.write_int(0x0004);\n        _response.write_short_bytes(m.get_id());\n        _response.write(m.metadata(), _version);\n        if (_version > 1) {\n            _response.write(*m.result_metadata());\n        }\n    }\n\n    virtual void visit(const messages::result_message::schema_change& m) override {\n        auto change = m.get_change();\n        switch (change->type) {\n        case event::event_type::SCHEMA_CHANGE: {\n            auto sc = static_pointer_cast<event::schema_change>(change);\n            _response.write_int(0x0005);\n            _response.serialize(*sc, _version);\n            break;\n        }\n        default:\n            assert(0);\n        }\n    }\n\n    virtual void visit(const messages::result_message::rows& m) override {\n        _response.write_int(0x0002);\n        auto& rs = m.rs();\n        _response.write(rs.get_metadata(), _skip_metadata);\n        auto row_count_plhldr = _response.write_int_placeholder();\n\n        class visitor {\n            cql_server::response& _response;\n            int64_t _row_count = 0;\n        public:\n            visitor(cql_server::response& r) : _response(r) { }\n\n            void start_row() {\n                _row_count++;\n            }\n            void accept_value(std::optional<query::result_bytes_view> cell) {\n                _response.write_value(cell);\n            }\n            void end_row() { }\n\n            int64_t row_count() const { return _row_count; }\n        };\n\n        auto v = visitor(_response);\n        rs.visit(v);\n        row_count_plhldr.write(v.row_count()); // even though the placeholder is for int32_t we won't overflow because of memory limits\n    }\n};\n\nstd::unique_ptr<cql_server::response>\nmake_result(int16_t stream, messages::result_message& msg, const tracing::trace_state_ptr& tr_state,\n        cql_protocol_version_type version, bool skip_metadata) {\n    auto response = std::make_unique<cql_server::response>(stream, cql_binary_opcode::RESULT, tr_state);\n    if (__builtin_expect(!msg.warnings().empty() && version > 3, false)) {\n        response->set_frame_flag(cql_frame_flags::warning);\n        response->write_string_list(msg.warnings());\n    }\n    cql_server::fmt_visitor fmt{version, *response, skip_metadata};\n    msg.accept(fmt);\n    return response;\n}\n\nstd::unique_ptr<cql_server::response>\ncql_server::connection::make_topology_change_event(const event::topology_change& event) const\n{\n    auto response = std::make_unique<cql_server::response>(-1, cql_binary_opcode::EVENT, tracing::trace_state_ptr());\n    response->write_string(\"TOPOLOGY_CHANGE\");\n    response->write_string(to_string(event.change));\n    response->write_inet(event.node);\n    return response;\n}\n\nstd::unique_ptr<cql_server::response>\ncql_server::connection::make_status_change_event(const event::status_change& event) const\n{\n    auto response = std::make_unique<cql_server::response>(-1, cql_binary_opcode::EVENT, tracing::trace_state_ptr());\n    response->write_string(\"STATUS_CHANGE\");\n    response->write_string(to_string(event.status));\n    response->write_inet(event.node);\n    return response;\n}\n\nstd::unique_ptr<cql_server::response>\ncql_server::connection::make_schema_change_event(const event::schema_change& event) const\n{\n    auto response = std::make_unique<cql_server::response>(-1, cql_binary_opcode::EVENT, tracing::trace_state_ptr());\n    response->write_string(\"SCHEMA_CHANGE\");\n    response->serialize(event, _version);\n    return response;\n}\n\nvoid cql_server::connection::write_response(foreign_ptr<std::unique_ptr<cql_server::response>>&& response, service_permit permit, cql_compression compression)\n{\n    _ready_to_respond = _ready_to_respond.then([this, compression, response = std::move(response), permit = std::move(permit)] () mutable {\n        auto message = response->make_message(_version, compression);\n        message.on_delete([response = std::move(response)] { });\n        return _write_buf.write(std::move(message)).then([this] {\n            return _write_buf.flush();\n        });\n    });\n}\n\nscattered_message<char> cql_server::response::make_message(uint8_t version, cql_compression compression) {\n    if (compression != cql_compression::none) {\n        compress(compression);\n    }\n    scattered_message<char> msg;\n    auto frame = make_frame(version, _body.size());\n    msg.append(std::move(frame));\n    for (auto&& fragment : _body.fragments()) {\n        msg.append_static(reinterpret_cast<const char*>(fragment.data()), fragment.size());\n    }\n    return msg;\n}\n\nvoid cql_server::response::compress(cql_compression compression)\n{\n    switch (compression) {\n    case cql_compression::lz4:\n        compress_lz4();\n        break;\n    case cql_compression::snappy:\n        compress_snappy();\n        break;\n    default:\n        throw std::invalid_argument(\"Invalid CQL compression algorithm\");\n    }\n    set_frame_flag(cql_frame_flags::compression);\n}\n\nvoid cql_server::response::compress_lz4()\n{\n    using namespace compression_buffers;\n    auto view = input_buffer.get_linearized_view(_body);\n    const char* input = reinterpret_cast<const char*>(view.data());\n    size_t input_len = view.size();\n\n    size_t output_len = LZ4_COMPRESSBOUND(input_len) + 4;\n    _body = output_buffer.make_buffer(output_len, [&] (bytes_mutable_view output_view) {\n        char* output = reinterpret_cast<char*>(output_view.data());\n        output[0] = (input_len >> 24) & 0xFF;\n        output[1] = (input_len >> 16) & 0xFF;\n        output[2] = (input_len >> 8) & 0xFF;\n        output[3] = input_len & 0xFF;\n#ifdef HAVE_LZ4_COMPRESS_DEFAULT\n        auto ret = LZ4_compress_default(input, output + 4, input_len, LZ4_compressBound(input_len));\n#else\n        auto ret = LZ4_compress(input, output + 4, input_len);\n#endif\n        if (ret == 0) {\n            throw std::runtime_error(\"CQL frame LZ4 compression failure\");\n        }\n        return ret + 4;\n    });\n    on_compression_buffer_use();\n}\n\nvoid cql_server::response::compress_snappy()\n{\n    using namespace compression_buffers;\n    auto view = input_buffer.get_linearized_view(_body);\n    const char* input = reinterpret_cast<const char*>(view.data());\n    size_t input_len = view.size();\n\n    size_t output_len = snappy_max_compressed_length(input_len);\n    _body = output_buffer.make_buffer(output_len, [&] (bytes_mutable_view output_view) {\n        char* output = reinterpret_cast<char*>(output_view.data());\n        if (snappy_compress(input, input_len, output, &output_len) != SNAPPY_OK) {\n            throw std::runtime_error(\"CQL frame Snappy compression failure\");\n        }\n        return output_len;\n    });\n    on_compression_buffer_use();\n}\n\nvoid cql_server::response::serialize(const event::schema_change& event, uint8_t version)\n{\n    if (version >= 3) {\n        write_string(to_string(event.change));\n        write_string(to_string(event.target));\n        write_string(event.keyspace);\n        switch (event.target) {\n        case event::schema_change::target_type::KEYSPACE:\n            break;\n        case event::schema_change::target_type::TYPE:\n        case event::schema_change::target_type::TABLE:\n            write_string(event.arguments[0]);\n            break;\n        case event::schema_change::target_type::FUNCTION:\n        case event::schema_change::target_type::AGGREGATE:\n            write_string(event.arguments[0]);\n            write_string_list(std::vector<sstring>(event.arguments.begin() + 1, event.arguments.end()));\n            break;\n        }\n    } else {\n        switch (event.target) {\n        // FIXME: Should we handle FUNCTION and AGGREGATE the same way as type?\n        // FIXME: How do we get here? Can a client using v2 know about UDF?\n        case event::schema_change::target_type::TYPE:\n        case event::schema_change::target_type::FUNCTION:\n        case event::schema_change::target_type::AGGREGATE:\n            // The v1/v2 protocol is unable to represent these changes. Tell the\n            // client that the keyspace was updated instead.\n            write_string(to_string(event::schema_change::change_type::UPDATED));\n            write_string(event.keyspace);\n            write_string(\"\");\n            break;\n        case event::schema_change::target_type::TABLE:\n        case event::schema_change::target_type::KEYSPACE:\n            write_string(to_string(event.change));\n            write_string(event.keyspace);\n            if (event.target == event::schema_change::target_type::TABLE) {\n                write_string(event.arguments[0]);\n            } else {\n                write_string(\"\");\n            }\n        }\n    }\n}\n\nvoid cql_server::response::write_byte(uint8_t b)\n{\n    auto s = reinterpret_cast<const int8_t*>(&b);\n    _body.write(bytes_view(s, sizeof(b)));\n}\n\nvoid cql_server::response::write_int(int32_t n)\n{\n    auto u = htonl(n);\n    auto *s = reinterpret_cast<const int8_t*>(&u);\n    _body.write(bytes_view(s, sizeof(u)));\n}\n\ncql_server::response::placeholder<int32_t> cql_server::response::write_int_placeholder() {\n    return placeholder<int32_t>(_body.write_place_holder(sizeof(int32_t)));\n}\n\nvoid cql_server::response::write_long(int64_t n)\n{\n    auto u = htonq(n);\n    auto *s = reinterpret_cast<const int8_t*>(&u);\n    _body.write(bytes_view(s, sizeof(u)));\n}\n\nvoid cql_server::response::write_short(uint16_t n)\n{\n    auto u = htons(n);\n    auto *s = reinterpret_cast<const int8_t*>(&u);\n    _body.write(bytes_view(s, sizeof(u)));\n}\n\ntemplate<typename T>\ninline\nT cast_if_fits(size_t v) {\n    size_t max = std::numeric_limits<T>::max();\n    if (v > max) {\n        throw std::runtime_error(format(\"Value too large, {:d} > {:d}\", v, max));\n    }\n    return static_cast<T>(v);\n}\n\nvoid cql_server::response::write_string(std::string_view s)\n{\n    write_short(cast_if_fits<uint16_t>(s.size()));\n    _body.write(bytes_view(reinterpret_cast<const int8_t*>(s.data()), s.size()));\n}\n\nvoid cql_server::response::write_bytes_as_string(bytes_view s)\n{\n    write_short(cast_if_fits<uint16_t>(s.size()));\n    _body.write(s);\n}\n\nvoid cql_server::response::write_long_string(const sstring& s)\n{\n    write_int(cast_if_fits<int32_t>(s.size()));\n    _body.write(bytes_view(reinterpret_cast<const int8_t*>(s.data()), s.size()));\n}\n\nvoid cql_server::response::write_string_list(std::vector<sstring> string_list)\n{\n    write_short(cast_if_fits<uint16_t>(string_list.size()));\n    for (auto&& s : string_list) {\n        write_string(s);\n    }\n}\n\nvoid cql_server::response::write_bytes(bytes b)\n{\n    write_int(cast_if_fits<int32_t>(b.size()));\n    _body.write(b);\n}\n\nvoid cql_server::response::write_short_bytes(bytes b)\n{\n    write_short(cast_if_fits<uint16_t>(b.size()));\n    _body.write(b);\n}\n\nvoid cql_server::response::write_inet(socket_address inet)\n{\n    auto addr = inet.addr();\n    write_byte(uint8_t(addr.size()));\n    auto * p = static_cast<const int8_t*>(addr.data());\n    _body.write(bytes_view(p, addr.size()));\n    write_int(inet.port());\n}\n\nvoid cql_server::response::write_consistency(db::consistency_level c)\n{\n    write_short(consistency_to_wire(c));\n}\n\nvoid cql_server::response::write_string_map(std::map<sstring, sstring> string_map)\n{\n    write_short(cast_if_fits<uint16_t>(string_map.size()));\n    for (auto&& s : string_map) {\n        write_string(s.first);\n        write_string(s.second);\n    }\n}\n\nvoid cql_server::response::write_string_multimap(std::multimap<sstring, sstring> string_map)\n{\n    std::vector<sstring> keys;\n    for (auto it = string_map.begin(), end = string_map.end(); it != end; it = string_map.upper_bound(it->first)) {\n        keys.push_back(it->first);\n    }\n    write_short(cast_if_fits<uint16_t>(keys.size()));\n    for (auto&& key : keys) {\n        std::vector<sstring> values;\n        auto range = string_map.equal_range(key);\n        for (auto it = range.first; it != range.second; ++it) {\n            values.push_back(it->second);\n        }\n        write_string(key);\n        write_string_list(values);\n    }\n}\n\nvoid cql_server::response::write_value(bytes_opt value)\n{\n    if (!value) {\n        write_int(-1);\n        return;\n    }\n\n    write_int(value->size());\n    _body.write(*value);\n}\n\nvoid cql_server::response::write_value(std::optional<query::result_bytes_view> value)\n{\n    if (!value) {\n        write_int(-1);\n        return;\n    }\n\n    write_int(value->size_bytes());\n    using boost::range::for_each;\n    for_each(*value, [&] (bytes_view fragment) {\n        _body.write(fragment);\n    });\n}\n\nclass type_codec {\nprivate:\n    enum class type_id : int16_t {\n        CUSTOM    = 0x0000,\n        ASCII     = 0x0001,\n        BIGINT    = 0x0002,\n        BLOB      = 0x0003,\n        BOOLEAN   = 0x0004,\n        COUNTER   = 0x0005,\n        DECIMAL   = 0x0006,\n        DOUBLE    = 0x0007,\n        FLOAT     = 0x0008,\n        INT       = 0x0009,\n        TIMESTAMP = 0x000B,\n        UUID      = 0x000C,\n        VARCHAR   = 0x000D,\n        VARINT    = 0x000E,\n        TIMEUUID  = 0x000F,\n        INET      = 0x0010,\n        DATE      = 0x0011,\n        TIME      = 0x0012,\n        SMALLINT  = 0x0013,\n        TINYINT   = 0x0014,\n        DURATION  = 0x0015,\n        LIST      = 0x0020,\n        MAP       = 0x0021,\n        SET       = 0x0022,\n        UDT       = 0x0030,\n        TUPLE     = 0x0031,\n    };\n\n    using type_id_to_type_type = std::unordered_map<data_type, type_id>;\n\n    static thread_local const type_id_to_type_type type_id_to_type;\npublic:\n    static void encode(cql_server::response& r, data_type type) {\n        type = type->underlying_type();\n\n        // For compatibility sake, we still return DateType as the timestamp type in resultSet metadata (#5723)\n        if (type == date_type) {\n            type = timestamp_type;\n        }\n\n        auto i = type_id_to_type.find(type);\n        if (i != type_id_to_type.end()) {\n            r.write_short(static_cast<std::underlying_type<type_id>::type>(i->second));\n            return;\n        }\n\n        if (type->is_reversed()) {\n            fail(unimplemented::cause::REVERSED);\n        }\n        if (type->is_user_type()) {\n            r.write_short(uint16_t(type_id::UDT));\n            auto udt = static_pointer_cast<const user_type_impl>(type);\n            r.write_string(udt->_keyspace);\n            r.write_bytes_as_string(udt->_name);\n            r.write_short(udt->size());\n            for (auto&& i : boost::irange<size_t>(0, udt->size())) {\n                r.write_bytes_as_string(udt->field_name(i));\n                encode(r, udt->field_type(i));\n            }\n            return;\n        }\n        if (type->is_tuple()) {\n            r.write_short(uint16_t(type_id::TUPLE));\n            auto ttype = static_pointer_cast<const tuple_type_impl>(type);\n            r.write_short(ttype->size());\n            for (auto&& t : ttype->all_types()) {\n                encode(r, t);\n            }\n            return;\n        }\n        if (type->is_collection()) {\n            auto&& ctype = static_cast<const collection_type_impl*>(type.get());\n            if (ctype->get_kind() == abstract_type::kind::map) {\n                r.write_short(uint16_t(type_id::MAP));\n                auto&& mtype = static_cast<const map_type_impl*>(ctype);\n                encode(r, mtype->get_keys_type());\n                encode(r, mtype->get_values_type());\n            } else if (ctype->get_kind() == abstract_type::kind::set) {\n                r.write_short(uint16_t(type_id::SET));\n                auto&& stype = static_cast<const set_type_impl*>(ctype);\n                encode(r, stype->get_elements_type());\n            } else if (ctype->get_kind() == abstract_type::kind::list) {\n                r.write_short(uint16_t(type_id::LIST));\n                auto&& ltype = static_cast<const list_type_impl*>(ctype);\n                encode(r, ltype->get_elements_type());\n            } else {\n                abort();\n            }\n            return;\n        }\n        abort();\n    }\n};\n\nthread_local const type_codec::type_id_to_type_type type_codec::type_id_to_type {\n    { ascii_type, type_id::ASCII },\n    { long_type, type_id::BIGINT },\n    { bytes_type, type_id::BLOB },\n    { boolean_type, type_id::BOOLEAN },\n    { counter_type, type_id::COUNTER },\n    { decimal_type, type_id::DECIMAL },\n    { double_type, type_id::DOUBLE },\n    { float_type, type_id::FLOAT },\n    { int32_type, type_id::INT },\n    { byte_type, type_id::TINYINT },\n    { duration_type, type_id::DURATION },\n    { short_type, type_id::SMALLINT },\n    { timestamp_type, type_id::TIMESTAMP },\n    { uuid_type, type_id::UUID },\n    { utf8_type, type_id::VARCHAR },\n    { varint_type, type_id::VARINT },\n    { timeuuid_type, type_id::TIMEUUID },\n    { simple_date_type, type_id::DATE },\n    { time_type, type_id::TIME },\n    { inet_addr_type, type_id::INET },\n};\n\nvoid cql_server::response::write(const cql3::metadata& m, bool no_metadata) {\n    auto flags = m.flags();\n    bool global_tables_spec = m.flags().contains<cql3::metadata::flag::GLOBAL_TABLES_SPEC>();\n    bool has_more_pages = m.flags().contains<cql3::metadata::flag::HAS_MORE_PAGES>();\n\n    if (no_metadata) {\n        flags.set<cql3::metadata::flag::NO_METADATA>();\n    }\n\n    write_int(flags.mask());\n    write_int(m.column_count());\n\n    if (has_more_pages) {\n        write_value(m.paging_state()->serialize());\n    }\n\n    if (no_metadata) {\n        return;\n    }\n\n    auto names_i = m.get_names().begin();\n\n    if (global_tables_spec) {\n        auto first_spec = *names_i;\n        write_string(first_spec->ks_name);\n        write_string(first_spec->cf_name);\n    }\n\n    for (uint32_t i = 0; i < m.column_count(); ++i, ++names_i) {\n        lw_shared_ptr<cql3::column_specification> name = *names_i;\n        if (!global_tables_spec) {\n            write_string(name->ks_name);\n            write_string(name->cf_name);\n        }\n        write_string(name->name->text());\n        type_codec::encode(*this, name->type);\n    }\n}\n\nvoid cql_server::response::write(const cql3::prepared_metadata& m, uint8_t version)\n{\n    bool global_tables_spec = m.flags().contains<cql3::prepared_metadata::flag::GLOBAL_TABLES_SPEC>();\n\n    write_int(m.flags().mask());\n    write_int(m.names().size());\n\n    if (version >= 4) {\n        if (!global_tables_spec) {\n            write_int(0);\n        } else {\n            write_int(m.partition_key_bind_indices().size());\n            for (uint16_t bind_index : m.partition_key_bind_indices()) {\n                write_short(bind_index);\n            }\n        }\n    }\n\n    if (global_tables_spec) {\n        write_string(m.names()[0]->ks_name);\n        write_string(m.names()[0]->cf_name);\n    }\n\n    for (auto const& name : m.names()) {\n        if (!global_tables_spec) {\n            write_string(name->ks_name);\n            write_string(name->cf_name);\n        }\n        write_string(name->name->text());\n        type_codec::encode(*this, name->type);\n    }\n}\n\nfuture<utils::chunked_vector<client_data>> cql_server::get_client_data() {\n    utils::chunked_vector<client_data> ret;\n    co_await for_each_gently([&ret] (const generic_server::connection& c) {\n        const connection& conn = dynamic_cast<const connection&>(c);\n        ret.emplace_back(conn.make_client_data());\n    });\n    co_return ret;\n}\n\n}\n"], "filenames": ["transport/server.cc"], "buggy_code_start_loc": [730], "buggy_code_end_loc": [731], "fixing_code_start_loc": [730], "fixing_code_end_loc": [734], "type": "CWE-908", "message": "Scylla is a real-time big data database that is API-compatible with Apache Cassandra and Amazon DynamoDB. When decompressing CQL frame received from user, Scylla assumes that user-provided uncompressed length is correct. If user provides fake length, that is greater than the real one, part of decompression buffer won't be overwritten, and will be left uninitialized. This can be exploited in several ways, depending on the privileges of the user. 1. The main exploit is that an attacker with access to CQL port, but no user account, can bypass authentication, but only if there are other legitimate clients making connections to the cluster, and they use LZ4. 2. Attacker that already has a user account on the cluster can read parts of uninitialized memory, which can contain things like passwords of other users or fragments of other queries / results, which leads to authorization bypass and sensitive information disclosure. The bug has been patched in the following versions: Scylla Enterprise: 2020.1.14, 2021.1.12, 2022.1.0. Scylla Open Source: 4.6.7, 5.0.3. Users unable to upgrade should make sure none of their drivers connect to cluster using LZ4 compression, and that Scylla CQL port is behind firewall. Additionally make sure no untrusted client can connect to Scylla, by setting up authentication and applying workarounds from previous point (firewall, no lz4 compression).", "other": {"cve": {"id": "CVE-2022-29240", "sourceIdentifier": "security-advisories@github.com", "published": "2022-09-15T22:15:11.220", "lastModified": "2022-09-21T14:17:44.350", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Scylla is a real-time big data database that is API-compatible with Apache Cassandra and Amazon DynamoDB. When decompressing CQL frame received from user, Scylla assumes that user-provided uncompressed length is correct. If user provides fake length, that is greater than the real one, part of decompression buffer won't be overwritten, and will be left uninitialized. This can be exploited in several ways, depending on the privileges of the user. 1. The main exploit is that an attacker with access to CQL port, but no user account, can bypass authentication, but only if there are other legitimate clients making connections to the cluster, and they use LZ4. 2. Attacker that already has a user account on the cluster can read parts of uninitialized memory, which can contain things like passwords of other users or fragments of other queries / results, which leads to authorization bypass and sensitive information disclosure. The bug has been patched in the following versions: Scylla Enterprise: 2020.1.14, 2021.1.12, 2022.1.0. Scylla Open Source: 4.6.7, 5.0.3. Users unable to upgrade should make sure none of their drivers connect to cluster using LZ4 compression, and that Scylla CQL port is behind firewall. Additionally make sure no untrusted client can connect to Scylla, by setting up authentication and applying workarounds from previous point (firewall, no lz4 compression)."}, {"lang": "es", "value": "Scylla es una base de datos de big data en tiempo real que es compatible con la API de Apache Cassandra y Amazon DynamoDB. Cuando es descomprimida la trama CQL recibida del usuario, Scylla asume que la longitud sin comprimir proporcionada por el usuario es correcta. Si el usuario proporciona una longitud falsa, que es mayor que la real, parte del b\u00fafer de descompresi\u00f3n no ser\u00e1 sobrescrita, y ser\u00e1 dejada sin inicializar. Esto puede ser explotado de varias maneras, dependiendo de los privilegios del usuario. 1. La principal explotaci\u00f3n es que un atacante con acceso al puerto CQL, pero sin cuenta de usuario, puede omitir la autenticaci\u00f3n, pero s\u00f3lo si se presentan otros clientes leg\u00edtimos haciendo conexiones al cl\u00faster, y usan LZ4. 2. El atacante que ya presenta una cuenta de usuario en el cl\u00faster puede leer partes de la memoria no inicializada, que pueden contener cosas como contrase\u00f1as de otros usuarios o fragmentos de otras consultas/resultados, lo que conlleva a omitir la autorizaci\u00f3n y revelar informaci\u00f3n confidencial. El bug ha sido parcheado en las siguientes versiones: Scylla Enterprise: 2020.1.14, 2021.1.12, 2022.1.0. Scylla Open Source: 4.6.7, 5.0.3. Los usuarios que no puedan actualizar deben asegurarse de que ninguno de sus controladores sean conectados al cl\u00faster usando la compresi\u00f3n LZ4, y que el puerto CQL de Scylla est\u00e1 detr\u00e1s del firewall. Adem\u00e1s, aseg\u00farese de que ning\u00fan cliente no confiable pueda conectarse a Scylla, al configurar la autenticaci\u00f3n y aplicando las mitigaciones del punto anterior (firewall, sin compresi\u00f3n LZ4)"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-908"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:scylladb:scylla:*:*:*:*:open_source:*:*:*", "versionEndExcluding": "4.6.7", "matchCriteriaId": "62049391-A8C3-4963-B692-B9D0EBD24754"}, {"vulnerable": true, "criteria": "cpe:2.3:a:scylladb:scylla:*:*:*:*:enterprise:*:*:*", "versionEndExcluding": "2020.1.14", "matchCriteriaId": "3D30E6EF-8EDA-467A-B467-0DD00916F5BE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:scylladb:scylla:*:*:*:*:open_source:*:*:*", "versionStartIncluding": "5.0.0", "versionEndExcluding": "5.0.3", "matchCriteriaId": "3BD1B169-D009-459A-AA09-60835C7712EA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:scylladb:scylla:*:*:*:*:enterprise:*:*:*", "versionStartIncluding": "2021.1.0", "versionEndExcluding": "2021.1.12", "matchCriteriaId": "25942345-FCBA-4788-B0CA-4E6C247C9862"}]}]}], "references": [{"url": "https://github.com/scylladb/scylla/security/advisories/GHSA-25pq-rrqm-6fmr", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/scylladb/scylladb/commit/1c2eef384da439b0457b6d71c7e37d7268e471cb", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/scylladb/scylladb/issues/11476", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/scylladb/scylladb/commit/1c2eef384da439b0457b6d71c7e37d7268e471cb"}}