{"buggy_code": ["/*\n * irc-ctcp.c - IRC CTCP protocol\n *\n * Copyright (C) 2003-2017 S\u00e9bastien Helleu <flashcode@flashtux.org>\n *\n * This file is part of WeeChat, the extensible chat client.\n *\n * WeeChat is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * WeeChat is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with WeeChat.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/time.h>\n#include <time.h>\n#include <sys/utsname.h>\n#include <locale.h>\n\n#include \"../weechat-plugin.h\"\n#include \"irc.h\"\n#include \"irc-ctcp.h\"\n#include \"irc-channel.h\"\n#include \"irc-color.h\"\n#include \"irc-config.h\"\n#include \"irc-msgbuffer.h\"\n#include \"irc-nick.h\"\n#include \"irc-protocol.h\"\n#include \"irc-server.h\"\n\n\nstruct t_irc_ctcp_reply irc_ctcp_default_reply[] =\n{ { \"clientinfo\", \"$clientinfo\" },\n  { \"finger\",     \"WeeChat $versiongit\" },\n  { \"source\",     \"$download\" },\n  { \"time\",       \"$time\" },\n  { \"userinfo\",   \"$username ($realname)\" },\n  { \"version\",    \"WeeChat $versiongit ($compilation)\" },\n  { NULL,         NULL },\n};\n\n\n/*\n * Gets default reply for a CTCP query.\n *\n * Returns NULL if CTCP is unknown.\n */\n\nconst char *\nirc_ctcp_get_default_reply (const char *ctcp)\n{\n    int i;\n\n    for (i = 0; irc_ctcp_default_reply[i].name; i++)\n    {\n        if (weechat_strcasecmp (irc_ctcp_default_reply[i].name, ctcp) == 0)\n            return irc_ctcp_default_reply[i].reply;\n    }\n\n    /* unknown CTCP */\n    return NULL;\n}\n\n/*\n * Gets reply for a CTCP query.\n */\n\nconst char *\nirc_ctcp_get_reply (struct t_irc_server *server, const char *ctcp)\n{\n    struct t_config_option *ptr_option;\n    char option_name[512];\n\n    snprintf (option_name, sizeof (option_name), \"%s.%s\", server->name, ctcp);\n\n    /* search for CTCP in configuration file, for server */\n    ptr_option = weechat_config_search_option (irc_config_file,\n                                               irc_config_section_ctcp,\n                                               option_name);\n    if (ptr_option)\n        return weechat_config_string (ptr_option);\n\n    /* search for CTCP in configuration file */\n    ptr_option = weechat_config_search_option (irc_config_file,\n                                               irc_config_section_ctcp,\n                                               ctcp);\n    if (ptr_option)\n        return weechat_config_string (ptr_option);\n\n    /*\n     * no CTCP reply found in config, then return default reply, or NULL\n     * for unknown CTCP\n     */\n    return irc_ctcp_get_default_reply (ctcp);\n}\n\n/*\n * Displays CTCP requested by a nick.\n */\n\nvoid\nirc_ctcp_display_request (struct t_irc_server *server,\n                          time_t date,\n                          const char *command,\n                          struct t_irc_channel *channel,\n                          const char *nick,\n                          const char *address,\n                          const char *ctcp,\n                          const char *arguments,\n                          const char *reply)\n{\n    /* CTCP blocked and user doesn't want to see message? then just return */\n    if (reply && !reply[0]\n        && !weechat_config_boolean (irc_config_look_display_ctcp_blocked))\n        return;\n\n    weechat_printf_date_tags (\n        irc_msgbuffer_get_target_buffer (\n            server, nick, NULL, \"ctcp\",\n            (channel) ? channel->buffer : NULL),\n        date,\n        irc_protocol_tags (command, \"irc_ctcp\", NULL, address),\n        _(\"%sCTCP requested by %s%s%s: %s%s%s%s%s%s\"),\n        weechat_prefix (\"network\"),\n        irc_nick_color_for_msg (server, 0, NULL, nick),\n        nick,\n        IRC_COLOR_RESET,\n        IRC_COLOR_CHAT_CHANNEL,\n        ctcp,\n        IRC_COLOR_RESET,\n        (arguments) ? \" \" : \"\",\n        (arguments) ? arguments : \"\",\n        (reply && !reply[0]) ? _(\" (blocked)\") : \"\");\n}\n\n/*\n * Displays reply from a nick to a CTCP query.\n */\n\nvoid\nirc_ctcp_display_reply_from_nick (struct t_irc_server *server, time_t date,\n                                  const char *command, const char *nick,\n                                  const char *address, char *arguments)\n{\n    char *pos_end, *pos_space, *pos_args, *pos_usec;\n    struct timeval tv;\n    long sec1, usec1, sec2, usec2, difftime;\n\n    while (arguments && arguments[0])\n    {\n        pos_end = strrchr (arguments + 1, '\\01');\n        if (pos_end)\n            pos_end[0] = '\\0';\n\n        pos_space = strchr (arguments + 1, ' ');\n        if (pos_space)\n        {\n            pos_space[0] = '\\0';\n            pos_args = pos_space + 1;\n            while (pos_args[0] == ' ')\n            {\n                pos_args++;\n            }\n            if (strcmp (arguments + 1, \"PING\") == 0)\n            {\n                pos_usec = strchr (pos_args, ' ');\n                if (pos_usec)\n                {\n                    pos_usec[0] = '\\0';\n\n                    gettimeofday (&tv, NULL);\n                    sec1 = atol (pos_args);\n                    usec1 = atol (pos_usec + 1);\n                    sec2 = tv.tv_sec;\n                    usec2 = tv.tv_usec;\n\n                    difftime = ((sec2 * 1000000) + usec2) -\n                        ((sec1 * 1000000) + usec1);\n                    weechat_printf_date_tags (\n                        irc_msgbuffer_get_target_buffer (\n                            server, nick, NULL, \"ctcp\", NULL),\n                        date,\n                        irc_protocol_tags (command, \"irc_ctcp\", NULL, NULL),\n                        /* TRANSLATORS: %.3fs is a float number + \"s\" (\"seconds\") */\n                        _(\"%sCTCP reply from %s%s%s: %s%s%s %.3fs\"),\n                        weechat_prefix (\"network\"),\n                        irc_nick_color_for_msg (server, 0, NULL, nick),\n                        nick,\n                        IRC_COLOR_RESET,\n                        IRC_COLOR_CHAT_CHANNEL,\n                        arguments + 1,\n                        IRC_COLOR_RESET,\n                        (float)difftime / 1000000.0);\n\n                    pos_usec[0] = ' ';\n                }\n            }\n            else\n            {\n                weechat_printf_date_tags (\n                    irc_msgbuffer_get_target_buffer (\n                        server, nick, NULL, \"ctcp\", NULL),\n                    date,\n                    irc_protocol_tags (command, \"irc_ctcp\", NULL, address),\n                    _(\"%sCTCP reply from %s%s%s: %s%s%s%s%s\"),\n                    weechat_prefix (\"network\"),\n                    irc_nick_color_for_msg (server, 0, NULL, nick),\n                    nick,\n                    IRC_COLOR_RESET,\n                    IRC_COLOR_CHAT_CHANNEL,\n                    arguments + 1,\n                    IRC_COLOR_RESET,\n                    \" \",\n                    pos_args);\n            }\n            pos_space[0] = ' ';\n        }\n        else\n        {\n            weechat_printf_date_tags (\n                irc_msgbuffer_get_target_buffer (\n                    server, nick, NULL, \"ctcp\", NULL),\n                date,\n                irc_protocol_tags (command, NULL, NULL, address),\n                _(\"%sCTCP reply from %s%s%s: %s%s%s%s%s\"),\n                weechat_prefix (\"network\"),\n                irc_nick_color_for_msg (server, 0, NULL, nick),\n                nick,\n                IRC_COLOR_RESET,\n                IRC_COLOR_CHAT_CHANNEL,\n                arguments + 1,\n                \"\",\n                \"\",\n                \"\");\n        }\n\n        if (pos_end)\n            pos_end[0] = '\\01';\n\n        arguments = (pos_end) ? pos_end + 1 : NULL;\n    }\n}\n\n/*\n * Displays CTCP replied to a nick.\n */\n\nvoid\nirc_ctcp_reply_to_nick (struct t_irc_server *server,\n                        const char *command,\n                        struct t_irc_channel *channel,\n                        const char *nick, const char *ctcp,\n                        const char *arguments)\n{\n    struct t_hashtable *hashtable;\n    int number;\n    char hash_key[32];\n    const char *str_args;\n    char *str_args_color;\n\n    hashtable = irc_server_sendf (\n        server,\n        IRC_SERVER_SEND_OUTQ_PRIO_LOW | IRC_SERVER_SEND_RETURN_HASHTABLE,\n        NULL,\n        \"NOTICE %s :\\01%s%s%s\\01\",\n        nick, ctcp,\n        (arguments) ? \" \" : \"\",\n        (arguments) ? arguments : \"\");\n\n    if (hashtable)\n    {\n        if (weechat_config_boolean (irc_config_look_display_ctcp_reply))\n        {\n            number = 1;\n            while (1)\n            {\n                snprintf (hash_key, sizeof (hash_key), \"args%d\", number);\n                str_args = weechat_hashtable_get (hashtable, hash_key);\n                if (!str_args)\n                    break;\n                str_args_color = irc_color_decode (str_args, 1);\n                if (!str_args_color)\n                    break;\n                weechat_printf_date_tags (\n                    irc_msgbuffer_get_target_buffer (\n                        server, nick, NULL, \"ctcp\",\n                        (channel) ? channel->buffer : NULL),\n                    0,\n                    irc_protocol_tags (\n                        command,\n                        \"irc_ctcp,irc_ctcp_reply,self_msg,notify_none,\"\n                        \"no_highlight\",\n                        NULL, NULL),\n                    _(\"%sCTCP reply to %s%s%s: %s%s%s%s%s\"),\n                    weechat_prefix (\"network\"),\n                    irc_nick_color_for_msg (server, 0, NULL, nick),\n                    nick,\n                    IRC_COLOR_RESET,\n                    IRC_COLOR_CHAT_CHANNEL,\n                    ctcp,\n                    (str_args_color[0]) ? IRC_COLOR_RESET : \"\",\n                    (str_args_color[0]) ? \" \" : \"\",\n                    str_args_color);\n                free (str_args_color);\n                number++;\n            }\n        }\n        weechat_hashtable_free (hashtable);\n    }\n}\n\n/*\n * Replaces variables in CTCP format.\n *\n * Note: result must be freed after use.\n */\n\nchar *\nirc_ctcp_replace_variables (struct t_irc_server *server, const char *format)\n{\n    char *res, *temp, *username, *realname;\n    const char *info;\n    time_t now;\n    struct tm *local_time;\n    char buf[1024];\n    struct utsname *buf_uname;\n\n    /*\n     * $clientinfo: supported CTCP, example:\n     *   ACTION DCC CLIENTINFO FINGER PING SOURCE TIME USERINFO VERSION\n     */\n    temp = weechat_string_replace (\n        format, \"$clientinfo\",\n        \"ACTION DCC CLIENTINFO FINGER PING SOURCE TIME USERINFO VERSION\");\n    if (!temp)\n        return NULL;\n    res = temp;\n\n    /*\n     * $git: git version (output of \"git describe\" for a development version\n     * only, empty string if unknown), example:\n     *   v0.3.9-104-g7eb5cc4\n     */\n    info = weechat_info_get (\"version_git\", \"\");\n    temp = weechat_string_replace (res, \"$git\", info);\n    free (res);\n    if (!temp)\n        return NULL;\n    res = temp;\n\n    /*\n     * $versiongit: WeeChat version + git version (if known), examples:\n     *   0.3.9\n     *   0.4.0-dev\n     *   0.4.0-dev (git: v0.3.9-104-g7eb5cc4)\n     */\n    info = weechat_info_get (\"version_git\", \"\");\n    snprintf (buf, sizeof (buf), \"%s%s%s%s\",\n              weechat_info_get (\"version\", \"\"),\n              (info && info[0]) ? \" (git: \" : \"\",\n              (info && info[0]) ? info : \"\",\n              (info && info[0]) ? \")\" : \"\");\n    temp = weechat_string_replace (res, \"$versiongit\", buf);\n    free (res);\n    if (!temp)\n        return NULL;\n    res = temp;\n\n    /*\n     * $version: WeeChat version, examples:\n     *   0.3.9\n     *   0.4.0-dev\n     */\n    info = weechat_info_get (\"version\", \"\");\n    temp = weechat_string_replace (res, \"$version\", info);\n    free (res);\n    if (!temp)\n        return NULL;\n    res = temp;\n\n    /*\n     * $compilation: compilation date, example:\n     *   Dec 16 2012\n     */\n    info = weechat_info_get (\"date\", \"\");\n    temp = weechat_string_replace (res, \"$compilation\", info);\n    free (res);\n    if (!temp)\n        return NULL;\n    res = temp;\n\n    /*\n     * $osinfo: info about OS, example:\n     *   Linux 2.6.32-5-amd64 / x86_64\n     */\n    buf_uname = (struct utsname *)malloc (sizeof (struct utsname));\n    if (buf_uname)\n    {\n        if (uname (buf_uname) >= 0)\n        {\n            snprintf (buf, sizeof (buf), \"%s %s / %s\",\n                      buf_uname->sysname, buf_uname->release,\n                      buf_uname->machine);\n            temp = weechat_string_replace (res, \"$osinfo\", buf);\n            free (res);\n            if (!temp)\n            {\n                free (buf_uname);\n                return NULL;\n            }\n            res = temp;\n        }\n        free (buf_uname);\n    }\n\n    /*\n     * $site: WeeChat web site, example:\n     *   https://weechat.org/\n     */\n    info = weechat_info_get (\"weechat_site\", \"\");\n    temp = weechat_string_replace (res, \"$site\", info);\n    free (res);\n    if (!temp)\n        return NULL;\n    res = temp;\n\n    /*\n     * $download: WeeChat download page, example:\n     *   https://weechat.org/download\n     */\n    info = weechat_info_get (\"weechat_site_download\", \"\");\n    temp = weechat_string_replace (res, \"$download\", info);\n    free (res);\n    if (!temp)\n        return NULL;\n    res = temp;\n\n    /*\n     * $time: local date/time of user, example:\n     *   Sun, 16 Dec 2012 10:40:48 +0100\n     */\n    now = time (NULL);\n    local_time = localtime (&now);\n    setlocale (LC_ALL, \"C\");\n    strftime (buf, sizeof (buf),\n              weechat_config_string (irc_config_look_ctcp_time_format),\n              local_time);\n    setlocale (LC_ALL, \"\");\n    temp = weechat_string_replace (res, \"$time\", buf);\n    free (res);\n    if (!temp)\n        return NULL;\n    res = temp;\n\n    /*\n     * $username: user name, example:\n     *   name\n     */\n    username = weechat_string_eval_expression (\n        IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_USERNAME),\n        NULL, NULL, NULL);\n    if (username)\n    {\n        temp = weechat_string_replace (res, \"$username\", username);\n        free (res);\n        if (!temp)\n            return NULL;\n        res = temp;\n        free (username);\n    }\n\n    /*\n     * $realname: real name, example:\n     *   John doe\n     */\n    realname = weechat_string_eval_expression (\n        IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_REALNAME),\n        NULL, NULL, NULL);\n    if (realname)\n    {\n        temp = weechat_string_replace (res, \"$realname\", realname);\n        free (res);\n        if (!temp)\n            return NULL;\n        res = temp;\n        free (realname);\n    }\n\n    /* return result */\n    return res;\n}\n\n/*\n * Returns filename for DCC, without double quotes.\n *\n * Note: result must be freed after use.\n */\n\nchar *\nirc_ctcp_dcc_filename_without_quotes (const char *filename)\n{\n    int length;\n\n    length = strlen (filename);\n    if (length > 0)\n    {\n        if ((filename[0] == '\\\"') && (filename[length - 1] == '\\\"'))\n            return weechat_strndup (filename + 1, length - 2);\n    }\n    return strdup (filename);\n}\n\n/*\n * Parses CTCP DCC.\n */\n\nvoid\nirc_ctcp_recv_dcc (struct t_irc_server *server, const char *nick,\n                   const char *arguments, char *message)\n{\n    char *dcc_args, *pos, *pos_file, *pos_addr, *pos_port, *pos_size;\n    char *pos_start_resume, *filename;\n    struct t_infolist *infolist;\n    struct t_infolist_item *item;\n    char charset_modifier[256];\n\n    if (!arguments || !arguments[0])\n        return;\n\n    if (strncmp (arguments, \"SEND \", 5) == 0)\n    {\n        arguments += 5;\n        while (arguments[0] == ' ')\n        {\n            arguments++;\n        }\n        dcc_args = strdup (arguments);\n\n        if (!dcc_args)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: not enough memory for \\\"%s\\\" command\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME, \"privmsg\");\n            return;\n        }\n\n        /* DCC filename */\n        pos_file = dcc_args;\n        while (pos_file[0] == ' ')\n        {\n            pos_file++;\n        }\n\n        /* look for file size */\n        pos_size = strrchr (pos_file, ' ');\n        if (!pos_size)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: cannot parse \\\"%s\\\" command\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME, \"privmsg\");\n            free (dcc_args);\n            return;\n        }\n\n        pos = pos_size;\n        pos_size++;\n        while (pos[0] == ' ')\n        {\n            pos--;\n        }\n        pos[1] = '\\0';\n\n        /* look for DCC port */\n        pos_port = strrchr (pos_file, ' ');\n        if (!pos_port)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: cannot parse \\\"%s\\\" command\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME, \"privmsg\");\n            free (dcc_args);\n            return;\n        }\n\n        pos = pos_port;\n        pos_port++;\n        while (pos[0] == ' ')\n        {\n            pos--;\n        }\n        pos[1] = '\\0';\n\n        /* look for DCC IP address */\n        pos_addr = strrchr (pos_file, ' ');\n        if (!pos_addr)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: cannot parse \\\"%s\\\" command\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME, \"privmsg\");\n            free (dcc_args);\n            return;\n        }\n\n        pos = pos_addr;\n        pos_addr++;\n        while (pos[0] == ' ')\n        {\n            pos--;\n        }\n        pos[1] = '\\0';\n\n        /* remove double quotes around filename */\n        filename = irc_ctcp_dcc_filename_without_quotes (pos_file);\n\n        /* add DCC file via xfer plugin */\n        infolist = weechat_infolist_new ();\n        if (infolist)\n        {\n            item = weechat_infolist_new_item (infolist);\n            if (item)\n            {\n                weechat_infolist_new_var_string (item, \"plugin_name\", weechat_plugin->name);\n                weechat_infolist_new_var_string (item, \"plugin_id\", server->name);\n                weechat_infolist_new_var_string (item, \"type_string\", \"file_recv\");\n                weechat_infolist_new_var_string (item, \"protocol_string\", \"dcc\");\n                weechat_infolist_new_var_string (item, \"remote_nick\", nick);\n                weechat_infolist_new_var_string (item, \"local_nick\", server->nick);\n                weechat_infolist_new_var_string (item, \"filename\",\n                                                 (filename) ? filename : pos_file);\n                weechat_infolist_new_var_string (item, \"size\", pos_size);\n                weechat_infolist_new_var_string (item, \"proxy\",\n                                                 IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_PROXY));\n                weechat_infolist_new_var_string (item, \"remote_address\", pos_addr);\n                weechat_infolist_new_var_integer (item, \"port\", atoi (pos_port));\n                (void) weechat_hook_signal_send (\"xfer_add\",\n                                                 WEECHAT_HOOK_SIGNAL_POINTER,\n                                                 infolist);\n            }\n            weechat_infolist_free (infolist);\n        }\n\n        (void) weechat_hook_signal_send (\"irc_dcc\",\n                                         WEECHAT_HOOK_SIGNAL_STRING,\n                                         message);\n\n        if (filename)\n            free (filename);\n\n        free (dcc_args);\n    }\n    else if (strncmp (arguments, \"RESUME \", 7) == 0)\n    {\n        arguments += 7;\n        while (arguments[0] == ' ')\n        {\n            arguments++;\n        }\n        dcc_args = strdup (arguments);\n\n        if (!dcc_args)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: not enough memory for \\\"%s\\\" command\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME, \"privmsg\");\n            return;\n        }\n\n        /* DCC filename */\n        pos_file = dcc_args;\n        while (pos_file[0] == ' ')\n        {\n            pos_file++;\n        }\n\n        /* look for resume start position */\n        pos_start_resume = strrchr (pos_file, ' ');\n        if (!pos_start_resume)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: cannot parse \\\"%s\\\" command\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME, \"privmsg\");\n            free (dcc_args);\n            return;\n        }\n        pos = pos_start_resume;\n        pos_start_resume++;\n        while (pos[0] == ' ')\n        {\n            pos--;\n        }\n        pos[1] = '\\0';\n\n        /* look for DCC port */\n        pos_port = strrchr (pos_file, ' ');\n        if (!pos_port)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: cannot parse \\\"%s\\\" command\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME, \"privmsg\");\n            free (dcc_args);\n            return;\n        }\n        pos = pos_port;\n        pos_port++;\n        while (pos[0] == ' ')\n        {\n            pos--;\n        }\n        pos[1] = '\\0';\n\n        /* remove double quotes around filename */\n        filename = irc_ctcp_dcc_filename_without_quotes (pos_file);\n\n        /* accept resume via xfer plugin */\n        infolist = weechat_infolist_new ();\n        if (infolist)\n        {\n            item = weechat_infolist_new_item (infolist);\n            if (item)\n            {\n                weechat_infolist_new_var_string (item, \"plugin_name\", weechat_plugin->name);\n                weechat_infolist_new_var_string (item, \"plugin_id\", server->name);\n                weechat_infolist_new_var_string (item, \"type_string\", \"file_recv\");\n                weechat_infolist_new_var_string (item, \"filename\",\n                                                 (filename) ? filename : pos_file);\n                weechat_infolist_new_var_integer (item, \"port\", atoi (pos_port));\n                weechat_infolist_new_var_string (item, \"start_resume\", pos_start_resume);\n                (void) weechat_hook_signal_send (\"xfer_accept_resume\",\n                                                 WEECHAT_HOOK_SIGNAL_POINTER,\n                                                 infolist);\n            }\n            weechat_infolist_free (infolist);\n        }\n\n        (void) weechat_hook_signal_send (\"irc_dcc\",\n                                         WEECHAT_HOOK_SIGNAL_STRING,\n                                         message);\n\n        if (filename)\n            free (filename);\n\n        free (dcc_args);\n    }\n    else if (strncmp (arguments, \"ACCEPT \", 7) == 0)\n    {\n        arguments += 7;\n        while (arguments[0] == ' ')\n        {\n            arguments++;\n        }\n        dcc_args = strdup (arguments);\n\n        if (!dcc_args)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: not enough memory for \\\"%s\\\" command\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME, \"privmsg\");\n            return;\n        }\n\n        /* DCC filename */\n        pos_file = dcc_args;\n        while (pos_file[0] == ' ')\n        {\n            pos_file++;\n        }\n\n        /* look for resume start position */\n        pos_start_resume = strrchr (pos_file, ' ');\n        if (!pos_start_resume)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: cannot parse \\\"%s\\\" command\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME, \"privmsg\");\n            free (dcc_args);\n            return;\n        }\n        pos = pos_start_resume;\n        pos_start_resume++;\n        while (pos[0] == ' ')\n        {\n            pos--;\n        }\n        pos[1] = '\\0';\n\n        /* look for DCC port */\n        pos_port = strrchr (pos_file, ' ');\n        if (!pos_port)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: cannot parse \\\"%s\\\" command\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME, \"privmsg\");\n            free (dcc_args);\n            return;\n        }\n        pos = pos_port;\n        pos_port++;\n        while (pos[0] == ' ')\n        {\n            pos--;\n        }\n        pos[1] = '\\0';\n\n        /* remove double quotes around filename */\n        filename = irc_ctcp_dcc_filename_without_quotes (pos_file);\n\n        /* resume file via xfer plugin */\n        infolist = weechat_infolist_new ();\n        if (infolist)\n        {\n            item = weechat_infolist_new_item (infolist);\n            if (item)\n            {\n                weechat_infolist_new_var_string (item, \"plugin_name\", weechat_plugin->name);\n                weechat_infolist_new_var_string (item, \"plugin_id\", server->name);\n                weechat_infolist_new_var_string (item, \"type_string\", \"file_recv\");\n                weechat_infolist_new_var_string (item, \"filename\",\n                                                 (filename) ? filename : pos_file);\n                weechat_infolist_new_var_integer (item, \"port\", atoi (pos_port));\n                weechat_infolist_new_var_string (item, \"start_resume\", pos_start_resume);\n                (void) weechat_hook_signal_send (\"xfer_start_resume\",\n                                                 WEECHAT_HOOK_SIGNAL_POINTER,\n                                                 infolist);\n            }\n            weechat_infolist_free (infolist);\n        }\n\n        (void) weechat_hook_signal_send (\"irc_dcc\",\n                                         WEECHAT_HOOK_SIGNAL_STRING,\n                                         message);\n\n        if (filename)\n            free (filename);\n\n        free (dcc_args);\n    }\n    else if (strncmp (arguments, \"CHAT \", 5) == 0)\n    {\n        arguments += 5;\n        while (arguments[0] == ' ')\n        {\n            arguments++;\n        }\n        dcc_args = strdup (arguments);\n\n        if (!dcc_args)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: not enough memory for \\\"%s\\\" command\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME, \"privmsg\");\n            return;\n        }\n\n        /* CHAT type */\n        pos_file = dcc_args;\n        while (pos_file[0] == ' ')\n        {\n            pos_file++;\n        }\n\n        /* DCC IP address */\n        pos_addr = strchr (pos_file, ' ');\n        if (!pos_addr)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: cannot parse \\\"%s\\\" command\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME, \"privmsg\");\n            free (dcc_args);\n            return;\n        }\n        pos_addr[0] = '\\0';\n        pos_addr++;\n        while (pos_addr[0] == ' ')\n        {\n            pos_addr++;\n        }\n\n        /* look for DCC port */\n        pos_port = strchr (pos_addr, ' ');\n        if (!pos_port)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: cannot parse \\\"%s\\\" command\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME, \"privmsg\");\n            free (dcc_args);\n            return;\n        }\n        pos_port[0] = '\\0';\n        pos_port++;\n        while (pos_port[0] == ' ')\n        {\n            pos_port++;\n        }\n\n        if (weechat_strcasecmp (pos_file, \"chat\") != 0)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: unknown DCC CHAT type received from %s%s%s: \\\"%s\\\"\"),\n                weechat_prefix (\"error\"),\n                IRC_PLUGIN_NAME,\n                irc_nick_color_for_msg (server, 0, NULL, nick),\n                nick,\n                IRC_COLOR_RESET,\n                pos_file);\n            free (dcc_args);\n            return;\n        }\n\n        /* add DCC chat via xfer plugin */\n        infolist = weechat_infolist_new ();\n        if (infolist)\n        {\n            item = weechat_infolist_new_item (infolist);\n            if (item)\n            {\n                weechat_infolist_new_var_string (item, \"plugin_name\", weechat_plugin->name);\n                weechat_infolist_new_var_string (item, \"plugin_id\", server->name);\n                weechat_infolist_new_var_string (item, \"type_string\", \"chat_recv\");\n                weechat_infolist_new_var_string (item, \"remote_nick\", nick);\n                weechat_infolist_new_var_string (item, \"local_nick\", server->nick);\n                snprintf (charset_modifier, sizeof (charset_modifier),\n                          \"irc.%s.%s\", server->name, nick);\n                weechat_infolist_new_var_string (item, \"charset_modifier\", charset_modifier);\n                weechat_infolist_new_var_string (item, \"proxy\",\n                                                 IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_PROXY));\n                weechat_infolist_new_var_string (item, \"remote_address\", pos_addr);\n                weechat_infolist_new_var_integer (item, \"port\", atoi (pos_port));\n                (void) weechat_hook_signal_send (\"xfer_add\",\n                                                 WEECHAT_HOOK_SIGNAL_POINTER,\n                                                 infolist);\n            }\n            weechat_infolist_free (infolist);\n        }\n\n        (void) weechat_hook_signal_send (\"irc_dcc\",\n                                         WEECHAT_HOOK_SIGNAL_STRING,\n                                         message);\n\n        free (dcc_args);\n    }\n}\n\n/*\n * Receives a CTCP and if needed replies to query.\n */\n\nvoid\nirc_ctcp_recv (struct t_irc_server *server, time_t date, const char *command,\n               struct t_irc_channel *channel, const char *address,\n               const char *nick, const char *remote_nick, char *arguments,\n               char *message)\n{\n    char *pos_end, *pos_space, *pos_args;\n    const char *reply;\n    char *decoded_reply;\n    struct t_irc_channel *ptr_channel;\n    struct t_irc_nick *ptr_nick;\n    int nick_is_me;\n\n    while (arguments && arguments[0])\n    {\n        pos_end = strrchr (arguments + 1, '\\01');\n        if (pos_end)\n            pos_end[0] = '\\0';\n\n        pos_args = NULL;\n        pos_space = strchr (arguments + 1, ' ');\n        if (pos_space)\n        {\n            pos_space[0] = '\\0';\n            pos_args = pos_space + 1;\n            while (pos_args[0] == ' ')\n            {\n                pos_args++;\n            }\n        }\n\n        /* CTCP ACTION */\n        if (strcmp (arguments + 1, \"ACTION\") == 0)\n        {\n            nick_is_me = (irc_server_strcasecmp (server, server->nick, nick) == 0);\n            if (channel)\n            {\n                ptr_nick = irc_nick_search (server, channel, nick);\n                irc_channel_nick_speaking_add (channel,\n                                               nick,\n                                               (pos_args) ?\n                                               weechat_string_has_highlight (pos_args,\n                                                                             server->nick) : 0);\n                irc_channel_nick_speaking_time_remove_old (channel);\n                irc_channel_nick_speaking_time_add (server, channel, nick,\n                                                    time (NULL));\n                weechat_printf_date_tags (\n                    channel->buffer,\n                    date,\n                    irc_protocol_tags (\n                        command,\n                        (nick_is_me) ?\n                        \"irc_action,self_msg,notify_none,no_highlight\" :\n                        \"irc_action,notify_message\",\n                        nick, address),\n                    \"%s%s%s%s%s%s%s\",\n                    weechat_prefix (\"action\"),\n                    irc_nick_mode_for_display (server, ptr_nick, 0),\n                    (ptr_nick) ? ptr_nick->color : ((nick) ? irc_nick_find_color (nick) : IRC_COLOR_CHAT_NICK),\n                    nick,\n                    (pos_args) ? IRC_COLOR_RESET : \"\",\n                    (pos_args) ? \" \" : \"\",\n                    (pos_args) ? pos_args : \"\");\n            }\n            else\n            {\n                ptr_channel = irc_channel_search (server, remote_nick);\n                if (!ptr_channel)\n                {\n                    ptr_channel = irc_channel_new (server,\n                                                   IRC_CHANNEL_TYPE_PRIVATE,\n                                                   remote_nick, 0, 0);\n                    if (!ptr_channel)\n                    {\n                        weechat_printf (\n                            server->buffer,\n                            _(\"%s%s: cannot create new private buffer \\\"%s\\\"\"),\n                            weechat_prefix (\"error\"), IRC_PLUGIN_NAME,\n                            remote_nick);\n                    }\n                }\n                if (ptr_channel)\n                {\n                    if (!ptr_channel->topic)\n                        irc_channel_set_topic (ptr_channel, address);\n\n                    weechat_printf_date_tags (\n                        ptr_channel->buffer,\n                        date,\n                        irc_protocol_tags (\n                            command,\n                            (nick_is_me) ?\n                            \"irc_action,self_msg,notify_none,no_highlight\" :\n                            \"irc_action,notify_private\",\n                            nick, address),\n                        \"%s%s%s%s%s%s\",\n                        weechat_prefix (\"action\"),\n                        (nick_is_me) ?\n                        IRC_COLOR_CHAT_NICK_SELF : irc_nick_color_for_pv (ptr_channel, nick),\n                        nick,\n                        (pos_args) ? IRC_COLOR_RESET : \"\",\n                        (pos_args) ? \" \" : \"\",\n                        (pos_args) ? pos_args : \"\");\n                    (void) weechat_hook_signal_send (\"irc_pv\",\n                                                     WEECHAT_HOOK_SIGNAL_STRING,\n                                                     message);\n                }\n            }\n        }\n        /* CTCP PING */\n        else if (strcmp (arguments + 1, \"PING\") == 0)\n        {\n            reply = irc_ctcp_get_reply (server, arguments + 1);\n            irc_ctcp_display_request (server, date, command, channel, nick,\n                                      address, arguments + 1, pos_args, reply);\n            if (!reply || reply[0])\n            {\n                irc_ctcp_reply_to_nick (server, command, channel, nick,\n                                        arguments + 1, pos_args);\n            }\n        }\n        /* CTCP DCC */\n        else if (strcmp (arguments + 1, \"DCC\") == 0)\n        {\n            irc_ctcp_recv_dcc (server, nick, pos_args, message);\n        }\n        /* other CTCP */\n        else\n        {\n            reply = irc_ctcp_get_reply (server, arguments + 1);\n            if (reply)\n            {\n                irc_ctcp_display_request (server, date, command, channel, nick,\n                                          address, arguments + 1, pos_args,\n                                          reply);\n\n                if (reply[0])\n                {\n                    decoded_reply = irc_ctcp_replace_variables (server, reply);\n                    if (decoded_reply)\n                    {\n                        irc_ctcp_reply_to_nick (server, command, channel, nick,\n                                                arguments + 1, decoded_reply);\n                        free (decoded_reply);\n                    }\n                }\n            }\n            else\n            {\n                if (weechat_config_boolean (irc_config_look_display_ctcp_unknown))\n                {\n                    weechat_printf_date_tags (\n                        irc_msgbuffer_get_target_buffer (\n                            server, nick, NULL, \"ctcp\",\n                            (channel) ? channel->buffer : NULL),\n                        date,\n                        irc_protocol_tags (command, \"irc_ctcp\", NULL, address),\n                        _(\"%sUnknown CTCP requested by %s%s%s: %s%s%s%s%s\"),\n                        weechat_prefix (\"network\"),\n                        irc_nick_color_for_msg (server, 0, NULL, nick),\n                        nick,\n                        IRC_COLOR_RESET,\n                        IRC_COLOR_CHAT_CHANNEL,\n                        arguments + 1,\n                        (pos_args) ? IRC_COLOR_RESET : \"\",\n                        (pos_args) ? \" \" : \"\",\n                        (pos_args) ? pos_args : \"\");\n                }\n            }\n        }\n\n        (void) weechat_hook_signal_send (\"irc_ctcp\",\n                                         WEECHAT_HOOK_SIGNAL_STRING,\n                                         message);\n\n        if (pos_space)\n            pos_space[0] = ' ';\n\n        if (pos_end)\n            pos_end[0] = '\\01';\n\n        arguments = (pos_end) ? pos_end + 1 : NULL;\n    }\n}\n"], "fixing_code": ["/*\n * irc-ctcp.c - IRC CTCP protocol\n *\n * Copyright (C) 2003-2017 S\u00e9bastien Helleu <flashcode@flashtux.org>\n *\n * This file is part of WeeChat, the extensible chat client.\n *\n * WeeChat is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * WeeChat is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with WeeChat.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/time.h>\n#include <time.h>\n#include <sys/utsname.h>\n#include <locale.h>\n\n#include \"../weechat-plugin.h\"\n#include \"irc.h\"\n#include \"irc-ctcp.h\"\n#include \"irc-channel.h\"\n#include \"irc-color.h\"\n#include \"irc-config.h\"\n#include \"irc-msgbuffer.h\"\n#include \"irc-nick.h\"\n#include \"irc-protocol.h\"\n#include \"irc-server.h\"\n\n\nstruct t_irc_ctcp_reply irc_ctcp_default_reply[] =\n{ { \"clientinfo\", \"$clientinfo\" },\n  { \"finger\",     \"WeeChat $versiongit\" },\n  { \"source\",     \"$download\" },\n  { \"time\",       \"$time\" },\n  { \"userinfo\",   \"$username ($realname)\" },\n  { \"version\",    \"WeeChat $versiongit ($compilation)\" },\n  { NULL,         NULL },\n};\n\n\n/*\n * Gets default reply for a CTCP query.\n *\n * Returns NULL if CTCP is unknown.\n */\n\nconst char *\nirc_ctcp_get_default_reply (const char *ctcp)\n{\n    int i;\n\n    for (i = 0; irc_ctcp_default_reply[i].name; i++)\n    {\n        if (weechat_strcasecmp (irc_ctcp_default_reply[i].name, ctcp) == 0)\n            return irc_ctcp_default_reply[i].reply;\n    }\n\n    /* unknown CTCP */\n    return NULL;\n}\n\n/*\n * Gets reply for a CTCP query.\n */\n\nconst char *\nirc_ctcp_get_reply (struct t_irc_server *server, const char *ctcp)\n{\n    struct t_config_option *ptr_option;\n    char option_name[512];\n\n    snprintf (option_name, sizeof (option_name), \"%s.%s\", server->name, ctcp);\n\n    /* search for CTCP in configuration file, for server */\n    ptr_option = weechat_config_search_option (irc_config_file,\n                                               irc_config_section_ctcp,\n                                               option_name);\n    if (ptr_option)\n        return weechat_config_string (ptr_option);\n\n    /* search for CTCP in configuration file */\n    ptr_option = weechat_config_search_option (irc_config_file,\n                                               irc_config_section_ctcp,\n                                               ctcp);\n    if (ptr_option)\n        return weechat_config_string (ptr_option);\n\n    /*\n     * no CTCP reply found in config, then return default reply, or NULL\n     * for unknown CTCP\n     */\n    return irc_ctcp_get_default_reply (ctcp);\n}\n\n/*\n * Displays CTCP requested by a nick.\n */\n\nvoid\nirc_ctcp_display_request (struct t_irc_server *server,\n                          time_t date,\n                          const char *command,\n                          struct t_irc_channel *channel,\n                          const char *nick,\n                          const char *address,\n                          const char *ctcp,\n                          const char *arguments,\n                          const char *reply)\n{\n    /* CTCP blocked and user doesn't want to see message? then just return */\n    if (reply && !reply[0]\n        && !weechat_config_boolean (irc_config_look_display_ctcp_blocked))\n        return;\n\n    weechat_printf_date_tags (\n        irc_msgbuffer_get_target_buffer (\n            server, nick, NULL, \"ctcp\",\n            (channel) ? channel->buffer : NULL),\n        date,\n        irc_protocol_tags (command, \"irc_ctcp\", NULL, address),\n        _(\"%sCTCP requested by %s%s%s: %s%s%s%s%s%s\"),\n        weechat_prefix (\"network\"),\n        irc_nick_color_for_msg (server, 0, NULL, nick),\n        nick,\n        IRC_COLOR_RESET,\n        IRC_COLOR_CHAT_CHANNEL,\n        ctcp,\n        IRC_COLOR_RESET,\n        (arguments) ? \" \" : \"\",\n        (arguments) ? arguments : \"\",\n        (reply && !reply[0]) ? _(\" (blocked)\") : \"\");\n}\n\n/*\n * Displays reply from a nick to a CTCP query.\n */\n\nvoid\nirc_ctcp_display_reply_from_nick (struct t_irc_server *server, time_t date,\n                                  const char *command, const char *nick,\n                                  const char *address, char *arguments)\n{\n    char *pos_end, *pos_space, *pos_args, *pos_usec;\n    struct timeval tv;\n    long sec1, usec1, sec2, usec2, difftime;\n\n    while (arguments && arguments[0])\n    {\n        pos_end = strrchr (arguments + 1, '\\01');\n        if (pos_end)\n            pos_end[0] = '\\0';\n\n        pos_space = strchr (arguments + 1, ' ');\n        if (pos_space)\n        {\n            pos_space[0] = '\\0';\n            pos_args = pos_space + 1;\n            while (pos_args[0] == ' ')\n            {\n                pos_args++;\n            }\n            if (strcmp (arguments + 1, \"PING\") == 0)\n            {\n                pos_usec = strchr (pos_args, ' ');\n                if (pos_usec)\n                {\n                    pos_usec[0] = '\\0';\n\n                    gettimeofday (&tv, NULL);\n                    sec1 = atol (pos_args);\n                    usec1 = atol (pos_usec + 1);\n                    sec2 = tv.tv_sec;\n                    usec2 = tv.tv_usec;\n\n                    difftime = ((sec2 * 1000000) + usec2) -\n                        ((sec1 * 1000000) + usec1);\n                    weechat_printf_date_tags (\n                        irc_msgbuffer_get_target_buffer (\n                            server, nick, NULL, \"ctcp\", NULL),\n                        date,\n                        irc_protocol_tags (command, \"irc_ctcp\", NULL, NULL),\n                        /* TRANSLATORS: %.3fs is a float number + \"s\" (\"seconds\") */\n                        _(\"%sCTCP reply from %s%s%s: %s%s%s %.3fs\"),\n                        weechat_prefix (\"network\"),\n                        irc_nick_color_for_msg (server, 0, NULL, nick),\n                        nick,\n                        IRC_COLOR_RESET,\n                        IRC_COLOR_CHAT_CHANNEL,\n                        arguments + 1,\n                        IRC_COLOR_RESET,\n                        (float)difftime / 1000000.0);\n\n                    pos_usec[0] = ' ';\n                }\n            }\n            else\n            {\n                weechat_printf_date_tags (\n                    irc_msgbuffer_get_target_buffer (\n                        server, nick, NULL, \"ctcp\", NULL),\n                    date,\n                    irc_protocol_tags (command, \"irc_ctcp\", NULL, address),\n                    _(\"%sCTCP reply from %s%s%s: %s%s%s%s%s\"),\n                    weechat_prefix (\"network\"),\n                    irc_nick_color_for_msg (server, 0, NULL, nick),\n                    nick,\n                    IRC_COLOR_RESET,\n                    IRC_COLOR_CHAT_CHANNEL,\n                    arguments + 1,\n                    IRC_COLOR_RESET,\n                    \" \",\n                    pos_args);\n            }\n            pos_space[0] = ' ';\n        }\n        else\n        {\n            weechat_printf_date_tags (\n                irc_msgbuffer_get_target_buffer (\n                    server, nick, NULL, \"ctcp\", NULL),\n                date,\n                irc_protocol_tags (command, NULL, NULL, address),\n                _(\"%sCTCP reply from %s%s%s: %s%s%s%s%s\"),\n                weechat_prefix (\"network\"),\n                irc_nick_color_for_msg (server, 0, NULL, nick),\n                nick,\n                IRC_COLOR_RESET,\n                IRC_COLOR_CHAT_CHANNEL,\n                arguments + 1,\n                \"\",\n                \"\",\n                \"\");\n        }\n\n        if (pos_end)\n            pos_end[0] = '\\01';\n\n        arguments = (pos_end) ? pos_end + 1 : NULL;\n    }\n}\n\n/*\n * Displays CTCP replied to a nick.\n */\n\nvoid\nirc_ctcp_reply_to_nick (struct t_irc_server *server,\n                        const char *command,\n                        struct t_irc_channel *channel,\n                        const char *nick, const char *ctcp,\n                        const char *arguments)\n{\n    struct t_hashtable *hashtable;\n    int number;\n    char hash_key[32];\n    const char *str_args;\n    char *str_args_color;\n\n    hashtable = irc_server_sendf (\n        server,\n        IRC_SERVER_SEND_OUTQ_PRIO_LOW | IRC_SERVER_SEND_RETURN_HASHTABLE,\n        NULL,\n        \"NOTICE %s :\\01%s%s%s\\01\",\n        nick, ctcp,\n        (arguments) ? \" \" : \"\",\n        (arguments) ? arguments : \"\");\n\n    if (hashtable)\n    {\n        if (weechat_config_boolean (irc_config_look_display_ctcp_reply))\n        {\n            number = 1;\n            while (1)\n            {\n                snprintf (hash_key, sizeof (hash_key), \"args%d\", number);\n                str_args = weechat_hashtable_get (hashtable, hash_key);\n                if (!str_args)\n                    break;\n                str_args_color = irc_color_decode (str_args, 1);\n                if (!str_args_color)\n                    break;\n                weechat_printf_date_tags (\n                    irc_msgbuffer_get_target_buffer (\n                        server, nick, NULL, \"ctcp\",\n                        (channel) ? channel->buffer : NULL),\n                    0,\n                    irc_protocol_tags (\n                        command,\n                        \"irc_ctcp,irc_ctcp_reply,self_msg,notify_none,\"\n                        \"no_highlight\",\n                        NULL, NULL),\n                    _(\"%sCTCP reply to %s%s%s: %s%s%s%s%s\"),\n                    weechat_prefix (\"network\"),\n                    irc_nick_color_for_msg (server, 0, NULL, nick),\n                    nick,\n                    IRC_COLOR_RESET,\n                    IRC_COLOR_CHAT_CHANNEL,\n                    ctcp,\n                    (str_args_color[0]) ? IRC_COLOR_RESET : \"\",\n                    (str_args_color[0]) ? \" \" : \"\",\n                    str_args_color);\n                free (str_args_color);\n                number++;\n            }\n        }\n        weechat_hashtable_free (hashtable);\n    }\n}\n\n/*\n * Replaces variables in CTCP format.\n *\n * Note: result must be freed after use.\n */\n\nchar *\nirc_ctcp_replace_variables (struct t_irc_server *server, const char *format)\n{\n    char *res, *temp, *username, *realname;\n    const char *info;\n    time_t now;\n    struct tm *local_time;\n    char buf[1024];\n    struct utsname *buf_uname;\n\n    /*\n     * $clientinfo: supported CTCP, example:\n     *   ACTION DCC CLIENTINFO FINGER PING SOURCE TIME USERINFO VERSION\n     */\n    temp = weechat_string_replace (\n        format, \"$clientinfo\",\n        \"ACTION DCC CLIENTINFO FINGER PING SOURCE TIME USERINFO VERSION\");\n    if (!temp)\n        return NULL;\n    res = temp;\n\n    /*\n     * $git: git version (output of \"git describe\" for a development version\n     * only, empty string if unknown), example:\n     *   v0.3.9-104-g7eb5cc4\n     */\n    info = weechat_info_get (\"version_git\", \"\");\n    temp = weechat_string_replace (res, \"$git\", info);\n    free (res);\n    if (!temp)\n        return NULL;\n    res = temp;\n\n    /*\n     * $versiongit: WeeChat version + git version (if known), examples:\n     *   0.3.9\n     *   0.4.0-dev\n     *   0.4.0-dev (git: v0.3.9-104-g7eb5cc4)\n     */\n    info = weechat_info_get (\"version_git\", \"\");\n    snprintf (buf, sizeof (buf), \"%s%s%s%s\",\n              weechat_info_get (\"version\", \"\"),\n              (info && info[0]) ? \" (git: \" : \"\",\n              (info && info[0]) ? info : \"\",\n              (info && info[0]) ? \")\" : \"\");\n    temp = weechat_string_replace (res, \"$versiongit\", buf);\n    free (res);\n    if (!temp)\n        return NULL;\n    res = temp;\n\n    /*\n     * $version: WeeChat version, examples:\n     *   0.3.9\n     *   0.4.0-dev\n     */\n    info = weechat_info_get (\"version\", \"\");\n    temp = weechat_string_replace (res, \"$version\", info);\n    free (res);\n    if (!temp)\n        return NULL;\n    res = temp;\n\n    /*\n     * $compilation: compilation date, example:\n     *   Dec 16 2012\n     */\n    info = weechat_info_get (\"date\", \"\");\n    temp = weechat_string_replace (res, \"$compilation\", info);\n    free (res);\n    if (!temp)\n        return NULL;\n    res = temp;\n\n    /*\n     * $osinfo: info about OS, example:\n     *   Linux 2.6.32-5-amd64 / x86_64\n     */\n    buf_uname = (struct utsname *)malloc (sizeof (struct utsname));\n    if (buf_uname)\n    {\n        if (uname (buf_uname) >= 0)\n        {\n            snprintf (buf, sizeof (buf), \"%s %s / %s\",\n                      buf_uname->sysname, buf_uname->release,\n                      buf_uname->machine);\n            temp = weechat_string_replace (res, \"$osinfo\", buf);\n            free (res);\n            if (!temp)\n            {\n                free (buf_uname);\n                return NULL;\n            }\n            res = temp;\n        }\n        free (buf_uname);\n    }\n\n    /*\n     * $site: WeeChat web site, example:\n     *   https://weechat.org/\n     */\n    info = weechat_info_get (\"weechat_site\", \"\");\n    temp = weechat_string_replace (res, \"$site\", info);\n    free (res);\n    if (!temp)\n        return NULL;\n    res = temp;\n\n    /*\n     * $download: WeeChat download page, example:\n     *   https://weechat.org/download\n     */\n    info = weechat_info_get (\"weechat_site_download\", \"\");\n    temp = weechat_string_replace (res, \"$download\", info);\n    free (res);\n    if (!temp)\n        return NULL;\n    res = temp;\n\n    /*\n     * $time: local date/time of user, example:\n     *   Sun, 16 Dec 2012 10:40:48 +0100\n     */\n    now = time (NULL);\n    local_time = localtime (&now);\n    setlocale (LC_ALL, \"C\");\n    strftime (buf, sizeof (buf),\n              weechat_config_string (irc_config_look_ctcp_time_format),\n              local_time);\n    setlocale (LC_ALL, \"\");\n    temp = weechat_string_replace (res, \"$time\", buf);\n    free (res);\n    if (!temp)\n        return NULL;\n    res = temp;\n\n    /*\n     * $username: user name, example:\n     *   name\n     */\n    username = weechat_string_eval_expression (\n        IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_USERNAME),\n        NULL, NULL, NULL);\n    if (username)\n    {\n        temp = weechat_string_replace (res, \"$username\", username);\n        free (res);\n        if (!temp)\n            return NULL;\n        res = temp;\n        free (username);\n    }\n\n    /*\n     * $realname: real name, example:\n     *   John doe\n     */\n    realname = weechat_string_eval_expression (\n        IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_REALNAME),\n        NULL, NULL, NULL);\n    if (realname)\n    {\n        temp = weechat_string_replace (res, \"$realname\", realname);\n        free (res);\n        if (!temp)\n            return NULL;\n        res = temp;\n        free (realname);\n    }\n\n    /* return result */\n    return res;\n}\n\n/*\n * Returns filename for DCC, without double quotes.\n *\n * Note: result must be freed after use.\n */\n\nchar *\nirc_ctcp_dcc_filename_without_quotes (const char *filename)\n{\n    int length;\n\n    length = strlen (filename);\n    if (length > 1)\n    {\n        if ((filename[0] == '\\\"') && (filename[length - 1] == '\\\"'))\n            return weechat_strndup (filename + 1, length - 2);\n    }\n    return strdup (filename);\n}\n\n/*\n * Parses CTCP DCC.\n */\n\nvoid\nirc_ctcp_recv_dcc (struct t_irc_server *server, const char *nick,\n                   const char *arguments, char *message)\n{\n    char *dcc_args, *pos, *pos_file, *pos_addr, *pos_port, *pos_size;\n    char *pos_start_resume, *filename;\n    struct t_infolist *infolist;\n    struct t_infolist_item *item;\n    char charset_modifier[256];\n\n    if (!arguments || !arguments[0])\n        return;\n\n    if (strncmp (arguments, \"SEND \", 5) == 0)\n    {\n        arguments += 5;\n        while (arguments[0] == ' ')\n        {\n            arguments++;\n        }\n        dcc_args = strdup (arguments);\n\n        if (!dcc_args)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: not enough memory for \\\"%s\\\" command\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME, \"privmsg\");\n            return;\n        }\n\n        /* DCC filename */\n        pos_file = dcc_args;\n        while (pos_file[0] == ' ')\n        {\n            pos_file++;\n        }\n\n        /* look for file size */\n        pos_size = strrchr (pos_file, ' ');\n        if (!pos_size)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: cannot parse \\\"%s\\\" command\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME, \"privmsg\");\n            free (dcc_args);\n            return;\n        }\n\n        pos = pos_size;\n        pos_size++;\n        while (pos[0] == ' ')\n        {\n            pos--;\n        }\n        pos[1] = '\\0';\n\n        /* look for DCC port */\n        pos_port = strrchr (pos_file, ' ');\n        if (!pos_port)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: cannot parse \\\"%s\\\" command\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME, \"privmsg\");\n            free (dcc_args);\n            return;\n        }\n\n        pos = pos_port;\n        pos_port++;\n        while (pos[0] == ' ')\n        {\n            pos--;\n        }\n        pos[1] = '\\0';\n\n        /* look for DCC IP address */\n        pos_addr = strrchr (pos_file, ' ');\n        if (!pos_addr)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: cannot parse \\\"%s\\\" command\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME, \"privmsg\");\n            free (dcc_args);\n            return;\n        }\n\n        pos = pos_addr;\n        pos_addr++;\n        while (pos[0] == ' ')\n        {\n            pos--;\n        }\n        pos[1] = '\\0';\n\n        /* remove double quotes around filename */\n        filename = irc_ctcp_dcc_filename_without_quotes (pos_file);\n\n        /* add DCC file via xfer plugin */\n        infolist = weechat_infolist_new ();\n        if (infolist)\n        {\n            item = weechat_infolist_new_item (infolist);\n            if (item)\n            {\n                weechat_infolist_new_var_string (item, \"plugin_name\", weechat_plugin->name);\n                weechat_infolist_new_var_string (item, \"plugin_id\", server->name);\n                weechat_infolist_new_var_string (item, \"type_string\", \"file_recv\");\n                weechat_infolist_new_var_string (item, \"protocol_string\", \"dcc\");\n                weechat_infolist_new_var_string (item, \"remote_nick\", nick);\n                weechat_infolist_new_var_string (item, \"local_nick\", server->nick);\n                weechat_infolist_new_var_string (item, \"filename\",\n                                                 (filename) ? filename : pos_file);\n                weechat_infolist_new_var_string (item, \"size\", pos_size);\n                weechat_infolist_new_var_string (item, \"proxy\",\n                                                 IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_PROXY));\n                weechat_infolist_new_var_string (item, \"remote_address\", pos_addr);\n                weechat_infolist_new_var_integer (item, \"port\", atoi (pos_port));\n                (void) weechat_hook_signal_send (\"xfer_add\",\n                                                 WEECHAT_HOOK_SIGNAL_POINTER,\n                                                 infolist);\n            }\n            weechat_infolist_free (infolist);\n        }\n\n        (void) weechat_hook_signal_send (\"irc_dcc\",\n                                         WEECHAT_HOOK_SIGNAL_STRING,\n                                         message);\n\n        if (filename)\n            free (filename);\n\n        free (dcc_args);\n    }\n    else if (strncmp (arguments, \"RESUME \", 7) == 0)\n    {\n        arguments += 7;\n        while (arguments[0] == ' ')\n        {\n            arguments++;\n        }\n        dcc_args = strdup (arguments);\n\n        if (!dcc_args)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: not enough memory for \\\"%s\\\" command\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME, \"privmsg\");\n            return;\n        }\n\n        /* DCC filename */\n        pos_file = dcc_args;\n        while (pos_file[0] == ' ')\n        {\n            pos_file++;\n        }\n\n        /* look for resume start position */\n        pos_start_resume = strrchr (pos_file, ' ');\n        if (!pos_start_resume)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: cannot parse \\\"%s\\\" command\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME, \"privmsg\");\n            free (dcc_args);\n            return;\n        }\n        pos = pos_start_resume;\n        pos_start_resume++;\n        while (pos[0] == ' ')\n        {\n            pos--;\n        }\n        pos[1] = '\\0';\n\n        /* look for DCC port */\n        pos_port = strrchr (pos_file, ' ');\n        if (!pos_port)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: cannot parse \\\"%s\\\" command\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME, \"privmsg\");\n            free (dcc_args);\n            return;\n        }\n        pos = pos_port;\n        pos_port++;\n        while (pos[0] == ' ')\n        {\n            pos--;\n        }\n        pos[1] = '\\0';\n\n        /* remove double quotes around filename */\n        filename = irc_ctcp_dcc_filename_without_quotes (pos_file);\n\n        /* accept resume via xfer plugin */\n        infolist = weechat_infolist_new ();\n        if (infolist)\n        {\n            item = weechat_infolist_new_item (infolist);\n            if (item)\n            {\n                weechat_infolist_new_var_string (item, \"plugin_name\", weechat_plugin->name);\n                weechat_infolist_new_var_string (item, \"plugin_id\", server->name);\n                weechat_infolist_new_var_string (item, \"type_string\", \"file_recv\");\n                weechat_infolist_new_var_string (item, \"filename\",\n                                                 (filename) ? filename : pos_file);\n                weechat_infolist_new_var_integer (item, \"port\", atoi (pos_port));\n                weechat_infolist_new_var_string (item, \"start_resume\", pos_start_resume);\n                (void) weechat_hook_signal_send (\"xfer_accept_resume\",\n                                                 WEECHAT_HOOK_SIGNAL_POINTER,\n                                                 infolist);\n            }\n            weechat_infolist_free (infolist);\n        }\n\n        (void) weechat_hook_signal_send (\"irc_dcc\",\n                                         WEECHAT_HOOK_SIGNAL_STRING,\n                                         message);\n\n        if (filename)\n            free (filename);\n\n        free (dcc_args);\n    }\n    else if (strncmp (arguments, \"ACCEPT \", 7) == 0)\n    {\n        arguments += 7;\n        while (arguments[0] == ' ')\n        {\n            arguments++;\n        }\n        dcc_args = strdup (arguments);\n\n        if (!dcc_args)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: not enough memory for \\\"%s\\\" command\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME, \"privmsg\");\n            return;\n        }\n\n        /* DCC filename */\n        pos_file = dcc_args;\n        while (pos_file[0] == ' ')\n        {\n            pos_file++;\n        }\n\n        /* look for resume start position */\n        pos_start_resume = strrchr (pos_file, ' ');\n        if (!pos_start_resume)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: cannot parse \\\"%s\\\" command\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME, \"privmsg\");\n            free (dcc_args);\n            return;\n        }\n        pos = pos_start_resume;\n        pos_start_resume++;\n        while (pos[0] == ' ')\n        {\n            pos--;\n        }\n        pos[1] = '\\0';\n\n        /* look for DCC port */\n        pos_port = strrchr (pos_file, ' ');\n        if (!pos_port)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: cannot parse \\\"%s\\\" command\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME, \"privmsg\");\n            free (dcc_args);\n            return;\n        }\n        pos = pos_port;\n        pos_port++;\n        while (pos[0] == ' ')\n        {\n            pos--;\n        }\n        pos[1] = '\\0';\n\n        /* remove double quotes around filename */\n        filename = irc_ctcp_dcc_filename_without_quotes (pos_file);\n\n        /* resume file via xfer plugin */\n        infolist = weechat_infolist_new ();\n        if (infolist)\n        {\n            item = weechat_infolist_new_item (infolist);\n            if (item)\n            {\n                weechat_infolist_new_var_string (item, \"plugin_name\", weechat_plugin->name);\n                weechat_infolist_new_var_string (item, \"plugin_id\", server->name);\n                weechat_infolist_new_var_string (item, \"type_string\", \"file_recv\");\n                weechat_infolist_new_var_string (item, \"filename\",\n                                                 (filename) ? filename : pos_file);\n                weechat_infolist_new_var_integer (item, \"port\", atoi (pos_port));\n                weechat_infolist_new_var_string (item, \"start_resume\", pos_start_resume);\n                (void) weechat_hook_signal_send (\"xfer_start_resume\",\n                                                 WEECHAT_HOOK_SIGNAL_POINTER,\n                                                 infolist);\n            }\n            weechat_infolist_free (infolist);\n        }\n\n        (void) weechat_hook_signal_send (\"irc_dcc\",\n                                         WEECHAT_HOOK_SIGNAL_STRING,\n                                         message);\n\n        if (filename)\n            free (filename);\n\n        free (dcc_args);\n    }\n    else if (strncmp (arguments, \"CHAT \", 5) == 0)\n    {\n        arguments += 5;\n        while (arguments[0] == ' ')\n        {\n            arguments++;\n        }\n        dcc_args = strdup (arguments);\n\n        if (!dcc_args)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: not enough memory for \\\"%s\\\" command\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME, \"privmsg\");\n            return;\n        }\n\n        /* CHAT type */\n        pos_file = dcc_args;\n        while (pos_file[0] == ' ')\n        {\n            pos_file++;\n        }\n\n        /* DCC IP address */\n        pos_addr = strchr (pos_file, ' ');\n        if (!pos_addr)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: cannot parse \\\"%s\\\" command\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME, \"privmsg\");\n            free (dcc_args);\n            return;\n        }\n        pos_addr[0] = '\\0';\n        pos_addr++;\n        while (pos_addr[0] == ' ')\n        {\n            pos_addr++;\n        }\n\n        /* look for DCC port */\n        pos_port = strchr (pos_addr, ' ');\n        if (!pos_port)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: cannot parse \\\"%s\\\" command\"),\n                weechat_prefix (\"error\"), IRC_PLUGIN_NAME, \"privmsg\");\n            free (dcc_args);\n            return;\n        }\n        pos_port[0] = '\\0';\n        pos_port++;\n        while (pos_port[0] == ' ')\n        {\n            pos_port++;\n        }\n\n        if (weechat_strcasecmp (pos_file, \"chat\") != 0)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: unknown DCC CHAT type received from %s%s%s: \\\"%s\\\"\"),\n                weechat_prefix (\"error\"),\n                IRC_PLUGIN_NAME,\n                irc_nick_color_for_msg (server, 0, NULL, nick),\n                nick,\n                IRC_COLOR_RESET,\n                pos_file);\n            free (dcc_args);\n            return;\n        }\n\n        /* add DCC chat via xfer plugin */\n        infolist = weechat_infolist_new ();\n        if (infolist)\n        {\n            item = weechat_infolist_new_item (infolist);\n            if (item)\n            {\n                weechat_infolist_new_var_string (item, \"plugin_name\", weechat_plugin->name);\n                weechat_infolist_new_var_string (item, \"plugin_id\", server->name);\n                weechat_infolist_new_var_string (item, \"type_string\", \"chat_recv\");\n                weechat_infolist_new_var_string (item, \"remote_nick\", nick);\n                weechat_infolist_new_var_string (item, \"local_nick\", server->nick);\n                snprintf (charset_modifier, sizeof (charset_modifier),\n                          \"irc.%s.%s\", server->name, nick);\n                weechat_infolist_new_var_string (item, \"charset_modifier\", charset_modifier);\n                weechat_infolist_new_var_string (item, \"proxy\",\n                                                 IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_PROXY));\n                weechat_infolist_new_var_string (item, \"remote_address\", pos_addr);\n                weechat_infolist_new_var_integer (item, \"port\", atoi (pos_port));\n                (void) weechat_hook_signal_send (\"xfer_add\",\n                                                 WEECHAT_HOOK_SIGNAL_POINTER,\n                                                 infolist);\n            }\n            weechat_infolist_free (infolist);\n        }\n\n        (void) weechat_hook_signal_send (\"irc_dcc\",\n                                         WEECHAT_HOOK_SIGNAL_STRING,\n                                         message);\n\n        free (dcc_args);\n    }\n}\n\n/*\n * Receives a CTCP and if needed replies to query.\n */\n\nvoid\nirc_ctcp_recv (struct t_irc_server *server, time_t date, const char *command,\n               struct t_irc_channel *channel, const char *address,\n               const char *nick, const char *remote_nick, char *arguments,\n               char *message)\n{\n    char *pos_end, *pos_space, *pos_args;\n    const char *reply;\n    char *decoded_reply;\n    struct t_irc_channel *ptr_channel;\n    struct t_irc_nick *ptr_nick;\n    int nick_is_me;\n\n    while (arguments && arguments[0])\n    {\n        pos_end = strrchr (arguments + 1, '\\01');\n        if (pos_end)\n            pos_end[0] = '\\0';\n\n        pos_args = NULL;\n        pos_space = strchr (arguments + 1, ' ');\n        if (pos_space)\n        {\n            pos_space[0] = '\\0';\n            pos_args = pos_space + 1;\n            while (pos_args[0] == ' ')\n            {\n                pos_args++;\n            }\n        }\n\n        /* CTCP ACTION */\n        if (strcmp (arguments + 1, \"ACTION\") == 0)\n        {\n            nick_is_me = (irc_server_strcasecmp (server, server->nick, nick) == 0);\n            if (channel)\n            {\n                ptr_nick = irc_nick_search (server, channel, nick);\n                irc_channel_nick_speaking_add (channel,\n                                               nick,\n                                               (pos_args) ?\n                                               weechat_string_has_highlight (pos_args,\n                                                                             server->nick) : 0);\n                irc_channel_nick_speaking_time_remove_old (channel);\n                irc_channel_nick_speaking_time_add (server, channel, nick,\n                                                    time (NULL));\n                weechat_printf_date_tags (\n                    channel->buffer,\n                    date,\n                    irc_protocol_tags (\n                        command,\n                        (nick_is_me) ?\n                        \"irc_action,self_msg,notify_none,no_highlight\" :\n                        \"irc_action,notify_message\",\n                        nick, address),\n                    \"%s%s%s%s%s%s%s\",\n                    weechat_prefix (\"action\"),\n                    irc_nick_mode_for_display (server, ptr_nick, 0),\n                    (ptr_nick) ? ptr_nick->color : ((nick) ? irc_nick_find_color (nick) : IRC_COLOR_CHAT_NICK),\n                    nick,\n                    (pos_args) ? IRC_COLOR_RESET : \"\",\n                    (pos_args) ? \" \" : \"\",\n                    (pos_args) ? pos_args : \"\");\n            }\n            else\n            {\n                ptr_channel = irc_channel_search (server, remote_nick);\n                if (!ptr_channel)\n                {\n                    ptr_channel = irc_channel_new (server,\n                                                   IRC_CHANNEL_TYPE_PRIVATE,\n                                                   remote_nick, 0, 0);\n                    if (!ptr_channel)\n                    {\n                        weechat_printf (\n                            server->buffer,\n                            _(\"%s%s: cannot create new private buffer \\\"%s\\\"\"),\n                            weechat_prefix (\"error\"), IRC_PLUGIN_NAME,\n                            remote_nick);\n                    }\n                }\n                if (ptr_channel)\n                {\n                    if (!ptr_channel->topic)\n                        irc_channel_set_topic (ptr_channel, address);\n\n                    weechat_printf_date_tags (\n                        ptr_channel->buffer,\n                        date,\n                        irc_protocol_tags (\n                            command,\n                            (nick_is_me) ?\n                            \"irc_action,self_msg,notify_none,no_highlight\" :\n                            \"irc_action,notify_private\",\n                            nick, address),\n                        \"%s%s%s%s%s%s\",\n                        weechat_prefix (\"action\"),\n                        (nick_is_me) ?\n                        IRC_COLOR_CHAT_NICK_SELF : irc_nick_color_for_pv (ptr_channel, nick),\n                        nick,\n                        (pos_args) ? IRC_COLOR_RESET : \"\",\n                        (pos_args) ? \" \" : \"\",\n                        (pos_args) ? pos_args : \"\");\n                    (void) weechat_hook_signal_send (\"irc_pv\",\n                                                     WEECHAT_HOOK_SIGNAL_STRING,\n                                                     message);\n                }\n            }\n        }\n        /* CTCP PING */\n        else if (strcmp (arguments + 1, \"PING\") == 0)\n        {\n            reply = irc_ctcp_get_reply (server, arguments + 1);\n            irc_ctcp_display_request (server, date, command, channel, nick,\n                                      address, arguments + 1, pos_args, reply);\n            if (!reply || reply[0])\n            {\n                irc_ctcp_reply_to_nick (server, command, channel, nick,\n                                        arguments + 1, pos_args);\n            }\n        }\n        /* CTCP DCC */\n        else if (strcmp (arguments + 1, \"DCC\") == 0)\n        {\n            irc_ctcp_recv_dcc (server, nick, pos_args, message);\n        }\n        /* other CTCP */\n        else\n        {\n            reply = irc_ctcp_get_reply (server, arguments + 1);\n            if (reply)\n            {\n                irc_ctcp_display_request (server, date, command, channel, nick,\n                                          address, arguments + 1, pos_args,\n                                          reply);\n\n                if (reply[0])\n                {\n                    decoded_reply = irc_ctcp_replace_variables (server, reply);\n                    if (decoded_reply)\n                    {\n                        irc_ctcp_reply_to_nick (server, command, channel, nick,\n                                                arguments + 1, decoded_reply);\n                        free (decoded_reply);\n                    }\n                }\n            }\n            else\n            {\n                if (weechat_config_boolean (irc_config_look_display_ctcp_unknown))\n                {\n                    weechat_printf_date_tags (\n                        irc_msgbuffer_get_target_buffer (\n                            server, nick, NULL, \"ctcp\",\n                            (channel) ? channel->buffer : NULL),\n                        date,\n                        irc_protocol_tags (command, \"irc_ctcp\", NULL, address),\n                        _(\"%sUnknown CTCP requested by %s%s%s: %s%s%s%s%s\"),\n                        weechat_prefix (\"network\"),\n                        irc_nick_color_for_msg (server, 0, NULL, nick),\n                        nick,\n                        IRC_COLOR_RESET,\n                        IRC_COLOR_CHAT_CHANNEL,\n                        arguments + 1,\n                        (pos_args) ? IRC_COLOR_RESET : \"\",\n                        (pos_args) ? \" \" : \"\",\n                        (pos_args) ? pos_args : \"\");\n                }\n            }\n        }\n\n        (void) weechat_hook_signal_send (\"irc_ctcp\",\n                                         WEECHAT_HOOK_SIGNAL_STRING,\n                                         message);\n\n        if (pos_space)\n            pos_space[0] = ' ';\n\n        if (pos_end)\n            pos_end[0] = '\\01';\n\n        arguments = (pos_end) ? pos_end + 1 : NULL;\n    }\n}\n"], "filenames": ["src/plugins/irc/irc-ctcp.c"], "buggy_code_start_loc": [515], "buggy_code_end_loc": [516], "fixing_code_start_loc": [515], "fixing_code_end_loc": [516], "type": "CWE-119", "message": "WeeChat before 1.7.1 allows a remote crash by sending a filename via DCC to the IRC plugin. This occurs in the irc_ctcp_dcc_filename_without_quotes function during quote removal, with a buffer overflow.", "other": {"cve": {"id": "CVE-2017-8073", "sourceIdentifier": "cve@mitre.org", "published": "2017-04-23T15:59:00.200", "lastModified": "2020-03-16T17:15:15.293", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "WeeChat before 1.7.1 allows a remote crash by sending a filename via DCC to the IRC plugin. This occurs in the irc_ctcp_dcc_filename_without_quotes function during quote removal, with a buffer overflow."}, {"lang": "es", "value": "WeeChat en versiones anteriores a 1.7.1 permite una ca\u00edda remota a trav\u00e9s del envio de un nombre de archivo a trav\u00e9s de DCC al plugin IRC. Esto ocurre en la funci\u00f3n irc_ctcp_dcc_filename_without_quotes durante la eliminaci\u00f3n de cotizaciones, con un desbordamiento de b\u00fafer."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:weechat:weechat:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.7.1", "matchCriteriaId": "34C2B09C-F044-4A5B-9512-B370B5C1E8FB"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3836", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/97987", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/weechat/weechat/commit/2fb346f25f79e412cf0ed314fdf791763c19b70b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/4ASRTCQFFDAAK347URWNDH6NSED2BGNY/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ER23GT23US5JXDLUZAMGMWXKZ74MI4S2/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/M3LAJTLI3LWZRNCFYJ7PCBBTHUMCCBHH/", "source": "cve@mitre.org"}, {"url": "https://weechat.org/download/security/", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://weechat.org/news/95/20170422-Version-1.7.1/", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/weechat/weechat/commit/2fb346f25f79e412cf0ed314fdf791763c19b70b"}}