{"buggy_code": ["/**\n *   Copyright(C) 2011-2015 Intel Corporation All Rights Reserved.\n *\n *   The source code, information  and  material (\"Material\") contained herein is\n *   owned  by Intel Corporation or its suppliers or licensors, and title to such\n *   Material remains  with Intel Corporation  or its suppliers or licensors. The\n *   Material  contains proprietary information  of  Intel or  its  suppliers and\n *   licensors. The  Material is protected by worldwide copyright laws and treaty\n *   provisions. No  part  of  the  Material  may  be  used,  copied, reproduced,\n *   modified, published, uploaded, posted, transmitted, distributed or disclosed\n *   in any way  without Intel's  prior  express written  permission. No  license\n *   under  any patent, copyright  or  other intellectual property rights  in the\n *   Material  is  granted  to  or  conferred  upon  you,  either  expressly,  by\n *   implication, inducement,  estoppel or  otherwise.  Any  license  under  such\n *   intellectual  property  rights must  be express  and  approved  by  Intel in\n *   writing.\n *\n *   *Third Party trademarks are the property of their respective owners.\n *\n *   Unless otherwise  agreed  by Intel  in writing, you may not remove  or alter\n *   this  notice or  any other notice embedded  in Materials by Intel or Intel's\n *   suppliers or licensors in any way.\n */\n\n#include \"SGXEnclave.h\"\n\n// MAX_PATH, getpwuid\n#include <sys/types.h>\n#ifdef _MSC_VER\n# include <Shlobj.h>\n#else\n# include <unistd.h>\n# include <pwd.h>\n# define MAX_PATH FILENAME_MAX\n#endif\n\n#include <climits>\n#include <cstdarg>\n#include <cstdio>\n#include <cstdlib>\n#include <sys/time.h> // struct timeval\n#include <time.h> // gettimeofday\n\n#include <sgx_eid.h>     /* sgx_enclave_id_t */\n#include <sgx_error.h>       /* sgx_status_t */\n#include <sgx_uae_service.h>\n#include <sgx_ukey_exchange.h>\n\n#include \"Enclave_u.h\"\n#include \"service_provider.h\"\n\n#ifndef TRUE\n# define TRUE 1\n#endif\n\n#ifndef FALSE\n# define FALSE 0\n#endif\n\n#if defined(_MSC_VER)\n# define TOKEN_FILENAME   \"Enclave.token\"\n# define ENCLAVE_FILENAME \"Enclave.signed.dll\"\n#elif defined(__GNUC__)\n# define TOKEN_FILENAME   \"enclave.token\"\n# define ENCLAVE_FILENAME \"enclave.signed.so\"\n#endif\n\nstatic sgx_ra_context_t context = INT_MAX;\nJavaVM* jvm;\n\n/* Global EID shared by multiple threads */\nsgx_enclave_id_t global_eid = 0;\n\ntypedef struct _sgx_errlist_t {\n  sgx_status_t err;\n  const char *msg;\n  const char *sug; /* Suggestion */\n} sgx_errlist_t;\n\n/* Error code returned by sgx_create_enclave */\nstatic sgx_errlist_t sgx_errlist[] = {\n  {\n    SGX_ERROR_UNEXPECTED,\n    \"Unexpected error occurred.\",\n    NULL\n  },\n  {\n    SGX_ERROR_INVALID_PARAMETER,\n    \"Invalid parameter.\",\n    NULL\n  },\n  {\n    SGX_ERROR_OUT_OF_MEMORY,\n    \"Out of memory.\",\n    NULL\n  },\n  {\n    SGX_ERROR_ENCLAVE_LOST,\n    \"Power transition occurred.\",\n    \"Please refer to the sample \\\"PowerTransition\\\" for details.\"\n  },\n  {\n    SGX_ERROR_INVALID_ENCLAVE,\n    \"Invalid enclave image.\",\n    NULL\n  },\n  {\n    SGX_ERROR_INVALID_ENCLAVE_ID,\n    \"Invalid enclave identification.\",\n    NULL\n  },\n  {\n    SGX_ERROR_INVALID_SIGNATURE,\n    \"Invalid enclave signature.\",\n    NULL\n  },\n  {\n    SGX_ERROR_OUT_OF_EPC,\n    \"Out of EPC memory.\",\n    NULL\n  },\n  {\n    SGX_ERROR_NO_DEVICE,\n    \"Invalid SGX device.\",\n    \"Please make sure SGX module is enabled in the BIOS, and install SGX driver afterwards.\"\n  },\n  {\n    SGX_ERROR_MEMORY_MAP_CONFLICT,\n    \"Memory map conflicted.\",\n    NULL\n  },\n  {\n    SGX_ERROR_INVALID_METADATA,\n    \"Invalid enclave metadata.\",\n    NULL\n  },\n  {\n    SGX_ERROR_DEVICE_BUSY,\n    \"SGX device was busy.\",\n    NULL\n  },\n  {\n    SGX_ERROR_INVALID_VERSION,\n    \"Enclave version was invalid.\",\n    NULL\n  },\n  {\n    SGX_ERROR_INVALID_ATTRIBUTE,\n    \"Enclave was not authorized.\",\n    NULL\n  },\n  {\n    SGX_ERROR_ENCLAVE_FILE_ACCESS,\n    \"Can't open enclave file.\",\n    NULL\n  },\n\n  {\n    SGX_SUCCESS,\n    \"SGX call success\",\n    NULL\n  },\n};\n\n/* Check error conditions for loading enclave */\nvoid print_error_message(sgx_status_t ret)\n{\n  size_t idx = 0;\n  size_t ttl = sizeof sgx_errlist/sizeof sgx_errlist[0];\n\n  for (idx = 0; idx < ttl; idx++) {\n    if(ret == sgx_errlist[idx].err) {\n      if(NULL != sgx_errlist[idx].sug)\n        printf(\"Info: %s\\n\", sgx_errlist[idx].sug);\n      printf(\"Error: %s\\n\", sgx_errlist[idx].msg);\n      break;\n    }\n  }\n\n  if (idx == ttl)\n    printf(\"Error: Unexpected error occurred.\\n\");\n}\n\nvoid sgx_check_quiet(const char* message, sgx_status_t ret)\n{\n  if (ret != SGX_SUCCESS) {\n    printf(\"%s failed\\n\", message);\n    print_error_message(ret);\n  }\n}\n\nclass scoped_timer {\npublic:\n  scoped_timer(uint64_t *total_time) {\n    this->total_time = total_time;\n    struct timeval start;\n    gettimeofday(&start, NULL);\n    time_start = start.tv_sec * 1000000 + start.tv_usec;\n  }\n\n  ~scoped_timer() {\n    struct timeval end;\n    gettimeofday(&end, NULL);\n    time_end = end.tv_sec * 1000000 + end.tv_usec;\n    *total_time += time_end - time_start;\n  }\n\n  uint64_t * total_time;\n  uint64_t time_start, time_end;\n};\n\n#if defined(PERF) || defined(DEBUG)\n#define sgx_check(message, op) do {                     \\\n    printf(\"%s running...\\n\", message);                 \\\n    uint64_t t_ = 0;                                    \\\n    sgx_status_t ret_;                                  \\\n    {                                                   \\\n      scoped_timer timer_(&t_);                         \\\n      ret_ = op;                                        \\\n    }                                                   \\\n    double t_ms_ = ((double) t_) / 1000;                \\\n    if (ret_ != SGX_SUCCESS) {                          \\\n      printf(\"%s failed (%f ms)\\n\", message, t_ms_);    \\\n      print_error_message(ret_);                        \\\n    } else {                                            \\\n      printf(\"%s done (%f ms).\\n\", message, t_ms_);     \\\n    }                                                   \\\n  } while (0)\n#else\n#define sgx_check(message, op) sgx_check_quiet(message, op)\n#endif\n\n/* Initialize the enclave:\n *   Step 1: retrive the launch token saved by last transaction\n *   Step 2: call sgx_create_enclave to initialize an enclave instance\n *   Step 3: save the launch token if it is updated\n */\nint initialize_enclave(void)\n{\n  char token_path[MAX_PATH] = {'\\0'};\n  sgx_launch_token_t token = {0};\n  sgx_status_t ret = SGX_ERROR_UNEXPECTED;\n  int updated = 0;\n\n  /* Step 1: retrive the launch token saved by last transaction */\n#ifdef _MSC_VER\n  /* try to get the token saved in CSIDL_LOCAL_APPDATA */\n  if (S_OK != SHGetFolderPathA(NULL, CSIDL_LOCAL_APPDATA, NULL, 0, token_path)) {\n    strncpy_s(token_path, _countof(token_path), TOKEN_FILENAME, sizeof(TOKEN_FILENAME));\n  } else {\n    strncat_s(token_path, _countof(token_path), \"\\\\\" TOKEN_FILENAME, sizeof(TOKEN_FILENAME)+2);\n  }\n\n  /* open the token file */\n  HANDLE token_handler = CreateFileA(token_path, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, NULL, NULL);\n  if (token_handler == INVALID_HANDLE_VALUE) {\n    printf(\"Warning: Failed to create/open the launch token file \\\"%s\\\".\\n\", token_path);\n  } else {\n    /* read the token from saved file */\n    DWORD read_num = 0;\n    ReadFile(token_handler, token, sizeof(sgx_launch_token_t), &read_num, NULL);\n    if (read_num != 0 && read_num != sizeof(sgx_launch_token_t)) {\n      /* if token is invalid, clear the buffer */\n      memset(&token, 0x0, sizeof(sgx_launch_token_t));\n      printf(\"Warning: Invalid launch token read from \\\"%s\\\".\\n\", token_path);\n    }\n  }\n#else /* __GNUC__ */\n  /* try to get the token saved in $HOME */\n  const char *home_dir = getpwuid(getuid())->pw_dir;\n\n  if (home_dir != NULL &&\n      (strlen(home_dir)+strlen(\"/\")+sizeof(TOKEN_FILENAME)+1) <= MAX_PATH) {\n    /* compose the token path */\n    strncpy(token_path, home_dir, strlen(home_dir));\n    strncat(token_path, \"/\", strlen(\"/\"));\n    strncat(token_path, TOKEN_FILENAME, sizeof(TOKEN_FILENAME)+1);\n  } else {\n    /* if token path is too long or $HOME is NULL */\n    strncpy(token_path, TOKEN_FILENAME, sizeof(TOKEN_FILENAME));\n  }\n\n  FILE *fp = fopen(token_path, \"rb\");\n  if (fp == NULL && (fp = fopen(token_path, \"wb\")) == NULL) {\n    printf(\"Warning: Failed to create/open the launch token file \\\"%s\\\".\\n\", token_path);\n  }\n\n  if (fp != NULL) {\n    /* read the token from saved file */\n    size_t read_num = fread(token, 1, sizeof(sgx_launch_token_t), fp);\n    if (read_num != 0 && read_num != sizeof(sgx_launch_token_t)) {\n      /* if token is invalid, clear the buffer */\n      memset(&token, 0x0, sizeof(sgx_launch_token_t));\n      printf(\"Warning: Invalid launch token read from \\\"%s\\\".\\n\", token_path);\n    }\n  }\n#endif\n  /* Step 2: call sgx_create_enclave to initialize an enclave instance */\n  /* Debug Support: set 2nd parameter to 1 */\n  ret = sgx_create_enclave(ENCLAVE_FILENAME, SGX_DEBUG_FLAG, &token, &updated, &global_eid, NULL);\n  if (ret != SGX_SUCCESS) {\n    print_error_message(ret);\n#ifdef _MSC_VER\n    if (token_handler != INVALID_HANDLE_VALUE)\n      CloseHandle(token_handler);\n#else\n    if (fp != NULL) fclose(fp);\n#endif\n    return -1;\n  }\n\n  /* Step 3: save the launch token if it is updated */\n#ifdef _MSC_VER\n  if (updated == FALSE || token_handler == INVALID_HANDLE_VALUE) {\n    /* if the token is not updated, or file handler is invalid, do not perform saving */\n    if (token_handler != INVALID_HANDLE_VALUE)\n      CloseHandle(token_handler);\n    return 0;\n  }\n\n  /* flush the file cache */\n  FlushFileBuffers(token_handler);\n  /* set access offset to the begin of the file */\n  SetFilePointer(token_handler, 0, NULL, FILE_BEGIN);\n\n  /* write back the token */\n  DWORD write_num = 0;\n  WriteFile(token_handler, token, sizeof(sgx_launch_token_t), &write_num, NULL);\n  if (write_num != sizeof(sgx_launch_token_t))\n    printf(\"Warning: Failed to save launch token to \\\"%s\\\".\\n\", token_path);\n  CloseHandle(token_handler);\n#else /* __GNUC__ */\n  if (updated == FALSE || fp == NULL) {\n    /* if the token is not updated, or file handler is invalid, do not perform saving */\n    if (fp != NULL) fclose(fp);\n    return 0;\n  }\n\n  /* reopen the file with write capablity */\n  fp = freopen(token_path, \"wb\", fp);\n  if (fp == NULL) return 0;\n  size_t write_num = fwrite(token, 1, sizeof(sgx_launch_token_t), fp);\n  if (write_num != sizeof(sgx_launch_token_t))\n    printf(\"Warning: Failed to save launch token to \\\"%s\\\".\\n\", token_path);\n  fclose(fp);\n#endif\n  return 0;\n}\n\n/* OCall functions */\nvoid ocall_print_string(const char *str)\n{\n  /* Proxy/Bridge will check the length and null-terminate\n   * the input string to prevent buffer overflow.\n   */\n  printf(\"%s\", str);\n  fflush(stdout);\n}\n\nvoid ocall_malloc(size_t size, uint8_t **ret) {\n  *ret = static_cast<uint8_t *>(malloc(size));\n}\n\nvoid ocall_free(uint8_t *buf) {\n  free(buf);\n}\n\nvoid ocall_exit(int exit_code) {\n  std::exit(exit_code);\n}\n\n/**\n * Throw a Java exception with the specified message.\n *\n * This function is intended to be invoked from an ecall that was in turn invoked by a JNI method.\n * As a result of calling this function, the JNI method will throw a Java exception upon its return.\n *\n * Important: Note that this function will return to the caller. The exception is only thrown at the\n * end of the JNI method invocation.\n */\nvoid ocall_throw(const char *message) {\n  JNIEnv* env;\n  jvm->AttachCurrentThread((void**) &env, NULL);\n  jclass exception = env->FindClass(\"edu/berkeley/cs/rise/opaque/OpaqueException\");\n  env->ThrowNew(exception, message);\n}\n\n#if defined(_MSC_VER)\n/* query and enable SGX device*/\nint query_sgx_status()\n{\n  sgx_device_status_t sgx_device_status;\n  sgx_status_t sgx_ret = sgx_enable_device(&sgx_device_status);\n  if (sgx_ret != SGX_SUCCESS) {\n    printf(\"Failed to get SGX device status.\\n\");\n    return -1;\n  }\n  else {\n    switch (sgx_device_status) {\n    case SGX_ENABLED:\n      return 0;\n    case SGX_DISABLED_REBOOT_REQUIRED:\n      printf(\"SGX device has been enabled. Please reboot your machine.\\n\");\n      return -1;\n    case SGX_DISABLED_LEGACY_OS:\n      printf(\"SGX device can't be enabled on an OS that doesn't support EFI interface.\\n\");\n      return -1;\n    case SGX_DISABLED:\n      printf(\"SGX device not found.\\n\");\n      return -1;\n    default:\n      printf(\"Unexpected error.\\n\");\n      return -1;\n    }\n  }\n}\n#endif\n\n\nJNIEXPORT jlong JNICALL Java_edu_berkeley_cs_rise_opaque_execution_SGXEnclave_StartEnclave(\n  JNIEnv *env, jobject obj, jstring library_path) {\n  (void)env;\n  (void)obj;\n\n  env->GetJavaVM(&jvm);\n\n  sgx_enclave_id_t eid;\n  sgx_launch_token_t token = {0};\n  int updated = 0;\n\n  const char *library_path_str = env->GetStringUTFChars(library_path, nullptr);\n  sgx_check(\"StartEnclave\",\n            sgx_create_enclave(\n              library_path_str, SGX_DEBUG_FLAG, &token, &updated, &eid, nullptr));\n  env->ReleaseStringUTFChars(library_path, library_path_str);\n\n  return eid;\n}\n\nJNIEXPORT jbyteArray JNICALL Java_edu_berkeley_cs_rise_opaque_execution_SGXEnclave_RemoteAttestation0(\n  JNIEnv *env, jobject obj) {\n\n  (void)env;\n  (void)obj;\n\n  // in the first step of the remote attestation, generate message 1 to send to the client\n  int ret = 0;\n\n  // Preparation for remote attestation by configuring extended epid group id\n  // This is Intel's group signature scheme for trusted hardware\n  // It keeps the machine anonymous while allowing the client to use a single public verification key to verify\n\n  uint32_t extended_epid_group_id = 0;\n  ret = sgx_get_extended_epid_group_id(&extended_epid_group_id);\n  if (SGX_SUCCESS != (sgx_status_t)ret) {\n    fprintf(stdout, \"\\nError, call sgx_get_extended_epid_group_id fail [%s].\", __FUNCTION__);\n    jbyteArray array_ret = env->NewByteArray(0);\n    return array_ret;\n  }\n\n#ifdef DEBUG\n  fprintf(stdout, \"\\nCall sgx_get_extended_epid_group_id success.\");\n#endif\n\n  // The ISV application sends msg0 to the SP.\n  // The ISV decides whether to support this extended epid group id.\n#ifdef DEBUG\n  fprintf(stdout, \"\\nSending msg0 to remote attestation service provider.\\n\");\n#endif\n\n  jbyteArray array_ret = env->NewByteArray(sizeof(uint32_t));\n  env->SetByteArrayRegion(array_ret, 0, sizeof(uint32_t), (jbyte *) &extended_epid_group_id);\n\n  return array_ret;\n}\n\nJNIEXPORT jbyteArray JNICALL Java_edu_berkeley_cs_rise_opaque_execution_SGXEnclave_RemoteAttestation1(\n    JNIEnv *env, jobject obj,\n    jlong eid) {\n\n  (void)env;\n  (void)obj;\n  (void)eid;\n\n  // Remote attestation will be initiated when the ISV server challenges the ISV\n  // app or if the ISV app detects it doesn't have the credentials\n  // (shared secret) from a previous attestation required for secure\n  // communication with the server.\n\n  int ret = 0;\n  int enclave_lost_retry_time = 2;\n  sgx_status_t status;\n\n  // Ideally, this check would be around the full attestation flow.\n  do {\n    ret = ecall_enclave_init_ra(eid,\n                                &status,\n                                false,\n                                &context);\n  } while (SGX_ERROR_ENCLAVE_LOST == ret && enclave_lost_retry_time--);\n\n  if (status != SGX_SUCCESS) {\n    printf(\"[RemoteAttestation1] enclave_init_ra's status is %u\\n\", (uint32_t) status);\n    std::exit(1);\n  }\n\n  uint8_t *msg1 = (uint8_t *) malloc(sizeof(sgx_ra_msg1_t));\n\n#ifdef DEBUG\n  printf(\"[RemoteAttestation1] context is %u, eid: %u\\n\", (uint32_t) context, (uint32_t) eid);\n#endif\n\n  ret = sgx_ra_get_msg1(context, eid, sgx_ra_get_ga, (sgx_ra_msg1_t*) msg1);\n\n  if(SGX_SUCCESS != ret) {\n    ret = -1;\n    fprintf(stdout, \"\\nError, call sgx_ra_get_msg1 fail [%s].\", __FUNCTION__);\n    jbyteArray array_ret = env->NewByteArray(0);\n    return array_ret;\n  } else {\n#ifdef DEBUG\n    fprintf(stdout, \"\\nCall sgx_ra_get_msg1 success.\\n\");\n    fprintf(stdout, \"\\nMSG1 body generated -\\n\");\n    PRINT_BYTE_ARRAY(stdout, msg1, sizeof(sgx_ra_msg1_t));\n#endif\n  }\n\n  // The ISV application sends msg1 to the SP to get msg2,\n  // msg2 needs to be freed when no longer needed.\n  // The ISV decides whether to use linkable or unlinkable signatures.\n#ifdef DEBUG\n  fprintf(stdout, \"\\nSending msg1 to remote attestation service provider.\"\n          \"Expecting msg2 back.\\n\");\n#endif\n\n  jbyteArray array_ret = env->NewByteArray(sizeof(sgx_ra_msg1_t));\n  env->SetByteArrayRegion(array_ret, 0, sizeof(sgx_ra_msg1_t), (jbyte *) msg1);\n\n  free(msg1);\n\n  return array_ret;\n}\n\nJNIEXPORT jbyteArray JNICALL Java_edu_berkeley_cs_rise_opaque_execution_SGXEnclave_RemoteAttestation2(\n    JNIEnv *env, jobject obj,\n    jlong eid,\n    jbyteArray msg2_input) {\n\n  (void)env;\n  (void)obj;\n\n  int ret = 0;\n  //sgx_ra_context_t context = INT_MAX;\n\n  (void)ret;\n  (void)eid;\n  // Successfully sent msg1 and received a msg2 back.\n  // Time now to check msg2.\n\n  //uint32_t input_len = (uint32_t) env->GetArrayLength(msg2_input);\n  jboolean if_copy = false;\n  jbyte *ptr = env->GetByteArrayElements(msg2_input, &if_copy);\n  sgx_ra_msg2_t* p_msg2_body = (sgx_ra_msg2_t*)(ptr);\n\n#ifdef DEBUG\n  printf(\"Printing p_msg2_body\\n\");\n  PRINT_BYTE_ARRAY(stdout, p_msg2_body, sizeof(sgx_ra_msg2_t));\n#endif\n\n  uint32_t msg3_size = 0;\n  sgx_ra_msg3_t *msg3 = NULL;\n\n  // The ISV app now calls uKE sgx_ra_proc_msg2,\n  // The ISV app is responsible for freeing the returned p_msg3!\n#ifdef DEBUG\n  printf(\"[RemoteAttestation2] context is %u, eid: %u\\n\", (uint32_t) context, (uint32_t) eid);\n#endif\n  ret = sgx_ra_proc_msg2(context,\n                         eid,\n                         sgx_ra_proc_msg2_trusted,\n                         sgx_ra_get_msg3_trusted,\n                         p_msg2_body,\n                         sizeof(sgx_ra_msg2_t),\n                         &msg3,\n                         &msg3_size);\n\n  if (!msg3) {\n    fprintf(stdout, \"\\nError, call sgx_ra_proc_msg2 fail. msg3 = 0x%p [%s].\\n\", msg3, __FUNCTION__);\n    print_error_message((sgx_status_t) ret);\n    jbyteArray array_ret = env->NewByteArray(0);\n    return array_ret;\n  }\n\n  if(SGX_SUCCESS != (sgx_status_t)ret) {\n    fprintf(stdout, \"\\nError, call sgx_ra_proc_msg2 fail. \"\n            \"ret = 0x%08x [%s].\\n\", ret, __FUNCTION__);\n    print_error_message((sgx_status_t) ret);\n    jbyteArray array_ret = env->NewByteArray(0);\n    return array_ret;\n  } else {\n#ifdef DEBUG\n    fprintf(stdout, \"\\nCall sgx_ra_proc_msg2 success.\\n\");\n#endif\n  }\n\n  jbyteArray array_ret = env->NewByteArray(msg3_size);\n  env->SetByteArrayRegion(array_ret, 0, msg3_size, (jbyte *) msg3);\n\n  free(msg3);\n  return array_ret;\n}\n\n\nJNIEXPORT void JNICALL Java_edu_berkeley_cs_rise_opaque_execution_SGXEnclave_RemoteAttestation3(\n    JNIEnv *env, jobject obj,\n    jlong eid,\n    jbyteArray att_result_input) {\n\n  (void)env;\n  (void)obj;\n\n#ifdef DEBUG\n  printf(\"RemoteAttestation3 called\\n\");\n#endif\n\n  sgx_status_t status = SGX_SUCCESS;\n  //uint32_t input_len = (uint32_t) env->GetArrayLength(att_result_input);\n  jboolean if_copy = false;\n  jbyte *ptr = env->GetByteArrayElements(att_result_input, &if_copy);\n\n  ra_samp_response_header_t *att_result_full = (ra_samp_response_header_t *)(ptr);\n  sample_ra_att_result_msg_t *att_result = (sample_ra_att_result_msg_t *) att_result_full->body;\n\n#ifdef DEBUG\n  printf(\"[RemoteAttestation3] att_result's size is %u\\n\", att_result_full->size);\n#endif\n\n  // Check the MAC using MK on the attestation result message.\n  // The format of the attestation result message is ISV specific.\n  // This is a simple form for demonstration. In a real product,\n  // the ISV may want to communicate more information.\n  int ret = 0;\n  ret = ecall_verify_att_result_mac(eid,\n                                    &status,\n                                    context,\n                                    (uint8_t*)&att_result->platform_info_blob,\n                                    sizeof(ias_platform_info_blob_t),\n                                    (uint8_t*)&att_result->mac,\n                                    sizeof(sgx_mac_t));\n\n  if((SGX_SUCCESS != ret) || (SGX_SUCCESS != status)) {\n    fprintf(stdout, \"\\nError: INTEGRITY FAILED - attestation result message MK based cmac failed in [%s], status is %u\", __FUNCTION__, (uint32_t) status);\n    return ;\n  }\n\n  bool attestation_passed = true;\n  // Check the attestation result for pass or fail.\n  // Whether attestation passes or fails is a decision made by the ISV Server.\n  // When the ISV server decides to trust the enclave, then it will return success.\n  // When the ISV server decided to not trust the enclave, then it will return failure.\n  if (0 != att_result_full->status[0] || 0 != att_result_full->status[1]) {\n    fprintf(stdout, \"\\nError, attestation result message MK based cmac \"\n            \"failed in [%s].\", __FUNCTION__);\n    attestation_passed = false;\n  }\n\n  // The attestation result message should contain a field for the Platform\n  // Info Blob (PIB).  The PIB is returned by attestation server in the attestation report.\n  // It is not returned in all cases, but when it is, the ISV app\n  // should pass it to the blob analysis API called sgx_report_attestation_status()\n  // along with the trust decision from the ISV server.\n  // The ISV application will take action based on the update_info.\n  // returned in update_info by the API.\n  // This call is stubbed out for the sample.\n  //\n  // sgx_update_info_bit_t update_info;\n  // ret = sgx_report_attestation_status(\n  //     &p_att_result_msg_body->platform_info_blob,\n  //     attestation_passed ? 0 : 1, &update_info);\n\n  // Get the shared secret sent by the server using SK (if attestation\n  // passed)\n#ifdef DEBUG\n  printf(\"[RemoteAttestation3] %u\\n\", attestation_passed);\n#endif\n  if (attestation_passed) {\n    ret = ecall_put_secret_data(eid,\n                                &status,\n                                context,\n                                att_result->secret.payload,\n                                att_result->secret.payload_size,\n                                att_result->secret.payload_tag);\n\n    if((SGX_SUCCESS != ret)  || (SGX_SUCCESS != status)) {\n      fprintf(stdout, \"\\nError, attestation result message secret \"\n              \"using SK based AESGCM failed in [%s]. ret = \"\n              \"0x%0x. status = 0x%0x\", __FUNCTION__, ret,\n              status);\n      return ;\n    }\n  }\n\n  fprintf(stdout, \"\\nSecret successfully received from server.\");\n  fprintf(stdout, \"\\nRemote attestation success!\\n\");\n\n#ifdef DEBUG\n  fprintf(stdout, \"Destroying the key exchange context\\n\");\n#endif\n  ecall_enclave_ra_close(eid, context);\n}\n\nJNIEXPORT void JNICALL Java_edu_berkeley_cs_rise_opaque_execution_SGXEnclave_StopEnclave(\n  JNIEnv *env, jobject obj, jlong eid) {\n  (void)env;\n  (void)obj;\n\n  sgx_check(\"StopEnclave\", sgx_destroy_enclave(eid));\n}\n\nJNIEXPORT jbyteArray JNICALL Java_edu_berkeley_cs_rise_opaque_execution_SGXEnclave_Project(\n  JNIEnv *env, jobject obj, jlong eid, jbyteArray project_list, jbyteArray input_rows) {\n  (void)obj;\n\n  jboolean if_copy;\n\n  uint32_t project_list_length = (uint32_t) env->GetArrayLength(project_list);\n  uint8_t *project_list_ptr = (uint8_t *) env->GetByteArrayElements(project_list, &if_copy);\n\n  uint32_t input_rows_length = (uint32_t) env->GetArrayLength(input_rows);\n  uint8_t *input_rows_ptr = (uint8_t *) env->GetByteArrayElements(input_rows, &if_copy);\n\n  uint8_t *output_rows;\n  size_t output_rows_length;\n\n  sgx_check(\"Project\",\n            ecall_project(\n              eid,\n              project_list_ptr, project_list_length,\n              input_rows_ptr, input_rows_length,\n              &output_rows, &output_rows_length));\n\n  env->ReleaseByteArrayElements(project_list, (jbyte *) project_list_ptr, 0);\n  env->ReleaseByteArrayElements(input_rows, (jbyte *) input_rows_ptr, 0);\n\n  jbyteArray ret = env->NewByteArray(output_rows_length);\n  env->SetByteArrayRegion(ret, 0, output_rows_length, (jbyte *) output_rows);\n  free(output_rows);\n\n  return ret;\n}\n\nJNIEXPORT jbyteArray JNICALL Java_edu_berkeley_cs_rise_opaque_execution_SGXEnclave_Filter(\n  JNIEnv *env, jobject obj, jlong eid, jbyteArray condition, jbyteArray input_rows) {\n  (void)obj;\n\n  jboolean if_copy;\n\n  size_t condition_length = (size_t) env->GetArrayLength(condition);\n  uint8_t *condition_ptr = (uint8_t *) env->GetByteArrayElements(condition, &if_copy);\n\n  uint32_t input_rows_length = (uint32_t) env->GetArrayLength(input_rows);\n  uint8_t *input_rows_ptr = (uint8_t *) env->GetByteArrayElements(input_rows, &if_copy);\n\n  uint8_t *output_rows;\n  size_t output_rows_length;\n\n  sgx_check(\"Filter\",\n            ecall_filter(\n              eid,\n              condition_ptr, condition_length,\n              input_rows_ptr, input_rows_length,\n              &output_rows, &output_rows_length));\n\n  env->ReleaseByteArrayElements(condition, (jbyte *) condition_ptr, 0);\n  env->ReleaseByteArrayElements(input_rows, (jbyte *) input_rows_ptr, 0);\n\n  jbyteArray ret = env->NewByteArray(output_rows_length);\n  env->SetByteArrayRegion(ret, 0, output_rows_length, (jbyte *) output_rows);\n  free(output_rows);\n\n  return ret;\n}\n\nJNIEXPORT jbyteArray JNICALL Java_edu_berkeley_cs_rise_opaque_execution_SGXEnclave_Encrypt(\n  JNIEnv *env, jobject obj, jlong eid, jbyteArray plaintext) {\n  (void)obj;\n\n  uint32_t plength = (uint32_t) env->GetArrayLength(plaintext);\n  jboolean if_copy = false;\n  jbyte *ptr = env->GetByteArrayElements(plaintext, &if_copy);\n\n  uint8_t *plaintext_ptr = (uint8_t *) ptr;\n\n  const jsize clength = plength + SGX_AESGCM_IV_SIZE + SGX_AESGCM_MAC_SIZE;\n  jbyteArray ciphertext = env->NewByteArray(clength);\n\n  uint8_t *ciphertext_copy = new uint8_t[clength];\n\n  sgx_check_quiet(\n    \"Encrypt\", ecall_encrypt(eid, plaintext_ptr, plength, ciphertext_copy, (uint32_t) clength));\n\n  env->SetByteArrayRegion(ciphertext, 0, clength, (jbyte *) ciphertext_copy);\n\n  env->ReleaseByteArrayElements(plaintext, ptr, 0);\n\n  delete[] ciphertext_copy;\n\n  return ciphertext;\n}\n\nJNIEXPORT jbyteArray JNICALL Java_edu_berkeley_cs_rise_opaque_execution_SGXEnclave_Sample(\n  JNIEnv *env, jobject obj, jlong eid, jbyteArray input_rows) {\n  (void)obj;\n\n  jboolean if_copy;\n  size_t input_rows_length = static_cast<size_t>(env->GetArrayLength(input_rows));\n  uint8_t *input_rows_ptr = reinterpret_cast<uint8_t *>(\n    env->GetByteArrayElements(input_rows, &if_copy));\n\n  uint8_t *output_rows;\n  size_t output_rows_length;\n\n  sgx_check(\"Sample\",\n            ecall_sample(\n              eid,\n              input_rows_ptr, input_rows_length,\n              &output_rows, &output_rows_length));\n\n  jbyteArray ret = env->NewByteArray(output_rows_length);\n  env->SetByteArrayRegion(ret, 0, output_rows_length, (jbyte *) output_rows);\n  free(output_rows);\n\n  env->ReleaseByteArrayElements(input_rows, (jbyte *) input_rows_ptr, 0);\n\n  return ret;\n}\n\nJNIEXPORT jbyteArray JNICALL Java_edu_berkeley_cs_rise_opaque_execution_SGXEnclave_FindRangeBounds(\n  JNIEnv *env, jobject obj, jlong eid, jbyteArray sort_order, jint num_partitions,\n  jbyteArray input_rows) {\n  (void)obj;\n\n  jboolean if_copy;\n\n  size_t sort_order_length = static_cast<size_t>(env->GetArrayLength(sort_order));\n  uint8_t *sort_order_ptr = reinterpret_cast<uint8_t *>(\n    env->GetByteArrayElements(sort_order, &if_copy));\n\n  size_t input_rows_length = static_cast<size_t>(env->GetArrayLength(input_rows));\n  uint8_t *input_rows_ptr = reinterpret_cast<uint8_t *>(\n    env->GetByteArrayElements(input_rows, &if_copy));\n\n  uint8_t *output_rows;\n  size_t output_rows_length;\n\n  sgx_check(\"Find Range Bounds\",\n            ecall_find_range_bounds(\n              eid,\n              sort_order_ptr, sort_order_length,\n              num_partitions,\n              input_rows_ptr, input_rows_length,\n              &output_rows, &output_rows_length));\n\n  jbyteArray ret = env->NewByteArray(output_rows_length);\n  env->SetByteArrayRegion(ret, 0, output_rows_length, reinterpret_cast<jbyte *>(output_rows));\n  free(output_rows);\n\n  env->ReleaseByteArrayElements(sort_order, reinterpret_cast<jbyte *>(sort_order_ptr), 0);\n  env->ReleaseByteArrayElements(input_rows, reinterpret_cast<jbyte *>(input_rows_ptr), 0);\n\n  return ret;\n}\n\nJNIEXPORT jobjectArray JNICALL\nJava_edu_berkeley_cs_rise_opaque_execution_SGXEnclave_PartitionForSort(\n  JNIEnv *env, jobject obj, jlong eid, jbyteArray sort_order, jint num_partitions,\n  jbyteArray input_rows, jbyteArray boundary_rows) {\n  (void)obj;\n\n  jboolean if_copy;\n\n  size_t sort_order_length = static_cast<size_t>(env->GetArrayLength(sort_order));\n  uint8_t *sort_order_ptr = reinterpret_cast<uint8_t *>(\n    env->GetByteArrayElements(sort_order, &if_copy));\n\n  size_t input_rows_length = static_cast<size_t>(env->GetArrayLength(input_rows));\n  uint8_t *input_rows_ptr = reinterpret_cast<uint8_t *>(\n    env->GetByteArrayElements(input_rows, &if_copy));\n\n  size_t boundary_rows_length = static_cast<size_t>(env->GetArrayLength(boundary_rows));\n  uint8_t *boundary_rows_ptr = reinterpret_cast<uint8_t *>(\n    env->GetByteArrayElements(boundary_rows, &if_copy));\n\n  uint8_t **output_partitions = new uint8_t *[num_partitions];\n  size_t *output_partition_lengths = new size_t[num_partitions];\n\n  sgx_check(\"Partition For Sort\",\n            ecall_partition_for_sort(\n              eid,\n              sort_order_ptr, sort_order_length,\n              num_partitions,\n              input_rows_ptr, input_rows_length,\n              boundary_rows_ptr, boundary_rows_length,\n              output_partitions, output_partition_lengths));\n\n  env->ReleaseByteArrayElements(sort_order, reinterpret_cast<jbyte *>(sort_order_ptr), 0);\n  env->ReleaseByteArrayElements(input_rows, reinterpret_cast<jbyte *>(input_rows_ptr), 0);\n  env->ReleaseByteArrayElements(boundary_rows, reinterpret_cast<jbyte *>(boundary_rows_ptr), 0);\n\n  jobjectArray result = env->NewObjectArray(num_partitions,  env->FindClass(\"[B\"), nullptr);\n  for (jint i = 0; i < num_partitions; i++) {\n    jbyteArray partition = env->NewByteArray(output_partition_lengths[i]);\n    env->SetByteArrayRegion(partition, 0, output_partition_lengths[i],\n                            reinterpret_cast<jbyte *>(output_partitions[i]));\n    free(output_partitions[i]);\n    env->SetObjectArrayElement(result, i, partition);\n  }\n  delete[] output_partitions;\n  delete[] output_partition_lengths;\n\n  return result;\n}\n\nJNIEXPORT jbyteArray JNICALL Java_edu_berkeley_cs_rise_opaque_execution_SGXEnclave_ExternalSort(\n  JNIEnv *env, jobject obj, jlong eid, jbyteArray sort_order, jbyteArray input_rows) {\n  (void)obj;\n\n  jboolean if_copy;\n\n  size_t sort_order_length = static_cast<size_t>(env->GetArrayLength(sort_order));\n  uint8_t *sort_order_ptr = reinterpret_cast<uint8_t *>(\n    env->GetByteArrayElements(sort_order, &if_copy));\n\n  size_t input_rows_length = static_cast<size_t>(env->GetArrayLength(input_rows));\n  uint8_t *input_rows_ptr = reinterpret_cast<uint8_t *>(\n    env->GetByteArrayElements(input_rows, &if_copy));\n\n  uint8_t *output_rows;\n  size_t output_rows_length;\n\n  sgx_check(\"External non-oblivious sort\",\n            ecall_external_sort(eid,\n                                sort_order_ptr, sort_order_length,\n                                input_rows_ptr, input_rows_length,\n                                &output_rows, &output_rows_length));\n\n  jbyteArray ret = env->NewByteArray(output_rows_length);\n  env->SetByteArrayRegion(ret, 0, output_rows_length, reinterpret_cast<jbyte *>(output_rows));\n  free(output_rows);\n\n  env->ReleaseByteArrayElements(sort_order, reinterpret_cast<jbyte *>(sort_order_ptr), 0);\n  env->ReleaseByteArrayElements(input_rows, reinterpret_cast<jbyte *>(input_rows_ptr), 0);\n\n  return ret;\n}\n\nJNIEXPORT jbyteArray JNICALL\nJava_edu_berkeley_cs_rise_opaque_execution_SGXEnclave_ScanCollectLastPrimary(\n  JNIEnv *env, jobject obj, jlong eid, jbyteArray join_expr, jbyteArray input_rows) {\n  (void)obj;\n\n  jboolean if_copy;\n\n  uint32_t join_expr_length = (uint32_t) env->GetArrayLength(join_expr);\n  uint8_t *join_expr_ptr = (uint8_t *) env->GetByteArrayElements(join_expr, &if_copy);\n\n  uint32_t input_rows_length = (uint32_t) env->GetArrayLength(input_rows);\n  uint8_t *input_rows_ptr = (uint8_t *) env->GetByteArrayElements(input_rows, &if_copy);\n\n  uint8_t *output_rows;\n  size_t output_rows_length;\n\n  sgx_check(\"Scan Collect Last Primary\",\n            ecall_scan_collect_last_primary(\n              eid,\n              join_expr_ptr, join_expr_length,\n              input_rows_ptr, input_rows_length,\n              &output_rows, &output_rows_length));\n\n  jbyteArray ret = env->NewByteArray(output_rows_length);\n  env->SetByteArrayRegion(ret, 0, output_rows_length, (jbyte *) output_rows);\n  free(output_rows);\n\n  env->ReleaseByteArrayElements(join_expr, (jbyte *) join_expr_ptr, 0);\n  env->ReleaseByteArrayElements(input_rows, (jbyte *) input_rows_ptr, 0);\n\n  return ret;\n}\n\nJNIEXPORT jbyteArray JNICALL\nJava_edu_berkeley_cs_rise_opaque_execution_SGXEnclave_NonObliviousSortMergeJoin(\n  JNIEnv *env, jobject obj, jlong eid, jbyteArray join_expr, jbyteArray input_rows,\n  jbyteArray join_row) {\n  (void)obj;\n\n  jboolean if_copy;\n\n  uint32_t join_expr_length = (uint32_t) env->GetArrayLength(join_expr);\n  uint8_t *join_expr_ptr = (uint8_t *) env->GetByteArrayElements(join_expr, &if_copy);\n\n  uint32_t input_rows_length = (uint32_t) env->GetArrayLength(input_rows);\n  uint8_t *input_rows_ptr = (uint8_t *) env->GetByteArrayElements(input_rows, &if_copy);\n\n  uint32_t join_row_length = (uint32_t) env->GetArrayLength(join_row);\n  uint8_t *join_row_ptr = (uint8_t *) env->GetByteArrayElements(join_row, &if_copy);\n\n  uint8_t *output_rows;\n  size_t output_rows_length;\n\n  sgx_check(\"Non-oblivious SortMergeJoin\",\n            ecall_non_oblivious_sort_merge_join(\n              eid,\n              join_expr_ptr, join_expr_length,\n              input_rows_ptr, input_rows_length,\n              join_row_ptr, join_row_length,\n              &output_rows, &output_rows_length));\n  \n  jbyteArray ret = env->NewByteArray(output_rows_length);\n  env->SetByteArrayRegion(ret, 0, output_rows_length, (jbyte *) output_rows);\n  free(output_rows);\n\n  env->ReleaseByteArrayElements(join_expr, (jbyte *) join_expr_ptr, 0);\n  env->ReleaseByteArrayElements(input_rows, (jbyte *) input_rows_ptr, 0);\n  env->ReleaseByteArrayElements(join_row, (jbyte *) join_row_ptr, 0);\n\n  return ret;\n}\n\nJNIEXPORT jobject JNICALL\nJava_edu_berkeley_cs_rise_opaque_execution_SGXEnclave_NonObliviousAggregateStep1(\n  JNIEnv *env, jobject obj, jlong eid, jbyteArray agg_op, jbyteArray input_rows) {\n  (void)obj;\n\n  jboolean if_copy;\n\n  uint32_t agg_op_length = (uint32_t) env->GetArrayLength(agg_op);\n  uint8_t *agg_op_ptr = (uint8_t *) env->GetByteArrayElements(agg_op, &if_copy);\n\n  uint32_t input_rows_length = (uint32_t) env->GetArrayLength(input_rows);\n  uint8_t *input_rows_ptr = (uint8_t *) env->GetByteArrayElements(input_rows, &if_copy);\n\n  uint8_t *first_row;\n  size_t first_row_length;\n\n  uint8_t *last_group;\n  size_t last_group_length;\n\n  uint8_t *last_row;\n  size_t last_row_length;\n\n  sgx_check(\"Non-Oblivious Aggregate Step 1\",\n            ecall_non_oblivious_aggregate_step1(\n              eid,\n              agg_op_ptr, agg_op_length,\n              input_rows_ptr, input_rows_length,\n              &first_row, &first_row_length,\n              &last_group, &last_group_length,\n              &last_row, &last_row_length));\n\n  jbyteArray first_row_array = env->NewByteArray(first_row_length);\n  env->SetByteArrayRegion(first_row_array, 0, first_row_length, (jbyte *) first_row);\n  free(first_row);\n\n  jbyteArray last_group_array = env->NewByteArray(last_group_length);\n  env->SetByteArrayRegion(last_group_array, 0, last_group_length, (jbyte *) last_group);\n  free(last_group);\n\n  jbyteArray last_row_array = env->NewByteArray(last_row_length);\n  env->SetByteArrayRegion(last_row_array, 0, last_row_length, (jbyte *) last_row);\n  free(last_row);\n\n  env->ReleaseByteArrayElements(agg_op, (jbyte *) agg_op_ptr, 0);\n  env->ReleaseByteArrayElements(input_rows, (jbyte *) input_rows_ptr, 0);\n\n  jclass tuple3_class = env->FindClass(\"scala/Tuple3\");\n  jobject ret = env->NewObject(\n    tuple3_class,\n    env->GetMethodID(tuple3_class, \"<init>\",\n                     \"(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)V\"),\n    first_row_array, last_group_array, last_row_array);\n\n  return ret;\n}\n\nJNIEXPORT jbyteArray JNICALL\nJava_edu_berkeley_cs_rise_opaque_execution_SGXEnclave_NonObliviousAggregateStep2(\n  JNIEnv *env, jobject obj, jlong eid, jbyteArray agg_op, jbyteArray input_rows,\n  jbyteArray next_partition_first_row, jbyteArray prev_partition_last_group,\n  jbyteArray prev_partition_last_row) {\n  (void)obj;\n\n  jboolean if_copy;\n\n  uint32_t agg_op_length = (uint32_t) env->GetArrayLength(agg_op);\n  uint8_t *agg_op_ptr = (uint8_t *) env->GetByteArrayElements(agg_op, &if_copy);\n\n  uint32_t input_rows_length = (uint32_t) env->GetArrayLength(input_rows);\n  uint8_t *input_rows_ptr = (uint8_t *) env->GetByteArrayElements(input_rows, &if_copy);\n\n  uint32_t next_partition_first_row_length =\n    (uint32_t) env->GetArrayLength(next_partition_first_row);\n  uint8_t *next_partition_first_row_ptr =\n    (uint8_t *) env->GetByteArrayElements(next_partition_first_row, &if_copy);\n\n  uint32_t prev_partition_last_group_length =\n    (uint32_t) env->GetArrayLength(prev_partition_last_group);\n  uint8_t *prev_partition_last_group_ptr =\n    (uint8_t *) env->GetByteArrayElements(prev_partition_last_group, &if_copy);\n\n  uint32_t prev_partition_last_row_length =\n    (uint32_t) env->GetArrayLength(prev_partition_last_row);\n  uint8_t *prev_partition_last_row_ptr =\n    (uint8_t *) env->GetByteArrayElements(prev_partition_last_row, &if_copy);\n\n  uint8_t *output_rows;\n  size_t output_rows_length;\n\n  sgx_check(\"Non-Oblivious Aggregate Step 2\",\n            ecall_non_oblivious_aggregate_step2(\n              eid,\n              agg_op_ptr, agg_op_length,\n              input_rows_ptr, input_rows_length,\n              next_partition_first_row_ptr, next_partition_first_row_length,\n              prev_partition_last_group_ptr, prev_partition_last_group_length,\n              prev_partition_last_row_ptr, prev_partition_last_row_length,\n              &output_rows, &output_rows_length));\n\n  jbyteArray ret = env->NewByteArray(output_rows_length);\n  env->SetByteArrayRegion(ret, 0, output_rows_length, (jbyte *) output_rows);\n  free(output_rows);\n\n  env->ReleaseByteArrayElements(agg_op, (jbyte *) agg_op_ptr, 0);\n  env->ReleaseByteArrayElements(input_rows, (jbyte *) input_rows_ptr, 0);\n  env->ReleaseByteArrayElements(\n    next_partition_first_row, (jbyte *) next_partition_first_row_ptr, 0);\n  env->ReleaseByteArrayElements(\n    prev_partition_last_group, (jbyte *) prev_partition_last_group_ptr, 0);\n  env->ReleaseByteArrayElements(\n    prev_partition_last_row, (jbyte *) prev_partition_last_row_ptr, 0);\n\n  return ret;\n}\n\n/* application entry */\n//SGX_CDECL\nint SGX_CDECL main(int argc, char *argv[])\n{\n  (void)(argc);\n  (void)(argv);\n\n#if defined(_MSC_VER)\n  if (query_sgx_status() < 0) {\n    /* either SGX is disabled, or a reboot is required to enable SGX */\n    printf(\"Enter a character before exit ...\\n\");\n    getchar();\n    return -1;\n  }\n#endif\n\n  /* Initialize the enclave */\n  if(initialize_enclave() < 0){\n    printf(\"Enter a character before exit ...\\n\");\n    getchar();\n    return -1;\n  }\n\n  /* Destroy the enclave */\n  sgx_destroy_enclave(global_eid);\n\n  printf(\"Info: SampleEnclave successfully returned.\\n\");\n\n  return 0;\n}\n", "#include \"Enclave_t.h\"\n\n#include <cstdint>\n#include <cassert>\n\n#include \"Aggregate.h\"\n#include \"Crypto.h\"\n#include \"Filter.h\"\n#include \"Join.h\"\n#include \"Project.h\"\n#include \"Sort.h\"\n#include \"isv_enclave.h\"\n#include \"util.h\"\n\n// This file contains definitions of the ecalls declared in Enclave.edl. Errors originating within\n// these ecalls are signaled by throwing a std::runtime_error, which is caught at the top level of\n// the ecall (i.e., within these definitions), and are then rethrown as Java exceptions using\n// ocall_throw.\n\nvoid ecall_encrypt(uint8_t *plaintext, uint32_t plaintext_length,\n                   uint8_t *ciphertext, uint32_t cipher_length) {\n  try {\n    // IV (12 bytes) + ciphertext + mac (16 bytes)\n    assert(cipher_length >= plaintext_length + SGX_AESGCM_IV_SIZE + SGX_AESGCM_MAC_SIZE);\n    (void)cipher_length;\n    (void)plaintext_length;\n    encrypt(plaintext, plaintext_length, ciphertext);\n  } catch (const std::runtime_error &e) {\n    ocall_throw(e.what());\n  }\n}\n\nvoid ecall_project(uint8_t *condition, size_t condition_length,\n                   uint8_t *input_rows, size_t input_rows_length,\n                   uint8_t **output_rows, size_t *output_rows_length) {\n  try {\n    project(condition, condition_length,\n            input_rows, input_rows_length,\n            output_rows, output_rows_length);\n  } catch (const std::runtime_error &e) {\n    ocall_throw(e.what());\n  }\n}\n\nvoid ecall_filter(uint8_t *condition, size_t condition_length,\n                  uint8_t *input_rows, size_t input_rows_length,\n                  uint8_t **output_rows, size_t *output_rows_length) {\n  try {\n    filter(condition, condition_length,\n           input_rows, input_rows_length,\n           output_rows, output_rows_length);\n  } catch (const std::runtime_error &e) {\n    ocall_throw(e.what());\n  }\n}\n\nvoid ecall_sample(uint8_t *input_rows, size_t input_rows_length,\n                  uint8_t **output_rows, size_t *output_rows_length) {\n  try {\n    sample(input_rows, input_rows_length,\n           output_rows, output_rows_length);\n  } catch (const std::runtime_error &e) {\n    ocall_throw(e.what());\n  }\n}\n\nvoid ecall_find_range_bounds(uint8_t *sort_order, size_t sort_order_length,\n                             uint32_t num_partitions,\n                             uint8_t *input_rows, size_t input_rows_length,\n                             uint8_t **output_rows, size_t *output_rows_length) {\n  try {\n    find_range_bounds(sort_order, sort_order_length,\n                      num_partitions,\n                      input_rows, input_rows_length,\n                      output_rows, output_rows_length);\n  } catch (const std::runtime_error &e) {\n    ocall_throw(e.what());\n  }\n}\n\nvoid ecall_partition_for_sort(uint8_t *sort_order, size_t sort_order_length,\n                              uint32_t num_partitions,\n                              uint8_t *input_rows, size_t input_rows_length,\n                              uint8_t *boundary_rows, size_t boundary_rows_length,\n                              uint8_t **output_partitions, size_t *output_partition_lengths) {\n  try {\n    partition_for_sort(sort_order, sort_order_length,\n                       num_partitions,\n                       input_rows, input_rows_length,\n                       boundary_rows, boundary_rows_length,\n                       output_partitions, output_partition_lengths);\n  } catch (const std::runtime_error &e) {\n    ocall_throw(e.what());\n  }\n}\n\nvoid ecall_external_sort(uint8_t *sort_order, size_t sort_order_length,\n                         uint8_t *input_rows, size_t input_rows_length,\n                         uint8_t **output_rows, size_t *output_rows_length) {\n  try {\n    external_sort(sort_order, sort_order_length,\n                  input_rows, input_rows_length,\n                  output_rows, output_rows_length);\n  } catch (const std::runtime_error &e) {\n    ocall_throw(e.what());\n  }\n}\n\nvoid ecall_scan_collect_last_primary(uint8_t *join_expr, size_t join_expr_length,\n                                     uint8_t *input_rows, size_t input_rows_length,\n                                     uint8_t **output_rows, size_t *output_rows_length) {\n  try {\n    scan_collect_last_primary(join_expr, join_expr_length,\n                              input_rows, input_rows_length,\n                              output_rows, output_rows_length);\n  } catch (const std::runtime_error &e) {\n    ocall_throw(e.what());\n  }\n}\n\nvoid ecall_non_oblivious_sort_merge_join(uint8_t *join_expr, size_t join_expr_length,\n                                         uint8_t *input_rows, size_t input_rows_length,\n                                         uint8_t *join_row, size_t join_row_length,\n                                         uint8_t **output_rows, size_t *output_rows_length) {\n  try {\n    non_oblivious_sort_merge_join(join_expr, join_expr_length,\n                                  input_rows, input_rows_length,\n                                  join_row, join_row_length,\n                                  output_rows, output_rows_length);\n  } catch (const std::runtime_error &e) {\n    ocall_throw(e.what());\n  }\n}\n\nvoid ecall_non_oblivious_aggregate_step1(\n  uint8_t *agg_op, size_t agg_op_length,\n  uint8_t *input_rows, size_t input_rows_length,\n  uint8_t **first_row, size_t *first_row_length,\n  uint8_t **last_group, size_t *last_group_length,\n  uint8_t **last_row, size_t *last_row_length) {\n  try {\n    non_oblivious_aggregate_step1(\n      agg_op, agg_op_length,\n      input_rows, input_rows_length,\n      first_row, first_row_length,\n      last_group, last_group_length,\n      last_row, last_row_length);\n  } catch (const std::runtime_error &e) {\n    ocall_throw(e.what());\n  }\n}\n\nvoid ecall_non_oblivious_aggregate_step2(\n  uint8_t *agg_op, size_t agg_op_length,\n  uint8_t *input_rows, size_t input_rows_length,\n  uint8_t *next_partition_first_row, size_t next_partition_first_row_length,\n  uint8_t *prev_partition_last_group, size_t prev_partition_last_group_length,\n  uint8_t *prev_partition_last_row, size_t prev_partition_last_row_length,\n  uint8_t **output_rows, size_t *output_rows_length) {\n  try {\n    non_oblivious_aggregate_step2(\n      agg_op, agg_op_length,\n      input_rows, input_rows_length,\n      next_partition_first_row, next_partition_first_row_length,\n      prev_partition_last_group, prev_partition_last_group_length,\n      prev_partition_last_row, prev_partition_last_row_length,\n      output_rows, output_rows_length);\n  } catch (const std::runtime_error &e) {\n    ocall_throw(e.what());\n  }\n}\n\nsgx_status_t ecall_enclave_init_ra(int b_pse, sgx_ra_context_t *p_context) {\n  try {\n    return enclave_init_ra(b_pse, p_context);\n  } catch (const std::runtime_error &e) {\n    ocall_throw(e.what());\n    return SGX_ERROR_UNEXPECTED;\n  }\n}\n\n\nvoid ecall_enclave_ra_close(sgx_ra_context_t context) {\n  try {\n    enclave_ra_close(context);\n  } catch (const std::runtime_error &e) {\n    ocall_throw(e.what());\n  }\n}\n\nsgx_status_t ecall_verify_att_result_mac(sgx_ra_context_t context, uint8_t* message,\n                                         size_t message_size, uint8_t* mac,\n                                         size_t mac_size) {\n  try {\n    return verify_att_result_mac(context, message, message_size, mac, mac_size);\n  } catch (const std::runtime_error &e) {\n    ocall_throw(e.what());\n    return SGX_ERROR_UNEXPECTED;\n  }\n}\n\nsgx_status_t ecall_put_secret_data(sgx_ra_context_t context,\n                                   uint8_t* p_secret,\n                                   uint32_t secret_size,\n                                   uint8_t* gcm_mac) {\n  try {\n    return put_secret_data(context, p_secret, secret_size, gcm_mac);\n  } catch (const std::runtime_error &e) {\n    ocall_throw(e.what());\n    return SGX_ERROR_UNEXPECTED;\n  }\n}\n", "// -*- mode: c++ -*-\n/* Enclave.edl - Top EDL file. */\n\nenclave {\n\n  include \"stdbool.h\"\n  include \"sgx_key_exchange.h\"\n  include \"sgx_trts.h\"\n  from \"sgx_tkey_exchange.edl\" import *;\n\n  trusted {\n    public void ecall_project(\n      [in, count=project_list_length] uint8_t *project_list, size_t project_list_length,\n      [user_check] uint8_t *input_rows, size_t input_rows_length,\n      [out] uint8_t **output_rows, [out] size_t *output_rows_length);\n\n    public void ecall_filter(\n      [in, count=condition_length] uint8_t *condition, size_t condition_length,\n      [user_check] uint8_t *input_rows, size_t input_rows_length,\n      [out] uint8_t **output_rows, [out] size_t *output_rows_length);\n\n    public void ecall_encrypt(\n      [user_check] uint8_t *plaintext, uint32_t length,\n      [user_check] uint8_t *ciphertext, uint32_t cipher_length);\n\n    public void ecall_sample(\n      [user_check] uint8_t *input_rows, size_t input_rows_length,\n      [out] uint8_t **output_rows, [out] size_t *output_rows_length);\n\n    public void ecall_find_range_bounds(\n      [in, count=sort_order_length] uint8_t *sort_order, size_t sort_order_length,\n      uint32_t num_partitions,\n      [user_check] uint8_t *input_rows, size_t input_rows_length,\n      [out] uint8_t **output_rows, [out] size_t *output_rows_length);\n\n    public void ecall_partition_for_sort(\n      [in, count=sort_order_length] uint8_t *sort_order, size_t sort_order_length,\n      uint32_t num_partitions,\n      [user_check] uint8_t *input_rows, size_t input_rows_length,\n      [user_check] uint8_t *boundary_rows, size_t boundary_rows_length,\n      [out, count=num_partitions] uint8_t **output_partitions,\n      [out, count=num_partitions] size_t *output_partition_lengths);\n\n    public void ecall_external_sort(\n      [in, count=sort_order_length] uint8_t *sort_order, size_t sort_order_length,\n      [user_check] uint8_t *input_rows, size_t input_rows_length,\n      [out] uint8_t **output_rows, [out] size_t *output_rows_length);\n\n    public void ecall_scan_collect_last_primary(\n      [in, count=join_expr_length] uint8_t *join_expr, size_t join_expr_length,\n      [user_check] uint8_t *input_rows, size_t input_rows_length,\n      [out] uint8_t **output_rows, [out] size_t *output_rows_length);\n\n    public void ecall_non_oblivious_sort_merge_join(\n      [in, count=join_expr_length] uint8_t *join_expr, size_t join_expr_length,\n      [user_check] uint8_t *input_rows, size_t input_rows_length,\n      [user_check] uint8_t *join_row, size_t join_row_length,\n      [out] uint8_t **output_rows, [out] size_t *output_rows_length);\n\n    public void ecall_non_oblivious_aggregate_step1(\n      [in, count=agg_op_length] uint8_t *agg_op, size_t agg_op_length,\n      [user_check] uint8_t *input_rows, size_t input_rows_length,\n      [out] uint8_t **first_row, [out] size_t *first_row_length,\n      [out] uint8_t **last_group, [out] size_t *last_group_length,\n      [out] uint8_t **last_row, [out] size_t *last_row_length);\n\n    public void ecall_non_oblivious_aggregate_step2(\n      [in, count=agg_op_length] uint8_t *agg_op, size_t agg_op_length,\n      [user_check] uint8_t *input_rows, size_t input_rows_length,\n      [user_check] uint8_t *next_partition_first_row, size_t next_partition_first_row_length,\n      [user_check] uint8_t *prev_partition_last_group, size_t prev_partition_last_group_length,\n      [user_check] uint8_t *prev_partition_last_row, size_t prev_partition_last_row_length,\n      [out] uint8_t **output_rows, [out] size_t *output_rows_length);\n\n    public sgx_status_t ecall_enclave_init_ra(int b_pse,\n                                              [out] sgx_ra_context_t *p_context);\n    public void ecall_enclave_ra_close(sgx_ra_context_t context);\n    public sgx_status_t ecall_verify_att_result_mac(sgx_ra_context_t context,\n                                                    [in,size=message_size] uint8_t* message,\n                                                    size_t message_size,\n                                                    [in,size=mac_size] uint8_t* mac,\n                                                    size_t mac_size);\n    public sgx_status_t ecall_put_secret_data(sgx_ra_context_t context,\n                                              [in,size=secret_size] uint8_t* p_secret,\n                                              uint32_t secret_size,\n                                              [in,count=16] uint8_t* gcm_mac);\n  };\n\n  untrusted {\n    void ocall_print_string([in, string] const char *str);\n    void ocall_malloc(size_t size, [out] uint8_t **ret);\n    void ocall_free([user_check] uint8_t *buf);\n    void ocall_exit(int exit_code);\n    void ocall_throw([in, string] const char *message);\n  };\n\n};\n", "#include \"util.h\"\n\n#include <climits>\n#include <cstdio>\n\n#include \"Enclave_t.h\"\n\nint printf(const char *fmt, ...) {\n  char buf[BUFSIZ] = {'\\0'};\n  va_list ap;\n  va_start(ap, fmt);\n  int ret = vsnprintf(buf, BUFSIZ, fmt, ap);\n  va_end(ap);\n  ocall_print_string(buf);\n  return ret;\n}\n\n/** From https://stackoverflow.com/a/8362718 */\nstd::string string_format(const std::string &fmt, ...) {\n    int size=BUFSIZ;\n    std::string str;\n    va_list ap;\n    while (1) {\n        str.resize(size);\n        va_start(ap, fmt);\n        int n = vsnprintf(&str[0], size, fmt.c_str(), ap);\n        va_end(ap);\n        if (n > -1 && n < size)\n            return str;\n        if (n > -1)\n            size = n + 1;\n        else\n            size *= 2;\n    }\n}\n\nvoid exit(int exit_code) {\n  ocall_exit(exit_code);\n}\n\nvoid print_bytes(uint8_t *ptr, uint32_t len) {\n  for (uint32_t i = 0; i < len; i++) {\n    printf(\"%u\", *(ptr + i));\n    printf(\" - \");\n  }\n\n  printf(\"\\n\");\n}\n\nint cmp(const uint8_t *value1, const uint8_t *value2, uint32_t len) {\n  for (uint32_t i = 0; i < len; i++) {\n    if (*(value1+i) != *(value2+i)) {\n      return -1;\n    }\n  }\n  return 0;\n}\n\n// basically a memset 0\nvoid clear(uint8_t *dest, uint32_t len) {\n  for (uint32_t i = 0; i < len; i++) {\n    *(dest + i) = 0;\n  }\n}\n\n/// From http://git.musl-libc.org/cgit/musl/tree/src/time/__secs_to_tm.c?h=v0.9.15\n/* 2000-03-01 (mod 400 year, immediately after feb29 */\n#define LEAPOCH (946684800LL + 86400*(31+29))\n#define DAYS_PER_400Y (365*400 + 97)\n#define DAYS_PER_100Y (365*100 + 24)\n#define DAYS_PER_4Y   (365*4   + 1)\nint secs_to_tm(long long t, struct tm *tm) {\n  long long days, secs;\n  int remdays, remsecs, remyears;\n  int qc_cycles, c_cycles, q_cycles;\n  int years, months;\n  int wday, yday, leap;\n  static const char days_in_month[] = {31,30,31,30,31,31,30,31,30,31,31,29};\n\n  /* Reject time_t values whose year would overflow int */\n  if (t < INT_MIN * 31622400LL || t > INT_MAX * 31622400LL)\n    return -1;\n\n  secs = t - LEAPOCH;\n  days = secs / 86400;\n  remsecs = secs % 86400;\n  if (remsecs < 0) {\n    remsecs += 86400;\n    days--;\n  }\n\n  wday = (3+days)%7;\n  if (wday < 0) wday += 7;\n\n  qc_cycles = days / DAYS_PER_400Y;\n  remdays = days % DAYS_PER_400Y;\n  if (remdays < 0) {\n    remdays += DAYS_PER_400Y;\n    qc_cycles--;\n  }\n\n  c_cycles = remdays / DAYS_PER_100Y;\n  if (c_cycles == 4) c_cycles--;\n  remdays -= c_cycles * DAYS_PER_100Y;\n\n  q_cycles = remdays / DAYS_PER_4Y;\n  if (q_cycles == 25) q_cycles--;\n  remdays -= q_cycles * DAYS_PER_4Y;\n\n  remyears = remdays / 365;\n  if (remyears == 4) remyears--;\n  remdays -= remyears * 365;\n\n  leap = !remyears && (q_cycles || !c_cycles);\n  yday = remdays + 31 + 28 + leap;\n  if (yday >= 365+leap) yday -= 365+leap;\n\n  years = remyears + 4*q_cycles + 100*c_cycles + 400*qc_cycles;\n\n  for (months=0; days_in_month[months] <= remdays; months++)\n    remdays -= days_in_month[months];\n\n  if (years+100 > INT_MAX || years+100 < INT_MIN)\n    return -1;\n\n  tm->tm_year = years + 100;\n  tm->tm_mon = months + 2;\n  if (tm->tm_mon >= 12) {\n    tm->tm_mon -=12;\n    tm->tm_year++;\n  }\n  tm->tm_mday = remdays + 1;\n  tm->tm_wday = wday;\n  tm->tm_yday = yday;\n\n  tm->tm_hour = remsecs / 3600;\n  tm->tm_min = remsecs / 60 % 60;\n  tm->tm_sec = remsecs % 60;\n\n  return 0;\n}\n", "#ifndef UTIL_H\n#define UTIL_H\n\n#include <cstdarg>\n#include <cstdint>\n#include <ctime>\n#include <string>\n\n/*\n * printf:\n *   Invokes OCALL to display the enclave buffer to the terminal.\n */\nint printf(const char *fmt, ...);\n\n/** Invoke OCALL to exit the program. */\nvoid exit(int exit_code);\nnamespace std {\n    using ::exit;\n}\n\nstd::string string_format(const std::string &fmt, ...);\n\nvoid print_bytes(uint8_t *ptr, uint32_t len);\n\n/** Return 0 if equal, and -1 if not equal. */\nint cmp(const uint8_t *value1, const uint8_t *value2, uint32_t len);\n\nvoid clear(uint8_t *dest, uint32_t len);\n\nint log_2(int value);\n\nint pow_2(int value);\n\nint secs_to_tm(long long t, struct tm *tm);\n\n#endif // UTIL_H\n"], "fixing_code": ["/**\n *   Copyright(C) 2011-2015 Intel Corporation All Rights Reserved.\n *\n *   The source code, information  and  material (\"Material\") contained herein is\n *   owned  by Intel Corporation or its suppliers or licensors, and title to such\n *   Material remains  with Intel Corporation  or its suppliers or licensors. The\n *   Material  contains proprietary information  of  Intel or  its  suppliers and\n *   licensors. The  Material is protected by worldwide copyright laws and treaty\n *   provisions. No  part  of  the  Material  may  be  used,  copied, reproduced,\n *   modified, published, uploaded, posted, transmitted, distributed or disclosed\n *   in any way  without Intel's  prior  express written  permission. No  license\n *   under  any patent, copyright  or  other intellectual property rights  in the\n *   Material  is  granted  to  or  conferred  upon  you,  either  expressly,  by\n *   implication, inducement,  estoppel or  otherwise.  Any  license  under  such\n *   intellectual  property  rights must  be express  and  approved  by  Intel in\n *   writing.\n *\n *   *Third Party trademarks are the property of their respective owners.\n *\n *   Unless otherwise  agreed  by Intel  in writing, you may not remove  or alter\n *   this  notice or  any other notice embedded  in Materials by Intel or Intel's\n *   suppliers or licensors in any way.\n */\n\n#include \"SGXEnclave.h\"\n\n// MAX_PATH, getpwuid\n#include <sys/types.h>\n#ifdef _MSC_VER\n# include <Shlobj.h>\n#else\n# include <unistd.h>\n# include <pwd.h>\n# define MAX_PATH FILENAME_MAX\n#endif\n\n#include <climits>\n#include <cstdarg>\n#include <cstdio>\n#include <cstdlib>\n#include <sys/time.h> // struct timeval\n#include <time.h> // gettimeofday\n\n#include <sgx_eid.h>     /* sgx_enclave_id_t */\n#include <sgx_error.h>       /* sgx_status_t */\n#include <sgx_uae_service.h>\n#include <sgx_ukey_exchange.h>\n\n#include \"Enclave_u.h\"\n#include \"service_provider.h\"\n\n#ifndef TRUE\n# define TRUE 1\n#endif\n\n#ifndef FALSE\n# define FALSE 0\n#endif\n\n#if defined(_MSC_VER)\n# define TOKEN_FILENAME   \"Enclave.token\"\n# define ENCLAVE_FILENAME \"Enclave.signed.dll\"\n#elif defined(__GNUC__)\n# define TOKEN_FILENAME   \"enclave.token\"\n# define ENCLAVE_FILENAME \"enclave.signed.so\"\n#endif\n\nstatic sgx_ra_context_t context = INT_MAX;\nJavaVM* jvm;\n\n/* Global EID shared by multiple threads */\nsgx_enclave_id_t global_eid = 0;\n\ntypedef struct _sgx_errlist_t {\n  sgx_status_t err;\n  const char *msg;\n  const char *sug; /* Suggestion */\n} sgx_errlist_t;\n\n/* Error code returned by sgx_create_enclave */\nstatic sgx_errlist_t sgx_errlist[] = {\n  {\n    SGX_ERROR_UNEXPECTED,\n    \"Unexpected error occurred.\",\n    NULL\n  },\n  {\n    SGX_ERROR_INVALID_PARAMETER,\n    \"Invalid parameter.\",\n    NULL\n  },\n  {\n    SGX_ERROR_OUT_OF_MEMORY,\n    \"Out of memory.\",\n    NULL\n  },\n  {\n    SGX_ERROR_ENCLAVE_LOST,\n    \"Power transition occurred.\",\n    \"Please refer to the sample \\\"PowerTransition\\\" for details.\"\n  },\n  {\n    SGX_ERROR_INVALID_ENCLAVE,\n    \"Invalid enclave image.\",\n    NULL\n  },\n  {\n    SGX_ERROR_INVALID_ENCLAVE_ID,\n    \"Invalid enclave identification.\",\n    NULL\n  },\n  {\n    SGX_ERROR_INVALID_SIGNATURE,\n    \"Invalid enclave signature.\",\n    NULL\n  },\n  {\n    SGX_ERROR_OUT_OF_EPC,\n    \"Out of EPC memory.\",\n    NULL\n  },\n  {\n    SGX_ERROR_NO_DEVICE,\n    \"Invalid SGX device.\",\n    \"Please make sure SGX module is enabled in the BIOS, and install SGX driver afterwards.\"\n  },\n  {\n    SGX_ERROR_MEMORY_MAP_CONFLICT,\n    \"Memory map conflicted.\",\n    NULL\n  },\n  {\n    SGX_ERROR_INVALID_METADATA,\n    \"Invalid enclave metadata.\",\n    NULL\n  },\n  {\n    SGX_ERROR_DEVICE_BUSY,\n    \"SGX device was busy.\",\n    NULL\n  },\n  {\n    SGX_ERROR_INVALID_VERSION,\n    \"Enclave version was invalid.\",\n    NULL\n  },\n  {\n    SGX_ERROR_INVALID_ATTRIBUTE,\n    \"Enclave was not authorized.\",\n    NULL\n  },\n  {\n    SGX_ERROR_ENCLAVE_FILE_ACCESS,\n    \"Can't open enclave file.\",\n    NULL\n  },\n\n  {\n    SGX_SUCCESS,\n    \"SGX call success\",\n    NULL\n  },\n};\n\n/* Check error conditions for loading enclave */\nvoid print_error_message(sgx_status_t ret)\n{\n  size_t idx = 0;\n  size_t ttl = sizeof sgx_errlist/sizeof sgx_errlist[0];\n\n  for (idx = 0; idx < ttl; idx++) {\n    if(ret == sgx_errlist[idx].err) {\n      if(NULL != sgx_errlist[idx].sug)\n        printf(\"Info: %s\\n\", sgx_errlist[idx].sug);\n      printf(\"Error: %s\\n\", sgx_errlist[idx].msg);\n      break;\n    }\n  }\n\n  if (idx == ttl)\n    printf(\"Error: Unexpected error occurred.\\n\");\n}\n\nvoid sgx_check_quiet(const char* message, sgx_status_t ret)\n{\n  if (ret != SGX_SUCCESS) {\n    printf(\"%s failed\\n\", message);\n    print_error_message(ret);\n  }\n}\n\nclass scoped_timer {\npublic:\n  scoped_timer(uint64_t *total_time) {\n    this->total_time = total_time;\n    struct timeval start;\n    gettimeofday(&start, NULL);\n    time_start = start.tv_sec * 1000000 + start.tv_usec;\n  }\n\n  ~scoped_timer() {\n    struct timeval end;\n    gettimeofday(&end, NULL);\n    time_end = end.tv_sec * 1000000 + end.tv_usec;\n    *total_time += time_end - time_start;\n  }\n\n  uint64_t * total_time;\n  uint64_t time_start, time_end;\n};\n\n#if defined(PERF) || defined(DEBUG)\n#define sgx_check(message, op) do {                     \\\n    printf(\"%s running...\\n\", message);                 \\\n    uint64_t t_ = 0;                                    \\\n    sgx_status_t ret_;                                  \\\n    {                                                   \\\n      scoped_timer timer_(&t_);                         \\\n      ret_ = op;                                        \\\n    }                                                   \\\n    double t_ms_ = ((double) t_) / 1000;                \\\n    if (ret_ != SGX_SUCCESS) {                          \\\n      printf(\"%s failed (%f ms)\\n\", message, t_ms_);    \\\n      print_error_message(ret_);                        \\\n    } else {                                            \\\n      printf(\"%s done (%f ms).\\n\", message, t_ms_);     \\\n    }                                                   \\\n  } while (0)\n#else\n#define sgx_check(message, op) sgx_check_quiet(message, op)\n#endif\n\n/* Initialize the enclave:\n *   Step 1: retrive the launch token saved by last transaction\n *   Step 2: call sgx_create_enclave to initialize an enclave instance\n *   Step 3: save the launch token if it is updated\n */\nint initialize_enclave(void)\n{\n  char token_path[MAX_PATH] = {'\\0'};\n  sgx_launch_token_t token = {0};\n  sgx_status_t ret = SGX_ERROR_UNEXPECTED;\n  int updated = 0;\n\n  /* Step 1: retrive the launch token saved by last transaction */\n#ifdef _MSC_VER\n  /* try to get the token saved in CSIDL_LOCAL_APPDATA */\n  if (S_OK != SHGetFolderPathA(NULL, CSIDL_LOCAL_APPDATA, NULL, 0, token_path)) {\n    strncpy_s(token_path, _countof(token_path), TOKEN_FILENAME, sizeof(TOKEN_FILENAME));\n  } else {\n    strncat_s(token_path, _countof(token_path), \"\\\\\" TOKEN_FILENAME, sizeof(TOKEN_FILENAME)+2);\n  }\n\n  /* open the token file */\n  HANDLE token_handler = CreateFileA(token_path, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, NULL, NULL);\n  if (token_handler == INVALID_HANDLE_VALUE) {\n    printf(\"Warning: Failed to create/open the launch token file \\\"%s\\\".\\n\", token_path);\n  } else {\n    /* read the token from saved file */\n    DWORD read_num = 0;\n    ReadFile(token_handler, token, sizeof(sgx_launch_token_t), &read_num, NULL);\n    if (read_num != 0 && read_num != sizeof(sgx_launch_token_t)) {\n      /* if token is invalid, clear the buffer */\n      memset(&token, 0x0, sizeof(sgx_launch_token_t));\n      printf(\"Warning: Invalid launch token read from \\\"%s\\\".\\n\", token_path);\n    }\n  }\n#else /* __GNUC__ */\n  /* try to get the token saved in $HOME */\n  const char *home_dir = getpwuid(getuid())->pw_dir;\n\n  if (home_dir != NULL &&\n      (strlen(home_dir)+strlen(\"/\")+sizeof(TOKEN_FILENAME)+1) <= MAX_PATH) {\n    /* compose the token path */\n    strncpy(token_path, home_dir, strlen(home_dir));\n    strncat(token_path, \"/\", strlen(\"/\"));\n    strncat(token_path, TOKEN_FILENAME, sizeof(TOKEN_FILENAME)+1);\n  } else {\n    /* if token path is too long or $HOME is NULL */\n    strncpy(token_path, TOKEN_FILENAME, sizeof(TOKEN_FILENAME));\n  }\n\n  FILE *fp = fopen(token_path, \"rb\");\n  if (fp == NULL && (fp = fopen(token_path, \"wb\")) == NULL) {\n    printf(\"Warning: Failed to create/open the launch token file \\\"%s\\\".\\n\", token_path);\n  }\n\n  if (fp != NULL) {\n    /* read the token from saved file */\n    size_t read_num = fread(token, 1, sizeof(sgx_launch_token_t), fp);\n    if (read_num != 0 && read_num != sizeof(sgx_launch_token_t)) {\n      /* if token is invalid, clear the buffer */\n      memset(&token, 0x0, sizeof(sgx_launch_token_t));\n      printf(\"Warning: Invalid launch token read from \\\"%s\\\".\\n\", token_path);\n    }\n  }\n#endif\n  /* Step 2: call sgx_create_enclave to initialize an enclave instance */\n  /* Debug Support: set 2nd parameter to 1 */\n  ret = sgx_create_enclave(ENCLAVE_FILENAME, SGX_DEBUG_FLAG, &token, &updated, &global_eid, NULL);\n  if (ret != SGX_SUCCESS) {\n    print_error_message(ret);\n#ifdef _MSC_VER\n    if (token_handler != INVALID_HANDLE_VALUE)\n      CloseHandle(token_handler);\n#else\n    if (fp != NULL) fclose(fp);\n#endif\n    return -1;\n  }\n\n  /* Step 3: save the launch token if it is updated */\n#ifdef _MSC_VER\n  if (updated == FALSE || token_handler == INVALID_HANDLE_VALUE) {\n    /* if the token is not updated, or file handler is invalid, do not perform saving */\n    if (token_handler != INVALID_HANDLE_VALUE)\n      CloseHandle(token_handler);\n    return 0;\n  }\n\n  /* flush the file cache */\n  FlushFileBuffers(token_handler);\n  /* set access offset to the begin of the file */\n  SetFilePointer(token_handler, 0, NULL, FILE_BEGIN);\n\n  /* write back the token */\n  DWORD write_num = 0;\n  WriteFile(token_handler, token, sizeof(sgx_launch_token_t), &write_num, NULL);\n  if (write_num != sizeof(sgx_launch_token_t))\n    printf(\"Warning: Failed to save launch token to \\\"%s\\\".\\n\", token_path);\n  CloseHandle(token_handler);\n#else /* __GNUC__ */\n  if (updated == FALSE || fp == NULL) {\n    /* if the token is not updated, or file handler is invalid, do not perform saving */\n    if (fp != NULL) fclose(fp);\n    return 0;\n  }\n\n  /* reopen the file with write capablity */\n  fp = freopen(token_path, \"wb\", fp);\n  if (fp == NULL) return 0;\n  size_t write_num = fwrite(token, 1, sizeof(sgx_launch_token_t), fp);\n  if (write_num != sizeof(sgx_launch_token_t))\n    printf(\"Warning: Failed to save launch token to \\\"%s\\\".\\n\", token_path);\n  fclose(fp);\n#endif\n  return 0;\n}\n\n/* OCall functions */\nvoid ocall_print_string(const char *str)\n{\n  /* Proxy/Bridge will check the length and null-terminate\n   * the input string to prevent buffer overflow.\n   */\n  printf(\"%s\", str);\n  fflush(stdout);\n}\n\nvoid unsafe_ocall_malloc(size_t size, uint8_t **ret) {\n  *ret = static_cast<uint8_t *>(malloc(size));\n}\n\nvoid ocall_free(uint8_t *buf) {\n  free(buf);\n}\n\nvoid ocall_exit(int exit_code) {\n  std::exit(exit_code);\n}\n\n/**\n * Throw a Java exception with the specified message.\n *\n * This function is intended to be invoked from an ecall that was in turn invoked by a JNI method.\n * As a result of calling this function, the JNI method will throw a Java exception upon its return.\n *\n * Important: Note that this function will return to the caller. The exception is only thrown at the\n * end of the JNI method invocation.\n */\nvoid ocall_throw(const char *message) {\n  JNIEnv* env;\n  jvm->AttachCurrentThread((void**) &env, NULL);\n  jclass exception = env->FindClass(\"edu/berkeley/cs/rise/opaque/OpaqueException\");\n  env->ThrowNew(exception, message);\n}\n\n#if defined(_MSC_VER)\n/* query and enable SGX device*/\nint query_sgx_status()\n{\n  sgx_device_status_t sgx_device_status;\n  sgx_status_t sgx_ret = sgx_enable_device(&sgx_device_status);\n  if (sgx_ret != SGX_SUCCESS) {\n    printf(\"Failed to get SGX device status.\\n\");\n    return -1;\n  }\n  else {\n    switch (sgx_device_status) {\n    case SGX_ENABLED:\n      return 0;\n    case SGX_DISABLED_REBOOT_REQUIRED:\n      printf(\"SGX device has been enabled. Please reboot your machine.\\n\");\n      return -1;\n    case SGX_DISABLED_LEGACY_OS:\n      printf(\"SGX device can't be enabled on an OS that doesn't support EFI interface.\\n\");\n      return -1;\n    case SGX_DISABLED:\n      printf(\"SGX device not found.\\n\");\n      return -1;\n    default:\n      printf(\"Unexpected error.\\n\");\n      return -1;\n    }\n  }\n}\n#endif\n\n\nJNIEXPORT jlong JNICALL Java_edu_berkeley_cs_rise_opaque_execution_SGXEnclave_StartEnclave(\n  JNIEnv *env, jobject obj, jstring library_path) {\n  (void)env;\n  (void)obj;\n\n  env->GetJavaVM(&jvm);\n\n  sgx_enclave_id_t eid;\n  sgx_launch_token_t token = {0};\n  int updated = 0;\n\n  const char *library_path_str = env->GetStringUTFChars(library_path, nullptr);\n  sgx_check(\"StartEnclave\",\n            sgx_create_enclave(\n              library_path_str, SGX_DEBUG_FLAG, &token, &updated, &eid, nullptr));\n  env->ReleaseStringUTFChars(library_path, library_path_str);\n\n  return eid;\n}\n\nJNIEXPORT jbyteArray JNICALL Java_edu_berkeley_cs_rise_opaque_execution_SGXEnclave_RemoteAttestation0(\n  JNIEnv *env, jobject obj) {\n\n  (void)env;\n  (void)obj;\n\n  // in the first step of the remote attestation, generate message 1 to send to the client\n  int ret = 0;\n\n  // Preparation for remote attestation by configuring extended epid group id\n  // This is Intel's group signature scheme for trusted hardware\n  // It keeps the machine anonymous while allowing the client to use a single public verification key to verify\n\n  uint32_t extended_epid_group_id = 0;\n  ret = sgx_get_extended_epid_group_id(&extended_epid_group_id);\n  if (SGX_SUCCESS != (sgx_status_t)ret) {\n    fprintf(stdout, \"\\nError, call sgx_get_extended_epid_group_id fail [%s].\", __FUNCTION__);\n    jbyteArray array_ret = env->NewByteArray(0);\n    return array_ret;\n  }\n\n#ifdef DEBUG\n  fprintf(stdout, \"\\nCall sgx_get_extended_epid_group_id success.\");\n#endif\n\n  // The ISV application sends msg0 to the SP.\n  // The ISV decides whether to support this extended epid group id.\n#ifdef DEBUG\n  fprintf(stdout, \"\\nSending msg0 to remote attestation service provider.\\n\");\n#endif\n\n  jbyteArray array_ret = env->NewByteArray(sizeof(uint32_t));\n  env->SetByteArrayRegion(array_ret, 0, sizeof(uint32_t), (jbyte *) &extended_epid_group_id);\n\n  return array_ret;\n}\n\nJNIEXPORT jbyteArray JNICALL Java_edu_berkeley_cs_rise_opaque_execution_SGXEnclave_RemoteAttestation1(\n    JNIEnv *env, jobject obj,\n    jlong eid) {\n\n  (void)env;\n  (void)obj;\n  (void)eid;\n\n  // Remote attestation will be initiated when the ISV server challenges the ISV\n  // app or if the ISV app detects it doesn't have the credentials\n  // (shared secret) from a previous attestation required for secure\n  // communication with the server.\n\n  int ret = 0;\n  int enclave_lost_retry_time = 2;\n  sgx_status_t status;\n\n  // Ideally, this check would be around the full attestation flow.\n  do {\n    ret = ecall_enclave_init_ra(eid,\n                                &status,\n                                false,\n                                &context);\n  } while (SGX_ERROR_ENCLAVE_LOST == ret && enclave_lost_retry_time--);\n\n  if (status != SGX_SUCCESS) {\n    printf(\"[RemoteAttestation1] enclave_init_ra's status is %u\\n\", (uint32_t) status);\n    std::exit(1);\n  }\n\n  uint8_t *msg1 = (uint8_t *) malloc(sizeof(sgx_ra_msg1_t));\n\n#ifdef DEBUG\n  printf(\"[RemoteAttestation1] context is %u, eid: %u\\n\", (uint32_t) context, (uint32_t) eid);\n#endif\n\n  ret = sgx_ra_get_msg1(context, eid, sgx_ra_get_ga, (sgx_ra_msg1_t*) msg1);\n\n  if(SGX_SUCCESS != ret) {\n    ret = -1;\n    fprintf(stdout, \"\\nError, call sgx_ra_get_msg1 fail [%s].\", __FUNCTION__);\n    jbyteArray array_ret = env->NewByteArray(0);\n    return array_ret;\n  } else {\n#ifdef DEBUG\n    fprintf(stdout, \"\\nCall sgx_ra_get_msg1 success.\\n\");\n    fprintf(stdout, \"\\nMSG1 body generated -\\n\");\n    PRINT_BYTE_ARRAY(stdout, msg1, sizeof(sgx_ra_msg1_t));\n#endif\n  }\n\n  // The ISV application sends msg1 to the SP to get msg2,\n  // msg2 needs to be freed when no longer needed.\n  // The ISV decides whether to use linkable or unlinkable signatures.\n#ifdef DEBUG\n  fprintf(stdout, \"\\nSending msg1 to remote attestation service provider.\"\n          \"Expecting msg2 back.\\n\");\n#endif\n\n  jbyteArray array_ret = env->NewByteArray(sizeof(sgx_ra_msg1_t));\n  env->SetByteArrayRegion(array_ret, 0, sizeof(sgx_ra_msg1_t), (jbyte *) msg1);\n\n  free(msg1);\n\n  return array_ret;\n}\n\nJNIEXPORT jbyteArray JNICALL Java_edu_berkeley_cs_rise_opaque_execution_SGXEnclave_RemoteAttestation2(\n    JNIEnv *env, jobject obj,\n    jlong eid,\n    jbyteArray msg2_input) {\n\n  (void)env;\n  (void)obj;\n\n  int ret = 0;\n  //sgx_ra_context_t context = INT_MAX;\n\n  (void)ret;\n  (void)eid;\n  // Successfully sent msg1 and received a msg2 back.\n  // Time now to check msg2.\n\n  //uint32_t input_len = (uint32_t) env->GetArrayLength(msg2_input);\n  jboolean if_copy = false;\n  jbyte *ptr = env->GetByteArrayElements(msg2_input, &if_copy);\n  sgx_ra_msg2_t* p_msg2_body = (sgx_ra_msg2_t*)(ptr);\n\n#ifdef DEBUG\n  printf(\"Printing p_msg2_body\\n\");\n  PRINT_BYTE_ARRAY(stdout, p_msg2_body, sizeof(sgx_ra_msg2_t));\n#endif\n\n  uint32_t msg3_size = 0;\n  sgx_ra_msg3_t *msg3 = NULL;\n\n  // The ISV app now calls uKE sgx_ra_proc_msg2,\n  // The ISV app is responsible for freeing the returned p_msg3!\n#ifdef DEBUG\n  printf(\"[RemoteAttestation2] context is %u, eid: %u\\n\", (uint32_t) context, (uint32_t) eid);\n#endif\n  ret = sgx_ra_proc_msg2(context,\n                         eid,\n                         sgx_ra_proc_msg2_trusted,\n                         sgx_ra_get_msg3_trusted,\n                         p_msg2_body,\n                         sizeof(sgx_ra_msg2_t),\n                         &msg3,\n                         &msg3_size);\n\n  if (!msg3) {\n    fprintf(stdout, \"\\nError, call sgx_ra_proc_msg2 fail. msg3 = 0x%p [%s].\\n\", msg3, __FUNCTION__);\n    print_error_message((sgx_status_t) ret);\n    jbyteArray array_ret = env->NewByteArray(0);\n    return array_ret;\n  }\n\n  if(SGX_SUCCESS != (sgx_status_t)ret) {\n    fprintf(stdout, \"\\nError, call sgx_ra_proc_msg2 fail. \"\n            \"ret = 0x%08x [%s].\\n\", ret, __FUNCTION__);\n    print_error_message((sgx_status_t) ret);\n    jbyteArray array_ret = env->NewByteArray(0);\n    return array_ret;\n  } else {\n#ifdef DEBUG\n    fprintf(stdout, \"\\nCall sgx_ra_proc_msg2 success.\\n\");\n#endif\n  }\n\n  jbyteArray array_ret = env->NewByteArray(msg3_size);\n  env->SetByteArrayRegion(array_ret, 0, msg3_size, (jbyte *) msg3);\n\n  free(msg3);\n  return array_ret;\n}\n\n\nJNIEXPORT void JNICALL Java_edu_berkeley_cs_rise_opaque_execution_SGXEnclave_RemoteAttestation3(\n    JNIEnv *env, jobject obj,\n    jlong eid,\n    jbyteArray att_result_input) {\n\n  (void)env;\n  (void)obj;\n\n#ifdef DEBUG\n  printf(\"RemoteAttestation3 called\\n\");\n#endif\n\n  sgx_status_t status = SGX_SUCCESS;\n  //uint32_t input_len = (uint32_t) env->GetArrayLength(att_result_input);\n  jboolean if_copy = false;\n  jbyte *ptr = env->GetByteArrayElements(att_result_input, &if_copy);\n\n  ra_samp_response_header_t *att_result_full = (ra_samp_response_header_t *)(ptr);\n  sample_ra_att_result_msg_t *att_result = (sample_ra_att_result_msg_t *) att_result_full->body;\n\n#ifdef DEBUG\n  printf(\"[RemoteAttestation3] att_result's size is %u\\n\", att_result_full->size);\n#endif\n\n  // Check the MAC using MK on the attestation result message.\n  // The format of the attestation result message is ISV specific.\n  // This is a simple form for demonstration. In a real product,\n  // the ISV may want to communicate more information.\n  int ret = 0;\n  ret = ecall_verify_att_result_mac(eid,\n                                    &status,\n                                    context,\n                                    (uint8_t*)&att_result->platform_info_blob,\n                                    sizeof(ias_platform_info_blob_t),\n                                    (uint8_t*)&att_result->mac,\n                                    sizeof(sgx_mac_t));\n\n  if((SGX_SUCCESS != ret) || (SGX_SUCCESS != status)) {\n    fprintf(stdout, \"\\nError: INTEGRITY FAILED - attestation result message MK based cmac failed in [%s], status is %u\", __FUNCTION__, (uint32_t) status);\n    return ;\n  }\n\n  bool attestation_passed = true;\n  // Check the attestation result for pass or fail.\n  // Whether attestation passes or fails is a decision made by the ISV Server.\n  // When the ISV server decides to trust the enclave, then it will return success.\n  // When the ISV server decided to not trust the enclave, then it will return failure.\n  if (0 != att_result_full->status[0] || 0 != att_result_full->status[1]) {\n    fprintf(stdout, \"\\nError, attestation result message MK based cmac \"\n            \"failed in [%s].\", __FUNCTION__);\n    attestation_passed = false;\n  }\n\n  // The attestation result message should contain a field for the Platform\n  // Info Blob (PIB).  The PIB is returned by attestation server in the attestation report.\n  // It is not returned in all cases, but when it is, the ISV app\n  // should pass it to the blob analysis API called sgx_report_attestation_status()\n  // along with the trust decision from the ISV server.\n  // The ISV application will take action based on the update_info.\n  // returned in update_info by the API.\n  // This call is stubbed out for the sample.\n  //\n  // sgx_update_info_bit_t update_info;\n  // ret = sgx_report_attestation_status(\n  //     &p_att_result_msg_body->platform_info_blob,\n  //     attestation_passed ? 0 : 1, &update_info);\n\n  // Get the shared secret sent by the server using SK (if attestation\n  // passed)\n#ifdef DEBUG\n  printf(\"[RemoteAttestation3] %u\\n\", attestation_passed);\n#endif\n  if (attestation_passed) {\n    ret = ecall_put_secret_data(eid,\n                                &status,\n                                context,\n                                att_result->secret.payload,\n                                att_result->secret.payload_size,\n                                att_result->secret.payload_tag);\n\n    if((SGX_SUCCESS != ret)  || (SGX_SUCCESS != status)) {\n      fprintf(stdout, \"\\nError, attestation result message secret \"\n              \"using SK based AESGCM failed in [%s]. ret = \"\n              \"0x%0x. status = 0x%0x\", __FUNCTION__, ret,\n              status);\n      return ;\n    }\n  }\n\n  fprintf(stdout, \"\\nSecret successfully received from server.\");\n  fprintf(stdout, \"\\nRemote attestation success!\\n\");\n\n#ifdef DEBUG\n  fprintf(stdout, \"Destroying the key exchange context\\n\");\n#endif\n  ecall_enclave_ra_close(eid, context);\n}\n\nJNIEXPORT void JNICALL Java_edu_berkeley_cs_rise_opaque_execution_SGXEnclave_StopEnclave(\n  JNIEnv *env, jobject obj, jlong eid) {\n  (void)env;\n  (void)obj;\n\n  sgx_check(\"StopEnclave\", sgx_destroy_enclave(eid));\n}\n\nJNIEXPORT jbyteArray JNICALL Java_edu_berkeley_cs_rise_opaque_execution_SGXEnclave_Project(\n  JNIEnv *env, jobject obj, jlong eid, jbyteArray project_list, jbyteArray input_rows) {\n  (void)obj;\n\n  jboolean if_copy;\n\n  uint32_t project_list_length = (uint32_t) env->GetArrayLength(project_list);\n  uint8_t *project_list_ptr = (uint8_t *) env->GetByteArrayElements(project_list, &if_copy);\n\n  uint32_t input_rows_length = (uint32_t) env->GetArrayLength(input_rows);\n  uint8_t *input_rows_ptr = (uint8_t *) env->GetByteArrayElements(input_rows, &if_copy);\n\n  uint8_t *output_rows;\n  size_t output_rows_length;\n\n  sgx_check(\"Project\",\n            ecall_project(\n              eid,\n              project_list_ptr, project_list_length,\n              input_rows_ptr, input_rows_length,\n              &output_rows, &output_rows_length));\n\n  env->ReleaseByteArrayElements(project_list, (jbyte *) project_list_ptr, 0);\n  env->ReleaseByteArrayElements(input_rows, (jbyte *) input_rows_ptr, 0);\n\n  jbyteArray ret = env->NewByteArray(output_rows_length);\n  env->SetByteArrayRegion(ret, 0, output_rows_length, (jbyte *) output_rows);\n  free(output_rows);\n\n  return ret;\n}\n\nJNIEXPORT jbyteArray JNICALL Java_edu_berkeley_cs_rise_opaque_execution_SGXEnclave_Filter(\n  JNIEnv *env, jobject obj, jlong eid, jbyteArray condition, jbyteArray input_rows) {\n  (void)obj;\n\n  jboolean if_copy;\n\n  size_t condition_length = (size_t) env->GetArrayLength(condition);\n  uint8_t *condition_ptr = (uint8_t *) env->GetByteArrayElements(condition, &if_copy);\n\n  uint32_t input_rows_length = (uint32_t) env->GetArrayLength(input_rows);\n  uint8_t *input_rows_ptr = (uint8_t *) env->GetByteArrayElements(input_rows, &if_copy);\n\n  uint8_t *output_rows;\n  size_t output_rows_length;\n\n  sgx_check(\"Filter\",\n            ecall_filter(\n              eid,\n              condition_ptr, condition_length,\n              input_rows_ptr, input_rows_length,\n              &output_rows, &output_rows_length));\n\n  env->ReleaseByteArrayElements(condition, (jbyte *) condition_ptr, 0);\n  env->ReleaseByteArrayElements(input_rows, (jbyte *) input_rows_ptr, 0);\n\n  jbyteArray ret = env->NewByteArray(output_rows_length);\n  env->SetByteArrayRegion(ret, 0, output_rows_length, (jbyte *) output_rows);\n  free(output_rows);\n\n  return ret;\n}\n\nJNIEXPORT jbyteArray JNICALL Java_edu_berkeley_cs_rise_opaque_execution_SGXEnclave_Encrypt(\n  JNIEnv *env, jobject obj, jlong eid, jbyteArray plaintext) {\n  (void)obj;\n\n  uint32_t plength = (uint32_t) env->GetArrayLength(plaintext);\n  jboolean if_copy = false;\n  jbyte *ptr = env->GetByteArrayElements(plaintext, &if_copy);\n\n  uint8_t *plaintext_ptr = (uint8_t *) ptr;\n\n  const jsize clength = plength + SGX_AESGCM_IV_SIZE + SGX_AESGCM_MAC_SIZE;\n  jbyteArray ciphertext = env->NewByteArray(clength);\n\n  uint8_t *ciphertext_copy = new uint8_t[clength];\n\n  sgx_check_quiet(\n    \"Encrypt\", ecall_encrypt(eid, plaintext_ptr, plength, ciphertext_copy, (uint32_t) clength));\n\n  env->SetByteArrayRegion(ciphertext, 0, clength, (jbyte *) ciphertext_copy);\n\n  env->ReleaseByteArrayElements(plaintext, ptr, 0);\n\n  delete[] ciphertext_copy;\n\n  return ciphertext;\n}\n\nJNIEXPORT jbyteArray JNICALL Java_edu_berkeley_cs_rise_opaque_execution_SGXEnclave_Sample(\n  JNIEnv *env, jobject obj, jlong eid, jbyteArray input_rows) {\n  (void)obj;\n\n  jboolean if_copy;\n  size_t input_rows_length = static_cast<size_t>(env->GetArrayLength(input_rows));\n  uint8_t *input_rows_ptr = reinterpret_cast<uint8_t *>(\n    env->GetByteArrayElements(input_rows, &if_copy));\n\n  uint8_t *output_rows;\n  size_t output_rows_length;\n\n  sgx_check(\"Sample\",\n            ecall_sample(\n              eid,\n              input_rows_ptr, input_rows_length,\n              &output_rows, &output_rows_length));\n\n  jbyteArray ret = env->NewByteArray(output_rows_length);\n  env->SetByteArrayRegion(ret, 0, output_rows_length, (jbyte *) output_rows);\n  free(output_rows);\n\n  env->ReleaseByteArrayElements(input_rows, (jbyte *) input_rows_ptr, 0);\n\n  return ret;\n}\n\nJNIEXPORT jbyteArray JNICALL Java_edu_berkeley_cs_rise_opaque_execution_SGXEnclave_FindRangeBounds(\n  JNIEnv *env, jobject obj, jlong eid, jbyteArray sort_order, jint num_partitions,\n  jbyteArray input_rows) {\n  (void)obj;\n\n  jboolean if_copy;\n\n  size_t sort_order_length = static_cast<size_t>(env->GetArrayLength(sort_order));\n  uint8_t *sort_order_ptr = reinterpret_cast<uint8_t *>(\n    env->GetByteArrayElements(sort_order, &if_copy));\n\n  size_t input_rows_length = static_cast<size_t>(env->GetArrayLength(input_rows));\n  uint8_t *input_rows_ptr = reinterpret_cast<uint8_t *>(\n    env->GetByteArrayElements(input_rows, &if_copy));\n\n  uint8_t *output_rows;\n  size_t output_rows_length;\n\n  sgx_check(\"Find Range Bounds\",\n            ecall_find_range_bounds(\n              eid,\n              sort_order_ptr, sort_order_length,\n              num_partitions,\n              input_rows_ptr, input_rows_length,\n              &output_rows, &output_rows_length));\n\n  jbyteArray ret = env->NewByteArray(output_rows_length);\n  env->SetByteArrayRegion(ret, 0, output_rows_length, reinterpret_cast<jbyte *>(output_rows));\n  free(output_rows);\n\n  env->ReleaseByteArrayElements(sort_order, reinterpret_cast<jbyte *>(sort_order_ptr), 0);\n  env->ReleaseByteArrayElements(input_rows, reinterpret_cast<jbyte *>(input_rows_ptr), 0);\n\n  return ret;\n}\n\nJNIEXPORT jobjectArray JNICALL\nJava_edu_berkeley_cs_rise_opaque_execution_SGXEnclave_PartitionForSort(\n  JNIEnv *env, jobject obj, jlong eid, jbyteArray sort_order, jint num_partitions,\n  jbyteArray input_rows, jbyteArray boundary_rows) {\n  (void)obj;\n\n  jboolean if_copy;\n\n  size_t sort_order_length = static_cast<size_t>(env->GetArrayLength(sort_order));\n  uint8_t *sort_order_ptr = reinterpret_cast<uint8_t *>(\n    env->GetByteArrayElements(sort_order, &if_copy));\n\n  size_t input_rows_length = static_cast<size_t>(env->GetArrayLength(input_rows));\n  uint8_t *input_rows_ptr = reinterpret_cast<uint8_t *>(\n    env->GetByteArrayElements(input_rows, &if_copy));\n\n  size_t boundary_rows_length = static_cast<size_t>(env->GetArrayLength(boundary_rows));\n  uint8_t *boundary_rows_ptr = reinterpret_cast<uint8_t *>(\n    env->GetByteArrayElements(boundary_rows, &if_copy));\n\n  uint8_t **output_partitions = new uint8_t *[num_partitions];\n  size_t *output_partition_lengths = new size_t[num_partitions];\n\n  sgx_check(\"Partition For Sort\",\n            ecall_partition_for_sort(\n              eid,\n              sort_order_ptr, sort_order_length,\n              num_partitions,\n              input_rows_ptr, input_rows_length,\n              boundary_rows_ptr, boundary_rows_length,\n              output_partitions, output_partition_lengths));\n\n  env->ReleaseByteArrayElements(sort_order, reinterpret_cast<jbyte *>(sort_order_ptr), 0);\n  env->ReleaseByteArrayElements(input_rows, reinterpret_cast<jbyte *>(input_rows_ptr), 0);\n  env->ReleaseByteArrayElements(boundary_rows, reinterpret_cast<jbyte *>(boundary_rows_ptr), 0);\n\n  jobjectArray result = env->NewObjectArray(num_partitions,  env->FindClass(\"[B\"), nullptr);\n  for (jint i = 0; i < num_partitions; i++) {\n    jbyteArray partition = env->NewByteArray(output_partition_lengths[i]);\n    env->SetByteArrayRegion(partition, 0, output_partition_lengths[i],\n                            reinterpret_cast<jbyte *>(output_partitions[i]));\n    free(output_partitions[i]);\n    env->SetObjectArrayElement(result, i, partition);\n  }\n  delete[] output_partitions;\n  delete[] output_partition_lengths;\n\n  return result;\n}\n\nJNIEXPORT jbyteArray JNICALL Java_edu_berkeley_cs_rise_opaque_execution_SGXEnclave_ExternalSort(\n  JNIEnv *env, jobject obj, jlong eid, jbyteArray sort_order, jbyteArray input_rows) {\n  (void)obj;\n\n  jboolean if_copy;\n\n  size_t sort_order_length = static_cast<size_t>(env->GetArrayLength(sort_order));\n  uint8_t *sort_order_ptr = reinterpret_cast<uint8_t *>(\n    env->GetByteArrayElements(sort_order, &if_copy));\n\n  size_t input_rows_length = static_cast<size_t>(env->GetArrayLength(input_rows));\n  uint8_t *input_rows_ptr = reinterpret_cast<uint8_t *>(\n    env->GetByteArrayElements(input_rows, &if_copy));\n\n  uint8_t *output_rows;\n  size_t output_rows_length;\n\n  sgx_check(\"External non-oblivious sort\",\n            ecall_external_sort(eid,\n                                sort_order_ptr, sort_order_length,\n                                input_rows_ptr, input_rows_length,\n                                &output_rows, &output_rows_length));\n\n  jbyteArray ret = env->NewByteArray(output_rows_length);\n  env->SetByteArrayRegion(ret, 0, output_rows_length, reinterpret_cast<jbyte *>(output_rows));\n  free(output_rows);\n\n  env->ReleaseByteArrayElements(sort_order, reinterpret_cast<jbyte *>(sort_order_ptr), 0);\n  env->ReleaseByteArrayElements(input_rows, reinterpret_cast<jbyte *>(input_rows_ptr), 0);\n\n  return ret;\n}\n\nJNIEXPORT jbyteArray JNICALL\nJava_edu_berkeley_cs_rise_opaque_execution_SGXEnclave_ScanCollectLastPrimary(\n  JNIEnv *env, jobject obj, jlong eid, jbyteArray join_expr, jbyteArray input_rows) {\n  (void)obj;\n\n  jboolean if_copy;\n\n  uint32_t join_expr_length = (uint32_t) env->GetArrayLength(join_expr);\n  uint8_t *join_expr_ptr = (uint8_t *) env->GetByteArrayElements(join_expr, &if_copy);\n\n  uint32_t input_rows_length = (uint32_t) env->GetArrayLength(input_rows);\n  uint8_t *input_rows_ptr = (uint8_t *) env->GetByteArrayElements(input_rows, &if_copy);\n\n  uint8_t *output_rows;\n  size_t output_rows_length;\n\n  sgx_check(\"Scan Collect Last Primary\",\n            ecall_scan_collect_last_primary(\n              eid,\n              join_expr_ptr, join_expr_length,\n              input_rows_ptr, input_rows_length,\n              &output_rows, &output_rows_length));\n\n  jbyteArray ret = env->NewByteArray(output_rows_length);\n  env->SetByteArrayRegion(ret, 0, output_rows_length, (jbyte *) output_rows);\n  free(output_rows);\n\n  env->ReleaseByteArrayElements(join_expr, (jbyte *) join_expr_ptr, 0);\n  env->ReleaseByteArrayElements(input_rows, (jbyte *) input_rows_ptr, 0);\n\n  return ret;\n}\n\nJNIEXPORT jbyteArray JNICALL\nJava_edu_berkeley_cs_rise_opaque_execution_SGXEnclave_NonObliviousSortMergeJoin(\n  JNIEnv *env, jobject obj, jlong eid, jbyteArray join_expr, jbyteArray input_rows,\n  jbyteArray join_row) {\n  (void)obj;\n\n  jboolean if_copy;\n\n  uint32_t join_expr_length = (uint32_t) env->GetArrayLength(join_expr);\n  uint8_t *join_expr_ptr = (uint8_t *) env->GetByteArrayElements(join_expr, &if_copy);\n\n  uint32_t input_rows_length = (uint32_t) env->GetArrayLength(input_rows);\n  uint8_t *input_rows_ptr = (uint8_t *) env->GetByteArrayElements(input_rows, &if_copy);\n\n  uint32_t join_row_length = (uint32_t) env->GetArrayLength(join_row);\n  uint8_t *join_row_ptr = (uint8_t *) env->GetByteArrayElements(join_row, &if_copy);\n\n  uint8_t *output_rows;\n  size_t output_rows_length;\n\n  sgx_check(\"Non-oblivious SortMergeJoin\",\n            ecall_non_oblivious_sort_merge_join(\n              eid,\n              join_expr_ptr, join_expr_length,\n              input_rows_ptr, input_rows_length,\n              join_row_ptr, join_row_length,\n              &output_rows, &output_rows_length));\n  \n  jbyteArray ret = env->NewByteArray(output_rows_length);\n  env->SetByteArrayRegion(ret, 0, output_rows_length, (jbyte *) output_rows);\n  free(output_rows);\n\n  env->ReleaseByteArrayElements(join_expr, (jbyte *) join_expr_ptr, 0);\n  env->ReleaseByteArrayElements(input_rows, (jbyte *) input_rows_ptr, 0);\n  env->ReleaseByteArrayElements(join_row, (jbyte *) join_row_ptr, 0);\n\n  return ret;\n}\n\nJNIEXPORT jobject JNICALL\nJava_edu_berkeley_cs_rise_opaque_execution_SGXEnclave_NonObliviousAggregateStep1(\n  JNIEnv *env, jobject obj, jlong eid, jbyteArray agg_op, jbyteArray input_rows) {\n  (void)obj;\n\n  jboolean if_copy;\n\n  uint32_t agg_op_length = (uint32_t) env->GetArrayLength(agg_op);\n  uint8_t *agg_op_ptr = (uint8_t *) env->GetByteArrayElements(agg_op, &if_copy);\n\n  uint32_t input_rows_length = (uint32_t) env->GetArrayLength(input_rows);\n  uint8_t *input_rows_ptr = (uint8_t *) env->GetByteArrayElements(input_rows, &if_copy);\n\n  uint8_t *first_row;\n  size_t first_row_length;\n\n  uint8_t *last_group;\n  size_t last_group_length;\n\n  uint8_t *last_row;\n  size_t last_row_length;\n\n  sgx_check(\"Non-Oblivious Aggregate Step 1\",\n            ecall_non_oblivious_aggregate_step1(\n              eid,\n              agg_op_ptr, agg_op_length,\n              input_rows_ptr, input_rows_length,\n              &first_row, &first_row_length,\n              &last_group, &last_group_length,\n              &last_row, &last_row_length));\n\n  jbyteArray first_row_array = env->NewByteArray(first_row_length);\n  env->SetByteArrayRegion(first_row_array, 0, first_row_length, (jbyte *) first_row);\n  free(first_row);\n\n  jbyteArray last_group_array = env->NewByteArray(last_group_length);\n  env->SetByteArrayRegion(last_group_array, 0, last_group_length, (jbyte *) last_group);\n  free(last_group);\n\n  jbyteArray last_row_array = env->NewByteArray(last_row_length);\n  env->SetByteArrayRegion(last_row_array, 0, last_row_length, (jbyte *) last_row);\n  free(last_row);\n\n  env->ReleaseByteArrayElements(agg_op, (jbyte *) agg_op_ptr, 0);\n  env->ReleaseByteArrayElements(input_rows, (jbyte *) input_rows_ptr, 0);\n\n  jclass tuple3_class = env->FindClass(\"scala/Tuple3\");\n  jobject ret = env->NewObject(\n    tuple3_class,\n    env->GetMethodID(tuple3_class, \"<init>\",\n                     \"(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)V\"),\n    first_row_array, last_group_array, last_row_array);\n\n  return ret;\n}\n\nJNIEXPORT jbyteArray JNICALL\nJava_edu_berkeley_cs_rise_opaque_execution_SGXEnclave_NonObliviousAggregateStep2(\n  JNIEnv *env, jobject obj, jlong eid, jbyteArray agg_op, jbyteArray input_rows,\n  jbyteArray next_partition_first_row, jbyteArray prev_partition_last_group,\n  jbyteArray prev_partition_last_row) {\n  (void)obj;\n\n  jboolean if_copy;\n\n  uint32_t agg_op_length = (uint32_t) env->GetArrayLength(agg_op);\n  uint8_t *agg_op_ptr = (uint8_t *) env->GetByteArrayElements(agg_op, &if_copy);\n\n  uint32_t input_rows_length = (uint32_t) env->GetArrayLength(input_rows);\n  uint8_t *input_rows_ptr = (uint8_t *) env->GetByteArrayElements(input_rows, &if_copy);\n\n  uint32_t next_partition_first_row_length =\n    (uint32_t) env->GetArrayLength(next_partition_first_row);\n  uint8_t *next_partition_first_row_ptr =\n    (uint8_t *) env->GetByteArrayElements(next_partition_first_row, &if_copy);\n\n  uint32_t prev_partition_last_group_length =\n    (uint32_t) env->GetArrayLength(prev_partition_last_group);\n  uint8_t *prev_partition_last_group_ptr =\n    (uint8_t *) env->GetByteArrayElements(prev_partition_last_group, &if_copy);\n\n  uint32_t prev_partition_last_row_length =\n    (uint32_t) env->GetArrayLength(prev_partition_last_row);\n  uint8_t *prev_partition_last_row_ptr =\n    (uint8_t *) env->GetByteArrayElements(prev_partition_last_row, &if_copy);\n\n  uint8_t *output_rows;\n  size_t output_rows_length;\n\n  sgx_check(\"Non-Oblivious Aggregate Step 2\",\n            ecall_non_oblivious_aggregate_step2(\n              eid,\n              agg_op_ptr, agg_op_length,\n              input_rows_ptr, input_rows_length,\n              next_partition_first_row_ptr, next_partition_first_row_length,\n              prev_partition_last_group_ptr, prev_partition_last_group_length,\n              prev_partition_last_row_ptr, prev_partition_last_row_length,\n              &output_rows, &output_rows_length));\n\n  jbyteArray ret = env->NewByteArray(output_rows_length);\n  env->SetByteArrayRegion(ret, 0, output_rows_length, (jbyte *) output_rows);\n  free(output_rows);\n\n  env->ReleaseByteArrayElements(agg_op, (jbyte *) agg_op_ptr, 0);\n  env->ReleaseByteArrayElements(input_rows, (jbyte *) input_rows_ptr, 0);\n  env->ReleaseByteArrayElements(\n    next_partition_first_row, (jbyte *) next_partition_first_row_ptr, 0);\n  env->ReleaseByteArrayElements(\n    prev_partition_last_group, (jbyte *) prev_partition_last_group_ptr, 0);\n  env->ReleaseByteArrayElements(\n    prev_partition_last_row, (jbyte *) prev_partition_last_row_ptr, 0);\n\n  return ret;\n}\n\n/* application entry */\n//SGX_CDECL\nint SGX_CDECL main(int argc, char *argv[])\n{\n  (void)(argc);\n  (void)(argv);\n\n#if defined(_MSC_VER)\n  if (query_sgx_status() < 0) {\n    /* either SGX is disabled, or a reboot is required to enable SGX */\n    printf(\"Enter a character before exit ...\\n\");\n    getchar();\n    return -1;\n  }\n#endif\n\n  /* Initialize the enclave */\n  if(initialize_enclave() < 0){\n    printf(\"Enter a character before exit ...\\n\");\n    getchar();\n    return -1;\n  }\n\n  /* Destroy the enclave */\n  sgx_destroy_enclave(global_eid);\n\n  printf(\"Info: SampleEnclave successfully returned.\\n\");\n\n  return 0;\n}\n", "#include \"Enclave_t.h\"\n\n#include <cstdint>\n#include <cassert>\n\n#include \"Aggregate.h\"\n#include \"Crypto.h\"\n#include \"Filter.h\"\n#include \"Join.h\"\n#include \"Project.h\"\n#include \"Sort.h\"\n#include \"isv_enclave.h\"\n#include \"sgx_lfence.h\"\n#include \"util.h\"\n\n// This file contains definitions of the ecalls declared in Enclave.edl. Errors originating within\n// these ecalls are signaled by throwing a std::runtime_error, which is caught at the top level of\n// the ecall (i.e., within these definitions), and are then rethrown as Java exceptions using\n// ocall_throw.\n\nvoid ecall_encrypt(uint8_t *plaintext, uint32_t plaintext_length,\n                   uint8_t *ciphertext, uint32_t cipher_length) {\n  // Guard against encrypting or overwriting enclave memory\n  assert(sgx_is_outside_enclave(plaintext, plaintext_length) == 1);\n  assert(sgx_is_outside_enclave(ciphertext, cipher_length) == 1);\n  sgx_lfence();\n\n  try {\n    // IV (12 bytes) + ciphertext + mac (16 bytes)\n    assert(cipher_length >= plaintext_length + SGX_AESGCM_IV_SIZE + SGX_AESGCM_MAC_SIZE);\n    (void)cipher_length;\n    (void)plaintext_length;\n    encrypt(plaintext, plaintext_length, ciphertext);\n  } catch (const std::runtime_error &e) {\n    ocall_throw(e.what());\n  }\n}\n\nvoid ecall_project(uint8_t *condition, size_t condition_length,\n                   uint8_t *input_rows, size_t input_rows_length,\n                   uint8_t **output_rows, size_t *output_rows_length) {\n  // Guard against operating on arbitrary enclave memory\n  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);\n  sgx_lfence();\n\n  try {\n    project(condition, condition_length,\n            input_rows, input_rows_length,\n            output_rows, output_rows_length);\n  } catch (const std::runtime_error &e) {\n    ocall_throw(e.what());\n  }\n}\n\nvoid ecall_filter(uint8_t *condition, size_t condition_length,\n                  uint8_t *input_rows, size_t input_rows_length,\n                  uint8_t **output_rows, size_t *output_rows_length) {\n  // Guard against operating on arbitrary enclave memory\n  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);\n  sgx_lfence();\n\n  try {\n    filter(condition, condition_length,\n           input_rows, input_rows_length,\n           output_rows, output_rows_length);\n  } catch (const std::runtime_error &e) {\n    ocall_throw(e.what());\n  }\n}\n\nvoid ecall_sample(uint8_t *input_rows, size_t input_rows_length,\n                  uint8_t **output_rows, size_t *output_rows_length) {\n  // Guard against operating on arbitrary enclave memory\n  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);\n  sgx_lfence();\n\n  try {\n    sample(input_rows, input_rows_length,\n           output_rows, output_rows_length);\n  } catch (const std::runtime_error &e) {\n    ocall_throw(e.what());\n  }\n}\n\nvoid ecall_find_range_bounds(uint8_t *sort_order, size_t sort_order_length,\n                             uint32_t num_partitions,\n                             uint8_t *input_rows, size_t input_rows_length,\n                             uint8_t **output_rows, size_t *output_rows_length) {\n  // Guard against operating on arbitrary enclave memory\n  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);\n  sgx_lfence();\n\n  try {\n    find_range_bounds(sort_order, sort_order_length,\n                      num_partitions,\n                      input_rows, input_rows_length,\n                      output_rows, output_rows_length);\n  } catch (const std::runtime_error &e) {\n    ocall_throw(e.what());\n  }\n}\n\nvoid ecall_partition_for_sort(uint8_t *sort_order, size_t sort_order_length,\n                              uint32_t num_partitions,\n                              uint8_t *input_rows, size_t input_rows_length,\n                              uint8_t *boundary_rows, size_t boundary_rows_length,\n                              uint8_t **output_partitions, size_t *output_partition_lengths) {\n  // Guard against operating on arbitrary enclave memory\n  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);\n  assert(sgx_is_outside_enclave(boundary_rows, boundary_rows_length) == 1);\n  sgx_lfence();\n\n  try {\n    partition_for_sort(sort_order, sort_order_length,\n                       num_partitions,\n                       input_rows, input_rows_length,\n                       boundary_rows, boundary_rows_length,\n                       output_partitions, output_partition_lengths);\n  } catch (const std::runtime_error &e) {\n    ocall_throw(e.what());\n  }\n}\n\nvoid ecall_external_sort(uint8_t *sort_order, size_t sort_order_length,\n                         uint8_t *input_rows, size_t input_rows_length,\n                         uint8_t **output_rows, size_t *output_rows_length) {\n  // Guard against operating on arbitrary enclave memory\n  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);\n  sgx_lfence();\n\n  try {\n    external_sort(sort_order, sort_order_length,\n                  input_rows, input_rows_length,\n                  output_rows, output_rows_length);\n  } catch (const std::runtime_error &e) {\n    ocall_throw(e.what());\n  }\n}\n\nvoid ecall_scan_collect_last_primary(uint8_t *join_expr, size_t join_expr_length,\n                                     uint8_t *input_rows, size_t input_rows_length,\n                                     uint8_t **output_rows, size_t *output_rows_length) {\n  // Guard against operating on arbitrary enclave memory\n  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);\n  sgx_lfence();\n\n  try {\n    scan_collect_last_primary(join_expr, join_expr_length,\n                              input_rows, input_rows_length,\n                              output_rows, output_rows_length);\n  } catch (const std::runtime_error &e) {\n    ocall_throw(e.what());\n  }\n}\n\nvoid ecall_non_oblivious_sort_merge_join(uint8_t *join_expr, size_t join_expr_length,\n                                         uint8_t *input_rows, size_t input_rows_length,\n                                         uint8_t *join_row, size_t join_row_length,\n                                         uint8_t **output_rows, size_t *output_rows_length) {\n  // Guard against operating on arbitrary enclave memory\n  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);\n  assert(sgx_is_outside_enclave(join_row, join_row_length) == 1);\n  sgx_lfence();\n\n  try {\n    non_oblivious_sort_merge_join(join_expr, join_expr_length,\n                                  input_rows, input_rows_length,\n                                  join_row, join_row_length,\n                                  output_rows, output_rows_length);\n  } catch (const std::runtime_error &e) {\n    ocall_throw(e.what());\n  }\n}\n\nvoid ecall_non_oblivious_aggregate_step1(\n  uint8_t *agg_op, size_t agg_op_length,\n  uint8_t *input_rows, size_t input_rows_length,\n  uint8_t **first_row, size_t *first_row_length,\n  uint8_t **last_group, size_t *last_group_length,\n  uint8_t **last_row, size_t *last_row_length) {\n  // Guard against operating on arbitrary enclave memory\n  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);\n  sgx_lfence();\n\n  try {\n    non_oblivious_aggregate_step1(\n      agg_op, agg_op_length,\n      input_rows, input_rows_length,\n      first_row, first_row_length,\n      last_group, last_group_length,\n      last_row, last_row_length);\n  } catch (const std::runtime_error &e) {\n    ocall_throw(e.what());\n  }\n}\n\nvoid ecall_non_oblivious_aggregate_step2(\n  uint8_t *agg_op, size_t agg_op_length,\n  uint8_t *input_rows, size_t input_rows_length,\n  uint8_t *next_partition_first_row, size_t next_partition_first_row_length,\n  uint8_t *prev_partition_last_group, size_t prev_partition_last_group_length,\n  uint8_t *prev_partition_last_row, size_t prev_partition_last_row_length,\n  uint8_t **output_rows, size_t *output_rows_length) {\n  // Guard against operating on arbitrary enclave memory\n  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);\n  assert(sgx_is_outside_enclave(next_partition_first_row, next_partition_first_row_length) == 1);\n  assert(sgx_is_outside_enclave(prev_partition_last_group, prev_partition_last_group_length) == 1);\n  assert(sgx_is_outside_enclave(prev_partition_last_row, prev_partition_last_row_length) == 1);\n  sgx_lfence();\n\n  try {\n    non_oblivious_aggregate_step2(\n      agg_op, agg_op_length,\n      input_rows, input_rows_length,\n      next_partition_first_row, next_partition_first_row_length,\n      prev_partition_last_group, prev_partition_last_group_length,\n      prev_partition_last_row, prev_partition_last_row_length,\n      output_rows, output_rows_length);\n  } catch (const std::runtime_error &e) {\n    ocall_throw(e.what());\n  }\n}\n\nsgx_status_t ecall_enclave_init_ra(int b_pse, sgx_ra_context_t *p_context) {\n  try {\n    return enclave_init_ra(b_pse, p_context);\n  } catch (const std::runtime_error &e) {\n    ocall_throw(e.what());\n    return SGX_ERROR_UNEXPECTED;\n  }\n}\n\n\nvoid ecall_enclave_ra_close(sgx_ra_context_t context) {\n  try {\n    enclave_ra_close(context);\n  } catch (const std::runtime_error &e) {\n    ocall_throw(e.what());\n  }\n}\n\nsgx_status_t ecall_verify_att_result_mac(sgx_ra_context_t context, uint8_t* message,\n                                         size_t message_size, uint8_t* mac,\n                                         size_t mac_size) {\n  try {\n    return verify_att_result_mac(context, message, message_size, mac, mac_size);\n  } catch (const std::runtime_error &e) {\n    ocall_throw(e.what());\n    return SGX_ERROR_UNEXPECTED;\n  }\n}\n\nsgx_status_t ecall_put_secret_data(sgx_ra_context_t context,\n                                   uint8_t* p_secret,\n                                   uint32_t secret_size,\n                                   uint8_t* gcm_mac) {\n  try {\n    return put_secret_data(context, p_secret, secret_size, gcm_mac);\n  } catch (const std::runtime_error &e) {\n    ocall_throw(e.what());\n    return SGX_ERROR_UNEXPECTED;\n  }\n}\n", "// -*- mode: c++ -*-\n/* Enclave.edl - Top EDL file. */\n\nenclave {\n\n  include \"stdbool.h\"\n  include \"sgx_key_exchange.h\"\n  include \"sgx_trts.h\"\n  from \"sgx_tkey_exchange.edl\" import *;\n\n  trusted {\n    public void ecall_project(\n      [in, count=project_list_length] uint8_t *project_list, size_t project_list_length,\n      [user_check] uint8_t *input_rows, size_t input_rows_length,\n      [out] uint8_t **output_rows, [out] size_t *output_rows_length);\n\n    public void ecall_filter(\n      [in, count=condition_length] uint8_t *condition, size_t condition_length,\n      [user_check] uint8_t *input_rows, size_t input_rows_length,\n      [out] uint8_t **output_rows, [out] size_t *output_rows_length);\n\n    public void ecall_encrypt(\n      [user_check] uint8_t *plaintext, uint32_t length,\n      [user_check] uint8_t *ciphertext, uint32_t cipher_length);\n\n    public void ecall_sample(\n      [user_check] uint8_t *input_rows, size_t input_rows_length,\n      [out] uint8_t **output_rows, [out] size_t *output_rows_length);\n\n    public void ecall_find_range_bounds(\n      [in, count=sort_order_length] uint8_t *sort_order, size_t sort_order_length,\n      uint32_t num_partitions,\n      [user_check] uint8_t *input_rows, size_t input_rows_length,\n      [out] uint8_t **output_rows, [out] size_t *output_rows_length);\n\n    public void ecall_partition_for_sort(\n      [in, count=sort_order_length] uint8_t *sort_order, size_t sort_order_length,\n      uint32_t num_partitions,\n      [user_check] uint8_t *input_rows, size_t input_rows_length,\n      [user_check] uint8_t *boundary_rows, size_t boundary_rows_length,\n      [out, count=num_partitions] uint8_t **output_partitions,\n      [out, count=num_partitions] size_t *output_partition_lengths);\n\n    public void ecall_external_sort(\n      [in, count=sort_order_length] uint8_t *sort_order, size_t sort_order_length,\n      [user_check] uint8_t *input_rows, size_t input_rows_length,\n      [out] uint8_t **output_rows, [out] size_t *output_rows_length);\n\n    public void ecall_scan_collect_last_primary(\n      [in, count=join_expr_length] uint8_t *join_expr, size_t join_expr_length,\n      [user_check] uint8_t *input_rows, size_t input_rows_length,\n      [out] uint8_t **output_rows, [out] size_t *output_rows_length);\n\n    public void ecall_non_oblivious_sort_merge_join(\n      [in, count=join_expr_length] uint8_t *join_expr, size_t join_expr_length,\n      [user_check] uint8_t *input_rows, size_t input_rows_length,\n      [user_check] uint8_t *join_row, size_t join_row_length,\n      [out] uint8_t **output_rows, [out] size_t *output_rows_length);\n\n    public void ecall_non_oblivious_aggregate_step1(\n      [in, count=agg_op_length] uint8_t *agg_op, size_t agg_op_length,\n      [user_check] uint8_t *input_rows, size_t input_rows_length,\n      [out] uint8_t **first_row, [out] size_t *first_row_length,\n      [out] uint8_t **last_group, [out] size_t *last_group_length,\n      [out] uint8_t **last_row, [out] size_t *last_row_length);\n\n    public void ecall_non_oblivious_aggregate_step2(\n      [in, count=agg_op_length] uint8_t *agg_op, size_t agg_op_length,\n      [user_check] uint8_t *input_rows, size_t input_rows_length,\n      [user_check] uint8_t *next_partition_first_row, size_t next_partition_first_row_length,\n      [user_check] uint8_t *prev_partition_last_group, size_t prev_partition_last_group_length,\n      [user_check] uint8_t *prev_partition_last_row, size_t prev_partition_last_row_length,\n      [out] uint8_t **output_rows, [out] size_t *output_rows_length);\n\n    public sgx_status_t ecall_enclave_init_ra(int b_pse,\n                                              [out] sgx_ra_context_t *p_context);\n    public void ecall_enclave_ra_close(sgx_ra_context_t context);\n    public sgx_status_t ecall_verify_att_result_mac(sgx_ra_context_t context,\n                                                    [in,size=message_size] uint8_t* message,\n                                                    size_t message_size,\n                                                    [in,size=mac_size] uint8_t* mac,\n                                                    size_t mac_size);\n    public sgx_status_t ecall_put_secret_data(sgx_ra_context_t context,\n                                              [in,size=secret_size] uint8_t* p_secret,\n                                              uint32_t secret_size,\n                                              [in,count=16] uint8_t* gcm_mac);\n  };\n\n  untrusted {\n    void ocall_print_string([in, string] const char *str);\n\n    /**\n     * Allocate memory outside of the enclave and return the pointer in `ret`.\n     *\n     * Before dereferencing the resulting pointer, the caller must check whether it is actually\n     * outside the enclave using `sgx_is_outside_enclave()`. Otherwise, an attacker could cause the\n     * enclave to perform unexpected operations on its own memory. The function `ocall_malloc()`\n     * wraps this function with such a bounds check and most callers should use that function\n     * instead.\n     */\n    void unsafe_ocall_malloc(size_t size, [out] uint8_t **ret);\n\n    void ocall_free([user_check] uint8_t *buf);\n    void ocall_exit(int exit_code);\n    void ocall_throw([in, string] const char *message);\n  };\n\n};\n", "#include \"util.h\"\n\n#include <climits>\n#include <cstdio>\n\n#include \"Enclave_t.h\"\n#include \"sgx_lfence.h\"\n\nint printf(const char *fmt, ...) {\n  char buf[BUFSIZ] = {'\\0'};\n  va_list ap;\n  va_start(ap, fmt);\n  int ret = vsnprintf(buf, BUFSIZ, fmt, ap);\n  va_end(ap);\n  ocall_print_string(buf);\n  return ret;\n}\n\n/** From https://stackoverflow.com/a/8362718 */\nstd::string string_format(const std::string &fmt, ...) {\n    int size=BUFSIZ;\n    std::string str;\n    va_list ap;\n    while (1) {\n        str.resize(size);\n        va_start(ap, fmt);\n        int n = vsnprintf(&str[0], size, fmt.c_str(), ap);\n        va_end(ap);\n        if (n > -1 && n < size)\n            return str;\n        if (n > -1)\n            size = n + 1;\n        else\n            size *= 2;\n    }\n}\n\nvoid exit(int exit_code) {\n  ocall_exit(exit_code);\n}\n\nvoid ocall_malloc(size_t size, uint8_t **ret) {\n  unsafe_ocall_malloc(size, ret);\n\n  // Guard against overwriting enclave memory\n  assert(sgx_is_outside_enclave(*ret, size) == 1);\n  sgx_lfence();\n}\n\nvoid print_bytes(uint8_t *ptr, uint32_t len) {\n  for (uint32_t i = 0; i < len; i++) {\n    printf(\"%u\", *(ptr + i));\n    printf(\" - \");\n  }\n\n  printf(\"\\n\");\n}\n\nint cmp(const uint8_t *value1, const uint8_t *value2, uint32_t len) {\n  for (uint32_t i = 0; i < len; i++) {\n    if (*(value1+i) != *(value2+i)) {\n      return -1;\n    }\n  }\n  return 0;\n}\n\n// basically a memset 0\nvoid clear(uint8_t *dest, uint32_t len) {\n  for (uint32_t i = 0; i < len; i++) {\n    *(dest + i) = 0;\n  }\n}\n\n/// From http://git.musl-libc.org/cgit/musl/tree/src/time/__secs_to_tm.c?h=v0.9.15\n/* 2000-03-01 (mod 400 year, immediately after feb29 */\n#define LEAPOCH (946684800LL + 86400*(31+29))\n#define DAYS_PER_400Y (365*400 + 97)\n#define DAYS_PER_100Y (365*100 + 24)\n#define DAYS_PER_4Y   (365*4   + 1)\nint secs_to_tm(long long t, struct tm *tm) {\n  long long days, secs;\n  int remdays, remsecs, remyears;\n  int qc_cycles, c_cycles, q_cycles;\n  int years, months;\n  int wday, yday, leap;\n  static const char days_in_month[] = {31,30,31,30,31,31,30,31,30,31,31,29};\n\n  /* Reject time_t values whose year would overflow int */\n  if (t < INT_MIN * 31622400LL || t > INT_MAX * 31622400LL)\n    return -1;\n\n  secs = t - LEAPOCH;\n  days = secs / 86400;\n  remsecs = secs % 86400;\n  if (remsecs < 0) {\n    remsecs += 86400;\n    days--;\n  }\n\n  wday = (3+days)%7;\n  if (wday < 0) wday += 7;\n\n  qc_cycles = days / DAYS_PER_400Y;\n  remdays = days % DAYS_PER_400Y;\n  if (remdays < 0) {\n    remdays += DAYS_PER_400Y;\n    qc_cycles--;\n  }\n\n  c_cycles = remdays / DAYS_PER_100Y;\n  if (c_cycles == 4) c_cycles--;\n  remdays -= c_cycles * DAYS_PER_100Y;\n\n  q_cycles = remdays / DAYS_PER_4Y;\n  if (q_cycles == 25) q_cycles--;\n  remdays -= q_cycles * DAYS_PER_4Y;\n\n  remyears = remdays / 365;\n  if (remyears == 4) remyears--;\n  remdays -= remyears * 365;\n\n  leap = !remyears && (q_cycles || !c_cycles);\n  yday = remdays + 31 + 28 + leap;\n  if (yday >= 365+leap) yday -= 365+leap;\n\n  years = remyears + 4*q_cycles + 100*c_cycles + 400*qc_cycles;\n\n  for (months=0; days_in_month[months] <= remdays; months++)\n    remdays -= days_in_month[months];\n\n  if (years+100 > INT_MAX || years+100 < INT_MIN)\n    return -1;\n\n  tm->tm_year = years + 100;\n  tm->tm_mon = months + 2;\n  if (tm->tm_mon >= 12) {\n    tm->tm_mon -=12;\n    tm->tm_year++;\n  }\n  tm->tm_mday = remdays + 1;\n  tm->tm_wday = wday;\n  tm->tm_yday = yday;\n\n  tm->tm_hour = remsecs / 3600;\n  tm->tm_min = remsecs / 60 % 60;\n  tm->tm_sec = remsecs % 60;\n\n  return 0;\n}\n", "#ifndef UTIL_H\n#define UTIL_H\n\n#include <cstdarg>\n#include <cstdint>\n#include <ctime>\n#include <string>\n\n/*\n * printf:\n *   Invokes OCALL to display the enclave buffer to the terminal.\n */\nint printf(const char *fmt, ...);\n\n/** Invoke OCALL to exit the program. */\nvoid exit(int exit_code);\nnamespace std {\n    using ::exit;\n}\n\n/**\n * Allocate memory outside of the enclave and return the pointer in `ret`.\n *\n * This is a checked wrapper around `unsafe_ocall_malloc`. The resulting pointer is safe to write\n * to.\n */\nvoid ocall_malloc(size_t size, uint8_t **ret);\n\nstd::string string_format(const std::string &fmt, ...);\n\nvoid print_bytes(uint8_t *ptr, uint32_t len);\n\n/** Return 0 if equal, and -1 if not equal. */\nint cmp(const uint8_t *value1, const uint8_t *value2, uint32_t len);\n\nvoid clear(uint8_t *dest, uint32_t len);\n\nint log_2(int value);\n\nint pow_2(int value);\n\nint secs_to_tm(long long t, struct tm *tm);\n\n#endif // UTIL_H\n"], "filenames": ["src/enclave/App/App.cpp", "src/enclave/Enclave/Enclave.cpp", "src/enclave/Enclave/Enclave.edl", "src/enclave/Enclave/util.cpp", "src/enclave/Enclave/util.h"], "buggy_code_start_loc": [360, 12, 91, 6, 20], "buggy_code_end_loc": [361, 159, 92, 38, 20], "fixing_code_start_loc": [360, 13, 91, 7, 21], "fixing_code_end_loc": [361, 211, 103, 48, 29], "type": "CWE-787", "message": "An issue was discovered in UC Berkeley RISE Opaque before 2018-12-01. There is no boundary check on ocall_malloc. The return value could be a pointer to enclave memory. It could cause an arbitrary enclave memory write.", "other": {"cve": {"id": "CVE-2018-20742", "sourceIdentifier": "cve@mitre.org", "published": "2019-01-24T05:29:00.753", "lastModified": "2019-02-13T19:02:56.350", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in UC Berkeley RISE Opaque before 2018-12-01. There is no boundary check on ocall_malloc. The return value could be a pointer to enclave memory. It could cause an arbitrary enclave memory write."}, {"lang": "es", "value": "Se ha descubierto un problema en UC Berkeley RISE Opaqu en versiones anteriores al 01/12/2018. No hay comprobaci\u00f3n de l\u00edmites de ocall_malloc. El valor de retorno podr\u00eda ser un puntero para enclavar memoria. Podr\u00eda provocar una escritura de memoria del enclave."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ucbrise:opaque:*:*:*:*:*:*:*:*", "versionEndExcluding": "2018-12-01", "matchCriteriaId": "3FFA46CC-CA6A-43D8-841A-2C7B17F7FCE6"}]}]}], "references": [{"url": "https://github.com/ucbrise/opaque/commit/5ddda15d89f5ac82f4416208c5319ace4aecdc36", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ucbrise/opaque/issues/66", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ucbrise/opaque/commit/5ddda15d89f5ac82f4416208c5319ace4aecdc36"}}