{"buggy_code": ["2007-07-31 Lorenzo Colitti <lorenzo@colitti.com>\n\n\t* bgp_dump.c: (general) Add comments to code.\n\t  (bgp_dump_interval_add) remove some redundant lines.\n\t  (bgp_dump_set) Use enum for type argument.\n\t  Avoid scheduling dump twice if exact same command\n\t  is given twice..\n\n2007-06-22 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_fsm.c: (struct FSM) Bug #368. TCP Errors during OpenSent\n\t  should cycle to Active, not to Idle or else peer bringup can\n\t  race and cycle Idle<->Active. Reported and fix tested by\n\t  Mukesh Agrawal.\n\n2007-05-25 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_route.c: (bgp_default_originate) Sanity check added\n\t  previously was broken and always failed, thus this function\n\t  never could run, bug #370.\n\n2007-05-03 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_route.h: (struct info) Move less frequently used\n\t  fields to a lazily allocated struct info_extra.\n\t  Export bgp_info_extra_get\n\t* bgp_route.c: (bgp_info_extra_new) allocate extra\n\t  (bgp_info_extra_free) Free damp info and the info_extra.\n\t  (bgp_info_extra_get) Retrieve the info_extra of a struct\n\t  info, allocating as required.\n\t  (generally) adjust to use info->extra\n\t* bgp_damp.c: (generally) use bgp_info_extra_get to access\n\t  dampinfo\n\t* bgp_attr.h: Move rarely allocated attributes from struct attr\n\t  to a struct attr_extra, for a substantial saving in size of\n\t  struct attr.\n\t* bgp_attr.c: (bgp_attr_extra_{new,free}), new, self-explanatory.\n\t  (bgp_attr_extra_get) Get the attr_extra for a given struct\n\t  attr, allocating it if needs be.\n\t  (bgp_attr_dup) Shallow copy the struct attr and its attr_extra.\n\t  (generally) adjust to know about attr->extra.\n\t* bgp_debug.c: (bgp_dump_attr) ditto\n\t* bgp_vty.c: (show_bgp_memory) print attr and info extra sizes.\n\t* bgp_nexthop.c: (generally) adjust to know about attr->extra\n\t  and info->extra.\n\t* bgp_{packet,routemap,snmp,zebra}.c: ditto\n\n2007-04-22 Sebastien Tandel <sebastien@tandel.be>\n\t* bgp_advertise.c : (baa_hash_alloc, baa_hash_key, baa_hash_cmp)\n\t  conforms to quagga hash API. Defines _hash_[alloc|key|cmp] with\n\t  void * arguments as defined by the API.\n\t* bgp_aspath.c,h : (aspath_key_make) conforms to quagga hash API.\n\t  Defines _hash_[alloc|key|cmp] with void * arguments as defined by\n\t  the API.\n\t* bgp_attr.c,h : (cluster_hash_alloc, cluster_hash_key_make,\n\t  cluster_hash_cmp, transit_hash_alloc, transit_hash_key_make,\n\t  transit_hash_cmp, attrhash_key_make, attrhash_cmp,\n\t  bgp_attr_hash_alloc) conforms to quagga hash API. Defines\n\t  _hash_[alloc|key|cmp] with void * arguments as defined by the API.\n\t* bgp_attr.h : Definition of BGP_ATTR_DEFAULT_WEIGHT.\n\t* bgp_attr.c : (bgp_attr_default_intern) now uses \n\t  bgp_attr_default_set instead of duplicating the same code.\n\t  (general) Use of BGP_ATTR_DEFAULT_WEIGHT. Replace two 16 by\n\t  IPV6_MAX_BYTELEN.\n\n2007-04-15 Sebastien Tandel <sebastien@tandel.be>\n\n\t* bgp_aspath.c: (aspath_as_add, aspath_segment_add) Minor performance\n\t  optimization: while loop should test one pointer instead of two.\n\n2007-04-08 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_route.c: (general) Same bug as fixed on 2006-11-28 by ajs for\n\t  bgp static routes, but for main BGP RIB: Quick 'flap' of routes\n\t  can cause bgpd to mistake a new route for a duplicate route,\n\t  due to presence of removed, but not yet processed BGP RIB entry.\n\t  (bgp_update_rsclient) Ignore REMOVED bgp_info for duplicate,\n\t  restore route instead.\n\t  (bgp_update_main) Ditto.\n\t* bgp_attr.c: (general) Bug #354: parsing of MP_REACH_NLRI and\n\t  MP_UNREACH_NLRI does not take sufficient care to ensure reads\n\t  from stream buffer stay in-bounds. Hence bgpd may attempt to read\n\t  beyond end of stream, if given a crafted packet. As it uses the\n\t  stream access methods to do so, this will typically result in\n\t  assert() being hit in stream.c. Where code is compiled without\n\t  assert() enabled, result is unknown.\n\t  (struct message attr_str) should be static.\n\t  (bgp_mp_reach_parse) Carefully check length remaining in stream\n\t  against amount desired to read from stream, prior to each read,\n\t  particularly where lengths are conditional on data obtained from\n\t  stream - using STREAM_READABLE.\n\t  Remove code to parse SNPA-number, it's a defunct field and changed\n\t  to a fixed size in latest BGP MP update RFC - log warning if\n\t  SNPA-number is not 0.\n\t  (bgp_mp_unreach_parse) Check withdraw_length carefully against\n\t  STREAM_READABLE.\n\t  (bgp_attr_parse) If attribute-parser function returns error, log\n\t  warning.\n\t  Log attribute type on mismatch.\n\n2007-04-07 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgpd.c: (general) Fix bug #352\n\t  (bgp_config_write_family_header) write ipv6/multicast\n\t  address family header.\n\t  (bgp_config_write) write out ipv6 multicast AF config.\n\n2007-02-22 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_fsm.c: (bgp_fsm_change_status) Handle state change into\n\t  clearing or greater here. Simpler.\n\t  (bgp_event) Clearing state change work moved to previous\n\t* bgp_route.c: (bgp_clear_route_node) Clearing adj-in here\n\t  is too late, as it leaves a race between a peer being deleted\n\t  and an identical peer being configured before clearing\n\t  completes, leading to a crash.\n\t  Simplest fix is to clean peers Adj-in up-front, rather than\n\t  queueing such work.\n\t  (bgp_clear_route_table) Clear peer's Adj-In and Adj-Out\n\t  up-front here, rather than queueing such work.\n\t  Extensive comment added on the various bits of indexed data\n\t  that exist and how they need to be dealt with.\n\t  (bgp_clear_route) Update comment.\n\n2006-12-12 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\t\n\t* bgp_nexthop.c: (bgp_connected_add, bgp_connected_delete)\n\t  Simplify logic by using new CONNECTED_PREFIX macro.\n\n2006-12-07 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_fsm.c: Bug #302 fix, diagnosis, suggestions and testing\n\t  by Juergen Kammer <j.kammer@eurodata.de>. Fix follows from\n\t  his suggested fix, just made in a slightly different way.\n\t  (bgp_event) Transitions into Clearing always must call\n\t  bgp_clear_route_all().\n\t  (bgp_stop) No need to clear routes here, BGP FSM should do\n\t  it.\n \n2006-11-30 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* bgp_debug.h: Declare new bgp_debug_zebra conf and term flags,\n\t  and define BGP_DEBUG_ZEBRA.\n\t* bgp_debug.c: Declare conf_bgp_debug_zebra and term_bgp_debug_zebra.\n\t  (debug_bgp_zebra, no_debug_bgp_zebra, undebug_bgp_zebra) New\n\t  functions to enable/disable bgp zebra debugging.\n\t  (no_debug_bgp_all) Turn off zebra debugging.\n\t  (show_debugging_bgp) Show whether zebra debugging is on.\n\t  (bgp_config_write_debug) Add 'debug bgp zebra' if configured.\n\t  (bgp_debug_init) Add new zebra debugging commands.\n\t* bgp_zebra.c: (bgp_router_id_update, bgp_interface_add,\n\t  bgp_interface_delete, bgp_interface_up, bgp_interface_down,\n\t  bgp_interface_address_add, bgp_interface_address_delete,\n\t  zebra_read_ipv4, zebra_read_ipv6, bgp_zebra_announce,\n\t  bgp_zebra_withdraw, bgp_redistribute_set, bgp_redistribute_unset)\n\t  If zebra debugging is enabled, log an appropriate debug message.\n\n2006-11-28 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* bgp_route.c: (bgp_info_restore) New function that undoes\n\t  the effects of a previous call to bgp_info_delete.  This is\n\t  used when a route is deleted and quickly re-added before the\n\t  deletion has been processed.\n\t  (bgp_static_update_rsclient, bgp_static_update_main,\n\t  bgp_redistribute_add) Check whether a pre-existing route\n\t  has the BGP_INFO_REMOVED set, and, if so, we need to call\n\t  bgp_info_restore to resurrect it.\n\n2006-10-27 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_route.c: (bgp_table_stats) oops, u_intXX_t should be\n\t  uintXX_t\n\n2006-10-19 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgpd.c: (peer_new) bgp element of peer absolutely must be\n\t  filled in, make peer_new() require it as argument and update\n\t  all callers. Fixes a crash reported by Jan 'yanek' Bortl and\n\t  Andrew Schorr where bgpd would crash in bgp_pcount_adjust\n\t  trying to dereference the bgp member of bgp->peer_self,\n\t  triggered through redistribution.\n\t* bgp_route.c: (bgp_pcount_adjust) assert sanity of arguments.\n\n2006-10-15 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_route.c: (bgp_table_stats_walker) NULL deref if table is\n\t  empty, bgp_table_top may return NULL, Coverity CID#73.\n\t* bgp_packet.c: (bgp_update_packet) adv->rn can not be NULL,\n\t  check is bogus - changed to assert(), CID#64.\n\t  binfo is checked for NULL, but then dereferenced\n\t  unconditionally, fix, CID #63.\n\t  (bgp_withdraw_packet) Assert adv->rn is valid, as with\n\t  bgp_update_packet().\n\n2006-10-14 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_fsm.h: Remove BGP_EVENT_FLUSH_ADD, dangerous and not\n\t  needed.\n\t* bgp_fsm.c: (bgp_stop) Move BGP_EVENT_FLUSH to the top of the\n\t  of the function, otherwise it could flush a ClearingCompleted\n          event, bug #302.\n\t* bgp_packet.c: Replace all BGP_EVENT_FLUSH_ADD with\n\t  BGP_EVENT_ADD, fixing bug #302.\n\n2006-09-19 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* bgpd.c: (peer_uptime) Fix printf format/arg mismatch in\n\t  zlog_warn message (%ld/size_t -> %lu/u_long).\n\n2006-09-14 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_route.c: (bgp_table_stats_walker) Address space announced\n\t  should only count top-level unaggregateable prefixes, to\n\t  avoid falling afoul of anti-dodgy-accounting regulations\n\t  in various jurisdictions.. ;)\n\t  (bgp_process_queue_init) process queue hold time too high,\n\t  adds extra memory load. Change to be much lower, until such\n\t  time as it's made configurable.\n\n2006-09-14 Paul Jakma <paul.jakma@sun.com>\n\n\t* (general) fix the peer refcount issue exposed by previous, by\n\t  just removing refcounting of peer threads, which is mostly\n\t  senseless as they're references leading from struct peer,\n\t  which peer_free cancels anyway. No need to muck around..\n\t* bgp_fsm.h: Just remove the refcounting from the various\n\t  TIMER/READ/WRITE/EVENT ON/OFF/ADD macros.\n\t* bgp_fsm.c: (bgp_stop) use BGP_EVENT_FLUSH, no refcounts attached\n\t  to events anymore.\n\t  (bgp_event) remove peer_unlock, events not refcounted.\n\t* bgpd.c: (peer_free) flush events before free.\n\n2006-09-14 Paul Jakma <paul.jakma@sun.com>\n\n\t* (general) Fix some niggly issues around 'shutdown' and clearing\n\t  by adding a Clearing FSM wait-state and a hidden 'Deleted'\n\t  FSM state, to allow deleted peers to 'cool off' and hit 0\n\t  references. This introduces a slow memory leak of struct peer,\n\t  however that's more a testament to the fragility of the\n\t  reference counting than a bug in this patch, cleanup of\n\t  reference counting to fix this is to follow.\n\t* bgpd.h: Add Clearing, Deleted states and Clearing_Completed\n\t  and event.\n\t* bgp_debug.c: (bgp_status_msg[]) Add strings for Clearing and\n\t  Deleted.\n\t* bgp_fsm.h: Don't allow timer/event threads to set anything\n\t  for Deleted peers.\n\t* bgp_fsm.c: (bgp_timer_set) Add Clearing and Deleted. Deleted\n\t  needs to stop everything.\n\t  (bgp_stop) Remove explicit fsm_change_status call, the\n\t  general framework handles the transition.\n\t  (bgp_start) Log a warning if a start is attempted on a peer\n\t  that should stay down, trying to start a peer.\n\t  (struct .. FSM) Add Clearing_Completed\n\t  events, has little influence except when in state\n\t  Clearing to signal wait-state can end.\n\t  Add Clearing and Deleted states, former is a wait-state,\n\t  latter is a placeholder state to allow peers to disappear\n\t  quietly once refcounts settle.\n\t  (bgp_event) Try reduce verbosity of FSM state-change debug, \n\t  changes to same state are not interesting (Established->Established)\n\t  Allow NULL action functions in FSM.\n\t* bgp_packet.c: (bgp_write) Use FSM events, rather than trying\n\t  to twiddle directly with FSM state behind the back of FSM.\n\t  (bgp_write_notify) ditto.\n\t  (bgp_read) Remove the vague ACCEPT_PEER peer_unlock, or else\n\t  this patch crashes, now it leaks instead.\n\t* bgp_route.c: (bgp_clear_node_complete) Clearing_Completed\n\t  event, to end clearing.\n\t  (bgp_clear_route) See extensive comments.\n\t* bgpd.c: (peer_free) should only be called while in Deleted,\n\t  peer refcounting controls when peer_free is called.\n\t  bgp_sync_delete should be here, not in peer_delete.\n\t  (peer_delete) Initiate delete. \n\t  Transition to Deleted state manually.\n\t  When removing peer from indices that provide visibility of it,\n\t  take great care to be idempotent wrt the reference counting\n\t  of struct peer through those indices.\n\t  Use bgp_timer_set, rather than replicating.\n\t  Call to bgp_sync_delete isn't appropriate here, sync can be\n\t  referenced while shutting down and finishing deletion.\n\t  (peer_group_bind) Take care to be idempotent wrt list references\n\t  indexing peers.\n\n2006-09-13 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_aspath.c: (aspath_highest) new, return highest ASN in an\n\t  aspath.\n\t* bgp_route.c: (bgp_peer_count_walker) new, do the walk done\n\t  in bgp_peer_counts as a thread.\n\t  (bgp_peer_counts) move walk to previous and call it via\n\t  thread_execute so this RIB walk shows up in thread stats.\n\t  (bgp_table_stats) New, gather some statistics for a given\n\t  RIB.\n\t  (bgp_table_stats_walker) New, RIB walker thread for former.\n\t  (bgp_table_stats_vty) Parsing front-end for 'show bgp ...',\n\t  useful model for future rationalisation of 'show ... bgp'.\n\t  (bgp_route_init) Add new RIB stats commands.\n\t\n2006-09-06 Paul Jakma <paul.jakma@sun.com>\n\n\t* (general) Squash any and all prefix-count issues by\n\t  abstracting route flag changes, and maintaining count as and\n\t  when flags are modified (rather than relying on explicit\n\t  modifications of count being sprinkled in just the right\n\t  places throughout the code).\n\t* bgp_route.c: (bgp_pcount_{dec,inc}rement) removed.\n\t  (bgp_pcount_adjust) new, update prefix count as\n\t  needed for a given route.\n\t  (bgp_info_{uns,s}et_flag) set/unset a BGP_INFO route status\n\t  flag, calling previous function when appropriate.\n\t  (general) Update all set/unsets of flags to use previous.\n\t  Remove pcount_{dec,inc}rement calls.\n\t  No need to unset BGP_INFO_VALID in places where\n\t  bgp_info_delete is called, it does that anyway.\n\t* bgp_{damp,nexthop}.c: Update to use bgp_info_{un,}set_flag.\n\t* bgp_route.h: Export bgp_info_{un,}set_flag.\n\t  Add a 'meta' BGP_INFO flag, BGP_INFO_UNUSEABLE.\n\t  Move BGP_INFO_HOLDDOWN macro to here from bgpd.h\n\n2006-09-03 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_route.c: Add 'show ... bgp ... <neighbour> prefix-count'\n\t  commands, to provide detailed counts of prefixes for a peer.\n\t  Informative, and should help pin down to pfxcnt drift\n\t  problems.\n\n2006-08-27 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_advertise.c: (bgp_sync_delete) fix mtype in XFREE.\n\t  NULL out peer->hash after free, to be sure.\n\n2006-08-06 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_aspath.c: (aspath_loop_check) Fix the typo-bug which\n\t  essentially had disabled this check. Problem reported by\n\t  Bartek Kania <mrbk@gnarf.org> in [quagga-users 7388].\n\n2006-07-27 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgpd.c: (peer_delete) Ensure freed buffers can not be\n\t  accidently reused. A potential fix for bug #287.\n\n2006-07-02 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_fsm.c: (bgp_{stop,start}) Move clear/free of certain\n\t  bits of state from stop to start, as they may be used via\n\t  peer references on clearing queues..\n\n2006-05-23 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_vty.c: (neighbor_update_source_cmd) Expand tab completion\n\t  to make it clear it takes both address and ifname.\n\n2006-05-12 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_attr.c: (bgp_packet_attribute) Remove dead code, Coverity\n\t  CID #1\n\t* bgp_aspath.{c,h}: (aspath_print_vty) take a format string,\n\t  so as to reduce burden on callers, all in bgp_route.c\n\t* bgp_route.c: (bgp_static_update_main) Remove useless NULL\n\t  check, code already assumes bgp_static can not be NULL, \n\t  fixes CID #7.\n\t  (bgp_static_update_rsclient) ditto, CID #6\n\t  (route_vty_out{,tmp}) Update to match aspath_print_vty,\n\t  simplifying checks needed to get spacing right. CID #4,#5.\n\t  ({damp,flap}_route_vty_out) Ditto, CID #9, #10\n\n2006-05-08 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_community.c: (community_str2com) Coverity CID#62, fix\n\t  double-free, use-after-free.\n\t* bgp_route.c: (bgp_afi_node_get) given table should never be\n\t  NULL, check/assert this.\n\t  (bgp_static_update) Bug #240. Rsclients should only be passed\n\t  the static update if they are configured for the afi,safi.\n\n2006-05-04 Paul Jakma <paul.jakma@sun.com>\n\n\t* (general) VPNv4 fixes. Certain VPNv4 code was not enabled.\n\t  See bug #210.\n\t* bgp_attr.{c,h}: (bgp_packet_{withdraw,attribute}) Tag should be\n\t  u_char really.\n\t* bgp_packet.c: (bgp_{update,withdraw}_packet) Enable some\n\t  VPNv4 code which inexplicably was ifdef'd out. comments from\n\t  a tester on IRC suggest this fixes bug #210.\n\t* bgp_route.c: (general) Fix logical bug in clearing, noted\n\t  by Chris Caputo in [quagga-users 6728] - clearing depended on\n\t  at least one route being added to workqueue, in order for\n\t  workqueue completion function to restart FSM. However, if no\n\t  routes are cleared, then the completion function never is\n\t  called, it needs to be called manually if the workqueue\n\t  didn't get scheduled. \n\t  Finally, clearing is per-peer-session, not per AFI/SAFI, so\n\t  the FSM synchronisation should be in bgp_clear_route_table.\n\t  (bgp_clear_route_table) Wrong place for FSM/clearing\n\t  synchronisation, move to..\n\t  (bgp_clear_route) FSM/clearing synchronisation should be\n\t  here.\n\t  If no routes were cleared, no workqueue scheduled, call\n\t  the completion func to ensure FSM kicks off again.\n\n2006-03-30 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_community.c: (community_gettoken) Unknown token should\n\t  return NULL, to give a strong indication to callers that\n\t  the token no longer can be parsed, otherwise callers looping\n\t  on this function may have a hard time ending their loop.\n\t  (community_str2com) While loop around community_gettoken appears\n\t  to have been coded thinking that break statement would break\n\t  from the while{}, hence it could never exit for unknown token\n\t  case. Fix it to do..while, so it can use the NULL result from\n\t  community_gettoken easily.\n\n2006-03-22 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgpd.c: (peer_free) release the per-peer workqueue when\n\t  freeing the peer.\n\n2006-03-19 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgpd/bgp_vty.c: Add includes to get several structs we want\n\t  to provide usage statistics on.\n\t  (show_bgp_memory_cmd) Show memory usage stats for various\n\t  notable fixed size objects. Using mtype_stats_alloc and\n\t  mtype_memstr recently added to memory.c.\n\t  (bgp_show_summary) Report some additional stats specific to\n\t  the given BGP instance and/or AFI/SAFI such as table counts,\n\t  peers, rsclients and peer-groups.\n\t  (bgp_vty_init) Install show_bgp_memory_cmd.\n\t* bgp_nexthop.h: Include if.h as a dependent header, for struct\n\t  connected.\n\t* bgp_advertise.c: Use a distinct memory type for struct\n\t  bgp_synchronize.\n\n2006-03-12 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_attr.h: (struct attr) rearrange fields to avoid\n\t  wasted padding between them as much as possible.\n\t  (attr_count,attr_unknown_count) export new functions to\n\t  return number of counts of cached attributes.\n\t* bgp_attr.c: (attr_count,attr_unknown_count) new functions to\n\t  return number of counts of cached attributes.\n\t* bgp_route.h: (struct bgp_info) rearrange fields to avoid\n\t  wasted padding.\n\t* bgp_table.h: (struct bgp_table) Add a count field, of number\n\t  of nodes in the table.\n\t  (struct bgp_node)  rearrange fields to avoid\n\t  wasted padding between them, though I don't think there\n\t  was any in this case. \n\t* bgp_table.c: (bgp_node_{delete,get}) Maintain the table node count.\n\t  (bgp_table_count) new function to access the table count.\n\n2006-03-03 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_route.c: (bgp_clear_node_complete) Doh. When clearing\n\t  is complete we need to kick off FSM again.\n\n2006-02-21 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgpd.h: move the clear_node_queue to be peer specific.\n\t  Add a new peer status flag, PEER_STATUS_CLEARING.\n\t* bgp_table.h: (struct bgp_table) Add fields to record afi,\n          safi of the table.\n          (bgp_table_init) Take afi and safi to create table for.\n        * bgp_table.c: (bgp_table_init) record the afi and safi.\n        * bgp_nexthop.c: Update all calls to bgp_table_init.\n        * bgp_vty.c: ditto.\n        * bgpd.c: ditto.\n        * bgp_fsm.c: (bgp_timer_set) dont bring up a session which is\n\t  clearing.\n        * bgp_route.c: (general) Update all bgp_table_init calls.\n          (bgp_process_{rsclient,main}) clear_node is serialised\n          via PEER_STATUS_CLEARING and fsm now.\n          (struct bgp_clear_node_queue) can be removed. struct bgp_node\n          can be the queue item data directly, as struct peer can be\n          kept in the new wq global user data and afi/safi can be\n          retrieved via bgp_node -> bgp_table.\n          (bgp_clear_route_node) fix to get peer via wq->spec.data,\n          afi/safi via bgp_node->bgp_table.\n          (bgp_clear_node_queue_del) no more item data to delete, only\n          unlock the bgp_node.\n          (bgp_clear_node_complete) only need to unset CLEARING flag\n          and unlock struct peer.\n          (bgp_clear_node_queue_init) queue attaches to struct peer\n          now. record peer name as queue name.\n          (bgp_clear_route_table) If queue transitions to active,\n          serialise clearing by setting PEER_STATUS_CLEARING rather\n          than plugging process queue, and lock peer while queue\n          active.\n          Update to pass only bgp_node as per-queue-item specific data.\n\t* bgp_vty.c: (bgp_show_summary) Add a 'Clrng' sub-description\n\t  to state of peer while it's suppressed due to clearing.\n\n2006-02-18 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_routemap.c: (route_set_community) Quick, very hacky, fix\n\t  for the set-community leak, bug #89. True fix will be to\n\t  detangle the web of *_intern caching and provide saner object\n\t  caching for Quagga, future work.\n\t* bgp_route.c: (bgp_announce_check) trivial, move declaration\n\t  of two local variables into the only block where they are\n\t  used, to aid the reader.\n\n2006-02-05 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_route.h: Add BGP_INFO_COUNTED to track whether\n\t  prefix has been counted or not.\n\t* bgp_route.c: (bgp_pcount_{inc,dec}rement) new helpers, to\n\t  centralise inc/dec of prefix-count, \n\t  (bgp_rib_remove) Remove pcount decrement, use helper.\n\t  (bgp_rib_withdraw) ditto, additionally use previous function\n\t  too.\n\t  (bgp_update_main) Use pcount helpers.\n\t  (bgp_clear_route_node) ditto, aslo REMOVED routes don't need\n\t  clearing.\n\t* bgp_aspath.c: (aspath_gettoken) fix gcc warning about\n\t  possible uninitialised usage.\n \n2006-02-02 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_route.c: (bgp_{clear_node,process}_queue_init) delay\n\t  field is removed from workqueue spec.\n\n2006-01-19 Paul Jakma <paul.jakma@sun.com>\n\n\t* (general) various miscellaneous compiler warning fixes.\n\t   Remove redundant break statements from switch clauses\n\t   which return.\n\t   return from main, not exit, cause it annoys SOS.\n\t   Remove stray semi-colons which cause empty-statement\n\t   warnings.\n\n2006-01-17 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_nexthop.c: (zlookup_read*) convert to new Zserv format.\n\t  (zlookup_query_ipv6) ditto.\n\t  (bgp_import_check) ditto.\n\t  \n2006-01-16 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_aspath.c: (assegment_append_asns) XREALLOC can return\n\t  NULL theoretically, take care not to lose the allocated data.\n\t  (aspath_hash_alloc) aspath_dup already set the aspath\n\t  string - fix leak.\n\t  (aspath_parse) aspath_hash_alloc dupes the entire aspath,\n\t  including segments, but we forgot to free the temporary\n\t  assegment.\n\t  (aspath_snmp_pathseg) move the static stream pointer out to\n\t  file scope, so it can be freed.\n\t  (aspath_finish) new function, free aspath resources.\n\t* bgp_aspath.h: (aspath_finish) export.\n\n2006-01-10 Juris Kalnins <juris@mt.lv>\n\n\t* bgpd.h: (bgp_router_id_unset) ex-function, remove.\n\t\n2005-11-23 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_aspath.c: (assegments_parse) should be static\n\n2005-11-23 Juergen Kammer <j.kammer@eurodata.de>\n\n\t* bgp_aspath.c: (aspath_cmp_left_confed) fix SEGV for case\n\t  where one or both paths are empty.\n\n2005-11-14 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_route.c: (bgp_process_rsclient)\u00a0convert to new workqueue\n          specs and shut up gcc, which complains about cast from void\n          via function parameters, for some dumb reason. Do the cast\n          inside the function instead.\n          (bgp_process_main,bgp_processq_del) ditto.\n          (bgp_clear_route_node) ditto.\n          (bgp_clear_node_queue_del) ditto.\n\n2005-11-03 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_damp.c: (bgp_reuse_timer) struct bgp can be retrieved via\n\t  the struct bgp_damp_info, no need to guess by using\n\t  bgp_get_default().\n\n2005-10-01 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* bgp_vty.c: (bgp_config_write_redistribute) Use new library function\n\t  zebra_route_string instead of a local hard-coded table.\n\n2005-09-30 Vincent Jardin <vincent.jardin@6wind.com>\n\n\t* bgp_packet.c: fix compilation when DEBUG is used.\n\n2005-09-10 Paul Jakma <paul.jakma@sun.com>\n\n\t* Makefile.am: bgpd shouldn't list libgp's sources as its own.\n\t  Use LDADD.\n\t* bgp_aspath.h:\t\n\t  (struct assegment) New struct, abstract representation of a\n\t  list of AS_PATH segments and the contained ASNs.\t  \n\t  (struct aspath) Remove the raw-data related\n\t  fields, reference the abstract struct assegment instead. \n\t  Remove several other computed fields, it's just a\n\t  headache to maintain them and they're cheap to compute from\n\t  struct assegment.\n\t  (aspath_parse) parse a stream, not a pointer to raw data.\n\t  (aspath_count_{hops,confeds,size}) helpers to access\n\t  information formerly directly contained in struct aspath.\n\t  (aspath_snmp_pathseg) Helper for SNMP, BGP MIB wants\n\t  to be able to output hex representation of raw data.\n\t* bgp_aspath.c: (general) partial-rewrite. Store aspath data\n\t  as an abstract singly-linked list of abstract segments,\n          rather than storing the raw data, and parsing it each and\n\t  every time. Remove several count/size fields which are cheap\n\t  to compute from the abstract segment structure.\n\t  (global) Include stream.h, needed for aspath_parse, and\n\t  others. Couple of helper macros added.\n\t  (struct assegment_header) Just the header, and only the\n\t  header.\n\t  (assegment_data_{new,free}) convenience functions for\n\t  AS_SEG_DATA allocation, the dynamic, per-segment array of\n\t  ASNs.\n\t  (assegment_{new,free,free_all,dup,dup_all}) convenience\n\t  functions for creating struct assegments. The _all forms will\n\t  follow the entire chain of segments from the given segment.\n\t  (assegment_prepend_asns) new function, prepend an ASN N times\n\t  to segment.\n \t  (assegment_append_asns) Append a list (array) of ASNs to\n\t  segment.\n\t  (int_cmp) convenience function for the aspath hash.\n\t  (assegment_normalise) new function. Normalise the given\n\t  segment chain to meet expectations of Quagga, and to\n\t  eliminate differing raw representations of the same paths.\n\t  Merge 'runs' of SEQUENCEs into one segment as our internal\n\t  segment is not limited by the protocol AS_PATH segment\n\t  length. Sort ASNs in SETs. \n\t  (aspath_new) Take void argument to quell warnings. Use the\n\t  assegment convenience functions.\n\t  (assegment_count_{asns,confeds,hops}) new functions to\n\t  compute at runtime values previously held in struct aspath.\n\t  (aspath_size) ditto.\n\t  (aspath_make_str_count) rewritten to stringify new\n\t  representation, and to be slightly easier to understand\n\t  hopefully.\n\t  (aspath_str_update) convenience function, update the aspath\n\t  str. Should investigate removing maintained string from\n\t  struct aspath, just run-time compute it, as per other fields.\n\t  It's just a maintenance headache, would save noticeable\n\t  amount of RAM with possibly not much extra run-time cost.\n\t  (aspath_dup) use the assegment dup functions.\n\t  (aspath_hash_alloc) Take void * argument to satisfy gcc. Use\n\t  the proper helper functions to dup data.\n\t  (assegments_parse) new function. parse raw AS_PATH data into\n\t  struct assegments. Normalise and return the head of the list.\n\t  (aspath_parse) Parse a stream, not pointer to raw data and\n\t  use assegments_parse to do it.\n\t  (assegment_data_put) Write out a single segment data in protocol\n\t  form to stream.\n\t  (assegment_header_put) ditto but for segment header.\n\t  (aspath_put) new function. As per previous but for an entire\n\t  struct aspath.\n\t  (aspath_snmp_pathseg) wrapper around aspath_put for\n\t  bgp_snmp.c. Uses a static buffer sadly.\n\t  (aspath_aggregate_as_set_add) rewritten to use assegments.\n\t  (aspath_aggregate) ditto\n\t  (aspath_{firstas,loop,private_as}_check) ditto\n\t  (aspath_{merge,prepend,add_one_as}) ditto\n\t  (aspath_cmp_left{_confed}) ditto\n\t  (aspath_delete_confed_seq) ditto, plus fixed to properly\n\t  delete all leading confed segments.\n\t  (aspath_as_add) Just use assegment_append_asns.\n\t  (aspath_segment_add) updated to use assegments.\n\t  (enum as_token) Add values for confeds\n\t  (aspath_gettoken) Add support for confeds\n\t  (aspath_str2aspath) ditto\n\t  (aspath_key_make) updated to use as_segments. Also, add\n\t  segment type into the hash value as appropriate.\n\t  (aspath_cmp) updated to use as_segments.\n\t  (aspath_print) don't segfault on NULL argument.\n\t* bgp_attr.c: (bgp_attr_aspath) aspath_parse wants the stream\n\t  now. No need for manual forwarding of stream.\n\t  (bgp_packet_attribute) empty aspath is now denoted by NULL\n\t  segment field, length is gone.\n\t  Use aspath_size() to determine size.\n\t  (bgp_attr_init) Fix declaration, explicitely specify void\n\t  arg.\n\t  (bgp_dump_routes_attr) Use aspath_size() to determine size.\n\t* bgp_route.c: (bgp_info_cmp) use the aspath_count_* functions.\n\t  (bgp_rib_withdraw) remove unused variable. Use\n\t  aspath_count_hops.\n\t* bgp_snmp.c: (bgp4PathAttrTable) raw data is gone, use \n\t  aspath_snmp_pathseg to get the representation.\n\n2005-09-10 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_vty.c: (bgp_vty_init) gcc 4 compile fix. static\n\t  function declarations shouldn't be inside functions.\n\t* bgp_dump.c: (bgp_dump_interval_add) ditto.\n\t\n2005-08-26 Hasso Tepper <hasso at quagga.net>\n\n\t* bgp_route.c: Third (?) attempt to fix best selection breakage\n\t  introduced long time ago with route server patch. Hopefully\n\t  it's last case to fix - route-server client not in peer group.\n\n2005-08-22 Hugo Santos <hsantos@av.it.pt>\n\n\t* bgp_vty.c: (general) Add support for BGP IPv6 Multicast SAFI\n\t  commands and BGP_IPV6M_NODE.\n\t  \n2005-08-22 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_route.h: (struct bgp_info) add a new flag, BGP_INFO_REMOVED.\n\t  BGP_INFO_VALID is already overloaded, don't care to do same thing\n\t  to STALE or HISTORY.\n\t* bgpd.h: (BGP_INFO_HOLDDOWN) Add INFO_REMOVED to the macro, as a\n\t  route which should generally be ignored.\n\t* bgp_route.c: (bgp_info_delete) Just set the REMOVE flag, rather \n\t  than doing actual work, so that bgp_process (called directly,\n\t  or indirectly via the scanner) can catch withdrawn routes.\n\t  (bgp_info_reap) Actually remove the route, what bgp_info_delete\n\t  used to do, only for use by bgp_process.\n\t  (bgp_best_selection) reap any REMOVED routes, other than the old\n\t  selected route.\n\t  (bgp_process_rsclient) reap the old-selected route, if appropriate\n\t  (bgp_process_main) ditto\n\t  (bgp_rib_withdraw, bgp_rib_remove) make them more consistent with\n\t  each other. Don't play games with the VALID flag, bgp_process\n\t  is async now, so it didn't make a difference anyway.\n\t  Remove the 'force' argument from bgp_rib_withdraw, withdraw+force\n\t  is equivalent to bgp_rib_remove. Update all its callers.\n\t  (bgp_update_rsclient) bgp_rib_withdraw and force set is same as\n\t  bgp_rib_remove.\n\t  (route_vty_short_status_out) new helper to print the leading\n\t  route-status string used in many command outputs. Consolidate.\n\t  (route_vty_out, route_vty_out_tag, damp_route_vty_out, \n\t   flap_route_vty_out) use route_vty_short_status_out rather than\n\t  duplicate.\n\t  (route_vty_out_detail) print state of REMOVED flag.\n\t  (BGP_SHOW_SCODE_HEADER) update for Removed flag. \n\t  \n2005-08-03 Hasso Tepper <hasso at quagga.net>\n\n\t* bgp_routemap.c: Revert part of leaking communities fix commited in\n\t  2005-05-27. While ecommunity fix seems to be correct, community case\n\t  isn't.\n\n2005-06-28 Paul Jakma <paul.jakma@sun.com>\n\n\t* (global) The great bgpd extern and static'ification.\n\t* bgp_routemap.c: remove unused ROUTE_MATCH_ASPATH_OLD code\n\t  (route_set_metric_compile) fix u_int32_t to ULONG_MAX comparison\n\t  warnings.\n\t* bgp_route.h: (bgp_process, bgp_withdraw, bgp_update) export these\n\t  used by various files which had their own private declarations,\n\t  in the case of mplsvpn - incorrect.\n\n2005-06-15 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgpd.c: (bgp_terminate) workqueue's are lazy allocated and its\n\t  possible to terminate bgpd before workqueues were setup, causing\n\t  an abort/crash. Reported by Ashish Mehta of Sun.\n\n2005-06-01 Paul Jakma <paul.jakma@sun.com>\n\n\t* (general) refcount struct peer and bgp_info, hence allowing us\n\t  add work_queues for bgp_process.\n\t* bgp_route.h: (struct bgp_info) Add 'lock' field for refcount.\n\t  Add bgp_info_{lock,unlock} helper functions.\n\t  Add bgp_info_{add,delete} helpers, to remove need for\n\t  users managing locking/freeing of bgp_info and bgp_node's.\n\t* bgp_table.h: (struct bgp_node) Add a flags field, and\n\t  BGP_NODE_PROCESS_SCHEDULED to merge redundant processing of\n\t  nodes.\n\t* bgp_fsm.h: Make the ON/OFF/ADD/REMOVE macros lock and unlock\n\t  peer reference as appropriate.\n\t* bgp_damp.c: Remove its internal prototypes for\n\t  bgp_info_delete/free. Just use bgp_info_delete.\n\t* bgpd.h: (struct bgp_master) Add work_queue pointers.\n\t  (struct peer) Add reference count 'lock'\n\t  (peer_lock,peer_unlock) New helpers to take/release reference\n\t  on struct peer.\n\t* bgp_advertise.c: (general) Add peer and bgp_info refcounting \n\t  and balance how references are taken and released.\n\t  (bgp_advertise_free) release bgp_info reference, if appropriate\n\t  (bgp_adj_out_free) unlock peer\n\t  (bgp_advertise_clean) leave the adv references alone, or else\n\t  call bgp_advertise_free cant unlock them.\n\t  (bgp_adj_out_set) lock the peer on new adj's, leave the reference\n\t  alone otherwise. lock the new bgp_info reference.\n\t  (bgp_adj_in_set) lock the peer reference\n\t  (bgp_adj_in_remove) and unlock it here\n\t  (bgp_sync_delete) make hash_free on peer conditional, just in\n\t  case.\n\t* bgp_fsm.c: (general) document that the timers depend on\n\t  bgp_event to release a peer reference.\n\t  (bgp_fsm_change_status) moved up the file, unchanged.\n\t  (bgp_stop) Decrement peer lock as many times as cancel_event\n\t  canceled - shouldnt be needed but just in case.\n\t  stream_fifo_clean of obuf made conditional, just in case.\n\t  (bgp_event) always unlock the peer, regardless of return value\n\t  of bgp_fsm_change_status.\n\t* bgp_packet.c: (general) change several bgp_stop's to BGP_EVENT's.\n\t  (bgp_read) Add a mysterious extra peer_unlock for ACCEPT_PEERs\n\t  along with a comment on it.\n\t* bgp_route.c: (general) Add refcounting of bgp_info, cleanup\n\t  some of the resource management around bgp_info. Refcount peer.\n\t  Add workqueues for bgp_process and clear_table.\n\t  (bgp_info_new) make static\n\t  (bgp_info_free) Ditto, and unlock the peer reference.\n\t  (bgp_info_lock,bgp_info_unlock) new exported functions\n\t  (bgp_info_add) Add a bgp_info to a bgp_node in correct fashion,\n\t  taking care of reference counts.\n\t  (bgp_info_delete) do the opposite of bgp_info_add.\n\t  (bgp_process_rsclient) Converted into a work_queue work function.\n\t  (bgp_process_main) ditto.\n\t  (bgp_processq_del) process work queue item deconstructor\n\t  (bgp_process_queue_init) process work queue init\n\t  (bgp_process) call init function if required, set up queue item\n\t  and add to queue, rather than calling process functions directly.\n\t  (bgp_rib_remove) let bgp_info_delete manage bgp_info refcounts\n\t  (bgp_rib_withdraw) ditto\n\t  (bgp_update_rsclient) let bgp_info_add manage refcounts\n\t  (bgp_update_main) ditto\n\t  (bgp_clear_route_node) clear_node_queue work function, does\n\t  per-node aspects of what bgp_clear_route_table did previously\n\t  (bgp_clear_node_queue_del) clear_node_queue item delete function\n\t  (bgp_clear_node_complete) clear_node_queue completion function,\n\t  it unplugs the process queues, which have to be blocked while\n\t  clear_node_queue is being processed to prevent a race.\n\t  (bgp_clear_node_queue_init) init function for clear_node_queue\n\t  work queues\n\t  (bgp_clear_route_table) Sets up items onto a workqueue now, rather\n\t  than clearing each node directly. Plugs both process queues to\n\t  avoid potential race.\n\t  (bgp_static_withdraw_rsclient) let bgp_info_{add,delete} manage\n\t  bgp_info refcounts.\n\t  (bgp_static_update_rsclient) ditto\n\t  (bgp_static_update_main) ditto\n\t  (bgp_static_update_vpnv4) ditto, remove unneeded cast.\n\t  (bgp_static_withdraw) see bgp_static_withdraw_rsclient\n\t  (bgp_static_withdraw_vpnv4) ditto\n\t  (bgp_aggregate_{route,add,delete}) ditto\n\t  (bgp_redistribute_{add,delete,withdraw}) ditto\n\t* bgp_vty.c: (peer_rsclient_set_vty) lock rsclient list peer\n\t  reference\n\t  (peer_rsclient_unset_vty) ditto, but unlock same reference\n\t* bgpd.c: (peer_free) handle frees of info to be kept for lifetime\n\t  of struct peer.\n\t  (peer_lock,peer_unlock) peer refcount helpers\n\t  (peer_new) add initial refcounts\n\t  (peer_create,peer_create_accept) lock peer as appropriate\n\t  (peer_delete) unlock as appropriate, move out some free's to\n\t  peer_free.\n\t  (peer_group_bind,peer_group_unbind) peer refcounting as\n\t  appropriate.\n\t  (bgp_create) check CALLOC return value.\n\t  (bgp_terminate) free workqueues too.\n\t \n2005-05-28 Hasso Tepper <hasso at quagga.net>\n\n\t* bgp_routemap.c: Sync set_metric_addsub_cmd with ripd.\n\n2005-05-27 Hasso Tepper <hasso at quagga.net>\n\n\t* bgp_routemap.c: Stop leaking communities.\n\n2005-05-27 Hasso Tepper <hasso at quagga.net>\n\n\t* bgpd.c: Deleting bgp->rsclient list needs fix similar to pree-groups\n\t  deleting fix. Avoid leaking bgp->group, bgp->peer and bgp->rsclient\n\t  lists.\n\n2005-05-26 Hasso Tepper <hasso at quagga.net>\n\n        * bgpd.c: Don't crash while deleting list of peer-groups.\n\n2005-05-25 Hasso Tepper <hasso at quagga.net>\n\n\t* bgpd.c: Fix obvious (routeserver patch) merge error. This makes \"no\n\t  neighbor x.x.x.x routemap [export|import] commands work again.\n\n2005-05-23 Paul Jakma <paul@dishone.st>\n\n\t* bgp_routemap.c: add semi-colons to VTY_GET_* to match vty.h change\n\t* bgp_fsm.h: Add extern qualifier to exported functions\n\t* bgp_nexthop.c: add static to nexthop specific globals\n\t* *.h: Add guard defines\n\n2005-05-19 Paul Jakma <paul@dishone.st>\n\n\t* bgp_fsm.c: (bgp_stop) use sockunion_free, not XFREE..\n\t* bgp_network.c: (bgp_getsockname) ditto\n\t  (bgp_accept) use XSTRDUP\n\t* bgp_routemap.c: (route_match_peer) ditto, als use a ret value and\n\t  remove one sockunion_free.\n\t* bgpd.c: (peer_delete) ditto.\n\t  XFREE the correct memtype, not free.\n\t  (peer_create) use XSTRDUP\n\t* bgp_packet.c: (bgp_stream_dup) deleted, stream_dup should be used\n\t  (various) update -> s/bgp_stream_dup/stream_dup\n\t  \n\n2005-04-11 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* bgp_zebra.c (bgp_redistribute_set, bgp_redistribute_unset):\n\t  The 2nd arg to zebra_redistribute_send is now zclient instead of\n\t  zclient->sock.\n\n2005-04-09 Akihiro Mizutani <mizutani@net-chef.net>\n\n\t* bgp_vty.c: Make \"exit-address-family\" work in IPv4 unicast address\n\t  family node.\n\n2005-04-08 Martin Ling <martin-quagga@earth.li>\n\n\t* bgp_aspath.[ch], bgp_route.c, bgp_vty.c, bgpd.[ch]: Allow to enable\n\t  the length of confederation path segments to be included during the\n\t  as-path length check in the best path decision.\n\n2005-04-02 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* bgp_zebra.c: (bgp_interface_delete) After deleting, set ifp->ifindex\n\t  to IFINDEX_INTERNAL.\n\n2005-03-21 Hasso Tepper <hasso at quagga.net>\n\n\t* bgp_route.c: Don't crash while clearing route tables if there is\n\t  no particular afi/safi configured.\n\n2005-02-23 Hasso Tepper <hasso at quagga.net>\n\n\t* bgp_route.c: Make reannouncing prefixes with changed attributes\n\t  work again.\n\n2005-02-02 Akihiro Mizutani <mizutani@net-chef.net>\n\n\t* bgp_vty.c: Deprecate \"neighbor transparent-as\" and \"neighbor\n\t  transparent-nexthop\" commands.\n\n2005-02-02 Akihiro Mizutani <mizutani@net-chef.net>\n\n\t* bgp_routemap.c: New route-map command - \"match ip route-source\".\n\n2005-02-02 Akihiro Mizutani <mizutani@net-chef.net>\n\n\t* bgp_clist.[ch], bgp_route.c, bgp_routemap.c, bgp_vty.c:\n\t  community-list cleanup.\n\n2005-02-02 Akihiro Mizutani <mizutani@net-chef.net>\n\n\t* bgp_route.c, bgp_vty.c, bgp_zebra.c, bgpd.[ch]: \"enforce-multihop\"\n\t  -> \"disable-connected-check\".\n\n2005-02-02 Akihiro Mizutani <mizutani@net-chef.net>\n\n\t* bgp_fsm.c, bgp_open.c, bgp_packet.c, bgp_route.[ch], bgp_vty.c,\n\t  bgpd.[ch]: Add BGP_INFO_STALE flag and end-of-rib support. \"bgp\n\t  graceful-restart\" commands added. Show numbers of individual\n\t  messages in \"show ip bgp neighbor\" command. Final pieces of graceful\n\t  restart.\n\n2005-02-01 Akihiro Mizutani <mizutani@net-chef.net>\n\n\t* bgp_open.c, bgp_packet.c, bgp_vty.c, bgpd.[ch]: Remove \"no neighbor\n\t  capability route-refresh\" commands. Route refresh capability is sent\n\t  anyway now. Preserve dummy deprecated commands.\n\n2005-02-01 Akihiro Mizutani <mizutani@net-chef.net>\n\n\t* bgp_attr.c, bgp_snmp.c, bgp_vty.c, bgpd.[ch]: Remove support for old\n\t  draft - ie. \"neighbor version 4-\" commands. Preserve dummy \"neighbor\n\t  version\" command as deprecated.\n\n2005-02-01 Akihiro Mizutani <mizutani@net-chef.net>\n\n\t* bgpd.[ch], bgp_vty.c, bgp_route.c: \"Restart session after\n\t  maximum-prefix limit\" feature support.\n\n2005-02-01 Akihiro Mizutani <mizutani@net-chef.net>\n\n\t* bgp_nexthop.c: Improve debug.\n\t* bgpd.[ch], bgp_nexthop.c, bgp_snmp.c: Remove useless bgp_get_master()\n\t  function.\n\t* bgp_packet.c: MP AFI_IP update and withdraw parsing.\n\t* bgp_fsm.c: Reset peer synctime in bgp_stop(). bgp_fsm_change_status()\n\t  is better place to log about peer status change than bgp_event().\n\t  Log in bgp_connect_success().\n\t* bgp_vty.c: Fix typo in comment.\n\t* bgp_attr.c: Better log about unknown attribute.\n\n2005-01-29 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* bgp_filter.c: (ip_as_path,no_ip_as_path) Use argv_concat instead\n\t  of buffer_getstr.\n\t* bgp_route.c: (bgp_show_regexp) Fix memory leak: need to free string\n\t  returned by buffer_getstr.\n\t  (bgp_show_community) Must use XFREE instead of free on string\n\t  returned by buffer_getstr.\n\t* bgp_routemap.c: (set_community) Must use XFREE instead of free\n\t  on string returned by buffer_getstr.\n\t* bgp_vty.c: (neighbor_description) Use argv_concat instead of\n\t  buffer_getstr.\n\n2005-01-24 Hasso Tepper <hasso at quagga.net>\n\n\t* bgp_route.c: Fix showstopper bug. New route must be selected also\n\t  if old one is flaged as BGP_INFO_ATTR_CHANGED.\n\n2005-01-17 Hasso Tepper <hasso at quagga.net>\n\n\t* bgp_route.c: Clear peer's routing table regardless whether it's\n\t  configured or not. Being not configured is even better reason to\n\t  do it.\n\n2005-01-05 Paul Jakma <paul@dishone.st>\n\n\t* bgp_packet.c: (bgp_write) set socket to nonblock while writing\n          this should be generalised. See bugzilla #102. Fix supplied by\n\t  wawa@yandex-team.ru (Vladimir Ivanov).\n\n2004-12-08 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* *.c: Change level of debug messages to LOG_DEBUG.\n\n2004-12-07 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* bgp_main.c: (main) The 2nd argument to openzlog has been removed.\n\n2004-12-03 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* bgp_main.c: (sigint) Use zlog_notice for termination message.\n\t  (main) Use zlog_notice for startup announcement.\n\n2004-11-25 Hasso Tepper <hasso at quagga.net>\n\n\t* bgp_main.c: Make group to run as configurable.\n\n2004-11-09 Paul Jakma <paul@dishone.st>\n\n\t* bgp_nexthop.c: collapse bgp_connected_ipvX, bgp_nexthop_cache_ipvX\n\t  and cache{1,2}.. into arrays of tables and hence collapse\n          bgp_scan_ipv{4,6} into a single bgp_scan function. Tested, though\n          a long time ago (and this change was hand-merged).\n\n2004-11-04 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* bgp_route.c: Remove all code related to VTY_CONTINUE; this feature\n\t  is deprecated because the output did not represent a single point\n\t  in time.  All output needs to be generated inline and buffered\n\t  by the library code.\n\t  (route_vty_out,route_vty_out_tag,damp_route_vty_out,\n\t   flap_route_vty_out) Remove code to count number of lines of output,\n\t   since this was only useful for VTY_CONTINUE behavior.\n\t  (bgp_show_callback,vty_calc_line) Removed.\n\t  (bgp_show_table) Remove hooks for VTY_CONTINUE callback support.\n\t  As a result, there's a new output_arg argument to this function.\n\t  Make function static.\n\t  (bgp_show) Make function static and add a new output_arg argument.\n\t  Change all functions that call bgp_show or bgp_show_table to\n\t  pass the new output_arg argument (that used to be passed inside\n\t  vty->output_arg).\n\t* bgp_mplsvpn.c: Remove declarations of functions defined in\n\t  bgp_route.c; these declarations belong in bgp_route.h.\n\t* bgp_route.h: Declare 3 global functions used in both bgp_route.c\n\t  and in bgp_mplsvpn.c.\n\n2004-10-31 Paul Jakma <paul@dishone.st>\n\n\t* {bgpd,bgp_attr}.c: size_t printf format should be ld.\n\n2004-10-25 Paul Jakma <paul@dishone.st>\n\n\t* Update with fix in debian bug id 222930.\n\t* bgp_main.c: Add ZCAP_RAW, needed to bind to interfaces.\n\t  bgp_network.c: (....) raise/lower privs around call to\n          SO_BINDTODEVICE sockopt. \n\n2004-10-19 Andrew J. Schorr <aschorr@telemetry-investments.com>\n\n\t* bgp_nexthop.c: (bgp_connected_add) Connected destination pointer\n\t  may be NULL.\n\t  (bgp_connected_delete) ditto.\n\n2004-10-14 Hasso Tepper <hasso at quagga.net>\n\n\t* bgp_dump.c: Make dump configuration appear in vtysh.\n\n2004-10-13 Hasso Tepper <hasso at quagga.net>\n\n\t* bgp_snmp.c: Remove defaults used to initialize smux connection to\n\t  snmpd. Connection is initialized only if smux peer is configured.\n\t* bgp_view.c: It's dead file. Reomved.\n\n2004-10-13 Paul Jakma <paul@dishone.st>\n\n\t* (global) more const'ification and fixups of types to clean up code.\n\t* bgp_mplsvpn.{c,h}: (str2tag) fix abuse. Still not perfect,\n          should use something like the VTY_GET_INTEGER macro, but without\n          the vty_out bits..\n        * bgp_routemap.c: (set_aggregator_as) use VTY_GET_INTEGER_RANGE\n          (no_set_aggregator_as) ditto.\n        * bgpd.c: (peer_uptime) fix unlikely bug, where no buffer is \n          returned, add comments about troublesome return value.\n\t\n2004-10-03 James R. Leu <jleu at mindspring.com>\n\n\t* bgp_vty.c: Router id from zebra can be manually overriden.\n\t* bgp_zebra.c: Read router id related messages from zebra daemon.\n\t  Remove own code related with router id selection.\n\t* bgpd.c, bgpd.h: Remove own router id selection code. Use the one\n\t  from zebra daemon if it isn't manually overriden.\n\n2004-09-26 Hasso Tepper <hasso at quagga.net>\n\n\t* bgp_aspath.c, bgp_packet.c, bgp_vty.c: Fix compiler warnings.\n\n2004-09-23 Hasso Tepper <hasso at quagga.net>\n\n\t* *.[c|h]: list -> struct list *, listnode -> struct listnode *.\n\n2004-07-09 Paul Jakma <paul@dishone.st>\n\n\t* Merge of GNU Zebra cvs2svn changesets r799, r800 and r807.\n\t* bgp_dump.c: (bgp_dump_attr) cleanup. return status code. check\n\t  attributes present before printing.\n\t* bgp_dump.c: update bgp_dump_attr prototype.\n\t* bgp_packet.c: (bgp_update_receive) init attrstr. check status\n\t  of bgp_dump_attr. Log end-of-rib UPDATEs.\n\n2004-07-09 Sowmini Varadhan <sowmini.varadhan@sun.com>\n\n\t* bgp_packet.c: (bgp_collision_detect) Send NOTIFY on new socket\n\t  if that is connection we're closing.\n\t  (bgp_read) invalid marker check applies to KEEPALIVE too.\n\t* bgp_route.c: Ignore multicast NRLI, dont send NOTIFY.\n\t\n2004-06-04 Paul Jakma <paul@dishone.st>\n\n\t* type mismatch fixes\n\t  \n2004-05-21  Akihiro Mizutani <mizutani@net-chef.net>\n\n\t* bgpd.h, bgp_open.[ch], bgp_debug.c, bgp_vty.[ch], bgp_fsm.c:\n\t  Graceful restart capability display.\n\n2005-05-20 Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* bgp_debug.c: Cosmetical fixes and log neighbor changes.\n\n2004-05-20  Akihiro Mizutani <mizutani@net-chef.net>\n\n\t* bgp_ecommunity.c: Transit ecommunity support.\n\t* bgp_ecommunity.c: Fix for unknown community crush.\n\n2005-05-20 Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* *: Maximum prefix threshold support.\n\t* *: Reset notification fixups.\n\n2004-05-08 Paul Jakma <paul@dishone.st>\n\n\t* bgp_zebra.c: (bgp_interface_address_add) sync to zclient changes\n\t  (bgp_interface_address_delete) ditto.\n\t  (bgp_zebra_announce) ditto.\n\t  (bgp_zebra_withdraw) ditto.\n\n2004-05-03 Daniel Roesen <dr@cluenet.de>\n\t\n\t* bgp_fsm.c: (bgp_stop) Reset uptime only on transition from \n\t  Established so that it reflects true downtime (rather time \n\t  since last transition, eg Active->Idle)\n\t  \n2004-05-01 rivo nurges <rix@estpak.ee>\n \n        * bgp_route.c: fix UNH IOL BGP-4.1.12f\n \n2004-05-01 Paul Jakma <paul@dishone.st>\n\n\t* Revert the attempted clean-up of the dummy peer hack, reverts\n\t  patchsets 435 (see 2004-02-17 below) and 456. \n\n2004-04-16 rivo nurges <rix@estpak.ee>\n\n\t* bgpd.h, bgp_debug.c: update cease subcodes to\n\t  draft-ietf-idr-cease-subcode-05\n\t* bgpd.h, bgpd.c, bgp_route.c, bgp_route.h: fix UNH IOL BGP-4.1.6a\n\n2004-02-17 Paul Jakma <paul@dishone.st>\n\n\t* bgpd.h: (bgp_peer) add fd_local and fd_accept \n\t  file descriptor's, fd becomes a pointer to one of these.\n\t* bgpd.c: (global) adjust for fact that fd is now a pointer.\n\t  (peer_create_accept) removed.\n\t* bgp_route.c: (global) adjust for change of peer fd to pointer\n\t* bgp_packet.c: (bgp_collision_detect) adjust and remove the \n\t  \"replace with other peer\" hack. \n\t* bgp_network.c: (bgp_accept) Remove the dummy peer hack. \n\t  Update peer->fd_accept instead. \n\t  (global) Adjust fd references - now a pointer.\n\t* bgp_fsm.c: (global) adjust peer fd to pointer.\n\t  (bgp_connection_stop) new function, to stop connection.\n\t  (global) adjust everything which closed peer fd to use\n\t  bgp_connection_stop().\n\t  \n2003-12-23 Krzysztof Oledzki <oleq@ans.pl>\n\n\t* bgp_network.c: drop privs on error cases\n\n2003-08-11 kunihiro <kunihiro@zebra.org>\n\n\t* bgp_route{,map}.c: Extend 'set ip next-hop' in route-maps with\n\t  ability to specify 'peer-address' rather than IP. \n\n2003-06-09 Paul Jakma <paul@dishone.st>\n\n\t* bgp_clist.c (community_list_delete): honour deny statements\n\n2003-04-19 Hasso Tepper <hasso@estpak.ee>\n\n\t* rip_routemap.c: sync daemon's route-map commands to have same\n\tsyntax\n\n2003-01-09  Akihiro Mizutani <mizutani@net-chef.net>\n\n\t* bgp_routemap.c: Add match extcommunity command.\n\n2002-10-23  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* bgp_aspath.c (aspath_init): Extend hash size from default to\n\t32767.\n\t(aspath_key_make): Use unsigned shoft for making hash.  Suggested\n\tby: Marc Evans <Marc@SoftwareHackery.Com>\n\n2002-08-19  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* bgp_clist.c (community_entry_free): Fix memory leak of standard\n\textcommunity-list config string.\n\n2002-08-19  Akihiro Mizutani <mizutani@net-chef.net>\n\n\t* bgp_route.c (route_vty_out_detail): Fix bug of router-id display\n\twhen multiple instance is used.\n\n2002-08-18  Akihiro Mizutani <mizutani@net-chef.net>\n\n\t* bgpd.c: Make \"default-originate\" and \"maximum-prefix\" commands\n\tavailable in peer-group configuration.\n\n2002-08-13  Akihiro Mizutani <mizutani@net-chef.net>\n\n\t* bgp_packet.c (bgp_open_send): Put Opt Parm Len 0 when last\n\tcapability packet cause error or dont-capability-negotiate option\n\tis specified.\n\n2002-07-07  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* zebra-0.93 released.\n\n2001-10-28  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c (bgp_vty_init): Translate update commands are removed.\n\n2001-10-10  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_static_set): Add workaround for BGP static\n\troute announcement when there is no zebra running.\n\n2001-10-08  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c (neighbor_remote_as_unicast): Remove \"remote-as nlri\n\tunicast multicast\" commands.\n\n2001-09-14  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_open.c: When we receive capability route-refresh, we should\n\tcheck we send the capability not we receive the capability.\n\n\t* bgp_route.c (bgp_network_mask_natural_route_map): network\n\tstatement route-map is added.\n\n2001-08-31  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* bgp_advertise.c (bgp_advertise_intern): attr must be interned\n\tbefore looking up hash table.\n\n2001-08-30  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* bgpd.h (struct peer): BGP filter is moved from peer_conf to\n\tpeer.\n\n2001-08-28  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* bgp_nexthop.c (bnc_nexthop_free): Fix next pointer bug.\n\tSuggested by: \"Hong-Sung Kim\" <hoskim@lanbird.co.kr>.\n\n2001-08-26  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* bgp_table.c (bgp_node_create): Clearn memory before use it.\n\n2001-08-24  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* Change to use bgp_table.[ch].\n\n2001-08-23  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* bgpd.c (bgp_init): Add \"transparent-as\" and\n\t\"transparent-nexthop\" for old version compatibility.\n\n2001-08-23  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgpd.h (struct peer): default-originate route-map is added.\n\n\t* bgp_route.c: When self originated route is advertised with\n\tattrubute-unchanged, nexthop was not properly set.  This bug is\n\tfixed.\n\n2001-08-22  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgpd.c (neighbor_attr_unchanged): transparent-as and\n\ttransparent-next-hop commands are restructured.  Instead of\n\tcurrent transparent-* commands, attribute-unchanged command is\n\tintroduced.\n\n\tneighbor A.B.C.D attribute-unchanged [as-path|next-hop|med]\n\n\t(neighbor_default_originate): \"default-originate\" configuration\n\tannounce default route even 0.0.0.0/0 does not exists in BGP RIB.\n\n2001-08-19  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* zebra-0.92a released.\n\n2001-08-19  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgpd.c: AF specific soft-reconfiguration inbound commands are\n\tadded.\n\n2001-08-17  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* bgp_route.c (bgp_show_callback): Do not do community NULL check.\n\n\t* bgp_community.c (community_cmp): Add check for commnunity NULL\n\tcheck.\n\n\t* bgp_routemap.c (route_match_community): Do not check comunity is\n\tNULL.  It may match to community-list \"^$\".\n\n\t* bgp_community.c (community_match): Add check for community is\n\tNULL case.\n\n2001-08-17  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgpd.c: AF specific route-reflector-client and\n\troute-server-client configuration are added.\n\n2001-08-17  Rick Payne <rickp@ayrnetworks.com>\n\n\t* bgp_clist.c (community_match_regexp): Check special ^$ case.\n\n2001-08-17  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_clist.c (community_list_match): Fix bug of community list\n\tpermit and deny check.\n\n2001-08-16  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_mplsvpn.c (bgp_mplsvpn_init): Add AF specific \"nexthop-self\"\n\tcommand.\n\n2001-08-15  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgpd.h (PEER_FLAG_SEND_COMMUNITY): Per AF based configuration\n\tflag is introduced.\n\n\t* bgp_mplsvpn.c (bgp_mplsvpn_init): VPNv4 filtering is added.\n\n2001-08-15  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* zebra-0.92 released.\n\n2001-08-13  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* bgpd.c (bgp_delete): \"no router bgp\" free static, aggregate, rib\n\ttable properly.\n\n2001-08-12  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* bgp_route.c (bgp_node_safi): Return SAFI of current node.\n\t(bgp_config_write_network_vpnv4): VPNv4 static configuration\n\tdisplay.\n\n2001-08-11  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* bgpd.c (no_bgp_ipv4_multicast_route_map): Add IPv4 multicast\n\tnode filter commands.\n\n2001-08-11  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.h (PEER_FLAG_IGNORE_LINK_LOCAL_NEXTHOP): Add\n\t\"ignore-link-local-nexthop\" flag for ignore link-local nexthop for\n\tIPv6.\n\n2001-08-07  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* bgpd.c (address_family_ipv4_multicast): \"address-family ipv4\n\tmulticast\" is added.\n\t(address_family_ipv6_unicast): \"address-family ipv6 unicast\" is\n\tadded.\n\t\n2001-08-07  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_route.c (bgp_process): Use flag instead of as_selected\n\tmemeber in struct bgp_info.\n\n\t* bgp_route.h (struct bgp_info): Remove as_selected memeber from\n\tstruct bgp_info.\n\n2001-07-31  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* bgp_route.c (bgp_announce_check): Enclose sending time AS loop\n\tcheck code with #ifdef BGP_SEND_ASPATH_CHECK.\n\n2001-07-29  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* bgp_packet.c (bgp_withdraw_send): Simplify address family check.\n\n\t* bgpd.h (BGP_INFO_HOLDDOWN): Introduce new macro to check BGP\n\tinformation is alive or not.\n\n\t* bgp_community.c: Use community_val_get() on all OS.\n\n2001-07-24  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* bgp_route.c (bgp_announce_check): Simplify set next-hop self\n\tcheck.\n\n2001-07-24  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_route.c (bgp_announce_check): To route server clients, we\n\tannounce AS path, MED and nexthop transparently.\n\n2001-06-21  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_routemap.c (route_set_atomic_aggregate_free): Do not call\n\tXFREE.  No memory is allocated in\n\troute_set_atomic_aggregate_compile().\n\n2001-06-21  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_routemap.c (bgp_route_map_init): `match nlri` and `set nlri`\n\tare replaced by `address-family ipv4` and `address-family vpnvr'.\n\n2001-06-19  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_withdraw): Add check for BGP_PEER_CONFED.\n\tReported by Rick Payne <rickp@rossfell.co.uk>.\n\n2001-06-17  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_zebra.c (bgp_zebra_announce): When global IPv6 nexthop is\n\tempty, use socket's remote address for the nexthop.\n\n2001-06-04  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* bgpd.c (peer_delete): Fix memory leak.  Reported by Yosi Yarchi\n\t<Yosi_Yarchi@KereniX.com>\n\n2001-06-01  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* bgpd.c (bgp_delete): Fix memory leak.  Reported by Yosi Yarchi\n\t<Yosi_Yarchi@KereniX.com>\n\n2001-05-27  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* bgp_route.c (bgp_route_clear_with_afi_vpnv4): Use next instead\n\tof ri->next.\n\n\t* bgp_packet.c (bgp_withdraw_send): MPLS/VPN withdraw takes effect\n\twhen HAVE_IPV6 is not defined.\n\n2001-03-07  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* bgpd.c (peer_timers_set): Adjust keepalive timer to fit less\n\tthan holdtime / 3.\n\t(bgp_confederation_peers_unset): Only set peer->local_as when\n\tconfederation is enabled.\n\t(bgp_timers): Add \"timers bgp <0-65535> <0-65535>\" command.\n\n\t* bgp_route.c (bgp_announce_check): Set med of redistributed route\n\twhen it is announced to EBGP peer.\n\n2001-03-06  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* bgp_nexthop.c (bgp_scan_ipv4): bgp_scan() call bgp_process() for\n\tall prefixes.\n\n2001-03-06  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_attr.c (bgp_attr_origin): When bgpd send NOTIFICATION with\n\terroneous attribute (type, length and value), it does include\n\tattribute flags field.\n\n2001-02-21  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* bgp_route.c (bgp_announce_check): The route reflector is not\n\tallowed to modify the attributes of the reflected IBGP routes.\n\n2001-02-20  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* bgp_route.c (bgp_info_cmp): During path seleciton, BGP\n\tconfederation peer is treated as same as IBGP peer.\n\n2001-02-19  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_redistribute_add): Initialize attr_new with\n\tattr.  Call aspath_unintern when return from this function.\n\n2001-02-19  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* bgpd.c (bgp_router_id_set): Reset BGP peer when router-id is\n\tchanged.\n\n2001-02-18  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* bgp_packet.c (bgp_open_receive): When user configure holdtimer,\n\tdo not refrect the value to current session.\n\n2001-02-16  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_aggregate_delete): Set BGP_INFO_ATTR_CHANGE to\n\tsuppress route withdraw.\n\n\t* bgp_damp.c (bgp_damp_init): Fix bug of flap dampening.\n\n2001-02-16  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* bgp_aspath.c (aspath_make_str_count): Use ',' for separator for\n\tAS_SET and AS_CONFED_SET.\n\n2001-02-15  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_process): Do not consider suppress route.\n\n\t* bgp_aspath.c (aspath_aggregate_as_set_add): Reset asset when\n\taspath->data is realloced.\n\n2001-02-15  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* bgp_attr.c (bgp_attr_aggregate_intern): Do not set atomic\n\taggregate when using as-set.\n\n2001-02-14  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* bgpd.c (bgp_confederation_peers_unset): Set peer's local-as\n\tcorrectly.\n\n\t* bgp_route.c (bgp_update): Just ignore AS path loop for\n\tconfederation peer.\n\n2001-02-10  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_aggregate_set): Add as_set argument.\n\t(bgp_aggregate_unset): Remove summary_only argument.\n\t(aggregate_address_as_set): New commands.\n\t\"aggregate-address A.B.C.D/M as-set\"\n\t\"no aggregate-address A.B.C.D/M as-set\"\n\n2001-02-08  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* bgp_route.c (bgp_announce_check): Do not modify nexthop when the\n\troute is passed by route reflector.\n\n2001-02-08  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c: \"no bgp dampening\" with argument.\n\t(bgp_announce_check): Do not modify nexthop when the route is\n\tpassed by route reflector.\n\n2001-02-07  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* bgpd.c (neighbor_passive): Change \"neighbor NEIGHBOR remote-as\n\tASN passive\" to \"neighbor NEIGHBOR passive\".\n\t(bgp_announce_check): Check well-known community attribute even\n\twhen \"no neighbor send-community\" is set.\n\n2001-02-03  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_fsm.c (bgp_establish): Do not send keepalive at established\n\ttime when keepalive timer is configured as zero.\n\n2001-02-01  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_attr.c (bgp_attr_check): When peer is IBGP peer, local\n\tpreference is well-known attribute.\n\n2001-01-30  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* zebra-0.91 is released.\n\n\t* bgp_attr.h (struct attr): Comment out DPA value.\n\t(struct attr): Change refcnt type from int to unsinged long.\n\n\t* bgp_attr.c (attrhash_key_make): Likewise.\n\t(attrhash_cmp): Likewise.\n\t(bgp_attr_dpa): Likewise.\n\n2001-01-30  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* bgp_route.c (bgp_info_cmp): Make route selection completely same\n\tas Cisco's.\n\n2001-01-30  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_attr.h (BGP_ATTR_FLAG_OPTIONAL): Rename old ATTR_FLAG_* to\n\tBGP_ATTR_FLAG_* to clarify meenings.\n\n2001-01-30  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* bgp_route.c (route_vty_out): Display argument to suppress same\n\tprefix information display.\n\t(route_vty_out_route): Don't display mask information for\n\tclassfull network.\n\n2001-01-30  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_attr.h (SET_BITMAP): Simple bitmapping macros.\n\n\t* bgp_attr.c (bgp_attr_parse): Use bitmap for attribute type\n\tcheck.\n\n2001-01-29  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_attr.c (bgp_mp_reach_parse): Enclose loggin with BGP_DEBUG.\n\t(bgp_attr_parse): Comment out well-known attribute check.\n\n2001-01-28  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_static_unset): Link-local IPv6 address can't be\n\tused for network advertisement.\n\t(nlri_parse): When link-local IPv6 address NLRI comes from\n\tremote-peer, log the information then simply ignore it.\n\n\t* bgp_zebra.c (zebra_read_ipv6): Link-local IPv6 address is not\n\tredistributed.\n\n\t* bgp_route.c (bgp_update): Check IPv6 global nexthop\n\treachability.\n\n2001-01-26  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_update): Check nexthop points local address or\n\tnot.\n\t(bgp_static_update_vpnv4): Set valid flag.\n\n\t* bgp_attr.c (bgp_attr_parse): Duplicate attribute check.\n\t(bgp_attr_parse): Well-known attribute check.\n\n\t* bgp_open.c (bgp_auth_parse): Authentication is not yet supported.\n\n\t* bgp_packet.c (bgp_valid_marker): Check marker is synchronized.\n\n\t* bgpd.c (clear_bgp): Send NOTIFICATION Cease when SEND_CEASE is\n\tdefined.\n\n\t* bgp_snmp.c (bgp4PathAttrTable): Fix compile error.\n\n2001-01-24  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c (bgp_network_import_check): New command for IGP network\n\tcheck.\n\n2001-01-23  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_nexthop.c (bgp_scan): Run bgp_process when IGP metric is\n\tchanged.  Call bgp_process once for each node.\n\n2001-01-23  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* bgp_route.c (bgp_info_cmp): Add IGP metric comparison.\n\n2001-01-23  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_info_cmp): Add IGP metric comparison.\n\n\t* bgp_nexthop.c (bgp_nexthop_lookup): Set IGP metric for valid\n\tIBGP route.\n\n2001-01-23  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* bgp_route.c (show_ip_bgp_prefix_longer): Add new commands.\n\t\"show ip bgp A.B.C.D/M longer-prefixes\"\n\t\"show ip bgp ipv4 (unicast|multicast) A.B.C.D/M longer-prefixes\"\n\t\"show ipv6 bgp X:X::X:X/M longer-prefixes\"\n\t\"show ipv6 mbgp X:X::X:X/M longer-prefixes\"\n\t\n2001-01-20  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* bgp_route.c (show_ip_bgp_cidr_only): Add new commands.\n\t\"show ip bgp cidr-only\"\n\t\"show ip bgp ipv4 (unicast|multicast) cidr-only\"\n\t\n2001-01-18  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* bgp_route.c (bgp_update): AS path lookup check is done in\n\tbgp_update() not in attr_parse().\n\n2001-01-18  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_update): Call bgp_aggregate_decrement() just\n\tbefore bgp_attr_unintern().\n\n2001-01-17  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_update): Now intern is performed very last part\n\tof the BGP packet update procedure.\n\n2001-01-17  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* bgp_route.c (bgp_update): When implicit withdraw occur, reuse\n\texisting bgp_info structure.\n\n2001-01-17  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_aggregate_decrement): Fix bug of aggregate\n\taddress matching method.\n\t(bgp_update): \n\n\t* bgp_nexthop.c (bgp_nexthop_onlink): Separate EBGP nexthop onlink\n\tcheck and IBGP nexthop route check.\n\n2001-01-16  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* bgp_route.h (BGP_INFO_ATRR_CHANGED): Added for track attribute\n\tchange.\n\n2001-01-16  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.h (struct bgp_info): Remove selected flag.  Use\n\tBGP_INFO_SELECTED for flags instead.\n\t(struct bgp_info): Remove valid flag.  Use BGP_INFO_VALID for\n\tflags instead.\n\t(struct bgp_info): Add igpmetric for IBGP route nexthop IGP\n\tmetric.\n\t(struct bgp_info_tab): Struct bgp_info_tag is integrated into\n\tstruct bgp_info.\n\t(BGP_INFO_ATRR_CHANGED): Added for track attribute change.\n\n\t* bgp_community.c (community_val_get): gcc-2.95 on\n\tsparc-sun-solaris cause crush.  This function is for avoid the\n\tcrush.\n\n2001-01-15  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_packet.c (bgp_open_receive): Translated peer's packet_size\n\tclear bug is fixed.\n\n2001-01-14  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* bgp_packet.c (bgp_open_receive): Return notification with\n\tsupported version number.\n\n2001-01-13  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c (bgp_show_summary): Display AS path and community\n\tentries.  Suggested by: \"Matt Ranney\" <mjr@ranney.com>.\n\n\t* bgp_packet.c (bgp_read_packet): Fix bug of unblocking BGP socket\n\tread.  When BGP packet read is partial, we must get size and type\n\tfrom packet again.\n\n2001-01-12  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* bgp_route.c (bgp_update): Do not unset BGP_INFO_HISTORY flag.\n\t(bgp_update): When there is a history entry increment route count.\n\t(bgp_damp_set): Check BGP_CONFIG_DAMPENING flag.\n\n\t* bgp_damp.c (bgp_damp_withdraw): Set status to\n\tBGP_DAMP_DISCONTINUE.\n\n2001-01-11  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_attr.c (bgp_mp_reach_parse): Fix warning code when second\n\tIPv6 nexthop is not link-local addresss.\n\n2001-01-11  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* bgp_damp.c (bgp_config_write_damp): Smart flap dampening\n\tconfiguration display.\n\t(bgp_damp_info_print): Display elapsed time from flap started.\n\n\t* bgp_damp.h (struct bgp_damp_info): Add flap start time.\n\n\t* bgpd.c (peer_create): Set last read time.\n\t(bgp_show_peer): Display last read time.\n\t(bgp_show_summary): Use BGP_CONFIG_DAMPENING flag to check\n\tconfiguration.\n\t\n\t* bgpd.h (BGP_CONFIG_DAMPENING): Add new configuration option.\n\t(struct peer): Add last read time member.\n\t(BGP_VERSION_MP_4): Remove obsolete definition.\n\n2001-01-10  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_nexthop.c: Remove OLD_RIB codes.\n\n\t* bgp_route.c (bgp_process): Likewise.\n\n\t* zebra-0.90 is released.\n\n\t* bgp_route.h (BGP_INFO_HISTORY): Remove damped member from struct\n\tbgp_info.  Instead of that use BGP_INFO_DAMPED flag.\n\t(struct bgp_info): Remove invalid member from struct bgp_info.\n\tInstead of that use BGP_INFO_HISTORY flag.\n\n2001-01-10  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* bgp_damp.c (bgp_damp_info_print): New function to display\n\tdampening status.\n\t(DEFAULT_HARF_LIFE): Define default value.\n\t(DEFAULT_REUSE): Likewise.\n\t(DEFAULT_SUPPRESS): Likewise.\n\t(bgp_config_write_damp): When config value is same as default\n\tvalue, simply display \"bgp dampening\" to configuration.\n\n\t* bgp_damp.h (struct bgp_damp_info): Add flap member.\n\n\t* bgp_route.h (struct bgp_info): Added for BGP flap dampening\n\thistory status.\n\n2001-01-10  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_nexthop.c (bgp_connected_add): Point-to-point connected\n\taddress is properly handled.\n\t(bgp_connected_delete): Likewise.\n\n\t* bgp_route.c (bgp_route_init): Turn off BGP Flap dampening code\n\tuntil it works fine.\n\n2001-01-09  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c (bgp_show_summary): Add BGP_VERSION_MP_4 case.\n\n\t* bgp_route.c (bgp_update): When this is not damped route, clear\n\tri pointer.\n\n2001-01-09  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_main.c: Add \"-n\" no_kernel option to not install route to\n\tkernel.  Suggested by: \"Matt Ranney\" <mjr@ranney.com>\n\n2001-01-09  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_nexthop.c (bgp_connected_add): Revert point-to-point\n\tconnected route patch.  Reported by ruud@ruud.org (Ruud de Rooij)\n\n\t* bgp_damp.c (bgp_config_write_damp): Add configuration display\n\tfunction.\n\n\t* bgp_route.c (bgp_info_free): Set NULL to BGP dampening\n\tinformation when BGP info structure is freed.\n\t(bgp_info_cmp): Check damped flag.\n\t(bgp_announce_check): Damped route is not announced.\n\n2001-01-09  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* bgpd.c (neighbor_capability_route_refresh): Change \"neighbor\n\troute-refresh\" command to \"neighbor capability route-refresh\".\n\t(clear_bgp_soft_in): Change soft-reconfig method.\n\n\tclear ip bgp <neighbor> soft in\n        --------------------------------------\n        Try stored cache first then route-refresh\n\n        clear ip bgp <neighbor> in\n        ---------------------------------\n        Try route-refresh first then try to use stored cache\n\n2001-01-09  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_nexthop.c (bgp_connected_add): Check point-to-point\n\tconnected route.  Reported by ruud@ruud.org (Ruud de Rooij)\n\n2001-01-08  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_nexthop.c (bgp_nexthop_lookup): When IBGP nexthop is\n\tchanged, refresh it.\n\n2001-01-04  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.h (struct bgp_info_tag): Add as_selected to\n\tbgp_info_tag.\n\n2001-01-03  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.h (struct bgp_info_tag): Add damped and bgp_damp_info\n\tmember for BGP flap dampening.\n\n\t* bgp_damp.c: New file is added.\n\n\t* bgp_damp.h: Likewise.\n\n2001-01-01  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.h (BGP_VTYSH_PATH): Change \"/tmp/bgpd\" to \"/tmp/.bgpd\".\n\n2000-12-29  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_nexthop.c (zlookup_connect): Change to use UNIX domain\n\tsocket for zebra communication.\n\n2000-12-29  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_route.c (bgp_process): Fix \"bgp deterministic-med\" process.\n\n2000-12-27  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_route.c (bgp_process): Add \"bgp deterministic-med\" process.\n\n2000-12-25  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_route.c (bgp_info_cmp): Use ntohl comparing router ID.\n\n2000-12-18  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_route.c (bgp_info_cmp): When over three same prefix exit,\n\twithdrawing best prefix perform router ID comparison.\n\n2000-12-15  Akihiro Mizutani  <mizutani@dml.com>\n\n\t* bgp_route.c (bgp_info_cmp): Do not compare router ID when the\n\troutes comes from EBGP peer.  When originator ID is same, take\n\tshorter cluster-list route.  If cluster-list is same take smaller\n\tIP address neighbor's route.\n\n\t* bgpd.c (bgp_bestpath_aspath_ignore): Add \"bgp bestpath as-path\n\tignore\" command.  When this option is set, do not concider AS path\n\tlength when route selection.\n\t(bgp_bestpath_compare_router_id): Add \"bgp bestpath\n\tcompare-routerid\".  When this option is set, compare router ID\n\twhen the routes comes from EBGP peer.\n\t\n2000-12-15  Akihiro Mizutani  <mizutani@dml.com>\n\n\t* bgp_route.c (bgp_info_cmp): Compare originator ID when it is\n\tavailable.\n\n2000-12-14  Akihiro Mizutani  <mizutani@dml.com>\n\n\t* bgp_packet.c (bgp_notify_receive): Disply received Notify data\n\tinformation.\n\n2000-12-14  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_filter.c (as_filter_free): Use MTYPE_AS_FILTER_STR to make\n\tit sure the memory is freed.\n\n\t* bgp_route.c (route_vty_out_detail): Do not use AF_INET6 outside\n\tHAVE_IPV6.\n\n2000-12-08  Akihiro Mizutani  <mizutani@dml.com>\n\n\t* bgp_packet.c (bgp_notify_send_with_data): Store BGP notification\n\tdata part.\n\n\t* bgp_network.c (bgp_accept): When BGP connection comes from\n\tunconfigured IP address, close socket immediately.\n\n\t* bgpd.c: Fix some display format.\n\n2000-11-29  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_packet.c (bgp_keepalive_send): Delete duplicate\n\tbgp_packet_set_size () call.\n\n2000-11-28  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_packet.c (bgp_read_packet): Remove debug codes.\n\n2000-11-27  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_snmp.c (write_bgpPeerTable): Add SNMP set method routine.\n\n\t* bgp_fsm.c (bgp_stop): Use fsm_change_status to change peer's\n\tstatus.\n\t(bgp_establish): Likewise.\n\n2000-11-26  Akihiro Mizutani  <mizutani@dml.com>\n\n\t* bgp_open.c: Fix error messages.\n\n2000-11-25  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_fsm.c (bgp_establish): Call BGP trap when the peer is\n\testablished.\n\t(bgp_stop): Call BGP trap when the peer is dropped.\n\n2000-11-24  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_snmp.c (bgp4PathAttrTable): Return BGP path attribute table.\n\n\t* bgpd.h (struct peer): Add update_time for track last update\n\treceived time.\n\n\t* bgp_packet.c (bgp_notify_receive): Preserv notify code and sub\n\tcode in any case.\n\n\t* bgp_snmp.c (bgpPeerTable): Return remote router ID instead of\n\tpeering IP address.\n\t(bgpPeerTable): Return actual BGP version number.\n\n2000-11-22  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_debug.c (bgp_notify_print): Notify data length display bug\n\tis fixed.\n\n2000-11-16  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_nexthop.c (zlookup_connect): When UNIX domain connection to\n\tzebra is enabled, use the method.\n\n2000-11-16  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgpd.c: Revise debug message output.\n\n2000-11-15  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_clist.c (ip_community_list): Fix bug of string comparison.\n\n2000-11-14  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_community.c (community_match): Fix bug of memcmp return\n\tvalue check.\n\n2000-11-07  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_clist.c (community_list_match_exact): Add check for\n\tentry->style is COMMUNITY_LIST.\n\t(community_match_regexp): Apply new com_nthval macro.\n\n2000-11-07  Rick Payne <rickp@rossfell.co.uk>\n\n\t* bgp_routemap.c (route_set_community_delete): \"set\n\tcommunity-delete COMMUNITY-LIST\" is added.\n\n\t* bgp_community.c (community_del_val): Delete one community.\n\t(community_delete): Delete all community included in list.\n\t(community_match): Fix bug of matching community value.\n\n\t* bgp_clist.c (community_entry_free): Free community regular\n\texpression.\n\t(community_entry_make): Default style is COMMUNITY_LIST.\n\t(community_entry_lookup): Make it sure style is COMMUNITY_LIST.\n\t(community_entry_regexp_lookup): New function for community\n\tregular expression lookup.\n\t(community_match_regexp): New function.\n\t(community_delete_regexp): New function.\n\t(community_list_delete_entries): New function.\n\t(community_list_match): Add COMMUNITY_REGEXP treatment.\n\t(community_list_match_exact): Likewise.\n\t(config_write_community): Write community list according to\n\tentry->style.\n\n2000-11-07  Rick Payne <rickp@rossfell.co.uk>\n\n\t* bgp_attr.c (bgp_attr_aspath): AS path first AS check.\n\n\t* bgp_clist.c (struct community_entry): Add style, regexp, reg to\n\tcommunity_entry.\n\n2000-11-06  Rick Payne <rickp@rossfell.co.uk>\n\n\t* bgp_aspath.c (aspath_firstas_check): AS path first AS check.\n\n\t* bgpd.c (bgp_enforce_first_as): New command \"bgp\n\tenforce-first-as\".\n\n\t* bgpd.h (BGP_CONFIG_ENFORCE_FIRST_AS): Add new flag.\n\n2000-11-06  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_community.c (community_compare): Copy byte stream data to\n\tactual value instead of using type casting hack.\n\t(community_add_val): Likewise.\n\t(community_uniq_sort): Likewise.\n\t(community_print): Likewise.\n\t(community_print_vty): Likewise.\n\t(community_include): Use memcmp to compare community value.\n\n\t* bgp_community.h (com_lastval): com_lastval and com_nthval macro\n\treturn pointer.\n\n2000-11-06  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgpd.h (struct peer): Add established and dropped member for\n\tcount peering up/down statistics.\n\n\t* bgpd.c (bgp_show_peer): Display peering up/down statistics.\n\n\t* bgp_fsm.c (bgp_establish): Increment established count.\n\t(bgp_stop): Increment dropped count.\n\n\t* bgp_packet.c (bgp_notify_receive): Increament notify count.\n\n2000-11-1  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_fsm.c: Fix bug of holdtimer is not reset when bgp cleared. \n\n2000-10-31  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.h: Static bit flag is set by (1 << DIGIT).\n\n2000-10-24  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_ecommunity.c (ecommunity_dup): Extended community display\n\tformat fix.\n\n2000-10-24  Arkadiusz Miskiewicz <misiek@pld.org.pl>\n\n\t* bgp_network.c (bgp_serv_sock_addrinfo): Use gai_strerror.\n\t(bgp_serv_sock_addrinfo): Check address family.\n\n2000-10-23  Jochen Friedrich <jochen@scram.de>\n\n\t* bgp_snmp.c: bgp_oid and bgpd_oid are used in smux_open after it\n\tis registered.  So those variables must be static.\n\n2000-10-23  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_routemap.c (route_match_ip_next_hop): Change \"match ip\n\tnext-hop\" argument from IP address to access-list name.\n\tRemove zebra-0.88 compatibility commands.\n        \"match ip prefix-list WORD\"\n        \"match ipv6 prefix-list WORD\"\n\t\n2000-10-23  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_routemap.c (route_match_ipv6_next_hop_compile): Fix bug of\n\tpassing the pointer to the pointer of struct in6_addr instead of\n\tthe pointer of struct in6_addr in \"match ipv6 next-hop\" command.\n\n\t* bgp_route.c (bgp_announce_check): Enclose IPv6 part with\n\tHAVE_IPV6.\n\n2000-10-20  Jasper Wallace <jasper@ivision.co.uk>\n\n\t* bgp_snmp.c (bgpPeerTable): ntohs missing bug is fixed.  Change\n\tto use linklist.c.  Define COUNTER32 as ASN_COUNTER.\n\n2000-10-18  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_announce_check): attr->nexthop empty check\n\tshould be done by attr->nexthop.s_addr instead of strcmp.\n\n2000-10-18  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_zebra.c (zebra_read_ipv4): Pass nexthop value to\n\tbgp_redistribute_add().\n\n\t* bgp_nexthop.c (bgp_multiaccess_check_v4): New function for\n\tchecking IPv4 multiaccess nexthop.\n\n\t* bgp_route.c (bgp_announce_check): In case of the nexthop is\n\treachable on multiaccess media, do not change nexthop.\n\t(bgp_redistribute_add): Set nexthop when the value is passed.\n\n2000-10-17  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_fsm.c (bgp_timer_set): If peer is passive mode, do not set\n\tconnect timer.\n\t(bgp_start): If the peer is passive mode, force to move to Active\n\tmode.\n\n2000-10-17  Horms <horms@vergenet.net>\n\n\t* bgp_debug.c (debug_bgp_fsm): Fix typo.\n\n2000-10-17  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_route.c: \"show ipv6 bgp\" route display improvement.\n\n2000-10-03  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (neighbor_routes): Allocate sockunion for callback\n\tfunction.\n\t(bgp_show_neighbor_route): Remove static declaration for union\n\tsockunion.\n\n\t* bgpd.c (peer_update_source_set): Clean previously allocated\n\tmemory before allocate new one.\n\n2000-10-03  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_route.c (neighbor_routes): Add show neighbor's routes\n\tcommand.\n\t\"show ip bgp neighbors (A.B.C.D|X:X::X:X) routes\"\n\t\"show ip bgp ipv4 (unicast|multicast) neighbors (A.B.C.D|X:X::X:X) routes\"\n\t\"show ipv6 bgp neighbors (A.B.C.D|X:X::X:X) routes\"\n\t\"show ipv6 mbgp neighbors (A.B.C.D|X:X::X:X) routes\"\n\n2000-10-02  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* zebra-0.89 is released.\n\n2000-10-02  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgpd.c: \"bgp deterministic-med\" command is added.\n\n2000-10-02  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_nexthop.c (bgp_connected_add): Apply mask for connected\n\troute addition and deletion.\n\n2000-09-29  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_aspath.c (aspath_cmp_left): Skip confederation AS segment\n\twhen comparing leftmost AS number.\n\n2000-09-29  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgpd.c (peer_route_reflector): Route reflector can be set for\n\tIBGP peer.\n\t(bgp_distribute_set): Fix bug of string check for (in|out).\n\t(bgp_show_summary): Display total neighbor count.\n\n2000-09-28  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_attr.c (bgp_packet_attribute): Only add cluster_list and\n\toriginator for clinet to client routes.\n\t(bgp_packet_attribute): Add new cluster_list to the beginning of\n\texisting cluster_list.\n\t(bgp_packet_attribute): Fix bug of originator is rewritten even\n\twhen originator is already set.\n\n2000-09-27  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c (bgp_client_to_client_reflection): Add new command.\n\t\"no bgp client-to-client reflection\"\n\t\"bgp client-to-client reflection\"\n\n\t* bgpd.h (BGP_CONFIG_NO_CLIENT_TO_CLIENT): Add new definition.\n\n2000-09-26  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_packet.c (bgp_read): Make BGP packet read to non-blocking\n\tread.\n\t(bgp_read_packet): Likewise.\n\t(bgp_read_packet): When errono is EAGAIN, try to read it again.\n\n\t* bgp_fsm.c (bgp_stop): Clear packet size and read buffer.\n\n2000-09-26  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_routemap.c: Configuration of prefix-list match is shown as\n\t\"match ip address prefix-list <WORD>\".  Old configuration \"match\n\tip prefix-list <WORD>\" is left for compatibilitty.\n\n2000-09-25  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgpd.h (BGP_CONFIG_MED_MISSING_AS_WORST): Changed from\n\tBGP_CONFIG_MISSING_AS_WORST.\n\n\t* bgpd.c (bgp_bestpath_med): Change missing-as-worst syntax.\n\tOld \"bgp bestpath missing-as-worst\"\n\tNew \"bgp bestpath med missing-as-worst\"\n\n2000-09-24  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_route.c: Compare MED properly in case of CONFED-IBGP.\n\n2000-09-21  steve@Watt.COM (Steve Watt)\n\n\t* bgp_debug.h: Do not declare debug variables conf_bgp_debug_* and\n\tterm_bgp_debug_*.\n\n\t* bgp_debug.c: Declare variables here.\n\n2000-09-21  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgpd.c: MBGP soft-reconfiguration command is added.\n\tclear ip bgp x.x.x.x ipv4 (unicast|multicast) in\n\tclear ip bgp x.x.x.x ipv4 (unicast|multicast) out\n\tclear ip bgp x.x.x.x ipv4 (unicast|multicast) soft\n\tclear ip bgp <1-65535> ipv4 (unicast|multicast) in\n\tclear ip bgp <1-65535> ipv4 (unicast|multicast) out\n\tclear ip bgp <1-65535> ipv4 (unicast|multicast) soft\n\tclear ip bgp * ipv4 (unicast|multicast) in\n\tclear ip bgp * ipv4 (unicast|multicast) out\n\tclear ip bgp * ipv4 (unicast|multicast) soft\n\n\tChange \"clear ip bgp vpnv4 x.x.x.x soft\" command to\n\t\"clear ip bgp x.x.x.x vpnv4 unicast soft\".\n\n\t\"bgp bestpath med confed\" command is added.\n\t\n\t* bgpd.h (BGP_CONFIG_MED_CONFED): Add New definition.\n\n2000-09-18  Rick Payne <rickp@rossfell.co.uk>\n\n\t* bgpd.c (bgp_show_peer): Fix misplaced #endif.\n\n2000-09-12  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgpd.c (bgp_default_local_preference): Add \"bgp default\n\tlocal-preference\" command.\n\n\t* bgp_nexthop.c (no_bgp_scan_time): Add \"no bgp scan-time\"\n\tcommand.\n\n2000-09-10  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_zebra.c (bgp_zebra_announce): BGP confederation peer's routes\n\tare passed to zebra like IBGP route.\n\n2000-09-10  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgpd.c (bgp_config_write_peer): Make it consistent passive\n\tconfiguration.\n\n\t* bgp_route.c: Community match command is added.\n\t\"show ip bgp community <val>\"\n\t\"show ip bgp community <val> exact-match\"\n\n2000-09-08  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_nexthop.c (bgp_nexthop_lookup): ebgp-multihop routes are\n\ttreated as IBGP routes.\n\n2000-09-08  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_route.c (bgp_show_route): When local-AS community route is\n\tselected, display \"not advertised outside local AS\" to \"show ip\n\troute A.B.C.D\" output.\n\t(show_ip_bgp_ipv4_filter_list): Add below four commands.\n\t\"show ip bgp ipv4 (unicast|multicast) filter-list WORD\"\n\t\"show ip bgp ipv4 (unicast|multicast) community\"\n\t\"show ip bgp ipv4 (unicast|multicast) community-list WORD\"\n\t\"show ip bgp ipv4 (unicast|multicast) community-list WORD exact-match\"\n\t\n\t* bgp_clist.c (community_list_match_exact): Community exact match\n\tfunction.\n\n2000-09-07  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_update): Add peer's ttl check.\n\n\t* bgpd.h (struct peer): Structure member refresh is renamed to\n\trefresh_adv.\n\n\t* bgpd.c (clear_bgp_soft_in): Check PEER_FLAG_ROUTE_REFRESH flag\n\twhen soft reconfiguration is performed.\n\n\t* bgp_zebra.c (bgp_zebra_announce): When the peer is EBGP and\n\tebgp-multiphop is set, set ZEBRA_FLAG_INTERNAL for nexthop lookup.\n\n\t* bgp_route.h (struct bgp_info_tag): Add valid flag.\n\n2000-08-25  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgpd.c: Add AS base BGP soft reconfiguration.\n\n\t* bgp_route.c: When no-advertise or no-export route is selected,\n\t\"show ip bgp\" display \"not advertised to EBGP peer\" or \"not\n\tadvertised to any peer\" message.\n\t\n2000-08-17  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* zebra-0.88 is released.\n\n\t* bgp_dump.c (dump_bgp_routes): Change \"dump bgp routes\" to \"dump\n\tbgp route-mrt\" to support MRT specific dump format.\n\n\t* bgpd.c (bgp_init): \"clear ip bgp vpnv4 soft {in,out}\" command is\n\tadded.\n\n\t* bgp_route.c (bgp_update): Currently nexthop check is only works\n\tfor IPv4.\n\n2000-08-17  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgpd. (clear_ip_bgp_all_soft): Add \"clear ip bgp * soft\" for\n\tboth inbound and outbound soft reconfiguration.\n\n2000-08-17  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c (clear_ip_bgp_peer_soft_out): Add soft-reconfiguration\n\toutbound.\n\t(peer_new): Set route-refresh flag.\n\n2000-08-16  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgpd.c: \"no bgp router-id A.B.C.D\" alias is added.  \"no bgp\n\tcluster-id A.B.C.D\" alias is added.  \" bgp cluster-id\n\t<1-4294967295>\" alias is added.  \"clear ip bgp * soft in\" command\n\tis added.  \"clear ip bgp A.B.C.D in\" alias is added.  \"clear ip\n\tbgp * in\" alias is added.\n\n2000-08-16  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_update): Add soft_reconfig flag.  When the flag\n\tis set do not install the route into Adj-RIBs-In.\n\t(bgp_update): Perform implicit withdraw before filtering of the\n\troute.\n\n\t* bgp_packet.c (bgp_read): draft-ietf-idr-bgp-route-refresh-01.txt\n\tcapability code and BGP message can be accepted.\n\n\t* bgp_open.c (bgp_capability_parse): Likewise.\n\n\t* bgp_route.c (bgp_refresh_table): New function for route refresh.\n\t(bgp_refresh_rib): Likewise.\n\n\t* bgpd.c (bgp_show_peer): Display route refresh status.\n\n\t* bgp_route.c (bgp_aggregate_add): Add check for the route\n\tvalidness.\n\t(bgp_aggregate_delete): Likewise.\n\n2000-08-15  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_nexthop.c (bgp_scan): Care for aggregate route when the\n\troute become inaccessible.\n\n2000-08-15  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_route.c (show_ip_bgp_prefix): \"show ip bgp A.B.C.D/M\"\n\tcommand is added.\n\n2000-08-15  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_zebra.c (bgp_interface_up): Register connected route.\n\t(bgp_interface_down): Unregister connected route.\n\n2000-08-14  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.h (struct bgp_info): Add distance to the structure.\n\n\t* bgp_route.c (bgp_aggregate_increment): Aggregate route only\n\tmatch to smaller prefixlen route not match same prefixlen route.\n\t(bgp_aggregate_decrement): Likewise.\n\t(bgp_aggregate_add): Likewise.\n\t(bgp_aggregate_delete): Likewise.\n\t(bgp_network_backdoor): Add backdoor network configuration.\n\n\t* bgpd.h (struct bgp ): Add distance_{ebgp,ibgp,local} for store\n\tconfiguration distance value.\n\n\t* bgp_route.c (bgp_update): Filter EBGP route which has non\n\tconnected nexthop.\n\n\t* bgp_attr.c (bgp_attr_aggregate_intern): New function for\n\taggregate route.  Set origin to IGP.  Set atomic aggregate flag.\n\tSet aggregator AS and address.\n\t(bgp_attr_aggregate_intern): Check BGP_CONFIG_CONFEDERATION when\n\tfilling aggregator_as.\n\n\t* bgp_route.c (bgp_process): Delete suppress check for install\n\tsuppressed route into local routing table.\n\t(bgp_aggregate_increment): Use bgp_attr_aggregate_intern() instead\n\tof bgp_attr_default_intern ().\n\t(bgp_aggregate_add): Likewise.\n\n\t* bgpd.c (bgp_get): Call bgp_if_update_all() after BGP instance is\n\tcreated.  This is for avoid 0.0.0.0 router-id.\n\n2000-08-13  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_route.c (route_vty_out_detail): Display \"valid\" when the\n\troute is valied.  Display \"aggregated\" when the route is\n\taggregated.  \"Advertisements suppressed by an aggregate\" is\n\tdisplayed when the route is suppressed.\n\t(bgp_info_cmp): Prefer EBGP than Confed-EBGP.\n\n2000-08-10  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_route.c (route_vty_out_detail): Display format change.\n\n2000-08-06  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_update): Only AFI_IP nexthop check is enabled.\n\n\t* bgpd.c (bgp_delete): Delete static route before delete peer\n\tconfiguration.\n\n2000-08-02  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c: Include bgpd/bgp_nexthop.h.\n\n2000-07-31  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgpd.c (bgp_show_summary): \"show ip bgp summary\" shows own BGP\n\tidentifier.  And status is changed like below.\n\n\tState/Pref   -> State/PfxRcd\n\tShutdown     -> Idle (Admin)\n\tPrefixOvflw  -> Idle (PfxCt)\n\n\t* bgp_route.c (route_vty_out): Show internal route as \"i\".\n\n2000-07-13  Jim Bowen <jimb@zereau.net>\n\n\t* bgp_snmp.c: Add BGP peer MIB implementation.\n\n2000-07-12  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgpd.c (bgp_show_peer): Fix typo.\n\n2000-07-11  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_routemap.c: Add commands for deleting set without argument.\n\n2000-07-03  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_zebra.c: Fix redistribute help strings.\n\n2000-07-01  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_show): When bgpd works as vtysh server send all\n\toutput to vty at once.\n\n2000-06-13  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_mplsvpn.c (no_vpnv4_network): \"no network A.B.C.D/M rd WORD\n\ttag WORD\" command is added.\n\n\t* bgp_ecommunity.c (ecommunity_vty_out): New function added.\n\n2000-06-12  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_show): Fix total number of prefix count bug.\n\n\t* bgpd.c (bgp_show_peer): Display VPNv4 unicast configuration and\n\tnegotiation result in \"show ip bgp neighbors\".\n\n2000-06-12  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgpd.c: Fix help strings.\n\t\n\t* bgpd.h: Likewise.\n\t\n2000-06-11  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_aggregate_unset): Fix bug of checking rn->info\n\tinstead of rn.  Reported by Akihiro Mizutani <mizutani@dml.com>.\n\n\t* bgp_mplsvpn.c (vpnv4_network): For testing purpose, \"network\n\tA.B.C.D rd RD\" is added to address-family vpnv4 unicast node.\n\n\t* bgp_route.c (bgp_static_set): Set safi to p.safi.\n\n2000-06-10  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_show_prefix_list): Change to use bgp_show().\n\t(bgp_show_regexp): Change to use bgp_show().\n\t(show_adj_route): Change to display header.\n\n\t* bgpd.c (clear_bgp): Set peer->v_start to default value when peer\n\tis cleared manually.\n\n\t* bgp_route.c (bgp_show_route): New function which display\n\tspecific BGP route.  Divided from bgp_show().\n\t(bgp_static_delete): Delete all static route.\n\n2000-06-09  NOGUCHI Kay <kay@v6.access.co.jp>\n\n\t* bgp_route.c (show_ipv6_bgp): \"show ipv6 bgp\" is broken with\n\tinvalid privious fix.  Now show_ipv6_bgp and show_ipv6_bgp_route\n\ttake care of \"show ipv6 bgp [X:X::X:X]\".  Same change for \"show ip\n\tmbgp\" and \"show ipv6 mbgp\".\n\n2000-06-07  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_route.c: Fix help strings and command arguments.\n\n2000-06-06  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_ecommunity.c: Include prefix.h\n\n2000-06-05  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.h (struct bgp_info_tag): New structure to hold tag\n\tvalue.\n\n\t* bgp_route.c (bgp_adj_set): table NULL check is added.\n\t(bgp_adj_unset): Likewise.\n\t(bgp_adj_lookup): Likewise.\n\t(bgp_adj_clear): Likewise.\n\t(route_vty_out): Add SAFI check for nexthop display.\n\t(bgp_withdraw): Add SAFI check for withdraw route.\n\n\t* Remove all #ifdef MPLS_VPN then include it as default.\n\n\t* bgpd.c: Temporary disable peer-group command until the\n\timplementation is completed.\n\n\t* bgp_routemap.c (bgp_route_map_init): Install\n\troute_metric_match_cmd.\n\t(route_match_metric_compile): MED value compile using strtoul.\n\n2000-06-05  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_filter.c: Fix help strings.  Change REGEXP to LINE.  Change\n\tNAME to WORD.\n\n\t* Change command argument to more comprehensive.\n\n\tMETRIC         -> <0-4294967295>\n\tWEIGHT         -> <0-4294967295>\n\tLOCAL_PREF     -> <0-4294967295>\n\tIP_ADDR        -> A.B.C.D\n\tAS             -> <1-65535>\n\tAS-PATH-NAME   -> WORD\n\tACCESS_LIST    -> WORD\n\tPREFIX_LIST    -> WORD\n\tCOMMUNITY      -> AA:NN\n\tEXT_COMMUNITY  -> ASN:nn_or_IP-address:nn\n\tIPv6_ADDR      -> X:X::X:X\n\n\t* bgp_clist.c: Fix help strings.\n\n2000-06-03  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c (peer_active): Add new function for check the peer is\n\tactive or not.\n\t(neighbor_activate): New command \"neighbor PEER activate\" and \"no\n\tneighbor PEER activate\" are added.\n\n\t* bgp_packet.c: Include bgpd/bgp_mplsvpn.h.\n\n2000-06-02  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_clist.c: Fix commuity-list help strings.\n\n\t* bgp_routemap.c: Fix \"set community\" help strings.  Add #define\n\tSET_STR.  Use (unicast|multicast) argument for \"set nlri\" command.\n\t\n2000-06-01  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_routemap.c (route_set_community_none_cmd): \"set community\n\tnone\" command is added to route-map.\n\n2000-06-01  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_debug.c: Change \"show debug\" to \"show debugging\".  Now \"show\n\tdebugging\" is not used in VIEW_NODE.\n\n2000-05-30  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_fsm.c (bgp_timer_set): Add check for shutdown flag.  This\n\tfix unconditional BGP connection.\n\n\t* bgpd.c (peer_shutdown): Replace peer_shutdown() with\n\tpeer_change_flag_with_reset().\n\n2000-05-26  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c (no_bgp_default_ipv4_unicast): Add \"no bgp default\n\tipv4-unicast\" command.\n\n\t* bgpd.h (BGP_CONFIG_NO_DEFAULT_IPV4): Add new definition.\n\n\t* bgp_filter.c (as_list_delete): Free all AS filter.\n\n\t* bgp_clist.c (community_list_delete): Free all community entry.\n\n\t* bgp_filter.c (no_ip_as_path_all): New DEFUN for \"no ip as-path\n\taccess-list NAME\".\n\n\t* bgp_clist.c (no_ip_community_list_all): New DEFUN for \"no ip\n\tcommunity-list NAME\".\n\n2000-05-19  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (ipv6_mbgp_neighbor_routes): Change \"show ip bgp PEER\n\troutes\" to \"show ip bgp PEER received-routes\"\n\n2000-05-14  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_ecommunity.c (ecommunity_parse): New file for Extended\n\tCommunities attribute.\n\t* bgp_ecommunity.h: Likewise.\n\n2000-05-11  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_mplsvpn.h: New file for MPLS-VPN.\n\t* bgp_mplsvpn.c: Likewise.\n\n\t* bgpd.c (bgp_delete): Fix bug of \"no router bgp\" crush.\n\n2000-05-10  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c (bgp_bestpath_missing_as_worst): Add \"bgp bestpath\n\tmissing-as-worst\".\n\n2000-05-08  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_routemap.c (match_community): Clarify help of \"match\n\tcommunity\".\n\n2000-05-02  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_aspath.c (aspath_cmp_left): Remove debug code.\n\n2000-04-27  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_info_cmp): Compare MED only both routes comes\n\tfrom same neighboring AS.\n\n\t* bgp_aspath.c (aspath_cmp_left): Compare leftmost AS value.\n\n\t* bgp_route.c (bgp_info_cmp): Fix misused htonl() to ntohl().\n\n2000-04-26  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_output_filter): When distribute-list's\n\tcorresponding access-list does not exist, filter all routes.\n\t(bgp_input_filter): Likewise.\n\n2000-04-19  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_attr.c (bgp_packet_attribute): Propagate MED to IBGP peer.\n\n\t* bgp_route.c (bgp_info_cmp): Add evaluation of local preference.\n\n2000-04-18  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c (bgp_distribute_update): Add struct access_list *\n\targument.\n\n2000-04-17  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_clist.c (community_list_dup_check): Add duplicate insertion\n\tcheck.\n\n\t* bgp_filter.c (as_list_dup_check): Add duplicate insertion check.\n\n\t* bgp_route.c (bgp_show): Fix undeclared write variable.\n\n2000-04-13  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_routemap.c: Add \"match ip address prefix-list\".\n\n2000-03-29  Rick Payne <rickp@rossfell.co.uk>\n\n\t* bgp_aspath.c (aspath_strip_confed): Fix realloc problem.\n\n2000-03-16  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_fsm.c (bgp_reconnect): Connect retry timer is expired when\n\tthe peer status is Connect.\n\n2000-03-03  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* Fix bug of rewritten originator-id.\n\n2000-01-27  Rick Payne <rickp@rossfell.co.uk>\n\n\t* bgp_aspath.c (aspath_delimiter_char): New function.  Instead of\n\tdirectly referencing array, search proper AS path delimiter.\n\t(aspath_strip_confed): Strip the confederation stuff from the\n\tfront of an AS path.\n\t(aspath_add_left_confed): New function for adding specified AS to\n\tthe leftmost AS_CONFED_SEQUENCE.\n\n\t* bgp_aspath.h: Change AS_CONFED_SEQUENCE and AS_CONFED_SET value\n\tto Cisco compatible.\n\n\t* bgpd.c (bgp_confederation_id_set): Confederation configuration.\n\t(bgp_confederation_id_unset): Likewise.\n\t(bgp_confederation_peers_check): Likewise.\n\t(bgp_confederation_peers_add): Likewise.\n\t(bgp_confederation_peers_remove): Likewise.\n\t(bgp_confederation_peers_set): Likewise.\n\t(bgp_confederation_peers_unset): Likewise.\n\t(bgp_confederation_peers_print): Likewise.\n\t\n2000-01-16  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c: Introduce peer_change_flag_with_reset() fucntion.\n\n2000-01-17  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_open.c (bgp_open_option_parse): When there is no common\n\tcapability send Unsupported Capability error to the peer.\n\n2000-01-14  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_open.c (bgp_capability_mp): Fix bug of mis-negotiation about\n\tIPv6 unicast.\n\n\t* bgpd.c (bgp_init): Add \"soft-reconfiguration inbound\" command.\n\t\n2000-01-12  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c (neighbor_strict_capability): Add\n\t\"strict-capability-match\" command.\n\n\t* bgp_zebra.c (bgp_if_update): Ignore NET127 determining\n\trouter-id.\n\n\t* bgpd.c (peer_override_capability): Add \"override-capability\"\n\tcommand.\n\n1999-12-16  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_packet.c (bgp_write): Change status to Idle and set timer\n\tafter write failed.\n\n1999-12-14  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_zebra.c (bgp_zebra_announce): Add info->selected check.\n\n1999-12-12  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (nlri_unfeasible): nlri_unfeasible() is merged with\n\tnlri_parse().\n\n1999-12-10  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_fsm.h (BGP_EVENT_DELETE): Macro added.\n\n\t* bgp_fsm.c (bgp_stop): Clear all event threads of the peer when\n\tthe peer is cleared.\n\n\t* bgp_zebra.c (bgp_nexthop_set): Clear interface index of\n\tlink-local address.  This is KAME specific problem.\n\n1999-12-06  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_attr.c (bgp_mp_reach_parse): Comment out previous code for a\n\twhile.  We don't completely detect the link is shared or not at\n\tthis moment.\n\n\t* bgp_packet.c (bgp_notify_send): Make shortcut call of\n\tbgp_write() and bgp_stop().\n\n\t* bgp_attr.c (bgp_mp_reach_parse): Fix serious bug when getting\n\tglobal and link-local address.\n\n1999-12-05  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c (no_neighbor_port): New command added.\n\t(peer_new): Set send_community.\n\n1999-12-04  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c (show_ip_bgp_summary): Changed to use bgp_show_summary().\n\t(show_ip_mbgp_summary): Likewise.\n\t(show_ipv6_bgp_summary): Likewise.\n\t(show_ipv6_mbgp_summary): Add new command.\n\t(peer_free): Free peer->host.\n\t(peer_lookup_by_su): Delete function.\n\t(ipv6_bgp_neighbor): Changed to use peer_remote_as().\n\t(sockunion_vty_out): Function deleted.\n\t(vty_clear_bgp): Use afi instead of family.\n\tDelete old list bgp_list.  Use struct newlist *bgplist.\n\t(peer_lookup_by_host): Function deleted.\n\n1999-12-03  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.h (struct peer_group): New structure added.\n\t(struct peer_conf): New structure added.\n\t(struct\tpeer): Change all prefix_count to unsigned long.\n\t\n\t* bgpd.c: Reconstruct all of VTY commands reflect internal\n\tstructure change.\n\tUse bgplist instead of bgp_list.\n\tUse peerlist intstead of peer_list.\n\n\t* bgp_attr.c (bgp_mp_reach_parse): If nlri_parse return -1, stop\n\tparsing then return immediately.\n\n\t* bgp_route.c (nlri_parse): When NLRI parse error occured, return\n\t-1.\n\t(nlri_process): Use pcount_v4_{unicast,multicast}.\n\t(nlri_delete): Likewise.\n\n1999-11-25  Robert Olsson <Robert.Olsson@data.slu.se>\n\n\t* bgp_routemap.c (route_match_nlri): `match nlri\n\tunicast|multicast' and `set nlri unicast|multicast' command are\n\tadded.\n\n1999-11-22  Robert Olsson <Robert.Olsson@data.slu.se>\n\n\t* bgpd.c: Add translate-update support.\n\n\t* bgpd.h (TRANSLATE_UPDATE_OFF): Add translate-update definition.\n\n1999-11-19  Robert.Olsson@data.slu.se\n\n\t* bgp_route.c (bgp_peer_delete): Add MBGP peer clear codes.\n\n1999-11-14  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_open.c (bgp_capability_mp): Temporary comment out\n\tSAFI_UNICAST_MULTICAST handling until we know the meanings.\n\n1999-11-13  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_btoa.c: New file added.\n\n1999-11-12  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.h (struct peer): Add dont_capability flag.\n\t(struct peer): Add override_capability flag.\n\n\t* bgpd.c (neighbor_dont_capability_negotiation): `neighbor PEER\n\tdont-capability-negotiation' added.\n\n1999-11-12  Bill Sommerfeld <sommerfeld@orchard.arlington.ma.us>\n\n\t* bgp_attr.c (bgp_mp_reach_parse): Ignore link-local addresses\n\tattribute from non-shared-network peers.\n\n1999-11-10  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_snmp.c: New file added.\n\n\t* BGP4-MIB.txt: Updated to the latest Internet-Draft\n\tdraft-ietf-idr-bgp4-mib-04.txt.\n\n1999-11-09  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_route_init): Add `show ipv6 bgp prefix-list'.\n\n\t* bgp_attr.c (bgp_mp_unreach_parse): Enclose safi setup with\n\t#ifdef HAVE_MBGPV4.\n\n1999-11-08  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_dump.c (no_dump_bgp_all): Add [PATH] and [INTERVAL] to no\n\tdump bgp commands.\n\t(config_write_bgp_dump): Write interval value to the\n\tconfiguration.\n\n1999-11-07  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_zebra.c: Redistribute route-map support is added.\n\n\t* bgp_zebra.h: New file added.\n\n1999-11-04  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_dump.c: BGP packet dump routine compatible with MRT.\n\t* bgp_dump.h: BGP packet dump routine compatible with MRT.\n\n\t* bgp_debug.c: Renamed from bgp_dump.c\n\t* bgp_debug.h: Renamed from bgp_dump.h\n\n1999-10-27  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* BGP4-MIB.txt: New file added.  Edited version of RFC1657.\n\n1999-10-25  Bill Sommerfeld <sommerfeld@orchard.arlington.ma.us>\n\n\t* bgp_route.c (bgp_announce): If we're not on a shared network\n\twith the peer and we don't have a link-local next hop, but the\n\tinbound next-hop has a link-local address, don't readvertise it to\n\tour peer.\n\n1999-10-25  Marc Boucher <marc@mbsi.ca>\n\n\t* bgp_zebra.c: Add redistribute kernel command.\n\n1999-10-25  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_reset): New function added.\n\n\t* bgpd.conf.sample2: Add IPv6 configuration sample.\n\n1999-10-24  Bill Sommerfeld <sommerfeld@orchard.arlington.ma.us>\n\n\t* bgp_route.c (ipv6_aggregate_address): Function added.\n\n1999-10-21  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_packet.c (bgp_update): Unintern aspath, community, cluster\n\tlist after parsing BGP update packet.\n\n\t* bgp_attr.c (bgp_attr_aspath): Intern parsed aspath.\n\t(bgp_attr_community): Intern parsed community.\n\t(bgp_attr_cluster_list): Intern parsed cluster list.\n\n\t* bgp_routemap.c: Add `set community-additive' command.\n\n1999-10-21  Alexandr D. Kanevskiy <kad@blackcatlinux.com>\n\n\t* bgp_routemap.c (route_set_local_pref): Fix bug of setting\n\tattribute flag.\n\n1999-10-21  Bill Sommerfeld <sommerfeld@orchard.arlington.ma.us>\n\n\t* bgp_route.c (bgp_announce): Add check of IPv6 default route\n\tannouncement.\n\n\t* bgp_packet.c (bgp_update_send): Add BGP announcement logging.\n\n1999-10-15  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* `show ip[v6] bgp PREFIX' show uptime of the route.\n\n1999-10-04  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c (bgp_filter_set): Delete PEER_FAMILY_{IPV4,IPV6}. instead\n\tof that use AF_INET and AF_INET6 directly.\n\t(vty_clear_bgp): Add new function to support various clear ip bgp\n\tmethod.\n\n1999-10-04  Lars Fenneberg <lf@elemental.net>\n\n\t* bgpd.c (clear_ip_bgp): Add `clear ip bgp ASN'.\n\n1999-10-03  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_routemap.c: Add `match ip prefix-list' and `match ipv6\n\tprefix-list'.\n\n1999-09-28  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c (bgp_collision_detect): Add BGP collision detection\n\tfunction.\n\n1999-09-26  Blake Meike <bmeike@adero.com>\n\n\t* bgpd.c (neighbor_port): New command `neighbor PEER port PORT' is\n\tadded.\n\n1999-08-24  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c (no_neighbor_timers_keepalive): Change MIN to min.  Add\n\tmin() macro.\n\n1999-08-19  Rick Payne <rickp@rossfell.co.uk>\n\n\t* bgp_packet.c (bgp_open): BGP holdtimer bug is fixed.  Make BGP\n\tkeepalive timer configurable.\n\n1999-08-15  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_zebra.c (bgp_redistribute_set): Fix redistribute bug.\n\n1999-08-13  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c (bgp_peer_display): show ip bgp neighbors PEER only list\n\tthe peer not all of them.\n\n1999-08-11  Rick Payne <rickp@rossfell.co.uk>\n\n\t* bgp_route.c (bgp_announce): Remove MED if its an EBGP peer -\n\twill get overwritten by route-maps.\n\n1999-08-08  Rick Payne <rickp@rossfell.co.uk>\n\n\t* bgp_routemap.c: Multi protocol route-map modification.\n\n1999-08-01  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c: Set network statement route's origin attribute as\n\tigp.\n\n\t* bgp_zebra.c: Set redistribute route's origin attribute as\n\tincomplete.\n\n\t* bgp_route.c (bgp_info_cmp): Add attribute existance check,\n\torigin attribute check, BGP peer type check.\n\n1999-07-30  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_peer_delete): Reselect of IPv6 route.\n\n1999-07-29  Rick Payne <rickp@rossfell.co.uk>\n\n\t* Changed route-maps to behave in a more cisco-like fashion\n\n1999-07-27  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_fsm.c (bgp_stop): Very serious bug of bgp_stop () is fixed.\n\tWhen multiple route to the same destination exist, bgpd try to\n\tannounce the information to stopped peer.  Then add orphan write\n\tthread is added.  This cause many strange behavior of bgpd.\n\tReported by Georg Hitsch <georg@atnet.at>.\n\n1999-07-23  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c: Change peer's A.B.C.D to PEER.\n\n1999-07-22  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_announce): Add hack for link-local nexthop.\n\n\t* bgp_zebra.c (bgp_zebra_announce): Fill in nexthop address from\n\tlocal address.\n\n1999-07-21  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_packet.c (bgp_open): Holdtime fetch bug is fixed.  Reported\n\tby Yuji SEKIYA <sekiya@sfc.wide.ad.jp>.\n\n1999-07-15  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_fsm.c (fsm_holdtime): Don't close file descriptor in\n\tfsm_holdtime ().\n\n1999-07-11  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_routemap.c: Add `set atomic-aggregate' command.\n\n1999-07-06  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_routemap.c (route_set_ip_nexthop_cmd): Change \"ip nexthop\"\n\tto \"ip next-hop\".\n\t\n1999-07-02  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (show_ipv6_bgp_regexp): `show ipv6 bgp regexp'\n\tadded.\n\n1999-07-01  Rick Payne <rickp@rossfell.co.uk>\n\n\t* bgp_zebra.c (zebra_init): Install standard commands to\n\tZEBRA_NODE.\n\n1999-06-28  Rick Payne <rickp@rossfell.co.uk>\n\n\t* bgpd.c (bgp_delete): bgp peer deletion bug is fixed.\n\n1999-06-25  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c: Add neighbor update-source command as ALIAS to\n\tneighbor_interface.\n\n1999-06-19  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_attr.c (bgp_packet_attribute): Send community attribute when\n\tsend_community flag is set.\n\n\t* bgpd.h (struct peer): Add send_community flag.\n\n1999-06-12  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c (router_bgp): router bgp's argument changed from AS_NO to\n\t<1-65535>.\n\n1999-06-08  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.h (struct bgp_info): Add subtype for BGP route type.\n\n1999-06-07  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_community.c (community_merge): Function added.\n\n1999-06-04  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_clist.c: New file.\n\t* bgp_clist.h: New file.\n\n\t* bgp_community.h (COMMUNITY_LOCAL_AS): Added for Cisco\n\tcompatibility.\n\t(COMMUNITY_NO_ADVERTISE): Fix typo.\n\n1999-05-30  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_routemap.c: Add `set weight WEIGHT' command.\n\n\t* bgpd.c: Remove all_digit_check function.  Instead of that use\n\tall_digit function in lib/prefix.c.\n\n\t* bgp_routemap.c (bgp_route_map_init): Install\n\tno_set_ipv6_nexthop_global_cmd and no_set_ipv6_nexthop_local_cmd\n\telement to the RMAP_NODE.\n\n1999-05-28  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_aspath.c (aspath_make_str): Declare aspath_delimiter_char\n\tinside aspath_make_str function.\n\t(aspath_prepend): New function is added for AS path prepend.\n\t(aspath_make_str_count): Renamed from aspath_make_str.  AS path\n\tcount is set to the structure.\n\t(aspath_merge): New function.\n\n1999-05-22  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_zebra.c (redistribute_bgp): Add new DEFUN.\n\t(no_redistribute_bgp): Likewise.\n\t(router_zebra): Semantics changed.  Now 'router zebra' is default\n\tbehavior of bgpd.\n\n1999-05-14  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_routemap.c: Add some commands to bgp route-map.\n\tmatch ip next-hop: New command.\n\tmatch metric: New command.\n\tset metric: Doc fix.\n\tset local-preference: Add DEFUN.\n\n1999-05-14  Stephen R. van den Berg <srb@cuci.nl>\n\n\t* bgp_main.c (signal_init): SIGTERM call sigint.\n\t(sigint): Loggging more better message.\n\n1999-05-12  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_attr.c (bgp_packet_attribute): AS path attribute extended\n\tlength bit check is added.\n\n1999-05-11  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_routemap.c (bgp_route_map_init): Call route_map_install_set\n\tfunction with route_set_local_pref_cmd argument.\n\t(no_match_aspath): Function added.\n\t(route_set_metric): Set attribute flag bit.\n\n\t* bgp_attr.c (bgp_packet_attribute): MULTI_EXIT_DISC is now in BGP\n\tpacket.\n\n1999-05-07  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c (no_neighbor_timers_holdtime): `no neighbor PEER timers\n\tholdtime' command is added.\n\n\t* bgpd.h (BGP_DEFAULT_HOLDTIME_BIG): Delete define.\n\n\t* bgpd.c (bgp_prefix_list_set): New function added.\n\t(bgp_prefix_list_unset): Likewise.\n\t(bgp_prefix_list_update): Likewise.\n\t(show_ip_bgp_neighbors): prefix-list information display.\n\n1999-05-06  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c (bgp_delete): Function added for `no router bgp'.\n\n1999-05-05  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_dump.c (bgp_dump_attr): Add originator_id display.\n\n\t* bgpd.c (bgp_router_id): Even when address is malformed set the\n\tvalue to configuration bug fixed.\n\t(no_bgp_router_id): New function.\n\t(no_bgp_cluster_id): New function.\n\n1999-05-04  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.h (BGP_ATTR_ORIGINATOR_ID): Changed from BGP_ATTR_ORIGINATOR.\n\n1999-05-02  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_announce): Add route reflector check.\n\n1999-05-01  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c (bgp_cluster_id): Add function for route reflector.\n\t(neighbor_route_reflector_client): Likewise.\n\t(no_neighbor_route_reflector_client): Likewise.\n\n\t* bgpd.h (struct bgp ): Add cluster for route reflector.\n\n\t* bgp_route.c (show_ip_bgp_prefix_list): New command is added.\n\n1999-04-24  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* Makefile.am (noinst_HEADERS): Add bgp_filter.h\n\n\t* bgp_aspath.c (aspath_undup): Function deleted.  aspath_free ()\n\thas same functionality.\n\n\t* bgp_filter.h: New file.\n\n\t* bgp_aspath.c (aspath_unintern): Rename aspath_free () to\n\taspath_unintern ()\n\t(aspath_free): New function.\n\n1999-04-23  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_aspath.c (aspath_aggregate): Function added.\n\n\t* bgp_aspath.h (aspath_aggregate): Prototype added.\n\n\t* bgp_aspath.c (aspath_empty_aspath): New argument\n\tgated_dont_eat_flag is added.\n\n1999-04-18  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c: Add bgp_aggregate_ipv4 and bgp_aggregate_ipv6.\n\n1999-04-17  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (aggregate_address): Function added.\n\n\t* bgp_zebra.c (zebra_read): Change log to zlog.\n\n1999-04-15  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* Makefile.am (noninst_HEADERS): Added for make dist.\n\n1999-04-09  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* aspath_regex.c: Removed from distribution.\n\n1999-04-07  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_attr.c (bgp_packet_attribute): Old draft-00 packet treatment\n\tbug fixed.\n\n1999-04-06  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_aspath.c (aspath_add_left): Fix empty aspath bug.  Reported\n\tby kad@gibson.skif.net.\n\n\t* bgp_regex.[ch]: New file added.\n\n\t\n1999-04-05  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_filter.c: New file added.\n\n1999-04-01  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_aspath.c (aspath_empty_aspath): Change for peering with\n\tgated.\n\n1999-03-24  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_main.c (main): Default loggin method changed from syslog to\n\tstdout.\n\n1999-03-05  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c: Delete obsolete default attribute DEFUN.\n\n1999-03-04  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_attr.c: Make attribute structure put into attribute hash.\n\n1999-03-02  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_view.c : Delete file.\n\n1999-02-25  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_routemap.c (bgp_apply_route_map): Add prefix argument. \n\n\t* bgp_route.h (struct bgp_info): Add bgp_info structre.  I'll\n\treplace bgp_route with this.\n\n\t* bgp_routemap.c (route_match_ip_address): Fix bug of passing non\n\tprefix value to access_list_apply(). \n\n\t* bgpd.conf.sample: Add route-map sample.\n\tDelete obsolete default-attr statements.\n\n\t* bgp_packet.c: Use stream_fifo for packet queueing.\n\n1999-02-24  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_aspath.c (aspath_add_left): add non empty aspath treatment.\n\n\t* bgp_main.c: include unistd.h for daemon().\n\n\t* bgp_route.c (nlri_process): add IPv6 table lookup.\n\n\t* bgp_attr.c (route_parse_ipv6): call nlri_process().\n\t(attr_make): Obsolete function attr_make deleted.\n\n1999-02-22  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_aspath.c (aspath_add_left): change function name from\n\taspath_add_leftmost_as().\n\n1999-02-21  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_aspath.c: add aspath_add_leftmost_as ().\n\n1999-02-18  Peter Galbavy  <Peter.Galbavy@knowledge.com>\n\n\t* syslog support added\n\n1999-01-26  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c: DEFUN (neighbor_nexthop): deleted.\n\tDEFUN (neighbor_distribute_list): added.\n\n1999-01-19  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.h (struct peer ): header_buf and read_buf is removed.\n\n\t* bgp_peer.[ch]: Deleted.  Peer related functions are merged to\n\tbgpd.c\n\n\t* bgp_network.c: New file.\n\t* bgp_network.h: New file.\n\n\t* bgp_packet.h: New file.\n\t\n1999-01-11  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_packet.c (bgp_keepalive_send): Now BGP keepalive packet is\n\tbuffered.\n\n1999-01-08  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_packet.c: New file.\n\n1998-12-22  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_zebra.c (zebra_client): Use zebra_connect() in lib/client.c. \n\n\t* `show ip bgp' bug fixed.\n\t* aspath_log (): Remove argument logfp.\n\n1998-12-15  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_fsm.h: New file.\n\n1998-12-15  Magnus Ahltorp <map@stacken.kth.se>\n\n\t* bgp_attr.c, bgp_community.h, bgp_dump.c, bgp_fsm.c, bgp_open.c\n\tbgp_peer.c, bgp_peer.h, bgp_route.c, bgp_route.h, bgp_view.c\n\tbgpd.c, bgpd.h, bgp_attr.c, bgp_community.h, bgp_dump.c,\n\tbgp_fsm.c, bgp_open.c, bgp_peer.c, bgp_peer.h: Prototype fixes.\n\n1998-12-09  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c (bgp_config_write): Delete vector v argument.\n\n1998-12-07  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.h: Delete annoying ld_[124]byte and st_[124]byte macros.\n\n1998-11-23  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_radix.[ch]: removed.\n\n1998-09-15  HEO SeonMeyong  <seirios@matrix.iri.co.jp>\n\n\t* bgp_main.c: ifdef HYDRANGEA -> ifdef KAME\n\n1998-08-13  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_dump.c: delete nroute().\n\n1998-05-19  Yamshita TAKAO  <jargon@lares.dti.ne.jp>\n\n\t* bgp_aspath.c: HAVE_CONFIG_H typo :-)\n\t* bgpd.h: Modify for compile on Solaris.\n\t* bgp_aspath.h: likewize\n\t* bgp_community.h: likewize\n\t* bgp_routemap.c: likewize\n\n1998-05-18  Yamshita TAKAO  <jargon@lares.dti.ne.jp>\n\n\t* bgpd.h: Modify for compile on Solaris.\n\t* bgp_aspath.h: likewize\n\n1998-05-08  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* routemap.[ch]: move to ../lib directory.\n\n1998-05-07  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* routemap.c (route_map_apply): add function.\n\n1998-05-06  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* routemap.h: add file.\n\n\t* bgp_peer.h (enum ): change PEER_{IBGP,EBGP} to BGP_PEER_{IBGP,EBGP}\n\n1998-05-03  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* Makefile.am: sysconfdir_DATA added.\n\n1998-05-02  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_dump.c: add `debug bgp fsm'\n\t\t      add `no debug bgp fsm'\n\t\t      add `show debug bgp'\n\t* bgp_open.c: File added.\n\n1998-05-01  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* .cvsignore: File added.\n\n1998-04-30  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_community.[ch]: File added.\n\n1998-03-04  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd now use lib/thread.[ch].\n\n1998-01-06  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c (show_ip_bgp_neighbors): add 'show ip bgp neighbors' command.\n\n\t* bgpd.h (BGP_DEFAULT_START_TIMER): change from 1 to 30.\n\n1997-12-30  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_vty.c: bgp_vty.c deleted.\n\n\t* bgpd.c (config_write_neighbor): add ebgp-multihop command.\n\n1997-12-29  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_fsm.c: [-p bgp_port] and [-P vty_port] works\n\n1997-12-06  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_vty.c: new file.\n\n\t* bgp_attr.c: add new logging system.\n\n1997-11-23  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* Change all inet_addr call into inet_aton.\n\n1997-11-10  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_radix.c: change radix_peer_delete\n\n1997-10-04  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_aspath.c: move AS_TOKEN_??? definition from header to c source.\n\n1997-09-12  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_dump.c (bgp_log_route): add dump_attr function\n\n1997-09-06  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_aspath.c (aspath_test): change AS_SET brace from '[' to '{'\n\t* bgp_dump.c (bgp_log_route): change logfile format.\n\n1997-08-19  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_open.c (bgp_open): move bgp_open function from bgpd.c\n\t* bgp_attr.c (community_str2com): add community value generation\n\t* bgp_attr.h: add SAFI definition for BGP-4+\n\n1997-08-18  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.h: add BGP_OPEN_OPT_CAP for Capabilities Optional Parameter\n\t* Makefile.in: add bgp_open.o, delete bgp_loop.o\n\t* bgp_open.c: newfile which manages BGP Open message\n\t* bgp_loop.c: this file is merged with bgp_fsm.c\n\t* bgp_radix.c (radix_add): radix_add() now return route_t instead\n\tof int\n\t(bgp_sim): now we can read update & withdraw from file\n\t* bgp_route.c: add route_free() call into route_parse etc.\n\n1997-08-17  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_radix.c: Radix code is completely rewritten. It has better\n\tmemory treatment than old one.\n\n1997-08-14  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c: route_alloc for route struct allocation statistics.\n\t* bgpd.c (bgp_make_update): now we cann announce MED attribute.\n\t* bgp_aspath.c (aspath_print_all): change aspath_print_all output\n\tformat.\n\n1997-08-13  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_term.c (term_parse): add command : show asstat, show ashash\n\t* bgp_aspath.c: aspath_cmp bug fix\n\t(aspath_print_all): add aspath_print_all ();\n\t* bgp_peer.h: delete rlist element from struct peer.\n\n1997-08-12  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_aspath.c: completely rewritten.\n\t* bgp_aspath.h: completely rewritten.\n\tadd AsPath, AsSegment structure\n\tadd AS_SET treatment\n\tchange Hash codes\n\n1997-08-09  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_attr.h: add Attribute flags defines\n\t* bgp_route.c: delete rlist related functions\n\t* bgp_aspath.c (as_origin): add as_origin function\n\t(aspath_print): move from bgp_dump.c and add support of AS_SET\n\tchange Hash related function names.\n\n1997-08-08  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_aspath.h: add next entry, delete rlist entry from struct aspath\n\n1997-08-04  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_aspath.c (as_sort): add function as_sort\n\t* bgp_aspath.h: add IBGP, EBGP\n\n", "/* BGP message debug header.\n   Copyright (C) 1996, 97, 98 Kunihiro Ishiguro\n\nThis file is part of GNU Zebra.\n\nGNU Zebra is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the\nFree Software Foundation; either version 2, or (at your option) any\nlater version.\n\nGNU Zebra is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GNU Zebra; see the file COPYING.  If not, write to the Free\nSoftware Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef _QUAGGA_BGP_DEBUG_H\n#define _QUAGGA_BGP_DEBUG_H\n\n/* sort of packet direction */\n#define DUMP_ON        1\n#define DUMP_SEND      2\n#define DUMP_RECV      4\n\n/* for dump_update */\n#define DUMP_WITHDRAW  8\n#define DUMP_NLRI     16\n\n/* dump detail */\n#define DUMP_DETAIL   32\n\nextern int dump_open;\nextern int dump_update;\nextern int dump_keepalive;\nextern int dump_notify;\n\nextern int Debug_Event;\nextern int Debug_Keepalive;\nextern int Debug_Update;\nextern int Debug_Radix;\n\n#define\tNLRI\t 1\n#define\tWITHDRAW 2\n#define\tNO_OPT\t 3\n#define\tSEND\t 4\n#define\tRECV\t 5\n#define\tDETAIL\t 6\n\n/* Prototypes. */\nextern void bgp_debug_init (void);\nextern void bgp_packet_dump (struct stream *);\n\nextern int debug (unsigned int option);\n\nextern unsigned long conf_bgp_debug_fsm;\nextern unsigned long conf_bgp_debug_events;\nextern unsigned long conf_bgp_debug_packet;\nextern unsigned long conf_bgp_debug_filter;\nextern unsigned long conf_bgp_debug_keepalive;\nextern unsigned long conf_bgp_debug_update;\nextern unsigned long conf_bgp_debug_normal;\nextern unsigned long conf_bgp_debug_zebra;\n\nextern unsigned long term_bgp_debug_fsm;\nextern unsigned long term_bgp_debug_events;\nextern unsigned long term_bgp_debug_packet;\nextern unsigned long term_bgp_debug_filter;\nextern unsigned long term_bgp_debug_keepalive;\nextern unsigned long term_bgp_debug_update;\nextern unsigned long term_bgp_debug_normal;\nextern unsigned long term_bgp_debug_zebra;\n\n#define BGP_DEBUG_FSM                 0x01\n#define BGP_DEBUG_EVENTS              0x01\n#define BGP_DEBUG_PACKET              0x01\n#define BGP_DEBUG_FILTER              0x01\n#define BGP_DEBUG_KEEPALIVE           0x01\n#define BGP_DEBUG_UPDATE_IN           0x01\n#define BGP_DEBUG_UPDATE_OUT          0x02\n#define BGP_DEBUG_NORMAL              0x01\n#define BGP_DEBUG_ZEBRA               0x01\n\n#define BGP_DEBUG_PACKET_SEND         0x01\n#define BGP_DEBUG_PACKET_SEND_DETAIL  0x02\n\n#define BGP_DEBUG_PACKET_RECV         0x01\n#define BGP_DEBUG_PACKET_RECV_DETAIL  0x02\n\n#define CONF_DEBUG_ON(a, b)\t(conf_bgp_debug_ ## a |= (BGP_DEBUG_ ## b))\n#define CONF_DEBUG_OFF(a, b)\t(conf_bgp_debug_ ## a &= ~(BGP_DEBUG_ ## b))\n\n#define TERM_DEBUG_ON(a, b)\t(term_bgp_debug_ ## a |= (BGP_DEBUG_ ## b))\n#define TERM_DEBUG_OFF(a, b)\t(term_bgp_debug_ ## a &= ~(BGP_DEBUG_ ## b))\n\n#define DEBUG_ON(a, b) \\\n    do { \\\n\tCONF_DEBUG_ON(a, b); \\\n\tTERM_DEBUG_ON(a, b); \\\n    } while (0)\n#define DEBUG_OFF(a, b) \\\n    do { \\\n\tCONF_DEBUG_OFF(a, b); \\\n\tTERM_DEBUG_OFF(a, b); \\\n    } while (0)\n\n#define BGP_DEBUG(a, b)\t\t(term_bgp_debug_ ## a & BGP_DEBUG_ ## b)\n#define CONF_BGP_DEBUG(a, b)    (conf_bgp_debug_ ## a & BGP_DEBUG_ ## b)\n\nconst extern char *bgp_type_str[];\n\nextern int bgp_dump_attr (struct peer *, struct attr *, char *, size_t);\nextern void bgp_notify_print (struct peer *, struct bgp_notify *, const char *);\n\nextern struct message bgp_status_msg[];\nextern int bgp_status_msg_max;\n\n#endif /* _QUAGGA_BGP_DEBUG_H */\n", "/* BGP open message handling\n   Copyright (C) 1998, 1999 Kunihiro Ishiguro\n\nThis file is part of GNU Zebra.\n\nGNU Zebra is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the\nFree Software Foundation; either version 2, or (at your option) any\nlater version.\n\nGNU Zebra is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GNU Zebra; see the file COPYING.  If not, write to the Free\nSoftware Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#include <zebra.h>\n\n#include \"linklist.h\"\n#include \"prefix.h\"\n#include \"stream.h\"\n#include \"thread.h\"\n#include \"log.h\"\n#include \"command.h\"\n\n#include \"bgpd/bgpd.h\"\n#include \"bgpd/bgp_attr.h\"\n#include \"bgpd/bgp_debug.h\"\n#include \"bgpd/bgp_fsm.h\"\n#include \"bgpd/bgp_packet.h\"\n#include \"bgpd/bgp_open.h\"\n#include \"bgpd/bgp_vty.h\"\n\n/* BGP-4 Multiprotocol Extentions lead us to the complex world. We can\n   negotiate remote peer supports extentions or not. But if\n   remote-peer doesn't supports negotiation process itself.  We would\n   like to do manual configuration.\n\n   So there is many configurable point.  First of all we want set each\n   peer whether we send capability negotiation to the peer or not.\n   Next, if we send capability to the peer we want to set my capabilty\n   inforation at each peer. */\n\nvoid\nbgp_capability_vty_out (struct vty *vty, struct peer *peer)\n{\n  char *pnt;\n  char *end;\n  struct capability cap;\n\n  pnt = peer->notify.data;\n  end = pnt + peer->notify.length;\n\n  while (pnt < end)\n    {\n      memcpy(&cap, pnt, sizeof(struct capability));\n\n      if (pnt + 2 > end)\n\treturn;\n      if (pnt + (cap.length + 2) > end)\n\treturn;\n\n      if (cap.code == CAPABILITY_CODE_MP)\n\t{\n\t  vty_out (vty, \"  Capability error for: Multi protocol \");\n\n\t  switch (ntohs (cap.mpc.afi))\n\t    {\n\t    case AFI_IP:\n\t      vty_out (vty, \"AFI IPv4, \");\n\t      break;\n\t    case AFI_IP6:\n\t      vty_out (vty, \"AFI IPv6, \");\n\t      break;\n\t    default:\n\t      vty_out (vty, \"AFI Unknown %d, \", ntohs (cap.mpc.afi));\n\t      break;\n\t    }\n\t  switch (cap.mpc.safi)\n\t    {\n\t    case SAFI_UNICAST:\n\t      vty_out (vty, \"SAFI Unicast\");\n\t      break;\n\t    case SAFI_MULTICAST:\n\t      vty_out (vty, \"SAFI Multicast\");\n\t      break;\n\t    case SAFI_UNICAST_MULTICAST:\n\t      vty_out (vty, \"SAFI Unicast Multicast\");\n\t      break;\n\t    case BGP_SAFI_VPNV4:\n\t      vty_out (vty, \"SAFI MPLS-VPN\");\n\t      break;\n\t    default:\n\t      vty_out (vty, \"SAFI Unknown %d \", cap.mpc.safi);\n\t      break;\n\t    }\n\t  vty_out (vty, \"%s\", VTY_NEWLINE);\n\t}\n      else if (cap.code >= 128)\n\tvty_out (vty, \"  Capability error: vendor specific capability code %d\",\n\t\t cap.code);\n      else\n\tvty_out (vty, \"  Capability error: unknown capability code %d\", \n\t\t cap.code);\n\n      pnt += cap.length + 2;\n    }\n}\n\n/* Set negotiated capability value. */\nstatic int\nbgp_capability_mp (struct peer *peer, struct capability *cap)\n{\n  if (ntohs (cap->mpc.afi) == AFI_IP)\n    {\n      if (cap->mpc.safi == SAFI_UNICAST)\n\t{\n\t  peer->afc_recv[AFI_IP][SAFI_UNICAST] = 1;\n\n\t  if (peer->afc[AFI_IP][SAFI_UNICAST])\n\t    peer->afc_nego[AFI_IP][SAFI_UNICAST] = 1;\n\t  else\n\t    return -1;\n\t}\n      else if (cap->mpc.safi == SAFI_MULTICAST) \n\t{\n\t  peer->afc_recv[AFI_IP][SAFI_MULTICAST] = 1;\n\n\t  if (peer->afc[AFI_IP][SAFI_MULTICAST])\n\t    peer->afc_nego[AFI_IP][SAFI_MULTICAST] = 1;\n\t  else\n\t    return -1;\n\t}\n      else if (cap->mpc.safi == BGP_SAFI_VPNV4)\n\t{\n\t  peer->afc_recv[AFI_IP][SAFI_MPLS_VPN] = 1;\n\n\t  if (peer->afc[AFI_IP][SAFI_MPLS_VPN])\n\t    peer->afc_nego[AFI_IP][SAFI_MPLS_VPN] = 1;\n\t  else\n\t    return -1;\n\t}\n      else\n\treturn -1;\n    }\n#ifdef HAVE_IPV6\n  else if (ntohs (cap->mpc.afi) == AFI_IP6)\n    {\n      if (cap->mpc.safi == SAFI_UNICAST)\n\t{\n\t  peer->afc_recv[AFI_IP6][SAFI_UNICAST] = 1;\n\n\t  if (peer->afc[AFI_IP6][SAFI_UNICAST])\n\t    peer->afc_nego[AFI_IP6][SAFI_UNICAST] = 1;\n\t  else\n\t    return -1;\n\t}\n      else if (cap->mpc.safi == SAFI_MULTICAST)\n\t{\n\t  peer->afc_recv[AFI_IP6][SAFI_MULTICAST] = 1;\n\n\t  if (peer->afc[AFI_IP6][SAFI_MULTICAST])\n\t    peer->afc_nego[AFI_IP6][SAFI_MULTICAST] = 1;\n\t  else\n\t    return -1;\n\t}\n      else\n\treturn -1;\n    }\n#endif /* HAVE_IPV6 */\n  else\n    {\n      /* Unknown Address Family. */\n      return -1;\n    }\n\n  return 0;\n}\n\nstatic void\nbgp_capability_orf_not_support (struct peer *peer, afi_t afi, safi_t safi,\n\t\t\t\tu_char type, u_char mode)\n{\n  if (BGP_DEBUG (normal, NORMAL))\n    zlog_debug (\"%s Addr-family %d/%d has ORF type/mode %d/%d not supported\",\n\t       peer->host, afi, safi, type, mode);\n}\n\nstatic int\nbgp_capability_orf (struct peer *peer, struct capability *cap,\n\t\t    u_char *pnt)\n{\n  afi_t afi = ntohs(cap->mpc.afi);\n  safi_t safi = cap->mpc.safi;\n  u_char number_of_orfs;\n  u_char type;\n  u_char mode;\n  u_int16_t sm_cap = 0; /* capability send-mode receive */\n  u_int16_t rm_cap = 0; /* capability receive-mode receive */ \n  int i;\n\n  /* Check length. */\n  if (cap->length < 7)\n    {\n      zlog_info (\"%s ORF Capability length error %d\",\n\t\t peer->host, cap->length);\n\t\t bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n      return -1;\n    }\n\n  if (BGP_DEBUG (normal, NORMAL))\n    zlog_debug (\"%s OPEN has ORF CAP(%s) for afi/safi: %u/%u\",\n\t       peer->host, (cap->code == CAPABILITY_CODE_ORF ?\n                       \"new\" : \"old\"), afi, safi);\n\n  /* Check AFI and SAFI. */\n  if ((afi != AFI_IP && afi != AFI_IP6)\n      || (safi != SAFI_UNICAST && safi != SAFI_MULTICAST\n\t  && safi != BGP_SAFI_VPNV4))\n    {\n      zlog_info (\"%s Addr-family %d/%d not supported. Ignoring the ORF capability\",\n                 peer->host, afi, safi);\n      return -1;\n    }\n\n  number_of_orfs = *pnt++;\n\n  for (i = 0 ; i < number_of_orfs ; i++)\n    {\n      type = *pnt++;\n      mode = *pnt++;\n\n      /* ORF Mode error check */\n      if (mode != ORF_MODE_BOTH && mode != ORF_MODE_SEND\n\t  && mode != ORF_MODE_RECEIVE)\n\t{\n\t  bgp_capability_orf_not_support (peer, afi, safi, type, mode);\n\t  continue;\n\t}\n\n      /* ORF Type and afi/safi error check */\n      if (cap->code == CAPABILITY_CODE_ORF)\n\t{\n\t  if (type == ORF_TYPE_PREFIX &&\n\t      ((afi == AFI_IP && safi == SAFI_UNICAST)\n\t\t|| (afi == AFI_IP && safi == SAFI_MULTICAST)\n\t\t|| (afi == AFI_IP6 && safi == SAFI_UNICAST)))\n\t    {\n\t      sm_cap = PEER_CAP_ORF_PREFIX_SM_RCV;\n\t      rm_cap = PEER_CAP_ORF_PREFIX_RM_RCV;\n\t      if (BGP_DEBUG (normal, NORMAL))\n\t\tzlog_debug (\"%s OPEN has Prefixlist ORF(%d) capability as %s for afi/safi: %d/%d\",\n\t\t\t   peer->host, ORF_TYPE_PREFIX, (mode == ORF_MODE_SEND ? \"SEND\" :\n\t\t\t   mode == ORF_MODE_RECEIVE ? \"RECEIVE\" : \"BOTH\") , afi, safi);\n\t    }\n\t  else\n\t    {\n\t      bgp_capability_orf_not_support (peer, afi, safi, type, mode);\n\t      continue;\n\t    }\n\t}\n      else if (cap->code == CAPABILITY_CODE_ORF_OLD)\n\t{\n\t  if (type == ORF_TYPE_PREFIX_OLD &&\n\t      ((afi == AFI_IP && safi == SAFI_UNICAST)\n\t\t|| (afi == AFI_IP && safi == SAFI_MULTICAST)\n\t\t|| (afi == AFI_IP6 && safi == SAFI_UNICAST)))\n\t    {\n\t      sm_cap = PEER_CAP_ORF_PREFIX_SM_OLD_RCV;\n\t      rm_cap = PEER_CAP_ORF_PREFIX_RM_OLD_RCV;\n\t      if (BGP_DEBUG (normal, NORMAL))\n\t\tzlog_debug (\"%s OPEN has Prefixlist ORF(%d) capability as %s for afi/safi: %d/%d\",\n\t\t\t   peer->host, ORF_TYPE_PREFIX_OLD, (mode == ORF_MODE_SEND ? \"SEND\" :\n\t\t\t   mode == ORF_MODE_RECEIVE ? \"RECEIVE\" : \"BOTH\") , afi, safi);\n\t    }\n\t  else\n\t    {\n\t      bgp_capability_orf_not_support (peer, afi, safi, type, mode);\n\t      continue;\n\t    }\n\t}\n      else\n\t{\n\t  bgp_capability_orf_not_support (peer, afi, safi, type, mode);\n\t  continue;\n\t}\n\n      switch (mode)\n\t{\n\t  case ORF_MODE_BOTH:\n\t    SET_FLAG (peer->af_cap[afi][safi], sm_cap);\n\t    SET_FLAG (peer->af_cap[afi][safi], rm_cap);\n\t    break;\n\t  case ORF_MODE_SEND:\n\t    SET_FLAG (peer->af_cap[afi][safi], sm_cap);\n\t    break;\n\t  case ORF_MODE_RECEIVE:\n\t    SET_FLAG (peer->af_cap[afi][safi], rm_cap);\n\t    break;\n\t}\n    }\n  return 0;\n}\n\n/* Parse given capability. */\nstatic int\nbgp_capability_parse (struct peer *peer, u_char *pnt, u_char length,\n\t\t      u_char **error)\n{\n  int ret;\n  u_char *end;\n  struct capability cap;\n\n  end = pnt + length;\n\n  while (pnt < end)\n    {\n      afi_t afi;\n      safi_t safi;\n\n      /* Fetch structure to the byte stream. */\n      memcpy (&cap, pnt, sizeof (struct capability));\n\n      afi = ntohs(cap.mpc.afi);\n      safi = cap.mpc.safi;\n\n      if (BGP_DEBUG (normal, NORMAL))\n\tzlog_debug (\"%s OPEN has CAPABILITY code: %d, length %d\",\n\t\t   peer->host, cap.code, cap.length);\n\n      /* We need at least capability code and capability length. */\n      if (pnt + 2 > end)\n\t{\n\t  zlog_info (\"%s Capability length error\", peer->host);\n\t  bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n\t  return -1;\n\t}\n\n      /* Capability length check. */\n      if (pnt + (cap.length + 2) > end)\n\t{\n\t  zlog_info (\"%s Capability length error\", peer->host);\n\t  bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n\t  return -1;\n\t}\n\n      /* We know MP Capability Code. */\n      if (cap.code == CAPABILITY_CODE_MP)\n\t{\n\t  if (BGP_DEBUG (normal, NORMAL))\n\t    zlog_debug (\"%s OPEN has MP_EXT CAP for afi/safi: %u/%u\",\n\t\t       peer->host, afi, safi);\n\n\t  /* Ignore capability when override-capability is set. */\n\t  if (! CHECK_FLAG (peer->flags, PEER_FLAG_OVERRIDE_CAPABILITY))\n\t    {\n\t      /* Set negotiated value. */\n\t      ret = bgp_capability_mp (peer, &cap);\n\n\t      /* Unsupported Capability. */\n\t      if (ret < 0)\n\t\t{\n\t\t  /* Store return data. */\n\t\t  memcpy (*error, &cap, cap.length + 2);\n\t\t  *error += cap.length + 2;\n\t\t}\n\t    }\n\t}\n      else if (cap.code == CAPABILITY_CODE_REFRESH\n\t       || cap.code == CAPABILITY_CODE_REFRESH_OLD)\n\t{\n\t  /* Check length. */\n\t  if (cap.length != CAPABILITY_CODE_REFRESH_LEN)\n\t    {\n\t      zlog_info (\"%s Route Refresh Capability length error %d\",\n\t\t\t peer->host, cap.length);\n\t      bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n\t      return -1;\n\t    }\n\n\t  if (BGP_DEBUG (normal, NORMAL))\n\t    zlog_debug (\"%s OPEN has ROUTE-REFRESH capability(%s) for all address-families\",\n\t\t       peer->host,\n\t\t       cap.code == CAPABILITY_CODE_REFRESH_OLD ? \"old\" : \"new\");\n\n\t  /* BGP refresh capability */\n\t  if (cap.code == CAPABILITY_CODE_REFRESH_OLD)\n\t    SET_FLAG (peer->cap, PEER_CAP_REFRESH_OLD_RCV);\n\t  else\n\t    SET_FLAG (peer->cap, PEER_CAP_REFRESH_NEW_RCV);\n\t}\n      else if (cap.code == CAPABILITY_CODE_ORF\n\t       || cap.code == CAPABILITY_CODE_ORF_OLD)\n\tbgp_capability_orf (peer, &cap, pnt + sizeof (struct capability));\n      else if (cap.code == CAPABILITY_CODE_RESTART)\n       {\n         struct graceful_restart_af graf;\n         u_int16_t restart_flag_time;\n         int restart_bit = 0;\n         u_char *restart_pnt;\n         u_char *restart_end;\n\n         /* Check length. */\n         if (cap.length < CAPABILITY_CODE_RESTART_LEN)\n           {\n             zlog_info (\"%s Graceful Restart Capability length error %d\",\n                        peer->host, cap.length);\n             bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n             return -1;\n           }\n\n         SET_FLAG (peer->cap, PEER_CAP_RESTART_RCV);\n         restart_flag_time = ntohs(cap.mpc.afi);\n         if (CHECK_FLAG (restart_flag_time, RESTART_R_BIT))\n           restart_bit = 1;\n         UNSET_FLAG (restart_flag_time, 0xF000);\n\t peer->v_gr_restart = restart_flag_time;\n\n         if (BGP_DEBUG (normal, NORMAL))\n           {\n             zlog_debug (\"%s OPEN has Graceful Restart capability\", peer->host);\n             zlog_debug (\"%s Peer has%srestarted. Restart Time : %d\",\n                        peer->host, restart_bit ? \" \" : \" not \",\n\t\t\tpeer->v_gr_restart);\n           }\n\n         restart_pnt = pnt + 4;\n         restart_end = pnt + cap.length + 2;\n\n         while (restart_pnt < restart_end)\n           {\n             memcpy (&graf, restart_pnt, sizeof (struct graceful_restart_af));\n\n             afi = ntohs(graf.afi);\n             safi = graf.safi;\n\n             if (CHECK_FLAG (graf.flag, RESTART_F_BIT))\n\t\tSET_FLAG (peer->af_cap[afi][safi], PEER_CAP_RESTART_AF_PRESERVE_RCV);\n\n             if (strcmp (afi_safi_print (afi, safi), \"Unknown\") == 0)\n               {\n                  if (BGP_DEBUG (normal, NORMAL))\n                    zlog_debug (\"%s Addr-family %d/%d(afi/safi) not supported. I gnore the Graceful Restart capability\",\n                               peer->host, afi, safi);\n               }\n             else if (! peer->afc[afi][safi])\n               {\n                  if (BGP_DEBUG (normal, NORMAL))\n                     zlog_debug (\"%s Addr-family %d/%d(afi/safi) not enabled. Ignore the Graceful Restart capability\",\n                                peer->host, afi, safi);\n               }\n             else\n               {\n                 if (BGP_DEBUG (normal, NORMAL))\n                   zlog_debug (\"%s Address family %s is%spreserved\", peer->host,\n\t\t\t       afi_safi_print (afi, safi),\n\t\t\t       CHECK_FLAG (peer->af_cap[afi][safi],\n\t\t\t       PEER_CAP_RESTART_AF_PRESERVE_RCV)\n\t\t\t       ? \" \" : \" not \");\n\n                   SET_FLAG (peer->af_cap[afi][safi], PEER_CAP_RESTART_AF_RCV);\n               }\n             restart_pnt += 4;\n           }\n       }\n      else if (cap.code == CAPABILITY_CODE_DYNAMIC)\n\t{\n\t  /* Check length. */\n\t  if (cap.length != CAPABILITY_CODE_DYNAMIC_LEN)\n\t    {\n\t      zlog_info (\"%s Dynamic Capability length error %d\",\n\t\t\t peer->host, cap.length);\n\t      bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n\t      return -1;\n\t    }\n\n\t  if (BGP_DEBUG (normal, NORMAL))\n\t    zlog_debug (\"%s OPEN has DYNAMIC capability\", peer->host);\n\n\t  SET_FLAG (peer->cap, PEER_CAP_DYNAMIC_RCV);\n\t}\n \n      else if (cap.code > 128)\n\t{\n\t  /* We don't send Notification for unknown vendor specific\n\t     capabilities.  It seems reasonable for now...  */\n\t  zlog_warn (\"%s Vendor specific capability %d\",\n\t\t     peer->host, cap.code);\n\t}\n      else\n\t{\n\t  zlog_warn (\"%s unrecognized capability code: %d - ignored\",\n\t\t     peer->host, cap.code);\n\t  memcpy (*error, &cap, cap.length + 2);\n\t  *error += cap.length + 2;\n\t}\n\n      pnt += cap.length + 2;\n    }\n  return 0;\n}\n\nstatic int\nbgp_auth_parse (struct peer *peer, u_char *pnt, size_t length)\n{\n  bgp_notify_send (peer, \n\t\t   BGP_NOTIFY_OPEN_ERR, \n\t\t   BGP_NOTIFY_OPEN_AUTH_FAILURE); \n  return -1;\n}\n\nstatic int\nstrict_capability_same (struct peer *peer)\n{\n  int i, j;\n\n  for (i = AFI_IP; i < AFI_MAX; i++)\n    for (j = SAFI_UNICAST; j < SAFI_MAX; j++)\n      if (peer->afc[i][j] != peer->afc_nego[i][j])\n\treturn 0;\n  return 1;\n}\n\n/* Parse open option */\nint\nbgp_open_option_parse (struct peer *peer, u_char length, int *capability)\n{\n  int ret;\n  u_char *end;\n  u_char opt_type;\n  u_char opt_length;\n  u_char *pnt;\n  u_char *error;\n  u_char error_data[BGP_MAX_PACKET_SIZE];\n\n  /* Fetch pointer. */\n  pnt = stream_pnt (peer->ibuf);\n\n  ret = 0;\n  opt_type = 0;\n  opt_length = 0;\n  end = pnt + length;\n  error = error_data;\n\n  if (BGP_DEBUG (normal, NORMAL))\n    zlog_debug (\"%s rcv OPEN w/ OPTION parameter len: %u\",\n\t       peer->host, length);\n  \n  while (pnt < end) \n    {\n      /* Check the length. */\n      if (pnt + 2 > end)\n\t{\n\t  zlog_info (\"%s Option length error\", peer->host);\n\t  bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n\t  return -1;\n\t}\n\n      /* Fetch option type and length. */\n      opt_type = *pnt++;\n      opt_length = *pnt++;\n      \n      /* Option length check. */\n      if (pnt + opt_length > end)\n\t{\n\t  zlog_info (\"%s Option length error\", peer->host);\n\t  bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n\t  return -1;\n\t}\n\n      if (BGP_DEBUG (normal, NORMAL))\n\tzlog_debug (\"%s rcvd OPEN w/ optional parameter type %u (%s) len %u\",\n\t\t   peer->host, opt_type,\n\t\t   opt_type == BGP_OPEN_OPT_AUTH ? \"Authentication\" :\n\t\t   opt_type == BGP_OPEN_OPT_CAP ? \"Capability\" : \"Unknown\",\n\t\t   opt_length);\n  \n      switch (opt_type)\n\t{\n\tcase BGP_OPEN_OPT_AUTH:\n\t  ret = bgp_auth_parse (peer, pnt, opt_length);\n\t  break;\n\tcase BGP_OPEN_OPT_CAP:\n\t  ret = bgp_capability_parse (peer, pnt, opt_length, &error);\n\t  *capability = 1;\n\t  break;\n\tdefault:\n\t  bgp_notify_send (peer, \n\t\t\t   BGP_NOTIFY_OPEN_ERR, \n\t\t\t   BGP_NOTIFY_OPEN_UNSUP_PARAM); \n\t  ret = -1;\n\t  break;\n\t}\n\n      /* Parse error.  To accumulate all unsupported capability codes,\n         bgp_capability_parse does not return -1 when encounter\n         unsupported capability code.  To detect that, please check\n         error and erro_data pointer, like below.  */\n      if (ret < 0)\n\treturn -1;\n\n      /* Forward pointer. */\n      pnt += opt_length;\n    }\n\n  /* All OPEN option is parsed.  Check capability when strict compare\n     flag is enabled.*/\n  if (CHECK_FLAG (peer->flags, PEER_FLAG_STRICT_CAP_MATCH))\n    {\n      /* If Unsupported Capability exists. */\n      if (error != error_data)\n\t{\n\t  bgp_notify_send_with_data (peer, \n\t\t\t\t     BGP_NOTIFY_OPEN_ERR, \n\t\t\t\t     BGP_NOTIFY_OPEN_UNSUP_CAPBL, \n\t\t\t\t     error_data, error - error_data);\n\t  return -1;\n\t}\n\n      /* Check local capability does not negotiated with remote\n         peer. */\n      if (! strict_capability_same (peer))\n\t{\n\t  bgp_notify_send (peer, \n\t\t\t   BGP_NOTIFY_OPEN_ERR, \n\t\t\t   BGP_NOTIFY_OPEN_UNSUP_CAPBL);\n\t  return -1;\n\t}\n    }\n\n  /* Check there is no common capability send Unsupported Capability\n     error. */\n  if (*capability && ! CHECK_FLAG (peer->flags, PEER_FLAG_OVERRIDE_CAPABILITY))\n    {\n      if (! peer->afc_nego[AFI_IP][SAFI_UNICAST] \n\t  && ! peer->afc_nego[AFI_IP][SAFI_MULTICAST]\n\t  && ! peer->afc_nego[AFI_IP][SAFI_MPLS_VPN]\n\t  && ! peer->afc_nego[AFI_IP6][SAFI_UNICAST]\n\t  && ! peer->afc_nego[AFI_IP6][SAFI_MULTICAST])\n\t{\n\t  plog_err (peer->log, \"%s [Error] No common capability\", peer->host);\n\n\t  if (error != error_data)\n\n\t    bgp_notify_send_with_data (peer, \n\t\t\t\t       BGP_NOTIFY_OPEN_ERR, \n\t\t\t\t       BGP_NOTIFY_OPEN_UNSUP_CAPBL, \n\t\t\t\t       error_data, error - error_data);\n\t  else\n\t    bgp_notify_send (peer, \n\t\t\t     BGP_NOTIFY_OPEN_ERR, \n\t\t\t     BGP_NOTIFY_OPEN_UNSUP_CAPBL);\n\t  return -1;\n\t}\n    }\n  return 0;\n}\n\nstatic void\nbgp_open_capability_orf (struct stream *s, struct peer *peer,\n                         afi_t afi, safi_t safi, u_char code)\n{\n  u_char cap_len;\n  u_char orf_len;\n  unsigned long capp;\n  unsigned long orfp;\n  unsigned long numberp;\n  int number_of_orfs = 0;\n\n  if (safi == SAFI_MPLS_VPN)\n    safi = BGP_SAFI_VPNV4;\n\n  stream_putc (s, BGP_OPEN_OPT_CAP);\n  capp = stream_get_endp (s);           /* Set Capability Len Pointer */\n  stream_putc (s, 0);                   /* Capability Length */\n  stream_putc (s, code);                /* Capability Code */\n  orfp = stream_get_endp (s);           /* Set ORF Len Pointer */\n  stream_putc (s, 0);                   /* ORF Length */\n  stream_putw (s, afi);\n  stream_putc (s, 0);\n  stream_putc (s, safi);\n  numberp = stream_get_endp (s);        /* Set Number Pointer */\n  stream_putc (s, 0);                   /* Number of ORFs */\n\n  /* Address Prefix ORF */\n  if (CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_ORF_PREFIX_SM)\n      || CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_ORF_PREFIX_RM))\n    {\n      stream_putc (s, (code == CAPABILITY_CODE_ORF ?\n\t\t   ORF_TYPE_PREFIX : ORF_TYPE_PREFIX_OLD));\n\n      if (CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_ORF_PREFIX_SM)\n\t  && CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_ORF_PREFIX_RM))\n\t{\n\t  SET_FLAG (peer->af_cap[afi][safi], PEER_CAP_ORF_PREFIX_SM_ADV);\n\t  SET_FLAG (peer->af_cap[afi][safi], PEER_CAP_ORF_PREFIX_RM_ADV);\n\t  stream_putc (s, ORF_MODE_BOTH);\n\t}\n      else if (CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_ORF_PREFIX_SM))\n\t{\n\t  SET_FLAG (peer->af_cap[afi][safi], PEER_CAP_ORF_PREFIX_SM_ADV);\n\t  stream_putc (s, ORF_MODE_SEND);\n\t}\n      else\n\t{\n\t  SET_FLAG (peer->af_cap[afi][safi], PEER_CAP_ORF_PREFIX_RM_ADV);\n\t  stream_putc (s, ORF_MODE_RECEIVE);\n\t}\n      number_of_orfs++;\n    }\n\n  /* Total Number of ORFs. */\n  stream_putc_at (s, numberp, number_of_orfs);\n\n  /* Total ORF Len. */\n  orf_len = stream_get_endp (s) - orfp - 1;\n  stream_putc_at (s, orfp, orf_len);\n\n  /* Total Capability Len. */\n  cap_len = stream_get_endp (s) - capp - 1;\n  stream_putc_at (s, capp, cap_len);\n}\n\n/* Fill in capability open option to the packet. */\nvoid\nbgp_open_capability (struct stream *s, struct peer *peer)\n{\n  u_char len;\n  unsigned long cp;\n  afi_t afi;\n  safi_t safi;\n\n  /* Remember current pointer for Opt Parm Len. */\n  cp = stream_get_endp (s);\n\n  /* Opt Parm Len. */\n  stream_putc (s, 0);\n\n  /* Do not send capability. */\n  if (! CHECK_FLAG (peer->sflags, PEER_STATUS_CAPABILITY_OPEN) \n      || CHECK_FLAG (peer->flags, PEER_FLAG_DONT_CAPABILITY))\n    return;\n\n  /* IPv4 unicast. */\n  if (peer->afc[AFI_IP][SAFI_UNICAST])\n    {\n      peer->afc_adv[AFI_IP][SAFI_UNICAST] = 1;\n      stream_putc (s, BGP_OPEN_OPT_CAP);\n      stream_putc (s, CAPABILITY_CODE_MP_LEN + 2);\n      stream_putc (s, CAPABILITY_CODE_MP);\n      stream_putc (s, CAPABILITY_CODE_MP_LEN);\n      stream_putw (s, AFI_IP);\n      stream_putc (s, 0);\n      stream_putc (s, SAFI_UNICAST);\n    }\n  /* IPv4 multicast. */\n  if (peer->afc[AFI_IP][SAFI_MULTICAST])\n    {\n      peer->afc_adv[AFI_IP][SAFI_MULTICAST] = 1;\n      stream_putc (s, BGP_OPEN_OPT_CAP);\n      stream_putc (s, CAPABILITY_CODE_MP_LEN + 2);\n      stream_putc (s, CAPABILITY_CODE_MP);\n      stream_putc (s, CAPABILITY_CODE_MP_LEN);\n      stream_putw (s, AFI_IP);\n      stream_putc (s, 0);\n      stream_putc (s, SAFI_MULTICAST);\n    }\n  /* IPv4 VPN */\n  if (peer->afc[AFI_IP][SAFI_MPLS_VPN])\n    {\n      peer->afc_adv[AFI_IP][SAFI_MPLS_VPN] = 1;\n      stream_putc (s, BGP_OPEN_OPT_CAP);\n      stream_putc (s, CAPABILITY_CODE_MP_LEN + 2);\n      stream_putc (s, CAPABILITY_CODE_MP);\n      stream_putc (s, CAPABILITY_CODE_MP_LEN);\n      stream_putw (s, AFI_IP);\n      stream_putc (s, 0);\n      stream_putc (s, BGP_SAFI_VPNV4);\n    }\n#ifdef HAVE_IPV6\n  /* IPv6 unicast. */\n  if (peer->afc[AFI_IP6][SAFI_UNICAST])\n    {\n      peer->afc_adv[AFI_IP6][SAFI_UNICAST] = 1;\n      stream_putc (s, BGP_OPEN_OPT_CAP);\n      stream_putc (s, CAPABILITY_CODE_MP_LEN + 2);\n      stream_putc (s, CAPABILITY_CODE_MP);\n      stream_putc (s, CAPABILITY_CODE_MP_LEN);\n      stream_putw (s, AFI_IP6);\n      stream_putc (s, 0);\n      stream_putc (s, SAFI_UNICAST);\n    }\n  /* IPv6 multicast. */\n  if (peer->afc[AFI_IP6][SAFI_MULTICAST])\n    {\n      peer->afc_adv[AFI_IP6][SAFI_MULTICAST] = 1;\n      stream_putc (s, BGP_OPEN_OPT_CAP);\n      stream_putc (s, CAPABILITY_CODE_MP_LEN + 2);\n      stream_putc (s, CAPABILITY_CODE_MP);\n      stream_putc (s, CAPABILITY_CODE_MP_LEN);\n      stream_putw (s, AFI_IP6);\n      stream_putc (s, 0);\n      stream_putc (s, SAFI_MULTICAST);\n    }\n#endif /* HAVE_IPV6 */\n\n  /* Route refresh. */\n  SET_FLAG (peer->cap, PEER_CAP_REFRESH_ADV);\n  stream_putc (s, BGP_OPEN_OPT_CAP);\n  stream_putc (s, CAPABILITY_CODE_REFRESH_LEN + 2);\n  stream_putc (s, CAPABILITY_CODE_REFRESH_OLD);\n  stream_putc (s, CAPABILITY_CODE_REFRESH_LEN);\n  stream_putc (s, BGP_OPEN_OPT_CAP);\n  stream_putc (s, CAPABILITY_CODE_REFRESH_LEN + 2);\n  stream_putc (s, CAPABILITY_CODE_REFRESH);\n  stream_putc (s, CAPABILITY_CODE_REFRESH_LEN);\n\n  /* ORF capability. */\n  for (afi = AFI_IP ; afi < AFI_MAX ; afi++)\n    for (safi = SAFI_UNICAST ; safi < SAFI_MAX ; safi++)\n      if (CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_ORF_PREFIX_SM)\n\t  || CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_ORF_PREFIX_RM))\n\t{\n\t  bgp_open_capability_orf (s, peer, afi, safi, CAPABILITY_CODE_ORF_OLD);\n\t  bgp_open_capability_orf (s, peer, afi, safi, CAPABILITY_CODE_ORF);\n\t}\n\n  /* Dynamic capability. */\n  if (CHECK_FLAG (peer->flags, PEER_FLAG_DYNAMIC_CAPABILITY))\n    {\n      SET_FLAG (peer->cap, PEER_CAP_DYNAMIC_ADV);\n      stream_putc (s, BGP_OPEN_OPT_CAP);\n      stream_putc (s, CAPABILITY_CODE_DYNAMIC_LEN + 2);\n      stream_putc (s, CAPABILITY_CODE_DYNAMIC);\n      stream_putc (s, CAPABILITY_CODE_DYNAMIC_LEN);\n    }\n\n  /* Graceful restart capability */\n  if (bgp_flag_check (peer->bgp, BGP_FLAG_GRACEFUL_RESTART))\n    {\n      SET_FLAG (peer->cap, PEER_CAP_RESTART_ADV);\n      stream_putc (s, BGP_OPEN_OPT_CAP);\n      stream_putc (s, CAPABILITY_CODE_RESTART_LEN + 2);\n      stream_putc (s, CAPABILITY_CODE_RESTART);\n      stream_putc (s, CAPABILITY_CODE_RESTART_LEN);\n      stream_putw (s, peer->bgp->restart_time);\n     }\n\n  /* Total Opt Parm Len. */\n  len = stream_get_endp (s) - cp - 1;\n  stream_putc_at (s, cp, len);\n}\n", "/* BGP open message handling\n   Copyright (C) 1999 Kunihiro Ishiguro\n\nThis file is part of GNU Zebra.\n\nGNU Zebra is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the\nFree Software Foundation; either version 2, or (at your option) any\nlater version.\n\nGNU Zebra is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GNU Zebra; see the file COPYING.  If not, write to the Free\nSoftware Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef _QUAGGA_BGP_OPEN_H\n#define _QUAGGA_BGP_OPEN_H\n\n/* MP Capability information. */\nstruct capability_mp\n{\n  u_int16_t afi;\n  u_char reserved;\n  u_char safi;\n};\n\n/* BGP open message capability. */\nstruct capability\n{\n  u_char code;\n  u_char length;\n  struct capability_mp mpc;\n};\n\nstruct graceful_restart_af\n{\n  u_int16_t afi;\n  u_char safi;\n  u_char flag;\n};\n\n/* Capability Code */\n#define CAPABILITY_CODE_MP              1 /* Multiprotocol Extensions */\n#define CAPABILITY_CODE_REFRESH         2 /* Route Refresh Capability */\n#define CAPABILITY_CODE_ORF             3 /* Cooperative Route Filtering Capability */\n#define CAPABILITY_CODE_RESTART        64 /* Graceful Restart Capability */\n#define CAPABILITY_CODE_4BYTE_AS       65 /* 4-octet AS number Capability */\n#define CAPABILITY_CODE_DYNAMIC        66 /* Dynamic Capability */\n#define CAPABILITY_CODE_REFRESH_OLD   128 /* Route Refresh Capability(cisco) */\n#define CAPABILITY_CODE_ORF_OLD       130 /* Cooperative Route Filtering Capability(cisco) */\n\n/* Capability Length */\n#define CAPABILITY_CODE_MP_LEN          4\n#define CAPABILITY_CODE_REFRESH_LEN     0\n#define CAPABILITY_CODE_DYNAMIC_LEN     0\n#define CAPABILITY_CODE_RESTART_LEN     2 /* Receiving only case */\n\n/* Cooperative Route Filtering Capability.  */\n\n/* ORF Type */\n#define ORF_TYPE_PREFIX                64 \n#define ORF_TYPE_PREFIX_OLD           128\n\n/* ORF Mode */\n#define ORF_MODE_RECEIVE                1 \n#define ORF_MODE_SEND                   2 \n#define ORF_MODE_BOTH                   3 \n\n/* Capability Message Action.  */\n#define CAPABILITY_ACTION_SET           0\n#define CAPABILITY_ACTION_UNSET         1\n\n/* Graceful Restart */\n#define RESTART_R_BIT              0x8000\n#define RESTART_F_BIT              0x80\n\nextern int bgp_open_option_parse (struct peer *, u_char, int *);\nextern void bgp_open_capability (struct stream *, struct peer *);\nextern void bgp_capability_vty_out (struct vty *, struct peer *);\n\n#endif /* _QUAGGA_BGP_OPEN_H */\n", "/* BGP packet management routine.\n   Copyright (C) 1999 Kunihiro Ishiguro\n\nThis file is part of GNU Zebra.\n\nGNU Zebra is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the\nFree Software Foundation; either version 2, or (at your option) any\nlater version.\n\nGNU Zebra is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GNU Zebra; see the file COPYING.  If not, write to the Free\nSoftware Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#include <zebra.h>\n\n#include \"thread.h\"\n#include \"stream.h\"\n#include \"network.h\"\n#include \"prefix.h\"\n#include \"command.h\"\n#include \"log.h\"\n#include \"memory.h\"\n#include \"sockunion.h\"\t\t/* for inet_ntop () */\n#include \"linklist.h\"\n#include \"plist.h\"\n\n#include \"bgpd/bgpd.h\"\n#include \"bgpd/bgp_table.h\"\n#include \"bgpd/bgp_dump.h\"\n#include \"bgpd/bgp_attr.h\"\n#include \"bgpd/bgp_debug.h\"\n#include \"bgpd/bgp_fsm.h\"\n#include \"bgpd/bgp_route.h\"\n#include \"bgpd/bgp_packet.h\"\n#include \"bgpd/bgp_open.h\"\n#include \"bgpd/bgp_aspath.h\"\n#include \"bgpd/bgp_community.h\"\n#include \"bgpd/bgp_ecommunity.h\"\n#include \"bgpd/bgp_network.h\"\n#include \"bgpd/bgp_mplsvpn.h\"\n#include \"bgpd/bgp_advertise.h\"\n#include \"bgpd/bgp_vty.h\"\n\nint stream_put_prefix (struct stream *, struct prefix *);\n\f\n/* Set up BGP packet marker and packet type. */\nstatic int\nbgp_packet_set_marker (struct stream *s, u_char type)\n{\n  int i;\n\n  /* Fill in marker. */\n  for (i = 0; i < BGP_MARKER_SIZE; i++)\n    stream_putc (s, 0xff);\n\n  /* Dummy total length. This field is should be filled in later on. */\n  stream_putw (s, 0);\n\n  /* BGP packet type. */\n  stream_putc (s, type);\n\n  /* Return current stream size. */\n  return stream_get_endp (s);\n}\n\n/* Set BGP packet header size entry.  If size is zero then use current\n   stream size. */\nstatic int\nbgp_packet_set_size (struct stream *s)\n{\n  int cp;\n\n  /* Preserve current pointer. */\n  cp = stream_get_endp (s);\n  stream_putw_at (s, BGP_MARKER_SIZE, cp);\n\n  return cp;\n}\n\n/* Add new packet to the peer. */\nstatic void\nbgp_packet_add (struct peer *peer, struct stream *s)\n{\n  /* Add packet to the end of list. */\n  stream_fifo_push (peer->obuf, s);\n}\n\n/* Free first packet. */\nstatic void\nbgp_packet_delete (struct peer *peer)\n{\n  stream_free (stream_fifo_pop (peer->obuf));\n}\n\n/* Check file descriptor whether connect is established. */\nstatic void\nbgp_connect_check (struct peer *peer)\n{\n  int status;\n  socklen_t slen;\n  int ret;\n\n  /* Anyway I have to reset read and write thread. */\n  BGP_READ_OFF (peer->t_read);\n  BGP_WRITE_OFF (peer->t_write);\n\n  /* Check file descriptor. */\n  slen = sizeof (status);\n  ret = getsockopt(peer->fd, SOL_SOCKET, SO_ERROR, (void *) &status, &slen);\n\n  /* If getsockopt is fail, this is fatal error. */\n  if (ret < 0)\n    {\n      zlog (peer->log, LOG_INFO, \"can't get sockopt for nonblocking connect\");\n      BGP_EVENT_ADD (peer, TCP_fatal_error);\n      return;\n    }      \n\n  /* When status is 0 then TCP connection is established. */\n  if (status == 0)\n    {\n      BGP_EVENT_ADD (peer, TCP_connection_open);\n    }\n  else\n    {\n      if (BGP_DEBUG (events, EVENTS))\n\t  plog_debug (peer->log, \"%s [Event] Connect failed (%s)\",\n\t\t     peer->host, safe_strerror (errno));\n      BGP_EVENT_ADD (peer, TCP_connection_open_failed);\n    }\n}\n\n/* Make BGP update packet.  */\nstatic struct stream *\nbgp_update_packet (struct peer *peer, afi_t afi, safi_t safi)\n{\n  struct stream *s;\n  struct bgp_adj_out *adj;\n  struct bgp_advertise *adv;\n  struct stream *packet;\n  struct bgp_node *rn = NULL;\n  struct bgp_info *binfo = NULL;\n  bgp_size_t total_attr_len = 0;\n  unsigned long pos;\n  char buf[BUFSIZ];\n\n  s = peer->work;\n  stream_reset (s);\n\n  adv = FIFO_HEAD (&peer->sync[afi][safi]->update);\n\n  while (adv)\n    {\n      assert (adv->rn);\n      rn = adv->rn;\n      adj = adv->adj;\n      if (adv->binfo)\n        binfo = adv->binfo;\n\n      /* When remaining space can't include NLRI and it's length.  */\n      if (STREAM_REMAIN (s) <= BGP_NLRI_LENGTH + PSIZE (rn->p.prefixlen))\n\tbreak;\n\n      /* If packet is empty, set attribute. */\n      if (stream_empty (s))\n\t{\n\t  struct prefix_rd *prd = NULL;\n\t  u_char *tag = NULL;\n\t  struct peer *from = NULL;\n\t  \n\t  if (rn->prn)\n\t    prd = (struct prefix_rd *) &rn->prn->p;\n          if (binfo && binfo->extra)\n            {\n              tag = binfo->extra->tag;\n              from = binfo->peer;\n            }\n          \n\t  bgp_packet_set_marker (s, BGP_MSG_UPDATE);\n\t  stream_putw (s, 0);\t\t\n\t  pos = stream_get_endp (s);\n\t  stream_putw (s, 0);\n\t  total_attr_len = bgp_packet_attribute (NULL, peer, s, \n\t                                         adv->baa->attr,\n\t                                         &rn->p, afi, safi, \n\t                                         from, prd, tag);\n\t  stream_putw_at (s, pos, total_attr_len);\n\t}\n\n      if (afi == AFI_IP && safi == SAFI_UNICAST)\n\tstream_put_prefix (s, &rn->p);\n      \n      if (BGP_DEBUG (update, UPDATE_OUT))\n\tzlog (peer->log, LOG_DEBUG, \"%s send UPDATE %s/%d\",\n\t      peer->host,\n\t      inet_ntop (rn->p.family, &(rn->p.u.prefix), buf, BUFSIZ),\n\t      rn->p.prefixlen);\n\n      /* Synchnorize attribute.  */\n      if (adj->attr)\n\tbgp_attr_unintern (adj->attr);\n      else\n\tpeer->scount[afi][safi]++;\n\n      adj->attr = bgp_attr_intern (adv->baa->attr);\n\n      adv = bgp_advertise_clean (peer, adj, afi, safi);\n\n      if (! (afi == AFI_IP && safi == SAFI_UNICAST))\n\tbreak;\n    }\n\t \n  if (! stream_empty (s))\n    {\n      bgp_packet_set_size (s);\n      packet = stream_dup (s);\n      bgp_packet_add (peer, packet);\n      BGP_WRITE_ON (peer->t_write, bgp_write, peer->fd);\n      stream_reset (s);\n      return packet;\n    }\n  return NULL;\n}\n\nstatic struct stream *\nbgp_update_packet_eor (struct peer *peer, afi_t afi, safi_t safi)\n{\n  struct stream *s;\n  struct stream *packet;\n\n#ifdef DISABLE_BGP_ANNOUNCE\n  return;\n#endif /* DISABLE_BGP_ANNOUNCE */\n\n  if (BGP_DEBUG (normal, NORMAL))\n    zlog_debug (\"send End-of-RIB for %s to %s\", afi_safi_print (afi, safi), peer->host);\n\n  s = stream_new (BGP_MAX_PACKET_SIZE);\n\n  /* Make BGP update packet. */\n  bgp_packet_set_marker (s, BGP_MSG_UPDATE);\n\n  /* Unfeasible Routes Length */\n  stream_putw (s, 0);\n\n  if (afi == AFI_IP && safi == SAFI_UNICAST)\n    {\n      /* Total Path Attribute Length */\n      stream_putw (s, 0);\n    }\n  else\n    {\n      /* Total Path Attribute Length */\n      stream_putw (s, 6);\n      stream_putc (s, BGP_ATTR_FLAG_OPTIONAL);\n      stream_putc (s, BGP_ATTR_MP_UNREACH_NLRI);\n      stream_putc (s, 3);\n      stream_putw (s, afi);\n      stream_putc (s, safi);\n    }\n\n  bgp_packet_set_size (s);\n  packet = stream_dup (s);\n  bgp_packet_add (peer, packet);\n  stream_free (s);\n  return packet;\n}\n\n/* Make BGP withdraw packet.  */\nstatic struct stream *\nbgp_withdraw_packet (struct peer *peer, afi_t afi, safi_t safi)\n{\n  struct stream *s;\n  struct stream *packet;\n  struct bgp_adj_out *adj;\n  struct bgp_advertise *adv;\n  struct bgp_node *rn;\n  unsigned long pos;\n  bgp_size_t unfeasible_len;\n  bgp_size_t total_attr_len;\n  char buf[BUFSIZ];\n\n  s = peer->work;\n  stream_reset (s);\n\n  while ((adv = FIFO_HEAD (&peer->sync[afi][safi]->withdraw)) != NULL)\n    {\n      assert (adv->rn);\n      adj = adv->adj;\n      rn = adv->rn;\n\n      if (STREAM_REMAIN (s) \n\t  < (BGP_NLRI_LENGTH + BGP_TOTAL_ATTR_LEN + PSIZE (rn->p.prefixlen)))\n\tbreak;\n\n      if (stream_empty (s))\n\t{\n\t  bgp_packet_set_marker (s, BGP_MSG_UPDATE);\n\t  stream_putw (s, 0);\n\t}\n\n      if (afi == AFI_IP && safi == SAFI_UNICAST)\n\tstream_put_prefix (s, &rn->p);\n      else\n\t{\n\t  struct prefix_rd *prd = NULL;\n\t  \n\t  if (rn->prn)\n\t    prd = (struct prefix_rd *) &rn->prn->p;\n\t  pos = stream_get_endp (s);\n\t  stream_putw (s, 0);\n\t  total_attr_len\n\t    = bgp_packet_withdraw (peer, s, &rn->p, afi, safi, prd, NULL);\n      \n\t  /* Set total path attribute length. */\n\t  stream_putw_at (s, pos, total_attr_len);\n\t}\n\n      if (BGP_DEBUG (update, UPDATE_OUT))\n\tzlog (peer->log, LOG_DEBUG, \"%s send UPDATE %s/%d -- unreachable\",\n\t      peer->host,\n\t      inet_ntop (rn->p.family, &(rn->p.u.prefix), buf, BUFSIZ),\n\t      rn->p.prefixlen);\n\n      peer->scount[afi][safi]--;\n\n      bgp_adj_out_remove (rn, adj, peer, afi, safi);\n      bgp_unlock_node (rn);\n\n      if (! (afi == AFI_IP && safi == SAFI_UNICAST))\n\tbreak;\n    }\n\n  if (! stream_empty (s))\n    {\n      if (afi == AFI_IP && safi == SAFI_UNICAST)\n\t{\n\t  unfeasible_len \n\t    = stream_get_endp (s) - BGP_HEADER_SIZE - BGP_UNFEASIBLE_LEN;\n\t  stream_putw_at (s, BGP_HEADER_SIZE, unfeasible_len);\n\t  stream_putw (s, 0);\n\t}\n      bgp_packet_set_size (s);\n      packet = stream_dup (s);\n      bgp_packet_add (peer, packet);\n      stream_reset (s);\n      return packet;\n    }\n\n  return NULL;\n}\n\nvoid\nbgp_default_update_send (struct peer *peer, struct attr *attr,\n\t\t\t afi_t afi, safi_t safi, struct peer *from)\n{\n  struct stream *s;\n  struct stream *packet;\n  struct prefix p;\n  unsigned long pos;\n  bgp_size_t total_attr_len;\n  char attrstr[BUFSIZ];\n  char buf[BUFSIZ];\n\n#ifdef DISABLE_BGP_ANNOUNCE\n  return;\n#endif /* DISABLE_BGP_ANNOUNCE */\n\n  if (afi == AFI_IP)\n    str2prefix (\"0.0.0.0/0\", &p);\n#ifdef HAVE_IPV6\n  else \n    str2prefix (\"::/0\", &p);\n#endif /* HAVE_IPV6 */\n\n  /* Logging the attribute. */\n  if (BGP_DEBUG (update, UPDATE_OUT))\n    {\n      bgp_dump_attr (peer, attr, attrstr, BUFSIZ);\n      zlog (peer->log, LOG_DEBUG, \"%s send UPDATE %s/%d %s\",\n\t    peer->host, inet_ntop(p.family, &(p.u.prefix), buf, BUFSIZ),\n\t    p.prefixlen, attrstr);\n    }\n\n  s = stream_new (BGP_MAX_PACKET_SIZE);\n\n  /* Make BGP update packet. */\n  bgp_packet_set_marker (s, BGP_MSG_UPDATE);\n\n  /* Unfeasible Routes Length. */\n  stream_putw (s, 0);\n\n  /* Make place for total attribute length.  */\n  pos = stream_get_endp (s);\n  stream_putw (s, 0);\n  total_attr_len = bgp_packet_attribute (NULL, peer, s, attr, &p, afi, safi, from, NULL, NULL);\n\n  /* Set Total Path Attribute Length. */\n  stream_putw_at (s, pos, total_attr_len);\n\n  /* NLRI set. */\n  if (p.family == AF_INET && safi == SAFI_UNICAST)\n    stream_put_prefix (s, &p);\n\n  /* Set size. */\n  bgp_packet_set_size (s);\n\n  packet = stream_dup (s);\n  stream_free (s);\n\n  /* Dump packet if debug option is set. */\n#ifdef DEBUG\n  /* bgp_packet_dump (packet); */\n#endif /* DEBUG */\n\n  /* Add packet to the peer. */\n  bgp_packet_add (peer, packet);\n\n  BGP_WRITE_ON (peer->t_write, bgp_write, peer->fd);\n}\n\nvoid\nbgp_default_withdraw_send (struct peer *peer, afi_t afi, safi_t safi)\n{\n  struct stream *s;\n  struct stream *packet;\n  struct prefix p;\n  unsigned long pos;\n  unsigned long cp;\n  bgp_size_t unfeasible_len;\n  bgp_size_t total_attr_len;\n  char buf[BUFSIZ];\n\n#ifdef DISABLE_BGP_ANNOUNCE\n  return;\n#endif /* DISABLE_BGP_ANNOUNCE */\n\n  if (afi == AFI_IP)\n    str2prefix (\"0.0.0.0/0\", &p);\n#ifdef HAVE_IPV6\n  else \n    str2prefix (\"::/0\", &p);\n#endif /* HAVE_IPV6 */\n\n  total_attr_len = 0;\n  pos = 0;\n\n  if (BGP_DEBUG (update, UPDATE_OUT))\n    zlog (peer->log, LOG_DEBUG, \"%s send UPDATE %s/%d -- unreachable\",\n          peer->host, inet_ntop(p.family, &(p.u.prefix), buf, BUFSIZ),\n          p.prefixlen);\n\n  s = stream_new (BGP_MAX_PACKET_SIZE);\n\n  /* Make BGP update packet. */\n  bgp_packet_set_marker (s, BGP_MSG_UPDATE);\n\n  /* Unfeasible Routes Length. */;\n  cp = stream_get_endp (s);\n  stream_putw (s, 0);\n\n  /* Withdrawn Routes. */\n  if (p.family == AF_INET && safi == SAFI_UNICAST)\n    {\n      stream_put_prefix (s, &p);\n\n      unfeasible_len = stream_get_endp (s) - cp - 2;\n\n      /* Set unfeasible len.  */\n      stream_putw_at (s, cp, unfeasible_len);\n\n      /* Set total path attribute length. */\n      stream_putw (s, 0);\n    }\n  else\n    {\n      pos = stream_get_endp (s);\n      stream_putw (s, 0);\n      total_attr_len = bgp_packet_withdraw (peer, s, &p, afi, safi, NULL, NULL);\n\n      /* Set total path attribute length. */\n      stream_putw_at (s, pos, total_attr_len);\n    }\n\n  bgp_packet_set_size (s);\n\n  packet = stream_dup (s);\n  stream_free (s);\n\n  /* Add packet to the peer. */\n  bgp_packet_add (peer, packet);\n\n  BGP_WRITE_ON (peer->t_write, bgp_write, peer->fd);\n}\n\n/* Get next packet to be written.  */\nstatic struct stream *\nbgp_write_packet (struct peer *peer)\n{\n  afi_t afi;\n  safi_t safi;\n  struct stream *s = NULL;\n  struct bgp_advertise *adv;\n\n  s = stream_fifo_head (peer->obuf);\n  if (s)\n    return s;\n\n  for (afi = AFI_IP; afi < AFI_MAX; afi++)\n    for (safi = SAFI_UNICAST; safi < SAFI_MAX; safi++)\n      {\n\tadv = FIFO_HEAD (&peer->sync[afi][safi]->withdraw);\n\tif (adv)\n\t  {\n\t    s = bgp_withdraw_packet (peer, afi, safi);\n\t    if (s)\n\t      return s;\n\t  }\n      }\n    \n  for (afi = AFI_IP; afi < AFI_MAX; afi++)\n    for (safi = SAFI_UNICAST; safi < SAFI_MAX; safi++)\n      {\n\tadv = FIFO_HEAD (&peer->sync[afi][safi]->update);\n\tif (adv)\n\t  {\n            if (adv->binfo && adv->binfo->uptime < peer->synctime)\n\t      {\n\t\tif (CHECK_FLAG (adv->binfo->peer->cap, PEER_CAP_RESTART_RCV)\n\t\t    && CHECK_FLAG (adv->binfo->peer->cap, PEER_CAP_RESTART_ADV)\n\t\t    && ! CHECK_FLAG (adv->binfo->flags, BGP_INFO_STALE)\n\t\t    && safi != SAFI_MPLS_VPN)\n\t\t  {\n\t\t    if (CHECK_FLAG (adv->binfo->peer->af_sflags[afi][safi],\n\t\t\tPEER_STATUS_EOR_RECEIVED))\n\t\t      s = bgp_update_packet (peer, afi, safi);\n\t\t  }\n\t\telse\n\t\t  s = bgp_update_packet (peer, afi, safi);\n\t      }\n\n\t    if (s)\n\t      return s;\n\t  }\n\n\tif (CHECK_FLAG (peer->cap, PEER_CAP_RESTART_RCV))\n\t  {\n\t    if (peer->afc_nego[afi][safi] && peer->synctime\n\t\t&& ! CHECK_FLAG (peer->af_sflags[afi][safi], PEER_STATUS_EOR_SEND)\n\t\t&& safi != SAFI_MPLS_VPN)\n\t      {\n\t\tSET_FLAG (peer->af_sflags[afi][safi], PEER_STATUS_EOR_SEND);\n\t\treturn bgp_update_packet_eor (peer, afi, safi);\n\t      }\n\t  }\n      }\n\n  return NULL;\n}\n\n/* Is there partially written packet or updates we can send right\n   now.  */\nstatic int\nbgp_write_proceed (struct peer *peer)\n{\n  afi_t afi;\n  safi_t safi;\n  struct bgp_advertise *adv;\n\n  if (stream_fifo_head (peer->obuf))\n    return 1;\n\n  for (afi = AFI_IP; afi < AFI_MAX; afi++)\n    for (safi = SAFI_UNICAST; safi < SAFI_MAX; safi++)\n      if (FIFO_HEAD (&peer->sync[afi][safi]->withdraw))\n\treturn 1;\n\n  for (afi = AFI_IP; afi < AFI_MAX; afi++)\n    for (safi = SAFI_UNICAST; safi < SAFI_MAX; safi++)\n      if ((adv = FIFO_HEAD (&peer->sync[afi][safi]->update)) != NULL)\n\tif (adv->binfo->uptime < peer->synctime)\n\t  return 1;\n\n  return 0;\n}\n\n/* Write packet to the peer. */\nint\nbgp_write (struct thread *thread)\n{\n  struct peer *peer;\n  u_char type;\n  struct stream *s; \n  int num;\n  unsigned int count = 0;\n  int write_errno;\n\n  /* Yes first of all get peer pointer. */\n  peer = THREAD_ARG (thread);\n  peer->t_write = NULL;\n\n  /* For non-blocking IO check. */\n  if (peer->status == Connect)\n    {\n      bgp_connect_check (peer);\n      return 0;\n    }\n\n    /* Nonblocking write until TCP output buffer is full.  */\n  while (1)\n    {\n      int writenum;\n      int val;\n\n      s = bgp_write_packet (peer);\n      if (! s)\n\treturn 0;\n      \n      /* XXX: FIXME, the socket should be NONBLOCK from the start\n       * status shouldnt need to be toggled on each write\n       */\n      val = fcntl (peer->fd, F_GETFL, 0);\n      fcntl (peer->fd, F_SETFL, val|O_NONBLOCK);\n\n      /* Number of bytes to be sent.  */\n      writenum = stream_get_endp (s) - stream_get_getp (s);\n\n      /* Call write() system call.  */\n      num = write (peer->fd, STREAM_PNT (s), writenum);\n      write_errno = errno;\n      fcntl (peer->fd, F_SETFL, val);\n      if (num <= 0)\n\t{\n\t  /* Partial write. */\n\t  if (write_errno == EWOULDBLOCK || write_errno == EAGAIN)\n\t      break;\n\n\t  BGP_EVENT_ADD (peer, TCP_fatal_error);\n\t  return 0;\n\t}\n      if (num != writenum)\n\t{\n\t  stream_forward_getp (s, num);\n\n\t  if (write_errno == EAGAIN)\n\t    break;\n\n\t  continue;\n\t}\n\n      /* Retrieve BGP packet type. */\n      stream_set_getp (s, BGP_MARKER_SIZE + 2);\n      type = stream_getc (s);\n\n      switch (type)\n\t{\n\tcase BGP_MSG_OPEN:\n\t  peer->open_out++;\n\t  break;\n\tcase BGP_MSG_UPDATE:\n\t  peer->update_out++;\n\t  break;\n\tcase BGP_MSG_NOTIFY:\n\t  peer->notify_out++;\n\t  /* Double start timer. */\n\t  peer->v_start *= 2;\n\n\t  /* Overflow check. */\n\t  if (peer->v_start >= (60 * 2))\n\t    peer->v_start = (60 * 2);\n\n\t  /* Flush any existing events */\n\t  BGP_EVENT_ADD (peer, BGP_Stop);\n\t  return 0;\n\tcase BGP_MSG_KEEPALIVE:\n\t  peer->keepalive_out++;\n\t  break;\n\tcase BGP_MSG_ROUTE_REFRESH_NEW:\n\tcase BGP_MSG_ROUTE_REFRESH_OLD:\n\t  peer->refresh_out++;\n\t  break;\n\tcase BGP_MSG_CAPABILITY:\n\t  peer->dynamic_cap_out++;\n\t  break;\n\t}\n\n      /* OK we send packet so delete it. */\n      bgp_packet_delete (peer);\n\n      if (++count >= BGP_WRITE_PACKET_MAX)\n\tbreak;\n    }\n  \n  if (bgp_write_proceed (peer))\n    BGP_WRITE_ON (peer->t_write, bgp_write, peer->fd);\n  \n  return 0;\n}\n\n/* This is only for sending NOTIFICATION message to neighbor. */\nstatic int\nbgp_write_notify (struct peer *peer)\n{\n  int ret;\n  u_char type;\n  struct stream *s; \n\n  /* There should be at least one packet. */\n  s = stream_fifo_head (peer->obuf);\n  if (!s)\n    return 0;\n  assert (stream_get_endp (s) >= BGP_HEADER_SIZE);\n\n  /* I'm not sure fd is writable. */\n  ret = writen (peer->fd, STREAM_DATA (s), stream_get_endp (s));\n  if (ret <= 0)\n    {\n      BGP_EVENT_ADD (peer, TCP_fatal_error);\n      return 0;\n    }\n\n  /* Retrieve BGP packet type. */\n  stream_set_getp (s, BGP_MARKER_SIZE + 2);\n  type = stream_getc (s);\n\n  assert (type == BGP_MSG_NOTIFY);\n\n  /* Type should be notify. */\n  peer->notify_out++;\n\n  /* Double start timer. */\n  peer->v_start *= 2;\n\n  /* Overflow check. */\n  if (peer->v_start >= (60 * 2))\n    peer->v_start = (60 * 2);\n\n  BGP_EVENT_ADD (peer, BGP_Stop);\n\n  return 0;\n}\n\n/* Make keepalive packet and send it to the peer. */\nvoid\nbgp_keepalive_send (struct peer *peer)\n{\n  struct stream *s;\n  int length;\n\n  s = stream_new (BGP_MAX_PACKET_SIZE);\n\n  /* Make keepalive packet. */\n  bgp_packet_set_marker (s, BGP_MSG_KEEPALIVE);\n\n  /* Set packet size. */\n  length = bgp_packet_set_size (s);\n\n  /* Dump packet if debug option is set. */\n  /* bgp_packet_dump (s); */\n \n  if (BGP_DEBUG (keepalive, KEEPALIVE))  \n    zlog_debug (\"%s sending KEEPALIVE\", peer->host); \n  if (BGP_DEBUG (normal, NORMAL))\n    zlog_debug (\"%s send message type %d, length (incl. header) %d\",\n               peer->host, BGP_MSG_KEEPALIVE, length);\n\n  /* Add packet to the peer. */\n  bgp_packet_add (peer, s);\n\n  BGP_WRITE_ON (peer->t_write, bgp_write, peer->fd);\n}\n\n/* Make open packet and send it to the peer. */\nvoid\nbgp_open_send (struct peer *peer)\n{\n  struct stream *s;\n  int length;\n  u_int16_t send_holdtime;\n  as_t local_as;\n\n  if (CHECK_FLAG (peer->config, PEER_CONFIG_TIMER))\n    send_holdtime = peer->holdtime;\n  else\n    send_holdtime = peer->bgp->default_holdtime;\n\n  /* local-as Change */\n  if (peer->change_local_as)\n    local_as = peer->change_local_as; \n  else\n    local_as = peer->local_as; \n\n  s = stream_new (BGP_MAX_PACKET_SIZE);\n\n  /* Make open packet. */\n  bgp_packet_set_marker (s, BGP_MSG_OPEN);\n\n  /* Set open packet values. */\n  stream_putc (s, BGP_VERSION_4);        /* BGP version */\n  stream_putw (s, local_as);\t\t /* My Autonomous System*/\n  stream_putw (s, send_holdtime);     \t /* Hold Time */\n  stream_put_in_addr (s, &peer->local_id); /* BGP Identifier */\n\n  /* Set capability code. */\n  bgp_open_capability (s, peer);\n\n  /* Set BGP packet length. */\n  length = bgp_packet_set_size (s);\n\n  if (BGP_DEBUG (normal, NORMAL))\n    zlog_debug (\"%s sending OPEN, version %d, my as %d, holdtime %d, id %s\", \n\t       peer->host, BGP_VERSION_4, local_as,\n\t       send_holdtime, inet_ntoa (peer->local_id));\n\n  if (BGP_DEBUG (normal, NORMAL))\n    zlog_debug (\"%s send message type %d, length (incl. header) %d\",\n\t       peer->host, BGP_MSG_OPEN, length);\n\n  /* Dump packet if debug option is set. */\n  /* bgp_packet_dump (s); */\n\n  /* Add packet to the peer. */\n  bgp_packet_add (peer, s);\n\n  BGP_WRITE_ON (peer->t_write, bgp_write, peer->fd);\n}\n\n/* Send BGP notify packet with data potion. */\nvoid\nbgp_notify_send_with_data (struct peer *peer, u_char code, u_char sub_code,\n\t\t\t   u_char *data, size_t datalen)\n{\n  struct stream *s;\n  int length;\n\n  /* Allocate new stream. */\n  s = stream_new (BGP_MAX_PACKET_SIZE);\n\n  /* Make nitify packet. */\n  bgp_packet_set_marker (s, BGP_MSG_NOTIFY);\n\n  /* Set notify packet values. */\n  stream_putc (s, code);        /* BGP notify code */\n  stream_putc (s, sub_code);\t/* BGP notify sub_code */\n\n  /* If notify data is present. */\n  if (data)\n    stream_write (s, data, datalen);\n  \n  /* Set BGP packet length. */\n  length = bgp_packet_set_size (s);\n  \n  /* Add packet to the peer. */\n  stream_fifo_clean (peer->obuf);\n  bgp_packet_add (peer, s);\n\n  /* For debug */\n  {\n    struct bgp_notify bgp_notify;\n    int first = 0;\n    int i;\n    char c[4];\n\n    bgp_notify.code = code;\n    bgp_notify.subcode = sub_code;\n    bgp_notify.data = NULL;\n    bgp_notify.length = length - BGP_MSG_NOTIFY_MIN_SIZE;\n    \n    if (bgp_notify.length)\n      {\n\tbgp_notify.data = XMALLOC (MTYPE_TMP, bgp_notify.length * 3);\n\tfor (i = 0; i < bgp_notify.length; i++)\n\t  if (first)\n\t    {\n\t      sprintf (c, \" %02x\", data[i]);\n\t      strcat (bgp_notify.data, c);\n\t    }\n\t  else\n\t    {\n\t      first = 1;\n\t      sprintf (c, \"%02x\", data[i]);\n\t      strcpy (bgp_notify.data, c);\n\t    }\n      }\n    bgp_notify_print (peer, &bgp_notify, \"sending\");\n    if (bgp_notify.data)\n      XFREE (MTYPE_TMP, bgp_notify.data);\n  }\n\n  if (BGP_DEBUG (normal, NORMAL))\n    zlog_debug (\"%s send message type %d, length (incl. header) %d\",\n\t       peer->host, BGP_MSG_NOTIFY, length);\n\n  /* peer reset cause */\n  if (sub_code != BGP_NOTIFY_CEASE_CONFIG_CHANGE)\n    {\n      if (sub_code == BGP_NOTIFY_CEASE_ADMIN_RESET)\n      peer->last_reset = PEER_DOWN_USER_RESET;\n      else if (sub_code == BGP_NOTIFY_CEASE_ADMIN_SHUTDOWN)\n      peer->last_reset = PEER_DOWN_USER_SHUTDOWN;\n      else\n      peer->last_reset = PEER_DOWN_NOTIFY_SEND;\n    }\n\n  /* Call imidiately. */\n  BGP_WRITE_OFF (peer->t_write);\n\n  bgp_write_notify (peer);\n}\n\n/* Send BGP notify packet. */\nvoid\nbgp_notify_send (struct peer *peer, u_char code, u_char sub_code)\n{\n  bgp_notify_send_with_data (peer, code, sub_code, NULL, 0);\n}\n\nstatic const char *\nafi2str (afi_t afi)\n{\n  if (afi == AFI_IP)\n    return \"AFI_IP\";\n  else if (afi == AFI_IP6)\n    return \"AFI_IP6\";\n  else\n    return \"Unknown AFI\";\n}\n\nstatic const char *\nsafi2str (safi_t safi)\n{\n  if (safi == SAFI_UNICAST)\n    return \"SAFI_UNICAST\";\n  else if (safi == SAFI_MULTICAST)\n    return \"SAFI_MULTICAST\";\n  else if (safi == SAFI_MPLS_VPN || safi == BGP_SAFI_VPNV4)\n    return \"SAFI_MPLS_VPN\";\n  else\n    return \"Unknown SAFI\";\n}\n\n/* Send route refresh message to the peer. */\nvoid\nbgp_route_refresh_send (struct peer *peer, afi_t afi, safi_t safi,\n\t\t\tu_char orf_type, u_char when_to_refresh, int remove)\n{\n  struct stream *s;\n  struct stream *packet;\n  int length;\n  struct bgp_filter *filter;\n  int orf_refresh = 0;\n\n#ifdef DISABLE_BGP_ANNOUNCE\n  return;\n#endif /* DISABLE_BGP_ANNOUNCE */\n\n  filter = &peer->filter[afi][safi];\n\n  /* Adjust safi code. */\n  if (safi == SAFI_MPLS_VPN)\n    safi = BGP_SAFI_VPNV4;\n  \n  s = stream_new (BGP_MAX_PACKET_SIZE);\n\n  /* Make BGP update packet. */\n  if (CHECK_FLAG (peer->cap, PEER_CAP_REFRESH_NEW_RCV))\n    bgp_packet_set_marker (s, BGP_MSG_ROUTE_REFRESH_NEW);\n  else\n    bgp_packet_set_marker (s, BGP_MSG_ROUTE_REFRESH_OLD);\n\n  /* Encode Route Refresh message. */\n  stream_putw (s, afi);\n  stream_putc (s, 0);\n  stream_putc (s, safi);\n \n  if (orf_type == ORF_TYPE_PREFIX\n      || orf_type == ORF_TYPE_PREFIX_OLD)\n    if (remove || filter->plist[FILTER_IN].plist)\n      {\n\tu_int16_t orf_len;\n\tunsigned long orfp;\n\n\torf_refresh = 1; \n\tstream_putc (s, when_to_refresh);\n\tstream_putc (s, orf_type);\n\torfp = stream_get_endp (s);\n\tstream_putw (s, 0);\n\n\tif (remove)\n\t  {\n\t    UNSET_FLAG (peer->af_sflags[afi][safi], PEER_STATUS_ORF_PREFIX_SEND);\n\t    stream_putc (s, ORF_COMMON_PART_REMOVE_ALL);\n\t    if (BGP_DEBUG (normal, NORMAL))\n\t      zlog_debug (\"%s sending REFRESH_REQ to remove ORF(%d) (%s) for afi/safi: %d/%d\", \n\t\t\t peer->host, orf_type,\n\t\t\t (when_to_refresh == REFRESH_DEFER ? \"defer\" : \"immediate\"),\n\t\t\t afi, safi);\n\t  }\n\telse\n\t  {\n\t    SET_FLAG (peer->af_sflags[afi][safi], PEER_STATUS_ORF_PREFIX_SEND);\n\t    prefix_bgp_orf_entry (s, filter->plist[FILTER_IN].plist,\n\t\t\t\t  ORF_COMMON_PART_ADD, ORF_COMMON_PART_PERMIT,\n\t\t\t\t  ORF_COMMON_PART_DENY);\n\t    if (BGP_DEBUG (normal, NORMAL))\n\t      zlog_debug (\"%s sending REFRESH_REQ with pfxlist ORF(%d) (%s) for afi/safi: %d/%d\", \n\t\t\t peer->host, orf_type,\n\t\t\t (when_to_refresh == REFRESH_DEFER ? \"defer\" : \"immediate\"),\n\t\t\t afi, safi);\n\t  }\n\n\t/* Total ORF Entry Len. */\n\torf_len = stream_get_endp (s) - orfp - 2;\n\tstream_putw_at (s, orfp, orf_len);\n      }\n\n  /* Set packet size. */\n  length = bgp_packet_set_size (s);\n\n  if (BGP_DEBUG (normal, NORMAL))\n    {\n      if (! orf_refresh)\n\tzlog_debug (\"%s sending REFRESH_REQ for afi/safi: %d/%d\", \n\t\t   peer->host, afi, safi);\n      zlog_debug (\"%s send message type %d, length (incl. header) %d\",\n\t\t peer->host, CHECK_FLAG (peer->cap, PEER_CAP_REFRESH_NEW_RCV) ?\n\t\t BGP_MSG_ROUTE_REFRESH_NEW : BGP_MSG_ROUTE_REFRESH_OLD, length);\n    }\n\n  /* Make real packet. */\n  packet = stream_dup (s);\n  stream_free (s);\n\n  /* Add packet to the peer. */\n  bgp_packet_add (peer, packet);\n\n  BGP_WRITE_ON (peer->t_write, bgp_write, peer->fd);\n}\n\n/* Send capability message to the peer. */\nvoid\nbgp_capability_send (struct peer *peer, afi_t afi, safi_t safi,\n\t\t     int capability_code, int action)\n{\n  struct stream *s;\n  struct stream *packet;\n  int length;\n\n  /* Adjust safi code. */\n  if (safi == SAFI_MPLS_VPN)\n    safi = BGP_SAFI_VPNV4;\n\n  s = stream_new (BGP_MAX_PACKET_SIZE);\n\n  /* Make BGP update packet. */\n  bgp_packet_set_marker (s, BGP_MSG_CAPABILITY);\n\n  /* Encode MP_EXT capability. */\n  if (capability_code == CAPABILITY_CODE_MP)\n    {\n      stream_putc (s, action);\n      stream_putc (s, CAPABILITY_CODE_MP);\n      stream_putc (s, CAPABILITY_CODE_MP_LEN);\n      stream_putw (s, afi);\n      stream_putc (s, 0);\n      stream_putc (s, safi);\n\n      if (BGP_DEBUG (normal, NORMAL))\n        zlog_debug (\"%s sending CAPABILITY has %s MP_EXT CAP for afi/safi: %d/%d\",\n\t\t   peer->host, action == CAPABILITY_ACTION_SET ?\n\t\t   \"Advertising\" : \"Removing\", afi, safi);\n    }\n\n  /* Set packet size. */\n  length = bgp_packet_set_size (s);\n\n  /* Make real packet. */\n  packet = stream_dup (s);\n  stream_free (s);\n\n  /* Add packet to the peer. */\n  bgp_packet_add (peer, packet);\n\n  if (BGP_DEBUG (normal, NORMAL))\n    zlog_debug (\"%s send message type %d, length (incl. header) %d\",\n\t       peer->host, BGP_MSG_CAPABILITY, length);\n\n  BGP_WRITE_ON (peer->t_write, bgp_write, peer->fd);\n}\n\f\n/* RFC1771 6.8 Connection collision detection. */\nstatic int\nbgp_collision_detect (struct peer *new, struct in_addr remote_id)\n{\n  struct peer *peer;\n  struct listnode *node, *nnode;\n  struct bgp *bgp;\n\n  bgp = bgp_get_default ();\n  if (! bgp)\n    return 0;\n  \n  /* Upon receipt of an OPEN message, the local system must examine\n     all of its connections that are in the OpenConfirm state.  A BGP\n     speaker may also examine connections in an OpenSent state if it\n     knows the BGP Identifier of the peer by means outside of the\n     protocol.  If among these connections there is a connection to a\n     remote BGP speaker whose BGP Identifier equals the one in the\n     OPEN message, then the local system performs the following\n     collision resolution procedure: */\n\n  for (ALL_LIST_ELEMENTS (bgp->peer, node, nnode, peer))\n    {\n      /* Under OpenConfirm status, local peer structure already hold\n         remote router ID. */\n\n      if (peer != new\n\t  && (peer->status == OpenConfirm || peer->status == OpenSent)\n\t  && sockunion_same (&peer->su, &new->su))\n\t{\n\t  /* 1. The BGP Identifier of the local system is compared to\n\t     the BGP Identifier of the remote system (as specified in\n\t     the OPEN message). */\n\n\t  if (ntohl (peer->local_id.s_addr) < ntohl (remote_id.s_addr))\n\t    {\n\t      /* 2. If the value of the local BGP Identifier is less\n\t\t than the remote one, the local system closes BGP\n\t\t connection that already exists (the one that is\n\t\t already in the OpenConfirm state), and accepts BGP\n\t\t connection initiated by the remote system. */\n\n\t      if (peer->fd >= 0)\n\t\tbgp_notify_send (peer, BGP_NOTIFY_CEASE, BGP_NOTIFY_CEASE_COLLISION_RESOLUTION);\n\t      return 1;\n\t    }\n\t  else\n\t    {\n\t      /* 3. Otherwise, the local system closes newly created\n\t\t BGP connection (the one associated with the newly\n\t\t received OPEN message), and continues to use the\n\t\t existing one (the one that is already in the\n\t\t OpenConfirm state). */\n\n\t      if (new->fd >= 0)\n\t\tbgp_notify_send (new, BGP_NOTIFY_CEASE, \n\t\t\t         BGP_NOTIFY_CEASE_COLLISION_RESOLUTION);\n\t      return -1;\n\t    }\n\t}\n    }\n  return 0;\n}\n\nstatic int\nbgp_open_receive (struct peer *peer, bgp_size_t size)\n{\n  int ret;\n  u_char version;\n  u_char optlen;\n  u_int16_t holdtime;\n  u_int16_t send_holdtime;\n  as_t remote_as;\n  struct peer *realpeer;\n  struct in_addr remote_id;\n  int capability;\n  u_int8_t notify_data_remote_as[2];\n  u_int8_t notify_data_remote_id[4];\n\n  realpeer = NULL;\n  \n  /* Parse open packet. */\n  version = stream_getc (peer->ibuf);\n  memcpy (notify_data_remote_as, stream_pnt (peer->ibuf), 2);\n  remote_as  = stream_getw (peer->ibuf);\n  holdtime = stream_getw (peer->ibuf);\n  memcpy (notify_data_remote_id, stream_pnt (peer->ibuf), 4);\n  remote_id.s_addr = stream_get_ipv4 (peer->ibuf);\n\n  /* Receive OPEN message log  */\n  if (BGP_DEBUG (normal, NORMAL))\n    zlog_debug (\"%s rcv OPEN, version %d, remote-as %d, holdtime %d, id %s\",\n\t       peer->host, version, remote_as, holdtime,\n\t       inet_ntoa (remote_id));\n\t  \n  /* Lookup peer from Open packet. */\n  if (CHECK_FLAG (peer->sflags, PEER_STATUS_ACCEPT_PEER))\n    {\n      int as = 0;\n\n      realpeer = peer_lookup_with_open (&peer->su, remote_as, &remote_id, &as);\n\n      if (! realpeer)\n\t{\n\t  /* Peer's source IP address is check in bgp_accept(), so this\n\t     must be AS number mismatch or remote-id configuration\n\t     mismatch. */\n\t  if (as)\n\t    {\n\t      if (BGP_DEBUG (normal, NORMAL))\n\t\tzlog_debug (\"%s bad OPEN, wrong router identifier %s\",\n\t\t\t    peer->host, inet_ntoa (remote_id));\n\t      bgp_notify_send_with_data (peer, BGP_NOTIFY_OPEN_ERR, \n\t\t\t\t\t BGP_NOTIFY_OPEN_BAD_BGP_IDENT,\n\t\t\t\t\t notify_data_remote_id, 4);\n\t    }\n\t  else\n\t    {\n\t      if (BGP_DEBUG (normal, NORMAL))\n\t\tzlog_debug (\"%s bad OPEN, remote AS is %d, expected %d\",\n\t\t\t    peer->host, remote_as, peer->as);\n\t      bgp_notify_send_with_data (peer, BGP_NOTIFY_OPEN_ERR,\n\t\t\t\t\t BGP_NOTIFY_OPEN_BAD_PEER_AS,\n\t\t\t\t\t notify_data_remote_as, 2);\n\t    }\n\t  return -1;\n\t}\n    }\n\n  /* When collision is detected and this peer is closed.  Retrun\n     immidiately. */\n  ret = bgp_collision_detect (peer, remote_id);\n  if (ret < 0)\n    return ret;\n\n  /* Hack part. */\n  if (CHECK_FLAG (peer->sflags, PEER_STATUS_ACCEPT_PEER))\n    {\n\tif (realpeer->status == Established\n\t    && CHECK_FLAG (realpeer->sflags, PEER_STATUS_NSF_MODE))\n\t{\n\t  realpeer->last_reset = PEER_DOWN_NSF_CLOSE_SESSION;\n\t  SET_FLAG (realpeer->sflags, PEER_STATUS_NSF_WAIT);\n\t}\n\telse if (ret == 0 && realpeer->status != Active\n\t         && realpeer->status != OpenSent\n\t\t && realpeer->status != OpenConfirm)\n\n \t{\n \t  if (BGP_DEBUG (events, EVENTS))\n\t    zlog_debug (\"%s peer status is %s close connection\",\n\t\t\trealpeer->host, LOOKUP (bgp_status_msg,\n\t\t\trealpeer->status));\n\t  bgp_notify_send (peer, BGP_NOTIFY_CEASE,\n\t\t\t   BGP_NOTIFY_CEASE_CONNECT_REJECT);\n\n \t  return -1;\n \t}\n\n      if (BGP_DEBUG (events, EVENTS))\n\tzlog_debug (\"%s [Event] Transfer temporary BGP peer to existing one\",\n\t\t   peer->host);\n\n      bgp_stop (realpeer);\n      \n      /* Transfer file descriptor. */\n      realpeer->fd = peer->fd;\n      peer->fd = -1;\n\n      /* Transfer input buffer. */\n      stream_free (realpeer->ibuf);\n      realpeer->ibuf = peer->ibuf;\n      realpeer->packet_size = peer->packet_size;\n      peer->ibuf = NULL;\n\n      /* Transfer status. */\n      realpeer->status = peer->status;\n      bgp_stop (peer);\n      \n      /* peer pointer change. Open packet send to neighbor. */\n      peer = realpeer;\n      bgp_open_send (peer);\n      if (peer->fd < 0)\n\t{\n\t  zlog_err (\"bgp_open_receive peer's fd is negative value %d\",\n\t\t    peer->fd);\n\t  return -1;\n\t}\n      BGP_READ_ON (peer->t_read, bgp_read, peer->fd);\n    }\n\n  /* remote router-id check. */\n  if (remote_id.s_addr == 0\n      || ntohl (remote_id.s_addr) >= 0xe0000000\n      || ntohl (peer->local_id.s_addr) == ntohl (remote_id.s_addr))\n    {\n      if (BGP_DEBUG (normal, NORMAL))\n\tzlog_debug (\"%s bad OPEN, wrong router identifier %s\",\n\t\t   peer->host, inet_ntoa (remote_id));\n      bgp_notify_send_with_data (peer, \n\t\t\t\t BGP_NOTIFY_OPEN_ERR, \n\t\t\t\t BGP_NOTIFY_OPEN_BAD_BGP_IDENT,\n\t\t\t\t notify_data_remote_id, 4);\n      return -1;\n    }\n\n  /* Set remote router-id */\n  peer->remote_id = remote_id;\n\n  /* Peer BGP version check. */\n  if (version != BGP_VERSION_4)\n    {\n      u_int8_t maxver = BGP_VERSION_4;\n      if (BGP_DEBUG (normal, NORMAL))\n\tzlog_debug (\"%s bad protocol version, remote requested %d, local request %d\",\n\t\t   peer->host, version, BGP_VERSION_4);\n      bgp_notify_send_with_data (peer, \n\t\t\t\t BGP_NOTIFY_OPEN_ERR, \n\t\t\t\t BGP_NOTIFY_OPEN_UNSUP_VERSION,\n\t\t\t\t &maxver, 1);\n      return -1;\n    }\n\n  /* Check neighbor as number. */\n  if (remote_as != peer->as)\n    {\n      if (BGP_DEBUG (normal, NORMAL))\n\tzlog_debug (\"%s bad OPEN, remote AS is %d, expected %d\",\n\t\t   peer->host, remote_as, peer->as);\n      bgp_notify_send_with_data (peer, \n\t\t\t\t BGP_NOTIFY_OPEN_ERR, \n\t\t\t\t BGP_NOTIFY_OPEN_BAD_PEER_AS,\n\t\t\t\t notify_data_remote_as, 2);\n      return -1;\n    }\n\n  /* From the rfc: Upon receipt of an OPEN message, a BGP speaker MUST\n     calculate the value of the Hold Timer by using the smaller of its\n     configured Hold Time and the Hold Time received in the OPEN message.\n     The Hold Time MUST be either zero or at least three seconds.  An\n     implementation may reject connections on the basis of the Hold Time. */\n\n  if (holdtime < 3 && holdtime != 0)\n    {\n      bgp_notify_send (peer,\n\t\t       BGP_NOTIFY_OPEN_ERR, \n\t\t       BGP_NOTIFY_OPEN_UNACEP_HOLDTIME);\n      return -1;\n    }\n    \n  /* From the rfc: A reasonable maximum time between KEEPALIVE messages\n     would be one third of the Hold Time interval.  KEEPALIVE messages\n     MUST NOT be sent more frequently than one per second.  An\n     implementation MAY adjust the rate at which it sends KEEPALIVE\n     messages as a function of the Hold Time interval. */\n\n  if (CHECK_FLAG (peer->config, PEER_CONFIG_TIMER))\n    send_holdtime = peer->holdtime;\n  else\n    send_holdtime = peer->bgp->default_holdtime;\n\n  if (holdtime < send_holdtime)\n    peer->v_holdtime = holdtime;\n  else\n    peer->v_holdtime = send_holdtime;\n\n  peer->v_keepalive = peer->v_holdtime / 3;\n\n  /* Open option part parse. */\n  capability = 0;\n  optlen = stream_getc (peer->ibuf);\n  if (optlen != 0) \n    {\n      ret = bgp_open_option_parse (peer, optlen, &capability);\n      if (ret < 0)\n\treturn ret;\n\n      stream_forward_getp (peer->ibuf, optlen);\n    }\n  else\n    {\n      if (BGP_DEBUG (normal, NORMAL))\n\tzlog_debug (\"%s rcvd OPEN w/ OPTION parameter len: 0\",\n\t\t   peer->host);\n    }\n\n  /* Override capability. */\n  if (! capability || CHECK_FLAG (peer->flags, PEER_FLAG_OVERRIDE_CAPABILITY))\n    {\n      peer->afc_nego[AFI_IP][SAFI_UNICAST] = peer->afc[AFI_IP][SAFI_UNICAST];\n      peer->afc_nego[AFI_IP][SAFI_MULTICAST] = peer->afc[AFI_IP][SAFI_MULTICAST];\n      peer->afc_nego[AFI_IP6][SAFI_UNICAST] = peer->afc[AFI_IP6][SAFI_UNICAST];\n      peer->afc_nego[AFI_IP6][SAFI_MULTICAST] = peer->afc[AFI_IP6][SAFI_MULTICAST];\n    }\n\n  /* Get sockname. */\n  bgp_getsockname (peer);\n\n  BGP_EVENT_ADD (peer, Receive_OPEN_message);\n\n  peer->packet_size = 0;\n  if (peer->ibuf)\n    stream_reset (peer->ibuf);\n\n  return 0;\n}\n\n/* Parse BGP Update packet and make attribute object. */\nstatic int\nbgp_update_receive (struct peer *peer, bgp_size_t size)\n{\n  int ret;\n  u_char *end;\n  struct stream *s;\n  struct attr attr;\n  bgp_size_t attribute_len;\n  bgp_size_t update_len;\n  bgp_size_t withdraw_len;\n  struct bgp_nlri update;\n  struct bgp_nlri withdraw;\n  struct bgp_nlri mp_update;\n  struct bgp_nlri mp_withdraw;\n  char attrstr[BUFSIZ] = \"\";\n\n  /* Status must be Established. */\n  if (peer->status != Established) \n    {\n      zlog_err (\"%s [FSM] Update packet received under status %s\",\n\t\tpeer->host, LOOKUP (bgp_status_msg, peer->status));\n      bgp_notify_send (peer, BGP_NOTIFY_FSM_ERR, 0);\n      return -1;\n    }\n\n  /* Set initial values. */\n  memset (&attr, 0, sizeof (struct attr));\n  memset (&update, 0, sizeof (struct bgp_nlri));\n  memset (&withdraw, 0, sizeof (struct bgp_nlri));\n  memset (&mp_update, 0, sizeof (struct bgp_nlri));\n  memset (&mp_withdraw, 0, sizeof (struct bgp_nlri));\n\n  s = peer->ibuf;\n  end = stream_pnt (s) + size;\n\n  /* RFC1771 6.3 If the Unfeasible Routes Length or Total Attribute\n     Length is too large (i.e., if Unfeasible Routes Length + Total\n     Attribute Length + 23 exceeds the message Length), then the Error\n     Subcode is set to Malformed Attribute List.  */\n  if (stream_pnt (s) + 2 > end)\n    {\n      zlog_err (\"%s [Error] Update packet error\"\n\t\t\" (packet length is short for unfeasible length)\",\n\t\tpeer->host);\n      bgp_notify_send (peer, BGP_NOTIFY_UPDATE_ERR, \n\t\t       BGP_NOTIFY_UPDATE_MAL_ATTR);\n      return -1;\n    }\n\n  /* Unfeasible Route Length. */\n  withdraw_len = stream_getw (s);\n\n  /* Unfeasible Route Length check. */\n  if (stream_pnt (s) + withdraw_len > end)\n    {\n      zlog_err (\"%s [Error] Update packet error\"\n\t\t\" (packet unfeasible length overflow %d)\",\n\t\tpeer->host, withdraw_len);\n      bgp_notify_send (peer, BGP_NOTIFY_UPDATE_ERR, \n\t\t       BGP_NOTIFY_UPDATE_MAL_ATTR);\n      return -1;\n    }\n\n  /* Unfeasible Route packet format check. */\n  if (withdraw_len > 0)\n    {\n      ret = bgp_nlri_sanity_check (peer, AFI_IP, stream_pnt (s), withdraw_len);\n      if (ret < 0)\n\treturn -1;\n\n      if (BGP_DEBUG (packet, PACKET_RECV))\n\tzlog_debug (\"%s [Update:RECV] Unfeasible NLRI received\", peer->host);\n\n      withdraw.afi = AFI_IP;\n      withdraw.safi = SAFI_UNICAST;\n      withdraw.nlri = stream_pnt (s);\n      withdraw.length = withdraw_len;\n      stream_forward_getp (s, withdraw_len);\n    }\n  \n  /* Attribute total length check. */\n  if (stream_pnt (s) + 2 > end)\n    {\n      zlog_warn (\"%s [Error] Packet Error\"\n\t\t \" (update packet is short for attribute length)\",\n\t\t peer->host);\n      bgp_notify_send (peer, BGP_NOTIFY_UPDATE_ERR, \n\t\t       BGP_NOTIFY_UPDATE_MAL_ATTR);\n      return -1;\n    }\n\n  /* Fetch attribute total length. */\n  attribute_len = stream_getw (s);\n\n  /* Attribute length check. */\n  if (stream_pnt (s) + attribute_len > end)\n    {\n      zlog_warn (\"%s [Error] Packet Error\"\n\t\t \" (update packet attribute length overflow %d)\",\n\t\t peer->host, attribute_len);\n      bgp_notify_send (peer, BGP_NOTIFY_UPDATE_ERR, \n\t\t       BGP_NOTIFY_UPDATE_MAL_ATTR);\n      return -1;\n    }\n\n  /* Parse attribute when it exists. */\n  if (attribute_len)\n    {\n      ret = bgp_attr_parse (peer, &attr, attribute_len, \n\t\t\t    &mp_update, &mp_withdraw);\n      if (ret < 0)\n\treturn -1;\n    }\n\n  /* Logging the attribute. */\n  if (BGP_DEBUG (update, UPDATE_IN))\n    {\n      ret= bgp_dump_attr (peer, &attr, attrstr, BUFSIZ);\n\n      if (ret)\n\tzlog (peer->log, LOG_DEBUG, \"%s rcvd UPDATE w/ attr: %s\",\n\t      peer->host, attrstr);\n    }\n\n  /* Network Layer Reachability Information. */\n  update_len = end - stream_pnt (s);\n\n  if (update_len)\n    {\n      /* Check NLRI packet format and prefix length. */\n      ret = bgp_nlri_sanity_check (peer, AFI_IP, stream_pnt (s), update_len);\n      if (ret < 0)\n\treturn -1;\n\n      /* Set NLRI portion to structure. */\n      update.afi = AFI_IP;\n      update.safi = SAFI_UNICAST;\n      update.nlri = stream_pnt (s);\n      update.length = update_len;\n      stream_forward_getp (s, update_len);\n    }\n\n  /* NLRI is processed only when the peer is configured specific\n     Address Family and Subsequent Address Family. */\n  if (peer->afc[AFI_IP][SAFI_UNICAST])\n    {\n      if (withdraw.length)\n\tbgp_nlri_parse (peer, NULL, &withdraw);\n\n      if (update.length)\n\t{\n\t  /* We check well-known attribute only for IPv4 unicast\n\t     update. */\n\t  ret = bgp_attr_check (peer, &attr);\n\t  if (ret < 0)\n\t    return -1;\n\n\t  bgp_nlri_parse (peer, &attr, &update);\n\t}\n\n      if (mp_update.length\n\t  && mp_update.afi == AFI_IP \n\t  && mp_update.safi == SAFI_UNICAST)\n\tbgp_nlri_parse (peer, &attr, &mp_update);\n\n      if (mp_withdraw.length\n\t  && mp_withdraw.afi == AFI_IP \n\t  && mp_withdraw.safi == SAFI_UNICAST)\n\tbgp_nlri_parse (peer, NULL, &mp_withdraw);\n\n      if (! attribute_len && ! withdraw_len)\n\t{\n\t  /* End-of-RIB received */\n\t  SET_FLAG (peer->af_sflags[AFI_IP][SAFI_UNICAST],\n\t\t    PEER_STATUS_EOR_RECEIVED);\n\n\t  /* NSF delete stale route */\n\t  if (peer->nsf[AFI_IP][SAFI_UNICAST])\n\t    bgp_clear_stale_route (peer, AFI_IP, SAFI_UNICAST);\n\n\t  if (BGP_DEBUG (normal, NORMAL))\n\t    zlog (peer->log, LOG_DEBUG, \"rcvd End-of-RIB for IPv4 Unicast from %s\",\n\t\t  peer->host);\n\t}\n    }\n  if (peer->afc[AFI_IP][SAFI_MULTICAST])\n    {\n      if (mp_update.length\n\t  && mp_update.afi == AFI_IP \n\t  && mp_update.safi == SAFI_MULTICAST)\n\tbgp_nlri_parse (peer, &attr, &mp_update);\n\n      if (mp_withdraw.length\n\t  && mp_withdraw.afi == AFI_IP \n\t  && mp_withdraw.safi == SAFI_MULTICAST)\n\tbgp_nlri_parse (peer, NULL, &mp_withdraw);\n\n      if (! withdraw_len\n\t  && mp_withdraw.afi == AFI_IP\n\t  && mp_withdraw.safi == SAFI_MULTICAST\n\t  && mp_withdraw.length == 0)\n\t{\n\t  /* End-of-RIB received */\n\t  SET_FLAG (peer->af_sflags[AFI_IP][SAFI_MULTICAST],\n\t\t    PEER_STATUS_EOR_RECEIVED);\n\n\t  /* NSF delete stale route */\n\t  if (peer->nsf[AFI_IP][SAFI_MULTICAST])\n\t    bgp_clear_stale_route (peer, AFI_IP, SAFI_MULTICAST);\n\n\t  if (BGP_DEBUG (normal, NORMAL))\n\t    zlog (peer->log, LOG_DEBUG, \"rcvd End-of-RIB for IPv4 Multicast from %s\",\n\t\t  peer->host);\n\t}\n    }\n  if (peer->afc[AFI_IP6][SAFI_UNICAST])\n    {\n      if (mp_update.length \n\t  && mp_update.afi == AFI_IP6 \n\t  && mp_update.safi == SAFI_UNICAST)\n\tbgp_nlri_parse (peer, &attr, &mp_update);\n\n      if (mp_withdraw.length \n\t  && mp_withdraw.afi == AFI_IP6 \n\t  && mp_withdraw.safi == SAFI_UNICAST)\n\tbgp_nlri_parse (peer, NULL, &mp_withdraw);\n\n      if (! withdraw_len\n\t  && mp_withdraw.afi == AFI_IP6\n\t  && mp_withdraw.safi == SAFI_UNICAST\n\t  && mp_withdraw.length == 0)\n\t{\n\t  /* End-of-RIB received */\n\t  SET_FLAG (peer->af_sflags[AFI_IP6][SAFI_UNICAST], PEER_STATUS_EOR_RECEIVED);\n\n\t  /* NSF delete stale route */\n\t  if (peer->nsf[AFI_IP6][SAFI_UNICAST])\n\t    bgp_clear_stale_route (peer, AFI_IP6, SAFI_UNICAST);\n\n\t  if (BGP_DEBUG (normal, NORMAL))\n\t    zlog (peer->log, LOG_DEBUG, \"rcvd End-of-RIB for IPv6 Unicast from %s\",\n\t\t  peer->host);\n\t}\n    }\n  if (peer->afc[AFI_IP6][SAFI_MULTICAST])\n    {\n      if (mp_update.length \n\t  && mp_update.afi == AFI_IP6 \n\t  && mp_update.safi == SAFI_MULTICAST)\n\tbgp_nlri_parse (peer, &attr, &mp_update);\n\n      if (mp_withdraw.length \n\t  && mp_withdraw.afi == AFI_IP6 \n\t  && mp_withdraw.safi == SAFI_MULTICAST)\n\tbgp_nlri_parse (peer, NULL, &mp_withdraw);\n\n      if (! withdraw_len\n\t  && mp_withdraw.afi == AFI_IP6\n\t  && mp_withdraw.safi == SAFI_MULTICAST\n\t  && mp_withdraw.length == 0)\n\t{\n\t  /* End-of-RIB received */\n\n\t  /* NSF delete stale route */\n\t  if (peer->nsf[AFI_IP6][SAFI_MULTICAST])\n\t    bgp_clear_stale_route (peer, AFI_IP6, SAFI_MULTICAST);\n\n\t  if (BGP_DEBUG (update, UPDATE_IN))\n\t    zlog (peer->log, LOG_DEBUG, \"rcvd End-of-RIB for IPv6 Multicast from %s\",\n\t\t  peer->host);\n\t}\n    }\n  if (peer->afc[AFI_IP][SAFI_MPLS_VPN])\n    {\n      if (mp_update.length \n\t  && mp_update.afi == AFI_IP \n\t  && mp_update.safi == BGP_SAFI_VPNV4)\n\tbgp_nlri_parse_vpnv4 (peer, &attr, &mp_update);\n\n      if (mp_withdraw.length \n\t  && mp_withdraw.afi == AFI_IP \n\t  && mp_withdraw.safi == BGP_SAFI_VPNV4)\n\tbgp_nlri_parse_vpnv4 (peer, NULL, &mp_withdraw);\n\n      if (! withdraw_len\n\t  && mp_withdraw.afi == AFI_IP\n\t  && mp_withdraw.safi == BGP_SAFI_VPNV4\n\t  && mp_withdraw.length == 0)\n\t{\n\t  /* End-of-RIB received */\n\n\t  if (BGP_DEBUG (update, UPDATE_IN))\n\t    zlog (peer->log, LOG_DEBUG, \"rcvd End-of-RIB for VPNv4 Unicast from %s\",\n\t\t  peer->host);\n\t}\n    }\n\n  /* Everything is done.  We unintern temporary structures which\n     interned in bgp_attr_parse(). */\n  if (attr.aspath)\n    aspath_unintern (attr.aspath);\n  if (attr.community)\n    community_unintern (attr.community);\n  if (attr.extra)\n    {\n      if (attr.extra->ecommunity)\n        ecommunity_unintern (attr.extra->ecommunity);\n      if (attr.extra->cluster)\n        cluster_unintern (attr.extra->cluster);\n      if (attr.extra->transit)\n        transit_unintern (attr.extra->transit);\n      bgp_attr_extra_free (&attr);\n    }\n\n  /* If peering is stopped due to some reason, do not generate BGP\n     event.  */\n  if (peer->status != Established)\n    return 0;\n\n  /* Increment packet counter. */\n  peer->update_in++;\n  peer->update_time = time (NULL);\n\n  /* Generate BGP event. */\n  BGP_EVENT_ADD (peer, Receive_UPDATE_message);\n\n  return 0;\n}\n\n/* Notify message treatment function. */\nstatic void\nbgp_notify_receive (struct peer *peer, bgp_size_t size)\n{\n  struct bgp_notify bgp_notify;\n\n  if (peer->notify.data)\n    {\n      XFREE (MTYPE_TMP, peer->notify.data);\n      peer->notify.data = NULL;\n      peer->notify.length = 0;\n    }\n\n  bgp_notify.code = stream_getc (peer->ibuf);\n  bgp_notify.subcode = stream_getc (peer->ibuf);\n  bgp_notify.length = size - 2;\n  bgp_notify.data = NULL;\n\n  /* Preserv notify code and sub code. */\n  peer->notify.code = bgp_notify.code;\n  peer->notify.subcode = bgp_notify.subcode;\n  /* For further diagnostic record returned Data. */\n  if (bgp_notify.length)\n    {\n      peer->notify.length = size - 2;\n      peer->notify.data = XMALLOC (MTYPE_TMP, size - 2);\n      memcpy (peer->notify.data, stream_pnt (peer->ibuf), size - 2);\n    }\n\n  /* For debug */\n  {\n    int i;\n    int first = 0;\n    char c[4];\n\n    if (bgp_notify.length)\n      {\n\tbgp_notify.data = XMALLOC (MTYPE_TMP, bgp_notify.length * 3);\n\tfor (i = 0; i < bgp_notify.length; i++)\n\t  if (first)\n\t    {\n\t      sprintf (c, \" %02x\", stream_getc (peer->ibuf));\n\t      strcat (bgp_notify.data, c);\n\t    }\n\t  else\n\t    {\n\t      first = 1;\n\t      sprintf (c, \"%02x\", stream_getc (peer->ibuf));\n\t      strcpy (bgp_notify.data, c);\n\t    }\n      }\n\n    bgp_notify_print(peer, &bgp_notify, \"received\");\n    if (bgp_notify.data)\n      XFREE (MTYPE_TMP, bgp_notify.data);\n  }\n\n  /* peer count update */\n  peer->notify_in++;\n\n  if (peer->status == Established)\n    peer->last_reset = PEER_DOWN_NOTIFY_RECEIVED;\n\n  /* We have to check for Notify with Unsupported Optional Parameter.\n     in that case we fallback to open without the capability option.\n     But this done in bgp_stop. We just mark it here to avoid changing\n     the fsm tables.  */\n  if (bgp_notify.code == BGP_NOTIFY_OPEN_ERR &&\n      bgp_notify.subcode == BGP_NOTIFY_OPEN_UNSUP_PARAM )\n    UNSET_FLAG (peer->sflags, PEER_STATUS_CAPABILITY_OPEN);\n\n  /* Also apply to Unsupported Capability until remote router support\n     capability. */\n  if (bgp_notify.code == BGP_NOTIFY_OPEN_ERR &&\n      bgp_notify.subcode == BGP_NOTIFY_OPEN_UNSUP_CAPBL)\n    UNSET_FLAG (peer->sflags, PEER_STATUS_CAPABILITY_OPEN);\n\n  BGP_EVENT_ADD (peer, Receive_NOTIFICATION_message);\n}\n\n/* Keepalive treatment function -- get keepalive send keepalive */\nstatic void\nbgp_keepalive_receive (struct peer *peer, bgp_size_t size)\n{\n  if (BGP_DEBUG (keepalive, KEEPALIVE))  \n    zlog_debug (\"%s KEEPALIVE rcvd\", peer->host); \n  \n  BGP_EVENT_ADD (peer, Receive_KEEPALIVE_message);\n}\n\n/* Route refresh message is received. */\nstatic void\nbgp_route_refresh_receive (struct peer *peer, bgp_size_t size)\n{\n  afi_t afi;\n  safi_t safi;\n  u_char reserved;\n  struct stream *s;\n\n  /* If peer does not have the capability, send notification. */\n  if (! CHECK_FLAG (peer->cap, PEER_CAP_REFRESH_ADV))\n    {\n      plog_err (peer->log, \"%s [Error] BGP route refresh is not enabled\",\n\t\tpeer->host);\n      bgp_notify_send (peer,\n\t\t       BGP_NOTIFY_HEADER_ERR,\n\t\t       BGP_NOTIFY_HEADER_BAD_MESTYPE);\n      return;\n    }\n\n  /* Status must be Established. */\n  if (peer->status != Established) \n    {\n      plog_err (peer->log,\n\t\t\"%s [Error] Route refresh packet received under status %s\",\n\t\tpeer->host, LOOKUP (bgp_status_msg, peer->status));\n      bgp_notify_send (peer, BGP_NOTIFY_FSM_ERR, 0);\n      return;\n    }\n\n  s = peer->ibuf;\n  \n  /* Parse packet. */\n  afi = stream_getw (s);\n  reserved = stream_getc (s);\n  safi = stream_getc (s);\n\n  if (BGP_DEBUG (normal, NORMAL))\n    zlog_debug (\"%s rcvd REFRESH_REQ for afi/safi: %d/%d\",\n\t       peer->host, afi, safi);\n\n  /* Check AFI and SAFI. */\n  if ((afi != AFI_IP && afi != AFI_IP6)\n      || (safi != SAFI_UNICAST && safi != SAFI_MULTICAST\n\t  && safi != BGP_SAFI_VPNV4))\n    {\n      if (BGP_DEBUG (normal, NORMAL))\n\t{\n\t  zlog_debug (\"%s REFRESH_REQ for unrecognized afi/safi: %d/%d - ignored\",\n\t\t     peer->host, afi, safi);\n\t}\n      return;\n    }\n\n  /* Adjust safi code. */\n  if (safi == BGP_SAFI_VPNV4)\n    safi = SAFI_MPLS_VPN;\n\n  if (size != BGP_MSG_ROUTE_REFRESH_MIN_SIZE - BGP_HEADER_SIZE)\n    {\n      u_char *end;\n      u_char when_to_refresh;\n      u_char orf_type;\n      u_int16_t orf_len;\n\n      if (size - (BGP_MSG_ROUTE_REFRESH_MIN_SIZE - BGP_HEADER_SIZE) < 5)\n        {\n          zlog_info (\"%s ORF route refresh length error\", peer->host);\n          bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n          return;\n        }\n\n      when_to_refresh = stream_getc (s);\n      end = stream_pnt (s) + (size - 5);\n\n      while (stream_pnt (s) < end)\n\t{\n\t  orf_type = stream_getc (s); \n\t  orf_len = stream_getw (s);\n\n\t  if (orf_type == ORF_TYPE_PREFIX\n\t      || orf_type == ORF_TYPE_PREFIX_OLD)\n\t    {\n\t      u_char *p_pnt = stream_pnt (s);\n\t      u_char *p_end = stream_pnt (s) + orf_len;\n\t      struct orf_prefix orfp;\n\t      u_char common = 0;\n\t      u_int32_t seq;\n\t      int psize;\n\t      char name[BUFSIZ];\n\t      char buf[BUFSIZ];\n\t      int ret;\n\n\t      if (BGP_DEBUG (normal, NORMAL))\n\t\t{\n\t\t  zlog_debug (\"%s rcvd Prefixlist ORF(%d) length %d\",\n\t\t\t     peer->host, orf_type, orf_len);\n\t\t}\n\n\t      /* ORF prefix-list name */\n\t      sprintf (name, \"%s.%d.%d\", peer->host, afi, safi);\n\n\t      while (p_pnt < p_end)\n\t\t{\n\t\t  memset (&orfp, 0, sizeof (struct orf_prefix));\n\t\t  common = *p_pnt++;\n\t\t  if (common & ORF_COMMON_PART_REMOVE_ALL)\n\t\t    {\n\t\t      if (BGP_DEBUG (normal, NORMAL))\n\t\t\tzlog_debug (\"%s rcvd Remove-All pfxlist ORF request\", peer->host);\n\t\t      prefix_bgp_orf_remove_all (name);\n\t\t      break;\n\t\t    }\n\t\t  memcpy (&seq, p_pnt, sizeof (u_int32_t));\n\t\t  p_pnt += sizeof (u_int32_t);\n\t\t  orfp.seq = ntohl (seq);\n\t\t  orfp.ge = *p_pnt++;\n\t\t  orfp.le = *p_pnt++;\n\t\t  orfp.p.prefixlen = *p_pnt++;\n\t\t  orfp.p.family = afi2family (afi);\n\t\t  psize = PSIZE (orfp.p.prefixlen);\n\t\t  memcpy (&orfp.p.u.prefix, p_pnt, psize);\n\t\t  p_pnt += psize;\n\n\t\t  if (BGP_DEBUG (normal, NORMAL))\n\t\t    zlog_debug (\"%s rcvd %s %s seq %u %s/%d ge %d le %d\",\n\t\t\t       peer->host,\n\t\t\t       (common & ORF_COMMON_PART_REMOVE ? \"Remove\" : \"Add\"), \n\t\t\t       (common & ORF_COMMON_PART_DENY ? \"deny\" : \"permit\"),\n\t\t\t       orfp.seq, \n\t\t\t       inet_ntop (orfp.p.family, &orfp.p.u.prefix, buf, BUFSIZ),\n\t\t\t       orfp.p.prefixlen, orfp.ge, orfp.le);\n\n\t\t  ret = prefix_bgp_orf_set (name, afi, &orfp,\n\t\t\t\t (common & ORF_COMMON_PART_DENY ? 0 : 1 ),\n\t\t\t\t (common & ORF_COMMON_PART_REMOVE ? 0 : 1));\n\n\t\t  if (ret != CMD_SUCCESS)\n\t\t    {\n\t\t      if (BGP_DEBUG (normal, NORMAL))\n\t\t\tzlog_debug (\"%s Received misformatted prefixlist ORF. Remove All pfxlist\", peer->host);\n\t\t      prefix_bgp_orf_remove_all (name);\n\t\t      break;\n\t\t    }\n\t\t}\n\t      peer->orf_plist[afi][safi] =\n\t\t\t prefix_list_lookup (AFI_ORF_PREFIX, name);\n\t    }\n\t  stream_forward_getp (s, orf_len);\n\t}\n      if (BGP_DEBUG (normal, NORMAL))\n\tzlog_debug (\"%s rcvd Refresh %s ORF request\", peer->host,\n\t\t   when_to_refresh == REFRESH_DEFER ? \"Defer\" : \"Immediate\");\n      if (when_to_refresh == REFRESH_DEFER)\n\treturn;\n    }\n\n  /* First update is deferred until ORF or ROUTE-REFRESH is received */\n  if (CHECK_FLAG (peer->af_sflags[afi][safi], PEER_STATUS_ORF_WAIT_REFRESH))\n    UNSET_FLAG (peer->af_sflags[afi][safi], PEER_STATUS_ORF_WAIT_REFRESH);\n\n  /* Perform route refreshment to the peer */\n  bgp_announce_route (peer, afi, safi);\n}\n\nstatic int\nbgp_capability_msg_parse (struct peer *peer, u_char *pnt, bgp_size_t length)\n{\n  u_char *end;\n  struct capability cap;\n  u_char action;\n  struct bgp *bgp;\n  afi_t afi;\n  safi_t safi;\n\n  bgp = peer->bgp;\n  end = pnt + length;\n\n  while (pnt < end)\n    {\n      /* We need at least action, capability code and capability length. */\n      if (pnt + 3 > end)\n        {\n          zlog_info (\"%s Capability length error\", peer->host);\n          bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n          return -1;\n        }\n\n      action = *pnt;\n\n      /* Fetch structure to the byte stream. */\n      memcpy (&cap, pnt + 1, sizeof (struct capability));\n\n      /* Action value check.  */\n      if (action != CAPABILITY_ACTION_SET\n\t  && action != CAPABILITY_ACTION_UNSET)\n        {\n          zlog_info (\"%s Capability Action Value error %d\",\n\t\t     peer->host, action);\n          bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n          return -1;\n        }\n\n      if (BGP_DEBUG (normal, NORMAL))\n\tzlog_debug (\"%s CAPABILITY has action: %d, code: %u, length %u\",\n\t\t   peer->host, action, cap.code, cap.length);\n\n      /* Capability length check. */\n      if (pnt + (cap.length + 3) > end)\n        {\n          zlog_info (\"%s Capability length error\", peer->host);\n          bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n          return -1;\n        }\n\n      /* We know MP Capability Code. */\n      if (cap.code == CAPABILITY_CODE_MP)\n        {\n\t  afi = ntohs (cap.mpc.afi);\n\t  safi = cap.mpc.safi;\n\n          /* Ignore capability when override-capability is set. */\n          if (CHECK_FLAG (peer->flags, PEER_FLAG_OVERRIDE_CAPABILITY))\n\t    continue;\n\n\t  /* Address family check.  */\n\t  if ((afi == AFI_IP \n\t       || afi == AFI_IP6)\n\t      && (safi == SAFI_UNICAST \n\t\t  || safi == SAFI_MULTICAST \n\t\t  || safi == BGP_SAFI_VPNV4))\n\t    {\n\t      if (BGP_DEBUG (normal, NORMAL))\n\t\tzlog_debug (\"%s CAPABILITY has %s MP_EXT CAP for afi/safi: %u/%u\",\n\t\t\t   peer->host,\n\t\t\t   action == CAPABILITY_ACTION_SET \n\t\t\t   ? \"Advertising\" : \"Removing\",\n\t\t\t   ntohs(cap.mpc.afi) , cap.mpc.safi);\n\t\t  \n\t      /* Adjust safi code. */\n\t      if (safi == BGP_SAFI_VPNV4)\n\t\tsafi = SAFI_MPLS_VPN;\n\t      \n\t      if (action == CAPABILITY_ACTION_SET)\n\t\t{\n\t\t  peer->afc_recv[afi][safi] = 1;\n\t\t  if (peer->afc[afi][safi])\n\t\t    {\n\t\t      peer->afc_nego[afi][safi] = 1;\n\t\t      bgp_announce_route (peer, afi, safi);\n\t\t    }\n\t\t}\n\t      else\n\t\t{\n\t\t  peer->afc_recv[afi][safi] = 0;\n\t\t  peer->afc_nego[afi][safi] = 0;\n\n\t\t  if (peer_active_nego (peer))\n\t\t    bgp_clear_route (peer, afi, safi);\n\t\t  else\n\t\t    BGP_EVENT_ADD (peer, BGP_Stop);\n\t\t} \n\t    }\n        }\n      else\n        {\n          zlog_warn (\"%s unrecognized capability code: %d - ignored\",\n                     peer->host, cap.code);\n        }\n      pnt += cap.length + 3;\n    }\n  return 0;\n}\n\n/* Dynamic Capability is received. */\nstatic void\nbgp_capability_receive (struct peer *peer, bgp_size_t size)\n{\n  u_char *pnt;\n  int ret;\n\n  /* Fetch pointer. */\n  pnt = stream_pnt (peer->ibuf);\n\n  if (BGP_DEBUG (normal, NORMAL))\n    zlog_debug (\"%s rcv CAPABILITY\", peer->host);\n\n  /* If peer does not have the capability, send notification. */\n  if (! CHECK_FLAG (peer->cap, PEER_CAP_DYNAMIC_ADV))\n    {\n      plog_err (peer->log, \"%s [Error] BGP dynamic capability is not enabled\",\n\t\tpeer->host);\n      bgp_notify_send (peer,\n\t\t       BGP_NOTIFY_HEADER_ERR,\n\t\t       BGP_NOTIFY_HEADER_BAD_MESTYPE);\n      return;\n    }\n\n  /* Status must be Established. */\n  if (peer->status != Established)\n    {\n      plog_err (peer->log,\n\t\t\"%s [Error] Dynamic capability packet received under status %s\", peer->host, LOOKUP (bgp_status_msg, peer->status));\n      bgp_notify_send (peer, BGP_NOTIFY_FSM_ERR, 0);\n      return;\n    }\n\n  /* Parse packet. */\n  ret = bgp_capability_msg_parse (peer, pnt, size);\n}\n\f\n/* BGP read utility function. */\nstatic int\nbgp_read_packet (struct peer *peer)\n{\n  int nbytes;\n  int readsize;\n\n  readsize = peer->packet_size - stream_get_endp (peer->ibuf);\n\n  /* If size is zero then return. */\n  if (! readsize)\n    return 0;\n\n  /* Read packet from fd. */\n  nbytes = stream_read_unblock (peer->ibuf, peer->fd, readsize);\n\n  /* If read byte is smaller than zero then error occured. */\n  if (nbytes < 0) \n    {\n      if (errno == EAGAIN)\n\treturn -1;\n\n      plog_err (peer->log, \"%s [Error] bgp_read_packet error: %s\",\n\t\t peer->host, safe_strerror (errno));\n\n      if (peer->status == Established) \n\t{\n\t  if (CHECK_FLAG (peer->sflags, PEER_STATUS_NSF_MODE))\n\t    {\n\t      peer->last_reset = PEER_DOWN_NSF_CLOSE_SESSION;\n\t      SET_FLAG (peer->sflags, PEER_STATUS_NSF_WAIT);\n\t    }\n\t  else\n\t    peer->last_reset = PEER_DOWN_CLOSE_SESSION;\n\t}\n\n      BGP_EVENT_ADD (peer, TCP_fatal_error);\n      return -1;\n    }  \n\n  /* When read byte is zero : clear bgp peer and return */\n  if (nbytes == 0) \n    {\n      if (BGP_DEBUG (events, EVENTS))\n\tplog_debug (peer->log, \"%s [Event] BGP connection closed fd %d\",\n\t\t   peer->host, peer->fd);\n\n      if (peer->status == Established) \n\t{\n\t  if (CHECK_FLAG (peer->sflags, PEER_STATUS_NSF_MODE))\n\t    {\n\t      peer->last_reset = PEER_DOWN_NSF_CLOSE_SESSION;\n\t      SET_FLAG (peer->sflags, PEER_STATUS_NSF_WAIT);\n\t    }\n\t  else\n\t    peer->last_reset = PEER_DOWN_CLOSE_SESSION;\n\t}\n\n      BGP_EVENT_ADD (peer, TCP_connection_closed);\n      return -1;\n    }\n\n  /* We read partial packet. */\n  if (stream_get_endp (peer->ibuf) != peer->packet_size)\n    return -1;\n\n  return 0;\n}\n\n/* Marker check. */\nstatic int\nbgp_marker_all_one (struct stream *s, int length)\n{\n  int i;\n\n  for (i = 0; i < length; i++)\n    if (s->data[i] != 0xff)\n      return 0;\n\n  return 1;\n}\n\n/* Starting point of packet process function. */\nint\nbgp_read (struct thread *thread)\n{\n  int ret;\n  u_char type = 0;\n  struct peer *peer;\n  bgp_size_t size;\n  char notify_data_length[2];\n\n  /* Yes first of all get peer pointer. */\n  peer = THREAD_ARG (thread);\n  peer->t_read = NULL;\n\n  /* For non-blocking IO check. */\n  if (peer->status == Connect)\n    {\n      bgp_connect_check (peer);\n      goto done;\n    }\n  else\n    {\n      if (peer->fd < 0)\n\t{\n\t  zlog_err (\"bgp_read peer's fd is negative value %d\", peer->fd);\n\t  return -1;\n\t}\n      BGP_READ_ON (peer->t_read, bgp_read, peer->fd);\n    }\n\n  /* Read packet header to determine type of the packet */\n  if (peer->packet_size == 0)\n    peer->packet_size = BGP_HEADER_SIZE;\n\n  if (stream_get_endp (peer->ibuf) < BGP_HEADER_SIZE)\n    {\n      ret = bgp_read_packet (peer);\n\n      /* Header read error or partial read packet. */\n      if (ret < 0) \n\tgoto done;\n\n      /* Get size and type. */\n      stream_forward_getp (peer->ibuf, BGP_MARKER_SIZE);\n      memcpy (notify_data_length, stream_pnt (peer->ibuf), 2);\n      size = stream_getw (peer->ibuf);\n      type = stream_getc (peer->ibuf);\n\n      if (BGP_DEBUG (normal, NORMAL) && type != 2 && type != 0)\n\tzlog_debug (\"%s rcv message type %d, length (excl. header) %d\",\n\t\t   peer->host, type, size - BGP_HEADER_SIZE);\n\n      /* Marker check */\n      if (((type == BGP_MSG_OPEN) || (type == BGP_MSG_KEEPALIVE))\n\t  && ! bgp_marker_all_one (peer->ibuf, BGP_MARKER_SIZE))\n\t{\n\t  bgp_notify_send (peer,\n\t\t\t   BGP_NOTIFY_HEADER_ERR, \n\t\t\t   BGP_NOTIFY_HEADER_NOT_SYNC);\n\t  goto done;\n\t}\n\n      /* BGP type check. */\n      if (type != BGP_MSG_OPEN && type != BGP_MSG_UPDATE \n\t  && type != BGP_MSG_NOTIFY && type != BGP_MSG_KEEPALIVE \n\t  && type != BGP_MSG_ROUTE_REFRESH_NEW\n\t  && type != BGP_MSG_ROUTE_REFRESH_OLD\n\t  && type != BGP_MSG_CAPABILITY)\n\t{\n\t  if (BGP_DEBUG (normal, NORMAL))\n\t    plog_debug (peer->log,\n\t\t      \"%s unknown message type 0x%02x\",\n\t\t      peer->host, type);\n\t  bgp_notify_send_with_data (peer,\n\t\t\t\t     BGP_NOTIFY_HEADER_ERR,\n\t\t\t \t     BGP_NOTIFY_HEADER_BAD_MESTYPE,\n\t\t\t\t     &type, 1);\n\t  goto done;\n\t}\n      /* Mimimum packet length check. */\n      if ((size < BGP_HEADER_SIZE)\n\t  || (size > BGP_MAX_PACKET_SIZE)\n\t  || (type == BGP_MSG_OPEN && size < BGP_MSG_OPEN_MIN_SIZE)\n\t  || (type == BGP_MSG_UPDATE && size < BGP_MSG_UPDATE_MIN_SIZE)\n\t  || (type == BGP_MSG_NOTIFY && size < BGP_MSG_NOTIFY_MIN_SIZE)\n\t  || (type == BGP_MSG_KEEPALIVE && size != BGP_MSG_KEEPALIVE_MIN_SIZE)\n\t  || (type == BGP_MSG_ROUTE_REFRESH_NEW && size < BGP_MSG_ROUTE_REFRESH_MIN_SIZE)\n\t  || (type == BGP_MSG_ROUTE_REFRESH_OLD && size < BGP_MSG_ROUTE_REFRESH_MIN_SIZE)\n\t  || (type == BGP_MSG_CAPABILITY && size < BGP_MSG_CAPABILITY_MIN_SIZE))\n\t{\n\t  if (BGP_DEBUG (normal, NORMAL))\n\t    plog_debug (peer->log,\n\t\t      \"%s bad message length - %d for %s\",\n\t\t      peer->host, size, \n\t\t      type == 128 ? \"ROUTE-REFRESH\" :\n\t\t      bgp_type_str[(int) type]);\n\t  bgp_notify_send_with_data (peer,\n\t\t\t\t     BGP_NOTIFY_HEADER_ERR,\n\t\t\t  \t     BGP_NOTIFY_HEADER_BAD_MESLEN,\n\t\t\t\t     (u_char *) notify_data_length, 2);\n\t  goto done;\n\t}\n\n      /* Adjust size to message length. */\n      peer->packet_size = size;\n    }\n\n  ret = bgp_read_packet (peer);\n  if (ret < 0) \n    goto done;\n\n  /* Get size and type again. */\n  size = stream_getw_from (peer->ibuf, BGP_MARKER_SIZE);\n  type = stream_getc_from (peer->ibuf, BGP_MARKER_SIZE + 2);\n\n  /* BGP packet dump function. */\n  bgp_dump_packet (peer, type, peer->ibuf);\n  \n  size = (peer->packet_size - BGP_HEADER_SIZE);\n\n  /* Read rest of the packet and call each sort of packet routine */\n  switch (type) \n    {\n    case BGP_MSG_OPEN:\n      peer->open_in++;\n      bgp_open_receive (peer, size); /* XXX return value ignored! */\n      break;\n    case BGP_MSG_UPDATE:\n      peer->readtime = time(NULL);    /* Last read timer reset */\n      bgp_update_receive (peer, size);\n      break;\n    case BGP_MSG_NOTIFY:\n      bgp_notify_receive (peer, size);\n      break;\n    case BGP_MSG_KEEPALIVE:\n      peer->readtime = time(NULL);    /* Last read timer reset */\n      bgp_keepalive_receive (peer, size);\n      break;\n    case BGP_MSG_ROUTE_REFRESH_NEW:\n    case BGP_MSG_ROUTE_REFRESH_OLD:\n      peer->refresh_in++;\n      bgp_route_refresh_receive (peer, size);\n      break;\n    case BGP_MSG_CAPABILITY:\n      peer->dynamic_cap_in++;\n      bgp_capability_receive (peer, size);\n      break;\n    }\n\n  /* Clear input buffer. */\n  peer->packet_size = 0;\n  if (peer->ibuf)\n    stream_reset (peer->ibuf);\n\n done:\n  if (CHECK_FLAG (peer->sflags, PEER_STATUS_ACCEPT_PEER))\n    {\n      if (BGP_DEBUG (events, EVENTS))\n\tzlog_debug (\"%s [Event] Accepting BGP peer delete\", peer->host);\n      peer_delete (peer);\n    }\n  return 0;\n}\n", "/* BGP VTY interface.\n   Copyright (C) 1996, 97, 98, 99, 2000 Kunihiro Ishiguro\n\nThis file is part of GNU Zebra.\n\nGNU Zebra is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the\nFree Software Foundation; either version 2, or (at your option) any\nlater version.\n\nGNU Zebra is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GNU Zebra; see the file COPYING.  If not, write to the Free\nSoftware Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#include <zebra.h>\n\n#include \"command.h\"\n#include \"prefix.h\"\n#include \"plist.h\"\n#include \"buffer.h\"\n#include \"linklist.h\"\n#include \"stream.h\"\n#include \"thread.h\"\n#include \"log.h\"\n#include \"memory.h\"\n#include \"hash.h\"\n\n#include \"bgpd/bgpd.h\"\n#include \"bgpd/bgp_advertise.h\"\n#include \"bgpd/bgp_attr.h\"\n#include \"bgpd/bgp_aspath.h\"\n#include \"bgpd/bgp_community.h\"\n#include \"bgpd/bgp_ecommunity.h\"\n#include \"bgpd/bgp_damp.h\"\n#include \"bgpd/bgp_debug.h\"\n#include \"bgpd/bgp_fsm.h\"\n#include \"bgpd/bgp_mplsvpn.h\"\n#include \"bgpd/bgp_nexthop.h\"\n#include \"bgpd/bgp_open.h\"\n#include \"bgpd/bgp_regex.h\"\n#include \"bgpd/bgp_route.h\"\n#include \"bgpd/bgp_zebra.h\"\n#include \"bgpd/bgp_table.h\"\n#include \"bgpd/bgp_vty.h\"\n\nextern struct in_addr router_id_zebra;\n\n/* Utility function to get address family from current node.  */\nafi_t\nbgp_node_afi (struct vty *vty)\n{\n  if (vty->node == BGP_IPV6_NODE || vty->node == BGP_IPV6M_NODE)\n    return AFI_IP6;\n  return AFI_IP;\n}\n\n/* Utility function to get subsequent address family from current\n   node.  */\nsafi_t\nbgp_node_safi (struct vty *vty)\n{\n  if (vty->node == BGP_VPNV4_NODE)\n    return SAFI_MPLS_VPN;\n  if (vty->node == BGP_IPV4M_NODE || vty->node == BGP_IPV6M_NODE)\n    return SAFI_MULTICAST;\n  return SAFI_UNICAST;\n}\n\nstatic int\npeer_address_self_check (union sockunion *su)\n{\n  struct interface *ifp = NULL;\n\n  if (su->sa.sa_family == AF_INET)\n    ifp = if_lookup_by_ipv4_exact (&su->sin.sin_addr);\n#ifdef HAVE_IPV6\n  else if (su->sa.sa_family == AF_INET6)\n    ifp = if_lookup_by_ipv6_exact (&su->sin6.sin6_addr);\n#endif /* HAVE IPV6 */\n\n  if (ifp)\n    return 1;\n\n  return 0;\n}\n\n/* Utility function for looking up peer from VTY.  */\nstatic struct peer *\npeer_lookup_vty (struct vty *vty, const char *ip_str)\n{\n  int ret;\n  struct bgp *bgp;\n  union sockunion su;\n  struct peer *peer;\n\n  bgp = vty->index;\n\n  ret = str2sockunion (ip_str, &su);\n  if (ret < 0)\n    {\n      vty_out (vty, \"%% Malformed address: %s%s\", ip_str, VTY_NEWLINE);\n      return NULL;\n    }\n\n  peer = peer_lookup (bgp, &su);\n  if (! peer)\n    {\n      vty_out (vty, \"%% Specify remote-as or peer-group commands first%s\", VTY_NEWLINE);\n      return NULL;\n    }\n  return peer;\n}\n\n/* Utility function for looking up peer or peer group.  */\nstatic struct peer *\npeer_and_group_lookup_vty (struct vty *vty, const char *peer_str)\n{\n  int ret;\n  struct bgp *bgp;\n  union sockunion su;\n  struct peer *peer;\n  struct peer_group *group;\n\n  bgp = vty->index;\n\n  ret = str2sockunion (peer_str, &su);\n  if (ret == 0)\n    {\n      peer = peer_lookup (bgp, &su);\n      if (peer)\n\treturn peer;\n    }\n  else\n    {\n      group = peer_group_lookup (bgp, peer_str);\n      if (group)\n\treturn group->conf;\n    }\n\n  vty_out (vty, \"%% Specify remote-as or peer-group commands first%s\",\n\t   VTY_NEWLINE);\n\n  return NULL;\n}\n\nstatic int\nbgp_vty_return (struct vty *vty, int ret)\n{\n  const char *str = NULL;\n\n  switch (ret)\n    {\n    case BGP_ERR_INVALID_VALUE:\n      str = \"Invalid value\";\n      break;\n    case BGP_ERR_INVALID_FLAG:\n      str = \"Invalid flag\";\n      break;\n    case BGP_ERR_PEER_INACTIVE:\n      str = \"Activate the neighbor for the address family first\";\n      break;\n    case BGP_ERR_INVALID_FOR_PEER_GROUP_MEMBER:\n      str = \"Invalid command for a peer-group member\";\n      break;\n    case BGP_ERR_PEER_GROUP_SHUTDOWN:\n      str = \"Peer-group has been shutdown. Activate the peer-group first\";\n      break;\n    case BGP_ERR_PEER_GROUP_HAS_THE_FLAG:\n      str = \"This peer is a peer-group member.  Please change peer-group configuration\";\n      break;\n    case BGP_ERR_PEER_FLAG_CONFLICT:\n      str = \"Can't set override-capability and strict-capability-match at the same time\";\n      break;\n    case BGP_ERR_PEER_GROUP_MEMBER_EXISTS:\n      str = \"No activate for peergroup can be given only if peer-group has no members\";\n      break;\n    case BGP_ERR_PEER_BELONGS_TO_GROUP:\n      str = \"No activate for an individual peer-group member is invalid\";\n      break;\n    case BGP_ERR_PEER_GROUP_AF_UNCONFIGURED:\n      str = \"Activate the peer-group for the address family first\";\n      break;\n    case BGP_ERR_PEER_GROUP_NO_REMOTE_AS:\n      str = \"Specify remote-as or peer-group remote AS first\";\n      break;\n    case BGP_ERR_PEER_GROUP_CANT_CHANGE:\n      str = \"Cannot change the peer-group. Deconfigure first\";\n      break;\n    case BGP_ERR_PEER_GROUP_MISMATCH:\n      str = \"Cannot have different peer-group for the neighbor\";\n      break;\n    case BGP_ERR_PEER_FILTER_CONFLICT:\n      str = \"Prefix/distribute list can not co-exist\";\n      break;\n    case BGP_ERR_NOT_INTERNAL_PEER:\n      str = \"Invalid command. Not an internal neighbor\";\n      break;\n    case BGP_ERR_REMOVE_PRIVATE_AS:\n      str = \"Private AS cannot be removed for IBGP peers\";\n      break;\n    case BGP_ERR_LOCAL_AS_ALLOWED_ONLY_FOR_EBGP:\n      str = \"Local-AS allowed only for EBGP peers\";\n      break;\n    case BGP_ERR_CANNOT_HAVE_LOCAL_AS_SAME_AS:\n      str = \"Cannot have local-as same as BGP AS number\";\n      break;\n    }\n  if (str)\n    {\n      vty_out (vty, \"%% %s%s\", str, VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n  return CMD_SUCCESS;\n}\n\n/* BGP global configuration.  */\n\nDEFUN (bgp_multiple_instance_func,\n       bgp_multiple_instance_cmd,\n       \"bgp multiple-instance\",\n       BGP_STR\n       \"Enable bgp multiple instance\\n\")\n{\n  bgp_option_set (BGP_OPT_MULTIPLE_INSTANCE);\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_bgp_multiple_instance,\n       no_bgp_multiple_instance_cmd,\n       \"no bgp multiple-instance\",\n       NO_STR\n       BGP_STR\n       \"BGP multiple instance\\n\")\n{\n  int ret;\n\n  ret = bgp_option_unset (BGP_OPT_MULTIPLE_INSTANCE);\n  if (ret < 0)\n    {\n      vty_out (vty, \"%% There are more than two BGP instances%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n  return CMD_SUCCESS;\n}\n\nDEFUN (bgp_config_type,\n       bgp_config_type_cmd,\n       \"bgp config-type (cisco|zebra)\",\n       BGP_STR\n       \"Configuration type\\n\"\n       \"cisco\\n\"\n       \"zebra\\n\")\n{\n  if (strncmp (argv[0], \"c\", 1) == 0)\n    bgp_option_set (BGP_OPT_CONFIG_CISCO);\n  else\n    bgp_option_unset (BGP_OPT_CONFIG_CISCO);\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_bgp_config_type,\n       no_bgp_config_type_cmd,\n       \"no bgp config-type\",\n       NO_STR\n       BGP_STR\n       \"Display configuration type\\n\")\n{\n  bgp_option_unset (BGP_OPT_CONFIG_CISCO);\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_synchronization,\n       no_synchronization_cmd,\n       \"no synchronization\",\n       NO_STR\n       \"Perform IGP synchronization\\n\")\n{\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_auto_summary,\n       no_auto_summary_cmd,\n       \"no auto-summary\",\n       NO_STR\n       \"Enable automatic network number summarization\\n\")\n{\n  return CMD_SUCCESS;\n}\n\nDEFUN_DEPRECATED (neighbor_version,\n\t\t  neighbor_version_cmd,\n\t\t  NEIGHBOR_CMD \"version (4|4-)\",\n\t\t  NEIGHBOR_STR\n\t\t  NEIGHBOR_ADDR_STR\n\t\t  \"Set the BGP version to match a neighbor\\n\"\n\t\t  \"Neighbor's BGP version\\n\")\n{\n  return CMD_SUCCESS;\n}\n\f\n/* \"router bgp\" commands. */\nDEFUN (router_bgp, \n       router_bgp_cmd, \n       \"router bgp <1-65535>\",\n       ROUTER_STR\n       BGP_STR\n       AS_STR)\n{\n  int ret;\n  as_t as;\n  struct bgp *bgp;\n  const char *name = NULL;\n\n  VTY_GET_INTEGER_RANGE (\"AS\", as, argv[0], 1, 65535);\n\n  if (argc == 2)\n    name = argv[1];\n\n  ret = bgp_get (&bgp, &as, name);\n  switch (ret)\n    {\n    case BGP_ERR_MULTIPLE_INSTANCE_NOT_SET:\n      vty_out (vty, \"Please specify 'bgp multiple-instance' first%s\", \n\t       VTY_NEWLINE);\n      return CMD_WARNING;\n    case BGP_ERR_AS_MISMATCH:\n      vty_out (vty, \"BGP is already running; AS is %d%s\", as, VTY_NEWLINE);\n      return CMD_WARNING;\n    case BGP_ERR_INSTANCE_MISMATCH:\n      vty_out (vty, \"BGP view name and AS number mismatch%s\", VTY_NEWLINE);\n      vty_out (vty, \"BGP instance is already running; AS is %d%s\",\n\t       as, VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  vty->node = BGP_NODE;\n  vty->index = bgp;\n\n  return CMD_SUCCESS;\n}\n\nALIAS (router_bgp,\n       router_bgp_view_cmd,\n       \"router bgp <1-65535> view WORD\",\n       ROUTER_STR\n       BGP_STR\n       AS_STR\n       \"BGP view\\n\"\n       \"view name\\n\")\n\f\n/* \"no router bgp\" commands. */\nDEFUN (no_router_bgp,\n       no_router_bgp_cmd,\n       \"no router bgp <1-65535>\",\n       NO_STR\n       ROUTER_STR\n       BGP_STR\n       AS_STR)\n{\n  as_t as;\n  struct bgp *bgp;\n  const char *name = NULL;\n\n  VTY_GET_INTEGER_RANGE (\"AS\", as, argv[0], 1, 65535);\n\n  if (argc == 2)\n    name = argv[1];\n\n  /* Lookup bgp structure. */\n  bgp = bgp_lookup (as, name);\n  if (! bgp)\n    {\n      vty_out (vty, \"%% Can't find BGP instance%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  bgp_delete (bgp);\n\n  return CMD_SUCCESS;\n}\n\nALIAS (no_router_bgp,\n       no_router_bgp_view_cmd,\n       \"no router bgp <1-65535> view WORD\",\n       NO_STR\n       ROUTER_STR\n       BGP_STR\n       AS_STR\n       \"BGP view\\n\"\n       \"view name\\n\")\n\f\n/* BGP router-id.  */\n\nDEFUN (bgp_router_id,\n       bgp_router_id_cmd,\n       \"bgp router-id A.B.C.D\",\n       BGP_STR\n       \"Override configured router identifier\\n\"\n       \"Manually configured router identifier\\n\")\n{\n  int ret;\n  struct in_addr id;\n  struct bgp *bgp;\n\n  bgp = vty->index;\n\n  ret = inet_aton (argv[0], &id);\n  if (! ret)\n    {\n      vty_out (vty, \"%% Malformed bgp router identifier%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  bgp->router_id_static = id;\n  bgp_router_id_set (bgp, &id);\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_bgp_router_id,\n       no_bgp_router_id_cmd,\n       \"no bgp router-id\",\n       NO_STR\n       BGP_STR\n       \"Override configured router identifier\\n\")\n{\n  int ret;\n  struct in_addr id;\n  struct bgp *bgp;\n\n  bgp = vty->index;\n\n  if (argc == 1)\n    {\n      ret = inet_aton (argv[0], &id);\n      if (! ret)\n\t{\n\t  vty_out (vty, \"%% Malformed BGP router identifier%s\", VTY_NEWLINE);\n\t  return CMD_WARNING;\n\t}\n\n      if (! IPV4_ADDR_SAME (&bgp->router_id_static, &id))\n\t{\n\t  vty_out (vty, \"%% BGP router-id doesn't match%s\", VTY_NEWLINE);\n\t  return CMD_WARNING;\n\t}\n    }\n\n  bgp->router_id_static.s_addr = 0;\n  bgp_router_id_set (bgp, &router_id_zebra);\n\n  return CMD_SUCCESS;\n}\n\nALIAS (no_bgp_router_id,\n       no_bgp_router_id_val_cmd,\n       \"no bgp router-id A.B.C.D\",\n       NO_STR\n       BGP_STR\n       \"Override configured router identifier\\n\"\n       \"Manually configured router identifier\\n\")\n\f\n/* BGP Cluster ID.  */\n\nDEFUN (bgp_cluster_id,\n       bgp_cluster_id_cmd,\n       \"bgp cluster-id A.B.C.D\",\n       BGP_STR\n       \"Configure Route-Reflector Cluster-id\\n\"\n       \"Route-Reflector Cluster-id in IP address format\\n\")\n{\n  int ret;\n  struct bgp *bgp;\n  struct in_addr cluster;\n\n  bgp = vty->index;\n\n  ret = inet_aton (argv[0], &cluster);\n  if (! ret)\n    {\n      vty_out (vty, \"%% Malformed bgp cluster identifier%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  bgp_cluster_id_set (bgp, &cluster);\n\n  return CMD_SUCCESS;\n}\n\nALIAS (bgp_cluster_id,\n       bgp_cluster_id32_cmd,\n       \"bgp cluster-id <1-4294967295>\",\n       BGP_STR\n       \"Configure Route-Reflector Cluster-id\\n\"\n       \"Route-Reflector Cluster-id as 32 bit quantity\\n\")\n\nDEFUN (no_bgp_cluster_id,\n       no_bgp_cluster_id_cmd,\n       \"no bgp cluster-id\",\n       NO_STR\n       BGP_STR\n       \"Configure Route-Reflector Cluster-id\\n\")\n{\n  int ret;\n  struct bgp *bgp;\n  struct in_addr cluster;\n\n  bgp = vty->index;\n\n  if (argc == 1)\n    {\n      ret = inet_aton (argv[0], &cluster);\n      if (! ret)\n\t{\n\t  vty_out (vty, \"%% Malformed bgp cluster identifier%s\", VTY_NEWLINE);\n\t  return CMD_WARNING;\n\t}\n    }\n\n  bgp_cluster_id_unset (bgp);\n\n  return CMD_SUCCESS;\n}\n\nALIAS (no_bgp_cluster_id,\n       no_bgp_cluster_id_arg_cmd,\n       \"no bgp cluster-id A.B.C.D\",\n       NO_STR\n       BGP_STR\n       \"Configure Route-Reflector Cluster-id\\n\"\n       \"Route-Reflector Cluster-id in IP address format\\n\")\n\f\nDEFUN (bgp_confederation_identifier,\n       bgp_confederation_identifier_cmd,\n       \"bgp confederation identifier <1-65535>\",\n       \"BGP specific commands\\n\"\n       \"AS confederation parameters\\n\"\n       \"AS number\\n\"\n       \"Set routing domain confederation AS\\n\")\n{\n  struct bgp *bgp;\n  as_t as;\n\n  bgp = vty->index;\n\n  VTY_GET_INTEGER (\"AS\", as, argv[0]);\n\n  bgp_confederation_id_set (bgp, as);\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_bgp_confederation_identifier,\n       no_bgp_confederation_identifier_cmd,\n       \"no bgp confederation identifier\",\n       NO_STR\n       \"BGP specific commands\\n\"\n       \"AS confederation parameters\\n\"\n       \"AS number\\n\")\n{\n  struct bgp *bgp;\n  as_t as;\n\n  bgp = vty->index;\n\n  if (argc == 1)\n    VTY_GET_INTEGER (\"AS\", as, argv[0]);\n\n  bgp_confederation_id_unset (bgp);\n\n  return CMD_SUCCESS;\n}\n\nALIAS (no_bgp_confederation_identifier,\n       no_bgp_confederation_identifier_arg_cmd,\n       \"no bgp confederation identifier <1-65535>\",\n       NO_STR\n       \"BGP specific commands\\n\"\n       \"AS confederation parameters\\n\"\n       \"AS number\\n\"\n       \"Set routing domain confederation AS\\n\")\n\f\nDEFUN (bgp_confederation_peers,\n       bgp_confederation_peers_cmd,\n       \"bgp confederation peers .<1-65535>\",\n       \"BGP specific commands\\n\"\n       \"AS confederation parameters\\n\"\n       \"Peer ASs in BGP confederation\\n\"\n       AS_STR)\n{\n  struct bgp *bgp;\n  as_t as;\n  int i;\n\n  bgp = vty->index;\n\n  for (i = 0; i < argc; i++)\n    {\n      VTY_GET_INTEGER_RANGE (\"AS\", as, argv[i], 1, 65535);\n\n      if (bgp->as == as)\n\t{\n\t  vty_out (vty, \"%% Local member-AS not allowed in confed peer list%s\",\n\t\t   VTY_NEWLINE);\n\t  continue;\n\t}\n\n      bgp_confederation_peers_add (bgp, as);\n    }\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_bgp_confederation_peers,\n       no_bgp_confederation_peers_cmd,\n       \"no bgp confederation peers .<1-65535>\",\n       NO_STR\n       \"BGP specific commands\\n\"\n       \"AS confederation parameters\\n\"\n       \"Peer ASs in BGP confederation\\n\"\n       AS_STR)\n{\n  struct bgp *bgp;\n  as_t as;\n  int i;\n\n  bgp = vty->index;\n\n  for (i = 0; i < argc; i++)\n    {\n      VTY_GET_INTEGER_RANGE (\"AS\", as, argv[i], 1, 65535);\n      \n      bgp_confederation_peers_remove (bgp, as);\n    }\n  return CMD_SUCCESS;\n}\n\f\n/* BGP timers.  */\n\nDEFUN (bgp_timers,\n       bgp_timers_cmd,\n       \"timers bgp <0-65535> <0-65535>\",\n       \"Adjust routing timers\\n\"\n       \"BGP timers\\n\"\n       \"Keepalive interval\\n\"\n       \"Holdtime\\n\")\n{\n  struct bgp *bgp;\n  unsigned long keepalive = 0;\n  unsigned long holdtime = 0;\n\n  bgp = vty->index;\n\n  VTY_GET_INTEGER (\"keepalive\", keepalive, argv[0]);\n  VTY_GET_INTEGER (\"holdtime\", holdtime, argv[1]);\n\n  /* Holdtime value check. */\n  if (holdtime < 3 && holdtime != 0)\n    {\n      vty_out (vty, \"%% hold time value must be either 0 or greater than 3%s\",\n\t       VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  bgp_timers_set (bgp, keepalive, holdtime);\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_bgp_timers,\n       no_bgp_timers_cmd,\n       \"no timers bgp\",\n       NO_STR\n       \"Adjust routing timers\\n\"\n       \"BGP timers\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_timers_unset (bgp);\n\n  return CMD_SUCCESS;\n}\n\nALIAS (no_bgp_timers,\n       no_bgp_timers_arg_cmd,\n       \"no timers bgp <0-65535> <0-65535>\",\n       NO_STR\n       \"Adjust routing timers\\n\"\n       \"BGP timers\\n\"\n       \"Keepalive interval\\n\"\n       \"Holdtime\\n\")\n\f\nDEFUN (bgp_client_to_client_reflection,\n       bgp_client_to_client_reflection_cmd,\n       \"bgp client-to-client reflection\",\n       \"BGP specific commands\\n\"\n       \"Configure client to client route reflection\\n\"\n       \"reflection of routes allowed\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_flag_unset (bgp, BGP_FLAG_NO_CLIENT_TO_CLIENT);\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_bgp_client_to_client_reflection,\n       no_bgp_client_to_client_reflection_cmd,\n       \"no bgp client-to-client reflection\",\n       NO_STR\n       \"BGP specific commands\\n\"\n       \"Configure client to client route reflection\\n\"\n       \"reflection of routes allowed\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_flag_set (bgp, BGP_FLAG_NO_CLIENT_TO_CLIENT);\n  return CMD_SUCCESS;\n}\n\n/* \"bgp always-compare-med\" configuration. */\nDEFUN (bgp_always_compare_med,\n       bgp_always_compare_med_cmd,\n       \"bgp always-compare-med\",\n       \"BGP specific commands\\n\"\n       \"Allow comparing MED from different neighbors\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_flag_set (bgp, BGP_FLAG_ALWAYS_COMPARE_MED);\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_bgp_always_compare_med,\n       no_bgp_always_compare_med_cmd,\n       \"no bgp always-compare-med\",\n       NO_STR\n       \"BGP specific commands\\n\"\n       \"Allow comparing MED from different neighbors\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_flag_unset (bgp, BGP_FLAG_ALWAYS_COMPARE_MED);\n  return CMD_SUCCESS;\n}\n\f\n/* \"bgp deterministic-med\" configuration. */\nDEFUN (bgp_deterministic_med,\n       bgp_deterministic_med_cmd,\n       \"bgp deterministic-med\",\n       \"BGP specific commands\\n\"\n       \"Pick the best-MED path among paths advertised from the neighboring AS\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_flag_set (bgp, BGP_FLAG_DETERMINISTIC_MED);\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_bgp_deterministic_med,\n       no_bgp_deterministic_med_cmd,\n       \"no bgp deterministic-med\",\n       NO_STR\n       \"BGP specific commands\\n\"\n       \"Pick the best-MED path among paths advertised from the neighboring AS\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_flag_unset (bgp, BGP_FLAG_DETERMINISTIC_MED);\n  return CMD_SUCCESS;\n}\n\n/* \"bgp graceful-restart\" configuration. */\nDEFUN (bgp_graceful_restart,\n       bgp_graceful_restart_cmd,\n       \"bgp graceful-restart\",\n       \"BGP specific commands\\n\"\n       \"Graceful restart capability parameters\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_flag_set (bgp, BGP_FLAG_GRACEFUL_RESTART);\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_bgp_graceful_restart,\n       no_bgp_graceful_restart_cmd,\n       \"no bgp graceful-restart\",\n       NO_STR\n       \"BGP specific commands\\n\"\n       \"Graceful restart capability parameters\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_flag_unset (bgp, BGP_FLAG_GRACEFUL_RESTART);\n  return CMD_SUCCESS;\n}\n\nDEFUN (bgp_graceful_restart_stalepath_time,\n       bgp_graceful_restart_stalepath_time_cmd,\n       \"bgp graceful-restart stalepath-time <1-3600>\",\n       \"BGP specific commands\\n\"\n       \"Graceful restart capability parameters\\n\"\n       \"Set the max time to hold onto restarting peer's stale paths\\n\"\n       \"Delay value (seconds)\\n\")\n{\n  struct bgp *bgp;\n  u_int32_t stalepath;\n\n  bgp = vty->index;\n  if (! bgp)\n    return CMD_WARNING;\n\n  VTY_GET_INTEGER_RANGE (\"stalepath-time\", stalepath, argv[0], 1, 3600);\n  bgp->stalepath_time = stalepath;\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_bgp_graceful_restart_stalepath_time,\n       no_bgp_graceful_restart_stalepath_time_cmd,\n       \"no bgp graceful-restart stalepath-time\",\n       NO_STR\n       \"BGP specific commands\\n\"\n       \"Graceful restart capability parameters\\n\"\n       \"Set the max time to hold onto restarting peer's stale paths\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  if (! bgp)\n    return CMD_WARNING;\n\n  bgp->stalepath_time = BGP_DEFAULT_STALEPATH_TIME;\n  return CMD_SUCCESS;\n}\n\nALIAS (no_bgp_graceful_restart_stalepath_time,\n       no_bgp_graceful_restart_stalepath_time_val_cmd,\n       \"no bgp graceful-restart stalepath-time <1-3600>\",\n       NO_STR\n       \"BGP specific commands\\n\"\n       \"Graceful restart capability parameters\\n\"\n       \"Set the max time to hold onto restarting peer's stale paths\\n\"\n       \"Delay value (seconds)\\n\")\n\n/* \"bgp fast-external-failover\" configuration. */\nDEFUN (bgp_fast_external_failover,\n       bgp_fast_external_failover_cmd,\n       \"bgp fast-external-failover\",\n       BGP_STR\n       \"Immediately reset session if a link to a directly connected external peer goes down\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_flag_unset (bgp, BGP_FLAG_NO_FAST_EXT_FAILOVER);\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_bgp_fast_external_failover,\n       no_bgp_fast_external_failover_cmd,\n       \"no bgp fast-external-failover\",\n       NO_STR\n       BGP_STR\n       \"Immediately reset session if a link to a directly connected external peer goes down\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_flag_set (bgp, BGP_FLAG_NO_FAST_EXT_FAILOVER);\n  return CMD_SUCCESS;\n}\n\f\n/* \"bgp enforce-first-as\" configuration. */\nDEFUN (bgp_enforce_first_as,\n       bgp_enforce_first_as_cmd,\n       \"bgp enforce-first-as\",\n       BGP_STR\n       \"Enforce the first AS for EBGP routes\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_flag_set (bgp, BGP_FLAG_ENFORCE_FIRST_AS);\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_bgp_enforce_first_as,\n       no_bgp_enforce_first_as_cmd,\n       \"no bgp enforce-first-as\",\n       NO_STR\n       BGP_STR\n       \"Enforce the first AS for EBGP routes\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_flag_unset (bgp, BGP_FLAG_ENFORCE_FIRST_AS);\n  return CMD_SUCCESS;\n}\n\f\n/* \"bgp bestpath compare-routerid\" configuration.  */\nDEFUN (bgp_bestpath_compare_router_id,\n       bgp_bestpath_compare_router_id_cmd,\n       \"bgp bestpath compare-routerid\",\n       \"BGP specific commands\\n\"\n       \"Change the default bestpath selection\\n\"\n       \"Compare router-id for identical EBGP paths\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_flag_set (bgp, BGP_FLAG_COMPARE_ROUTER_ID);\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_bgp_bestpath_compare_router_id,\n       no_bgp_bestpath_compare_router_id_cmd,\n       \"no bgp bestpath compare-routerid\",\n       NO_STR\n       \"BGP specific commands\\n\"\n       \"Change the default bestpath selection\\n\"\n       \"Compare router-id for identical EBGP paths\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_flag_unset (bgp, BGP_FLAG_COMPARE_ROUTER_ID);\n  return CMD_SUCCESS;\n}\n\f\n/* \"bgp bestpath as-path ignore\" configuration.  */\nDEFUN (bgp_bestpath_aspath_ignore,\n       bgp_bestpath_aspath_ignore_cmd,\n       \"bgp bestpath as-path ignore\",\n       \"BGP specific commands\\n\"\n       \"Change the default bestpath selection\\n\"\n       \"AS-path attribute\\n\"\n       \"Ignore as-path length in selecting a route\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_flag_set (bgp, BGP_FLAG_ASPATH_IGNORE);\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_bgp_bestpath_aspath_ignore,\n       no_bgp_bestpath_aspath_ignore_cmd,\n       \"no bgp bestpath as-path ignore\",\n       NO_STR\n       \"BGP specific commands\\n\"\n       \"Change the default bestpath selection\\n\"\n       \"AS-path attribute\\n\"\n       \"Ignore as-path length in selecting a route\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_flag_unset (bgp, BGP_FLAG_ASPATH_IGNORE);\n  return CMD_SUCCESS;\n}\n\f\n/* \"bgp bestpath as-path confed\" configuration.  */\nDEFUN (bgp_bestpath_aspath_confed,\n       bgp_bestpath_aspath_confed_cmd,\n       \"bgp bestpath as-path confed\",\n       \"BGP specific commands\\n\"\n       \"Change the default bestpath selection\\n\"\n       \"AS-path attribute\\n\"\n       \"Compare path lengths including confederation sets & sequences in selecting a route\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_flag_set (bgp, BGP_FLAG_ASPATH_CONFED);\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_bgp_bestpath_aspath_confed,\n       no_bgp_bestpath_aspath_confed_cmd,\n       \"no bgp bestpath as-path confed\",\n       NO_STR\n       \"BGP specific commands\\n\"\n       \"Change the default bestpath selection\\n\"\n       \"AS-path attribute\\n\"\n       \"Compare path lengths including confederation sets & sequences in selecting a route\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_flag_unset (bgp, BGP_FLAG_ASPATH_CONFED);\n  return CMD_SUCCESS;\n}\n\f\n/* \"bgp log-neighbor-changes\" configuration.  */\nDEFUN (bgp_log_neighbor_changes,\n       bgp_log_neighbor_changes_cmd,\n       \"bgp log-neighbor-changes\",\n       \"BGP specific commands\\n\"\n       \"Log neighbor up/down and reset reason\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_flag_set (bgp, BGP_FLAG_LOG_NEIGHBOR_CHANGES);\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_bgp_log_neighbor_changes,\n       no_bgp_log_neighbor_changes_cmd,\n       \"no bgp log-neighbor-changes\",\n       NO_STR\n       \"BGP specific commands\\n\"\n       \"Log neighbor up/down and reset reason\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_flag_unset (bgp, BGP_FLAG_LOG_NEIGHBOR_CHANGES);\n  return CMD_SUCCESS;\n}\n\f\n/* \"bgp bestpath med\" configuration. */\nDEFUN (bgp_bestpath_med,\n       bgp_bestpath_med_cmd,\n       \"bgp bestpath med (confed|missing-as-worst)\",\n       \"BGP specific commands\\n\"\n       \"Change the default bestpath selection\\n\"\n       \"MED attribute\\n\"\n       \"Compare MED among confederation paths\\n\"\n       \"Treat missing MED as the least preferred one\\n\")\n{\n  struct bgp *bgp;\n  \n  bgp = vty->index;\n\n  if (strncmp (argv[0], \"confed\", 1) == 0)\n    bgp_flag_set (bgp, BGP_FLAG_MED_CONFED);\n  else\n    bgp_flag_set (bgp, BGP_FLAG_MED_MISSING_AS_WORST);\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (bgp_bestpath_med2,\n       bgp_bestpath_med2_cmd,\n       \"bgp bestpath med confed missing-as-worst\",\n       \"BGP specific commands\\n\"\n       \"Change the default bestpath selection\\n\"\n       \"MED attribute\\n\"\n       \"Compare MED among confederation paths\\n\"\n       \"Treat missing MED as the least preferred one\\n\")\n{\n  struct bgp *bgp;\n  \n  bgp = vty->index;\n  bgp_flag_set (bgp, BGP_FLAG_MED_CONFED);\n  bgp_flag_set (bgp, BGP_FLAG_MED_MISSING_AS_WORST);\n  return CMD_SUCCESS;\n}\n\nALIAS (bgp_bestpath_med2,\n       bgp_bestpath_med3_cmd,\n       \"bgp bestpath med missing-as-worst confed\",\n       \"BGP specific commands\\n\"\n       \"Change the default bestpath selection\\n\"\n       \"MED attribute\\n\"\n       \"Treat missing MED as the least preferred one\\n\"\n       \"Compare MED among confederation paths\\n\")\n\nDEFUN (no_bgp_bestpath_med,\n       no_bgp_bestpath_med_cmd,\n       \"no bgp bestpath med (confed|missing-as-worst)\",\n       NO_STR\n       \"BGP specific commands\\n\"\n       \"Change the default bestpath selection\\n\"\n       \"MED attribute\\n\"\n       \"Compare MED among confederation paths\\n\"\n       \"Treat missing MED as the least preferred one\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  \n  if (strncmp (argv[0], \"confed\", 1) == 0)\n    bgp_flag_unset (bgp, BGP_FLAG_MED_CONFED);\n  else\n    bgp_flag_unset (bgp, BGP_FLAG_MED_MISSING_AS_WORST);\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_bgp_bestpath_med2,\n       no_bgp_bestpath_med2_cmd,\n       \"no bgp bestpath med confed missing-as-worst\",\n       NO_STR\n       \"BGP specific commands\\n\"\n       \"Change the default bestpath selection\\n\"\n       \"MED attribute\\n\"\n       \"Compare MED among confederation paths\\n\"\n       \"Treat missing MED as the least preferred one\\n\")\n{\n  struct bgp *bgp;\n  \n  bgp = vty->index;\n  bgp_flag_unset (bgp, BGP_FLAG_MED_CONFED);\n  bgp_flag_unset (bgp, BGP_FLAG_MED_MISSING_AS_WORST);\n  return CMD_SUCCESS;\n}\n\nALIAS (no_bgp_bestpath_med2,\n       no_bgp_bestpath_med3_cmd,\n       \"no bgp bestpath med missing-as-worst confed\",\n       NO_STR\n       \"BGP specific commands\\n\"\n       \"Change the default bestpath selection\\n\"\n       \"MED attribute\\n\"\n       \"Treat missing MED as the least preferred one\\n\"\n       \"Compare MED among confederation paths\\n\")\n\f\n/* \"no bgp default ipv4-unicast\". */\nDEFUN (no_bgp_default_ipv4_unicast,\n       no_bgp_default_ipv4_unicast_cmd,\n       \"no bgp default ipv4-unicast\",\n       NO_STR\n       \"BGP specific commands\\n\"\n       \"Configure BGP defaults\\n\"\n       \"Activate ipv4-unicast for a peer by default\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_flag_set (bgp, BGP_FLAG_NO_DEFAULT_IPV4);\n  return CMD_SUCCESS;\n}\n\nDEFUN (bgp_default_ipv4_unicast,\n       bgp_default_ipv4_unicast_cmd,\n       \"bgp default ipv4-unicast\",\n       \"BGP specific commands\\n\"\n       \"Configure BGP defaults\\n\"\n       \"Activate ipv4-unicast for a peer by default\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_flag_unset (bgp, BGP_FLAG_NO_DEFAULT_IPV4);\n  return CMD_SUCCESS;\n}\n\f\n/* \"bgp import-check\" configuration.  */\nDEFUN (bgp_network_import_check,\n       bgp_network_import_check_cmd,\n       \"bgp network import-check\",\n       \"BGP specific commands\\n\"\n       \"BGP network command\\n\"\n       \"Check BGP network route exists in IGP\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_flag_set (bgp, BGP_FLAG_IMPORT_CHECK);\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_bgp_network_import_check,\n       no_bgp_network_import_check_cmd,\n       \"no bgp network import-check\",\n       NO_STR\n       \"BGP specific commands\\n\"\n       \"BGP network command\\n\"\n       \"Check BGP network route exists in IGP\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_flag_unset (bgp, BGP_FLAG_IMPORT_CHECK);\n  return CMD_SUCCESS;\n}\n\f\nDEFUN (bgp_default_local_preference,\n       bgp_default_local_preference_cmd,\n       \"bgp default local-preference <0-4294967295>\",\n       \"BGP specific commands\\n\"\n       \"Configure BGP defaults\\n\"\n       \"local preference (higher=more preferred)\\n\"\n       \"Configure default local preference value\\n\")\n{\n  struct bgp *bgp;\n  u_int32_t local_pref;\n\n  bgp = vty->index;\n\n  VTY_GET_INTEGER (\"local preference\", local_pref, argv[0]);\n\n  bgp_default_local_preference_set (bgp, local_pref);\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_bgp_default_local_preference,\n       no_bgp_default_local_preference_cmd,\n       \"no bgp default local-preference\",\n       NO_STR\n       \"BGP specific commands\\n\"\n       \"Configure BGP defaults\\n\"\n       \"local preference (higher=more preferred)\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_default_local_preference_unset (bgp);\n  return CMD_SUCCESS;\n}\n\nALIAS (no_bgp_default_local_preference,\n       no_bgp_default_local_preference_val_cmd,\n       \"no bgp default local-preference <0-4294967295>\",\n       NO_STR\n       \"BGP specific commands\\n\"\n       \"Configure BGP defaults\\n\"\n       \"local preference (higher=more preferred)\\n\"\n       \"Configure default local preference value\\n\")\n\f\nstatic int\npeer_remote_as_vty (struct vty *vty, const char *peer_str, \n                    const char *as_str, afi_t afi, safi_t safi)\n{\n  int ret;\n  struct bgp *bgp;\n  as_t as;\n  union sockunion su;\n\n  bgp = vty->index;\n\n  /* Get AS number.  */\n  VTY_GET_INTEGER_RANGE (\"AS\", as, as_str, 1, 65535);\n\n  /* If peer is peer group, call proper function.  */\n  ret = str2sockunion (peer_str, &su);\n  if (ret < 0)\n    {\n      ret = peer_group_remote_as (bgp, peer_str, &as);\n      if (ret < 0)\n\t{\n\t  vty_out (vty, \"%% Create the peer-group first%s\", VTY_NEWLINE);\n\t  return CMD_WARNING;\n\t}\n      return CMD_SUCCESS;\n    }\n\n  if (peer_address_self_check (&su))\n    {\n      vty_out (vty, \"%% Can not configure the local system as neighbor%s\",\n\t       VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  ret = peer_remote_as (bgp, &su, &as, afi, safi);\n\n  /* This peer belongs to peer group.  */\n  switch (ret)\n    {\n    case BGP_ERR_PEER_GROUP_MEMBER:\n      vty_out (vty, \"%% Peer-group AS %d. Cannot configure remote-as for member%s\", as, VTY_NEWLINE);\n      return CMD_WARNING;\n    case BGP_ERR_PEER_GROUP_PEER_TYPE_DIFFERENT:\n      vty_out (vty, \"%% The AS# can not be changed from %d to %s, peer-group members must be all internal or all external%s\", as, as_str, VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n  return bgp_vty_return (vty, ret);\n}\n\nDEFUN (neighbor_remote_as,\n       neighbor_remote_as_cmd,\n       NEIGHBOR_CMD2 \"remote-as <1-65535>\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Specify a BGP neighbor\\n\"\n       AS_STR)\n{\n  return peer_remote_as_vty (vty, argv[0], argv[1], AFI_IP, SAFI_UNICAST);\n}\n\f\nDEFUN (neighbor_peer_group,\n       neighbor_peer_group_cmd,\n       \"neighbor WORD peer-group\",\n       NEIGHBOR_STR\n       \"Neighbor tag\\n\"\n       \"Configure peer-group\\n\")\n{\n  struct bgp *bgp;\n  struct peer_group *group;\n\n  bgp = vty->index;\n\n  group = peer_group_get (bgp, argv[0]);\n  if (! group)\n    return CMD_WARNING;\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_neighbor,\n       no_neighbor_cmd,\n       NO_NEIGHBOR_CMD2,\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2)\n{\n  int ret;\n  union sockunion su;\n  struct peer_group *group;\n  struct peer *peer;\n\n  ret = str2sockunion (argv[0], &su);\n  if (ret < 0)\n    {\n      group = peer_group_lookup (vty->index, argv[0]);\n      if (group)\n\tpeer_group_delete (group);\n      else\n\t{\n\t  vty_out (vty, \"%% Create the peer-group first%s\", VTY_NEWLINE);\n\t  return CMD_WARNING;\n\t}\n    }\n  else\n    {\n      peer = peer_lookup (vty->index, &su);\n      if (peer)\n        peer_delete (peer);\n    }\n\n  return CMD_SUCCESS;\n}\n\nALIAS (no_neighbor,\n       no_neighbor_remote_as_cmd,\n       NO_NEIGHBOR_CMD \"remote-as <1-65535>\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR\n       \"Specify a BGP neighbor\\n\"\n       AS_STR)\n\nDEFUN (no_neighbor_peer_group,\n       no_neighbor_peer_group_cmd,\n       \"no neighbor WORD peer-group\",\n       NO_STR\n       NEIGHBOR_STR\n       \"Neighbor tag\\n\"\n       \"Configure peer-group\\n\")\n{\n  struct peer_group *group;\n\n  group = peer_group_lookup (vty->index, argv[0]);\n  if (group)\n    peer_group_delete (group);\n  else\n    {\n      vty_out (vty, \"%% Create the peer-group first%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_neighbor_peer_group_remote_as,\n       no_neighbor_peer_group_remote_as_cmd,\n       \"no neighbor WORD remote-as <1-65535>\",\n       NO_STR\n       NEIGHBOR_STR\n       \"Neighbor tag\\n\"\n       \"Specify a BGP neighbor\\n\"\n       AS_STR)\n{\n  struct peer_group *group;\n\n  group = peer_group_lookup (vty->index, argv[0]);\n  if (group)\n    peer_group_remote_as_delete (group);\n  else\n    {\n      vty_out (vty, \"%% Create the peer-group first%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n  return CMD_SUCCESS;\n}\n\f\nDEFUN (neighbor_local_as,\n       neighbor_local_as_cmd,\n       NEIGHBOR_CMD2 \"local-as <1-65535>\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Specify a local-as number\\n\"\n       \"AS number used as local AS\\n\")\n{\n  struct peer *peer;\n  int ret;\n\n  peer = peer_and_group_lookup_vty (vty, argv[0]);\n  if (! peer)\n    return CMD_WARNING;\n\n  ret = peer_local_as_set (peer, atoi (argv[1]), 0);\n  return bgp_vty_return (vty, ret);\n}\n\nDEFUN (neighbor_local_as_no_prepend,\n       neighbor_local_as_no_prepend_cmd,\n       NEIGHBOR_CMD2 \"local-as <1-65535> no-prepend\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Specify a local-as number\\n\"\n       \"AS number used as local AS\\n\"\n       \"Do not prepend local-as to updates from ebgp peers\\n\")\n{\n  struct peer *peer;\n  int ret;\n\n  peer = peer_and_group_lookup_vty (vty, argv[0]);\n  if (! peer)\n    return CMD_WARNING;\n\n  ret = peer_local_as_set (peer, atoi (argv[1]), 1);\n  return bgp_vty_return (vty, ret);\n}\n\nDEFUN (no_neighbor_local_as,\n       no_neighbor_local_as_cmd,\n       NO_NEIGHBOR_CMD2 \"local-as\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Specify a local-as number\\n\")\n{\n  struct peer *peer;\n  int ret;\n\n  peer = peer_and_group_lookup_vty (vty, argv[0]);\n  if (! peer)\n    return CMD_WARNING;\n\n  ret = peer_local_as_unset (peer);\n  return bgp_vty_return (vty, ret);\n}\n\nALIAS (no_neighbor_local_as,\n       no_neighbor_local_as_val_cmd,\n       NO_NEIGHBOR_CMD2 \"local-as <1-65535>\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Specify a local-as number\\n\"\n       \"AS number used as local AS\\n\")\n\nALIAS (no_neighbor_local_as,\n       no_neighbor_local_as_val2_cmd,\n       NO_NEIGHBOR_CMD2 \"local-as <1-65535> no-prepend\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Specify a local-as number\\n\"\n       \"AS number used as local AS\\n\"\n       \"Do not prepend local-as to updates from ebgp peers\\n\")\n\f\nDEFUN (neighbor_activate,\n       neighbor_activate_cmd,\n       NEIGHBOR_CMD2 \"activate\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Enable the Address Family for this Neighbor\\n\")\n{\n  struct peer *peer;\n\n  peer = peer_and_group_lookup_vty (vty, argv[0]);\n  if (! peer)\n    return CMD_WARNING;\n\n  peer_activate (peer, bgp_node_afi (vty), bgp_node_safi (vty));\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_neighbor_activate,\n       no_neighbor_activate_cmd,\n       NO_NEIGHBOR_CMD2 \"activate\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Enable the Address Family for this Neighbor\\n\")\n{\n  int ret;\n  struct peer *peer;\n\n  /* Lookup peer. */\n  peer = peer_and_group_lookup_vty (vty, argv[0]);\n  if (! peer)\n    return CMD_WARNING;\n\n  ret = peer_deactivate (peer, bgp_node_afi (vty), bgp_node_safi (vty));\n\n  return bgp_vty_return (vty, ret);\n}\n\f\nDEFUN (neighbor_set_peer_group,\n       neighbor_set_peer_group_cmd,\n       NEIGHBOR_CMD \"peer-group WORD\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR\n       \"Member of the peer-group\\n\"\n       \"peer-group name\\n\")\n{\n  int ret;\n  as_t as;\n  union sockunion su;\n  struct bgp *bgp;\n  struct peer_group *group;\n\n  bgp = vty->index;\n\n  ret = str2sockunion (argv[0], &su);\n  if (ret < 0)\n    {\n      vty_out (vty, \"%% Malformed address: %s%s\", argv[0], VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  group = peer_group_lookup (bgp, argv[1]);\n  if (! group)\n    {\n      vty_out (vty, \"%% Configure the peer-group first%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  if (peer_address_self_check (&su))\n    {\n      vty_out (vty, \"%% Can not configure the local system as neighbor%s\",\n\t       VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  ret = peer_group_bind (bgp, &su, group, bgp_node_afi (vty), \n\t\t\t bgp_node_safi (vty), &as);\n\n  if (ret == BGP_ERR_PEER_GROUP_PEER_TYPE_DIFFERENT)\n    {\n      vty_out (vty, \"%% Peer with AS %d cannot be in this peer-group, members must be all internal or all external%s\", as, VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  return bgp_vty_return (vty, ret);\n}\n\nDEFUN (no_neighbor_set_peer_group,\n       no_neighbor_set_peer_group_cmd,\n       NO_NEIGHBOR_CMD \"peer-group WORD\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR\n       \"Member of the peer-group\\n\"\n       \"peer-group name\\n\")\n{\n  int ret;\n  struct bgp *bgp;\n  struct peer *peer;\n  struct peer_group *group;\n\n  bgp = vty->index;\n\n  peer = peer_lookup_vty (vty, argv[0]);\n  if (! peer)\n    return CMD_WARNING;\n\n  group = peer_group_lookup (bgp, argv[1]);\n  if (! group)\n    {\n      vty_out (vty, \"%% Configure the peer-group first%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  ret = peer_group_unbind (bgp, peer, group, bgp_node_afi (vty),\n\t\t\t   bgp_node_safi (vty));\n\n  return bgp_vty_return (vty, ret);\n}\n\f\nstatic int\npeer_flag_modify_vty (struct vty *vty, const char *ip_str, \n                      u_int16_t flag, int set)\n{\n  int ret;\n  struct peer *peer;\n\n  peer = peer_and_group_lookup_vty (vty, ip_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  if (set)\n    ret = peer_flag_set (peer, flag);\n  else\n    ret = peer_flag_unset (peer, flag);\n\n  return bgp_vty_return (vty, ret);\n}\n\nstatic int\npeer_flag_set_vty (struct vty *vty, const char *ip_str, u_int16_t flag)\n{\n  return peer_flag_modify_vty (vty, ip_str, flag, 1);\n}\n\nstatic int\npeer_flag_unset_vty (struct vty *vty, const char *ip_str, u_int16_t flag)\n{\n  return peer_flag_modify_vty (vty, ip_str, flag, 0);\n}\n\n/* neighbor passive. */\nDEFUN (neighbor_passive,\n       neighbor_passive_cmd,\n       NEIGHBOR_CMD2 \"passive\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Don't send open messages to this neighbor\\n\")\n{\n  return peer_flag_set_vty (vty, argv[0], PEER_FLAG_PASSIVE);\n}\n\nDEFUN (no_neighbor_passive,\n       no_neighbor_passive_cmd,\n       NO_NEIGHBOR_CMD2 \"passive\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Don't send open messages to this neighbor\\n\")\n{\n  return peer_flag_unset_vty (vty, argv[0], PEER_FLAG_PASSIVE);\n}\n\f\n/* neighbor shutdown. */\nDEFUN (neighbor_shutdown,\n       neighbor_shutdown_cmd,\n       NEIGHBOR_CMD2 \"shutdown\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Administratively shut down this neighbor\\n\")\n{\n  return peer_flag_set_vty (vty, argv[0], PEER_FLAG_SHUTDOWN);\n}\n\nDEFUN (no_neighbor_shutdown,\n       no_neighbor_shutdown_cmd,\n       NO_NEIGHBOR_CMD2 \"shutdown\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Administratively shut down this neighbor\\n\")\n{\n  return peer_flag_unset_vty (vty, argv[0], PEER_FLAG_SHUTDOWN);\n}\n\f\n/* Deprecated neighbor capability route-refresh. */\nDEFUN_DEPRECATED (neighbor_capability_route_refresh,\n\t\t  neighbor_capability_route_refresh_cmd,\n\t\t  NEIGHBOR_CMD2 \"capability route-refresh\",\n\t\t  NEIGHBOR_STR\n\t\t  NEIGHBOR_ADDR_STR2\n\t\t  \"Advertise capability to the peer\\n\"\n\t\t  \"Advertise route-refresh capability to this neighbor\\n\")\n{\n  return CMD_SUCCESS;\n}\n\nDEFUN_DEPRECATED (no_neighbor_capability_route_refresh,\n\t\t  no_neighbor_capability_route_refresh_cmd,\n\t\t  NO_NEIGHBOR_CMD2 \"capability route-refresh\",\n\t\t  NO_STR\n\t\t  NEIGHBOR_STR\n\t\t  NEIGHBOR_ADDR_STR2\n\t\t  \"Advertise capability to the peer\\n\"\n\t\t  \"Advertise route-refresh capability to this neighbor\\n\")\n{\n  return CMD_SUCCESS;\n}\n\f\n/* neighbor capability dynamic. */\nDEFUN (neighbor_capability_dynamic,\n       neighbor_capability_dynamic_cmd,\n       NEIGHBOR_CMD2 \"capability dynamic\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Advertise capability to the peer\\n\"\n       \"Advertise dynamic capability to this neighbor\\n\")\n{\n  return peer_flag_set_vty (vty, argv[0], PEER_FLAG_DYNAMIC_CAPABILITY);\n}\n\nDEFUN (no_neighbor_capability_dynamic,\n       no_neighbor_capability_dynamic_cmd,\n       NO_NEIGHBOR_CMD2 \"capability dynamic\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Advertise capability to the peer\\n\"\n       \"Advertise dynamic capability to this neighbor\\n\")\n{\n  return peer_flag_unset_vty (vty, argv[0], PEER_FLAG_DYNAMIC_CAPABILITY);\n}\n\f\n/* neighbor dont-capability-negotiate */\nDEFUN (neighbor_dont_capability_negotiate,\n       neighbor_dont_capability_negotiate_cmd,\n       NEIGHBOR_CMD2 \"dont-capability-negotiate\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Do not perform capability negotiation\\n\")\n{\n  return peer_flag_set_vty (vty, argv[0], PEER_FLAG_DONT_CAPABILITY);\n}\n\nDEFUN (no_neighbor_dont_capability_negotiate,\n       no_neighbor_dont_capability_negotiate_cmd,\n       NO_NEIGHBOR_CMD2 \"dont-capability-negotiate\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Do not perform capability negotiation\\n\")\n{\n  return peer_flag_unset_vty (vty, argv[0], PEER_FLAG_DONT_CAPABILITY);\n}\n\f\nstatic int\npeer_af_flag_modify_vty (struct vty *vty, const char *peer_str, afi_t afi,\n\t\t\t safi_t safi, u_int32_t flag, int set)\n{\n  int ret;\n  struct peer *peer;\n\n  peer = peer_and_group_lookup_vty (vty, peer_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  if (set)\n    ret = peer_af_flag_set (peer, afi, safi, flag);\n  else\n    ret = peer_af_flag_unset (peer, afi, safi, flag);\n\n  return bgp_vty_return (vty, ret);\n}\n\nstatic int\npeer_af_flag_set_vty (struct vty *vty, const char *peer_str, afi_t afi,\n\t\t      safi_t safi, u_int32_t flag)\n{\n  return peer_af_flag_modify_vty (vty, peer_str, afi, safi, flag, 1);\n}\n\nstatic int\npeer_af_flag_unset_vty (struct vty *vty, const char *peer_str, afi_t afi,\n\t\t\tsafi_t safi, u_int32_t flag)\n{\n  return peer_af_flag_modify_vty (vty, peer_str, afi, safi, flag, 0);\n}\n\f\n/* neighbor capability orf prefix-list. */\nDEFUN (neighbor_capability_orf_prefix,\n       neighbor_capability_orf_prefix_cmd,\n       NEIGHBOR_CMD2 \"capability orf prefix-list (both|send|receive)\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Advertise capability to the peer\\n\"\n       \"Advertise ORF capability to the peer\\n\"\n       \"Advertise prefixlist ORF capability to this neighbor\\n\"\n       \"Capability to SEND and RECEIVE the ORF to/from this neighbor\\n\"\n       \"Capability to RECEIVE the ORF from this neighbor\\n\"\n       \"Capability to SEND the ORF to this neighbor\\n\")\n{\n  u_int16_t flag = 0;\n\n  if (strncmp (argv[1], \"s\", 1) == 0)\n    flag = PEER_FLAG_ORF_PREFIX_SM;\n  else if (strncmp (argv[1], \"r\", 1) == 0)\n    flag = PEER_FLAG_ORF_PREFIX_RM;\n  else if (strncmp (argv[1], \"b\", 1) == 0)\n    flag = PEER_FLAG_ORF_PREFIX_SM|PEER_FLAG_ORF_PREFIX_RM;\n  else\n    return CMD_WARNING;\n\n  return peer_af_flag_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t       bgp_node_safi (vty), flag);\n}\n\nDEFUN (no_neighbor_capability_orf_prefix,\n       no_neighbor_capability_orf_prefix_cmd,\n       NO_NEIGHBOR_CMD2 \"capability orf prefix-list (both|send|receive)\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Advertise capability to the peer\\n\"\n       \"Advertise ORF capability to the peer\\n\"\n       \"Advertise prefixlist ORF capability to this neighbor\\n\"\n       \"Capability to SEND and RECEIVE the ORF to/from this neighbor\\n\"\n       \"Capability to RECEIVE the ORF from this neighbor\\n\"\n       \"Capability to SEND the ORF to this neighbor\\n\")\n{\n  u_int16_t flag = 0;\n\n  if (strncmp (argv[1], \"s\", 1) == 0)\n    flag = PEER_FLAG_ORF_PREFIX_SM;\n  else if (strncmp (argv[1], \"r\", 1) == 0)\n    flag = PEER_FLAG_ORF_PREFIX_RM;\n  else if (strncmp (argv[1], \"b\", 1) == 0)\n    flag = PEER_FLAG_ORF_PREFIX_SM|PEER_FLAG_ORF_PREFIX_RM;\n  else\n    return CMD_WARNING;\n\n  return peer_af_flag_unset_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t bgp_node_safi (vty), flag);\n}\n\f\n/* neighbor next-hop-self. */\nDEFUN (neighbor_nexthop_self,\n       neighbor_nexthop_self_cmd,\n       NEIGHBOR_CMD2 \"next-hop-self\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Disable the next hop calculation for this neighbor\\n\")\n{\n  return peer_af_flag_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t       bgp_node_safi (vty), PEER_FLAG_NEXTHOP_SELF);\n}\n\nDEFUN (no_neighbor_nexthop_self,\n       no_neighbor_nexthop_self_cmd,\n       NO_NEIGHBOR_CMD2 \"next-hop-self\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Disable the next hop calculation for this neighbor\\n\")\n{\n  return peer_af_flag_unset_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t bgp_node_safi (vty), PEER_FLAG_NEXTHOP_SELF);\n}\n\f\n/* neighbor remove-private-AS. */\nDEFUN (neighbor_remove_private_as,\n       neighbor_remove_private_as_cmd,\n       NEIGHBOR_CMD2 \"remove-private-AS\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Remove private AS number from outbound updates\\n\")\n{\n  return peer_af_flag_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t       bgp_node_safi (vty),\n\t\t\t       PEER_FLAG_REMOVE_PRIVATE_AS);\n}\n\nDEFUN (no_neighbor_remove_private_as,\n       no_neighbor_remove_private_as_cmd,\n       NO_NEIGHBOR_CMD2 \"remove-private-AS\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Remove private AS number from outbound updates\\n\")\n{\n  return peer_af_flag_unset_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t bgp_node_safi (vty),\n\t\t\t\t PEER_FLAG_REMOVE_PRIVATE_AS);\n}\n\f\n/* neighbor send-community. */\nDEFUN (neighbor_send_community,\n       neighbor_send_community_cmd,\n       NEIGHBOR_CMD2 \"send-community\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Send Community attribute to this neighbor\\n\")\n{\n  return peer_af_flag_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t       bgp_node_safi (vty),\n\t\t\t       PEER_FLAG_SEND_COMMUNITY);\n}\n\nDEFUN (no_neighbor_send_community,\n       no_neighbor_send_community_cmd,\n       NO_NEIGHBOR_CMD2 \"send-community\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Send Community attribute to this neighbor\\n\")\n{\n  return peer_af_flag_unset_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t bgp_node_safi (vty),\n\t\t\t\t PEER_FLAG_SEND_COMMUNITY);\n}\n\f\n/* neighbor send-community extended. */\nDEFUN (neighbor_send_community_type,\n       neighbor_send_community_type_cmd,\n       NEIGHBOR_CMD2 \"send-community (both|extended|standard)\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Send Community attribute to this neighbor\\n\"\n       \"Send Standard and Extended Community attributes\\n\"\n       \"Send Extended Community attributes\\n\"\n       \"Send Standard Community attributes\\n\")\n{\n  if (strncmp (argv[1], \"s\", 1) == 0)\n    return peer_af_flag_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t bgp_node_safi (vty),\n\t\t\t\t PEER_FLAG_SEND_COMMUNITY);\n  if (strncmp (argv[1], \"e\", 1) == 0)\n    return peer_af_flag_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t bgp_node_safi (vty),\n\t\t\t\t PEER_FLAG_SEND_EXT_COMMUNITY);\n\n  return peer_af_flag_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t       bgp_node_safi (vty),\n\t\t\t       (PEER_FLAG_SEND_COMMUNITY|\n\t\t\t\tPEER_FLAG_SEND_EXT_COMMUNITY));\n}\n\nDEFUN (no_neighbor_send_community_type,\n       no_neighbor_send_community_type_cmd,\n       NO_NEIGHBOR_CMD2 \"send-community (both|extended|standard)\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Send Community attribute to this neighbor\\n\"\n       \"Send Standard and Extended Community attributes\\n\"\n       \"Send Extended Community attributes\\n\"\n       \"Send Standard Community attributes\\n\")\n{\n  if (strncmp (argv[1], \"s\", 1) == 0)\n    return peer_af_flag_unset_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t   bgp_node_safi (vty),\n\t\t\t\t   PEER_FLAG_SEND_COMMUNITY);\n  if (strncmp (argv[1], \"e\", 1) == 0)\n    return peer_af_flag_unset_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t   bgp_node_safi (vty),\n\t\t\t\t   PEER_FLAG_SEND_EXT_COMMUNITY);\n\n  return peer_af_flag_unset_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t bgp_node_safi (vty),\n\t\t\t\t (PEER_FLAG_SEND_COMMUNITY |\n\t\t\t\t  PEER_FLAG_SEND_EXT_COMMUNITY));\n}\n\f\n/* neighbor soft-reconfig. */\nDEFUN (neighbor_soft_reconfiguration,\n       neighbor_soft_reconfiguration_cmd,\n       NEIGHBOR_CMD2 \"soft-reconfiguration inbound\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Per neighbor soft reconfiguration\\n\"\n       \"Allow inbound soft reconfiguration for this neighbor\\n\")\n{\n  return peer_af_flag_set_vty (vty, argv[0],\n\t\t\t       bgp_node_afi (vty), bgp_node_safi (vty),\n\t\t\t       PEER_FLAG_SOFT_RECONFIG);\n}\n\nDEFUN (no_neighbor_soft_reconfiguration,\n       no_neighbor_soft_reconfiguration_cmd,\n       NO_NEIGHBOR_CMD2 \"soft-reconfiguration inbound\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Per neighbor soft reconfiguration\\n\"\n       \"Allow inbound soft reconfiguration for this neighbor\\n\")\n{\n  return peer_af_flag_unset_vty (vty, argv[0],\n\t\t\t\t bgp_node_afi (vty), bgp_node_safi (vty),\n\t\t\t\t PEER_FLAG_SOFT_RECONFIG);\n}\n\f\nDEFUN (neighbor_route_reflector_client,\n       neighbor_route_reflector_client_cmd,\n       NEIGHBOR_CMD2 \"route-reflector-client\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Configure a neighbor as Route Reflector client\\n\")\n{\n  struct peer *peer;\n\n\n  peer = peer_and_group_lookup_vty (vty, argv[0]);\n  if (! peer)\n    return CMD_WARNING;\n\n  return peer_af_flag_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t       bgp_node_safi (vty),\n\t\t\t       PEER_FLAG_REFLECTOR_CLIENT);\n}\n\nDEFUN (no_neighbor_route_reflector_client,\n       no_neighbor_route_reflector_client_cmd,\n       NO_NEIGHBOR_CMD2 \"route-reflector-client\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Configure a neighbor as Route Reflector client\\n\")\n{\n  return peer_af_flag_unset_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t bgp_node_safi (vty),\n\t\t\t\t PEER_FLAG_REFLECTOR_CLIENT);\n}\n\f\nstatic int\npeer_rsclient_set_vty (struct vty *vty, const char *peer_str, \n                       int afi, int safi)\n{\n  int ret;\n  struct bgp *bgp;\n  struct peer *peer;\n  struct peer_group *group;\n  struct listnode *node, *nnode;\n  struct bgp_filter *pfilter;\n  struct bgp_filter *gfilter;\n\n  bgp = vty->index;\n\n  peer = peer_and_group_lookup_vty (vty, peer_str);\n  if ( ! peer )\n    return CMD_WARNING;\n\n  /* If it is already a RS-Client, don't do anything. */\n  if ( CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_RSERVER_CLIENT) )\n    return CMD_SUCCESS;\n\n  if ( ! peer_rsclient_active (peer) )\n    {\n      peer = peer_lock (peer); /* rsclient peer list reference */\n      listnode_add_sort (bgp->rsclient, peer);\n    }\n\n  ret = peer_af_flag_set (peer, afi, safi, PEER_FLAG_RSERVER_CLIENT);\n  if (ret < 0)\n    return bgp_vty_return (vty, ret);\n\n  peer->rib[afi][safi] = bgp_table_init (afi, safi);\n  peer->rib[afi][safi]->type = BGP_TABLE_RSCLIENT;\n  peer->rib[afi][safi]->owner = peer;\n\n  /* Check for existing 'network' and 'redistribute' routes. */\n  bgp_check_local_routes_rsclient (peer, afi, safi);\n\n  /* Check for routes for peers configured with 'soft-reconfiguration'. */\n  bgp_soft_reconfig_rsclient (peer, afi, safi);\n\n  if (CHECK_FLAG(peer->sflags, PEER_STATUS_GROUP))\n    {\n      group = peer->group;\n      gfilter = &peer->filter[afi][safi];\n\n      for (ALL_LIST_ELEMENTS (group->peer, node, nnode, peer))\n        {\n          pfilter = &peer->filter[afi][safi];\n\n          /* Members of a non-RS-Client group should not be RS-Clients, as that \n             is checked when the become part of the peer-group */\n          ret = peer_af_flag_set (peer, afi, safi, PEER_FLAG_RSERVER_CLIENT);\n          if (ret < 0)\n            return bgp_vty_return (vty, ret);\n\n          /* Make peer's RIB point to group's RIB. */\n          peer->rib[afi][safi] = group->conf->rib[afi][safi];\n\n          /* Import policy. */\n          if (pfilter->map[RMAP_IMPORT].name)\n            free (pfilter->map[RMAP_IMPORT].name);\n          if (gfilter->map[RMAP_IMPORT].name)\n            {\n              pfilter->map[RMAP_IMPORT].name = strdup (gfilter->map[RMAP_IMPORT].name);\n              pfilter->map[RMAP_IMPORT].map = gfilter->map[RMAP_IMPORT].map;\n            }\n          else\n            {\n              pfilter->map[RMAP_IMPORT].name = NULL;\n              pfilter->map[RMAP_IMPORT].map =NULL;\n            }\n\n          /* Export policy. */\n          if (gfilter->map[RMAP_EXPORT].name && ! pfilter->map[RMAP_EXPORT].name)\n            {\n              pfilter->map[RMAP_EXPORT].name = strdup (gfilter->map[RMAP_EXPORT].name);\n              pfilter->map[RMAP_EXPORT].map = gfilter->map[RMAP_EXPORT].map;\n            }\n        }\n    }\n  return CMD_SUCCESS;\n}\n\nstatic int\npeer_rsclient_unset_vty (struct vty *vty, const char *peer_str, \n                         int afi, int safi)\n{\n  int ret;\n  struct bgp *bgp;\n  struct peer *peer;\n  struct peer_group *group;\n  struct listnode *node, *nnode;\n\n  bgp = vty->index;\n\n  peer = peer_and_group_lookup_vty (vty, peer_str);\n  if ( ! peer )\n    return CMD_WARNING;\n\n  /* If it is not a RS-Client, don't do anything. */\n  if ( ! CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_RSERVER_CLIENT) )\n    return CMD_SUCCESS;\n\n  if (CHECK_FLAG(peer->sflags, PEER_STATUS_GROUP))\n    {\n      group = peer->group;\n\n      for (ALL_LIST_ELEMENTS (group->peer, node, nnode, peer))\n        {\n          ret = peer_af_flag_unset (peer, afi, safi, PEER_FLAG_RSERVER_CLIENT);\n          if (ret < 0)\n            return bgp_vty_return (vty, ret);\n\n          peer->rib[afi][safi] = NULL;\n        }\n\n        peer = group->conf;\n    }\n\n  ret = peer_af_flag_unset (peer, afi, safi, PEER_FLAG_RSERVER_CLIENT);\n  if (ret < 0)\n    return bgp_vty_return (vty, ret);\n\n  if ( ! peer_rsclient_active (peer) )\n    {\n      peer_unlock (peer); /* peer bgp rsclient reference */\n      listnode_delete (bgp->rsclient, peer);\n    }\n\n  bgp_table_finish (peer->rib[bgp_node_afi(vty)][bgp_node_safi(vty)]);\n\n  return CMD_SUCCESS;\n}\n\f\n/* neighbor route-server-client. */\nDEFUN (neighbor_route_server_client,\n       neighbor_route_server_client_cmd,\n       NEIGHBOR_CMD2 \"route-server-client\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Configure a neighbor as Route Server client\\n\")\n{\n  return peer_rsclient_set_vty (vty, argv[0], bgp_node_afi(vty),\n                  bgp_node_safi(vty));\n}\n\nDEFUN (no_neighbor_route_server_client,\n       no_neighbor_route_server_client_cmd,\n       NO_NEIGHBOR_CMD2 \"route-server-client\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Configure a neighbor as Route Server client\\n\")\n{\n  return peer_rsclient_unset_vty (vty, argv[0], bgp_node_afi(vty),\n                  bgp_node_safi(vty));\n}\n\f\nDEFUN (neighbor_nexthop_local_unchanged,\n       neighbor_nexthop_local_unchanged_cmd,\n       NEIGHBOR_CMD2 \"nexthop-local unchanged\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Configure treatment of outgoing link-local nexthop attribute\\n\"\n       \"Leave link-local nexthop unchanged for this peer\\n\")\n{\n  return peer_af_flag_set_vty (vty, argv[0], bgp_node_afi (vty),\n                                bgp_node_safi (vty),\n                                PEER_FLAG_NEXTHOP_LOCAL_UNCHANGED );\n}\n\f\nDEFUN (no_neighbor_nexthop_local_unchanged,\n       no_neighbor_nexthop_local_unchanged_cmd,\n       NO_NEIGHBOR_CMD2 \"nexthop-local unchanged\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Configure treatment of outgoing link-local-nexthop attribute\\n\"\n       \"Leave link-local nexthop unchanged for this peer\\n\")\n{\n  return peer_af_flag_unset_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t bgp_node_safi (vty),\n                                PEER_FLAG_NEXTHOP_LOCAL_UNCHANGED );\n}\n\f\nDEFUN (neighbor_attr_unchanged,\n       neighbor_attr_unchanged_cmd,\n       NEIGHBOR_CMD2 \"attribute-unchanged\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"BGP attribute is propagated unchanged to this neighbor\\n\")\n{\n  return peer_af_flag_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t       bgp_node_safi (vty),\n\t\t\t       (PEER_FLAG_AS_PATH_UNCHANGED |\n\t\t\t\tPEER_FLAG_NEXTHOP_UNCHANGED |\n\t\t\t\tPEER_FLAG_MED_UNCHANGED));\n}\n\nDEFUN (neighbor_attr_unchanged1,\n       neighbor_attr_unchanged1_cmd,\n       NEIGHBOR_CMD2 \"attribute-unchanged (as-path|next-hop|med)\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"BGP attribute is propagated unchanged to this neighbor\\n\"\n       \"As-path attribute\\n\"\n       \"Nexthop attribute\\n\"\n       \"Med attribute\\n\")\n{\n  u_int16_t flags = 0;\n\n  if (strncmp (argv[1], \"as-path\", 1) == 0)\n    SET_FLAG (flags, PEER_FLAG_AS_PATH_UNCHANGED);\n  else if (strncmp (argv[1], \"next-hop\", 1) == 0)\n    SET_FLAG (flags, PEER_FLAG_NEXTHOP_UNCHANGED);\n  else if (strncmp (argv[1], \"med\", 1) == 0)\n    SET_FLAG (flags, PEER_FLAG_MED_UNCHANGED);\n\n  return peer_af_flag_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t       bgp_node_safi (vty), flags);\n}\n\nDEFUN (neighbor_attr_unchanged2,\n       neighbor_attr_unchanged2_cmd,\n       NEIGHBOR_CMD2 \"attribute-unchanged as-path (next-hop|med)\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"BGP attribute is propagated unchanged to this neighbor\\n\"\n       \"As-path attribute\\n\"\n       \"Nexthop attribute\\n\"\n       \"Med attribute\\n\")\n{\n  u_int16_t flags = PEER_FLAG_AS_PATH_UNCHANGED;\n\n  if (strncmp (argv[1], \"next-hop\", 1) == 0)\n    SET_FLAG (flags, PEER_FLAG_NEXTHOP_UNCHANGED);\n  else if (strncmp (argv[1], \"med\", 1) == 0)\n    SET_FLAG (flags, PEER_FLAG_MED_UNCHANGED);\n\n  return peer_af_flag_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t       bgp_node_safi (vty), flags);\n\n}\n\nDEFUN (neighbor_attr_unchanged3,\n       neighbor_attr_unchanged3_cmd,\n       NEIGHBOR_CMD2 \"attribute-unchanged next-hop (as-path|med)\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"BGP attribute is propagated unchanged to this neighbor\\n\"\n       \"Nexthop attribute\\n\"\n       \"As-path attribute\\n\"\n       \"Med attribute\\n\")\n{\n  u_int16_t flags = PEER_FLAG_NEXTHOP_UNCHANGED;\n\n  if (strncmp (argv[1], \"as-path\", 1) == 0)\n    SET_FLAG (flags, PEER_FLAG_AS_PATH_UNCHANGED);\n  else if (strncmp (argv[1], \"med\", 1) == 0)\n    SET_FLAG (flags, PEER_FLAG_MED_UNCHANGED);\n\n  return peer_af_flag_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t       bgp_node_safi (vty), flags);\n}\n\nDEFUN (neighbor_attr_unchanged4,\n       neighbor_attr_unchanged4_cmd,\n       NEIGHBOR_CMD2 \"attribute-unchanged med (as-path|next-hop)\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"BGP attribute is propagated unchanged to this neighbor\\n\"\n       \"Med attribute\\n\"\n       \"As-path attribute\\n\"\n       \"Nexthop attribute\\n\")\n{\n  u_int16_t flags = PEER_FLAG_MED_UNCHANGED;\n\n  if (strncmp (argv[1], \"as-path\", 1) == 0)\n    SET_FLAG (flags, PEER_FLAG_AS_PATH_UNCHANGED);\n  else if (strncmp (argv[1], \"next-hop\", 1) == 0)\n    SET_FLAG (flags, PEER_FLAG_NEXTHOP_UNCHANGED);\n\n  return peer_af_flag_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t       bgp_node_safi (vty), flags);\n}\n\nALIAS (neighbor_attr_unchanged,\n       neighbor_attr_unchanged5_cmd,\n       NEIGHBOR_CMD2 \"attribute-unchanged as-path next-hop med\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"BGP attribute is propagated unchanged to this neighbor\\n\"\n       \"As-path attribute\\n\"\n       \"Nexthop attribute\\n\"\n       \"Med attribute\\n\")\n\nALIAS (neighbor_attr_unchanged,\n       neighbor_attr_unchanged6_cmd,\n       NEIGHBOR_CMD2 \"attribute-unchanged as-path med next-hop\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"BGP attribute is propagated unchanged to this neighbor\\n\"\n       \"As-path attribute\\n\"\n       \"Med attribute\\n\"\n       \"Nexthop attribute\\n\")\n\nALIAS (neighbor_attr_unchanged,\n       neighbor_attr_unchanged7_cmd,\n       NEIGHBOR_CMD2 \"attribute-unchanged next-hop med as-path\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"BGP attribute is propagated unchanged to this neighbor\\n\"\n       \"Nexthop attribute\\n\"\n       \"Med attribute\\n\"\n       \"As-path attribute\\n\")\n\nALIAS (neighbor_attr_unchanged,\n       neighbor_attr_unchanged8_cmd,\n       NEIGHBOR_CMD2 \"attribute-unchanged next-hop as-path med\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"BGP attribute is propagated unchanged to this neighbor\\n\"\n       \"Nexthop attribute\\n\"\n       \"As-path attribute\\n\"\n       \"Med attribute\\n\")\n\nALIAS (neighbor_attr_unchanged,\n       neighbor_attr_unchanged9_cmd,\n       NEIGHBOR_CMD2 \"attribute-unchanged med next-hop as-path\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"BGP attribute is propagated unchanged to this neighbor\\n\"\n       \"Med attribute\\n\"\n       \"Nexthop attribute\\n\"\n       \"As-path attribute\\n\")\n\nALIAS (neighbor_attr_unchanged,\n       neighbor_attr_unchanged10_cmd,\n       NEIGHBOR_CMD2 \"attribute-unchanged med as-path next-hop\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"BGP attribute is propagated unchanged to this neighbor\\n\"\n       \"Med attribute\\n\"\n       \"As-path attribute\\n\"\n       \"Nexthop attribute\\n\")\n\nDEFUN (no_neighbor_attr_unchanged,\n       no_neighbor_attr_unchanged_cmd,\n       NO_NEIGHBOR_CMD2 \"attribute-unchanged\",\n       NO_STR\t \n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"BGP attribute is propagated unchanged to this neighbor\\n\")\n{\n  return peer_af_flag_unset_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t bgp_node_safi (vty),\n\t\t\t\t (PEER_FLAG_AS_PATH_UNCHANGED |\n\t\t\t\t  PEER_FLAG_NEXTHOP_UNCHANGED |\n\t\t\t\t  PEER_FLAG_MED_UNCHANGED));\n}\n\nDEFUN (no_neighbor_attr_unchanged1,\n       no_neighbor_attr_unchanged1_cmd,\n       NO_NEIGHBOR_CMD2 \"attribute-unchanged (as-path|next-hop|med)\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"BGP attribute is propagated unchanged to this neighbor\\n\"\n       \"As-path attribute\\n\"\n       \"Nexthop attribute\\n\"\n       \"Med attribute\\n\")\n{\n  u_int16_t flags = 0;\n\n  if (strncmp (argv[1], \"as-path\", 1) == 0)\n    SET_FLAG (flags, PEER_FLAG_AS_PATH_UNCHANGED);\n  else if (strncmp (argv[1], \"next-hop\", 1) == 0)\n    SET_FLAG (flags, PEER_FLAG_NEXTHOP_UNCHANGED);\n  else if (strncmp (argv[1], \"med\", 1) == 0)\n    SET_FLAG (flags, PEER_FLAG_MED_UNCHANGED);\n\n  return peer_af_flag_unset_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t bgp_node_safi (vty), flags);\n}\n\nDEFUN (no_neighbor_attr_unchanged2,\n       no_neighbor_attr_unchanged2_cmd,\n       NO_NEIGHBOR_CMD2 \"attribute-unchanged as-path (next-hop|med)\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"BGP attribute is propagated unchanged to this neighbor\\n\"\n       \"As-path attribute\\n\"\n       \"Nexthop attribute\\n\"\n       \"Med attribute\\n\")\n{\n  u_int16_t flags = PEER_FLAG_AS_PATH_UNCHANGED;\n\n  if (strncmp (argv[1], \"next-hop\", 1) == 0)\n    SET_FLAG (flags, PEER_FLAG_NEXTHOP_UNCHANGED);\n  else if (strncmp (argv[1], \"med\", 1) == 0)\n    SET_FLAG (flags, PEER_FLAG_MED_UNCHANGED);\n\n  return peer_af_flag_unset_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t       bgp_node_safi (vty), flags);\n}\n\nDEFUN (no_neighbor_attr_unchanged3,\n       no_neighbor_attr_unchanged3_cmd,\n       NO_NEIGHBOR_CMD2 \"attribute-unchanged next-hop (as-path|med)\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"BGP attribute is propagated unchanged to this neighbor\\n\"\n       \"Nexthop attribute\\n\"\n       \"As-path attribute\\n\"\n       \"Med attribute\\n\")\n{\n  u_int16_t flags = PEER_FLAG_NEXTHOP_UNCHANGED;\n\n  if (strncmp (argv[1], \"as-path\", 1) == 0)\n    SET_FLAG (flags, PEER_FLAG_AS_PATH_UNCHANGED);\n  else if (strncmp (argv[1], \"med\", 1) == 0)\n    SET_FLAG (flags, PEER_FLAG_MED_UNCHANGED);\n\n  return peer_af_flag_unset_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t bgp_node_safi (vty), flags);\n}\n\nDEFUN (no_neighbor_attr_unchanged4,\n       no_neighbor_attr_unchanged4_cmd,\n       NO_NEIGHBOR_CMD2 \"attribute-unchanged med (as-path|next-hop)\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"BGP attribute is propagated unchanged to this neighbor\\n\"\n       \"Med attribute\\n\"\n       \"As-path attribute\\n\"\n       \"Nexthop attribute\\n\")\n{\n  u_int16_t flags = PEER_FLAG_MED_UNCHANGED;\n\n  if (strncmp (argv[1], \"as-path\", 1) == 0)\n    SET_FLAG (flags, PEER_FLAG_AS_PATH_UNCHANGED);\n  else if (strncmp (argv[1], \"next-hop\", 1) == 0)\n    SET_FLAG (flags, PEER_FLAG_NEXTHOP_UNCHANGED);\n\n  return peer_af_flag_unset_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t       bgp_node_safi (vty), flags);\n}\n\nALIAS (no_neighbor_attr_unchanged,\n       no_neighbor_attr_unchanged5_cmd,\n       NO_NEIGHBOR_CMD2 \"attribute-unchanged as-path next-hop med\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"BGP attribute is propagated unchanged to this neighbor\\n\"\n       \"As-path attribute\\n\"\n       \"Nexthop attribute\\n\"\n       \"Med attribute\\n\")\n\nALIAS (no_neighbor_attr_unchanged,\n       no_neighbor_attr_unchanged6_cmd,\n       NO_NEIGHBOR_CMD2 \"attribute-unchanged as-path med next-hop\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"BGP attribute is propagated unchanged to this neighbor\\n\"\n       \"As-path attribute\\n\"\n       \"Med attribute\\n\"\n       \"Nexthop attribute\\n\")\n\nALIAS (no_neighbor_attr_unchanged,\n       no_neighbor_attr_unchanged7_cmd,\n       NO_NEIGHBOR_CMD2 \"attribute-unchanged next-hop med as-path\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"BGP attribute is propagated unchanged to this neighbor\\n\"\n       \"Nexthop attribute\\n\"\n       \"Med attribute\\n\"\n       \"As-path attribute\\n\")\n\nALIAS (no_neighbor_attr_unchanged,\n       no_neighbor_attr_unchanged8_cmd,\n       NO_NEIGHBOR_CMD2 \"attribute-unchanged next-hop as-path med\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"BGP attribute is propagated unchanged to this neighbor\\n\"\n       \"Nexthop attribute\\n\"\n       \"As-path attribute\\n\"\n       \"Med attribute\\n\")\n\nALIAS (no_neighbor_attr_unchanged,\n       no_neighbor_attr_unchanged9_cmd,\n       NO_NEIGHBOR_CMD2 \"attribute-unchanged med next-hop as-path\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"BGP attribute is propagated unchanged to this neighbor\\n\"\n       \"Med attribute\\n\"\n       \"Nexthop attribute\\n\"\n       \"As-path attribute\\n\")\n\nALIAS (no_neighbor_attr_unchanged,\n       no_neighbor_attr_unchanged10_cmd,\n       NO_NEIGHBOR_CMD2 \"attribute-unchanged med as-path next-hop\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"BGP attribute is propagated unchanged to this neighbor\\n\"\n       \"Med attribute\\n\"\n       \"As-path attribute\\n\"\n       \"Nexthop attribute\\n\")\n\n/* For old version Zebra compatibility.  */\nDEFUN_DEPRECATED (neighbor_transparent_as,\n\t\t  neighbor_transparent_as_cmd,\n\t\t  NEIGHBOR_CMD \"transparent-as\",\n\t\t  NEIGHBOR_STR\n\t\t  NEIGHBOR_ADDR_STR\n\t\t  \"Do not append my AS number even peer is EBGP peer\\n\")\n{\n  return peer_af_flag_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t       bgp_node_safi (vty),\n\t\t\t       PEER_FLAG_AS_PATH_UNCHANGED);\n}\n\nDEFUN_DEPRECATED (neighbor_transparent_nexthop,\n\t\t  neighbor_transparent_nexthop_cmd,\n\t\t  NEIGHBOR_CMD \"transparent-nexthop\",\n\t\t  NEIGHBOR_STR\n\t\t  NEIGHBOR_ADDR_STR\n\t\t  \"Do not change nexthop even peer is EBGP peer\\n\")\n{\n  return peer_af_flag_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t       bgp_node_safi (vty),\n\t\t\t       PEER_FLAG_NEXTHOP_UNCHANGED);\n}\n\f\n/* EBGP multihop configuration. */\nstatic int\npeer_ebgp_multihop_set_vty (struct vty *vty, const char *ip_str, \n                            const char *ttl_str)\n{\n  struct peer *peer;\n  unsigned int ttl;\n\n  peer = peer_and_group_lookup_vty (vty, ip_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  if (! ttl_str)\n    ttl = TTL_MAX;\n  else\n    VTY_GET_INTEGER_RANGE (\"TTL\", ttl, ttl_str, 1, 255);\n\n  peer_ebgp_multihop_set (peer, ttl);\n\n  return CMD_SUCCESS;\n}\n\nstatic int\npeer_ebgp_multihop_unset_vty (struct vty *vty, const char *ip_str) \n{\n  struct peer *peer;\n\n  peer = peer_and_group_lookup_vty (vty, ip_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  peer_ebgp_multihop_unset (peer);\n\n  return CMD_SUCCESS;\n}\n\n/* neighbor ebgp-multihop. */\nDEFUN (neighbor_ebgp_multihop,\n       neighbor_ebgp_multihop_cmd,\n       NEIGHBOR_CMD2 \"ebgp-multihop\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Allow EBGP neighbors not on directly connected networks\\n\")\n{\n  return peer_ebgp_multihop_set_vty (vty, argv[0], NULL);\n}\n\nDEFUN (neighbor_ebgp_multihop_ttl,\n       neighbor_ebgp_multihop_ttl_cmd,\n       NEIGHBOR_CMD2 \"ebgp-multihop <1-255>\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Allow EBGP neighbors not on directly connected networks\\n\"\n       \"maximum hop count\\n\")\n{\n  return peer_ebgp_multihop_set_vty (vty, argv[0], argv[1]);\n}\n\nDEFUN (no_neighbor_ebgp_multihop,\n       no_neighbor_ebgp_multihop_cmd,\n       NO_NEIGHBOR_CMD2 \"ebgp-multihop\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Allow EBGP neighbors not on directly connected networks\\n\")\n{\n  return peer_ebgp_multihop_unset_vty (vty, argv[0]);\n}\n\nALIAS (no_neighbor_ebgp_multihop,\n       no_neighbor_ebgp_multihop_ttl_cmd,\n       NO_NEIGHBOR_CMD2 \"ebgp-multihop <1-255>\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Allow EBGP neighbors not on directly connected networks\\n\"\n       \"maximum hop count\\n\")\n\f\n/* disable-connected-check */\nDEFUN (neighbor_disable_connected_check,\n       neighbor_disable_connected_check_cmd,\n       NEIGHBOR_CMD2 \"disable-connected-check\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"one-hop away EBGP peer using loopback address\\n\")\n{\n  return peer_flag_set_vty (vty, argv[0], PEER_FLAG_DISABLE_CONNECTED_CHECK);\n}\n\nDEFUN (no_neighbor_disable_connected_check,\n       no_neighbor_disable_connected_check_cmd,\n       NO_NEIGHBOR_CMD2 \"disable-connected-check\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"one-hop away EBGP peer using loopback address\\n\")\n{\n  return peer_flag_unset_vty (vty, argv[0], PEER_FLAG_DISABLE_CONNECTED_CHECK);\n}\n\n/* Enforce multihop.  */\nALIAS (neighbor_disable_connected_check,\n       neighbor_enforce_multihop_cmd,\n       NEIGHBOR_CMD2 \"enforce-multihop\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Enforce EBGP neighbors perform multihop\\n\")\n\n/* Enforce multihop.  */\nALIAS (no_neighbor_disable_connected_check,\n       no_neighbor_enforce_multihop_cmd,\n       NO_NEIGHBOR_CMD2 \"enforce-multihop\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Enforce EBGP neighbors perform multihop\\n\")\n\f\nDEFUN (neighbor_description,\n       neighbor_description_cmd,\n       NEIGHBOR_CMD2 \"description .LINE\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Neighbor specific description\\n\"\n       \"Up to 80 characters describing this neighbor\\n\")\n{\n  struct peer *peer;\n  char *str;\n\n  peer = peer_and_group_lookup_vty (vty, argv[0]);\n  if (! peer)\n    return CMD_WARNING;\n\n  if (argc == 1)\n    return CMD_SUCCESS;\n\n  str = argv_concat(argv, argc, 1);\n\n  peer_description_set (peer, str);\n\n  XFREE (MTYPE_TMP, str);\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_neighbor_description,\n       no_neighbor_description_cmd,\n       NO_NEIGHBOR_CMD2 \"description\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Neighbor specific description\\n\")\n{\n  struct peer *peer;\n\n  peer = peer_and_group_lookup_vty (vty, argv[0]);\n  if (! peer)\n    return CMD_WARNING;\n\n  peer_description_unset (peer);\n\n  return CMD_SUCCESS;\n}\n\nALIAS (no_neighbor_description,\n       no_neighbor_description_val_cmd,\n       NO_NEIGHBOR_CMD2 \"description .LINE\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Neighbor specific description\\n\"\n       \"Up to 80 characters describing this neighbor\\n\")\n\f\n/* Neighbor update-source. */\nstatic int\npeer_update_source_vty (struct vty *vty, const char *peer_str, \n                        const char *source_str)\n{\n  struct peer *peer;\n  union sockunion *su;\n\n  peer = peer_and_group_lookup_vty (vty, peer_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  if (source_str)\n    {\n      su = sockunion_str2su (source_str);\n      if (su)\n\t{\n\t  peer_update_source_addr_set (peer, su);\n\t  sockunion_free (su);\n\t}\n      else\n\tpeer_update_source_if_set (peer, source_str);\n    }\n  else\n    peer_update_source_unset (peer);\n\n  return CMD_SUCCESS;\n}\n\n#define BGP_UPDATE_SOURCE_STR \"(A.B.C.D|WORD)\"\n#define BGP_UPDATE_SOURCE_HELP_STR \\\n  \"IPv4 address\\n\" \\\n  \"Interface name\\n\"\n\nDEFUN (neighbor_update_source,\n       neighbor_update_source_cmd,\n       NEIGHBOR_CMD2 \"update-source \" BGP_UPDATE_SOURCE_STR,\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Source of routing updates\\n\"\n       BGP_UPDATE_SOURCE_HELP_STR)\n{\n  return peer_update_source_vty (vty, argv[0], argv[1]);\n}\n\nDEFUN (no_neighbor_update_source,\n       no_neighbor_update_source_cmd,\n       NO_NEIGHBOR_CMD2 \"update-source\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Source of routing updates\\n\")\n{\n  return peer_update_source_vty (vty, argv[0], NULL);\n}\n\f\nstatic int\npeer_default_originate_set_vty (struct vty *vty, const char *peer_str, \n                                afi_t afi, safi_t safi, \n                                const char *rmap, int set)\n{\n  int ret;\n  struct peer *peer;\n\n  peer = peer_and_group_lookup_vty (vty, peer_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  if (set)\n    ret = peer_default_originate_set (peer, afi, safi, rmap);\n  else\n    ret = peer_default_originate_unset (peer, afi, safi);\n\n  return bgp_vty_return (vty, ret);\n}\n\n/* neighbor default-originate. */\nDEFUN (neighbor_default_originate,\n       neighbor_default_originate_cmd,\n       NEIGHBOR_CMD2 \"default-originate\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Originate default route to this neighbor\\n\")\n{\n  return peer_default_originate_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t\t bgp_node_safi (vty), NULL, 1);\n}\n\nDEFUN (neighbor_default_originate_rmap,\n       neighbor_default_originate_rmap_cmd,\n       NEIGHBOR_CMD2 \"default-originate route-map WORD\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Originate default route to this neighbor\\n\"\n       \"Route-map to specify criteria to originate default\\n\"\n       \"route-map name\\n\")\n{\n  return peer_default_originate_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t\t bgp_node_safi (vty), argv[1], 1);\n}\n\nDEFUN (no_neighbor_default_originate,\n       no_neighbor_default_originate_cmd,\n       NO_NEIGHBOR_CMD2 \"default-originate\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Originate default route to this neighbor\\n\")\n{\n  return peer_default_originate_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t\t bgp_node_safi (vty), NULL, 0);\n}\n\nALIAS (no_neighbor_default_originate,\n       no_neighbor_default_originate_rmap_cmd,\n       NO_NEIGHBOR_CMD2 \"default-originate route-map WORD\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Originate default route to this neighbor\\n\"\n       \"Route-map to specify criteria to originate default\\n\"\n       \"route-map name\\n\")\n\f\n/* Set neighbor's BGP port.  */\nstatic int\npeer_port_vty (struct vty *vty, const char *ip_str, int afi, \n               const char *port_str)\n{\n  struct peer *peer;\n  u_int16_t port;\n  struct servent *sp;\n\n  peer = peer_lookup_vty (vty, ip_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  if (! port_str)\n    { \n      sp = getservbyname (\"bgp\", \"tcp\");\n      port = (sp == NULL) ? BGP_PORT_DEFAULT : ntohs (sp->s_port);\n    }\n  else\n    {\n      VTY_GET_INTEGER(\"port\", port, port_str);\n    }\n\n  peer_port_set (peer, port);\n\n  return CMD_SUCCESS;\n}\n\n/* Set specified peer's BGP port.  */\nDEFUN (neighbor_port,\n       neighbor_port_cmd,\n       NEIGHBOR_CMD \"port <0-65535>\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR\n       \"Neighbor's BGP port\\n\"\n       \"TCP port number\\n\")\n{\n  return peer_port_vty (vty, argv[0], AFI_IP, argv[1]);\n}\n\nDEFUN (no_neighbor_port,\n       no_neighbor_port_cmd,\n       NO_NEIGHBOR_CMD \"port\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR\n       \"Neighbor's BGP port\\n\")\n{\n  return peer_port_vty (vty, argv[0], AFI_IP, NULL);\n}\n\nALIAS (no_neighbor_port,\n       no_neighbor_port_val_cmd,\n       NO_NEIGHBOR_CMD \"port <0-65535>\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR\n       \"Neighbor's BGP port\\n\"\n       \"TCP port number\\n\")\n\f\n/* neighbor weight. */\nstatic int\npeer_weight_set_vty (struct vty *vty, const char *ip_str, \n                     const char *weight_str)\n{\n  int ret;\n  struct peer *peer;\n  unsigned long weight;\n\n  peer = peer_and_group_lookup_vty (vty, ip_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  VTY_GET_INTEGER_RANGE(\"weight\", weight, weight_str, 0, 65535);\n\n  ret = peer_weight_set (peer, weight);\n\n  return CMD_SUCCESS;\n}\n\nstatic int\npeer_weight_unset_vty (struct vty *vty, const char *ip_str)\n{\n  struct peer *peer;\n\n  peer = peer_and_group_lookup_vty (vty, ip_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  peer_weight_unset (peer);\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (neighbor_weight,\n       neighbor_weight_cmd,\n       NEIGHBOR_CMD2 \"weight <0-65535>\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Set default weight for routes from this neighbor\\n\"\n       \"default weight\\n\")\n{\n  return peer_weight_set_vty (vty, argv[0], argv[1]);\n}\n\nDEFUN (no_neighbor_weight,\n       no_neighbor_weight_cmd,\n       NO_NEIGHBOR_CMD2 \"weight\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Set default weight for routes from this neighbor\\n\")\n{\n  return peer_weight_unset_vty (vty, argv[0]);\n}\n\nALIAS (no_neighbor_weight,\n       no_neighbor_weight_val_cmd,\n       NO_NEIGHBOR_CMD2 \"weight <0-65535>\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Set default weight for routes from this neighbor\\n\"\n       \"default weight\\n\")\n\f\n/* Override capability negotiation. */\nDEFUN (neighbor_override_capability,\n       neighbor_override_capability_cmd,\n       NEIGHBOR_CMD2 \"override-capability\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Override capability negotiation result\\n\")\n{\n  return peer_flag_set_vty (vty, argv[0], PEER_FLAG_OVERRIDE_CAPABILITY);\n}\n\nDEFUN (no_neighbor_override_capability,\n       no_neighbor_override_capability_cmd,\n       NO_NEIGHBOR_CMD2 \"override-capability\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Override capability negotiation result\\n\")\n{\n  return peer_flag_unset_vty (vty, argv[0], PEER_FLAG_OVERRIDE_CAPABILITY);\n}\n\f\nDEFUN (neighbor_strict_capability,\n       neighbor_strict_capability_cmd,\n       NEIGHBOR_CMD \"strict-capability-match\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR\n       \"Strict capability negotiation match\\n\")\n{\n  return peer_flag_set_vty (vty, argv[0], PEER_FLAG_STRICT_CAP_MATCH);\n}\n\nDEFUN (no_neighbor_strict_capability,\n       no_neighbor_strict_capability_cmd,\n       NO_NEIGHBOR_CMD \"strict-capability-match\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR\n       \"Strict capability negotiation match\\n\")\n{\n  return peer_flag_unset_vty (vty, argv[0], PEER_FLAG_STRICT_CAP_MATCH);\n}\n\f\nstatic int\npeer_timers_set_vty (struct vty *vty, const char *ip_str, \n                     const char *keep_str, const char *hold_str)\n{\n  int ret;\n  struct peer *peer;\n  u_int32_t keepalive;\n  u_int32_t holdtime;\n\n  peer = peer_and_group_lookup_vty (vty, ip_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  VTY_GET_INTEGER_RANGE (\"Keepalive\", keepalive, keep_str, 0, 65535);\n  VTY_GET_INTEGER_RANGE (\"Holdtime\", holdtime, hold_str, 0, 65535);\n\n  ret = peer_timers_set (peer, keepalive, holdtime);\n\n  return bgp_vty_return (vty, ret);\n}\n\f\nstatic int\npeer_timers_unset_vty (struct vty *vty, const char *ip_str)\n{\n  int ret;\n  struct peer *peer;\n\n  peer = peer_lookup_vty (vty, ip_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  ret = peer_timers_unset (peer);\n\n  return bgp_vty_return (vty, ret);\n}\n\nDEFUN (neighbor_timers,\n       neighbor_timers_cmd,\n       NEIGHBOR_CMD2 \"timers <0-65535> <0-65535>\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"BGP per neighbor timers\\n\"\n       \"Keepalive interval\\n\"\n       \"Holdtime\\n\")\n{\n  return peer_timers_set_vty (vty, argv[0], argv[1], argv[2]);\n}\n\nDEFUN (no_neighbor_timers,\n       no_neighbor_timers_cmd,\n       NO_NEIGHBOR_CMD2 \"timers\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"BGP per neighbor timers\\n\")\n{\n  return peer_timers_unset_vty (vty, argv[0]);\n}\n\f\nstatic int\npeer_timers_connect_set_vty (struct vty *vty, const char *ip_str, \n                             const char *time_str)\n{\n  int ret;\n  struct peer *peer;\n  u_int32_t connect;\n\n  peer = peer_lookup_vty (vty, ip_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  VTY_GET_INTEGER_RANGE (\"Connect time\", connect, time_str, 0, 65535);\n\n  ret = peer_timers_connect_set (peer, connect);\n\n  return CMD_SUCCESS;\n}\n\nstatic int\npeer_timers_connect_unset_vty (struct vty *vty, const char *ip_str)\n{\n  int ret;\n  struct peer *peer;\n\n  peer = peer_and_group_lookup_vty (vty, ip_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  ret = peer_timers_connect_unset (peer);\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (neighbor_timers_connect,\n       neighbor_timers_connect_cmd,\n       NEIGHBOR_CMD \"timers connect <0-65535>\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR\n       \"BGP per neighbor timers\\n\"\n       \"BGP connect timer\\n\"\n       \"Connect timer\\n\")\n{\n  return peer_timers_connect_set_vty (vty, argv[0], argv[1]);\n}\n\nDEFUN (no_neighbor_timers_connect,\n       no_neighbor_timers_connect_cmd,\n       NO_NEIGHBOR_CMD \"timers connect\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR\n       \"BGP per neighbor timers\\n\"\n       \"BGP connect timer\\n\")\n{\n  return peer_timers_connect_unset_vty (vty, argv[0]);\n}\n\nALIAS (no_neighbor_timers_connect,\n       no_neighbor_timers_connect_val_cmd,\n       NO_NEIGHBOR_CMD \"timers connect <0-65535>\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR\n       \"BGP per neighbor timers\\n\"\n       \"BGP connect timer\\n\"\n       \"Connect timer\\n\")\n\f\nstatic int\npeer_advertise_interval_vty (struct vty *vty, const char *ip_str, \n                             const char *time_str, int set)  \n{\n  int ret;\n  struct peer *peer;\n  u_int32_t routeadv = 0;\n\n  peer = peer_lookup_vty (vty, ip_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  if (time_str)\n    VTY_GET_INTEGER_RANGE (\"advertise interval\", routeadv, time_str, 0, 600);\n\n  if (set)\n    ret = peer_advertise_interval_set (peer, routeadv);\n  else\n    ret = peer_advertise_interval_unset (peer);\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (neighbor_advertise_interval,\n       neighbor_advertise_interval_cmd,\n       NEIGHBOR_CMD \"advertisement-interval <0-600>\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR\n       \"Minimum interval between sending BGP routing updates\\n\"\n       \"time in seconds\\n\")\n{\n  return peer_advertise_interval_vty (vty, argv[0], argv[1], 1);\n}\n\nDEFUN (no_neighbor_advertise_interval,\n       no_neighbor_advertise_interval_cmd,\n       NO_NEIGHBOR_CMD \"advertisement-interval\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR\n       \"Minimum interval between sending BGP routing updates\\n\")\n{\n  return peer_advertise_interval_vty (vty, argv[0], NULL, 0);\n}\n\nALIAS (no_neighbor_advertise_interval,\n       no_neighbor_advertise_interval_val_cmd,\n       NO_NEIGHBOR_CMD \"advertisement-interval <0-600>\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR\n       \"Minimum interval between sending BGP routing updates\\n\"\n       \"time in seconds\\n\")\n\f\n/* neighbor interface */\nstatic int\npeer_interface_vty (struct vty *vty, const char *ip_str, const char *str)\n{\n  int ret;\n  struct peer *peer;\n\n  peer = peer_lookup_vty (vty, ip_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  if (str)\n    ret = peer_interface_set (peer, str);\n  else\n    ret = peer_interface_unset (peer);\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (neighbor_interface,\n       neighbor_interface_cmd,\n       NEIGHBOR_CMD \"interface WORD\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR\n       \"Interface\\n\"\n       \"Interface name\\n\")\n{\n  return peer_interface_vty (vty, argv[0], argv[1]);\n}\n\nDEFUN (no_neighbor_interface,\n       no_neighbor_interface_cmd,\n       NO_NEIGHBOR_CMD \"interface WORD\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR\n       \"Interface\\n\"\n       \"Interface name\\n\")\n{\n  return peer_interface_vty (vty, argv[0], NULL);\n}\n\f\n/* Set distribute list to the peer. */\nstatic int\npeer_distribute_set_vty (struct vty *vty, const char *ip_str, \n                         afi_t afi, safi_t safi,\n\t\t\t const char *name_str, const char *direct_str)\n{\n  int ret;\n  struct peer *peer;\n  int direct = FILTER_IN;\n\n  peer = peer_and_group_lookup_vty (vty, ip_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  /* Check filter direction. */\n  if (strncmp (direct_str, \"i\", 1) == 0)\n    direct = FILTER_IN;\n  else if (strncmp (direct_str, \"o\", 1) == 0)\n    direct = FILTER_OUT;\n\n  ret = peer_distribute_set (peer, afi, safi, direct, name_str);\n\n  return bgp_vty_return (vty, ret);\n}\n\nstatic int\npeer_distribute_unset_vty (struct vty *vty, const char *ip_str, afi_t afi,\n\t\t\t   safi_t safi, const char *direct_str)\n{\n  int ret;\n  struct peer *peer;\n  int direct = FILTER_IN;\n\n  peer = peer_and_group_lookup_vty (vty, ip_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  /* Check filter direction. */\n  if (strncmp (direct_str, \"i\", 1) == 0)\n    direct = FILTER_IN;\n  else if (strncmp (direct_str, \"o\", 1) == 0)\n    direct = FILTER_OUT;\n\n  ret = peer_distribute_unset (peer, afi, safi, direct);\n\n  return bgp_vty_return (vty, ret);\n}\n\nDEFUN (neighbor_distribute_list,\n       neighbor_distribute_list_cmd,\n       NEIGHBOR_CMD2 \"distribute-list (<1-199>|<1300-2699>|WORD) (in|out)\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Filter updates to/from this neighbor\\n\"\n       \"IP access-list number\\n\"\n       \"IP access-list number (expanded range)\\n\"\n       \"IP Access-list name\\n\"\n       \"Filter incoming updates\\n\"\n       \"Filter outgoing updates\\n\")\n{\n  return peer_distribute_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t  bgp_node_safi (vty), argv[1], argv[2]);\n}\n\nDEFUN (no_neighbor_distribute_list,\n       no_neighbor_distribute_list_cmd,\n       NO_NEIGHBOR_CMD2 \"distribute-list (<1-199>|<1300-2699>|WORD) (in|out)\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Filter updates to/from this neighbor\\n\"\n       \"IP access-list number\\n\"\n       \"IP access-list number (expanded range)\\n\"\n       \"IP Access-list name\\n\"\n       \"Filter incoming updates\\n\"\n       \"Filter outgoing updates\\n\")\n{\n  return peer_distribute_unset_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t    bgp_node_safi (vty), argv[2]);\n}\n\f\n/* Set prefix list to the peer. */\nstatic int\npeer_prefix_list_set_vty (struct vty *vty, const char *ip_str, afi_t afi,\n\t\t\t  safi_t safi, const char *name_str, \n                          const char *direct_str)\n{\n  int ret;\n  struct peer *peer;\n  int direct = FILTER_IN;\n\n  peer = peer_and_group_lookup_vty (vty, ip_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  /* Check filter direction. */\n  if (strncmp (direct_str, \"i\", 1) == 0)\n    direct = FILTER_IN;\n  else if (strncmp (direct_str, \"o\", 1) == 0)\n    direct = FILTER_OUT;\n\n  ret = peer_prefix_list_set (peer, afi, safi, direct, name_str);\n\n  return bgp_vty_return (vty, ret);\n}\n\nstatic int\npeer_prefix_list_unset_vty (struct vty *vty, const char *ip_str, afi_t afi,\n\t\t\t    safi_t safi, const char *direct_str)\n{\n  int ret;\n  struct peer *peer;\n  int direct = FILTER_IN;\n\n  peer = peer_and_group_lookup_vty (vty, ip_str);\n  if (! peer)\n    return CMD_WARNING;\n  \n  /* Check filter direction. */\n  if (strncmp (direct_str, \"i\", 1) == 0)\n    direct = FILTER_IN;\n  else if (strncmp (direct_str, \"o\", 1) == 0)\n    direct = FILTER_OUT;\n\n  ret = peer_prefix_list_unset (peer, afi, safi, direct);\n\n  return bgp_vty_return (vty, ret);\n}\n\nDEFUN (neighbor_prefix_list,\n       neighbor_prefix_list_cmd,\n       NEIGHBOR_CMD2 \"prefix-list WORD (in|out)\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Filter updates to/from this neighbor\\n\"\n       \"Name of a prefix list\\n\"\n       \"Filter incoming updates\\n\"\n       \"Filter outgoing updates\\n\")\n{\n  return peer_prefix_list_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t   bgp_node_safi (vty), argv[1], argv[2]);\n}\n\nDEFUN (no_neighbor_prefix_list,\n       no_neighbor_prefix_list_cmd,\n       NO_NEIGHBOR_CMD2 \"prefix-list WORD (in|out)\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Filter updates to/from this neighbor\\n\"\n       \"Name of a prefix list\\n\"\n       \"Filter incoming updates\\n\"\n       \"Filter outgoing updates\\n\")\n{\n  return peer_prefix_list_unset_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t     bgp_node_safi (vty), argv[2]);\n}\n\f\nstatic int\npeer_aslist_set_vty (struct vty *vty, const char *ip_str, \n                     afi_t afi, safi_t safi,\n\t\t     const char *name_str, const char *direct_str)\n{\n  int ret;\n  struct peer *peer;\n  int direct = FILTER_IN;\n\n  peer = peer_and_group_lookup_vty (vty, ip_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  /* Check filter direction. */\n  if (strncmp (direct_str, \"i\", 1) == 0)\n    direct = FILTER_IN;\n  else if (strncmp (direct_str, \"o\", 1) == 0)\n    direct = FILTER_OUT;\n\n  ret = peer_aslist_set (peer, afi, safi, direct, name_str);\n\n  return bgp_vty_return (vty, ret);\n}\n\nstatic int\npeer_aslist_unset_vty (struct vty *vty, const char *ip_str, \n                       afi_t afi, safi_t safi,\n\t\t       const char *direct_str)\n{\n  int ret;\n  struct peer *peer;\n  int direct = FILTER_IN;\n\n  peer = peer_and_group_lookup_vty (vty, ip_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  /* Check filter direction. */\n  if (strncmp (direct_str, \"i\", 1) == 0)\n    direct = FILTER_IN;\n  else if (strncmp (direct_str, \"o\", 1) == 0)\n    direct = FILTER_OUT;\n\n  ret = peer_aslist_unset (peer, afi, safi, direct);\n\n  return bgp_vty_return (vty, ret);\n}\n\nDEFUN (neighbor_filter_list,\n       neighbor_filter_list_cmd,\n       NEIGHBOR_CMD2 \"filter-list WORD (in|out)\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Establish BGP filters\\n\"\n       \"AS path access-list name\\n\"\n       \"Filter incoming routes\\n\"\n       \"Filter outgoing routes\\n\")\n{\n  return peer_aslist_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t      bgp_node_safi (vty), argv[1], argv[2]);\n}\n\nDEFUN (no_neighbor_filter_list,\n       no_neighbor_filter_list_cmd,\n       NO_NEIGHBOR_CMD2 \"filter-list WORD (in|out)\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Establish BGP filters\\n\"\n       \"AS path access-list name\\n\"\n       \"Filter incoming routes\\n\"\n       \"Filter outgoing routes\\n\")\n{\n  return peer_aslist_unset_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\tbgp_node_safi (vty), argv[2]);\n}\n\f\n/* Set route-map to the peer. */\nstatic int\npeer_route_map_set_vty (struct vty *vty, const char *ip_str, \n                        afi_t afi, safi_t safi,\n\t\t\tconst char *name_str, const char *direct_str)\n{\n  int ret;\n  struct peer *peer;\n  int direct = RMAP_IN;\n\n  peer = peer_and_group_lookup_vty (vty, ip_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  /* Check filter direction. */\n  if (strncmp (direct_str, \"in\", 2) == 0)\n    direct = RMAP_IN;\n  else if (strncmp (direct_str, \"o\", 1) == 0)\n    direct = RMAP_OUT;\n  else if (strncmp (direct_str, \"im\", 2) == 0)\n    direct = RMAP_IMPORT;\n  else if (strncmp (direct_str, \"e\", 1) == 0)\n    direct = RMAP_EXPORT;\n\n  ret = peer_route_map_set (peer, afi, safi, direct, name_str);\n\n  return bgp_vty_return (vty, ret);\n}\n\nstatic int\npeer_route_map_unset_vty (struct vty *vty, const char *ip_str, afi_t afi,\n\t\t\t  safi_t safi, const char *direct_str)\n{\n  int ret;\n  struct peer *peer;\n  int direct = RMAP_IN;\n\n  peer = peer_and_group_lookup_vty (vty, ip_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  /* Check filter direction. */\n  if (strncmp (direct_str, \"in\", 2) == 0)\n    direct = RMAP_IN;\n  else if (strncmp (direct_str, \"o\", 1) == 0)\n    direct = RMAP_OUT;\n  else if (strncmp (direct_str, \"im\", 2) == 0)\n    direct = RMAP_IMPORT;\n  else if (strncmp (direct_str, \"e\", 1) == 0)\n    direct = RMAP_EXPORT;\n\n  ret = peer_route_map_unset (peer, afi, safi, direct);\n\n  return bgp_vty_return (vty, ret);\n}\n\nDEFUN (neighbor_route_map,\n       neighbor_route_map_cmd,\n       NEIGHBOR_CMD2 \"route-map WORD (in|out|import|export)\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Apply route map to neighbor\\n\"\n       \"Name of route map\\n\"\n       \"Apply map to incoming routes\\n\"\n       \"Apply map to outbound routes\\n\"\n       \"Apply map to routes going into a Route-Server client's table\\n\"\n       \"Apply map to routes coming from a Route-Server client\")\n{\n  return peer_route_map_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t bgp_node_safi (vty), argv[1], argv[2]);\n}\n\nDEFUN (no_neighbor_route_map,\n       no_neighbor_route_map_cmd,\n       NO_NEIGHBOR_CMD2 \"route-map WORD (in|out|import|export)\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Apply route map to neighbor\\n\"\n       \"Name of route map\\n\"\n       \"Apply map to incoming routes\\n\"\n       \"Apply map to outbound routes\\n\"\n       \"Apply map to routes going into a Route-Server client's table\\n\"\n       \"Apply map to routes coming from a Route-Server client\")\n{\n  return peer_route_map_unset_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t   bgp_node_safi (vty), argv[2]);\n}\n\f\n/* Set unsuppress-map to the peer. */\nstatic int\npeer_unsuppress_map_set_vty (struct vty *vty, const char *ip_str, afi_t afi,\n\t\t\t     safi_t safi, const char *name_str)\n{\n  int ret;\n  struct peer *peer;\n\n  peer = peer_and_group_lookup_vty (vty, ip_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  ret = peer_unsuppress_map_set (peer, afi, safi, name_str);\n\n  return bgp_vty_return (vty, ret);\n}\n\n/* Unset route-map from the peer. */\nstatic int\npeer_unsuppress_map_unset_vty (struct vty *vty, const char *ip_str, afi_t afi,\n\t\t\t       safi_t safi)\n{\n  int ret;\n  struct peer *peer;\n\n  peer = peer_and_group_lookup_vty (vty, ip_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  ret = peer_unsuppress_map_unset (peer, afi, safi);\n\n  return bgp_vty_return (vty, ret);\n}\n\nDEFUN (neighbor_unsuppress_map,\n       neighbor_unsuppress_map_cmd,\n       NEIGHBOR_CMD2 \"unsuppress-map WORD\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Route-map to selectively unsuppress suppressed routes\\n\"\n       \"Name of route map\\n\")\n{\n  return peer_unsuppress_map_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t      bgp_node_safi (vty), argv[1]);\n}\n\nDEFUN (no_neighbor_unsuppress_map,\n       no_neighbor_unsuppress_map_cmd,\n       NO_NEIGHBOR_CMD2 \"unsuppress-map WORD\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Route-map to selectively unsuppress suppressed routes\\n\"\n       \"Name of route map\\n\")\n{\n  return peer_unsuppress_map_unset_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t\tbgp_node_safi (vty));\n}\n\f\nstatic int\npeer_maximum_prefix_set_vty (struct vty *vty, const char *ip_str, afi_t afi,\n\t\t\t     safi_t safi, const char *num_str,  \n\t\t\t     const char *threshold_str, int warning,\n\t\t\t     const char *restart_str)\n{\n  int ret;\n  struct peer *peer;\n  u_int32_t max;\n  u_char threshold;\n  u_int16_t restart;\n\n  peer = peer_and_group_lookup_vty (vty, ip_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  VTY_GET_INTEGER (\"maxmum number\", max, num_str);\n  if (threshold_str)\n    threshold = atoi (threshold_str);\n  else\n    threshold = MAXIMUM_PREFIX_THRESHOLD_DEFAULT;\n\n  if (restart_str)\n    restart = atoi (restart_str);\n  else\n    restart = 0;\n\n  ret = peer_maximum_prefix_set (peer, afi, safi, max, threshold, warning, restart);\n\n  return bgp_vty_return (vty, ret);\n}\n\nstatic int\npeer_maximum_prefix_unset_vty (struct vty *vty, const char *ip_str, afi_t afi,\n\t\t\t       safi_t safi)\n{\n  int ret;\n  struct peer *peer;\n\n  peer = peer_and_group_lookup_vty (vty, ip_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  ret = peer_maximum_prefix_unset (peer, afi, safi);\n\n  return bgp_vty_return (vty, ret);\n}\n\n/* Maximum number of prefix configuration.  prefix count is different\n   for each peer configuration.  So this configuration can be set for\n   each peer configuration. */\nDEFUN (neighbor_maximum_prefix,\n       neighbor_maximum_prefix_cmd,\n       NEIGHBOR_CMD2 \"maximum-prefix <1-4294967295>\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Maximum number of prefix accept from this peer\\n\"\n       \"maximum no. of prefix limit\\n\")\n{\n  return peer_maximum_prefix_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t      bgp_node_safi (vty), argv[1], NULL, 0,\n\t\t\t\t      NULL);\n}\n\nDEFUN (neighbor_maximum_prefix_threshold,\n       neighbor_maximum_prefix_threshold_cmd,\n       NEIGHBOR_CMD2 \"maximum-prefix <1-4294967295> <1-100>\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Maximum number of prefix accept from this peer\\n\"\n       \"maximum no. of prefix limit\\n\"\n       \"Threshold value (%) at which to generate a warning msg\\n\")\n{\n  return peer_maximum_prefix_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t      bgp_node_safi (vty), argv[1], argv[2], 0,\n\t\t\t\t      NULL);\n}\n\nDEFUN (neighbor_maximum_prefix_warning,\n       neighbor_maximum_prefix_warning_cmd,\n       NEIGHBOR_CMD2 \"maximum-prefix <1-4294967295> warning-only\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Maximum number of prefix accept from this peer\\n\"\n       \"maximum no. of prefix limit\\n\"\n       \"Only give warning message when limit is exceeded\\n\")\n{\n  return peer_maximum_prefix_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t      bgp_node_safi (vty), argv[1], NULL, 1,\n\t\t\t\t      NULL);\n}\n\nDEFUN (neighbor_maximum_prefix_threshold_warning,\n       neighbor_maximum_prefix_threshold_warning_cmd,\n       NEIGHBOR_CMD2 \"maximum-prefix <1-4294967295> <1-100> warning-only\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Maximum number of prefix accept from this peer\\n\"\n       \"maximum no. of prefix limit\\n\"\n       \"Threshold value (%) at which to generate a warning msg\\n\"\n       \"Only give warning message when limit is exceeded\\n\")\n{\n  return peer_maximum_prefix_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t      bgp_node_safi (vty), argv[1], argv[2], 1, NULL);\n}\n\nDEFUN (neighbor_maximum_prefix_restart,\n       neighbor_maximum_prefix_restart_cmd,\n       NEIGHBOR_CMD2 \"maximum-prefix <1-4294967295> restart <1-65535>\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Maximum number of prefix accept from this peer\\n\"\n       \"maximum no. of prefix limit\\n\"\n       \"Restart bgp connection after limit is exceeded\\n\"\n       \"Restart interval in minutes\")\n{\n  return peer_maximum_prefix_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t      bgp_node_safi (vty), argv[1], NULL, 0, argv[2]);\n}\n\nDEFUN (neighbor_maximum_prefix_threshold_restart,\n       neighbor_maximum_prefix_threshold_restart_cmd,\n       NEIGHBOR_CMD2 \"maximum-prefix <1-4294967295> <1-100> restart <1-65535>\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Maximum number of prefix accept from this peer\\n\"\n       \"maximum no. of prefix limit\\n\"\n       \"Threshold value (%) at which to generate a warning msg\\n\"\n       \"Restart bgp connection after limit is exceeded\\n\"\n       \"Restart interval in minutes\")\n{\n  return peer_maximum_prefix_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t      bgp_node_safi (vty), argv[1], argv[2], 0, argv[3]);\n}\n\nDEFUN (no_neighbor_maximum_prefix,\n       no_neighbor_maximum_prefix_cmd,\n       NO_NEIGHBOR_CMD2 \"maximum-prefix\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Maximum number of prefix accept from this peer\\n\")\n{\n  return peer_maximum_prefix_unset_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t\tbgp_node_safi (vty));\n}\n \nALIAS (no_neighbor_maximum_prefix,\n       no_neighbor_maximum_prefix_val_cmd,\n       NO_NEIGHBOR_CMD2 \"maximum-prefix <1-4294967295>\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Maximum number of prefix accept from this peer\\n\"\n       \"maximum no. of prefix limit\\n\")\n\nALIAS (no_neighbor_maximum_prefix,\n       no_neighbor_maximum_prefix_threshold_cmd,\n       NO_NEIGHBOR_CMD2 \"maximum-prefix <1-4294967295> warning-only\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Maximum number of prefix accept from this peer\\n\"\n       \"maximum no. of prefix limit\\n\"\n       \"Threshold value (%) at which to generate a warning msg\\n\")\n\nALIAS (no_neighbor_maximum_prefix,\n       no_neighbor_maximum_prefix_warning_cmd,\n       NO_NEIGHBOR_CMD2 \"maximum-prefix <1-4294967295> warning-only\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Maximum number of prefix accept from this peer\\n\"\n       \"maximum no. of prefix limit\\n\"\n       \"Only give warning message when limit is exceeded\\n\")\n\nALIAS (no_neighbor_maximum_prefix,\n       no_neighbor_maximum_prefix_threshold_warning_cmd,\n       NO_NEIGHBOR_CMD2 \"maximum-prefix <1-4294967295> <1-100> warning-only\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Maximum number of prefix accept from this peer\\n\"\n       \"maximum no. of prefix limit\\n\"\n       \"Threshold value (%) at which to generate a warning msg\\n\"\n       \"Only give warning message when limit is exceeded\\n\")\n\nALIAS (no_neighbor_maximum_prefix,\n       no_neighbor_maximum_prefix_restart_cmd,\n       NO_NEIGHBOR_CMD2 \"maximum-prefix <1-4294967295> restart <1-65535>\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Maximum number of prefix accept from this peer\\n\"\n       \"maximum no. of prefix limit\\n\"\n       \"Restart bgp connection after limit is exceeded\\n\"\n       \"Restart interval in minutes\")\n\nALIAS (no_neighbor_maximum_prefix,\n       no_neighbor_maximum_prefix_threshold_restart_cmd,\n       NO_NEIGHBOR_CMD2 \"maximum-prefix <1-4294967295> <1-100> restart <1-65535>\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Maximum number of prefix accept from this peer\\n\"\n       \"maximum no. of prefix limit\\n\"\n       \"Threshold value (%) at which to generate a warning msg\\n\"\n       \"Restart bgp connection after limit is exceeded\\n\"\n       \"Restart interval in minutes\")\n\f\n/* \"neighbor allowas-in\" */\nDEFUN (neighbor_allowas_in,\n       neighbor_allowas_in_cmd,\n       NEIGHBOR_CMD2 \"allowas-in\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Accept as-path with my AS present in it\\n\")\n{\n  int ret;\n  struct peer *peer;\n  unsigned int allow_num;\n\n  peer = peer_and_group_lookup_vty (vty, argv[0]);\n  if (! peer)\n    return CMD_WARNING;\n\n  if (argc == 1)\n    allow_num = 3;\n  else\n    VTY_GET_INTEGER_RANGE (\"AS number\", allow_num, argv[1], 1, 10);\n\n  ret = peer_allowas_in_set (peer, bgp_node_afi (vty), bgp_node_safi (vty),\n\t\t\t     allow_num);\n\n  return bgp_vty_return (vty, ret);\n}\n\nALIAS (neighbor_allowas_in,\n       neighbor_allowas_in_arg_cmd,\n       NEIGHBOR_CMD2 \"allowas-in <1-10>\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Accept as-path with my AS present in it\\n\"\n       \"Number of occurances of AS number\\n\")\n\nDEFUN (no_neighbor_allowas_in,\n       no_neighbor_allowas_in_cmd,\n       NO_NEIGHBOR_CMD2 \"allowas-in\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"allow local ASN appears in aspath attribute\\n\")\n{\n  int ret;\n  struct peer *peer;\n\n  peer = peer_and_group_lookup_vty (vty, argv[0]);\n  if (! peer)\n    return CMD_WARNING;\n\n  ret = peer_allowas_in_unset (peer, bgp_node_afi (vty), bgp_node_safi (vty));\n\n  return bgp_vty_return (vty, ret);\n}\n\f\n/* Address family configuration.  */\nDEFUN (address_family_ipv4,\n       address_family_ipv4_cmd,\n       \"address-family ipv4\",\n       \"Enter Address Family command mode\\n\"\n       \"Address family\\n\")\n{\n  vty->node = BGP_IPV4_NODE;\n  return CMD_SUCCESS;\n}\n\nDEFUN (address_family_ipv4_safi,\n       address_family_ipv4_safi_cmd,\n       \"address-family ipv4 (unicast|multicast)\",\n       \"Enter Address Family command mode\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\")\n{\n  if (strncmp (argv[0], \"m\", 1) == 0)\n    vty->node = BGP_IPV4M_NODE;\n  else\n    vty->node = BGP_IPV4_NODE;\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (address_family_ipv6,\n       address_family_ipv6_cmd,\n       \"address-family ipv6\",\n       \"Enter Address Family command mode\\n\"\n       \"Address family\\n\")\n{\n  vty->node = BGP_IPV6_NODE;\n  return CMD_SUCCESS;\n}\n\nDEFUN (address_family_ipv6_safi,\n       address_family_ipv6_safi_cmd,\n       \"address-family ipv6 (unicast|multicast)\",\n       \"Enter Address Family command mode\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\")\n{\n  if (strncmp (argv[0], \"m\", 1) == 0)\n    vty->node = BGP_IPV6M_NODE;\n  else\n    vty->node = BGP_IPV6_NODE;\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (address_family_vpnv4,\n       address_family_vpnv4_cmd,\n       \"address-family vpnv4\",\n       \"Enter Address Family command mode\\n\"\n       \"Address family\\n\")\n{\n  vty->node = BGP_VPNV4_NODE;\n  return CMD_SUCCESS;\n}\n\nALIAS (address_family_vpnv4,\n       address_family_vpnv4_unicast_cmd,\n       \"address-family vpnv4 unicast\",\n       \"Enter Address Family command mode\\n\"\n       \"Address family\\n\"\n       \"Address Family Modifier\\n\")\n\nDEFUN (exit_address_family,\n       exit_address_family_cmd,\n       \"exit-address-family\",\n       \"Exit from Address Family configuration mode\\n\")\n{\n  if (vty->node == BGP_IPV4_NODE\n      || vty->node == BGP_IPV4M_NODE\n      || vty->node == BGP_VPNV4_NODE\n      || vty->node == BGP_IPV6_NODE\n      || vty->node == BGP_IPV6M_NODE)\n    vty->node = BGP_NODE;\n  return CMD_SUCCESS;\n}\n\f\n/* BGP clear sort. */\nenum clear_sort\n{\n  clear_all,\n  clear_peer,\n  clear_group,\n  clear_external,\n  clear_as\n};\n\nstatic void\nbgp_clear_vty_error (struct vty *vty, struct peer *peer, afi_t afi,\n\t\t     safi_t safi, int error)\n{\n  switch (error)\n    {\n    case BGP_ERR_AF_UNCONFIGURED:\n      vty_out (vty,\n\t       \"%%BGP: Enable %s %s address family for the neighbor %s%s\",\n\t       afi == AFI_IP6 ? \"IPv6\" : safi == SAFI_MPLS_VPN ? \"VPNv4\" : \"IPv4\",\n\t       safi == SAFI_MULTICAST ? \"Multicast\" : \"Unicast\",\n\t       peer->host, VTY_NEWLINE);\n      break;\n    case BGP_ERR_SOFT_RECONFIG_UNCONFIGURED:\n      vty_out (vty, \"%%BGP: Inbound soft reconfig for %s not possible as it%s      has neither refresh capability, nor inbound soft reconfig%s\", peer->host, VTY_NEWLINE, VTY_NEWLINE);\n      break;\n    default:\n      break;\n    }\n}\n\n/* `clear ip bgp' functions. */\nstatic int\nbgp_clear (struct vty *vty, struct bgp *bgp,  afi_t afi, safi_t safi,\n           enum clear_sort sort,enum bgp_clear_type stype, const char *arg)\n{\n  int ret;\n  struct peer *peer;\n  struct listnode *node, *nnode;\n\n  /* Clear all neighbors. */\n  if (sort == clear_all)\n    {\n      for (ALL_LIST_ELEMENTS (bgp->peer, node, nnode, peer))\n\t{\n\t  if (stype == BGP_CLEAR_SOFT_NONE)\n\t    ret = peer_clear (peer);\n\t  else\n\t    ret = peer_clear_soft (peer, afi, safi, stype);\n\n\t  if (ret < 0)\n\t    bgp_clear_vty_error (vty, peer, afi, safi, ret);\n\t}\n      return 0;\n    }\n\n  /* Clear specified neighbors. */\n  if (sort == clear_peer)\n    {\n      union sockunion su;\n      int ret;\n\n      /* Make sockunion for lookup. */\n      ret = str2sockunion (arg, &su);\n      if (ret < 0)\n\t{\n\t  vty_out (vty, \"Malformed address: %s%s\", arg, VTY_NEWLINE);\n\t  return -1;\n\t}\n      peer = peer_lookup (bgp, &su);\n      if (! peer)\n\t{\n\t  vty_out (vty, \"%%BGP: Unknown neighbor - \\\"%s\\\"%s\", arg, VTY_NEWLINE);\n\t  return -1;\n\t}\n\n      if (stype == BGP_CLEAR_SOFT_NONE)\n\tret = peer_clear (peer);\n      else\n\tret = peer_clear_soft (peer, afi, safi, stype);\n\n      if (ret < 0)\n\tbgp_clear_vty_error (vty, peer, afi, safi, ret);\n\n      return 0;\n    }\n\n  /* Clear all peer-group members. */\n  if (sort == clear_group)\n    {\n      struct peer_group *group;\n\n      group = peer_group_lookup (bgp, arg);\n      if (! group)\n\t{\n\t  vty_out (vty, \"%%BGP: No such peer-group %s%s\", arg, VTY_NEWLINE);\n\t  return -1; \n\t}\n\n      for (ALL_LIST_ELEMENTS (group->peer, node, nnode, peer))\n\t{\n\t  if (stype == BGP_CLEAR_SOFT_NONE)\n\t    {\n\t      ret = peer_clear (peer);\n\t      continue;\n\t    }\n\n\t  if (! peer->af_group[afi][safi])\n\t    continue;\n\n\t  ret = peer_clear_soft (peer, afi, safi, stype);\n\n\t  if (ret < 0)\n\t    bgp_clear_vty_error (vty, peer, afi, safi, ret);\n\t}\n      return 0;\n    }\n\n  if (sort == clear_external)\n    {\n      for (ALL_LIST_ELEMENTS (bgp->peer, node, nnode, peer))\n\t{\n\t  if (peer_sort (peer) == BGP_PEER_IBGP) \n\t    continue;\n\n\t  if (stype == BGP_CLEAR_SOFT_NONE)\n\t    ret = peer_clear (peer);\n\t  else\n\t    ret = peer_clear_soft (peer, afi, safi, stype);\n\n\t  if (ret < 0)\n\t    bgp_clear_vty_error (vty, peer, afi, safi, ret);\n\t}\n      return 0;\n    }\n\n  if (sort == clear_as)\n    {\n      as_t as;\n      unsigned long as_ul;\n      char *endptr = NULL;\n      int find = 0;\n\n      as_ul = strtoul(arg, &endptr, 10);\n\n      if ((as_ul == ULONG_MAX) || (*endptr != '\\0') || (as_ul > USHRT_MAX))\n\t{\n\t  vty_out (vty, \"Invalid AS number%s\", VTY_NEWLINE); \n\t  return -1;\n\t}\n      as = (as_t) as_ul;\n\n      for (ALL_LIST_ELEMENTS (bgp->peer, node, nnode, peer))\n\t{\n\t  if (peer->as != as) \n\t    continue;\n\n\t  find = 1;\n\t  if (stype == BGP_CLEAR_SOFT_NONE)\n\t    ret = peer_clear (peer);\n\t  else\n\t    ret = peer_clear_soft (peer, afi, safi, stype);\n\n\t  if (ret < 0)\n\t    bgp_clear_vty_error (vty, peer, afi, safi, ret);\n\t}\n      if (! find)\n\tvty_out (vty, \"%%BGP: No peer is configured with AS %s%s\", arg,\n\t\t VTY_NEWLINE);\n      return 0;\n    }\n\n  return 0;\n}\n\nstatic int\nbgp_clear_vty (struct vty *vty, const char *name, afi_t afi, safi_t safi,\n               enum clear_sort sort, enum bgp_clear_type stype, \n               const char *arg)\n{\n  int ret;\n  struct bgp *bgp;\n\n  /* BGP structure lookup. */\n  if (name)\n    {\n      bgp = bgp_lookup_by_name (name);\n      if (bgp == NULL)\n        {\n          vty_out (vty, \"Can't find BGP view %s%s\", name, VTY_NEWLINE);\n          return CMD_WARNING;\n        }\n    }\n  else\n    {\n      bgp = bgp_get_default ();\n      if (bgp == NULL)\n        {\n          vty_out (vty, \"No BGP process is configured%s\", VTY_NEWLINE);\n          return CMD_WARNING;\n        }\n    }\n\n  ret =  bgp_clear (vty, bgp, afi, safi, sort, stype, arg);\n  if (ret < 0)\n    return CMD_WARNING;\n\n  return CMD_SUCCESS;\n}\n  \nDEFUN (clear_ip_bgp_all,\n       clear_ip_bgp_all_cmd,\n       \"clear ip bgp *\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all peers\\n\")\n{\n  if (argc == 1)\n    return bgp_clear_vty (vty, argv[0], 0, 0, clear_all, BGP_CLEAR_SOFT_NONE, NULL);    \n\n  return bgp_clear_vty (vty, NULL, 0, 0, clear_all, BGP_CLEAR_SOFT_NONE, NULL);\n}\n\nALIAS (clear_ip_bgp_all,\n       clear_bgp_all_cmd,\n       \"clear bgp *\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear all peers\\n\")\n\nALIAS (clear_ip_bgp_all,\n       clear_bgp_ipv6_all_cmd,\n       \"clear bgp ipv6 *\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear all peers\\n\")\n\nALIAS (clear_ip_bgp_all,\n       clear_ip_bgp_instance_all_cmd,\n       \"clear ip bgp view WORD *\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"view name\\n\"\n       \"Clear all peers\\n\")\n\nALIAS (clear_ip_bgp_all,\n       clear_bgp_instance_all_cmd,\n       \"clear bgp view WORD *\",\n       CLEAR_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"view name\\n\"\n       \"Clear all peers\\n\")\n\nDEFUN (clear_ip_bgp_peer,\n       clear_ip_bgp_peer_cmd, \n       \"clear ip bgp (A.B.C.D|X:X::X:X)\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP neighbor IP address to clear\\n\"\n       \"BGP IPv6 neighbor to clear\\n\")\n{\n  return bgp_clear_vty (vty, NULL, 0, 0, clear_peer, BGP_CLEAR_SOFT_NONE, argv[0]);\n}\n\nALIAS (clear_ip_bgp_peer,\n       clear_bgp_peer_cmd, \n       \"clear bgp (A.B.C.D|X:X::X:X)\",\n       CLEAR_STR\n       BGP_STR\n       \"BGP neighbor address to clear\\n\"\n       \"BGP IPv6 neighbor to clear\\n\")\n\nALIAS (clear_ip_bgp_peer,\n       clear_bgp_ipv6_peer_cmd, \n       \"clear bgp ipv6 (A.B.C.D|X:X::X:X)\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"BGP neighbor address to clear\\n\"\n       \"BGP IPv6 neighbor to clear\\n\")\n\nDEFUN (clear_ip_bgp_peer_group,\n       clear_ip_bgp_peer_group_cmd, \n       \"clear ip bgp peer-group WORD\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\")\n{\n  return bgp_clear_vty (vty, NULL, 0, 0, clear_group, BGP_CLEAR_SOFT_NONE, argv[0]);\n}\n\nALIAS (clear_ip_bgp_peer_group,\n       clear_bgp_peer_group_cmd, \n       \"clear bgp peer-group WORD\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\")\n\nALIAS (clear_ip_bgp_peer_group,\n       clear_bgp_ipv6_peer_group_cmd, \n       \"clear bgp ipv6 peer-group WORD\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\")\n\nDEFUN (clear_ip_bgp_external,\n       clear_ip_bgp_external_cmd,\n       \"clear ip bgp external\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all external peers\\n\")\n{\n  return bgp_clear_vty (vty, NULL, 0, 0, clear_external, BGP_CLEAR_SOFT_NONE, NULL);\n}\n\nALIAS (clear_ip_bgp_external,\n       clear_bgp_external_cmd, \n       \"clear bgp external\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear all external peers\\n\")\n\nALIAS (clear_ip_bgp_external,\n       clear_bgp_ipv6_external_cmd, \n       \"clear bgp ipv6 external\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear all external peers\\n\")\n\nDEFUN (clear_ip_bgp_as,\n       clear_ip_bgp_as_cmd,\n       \"clear ip bgp <1-65535>\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\")\n{\n  return bgp_clear_vty (vty, NULL, 0, 0, clear_as, BGP_CLEAR_SOFT_NONE, argv[0]);\n}       \n\nALIAS (clear_ip_bgp_as,\n       clear_bgp_as_cmd,\n       \"clear bgp <1-65535>\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\")\n\nALIAS (clear_ip_bgp_as,\n       clear_bgp_ipv6_as_cmd,\n       \"clear bgp ipv6 <1-65535>\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear peers with the AS number\\n\")\n\f\n/* Outbound soft-reconfiguration */\nDEFUN (clear_ip_bgp_all_soft_out,\n       clear_ip_bgp_all_soft_out_cmd,\n       \"clear ip bgp * soft out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n{\n  if (argc == 1)\n    return bgp_clear_vty (vty, argv[0], AFI_IP, SAFI_UNICAST, clear_all,\n                          BGP_CLEAR_SOFT_OUT, NULL);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_all,\n\t\t\tBGP_CLEAR_SOFT_OUT, NULL);\n}\n\nALIAS (clear_ip_bgp_all_soft_out,\n       clear_ip_bgp_all_out_cmd,\n       \"clear ip bgp * out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nALIAS (clear_ip_bgp_all_soft_out,\n       clear_ip_bgp_instance_all_soft_out_cmd,\n       \"clear ip bgp view WORD * soft out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"view name\\n\"\n       \"Clear all peers\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nDEFUN (clear_ip_bgp_all_ipv4_soft_out,\n       clear_ip_bgp_all_ipv4_soft_out_cmd,\n       \"clear ip bgp * ipv4 (unicast|multicast) soft out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n{\n  if (strncmp (argv[0], \"m\", 1) == 0)\n    return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MULTICAST, clear_all,\n\t\t\t  BGP_CLEAR_SOFT_OUT, NULL);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_all,\n\t\t\tBGP_CLEAR_SOFT_OUT, NULL);\n}\n\nALIAS (clear_ip_bgp_all_ipv4_soft_out,\n       clear_ip_bgp_all_ipv4_out_cmd,\n       \"clear ip bgp * ipv4 (unicast|multicast) out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nDEFUN (clear_ip_bgp_instance_all_ipv4_soft_out,\n       clear_ip_bgp_instance_all_ipv4_soft_out_cmd,\n       \"clear ip bgp view WORD * ipv4 (unicast|multicast) soft out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"view name\\n\"\n       \"Clear all peers\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig outbound update\\n\")\n{\n  if (strncmp (argv[1], \"m\", 1) == 0)\n    return bgp_clear_vty (vty, argv[0], AFI_IP, SAFI_MULTICAST, clear_all,\n                          BGP_CLEAR_SOFT_OUT, NULL);\n\n  return bgp_clear_vty (vty, argv[0], AFI_IP, SAFI_UNICAST, clear_all,\n                        BGP_CLEAR_SOFT_OUT, NULL);\n}\n\nDEFUN (clear_ip_bgp_all_vpnv4_soft_out,\n       clear_ip_bgp_all_vpnv4_soft_out_cmd,\n       \"clear ip bgp * vpnv4 unicast soft out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Address family\\n\"\n       \"Address Family Modifier\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MPLS_VPN, clear_all,\n\t\t\tBGP_CLEAR_SOFT_OUT, NULL);\n}\n\nALIAS (clear_ip_bgp_all_vpnv4_soft_out,\n       clear_ip_bgp_all_vpnv4_out_cmd,\n       \"clear ip bgp * vpnv4 unicast out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Address family\\n\"\n       \"Address Family Modifier\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nDEFUN (clear_bgp_all_soft_out,\n       clear_bgp_all_soft_out_cmd,\n       \"clear bgp * soft out\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n{\n  if (argc == 1)\n    return bgp_clear_vty (vty, argv[0], AFI_IP6, SAFI_UNICAST, clear_all,\n                          BGP_CLEAR_SOFT_OUT, NULL);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_all,\n\t\t\tBGP_CLEAR_SOFT_OUT, NULL);\n}\n\nALIAS (clear_bgp_all_soft_out,\n       clear_bgp_instance_all_soft_out_cmd,\n       \"clear bgp view WORD * soft out\",\n       CLEAR_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"view name\\n\"\n       \"Clear all peers\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nALIAS (clear_bgp_all_soft_out,\n       clear_bgp_all_out_cmd,\n       \"clear bgp * out\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nALIAS (clear_bgp_all_soft_out,\n       clear_bgp_ipv6_all_soft_out_cmd,\n       \"clear bgp ipv6 * soft out\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear all peers\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nALIAS (clear_bgp_all_soft_out,\n       clear_bgp_ipv6_all_out_cmd,\n       \"clear bgp ipv6 * out\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear all peers\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nDEFUN (clear_ip_bgp_peer_soft_out,\n       clear_ip_bgp_peer_soft_out_cmd,\n       \"clear ip bgp A.B.C.D soft out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP neighbor address to clear\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_peer,\n\t\t\tBGP_CLEAR_SOFT_OUT, argv[0]);\n}\n\nALIAS (clear_ip_bgp_peer_soft_out,\n       clear_ip_bgp_peer_out_cmd,\n       \"clear ip bgp A.B.C.D out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP neighbor address to clear\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nDEFUN (clear_ip_bgp_peer_ipv4_soft_out,\n       clear_ip_bgp_peer_ipv4_soft_out_cmd,\n       \"clear ip bgp A.B.C.D ipv4 (unicast|multicast) soft out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP neighbor address to clear\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n{\n  if (strncmp (argv[1], \"m\", 1) == 0)\n    return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MULTICAST, clear_peer,\n\t\t\t  BGP_CLEAR_SOFT_OUT, argv[0]);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_peer,\n\t\t\tBGP_CLEAR_SOFT_OUT, argv[0]);\n}\n\nALIAS (clear_ip_bgp_peer_ipv4_soft_out,\n       clear_ip_bgp_peer_ipv4_out_cmd,\n       \"clear ip bgp A.B.C.D ipv4 (unicast|multicast) out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP neighbor address to clear\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nDEFUN (clear_ip_bgp_peer_vpnv4_soft_out,\n       clear_ip_bgp_peer_vpnv4_soft_out_cmd,\n       \"clear ip bgp A.B.C.D vpnv4 unicast soft out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP neighbor address to clear\\n\"\n       \"Address family\\n\"\n       \"Address Family Modifier\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MPLS_VPN, clear_peer,\n\t\t\tBGP_CLEAR_SOFT_OUT, argv[0]);\n}\n\nALIAS (clear_ip_bgp_peer_vpnv4_soft_out,\n       clear_ip_bgp_peer_vpnv4_out_cmd,\n       \"clear ip bgp A.B.C.D vpnv4 unicast out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP neighbor address to clear\\n\"\n       \"Address family\\n\"\n       \"Address Family Modifier\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nDEFUN (clear_bgp_peer_soft_out,\n       clear_bgp_peer_soft_out_cmd,\n       \"clear bgp (A.B.C.D|X:X::X:X) soft out\",\n       CLEAR_STR\n       BGP_STR\n       \"BGP neighbor address to clear\\n\"\n       \"BGP IPv6 neighbor to clear\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_peer,\n\t\t\tBGP_CLEAR_SOFT_OUT, argv[0]);\n}\n\nALIAS (clear_bgp_peer_soft_out,\n       clear_bgp_ipv6_peer_soft_out_cmd,\n       \"clear bgp ipv6 (A.B.C.D|X:X::X:X) soft out\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"BGP neighbor address to clear\\n\"\n       \"BGP IPv6 neighbor to clear\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nALIAS (clear_bgp_peer_soft_out,\n       clear_bgp_peer_out_cmd,\n       \"clear bgp (A.B.C.D|X:X::X:X) out\",\n       CLEAR_STR\n       BGP_STR\n       \"BGP neighbor address to clear\\n\"\n       \"BGP IPv6 neighbor to clear\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nALIAS (clear_bgp_peer_soft_out,\n       clear_bgp_ipv6_peer_out_cmd,\n       \"clear bgp ipv6 (A.B.C.D|X:X::X:X) out\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"BGP neighbor address to clear\\n\"\n       \"BGP IPv6 neighbor to clear\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nDEFUN (clear_ip_bgp_peer_group_soft_out,\n       clear_ip_bgp_peer_group_soft_out_cmd, \n       \"clear ip bgp peer-group WORD soft out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_group,\n\t\t\tBGP_CLEAR_SOFT_OUT, argv[0]);\n}\n\nALIAS (clear_ip_bgp_peer_group_soft_out,\n       clear_ip_bgp_peer_group_out_cmd, \n       \"clear ip bgp peer-group WORD out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nDEFUN (clear_ip_bgp_peer_group_ipv4_soft_out,\n       clear_ip_bgp_peer_group_ipv4_soft_out_cmd,\n       \"clear ip bgp peer-group WORD ipv4 (unicast|multicast) soft out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n{\n  if (strncmp (argv[1], \"m\", 1) == 0)\n    return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MULTICAST, clear_group,\n\t\t\t  BGP_CLEAR_SOFT_OUT, argv[0]);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_group,\n\t\t\tBGP_CLEAR_SOFT_OUT, argv[0]);\n}\n\nALIAS (clear_ip_bgp_peer_group_ipv4_soft_out,\n       clear_ip_bgp_peer_group_ipv4_out_cmd,\n       \"clear ip bgp peer-group WORD ipv4 (unicast|multicast) out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nDEFUN (clear_bgp_peer_group_soft_out,\n       clear_bgp_peer_group_soft_out_cmd,\n       \"clear bgp peer-group WORD soft out\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_group,\n\t\t\tBGP_CLEAR_SOFT_OUT, argv[0]);\n}\n\nALIAS (clear_bgp_peer_group_soft_out,\n       clear_bgp_ipv6_peer_group_soft_out_cmd,\n       \"clear bgp ipv6 peer-group WORD soft out\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nALIAS (clear_bgp_peer_group_soft_out,\n       clear_bgp_peer_group_out_cmd,\n       \"clear bgp peer-group WORD out\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nALIAS (clear_bgp_peer_group_soft_out,\n       clear_bgp_ipv6_peer_group_out_cmd,\n       \"clear bgp ipv6 peer-group WORD out\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nDEFUN (clear_ip_bgp_external_soft_out,\n       clear_ip_bgp_external_soft_out_cmd, \n       \"clear ip bgp external soft out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all external peers\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_external,\n\t\t\tBGP_CLEAR_SOFT_OUT, NULL);\n}\n\nALIAS (clear_ip_bgp_external_soft_out,\n       clear_ip_bgp_external_out_cmd, \n       \"clear ip bgp external out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all external peers\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nDEFUN (clear_ip_bgp_external_ipv4_soft_out,\n       clear_ip_bgp_external_ipv4_soft_out_cmd,\n       \"clear ip bgp external ipv4 (unicast|multicast) soft out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all external peers\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n{\n  if (strncmp (argv[0], \"m\", 1) == 0)\n    return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MULTICAST, clear_external,\n\t\t\t  BGP_CLEAR_SOFT_OUT, NULL);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_external,\n\t\t\tBGP_CLEAR_SOFT_OUT, NULL);\n}\n\nALIAS (clear_ip_bgp_external_ipv4_soft_out,\n       clear_ip_bgp_external_ipv4_out_cmd,\n       \"clear ip bgp external ipv4 (unicast|multicast) out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all external peers\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nDEFUN (clear_bgp_external_soft_out,\n       clear_bgp_external_soft_out_cmd,\n       \"clear bgp external soft out\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear all external peers\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_external,\n\t\t\tBGP_CLEAR_SOFT_OUT, NULL);\n}\n\nALIAS (clear_bgp_external_soft_out,\n       clear_bgp_ipv6_external_soft_out_cmd,\n       \"clear bgp ipv6 external soft out\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear all external peers\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nALIAS (clear_bgp_external_soft_out,\n       clear_bgp_external_out_cmd,\n       \"clear bgp external out\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear all external peers\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nALIAS (clear_bgp_external_soft_out,\n       clear_bgp_ipv6_external_out_cmd,\n       \"clear bgp ipv6 external WORD out\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear all external peers\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nDEFUN (clear_ip_bgp_as_soft_out,\n       clear_ip_bgp_as_soft_out_cmd,\n       \"clear ip bgp <1-65535> soft out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_as,\n\t\t\tBGP_CLEAR_SOFT_OUT, argv[0]);\n}\n\nALIAS (clear_ip_bgp_as_soft_out,\n       clear_ip_bgp_as_out_cmd,\n       \"clear ip bgp <1-65535> out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nDEFUN (clear_ip_bgp_as_ipv4_soft_out,\n       clear_ip_bgp_as_ipv4_soft_out_cmd,\n       \"clear ip bgp <1-65535> ipv4 (unicast|multicast) soft out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n{\n  if (strncmp (argv[1], \"m\", 1) == 0)\n    return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MULTICAST, clear_as,\n\t\t\t  BGP_CLEAR_SOFT_OUT, argv[0]);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_as,\n\t\t\tBGP_CLEAR_SOFT_OUT, argv[0]);\n}\n\nALIAS (clear_ip_bgp_as_ipv4_soft_out,\n       clear_ip_bgp_as_ipv4_out_cmd,\n       \"clear ip bgp <1-65535> ipv4 (unicast|multicast) out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nDEFUN (clear_ip_bgp_as_vpnv4_soft_out,\n       clear_ip_bgp_as_vpnv4_soft_out_cmd,\n       \"clear ip bgp <1-65535> vpnv4 unicast soft out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MPLS_VPN, clear_as,\n\t\t\tBGP_CLEAR_SOFT_OUT, argv[0]);\n}\n\nALIAS (clear_ip_bgp_as_vpnv4_soft_out,\n       clear_ip_bgp_as_vpnv4_out_cmd,\n       \"clear ip bgp <1-65535> vpnv4 unicast out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nDEFUN (clear_bgp_as_soft_out,\n       clear_bgp_as_soft_out_cmd,\n       \"clear bgp <1-65535> soft out\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_as,\n\t\t\tBGP_CLEAR_SOFT_OUT, argv[0]);\n}\n\nALIAS (clear_bgp_as_soft_out,\n       clear_bgp_ipv6_as_soft_out_cmd,\n       \"clear bgp ipv6 <1-65535> soft out\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear peers with the AS number\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nALIAS (clear_bgp_as_soft_out,\n       clear_bgp_as_out_cmd,\n       \"clear bgp <1-65535> out\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nALIAS (clear_bgp_as_soft_out,\n       clear_bgp_ipv6_as_out_cmd,\n       \"clear bgp ipv6 <1-65535> out\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear peers with the AS number\\n\"\n       \"Soft reconfig outbound update\\n\")\n\f\n/* Inbound soft-reconfiguration */\nDEFUN (clear_ip_bgp_all_soft_in,\n       clear_ip_bgp_all_soft_in_cmd,\n       \"clear ip bgp * soft in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n{\n  if (argc == 1)\n    return bgp_clear_vty (vty, argv[0], AFI_IP, SAFI_UNICAST, clear_all,\n                          BGP_CLEAR_SOFT_IN, NULL);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_all,\n\t\t\tBGP_CLEAR_SOFT_IN, NULL);\n}\n\nALIAS (clear_ip_bgp_all_soft_in,\n       clear_ip_bgp_instance_all_soft_in_cmd,\n       \"clear ip bgp view WORD * soft in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"view name\\n\"\n       \"Clear all peers\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nALIAS (clear_ip_bgp_all_soft_in,\n       clear_ip_bgp_all_in_cmd,\n       \"clear ip bgp * in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nDEFUN (clear_ip_bgp_all_in_prefix_filter,\n       clear_ip_bgp_all_in_prefix_filter_cmd,\n       \"clear ip bgp * in prefix-filter\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Soft reconfig inbound update\\n\"\n       \"Push out prefix-list ORF and do inbound soft reconfig\\n\")\n{\n  if (argc== 1)\n    return bgp_clear_vty (vty, argv[0], AFI_IP, SAFI_UNICAST, clear_all,\n                          BGP_CLEAR_SOFT_IN_ORF_PREFIX, NULL);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_all,\n\t\t\tBGP_CLEAR_SOFT_IN_ORF_PREFIX, NULL);\n}\n\nALIAS (clear_ip_bgp_all_in_prefix_filter,\n       clear_ip_bgp_instance_all_in_prefix_filter_cmd,\n       \"clear ip bgp view WORD * in prefix-filter\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"view name\\n\"\n       \"Clear all peers\\n\"\n       \"Soft reconfig inbound update\\n\"\n       \"Push out prefix-list ORF and do inbound soft reconfig\\n\")\n\n\nDEFUN (clear_ip_bgp_all_ipv4_soft_in,\n       clear_ip_bgp_all_ipv4_soft_in_cmd,\n       \"clear ip bgp * ipv4 (unicast|multicast) soft in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n{\n  if (strncmp (argv[0], \"m\", 1) == 0)\n    return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MULTICAST, clear_all,\n\t\t\t  BGP_CLEAR_SOFT_IN, NULL);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_all,\n\t\t\tBGP_CLEAR_SOFT_IN, NULL);\n}\n\nALIAS (clear_ip_bgp_all_ipv4_soft_in,\n       clear_ip_bgp_all_ipv4_in_cmd,\n       \"clear ip bgp * ipv4 (unicast|multicast) in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nDEFUN (clear_ip_bgp_instance_all_ipv4_soft_in,\n       clear_ip_bgp_instance_all_ipv4_soft_in_cmd,\n       \"clear ip bgp view WORD * ipv4 (unicast|multicast) soft in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"view name\\n\"\n       \"Clear all peers\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n{\n  if (strncmp (argv[1], \"m\", 1) == 0)\n    return bgp_clear_vty (vty, argv[0], AFI_IP, SAFI_MULTICAST, clear_all,\n                          BGP_CLEAR_SOFT_IN, NULL);\n\n  return bgp_clear_vty (vty, argv[0], AFI_IP, SAFI_UNICAST, clear_all,\n                        BGP_CLEAR_SOFT_IN, NULL);\n}\n\nDEFUN (clear_ip_bgp_all_ipv4_in_prefix_filter,\n       clear_ip_bgp_all_ipv4_in_prefix_filter_cmd,\n       \"clear ip bgp * ipv4 (unicast|multicast) in prefix-filter\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig inbound update\\n\"\n       \"Push out prefix-list ORF and do inbound soft reconfig\\n\")\n{\n  if (strncmp (argv[0], \"m\", 1) == 0)\n    return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MULTICAST, clear_all,\n\t\t\t  BGP_CLEAR_SOFT_IN_ORF_PREFIX, NULL);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_all,\n\t\t\tBGP_CLEAR_SOFT_IN_ORF_PREFIX, NULL);\n}\n\nDEFUN (clear_ip_bgp_instance_all_ipv4_in_prefix_filter,\n       clear_ip_bgp_instance_all_ipv4_in_prefix_filter_cmd,\n       \"clear ip bgp view WORD * ipv4 (unicast|multicast) in prefix-filter\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig inbound update\\n\"\n       \"Push out prefix-list ORF and do inbound soft reconfig\\n\")\n{\n  if (strncmp (argv[1], \"m\", 1) == 0)\n    return bgp_clear_vty (vty, argv[0], AFI_IP, SAFI_MULTICAST, clear_all,\n                          BGP_CLEAR_SOFT_IN_ORF_PREFIX, NULL);\n\n  return bgp_clear_vty (vty, argv[0], AFI_IP, SAFI_UNICAST, clear_all,\n                        BGP_CLEAR_SOFT_IN_ORF_PREFIX, NULL);\n}\n\nDEFUN (clear_ip_bgp_all_vpnv4_soft_in,\n       clear_ip_bgp_all_vpnv4_soft_in_cmd,\n       \"clear ip bgp * vpnv4 unicast soft in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Address family\\n\"\n       \"Address Family Modifier\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MPLS_VPN, clear_all,\n\t\t\tBGP_CLEAR_SOFT_IN, NULL);\n}\n\nALIAS (clear_ip_bgp_all_vpnv4_soft_in,\n       clear_ip_bgp_all_vpnv4_in_cmd,\n       \"clear ip bgp * vpnv4 unicast in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Address family\\n\"\n       \"Address Family Modifier\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nDEFUN (clear_bgp_all_soft_in,\n       clear_bgp_all_soft_in_cmd,\n       \"clear bgp * soft in\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n{\n  if (argc == 1)\n    return bgp_clear_vty (vty, argv[0], AFI_IP6, SAFI_UNICAST, clear_all,\n                        BGP_CLEAR_SOFT_IN, NULL);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_all,\n\t\t\tBGP_CLEAR_SOFT_IN, NULL);\n}\n\nALIAS (clear_bgp_all_soft_in,\n       clear_bgp_instance_all_soft_in_cmd,\n       \"clear bgp view WORD * soft in\",\n       CLEAR_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"view name\\n\"\n       \"Clear all peers\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nALIAS (clear_bgp_all_soft_in,\n       clear_bgp_ipv6_all_soft_in_cmd,\n       \"clear bgp ipv6 * soft in\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear all peers\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nALIAS (clear_bgp_all_soft_in,\n       clear_bgp_all_in_cmd,\n       \"clear bgp * in\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nALIAS (clear_bgp_all_soft_in,\n       clear_bgp_ipv6_all_in_cmd,\n       \"clear bgp ipv6 * in\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear all peers\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nDEFUN (clear_bgp_all_in_prefix_filter,\n       clear_bgp_all_in_prefix_filter_cmd,\n       \"clear bgp * in prefix-filter\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Soft reconfig inbound update\\n\"\n       \"Push out prefix-list ORF and do inbound soft reconfig\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_all,\n\t\t\tBGP_CLEAR_SOFT_IN_ORF_PREFIX, NULL);\n}\n\nALIAS (clear_bgp_all_in_prefix_filter,\n       clear_bgp_ipv6_all_in_prefix_filter_cmd,\n       \"clear bgp ipv6 * in prefix-filter\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear all peers\\n\"\n       \"Soft reconfig inbound update\\n\"\n       \"Push out prefix-list ORF and do inbound soft reconfig\\n\")\n\nDEFUN (clear_ip_bgp_peer_soft_in,\n       clear_ip_bgp_peer_soft_in_cmd,\n       \"clear ip bgp A.B.C.D soft in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP neighbor address to clear\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_peer,\n\t\t\tBGP_CLEAR_SOFT_IN, argv[0]);\n}\n\nALIAS (clear_ip_bgp_peer_soft_in,\n       clear_ip_bgp_peer_in_cmd,\n       \"clear ip bgp A.B.C.D in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP neighbor address to clear\\n\"\n       \"Soft reconfig inbound update\\n\")\n       \nDEFUN (clear_ip_bgp_peer_in_prefix_filter,\n       clear_ip_bgp_peer_in_prefix_filter_cmd,\n       \"clear ip bgp A.B.C.D in prefix-filter\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP neighbor address to clear\\n\"\n       \"Soft reconfig inbound update\\n\"\n       \"Push out the existing ORF prefix-list\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_peer,\n\t\t\tBGP_CLEAR_SOFT_IN_ORF_PREFIX, argv[0]);\n}\n\nDEFUN (clear_ip_bgp_peer_ipv4_soft_in,\n       clear_ip_bgp_peer_ipv4_soft_in_cmd,\n       \"clear ip bgp A.B.C.D ipv4 (unicast|multicast) soft in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP neighbor address to clear\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n{\n  if (strncmp (argv[1], \"m\", 1) == 0)\n    return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MULTICAST, clear_peer,\n\t\t\t  BGP_CLEAR_SOFT_IN, argv[0]);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_peer,\n\t\t\tBGP_CLEAR_SOFT_IN, argv[0]);\n}\n\nALIAS (clear_ip_bgp_peer_ipv4_soft_in,\n       clear_ip_bgp_peer_ipv4_in_cmd,\n       \"clear ip bgp A.B.C.D ipv4 (unicast|multicast) in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP neighbor address to clear\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nDEFUN (clear_ip_bgp_peer_ipv4_in_prefix_filter,\n       clear_ip_bgp_peer_ipv4_in_prefix_filter_cmd,\n       \"clear ip bgp A.B.C.D ipv4 (unicast|multicast) in prefix-filter\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP neighbor address to clear\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig inbound update\\n\"\n       \"Push out the existing ORF prefix-list\\n\")\n{\n  if (strncmp (argv[1], \"m\", 1) == 0)\n    return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MULTICAST, clear_peer,\n\t\t\t  BGP_CLEAR_SOFT_IN_ORF_PREFIX, argv[0]);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_peer,\n\t\t\tBGP_CLEAR_SOFT_IN_ORF_PREFIX, argv[0]);\n}\n\nDEFUN (clear_ip_bgp_peer_vpnv4_soft_in,\n       clear_ip_bgp_peer_vpnv4_soft_in_cmd,\n       \"clear ip bgp A.B.C.D vpnv4 unicast soft in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP neighbor address to clear\\n\"\n       \"Address family\\n\"\n       \"Address Family Modifier\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MPLS_VPN, clear_peer,\n\t\t\tBGP_CLEAR_SOFT_IN, argv[0]);\n}\n\nALIAS (clear_ip_bgp_peer_vpnv4_soft_in,\n       clear_ip_bgp_peer_vpnv4_in_cmd,\n       \"clear ip bgp A.B.C.D vpnv4 unicast in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP neighbor address to clear\\n\"\n       \"Address family\\n\"\n       \"Address Family Modifier\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nDEFUN (clear_bgp_peer_soft_in,\n       clear_bgp_peer_soft_in_cmd,\n       \"clear bgp (A.B.C.D|X:X::X:X) soft in\",\n       CLEAR_STR\n       BGP_STR\n       \"BGP neighbor address to clear\\n\"\n       \"BGP IPv6 neighbor to clear\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_peer,\n\t\t\tBGP_CLEAR_SOFT_IN, argv[0]);\n}\n\nALIAS (clear_bgp_peer_soft_in,\n       clear_bgp_ipv6_peer_soft_in_cmd,\n       \"clear bgp ipv6 (A.B.C.D|X:X::X:X) soft in\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"BGP neighbor address to clear\\n\"\n       \"BGP IPv6 neighbor to clear\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nALIAS (clear_bgp_peer_soft_in,\n       clear_bgp_peer_in_cmd,\n       \"clear bgp (A.B.C.D|X:X::X:X) in\",\n       CLEAR_STR\n       BGP_STR\n       \"BGP neighbor address to clear\\n\"\n       \"BGP IPv6 neighbor to clear\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nALIAS (clear_bgp_peer_soft_in,\n       clear_bgp_ipv6_peer_in_cmd,\n       \"clear bgp ipv6 (A.B.C.D|X:X::X:X) in\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"BGP neighbor address to clear\\n\"\n       \"BGP IPv6 neighbor to clear\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nDEFUN (clear_bgp_peer_in_prefix_filter,\n       clear_bgp_peer_in_prefix_filter_cmd,\n       \"clear bgp (A.B.C.D|X:X::X:X) in prefix-filter\",\n       CLEAR_STR\n       BGP_STR\n       \"BGP neighbor address to clear\\n\"\n       \"BGP IPv6 neighbor to clear\\n\"\n       \"Soft reconfig inbound update\\n\"\n       \"Push out the existing ORF prefix-list\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_peer,\n\t\t\tBGP_CLEAR_SOFT_IN_ORF_PREFIX, argv[0]);\n}\n\nALIAS (clear_bgp_peer_in_prefix_filter,\n       clear_bgp_ipv6_peer_in_prefix_filter_cmd,\n       \"clear bgp ipv6 (A.B.C.D|X:X::X:X) in prefix-filter\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"BGP neighbor address to clear\\n\"\n       \"BGP IPv6 neighbor to clear\\n\"\n       \"Soft reconfig inbound update\\n\"\n       \"Push out the existing ORF prefix-list\\n\")\n\nDEFUN (clear_ip_bgp_peer_group_soft_in,\n       clear_ip_bgp_peer_group_soft_in_cmd,\n       \"clear ip bgp peer-group WORD soft in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_group,\n\t\t\tBGP_CLEAR_SOFT_IN, argv[0]);\n}\n\nALIAS (clear_ip_bgp_peer_group_soft_in,\n       clear_ip_bgp_peer_group_in_cmd,\n       \"clear ip bgp peer-group WORD in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nDEFUN (clear_ip_bgp_peer_group_in_prefix_filter,\n       clear_ip_bgp_peer_group_in_prefix_filter_cmd,\n       \"clear ip bgp peer-group WORD in prefix-filter\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\"\n       \"Soft reconfig inbound update\\n\"\n       \"Push out prefix-list ORF and do inbound soft reconfig\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_group,\n\t\t\tBGP_CLEAR_SOFT_IN_ORF_PREFIX, argv[0]);\n}\n\nDEFUN (clear_ip_bgp_peer_group_ipv4_soft_in,\n       clear_ip_bgp_peer_group_ipv4_soft_in_cmd,\n       \"clear ip bgp peer-group WORD ipv4 (unicast|multicast) soft in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n{\n  if (strncmp (argv[1], \"m\", 1) == 0)\n    return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MULTICAST, clear_group,\n\t\t\t  BGP_CLEAR_SOFT_IN, argv[0]);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_group,\n\t\t\tBGP_CLEAR_SOFT_IN, argv[0]);\n}\n\nALIAS (clear_ip_bgp_peer_group_ipv4_soft_in,\n       clear_ip_bgp_peer_group_ipv4_in_cmd,\n       \"clear ip bgp peer-group WORD ipv4 (unicast|multicast) in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nDEFUN (clear_ip_bgp_peer_group_ipv4_in_prefix_filter,\n       clear_ip_bgp_peer_group_ipv4_in_prefix_filter_cmd,\n       \"clear ip bgp peer-group WORD ipv4 (unicast|multicast) in prefix-filter\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig inbound update\\n\"\n       \"Push out prefix-list ORF and do inbound soft reconfig\\n\")\n{\n  if (strncmp (argv[1], \"m\", 1) == 0)\n    return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MULTICAST, clear_group,\n\t\t\t  BGP_CLEAR_SOFT_IN_ORF_PREFIX, argv[0]);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_group,\n\t\t\tBGP_CLEAR_SOFT_IN_ORF_PREFIX, argv[0]);\n}\n\nDEFUN (clear_bgp_peer_group_soft_in,\n       clear_bgp_peer_group_soft_in_cmd,\n       \"clear bgp peer-group WORD soft in\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_group,\n\t\t\tBGP_CLEAR_SOFT_IN, argv[0]);\n}\n\nALIAS (clear_bgp_peer_group_soft_in,\n       clear_bgp_ipv6_peer_group_soft_in_cmd,\n       \"clear bgp ipv6 peer-group WORD soft in\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nALIAS (clear_bgp_peer_group_soft_in,\n       clear_bgp_peer_group_in_cmd,\n       \"clear bgp peer-group WORD in\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nALIAS (clear_bgp_peer_group_soft_in,\n       clear_bgp_ipv6_peer_group_in_cmd,\n       \"clear bgp ipv6 peer-group WORD in\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nDEFUN (clear_bgp_peer_group_in_prefix_filter,\n       clear_bgp_peer_group_in_prefix_filter_cmd,\n       \"clear bgp peer-group WORD in prefix-filter\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\"\n       \"Soft reconfig inbound update\\n\"\n       \"Push out prefix-list ORF and do inbound soft reconfig\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_group,\n\t\t\tBGP_CLEAR_SOFT_IN_ORF_PREFIX, argv[0]);\n}\n\nALIAS (clear_bgp_peer_group_in_prefix_filter,\n       clear_bgp_ipv6_peer_group_in_prefix_filter_cmd,\n       \"clear bgp ipv6 peer-group WORD in prefix-filter\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\"\n       \"Soft reconfig inbound update\\n\"\n       \"Push out prefix-list ORF and do inbound soft reconfig\\n\")\n\nDEFUN (clear_ip_bgp_external_soft_in,\n       clear_ip_bgp_external_soft_in_cmd,\n       \"clear ip bgp external soft in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all external peers\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_external,\n\t\t\tBGP_CLEAR_SOFT_IN, NULL);\n}\n\nALIAS (clear_ip_bgp_external_soft_in,\n       clear_ip_bgp_external_in_cmd,\n       \"clear ip bgp external in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all external peers\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nDEFUN (clear_ip_bgp_external_in_prefix_filter,\n       clear_ip_bgp_external_in_prefix_filter_cmd,\n       \"clear ip bgp external in prefix-filter\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all external peers\\n\"\n       \"Soft reconfig inbound update\\n\"\n       \"Push out prefix-list ORF and do inbound soft reconfig\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_external,\n\t\t\tBGP_CLEAR_SOFT_IN_ORF_PREFIX, NULL);\n}\n\nDEFUN (clear_ip_bgp_external_ipv4_soft_in,\n       clear_ip_bgp_external_ipv4_soft_in_cmd,\n       \"clear ip bgp external ipv4 (unicast|multicast) soft in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all external peers\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n{\n  if (strncmp (argv[0], \"m\", 1) == 0)\n    return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MULTICAST, clear_external,\n\t\t\t  BGP_CLEAR_SOFT_IN, NULL);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_external,\n\t\t\tBGP_CLEAR_SOFT_IN, NULL);\n}\n\nALIAS (clear_ip_bgp_external_ipv4_soft_in,\n       clear_ip_bgp_external_ipv4_in_cmd,\n       \"clear ip bgp external ipv4 (unicast|multicast) in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all external peers\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nDEFUN (clear_ip_bgp_external_ipv4_in_prefix_filter,\n       clear_ip_bgp_external_ipv4_in_prefix_filter_cmd,\n       \"clear ip bgp external ipv4 (unicast|multicast) in prefix-filter\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all external peers\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig inbound update\\n\"\n       \"Push out prefix-list ORF and do inbound soft reconfig\\n\")\n{\n  if (strncmp (argv[0], \"m\", 1) == 0)\n    return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MULTICAST, clear_external,\n\t\t\t  BGP_CLEAR_SOFT_IN_ORF_PREFIX, NULL);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_external,\n\t\t\tBGP_CLEAR_SOFT_IN_ORF_PREFIX, NULL);\n}\n\nDEFUN (clear_bgp_external_soft_in,\n       clear_bgp_external_soft_in_cmd,\n       \"clear bgp external soft in\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear all external peers\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_external,\n\t\t\tBGP_CLEAR_SOFT_IN, NULL);\n}\n\nALIAS (clear_bgp_external_soft_in,\n       clear_bgp_ipv6_external_soft_in_cmd,\n       \"clear bgp ipv6 external soft in\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear all external peers\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nALIAS (clear_bgp_external_soft_in,\n       clear_bgp_external_in_cmd,\n       \"clear bgp external in\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear all external peers\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nALIAS (clear_bgp_external_soft_in,\n       clear_bgp_ipv6_external_in_cmd,\n       \"clear bgp ipv6 external WORD in\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear all external peers\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nDEFUN (clear_bgp_external_in_prefix_filter,\n       clear_bgp_external_in_prefix_filter_cmd,\n       \"clear bgp external in prefix-filter\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear all external peers\\n\"\n       \"Soft reconfig inbound update\\n\"\n       \"Push out prefix-list ORF and do inbound soft reconfig\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_external,\n\t\t\tBGP_CLEAR_SOFT_IN_ORF_PREFIX, NULL);\n}\n\nALIAS (clear_bgp_external_in_prefix_filter,\n       clear_bgp_ipv6_external_in_prefix_filter_cmd,\n       \"clear bgp ipv6 external in prefix-filter\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear all external peers\\n\"\n       \"Soft reconfig inbound update\\n\"\n       \"Push out prefix-list ORF and do inbound soft reconfig\\n\")\n\nDEFUN (clear_ip_bgp_as_soft_in,\n       clear_ip_bgp_as_soft_in_cmd,\n       \"clear ip bgp <1-65535> soft in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_as,\n\t\t\tBGP_CLEAR_SOFT_IN, argv[0]);\n}\n\nALIAS (clear_ip_bgp_as_soft_in,\n       clear_ip_bgp_as_in_cmd,\n       \"clear ip bgp <1-65535> in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nDEFUN (clear_ip_bgp_as_in_prefix_filter,\n       clear_ip_bgp_as_in_prefix_filter_cmd,\n       \"clear ip bgp <1-65535> in prefix-filter\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\"\n       \"Soft reconfig inbound update\\n\"\n       \"Push out prefix-list ORF and do inbound soft reconfig\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_as,\n\t\t\tBGP_CLEAR_SOFT_IN_ORF_PREFIX, argv[0]);\n}\n\nDEFUN (clear_ip_bgp_as_ipv4_soft_in,\n       clear_ip_bgp_as_ipv4_soft_in_cmd,\n       \"clear ip bgp <1-65535> ipv4 (unicast|multicast) soft in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n{\n  if (strncmp (argv[1], \"m\", 1) == 0)\n    return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MULTICAST, clear_as,\n\t\t\t  BGP_CLEAR_SOFT_IN, argv[0]);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_as,\n\t\t\tBGP_CLEAR_SOFT_IN, argv[0]);\n}\n\nALIAS (clear_ip_bgp_as_ipv4_soft_in,\n       clear_ip_bgp_as_ipv4_in_cmd,\n       \"clear ip bgp <1-65535> ipv4 (unicast|multicast) in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nDEFUN (clear_ip_bgp_as_ipv4_in_prefix_filter,\n       clear_ip_bgp_as_ipv4_in_prefix_filter_cmd,\n       \"clear ip bgp <1-65535> ipv4 (unicast|multicast) in prefix-filter\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig inbound update\\n\"\n       \"Push out prefix-list ORF and do inbound soft reconfig\\n\")\n{\n  if (strncmp (argv[1], \"m\", 1) == 0)\n    return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MULTICAST, clear_as,\n\t\t\t  BGP_CLEAR_SOFT_IN_ORF_PREFIX, argv[0]);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_as,\n\t\t\tBGP_CLEAR_SOFT_IN_ORF_PREFIX, argv[0]);\n}\n\nDEFUN (clear_ip_bgp_as_vpnv4_soft_in,\n       clear_ip_bgp_as_vpnv4_soft_in_cmd,\n       \"clear ip bgp <1-65535> vpnv4 unicast soft in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MPLS_VPN, clear_as,\n\t\t\tBGP_CLEAR_SOFT_IN, argv[0]);\n}\n\nALIAS (clear_ip_bgp_as_vpnv4_soft_in,\n       clear_ip_bgp_as_vpnv4_in_cmd,\n       \"clear ip bgp <1-65535> vpnv4 unicast in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nDEFUN (clear_bgp_as_soft_in,\n       clear_bgp_as_soft_in_cmd,\n       \"clear bgp <1-65535> soft in\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_as,\n\t\t\tBGP_CLEAR_SOFT_IN, argv[0]);\n}\n\nALIAS (clear_bgp_as_soft_in,\n       clear_bgp_ipv6_as_soft_in_cmd,\n       \"clear bgp ipv6 <1-65535> soft in\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear peers with the AS number\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nALIAS (clear_bgp_as_soft_in,\n       clear_bgp_as_in_cmd,\n       \"clear bgp <1-65535> in\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nALIAS (clear_bgp_as_soft_in,\n       clear_bgp_ipv6_as_in_cmd,\n       \"clear bgp ipv6 <1-65535> in\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear peers with the AS number\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nDEFUN (clear_bgp_as_in_prefix_filter,\n       clear_bgp_as_in_prefix_filter_cmd,\n       \"clear bgp <1-65535> in prefix-filter\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\"\n       \"Soft reconfig inbound update\\n\"\n       \"Push out prefix-list ORF and do inbound soft reconfig\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_as,\n\t\t\tBGP_CLEAR_SOFT_IN_ORF_PREFIX, argv[0]);\n}\n\nALIAS (clear_bgp_as_in_prefix_filter,\n       clear_bgp_ipv6_as_in_prefix_filter_cmd,\n       \"clear bgp ipv6 <1-65535> in prefix-filter\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear peers with the AS number\\n\"\n       \"Soft reconfig inbound update\\n\"\n       \"Push out prefix-list ORF and do inbound soft reconfig\\n\")\n\f\n/* Both soft-reconfiguration */\nDEFUN (clear_ip_bgp_all_soft,\n       clear_ip_bgp_all_soft_cmd,\n       \"clear ip bgp * soft\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Soft reconfig\\n\")\n{\n  if (argc == 1)\n    return bgp_clear_vty (vty, argv[0], AFI_IP, SAFI_UNICAST, clear_all,\n                        BGP_CLEAR_SOFT_BOTH, NULL);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_all,\n\t\t\tBGP_CLEAR_SOFT_BOTH, NULL);\n}\n\nALIAS (clear_ip_bgp_all_soft,\n       clear_ip_bgp_instance_all_soft_cmd,\n       \"clear ip bgp view WORD * soft\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"view name\\n\"\n       \"Clear all peers\\n\"\n       \"Soft reconfig\\n\")\n\n\nDEFUN (clear_ip_bgp_all_ipv4_soft,\n       clear_ip_bgp_all_ipv4_soft_cmd,\n       \"clear ip bgp * ipv4 (unicast|multicast) soft\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Address family\\n\"\n       \"Address Family Modifier\\n\"\n       \"Address Family Modifier\\n\"\n       \"Soft reconfig\\n\")\n{\n  if (strncmp (argv[0], \"m\", 1) == 0)\n    return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MULTICAST, clear_all,\n\t\t\t  BGP_CLEAR_SOFT_BOTH, NULL);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_all,\n\t\t\tBGP_CLEAR_SOFT_BOTH, NULL);\n}\n\nDEFUN (clear_ip_bgp_instance_all_ipv4_soft,\n       clear_ip_bgp_instance_all_ipv4_soft_cmd,\n       \"clear ip bgp view WORD * ipv4 (unicast|multicast) soft\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"view name\\n\"\n       \"Clear all peers\\n\"\n       \"Address family\\n\"\n       \"Address Family Modifier\\n\"\n       \"Address Family Modifier\\n\"\n       \"Soft reconfig\\n\")\n{\n  if (strncmp (argv[1], \"m\", 1) == 0)\n    return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MULTICAST, clear_all,\n                          BGP_CLEAR_SOFT_BOTH, NULL);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_all,\n                        BGP_CLEAR_SOFT_BOTH, NULL);\n}\n\nDEFUN (clear_ip_bgp_all_vpnv4_soft,\n       clear_ip_bgp_all_vpnv4_soft_cmd,\n       \"clear ip bgp * vpnv4 unicast soft\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Address family\\n\"\n       \"Address Family Modifier\\n\"\n       \"Soft reconfig\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MPLS_VPN, clear_all,\n\t\t\tBGP_CLEAR_SOFT_BOTH, argv[0]);\n}\n\nDEFUN (clear_bgp_all_soft,\n       clear_bgp_all_soft_cmd,\n       \"clear bgp * soft\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Soft reconfig\\n\")\n{\n  if (argc == 1)\n    return bgp_clear_vty (vty, argv[0], AFI_IP6, SAFI_UNICAST, clear_all,\n                        BGP_CLEAR_SOFT_BOTH, argv[0]);\n \n  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_all,\n\t\t\tBGP_CLEAR_SOFT_BOTH, argv[0]);\n}\n\nALIAS (clear_bgp_all_soft,\n       clear_bgp_instance_all_soft_cmd,\n       \"clear bgp view WORD * soft\",\n       CLEAR_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"view name\\n\"\n       \"Clear all peers\\n\"\n       \"Soft reconfig\\n\")\n\nALIAS (clear_bgp_all_soft,\n       clear_bgp_ipv6_all_soft_cmd,\n       \"clear bgp ipv6 * soft\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear all peers\\n\"\n       \"Soft reconfig\\n\")\n\nDEFUN (clear_ip_bgp_peer_soft,\n       clear_ip_bgp_peer_soft_cmd,\n       \"clear ip bgp A.B.C.D soft\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP neighbor address to clear\\n\"\n       \"Soft reconfig\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_peer,\n\t\t\tBGP_CLEAR_SOFT_BOTH, argv[0]);\n}\n\nDEFUN (clear_ip_bgp_peer_ipv4_soft,\n       clear_ip_bgp_peer_ipv4_soft_cmd,\n       \"clear ip bgp A.B.C.D ipv4 (unicast|multicast) soft\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP neighbor address to clear\\n\"\n       \"Address family\\n\"\n       \"Address Family Modifier\\n\"\n       \"Address Family Modifier\\n\"\n       \"Soft reconfig\\n\")\n{\n  if (strncmp (argv[1], \"m\", 1) == 0)\n    return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MULTICAST, clear_peer,\n\t\t\t  BGP_CLEAR_SOFT_BOTH, argv[0]);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_peer,\n\t\t\tBGP_CLEAR_SOFT_BOTH, argv[0]);\n}\n\nDEFUN (clear_ip_bgp_peer_vpnv4_soft,\n       clear_ip_bgp_peer_vpnv4_soft_cmd,\n       \"clear ip bgp A.B.C.D vpnv4 unicast soft\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP neighbor address to clear\\n\"\n       \"Address family\\n\"\n       \"Address Family Modifier\\n\"\n       \"Soft reconfig\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MPLS_VPN, clear_peer,\n\t\t\tBGP_CLEAR_SOFT_BOTH, argv[0]);\n}\n\nDEFUN (clear_bgp_peer_soft,\n       clear_bgp_peer_soft_cmd,\n       \"clear bgp (A.B.C.D|X:X::X:X) soft\",\n       CLEAR_STR\n       BGP_STR\n       \"BGP neighbor address to clear\\n\"\n       \"BGP IPv6 neighbor to clear\\n\"\n       \"Soft reconfig\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_peer,\n\t\t\tBGP_CLEAR_SOFT_BOTH, argv[0]);\n}\n\nALIAS (clear_bgp_peer_soft,\n       clear_bgp_ipv6_peer_soft_cmd,\n       \"clear bgp ipv6 (A.B.C.D|X:X::X:X) soft\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"BGP neighbor address to clear\\n\"\n       \"BGP IPv6 neighbor to clear\\n\"\n       \"Soft reconfig\\n\")\n\nDEFUN (clear_ip_bgp_peer_group_soft,\n       clear_ip_bgp_peer_group_soft_cmd,\n       \"clear ip bgp peer-group WORD soft\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\"\n       \"Soft reconfig\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_group,\n\t\t\tBGP_CLEAR_SOFT_BOTH, argv[0]);\n}\n\nDEFUN (clear_ip_bgp_peer_group_ipv4_soft,\n       clear_ip_bgp_peer_group_ipv4_soft_cmd,\n       \"clear ip bgp peer-group WORD ipv4 (unicast|multicast) soft\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig\\n\")\n{\n  if (strncmp (argv[1], \"m\", 1) == 0)\n    return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MULTICAST, clear_group,\n\t\t\t  BGP_CLEAR_SOFT_BOTH, argv[0]);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_group,\n\t\t\tBGP_CLEAR_SOFT_BOTH, argv[0]);\n}\n\nDEFUN (clear_bgp_peer_group_soft,\n       clear_bgp_peer_group_soft_cmd,\n       \"clear bgp peer-group WORD soft\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\"\n       \"Soft reconfig\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_group,\n\t\t\tBGP_CLEAR_SOFT_BOTH, argv[0]);\n}\n\nALIAS (clear_bgp_peer_group_soft,\n       clear_bgp_ipv6_peer_group_soft_cmd,\n       \"clear bgp ipv6 peer-group WORD soft\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\"\n       \"Soft reconfig\\n\")\n\nDEFUN (clear_ip_bgp_external_soft,\n       clear_ip_bgp_external_soft_cmd,\n       \"clear ip bgp external soft\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all external peers\\n\"\n       \"Soft reconfig\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_external,\n\t\t\tBGP_CLEAR_SOFT_BOTH, NULL);\n}\n\nDEFUN (clear_ip_bgp_external_ipv4_soft,\n       clear_ip_bgp_external_ipv4_soft_cmd,\n       \"clear ip bgp external ipv4 (unicast|multicast) soft\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all external peers\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig\\n\")\n{\n  if (strncmp (argv[0], \"m\", 1) == 0)\n    return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MULTICAST, clear_external,\n\t\t\t  BGP_CLEAR_SOFT_BOTH, NULL);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_external,\n\t\t\tBGP_CLEAR_SOFT_BOTH, NULL);\n}\n\nDEFUN (clear_bgp_external_soft,\n       clear_bgp_external_soft_cmd,\n       \"clear bgp external soft\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear all external peers\\n\"\n       \"Soft reconfig\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_external,\n\t\t\tBGP_CLEAR_SOFT_BOTH, NULL);\n}\n\nALIAS (clear_bgp_external_soft,\n       clear_bgp_ipv6_external_soft_cmd,\n       \"clear bgp ipv6 external soft\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear all external peers\\n\"\n       \"Soft reconfig\\n\")\n\nDEFUN (clear_ip_bgp_as_soft,\n       clear_ip_bgp_as_soft_cmd,\n       \"clear ip bgp <1-65535> soft\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\"\n       \"Soft reconfig\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_as,\n\t\t\tBGP_CLEAR_SOFT_BOTH, argv[0]);\n}\n\nDEFUN (clear_ip_bgp_as_ipv4_soft,\n       clear_ip_bgp_as_ipv4_soft_cmd,\n       \"clear ip bgp <1-65535> ipv4 (unicast|multicast) soft\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\"\n       \"Address family\\n\"\n       \"Address Family Modifier\\n\"\n       \"Address Family Modifier\\n\"\n       \"Soft reconfig\\n\")\n{\n  if (strncmp (argv[1], \"m\", 1) == 0)\n    return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MULTICAST, clear_as,\n\t\t\t  BGP_CLEAR_SOFT_BOTH, argv[0]);\n\n  return bgp_clear_vty (vty, NULL,AFI_IP, SAFI_UNICAST, clear_as,\n\t\t\tBGP_CLEAR_SOFT_BOTH, argv[0]);\n}\n\nDEFUN (clear_ip_bgp_as_vpnv4_soft,\n       clear_ip_bgp_as_vpnv4_soft_cmd,\n       \"clear ip bgp <1-65535> vpnv4 unicast soft\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\"\n       \"Address family\\n\"\n       \"Address Family Modifier\\n\"\n       \"Soft reconfig\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MPLS_VPN, clear_as,\n\t\t\tBGP_CLEAR_SOFT_BOTH, argv[0]);\n}\n\nDEFUN (clear_bgp_as_soft,\n       clear_bgp_as_soft_cmd,\n       \"clear bgp <1-65535> soft\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\"\n       \"Soft reconfig\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_as,\n\t\t\tBGP_CLEAR_SOFT_BOTH, argv[0]);\n}\n\nALIAS (clear_bgp_as_soft,\n       clear_bgp_ipv6_as_soft_cmd,\n       \"clear bgp ipv6 <1-65535> soft\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear peers with the AS number\\n\"\n       \"Soft reconfig\\n\")\n\f\n/* RS-client soft reconfiguration. */\n#ifdef HAVE_IPV6\nDEFUN (clear_bgp_all_rsclient,\n       clear_bgp_all_rsclient_cmd,\n       \"clear bgp * rsclient\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Soft reconfig for rsclient RIB\\n\")\n{\n  if (argc == 1)\n    return bgp_clear_vty (vty, argv[0], AFI_IP6, SAFI_UNICAST, clear_all,\n                          BGP_CLEAR_SOFT_RSCLIENT, NULL);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_all,\n                        BGP_CLEAR_SOFT_RSCLIENT, NULL);\n}\n\nALIAS (clear_bgp_all_rsclient,\n       clear_bgp_ipv6_all_rsclient_cmd,\n       \"clear bgp ipv6 * rsclient\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear all peers\\n\"\n       \"Soft reconfig for rsclient RIB\\n\")\n\nALIAS (clear_bgp_all_rsclient,\n       clear_bgp_instance_all_rsclient_cmd,\n       \"clear bgp view WORD * rsclient\",\n       CLEAR_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"view name\\n\"\n       \"Clear all peers\\n\"\n       \"Soft reconfig for rsclient RIB\\n\")\n\nALIAS (clear_bgp_all_rsclient,\n       clear_bgp_ipv6_instance_all_rsclient_cmd,\n       \"clear bgp ipv6 view WORD * rsclient\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"BGP view\\n\"\n       \"view name\\n\"\n       \"Clear all peers\\n\"\n       \"Soft reconfig for rsclient RIB\\n\")\n#endif /* HAVE_IPV6 */\n\nDEFUN (clear_ip_bgp_all_rsclient,\n       clear_ip_bgp_all_rsclient_cmd,\n       \"clear ip bgp * rsclient\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Soft reconfig for rsclient RIB\\n\")\n{\n  if (argc == 1)\n    return bgp_clear_vty (vty, argv[0], AFI_IP, SAFI_UNICAST, clear_all,\n                          BGP_CLEAR_SOFT_RSCLIENT, NULL);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_all,\n                        BGP_CLEAR_SOFT_RSCLIENT, NULL);\n}\n\nALIAS (clear_ip_bgp_all_rsclient,\n       clear_ip_bgp_instance_all_rsclient_cmd,\n       \"clear ip bgp view WORD * rsclient\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"view name\\n\"\n       \"Clear all peers\\n\"\n       \"Soft reconfig for rsclient RIB\\n\")\n\n#ifdef HAVE_IPV6\nDEFUN (clear_bgp_peer_rsclient,\n       clear_bgp_peer_rsclient_cmd,\n       \"clear bgp (A.B.C.D|X:X::X:X) rsclient\",\n       CLEAR_STR\n       BGP_STR\n       \"BGP neighbor IP address to clear\\n\"\n       \"BGP IPv6 neighbor to clear\\n\"\n       \"Soft reconfig for rsclient RIB\\n\")\n{\n  if (argc == 2)\n    return bgp_clear_vty (vty, argv[0], AFI_IP6, SAFI_UNICAST, clear_peer,\n                          BGP_CLEAR_SOFT_RSCLIENT, argv[1]);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_peer,\n                        BGP_CLEAR_SOFT_RSCLIENT, argv[0]);\n}\n\nALIAS (clear_bgp_peer_rsclient,\n       clear_bgp_ipv6_peer_rsclient_cmd,\n       \"clear bgp ipv6 (A.B.C.D|X:X::X:X) rsclient\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"BGP neighbor IP address to clear\\n\"\n       \"BGP IPv6 neighbor to clear\\n\"\n       \"Soft reconfig for rsclient RIB\\n\")\n\nALIAS (clear_bgp_peer_rsclient,\n       clear_bgp_instance_peer_rsclient_cmd,\n       \"clear bgp view WORD (A.B.C.D|X:X::X:X) rsclient\",\n       CLEAR_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"view name\\n\"\n       \"BGP neighbor IP address to clear\\n\"\n       \"BGP IPv6 neighbor to clear\\n\"\n       \"Soft reconfig for rsclient RIB\\n\")\n\nALIAS (clear_bgp_peer_rsclient,\n       clear_bgp_ipv6_instance_peer_rsclient_cmd,\n       \"clear bgp ipv6 view WORD (A.B.C.D|X:X::X:X) rsclient\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"BGP view\\n\"\n       \"view name\\n\"\n       \"BGP neighbor IP address to clear\\n\"\n       \"BGP IPv6 neighbor to clear\\n\"\n       \"Soft reconfig for rsclient RIB\\n\")\n#endif /* HAVE_IPV6 */\n\nDEFUN (clear_ip_bgp_peer_rsclient,\n       clear_ip_bgp_peer_rsclient_cmd,\n       \"clear ip bgp (A.B.C.D|X:X::X:X) rsclient\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP neighbor IP address to clear\\n\"\n       \"BGP IPv6 neighbor to clear\\n\"\n       \"Soft reconfig for rsclient RIB\\n\")\n{\n  if (argc == 2)\n    return bgp_clear_vty (vty, argv[0], AFI_IP, SAFI_UNICAST, clear_peer,\n                          BGP_CLEAR_SOFT_RSCLIENT, argv[1]);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_peer,\n                        BGP_CLEAR_SOFT_RSCLIENT, argv[0]);\n}\n\nALIAS (clear_ip_bgp_peer_rsclient,\n       clear_ip_bgp_instance_peer_rsclient_cmd,\n       \"clear ip bgp view WORD (A.B.C.D|X:X::X:X) rsclient\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"view name\\n\"\n       \"BGP neighbor IP address to clear\\n\"\n       \"BGP IPv6 neighbor to clear\\n\"\n       \"Soft reconfig for rsclient RIB\\n\")\n\nDEFUN (show_bgp_memory, \n       show_bgp_memory_cmd,\n       \"show bgp memory\",\n       SHOW_STR\n       BGP_STR\n       \"Global BGP memory statistics\\n\")\n{\n  char memstrbuf[MTYPE_MEMSTR_LEN];\n  unsigned long count;\n  \n  /* RIB related usage stats */\n  count = mtype_stats_alloc (MTYPE_BGP_NODE);\n  vty_out (vty, \"%ld RIB nodes, using %s of memory%s\", count,\n           mtype_memstr (memstrbuf, sizeof (memstrbuf),\n                         count * sizeof (struct bgp_node)),\n           VTY_NEWLINE);\n  \n  count = mtype_stats_alloc (MTYPE_BGP_ROUTE);\n  vty_out (vty, \"%ld BGP routes, using %s of memory%s\", count,\n           mtype_memstr (memstrbuf, sizeof (memstrbuf),\n                         count * sizeof (struct bgp_info)),\n           VTY_NEWLINE);\n  if ((count = mtype_stats_alloc (MTYPE_BGP_ROUTE_EXTRA)))\n    vty_out (vty, \"%ld BGP route ancillaries, using %s of memory%s\", count,\n             mtype_memstr (memstrbuf, sizeof (memstrbuf),\n                           count * sizeof (struct bgp_info_extra)),\n             VTY_NEWLINE);\n  \n  if ((count = mtype_stats_alloc (MTYPE_BGP_STATIC)))\n    vty_out (vty, \"%ld Static routes, using %s of memory%s\", count,\n             mtype_memstr (memstrbuf, sizeof (memstrbuf),\n                         count * sizeof (struct bgp_static)),\n             VTY_NEWLINE);\n  \n  /* Adj-In/Out */\n  if ((count = mtype_stats_alloc (MTYPE_BGP_ADJ_IN)))\n    vty_out (vty, \"%ld Adj-In entries, using %s of memory%s\", count,\n             mtype_memstr (memstrbuf, sizeof (memstrbuf),\n                           count * sizeof (struct bgp_adj_in)),\n             VTY_NEWLINE);\n  if ((count = mtype_stats_alloc (MTYPE_BGP_ADJ_OUT)))\n    vty_out (vty, \"%ld Adj-Out entries, using %s of memory%s\", count,\n             mtype_memstr (memstrbuf, sizeof (memstrbuf),\n                           count * sizeof (struct bgp_adj_out)),\n             VTY_NEWLINE);\n  \n  if ((count = mtype_stats_alloc (MTYPE_BGP_NEXTHOP_CACHE)))\n    vty_out (vty, \"%ld Nexthop cache entries, using %s of memory%s\", count,\n             mtype_memstr (memstrbuf, sizeof (memstrbuf),\n                         count * sizeof (struct bgp_nexthop_cache)),\n             VTY_NEWLINE);\n\n  if ((count = mtype_stats_alloc (MTYPE_BGP_DAMP_INFO)))\n    vty_out (vty, \"%ld Dampening entries, using %s of memory%s\", count,\n             mtype_memstr (memstrbuf, sizeof (memstrbuf),\n                         count * sizeof (struct bgp_damp_info)),\n             VTY_NEWLINE);\n\n  /* Attributes */\n  count = attr_count();\n  vty_out (vty, \"%ld BGP attributes, using %s of memory%s\", count, \n           mtype_memstr (memstrbuf, sizeof (memstrbuf), \n                         count * sizeof(struct attr)), \n           VTY_NEWLINE);\n  if ((count = mtype_stats_alloc (MTYPE_ATTR_EXTRA)))\n    vty_out (vty, \"%ld BGP extra attributes, using %s of memory%s\", count, \n             mtype_memstr (memstrbuf, sizeof (memstrbuf), \n                           count * sizeof(struct attr_extra)), \n             VTY_NEWLINE);\n  \n  if ((count = attr_unknown_count()))\n    vty_out (vty, \"%ld unknown attributes%s\", count, VTY_NEWLINE);\n  \n  /* AS_PATH attributes */\n  count = aspath_count ();\n  vty_out (vty, \"%ld BGP AS-PATH entries, using %s of memory%s\", count,\n           mtype_memstr (memstrbuf, sizeof (memstrbuf),\n                         count * sizeof (struct aspath)),\n           VTY_NEWLINE);\n  \n  count = mtype_stats_alloc (MTYPE_AS_SEG);\n  vty_out (vty, \"%ld BGP AS-PATH segments, using %s of memory%s\", count,\n           mtype_memstr (memstrbuf, sizeof (memstrbuf),\n                         count * sizeof (struct assegment)),\n           VTY_NEWLINE);\n  \n  /* Other attributes */\n  if ((count = community_count ()))\n    vty_out (vty, \"%ld BGP community entries, using %s of memory%s\", count,\n             mtype_memstr (memstrbuf, sizeof (memstrbuf),\n                         count * sizeof (struct community)),\n             VTY_NEWLINE);\n  if ((count = mtype_stats_alloc (MTYPE_ECOMMUNITY)))\n    vty_out (vty, \"%ld BGP community entries, using %s of memory%s\", count,\n             mtype_memstr (memstrbuf, sizeof (memstrbuf),\n                         count * sizeof (struct ecommunity)),\n             VTY_NEWLINE);\n  \n  if ((count = mtype_stats_alloc (MTYPE_CLUSTER)))\n    vty_out (vty, \"%ld Cluster lists, using %s of memory%s\", count,\n             mtype_memstr (memstrbuf, sizeof (memstrbuf),\n                         count * sizeof (struct cluster_list)),\n             VTY_NEWLINE);\n  \n  /* Peer related usage */\n  count = mtype_stats_alloc (MTYPE_BGP_PEER);\n  vty_out (vty, \"%ld peers, using %s of memory%s\", count,\n           mtype_memstr (memstrbuf, sizeof (memstrbuf),\n                         count * sizeof (struct peer)),\n           VTY_NEWLINE);\n  \n  if ((count = mtype_stats_alloc (MTYPE_PEER_GROUP)))\n    vty_out (vty, \"%ld peer groups, using %s of memory%s\", count,\n             mtype_memstr (memstrbuf, sizeof (memstrbuf),\n                           count * sizeof (struct peer_group)),\n             VTY_NEWLINE);\n  \n  /* Other */\n  if ((count = mtype_stats_alloc (MTYPE_HASH)))\n    vty_out (vty, \"%ld hash tables, using %s of memory%s\", count,\n             mtype_memstr (memstrbuf, sizeof (memstrbuf),\n                           count * sizeof (struct hash)),\n             VTY_NEWLINE);\n  if ((count = mtype_stats_alloc (MTYPE_HASH_BACKET)))\n    vty_out (vty, \"%ld hash buckets, using %s of memory%s\", count,\n             mtype_memstr (memstrbuf, sizeof (memstrbuf),\n                           count * sizeof (struct hash_backet)),\n             VTY_NEWLINE);\n  if ((count = mtype_stats_alloc (MTYPE_BGP_REGEXP)))\n    vty_out (vty, \"%ld compiled regexes, using %s of memory%s\", count,\n             mtype_memstr (memstrbuf, sizeof (memstrbuf),\n                           count * sizeof (regex_t)),\n             VTY_NEWLINE);\n  return CMD_SUCCESS;\n}\n\n/* Show BGP peer's summary information. */\nstatic int\nbgp_show_summary (struct vty *vty, struct bgp *bgp, int afi, int safi)\n{\n  struct peer *peer;\n  struct listnode *node, *nnode;\n  unsigned int count = 0;\n  char timebuf[BGP_UPTIME_LEN];\n  int len;\n\n  /* Header string for each address family. */\n  static char header[] = \"Neighbor        V    AS MsgRcvd MsgSent   TblVer  InQ OutQ Up/Down  State/PfxRcd\";\n  \n  for (ALL_LIST_ELEMENTS (bgp->peer, node, nnode, peer))\n    {\n      if (peer->afc[afi][safi])\n\t{\n          if (!count)\n            {\n              unsigned long ents;\n              char memstrbuf[MTYPE_MEMSTR_LEN];\n              \n              /* Usage summary and header */\n              vty_out (vty,\n                       \"BGP router identifier %s, local AS number %d%s\",\n                       inet_ntoa (bgp->router_id), bgp->as, VTY_NEWLINE);\n\n              ents = bgp_table_count (bgp->rib[afi][safi]);\n              vty_out (vty, \"RIB entries %ld, using %s of memory%s\", ents,\n                       mtype_memstr (memstrbuf, sizeof (memstrbuf),\n                                     ents * sizeof (struct bgp_node)),\n                       VTY_NEWLINE);\n              \n              /* Peer related usage */\n              ents = listcount (bgp->peer);\n              vty_out (vty, \"Peers %ld, using %s of memory%s\",\n                       ents,\n                       mtype_memstr (memstrbuf, sizeof (memstrbuf),\n                                     ents * sizeof (struct peer)),\n                       VTY_NEWLINE);\n              \n              if ((ents = listcount (bgp->rsclient)))\n                vty_out (vty, \"RS-Client peers %ld, using %s of memory%s\",\n                         ents,\n                         mtype_memstr (memstrbuf, sizeof (memstrbuf),\n                                       ents * sizeof (struct peer)),\n                         VTY_NEWLINE);\n              \n              if ((ents = listcount (bgp->group)))\n                vty_out (vty, \"Peer groups %ld, using %s of memory%s\", ents,\n                         mtype_memstr (memstrbuf, sizeof (memstrbuf),\n                                       ents * sizeof (struct peer_group)),\n                         VTY_NEWLINE);\n\n              if (CHECK_FLAG (bgp->af_flags[afi][safi], BGP_CONFIG_DAMPENING))\n                vty_out (vty, \"Dampening enabled.%s\", VTY_NEWLINE);\n              vty_out (vty, \"%s\", VTY_NEWLINE);\n              vty_out (vty, \"%s%s\", header, VTY_NEWLINE);\n            }\n          \n\t  count++;\n\n\t  len = vty_out (vty, \"%s\", peer->host);\n\t  len = 16 - len;\n\t  if (len < 1)\n\t    vty_out (vty, \"%s%*s\", VTY_NEWLINE, 16, \" \");\n\t  else\n\t    vty_out (vty, \"%*s\", len, \" \");\n\n\t  vty_out (vty, \"4 \");\n\n\t  vty_out (vty, \"%5d %7d %7d %8d %4d %4ld \",\n\t\t   peer->as,\n\t\t   peer->open_in + peer->update_in + peer->keepalive_in\n\t\t   + peer->notify_in + peer->refresh_in + peer->dynamic_cap_in,\n\t\t   peer->open_out + peer->update_out + peer->keepalive_out\n\t\t   + peer->notify_out + peer->refresh_out\n\t\t   + peer->dynamic_cap_out,\n\t\t   0, 0, peer->obuf->count);\n\n\t  vty_out (vty, \"%8s\", \n\t\t   peer_uptime (peer->uptime, timebuf, BGP_UPTIME_LEN));\n\n\t  if (peer->status == Established)\n\t    {\n\t      vty_out (vty, \" %8ld\", peer->pcount[afi][safi]);\n\t    }\n\t  else\n\t    {\n\t      if (CHECK_FLAG (peer->flags, PEER_FLAG_SHUTDOWN))\n\t\tvty_out (vty, \" Idle (Admin)\");\n\t      else if (CHECK_FLAG (peer->sflags, PEER_STATUS_PREFIX_OVERFLOW))\n\t\tvty_out (vty, \" Idle (PfxCt)\");\n\t      else\n\t\tvty_out (vty, \" %-11s\", LOOKUP(bgp_status_msg, peer->status));\n\t    }\n\n\t  vty_out (vty, \"%s\", VTY_NEWLINE);\n\t}\n    }\n\n  if (count)\n    vty_out (vty, \"%sTotal number of neighbors %d%s\", VTY_NEWLINE,\n\t     count, VTY_NEWLINE);\n  else\n    vty_out (vty, \"No %s neighbor is configured%s\",\n\t     afi == AFI_IP ? \"IPv4\" : \"IPv6\", VTY_NEWLINE);\n  return CMD_SUCCESS;\n}\n\nstatic int \nbgp_show_summary_vty (struct vty *vty, const char *name, \n                      afi_t afi, safi_t safi)\n{\n  struct bgp *bgp;\n\n  if (name)\n    {\n      bgp = bgp_lookup_by_name (name);\n      \n      if (! bgp)\n\t{\n\t  vty_out (vty, \"%% No such BGP instance exist%s\", VTY_NEWLINE); \n\t  return CMD_WARNING;\n\t}\n\n      bgp_show_summary (vty, bgp, afi, safi);\n      return CMD_SUCCESS;\n    }\n  \n  bgp = bgp_get_default ();\n\n  if (bgp)\n    bgp_show_summary (vty, bgp, afi, safi);    \n \n  return CMD_SUCCESS;\n}\n\n/* `show ip bgp summary' commands. */\nDEFUN (show_ip_bgp_summary, \n       show_ip_bgp_summary_cmd,\n       \"show ip bgp summary\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"Summary of BGP neighbor status\\n\")\n{\n  return bgp_show_summary_vty (vty, NULL, AFI_IP, SAFI_UNICAST);\n}\n\nDEFUN (show_ip_bgp_instance_summary,\n       show_ip_bgp_instance_summary_cmd,\n       \"show ip bgp view WORD summary\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"View name\\n\"\n       \"Summary of BGP neighbor status\\n\")\n{\n  return bgp_show_summary_vty (vty, argv[0], AFI_IP, SAFI_UNICAST);  \n}\n\nDEFUN (show_ip_bgp_ipv4_summary, \n       show_ip_bgp_ipv4_summary_cmd,\n       \"show ip bgp ipv4 (unicast|multicast) summary\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Summary of BGP neighbor status\\n\")\n{\n  if (strncmp (argv[0], \"m\", 1) == 0)\n    return bgp_show_summary_vty (vty, NULL, AFI_IP, SAFI_MULTICAST);\n\n  return bgp_show_summary_vty (vty, NULL, AFI_IP, SAFI_UNICAST);\n}\n\nDEFUN (show_ip_bgp_instance_ipv4_summary,\n       show_ip_bgp_instance_ipv4_summary_cmd,\n       \"show ip bgp view WORD ipv4 (unicast|multicast) summary\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"View name\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Summary of BGP neighbor status\\n\")\n{\n  if (strncmp (argv[1], \"m\", 1) == 0)\n    return bgp_show_summary_vty (vty, argv[0], AFI_IP, SAFI_MULTICAST);\n  else\n    return bgp_show_summary_vty (vty, argv[0], AFI_IP, SAFI_UNICAST);\n}\n\nDEFUN (show_ip_bgp_vpnv4_all_summary,\n       show_ip_bgp_vpnv4_all_summary_cmd,\n       \"show ip bgp vpnv4 all summary\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"Display VPNv4 NLRI specific information\\n\"\n       \"Display information about all VPNv4 NLRIs\\n\"\n       \"Summary of BGP neighbor status\\n\")\n{\n  return bgp_show_summary_vty (vty, NULL, AFI_IP, SAFI_MPLS_VPN);\n}\n\nDEFUN (show_ip_bgp_vpnv4_rd_summary,\n       show_ip_bgp_vpnv4_rd_summary_cmd,\n       \"show ip bgp vpnv4 rd ASN:nn_or_IP-address:nn summary\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"Display VPNv4 NLRI specific information\\n\"\n       \"Display information for a route distinguisher\\n\"\n       \"VPN Route Distinguisher\\n\"\n       \"Summary of BGP neighbor status\\n\")\n{\n  int ret;\n  struct prefix_rd prd;\n\n  ret = str2prefix_rd (argv[0], &prd);\n  if (! ret)\n    {\n      vty_out (vty, \"%% Malformed Route Distinguisher%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  return bgp_show_summary_vty (vty, NULL, AFI_IP, SAFI_MPLS_VPN);\n}\n\n#ifdef HAVE_IPV6\nDEFUN (show_bgp_summary, \n       show_bgp_summary_cmd,\n       \"show bgp summary\",\n       SHOW_STR\n       BGP_STR\n       \"Summary of BGP neighbor status\\n\")\n{\n  return bgp_show_summary_vty (vty, NULL, AFI_IP6, SAFI_UNICAST);\n}\n\nDEFUN (show_bgp_instance_summary,\n       show_bgp_instance_summary_cmd,\n       \"show bgp view WORD summary\",\n       SHOW_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"View name\\n\"\n       \"Summary of BGP neighbor status\\n\")\n{\n  return bgp_show_summary_vty (vty, argv[0], AFI_IP6, SAFI_UNICAST);\n}\n\nALIAS (show_bgp_summary, \n       show_bgp_ipv6_summary_cmd,\n       \"show bgp ipv6 summary\",\n       SHOW_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Summary of BGP neighbor status\\n\")\n\nALIAS (show_bgp_instance_summary,\n       show_bgp_instance_ipv6_summary_cmd,\n       \"show bgp view WORD ipv6 summary\",\n       SHOW_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"View name\\n\"\n       \"Address family\\n\"\n       \"Summary of BGP neighbor status\\n\")\n\n/* old command */\nDEFUN (show_ipv6_bgp_summary, \n       show_ipv6_bgp_summary_cmd,\n       \"show ipv6 bgp summary\",\n       SHOW_STR\n       IPV6_STR\n       BGP_STR\n       \"Summary of BGP neighbor status\\n\")\n{\n  return bgp_show_summary_vty (vty, NULL, AFI_IP6, SAFI_UNICAST);\n}\n\n/* old command */\nDEFUN (show_ipv6_mbgp_summary, \n       show_ipv6_mbgp_summary_cmd,\n       \"show ipv6 mbgp summary\",\n       SHOW_STR\n       IPV6_STR\n       MBGP_STR\n       \"Summary of BGP neighbor status\\n\")\n{\n  return bgp_show_summary_vty (vty, NULL, AFI_IP6, SAFI_MULTICAST);\n}\n#endif /* HAVE_IPV6 */\n\f\nconst char *\nafi_safi_print (afi_t afi, safi_t safi)\n{\n  if (afi == AFI_IP && safi == SAFI_UNICAST)\n    return \"IPv4 Unicast\";\n  else if (afi == AFI_IP && safi == SAFI_MULTICAST)\n    return \"IPv4 Multicast\";\n  else if (afi == AFI_IP && safi == SAFI_MPLS_VPN)\n    return \"VPNv4 Unicast\";\n  else if (afi == AFI_IP6 && safi == SAFI_UNICAST)\n    return \"IPv6 Unicast\";\n  else if (afi == AFI_IP6 && safi == SAFI_MULTICAST)\n    return \"IPv6 Multicast\";\n  else\n    return \"Unknown\";\n}\n\n/* Show BGP peer's information. */\nenum show_type\n{\n  show_all,\n  show_peer\n};\n\nstatic void\nbgp_show_peer_afi_orf_cap (struct vty *vty, struct peer *p,\n\t\t\t   afi_t afi, safi_t safi,\n\t\t\t   u_int16_t adv_smcap, u_int16_t adv_rmcap,\n\t\t\t   u_int16_t rcv_smcap, u_int16_t rcv_rmcap)\n{\n  /* Send-Mode */\n  if (CHECK_FLAG (p->af_cap[afi][safi], adv_smcap)\n      || CHECK_FLAG (p->af_cap[afi][safi], rcv_smcap))\n    {\n      vty_out (vty, \"      Send-mode: \");\n      if (CHECK_FLAG (p->af_cap[afi][safi], adv_smcap))\n\tvty_out (vty, \"advertised\");\n      if (CHECK_FLAG (p->af_cap[afi][safi], rcv_smcap))\n\tvty_out (vty, \"%sreceived\",\n\t\t CHECK_FLAG (p->af_cap[afi][safi], adv_smcap) ?\n\t\t \", \" : \"\");\n      vty_out (vty, \"%s\", VTY_NEWLINE);\n    }\n\n  /* Receive-Mode */\n  if (CHECK_FLAG (p->af_cap[afi][safi], adv_rmcap)\n      || CHECK_FLAG (p->af_cap[afi][safi], rcv_rmcap))\n    {\n      vty_out (vty, \"      Receive-mode: \");\n      if (CHECK_FLAG (p->af_cap[afi][safi], adv_rmcap))\n\tvty_out (vty, \"advertised\");\n      if (CHECK_FLAG (p->af_cap[afi][safi], rcv_rmcap))\n\tvty_out (vty, \"%sreceived\",\n\t\t CHECK_FLAG (p->af_cap[afi][safi], adv_rmcap) ?\n\t\t \", \" : \"\");\n      vty_out (vty, \"%s\", VTY_NEWLINE);\n    }\n}\n\nstatic void\nbgp_show_peer_afi (struct vty *vty, struct peer *p, afi_t afi, safi_t safi)\n{\n  struct bgp_filter *filter;\n  char orf_pfx_name[BUFSIZ];\n  int orf_pfx_count;\n\n  filter = &p->filter[afi][safi];\n\n  vty_out (vty, \" For address family: %s%s\", afi_safi_print (afi, safi),\n\t   VTY_NEWLINE);\n\n  if (p->af_group[afi][safi])\n    vty_out (vty, \"  %s peer-group member%s\", p->group->name, VTY_NEWLINE);\n\n  if (CHECK_FLAG (p->af_cap[afi][safi], PEER_CAP_ORF_PREFIX_SM_ADV)\n      || CHECK_FLAG (p->af_cap[afi][safi], PEER_CAP_ORF_PREFIX_SM_RCV)\n      || CHECK_FLAG (p->af_cap[afi][safi], PEER_CAP_ORF_PREFIX_SM_OLD_RCV)\n      || CHECK_FLAG (p->af_cap[afi][safi], PEER_CAP_ORF_PREFIX_RM_ADV)\n      || CHECK_FLAG (p->af_cap[afi][safi], PEER_CAP_ORF_PREFIX_RM_RCV)\n      || CHECK_FLAG (p->af_cap[afi][safi], PEER_CAP_ORF_PREFIX_RM_OLD_RCV))\n    vty_out (vty, \"  AF-dependant capabilities:%s\", VTY_NEWLINE);\n\n  if (CHECK_FLAG (p->af_cap[afi][safi], PEER_CAP_ORF_PREFIX_SM_ADV)\n      || CHECK_FLAG (p->af_cap[afi][safi], PEER_CAP_ORF_PREFIX_SM_RCV)\n      || CHECK_FLAG (p->af_cap[afi][safi], PEER_CAP_ORF_PREFIX_RM_ADV)\n      || CHECK_FLAG (p->af_cap[afi][safi], PEER_CAP_ORF_PREFIX_RM_RCV))\n    {\n      vty_out (vty, \"    Outbound Route Filter (ORF) type (%d) Prefix-list:%s\",\n\t       ORF_TYPE_PREFIX, VTY_NEWLINE);\n      bgp_show_peer_afi_orf_cap (vty, p, afi, safi,\n\t\t\t\t PEER_CAP_ORF_PREFIX_SM_ADV,\n\t\t\t\t PEER_CAP_ORF_PREFIX_RM_ADV,\n\t\t\t\t PEER_CAP_ORF_PREFIX_SM_RCV,\n\t\t\t\t PEER_CAP_ORF_PREFIX_RM_RCV);\n    }\n  if (CHECK_FLAG (p->af_cap[afi][safi], PEER_CAP_ORF_PREFIX_SM_ADV)\n      || CHECK_FLAG (p->af_cap[afi][safi], PEER_CAP_ORF_PREFIX_SM_OLD_RCV)\n      || CHECK_FLAG (p->af_cap[afi][safi], PEER_CAP_ORF_PREFIX_RM_ADV)\n      || CHECK_FLAG (p->af_cap[afi][safi], PEER_CAP_ORF_PREFIX_RM_OLD_RCV))\n    {\n      vty_out (vty, \"    Outbound Route Filter (ORF) type (%d) Prefix-list:%s\",\n\t       ORF_TYPE_PREFIX_OLD, VTY_NEWLINE);\n      bgp_show_peer_afi_orf_cap (vty, p, afi, safi,\n\t\t\t\t PEER_CAP_ORF_PREFIX_SM_ADV,\n\t\t\t\t PEER_CAP_ORF_PREFIX_RM_ADV,\n\t\t\t\t PEER_CAP_ORF_PREFIX_SM_OLD_RCV,\n\t\t\t\t PEER_CAP_ORF_PREFIX_RM_OLD_RCV);\n    }\n\n  sprintf (orf_pfx_name, \"%s.%d.%d\", p->host, afi, safi);\n  orf_pfx_count =  prefix_bgp_show_prefix_list (NULL, afi, orf_pfx_name);\n\n  if (CHECK_FLAG (p->af_sflags[afi][safi], PEER_STATUS_ORF_PREFIX_SEND)\n      || orf_pfx_count)\n    {\n      vty_out (vty, \"  Outbound Route Filter (ORF):\");\n      if (CHECK_FLAG (p->af_sflags[afi][safi], PEER_STATUS_ORF_PREFIX_SEND))\n\t  vty_out (vty, \" sent;\");\n      if (orf_pfx_count)\n\tvty_out (vty, \" received (%d entries)\", orf_pfx_count);\n      vty_out (vty, \"%s\", VTY_NEWLINE);\n    }\n  if (CHECK_FLAG (p->af_sflags[afi][safi], PEER_STATUS_ORF_WAIT_REFRESH))\n      vty_out (vty, \"  First update is deferred until ORF or ROUTE-REFRESH is received%s\", VTY_NEWLINE);\n\n  if (CHECK_FLAG (p->af_flags[afi][safi], PEER_FLAG_REFLECTOR_CLIENT))\n    vty_out (vty, \"  Route-Reflector Client%s\", VTY_NEWLINE);\n  if (CHECK_FLAG (p->af_flags[afi][safi], PEER_FLAG_RSERVER_CLIENT))\n    vty_out (vty, \"  Route-Server Client%s\", VTY_NEWLINE);\n  if (CHECK_FLAG (p->af_flags[afi][safi], PEER_FLAG_SOFT_RECONFIG))\n    vty_out (vty, \"  Inbound soft reconfiguration allowed%s\", VTY_NEWLINE);\n  if (CHECK_FLAG (p->af_flags[afi][safi], PEER_FLAG_REMOVE_PRIVATE_AS))\n    vty_out (vty, \"  Private AS number removed from updates to this neighbor%s\", VTY_NEWLINE);\n  if (CHECK_FLAG (p->af_flags[afi][safi], PEER_FLAG_NEXTHOP_SELF))\n    vty_out (vty, \"  NEXT_HOP is always this router%s\", VTY_NEWLINE);\n  if (CHECK_FLAG (p->af_flags[afi][safi], PEER_FLAG_AS_PATH_UNCHANGED))\n    vty_out (vty, \"  AS_PATH is propagated unchanged to this neighbor%s\", VTY_NEWLINE);\n  if (CHECK_FLAG (p->af_flags[afi][safi], PEER_FLAG_NEXTHOP_UNCHANGED))\n    vty_out (vty, \"  NEXT_HOP is propagated unchanged to this neighbor%s\", VTY_NEWLINE);\n  if (CHECK_FLAG (p->af_flags[afi][safi], PEER_FLAG_MED_UNCHANGED))\n    vty_out (vty, \"  MED is propagated unchanged to this neighbor%s\", VTY_NEWLINE);\n  if (CHECK_FLAG (p->af_flags[afi][safi], PEER_FLAG_SEND_COMMUNITY)\n      || CHECK_FLAG (p->af_flags[afi][safi], PEER_FLAG_SEND_EXT_COMMUNITY))\n    {\n      vty_out (vty, \"  Community attribute sent to this neighbor\");\n      if (CHECK_FLAG (p->af_flags[afi][safi], PEER_FLAG_SEND_COMMUNITY)\n\t&& CHECK_FLAG (p->af_flags[afi][safi], PEER_FLAG_SEND_EXT_COMMUNITY))\n\tvty_out (vty, \"(both)%s\", VTY_NEWLINE);\n      else if (CHECK_FLAG (p->af_flags[afi][safi], PEER_FLAG_SEND_EXT_COMMUNITY))\n\tvty_out (vty, \"(extended)%s\", VTY_NEWLINE);\n      else \n\tvty_out (vty, \"(standard)%s\", VTY_NEWLINE);\n    }\n  if (CHECK_FLAG (p->af_flags[afi][safi], PEER_FLAG_DEFAULT_ORIGINATE))\n    {\n      vty_out (vty, \"  Default information originate,\");\n\n      if (p->default_rmap[afi][safi].name)\n\tvty_out (vty, \" default route-map %s%s,\",\n\t\t p->default_rmap[afi][safi].map ? \"*\" : \"\",\n\t\t p->default_rmap[afi][safi].name);\n      if (CHECK_FLAG (p->af_sflags[afi][safi], PEER_STATUS_DEFAULT_ORIGINATE))\n\tvty_out (vty, \" default sent%s\", VTY_NEWLINE);\n      else\n\tvty_out (vty, \" default not sent%s\", VTY_NEWLINE);\n    }\n\n  if (filter->plist[FILTER_IN].name\n      || filter->dlist[FILTER_IN].name\n      || filter->aslist[FILTER_IN].name\n      || filter->map[RMAP_IN].name)\n    vty_out (vty, \"  Inbound path policy configured%s\", VTY_NEWLINE);\n  if (filter->plist[FILTER_OUT].name\n      || filter->dlist[FILTER_OUT].name\n      || filter->aslist[FILTER_OUT].name\n      || filter->map[RMAP_OUT].name\n      || filter->usmap.name)\n    vty_out (vty, \"  Outbound path policy configured%s\", VTY_NEWLINE);\n  if (filter->map[RMAP_IMPORT].name)\n    vty_out (vty, \"  Import policy for this RS-client configured%s\", VTY_NEWLINE);\n  if (filter->map[RMAP_EXPORT].name)\n    vty_out (vty, \"  Export policy for this RS-client configured%s\", VTY_NEWLINE);\n\n  /* prefix-list */\n  if (filter->plist[FILTER_IN].name)\n    vty_out (vty, \"  Incoming update prefix filter list is %s%s%s\",\n\t     filter->plist[FILTER_IN].plist ? \"*\" : \"\",\n\t     filter->plist[FILTER_IN].name,\n\t     VTY_NEWLINE);\n  if (filter->plist[FILTER_OUT].name)\n    vty_out (vty, \"  Outgoing update prefix filter list is %s%s%s\",\n\t     filter->plist[FILTER_OUT].plist ? \"*\" : \"\",\n\t     filter->plist[FILTER_OUT].name,\n\t     VTY_NEWLINE);\n\n  /* distribute-list */\n  if (filter->dlist[FILTER_IN].name)\n    vty_out (vty, \"  Incoming update network filter list is %s%s%s\",\n\t     filter->dlist[FILTER_IN].alist ? \"*\" : \"\",\n\t     filter->dlist[FILTER_IN].name,\n\t     VTY_NEWLINE);\n  if (filter->dlist[FILTER_OUT].name)\n    vty_out (vty, \"  Outgoing update network filter list is %s%s%s\",\n\t     filter->dlist[FILTER_OUT].alist ? \"*\" : \"\",\n\t     filter->dlist[FILTER_OUT].name,\n\t     VTY_NEWLINE);\n\n  /* filter-list. */\n  if (filter->aslist[FILTER_IN].name)\n    vty_out (vty, \"  Incoming update AS path filter list is %s%s%s\",\n\t     filter->aslist[FILTER_IN].aslist ? \"*\" : \"\",\n\t     filter->aslist[FILTER_IN].name,\n\t     VTY_NEWLINE);\n  if (filter->aslist[FILTER_OUT].name)\n    vty_out (vty, \"  Outgoing update AS path filter list is %s%s%s\",\n\t     filter->aslist[FILTER_OUT].aslist ? \"*\" : \"\",\n\t     filter->aslist[FILTER_OUT].name,\n\t     VTY_NEWLINE);\n\n  /* route-map. */\n  if (filter->map[RMAP_IN].name)\n    vty_out (vty, \"  Route map for incoming advertisements is %s%s%s\",\n            filter->map[RMAP_IN].map ? \"*\" : \"\",\n            filter->map[RMAP_IN].name,\n\t     VTY_NEWLINE);\n  if (filter->map[RMAP_OUT].name)\n    vty_out (vty, \"  Route map for outgoing advertisements is %s%s%s\",\n            filter->map[RMAP_OUT].map ? \"*\" : \"\",\n            filter->map[RMAP_OUT].name,\n            VTY_NEWLINE);\n  if (filter->map[RMAP_IMPORT].name)\n    vty_out (vty, \"  Route map for advertisements going into this RS-client's table is %s%s%s\",\n            filter->map[RMAP_IMPORT].map ? \"*\" : \"\",\n            filter->map[RMAP_IMPORT].name,\n            VTY_NEWLINE);\n  if (filter->map[RMAP_EXPORT].name)\n    vty_out (vty, \"  Route map for advertisements coming from this RS-client is %s%s%s\",\n            filter->map[RMAP_EXPORT].map ? \"*\" : \"\",\n            filter->map[RMAP_EXPORT].name,\n\t     VTY_NEWLINE);\n\n  /* unsuppress-map */\n  if (filter->usmap.name)\n    vty_out (vty, \"  Route map for selective unsuppress is %s%s%s\",\n\t     filter->usmap.map ? \"*\" : \"\",\n\t     filter->usmap.name, VTY_NEWLINE);\n\n  /* Receive prefix count */\n  vty_out (vty, \"  %ld accepted prefixes%s\", p->pcount[afi][safi], VTY_NEWLINE);\n\n  /* Maximum prefix */\n  if (CHECK_FLAG (p->af_flags[afi][safi], PEER_FLAG_MAX_PREFIX))\n    {\n      vty_out (vty, \"  Maximum prefixes allowed %ld%s%s\", p->pmax[afi][safi],\n\t       CHECK_FLAG (p->af_flags[afi][safi], PEER_FLAG_MAX_PREFIX_WARNING)\n\t       ? \" (warning-only)\" : \"\", VTY_NEWLINE);\n      vty_out (vty, \"  Threshold for warning message %d%%\",\n\t       p->pmax_threshold[afi][safi]);\n      if (p->pmax_restart[afi][safi])\n\tvty_out (vty, \", restart interval %d min\", p->pmax_restart[afi][safi]);\n      vty_out (vty, \"%s\", VTY_NEWLINE);\n    }\n\n  vty_out (vty, \"%s\", VTY_NEWLINE);\n}\n\nstatic void\nbgp_show_peer (struct vty *vty, struct peer *p)\n{\n  struct bgp *bgp;\n  char buf1[BUFSIZ];\n  char timebuf[BGP_UPTIME_LEN];\n  afi_t afi;\n  safi_t safi;\n\n  bgp = p->bgp;\n\n  /* Configured IP address. */\n  vty_out (vty, \"BGP neighbor is %s, \", p->host);\n  vty_out (vty, \"remote AS %d, \", p->as);\n  vty_out (vty, \"local AS %d%s, \",\n\t   p->change_local_as ? p->change_local_as : p->local_as,\n\t   CHECK_FLAG (p->flags, PEER_FLAG_LOCAL_AS_NO_PREPEND) ?\n\t   \" no-prepend\" : \"\");\n  vty_out (vty, \"%s link%s\",\n\t   p->as == p->local_as ? \"internal\" : \"external\",\n\t   VTY_NEWLINE);\n\n  /* Description. */\n  if (p->desc)\n    vty_out (vty, \" Description: %s%s\", p->desc, VTY_NEWLINE);\n  \n  /* Peer-group */\n  if (p->group)\n    vty_out (vty, \" Member of peer-group %s for session parameters%s\",\n\t     p->group->name, VTY_NEWLINE);\n\n  /* Administrative shutdown. */\n  if (CHECK_FLAG (p->flags, PEER_FLAG_SHUTDOWN))\n    vty_out (vty, \" Administratively shut down%s\", VTY_NEWLINE);\n\n  /* BGP Version. */\n  vty_out (vty, \"  BGP version 4\");\n  vty_out (vty, \", remote router ID %s%s\", \n\t   inet_ntop (AF_INET, &p->remote_id, buf1, BUFSIZ),\n\t   VTY_NEWLINE);\n\n  /* Confederation */\n  if (CHECK_FLAG (bgp->config, BGP_CONFIG_CONFEDERATION)\n      && bgp_confederation_peers_check (bgp, p->as))\n    vty_out (vty, \"  Neighbor under common administration%s\", VTY_NEWLINE);\n  \n  /* Status. */\n  vty_out (vty, \"  BGP state = %s\",  \n\t   LOOKUP (bgp_status_msg, p->status));\n  if (p->status == Established) \n    vty_out (vty, \", up for %8s\", \n\t     peer_uptime (p->uptime, timebuf, BGP_UPTIME_LEN));\n  else if (p->status == Active)\n    {\n      if (CHECK_FLAG (p->flags, PEER_FLAG_PASSIVE))\n\tvty_out (vty, \" (passive)\"); \n      else if (CHECK_FLAG (p->sflags, PEER_STATUS_NSF_WAIT))\n\tvty_out (vty, \" (NSF passive)\"); \n    }\n  vty_out (vty, \"%s\", VTY_NEWLINE);\n  \n  /* read timer */\n  vty_out (vty, \"  Last read %s\", peer_uptime (p->readtime, timebuf, BGP_UPTIME_LEN));\n\n  /* Configured timer values. */\n  vty_out (vty, \", hold time is %d, keepalive interval is %d seconds%s\",\n\t   p->v_holdtime, p->v_keepalive, VTY_NEWLINE);\n  if (CHECK_FLAG (p->config, PEER_CONFIG_TIMER))\n    {\n      vty_out (vty, \"  Configured hold time is %d\", p->holdtime);\n      vty_out (vty, \", keepalive interval is %d seconds%s\",\n\t       p->keepalive, VTY_NEWLINE);\n    }\n\n  /* Capability. */\n  if (p->status == Established) \n    {\n      if (p->cap\n\t  || p->afc_adv[AFI_IP][SAFI_UNICAST]\n\t  || p->afc_recv[AFI_IP][SAFI_UNICAST]\n\t  || p->afc_adv[AFI_IP][SAFI_MULTICAST]\n\t  || p->afc_recv[AFI_IP][SAFI_MULTICAST]\n#ifdef HAVE_IPV6\n\t  || p->afc_adv[AFI_IP6][SAFI_UNICAST]\n\t  || p->afc_recv[AFI_IP6][SAFI_UNICAST]\n\t  || p->afc_adv[AFI_IP6][SAFI_MULTICAST]\n\t  || p->afc_recv[AFI_IP6][SAFI_MULTICAST]\n#endif /* HAVE_IPV6 */\n\t  || p->afc_adv[AFI_IP][SAFI_MPLS_VPN]\n\t  || p->afc_recv[AFI_IP][SAFI_MPLS_VPN])\n\t{\n\t  vty_out (vty, \"  Neighbor capabilities:%s\", VTY_NEWLINE);\n\n\t  /* Dynamic */\n\t  if (CHECK_FLAG (p->cap, PEER_CAP_DYNAMIC_RCV)\n\t      || CHECK_FLAG (p->cap, PEER_CAP_DYNAMIC_ADV))\n\t    {\n\t      vty_out (vty, \"    Dynamic:\");\n\t      if (CHECK_FLAG (p->cap, PEER_CAP_DYNAMIC_ADV))\n\t\tvty_out (vty, \" advertised\");\n\t      if (CHECK_FLAG (p->cap, PEER_CAP_DYNAMIC_RCV))\n\t\tvty_out (vty, \" %sreceived\",\n\t\t\t CHECK_FLAG (p->cap, PEER_CAP_DYNAMIC_ADV) ? \"and \" : \"\");\n\t      vty_out (vty, \"%s\", VTY_NEWLINE);\n\t    }\n\n\t  /* Route Refresh */\n\t  if (CHECK_FLAG (p->cap, PEER_CAP_REFRESH_ADV)\n\t      || CHECK_FLAG (p->cap, PEER_CAP_REFRESH_NEW_RCV)\n\t      || CHECK_FLAG (p->cap, PEER_CAP_REFRESH_OLD_RCV))\n\t    {\n\t      vty_out (vty, \"    Route refresh:\");\n \t      if (CHECK_FLAG (p->cap, PEER_CAP_REFRESH_ADV))\n\t\tvty_out (vty, \" advertised\");\n\t      if (CHECK_FLAG (p->cap, PEER_CAP_REFRESH_NEW_RCV)\n\t\t  || CHECK_FLAG (p->cap, PEER_CAP_REFRESH_OLD_RCV))\n\t\tvty_out (vty, \" %sreceived(%s)\",\n\t\t\t CHECK_FLAG (p->cap, PEER_CAP_REFRESH_ADV) ? \"and \" : \"\",\n\t\t\t (CHECK_FLAG (p->cap, PEER_CAP_REFRESH_OLD_RCV)\n\t\t\t  && CHECK_FLAG (p->cap, PEER_CAP_REFRESH_NEW_RCV)) ?\n\t\t\t \"old & new\" : CHECK_FLAG (p->cap, PEER_CAP_REFRESH_OLD_RCV) ? \"old\" : \"new\");\n\n\t      vty_out (vty, \"%s\", VTY_NEWLINE);\n\t    }\n\n\t  /* Multiprotocol Extensions */\n\t  for (afi = AFI_IP ; afi < AFI_MAX ; afi++)\n\t    for (safi = SAFI_UNICAST ; safi < SAFI_MAX ; safi++)\n\t      if (p->afc_adv[afi][safi] || p->afc_recv[afi][safi])\n\t\t{\n\t\t  vty_out (vty, \"    Address family %s:\", afi_safi_print (afi, safi));\n\t\t  if (p->afc_adv[afi][safi]) \n\t\t    vty_out (vty, \" advertised\");\n\t\t  if (p->afc_recv[afi][safi])\n\t\t    vty_out (vty, \" %sreceived\", p->afc_adv[afi][safi] ? \"and \" : \"\");\n\t\t  vty_out (vty, \"%s\", VTY_NEWLINE);\n\t\t} \n\n\t  /* Gracefull Restart */\n\t  if (CHECK_FLAG (p->cap, PEER_CAP_RESTART_RCV)\n\t      || CHECK_FLAG (p->cap, PEER_CAP_RESTART_ADV))\n\t    {\n\t      vty_out (vty, \"    Graceful Restart Capabilty:\");\n\t      if (CHECK_FLAG (p->cap, PEER_CAP_RESTART_ADV))\n\t\tvty_out (vty, \" advertised\");\n\t      if (CHECK_FLAG (p->cap, PEER_CAP_RESTART_RCV))\n\t\tvty_out (vty, \" %sreceived\",\n\t\t\t CHECK_FLAG (p->cap, PEER_CAP_RESTART_ADV) ? \"and \" : \"\");\n\t      vty_out (vty, \"%s\", VTY_NEWLINE);\n\n\t      if (CHECK_FLAG (p->cap, PEER_CAP_RESTART_RCV))\n\t\t{\n\t\t  int restart_af_count = 0;\n\n\t\t  vty_out (vty, \"      Remote Restart timer is %d seconds%s\",\n\t\t\t   p->v_gr_restart, VTY_NEWLINE);\t\n\t\t  vty_out (vty, \"      Address families by peer:%s        \", VTY_NEWLINE);\n\n\t\t  for (afi = AFI_IP ; afi < AFI_MAX ; afi++)\n\t\t    for (safi = SAFI_UNICAST ; safi < SAFI_MAX ; safi++)\n\t\t      if (CHECK_FLAG (p->af_cap[afi][safi], PEER_CAP_RESTART_AF_RCV))\n\t\t\t{\n\t\t\t  vty_out (vty, \"%s%s(%s)\", restart_af_count ? \", \" : \"\",\n\t\t\t\t   afi_safi_print (afi, safi),\n\t\t\t\t   CHECK_FLAG (p->af_cap[afi][safi], PEER_CAP_RESTART_AF_PRESERVE_RCV) ?\n\t\t\t\t   \"preserved\" : \"not preserved\");\n\t\t\t  restart_af_count++;\n\t\t\t}\n\t\t  if (! restart_af_count)\n\t\t    vty_out (vty, \"none\");\n\t\t  vty_out (vty, \"%s\", VTY_NEWLINE);\n\t\t}\n\t    }\n\t}\n    }\n\n  /* graceful restart information */\n  if (CHECK_FLAG (p->cap, PEER_CAP_RESTART_RCV)\n      || p->t_gr_restart\n      || p->t_gr_stale)\n    {\n      int eor_send_af_count = 0;\n      int eor_receive_af_count = 0;\n\n      vty_out (vty, \"  Graceful restart informations:%s\", VTY_NEWLINE);\n      if (p->status == Established) \n\t{\n\t  vty_out (vty, \"    End-of-RIB send: \");\n\t  for (afi = AFI_IP ; afi < AFI_MAX ; afi++)\n\t    for (safi = SAFI_UNICAST ; safi < SAFI_MAX ; safi++)\n\t      if (CHECK_FLAG (p->af_sflags[afi][safi], PEER_STATUS_EOR_SEND))\n\t\t{\n\t\t  vty_out (vty, \"%s%s\", eor_send_af_count ? \", \" : \"\",\n\t\t\t   afi_safi_print (afi, safi));\n\t\t  eor_send_af_count++;\n\t\t}\n\t  vty_out (vty, \"%s\", VTY_NEWLINE);\n\n\t  vty_out (vty, \"    End-of-RIB received: \");\n\t  for (afi = AFI_IP ; afi < AFI_MAX ; afi++)\n\t    for (safi = SAFI_UNICAST ; safi < SAFI_MAX ; safi++)\n\t      if (CHECK_FLAG (p->af_sflags[afi][safi], PEER_STATUS_EOR_RECEIVED))\n\t\t{\n\t\t  vty_out (vty, \"%s%s\", eor_receive_af_count ? \", \" : \"\",\n\t\t\t   afi_safi_print (afi, safi));\n\t\t  eor_receive_af_count++;\n\t\t}\n\t  vty_out (vty, \"%s\", VTY_NEWLINE);\n\t}\n\n      if (p->t_gr_restart)\n        {\n\t  vty_out (vty, \"    The remaining time of restart timer is %ld%s\",\n\t\t   thread_timer_remain_second (p->t_gr_restart), VTY_NEWLINE);\n\t}\n      if (p->t_gr_stale)\n\t{\n\t  vty_out (vty, \"    The remaining time of stalepath timer is %ld%s\",\n\t\t   thread_timer_remain_second (p->t_gr_stale), VTY_NEWLINE);\n\t}\n    }\n\n  /* Packet counts. */\n  vty_out (vty, \"  Message statistics:%s\", VTY_NEWLINE);\n  vty_out (vty, \"    Inq depth is 0%s\", VTY_NEWLINE);\n  vty_out (vty, \"    Outq depth is %ld%s\", p->obuf->count, VTY_NEWLINE);\n  vty_out (vty, \"                         Sent       Rcvd%s\", VTY_NEWLINE);\n  vty_out (vty, \"    Opens:         %10d %10d%s\", p->open_out, p->open_in, VTY_NEWLINE);\n  vty_out (vty, \"    Notifications: %10d %10d%s\", p->notify_out, p->notify_in, VTY_NEWLINE);\n  vty_out (vty, \"    Updates:       %10d %10d%s\", p->update_out, p->update_in, VTY_NEWLINE);\n  vty_out (vty, \"    Keepalives:    %10d %10d%s\", p->keepalive_out, p->keepalive_in, VTY_NEWLINE);\n  vty_out (vty, \"    Route Refresh: %10d %10d%s\", p->refresh_out, p->refresh_in, VTY_NEWLINE);\n  vty_out (vty, \"    Capability:    %10d %10d%s\", p->dynamic_cap_out, p->dynamic_cap_in, VTY_NEWLINE);\n  vty_out (vty, \"    Total:         %10d %10d%s\", p->open_out + p->notify_out +\n\t   p->update_out + p->keepalive_out + p->refresh_out + p->dynamic_cap_out,\n\t   p->open_in + p->notify_in + p->update_in + p->keepalive_in + p->refresh_in +\n\t   p->dynamic_cap_in, VTY_NEWLINE);\n\n  /* advertisement-interval */\n  vty_out (vty, \"  Minimum time between advertisement runs is %d seconds%s\",\n\t   p->v_routeadv, VTY_NEWLINE);\n\n  /* Update-source. */\n  if (p->update_if || p->update_source)\n    {\n      vty_out (vty, \"  Update source is \");\n      if (p->update_if)\n\tvty_out (vty, \"%s\", p->update_if);\n      else if (p->update_source)\n\tvty_out (vty, \"%s\",\n\t\t sockunion2str (p->update_source, buf1, SU_ADDRSTRLEN));\n      vty_out (vty, \"%s\", VTY_NEWLINE);\n    }\n\n  /* Default weight */\n  if (CHECK_FLAG (p->config, PEER_CONFIG_WEIGHT))\n    vty_out (vty, \"  Default weight %d%s\", p->weight,\n\t     VTY_NEWLINE);\n\n  vty_out (vty, \"%s\", VTY_NEWLINE);\n\n  /* Address Family Information */\n  for (afi = AFI_IP ; afi < AFI_MAX ; afi++)\n    for (safi = SAFI_UNICAST ; safi < SAFI_MAX ; safi++)\n      if (p->afc[afi][safi])\n\tbgp_show_peer_afi (vty, p, afi, safi);\n\n  vty_out (vty, \"  Connections established %d; dropped %d%s\",\n\t   p->established, p->dropped,\n\t   VTY_NEWLINE);\n\n  if (! p->dropped)\n    vty_out (vty, \"  Last reset never%s\", VTY_NEWLINE);\n  else\n    vty_out (vty, \"  Last reset %s, due to %s%s\",\n            peer_uptime (p->resettime, timebuf, BGP_UPTIME_LEN),\n            peer_down_str[(int) p->last_reset], VTY_NEWLINE);\n\n  if (CHECK_FLAG (p->sflags, PEER_STATUS_PREFIX_OVERFLOW))\n    {\n      vty_out (vty, \"  Peer had exceeded the max. no. of prefixes configured.%s\", VTY_NEWLINE);\n\n      if (p->t_pmax_restart)\n\tvty_out (vty, \"  Reduce the no. of prefix from %s, will restart in %ld seconds%s\",\n\t\t p->host, thread_timer_remain_second (p->t_pmax_restart),\n\t\t VTY_NEWLINE);\n      else\n\tvty_out (vty, \"  Reduce the no. of prefix and clear ip bgp %s to restore peering%s\",\n\t\t p->host, VTY_NEWLINE);\n    }\n\n  /* EBGP Multihop */\n  if (peer_sort (p) != BGP_PEER_IBGP && p->ttl > 1)\n    vty_out (vty, \"  External BGP neighbor may be up to %d hops away.%s\",\n\t     p->ttl, VTY_NEWLINE);\n\n  /* Local address. */\n  if (p->su_local)\n    {\n      vty_out (vty, \"Local host: %s, Local port: %d%s\",\n\t       sockunion2str (p->su_local, buf1, SU_ADDRSTRLEN),\n\t       ntohs (p->su_local->sin.sin_port),\n\t       VTY_NEWLINE);\n    }\n      \n  /* Remote address. */\n  if (p->su_remote)\n    {\n      vty_out (vty, \"Foreign host: %s, Foreign port: %d%s\",\n\t       sockunion2str (p->su_remote, buf1, SU_ADDRSTRLEN),\n\t       ntohs (p->su_remote->sin.sin_port),\n\t       VTY_NEWLINE);\n    }\n\n  /* Nexthop display. */\n  if (p->su_local)\n    {\n      vty_out (vty, \"Nexthop: %s%s\", \n\t       inet_ntop (AF_INET, &p->nexthop.v4, buf1, BUFSIZ),\n\t       VTY_NEWLINE);\n#ifdef HAVE_IPV6\n      vty_out (vty, \"Nexthop global: %s%s\", \n\t       inet_ntop (AF_INET6, &p->nexthop.v6_global, buf1, BUFSIZ),\n\t       VTY_NEWLINE);\n      vty_out (vty, \"Nexthop local: %s%s\",\n\t       inet_ntop (AF_INET6, &p->nexthop.v6_local, buf1, BUFSIZ),\n\t       VTY_NEWLINE);\n      vty_out (vty, \"BGP connection: %s%s\",\n\t       p->shared_network ? \"shared network\" : \"non shared network\",\n\t       VTY_NEWLINE);\n#endif /* HAVE_IPV6 */\n    }\n\n  /* Timer information. */\n  if (p->t_start)\n    vty_out (vty, \"Next start timer due in %ld seconds%s\",\n\t     thread_timer_remain_second (p->t_start), VTY_NEWLINE);\n  if (p->t_connect)\n    vty_out (vty, \"Next connect timer due in %ld seconds%s\",\n\t     thread_timer_remain_second (p->t_connect), VTY_NEWLINE);\n  \n  vty_out (vty, \"Read thread: %s  Write thread: %s%s\", \n\t   p->t_read ? \"on\" : \"off\",\n\t   p->t_write ? \"on\" : \"off\",\n\t   VTY_NEWLINE);\n\n  if (p->notify.code == BGP_NOTIFY_OPEN_ERR\n      && p->notify.subcode == BGP_NOTIFY_OPEN_UNSUP_CAPBL)\n    bgp_capability_vty_out (vty, p);\n \n  vty_out (vty, \"%s\", VTY_NEWLINE);\n}\n\nstatic int\nbgp_show_neighbor (struct vty *vty, struct bgp *bgp,\n\t\t   enum show_type type, union sockunion *su)\n{\n  struct listnode *node, *nnode;\n  struct peer *peer;\n  int find = 0;\n\n  for (ALL_LIST_ELEMENTS (bgp->peer, node, nnode, peer))\n    {\n      switch (type)\n\t{\n\tcase show_all:\n\t  bgp_show_peer (vty, peer);\n\t  break;\n\tcase show_peer:\n\t  if (sockunion_same (&peer->su, su))\n\t    {\n\t      find = 1;\n\t      bgp_show_peer (vty, peer);\n\t    }\n\t  break;\n\t}\n    }\n\n  if (type == show_peer && ! find)\n    vty_out (vty, \"%% No such neighbor%s\", VTY_NEWLINE);\n  \n  return CMD_SUCCESS;\n}\n\nstatic int \nbgp_show_neighbor_vty (struct vty *vty, const char *name, \n                       enum show_type type, const char *ip_str)\n{\n  int ret;\n  struct bgp *bgp;\n  union sockunion su;\n\n  if (ip_str)\n    {\n      ret = str2sockunion (ip_str, &su);\n      if (ret < 0)\n        {\n          vty_out (vty, \"%% Malformed address: %s%s\", ip_str, VTY_NEWLINE);\n          return CMD_WARNING;\n        }\n    }\n\n  if (name)\n    {\n      bgp = bgp_lookup_by_name (name);\n      \n      if (! bgp)\n        {\n          vty_out (vty, \"%% No such BGP instance exist%s\", VTY_NEWLINE); \n          return CMD_WARNING;\n        }\n\n      bgp_show_neighbor (vty, bgp, type, &su);\n\n      return CMD_SUCCESS;\n    }\n\n  bgp = bgp_get_default ();\n\n  if (bgp)\n    bgp_show_neighbor (vty, bgp, type, &su);\n\n  return CMD_SUCCESS;\n}\n\n/* \"show ip bgp neighbors\" commands.  */\nDEFUN (show_ip_bgp_neighbors,\n       show_ip_bgp_neighbors_cmd,\n       \"show ip bgp neighbors\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"Detailed information on TCP and BGP neighbor connections\\n\")\n{\n  return bgp_show_neighbor_vty (vty, NULL, show_all, NULL);\n}\n\nALIAS (show_ip_bgp_neighbors,\n       show_ip_bgp_ipv4_neighbors_cmd,\n       \"show ip bgp ipv4 (unicast|multicast) neighbors\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Detailed information on TCP and BGP neighbor connections\\n\")\n\nALIAS (show_ip_bgp_neighbors,\n       show_ip_bgp_vpnv4_all_neighbors_cmd,\n       \"show ip bgp vpnv4 all neighbors\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"Display VPNv4 NLRI specific information\\n\"\n       \"Display information about all VPNv4 NLRIs\\n\"\n       \"Detailed information on TCP and BGP neighbor connections\\n\")\n\nALIAS (show_ip_bgp_neighbors,\n       show_ip_bgp_vpnv4_rd_neighbors_cmd,\n       \"show ip bgp vpnv4 rd ASN:nn_or_IP-address:nn neighbors\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"Display VPNv4 NLRI specific information\\n\"\n       \"Display information for a route distinguisher\\n\"\n       \"VPN Route Distinguisher\\n\"\n       \"Detailed information on TCP and BGP neighbor connections\\n\")\n\nALIAS (show_ip_bgp_neighbors,\n       show_bgp_neighbors_cmd,\n       \"show bgp neighbors\",\n       SHOW_STR\n       BGP_STR\n       \"Detailed information on TCP and BGP neighbor connections\\n\")\n\nALIAS (show_ip_bgp_neighbors,\n       show_bgp_ipv6_neighbors_cmd,\n       \"show bgp ipv6 neighbors\",\n       SHOW_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Detailed information on TCP and BGP neighbor connections\\n\")\n\nDEFUN (show_ip_bgp_neighbors_peer,\n       show_ip_bgp_neighbors_peer_cmd,\n       \"show ip bgp neighbors (A.B.C.D|X:X::X:X)\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"Detailed information on TCP and BGP neighbor connections\\n\"\n       \"Neighbor to display information about\\n\"\n       \"Neighbor to display information about\\n\")\n{\n  return bgp_show_neighbor_vty (vty, NULL, show_peer, argv[argc - 1]);\n}\n\nALIAS (show_ip_bgp_neighbors_peer,\n       show_ip_bgp_ipv4_neighbors_peer_cmd,\n       \"show ip bgp ipv4 (unicast|multicast) neighbors (A.B.C.D|X:X::X:X)\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Detailed information on TCP and BGP neighbor connections\\n\"\n       \"Neighbor to display information about\\n\"\n       \"Neighbor to display information about\\n\")\n\nALIAS (show_ip_bgp_neighbors_peer,\n       show_ip_bgp_vpnv4_all_neighbors_peer_cmd,\n       \"show ip bgp vpnv4 all neighbors A.B.C.D\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"Display VPNv4 NLRI specific information\\n\"\n       \"Display information about all VPNv4 NLRIs\\n\"\n       \"Detailed information on TCP and BGP neighbor connections\\n\"\n       \"Neighbor to display information about\\n\")\n\nALIAS (show_ip_bgp_neighbors_peer,\n       show_ip_bgp_vpnv4_rd_neighbors_peer_cmd,\n       \"show ip bgp vpnv4 rd ASN:nn_or_IP-address:nn neighbors A.B.C.D\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"Display VPNv4 NLRI specific information\\n\"\n       \"Display information about all VPNv4 NLRIs\\n\"\n       \"Detailed information on TCP and BGP neighbor connections\\n\"\n       \"Neighbor to display information about\\n\")\n\nALIAS (show_ip_bgp_neighbors_peer,\n       show_bgp_neighbors_peer_cmd,\n       \"show bgp neighbors (A.B.C.D|X:X::X:X)\",\n       SHOW_STR\n       BGP_STR\n       \"Detailed information on TCP and BGP neighbor connections\\n\"\n       \"Neighbor to display information about\\n\"\n       \"Neighbor to display information about\\n\")\n\nALIAS (show_ip_bgp_neighbors_peer,\n       show_bgp_ipv6_neighbors_peer_cmd,\n       \"show bgp ipv6 neighbors (A.B.C.D|X:X::X:X)\",\n       SHOW_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Detailed information on TCP and BGP neighbor connections\\n\"\n       \"Neighbor to display information about\\n\"\n       \"Neighbor to display information about\\n\")\n\nDEFUN (show_ip_bgp_instance_neighbors,\n       show_ip_bgp_instance_neighbors_cmd,\n       \"show ip bgp view WORD neighbors\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"View name\\n\"\n       \"Detailed information on TCP and BGP neighbor connections\\n\")\n{\n  return bgp_show_neighbor_vty (vty, argv[0], show_all, NULL);\n}\n\nALIAS (show_ip_bgp_instance_neighbors,\n       show_bgp_instance_neighbors_cmd,\n       \"show bgp view WORD neighbors\",\n       SHOW_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"View name\\n\"\n       \"Detailed information on TCP and BGP neighbor connections\\n\")\n\nALIAS (show_ip_bgp_instance_neighbors,\n       show_bgp_instance_ipv6_neighbors_cmd,\n       \"show bgp view WORD ipv6 neighbors\",\n       SHOW_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"View name\\n\"\n       \"Address family\\n\"\n       \"Detailed information on TCP and BGP neighbor connections\\n\")\n\nDEFUN (show_ip_bgp_instance_neighbors_peer,\n       show_ip_bgp_instance_neighbors_peer_cmd,\n       \"show ip bgp view WORD neighbors (A.B.C.D|X:X::X:X)\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"View name\\n\"\n       \"Detailed information on TCP and BGP neighbor connections\\n\"\n       \"Neighbor to display information about\\n\"\n       \"Neighbor to display information about\\n\")\n{\n  return bgp_show_neighbor_vty (vty, argv[0], show_peer, argv[1]);\n}\n\nALIAS (show_ip_bgp_instance_neighbors_peer,\n       show_bgp_instance_neighbors_peer_cmd,\n       \"show bgp view WORD neighbors (A.B.C.D|X:X::X:X)\",\n       SHOW_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"View name\\n\"\n       \"Detailed information on TCP and BGP neighbor connections\\n\"\n       \"Neighbor to display information about\\n\"\n       \"Neighbor to display information about\\n\")\n\nALIAS (show_ip_bgp_instance_neighbors_peer,\n       show_bgp_instance_ipv6_neighbors_peer_cmd,\n       \"show bgp view WORD ipv6 neighbors (A.B.C.D|X:X::X:X)\",\n       SHOW_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"View name\\n\"\n       \"Address family\\n\"\n       \"Detailed information on TCP and BGP neighbor connections\\n\"\n       \"Neighbor to display information about\\n\"\n       \"Neighbor to display information about\\n\")\n       \f\n/* Show BGP's AS paths internal data.  There are both `show ip bgp\n   paths' and `show ip mbgp paths'.  Those functions results are the\n   same.*/\nDEFUN (show_ip_bgp_paths, \n       show_ip_bgp_paths_cmd,\n       \"show ip bgp paths\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"Path information\\n\")\n{\n  vty_out (vty, \"Address Refcnt Path%s\", VTY_NEWLINE);\n  aspath_print_all_vty (vty);\n  return CMD_SUCCESS;\n}\n\nDEFUN (show_ip_bgp_ipv4_paths, \n       show_ip_bgp_ipv4_paths_cmd,\n       \"show ip bgp ipv4 (unicast|multicast) paths\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Path information\\n\")\n{\n  vty_out (vty, \"Address Refcnt Path\\r\\n\");\n  aspath_print_all_vty (vty);\n\n  return CMD_SUCCESS;\n}\n\f\n#include \"hash.h\"\n\nstatic void\ncommunity_show_all_iterator (struct hash_backet *backet, struct vty *vty)\n{\n  struct community *com;\n\n  com = (struct community *) backet->data;\n  vty_out (vty, \"[%p] (%ld) %s%s\", backet, com->refcnt,\n\t   community_str (com), VTY_NEWLINE);\n}\n\n/* Show BGP's community internal data. */\nDEFUN (show_ip_bgp_community_info, \n       show_ip_bgp_community_info_cmd,\n       \"show ip bgp community-info\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"List all bgp community information\\n\")\n{\n  vty_out (vty, \"Address Refcnt Community%s\", VTY_NEWLINE);\n\n  hash_iterate (community_hash (), \n\t\t(void (*) (struct hash_backet *, void *))\n\t\tcommunity_show_all_iterator,\n\t\tvty);\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (show_ip_bgp_attr_info, \n       show_ip_bgp_attr_info_cmd,\n       \"show ip bgp attribute-info\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"List all bgp attribute information\\n\")\n{\n  attr_show_all (vty);\n  return CMD_SUCCESS;\n}\n\f\nstatic int\nbgp_write_rsclient_summary (struct vty *vty, struct peer *rsclient,\n        afi_t afi, safi_t safi)\n{\n  char timebuf[BGP_UPTIME_LEN];\n  char rmbuf[14];\n  const char *rmname;\n  struct peer *peer;\n  struct listnode *node, *nnode;\n  int len;\n  int count = 0;\n\n  if (CHECK_FLAG (rsclient->sflags, PEER_STATUS_GROUP))\n    {\n      for (ALL_LIST_ELEMENTS (rsclient->group->peer, node, nnode, peer))\n        {\n          count++;\n          bgp_write_rsclient_summary (vty, peer, afi, safi);\n        }\n      return count;\n    }\n\n  len = vty_out (vty, \"%s\", rsclient->host);\n  len = 16 - len;\n\n  if (len < 1)\n    vty_out (vty, \"%s%*s\", VTY_NEWLINE, 16, \" \");\n  else\n    vty_out (vty, \"%*s\", len, \" \");\n\n  vty_out (vty, \"4 \");\n\n  vty_out (vty, \"%5d \", rsclient->as);\n\n  rmname = ROUTE_MAP_EXPORT_NAME(&rsclient->filter[afi][safi]);\n  if ( rmname && strlen (rmname) > 13 )\n    {\n      sprintf (rmbuf, \"%13s\", \"...\");\n      rmname = strncpy (rmbuf, rmname, 10);\n    }\n  else if (! rmname)\n    rmname = \"<none>\";\n  vty_out (vty, \" %13s \", rmname);\n\n  rmname = ROUTE_MAP_IMPORT_NAME(&rsclient->filter[afi][safi]);\n  if ( rmname && strlen (rmname) > 13 )\n    {\n      sprintf (rmbuf, \"%13s\", \"...\");\n      rmname = strncpy (rmbuf, rmname, 10);\n    }\n  else if (! rmname)\n    rmname = \"<none>\";\n  vty_out (vty, \" %13s \", rmname);\n\n  vty_out (vty, \"%8s\", peer_uptime (rsclient->uptime, timebuf, BGP_UPTIME_LEN));\n\n  if (CHECK_FLAG (rsclient->flags, PEER_FLAG_SHUTDOWN))\n    vty_out (vty, \" Idle (Admin)\");\n  else if (CHECK_FLAG (rsclient->sflags, PEER_STATUS_PREFIX_OVERFLOW))\n    vty_out (vty, \" Idle (PfxCt)\");\n  else\n    vty_out (vty, \" %-11s\", LOOKUP(bgp_status_msg, rsclient->status));\n\n  vty_out (vty, \"%s\", VTY_NEWLINE);\n\n  return 1;\n}\n\nstatic int\nbgp_show_rsclient_summary (struct vty *vty, struct bgp *bgp, \n                           afi_t afi, safi_t safi)\n{\n  struct peer *peer;\n  struct listnode *node, *nnode;\n  int count = 0;\n\n  /* Header string for each address family. */\n  static char header[] = \"Neighbor        V    AS  Export-Policy  Import-Policy  Up/Down  State\";\n\n  for (ALL_LIST_ELEMENTS (bgp->rsclient, node, nnode, peer))\n    {\n      if (peer->afc[afi][safi] &&\n         CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_RSERVER_CLIENT))\n       {\n         if (! count)\n           {\n             vty_out (vty,\n                      \"Route Server's BGP router identifier %s%s\",\n                      inet_ntoa (bgp->router_id), VTY_NEWLINE);\n             vty_out (vty,\n              \"Route Server's local AS number %d%s\", bgp->as,\n                       VTY_NEWLINE);\n\n             vty_out (vty, \"%s\", VTY_NEWLINE);\n             vty_out (vty, \"%s%s\", header, VTY_NEWLINE);\n           }\n\n         count += bgp_write_rsclient_summary (vty, peer, afi, safi);\n       }\n    }\n\n  if (count)\n    vty_out (vty, \"%sTotal number of Route Server Clients %d%s\", VTY_NEWLINE,\n            count, VTY_NEWLINE);\n  else\n    vty_out (vty, \"No %s Route Server Client is configured%s\",\n            afi == AFI_IP ? \"IPv4\" : \"IPv6\", VTY_NEWLINE);\n\n  return CMD_SUCCESS;\n}\n\nstatic int\nbgp_show_rsclient_summary_vty (struct vty *vty, const char *name, \n                               afi_t afi, safi_t safi)\n{\n  struct bgp *bgp;\n\n  if (name)\n    {\n      bgp = bgp_lookup_by_name (name);\n\n      if (! bgp)\n       {\n         vty_out (vty, \"%% No such BGP instance exist%s\", VTY_NEWLINE);\n         return CMD_WARNING;\n       }\n\n      bgp_show_rsclient_summary (vty, bgp, afi, safi);\n      return CMD_SUCCESS;\n    }\n\n  bgp = bgp_get_default ();\n\n  if (bgp)\n    bgp_show_rsclient_summary (vty, bgp, afi, safi);\n\n  return CMD_SUCCESS;\n}\n\n/* 'show bgp rsclient' commands. */\nDEFUN (show_ip_bgp_rsclient_summary,\n       show_ip_bgp_rsclient_summary_cmd,\n       \"show ip bgp rsclient summary\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"Information about Route Server Clients\\n\"\n       \"Summary of all Route Server Clients\\n\")\n{\n  return bgp_show_rsclient_summary_vty (vty, NULL, AFI_IP, SAFI_UNICAST);\n}\n\nDEFUN (show_ip_bgp_instance_rsclient_summary,\n       show_ip_bgp_instance_rsclient_summary_cmd,\n       \"show ip bgp view WORD rsclient summary\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"View name\\n\"\n       \"Information about Route Server Clients\\n\"\n       \"Summary of all Route Server Clients\\n\")\n{\n  return bgp_show_rsclient_summary_vty (vty, argv[0], AFI_IP, SAFI_UNICAST);\n}\n\nDEFUN (show_ip_bgp_ipv4_rsclient_summary,\n      show_ip_bgp_ipv4_rsclient_summary_cmd,\n      \"show ip bgp ipv4 (unicast|multicast) rsclient summary\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Information about Route Server Clients\\n\"\n       \"Summary of all Route Server Clients\\n\")\n{\n  if (strncmp (argv[0], \"m\", 1) == 0)\n    return bgp_show_rsclient_summary_vty (vty, NULL, AFI_IP, SAFI_MULTICAST);\n\n  return bgp_show_rsclient_summary_vty (vty, NULL, AFI_IP, SAFI_UNICAST);\n}\n\nDEFUN (show_ip_bgp_instance_ipv4_rsclient_summary,\n      show_ip_bgp_instance_ipv4_rsclient_summary_cmd,\n      \"show ip bgp view WORD ipv4 (unicast|multicast) rsclient summary\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"View name\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Information about Route Server Clients\\n\"\n       \"Summary of all Route Server Clients\\n\")\n{\n  if (strncmp (argv[1], \"m\", 1) == 0)\n    return bgp_show_rsclient_summary_vty (vty, argv[0], AFI_IP, SAFI_MULTICAST);\n\n  return bgp_show_rsclient_summary_vty (vty, argv[0], AFI_IP, SAFI_UNICAST);\n}\n\n#ifdef HAVE_IPV6\nDEFUN (show_bgp_rsclient_summary,\n       show_bgp_rsclient_summary_cmd,\n       \"show bgp rsclient summary\",\n       SHOW_STR\n       BGP_STR\n       \"Information about Route Server Clients\\n\"\n       \"Summary of all Route Server Clients\\n\")\n{\n  return bgp_show_rsclient_summary_vty (vty, NULL, AFI_IP6, SAFI_UNICAST);\n}\n\nDEFUN (show_bgp_instance_rsclient_summary,\n       show_bgp_instance_rsclient_summary_cmd,\n       \"show bgp view WORD rsclient summary\",\n       SHOW_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"View name\\n\"\n       \"Information about Route Server Clients\\n\"\n       \"Summary of all Route Server Clients\\n\")\n{\n  return bgp_show_rsclient_summary_vty (vty, argv[0], AFI_IP6, SAFI_UNICAST);\n}\n\nALIAS (show_bgp_rsclient_summary,\n      show_bgp_ipv6_rsclient_summary_cmd,\n      \"show bgp ipv6 rsclient summary\",\n       SHOW_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Information about Route Server Clients\\n\"\n       \"Summary of all Route Server Clients\\n\")\n\nALIAS (show_bgp_instance_rsclient_summary,\n      show_bgp_instance_ipv6_rsclient_summary_cmd,\n       \"show bgp view WORD ipv6 rsclient summary\",\n       SHOW_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"View name\\n\"\n       \"Address family\\n\"\n       \"Information about Route Server Clients\\n\"\n       \"Summary of all Route Server Clients\\n\")\n#endif /* HAVE IPV6 */\n\f\n/* Redistribute VTY commands.  */\n\n/* Utility function to convert user input route type string to route\n   type.  */\nstatic int\nbgp_str2route_type (int afi, const char *str)\n{\n  if (! str)\n    return 0;\n\n  if (afi == AFI_IP)\n    {\n      if (strncmp (str, \"k\", 1) == 0)\n\treturn ZEBRA_ROUTE_KERNEL;\n      else if (strncmp (str, \"c\", 1) == 0)\n\treturn ZEBRA_ROUTE_CONNECT;\n      else if (strncmp (str, \"s\", 1) == 0)\n\treturn ZEBRA_ROUTE_STATIC;\n      else if (strncmp (str, \"r\", 1) == 0)\n\treturn ZEBRA_ROUTE_RIP;\n      else if (strncmp (str, \"o\", 1) == 0)\n\treturn ZEBRA_ROUTE_OSPF;\n    }\n  if (afi == AFI_IP6)\n    {\n      if (strncmp (str, \"k\", 1) == 0)\n\treturn ZEBRA_ROUTE_KERNEL;\n      else if (strncmp (str, \"c\", 1) == 0)\n\treturn ZEBRA_ROUTE_CONNECT;\n      else if (strncmp (str, \"s\", 1) == 0)\n\treturn ZEBRA_ROUTE_STATIC;\n      else if (strncmp (str, \"r\", 1) == 0)\n\treturn ZEBRA_ROUTE_RIPNG;\n      else if (strncmp (str, \"o\", 1) == 0)\n\treturn ZEBRA_ROUTE_OSPF6;\n    }\n  return 0;\n}\n\nDEFUN (bgp_redistribute_ipv4,\n       bgp_redistribute_ipv4_cmd,\n       \"redistribute (connected|kernel|ospf|rip|static)\",\n       \"Redistribute information from another routing protocol\\n\"\n       \"Connected\\n\"\n       \"Kernel routes\\n\"\n       \"Open Shurtest Path First (OSPF)\\n\"\n       \"Routing Information Protocol (RIP)\\n\"\n       \"Static routes\\n\")\n{\n  int type;\n\n  type = bgp_str2route_type (AFI_IP, argv[0]);\n  if (! type)\n    {\n      vty_out (vty, \"%% Invalid route type%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n  return bgp_redistribute_set (vty->index, AFI_IP, type);\n}\n\nDEFUN (bgp_redistribute_ipv4_rmap,\n       bgp_redistribute_ipv4_rmap_cmd,\n       \"redistribute (connected|kernel|ospf|rip|static) route-map WORD\",\n       \"Redistribute information from another routing protocol\\n\"\n       \"Connected\\n\"\n       \"Kernel routes\\n\"\n       \"Open Shurtest Path First (OSPF)\\n\"\n       \"Routing Information Protocol (RIP)\\n\"\n       \"Static routes\\n\"\n       \"Route map reference\\n\"\n       \"Pointer to route-map entries\\n\")\n{\n  int type;\n\n  type = bgp_str2route_type (AFI_IP, argv[0]);\n  if (! type)\n    {\n      vty_out (vty, \"%% Invalid route type%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  bgp_redistribute_rmap_set (vty->index, AFI_IP, type, argv[1]);\n  return bgp_redistribute_set (vty->index, AFI_IP, type);\n}\n\nDEFUN (bgp_redistribute_ipv4_metric,\n       bgp_redistribute_ipv4_metric_cmd,\n       \"redistribute (connected|kernel|ospf|rip|static) metric <0-4294967295>\",\n       \"Redistribute information from another routing protocol\\n\"\n       \"Connected\\n\"\n       \"Kernel routes\\n\"\n       \"Open Shurtest Path First (OSPF)\\n\"\n       \"Routing Information Protocol (RIP)\\n\"\n       \"Static routes\\n\"\n       \"Metric for redistributed routes\\n\"\n       \"Default metric\\n\")\n{\n  int type;\n  u_int32_t metric;\n\n  type = bgp_str2route_type (AFI_IP, argv[0]);\n  if (! type)\n    {\n      vty_out (vty, \"%% Invalid route type%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n  VTY_GET_INTEGER (\"metric\", metric, argv[1]);\n\n  bgp_redistribute_metric_set (vty->index, AFI_IP, type, metric);\n  return bgp_redistribute_set (vty->index, AFI_IP, type);\n}\n\nDEFUN (bgp_redistribute_ipv4_rmap_metric,\n       bgp_redistribute_ipv4_rmap_metric_cmd,\n       \"redistribute (connected|kernel|ospf|rip|static) route-map WORD metric <0-4294967295>\",\n       \"Redistribute information from another routing protocol\\n\"\n       \"Connected\\n\"\n       \"Kernel routes\\n\"\n       \"Open Shurtest Path First (OSPF)\\n\"\n       \"Routing Information Protocol (RIP)\\n\"\n       \"Static routes\\n\"\n       \"Route map reference\\n\"\n       \"Pointer to route-map entries\\n\"\n       \"Metric for redistributed routes\\n\"\n       \"Default metric\\n\")\n{\n  int type;\n  u_int32_t metric;\n\n  type = bgp_str2route_type (AFI_IP, argv[0]);\n  if (! type)\n    {\n      vty_out (vty, \"%% Invalid route type%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n  VTY_GET_INTEGER (\"metric\", metric, argv[2]);\n\n  bgp_redistribute_rmap_set (vty->index, AFI_IP, type, argv[1]);\n  bgp_redistribute_metric_set (vty->index, AFI_IP, type, metric);\n  return bgp_redistribute_set (vty->index, AFI_IP, type);\n}\n\nDEFUN (bgp_redistribute_ipv4_metric_rmap,\n       bgp_redistribute_ipv4_metric_rmap_cmd,\n       \"redistribute (connected|kernel|ospf|rip|static) metric <0-4294967295> route-map WORD\",\n       \"Redistribute information from another routing protocol\\n\"\n       \"Connected\\n\"\n       \"Kernel routes\\n\"\n       \"Open Shurtest Path First (OSPF)\\n\"\n       \"Routing Information Protocol (RIP)\\n\"\n       \"Static routes\\n\"\n       \"Metric for redistributed routes\\n\"\n       \"Default metric\\n\"\n       \"Route map reference\\n\"\n       \"Pointer to route-map entries\\n\")\n{\n  int type;\n  u_int32_t metric;\n\n  type = bgp_str2route_type (AFI_IP, argv[0]);\n  if (! type)\n    {\n      vty_out (vty, \"%% Invalid route type%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n  VTY_GET_INTEGER (\"metric\", metric, argv[1]);\n\n  bgp_redistribute_metric_set (vty->index, AFI_IP, type, metric);\n  bgp_redistribute_rmap_set (vty->index, AFI_IP, type, argv[2]);\n  return bgp_redistribute_set (vty->index, AFI_IP, type);\n}\n\nDEFUN (no_bgp_redistribute_ipv4,\n       no_bgp_redistribute_ipv4_cmd,\n       \"no redistribute (connected|kernel|ospf|rip|static)\",\n       NO_STR\n       \"Redistribute information from another routing protocol\\n\"\n       \"Connected\\n\"\n       \"Kernel routes\\n\"\n       \"Open Shurtest Path First (OSPF)\\n\"\n       \"Routing Information Protocol (RIP)\\n\"\n       \"Static routes\\n\")\n{\n  int type;\n\n  type = bgp_str2route_type (AFI_IP, argv[0]);\n  if (! type)\n    {\n      vty_out (vty, \"%% Invalid route type%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  return bgp_redistribute_unset (vty->index, AFI_IP, type);\n}\n\nDEFUN (no_bgp_redistribute_ipv4_rmap,\n       no_bgp_redistribute_ipv4_rmap_cmd,\n       \"no redistribute (connected|kernel|ospf|rip|static) route-map WORD\",\n       NO_STR\n       \"Redistribute information from another routing protocol\\n\"\n       \"Connected\\n\"\n       \"Kernel routes\\n\"\n       \"Open Shurtest Path First (OSPF)\\n\"\n       \"Routing Information Protocol (RIP)\\n\"\n       \"Static routes\\n\"\n       \"Route map reference\\n\"\n       \"Pointer to route-map entries\\n\")\n{\n  int type;\n\n  type = bgp_str2route_type (AFI_IP, argv[0]);\n  if (! type)\n    {\n      vty_out (vty, \"%% Invalid route type%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  bgp_redistribute_routemap_unset (vty->index, AFI_IP, type);\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_bgp_redistribute_ipv4_metric,\n       no_bgp_redistribute_ipv4_metric_cmd,\n       \"no redistribute (connected|kernel|ospf|rip|static) metric <0-4294967295>\",\n       NO_STR\n       \"Redistribute information from another routing protocol\\n\"\n       \"Connected\\n\"\n       \"Kernel routes\\n\"\n       \"Open Shurtest Path First (OSPF)\\n\"\n       \"Routing Information Protocol (RIP)\\n\"\n       \"Static routes\\n\"\n       \"Metric for redistributed routes\\n\"\n       \"Default metric\\n\")\n{\n  int type;\n\n  type = bgp_str2route_type (AFI_IP, argv[0]);\n  if (! type)\n    {\n      vty_out (vty, \"%% Invalid route type%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  bgp_redistribute_metric_unset (vty->index, AFI_IP, type);\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_bgp_redistribute_ipv4_rmap_metric,\n       no_bgp_redistribute_ipv4_rmap_metric_cmd,\n       \"no redistribute (connected|kernel|ospf|rip|static) route-map WORD metric <0-4294967295>\",\n       NO_STR\n       \"Redistribute information from another routing protocol\\n\"\n       \"Connected\\n\"\n       \"Kernel routes\\n\"\n       \"Open Shurtest Path First (OSPF)\\n\"\n       \"Routing Information Protocol (RIP)\\n\"\n       \"Static routes\\n\"\n       \"Route map reference\\n\"\n       \"Pointer to route-map entries\\n\"\n       \"Metric for redistributed routes\\n\"\n       \"Default metric\\n\")\n{\n  int type;\n\n  type = bgp_str2route_type (AFI_IP, argv[0]);\n  if (! type)\n    {\n      vty_out (vty, \"%% Invalid route type%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  bgp_redistribute_metric_unset (vty->index, AFI_IP, type);\n  bgp_redistribute_routemap_unset (vty->index, AFI_IP, type);\n  return CMD_SUCCESS;\n}\n\nALIAS (no_bgp_redistribute_ipv4_rmap_metric,\n       no_bgp_redistribute_ipv4_metric_rmap_cmd,\n       \"no redistribute (connected|kernel|ospf|rip|static) metric <0-4294967295> route-map WORD\",\n       NO_STR\n       \"Redistribute information from another routing protocol\\n\"\n       \"Connected\\n\"\n       \"Kernel routes\\n\"\n       \"Open Shurtest Path First (OSPF)\\n\"\n       \"Routing Information Protocol (RIP)\\n\"\n       \"Static routes\\n\"\n       \"Metric for redistributed routes\\n\"\n       \"Default metric\\n\"\n       \"Route map reference\\n\"\n       \"Pointer to route-map entries\\n\")\n\f\n#ifdef HAVE_IPV6\nDEFUN (bgp_redistribute_ipv6,\n       bgp_redistribute_ipv6_cmd,\n       \"redistribute (connected|kernel|ospf6|ripng|static)\",\n       \"Redistribute information from another routing protocol\\n\"\n       \"Connected\\n\"\n       \"Kernel routes\\n\"\n       \"Open Shurtest Path First (OSPFv3)\\n\"\n       \"Routing Information Protocol (RIPng)\\n\"\n       \"Static routes\\n\")\n{\n  int type;\n\n  type = bgp_str2route_type (AFI_IP6, argv[0]);\n  if (! type)\n    {\n      vty_out (vty, \"%% Invalid route type%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  return bgp_redistribute_set (vty->index, AFI_IP6, type);\n}\n\nDEFUN (bgp_redistribute_ipv6_rmap,\n       bgp_redistribute_ipv6_rmap_cmd,\n       \"redistribute (connected|kernel|ospf6|ripng|static) route-map WORD\",\n       \"Redistribute information from another routing protocol\\n\"\n       \"Connected\\n\"\n       \"Kernel routes\\n\"\n       \"Open Shurtest Path First (OSPFv3)\\n\"\n       \"Routing Information Protocol (RIPng)\\n\"\n       \"Static routes\\n\"\n       \"Route map reference\\n\"\n       \"Pointer to route-map entries\\n\")\n{\n  int type;\n\n  type = bgp_str2route_type (AFI_IP6, argv[0]);\n  if (! type)\n    {\n      vty_out (vty, \"%% Invalid route type%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  bgp_redistribute_rmap_set (vty->index, AFI_IP6, type, argv[1]);\n  return bgp_redistribute_set (vty->index, AFI_IP6, type);\n}\n\nDEFUN (bgp_redistribute_ipv6_metric,\n       bgp_redistribute_ipv6_metric_cmd,\n       \"redistribute (connected|kernel|ospf6|ripng|static) metric <0-4294967295>\",\n       \"Redistribute information from another routing protocol\\n\"\n       \"Connected\\n\"\n       \"Kernel routes\\n\"\n       \"Open Shurtest Path First (OSPFv3)\\n\"\n       \"Routing Information Protocol (RIPng)\\n\"\n       \"Static routes\\n\"\n       \"Metric for redistributed routes\\n\"\n       \"Default metric\\n\")\n{\n  int type;\n  u_int32_t metric;\n\n  type = bgp_str2route_type (AFI_IP6, argv[0]);\n  if (! type)\n    {\n      vty_out (vty, \"%% Invalid route type%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n  VTY_GET_INTEGER (\"metric\", metric, argv[1]);\n\n  bgp_redistribute_metric_set (vty->index, AFI_IP6, type, metric);\n  return bgp_redistribute_set (vty->index, AFI_IP6, type);\n}\n\nDEFUN (bgp_redistribute_ipv6_rmap_metric,\n       bgp_redistribute_ipv6_rmap_metric_cmd,\n       \"redistribute (connected|kernel|ospf6|ripng|static) route-map WORD metric <0-4294967295>\",\n       \"Redistribute information from another routing protocol\\n\"\n       \"Connected\\n\"\n       \"Kernel routes\\n\"\n       \"Open Shurtest Path First (OSPFv3)\\n\"\n       \"Routing Information Protocol (RIPng)\\n\"\n       \"Static routes\\n\"\n       \"Route map reference\\n\"\n       \"Pointer to route-map entries\\n\"\n       \"Metric for redistributed routes\\n\"\n       \"Default metric\\n\")\n{\n  int type;\n  u_int32_t metric;\n\n  type = bgp_str2route_type (AFI_IP6, argv[0]);\n  if (! type)\n    {\n      vty_out (vty, \"%% Invalid route type%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n  VTY_GET_INTEGER (\"metric\", metric, argv[2]);\n\n  bgp_redistribute_rmap_set (vty->index, AFI_IP6, type, argv[1]);\n  bgp_redistribute_metric_set (vty->index, AFI_IP6, type, metric);\n  return bgp_redistribute_set (vty->index, AFI_IP6, type);\n}\n\nDEFUN (bgp_redistribute_ipv6_metric_rmap,\n       bgp_redistribute_ipv6_metric_rmap_cmd,\n       \"redistribute (connected|kernel|ospf6|ripng|static) metric <0-4294967295> route-map WORD\",\n       \"Redistribute information from another routing protocol\\n\"\n       \"Connected\\n\"\n       \"Kernel routes\\n\"\n       \"Open Shurtest Path First (OSPFv3)\\n\"\n       \"Routing Information Protocol (RIPng)\\n\"\n       \"Static routes\\n\"\n       \"Metric for redistributed routes\\n\"\n       \"Default metric\\n\"\n       \"Route map reference\\n\"\n       \"Pointer to route-map entries\\n\")\n{\n  int type;\n  u_int32_t metric;\n\n  type = bgp_str2route_type (AFI_IP6, argv[0]);\n  if (! type)\n    {\n      vty_out (vty, \"%% Invalid route type%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n  VTY_GET_INTEGER (\"metric\", metric, argv[1]);\n\n  bgp_redistribute_metric_set (vty->index, AFI_IP6, type, metric);\n  bgp_redistribute_rmap_set (vty->index, AFI_IP6, type, argv[2]);\n  return bgp_redistribute_set (vty->index, AFI_IP6, type);\n}\n\nDEFUN (no_bgp_redistribute_ipv6,\n       no_bgp_redistribute_ipv6_cmd,\n       \"no redistribute (connected|kernel|ospf6|ripng|static)\",\n       NO_STR\n       \"Redistribute information from another routing protocol\\n\"\n       \"Connected\\n\"\n       \"Kernel routes\\n\"\n       \"Open Shurtest Path First (OSPFv3)\\n\"\n       \"Routing Information Protocol (RIPng)\\n\"\n       \"Static routes\\n\")\n{\n  int type;\n\n  type = bgp_str2route_type (AFI_IP6, argv[0]);\n  if (! type)\n    {\n      vty_out (vty, \"%% Invalid route type%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  return bgp_redistribute_unset (vty->index, AFI_IP6, type);\n}\n\nDEFUN (no_bgp_redistribute_ipv6_rmap,\n       no_bgp_redistribute_ipv6_rmap_cmd,\n       \"no redistribute (connected|kernel|ospf6|ripng|static) route-map WORD\",\n       NO_STR\n       \"Redistribute information from another routing protocol\\n\"\n       \"Connected\\n\"\n       \"Kernel routes\\n\"\n       \"Open Shurtest Path First (OSPFv3)\\n\"\n       \"Routing Information Protocol (RIPng)\\n\"\n       \"Static routes\\n\"\n       \"Route map reference\\n\"\n       \"Pointer to route-map entries\\n\")\n{\n  int type;\n\n  type = bgp_str2route_type (AFI_IP6, argv[0]);\n  if (! type)\n    {\n      vty_out (vty, \"%% Invalid route type%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  bgp_redistribute_routemap_unset (vty->index, AFI_IP6, type);\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_bgp_redistribute_ipv6_metric,\n       no_bgp_redistribute_ipv6_metric_cmd,\n       \"no redistribute (connected|kernel|ospf6|ripng|static) metric <0-4294967295>\",\n       NO_STR\n       \"Redistribute information from another routing protocol\\n\"\n       \"Connected\\n\"\n       \"Kernel routes\\n\"\n       \"Open Shurtest Path First (OSPFv3)\\n\"\n       \"Routing Information Protocol (RIPng)\\n\"\n       \"Static routes\\n\"\n       \"Metric for redistributed routes\\n\"\n       \"Default metric\\n\")\n{\n  int type;\n\n  type = bgp_str2route_type (AFI_IP6, argv[0]);\n  if (! type)\n    {\n      vty_out (vty, \"%% Invalid route type%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  bgp_redistribute_metric_unset (vty->index, AFI_IP6, type);\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_bgp_redistribute_ipv6_rmap_metric,\n       no_bgp_redistribute_ipv6_rmap_metric_cmd,\n       \"no redistribute (connected|kernel|ospf6|ripng|static) route-map WORD metric <0-4294967295>\",\n       NO_STR\n       \"Redistribute information from another routing protocol\\n\"\n       \"Connected\\n\"\n       \"Kernel routes\\n\"\n       \"Open Shurtest Path First (OSPFv3)\\n\"\n       \"Routing Information Protocol (RIPng)\\n\"\n       \"Static routes\\n\"\n       \"Route map reference\\n\"\n       \"Pointer to route-map entries\\n\"\n       \"Metric for redistributed routes\\n\"\n       \"Default metric\\n\")\n{\n  int type;\n\n  type = bgp_str2route_type (AFI_IP6, argv[0]);\n  if (! type)\n    {\n      vty_out (vty, \"%% Invalid route type%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  bgp_redistribute_metric_unset (vty->index, AFI_IP6, type);\n  bgp_redistribute_routemap_unset (vty->index, AFI_IP6, type);\n  return CMD_SUCCESS;\n}\n\nALIAS (no_bgp_redistribute_ipv6_rmap_metric,\n       no_bgp_redistribute_ipv6_metric_rmap_cmd,\n       \"no redistribute (connected|kernel|ospf6|ripng|static) metric <0-4294967295> route-map WORD\",\n       NO_STR\n       \"Redistribute information from another routing protocol\\n\"\n       \"Connected\\n\"\n       \"Kernel routes\\n\"\n       \"Open Shurtest Path First (OSPFv3)\\n\"\n       \"Routing Information Protocol (RIPng)\\n\"\n       \"Static routes\\n\"\n       \"Metric for redistributed routes\\n\"\n       \"Default metric\\n\"\n       \"Route map reference\\n\"\n       \"Pointer to route-map entries\\n\")\n#endif /* HAVE_IPV6 */\n\f\nint\nbgp_config_write_redistribute (struct vty *vty, struct bgp *bgp, afi_t afi,\n\t\t\t       safi_t safi, int *write)\n{\n  int i;\n\n  /* Unicast redistribution only.  */\n  if (safi != SAFI_UNICAST)\n    return 0;\n\n  for (i = 0; i < ZEBRA_ROUTE_MAX; i++)\n    {\n      /* Redistribute BGP does not make sense.  */\n      if (bgp->redist[afi][i] && i != ZEBRA_ROUTE_BGP)\n\t{\n\t  /* Display \"address-family\" when it is not yet diplayed.  */\n\t  bgp_config_write_family_header (vty, afi, safi, write);\n\n\t  /* \"redistribute\" configuration.  */\n\t  vty_out (vty, \" redistribute %s\", zebra_route_string(i));\n\n\t  if (bgp->redist_metric_flag[afi][i])\n\t    vty_out (vty, \" metric %d\", bgp->redist_metric[afi][i]);\n\n\t  if (bgp->rmap[afi][i].name)\n\t    vty_out (vty, \" route-map %s\", bgp->rmap[afi][i].name);\n\n\t  vty_out (vty, \"%s\", VTY_NEWLINE);\n\t}\n    }\n  return *write;\n}\n\f\n/* BGP node structure. */\nstruct cmd_node bgp_node =\n{\n  BGP_NODE,\n  \"%s(config-router)# \",\n  1,\n};\n\nstruct cmd_node bgp_ipv4_unicast_node =\n{\n  BGP_IPV4_NODE,\n  \"%s(config-router-af)# \",\n  1,\n};\n\nstruct cmd_node bgp_ipv4_multicast_node =\n{\n  BGP_IPV4M_NODE,\n  \"%s(config-router-af)# \",\n  1,\n};\n\nstruct cmd_node bgp_ipv6_unicast_node = \n{\n  BGP_IPV6_NODE,\n  \"%s(config-router-af)# \",\n  1,\n};\n\nstruct cmd_node bgp_ipv6_multicast_node =\n{\n  BGP_IPV6M_NODE,\n  \"%s(config-router-af)# \",\n  1,\n};\n\nstruct cmd_node bgp_vpnv4_node =\n{\n  BGP_VPNV4_NODE,\n  \"%s(config-router-af)# \",\n  1\n};\n\f\nstatic void community_list_vty (void);\n\nvoid\nbgp_vty_init (void)\n{\n  /* Install bgp top node. */\n  install_node (&bgp_node, bgp_config_write);\n  install_node (&bgp_ipv4_unicast_node, NULL);\n  install_node (&bgp_ipv4_multicast_node, NULL);\n  install_node (&bgp_ipv6_unicast_node, NULL);\n  install_node (&bgp_ipv6_multicast_node, NULL);\n  install_node (&bgp_vpnv4_node, NULL);\n\n  /* Install default VTY commands to new nodes.  */\n  install_default (BGP_NODE);\n  install_default (BGP_IPV4_NODE);\n  install_default (BGP_IPV4M_NODE);\n  install_default (BGP_IPV6_NODE);\n  install_default (BGP_IPV6M_NODE);\n  install_default (BGP_VPNV4_NODE);\n  \n  /* \"bgp multiple-instance\" commands. */\n  install_element (CONFIG_NODE, &bgp_multiple_instance_cmd);\n  install_element (CONFIG_NODE, &no_bgp_multiple_instance_cmd);\n\n  /* \"bgp config-type\" commands. */\n  install_element (CONFIG_NODE, &bgp_config_type_cmd);\n  install_element (CONFIG_NODE, &no_bgp_config_type_cmd);\n\n  /* Dummy commands (Currently not supported) */\n  install_element (BGP_NODE, &no_synchronization_cmd);\n  install_element (BGP_NODE, &no_auto_summary_cmd);\n\n  /* \"router bgp\" commands. */\n  install_element (CONFIG_NODE, &router_bgp_cmd);\n  install_element (CONFIG_NODE, &router_bgp_view_cmd);\n\n  /* \"no router bgp\" commands. */\n  install_element (CONFIG_NODE, &no_router_bgp_cmd);\n  install_element (CONFIG_NODE, &no_router_bgp_view_cmd);\n\n  /* \"bgp router-id\" commands. */\n  install_element (BGP_NODE, &bgp_router_id_cmd);\n  install_element (BGP_NODE, &no_bgp_router_id_cmd);\n  install_element (BGP_NODE, &no_bgp_router_id_val_cmd);\n\n  /* \"bgp cluster-id\" commands. */\n  install_element (BGP_NODE, &bgp_cluster_id_cmd);\n  install_element (BGP_NODE, &bgp_cluster_id32_cmd);\n  install_element (BGP_NODE, &no_bgp_cluster_id_cmd);\n  install_element (BGP_NODE, &no_bgp_cluster_id_arg_cmd);\n\n  /* \"bgp confederation\" commands. */\n  install_element (BGP_NODE, &bgp_confederation_identifier_cmd);\n  install_element (BGP_NODE, &no_bgp_confederation_identifier_cmd);\n  install_element (BGP_NODE, &no_bgp_confederation_identifier_arg_cmd);\n\n  /* \"bgp confederation peers\" commands. */\n  install_element (BGP_NODE, &bgp_confederation_peers_cmd);\n  install_element (BGP_NODE, &no_bgp_confederation_peers_cmd);\n\n  /* \"timers bgp\" commands. */\n  install_element (BGP_NODE, &bgp_timers_cmd);\n  install_element (BGP_NODE, &no_bgp_timers_cmd);\n  install_element (BGP_NODE, &no_bgp_timers_arg_cmd);\n\n  /* \"bgp client-to-client reflection\" commands */\n  install_element (BGP_NODE, &no_bgp_client_to_client_reflection_cmd);\n  install_element (BGP_NODE, &bgp_client_to_client_reflection_cmd);\n\n  /* \"bgp always-compare-med\" commands */\n  install_element (BGP_NODE, &bgp_always_compare_med_cmd);\n  install_element (BGP_NODE, &no_bgp_always_compare_med_cmd);\n  \n  /* \"bgp deterministic-med\" commands */\n  install_element (BGP_NODE, &bgp_deterministic_med_cmd);\n  install_element (BGP_NODE, &no_bgp_deterministic_med_cmd);\n\n  /* \"bgp graceful-restart\" commands */\n  install_element (BGP_NODE, &bgp_graceful_restart_cmd);\n  install_element (BGP_NODE, &no_bgp_graceful_restart_cmd);\n  install_element (BGP_NODE, &bgp_graceful_restart_stalepath_time_cmd);\n  install_element (BGP_NODE, &no_bgp_graceful_restart_stalepath_time_cmd);\n  install_element (BGP_NODE, &no_bgp_graceful_restart_stalepath_time_val_cmd);\n \n  /* \"bgp fast-external-failover\" commands */\n  install_element (BGP_NODE, &bgp_fast_external_failover_cmd);\n  install_element (BGP_NODE, &no_bgp_fast_external_failover_cmd);\n\n  /* \"bgp enforce-first-as\" commands */\n  install_element (BGP_NODE, &bgp_enforce_first_as_cmd);\n  install_element (BGP_NODE, &no_bgp_enforce_first_as_cmd);\n\n  /* \"bgp bestpath compare-routerid\" commands */\n  install_element (BGP_NODE, &bgp_bestpath_compare_router_id_cmd);\n  install_element (BGP_NODE, &no_bgp_bestpath_compare_router_id_cmd);\n\n  /* \"bgp bestpath as-path ignore\" commands */\n  install_element (BGP_NODE, &bgp_bestpath_aspath_ignore_cmd);\n  install_element (BGP_NODE, &no_bgp_bestpath_aspath_ignore_cmd);\n\n  /* \"bgp bestpath as-path confed\" commands */\n  install_element (BGP_NODE, &bgp_bestpath_aspath_confed_cmd);\n  install_element (BGP_NODE, &no_bgp_bestpath_aspath_confed_cmd);\n\n  /* \"bgp log-neighbor-changes\" commands */\n  install_element (BGP_NODE, &bgp_log_neighbor_changes_cmd);\n  install_element (BGP_NODE, &no_bgp_log_neighbor_changes_cmd);\n\n  /* \"bgp bestpath med\" commands */\n  install_element (BGP_NODE, &bgp_bestpath_med_cmd);\n  install_element (BGP_NODE, &bgp_bestpath_med2_cmd);\n  install_element (BGP_NODE, &bgp_bestpath_med3_cmd);\n  install_element (BGP_NODE, &no_bgp_bestpath_med_cmd);\n  install_element (BGP_NODE, &no_bgp_bestpath_med2_cmd);\n  install_element (BGP_NODE, &no_bgp_bestpath_med3_cmd);\n\n  /* \"no bgp default ipv4-unicast\" commands. */\n  install_element (BGP_NODE, &no_bgp_default_ipv4_unicast_cmd);\n  install_element (BGP_NODE, &bgp_default_ipv4_unicast_cmd);\n  \n  /* \"bgp network import-check\" commands. */\n  install_element (BGP_NODE, &bgp_network_import_check_cmd);\n  install_element (BGP_NODE, &no_bgp_network_import_check_cmd);\n\n  /* \"bgp default local-preference\" commands. */\n  install_element (BGP_NODE, &bgp_default_local_preference_cmd);\n  install_element (BGP_NODE, &no_bgp_default_local_preference_cmd);\n  install_element (BGP_NODE, &no_bgp_default_local_preference_val_cmd);\n\n  /* \"neighbor remote-as\" commands. */\n  install_element (BGP_NODE, &neighbor_remote_as_cmd);\n  install_element (BGP_NODE, &no_neighbor_cmd);\n  install_element (BGP_NODE, &no_neighbor_remote_as_cmd);\n\n  /* \"neighbor peer-group\" commands. */\n  install_element (BGP_NODE, &neighbor_peer_group_cmd);\n  install_element (BGP_NODE, &no_neighbor_peer_group_cmd);\n  install_element (BGP_NODE, &no_neighbor_peer_group_remote_as_cmd);\n\n  /* \"neighbor local-as\" commands. */\n  install_element (BGP_NODE, &neighbor_local_as_cmd);\n  install_element (BGP_NODE, &neighbor_local_as_no_prepend_cmd);\n  install_element (BGP_NODE, &no_neighbor_local_as_cmd);\n  install_element (BGP_NODE, &no_neighbor_local_as_val_cmd);\n  install_element (BGP_NODE, &no_neighbor_local_as_val2_cmd);\n\n  /* \"neighbor activate\" commands. */\n  install_element (BGP_NODE, &neighbor_activate_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_activate_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_activate_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_activate_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_activate_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_activate_cmd);\n\n  /* \"no neighbor activate\" commands. */\n  install_element (BGP_NODE, &no_neighbor_activate_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_activate_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_activate_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_activate_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_activate_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_activate_cmd);\n\n  /* \"neighbor peer-group set\" commands. */\n  install_element (BGP_NODE, &neighbor_set_peer_group_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_set_peer_group_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_set_peer_group_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_set_peer_group_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_set_peer_group_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_set_peer_group_cmd);\n  \n  /* \"no neighbor peer-group unset\" commands. */\n  install_element (BGP_NODE, &no_neighbor_set_peer_group_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_set_peer_group_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_set_peer_group_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_set_peer_group_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_set_peer_group_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_set_peer_group_cmd);\n  \n  /* \"neighbor softreconfiguration inbound\" commands.*/\n  install_element (BGP_NODE, &neighbor_soft_reconfiguration_cmd);\n  install_element (BGP_NODE, &no_neighbor_soft_reconfiguration_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_soft_reconfiguration_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_soft_reconfiguration_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_soft_reconfiguration_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_soft_reconfiguration_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_soft_reconfiguration_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_soft_reconfiguration_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_soft_reconfiguration_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_soft_reconfiguration_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_soft_reconfiguration_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_soft_reconfiguration_cmd);\n\n  /* \"neighbor attribute-unchanged\" commands.  */\n  install_element (BGP_NODE, &neighbor_attr_unchanged_cmd);\n  install_element (BGP_NODE, &neighbor_attr_unchanged1_cmd);\n  install_element (BGP_NODE, &neighbor_attr_unchanged2_cmd);\n  install_element (BGP_NODE, &neighbor_attr_unchanged3_cmd);\n  install_element (BGP_NODE, &neighbor_attr_unchanged4_cmd);\n  install_element (BGP_NODE, &neighbor_attr_unchanged5_cmd);\n  install_element (BGP_NODE, &neighbor_attr_unchanged6_cmd);\n  install_element (BGP_NODE, &neighbor_attr_unchanged7_cmd);\n  install_element (BGP_NODE, &neighbor_attr_unchanged8_cmd);\n  install_element (BGP_NODE, &neighbor_attr_unchanged9_cmd);\n  install_element (BGP_NODE, &neighbor_attr_unchanged10_cmd);\n  install_element (BGP_NODE, &no_neighbor_attr_unchanged_cmd);\n  install_element (BGP_NODE, &no_neighbor_attr_unchanged1_cmd);\n  install_element (BGP_NODE, &no_neighbor_attr_unchanged2_cmd);\n  install_element (BGP_NODE, &no_neighbor_attr_unchanged3_cmd);\n  install_element (BGP_NODE, &no_neighbor_attr_unchanged4_cmd);\n  install_element (BGP_NODE, &no_neighbor_attr_unchanged5_cmd);\n  install_element (BGP_NODE, &no_neighbor_attr_unchanged6_cmd);\n  install_element (BGP_NODE, &no_neighbor_attr_unchanged7_cmd);\n  install_element (BGP_NODE, &no_neighbor_attr_unchanged8_cmd);\n  install_element (BGP_NODE, &no_neighbor_attr_unchanged9_cmd);\n  install_element (BGP_NODE, &no_neighbor_attr_unchanged10_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_attr_unchanged_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_attr_unchanged1_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_attr_unchanged2_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_attr_unchanged3_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_attr_unchanged4_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_attr_unchanged5_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_attr_unchanged6_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_attr_unchanged7_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_attr_unchanged8_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_attr_unchanged9_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_attr_unchanged10_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_attr_unchanged_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_attr_unchanged1_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_attr_unchanged2_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_attr_unchanged3_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_attr_unchanged4_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_attr_unchanged5_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_attr_unchanged6_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_attr_unchanged7_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_attr_unchanged8_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_attr_unchanged9_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_attr_unchanged10_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_attr_unchanged_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_attr_unchanged1_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_attr_unchanged2_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_attr_unchanged3_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_attr_unchanged4_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_attr_unchanged5_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_attr_unchanged6_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_attr_unchanged7_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_attr_unchanged8_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_attr_unchanged9_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_attr_unchanged10_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_attr_unchanged_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_attr_unchanged1_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_attr_unchanged2_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_attr_unchanged3_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_attr_unchanged4_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_attr_unchanged5_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_attr_unchanged6_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_attr_unchanged7_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_attr_unchanged8_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_attr_unchanged9_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_attr_unchanged10_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_attr_unchanged_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_attr_unchanged1_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_attr_unchanged2_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_attr_unchanged3_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_attr_unchanged4_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_attr_unchanged5_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_attr_unchanged6_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_attr_unchanged7_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_attr_unchanged8_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_attr_unchanged9_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_attr_unchanged10_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_attr_unchanged_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_attr_unchanged1_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_attr_unchanged2_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_attr_unchanged3_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_attr_unchanged4_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_attr_unchanged5_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_attr_unchanged6_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_attr_unchanged7_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_attr_unchanged8_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_attr_unchanged9_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_attr_unchanged10_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_attr_unchanged_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_attr_unchanged1_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_attr_unchanged2_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_attr_unchanged3_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_attr_unchanged4_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_attr_unchanged5_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_attr_unchanged6_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_attr_unchanged7_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_attr_unchanged8_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_attr_unchanged9_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_attr_unchanged10_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_attr_unchanged_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_attr_unchanged1_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_attr_unchanged2_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_attr_unchanged3_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_attr_unchanged4_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_attr_unchanged5_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_attr_unchanged6_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_attr_unchanged7_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_attr_unchanged8_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_attr_unchanged9_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_attr_unchanged10_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_attr_unchanged_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_attr_unchanged1_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_attr_unchanged2_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_attr_unchanged3_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_attr_unchanged4_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_attr_unchanged5_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_attr_unchanged6_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_attr_unchanged7_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_attr_unchanged8_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_attr_unchanged9_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_attr_unchanged10_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_attr_unchanged_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_attr_unchanged1_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_attr_unchanged2_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_attr_unchanged3_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_attr_unchanged4_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_attr_unchanged5_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_attr_unchanged6_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_attr_unchanged7_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_attr_unchanged8_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_attr_unchanged9_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_attr_unchanged10_cmd);\n\n  /* \"nexthop-local unchanged\" commands */\n  install_element (BGP_IPV6_NODE, &neighbor_nexthop_local_unchanged_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_nexthop_local_unchanged_cmd);\n\n  /* \"transparent-as\" and \"transparent-nexthop\" for old version\n     compatibility.  */\n  install_element (BGP_NODE, &neighbor_transparent_as_cmd);\n  install_element (BGP_NODE, &neighbor_transparent_nexthop_cmd);\n\n  /* \"neighbor next-hop-self\" commands. */\n  install_element (BGP_NODE, &neighbor_nexthop_self_cmd);\n  install_element (BGP_NODE, &no_neighbor_nexthop_self_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_nexthop_self_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_nexthop_self_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_nexthop_self_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_nexthop_self_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_nexthop_self_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_nexthop_self_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_nexthop_self_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_nexthop_self_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_nexthop_self_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_nexthop_self_cmd);\n\n  /* \"neighbor remove-private-AS\" commands. */\n  install_element (BGP_NODE, &neighbor_remove_private_as_cmd);\n  install_element (BGP_NODE, &no_neighbor_remove_private_as_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_remove_private_as_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_remove_private_as_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_remove_private_as_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_remove_private_as_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_remove_private_as_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_remove_private_as_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_remove_private_as_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_remove_private_as_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_remove_private_as_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_remove_private_as_cmd);\n\n  /* \"neighbor send-community\" commands.*/\n  install_element (BGP_NODE, &neighbor_send_community_cmd);\n  install_element (BGP_NODE, &neighbor_send_community_type_cmd);\n  install_element (BGP_NODE, &no_neighbor_send_community_cmd);\n  install_element (BGP_NODE, &no_neighbor_send_community_type_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_send_community_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_send_community_type_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_send_community_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_send_community_type_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_send_community_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_send_community_type_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_send_community_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_send_community_type_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_send_community_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_send_community_type_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_send_community_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_send_community_type_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_send_community_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_send_community_type_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_send_community_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_send_community_type_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_send_community_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_send_community_type_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_send_community_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_send_community_type_cmd);\n\n  /* \"neighbor route-reflector\" commands.*/\n  install_element (BGP_NODE, &neighbor_route_reflector_client_cmd);\n  install_element (BGP_NODE, &no_neighbor_route_reflector_client_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_route_reflector_client_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_route_reflector_client_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_route_reflector_client_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_route_reflector_client_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_route_reflector_client_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_route_reflector_client_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_route_reflector_client_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_route_reflector_client_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_route_reflector_client_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_route_reflector_client_cmd);\n\n  /* \"neighbor route-server\" commands.*/\n  install_element (BGP_NODE, &neighbor_route_server_client_cmd);\n  install_element (BGP_NODE, &no_neighbor_route_server_client_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_route_server_client_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_route_server_client_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_route_server_client_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_route_server_client_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_route_server_client_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_route_server_client_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_route_server_client_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_route_server_client_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_route_server_client_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_route_server_client_cmd);\n\n  /* \"neighbor passive\" commands. */\n  install_element (BGP_NODE, &neighbor_passive_cmd);\n  install_element (BGP_NODE, &no_neighbor_passive_cmd);\n\n  /* \"neighbor shutdown\" commands. */\n  install_element (BGP_NODE, &neighbor_shutdown_cmd);\n  install_element (BGP_NODE, &no_neighbor_shutdown_cmd);\n\n  /* Deprecated \"neighbor capability route-refresh\" commands.*/\n  install_element (BGP_NODE, &neighbor_capability_route_refresh_cmd);\n  install_element (BGP_NODE, &no_neighbor_capability_route_refresh_cmd);\n\n  /* \"neighbor capability orf prefix-list\" commands.*/\n  install_element (BGP_NODE, &neighbor_capability_orf_prefix_cmd);\n  install_element (BGP_NODE, &no_neighbor_capability_orf_prefix_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_capability_orf_prefix_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_capability_orf_prefix_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_capability_orf_prefix_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_capability_orf_prefix_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_capability_orf_prefix_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_capability_orf_prefix_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_capability_orf_prefix_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_capability_orf_prefix_cmd);\n\n  /* \"neighbor capability dynamic\" commands.*/\n  install_element (BGP_NODE, &neighbor_capability_dynamic_cmd);\n  install_element (BGP_NODE, &no_neighbor_capability_dynamic_cmd);\n\n  /* \"neighbor dont-capability-negotiate\" commands. */\n  install_element (BGP_NODE, &neighbor_dont_capability_negotiate_cmd);\n  install_element (BGP_NODE, &no_neighbor_dont_capability_negotiate_cmd);\n\n  /* \"neighbor ebgp-multihop\" commands. */\n  install_element (BGP_NODE, &neighbor_ebgp_multihop_cmd);\n  install_element (BGP_NODE, &neighbor_ebgp_multihop_ttl_cmd);\n  install_element (BGP_NODE, &no_neighbor_ebgp_multihop_cmd);\n  install_element (BGP_NODE, &no_neighbor_ebgp_multihop_ttl_cmd);\n\n  /* \"neighbor disable-connected-check\" commands.  */\n  install_element (BGP_NODE, &neighbor_disable_connected_check_cmd);\n  install_element (BGP_NODE, &no_neighbor_disable_connected_check_cmd);\n  install_element (BGP_NODE, &neighbor_enforce_multihop_cmd);\n  install_element (BGP_NODE, &no_neighbor_enforce_multihop_cmd);\n\n  /* \"neighbor description\" commands. */\n  install_element (BGP_NODE, &neighbor_description_cmd);\n  install_element (BGP_NODE, &no_neighbor_description_cmd);\n  install_element (BGP_NODE, &no_neighbor_description_val_cmd);\n\n  /* \"neighbor update-source\" commands. \"*/\n  install_element (BGP_NODE, &neighbor_update_source_cmd);\n  install_element (BGP_NODE, &no_neighbor_update_source_cmd);\n\n  /* \"neighbor default-originate\" commands. */\n  install_element (BGP_NODE, &neighbor_default_originate_cmd);\n  install_element (BGP_NODE, &neighbor_default_originate_rmap_cmd);\n  install_element (BGP_NODE, &no_neighbor_default_originate_cmd);\n  install_element (BGP_NODE, &no_neighbor_default_originate_rmap_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_default_originate_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_default_originate_rmap_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_default_originate_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_default_originate_rmap_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_default_originate_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_default_originate_rmap_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_default_originate_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_default_originate_rmap_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_default_originate_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_default_originate_rmap_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_default_originate_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_default_originate_rmap_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_default_originate_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_default_originate_rmap_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_default_originate_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_default_originate_rmap_cmd);\n\n  /* \"neighbor port\" commands. */\n  install_element (BGP_NODE, &neighbor_port_cmd);\n  install_element (BGP_NODE, &no_neighbor_port_cmd);\n  install_element (BGP_NODE, &no_neighbor_port_val_cmd);\n\n  /* \"neighbor weight\" commands. */\n  install_element (BGP_NODE, &neighbor_weight_cmd);\n  install_element (BGP_NODE, &no_neighbor_weight_cmd);\n  install_element (BGP_NODE, &no_neighbor_weight_val_cmd);\n\n  /* \"neighbor override-capability\" commands. */\n  install_element (BGP_NODE, &neighbor_override_capability_cmd);\n  install_element (BGP_NODE, &no_neighbor_override_capability_cmd);\n\n  /* \"neighbor strict-capability-match\" commands. */\n  install_element (BGP_NODE, &neighbor_strict_capability_cmd);\n  install_element (BGP_NODE, &no_neighbor_strict_capability_cmd);\n\n  /* \"neighbor timers\" commands. */\n  install_element (BGP_NODE, &neighbor_timers_cmd);\n  install_element (BGP_NODE, &no_neighbor_timers_cmd);\n\n  /* \"neighbor timers connect\" commands. */\n  install_element (BGP_NODE, &neighbor_timers_connect_cmd);\n  install_element (BGP_NODE, &no_neighbor_timers_connect_cmd);\n  install_element (BGP_NODE, &no_neighbor_timers_connect_val_cmd);\n\n  /* \"neighbor advertisement-interval\" commands. */\n  install_element (BGP_NODE, &neighbor_advertise_interval_cmd);\n  install_element (BGP_NODE, &no_neighbor_advertise_interval_cmd);\n  install_element (BGP_NODE, &no_neighbor_advertise_interval_val_cmd);\n\n  /* \"neighbor version\" commands. */\n  install_element (BGP_NODE, &neighbor_version_cmd);\n\n  /* \"neighbor interface\" commands. */\n  install_element (BGP_NODE, &neighbor_interface_cmd);\n  install_element (BGP_NODE, &no_neighbor_interface_cmd);\n\n  /* \"neighbor distribute\" commands. */\n  install_element (BGP_NODE, &neighbor_distribute_list_cmd);\n  install_element (BGP_NODE, &no_neighbor_distribute_list_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_distribute_list_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_distribute_list_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_distribute_list_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_distribute_list_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_distribute_list_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_distribute_list_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_distribute_list_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_distribute_list_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_distribute_list_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_distribute_list_cmd);\n\n  /* \"neighbor prefix-list\" commands. */\n  install_element (BGP_NODE, &neighbor_prefix_list_cmd);\n  install_element (BGP_NODE, &no_neighbor_prefix_list_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_prefix_list_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_prefix_list_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_prefix_list_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_prefix_list_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_prefix_list_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_prefix_list_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_prefix_list_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_prefix_list_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_prefix_list_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_prefix_list_cmd);\n\n  /* \"neighbor filter-list\" commands. */\n  install_element (BGP_NODE, &neighbor_filter_list_cmd);\n  install_element (BGP_NODE, &no_neighbor_filter_list_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_filter_list_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_filter_list_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_filter_list_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_filter_list_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_filter_list_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_filter_list_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_filter_list_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_filter_list_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_filter_list_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_filter_list_cmd);\n\n  /* \"neighbor route-map\" commands. */\n  install_element (BGP_NODE, &neighbor_route_map_cmd);\n  install_element (BGP_NODE, &no_neighbor_route_map_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_route_map_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_route_map_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_route_map_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_route_map_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_route_map_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_route_map_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_route_map_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_route_map_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_route_map_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_route_map_cmd);\n\n  /* \"neighbor unsuppress-map\" commands. */\n  install_element (BGP_NODE, &neighbor_unsuppress_map_cmd);\n  install_element (BGP_NODE, &no_neighbor_unsuppress_map_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_unsuppress_map_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_unsuppress_map_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_unsuppress_map_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_unsuppress_map_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_unsuppress_map_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_unsuppress_map_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_unsuppress_map_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_unsuppress_map_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_unsuppress_map_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_unsuppress_map_cmd);  \n\n  /* \"neighbor maximum-prefix\" commands. */\n  install_element (BGP_NODE, &neighbor_maximum_prefix_cmd);\n  install_element (BGP_NODE, &neighbor_maximum_prefix_threshold_cmd);\n  install_element (BGP_NODE, &neighbor_maximum_prefix_warning_cmd);\n  install_element (BGP_NODE, &neighbor_maximum_prefix_threshold_warning_cmd);\n  install_element (BGP_NODE, &neighbor_maximum_prefix_restart_cmd);\n  install_element (BGP_NODE, &neighbor_maximum_prefix_threshold_restart_cmd);\n  install_element (BGP_NODE, &no_neighbor_maximum_prefix_cmd);\n  install_element (BGP_NODE, &no_neighbor_maximum_prefix_val_cmd);\n  install_element (BGP_NODE, &no_neighbor_maximum_prefix_threshold_cmd);\n  install_element (BGP_NODE, &no_neighbor_maximum_prefix_warning_cmd);\n  install_element (BGP_NODE, &no_neighbor_maximum_prefix_threshold_warning_cmd);\n  install_element (BGP_NODE, &no_neighbor_maximum_prefix_restart_cmd);\n  install_element (BGP_NODE, &no_neighbor_maximum_prefix_threshold_restart_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_maximum_prefix_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_maximum_prefix_threshold_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_maximum_prefix_warning_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_maximum_prefix_threshold_warning_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_maximum_prefix_restart_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_maximum_prefix_threshold_restart_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_maximum_prefix_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_maximum_prefix_val_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_maximum_prefix_threshold_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_maximum_prefix_warning_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_maximum_prefix_threshold_warning_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_maximum_prefix_restart_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_maximum_prefix_threshold_restart_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_maximum_prefix_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_maximum_prefix_threshold_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_maximum_prefix_warning_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_maximum_prefix_threshold_warning_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_maximum_prefix_restart_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_maximum_prefix_threshold_restart_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_maximum_prefix_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_maximum_prefix_val_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_maximum_prefix_threshold_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_maximum_prefix_warning_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_maximum_prefix_threshold_warning_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_maximum_prefix_restart_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_maximum_prefix_threshold_restart_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_maximum_prefix_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_maximum_prefix_threshold_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_maximum_prefix_warning_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_maximum_prefix_threshold_warning_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_maximum_prefix_restart_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_maximum_prefix_threshold_restart_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_maximum_prefix_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_maximum_prefix_val_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_maximum_prefix_threshold_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_maximum_prefix_warning_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_maximum_prefix_threshold_warning_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_maximum_prefix_restart_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_maximum_prefix_threshold_restart_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_maximum_prefix_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_maximum_prefix_threshold_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_maximum_prefix_warning_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_maximum_prefix_threshold_warning_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_maximum_prefix_restart_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_maximum_prefix_threshold_restart_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_maximum_prefix_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_maximum_prefix_val_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_maximum_prefix_threshold_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_maximum_prefix_warning_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_maximum_prefix_threshold_warning_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_maximum_prefix_restart_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_maximum_prefix_threshold_restart_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_maximum_prefix_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_maximum_prefix_threshold_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_maximum_prefix_warning_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_maximum_prefix_threshold_warning_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_maximum_prefix_restart_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_maximum_prefix_threshold_restart_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_maximum_prefix_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_maximum_prefix_val_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_maximum_prefix_threshold_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_maximum_prefix_warning_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_maximum_prefix_threshold_warning_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_maximum_prefix_restart_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_maximum_prefix_threshold_restart_cmd);\n\n  /* \"neighbor allowas-in\" */\n  install_element (BGP_NODE, &neighbor_allowas_in_cmd);\n  install_element (BGP_NODE, &neighbor_allowas_in_arg_cmd);\n  install_element (BGP_NODE, &no_neighbor_allowas_in_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_allowas_in_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_allowas_in_arg_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_allowas_in_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_allowas_in_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_allowas_in_arg_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_allowas_in_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_allowas_in_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_allowas_in_arg_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_allowas_in_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_allowas_in_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_allowas_in_arg_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_allowas_in_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_allowas_in_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_allowas_in_arg_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_allowas_in_cmd);\n\n  /* address-family commands. */\n  install_element (BGP_NODE, &address_family_ipv4_cmd);\n  install_element (BGP_NODE, &address_family_ipv4_safi_cmd);\n#ifdef HAVE_IPV6\n  install_element (BGP_NODE, &address_family_ipv6_cmd);\n  install_element (BGP_NODE, &address_family_ipv6_safi_cmd);\n#endif /* HAVE_IPV6 */\n  install_element (BGP_NODE, &address_family_vpnv4_cmd);\n  install_element (BGP_NODE, &address_family_vpnv4_unicast_cmd);\n\n  /* \"exit-address-family\" command. */\n  install_element (BGP_IPV4_NODE, &exit_address_family_cmd);\n  install_element (BGP_IPV4M_NODE, &exit_address_family_cmd);\n  install_element (BGP_IPV6_NODE, &exit_address_family_cmd);\n  install_element (BGP_IPV6M_NODE, &exit_address_family_cmd);\n  install_element (BGP_VPNV4_NODE, &exit_address_family_cmd);\n\n  /* \"clear ip bgp commands\" */\n  install_element (ENABLE_NODE, &clear_ip_bgp_all_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_instance_all_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_as_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_group_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_external_cmd);\n#ifdef HAVE_IPV6\n  install_element (ENABLE_NODE, &clear_bgp_all_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_instance_all_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_all_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_peer_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_peer_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_peer_group_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_peer_group_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_external_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_external_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_as_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_as_cmd);\n#endif /* HAVE_IPV6 */\n\n  /* \"clear ip bgp neighbor soft in\" */\n  install_element (ENABLE_NODE, &clear_ip_bgp_all_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_instance_all_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_all_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_all_in_prefix_filter_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_instance_all_in_prefix_filter_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_in_prefix_filter_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_group_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_group_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_group_in_prefix_filter_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_external_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_external_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_external_in_prefix_filter_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_as_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_as_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_as_in_prefix_filter_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_all_ipv4_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_instance_all_ipv4_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_all_ipv4_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_all_ipv4_in_prefix_filter_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_instance_all_ipv4_in_prefix_filter_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_ipv4_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_ipv4_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_ipv4_in_prefix_filter_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_group_ipv4_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_group_ipv4_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_group_ipv4_in_prefix_filter_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_external_ipv4_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_external_ipv4_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_external_ipv4_in_prefix_filter_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_as_ipv4_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_as_ipv4_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_as_ipv4_in_prefix_filter_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_all_vpnv4_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_all_vpnv4_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_vpnv4_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_vpnv4_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_as_vpnv4_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_as_vpnv4_in_cmd);\n#ifdef HAVE_IPV6\n  install_element (ENABLE_NODE, &clear_bgp_all_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_instance_all_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_all_in_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_all_in_prefix_filter_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_peer_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_peer_in_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_peer_in_prefix_filter_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_peer_group_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_peer_group_in_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_peer_group_in_prefix_filter_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_external_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_external_in_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_external_in_prefix_filter_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_as_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_as_in_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_as_in_prefix_filter_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_all_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_all_in_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_all_in_prefix_filter_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_peer_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_peer_in_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_peer_in_prefix_filter_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_peer_group_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_peer_group_in_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_peer_group_in_prefix_filter_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_external_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_external_in_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_external_in_prefix_filter_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_as_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_as_in_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_as_in_prefix_filter_cmd);\n#endif /* HAVE_IPV6 */\n\n  /* \"clear ip bgp neighbor soft out\" */\n  install_element (ENABLE_NODE, &clear_ip_bgp_all_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_instance_all_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_all_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_group_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_group_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_external_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_external_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_as_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_as_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_all_ipv4_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_instance_all_ipv4_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_all_ipv4_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_ipv4_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_ipv4_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_group_ipv4_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_group_ipv4_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_external_ipv4_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_external_ipv4_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_as_ipv4_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_as_ipv4_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_all_vpnv4_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_all_vpnv4_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_vpnv4_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_vpnv4_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_as_vpnv4_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_as_vpnv4_out_cmd);\n#ifdef HAVE_IPV6\n  install_element (ENABLE_NODE, &clear_bgp_all_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_instance_all_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_all_out_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_peer_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_peer_out_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_peer_group_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_peer_group_out_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_external_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_external_out_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_as_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_as_out_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_all_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_all_out_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_peer_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_peer_out_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_peer_group_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_peer_group_out_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_external_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_external_out_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_as_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_as_out_cmd);\n#endif /* HAVE_IPV6 */\n\n  /* \"clear ip bgp neighbor soft\" */\n  install_element (ENABLE_NODE, &clear_ip_bgp_all_soft_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_instance_all_soft_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_soft_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_group_soft_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_external_soft_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_as_soft_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_all_ipv4_soft_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_instance_all_ipv4_soft_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_ipv4_soft_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_group_ipv4_soft_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_external_ipv4_soft_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_as_ipv4_soft_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_all_vpnv4_soft_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_vpnv4_soft_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_as_vpnv4_soft_cmd);\n#ifdef HAVE_IPV6\n  install_element (ENABLE_NODE, &clear_bgp_all_soft_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_instance_all_soft_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_peer_soft_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_peer_group_soft_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_external_soft_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_as_soft_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_all_soft_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_peer_soft_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_peer_group_soft_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_external_soft_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_as_soft_cmd);\n#endif /* HAVE_IPV6 */\n\n  /* \"clear ip bgp neighbor rsclient\" */\n  install_element (ENABLE_NODE, &clear_ip_bgp_all_rsclient_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_instance_all_rsclient_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_rsclient_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_instance_peer_rsclient_cmd);\n#ifdef HAVE_IPV6\n  install_element (ENABLE_NODE, &clear_bgp_all_rsclient_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_instance_all_rsclient_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_all_rsclient_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_instance_all_rsclient_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_peer_rsclient_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_instance_peer_rsclient_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_peer_rsclient_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_instance_peer_rsclient_cmd);\n#endif /* HAVE_IPV6 */\n\n  /* \"show ip bgp summary\" commands. */\n  install_element (VIEW_NODE, &show_ip_bgp_summary_cmd);\n  install_element (VIEW_NODE, &show_ip_bgp_instance_summary_cmd);\n  install_element (VIEW_NODE, &show_ip_bgp_ipv4_summary_cmd);\n  install_element (VIEW_NODE, &show_ip_bgp_instance_ipv4_summary_cmd);\n  install_element (VIEW_NODE, &show_ip_bgp_vpnv4_all_summary_cmd);\n  install_element (VIEW_NODE, &show_ip_bgp_vpnv4_rd_summary_cmd);\n#ifdef HAVE_IPV6\n  install_element (VIEW_NODE, &show_bgp_summary_cmd);\n  install_element (VIEW_NODE, &show_bgp_instance_summary_cmd);\n  install_element (VIEW_NODE, &show_bgp_ipv6_summary_cmd);\n  install_element (VIEW_NODE, &show_bgp_instance_ipv6_summary_cmd);\n#endif /* HAVE_IPV6 */\n  install_element (ENABLE_NODE, &show_ip_bgp_summary_cmd);\n  install_element (ENABLE_NODE, &show_ip_bgp_instance_summary_cmd);\n  install_element (ENABLE_NODE, &show_ip_bgp_ipv4_summary_cmd);\n  install_element (ENABLE_NODE, &show_ip_bgp_instance_ipv4_summary_cmd);\n  install_element (ENABLE_NODE, &show_ip_bgp_vpnv4_all_summary_cmd);\n  install_element (ENABLE_NODE, &show_ip_bgp_vpnv4_rd_summary_cmd);\n#ifdef HAVE_IPV6\n  install_element (ENABLE_NODE, &show_bgp_summary_cmd);\n  install_element (ENABLE_NODE, &show_bgp_instance_summary_cmd);\n  install_element (ENABLE_NODE, &show_bgp_ipv6_summary_cmd);\n  install_element (ENABLE_NODE, &show_bgp_instance_ipv6_summary_cmd);\n#endif /* HAVE_IPV6 */\n\n  /* \"show ip bgp neighbors\" commands. */\n  install_element (VIEW_NODE, &show_ip_bgp_neighbors_cmd);\n  install_element (VIEW_NODE, &show_ip_bgp_ipv4_neighbors_cmd);\n  install_element (VIEW_NODE, &show_ip_bgp_neighbors_peer_cmd);\n  install_element (VIEW_NODE, &show_ip_bgp_ipv4_neighbors_peer_cmd);\n  install_element (VIEW_NODE, &show_ip_bgp_vpnv4_all_neighbors_cmd);\n  install_element (VIEW_NODE, &show_ip_bgp_vpnv4_rd_neighbors_cmd);\n  install_element (VIEW_NODE, &show_ip_bgp_vpnv4_all_neighbors_peer_cmd);\n  install_element (VIEW_NODE, &show_ip_bgp_vpnv4_rd_neighbors_peer_cmd);\n  install_element (VIEW_NODE, &show_ip_bgp_instance_neighbors_cmd);\n  install_element (VIEW_NODE, &show_ip_bgp_instance_neighbors_peer_cmd);\n  install_element (ENABLE_NODE, &show_ip_bgp_neighbors_cmd);\n  install_element (ENABLE_NODE, &show_ip_bgp_ipv4_neighbors_cmd);\n  install_element (ENABLE_NODE, &show_ip_bgp_neighbors_peer_cmd);\n  install_element (ENABLE_NODE, &show_ip_bgp_ipv4_neighbors_peer_cmd);\n  install_element (ENABLE_NODE, &show_ip_bgp_vpnv4_all_neighbors_cmd);\n  install_element (ENABLE_NODE, &show_ip_bgp_vpnv4_rd_neighbors_cmd);\n  install_element (ENABLE_NODE, &show_ip_bgp_vpnv4_all_neighbors_peer_cmd);\n  install_element (ENABLE_NODE, &show_ip_bgp_vpnv4_rd_neighbors_peer_cmd);\n  install_element (ENABLE_NODE, &show_ip_bgp_instance_neighbors_cmd);\n  install_element (ENABLE_NODE, &show_ip_bgp_instance_neighbors_peer_cmd);\n\n#ifdef HAVE_IPV6\n  install_element (VIEW_NODE, &show_bgp_neighbors_cmd);\n  install_element (VIEW_NODE, &show_bgp_ipv6_neighbors_cmd);\n  install_element (VIEW_NODE, &show_bgp_neighbors_peer_cmd);\n  install_element (VIEW_NODE, &show_bgp_ipv6_neighbors_peer_cmd);\n  install_element (VIEW_NODE, &show_bgp_instance_neighbors_cmd);\n  install_element (VIEW_NODE, &show_bgp_instance_ipv6_neighbors_cmd);\n  install_element (VIEW_NODE, &show_bgp_instance_neighbors_peer_cmd);\n  install_element (VIEW_NODE, &show_bgp_instance_ipv6_neighbors_peer_cmd);\n  install_element (ENABLE_NODE, &show_bgp_neighbors_cmd);\n  install_element (ENABLE_NODE, &show_bgp_ipv6_neighbors_cmd);\n  install_element (ENABLE_NODE, &show_bgp_neighbors_peer_cmd);\n  install_element (ENABLE_NODE, &show_bgp_ipv6_neighbors_peer_cmd);\n  install_element (ENABLE_NODE, &show_bgp_instance_neighbors_cmd);\n  install_element (ENABLE_NODE, &show_bgp_instance_ipv6_neighbors_cmd);\n  install_element (ENABLE_NODE, &show_bgp_instance_neighbors_peer_cmd);\n  install_element (ENABLE_NODE, &show_bgp_instance_ipv6_neighbors_peer_cmd);\n\n  /* Old commands.  */\n  install_element (VIEW_NODE, &show_ipv6_bgp_summary_cmd);\n  install_element (VIEW_NODE, &show_ipv6_mbgp_summary_cmd);\n  install_element (ENABLE_NODE, &show_ipv6_bgp_summary_cmd);\n  install_element (ENABLE_NODE, &show_ipv6_mbgp_summary_cmd);\n#endif /* HAVE_IPV6 */\n\n  /* \"show ip bgp rsclient\" commands. */\n  install_element (VIEW_NODE, &show_ip_bgp_rsclient_summary_cmd);\n  install_element (VIEW_NODE, &show_ip_bgp_instance_rsclient_summary_cmd);\n  install_element (VIEW_NODE, &show_ip_bgp_ipv4_rsclient_summary_cmd);\n  install_element (VIEW_NODE, &show_ip_bgp_instance_ipv4_rsclient_summary_cmd);\n  install_element (ENABLE_NODE, &show_ip_bgp_rsclient_summary_cmd);\n  install_element (ENABLE_NODE, &show_ip_bgp_instance_rsclient_summary_cmd);\n  install_element (ENABLE_NODE, &show_ip_bgp_ipv4_rsclient_summary_cmd);\n  install_element (ENABLE_NODE, &show_ip_bgp_instance_ipv4_rsclient_summary_cmd);\n\n#ifdef HAVE_IPV6\n  install_element (VIEW_NODE, &show_bgp_rsclient_summary_cmd);\n  install_element (VIEW_NODE, &show_bgp_ipv6_rsclient_summary_cmd);\n  install_element (VIEW_NODE, &show_bgp_instance_rsclient_summary_cmd);\n  install_element (VIEW_NODE, &show_bgp_instance_ipv6_rsclient_summary_cmd);\n  install_element (ENABLE_NODE, &show_bgp_rsclient_summary_cmd);\n  install_element (ENABLE_NODE, &show_bgp_ipv6_rsclient_summary_cmd);\n  install_element (ENABLE_NODE, &show_bgp_instance_rsclient_summary_cmd);\n  install_element (ENABLE_NODE, &show_bgp_instance_ipv6_rsclient_summary_cmd);\n#endif /* HAVE_IPV6 */\n\n  /* \"show ip bgp paths\" commands. */\n  install_element (VIEW_NODE, &show_ip_bgp_paths_cmd);\n  install_element (VIEW_NODE, &show_ip_bgp_ipv4_paths_cmd);\n  install_element (ENABLE_NODE, &show_ip_bgp_paths_cmd);\n  install_element (ENABLE_NODE, &show_ip_bgp_ipv4_paths_cmd);\n\n  /* \"show ip bgp community\" commands. */\n  install_element (VIEW_NODE, &show_ip_bgp_community_info_cmd);\n  install_element (ENABLE_NODE, &show_ip_bgp_community_info_cmd);\n\n  /* \"show ip bgp attribute-info\" commands. */\n  install_element (VIEW_NODE, &show_ip_bgp_attr_info_cmd);\n  install_element (ENABLE_NODE, &show_ip_bgp_attr_info_cmd);\n\n  /* \"redistribute\" commands.  */\n  install_element (BGP_NODE, &bgp_redistribute_ipv4_cmd);\n  install_element (BGP_NODE, &no_bgp_redistribute_ipv4_cmd);\n  install_element (BGP_NODE, &bgp_redistribute_ipv4_rmap_cmd);\n  install_element (BGP_NODE, &no_bgp_redistribute_ipv4_rmap_cmd);\n  install_element (BGP_NODE, &bgp_redistribute_ipv4_metric_cmd);\n  install_element (BGP_NODE, &no_bgp_redistribute_ipv4_metric_cmd);\n  install_element (BGP_NODE, &bgp_redistribute_ipv4_rmap_metric_cmd);\n  install_element (BGP_NODE, &bgp_redistribute_ipv4_metric_rmap_cmd);\n  install_element (BGP_NODE, &no_bgp_redistribute_ipv4_rmap_metric_cmd);\n  install_element (BGP_NODE, &no_bgp_redistribute_ipv4_metric_rmap_cmd);\n#ifdef HAVE_IPV6\n  install_element (BGP_IPV6_NODE, &bgp_redistribute_ipv6_cmd);\n  install_element (BGP_IPV6_NODE, &no_bgp_redistribute_ipv6_cmd);\n  install_element (BGP_IPV6_NODE, &bgp_redistribute_ipv6_rmap_cmd);\n  install_element (BGP_IPV6_NODE, &no_bgp_redistribute_ipv6_rmap_cmd);\n  install_element (BGP_IPV6_NODE, &bgp_redistribute_ipv6_metric_cmd);\n  install_element (BGP_IPV6_NODE, &no_bgp_redistribute_ipv6_metric_cmd);\n  install_element (BGP_IPV6_NODE, &bgp_redistribute_ipv6_rmap_metric_cmd);\n  install_element (BGP_IPV6_NODE, &bgp_redistribute_ipv6_metric_rmap_cmd);\n  install_element (BGP_IPV6_NODE, &no_bgp_redistribute_ipv6_rmap_metric_cmd);\n  install_element (BGP_IPV6_NODE, &no_bgp_redistribute_ipv6_metric_rmap_cmd);\n#endif /* HAVE_IPV6 */\n\n  /* \"show bgp memory\" commands. */\n  install_element (VIEW_NODE, &show_bgp_memory_cmd);\n  install_element (ENABLE_NODE, &show_bgp_memory_cmd);\n  \n  /* Community-list. */\n  community_list_vty ();\n}\n\f\n#include \"memory.h\"\n#include \"bgp_regex.h\"\n#include \"bgp_clist.h\"\n#include \"bgp_ecommunity.h\"\n\n/* VTY functions.  */\n\n/* Direction value to string conversion.  */\nstatic const char *\ncommunity_direct_str (int direct)\n{\n  switch (direct)\n    {\n    case COMMUNITY_DENY:\n      return \"deny\";\n    case COMMUNITY_PERMIT:\n      return \"permit\";\n    default:\n      return \"unknown\";\n    }\n}\n\n/* Display error string.  */\nstatic void\ncommunity_list_perror (struct vty *vty, int ret)\n{\n  switch (ret)\n    {\n    case COMMUNITY_LIST_ERR_CANT_FIND_LIST:\n      vty_out (vty, \"%% Can't find communit-list%s\", VTY_NEWLINE);\n      break;\n    case COMMUNITY_LIST_ERR_MALFORMED_VAL:\n      vty_out (vty, \"%% Malformed community-list value%s\", VTY_NEWLINE);\n      break;\n    case COMMUNITY_LIST_ERR_STANDARD_CONFLICT:\n      vty_out (vty, \"%% Community name conflict, previously defined as standard community%s\", VTY_NEWLINE);\n      break;\n    case COMMUNITY_LIST_ERR_EXPANDED_CONFLICT:\n      vty_out (vty, \"%% Community name conflict, previously defined as expanded community%s\", VTY_NEWLINE);\n      break;\n    }\n}\n\n/* VTY interface for community_set() function.  */\nstatic int\ncommunity_list_set_vty (struct vty *vty, int argc, const char **argv, \n                        int style, int reject_all_digit_name)\n{\n  int ret;\n  int direct;\n  char *str;\n\n  /* Check the list type. */\n  if (strncmp (argv[1], \"p\", 1) == 0)\n    direct = COMMUNITY_PERMIT;\n  else if (strncmp (argv[1], \"d\", 1) == 0)\n    direct = COMMUNITY_DENY;\n  else\n    {\n      vty_out (vty, \"%% Matching condition must be permit or deny%s\",\n\t       VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  /* All digit name check.  */\n  if (reject_all_digit_name && all_digit (argv[0]))\n    {\n      vty_out (vty, \"%% Community name cannot have all digits%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  /* Concat community string argument.  */\n  if (argc > 1)\n    str = argv_concat (argv, argc, 2);\n  else\n    str = NULL;\n\n  /* When community_list_set() return nevetive value, it means\n     malformed community string.  */\n  ret = community_list_set (bgp_clist, argv[0], str, direct, style);\n\n  /* Free temporary community list string allocated by\n     argv_concat().  */\n  if (str)\n    XFREE (MTYPE_TMP, str);\n\n  if (ret < 0)\n    {\n      /* Display error string.  */\n      community_list_perror (vty, ret);\n      return CMD_WARNING;\n    }\n\n  return CMD_SUCCESS;\n}\n\n/* Communiyt-list entry delete.  */\nstatic int\ncommunity_list_unset_vty (struct vty *vty, int argc, const char **argv,\n\t\t\t  int style)\n{\n  int ret;\n  int direct = 0;\n  char *str = NULL;\n\n  if (argc > 1)\n    {\n      /* Check the list direct. */\n      if (strncmp (argv[1], \"p\", 1) == 0)\n\tdirect = COMMUNITY_PERMIT;\n      else if (strncmp (argv[1], \"d\", 1) == 0)\n\tdirect = COMMUNITY_DENY;\n      else\n\t{\n\t  vty_out (vty, \"%% Matching condition must be permit or deny%s\",\n\t\t   VTY_NEWLINE);\n\t  return CMD_WARNING;\n\t}\n\n      /* Concat community string argument.  */\n      str = argv_concat (argv, argc, 2);\n    }\n\n  /* Unset community list.  */\n  ret = community_list_unset (bgp_clist, argv[0], str, direct, style);\n\n  /* Free temporary community list string allocated by\n     argv_concat().  */\n  if (str)\n    XFREE (MTYPE_TMP, str);\n\n  if (ret < 0)\n    {\n      community_list_perror (vty, ret);\n      return CMD_WARNING;\n    }\n\n  return CMD_SUCCESS;\n}\n\n/* \"community-list\" keyword help string.  */\n#define COMMUNITY_LIST_STR \"Add a community list entry\\n\"\n#define COMMUNITY_VAL_STR  \"Community number in aa:nn format or internet|local-AS|no-advertise|no-export\\n\"\n\nDEFUN (ip_community_list_standard,\n       ip_community_list_standard_cmd,\n       \"ip community-list <1-99> (deny|permit) .AA:NN\",\n       IP_STR\n       COMMUNITY_LIST_STR\n       \"Community list number (standard)\\n\"\n       \"Specify community to reject\\n\"\n       \"Specify community to accept\\n\"\n       COMMUNITY_VAL_STR)\n{\n  return community_list_set_vty (vty, argc, argv, COMMUNITY_LIST_STANDARD, 0);\n}\n\nALIAS (ip_community_list_standard,\n       ip_community_list_standard2_cmd,\n       \"ip community-list <1-99> (deny|permit)\",\n       IP_STR\n       COMMUNITY_LIST_STR\n       \"Community list number (standard)\\n\"\n       \"Specify community to reject\\n\"\n       \"Specify community to accept\\n\")\n\nDEFUN (ip_community_list_expanded,\n       ip_community_list_expanded_cmd,\n       \"ip community-list <100-500> (deny|permit) .LINE\",\n       IP_STR\n       COMMUNITY_LIST_STR\n       \"Community list number (expanded)\\n\"\n       \"Specify community to reject\\n\"\n       \"Specify community to accept\\n\"\n       \"An ordered list as a regular-expression\\n\")\n{\n  return community_list_set_vty (vty, argc, argv, COMMUNITY_LIST_EXPANDED, 0);\n}\n\nDEFUN (ip_community_list_name_standard,\n       ip_community_list_name_standard_cmd,\n       \"ip community-list standard WORD (deny|permit) .AA:NN\",\n       IP_STR\n       COMMUNITY_LIST_STR\n       \"Add a standard community-list entry\\n\"\n       \"Community list name\\n\"\n       \"Specify community to reject\\n\"\n       \"Specify community to accept\\n\"\n       COMMUNITY_VAL_STR)\n{\n  return community_list_set_vty (vty, argc, argv, COMMUNITY_LIST_STANDARD, 1);\n}\n\nALIAS (ip_community_list_name_standard,\n       ip_community_list_name_standard2_cmd,\n       \"ip community-list standard WORD (deny|permit)\",\n       IP_STR\n       COMMUNITY_LIST_STR\n       \"Add a standard community-list entry\\n\"\n       \"Community list name\\n\"\n       \"Specify community to reject\\n\"\n       \"Specify community to accept\\n\")\n\nDEFUN (ip_community_list_name_expanded,\n       ip_community_list_name_expanded_cmd,\n       \"ip community-list expanded WORD (deny|permit) .LINE\",\n       IP_STR\n       COMMUNITY_LIST_STR\n       \"Add an expanded community-list entry\\n\"\n       \"Community list name\\n\"\n       \"Specify community to reject\\n\"\n       \"Specify community to accept\\n\"\n       \"An ordered list as a regular-expression\\n\")\n{\n  return community_list_set_vty (vty, argc, argv, COMMUNITY_LIST_EXPANDED, 1);\n}\n\nDEFUN (no_ip_community_list_standard_all,\n       no_ip_community_list_standard_all_cmd,\n       \"no ip community-list <1-99>\",\n       NO_STR\n       IP_STR\n       COMMUNITY_LIST_STR\n       \"Community list number (standard)\\n\")\n{\n  return community_list_unset_vty (vty, argc, argv, COMMUNITY_LIST_STANDARD);\n}\n\nDEFUN (no_ip_community_list_expanded_all,\n       no_ip_community_list_expanded_all_cmd,\n       \"no ip community-list <100-500>\",\n       NO_STR\n       IP_STR\n       COMMUNITY_LIST_STR\n       \"Community list number (expanded)\\n\")\n{\n  return community_list_unset_vty (vty, argc, argv, COMMUNITY_LIST_EXPANDED);\n}\n\nDEFUN (no_ip_community_list_name_standard_all,\n       no_ip_community_list_name_standard_all_cmd,\n       \"no ip community-list standard WORD\",\n       NO_STR\n       IP_STR\n       COMMUNITY_LIST_STR\n       \"Add a standard community-list entry\\n\"\n       \"Community list name\\n\")\n{\n  return community_list_unset_vty (vty, argc, argv, COMMUNITY_LIST_STANDARD);\n}\n\nDEFUN (no_ip_community_list_name_expanded_all,\n       no_ip_community_list_name_expanded_all_cmd,\n       \"no ip community-list expanded WORD\",\n       NO_STR\n       IP_STR\n       COMMUNITY_LIST_STR\n       \"Add an expanded community-list entry\\n\"\n       \"Community list name\\n\")\n{\n  return community_list_unset_vty (vty, argc, argv, COMMUNITY_LIST_EXPANDED);\n}\n\nDEFUN (no_ip_community_list_standard,\n       no_ip_community_list_standard_cmd,\n       \"no ip community-list <1-99> (deny|permit) .AA:NN\",\n       NO_STR\n       IP_STR\n       COMMUNITY_LIST_STR\n       \"Community list number (standard)\\n\"\n       \"Specify community to reject\\n\"\n       \"Specify community to accept\\n\"\n       COMMUNITY_VAL_STR)\n{\n  return community_list_unset_vty (vty, argc, argv, COMMUNITY_LIST_STANDARD);\n}\n\nDEFUN (no_ip_community_list_expanded,\n       no_ip_community_list_expanded_cmd,\n       \"no ip community-list <100-500> (deny|permit) .LINE\",\n       NO_STR\n       IP_STR\n       COMMUNITY_LIST_STR\n       \"Community list number (expanded)\\n\"\n       \"Specify community to reject\\n\"\n       \"Specify community to accept\\n\"\n       \"An ordered list as a regular-expression\\n\")\n{\n  return community_list_unset_vty (vty, argc, argv, COMMUNITY_LIST_EXPANDED);\n}\n\nDEFUN (no_ip_community_list_name_standard,\n       no_ip_community_list_name_standard_cmd,\n       \"no ip community-list standard WORD (deny|permit) .AA:NN\",\n       NO_STR\n       IP_STR\n       COMMUNITY_LIST_STR\n       \"Specify a standard community-list\\n\"\n       \"Community list name\\n\"\n       \"Specify community to reject\\n\"\n       \"Specify community to accept\\n\"\n       COMMUNITY_VAL_STR)\n{\n  return community_list_unset_vty (vty, argc, argv, COMMUNITY_LIST_STANDARD);\n}\n\nDEFUN (no_ip_community_list_name_expanded,\n       no_ip_community_list_name_expanded_cmd,\n       \"no ip community-list expanded WORD (deny|permit) .LINE\",\n       NO_STR\n       IP_STR\n       COMMUNITY_LIST_STR\n       \"Specify an expanded community-list\\n\"\n       \"Community list name\\n\"\n       \"Specify community to reject\\n\"\n       \"Specify community to accept\\n\"\n       \"An ordered list as a regular-expression\\n\")\n{\n  return community_list_unset_vty (vty, argc, argv, COMMUNITY_LIST_EXPANDED);\n}\n\nstatic void\ncommunity_list_show (struct vty *vty, struct community_list *list)\n{\n  struct community_entry *entry;\n\n  for (entry = list->head; entry; entry = entry->next)\n    {\n      if (entry == list->head)\n\t{\n\t  if (all_digit (list->name))\n\t    vty_out (vty, \"Community %s list %s%s\",\n\t\t     entry->style == COMMUNITY_LIST_STANDARD ?\n\t\t     \"standard\" : \"(expanded) access\",\n\t\t     list->name, VTY_NEWLINE);\n\t  else\n\t    vty_out (vty, \"Named Community %s list %s%s\",\n\t\t     entry->style == COMMUNITY_LIST_STANDARD ?\n\t\t     \"standard\" : \"expanded\",\n\t\t     list->name, VTY_NEWLINE);\n\t}\n      if (entry->any)\n\tvty_out (vty, \"    %s%s\",\n\t\t community_direct_str (entry->direct), VTY_NEWLINE);\n      else\n\tvty_out (vty, \"    %s %s%s\",\n\t\t community_direct_str (entry->direct),\n\t\t entry->style == COMMUNITY_LIST_STANDARD\n\t\t ? community_str (entry->u.com) : entry->config,\n\t\t VTY_NEWLINE);\n    }\n}\n\nDEFUN (show_ip_community_list,\n       show_ip_community_list_cmd,\n       \"show ip community-list\",\n       SHOW_STR\n       IP_STR\n       \"List community-list\\n\")\n{\n  struct community_list *list;\n  struct community_list_master *cm;\n\n  cm = community_list_master_lookup (bgp_clist, COMMUNITY_LIST_MASTER);\n  if (! cm)\n    return CMD_SUCCESS;\n\n  for (list = cm->num.head; list; list = list->next)\n    community_list_show (vty, list);\n\n  for (list = cm->str.head; list; list = list->next)\n    community_list_show (vty, list);\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (show_ip_community_list_arg,\n       show_ip_community_list_arg_cmd,\n       \"show ip community-list (<1-500>|WORD)\",\n       SHOW_STR\n       IP_STR\n       \"List community-list\\n\"\n       \"Community-list number\\n\"\n       \"Community-list name\\n\")\n{\n  struct community_list *list;\n\n  list = community_list_lookup (bgp_clist, argv[0], COMMUNITY_LIST_MASTER);\n  if (! list)\n    {\n      vty_out (vty, \"%% Can't find communit-list%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  community_list_show (vty, list);\n\n  return CMD_SUCCESS;\n}\n\f\nstatic int\nextcommunity_list_set_vty (struct vty *vty, int argc, const char **argv, \n                           int style, int reject_all_digit_name)\n{\n  int ret;\n  int direct;\n  char *str;\n\n  /* Check the list type. */\n  if (strncmp (argv[1], \"p\", 1) == 0)\n    direct = COMMUNITY_PERMIT;\n  else if (strncmp (argv[1], \"d\", 1) == 0)\n    direct = COMMUNITY_DENY;\n  else\n    {\n      vty_out (vty, \"%% Matching condition must be permit or deny%s\",\n\t       VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  /* All digit name check.  */\n  if (reject_all_digit_name && all_digit (argv[0]))\n    {\n      vty_out (vty, \"%% Community name cannot have all digits%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  /* Concat community string argument.  */\n  if (argc > 1)\n    str = argv_concat (argv, argc, 2);\n  else\n    str = NULL;\n\n  ret = extcommunity_list_set (bgp_clist, argv[0], str, direct, style);\n\n  /* Free temporary community list string allocated by\n     argv_concat().  */\n  if (str)\n    XFREE (MTYPE_TMP, str);\n\n  if (ret < 0)\n    {\n      community_list_perror (vty, ret);\n      return CMD_WARNING;\n    }\n  return CMD_SUCCESS;\n}\n\nstatic int\nextcommunity_list_unset_vty (struct vty *vty, int argc, const char **argv,\n\t\t\t     int style)\n{\n  int ret;\n  int direct = 0;\n  char *str = NULL;\n\n  if (argc > 1)\n    {\n      /* Check the list direct. */\n      if (strncmp (argv[1], \"p\", 1) == 0)\n\tdirect = COMMUNITY_PERMIT;\n      else if (strncmp (argv[1], \"d\", 1) == 0)\n\tdirect = COMMUNITY_DENY;\n      else\n\t{\n\t  vty_out (vty, \"%% Matching condition must be permit or deny%s\",\n\t\t   VTY_NEWLINE);\n\t  return CMD_WARNING;\n\t}\n\n      /* Concat community string argument.  */\n      str = argv_concat (argv, argc, 2);\n    }\n\n  /* Unset community list.  */\n  ret = extcommunity_list_unset (bgp_clist, argv[0], str, direct, style);\n\n  /* Free temporary community list string allocated by\n     argv_concat().  */\n  if (str)\n    XFREE (MTYPE_TMP, str);\n\n  if (ret < 0)\n    {\n      community_list_perror (vty, ret);\n      return CMD_WARNING;\n    }\n\n  return CMD_SUCCESS;\n}\n\n/* \"extcommunity-list\" keyword help string.  */\n#define EXTCOMMUNITY_LIST_STR \"Add a extended community list entry\\n\"\n#define EXTCOMMUNITY_VAL_STR  \"Extended community attribute in 'rt aa:nn_or_IPaddr:nn' OR 'soo aa:nn_or_IPaddr:nn' format\\n\"\n\nDEFUN (ip_extcommunity_list_standard,\n       ip_extcommunity_list_standard_cmd,\n       \"ip extcommunity-list <1-99> (deny|permit) .AA:NN\",\n       IP_STR\n       EXTCOMMUNITY_LIST_STR\n       \"Extended Community list number (standard)\\n\"\n       \"Specify community to reject\\n\"\n       \"Specify community to accept\\n\"\n       EXTCOMMUNITY_VAL_STR)\n{\n  return extcommunity_list_set_vty (vty, argc, argv, EXTCOMMUNITY_LIST_STANDARD, 0);\n}\n\nALIAS (ip_extcommunity_list_standard,\n       ip_extcommunity_list_standard2_cmd,\n       \"ip extcommunity-list <1-99> (deny|permit)\",\n       IP_STR\n       EXTCOMMUNITY_LIST_STR\n       \"Extended Community list number (standard)\\n\"\n       \"Specify community to reject\\n\"\n       \"Specify community to accept\\n\")\n\nDEFUN (ip_extcommunity_list_expanded,\n       ip_extcommunity_list_expanded_cmd,\n       \"ip extcommunity-list <100-500> (deny|permit) .LINE\",\n       IP_STR\n       EXTCOMMUNITY_LIST_STR\n       \"Extended Community list number (expanded)\\n\"\n       \"Specify community to reject\\n\"\n       \"Specify community to accept\\n\"\n       \"An ordered list as a regular-expression\\n\")\n{\n  return extcommunity_list_set_vty (vty, argc, argv, EXTCOMMUNITY_LIST_EXPANDED, 0);\n}\n\nDEFUN (ip_extcommunity_list_name_standard,\n       ip_extcommunity_list_name_standard_cmd,\n       \"ip extcommunity-list standard WORD (deny|permit) .AA:NN\",\n       IP_STR\n       EXTCOMMUNITY_LIST_STR\n       \"Specify standard extcommunity-list\\n\"\n       \"Extended Community list name\\n\"\n       \"Specify community to reject\\n\"\n       \"Specify community to accept\\n\"\n       EXTCOMMUNITY_VAL_STR)\n{\n  return extcommunity_list_set_vty (vty, argc, argv, EXTCOMMUNITY_LIST_STANDARD, 1);\n}\n\nALIAS (ip_extcommunity_list_name_standard,\n       ip_extcommunity_list_name_standard2_cmd,\n       \"ip extcommunity-list standard WORD (deny|permit)\",\n       IP_STR\n       EXTCOMMUNITY_LIST_STR\n       \"Specify standard extcommunity-list\\n\"\n       \"Extended Community list name\\n\"\n       \"Specify community to reject\\n\"\n       \"Specify community to accept\\n\")\n\nDEFUN (ip_extcommunity_list_name_expanded,\n       ip_extcommunity_list_name_expanded_cmd,\n       \"ip extcommunity-list expanded WORD (deny|permit) .LINE\",\n       IP_STR\n       EXTCOMMUNITY_LIST_STR\n       \"Specify expanded extcommunity-list\\n\"\n       \"Extended Community list name\\n\"\n       \"Specify community to reject\\n\"\n       \"Specify community to accept\\n\"\n       \"An ordered list as a regular-expression\\n\")\n{\n  return extcommunity_list_set_vty (vty, argc, argv, EXTCOMMUNITY_LIST_EXPANDED, 1);\n}\n\nDEFUN (no_ip_extcommunity_list_standard_all,\n       no_ip_extcommunity_list_standard_all_cmd,\n       \"no ip extcommunity-list <1-99>\",\n       NO_STR\n       IP_STR\n       EXTCOMMUNITY_LIST_STR\n       \"Extended Community list number (standard)\\n\")\n{\n  return extcommunity_list_unset_vty (vty, argc, argv, EXTCOMMUNITY_LIST_STANDARD);\n}\n\nDEFUN (no_ip_extcommunity_list_expanded_all,\n       no_ip_extcommunity_list_expanded_all_cmd,\n       \"no ip extcommunity-list <100-500>\",\n       NO_STR\n       IP_STR\n       EXTCOMMUNITY_LIST_STR\n       \"Extended Community list number (expanded)\\n\")\n{\n  return extcommunity_list_unset_vty (vty, argc, argv, EXTCOMMUNITY_LIST_EXPANDED);\n}\n\nDEFUN (no_ip_extcommunity_list_name_standard_all,\n       no_ip_extcommunity_list_name_standard_all_cmd,\n       \"no ip extcommunity-list standard WORD\",\n       NO_STR\n       IP_STR\n       EXTCOMMUNITY_LIST_STR\n       \"Specify standard extcommunity-list\\n\"\n       \"Extended Community list name\\n\")\n{\n  return extcommunity_list_unset_vty (vty, argc, argv, EXTCOMMUNITY_LIST_STANDARD);\n}\n\nDEFUN (no_ip_extcommunity_list_name_expanded_all,\n       no_ip_extcommunity_list_name_expanded_all_cmd,\n       \"no ip extcommunity-list expanded WORD\",\n       NO_STR\n       IP_STR\n       EXTCOMMUNITY_LIST_STR\n       \"Specify expanded extcommunity-list\\n\"\n       \"Extended Community list name\\n\")\n{\n  return extcommunity_list_unset_vty (vty, argc, argv, EXTCOMMUNITY_LIST_EXPANDED);\n}\n\nDEFUN (no_ip_extcommunity_list_standard,\n       no_ip_extcommunity_list_standard_cmd,\n       \"no ip extcommunity-list <1-99> (deny|permit) .AA:NN\",\n       NO_STR\n       IP_STR\n       EXTCOMMUNITY_LIST_STR\n       \"Extended Community list number (standard)\\n\"\n       \"Specify community to reject\\n\"\n       \"Specify community to accept\\n\"\n       EXTCOMMUNITY_VAL_STR)\n{\n  return extcommunity_list_unset_vty (vty, argc, argv, EXTCOMMUNITY_LIST_STANDARD);\n}\n\nDEFUN (no_ip_extcommunity_list_expanded,\n       no_ip_extcommunity_list_expanded_cmd,\n       \"no ip extcommunity-list <100-500> (deny|permit) .LINE\",\n       NO_STR\n       IP_STR\n       EXTCOMMUNITY_LIST_STR\n       \"Extended Community list number (expanded)\\n\"\n       \"Specify community to reject\\n\"\n       \"Specify community to accept\\n\"\n       \"An ordered list as a regular-expression\\n\")\n{\n  return extcommunity_list_unset_vty (vty, argc, argv, EXTCOMMUNITY_LIST_EXPANDED);\n}\n\nDEFUN (no_ip_extcommunity_list_name_standard,\n       no_ip_extcommunity_list_name_standard_cmd,\n       \"no ip extcommunity-list standard WORD (deny|permit) .AA:NN\",\n       NO_STR\n       IP_STR\n       EXTCOMMUNITY_LIST_STR\n       \"Specify standard extcommunity-list\\n\"\n       \"Extended Community list name\\n\"\n       \"Specify community to reject\\n\"\n       \"Specify community to accept\\n\"\n       EXTCOMMUNITY_VAL_STR)\n{\n  return extcommunity_list_unset_vty (vty, argc, argv, EXTCOMMUNITY_LIST_STANDARD);\n}\n\nDEFUN (no_ip_extcommunity_list_name_expanded,\n       no_ip_extcommunity_list_name_expanded_cmd,\n       \"no ip extcommunity-list expanded WORD (deny|permit) .LINE\",\n       NO_STR\n       IP_STR\n       EXTCOMMUNITY_LIST_STR\n       \"Specify expanded extcommunity-list\\n\"\n       \"Community list name\\n\"\n       \"Specify community to reject\\n\"\n       \"Specify community to accept\\n\"\n       \"An ordered list as a regular-expression\\n\")\n{\n  return extcommunity_list_unset_vty (vty, argc, argv, EXTCOMMUNITY_LIST_EXPANDED);\n}\n\nstatic void\nextcommunity_list_show (struct vty *vty, struct community_list *list)\n{\n  struct community_entry *entry;\n\n  for (entry = list->head; entry; entry = entry->next)\n    {\n      if (entry == list->head)\n\t{\n\t  if (all_digit (list->name))\n\t    vty_out (vty, \"Extended community %s list %s%s\",\n\t\t     entry->style == EXTCOMMUNITY_LIST_STANDARD ?\n\t\t     \"standard\" : \"(expanded) access\",\n\t\t     list->name, VTY_NEWLINE);\n\t  else\n\t    vty_out (vty, \"Named extended community %s list %s%s\",\n\t\t     entry->style == EXTCOMMUNITY_LIST_STANDARD ?\n\t\t     \"standard\" : \"expanded\",\n\t\t     list->name, VTY_NEWLINE);\n\t}\n      if (entry->any)\n\tvty_out (vty, \"    %s%s\",\n\t\t community_direct_str (entry->direct), VTY_NEWLINE);\n      else\n\tvty_out (vty, \"    %s %s%s\",\n\t\t community_direct_str (entry->direct),\n\t\t entry->style == EXTCOMMUNITY_LIST_STANDARD ?\n\t\t entry->u.ecom->str : entry->config,\n\t\t VTY_NEWLINE);\n    }\n}\n\nDEFUN (show_ip_extcommunity_list,\n       show_ip_extcommunity_list_cmd,\n       \"show ip extcommunity-list\",\n       SHOW_STR\n       IP_STR\n       \"List extended-community list\\n\")\n{\n  struct community_list *list;\n  struct community_list_master *cm;\n\n  cm = community_list_master_lookup (bgp_clist, EXTCOMMUNITY_LIST_MASTER);\n  if (! cm)\n    return CMD_SUCCESS;\n\n  for (list = cm->num.head; list; list = list->next)\n    extcommunity_list_show (vty, list);\n\n  for (list = cm->str.head; list; list = list->next)\n    extcommunity_list_show (vty, list);\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (show_ip_extcommunity_list_arg,\n       show_ip_extcommunity_list_arg_cmd,\n       \"show ip extcommunity-list (<1-500>|WORD)\",\n       SHOW_STR\n       IP_STR\n       \"List extended-community list\\n\"\n       \"Extcommunity-list number\\n\"\n       \"Extcommunity-list name\\n\")\n{\n  struct community_list *list;\n\n  list = community_list_lookup (bgp_clist, argv[0], EXTCOMMUNITY_LIST_MASTER);\n  if (! list)\n    {\n      vty_out (vty, \"%% Can't find extcommunit-list%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  extcommunity_list_show (vty, list);\n\n  return CMD_SUCCESS;\n}\n\f\n/* Return configuration string of community-list entry.  */\nstatic const char *\ncommunity_list_config_str (struct community_entry *entry)\n{\n  const char *str;\n\n  if (entry->any)\n    str = \"\";\n  else\n    {\n      if (entry->style == COMMUNITY_LIST_STANDARD)\n\tstr = community_str (entry->u.com);\n      else\n\tstr = entry->config;\n    }\n  return str;\n}\n\n/* Display community-list and extcommunity-list configuration.  */\nstatic int\ncommunity_list_config_write (struct vty *vty)\n{\n  struct community_list *list;\n  struct community_entry *entry;\n  struct community_list_master *cm;\n  int write = 0;\n\n  /* Community-list.  */\n  cm = community_list_master_lookup (bgp_clist, COMMUNITY_LIST_MASTER);\n\n  for (list = cm->num.head; list; list = list->next)\n    for (entry = list->head; entry; entry = entry->next)\n      {\n\tvty_out (vty, \"ip community-list %s %s %s%s\",\n\t\t list->name, community_direct_str (entry->direct),\n\t\t community_list_config_str (entry),\n\t\t VTY_NEWLINE);\n\twrite++;\n      }\n  for (list = cm->str.head; list; list = list->next)\n    for (entry = list->head; entry; entry = entry->next)\n      {\n\tvty_out (vty, \"ip community-list %s %s %s %s%s\",\n\t\t entry->style == COMMUNITY_LIST_STANDARD\n\t\t ? \"standard\" : \"expanded\",\n\t\t list->name, community_direct_str (entry->direct),\n\t\t community_list_config_str (entry),\n\t\t VTY_NEWLINE);\n\twrite++;\n      }\n\n  /* Extcommunity-list.  */\n  cm = community_list_master_lookup (bgp_clist, EXTCOMMUNITY_LIST_MASTER);\n\n  for (list = cm->num.head; list; list = list->next)\n    for (entry = list->head; entry; entry = entry->next)\n      {\n\tvty_out (vty, \"ip extcommunity-list %s %s %s%s\",\n\t\t list->name, community_direct_str (entry->direct),\n\t\t community_list_config_str (entry), VTY_NEWLINE);\n\twrite++;\n      }\n  for (list = cm->str.head; list; list = list->next)\n    for (entry = list->head; entry; entry = entry->next)\n      {\n\tvty_out (vty, \"ip extcommunity-list %s %s %s %s%s\",\n\t\t entry->style == EXTCOMMUNITY_LIST_STANDARD\n\t\t ? \"standard\" : \"expanded\",\n\t\t list->name, community_direct_str (entry->direct),\n\t\t community_list_config_str (entry), VTY_NEWLINE);\n\twrite++;\n      }\n  return write;\n}\n\nstruct cmd_node community_list_node =\n{\n  COMMUNITY_LIST_NODE,\n  \"\",\n  1\t\t\t\t/* Export to vtysh.  */\n};\n\nstatic void\ncommunity_list_vty (void)\n{\n  install_node (&community_list_node, community_list_config_write);\n\n  /* Community-list.  */\n  install_element (CONFIG_NODE, &ip_community_list_standard_cmd);\n  install_element (CONFIG_NODE, &ip_community_list_standard2_cmd);\n  install_element (CONFIG_NODE, &ip_community_list_expanded_cmd);\n  install_element (CONFIG_NODE, &ip_community_list_name_standard_cmd);\n  install_element (CONFIG_NODE, &ip_community_list_name_standard2_cmd);\n  install_element (CONFIG_NODE, &ip_community_list_name_expanded_cmd);\n  install_element (CONFIG_NODE, &no_ip_community_list_standard_all_cmd);\n  install_element (CONFIG_NODE, &no_ip_community_list_expanded_all_cmd);\n  install_element (CONFIG_NODE, &no_ip_community_list_name_standard_all_cmd);\n  install_element (CONFIG_NODE, &no_ip_community_list_name_expanded_all_cmd);\n  install_element (CONFIG_NODE, &no_ip_community_list_standard_cmd);\n  install_element (CONFIG_NODE, &no_ip_community_list_expanded_cmd);\n  install_element (CONFIG_NODE, &no_ip_community_list_name_standard_cmd);\n  install_element (CONFIG_NODE, &no_ip_community_list_name_expanded_cmd);\n  install_element (VIEW_NODE, &show_ip_community_list_cmd);\n  install_element (VIEW_NODE, &show_ip_community_list_arg_cmd);\n  install_element (ENABLE_NODE, &show_ip_community_list_cmd);\n  install_element (ENABLE_NODE, &show_ip_community_list_arg_cmd);\n\n  /* Extcommunity-list.  */\n  install_element (CONFIG_NODE, &ip_extcommunity_list_standard_cmd);\n  install_element (CONFIG_NODE, &ip_extcommunity_list_standard2_cmd);\n  install_element (CONFIG_NODE, &ip_extcommunity_list_expanded_cmd);\n  install_element (CONFIG_NODE, &ip_extcommunity_list_name_standard_cmd);\n  install_element (CONFIG_NODE, &ip_extcommunity_list_name_standard2_cmd);\n  install_element (CONFIG_NODE, &ip_extcommunity_list_name_expanded_cmd);\n  install_element (CONFIG_NODE, &no_ip_extcommunity_list_standard_all_cmd);\n  install_element (CONFIG_NODE, &no_ip_extcommunity_list_expanded_all_cmd);\n  install_element (CONFIG_NODE, &no_ip_extcommunity_list_name_standard_all_cmd);\n  install_element (CONFIG_NODE, &no_ip_extcommunity_list_name_expanded_all_cmd);\n  install_element (CONFIG_NODE, &no_ip_extcommunity_list_standard_cmd);\n  install_element (CONFIG_NODE, &no_ip_extcommunity_list_expanded_cmd);\n  install_element (CONFIG_NODE, &no_ip_extcommunity_list_name_standard_cmd);\n  install_element (CONFIG_NODE, &no_ip_extcommunity_list_name_expanded_cmd);\n  install_element (VIEW_NODE, &show_ip_extcommunity_list_cmd);\n  install_element (VIEW_NODE, &show_ip_extcommunity_list_arg_cmd);\n  install_element (ENABLE_NODE, &show_ip_extcommunity_list_cmd);\n  install_element (ENABLE_NODE, &show_ip_extcommunity_list_arg_cmd);\n}\n", "2007-07-06 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* sockopt.{c,h}: (setsockopt_multicast_ipv4) Add some comments about\n\t  the arguments.\n\n2007-06-01 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* zebra.h: On linux, we seem to need to include <linux/types.h> before\n\t  <sys/sysctl.h>, otherwise we get isisd compilation errors about\n\t  __be16 not being defined.\n\n2007-05-10 Paul Jakma <paul.jakma@sun.com>\n\n\t* zebra.h: Don't try define _GNU_SOURCE, autoconf should do it.\n\n2007-05-03 Paul Jakma <paul.jakma@sun.com>\n\n\t* memtypes.c: Add MTYPE_ATTR_EXTRA and MTYPE_BGP_ROUTE_EXTRA\n\n2007-05-01 David L Stevens <dlstevens@us.ibm.com>\n\n\t* (general) These changes collectively add route-map and\n\t  prefix-list support to zebra and fix a bug in \"show\n\t  route-map\" (with no argument).\n\t* command.h: added PROTOCOL_NODE type\n\t* log.c: (proto_name2num) new function, protocol name to\n\t  number translation.\n\t* routemap.c: (vty_show_route_map) fixed \"show route-map\"\n\t  without route-map name\n\t* routemap.h: added RMAP_ZEBRA type\n\t* zebra.h: added proto_name2num() prototype\n\n2007-04-29 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* log.c: (quagga_timestamp) Optimize the subsecond timestamp generation.\n\n2007-04-28 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* command.c: (config_write_host) Save \"log timestamp precision\"\n\t  if not default value.\n\t  (show_logging) Show configured timestamp precision.\n\t  (config_log_timestamp_precision) Enable configuration of timestamp\n\t  precision.\n\t  (no_config_log_timestamp_precision) Restore default timestamp\n\t  precision.\n\t  (cmd_init) Install new timestamp precision commands.\n\t* log.h: (struct zlog) New timestamp_precision field.\n\t  (quagga_timestamp) New function to generate a timestamp with the\n\t  desired precision.\n\t  (struct timestamp_control) Declare a structure for use in avoiding\n\t  repeated duplicate calls to quagga_timestamp.\n\t* log.c: (quagga_timestamp) New function to generate a timestamp\n\t  of the desired precision.\n\t  (time_print) Call quagga_timestamp if the time hasn't already been\n\t  calculated.\n\t  (vzlog) Initialize a timestamp_control structure and pass it to\n\t  time_print and vty_log.\n\t  (zlog_backtrace) Fix 64-bit problem: cannot print size_t with %u.\n\t* vty.h: Must now include \"log.h\".\n\t  (vty_log) Takes an additional struct timestamp_control argument.\n\t* vty.c: (vty_log_out) Use new struct timestamp_control and new\n\t  quagga_timestamp function to print timestamps of the desired\n\t  precision.\n\t  (vty_time_print) Use new quagga_timestamp function.\n\t  (vty_log) Accept new struct timestamp_control argument and pass it\n\t  down to vty_log_out.\n\n2007-04-27 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* smux.c: (smux_trap) Fix printf format to work with 64-bit size_t.\n\n2007-04-07 Paul Jakma <paul.jakma@sun.com>\n\n\t* prefix.h: Add define to match IPv4 Link-Local addresses\n\n2007-03-20 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* log.c: (mes_lookup) Make the function more robust: check for\n\t  cases where the index does not match the key value at that position.\n\t  If so, give a warning and fall back to a linear search.\n\t  And improve the error message in cases where even that fails.\n\n2006-12-12 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* if.h: (struct connected) Add new ZEBRA_IFA_PEER flag indicating\n\t  whether a peer address has been configured.  Comment now shows\n\t  the new interpretation of the destination addr: if ZEBRA_IFA_PEER\n\t  is set, then it must contain the destination address, otherwise\n\t  it may contain the broadcast address or be NULL.\n\t  (CONNECTED_DEST_HOST,CONNECTED_POINTOPOINT_HOST) Remove obsolete\n\t  macros that were specific to IPv4 and not fully general.\n\t  (CONNECTED_PEER) New macro to check ZEBRA_IFA_PEER flag.\n\t  (CONNECTED_PREFIX) New macro giving the prefix to insert into\n\t  the RIB: if CONNECTED_PEER, then use the destination (peer) address,\n\t  else use the address field.\n\t  (CONNECTED_ID) New macro to come up with an identifying address\n\t  for the struct connected.\n\t* if.c: (if_lookup_address, connected_lookup_address) Streamline\n\t  logic with new CONNECTED_PREFIX macro.\n\t* prefix.h: (PREFIX_COPY_IPV4, PREFIX_COPY_IPV6) New macros\n\t  for better performance than the general prefix_copy function.\n\t* zclient.c: (zebra_interface_address_read) For non-null destination\n\t  addresses, set prefixlen to equal the address prefixlen.  This\n\t  is needed to get the new CONNECTED_PREFIX macro to work properly.\n\n2006-10-14 Paul Jakma <paul.jakma@sun.com>\n\n\t* if.c: (general) Handle upgrades from SUNWzebra, which tried\n\t  to track each logical interface as a seperate struct\n\t  interface, to Quagga, which assigns only one struct interface\n\t  per ifindex.\n\t  (if_sunwzebra_get) Try decompose a logical interface name\n          (fooX:Y) to the 'primary' name (fooX), for Solaris.\n          (interface_cmd) Use if_sunwzebra_get on Solaris.\n\n2006-09-26 Pierre-Yves Ritschard <pierre-yves@spootnik.org>\n\n\t* smux.c: (smux_open,smux_trap,smux_register) Fix various\n\t  asn_build_* calls to pass the proper length in the final\n\t  argument: use sizeof(<variable>) instead of sizeof(<type>),\n\t  since there were several inconsistencies between the actual\n\t  variable type and the size that was passed.  This should\n\t  fix some problems on 64-bit architectures where sizeof(int)\n\t  != sizeof(long).\n\n2006-08-25 Paul Jakma <paul.jakma@sun.com>\n\n\t* thread.c: (general) Add support for monotonic clock, it may still\n\t  jump forward by huge amounts, but should be immune to going\n\t  backwards. Fixes bug #134.\n\t  (quagga_gettimeofday_relative_adjust) helper, does what name\n\t  says - adjusts gettimeofday based relative timer.\n\t  (quagga_gettimeofday) helper to keep recent_time up to date.\n\t  (quagga_get_relative) helper, update and getch the relative\n\t  timer using gettimeofday(). POSIX CLOCK_MONOTONIC is also\n\t  supported, but the code is not enabled yet nor tested.\n\t  (quagga_real_stabilised) helper, retrieve absolute time but\n\t  stabilised so as to never decrease.\n\t  (quagga_gettime) Exported interface, analogous to POSIX\n\t  clock_gettime() in interface, supporting several clocks.\n\t  (quagga_time) Exported interface, analogous to traditional\n\t  time(), will never decrease.\n\t  (recent_relative_time) Convenience function to retrieve\n\t  relative_time timeval, similar to existing recent_time absolute\n\t  timeval, for when an approximately recent value will do.\n\t  (remainder) Update to use above helpers.\n\t  (thread_getrusage) Previously was a macro, but needs to be\n\t  a function to twiddle with thread.c private stuff.\n\t* thread.c: Point the GETRUSAGE macro at previous function.\n\t  Export quagga_gettime, quagga_time and recent_relative_time for \n\t  general use.\n\n2006-07-25 Paul Jakma <paul.jakma@sun.com>\n\n\t* thread.h: (struct thread) Add a cache pointer to the struct\n\t  cpu_thread_history, if it is known - saving hash lookup on\n\t  each thread_call.\n\t* thread.c: (thread_call) Cache the pointer to the\n          cpu_thread_history, so that future thread_calls of same\n          thread can avoid the hash_lookup.\n\n2006-07-10 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* vty.c: (vty_log_out) Do not call vty_close, because this could\n\t  result in a parent function's accessing the freed memory.\n\t  Instead, set status VTY_CLOSE and call shutdown(vty->fd, SHUT_RDWR).\n\t  And add a comment on vty_close.\n\n2006-07-10 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* vty.c: (vty_log_out, vty_read, vty_flush, vtysh_flush, vtysh_read)\n\t  After an I/O error, must set vty->monitor to 0 before calling\n\t  zlog_warn, otherwise an infinite recursion could occur\n\t  (since zlog_warn triggers a message to be written to the vty,\n\t  and that in turn triggers another error message when it fails, etc.).\n\n2006-07-03 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* vty.c: (vty_log_out) Debug messages to terminal vty sessions\n\t  should include timestamps.\n\n2006-06-28 Paul Jakma <paul.jakma@sun.com>\n\n\t* memory.c: Fix typo in cpp conditional around malloc.h, from\n\t  comment in bug #269.\n\n2006-06-27 Paul Jakma <paul.jakma@sun.com>\n\n\t* route_types.awk: Remove setting the 'bare' numeric route type\n\t  in redist strings.\n\n2006-06-15 Paul Jakma <paul.jakma@sun.com>\n\n\t* command.c: (cmd_describe_command_real) Fix leak, CID #38.\n\t* memory.h: Experimental, have XFREE macro NULL out the freed\n\t  pointer.\n\t* linklist.c: (list_delete) call list_delete_all_node, don't\n\t  duplicate it.\n\t* if.c: (if_flag_dump) remove the whitespace indentation, callers\n\t  should provide.\n\n2006-05-28 Paul Jakma <paul.jakma@sun.com>\n\n\t* zebra.h: Include inttypes.h rather than stdint.h, best practice\n\t  according to the autoconf manual.\n\t  Add UINT*_MAX defines for older platforms lacking these (FBSD 4)\n\t* memory.c: malloc.h is deprecated in favour of stdlib.h, however\n\t  we still need it on GNU Libc for mallinfo().\n\t* vty.c: (vty_log/vty_log_fixed) dont crash if called when vty\n\t  hasn't been initiliased.\n\t* log.c: (general) Add support for Sun libc printstack().\n\t  (hex_append) make the cpp conditional on general HAVE_STACK_TRACE\n\t  define.\n\t  (zlog_backtrace_sigsafe) Ditto. Add printstack() version of the\n\t  the DUMP macro in this function.\n\n2006-05-23 Paul Jakma <paul.jakma@sun.com>\n\n\t* route_types.txt: New file, table of ZEBRA_ROUTE definitions.\n\t* route_types.awk: New script, to parse previous and generate\n\t  (for now) redistribute string defines.\n\t* Makefile.am: build route_types.h using previous two, ala\n\t  memtypes.h, include the script and table file in EXTRA_DIST.\n\t* command.h: pull in route_types.h, add a REDIST_STR define.\n\n2006-05-21 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* if.h: (struct connected) Document the meaning of the\n\t  ZEBRA_IFC_REAL and ZEBRA_IFC_CONFIGURED flags.\n\n2006-05-15 Paul Jakma <paul.jakma@sun.com>\n\n\t* log.c: (general) Generalise struct zebra_route_desc into\n\t  struct zebra_desc_table and, similar to route_types, add a\n\t  command_types table to describe Zserv protocol commands.\n\t  (route_types[]) use a macro to use designated initialisers\n\t  while avoiding tedious duplication.\n\t  (zserv_command_string) lookup string from zebra_desc_table,\n\t  similar to zebra_route_string\n\t* zebra.h: Add declaration for zserv_command_string, adjust the\n\t  comments to reflect zebra_desc_table.\n\n2006-05-13 Paul Jakma <paul.jakma@sun.com>\n\n\t* vty.c: (vty_describe_command) CID #39 fix was too hasty, just\n\t  cause it /can/ leak doesn't mean it always will have, check\n\t  first.\n\n2006-05-12 Paul Jakma <paul.jakma@sun.com>\n\n\t* plist.c: (vty_prefix_list_uninstall) Fix potential NULL deref\n\t  of prefix and typestr strings, Coverity CID #3.\n\t* command.c: (cmd_complete_command_real) Fix leak of cmd_vector\n\t  in error case, Coverity CID #37.\n\t  (cmd_describe_command_real) Fix return of freed pointer when\n\t  no-match, CID #55.\n\t* vty.c: (vty_describe_command) fix leak of describe vector in\n\t  error path, CID #39.\n\n2006-03-30 Paul Jakma <paul.jakma@sun.com>\n\n\t* command.h: (DEFUN_CMD_FUNC_TEXT) Annotate arguments as\n\t  potentially being unused.\n\t* workqueue.c: (work_queue_run) fix line length of comment\n\n2006-03-27 Paul Jakma <paul.jakma@sun.com>\n\n\t* memtypes.awk: Fix gensub call, g should be a string..\n\n2006-03-25 Paul Jakma <paul.jakma@sun.com>\n\n\t* workqueue.h: (struct work_queue) Remove status field and\n\t  state flag, no longer used.\n\n2006-03-19 Paul Jakma <paul.jakma@sun.com>\n\n\t* memtypes.c: Add MTYPE_BGP_SYNCHRONISE.\n\n2006-03-16 Paul Jakma <paul.jakma@sun.com>\n\n\t* Makefile.am: Fix -version-info argument.\n\n2006-03-15 Paul Jakma <paul.jakma@sun.com>\n\n\t* memory.c: (mtype_memstr) new helper function to \n\t  return human friendly string for a byte count.\n\t  (mtype_stats_alloc) new function, for users to retrieve\n\t  number of objects allocated.\n\t  (show_memory_mallinfo) New function, show mallinfo statistics\n\t  if available.\n\t  (show_memory_all_cmd) Call show_memory_mallinfo, if mallinfo\n\t  is available.\n\t* memory.h: Export mtype_memstr and mtype_stats_alloc.\n\t  Provide a define for a reasonable buffer size for\n\t  mtype_memstr.\n\t  \n2006-03-14 Paul Jakma <paul.jakma@sun.com>\n\n\t* privs.c: (zprivs_caps_init) Change user IDs before lowering\n\t  privileges, while this seems to work on Linux, on Solaris\n\t  it rightfully refuses due to PRIV_PROC_SETID having been\n\t  dropped.\n\t* command.h: Add the struct host global exported from command.c\n\n2006-03-06 Paul Jakma <paul.jakma@sun.com>\n\n\t* if.h: export show_address_cmd, for anyone who wishes to use\n\t  it.\n\n2006-02-21 Paul Jakma <paul.jakma@sun.com>\n\n\t* sockunion.c: (sockunion_{su2str,log}) Use XSTRDUP.\n\t  Particularly with _su2str, as that string gets XFREEd,\n\t  which can be annoying if run debug code in memory.c.\n\n2006-02-02 Paul Jakma <paul.jakma@sun.com>\n\n\t* workqueue.h: (struct work_queue) Remove the delay field.\n\t  It served no purpose and just introduced bad behaviour.\n\t  Should be excised before its allowed to escape into 1.0.\n\t  This removes need for the 'flood' and runs_since_clear\n\t  fields.\n\t* workqueue.c: (general) excise delay factor between queue\n\t  runs, hence the 'flood' crap too.. See above.\n\n2006-01-19 Paul Jakma <paul.jakma@sun.com>\n\n\t* stream.c: (stream_getq_from) should use POSIX uint64_t\n\t  not u_int64_t. Latter is neither a traditional BSD type, nor\n\t  a POSIX type.\n\n2006-01-17 Vincent Jardin <vincent.jardin@6wind.com>\n\n\t* md5.c: Don't forget to keep const.\n\t* regex.c: Cleanup code and remove warnings.\n\n2006-01-17 Paul Jakma <paul.jakma@sun.com>\n\n\t* md5.{c,h}: (md5_loop) Is better off taking a void * and doing\n\t  cast to byte wise type internally, avoids needs for casts \n\t  in users.\n\t* vty.c: (no_terminal_monitor_cmd) New ALIAS for \n\t  terminal_no_monitor, in the more normal negating format,\n\t  to be kind to my fingers.\n\t  (vty_init) install new ALIAS.\n\t* zclient.{c,h}: (zclient_create_header) export this, seems others\n\t  could use it (in lieu of more complete zserv helpers).\n\n2006-01-16 Paul Jakma <paul.jakma@sun.com>\n\n\t* zclient.h: Update the Zserv protocol header with a version\n\t  field.  Define the old command field to be a 'marker', to\n\t  allow old Zserv and updated Zserv to be differentiated.\n\t  Future updates will bump the version field obviously. New\n\t  command field is made wider.  Try to stop using the\n\t  'zebra_size_t' typedef in the callbacks.\n\t* zclient.c: Update to read/write new format header.\n\n2006-01-11 Paul Jakma <paul.jakma@sun.com>\n\n\t* if.h: (struct interface) expand flags to 8 bytes.\n\t* zclient.c: (zebra_interface_{add,state}_read) stream read of\n\t  interface flags now need to use stream_getq.\n\t  (zebra_interface_if_set_value) ditto\n\n2006-01-10 Paul Jakma <paul.jakma@sun.com>\n\n\t* stream.c: (stream_new) Allocate stream data as seperate object.\n\t  (stream_free) free the data.\n\t  (stream_resize) new function, resize stream to new size.\n\t  (stream_{get,put}q*) new functions to get/put quad word size\n\t  types.\n\t* stream.h: (struct stream) make data seperate from the stream.\n\t  Export new stream_resize and quad-word get/put functions.\n\t  \n2005-12-29  Greg Troxel  <gdt@fnord.ir.bbn.com>\n\n\t* vty.c (vty_hello): add cast to quiet lint (from David Young)\n\n2005-11-26 Paul Jakma <paul.jakma@sun.com>\n\n\t* buffer.c: (struct buffer_data) change gcc zero array\n\t  declaration to C99 incomplete array.\n\t* stream.h: (struct stream) same\n\n2005-11-24 Paul Jakma <paul.jakma@sun.com>\n\n\t* privs.c: (zcaps2sys/solaris) remove unused variable.\n\t  (zprivs_state_caps/solaris) Format string missing a\n\t  specifier.\n\t* zebra.h: s/u_int/unsigned int/, u_int is a BSD type, defining\n\t  __USE_BSD on Linux pulls in further things from netinet/ip.h\n\t  which dont preprocess for some reason. There is no C99\n\t  shorthand type directly equivalent to u_int afaict, so don't\n\t  use it.\n\n2005-11-14 Paul Jakma <paul.jakma@sun.com>\n\n\t* (general) pass struct work-queue to callback functions.\n\t* workqueue.h: (struct work_queue) move the state flag\n\t  variables to end.\n\t  Add an opaque pointer to spec, for user-data global to the\n\t  queue.\n\t  Pass reference to work_queue to all callbacks.\n\t* workqueue.c: (work_queue_item_remove) pass ref to workqueue\n\t  to user callbacks.\n\t  (work_queue_run) ditto.\n\n2005-11-14 Paul Jakma <paul.jakma@sun.com>\n\n\t* (general) Add state to detect queue floods.  There's no sense\n\t  trying to be sparing of CPU resources, if the queue is\n\t  flooding and using ever more memory resources. we should just\n\t  get on with clearing the queue.\n\t  The sense of delay and hold were wrong way around, fix.\n\t* workqueue.h: (struct work_queue) Add status bitfield.  Add\n\t  'flood' integer to workqueue spec.  Add runs_since_clear\n\t  counter to workqueue.\n\t* workqueue.c: (work_queue_new) set defaults for delay, hold\n\t  and flood.\n\t  (work_queue_add) initial schedule should use delay, not hold.\n\t  (show_work_queues) Print flood field, conserve whitespace.\n\t  (work_queue_unplug) use delay, not hold.\n\t  (work_queue_run) consecutive runs should be seperated by hold\n\t  time, not delay.\n\t  Keep track of number of consecutive runs, go into 'overdrive'\n\t  if queue is being flooded, we can't avoid making heavy use of \n\t  resources, better to use CPU than ever more RAM.\n\t* zebra.h: [bug #231] include stdint, if its there.\n\n2005-11-05 Paul Jakma <paul.jakma@sun.com>\n\n\t* routemap.c: (vty_show_route_map_entry) call action is\n\t  seperate from exit action, latter should still be printed\n\t  regardless of whether a call is specified.\n\n2005-11-03 Paul Jakma <paul.jakma@sun.com>\n\n\t* zebra.h: BSD BYTE_ORDER define isn't available everywhere,\n\t  define if needs be.\n\t* checksum.h: new file. checksum.c exports in_cksum, provide\n\t  a header for it.\n\t* checksum.c: (in_cksum) callers shouldn't have to know it uses\n\t  a u_short internally, change to void *.\n\t* Makefile.am: Add checksum.h\n\t* command.h: remove bogus trailling slash.\n\t* md5.c: (general) Update it for the twentieth century. ANSI\n\t  declarations are widely supported now.. Don't include system\n\t  headers, only include zebra.h. Use POSIX types (the\n\t  alternative is to define u_int64_t in a portable way - rest\n\t  of Quagga needs same cleanup).\n\t  Make endian-conditional code be compiler conditional rather\n\t  than preprocessor conditional, so that breakage gets noticed\n\t  quicker.\n\t* md5.h: POSIX types. Get rid of the odd __P() non-ANSI capable\n\t  compiler compatibility hack.\n\t* if.c: (connected_free) use MTYPE for connected label.\n\t* memtypes.c: Add MTYPE_CONNECTED_LABEL\n\t* memtypes.h: Update auto-built file.\n\n2005-10-26 Paul Jakma <paul.jakma@sun.com>\n\n\t* (general) Cleanup a some calls to XFREE,strdup, etc. to use\n\t  the memory.h macros.\n\t* memtypes.c: Add MTYPE_IF_RMAP_NAME, MTYPE_PQUEUE,\n\t  MTYPE_PQUEUE_DATA and MTYPE_HOST.\n\t* memtypes.h: update auto-built file.\n\t* if_rmap.c: Use MTYPE_IF_RMAP_NAME.\n\t* pqueue.c: Use the two MTYPE_PQUEUE mtypes for allocations.\n\t* command.c: Use MTYPE_HOST, MTYPE_STRVEC. Some other fixups,\n\t  including fixing some likely leaks in config_write_file.\n\t* vty.c: memory macro usage fixes. \n\t  (vty_read_config) fix leak where relative config file is\n\t  specified.\n\n2005-10-20 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* sockopt.c: (setsockopt_multicast_ipv4) If IP_ADD_MEMBERSHIP\n\t  fails with errno equal to EADDRINUSE, then issue an info\n\t  message and try IP_DROP_MEMBERSHIP followed by IP_ADD_MEMBERSHIP.\n\n2005-10-20 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* memory.c: (show_memory_vty) Omit zero statistics.  Print separators\n\t  only if some non-zero stats have been printed in between.\n\t  (show_separator) New function to print a separator.\n\t  (show_memory_all) Keep track of whether a separator is needed\n\t  between the different memory statistics groups.\n\n2005-10-18 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* memtypes.h: Add MTYPE_OSPF_VERTEX_PARENT (to match memtypes.c).\n\n2005-10-18 Paul Jakma <paul.jakma@sun.com>\n\n\t* memtypes.c: (memory_list_ospf) Add MTYPE_OSPF_VERTEX_PARENT.\n\n2005-10-01 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* zebra.h: Declare new functions zebra_route_string() and\n\t  zebra_route_char().\n\t* log.c: (zroute_lookup,zebra_route_string,zebra_route_char) New\n\t  functions to map zebra route numbers to strings.\n\n2005-09-29 Alain Ritoux <alain.ritoux@6wind.com>\n\n\t* smux.[ch]: allow to retreive global OID (identified by <0\n\t  namelen).\n\n2005-09-29 Paul Jakma <paul.jakma@sun.com>\n\n\t* zebra.h: Solaris capabilities requires priv.h to be included.\n\t* privs.{c,h}: Add support for Solaris Least-Privileges.\n\t  privs.h: Reduce some of the abstract capabilities, which do\n\t  not have rough equivalents on both systems. Rename the net\n\t  related caps to _NET, as they should have been in first\n\t  place.\n\t  (zprivs_terminate) should take the zebra_privs_t as argument so\n\t  that it can update change pointer.\n\t  Add an additional privilege state, ZPRIVS_UNKNOWN.\n\t* privs.c: (various capability functions) Add\n\t  Solaris privileges variants.\n\t  (zprivs_state) Use privs.c specific generic types to\n          represent various capability/privilege related types, so that\n          each can be typedef'd as appropriate on each platform.\n\t  (zprivs_null_state) static added, to hold the state the null\n\t  method should report (should be raised by default, and\n          LOWERED if zprivs_terminate has been called)\n          (zprivs_state_null) Report back the zprivs_null_state.\n          (cap_map) Make it able to map abstract capability to multiple\n          system capabilities.\n          (zcaps2sys) Map to abstract capabilities to multiple system\n          privileges/capabilities.\n          (zprivs_init) move capability related init to seperate\n\t  function, zprivs_caps_init.\n          (zprivs_terminate) ditto, moved to zprivs_caps_terminate.\n          Set the change_state callback to the NULL state, so the\n          user can continue to run and use the callbacks.\n          \n2005-09-29 Alain Ritoux <alain.ritoux@6wind.com>\n\n\t* filer.c: show protocol name in filter_show()\n\t* plist.c: show protocol name in vty_show_prefix_entry()\n\t* routemap.c: show protocol name in vty_show_route_map_entry()\n\t* vty.c: in vty_command(), show protocol name if command unknown\n\t\n2005-09-28 Alain Ritoux <alain.ritoux@6wind.com>\n\n\t* md5-gnu.h: removed\n\t* md5.h: replaces md5-gnu.h\n\t* Makefile.am: use correct md5.h\n\t* md5.c: import from WIDE\n\n2005-09-21 Paul Jakma <paul.jakma@sun.com>\n\n\t* memtypes.{c,h}: Add MTYPE_AS_SEG_DATA.\n\t\n2005-09-19 Hasso Tepper <hasso at quagga.net>\n\n\t* str.[ch]: Add strndup() from glibc.\n\n2005-09-05 Paul Jakma <paul.jakma@sun.com>\n\n\t* command.c: (install_element) be more robust. Eg, cmd_init\n\t  need not have been called, some applications may use other\n\t  library subsystems, which call install_element, without the\n          application wanting commands and hence not calling cmd_init.\n        \n2005-08-22 Hugo Santos <hsantos@av.it.pt>\n\n\t* command.h: (enum node_type) Add BGP_IPV6M_NODE \n\t* command.c: (node_parent) Handle BGP_IPV6M_NODE node\n\t  (config_exit, config_end) ditto\n\t* vty.c: (vty_end_config) Handle BGP_IPV6M_NODE node\n\t\n2005-08-10  Greg Troxel  <gdt@fnord.ir.bbn.com>\n\n\t* getopt.h: Don't declare getopt (rather than getopt_long), since\n\tquagga doesn't need it.\n\t* getopt.c (getopt): Don't define getopt.\n\n2005-07-26 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\t* prefix.c: (prefix_ipv4_new, prefix_ipv6_new): Call prefix_new\n\t  to allocate the memory to make sure that all struct prefix pointers\n\t  point to objects of the same length (avoids memory overruns\n\t  on struct prefix assignments).\n\t  (prefix_ipv4_free, prefix_ipv6_free): Simply call prefix_free.\n\t  It is interesting to note that these functions are never actually\n\t  called anywhere in the code.  Instead prefix_free was already\n\t  being called directly, despite the previous MTYPE incompatibility.\n\n2005-07-26 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* prefix.c: (ip_masklen) While loop should test that 'pnt' pointer is\n\t  in range before dereferencing it.\n\n2005-06-24 Pawel Worach <pawel.worach@gmail.com>\n\n\t* getopt.h: add further tests for full getopt declaration on\n\t  various systems.\n\n2005-06-18 Paul Jakma <paul.jakma@sun.com>\n\n\t* memtypes.h: update autobuilt file to match memtypes.c changes\n\n2005-06-01 Paul Jakma <paul.jakma@sun.com>\n\n\t* memtypes.c: Add MTYPE_BGP_PROCESS_QUEUE and\n\t  MTYPE_BGP_CLEAR_NODE_QUEUE\n\n2005-05-24 Paul Jakma <paul@dishone.st>\n\n\t* memtypes.h: update this auto-built file. (maybe we should just\n\t  remove it, is GNU awk a terrible dependency to have?)\n\n2005-05-23 Paul Jakma <paul@dishone.st>\n\n\t* memtypes.awk: use character classes, which work correctly in\n\t  all LC_COLLATE environments, unlike A-Z, which doesnt work in\n\t  eg estonian collate order. Reported by Hasso.\n\t* routemap.c: (rmap_onmatch_goto) fix crash if 'continue' command\n\t  is used, which does not supply an argv[0].\n\t  this is a backport candidate /iff/ the trailing ; is removed\n\t  from VTY_GET_INTEGER_RANGE\n\t* vty.h: fix the VTY_GET macros, do {..} while(0) so they have\n\t  correct function like syntax in usage.\n\t* workqueue.h: Add a WQ_QUEUE_BLOCKED item_status return code,\n\t  to allow a queue function to indicate the queue is not\n\t  ready/blocked - rather than any problem with the item at hand.\n\t  Add a notion of being able to 'plug' and 'unplug' a queue.\n\t  Add helpers to plug/unplug a queue.\n\t  Add a completion callback, to be called when a queue is emptied.\n\t* workqueue.c: (work_queue_new) remove useless list_free.\n\t  (work_queue_schedule) new internal helper function to schedule\n\t  queue, if appropriate.\n\t  (work_queue_add) use work_queue_schedule\n\t  (show_work_queues) Print 'P' if queue is plugged.\n\t  (work_queue_plug) new API function, plug a queue - ie prevent it\n\t  from 'drained' / processed / scheduled.\n\t  (work_queue_unplug) unplug a queue, allowing it to be drained\n\t  / scheduled / processed again.\n\t  (work_queue_run) Add support for WQ_QUEUE_BLOCKED.\n\t  Add comment for RETRY_NOW case.\n\t  Make hysteris more aggresive in ramping up granularity, improves\n\t  performance significantly.\n\t  Add support for calling completion callback when queue is emptied,\n\t  possibly useful for knowing when to unplug a queue.\n\n2005-05-19 Paul Jakma <paul@dishone.st>\n\n\t* thread.c: (thread_cancel_event) the number of pending events\n\t  cancelled is potentially useful information, dont throw it away,\n\t  pass it back to the caller.\n\t* sockunion.c: (sockunion_getsockname) use MTYPE_SOCKUNION, not TMP\n\t  (sockunion_getpeername) ditto\n\t* memtypes.c: (memory_list_bgp) add MTYPE_BGP_PEER_HOST\n\n2005-05-15 Paul Jakma <paul@dishone.st>\n\n\t* getopt.h: It's not just __GNU_LIBRARY__ which defines\n\t  getopt, eg __EXTENSIONS__ does too on SunOS. It still seems\n\t  awfully fragile though.\n\t* getopt.c: include zebra.h after config.h, before including\n\t  getopt.h so that things at least are consistent..\n\t* getopt1.c: ditto\n\t\n2005-05-07 Yar Tikhiy <yar@comp.chem.msu.su>\n\n\t* sockopt.c: Add support for BSD style ifindex in ip_mreq.\n\n2005-05-06 Paul Jakma <paul@dishone.st>\n\n\t* (general) extern and static'ification of functions in code and\n\t  header.\n\t  Cleanup any definitions with unspecified arguments.\n\t  Add casts for callback assignments where the callback is defined,\n\t  typically, as passing void *, but the function being assigned has\n\t  some other pointer type defined as its argument, as gcc complains \n\t  about casts from void * to X* via function arguments.\n\t  Fix some old K&R style function argument definitions.\n\t  Add noreturn gcc attribute to some functions, as appropriate.\n\t  Add unused gcc attribute to some functions (eg ones meant to help\n\t  while debugging)\n\t  Add guard defines to headers which were missing them.\n\t* command.c: (install_node) add const qualifier, still doesnt shut\n\t  up the warning though, because of the double pointer.\n\t  (cmp_node) ditto\n\t* keychain.c: (key_str2time) Add GET_LONG_RANGE() macro, derived \n\t  fromn vty.h ones to fix some of the (long) < 0 warnings.\n\t* thread.c: (various) use thread_empty\n\t  (cpu_record_hash_key) should cast to uintptr_t, a stdint.h type\n\t* vty.h: Add VTY_GET_IPV4_ADDRESS and VTY_GET_IPV4_PREFIX so they\n\t  removed from ospfd/ospf_vty.h\n\t* zebra.h: Move definition of ZEBRA_PORT to here, to remove\n\t  dependence of lib on zebra/zserv.h\n\n2005-05-06 Hasso Tepper <hasso at quagga.net>\n\n\t* sockunion.c: Fix warning message.\n\n2005-05-03 Paul Jakma <paul@dishone.st>\n\n\t* stream.h: Add comment about the special zero-ing ability of\n\t  stream_put.\n\t  (stream_recvmsg, stream_write) should return ssize_t and size_t\n\t  respectively. Should both be extern linkage.\n\t  (stream_recvfrom) Stream aware wrapper around recvfrom, in style\n\t  of stream_read_try.\n\t* stream.c: (stream_recvfrom) new function, wrapper around recvfrom.\n\t  (stream_recvmsg, stream_write) ssize_t and size_t return values\n\t  \n2005-04-27 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\tAdd wall-clock timing statistics to 'show thread cpu' output.\n\t* thread.h: Define struct rusage_t to contain wall-clock time\n\t  and cpu time.  Change GETRUSAGE macro to collect both pieces\n\t  of data.  Make appropriate changes to struct cpu_thread_history\n\t  to track CPU time and real time.  Change proto for\n\t  thread_consumed_time to return real and cpu time elapsed.\n\t  And declare a new global variable 'struct timeval recent_time'.\n\t* thread.c (struct timeval recent_time): New global timestamp variable.\n\t  (timeval_adjust): If timeout is negative, set to 0 (not 10\n\t  microseconds).  And remove upper bound of 1,000,000 seconds, since\n\t  this does not seem to make any sense (and it breaks\n\t  funcname_thread_add_timer_timeval).\n\t  (timeval_cmp): Should return long, not int.\n\t  (vty_out_cpu_thread_history): Show CPU time and real time.\n\t  (cpu_record_hash_print): Calculate totals for CPU and real time.\n\t  (cpu_record_print): Change 'show thread cpu' title to show CPU and\n\t  real time.\n\t  (thread_timer_remain_second): Put current time in global recent_time.\n\t  (funcname_thread_add_timer_timeval): Fix assert.  Replace 2-case\n\t  switch assignment with a ternary expression.  Use global recent_time\n\t  variable.  Fix use of timeval_adjust (previously, the value was not\n\t  actually being adjusted).\n\t  (thread_cancel): Add missing \"break\" statement in case\n\t  THREAD_BACKGROUND.\n\t  (thread_timer_wait): Use global recent_time value instead of calling\n\t  gettimeofday.  And there's no need to check for negative timeouts,\n\t  since timeval_subtract already sets these to zero.\n\t  (thread_timer_process): Timers are sorted, so bail out once we\n\t  encounter a timer that has not yet popped.  And remove some\n\t  extraneous asserts.\n\t  (thread_fetch): Do not process foreground timers before calling\n\t  select.  Instead, add them to the ready list just after the select.\n\t  Also, no need to maintain a count of the number of ready threads,\n\t  since we don't care how many there are, just whether there's\n\t  one at the head of the ready list (which is easily checked).\n\t  Stick current time in global variable recent_time to reduce\n\t  the number of calls to gettimeofday.  Tighten logic for\n\t  calculating the select timeout.\n\t  (thread_consumed_time): Now returns real time and puts the elapsed\n\t  cpu time in an additional argument.\n\t  (thread_should_yield): Use real (wall-clock) time to decide whether\n\t  to yield.\n\t  (thread_call): Maintain CPU and real time statistics.\n\t* vty.c (vty_command): For slow commands, show real and cpu time.\n\n2005-04-27 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* workqueue.c (show_work_queues): Remove unused gettimeofday call.\n\n2005-04-27 Paul Jakma <paul.jakma@sun.com>\n\n\t* workqueue.h: (struct work_queue_item) change retry_count to ran,\n\t  its a count of number item has been run.\n\t* workqueue.c: (show_work_queues) Fix formating of slightly\n\t  bugfix: fix SIGFPE if wq->runs is 0.\n\t  (work_queue_run) retry logic was slightly wrong.\n\t  cycles.best is 0 initialy, granularity is 1, so update best\n\t  if cycles >= granularity, not just >.\n\t* memory.h: memtypes is built source, default includes points to\n\t  top_builddir, so we should refer to lib/memtypes.h\n\n2005-04-26 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* buffer.c (buffer_write): Comment out call to buffer_flush_available.\n\t  This should speed up buffering at the expense of a possible increase\n\t  in latency in flushing the data if inside a long-running thread.\n\n2005-04-25 Paul Jakma <paul.jakma@sun.com>\n\n\t* workqueue.{c,h}: Helper API for setting up and running queues via\n\t  background threads.\n\t* command.c: install the 'show workqueues' command\n\t* memtypes.c: Add work queue mtypes, and a rib-queue type for\n\t  a zebra rib work queue.\n\t* memtypes.h: Updated to match memtypes.c\n\t* Makefile.am: Refer to source files via srcdir variable, fix\n\t  out-of-tree build breakage.\n\t  Add new workqueue files to build.\n\t* memory.c: Make the string field much wider\n\t* memtypes.c: Correct the prefix list str/entry strings\n\t* thread.c: Kill unused TIMER_NO_SORT bits\n\n2005-04-22 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* thread.h: Fix type for struct thread_master add_type: should be\n\t  unsigned char.  Also, add some documentation of thread_add_background\n\t  args.  And remove extraneous declaration of\n\t  show_thread_work_queues_cmd.\n\n2005-04-22 Paul Jakma <paul.jakma@sun.com>\n\n\t* memory.h: Move include of memtypes.h to after the definition of\n\t  struct memory_list, gcc 4.0 doesn't like arrays of incomplete \n\t  types.\n\t* thread.h: Add background thread type and thread_add_background\n\t  macro and accompanying funcname_... function.\n\t  export thread_should_yield, background threads can use it.\n\t  Lower thread yield time to 10ms, 100ms is noticeable lag and\n\t  a thread would only be /starting/ to finish sometime afterward.\n\t* thread.c: (general) Add background thread type and schedule\n\t  nearly all thread types through the ready list for fairness.\n\t  (timeval_adjust) static qualifier missing\n\t  (vty_out_cpu_thread_history) add support for printout of \n\t  background threads\n\t  (show_thread_cpu) ditto.\n\t  (thread_master_debug) add debug of background list\n\t  (thread_master_create) fixup long line\n\t  (thread_add_unuse) add asserts for required state.\n\t  (thread_master_free) free background thread list\n\t  (funcname_thread_add_timer_timeval) make generic, able to \n\t  support arbitrary timer-like thread types.\n\t  (funcname_thread_add_timer) pass thread type to .._add_timer_timeval\n\t  (funcname_thread_add_timer_msec) ditto\n\t  (funcname_thread_add_background) Add a background thread, with an\n\t  optional millisecond delay factor, using .._add_timer_timeval.\n\t  (thread_cancel) Add background thread type.\n\t  Move the thread_list_delete common to all cases to bottom of\n\t  function, after the switch statement..\n\t  (thread_cancel_event) indent\n\t  (thread_timer_wait) Static qualifier, and make it able to cope\n\t  with arbitrary timer-like thread lists, so its of use to\n\t  background threads too.\n\t  (thread_process_fd) static qualifier. Again, make it take a list\n\t  reference rather than thread_master. Fix indentation.\n\t  (thread_timer_process) Check for ready timer-like threads in the\n\t  given list and move them on to the ready list - code originally\n\t  embedded in thread_fetch.\n\t  (thread_fetch) Schedule all threads, other than events, through\n\t  the ready list, to ensure fairness. Timer readying code moved to\n\t  thread_timer_process so it can be reused for background threads.\n\t  Remove the unneeded quagga_sigevent_process, as pointed out by\n\t  John Lin <john.ch.lin@gmail.com>.\n\t  (thread_should_yield) make this available.\n\t\n2005-04-16 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* thread.h (thread_consumed_time): Declare new function to calculate\n\t  elapsed microseconds.\n\t* thread.c (thread_consumed_time): Must be global not static so we\n\t  can call it from lib/vty.c:vty_command.\n\t  (thread_should_yield): Surround with `#if 0' to make clear that this\n\t  function is not currently being used anywhere.\n\t  (thread_call): If CONSUMED_TIME_CHECK is defined, print a CPU HOG\n\t  warning message if the thread takes more than CONSUMED_TIME_CHECK\n\t  microseconds.\n\t* vty.c (vty_command): If CONSUMED_TIME_CHECK is defined, print a CPU\n\t  HOG warning message if the command takes more than CONSUMED_TIME_CHECK\n\t  microseconds.\n\n2005-04-16 Paul Jakma <paul@dishone.st>\n\n\t* memtypes.c: the comment about use of comments in the comments\n\t  headers was causing comment within comment warnings from compiler\n\t* memtypes.awk: Add extensive comments on the file format for\n\t  memtypes.c.\n\t  tighten the pattern for the MTYPE matching action (suggestion from\n\t  Andrew) and tighten which field we try the match on.\n\n2005-04-15 Paul Jakma <paul@dishone.st>\n\n\t* memtypes.c: The new, unified location for memory type definitions.\n\t  The memtype enum and declarations for memory_lists are built from\n          this automatically and put into memtypes.h.\n        * memtypes.awk: New script to generate memtypes.h from memtypes.c\n        * memory.h: Finally, the enum can banished!\n        * memory.c: Finally, the seperate mtype memory_list definitions can\n          be banished!\n          (log_memstats) Increase width of fields\n          (show_memory_zebra_cmd) display zebra specific memory types.\n          Increase width of fields.\n        * Makefile.am: Add memtypes.{c,h}, add BUILT_SOURCES for memtypes.h\n          Add a rule to build memtypes.h using memtypes.awk.\n          Add memtypes.awk to EXTRA_DIST.\n\t  memtypes.awk is gawk dependent, use the GAWK automake var.\n\t* memtypes.h: New file, auto-generated, checked in for convenience.\n\n2005-04-11 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* zclient.h (struct zclient): Add two fields to support non-blocking\n\t  I/O: struct buffer *wb, and struct thread *t_write.\n\t  (zclient_free): Remove function.\n\t  (zebra_redistribute_send): Change 2nd arg from socket fd to\n\t  struct zclient * (needed to support non-blocking I/O and buffering).\n\t  (zclient_send_message): New function to send an arbitrary\n\t  message with non-blocking I/O.\n\t* zclient.c (zclient_new): Create write buffer.\n\t  (zclient_free): Remove unused function.\n\t  (zclient_stop): Must cancel new t_write thread.  Also, reset\n\t  all buffers: ibuf, obuf, and wb.\n\t  (zclient_failed): New helper function for typical error handling.\n\t  (zclient_flush_data): New thread to flush queued data.\n\t  (zclient_send_message): New function to send the message in\n\t  zclient->obuf to zebra using non-blocking I/O and buffering.\n\t  (zebra_message_send, zapi_ipv4_route, zapi_ipv6_route): Use\n\t  new zclient_send_message function instead of calling writen.\n\t  (zclient_start): Set socket non-blocking.  Also, change 2nd arg\n\t  to zebra_redistribute_send from zclient->sock to zclient.\n\t  (zebra_redistribute_send): Change 2nd arg to struct zclient *.\n\t  Can now use zclient->obuf to assemble the message instead of\n\t  allocating a temporary stream.  And call zclient_send_message to\n\t  send the message instead of writen. \n\t  (zclient_read): Convert to support non-blocking I/O by using\n\t  stream_read_try instead of deprecated stream_read.\n\t  (zclient_redistribute): Change 2nd arg to zebra_redistribute_send\n\t  from zclient->sock to zclient.\n\n2005-04-09 Jeroen Simonetti <jeroens@office.netland.nl>\n\n\t* routemap.c: Show description in \"show route-map\" output.\n\n2005-04-08 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* sigevent.c: On GNU_LINUX, check whether __USE_GNU is already defined.\n\n2005-04-08 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* vty.c: (vty_log_fixed) Use casts to (void *) to try to eliminate\n\t  compiler warnings when assigning a (const char *) value to\n\t  struct iovec iov_base.\n\n2005-04-08 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* zebra.h: If GNU_LINUX is defined, then define _GNU_SOURCE.  This\n\t  fixes a problem where we were not getting the declaration of strnlen\n\t  in <string.h>.\n\n2005-04-08 Hasso Tepper <hasso at quagga.net>\n\n\t* routemap.[ch]: Added \"description ...\" command.\n\n2005-04-08 Hasso Tepper <hasso at quagga.net>\n\n\t* prefix.[hc]: Pass argument to the inet6_ntoa by value making it more\n\t  inet_ntoa alike.\n\n2005-04-07 Paul Jakma <paul.jakma@sun.com>\n\n\t* linklist.h: Add usage comments.\t  \n\t  Rename getdata macro to listgetdata.\n\t  Rename nextnode to listnextnode and fix its odd behaviour to be\n\t  less dangerous.\n\t  Make listgetdata macro assert node is not null, NULL list entries\n          should be bug condition.\n          ALL_LIST_ELEMENTS, new macro, forward-referencing macro for use\n          with for loop, Suggested by Jim Carlson of Sun.\n          Add ALL_LIST_ELEMENTS_RO for cases which obviously do not need the\n          \"safety\" of previous macro.\n\t  LISTNODE_ADD and DELETE macros renamed to ATTACH, DETACH, to\n\t  distinguish from the similarly named functions, and reflect their\n\t  effect better.\n\t  Add a QUAGGA_NO_DEPRECATED_INTERFACES define guarded section \n\t  with the old defines which were modified above, \n\t  for backwards compatibility - guarded to prevent Quagga using it..\n\t* linklist.c: fix up for linklist.h changes.\n\t* *.c: fix up for new list loop macro, try audit other loop\n          usage at same time, to some degree.\n\n2004-04-05 Hasso Tepper <hasso at quagga.net>\n\n\t* lib/prefix.[hc]: inet6_ntoa utility function copied from\n\t  ripngd/ripngd.c (inet6_ntop).\n\n2004-04-05 Paul Jakma <paul@dishone.st>\n\n\t* vty.c: Improve logging of failures to open vty socket(s).\n\t  See bugid #163.\n\n2005-04-02 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* if.h: Fix comments to reflect that if_lookup_by_name and\n\t  if_get_by_name now require the argument strings to be NUL-terminated.\n\t* if.c: (if_lookup_by_name) Compare using strcmp.\n\t  (if_get_by_name) Pass strlen(ifname) as 2nd arg to if_create.\n\n2005-04-02 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* if.c: (if_nametoindex) The man page is rather vague, but it seems\n\t  like the argument to if_nametoindex has an implicit maximum length\n\t  of IFNAMSIZ characters.\n\n2005-04-02 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* if.h: (if_lookup_by_name_len, if_get_by_name_len) New functions.\n\t* if.c: (if_lookup_by_name_len, if_get_by_name_len) New functions.\n\t  (if_get_by_name) Tighten up code.\n\t  (interface) Use new function if_get_by_name_len.\n\t* zclient.c: (zebra_interface_add_read) Use new if_get_by_name_len\n\t  function.\n\t  (zebra_interface_state_read) Use new if_lookup_by_name_len function.\n\n2005-04-02 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* str.c: Replace strlcpy and strlcat with actual working versions\n\t  copied from rsync-2.6.2/lib/compat.c.\n\n2005-04-02 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* if.h: Remove define for IFINDEX_INTERNBASE and add define\n\t  IFINDEX_INTERNAL 0, since all internal (i.e. non-kernel) pseudo-\n\t  interfaces should have ifindex set to 0.\n\t  (if_new) Remove function.\n\t  (if_delete_retain) New function to delete an interface without\n\t  removing from iflist and freeing the structure.\n\t  (ifname2ifindex) New function.\n\t* if.c: (if_new) Remove function (absorb into if_create).\n\t  (if_create) Replace function if_new with call to calloc.\n\t  Set ifp->ifindex to IFINDEX_INTERNAL.  Fix off-by-one error\n\t  in assert to check length of interface name.  Add error message\n\t  if interface with this name already exists.\n\t  (if_delete_retain) New function to delete an interface without\n\t  removing from iflist and freeing the structure.\n\t  (if_delete) Implement with help of if_delete_retain.\n\t  (ifindex2ifname) Reimplement using if_lookup_by_index.\n\t  (ifname2ifindex) New function to complement ifindex2ifname.\n\t  (interface) The interface command should check the name length\n\t  and fail with a warning message if it is too long.\n\t  (no_interface) Fix spelling in warning message.\n\t  (if_nametoindex) Reimplement using if_lookup_by_name.\n\t  (if_indextoname, ifaddr_ipv4_lookup) Reimplement using\n\t  if_lookup_by_index.\n\n2005-04-02 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* zebra.h: Should include str.h to pick up missing functions.\n\t* str.h: Declare strnlen if needed.\n\t* str.c: Do not include str.h since zebra.h now includes it.\n\t  (strnlen) New function.\n\n2005-03-16 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* zebra.h: Must check whether __attribute__ should be defined before\n\t  including zassert.h.\n\n2005-03-14 Paul Jakma <paul.jakma@sun.com>\n\n\t* command.c: (sort_node) use vector_max instead of referencing \n\t  (struct vector *)->max directly. Test that vector_max is > 0 \n\t  before using it to calculate an index.\n\t  Fixup vector loop to make main body conditional on vector slot\n\t  not being empty.\n\t  (cmd_cmdsize) Fixup vector loop to make main body conditional on\n\t  vector slot not being empty.\n\t  (cmd_filter_by_completion) ditto\n\t  (cmd_filter_by_string) ditto \n\t  (is_cmd_ambiguous) ditto\n\t  (cmd_describe_command_real) Change index integers to unsigned.\n\t  Test that vector_max is > 0 before using it to calculate an index.\n\t  Return immediately with CMD_ERR_NO_MATCH if vline has no \n\t  active slots.\n\t  Fixup vector loop to make main body conditional on vector slot\n\t  not being empty.\n\t  (cmd_complete_command_real) ditto.\n\t  (cmd_execute_command_strict) Fixup vector loop to be conditional\n\t  on non-null slot.\n\t  (various) Fix indentation and other whitespace.\n\t  vector.h: Rename to (struct vector).max to slightly less confusing\n\t  active, for the number of active slots, distinct from allocated\n\t  or active-and-not-empty. Rename vector_max to vector_active \n\t  for same reason.\n\n2005-03-09 Paul Jakma <paul.jakma@sun.com>\n\n\t* command.c: Undo commit of sign warning fix and hidden command\n\t  in list_cmd. Sign warning is more subtle. list_cmd on its own\n\t  will be committed after.\n\t* command.c: (config_list_cmd) Don't list hidden or deprecated\n\t  commands, hiding these from tab completion is still to be done.\n\n2005-03-08 Paul Jakma <paul.jakma@sun.com>\n\n\t* command.c: (banner_motd_file_cmd) use XSTRDUP/XFREE.\n\t  (no_banner_motd_cmd) use XFREE.\n\t  (cmd_describe_command_real) sign compile warning fix\n\t  (cmd_complete_command_real) ditto.\n\t  (config_list_cmd) Don't list hidden or deprecated commands,\n\t  hiding these from tab completion is still to be done.\n\t* command.h: cmd attr enum should start at 1.\n\t* vty.c: (vty_hello) suggestions from Andrew, read by line and\n\t  stub out trailling non-printable characters on each line thus\n\t  allowing us to specify VTY_NEWLINE to vty_out.\n\n2005-03-08 Jeroen Massar <jeroen@unfix.org>\n\n\t* vty.c: (vty_hello) display motd file, if set\n\t* command.h: add char *motdfile to struct host\n\t* command.c: (config_write_host) write out motdfile config\n\t  (banner_motd_file_cmd) new command, allow motd to be read from\n\t  file.\n\t  (no_banner_motd_cmd) free motdfile string, if needs be.\n\t  (cmd_init) init (struct host).motdfile. Add new motd file\n\t  commands.\n\n2005-03-07 Michael Sandee <voidptr@voidptr.sboost.org>\n\n\t* command.c: host.name might be NULL.\n\t* vty.c: Fix fd leak.\n\n2005-02-24 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* stream.c: (stream_read_try) Log a warning message if a fatal\n\t  I/O error occurs.\n\t  (stream_fifo_new) Fix prototype.\n\t* stream.h: Fix prototype for stream_fifo_new (need void arg).\n\n2005-02-23 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* {vty.h,vty.c}: Remove vty_finish (duplicate of vty_reset).\n\n2005-02-23 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* buffer.h: Make the struct buffer and struct buffer_data structures\n\t  private by moving them inside buffer.c.  Add comments for all\n\t  functions.  Rename buffer_write as buffer_put (to be more consistent\n\t  with the buffer_putc and buffer_putstr functions).  Declare a new\n\t  buffer_write function that is used to write data to a file descriptor\n\t  and/or add it to the buffer queue.  Remove unused function\n\t  buffer_flush_vty_all.  Create a new enum typedef buffer_status_t\n\t  to be used as the return code for all buffer_flush* functions\n\t  and buffer_write.\n\t* buffer.c: The struct buffer and struct buffer_data declarations\n\t  are now private to this file.  In conjunction with that, remove\n\t  some unnecessary fields: struct buffer (alloc, unused_head,\n\t  unused_tail, length), struct buffer_data (prev).\n\t  (buffer_data_new) Removed: functionality incorporated into buffer_add.\n\t  (buffer_data_free) Removed: use a macro BUFFER_DATA_FREE instead.\n\t  (buffer_new) Use calloc instead of malloc + memset(zero). \n\t  Supply an appropriate default size if the specified size is 0.\n\t  (buffer_free) Eliminate code duplication by calling buffer_reset to\n\t  free the contents of the buffer (and remove unused code related\n\t  to unused_head).\n\t  (buffer_empty,buffer_putc,buffer_putstr) Aesthetic change (make more\n\t  compact).\n\t  (buffer_reset) Use macro BUFFER_DATA_FREE.  No need to set\n\t  alloc and length to 0 (these fields have been removed).\n\t  (buffer_add) Fix scope to be static.  Call XMALLOC directly instead\n\t  of calling removed buffer_data_new function.  Simplify the logic\n\t  (since it's now a singly-linked list instead of doubly-linked).\n\t  (buffer_write) Renamed to buffer_put.  Change to void, since return\n\t  code of 1 was meaningless.  No need to adjust length field, since\n\t  it has been removed.\n\t  (buffer_putw,buffer_flush,buffer_flush_vty_all,buffer_flush_vty)\n\t  Remove unused functions.\n\t  (buffer_flush_all) Rewrite using buffer_flush_available to eliminate\n\t  a possible failure mode if IOV_MAX is less than the number of buffers\n\t  on the queue.\n\t  (buffer_flush_window) Incorporate logic from buffer_flush_vty.\n\t  Log an error message if there is a writev error.\n\t  (buffer_flush_available) Be more paranoid: check for case where\n\t  buffer is already empty.  Use new ERRNO_IO_RETRY macro, and use\n\t  new enum for return codes.  Simplify deletion logic (since it's\n\t  now a singly-linked list).\n\t  (buffer_write) New function for use with non-blocking I/O.\n\t* vty.h: Replace the struct vty sb_buffer field with a fixed-size\n\t  (5-character) sb_buf field and an sb_len field, since using\n\t  a struct buffer was inappropriate for this task.  Add some useful\n\t  comments about telnet window size negotiation.\n\t* vty.c: Include <arpa/telnet.h> (no longer included by zebra.h).\n\t  Remove VTY_OBUF_SIZE (instead use buffer_new default size).\n\t  Make telnet_backward_char and telnet_space_char static const.\n\t  (vty_out) Replace buffer_write with buffer_put.\n\t  (vty_log_out) Check for I/O errors.  If fatal, close the vty session.\n\t  Consolidate 3 separate writes into a single write call.\n\t  (vty_will_echo,vty_command,vty_next_line,vty_previous_line,\n\t  vty_end_config,vty_describe_fold,vty_clear_buf,vty_serv_sock_addrinfo,\n\t  vty_serv_sock_family,vty_serv_un,vty_use_backup_config,exec_timeout,\n\t  vty_config_write,vty_save_cwd) Fix scope to static.\n\t  (vty_new) Let buffer_new use its default buffer size.\n\t  (vty_write) Fix signature: 2nd arg should be const char *.\n\t  Replaced buffer_write with buffer_put.\n\t  (vty_telnet_option) Fix minor bug (window height or width greater than\n\t  255 was broken).  Use sb_buf and sb_len instead of removed sb_buffer\n\t  (which was being used improperly).\n\t  (vty_read) On error, use ERRNO_IO_RETRY to decide whether it's fatal.\n\t  If the error is fatal, call buffer_reset so vty_close does not attempt\n\t  to flush the data.  Use new sb_buf and sb_len instead of sb_buffer\n\t  to store the SB negotiation string.\n\t  (vty_flush) When vty->lines is 0, call buffer_flush_available instead\n\t  of buffer_flush_window.  Look at the return code from buffer_flush\n\t  to detect I/O errors (and in that case, log an error message and\n\t  close the vty).\n\t  (vty_create) Fix scope to static.  Initialize sb_len to 0 instead\n\t  of creating sb_buffer.\n\t  (vty_accept) Set socket nonblocking.\n\t  (vtysh_accept) Use new set_nonblocking function instead of calling\n\t  fcntl directly.\n\t  (vtysh_flush) New function called from vtysh_read (after command\n\t  execution) and from vtysh_write.  This flushes the buffer\n\t  and reacts appropriately to the return code (by closing the vty\n\t  or scheduling further flushes).\n\t  (vtysh_read) Check whether error is fatal using ERRNO_IO_RETRY.\n\t  If not, just try again later.  Otherwise, call buffer_reset before\n\t  calling vty_close (to avoid trying to flush the buffer in vty_close).\n\t  Fix logic to allow case where a command does not arrive atomically\n\t  in a single read call by checking for the terminating NUL char.\n\t  (vtysh_write) Use new vtysh_flush helper function.\n\t  (vty_close) No need to call buffer_empty, just call buffer_flush_all\n\t  in any case (it will check whether the buffer is empty).\n\t  Do not free sb_buffer (since it has been removed).\n\t  (vty_log_fixed) Use writev instead of write.\n\t* zebra.h: Do not include <arpa/telnet.h>, since this is used only\n\t  by lib/vty.c.\n\n2005-02-21 Vincenzo Eramo <eramo at infocom.ing.uniroma1.it>\n\n\t* pqueue.[ch]: Introduce \"update\" function to meet ospf spf needs. It\n\t  will allow to update node when:\n\t  i) a node is inserted into the priority queue;\n\t  ii) a node position is modified in the priority queue;\n\t* pqueue.h: Export trickle_down() function.\n\n2005-02-19 Paul Jakma <paul.jakma@sun.com>\n\n\t* stream.c: (stream_new) fix dumb mistake.\n\n2005-02-17 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* stream.c: (stream_read_try) Use new ERRNO_IO_RETRY macro.\n\n2005-02-17 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* network.h: Define a new ERRNO_IO_RETRY macro to test whether an I/O\n\t  operation should be retried.  This eliminates the need to duplicate\n\t  the same logic testing for EAGAIN or EINTR in multiple places.\n\n2005-02-16 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* stream.h: Declare new function stream_read_try suitable for use\n\t  with non-blocking file descriptors.  Indicate that stream_read\n\t  and stream_read_unblock are deprecated.\n\t* stream.c: (stream_read_try) New function for use with non-blocking\n\t  I/O.\n\t  (stream_recvmsg) Should return -1 if the stream is too small to\n\t  contain the data.\n\n2005-02-16 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* network.c: (set_nonblocking) Should check return code from\n\t  fcntl(F_GETFL).\n\n2005-02-15 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\t\n\t* network.h: Declare new function set_nonblocking.  Indicate that\n\t  readn and writen are deprecated.\n\t* network.c: (set_nonblocking) New function to make a file descriptor\n\t  non-blocking, since it seems silly to have fcntl calls sprinkled\n\t  throughout the code.\n\n2005-02-14 Paul Jakma <paul.jakma@sun.com>\n\n\t* stream.h: Unsigned long updated to size_t\n\t* stream.c: ditto\n\t* stream.h: Add stream_copy, stream_dup, stream_recvmsg.\n\t  Add comment describing struct stream abstraction, and various\n\t  other comments.\n\t  Deprecate several unsafe/ambigious macros.\n\t  Add STREAM_WRITEABLE and STREAM_READABLE.\n\t  Add (stream_getl_from) for symmetry.\n\t  Update stream_forward_{endp,getp} to use size_t offset.\n\t  Make stream data a 0 length array, rather than a seperate malloc.\n\t* stream.c: Add consistency checks. Update to follow stream.h\n\t  changes.\n\t  (stream_new) Alloc stream+data in one go.\n\t  (stream_copy) new function, copy a stream.\n\t  (stream_dup) new function, dup a stream.\n\t  (stream_recvmsg) new function, recvmsg data into a stream.\n\t  (stream_empty) no need to check getp == 0.\n\n2005-02-09 Paul Jakma <paul.jakma@sun.com>\n\n\t* stream.h: Remove putp. Update reference to putp with endp.\n\t  Add stream_forward_endp, which daemons were doing manually.\n\t  Rename stream_forward to stream_forward_getp.\n\t  stream.c: Remove/update references to putp.\n\t  introduce stream_forward_endp.\n\n2005-02-08 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* zebra.h: Change macro definitions SET_FLAG and UNSET_FLAG\n\t  to use compound assignment operators (aesthetic change).\n\n2005-02-03 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* log.c: (zlog_signal,zlog_backtrace_sigsafe) Eliminate use of fileno()\n\t  since it is not async-signal-safe.\n\t  (_zlog_assert_failed) Rewrite crashlog logic more compactly.\n\t  (zlog_set_file,zlog_reset_file,zlog_rotate) Update logfile_fd\n\t  for use in signal handler.\n\n2005-02-03 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* log.c: (syslog_sigsafe) Reduce scope of syslog_fd: it is accessed\n\t  inside this function only.\n\t  (open_crashlog) New function to open /var/tmp/quagga.<daemon>.crashlog\n\t  with flags O_WRONLY|O_CREAT|O_EXCL to save some crash info.\n\t  (zlog_signal,_zlog_assert_failed) Increase logging priority from\n\t  LOG_ERR to LOG_CRIT.  If no file logging is configured, try to use\n\t  open_crashlog to create a crash logfile.\n\t  (zlog_backtrace_sigsafe) If a crashlog file descriptor is open,\n\t  dump a backtrace to that file.\n\n2005-02-02 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* if.h: Declare if_flag_dump.\n\n2005-01-30 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* daemon.c: (daemon) Replace perror with zlog_err.\n\t* vty.c: (vty_serv_un) Replace perror with zlog_err.\n\n2005-01-29 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* buffer.h: Fix comment on buffer_getstr to reflect that it now\n\t  uses XMALLOC.\n\t* buffer.c: (buffer_getstr) Use XMALLOC(MTYPE_TMP) instead of malloc.\n\t* filter.c: (access_list_remark,ipv6_access_list_remark) Use\n\t  argv_concat instead of buffer_getstr.\n\t* if.c: (interface_desc) Use argv_concat instead of buffer_getstr.\n\t* plist.c: (ip_prefix_list_description,ipv6_prefix_list_description)\n\t  Use argv_concat instead of buffer_getstr.\n\n2005-01-28 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* lib/buffer.h: Document behavior of buffer_getstr function.\n\t* lib/buffer.c: (buffer_getstr) Fix bug: must handle case where\n\t  the string extends beyond the head struct buffer_data.\n\n2005-01-28 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* lib/command.h: Document behavior of argv_concat function.\n\t* lib/command.c: (argv_concat) Calculate total string length first so\n\t  we can call malloc just once (instead of realloc'ing to add each\n\t  string element).\n\t  (do_echo,config_logmsg) Allow for possible NULL return value from\n\t  argv_concat.\n\n2005-01-23 Hasso Tepper <hasso at quagga.net>\n\n\t* lib/command.[ch]: Make node_parent() function nonstatic. vtyh.c will\n\t  use it as well.\n\n2005-01-18 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* log.h: Test for SA_SIGINFO to see whether zlog_signal takes final\n\t  two args (siginfo and program_counter).\n\t* log.c: (hex_append) Include this function only if SA_SIGINFO or\n\t  HAVE_GLIBC_BACKTRACE is defined.\n\t  (zlog_signal) Final two args (siginfo and program_counter) now\n\t  depend on whether SA_SIGINFO is defined on this platform.\n\t* sigevent.c: (program_counter) Do not include this function if\n\t  SA_SIGINFO is not defined on this platform.\n\t  (exit_handler,core_handler) Test for SA_SIGINFO to decide whether\n\t  2nd & 3rd arguments are present and to decide how to invoke\n\t  zlog_signal.\n\t  (trap_default_signals) Test for SA_SIGINFO and invoke sigaction\n\t  appropriately.\n\n2005-01-17 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* log.h: Change prototype for zlog_backtrace_sigsafe to take additional\n\t  program_counter argument.\n\t* log.c: (zlog_backtrace_sigsafe) Add additional program_counter\n\t  argument.  If it is non-NULL, use backtrace_symbols_fd to resolve\n\t  the address.\n\t  (zlog_signal) Call zlog_backtrace_sigsafe with additional\n\t  program_counter argument.\n\n2005-01-17 Hasso Tepper <hasso at quagga.net>\n\n\t* command.[ch], vty.c: cmd_execute_command() function must not attempt\n\t  to walk up in the node tree if called from vtysh. Different daemons\n\t  might have commands with same syntax in different nodes (for example\n\t  \"router-id x.x.x.x\" commands in zebra/ospfd/ospf6d daemons).\n\n2005-01-14 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* command.c (print_version): Do not bother even to examine host.name,\n\t  since it is always NULL when this function is called from main.\n\n2005-01-14  Greg Troxel  <gdt@fnord.ir.bbn.com>\n\n\t* command.c (print_version): Don't print host.name if it is NULL.\n\tFixes segfault on Solaris reported by Goetz von Escher <goetz@open.ch>\n\t\n2005-01-12 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* sigevent.c: (trap_default_signals) Use the SA_SIGINFO flag to\n\t  pass additional siginfo_t and ucontext_t arguments to core_handler\n\t  and exit_handler.\n\t  (core_handler,exit_handler) Now invoked with 3 arguments (using\n\t  SA_SIGINFO).  Pass additional info to zlog_signal.\n\t  (program_counter) New function to find program counter in ucontext_t,\n\t  needs to be enhanced to support more platforms (currently works only\n\t  on Linux/x86).\n\t* log.h: Change the zlog_signal prototype to add new arguments\n\t  siginfo_t * and program_counter.\n\t* log.c: (zlog_signal) Add new arguments siginfo and program_counter.\n\t  Include si_addr and program counter (if non-NULL) in message.\n\t  And remove #ifdef HAVE_GLIBC_BACKTRACE around hex_append, since\n\t  that is now used to render the si_addr and PC pointers.\n\n2005-01-12 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* zebra.h: If not C99 and no va_copy macro available, fall back to\n\t  memcpy (solves a build problem on FreeBSD 4.x).\n\n2005-01-04 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* zebra.h: Define ZCMSG_FIRSTHDR appropriately based on whether\n\t  config.h indicates HAVE_BROKEN_CMSG_FIRSTHDR (as determined\n\t  by the configure test program).\n\t* sockopt.c: (getsockopt_cmsg_data) Use ZCMSG_FIRSTHDR instead\n\t  of CMSG_FIRSTHDR.\n\n2005-01-02 Hasso Tepper <hasso at quagga.net>\n\n\t* command.c: Revert int -> unsigned int fixes in\n\tcmd_describe_command_real() and cmd_complete_command_real(). index can\n\tbe actually negative and it caused crash with \"do<TAB>\" in vty.\n\n2004-12-29  Greg Troxel  <gdt@poblano.ir.bbn.com>\n\n\t* sockopt.c (getsockopt_ipv4_ifindex): Document calling\n\tconvention.  Beef up comments.  Handle the case where the cmsghdr\n\thas a zero controllen, or more specifically when the wanted option\n\tis not present.  This is needed for Solaris 8, and in general for\n\tany platform for which configure finds a method and it can fail.\n\tMark some changes with XXX to be cleaned up post 0.98.\t\n\t\n2004-12-28 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* sockopt.c: (setsockopt_ipv4_ifindex) Improve error message.\n\t  When neither IP_PKTINFO nor IP_RECVIF is defined, make return value\n\t  deterministic (-1).\n\n2004-12-28 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* thread.c: (funcname_thread_add_timer_msec) Reduce overflow risk.\n\n2004-12-21 Paul Jakma <paul.jakma@sun.com>\n\n\t* if.h: Add more 'non-generic' IFF_ flags.\n\t* if.c: IFF_NOXMIT/IFF_VIRTUAL interfaces are 'loopback like'\n\t* stream.c: Dont allocate streams with 0 sized data buffers\n\n2004-12-17 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* command.c: (do_echo) Added new \"echo\" command, useful for\n\t  watchdog pinging to make sure the daemon is responsive.\n\n2004-12-17 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\t\n\t* pid_output.c: (pid_output_lock) Eliminate static function, and just\n\t  use the #ifdef to decide which version of the function to include.\n\t  This eliminates a compilation problem with gcc4.  And fix the\n\t  non-fcntl version so that it actually compiles.  Exit with\n\t  status 1 instead of -1 on error.\n\n2004-12-15 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* sigevent.c: (trap_default_signals) Ignore SIGPIPE instead of exiting.\n\n2004-12-10 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\t\n\t* log.c: (zlog_signal,_zlog_assert_failed) Change logging level back to\n\t  LOG_ERR instead of LOG_EMERG.\n\n2004-12-09 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* log.c: (hex_append) No need to include this function if\n\t  HAVE_GLIBC_BACKTRACE is not defined.\n\n2004-12-08 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* prefix.c: (prefix_copy) Error message before abort should\n\t  have severity LOG_ERR, not LOG_INFO.\n\t* memory.c: (mtype_log) Log level should be LOG_DEBUG, not LOG_INFO.\n\n2004-12-07 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* {smux.c,zclient.c}: Change level of debug messages to LOG_DEBUG.\n\n2004-12-07 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* command.c: (config_write_host) Note that \"log trap\" is deprecated\n\t  when writing out the config.\n\n2004-12-07 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* log.h: Replace struct zlog flags and maskpri fields with maxlvl\n\t  array to support individual logging levels for each destination.\n\t  Remove the 2nd argument to openzlog since the default logging config\n\t  should be standardized inside the library.  Replaced the\n\t  zlog_set_flag and zlog_reset_flag functions with zlog_set_level.\n\t  And zlog_set_file now requires an additional log_level argument.\n\t  Declare zlog_proto_names for use inside command.c in the\n\t  \"show logging\" command.  Added defines useful for command\n\t  construction.\n\t* log.c: (vzlog) Decide where to send the message based on the\n\t  individual logging levels configured for each destination.\n\t  Remove support for ZLOG_STDERR since it was never actually used.\n\t  Support record-priority for terminal monitors.\n\t  (zlog_signal,zlog_backtrace_sigsafe) Support destination-specific\n\t  logging levels.  Remove stderr support (was never used).  Added\n\t  support for terminal monitor logging.\n\t  (_zlog_assert_failed) Increase message severity to LOG_EMERG.\n\t  (openzlog) Remove 2nd argument since default config should be\n\t  standardized in library.  By default, terminal monitoring\n\t  is set to debug, and all other logging is disabled.\n\t  (zlog_set_flag,zlog_reset_flag) Removed.\n\t  (zlog_set_level) New function to replace zlog_set_flag and\n\t  zlog_reset_flag.  Supports destination-specific logging levels.\n\t  (zlog_set_file,zlog_reset_file) Support file-specific logging level.\n\t  (zlog_rotate) Log an error message if fopen fails, and support\n\t  new file-specific logging level.\n\t* command.h: Change DEFUN_CMD_FUNC_DECL and DEFUN_CMD_FUNC_TEXT so that\n\t  command functions will be static instead of global.  Remove\n\t  declarations for config_exit and config_help.  Define new macros\n\t  DEFUNSH_ATTR, DEFUNSH_HIDDEN, and DEFUNSH_DEPRECATED so we can\n\t  have deprecated commands in vtysh.  Similarly, for completeness,\n\t  define macros ALIAS_SH, ALIAS_SH_HIDDEN, and ALIAS_SH_DEPRECATED.\n\t  Also, fix bug in ALIAS_ATTR macro (didn't matter because it\n\t  was never used).\n\t* command.c: Make many functions static instead of global.\n\t  (facility_name,facility_match,level_match) New functions\n\t  to support enhanced destination-specific logging levels.\n\t  (config_write_host) Support new destination-specific logging levels.\n\t  (config_logmsg) Added new \"logmsg\" command to help test logging\n\t  system.\n\t  (show_logging) Added \"show logging\" command to show the current\n\t  configuration of the logging system.\n\t  (config_log_stdout_level) Support explicit stdout logging level.\n\t  (no_config_log_stdout) Now takes optional LEVEL arg.\n\t  (config_log_monitor,config_log_monitor_level,no_config_log_monitor)\n\t  New commands creating new \"log monitor\" commands to set terminal\n\t  monitoring log level.\n\t  (config_log_file_level) Support explicit file logging level.\n\t  (config_log_syslog_level) Support explicit syslog logging level.\n\t  (config_log_facility,no_config_log_facility) Implement new\n\t  \"log facility\" command.\n\t  (cmd_init) Add hooks for new commands: \"show logging\", \"logmsg\",\n\t  \"log stdout <level>\", \"log monitor\", \"log monitor <level>\",\n\t  \"no log monitor\", \"log file <filename> <level>\",\n\t  \"no log file <filename> <level>\", \"log syslog <level>\",\n\t  \"log facility\", and \"no log facility\".\n\t* vty.h: Added a \"level\" argument to vty_log so it can support\n\t  \"log record-priority\".  Declare new function vty_log_fixed for\n\t  use in signal handlers.\n\t* vty.c: (vty_log,vty_log_out) Added a \"level\" argument to support\n\t  \"log record-priority\" for vty terminal monitors.\n\t  (vty_down_level) Use config_exit_cmd.func instead of calling\n\t  config_exit directly (since command functions will now be static\n\t  instead of global).\n\t  (vty_log_fixed) New function to send terminal monitor messages\n\t  from inside a signal handler.\n\n2004-12-03 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* log.h: Document appropriate use of syslog logging priorities\n\t  inside quagga.\n\n2004-12-03 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* command.h: Remove fields log_stdout and log_syslog from struct host,\n\t  since they are just trying to duplicate information in the\n\t  zlog_default structure.  Note that this fixes a bug since those\n\t  fields were not registering any logging that was established\n\t  in the initial call to openzlog (this affects only the zebra and\n\t  ospf6d daemons).  It is probably a bug to turn on any logging by\n\t  default in the call to openzlog.\n\t* command.c: (config_write_host) Get logging info from zlog_default\n\t  instead of now-removed fields host.log_stdout and host.log_syslog.\n\t  (config_log_stdout,no_config_log_stdout) Do not set now-removed field\n\t  host.log_stdout, since this info is recorded in zlog_default.\n\t  (config_log_file) Use XSTRDUP (instead of strdup) to set host.logfile.\n\t  (config_log_syslog,config_log_syslog_facility,no_config_log_syslog)\n\t  Do not set now-removed field host.log_syslog, since this info is\n\t  recorded in zlog_default.\n\n2004-12-03 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* version.h.in: Remove declaration for pid_output_lock, this function\n\t  is now static, not global.\n\t* pid_output.c: (pid_output_lock) This function should be static, not\n\t  global.  And remove \"old umask\" error message, since it was really\n\t  an unimportant debug message, not an error.\n\t  (pid_output) Need to declare static function pid_output_lock.\n\n2004-11-28 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* log.h: Remove several unused fields from struct zlog.  Add comments\n\t  for other fields, and add one new field syslog_options that is\n\t  used in the new syslog_sigsafe implementation.\n\t* log.c: (syslog_sigsafe) New function to send syslog messages in\n\t  an async-signal safe way that can be used inside a signal handler.\n\t  (syslog_connect) New function to connect to syslog daemon inside a\n\t  signal handler.  This function supports only systems where /dev/log\n\t  is a unix datagram socket (e.g. not Solaris).\n\t  (zlog_signal) Call syslog_sigsafe if syslog logging is enabled.\n\t  (zlog_backtrace_sigsafe) Call syslog_sigsafe if syslog logging is\n\t  enabled.\n\t  (openzlog) Save syslog_options for use in syslog_sigsafe.\n\t  (num_append) Fix bug: handle 0 properly.\n\t  (hex_append) New function to print a u_long in hex format.\n\n2004-11-28 Hasso Tepper <hasso at quagga.net>\n\n\t* command.h: DEFUN_DEPRECATED passes attribute to DEFUN as well.\n\n2004-11-26 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* log.c, log.h, memory.c: Change function name from zlog_backtrace_safe\n\t  to the more self-explanatory zlog_backtrace_sigsafe.\n\n2004-11-26 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* debug.[ch]: Remove unused files.\n\t* Makefile.am: Remove references to debug.c and debug.h\n\n2004-11-26 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* log.c: (zlog_backtrace) New function to log a backtrace.\n\t  (zlog_backtrace_safe) Log a backtrace in an async-signal-safe way.\n\t  Unfortunately, this function does not support syslog logging yet.\n\t  (zlog_signal) Move backtrace code into separate function\n\t  zlog_backtrace_safe.\n\t  (_zlog_assert_failed) Call zlog_backtrace before aborting.\n\t* log.h: Declare new functions zlog_backtrace and zlog_backtrace_safe.\n\t* memory.c: (zerror) Call zlog_backtrace before aborting.\n\n2004-11-26 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* Makefile.am: Need to add zassert.h to pkginclude_HEADERS.\n\n2004-11-25 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* zebra.h: If not C99 and there's no va_copy macro and there is\n\t  a __va_copy macro, define va_copy as __va_copy.\n\n2004-11-25 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* pid_output.c: (pid_output_lock) Fix 2 bugs: when locking, should\n\t  set l_whence to SEEK_SET, not SEEK_END.  And after writing new\n\t  pid to file, must ftruncate to eliminate any extraneous bytes left\n\t  over from the last time a pid was written.\n\n2004-11-24 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* zassert.h: New header file to declare a quagga-specific assert macro.\n\t* log.c: (_zlog_assert_failed) New function called when assert fails\n\t  to log the error and abort.\n\t* zebra.h: Include \"zassert.h\" instead of <assert.h>.\n\t* regex.c: Include \"zassert.h\" instead of <assert.h>.\n\n2004-11-23 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* sigevent.c: (signal_init) Set up some default signal handlers\n\t  so that processes will issue an error message before terminating\n\t  or dumping core.\n\t  (trap_default_signals) New function to set up signal handlers\n\t  for various signals that may kill the process.\n\t  (exit_handler) Call zlog_signal, then _exit.\n\t  (core_handler) Call zlog_signal, then abort.\n\t* log.h: Declare new function zlog_signal.\n\t* log.c: (zlog_signal) New function to log information about\n\t  a received signal before the process dies.  Try to log a \n\t  backtrace also.\n\t  (quagga_signal_handler,signal_set) Should be static.\n\n2004-11-23 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* log.c: (vzlog) Take a single va_list argument and use va_copy\n\t  as necessary for multiple traversals.\n\t  (zlog) Pass only one va_list to vzlog.\n\t  (zlog_*,plog_*) Use a macro for boilerplate code; pass only one\n\t  va_list to vzlog.\n\t  (zlog_set_file) Remove unused 2nd argument (flags).\n\t  (zlog_save_cwd,zlog_get_cwd,zlog_free_cwd) Remove unused functions.\n\t* log.h: Remove ZLOG_*_INDEX defines (no longer used).\n\t  Remove unused 2nd argument from zlog_set_file prototype.\n\t  Fix prototype for zlog_rotate.\n\t* command.c: (config_log_file) Remove unused 2nd arg to zlog_set_file.\n\t* vty.c: (vty_out) Fix stdarg usage to perform multiple traversals\n\t  properly.\n\t  (vty_log) Must use va_copy for multiple traversals of va_list arg.\n\n2004-11-19 David Young <dyoung@pobox.com>\n\n\t* log.c: (safe_strerror) New function: safe wrapper for strerror.\n\n2004-11-19 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* sockopt.c: (setsockopt_so_recvbuf) Stop error message from being\n\t  printed every time.\n\n2004-11-16 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* memory.h: Fix prototype for memory_init().\n\t* memory.c: Declare many functions and data structures static instead\n\t  of global.  Fix prototype for memory_init().\n\n2004-11-15  Greg Troxel  <gdt@fnord.ir.bbn.com>\n\n\t* sockopt.h: Avoid CMSG_ALIGN, and declare that sizes are without\n\talignment (users should use CMSG_SPACE).\n\n\t* zebra.h: Rationalize CMSG_SPACE compatibility defines.  Warn if\n\tasumming 4-byte alignment, since this isn't safe.\n\n2004-11-15 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* memory.c: (zerror) Use zlog_err instead of fprintf to stderr.\n\t  Instead of exiting, log currenty memory usage and then abort.\n\t  (log_memstats) New function to log memory statistics, called by\n\t  zerror.\n\t  (show_memory_all) Loop over new mlists array instead of calling\n\t  show_memory_vty separately for each memory_list.\n\n2004-11-08 Paul Jakma <paul@dishone.st>\n\n\t* buffer.c: Add missing include of log.h.\n\t  (buffer_flush_available) written is compared against\n\t  mostly against unsigned types, only for the writev do we need\n          signed compare, so declare it as size_t and cast it to ssize_t\n          just for the error compare when we've called writev.\n\t* buffer.h: Add comment that buffer data sizes really should be \n          size_t.\n\n2004-11-07 Paul Jakma <paul@dishone.st>\n\n\t* version.h.in: add autoconf configure_input output var\n\n2004-11-04 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* vty.h: Remove fields in struct vty that were related to VTY_CONTINUE\n\t  capabilities (that were used only in bgpd/bgp_route.c and are now\n\t  removed).  Also remove some other fields that were not being\n\t  used at all.\n\t* vty.c: (vty_execute) Do not test for obsolete status values VTY_START\n\t  and VTY_CONTINUE.\n\t  (vty_read) Remove calls to vty->output_func since that was part\n\t  of the VTY_CONTINUE infrastructure that has been removed.\n\t  (vty_flush) Remove code to support VTY_START and VTY_CONTINUE.\n\t  (vty_close) Remove code to cancel vty->t_output thread, since that\n\t  thread was never actually used.\n\n2004-11-04 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* vty.c: Vtysh connections to daemons should use buffering.\n\t  (vty_out) Remove exception for vty_shell_serv, just use buffer_write.\n\t  (vty_new) Increase output buffer size to 4096 rounded up to a\n\t  multiple of pagesize.\n\t  (vtysh_read) After command has been executed and all output buffered,\n\t  call buffer_flush_available and schedule further writes if the\n\t  buffers are not yet empty.\n\t  (vtysh_write) New function to flush output to vtysh when the socket\n\t  is writeable.\n\t  (vty_event) Added new VTYSH_WRITE event for flushing buffers to vtysh\n\t  clients.  Also, should save read thread in vty->t_read so the\n\t  thread can be cancelled in vty_close.\n\t* buffer.h: In struct buffer_data, remove unused \"parent\" field.\n\t  Convert \"unsigned char *data\" to \"unsigned char data[0]\" to save\n\t  a malloc.  Declare new function buffer_flush_available that works\n\t  with non-blocking sockets.\n\t* buffer.c: (buffer_data_new) Use a single malloc now that data is\n\t  a variable-size array at end of structure.\n\t  (buffer_data_free) Just a single free now that data is part of the\n\t  structure.\n\t  (buffer_write) Simplify the logic to make behavior more transparent.\n\t  (buffer_flush) Decrease b->length as data is written out.\n\t  (buffer_flush_vty_all) Decrease b->length as buffers are freed.\n\t  (buffer_flush_vty) Decrease b->length as data is written out.\n\t  (buffer_flush_available) New function to flush non-blocking sockets.\n\t  \n2004-11-01 Paul Jakma <paul@dishone.st>\n\n\t* sockopt.c: (setsockopt_pktinfo) remove, its unused.\n\n2004-10-31 Paul Jakma <paul@dishone.st>\n\n\t* vty.c: As per Andrew's suggestions..\n\t  (vty_serv_un) remove flags.\n\t  (vtysh_accept) close socket if we cant set NONBLOCK. Add flags.\n\t* keychain.c: Convert some more strtoul users to VTY_GET_INTEGER.\n\t* memory.h: Add MTYPE_THREAD_FUNCNAME and MTYPE_THREAD_STATS\n\t* thread.c: Update stats and funcname alloc/free to use previous\n\t  specific memory type defines. Use XCALLOC and sizeof the type,\n          not the pointer.\n\t* smux.c: fix int to size_t compile warnings\n\n2004-10-29 Paul Jakma <paul@dishone.st>\n\n\t* vty.c: Move setting of sock to O_NONBLOCK from vty_serv_un\n\t  to vtysh_accept, where sock is the actual fd we wanted to set to\n          O_NONBLOCK, ie the /connected/ vtysh unix socket.\n\n2004-10-23 Hasso Tepper <hasso at quagga.net>\n\n\t* zclient.c: Unbreak reading interface update message. Might fix\n\tblocker bugzilla #109.\n\n2004-10-22 Paul Jakma <paul@dishone.st>\n\n\t* sockopt.c: (getsockopt_ipv4_ifindex) no ifindex should be 0, not\n          -1. \n          (setsockopt_pktinfo) unexported\n\t* sockopt.h: Cleanup SOCKOPT_CMSG defines a bit. Add a throwaway\n          define for SOPT_SIZE_CMSG_IFINDEX_IPV4 for systems which have\n          neither IP_RECVIF nor IP_PKTINFO (eg openbsd), thanks to Rivo\n          Nurges for highlighting problem and fix.\n          Fix elif that should be an else.\n\t* command.h: Cleanup the defines a bit, add helper defines and\n\t  collapse all defines to use those. Add an attribute field to\n\t  cmd_element to support, eg hidden or deprecated commands, add\n          defun defines for such. All that's left to do is add logic\n          to command.c to check these attributes... ;)\n\t* zebra.h: reserve ZEBRA_ROUTE_HSLS\n\n2004-10-19 Hasso Tepper <hasso at quagga.net>\n\n\t* version.h.in: Define copyright string QUAGGA_COPYRIGHT.\n\t* print_version.c: Remove. print_version () function moved to\n\t  command.[c|h].\n\t* command.c: Use QUAGGA_COPYRIGHT.\n\t* Makefile.am: Remove useless version.c and print_version.c files.\n\n2004-10-19 Andrew J. Schorr <aschorr@telemetry-investments.com>\n\n\t* zclient.c: (zebra_interface_address_read) If the destination address\n\t  is encoded as all zeroes, load it as a NULL pointer.\n\t* if.h: Add comment describing struct connected destination field\n\t  and indicating that it may be NULL.  Define macros\n\t  CONNECTED_DEST_HOST and CONNECTED_POINTOPOINT_HOST to help\n\t  with PtP logic (distinguish between host and subnet addressing).\n\t* if.c: (if_lookup_address) Fix PtP logic to handle subnet addressing\n\t  properly,\n\t  (connected_lookup_address) ditto.\n\t  (connected_add_by_prefix) Handle case where destination is NULL,\n\t* prefix.[c|h]: New functions ipv4_network_addr and\n\t  ipv4_broadcast_addr.\n\n2004-10-13 Hasso Tepper <hasso at quagga.net>\n\n\t* command.c: Make CMD_ERR_NOTHING_TODO nonfatal if reading\n\t  configuration from file. Fixes critical bugzilla #113.\n\t* smux.c, smux.h: Remove all defaults to initialize smux connection to\n\t  snmpd by default even if not configured to do so. \"smux peer OID\n\t  <password>\" initializes now connection and \"no smux peer\" terminates\n\t  it.\n\n2004-10-13 Paul Jakma <paul@dishone.st>\n\n\t* (global) more const'ification.\n\t* sockunion.c: (sockunion_su2str) buffer should be sized\n          SU_ADDRSTRLEN.\n          (sockunion_log) do not return stack variables, strdup buf before\n          return.\n        * vty.h: Fix up the VTY_GET_INTEGER macros. Testing caller supplied\n          values against ULONG_MAX is daft, when caller probably has passed\n          a type that can not hold ULONG_MAX. use a temporary long instead.\n          Add VTY_GET_LONG, make VTY_GET_INTEGER_RANGE use it, make\n\t  VTY_GET_INTEGER a define for VTY_GET_INTEGER_RANGE.\n\n2004-10-11 Hasso Tepper <hasso at quagga.net>\n\n\t* command.h: Sync DEFUNSH with other macros.\n\t* sockunion.c, sockunion.h: More const strings.\n\n2004-10-11 Paul Jakma <paul@dishone.st>\n\n\t* thread.c: (funcname_thread_add_timer) \n\t  (funcname_thread_add_timer_msec) Fix mistakes from last change.\n\t  Pointed out by Liu Xin in [quagga-dev 1609].\n\t* if.h: mtu's should be unsigned.\n\t* routemap.{c,h}: const char updates\n\t* smux.{c,h}: ditto\n\n2004-10-10 Paul Jakma <paul@dishone.st>\n\n\t* version.h.in: (pid_output*) add const qualifier.\n\t* command.h: Change DEFUN func to take const char *[] rather\n          than char **, to begin process of fixing compile warnings in lib/.\n          Nearly all other changes in this commit follow from this change.\n        * buffer.{c,h}: (buffer_write) pointer-arithmetic is gccism, take\n          const void * and cast an automatic const char *p to it.\n          (buffer_putstr) add const\n        * command.c: (zencrypt) const qualifier\n          (cmd_execute_command_real) ditto\n          (cmd_execute_command_strict) ditto\n          (config_log_file) ditto. \n          Fix leak of getcwd() returned string.\n        * memory.{c,h}: Add MTYPE_DISTRIBUTE_IFNAME for struct dist ifname.\n        * distribute.{c,h}: Update with const qualifier.\n          (distribute_free) use MTYPE_DISTRIBUTE_IFNAME\n          (distribute_lookup) Cast to char *, note that it's ok.\n          (distribute_hash_alloc) use MTYPE_DISTRIBUTE_IFNAME.\n          (distribute_get)  Cast to char *, note that it's ok.\n        * filter.c: Update with const qualifier.\n        * if.{c,h}: ditto.\n        * if_rmap.{c,h}: ditto.\n          (if_rmap_lookup) Cast to char *, note that it's ok.\n          (if_rmap_get) ditto.\n        * log.{c,h}: Update with const qualifier.\n        * plist.{c,h}: ditto.\n        * routemap.{c,h}: ditto.\n        * smux.{c,h}: ditto. Fix some signed/unsigned comparisons.\n        * sockopt.c: (getsockopt_cmsg_data) add return for error case.\n        * vty.c: Update with const qualifier.\n          \n2004-10-08 Hasso Tepper <hasso at quagga.net>\n\n\t* routemap.c, routemap.h: Make some string arguments const.\n\n2004-10-05 Paul Jakma <paul@dishone.st>\n\n\t* version.h.in: print_version declaration is here, not in automake\n\t  generated version.h.\n\n2004-10-08 Hasso Tepper <hasso at quagga.net>\n\n\t* command.c, command.h: Make argument of cmd_make_strvec function\n\t  const.\n\t* command.c: Make hostname commands usable in vtysh again.\n\n2004-10-07 Hasso Tepper <hasso at quagga.net>\n\n\t* command.c, pid_output.c, print_version.c, vty.c, vty.h: Make more\n\t  strings const.\n\n2004-10-05 Hasso Tepper <hasso at quagga.net>\n\n\t* *.[c|h]: Make many strings cons and a lot of int -> unsigned int\n\t  changes to fix warnings.\n\n2004-10-05 Paul Jakma <paul@dishone.st>\n\n\t* sockopt.{c,h}: add sockopt_iphdrincl_swab_{htosys,systoh},\n          functions to change byte order between system IP_HDRINCL order\n          and host order.\n\t* thread.c: (funcname_thread_add_timer_timeval) new function, add\n          timer at specified timeval.\n\t  (funcname_thread_add_timer) use funcname_thread_add_timer_timeval.\n\t  (funcname_thread_add_timer_msec) ditto\n\n2004-10-04 Hasso Tepper <hasso at quagga.net>\n\n\t* memory.c, memory.h: Make char * argument of strdup functions const.\n\t* prefix.c, prefix.h: Make many arguments const. Reorder stuff in\n\t  header.\n\t* log.h: Make log message const in struct message.\n\t* log.c: Fix some indenting.\n\t* network.c, network.h: Make second argument of writen() const.\n\n2004-10-03  Hasso Tepper  <hasso at quagga.net>\n\n\t* command.h: Introduce SERVICE_NODE for \"service <...>\" commands.\n\t* command.c: Don't initialize commands that don't make sense if vtysh\n\t  is used.\n\t* vty.c: Make VTY_NODE appear in vtysh.\n\n2004-10-03 James R. Leu <jleu at mindspring.com>\n\n\t* zclient.c, zclient.h: zclient functions for router id handling.\n\t* zebra.h: New message types for router id handling.\n\n2004-09-27 Paul Jakma <paul@dishone.st>\n\n\t* zebra.h: Add WANT_OSPF_WRITE_FRAGMENT for ospfd\n\t  to try to fragment oversized packets. Enabled only for Linux.\n\t  Add HAVE_IP_HDRINCL_BSD_ORDER to define struct ip byte order,\n\t  to consolidate various ad-hoc platform defines for same thing.\n\n2004-09-26 Hasso Tepper <hasso at quagga.net>\n\n\t* vty.c, sockopt.c: Fix compiler warnings.\n\n2004-09-23 Hasso Tepper <hasso at quagga.net>\n\n\t* linklist.h: Remove list and listnode typedefs.\n\t* *.[c|h]: list -> struct list *, listnode -> struct listnode *.\n\n2004-09-17 Paul Jakma <paul@dishone.st>\n\n\t* sockopt.c: Add missing bracket\n\n2004-09-17 Paul Jakma <paul@dishone.st>\n\n\t* sockopt.{c,h}: Add setsockopt_so_recvbuf, for ripd and ripngd.\n\n2004-09-13 Paul Jakma <paul@dishone.st>\n\n\t* command.c: Update the copyright string in the default motd.\n\n2004-08-31  David Wiggins  <dwiggins@bbn.com>\n\n\t* hash.c (hash_iterate): Save next pointer before calling\n\tprocedure, so that iteration works even if the called procedure\n\tdeletes the hash backet.\n\n\t* linklist.h (listtail): new macro, not yet used.\n\n2004-08-27 Hasso Tepper <hasso at quagga.net>\n\n\t* command.c: Install \"terminal length\" commands only if vty is used.\n\t  Vtysh will handle it itself.\n\n2004-08-26  Greg Troxel  <gdt@fnord.ir.bbn.com>\n\n\t* sockopt.h: Define method-independent macro for callers of\n\tget_ifindex to use for cmsg length.\n\n2004-08-19 Paul Jakma <paul@dishone.st>\n\n\t* zebra.h: add MAX and MIN defines (eg for ospf6d)\n\n2004-08-19 Paul Jakma <paul@dishone.st>\n\n\t* sockopt.c: include sockopt.h\n\t  rename some of the _pktinfo_ functions to _ifindex, where that is\n\t  their purpose.\n          (getsockopt_ipv6_pktinfo_ifindex) renamed to\n\t  getsockopt_ipv6_ifindex.\n\t  (setsockopt_ipv4_pktinfo) renamed to setsockopt_ipv4_ifindex\n\t  (setsockopt_pktinfo) update with previous and add comment re\n\t  AF_INET portability.\n\t  (setsockopt_ifindex) generic ifindex function ala\n\t  setsockopt_pktinfo.\n\t  (getsockopt_ipv4_pktinfo_ifindex) renamed to\n\t  getsockopt_ipv4_ifindex.\n\t  (getsockopt_ipv4_ifindex) rejiggling to reduce repeated\n          ifdef/elses. pktinfo case forgot to set ifindex.\n          (getsockopt_pktinfo_ifindex) renamed to \n          getsockopt_ifindex. update some calls to renamed functions.\n        * sockopt.h: Update renamed exported functions\n          Rename the CMSG_SIZE macros to IFINDEX.\n          Guard IPv4 PKTINFO in a conditional define.\n\n2004-08-18 Paul Jakma <paul@dishone.st>\n\n\t* vty.c: (vty_serv_un) set unix vty socket to nonblocking\n\t  to prevent inadvertent blocking of daemons by use of\n\t  vtysh. TODO: disentangle manual paging from the buffer_write\n\t  path so that unix vty can use this path too and be reliable.\n\t  \n2004-07-23  Greg Troxel  <gdt@poblano.ir.bbn.com>\n\n\t* sockopt.c (getsockopt_ipv4_pktinfo_ifindex): Make this compile\n\ton NetBSD, and add comments to make it less confusing.  Change the\n\tsense of the SUNOS_5 test to make parallel structure between the\n\tvariables and the code.\n\n2004-07-23 Paul Jakma <paul@dishone.st>\n\n\t* sockopt.h: Add SOPT_SIZE_CMSG_PKTINFO{_IPV{4,6}} define, for\n\t  sizeof pktinfo as appropriate, to be used when allocating msg\n\t  buffers. export setsockopt_pktinfo() and\n\t  getsockopt_pktinfo_ifindex()\n\t* sockopt.c: (setsockopt_pktinfo_ifindex) new function to portably\n\t  set received ifindex sock option.\n\t  (getsockopt_pktinfo_ifindex) portably retrieve ifindex.\n\t  (getsockopt_cmsg_data) retrieve indicated control info from \n\t  message header.\n\t  (getsockopt_ipv6_pktinfo_ifindex) ipv6 version of above.\n\t  (setsockopt_ipv4_pktinfo) v4 version\n\t  (setsockopt_pktinfo) the exported version\n\t  (getsockopt_ipv4_pktinfo_ifindex) v4 specific version\n\t  (getsockopt_pktinfo_ifindex) the exported version\n\n2004-07-14 Paul Jakma <paul@dishone.st>\n\n\t* sigevent.c: (quagga_signal_handler) add a global caught flag, set\n\t  the flags to a constant rather increment to be kinder. \n\t  (quagga_sigevent_process) new function, to do core of what\n\t  quagga_signal_timer did. dont block signals at all as sig->caught\n\t  is volatile sig_atomic_t and should be safe to access from signal\n\t  and normal contexts. The signal blocking is unneeded paranoia, but\n\t  is left intact under an ifdef, should some platform require it.\n\t  Check global caught flag before iterating through array. \n\t  (quagga_signal_timer) nearly everything moved to\n\t  quagga_sigevent_process. Left in under ifdef, in case some\n\t  platform could use a regular timer check for signals.\n\t* sigevent.h: quagga_sigevent_process declaration.\n\t* thread.c: (thread_fetch) check for signals at beginning of \n\t  scheduler loop, check for signals if select returns EINTR.\n\t \n2004-07-13  Greg Troxel  <gdt@poblano.ir.bbn.com>\n\n\t* sigevent.c: Don't block SIGTRAP and SIGKILL.  Blocking SIGTRAP\n\tconfuses gdb, at least on NetBSD 2.0_BETA, where the block\n\tsucceeds.\n\n2004-07-09 Paul Jakma <paul@dishone.st>\n\n\t* Merge Kunihiro's 'show route-map' change and add \n\t  compatibility aliases for route-map continue\n\t* jhash.{c,h}: New files. Bob Jenkins' public domain hashing \n\t  function, as implemented in linux kernel by David Miller.\n\n2004-07-09 Juris Kalnins <juris@mt.lv>\n\n\t* if.c: (if_cmp_func) fix for interface names where name is same,\n\t  but one has no number, eg \"devtyp\" and \"devtyp0\".\n\t  \n2004-06-30  Greg Troxel  <gdt@poblano.ir.bbn.com>\n\n\t* Makefile.am: Make libzebra shared.\n\n2004-06-21 Paul Jakma <paul@dishone.st>\n\n\t* ChangeLog: fix my last update config.h -> zebra.h ;)\n\t* zebra.h: Fix gcc check.\n\t\n2004-06-11 Sowmini Varadhan <sowmini.varadhan@sun.com>\n\n\t* filter.c: (access_list_remark_cmd) buffer_putstr doesnt need cast\n\t  to u_char. (ipv6_access_list_remark_cmd) ditto.\n\t  if.c: ditto\n\t* network.c: (readn/writen) pointer arg should be type u_char.\n\t* plist.c: needs to include stream.h, not declare stream functions\n\t  internally.\n\t  (various) Add static qualifier to internal functions.\n\t  (prefix_list_type_str) extraneous breaks in switch statement.\n\t  (ip_prefix_list_description_cmd) buffer_putstr doesnt need cast\n\t* stream.h: depends on plist.h and export stream_put_prefix\n\t* vty.c: (vty_<telnet option build functions>) should use \n\t  unsigned char, telnet options are 0 -> 255.\n\t* zclient.c: various u_char<->char type cleanups.\n\t* zebra.h: Having to define CMSG_* can apply to more than just\n\t  BSDI_NRL. \n\t  \n2004-06-09 Paul Jakma <paul@dishone.st>\n\n\t* zebra.h: __attribute__ is a gcc'ism\n\t\n2004-06-04 Paul Jakma <paul@dishone.st>\n\n        * type mismatch fixes\n        \n2004-05-18 Hasso Tepper <hasso@estpak.ee>\n\t\n\t* pqueue.[c|h]: Added as part of ospf6d merge from Zebra repository.\n\n2004-05-08 Paul Jakma <paul@dishone.st>\n\n\t* zclient.c (zapi_ipv4_route) Follow Sowmini's lead and describe\n\t  message format.\n\n2004-05-08 Sowmini Varadhan <sowmini.varadhan@sun.com>\n\n\t* zclient.c: (zapi_ipv4_add) collapsed into zapi_ipv4_route\n\t  (zapi_ipv4_delete) ditto.\n\t  (zapi_ipv4_route) add/delete a route by way of cmd arg.\n\t  (zapi_ipv6_add) collapsed into zapi_ipv6_route.\n\t  (zapi_ipv6_delete) ditto.\n\t  (zapi_ipv6_route) add/delete a route by way of cmd arg.\n\t  (zebra_interface_address_delete_read) collapsed into \n\t  zebra_interface_address_read.\n\t  (zebra_interface_address_delete_read) ditto.\n\t  (zebra_interface_address_read) read address add/delete messages\n\t  by way of type argument. Describe command message format.\n\t  (zebra_interface_add_read) Unconditionally read new ifmtu6 field.\n\t  Describe command message format.\n\t  (zebra_interface_state_read) Unconditionally read new ifmtu6 field.\n\t  (zclient_redistribute_set) Collapsed into zclient_redistribute\n\t  (zclient_redistribute_unset) ditto\n\t  (zclient_redistribute) set/unset redistribution.\n\t  (zclient_redistribute_default_set) Collapsed into\n\t  zclient_redistribute_default.\n\t  (zclient_redistribute_default_unset) ditto.\n\t  (zclient_redistribute_default) Redistribute default set/unset.\n\t* zclient.h: delete zapi_ipv{4,6}_add, zapi_ipv{4,6}_delete. Add\n\t  zapi_ipv{4,6}_route. delete zclient_redistribute_set/unset. Add\n\t  zclient_redistribute. Ditto for\n          zclient_redistribute_default_{set/unset}.\n          \n2004-05-08 Sowmini Varadhan <sowmini.varadhan@sun.com>\n\n\t* if.h: Add mtu6 field to struct interface, IPv6 MTU may differ\n\t  from IPv4, and Solaris treats the MTU's differently.\n\t  Add connected_add_by_prefix, for use by later patch.\n\t* if.c: (connected_add_by_prefix) Add prefix to connected list.\n\t  (if_flag_dump) Solaris: Dump IFF_IPv4/6 flag\n\t  (if_dump) Dump mtu6 flag, for HAVE_IPV6.\n\t* command.c: (sockunion_getsockname) use socklen_t for len.\n\t  (sockunion_getpeername) ditto.\n\t  \t  \n2004-04-21 Boris Kovalenko <boris@tagnet.ru>\n\n\t* daemon.c: (daemon) fix check for error return from setsid\n\t\n2004-01-19 Paul Jakma <paul@dishone.st>\n\n\t* sigevent.{c,h}: New files, implement event handled signals.\n\t  see signal_init() in sigevent.h.\n\t  \n2003-12-23  Vincent Jardin  <jardin@6wind.com>\n\n\t* {command.c, memory.c, vty.c, zebra.h}: Add isisd support\n\n2003-12-22  Greg Troxel  <gdt@fnord.ir.bbn.com>\n\n\t* vty.c (vty_use_backup_config): Don't free filenames before using\n\tthem for unlink.\n\n2003-08-20 Yasuhiro Ohara <yasu@sfc.wide.ad.jp>\n\n\t* command.c: Fix <cr> display problem for command line\n\t  description\n\n2003-05-24 Anil Madhavapeddy\n\n\t* (sockunion.c): Incorrect bounds specified in sockunion_log()\n\n2003-05-08 Sergiy Vyshnevetskiy <serg @ vostok.net>\n\n\t* vty.c: -A option\n\n2003-04-19 Hasso Tepper <hasso@estpak.ee>\n\n\t* rip_routemap.c: sync daemon's route-map commands to have same\n\tsyntax\n\n2002-09-28  Yasuhiro Ohara <yasu@sfc.wide.ad.jp>\n\n\t* vty.c (vty_flush): One line more on vty.\n\n2002-09-27  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* vector.c (vector_lookup): Add new function.\n\n2002-08-19  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* thread.c (timeval_adjust): Fix unconditional crush due to\n\tFreeBSD's select() system call timeval value check.\n\n2002-07-07  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* zebra-0.93 released.\n\n2002-06-21  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* if.c (ifc_pointopoint): Add ifc_pointopoint() accoding to Frank\n\tvan Maarseveen's suggestion.\n\n2002-06-18  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c: Change bcopy() to memcpy().\n\n2001-12-12  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c (config_password): Fix host.password clear bug.\n\tReported by Wang Jian <lark@linux.net.cn>.\n\n2001-08-29  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* thread.c (thread_should_yield): New function to check thread\n\tshould yeild it's execution to other thread.  Suggested by: Rick\n\tPayne <rickp@ayrnetworks.com>\n\n2001-08-20  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* thread.c (thread_timer_cmp): Rewrite function.\n\n\t* hash.c: Add hash_get().  Change hash_pull() to hash_release().\n\n2001-08-19  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* zebra-0.92a released.\n\n2001-08-15  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* zebra-0.92 released.\n\n2001-08-12  Akihiro Mizutani <mizutani@dml.com>\n\n\t* prefix.c (netmask_str2prefix_str): Convert \"1.1.0.0 255.255.0.0\"\n\tstring to \"1.1.0.0/16\".\n\n2001-08-10  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* filter.c (access_list_lookup): access_list_lookup's first\n\targument is changed from address family to AFI.\n\n\t* plist.c: (prefix_list_lookup): Likewise.\n\n2001-07-27  Akihiro Mizutani <mizutani@dml.com>\n\n\t* plist.c: ge and le display order is changed.  Old compatible\n\trule (len <= ge-value <= le-value) is removed.\n\n2001-07-08  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* prefix.h: Temporary fix for alignment of prefix problem.\n\n2001-06-21  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* prefix.h (struct prefix): Remove safi and padding field.\n\t(struct prefix_ipv4): Likewise.\n\t(struct prefix_ipv6): Likewise.\n\t(struct prefix_ls): Likewise.\n\t(struct prefix_rd): Likewise.\n\n\t* command.h (enum node_type): Preparation for BGP new config.\n\n\t* vty.c (vty_end_config): Likewise.\n\n2001-06-17  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* routemap.c (route_map_rule_delete): Call func_free when\n\troute-map rule is deleted.\n\n2001-06-14  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* routemap.c (route_map_index_lookup): Prevent to use deny and\n\tpermit for same route-map sequence.\n\n2001-04-12  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c (vty_read_config): Fix warning.\n\n2001-03-08  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c (IPV6_PREFIX_STR): Add '.' and '%' for IPv6 address\n\tstrings.\n\n2001-03-07  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* zebra.h (_XPG4_2): Define _XPG4_2 and __EXTENSIONS__ for\n\tCMSG_FIRSTHDR.\n\n2001-03-07  Michael Rozhavsky <mrozhavsky@opticalaccess.com>\n\n\t* zebra.h (struct in_pktinfo): structure in_pktinfo declaration.\n\n2001-02-19  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* memory.c (memory_list_lib): Add MTYPE_NEXTHOP for \"show memory\n\tlib\" member.\n\n2001-02-13  Matthew Grant <grantma@anathoth.gen.nz>\n\n\t* vty.c (vty_read_config): Revert check of integrate_default when\n\tVTYSH is defined.\n\n2001-02-13  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c (vty_read_config): Do not check integrate_default.  That\n\tshould be used only by vtysh.\n\n2001-02-08  Matthew Grant <grantma@anathoth.gen.nz>\n\n\t* vty.c (vty_serv_un): Set umask 0077.\n\t(vty_read_config): Stat for vtysh Zebra.conf, if found startup and\n\twait for boot configuration.\n\n\t* if.c (if_lookup_address): Make it smart implementation.\n\n\t* sockopt.c (setsockopt_multicast_ipv4): Set up a multicast socket\n\toptions for IPv4 This is here so that people only have to do their\n\tOS multicast mess in one place rather than all through zebra,\n\tospfd, and ripd .\n\n2001-02-04  Akihiro Mizutani <mizutani@dml.com>\n\n\t* plist.c (vty_prefix_list_install): Even when argument is\n\tinvalid, new memory is allocated.  Now memory allocation is done\n\tafter argument check.\n\n2001-02-01  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* zebra-0.91 is released.\n\n2001-01-31  Akihiro Mizutani <mizutani@dml.com>\n\n\t* vty.c (vty_login): Add vty login command.\n\n2001-01-31  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c (vty_reset): Close accept socket.\n\n2001-01-30  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* memory.h (enum): MTYPE_ATTR_TRANSIT is added for unknown transit\n\tattribute.\n\n2001-01-22  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* zclient.c (zebra_interface_address_add_read): Fetch interface\n\taddress flag.\n\t(zebra_interface_address_delete_read): Likewise.\n\n2001-01-16  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* table.c (route_node_match_ipv4): Utility function for IPv4\n\taddress lookup.\n\t(route_node_match_ipv6): Utility function for IPv4 address lookup.\n\n2001-01-15  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* if.c: Delete RIP_API part until new implementation comes out.\n\n2001-01-13  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* hash.h (struct Hash): Rename alloc to count.  Change type to\n\tunsigned long.\n\n\t* stream.c (stream_getc_from): New function.\n\t(stream_getw_from): Likewise.\n\n\t* zebra.h (ZEBRA_FLAG_STATIC): Add new flag for persistent route.\n\n2001-01-11  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* flap.c: File is removed.\n\n\t* flap.c: Likewise.\n\n\t* roken.h: Likewise.\n\n\t* buffer.c (buffer_new): Remove type option to buffer_new().\n\n2001-01-10  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* zclient.c (zapi_ipv4_delete): Remove OLD_RIB part.\n\n2001-01-09  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* zebra-0.90 is released.\n\n\t* command.c: Update Copyright year.\n\n2001-01-09  Matthew Grant <grantma@anathoth.gen.nz>\n\n\t* if.c (if_create): Register connected_free() function for\n\tdeletion.\n\t(if_delete): Free connected information when the interface is\n\tdeleted.\n\t(if_lookup_by_index): Fix argument type from int to unsigned int.\n\t(connected_add): Keep list in order if old info found, essential\n\tfor repeatable operation in some daemons.\n\n2001-01-09  endo@suri.co.jp (Masahiko Endo)\n\n\t* vty.c (vty_flush): When vty->statis is VTY_CLOSE do not add vty\n\tread thread.\n\n2001-01-08  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* filter.c (access_list_delete): Access-list name is not freed.\n\n\t* plist.c (prefix_list_delete): Prefix-list name is not freed.\n\n2000-12-29  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* zclient.c (zclient_start): Change to use UNIX domain\n\tsocket for zebra communication.\n\n\t* vector.c (vector_init): vector_alloc and vector_data_alloc is\n\tremoved.  All memory allocation count should be maintained by\n\tXMALLOC and XFREE macros.\n\n2000-12-28  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* zebra.h (ZEBRA_NEXTHOP_IFINDEX): Define ZEBRA_NEXTHOP_* values.\n\n2000-12-27  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* zebra.h (ZEBRA_ERR_RTEXIST): Make zebra error code to negative\n\tvalue.\n\n2000-12-25  \"Wataru Uno\" <wataru@po.ntts.co.jp>\n\n\t* vty.c (vtysh_read): Don't allocate new buffer because buffer is\n\tallocated in vty_new ().\n\n2000-12-14  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* memory.h (enum): Add MTYPE_AS_FILTER_STR.\n\n\t* command.c (config_write_terminal): Display \"end\" at the end of\n\tconfiguration.\n\n\t* plist.c (vty_prefix_list_install): Use AF_INET to determine\n\tlenum length.\n\n2000-12-13  \"Wataru Uno\" <wataru@po.ntts.co.jp>\n\n\t* buffer.c (buffer_flush_vty): If IOV_MAX defined in the System,\n\tthen all lines write by IOV_MAX.\n\n2000-12-12  Michael Rozhavsky <mrozhavsky@opticalaccess.com>\n\n\t* command.c (config_write_file): Robust method for writing\n\tconfiguration file and recover from backing up config file.\n\n2000-11-29  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* smux.c (smux_connect): More fail check.\n\t(smux_trap): When SMUX connection is not established, do nothing.\n\n2000-11-28  Gleb Natapov <gleb@nbase.co.il>\n\n\t* thread.c (thread_fetch): Execut event list first.  Old event\n\tlist is renamed to ready list.  With this change, event thread is\n\texecuted before any other thread.\n\n\t* thread.h (struct thread_master): Add ready list.\n\n2000-11-28  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* linklist.c (listnode_add_after): Add node right after the\n\tlistnode pointer.\n\n2000-11-27  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* smux.h: Pass struct variable to WriteMethod.\n\n2000-11-25  Frank van Maarseveen <F.vanMaarseveen@inter.NL.net>\n\n\t* if.c (if_lookup_address): When looking up interface with IP\n\taddress, Sometimes multiple interfaces will match.  Now PtP\n\tinterfaces prevail in such a case which seem the right thing to\n\tdo: There will probably also be host routes which usually prevail\n\tover network routes.\n\n2000-11-25  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* smux.c (smux_trap): SMUX trap implementation.\n\n2000-11-19  Akihiro Mizutani <mizutani@dml.com>\n\n\t* plist.c: Add automatic conversion function of an old rule. \n\tex.) 10.0.0.0/8 ge 8 -> 10.0.0.0/8 le 32\n\n2000-11-16  Yon Uriarte <ukl2@rz.uni-karlsruhe.de>\n\n\t* zclient.c (zebra_interface_add_read): Read hardware address when\n\thw_addr_len is greater than 0.\n\n2000-11-15  Akihiro Mizutani <mizutani@dml.com>\n\n\t* plist.c: The rule of \"len <= ge-value <= le-value\" \n\twas changed to \"len < ge-value <= le-value\".\n\n2000-11-09  Yasuhiro Ohara  <yasu@sfc.wide.ad.jp>\n\n\t* memory.[ch]: Added #define and functions for ospf6d.\n\n\t* log.[ch]: some platform says that the data of used va_list\n\tis undefined. Changed to hold list of va_list for each\n\tvsnprintf.\n\n2000-11-07  Rick Payne <rickp@rossfell.co.uk>\n\n\t* memory.h (enum): Add MTYPE_COMMUNITY_REGEXP.\n\n2000-11-06  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c (config_exit): Fix bug of missing break after case\n\tBGP_VPNV4_NODE.\n\n2000-10-30  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vector.c (vector_unset): Check i is not nevative.\n\n2000-10-24  Arkadiusz Miskiewicz <misiek@pld.org.pl>\n\n\t* smux.c (smux_sock): Set terminating '\\0'.  Check address family.\n\n\t* vty.c (vty_serv_sock_addrinfo): Set terminating '\\0'. Use\n\tgai_strerror.  Check address family.\n\n2000-10-23  Jochen Friedrich <jochen@scram.de>\n\n\t* smux.c: Use linklist rather than vector.\n\t(smux_getnext): A SMUX subagent has to behave as if it manages the\n\twhole SNMP MIB tree itself. It's the duty of the master agent to\n\tcollect the best answer and return it to the manager. See RFC 1227\n\tchapter 3.1.6 for the glory details :-). ucd-snmp really behaves\n\tbad here as it actually might ask multiple times for the same\n\tGETNEXT request as it throws away the answer when it expects it in\n\ta different subtree and might come back later with the very same\n\trequest.\n\n2000-10-23  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c (cmd_init): Log related command are only installed for\n\tterminal mode.\n\n2000-10-21  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* Makefile.am (libzebra_a_SOURCES): Remove duplicated buffer.c.\n\n\t* zebra.h: Remove #warn directive.\n\n2000-10-20  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* keychain.c (keychain_init): Register \"key chain\" command to\n\tKEYCHAIN_NODE and KEYCHAIN_KEY_NODE.\n\n\t* vty.c (vty_end_config): Fix missing vty_cinfig_unlock for other\n\tCONFIG_NODE.\n\n\t* command.c (config_end): Likewise.\n\n\t* keychain.c (keychain_get): Key is sorted by it's identifier\n\tvalue.\n\n2000-10-19  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* linklist.c (list_delete_all_node): Call delete function if it is\n\tdefined.\n\n\t* command.c (cmd_execute_command_strict): Add modification for\n\tvtysh.\n\t(cmd_execute_command_strict): Remove first argument cmdvec because\n\tit is global varibale in command.c.\n\n2000-10-18  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c (cmd_init): Install\n\tcopy_runningconfig_startupconfig_cmd only in terminal mode.\n\n\t* linklist.c (list_delete_node): Simplify the function.\n\t(listnode_lookup): Renamed from list_lookup_node.\n\n2000-10-17  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* stream.h: Undef stream_read and stream_write without\n\tparenthesis.\n\n\t* newlist.c: File removed.\n\n\t* newlist.h: Likewise.\n\n\t* linklist.c (list_new): Remove list_init().  To allocate new\n\tlinked list, please use list_new().\n\t(listnode_add): Remove list_add_node().  To add new node to linked\n\tlist, please use listnode_add().\n\t(list_delete_by_val): Revemove fucntion.\n\n2000-10-16  Nobuaki Tanaka <nobby@po.ntts.co.jp>\n\n\t* table.c (route_table_free): Reimplement route_table_free().\n\n2000-10-11  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* keychain.c (keychain_get): Register key_delete_func to key\n\tlist's delete function.  Use linklist.c instead of newlist.c.\n\n2000-10-04  Akihiro Mizutani <mizutani@dml.com>\n\n\t* filter.c (access_list_remark): Add access-list's remark command.\n\t(no_access_list): \"no access-list 100 permit any\" error message\n\tbug is fixed.\n\n2000-10-03  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* memory.h (enum): Add MTYPE_SOCKUNION.\n\n2000-10-02  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* zebra-0.89 is released.\n\n2000-10-01  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* linklist.c (list_add_node_head): Delete unused function.\n\t(list_add_node_tail): Likewise.\n\n2000-09-26  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* stream.c (stream_read_unblock): Add new function for unblocking\n\tread.\n\n2000-09-26  Jochen Friedrich <jochen@nwe.de>\n\n\t* smux.c (smux_register): Fix bug of can't register more than one\n\tMIB with SMUX.\n\n2000-09-26  Makoto Otsuka <otsuka@inl.ntts.co.jp>\n\n\t* vty.c (vty_close): Fix memory leak of sb_buffer.\n\t(vty_new): Likewise.\n\n2000-09-21  steve@Watt.COM (Steve Watt)\n\n\t* log.h: Do not declare zlog_priority[0] variable.\n\n2000-09-12  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* linklist.h (struct _list ): Add member cmp for compare function.\n\t(struct _list ): Member up is deleted\n\n2000-09-12  David Lipovkov <dlipovkov@OpticalAccess.com>\n\n\t* if.c: Include RIP_API header when RIP API is enabled.\n\n2000-09-10  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* prefix.c (prefix_free): Siplify prefix_free().\n\n\t* keychain.c (key_match_for_accept): strncmp check bug is fixed.\n\n2000-09-07  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* zebra.h: Merge roken.h into zebra.h.\n\n2000-09-05  Akihiro Mizutani <mizutani@dml.com>\n\n\t* routemap.c (route_map_init_vty): Install route-map command to\n\tRMAP_NODE.\n\n2000-08-22  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* thread.c (thread_get_id): Remove pthread related garbage.\n\n\t* command.h (struct host): Likewise.\n\n\t* zebra.h: Likewise.\n\n2000-08-20  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.h (node_type ): Add AAA node for authentication.\n\n\t* vty.c (vty_close): Do not close stdout.\n\n2000-08-18  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c (vty_init_vtysh): Added for vtysh.\n\n\t* distribute.c (districute_list_prefix_all): Interface independent\n\tfilter can be set.\n\t(distribute_list_all): Likewise.\n\t(config_show_distribute): Display current distribute-list status\n\tfor \"show ip protocols\".\n\n2000-08-18  Akihiro Mizutani <mizutani@dml.com>\n\n\t* command.c (config_terminal_no_length): no terminal monitor ->\n\tterminal no monitor\n\t(cmd_init): Do not install service_terminal_length_cmd into\n\tENABLE_NODE.\n\n\t* vty.c (terminal_no_monitor): no terminal length -> terminal no\n\tlength.\n\n2000-08-17  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* zebra-0.88 is released.\n\n2000-08-17  Magnus Ahltorp <ahltorp@nada.kth.se>\n\n\t* vty.h (struct vty ): Add iac_sb_in_progress and sb_buffer for\n\tbetter IAC handling.\n\n\t* vty.c (vty_telnet_option): Change telnet option handling.\n\n2000-08-15  Gleb Natapov <gleb@nbase.co.il>\n\n\t* zclient.c (zclient_redistribute_unset):  New function added.\n\n2000-08-14  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* zclient.c (zebra_interface_add_read): Change ifindex restore\n\tsize from two octet to four.\n\t(zebra_interface_state_read): Likewise.\n\t(zebra_interface_address_add_read): Likewise.\n\n2000-08-13  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c (vty_event): Use vector_set_index() instead of\n\tvector_set().\n\n2000-08-07  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* zebra.h (ZEBRA_XXX_DISTANCE_DEFAULT): Define Default\n\tAdministrative Distance of each protocol.\n\n2000-08-07  Matthew Grant <grantma@anathoth.gen.nz>\n\n\t* if.h (struct interface ): Add new member bandwidth to struct\n\tinterface.\n\n\t* zclient.c (zebra_interface_add_read): Fetch bandwidth value.\n\t(zebra_interface_state_read): Likewise.\n\n2000-08-07  Gleb Natapov <gleb@nbase.co.il>\n\n\t* routemap.c (route_map_event_hook): New hook route_map_event_hook\n\tis added.  This hook is called when route-map is changed. The\n\tparameters passed to the hook are 'event' and 'route-map name'\n\n\t* routemap.h: Add prototype for route_map_event_hook().\n\n2000-08-06  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* zclient.c (zebra_ipv4_route): zebra_ipv4_route(),\n\tzebra_ipv4_add(), zebra_ipv4_delete() are removed.\n\n\t* routemap.c (route_map_empty): Add new function.\n\t(route_map_delete): Use route_map_index_delete() instead of\n\troute_map_index_free().\n\t(route_map_index_free): Function removed.\n\n2000-08-06  Gleb Natapov <gleb@nbase.co.il>\n\n\t* routemap.c (route_map_index_delete): Add check for route-map is\n\tempty or not.\n\n2000-08-03  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* zclient.c (zebra_ipv4_add): Change socket arguemnt with struct\n\tzclient.\n\n2000-08-02  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* zclient.h (struct zebra): Add obuf for output buffer.\n\n\t* if.c: Remove #ifdef NRL enclosing if_nametoindex() and\n\tif_indextoname().\n\n2000-08-02  David Lipovkov <davidl@nbase.co.il>\n\n\t* if.h (IF_PSEUDO_UNSET): IF_PSEUDO related macro added.\n\t(IF_UNKNOWN_SET): IF_UNKNOWN related macro deleted.\n\n\t* if.c (interface_pseudo): Add \"pseudo\" command to interface node.\n\t(no_interface_pseudo): Add \"no pseudo\" command to interface node.\n\n\t* zclient.c (zebra_interface_add_read): Set pseudo flag when it is\n\tsend from zebra.\n\n2000-08-01  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* zebra.h (ZEBRA_IPV4_NEXTHOP_LOOKUP): Add new message.\n\t(ZEBRA_IPV6_NEXTHOP_LOOKUP): Likewise.\n\n\t* vty.c (vty_serv_un): Use AF_UNIX for backward compatibility.\n\n2000-07-31  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c: Use vector for VTY server thread listing instead of\n\tsingle value.\n\n2000-07-30  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* keychain.c (no_key_chain): \"no key chain WORD\" command is added.\n\n2000-07-29  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c (config_from_file): If command fail in\n\tKEYCHAIN_KEY_NODE, down to KEYCHAIN_NODE.\n\n\t* vty.h (struct vty ): Add index_sub member.\n\n2000-07-27  Akihiro Mizutani <mizutani@dml.com>\n\n\t* if.c: Help strings updates.\n\n2000-07-11  Akihiro Mizutani <mizutani@dml.com>\n\n\t* command.c (no_config_enable_password): Add \"no enable password\"\n\tcommand.\n\t(config_write_host): Display password string.\n\n\t* routemap.c (route_map_delete_match): Add support for delete\n\tmatch without argument.\n\t(route_map_delete_set): Likewise.\n\n2000-07-09  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.h (node_type ): Change KEYCHAIN_NODE and\n\tKEYCHAIN_KEY_NODE place just before INTERFACE_NODE.\n\n2000-07-09  Jochen Friedrich <jochen@scram.de>\n\n\t* smux.c (config_write_smux): Fixes the option to override OID and\n\tpassword for SMUX.\n\n2000-07-09  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.h (node_type ): Add SMUX_NODE for SMUX configuration.\n\n2000-07-09  Toshiaki Takada  <takada@zebra.org>\n\n\t* command.c: Sort descvec command's help.\n\n\t* vty.c (vty_describe_command): Display '<cr>' at the end of\n\tdescriptions.\n\n2000-07-05  Toshiaki Takada  <takada@zebra.org>\n\n\t* command.c (cmd_ipv6_match), (cmd_ipv6_prefix_match):  Fix bug\n\ttreatment of double colon.\n\n2000-07-04  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* zclient.h: Add zclient_redistribute_default_{set,unset}().\n\n\t* keychain.c: New file for authentication key management.\n\t* keychain.h: Likewise.\n\t\n\t* tcpfilter.c: New file for TCP/UDP base filtering using ipfw or\n\tipchains.\n\t* tcpfilter.h: Likewise.\n\t\n\t* flap.h: New file for route flap dampening.\n\t* flap.c: Likewise.\n\n2000-07-04  Toshiaki Takada <takada@zebra.org>\n\n\t* filter.c (struct filter): Add exact flag.\n\t(access_list): Add exact-match command.\n\t(ipv6_access_list): Add exact-match command.\n\t\n2000-07-03  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* zebra.h (ZEBRA_REDISTRIBUTE_DEFAULT_ADD): New message for\n\trequest default route.\n\n2000-07-01  Hideaki YOSHIFUJI (\u001b$B5HF#1QL@\u001b(B) <yoshfuji@ecei.tohoku.ac.jp>\n\n\t* smux.c: Add IPv6 smux connection code.\n\n2000-06-15  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c (vty_complete_command): To cooperate readline library,\n\treturned string is newly allocated.  So some match function case\n\tneed, free of memory.\n\n2000-06-12  Akihiro Mizutani <mizutani@dml.com>\n\n\t* distribute.c: Fix help strings.\n\n2000-06-11  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c (cmd_complete_command): Add check for vector_slot\n\t(vline, index) is not NULL when calculating lcd.\n\t(cmd_entry_function): First check variable arguemnt to prevent it\n\tfrom completion.\n\n2000-06-10  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.h (struct vty ): Add output_count member for displaying\n\toutput route count.  Remove arugment arg from output_func because\n\tthe value is passed by vty argument.  Change output to output_rn.\n\tAdd output_clean function pointer member.  Add output_type member.\n\n2000-06-10  Toshiaki Takada <takada@zebra.org>\n\n\t* command.c (show_startup_config): Add \"show startup-config\"\n\tcommand.\n\n2000-06-06  Akihiro Mizutani <mizutani@dml.com>\n\n\t* filter.c: Fix help strings.\n\n2000-06-05  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* prefix.h (struct prefix_rd): New prefix structure for routing\n\tdistinguisher.\n\t(struct prefix): Add padding to every prefix structure.\n\n\n\t* routemap.c (route_map_add_match): When completely same match\n\tstatement exists, don't duplicate it.\n\n2000-06-05  Akihiro Mizutani <mizutani@dml.com>\n\n\t* routemap.c: Change NAME to WORD.\n\n\t* plist.c: Fix help strings.\n\n2000-06-02  Akihiro Mizutani <mizutani@dml.com>\n\n\t* routemap.c: Fix route-map help strings.\n\n2000-06-01  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c (cmd_filter_by_completion): Fix CMD_VARARG treatment\n\tto filter other non vararg commands.\n\n\t* routemap.c (route_map_init_vty): Use install_default() for\n\tinstall common commands into route-map node..\n\n2000-06-01  Akihiro Mizutani  <mizutani@dml.com>\n\n\t* command.h (OSPF_STR):  Macro added.\n\n2000-05-31  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c (cmd_complete_command): LCD completion must not modify\n\tinstalled command string.\n\n\t* plist.c (ipv6_prefix_list): Fix wrong syntax definition.  Change\n\tX:X::X:X to X:X::X:X/M.\n\n2000-05-31  Toshiaki Takada  <takada@zebra.org>\n\n\t* vty.c (show_history):  New defun added.\n\n2000-05-30  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.h (CMD_COMPLETE_LIST_MATCH): New define for completion\n\tlist.  CMD_COMPLETE_MATCH is used for LCD completion.\n\n\t* vty.c (vty_complete_command): Matched string's LCD is completed.\n\n\t* command.c (cmd_lcd): New function for calculate LCD of matched\n\tstrings.\n\n2000-05-26  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c (install_default): config_write_terminal_cmd,\n\tconfig_write_file_cmd, config_write_memory_cmd are added to\n\tdefault node.\n\n\t* memory.c (memory_init): Divide show memory command into each\n\tsort.\n\n\t* command.c (cmd_init): config_write_terminal_cmd,\n\tconfig_write_file_cmd, config_write_memory_cmd are added to\n\tCONFIG_NODE.\n\n\t* routemap.c (route_map_index_free): New function.\n\t(no_route_map_all): New DEFUN for \"no route-map NAME\".\n\n\t* filter.c (no_access_list_all): New DEFUN for delete access-list\n\twith NAME.\n\t(no_ipv6_access_list_all): Likewise.\n\n2000-05-23  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* plist.c: Change IPV6_PREFIX to X:X::X:X.  When \"any\" is\n\tspecified, user can not use \"ge\" and \"le\" statement.\n\n2000-05-22  Thomas Molkenbur <tmo@datus.datus.com>\n\n\t* routemap.c (route_map_add_set): Fix bug of next pointer missing.\n\n\t* table.c (route_table_free): Like wise.\n\n2000-05-22  Toshiaki Takada  <takada@zebra.org>\n\n\t* vty.c (vty_stop_input): Set history pointer to the latest one.\n\n\t* vty.c (vty_hist_add): Do not add command line history when input\n\tis as same as previous one.\n\n2000-05-14  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* memory.h (enum): Add MTYPE_ECOMMUNITY and MTYPE_ECOMMUNITY_VAL.\n\n2000-05-13  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.h (node_type ): Add BGP_VPNV4_NODE.\n\n2000-05-08  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c (vtysh_accept): Add cast of struct sockaddr * to bind\n\targument.  Reported by: Vesselin Mladenov <mladenov@netbg.com>.\n\n\t* filter.c (ipv6_access_list): Add IPv6 prefix example instead of\n\tIPv4 example.  Reported by: Love <lha@s3.kth.se>.\n\n\t* command.c (cmd_complete_command): Make it sure last element of\n\tmatchvec is NULL.  This fix problem which cause crush in\n\tvty_complete_command().  Reported by: JINMEI Tatuya\n\t<jinmei@isl.rdc.toshiba.co.jp>.\n\n2000-04-28  Love <lha@s3.kth.se>\n\n\t* prefix.h (struct prefix): Add padding.\n\n2000-04-28  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c (show_version): Update copyright year.\n\n2000-04-27  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* routemap.c (route_map_apply): When map is NULL, return deny.\n\n2000-04-26  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* filter.c (access_list_apply): When access is NULL, return deny.\n\n\t* plist.c (prefix_list_apply): When plist is NULL, return deny.\n\n2000-04-23  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.h (node_type ): Change RDISC_NODE to IRDP_NODE.\n\n2000-04-18  Toshiaki Takada  <takada@zebra.org>\n\n\t* filter.[ch] (access_list_add_hook), (access_list_delete_hook):\n\tAdd argument for hook function to give struct access_list *.\n\n2000-04-17  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* plist.c (prefix_list_entry_match): In case of le nor ge is\n\tspecified, exact match is performed.\n\t(prefix_list_entry_match): Add any entry matching check.\n\n2000-04-09  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c (exec_timeout): Separate timeout setting to minutes and\n\tseconds.\n\t(no_exec_timeout): Add \"no exec-timeout\" command.\n\n\t* vty.h (VTY_TIMEOUT_DEFAULT): Change default value from 300 to\n\t600.\n\n2000-03-31  Jochen Friedrich <jochen@scram.de>\n\n\t* smux.h (SMUX_CLOSE): The SMUX_CLOSE PDU is implicit integer, so\n\tit is a primitive encoding and not constructed.\n\n2000-03-28  Toshiaki Takada  <takada@zebra.org>\n\n\t* memory.[ch] (enum): Add MTYPE_OSPF_EXTERNAL_INFO.\n\n2000-03-26  Love <lha@s3.kth.se>\n\n\t* zclient.c (zclient_read): Add nbytes size check for\n\tZEBRA_HEADER_SIZE.  Check return value of steam_read ().\n\n2000-03-26  Rick Payne <rickp@rossfell.co.uk>\n\n\t* routemap.c: Add flexible route-map commands such as on-match\n\tnext, on-match goto N.\n\n\t* routemap.h: Likewise\n\n2000-03-23  Adrian Bool <aid@u.net.uk>\n\n\t* command.c (config_log_trap): Add new command \"log trap\n\tPRIORITY\".\n\n2000-03-14  Toshiaki Takada  <takada@zebra.org>\n\n\t* memory.c (struct memory_list): Add Link List and Link Node\n\tto view.\n\t\n\t* memory.h (enum): Remove MTYPE_OSPF_EXTERNAL_ROUTE.\n\t\n2000-01-20  Hideto Yamakawa <hideto.yamakawa@soliton.co.jp>\n\n\t* str.c (snprintf): Fix bug of calling sprintf instead of\n\tvsprintf.\n\n2000-01-16  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* memory.h (enum): Add MTYPE_RIP_PEER.\n\n2000-01-15  Toshiaki Takada  <takada@zebra.org>\n\n\t* memory.h (enum): Add MTYPE_OSPF_CRYPT_KEY.\n\n2000-01-15  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.h (node_type ): Add MASC_NODE for masc.\n\n2000-01-09  Wang Jianliang <wangjl@soim.net>\n\n\t* routemap.c (route_map_index_add): When route_map_index is not\n\tempty and insert new item at the head, it can cause core dump.\n\tFix \"if (index == map->head)\" to \"if (point == map->head).\n\t(route_map_add_set): If there is an old set command, override old\n\tset command with new one.\n\t(route_map_index_delete): Use while() instead of for for() for\n\tlogical correctness.\n\n1999-12-26  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* memory.h (enum): Add MTYPE_BGP_STATIC.\n\n1999-12-23  Alex Zinin <zinin@amt.ru>\n\t* zebra.h, zclient.*: dynamic int up/down message\n\tsupport\n\n1999-12-10  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* thread.c (thread_cancel_event): Add a function for clean up\n\tevents.\n\n1999-12-09  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* dropline.c: Delete file.\n\tdropline.h: Linewise.\t\n\n1999-12-14  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* filter.c (access_list_filter_delete): Wrong pointer\n\taccess->master was pointed out after access is freed.  I store\n\tmaster value at the beginning of the function.\n\n1999-12-08  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c (exec_timeout): Change of VTY timeout affect to current\n\tVTY connection.\n\t(vty_accept): Instead of immediate exit() return -1.\n\n1999-12-07  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c (vty_configure_lock): Configuration lock function added.\n\tOnly one VTY can use CONFI_NODE at the same time.\n\n\t* log.c: Delete zvlog_* functions.  Now zlog_* does the same\n\tthing.\n\n\t* log.c (log_init): Function removed.\n\t(log_close): Likewise.\n\t(log_flush): Likewise.\n\t(log_open): Likewise.\n\n\t* vty.c (terminal_monitor): Add new command.\n\t(no_terminal_monitor): Likewise.\n\n\t* log.c (old_log): Function removed.\n\t(old_log2): Likewise.\n\t(old_log_warn): Likewise.\n\n1999-12-04  Toshiaki Takada  <takada@zebra.org>\n\n\t* command.c (cmd_ipv6_match): New function added.\n\t(cmd_ipv6_prefix_match): Likewise.\n\t\n1999-12-04  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c (cmd_ipv6_match): \n\n\t* table.c: Delete #ifdef HAVE_MBGPV4.\n\n\t* prefix.h (struct prefix): Add safi member.\n\t(struct prefix_ipv4): Likewise.\n\t(struct prefix_ipv6): Likewise.\n\n1999-12-04  Rumen Svobodnikov <rumen@linux.tu-varna.acad.bg>\n\n\t* memory.c (struct mstat): Revert to support MEMORY_LOG.\n\n1999-11-25  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* version.h: Bump up to 0.81c for testing new kernel codes.\n\n1999-11-21  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* thread.h (struct thread): Pthread support is disabled all\n\tplatform.\n\n1999-11-21  Michael Handler <handler@sub-rosa.com>\n\n\t* Include <limits.h> and <strings.h> under SUNOS_5.\n\n1999-11-21  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* sockunion.c (in6addr_cmp): Enclosed by #define HAVE_IPV6\n1999-11-13  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.h (node_type ): Add BGP_IPV4_NODE and BGP_IPV6_NODE.\n\n1999-11-12  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c (disable): Add `disable' command.\n\n1999-11-09  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* plist.c (vty_prefix_list_install): Add any check.\n\n1999-11-04  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.h (node_type ): Add DUMP_NODE.\n\n1999-11-03  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* smux.c: Change default SMUX oid to compatible with gated.\n\n1999-10-30  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* if_rmap.c: New file added.\n\n\t* if_rmap.h: New file added.\n\n1999-10-29  Alex Zinin  <zinin@amt.ru>\n\n\t* hash.c: add hash_free() function\n\n1999-10-25  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* hash.c (hash_clean): Add clean function.\n\n\t* plist.c (prefix_list_reset): Add reset function.\n\n\t* filter.c (access_list_reset): Add reset function.\n\n1999-10-17  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* client.c: Merged with zclient.c.\n\t* client.h: Merged with zclient.h.\n\n1999-10-15  Jordan Mendelson <jordy@wserv.com>\n\n\t* md5.c: Imported from GNU C Library.\n\t* md5-gnu.h: Likewise.\n\n1999-10-15  Jochen Friedrich <jochen@scram.de>\n\n\t* smux.c (smux_getresp_send): SMUX_GETRSP codes improvement.\n\n1999-10-06  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* smux.h: New file added.\n\n\t* snmp.c: Rename to smux.c.\n\n1999-10-02  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c (cmd_execute_command_strict): Filter ambious commands.\n\t(cmd_filter_by_string): Change to return enum match_type.\n\n1999-10-01  Toshiaki Takada  <takada@zebra.org>\n\n\t* vty.c (vty_describe_fold): New function which does VTY\n\tdescription line fold.\n\t* vty.c (vty_describe_command): Set description column.\n\n1999-09-30  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* plist.c (prefix_list_init_ipv4): VTY user interface is improved.\n\n1999-09-26  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c (cmd_filter_by_string): Fix bug of CMD_IPV4 and\n\tCMD_IPV4_PREFIX check.  Both return type must be exact_match.\n\n1999-09-24  Toshiaki Takada  <takada@zebra.org>\n\n\t* command.c (cmd_filter_by_completion),\n\t(is_cmd_ambiguous): Check IPv4 address, IPv4 prefix and range \n\tparameter matches range.\n\n1999-09-22  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* routemap.c (route_map_apply): Returm RM_DENYMATCH when no match\n\tis performed.\n\n1999-09-21  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c (vty_read): Control-C stop VTY_MORE mode.\n\n1999-09-20  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.h (node_type ): Add ACCESS_IPV6_NODE and\n\tPREFIX_IPV6_NODE.\n\n\t* distribute.h: New file added.\n\n\t* command.h (node_type ): Delete DISTRIBUTE_NODE.\n\n1999-09-18  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c (vty_terminate_all): New function added for reload\n\tsupport.\n\n1999-09-06  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* memory.h (enum): Add new type MTYPE_OSPF_EXTERNAL_ROUTE.\n\n1999-08-31  Janos Farkas <chexum@shadow.banki.hu>\n\n\t* vty.c (vty_read): Handle also 0x7f (alt-backspace), just like\n\tesc-ctrl-h (delete word backwards).\n\n1999-08-24  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* if.h: Add if_nametoindex for NRL.\n\n1999-08-23  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* if.c (if_create): New function.\n\n1999-08-22  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* snmp.c: New file.\n\n1999-08-21  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* stream.c (stream_put): stream_memcpy () is changed to stream_put\n\t().  stream_get () is added.\n\n1999-08-18  Toshiaki Takada  <takada@zebra.org>\n\n\t* memory.h (enum): Add MTYPE_OSPF_LSA_DATA.\n\t\n1999-08-18  Yasuhiro Ohara  <yasu@sfc.wide.ad.jp>\n\n\t* table.c (route_table_finish): add function frees table.\n\n1999-08-12  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* memory.h (enum): Add MTYPE_RTADV_PREFIX.\n\n1999-08-11  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* if.h (struct interface ): hw_address, hw_address_len added.\n\n1999-08-10  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* if.h (struct interface ): Change structure member if_data to\n\tinfo, index to ifindex.\n\n1999-08-08  Rick Payne <rickp@rossfell.co.uk>\n\n\t* routemap.c: Multi protocol route-map modification.\n\n\t* routemap.c (route_map_apply): Route match process bug is fixed.\n\n1999-08-05  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* thread.c (thread_fetch): When signal comes, goto retry point.\n\n1999-08-04  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* Makefile.am: Add sockopt.c and sockopt.h\n\t* sockopt.c: New file.\n\t* sockopt.h: New file.\n\t\n1999-08-02  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* version.h (ZEBRA_VERSION): Release zebra-0.75\n\n1999-08-01  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* memory.h (enum): Add MTYPE_RIPNG_AGGREGATE.\n\n1999-07-31  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* sockunion.h: Add sockunion_getpeername ().\n\n1999-07-27  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* version.h: Release zebra-0.74\n\n1999-07-26  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.h (struct host): Delete lines from struct host.  Add\n\tlines to struct vty.\n\n\t* command.c: Delete `lines LINES'.  Terminal display line settings\n\tshould be done by `terminal length' command.\n\n1999-07-24  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* memory.h (enum): MTYPE_OSPF_PATH are added.\n\n1999-07-22  Toshiaki Takada  <takada@zebra.org>\n\n\t* memory.h (enum): MTYPE_OSPF_NEXTHOP is added.\n\n1999-07-21  Toshiaki Takada  <takada@zebra.org>\n\n\t* linklist.c (list_add_node_prev), (list_add_node_next),\n\t(list_add_list): New function added.\n\n\t* table.c (route_table_free): New function added.\n\t\n1999-07-21  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* plist.c (config_write_prefix): Set write flag when configuration\n\tis written.\n\n1999-07-15  Yasuhiro Ohara  <yasu@sfc.wide.ad.jp> \n\n\t* prefix.c : prefix_cmp() added. change apply_mask() to\n\tapply_mask_ipv4(), and new apply_mask() added.\n\n1999-07-14  Yasuhiro Ohara  <yasu@sfc.wide.ad.jp>\n\n\t* prefix.c (prefix2str): append prefixlen.\n\n1999-07-13  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c (config_terminal): Change \"config terminal\" to\n\t\"configure terminal\".  Reported by Georg Hitsch\n\t<georg@atnet.at>.\n\t(config_terminal_length): `terminal length <0-512>' is added.  At\n\tthis moment this command is only usef for vty interface.\n\tSuggested by Georg Hitsch <georg@atnet.at>.\n\n1999-07-12  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* routemap.c (rulecmp): Add wrapper function of strcmp.\n\n1999-07-08  Rick Payne <rickp@rossfell.co.uk>\n\n\t* sockunion.c (inet_aton): Fix bug of inet_aton.\n\n1999-07-08  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* version.h (ZEBRA_VERSION): Start zebra-0.73\n\n1999-07-06  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* version.h: Bump up to 0.72.\n\n1999-07-05  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c (install_default): New function for install default\n\tcommands to the node.\n\n\t* memory.h (enum): MTYPE_NEXTHOP is added.\n\n1999-07-01    <kunihiro@zebra.org>\n\n\t* command.c (no_banner_motd): `no banner motd' command added.\n\n1999-06-30  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* regex.c: Update to glibc-2.1.1's posix/regex.c\n\n\t* regex-gnu.h: Update to glibc-2.1.1's posix/regex.h\n\n\t* prefix.h (IPV4_ADDR_SAME): Macro added.\n\t(IPV6_ADDR_SAME): Likewise.\n\n1999-06-29  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* memory.h (enum): Add MTYPE_OSPF_VERTEX\n\n\t* version.h: Bump up to 0.71.\n\n\t* vty.c (vty_serv_sock_addrinfo): Use addrinfo function to bind\n\tVTY socket when IPv6 is enabled.\n\n1999-06-28  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c (vty_serv_sock): Change vty_serv_sock determine which\n\taddress family to bind.\n\n\t* command.c: Add quit command.\n\n1999-06-26  NOGUCHI kay <kay@dti.ad.jp>\n\n\t* vty.c (vty_read_config): Fix bug of configuration file path\n\tdetection.\n\n1999-06-25  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* version.h: Bump up to 0.70.\n\n1999-06-17  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* buffer.h (GETL): Remove GETL macro.\n\n\t* version.h: Bump up to 0.69.\n\n1999-06-14  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* if.c (connected_add): Commented out connected_log.\n\n1999-06-13  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.h (struct cmd_element ): strvec and descvec is combined\n\tinto newstrvec.\n\n\t* command.c (desc_make): Function removed.\n\t(desc_next): Function removed.\n\n\t* command.h (struct cmd_element ): docvec is removed from struct\n\tcmd_element.\n\n1999-06-12  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c (cmd_execute_command): Remove command NULL check.\n\n\t* command.h (struct cmd_element ): Add newstrvec entry to struct\n\tcmd_element.\n\t(DEFUN2): DEFUN2 macro is removed.  DEFUN is extended to support\n\t(a|b|c) statement.\n\t(DESC): DESC macro is removed.\n\n\t* vty.c (vty_complete_command): When return value is\n\tCMD_ERR_NO_MATCH, don't display error message.\n\n1999-06-08  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* table.c (route_next_until): New function.\n\n\t* version.h: Bump up to 0.68.\n\n1999-06-06  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c (vty_close): Free vty->buf when vty is closed.\n\n\t* memory.h (enum): Add MTYPE_COMMUNITY_ENTRY and\n\tMTYPE_COMMUNITY_LIST.\n\n\t* vty.h (struct vty ): Change buf from static length buffer to\n\tvariable length buffer.\n\n\t* vty.c (vty_ensure): New function added.\n\t\n1999-06-04  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.h (node_type ): Add COMMUNITY_LIST_NODE.\n\n\t* command.c (config_enable_password): Freeing host.enable bug is\n\tfixed.\n\t(config_enable_password): Add argc count check.\n\n1999-05-31  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* version.h: Bump up to 0.67.\n\n1999-05-30  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c (zencrypt): New function for encrypt password.\n\n\t* command.h (struct host): Add password_encrypt and\n\tenable_encrypt.\n\n1999-05-30  Jochen Friedrich <jochen@scram.de>\n\n\t* command.h (struct host): New member encrypt is added for\n\tencrypted password.\n\n1999-05-30  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c: Remove all_digit_check function.  Instead use all_digit.\n\n\t* prefix.c (all_digit): New function for checking string is made\n\tfrom digit character.\n\n1999-05-25  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* Makefile.am (libzebra_a_SOURCES): Add zclient.c.\n\t(noinst_HEADERS): Add zclient.h\n\n\t* zclient.[ch]: New file for zebra client routine.\n\n\t* memory.h (enum): Add MTYPE_ZEBRA.\n\n1999-05-19  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* version.h (ZEBRA_VERSION): Update to 0.66.\n\n1999-05-15  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* buffer.h (GETC,GETW): Macro deleted.\n\n1999-05-15  Carlos Alberto Barcenilla <barce@frlp.utn.edu.ar>\n\n\t* prefix.h (IPV4_NET0, IPV4_NET127): Macro added.\n\n1999-05-15  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c (service_advanced_vty): New command added.\n\t(no_service_advanced_vty): Likewise.\n\n1999-05-14  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c (vty_auth): If advanced flag is set and enable password is\n\tnot set, directly login to the ENABLE_NODE.  This feature is\n\toriginally designed and implemented by Stephen R. van den Berg\n\t<srb@cuci.nl>.\n\n\t* command.h (host): Add advanced flag to struct host for advanced\n\tvty terminal interface.\n\n\t* version.h (ZEBRA_VERSION): Update to 0.65 for next beta release.\n\n1999-05-14  Stephen R. van den Berg <srb@cuci.nl>\n\n\t* command.h (node_type ): Add TABLE_NODE.\n\t\n\t* vty.c (vty_telnet_option): Check host.lines value.\n\n\t* command.c (config_lines): DEFUN for 'lines LINES' command.\n\n\t* zebra.h: Include <sys/utsname.h> for uname().\n\t(RT_TABLE_MAIN): Defined as 0 if OS does not support multiple\n\trouting table.\n\n\t* vty.c (vty_auth): Directly login to the ENABLE_NODE when enable\n\tpassword is not set.\n\t(vty_prompt): Get machine's hostname when hostname is not set.\n\n1999-05-11  James Willard <james@whispering.org>\n\n\t* command.c (config_exit): Close connection when `exit' command is\n\texecuted at ENABLE_NODE.\n\n1999-05-10  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c (vty_stop_input): `C-c' key change node to ENABLE_NODE.\n\n\t* command.c (cmd_execute_command_strict): Matched command size\n\tcheck added.\n\t(cmd_make_desc_line): New function for DEFUN2.\n\n\t* command.h (struct cmd_element ): Add descsize.\n\n1999-05-09  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.h (struct cmd_element ): Remame descvec to docvec.\n\t(struct cmd_element ): Add descvec for new description system.\n\n\t* command.c (desc_make): Check cmd->descvec.\n\n1999-05-06  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* memory.h (enum): Add MTYPE_CLUSTER, MTYPE_CLUSTER_VAL.\n\n1999-05-05  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* version.h (ZEBRA_VERSION): Bump up to 0.64 for next beta\n\trelease.\n\n1999-05-04  Yasuhiro Ohara <yasu@sfc.wide.ad.jp>\n\n\t* linklist.c (list_delete_all_node): bug fix. \n\tprevious code loses current position when node\n\tis deleted.\n\n1999-05-03  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.h (DESC): Macro added.\n\t(struct cmd_element2): Delete struct cmd_element2.\n\n\t* plist.c (prefix_list): Sequential number option check is added.\n\n1999-05-02  Yasuhiro Ohara <yasu@sfc.wide.ad.jp>\n\n\t* log.c (zvlog_{debug,info,notice,warn,err}): have been\n\tadded. now we can log both console and file, but still \n\tneed some fix about config write.\n\n1999-05-02  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* log.c (zvlog_debug): Fix yasu's change.\n\n1999-05-01  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* plist.c (prefix_list): Fix typo.\n\n1999-04-30  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* Set version to 0.63 for first beta package.\n\n1999-04-27  Carlos Barcenilla <barce@frlp.utn.edu.ar>\n\n\t* prefix.c (str2prefix_ipv4): Fix prefix length check.\n\t(str2prefix_ipv6): Likewise.\n\n1999-04-25  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* memory.h (enum): Add MTPYE_PREFIX_LIST and\n\tMTYPE_PREFIX_LIST_ENTRY.\n\n\t* command.h (node_type ): Add PREFIX_NODE.\n\n1999-04-25  Carlos Barcenilla <barce@frlp.utn.edu.ar>\n\n\t* command.c: ALIAS (config_write_memory_cmd) and ALIAS\n\t(copy_runningconfig_startupconfig_cmd) is added.\n\n\t* table.c (route_node_lookup): Unused match variable deletion.\n\n1999-04-24  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* Makefile.am (libzebra_a_SOURCES): plist.c added.\n\t(noinst_HEADERS): plist.h added.\n\n\t* plist.c, plist.h: New file added.\n\n\t* memory.h (enum): Rename MTYPE_AS_PASN to MTYPE_AS_STR.\n\t* memory.c: Likewise.\n\n1999-04-19  Carlos Alberto Barcenilla <barce@frlp.utn.edu.ar>\n\n\t* command.c (show_version): `show version' command added.\n\n1999-04-19  Kunihiro Ishiguro <kunihiro@zebra.org>\n\n\t* prefix.c (str2prefix_ipv6): Prefix length overflow check.\n\n1999-04-19  Carlos Alberto Barcenilla <barce@frlp.utn.edu.ar>\n\n\t* prefix.c (str2prefix_ipv4): Prefix length overflow check.\n\n1999-04-19  Alex Bligh <amb@gxn.net>\n\n\t* prefix.c (sockunion2hostprefix): Function added.\n\t(sockunion2prefix): Address family was not set.  Now it is set.\n\t\n\t* vty.c: VTY access-class command is added.\n\n1999-04-18  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* memory.c: Change xmalloc to zmalloc.  xcalloc, xrealloc, xfree,\n\txstrdup are likewise.\n\n1999-04-18  Yasuhiro Ohara <yasu@sfc.wide.ad.jp>\n\n\t* thread.c: Add thread_execute for other routing daemon.\n\tOSPF tasks need to be generated by \"sheduled\" and \"executed\".\n\n1999-04-13  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* buffer.c: Rewrite buffer_write and buffer_flush related\n\tfunctions for fixing bugs.  Reason of the problem and fix is\n\tsuggested by Alex Bligh <amb@gxn.net>.\n\t\n1999-04-12  Alex Bligh <amb@gxn.net>\n\n\t* command.c (cmd_entry_function_descr): Added for variable\n\targument help display.\n\n1999-04-07  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* regex.c, regex-gnu.h: Imported from GNU sed-3.02 distribution.\n\n1999-03-24  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* stream.c: stream_fifo_free bug is fixed.\n\n1999-03-19  Toshiaki Takada  <takada@zebra.org>\n\n\t* stream.c (stream_strncpy): Added for getting any length bytes\n\tfrom stream.\n\n1999-03-16  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* version.h (ZEBRA_BUG_ADDRESS): New macro added.\n\n1999-03-14  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* buffer.c (buffer_flush_window): If ep is same as buffer's size\n\tlength and lp is overrun one octet.\n\n1999-03-13  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.h: add VTY's timeout function.\n\n1999-03-05    <kunihiro@zebra.org>\n\n\t* command.h (node_type ): Add OSPF6_node.\n\n1999-03-04  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* zebra.h: Check HAVE_SYS_SELECT_H when include <sys/select.h>\n\n1999-03-03  Jeroen Ruigrok/Asmodai <asmodai@wxs.nl>\n\n\t* zebra.h: Include <net/if_var.h> if it exists.\n\n1999-03-02  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* getopt.[ch],getopt1.c: Sync with glibc-2.1.\n\n\t* log.c (zlog): Tempolary ZLOG_STDOUT feature added.\n\n\t* command.h: Include vector.h and vty.h\n\n1999-02-25  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* routemap.h (struct route_map_rule_cmd): Add prefix arguemnt.\n\n\t* routemap.c (route_map_apply_index): Add prefix argument.\n\t(route_map_apply): Likewise.\n\n\t* memory.h (enum): Add MTYPE_ROUTE_MAP_COMPILED.\n\n\t* stream.c: Add stream_fifo related functions.\n\n1999-02-24  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* daemon.c: Return integer value.  File descriptor close is added.\n\n\t* memory.h (enum): add MTYPE_OSPF_LSA.\n\n1999-02-23  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* rsh.c: Remove empty file.\n\n1999-02-22    <kunihiro@zebra.org>\n\n\t* routemap.c: Add add/delete hook to route_map_master.\n\n1999-02-19  Peter Galbavy  <Peter.Galbavy@knowledge.com>\n\n\t* str.[ch] added to supply wrappers for snprintf(), strlcat() and\n\tstrlcpy on system without these.\n\n1999-02-18  Peter Galbavy  <Peter.Galbavy@knowledge.com>\n\n\t* syslog support added\n\n1999-02-02  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* filter.c (access_list_add_hook): added for hook function management.\n\t* filter.c (access_list_delete_hook): Likewise.\n\n1999-01-19  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* stream.c: New file.\n\t* stream.h: New file.\n\t* Divide stream related fucntions from buffer.[ch] into stream.[ch].\n\t\n1999-01-14  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* memory.h (enum): add MTYPE_STREAM, MTYPE_STREAM_DATA\n\n\t* buffer.c (stream_new): Set MTYPE_STREAM to XMALLOC argument.\n\n1998-12-23  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* routemap.c: route_map_index_delete() added.\n\n1998-12-22  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* buffer.c (buffer_empty): check cp instead of sp.\n\n1998-12-17  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* radix.[ch]: Deleted.\n\n1998-12-15  Magnus Ahltorp <map@stacken.kth.se>\n\n\t* buffer.c: Prototype fixes.\n\t* prefix.c: Likewise.\n\t* sockunion.c: Likewise.\n\t* sockunion.h: Likewise.\n\n1998-12-14  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c (vty_read): DELETE key works as vty_delete_char.\n\n1998-12-13  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* log.c (time_print): chane %y to %Y.\n\n1998-12-10  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* distribute.c: new file.\n\n1998-12-09  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* filter.c: Remove all of struct prefix_{ipv4,ipv6} and add\n\tcomplete support of IPv6 access list.\n\n\t* command.c (config_write_element): function delete.\n\t(config_write_host): function add.  password and enable password\n\tisn't printed to vty interface.\n\n1998-12-08  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* filter.c: Change prefix_ipv4 to prefix and add support of\n\tprefix_ipv6 filtering.\n\n1998-12-07  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* Makefile.am (INCLUDES): add @INCLUDES@ for Linux IPv6 inet6-apps\n\theader includes.\n\n1998-12-05  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* log.c (log_flush): fix function name typo.\n\n1998-12-04  Yasuhiro Ohara <yasu@sfc.wide.ad.jp>\n\n\t* memory.h: OSPF memory type is added.\n\n1998-11-15  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c (sort_node): add sort_node() for pretty printing of\n\tcommand on vty interface.\n\t(config_password): delete the restriction of charaster of password\n\tstring.\n\n1998-09-05  Kunihiro Ishiguro  <kunihiro@debian.zebra.org>\n\n\t* prefix.c (prefix_ipv4_any): add prefix_ipv4_any().\n\n1998-08-25  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* network.h: New file.\n\n1998-08-24  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c (vty_will_echo): function name change from vty_off_echo.\n\n1998-08-18  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* buffer.h: add PUTC,PUTW,PUTL macros.\n\n1998-07-22  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* route.[ch]: renamed to prefix.[ch]\n\n1998-06-09  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* prefix_in, prefix_in6 is replaced by prefix_ipv4, prefix_ipv6.\n\n\t* Makefile.am: @INCLUDES@ is deleted from INCLUDES.\n\n1998-06-07  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* host.[ch]: merged with command.[ch]\n\n1998-05-08  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* Makefile.am (libzebra_a_SOURCES): add route.c to libzebra_a_SOURCES.\n\n1998-05-07  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* route.c (str2prefix): str2prefix () is gone.\n\n1998-05-03  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c (vty_read_config): change CONDIR to SYSCONFDIR.\n\n\t* .cvsignore: add file.\n\n\t* memory.c (xerror): add arguent `type' and `size'.\n\n\t* socket.c: deleted.\n\n1998-05-02  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vector.c: malloc,free,realloc -> XMALLOC,XFREE,XREALLOC.\n\t* linklist.c: same as above.\n\n1998-04-30  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* filter.[ch]: added.\n\n1998-04-01  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c (config_who): return CMD_SUCCESS\n\n1998-04-01  Jochen Friedrich <jochen@scram.de>\n\n\t* table.c (route_dump_node): route_dump_node is IPv6 specific\n\tfunction so move #ifdef to the end of route_dump_node ().\n\n1998-03-05  \"Hannes R. Boehm\" <hannes@boehm.org>\n\n\t* if.c: DEFUN(interface_desc) added.\n\n1998-03-05  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* if.c: separated from ripd/rip_interface.c\n\n1998-03-04  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* thread.[ch] : added.\n\n1998-02-14  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c (vty_delete_char): fix size bug.\n\t(vty_backward_pure_word): function added.\n\t(vty_read): ESC + 'f' perform vty_forward_word.\n\t(vty_read): ESC + 'b' perform vty_backward_word.\n\n1998-02-11  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* radix.c (radix_lookup_rt): add mask check.\n\t(radix_delete_duproute): add mask check.\n\n1998-02-10  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c (config_write_file): fix vty -> file_vty.\n\n1998-02-06  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c (cmd_filter_ambiguous): add complex type treatment.\n\n1998-02-05  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c (vty_time_print): function added.\n\t(vty_complete_command): now [...] element isn't shown by completion.\n\n1998-01-26  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c : change from cmd_install_node() to install_node().\n\n1998-01-16  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* route.[ch]: struct rt{} is replaced by struct prefix{}.\n\n1998-01-06  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c (cmd_execute_command): check command length.\n\n\t* timer.c (zebra_timer_set): add zebra_timer_set.\n\n1998-01-05  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.h (node_type ): add ZEBRA_NODE.\n\n\t* command.c (config_exit): add RIP_NODE.\n\t(config_write_file): add RIP_NODE.\n\n1998-01-04  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* print_version.c (print_version): Now Copyright is 1996-1998.\n\n\t* sockunion.c (sockunion_log): moved from ../zebra/route.c\n\n1997-12-30  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* host.c (config_logfile): change 'log PATH' to 'logfile PATH'.\n\n\t* sockunion.c (sockunion_sameprefix): add same prefix for\n\tsockunion.\n\n1997-12-29  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* radix.[ch] : are moved from ../zebra directroy.\n\t\n\t* command.c (config_from_file): if command execution failed down\n\tlevel to CONFIG_NODE.\n\n\t* host.c: config_log function which enable 'log FILENAME' command.\n\n1997-12-23  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c: add vty_transpose_chars ().  Now you can use '^T' to\n\ttranspose character.\n\n\t* command.c: cmd_cmdsize add, this is useful to check incomplete\n\tcommand.\n\n1997-12-07  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* fd.h: add family for address family\n\n1997-12-06  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.o\n\t* vty.o\n\t* host.o    is moved from ../zebra\n\n1997-08-14  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* make library directory.\n\n", "/*\n * $Id$\n *\n * Logging of zebra\n * Copyright (C) 1997, 1998, 1999 Kunihiro Ishiguro\n *\n * This file is part of GNU Zebra.\n *\n * GNU Zebra is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the\n * Free Software Foundation; either version 2, or (at your option) any\n * later version.\n *\n * GNU Zebra is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with GNU Zebra; see the file COPYING.  If not, write to the Free\n * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n * 02111-1307, USA.  \n */\n\n#include <zebra.h>\n\n#include \"log.h\"\n#include \"memory.h\"\n#include \"command.h\"\n#ifndef SUNOS_5\n#include <sys/un.h>\n#endif\n\nstatic int logfile_fd = -1;\t/* Used in signal handler. */\n\nstruct zlog *zlog_default = NULL;\n\nconst char *zlog_proto_names[] = \n{\n  \"NONE\",\n  \"DEFAULT\",\n  \"ZEBRA\",\n  \"RIP\",\n  \"BGP\",\n  \"OSPF\",\n  \"RIPNG\",\n  \"OSPF6\",\n  \"ISIS\",\n  \"MASC\",\n  NULL,\n};\n\nconst char *zlog_priority[] =\n{\n  \"emergencies\",\n  \"alerts\",\n  \"critical\",\n  \"errors\",\n  \"warnings\",\n  \"notifications\",\n  \"informational\",\n  \"debugging\",\n  NULL,\n};\n  \n\n\f\n/* For time string format. */\n\nsize_t\nquagga_timestamp(int timestamp_precision, char *buf, size_t buflen)\n{\n  static struct {\n    time_t last;\n    size_t len;\n    char buf[28];\n  } cache;\n  struct timeval clock;\n\n  /* would it be sufficient to use global 'recent_time' here?  I fear not... */\n  gettimeofday(&clock, NULL);\n\n  /* first, we update the cache if the time has changed */\n  if (cache.last != clock.tv_sec)\n    {\n      struct tm *tm;\n      cache.last = clock.tv_sec;\n      tm = localtime(&cache.last);\n      cache.len = strftime(cache.buf, sizeof(cache.buf),\n      \t\t\t   \"%Y/%m/%d %H:%M:%S\", tm);\n    }\n  /* note: it's not worth caching the subsecond part, because\n     chances are that back-to-back calls are not sufficiently close together\n     for the clock not to have ticked forward */\n\n  if (buflen > cache.len)\n    {\n      memcpy(buf, cache.buf, cache.len);\n      if ((timestamp_precision > 0) &&\n\t  (buflen > cache.len+1+timestamp_precision))\n\t{\n\t  /* should we worry about locale issues? */\n\t  static const int divisor[] = {0, 100000, 10000, 1000, 100, 10, 1};\n\t  int prec;\n\t  char *p = buf+cache.len+1+(prec = timestamp_precision);\n\t  *p-- = '\\0';\n\t  while (prec > 6)\n\t    /* this is unlikely to happen, but protect anyway */\n\t    {\n\t      *p-- = '0';\n\t      prec--;\n\t    }\n\t  clock.tv_usec /= divisor[prec];\n\t  do\n\t    {\n\t      *p-- = '0'+(clock.tv_usec % 10);\n\t      clock.tv_usec /= 10;\n\t    }\n\t  while (--prec > 0);\n\t  *p = '.';\n\t  return cache.len+1+timestamp_precision;\n\t}\n      buf[cache.len] = '\\0';\n      return cache.len;\n    }\n  if (buflen > 0)\n    buf[0] = '\\0';\n  return 0;\n}\n\n/* Utility routine for current time printing. */\nstatic void\ntime_print(FILE *fp, struct timestamp_control *ctl)\n{\n  if (!ctl->already_rendered)\n    {\n      ctl->len = quagga_timestamp(ctl->precision, ctl->buf, sizeof(ctl->buf));\n      ctl->already_rendered = 1;\n    }\n  fprintf(fp, \"%s \", ctl->buf);\n}\n  \n\f\n/* va_list version of zlog. */\nstatic void\nvzlog (struct zlog *zl, int priority, const char *format, va_list args)\n{\n  struct timestamp_control tsctl;\n  tsctl.already_rendered = 0;\n\n  /* If zlog is not specified, use default one. */\n  if (zl == NULL)\n    zl = zlog_default;\n\n  /* When zlog_default is also NULL, use stderr for logging. */\n  if (zl == NULL)\n    {\n      tsctl.precision = 0;\n      time_print(stderr, &tsctl);\n      fprintf (stderr, \"%s: \", \"unknown\");\n      vfprintf (stderr, format, args);\n      fprintf (stderr, \"\\n\");\n      fflush (stderr);\n\n      /* In this case we return at here. */\n      return;\n    }\n  tsctl.precision = zl->timestamp_precision;\n\n  /* Syslog output */\n  if (priority <= zl->maxlvl[ZLOG_DEST_SYSLOG])\n    {\n      va_list ac;\n      va_copy(ac, args);\n      vsyslog (priority|zlog_default->facility, format, ac);\n      va_end(ac);\n    }\n\n  /* File output. */\n  if ((priority <= zl->maxlvl[ZLOG_DEST_FILE]) && zl->fp)\n    {\n      va_list ac;\n      time_print (zl->fp, &tsctl);\n      if (zl->record_priority)\n\tfprintf (zl->fp, \"%s: \", zlog_priority[priority]);\n      fprintf (zl->fp, \"%s: \", zlog_proto_names[zl->protocol]);\n      va_copy(ac, args);\n      vfprintf (zl->fp, format, ac);\n      va_end(ac);\n      fprintf (zl->fp, \"\\n\");\n      fflush (zl->fp);\n    }\n\n  /* stdout output. */\n  if (priority <= zl->maxlvl[ZLOG_DEST_STDOUT])\n    {\n      va_list ac;\n      time_print (stdout, &tsctl);\n      if (zl->record_priority)\n\tfprintf (stdout, \"%s: \", zlog_priority[priority]);\n      fprintf (stdout, \"%s: \", zlog_proto_names[zl->protocol]);\n      va_copy(ac, args);\n      vfprintf (stdout, format, ac);\n      va_end(ac);\n      fprintf (stdout, \"\\n\");\n      fflush (stdout);\n    }\n\n  /* Terminal monitor. */\n  if (priority <= zl->maxlvl[ZLOG_DEST_MONITOR])\n    vty_log ((zl->record_priority ? zlog_priority[priority] : NULL),\n\t     zlog_proto_names[zl->protocol], format, &tsctl, args);\n}\n\nstatic char *\nstr_append(char *dst, int len, const char *src)\n{\n  while ((len-- > 0) && *src)\n    *dst++ = *src++;\n  return dst;\n}\n\nstatic char *\nnum_append(char *s, int len, u_long x)\n{\n  char buf[30];\n  char *t;\n\n  if (!x)\n    return str_append(s,len,\"0\");\n  *(t = &buf[sizeof(buf)-1]) = '\\0';\n  while (x && (t > buf))\n    {\n      *--t = '0'+(x % 10);\n      x /= 10;\n    }\n  return str_append(s,len,t);\n}\n\n#if defined(SA_SIGINFO) || defined(HAVE_STACK_TRACE)\nstatic char *\nhex_append(char *s, int len, u_long x)\n{\n  char buf[30];\n  char *t;\n\n  if (!x)\n    return str_append(s,len,\"0\");\n  *(t = &buf[sizeof(buf)-1]) = '\\0';\n  while (x && (t > buf))\n    {\n      u_int cc = (x % 16);\n      *--t = ((cc < 10) ? ('0'+cc) : ('a'+cc-10));\n      x /= 16;\n    }\n  return str_append(s,len,t);\n}\n#endif\n\n/* Needs to be enhanced to support Solaris. */\nstatic int\nsyslog_connect(void)\n{\n#ifdef SUNOS_5\n  return -1;\n#else\n  int fd;\n  char *s;\n  struct sockaddr_un addr;\n\n  if ((fd = socket(AF_UNIX,SOCK_DGRAM,0)) < 0)\n    return -1;\n  addr.sun_family = AF_UNIX;\n#ifdef _PATH_LOG\n#define SYSLOG_SOCKET_PATH _PATH_LOG\n#else\n#define SYSLOG_SOCKET_PATH \"/dev/log\"\n#endif\n  s = str_append(addr.sun_path,sizeof(addr.sun_path),SYSLOG_SOCKET_PATH);\n#undef SYSLOG_SOCKET_PATH\n  *s = '\\0';\n  if (connect(fd,(struct sockaddr *)&addr,sizeof(addr)) < 0)\n    {\n      close(fd);\n      return -1;\n    }\n  return fd;\n#endif\n}\n\nstatic void\nsyslog_sigsafe(int priority, const char *msg, size_t msglen)\n{\n  static int syslog_fd = -1;\n  char buf[sizeof(\"<1234567890>ripngd[1234567890]: \")+msglen+50];\n  char *s;\n\n  if ((syslog_fd < 0) && ((syslog_fd = syslog_connect()) < 0))\n    return;\n\n#define LOC s,buf+sizeof(buf)-s\n  s = buf;\n  s = str_append(LOC,\"<\");\n  s = num_append(LOC,priority);\n  s = str_append(LOC,\">\");\n  /* forget about the timestamp, too difficult in a signal handler */\n  s = str_append(LOC,zlog_default->ident);\n  if (zlog_default->syslog_options & LOG_PID)\n    {\n      s = str_append(LOC,\"[\");\n      s = num_append(LOC,getpid());\n      s = str_append(LOC,\"]\");\n    }\n  s = str_append(LOC,\": \");\n  s = str_append(LOC,msg);\n  write(syslog_fd,buf,s-buf);\n#undef LOC\n}\n\nstatic int\nopen_crashlog(void)\n{\n#define CRASHLOG_PREFIX \"/var/tmp/quagga.\"\n#define CRASHLOG_SUFFIX \"crashlog\"\n  if (zlog_default && zlog_default->ident)\n    {\n      /* Avoid strlen since it is not async-signal-safe. */\n      const char *p;\n      size_t ilen;\n\n      for (p = zlog_default->ident, ilen = 0; *p; p++)\n\tilen++;\n      {\n\tchar buf[sizeof(CRASHLOG_PREFIX)+ilen+sizeof(CRASHLOG_SUFFIX)+3];\n\tchar *s = buf;\n#define LOC s,buf+sizeof(buf)-s\n\ts = str_append(LOC, CRASHLOG_PREFIX);\n\ts = str_append(LOC, zlog_default->ident);\n\ts = str_append(LOC, \".\");\n\ts = str_append(LOC, CRASHLOG_SUFFIX);\n#undef LOC\n\t*s = '\\0';\n\treturn open(buf, O_WRONLY|O_CREAT|O_EXCL, LOGFILE_MASK);\n      }\n    }\n  return open(CRASHLOG_PREFIX CRASHLOG_SUFFIX, O_WRONLY|O_CREAT|O_EXCL,\n\t      LOGFILE_MASK);\n#undef CRASHLOG_SUFFIX\n#undef CRASHLOG_PREFIX\n}\n\n/* Note: the goal here is to use only async-signal-safe functions. */\nvoid\nzlog_signal(int signo, const char *action\n#ifdef SA_SIGINFO\n\t    , siginfo_t *siginfo, void *program_counter\n#endif\n\t   )\n{\n  time_t now;\n  char buf[sizeof(\"DEFAULT: Received signal S at T (si_addr 0xP, PC 0xP); aborting...\")+100];\n  char *s = buf;\n  char *msgstart = buf;\n#define LOC s,buf+sizeof(buf)-s\n\n  time(&now);\n  if (zlog_default)\n    {\n      s = str_append(LOC,zlog_proto_names[zlog_default->protocol]);\n      *s++ = ':';\n      *s++ = ' ';\n      msgstart = s;\n    }\n  s = str_append(LOC,\"Received signal \");\n  s = num_append(LOC,signo);\n  s = str_append(LOC,\" at \");\n  s = num_append(LOC,now);\n#ifdef SA_SIGINFO\n  s = str_append(LOC,\" (si_addr 0x\");\n  s = hex_append(LOC,(u_long)(siginfo->si_addr));\n  if (program_counter)\n    {\n      s = str_append(LOC,\", PC 0x\");\n      s = hex_append(LOC,(u_long)program_counter);\n    }\n  s = str_append(LOC,\"); \");\n#else /* SA_SIGINFO */\n  s = str_append(LOC,\"; \");\n#endif /* SA_SIGINFO */\n  s = str_append(LOC,action);\n  if (s < buf+sizeof(buf))\n    *s++ = '\\n';\n\n  /* N.B. implicit priority is most severe */\n#define PRI LOG_CRIT\n\n#define DUMP(FD) write(FD, buf, s-buf);\n  /* If no file logging configured, try to write to fallback log file. */\n  if ((logfile_fd >= 0) || ((logfile_fd = open_crashlog()) >= 0))\n    DUMP(logfile_fd)\n  if (!zlog_default)\n    DUMP(STDERR_FILENO)\n  else\n    {\n      if (PRI <= zlog_default->maxlvl[ZLOG_DEST_STDOUT])\n        DUMP(STDOUT_FILENO)\n      /* Remove trailing '\\n' for monitor and syslog */\n      *--s = '\\0';\n      if (PRI <= zlog_default->maxlvl[ZLOG_DEST_MONITOR])\n        vty_log_fixed(buf,s-buf);\n      if (PRI <= zlog_default->maxlvl[ZLOG_DEST_SYSLOG])\n\tsyslog_sigsafe(PRI|zlog_default->facility,msgstart,s-msgstart);\n    }\n#undef DUMP\n\n  zlog_backtrace_sigsafe(PRI,\n#ifdef SA_SIGINFO\n  \t\t\t program_counter\n#else\n\t\t\t NULL\n#endif\n\t\t\t);\n#undef PRI\n#undef LOC\n}\n\n/* Log a backtrace using only async-signal-safe functions.\n   Needs to be enhanced to support syslog logging. */\nvoid\nzlog_backtrace_sigsafe(int priority, void *program_counter)\n{\n#ifdef HAVE_STACK_TRACE\n  static const char pclabel[] = \"Program counter: \";\n  void *array[20];\n  int size;\n  char buf[100];\n  char *s;\n#define LOC s,buf+sizeof(buf)-s\n\n#ifdef HAVE_GLIBC_BACKTRACE\n  if (((size = backtrace(array,sizeof(array)/sizeof(array[0]))) <= 0) ||\n      ((size_t)size > sizeof(array)/sizeof(array[0])))\n    return;\n\n#define DUMP(FD) { \\\n  if (program_counter) \\\n    { \\\n      write(FD, pclabel, sizeof(pclabel)-1); \\\n      backtrace_symbols_fd(&program_counter, 1, FD); \\\n    } \\\n  write(FD, buf, s-buf);\t\\\n  backtrace_symbols_fd(array, size, FD); \\\n}\n#elif defined(HAVE_PRINTSTACK)\n#define DUMP(FD) { \\\n  if (program_counter) \\\n    write((FD), pclabel, sizeof(pclabel)-1); \\\n  write((FD), buf, s-buf); \\\n  printstack((FD)); \\\n}\n#endif /* HAVE_GLIBC_BACKTRACE, HAVE_PRINTSTACK */\n\n  s = buf;\n  s = str_append(LOC,\"Backtrace for \");\n  s = num_append(LOC,size);\n  s = str_append(LOC,\" stack frames:\\n\");\n\n  if ((logfile_fd >= 0) || ((logfile_fd = open_crashlog()) >= 0))\n    DUMP(logfile_fd)\n  if (!zlog_default)\n    DUMP(STDERR_FILENO)\n  else\n    {\n      if (priority <= zlog_default->maxlvl[ZLOG_DEST_STDOUT])\n\tDUMP(STDOUT_FILENO)\n      /* Remove trailing '\\n' for monitor and syslog */\n      *--s = '\\0';\n      if (priority <= zlog_default->maxlvl[ZLOG_DEST_MONITOR])\n\tvty_log_fixed(buf,s-buf);\n      if (priority <= zlog_default->maxlvl[ZLOG_DEST_SYSLOG])\n\tsyslog_sigsafe(priority|zlog_default->facility,buf,s-buf);\n      {\n\tint i;\n\t/* Just print the function addresses. */\n\tfor (i = 0; i < size; i++)\n\t  {\n\t    s = buf;\n\t    s = str_append(LOC,\"[bt \");\n\t    s = num_append(LOC,i);\n\t    s = str_append(LOC,\"] 0x\");\n\t    s = hex_append(LOC,(u_long)(array[i]));\n\t    *s = '\\0';\n\t    if (priority <= zlog_default->maxlvl[ZLOG_DEST_MONITOR])\n\t      vty_log_fixed(buf,s-buf);\n\t    if (priority <= zlog_default->maxlvl[ZLOG_DEST_SYSLOG])\n\t      syslog_sigsafe(priority|zlog_default->facility,buf,s-buf);\n\t  }\n      }\n    }\n#undef DUMP\n#undef LOC\n#endif /* HAVE_STRACK_TRACE */\n}\n\nvoid\nzlog_backtrace(int priority)\n{\n#ifndef HAVE_GLIBC_BACKTRACE\n  zlog(NULL, priority, \"No backtrace available on this platform.\");\n#else\n  void *array[20];\n  int size, i;\n  char **strings;\n\n  if (((size = backtrace(array,sizeof(array)/sizeof(array[0]))) <= 0) ||\n      ((size_t)size > sizeof(array)/sizeof(array[0])))\n    {\n      zlog_err(\"Cannot get backtrace, returned invalid # of frames %d \"\n\t       \"(valid range is between 1 and %lu)\",\n\t       size, (unsigned long)(sizeof(array)/sizeof(array[0])));\n      return;\n    }\n  zlog(NULL, priority, \"Backtrace for %d stack frames:\", size);\n  if (!(strings = backtrace_symbols(array, size)))\n    {\n      zlog_err(\"Cannot get backtrace symbols (out of memory?)\");\n      for (i = 0; i < size; i++)\n\tzlog(NULL, priority, \"[bt %d] %p\",i,array[i]);\n    }\n  else\n    {\n      for (i = 0; i < size; i++)\n\tzlog(NULL, priority, \"[bt %d] %s\",i,strings[i]);\n      free(strings);\n    }\n#endif /* HAVE_GLIBC_BACKTRACE */\n}\n\nvoid\nzlog (struct zlog *zl, int priority, const char *format, ...)\n{\n  va_list args;\n\n  va_start(args, format);\n  vzlog (zl, priority, format, args);\n  va_end (args);\n}\n\n#define ZLOG_FUNC(FUNCNAME,PRIORITY) \\\nvoid \\\nFUNCNAME(const char *format, ...) \\\n{ \\\n  va_list args; \\\n  va_start(args, format); \\\n  vzlog (NULL, PRIORITY, format, args); \\\n  va_end(args); \\\n}\n\nZLOG_FUNC(zlog_err, LOG_ERR)\n\nZLOG_FUNC(zlog_warn, LOG_WARNING)\n\nZLOG_FUNC(zlog_info, LOG_INFO)\n\nZLOG_FUNC(zlog_notice, LOG_NOTICE)\n\nZLOG_FUNC(zlog_debug, LOG_DEBUG)\n\n#undef ZLOG_FUNC\n\n#define PLOG_FUNC(FUNCNAME,PRIORITY) \\\nvoid \\\nFUNCNAME(struct zlog *zl, const char *format, ...) \\\n{ \\\n  va_list args; \\\n  va_start(args, format); \\\n  vzlog (zl, PRIORITY, format, args); \\\n  va_end(args); \\\n}\n\nPLOG_FUNC(plog_err, LOG_ERR)\n\nPLOG_FUNC(plog_warn, LOG_WARNING)\n\nPLOG_FUNC(plog_info, LOG_INFO)\n\nPLOG_FUNC(plog_notice, LOG_NOTICE)\n\nPLOG_FUNC(plog_debug, LOG_DEBUG)\n\n#undef PLOG_FUNC\n\nvoid\n_zlog_assert_failed (const char *assertion, const char *file,\n\t\t     unsigned int line, const char *function)\n{\n  /* Force fallback file logging? */\n  if (zlog_default && !zlog_default->fp &&\n      ((logfile_fd = open_crashlog()) >= 0) &&\n      ((zlog_default->fp = fdopen(logfile_fd, \"w\")) != NULL))\n    zlog_default->maxlvl[ZLOG_DEST_FILE] = LOG_ERR;\n  zlog(NULL, LOG_CRIT, \"Assertion `%s' failed in file %s, line %u, function %s\",\n       assertion,file,line,(function ? function : \"?\"));\n  zlog_backtrace(LOG_CRIT);\n  abort();\n}\n\n\f\n/* Open log stream */\nstruct zlog *\nopenzlog (const char *progname, zlog_proto_t protocol,\n\t  int syslog_flags, int syslog_facility)\n{\n  struct zlog *zl;\n  u_int i;\n\n  zl = XCALLOC(MTYPE_ZLOG, sizeof (struct zlog));\n\n  zl->ident = progname;\n  zl->protocol = protocol;\n  zl->facility = syslog_facility;\n  zl->syslog_options = syslog_flags;\n\n  /* Set default logging levels. */\n  for (i = 0; i < sizeof(zl->maxlvl)/sizeof(zl->maxlvl[0]); i++)\n    zl->maxlvl[i] = ZLOG_DISABLED;\n  zl->maxlvl[ZLOG_DEST_MONITOR] = LOG_DEBUG;\n  zl->default_lvl = LOG_DEBUG;\n\n  openlog (progname, syslog_flags, zl->facility);\n  \n  return zl;\n}\n\nvoid\nclosezlog (struct zlog *zl)\n{\n  closelog();\n  fclose (zl->fp);\n\n  XFREE (MTYPE_ZLOG, zl);\n}\n\n/* Called from command.c. */\nvoid\nzlog_set_level (struct zlog *zl, zlog_dest_t dest, int log_level)\n{\n  if (zl == NULL)\n    zl = zlog_default;\n\n  zl->maxlvl[dest] = log_level;\n}\n\nint\nzlog_set_file (struct zlog *zl, const char *filename, int log_level)\n{\n  FILE *fp;\n  mode_t oldumask;\n\n  /* There is opend file.  */\n  zlog_reset_file (zl);\n\n  /* Set default zl. */\n  if (zl == NULL)\n    zl = zlog_default;\n\n  /* Open file. */\n  oldumask = umask (0777 & ~LOGFILE_MASK);\n  fp = fopen (filename, \"a\");\n  umask(oldumask);\n  if (fp == NULL)\n    return 0;\n\n  /* Set flags. */\n  zl->filename = strdup (filename);\n  zl->maxlvl[ZLOG_DEST_FILE] = log_level;\n  zl->fp = fp;\n  logfile_fd = fileno(fp);\n\n  return 1;\n}\n\n/* Reset opend file. */\nint\nzlog_reset_file (struct zlog *zl)\n{\n  if (zl == NULL)\n    zl = zlog_default;\n\n  if (zl->fp)\n    fclose (zl->fp);\n  zl->fp = NULL;\n  logfile_fd = -1;\n  zl->maxlvl[ZLOG_DEST_FILE] = ZLOG_DISABLED;\n\n  if (zl->filename)\n    free (zl->filename);\n  zl->filename = NULL;\n\n  return 1;\n}\n\n/* Reopen log file. */\nint\nzlog_rotate (struct zlog *zl)\n{\n  int level;\n\n  if (zl == NULL)\n    zl = zlog_default;\n\n  if (zl->fp)\n    fclose (zl->fp);\n  zl->fp = NULL;\n  logfile_fd = -1;\n  level = zl->maxlvl[ZLOG_DEST_FILE];\n  zl->maxlvl[ZLOG_DEST_FILE] = ZLOG_DISABLED;\n\n  if (zl->filename)\n    {\n      mode_t oldumask;\n      int save_errno;\n\n      oldumask = umask (0777 & ~LOGFILE_MASK);\n      zl->fp = fopen (zl->filename, \"a\");\n      save_errno = errno;\n      umask(oldumask);\n      if (zl->fp == NULL)\n        {\n\t  zlog_err(\"Log rotate failed: cannot open file %s for append: %s\",\n\t  \t   zl->filename, safe_strerror(save_errno));\n\t  return -1;\n        }\t\n      logfile_fd = fileno(zl->fp);\n      zl->maxlvl[ZLOG_DEST_FILE] = level;\n    }\n\n  return 1;\n}\n\f\n/* Message lookup function. */\nconst char *\nlookup (struct message *mes, int key)\n{\n  struct message *pnt;\n\n  for (pnt = mes; pnt->key != 0; pnt++) \n    if (pnt->key == key) \n      return pnt->str;\n\n  return \"\";\n}\n\n/* Older/faster version of message lookup function, but requires caller to pass\n   in the array size (instead of relying on a 0 key to terminate the search). */\nconst char *\nmes_lookup (struct message *meslist, int max, int index)\n{\n  /* first check for best case: index is in range and matches the key\n     value in that slot */\n  if ((index >= 0) && (index < max) && (meslist[index].key == index))\n    return meslist[index].str;\n\n  /* fall back to linear search */\n  {\n    int i;\n\n    for (i = 0; i < max; i++, meslist++)\n      {\n\tif (meslist->key == index)\n\t  {\n\t    zlog_warn(\"message index %d [%s] found in position %d (max is %d)\",\n\t\t      index, meslist->str, i, max);\n\t    return meslist->str;\n\t  }\n      }\n  }\n  zlog_err(\"message index %d not found (max is %d)\", index, max);\n  return NULL;\n}\n\n/* Wrapper around strerror to handle case where it returns NULL. */\nconst char *\nsafe_strerror(int errnum)\n{\n  const char *s = strerror(errnum);\n  return (s != NULL) ? s : \"Unknown error\";\n}\n\nstruct zebra_desc_table\n{\n  unsigned int type;\n  const char *string;\n  char chr;\n};\n\n#define DESC_ENTRY(T,S,C) [(T)] = { (T), (S), (C) }\nstatic const struct zebra_desc_table route_types[] = {\n  DESC_ENTRY\t(ZEBRA_ROUTE_SYSTEM,\t\"system\",\t'X' ),\n  DESC_ENTRY\t(ZEBRA_ROUTE_KERNEL,\t\"kernel\",\t'K' ),\n  DESC_ENTRY\t(ZEBRA_ROUTE_CONNECT,\t\"connected\",\t'C' ),\n  DESC_ENTRY\t(ZEBRA_ROUTE_STATIC,\t\"static\",\t'S' ),\n  DESC_ENTRY\t(ZEBRA_ROUTE_RIP,\t\"rip\",\t\t'R' ),\n  DESC_ENTRY\t(ZEBRA_ROUTE_RIPNG,\t\"ripng\",\t'R' ),\n  DESC_ENTRY\t(ZEBRA_ROUTE_OSPF,\t\"ospf\",\t\t'O' ),\n  DESC_ENTRY\t(ZEBRA_ROUTE_OSPF6,\t\"ospf6\",\t'O' ),\n  DESC_ENTRY\t(ZEBRA_ROUTE_ISIS,\t\"isis\",\t\t'I' ),\n  DESC_ENTRY\t(ZEBRA_ROUTE_BGP,\t\"bgp\",\t\t'B' ),\n  DESC_ENTRY\t(ZEBRA_ROUTE_HSLS,\t\"hsls\",\t\t'H' ),\n};\n#undef DESC_ENTRY\n\n#define DESC_ENTRY(T) [(T)] = { (T), (#T), '\\0' }\nstatic const struct zebra_desc_table command_types[] = {\n  DESC_ENTRY\t(ZEBRA_INTERFACE_ADD),\n  DESC_ENTRY\t(ZEBRA_INTERFACE_DELETE),\n  DESC_ENTRY\t(ZEBRA_INTERFACE_ADDRESS_ADD),\n  DESC_ENTRY\t(ZEBRA_INTERFACE_ADDRESS_DELETE),\n  DESC_ENTRY\t(ZEBRA_INTERFACE_UP),\n  DESC_ENTRY\t(ZEBRA_INTERFACE_DOWN),\n  DESC_ENTRY\t(ZEBRA_IPV4_ROUTE_ADD),\n  DESC_ENTRY\t(ZEBRA_IPV4_ROUTE_DELETE),\n  DESC_ENTRY\t(ZEBRA_IPV6_ROUTE_ADD),\n  DESC_ENTRY\t(ZEBRA_IPV6_ROUTE_DELETE),\n  DESC_ENTRY\t(ZEBRA_REDISTRIBUTE_ADD),\n  DESC_ENTRY\t(ZEBRA_REDISTRIBUTE_DELETE),\n  DESC_ENTRY\t(ZEBRA_REDISTRIBUTE_DEFAULT_ADD),\n  DESC_ENTRY\t(ZEBRA_REDISTRIBUTE_DEFAULT_DELETE),\n  DESC_ENTRY\t(ZEBRA_IPV4_NEXTHOP_LOOKUP),\n  DESC_ENTRY\t(ZEBRA_IPV6_NEXTHOP_LOOKUP),\n  DESC_ENTRY\t(ZEBRA_IPV4_IMPORT_LOOKUP),\n  DESC_ENTRY\t(ZEBRA_IPV6_IMPORT_LOOKUP),\n  DESC_ENTRY\t(ZEBRA_INTERFACE_RENAME),\n  DESC_ENTRY\t(ZEBRA_ROUTER_ID_ADD),\n  DESC_ENTRY\t(ZEBRA_ROUTER_ID_DELETE),\n  DESC_ENTRY\t(ZEBRA_ROUTER_ID_UPDATE),\n};\n#undef DESC_ENTRY\n\nstatic const struct zebra_desc_table unknown = { 0, \"unknown\", '?' };\n\nstatic const struct zebra_desc_table *\nzroute_lookup(u_int zroute)\n{\n  u_int i;\n\n  if (zroute >= sizeof(route_types)/sizeof(route_types[0]))\n    {\n      zlog_err(\"unknown zebra route type: %u\", zroute);\n      return &unknown;\n    }\n  if (zroute == route_types[zroute].type)\n    return &route_types[zroute];\n  for (i = 0; i < sizeof(route_types)/sizeof(route_types[0]); i++)\n    {\n      if (zroute == route_types[i].type)\n        {\n\t  zlog_warn(\"internal error: route type table out of order \"\n\t\t    \"while searching for %u, please notify developers\", zroute);\n\t  return &route_types[i];\n        }\n    }\n  zlog_err(\"internal error: cannot find route type %u in table!\", zroute);\n  return &unknown;\n}\n\nconst char *\nzebra_route_string(u_int zroute)\n{\n  return zroute_lookup(zroute)->string;\n}\n\nchar\nzebra_route_char(u_int zroute)\n{\n  return zroute_lookup(zroute)->chr;\n}\n\nconst char *\nzserv_command_string (unsigned int command)\n{\n  if (command >= sizeof(command_types)/sizeof(command_types[0]))\n    {\n      zlog_err (\"unknown zserv command type: %u\", command);\n      return unknown.string;\n    }\n  return command_types[command].string;\n}\n\n#define RTSIZE\t(sizeof(route_types)/sizeof(route_types[0]))\n\nint\nproto_name2num(const char *s)\n{\n   unsigned i;\n\n   for (i=0; i<RTSIZE; ++i)\n     if (strcasecmp(s, route_types[i].string) == 0)\n       return route_types[i].type;\n   return -1;\n}\n#undef RTSIZE\n", "2006-08-26 Paul Jakma <paul.jakma@sun.com>\n\n\t* heavy-wq.c: (slow_func_del,slow_func) update to match workqueue\n\t  changes\n\n2006-08-06 Paul Jakma <paul.jakma@sun.com>\n\n\t* aspath_test.c: (validate) Fix the sense of the aspath_loop_check,\n\t  which was the wrong way around and had actually been testing for\n\t  aspath_loop_check to be buggy.\n\n2006-05-28 Paul Jakma <paul.jakma@sun.com>\n\n\t* test-sig.c: (main) configure logging, there's no terminal\n\t  to write to for one thing, but we do want stdout, and we\n\t  don't want a test to spam syslog.\n\n2006-03-16 Paul Jakma <paul.jakma@sun.com>\n\n\t* heavy-wq.c: (heavy_wq_init) delay is gone from workqueue\n\t  spec.\n\t* aspath_test.c: (test_segments) Add an AS_SET with redundant\n\t  ASNs.\n\t  ({empty_prepend,prepend,parse}_test) add static qualifiers\n\n2006-01-16 Paul Jakma <paul.jakma@sun.com>\n\n\t* aspath_test.c: (validate) free the temporary aspaths.\n\t  (empty_get_test) ditto.\n\n2006-01-10 Paul Jakma <paul.jakma@sun.com>\n\n\t* test-stream.c: new file, small unit test for new\n\t  resize and {put,get}-quad stream functions.\n\t* Makefile.am: build teststream unit test.\n\n2005-11-23 Paul Jakma <paul.jakma@sun.com>\n\n\t* aspath_test.c: Add an empty aspath to test segments, and to\n\t  compare tests.\n\t  Add a segment identical to seq1, but with one extra asn.\n\t  Fix bogus free of stream in make_aspath for case where\n\t  no stream was allocated (empty path data).\n\n2005-10-11 Paul Jakma <paul.jakma@sun.com>\n\n\t* test-privs.c: Privileges unit test.\n\t* Makefile.am: build testprivs\n\t* aspath_test.c: fix a few sign warnings\n\n2005-09-06 Paul Jakma <paul@dishone.st>\n\n\t* aspath_test.c: Test bgp_aspath functionality.\n\t* Makefile.am: build aspathtest\n\t* ChangeLog: Fix date of previous commit\n\n2005-09-06 Paul Jakma <paul@dishone.st>\n\n\t* test-buffer.c: include memory.h\n          (main) call memory_init().\n\t\n2004-09-05 Paul Jakma <paul@dishone.st>\n\n\t* heavy-wq.c: (slow_func_del,slow_func_err) make them take\n\t  void * argument to shut up silly gcc warning.\n\t  \n2004-05-25 Paul Jakma <paul@dishone.st>\n\n\t* main.c: new file, common 'main' portion which then calls\n\t  test_init.\n\t* heavy.c: remove common portions now in 'main.\n\t* heavy-wq.c: ditto\n\t* heavy-thread.c: ditto\n\t* heavy*.c: Set the slow_function iteration number lower, to 300, it\n\t  was several orders of magnitude too 'slow' to be useful. :)\n\t* Makefile.am: main is a source of the tests. heavy should link\n\t  to the math library.\n\n2004-05-22 Paul Jakma <paul@dishone.st>\n\n\t* heavy-thread.c: Andrew Schorr's adaptation of heavy.c to use a\n\t  background thread to avoid responsiveness problems.\n\t* Makefile.am: Build heavythread\n\n2004-05-21 Paul Jakma <paul@dishone.st>\n\n\t* heavy.c: Add a timer thread to demonstrate thread interactivity,\n\t  Add a daemon_exit command to assist with debugging (eg for memory\n\t  tracers, etc..)\n\n2004-05-19 Paul Jakma <paul@dishone.st>\n\n\t* heavy.c: test programme to show how long-running functions\n\t  kill responsiveness. Demonstrating the most niggly problem \n\t  left in bgpd.\n\n2004-05-13 Paul Jakma <paul@dishone.st>\n\n\t* test-buffer.c: Andrew's buffer tester\n\t* test-memory.c: basic memory tester\n\t* Makefile.am: Add new tests\n", "INCLUDES = @INCLUDES@ -I.. -I$(top_srcdir) -I$(top_srcdir)/lib\nDEFS = @DEFS@ $(LOCAL_OPTS) -DSYSCONFDIR=\\\"$(sysconfdir)/\\\"\n\nnoinst_PROGRAMS = testsig testbuffer testmemory heavy heavywq heavythread \\\n\t\taspathtest testprivs teststream\ntestsig_SOURCES = test-sig.c\ntestbuffer_SOURCES = test-buffer.c\ntestmemory_SOURCES = test-memory.c\ntestprivs_SOURCES = test-privs.c\nteststream_SOURCES = test-stream.c\nheavy_SOURCES = heavy.c main.c\nheavywq_SOURCES = heavy-wq.c main.c\nheavythread_SOURCES = heavy-thread.c main.c\naspathtest_SOURCES = aspath_test.c\n\ntestsig_LDADD = ../lib/libzebra.la @LIBCAP@\ntestbuffer_LDADD = ../lib/libzebra.la @LIBCAP@\ntestmemory_LDADD = ../lib/libzebra.la @LIBCAP@\ntestprivs_LDADD = ../lib/libzebra.la @LIBCAP@\nteststream_LDADD = ../lib/libzebra.la @LIBCAP@\nheavy_LDADD = ../lib/libzebra.la @LIBCAP@ -lm\nheavywq_LDADD = ../lib/libzebra.la @LIBCAP@ -lm\nheavythread_LDADD = ../lib/libzebra.la @LIBCAP@ -lm\naspathtest_LDADD = ../lib/libzebra.la @LIBCAP@ -lm ../bgpd/libbgp.a\n"], "fixing_code": ["2007-07-26 Paul Jakma <paul.jakma@sun.com>\n\n\t* (general) Clean up and compact capability parsing slightly.\n\t  Consolidate validation of length and logging of generic TLV, and\n\t  memcpy of capability data, thus removing such from cap specifc\n\t  code (not always present or correct).\n\t* bgp_open.h: Add structures for the generic capability TLV header\n\t  and for the data formats of the various specific capabilities we\n\t  support.  Hence remove the badly named, or else misdefined, struct\n\t  capability.\n\t* bgp_open.c: (bgp_capability_vty_out) Use struct capability_mp_data.\n\t  Do the length checks *before* memcpy()'ing based on that length\n\t  (stored capability - should have been validated anyway on input,\n\t  but..).\n\t  (bgp_afi_safi_valid_indices) new function to validate (afi,safi)\n\t  which is about to be used as index into arrays, consolidates\n\t  several instances of same, at least one of which appeared to be\n\t  incomplete..\n\t  (bgp_capability_mp) Much condensed.\n\t  (bgp_capability_orf_entry) New, process one ORF entry\n\t  (bgp_capability_orf) Condensed. Fixed to process all ORF entries.\n\t  (bgp_capability_restart) Condensed, and fixed to use a\n\t  cap-specific type, rather than abusing capability_mp.\n\t  (struct message capcode_str) added to aid generic logging.\n\t  (size_t cap_minsizes[]) added to aid generic validation of\n\t  capability length field.\n\t  (bgp_capability_parse) Generic logging and validation of TLV\n\t  consolidated here. Code compacted as much as possible.\n\t* bgp_packet.c: (bgp_open_receive) Capability parsers now use\n\t  streams, so no more need here to manually fudge the input stream\n\t  getp.\n\t  (bgp_capability_msg_parse) use struct capability_mp_data. Validate\n\t  lengths /before/ memcpy. Use bgp_afi_safi_valid_indices.\n\t  (bgp_capability_receive) Exported for use by test harness.\t  \n\t* bgp_vty.c: (bgp_show_summary) fix conversion warning\n\t  (bgp_show_peer) ditto\n\t* bgp_debug.h: Fix storage 'extern' after type 'const'.\n\n2007-07-31 Lorenzo Colitti <lorenzo@colitti.com>\n\n\t* bgp_dump.c: (general) Add comments to code.\n\t  (bgp_dump_interval_add) remove some redundant lines.\n\t  (bgp_dump_set) Use enum for type argument.\n\t  Avoid scheduling dump twice if exact same command\n\t  is given twice..\n\n2007-06-22 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_fsm.c: (struct FSM) Bug #368. TCP Errors during OpenSent\n\t  should cycle to Active, not to Idle or else peer bringup can\n\t  race and cycle Idle<->Active. Reported and fix tested by\n\t  Mukesh Agrawal.\n\n2007-05-25 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_route.c: (bgp_default_originate) Sanity check added\n\t  previously was broken and always failed, thus this function\n\t  never could run, bug #370.\n\n2007-05-03 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_route.h: (struct info) Move less frequently used\n\t  fields to a lazily allocated struct info_extra.\n\t  Export bgp_info_extra_get\n\t* bgp_route.c: (bgp_info_extra_new) allocate extra\n\t  (bgp_info_extra_free) Free damp info and the info_extra.\n\t  (bgp_info_extra_get) Retrieve the info_extra of a struct\n\t  info, allocating as required.\n\t  (generally) adjust to use info->extra\n\t* bgp_damp.c: (generally) use bgp_info_extra_get to access\n\t  dampinfo\n\t* bgp_attr.h: Move rarely allocated attributes from struct attr\n\t  to a struct attr_extra, for a substantial saving in size of\n\t  struct attr.\n\t* bgp_attr.c: (bgp_attr_extra_{new,free}), new, self-explanatory.\n\t  (bgp_attr_extra_get) Get the attr_extra for a given struct\n\t  attr, allocating it if needs be.\n\t  (bgp_attr_dup) Shallow copy the struct attr and its attr_extra.\n\t  (generally) adjust to know about attr->extra.\n\t* bgp_debug.c: (bgp_dump_attr) ditto\n\t* bgp_vty.c: (show_bgp_memory) print attr and info extra sizes.\n\t* bgp_nexthop.c: (generally) adjust to know about attr->extra\n\t  and info->extra.\n\t* bgp_{packet,routemap,snmp,zebra}.c: ditto\n\n2007-04-22 Sebastien Tandel <sebastien@tandel.be>\n\t* bgp_advertise.c : (baa_hash_alloc, baa_hash_key, baa_hash_cmp)\n\t  conforms to quagga hash API. Defines _hash_[alloc|key|cmp] with\n\t  void * arguments as defined by the API.\n\t* bgp_aspath.c,h : (aspath_key_make) conforms to quagga hash API.\n\t  Defines _hash_[alloc|key|cmp] with void * arguments as defined by\n\t  the API.\n\t* bgp_attr.c,h : (cluster_hash_alloc, cluster_hash_key_make,\n\t  cluster_hash_cmp, transit_hash_alloc, transit_hash_key_make,\n\t  transit_hash_cmp, attrhash_key_make, attrhash_cmp,\n\t  bgp_attr_hash_alloc) conforms to quagga hash API. Defines\n\t  _hash_[alloc|key|cmp] with void * arguments as defined by the API.\n\t* bgp_attr.h : Definition of BGP_ATTR_DEFAULT_WEIGHT.\n\t* bgp_attr.c : (bgp_attr_default_intern) now uses \n\t  bgp_attr_default_set instead of duplicating the same code.\n\t  (general) Use of BGP_ATTR_DEFAULT_WEIGHT. Replace two 16 by\n\t  IPV6_MAX_BYTELEN.\n\n2007-04-15 Sebastien Tandel <sebastien@tandel.be>\n\n\t* bgp_aspath.c: (aspath_as_add, aspath_segment_add) Minor performance\n\t  optimization: while loop should test one pointer instead of two.\n\n2007-04-08 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_route.c: (general) Same bug as fixed on 2006-11-28 by ajs for\n\t  bgp static routes, but for main BGP RIB: Quick 'flap' of routes\n\t  can cause bgpd to mistake a new route for a duplicate route,\n\t  due to presence of removed, but not yet processed BGP RIB entry.\n\t  (bgp_update_rsclient) Ignore REMOVED bgp_info for duplicate,\n\t  restore route instead.\n\t  (bgp_update_main) Ditto.\n\t* bgp_attr.c: (general) Bug #354: parsing of MP_REACH_NLRI and\n\t  MP_UNREACH_NLRI does not take sufficient care to ensure reads\n\t  from stream buffer stay in-bounds. Hence bgpd may attempt to read\n\t  beyond end of stream, if given a crafted packet. As it uses the\n\t  stream access methods to do so, this will typically result in\n\t  assert() being hit in stream.c. Where code is compiled without\n\t  assert() enabled, result is unknown.\n\t  (struct message attr_str) should be static.\n\t  (bgp_mp_reach_parse) Carefully check length remaining in stream\n\t  against amount desired to read from stream, prior to each read,\n\t  particularly where lengths are conditional on data obtained from\n\t  stream - using STREAM_READABLE.\n\t  Remove code to parse SNPA-number, it's a defunct field and changed\n\t  to a fixed size in latest BGP MP update RFC - log warning if\n\t  SNPA-number is not 0.\n\t  (bgp_mp_unreach_parse) Check withdraw_length carefully against\n\t  STREAM_READABLE.\n\t  (bgp_attr_parse) If attribute-parser function returns error, log\n\t  warning.\n\t  Log attribute type on mismatch.\n\n2007-04-07 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgpd.c: (general) Fix bug #352\n\t  (bgp_config_write_family_header) write ipv6/multicast\n\t  address family header.\n\t  (bgp_config_write) write out ipv6 multicast AF config.\n\n2007-02-22 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_fsm.c: (bgp_fsm_change_status) Handle state change into\n\t  clearing or greater here. Simpler.\n\t  (bgp_event) Clearing state change work moved to previous\n\t* bgp_route.c: (bgp_clear_route_node) Clearing adj-in here\n\t  is too late, as it leaves a race between a peer being deleted\n\t  and an identical peer being configured before clearing\n\t  completes, leading to a crash.\n\t  Simplest fix is to clean peers Adj-in up-front, rather than\n\t  queueing such work.\n\t  (bgp_clear_route_table) Clear peer's Adj-In and Adj-Out\n\t  up-front here, rather than queueing such work.\n\t  Extensive comment added on the various bits of indexed data\n\t  that exist and how they need to be dealt with.\n\t  (bgp_clear_route) Update comment.\n\n2006-12-12 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\t\n\t* bgp_nexthop.c: (bgp_connected_add, bgp_connected_delete)\n\t  Simplify logic by using new CONNECTED_PREFIX macro.\n\n2006-12-07 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_fsm.c: Bug #302 fix, diagnosis, suggestions and testing\n\t  by Juergen Kammer <j.kammer@eurodata.de>. Fix follows from\n\t  his suggested fix, just made in a slightly different way.\n\t  (bgp_event) Transitions into Clearing always must call\n\t  bgp_clear_route_all().\n\t  (bgp_stop) No need to clear routes here, BGP FSM should do\n\t  it.\n \n2006-11-30 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* bgp_debug.h: Declare new bgp_debug_zebra conf and term flags,\n\t  and define BGP_DEBUG_ZEBRA.\n\t* bgp_debug.c: Declare conf_bgp_debug_zebra and term_bgp_debug_zebra.\n\t  (debug_bgp_zebra, no_debug_bgp_zebra, undebug_bgp_zebra) New\n\t  functions to enable/disable bgp zebra debugging.\n\t  (no_debug_bgp_all) Turn off zebra debugging.\n\t  (show_debugging_bgp) Show whether zebra debugging is on.\n\t  (bgp_config_write_debug) Add 'debug bgp zebra' if configured.\n\t  (bgp_debug_init) Add new zebra debugging commands.\n\t* bgp_zebra.c: (bgp_router_id_update, bgp_interface_add,\n\t  bgp_interface_delete, bgp_interface_up, bgp_interface_down,\n\t  bgp_interface_address_add, bgp_interface_address_delete,\n\t  zebra_read_ipv4, zebra_read_ipv6, bgp_zebra_announce,\n\t  bgp_zebra_withdraw, bgp_redistribute_set, bgp_redistribute_unset)\n\t  If zebra debugging is enabled, log an appropriate debug message.\n\n2006-11-28 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* bgp_route.c: (bgp_info_restore) New function that undoes\n\t  the effects of a previous call to bgp_info_delete.  This is\n\t  used when a route is deleted and quickly re-added before the\n\t  deletion has been processed.\n\t  (bgp_static_update_rsclient, bgp_static_update_main,\n\t  bgp_redistribute_add) Check whether a pre-existing route\n\t  has the BGP_INFO_REMOVED set, and, if so, we need to call\n\t  bgp_info_restore to resurrect it.\n\n2006-10-27 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_route.c: (bgp_table_stats) oops, u_intXX_t should be\n\t  uintXX_t\n\n2006-10-19 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgpd.c: (peer_new) bgp element of peer absolutely must be\n\t  filled in, make peer_new() require it as argument and update\n\t  all callers. Fixes a crash reported by Jan 'yanek' Bortl and\n\t  Andrew Schorr where bgpd would crash in bgp_pcount_adjust\n\t  trying to dereference the bgp member of bgp->peer_self,\n\t  triggered through redistribution.\n\t* bgp_route.c: (bgp_pcount_adjust) assert sanity of arguments.\n\n2006-10-15 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_route.c: (bgp_table_stats_walker) NULL deref if table is\n\t  empty, bgp_table_top may return NULL, Coverity CID#73.\n\t* bgp_packet.c: (bgp_update_packet) adv->rn can not be NULL,\n\t  check is bogus - changed to assert(), CID#64.\n\t  binfo is checked for NULL, but then dereferenced\n\t  unconditionally, fix, CID #63.\n\t  (bgp_withdraw_packet) Assert adv->rn is valid, as with\n\t  bgp_update_packet().\n\n2006-10-14 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_fsm.h: Remove BGP_EVENT_FLUSH_ADD, dangerous and not\n\t  needed.\n\t* bgp_fsm.c: (bgp_stop) Move BGP_EVENT_FLUSH to the top of the\n\t  of the function, otherwise it could flush a ClearingCompleted\n          event, bug #302.\n\t* bgp_packet.c: Replace all BGP_EVENT_FLUSH_ADD with\n\t  BGP_EVENT_ADD, fixing bug #302.\n\n2006-09-19 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* bgpd.c: (peer_uptime) Fix printf format/arg mismatch in\n\t  zlog_warn message (%ld/size_t -> %lu/u_long).\n\n2006-09-14 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_route.c: (bgp_table_stats_walker) Address space announced\n\t  should only count top-level unaggregateable prefixes, to\n\t  avoid falling afoul of anti-dodgy-accounting regulations\n\t  in various jurisdictions.. ;)\n\t  (bgp_process_queue_init) process queue hold time too high,\n\t  adds extra memory load. Change to be much lower, until such\n\t  time as it's made configurable.\n\n2006-09-14 Paul Jakma <paul.jakma@sun.com>\n\n\t* (general) fix the peer refcount issue exposed by previous, by\n\t  just removing refcounting of peer threads, which is mostly\n\t  senseless as they're references leading from struct peer,\n\t  which peer_free cancels anyway. No need to muck around..\n\t* bgp_fsm.h: Just remove the refcounting from the various\n\t  TIMER/READ/WRITE/EVENT ON/OFF/ADD macros.\n\t* bgp_fsm.c: (bgp_stop) use BGP_EVENT_FLUSH, no refcounts attached\n\t  to events anymore.\n\t  (bgp_event) remove peer_unlock, events not refcounted.\n\t* bgpd.c: (peer_free) flush events before free.\n\n2006-09-14 Paul Jakma <paul.jakma@sun.com>\n\n\t* (general) Fix some niggly issues around 'shutdown' and clearing\n\t  by adding a Clearing FSM wait-state and a hidden 'Deleted'\n\t  FSM state, to allow deleted peers to 'cool off' and hit 0\n\t  references. This introduces a slow memory leak of struct peer,\n\t  however that's more a testament to the fragility of the\n\t  reference counting than a bug in this patch, cleanup of\n\t  reference counting to fix this is to follow.\n\t* bgpd.h: Add Clearing, Deleted states and Clearing_Completed\n\t  and event.\n\t* bgp_debug.c: (bgp_status_msg[]) Add strings for Clearing and\n\t  Deleted.\n\t* bgp_fsm.h: Don't allow timer/event threads to set anything\n\t  for Deleted peers.\n\t* bgp_fsm.c: (bgp_timer_set) Add Clearing and Deleted. Deleted\n\t  needs to stop everything.\n\t  (bgp_stop) Remove explicit fsm_change_status call, the\n\t  general framework handles the transition.\n\t  (bgp_start) Log a warning if a start is attempted on a peer\n\t  that should stay down, trying to start a peer.\n\t  (struct .. FSM) Add Clearing_Completed\n\t  events, has little influence except when in state\n\t  Clearing to signal wait-state can end.\n\t  Add Clearing and Deleted states, former is a wait-state,\n\t  latter is a placeholder state to allow peers to disappear\n\t  quietly once refcounts settle.\n\t  (bgp_event) Try reduce verbosity of FSM state-change debug, \n\t  changes to same state are not interesting (Established->Established)\n\t  Allow NULL action functions in FSM.\n\t* bgp_packet.c: (bgp_write) Use FSM events, rather than trying\n\t  to twiddle directly with FSM state behind the back of FSM.\n\t  (bgp_write_notify) ditto.\n\t  (bgp_read) Remove the vague ACCEPT_PEER peer_unlock, or else\n\t  this patch crashes, now it leaks instead.\n\t* bgp_route.c: (bgp_clear_node_complete) Clearing_Completed\n\t  event, to end clearing.\n\t  (bgp_clear_route) See extensive comments.\n\t* bgpd.c: (peer_free) should only be called while in Deleted,\n\t  peer refcounting controls when peer_free is called.\n\t  bgp_sync_delete should be here, not in peer_delete.\n\t  (peer_delete) Initiate delete. \n\t  Transition to Deleted state manually.\n\t  When removing peer from indices that provide visibility of it,\n\t  take great care to be idempotent wrt the reference counting\n\t  of struct peer through those indices.\n\t  Use bgp_timer_set, rather than replicating.\n\t  Call to bgp_sync_delete isn't appropriate here, sync can be\n\t  referenced while shutting down and finishing deletion.\n\t  (peer_group_bind) Take care to be idempotent wrt list references\n\t  indexing peers.\n\n2006-09-13 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_aspath.c: (aspath_highest) new, return highest ASN in an\n\t  aspath.\n\t* bgp_route.c: (bgp_peer_count_walker) new, do the walk done\n\t  in bgp_peer_counts as a thread.\n\t  (bgp_peer_counts) move walk to previous and call it via\n\t  thread_execute so this RIB walk shows up in thread stats.\n\t  (bgp_table_stats) New, gather some statistics for a given\n\t  RIB.\n\t  (bgp_table_stats_walker) New, RIB walker thread for former.\n\t  (bgp_table_stats_vty) Parsing front-end for 'show bgp ...',\n\t  useful model for future rationalisation of 'show ... bgp'.\n\t  (bgp_route_init) Add new RIB stats commands.\n\t\n2006-09-06 Paul Jakma <paul.jakma@sun.com>\n\n\t* (general) Squash any and all prefix-count issues by\n\t  abstracting route flag changes, and maintaining count as and\n\t  when flags are modified (rather than relying on explicit\n\t  modifications of count being sprinkled in just the right\n\t  places throughout the code).\n\t* bgp_route.c: (bgp_pcount_{dec,inc}rement) removed.\n\t  (bgp_pcount_adjust) new, update prefix count as\n\t  needed for a given route.\n\t  (bgp_info_{uns,s}et_flag) set/unset a BGP_INFO route status\n\t  flag, calling previous function when appropriate.\n\t  (general) Update all set/unsets of flags to use previous.\n\t  Remove pcount_{dec,inc}rement calls.\n\t  No need to unset BGP_INFO_VALID in places where\n\t  bgp_info_delete is called, it does that anyway.\n\t* bgp_{damp,nexthop}.c: Update to use bgp_info_{un,}set_flag.\n\t* bgp_route.h: Export bgp_info_{un,}set_flag.\n\t  Add a 'meta' BGP_INFO flag, BGP_INFO_UNUSEABLE.\n\t  Move BGP_INFO_HOLDDOWN macro to here from bgpd.h\n\n2006-09-03 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_route.c: Add 'show ... bgp ... <neighbour> prefix-count'\n\t  commands, to provide detailed counts of prefixes for a peer.\n\t  Informative, and should help pin down to pfxcnt drift\n\t  problems.\n\n2006-08-27 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_advertise.c: (bgp_sync_delete) fix mtype in XFREE.\n\t  NULL out peer->hash after free, to be sure.\n\n2006-08-06 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_aspath.c: (aspath_loop_check) Fix the typo-bug which\n\t  essentially had disabled this check. Problem reported by\n\t  Bartek Kania <mrbk@gnarf.org> in [quagga-users 7388].\n\n2006-07-27 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgpd.c: (peer_delete) Ensure freed buffers can not be\n\t  accidently reused. A potential fix for bug #287.\n\n2006-07-02 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_fsm.c: (bgp_{stop,start}) Move clear/free of certain\n\t  bits of state from stop to start, as they may be used via\n\t  peer references on clearing queues..\n\n2006-05-23 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_vty.c: (neighbor_update_source_cmd) Expand tab completion\n\t  to make it clear it takes both address and ifname.\n\n2006-05-12 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_attr.c: (bgp_packet_attribute) Remove dead code, Coverity\n\t  CID #1\n\t* bgp_aspath.{c,h}: (aspath_print_vty) take a format string,\n\t  so as to reduce burden on callers, all in bgp_route.c\n\t* bgp_route.c: (bgp_static_update_main) Remove useless NULL\n\t  check, code already assumes bgp_static can not be NULL, \n\t  fixes CID #7.\n\t  (bgp_static_update_rsclient) ditto, CID #6\n\t  (route_vty_out{,tmp}) Update to match aspath_print_vty,\n\t  simplifying checks needed to get spacing right. CID #4,#5.\n\t  ({damp,flap}_route_vty_out) Ditto, CID #9, #10\n\n2006-05-08 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_community.c: (community_str2com) Coverity CID#62, fix\n\t  double-free, use-after-free.\n\t* bgp_route.c: (bgp_afi_node_get) given table should never be\n\t  NULL, check/assert this.\n\t  (bgp_static_update) Bug #240. Rsclients should only be passed\n\t  the static update if they are configured for the afi,safi.\n\n2006-05-04 Paul Jakma <paul.jakma@sun.com>\n\n\t* (general) VPNv4 fixes. Certain VPNv4 code was not enabled.\n\t  See bug #210.\n\t* bgp_attr.{c,h}: (bgp_packet_{withdraw,attribute}) Tag should be\n\t  u_char really.\n\t* bgp_packet.c: (bgp_{update,withdraw}_packet) Enable some\n\t  VPNv4 code which inexplicably was ifdef'd out. comments from\n\t  a tester on IRC suggest this fixes bug #210.\n\t* bgp_route.c: (general) Fix logical bug in clearing, noted\n\t  by Chris Caputo in [quagga-users 6728] - clearing depended on\n\t  at least one route being added to workqueue, in order for\n\t  workqueue completion function to restart FSM. However, if no\n\t  routes are cleared, then the completion function never is\n\t  called, it needs to be called manually if the workqueue\n\t  didn't get scheduled. \n\t  Finally, clearing is per-peer-session, not per AFI/SAFI, so\n\t  the FSM synchronisation should be in bgp_clear_route_table.\n\t  (bgp_clear_route_table) Wrong place for FSM/clearing\n\t  synchronisation, move to..\n\t  (bgp_clear_route) FSM/clearing synchronisation should be\n\t  here.\n\t  If no routes were cleared, no workqueue scheduled, call\n\t  the completion func to ensure FSM kicks off again.\n\n2006-03-30 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_community.c: (community_gettoken) Unknown token should\n\t  return NULL, to give a strong indication to callers that\n\t  the token no longer can be parsed, otherwise callers looping\n\t  on this function may have a hard time ending their loop.\n\t  (community_str2com) While loop around community_gettoken appears\n\t  to have been coded thinking that break statement would break\n\t  from the while{}, hence it could never exit for unknown token\n\t  case. Fix it to do..while, so it can use the NULL result from\n\t  community_gettoken easily.\n\n2006-03-22 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgpd.c: (peer_free) release the per-peer workqueue when\n\t  freeing the peer.\n\n2006-03-19 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgpd/bgp_vty.c: Add includes to get several structs we want\n\t  to provide usage statistics on.\n\t  (show_bgp_memory_cmd) Show memory usage stats for various\n\t  notable fixed size objects. Using mtype_stats_alloc and\n\t  mtype_memstr recently added to memory.c.\n\t  (bgp_show_summary) Report some additional stats specific to\n\t  the given BGP instance and/or AFI/SAFI such as table counts,\n\t  peers, rsclients and peer-groups.\n\t  (bgp_vty_init) Install show_bgp_memory_cmd.\n\t* bgp_nexthop.h: Include if.h as a dependent header, for struct\n\t  connected.\n\t* bgp_advertise.c: Use a distinct memory type for struct\n\t  bgp_synchronize.\n\n2006-03-12 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_attr.h: (struct attr) rearrange fields to avoid\n\t  wasted padding between them as much as possible.\n\t  (attr_count,attr_unknown_count) export new functions to\n\t  return number of counts of cached attributes.\n\t* bgp_attr.c: (attr_count,attr_unknown_count) new functions to\n\t  return number of counts of cached attributes.\n\t* bgp_route.h: (struct bgp_info) rearrange fields to avoid\n\t  wasted padding.\n\t* bgp_table.h: (struct bgp_table) Add a count field, of number\n\t  of nodes in the table.\n\t  (struct bgp_node)  rearrange fields to avoid\n\t  wasted padding between them, though I don't think there\n\t  was any in this case. \n\t* bgp_table.c: (bgp_node_{delete,get}) Maintain the table node count.\n\t  (bgp_table_count) new function to access the table count.\n\n2006-03-03 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_route.c: (bgp_clear_node_complete) Doh. When clearing\n\t  is complete we need to kick off FSM again.\n\n2006-02-21 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgpd.h: move the clear_node_queue to be peer specific.\n\t  Add a new peer status flag, PEER_STATUS_CLEARING.\n\t* bgp_table.h: (struct bgp_table) Add fields to record afi,\n          safi of the table.\n          (bgp_table_init) Take afi and safi to create table for.\n        * bgp_table.c: (bgp_table_init) record the afi and safi.\n        * bgp_nexthop.c: Update all calls to bgp_table_init.\n        * bgp_vty.c: ditto.\n        * bgpd.c: ditto.\n        * bgp_fsm.c: (bgp_timer_set) dont bring up a session which is\n\t  clearing.\n        * bgp_route.c: (general) Update all bgp_table_init calls.\n          (bgp_process_{rsclient,main}) clear_node is serialised\n          via PEER_STATUS_CLEARING and fsm now.\n          (struct bgp_clear_node_queue) can be removed. struct bgp_node\n          can be the queue item data directly, as struct peer can be\n          kept in the new wq global user data and afi/safi can be\n          retrieved via bgp_node -> bgp_table.\n          (bgp_clear_route_node) fix to get peer via wq->spec.data,\n          afi/safi via bgp_node->bgp_table.\n          (bgp_clear_node_queue_del) no more item data to delete, only\n          unlock the bgp_node.\n          (bgp_clear_node_complete) only need to unset CLEARING flag\n          and unlock struct peer.\n          (bgp_clear_node_queue_init) queue attaches to struct peer\n          now. record peer name as queue name.\n          (bgp_clear_route_table) If queue transitions to active,\n          serialise clearing by setting PEER_STATUS_CLEARING rather\n          than plugging process queue, and lock peer while queue\n          active.\n          Update to pass only bgp_node as per-queue-item specific data.\n\t* bgp_vty.c: (bgp_show_summary) Add a 'Clrng' sub-description\n\t  to state of peer while it's suppressed due to clearing.\n\n2006-02-18 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_routemap.c: (route_set_community) Quick, very hacky, fix\n\t  for the set-community leak, bug #89. True fix will be to\n\t  detangle the web of *_intern caching and provide saner object\n\t  caching for Quagga, future work.\n\t* bgp_route.c: (bgp_announce_check) trivial, move declaration\n\t  of two local variables into the only block where they are\n\t  used, to aid the reader.\n\n2006-02-05 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_route.h: Add BGP_INFO_COUNTED to track whether\n\t  prefix has been counted or not.\n\t* bgp_route.c: (bgp_pcount_{inc,dec}rement) new helpers, to\n\t  centralise inc/dec of prefix-count, \n\t  (bgp_rib_remove) Remove pcount decrement, use helper.\n\t  (bgp_rib_withdraw) ditto, additionally use previous function\n\t  too.\n\t  (bgp_update_main) Use pcount helpers.\n\t  (bgp_clear_route_node) ditto, aslo REMOVED routes don't need\n\t  clearing.\n\t* bgp_aspath.c: (aspath_gettoken) fix gcc warning about\n\t  possible uninitialised usage.\n \n2006-02-02 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_route.c: (bgp_{clear_node,process}_queue_init) delay\n\t  field is removed from workqueue spec.\n\n2006-01-19 Paul Jakma <paul.jakma@sun.com>\n\n\t* (general) various miscellaneous compiler warning fixes.\n\t   Remove redundant break statements from switch clauses\n\t   which return.\n\t   return from main, not exit, cause it annoys SOS.\n\t   Remove stray semi-colons which cause empty-statement\n\t   warnings.\n\n2006-01-17 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_nexthop.c: (zlookup_read*) convert to new Zserv format.\n\t  (zlookup_query_ipv6) ditto.\n\t  (bgp_import_check) ditto.\n\t  \n2006-01-16 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_aspath.c: (assegment_append_asns) XREALLOC can return\n\t  NULL theoretically, take care not to lose the allocated data.\n\t  (aspath_hash_alloc) aspath_dup already set the aspath\n\t  string - fix leak.\n\t  (aspath_parse) aspath_hash_alloc dupes the entire aspath,\n\t  including segments, but we forgot to free the temporary\n\t  assegment.\n\t  (aspath_snmp_pathseg) move the static stream pointer out to\n\t  file scope, so it can be freed.\n\t  (aspath_finish) new function, free aspath resources.\n\t* bgp_aspath.h: (aspath_finish) export.\n\n2006-01-10 Juris Kalnins <juris@mt.lv>\n\n\t* bgpd.h: (bgp_router_id_unset) ex-function, remove.\n\t\n2005-11-23 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_aspath.c: (assegments_parse) should be static\n\n2005-11-23 Juergen Kammer <j.kammer@eurodata.de>\n\n\t* bgp_aspath.c: (aspath_cmp_left_confed) fix SEGV for case\n\t  where one or both paths are empty.\n\n2005-11-14 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_route.c: (bgp_process_rsclient)\u00a0convert to new workqueue\n          specs and shut up gcc, which complains about cast from void\n          via function parameters, for some dumb reason. Do the cast\n          inside the function instead.\n          (bgp_process_main,bgp_processq_del) ditto.\n          (bgp_clear_route_node) ditto.\n          (bgp_clear_node_queue_del) ditto.\n\n2005-11-03 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_damp.c: (bgp_reuse_timer) struct bgp can be retrieved via\n\t  the struct bgp_damp_info, no need to guess by using\n\t  bgp_get_default().\n\n2005-10-01 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* bgp_vty.c: (bgp_config_write_redistribute) Use new library function\n\t  zebra_route_string instead of a local hard-coded table.\n\n2005-09-30 Vincent Jardin <vincent.jardin@6wind.com>\n\n\t* bgp_packet.c: fix compilation when DEBUG is used.\n\n2005-09-10 Paul Jakma <paul.jakma@sun.com>\n\n\t* Makefile.am: bgpd shouldn't list libgp's sources as its own.\n\t  Use LDADD.\n\t* bgp_aspath.h:\t\n\t  (struct assegment) New struct, abstract representation of a\n\t  list of AS_PATH segments and the contained ASNs.\t  \n\t  (struct aspath) Remove the raw-data related\n\t  fields, reference the abstract struct assegment instead. \n\t  Remove several other computed fields, it's just a\n\t  headache to maintain them and they're cheap to compute from\n\t  struct assegment.\n\t  (aspath_parse) parse a stream, not a pointer to raw data.\n\t  (aspath_count_{hops,confeds,size}) helpers to access\n\t  information formerly directly contained in struct aspath.\n\t  (aspath_snmp_pathseg) Helper for SNMP, BGP MIB wants\n\t  to be able to output hex representation of raw data.\n\t* bgp_aspath.c: (general) partial-rewrite. Store aspath data\n\t  as an abstract singly-linked list of abstract segments,\n          rather than storing the raw data, and parsing it each and\n\t  every time. Remove several count/size fields which are cheap\n\t  to compute from the abstract segment structure.\n\t  (global) Include stream.h, needed for aspath_parse, and\n\t  others. Couple of helper macros added.\n\t  (struct assegment_header) Just the header, and only the\n\t  header.\n\t  (assegment_data_{new,free}) convenience functions for\n\t  AS_SEG_DATA allocation, the dynamic, per-segment array of\n\t  ASNs.\n\t  (assegment_{new,free,free_all,dup,dup_all}) convenience\n\t  functions for creating struct assegments. The _all forms will\n\t  follow the entire chain of segments from the given segment.\n\t  (assegment_prepend_asns) new function, prepend an ASN N times\n\t  to segment.\n \t  (assegment_append_asns) Append a list (array) of ASNs to\n\t  segment.\n\t  (int_cmp) convenience function for the aspath hash.\n\t  (assegment_normalise) new function. Normalise the given\n\t  segment chain to meet expectations of Quagga, and to\n\t  eliminate differing raw representations of the same paths.\n\t  Merge 'runs' of SEQUENCEs into one segment as our internal\n\t  segment is not limited by the protocol AS_PATH segment\n\t  length. Sort ASNs in SETs. \n\t  (aspath_new) Take void argument to quell warnings. Use the\n\t  assegment convenience functions.\n\t  (assegment_count_{asns,confeds,hops}) new functions to\n\t  compute at runtime values previously held in struct aspath.\n\t  (aspath_size) ditto.\n\t  (aspath_make_str_count) rewritten to stringify new\n\t  representation, and to be slightly easier to understand\n\t  hopefully.\n\t  (aspath_str_update) convenience function, update the aspath\n\t  str. Should investigate removing maintained string from\n\t  struct aspath, just run-time compute it, as per other fields.\n\t  It's just a maintenance headache, would save noticeable\n\t  amount of RAM with possibly not much extra run-time cost.\n\t  (aspath_dup) use the assegment dup functions.\n\t  (aspath_hash_alloc) Take void * argument to satisfy gcc. Use\n\t  the proper helper functions to dup data.\n\t  (assegments_parse) new function. parse raw AS_PATH data into\n\t  struct assegments. Normalise and return the head of the list.\n\t  (aspath_parse) Parse a stream, not pointer to raw data and\n\t  use assegments_parse to do it.\n\t  (assegment_data_put) Write out a single segment data in protocol\n\t  form to stream.\n\t  (assegment_header_put) ditto but for segment header.\n\t  (aspath_put) new function. As per previous but for an entire\n\t  struct aspath.\n\t  (aspath_snmp_pathseg) wrapper around aspath_put for\n\t  bgp_snmp.c. Uses a static buffer sadly.\n\t  (aspath_aggregate_as_set_add) rewritten to use assegments.\n\t  (aspath_aggregate) ditto\n\t  (aspath_{firstas,loop,private_as}_check) ditto\n\t  (aspath_{merge,prepend,add_one_as}) ditto\n\t  (aspath_cmp_left{_confed}) ditto\n\t  (aspath_delete_confed_seq) ditto, plus fixed to properly\n\t  delete all leading confed segments.\n\t  (aspath_as_add) Just use assegment_append_asns.\n\t  (aspath_segment_add) updated to use assegments.\n\t  (enum as_token) Add values for confeds\n\t  (aspath_gettoken) Add support for confeds\n\t  (aspath_str2aspath) ditto\n\t  (aspath_key_make) updated to use as_segments. Also, add\n\t  segment type into the hash value as appropriate.\n\t  (aspath_cmp) updated to use as_segments.\n\t  (aspath_print) don't segfault on NULL argument.\n\t* bgp_attr.c: (bgp_attr_aspath) aspath_parse wants the stream\n\t  now. No need for manual forwarding of stream.\n\t  (bgp_packet_attribute) empty aspath is now denoted by NULL\n\t  segment field, length is gone.\n\t  Use aspath_size() to determine size.\n\t  (bgp_attr_init) Fix declaration, explicitely specify void\n\t  arg.\n\t  (bgp_dump_routes_attr) Use aspath_size() to determine size.\n\t* bgp_route.c: (bgp_info_cmp) use the aspath_count_* functions.\n\t  (bgp_rib_withdraw) remove unused variable. Use\n\t  aspath_count_hops.\n\t* bgp_snmp.c: (bgp4PathAttrTable) raw data is gone, use \n\t  aspath_snmp_pathseg to get the representation.\n\n2005-09-10 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_vty.c: (bgp_vty_init) gcc 4 compile fix. static\n\t  function declarations shouldn't be inside functions.\n\t* bgp_dump.c: (bgp_dump_interval_add) ditto.\n\t\n2005-08-26 Hasso Tepper <hasso at quagga.net>\n\n\t* bgp_route.c: Third (?) attempt to fix best selection breakage\n\t  introduced long time ago with route server patch. Hopefully\n\t  it's last case to fix - route-server client not in peer group.\n\n2005-08-22 Hugo Santos <hsantos@av.it.pt>\n\n\t* bgp_vty.c: (general) Add support for BGP IPv6 Multicast SAFI\n\t  commands and BGP_IPV6M_NODE.\n\t  \n2005-08-22 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_route.h: (struct bgp_info) add a new flag, BGP_INFO_REMOVED.\n\t  BGP_INFO_VALID is already overloaded, don't care to do same thing\n\t  to STALE or HISTORY.\n\t* bgpd.h: (BGP_INFO_HOLDDOWN) Add INFO_REMOVED to the macro, as a\n\t  route which should generally be ignored.\n\t* bgp_route.c: (bgp_info_delete) Just set the REMOVE flag, rather \n\t  than doing actual work, so that bgp_process (called directly,\n\t  or indirectly via the scanner) can catch withdrawn routes.\n\t  (bgp_info_reap) Actually remove the route, what bgp_info_delete\n\t  used to do, only for use by bgp_process.\n\t  (bgp_best_selection) reap any REMOVED routes, other than the old\n\t  selected route.\n\t  (bgp_process_rsclient) reap the old-selected route, if appropriate\n\t  (bgp_process_main) ditto\n\t  (bgp_rib_withdraw, bgp_rib_remove) make them more consistent with\n\t  each other. Don't play games with the VALID flag, bgp_process\n\t  is async now, so it didn't make a difference anyway.\n\t  Remove the 'force' argument from bgp_rib_withdraw, withdraw+force\n\t  is equivalent to bgp_rib_remove. Update all its callers.\n\t  (bgp_update_rsclient) bgp_rib_withdraw and force set is same as\n\t  bgp_rib_remove.\n\t  (route_vty_short_status_out) new helper to print the leading\n\t  route-status string used in many command outputs. Consolidate.\n\t  (route_vty_out, route_vty_out_tag, damp_route_vty_out, \n\t   flap_route_vty_out) use route_vty_short_status_out rather than\n\t  duplicate.\n\t  (route_vty_out_detail) print state of REMOVED flag.\n\t  (BGP_SHOW_SCODE_HEADER) update for Removed flag. \n\t  \n2005-08-03 Hasso Tepper <hasso at quagga.net>\n\n\t* bgp_routemap.c: Revert part of leaking communities fix commited in\n\t  2005-05-27. While ecommunity fix seems to be correct, community case\n\t  isn't.\n\n2005-06-28 Paul Jakma <paul.jakma@sun.com>\n\n\t* (global) The great bgpd extern and static'ification.\n\t* bgp_routemap.c: remove unused ROUTE_MATCH_ASPATH_OLD code\n\t  (route_set_metric_compile) fix u_int32_t to ULONG_MAX comparison\n\t  warnings.\n\t* bgp_route.h: (bgp_process, bgp_withdraw, bgp_update) export these\n\t  used by various files which had their own private declarations,\n\t  in the case of mplsvpn - incorrect.\n\n2005-06-15 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgpd.c: (bgp_terminate) workqueue's are lazy allocated and its\n\t  possible to terminate bgpd before workqueues were setup, causing\n\t  an abort/crash. Reported by Ashish Mehta of Sun.\n\n2005-06-01 Paul Jakma <paul.jakma@sun.com>\n\n\t* (general) refcount struct peer and bgp_info, hence allowing us\n\t  add work_queues for bgp_process.\n\t* bgp_route.h: (struct bgp_info) Add 'lock' field for refcount.\n\t  Add bgp_info_{lock,unlock} helper functions.\n\t  Add bgp_info_{add,delete} helpers, to remove need for\n\t  users managing locking/freeing of bgp_info and bgp_node's.\n\t* bgp_table.h: (struct bgp_node) Add a flags field, and\n\t  BGP_NODE_PROCESS_SCHEDULED to merge redundant processing of\n\t  nodes.\n\t* bgp_fsm.h: Make the ON/OFF/ADD/REMOVE macros lock and unlock\n\t  peer reference as appropriate.\n\t* bgp_damp.c: Remove its internal prototypes for\n\t  bgp_info_delete/free. Just use bgp_info_delete.\n\t* bgpd.h: (struct bgp_master) Add work_queue pointers.\n\t  (struct peer) Add reference count 'lock'\n\t  (peer_lock,peer_unlock) New helpers to take/release reference\n\t  on struct peer.\n\t* bgp_advertise.c: (general) Add peer and bgp_info refcounting \n\t  and balance how references are taken and released.\n\t  (bgp_advertise_free) release bgp_info reference, if appropriate\n\t  (bgp_adj_out_free) unlock peer\n\t  (bgp_advertise_clean) leave the adv references alone, or else\n\t  call bgp_advertise_free cant unlock them.\n\t  (bgp_adj_out_set) lock the peer on new adj's, leave the reference\n\t  alone otherwise. lock the new bgp_info reference.\n\t  (bgp_adj_in_set) lock the peer reference\n\t  (bgp_adj_in_remove) and unlock it here\n\t  (bgp_sync_delete) make hash_free on peer conditional, just in\n\t  case.\n\t* bgp_fsm.c: (general) document that the timers depend on\n\t  bgp_event to release a peer reference.\n\t  (bgp_fsm_change_status) moved up the file, unchanged.\n\t  (bgp_stop) Decrement peer lock as many times as cancel_event\n\t  canceled - shouldnt be needed but just in case.\n\t  stream_fifo_clean of obuf made conditional, just in case.\n\t  (bgp_event) always unlock the peer, regardless of return value\n\t  of bgp_fsm_change_status.\n\t* bgp_packet.c: (general) change several bgp_stop's to BGP_EVENT's.\n\t  (bgp_read) Add a mysterious extra peer_unlock for ACCEPT_PEERs\n\t  along with a comment on it.\n\t* bgp_route.c: (general) Add refcounting of bgp_info, cleanup\n\t  some of the resource management around bgp_info. Refcount peer.\n\t  Add workqueues for bgp_process and clear_table.\n\t  (bgp_info_new) make static\n\t  (bgp_info_free) Ditto, and unlock the peer reference.\n\t  (bgp_info_lock,bgp_info_unlock) new exported functions\n\t  (bgp_info_add) Add a bgp_info to a bgp_node in correct fashion,\n\t  taking care of reference counts.\n\t  (bgp_info_delete) do the opposite of bgp_info_add.\n\t  (bgp_process_rsclient) Converted into a work_queue work function.\n\t  (bgp_process_main) ditto.\n\t  (bgp_processq_del) process work queue item deconstructor\n\t  (bgp_process_queue_init) process work queue init\n\t  (bgp_process) call init function if required, set up queue item\n\t  and add to queue, rather than calling process functions directly.\n\t  (bgp_rib_remove) let bgp_info_delete manage bgp_info refcounts\n\t  (bgp_rib_withdraw) ditto\n\t  (bgp_update_rsclient) let bgp_info_add manage refcounts\n\t  (bgp_update_main) ditto\n\t  (bgp_clear_route_node) clear_node_queue work function, does\n\t  per-node aspects of what bgp_clear_route_table did previously\n\t  (bgp_clear_node_queue_del) clear_node_queue item delete function\n\t  (bgp_clear_node_complete) clear_node_queue completion function,\n\t  it unplugs the process queues, which have to be blocked while\n\t  clear_node_queue is being processed to prevent a race.\n\t  (bgp_clear_node_queue_init) init function for clear_node_queue\n\t  work queues\n\t  (bgp_clear_route_table) Sets up items onto a workqueue now, rather\n\t  than clearing each node directly. Plugs both process queues to\n\t  avoid potential race.\n\t  (bgp_static_withdraw_rsclient) let bgp_info_{add,delete} manage\n\t  bgp_info refcounts.\n\t  (bgp_static_update_rsclient) ditto\n\t  (bgp_static_update_main) ditto\n\t  (bgp_static_update_vpnv4) ditto, remove unneeded cast.\n\t  (bgp_static_withdraw) see bgp_static_withdraw_rsclient\n\t  (bgp_static_withdraw_vpnv4) ditto\n\t  (bgp_aggregate_{route,add,delete}) ditto\n\t  (bgp_redistribute_{add,delete,withdraw}) ditto\n\t* bgp_vty.c: (peer_rsclient_set_vty) lock rsclient list peer\n\t  reference\n\t  (peer_rsclient_unset_vty) ditto, but unlock same reference\n\t* bgpd.c: (peer_free) handle frees of info to be kept for lifetime\n\t  of struct peer.\n\t  (peer_lock,peer_unlock) peer refcount helpers\n\t  (peer_new) add initial refcounts\n\t  (peer_create,peer_create_accept) lock peer as appropriate\n\t  (peer_delete) unlock as appropriate, move out some free's to\n\t  peer_free.\n\t  (peer_group_bind,peer_group_unbind) peer refcounting as\n\t  appropriate.\n\t  (bgp_create) check CALLOC return value.\n\t  (bgp_terminate) free workqueues too.\n\t \n2005-05-28 Hasso Tepper <hasso at quagga.net>\n\n\t* bgp_routemap.c: Sync set_metric_addsub_cmd with ripd.\n\n2005-05-27 Hasso Tepper <hasso at quagga.net>\n\n\t* bgp_routemap.c: Stop leaking communities.\n\n2005-05-27 Hasso Tepper <hasso at quagga.net>\n\n\t* bgpd.c: Deleting bgp->rsclient list needs fix similar to pree-groups\n\t  deleting fix. Avoid leaking bgp->group, bgp->peer and bgp->rsclient\n\t  lists.\n\n2005-05-26 Hasso Tepper <hasso at quagga.net>\n\n        * bgpd.c: Don't crash while deleting list of peer-groups.\n\n2005-05-25 Hasso Tepper <hasso at quagga.net>\n\n\t* bgpd.c: Fix obvious (routeserver patch) merge error. This makes \"no\n\t  neighbor x.x.x.x routemap [export|import] commands work again.\n\n2005-05-23 Paul Jakma <paul@dishone.st>\n\n\t* bgp_routemap.c: add semi-colons to VTY_GET_* to match vty.h change\n\t* bgp_fsm.h: Add extern qualifier to exported functions\n\t* bgp_nexthop.c: add static to nexthop specific globals\n\t* *.h: Add guard defines\n\n2005-05-19 Paul Jakma <paul@dishone.st>\n\n\t* bgp_fsm.c: (bgp_stop) use sockunion_free, not XFREE..\n\t* bgp_network.c: (bgp_getsockname) ditto\n\t  (bgp_accept) use XSTRDUP\n\t* bgp_routemap.c: (route_match_peer) ditto, als use a ret value and\n\t  remove one sockunion_free.\n\t* bgpd.c: (peer_delete) ditto.\n\t  XFREE the correct memtype, not free.\n\t  (peer_create) use XSTRDUP\n\t* bgp_packet.c: (bgp_stream_dup) deleted, stream_dup should be used\n\t  (various) update -> s/bgp_stream_dup/stream_dup\n\t  \n\n2005-04-11 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* bgp_zebra.c (bgp_redistribute_set, bgp_redistribute_unset):\n\t  The 2nd arg to zebra_redistribute_send is now zclient instead of\n\t  zclient->sock.\n\n2005-04-09 Akihiro Mizutani <mizutani@net-chef.net>\n\n\t* bgp_vty.c: Make \"exit-address-family\" work in IPv4 unicast address\n\t  family node.\n\n2005-04-08 Martin Ling <martin-quagga@earth.li>\n\n\t* bgp_aspath.[ch], bgp_route.c, bgp_vty.c, bgpd.[ch]: Allow to enable\n\t  the length of confederation path segments to be included during the\n\t  as-path length check in the best path decision.\n\n2005-04-02 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* bgp_zebra.c: (bgp_interface_delete) After deleting, set ifp->ifindex\n\t  to IFINDEX_INTERNAL.\n\n2005-03-21 Hasso Tepper <hasso at quagga.net>\n\n\t* bgp_route.c: Don't crash while clearing route tables if there is\n\t  no particular afi/safi configured.\n\n2005-02-23 Hasso Tepper <hasso at quagga.net>\n\n\t* bgp_route.c: Make reannouncing prefixes with changed attributes\n\t  work again.\n\n2005-02-02 Akihiro Mizutani <mizutani@net-chef.net>\n\n\t* bgp_vty.c: Deprecate \"neighbor transparent-as\" and \"neighbor\n\t  transparent-nexthop\" commands.\n\n2005-02-02 Akihiro Mizutani <mizutani@net-chef.net>\n\n\t* bgp_routemap.c: New route-map command - \"match ip route-source\".\n\n2005-02-02 Akihiro Mizutani <mizutani@net-chef.net>\n\n\t* bgp_clist.[ch], bgp_route.c, bgp_routemap.c, bgp_vty.c:\n\t  community-list cleanup.\n\n2005-02-02 Akihiro Mizutani <mizutani@net-chef.net>\n\n\t* bgp_route.c, bgp_vty.c, bgp_zebra.c, bgpd.[ch]: \"enforce-multihop\"\n\t  -> \"disable-connected-check\".\n\n2005-02-02 Akihiro Mizutani <mizutani@net-chef.net>\n\n\t* bgp_fsm.c, bgp_open.c, bgp_packet.c, bgp_route.[ch], bgp_vty.c,\n\t  bgpd.[ch]: Add BGP_INFO_STALE flag and end-of-rib support. \"bgp\n\t  graceful-restart\" commands added. Show numbers of individual\n\t  messages in \"show ip bgp neighbor\" command. Final pieces of graceful\n\t  restart.\n\n2005-02-01 Akihiro Mizutani <mizutani@net-chef.net>\n\n\t* bgp_open.c, bgp_packet.c, bgp_vty.c, bgpd.[ch]: Remove \"no neighbor\n\t  capability route-refresh\" commands. Route refresh capability is sent\n\t  anyway now. Preserve dummy deprecated commands.\n\n2005-02-01 Akihiro Mizutani <mizutani@net-chef.net>\n\n\t* bgp_attr.c, bgp_snmp.c, bgp_vty.c, bgpd.[ch]: Remove support for old\n\t  draft - ie. \"neighbor version 4-\" commands. Preserve dummy \"neighbor\n\t  version\" command as deprecated.\n\n2005-02-01 Akihiro Mizutani <mizutani@net-chef.net>\n\n\t* bgpd.[ch], bgp_vty.c, bgp_route.c: \"Restart session after\n\t  maximum-prefix limit\" feature support.\n\n2005-02-01 Akihiro Mizutani <mizutani@net-chef.net>\n\n\t* bgp_nexthop.c: Improve debug.\n\t* bgpd.[ch], bgp_nexthop.c, bgp_snmp.c: Remove useless bgp_get_master()\n\t  function.\n\t* bgp_packet.c: MP AFI_IP update and withdraw parsing.\n\t* bgp_fsm.c: Reset peer synctime in bgp_stop(). bgp_fsm_change_status()\n\t  is better place to log about peer status change than bgp_event().\n\t  Log in bgp_connect_success().\n\t* bgp_vty.c: Fix typo in comment.\n\t* bgp_attr.c: Better log about unknown attribute.\n\n2005-01-29 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* bgp_filter.c: (ip_as_path,no_ip_as_path) Use argv_concat instead\n\t  of buffer_getstr.\n\t* bgp_route.c: (bgp_show_regexp) Fix memory leak: need to free string\n\t  returned by buffer_getstr.\n\t  (bgp_show_community) Must use XFREE instead of free on string\n\t  returned by buffer_getstr.\n\t* bgp_routemap.c: (set_community) Must use XFREE instead of free\n\t  on string returned by buffer_getstr.\n\t* bgp_vty.c: (neighbor_description) Use argv_concat instead of\n\t  buffer_getstr.\n\n2005-01-24 Hasso Tepper <hasso at quagga.net>\n\n\t* bgp_route.c: Fix showstopper bug. New route must be selected also\n\t  if old one is flaged as BGP_INFO_ATTR_CHANGED.\n\n2005-01-17 Hasso Tepper <hasso at quagga.net>\n\n\t* bgp_route.c: Clear peer's routing table regardless whether it's\n\t  configured or not. Being not configured is even better reason to\n\t  do it.\n\n2005-01-05 Paul Jakma <paul@dishone.st>\n\n\t* bgp_packet.c: (bgp_write) set socket to nonblock while writing\n          this should be generalised. See bugzilla #102. Fix supplied by\n\t  wawa@yandex-team.ru (Vladimir Ivanov).\n\n2004-12-08 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* *.c: Change level of debug messages to LOG_DEBUG.\n\n2004-12-07 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* bgp_main.c: (main) The 2nd argument to openzlog has been removed.\n\n2004-12-03 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* bgp_main.c: (sigint) Use zlog_notice for termination message.\n\t  (main) Use zlog_notice for startup announcement.\n\n2004-11-25 Hasso Tepper <hasso at quagga.net>\n\n\t* bgp_main.c: Make group to run as configurable.\n\n2004-11-09 Paul Jakma <paul@dishone.st>\n\n\t* bgp_nexthop.c: collapse bgp_connected_ipvX, bgp_nexthop_cache_ipvX\n\t  and cache{1,2}.. into arrays of tables and hence collapse\n          bgp_scan_ipv{4,6} into a single bgp_scan function. Tested, though\n          a long time ago (and this change was hand-merged).\n\n2004-11-04 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* bgp_route.c: Remove all code related to VTY_CONTINUE; this feature\n\t  is deprecated because the output did not represent a single point\n\t  in time.  All output needs to be generated inline and buffered\n\t  by the library code.\n\t  (route_vty_out,route_vty_out_tag,damp_route_vty_out,\n\t   flap_route_vty_out) Remove code to count number of lines of output,\n\t   since this was only useful for VTY_CONTINUE behavior.\n\t  (bgp_show_callback,vty_calc_line) Removed.\n\t  (bgp_show_table) Remove hooks for VTY_CONTINUE callback support.\n\t  As a result, there's a new output_arg argument to this function.\n\t  Make function static.\n\t  (bgp_show) Make function static and add a new output_arg argument.\n\t  Change all functions that call bgp_show or bgp_show_table to\n\t  pass the new output_arg argument (that used to be passed inside\n\t  vty->output_arg).\n\t* bgp_mplsvpn.c: Remove declarations of functions defined in\n\t  bgp_route.c; these declarations belong in bgp_route.h.\n\t* bgp_route.h: Declare 3 global functions used in both bgp_route.c\n\t  and in bgp_mplsvpn.c.\n\n2004-10-31 Paul Jakma <paul@dishone.st>\n\n\t* {bgpd,bgp_attr}.c: size_t printf format should be ld.\n\n2004-10-25 Paul Jakma <paul@dishone.st>\n\n\t* Update with fix in debian bug id 222930.\n\t* bgp_main.c: Add ZCAP_RAW, needed to bind to interfaces.\n\t  bgp_network.c: (....) raise/lower privs around call to\n          SO_BINDTODEVICE sockopt. \n\n2004-10-19 Andrew J. Schorr <aschorr@telemetry-investments.com>\n\n\t* bgp_nexthop.c: (bgp_connected_add) Connected destination pointer\n\t  may be NULL.\n\t  (bgp_connected_delete) ditto.\n\n2004-10-14 Hasso Tepper <hasso at quagga.net>\n\n\t* bgp_dump.c: Make dump configuration appear in vtysh.\n\n2004-10-13 Hasso Tepper <hasso at quagga.net>\n\n\t* bgp_snmp.c: Remove defaults used to initialize smux connection to\n\t  snmpd. Connection is initialized only if smux peer is configured.\n\t* bgp_view.c: It's dead file. Reomved.\n\n2004-10-13 Paul Jakma <paul@dishone.st>\n\n\t* (global) more const'ification and fixups of types to clean up code.\n\t* bgp_mplsvpn.{c,h}: (str2tag) fix abuse. Still not perfect,\n          should use something like the VTY_GET_INTEGER macro, but without\n          the vty_out bits..\n        * bgp_routemap.c: (set_aggregator_as) use VTY_GET_INTEGER_RANGE\n          (no_set_aggregator_as) ditto.\n        * bgpd.c: (peer_uptime) fix unlikely bug, where no buffer is \n          returned, add comments about troublesome return value.\n\t\n2004-10-03 James R. Leu <jleu at mindspring.com>\n\n\t* bgp_vty.c: Router id from zebra can be manually overriden.\n\t* bgp_zebra.c: Read router id related messages from zebra daemon.\n\t  Remove own code related with router id selection.\n\t* bgpd.c, bgpd.h: Remove own router id selection code. Use the one\n\t  from zebra daemon if it isn't manually overriden.\n\n2004-09-26 Hasso Tepper <hasso at quagga.net>\n\n\t* bgp_aspath.c, bgp_packet.c, bgp_vty.c: Fix compiler warnings.\n\n2004-09-23 Hasso Tepper <hasso at quagga.net>\n\n\t* *.[c|h]: list -> struct list *, listnode -> struct listnode *.\n\n2004-07-09 Paul Jakma <paul@dishone.st>\n\n\t* Merge of GNU Zebra cvs2svn changesets r799, r800 and r807.\n\t* bgp_dump.c: (bgp_dump_attr) cleanup. return status code. check\n\t  attributes present before printing.\n\t* bgp_dump.c: update bgp_dump_attr prototype.\n\t* bgp_packet.c: (bgp_update_receive) init attrstr. check status\n\t  of bgp_dump_attr. Log end-of-rib UPDATEs.\n\n2004-07-09 Sowmini Varadhan <sowmini.varadhan@sun.com>\n\n\t* bgp_packet.c: (bgp_collision_detect) Send NOTIFY on new socket\n\t  if that is connection we're closing.\n\t  (bgp_read) invalid marker check applies to KEEPALIVE too.\n\t* bgp_route.c: Ignore multicast NRLI, dont send NOTIFY.\n\t\n2004-06-04 Paul Jakma <paul@dishone.st>\n\n\t* type mismatch fixes\n\t  \n2004-05-21  Akihiro Mizutani <mizutani@net-chef.net>\n\n\t* bgpd.h, bgp_open.[ch], bgp_debug.c, bgp_vty.[ch], bgp_fsm.c:\n\t  Graceful restart capability display.\n\n2005-05-20 Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* bgp_debug.c: Cosmetical fixes and log neighbor changes.\n\n2004-05-20  Akihiro Mizutani <mizutani@net-chef.net>\n\n\t* bgp_ecommunity.c: Transit ecommunity support.\n\t* bgp_ecommunity.c: Fix for unknown community crush.\n\n2005-05-20 Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* *: Maximum prefix threshold support.\n\t* *: Reset notification fixups.\n\n2004-05-08 Paul Jakma <paul@dishone.st>\n\n\t* bgp_zebra.c: (bgp_interface_address_add) sync to zclient changes\n\t  (bgp_interface_address_delete) ditto.\n\t  (bgp_zebra_announce) ditto.\n\t  (bgp_zebra_withdraw) ditto.\n\n2004-05-03 Daniel Roesen <dr@cluenet.de>\n\t\n\t* bgp_fsm.c: (bgp_stop) Reset uptime only on transition from \n\t  Established so that it reflects true downtime (rather time \n\t  since last transition, eg Active->Idle)\n\t  \n2004-05-01 rivo nurges <rix@estpak.ee>\n \n        * bgp_route.c: fix UNH IOL BGP-4.1.12f\n \n2004-05-01 Paul Jakma <paul@dishone.st>\n\n\t* Revert the attempted clean-up of the dummy peer hack, reverts\n\t  patchsets 435 (see 2004-02-17 below) and 456. \n\n2004-04-16 rivo nurges <rix@estpak.ee>\n\n\t* bgpd.h, bgp_debug.c: update cease subcodes to\n\t  draft-ietf-idr-cease-subcode-05\n\t* bgpd.h, bgpd.c, bgp_route.c, bgp_route.h: fix UNH IOL BGP-4.1.6a\n\n2004-02-17 Paul Jakma <paul@dishone.st>\n\n\t* bgpd.h: (bgp_peer) add fd_local and fd_accept \n\t  file descriptor's, fd becomes a pointer to one of these.\n\t* bgpd.c: (global) adjust for fact that fd is now a pointer.\n\t  (peer_create_accept) removed.\n\t* bgp_route.c: (global) adjust for change of peer fd to pointer\n\t* bgp_packet.c: (bgp_collision_detect) adjust and remove the \n\t  \"replace with other peer\" hack. \n\t* bgp_network.c: (bgp_accept) Remove the dummy peer hack. \n\t  Update peer->fd_accept instead. \n\t  (global) Adjust fd references - now a pointer.\n\t* bgp_fsm.c: (global) adjust peer fd to pointer.\n\t  (bgp_connection_stop) new function, to stop connection.\n\t  (global) adjust everything which closed peer fd to use\n\t  bgp_connection_stop().\n\t  \n2003-12-23 Krzysztof Oledzki <oleq@ans.pl>\n\n\t* bgp_network.c: drop privs on error cases\n\n2003-08-11 kunihiro <kunihiro@zebra.org>\n\n\t* bgp_route{,map}.c: Extend 'set ip next-hop' in route-maps with\n\t  ability to specify 'peer-address' rather than IP. \n\n2003-06-09 Paul Jakma <paul@dishone.st>\n\n\t* bgp_clist.c (community_list_delete): honour deny statements\n\n2003-04-19 Hasso Tepper <hasso@estpak.ee>\n\n\t* rip_routemap.c: sync daemon's route-map commands to have same\n\tsyntax\n\n2003-01-09  Akihiro Mizutani <mizutani@net-chef.net>\n\n\t* bgp_routemap.c: Add match extcommunity command.\n\n2002-10-23  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* bgp_aspath.c (aspath_init): Extend hash size from default to\n\t32767.\n\t(aspath_key_make): Use unsigned shoft for making hash.  Suggested\n\tby: Marc Evans <Marc@SoftwareHackery.Com>\n\n2002-08-19  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* bgp_clist.c (community_entry_free): Fix memory leak of standard\n\textcommunity-list config string.\n\n2002-08-19  Akihiro Mizutani <mizutani@net-chef.net>\n\n\t* bgp_route.c (route_vty_out_detail): Fix bug of router-id display\n\twhen multiple instance is used.\n\n2002-08-18  Akihiro Mizutani <mizutani@net-chef.net>\n\n\t* bgpd.c: Make \"default-originate\" and \"maximum-prefix\" commands\n\tavailable in peer-group configuration.\n\n2002-08-13  Akihiro Mizutani <mizutani@net-chef.net>\n\n\t* bgp_packet.c (bgp_open_send): Put Opt Parm Len 0 when last\n\tcapability packet cause error or dont-capability-negotiate option\n\tis specified.\n\n2002-07-07  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* zebra-0.93 released.\n\n2001-10-28  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c (bgp_vty_init): Translate update commands are removed.\n\n2001-10-10  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_static_set): Add workaround for BGP static\n\troute announcement when there is no zebra running.\n\n2001-10-08  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c (neighbor_remote_as_unicast): Remove \"remote-as nlri\n\tunicast multicast\" commands.\n\n2001-09-14  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_open.c: When we receive capability route-refresh, we should\n\tcheck we send the capability not we receive the capability.\n\n\t* bgp_route.c (bgp_network_mask_natural_route_map): network\n\tstatement route-map is added.\n\n2001-08-31  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* bgp_advertise.c (bgp_advertise_intern): attr must be interned\n\tbefore looking up hash table.\n\n2001-08-30  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* bgpd.h (struct peer): BGP filter is moved from peer_conf to\n\tpeer.\n\n2001-08-28  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* bgp_nexthop.c (bnc_nexthop_free): Fix next pointer bug.\n\tSuggested by: \"Hong-Sung Kim\" <hoskim@lanbird.co.kr>.\n\n2001-08-26  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* bgp_table.c (bgp_node_create): Clearn memory before use it.\n\n2001-08-24  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* Change to use bgp_table.[ch].\n\n2001-08-23  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* bgpd.c (bgp_init): Add \"transparent-as\" and\n\t\"transparent-nexthop\" for old version compatibility.\n\n2001-08-23  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgpd.h (struct peer): default-originate route-map is added.\n\n\t* bgp_route.c: When self originated route is advertised with\n\tattrubute-unchanged, nexthop was not properly set.  This bug is\n\tfixed.\n\n2001-08-22  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgpd.c (neighbor_attr_unchanged): transparent-as and\n\ttransparent-next-hop commands are restructured.  Instead of\n\tcurrent transparent-* commands, attribute-unchanged command is\n\tintroduced.\n\n\tneighbor A.B.C.D attribute-unchanged [as-path|next-hop|med]\n\n\t(neighbor_default_originate): \"default-originate\" configuration\n\tannounce default route even 0.0.0.0/0 does not exists in BGP RIB.\n\n2001-08-19  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* zebra-0.92a released.\n\n2001-08-19  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgpd.c: AF specific soft-reconfiguration inbound commands are\n\tadded.\n\n2001-08-17  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* bgp_route.c (bgp_show_callback): Do not do community NULL check.\n\n\t* bgp_community.c (community_cmp): Add check for commnunity NULL\n\tcheck.\n\n\t* bgp_routemap.c (route_match_community): Do not check comunity is\n\tNULL.  It may match to community-list \"^$\".\n\n\t* bgp_community.c (community_match): Add check for community is\n\tNULL case.\n\n2001-08-17  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgpd.c: AF specific route-reflector-client and\n\troute-server-client configuration are added.\n\n2001-08-17  Rick Payne <rickp@ayrnetworks.com>\n\n\t* bgp_clist.c (community_match_regexp): Check special ^$ case.\n\n2001-08-17  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_clist.c (community_list_match): Fix bug of community list\n\tpermit and deny check.\n\n2001-08-16  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_mplsvpn.c (bgp_mplsvpn_init): Add AF specific \"nexthop-self\"\n\tcommand.\n\n2001-08-15  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgpd.h (PEER_FLAG_SEND_COMMUNITY): Per AF based configuration\n\tflag is introduced.\n\n\t* bgp_mplsvpn.c (bgp_mplsvpn_init): VPNv4 filtering is added.\n\n2001-08-15  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* zebra-0.92 released.\n\n2001-08-13  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* bgpd.c (bgp_delete): \"no router bgp\" free static, aggregate, rib\n\ttable properly.\n\n2001-08-12  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* bgp_route.c (bgp_node_safi): Return SAFI of current node.\n\t(bgp_config_write_network_vpnv4): VPNv4 static configuration\n\tdisplay.\n\n2001-08-11  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* bgpd.c (no_bgp_ipv4_multicast_route_map): Add IPv4 multicast\n\tnode filter commands.\n\n2001-08-11  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.h (PEER_FLAG_IGNORE_LINK_LOCAL_NEXTHOP): Add\n\t\"ignore-link-local-nexthop\" flag for ignore link-local nexthop for\n\tIPv6.\n\n2001-08-07  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* bgpd.c (address_family_ipv4_multicast): \"address-family ipv4\n\tmulticast\" is added.\n\t(address_family_ipv6_unicast): \"address-family ipv6 unicast\" is\n\tadded.\n\t\n2001-08-07  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_route.c (bgp_process): Use flag instead of as_selected\n\tmemeber in struct bgp_info.\n\n\t* bgp_route.h (struct bgp_info): Remove as_selected memeber from\n\tstruct bgp_info.\n\n2001-07-31  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* bgp_route.c (bgp_announce_check): Enclose sending time AS loop\n\tcheck code with #ifdef BGP_SEND_ASPATH_CHECK.\n\n2001-07-29  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* bgp_packet.c (bgp_withdraw_send): Simplify address family check.\n\n\t* bgpd.h (BGP_INFO_HOLDDOWN): Introduce new macro to check BGP\n\tinformation is alive or not.\n\n\t* bgp_community.c: Use community_val_get() on all OS.\n\n2001-07-24  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* bgp_route.c (bgp_announce_check): Simplify set next-hop self\n\tcheck.\n\n2001-07-24  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_route.c (bgp_announce_check): To route server clients, we\n\tannounce AS path, MED and nexthop transparently.\n\n2001-06-21  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_routemap.c (route_set_atomic_aggregate_free): Do not call\n\tXFREE.  No memory is allocated in\n\troute_set_atomic_aggregate_compile().\n\n2001-06-21  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_routemap.c (bgp_route_map_init): `match nlri` and `set nlri`\n\tare replaced by `address-family ipv4` and `address-family vpnvr'.\n\n2001-06-19  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_withdraw): Add check for BGP_PEER_CONFED.\n\tReported by Rick Payne <rickp@rossfell.co.uk>.\n\n2001-06-17  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_zebra.c (bgp_zebra_announce): When global IPv6 nexthop is\n\tempty, use socket's remote address for the nexthop.\n\n2001-06-04  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* bgpd.c (peer_delete): Fix memory leak.  Reported by Yosi Yarchi\n\t<Yosi_Yarchi@KereniX.com>\n\n2001-06-01  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* bgpd.c (bgp_delete): Fix memory leak.  Reported by Yosi Yarchi\n\t<Yosi_Yarchi@KereniX.com>\n\n2001-05-27  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* bgp_route.c (bgp_route_clear_with_afi_vpnv4): Use next instead\n\tof ri->next.\n\n\t* bgp_packet.c (bgp_withdraw_send): MPLS/VPN withdraw takes effect\n\twhen HAVE_IPV6 is not defined.\n\n2001-03-07  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* bgpd.c (peer_timers_set): Adjust keepalive timer to fit less\n\tthan holdtime / 3.\n\t(bgp_confederation_peers_unset): Only set peer->local_as when\n\tconfederation is enabled.\n\t(bgp_timers): Add \"timers bgp <0-65535> <0-65535>\" command.\n\n\t* bgp_route.c (bgp_announce_check): Set med of redistributed route\n\twhen it is announced to EBGP peer.\n\n2001-03-06  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* bgp_nexthop.c (bgp_scan_ipv4): bgp_scan() call bgp_process() for\n\tall prefixes.\n\n2001-03-06  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_attr.c (bgp_attr_origin): When bgpd send NOTIFICATION with\n\terroneous attribute (type, length and value), it does include\n\tattribute flags field.\n\n2001-02-21  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* bgp_route.c (bgp_announce_check): The route reflector is not\n\tallowed to modify the attributes of the reflected IBGP routes.\n\n2001-02-20  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* bgp_route.c (bgp_info_cmp): During path seleciton, BGP\n\tconfederation peer is treated as same as IBGP peer.\n\n2001-02-19  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_redistribute_add): Initialize attr_new with\n\tattr.  Call aspath_unintern when return from this function.\n\n2001-02-19  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* bgpd.c (bgp_router_id_set): Reset BGP peer when router-id is\n\tchanged.\n\n2001-02-18  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* bgp_packet.c (bgp_open_receive): When user configure holdtimer,\n\tdo not refrect the value to current session.\n\n2001-02-16  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_aggregate_delete): Set BGP_INFO_ATTR_CHANGE to\n\tsuppress route withdraw.\n\n\t* bgp_damp.c (bgp_damp_init): Fix bug of flap dampening.\n\n2001-02-16  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* bgp_aspath.c (aspath_make_str_count): Use ',' for separator for\n\tAS_SET and AS_CONFED_SET.\n\n2001-02-15  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_process): Do not consider suppress route.\n\n\t* bgp_aspath.c (aspath_aggregate_as_set_add): Reset asset when\n\taspath->data is realloced.\n\n2001-02-15  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* bgp_attr.c (bgp_attr_aggregate_intern): Do not set atomic\n\taggregate when using as-set.\n\n2001-02-14  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* bgpd.c (bgp_confederation_peers_unset): Set peer's local-as\n\tcorrectly.\n\n\t* bgp_route.c (bgp_update): Just ignore AS path loop for\n\tconfederation peer.\n\n2001-02-10  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_aggregate_set): Add as_set argument.\n\t(bgp_aggregate_unset): Remove summary_only argument.\n\t(aggregate_address_as_set): New commands.\n\t\"aggregate-address A.B.C.D/M as-set\"\n\t\"no aggregate-address A.B.C.D/M as-set\"\n\n2001-02-08  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* bgp_route.c (bgp_announce_check): Do not modify nexthop when the\n\troute is passed by route reflector.\n\n2001-02-08  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c: \"no bgp dampening\" with argument.\n\t(bgp_announce_check): Do not modify nexthop when the route is\n\tpassed by route reflector.\n\n2001-02-07  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* bgpd.c (neighbor_passive): Change \"neighbor NEIGHBOR remote-as\n\tASN passive\" to \"neighbor NEIGHBOR passive\".\n\t(bgp_announce_check): Check well-known community attribute even\n\twhen \"no neighbor send-community\" is set.\n\n2001-02-03  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_fsm.c (bgp_establish): Do not send keepalive at established\n\ttime when keepalive timer is configured as zero.\n\n2001-02-01  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_attr.c (bgp_attr_check): When peer is IBGP peer, local\n\tpreference is well-known attribute.\n\n2001-01-30  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* zebra-0.91 is released.\n\n\t* bgp_attr.h (struct attr): Comment out DPA value.\n\t(struct attr): Change refcnt type from int to unsinged long.\n\n\t* bgp_attr.c (attrhash_key_make): Likewise.\n\t(attrhash_cmp): Likewise.\n\t(bgp_attr_dpa): Likewise.\n\n2001-01-30  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* bgp_route.c (bgp_info_cmp): Make route selection completely same\n\tas Cisco's.\n\n2001-01-30  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_attr.h (BGP_ATTR_FLAG_OPTIONAL): Rename old ATTR_FLAG_* to\n\tBGP_ATTR_FLAG_* to clarify meenings.\n\n2001-01-30  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* bgp_route.c (route_vty_out): Display argument to suppress same\n\tprefix information display.\n\t(route_vty_out_route): Don't display mask information for\n\tclassfull network.\n\n2001-01-30  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_attr.h (SET_BITMAP): Simple bitmapping macros.\n\n\t* bgp_attr.c (bgp_attr_parse): Use bitmap for attribute type\n\tcheck.\n\n2001-01-29  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_attr.c (bgp_mp_reach_parse): Enclose loggin with BGP_DEBUG.\n\t(bgp_attr_parse): Comment out well-known attribute check.\n\n2001-01-28  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_static_unset): Link-local IPv6 address can't be\n\tused for network advertisement.\n\t(nlri_parse): When link-local IPv6 address NLRI comes from\n\tremote-peer, log the information then simply ignore it.\n\n\t* bgp_zebra.c (zebra_read_ipv6): Link-local IPv6 address is not\n\tredistributed.\n\n\t* bgp_route.c (bgp_update): Check IPv6 global nexthop\n\treachability.\n\n2001-01-26  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_update): Check nexthop points local address or\n\tnot.\n\t(bgp_static_update_vpnv4): Set valid flag.\n\n\t* bgp_attr.c (bgp_attr_parse): Duplicate attribute check.\n\t(bgp_attr_parse): Well-known attribute check.\n\n\t* bgp_open.c (bgp_auth_parse): Authentication is not yet supported.\n\n\t* bgp_packet.c (bgp_valid_marker): Check marker is synchronized.\n\n\t* bgpd.c (clear_bgp): Send NOTIFICATION Cease when SEND_CEASE is\n\tdefined.\n\n\t* bgp_snmp.c (bgp4PathAttrTable): Fix compile error.\n\n2001-01-24  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c (bgp_network_import_check): New command for IGP network\n\tcheck.\n\n2001-01-23  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_nexthop.c (bgp_scan): Run bgp_process when IGP metric is\n\tchanged.  Call bgp_process once for each node.\n\n2001-01-23  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* bgp_route.c (bgp_info_cmp): Add IGP metric comparison.\n\n2001-01-23  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_info_cmp): Add IGP metric comparison.\n\n\t* bgp_nexthop.c (bgp_nexthop_lookup): Set IGP metric for valid\n\tIBGP route.\n\n2001-01-23  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* bgp_route.c (show_ip_bgp_prefix_longer): Add new commands.\n\t\"show ip bgp A.B.C.D/M longer-prefixes\"\n\t\"show ip bgp ipv4 (unicast|multicast) A.B.C.D/M longer-prefixes\"\n\t\"show ipv6 bgp X:X::X:X/M longer-prefixes\"\n\t\"show ipv6 mbgp X:X::X:X/M longer-prefixes\"\n\t\n2001-01-20  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* bgp_route.c (show_ip_bgp_cidr_only): Add new commands.\n\t\"show ip bgp cidr-only\"\n\t\"show ip bgp ipv4 (unicast|multicast) cidr-only\"\n\t\n2001-01-18  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* bgp_route.c (bgp_update): AS path lookup check is done in\n\tbgp_update() not in attr_parse().\n\n2001-01-18  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_update): Call bgp_aggregate_decrement() just\n\tbefore bgp_attr_unintern().\n\n2001-01-17  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_update): Now intern is performed very last part\n\tof the BGP packet update procedure.\n\n2001-01-17  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* bgp_route.c (bgp_update): When implicit withdraw occur, reuse\n\texisting bgp_info structure.\n\n2001-01-17  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_aggregate_decrement): Fix bug of aggregate\n\taddress matching method.\n\t(bgp_update): \n\n\t* bgp_nexthop.c (bgp_nexthop_onlink): Separate EBGP nexthop onlink\n\tcheck and IBGP nexthop route check.\n\n2001-01-16  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* bgp_route.h (BGP_INFO_ATRR_CHANGED): Added for track attribute\n\tchange.\n\n2001-01-16  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.h (struct bgp_info): Remove selected flag.  Use\n\tBGP_INFO_SELECTED for flags instead.\n\t(struct bgp_info): Remove valid flag.  Use BGP_INFO_VALID for\n\tflags instead.\n\t(struct bgp_info): Add igpmetric for IBGP route nexthop IGP\n\tmetric.\n\t(struct bgp_info_tab): Struct bgp_info_tag is integrated into\n\tstruct bgp_info.\n\t(BGP_INFO_ATRR_CHANGED): Added for track attribute change.\n\n\t* bgp_community.c (community_val_get): gcc-2.95 on\n\tsparc-sun-solaris cause crush.  This function is for avoid the\n\tcrush.\n\n2001-01-15  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_packet.c (bgp_open_receive): Translated peer's packet_size\n\tclear bug is fixed.\n\n2001-01-14  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* bgp_packet.c (bgp_open_receive): Return notification with\n\tsupported version number.\n\n2001-01-13  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c (bgp_show_summary): Display AS path and community\n\tentries.  Suggested by: \"Matt Ranney\" <mjr@ranney.com>.\n\n\t* bgp_packet.c (bgp_read_packet): Fix bug of unblocking BGP socket\n\tread.  When BGP packet read is partial, we must get size and type\n\tfrom packet again.\n\n2001-01-12  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* bgp_route.c (bgp_update): Do not unset BGP_INFO_HISTORY flag.\n\t(bgp_update): When there is a history entry increment route count.\n\t(bgp_damp_set): Check BGP_CONFIG_DAMPENING flag.\n\n\t* bgp_damp.c (bgp_damp_withdraw): Set status to\n\tBGP_DAMP_DISCONTINUE.\n\n2001-01-11  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_attr.c (bgp_mp_reach_parse): Fix warning code when second\n\tIPv6 nexthop is not link-local addresss.\n\n2001-01-11  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* bgp_damp.c (bgp_config_write_damp): Smart flap dampening\n\tconfiguration display.\n\t(bgp_damp_info_print): Display elapsed time from flap started.\n\n\t* bgp_damp.h (struct bgp_damp_info): Add flap start time.\n\n\t* bgpd.c (peer_create): Set last read time.\n\t(bgp_show_peer): Display last read time.\n\t(bgp_show_summary): Use BGP_CONFIG_DAMPENING flag to check\n\tconfiguration.\n\t\n\t* bgpd.h (BGP_CONFIG_DAMPENING): Add new configuration option.\n\t(struct peer): Add last read time member.\n\t(BGP_VERSION_MP_4): Remove obsolete definition.\n\n2001-01-10  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_nexthop.c: Remove OLD_RIB codes.\n\n\t* bgp_route.c (bgp_process): Likewise.\n\n\t* zebra-0.90 is released.\n\n\t* bgp_route.h (BGP_INFO_HISTORY): Remove damped member from struct\n\tbgp_info.  Instead of that use BGP_INFO_DAMPED flag.\n\t(struct bgp_info): Remove invalid member from struct bgp_info.\n\tInstead of that use BGP_INFO_HISTORY flag.\n\n2001-01-10  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* bgp_damp.c (bgp_damp_info_print): New function to display\n\tdampening status.\n\t(DEFAULT_HARF_LIFE): Define default value.\n\t(DEFAULT_REUSE): Likewise.\n\t(DEFAULT_SUPPRESS): Likewise.\n\t(bgp_config_write_damp): When config value is same as default\n\tvalue, simply display \"bgp dampening\" to configuration.\n\n\t* bgp_damp.h (struct bgp_damp_info): Add flap member.\n\n\t* bgp_route.h (struct bgp_info): Added for BGP flap dampening\n\thistory status.\n\n2001-01-10  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_nexthop.c (bgp_connected_add): Point-to-point connected\n\taddress is properly handled.\n\t(bgp_connected_delete): Likewise.\n\n\t* bgp_route.c (bgp_route_init): Turn off BGP Flap dampening code\n\tuntil it works fine.\n\n2001-01-09  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c (bgp_show_summary): Add BGP_VERSION_MP_4 case.\n\n\t* bgp_route.c (bgp_update): When this is not damped route, clear\n\tri pointer.\n\n2001-01-09  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_main.c: Add \"-n\" no_kernel option to not install route to\n\tkernel.  Suggested by: \"Matt Ranney\" <mjr@ranney.com>\n\n2001-01-09  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_nexthop.c (bgp_connected_add): Revert point-to-point\n\tconnected route patch.  Reported by ruud@ruud.org (Ruud de Rooij)\n\n\t* bgp_damp.c (bgp_config_write_damp): Add configuration display\n\tfunction.\n\n\t* bgp_route.c (bgp_info_free): Set NULL to BGP dampening\n\tinformation when BGP info structure is freed.\n\t(bgp_info_cmp): Check damped flag.\n\t(bgp_announce_check): Damped route is not announced.\n\n2001-01-09  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* bgpd.c (neighbor_capability_route_refresh): Change \"neighbor\n\troute-refresh\" command to \"neighbor capability route-refresh\".\n\t(clear_bgp_soft_in): Change soft-reconfig method.\n\n\tclear ip bgp <neighbor> soft in\n        --------------------------------------\n        Try stored cache first then route-refresh\n\n        clear ip bgp <neighbor> in\n        ---------------------------------\n        Try route-refresh first then try to use stored cache\n\n2001-01-09  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_nexthop.c (bgp_connected_add): Check point-to-point\n\tconnected route.  Reported by ruud@ruud.org (Ruud de Rooij)\n\n2001-01-08  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_nexthop.c (bgp_nexthop_lookup): When IBGP nexthop is\n\tchanged, refresh it.\n\n2001-01-04  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.h (struct bgp_info_tag): Add as_selected to\n\tbgp_info_tag.\n\n2001-01-03  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.h (struct bgp_info_tag): Add damped and bgp_damp_info\n\tmember for BGP flap dampening.\n\n\t* bgp_damp.c: New file is added.\n\n\t* bgp_damp.h: Likewise.\n\n2001-01-01  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.h (BGP_VTYSH_PATH): Change \"/tmp/bgpd\" to \"/tmp/.bgpd\".\n\n2000-12-29  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_nexthop.c (zlookup_connect): Change to use UNIX domain\n\tsocket for zebra communication.\n\n2000-12-29  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_route.c (bgp_process): Fix \"bgp deterministic-med\" process.\n\n2000-12-27  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_route.c (bgp_process): Add \"bgp deterministic-med\" process.\n\n2000-12-25  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_route.c (bgp_info_cmp): Use ntohl comparing router ID.\n\n2000-12-18  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_route.c (bgp_info_cmp): When over three same prefix exit,\n\twithdrawing best prefix perform router ID comparison.\n\n2000-12-15  Akihiro Mizutani  <mizutani@dml.com>\n\n\t* bgp_route.c (bgp_info_cmp): Do not compare router ID when the\n\troutes comes from EBGP peer.  When originator ID is same, take\n\tshorter cluster-list route.  If cluster-list is same take smaller\n\tIP address neighbor's route.\n\n\t* bgpd.c (bgp_bestpath_aspath_ignore): Add \"bgp bestpath as-path\n\tignore\" command.  When this option is set, do not concider AS path\n\tlength when route selection.\n\t(bgp_bestpath_compare_router_id): Add \"bgp bestpath\n\tcompare-routerid\".  When this option is set, compare router ID\n\twhen the routes comes from EBGP peer.\n\t\n2000-12-15  Akihiro Mizutani  <mizutani@dml.com>\n\n\t* bgp_route.c (bgp_info_cmp): Compare originator ID when it is\n\tavailable.\n\n2000-12-14  Akihiro Mizutani  <mizutani@dml.com>\n\n\t* bgp_packet.c (bgp_notify_receive): Disply received Notify data\n\tinformation.\n\n2000-12-14  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_filter.c (as_filter_free): Use MTYPE_AS_FILTER_STR to make\n\tit sure the memory is freed.\n\n\t* bgp_route.c (route_vty_out_detail): Do not use AF_INET6 outside\n\tHAVE_IPV6.\n\n2000-12-08  Akihiro Mizutani  <mizutani@dml.com>\n\n\t* bgp_packet.c (bgp_notify_send_with_data): Store BGP notification\n\tdata part.\n\n\t* bgp_network.c (bgp_accept): When BGP connection comes from\n\tunconfigured IP address, close socket immediately.\n\n\t* bgpd.c: Fix some display format.\n\n2000-11-29  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_packet.c (bgp_keepalive_send): Delete duplicate\n\tbgp_packet_set_size () call.\n\n2000-11-28  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_packet.c (bgp_read_packet): Remove debug codes.\n\n2000-11-27  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_snmp.c (write_bgpPeerTable): Add SNMP set method routine.\n\n\t* bgp_fsm.c (bgp_stop): Use fsm_change_status to change peer's\n\tstatus.\n\t(bgp_establish): Likewise.\n\n2000-11-26  Akihiro Mizutani  <mizutani@dml.com>\n\n\t* bgp_open.c: Fix error messages.\n\n2000-11-25  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_fsm.c (bgp_establish): Call BGP trap when the peer is\n\testablished.\n\t(bgp_stop): Call BGP trap when the peer is dropped.\n\n2000-11-24  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_snmp.c (bgp4PathAttrTable): Return BGP path attribute table.\n\n\t* bgpd.h (struct peer): Add update_time for track last update\n\treceived time.\n\n\t* bgp_packet.c (bgp_notify_receive): Preserv notify code and sub\n\tcode in any case.\n\n\t* bgp_snmp.c (bgpPeerTable): Return remote router ID instead of\n\tpeering IP address.\n\t(bgpPeerTable): Return actual BGP version number.\n\n2000-11-22  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_debug.c (bgp_notify_print): Notify data length display bug\n\tis fixed.\n\n2000-11-16  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_nexthop.c (zlookup_connect): When UNIX domain connection to\n\tzebra is enabled, use the method.\n\n2000-11-16  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgpd.c: Revise debug message output.\n\n2000-11-15  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_clist.c (ip_community_list): Fix bug of string comparison.\n\n2000-11-14  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_community.c (community_match): Fix bug of memcmp return\n\tvalue check.\n\n2000-11-07  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_clist.c (community_list_match_exact): Add check for\n\tentry->style is COMMUNITY_LIST.\n\t(community_match_regexp): Apply new com_nthval macro.\n\n2000-11-07  Rick Payne <rickp@rossfell.co.uk>\n\n\t* bgp_routemap.c (route_set_community_delete): \"set\n\tcommunity-delete COMMUNITY-LIST\" is added.\n\n\t* bgp_community.c (community_del_val): Delete one community.\n\t(community_delete): Delete all community included in list.\n\t(community_match): Fix bug of matching community value.\n\n\t* bgp_clist.c (community_entry_free): Free community regular\n\texpression.\n\t(community_entry_make): Default style is COMMUNITY_LIST.\n\t(community_entry_lookup): Make it sure style is COMMUNITY_LIST.\n\t(community_entry_regexp_lookup): New function for community\n\tregular expression lookup.\n\t(community_match_regexp): New function.\n\t(community_delete_regexp): New function.\n\t(community_list_delete_entries): New function.\n\t(community_list_match): Add COMMUNITY_REGEXP treatment.\n\t(community_list_match_exact): Likewise.\n\t(config_write_community): Write community list according to\n\tentry->style.\n\n2000-11-07  Rick Payne <rickp@rossfell.co.uk>\n\n\t* bgp_attr.c (bgp_attr_aspath): AS path first AS check.\n\n\t* bgp_clist.c (struct community_entry): Add style, regexp, reg to\n\tcommunity_entry.\n\n2000-11-06  Rick Payne <rickp@rossfell.co.uk>\n\n\t* bgp_aspath.c (aspath_firstas_check): AS path first AS check.\n\n\t* bgpd.c (bgp_enforce_first_as): New command \"bgp\n\tenforce-first-as\".\n\n\t* bgpd.h (BGP_CONFIG_ENFORCE_FIRST_AS): Add new flag.\n\n2000-11-06  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_community.c (community_compare): Copy byte stream data to\n\tactual value instead of using type casting hack.\n\t(community_add_val): Likewise.\n\t(community_uniq_sort): Likewise.\n\t(community_print): Likewise.\n\t(community_print_vty): Likewise.\n\t(community_include): Use memcmp to compare community value.\n\n\t* bgp_community.h (com_lastval): com_lastval and com_nthval macro\n\treturn pointer.\n\n2000-11-06  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgpd.h (struct peer): Add established and dropped member for\n\tcount peering up/down statistics.\n\n\t* bgpd.c (bgp_show_peer): Display peering up/down statistics.\n\n\t* bgp_fsm.c (bgp_establish): Increment established count.\n\t(bgp_stop): Increment dropped count.\n\n\t* bgp_packet.c (bgp_notify_receive): Increament notify count.\n\n2000-11-1  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_fsm.c: Fix bug of holdtimer is not reset when bgp cleared. \n\n2000-10-31  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.h: Static bit flag is set by (1 << DIGIT).\n\n2000-10-24  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_ecommunity.c (ecommunity_dup): Extended community display\n\tformat fix.\n\n2000-10-24  Arkadiusz Miskiewicz <misiek@pld.org.pl>\n\n\t* bgp_network.c (bgp_serv_sock_addrinfo): Use gai_strerror.\n\t(bgp_serv_sock_addrinfo): Check address family.\n\n2000-10-23  Jochen Friedrich <jochen@scram.de>\n\n\t* bgp_snmp.c: bgp_oid and bgpd_oid are used in smux_open after it\n\tis registered.  So those variables must be static.\n\n2000-10-23  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_routemap.c (route_match_ip_next_hop): Change \"match ip\n\tnext-hop\" argument from IP address to access-list name.\n\tRemove zebra-0.88 compatibility commands.\n        \"match ip prefix-list WORD\"\n        \"match ipv6 prefix-list WORD\"\n\t\n2000-10-23  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_routemap.c (route_match_ipv6_next_hop_compile): Fix bug of\n\tpassing the pointer to the pointer of struct in6_addr instead of\n\tthe pointer of struct in6_addr in \"match ipv6 next-hop\" command.\n\n\t* bgp_route.c (bgp_announce_check): Enclose IPv6 part with\n\tHAVE_IPV6.\n\n2000-10-20  Jasper Wallace <jasper@ivision.co.uk>\n\n\t* bgp_snmp.c (bgpPeerTable): ntohs missing bug is fixed.  Change\n\tto use linklist.c.  Define COUNTER32 as ASN_COUNTER.\n\n2000-10-18  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_announce_check): attr->nexthop empty check\n\tshould be done by attr->nexthop.s_addr instead of strcmp.\n\n2000-10-18  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_zebra.c (zebra_read_ipv4): Pass nexthop value to\n\tbgp_redistribute_add().\n\n\t* bgp_nexthop.c (bgp_multiaccess_check_v4): New function for\n\tchecking IPv4 multiaccess nexthop.\n\n\t* bgp_route.c (bgp_announce_check): In case of the nexthop is\n\treachable on multiaccess media, do not change nexthop.\n\t(bgp_redistribute_add): Set nexthop when the value is passed.\n\n2000-10-17  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_fsm.c (bgp_timer_set): If peer is passive mode, do not set\n\tconnect timer.\n\t(bgp_start): If the peer is passive mode, force to move to Active\n\tmode.\n\n2000-10-17  Horms <horms@vergenet.net>\n\n\t* bgp_debug.c (debug_bgp_fsm): Fix typo.\n\n2000-10-17  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_route.c: \"show ipv6 bgp\" route display improvement.\n\n2000-10-03  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (neighbor_routes): Allocate sockunion for callback\n\tfunction.\n\t(bgp_show_neighbor_route): Remove static declaration for union\n\tsockunion.\n\n\t* bgpd.c (peer_update_source_set): Clean previously allocated\n\tmemory before allocate new one.\n\n2000-10-03  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_route.c (neighbor_routes): Add show neighbor's routes\n\tcommand.\n\t\"show ip bgp neighbors (A.B.C.D|X:X::X:X) routes\"\n\t\"show ip bgp ipv4 (unicast|multicast) neighbors (A.B.C.D|X:X::X:X) routes\"\n\t\"show ipv6 bgp neighbors (A.B.C.D|X:X::X:X) routes\"\n\t\"show ipv6 mbgp neighbors (A.B.C.D|X:X::X:X) routes\"\n\n2000-10-02  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* zebra-0.89 is released.\n\n2000-10-02  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgpd.c: \"bgp deterministic-med\" command is added.\n\n2000-10-02  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_nexthop.c (bgp_connected_add): Apply mask for connected\n\troute addition and deletion.\n\n2000-09-29  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_aspath.c (aspath_cmp_left): Skip confederation AS segment\n\twhen comparing leftmost AS number.\n\n2000-09-29  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgpd.c (peer_route_reflector): Route reflector can be set for\n\tIBGP peer.\n\t(bgp_distribute_set): Fix bug of string check for (in|out).\n\t(bgp_show_summary): Display total neighbor count.\n\n2000-09-28  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_attr.c (bgp_packet_attribute): Only add cluster_list and\n\toriginator for clinet to client routes.\n\t(bgp_packet_attribute): Add new cluster_list to the beginning of\n\texisting cluster_list.\n\t(bgp_packet_attribute): Fix bug of originator is rewritten even\n\twhen originator is already set.\n\n2000-09-27  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c (bgp_client_to_client_reflection): Add new command.\n\t\"no bgp client-to-client reflection\"\n\t\"bgp client-to-client reflection\"\n\n\t* bgpd.h (BGP_CONFIG_NO_CLIENT_TO_CLIENT): Add new definition.\n\n2000-09-26  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_packet.c (bgp_read): Make BGP packet read to non-blocking\n\tread.\n\t(bgp_read_packet): Likewise.\n\t(bgp_read_packet): When errono is EAGAIN, try to read it again.\n\n\t* bgp_fsm.c (bgp_stop): Clear packet size and read buffer.\n\n2000-09-26  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_routemap.c: Configuration of prefix-list match is shown as\n\t\"match ip address prefix-list <WORD>\".  Old configuration \"match\n\tip prefix-list <WORD>\" is left for compatibilitty.\n\n2000-09-25  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgpd.h (BGP_CONFIG_MED_MISSING_AS_WORST): Changed from\n\tBGP_CONFIG_MISSING_AS_WORST.\n\n\t* bgpd.c (bgp_bestpath_med): Change missing-as-worst syntax.\n\tOld \"bgp bestpath missing-as-worst\"\n\tNew \"bgp bestpath med missing-as-worst\"\n\n2000-09-24  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_route.c: Compare MED properly in case of CONFED-IBGP.\n\n2000-09-21  steve@Watt.COM (Steve Watt)\n\n\t* bgp_debug.h: Do not declare debug variables conf_bgp_debug_* and\n\tterm_bgp_debug_*.\n\n\t* bgp_debug.c: Declare variables here.\n\n2000-09-21  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgpd.c: MBGP soft-reconfiguration command is added.\n\tclear ip bgp x.x.x.x ipv4 (unicast|multicast) in\n\tclear ip bgp x.x.x.x ipv4 (unicast|multicast) out\n\tclear ip bgp x.x.x.x ipv4 (unicast|multicast) soft\n\tclear ip bgp <1-65535> ipv4 (unicast|multicast) in\n\tclear ip bgp <1-65535> ipv4 (unicast|multicast) out\n\tclear ip bgp <1-65535> ipv4 (unicast|multicast) soft\n\tclear ip bgp * ipv4 (unicast|multicast) in\n\tclear ip bgp * ipv4 (unicast|multicast) out\n\tclear ip bgp * ipv4 (unicast|multicast) soft\n\n\tChange \"clear ip bgp vpnv4 x.x.x.x soft\" command to\n\t\"clear ip bgp x.x.x.x vpnv4 unicast soft\".\n\n\t\"bgp bestpath med confed\" command is added.\n\t\n\t* bgpd.h (BGP_CONFIG_MED_CONFED): Add New definition.\n\n2000-09-18  Rick Payne <rickp@rossfell.co.uk>\n\n\t* bgpd.c (bgp_show_peer): Fix misplaced #endif.\n\n2000-09-12  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgpd.c (bgp_default_local_preference): Add \"bgp default\n\tlocal-preference\" command.\n\n\t* bgp_nexthop.c (no_bgp_scan_time): Add \"no bgp scan-time\"\n\tcommand.\n\n2000-09-10  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_zebra.c (bgp_zebra_announce): BGP confederation peer's routes\n\tare passed to zebra like IBGP route.\n\n2000-09-10  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgpd.c (bgp_config_write_peer): Make it consistent passive\n\tconfiguration.\n\n\t* bgp_route.c: Community match command is added.\n\t\"show ip bgp community <val>\"\n\t\"show ip bgp community <val> exact-match\"\n\n2000-09-08  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_nexthop.c (bgp_nexthop_lookup): ebgp-multihop routes are\n\ttreated as IBGP routes.\n\n2000-09-08  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_route.c (bgp_show_route): When local-AS community route is\n\tselected, display \"not advertised outside local AS\" to \"show ip\n\troute A.B.C.D\" output.\n\t(show_ip_bgp_ipv4_filter_list): Add below four commands.\n\t\"show ip bgp ipv4 (unicast|multicast) filter-list WORD\"\n\t\"show ip bgp ipv4 (unicast|multicast) community\"\n\t\"show ip bgp ipv4 (unicast|multicast) community-list WORD\"\n\t\"show ip bgp ipv4 (unicast|multicast) community-list WORD exact-match\"\n\t\n\t* bgp_clist.c (community_list_match_exact): Community exact match\n\tfunction.\n\n2000-09-07  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_update): Add peer's ttl check.\n\n\t* bgpd.h (struct peer): Structure member refresh is renamed to\n\trefresh_adv.\n\n\t* bgpd.c (clear_bgp_soft_in): Check PEER_FLAG_ROUTE_REFRESH flag\n\twhen soft reconfiguration is performed.\n\n\t* bgp_zebra.c (bgp_zebra_announce): When the peer is EBGP and\n\tebgp-multiphop is set, set ZEBRA_FLAG_INTERNAL for nexthop lookup.\n\n\t* bgp_route.h (struct bgp_info_tag): Add valid flag.\n\n2000-08-25  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgpd.c: Add AS base BGP soft reconfiguration.\n\n\t* bgp_route.c: When no-advertise or no-export route is selected,\n\t\"show ip bgp\" display \"not advertised to EBGP peer\" or \"not\n\tadvertised to any peer\" message.\n\t\n2000-08-17  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* zebra-0.88 is released.\n\n\t* bgp_dump.c (dump_bgp_routes): Change \"dump bgp routes\" to \"dump\n\tbgp route-mrt\" to support MRT specific dump format.\n\n\t* bgpd.c (bgp_init): \"clear ip bgp vpnv4 soft {in,out}\" command is\n\tadded.\n\n\t* bgp_route.c (bgp_update): Currently nexthop check is only works\n\tfor IPv4.\n\n2000-08-17  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgpd. (clear_ip_bgp_all_soft): Add \"clear ip bgp * soft\" for\n\tboth inbound and outbound soft reconfiguration.\n\n2000-08-17  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c (clear_ip_bgp_peer_soft_out): Add soft-reconfiguration\n\toutbound.\n\t(peer_new): Set route-refresh flag.\n\n2000-08-16  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgpd.c: \"no bgp router-id A.B.C.D\" alias is added.  \"no bgp\n\tcluster-id A.B.C.D\" alias is added.  \" bgp cluster-id\n\t<1-4294967295>\" alias is added.  \"clear ip bgp * soft in\" command\n\tis added.  \"clear ip bgp A.B.C.D in\" alias is added.  \"clear ip\n\tbgp * in\" alias is added.\n\n2000-08-16  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_update): Add soft_reconfig flag.  When the flag\n\tis set do not install the route into Adj-RIBs-In.\n\t(bgp_update): Perform implicit withdraw before filtering of the\n\troute.\n\n\t* bgp_packet.c (bgp_read): draft-ietf-idr-bgp-route-refresh-01.txt\n\tcapability code and BGP message can be accepted.\n\n\t* bgp_open.c (bgp_capability_parse): Likewise.\n\n\t* bgp_route.c (bgp_refresh_table): New function for route refresh.\n\t(bgp_refresh_rib): Likewise.\n\n\t* bgpd.c (bgp_show_peer): Display route refresh status.\n\n\t* bgp_route.c (bgp_aggregate_add): Add check for the route\n\tvalidness.\n\t(bgp_aggregate_delete): Likewise.\n\n2000-08-15  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_nexthop.c (bgp_scan): Care for aggregate route when the\n\troute become inaccessible.\n\n2000-08-15  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_route.c (show_ip_bgp_prefix): \"show ip bgp A.B.C.D/M\"\n\tcommand is added.\n\n2000-08-15  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_zebra.c (bgp_interface_up): Register connected route.\n\t(bgp_interface_down): Unregister connected route.\n\n2000-08-14  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.h (struct bgp_info): Add distance to the structure.\n\n\t* bgp_route.c (bgp_aggregate_increment): Aggregate route only\n\tmatch to smaller prefixlen route not match same prefixlen route.\n\t(bgp_aggregate_decrement): Likewise.\n\t(bgp_aggregate_add): Likewise.\n\t(bgp_aggregate_delete): Likewise.\n\t(bgp_network_backdoor): Add backdoor network configuration.\n\n\t* bgpd.h (struct bgp ): Add distance_{ebgp,ibgp,local} for store\n\tconfiguration distance value.\n\n\t* bgp_route.c (bgp_update): Filter EBGP route which has non\n\tconnected nexthop.\n\n\t* bgp_attr.c (bgp_attr_aggregate_intern): New function for\n\taggregate route.  Set origin to IGP.  Set atomic aggregate flag.\n\tSet aggregator AS and address.\n\t(bgp_attr_aggregate_intern): Check BGP_CONFIG_CONFEDERATION when\n\tfilling aggregator_as.\n\n\t* bgp_route.c (bgp_process): Delete suppress check for install\n\tsuppressed route into local routing table.\n\t(bgp_aggregate_increment): Use bgp_attr_aggregate_intern() instead\n\tof bgp_attr_default_intern ().\n\t(bgp_aggregate_add): Likewise.\n\n\t* bgpd.c (bgp_get): Call bgp_if_update_all() after BGP instance is\n\tcreated.  This is for avoid 0.0.0.0 router-id.\n\n2000-08-13  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_route.c (route_vty_out_detail): Display \"valid\" when the\n\troute is valied.  Display \"aggregated\" when the route is\n\taggregated.  \"Advertisements suppressed by an aggregate\" is\n\tdisplayed when the route is suppressed.\n\t(bgp_info_cmp): Prefer EBGP than Confed-EBGP.\n\n2000-08-10  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_route.c (route_vty_out_detail): Display format change.\n\n2000-08-06  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_update): Only AFI_IP nexthop check is enabled.\n\n\t* bgpd.c (bgp_delete): Delete static route before delete peer\n\tconfiguration.\n\n2000-08-02  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c: Include bgpd/bgp_nexthop.h.\n\n2000-07-31  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgpd.c (bgp_show_summary): \"show ip bgp summary\" shows own BGP\n\tidentifier.  And status is changed like below.\n\n\tState/Pref   -> State/PfxRcd\n\tShutdown     -> Idle (Admin)\n\tPrefixOvflw  -> Idle (PfxCt)\n\n\t* bgp_route.c (route_vty_out): Show internal route as \"i\".\n\n2000-07-13  Jim Bowen <jimb@zereau.net>\n\n\t* bgp_snmp.c: Add BGP peer MIB implementation.\n\n2000-07-12  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgpd.c (bgp_show_peer): Fix typo.\n\n2000-07-11  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_routemap.c: Add commands for deleting set without argument.\n\n2000-07-03  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_zebra.c: Fix redistribute help strings.\n\n2000-07-01  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_show): When bgpd works as vtysh server send all\n\toutput to vty at once.\n\n2000-06-13  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_mplsvpn.c (no_vpnv4_network): \"no network A.B.C.D/M rd WORD\n\ttag WORD\" command is added.\n\n\t* bgp_ecommunity.c (ecommunity_vty_out): New function added.\n\n2000-06-12  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_show): Fix total number of prefix count bug.\n\n\t* bgpd.c (bgp_show_peer): Display VPNv4 unicast configuration and\n\tnegotiation result in \"show ip bgp neighbors\".\n\n2000-06-12  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgpd.c: Fix help strings.\n\t\n\t* bgpd.h: Likewise.\n\t\n2000-06-11  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_aggregate_unset): Fix bug of checking rn->info\n\tinstead of rn.  Reported by Akihiro Mizutani <mizutani@dml.com>.\n\n\t* bgp_mplsvpn.c (vpnv4_network): For testing purpose, \"network\n\tA.B.C.D rd RD\" is added to address-family vpnv4 unicast node.\n\n\t* bgp_route.c (bgp_static_set): Set safi to p.safi.\n\n2000-06-10  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_show_prefix_list): Change to use bgp_show().\n\t(bgp_show_regexp): Change to use bgp_show().\n\t(show_adj_route): Change to display header.\n\n\t* bgpd.c (clear_bgp): Set peer->v_start to default value when peer\n\tis cleared manually.\n\n\t* bgp_route.c (bgp_show_route): New function which display\n\tspecific BGP route.  Divided from bgp_show().\n\t(bgp_static_delete): Delete all static route.\n\n2000-06-09  NOGUCHI Kay <kay@v6.access.co.jp>\n\n\t* bgp_route.c (show_ipv6_bgp): \"show ipv6 bgp\" is broken with\n\tinvalid privious fix.  Now show_ipv6_bgp and show_ipv6_bgp_route\n\ttake care of \"show ipv6 bgp [X:X::X:X]\".  Same change for \"show ip\n\tmbgp\" and \"show ipv6 mbgp\".\n\n2000-06-07  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_route.c: Fix help strings and command arguments.\n\n2000-06-06  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_ecommunity.c: Include prefix.h\n\n2000-06-05  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.h (struct bgp_info_tag): New structure to hold tag\n\tvalue.\n\n\t* bgp_route.c (bgp_adj_set): table NULL check is added.\n\t(bgp_adj_unset): Likewise.\n\t(bgp_adj_lookup): Likewise.\n\t(bgp_adj_clear): Likewise.\n\t(route_vty_out): Add SAFI check for nexthop display.\n\t(bgp_withdraw): Add SAFI check for withdraw route.\n\n\t* Remove all #ifdef MPLS_VPN then include it as default.\n\n\t* bgpd.c: Temporary disable peer-group command until the\n\timplementation is completed.\n\n\t* bgp_routemap.c (bgp_route_map_init): Install\n\troute_metric_match_cmd.\n\t(route_match_metric_compile): MED value compile using strtoul.\n\n2000-06-05  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_filter.c: Fix help strings.  Change REGEXP to LINE.  Change\n\tNAME to WORD.\n\n\t* Change command argument to more comprehensive.\n\n\tMETRIC         -> <0-4294967295>\n\tWEIGHT         -> <0-4294967295>\n\tLOCAL_PREF     -> <0-4294967295>\n\tIP_ADDR        -> A.B.C.D\n\tAS             -> <1-65535>\n\tAS-PATH-NAME   -> WORD\n\tACCESS_LIST    -> WORD\n\tPREFIX_LIST    -> WORD\n\tCOMMUNITY      -> AA:NN\n\tEXT_COMMUNITY  -> ASN:nn_or_IP-address:nn\n\tIPv6_ADDR      -> X:X::X:X\n\n\t* bgp_clist.c: Fix help strings.\n\n2000-06-03  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c (peer_active): Add new function for check the peer is\n\tactive or not.\n\t(neighbor_activate): New command \"neighbor PEER activate\" and \"no\n\tneighbor PEER activate\" are added.\n\n\t* bgp_packet.c: Include bgpd/bgp_mplsvpn.h.\n\n2000-06-02  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_clist.c: Fix commuity-list help strings.\n\n\t* bgp_routemap.c: Fix \"set community\" help strings.  Add #define\n\tSET_STR.  Use (unicast|multicast) argument for \"set nlri\" command.\n\t\n2000-06-01  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_routemap.c (route_set_community_none_cmd): \"set community\n\tnone\" command is added to route-map.\n\n2000-06-01  Akihiro Mizutani <mizutani@dml.com>\n\n\t* bgp_debug.c: Change \"show debug\" to \"show debugging\".  Now \"show\n\tdebugging\" is not used in VIEW_NODE.\n\n2000-05-30  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_fsm.c (bgp_timer_set): Add check for shutdown flag.  This\n\tfix unconditional BGP connection.\n\n\t* bgpd.c (peer_shutdown): Replace peer_shutdown() with\n\tpeer_change_flag_with_reset().\n\n2000-05-26  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c (no_bgp_default_ipv4_unicast): Add \"no bgp default\n\tipv4-unicast\" command.\n\n\t* bgpd.h (BGP_CONFIG_NO_DEFAULT_IPV4): Add new definition.\n\n\t* bgp_filter.c (as_list_delete): Free all AS filter.\n\n\t* bgp_clist.c (community_list_delete): Free all community entry.\n\n\t* bgp_filter.c (no_ip_as_path_all): New DEFUN for \"no ip as-path\n\taccess-list NAME\".\n\n\t* bgp_clist.c (no_ip_community_list_all): New DEFUN for \"no ip\n\tcommunity-list NAME\".\n\n2000-05-19  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (ipv6_mbgp_neighbor_routes): Change \"show ip bgp PEER\n\troutes\" to \"show ip bgp PEER received-routes\"\n\n2000-05-14  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_ecommunity.c (ecommunity_parse): New file for Extended\n\tCommunities attribute.\n\t* bgp_ecommunity.h: Likewise.\n\n2000-05-11  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_mplsvpn.h: New file for MPLS-VPN.\n\t* bgp_mplsvpn.c: Likewise.\n\n\t* bgpd.c (bgp_delete): Fix bug of \"no router bgp\" crush.\n\n2000-05-10  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c (bgp_bestpath_missing_as_worst): Add \"bgp bestpath\n\tmissing-as-worst\".\n\n2000-05-08  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_routemap.c (match_community): Clarify help of \"match\n\tcommunity\".\n\n2000-05-02  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_aspath.c (aspath_cmp_left): Remove debug code.\n\n2000-04-27  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_info_cmp): Compare MED only both routes comes\n\tfrom same neighboring AS.\n\n\t* bgp_aspath.c (aspath_cmp_left): Compare leftmost AS value.\n\n\t* bgp_route.c (bgp_info_cmp): Fix misused htonl() to ntohl().\n\n2000-04-26  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_output_filter): When distribute-list's\n\tcorresponding access-list does not exist, filter all routes.\n\t(bgp_input_filter): Likewise.\n\n2000-04-19  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_attr.c (bgp_packet_attribute): Propagate MED to IBGP peer.\n\n\t* bgp_route.c (bgp_info_cmp): Add evaluation of local preference.\n\n2000-04-18  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c (bgp_distribute_update): Add struct access_list *\n\targument.\n\n2000-04-17  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_clist.c (community_list_dup_check): Add duplicate insertion\n\tcheck.\n\n\t* bgp_filter.c (as_list_dup_check): Add duplicate insertion check.\n\n\t* bgp_route.c (bgp_show): Fix undeclared write variable.\n\n2000-04-13  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_routemap.c: Add \"match ip address prefix-list\".\n\n2000-03-29  Rick Payne <rickp@rossfell.co.uk>\n\n\t* bgp_aspath.c (aspath_strip_confed): Fix realloc problem.\n\n2000-03-16  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_fsm.c (bgp_reconnect): Connect retry timer is expired when\n\tthe peer status is Connect.\n\n2000-03-03  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* Fix bug of rewritten originator-id.\n\n2000-01-27  Rick Payne <rickp@rossfell.co.uk>\n\n\t* bgp_aspath.c (aspath_delimiter_char): New function.  Instead of\n\tdirectly referencing array, search proper AS path delimiter.\n\t(aspath_strip_confed): Strip the confederation stuff from the\n\tfront of an AS path.\n\t(aspath_add_left_confed): New function for adding specified AS to\n\tthe leftmost AS_CONFED_SEQUENCE.\n\n\t* bgp_aspath.h: Change AS_CONFED_SEQUENCE and AS_CONFED_SET value\n\tto Cisco compatible.\n\n\t* bgpd.c (bgp_confederation_id_set): Confederation configuration.\n\t(bgp_confederation_id_unset): Likewise.\n\t(bgp_confederation_peers_check): Likewise.\n\t(bgp_confederation_peers_add): Likewise.\n\t(bgp_confederation_peers_remove): Likewise.\n\t(bgp_confederation_peers_set): Likewise.\n\t(bgp_confederation_peers_unset): Likewise.\n\t(bgp_confederation_peers_print): Likewise.\n\t\n2000-01-16  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c: Introduce peer_change_flag_with_reset() fucntion.\n\n2000-01-17  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_open.c (bgp_open_option_parse): When there is no common\n\tcapability send Unsupported Capability error to the peer.\n\n2000-01-14  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_open.c (bgp_capability_mp): Fix bug of mis-negotiation about\n\tIPv6 unicast.\n\n\t* bgpd.c (bgp_init): Add \"soft-reconfiguration inbound\" command.\n\t\n2000-01-12  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c (neighbor_strict_capability): Add\n\t\"strict-capability-match\" command.\n\n\t* bgp_zebra.c (bgp_if_update): Ignore NET127 determining\n\trouter-id.\n\n\t* bgpd.c (peer_override_capability): Add \"override-capability\"\n\tcommand.\n\n1999-12-16  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_packet.c (bgp_write): Change status to Idle and set timer\n\tafter write failed.\n\n1999-12-14  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_zebra.c (bgp_zebra_announce): Add info->selected check.\n\n1999-12-12  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (nlri_unfeasible): nlri_unfeasible() is merged with\n\tnlri_parse().\n\n1999-12-10  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_fsm.h (BGP_EVENT_DELETE): Macro added.\n\n\t* bgp_fsm.c (bgp_stop): Clear all event threads of the peer when\n\tthe peer is cleared.\n\n\t* bgp_zebra.c (bgp_nexthop_set): Clear interface index of\n\tlink-local address.  This is KAME specific problem.\n\n1999-12-06  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_attr.c (bgp_mp_reach_parse): Comment out previous code for a\n\twhile.  We don't completely detect the link is shared or not at\n\tthis moment.\n\n\t* bgp_packet.c (bgp_notify_send): Make shortcut call of\n\tbgp_write() and bgp_stop().\n\n\t* bgp_attr.c (bgp_mp_reach_parse): Fix serious bug when getting\n\tglobal and link-local address.\n\n1999-12-05  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c (no_neighbor_port): New command added.\n\t(peer_new): Set send_community.\n\n1999-12-04  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c (show_ip_bgp_summary): Changed to use bgp_show_summary().\n\t(show_ip_mbgp_summary): Likewise.\n\t(show_ipv6_bgp_summary): Likewise.\n\t(show_ipv6_mbgp_summary): Add new command.\n\t(peer_free): Free peer->host.\n\t(peer_lookup_by_su): Delete function.\n\t(ipv6_bgp_neighbor): Changed to use peer_remote_as().\n\t(sockunion_vty_out): Function deleted.\n\t(vty_clear_bgp): Use afi instead of family.\n\tDelete old list bgp_list.  Use struct newlist *bgplist.\n\t(peer_lookup_by_host): Function deleted.\n\n1999-12-03  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.h (struct peer_group): New structure added.\n\t(struct peer_conf): New structure added.\n\t(struct\tpeer): Change all prefix_count to unsigned long.\n\t\n\t* bgpd.c: Reconstruct all of VTY commands reflect internal\n\tstructure change.\n\tUse bgplist instead of bgp_list.\n\tUse peerlist intstead of peer_list.\n\n\t* bgp_attr.c (bgp_mp_reach_parse): If nlri_parse return -1, stop\n\tparsing then return immediately.\n\n\t* bgp_route.c (nlri_parse): When NLRI parse error occured, return\n\t-1.\n\t(nlri_process): Use pcount_v4_{unicast,multicast}.\n\t(nlri_delete): Likewise.\n\n1999-11-25  Robert Olsson <Robert.Olsson@data.slu.se>\n\n\t* bgp_routemap.c (route_match_nlri): `match nlri\n\tunicast|multicast' and `set nlri unicast|multicast' command are\n\tadded.\n\n1999-11-22  Robert Olsson <Robert.Olsson@data.slu.se>\n\n\t* bgpd.c: Add translate-update support.\n\n\t* bgpd.h (TRANSLATE_UPDATE_OFF): Add translate-update definition.\n\n1999-11-19  Robert.Olsson@data.slu.se\n\n\t* bgp_route.c (bgp_peer_delete): Add MBGP peer clear codes.\n\n1999-11-14  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_open.c (bgp_capability_mp): Temporary comment out\n\tSAFI_UNICAST_MULTICAST handling until we know the meanings.\n\n1999-11-13  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_btoa.c: New file added.\n\n1999-11-12  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.h (struct peer): Add dont_capability flag.\n\t(struct peer): Add override_capability flag.\n\n\t* bgpd.c (neighbor_dont_capability_negotiation): `neighbor PEER\n\tdont-capability-negotiation' added.\n\n1999-11-12  Bill Sommerfeld <sommerfeld@orchard.arlington.ma.us>\n\n\t* bgp_attr.c (bgp_mp_reach_parse): Ignore link-local addresses\n\tattribute from non-shared-network peers.\n\n1999-11-10  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_snmp.c: New file added.\n\n\t* BGP4-MIB.txt: Updated to the latest Internet-Draft\n\tdraft-ietf-idr-bgp4-mib-04.txt.\n\n1999-11-09  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_route_init): Add `show ipv6 bgp prefix-list'.\n\n\t* bgp_attr.c (bgp_mp_unreach_parse): Enclose safi setup with\n\t#ifdef HAVE_MBGPV4.\n\n1999-11-08  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_dump.c (no_dump_bgp_all): Add [PATH] and [INTERVAL] to no\n\tdump bgp commands.\n\t(config_write_bgp_dump): Write interval value to the\n\tconfiguration.\n\n1999-11-07  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_zebra.c: Redistribute route-map support is added.\n\n\t* bgp_zebra.h: New file added.\n\n1999-11-04  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_dump.c: BGP packet dump routine compatible with MRT.\n\t* bgp_dump.h: BGP packet dump routine compatible with MRT.\n\n\t* bgp_debug.c: Renamed from bgp_dump.c\n\t* bgp_debug.h: Renamed from bgp_dump.h\n\n1999-10-27  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* BGP4-MIB.txt: New file added.  Edited version of RFC1657.\n\n1999-10-25  Bill Sommerfeld <sommerfeld@orchard.arlington.ma.us>\n\n\t* bgp_route.c (bgp_announce): If we're not on a shared network\n\twith the peer and we don't have a link-local next hop, but the\n\tinbound next-hop has a link-local address, don't readvertise it to\n\tour peer.\n\n1999-10-25  Marc Boucher <marc@mbsi.ca>\n\n\t* bgp_zebra.c: Add redistribute kernel command.\n\n1999-10-25  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_reset): New function added.\n\n\t* bgpd.conf.sample2: Add IPv6 configuration sample.\n\n1999-10-24  Bill Sommerfeld <sommerfeld@orchard.arlington.ma.us>\n\n\t* bgp_route.c (ipv6_aggregate_address): Function added.\n\n1999-10-21  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_packet.c (bgp_update): Unintern aspath, community, cluster\n\tlist after parsing BGP update packet.\n\n\t* bgp_attr.c (bgp_attr_aspath): Intern parsed aspath.\n\t(bgp_attr_community): Intern parsed community.\n\t(bgp_attr_cluster_list): Intern parsed cluster list.\n\n\t* bgp_routemap.c: Add `set community-additive' command.\n\n1999-10-21  Alexandr D. Kanevskiy <kad@blackcatlinux.com>\n\n\t* bgp_routemap.c (route_set_local_pref): Fix bug of setting\n\tattribute flag.\n\n1999-10-21  Bill Sommerfeld <sommerfeld@orchard.arlington.ma.us>\n\n\t* bgp_route.c (bgp_announce): Add check of IPv6 default route\n\tannouncement.\n\n\t* bgp_packet.c (bgp_update_send): Add BGP announcement logging.\n\n1999-10-15  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* `show ip[v6] bgp PREFIX' show uptime of the route.\n\n1999-10-04  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c (bgp_filter_set): Delete PEER_FAMILY_{IPV4,IPV6}. instead\n\tof that use AF_INET and AF_INET6 directly.\n\t(vty_clear_bgp): Add new function to support various clear ip bgp\n\tmethod.\n\n1999-10-04  Lars Fenneberg <lf@elemental.net>\n\n\t* bgpd.c (clear_ip_bgp): Add `clear ip bgp ASN'.\n\n1999-10-03  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_routemap.c: Add `match ip prefix-list' and `match ipv6\n\tprefix-list'.\n\n1999-09-28  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c (bgp_collision_detect): Add BGP collision detection\n\tfunction.\n\n1999-09-26  Blake Meike <bmeike@adero.com>\n\n\t* bgpd.c (neighbor_port): New command `neighbor PEER port PORT' is\n\tadded.\n\n1999-08-24  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c (no_neighbor_timers_keepalive): Change MIN to min.  Add\n\tmin() macro.\n\n1999-08-19  Rick Payne <rickp@rossfell.co.uk>\n\n\t* bgp_packet.c (bgp_open): BGP holdtimer bug is fixed.  Make BGP\n\tkeepalive timer configurable.\n\n1999-08-15  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_zebra.c (bgp_redistribute_set): Fix redistribute bug.\n\n1999-08-13  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c (bgp_peer_display): show ip bgp neighbors PEER only list\n\tthe peer not all of them.\n\n1999-08-11  Rick Payne <rickp@rossfell.co.uk>\n\n\t* bgp_route.c (bgp_announce): Remove MED if its an EBGP peer -\n\twill get overwritten by route-maps.\n\n1999-08-08  Rick Payne <rickp@rossfell.co.uk>\n\n\t* bgp_routemap.c: Multi protocol route-map modification.\n\n1999-08-01  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c: Set network statement route's origin attribute as\n\tigp.\n\n\t* bgp_zebra.c: Set redistribute route's origin attribute as\n\tincomplete.\n\n\t* bgp_route.c (bgp_info_cmp): Add attribute existance check,\n\torigin attribute check, BGP peer type check.\n\n1999-07-30  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_peer_delete): Reselect of IPv6 route.\n\n1999-07-29  Rick Payne <rickp@rossfell.co.uk>\n\n\t* Changed route-maps to behave in a more cisco-like fashion\n\n1999-07-27  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_fsm.c (bgp_stop): Very serious bug of bgp_stop () is fixed.\n\tWhen multiple route to the same destination exist, bgpd try to\n\tannounce the information to stopped peer.  Then add orphan write\n\tthread is added.  This cause many strange behavior of bgpd.\n\tReported by Georg Hitsch <georg@atnet.at>.\n\n1999-07-23  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c: Change peer's A.B.C.D to PEER.\n\n1999-07-22  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_announce): Add hack for link-local nexthop.\n\n\t* bgp_zebra.c (bgp_zebra_announce): Fill in nexthop address from\n\tlocal address.\n\n1999-07-21  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_packet.c (bgp_open): Holdtime fetch bug is fixed.  Reported\n\tby Yuji SEKIYA <sekiya@sfc.wide.ad.jp>.\n\n1999-07-15  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_fsm.c (fsm_holdtime): Don't close file descriptor in\n\tfsm_holdtime ().\n\n1999-07-11  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_routemap.c: Add `set atomic-aggregate' command.\n\n1999-07-06  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_routemap.c (route_set_ip_nexthop_cmd): Change \"ip nexthop\"\n\tto \"ip next-hop\".\n\t\n1999-07-02  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (show_ipv6_bgp_regexp): `show ipv6 bgp regexp'\n\tadded.\n\n1999-07-01  Rick Payne <rickp@rossfell.co.uk>\n\n\t* bgp_zebra.c (zebra_init): Install standard commands to\n\tZEBRA_NODE.\n\n1999-06-28  Rick Payne <rickp@rossfell.co.uk>\n\n\t* bgpd.c (bgp_delete): bgp peer deletion bug is fixed.\n\n1999-06-25  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c: Add neighbor update-source command as ALIAS to\n\tneighbor_interface.\n\n1999-06-19  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_attr.c (bgp_packet_attribute): Send community attribute when\n\tsend_community flag is set.\n\n\t* bgpd.h (struct peer): Add send_community flag.\n\n1999-06-12  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c (router_bgp): router bgp's argument changed from AS_NO to\n\t<1-65535>.\n\n1999-06-08  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.h (struct bgp_info): Add subtype for BGP route type.\n\n1999-06-07  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_community.c (community_merge): Function added.\n\n1999-06-04  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_clist.c: New file.\n\t* bgp_clist.h: New file.\n\n\t* bgp_community.h (COMMUNITY_LOCAL_AS): Added for Cisco\n\tcompatibility.\n\t(COMMUNITY_NO_ADVERTISE): Fix typo.\n\n1999-05-30  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_routemap.c: Add `set weight WEIGHT' command.\n\n\t* bgpd.c: Remove all_digit_check function.  Instead of that use\n\tall_digit function in lib/prefix.c.\n\n\t* bgp_routemap.c (bgp_route_map_init): Install\n\tno_set_ipv6_nexthop_global_cmd and no_set_ipv6_nexthop_local_cmd\n\telement to the RMAP_NODE.\n\n1999-05-28  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_aspath.c (aspath_make_str): Declare aspath_delimiter_char\n\tinside aspath_make_str function.\n\t(aspath_prepend): New function is added for AS path prepend.\n\t(aspath_make_str_count): Renamed from aspath_make_str.  AS path\n\tcount is set to the structure.\n\t(aspath_merge): New function.\n\n1999-05-22  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_zebra.c (redistribute_bgp): Add new DEFUN.\n\t(no_redistribute_bgp): Likewise.\n\t(router_zebra): Semantics changed.  Now 'router zebra' is default\n\tbehavior of bgpd.\n\n1999-05-14  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_routemap.c: Add some commands to bgp route-map.\n\tmatch ip next-hop: New command.\n\tmatch metric: New command.\n\tset metric: Doc fix.\n\tset local-preference: Add DEFUN.\n\n1999-05-14  Stephen R. van den Berg <srb@cuci.nl>\n\n\t* bgp_main.c (signal_init): SIGTERM call sigint.\n\t(sigint): Loggging more better message.\n\n1999-05-12  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_attr.c (bgp_packet_attribute): AS path attribute extended\n\tlength bit check is added.\n\n1999-05-11  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_routemap.c (bgp_route_map_init): Call route_map_install_set\n\tfunction with route_set_local_pref_cmd argument.\n\t(no_match_aspath): Function added.\n\t(route_set_metric): Set attribute flag bit.\n\n\t* bgp_attr.c (bgp_packet_attribute): MULTI_EXIT_DISC is now in BGP\n\tpacket.\n\n1999-05-07  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c (no_neighbor_timers_holdtime): `no neighbor PEER timers\n\tholdtime' command is added.\n\n\t* bgpd.h (BGP_DEFAULT_HOLDTIME_BIG): Delete define.\n\n\t* bgpd.c (bgp_prefix_list_set): New function added.\n\t(bgp_prefix_list_unset): Likewise.\n\t(bgp_prefix_list_update): Likewise.\n\t(show_ip_bgp_neighbors): prefix-list information display.\n\n1999-05-06  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c (bgp_delete): Function added for `no router bgp'.\n\n1999-05-05  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_dump.c (bgp_dump_attr): Add originator_id display.\n\n\t* bgpd.c (bgp_router_id): Even when address is malformed set the\n\tvalue to configuration bug fixed.\n\t(no_bgp_router_id): New function.\n\t(no_bgp_cluster_id): New function.\n\n1999-05-04  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.h (BGP_ATTR_ORIGINATOR_ID): Changed from BGP_ATTR_ORIGINATOR.\n\n1999-05-02  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (bgp_announce): Add route reflector check.\n\n1999-05-01  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c (bgp_cluster_id): Add function for route reflector.\n\t(neighbor_route_reflector_client): Likewise.\n\t(no_neighbor_route_reflector_client): Likewise.\n\n\t* bgpd.h (struct bgp ): Add cluster for route reflector.\n\n\t* bgp_route.c (show_ip_bgp_prefix_list): New command is added.\n\n1999-04-24  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* Makefile.am (noinst_HEADERS): Add bgp_filter.h\n\n\t* bgp_aspath.c (aspath_undup): Function deleted.  aspath_free ()\n\thas same functionality.\n\n\t* bgp_filter.h: New file.\n\n\t* bgp_aspath.c (aspath_unintern): Rename aspath_free () to\n\taspath_unintern ()\n\t(aspath_free): New function.\n\n1999-04-23  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_aspath.c (aspath_aggregate): Function added.\n\n\t* bgp_aspath.h (aspath_aggregate): Prototype added.\n\n\t* bgp_aspath.c (aspath_empty_aspath): New argument\n\tgated_dont_eat_flag is added.\n\n1999-04-18  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c: Add bgp_aggregate_ipv4 and bgp_aggregate_ipv6.\n\n1999-04-17  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c (aggregate_address): Function added.\n\n\t* bgp_zebra.c (zebra_read): Change log to zlog.\n\n1999-04-15  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* Makefile.am (noninst_HEADERS): Added for make dist.\n\n1999-04-09  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* aspath_regex.c: Removed from distribution.\n\n1999-04-07  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_attr.c (bgp_packet_attribute): Old draft-00 packet treatment\n\tbug fixed.\n\n1999-04-06  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_aspath.c (aspath_add_left): Fix empty aspath bug.  Reported\n\tby kad@gibson.skif.net.\n\n\t* bgp_regex.[ch]: New file added.\n\n\t\n1999-04-05  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_filter.c: New file added.\n\n1999-04-01  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_aspath.c (aspath_empty_aspath): Change for peering with\n\tgated.\n\n1999-03-24  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_main.c (main): Default loggin method changed from syslog to\n\tstdout.\n\n1999-03-05  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c: Delete obsolete default attribute DEFUN.\n\n1999-03-04  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_attr.c: Make attribute structure put into attribute hash.\n\n1999-03-02  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_view.c : Delete file.\n\n1999-02-25  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_routemap.c (bgp_apply_route_map): Add prefix argument. \n\n\t* bgp_route.h (struct bgp_info): Add bgp_info structre.  I'll\n\treplace bgp_route with this.\n\n\t* bgp_routemap.c (route_match_ip_address): Fix bug of passing non\n\tprefix value to access_list_apply(). \n\n\t* bgpd.conf.sample: Add route-map sample.\n\tDelete obsolete default-attr statements.\n\n\t* bgp_packet.c: Use stream_fifo for packet queueing.\n\n1999-02-24  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_aspath.c (aspath_add_left): add non empty aspath treatment.\n\n\t* bgp_main.c: include unistd.h for daemon().\n\n\t* bgp_route.c (nlri_process): add IPv6 table lookup.\n\n\t* bgp_attr.c (route_parse_ipv6): call nlri_process().\n\t(attr_make): Obsolete function attr_make deleted.\n\n1999-02-22  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_aspath.c (aspath_add_left): change function name from\n\taspath_add_leftmost_as().\n\n1999-02-21  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_aspath.c: add aspath_add_leftmost_as ().\n\n1999-02-18  Peter Galbavy  <Peter.Galbavy@knowledge.com>\n\n\t* syslog support added\n\n1999-01-26  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c: DEFUN (neighbor_nexthop): deleted.\n\tDEFUN (neighbor_distribute_list): added.\n\n1999-01-19  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.h (struct peer ): header_buf and read_buf is removed.\n\n\t* bgp_peer.[ch]: Deleted.  Peer related functions are merged to\n\tbgpd.c\n\n\t* bgp_network.c: New file.\n\t* bgp_network.h: New file.\n\n\t* bgp_packet.h: New file.\n\t\n1999-01-11  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_packet.c (bgp_keepalive_send): Now BGP keepalive packet is\n\tbuffered.\n\n1999-01-08  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_packet.c: New file.\n\n1998-12-22  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_zebra.c (zebra_client): Use zebra_connect() in lib/client.c. \n\n\t* `show ip bgp' bug fixed.\n\t* aspath_log (): Remove argument logfp.\n\n1998-12-15  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_fsm.h: New file.\n\n1998-12-15  Magnus Ahltorp <map@stacken.kth.se>\n\n\t* bgp_attr.c, bgp_community.h, bgp_dump.c, bgp_fsm.c, bgp_open.c\n\tbgp_peer.c, bgp_peer.h, bgp_route.c, bgp_route.h, bgp_view.c\n\tbgpd.c, bgpd.h, bgp_attr.c, bgp_community.h, bgp_dump.c,\n\tbgp_fsm.c, bgp_open.c, bgp_peer.c, bgp_peer.h: Prototype fixes.\n\n1998-12-09  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c (bgp_config_write): Delete vector v argument.\n\n1998-12-07  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.h: Delete annoying ld_[124]byte and st_[124]byte macros.\n\n1998-11-23  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_radix.[ch]: removed.\n\n1998-09-15  HEO SeonMeyong  <seirios@matrix.iri.co.jp>\n\n\t* bgp_main.c: ifdef HYDRANGEA -> ifdef KAME\n\n1998-08-13  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_dump.c: delete nroute().\n\n1998-05-19  Yamshita TAKAO  <jargon@lares.dti.ne.jp>\n\n\t* bgp_aspath.c: HAVE_CONFIG_H typo :-)\n\t* bgpd.h: Modify for compile on Solaris.\n\t* bgp_aspath.h: likewize\n\t* bgp_community.h: likewize\n\t* bgp_routemap.c: likewize\n\n1998-05-18  Yamshita TAKAO  <jargon@lares.dti.ne.jp>\n\n\t* bgpd.h: Modify for compile on Solaris.\n\t* bgp_aspath.h: likewize\n\n1998-05-08  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* routemap.[ch]: move to ../lib directory.\n\n1998-05-07  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* routemap.c (route_map_apply): add function.\n\n1998-05-06  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* routemap.h: add file.\n\n\t* bgp_peer.h (enum ): change PEER_{IBGP,EBGP} to BGP_PEER_{IBGP,EBGP}\n\n1998-05-03  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* Makefile.am: sysconfdir_DATA added.\n\n1998-05-02  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_dump.c: add `debug bgp fsm'\n\t\t      add `no debug bgp fsm'\n\t\t      add `show debug bgp'\n\t* bgp_open.c: File added.\n\n1998-05-01  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* .cvsignore: File added.\n\n1998-04-30  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_community.[ch]: File added.\n\n1998-03-04  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd now use lib/thread.[ch].\n\n1998-01-06  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.c (show_ip_bgp_neighbors): add 'show ip bgp neighbors' command.\n\n\t* bgpd.h (BGP_DEFAULT_START_TIMER): change from 1 to 30.\n\n1997-12-30  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_vty.c: bgp_vty.c deleted.\n\n\t* bgpd.c (config_write_neighbor): add ebgp-multihop command.\n\n1997-12-29  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_fsm.c: [-p bgp_port] and [-P vty_port] works\n\n1997-12-06  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_vty.c: new file.\n\n\t* bgp_attr.c: add new logging system.\n\n1997-11-23  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* Change all inet_addr call into inet_aton.\n\n1997-11-10  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_radix.c: change radix_peer_delete\n\n1997-10-04  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_aspath.c: move AS_TOKEN_??? definition from header to c source.\n\n1997-09-12  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_dump.c (bgp_log_route): add dump_attr function\n\n1997-09-06  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_aspath.c (aspath_test): change AS_SET brace from '[' to '{'\n\t* bgp_dump.c (bgp_log_route): change logfile format.\n\n1997-08-19  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_open.c (bgp_open): move bgp_open function from bgpd.c\n\t* bgp_attr.c (community_str2com): add community value generation\n\t* bgp_attr.h: add SAFI definition for BGP-4+\n\n1997-08-18  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgpd.h: add BGP_OPEN_OPT_CAP for Capabilities Optional Parameter\n\t* Makefile.in: add bgp_open.o, delete bgp_loop.o\n\t* bgp_open.c: newfile which manages BGP Open message\n\t* bgp_loop.c: this file is merged with bgp_fsm.c\n\t* bgp_radix.c (radix_add): radix_add() now return route_t instead\n\tof int\n\t(bgp_sim): now we can read update & withdraw from file\n\t* bgp_route.c: add route_free() call into route_parse etc.\n\n1997-08-17  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_radix.c: Radix code is completely rewritten. It has better\n\tmemory treatment than old one.\n\n1997-08-14  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_route.c: route_alloc for route struct allocation statistics.\n\t* bgpd.c (bgp_make_update): now we cann announce MED attribute.\n\t* bgp_aspath.c (aspath_print_all): change aspath_print_all output\n\tformat.\n\n1997-08-13  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_term.c (term_parse): add command : show asstat, show ashash\n\t* bgp_aspath.c: aspath_cmp bug fix\n\t(aspath_print_all): add aspath_print_all ();\n\t* bgp_peer.h: delete rlist element from struct peer.\n\n1997-08-12  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_aspath.c: completely rewritten.\n\t* bgp_aspath.h: completely rewritten.\n\tadd AsPath, AsSegment structure\n\tadd AS_SET treatment\n\tchange Hash codes\n\n1997-08-09  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_attr.h: add Attribute flags defines\n\t* bgp_route.c: delete rlist related functions\n\t* bgp_aspath.c (as_origin): add as_origin function\n\t(aspath_print): move from bgp_dump.c and add support of AS_SET\n\tchange Hash related function names.\n\n1997-08-08  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_aspath.h: add next entry, delete rlist entry from struct aspath\n\n1997-08-04  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* bgp_aspath.c (as_sort): add function as_sort\n\t* bgp_aspath.h: add IBGP, EBGP\n\n", "/* BGP message debug header.\n   Copyright (C) 1996, 97, 98 Kunihiro Ishiguro\n\nThis file is part of GNU Zebra.\n\nGNU Zebra is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the\nFree Software Foundation; either version 2, or (at your option) any\nlater version.\n\nGNU Zebra is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GNU Zebra; see the file COPYING.  If not, write to the Free\nSoftware Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef _QUAGGA_BGP_DEBUG_H\n#define _QUAGGA_BGP_DEBUG_H\n\n/* sort of packet direction */\n#define DUMP_ON        1\n#define DUMP_SEND      2\n#define DUMP_RECV      4\n\n/* for dump_update */\n#define DUMP_WITHDRAW  8\n#define DUMP_NLRI     16\n\n/* dump detail */\n#define DUMP_DETAIL   32\n\nextern int dump_open;\nextern int dump_update;\nextern int dump_keepalive;\nextern int dump_notify;\n\nextern int Debug_Event;\nextern int Debug_Keepalive;\nextern int Debug_Update;\nextern int Debug_Radix;\n\n#define\tNLRI\t 1\n#define\tWITHDRAW 2\n#define\tNO_OPT\t 3\n#define\tSEND\t 4\n#define\tRECV\t 5\n#define\tDETAIL\t 6\n\n/* Prototypes. */\nextern void bgp_debug_init (void);\nextern void bgp_packet_dump (struct stream *);\n\nextern int debug (unsigned int option);\n\nextern unsigned long conf_bgp_debug_fsm;\nextern unsigned long conf_bgp_debug_events;\nextern unsigned long conf_bgp_debug_packet;\nextern unsigned long conf_bgp_debug_filter;\nextern unsigned long conf_bgp_debug_keepalive;\nextern unsigned long conf_bgp_debug_update;\nextern unsigned long conf_bgp_debug_normal;\nextern unsigned long conf_bgp_debug_zebra;\n\nextern unsigned long term_bgp_debug_fsm;\nextern unsigned long term_bgp_debug_events;\nextern unsigned long term_bgp_debug_packet;\nextern unsigned long term_bgp_debug_filter;\nextern unsigned long term_bgp_debug_keepalive;\nextern unsigned long term_bgp_debug_update;\nextern unsigned long term_bgp_debug_normal;\nextern unsigned long term_bgp_debug_zebra;\n\n#define BGP_DEBUG_FSM                 0x01\n#define BGP_DEBUG_EVENTS              0x01\n#define BGP_DEBUG_PACKET              0x01\n#define BGP_DEBUG_FILTER              0x01\n#define BGP_DEBUG_KEEPALIVE           0x01\n#define BGP_DEBUG_UPDATE_IN           0x01\n#define BGP_DEBUG_UPDATE_OUT          0x02\n#define BGP_DEBUG_NORMAL              0x01\n#define BGP_DEBUG_ZEBRA               0x01\n\n#define BGP_DEBUG_PACKET_SEND         0x01\n#define BGP_DEBUG_PACKET_SEND_DETAIL  0x02\n\n#define BGP_DEBUG_PACKET_RECV         0x01\n#define BGP_DEBUG_PACKET_RECV_DETAIL  0x02\n\n#define CONF_DEBUG_ON(a, b)\t(conf_bgp_debug_ ## a |= (BGP_DEBUG_ ## b))\n#define CONF_DEBUG_OFF(a, b)\t(conf_bgp_debug_ ## a &= ~(BGP_DEBUG_ ## b))\n\n#define TERM_DEBUG_ON(a, b)\t(term_bgp_debug_ ## a |= (BGP_DEBUG_ ## b))\n#define TERM_DEBUG_OFF(a, b)\t(term_bgp_debug_ ## a &= ~(BGP_DEBUG_ ## b))\n\n#define DEBUG_ON(a, b) \\\n    do { \\\n\tCONF_DEBUG_ON(a, b); \\\n\tTERM_DEBUG_ON(a, b); \\\n    } while (0)\n#define DEBUG_OFF(a, b) \\\n    do { \\\n\tCONF_DEBUG_OFF(a, b); \\\n\tTERM_DEBUG_OFF(a, b); \\\n    } while (0)\n\n#define BGP_DEBUG(a, b)\t\t(term_bgp_debug_ ## a & BGP_DEBUG_ ## b)\n#define CONF_BGP_DEBUG(a, b)    (conf_bgp_debug_ ## a & BGP_DEBUG_ ## b)\n\nextern const char *bgp_type_str[];\n\nextern int bgp_dump_attr (struct peer *, struct attr *, char *, size_t);\nextern void bgp_notify_print (struct peer *, struct bgp_notify *, const char *);\n\nextern struct message bgp_status_msg[];\nextern int bgp_status_msg_max;\n\n#endif /* _QUAGGA_BGP_DEBUG_H */\n", "/* BGP open message handling\n   Copyright (C) 1998, 1999 Kunihiro Ishiguro\n\nThis file is part of GNU Zebra.\n\nGNU Zebra is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the\nFree Software Foundation; either version 2, or (at your option) any\nlater version.\n\nGNU Zebra is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GNU Zebra; see the file COPYING.  If not, write to the Free\nSoftware Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#include <zebra.h>\n\n#include \"linklist.h\"\n#include \"prefix.h\"\n#include \"stream.h\"\n#include \"thread.h\"\n#include \"log.h\"\n#include \"command.h\"\n#include \"memory.h\"\n\n#include \"bgpd/bgpd.h\"\n#include \"bgpd/bgp_attr.h\"\n#include \"bgpd/bgp_debug.h\"\n#include \"bgpd/bgp_fsm.h\"\n#include \"bgpd/bgp_packet.h\"\n#include \"bgpd/bgp_open.h\"\n#include \"bgpd/bgp_vty.h\"\n\n/* BGP-4 Multiprotocol Extentions lead us to the complex world. We can\n   negotiate remote peer supports extentions or not. But if\n   remote-peer doesn't supports negotiation process itself.  We would\n   like to do manual configuration.\n\n   So there is many configurable point.  First of all we want set each\n   peer whether we send capability negotiation to the peer or not.\n   Next, if we send capability to the peer we want to set my capabilty\n   inforation at each peer. */\n\nvoid\nbgp_capability_vty_out (struct vty *vty, struct peer *peer)\n{\n  char *pnt;\n  char *end;\n  struct capability_mp_data mpc;\n  struct capability_header *hdr;\n\n  pnt = peer->notify.data;\n  end = pnt + peer->notify.length;\n  \n  while (pnt < end)\n    {\n      if (pnt + sizeof (struct capability_mp_data) + 2 > end)\n\treturn;\n      \n      hdr = (struct capability_header *)pnt;\n      if (pnt + hdr->length + 2 > end)\n\treturn;\n\n      memcpy (&mpc, pnt + 2, sizeof(struct capability_mp_data));\n\n      if (hdr->code == CAPABILITY_CODE_MP)\n\t{\n\t  vty_out (vty, \"  Capability error for: Multi protocol \");\n\n\t  switch (ntohs (mpc.afi))\n\t    {\n\t    case AFI_IP:\n\t      vty_out (vty, \"AFI IPv4, \");\n\t      break;\n\t    case AFI_IP6:\n\t      vty_out (vty, \"AFI IPv6, \");\n\t      break;\n\t    default:\n\t      vty_out (vty, \"AFI Unknown %d, \", ntohs (mpc.afi));\n\t      break;\n\t    }\n\t  switch (mpc.safi)\n\t    {\n\t    case SAFI_UNICAST:\n\t      vty_out (vty, \"SAFI Unicast\");\n\t      break;\n\t    case SAFI_MULTICAST:\n\t      vty_out (vty, \"SAFI Multicast\");\n\t      break;\n\t    case SAFI_UNICAST_MULTICAST:\n\t      vty_out (vty, \"SAFI Unicast Multicast\");\n\t      break;\n\t    case BGP_SAFI_VPNV4:\n\t      vty_out (vty, \"SAFI MPLS-VPN\");\n\t      break;\n\t    default:\n\t      vty_out (vty, \"SAFI Unknown %d \", mpc.safi);\n\t      break;\n\t    }\n\t  vty_out (vty, \"%s\", VTY_NEWLINE);\n\t}\n      else if (hdr->code >= 128)\n\tvty_out (vty, \"  Capability error: vendor specific capability code %d\",\n\t\t hdr->code);\n      else\n\tvty_out (vty, \"  Capability error: unknown capability code %d\", \n\t\t hdr->code);\n\n      pnt += hdr->length + 2;\n    }\n}\n\nstatic void \nbgp_capability_mp_data (struct stream *s, struct capability_mp_data *mpc)\n{\n  mpc->afi = stream_getw (s);\n  mpc->reserved = stream_getc (s);\n  mpc->safi = stream_getc (s);\n}\n\nint\nbgp_afi_safi_valid_indices (afi_t afi, safi_t *safi)\n{\n  /* VPNvX are AFI specific */\n  if ((afi == AFI_IP6 && *safi == BGP_SAFI_VPNV4)\n      || (afi == AFI_IP && *safi == BGP_SAFI_VPNV6))\n    {\n      zlog_warn (\"Invalid afi/safi combination (%u/%u)\", afi, *safi);\n      return 0;\n    }\n  \n  switch (afi)\n    {\n      case AFI_IP:\n#ifdef HAVE_IPV6\n      case AFI_IP6:\n#endif\n        switch (*safi)\n          {\n            /* BGP VPNvX SAFI isn't contigious with others, remap */\n            case BGP_SAFI_VPNV4:\n            case BGP_SAFI_VPNV6:\n              *safi = SAFI_MPLS_VPN;\n            case SAFI_UNICAST:\n            case SAFI_MULTICAST:\n            case SAFI_MPLS_VPN:\n              return 1;\n          }\n    }\n  zlog_debug (\"unknown afi/safi (%u/%u)\", afi, *safi);\n  \n  return 0;\n}\n\n/* Set negotiated capability value. */\nstatic int\nbgp_capability_mp (struct peer *peer, struct capability_header *hdr)\n{\n  struct capability_mp_data mpc;\n  struct stream *s = BGP_INPUT (peer);\n  \n  bgp_capability_mp_data (s, &mpc);\n  \n  if (BGP_DEBUG (normal, NORMAL))\n    zlog_debug (\"%s OPEN has MP_EXT CAP for afi/safi: %u/%u\",\n               peer->host, mpc.afi, mpc.safi);\n  \n  if (!bgp_afi_safi_valid_indices (mpc.afi, &mpc.safi))\n    return -1;\n   \n  /* Now safi remapped, and afi/safi are valid array indices */\n  peer->afc_recv[mpc.afi][mpc.safi] = 1;\n  \n  if (peer->afc[mpc.afi][mpc.safi])\n    peer->afc_nego[mpc.safi][mpc.safi] = 1;\n  else \n    return -1;\n\n  return 0;\n}\n\nstatic void\nbgp_capability_orf_not_support (struct peer *peer, afi_t afi, safi_t safi,\n\t\t\t\tu_char type, u_char mode)\n{\n  if (BGP_DEBUG (normal, NORMAL))\n    zlog_debug (\"%s Addr-family %d/%d has ORF type/mode %d/%d not supported\",\n\t       peer->host, afi, safi, type, mode);\n}\n\nstatic struct message orf_type_str[] =\n{\n  { ORF_TYPE_PREFIX,\t\t\"Prefixlist\"\t\t},\n  { ORF_TYPE_PREFIX_OLD,\t\"Prefixlist (old)\"\t},\n};\nstatic int orf_type_str_max = sizeof(orf_type_str)/sizeof(orf_type_str[0]);\n\nstatic struct message orf_mode_str[] =\n{\n  { ORF_MODE_RECEIVE,\t\"Receive\"\t},\n  { ORF_MODE_SEND,\t\"Send\"\t\t},\n  { ORF_MODE_BOTH,\t\"Both\"\t\t},\n};\nstatic int orf_mode_str_max = sizeof(orf_mode_str)/sizeof(orf_mode_str[0]);\n\nstatic int\nbgp_capability_orf_entry (struct peer *peer, struct capability_header *hdr)\n{\n  struct stream *s = BGP_INPUT (peer);\n  struct capability_orf_entry entry;\n  afi_t afi;\n  safi_t safi;\n  u_char type;\n  u_char mode;\n  u_int16_t sm_cap = 0; /* capability send-mode receive */\n  u_int16_t rm_cap = 0; /* capability receive-mode receive */ \n  int i;\n\n  /* ORF Entry header */\n  bgp_capability_mp_data (s, &entry.mpc);\n  entry.num = stream_getc (s);\n  afi = entry.mpc.afi;\n  safi = entry.mpc.safi;\n  \n  if (BGP_DEBUG (normal, NORMAL))\n    zlog_debug (\"%s ORF Cap entry for afi/safi: %u/%u\",\n\t        peer->host, entry.mpc.afi, entry.mpc.safi);\n\n  /* Check AFI and SAFI. */\n  if (!bgp_afi_safi_valid_indices (entry.mpc.afi, &safi))\n    {\n      zlog_info (\"%s Addr-family %d/%d not supported.\"\n                 \" Ignoring the ORF capability\",\n                 peer->host, entry.mpc.afi, entry.mpc.safi);\n      return 0;\n    }\n  \n  /* validate number field */\n  if (sizeof (struct capability_orf_entry) + (entry.num * 2) > hdr->length)\n    {\n      zlog_info (\"%s ORF Capability entry length error,\"\n                 \" Cap length %u, num %u\",\n                 peer->host, hdr->length, entry.num);\n      bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n      return -1;\n    }\n\n  for (i = 0 ; i < entry.num ; i++)\n    {\n      type = stream_getc(s);\n      mode = stream_getc(s);\n      \n      /* ORF Mode error check */\n      switch (mode)\n        {\n          case ORF_MODE_BOTH:\n          case ORF_MODE_SEND:\n          case ORF_MODE_RECEIVE:\n            break;\n          default:\n\t    bgp_capability_orf_not_support (peer, afi, safi, type, mode);\n\t    continue;\n\t}\n      /* ORF Type and afi/safi error checks */\n      /* capcode versus type */\n      switch (hdr->code)\n        {\n          case CAPABILITY_CODE_ORF:\n            switch (type)\n              {\n                case ORF_TYPE_PREFIX:\n                  break;\n                default:\n                  bgp_capability_orf_not_support (peer, afi, safi, type, mode);\n                  continue;\n              }\n            break;\n          case CAPABILITY_CODE_ORF_OLD:\n            switch (type)\n              {\n                case ORF_TYPE_PREFIX_OLD:\n                  break;\n                default:\n                  bgp_capability_orf_not_support (peer, afi, safi, type, mode);\n                  continue;\n              }\n            break;\n          default:\n            bgp_capability_orf_not_support (peer, afi, safi, type, mode);\n            continue;\n        }\n                \n      /* AFI vs SAFI */\n      if (!((afi == AFI_IP && safi == SAFI_UNICAST)\n            || (afi == AFI_IP && safi == SAFI_MULTICAST)\n            || (afi == AFI_IP6 && safi == SAFI_UNICAST)))\n        {\n          bgp_capability_orf_not_support (peer, afi, safi, type, mode);\n          continue;\n        }\n      \n      if (BGP_DEBUG (normal, NORMAL))\n        zlog_debug (\"%s OPEN has %s ORF capability\"\n                    \" as %s for afi/safi: %d/%d\",\n                    peer->host, LOOKUP (orf_type_str, type),\n                    LOOKUP (orf_mode_str, mode),\n                    entry.mpc.afi, safi);\n\n      if (hdr->code == CAPABILITY_CODE_ORF)\n\t{\n          sm_cap = PEER_CAP_ORF_PREFIX_SM_RCV;\n          rm_cap = PEER_CAP_ORF_PREFIX_RM_RCV;\n\t}\n      else if (hdr->code == CAPABILITY_CODE_ORF_OLD)\n\t{\n          sm_cap = PEER_CAP_ORF_PREFIX_SM_OLD_RCV;\n          rm_cap = PEER_CAP_ORF_PREFIX_RM_OLD_RCV;\n\t}\n      else\n\t{\n\t  bgp_capability_orf_not_support (peer, afi, safi, type, mode);\n\t  continue;\n\t}\n\n      switch (mode)\n\t{\n\t  case ORF_MODE_BOTH:\n\t    SET_FLAG (peer->af_cap[afi][safi], sm_cap);\n\t    SET_FLAG (peer->af_cap[afi][safi], rm_cap);\n\t    break;\n\t  case ORF_MODE_SEND:\n\t    SET_FLAG (peer->af_cap[afi][safi], sm_cap);\n\t    break;\n\t  case ORF_MODE_RECEIVE:\n\t    SET_FLAG (peer->af_cap[afi][safi], rm_cap);\n\t    break;\n\t}\n    }\n  return 0;\n}\n\nstatic int\nbgp_capability_orf (struct peer *peer, struct capability_header *hdr)\n{\n  struct stream *s = BGP_INPUT (peer);\n  size_t end = stream_get_getp (s) + hdr->length;\n  \n  assert (stream_get_getp(s) + sizeof(struct capability_orf_entry) <= end);\n  \n  /* We must have at least one ORF entry, as the caller has already done\n   * minimum length validation for the capability code - for ORF there must\n   * at least one ORF entry (header and unknown number of pairs of bytes).\n   */\n  do\n    {\n      if (bgp_capability_orf_entry (peer, hdr) == -1)\n        return -1;\n    } \n  while (stream_get_getp(s) + sizeof(struct capability_orf_entry) < end);\n  \n  return 0;\n}\n\nstatic int\nbgp_capability_restart (struct peer *peer, struct capability_header *caphdr)\n{\n  struct stream *s = BGP_INPUT (peer);\n  u_int16_t restart_flag_time;\n  int restart_bit = 0;\n  size_t end = stream_get_getp (s) + caphdr->length;\n\n  SET_FLAG (peer->cap, PEER_CAP_RESTART_RCV);\n  restart_flag_time = stream_getw(s);\n  if (CHECK_FLAG (restart_flag_time, RESTART_R_BIT))\n    restart_bit = 1;\n  UNSET_FLAG (restart_flag_time, 0xF000);\n  peer->v_gr_restart = restart_flag_time;\n\n  if (BGP_DEBUG (normal, NORMAL))\n    {\n      zlog_debug (\"%s OPEN has Graceful Restart capability\", peer->host);\n      zlog_debug (\"%s Peer has%srestarted. Restart Time : %d\",\n                  peer->host, restart_bit ? \" \" : \" not \",\n                  peer->v_gr_restart);\n    }\n\n  while (stream_get_getp (s) + 4 < end)\n    {\n      afi_t afi = stream_getw (s);\n      safi_t safi = stream_getc (s);\n      u_char flag = stream_getc (s);\n      \n      if (!bgp_afi_safi_valid_indices (afi, &safi))\n        {\n          if (BGP_DEBUG (normal, NORMAL))\n            zlog_debug (\"%s Addr-family %d/%d(afi/safi) not supported.\"\n                        \" Ignore the Graceful Restart capability\",\n                        peer->host, afi, safi);\n        }\n      else if (!peer->afc[afi][safi])\n        {\n          if (BGP_DEBUG (normal, NORMAL))\n            zlog_debug (\"%s Addr-family %d/%d(afi/safi) not enabled.\"\n                        \" Ignore the Graceful Restart capability\",\n                        peer->host, afi, safi);\n        }\n      else\n        {\n          if (BGP_DEBUG (normal, NORMAL))\n            zlog_debug (\"%s Address family %s is%spreserved\", peer->host,\n                        afi_safi_print (afi, safi),\n                        CHECK_FLAG (peer->af_cap[afi][safi],\n                                    PEER_CAP_RESTART_AF_PRESERVE_RCV)\n                        ? \" \" : \" not \");\n\n          SET_FLAG (peer->af_cap[afi][safi], PEER_CAP_RESTART_AF_RCV);\n          if (CHECK_FLAG (flag, RESTART_F_BIT))\n            SET_FLAG (peer->af_cap[afi][safi], PEER_CAP_RESTART_AF_PRESERVE_RCV);\n          \n        }\n    }\n  return 0;\n}\n\nstatic struct message capcode_str[] =\n{\n  { 0,\t\"\"},\n  { CAPABILITY_CODE_MP,\t\t\t\"MultiProtocol Extensions\"\t},\n  { CAPABILITY_CODE_REFRESH,\t\t\"Route Refresh\"\t\t\t},\n  { CAPABILITY_CODE_ORF,\t\t\"Cooperative Route Filtering\" \t},\n  { CAPABILITY_CODE_RESTART,\t\t\"Graceful Restart\"\t\t},\n  { CAPABILITY_CODE_AS4,\t\t\"4-octet AS number\"\t\t},\n  { CAPABILITY_CODE_DYNAMIC,\t\t\"Dynamic\"\t\t\t},\n  { CAPABILITY_CODE_REFRESH_OLD,\t\"Route Refresh (Old)\"\t\t},\n  { CAPABILITY_CODE_ORF_OLD,\t\t\"ORF (Old)\"\t\t\t},\n};\nint capcode_str_max = sizeof(capcode_str)/sizeof(capcode_str[0]);\n\n/* Minimum sizes for length field of each cap (so not inc. the header) */\nstatic size_t cap_minsizes[] = \n{\n  [CAPABILITY_CODE_MP]\t\t= sizeof (struct capability_mp_data),\n  [CAPABILITY_CODE_REFRESH]\t= CAPABILITY_CODE_REFRESH_LEN,\n  [CAPABILITY_CODE_ORF]\t\t= sizeof (struct capability_orf_entry),\n  [CAPABILITY_CODE_RESTART]\t= sizeof (struct capability_gr) - 2,\n  [CAPABILITY_CODE_AS4]\t\t= CAPABILITY_CODE_AS4_LEN,\n  [CAPABILITY_CODE_DYNAMIC]\t= CAPABILITY_CODE_DYNAMIC_LEN,\n  [CAPABILITY_CODE_REFRESH_OLD]\t= CAPABILITY_CODE_REFRESH_LEN,\n  [CAPABILITY_CODE_ORF_OLD]\t= sizeof (struct capability_orf_entry),\n};\n\n/* Parse given capability.\n * XXX: This is reading into a stream, but not using stream API\n */\nstatic int\nbgp_capability_parse (struct peer *peer, size_t length, u_char **error)\n{\n  int ret;\n  struct stream *s = BGP_INPUT (peer);\n  size_t end = stream_get_getp (s) + length;\n  \n  assert (STREAM_READABLE (s) >= length);\n  \n  while (stream_get_getp (s) < end)\n    {\n      size_t start;\n      u_char *sp = stream_pnt (s);\n      struct capability_header caphdr;\n      \n      /* We need at least capability code and capability length. */\n      if (stream_get_getp(s) + 2 > end)\n\t{\n\t  zlog_info (\"%s Capability length error (< header)\", peer->host);\n\t  bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n\t  return -1;\n\t}\n      \n      caphdr.code = stream_getc (s);\n      caphdr.length = stream_getc (s);\n      start = stream_get_getp (s);\n      \n      /* Capability length check sanity check. */\n      if (start + caphdr.length > end)\n\t{\n\t  zlog_info (\"%s Capability length error (< length)\", peer->host);\n\t  bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n\t  return -1;\n\t}\n      \n      if (BGP_DEBUG (normal, NORMAL))\n\tzlog_debug (\"%s OPEN has %s capability (%u), length %u\",\n\t\t   peer->host,\n\t\t   LOOKUP (capcode_str, caphdr.code),\n\t\t   caphdr.code, caphdr.length);\n      \n      /* Length sanity check, type-specific, for known capabilities */\n      switch (caphdr.code)\n        {\n          case CAPABILITY_CODE_MP:\n          case CAPABILITY_CODE_REFRESH:\n          case CAPABILITY_CODE_REFRESH_OLD:\n          case CAPABILITY_CODE_ORF:\n          case CAPABILITY_CODE_ORF_OLD:\n          case CAPABILITY_CODE_RESTART:\n          case CAPABILITY_CODE_DYNAMIC:\n              /* Check length. */\n              if (caphdr.length < cap_minsizes[caphdr.code])\n                {\n                  zlog_info (\"%s %s Capability length error: got %u,\"\n                             \" expected at least %u\",\n                             peer->host, \n                             LOOKUP (capcode_str, caphdr.code),\n                             caphdr.length, cap_minsizes[caphdr.code]);\n                  bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n                  return -1;\n                }\n          /* we deliberately ignore unknown codes, see below */\n          default:\n            break;\n        }\n      \n      switch (caphdr.code)\n        {\n          case CAPABILITY_CODE_MP:\n            {\n              /* Ignore capability when override-capability is set. */\n              if (! CHECK_FLAG (peer->flags, PEER_FLAG_OVERRIDE_CAPABILITY))\n                {\n                  /* Set negotiated value. */\n                  ret = bgp_capability_mp (peer, &caphdr);\n\n                  /* Unsupported Capability. */\n                  if (ret < 0)\n                    {\n                      /* Store return data. */\n                      memcpy (*error, sp, caphdr.length + 2);\n                      *error += caphdr.length + 2;\n                    }\n                }\n            }\n            break;\n          case CAPABILITY_CODE_REFRESH:\n          case CAPABILITY_CODE_REFRESH_OLD:\n            {\n              /* BGP refresh capability */\n              if (caphdr.code == CAPABILITY_CODE_REFRESH_OLD)\n                SET_FLAG (peer->cap, PEER_CAP_REFRESH_OLD_RCV);\n              else\n                SET_FLAG (peer->cap, PEER_CAP_REFRESH_NEW_RCV);\n            }\n            break;\n          case CAPABILITY_CODE_ORF:\n          case CAPABILITY_CODE_ORF_OLD:\n            if (bgp_capability_orf (peer, &caphdr))\n              return -1;\n            break;\n          case CAPABILITY_CODE_RESTART:\n            if (bgp_capability_restart (peer, &caphdr))\n              return -1;\n            break;\n          case CAPABILITY_CODE_DYNAMIC:\n            SET_FLAG (peer->cap, PEER_CAP_DYNAMIC_RCV);\n            break;\n          default:\n            if (caphdr.code > 128)\n              {\n                /* We don't send Notification for unknown vendor specific\n                   capabilities.  It seems reasonable for now...  */\n                zlog_warn (\"%s Vendor specific capability %d\",\n                           peer->host, caphdr.code);\n              }\n            else\n              {\n                zlog_warn (\"%s unrecognized capability code: %d - ignored\",\n                           peer->host, caphdr.code);\n                memcpy (*error, sp, caphdr.length + 2);\n                *error += caphdr.length + 2;\n              }\n          }\n      if (stream_get_getp(s) != (start + caphdr.length))\n        {\n          if (stream_get_getp(s) > (start + caphdr.length))\n            zlog_warn (\"%s Cap-parser for %s read past cap-length, %u!\",\n                       peer->host, LOOKUP (capcode_str, caphdr.code),\n                       caphdr.length);\n          stream_set_getp (s, start + caphdr.length);\n        }\n    }\n  return 0;\n}\n\nstatic int\nbgp_auth_parse (struct peer *peer, size_t length)\n{\n  bgp_notify_send (peer, \n\t\t   BGP_NOTIFY_OPEN_ERR, \n\t\t   BGP_NOTIFY_OPEN_AUTH_FAILURE); \n  return -1;\n}\n\nstatic int\nstrict_capability_same (struct peer *peer)\n{\n  int i, j;\n\n  for (i = AFI_IP; i < AFI_MAX; i++)\n    for (j = SAFI_UNICAST; j < SAFI_MAX; j++)\n      if (peer->afc[i][j] != peer->afc_nego[i][j])\n\treturn 0;\n  return 1;\n}\n\n/* Parse open option */\nint\nbgp_open_option_parse (struct peer *peer, u_char length, int *capability)\n{\n  int ret;\n  u_char *error;\n  u_char error_data[BGP_MAX_PACKET_SIZE];\n  struct stream *s = BGP_INPUT(peer);\n  size_t end = stream_get_getp (s) + length;\n\n  ret = 0;\n  error = error_data;\n\n  if (BGP_DEBUG (normal, NORMAL))\n    zlog_debug (\"%s rcv OPEN w/ OPTION parameter len: %u\",\n\t       peer->host, length);\n  \n  while (stream_get_getp(s) < end)\n    {\n      u_char opt_type;\n      u_char opt_length;\n      \n      /* Must have at least an OPEN option header */\n      if (STREAM_READABLE(s) < 2)\n\t{\n\t  zlog_info (\"%s Option length error\", peer->host);\n\t  bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n\t  return -1;\n\t}\n\n      /* Fetch option type and length. */\n      opt_type = stream_getc (s);\n      opt_length = stream_getc (s);\n      \n      /* Option length check. */\n      if (STREAM_READABLE (s) < opt_length)\n\t{\n\t  zlog_info (\"%s Option length error\", peer->host);\n\t  bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n\t  return -1;\n\t}\n\n      if (BGP_DEBUG (normal, NORMAL))\n\tzlog_debug (\"%s rcvd OPEN w/ optional parameter type %u (%s) len %u\",\n\t\t   peer->host, opt_type,\n\t\t   opt_type == BGP_OPEN_OPT_AUTH ? \"Authentication\" :\n\t\t   opt_type == BGP_OPEN_OPT_CAP ? \"Capability\" : \"Unknown\",\n\t\t   opt_length);\n  \n      switch (opt_type)\n\t{\n\tcase BGP_OPEN_OPT_AUTH:\n\t  ret = bgp_auth_parse (peer, opt_length);\n\t  break;\n\tcase BGP_OPEN_OPT_CAP:\n\t  ret = bgp_capability_parse (peer, opt_length, &error);\n\t  *capability = 1;\n\t  break;\n\tdefault:\n\t  bgp_notify_send (peer, \n\t\t\t   BGP_NOTIFY_OPEN_ERR, \n\t\t\t   BGP_NOTIFY_OPEN_UNSUP_PARAM); \n\t  ret = -1;\n\t  break;\n\t}\n\n      /* Parse error.  To accumulate all unsupported capability codes,\n         bgp_capability_parse does not return -1 when encounter\n         unsupported capability code.  To detect that, please check\n         error and erro_data pointer, like below.  */\n      if (ret < 0)\n\treturn -1;\n    }\n\n  /* All OPEN option is parsed.  Check capability when strict compare\n     flag is enabled.*/\n  if (CHECK_FLAG (peer->flags, PEER_FLAG_STRICT_CAP_MATCH))\n    {\n      /* If Unsupported Capability exists. */\n      if (error != error_data)\n\t{\n\t  bgp_notify_send_with_data (peer, \n\t\t\t\t     BGP_NOTIFY_OPEN_ERR, \n\t\t\t\t     BGP_NOTIFY_OPEN_UNSUP_CAPBL, \n\t\t\t\t     error_data, error - error_data);\n\t  return -1;\n\t}\n\n      /* Check local capability does not negotiated with remote\n         peer. */\n      if (! strict_capability_same (peer))\n\t{\n\t  bgp_notify_send (peer, \n\t\t\t   BGP_NOTIFY_OPEN_ERR, \n\t\t\t   BGP_NOTIFY_OPEN_UNSUP_CAPBL);\n\t  return -1;\n\t}\n    }\n\n  /* Check there is no common capability send Unsupported Capability\n     error. */\n  if (*capability && ! CHECK_FLAG (peer->flags, PEER_FLAG_OVERRIDE_CAPABILITY))\n    {\n      if (! peer->afc_nego[AFI_IP][SAFI_UNICAST] \n\t  && ! peer->afc_nego[AFI_IP][SAFI_MULTICAST]\n\t  && ! peer->afc_nego[AFI_IP][SAFI_MPLS_VPN]\n\t  && ! peer->afc_nego[AFI_IP6][SAFI_UNICAST]\n\t  && ! peer->afc_nego[AFI_IP6][SAFI_MULTICAST])\n\t{\n\t  plog_err (peer->log, \"%s [Error] No common capability\", peer->host);\n\n\t  if (error != error_data)\n\n\t    bgp_notify_send_with_data (peer, \n\t\t\t\t       BGP_NOTIFY_OPEN_ERR, \n\t\t\t\t       BGP_NOTIFY_OPEN_UNSUP_CAPBL, \n\t\t\t\t       error_data, error - error_data);\n\t  else\n\t    bgp_notify_send (peer, \n\t\t\t     BGP_NOTIFY_OPEN_ERR, \n\t\t\t     BGP_NOTIFY_OPEN_UNSUP_CAPBL);\n\t  return -1;\n\t}\n    }\n  return 0;\n}\n\nstatic void\nbgp_open_capability_orf (struct stream *s, struct peer *peer,\n                         afi_t afi, safi_t safi, u_char code)\n{\n  u_char cap_len;\n  u_char orf_len;\n  unsigned long capp;\n  unsigned long orfp;\n  unsigned long numberp;\n  int number_of_orfs = 0;\n\n  if (safi == SAFI_MPLS_VPN)\n    safi = BGP_SAFI_VPNV4;\n\n  stream_putc (s, BGP_OPEN_OPT_CAP);\n  capp = stream_get_endp (s);           /* Set Capability Len Pointer */\n  stream_putc (s, 0);                   /* Capability Length */\n  stream_putc (s, code);                /* Capability Code */\n  orfp = stream_get_endp (s);           /* Set ORF Len Pointer */\n  stream_putc (s, 0);                   /* ORF Length */\n  stream_putw (s, afi);\n  stream_putc (s, 0);\n  stream_putc (s, safi);\n  numberp = stream_get_endp (s);        /* Set Number Pointer */\n  stream_putc (s, 0);                   /* Number of ORFs */\n\n  /* Address Prefix ORF */\n  if (CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_ORF_PREFIX_SM)\n      || CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_ORF_PREFIX_RM))\n    {\n      stream_putc (s, (code == CAPABILITY_CODE_ORF ?\n\t\t   ORF_TYPE_PREFIX : ORF_TYPE_PREFIX_OLD));\n\n      if (CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_ORF_PREFIX_SM)\n\t  && CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_ORF_PREFIX_RM))\n\t{\n\t  SET_FLAG (peer->af_cap[afi][safi], PEER_CAP_ORF_PREFIX_SM_ADV);\n\t  SET_FLAG (peer->af_cap[afi][safi], PEER_CAP_ORF_PREFIX_RM_ADV);\n\t  stream_putc (s, ORF_MODE_BOTH);\n\t}\n      else if (CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_ORF_PREFIX_SM))\n\t{\n\t  SET_FLAG (peer->af_cap[afi][safi], PEER_CAP_ORF_PREFIX_SM_ADV);\n\t  stream_putc (s, ORF_MODE_SEND);\n\t}\n      else\n\t{\n\t  SET_FLAG (peer->af_cap[afi][safi], PEER_CAP_ORF_PREFIX_RM_ADV);\n\t  stream_putc (s, ORF_MODE_RECEIVE);\n\t}\n      number_of_orfs++;\n    }\n\n  /* Total Number of ORFs. */\n  stream_putc_at (s, numberp, number_of_orfs);\n\n  /* Total ORF Len. */\n  orf_len = stream_get_endp (s) - orfp - 1;\n  stream_putc_at (s, orfp, orf_len);\n\n  /* Total Capability Len. */\n  cap_len = stream_get_endp (s) - capp - 1;\n  stream_putc_at (s, capp, cap_len);\n}\n\n/* Fill in capability open option to the packet. */\nvoid\nbgp_open_capability (struct stream *s, struct peer *peer)\n{\n  u_char len;\n  unsigned long cp;\n  afi_t afi;\n  safi_t safi;\n\n  /* Remember current pointer for Opt Parm Len. */\n  cp = stream_get_endp (s);\n\n  /* Opt Parm Len. */\n  stream_putc (s, 0);\n\n  /* Do not send capability. */\n  if (! CHECK_FLAG (peer->sflags, PEER_STATUS_CAPABILITY_OPEN) \n      || CHECK_FLAG (peer->flags, PEER_FLAG_DONT_CAPABILITY))\n    return;\n\n  /* IPv4 unicast. */\n  if (peer->afc[AFI_IP][SAFI_UNICAST])\n    {\n      peer->afc_adv[AFI_IP][SAFI_UNICAST] = 1;\n      stream_putc (s, BGP_OPEN_OPT_CAP);\n      stream_putc (s, CAPABILITY_CODE_MP_LEN + 2);\n      stream_putc (s, CAPABILITY_CODE_MP);\n      stream_putc (s, CAPABILITY_CODE_MP_LEN);\n      stream_putw (s, AFI_IP);\n      stream_putc (s, 0);\n      stream_putc (s, SAFI_UNICAST);\n    }\n  /* IPv4 multicast. */\n  if (peer->afc[AFI_IP][SAFI_MULTICAST])\n    {\n      peer->afc_adv[AFI_IP][SAFI_MULTICAST] = 1;\n      stream_putc (s, BGP_OPEN_OPT_CAP);\n      stream_putc (s, CAPABILITY_CODE_MP_LEN + 2);\n      stream_putc (s, CAPABILITY_CODE_MP);\n      stream_putc (s, CAPABILITY_CODE_MP_LEN);\n      stream_putw (s, AFI_IP);\n      stream_putc (s, 0);\n      stream_putc (s, SAFI_MULTICAST);\n    }\n  /* IPv4 VPN */\n  if (peer->afc[AFI_IP][SAFI_MPLS_VPN])\n    {\n      peer->afc_adv[AFI_IP][SAFI_MPLS_VPN] = 1;\n      stream_putc (s, BGP_OPEN_OPT_CAP);\n      stream_putc (s, CAPABILITY_CODE_MP_LEN + 2);\n      stream_putc (s, CAPABILITY_CODE_MP);\n      stream_putc (s, CAPABILITY_CODE_MP_LEN);\n      stream_putw (s, AFI_IP);\n      stream_putc (s, 0);\n      stream_putc (s, BGP_SAFI_VPNV4);\n    }\n#ifdef HAVE_IPV6\n  /* IPv6 unicast. */\n  if (peer->afc[AFI_IP6][SAFI_UNICAST])\n    {\n      peer->afc_adv[AFI_IP6][SAFI_UNICAST] = 1;\n      stream_putc (s, BGP_OPEN_OPT_CAP);\n      stream_putc (s, CAPABILITY_CODE_MP_LEN + 2);\n      stream_putc (s, CAPABILITY_CODE_MP);\n      stream_putc (s, CAPABILITY_CODE_MP_LEN);\n      stream_putw (s, AFI_IP6);\n      stream_putc (s, 0);\n      stream_putc (s, SAFI_UNICAST);\n    }\n  /* IPv6 multicast. */\n  if (peer->afc[AFI_IP6][SAFI_MULTICAST])\n    {\n      peer->afc_adv[AFI_IP6][SAFI_MULTICAST] = 1;\n      stream_putc (s, BGP_OPEN_OPT_CAP);\n      stream_putc (s, CAPABILITY_CODE_MP_LEN + 2);\n      stream_putc (s, CAPABILITY_CODE_MP);\n      stream_putc (s, CAPABILITY_CODE_MP_LEN);\n      stream_putw (s, AFI_IP6);\n      stream_putc (s, 0);\n      stream_putc (s, SAFI_MULTICAST);\n    }\n#endif /* HAVE_IPV6 */\n\n  /* Route refresh. */\n  SET_FLAG (peer->cap, PEER_CAP_REFRESH_ADV);\n  stream_putc (s, BGP_OPEN_OPT_CAP);\n  stream_putc (s, CAPABILITY_CODE_REFRESH_LEN + 2);\n  stream_putc (s, CAPABILITY_CODE_REFRESH_OLD);\n  stream_putc (s, CAPABILITY_CODE_REFRESH_LEN);\n  stream_putc (s, BGP_OPEN_OPT_CAP);\n  stream_putc (s, CAPABILITY_CODE_REFRESH_LEN + 2);\n  stream_putc (s, CAPABILITY_CODE_REFRESH);\n  stream_putc (s, CAPABILITY_CODE_REFRESH_LEN);\n\n  /* ORF capability. */\n  for (afi = AFI_IP ; afi < AFI_MAX ; afi++)\n    for (safi = SAFI_UNICAST ; safi < SAFI_MAX ; safi++)\n      if (CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_ORF_PREFIX_SM)\n\t  || CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_ORF_PREFIX_RM))\n\t{\n\t  bgp_open_capability_orf (s, peer, afi, safi, CAPABILITY_CODE_ORF_OLD);\n\t  bgp_open_capability_orf (s, peer, afi, safi, CAPABILITY_CODE_ORF);\n\t}\n\n  /* Dynamic capability. */\n  if (CHECK_FLAG (peer->flags, PEER_FLAG_DYNAMIC_CAPABILITY))\n    {\n      SET_FLAG (peer->cap, PEER_CAP_DYNAMIC_ADV);\n      stream_putc (s, BGP_OPEN_OPT_CAP);\n      stream_putc (s, CAPABILITY_CODE_DYNAMIC_LEN + 2);\n      stream_putc (s, CAPABILITY_CODE_DYNAMIC);\n      stream_putc (s, CAPABILITY_CODE_DYNAMIC_LEN);\n    }\n\n  /* Graceful restart capability */\n  if (bgp_flag_check (peer->bgp, BGP_FLAG_GRACEFUL_RESTART))\n    {\n      SET_FLAG (peer->cap, PEER_CAP_RESTART_ADV);\n      stream_putc (s, BGP_OPEN_OPT_CAP);\n      stream_putc (s, CAPABILITY_CODE_RESTART_LEN + 2);\n      stream_putc (s, CAPABILITY_CODE_RESTART);\n      stream_putc (s, CAPABILITY_CODE_RESTART_LEN);\n      stream_putw (s, peer->bgp->restart_time);\n     }\n\n  /* Total Opt Parm Len. */\n  len = stream_get_endp (s) - cp - 1;\n  stream_putc_at (s, cp, len);\n}\n", "/* BGP open message handling\n   Copyright (C) 1999 Kunihiro Ishiguro\n\nThis file is part of GNU Zebra.\n\nGNU Zebra is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the\nFree Software Foundation; either version 2, or (at your option) any\nlater version.\n\nGNU Zebra is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GNU Zebra; see the file COPYING.  If not, write to the Free\nSoftware Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef _QUAGGA_BGP_OPEN_H\n#define _QUAGGA_BGP_OPEN_H\n\n/* Standard header for capability TLV */\nstruct capability_header\n{\n  u_char code;\n  u_char length;\n};\n\n/* Generic MP capability data */\nstruct capability_mp_data\n{\n  u_int16_t afi;\n  u_char reserved;\n  u_char safi;\n};\n\n#pragma pack(1)\nstruct capability_orf_entry \n{\n  struct capability_mp_data mpc;\n  u_char num;\n  struct {\n    u_char type;\n    u_char mode;\n  } orfs[];\n} __attribute__ ((packed));\n#pragma pack()\n\nstruct graceful_restart_af\n{\n  u_int16_t afi;\n  u_char safi;\n  u_char flag;\n};\n\nstruct capability_gr\n{\n  u_int16_t restart_flag_time;\n  struct graceful_restart_af gr[];\n};\n\n/* Capability Code */\n#define CAPABILITY_CODE_MP              1 /* Multiprotocol Extensions */\n#define CAPABILITY_CODE_REFRESH         2 /* Route Refresh Capability */\n#define CAPABILITY_CODE_ORF             3 /* Cooperative Route Filtering Capability */\n#define CAPABILITY_CODE_RESTART        64 /* Graceful Restart Capability */\n#define CAPABILITY_CODE_AS4            65 /* 4-octet AS number Capability */\n#define CAPABILITY_CODE_DYNAMIC        66 /* Dynamic Capability */\n#define CAPABILITY_CODE_REFRESH_OLD   128 /* Route Refresh Capability(cisco) */\n#define CAPABILITY_CODE_ORF_OLD       130 /* Cooperative Route Filtering Capability(cisco) */\n\n/* Capability Length */\n#define CAPABILITY_CODE_MP_LEN          4\n#define CAPABILITY_CODE_REFRESH_LEN     0\n#define CAPABILITY_CODE_DYNAMIC_LEN     0\n#define CAPABILITY_CODE_RESTART_LEN     2 /* Receiving only case */\n#define CAPABILITY_CODE_AS4_LEN         4\n\n/* Cooperative Route Filtering Capability.  */\n\n/* ORF Type */\n#define ORF_TYPE_PREFIX                64 \n#define ORF_TYPE_PREFIX_OLD           128\n\n/* ORF Mode */\n#define ORF_MODE_RECEIVE                1 \n#define ORF_MODE_SEND                   2 \n#define ORF_MODE_BOTH                   3 \n\n/* Capability Message Action.  */\n#define CAPABILITY_ACTION_SET           0\n#define CAPABILITY_ACTION_UNSET         1\n\n/* Graceful Restart */\n#define RESTART_R_BIT              0x8000\n#define RESTART_F_BIT              0x80\n\nextern int bgp_open_option_parse (struct peer *, u_char, int *);\nextern void bgp_open_capability (struct stream *, struct peer *);\nextern void bgp_capability_vty_out (struct vty *, struct peer *);\nextern int bgp_afi_safi_valid_indices (afi_t, safi_t *);\n\n#endif /* _QUAGGA_BGP_OPEN_H */\n", "/* BGP packet management routine.\n   Copyright (C) 1999 Kunihiro Ishiguro\n\nThis file is part of GNU Zebra.\n\nGNU Zebra is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the\nFree Software Foundation; either version 2, or (at your option) any\nlater version.\n\nGNU Zebra is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GNU Zebra; see the file COPYING.  If not, write to the Free\nSoftware Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#include <zebra.h>\n\n#include \"thread.h\"\n#include \"stream.h\"\n#include \"network.h\"\n#include \"prefix.h\"\n#include \"command.h\"\n#include \"log.h\"\n#include \"memory.h\"\n#include \"sockunion.h\"\t\t/* for inet_ntop () */\n#include \"linklist.h\"\n#include \"plist.h\"\n\n#include \"bgpd/bgpd.h\"\n#include \"bgpd/bgp_table.h\"\n#include \"bgpd/bgp_dump.h\"\n#include \"bgpd/bgp_attr.h\"\n#include \"bgpd/bgp_debug.h\"\n#include \"bgpd/bgp_fsm.h\"\n#include \"bgpd/bgp_route.h\"\n#include \"bgpd/bgp_packet.h\"\n#include \"bgpd/bgp_open.h\"\n#include \"bgpd/bgp_aspath.h\"\n#include \"bgpd/bgp_community.h\"\n#include \"bgpd/bgp_ecommunity.h\"\n#include \"bgpd/bgp_network.h\"\n#include \"bgpd/bgp_mplsvpn.h\"\n#include \"bgpd/bgp_advertise.h\"\n#include \"bgpd/bgp_vty.h\"\n\nint stream_put_prefix (struct stream *, struct prefix *);\n\f\n/* Set up BGP packet marker and packet type. */\nstatic int\nbgp_packet_set_marker (struct stream *s, u_char type)\n{\n  int i;\n\n  /* Fill in marker. */\n  for (i = 0; i < BGP_MARKER_SIZE; i++)\n    stream_putc (s, 0xff);\n\n  /* Dummy total length. This field is should be filled in later on. */\n  stream_putw (s, 0);\n\n  /* BGP packet type. */\n  stream_putc (s, type);\n\n  /* Return current stream size. */\n  return stream_get_endp (s);\n}\n\n/* Set BGP packet header size entry.  If size is zero then use current\n   stream size. */\nstatic int\nbgp_packet_set_size (struct stream *s)\n{\n  int cp;\n\n  /* Preserve current pointer. */\n  cp = stream_get_endp (s);\n  stream_putw_at (s, BGP_MARKER_SIZE, cp);\n\n  return cp;\n}\n\n/* Add new packet to the peer. */\nstatic void\nbgp_packet_add (struct peer *peer, struct stream *s)\n{\n  /* Add packet to the end of list. */\n  stream_fifo_push (peer->obuf, s);\n}\n\n/* Free first packet. */\nstatic void\nbgp_packet_delete (struct peer *peer)\n{\n  stream_free (stream_fifo_pop (peer->obuf));\n}\n\n/* Check file descriptor whether connect is established. */\nstatic void\nbgp_connect_check (struct peer *peer)\n{\n  int status;\n  socklen_t slen;\n  int ret;\n\n  /* Anyway I have to reset read and write thread. */\n  BGP_READ_OFF (peer->t_read);\n  BGP_WRITE_OFF (peer->t_write);\n\n  /* Check file descriptor. */\n  slen = sizeof (status);\n  ret = getsockopt(peer->fd, SOL_SOCKET, SO_ERROR, (void *) &status, &slen);\n\n  /* If getsockopt is fail, this is fatal error. */\n  if (ret < 0)\n    {\n      zlog (peer->log, LOG_INFO, \"can't get sockopt for nonblocking connect\");\n      BGP_EVENT_ADD (peer, TCP_fatal_error);\n      return;\n    }      \n\n  /* When status is 0 then TCP connection is established. */\n  if (status == 0)\n    {\n      BGP_EVENT_ADD (peer, TCP_connection_open);\n    }\n  else\n    {\n      if (BGP_DEBUG (events, EVENTS))\n\t  plog_debug (peer->log, \"%s [Event] Connect failed (%s)\",\n\t\t     peer->host, safe_strerror (errno));\n      BGP_EVENT_ADD (peer, TCP_connection_open_failed);\n    }\n}\n\n/* Make BGP update packet.  */\nstatic struct stream *\nbgp_update_packet (struct peer *peer, afi_t afi, safi_t safi)\n{\n  struct stream *s;\n  struct bgp_adj_out *adj;\n  struct bgp_advertise *adv;\n  struct stream *packet;\n  struct bgp_node *rn = NULL;\n  struct bgp_info *binfo = NULL;\n  bgp_size_t total_attr_len = 0;\n  unsigned long pos;\n  char buf[BUFSIZ];\n\n  s = peer->work;\n  stream_reset (s);\n\n  adv = FIFO_HEAD (&peer->sync[afi][safi]->update);\n\n  while (adv)\n    {\n      assert (adv->rn);\n      rn = adv->rn;\n      adj = adv->adj;\n      if (adv->binfo)\n        binfo = adv->binfo;\n\n      /* When remaining space can't include NLRI and it's length.  */\n      if (STREAM_REMAIN (s) <= BGP_NLRI_LENGTH + PSIZE (rn->p.prefixlen))\n\tbreak;\n\n      /* If packet is empty, set attribute. */\n      if (stream_empty (s))\n\t{\n\t  struct prefix_rd *prd = NULL;\n\t  u_char *tag = NULL;\n\t  struct peer *from = NULL;\n\t  \n\t  if (rn->prn)\n\t    prd = (struct prefix_rd *) &rn->prn->p;\n          if (binfo && binfo->extra)\n            {\n              tag = binfo->extra->tag;\n              from = binfo->peer;\n            }\n          \n\t  bgp_packet_set_marker (s, BGP_MSG_UPDATE);\n\t  stream_putw (s, 0);\t\t\n\t  pos = stream_get_endp (s);\n\t  stream_putw (s, 0);\n\t  total_attr_len = bgp_packet_attribute (NULL, peer, s, \n\t                                         adv->baa->attr,\n\t                                         &rn->p, afi, safi, \n\t                                         from, prd, tag);\n\t  stream_putw_at (s, pos, total_attr_len);\n\t}\n\n      if (afi == AFI_IP && safi == SAFI_UNICAST)\n\tstream_put_prefix (s, &rn->p);\n      \n      if (BGP_DEBUG (update, UPDATE_OUT))\n\tzlog (peer->log, LOG_DEBUG, \"%s send UPDATE %s/%d\",\n\t      peer->host,\n\t      inet_ntop (rn->p.family, &(rn->p.u.prefix), buf, BUFSIZ),\n\t      rn->p.prefixlen);\n\n      /* Synchnorize attribute.  */\n      if (adj->attr)\n\tbgp_attr_unintern (adj->attr);\n      else\n\tpeer->scount[afi][safi]++;\n\n      adj->attr = bgp_attr_intern (adv->baa->attr);\n\n      adv = bgp_advertise_clean (peer, adj, afi, safi);\n\n      if (! (afi == AFI_IP && safi == SAFI_UNICAST))\n\tbreak;\n    }\n\t \n  if (! stream_empty (s))\n    {\n      bgp_packet_set_size (s);\n      packet = stream_dup (s);\n      bgp_packet_add (peer, packet);\n      BGP_WRITE_ON (peer->t_write, bgp_write, peer->fd);\n      stream_reset (s);\n      return packet;\n    }\n  return NULL;\n}\n\nstatic struct stream *\nbgp_update_packet_eor (struct peer *peer, afi_t afi, safi_t safi)\n{\n  struct stream *s;\n  struct stream *packet;\n\n#ifdef DISABLE_BGP_ANNOUNCE\n  return;\n#endif /* DISABLE_BGP_ANNOUNCE */\n\n  if (BGP_DEBUG (normal, NORMAL))\n    zlog_debug (\"send End-of-RIB for %s to %s\", afi_safi_print (afi, safi), peer->host);\n\n  s = stream_new (BGP_MAX_PACKET_SIZE);\n\n  /* Make BGP update packet. */\n  bgp_packet_set_marker (s, BGP_MSG_UPDATE);\n\n  /* Unfeasible Routes Length */\n  stream_putw (s, 0);\n\n  if (afi == AFI_IP && safi == SAFI_UNICAST)\n    {\n      /* Total Path Attribute Length */\n      stream_putw (s, 0);\n    }\n  else\n    {\n      /* Total Path Attribute Length */\n      stream_putw (s, 6);\n      stream_putc (s, BGP_ATTR_FLAG_OPTIONAL);\n      stream_putc (s, BGP_ATTR_MP_UNREACH_NLRI);\n      stream_putc (s, 3);\n      stream_putw (s, afi);\n      stream_putc (s, safi);\n    }\n\n  bgp_packet_set_size (s);\n  packet = stream_dup (s);\n  bgp_packet_add (peer, packet);\n  stream_free (s);\n  return packet;\n}\n\n/* Make BGP withdraw packet.  */\nstatic struct stream *\nbgp_withdraw_packet (struct peer *peer, afi_t afi, safi_t safi)\n{\n  struct stream *s;\n  struct stream *packet;\n  struct bgp_adj_out *adj;\n  struct bgp_advertise *adv;\n  struct bgp_node *rn;\n  unsigned long pos;\n  bgp_size_t unfeasible_len;\n  bgp_size_t total_attr_len;\n  char buf[BUFSIZ];\n\n  s = peer->work;\n  stream_reset (s);\n\n  while ((adv = FIFO_HEAD (&peer->sync[afi][safi]->withdraw)) != NULL)\n    {\n      assert (adv->rn);\n      adj = adv->adj;\n      rn = adv->rn;\n\n      if (STREAM_REMAIN (s) \n\t  < (BGP_NLRI_LENGTH + BGP_TOTAL_ATTR_LEN + PSIZE (rn->p.prefixlen)))\n\tbreak;\n\n      if (stream_empty (s))\n\t{\n\t  bgp_packet_set_marker (s, BGP_MSG_UPDATE);\n\t  stream_putw (s, 0);\n\t}\n\n      if (afi == AFI_IP && safi == SAFI_UNICAST)\n\tstream_put_prefix (s, &rn->p);\n      else\n\t{\n\t  struct prefix_rd *prd = NULL;\n\t  \n\t  if (rn->prn)\n\t    prd = (struct prefix_rd *) &rn->prn->p;\n\t  pos = stream_get_endp (s);\n\t  stream_putw (s, 0);\n\t  total_attr_len\n\t    = bgp_packet_withdraw (peer, s, &rn->p, afi, safi, prd, NULL);\n      \n\t  /* Set total path attribute length. */\n\t  stream_putw_at (s, pos, total_attr_len);\n\t}\n\n      if (BGP_DEBUG (update, UPDATE_OUT))\n\tzlog (peer->log, LOG_DEBUG, \"%s send UPDATE %s/%d -- unreachable\",\n\t      peer->host,\n\t      inet_ntop (rn->p.family, &(rn->p.u.prefix), buf, BUFSIZ),\n\t      rn->p.prefixlen);\n\n      peer->scount[afi][safi]--;\n\n      bgp_adj_out_remove (rn, adj, peer, afi, safi);\n      bgp_unlock_node (rn);\n\n      if (! (afi == AFI_IP && safi == SAFI_UNICAST))\n\tbreak;\n    }\n\n  if (! stream_empty (s))\n    {\n      if (afi == AFI_IP && safi == SAFI_UNICAST)\n\t{\n\t  unfeasible_len \n\t    = stream_get_endp (s) - BGP_HEADER_SIZE - BGP_UNFEASIBLE_LEN;\n\t  stream_putw_at (s, BGP_HEADER_SIZE, unfeasible_len);\n\t  stream_putw (s, 0);\n\t}\n      bgp_packet_set_size (s);\n      packet = stream_dup (s);\n      bgp_packet_add (peer, packet);\n      stream_reset (s);\n      return packet;\n    }\n\n  return NULL;\n}\n\nvoid\nbgp_default_update_send (struct peer *peer, struct attr *attr,\n\t\t\t afi_t afi, safi_t safi, struct peer *from)\n{\n  struct stream *s;\n  struct stream *packet;\n  struct prefix p;\n  unsigned long pos;\n  bgp_size_t total_attr_len;\n  char attrstr[BUFSIZ];\n  char buf[BUFSIZ];\n\n#ifdef DISABLE_BGP_ANNOUNCE\n  return;\n#endif /* DISABLE_BGP_ANNOUNCE */\n\n  if (afi == AFI_IP)\n    str2prefix (\"0.0.0.0/0\", &p);\n#ifdef HAVE_IPV6\n  else \n    str2prefix (\"::/0\", &p);\n#endif /* HAVE_IPV6 */\n\n  /* Logging the attribute. */\n  if (BGP_DEBUG (update, UPDATE_OUT))\n    {\n      bgp_dump_attr (peer, attr, attrstr, BUFSIZ);\n      zlog (peer->log, LOG_DEBUG, \"%s send UPDATE %s/%d %s\",\n\t    peer->host, inet_ntop(p.family, &(p.u.prefix), buf, BUFSIZ),\n\t    p.prefixlen, attrstr);\n    }\n\n  s = stream_new (BGP_MAX_PACKET_SIZE);\n\n  /* Make BGP update packet. */\n  bgp_packet_set_marker (s, BGP_MSG_UPDATE);\n\n  /* Unfeasible Routes Length. */\n  stream_putw (s, 0);\n\n  /* Make place for total attribute length.  */\n  pos = stream_get_endp (s);\n  stream_putw (s, 0);\n  total_attr_len = bgp_packet_attribute (NULL, peer, s, attr, &p, afi, safi, from, NULL, NULL);\n\n  /* Set Total Path Attribute Length. */\n  stream_putw_at (s, pos, total_attr_len);\n\n  /* NLRI set. */\n  if (p.family == AF_INET && safi == SAFI_UNICAST)\n    stream_put_prefix (s, &p);\n\n  /* Set size. */\n  bgp_packet_set_size (s);\n\n  packet = stream_dup (s);\n  stream_free (s);\n\n  /* Dump packet if debug option is set. */\n#ifdef DEBUG\n  /* bgp_packet_dump (packet); */\n#endif /* DEBUG */\n\n  /* Add packet to the peer. */\n  bgp_packet_add (peer, packet);\n\n  BGP_WRITE_ON (peer->t_write, bgp_write, peer->fd);\n}\n\nvoid\nbgp_default_withdraw_send (struct peer *peer, afi_t afi, safi_t safi)\n{\n  struct stream *s;\n  struct stream *packet;\n  struct prefix p;\n  unsigned long pos;\n  unsigned long cp;\n  bgp_size_t unfeasible_len;\n  bgp_size_t total_attr_len;\n  char buf[BUFSIZ];\n\n#ifdef DISABLE_BGP_ANNOUNCE\n  return;\n#endif /* DISABLE_BGP_ANNOUNCE */\n\n  if (afi == AFI_IP)\n    str2prefix (\"0.0.0.0/0\", &p);\n#ifdef HAVE_IPV6\n  else \n    str2prefix (\"::/0\", &p);\n#endif /* HAVE_IPV6 */\n\n  total_attr_len = 0;\n  pos = 0;\n\n  if (BGP_DEBUG (update, UPDATE_OUT))\n    zlog (peer->log, LOG_DEBUG, \"%s send UPDATE %s/%d -- unreachable\",\n          peer->host, inet_ntop(p.family, &(p.u.prefix), buf, BUFSIZ),\n          p.prefixlen);\n\n  s = stream_new (BGP_MAX_PACKET_SIZE);\n\n  /* Make BGP update packet. */\n  bgp_packet_set_marker (s, BGP_MSG_UPDATE);\n\n  /* Unfeasible Routes Length. */;\n  cp = stream_get_endp (s);\n  stream_putw (s, 0);\n\n  /* Withdrawn Routes. */\n  if (p.family == AF_INET && safi == SAFI_UNICAST)\n    {\n      stream_put_prefix (s, &p);\n\n      unfeasible_len = stream_get_endp (s) - cp - 2;\n\n      /* Set unfeasible len.  */\n      stream_putw_at (s, cp, unfeasible_len);\n\n      /* Set total path attribute length. */\n      stream_putw (s, 0);\n    }\n  else\n    {\n      pos = stream_get_endp (s);\n      stream_putw (s, 0);\n      total_attr_len = bgp_packet_withdraw (peer, s, &p, afi, safi, NULL, NULL);\n\n      /* Set total path attribute length. */\n      stream_putw_at (s, pos, total_attr_len);\n    }\n\n  bgp_packet_set_size (s);\n\n  packet = stream_dup (s);\n  stream_free (s);\n\n  /* Add packet to the peer. */\n  bgp_packet_add (peer, packet);\n\n  BGP_WRITE_ON (peer->t_write, bgp_write, peer->fd);\n}\n\n/* Get next packet to be written.  */\nstatic struct stream *\nbgp_write_packet (struct peer *peer)\n{\n  afi_t afi;\n  safi_t safi;\n  struct stream *s = NULL;\n  struct bgp_advertise *adv;\n\n  s = stream_fifo_head (peer->obuf);\n  if (s)\n    return s;\n\n  for (afi = AFI_IP; afi < AFI_MAX; afi++)\n    for (safi = SAFI_UNICAST; safi < SAFI_MAX; safi++)\n      {\n\tadv = FIFO_HEAD (&peer->sync[afi][safi]->withdraw);\n\tif (adv)\n\t  {\n\t    s = bgp_withdraw_packet (peer, afi, safi);\n\t    if (s)\n\t      return s;\n\t  }\n      }\n    \n  for (afi = AFI_IP; afi < AFI_MAX; afi++)\n    for (safi = SAFI_UNICAST; safi < SAFI_MAX; safi++)\n      {\n\tadv = FIFO_HEAD (&peer->sync[afi][safi]->update);\n\tif (adv)\n\t  {\n            if (adv->binfo && adv->binfo->uptime < peer->synctime)\n\t      {\n\t\tif (CHECK_FLAG (adv->binfo->peer->cap, PEER_CAP_RESTART_RCV)\n\t\t    && CHECK_FLAG (adv->binfo->peer->cap, PEER_CAP_RESTART_ADV)\n\t\t    && ! CHECK_FLAG (adv->binfo->flags, BGP_INFO_STALE)\n\t\t    && safi != SAFI_MPLS_VPN)\n\t\t  {\n\t\t    if (CHECK_FLAG (adv->binfo->peer->af_sflags[afi][safi],\n\t\t\tPEER_STATUS_EOR_RECEIVED))\n\t\t      s = bgp_update_packet (peer, afi, safi);\n\t\t  }\n\t\telse\n\t\t  s = bgp_update_packet (peer, afi, safi);\n\t      }\n\n\t    if (s)\n\t      return s;\n\t  }\n\n\tif (CHECK_FLAG (peer->cap, PEER_CAP_RESTART_RCV))\n\t  {\n\t    if (peer->afc_nego[afi][safi] && peer->synctime\n\t\t&& ! CHECK_FLAG (peer->af_sflags[afi][safi], PEER_STATUS_EOR_SEND)\n\t\t&& safi != SAFI_MPLS_VPN)\n\t      {\n\t\tSET_FLAG (peer->af_sflags[afi][safi], PEER_STATUS_EOR_SEND);\n\t\treturn bgp_update_packet_eor (peer, afi, safi);\n\t      }\n\t  }\n      }\n\n  return NULL;\n}\n\n/* Is there partially written packet or updates we can send right\n   now.  */\nstatic int\nbgp_write_proceed (struct peer *peer)\n{\n  afi_t afi;\n  safi_t safi;\n  struct bgp_advertise *adv;\n\n  if (stream_fifo_head (peer->obuf))\n    return 1;\n\n  for (afi = AFI_IP; afi < AFI_MAX; afi++)\n    for (safi = SAFI_UNICAST; safi < SAFI_MAX; safi++)\n      if (FIFO_HEAD (&peer->sync[afi][safi]->withdraw))\n\treturn 1;\n\n  for (afi = AFI_IP; afi < AFI_MAX; afi++)\n    for (safi = SAFI_UNICAST; safi < SAFI_MAX; safi++)\n      if ((adv = FIFO_HEAD (&peer->sync[afi][safi]->update)) != NULL)\n\tif (adv->binfo->uptime < peer->synctime)\n\t  return 1;\n\n  return 0;\n}\n\n/* Write packet to the peer. */\nint\nbgp_write (struct thread *thread)\n{\n  struct peer *peer;\n  u_char type;\n  struct stream *s; \n  int num;\n  unsigned int count = 0;\n  int write_errno;\n\n  /* Yes first of all get peer pointer. */\n  peer = THREAD_ARG (thread);\n  peer->t_write = NULL;\n\n  /* For non-blocking IO check. */\n  if (peer->status == Connect)\n    {\n      bgp_connect_check (peer);\n      return 0;\n    }\n\n    /* Nonblocking write until TCP output buffer is full.  */\n  while (1)\n    {\n      int writenum;\n      int val;\n\n      s = bgp_write_packet (peer);\n      if (! s)\n\treturn 0;\n      \n      /* XXX: FIXME, the socket should be NONBLOCK from the start\n       * status shouldnt need to be toggled on each write\n       */\n      val = fcntl (peer->fd, F_GETFL, 0);\n      fcntl (peer->fd, F_SETFL, val|O_NONBLOCK);\n\n      /* Number of bytes to be sent.  */\n      writenum = stream_get_endp (s) - stream_get_getp (s);\n\n      /* Call write() system call.  */\n      num = write (peer->fd, STREAM_PNT (s), writenum);\n      write_errno = errno;\n      fcntl (peer->fd, F_SETFL, val);\n      if (num <= 0)\n\t{\n\t  /* Partial write. */\n\t  if (write_errno == EWOULDBLOCK || write_errno == EAGAIN)\n\t      break;\n\n\t  BGP_EVENT_ADD (peer, TCP_fatal_error);\n\t  return 0;\n\t}\n      if (num != writenum)\n\t{\n\t  stream_forward_getp (s, num);\n\n\t  if (write_errno == EAGAIN)\n\t    break;\n\n\t  continue;\n\t}\n\n      /* Retrieve BGP packet type. */\n      stream_set_getp (s, BGP_MARKER_SIZE + 2);\n      type = stream_getc (s);\n\n      switch (type)\n\t{\n\tcase BGP_MSG_OPEN:\n\t  peer->open_out++;\n\t  break;\n\tcase BGP_MSG_UPDATE:\n\t  peer->update_out++;\n\t  break;\n\tcase BGP_MSG_NOTIFY:\n\t  peer->notify_out++;\n\t  /* Double start timer. */\n\t  peer->v_start *= 2;\n\n\t  /* Overflow check. */\n\t  if (peer->v_start >= (60 * 2))\n\t    peer->v_start = (60 * 2);\n\n\t  /* Flush any existing events */\n\t  BGP_EVENT_ADD (peer, BGP_Stop);\n\t  return 0;\n\tcase BGP_MSG_KEEPALIVE:\n\t  peer->keepalive_out++;\n\t  break;\n\tcase BGP_MSG_ROUTE_REFRESH_NEW:\n\tcase BGP_MSG_ROUTE_REFRESH_OLD:\n\t  peer->refresh_out++;\n\t  break;\n\tcase BGP_MSG_CAPABILITY:\n\t  peer->dynamic_cap_out++;\n\t  break;\n\t}\n\n      /* OK we send packet so delete it. */\n      bgp_packet_delete (peer);\n\n      if (++count >= BGP_WRITE_PACKET_MAX)\n\tbreak;\n    }\n  \n  if (bgp_write_proceed (peer))\n    BGP_WRITE_ON (peer->t_write, bgp_write, peer->fd);\n  \n  return 0;\n}\n\n/* This is only for sending NOTIFICATION message to neighbor. */\nstatic int\nbgp_write_notify (struct peer *peer)\n{\n  int ret;\n  u_char type;\n  struct stream *s; \n\n  /* There should be at least one packet. */\n  s = stream_fifo_head (peer->obuf);\n  if (!s)\n    return 0;\n  assert (stream_get_endp (s) >= BGP_HEADER_SIZE);\n\n  /* I'm not sure fd is writable. */\n  ret = writen (peer->fd, STREAM_DATA (s), stream_get_endp (s));\n  if (ret <= 0)\n    {\n      BGP_EVENT_ADD (peer, TCP_fatal_error);\n      return 0;\n    }\n\n  /* Retrieve BGP packet type. */\n  stream_set_getp (s, BGP_MARKER_SIZE + 2);\n  type = stream_getc (s);\n\n  assert (type == BGP_MSG_NOTIFY);\n\n  /* Type should be notify. */\n  peer->notify_out++;\n\n  /* Double start timer. */\n  peer->v_start *= 2;\n\n  /* Overflow check. */\n  if (peer->v_start >= (60 * 2))\n    peer->v_start = (60 * 2);\n\n  BGP_EVENT_ADD (peer, BGP_Stop);\n\n  return 0;\n}\n\n/* Make keepalive packet and send it to the peer. */\nvoid\nbgp_keepalive_send (struct peer *peer)\n{\n  struct stream *s;\n  int length;\n\n  s = stream_new (BGP_MAX_PACKET_SIZE);\n\n  /* Make keepalive packet. */\n  bgp_packet_set_marker (s, BGP_MSG_KEEPALIVE);\n\n  /* Set packet size. */\n  length = bgp_packet_set_size (s);\n\n  /* Dump packet if debug option is set. */\n  /* bgp_packet_dump (s); */\n \n  if (BGP_DEBUG (keepalive, KEEPALIVE))  \n    zlog_debug (\"%s sending KEEPALIVE\", peer->host); \n  if (BGP_DEBUG (normal, NORMAL))\n    zlog_debug (\"%s send message type %d, length (incl. header) %d\",\n               peer->host, BGP_MSG_KEEPALIVE, length);\n\n  /* Add packet to the peer. */\n  bgp_packet_add (peer, s);\n\n  BGP_WRITE_ON (peer->t_write, bgp_write, peer->fd);\n}\n\n/* Make open packet and send it to the peer. */\nvoid\nbgp_open_send (struct peer *peer)\n{\n  struct stream *s;\n  int length;\n  u_int16_t send_holdtime;\n  as_t local_as;\n\n  if (CHECK_FLAG (peer->config, PEER_CONFIG_TIMER))\n    send_holdtime = peer->holdtime;\n  else\n    send_holdtime = peer->bgp->default_holdtime;\n\n  /* local-as Change */\n  if (peer->change_local_as)\n    local_as = peer->change_local_as; \n  else\n    local_as = peer->local_as; \n\n  s = stream_new (BGP_MAX_PACKET_SIZE);\n\n  /* Make open packet. */\n  bgp_packet_set_marker (s, BGP_MSG_OPEN);\n\n  /* Set open packet values. */\n  stream_putc (s, BGP_VERSION_4);        /* BGP version */\n  stream_putw (s, local_as);\t\t /* My Autonomous System*/\n  stream_putw (s, send_holdtime);     \t /* Hold Time */\n  stream_put_in_addr (s, &peer->local_id); /* BGP Identifier */\n\n  /* Set capability code. */\n  bgp_open_capability (s, peer);\n\n  /* Set BGP packet length. */\n  length = bgp_packet_set_size (s);\n\n  if (BGP_DEBUG (normal, NORMAL))\n    zlog_debug (\"%s sending OPEN, version %d, my as %d, holdtime %d, id %s\", \n\t       peer->host, BGP_VERSION_4, local_as,\n\t       send_holdtime, inet_ntoa (peer->local_id));\n\n  if (BGP_DEBUG (normal, NORMAL))\n    zlog_debug (\"%s send message type %d, length (incl. header) %d\",\n\t       peer->host, BGP_MSG_OPEN, length);\n\n  /* Dump packet if debug option is set. */\n  /* bgp_packet_dump (s); */\n\n  /* Add packet to the peer. */\n  bgp_packet_add (peer, s);\n\n  BGP_WRITE_ON (peer->t_write, bgp_write, peer->fd);\n}\n\n/* Send BGP notify packet with data potion. */\nvoid\nbgp_notify_send_with_data (struct peer *peer, u_char code, u_char sub_code,\n\t\t\t   u_char *data, size_t datalen)\n{\n  struct stream *s;\n  int length;\n\n  /* Allocate new stream. */\n  s = stream_new (BGP_MAX_PACKET_SIZE);\n\n  /* Make nitify packet. */\n  bgp_packet_set_marker (s, BGP_MSG_NOTIFY);\n\n  /* Set notify packet values. */\n  stream_putc (s, code);        /* BGP notify code */\n  stream_putc (s, sub_code);\t/* BGP notify sub_code */\n\n  /* If notify data is present. */\n  if (data)\n    stream_write (s, data, datalen);\n  \n  /* Set BGP packet length. */\n  length = bgp_packet_set_size (s);\n  \n  /* Add packet to the peer. */\n  stream_fifo_clean (peer->obuf);\n  bgp_packet_add (peer, s);\n\n  /* For debug */\n  {\n    struct bgp_notify bgp_notify;\n    int first = 0;\n    int i;\n    char c[4];\n\n    bgp_notify.code = code;\n    bgp_notify.subcode = sub_code;\n    bgp_notify.data = NULL;\n    bgp_notify.length = length - BGP_MSG_NOTIFY_MIN_SIZE;\n    \n    if (bgp_notify.length)\n      {\n\tbgp_notify.data = XMALLOC (MTYPE_TMP, bgp_notify.length * 3);\n\tfor (i = 0; i < bgp_notify.length; i++)\n\t  if (first)\n\t    {\n\t      sprintf (c, \" %02x\", data[i]);\n\t      strcat (bgp_notify.data, c);\n\t    }\n\t  else\n\t    {\n\t      first = 1;\n\t      sprintf (c, \"%02x\", data[i]);\n\t      strcpy (bgp_notify.data, c);\n\t    }\n      }\n    bgp_notify_print (peer, &bgp_notify, \"sending\");\n    if (bgp_notify.data)\n      XFREE (MTYPE_TMP, bgp_notify.data);\n  }\n\n  if (BGP_DEBUG (normal, NORMAL))\n    zlog_debug (\"%s send message type %d, length (incl. header) %d\",\n\t       peer->host, BGP_MSG_NOTIFY, length);\n\n  /* peer reset cause */\n  if (sub_code != BGP_NOTIFY_CEASE_CONFIG_CHANGE)\n    {\n      if (sub_code == BGP_NOTIFY_CEASE_ADMIN_RESET)\n      peer->last_reset = PEER_DOWN_USER_RESET;\n      else if (sub_code == BGP_NOTIFY_CEASE_ADMIN_SHUTDOWN)\n      peer->last_reset = PEER_DOWN_USER_SHUTDOWN;\n      else\n      peer->last_reset = PEER_DOWN_NOTIFY_SEND;\n    }\n\n  /* Call imidiately. */\n  BGP_WRITE_OFF (peer->t_write);\n\n  bgp_write_notify (peer);\n}\n\n/* Send BGP notify packet. */\nvoid\nbgp_notify_send (struct peer *peer, u_char code, u_char sub_code)\n{\n  bgp_notify_send_with_data (peer, code, sub_code, NULL, 0);\n}\n\nstatic const char *\nafi2str (afi_t afi)\n{\n  if (afi == AFI_IP)\n    return \"AFI_IP\";\n  else if (afi == AFI_IP6)\n    return \"AFI_IP6\";\n  else\n    return \"Unknown AFI\";\n}\n\nstatic const char *\nsafi2str (safi_t safi)\n{\n  if (safi == SAFI_UNICAST)\n    return \"SAFI_UNICAST\";\n  else if (safi == SAFI_MULTICAST)\n    return \"SAFI_MULTICAST\";\n  else if (safi == SAFI_MPLS_VPN || safi == BGP_SAFI_VPNV4)\n    return \"SAFI_MPLS_VPN\";\n  else\n    return \"Unknown SAFI\";\n}\n\n/* Send route refresh message to the peer. */\nvoid\nbgp_route_refresh_send (struct peer *peer, afi_t afi, safi_t safi,\n\t\t\tu_char orf_type, u_char when_to_refresh, int remove)\n{\n  struct stream *s;\n  struct stream *packet;\n  int length;\n  struct bgp_filter *filter;\n  int orf_refresh = 0;\n\n#ifdef DISABLE_BGP_ANNOUNCE\n  return;\n#endif /* DISABLE_BGP_ANNOUNCE */\n\n  filter = &peer->filter[afi][safi];\n\n  /* Adjust safi code. */\n  if (safi == SAFI_MPLS_VPN)\n    safi = BGP_SAFI_VPNV4;\n  \n  s = stream_new (BGP_MAX_PACKET_SIZE);\n\n  /* Make BGP update packet. */\n  if (CHECK_FLAG (peer->cap, PEER_CAP_REFRESH_NEW_RCV))\n    bgp_packet_set_marker (s, BGP_MSG_ROUTE_REFRESH_NEW);\n  else\n    bgp_packet_set_marker (s, BGP_MSG_ROUTE_REFRESH_OLD);\n\n  /* Encode Route Refresh message. */\n  stream_putw (s, afi);\n  stream_putc (s, 0);\n  stream_putc (s, safi);\n \n  if (orf_type == ORF_TYPE_PREFIX\n      || orf_type == ORF_TYPE_PREFIX_OLD)\n    if (remove || filter->plist[FILTER_IN].plist)\n      {\n\tu_int16_t orf_len;\n\tunsigned long orfp;\n\n\torf_refresh = 1; \n\tstream_putc (s, when_to_refresh);\n\tstream_putc (s, orf_type);\n\torfp = stream_get_endp (s);\n\tstream_putw (s, 0);\n\n\tif (remove)\n\t  {\n\t    UNSET_FLAG (peer->af_sflags[afi][safi], PEER_STATUS_ORF_PREFIX_SEND);\n\t    stream_putc (s, ORF_COMMON_PART_REMOVE_ALL);\n\t    if (BGP_DEBUG (normal, NORMAL))\n\t      zlog_debug (\"%s sending REFRESH_REQ to remove ORF(%d) (%s) for afi/safi: %d/%d\", \n\t\t\t peer->host, orf_type,\n\t\t\t (when_to_refresh == REFRESH_DEFER ? \"defer\" : \"immediate\"),\n\t\t\t afi, safi);\n\t  }\n\telse\n\t  {\n\t    SET_FLAG (peer->af_sflags[afi][safi], PEER_STATUS_ORF_PREFIX_SEND);\n\t    prefix_bgp_orf_entry (s, filter->plist[FILTER_IN].plist,\n\t\t\t\t  ORF_COMMON_PART_ADD, ORF_COMMON_PART_PERMIT,\n\t\t\t\t  ORF_COMMON_PART_DENY);\n\t    if (BGP_DEBUG (normal, NORMAL))\n\t      zlog_debug (\"%s sending REFRESH_REQ with pfxlist ORF(%d) (%s) for afi/safi: %d/%d\", \n\t\t\t peer->host, orf_type,\n\t\t\t (when_to_refresh == REFRESH_DEFER ? \"defer\" : \"immediate\"),\n\t\t\t afi, safi);\n\t  }\n\n\t/* Total ORF Entry Len. */\n\torf_len = stream_get_endp (s) - orfp - 2;\n\tstream_putw_at (s, orfp, orf_len);\n      }\n\n  /* Set packet size. */\n  length = bgp_packet_set_size (s);\n\n  if (BGP_DEBUG (normal, NORMAL))\n    {\n      if (! orf_refresh)\n\tzlog_debug (\"%s sending REFRESH_REQ for afi/safi: %d/%d\", \n\t\t   peer->host, afi, safi);\n      zlog_debug (\"%s send message type %d, length (incl. header) %d\",\n\t\t peer->host, CHECK_FLAG (peer->cap, PEER_CAP_REFRESH_NEW_RCV) ?\n\t\t BGP_MSG_ROUTE_REFRESH_NEW : BGP_MSG_ROUTE_REFRESH_OLD, length);\n    }\n\n  /* Make real packet. */\n  packet = stream_dup (s);\n  stream_free (s);\n\n  /* Add packet to the peer. */\n  bgp_packet_add (peer, packet);\n\n  BGP_WRITE_ON (peer->t_write, bgp_write, peer->fd);\n}\n\n/* Send capability message to the peer. */\nvoid\nbgp_capability_send (struct peer *peer, afi_t afi, safi_t safi,\n\t\t     int capability_code, int action)\n{\n  struct stream *s;\n  struct stream *packet;\n  int length;\n\n  /* Adjust safi code. */\n  if (safi == SAFI_MPLS_VPN)\n    safi = BGP_SAFI_VPNV4;\n\n  s = stream_new (BGP_MAX_PACKET_SIZE);\n\n  /* Make BGP update packet. */\n  bgp_packet_set_marker (s, BGP_MSG_CAPABILITY);\n\n  /* Encode MP_EXT capability. */\n  if (capability_code == CAPABILITY_CODE_MP)\n    {\n      stream_putc (s, action);\n      stream_putc (s, CAPABILITY_CODE_MP);\n      stream_putc (s, CAPABILITY_CODE_MP_LEN);\n      stream_putw (s, afi);\n      stream_putc (s, 0);\n      stream_putc (s, safi);\n\n      if (BGP_DEBUG (normal, NORMAL))\n        zlog_debug (\"%s sending CAPABILITY has %s MP_EXT CAP for afi/safi: %d/%d\",\n\t\t   peer->host, action == CAPABILITY_ACTION_SET ?\n\t\t   \"Advertising\" : \"Removing\", afi, safi);\n    }\n\n  /* Set packet size. */\n  length = bgp_packet_set_size (s);\n\n  /* Make real packet. */\n  packet = stream_dup (s);\n  stream_free (s);\n\n  /* Add packet to the peer. */\n  bgp_packet_add (peer, packet);\n\n  if (BGP_DEBUG (normal, NORMAL))\n    zlog_debug (\"%s send message type %d, length (incl. header) %d\",\n\t       peer->host, BGP_MSG_CAPABILITY, length);\n\n  BGP_WRITE_ON (peer->t_write, bgp_write, peer->fd);\n}\n\f\n/* RFC1771 6.8 Connection collision detection. */\nstatic int\nbgp_collision_detect (struct peer *new, struct in_addr remote_id)\n{\n  struct peer *peer;\n  struct listnode *node, *nnode;\n  struct bgp *bgp;\n\n  bgp = bgp_get_default ();\n  if (! bgp)\n    return 0;\n  \n  /* Upon receipt of an OPEN message, the local system must examine\n     all of its connections that are in the OpenConfirm state.  A BGP\n     speaker may also examine connections in an OpenSent state if it\n     knows the BGP Identifier of the peer by means outside of the\n     protocol.  If among these connections there is a connection to a\n     remote BGP speaker whose BGP Identifier equals the one in the\n     OPEN message, then the local system performs the following\n     collision resolution procedure: */\n\n  for (ALL_LIST_ELEMENTS (bgp->peer, node, nnode, peer))\n    {\n      /* Under OpenConfirm status, local peer structure already hold\n         remote router ID. */\n\n      if (peer != new\n\t  && (peer->status == OpenConfirm || peer->status == OpenSent)\n\t  && sockunion_same (&peer->su, &new->su))\n\t{\n\t  /* 1. The BGP Identifier of the local system is compared to\n\t     the BGP Identifier of the remote system (as specified in\n\t     the OPEN message). */\n\n\t  if (ntohl (peer->local_id.s_addr) < ntohl (remote_id.s_addr))\n\t    {\n\t      /* 2. If the value of the local BGP Identifier is less\n\t\t than the remote one, the local system closes BGP\n\t\t connection that already exists (the one that is\n\t\t already in the OpenConfirm state), and accepts BGP\n\t\t connection initiated by the remote system. */\n\n\t      if (peer->fd >= 0)\n\t\tbgp_notify_send (peer, BGP_NOTIFY_CEASE, BGP_NOTIFY_CEASE_COLLISION_RESOLUTION);\n\t      return 1;\n\t    }\n\t  else\n\t    {\n\t      /* 3. Otherwise, the local system closes newly created\n\t\t BGP connection (the one associated with the newly\n\t\t received OPEN message), and continues to use the\n\t\t existing one (the one that is already in the\n\t\t OpenConfirm state). */\n\n\t      if (new->fd >= 0)\n\t\tbgp_notify_send (new, BGP_NOTIFY_CEASE, \n\t\t\t         BGP_NOTIFY_CEASE_COLLISION_RESOLUTION);\n\t      return -1;\n\t    }\n\t}\n    }\n  return 0;\n}\n\nstatic int\nbgp_open_receive (struct peer *peer, bgp_size_t size)\n{\n  int ret;\n  u_char version;\n  u_char optlen;\n  u_int16_t holdtime;\n  u_int16_t send_holdtime;\n  as_t remote_as;\n  struct peer *realpeer;\n  struct in_addr remote_id;\n  int capability;\n  u_int8_t notify_data_remote_as[2];\n  u_int8_t notify_data_remote_id[4];\n\n  realpeer = NULL;\n  \n  /* Parse open packet. */\n  version = stream_getc (peer->ibuf);\n  memcpy (notify_data_remote_as, stream_pnt (peer->ibuf), 2);\n  remote_as  = stream_getw (peer->ibuf);\n  holdtime = stream_getw (peer->ibuf);\n  memcpy (notify_data_remote_id, stream_pnt (peer->ibuf), 4);\n  remote_id.s_addr = stream_get_ipv4 (peer->ibuf);\n\n  /* Receive OPEN message log  */\n  if (BGP_DEBUG (normal, NORMAL))\n    zlog_debug (\"%s rcv OPEN, version %d, remote-as %d, holdtime %d, id %s\",\n\t       peer->host, version, remote_as, holdtime,\n\t       inet_ntoa (remote_id));\n\t  \n  /* Lookup peer from Open packet. */\n  if (CHECK_FLAG (peer->sflags, PEER_STATUS_ACCEPT_PEER))\n    {\n      int as = 0;\n\n      realpeer = peer_lookup_with_open (&peer->su, remote_as, &remote_id, &as);\n\n      if (! realpeer)\n\t{\n\t  /* Peer's source IP address is check in bgp_accept(), so this\n\t     must be AS number mismatch or remote-id configuration\n\t     mismatch. */\n\t  if (as)\n\t    {\n\t      if (BGP_DEBUG (normal, NORMAL))\n\t\tzlog_debug (\"%s bad OPEN, wrong router identifier %s\",\n\t\t\t    peer->host, inet_ntoa (remote_id));\n\t      bgp_notify_send_with_data (peer, BGP_NOTIFY_OPEN_ERR, \n\t\t\t\t\t BGP_NOTIFY_OPEN_BAD_BGP_IDENT,\n\t\t\t\t\t notify_data_remote_id, 4);\n\t    }\n\t  else\n\t    {\n\t      if (BGP_DEBUG (normal, NORMAL))\n\t\tzlog_debug (\"%s bad OPEN, remote AS is %d, expected %d\",\n\t\t\t    peer->host, remote_as, peer->as);\n\t      bgp_notify_send_with_data (peer, BGP_NOTIFY_OPEN_ERR,\n\t\t\t\t\t BGP_NOTIFY_OPEN_BAD_PEER_AS,\n\t\t\t\t\t notify_data_remote_as, 2);\n\t    }\n\t  return -1;\n\t}\n    }\n\n  /* When collision is detected and this peer is closed.  Retrun\n     immidiately. */\n  ret = bgp_collision_detect (peer, remote_id);\n  if (ret < 0)\n    return ret;\n\n  /* Hack part. */\n  if (CHECK_FLAG (peer->sflags, PEER_STATUS_ACCEPT_PEER))\n    {\n\tif (realpeer->status == Established\n\t    && CHECK_FLAG (realpeer->sflags, PEER_STATUS_NSF_MODE))\n\t{\n\t  realpeer->last_reset = PEER_DOWN_NSF_CLOSE_SESSION;\n\t  SET_FLAG (realpeer->sflags, PEER_STATUS_NSF_WAIT);\n\t}\n\telse if (ret == 0 && realpeer->status != Active\n\t         && realpeer->status != OpenSent\n\t\t && realpeer->status != OpenConfirm)\n\n \t{\n \t  if (BGP_DEBUG (events, EVENTS))\n\t    zlog_debug (\"%s peer status is %s close connection\",\n\t\t\trealpeer->host, LOOKUP (bgp_status_msg,\n\t\t\trealpeer->status));\n\t  bgp_notify_send (peer, BGP_NOTIFY_CEASE,\n\t\t\t   BGP_NOTIFY_CEASE_CONNECT_REJECT);\n\n \t  return -1;\n \t}\n\n      if (BGP_DEBUG (events, EVENTS))\n\tzlog_debug (\"%s [Event] Transfer temporary BGP peer to existing one\",\n\t\t   peer->host);\n\n      bgp_stop (realpeer);\n      \n      /* Transfer file descriptor. */\n      realpeer->fd = peer->fd;\n      peer->fd = -1;\n\n      /* Transfer input buffer. */\n      stream_free (realpeer->ibuf);\n      realpeer->ibuf = peer->ibuf;\n      realpeer->packet_size = peer->packet_size;\n      peer->ibuf = NULL;\n\n      /* Transfer status. */\n      realpeer->status = peer->status;\n      bgp_stop (peer);\n      \n      /* peer pointer change. Open packet send to neighbor. */\n      peer = realpeer;\n      bgp_open_send (peer);\n      if (peer->fd < 0)\n\t{\n\t  zlog_err (\"bgp_open_receive peer's fd is negative value %d\",\n\t\t    peer->fd);\n\t  return -1;\n\t}\n      BGP_READ_ON (peer->t_read, bgp_read, peer->fd);\n    }\n\n  /* remote router-id check. */\n  if (remote_id.s_addr == 0\n      || ntohl (remote_id.s_addr) >= 0xe0000000\n      || ntohl (peer->local_id.s_addr) == ntohl (remote_id.s_addr))\n    {\n      if (BGP_DEBUG (normal, NORMAL))\n\tzlog_debug (\"%s bad OPEN, wrong router identifier %s\",\n\t\t   peer->host, inet_ntoa (remote_id));\n      bgp_notify_send_with_data (peer, \n\t\t\t\t BGP_NOTIFY_OPEN_ERR, \n\t\t\t\t BGP_NOTIFY_OPEN_BAD_BGP_IDENT,\n\t\t\t\t notify_data_remote_id, 4);\n      return -1;\n    }\n\n  /* Set remote router-id */\n  peer->remote_id = remote_id;\n\n  /* Peer BGP version check. */\n  if (version != BGP_VERSION_4)\n    {\n      u_int8_t maxver = BGP_VERSION_4;\n      if (BGP_DEBUG (normal, NORMAL))\n\tzlog_debug (\"%s bad protocol version, remote requested %d, local request %d\",\n\t\t   peer->host, version, BGP_VERSION_4);\n      bgp_notify_send_with_data (peer, \n\t\t\t\t BGP_NOTIFY_OPEN_ERR, \n\t\t\t\t BGP_NOTIFY_OPEN_UNSUP_VERSION,\n\t\t\t\t &maxver, 1);\n      return -1;\n    }\n\n  /* Check neighbor as number. */\n  if (remote_as != peer->as)\n    {\n      if (BGP_DEBUG (normal, NORMAL))\n\tzlog_debug (\"%s bad OPEN, remote AS is %d, expected %d\",\n\t\t   peer->host, remote_as, peer->as);\n      bgp_notify_send_with_data (peer, \n\t\t\t\t BGP_NOTIFY_OPEN_ERR, \n\t\t\t\t BGP_NOTIFY_OPEN_BAD_PEER_AS,\n\t\t\t\t notify_data_remote_as, 2);\n      return -1;\n    }\n\n  /* From the rfc: Upon receipt of an OPEN message, a BGP speaker MUST\n     calculate the value of the Hold Timer by using the smaller of its\n     configured Hold Time and the Hold Time received in the OPEN message.\n     The Hold Time MUST be either zero or at least three seconds.  An\n     implementation may reject connections on the basis of the Hold Time. */\n\n  if (holdtime < 3 && holdtime != 0)\n    {\n      bgp_notify_send (peer,\n\t\t       BGP_NOTIFY_OPEN_ERR, \n\t\t       BGP_NOTIFY_OPEN_UNACEP_HOLDTIME);\n      return -1;\n    }\n    \n  /* From the rfc: A reasonable maximum time between KEEPALIVE messages\n     would be one third of the Hold Time interval.  KEEPALIVE messages\n     MUST NOT be sent more frequently than one per second.  An\n     implementation MAY adjust the rate at which it sends KEEPALIVE\n     messages as a function of the Hold Time interval. */\n\n  if (CHECK_FLAG (peer->config, PEER_CONFIG_TIMER))\n    send_holdtime = peer->holdtime;\n  else\n    send_holdtime = peer->bgp->default_holdtime;\n\n  if (holdtime < send_holdtime)\n    peer->v_holdtime = holdtime;\n  else\n    peer->v_holdtime = send_holdtime;\n\n  peer->v_keepalive = peer->v_holdtime / 3;\n\n  /* Open option part parse. */\n  capability = 0;\n  optlen = stream_getc (peer->ibuf);\n  if (optlen != 0) \n    {\n      ret = bgp_open_option_parse (peer, optlen, &capability);\n      if (ret < 0)\n\treturn ret;\n    }\n  else\n    {\n      if (BGP_DEBUG (normal, NORMAL))\n\tzlog_debug (\"%s rcvd OPEN w/ OPTION parameter len: 0\",\n\t\t   peer->host);\n    }\n\n  /* Override capability. */\n  if (! capability || CHECK_FLAG (peer->flags, PEER_FLAG_OVERRIDE_CAPABILITY))\n    {\n      peer->afc_nego[AFI_IP][SAFI_UNICAST] = peer->afc[AFI_IP][SAFI_UNICAST];\n      peer->afc_nego[AFI_IP][SAFI_MULTICAST] = peer->afc[AFI_IP][SAFI_MULTICAST];\n      peer->afc_nego[AFI_IP6][SAFI_UNICAST] = peer->afc[AFI_IP6][SAFI_UNICAST];\n      peer->afc_nego[AFI_IP6][SAFI_MULTICAST] = peer->afc[AFI_IP6][SAFI_MULTICAST];\n    }\n\n  /* Get sockname. */\n  bgp_getsockname (peer);\n\n  BGP_EVENT_ADD (peer, Receive_OPEN_message);\n\n  peer->packet_size = 0;\n  if (peer->ibuf)\n    stream_reset (peer->ibuf);\n\n  return 0;\n}\n\n/* Parse BGP Update packet and make attribute object. */\nstatic int\nbgp_update_receive (struct peer *peer, bgp_size_t size)\n{\n  int ret;\n  u_char *end;\n  struct stream *s;\n  struct attr attr;\n  bgp_size_t attribute_len;\n  bgp_size_t update_len;\n  bgp_size_t withdraw_len;\n  struct bgp_nlri update;\n  struct bgp_nlri withdraw;\n  struct bgp_nlri mp_update;\n  struct bgp_nlri mp_withdraw;\n  char attrstr[BUFSIZ] = \"\";\n\n  /* Status must be Established. */\n  if (peer->status != Established) \n    {\n      zlog_err (\"%s [FSM] Update packet received under status %s\",\n\t\tpeer->host, LOOKUP (bgp_status_msg, peer->status));\n      bgp_notify_send (peer, BGP_NOTIFY_FSM_ERR, 0);\n      return -1;\n    }\n\n  /* Set initial values. */\n  memset (&attr, 0, sizeof (struct attr));\n  memset (&update, 0, sizeof (struct bgp_nlri));\n  memset (&withdraw, 0, sizeof (struct bgp_nlri));\n  memset (&mp_update, 0, sizeof (struct bgp_nlri));\n  memset (&mp_withdraw, 0, sizeof (struct bgp_nlri));\n\n  s = peer->ibuf;\n  end = stream_pnt (s) + size;\n\n  /* RFC1771 6.3 If the Unfeasible Routes Length or Total Attribute\n     Length is too large (i.e., if Unfeasible Routes Length + Total\n     Attribute Length + 23 exceeds the message Length), then the Error\n     Subcode is set to Malformed Attribute List.  */\n  if (stream_pnt (s) + 2 > end)\n    {\n      zlog_err (\"%s [Error] Update packet error\"\n\t\t\" (packet length is short for unfeasible length)\",\n\t\tpeer->host);\n      bgp_notify_send (peer, BGP_NOTIFY_UPDATE_ERR, \n\t\t       BGP_NOTIFY_UPDATE_MAL_ATTR);\n      return -1;\n    }\n\n  /* Unfeasible Route Length. */\n  withdraw_len = stream_getw (s);\n\n  /* Unfeasible Route Length check. */\n  if (stream_pnt (s) + withdraw_len > end)\n    {\n      zlog_err (\"%s [Error] Update packet error\"\n\t\t\" (packet unfeasible length overflow %d)\",\n\t\tpeer->host, withdraw_len);\n      bgp_notify_send (peer, BGP_NOTIFY_UPDATE_ERR, \n\t\t       BGP_NOTIFY_UPDATE_MAL_ATTR);\n      return -1;\n    }\n\n  /* Unfeasible Route packet format check. */\n  if (withdraw_len > 0)\n    {\n      ret = bgp_nlri_sanity_check (peer, AFI_IP, stream_pnt (s), withdraw_len);\n      if (ret < 0)\n\treturn -1;\n\n      if (BGP_DEBUG (packet, PACKET_RECV))\n\tzlog_debug (\"%s [Update:RECV] Unfeasible NLRI received\", peer->host);\n\n      withdraw.afi = AFI_IP;\n      withdraw.safi = SAFI_UNICAST;\n      withdraw.nlri = stream_pnt (s);\n      withdraw.length = withdraw_len;\n      stream_forward_getp (s, withdraw_len);\n    }\n  \n  /* Attribute total length check. */\n  if (stream_pnt (s) + 2 > end)\n    {\n      zlog_warn (\"%s [Error] Packet Error\"\n\t\t \" (update packet is short for attribute length)\",\n\t\t peer->host);\n      bgp_notify_send (peer, BGP_NOTIFY_UPDATE_ERR, \n\t\t       BGP_NOTIFY_UPDATE_MAL_ATTR);\n      return -1;\n    }\n\n  /* Fetch attribute total length. */\n  attribute_len = stream_getw (s);\n\n  /* Attribute length check. */\n  if (stream_pnt (s) + attribute_len > end)\n    {\n      zlog_warn (\"%s [Error] Packet Error\"\n\t\t \" (update packet attribute length overflow %d)\",\n\t\t peer->host, attribute_len);\n      bgp_notify_send (peer, BGP_NOTIFY_UPDATE_ERR, \n\t\t       BGP_NOTIFY_UPDATE_MAL_ATTR);\n      return -1;\n    }\n\n  /* Parse attribute when it exists. */\n  if (attribute_len)\n    {\n      ret = bgp_attr_parse (peer, &attr, attribute_len, \n\t\t\t    &mp_update, &mp_withdraw);\n      if (ret < 0)\n\treturn -1;\n    }\n\n  /* Logging the attribute. */\n  if (BGP_DEBUG (update, UPDATE_IN))\n    {\n      ret= bgp_dump_attr (peer, &attr, attrstr, BUFSIZ);\n\n      if (ret)\n\tzlog (peer->log, LOG_DEBUG, \"%s rcvd UPDATE w/ attr: %s\",\n\t      peer->host, attrstr);\n    }\n\n  /* Network Layer Reachability Information. */\n  update_len = end - stream_pnt (s);\n\n  if (update_len)\n    {\n      /* Check NLRI packet format and prefix length. */\n      ret = bgp_nlri_sanity_check (peer, AFI_IP, stream_pnt (s), update_len);\n      if (ret < 0)\n\treturn -1;\n\n      /* Set NLRI portion to structure. */\n      update.afi = AFI_IP;\n      update.safi = SAFI_UNICAST;\n      update.nlri = stream_pnt (s);\n      update.length = update_len;\n      stream_forward_getp (s, update_len);\n    }\n\n  /* NLRI is processed only when the peer is configured specific\n     Address Family and Subsequent Address Family. */\n  if (peer->afc[AFI_IP][SAFI_UNICAST])\n    {\n      if (withdraw.length)\n\tbgp_nlri_parse (peer, NULL, &withdraw);\n\n      if (update.length)\n\t{\n\t  /* We check well-known attribute only for IPv4 unicast\n\t     update. */\n\t  ret = bgp_attr_check (peer, &attr);\n\t  if (ret < 0)\n\t    return -1;\n\n\t  bgp_nlri_parse (peer, &attr, &update);\n\t}\n\n      if (mp_update.length\n\t  && mp_update.afi == AFI_IP \n\t  && mp_update.safi == SAFI_UNICAST)\n\tbgp_nlri_parse (peer, &attr, &mp_update);\n\n      if (mp_withdraw.length\n\t  && mp_withdraw.afi == AFI_IP \n\t  && mp_withdraw.safi == SAFI_UNICAST)\n\tbgp_nlri_parse (peer, NULL, &mp_withdraw);\n\n      if (! attribute_len && ! withdraw_len)\n\t{\n\t  /* End-of-RIB received */\n\t  SET_FLAG (peer->af_sflags[AFI_IP][SAFI_UNICAST],\n\t\t    PEER_STATUS_EOR_RECEIVED);\n\n\t  /* NSF delete stale route */\n\t  if (peer->nsf[AFI_IP][SAFI_UNICAST])\n\t    bgp_clear_stale_route (peer, AFI_IP, SAFI_UNICAST);\n\n\t  if (BGP_DEBUG (normal, NORMAL))\n\t    zlog (peer->log, LOG_DEBUG, \"rcvd End-of-RIB for IPv4 Unicast from %s\",\n\t\t  peer->host);\n\t}\n    }\n  if (peer->afc[AFI_IP][SAFI_MULTICAST])\n    {\n      if (mp_update.length\n\t  && mp_update.afi == AFI_IP \n\t  && mp_update.safi == SAFI_MULTICAST)\n\tbgp_nlri_parse (peer, &attr, &mp_update);\n\n      if (mp_withdraw.length\n\t  && mp_withdraw.afi == AFI_IP \n\t  && mp_withdraw.safi == SAFI_MULTICAST)\n\tbgp_nlri_parse (peer, NULL, &mp_withdraw);\n\n      if (! withdraw_len\n\t  && mp_withdraw.afi == AFI_IP\n\t  && mp_withdraw.safi == SAFI_MULTICAST\n\t  && mp_withdraw.length == 0)\n\t{\n\t  /* End-of-RIB received */\n\t  SET_FLAG (peer->af_sflags[AFI_IP][SAFI_MULTICAST],\n\t\t    PEER_STATUS_EOR_RECEIVED);\n\n\t  /* NSF delete stale route */\n\t  if (peer->nsf[AFI_IP][SAFI_MULTICAST])\n\t    bgp_clear_stale_route (peer, AFI_IP, SAFI_MULTICAST);\n\n\t  if (BGP_DEBUG (normal, NORMAL))\n\t    zlog (peer->log, LOG_DEBUG, \"rcvd End-of-RIB for IPv4 Multicast from %s\",\n\t\t  peer->host);\n\t}\n    }\n  if (peer->afc[AFI_IP6][SAFI_UNICAST])\n    {\n      if (mp_update.length \n\t  && mp_update.afi == AFI_IP6 \n\t  && mp_update.safi == SAFI_UNICAST)\n\tbgp_nlri_parse (peer, &attr, &mp_update);\n\n      if (mp_withdraw.length \n\t  && mp_withdraw.afi == AFI_IP6 \n\t  && mp_withdraw.safi == SAFI_UNICAST)\n\tbgp_nlri_parse (peer, NULL, &mp_withdraw);\n\n      if (! withdraw_len\n\t  && mp_withdraw.afi == AFI_IP6\n\t  && mp_withdraw.safi == SAFI_UNICAST\n\t  && mp_withdraw.length == 0)\n\t{\n\t  /* End-of-RIB received */\n\t  SET_FLAG (peer->af_sflags[AFI_IP6][SAFI_UNICAST], PEER_STATUS_EOR_RECEIVED);\n\n\t  /* NSF delete stale route */\n\t  if (peer->nsf[AFI_IP6][SAFI_UNICAST])\n\t    bgp_clear_stale_route (peer, AFI_IP6, SAFI_UNICAST);\n\n\t  if (BGP_DEBUG (normal, NORMAL))\n\t    zlog (peer->log, LOG_DEBUG, \"rcvd End-of-RIB for IPv6 Unicast from %s\",\n\t\t  peer->host);\n\t}\n    }\n  if (peer->afc[AFI_IP6][SAFI_MULTICAST])\n    {\n      if (mp_update.length \n\t  && mp_update.afi == AFI_IP6 \n\t  && mp_update.safi == SAFI_MULTICAST)\n\tbgp_nlri_parse (peer, &attr, &mp_update);\n\n      if (mp_withdraw.length \n\t  && mp_withdraw.afi == AFI_IP6 \n\t  && mp_withdraw.safi == SAFI_MULTICAST)\n\tbgp_nlri_parse (peer, NULL, &mp_withdraw);\n\n      if (! withdraw_len\n\t  && mp_withdraw.afi == AFI_IP6\n\t  && mp_withdraw.safi == SAFI_MULTICAST\n\t  && mp_withdraw.length == 0)\n\t{\n\t  /* End-of-RIB received */\n\n\t  /* NSF delete stale route */\n\t  if (peer->nsf[AFI_IP6][SAFI_MULTICAST])\n\t    bgp_clear_stale_route (peer, AFI_IP6, SAFI_MULTICAST);\n\n\t  if (BGP_DEBUG (update, UPDATE_IN))\n\t    zlog (peer->log, LOG_DEBUG, \"rcvd End-of-RIB for IPv6 Multicast from %s\",\n\t\t  peer->host);\n\t}\n    }\n  if (peer->afc[AFI_IP][SAFI_MPLS_VPN])\n    {\n      if (mp_update.length \n\t  && mp_update.afi == AFI_IP \n\t  && mp_update.safi == BGP_SAFI_VPNV4)\n\tbgp_nlri_parse_vpnv4 (peer, &attr, &mp_update);\n\n      if (mp_withdraw.length \n\t  && mp_withdraw.afi == AFI_IP \n\t  && mp_withdraw.safi == BGP_SAFI_VPNV4)\n\tbgp_nlri_parse_vpnv4 (peer, NULL, &mp_withdraw);\n\n      if (! withdraw_len\n\t  && mp_withdraw.afi == AFI_IP\n\t  && mp_withdraw.safi == BGP_SAFI_VPNV4\n\t  && mp_withdraw.length == 0)\n\t{\n\t  /* End-of-RIB received */\n\n\t  if (BGP_DEBUG (update, UPDATE_IN))\n\t    zlog (peer->log, LOG_DEBUG, \"rcvd End-of-RIB for VPNv4 Unicast from %s\",\n\t\t  peer->host);\n\t}\n    }\n\n  /* Everything is done.  We unintern temporary structures which\n     interned in bgp_attr_parse(). */\n  if (attr.aspath)\n    aspath_unintern (attr.aspath);\n  if (attr.community)\n    community_unintern (attr.community);\n  if (attr.extra)\n    {\n      if (attr.extra->ecommunity)\n        ecommunity_unintern (attr.extra->ecommunity);\n      if (attr.extra->cluster)\n        cluster_unintern (attr.extra->cluster);\n      if (attr.extra->transit)\n        transit_unintern (attr.extra->transit);\n      bgp_attr_extra_free (&attr);\n    }\n\n  /* If peering is stopped due to some reason, do not generate BGP\n     event.  */\n  if (peer->status != Established)\n    return 0;\n\n  /* Increment packet counter. */\n  peer->update_in++;\n  peer->update_time = time (NULL);\n\n  /* Generate BGP event. */\n  BGP_EVENT_ADD (peer, Receive_UPDATE_message);\n\n  return 0;\n}\n\n/* Notify message treatment function. */\nstatic void\nbgp_notify_receive (struct peer *peer, bgp_size_t size)\n{\n  struct bgp_notify bgp_notify;\n\n  if (peer->notify.data)\n    {\n      XFREE (MTYPE_TMP, peer->notify.data);\n      peer->notify.data = NULL;\n      peer->notify.length = 0;\n    }\n\n  bgp_notify.code = stream_getc (peer->ibuf);\n  bgp_notify.subcode = stream_getc (peer->ibuf);\n  bgp_notify.length = size - 2;\n  bgp_notify.data = NULL;\n\n  /* Preserv notify code and sub code. */\n  peer->notify.code = bgp_notify.code;\n  peer->notify.subcode = bgp_notify.subcode;\n  /* For further diagnostic record returned Data. */\n  if (bgp_notify.length)\n    {\n      peer->notify.length = size - 2;\n      peer->notify.data = XMALLOC (MTYPE_TMP, size - 2);\n      memcpy (peer->notify.data, stream_pnt (peer->ibuf), size - 2);\n    }\n\n  /* For debug */\n  {\n    int i;\n    int first = 0;\n    char c[4];\n\n    if (bgp_notify.length)\n      {\n\tbgp_notify.data = XMALLOC (MTYPE_TMP, bgp_notify.length * 3);\n\tfor (i = 0; i < bgp_notify.length; i++)\n\t  if (first)\n\t    {\n\t      sprintf (c, \" %02x\", stream_getc (peer->ibuf));\n\t      strcat (bgp_notify.data, c);\n\t    }\n\t  else\n\t    {\n\t      first = 1;\n\t      sprintf (c, \"%02x\", stream_getc (peer->ibuf));\n\t      strcpy (bgp_notify.data, c);\n\t    }\n      }\n\n    bgp_notify_print(peer, &bgp_notify, \"received\");\n    if (bgp_notify.data)\n      XFREE (MTYPE_TMP, bgp_notify.data);\n  }\n\n  /* peer count update */\n  peer->notify_in++;\n\n  if (peer->status == Established)\n    peer->last_reset = PEER_DOWN_NOTIFY_RECEIVED;\n\n  /* We have to check for Notify with Unsupported Optional Parameter.\n     in that case we fallback to open without the capability option.\n     But this done in bgp_stop. We just mark it here to avoid changing\n     the fsm tables.  */\n  if (bgp_notify.code == BGP_NOTIFY_OPEN_ERR &&\n      bgp_notify.subcode == BGP_NOTIFY_OPEN_UNSUP_PARAM )\n    UNSET_FLAG (peer->sflags, PEER_STATUS_CAPABILITY_OPEN);\n\n  /* Also apply to Unsupported Capability until remote router support\n     capability. */\n  if (bgp_notify.code == BGP_NOTIFY_OPEN_ERR &&\n      bgp_notify.subcode == BGP_NOTIFY_OPEN_UNSUP_CAPBL)\n    UNSET_FLAG (peer->sflags, PEER_STATUS_CAPABILITY_OPEN);\n\n  BGP_EVENT_ADD (peer, Receive_NOTIFICATION_message);\n}\n\n/* Keepalive treatment function -- get keepalive send keepalive */\nstatic void\nbgp_keepalive_receive (struct peer *peer, bgp_size_t size)\n{\n  if (BGP_DEBUG (keepalive, KEEPALIVE))  \n    zlog_debug (\"%s KEEPALIVE rcvd\", peer->host); \n  \n  BGP_EVENT_ADD (peer, Receive_KEEPALIVE_message);\n}\n\n/* Route refresh message is received. */\nstatic void\nbgp_route_refresh_receive (struct peer *peer, bgp_size_t size)\n{\n  afi_t afi;\n  safi_t safi;\n  u_char reserved;\n  struct stream *s;\n\n  /* If peer does not have the capability, send notification. */\n  if (! CHECK_FLAG (peer->cap, PEER_CAP_REFRESH_ADV))\n    {\n      plog_err (peer->log, \"%s [Error] BGP route refresh is not enabled\",\n\t\tpeer->host);\n      bgp_notify_send (peer,\n\t\t       BGP_NOTIFY_HEADER_ERR,\n\t\t       BGP_NOTIFY_HEADER_BAD_MESTYPE);\n      return;\n    }\n\n  /* Status must be Established. */\n  if (peer->status != Established) \n    {\n      plog_err (peer->log,\n\t\t\"%s [Error] Route refresh packet received under status %s\",\n\t\tpeer->host, LOOKUP (bgp_status_msg, peer->status));\n      bgp_notify_send (peer, BGP_NOTIFY_FSM_ERR, 0);\n      return;\n    }\n\n  s = peer->ibuf;\n  \n  /* Parse packet. */\n  afi = stream_getw (s);\n  reserved = stream_getc (s);\n  safi = stream_getc (s);\n\n  if (BGP_DEBUG (normal, NORMAL))\n    zlog_debug (\"%s rcvd REFRESH_REQ for afi/safi: %d/%d\",\n\t       peer->host, afi, safi);\n\n  /* Check AFI and SAFI. */\n  if ((afi != AFI_IP && afi != AFI_IP6)\n      || (safi != SAFI_UNICAST && safi != SAFI_MULTICAST\n\t  && safi != BGP_SAFI_VPNV4))\n    {\n      if (BGP_DEBUG (normal, NORMAL))\n\t{\n\t  zlog_debug (\"%s REFRESH_REQ for unrecognized afi/safi: %d/%d - ignored\",\n\t\t     peer->host, afi, safi);\n\t}\n      return;\n    }\n\n  /* Adjust safi code. */\n  if (safi == BGP_SAFI_VPNV4)\n    safi = SAFI_MPLS_VPN;\n\n  if (size != BGP_MSG_ROUTE_REFRESH_MIN_SIZE - BGP_HEADER_SIZE)\n    {\n      u_char *end;\n      u_char when_to_refresh;\n      u_char orf_type;\n      u_int16_t orf_len;\n\n      if (size - (BGP_MSG_ROUTE_REFRESH_MIN_SIZE - BGP_HEADER_SIZE) < 5)\n        {\n          zlog_info (\"%s ORF route refresh length error\", peer->host);\n          bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n          return;\n        }\n\n      when_to_refresh = stream_getc (s);\n      end = stream_pnt (s) + (size - 5);\n\n      while (stream_pnt (s) < end)\n\t{\n\t  orf_type = stream_getc (s); \n\t  orf_len = stream_getw (s);\n\n\t  if (orf_type == ORF_TYPE_PREFIX\n\t      || orf_type == ORF_TYPE_PREFIX_OLD)\n\t    {\n\t      u_char *p_pnt = stream_pnt (s);\n\t      u_char *p_end = stream_pnt (s) + orf_len;\n\t      struct orf_prefix orfp;\n\t      u_char common = 0;\n\t      u_int32_t seq;\n\t      int psize;\n\t      char name[BUFSIZ];\n\t      char buf[BUFSIZ];\n\t      int ret;\n\n\t      if (BGP_DEBUG (normal, NORMAL))\n\t\t{\n\t\t  zlog_debug (\"%s rcvd Prefixlist ORF(%d) length %d\",\n\t\t\t     peer->host, orf_type, orf_len);\n\t\t}\n\n\t      /* ORF prefix-list name */\n\t      sprintf (name, \"%s.%d.%d\", peer->host, afi, safi);\n\n\t      while (p_pnt < p_end)\n\t\t{\n\t\t  memset (&orfp, 0, sizeof (struct orf_prefix));\n\t\t  common = *p_pnt++;\n\t\t  if (common & ORF_COMMON_PART_REMOVE_ALL)\n\t\t    {\n\t\t      if (BGP_DEBUG (normal, NORMAL))\n\t\t\tzlog_debug (\"%s rcvd Remove-All pfxlist ORF request\", peer->host);\n\t\t      prefix_bgp_orf_remove_all (name);\n\t\t      break;\n\t\t    }\n\t\t  memcpy (&seq, p_pnt, sizeof (u_int32_t));\n\t\t  p_pnt += sizeof (u_int32_t);\n\t\t  orfp.seq = ntohl (seq);\n\t\t  orfp.ge = *p_pnt++;\n\t\t  orfp.le = *p_pnt++;\n\t\t  orfp.p.prefixlen = *p_pnt++;\n\t\t  orfp.p.family = afi2family (afi);\n\t\t  psize = PSIZE (orfp.p.prefixlen);\n\t\t  memcpy (&orfp.p.u.prefix, p_pnt, psize);\n\t\t  p_pnt += psize;\n\n\t\t  if (BGP_DEBUG (normal, NORMAL))\n\t\t    zlog_debug (\"%s rcvd %s %s seq %u %s/%d ge %d le %d\",\n\t\t\t       peer->host,\n\t\t\t       (common & ORF_COMMON_PART_REMOVE ? \"Remove\" : \"Add\"), \n\t\t\t       (common & ORF_COMMON_PART_DENY ? \"deny\" : \"permit\"),\n\t\t\t       orfp.seq, \n\t\t\t       inet_ntop (orfp.p.family, &orfp.p.u.prefix, buf, BUFSIZ),\n\t\t\t       orfp.p.prefixlen, orfp.ge, orfp.le);\n\n\t\t  ret = prefix_bgp_orf_set (name, afi, &orfp,\n\t\t\t\t (common & ORF_COMMON_PART_DENY ? 0 : 1 ),\n\t\t\t\t (common & ORF_COMMON_PART_REMOVE ? 0 : 1));\n\n\t\t  if (ret != CMD_SUCCESS)\n\t\t    {\n\t\t      if (BGP_DEBUG (normal, NORMAL))\n\t\t\tzlog_debug (\"%s Received misformatted prefixlist ORF. Remove All pfxlist\", peer->host);\n\t\t      prefix_bgp_orf_remove_all (name);\n\t\t      break;\n\t\t    }\n\t\t}\n\t      peer->orf_plist[afi][safi] =\n\t\t\t prefix_list_lookup (AFI_ORF_PREFIX, name);\n\t    }\n\t  stream_forward_getp (s, orf_len);\n\t}\n      if (BGP_DEBUG (normal, NORMAL))\n\tzlog_debug (\"%s rcvd Refresh %s ORF request\", peer->host,\n\t\t   when_to_refresh == REFRESH_DEFER ? \"Defer\" : \"Immediate\");\n      if (when_to_refresh == REFRESH_DEFER)\n\treturn;\n    }\n\n  /* First update is deferred until ORF or ROUTE-REFRESH is received */\n  if (CHECK_FLAG (peer->af_sflags[afi][safi], PEER_STATUS_ORF_WAIT_REFRESH))\n    UNSET_FLAG (peer->af_sflags[afi][safi], PEER_STATUS_ORF_WAIT_REFRESH);\n\n  /* Perform route refreshment to the peer */\n  bgp_announce_route (peer, afi, safi);\n}\n\nstatic int\nbgp_capability_msg_parse (struct peer *peer, u_char *pnt, bgp_size_t length)\n{\n  u_char *end;\n  struct capability_mp_data mpc;\n  struct capability_header *hdr;\n  u_char action;\n  struct bgp *bgp;\n  afi_t afi;\n  safi_t safi;\n\n  bgp = peer->bgp;\n  end = pnt + length;\n\n  while (pnt < end)\n    {      \n      /* We need at least action, capability code and capability length. */\n      if (pnt + 3 > end)\n        {\n          zlog_info (\"%s Capability length error\", peer->host);\n          bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n          return -1;\n        }\n      action = *pnt;\n      hdr = (struct capability_header *)(pnt + 1);\n      \n      /* Action value check.  */\n      if (action != CAPABILITY_ACTION_SET\n\t  && action != CAPABILITY_ACTION_UNSET)\n        {\n          zlog_info (\"%s Capability Action Value error %d\",\n\t\t     peer->host, action);\n          bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n          return -1;\n        }\n\n      if (BGP_DEBUG (normal, NORMAL))\n\tzlog_debug (\"%s CAPABILITY has action: %d, code: %u, length %u\",\n\t\t   peer->host, action, hdr->code, hdr->length);\n\n      /* Capability length check. */\n      if ((pnt + hdr->length + 3) > end)\n        {\n          zlog_info (\"%s Capability length error\", peer->host);\n          bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n          return -1;\n        }\n\n      /* Fetch structure to the byte stream. */\n      memcpy (&mpc, pnt + 3, sizeof (struct capability_mp_data));\n\n      /* We know MP Capability Code. */\n      if (hdr->code == CAPABILITY_CODE_MP)\n        {\n\t  afi = ntohs (mpc.afi);\n\t  safi = mpc.safi;\n\n          /* Ignore capability when override-capability is set. */\n          if (CHECK_FLAG (peer->flags, PEER_FLAG_OVERRIDE_CAPABILITY))\n\t    continue;\n          \n          if (!bgp_afi_safi_valid_indices (afi, &safi))\n            {\n              if (BGP_DEBUG (normal, NORMAL))\n                zlog_debug (\"%s Dynamic Capability MP_EXT afi/safi invalid\",\n                            peer->host, afi, safi);\n              continue;\n            }\n          \n\t  /* Address family check.  */\n          if (BGP_DEBUG (normal, NORMAL))\n            zlog_debug (\"%s CAPABILITY has %s MP_EXT CAP for afi/safi: %u/%u\",\n                       peer->host,\n                       action == CAPABILITY_ACTION_SET \n                       ? \"Advertising\" : \"Removing\",\n                       ntohs(mpc.afi) , mpc.safi);\n              \n          if (action == CAPABILITY_ACTION_SET)\n            {\n              peer->afc_recv[afi][safi] = 1;\n              if (peer->afc[afi][safi])\n                {\n                  peer->afc_nego[afi][safi] = 1;\n                  bgp_announce_route (peer, afi, safi);\n                }\n            }\n          else\n            {\n              peer->afc_recv[afi][safi] = 0;\n              peer->afc_nego[afi][safi] = 0;\n\n              if (peer_active_nego (peer))\n                bgp_clear_route (peer, afi, safi);\n              else\n                BGP_EVENT_ADD (peer, BGP_Stop);\n            }\n        }\n      else\n        {\n          zlog_warn (\"%s unrecognized capability code: %d - ignored\",\n                     peer->host, hdr->code);\n        }\n      pnt += hdr->length + 3;\n    }\n  return 0;\n}\n\n/* Dynamic Capability is received. */\nint\nbgp_capability_receive (struct peer *peer, bgp_size_t size)\n{\n  u_char *pnt;\n  int ret;\n\n  /* Fetch pointer. */\n  pnt = stream_pnt (peer->ibuf);\n\n  if (BGP_DEBUG (normal, NORMAL))\n    zlog_debug (\"%s rcv CAPABILITY\", peer->host);\n\n  /* If peer does not have the capability, send notification. */\n  if (! CHECK_FLAG (peer->cap, PEER_CAP_DYNAMIC_ADV))\n    {\n      plog_err (peer->log, \"%s [Error] BGP dynamic capability is not enabled\",\n\t\tpeer->host);\n      bgp_notify_send (peer,\n\t\t       BGP_NOTIFY_HEADER_ERR,\n\t\t       BGP_NOTIFY_HEADER_BAD_MESTYPE);\n      return;\n    }\n\n  /* Status must be Established. */\n  if (peer->status != Established)\n    {\n      plog_err (peer->log,\n\t\t\"%s [Error] Dynamic capability packet received under status %s\", peer->host, LOOKUP (bgp_status_msg, peer->status));\n      bgp_notify_send (peer, BGP_NOTIFY_FSM_ERR, 0);\n      return;\n    }\n\n  /* Parse packet. */\n  return bgp_capability_msg_parse (peer, pnt, size);\n}\n\f\n/* BGP read utility function. */\nstatic int\nbgp_read_packet (struct peer *peer)\n{\n  int nbytes;\n  int readsize;\n\n  readsize = peer->packet_size - stream_get_endp (peer->ibuf);\n\n  /* If size is zero then return. */\n  if (! readsize)\n    return 0;\n\n  /* Read packet from fd. */\n  nbytes = stream_read_unblock (peer->ibuf, peer->fd, readsize);\n\n  /* If read byte is smaller than zero then error occured. */\n  if (nbytes < 0) \n    {\n      if (errno == EAGAIN)\n\treturn -1;\n\n      plog_err (peer->log, \"%s [Error] bgp_read_packet error: %s\",\n\t\t peer->host, safe_strerror (errno));\n\n      if (peer->status == Established) \n\t{\n\t  if (CHECK_FLAG (peer->sflags, PEER_STATUS_NSF_MODE))\n\t    {\n\t      peer->last_reset = PEER_DOWN_NSF_CLOSE_SESSION;\n\t      SET_FLAG (peer->sflags, PEER_STATUS_NSF_WAIT);\n\t    }\n\t  else\n\t    peer->last_reset = PEER_DOWN_CLOSE_SESSION;\n\t}\n\n      BGP_EVENT_ADD (peer, TCP_fatal_error);\n      return -1;\n    }  \n\n  /* When read byte is zero : clear bgp peer and return */\n  if (nbytes == 0) \n    {\n      if (BGP_DEBUG (events, EVENTS))\n\tplog_debug (peer->log, \"%s [Event] BGP connection closed fd %d\",\n\t\t   peer->host, peer->fd);\n\n      if (peer->status == Established) \n\t{\n\t  if (CHECK_FLAG (peer->sflags, PEER_STATUS_NSF_MODE))\n\t    {\n\t      peer->last_reset = PEER_DOWN_NSF_CLOSE_SESSION;\n\t      SET_FLAG (peer->sflags, PEER_STATUS_NSF_WAIT);\n\t    }\n\t  else\n\t    peer->last_reset = PEER_DOWN_CLOSE_SESSION;\n\t}\n\n      BGP_EVENT_ADD (peer, TCP_connection_closed);\n      return -1;\n    }\n\n  /* We read partial packet. */\n  if (stream_get_endp (peer->ibuf) != peer->packet_size)\n    return -1;\n\n  return 0;\n}\n\n/* Marker check. */\nstatic int\nbgp_marker_all_one (struct stream *s, int length)\n{\n  int i;\n\n  for (i = 0; i < length; i++)\n    if (s->data[i] != 0xff)\n      return 0;\n\n  return 1;\n}\n\n/* Starting point of packet process function. */\nint\nbgp_read (struct thread *thread)\n{\n  int ret;\n  u_char type = 0;\n  struct peer *peer;\n  bgp_size_t size;\n  char notify_data_length[2];\n\n  /* Yes first of all get peer pointer. */\n  peer = THREAD_ARG (thread);\n  peer->t_read = NULL;\n\n  /* For non-blocking IO check. */\n  if (peer->status == Connect)\n    {\n      bgp_connect_check (peer);\n      goto done;\n    }\n  else\n    {\n      if (peer->fd < 0)\n\t{\n\t  zlog_err (\"bgp_read peer's fd is negative value %d\", peer->fd);\n\t  return -1;\n\t}\n      BGP_READ_ON (peer->t_read, bgp_read, peer->fd);\n    }\n\n  /* Read packet header to determine type of the packet */\n  if (peer->packet_size == 0)\n    peer->packet_size = BGP_HEADER_SIZE;\n\n  if (stream_get_endp (peer->ibuf) < BGP_HEADER_SIZE)\n    {\n      ret = bgp_read_packet (peer);\n\n      /* Header read error or partial read packet. */\n      if (ret < 0) \n\tgoto done;\n\n      /* Get size and type. */\n      stream_forward_getp (peer->ibuf, BGP_MARKER_SIZE);\n      memcpy (notify_data_length, stream_pnt (peer->ibuf), 2);\n      size = stream_getw (peer->ibuf);\n      type = stream_getc (peer->ibuf);\n\n      if (BGP_DEBUG (normal, NORMAL) && type != 2 && type != 0)\n\tzlog_debug (\"%s rcv message type %d, length (excl. header) %d\",\n\t\t   peer->host, type, size - BGP_HEADER_SIZE);\n\n      /* Marker check */\n      if (((type == BGP_MSG_OPEN) || (type == BGP_MSG_KEEPALIVE))\n\t  && ! bgp_marker_all_one (peer->ibuf, BGP_MARKER_SIZE))\n\t{\n\t  bgp_notify_send (peer,\n\t\t\t   BGP_NOTIFY_HEADER_ERR, \n\t\t\t   BGP_NOTIFY_HEADER_NOT_SYNC);\n\t  goto done;\n\t}\n\n      /* BGP type check. */\n      if (type != BGP_MSG_OPEN && type != BGP_MSG_UPDATE \n\t  && type != BGP_MSG_NOTIFY && type != BGP_MSG_KEEPALIVE \n\t  && type != BGP_MSG_ROUTE_REFRESH_NEW\n\t  && type != BGP_MSG_ROUTE_REFRESH_OLD\n\t  && type != BGP_MSG_CAPABILITY)\n\t{\n\t  if (BGP_DEBUG (normal, NORMAL))\n\t    plog_debug (peer->log,\n\t\t      \"%s unknown message type 0x%02x\",\n\t\t      peer->host, type);\n\t  bgp_notify_send_with_data (peer,\n\t\t\t\t     BGP_NOTIFY_HEADER_ERR,\n\t\t\t \t     BGP_NOTIFY_HEADER_BAD_MESTYPE,\n\t\t\t\t     &type, 1);\n\t  goto done;\n\t}\n      /* Mimimum packet length check. */\n      if ((size < BGP_HEADER_SIZE)\n\t  || (size > BGP_MAX_PACKET_SIZE)\n\t  || (type == BGP_MSG_OPEN && size < BGP_MSG_OPEN_MIN_SIZE)\n\t  || (type == BGP_MSG_UPDATE && size < BGP_MSG_UPDATE_MIN_SIZE)\n\t  || (type == BGP_MSG_NOTIFY && size < BGP_MSG_NOTIFY_MIN_SIZE)\n\t  || (type == BGP_MSG_KEEPALIVE && size != BGP_MSG_KEEPALIVE_MIN_SIZE)\n\t  || (type == BGP_MSG_ROUTE_REFRESH_NEW && size < BGP_MSG_ROUTE_REFRESH_MIN_SIZE)\n\t  || (type == BGP_MSG_ROUTE_REFRESH_OLD && size < BGP_MSG_ROUTE_REFRESH_MIN_SIZE)\n\t  || (type == BGP_MSG_CAPABILITY && size < BGP_MSG_CAPABILITY_MIN_SIZE))\n\t{\n\t  if (BGP_DEBUG (normal, NORMAL))\n\t    plog_debug (peer->log,\n\t\t      \"%s bad message length - %d for %s\",\n\t\t      peer->host, size, \n\t\t      type == 128 ? \"ROUTE-REFRESH\" :\n\t\t      bgp_type_str[(int) type]);\n\t  bgp_notify_send_with_data (peer,\n\t\t\t\t     BGP_NOTIFY_HEADER_ERR,\n\t\t\t  \t     BGP_NOTIFY_HEADER_BAD_MESLEN,\n\t\t\t\t     (u_char *) notify_data_length, 2);\n\t  goto done;\n\t}\n\n      /* Adjust size to message length. */\n      peer->packet_size = size;\n    }\n\n  ret = bgp_read_packet (peer);\n  if (ret < 0) \n    goto done;\n\n  /* Get size and type again. */\n  size = stream_getw_from (peer->ibuf, BGP_MARKER_SIZE);\n  type = stream_getc_from (peer->ibuf, BGP_MARKER_SIZE + 2);\n\n  /* BGP packet dump function. */\n  bgp_dump_packet (peer, type, peer->ibuf);\n  \n  size = (peer->packet_size - BGP_HEADER_SIZE);\n\n  /* Read rest of the packet and call each sort of packet routine */\n  switch (type) \n    {\n    case BGP_MSG_OPEN:\n      peer->open_in++;\n      bgp_open_receive (peer, size); /* XXX return value ignored! */\n      break;\n    case BGP_MSG_UPDATE:\n      peer->readtime = time(NULL);    /* Last read timer reset */\n      bgp_update_receive (peer, size);\n      break;\n    case BGP_MSG_NOTIFY:\n      bgp_notify_receive (peer, size);\n      break;\n    case BGP_MSG_KEEPALIVE:\n      peer->readtime = time(NULL);    /* Last read timer reset */\n      bgp_keepalive_receive (peer, size);\n      break;\n    case BGP_MSG_ROUTE_REFRESH_NEW:\n    case BGP_MSG_ROUTE_REFRESH_OLD:\n      peer->refresh_in++;\n      bgp_route_refresh_receive (peer, size);\n      break;\n    case BGP_MSG_CAPABILITY:\n      peer->dynamic_cap_in++;\n      bgp_capability_receive (peer, size);\n      break;\n    }\n\n  /* Clear input buffer. */\n  peer->packet_size = 0;\n  if (peer->ibuf)\n    stream_reset (peer->ibuf);\n\n done:\n  if (CHECK_FLAG (peer->sflags, PEER_STATUS_ACCEPT_PEER))\n    {\n      if (BGP_DEBUG (events, EVENTS))\n\tzlog_debug (\"%s [Event] Accepting BGP peer delete\", peer->host);\n      peer_delete (peer);\n    }\n  return 0;\n}\n", "/* BGP VTY interface.\n   Copyright (C) 1996, 97, 98, 99, 2000 Kunihiro Ishiguro\n\nThis file is part of GNU Zebra.\n\nGNU Zebra is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the\nFree Software Foundation; either version 2, or (at your option) any\nlater version.\n\nGNU Zebra is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GNU Zebra; see the file COPYING.  If not, write to the Free\nSoftware Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#include <zebra.h>\n\n#include \"command.h\"\n#include \"prefix.h\"\n#include \"plist.h\"\n#include \"buffer.h\"\n#include \"linklist.h\"\n#include \"stream.h\"\n#include \"thread.h\"\n#include \"log.h\"\n#include \"memory.h\"\n#include \"hash.h\"\n\n#include \"bgpd/bgpd.h\"\n#include \"bgpd/bgp_advertise.h\"\n#include \"bgpd/bgp_attr.h\"\n#include \"bgpd/bgp_aspath.h\"\n#include \"bgpd/bgp_community.h\"\n#include \"bgpd/bgp_ecommunity.h\"\n#include \"bgpd/bgp_damp.h\"\n#include \"bgpd/bgp_debug.h\"\n#include \"bgpd/bgp_fsm.h\"\n#include \"bgpd/bgp_mplsvpn.h\"\n#include \"bgpd/bgp_nexthop.h\"\n#include \"bgpd/bgp_open.h\"\n#include \"bgpd/bgp_regex.h\"\n#include \"bgpd/bgp_route.h\"\n#include \"bgpd/bgp_zebra.h\"\n#include \"bgpd/bgp_table.h\"\n#include \"bgpd/bgp_vty.h\"\n\nextern struct in_addr router_id_zebra;\n\n/* Utility function to get address family from current node.  */\nafi_t\nbgp_node_afi (struct vty *vty)\n{\n  if (vty->node == BGP_IPV6_NODE || vty->node == BGP_IPV6M_NODE)\n    return AFI_IP6;\n  return AFI_IP;\n}\n\n/* Utility function to get subsequent address family from current\n   node.  */\nsafi_t\nbgp_node_safi (struct vty *vty)\n{\n  if (vty->node == BGP_VPNV4_NODE)\n    return SAFI_MPLS_VPN;\n  if (vty->node == BGP_IPV4M_NODE || vty->node == BGP_IPV6M_NODE)\n    return SAFI_MULTICAST;\n  return SAFI_UNICAST;\n}\n\nstatic int\npeer_address_self_check (union sockunion *su)\n{\n  struct interface *ifp = NULL;\n\n  if (su->sa.sa_family == AF_INET)\n    ifp = if_lookup_by_ipv4_exact (&su->sin.sin_addr);\n#ifdef HAVE_IPV6\n  else if (su->sa.sa_family == AF_INET6)\n    ifp = if_lookup_by_ipv6_exact (&su->sin6.sin6_addr);\n#endif /* HAVE IPV6 */\n\n  if (ifp)\n    return 1;\n\n  return 0;\n}\n\n/* Utility function for looking up peer from VTY.  */\nstatic struct peer *\npeer_lookup_vty (struct vty *vty, const char *ip_str)\n{\n  int ret;\n  struct bgp *bgp;\n  union sockunion su;\n  struct peer *peer;\n\n  bgp = vty->index;\n\n  ret = str2sockunion (ip_str, &su);\n  if (ret < 0)\n    {\n      vty_out (vty, \"%% Malformed address: %s%s\", ip_str, VTY_NEWLINE);\n      return NULL;\n    }\n\n  peer = peer_lookup (bgp, &su);\n  if (! peer)\n    {\n      vty_out (vty, \"%% Specify remote-as or peer-group commands first%s\", VTY_NEWLINE);\n      return NULL;\n    }\n  return peer;\n}\n\n/* Utility function for looking up peer or peer group.  */\nstatic struct peer *\npeer_and_group_lookup_vty (struct vty *vty, const char *peer_str)\n{\n  int ret;\n  struct bgp *bgp;\n  union sockunion su;\n  struct peer *peer;\n  struct peer_group *group;\n\n  bgp = vty->index;\n\n  ret = str2sockunion (peer_str, &su);\n  if (ret == 0)\n    {\n      peer = peer_lookup (bgp, &su);\n      if (peer)\n\treturn peer;\n    }\n  else\n    {\n      group = peer_group_lookup (bgp, peer_str);\n      if (group)\n\treturn group->conf;\n    }\n\n  vty_out (vty, \"%% Specify remote-as or peer-group commands first%s\",\n\t   VTY_NEWLINE);\n\n  return NULL;\n}\n\nstatic int\nbgp_vty_return (struct vty *vty, int ret)\n{\n  const char *str = NULL;\n\n  switch (ret)\n    {\n    case BGP_ERR_INVALID_VALUE:\n      str = \"Invalid value\";\n      break;\n    case BGP_ERR_INVALID_FLAG:\n      str = \"Invalid flag\";\n      break;\n    case BGP_ERR_PEER_INACTIVE:\n      str = \"Activate the neighbor for the address family first\";\n      break;\n    case BGP_ERR_INVALID_FOR_PEER_GROUP_MEMBER:\n      str = \"Invalid command for a peer-group member\";\n      break;\n    case BGP_ERR_PEER_GROUP_SHUTDOWN:\n      str = \"Peer-group has been shutdown. Activate the peer-group first\";\n      break;\n    case BGP_ERR_PEER_GROUP_HAS_THE_FLAG:\n      str = \"This peer is a peer-group member.  Please change peer-group configuration\";\n      break;\n    case BGP_ERR_PEER_FLAG_CONFLICT:\n      str = \"Can't set override-capability and strict-capability-match at the same time\";\n      break;\n    case BGP_ERR_PEER_GROUP_MEMBER_EXISTS:\n      str = \"No activate for peergroup can be given only if peer-group has no members\";\n      break;\n    case BGP_ERR_PEER_BELONGS_TO_GROUP:\n      str = \"No activate for an individual peer-group member is invalid\";\n      break;\n    case BGP_ERR_PEER_GROUP_AF_UNCONFIGURED:\n      str = \"Activate the peer-group for the address family first\";\n      break;\n    case BGP_ERR_PEER_GROUP_NO_REMOTE_AS:\n      str = \"Specify remote-as or peer-group remote AS first\";\n      break;\n    case BGP_ERR_PEER_GROUP_CANT_CHANGE:\n      str = \"Cannot change the peer-group. Deconfigure first\";\n      break;\n    case BGP_ERR_PEER_GROUP_MISMATCH:\n      str = \"Cannot have different peer-group for the neighbor\";\n      break;\n    case BGP_ERR_PEER_FILTER_CONFLICT:\n      str = \"Prefix/distribute list can not co-exist\";\n      break;\n    case BGP_ERR_NOT_INTERNAL_PEER:\n      str = \"Invalid command. Not an internal neighbor\";\n      break;\n    case BGP_ERR_REMOVE_PRIVATE_AS:\n      str = \"Private AS cannot be removed for IBGP peers\";\n      break;\n    case BGP_ERR_LOCAL_AS_ALLOWED_ONLY_FOR_EBGP:\n      str = \"Local-AS allowed only for EBGP peers\";\n      break;\n    case BGP_ERR_CANNOT_HAVE_LOCAL_AS_SAME_AS:\n      str = \"Cannot have local-as same as BGP AS number\";\n      break;\n    }\n  if (str)\n    {\n      vty_out (vty, \"%% %s%s\", str, VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n  return CMD_SUCCESS;\n}\n\n/* BGP global configuration.  */\n\nDEFUN (bgp_multiple_instance_func,\n       bgp_multiple_instance_cmd,\n       \"bgp multiple-instance\",\n       BGP_STR\n       \"Enable bgp multiple instance\\n\")\n{\n  bgp_option_set (BGP_OPT_MULTIPLE_INSTANCE);\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_bgp_multiple_instance,\n       no_bgp_multiple_instance_cmd,\n       \"no bgp multiple-instance\",\n       NO_STR\n       BGP_STR\n       \"BGP multiple instance\\n\")\n{\n  int ret;\n\n  ret = bgp_option_unset (BGP_OPT_MULTIPLE_INSTANCE);\n  if (ret < 0)\n    {\n      vty_out (vty, \"%% There are more than two BGP instances%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n  return CMD_SUCCESS;\n}\n\nDEFUN (bgp_config_type,\n       bgp_config_type_cmd,\n       \"bgp config-type (cisco|zebra)\",\n       BGP_STR\n       \"Configuration type\\n\"\n       \"cisco\\n\"\n       \"zebra\\n\")\n{\n  if (strncmp (argv[0], \"c\", 1) == 0)\n    bgp_option_set (BGP_OPT_CONFIG_CISCO);\n  else\n    bgp_option_unset (BGP_OPT_CONFIG_CISCO);\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_bgp_config_type,\n       no_bgp_config_type_cmd,\n       \"no bgp config-type\",\n       NO_STR\n       BGP_STR\n       \"Display configuration type\\n\")\n{\n  bgp_option_unset (BGP_OPT_CONFIG_CISCO);\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_synchronization,\n       no_synchronization_cmd,\n       \"no synchronization\",\n       NO_STR\n       \"Perform IGP synchronization\\n\")\n{\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_auto_summary,\n       no_auto_summary_cmd,\n       \"no auto-summary\",\n       NO_STR\n       \"Enable automatic network number summarization\\n\")\n{\n  return CMD_SUCCESS;\n}\n\nDEFUN_DEPRECATED (neighbor_version,\n\t\t  neighbor_version_cmd,\n\t\t  NEIGHBOR_CMD \"version (4|4-)\",\n\t\t  NEIGHBOR_STR\n\t\t  NEIGHBOR_ADDR_STR\n\t\t  \"Set the BGP version to match a neighbor\\n\"\n\t\t  \"Neighbor's BGP version\\n\")\n{\n  return CMD_SUCCESS;\n}\n\f\n/* \"router bgp\" commands. */\nDEFUN (router_bgp, \n       router_bgp_cmd, \n       \"router bgp <1-65535>\",\n       ROUTER_STR\n       BGP_STR\n       AS_STR)\n{\n  int ret;\n  as_t as;\n  struct bgp *bgp;\n  const char *name = NULL;\n\n  VTY_GET_INTEGER_RANGE (\"AS\", as, argv[0], 1, 65535);\n\n  if (argc == 2)\n    name = argv[1];\n\n  ret = bgp_get (&bgp, &as, name);\n  switch (ret)\n    {\n    case BGP_ERR_MULTIPLE_INSTANCE_NOT_SET:\n      vty_out (vty, \"Please specify 'bgp multiple-instance' first%s\", \n\t       VTY_NEWLINE);\n      return CMD_WARNING;\n    case BGP_ERR_AS_MISMATCH:\n      vty_out (vty, \"BGP is already running; AS is %d%s\", as, VTY_NEWLINE);\n      return CMD_WARNING;\n    case BGP_ERR_INSTANCE_MISMATCH:\n      vty_out (vty, \"BGP view name and AS number mismatch%s\", VTY_NEWLINE);\n      vty_out (vty, \"BGP instance is already running; AS is %d%s\",\n\t       as, VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  vty->node = BGP_NODE;\n  vty->index = bgp;\n\n  return CMD_SUCCESS;\n}\n\nALIAS (router_bgp,\n       router_bgp_view_cmd,\n       \"router bgp <1-65535> view WORD\",\n       ROUTER_STR\n       BGP_STR\n       AS_STR\n       \"BGP view\\n\"\n       \"view name\\n\")\n\f\n/* \"no router bgp\" commands. */\nDEFUN (no_router_bgp,\n       no_router_bgp_cmd,\n       \"no router bgp <1-65535>\",\n       NO_STR\n       ROUTER_STR\n       BGP_STR\n       AS_STR)\n{\n  as_t as;\n  struct bgp *bgp;\n  const char *name = NULL;\n\n  VTY_GET_INTEGER_RANGE (\"AS\", as, argv[0], 1, 65535);\n\n  if (argc == 2)\n    name = argv[1];\n\n  /* Lookup bgp structure. */\n  bgp = bgp_lookup (as, name);\n  if (! bgp)\n    {\n      vty_out (vty, \"%% Can't find BGP instance%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  bgp_delete (bgp);\n\n  return CMD_SUCCESS;\n}\n\nALIAS (no_router_bgp,\n       no_router_bgp_view_cmd,\n       \"no router bgp <1-65535> view WORD\",\n       NO_STR\n       ROUTER_STR\n       BGP_STR\n       AS_STR\n       \"BGP view\\n\"\n       \"view name\\n\")\n\f\n/* BGP router-id.  */\n\nDEFUN (bgp_router_id,\n       bgp_router_id_cmd,\n       \"bgp router-id A.B.C.D\",\n       BGP_STR\n       \"Override configured router identifier\\n\"\n       \"Manually configured router identifier\\n\")\n{\n  int ret;\n  struct in_addr id;\n  struct bgp *bgp;\n\n  bgp = vty->index;\n\n  ret = inet_aton (argv[0], &id);\n  if (! ret)\n    {\n      vty_out (vty, \"%% Malformed bgp router identifier%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  bgp->router_id_static = id;\n  bgp_router_id_set (bgp, &id);\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_bgp_router_id,\n       no_bgp_router_id_cmd,\n       \"no bgp router-id\",\n       NO_STR\n       BGP_STR\n       \"Override configured router identifier\\n\")\n{\n  int ret;\n  struct in_addr id;\n  struct bgp *bgp;\n\n  bgp = vty->index;\n\n  if (argc == 1)\n    {\n      ret = inet_aton (argv[0], &id);\n      if (! ret)\n\t{\n\t  vty_out (vty, \"%% Malformed BGP router identifier%s\", VTY_NEWLINE);\n\t  return CMD_WARNING;\n\t}\n\n      if (! IPV4_ADDR_SAME (&bgp->router_id_static, &id))\n\t{\n\t  vty_out (vty, \"%% BGP router-id doesn't match%s\", VTY_NEWLINE);\n\t  return CMD_WARNING;\n\t}\n    }\n\n  bgp->router_id_static.s_addr = 0;\n  bgp_router_id_set (bgp, &router_id_zebra);\n\n  return CMD_SUCCESS;\n}\n\nALIAS (no_bgp_router_id,\n       no_bgp_router_id_val_cmd,\n       \"no bgp router-id A.B.C.D\",\n       NO_STR\n       BGP_STR\n       \"Override configured router identifier\\n\"\n       \"Manually configured router identifier\\n\")\n\f\n/* BGP Cluster ID.  */\n\nDEFUN (bgp_cluster_id,\n       bgp_cluster_id_cmd,\n       \"bgp cluster-id A.B.C.D\",\n       BGP_STR\n       \"Configure Route-Reflector Cluster-id\\n\"\n       \"Route-Reflector Cluster-id in IP address format\\n\")\n{\n  int ret;\n  struct bgp *bgp;\n  struct in_addr cluster;\n\n  bgp = vty->index;\n\n  ret = inet_aton (argv[0], &cluster);\n  if (! ret)\n    {\n      vty_out (vty, \"%% Malformed bgp cluster identifier%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  bgp_cluster_id_set (bgp, &cluster);\n\n  return CMD_SUCCESS;\n}\n\nALIAS (bgp_cluster_id,\n       bgp_cluster_id32_cmd,\n       \"bgp cluster-id <1-4294967295>\",\n       BGP_STR\n       \"Configure Route-Reflector Cluster-id\\n\"\n       \"Route-Reflector Cluster-id as 32 bit quantity\\n\")\n\nDEFUN (no_bgp_cluster_id,\n       no_bgp_cluster_id_cmd,\n       \"no bgp cluster-id\",\n       NO_STR\n       BGP_STR\n       \"Configure Route-Reflector Cluster-id\\n\")\n{\n  int ret;\n  struct bgp *bgp;\n  struct in_addr cluster;\n\n  bgp = vty->index;\n\n  if (argc == 1)\n    {\n      ret = inet_aton (argv[0], &cluster);\n      if (! ret)\n\t{\n\t  vty_out (vty, \"%% Malformed bgp cluster identifier%s\", VTY_NEWLINE);\n\t  return CMD_WARNING;\n\t}\n    }\n\n  bgp_cluster_id_unset (bgp);\n\n  return CMD_SUCCESS;\n}\n\nALIAS (no_bgp_cluster_id,\n       no_bgp_cluster_id_arg_cmd,\n       \"no bgp cluster-id A.B.C.D\",\n       NO_STR\n       BGP_STR\n       \"Configure Route-Reflector Cluster-id\\n\"\n       \"Route-Reflector Cluster-id in IP address format\\n\")\n\f\nDEFUN (bgp_confederation_identifier,\n       bgp_confederation_identifier_cmd,\n       \"bgp confederation identifier <1-65535>\",\n       \"BGP specific commands\\n\"\n       \"AS confederation parameters\\n\"\n       \"AS number\\n\"\n       \"Set routing domain confederation AS\\n\")\n{\n  struct bgp *bgp;\n  as_t as;\n\n  bgp = vty->index;\n\n  VTY_GET_INTEGER (\"AS\", as, argv[0]);\n\n  bgp_confederation_id_set (bgp, as);\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_bgp_confederation_identifier,\n       no_bgp_confederation_identifier_cmd,\n       \"no bgp confederation identifier\",\n       NO_STR\n       \"BGP specific commands\\n\"\n       \"AS confederation parameters\\n\"\n       \"AS number\\n\")\n{\n  struct bgp *bgp;\n  as_t as;\n\n  bgp = vty->index;\n\n  if (argc == 1)\n    VTY_GET_INTEGER (\"AS\", as, argv[0]);\n\n  bgp_confederation_id_unset (bgp);\n\n  return CMD_SUCCESS;\n}\n\nALIAS (no_bgp_confederation_identifier,\n       no_bgp_confederation_identifier_arg_cmd,\n       \"no bgp confederation identifier <1-65535>\",\n       NO_STR\n       \"BGP specific commands\\n\"\n       \"AS confederation parameters\\n\"\n       \"AS number\\n\"\n       \"Set routing domain confederation AS\\n\")\n\f\nDEFUN (bgp_confederation_peers,\n       bgp_confederation_peers_cmd,\n       \"bgp confederation peers .<1-65535>\",\n       \"BGP specific commands\\n\"\n       \"AS confederation parameters\\n\"\n       \"Peer ASs in BGP confederation\\n\"\n       AS_STR)\n{\n  struct bgp *bgp;\n  as_t as;\n  int i;\n\n  bgp = vty->index;\n\n  for (i = 0; i < argc; i++)\n    {\n      VTY_GET_INTEGER_RANGE (\"AS\", as, argv[i], 1, 65535);\n\n      if (bgp->as == as)\n\t{\n\t  vty_out (vty, \"%% Local member-AS not allowed in confed peer list%s\",\n\t\t   VTY_NEWLINE);\n\t  continue;\n\t}\n\n      bgp_confederation_peers_add (bgp, as);\n    }\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_bgp_confederation_peers,\n       no_bgp_confederation_peers_cmd,\n       \"no bgp confederation peers .<1-65535>\",\n       NO_STR\n       \"BGP specific commands\\n\"\n       \"AS confederation parameters\\n\"\n       \"Peer ASs in BGP confederation\\n\"\n       AS_STR)\n{\n  struct bgp *bgp;\n  as_t as;\n  int i;\n\n  bgp = vty->index;\n\n  for (i = 0; i < argc; i++)\n    {\n      VTY_GET_INTEGER_RANGE (\"AS\", as, argv[i], 1, 65535);\n      \n      bgp_confederation_peers_remove (bgp, as);\n    }\n  return CMD_SUCCESS;\n}\n\f\n/* BGP timers.  */\n\nDEFUN (bgp_timers,\n       bgp_timers_cmd,\n       \"timers bgp <0-65535> <0-65535>\",\n       \"Adjust routing timers\\n\"\n       \"BGP timers\\n\"\n       \"Keepalive interval\\n\"\n       \"Holdtime\\n\")\n{\n  struct bgp *bgp;\n  unsigned long keepalive = 0;\n  unsigned long holdtime = 0;\n\n  bgp = vty->index;\n\n  VTY_GET_INTEGER (\"keepalive\", keepalive, argv[0]);\n  VTY_GET_INTEGER (\"holdtime\", holdtime, argv[1]);\n\n  /* Holdtime value check. */\n  if (holdtime < 3 && holdtime != 0)\n    {\n      vty_out (vty, \"%% hold time value must be either 0 or greater than 3%s\",\n\t       VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  bgp_timers_set (bgp, keepalive, holdtime);\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_bgp_timers,\n       no_bgp_timers_cmd,\n       \"no timers bgp\",\n       NO_STR\n       \"Adjust routing timers\\n\"\n       \"BGP timers\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_timers_unset (bgp);\n\n  return CMD_SUCCESS;\n}\n\nALIAS (no_bgp_timers,\n       no_bgp_timers_arg_cmd,\n       \"no timers bgp <0-65535> <0-65535>\",\n       NO_STR\n       \"Adjust routing timers\\n\"\n       \"BGP timers\\n\"\n       \"Keepalive interval\\n\"\n       \"Holdtime\\n\")\n\f\nDEFUN (bgp_client_to_client_reflection,\n       bgp_client_to_client_reflection_cmd,\n       \"bgp client-to-client reflection\",\n       \"BGP specific commands\\n\"\n       \"Configure client to client route reflection\\n\"\n       \"reflection of routes allowed\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_flag_unset (bgp, BGP_FLAG_NO_CLIENT_TO_CLIENT);\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_bgp_client_to_client_reflection,\n       no_bgp_client_to_client_reflection_cmd,\n       \"no bgp client-to-client reflection\",\n       NO_STR\n       \"BGP specific commands\\n\"\n       \"Configure client to client route reflection\\n\"\n       \"reflection of routes allowed\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_flag_set (bgp, BGP_FLAG_NO_CLIENT_TO_CLIENT);\n  return CMD_SUCCESS;\n}\n\n/* \"bgp always-compare-med\" configuration. */\nDEFUN (bgp_always_compare_med,\n       bgp_always_compare_med_cmd,\n       \"bgp always-compare-med\",\n       \"BGP specific commands\\n\"\n       \"Allow comparing MED from different neighbors\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_flag_set (bgp, BGP_FLAG_ALWAYS_COMPARE_MED);\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_bgp_always_compare_med,\n       no_bgp_always_compare_med_cmd,\n       \"no bgp always-compare-med\",\n       NO_STR\n       \"BGP specific commands\\n\"\n       \"Allow comparing MED from different neighbors\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_flag_unset (bgp, BGP_FLAG_ALWAYS_COMPARE_MED);\n  return CMD_SUCCESS;\n}\n\f\n/* \"bgp deterministic-med\" configuration. */\nDEFUN (bgp_deterministic_med,\n       bgp_deterministic_med_cmd,\n       \"bgp deterministic-med\",\n       \"BGP specific commands\\n\"\n       \"Pick the best-MED path among paths advertised from the neighboring AS\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_flag_set (bgp, BGP_FLAG_DETERMINISTIC_MED);\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_bgp_deterministic_med,\n       no_bgp_deterministic_med_cmd,\n       \"no bgp deterministic-med\",\n       NO_STR\n       \"BGP specific commands\\n\"\n       \"Pick the best-MED path among paths advertised from the neighboring AS\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_flag_unset (bgp, BGP_FLAG_DETERMINISTIC_MED);\n  return CMD_SUCCESS;\n}\n\n/* \"bgp graceful-restart\" configuration. */\nDEFUN (bgp_graceful_restart,\n       bgp_graceful_restart_cmd,\n       \"bgp graceful-restart\",\n       \"BGP specific commands\\n\"\n       \"Graceful restart capability parameters\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_flag_set (bgp, BGP_FLAG_GRACEFUL_RESTART);\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_bgp_graceful_restart,\n       no_bgp_graceful_restart_cmd,\n       \"no bgp graceful-restart\",\n       NO_STR\n       \"BGP specific commands\\n\"\n       \"Graceful restart capability parameters\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_flag_unset (bgp, BGP_FLAG_GRACEFUL_RESTART);\n  return CMD_SUCCESS;\n}\n\nDEFUN (bgp_graceful_restart_stalepath_time,\n       bgp_graceful_restart_stalepath_time_cmd,\n       \"bgp graceful-restart stalepath-time <1-3600>\",\n       \"BGP specific commands\\n\"\n       \"Graceful restart capability parameters\\n\"\n       \"Set the max time to hold onto restarting peer's stale paths\\n\"\n       \"Delay value (seconds)\\n\")\n{\n  struct bgp *bgp;\n  u_int32_t stalepath;\n\n  bgp = vty->index;\n  if (! bgp)\n    return CMD_WARNING;\n\n  VTY_GET_INTEGER_RANGE (\"stalepath-time\", stalepath, argv[0], 1, 3600);\n  bgp->stalepath_time = stalepath;\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_bgp_graceful_restart_stalepath_time,\n       no_bgp_graceful_restart_stalepath_time_cmd,\n       \"no bgp graceful-restart stalepath-time\",\n       NO_STR\n       \"BGP specific commands\\n\"\n       \"Graceful restart capability parameters\\n\"\n       \"Set the max time to hold onto restarting peer's stale paths\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  if (! bgp)\n    return CMD_WARNING;\n\n  bgp->stalepath_time = BGP_DEFAULT_STALEPATH_TIME;\n  return CMD_SUCCESS;\n}\n\nALIAS (no_bgp_graceful_restart_stalepath_time,\n       no_bgp_graceful_restart_stalepath_time_val_cmd,\n       \"no bgp graceful-restart stalepath-time <1-3600>\",\n       NO_STR\n       \"BGP specific commands\\n\"\n       \"Graceful restart capability parameters\\n\"\n       \"Set the max time to hold onto restarting peer's stale paths\\n\"\n       \"Delay value (seconds)\\n\")\n\n/* \"bgp fast-external-failover\" configuration. */\nDEFUN (bgp_fast_external_failover,\n       bgp_fast_external_failover_cmd,\n       \"bgp fast-external-failover\",\n       BGP_STR\n       \"Immediately reset session if a link to a directly connected external peer goes down\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_flag_unset (bgp, BGP_FLAG_NO_FAST_EXT_FAILOVER);\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_bgp_fast_external_failover,\n       no_bgp_fast_external_failover_cmd,\n       \"no bgp fast-external-failover\",\n       NO_STR\n       BGP_STR\n       \"Immediately reset session if a link to a directly connected external peer goes down\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_flag_set (bgp, BGP_FLAG_NO_FAST_EXT_FAILOVER);\n  return CMD_SUCCESS;\n}\n\f\n/* \"bgp enforce-first-as\" configuration. */\nDEFUN (bgp_enforce_first_as,\n       bgp_enforce_first_as_cmd,\n       \"bgp enforce-first-as\",\n       BGP_STR\n       \"Enforce the first AS for EBGP routes\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_flag_set (bgp, BGP_FLAG_ENFORCE_FIRST_AS);\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_bgp_enforce_first_as,\n       no_bgp_enforce_first_as_cmd,\n       \"no bgp enforce-first-as\",\n       NO_STR\n       BGP_STR\n       \"Enforce the first AS for EBGP routes\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_flag_unset (bgp, BGP_FLAG_ENFORCE_FIRST_AS);\n  return CMD_SUCCESS;\n}\n\f\n/* \"bgp bestpath compare-routerid\" configuration.  */\nDEFUN (bgp_bestpath_compare_router_id,\n       bgp_bestpath_compare_router_id_cmd,\n       \"bgp bestpath compare-routerid\",\n       \"BGP specific commands\\n\"\n       \"Change the default bestpath selection\\n\"\n       \"Compare router-id for identical EBGP paths\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_flag_set (bgp, BGP_FLAG_COMPARE_ROUTER_ID);\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_bgp_bestpath_compare_router_id,\n       no_bgp_bestpath_compare_router_id_cmd,\n       \"no bgp bestpath compare-routerid\",\n       NO_STR\n       \"BGP specific commands\\n\"\n       \"Change the default bestpath selection\\n\"\n       \"Compare router-id for identical EBGP paths\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_flag_unset (bgp, BGP_FLAG_COMPARE_ROUTER_ID);\n  return CMD_SUCCESS;\n}\n\f\n/* \"bgp bestpath as-path ignore\" configuration.  */\nDEFUN (bgp_bestpath_aspath_ignore,\n       bgp_bestpath_aspath_ignore_cmd,\n       \"bgp bestpath as-path ignore\",\n       \"BGP specific commands\\n\"\n       \"Change the default bestpath selection\\n\"\n       \"AS-path attribute\\n\"\n       \"Ignore as-path length in selecting a route\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_flag_set (bgp, BGP_FLAG_ASPATH_IGNORE);\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_bgp_bestpath_aspath_ignore,\n       no_bgp_bestpath_aspath_ignore_cmd,\n       \"no bgp bestpath as-path ignore\",\n       NO_STR\n       \"BGP specific commands\\n\"\n       \"Change the default bestpath selection\\n\"\n       \"AS-path attribute\\n\"\n       \"Ignore as-path length in selecting a route\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_flag_unset (bgp, BGP_FLAG_ASPATH_IGNORE);\n  return CMD_SUCCESS;\n}\n\f\n/* \"bgp bestpath as-path confed\" configuration.  */\nDEFUN (bgp_bestpath_aspath_confed,\n       bgp_bestpath_aspath_confed_cmd,\n       \"bgp bestpath as-path confed\",\n       \"BGP specific commands\\n\"\n       \"Change the default bestpath selection\\n\"\n       \"AS-path attribute\\n\"\n       \"Compare path lengths including confederation sets & sequences in selecting a route\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_flag_set (bgp, BGP_FLAG_ASPATH_CONFED);\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_bgp_bestpath_aspath_confed,\n       no_bgp_bestpath_aspath_confed_cmd,\n       \"no bgp bestpath as-path confed\",\n       NO_STR\n       \"BGP specific commands\\n\"\n       \"Change the default bestpath selection\\n\"\n       \"AS-path attribute\\n\"\n       \"Compare path lengths including confederation sets & sequences in selecting a route\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_flag_unset (bgp, BGP_FLAG_ASPATH_CONFED);\n  return CMD_SUCCESS;\n}\n\f\n/* \"bgp log-neighbor-changes\" configuration.  */\nDEFUN (bgp_log_neighbor_changes,\n       bgp_log_neighbor_changes_cmd,\n       \"bgp log-neighbor-changes\",\n       \"BGP specific commands\\n\"\n       \"Log neighbor up/down and reset reason\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_flag_set (bgp, BGP_FLAG_LOG_NEIGHBOR_CHANGES);\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_bgp_log_neighbor_changes,\n       no_bgp_log_neighbor_changes_cmd,\n       \"no bgp log-neighbor-changes\",\n       NO_STR\n       \"BGP specific commands\\n\"\n       \"Log neighbor up/down and reset reason\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_flag_unset (bgp, BGP_FLAG_LOG_NEIGHBOR_CHANGES);\n  return CMD_SUCCESS;\n}\n\f\n/* \"bgp bestpath med\" configuration. */\nDEFUN (bgp_bestpath_med,\n       bgp_bestpath_med_cmd,\n       \"bgp bestpath med (confed|missing-as-worst)\",\n       \"BGP specific commands\\n\"\n       \"Change the default bestpath selection\\n\"\n       \"MED attribute\\n\"\n       \"Compare MED among confederation paths\\n\"\n       \"Treat missing MED as the least preferred one\\n\")\n{\n  struct bgp *bgp;\n  \n  bgp = vty->index;\n\n  if (strncmp (argv[0], \"confed\", 1) == 0)\n    bgp_flag_set (bgp, BGP_FLAG_MED_CONFED);\n  else\n    bgp_flag_set (bgp, BGP_FLAG_MED_MISSING_AS_WORST);\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (bgp_bestpath_med2,\n       bgp_bestpath_med2_cmd,\n       \"bgp bestpath med confed missing-as-worst\",\n       \"BGP specific commands\\n\"\n       \"Change the default bestpath selection\\n\"\n       \"MED attribute\\n\"\n       \"Compare MED among confederation paths\\n\"\n       \"Treat missing MED as the least preferred one\\n\")\n{\n  struct bgp *bgp;\n  \n  bgp = vty->index;\n  bgp_flag_set (bgp, BGP_FLAG_MED_CONFED);\n  bgp_flag_set (bgp, BGP_FLAG_MED_MISSING_AS_WORST);\n  return CMD_SUCCESS;\n}\n\nALIAS (bgp_bestpath_med2,\n       bgp_bestpath_med3_cmd,\n       \"bgp bestpath med missing-as-worst confed\",\n       \"BGP specific commands\\n\"\n       \"Change the default bestpath selection\\n\"\n       \"MED attribute\\n\"\n       \"Treat missing MED as the least preferred one\\n\"\n       \"Compare MED among confederation paths\\n\")\n\nDEFUN (no_bgp_bestpath_med,\n       no_bgp_bestpath_med_cmd,\n       \"no bgp bestpath med (confed|missing-as-worst)\",\n       NO_STR\n       \"BGP specific commands\\n\"\n       \"Change the default bestpath selection\\n\"\n       \"MED attribute\\n\"\n       \"Compare MED among confederation paths\\n\"\n       \"Treat missing MED as the least preferred one\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  \n  if (strncmp (argv[0], \"confed\", 1) == 0)\n    bgp_flag_unset (bgp, BGP_FLAG_MED_CONFED);\n  else\n    bgp_flag_unset (bgp, BGP_FLAG_MED_MISSING_AS_WORST);\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_bgp_bestpath_med2,\n       no_bgp_bestpath_med2_cmd,\n       \"no bgp bestpath med confed missing-as-worst\",\n       NO_STR\n       \"BGP specific commands\\n\"\n       \"Change the default bestpath selection\\n\"\n       \"MED attribute\\n\"\n       \"Compare MED among confederation paths\\n\"\n       \"Treat missing MED as the least preferred one\\n\")\n{\n  struct bgp *bgp;\n  \n  bgp = vty->index;\n  bgp_flag_unset (bgp, BGP_FLAG_MED_CONFED);\n  bgp_flag_unset (bgp, BGP_FLAG_MED_MISSING_AS_WORST);\n  return CMD_SUCCESS;\n}\n\nALIAS (no_bgp_bestpath_med2,\n       no_bgp_bestpath_med3_cmd,\n       \"no bgp bestpath med missing-as-worst confed\",\n       NO_STR\n       \"BGP specific commands\\n\"\n       \"Change the default bestpath selection\\n\"\n       \"MED attribute\\n\"\n       \"Treat missing MED as the least preferred one\\n\"\n       \"Compare MED among confederation paths\\n\")\n\f\n/* \"no bgp default ipv4-unicast\". */\nDEFUN (no_bgp_default_ipv4_unicast,\n       no_bgp_default_ipv4_unicast_cmd,\n       \"no bgp default ipv4-unicast\",\n       NO_STR\n       \"BGP specific commands\\n\"\n       \"Configure BGP defaults\\n\"\n       \"Activate ipv4-unicast for a peer by default\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_flag_set (bgp, BGP_FLAG_NO_DEFAULT_IPV4);\n  return CMD_SUCCESS;\n}\n\nDEFUN (bgp_default_ipv4_unicast,\n       bgp_default_ipv4_unicast_cmd,\n       \"bgp default ipv4-unicast\",\n       \"BGP specific commands\\n\"\n       \"Configure BGP defaults\\n\"\n       \"Activate ipv4-unicast for a peer by default\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_flag_unset (bgp, BGP_FLAG_NO_DEFAULT_IPV4);\n  return CMD_SUCCESS;\n}\n\f\n/* \"bgp import-check\" configuration.  */\nDEFUN (bgp_network_import_check,\n       bgp_network_import_check_cmd,\n       \"bgp network import-check\",\n       \"BGP specific commands\\n\"\n       \"BGP network command\\n\"\n       \"Check BGP network route exists in IGP\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_flag_set (bgp, BGP_FLAG_IMPORT_CHECK);\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_bgp_network_import_check,\n       no_bgp_network_import_check_cmd,\n       \"no bgp network import-check\",\n       NO_STR\n       \"BGP specific commands\\n\"\n       \"BGP network command\\n\"\n       \"Check BGP network route exists in IGP\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_flag_unset (bgp, BGP_FLAG_IMPORT_CHECK);\n  return CMD_SUCCESS;\n}\n\f\nDEFUN (bgp_default_local_preference,\n       bgp_default_local_preference_cmd,\n       \"bgp default local-preference <0-4294967295>\",\n       \"BGP specific commands\\n\"\n       \"Configure BGP defaults\\n\"\n       \"local preference (higher=more preferred)\\n\"\n       \"Configure default local preference value\\n\")\n{\n  struct bgp *bgp;\n  u_int32_t local_pref;\n\n  bgp = vty->index;\n\n  VTY_GET_INTEGER (\"local preference\", local_pref, argv[0]);\n\n  bgp_default_local_preference_set (bgp, local_pref);\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_bgp_default_local_preference,\n       no_bgp_default_local_preference_cmd,\n       \"no bgp default local-preference\",\n       NO_STR\n       \"BGP specific commands\\n\"\n       \"Configure BGP defaults\\n\"\n       \"local preference (higher=more preferred)\\n\")\n{\n  struct bgp *bgp;\n\n  bgp = vty->index;\n  bgp_default_local_preference_unset (bgp);\n  return CMD_SUCCESS;\n}\n\nALIAS (no_bgp_default_local_preference,\n       no_bgp_default_local_preference_val_cmd,\n       \"no bgp default local-preference <0-4294967295>\",\n       NO_STR\n       \"BGP specific commands\\n\"\n       \"Configure BGP defaults\\n\"\n       \"local preference (higher=more preferred)\\n\"\n       \"Configure default local preference value\\n\")\n\f\nstatic int\npeer_remote_as_vty (struct vty *vty, const char *peer_str, \n                    const char *as_str, afi_t afi, safi_t safi)\n{\n  int ret;\n  struct bgp *bgp;\n  as_t as;\n  union sockunion su;\n\n  bgp = vty->index;\n\n  /* Get AS number.  */\n  VTY_GET_INTEGER_RANGE (\"AS\", as, as_str, 1, 65535);\n\n  /* If peer is peer group, call proper function.  */\n  ret = str2sockunion (peer_str, &su);\n  if (ret < 0)\n    {\n      ret = peer_group_remote_as (bgp, peer_str, &as);\n      if (ret < 0)\n\t{\n\t  vty_out (vty, \"%% Create the peer-group first%s\", VTY_NEWLINE);\n\t  return CMD_WARNING;\n\t}\n      return CMD_SUCCESS;\n    }\n\n  if (peer_address_self_check (&su))\n    {\n      vty_out (vty, \"%% Can not configure the local system as neighbor%s\",\n\t       VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  ret = peer_remote_as (bgp, &su, &as, afi, safi);\n\n  /* This peer belongs to peer group.  */\n  switch (ret)\n    {\n    case BGP_ERR_PEER_GROUP_MEMBER:\n      vty_out (vty, \"%% Peer-group AS %d. Cannot configure remote-as for member%s\", as, VTY_NEWLINE);\n      return CMD_WARNING;\n    case BGP_ERR_PEER_GROUP_PEER_TYPE_DIFFERENT:\n      vty_out (vty, \"%% The AS# can not be changed from %d to %s, peer-group members must be all internal or all external%s\", as, as_str, VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n  return bgp_vty_return (vty, ret);\n}\n\nDEFUN (neighbor_remote_as,\n       neighbor_remote_as_cmd,\n       NEIGHBOR_CMD2 \"remote-as <1-65535>\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Specify a BGP neighbor\\n\"\n       AS_STR)\n{\n  return peer_remote_as_vty (vty, argv[0], argv[1], AFI_IP, SAFI_UNICAST);\n}\n\f\nDEFUN (neighbor_peer_group,\n       neighbor_peer_group_cmd,\n       \"neighbor WORD peer-group\",\n       NEIGHBOR_STR\n       \"Neighbor tag\\n\"\n       \"Configure peer-group\\n\")\n{\n  struct bgp *bgp;\n  struct peer_group *group;\n\n  bgp = vty->index;\n\n  group = peer_group_get (bgp, argv[0]);\n  if (! group)\n    return CMD_WARNING;\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_neighbor,\n       no_neighbor_cmd,\n       NO_NEIGHBOR_CMD2,\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2)\n{\n  int ret;\n  union sockunion su;\n  struct peer_group *group;\n  struct peer *peer;\n\n  ret = str2sockunion (argv[0], &su);\n  if (ret < 0)\n    {\n      group = peer_group_lookup (vty->index, argv[0]);\n      if (group)\n\tpeer_group_delete (group);\n      else\n\t{\n\t  vty_out (vty, \"%% Create the peer-group first%s\", VTY_NEWLINE);\n\t  return CMD_WARNING;\n\t}\n    }\n  else\n    {\n      peer = peer_lookup (vty->index, &su);\n      if (peer)\n        peer_delete (peer);\n    }\n\n  return CMD_SUCCESS;\n}\n\nALIAS (no_neighbor,\n       no_neighbor_remote_as_cmd,\n       NO_NEIGHBOR_CMD \"remote-as <1-65535>\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR\n       \"Specify a BGP neighbor\\n\"\n       AS_STR)\n\nDEFUN (no_neighbor_peer_group,\n       no_neighbor_peer_group_cmd,\n       \"no neighbor WORD peer-group\",\n       NO_STR\n       NEIGHBOR_STR\n       \"Neighbor tag\\n\"\n       \"Configure peer-group\\n\")\n{\n  struct peer_group *group;\n\n  group = peer_group_lookup (vty->index, argv[0]);\n  if (group)\n    peer_group_delete (group);\n  else\n    {\n      vty_out (vty, \"%% Create the peer-group first%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_neighbor_peer_group_remote_as,\n       no_neighbor_peer_group_remote_as_cmd,\n       \"no neighbor WORD remote-as <1-65535>\",\n       NO_STR\n       NEIGHBOR_STR\n       \"Neighbor tag\\n\"\n       \"Specify a BGP neighbor\\n\"\n       AS_STR)\n{\n  struct peer_group *group;\n\n  group = peer_group_lookup (vty->index, argv[0]);\n  if (group)\n    peer_group_remote_as_delete (group);\n  else\n    {\n      vty_out (vty, \"%% Create the peer-group first%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n  return CMD_SUCCESS;\n}\n\f\nDEFUN (neighbor_local_as,\n       neighbor_local_as_cmd,\n       NEIGHBOR_CMD2 \"local-as <1-65535>\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Specify a local-as number\\n\"\n       \"AS number used as local AS\\n\")\n{\n  struct peer *peer;\n  int ret;\n\n  peer = peer_and_group_lookup_vty (vty, argv[0]);\n  if (! peer)\n    return CMD_WARNING;\n\n  ret = peer_local_as_set (peer, atoi (argv[1]), 0);\n  return bgp_vty_return (vty, ret);\n}\n\nDEFUN (neighbor_local_as_no_prepend,\n       neighbor_local_as_no_prepend_cmd,\n       NEIGHBOR_CMD2 \"local-as <1-65535> no-prepend\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Specify a local-as number\\n\"\n       \"AS number used as local AS\\n\"\n       \"Do not prepend local-as to updates from ebgp peers\\n\")\n{\n  struct peer *peer;\n  int ret;\n\n  peer = peer_and_group_lookup_vty (vty, argv[0]);\n  if (! peer)\n    return CMD_WARNING;\n\n  ret = peer_local_as_set (peer, atoi (argv[1]), 1);\n  return bgp_vty_return (vty, ret);\n}\n\nDEFUN (no_neighbor_local_as,\n       no_neighbor_local_as_cmd,\n       NO_NEIGHBOR_CMD2 \"local-as\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Specify a local-as number\\n\")\n{\n  struct peer *peer;\n  int ret;\n\n  peer = peer_and_group_lookup_vty (vty, argv[0]);\n  if (! peer)\n    return CMD_WARNING;\n\n  ret = peer_local_as_unset (peer);\n  return bgp_vty_return (vty, ret);\n}\n\nALIAS (no_neighbor_local_as,\n       no_neighbor_local_as_val_cmd,\n       NO_NEIGHBOR_CMD2 \"local-as <1-65535>\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Specify a local-as number\\n\"\n       \"AS number used as local AS\\n\")\n\nALIAS (no_neighbor_local_as,\n       no_neighbor_local_as_val2_cmd,\n       NO_NEIGHBOR_CMD2 \"local-as <1-65535> no-prepend\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Specify a local-as number\\n\"\n       \"AS number used as local AS\\n\"\n       \"Do not prepend local-as to updates from ebgp peers\\n\")\n\f\nDEFUN (neighbor_activate,\n       neighbor_activate_cmd,\n       NEIGHBOR_CMD2 \"activate\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Enable the Address Family for this Neighbor\\n\")\n{\n  struct peer *peer;\n\n  peer = peer_and_group_lookup_vty (vty, argv[0]);\n  if (! peer)\n    return CMD_WARNING;\n\n  peer_activate (peer, bgp_node_afi (vty), bgp_node_safi (vty));\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_neighbor_activate,\n       no_neighbor_activate_cmd,\n       NO_NEIGHBOR_CMD2 \"activate\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Enable the Address Family for this Neighbor\\n\")\n{\n  int ret;\n  struct peer *peer;\n\n  /* Lookup peer. */\n  peer = peer_and_group_lookup_vty (vty, argv[0]);\n  if (! peer)\n    return CMD_WARNING;\n\n  ret = peer_deactivate (peer, bgp_node_afi (vty), bgp_node_safi (vty));\n\n  return bgp_vty_return (vty, ret);\n}\n\f\nDEFUN (neighbor_set_peer_group,\n       neighbor_set_peer_group_cmd,\n       NEIGHBOR_CMD \"peer-group WORD\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR\n       \"Member of the peer-group\\n\"\n       \"peer-group name\\n\")\n{\n  int ret;\n  as_t as;\n  union sockunion su;\n  struct bgp *bgp;\n  struct peer_group *group;\n\n  bgp = vty->index;\n\n  ret = str2sockunion (argv[0], &su);\n  if (ret < 0)\n    {\n      vty_out (vty, \"%% Malformed address: %s%s\", argv[0], VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  group = peer_group_lookup (bgp, argv[1]);\n  if (! group)\n    {\n      vty_out (vty, \"%% Configure the peer-group first%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  if (peer_address_self_check (&su))\n    {\n      vty_out (vty, \"%% Can not configure the local system as neighbor%s\",\n\t       VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  ret = peer_group_bind (bgp, &su, group, bgp_node_afi (vty), \n\t\t\t bgp_node_safi (vty), &as);\n\n  if (ret == BGP_ERR_PEER_GROUP_PEER_TYPE_DIFFERENT)\n    {\n      vty_out (vty, \"%% Peer with AS %d cannot be in this peer-group, members must be all internal or all external%s\", as, VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  return bgp_vty_return (vty, ret);\n}\n\nDEFUN (no_neighbor_set_peer_group,\n       no_neighbor_set_peer_group_cmd,\n       NO_NEIGHBOR_CMD \"peer-group WORD\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR\n       \"Member of the peer-group\\n\"\n       \"peer-group name\\n\")\n{\n  int ret;\n  struct bgp *bgp;\n  struct peer *peer;\n  struct peer_group *group;\n\n  bgp = vty->index;\n\n  peer = peer_lookup_vty (vty, argv[0]);\n  if (! peer)\n    return CMD_WARNING;\n\n  group = peer_group_lookup (bgp, argv[1]);\n  if (! group)\n    {\n      vty_out (vty, \"%% Configure the peer-group first%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  ret = peer_group_unbind (bgp, peer, group, bgp_node_afi (vty),\n\t\t\t   bgp_node_safi (vty));\n\n  return bgp_vty_return (vty, ret);\n}\n\f\nstatic int\npeer_flag_modify_vty (struct vty *vty, const char *ip_str, \n                      u_int16_t flag, int set)\n{\n  int ret;\n  struct peer *peer;\n\n  peer = peer_and_group_lookup_vty (vty, ip_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  if (set)\n    ret = peer_flag_set (peer, flag);\n  else\n    ret = peer_flag_unset (peer, flag);\n\n  return bgp_vty_return (vty, ret);\n}\n\nstatic int\npeer_flag_set_vty (struct vty *vty, const char *ip_str, u_int16_t flag)\n{\n  return peer_flag_modify_vty (vty, ip_str, flag, 1);\n}\n\nstatic int\npeer_flag_unset_vty (struct vty *vty, const char *ip_str, u_int16_t flag)\n{\n  return peer_flag_modify_vty (vty, ip_str, flag, 0);\n}\n\n/* neighbor passive. */\nDEFUN (neighbor_passive,\n       neighbor_passive_cmd,\n       NEIGHBOR_CMD2 \"passive\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Don't send open messages to this neighbor\\n\")\n{\n  return peer_flag_set_vty (vty, argv[0], PEER_FLAG_PASSIVE);\n}\n\nDEFUN (no_neighbor_passive,\n       no_neighbor_passive_cmd,\n       NO_NEIGHBOR_CMD2 \"passive\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Don't send open messages to this neighbor\\n\")\n{\n  return peer_flag_unset_vty (vty, argv[0], PEER_FLAG_PASSIVE);\n}\n\f\n/* neighbor shutdown. */\nDEFUN (neighbor_shutdown,\n       neighbor_shutdown_cmd,\n       NEIGHBOR_CMD2 \"shutdown\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Administratively shut down this neighbor\\n\")\n{\n  return peer_flag_set_vty (vty, argv[0], PEER_FLAG_SHUTDOWN);\n}\n\nDEFUN (no_neighbor_shutdown,\n       no_neighbor_shutdown_cmd,\n       NO_NEIGHBOR_CMD2 \"shutdown\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Administratively shut down this neighbor\\n\")\n{\n  return peer_flag_unset_vty (vty, argv[0], PEER_FLAG_SHUTDOWN);\n}\n\f\n/* Deprecated neighbor capability route-refresh. */\nDEFUN_DEPRECATED (neighbor_capability_route_refresh,\n\t\t  neighbor_capability_route_refresh_cmd,\n\t\t  NEIGHBOR_CMD2 \"capability route-refresh\",\n\t\t  NEIGHBOR_STR\n\t\t  NEIGHBOR_ADDR_STR2\n\t\t  \"Advertise capability to the peer\\n\"\n\t\t  \"Advertise route-refresh capability to this neighbor\\n\")\n{\n  return CMD_SUCCESS;\n}\n\nDEFUN_DEPRECATED (no_neighbor_capability_route_refresh,\n\t\t  no_neighbor_capability_route_refresh_cmd,\n\t\t  NO_NEIGHBOR_CMD2 \"capability route-refresh\",\n\t\t  NO_STR\n\t\t  NEIGHBOR_STR\n\t\t  NEIGHBOR_ADDR_STR2\n\t\t  \"Advertise capability to the peer\\n\"\n\t\t  \"Advertise route-refresh capability to this neighbor\\n\")\n{\n  return CMD_SUCCESS;\n}\n\f\n/* neighbor capability dynamic. */\nDEFUN (neighbor_capability_dynamic,\n       neighbor_capability_dynamic_cmd,\n       NEIGHBOR_CMD2 \"capability dynamic\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Advertise capability to the peer\\n\"\n       \"Advertise dynamic capability to this neighbor\\n\")\n{\n  return peer_flag_set_vty (vty, argv[0], PEER_FLAG_DYNAMIC_CAPABILITY);\n}\n\nDEFUN (no_neighbor_capability_dynamic,\n       no_neighbor_capability_dynamic_cmd,\n       NO_NEIGHBOR_CMD2 \"capability dynamic\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Advertise capability to the peer\\n\"\n       \"Advertise dynamic capability to this neighbor\\n\")\n{\n  return peer_flag_unset_vty (vty, argv[0], PEER_FLAG_DYNAMIC_CAPABILITY);\n}\n\f\n/* neighbor dont-capability-negotiate */\nDEFUN (neighbor_dont_capability_negotiate,\n       neighbor_dont_capability_negotiate_cmd,\n       NEIGHBOR_CMD2 \"dont-capability-negotiate\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Do not perform capability negotiation\\n\")\n{\n  return peer_flag_set_vty (vty, argv[0], PEER_FLAG_DONT_CAPABILITY);\n}\n\nDEFUN (no_neighbor_dont_capability_negotiate,\n       no_neighbor_dont_capability_negotiate_cmd,\n       NO_NEIGHBOR_CMD2 \"dont-capability-negotiate\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Do not perform capability negotiation\\n\")\n{\n  return peer_flag_unset_vty (vty, argv[0], PEER_FLAG_DONT_CAPABILITY);\n}\n\f\nstatic int\npeer_af_flag_modify_vty (struct vty *vty, const char *peer_str, afi_t afi,\n\t\t\t safi_t safi, u_int32_t flag, int set)\n{\n  int ret;\n  struct peer *peer;\n\n  peer = peer_and_group_lookup_vty (vty, peer_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  if (set)\n    ret = peer_af_flag_set (peer, afi, safi, flag);\n  else\n    ret = peer_af_flag_unset (peer, afi, safi, flag);\n\n  return bgp_vty_return (vty, ret);\n}\n\nstatic int\npeer_af_flag_set_vty (struct vty *vty, const char *peer_str, afi_t afi,\n\t\t      safi_t safi, u_int32_t flag)\n{\n  return peer_af_flag_modify_vty (vty, peer_str, afi, safi, flag, 1);\n}\n\nstatic int\npeer_af_flag_unset_vty (struct vty *vty, const char *peer_str, afi_t afi,\n\t\t\tsafi_t safi, u_int32_t flag)\n{\n  return peer_af_flag_modify_vty (vty, peer_str, afi, safi, flag, 0);\n}\n\f\n/* neighbor capability orf prefix-list. */\nDEFUN (neighbor_capability_orf_prefix,\n       neighbor_capability_orf_prefix_cmd,\n       NEIGHBOR_CMD2 \"capability orf prefix-list (both|send|receive)\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Advertise capability to the peer\\n\"\n       \"Advertise ORF capability to the peer\\n\"\n       \"Advertise prefixlist ORF capability to this neighbor\\n\"\n       \"Capability to SEND and RECEIVE the ORF to/from this neighbor\\n\"\n       \"Capability to RECEIVE the ORF from this neighbor\\n\"\n       \"Capability to SEND the ORF to this neighbor\\n\")\n{\n  u_int16_t flag = 0;\n\n  if (strncmp (argv[1], \"s\", 1) == 0)\n    flag = PEER_FLAG_ORF_PREFIX_SM;\n  else if (strncmp (argv[1], \"r\", 1) == 0)\n    flag = PEER_FLAG_ORF_PREFIX_RM;\n  else if (strncmp (argv[1], \"b\", 1) == 0)\n    flag = PEER_FLAG_ORF_PREFIX_SM|PEER_FLAG_ORF_PREFIX_RM;\n  else\n    return CMD_WARNING;\n\n  return peer_af_flag_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t       bgp_node_safi (vty), flag);\n}\n\nDEFUN (no_neighbor_capability_orf_prefix,\n       no_neighbor_capability_orf_prefix_cmd,\n       NO_NEIGHBOR_CMD2 \"capability orf prefix-list (both|send|receive)\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Advertise capability to the peer\\n\"\n       \"Advertise ORF capability to the peer\\n\"\n       \"Advertise prefixlist ORF capability to this neighbor\\n\"\n       \"Capability to SEND and RECEIVE the ORF to/from this neighbor\\n\"\n       \"Capability to RECEIVE the ORF from this neighbor\\n\"\n       \"Capability to SEND the ORF to this neighbor\\n\")\n{\n  u_int16_t flag = 0;\n\n  if (strncmp (argv[1], \"s\", 1) == 0)\n    flag = PEER_FLAG_ORF_PREFIX_SM;\n  else if (strncmp (argv[1], \"r\", 1) == 0)\n    flag = PEER_FLAG_ORF_PREFIX_RM;\n  else if (strncmp (argv[1], \"b\", 1) == 0)\n    flag = PEER_FLAG_ORF_PREFIX_SM|PEER_FLAG_ORF_PREFIX_RM;\n  else\n    return CMD_WARNING;\n\n  return peer_af_flag_unset_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t bgp_node_safi (vty), flag);\n}\n\f\n/* neighbor next-hop-self. */\nDEFUN (neighbor_nexthop_self,\n       neighbor_nexthop_self_cmd,\n       NEIGHBOR_CMD2 \"next-hop-self\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Disable the next hop calculation for this neighbor\\n\")\n{\n  return peer_af_flag_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t       bgp_node_safi (vty), PEER_FLAG_NEXTHOP_SELF);\n}\n\nDEFUN (no_neighbor_nexthop_self,\n       no_neighbor_nexthop_self_cmd,\n       NO_NEIGHBOR_CMD2 \"next-hop-self\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Disable the next hop calculation for this neighbor\\n\")\n{\n  return peer_af_flag_unset_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t bgp_node_safi (vty), PEER_FLAG_NEXTHOP_SELF);\n}\n\f\n/* neighbor remove-private-AS. */\nDEFUN (neighbor_remove_private_as,\n       neighbor_remove_private_as_cmd,\n       NEIGHBOR_CMD2 \"remove-private-AS\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Remove private AS number from outbound updates\\n\")\n{\n  return peer_af_flag_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t       bgp_node_safi (vty),\n\t\t\t       PEER_FLAG_REMOVE_PRIVATE_AS);\n}\n\nDEFUN (no_neighbor_remove_private_as,\n       no_neighbor_remove_private_as_cmd,\n       NO_NEIGHBOR_CMD2 \"remove-private-AS\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Remove private AS number from outbound updates\\n\")\n{\n  return peer_af_flag_unset_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t bgp_node_safi (vty),\n\t\t\t\t PEER_FLAG_REMOVE_PRIVATE_AS);\n}\n\f\n/* neighbor send-community. */\nDEFUN (neighbor_send_community,\n       neighbor_send_community_cmd,\n       NEIGHBOR_CMD2 \"send-community\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Send Community attribute to this neighbor\\n\")\n{\n  return peer_af_flag_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t       bgp_node_safi (vty),\n\t\t\t       PEER_FLAG_SEND_COMMUNITY);\n}\n\nDEFUN (no_neighbor_send_community,\n       no_neighbor_send_community_cmd,\n       NO_NEIGHBOR_CMD2 \"send-community\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Send Community attribute to this neighbor\\n\")\n{\n  return peer_af_flag_unset_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t bgp_node_safi (vty),\n\t\t\t\t PEER_FLAG_SEND_COMMUNITY);\n}\n\f\n/* neighbor send-community extended. */\nDEFUN (neighbor_send_community_type,\n       neighbor_send_community_type_cmd,\n       NEIGHBOR_CMD2 \"send-community (both|extended|standard)\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Send Community attribute to this neighbor\\n\"\n       \"Send Standard and Extended Community attributes\\n\"\n       \"Send Extended Community attributes\\n\"\n       \"Send Standard Community attributes\\n\")\n{\n  if (strncmp (argv[1], \"s\", 1) == 0)\n    return peer_af_flag_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t bgp_node_safi (vty),\n\t\t\t\t PEER_FLAG_SEND_COMMUNITY);\n  if (strncmp (argv[1], \"e\", 1) == 0)\n    return peer_af_flag_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t bgp_node_safi (vty),\n\t\t\t\t PEER_FLAG_SEND_EXT_COMMUNITY);\n\n  return peer_af_flag_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t       bgp_node_safi (vty),\n\t\t\t       (PEER_FLAG_SEND_COMMUNITY|\n\t\t\t\tPEER_FLAG_SEND_EXT_COMMUNITY));\n}\n\nDEFUN (no_neighbor_send_community_type,\n       no_neighbor_send_community_type_cmd,\n       NO_NEIGHBOR_CMD2 \"send-community (both|extended|standard)\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Send Community attribute to this neighbor\\n\"\n       \"Send Standard and Extended Community attributes\\n\"\n       \"Send Extended Community attributes\\n\"\n       \"Send Standard Community attributes\\n\")\n{\n  if (strncmp (argv[1], \"s\", 1) == 0)\n    return peer_af_flag_unset_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t   bgp_node_safi (vty),\n\t\t\t\t   PEER_FLAG_SEND_COMMUNITY);\n  if (strncmp (argv[1], \"e\", 1) == 0)\n    return peer_af_flag_unset_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t   bgp_node_safi (vty),\n\t\t\t\t   PEER_FLAG_SEND_EXT_COMMUNITY);\n\n  return peer_af_flag_unset_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t bgp_node_safi (vty),\n\t\t\t\t (PEER_FLAG_SEND_COMMUNITY |\n\t\t\t\t  PEER_FLAG_SEND_EXT_COMMUNITY));\n}\n\f\n/* neighbor soft-reconfig. */\nDEFUN (neighbor_soft_reconfiguration,\n       neighbor_soft_reconfiguration_cmd,\n       NEIGHBOR_CMD2 \"soft-reconfiguration inbound\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Per neighbor soft reconfiguration\\n\"\n       \"Allow inbound soft reconfiguration for this neighbor\\n\")\n{\n  return peer_af_flag_set_vty (vty, argv[0],\n\t\t\t       bgp_node_afi (vty), bgp_node_safi (vty),\n\t\t\t       PEER_FLAG_SOFT_RECONFIG);\n}\n\nDEFUN (no_neighbor_soft_reconfiguration,\n       no_neighbor_soft_reconfiguration_cmd,\n       NO_NEIGHBOR_CMD2 \"soft-reconfiguration inbound\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Per neighbor soft reconfiguration\\n\"\n       \"Allow inbound soft reconfiguration for this neighbor\\n\")\n{\n  return peer_af_flag_unset_vty (vty, argv[0],\n\t\t\t\t bgp_node_afi (vty), bgp_node_safi (vty),\n\t\t\t\t PEER_FLAG_SOFT_RECONFIG);\n}\n\f\nDEFUN (neighbor_route_reflector_client,\n       neighbor_route_reflector_client_cmd,\n       NEIGHBOR_CMD2 \"route-reflector-client\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Configure a neighbor as Route Reflector client\\n\")\n{\n  struct peer *peer;\n\n\n  peer = peer_and_group_lookup_vty (vty, argv[0]);\n  if (! peer)\n    return CMD_WARNING;\n\n  return peer_af_flag_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t       bgp_node_safi (vty),\n\t\t\t       PEER_FLAG_REFLECTOR_CLIENT);\n}\n\nDEFUN (no_neighbor_route_reflector_client,\n       no_neighbor_route_reflector_client_cmd,\n       NO_NEIGHBOR_CMD2 \"route-reflector-client\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Configure a neighbor as Route Reflector client\\n\")\n{\n  return peer_af_flag_unset_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t bgp_node_safi (vty),\n\t\t\t\t PEER_FLAG_REFLECTOR_CLIENT);\n}\n\f\nstatic int\npeer_rsclient_set_vty (struct vty *vty, const char *peer_str, \n                       int afi, int safi)\n{\n  int ret;\n  struct bgp *bgp;\n  struct peer *peer;\n  struct peer_group *group;\n  struct listnode *node, *nnode;\n  struct bgp_filter *pfilter;\n  struct bgp_filter *gfilter;\n\n  bgp = vty->index;\n\n  peer = peer_and_group_lookup_vty (vty, peer_str);\n  if ( ! peer )\n    return CMD_WARNING;\n\n  /* If it is already a RS-Client, don't do anything. */\n  if ( CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_RSERVER_CLIENT) )\n    return CMD_SUCCESS;\n\n  if ( ! peer_rsclient_active (peer) )\n    {\n      peer = peer_lock (peer); /* rsclient peer list reference */\n      listnode_add_sort (bgp->rsclient, peer);\n    }\n\n  ret = peer_af_flag_set (peer, afi, safi, PEER_FLAG_RSERVER_CLIENT);\n  if (ret < 0)\n    return bgp_vty_return (vty, ret);\n\n  peer->rib[afi][safi] = bgp_table_init (afi, safi);\n  peer->rib[afi][safi]->type = BGP_TABLE_RSCLIENT;\n  peer->rib[afi][safi]->owner = peer;\n\n  /* Check for existing 'network' and 'redistribute' routes. */\n  bgp_check_local_routes_rsclient (peer, afi, safi);\n\n  /* Check for routes for peers configured with 'soft-reconfiguration'. */\n  bgp_soft_reconfig_rsclient (peer, afi, safi);\n\n  if (CHECK_FLAG(peer->sflags, PEER_STATUS_GROUP))\n    {\n      group = peer->group;\n      gfilter = &peer->filter[afi][safi];\n\n      for (ALL_LIST_ELEMENTS (group->peer, node, nnode, peer))\n        {\n          pfilter = &peer->filter[afi][safi];\n\n          /* Members of a non-RS-Client group should not be RS-Clients, as that \n             is checked when the become part of the peer-group */\n          ret = peer_af_flag_set (peer, afi, safi, PEER_FLAG_RSERVER_CLIENT);\n          if (ret < 0)\n            return bgp_vty_return (vty, ret);\n\n          /* Make peer's RIB point to group's RIB. */\n          peer->rib[afi][safi] = group->conf->rib[afi][safi];\n\n          /* Import policy. */\n          if (pfilter->map[RMAP_IMPORT].name)\n            free (pfilter->map[RMAP_IMPORT].name);\n          if (gfilter->map[RMAP_IMPORT].name)\n            {\n              pfilter->map[RMAP_IMPORT].name = strdup (gfilter->map[RMAP_IMPORT].name);\n              pfilter->map[RMAP_IMPORT].map = gfilter->map[RMAP_IMPORT].map;\n            }\n          else\n            {\n              pfilter->map[RMAP_IMPORT].name = NULL;\n              pfilter->map[RMAP_IMPORT].map =NULL;\n            }\n\n          /* Export policy. */\n          if (gfilter->map[RMAP_EXPORT].name && ! pfilter->map[RMAP_EXPORT].name)\n            {\n              pfilter->map[RMAP_EXPORT].name = strdup (gfilter->map[RMAP_EXPORT].name);\n              pfilter->map[RMAP_EXPORT].map = gfilter->map[RMAP_EXPORT].map;\n            }\n        }\n    }\n  return CMD_SUCCESS;\n}\n\nstatic int\npeer_rsclient_unset_vty (struct vty *vty, const char *peer_str, \n                         int afi, int safi)\n{\n  int ret;\n  struct bgp *bgp;\n  struct peer *peer;\n  struct peer_group *group;\n  struct listnode *node, *nnode;\n\n  bgp = vty->index;\n\n  peer = peer_and_group_lookup_vty (vty, peer_str);\n  if ( ! peer )\n    return CMD_WARNING;\n\n  /* If it is not a RS-Client, don't do anything. */\n  if ( ! CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_RSERVER_CLIENT) )\n    return CMD_SUCCESS;\n\n  if (CHECK_FLAG(peer->sflags, PEER_STATUS_GROUP))\n    {\n      group = peer->group;\n\n      for (ALL_LIST_ELEMENTS (group->peer, node, nnode, peer))\n        {\n          ret = peer_af_flag_unset (peer, afi, safi, PEER_FLAG_RSERVER_CLIENT);\n          if (ret < 0)\n            return bgp_vty_return (vty, ret);\n\n          peer->rib[afi][safi] = NULL;\n        }\n\n        peer = group->conf;\n    }\n\n  ret = peer_af_flag_unset (peer, afi, safi, PEER_FLAG_RSERVER_CLIENT);\n  if (ret < 0)\n    return bgp_vty_return (vty, ret);\n\n  if ( ! peer_rsclient_active (peer) )\n    {\n      peer_unlock (peer); /* peer bgp rsclient reference */\n      listnode_delete (bgp->rsclient, peer);\n    }\n\n  bgp_table_finish (peer->rib[bgp_node_afi(vty)][bgp_node_safi(vty)]);\n\n  return CMD_SUCCESS;\n}\n\f\n/* neighbor route-server-client. */\nDEFUN (neighbor_route_server_client,\n       neighbor_route_server_client_cmd,\n       NEIGHBOR_CMD2 \"route-server-client\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Configure a neighbor as Route Server client\\n\")\n{\n  return peer_rsclient_set_vty (vty, argv[0], bgp_node_afi(vty),\n                  bgp_node_safi(vty));\n}\n\nDEFUN (no_neighbor_route_server_client,\n       no_neighbor_route_server_client_cmd,\n       NO_NEIGHBOR_CMD2 \"route-server-client\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Configure a neighbor as Route Server client\\n\")\n{\n  return peer_rsclient_unset_vty (vty, argv[0], bgp_node_afi(vty),\n                  bgp_node_safi(vty));\n}\n\f\nDEFUN (neighbor_nexthop_local_unchanged,\n       neighbor_nexthop_local_unchanged_cmd,\n       NEIGHBOR_CMD2 \"nexthop-local unchanged\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Configure treatment of outgoing link-local nexthop attribute\\n\"\n       \"Leave link-local nexthop unchanged for this peer\\n\")\n{\n  return peer_af_flag_set_vty (vty, argv[0], bgp_node_afi (vty),\n                                bgp_node_safi (vty),\n                                PEER_FLAG_NEXTHOP_LOCAL_UNCHANGED );\n}\n\f\nDEFUN (no_neighbor_nexthop_local_unchanged,\n       no_neighbor_nexthop_local_unchanged_cmd,\n       NO_NEIGHBOR_CMD2 \"nexthop-local unchanged\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Configure treatment of outgoing link-local-nexthop attribute\\n\"\n       \"Leave link-local nexthop unchanged for this peer\\n\")\n{\n  return peer_af_flag_unset_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t bgp_node_safi (vty),\n                                PEER_FLAG_NEXTHOP_LOCAL_UNCHANGED );\n}\n\f\nDEFUN (neighbor_attr_unchanged,\n       neighbor_attr_unchanged_cmd,\n       NEIGHBOR_CMD2 \"attribute-unchanged\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"BGP attribute is propagated unchanged to this neighbor\\n\")\n{\n  return peer_af_flag_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t       bgp_node_safi (vty),\n\t\t\t       (PEER_FLAG_AS_PATH_UNCHANGED |\n\t\t\t\tPEER_FLAG_NEXTHOP_UNCHANGED |\n\t\t\t\tPEER_FLAG_MED_UNCHANGED));\n}\n\nDEFUN (neighbor_attr_unchanged1,\n       neighbor_attr_unchanged1_cmd,\n       NEIGHBOR_CMD2 \"attribute-unchanged (as-path|next-hop|med)\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"BGP attribute is propagated unchanged to this neighbor\\n\"\n       \"As-path attribute\\n\"\n       \"Nexthop attribute\\n\"\n       \"Med attribute\\n\")\n{\n  u_int16_t flags = 0;\n\n  if (strncmp (argv[1], \"as-path\", 1) == 0)\n    SET_FLAG (flags, PEER_FLAG_AS_PATH_UNCHANGED);\n  else if (strncmp (argv[1], \"next-hop\", 1) == 0)\n    SET_FLAG (flags, PEER_FLAG_NEXTHOP_UNCHANGED);\n  else if (strncmp (argv[1], \"med\", 1) == 0)\n    SET_FLAG (flags, PEER_FLAG_MED_UNCHANGED);\n\n  return peer_af_flag_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t       bgp_node_safi (vty), flags);\n}\n\nDEFUN (neighbor_attr_unchanged2,\n       neighbor_attr_unchanged2_cmd,\n       NEIGHBOR_CMD2 \"attribute-unchanged as-path (next-hop|med)\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"BGP attribute is propagated unchanged to this neighbor\\n\"\n       \"As-path attribute\\n\"\n       \"Nexthop attribute\\n\"\n       \"Med attribute\\n\")\n{\n  u_int16_t flags = PEER_FLAG_AS_PATH_UNCHANGED;\n\n  if (strncmp (argv[1], \"next-hop\", 1) == 0)\n    SET_FLAG (flags, PEER_FLAG_NEXTHOP_UNCHANGED);\n  else if (strncmp (argv[1], \"med\", 1) == 0)\n    SET_FLAG (flags, PEER_FLAG_MED_UNCHANGED);\n\n  return peer_af_flag_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t       bgp_node_safi (vty), flags);\n\n}\n\nDEFUN (neighbor_attr_unchanged3,\n       neighbor_attr_unchanged3_cmd,\n       NEIGHBOR_CMD2 \"attribute-unchanged next-hop (as-path|med)\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"BGP attribute is propagated unchanged to this neighbor\\n\"\n       \"Nexthop attribute\\n\"\n       \"As-path attribute\\n\"\n       \"Med attribute\\n\")\n{\n  u_int16_t flags = PEER_FLAG_NEXTHOP_UNCHANGED;\n\n  if (strncmp (argv[1], \"as-path\", 1) == 0)\n    SET_FLAG (flags, PEER_FLAG_AS_PATH_UNCHANGED);\n  else if (strncmp (argv[1], \"med\", 1) == 0)\n    SET_FLAG (flags, PEER_FLAG_MED_UNCHANGED);\n\n  return peer_af_flag_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t       bgp_node_safi (vty), flags);\n}\n\nDEFUN (neighbor_attr_unchanged4,\n       neighbor_attr_unchanged4_cmd,\n       NEIGHBOR_CMD2 \"attribute-unchanged med (as-path|next-hop)\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"BGP attribute is propagated unchanged to this neighbor\\n\"\n       \"Med attribute\\n\"\n       \"As-path attribute\\n\"\n       \"Nexthop attribute\\n\")\n{\n  u_int16_t flags = PEER_FLAG_MED_UNCHANGED;\n\n  if (strncmp (argv[1], \"as-path\", 1) == 0)\n    SET_FLAG (flags, PEER_FLAG_AS_PATH_UNCHANGED);\n  else if (strncmp (argv[1], \"next-hop\", 1) == 0)\n    SET_FLAG (flags, PEER_FLAG_NEXTHOP_UNCHANGED);\n\n  return peer_af_flag_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t       bgp_node_safi (vty), flags);\n}\n\nALIAS (neighbor_attr_unchanged,\n       neighbor_attr_unchanged5_cmd,\n       NEIGHBOR_CMD2 \"attribute-unchanged as-path next-hop med\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"BGP attribute is propagated unchanged to this neighbor\\n\"\n       \"As-path attribute\\n\"\n       \"Nexthop attribute\\n\"\n       \"Med attribute\\n\")\n\nALIAS (neighbor_attr_unchanged,\n       neighbor_attr_unchanged6_cmd,\n       NEIGHBOR_CMD2 \"attribute-unchanged as-path med next-hop\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"BGP attribute is propagated unchanged to this neighbor\\n\"\n       \"As-path attribute\\n\"\n       \"Med attribute\\n\"\n       \"Nexthop attribute\\n\")\n\nALIAS (neighbor_attr_unchanged,\n       neighbor_attr_unchanged7_cmd,\n       NEIGHBOR_CMD2 \"attribute-unchanged next-hop med as-path\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"BGP attribute is propagated unchanged to this neighbor\\n\"\n       \"Nexthop attribute\\n\"\n       \"Med attribute\\n\"\n       \"As-path attribute\\n\")\n\nALIAS (neighbor_attr_unchanged,\n       neighbor_attr_unchanged8_cmd,\n       NEIGHBOR_CMD2 \"attribute-unchanged next-hop as-path med\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"BGP attribute is propagated unchanged to this neighbor\\n\"\n       \"Nexthop attribute\\n\"\n       \"As-path attribute\\n\"\n       \"Med attribute\\n\")\n\nALIAS (neighbor_attr_unchanged,\n       neighbor_attr_unchanged9_cmd,\n       NEIGHBOR_CMD2 \"attribute-unchanged med next-hop as-path\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"BGP attribute is propagated unchanged to this neighbor\\n\"\n       \"Med attribute\\n\"\n       \"Nexthop attribute\\n\"\n       \"As-path attribute\\n\")\n\nALIAS (neighbor_attr_unchanged,\n       neighbor_attr_unchanged10_cmd,\n       NEIGHBOR_CMD2 \"attribute-unchanged med as-path next-hop\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"BGP attribute is propagated unchanged to this neighbor\\n\"\n       \"Med attribute\\n\"\n       \"As-path attribute\\n\"\n       \"Nexthop attribute\\n\")\n\nDEFUN (no_neighbor_attr_unchanged,\n       no_neighbor_attr_unchanged_cmd,\n       NO_NEIGHBOR_CMD2 \"attribute-unchanged\",\n       NO_STR\t \n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"BGP attribute is propagated unchanged to this neighbor\\n\")\n{\n  return peer_af_flag_unset_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t bgp_node_safi (vty),\n\t\t\t\t (PEER_FLAG_AS_PATH_UNCHANGED |\n\t\t\t\t  PEER_FLAG_NEXTHOP_UNCHANGED |\n\t\t\t\t  PEER_FLAG_MED_UNCHANGED));\n}\n\nDEFUN (no_neighbor_attr_unchanged1,\n       no_neighbor_attr_unchanged1_cmd,\n       NO_NEIGHBOR_CMD2 \"attribute-unchanged (as-path|next-hop|med)\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"BGP attribute is propagated unchanged to this neighbor\\n\"\n       \"As-path attribute\\n\"\n       \"Nexthop attribute\\n\"\n       \"Med attribute\\n\")\n{\n  u_int16_t flags = 0;\n\n  if (strncmp (argv[1], \"as-path\", 1) == 0)\n    SET_FLAG (flags, PEER_FLAG_AS_PATH_UNCHANGED);\n  else if (strncmp (argv[1], \"next-hop\", 1) == 0)\n    SET_FLAG (flags, PEER_FLAG_NEXTHOP_UNCHANGED);\n  else if (strncmp (argv[1], \"med\", 1) == 0)\n    SET_FLAG (flags, PEER_FLAG_MED_UNCHANGED);\n\n  return peer_af_flag_unset_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t bgp_node_safi (vty), flags);\n}\n\nDEFUN (no_neighbor_attr_unchanged2,\n       no_neighbor_attr_unchanged2_cmd,\n       NO_NEIGHBOR_CMD2 \"attribute-unchanged as-path (next-hop|med)\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"BGP attribute is propagated unchanged to this neighbor\\n\"\n       \"As-path attribute\\n\"\n       \"Nexthop attribute\\n\"\n       \"Med attribute\\n\")\n{\n  u_int16_t flags = PEER_FLAG_AS_PATH_UNCHANGED;\n\n  if (strncmp (argv[1], \"next-hop\", 1) == 0)\n    SET_FLAG (flags, PEER_FLAG_NEXTHOP_UNCHANGED);\n  else if (strncmp (argv[1], \"med\", 1) == 0)\n    SET_FLAG (flags, PEER_FLAG_MED_UNCHANGED);\n\n  return peer_af_flag_unset_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t       bgp_node_safi (vty), flags);\n}\n\nDEFUN (no_neighbor_attr_unchanged3,\n       no_neighbor_attr_unchanged3_cmd,\n       NO_NEIGHBOR_CMD2 \"attribute-unchanged next-hop (as-path|med)\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"BGP attribute is propagated unchanged to this neighbor\\n\"\n       \"Nexthop attribute\\n\"\n       \"As-path attribute\\n\"\n       \"Med attribute\\n\")\n{\n  u_int16_t flags = PEER_FLAG_NEXTHOP_UNCHANGED;\n\n  if (strncmp (argv[1], \"as-path\", 1) == 0)\n    SET_FLAG (flags, PEER_FLAG_AS_PATH_UNCHANGED);\n  else if (strncmp (argv[1], \"med\", 1) == 0)\n    SET_FLAG (flags, PEER_FLAG_MED_UNCHANGED);\n\n  return peer_af_flag_unset_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t bgp_node_safi (vty), flags);\n}\n\nDEFUN (no_neighbor_attr_unchanged4,\n       no_neighbor_attr_unchanged4_cmd,\n       NO_NEIGHBOR_CMD2 \"attribute-unchanged med (as-path|next-hop)\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"BGP attribute is propagated unchanged to this neighbor\\n\"\n       \"Med attribute\\n\"\n       \"As-path attribute\\n\"\n       \"Nexthop attribute\\n\")\n{\n  u_int16_t flags = PEER_FLAG_MED_UNCHANGED;\n\n  if (strncmp (argv[1], \"as-path\", 1) == 0)\n    SET_FLAG (flags, PEER_FLAG_AS_PATH_UNCHANGED);\n  else if (strncmp (argv[1], \"next-hop\", 1) == 0)\n    SET_FLAG (flags, PEER_FLAG_NEXTHOP_UNCHANGED);\n\n  return peer_af_flag_unset_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t       bgp_node_safi (vty), flags);\n}\n\nALIAS (no_neighbor_attr_unchanged,\n       no_neighbor_attr_unchanged5_cmd,\n       NO_NEIGHBOR_CMD2 \"attribute-unchanged as-path next-hop med\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"BGP attribute is propagated unchanged to this neighbor\\n\"\n       \"As-path attribute\\n\"\n       \"Nexthop attribute\\n\"\n       \"Med attribute\\n\")\n\nALIAS (no_neighbor_attr_unchanged,\n       no_neighbor_attr_unchanged6_cmd,\n       NO_NEIGHBOR_CMD2 \"attribute-unchanged as-path med next-hop\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"BGP attribute is propagated unchanged to this neighbor\\n\"\n       \"As-path attribute\\n\"\n       \"Med attribute\\n\"\n       \"Nexthop attribute\\n\")\n\nALIAS (no_neighbor_attr_unchanged,\n       no_neighbor_attr_unchanged7_cmd,\n       NO_NEIGHBOR_CMD2 \"attribute-unchanged next-hop med as-path\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"BGP attribute is propagated unchanged to this neighbor\\n\"\n       \"Nexthop attribute\\n\"\n       \"Med attribute\\n\"\n       \"As-path attribute\\n\")\n\nALIAS (no_neighbor_attr_unchanged,\n       no_neighbor_attr_unchanged8_cmd,\n       NO_NEIGHBOR_CMD2 \"attribute-unchanged next-hop as-path med\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"BGP attribute is propagated unchanged to this neighbor\\n\"\n       \"Nexthop attribute\\n\"\n       \"As-path attribute\\n\"\n       \"Med attribute\\n\")\n\nALIAS (no_neighbor_attr_unchanged,\n       no_neighbor_attr_unchanged9_cmd,\n       NO_NEIGHBOR_CMD2 \"attribute-unchanged med next-hop as-path\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"BGP attribute is propagated unchanged to this neighbor\\n\"\n       \"Med attribute\\n\"\n       \"Nexthop attribute\\n\"\n       \"As-path attribute\\n\")\n\nALIAS (no_neighbor_attr_unchanged,\n       no_neighbor_attr_unchanged10_cmd,\n       NO_NEIGHBOR_CMD2 \"attribute-unchanged med as-path next-hop\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"BGP attribute is propagated unchanged to this neighbor\\n\"\n       \"Med attribute\\n\"\n       \"As-path attribute\\n\"\n       \"Nexthop attribute\\n\")\n\n/* For old version Zebra compatibility.  */\nDEFUN_DEPRECATED (neighbor_transparent_as,\n\t\t  neighbor_transparent_as_cmd,\n\t\t  NEIGHBOR_CMD \"transparent-as\",\n\t\t  NEIGHBOR_STR\n\t\t  NEIGHBOR_ADDR_STR\n\t\t  \"Do not append my AS number even peer is EBGP peer\\n\")\n{\n  return peer_af_flag_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t       bgp_node_safi (vty),\n\t\t\t       PEER_FLAG_AS_PATH_UNCHANGED);\n}\n\nDEFUN_DEPRECATED (neighbor_transparent_nexthop,\n\t\t  neighbor_transparent_nexthop_cmd,\n\t\t  NEIGHBOR_CMD \"transparent-nexthop\",\n\t\t  NEIGHBOR_STR\n\t\t  NEIGHBOR_ADDR_STR\n\t\t  \"Do not change nexthop even peer is EBGP peer\\n\")\n{\n  return peer_af_flag_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t       bgp_node_safi (vty),\n\t\t\t       PEER_FLAG_NEXTHOP_UNCHANGED);\n}\n\f\n/* EBGP multihop configuration. */\nstatic int\npeer_ebgp_multihop_set_vty (struct vty *vty, const char *ip_str, \n                            const char *ttl_str)\n{\n  struct peer *peer;\n  unsigned int ttl;\n\n  peer = peer_and_group_lookup_vty (vty, ip_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  if (! ttl_str)\n    ttl = TTL_MAX;\n  else\n    VTY_GET_INTEGER_RANGE (\"TTL\", ttl, ttl_str, 1, 255);\n\n  peer_ebgp_multihop_set (peer, ttl);\n\n  return CMD_SUCCESS;\n}\n\nstatic int\npeer_ebgp_multihop_unset_vty (struct vty *vty, const char *ip_str) \n{\n  struct peer *peer;\n\n  peer = peer_and_group_lookup_vty (vty, ip_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  peer_ebgp_multihop_unset (peer);\n\n  return CMD_SUCCESS;\n}\n\n/* neighbor ebgp-multihop. */\nDEFUN (neighbor_ebgp_multihop,\n       neighbor_ebgp_multihop_cmd,\n       NEIGHBOR_CMD2 \"ebgp-multihop\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Allow EBGP neighbors not on directly connected networks\\n\")\n{\n  return peer_ebgp_multihop_set_vty (vty, argv[0], NULL);\n}\n\nDEFUN (neighbor_ebgp_multihop_ttl,\n       neighbor_ebgp_multihop_ttl_cmd,\n       NEIGHBOR_CMD2 \"ebgp-multihop <1-255>\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Allow EBGP neighbors not on directly connected networks\\n\"\n       \"maximum hop count\\n\")\n{\n  return peer_ebgp_multihop_set_vty (vty, argv[0], argv[1]);\n}\n\nDEFUN (no_neighbor_ebgp_multihop,\n       no_neighbor_ebgp_multihop_cmd,\n       NO_NEIGHBOR_CMD2 \"ebgp-multihop\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Allow EBGP neighbors not on directly connected networks\\n\")\n{\n  return peer_ebgp_multihop_unset_vty (vty, argv[0]);\n}\n\nALIAS (no_neighbor_ebgp_multihop,\n       no_neighbor_ebgp_multihop_ttl_cmd,\n       NO_NEIGHBOR_CMD2 \"ebgp-multihop <1-255>\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Allow EBGP neighbors not on directly connected networks\\n\"\n       \"maximum hop count\\n\")\n\f\n/* disable-connected-check */\nDEFUN (neighbor_disable_connected_check,\n       neighbor_disable_connected_check_cmd,\n       NEIGHBOR_CMD2 \"disable-connected-check\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"one-hop away EBGP peer using loopback address\\n\")\n{\n  return peer_flag_set_vty (vty, argv[0], PEER_FLAG_DISABLE_CONNECTED_CHECK);\n}\n\nDEFUN (no_neighbor_disable_connected_check,\n       no_neighbor_disable_connected_check_cmd,\n       NO_NEIGHBOR_CMD2 \"disable-connected-check\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"one-hop away EBGP peer using loopback address\\n\")\n{\n  return peer_flag_unset_vty (vty, argv[0], PEER_FLAG_DISABLE_CONNECTED_CHECK);\n}\n\n/* Enforce multihop.  */\nALIAS (neighbor_disable_connected_check,\n       neighbor_enforce_multihop_cmd,\n       NEIGHBOR_CMD2 \"enforce-multihop\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Enforce EBGP neighbors perform multihop\\n\")\n\n/* Enforce multihop.  */\nALIAS (no_neighbor_disable_connected_check,\n       no_neighbor_enforce_multihop_cmd,\n       NO_NEIGHBOR_CMD2 \"enforce-multihop\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Enforce EBGP neighbors perform multihop\\n\")\n\f\nDEFUN (neighbor_description,\n       neighbor_description_cmd,\n       NEIGHBOR_CMD2 \"description .LINE\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Neighbor specific description\\n\"\n       \"Up to 80 characters describing this neighbor\\n\")\n{\n  struct peer *peer;\n  char *str;\n\n  peer = peer_and_group_lookup_vty (vty, argv[0]);\n  if (! peer)\n    return CMD_WARNING;\n\n  if (argc == 1)\n    return CMD_SUCCESS;\n\n  str = argv_concat(argv, argc, 1);\n\n  peer_description_set (peer, str);\n\n  XFREE (MTYPE_TMP, str);\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_neighbor_description,\n       no_neighbor_description_cmd,\n       NO_NEIGHBOR_CMD2 \"description\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Neighbor specific description\\n\")\n{\n  struct peer *peer;\n\n  peer = peer_and_group_lookup_vty (vty, argv[0]);\n  if (! peer)\n    return CMD_WARNING;\n\n  peer_description_unset (peer);\n\n  return CMD_SUCCESS;\n}\n\nALIAS (no_neighbor_description,\n       no_neighbor_description_val_cmd,\n       NO_NEIGHBOR_CMD2 \"description .LINE\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Neighbor specific description\\n\"\n       \"Up to 80 characters describing this neighbor\\n\")\n\f\n/* Neighbor update-source. */\nstatic int\npeer_update_source_vty (struct vty *vty, const char *peer_str, \n                        const char *source_str)\n{\n  struct peer *peer;\n  union sockunion *su;\n\n  peer = peer_and_group_lookup_vty (vty, peer_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  if (source_str)\n    {\n      su = sockunion_str2su (source_str);\n      if (su)\n\t{\n\t  peer_update_source_addr_set (peer, su);\n\t  sockunion_free (su);\n\t}\n      else\n\tpeer_update_source_if_set (peer, source_str);\n    }\n  else\n    peer_update_source_unset (peer);\n\n  return CMD_SUCCESS;\n}\n\n#define BGP_UPDATE_SOURCE_STR \"(A.B.C.D|WORD)\"\n#define BGP_UPDATE_SOURCE_HELP_STR \\\n  \"IPv4 address\\n\" \\\n  \"Interface name\\n\"\n\nDEFUN (neighbor_update_source,\n       neighbor_update_source_cmd,\n       NEIGHBOR_CMD2 \"update-source \" BGP_UPDATE_SOURCE_STR,\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Source of routing updates\\n\"\n       BGP_UPDATE_SOURCE_HELP_STR)\n{\n  return peer_update_source_vty (vty, argv[0], argv[1]);\n}\n\nDEFUN (no_neighbor_update_source,\n       no_neighbor_update_source_cmd,\n       NO_NEIGHBOR_CMD2 \"update-source\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Source of routing updates\\n\")\n{\n  return peer_update_source_vty (vty, argv[0], NULL);\n}\n\f\nstatic int\npeer_default_originate_set_vty (struct vty *vty, const char *peer_str, \n                                afi_t afi, safi_t safi, \n                                const char *rmap, int set)\n{\n  int ret;\n  struct peer *peer;\n\n  peer = peer_and_group_lookup_vty (vty, peer_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  if (set)\n    ret = peer_default_originate_set (peer, afi, safi, rmap);\n  else\n    ret = peer_default_originate_unset (peer, afi, safi);\n\n  return bgp_vty_return (vty, ret);\n}\n\n/* neighbor default-originate. */\nDEFUN (neighbor_default_originate,\n       neighbor_default_originate_cmd,\n       NEIGHBOR_CMD2 \"default-originate\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Originate default route to this neighbor\\n\")\n{\n  return peer_default_originate_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t\t bgp_node_safi (vty), NULL, 1);\n}\n\nDEFUN (neighbor_default_originate_rmap,\n       neighbor_default_originate_rmap_cmd,\n       NEIGHBOR_CMD2 \"default-originate route-map WORD\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Originate default route to this neighbor\\n\"\n       \"Route-map to specify criteria to originate default\\n\"\n       \"route-map name\\n\")\n{\n  return peer_default_originate_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t\t bgp_node_safi (vty), argv[1], 1);\n}\n\nDEFUN (no_neighbor_default_originate,\n       no_neighbor_default_originate_cmd,\n       NO_NEIGHBOR_CMD2 \"default-originate\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Originate default route to this neighbor\\n\")\n{\n  return peer_default_originate_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t\t bgp_node_safi (vty), NULL, 0);\n}\n\nALIAS (no_neighbor_default_originate,\n       no_neighbor_default_originate_rmap_cmd,\n       NO_NEIGHBOR_CMD2 \"default-originate route-map WORD\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Originate default route to this neighbor\\n\"\n       \"Route-map to specify criteria to originate default\\n\"\n       \"route-map name\\n\")\n\f\n/* Set neighbor's BGP port.  */\nstatic int\npeer_port_vty (struct vty *vty, const char *ip_str, int afi, \n               const char *port_str)\n{\n  struct peer *peer;\n  u_int16_t port;\n  struct servent *sp;\n\n  peer = peer_lookup_vty (vty, ip_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  if (! port_str)\n    { \n      sp = getservbyname (\"bgp\", \"tcp\");\n      port = (sp == NULL) ? BGP_PORT_DEFAULT : ntohs (sp->s_port);\n    }\n  else\n    {\n      VTY_GET_INTEGER(\"port\", port, port_str);\n    }\n\n  peer_port_set (peer, port);\n\n  return CMD_SUCCESS;\n}\n\n/* Set specified peer's BGP port.  */\nDEFUN (neighbor_port,\n       neighbor_port_cmd,\n       NEIGHBOR_CMD \"port <0-65535>\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR\n       \"Neighbor's BGP port\\n\"\n       \"TCP port number\\n\")\n{\n  return peer_port_vty (vty, argv[0], AFI_IP, argv[1]);\n}\n\nDEFUN (no_neighbor_port,\n       no_neighbor_port_cmd,\n       NO_NEIGHBOR_CMD \"port\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR\n       \"Neighbor's BGP port\\n\")\n{\n  return peer_port_vty (vty, argv[0], AFI_IP, NULL);\n}\n\nALIAS (no_neighbor_port,\n       no_neighbor_port_val_cmd,\n       NO_NEIGHBOR_CMD \"port <0-65535>\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR\n       \"Neighbor's BGP port\\n\"\n       \"TCP port number\\n\")\n\f\n/* neighbor weight. */\nstatic int\npeer_weight_set_vty (struct vty *vty, const char *ip_str, \n                     const char *weight_str)\n{\n  int ret;\n  struct peer *peer;\n  unsigned long weight;\n\n  peer = peer_and_group_lookup_vty (vty, ip_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  VTY_GET_INTEGER_RANGE(\"weight\", weight, weight_str, 0, 65535);\n\n  ret = peer_weight_set (peer, weight);\n\n  return CMD_SUCCESS;\n}\n\nstatic int\npeer_weight_unset_vty (struct vty *vty, const char *ip_str)\n{\n  struct peer *peer;\n\n  peer = peer_and_group_lookup_vty (vty, ip_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  peer_weight_unset (peer);\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (neighbor_weight,\n       neighbor_weight_cmd,\n       NEIGHBOR_CMD2 \"weight <0-65535>\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Set default weight for routes from this neighbor\\n\"\n       \"default weight\\n\")\n{\n  return peer_weight_set_vty (vty, argv[0], argv[1]);\n}\n\nDEFUN (no_neighbor_weight,\n       no_neighbor_weight_cmd,\n       NO_NEIGHBOR_CMD2 \"weight\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Set default weight for routes from this neighbor\\n\")\n{\n  return peer_weight_unset_vty (vty, argv[0]);\n}\n\nALIAS (no_neighbor_weight,\n       no_neighbor_weight_val_cmd,\n       NO_NEIGHBOR_CMD2 \"weight <0-65535>\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Set default weight for routes from this neighbor\\n\"\n       \"default weight\\n\")\n\f\n/* Override capability negotiation. */\nDEFUN (neighbor_override_capability,\n       neighbor_override_capability_cmd,\n       NEIGHBOR_CMD2 \"override-capability\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Override capability negotiation result\\n\")\n{\n  return peer_flag_set_vty (vty, argv[0], PEER_FLAG_OVERRIDE_CAPABILITY);\n}\n\nDEFUN (no_neighbor_override_capability,\n       no_neighbor_override_capability_cmd,\n       NO_NEIGHBOR_CMD2 \"override-capability\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Override capability negotiation result\\n\")\n{\n  return peer_flag_unset_vty (vty, argv[0], PEER_FLAG_OVERRIDE_CAPABILITY);\n}\n\f\nDEFUN (neighbor_strict_capability,\n       neighbor_strict_capability_cmd,\n       NEIGHBOR_CMD \"strict-capability-match\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR\n       \"Strict capability negotiation match\\n\")\n{\n  return peer_flag_set_vty (vty, argv[0], PEER_FLAG_STRICT_CAP_MATCH);\n}\n\nDEFUN (no_neighbor_strict_capability,\n       no_neighbor_strict_capability_cmd,\n       NO_NEIGHBOR_CMD \"strict-capability-match\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR\n       \"Strict capability negotiation match\\n\")\n{\n  return peer_flag_unset_vty (vty, argv[0], PEER_FLAG_STRICT_CAP_MATCH);\n}\n\f\nstatic int\npeer_timers_set_vty (struct vty *vty, const char *ip_str, \n                     const char *keep_str, const char *hold_str)\n{\n  int ret;\n  struct peer *peer;\n  u_int32_t keepalive;\n  u_int32_t holdtime;\n\n  peer = peer_and_group_lookup_vty (vty, ip_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  VTY_GET_INTEGER_RANGE (\"Keepalive\", keepalive, keep_str, 0, 65535);\n  VTY_GET_INTEGER_RANGE (\"Holdtime\", holdtime, hold_str, 0, 65535);\n\n  ret = peer_timers_set (peer, keepalive, holdtime);\n\n  return bgp_vty_return (vty, ret);\n}\n\f\nstatic int\npeer_timers_unset_vty (struct vty *vty, const char *ip_str)\n{\n  int ret;\n  struct peer *peer;\n\n  peer = peer_lookup_vty (vty, ip_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  ret = peer_timers_unset (peer);\n\n  return bgp_vty_return (vty, ret);\n}\n\nDEFUN (neighbor_timers,\n       neighbor_timers_cmd,\n       NEIGHBOR_CMD2 \"timers <0-65535> <0-65535>\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"BGP per neighbor timers\\n\"\n       \"Keepalive interval\\n\"\n       \"Holdtime\\n\")\n{\n  return peer_timers_set_vty (vty, argv[0], argv[1], argv[2]);\n}\n\nDEFUN (no_neighbor_timers,\n       no_neighbor_timers_cmd,\n       NO_NEIGHBOR_CMD2 \"timers\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"BGP per neighbor timers\\n\")\n{\n  return peer_timers_unset_vty (vty, argv[0]);\n}\n\f\nstatic int\npeer_timers_connect_set_vty (struct vty *vty, const char *ip_str, \n                             const char *time_str)\n{\n  int ret;\n  struct peer *peer;\n  u_int32_t connect;\n\n  peer = peer_lookup_vty (vty, ip_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  VTY_GET_INTEGER_RANGE (\"Connect time\", connect, time_str, 0, 65535);\n\n  ret = peer_timers_connect_set (peer, connect);\n\n  return CMD_SUCCESS;\n}\n\nstatic int\npeer_timers_connect_unset_vty (struct vty *vty, const char *ip_str)\n{\n  int ret;\n  struct peer *peer;\n\n  peer = peer_and_group_lookup_vty (vty, ip_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  ret = peer_timers_connect_unset (peer);\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (neighbor_timers_connect,\n       neighbor_timers_connect_cmd,\n       NEIGHBOR_CMD \"timers connect <0-65535>\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR\n       \"BGP per neighbor timers\\n\"\n       \"BGP connect timer\\n\"\n       \"Connect timer\\n\")\n{\n  return peer_timers_connect_set_vty (vty, argv[0], argv[1]);\n}\n\nDEFUN (no_neighbor_timers_connect,\n       no_neighbor_timers_connect_cmd,\n       NO_NEIGHBOR_CMD \"timers connect\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR\n       \"BGP per neighbor timers\\n\"\n       \"BGP connect timer\\n\")\n{\n  return peer_timers_connect_unset_vty (vty, argv[0]);\n}\n\nALIAS (no_neighbor_timers_connect,\n       no_neighbor_timers_connect_val_cmd,\n       NO_NEIGHBOR_CMD \"timers connect <0-65535>\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR\n       \"BGP per neighbor timers\\n\"\n       \"BGP connect timer\\n\"\n       \"Connect timer\\n\")\n\f\nstatic int\npeer_advertise_interval_vty (struct vty *vty, const char *ip_str, \n                             const char *time_str, int set)  \n{\n  int ret;\n  struct peer *peer;\n  u_int32_t routeadv = 0;\n\n  peer = peer_lookup_vty (vty, ip_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  if (time_str)\n    VTY_GET_INTEGER_RANGE (\"advertise interval\", routeadv, time_str, 0, 600);\n\n  if (set)\n    ret = peer_advertise_interval_set (peer, routeadv);\n  else\n    ret = peer_advertise_interval_unset (peer);\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (neighbor_advertise_interval,\n       neighbor_advertise_interval_cmd,\n       NEIGHBOR_CMD \"advertisement-interval <0-600>\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR\n       \"Minimum interval between sending BGP routing updates\\n\"\n       \"time in seconds\\n\")\n{\n  return peer_advertise_interval_vty (vty, argv[0], argv[1], 1);\n}\n\nDEFUN (no_neighbor_advertise_interval,\n       no_neighbor_advertise_interval_cmd,\n       NO_NEIGHBOR_CMD \"advertisement-interval\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR\n       \"Minimum interval between sending BGP routing updates\\n\")\n{\n  return peer_advertise_interval_vty (vty, argv[0], NULL, 0);\n}\n\nALIAS (no_neighbor_advertise_interval,\n       no_neighbor_advertise_interval_val_cmd,\n       NO_NEIGHBOR_CMD \"advertisement-interval <0-600>\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR\n       \"Minimum interval between sending BGP routing updates\\n\"\n       \"time in seconds\\n\")\n\f\n/* neighbor interface */\nstatic int\npeer_interface_vty (struct vty *vty, const char *ip_str, const char *str)\n{\n  int ret;\n  struct peer *peer;\n\n  peer = peer_lookup_vty (vty, ip_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  if (str)\n    ret = peer_interface_set (peer, str);\n  else\n    ret = peer_interface_unset (peer);\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (neighbor_interface,\n       neighbor_interface_cmd,\n       NEIGHBOR_CMD \"interface WORD\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR\n       \"Interface\\n\"\n       \"Interface name\\n\")\n{\n  return peer_interface_vty (vty, argv[0], argv[1]);\n}\n\nDEFUN (no_neighbor_interface,\n       no_neighbor_interface_cmd,\n       NO_NEIGHBOR_CMD \"interface WORD\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR\n       \"Interface\\n\"\n       \"Interface name\\n\")\n{\n  return peer_interface_vty (vty, argv[0], NULL);\n}\n\f\n/* Set distribute list to the peer. */\nstatic int\npeer_distribute_set_vty (struct vty *vty, const char *ip_str, \n                         afi_t afi, safi_t safi,\n\t\t\t const char *name_str, const char *direct_str)\n{\n  int ret;\n  struct peer *peer;\n  int direct = FILTER_IN;\n\n  peer = peer_and_group_lookup_vty (vty, ip_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  /* Check filter direction. */\n  if (strncmp (direct_str, \"i\", 1) == 0)\n    direct = FILTER_IN;\n  else if (strncmp (direct_str, \"o\", 1) == 0)\n    direct = FILTER_OUT;\n\n  ret = peer_distribute_set (peer, afi, safi, direct, name_str);\n\n  return bgp_vty_return (vty, ret);\n}\n\nstatic int\npeer_distribute_unset_vty (struct vty *vty, const char *ip_str, afi_t afi,\n\t\t\t   safi_t safi, const char *direct_str)\n{\n  int ret;\n  struct peer *peer;\n  int direct = FILTER_IN;\n\n  peer = peer_and_group_lookup_vty (vty, ip_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  /* Check filter direction. */\n  if (strncmp (direct_str, \"i\", 1) == 0)\n    direct = FILTER_IN;\n  else if (strncmp (direct_str, \"o\", 1) == 0)\n    direct = FILTER_OUT;\n\n  ret = peer_distribute_unset (peer, afi, safi, direct);\n\n  return bgp_vty_return (vty, ret);\n}\n\nDEFUN (neighbor_distribute_list,\n       neighbor_distribute_list_cmd,\n       NEIGHBOR_CMD2 \"distribute-list (<1-199>|<1300-2699>|WORD) (in|out)\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Filter updates to/from this neighbor\\n\"\n       \"IP access-list number\\n\"\n       \"IP access-list number (expanded range)\\n\"\n       \"IP Access-list name\\n\"\n       \"Filter incoming updates\\n\"\n       \"Filter outgoing updates\\n\")\n{\n  return peer_distribute_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t  bgp_node_safi (vty), argv[1], argv[2]);\n}\n\nDEFUN (no_neighbor_distribute_list,\n       no_neighbor_distribute_list_cmd,\n       NO_NEIGHBOR_CMD2 \"distribute-list (<1-199>|<1300-2699>|WORD) (in|out)\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Filter updates to/from this neighbor\\n\"\n       \"IP access-list number\\n\"\n       \"IP access-list number (expanded range)\\n\"\n       \"IP Access-list name\\n\"\n       \"Filter incoming updates\\n\"\n       \"Filter outgoing updates\\n\")\n{\n  return peer_distribute_unset_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t    bgp_node_safi (vty), argv[2]);\n}\n\f\n/* Set prefix list to the peer. */\nstatic int\npeer_prefix_list_set_vty (struct vty *vty, const char *ip_str, afi_t afi,\n\t\t\t  safi_t safi, const char *name_str, \n                          const char *direct_str)\n{\n  int ret;\n  struct peer *peer;\n  int direct = FILTER_IN;\n\n  peer = peer_and_group_lookup_vty (vty, ip_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  /* Check filter direction. */\n  if (strncmp (direct_str, \"i\", 1) == 0)\n    direct = FILTER_IN;\n  else if (strncmp (direct_str, \"o\", 1) == 0)\n    direct = FILTER_OUT;\n\n  ret = peer_prefix_list_set (peer, afi, safi, direct, name_str);\n\n  return bgp_vty_return (vty, ret);\n}\n\nstatic int\npeer_prefix_list_unset_vty (struct vty *vty, const char *ip_str, afi_t afi,\n\t\t\t    safi_t safi, const char *direct_str)\n{\n  int ret;\n  struct peer *peer;\n  int direct = FILTER_IN;\n\n  peer = peer_and_group_lookup_vty (vty, ip_str);\n  if (! peer)\n    return CMD_WARNING;\n  \n  /* Check filter direction. */\n  if (strncmp (direct_str, \"i\", 1) == 0)\n    direct = FILTER_IN;\n  else if (strncmp (direct_str, \"o\", 1) == 0)\n    direct = FILTER_OUT;\n\n  ret = peer_prefix_list_unset (peer, afi, safi, direct);\n\n  return bgp_vty_return (vty, ret);\n}\n\nDEFUN (neighbor_prefix_list,\n       neighbor_prefix_list_cmd,\n       NEIGHBOR_CMD2 \"prefix-list WORD (in|out)\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Filter updates to/from this neighbor\\n\"\n       \"Name of a prefix list\\n\"\n       \"Filter incoming updates\\n\"\n       \"Filter outgoing updates\\n\")\n{\n  return peer_prefix_list_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t   bgp_node_safi (vty), argv[1], argv[2]);\n}\n\nDEFUN (no_neighbor_prefix_list,\n       no_neighbor_prefix_list_cmd,\n       NO_NEIGHBOR_CMD2 \"prefix-list WORD (in|out)\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Filter updates to/from this neighbor\\n\"\n       \"Name of a prefix list\\n\"\n       \"Filter incoming updates\\n\"\n       \"Filter outgoing updates\\n\")\n{\n  return peer_prefix_list_unset_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t     bgp_node_safi (vty), argv[2]);\n}\n\f\nstatic int\npeer_aslist_set_vty (struct vty *vty, const char *ip_str, \n                     afi_t afi, safi_t safi,\n\t\t     const char *name_str, const char *direct_str)\n{\n  int ret;\n  struct peer *peer;\n  int direct = FILTER_IN;\n\n  peer = peer_and_group_lookup_vty (vty, ip_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  /* Check filter direction. */\n  if (strncmp (direct_str, \"i\", 1) == 0)\n    direct = FILTER_IN;\n  else if (strncmp (direct_str, \"o\", 1) == 0)\n    direct = FILTER_OUT;\n\n  ret = peer_aslist_set (peer, afi, safi, direct, name_str);\n\n  return bgp_vty_return (vty, ret);\n}\n\nstatic int\npeer_aslist_unset_vty (struct vty *vty, const char *ip_str, \n                       afi_t afi, safi_t safi,\n\t\t       const char *direct_str)\n{\n  int ret;\n  struct peer *peer;\n  int direct = FILTER_IN;\n\n  peer = peer_and_group_lookup_vty (vty, ip_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  /* Check filter direction. */\n  if (strncmp (direct_str, \"i\", 1) == 0)\n    direct = FILTER_IN;\n  else if (strncmp (direct_str, \"o\", 1) == 0)\n    direct = FILTER_OUT;\n\n  ret = peer_aslist_unset (peer, afi, safi, direct);\n\n  return bgp_vty_return (vty, ret);\n}\n\nDEFUN (neighbor_filter_list,\n       neighbor_filter_list_cmd,\n       NEIGHBOR_CMD2 \"filter-list WORD (in|out)\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Establish BGP filters\\n\"\n       \"AS path access-list name\\n\"\n       \"Filter incoming routes\\n\"\n       \"Filter outgoing routes\\n\")\n{\n  return peer_aslist_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t      bgp_node_safi (vty), argv[1], argv[2]);\n}\n\nDEFUN (no_neighbor_filter_list,\n       no_neighbor_filter_list_cmd,\n       NO_NEIGHBOR_CMD2 \"filter-list WORD (in|out)\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Establish BGP filters\\n\"\n       \"AS path access-list name\\n\"\n       \"Filter incoming routes\\n\"\n       \"Filter outgoing routes\\n\")\n{\n  return peer_aslist_unset_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\tbgp_node_safi (vty), argv[2]);\n}\n\f\n/* Set route-map to the peer. */\nstatic int\npeer_route_map_set_vty (struct vty *vty, const char *ip_str, \n                        afi_t afi, safi_t safi,\n\t\t\tconst char *name_str, const char *direct_str)\n{\n  int ret;\n  struct peer *peer;\n  int direct = RMAP_IN;\n\n  peer = peer_and_group_lookup_vty (vty, ip_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  /* Check filter direction. */\n  if (strncmp (direct_str, \"in\", 2) == 0)\n    direct = RMAP_IN;\n  else if (strncmp (direct_str, \"o\", 1) == 0)\n    direct = RMAP_OUT;\n  else if (strncmp (direct_str, \"im\", 2) == 0)\n    direct = RMAP_IMPORT;\n  else if (strncmp (direct_str, \"e\", 1) == 0)\n    direct = RMAP_EXPORT;\n\n  ret = peer_route_map_set (peer, afi, safi, direct, name_str);\n\n  return bgp_vty_return (vty, ret);\n}\n\nstatic int\npeer_route_map_unset_vty (struct vty *vty, const char *ip_str, afi_t afi,\n\t\t\t  safi_t safi, const char *direct_str)\n{\n  int ret;\n  struct peer *peer;\n  int direct = RMAP_IN;\n\n  peer = peer_and_group_lookup_vty (vty, ip_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  /* Check filter direction. */\n  if (strncmp (direct_str, \"in\", 2) == 0)\n    direct = RMAP_IN;\n  else if (strncmp (direct_str, \"o\", 1) == 0)\n    direct = RMAP_OUT;\n  else if (strncmp (direct_str, \"im\", 2) == 0)\n    direct = RMAP_IMPORT;\n  else if (strncmp (direct_str, \"e\", 1) == 0)\n    direct = RMAP_EXPORT;\n\n  ret = peer_route_map_unset (peer, afi, safi, direct);\n\n  return bgp_vty_return (vty, ret);\n}\n\nDEFUN (neighbor_route_map,\n       neighbor_route_map_cmd,\n       NEIGHBOR_CMD2 \"route-map WORD (in|out|import|export)\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Apply route map to neighbor\\n\"\n       \"Name of route map\\n\"\n       \"Apply map to incoming routes\\n\"\n       \"Apply map to outbound routes\\n\"\n       \"Apply map to routes going into a Route-Server client's table\\n\"\n       \"Apply map to routes coming from a Route-Server client\")\n{\n  return peer_route_map_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t bgp_node_safi (vty), argv[1], argv[2]);\n}\n\nDEFUN (no_neighbor_route_map,\n       no_neighbor_route_map_cmd,\n       NO_NEIGHBOR_CMD2 \"route-map WORD (in|out|import|export)\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Apply route map to neighbor\\n\"\n       \"Name of route map\\n\"\n       \"Apply map to incoming routes\\n\"\n       \"Apply map to outbound routes\\n\"\n       \"Apply map to routes going into a Route-Server client's table\\n\"\n       \"Apply map to routes coming from a Route-Server client\")\n{\n  return peer_route_map_unset_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t   bgp_node_safi (vty), argv[2]);\n}\n\f\n/* Set unsuppress-map to the peer. */\nstatic int\npeer_unsuppress_map_set_vty (struct vty *vty, const char *ip_str, afi_t afi,\n\t\t\t     safi_t safi, const char *name_str)\n{\n  int ret;\n  struct peer *peer;\n\n  peer = peer_and_group_lookup_vty (vty, ip_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  ret = peer_unsuppress_map_set (peer, afi, safi, name_str);\n\n  return bgp_vty_return (vty, ret);\n}\n\n/* Unset route-map from the peer. */\nstatic int\npeer_unsuppress_map_unset_vty (struct vty *vty, const char *ip_str, afi_t afi,\n\t\t\t       safi_t safi)\n{\n  int ret;\n  struct peer *peer;\n\n  peer = peer_and_group_lookup_vty (vty, ip_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  ret = peer_unsuppress_map_unset (peer, afi, safi);\n\n  return bgp_vty_return (vty, ret);\n}\n\nDEFUN (neighbor_unsuppress_map,\n       neighbor_unsuppress_map_cmd,\n       NEIGHBOR_CMD2 \"unsuppress-map WORD\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Route-map to selectively unsuppress suppressed routes\\n\"\n       \"Name of route map\\n\")\n{\n  return peer_unsuppress_map_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t      bgp_node_safi (vty), argv[1]);\n}\n\nDEFUN (no_neighbor_unsuppress_map,\n       no_neighbor_unsuppress_map_cmd,\n       NO_NEIGHBOR_CMD2 \"unsuppress-map WORD\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Route-map to selectively unsuppress suppressed routes\\n\"\n       \"Name of route map\\n\")\n{\n  return peer_unsuppress_map_unset_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t\tbgp_node_safi (vty));\n}\n\f\nstatic int\npeer_maximum_prefix_set_vty (struct vty *vty, const char *ip_str, afi_t afi,\n\t\t\t     safi_t safi, const char *num_str,  \n\t\t\t     const char *threshold_str, int warning,\n\t\t\t     const char *restart_str)\n{\n  int ret;\n  struct peer *peer;\n  u_int32_t max;\n  u_char threshold;\n  u_int16_t restart;\n\n  peer = peer_and_group_lookup_vty (vty, ip_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  VTY_GET_INTEGER (\"maxmum number\", max, num_str);\n  if (threshold_str)\n    threshold = atoi (threshold_str);\n  else\n    threshold = MAXIMUM_PREFIX_THRESHOLD_DEFAULT;\n\n  if (restart_str)\n    restart = atoi (restart_str);\n  else\n    restart = 0;\n\n  ret = peer_maximum_prefix_set (peer, afi, safi, max, threshold, warning, restart);\n\n  return bgp_vty_return (vty, ret);\n}\n\nstatic int\npeer_maximum_prefix_unset_vty (struct vty *vty, const char *ip_str, afi_t afi,\n\t\t\t       safi_t safi)\n{\n  int ret;\n  struct peer *peer;\n\n  peer = peer_and_group_lookup_vty (vty, ip_str);\n  if (! peer)\n    return CMD_WARNING;\n\n  ret = peer_maximum_prefix_unset (peer, afi, safi);\n\n  return bgp_vty_return (vty, ret);\n}\n\n/* Maximum number of prefix configuration.  prefix count is different\n   for each peer configuration.  So this configuration can be set for\n   each peer configuration. */\nDEFUN (neighbor_maximum_prefix,\n       neighbor_maximum_prefix_cmd,\n       NEIGHBOR_CMD2 \"maximum-prefix <1-4294967295>\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Maximum number of prefix accept from this peer\\n\"\n       \"maximum no. of prefix limit\\n\")\n{\n  return peer_maximum_prefix_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t      bgp_node_safi (vty), argv[1], NULL, 0,\n\t\t\t\t      NULL);\n}\n\nDEFUN (neighbor_maximum_prefix_threshold,\n       neighbor_maximum_prefix_threshold_cmd,\n       NEIGHBOR_CMD2 \"maximum-prefix <1-4294967295> <1-100>\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Maximum number of prefix accept from this peer\\n\"\n       \"maximum no. of prefix limit\\n\"\n       \"Threshold value (%) at which to generate a warning msg\\n\")\n{\n  return peer_maximum_prefix_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t      bgp_node_safi (vty), argv[1], argv[2], 0,\n\t\t\t\t      NULL);\n}\n\nDEFUN (neighbor_maximum_prefix_warning,\n       neighbor_maximum_prefix_warning_cmd,\n       NEIGHBOR_CMD2 \"maximum-prefix <1-4294967295> warning-only\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Maximum number of prefix accept from this peer\\n\"\n       \"maximum no. of prefix limit\\n\"\n       \"Only give warning message when limit is exceeded\\n\")\n{\n  return peer_maximum_prefix_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t      bgp_node_safi (vty), argv[1], NULL, 1,\n\t\t\t\t      NULL);\n}\n\nDEFUN (neighbor_maximum_prefix_threshold_warning,\n       neighbor_maximum_prefix_threshold_warning_cmd,\n       NEIGHBOR_CMD2 \"maximum-prefix <1-4294967295> <1-100> warning-only\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Maximum number of prefix accept from this peer\\n\"\n       \"maximum no. of prefix limit\\n\"\n       \"Threshold value (%) at which to generate a warning msg\\n\"\n       \"Only give warning message when limit is exceeded\\n\")\n{\n  return peer_maximum_prefix_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t      bgp_node_safi (vty), argv[1], argv[2], 1, NULL);\n}\n\nDEFUN (neighbor_maximum_prefix_restart,\n       neighbor_maximum_prefix_restart_cmd,\n       NEIGHBOR_CMD2 \"maximum-prefix <1-4294967295> restart <1-65535>\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Maximum number of prefix accept from this peer\\n\"\n       \"maximum no. of prefix limit\\n\"\n       \"Restart bgp connection after limit is exceeded\\n\"\n       \"Restart interval in minutes\")\n{\n  return peer_maximum_prefix_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t      bgp_node_safi (vty), argv[1], NULL, 0, argv[2]);\n}\n\nDEFUN (neighbor_maximum_prefix_threshold_restart,\n       neighbor_maximum_prefix_threshold_restart_cmd,\n       NEIGHBOR_CMD2 \"maximum-prefix <1-4294967295> <1-100> restart <1-65535>\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Maximum number of prefix accept from this peer\\n\"\n       \"maximum no. of prefix limit\\n\"\n       \"Threshold value (%) at which to generate a warning msg\\n\"\n       \"Restart bgp connection after limit is exceeded\\n\"\n       \"Restart interval in minutes\")\n{\n  return peer_maximum_prefix_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t      bgp_node_safi (vty), argv[1], argv[2], 0, argv[3]);\n}\n\nDEFUN (no_neighbor_maximum_prefix,\n       no_neighbor_maximum_prefix_cmd,\n       NO_NEIGHBOR_CMD2 \"maximum-prefix\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Maximum number of prefix accept from this peer\\n\")\n{\n  return peer_maximum_prefix_unset_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t\tbgp_node_safi (vty));\n}\n \nALIAS (no_neighbor_maximum_prefix,\n       no_neighbor_maximum_prefix_val_cmd,\n       NO_NEIGHBOR_CMD2 \"maximum-prefix <1-4294967295>\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Maximum number of prefix accept from this peer\\n\"\n       \"maximum no. of prefix limit\\n\")\n\nALIAS (no_neighbor_maximum_prefix,\n       no_neighbor_maximum_prefix_threshold_cmd,\n       NO_NEIGHBOR_CMD2 \"maximum-prefix <1-4294967295> warning-only\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Maximum number of prefix accept from this peer\\n\"\n       \"maximum no. of prefix limit\\n\"\n       \"Threshold value (%) at which to generate a warning msg\\n\")\n\nALIAS (no_neighbor_maximum_prefix,\n       no_neighbor_maximum_prefix_warning_cmd,\n       NO_NEIGHBOR_CMD2 \"maximum-prefix <1-4294967295> warning-only\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Maximum number of prefix accept from this peer\\n\"\n       \"maximum no. of prefix limit\\n\"\n       \"Only give warning message when limit is exceeded\\n\")\n\nALIAS (no_neighbor_maximum_prefix,\n       no_neighbor_maximum_prefix_threshold_warning_cmd,\n       NO_NEIGHBOR_CMD2 \"maximum-prefix <1-4294967295> <1-100> warning-only\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Maximum number of prefix accept from this peer\\n\"\n       \"maximum no. of prefix limit\\n\"\n       \"Threshold value (%) at which to generate a warning msg\\n\"\n       \"Only give warning message when limit is exceeded\\n\")\n\nALIAS (no_neighbor_maximum_prefix,\n       no_neighbor_maximum_prefix_restart_cmd,\n       NO_NEIGHBOR_CMD2 \"maximum-prefix <1-4294967295> restart <1-65535>\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Maximum number of prefix accept from this peer\\n\"\n       \"maximum no. of prefix limit\\n\"\n       \"Restart bgp connection after limit is exceeded\\n\"\n       \"Restart interval in minutes\")\n\nALIAS (no_neighbor_maximum_prefix,\n       no_neighbor_maximum_prefix_threshold_restart_cmd,\n       NO_NEIGHBOR_CMD2 \"maximum-prefix <1-4294967295> <1-100> restart <1-65535>\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Maximum number of prefix accept from this peer\\n\"\n       \"maximum no. of prefix limit\\n\"\n       \"Threshold value (%) at which to generate a warning msg\\n\"\n       \"Restart bgp connection after limit is exceeded\\n\"\n       \"Restart interval in minutes\")\n\f\n/* \"neighbor allowas-in\" */\nDEFUN (neighbor_allowas_in,\n       neighbor_allowas_in_cmd,\n       NEIGHBOR_CMD2 \"allowas-in\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Accept as-path with my AS present in it\\n\")\n{\n  int ret;\n  struct peer *peer;\n  unsigned int allow_num;\n\n  peer = peer_and_group_lookup_vty (vty, argv[0]);\n  if (! peer)\n    return CMD_WARNING;\n\n  if (argc == 1)\n    allow_num = 3;\n  else\n    VTY_GET_INTEGER_RANGE (\"AS number\", allow_num, argv[1], 1, 10);\n\n  ret = peer_allowas_in_set (peer, bgp_node_afi (vty), bgp_node_safi (vty),\n\t\t\t     allow_num);\n\n  return bgp_vty_return (vty, ret);\n}\n\nALIAS (neighbor_allowas_in,\n       neighbor_allowas_in_arg_cmd,\n       NEIGHBOR_CMD2 \"allowas-in <1-10>\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Accept as-path with my AS present in it\\n\"\n       \"Number of occurances of AS number\\n\")\n\nDEFUN (no_neighbor_allowas_in,\n       no_neighbor_allowas_in_cmd,\n       NO_NEIGHBOR_CMD2 \"allowas-in\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"allow local ASN appears in aspath attribute\\n\")\n{\n  int ret;\n  struct peer *peer;\n\n  peer = peer_and_group_lookup_vty (vty, argv[0]);\n  if (! peer)\n    return CMD_WARNING;\n\n  ret = peer_allowas_in_unset (peer, bgp_node_afi (vty), bgp_node_safi (vty));\n\n  return bgp_vty_return (vty, ret);\n}\n\f\n/* Address family configuration.  */\nDEFUN (address_family_ipv4,\n       address_family_ipv4_cmd,\n       \"address-family ipv4\",\n       \"Enter Address Family command mode\\n\"\n       \"Address family\\n\")\n{\n  vty->node = BGP_IPV4_NODE;\n  return CMD_SUCCESS;\n}\n\nDEFUN (address_family_ipv4_safi,\n       address_family_ipv4_safi_cmd,\n       \"address-family ipv4 (unicast|multicast)\",\n       \"Enter Address Family command mode\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\")\n{\n  if (strncmp (argv[0], \"m\", 1) == 0)\n    vty->node = BGP_IPV4M_NODE;\n  else\n    vty->node = BGP_IPV4_NODE;\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (address_family_ipv6,\n       address_family_ipv6_cmd,\n       \"address-family ipv6\",\n       \"Enter Address Family command mode\\n\"\n       \"Address family\\n\")\n{\n  vty->node = BGP_IPV6_NODE;\n  return CMD_SUCCESS;\n}\n\nDEFUN (address_family_ipv6_safi,\n       address_family_ipv6_safi_cmd,\n       \"address-family ipv6 (unicast|multicast)\",\n       \"Enter Address Family command mode\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\")\n{\n  if (strncmp (argv[0], \"m\", 1) == 0)\n    vty->node = BGP_IPV6M_NODE;\n  else\n    vty->node = BGP_IPV6_NODE;\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (address_family_vpnv4,\n       address_family_vpnv4_cmd,\n       \"address-family vpnv4\",\n       \"Enter Address Family command mode\\n\"\n       \"Address family\\n\")\n{\n  vty->node = BGP_VPNV4_NODE;\n  return CMD_SUCCESS;\n}\n\nALIAS (address_family_vpnv4,\n       address_family_vpnv4_unicast_cmd,\n       \"address-family vpnv4 unicast\",\n       \"Enter Address Family command mode\\n\"\n       \"Address family\\n\"\n       \"Address Family Modifier\\n\")\n\nDEFUN (exit_address_family,\n       exit_address_family_cmd,\n       \"exit-address-family\",\n       \"Exit from Address Family configuration mode\\n\")\n{\n  if (vty->node == BGP_IPV4_NODE\n      || vty->node == BGP_IPV4M_NODE\n      || vty->node == BGP_VPNV4_NODE\n      || vty->node == BGP_IPV6_NODE\n      || vty->node == BGP_IPV6M_NODE)\n    vty->node = BGP_NODE;\n  return CMD_SUCCESS;\n}\n\f\n/* BGP clear sort. */\nenum clear_sort\n{\n  clear_all,\n  clear_peer,\n  clear_group,\n  clear_external,\n  clear_as\n};\n\nstatic void\nbgp_clear_vty_error (struct vty *vty, struct peer *peer, afi_t afi,\n\t\t     safi_t safi, int error)\n{\n  switch (error)\n    {\n    case BGP_ERR_AF_UNCONFIGURED:\n      vty_out (vty,\n\t       \"%%BGP: Enable %s %s address family for the neighbor %s%s\",\n\t       afi == AFI_IP6 ? \"IPv6\" : safi == SAFI_MPLS_VPN ? \"VPNv4\" : \"IPv4\",\n\t       safi == SAFI_MULTICAST ? \"Multicast\" : \"Unicast\",\n\t       peer->host, VTY_NEWLINE);\n      break;\n    case BGP_ERR_SOFT_RECONFIG_UNCONFIGURED:\n      vty_out (vty, \"%%BGP: Inbound soft reconfig for %s not possible as it%s      has neither refresh capability, nor inbound soft reconfig%s\", peer->host, VTY_NEWLINE, VTY_NEWLINE);\n      break;\n    default:\n      break;\n    }\n}\n\n/* `clear ip bgp' functions. */\nstatic int\nbgp_clear (struct vty *vty, struct bgp *bgp,  afi_t afi, safi_t safi,\n           enum clear_sort sort,enum bgp_clear_type stype, const char *arg)\n{\n  int ret;\n  struct peer *peer;\n  struct listnode *node, *nnode;\n\n  /* Clear all neighbors. */\n  if (sort == clear_all)\n    {\n      for (ALL_LIST_ELEMENTS (bgp->peer, node, nnode, peer))\n\t{\n\t  if (stype == BGP_CLEAR_SOFT_NONE)\n\t    ret = peer_clear (peer);\n\t  else\n\t    ret = peer_clear_soft (peer, afi, safi, stype);\n\n\t  if (ret < 0)\n\t    bgp_clear_vty_error (vty, peer, afi, safi, ret);\n\t}\n      return 0;\n    }\n\n  /* Clear specified neighbors. */\n  if (sort == clear_peer)\n    {\n      union sockunion su;\n      int ret;\n\n      /* Make sockunion for lookup. */\n      ret = str2sockunion (arg, &su);\n      if (ret < 0)\n\t{\n\t  vty_out (vty, \"Malformed address: %s%s\", arg, VTY_NEWLINE);\n\t  return -1;\n\t}\n      peer = peer_lookup (bgp, &su);\n      if (! peer)\n\t{\n\t  vty_out (vty, \"%%BGP: Unknown neighbor - \\\"%s\\\"%s\", arg, VTY_NEWLINE);\n\t  return -1;\n\t}\n\n      if (stype == BGP_CLEAR_SOFT_NONE)\n\tret = peer_clear (peer);\n      else\n\tret = peer_clear_soft (peer, afi, safi, stype);\n\n      if (ret < 0)\n\tbgp_clear_vty_error (vty, peer, afi, safi, ret);\n\n      return 0;\n    }\n\n  /* Clear all peer-group members. */\n  if (sort == clear_group)\n    {\n      struct peer_group *group;\n\n      group = peer_group_lookup (bgp, arg);\n      if (! group)\n\t{\n\t  vty_out (vty, \"%%BGP: No such peer-group %s%s\", arg, VTY_NEWLINE);\n\t  return -1; \n\t}\n\n      for (ALL_LIST_ELEMENTS (group->peer, node, nnode, peer))\n\t{\n\t  if (stype == BGP_CLEAR_SOFT_NONE)\n\t    {\n\t      ret = peer_clear (peer);\n\t      continue;\n\t    }\n\n\t  if (! peer->af_group[afi][safi])\n\t    continue;\n\n\t  ret = peer_clear_soft (peer, afi, safi, stype);\n\n\t  if (ret < 0)\n\t    bgp_clear_vty_error (vty, peer, afi, safi, ret);\n\t}\n      return 0;\n    }\n\n  if (sort == clear_external)\n    {\n      for (ALL_LIST_ELEMENTS (bgp->peer, node, nnode, peer))\n\t{\n\t  if (peer_sort (peer) == BGP_PEER_IBGP) \n\t    continue;\n\n\t  if (stype == BGP_CLEAR_SOFT_NONE)\n\t    ret = peer_clear (peer);\n\t  else\n\t    ret = peer_clear_soft (peer, afi, safi, stype);\n\n\t  if (ret < 0)\n\t    bgp_clear_vty_error (vty, peer, afi, safi, ret);\n\t}\n      return 0;\n    }\n\n  if (sort == clear_as)\n    {\n      as_t as;\n      unsigned long as_ul;\n      char *endptr = NULL;\n      int find = 0;\n\n      as_ul = strtoul(arg, &endptr, 10);\n\n      if ((as_ul == ULONG_MAX) || (*endptr != '\\0') || (as_ul > USHRT_MAX))\n\t{\n\t  vty_out (vty, \"Invalid AS number%s\", VTY_NEWLINE); \n\t  return -1;\n\t}\n      as = (as_t) as_ul;\n\n      for (ALL_LIST_ELEMENTS (bgp->peer, node, nnode, peer))\n\t{\n\t  if (peer->as != as) \n\t    continue;\n\n\t  find = 1;\n\t  if (stype == BGP_CLEAR_SOFT_NONE)\n\t    ret = peer_clear (peer);\n\t  else\n\t    ret = peer_clear_soft (peer, afi, safi, stype);\n\n\t  if (ret < 0)\n\t    bgp_clear_vty_error (vty, peer, afi, safi, ret);\n\t}\n      if (! find)\n\tvty_out (vty, \"%%BGP: No peer is configured with AS %s%s\", arg,\n\t\t VTY_NEWLINE);\n      return 0;\n    }\n\n  return 0;\n}\n\nstatic int\nbgp_clear_vty (struct vty *vty, const char *name, afi_t afi, safi_t safi,\n               enum clear_sort sort, enum bgp_clear_type stype, \n               const char *arg)\n{\n  int ret;\n  struct bgp *bgp;\n\n  /* BGP structure lookup. */\n  if (name)\n    {\n      bgp = bgp_lookup_by_name (name);\n      if (bgp == NULL)\n        {\n          vty_out (vty, \"Can't find BGP view %s%s\", name, VTY_NEWLINE);\n          return CMD_WARNING;\n        }\n    }\n  else\n    {\n      bgp = bgp_get_default ();\n      if (bgp == NULL)\n        {\n          vty_out (vty, \"No BGP process is configured%s\", VTY_NEWLINE);\n          return CMD_WARNING;\n        }\n    }\n\n  ret =  bgp_clear (vty, bgp, afi, safi, sort, stype, arg);\n  if (ret < 0)\n    return CMD_WARNING;\n\n  return CMD_SUCCESS;\n}\n  \nDEFUN (clear_ip_bgp_all,\n       clear_ip_bgp_all_cmd,\n       \"clear ip bgp *\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all peers\\n\")\n{\n  if (argc == 1)\n    return bgp_clear_vty (vty, argv[0], 0, 0, clear_all, BGP_CLEAR_SOFT_NONE, NULL);    \n\n  return bgp_clear_vty (vty, NULL, 0, 0, clear_all, BGP_CLEAR_SOFT_NONE, NULL);\n}\n\nALIAS (clear_ip_bgp_all,\n       clear_bgp_all_cmd,\n       \"clear bgp *\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear all peers\\n\")\n\nALIAS (clear_ip_bgp_all,\n       clear_bgp_ipv6_all_cmd,\n       \"clear bgp ipv6 *\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear all peers\\n\")\n\nALIAS (clear_ip_bgp_all,\n       clear_ip_bgp_instance_all_cmd,\n       \"clear ip bgp view WORD *\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"view name\\n\"\n       \"Clear all peers\\n\")\n\nALIAS (clear_ip_bgp_all,\n       clear_bgp_instance_all_cmd,\n       \"clear bgp view WORD *\",\n       CLEAR_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"view name\\n\"\n       \"Clear all peers\\n\")\n\nDEFUN (clear_ip_bgp_peer,\n       clear_ip_bgp_peer_cmd, \n       \"clear ip bgp (A.B.C.D|X:X::X:X)\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP neighbor IP address to clear\\n\"\n       \"BGP IPv6 neighbor to clear\\n\")\n{\n  return bgp_clear_vty (vty, NULL, 0, 0, clear_peer, BGP_CLEAR_SOFT_NONE, argv[0]);\n}\n\nALIAS (clear_ip_bgp_peer,\n       clear_bgp_peer_cmd, \n       \"clear bgp (A.B.C.D|X:X::X:X)\",\n       CLEAR_STR\n       BGP_STR\n       \"BGP neighbor address to clear\\n\"\n       \"BGP IPv6 neighbor to clear\\n\")\n\nALIAS (clear_ip_bgp_peer,\n       clear_bgp_ipv6_peer_cmd, \n       \"clear bgp ipv6 (A.B.C.D|X:X::X:X)\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"BGP neighbor address to clear\\n\"\n       \"BGP IPv6 neighbor to clear\\n\")\n\nDEFUN (clear_ip_bgp_peer_group,\n       clear_ip_bgp_peer_group_cmd, \n       \"clear ip bgp peer-group WORD\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\")\n{\n  return bgp_clear_vty (vty, NULL, 0, 0, clear_group, BGP_CLEAR_SOFT_NONE, argv[0]);\n}\n\nALIAS (clear_ip_bgp_peer_group,\n       clear_bgp_peer_group_cmd, \n       \"clear bgp peer-group WORD\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\")\n\nALIAS (clear_ip_bgp_peer_group,\n       clear_bgp_ipv6_peer_group_cmd, \n       \"clear bgp ipv6 peer-group WORD\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\")\n\nDEFUN (clear_ip_bgp_external,\n       clear_ip_bgp_external_cmd,\n       \"clear ip bgp external\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all external peers\\n\")\n{\n  return bgp_clear_vty (vty, NULL, 0, 0, clear_external, BGP_CLEAR_SOFT_NONE, NULL);\n}\n\nALIAS (clear_ip_bgp_external,\n       clear_bgp_external_cmd, \n       \"clear bgp external\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear all external peers\\n\")\n\nALIAS (clear_ip_bgp_external,\n       clear_bgp_ipv6_external_cmd, \n       \"clear bgp ipv6 external\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear all external peers\\n\")\n\nDEFUN (clear_ip_bgp_as,\n       clear_ip_bgp_as_cmd,\n       \"clear ip bgp <1-65535>\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\")\n{\n  return bgp_clear_vty (vty, NULL, 0, 0, clear_as, BGP_CLEAR_SOFT_NONE, argv[0]);\n}       \n\nALIAS (clear_ip_bgp_as,\n       clear_bgp_as_cmd,\n       \"clear bgp <1-65535>\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\")\n\nALIAS (clear_ip_bgp_as,\n       clear_bgp_ipv6_as_cmd,\n       \"clear bgp ipv6 <1-65535>\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear peers with the AS number\\n\")\n\f\n/* Outbound soft-reconfiguration */\nDEFUN (clear_ip_bgp_all_soft_out,\n       clear_ip_bgp_all_soft_out_cmd,\n       \"clear ip bgp * soft out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n{\n  if (argc == 1)\n    return bgp_clear_vty (vty, argv[0], AFI_IP, SAFI_UNICAST, clear_all,\n                          BGP_CLEAR_SOFT_OUT, NULL);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_all,\n\t\t\tBGP_CLEAR_SOFT_OUT, NULL);\n}\n\nALIAS (clear_ip_bgp_all_soft_out,\n       clear_ip_bgp_all_out_cmd,\n       \"clear ip bgp * out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nALIAS (clear_ip_bgp_all_soft_out,\n       clear_ip_bgp_instance_all_soft_out_cmd,\n       \"clear ip bgp view WORD * soft out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"view name\\n\"\n       \"Clear all peers\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nDEFUN (clear_ip_bgp_all_ipv4_soft_out,\n       clear_ip_bgp_all_ipv4_soft_out_cmd,\n       \"clear ip bgp * ipv4 (unicast|multicast) soft out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n{\n  if (strncmp (argv[0], \"m\", 1) == 0)\n    return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MULTICAST, clear_all,\n\t\t\t  BGP_CLEAR_SOFT_OUT, NULL);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_all,\n\t\t\tBGP_CLEAR_SOFT_OUT, NULL);\n}\n\nALIAS (clear_ip_bgp_all_ipv4_soft_out,\n       clear_ip_bgp_all_ipv4_out_cmd,\n       \"clear ip bgp * ipv4 (unicast|multicast) out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nDEFUN (clear_ip_bgp_instance_all_ipv4_soft_out,\n       clear_ip_bgp_instance_all_ipv4_soft_out_cmd,\n       \"clear ip bgp view WORD * ipv4 (unicast|multicast) soft out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"view name\\n\"\n       \"Clear all peers\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig outbound update\\n\")\n{\n  if (strncmp (argv[1], \"m\", 1) == 0)\n    return bgp_clear_vty (vty, argv[0], AFI_IP, SAFI_MULTICAST, clear_all,\n                          BGP_CLEAR_SOFT_OUT, NULL);\n\n  return bgp_clear_vty (vty, argv[0], AFI_IP, SAFI_UNICAST, clear_all,\n                        BGP_CLEAR_SOFT_OUT, NULL);\n}\n\nDEFUN (clear_ip_bgp_all_vpnv4_soft_out,\n       clear_ip_bgp_all_vpnv4_soft_out_cmd,\n       \"clear ip bgp * vpnv4 unicast soft out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Address family\\n\"\n       \"Address Family Modifier\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MPLS_VPN, clear_all,\n\t\t\tBGP_CLEAR_SOFT_OUT, NULL);\n}\n\nALIAS (clear_ip_bgp_all_vpnv4_soft_out,\n       clear_ip_bgp_all_vpnv4_out_cmd,\n       \"clear ip bgp * vpnv4 unicast out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Address family\\n\"\n       \"Address Family Modifier\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nDEFUN (clear_bgp_all_soft_out,\n       clear_bgp_all_soft_out_cmd,\n       \"clear bgp * soft out\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n{\n  if (argc == 1)\n    return bgp_clear_vty (vty, argv[0], AFI_IP6, SAFI_UNICAST, clear_all,\n                          BGP_CLEAR_SOFT_OUT, NULL);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_all,\n\t\t\tBGP_CLEAR_SOFT_OUT, NULL);\n}\n\nALIAS (clear_bgp_all_soft_out,\n       clear_bgp_instance_all_soft_out_cmd,\n       \"clear bgp view WORD * soft out\",\n       CLEAR_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"view name\\n\"\n       \"Clear all peers\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nALIAS (clear_bgp_all_soft_out,\n       clear_bgp_all_out_cmd,\n       \"clear bgp * out\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nALIAS (clear_bgp_all_soft_out,\n       clear_bgp_ipv6_all_soft_out_cmd,\n       \"clear bgp ipv6 * soft out\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear all peers\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nALIAS (clear_bgp_all_soft_out,\n       clear_bgp_ipv6_all_out_cmd,\n       \"clear bgp ipv6 * out\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear all peers\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nDEFUN (clear_ip_bgp_peer_soft_out,\n       clear_ip_bgp_peer_soft_out_cmd,\n       \"clear ip bgp A.B.C.D soft out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP neighbor address to clear\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_peer,\n\t\t\tBGP_CLEAR_SOFT_OUT, argv[0]);\n}\n\nALIAS (clear_ip_bgp_peer_soft_out,\n       clear_ip_bgp_peer_out_cmd,\n       \"clear ip bgp A.B.C.D out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP neighbor address to clear\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nDEFUN (clear_ip_bgp_peer_ipv4_soft_out,\n       clear_ip_bgp_peer_ipv4_soft_out_cmd,\n       \"clear ip bgp A.B.C.D ipv4 (unicast|multicast) soft out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP neighbor address to clear\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n{\n  if (strncmp (argv[1], \"m\", 1) == 0)\n    return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MULTICAST, clear_peer,\n\t\t\t  BGP_CLEAR_SOFT_OUT, argv[0]);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_peer,\n\t\t\tBGP_CLEAR_SOFT_OUT, argv[0]);\n}\n\nALIAS (clear_ip_bgp_peer_ipv4_soft_out,\n       clear_ip_bgp_peer_ipv4_out_cmd,\n       \"clear ip bgp A.B.C.D ipv4 (unicast|multicast) out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP neighbor address to clear\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nDEFUN (clear_ip_bgp_peer_vpnv4_soft_out,\n       clear_ip_bgp_peer_vpnv4_soft_out_cmd,\n       \"clear ip bgp A.B.C.D vpnv4 unicast soft out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP neighbor address to clear\\n\"\n       \"Address family\\n\"\n       \"Address Family Modifier\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MPLS_VPN, clear_peer,\n\t\t\tBGP_CLEAR_SOFT_OUT, argv[0]);\n}\n\nALIAS (clear_ip_bgp_peer_vpnv4_soft_out,\n       clear_ip_bgp_peer_vpnv4_out_cmd,\n       \"clear ip bgp A.B.C.D vpnv4 unicast out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP neighbor address to clear\\n\"\n       \"Address family\\n\"\n       \"Address Family Modifier\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nDEFUN (clear_bgp_peer_soft_out,\n       clear_bgp_peer_soft_out_cmd,\n       \"clear bgp (A.B.C.D|X:X::X:X) soft out\",\n       CLEAR_STR\n       BGP_STR\n       \"BGP neighbor address to clear\\n\"\n       \"BGP IPv6 neighbor to clear\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_peer,\n\t\t\tBGP_CLEAR_SOFT_OUT, argv[0]);\n}\n\nALIAS (clear_bgp_peer_soft_out,\n       clear_bgp_ipv6_peer_soft_out_cmd,\n       \"clear bgp ipv6 (A.B.C.D|X:X::X:X) soft out\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"BGP neighbor address to clear\\n\"\n       \"BGP IPv6 neighbor to clear\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nALIAS (clear_bgp_peer_soft_out,\n       clear_bgp_peer_out_cmd,\n       \"clear bgp (A.B.C.D|X:X::X:X) out\",\n       CLEAR_STR\n       BGP_STR\n       \"BGP neighbor address to clear\\n\"\n       \"BGP IPv6 neighbor to clear\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nALIAS (clear_bgp_peer_soft_out,\n       clear_bgp_ipv6_peer_out_cmd,\n       \"clear bgp ipv6 (A.B.C.D|X:X::X:X) out\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"BGP neighbor address to clear\\n\"\n       \"BGP IPv6 neighbor to clear\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nDEFUN (clear_ip_bgp_peer_group_soft_out,\n       clear_ip_bgp_peer_group_soft_out_cmd, \n       \"clear ip bgp peer-group WORD soft out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_group,\n\t\t\tBGP_CLEAR_SOFT_OUT, argv[0]);\n}\n\nALIAS (clear_ip_bgp_peer_group_soft_out,\n       clear_ip_bgp_peer_group_out_cmd, \n       \"clear ip bgp peer-group WORD out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nDEFUN (clear_ip_bgp_peer_group_ipv4_soft_out,\n       clear_ip_bgp_peer_group_ipv4_soft_out_cmd,\n       \"clear ip bgp peer-group WORD ipv4 (unicast|multicast) soft out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n{\n  if (strncmp (argv[1], \"m\", 1) == 0)\n    return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MULTICAST, clear_group,\n\t\t\t  BGP_CLEAR_SOFT_OUT, argv[0]);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_group,\n\t\t\tBGP_CLEAR_SOFT_OUT, argv[0]);\n}\n\nALIAS (clear_ip_bgp_peer_group_ipv4_soft_out,\n       clear_ip_bgp_peer_group_ipv4_out_cmd,\n       \"clear ip bgp peer-group WORD ipv4 (unicast|multicast) out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nDEFUN (clear_bgp_peer_group_soft_out,\n       clear_bgp_peer_group_soft_out_cmd,\n       \"clear bgp peer-group WORD soft out\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_group,\n\t\t\tBGP_CLEAR_SOFT_OUT, argv[0]);\n}\n\nALIAS (clear_bgp_peer_group_soft_out,\n       clear_bgp_ipv6_peer_group_soft_out_cmd,\n       \"clear bgp ipv6 peer-group WORD soft out\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nALIAS (clear_bgp_peer_group_soft_out,\n       clear_bgp_peer_group_out_cmd,\n       \"clear bgp peer-group WORD out\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nALIAS (clear_bgp_peer_group_soft_out,\n       clear_bgp_ipv6_peer_group_out_cmd,\n       \"clear bgp ipv6 peer-group WORD out\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nDEFUN (clear_ip_bgp_external_soft_out,\n       clear_ip_bgp_external_soft_out_cmd, \n       \"clear ip bgp external soft out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all external peers\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_external,\n\t\t\tBGP_CLEAR_SOFT_OUT, NULL);\n}\n\nALIAS (clear_ip_bgp_external_soft_out,\n       clear_ip_bgp_external_out_cmd, \n       \"clear ip bgp external out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all external peers\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nDEFUN (clear_ip_bgp_external_ipv4_soft_out,\n       clear_ip_bgp_external_ipv4_soft_out_cmd,\n       \"clear ip bgp external ipv4 (unicast|multicast) soft out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all external peers\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n{\n  if (strncmp (argv[0], \"m\", 1) == 0)\n    return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MULTICAST, clear_external,\n\t\t\t  BGP_CLEAR_SOFT_OUT, NULL);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_external,\n\t\t\tBGP_CLEAR_SOFT_OUT, NULL);\n}\n\nALIAS (clear_ip_bgp_external_ipv4_soft_out,\n       clear_ip_bgp_external_ipv4_out_cmd,\n       \"clear ip bgp external ipv4 (unicast|multicast) out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all external peers\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nDEFUN (clear_bgp_external_soft_out,\n       clear_bgp_external_soft_out_cmd,\n       \"clear bgp external soft out\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear all external peers\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_external,\n\t\t\tBGP_CLEAR_SOFT_OUT, NULL);\n}\n\nALIAS (clear_bgp_external_soft_out,\n       clear_bgp_ipv6_external_soft_out_cmd,\n       \"clear bgp ipv6 external soft out\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear all external peers\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nALIAS (clear_bgp_external_soft_out,\n       clear_bgp_external_out_cmd,\n       \"clear bgp external out\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear all external peers\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nALIAS (clear_bgp_external_soft_out,\n       clear_bgp_ipv6_external_out_cmd,\n       \"clear bgp ipv6 external WORD out\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear all external peers\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nDEFUN (clear_ip_bgp_as_soft_out,\n       clear_ip_bgp_as_soft_out_cmd,\n       \"clear ip bgp <1-65535> soft out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_as,\n\t\t\tBGP_CLEAR_SOFT_OUT, argv[0]);\n}\n\nALIAS (clear_ip_bgp_as_soft_out,\n       clear_ip_bgp_as_out_cmd,\n       \"clear ip bgp <1-65535> out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nDEFUN (clear_ip_bgp_as_ipv4_soft_out,\n       clear_ip_bgp_as_ipv4_soft_out_cmd,\n       \"clear ip bgp <1-65535> ipv4 (unicast|multicast) soft out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n{\n  if (strncmp (argv[1], \"m\", 1) == 0)\n    return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MULTICAST, clear_as,\n\t\t\t  BGP_CLEAR_SOFT_OUT, argv[0]);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_as,\n\t\t\tBGP_CLEAR_SOFT_OUT, argv[0]);\n}\n\nALIAS (clear_ip_bgp_as_ipv4_soft_out,\n       clear_ip_bgp_as_ipv4_out_cmd,\n       \"clear ip bgp <1-65535> ipv4 (unicast|multicast) out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nDEFUN (clear_ip_bgp_as_vpnv4_soft_out,\n       clear_ip_bgp_as_vpnv4_soft_out_cmd,\n       \"clear ip bgp <1-65535> vpnv4 unicast soft out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MPLS_VPN, clear_as,\n\t\t\tBGP_CLEAR_SOFT_OUT, argv[0]);\n}\n\nALIAS (clear_ip_bgp_as_vpnv4_soft_out,\n       clear_ip_bgp_as_vpnv4_out_cmd,\n       \"clear ip bgp <1-65535> vpnv4 unicast out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nDEFUN (clear_bgp_as_soft_out,\n       clear_bgp_as_soft_out_cmd,\n       \"clear bgp <1-65535> soft out\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_as,\n\t\t\tBGP_CLEAR_SOFT_OUT, argv[0]);\n}\n\nALIAS (clear_bgp_as_soft_out,\n       clear_bgp_ipv6_as_soft_out_cmd,\n       \"clear bgp ipv6 <1-65535> soft out\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear peers with the AS number\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nALIAS (clear_bgp_as_soft_out,\n       clear_bgp_as_out_cmd,\n       \"clear bgp <1-65535> out\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\"\n       \"Soft reconfig outbound update\\n\")\n\nALIAS (clear_bgp_as_soft_out,\n       clear_bgp_ipv6_as_out_cmd,\n       \"clear bgp ipv6 <1-65535> out\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear peers with the AS number\\n\"\n       \"Soft reconfig outbound update\\n\")\n\f\n/* Inbound soft-reconfiguration */\nDEFUN (clear_ip_bgp_all_soft_in,\n       clear_ip_bgp_all_soft_in_cmd,\n       \"clear ip bgp * soft in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n{\n  if (argc == 1)\n    return bgp_clear_vty (vty, argv[0], AFI_IP, SAFI_UNICAST, clear_all,\n                          BGP_CLEAR_SOFT_IN, NULL);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_all,\n\t\t\tBGP_CLEAR_SOFT_IN, NULL);\n}\n\nALIAS (clear_ip_bgp_all_soft_in,\n       clear_ip_bgp_instance_all_soft_in_cmd,\n       \"clear ip bgp view WORD * soft in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"view name\\n\"\n       \"Clear all peers\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nALIAS (clear_ip_bgp_all_soft_in,\n       clear_ip_bgp_all_in_cmd,\n       \"clear ip bgp * in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nDEFUN (clear_ip_bgp_all_in_prefix_filter,\n       clear_ip_bgp_all_in_prefix_filter_cmd,\n       \"clear ip bgp * in prefix-filter\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Soft reconfig inbound update\\n\"\n       \"Push out prefix-list ORF and do inbound soft reconfig\\n\")\n{\n  if (argc== 1)\n    return bgp_clear_vty (vty, argv[0], AFI_IP, SAFI_UNICAST, clear_all,\n                          BGP_CLEAR_SOFT_IN_ORF_PREFIX, NULL);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_all,\n\t\t\tBGP_CLEAR_SOFT_IN_ORF_PREFIX, NULL);\n}\n\nALIAS (clear_ip_bgp_all_in_prefix_filter,\n       clear_ip_bgp_instance_all_in_prefix_filter_cmd,\n       \"clear ip bgp view WORD * in prefix-filter\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"view name\\n\"\n       \"Clear all peers\\n\"\n       \"Soft reconfig inbound update\\n\"\n       \"Push out prefix-list ORF and do inbound soft reconfig\\n\")\n\n\nDEFUN (clear_ip_bgp_all_ipv4_soft_in,\n       clear_ip_bgp_all_ipv4_soft_in_cmd,\n       \"clear ip bgp * ipv4 (unicast|multicast) soft in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n{\n  if (strncmp (argv[0], \"m\", 1) == 0)\n    return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MULTICAST, clear_all,\n\t\t\t  BGP_CLEAR_SOFT_IN, NULL);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_all,\n\t\t\tBGP_CLEAR_SOFT_IN, NULL);\n}\n\nALIAS (clear_ip_bgp_all_ipv4_soft_in,\n       clear_ip_bgp_all_ipv4_in_cmd,\n       \"clear ip bgp * ipv4 (unicast|multicast) in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nDEFUN (clear_ip_bgp_instance_all_ipv4_soft_in,\n       clear_ip_bgp_instance_all_ipv4_soft_in_cmd,\n       \"clear ip bgp view WORD * ipv4 (unicast|multicast) soft in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"view name\\n\"\n       \"Clear all peers\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n{\n  if (strncmp (argv[1], \"m\", 1) == 0)\n    return bgp_clear_vty (vty, argv[0], AFI_IP, SAFI_MULTICAST, clear_all,\n                          BGP_CLEAR_SOFT_IN, NULL);\n\n  return bgp_clear_vty (vty, argv[0], AFI_IP, SAFI_UNICAST, clear_all,\n                        BGP_CLEAR_SOFT_IN, NULL);\n}\n\nDEFUN (clear_ip_bgp_all_ipv4_in_prefix_filter,\n       clear_ip_bgp_all_ipv4_in_prefix_filter_cmd,\n       \"clear ip bgp * ipv4 (unicast|multicast) in prefix-filter\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig inbound update\\n\"\n       \"Push out prefix-list ORF and do inbound soft reconfig\\n\")\n{\n  if (strncmp (argv[0], \"m\", 1) == 0)\n    return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MULTICAST, clear_all,\n\t\t\t  BGP_CLEAR_SOFT_IN_ORF_PREFIX, NULL);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_all,\n\t\t\tBGP_CLEAR_SOFT_IN_ORF_PREFIX, NULL);\n}\n\nDEFUN (clear_ip_bgp_instance_all_ipv4_in_prefix_filter,\n       clear_ip_bgp_instance_all_ipv4_in_prefix_filter_cmd,\n       \"clear ip bgp view WORD * ipv4 (unicast|multicast) in prefix-filter\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig inbound update\\n\"\n       \"Push out prefix-list ORF and do inbound soft reconfig\\n\")\n{\n  if (strncmp (argv[1], \"m\", 1) == 0)\n    return bgp_clear_vty (vty, argv[0], AFI_IP, SAFI_MULTICAST, clear_all,\n                          BGP_CLEAR_SOFT_IN_ORF_PREFIX, NULL);\n\n  return bgp_clear_vty (vty, argv[0], AFI_IP, SAFI_UNICAST, clear_all,\n                        BGP_CLEAR_SOFT_IN_ORF_PREFIX, NULL);\n}\n\nDEFUN (clear_ip_bgp_all_vpnv4_soft_in,\n       clear_ip_bgp_all_vpnv4_soft_in_cmd,\n       \"clear ip bgp * vpnv4 unicast soft in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Address family\\n\"\n       \"Address Family Modifier\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MPLS_VPN, clear_all,\n\t\t\tBGP_CLEAR_SOFT_IN, NULL);\n}\n\nALIAS (clear_ip_bgp_all_vpnv4_soft_in,\n       clear_ip_bgp_all_vpnv4_in_cmd,\n       \"clear ip bgp * vpnv4 unicast in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Address family\\n\"\n       \"Address Family Modifier\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nDEFUN (clear_bgp_all_soft_in,\n       clear_bgp_all_soft_in_cmd,\n       \"clear bgp * soft in\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n{\n  if (argc == 1)\n    return bgp_clear_vty (vty, argv[0], AFI_IP6, SAFI_UNICAST, clear_all,\n                        BGP_CLEAR_SOFT_IN, NULL);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_all,\n\t\t\tBGP_CLEAR_SOFT_IN, NULL);\n}\n\nALIAS (clear_bgp_all_soft_in,\n       clear_bgp_instance_all_soft_in_cmd,\n       \"clear bgp view WORD * soft in\",\n       CLEAR_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"view name\\n\"\n       \"Clear all peers\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nALIAS (clear_bgp_all_soft_in,\n       clear_bgp_ipv6_all_soft_in_cmd,\n       \"clear bgp ipv6 * soft in\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear all peers\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nALIAS (clear_bgp_all_soft_in,\n       clear_bgp_all_in_cmd,\n       \"clear bgp * in\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nALIAS (clear_bgp_all_soft_in,\n       clear_bgp_ipv6_all_in_cmd,\n       \"clear bgp ipv6 * in\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear all peers\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nDEFUN (clear_bgp_all_in_prefix_filter,\n       clear_bgp_all_in_prefix_filter_cmd,\n       \"clear bgp * in prefix-filter\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Soft reconfig inbound update\\n\"\n       \"Push out prefix-list ORF and do inbound soft reconfig\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_all,\n\t\t\tBGP_CLEAR_SOFT_IN_ORF_PREFIX, NULL);\n}\n\nALIAS (clear_bgp_all_in_prefix_filter,\n       clear_bgp_ipv6_all_in_prefix_filter_cmd,\n       \"clear bgp ipv6 * in prefix-filter\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear all peers\\n\"\n       \"Soft reconfig inbound update\\n\"\n       \"Push out prefix-list ORF and do inbound soft reconfig\\n\")\n\nDEFUN (clear_ip_bgp_peer_soft_in,\n       clear_ip_bgp_peer_soft_in_cmd,\n       \"clear ip bgp A.B.C.D soft in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP neighbor address to clear\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_peer,\n\t\t\tBGP_CLEAR_SOFT_IN, argv[0]);\n}\n\nALIAS (clear_ip_bgp_peer_soft_in,\n       clear_ip_bgp_peer_in_cmd,\n       \"clear ip bgp A.B.C.D in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP neighbor address to clear\\n\"\n       \"Soft reconfig inbound update\\n\")\n       \nDEFUN (clear_ip_bgp_peer_in_prefix_filter,\n       clear_ip_bgp_peer_in_prefix_filter_cmd,\n       \"clear ip bgp A.B.C.D in prefix-filter\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP neighbor address to clear\\n\"\n       \"Soft reconfig inbound update\\n\"\n       \"Push out the existing ORF prefix-list\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_peer,\n\t\t\tBGP_CLEAR_SOFT_IN_ORF_PREFIX, argv[0]);\n}\n\nDEFUN (clear_ip_bgp_peer_ipv4_soft_in,\n       clear_ip_bgp_peer_ipv4_soft_in_cmd,\n       \"clear ip bgp A.B.C.D ipv4 (unicast|multicast) soft in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP neighbor address to clear\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n{\n  if (strncmp (argv[1], \"m\", 1) == 0)\n    return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MULTICAST, clear_peer,\n\t\t\t  BGP_CLEAR_SOFT_IN, argv[0]);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_peer,\n\t\t\tBGP_CLEAR_SOFT_IN, argv[0]);\n}\n\nALIAS (clear_ip_bgp_peer_ipv4_soft_in,\n       clear_ip_bgp_peer_ipv4_in_cmd,\n       \"clear ip bgp A.B.C.D ipv4 (unicast|multicast) in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP neighbor address to clear\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nDEFUN (clear_ip_bgp_peer_ipv4_in_prefix_filter,\n       clear_ip_bgp_peer_ipv4_in_prefix_filter_cmd,\n       \"clear ip bgp A.B.C.D ipv4 (unicast|multicast) in prefix-filter\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP neighbor address to clear\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig inbound update\\n\"\n       \"Push out the existing ORF prefix-list\\n\")\n{\n  if (strncmp (argv[1], \"m\", 1) == 0)\n    return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MULTICAST, clear_peer,\n\t\t\t  BGP_CLEAR_SOFT_IN_ORF_PREFIX, argv[0]);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_peer,\n\t\t\tBGP_CLEAR_SOFT_IN_ORF_PREFIX, argv[0]);\n}\n\nDEFUN (clear_ip_bgp_peer_vpnv4_soft_in,\n       clear_ip_bgp_peer_vpnv4_soft_in_cmd,\n       \"clear ip bgp A.B.C.D vpnv4 unicast soft in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP neighbor address to clear\\n\"\n       \"Address family\\n\"\n       \"Address Family Modifier\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MPLS_VPN, clear_peer,\n\t\t\tBGP_CLEAR_SOFT_IN, argv[0]);\n}\n\nALIAS (clear_ip_bgp_peer_vpnv4_soft_in,\n       clear_ip_bgp_peer_vpnv4_in_cmd,\n       \"clear ip bgp A.B.C.D vpnv4 unicast in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP neighbor address to clear\\n\"\n       \"Address family\\n\"\n       \"Address Family Modifier\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nDEFUN (clear_bgp_peer_soft_in,\n       clear_bgp_peer_soft_in_cmd,\n       \"clear bgp (A.B.C.D|X:X::X:X) soft in\",\n       CLEAR_STR\n       BGP_STR\n       \"BGP neighbor address to clear\\n\"\n       \"BGP IPv6 neighbor to clear\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_peer,\n\t\t\tBGP_CLEAR_SOFT_IN, argv[0]);\n}\n\nALIAS (clear_bgp_peer_soft_in,\n       clear_bgp_ipv6_peer_soft_in_cmd,\n       \"clear bgp ipv6 (A.B.C.D|X:X::X:X) soft in\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"BGP neighbor address to clear\\n\"\n       \"BGP IPv6 neighbor to clear\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nALIAS (clear_bgp_peer_soft_in,\n       clear_bgp_peer_in_cmd,\n       \"clear bgp (A.B.C.D|X:X::X:X) in\",\n       CLEAR_STR\n       BGP_STR\n       \"BGP neighbor address to clear\\n\"\n       \"BGP IPv6 neighbor to clear\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nALIAS (clear_bgp_peer_soft_in,\n       clear_bgp_ipv6_peer_in_cmd,\n       \"clear bgp ipv6 (A.B.C.D|X:X::X:X) in\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"BGP neighbor address to clear\\n\"\n       \"BGP IPv6 neighbor to clear\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nDEFUN (clear_bgp_peer_in_prefix_filter,\n       clear_bgp_peer_in_prefix_filter_cmd,\n       \"clear bgp (A.B.C.D|X:X::X:X) in prefix-filter\",\n       CLEAR_STR\n       BGP_STR\n       \"BGP neighbor address to clear\\n\"\n       \"BGP IPv6 neighbor to clear\\n\"\n       \"Soft reconfig inbound update\\n\"\n       \"Push out the existing ORF prefix-list\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_peer,\n\t\t\tBGP_CLEAR_SOFT_IN_ORF_PREFIX, argv[0]);\n}\n\nALIAS (clear_bgp_peer_in_prefix_filter,\n       clear_bgp_ipv6_peer_in_prefix_filter_cmd,\n       \"clear bgp ipv6 (A.B.C.D|X:X::X:X) in prefix-filter\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"BGP neighbor address to clear\\n\"\n       \"BGP IPv6 neighbor to clear\\n\"\n       \"Soft reconfig inbound update\\n\"\n       \"Push out the existing ORF prefix-list\\n\")\n\nDEFUN (clear_ip_bgp_peer_group_soft_in,\n       clear_ip_bgp_peer_group_soft_in_cmd,\n       \"clear ip bgp peer-group WORD soft in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_group,\n\t\t\tBGP_CLEAR_SOFT_IN, argv[0]);\n}\n\nALIAS (clear_ip_bgp_peer_group_soft_in,\n       clear_ip_bgp_peer_group_in_cmd,\n       \"clear ip bgp peer-group WORD in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nDEFUN (clear_ip_bgp_peer_group_in_prefix_filter,\n       clear_ip_bgp_peer_group_in_prefix_filter_cmd,\n       \"clear ip bgp peer-group WORD in prefix-filter\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\"\n       \"Soft reconfig inbound update\\n\"\n       \"Push out prefix-list ORF and do inbound soft reconfig\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_group,\n\t\t\tBGP_CLEAR_SOFT_IN_ORF_PREFIX, argv[0]);\n}\n\nDEFUN (clear_ip_bgp_peer_group_ipv4_soft_in,\n       clear_ip_bgp_peer_group_ipv4_soft_in_cmd,\n       \"clear ip bgp peer-group WORD ipv4 (unicast|multicast) soft in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n{\n  if (strncmp (argv[1], \"m\", 1) == 0)\n    return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MULTICAST, clear_group,\n\t\t\t  BGP_CLEAR_SOFT_IN, argv[0]);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_group,\n\t\t\tBGP_CLEAR_SOFT_IN, argv[0]);\n}\n\nALIAS (clear_ip_bgp_peer_group_ipv4_soft_in,\n       clear_ip_bgp_peer_group_ipv4_in_cmd,\n       \"clear ip bgp peer-group WORD ipv4 (unicast|multicast) in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nDEFUN (clear_ip_bgp_peer_group_ipv4_in_prefix_filter,\n       clear_ip_bgp_peer_group_ipv4_in_prefix_filter_cmd,\n       \"clear ip bgp peer-group WORD ipv4 (unicast|multicast) in prefix-filter\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig inbound update\\n\"\n       \"Push out prefix-list ORF and do inbound soft reconfig\\n\")\n{\n  if (strncmp (argv[1], \"m\", 1) == 0)\n    return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MULTICAST, clear_group,\n\t\t\t  BGP_CLEAR_SOFT_IN_ORF_PREFIX, argv[0]);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_group,\n\t\t\tBGP_CLEAR_SOFT_IN_ORF_PREFIX, argv[0]);\n}\n\nDEFUN (clear_bgp_peer_group_soft_in,\n       clear_bgp_peer_group_soft_in_cmd,\n       \"clear bgp peer-group WORD soft in\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_group,\n\t\t\tBGP_CLEAR_SOFT_IN, argv[0]);\n}\n\nALIAS (clear_bgp_peer_group_soft_in,\n       clear_bgp_ipv6_peer_group_soft_in_cmd,\n       \"clear bgp ipv6 peer-group WORD soft in\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nALIAS (clear_bgp_peer_group_soft_in,\n       clear_bgp_peer_group_in_cmd,\n       \"clear bgp peer-group WORD in\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nALIAS (clear_bgp_peer_group_soft_in,\n       clear_bgp_ipv6_peer_group_in_cmd,\n       \"clear bgp ipv6 peer-group WORD in\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nDEFUN (clear_bgp_peer_group_in_prefix_filter,\n       clear_bgp_peer_group_in_prefix_filter_cmd,\n       \"clear bgp peer-group WORD in prefix-filter\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\"\n       \"Soft reconfig inbound update\\n\"\n       \"Push out prefix-list ORF and do inbound soft reconfig\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_group,\n\t\t\tBGP_CLEAR_SOFT_IN_ORF_PREFIX, argv[0]);\n}\n\nALIAS (clear_bgp_peer_group_in_prefix_filter,\n       clear_bgp_ipv6_peer_group_in_prefix_filter_cmd,\n       \"clear bgp ipv6 peer-group WORD in prefix-filter\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\"\n       \"Soft reconfig inbound update\\n\"\n       \"Push out prefix-list ORF and do inbound soft reconfig\\n\")\n\nDEFUN (clear_ip_bgp_external_soft_in,\n       clear_ip_bgp_external_soft_in_cmd,\n       \"clear ip bgp external soft in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all external peers\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_external,\n\t\t\tBGP_CLEAR_SOFT_IN, NULL);\n}\n\nALIAS (clear_ip_bgp_external_soft_in,\n       clear_ip_bgp_external_in_cmd,\n       \"clear ip bgp external in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all external peers\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nDEFUN (clear_ip_bgp_external_in_prefix_filter,\n       clear_ip_bgp_external_in_prefix_filter_cmd,\n       \"clear ip bgp external in prefix-filter\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all external peers\\n\"\n       \"Soft reconfig inbound update\\n\"\n       \"Push out prefix-list ORF and do inbound soft reconfig\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_external,\n\t\t\tBGP_CLEAR_SOFT_IN_ORF_PREFIX, NULL);\n}\n\nDEFUN (clear_ip_bgp_external_ipv4_soft_in,\n       clear_ip_bgp_external_ipv4_soft_in_cmd,\n       \"clear ip bgp external ipv4 (unicast|multicast) soft in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all external peers\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n{\n  if (strncmp (argv[0], \"m\", 1) == 0)\n    return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MULTICAST, clear_external,\n\t\t\t  BGP_CLEAR_SOFT_IN, NULL);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_external,\n\t\t\tBGP_CLEAR_SOFT_IN, NULL);\n}\n\nALIAS (clear_ip_bgp_external_ipv4_soft_in,\n       clear_ip_bgp_external_ipv4_in_cmd,\n       \"clear ip bgp external ipv4 (unicast|multicast) in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all external peers\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nDEFUN (clear_ip_bgp_external_ipv4_in_prefix_filter,\n       clear_ip_bgp_external_ipv4_in_prefix_filter_cmd,\n       \"clear ip bgp external ipv4 (unicast|multicast) in prefix-filter\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all external peers\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig inbound update\\n\"\n       \"Push out prefix-list ORF and do inbound soft reconfig\\n\")\n{\n  if (strncmp (argv[0], \"m\", 1) == 0)\n    return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MULTICAST, clear_external,\n\t\t\t  BGP_CLEAR_SOFT_IN_ORF_PREFIX, NULL);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_external,\n\t\t\tBGP_CLEAR_SOFT_IN_ORF_PREFIX, NULL);\n}\n\nDEFUN (clear_bgp_external_soft_in,\n       clear_bgp_external_soft_in_cmd,\n       \"clear bgp external soft in\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear all external peers\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_external,\n\t\t\tBGP_CLEAR_SOFT_IN, NULL);\n}\n\nALIAS (clear_bgp_external_soft_in,\n       clear_bgp_ipv6_external_soft_in_cmd,\n       \"clear bgp ipv6 external soft in\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear all external peers\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nALIAS (clear_bgp_external_soft_in,\n       clear_bgp_external_in_cmd,\n       \"clear bgp external in\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear all external peers\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nALIAS (clear_bgp_external_soft_in,\n       clear_bgp_ipv6_external_in_cmd,\n       \"clear bgp ipv6 external WORD in\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear all external peers\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nDEFUN (clear_bgp_external_in_prefix_filter,\n       clear_bgp_external_in_prefix_filter_cmd,\n       \"clear bgp external in prefix-filter\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear all external peers\\n\"\n       \"Soft reconfig inbound update\\n\"\n       \"Push out prefix-list ORF and do inbound soft reconfig\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_external,\n\t\t\tBGP_CLEAR_SOFT_IN_ORF_PREFIX, NULL);\n}\n\nALIAS (clear_bgp_external_in_prefix_filter,\n       clear_bgp_ipv6_external_in_prefix_filter_cmd,\n       \"clear bgp ipv6 external in prefix-filter\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear all external peers\\n\"\n       \"Soft reconfig inbound update\\n\"\n       \"Push out prefix-list ORF and do inbound soft reconfig\\n\")\n\nDEFUN (clear_ip_bgp_as_soft_in,\n       clear_ip_bgp_as_soft_in_cmd,\n       \"clear ip bgp <1-65535> soft in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_as,\n\t\t\tBGP_CLEAR_SOFT_IN, argv[0]);\n}\n\nALIAS (clear_ip_bgp_as_soft_in,\n       clear_ip_bgp_as_in_cmd,\n       \"clear ip bgp <1-65535> in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nDEFUN (clear_ip_bgp_as_in_prefix_filter,\n       clear_ip_bgp_as_in_prefix_filter_cmd,\n       \"clear ip bgp <1-65535> in prefix-filter\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\"\n       \"Soft reconfig inbound update\\n\"\n       \"Push out prefix-list ORF and do inbound soft reconfig\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_as,\n\t\t\tBGP_CLEAR_SOFT_IN_ORF_PREFIX, argv[0]);\n}\n\nDEFUN (clear_ip_bgp_as_ipv4_soft_in,\n       clear_ip_bgp_as_ipv4_soft_in_cmd,\n       \"clear ip bgp <1-65535> ipv4 (unicast|multicast) soft in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n{\n  if (strncmp (argv[1], \"m\", 1) == 0)\n    return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MULTICAST, clear_as,\n\t\t\t  BGP_CLEAR_SOFT_IN, argv[0]);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_as,\n\t\t\tBGP_CLEAR_SOFT_IN, argv[0]);\n}\n\nALIAS (clear_ip_bgp_as_ipv4_soft_in,\n       clear_ip_bgp_as_ipv4_in_cmd,\n       \"clear ip bgp <1-65535> ipv4 (unicast|multicast) in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nDEFUN (clear_ip_bgp_as_ipv4_in_prefix_filter,\n       clear_ip_bgp_as_ipv4_in_prefix_filter_cmd,\n       \"clear ip bgp <1-65535> ipv4 (unicast|multicast) in prefix-filter\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig inbound update\\n\"\n       \"Push out prefix-list ORF and do inbound soft reconfig\\n\")\n{\n  if (strncmp (argv[1], \"m\", 1) == 0)\n    return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MULTICAST, clear_as,\n\t\t\t  BGP_CLEAR_SOFT_IN_ORF_PREFIX, argv[0]);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_as,\n\t\t\tBGP_CLEAR_SOFT_IN_ORF_PREFIX, argv[0]);\n}\n\nDEFUN (clear_ip_bgp_as_vpnv4_soft_in,\n       clear_ip_bgp_as_vpnv4_soft_in_cmd,\n       \"clear ip bgp <1-65535> vpnv4 unicast soft in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MPLS_VPN, clear_as,\n\t\t\tBGP_CLEAR_SOFT_IN, argv[0]);\n}\n\nALIAS (clear_ip_bgp_as_vpnv4_soft_in,\n       clear_ip_bgp_as_vpnv4_in_cmd,\n       \"clear ip bgp <1-65535> vpnv4 unicast in\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nDEFUN (clear_bgp_as_soft_in,\n       clear_bgp_as_soft_in_cmd,\n       \"clear bgp <1-65535> soft in\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_as,\n\t\t\tBGP_CLEAR_SOFT_IN, argv[0]);\n}\n\nALIAS (clear_bgp_as_soft_in,\n       clear_bgp_ipv6_as_soft_in_cmd,\n       \"clear bgp ipv6 <1-65535> soft in\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear peers with the AS number\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nALIAS (clear_bgp_as_soft_in,\n       clear_bgp_as_in_cmd,\n       \"clear bgp <1-65535> in\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nALIAS (clear_bgp_as_soft_in,\n       clear_bgp_ipv6_as_in_cmd,\n       \"clear bgp ipv6 <1-65535> in\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear peers with the AS number\\n\"\n       \"Soft reconfig inbound update\\n\")\n\nDEFUN (clear_bgp_as_in_prefix_filter,\n       clear_bgp_as_in_prefix_filter_cmd,\n       \"clear bgp <1-65535> in prefix-filter\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\"\n       \"Soft reconfig inbound update\\n\"\n       \"Push out prefix-list ORF and do inbound soft reconfig\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_as,\n\t\t\tBGP_CLEAR_SOFT_IN_ORF_PREFIX, argv[0]);\n}\n\nALIAS (clear_bgp_as_in_prefix_filter,\n       clear_bgp_ipv6_as_in_prefix_filter_cmd,\n       \"clear bgp ipv6 <1-65535> in prefix-filter\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear peers with the AS number\\n\"\n       \"Soft reconfig inbound update\\n\"\n       \"Push out prefix-list ORF and do inbound soft reconfig\\n\")\n\f\n/* Both soft-reconfiguration */\nDEFUN (clear_ip_bgp_all_soft,\n       clear_ip_bgp_all_soft_cmd,\n       \"clear ip bgp * soft\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Soft reconfig\\n\")\n{\n  if (argc == 1)\n    return bgp_clear_vty (vty, argv[0], AFI_IP, SAFI_UNICAST, clear_all,\n                        BGP_CLEAR_SOFT_BOTH, NULL);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_all,\n\t\t\tBGP_CLEAR_SOFT_BOTH, NULL);\n}\n\nALIAS (clear_ip_bgp_all_soft,\n       clear_ip_bgp_instance_all_soft_cmd,\n       \"clear ip bgp view WORD * soft\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"view name\\n\"\n       \"Clear all peers\\n\"\n       \"Soft reconfig\\n\")\n\n\nDEFUN (clear_ip_bgp_all_ipv4_soft,\n       clear_ip_bgp_all_ipv4_soft_cmd,\n       \"clear ip bgp * ipv4 (unicast|multicast) soft\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Address family\\n\"\n       \"Address Family Modifier\\n\"\n       \"Address Family Modifier\\n\"\n       \"Soft reconfig\\n\")\n{\n  if (strncmp (argv[0], \"m\", 1) == 0)\n    return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MULTICAST, clear_all,\n\t\t\t  BGP_CLEAR_SOFT_BOTH, NULL);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_all,\n\t\t\tBGP_CLEAR_SOFT_BOTH, NULL);\n}\n\nDEFUN (clear_ip_bgp_instance_all_ipv4_soft,\n       clear_ip_bgp_instance_all_ipv4_soft_cmd,\n       \"clear ip bgp view WORD * ipv4 (unicast|multicast) soft\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"view name\\n\"\n       \"Clear all peers\\n\"\n       \"Address family\\n\"\n       \"Address Family Modifier\\n\"\n       \"Address Family Modifier\\n\"\n       \"Soft reconfig\\n\")\n{\n  if (strncmp (argv[1], \"m\", 1) == 0)\n    return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MULTICAST, clear_all,\n                          BGP_CLEAR_SOFT_BOTH, NULL);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_all,\n                        BGP_CLEAR_SOFT_BOTH, NULL);\n}\n\nDEFUN (clear_ip_bgp_all_vpnv4_soft,\n       clear_ip_bgp_all_vpnv4_soft_cmd,\n       \"clear ip bgp * vpnv4 unicast soft\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Address family\\n\"\n       \"Address Family Modifier\\n\"\n       \"Soft reconfig\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MPLS_VPN, clear_all,\n\t\t\tBGP_CLEAR_SOFT_BOTH, argv[0]);\n}\n\nDEFUN (clear_bgp_all_soft,\n       clear_bgp_all_soft_cmd,\n       \"clear bgp * soft\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Soft reconfig\\n\")\n{\n  if (argc == 1)\n    return bgp_clear_vty (vty, argv[0], AFI_IP6, SAFI_UNICAST, clear_all,\n                        BGP_CLEAR_SOFT_BOTH, argv[0]);\n \n  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_all,\n\t\t\tBGP_CLEAR_SOFT_BOTH, argv[0]);\n}\n\nALIAS (clear_bgp_all_soft,\n       clear_bgp_instance_all_soft_cmd,\n       \"clear bgp view WORD * soft\",\n       CLEAR_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"view name\\n\"\n       \"Clear all peers\\n\"\n       \"Soft reconfig\\n\")\n\nALIAS (clear_bgp_all_soft,\n       clear_bgp_ipv6_all_soft_cmd,\n       \"clear bgp ipv6 * soft\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear all peers\\n\"\n       \"Soft reconfig\\n\")\n\nDEFUN (clear_ip_bgp_peer_soft,\n       clear_ip_bgp_peer_soft_cmd,\n       \"clear ip bgp A.B.C.D soft\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP neighbor address to clear\\n\"\n       \"Soft reconfig\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_peer,\n\t\t\tBGP_CLEAR_SOFT_BOTH, argv[0]);\n}\n\nDEFUN (clear_ip_bgp_peer_ipv4_soft,\n       clear_ip_bgp_peer_ipv4_soft_cmd,\n       \"clear ip bgp A.B.C.D ipv4 (unicast|multicast) soft\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP neighbor address to clear\\n\"\n       \"Address family\\n\"\n       \"Address Family Modifier\\n\"\n       \"Address Family Modifier\\n\"\n       \"Soft reconfig\\n\")\n{\n  if (strncmp (argv[1], \"m\", 1) == 0)\n    return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MULTICAST, clear_peer,\n\t\t\t  BGP_CLEAR_SOFT_BOTH, argv[0]);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_peer,\n\t\t\tBGP_CLEAR_SOFT_BOTH, argv[0]);\n}\n\nDEFUN (clear_ip_bgp_peer_vpnv4_soft,\n       clear_ip_bgp_peer_vpnv4_soft_cmd,\n       \"clear ip bgp A.B.C.D vpnv4 unicast soft\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP neighbor address to clear\\n\"\n       \"Address family\\n\"\n       \"Address Family Modifier\\n\"\n       \"Soft reconfig\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MPLS_VPN, clear_peer,\n\t\t\tBGP_CLEAR_SOFT_BOTH, argv[0]);\n}\n\nDEFUN (clear_bgp_peer_soft,\n       clear_bgp_peer_soft_cmd,\n       \"clear bgp (A.B.C.D|X:X::X:X) soft\",\n       CLEAR_STR\n       BGP_STR\n       \"BGP neighbor address to clear\\n\"\n       \"BGP IPv6 neighbor to clear\\n\"\n       \"Soft reconfig\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_peer,\n\t\t\tBGP_CLEAR_SOFT_BOTH, argv[0]);\n}\n\nALIAS (clear_bgp_peer_soft,\n       clear_bgp_ipv6_peer_soft_cmd,\n       \"clear bgp ipv6 (A.B.C.D|X:X::X:X) soft\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"BGP neighbor address to clear\\n\"\n       \"BGP IPv6 neighbor to clear\\n\"\n       \"Soft reconfig\\n\")\n\nDEFUN (clear_ip_bgp_peer_group_soft,\n       clear_ip_bgp_peer_group_soft_cmd,\n       \"clear ip bgp peer-group WORD soft\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\"\n       \"Soft reconfig\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_group,\n\t\t\tBGP_CLEAR_SOFT_BOTH, argv[0]);\n}\n\nDEFUN (clear_ip_bgp_peer_group_ipv4_soft,\n       clear_ip_bgp_peer_group_ipv4_soft_cmd,\n       \"clear ip bgp peer-group WORD ipv4 (unicast|multicast) soft\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig\\n\")\n{\n  if (strncmp (argv[1], \"m\", 1) == 0)\n    return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MULTICAST, clear_group,\n\t\t\t  BGP_CLEAR_SOFT_BOTH, argv[0]);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_group,\n\t\t\tBGP_CLEAR_SOFT_BOTH, argv[0]);\n}\n\nDEFUN (clear_bgp_peer_group_soft,\n       clear_bgp_peer_group_soft_cmd,\n       \"clear bgp peer-group WORD soft\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\"\n       \"Soft reconfig\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_group,\n\t\t\tBGP_CLEAR_SOFT_BOTH, argv[0]);\n}\n\nALIAS (clear_bgp_peer_group_soft,\n       clear_bgp_ipv6_peer_group_soft_cmd,\n       \"clear bgp ipv6 peer-group WORD soft\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear all members of peer-group\\n\"\n       \"BGP peer-group name\\n\"\n       \"Soft reconfig\\n\")\n\nDEFUN (clear_ip_bgp_external_soft,\n       clear_ip_bgp_external_soft_cmd,\n       \"clear ip bgp external soft\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all external peers\\n\"\n       \"Soft reconfig\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_external,\n\t\t\tBGP_CLEAR_SOFT_BOTH, NULL);\n}\n\nDEFUN (clear_ip_bgp_external_ipv4_soft,\n       clear_ip_bgp_external_ipv4_soft_cmd,\n       \"clear ip bgp external ipv4 (unicast|multicast) soft\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all external peers\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Soft reconfig\\n\")\n{\n  if (strncmp (argv[0], \"m\", 1) == 0)\n    return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MULTICAST, clear_external,\n\t\t\t  BGP_CLEAR_SOFT_BOTH, NULL);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_external,\n\t\t\tBGP_CLEAR_SOFT_BOTH, NULL);\n}\n\nDEFUN (clear_bgp_external_soft,\n       clear_bgp_external_soft_cmd,\n       \"clear bgp external soft\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear all external peers\\n\"\n       \"Soft reconfig\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_external,\n\t\t\tBGP_CLEAR_SOFT_BOTH, NULL);\n}\n\nALIAS (clear_bgp_external_soft,\n       clear_bgp_ipv6_external_soft_cmd,\n       \"clear bgp ipv6 external soft\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear all external peers\\n\"\n       \"Soft reconfig\\n\")\n\nDEFUN (clear_ip_bgp_as_soft,\n       clear_ip_bgp_as_soft_cmd,\n       \"clear ip bgp <1-65535> soft\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\"\n       \"Soft reconfig\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_as,\n\t\t\tBGP_CLEAR_SOFT_BOTH, argv[0]);\n}\n\nDEFUN (clear_ip_bgp_as_ipv4_soft,\n       clear_ip_bgp_as_ipv4_soft_cmd,\n       \"clear ip bgp <1-65535> ipv4 (unicast|multicast) soft\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\"\n       \"Address family\\n\"\n       \"Address Family Modifier\\n\"\n       \"Address Family Modifier\\n\"\n       \"Soft reconfig\\n\")\n{\n  if (strncmp (argv[1], \"m\", 1) == 0)\n    return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MULTICAST, clear_as,\n\t\t\t  BGP_CLEAR_SOFT_BOTH, argv[0]);\n\n  return bgp_clear_vty (vty, NULL,AFI_IP, SAFI_UNICAST, clear_as,\n\t\t\tBGP_CLEAR_SOFT_BOTH, argv[0]);\n}\n\nDEFUN (clear_ip_bgp_as_vpnv4_soft,\n       clear_ip_bgp_as_vpnv4_soft_cmd,\n       \"clear ip bgp <1-65535> vpnv4 unicast soft\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\"\n       \"Address family\\n\"\n       \"Address Family Modifier\\n\"\n       \"Soft reconfig\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_MPLS_VPN, clear_as,\n\t\t\tBGP_CLEAR_SOFT_BOTH, argv[0]);\n}\n\nDEFUN (clear_bgp_as_soft,\n       clear_bgp_as_soft_cmd,\n       \"clear bgp <1-65535> soft\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\"\n       \"Soft reconfig\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_as,\n\t\t\tBGP_CLEAR_SOFT_BOTH, argv[0]);\n}\n\nALIAS (clear_bgp_as_soft,\n       clear_bgp_ipv6_as_soft_cmd,\n       \"clear bgp ipv6 <1-65535> soft\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear peers with the AS number\\n\"\n       \"Soft reconfig\\n\")\n\f\n/* RS-client soft reconfiguration. */\n#ifdef HAVE_IPV6\nDEFUN (clear_bgp_all_rsclient,\n       clear_bgp_all_rsclient_cmd,\n       \"clear bgp * rsclient\",\n       CLEAR_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Soft reconfig for rsclient RIB\\n\")\n{\n  if (argc == 1)\n    return bgp_clear_vty (vty, argv[0], AFI_IP6, SAFI_UNICAST, clear_all,\n                          BGP_CLEAR_SOFT_RSCLIENT, NULL);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_all,\n                        BGP_CLEAR_SOFT_RSCLIENT, NULL);\n}\n\nALIAS (clear_bgp_all_rsclient,\n       clear_bgp_ipv6_all_rsclient_cmd,\n       \"clear bgp ipv6 * rsclient\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Clear all peers\\n\"\n       \"Soft reconfig for rsclient RIB\\n\")\n\nALIAS (clear_bgp_all_rsclient,\n       clear_bgp_instance_all_rsclient_cmd,\n       \"clear bgp view WORD * rsclient\",\n       CLEAR_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"view name\\n\"\n       \"Clear all peers\\n\"\n       \"Soft reconfig for rsclient RIB\\n\")\n\nALIAS (clear_bgp_all_rsclient,\n       clear_bgp_ipv6_instance_all_rsclient_cmd,\n       \"clear bgp ipv6 view WORD * rsclient\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"BGP view\\n\"\n       \"view name\\n\"\n       \"Clear all peers\\n\"\n       \"Soft reconfig for rsclient RIB\\n\")\n#endif /* HAVE_IPV6 */\n\nDEFUN (clear_ip_bgp_all_rsclient,\n       clear_ip_bgp_all_rsclient_cmd,\n       \"clear ip bgp * rsclient\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear all peers\\n\"\n       \"Soft reconfig for rsclient RIB\\n\")\n{\n  if (argc == 1)\n    return bgp_clear_vty (vty, argv[0], AFI_IP, SAFI_UNICAST, clear_all,\n                          BGP_CLEAR_SOFT_RSCLIENT, NULL);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_all,\n                        BGP_CLEAR_SOFT_RSCLIENT, NULL);\n}\n\nALIAS (clear_ip_bgp_all_rsclient,\n       clear_ip_bgp_instance_all_rsclient_cmd,\n       \"clear ip bgp view WORD * rsclient\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"view name\\n\"\n       \"Clear all peers\\n\"\n       \"Soft reconfig for rsclient RIB\\n\")\n\n#ifdef HAVE_IPV6\nDEFUN (clear_bgp_peer_rsclient,\n       clear_bgp_peer_rsclient_cmd,\n       \"clear bgp (A.B.C.D|X:X::X:X) rsclient\",\n       CLEAR_STR\n       BGP_STR\n       \"BGP neighbor IP address to clear\\n\"\n       \"BGP IPv6 neighbor to clear\\n\"\n       \"Soft reconfig for rsclient RIB\\n\")\n{\n  if (argc == 2)\n    return bgp_clear_vty (vty, argv[0], AFI_IP6, SAFI_UNICAST, clear_peer,\n                          BGP_CLEAR_SOFT_RSCLIENT, argv[1]);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP6, SAFI_UNICAST, clear_peer,\n                        BGP_CLEAR_SOFT_RSCLIENT, argv[0]);\n}\n\nALIAS (clear_bgp_peer_rsclient,\n       clear_bgp_ipv6_peer_rsclient_cmd,\n       \"clear bgp ipv6 (A.B.C.D|X:X::X:X) rsclient\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"BGP neighbor IP address to clear\\n\"\n       \"BGP IPv6 neighbor to clear\\n\"\n       \"Soft reconfig for rsclient RIB\\n\")\n\nALIAS (clear_bgp_peer_rsclient,\n       clear_bgp_instance_peer_rsclient_cmd,\n       \"clear bgp view WORD (A.B.C.D|X:X::X:X) rsclient\",\n       CLEAR_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"view name\\n\"\n       \"BGP neighbor IP address to clear\\n\"\n       \"BGP IPv6 neighbor to clear\\n\"\n       \"Soft reconfig for rsclient RIB\\n\")\n\nALIAS (clear_bgp_peer_rsclient,\n       clear_bgp_ipv6_instance_peer_rsclient_cmd,\n       \"clear bgp ipv6 view WORD (A.B.C.D|X:X::X:X) rsclient\",\n       CLEAR_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"BGP view\\n\"\n       \"view name\\n\"\n       \"BGP neighbor IP address to clear\\n\"\n       \"BGP IPv6 neighbor to clear\\n\"\n       \"Soft reconfig for rsclient RIB\\n\")\n#endif /* HAVE_IPV6 */\n\nDEFUN (clear_ip_bgp_peer_rsclient,\n       clear_ip_bgp_peer_rsclient_cmd,\n       \"clear ip bgp (A.B.C.D|X:X::X:X) rsclient\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP neighbor IP address to clear\\n\"\n       \"BGP IPv6 neighbor to clear\\n\"\n       \"Soft reconfig for rsclient RIB\\n\")\n{\n  if (argc == 2)\n    return bgp_clear_vty (vty, argv[0], AFI_IP, SAFI_UNICAST, clear_peer,\n                          BGP_CLEAR_SOFT_RSCLIENT, argv[1]);\n\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_peer,\n                        BGP_CLEAR_SOFT_RSCLIENT, argv[0]);\n}\n\nALIAS (clear_ip_bgp_peer_rsclient,\n       clear_ip_bgp_instance_peer_rsclient_cmd,\n       \"clear ip bgp view WORD (A.B.C.D|X:X::X:X) rsclient\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"view name\\n\"\n       \"BGP neighbor IP address to clear\\n\"\n       \"BGP IPv6 neighbor to clear\\n\"\n       \"Soft reconfig for rsclient RIB\\n\")\n\nDEFUN (show_bgp_memory, \n       show_bgp_memory_cmd,\n       \"show bgp memory\",\n       SHOW_STR\n       BGP_STR\n       \"Global BGP memory statistics\\n\")\n{\n  char memstrbuf[MTYPE_MEMSTR_LEN];\n  unsigned long count;\n  \n  /* RIB related usage stats */\n  count = mtype_stats_alloc (MTYPE_BGP_NODE);\n  vty_out (vty, \"%ld RIB nodes, using %s of memory%s\", count,\n           mtype_memstr (memstrbuf, sizeof (memstrbuf),\n                         count * sizeof (struct bgp_node)),\n           VTY_NEWLINE);\n  \n  count = mtype_stats_alloc (MTYPE_BGP_ROUTE);\n  vty_out (vty, \"%ld BGP routes, using %s of memory%s\", count,\n           mtype_memstr (memstrbuf, sizeof (memstrbuf),\n                         count * sizeof (struct bgp_info)),\n           VTY_NEWLINE);\n  if ((count = mtype_stats_alloc (MTYPE_BGP_ROUTE_EXTRA)))\n    vty_out (vty, \"%ld BGP route ancillaries, using %s of memory%s\", count,\n             mtype_memstr (memstrbuf, sizeof (memstrbuf),\n                           count * sizeof (struct bgp_info_extra)),\n             VTY_NEWLINE);\n  \n  if ((count = mtype_stats_alloc (MTYPE_BGP_STATIC)))\n    vty_out (vty, \"%ld Static routes, using %s of memory%s\", count,\n             mtype_memstr (memstrbuf, sizeof (memstrbuf),\n                         count * sizeof (struct bgp_static)),\n             VTY_NEWLINE);\n  \n  /* Adj-In/Out */\n  if ((count = mtype_stats_alloc (MTYPE_BGP_ADJ_IN)))\n    vty_out (vty, \"%ld Adj-In entries, using %s of memory%s\", count,\n             mtype_memstr (memstrbuf, sizeof (memstrbuf),\n                           count * sizeof (struct bgp_adj_in)),\n             VTY_NEWLINE);\n  if ((count = mtype_stats_alloc (MTYPE_BGP_ADJ_OUT)))\n    vty_out (vty, \"%ld Adj-Out entries, using %s of memory%s\", count,\n             mtype_memstr (memstrbuf, sizeof (memstrbuf),\n                           count * sizeof (struct bgp_adj_out)),\n             VTY_NEWLINE);\n  \n  if ((count = mtype_stats_alloc (MTYPE_BGP_NEXTHOP_CACHE)))\n    vty_out (vty, \"%ld Nexthop cache entries, using %s of memory%s\", count,\n             mtype_memstr (memstrbuf, sizeof (memstrbuf),\n                         count * sizeof (struct bgp_nexthop_cache)),\n             VTY_NEWLINE);\n\n  if ((count = mtype_stats_alloc (MTYPE_BGP_DAMP_INFO)))\n    vty_out (vty, \"%ld Dampening entries, using %s of memory%s\", count,\n             mtype_memstr (memstrbuf, sizeof (memstrbuf),\n                         count * sizeof (struct bgp_damp_info)),\n             VTY_NEWLINE);\n\n  /* Attributes */\n  count = attr_count();\n  vty_out (vty, \"%ld BGP attributes, using %s of memory%s\", count, \n           mtype_memstr (memstrbuf, sizeof (memstrbuf), \n                         count * sizeof(struct attr)), \n           VTY_NEWLINE);\n  if ((count = mtype_stats_alloc (MTYPE_ATTR_EXTRA)))\n    vty_out (vty, \"%ld BGP extra attributes, using %s of memory%s\", count, \n             mtype_memstr (memstrbuf, sizeof (memstrbuf), \n                           count * sizeof(struct attr_extra)), \n             VTY_NEWLINE);\n  \n  if ((count = attr_unknown_count()))\n    vty_out (vty, \"%ld unknown attributes%s\", count, VTY_NEWLINE);\n  \n  /* AS_PATH attributes */\n  count = aspath_count ();\n  vty_out (vty, \"%ld BGP AS-PATH entries, using %s of memory%s\", count,\n           mtype_memstr (memstrbuf, sizeof (memstrbuf),\n                         count * sizeof (struct aspath)),\n           VTY_NEWLINE);\n  \n  count = mtype_stats_alloc (MTYPE_AS_SEG);\n  vty_out (vty, \"%ld BGP AS-PATH segments, using %s of memory%s\", count,\n           mtype_memstr (memstrbuf, sizeof (memstrbuf),\n                         count * sizeof (struct assegment)),\n           VTY_NEWLINE);\n  \n  /* Other attributes */\n  if ((count = community_count ()))\n    vty_out (vty, \"%ld BGP community entries, using %s of memory%s\", count,\n             mtype_memstr (memstrbuf, sizeof (memstrbuf),\n                         count * sizeof (struct community)),\n             VTY_NEWLINE);\n  if ((count = mtype_stats_alloc (MTYPE_ECOMMUNITY)))\n    vty_out (vty, \"%ld BGP community entries, using %s of memory%s\", count,\n             mtype_memstr (memstrbuf, sizeof (memstrbuf),\n                         count * sizeof (struct ecommunity)),\n             VTY_NEWLINE);\n  \n  if ((count = mtype_stats_alloc (MTYPE_CLUSTER)))\n    vty_out (vty, \"%ld Cluster lists, using %s of memory%s\", count,\n             mtype_memstr (memstrbuf, sizeof (memstrbuf),\n                         count * sizeof (struct cluster_list)),\n             VTY_NEWLINE);\n  \n  /* Peer related usage */\n  count = mtype_stats_alloc (MTYPE_BGP_PEER);\n  vty_out (vty, \"%ld peers, using %s of memory%s\", count,\n           mtype_memstr (memstrbuf, sizeof (memstrbuf),\n                         count * sizeof (struct peer)),\n           VTY_NEWLINE);\n  \n  if ((count = mtype_stats_alloc (MTYPE_PEER_GROUP)))\n    vty_out (vty, \"%ld peer groups, using %s of memory%s\", count,\n             mtype_memstr (memstrbuf, sizeof (memstrbuf),\n                           count * sizeof (struct peer_group)),\n             VTY_NEWLINE);\n  \n  /* Other */\n  if ((count = mtype_stats_alloc (MTYPE_HASH)))\n    vty_out (vty, \"%ld hash tables, using %s of memory%s\", count,\n             mtype_memstr (memstrbuf, sizeof (memstrbuf),\n                           count * sizeof (struct hash)),\n             VTY_NEWLINE);\n  if ((count = mtype_stats_alloc (MTYPE_HASH_BACKET)))\n    vty_out (vty, \"%ld hash buckets, using %s of memory%s\", count,\n             mtype_memstr (memstrbuf, sizeof (memstrbuf),\n                           count * sizeof (struct hash_backet)),\n             VTY_NEWLINE);\n  if ((count = mtype_stats_alloc (MTYPE_BGP_REGEXP)))\n    vty_out (vty, \"%ld compiled regexes, using %s of memory%s\", count,\n             mtype_memstr (memstrbuf, sizeof (memstrbuf),\n                           count * sizeof (regex_t)),\n             VTY_NEWLINE);\n  return CMD_SUCCESS;\n}\n\n/* Show BGP peer's summary information. */\nstatic int\nbgp_show_summary (struct vty *vty, struct bgp *bgp, int afi, int safi)\n{\n  struct peer *peer;\n  struct listnode *node, *nnode;\n  unsigned int count = 0;\n  char timebuf[BGP_UPTIME_LEN];\n  int len;\n\n  /* Header string for each address family. */\n  static char header[] = \"Neighbor        V    AS MsgRcvd MsgSent   TblVer  InQ OutQ Up/Down  State/PfxRcd\";\n  \n  for (ALL_LIST_ELEMENTS (bgp->peer, node, nnode, peer))\n    {\n      if (peer->afc[afi][safi])\n\t{\n          if (!count)\n            {\n              unsigned long ents;\n              char memstrbuf[MTYPE_MEMSTR_LEN];\n              \n              /* Usage summary and header */\n              vty_out (vty,\n                       \"BGP router identifier %s, local AS number %d%s\",\n                       inet_ntoa (bgp->router_id), bgp->as, VTY_NEWLINE);\n\n              ents = bgp_table_count (bgp->rib[afi][safi]);\n              vty_out (vty, \"RIB entries %ld, using %s of memory%s\", ents,\n                       mtype_memstr (memstrbuf, sizeof (memstrbuf),\n                                     ents * sizeof (struct bgp_node)),\n                       VTY_NEWLINE);\n              \n              /* Peer related usage */\n              ents = listcount (bgp->peer);\n              vty_out (vty, \"Peers %ld, using %s of memory%s\",\n                       ents,\n                       mtype_memstr (memstrbuf, sizeof (memstrbuf),\n                                     ents * sizeof (struct peer)),\n                       VTY_NEWLINE);\n              \n              if ((ents = listcount (bgp->rsclient)))\n                vty_out (vty, \"RS-Client peers %ld, using %s of memory%s\",\n                         ents,\n                         mtype_memstr (memstrbuf, sizeof (memstrbuf),\n                                       ents * sizeof (struct peer)),\n                         VTY_NEWLINE);\n              \n              if ((ents = listcount (bgp->group)))\n                vty_out (vty, \"Peer groups %ld, using %s of memory%s\", ents,\n                         mtype_memstr (memstrbuf, sizeof (memstrbuf),\n                                       ents * sizeof (struct peer_group)),\n                         VTY_NEWLINE);\n\n              if (CHECK_FLAG (bgp->af_flags[afi][safi], BGP_CONFIG_DAMPENING))\n                vty_out (vty, \"Dampening enabled.%s\", VTY_NEWLINE);\n              vty_out (vty, \"%s\", VTY_NEWLINE);\n              vty_out (vty, \"%s%s\", header, VTY_NEWLINE);\n            }\n          \n\t  count++;\n\n\t  len = vty_out (vty, \"%s\", peer->host);\n\t  len = 16 - len;\n\t  if (len < 1)\n\t    vty_out (vty, \"%s%*s\", VTY_NEWLINE, 16, \" \");\n\t  else\n\t    vty_out (vty, \"%*s\", len, \" \");\n\n\t  vty_out (vty, \"4 \");\n\n\t  vty_out (vty, \"%5d %7d %7d %8d %4d %4lu \",\n\t\t   peer->as,\n\t\t   peer->open_in + peer->update_in + peer->keepalive_in\n\t\t   + peer->notify_in + peer->refresh_in + peer->dynamic_cap_in,\n\t\t   peer->open_out + peer->update_out + peer->keepalive_out\n\t\t   + peer->notify_out + peer->refresh_out\n\t\t   + peer->dynamic_cap_out,\n\t\t   0, 0, (unsigned long)peer->obuf->count);\n\n\t  vty_out (vty, \"%8s\", \n\t\t   peer_uptime (peer->uptime, timebuf, BGP_UPTIME_LEN));\n\n\t  if (peer->status == Established)\n\t    {\n\t      vty_out (vty, \" %8ld\", peer->pcount[afi][safi]);\n\t    }\n\t  else\n\t    {\n\t      if (CHECK_FLAG (peer->flags, PEER_FLAG_SHUTDOWN))\n\t\tvty_out (vty, \" Idle (Admin)\");\n\t      else if (CHECK_FLAG (peer->sflags, PEER_STATUS_PREFIX_OVERFLOW))\n\t\tvty_out (vty, \" Idle (PfxCt)\");\n\t      else\n\t\tvty_out (vty, \" %-11s\", LOOKUP(bgp_status_msg, peer->status));\n\t    }\n\n\t  vty_out (vty, \"%s\", VTY_NEWLINE);\n\t}\n    }\n\n  if (count)\n    vty_out (vty, \"%sTotal number of neighbors %d%s\", VTY_NEWLINE,\n\t     count, VTY_NEWLINE);\n  else\n    vty_out (vty, \"No %s neighbor is configured%s\",\n\t     afi == AFI_IP ? \"IPv4\" : \"IPv6\", VTY_NEWLINE);\n  return CMD_SUCCESS;\n}\n\nstatic int \nbgp_show_summary_vty (struct vty *vty, const char *name, \n                      afi_t afi, safi_t safi)\n{\n  struct bgp *bgp;\n\n  if (name)\n    {\n      bgp = bgp_lookup_by_name (name);\n      \n      if (! bgp)\n\t{\n\t  vty_out (vty, \"%% No such BGP instance exist%s\", VTY_NEWLINE); \n\t  return CMD_WARNING;\n\t}\n\n      bgp_show_summary (vty, bgp, afi, safi);\n      return CMD_SUCCESS;\n    }\n  \n  bgp = bgp_get_default ();\n\n  if (bgp)\n    bgp_show_summary (vty, bgp, afi, safi);    \n \n  return CMD_SUCCESS;\n}\n\n/* `show ip bgp summary' commands. */\nDEFUN (show_ip_bgp_summary, \n       show_ip_bgp_summary_cmd,\n       \"show ip bgp summary\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"Summary of BGP neighbor status\\n\")\n{\n  return bgp_show_summary_vty (vty, NULL, AFI_IP, SAFI_UNICAST);\n}\n\nDEFUN (show_ip_bgp_instance_summary,\n       show_ip_bgp_instance_summary_cmd,\n       \"show ip bgp view WORD summary\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"View name\\n\"\n       \"Summary of BGP neighbor status\\n\")\n{\n  return bgp_show_summary_vty (vty, argv[0], AFI_IP, SAFI_UNICAST);  \n}\n\nDEFUN (show_ip_bgp_ipv4_summary, \n       show_ip_bgp_ipv4_summary_cmd,\n       \"show ip bgp ipv4 (unicast|multicast) summary\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Summary of BGP neighbor status\\n\")\n{\n  if (strncmp (argv[0], \"m\", 1) == 0)\n    return bgp_show_summary_vty (vty, NULL, AFI_IP, SAFI_MULTICAST);\n\n  return bgp_show_summary_vty (vty, NULL, AFI_IP, SAFI_UNICAST);\n}\n\nDEFUN (show_ip_bgp_instance_ipv4_summary,\n       show_ip_bgp_instance_ipv4_summary_cmd,\n       \"show ip bgp view WORD ipv4 (unicast|multicast) summary\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"View name\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Summary of BGP neighbor status\\n\")\n{\n  if (strncmp (argv[1], \"m\", 1) == 0)\n    return bgp_show_summary_vty (vty, argv[0], AFI_IP, SAFI_MULTICAST);\n  else\n    return bgp_show_summary_vty (vty, argv[0], AFI_IP, SAFI_UNICAST);\n}\n\nDEFUN (show_ip_bgp_vpnv4_all_summary,\n       show_ip_bgp_vpnv4_all_summary_cmd,\n       \"show ip bgp vpnv4 all summary\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"Display VPNv4 NLRI specific information\\n\"\n       \"Display information about all VPNv4 NLRIs\\n\"\n       \"Summary of BGP neighbor status\\n\")\n{\n  return bgp_show_summary_vty (vty, NULL, AFI_IP, SAFI_MPLS_VPN);\n}\n\nDEFUN (show_ip_bgp_vpnv4_rd_summary,\n       show_ip_bgp_vpnv4_rd_summary_cmd,\n       \"show ip bgp vpnv4 rd ASN:nn_or_IP-address:nn summary\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"Display VPNv4 NLRI specific information\\n\"\n       \"Display information for a route distinguisher\\n\"\n       \"VPN Route Distinguisher\\n\"\n       \"Summary of BGP neighbor status\\n\")\n{\n  int ret;\n  struct prefix_rd prd;\n\n  ret = str2prefix_rd (argv[0], &prd);\n  if (! ret)\n    {\n      vty_out (vty, \"%% Malformed Route Distinguisher%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  return bgp_show_summary_vty (vty, NULL, AFI_IP, SAFI_MPLS_VPN);\n}\n\n#ifdef HAVE_IPV6\nDEFUN (show_bgp_summary, \n       show_bgp_summary_cmd,\n       \"show bgp summary\",\n       SHOW_STR\n       BGP_STR\n       \"Summary of BGP neighbor status\\n\")\n{\n  return bgp_show_summary_vty (vty, NULL, AFI_IP6, SAFI_UNICAST);\n}\n\nDEFUN (show_bgp_instance_summary,\n       show_bgp_instance_summary_cmd,\n       \"show bgp view WORD summary\",\n       SHOW_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"View name\\n\"\n       \"Summary of BGP neighbor status\\n\")\n{\n  return bgp_show_summary_vty (vty, argv[0], AFI_IP6, SAFI_UNICAST);\n}\n\nALIAS (show_bgp_summary, \n       show_bgp_ipv6_summary_cmd,\n       \"show bgp ipv6 summary\",\n       SHOW_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Summary of BGP neighbor status\\n\")\n\nALIAS (show_bgp_instance_summary,\n       show_bgp_instance_ipv6_summary_cmd,\n       \"show bgp view WORD ipv6 summary\",\n       SHOW_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"View name\\n\"\n       \"Address family\\n\"\n       \"Summary of BGP neighbor status\\n\")\n\n/* old command */\nDEFUN (show_ipv6_bgp_summary, \n       show_ipv6_bgp_summary_cmd,\n       \"show ipv6 bgp summary\",\n       SHOW_STR\n       IPV6_STR\n       BGP_STR\n       \"Summary of BGP neighbor status\\n\")\n{\n  return bgp_show_summary_vty (vty, NULL, AFI_IP6, SAFI_UNICAST);\n}\n\n/* old command */\nDEFUN (show_ipv6_mbgp_summary, \n       show_ipv6_mbgp_summary_cmd,\n       \"show ipv6 mbgp summary\",\n       SHOW_STR\n       IPV6_STR\n       MBGP_STR\n       \"Summary of BGP neighbor status\\n\")\n{\n  return bgp_show_summary_vty (vty, NULL, AFI_IP6, SAFI_MULTICAST);\n}\n#endif /* HAVE_IPV6 */\n\f\nconst char *\nafi_safi_print (afi_t afi, safi_t safi)\n{\n  if (afi == AFI_IP && safi == SAFI_UNICAST)\n    return \"IPv4 Unicast\";\n  else if (afi == AFI_IP && safi == SAFI_MULTICAST)\n    return \"IPv4 Multicast\";\n  else if (afi == AFI_IP && safi == SAFI_MPLS_VPN)\n    return \"VPNv4 Unicast\";\n  else if (afi == AFI_IP6 && safi == SAFI_UNICAST)\n    return \"IPv6 Unicast\";\n  else if (afi == AFI_IP6 && safi == SAFI_MULTICAST)\n    return \"IPv6 Multicast\";\n  else\n    return \"Unknown\";\n}\n\n/* Show BGP peer's information. */\nenum show_type\n{\n  show_all,\n  show_peer\n};\n\nstatic void\nbgp_show_peer_afi_orf_cap (struct vty *vty, struct peer *p,\n\t\t\t   afi_t afi, safi_t safi,\n\t\t\t   u_int16_t adv_smcap, u_int16_t adv_rmcap,\n\t\t\t   u_int16_t rcv_smcap, u_int16_t rcv_rmcap)\n{\n  /* Send-Mode */\n  if (CHECK_FLAG (p->af_cap[afi][safi], adv_smcap)\n      || CHECK_FLAG (p->af_cap[afi][safi], rcv_smcap))\n    {\n      vty_out (vty, \"      Send-mode: \");\n      if (CHECK_FLAG (p->af_cap[afi][safi], adv_smcap))\n\tvty_out (vty, \"advertised\");\n      if (CHECK_FLAG (p->af_cap[afi][safi], rcv_smcap))\n\tvty_out (vty, \"%sreceived\",\n\t\t CHECK_FLAG (p->af_cap[afi][safi], adv_smcap) ?\n\t\t \", \" : \"\");\n      vty_out (vty, \"%s\", VTY_NEWLINE);\n    }\n\n  /* Receive-Mode */\n  if (CHECK_FLAG (p->af_cap[afi][safi], adv_rmcap)\n      || CHECK_FLAG (p->af_cap[afi][safi], rcv_rmcap))\n    {\n      vty_out (vty, \"      Receive-mode: \");\n      if (CHECK_FLAG (p->af_cap[afi][safi], adv_rmcap))\n\tvty_out (vty, \"advertised\");\n      if (CHECK_FLAG (p->af_cap[afi][safi], rcv_rmcap))\n\tvty_out (vty, \"%sreceived\",\n\t\t CHECK_FLAG (p->af_cap[afi][safi], adv_rmcap) ?\n\t\t \", \" : \"\");\n      vty_out (vty, \"%s\", VTY_NEWLINE);\n    }\n}\n\nstatic void\nbgp_show_peer_afi (struct vty *vty, struct peer *p, afi_t afi, safi_t safi)\n{\n  struct bgp_filter *filter;\n  char orf_pfx_name[BUFSIZ];\n  int orf_pfx_count;\n\n  filter = &p->filter[afi][safi];\n\n  vty_out (vty, \" For address family: %s%s\", afi_safi_print (afi, safi),\n\t   VTY_NEWLINE);\n\n  if (p->af_group[afi][safi])\n    vty_out (vty, \"  %s peer-group member%s\", p->group->name, VTY_NEWLINE);\n\n  if (CHECK_FLAG (p->af_cap[afi][safi], PEER_CAP_ORF_PREFIX_SM_ADV)\n      || CHECK_FLAG (p->af_cap[afi][safi], PEER_CAP_ORF_PREFIX_SM_RCV)\n      || CHECK_FLAG (p->af_cap[afi][safi], PEER_CAP_ORF_PREFIX_SM_OLD_RCV)\n      || CHECK_FLAG (p->af_cap[afi][safi], PEER_CAP_ORF_PREFIX_RM_ADV)\n      || CHECK_FLAG (p->af_cap[afi][safi], PEER_CAP_ORF_PREFIX_RM_RCV)\n      || CHECK_FLAG (p->af_cap[afi][safi], PEER_CAP_ORF_PREFIX_RM_OLD_RCV))\n    vty_out (vty, \"  AF-dependant capabilities:%s\", VTY_NEWLINE);\n\n  if (CHECK_FLAG (p->af_cap[afi][safi], PEER_CAP_ORF_PREFIX_SM_ADV)\n      || CHECK_FLAG (p->af_cap[afi][safi], PEER_CAP_ORF_PREFIX_SM_RCV)\n      || CHECK_FLAG (p->af_cap[afi][safi], PEER_CAP_ORF_PREFIX_RM_ADV)\n      || CHECK_FLAG (p->af_cap[afi][safi], PEER_CAP_ORF_PREFIX_RM_RCV))\n    {\n      vty_out (vty, \"    Outbound Route Filter (ORF) type (%d) Prefix-list:%s\",\n\t       ORF_TYPE_PREFIX, VTY_NEWLINE);\n      bgp_show_peer_afi_orf_cap (vty, p, afi, safi,\n\t\t\t\t PEER_CAP_ORF_PREFIX_SM_ADV,\n\t\t\t\t PEER_CAP_ORF_PREFIX_RM_ADV,\n\t\t\t\t PEER_CAP_ORF_PREFIX_SM_RCV,\n\t\t\t\t PEER_CAP_ORF_PREFIX_RM_RCV);\n    }\n  if (CHECK_FLAG (p->af_cap[afi][safi], PEER_CAP_ORF_PREFIX_SM_ADV)\n      || CHECK_FLAG (p->af_cap[afi][safi], PEER_CAP_ORF_PREFIX_SM_OLD_RCV)\n      || CHECK_FLAG (p->af_cap[afi][safi], PEER_CAP_ORF_PREFIX_RM_ADV)\n      || CHECK_FLAG (p->af_cap[afi][safi], PEER_CAP_ORF_PREFIX_RM_OLD_RCV))\n    {\n      vty_out (vty, \"    Outbound Route Filter (ORF) type (%d) Prefix-list:%s\",\n\t       ORF_TYPE_PREFIX_OLD, VTY_NEWLINE);\n      bgp_show_peer_afi_orf_cap (vty, p, afi, safi,\n\t\t\t\t PEER_CAP_ORF_PREFIX_SM_ADV,\n\t\t\t\t PEER_CAP_ORF_PREFIX_RM_ADV,\n\t\t\t\t PEER_CAP_ORF_PREFIX_SM_OLD_RCV,\n\t\t\t\t PEER_CAP_ORF_PREFIX_RM_OLD_RCV);\n    }\n\n  sprintf (orf_pfx_name, \"%s.%d.%d\", p->host, afi, safi);\n  orf_pfx_count =  prefix_bgp_show_prefix_list (NULL, afi, orf_pfx_name);\n\n  if (CHECK_FLAG (p->af_sflags[afi][safi], PEER_STATUS_ORF_PREFIX_SEND)\n      || orf_pfx_count)\n    {\n      vty_out (vty, \"  Outbound Route Filter (ORF):\");\n      if (CHECK_FLAG (p->af_sflags[afi][safi], PEER_STATUS_ORF_PREFIX_SEND))\n\t  vty_out (vty, \" sent;\");\n      if (orf_pfx_count)\n\tvty_out (vty, \" received (%d entries)\", orf_pfx_count);\n      vty_out (vty, \"%s\", VTY_NEWLINE);\n    }\n  if (CHECK_FLAG (p->af_sflags[afi][safi], PEER_STATUS_ORF_WAIT_REFRESH))\n      vty_out (vty, \"  First update is deferred until ORF or ROUTE-REFRESH is received%s\", VTY_NEWLINE);\n\n  if (CHECK_FLAG (p->af_flags[afi][safi], PEER_FLAG_REFLECTOR_CLIENT))\n    vty_out (vty, \"  Route-Reflector Client%s\", VTY_NEWLINE);\n  if (CHECK_FLAG (p->af_flags[afi][safi], PEER_FLAG_RSERVER_CLIENT))\n    vty_out (vty, \"  Route-Server Client%s\", VTY_NEWLINE);\n  if (CHECK_FLAG (p->af_flags[afi][safi], PEER_FLAG_SOFT_RECONFIG))\n    vty_out (vty, \"  Inbound soft reconfiguration allowed%s\", VTY_NEWLINE);\n  if (CHECK_FLAG (p->af_flags[afi][safi], PEER_FLAG_REMOVE_PRIVATE_AS))\n    vty_out (vty, \"  Private AS number removed from updates to this neighbor%s\", VTY_NEWLINE);\n  if (CHECK_FLAG (p->af_flags[afi][safi], PEER_FLAG_NEXTHOP_SELF))\n    vty_out (vty, \"  NEXT_HOP is always this router%s\", VTY_NEWLINE);\n  if (CHECK_FLAG (p->af_flags[afi][safi], PEER_FLAG_AS_PATH_UNCHANGED))\n    vty_out (vty, \"  AS_PATH is propagated unchanged to this neighbor%s\", VTY_NEWLINE);\n  if (CHECK_FLAG (p->af_flags[afi][safi], PEER_FLAG_NEXTHOP_UNCHANGED))\n    vty_out (vty, \"  NEXT_HOP is propagated unchanged to this neighbor%s\", VTY_NEWLINE);\n  if (CHECK_FLAG (p->af_flags[afi][safi], PEER_FLAG_MED_UNCHANGED))\n    vty_out (vty, \"  MED is propagated unchanged to this neighbor%s\", VTY_NEWLINE);\n  if (CHECK_FLAG (p->af_flags[afi][safi], PEER_FLAG_SEND_COMMUNITY)\n      || CHECK_FLAG (p->af_flags[afi][safi], PEER_FLAG_SEND_EXT_COMMUNITY))\n    {\n      vty_out (vty, \"  Community attribute sent to this neighbor\");\n      if (CHECK_FLAG (p->af_flags[afi][safi], PEER_FLAG_SEND_COMMUNITY)\n\t&& CHECK_FLAG (p->af_flags[afi][safi], PEER_FLAG_SEND_EXT_COMMUNITY))\n\tvty_out (vty, \"(both)%s\", VTY_NEWLINE);\n      else if (CHECK_FLAG (p->af_flags[afi][safi], PEER_FLAG_SEND_EXT_COMMUNITY))\n\tvty_out (vty, \"(extended)%s\", VTY_NEWLINE);\n      else \n\tvty_out (vty, \"(standard)%s\", VTY_NEWLINE);\n    }\n  if (CHECK_FLAG (p->af_flags[afi][safi], PEER_FLAG_DEFAULT_ORIGINATE))\n    {\n      vty_out (vty, \"  Default information originate,\");\n\n      if (p->default_rmap[afi][safi].name)\n\tvty_out (vty, \" default route-map %s%s,\",\n\t\t p->default_rmap[afi][safi].map ? \"*\" : \"\",\n\t\t p->default_rmap[afi][safi].name);\n      if (CHECK_FLAG (p->af_sflags[afi][safi], PEER_STATUS_DEFAULT_ORIGINATE))\n\tvty_out (vty, \" default sent%s\", VTY_NEWLINE);\n      else\n\tvty_out (vty, \" default not sent%s\", VTY_NEWLINE);\n    }\n\n  if (filter->plist[FILTER_IN].name\n      || filter->dlist[FILTER_IN].name\n      || filter->aslist[FILTER_IN].name\n      || filter->map[RMAP_IN].name)\n    vty_out (vty, \"  Inbound path policy configured%s\", VTY_NEWLINE);\n  if (filter->plist[FILTER_OUT].name\n      || filter->dlist[FILTER_OUT].name\n      || filter->aslist[FILTER_OUT].name\n      || filter->map[RMAP_OUT].name\n      || filter->usmap.name)\n    vty_out (vty, \"  Outbound path policy configured%s\", VTY_NEWLINE);\n  if (filter->map[RMAP_IMPORT].name)\n    vty_out (vty, \"  Import policy for this RS-client configured%s\", VTY_NEWLINE);\n  if (filter->map[RMAP_EXPORT].name)\n    vty_out (vty, \"  Export policy for this RS-client configured%s\", VTY_NEWLINE);\n\n  /* prefix-list */\n  if (filter->plist[FILTER_IN].name)\n    vty_out (vty, \"  Incoming update prefix filter list is %s%s%s\",\n\t     filter->plist[FILTER_IN].plist ? \"*\" : \"\",\n\t     filter->plist[FILTER_IN].name,\n\t     VTY_NEWLINE);\n  if (filter->plist[FILTER_OUT].name)\n    vty_out (vty, \"  Outgoing update prefix filter list is %s%s%s\",\n\t     filter->plist[FILTER_OUT].plist ? \"*\" : \"\",\n\t     filter->plist[FILTER_OUT].name,\n\t     VTY_NEWLINE);\n\n  /* distribute-list */\n  if (filter->dlist[FILTER_IN].name)\n    vty_out (vty, \"  Incoming update network filter list is %s%s%s\",\n\t     filter->dlist[FILTER_IN].alist ? \"*\" : \"\",\n\t     filter->dlist[FILTER_IN].name,\n\t     VTY_NEWLINE);\n  if (filter->dlist[FILTER_OUT].name)\n    vty_out (vty, \"  Outgoing update network filter list is %s%s%s\",\n\t     filter->dlist[FILTER_OUT].alist ? \"*\" : \"\",\n\t     filter->dlist[FILTER_OUT].name,\n\t     VTY_NEWLINE);\n\n  /* filter-list. */\n  if (filter->aslist[FILTER_IN].name)\n    vty_out (vty, \"  Incoming update AS path filter list is %s%s%s\",\n\t     filter->aslist[FILTER_IN].aslist ? \"*\" : \"\",\n\t     filter->aslist[FILTER_IN].name,\n\t     VTY_NEWLINE);\n  if (filter->aslist[FILTER_OUT].name)\n    vty_out (vty, \"  Outgoing update AS path filter list is %s%s%s\",\n\t     filter->aslist[FILTER_OUT].aslist ? \"*\" : \"\",\n\t     filter->aslist[FILTER_OUT].name,\n\t     VTY_NEWLINE);\n\n  /* route-map. */\n  if (filter->map[RMAP_IN].name)\n    vty_out (vty, \"  Route map for incoming advertisements is %s%s%s\",\n            filter->map[RMAP_IN].map ? \"*\" : \"\",\n            filter->map[RMAP_IN].name,\n\t     VTY_NEWLINE);\n  if (filter->map[RMAP_OUT].name)\n    vty_out (vty, \"  Route map for outgoing advertisements is %s%s%s\",\n            filter->map[RMAP_OUT].map ? \"*\" : \"\",\n            filter->map[RMAP_OUT].name,\n            VTY_NEWLINE);\n  if (filter->map[RMAP_IMPORT].name)\n    vty_out (vty, \"  Route map for advertisements going into this RS-client's table is %s%s%s\",\n            filter->map[RMAP_IMPORT].map ? \"*\" : \"\",\n            filter->map[RMAP_IMPORT].name,\n            VTY_NEWLINE);\n  if (filter->map[RMAP_EXPORT].name)\n    vty_out (vty, \"  Route map for advertisements coming from this RS-client is %s%s%s\",\n            filter->map[RMAP_EXPORT].map ? \"*\" : \"\",\n            filter->map[RMAP_EXPORT].name,\n\t     VTY_NEWLINE);\n\n  /* unsuppress-map */\n  if (filter->usmap.name)\n    vty_out (vty, \"  Route map for selective unsuppress is %s%s%s\",\n\t     filter->usmap.map ? \"*\" : \"\",\n\t     filter->usmap.name, VTY_NEWLINE);\n\n  /* Receive prefix count */\n  vty_out (vty, \"  %ld accepted prefixes%s\", p->pcount[afi][safi], VTY_NEWLINE);\n\n  /* Maximum prefix */\n  if (CHECK_FLAG (p->af_flags[afi][safi], PEER_FLAG_MAX_PREFIX))\n    {\n      vty_out (vty, \"  Maximum prefixes allowed %ld%s%s\", p->pmax[afi][safi],\n\t       CHECK_FLAG (p->af_flags[afi][safi], PEER_FLAG_MAX_PREFIX_WARNING)\n\t       ? \" (warning-only)\" : \"\", VTY_NEWLINE);\n      vty_out (vty, \"  Threshold for warning message %d%%\",\n\t       p->pmax_threshold[afi][safi]);\n      if (p->pmax_restart[afi][safi])\n\tvty_out (vty, \", restart interval %d min\", p->pmax_restart[afi][safi]);\n      vty_out (vty, \"%s\", VTY_NEWLINE);\n    }\n\n  vty_out (vty, \"%s\", VTY_NEWLINE);\n}\n\nstatic void\nbgp_show_peer (struct vty *vty, struct peer *p)\n{\n  struct bgp *bgp;\n  char buf1[BUFSIZ];\n  char timebuf[BGP_UPTIME_LEN];\n  afi_t afi;\n  safi_t safi;\n\n  bgp = p->bgp;\n\n  /* Configured IP address. */\n  vty_out (vty, \"BGP neighbor is %s, \", p->host);\n  vty_out (vty, \"remote AS %d, \", p->as);\n  vty_out (vty, \"local AS %d%s, \",\n\t   p->change_local_as ? p->change_local_as : p->local_as,\n\t   CHECK_FLAG (p->flags, PEER_FLAG_LOCAL_AS_NO_PREPEND) ?\n\t   \" no-prepend\" : \"\");\n  vty_out (vty, \"%s link%s\",\n\t   p->as == p->local_as ? \"internal\" : \"external\",\n\t   VTY_NEWLINE);\n\n  /* Description. */\n  if (p->desc)\n    vty_out (vty, \" Description: %s%s\", p->desc, VTY_NEWLINE);\n  \n  /* Peer-group */\n  if (p->group)\n    vty_out (vty, \" Member of peer-group %s for session parameters%s\",\n\t     p->group->name, VTY_NEWLINE);\n\n  /* Administrative shutdown. */\n  if (CHECK_FLAG (p->flags, PEER_FLAG_SHUTDOWN))\n    vty_out (vty, \" Administratively shut down%s\", VTY_NEWLINE);\n\n  /* BGP Version. */\n  vty_out (vty, \"  BGP version 4\");\n  vty_out (vty, \", remote router ID %s%s\", \n\t   inet_ntop (AF_INET, &p->remote_id, buf1, BUFSIZ),\n\t   VTY_NEWLINE);\n\n  /* Confederation */\n  if (CHECK_FLAG (bgp->config, BGP_CONFIG_CONFEDERATION)\n      && bgp_confederation_peers_check (bgp, p->as))\n    vty_out (vty, \"  Neighbor under common administration%s\", VTY_NEWLINE);\n  \n  /* Status. */\n  vty_out (vty, \"  BGP state = %s\",  \n\t   LOOKUP (bgp_status_msg, p->status));\n  if (p->status == Established) \n    vty_out (vty, \", up for %8s\", \n\t     peer_uptime (p->uptime, timebuf, BGP_UPTIME_LEN));\n  else if (p->status == Active)\n    {\n      if (CHECK_FLAG (p->flags, PEER_FLAG_PASSIVE))\n\tvty_out (vty, \" (passive)\"); \n      else if (CHECK_FLAG (p->sflags, PEER_STATUS_NSF_WAIT))\n\tvty_out (vty, \" (NSF passive)\"); \n    }\n  vty_out (vty, \"%s\", VTY_NEWLINE);\n  \n  /* read timer */\n  vty_out (vty, \"  Last read %s\", peer_uptime (p->readtime, timebuf, BGP_UPTIME_LEN));\n\n  /* Configured timer values. */\n  vty_out (vty, \", hold time is %d, keepalive interval is %d seconds%s\",\n\t   p->v_holdtime, p->v_keepalive, VTY_NEWLINE);\n  if (CHECK_FLAG (p->config, PEER_CONFIG_TIMER))\n    {\n      vty_out (vty, \"  Configured hold time is %d\", p->holdtime);\n      vty_out (vty, \", keepalive interval is %d seconds%s\",\n\t       p->keepalive, VTY_NEWLINE);\n    }\n\n  /* Capability. */\n  if (p->status == Established) \n    {\n      if (p->cap\n\t  || p->afc_adv[AFI_IP][SAFI_UNICAST]\n\t  || p->afc_recv[AFI_IP][SAFI_UNICAST]\n\t  || p->afc_adv[AFI_IP][SAFI_MULTICAST]\n\t  || p->afc_recv[AFI_IP][SAFI_MULTICAST]\n#ifdef HAVE_IPV6\n\t  || p->afc_adv[AFI_IP6][SAFI_UNICAST]\n\t  || p->afc_recv[AFI_IP6][SAFI_UNICAST]\n\t  || p->afc_adv[AFI_IP6][SAFI_MULTICAST]\n\t  || p->afc_recv[AFI_IP6][SAFI_MULTICAST]\n#endif /* HAVE_IPV6 */\n\t  || p->afc_adv[AFI_IP][SAFI_MPLS_VPN]\n\t  || p->afc_recv[AFI_IP][SAFI_MPLS_VPN])\n\t{\n\t  vty_out (vty, \"  Neighbor capabilities:%s\", VTY_NEWLINE);\n\n\t  /* Dynamic */\n\t  if (CHECK_FLAG (p->cap, PEER_CAP_DYNAMIC_RCV)\n\t      || CHECK_FLAG (p->cap, PEER_CAP_DYNAMIC_ADV))\n\t    {\n\t      vty_out (vty, \"    Dynamic:\");\n\t      if (CHECK_FLAG (p->cap, PEER_CAP_DYNAMIC_ADV))\n\t\tvty_out (vty, \" advertised\");\n\t      if (CHECK_FLAG (p->cap, PEER_CAP_DYNAMIC_RCV))\n\t\tvty_out (vty, \" %sreceived\",\n\t\t\t CHECK_FLAG (p->cap, PEER_CAP_DYNAMIC_ADV) ? \"and \" : \"\");\n\t      vty_out (vty, \"%s\", VTY_NEWLINE);\n\t    }\n\n\t  /* Route Refresh */\n\t  if (CHECK_FLAG (p->cap, PEER_CAP_REFRESH_ADV)\n\t      || CHECK_FLAG (p->cap, PEER_CAP_REFRESH_NEW_RCV)\n\t      || CHECK_FLAG (p->cap, PEER_CAP_REFRESH_OLD_RCV))\n\t    {\n\t      vty_out (vty, \"    Route refresh:\");\n \t      if (CHECK_FLAG (p->cap, PEER_CAP_REFRESH_ADV))\n\t\tvty_out (vty, \" advertised\");\n\t      if (CHECK_FLAG (p->cap, PEER_CAP_REFRESH_NEW_RCV)\n\t\t  || CHECK_FLAG (p->cap, PEER_CAP_REFRESH_OLD_RCV))\n\t\tvty_out (vty, \" %sreceived(%s)\",\n\t\t\t CHECK_FLAG (p->cap, PEER_CAP_REFRESH_ADV) ? \"and \" : \"\",\n\t\t\t (CHECK_FLAG (p->cap, PEER_CAP_REFRESH_OLD_RCV)\n\t\t\t  && CHECK_FLAG (p->cap, PEER_CAP_REFRESH_NEW_RCV)) ?\n\t\t\t \"old & new\" : CHECK_FLAG (p->cap, PEER_CAP_REFRESH_OLD_RCV) ? \"old\" : \"new\");\n\n\t      vty_out (vty, \"%s\", VTY_NEWLINE);\n\t    }\n\n\t  /* Multiprotocol Extensions */\n\t  for (afi = AFI_IP ; afi < AFI_MAX ; afi++)\n\t    for (safi = SAFI_UNICAST ; safi < SAFI_MAX ; safi++)\n\t      if (p->afc_adv[afi][safi] || p->afc_recv[afi][safi])\n\t\t{\n\t\t  vty_out (vty, \"    Address family %s:\", afi_safi_print (afi, safi));\n\t\t  if (p->afc_adv[afi][safi]) \n\t\t    vty_out (vty, \" advertised\");\n\t\t  if (p->afc_recv[afi][safi])\n\t\t    vty_out (vty, \" %sreceived\", p->afc_adv[afi][safi] ? \"and \" : \"\");\n\t\t  vty_out (vty, \"%s\", VTY_NEWLINE);\n\t\t} \n\n\t  /* Gracefull Restart */\n\t  if (CHECK_FLAG (p->cap, PEER_CAP_RESTART_RCV)\n\t      || CHECK_FLAG (p->cap, PEER_CAP_RESTART_ADV))\n\t    {\n\t      vty_out (vty, \"    Graceful Restart Capabilty:\");\n\t      if (CHECK_FLAG (p->cap, PEER_CAP_RESTART_ADV))\n\t\tvty_out (vty, \" advertised\");\n\t      if (CHECK_FLAG (p->cap, PEER_CAP_RESTART_RCV))\n\t\tvty_out (vty, \" %sreceived\",\n\t\t\t CHECK_FLAG (p->cap, PEER_CAP_RESTART_ADV) ? \"and \" : \"\");\n\t      vty_out (vty, \"%s\", VTY_NEWLINE);\n\n\t      if (CHECK_FLAG (p->cap, PEER_CAP_RESTART_RCV))\n\t\t{\n\t\t  int restart_af_count = 0;\n\n\t\t  vty_out (vty, \"      Remote Restart timer is %d seconds%s\",\n\t\t\t   p->v_gr_restart, VTY_NEWLINE);\t\n\t\t  vty_out (vty, \"      Address families by peer:%s        \", VTY_NEWLINE);\n\n\t\t  for (afi = AFI_IP ; afi < AFI_MAX ; afi++)\n\t\t    for (safi = SAFI_UNICAST ; safi < SAFI_MAX ; safi++)\n\t\t      if (CHECK_FLAG (p->af_cap[afi][safi], PEER_CAP_RESTART_AF_RCV))\n\t\t\t{\n\t\t\t  vty_out (vty, \"%s%s(%s)\", restart_af_count ? \", \" : \"\",\n\t\t\t\t   afi_safi_print (afi, safi),\n\t\t\t\t   CHECK_FLAG (p->af_cap[afi][safi], PEER_CAP_RESTART_AF_PRESERVE_RCV) ?\n\t\t\t\t   \"preserved\" : \"not preserved\");\n\t\t\t  restart_af_count++;\n\t\t\t}\n\t\t  if (! restart_af_count)\n\t\t    vty_out (vty, \"none\");\n\t\t  vty_out (vty, \"%s\", VTY_NEWLINE);\n\t\t}\n\t    }\n\t}\n    }\n\n  /* graceful restart information */\n  if (CHECK_FLAG (p->cap, PEER_CAP_RESTART_RCV)\n      || p->t_gr_restart\n      || p->t_gr_stale)\n    {\n      int eor_send_af_count = 0;\n      int eor_receive_af_count = 0;\n\n      vty_out (vty, \"  Graceful restart informations:%s\", VTY_NEWLINE);\n      if (p->status == Established) \n\t{\n\t  vty_out (vty, \"    End-of-RIB send: \");\n\t  for (afi = AFI_IP ; afi < AFI_MAX ; afi++)\n\t    for (safi = SAFI_UNICAST ; safi < SAFI_MAX ; safi++)\n\t      if (CHECK_FLAG (p->af_sflags[afi][safi], PEER_STATUS_EOR_SEND))\n\t\t{\n\t\t  vty_out (vty, \"%s%s\", eor_send_af_count ? \", \" : \"\",\n\t\t\t   afi_safi_print (afi, safi));\n\t\t  eor_send_af_count++;\n\t\t}\n\t  vty_out (vty, \"%s\", VTY_NEWLINE);\n\n\t  vty_out (vty, \"    End-of-RIB received: \");\n\t  for (afi = AFI_IP ; afi < AFI_MAX ; afi++)\n\t    for (safi = SAFI_UNICAST ; safi < SAFI_MAX ; safi++)\n\t      if (CHECK_FLAG (p->af_sflags[afi][safi], PEER_STATUS_EOR_RECEIVED))\n\t\t{\n\t\t  vty_out (vty, \"%s%s\", eor_receive_af_count ? \", \" : \"\",\n\t\t\t   afi_safi_print (afi, safi));\n\t\t  eor_receive_af_count++;\n\t\t}\n\t  vty_out (vty, \"%s\", VTY_NEWLINE);\n\t}\n\n      if (p->t_gr_restart)\n        {\n\t  vty_out (vty, \"    The remaining time of restart timer is %ld%s\",\n\t\t   thread_timer_remain_second (p->t_gr_restart), VTY_NEWLINE);\n\t}\n      if (p->t_gr_stale)\n\t{\n\t  vty_out (vty, \"    The remaining time of stalepath timer is %ld%s\",\n\t\t   thread_timer_remain_second (p->t_gr_stale), VTY_NEWLINE);\n\t}\n    }\n\n  /* Packet counts. */\n  vty_out (vty, \"  Message statistics:%s\", VTY_NEWLINE);\n  vty_out (vty, \"    Inq depth is 0%s\", VTY_NEWLINE);\n  vty_out (vty, \"    Outq depth is %lu%s\", (unsigned long)p->obuf->count, VTY_NEWLINE);\n  vty_out (vty, \"                         Sent       Rcvd%s\", VTY_NEWLINE);\n  vty_out (vty, \"    Opens:         %10d %10d%s\", p->open_out, p->open_in, VTY_NEWLINE);\n  vty_out (vty, \"    Notifications: %10d %10d%s\", p->notify_out, p->notify_in, VTY_NEWLINE);\n  vty_out (vty, \"    Updates:       %10d %10d%s\", p->update_out, p->update_in, VTY_NEWLINE);\n  vty_out (vty, \"    Keepalives:    %10d %10d%s\", p->keepalive_out, p->keepalive_in, VTY_NEWLINE);\n  vty_out (vty, \"    Route Refresh: %10d %10d%s\", p->refresh_out, p->refresh_in, VTY_NEWLINE);\n  vty_out (vty, \"    Capability:    %10d %10d%s\", p->dynamic_cap_out, p->dynamic_cap_in, VTY_NEWLINE);\n  vty_out (vty, \"    Total:         %10d %10d%s\", p->open_out + p->notify_out +\n\t   p->update_out + p->keepalive_out + p->refresh_out + p->dynamic_cap_out,\n\t   p->open_in + p->notify_in + p->update_in + p->keepalive_in + p->refresh_in +\n\t   p->dynamic_cap_in, VTY_NEWLINE);\n\n  /* advertisement-interval */\n  vty_out (vty, \"  Minimum time between advertisement runs is %d seconds%s\",\n\t   p->v_routeadv, VTY_NEWLINE);\n\n  /* Update-source. */\n  if (p->update_if || p->update_source)\n    {\n      vty_out (vty, \"  Update source is \");\n      if (p->update_if)\n\tvty_out (vty, \"%s\", p->update_if);\n      else if (p->update_source)\n\tvty_out (vty, \"%s\",\n\t\t sockunion2str (p->update_source, buf1, SU_ADDRSTRLEN));\n      vty_out (vty, \"%s\", VTY_NEWLINE);\n    }\n\n  /* Default weight */\n  if (CHECK_FLAG (p->config, PEER_CONFIG_WEIGHT))\n    vty_out (vty, \"  Default weight %d%s\", p->weight,\n\t     VTY_NEWLINE);\n\n  vty_out (vty, \"%s\", VTY_NEWLINE);\n\n  /* Address Family Information */\n  for (afi = AFI_IP ; afi < AFI_MAX ; afi++)\n    for (safi = SAFI_UNICAST ; safi < SAFI_MAX ; safi++)\n      if (p->afc[afi][safi])\n\tbgp_show_peer_afi (vty, p, afi, safi);\n\n  vty_out (vty, \"  Connections established %d; dropped %d%s\",\n\t   p->established, p->dropped,\n\t   VTY_NEWLINE);\n\n  if (! p->dropped)\n    vty_out (vty, \"  Last reset never%s\", VTY_NEWLINE);\n  else\n    vty_out (vty, \"  Last reset %s, due to %s%s\",\n            peer_uptime (p->resettime, timebuf, BGP_UPTIME_LEN),\n            peer_down_str[(int) p->last_reset], VTY_NEWLINE);\n\n  if (CHECK_FLAG (p->sflags, PEER_STATUS_PREFIX_OVERFLOW))\n    {\n      vty_out (vty, \"  Peer had exceeded the max. no. of prefixes configured.%s\", VTY_NEWLINE);\n\n      if (p->t_pmax_restart)\n\tvty_out (vty, \"  Reduce the no. of prefix from %s, will restart in %ld seconds%s\",\n\t\t p->host, thread_timer_remain_second (p->t_pmax_restart),\n\t\t VTY_NEWLINE);\n      else\n\tvty_out (vty, \"  Reduce the no. of prefix and clear ip bgp %s to restore peering%s\",\n\t\t p->host, VTY_NEWLINE);\n    }\n\n  /* EBGP Multihop */\n  if (peer_sort (p) != BGP_PEER_IBGP && p->ttl > 1)\n    vty_out (vty, \"  External BGP neighbor may be up to %d hops away.%s\",\n\t     p->ttl, VTY_NEWLINE);\n\n  /* Local address. */\n  if (p->su_local)\n    {\n      vty_out (vty, \"Local host: %s, Local port: %d%s\",\n\t       sockunion2str (p->su_local, buf1, SU_ADDRSTRLEN),\n\t       ntohs (p->su_local->sin.sin_port),\n\t       VTY_NEWLINE);\n    }\n      \n  /* Remote address. */\n  if (p->su_remote)\n    {\n      vty_out (vty, \"Foreign host: %s, Foreign port: %d%s\",\n\t       sockunion2str (p->su_remote, buf1, SU_ADDRSTRLEN),\n\t       ntohs (p->su_remote->sin.sin_port),\n\t       VTY_NEWLINE);\n    }\n\n  /* Nexthop display. */\n  if (p->su_local)\n    {\n      vty_out (vty, \"Nexthop: %s%s\", \n\t       inet_ntop (AF_INET, &p->nexthop.v4, buf1, BUFSIZ),\n\t       VTY_NEWLINE);\n#ifdef HAVE_IPV6\n      vty_out (vty, \"Nexthop global: %s%s\", \n\t       inet_ntop (AF_INET6, &p->nexthop.v6_global, buf1, BUFSIZ),\n\t       VTY_NEWLINE);\n      vty_out (vty, \"Nexthop local: %s%s\",\n\t       inet_ntop (AF_INET6, &p->nexthop.v6_local, buf1, BUFSIZ),\n\t       VTY_NEWLINE);\n      vty_out (vty, \"BGP connection: %s%s\",\n\t       p->shared_network ? \"shared network\" : \"non shared network\",\n\t       VTY_NEWLINE);\n#endif /* HAVE_IPV6 */\n    }\n\n  /* Timer information. */\n  if (p->t_start)\n    vty_out (vty, \"Next start timer due in %ld seconds%s\",\n\t     thread_timer_remain_second (p->t_start), VTY_NEWLINE);\n  if (p->t_connect)\n    vty_out (vty, \"Next connect timer due in %ld seconds%s\",\n\t     thread_timer_remain_second (p->t_connect), VTY_NEWLINE);\n  \n  vty_out (vty, \"Read thread: %s  Write thread: %s%s\", \n\t   p->t_read ? \"on\" : \"off\",\n\t   p->t_write ? \"on\" : \"off\",\n\t   VTY_NEWLINE);\n\n  if (p->notify.code == BGP_NOTIFY_OPEN_ERR\n      && p->notify.subcode == BGP_NOTIFY_OPEN_UNSUP_CAPBL)\n    bgp_capability_vty_out (vty, p);\n \n  vty_out (vty, \"%s\", VTY_NEWLINE);\n}\n\nstatic int\nbgp_show_neighbor (struct vty *vty, struct bgp *bgp,\n\t\t   enum show_type type, union sockunion *su)\n{\n  struct listnode *node, *nnode;\n  struct peer *peer;\n  int find = 0;\n\n  for (ALL_LIST_ELEMENTS (bgp->peer, node, nnode, peer))\n    {\n      switch (type)\n\t{\n\tcase show_all:\n\t  bgp_show_peer (vty, peer);\n\t  break;\n\tcase show_peer:\n\t  if (sockunion_same (&peer->su, su))\n\t    {\n\t      find = 1;\n\t      bgp_show_peer (vty, peer);\n\t    }\n\t  break;\n\t}\n    }\n\n  if (type == show_peer && ! find)\n    vty_out (vty, \"%% No such neighbor%s\", VTY_NEWLINE);\n  \n  return CMD_SUCCESS;\n}\n\nstatic int \nbgp_show_neighbor_vty (struct vty *vty, const char *name, \n                       enum show_type type, const char *ip_str)\n{\n  int ret;\n  struct bgp *bgp;\n  union sockunion su;\n\n  if (ip_str)\n    {\n      ret = str2sockunion (ip_str, &su);\n      if (ret < 0)\n        {\n          vty_out (vty, \"%% Malformed address: %s%s\", ip_str, VTY_NEWLINE);\n          return CMD_WARNING;\n        }\n    }\n\n  if (name)\n    {\n      bgp = bgp_lookup_by_name (name);\n      \n      if (! bgp)\n        {\n          vty_out (vty, \"%% No such BGP instance exist%s\", VTY_NEWLINE); \n          return CMD_WARNING;\n        }\n\n      bgp_show_neighbor (vty, bgp, type, &su);\n\n      return CMD_SUCCESS;\n    }\n\n  bgp = bgp_get_default ();\n\n  if (bgp)\n    bgp_show_neighbor (vty, bgp, type, &su);\n\n  return CMD_SUCCESS;\n}\n\n/* \"show ip bgp neighbors\" commands.  */\nDEFUN (show_ip_bgp_neighbors,\n       show_ip_bgp_neighbors_cmd,\n       \"show ip bgp neighbors\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"Detailed information on TCP and BGP neighbor connections\\n\")\n{\n  return bgp_show_neighbor_vty (vty, NULL, show_all, NULL);\n}\n\nALIAS (show_ip_bgp_neighbors,\n       show_ip_bgp_ipv4_neighbors_cmd,\n       \"show ip bgp ipv4 (unicast|multicast) neighbors\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Detailed information on TCP and BGP neighbor connections\\n\")\n\nALIAS (show_ip_bgp_neighbors,\n       show_ip_bgp_vpnv4_all_neighbors_cmd,\n       \"show ip bgp vpnv4 all neighbors\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"Display VPNv4 NLRI specific information\\n\"\n       \"Display information about all VPNv4 NLRIs\\n\"\n       \"Detailed information on TCP and BGP neighbor connections\\n\")\n\nALIAS (show_ip_bgp_neighbors,\n       show_ip_bgp_vpnv4_rd_neighbors_cmd,\n       \"show ip bgp vpnv4 rd ASN:nn_or_IP-address:nn neighbors\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"Display VPNv4 NLRI specific information\\n\"\n       \"Display information for a route distinguisher\\n\"\n       \"VPN Route Distinguisher\\n\"\n       \"Detailed information on TCP and BGP neighbor connections\\n\")\n\nALIAS (show_ip_bgp_neighbors,\n       show_bgp_neighbors_cmd,\n       \"show bgp neighbors\",\n       SHOW_STR\n       BGP_STR\n       \"Detailed information on TCP and BGP neighbor connections\\n\")\n\nALIAS (show_ip_bgp_neighbors,\n       show_bgp_ipv6_neighbors_cmd,\n       \"show bgp ipv6 neighbors\",\n       SHOW_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Detailed information on TCP and BGP neighbor connections\\n\")\n\nDEFUN (show_ip_bgp_neighbors_peer,\n       show_ip_bgp_neighbors_peer_cmd,\n       \"show ip bgp neighbors (A.B.C.D|X:X::X:X)\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"Detailed information on TCP and BGP neighbor connections\\n\"\n       \"Neighbor to display information about\\n\"\n       \"Neighbor to display information about\\n\")\n{\n  return bgp_show_neighbor_vty (vty, NULL, show_peer, argv[argc - 1]);\n}\n\nALIAS (show_ip_bgp_neighbors_peer,\n       show_ip_bgp_ipv4_neighbors_peer_cmd,\n       \"show ip bgp ipv4 (unicast|multicast) neighbors (A.B.C.D|X:X::X:X)\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Detailed information on TCP and BGP neighbor connections\\n\"\n       \"Neighbor to display information about\\n\"\n       \"Neighbor to display information about\\n\")\n\nALIAS (show_ip_bgp_neighbors_peer,\n       show_ip_bgp_vpnv4_all_neighbors_peer_cmd,\n       \"show ip bgp vpnv4 all neighbors A.B.C.D\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"Display VPNv4 NLRI specific information\\n\"\n       \"Display information about all VPNv4 NLRIs\\n\"\n       \"Detailed information on TCP and BGP neighbor connections\\n\"\n       \"Neighbor to display information about\\n\")\n\nALIAS (show_ip_bgp_neighbors_peer,\n       show_ip_bgp_vpnv4_rd_neighbors_peer_cmd,\n       \"show ip bgp vpnv4 rd ASN:nn_or_IP-address:nn neighbors A.B.C.D\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"Display VPNv4 NLRI specific information\\n\"\n       \"Display information about all VPNv4 NLRIs\\n\"\n       \"Detailed information on TCP and BGP neighbor connections\\n\"\n       \"Neighbor to display information about\\n\")\n\nALIAS (show_ip_bgp_neighbors_peer,\n       show_bgp_neighbors_peer_cmd,\n       \"show bgp neighbors (A.B.C.D|X:X::X:X)\",\n       SHOW_STR\n       BGP_STR\n       \"Detailed information on TCP and BGP neighbor connections\\n\"\n       \"Neighbor to display information about\\n\"\n       \"Neighbor to display information about\\n\")\n\nALIAS (show_ip_bgp_neighbors_peer,\n       show_bgp_ipv6_neighbors_peer_cmd,\n       \"show bgp ipv6 neighbors (A.B.C.D|X:X::X:X)\",\n       SHOW_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Detailed information on TCP and BGP neighbor connections\\n\"\n       \"Neighbor to display information about\\n\"\n       \"Neighbor to display information about\\n\")\n\nDEFUN (show_ip_bgp_instance_neighbors,\n       show_ip_bgp_instance_neighbors_cmd,\n       \"show ip bgp view WORD neighbors\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"View name\\n\"\n       \"Detailed information on TCP and BGP neighbor connections\\n\")\n{\n  return bgp_show_neighbor_vty (vty, argv[0], show_all, NULL);\n}\n\nALIAS (show_ip_bgp_instance_neighbors,\n       show_bgp_instance_neighbors_cmd,\n       \"show bgp view WORD neighbors\",\n       SHOW_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"View name\\n\"\n       \"Detailed information on TCP and BGP neighbor connections\\n\")\n\nALIAS (show_ip_bgp_instance_neighbors,\n       show_bgp_instance_ipv6_neighbors_cmd,\n       \"show bgp view WORD ipv6 neighbors\",\n       SHOW_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"View name\\n\"\n       \"Address family\\n\"\n       \"Detailed information on TCP and BGP neighbor connections\\n\")\n\nDEFUN (show_ip_bgp_instance_neighbors_peer,\n       show_ip_bgp_instance_neighbors_peer_cmd,\n       \"show ip bgp view WORD neighbors (A.B.C.D|X:X::X:X)\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"View name\\n\"\n       \"Detailed information on TCP and BGP neighbor connections\\n\"\n       \"Neighbor to display information about\\n\"\n       \"Neighbor to display information about\\n\")\n{\n  return bgp_show_neighbor_vty (vty, argv[0], show_peer, argv[1]);\n}\n\nALIAS (show_ip_bgp_instance_neighbors_peer,\n       show_bgp_instance_neighbors_peer_cmd,\n       \"show bgp view WORD neighbors (A.B.C.D|X:X::X:X)\",\n       SHOW_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"View name\\n\"\n       \"Detailed information on TCP and BGP neighbor connections\\n\"\n       \"Neighbor to display information about\\n\"\n       \"Neighbor to display information about\\n\")\n\nALIAS (show_ip_bgp_instance_neighbors_peer,\n       show_bgp_instance_ipv6_neighbors_peer_cmd,\n       \"show bgp view WORD ipv6 neighbors (A.B.C.D|X:X::X:X)\",\n       SHOW_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"View name\\n\"\n       \"Address family\\n\"\n       \"Detailed information on TCP and BGP neighbor connections\\n\"\n       \"Neighbor to display information about\\n\"\n       \"Neighbor to display information about\\n\")\n       \f\n/* Show BGP's AS paths internal data.  There are both `show ip bgp\n   paths' and `show ip mbgp paths'.  Those functions results are the\n   same.*/\nDEFUN (show_ip_bgp_paths, \n       show_ip_bgp_paths_cmd,\n       \"show ip bgp paths\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"Path information\\n\")\n{\n  vty_out (vty, \"Address Refcnt Path%s\", VTY_NEWLINE);\n  aspath_print_all_vty (vty);\n  return CMD_SUCCESS;\n}\n\nDEFUN (show_ip_bgp_ipv4_paths, \n       show_ip_bgp_ipv4_paths_cmd,\n       \"show ip bgp ipv4 (unicast|multicast) paths\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Path information\\n\")\n{\n  vty_out (vty, \"Address Refcnt Path\\r\\n\");\n  aspath_print_all_vty (vty);\n\n  return CMD_SUCCESS;\n}\n\f\n#include \"hash.h\"\n\nstatic void\ncommunity_show_all_iterator (struct hash_backet *backet, struct vty *vty)\n{\n  struct community *com;\n\n  com = (struct community *) backet->data;\n  vty_out (vty, \"[%p] (%ld) %s%s\", backet, com->refcnt,\n\t   community_str (com), VTY_NEWLINE);\n}\n\n/* Show BGP's community internal data. */\nDEFUN (show_ip_bgp_community_info, \n       show_ip_bgp_community_info_cmd,\n       \"show ip bgp community-info\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"List all bgp community information\\n\")\n{\n  vty_out (vty, \"Address Refcnt Community%s\", VTY_NEWLINE);\n\n  hash_iterate (community_hash (), \n\t\t(void (*) (struct hash_backet *, void *))\n\t\tcommunity_show_all_iterator,\n\t\tvty);\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (show_ip_bgp_attr_info, \n       show_ip_bgp_attr_info_cmd,\n       \"show ip bgp attribute-info\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"List all bgp attribute information\\n\")\n{\n  attr_show_all (vty);\n  return CMD_SUCCESS;\n}\n\f\nstatic int\nbgp_write_rsclient_summary (struct vty *vty, struct peer *rsclient,\n        afi_t afi, safi_t safi)\n{\n  char timebuf[BGP_UPTIME_LEN];\n  char rmbuf[14];\n  const char *rmname;\n  struct peer *peer;\n  struct listnode *node, *nnode;\n  int len;\n  int count = 0;\n\n  if (CHECK_FLAG (rsclient->sflags, PEER_STATUS_GROUP))\n    {\n      for (ALL_LIST_ELEMENTS (rsclient->group->peer, node, nnode, peer))\n        {\n          count++;\n          bgp_write_rsclient_summary (vty, peer, afi, safi);\n        }\n      return count;\n    }\n\n  len = vty_out (vty, \"%s\", rsclient->host);\n  len = 16 - len;\n\n  if (len < 1)\n    vty_out (vty, \"%s%*s\", VTY_NEWLINE, 16, \" \");\n  else\n    vty_out (vty, \"%*s\", len, \" \");\n\n  vty_out (vty, \"4 \");\n\n  vty_out (vty, \"%5d \", rsclient->as);\n\n  rmname = ROUTE_MAP_EXPORT_NAME(&rsclient->filter[afi][safi]);\n  if ( rmname && strlen (rmname) > 13 )\n    {\n      sprintf (rmbuf, \"%13s\", \"...\");\n      rmname = strncpy (rmbuf, rmname, 10);\n    }\n  else if (! rmname)\n    rmname = \"<none>\";\n  vty_out (vty, \" %13s \", rmname);\n\n  rmname = ROUTE_MAP_IMPORT_NAME(&rsclient->filter[afi][safi]);\n  if ( rmname && strlen (rmname) > 13 )\n    {\n      sprintf (rmbuf, \"%13s\", \"...\");\n      rmname = strncpy (rmbuf, rmname, 10);\n    }\n  else if (! rmname)\n    rmname = \"<none>\";\n  vty_out (vty, \" %13s \", rmname);\n\n  vty_out (vty, \"%8s\", peer_uptime (rsclient->uptime, timebuf, BGP_UPTIME_LEN));\n\n  if (CHECK_FLAG (rsclient->flags, PEER_FLAG_SHUTDOWN))\n    vty_out (vty, \" Idle (Admin)\");\n  else if (CHECK_FLAG (rsclient->sflags, PEER_STATUS_PREFIX_OVERFLOW))\n    vty_out (vty, \" Idle (PfxCt)\");\n  else\n    vty_out (vty, \" %-11s\", LOOKUP(bgp_status_msg, rsclient->status));\n\n  vty_out (vty, \"%s\", VTY_NEWLINE);\n\n  return 1;\n}\n\nstatic int\nbgp_show_rsclient_summary (struct vty *vty, struct bgp *bgp, \n                           afi_t afi, safi_t safi)\n{\n  struct peer *peer;\n  struct listnode *node, *nnode;\n  int count = 0;\n\n  /* Header string for each address family. */\n  static char header[] = \"Neighbor        V    AS  Export-Policy  Import-Policy  Up/Down  State\";\n\n  for (ALL_LIST_ELEMENTS (bgp->rsclient, node, nnode, peer))\n    {\n      if (peer->afc[afi][safi] &&\n         CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_RSERVER_CLIENT))\n       {\n         if (! count)\n           {\n             vty_out (vty,\n                      \"Route Server's BGP router identifier %s%s\",\n                      inet_ntoa (bgp->router_id), VTY_NEWLINE);\n             vty_out (vty,\n              \"Route Server's local AS number %d%s\", bgp->as,\n                       VTY_NEWLINE);\n\n             vty_out (vty, \"%s\", VTY_NEWLINE);\n             vty_out (vty, \"%s%s\", header, VTY_NEWLINE);\n           }\n\n         count += bgp_write_rsclient_summary (vty, peer, afi, safi);\n       }\n    }\n\n  if (count)\n    vty_out (vty, \"%sTotal number of Route Server Clients %d%s\", VTY_NEWLINE,\n            count, VTY_NEWLINE);\n  else\n    vty_out (vty, \"No %s Route Server Client is configured%s\",\n            afi == AFI_IP ? \"IPv4\" : \"IPv6\", VTY_NEWLINE);\n\n  return CMD_SUCCESS;\n}\n\nstatic int\nbgp_show_rsclient_summary_vty (struct vty *vty, const char *name, \n                               afi_t afi, safi_t safi)\n{\n  struct bgp *bgp;\n\n  if (name)\n    {\n      bgp = bgp_lookup_by_name (name);\n\n      if (! bgp)\n       {\n         vty_out (vty, \"%% No such BGP instance exist%s\", VTY_NEWLINE);\n         return CMD_WARNING;\n       }\n\n      bgp_show_rsclient_summary (vty, bgp, afi, safi);\n      return CMD_SUCCESS;\n    }\n\n  bgp = bgp_get_default ();\n\n  if (bgp)\n    bgp_show_rsclient_summary (vty, bgp, afi, safi);\n\n  return CMD_SUCCESS;\n}\n\n/* 'show bgp rsclient' commands. */\nDEFUN (show_ip_bgp_rsclient_summary,\n       show_ip_bgp_rsclient_summary_cmd,\n       \"show ip bgp rsclient summary\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"Information about Route Server Clients\\n\"\n       \"Summary of all Route Server Clients\\n\")\n{\n  return bgp_show_rsclient_summary_vty (vty, NULL, AFI_IP, SAFI_UNICAST);\n}\n\nDEFUN (show_ip_bgp_instance_rsclient_summary,\n       show_ip_bgp_instance_rsclient_summary_cmd,\n       \"show ip bgp view WORD rsclient summary\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"View name\\n\"\n       \"Information about Route Server Clients\\n\"\n       \"Summary of all Route Server Clients\\n\")\n{\n  return bgp_show_rsclient_summary_vty (vty, argv[0], AFI_IP, SAFI_UNICAST);\n}\n\nDEFUN (show_ip_bgp_ipv4_rsclient_summary,\n      show_ip_bgp_ipv4_rsclient_summary_cmd,\n      \"show ip bgp ipv4 (unicast|multicast) rsclient summary\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Information about Route Server Clients\\n\"\n       \"Summary of all Route Server Clients\\n\")\n{\n  if (strncmp (argv[0], \"m\", 1) == 0)\n    return bgp_show_rsclient_summary_vty (vty, NULL, AFI_IP, SAFI_MULTICAST);\n\n  return bgp_show_rsclient_summary_vty (vty, NULL, AFI_IP, SAFI_UNICAST);\n}\n\nDEFUN (show_ip_bgp_instance_ipv4_rsclient_summary,\n      show_ip_bgp_instance_ipv4_rsclient_summary_cmd,\n      \"show ip bgp view WORD ipv4 (unicast|multicast) rsclient summary\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"View name\\n\"\n       \"Address family\\n\"\n       \"Address Family modifier\\n\"\n       \"Address Family modifier\\n\"\n       \"Information about Route Server Clients\\n\"\n       \"Summary of all Route Server Clients\\n\")\n{\n  if (strncmp (argv[1], \"m\", 1) == 0)\n    return bgp_show_rsclient_summary_vty (vty, argv[0], AFI_IP, SAFI_MULTICAST);\n\n  return bgp_show_rsclient_summary_vty (vty, argv[0], AFI_IP, SAFI_UNICAST);\n}\n\n#ifdef HAVE_IPV6\nDEFUN (show_bgp_rsclient_summary,\n       show_bgp_rsclient_summary_cmd,\n       \"show bgp rsclient summary\",\n       SHOW_STR\n       BGP_STR\n       \"Information about Route Server Clients\\n\"\n       \"Summary of all Route Server Clients\\n\")\n{\n  return bgp_show_rsclient_summary_vty (vty, NULL, AFI_IP6, SAFI_UNICAST);\n}\n\nDEFUN (show_bgp_instance_rsclient_summary,\n       show_bgp_instance_rsclient_summary_cmd,\n       \"show bgp view WORD rsclient summary\",\n       SHOW_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"View name\\n\"\n       \"Information about Route Server Clients\\n\"\n       \"Summary of all Route Server Clients\\n\")\n{\n  return bgp_show_rsclient_summary_vty (vty, argv[0], AFI_IP6, SAFI_UNICAST);\n}\n\nALIAS (show_bgp_rsclient_summary,\n      show_bgp_ipv6_rsclient_summary_cmd,\n      \"show bgp ipv6 rsclient summary\",\n       SHOW_STR\n       BGP_STR\n       \"Address family\\n\"\n       \"Information about Route Server Clients\\n\"\n       \"Summary of all Route Server Clients\\n\")\n\nALIAS (show_bgp_instance_rsclient_summary,\n      show_bgp_instance_ipv6_rsclient_summary_cmd,\n       \"show bgp view WORD ipv6 rsclient summary\",\n       SHOW_STR\n       BGP_STR\n       \"BGP view\\n\"\n       \"View name\\n\"\n       \"Address family\\n\"\n       \"Information about Route Server Clients\\n\"\n       \"Summary of all Route Server Clients\\n\")\n#endif /* HAVE IPV6 */\n\f\n/* Redistribute VTY commands.  */\n\n/* Utility function to convert user input route type string to route\n   type.  */\nstatic int\nbgp_str2route_type (int afi, const char *str)\n{\n  if (! str)\n    return 0;\n\n  if (afi == AFI_IP)\n    {\n      if (strncmp (str, \"k\", 1) == 0)\n\treturn ZEBRA_ROUTE_KERNEL;\n      else if (strncmp (str, \"c\", 1) == 0)\n\treturn ZEBRA_ROUTE_CONNECT;\n      else if (strncmp (str, \"s\", 1) == 0)\n\treturn ZEBRA_ROUTE_STATIC;\n      else if (strncmp (str, \"r\", 1) == 0)\n\treturn ZEBRA_ROUTE_RIP;\n      else if (strncmp (str, \"o\", 1) == 0)\n\treturn ZEBRA_ROUTE_OSPF;\n    }\n  if (afi == AFI_IP6)\n    {\n      if (strncmp (str, \"k\", 1) == 0)\n\treturn ZEBRA_ROUTE_KERNEL;\n      else if (strncmp (str, \"c\", 1) == 0)\n\treturn ZEBRA_ROUTE_CONNECT;\n      else if (strncmp (str, \"s\", 1) == 0)\n\treturn ZEBRA_ROUTE_STATIC;\n      else if (strncmp (str, \"r\", 1) == 0)\n\treturn ZEBRA_ROUTE_RIPNG;\n      else if (strncmp (str, \"o\", 1) == 0)\n\treturn ZEBRA_ROUTE_OSPF6;\n    }\n  return 0;\n}\n\nDEFUN (bgp_redistribute_ipv4,\n       bgp_redistribute_ipv4_cmd,\n       \"redistribute (connected|kernel|ospf|rip|static)\",\n       \"Redistribute information from another routing protocol\\n\"\n       \"Connected\\n\"\n       \"Kernel routes\\n\"\n       \"Open Shurtest Path First (OSPF)\\n\"\n       \"Routing Information Protocol (RIP)\\n\"\n       \"Static routes\\n\")\n{\n  int type;\n\n  type = bgp_str2route_type (AFI_IP, argv[0]);\n  if (! type)\n    {\n      vty_out (vty, \"%% Invalid route type%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n  return bgp_redistribute_set (vty->index, AFI_IP, type);\n}\n\nDEFUN (bgp_redistribute_ipv4_rmap,\n       bgp_redistribute_ipv4_rmap_cmd,\n       \"redistribute (connected|kernel|ospf|rip|static) route-map WORD\",\n       \"Redistribute information from another routing protocol\\n\"\n       \"Connected\\n\"\n       \"Kernel routes\\n\"\n       \"Open Shurtest Path First (OSPF)\\n\"\n       \"Routing Information Protocol (RIP)\\n\"\n       \"Static routes\\n\"\n       \"Route map reference\\n\"\n       \"Pointer to route-map entries\\n\")\n{\n  int type;\n\n  type = bgp_str2route_type (AFI_IP, argv[0]);\n  if (! type)\n    {\n      vty_out (vty, \"%% Invalid route type%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  bgp_redistribute_rmap_set (vty->index, AFI_IP, type, argv[1]);\n  return bgp_redistribute_set (vty->index, AFI_IP, type);\n}\n\nDEFUN (bgp_redistribute_ipv4_metric,\n       bgp_redistribute_ipv4_metric_cmd,\n       \"redistribute (connected|kernel|ospf|rip|static) metric <0-4294967295>\",\n       \"Redistribute information from another routing protocol\\n\"\n       \"Connected\\n\"\n       \"Kernel routes\\n\"\n       \"Open Shurtest Path First (OSPF)\\n\"\n       \"Routing Information Protocol (RIP)\\n\"\n       \"Static routes\\n\"\n       \"Metric for redistributed routes\\n\"\n       \"Default metric\\n\")\n{\n  int type;\n  u_int32_t metric;\n\n  type = bgp_str2route_type (AFI_IP, argv[0]);\n  if (! type)\n    {\n      vty_out (vty, \"%% Invalid route type%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n  VTY_GET_INTEGER (\"metric\", metric, argv[1]);\n\n  bgp_redistribute_metric_set (vty->index, AFI_IP, type, metric);\n  return bgp_redistribute_set (vty->index, AFI_IP, type);\n}\n\nDEFUN (bgp_redistribute_ipv4_rmap_metric,\n       bgp_redistribute_ipv4_rmap_metric_cmd,\n       \"redistribute (connected|kernel|ospf|rip|static) route-map WORD metric <0-4294967295>\",\n       \"Redistribute information from another routing protocol\\n\"\n       \"Connected\\n\"\n       \"Kernel routes\\n\"\n       \"Open Shurtest Path First (OSPF)\\n\"\n       \"Routing Information Protocol (RIP)\\n\"\n       \"Static routes\\n\"\n       \"Route map reference\\n\"\n       \"Pointer to route-map entries\\n\"\n       \"Metric for redistributed routes\\n\"\n       \"Default metric\\n\")\n{\n  int type;\n  u_int32_t metric;\n\n  type = bgp_str2route_type (AFI_IP, argv[0]);\n  if (! type)\n    {\n      vty_out (vty, \"%% Invalid route type%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n  VTY_GET_INTEGER (\"metric\", metric, argv[2]);\n\n  bgp_redistribute_rmap_set (vty->index, AFI_IP, type, argv[1]);\n  bgp_redistribute_metric_set (vty->index, AFI_IP, type, metric);\n  return bgp_redistribute_set (vty->index, AFI_IP, type);\n}\n\nDEFUN (bgp_redistribute_ipv4_metric_rmap,\n       bgp_redistribute_ipv4_metric_rmap_cmd,\n       \"redistribute (connected|kernel|ospf|rip|static) metric <0-4294967295> route-map WORD\",\n       \"Redistribute information from another routing protocol\\n\"\n       \"Connected\\n\"\n       \"Kernel routes\\n\"\n       \"Open Shurtest Path First (OSPF)\\n\"\n       \"Routing Information Protocol (RIP)\\n\"\n       \"Static routes\\n\"\n       \"Metric for redistributed routes\\n\"\n       \"Default metric\\n\"\n       \"Route map reference\\n\"\n       \"Pointer to route-map entries\\n\")\n{\n  int type;\n  u_int32_t metric;\n\n  type = bgp_str2route_type (AFI_IP, argv[0]);\n  if (! type)\n    {\n      vty_out (vty, \"%% Invalid route type%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n  VTY_GET_INTEGER (\"metric\", metric, argv[1]);\n\n  bgp_redistribute_metric_set (vty->index, AFI_IP, type, metric);\n  bgp_redistribute_rmap_set (vty->index, AFI_IP, type, argv[2]);\n  return bgp_redistribute_set (vty->index, AFI_IP, type);\n}\n\nDEFUN (no_bgp_redistribute_ipv4,\n       no_bgp_redistribute_ipv4_cmd,\n       \"no redistribute (connected|kernel|ospf|rip|static)\",\n       NO_STR\n       \"Redistribute information from another routing protocol\\n\"\n       \"Connected\\n\"\n       \"Kernel routes\\n\"\n       \"Open Shurtest Path First (OSPF)\\n\"\n       \"Routing Information Protocol (RIP)\\n\"\n       \"Static routes\\n\")\n{\n  int type;\n\n  type = bgp_str2route_type (AFI_IP, argv[0]);\n  if (! type)\n    {\n      vty_out (vty, \"%% Invalid route type%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  return bgp_redistribute_unset (vty->index, AFI_IP, type);\n}\n\nDEFUN (no_bgp_redistribute_ipv4_rmap,\n       no_bgp_redistribute_ipv4_rmap_cmd,\n       \"no redistribute (connected|kernel|ospf|rip|static) route-map WORD\",\n       NO_STR\n       \"Redistribute information from another routing protocol\\n\"\n       \"Connected\\n\"\n       \"Kernel routes\\n\"\n       \"Open Shurtest Path First (OSPF)\\n\"\n       \"Routing Information Protocol (RIP)\\n\"\n       \"Static routes\\n\"\n       \"Route map reference\\n\"\n       \"Pointer to route-map entries\\n\")\n{\n  int type;\n\n  type = bgp_str2route_type (AFI_IP, argv[0]);\n  if (! type)\n    {\n      vty_out (vty, \"%% Invalid route type%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  bgp_redistribute_routemap_unset (vty->index, AFI_IP, type);\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_bgp_redistribute_ipv4_metric,\n       no_bgp_redistribute_ipv4_metric_cmd,\n       \"no redistribute (connected|kernel|ospf|rip|static) metric <0-4294967295>\",\n       NO_STR\n       \"Redistribute information from another routing protocol\\n\"\n       \"Connected\\n\"\n       \"Kernel routes\\n\"\n       \"Open Shurtest Path First (OSPF)\\n\"\n       \"Routing Information Protocol (RIP)\\n\"\n       \"Static routes\\n\"\n       \"Metric for redistributed routes\\n\"\n       \"Default metric\\n\")\n{\n  int type;\n\n  type = bgp_str2route_type (AFI_IP, argv[0]);\n  if (! type)\n    {\n      vty_out (vty, \"%% Invalid route type%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  bgp_redistribute_metric_unset (vty->index, AFI_IP, type);\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_bgp_redistribute_ipv4_rmap_metric,\n       no_bgp_redistribute_ipv4_rmap_metric_cmd,\n       \"no redistribute (connected|kernel|ospf|rip|static) route-map WORD metric <0-4294967295>\",\n       NO_STR\n       \"Redistribute information from another routing protocol\\n\"\n       \"Connected\\n\"\n       \"Kernel routes\\n\"\n       \"Open Shurtest Path First (OSPF)\\n\"\n       \"Routing Information Protocol (RIP)\\n\"\n       \"Static routes\\n\"\n       \"Route map reference\\n\"\n       \"Pointer to route-map entries\\n\"\n       \"Metric for redistributed routes\\n\"\n       \"Default metric\\n\")\n{\n  int type;\n\n  type = bgp_str2route_type (AFI_IP, argv[0]);\n  if (! type)\n    {\n      vty_out (vty, \"%% Invalid route type%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  bgp_redistribute_metric_unset (vty->index, AFI_IP, type);\n  bgp_redistribute_routemap_unset (vty->index, AFI_IP, type);\n  return CMD_SUCCESS;\n}\n\nALIAS (no_bgp_redistribute_ipv4_rmap_metric,\n       no_bgp_redistribute_ipv4_metric_rmap_cmd,\n       \"no redistribute (connected|kernel|ospf|rip|static) metric <0-4294967295> route-map WORD\",\n       NO_STR\n       \"Redistribute information from another routing protocol\\n\"\n       \"Connected\\n\"\n       \"Kernel routes\\n\"\n       \"Open Shurtest Path First (OSPF)\\n\"\n       \"Routing Information Protocol (RIP)\\n\"\n       \"Static routes\\n\"\n       \"Metric for redistributed routes\\n\"\n       \"Default metric\\n\"\n       \"Route map reference\\n\"\n       \"Pointer to route-map entries\\n\")\n\f\n#ifdef HAVE_IPV6\nDEFUN (bgp_redistribute_ipv6,\n       bgp_redistribute_ipv6_cmd,\n       \"redistribute (connected|kernel|ospf6|ripng|static)\",\n       \"Redistribute information from another routing protocol\\n\"\n       \"Connected\\n\"\n       \"Kernel routes\\n\"\n       \"Open Shurtest Path First (OSPFv3)\\n\"\n       \"Routing Information Protocol (RIPng)\\n\"\n       \"Static routes\\n\")\n{\n  int type;\n\n  type = bgp_str2route_type (AFI_IP6, argv[0]);\n  if (! type)\n    {\n      vty_out (vty, \"%% Invalid route type%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  return bgp_redistribute_set (vty->index, AFI_IP6, type);\n}\n\nDEFUN (bgp_redistribute_ipv6_rmap,\n       bgp_redistribute_ipv6_rmap_cmd,\n       \"redistribute (connected|kernel|ospf6|ripng|static) route-map WORD\",\n       \"Redistribute information from another routing protocol\\n\"\n       \"Connected\\n\"\n       \"Kernel routes\\n\"\n       \"Open Shurtest Path First (OSPFv3)\\n\"\n       \"Routing Information Protocol (RIPng)\\n\"\n       \"Static routes\\n\"\n       \"Route map reference\\n\"\n       \"Pointer to route-map entries\\n\")\n{\n  int type;\n\n  type = bgp_str2route_type (AFI_IP6, argv[0]);\n  if (! type)\n    {\n      vty_out (vty, \"%% Invalid route type%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  bgp_redistribute_rmap_set (vty->index, AFI_IP6, type, argv[1]);\n  return bgp_redistribute_set (vty->index, AFI_IP6, type);\n}\n\nDEFUN (bgp_redistribute_ipv6_metric,\n       bgp_redistribute_ipv6_metric_cmd,\n       \"redistribute (connected|kernel|ospf6|ripng|static) metric <0-4294967295>\",\n       \"Redistribute information from another routing protocol\\n\"\n       \"Connected\\n\"\n       \"Kernel routes\\n\"\n       \"Open Shurtest Path First (OSPFv3)\\n\"\n       \"Routing Information Protocol (RIPng)\\n\"\n       \"Static routes\\n\"\n       \"Metric for redistributed routes\\n\"\n       \"Default metric\\n\")\n{\n  int type;\n  u_int32_t metric;\n\n  type = bgp_str2route_type (AFI_IP6, argv[0]);\n  if (! type)\n    {\n      vty_out (vty, \"%% Invalid route type%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n  VTY_GET_INTEGER (\"metric\", metric, argv[1]);\n\n  bgp_redistribute_metric_set (vty->index, AFI_IP6, type, metric);\n  return bgp_redistribute_set (vty->index, AFI_IP6, type);\n}\n\nDEFUN (bgp_redistribute_ipv6_rmap_metric,\n       bgp_redistribute_ipv6_rmap_metric_cmd,\n       \"redistribute (connected|kernel|ospf6|ripng|static) route-map WORD metric <0-4294967295>\",\n       \"Redistribute information from another routing protocol\\n\"\n       \"Connected\\n\"\n       \"Kernel routes\\n\"\n       \"Open Shurtest Path First (OSPFv3)\\n\"\n       \"Routing Information Protocol (RIPng)\\n\"\n       \"Static routes\\n\"\n       \"Route map reference\\n\"\n       \"Pointer to route-map entries\\n\"\n       \"Metric for redistributed routes\\n\"\n       \"Default metric\\n\")\n{\n  int type;\n  u_int32_t metric;\n\n  type = bgp_str2route_type (AFI_IP6, argv[0]);\n  if (! type)\n    {\n      vty_out (vty, \"%% Invalid route type%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n  VTY_GET_INTEGER (\"metric\", metric, argv[2]);\n\n  bgp_redistribute_rmap_set (vty->index, AFI_IP6, type, argv[1]);\n  bgp_redistribute_metric_set (vty->index, AFI_IP6, type, metric);\n  return bgp_redistribute_set (vty->index, AFI_IP6, type);\n}\n\nDEFUN (bgp_redistribute_ipv6_metric_rmap,\n       bgp_redistribute_ipv6_metric_rmap_cmd,\n       \"redistribute (connected|kernel|ospf6|ripng|static) metric <0-4294967295> route-map WORD\",\n       \"Redistribute information from another routing protocol\\n\"\n       \"Connected\\n\"\n       \"Kernel routes\\n\"\n       \"Open Shurtest Path First (OSPFv3)\\n\"\n       \"Routing Information Protocol (RIPng)\\n\"\n       \"Static routes\\n\"\n       \"Metric for redistributed routes\\n\"\n       \"Default metric\\n\"\n       \"Route map reference\\n\"\n       \"Pointer to route-map entries\\n\")\n{\n  int type;\n  u_int32_t metric;\n\n  type = bgp_str2route_type (AFI_IP6, argv[0]);\n  if (! type)\n    {\n      vty_out (vty, \"%% Invalid route type%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n  VTY_GET_INTEGER (\"metric\", metric, argv[1]);\n\n  bgp_redistribute_metric_set (vty->index, AFI_IP6, type, metric);\n  bgp_redistribute_rmap_set (vty->index, AFI_IP6, type, argv[2]);\n  return bgp_redistribute_set (vty->index, AFI_IP6, type);\n}\n\nDEFUN (no_bgp_redistribute_ipv6,\n       no_bgp_redistribute_ipv6_cmd,\n       \"no redistribute (connected|kernel|ospf6|ripng|static)\",\n       NO_STR\n       \"Redistribute information from another routing protocol\\n\"\n       \"Connected\\n\"\n       \"Kernel routes\\n\"\n       \"Open Shurtest Path First (OSPFv3)\\n\"\n       \"Routing Information Protocol (RIPng)\\n\"\n       \"Static routes\\n\")\n{\n  int type;\n\n  type = bgp_str2route_type (AFI_IP6, argv[0]);\n  if (! type)\n    {\n      vty_out (vty, \"%% Invalid route type%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  return bgp_redistribute_unset (vty->index, AFI_IP6, type);\n}\n\nDEFUN (no_bgp_redistribute_ipv6_rmap,\n       no_bgp_redistribute_ipv6_rmap_cmd,\n       \"no redistribute (connected|kernel|ospf6|ripng|static) route-map WORD\",\n       NO_STR\n       \"Redistribute information from another routing protocol\\n\"\n       \"Connected\\n\"\n       \"Kernel routes\\n\"\n       \"Open Shurtest Path First (OSPFv3)\\n\"\n       \"Routing Information Protocol (RIPng)\\n\"\n       \"Static routes\\n\"\n       \"Route map reference\\n\"\n       \"Pointer to route-map entries\\n\")\n{\n  int type;\n\n  type = bgp_str2route_type (AFI_IP6, argv[0]);\n  if (! type)\n    {\n      vty_out (vty, \"%% Invalid route type%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  bgp_redistribute_routemap_unset (vty->index, AFI_IP6, type);\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_bgp_redistribute_ipv6_metric,\n       no_bgp_redistribute_ipv6_metric_cmd,\n       \"no redistribute (connected|kernel|ospf6|ripng|static) metric <0-4294967295>\",\n       NO_STR\n       \"Redistribute information from another routing protocol\\n\"\n       \"Connected\\n\"\n       \"Kernel routes\\n\"\n       \"Open Shurtest Path First (OSPFv3)\\n\"\n       \"Routing Information Protocol (RIPng)\\n\"\n       \"Static routes\\n\"\n       \"Metric for redistributed routes\\n\"\n       \"Default metric\\n\")\n{\n  int type;\n\n  type = bgp_str2route_type (AFI_IP6, argv[0]);\n  if (! type)\n    {\n      vty_out (vty, \"%% Invalid route type%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  bgp_redistribute_metric_unset (vty->index, AFI_IP6, type);\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_bgp_redistribute_ipv6_rmap_metric,\n       no_bgp_redistribute_ipv6_rmap_metric_cmd,\n       \"no redistribute (connected|kernel|ospf6|ripng|static) route-map WORD metric <0-4294967295>\",\n       NO_STR\n       \"Redistribute information from another routing protocol\\n\"\n       \"Connected\\n\"\n       \"Kernel routes\\n\"\n       \"Open Shurtest Path First (OSPFv3)\\n\"\n       \"Routing Information Protocol (RIPng)\\n\"\n       \"Static routes\\n\"\n       \"Route map reference\\n\"\n       \"Pointer to route-map entries\\n\"\n       \"Metric for redistributed routes\\n\"\n       \"Default metric\\n\")\n{\n  int type;\n\n  type = bgp_str2route_type (AFI_IP6, argv[0]);\n  if (! type)\n    {\n      vty_out (vty, \"%% Invalid route type%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  bgp_redistribute_metric_unset (vty->index, AFI_IP6, type);\n  bgp_redistribute_routemap_unset (vty->index, AFI_IP6, type);\n  return CMD_SUCCESS;\n}\n\nALIAS (no_bgp_redistribute_ipv6_rmap_metric,\n       no_bgp_redistribute_ipv6_metric_rmap_cmd,\n       \"no redistribute (connected|kernel|ospf6|ripng|static) metric <0-4294967295> route-map WORD\",\n       NO_STR\n       \"Redistribute information from another routing protocol\\n\"\n       \"Connected\\n\"\n       \"Kernel routes\\n\"\n       \"Open Shurtest Path First (OSPFv3)\\n\"\n       \"Routing Information Protocol (RIPng)\\n\"\n       \"Static routes\\n\"\n       \"Metric for redistributed routes\\n\"\n       \"Default metric\\n\"\n       \"Route map reference\\n\"\n       \"Pointer to route-map entries\\n\")\n#endif /* HAVE_IPV6 */\n\f\nint\nbgp_config_write_redistribute (struct vty *vty, struct bgp *bgp, afi_t afi,\n\t\t\t       safi_t safi, int *write)\n{\n  int i;\n\n  /* Unicast redistribution only.  */\n  if (safi != SAFI_UNICAST)\n    return 0;\n\n  for (i = 0; i < ZEBRA_ROUTE_MAX; i++)\n    {\n      /* Redistribute BGP does not make sense.  */\n      if (bgp->redist[afi][i] && i != ZEBRA_ROUTE_BGP)\n\t{\n\t  /* Display \"address-family\" when it is not yet diplayed.  */\n\t  bgp_config_write_family_header (vty, afi, safi, write);\n\n\t  /* \"redistribute\" configuration.  */\n\t  vty_out (vty, \" redistribute %s\", zebra_route_string(i));\n\n\t  if (bgp->redist_metric_flag[afi][i])\n\t    vty_out (vty, \" metric %d\", bgp->redist_metric[afi][i]);\n\n\t  if (bgp->rmap[afi][i].name)\n\t    vty_out (vty, \" route-map %s\", bgp->rmap[afi][i].name);\n\n\t  vty_out (vty, \"%s\", VTY_NEWLINE);\n\t}\n    }\n  return *write;\n}\n\f\n/* BGP node structure. */\nstruct cmd_node bgp_node =\n{\n  BGP_NODE,\n  \"%s(config-router)# \",\n  1,\n};\n\nstruct cmd_node bgp_ipv4_unicast_node =\n{\n  BGP_IPV4_NODE,\n  \"%s(config-router-af)# \",\n  1,\n};\n\nstruct cmd_node bgp_ipv4_multicast_node =\n{\n  BGP_IPV4M_NODE,\n  \"%s(config-router-af)# \",\n  1,\n};\n\nstruct cmd_node bgp_ipv6_unicast_node = \n{\n  BGP_IPV6_NODE,\n  \"%s(config-router-af)# \",\n  1,\n};\n\nstruct cmd_node bgp_ipv6_multicast_node =\n{\n  BGP_IPV6M_NODE,\n  \"%s(config-router-af)# \",\n  1,\n};\n\nstruct cmd_node bgp_vpnv4_node =\n{\n  BGP_VPNV4_NODE,\n  \"%s(config-router-af)# \",\n  1\n};\n\f\nstatic void community_list_vty (void);\n\nvoid\nbgp_vty_init (void)\n{\n  /* Install bgp top node. */\n  install_node (&bgp_node, bgp_config_write);\n  install_node (&bgp_ipv4_unicast_node, NULL);\n  install_node (&bgp_ipv4_multicast_node, NULL);\n  install_node (&bgp_ipv6_unicast_node, NULL);\n  install_node (&bgp_ipv6_multicast_node, NULL);\n  install_node (&bgp_vpnv4_node, NULL);\n\n  /* Install default VTY commands to new nodes.  */\n  install_default (BGP_NODE);\n  install_default (BGP_IPV4_NODE);\n  install_default (BGP_IPV4M_NODE);\n  install_default (BGP_IPV6_NODE);\n  install_default (BGP_IPV6M_NODE);\n  install_default (BGP_VPNV4_NODE);\n  \n  /* \"bgp multiple-instance\" commands. */\n  install_element (CONFIG_NODE, &bgp_multiple_instance_cmd);\n  install_element (CONFIG_NODE, &no_bgp_multiple_instance_cmd);\n\n  /* \"bgp config-type\" commands. */\n  install_element (CONFIG_NODE, &bgp_config_type_cmd);\n  install_element (CONFIG_NODE, &no_bgp_config_type_cmd);\n\n  /* Dummy commands (Currently not supported) */\n  install_element (BGP_NODE, &no_synchronization_cmd);\n  install_element (BGP_NODE, &no_auto_summary_cmd);\n\n  /* \"router bgp\" commands. */\n  install_element (CONFIG_NODE, &router_bgp_cmd);\n  install_element (CONFIG_NODE, &router_bgp_view_cmd);\n\n  /* \"no router bgp\" commands. */\n  install_element (CONFIG_NODE, &no_router_bgp_cmd);\n  install_element (CONFIG_NODE, &no_router_bgp_view_cmd);\n\n  /* \"bgp router-id\" commands. */\n  install_element (BGP_NODE, &bgp_router_id_cmd);\n  install_element (BGP_NODE, &no_bgp_router_id_cmd);\n  install_element (BGP_NODE, &no_bgp_router_id_val_cmd);\n\n  /* \"bgp cluster-id\" commands. */\n  install_element (BGP_NODE, &bgp_cluster_id_cmd);\n  install_element (BGP_NODE, &bgp_cluster_id32_cmd);\n  install_element (BGP_NODE, &no_bgp_cluster_id_cmd);\n  install_element (BGP_NODE, &no_bgp_cluster_id_arg_cmd);\n\n  /* \"bgp confederation\" commands. */\n  install_element (BGP_NODE, &bgp_confederation_identifier_cmd);\n  install_element (BGP_NODE, &no_bgp_confederation_identifier_cmd);\n  install_element (BGP_NODE, &no_bgp_confederation_identifier_arg_cmd);\n\n  /* \"bgp confederation peers\" commands. */\n  install_element (BGP_NODE, &bgp_confederation_peers_cmd);\n  install_element (BGP_NODE, &no_bgp_confederation_peers_cmd);\n\n  /* \"timers bgp\" commands. */\n  install_element (BGP_NODE, &bgp_timers_cmd);\n  install_element (BGP_NODE, &no_bgp_timers_cmd);\n  install_element (BGP_NODE, &no_bgp_timers_arg_cmd);\n\n  /* \"bgp client-to-client reflection\" commands */\n  install_element (BGP_NODE, &no_bgp_client_to_client_reflection_cmd);\n  install_element (BGP_NODE, &bgp_client_to_client_reflection_cmd);\n\n  /* \"bgp always-compare-med\" commands */\n  install_element (BGP_NODE, &bgp_always_compare_med_cmd);\n  install_element (BGP_NODE, &no_bgp_always_compare_med_cmd);\n  \n  /* \"bgp deterministic-med\" commands */\n  install_element (BGP_NODE, &bgp_deterministic_med_cmd);\n  install_element (BGP_NODE, &no_bgp_deterministic_med_cmd);\n\n  /* \"bgp graceful-restart\" commands */\n  install_element (BGP_NODE, &bgp_graceful_restart_cmd);\n  install_element (BGP_NODE, &no_bgp_graceful_restart_cmd);\n  install_element (BGP_NODE, &bgp_graceful_restart_stalepath_time_cmd);\n  install_element (BGP_NODE, &no_bgp_graceful_restart_stalepath_time_cmd);\n  install_element (BGP_NODE, &no_bgp_graceful_restart_stalepath_time_val_cmd);\n \n  /* \"bgp fast-external-failover\" commands */\n  install_element (BGP_NODE, &bgp_fast_external_failover_cmd);\n  install_element (BGP_NODE, &no_bgp_fast_external_failover_cmd);\n\n  /* \"bgp enforce-first-as\" commands */\n  install_element (BGP_NODE, &bgp_enforce_first_as_cmd);\n  install_element (BGP_NODE, &no_bgp_enforce_first_as_cmd);\n\n  /* \"bgp bestpath compare-routerid\" commands */\n  install_element (BGP_NODE, &bgp_bestpath_compare_router_id_cmd);\n  install_element (BGP_NODE, &no_bgp_bestpath_compare_router_id_cmd);\n\n  /* \"bgp bestpath as-path ignore\" commands */\n  install_element (BGP_NODE, &bgp_bestpath_aspath_ignore_cmd);\n  install_element (BGP_NODE, &no_bgp_bestpath_aspath_ignore_cmd);\n\n  /* \"bgp bestpath as-path confed\" commands */\n  install_element (BGP_NODE, &bgp_bestpath_aspath_confed_cmd);\n  install_element (BGP_NODE, &no_bgp_bestpath_aspath_confed_cmd);\n\n  /* \"bgp log-neighbor-changes\" commands */\n  install_element (BGP_NODE, &bgp_log_neighbor_changes_cmd);\n  install_element (BGP_NODE, &no_bgp_log_neighbor_changes_cmd);\n\n  /* \"bgp bestpath med\" commands */\n  install_element (BGP_NODE, &bgp_bestpath_med_cmd);\n  install_element (BGP_NODE, &bgp_bestpath_med2_cmd);\n  install_element (BGP_NODE, &bgp_bestpath_med3_cmd);\n  install_element (BGP_NODE, &no_bgp_bestpath_med_cmd);\n  install_element (BGP_NODE, &no_bgp_bestpath_med2_cmd);\n  install_element (BGP_NODE, &no_bgp_bestpath_med3_cmd);\n\n  /* \"no bgp default ipv4-unicast\" commands. */\n  install_element (BGP_NODE, &no_bgp_default_ipv4_unicast_cmd);\n  install_element (BGP_NODE, &bgp_default_ipv4_unicast_cmd);\n  \n  /* \"bgp network import-check\" commands. */\n  install_element (BGP_NODE, &bgp_network_import_check_cmd);\n  install_element (BGP_NODE, &no_bgp_network_import_check_cmd);\n\n  /* \"bgp default local-preference\" commands. */\n  install_element (BGP_NODE, &bgp_default_local_preference_cmd);\n  install_element (BGP_NODE, &no_bgp_default_local_preference_cmd);\n  install_element (BGP_NODE, &no_bgp_default_local_preference_val_cmd);\n\n  /* \"neighbor remote-as\" commands. */\n  install_element (BGP_NODE, &neighbor_remote_as_cmd);\n  install_element (BGP_NODE, &no_neighbor_cmd);\n  install_element (BGP_NODE, &no_neighbor_remote_as_cmd);\n\n  /* \"neighbor peer-group\" commands. */\n  install_element (BGP_NODE, &neighbor_peer_group_cmd);\n  install_element (BGP_NODE, &no_neighbor_peer_group_cmd);\n  install_element (BGP_NODE, &no_neighbor_peer_group_remote_as_cmd);\n\n  /* \"neighbor local-as\" commands. */\n  install_element (BGP_NODE, &neighbor_local_as_cmd);\n  install_element (BGP_NODE, &neighbor_local_as_no_prepend_cmd);\n  install_element (BGP_NODE, &no_neighbor_local_as_cmd);\n  install_element (BGP_NODE, &no_neighbor_local_as_val_cmd);\n  install_element (BGP_NODE, &no_neighbor_local_as_val2_cmd);\n\n  /* \"neighbor activate\" commands. */\n  install_element (BGP_NODE, &neighbor_activate_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_activate_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_activate_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_activate_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_activate_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_activate_cmd);\n\n  /* \"no neighbor activate\" commands. */\n  install_element (BGP_NODE, &no_neighbor_activate_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_activate_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_activate_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_activate_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_activate_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_activate_cmd);\n\n  /* \"neighbor peer-group set\" commands. */\n  install_element (BGP_NODE, &neighbor_set_peer_group_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_set_peer_group_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_set_peer_group_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_set_peer_group_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_set_peer_group_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_set_peer_group_cmd);\n  \n  /* \"no neighbor peer-group unset\" commands. */\n  install_element (BGP_NODE, &no_neighbor_set_peer_group_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_set_peer_group_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_set_peer_group_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_set_peer_group_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_set_peer_group_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_set_peer_group_cmd);\n  \n  /* \"neighbor softreconfiguration inbound\" commands.*/\n  install_element (BGP_NODE, &neighbor_soft_reconfiguration_cmd);\n  install_element (BGP_NODE, &no_neighbor_soft_reconfiguration_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_soft_reconfiguration_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_soft_reconfiguration_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_soft_reconfiguration_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_soft_reconfiguration_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_soft_reconfiguration_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_soft_reconfiguration_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_soft_reconfiguration_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_soft_reconfiguration_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_soft_reconfiguration_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_soft_reconfiguration_cmd);\n\n  /* \"neighbor attribute-unchanged\" commands.  */\n  install_element (BGP_NODE, &neighbor_attr_unchanged_cmd);\n  install_element (BGP_NODE, &neighbor_attr_unchanged1_cmd);\n  install_element (BGP_NODE, &neighbor_attr_unchanged2_cmd);\n  install_element (BGP_NODE, &neighbor_attr_unchanged3_cmd);\n  install_element (BGP_NODE, &neighbor_attr_unchanged4_cmd);\n  install_element (BGP_NODE, &neighbor_attr_unchanged5_cmd);\n  install_element (BGP_NODE, &neighbor_attr_unchanged6_cmd);\n  install_element (BGP_NODE, &neighbor_attr_unchanged7_cmd);\n  install_element (BGP_NODE, &neighbor_attr_unchanged8_cmd);\n  install_element (BGP_NODE, &neighbor_attr_unchanged9_cmd);\n  install_element (BGP_NODE, &neighbor_attr_unchanged10_cmd);\n  install_element (BGP_NODE, &no_neighbor_attr_unchanged_cmd);\n  install_element (BGP_NODE, &no_neighbor_attr_unchanged1_cmd);\n  install_element (BGP_NODE, &no_neighbor_attr_unchanged2_cmd);\n  install_element (BGP_NODE, &no_neighbor_attr_unchanged3_cmd);\n  install_element (BGP_NODE, &no_neighbor_attr_unchanged4_cmd);\n  install_element (BGP_NODE, &no_neighbor_attr_unchanged5_cmd);\n  install_element (BGP_NODE, &no_neighbor_attr_unchanged6_cmd);\n  install_element (BGP_NODE, &no_neighbor_attr_unchanged7_cmd);\n  install_element (BGP_NODE, &no_neighbor_attr_unchanged8_cmd);\n  install_element (BGP_NODE, &no_neighbor_attr_unchanged9_cmd);\n  install_element (BGP_NODE, &no_neighbor_attr_unchanged10_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_attr_unchanged_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_attr_unchanged1_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_attr_unchanged2_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_attr_unchanged3_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_attr_unchanged4_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_attr_unchanged5_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_attr_unchanged6_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_attr_unchanged7_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_attr_unchanged8_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_attr_unchanged9_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_attr_unchanged10_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_attr_unchanged_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_attr_unchanged1_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_attr_unchanged2_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_attr_unchanged3_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_attr_unchanged4_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_attr_unchanged5_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_attr_unchanged6_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_attr_unchanged7_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_attr_unchanged8_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_attr_unchanged9_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_attr_unchanged10_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_attr_unchanged_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_attr_unchanged1_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_attr_unchanged2_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_attr_unchanged3_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_attr_unchanged4_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_attr_unchanged5_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_attr_unchanged6_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_attr_unchanged7_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_attr_unchanged8_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_attr_unchanged9_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_attr_unchanged10_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_attr_unchanged_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_attr_unchanged1_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_attr_unchanged2_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_attr_unchanged3_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_attr_unchanged4_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_attr_unchanged5_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_attr_unchanged6_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_attr_unchanged7_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_attr_unchanged8_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_attr_unchanged9_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_attr_unchanged10_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_attr_unchanged_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_attr_unchanged1_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_attr_unchanged2_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_attr_unchanged3_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_attr_unchanged4_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_attr_unchanged5_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_attr_unchanged6_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_attr_unchanged7_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_attr_unchanged8_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_attr_unchanged9_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_attr_unchanged10_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_attr_unchanged_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_attr_unchanged1_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_attr_unchanged2_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_attr_unchanged3_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_attr_unchanged4_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_attr_unchanged5_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_attr_unchanged6_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_attr_unchanged7_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_attr_unchanged8_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_attr_unchanged9_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_attr_unchanged10_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_attr_unchanged_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_attr_unchanged1_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_attr_unchanged2_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_attr_unchanged3_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_attr_unchanged4_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_attr_unchanged5_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_attr_unchanged6_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_attr_unchanged7_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_attr_unchanged8_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_attr_unchanged9_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_attr_unchanged10_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_attr_unchanged_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_attr_unchanged1_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_attr_unchanged2_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_attr_unchanged3_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_attr_unchanged4_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_attr_unchanged5_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_attr_unchanged6_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_attr_unchanged7_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_attr_unchanged8_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_attr_unchanged9_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_attr_unchanged10_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_attr_unchanged_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_attr_unchanged1_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_attr_unchanged2_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_attr_unchanged3_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_attr_unchanged4_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_attr_unchanged5_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_attr_unchanged6_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_attr_unchanged7_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_attr_unchanged8_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_attr_unchanged9_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_attr_unchanged10_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_attr_unchanged_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_attr_unchanged1_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_attr_unchanged2_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_attr_unchanged3_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_attr_unchanged4_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_attr_unchanged5_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_attr_unchanged6_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_attr_unchanged7_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_attr_unchanged8_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_attr_unchanged9_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_attr_unchanged10_cmd);\n\n  /* \"nexthop-local unchanged\" commands */\n  install_element (BGP_IPV6_NODE, &neighbor_nexthop_local_unchanged_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_nexthop_local_unchanged_cmd);\n\n  /* \"transparent-as\" and \"transparent-nexthop\" for old version\n     compatibility.  */\n  install_element (BGP_NODE, &neighbor_transparent_as_cmd);\n  install_element (BGP_NODE, &neighbor_transparent_nexthop_cmd);\n\n  /* \"neighbor next-hop-self\" commands. */\n  install_element (BGP_NODE, &neighbor_nexthop_self_cmd);\n  install_element (BGP_NODE, &no_neighbor_nexthop_self_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_nexthop_self_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_nexthop_self_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_nexthop_self_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_nexthop_self_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_nexthop_self_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_nexthop_self_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_nexthop_self_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_nexthop_self_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_nexthop_self_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_nexthop_self_cmd);\n\n  /* \"neighbor remove-private-AS\" commands. */\n  install_element (BGP_NODE, &neighbor_remove_private_as_cmd);\n  install_element (BGP_NODE, &no_neighbor_remove_private_as_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_remove_private_as_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_remove_private_as_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_remove_private_as_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_remove_private_as_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_remove_private_as_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_remove_private_as_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_remove_private_as_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_remove_private_as_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_remove_private_as_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_remove_private_as_cmd);\n\n  /* \"neighbor send-community\" commands.*/\n  install_element (BGP_NODE, &neighbor_send_community_cmd);\n  install_element (BGP_NODE, &neighbor_send_community_type_cmd);\n  install_element (BGP_NODE, &no_neighbor_send_community_cmd);\n  install_element (BGP_NODE, &no_neighbor_send_community_type_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_send_community_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_send_community_type_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_send_community_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_send_community_type_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_send_community_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_send_community_type_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_send_community_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_send_community_type_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_send_community_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_send_community_type_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_send_community_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_send_community_type_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_send_community_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_send_community_type_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_send_community_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_send_community_type_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_send_community_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_send_community_type_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_send_community_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_send_community_type_cmd);\n\n  /* \"neighbor route-reflector\" commands.*/\n  install_element (BGP_NODE, &neighbor_route_reflector_client_cmd);\n  install_element (BGP_NODE, &no_neighbor_route_reflector_client_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_route_reflector_client_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_route_reflector_client_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_route_reflector_client_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_route_reflector_client_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_route_reflector_client_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_route_reflector_client_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_route_reflector_client_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_route_reflector_client_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_route_reflector_client_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_route_reflector_client_cmd);\n\n  /* \"neighbor route-server\" commands.*/\n  install_element (BGP_NODE, &neighbor_route_server_client_cmd);\n  install_element (BGP_NODE, &no_neighbor_route_server_client_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_route_server_client_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_route_server_client_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_route_server_client_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_route_server_client_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_route_server_client_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_route_server_client_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_route_server_client_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_route_server_client_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_route_server_client_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_route_server_client_cmd);\n\n  /* \"neighbor passive\" commands. */\n  install_element (BGP_NODE, &neighbor_passive_cmd);\n  install_element (BGP_NODE, &no_neighbor_passive_cmd);\n\n  /* \"neighbor shutdown\" commands. */\n  install_element (BGP_NODE, &neighbor_shutdown_cmd);\n  install_element (BGP_NODE, &no_neighbor_shutdown_cmd);\n\n  /* Deprecated \"neighbor capability route-refresh\" commands.*/\n  install_element (BGP_NODE, &neighbor_capability_route_refresh_cmd);\n  install_element (BGP_NODE, &no_neighbor_capability_route_refresh_cmd);\n\n  /* \"neighbor capability orf prefix-list\" commands.*/\n  install_element (BGP_NODE, &neighbor_capability_orf_prefix_cmd);\n  install_element (BGP_NODE, &no_neighbor_capability_orf_prefix_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_capability_orf_prefix_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_capability_orf_prefix_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_capability_orf_prefix_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_capability_orf_prefix_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_capability_orf_prefix_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_capability_orf_prefix_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_capability_orf_prefix_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_capability_orf_prefix_cmd);\n\n  /* \"neighbor capability dynamic\" commands.*/\n  install_element (BGP_NODE, &neighbor_capability_dynamic_cmd);\n  install_element (BGP_NODE, &no_neighbor_capability_dynamic_cmd);\n\n  /* \"neighbor dont-capability-negotiate\" commands. */\n  install_element (BGP_NODE, &neighbor_dont_capability_negotiate_cmd);\n  install_element (BGP_NODE, &no_neighbor_dont_capability_negotiate_cmd);\n\n  /* \"neighbor ebgp-multihop\" commands. */\n  install_element (BGP_NODE, &neighbor_ebgp_multihop_cmd);\n  install_element (BGP_NODE, &neighbor_ebgp_multihop_ttl_cmd);\n  install_element (BGP_NODE, &no_neighbor_ebgp_multihop_cmd);\n  install_element (BGP_NODE, &no_neighbor_ebgp_multihop_ttl_cmd);\n\n  /* \"neighbor disable-connected-check\" commands.  */\n  install_element (BGP_NODE, &neighbor_disable_connected_check_cmd);\n  install_element (BGP_NODE, &no_neighbor_disable_connected_check_cmd);\n  install_element (BGP_NODE, &neighbor_enforce_multihop_cmd);\n  install_element (BGP_NODE, &no_neighbor_enforce_multihop_cmd);\n\n  /* \"neighbor description\" commands. */\n  install_element (BGP_NODE, &neighbor_description_cmd);\n  install_element (BGP_NODE, &no_neighbor_description_cmd);\n  install_element (BGP_NODE, &no_neighbor_description_val_cmd);\n\n  /* \"neighbor update-source\" commands. \"*/\n  install_element (BGP_NODE, &neighbor_update_source_cmd);\n  install_element (BGP_NODE, &no_neighbor_update_source_cmd);\n\n  /* \"neighbor default-originate\" commands. */\n  install_element (BGP_NODE, &neighbor_default_originate_cmd);\n  install_element (BGP_NODE, &neighbor_default_originate_rmap_cmd);\n  install_element (BGP_NODE, &no_neighbor_default_originate_cmd);\n  install_element (BGP_NODE, &no_neighbor_default_originate_rmap_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_default_originate_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_default_originate_rmap_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_default_originate_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_default_originate_rmap_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_default_originate_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_default_originate_rmap_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_default_originate_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_default_originate_rmap_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_default_originate_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_default_originate_rmap_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_default_originate_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_default_originate_rmap_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_default_originate_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_default_originate_rmap_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_default_originate_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_default_originate_rmap_cmd);\n\n  /* \"neighbor port\" commands. */\n  install_element (BGP_NODE, &neighbor_port_cmd);\n  install_element (BGP_NODE, &no_neighbor_port_cmd);\n  install_element (BGP_NODE, &no_neighbor_port_val_cmd);\n\n  /* \"neighbor weight\" commands. */\n  install_element (BGP_NODE, &neighbor_weight_cmd);\n  install_element (BGP_NODE, &no_neighbor_weight_cmd);\n  install_element (BGP_NODE, &no_neighbor_weight_val_cmd);\n\n  /* \"neighbor override-capability\" commands. */\n  install_element (BGP_NODE, &neighbor_override_capability_cmd);\n  install_element (BGP_NODE, &no_neighbor_override_capability_cmd);\n\n  /* \"neighbor strict-capability-match\" commands. */\n  install_element (BGP_NODE, &neighbor_strict_capability_cmd);\n  install_element (BGP_NODE, &no_neighbor_strict_capability_cmd);\n\n  /* \"neighbor timers\" commands. */\n  install_element (BGP_NODE, &neighbor_timers_cmd);\n  install_element (BGP_NODE, &no_neighbor_timers_cmd);\n\n  /* \"neighbor timers connect\" commands. */\n  install_element (BGP_NODE, &neighbor_timers_connect_cmd);\n  install_element (BGP_NODE, &no_neighbor_timers_connect_cmd);\n  install_element (BGP_NODE, &no_neighbor_timers_connect_val_cmd);\n\n  /* \"neighbor advertisement-interval\" commands. */\n  install_element (BGP_NODE, &neighbor_advertise_interval_cmd);\n  install_element (BGP_NODE, &no_neighbor_advertise_interval_cmd);\n  install_element (BGP_NODE, &no_neighbor_advertise_interval_val_cmd);\n\n  /* \"neighbor version\" commands. */\n  install_element (BGP_NODE, &neighbor_version_cmd);\n\n  /* \"neighbor interface\" commands. */\n  install_element (BGP_NODE, &neighbor_interface_cmd);\n  install_element (BGP_NODE, &no_neighbor_interface_cmd);\n\n  /* \"neighbor distribute\" commands. */\n  install_element (BGP_NODE, &neighbor_distribute_list_cmd);\n  install_element (BGP_NODE, &no_neighbor_distribute_list_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_distribute_list_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_distribute_list_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_distribute_list_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_distribute_list_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_distribute_list_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_distribute_list_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_distribute_list_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_distribute_list_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_distribute_list_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_distribute_list_cmd);\n\n  /* \"neighbor prefix-list\" commands. */\n  install_element (BGP_NODE, &neighbor_prefix_list_cmd);\n  install_element (BGP_NODE, &no_neighbor_prefix_list_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_prefix_list_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_prefix_list_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_prefix_list_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_prefix_list_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_prefix_list_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_prefix_list_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_prefix_list_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_prefix_list_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_prefix_list_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_prefix_list_cmd);\n\n  /* \"neighbor filter-list\" commands. */\n  install_element (BGP_NODE, &neighbor_filter_list_cmd);\n  install_element (BGP_NODE, &no_neighbor_filter_list_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_filter_list_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_filter_list_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_filter_list_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_filter_list_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_filter_list_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_filter_list_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_filter_list_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_filter_list_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_filter_list_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_filter_list_cmd);\n\n  /* \"neighbor route-map\" commands. */\n  install_element (BGP_NODE, &neighbor_route_map_cmd);\n  install_element (BGP_NODE, &no_neighbor_route_map_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_route_map_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_route_map_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_route_map_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_route_map_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_route_map_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_route_map_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_route_map_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_route_map_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_route_map_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_route_map_cmd);\n\n  /* \"neighbor unsuppress-map\" commands. */\n  install_element (BGP_NODE, &neighbor_unsuppress_map_cmd);\n  install_element (BGP_NODE, &no_neighbor_unsuppress_map_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_unsuppress_map_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_unsuppress_map_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_unsuppress_map_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_unsuppress_map_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_unsuppress_map_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_unsuppress_map_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_unsuppress_map_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_unsuppress_map_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_unsuppress_map_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_unsuppress_map_cmd);  \n\n  /* \"neighbor maximum-prefix\" commands. */\n  install_element (BGP_NODE, &neighbor_maximum_prefix_cmd);\n  install_element (BGP_NODE, &neighbor_maximum_prefix_threshold_cmd);\n  install_element (BGP_NODE, &neighbor_maximum_prefix_warning_cmd);\n  install_element (BGP_NODE, &neighbor_maximum_prefix_threshold_warning_cmd);\n  install_element (BGP_NODE, &neighbor_maximum_prefix_restart_cmd);\n  install_element (BGP_NODE, &neighbor_maximum_prefix_threshold_restart_cmd);\n  install_element (BGP_NODE, &no_neighbor_maximum_prefix_cmd);\n  install_element (BGP_NODE, &no_neighbor_maximum_prefix_val_cmd);\n  install_element (BGP_NODE, &no_neighbor_maximum_prefix_threshold_cmd);\n  install_element (BGP_NODE, &no_neighbor_maximum_prefix_warning_cmd);\n  install_element (BGP_NODE, &no_neighbor_maximum_prefix_threshold_warning_cmd);\n  install_element (BGP_NODE, &no_neighbor_maximum_prefix_restart_cmd);\n  install_element (BGP_NODE, &no_neighbor_maximum_prefix_threshold_restart_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_maximum_prefix_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_maximum_prefix_threshold_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_maximum_prefix_warning_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_maximum_prefix_threshold_warning_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_maximum_prefix_restart_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_maximum_prefix_threshold_restart_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_maximum_prefix_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_maximum_prefix_val_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_maximum_prefix_threshold_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_maximum_prefix_warning_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_maximum_prefix_threshold_warning_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_maximum_prefix_restart_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_maximum_prefix_threshold_restart_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_maximum_prefix_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_maximum_prefix_threshold_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_maximum_prefix_warning_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_maximum_prefix_threshold_warning_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_maximum_prefix_restart_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_maximum_prefix_threshold_restart_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_maximum_prefix_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_maximum_prefix_val_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_maximum_prefix_threshold_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_maximum_prefix_warning_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_maximum_prefix_threshold_warning_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_maximum_prefix_restart_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_maximum_prefix_threshold_restart_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_maximum_prefix_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_maximum_prefix_threshold_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_maximum_prefix_warning_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_maximum_prefix_threshold_warning_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_maximum_prefix_restart_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_maximum_prefix_threshold_restart_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_maximum_prefix_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_maximum_prefix_val_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_maximum_prefix_threshold_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_maximum_prefix_warning_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_maximum_prefix_threshold_warning_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_maximum_prefix_restart_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_maximum_prefix_threshold_restart_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_maximum_prefix_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_maximum_prefix_threshold_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_maximum_prefix_warning_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_maximum_prefix_threshold_warning_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_maximum_prefix_restart_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_maximum_prefix_threshold_restart_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_maximum_prefix_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_maximum_prefix_val_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_maximum_prefix_threshold_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_maximum_prefix_warning_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_maximum_prefix_threshold_warning_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_maximum_prefix_restart_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_maximum_prefix_threshold_restart_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_maximum_prefix_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_maximum_prefix_threshold_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_maximum_prefix_warning_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_maximum_prefix_threshold_warning_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_maximum_prefix_restart_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_maximum_prefix_threshold_restart_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_maximum_prefix_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_maximum_prefix_val_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_maximum_prefix_threshold_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_maximum_prefix_warning_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_maximum_prefix_threshold_warning_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_maximum_prefix_restart_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_maximum_prefix_threshold_restart_cmd);\n\n  /* \"neighbor allowas-in\" */\n  install_element (BGP_NODE, &neighbor_allowas_in_cmd);\n  install_element (BGP_NODE, &neighbor_allowas_in_arg_cmd);\n  install_element (BGP_NODE, &no_neighbor_allowas_in_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_allowas_in_cmd);\n  install_element (BGP_IPV4_NODE, &neighbor_allowas_in_arg_cmd);\n  install_element (BGP_IPV4_NODE, &no_neighbor_allowas_in_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_allowas_in_cmd);\n  install_element (BGP_IPV4M_NODE, &neighbor_allowas_in_arg_cmd);\n  install_element (BGP_IPV4M_NODE, &no_neighbor_allowas_in_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_allowas_in_cmd);\n  install_element (BGP_IPV6_NODE, &neighbor_allowas_in_arg_cmd);\n  install_element (BGP_IPV6_NODE, &no_neighbor_allowas_in_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_allowas_in_cmd);\n  install_element (BGP_IPV6M_NODE, &neighbor_allowas_in_arg_cmd);\n  install_element (BGP_IPV6M_NODE, &no_neighbor_allowas_in_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_allowas_in_cmd);\n  install_element (BGP_VPNV4_NODE, &neighbor_allowas_in_arg_cmd);\n  install_element (BGP_VPNV4_NODE, &no_neighbor_allowas_in_cmd);\n\n  /* address-family commands. */\n  install_element (BGP_NODE, &address_family_ipv4_cmd);\n  install_element (BGP_NODE, &address_family_ipv4_safi_cmd);\n#ifdef HAVE_IPV6\n  install_element (BGP_NODE, &address_family_ipv6_cmd);\n  install_element (BGP_NODE, &address_family_ipv6_safi_cmd);\n#endif /* HAVE_IPV6 */\n  install_element (BGP_NODE, &address_family_vpnv4_cmd);\n  install_element (BGP_NODE, &address_family_vpnv4_unicast_cmd);\n\n  /* \"exit-address-family\" command. */\n  install_element (BGP_IPV4_NODE, &exit_address_family_cmd);\n  install_element (BGP_IPV4M_NODE, &exit_address_family_cmd);\n  install_element (BGP_IPV6_NODE, &exit_address_family_cmd);\n  install_element (BGP_IPV6M_NODE, &exit_address_family_cmd);\n  install_element (BGP_VPNV4_NODE, &exit_address_family_cmd);\n\n  /* \"clear ip bgp commands\" */\n  install_element (ENABLE_NODE, &clear_ip_bgp_all_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_instance_all_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_as_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_group_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_external_cmd);\n#ifdef HAVE_IPV6\n  install_element (ENABLE_NODE, &clear_bgp_all_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_instance_all_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_all_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_peer_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_peer_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_peer_group_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_peer_group_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_external_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_external_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_as_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_as_cmd);\n#endif /* HAVE_IPV6 */\n\n  /* \"clear ip bgp neighbor soft in\" */\n  install_element (ENABLE_NODE, &clear_ip_bgp_all_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_instance_all_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_all_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_all_in_prefix_filter_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_instance_all_in_prefix_filter_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_in_prefix_filter_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_group_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_group_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_group_in_prefix_filter_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_external_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_external_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_external_in_prefix_filter_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_as_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_as_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_as_in_prefix_filter_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_all_ipv4_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_instance_all_ipv4_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_all_ipv4_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_all_ipv4_in_prefix_filter_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_instance_all_ipv4_in_prefix_filter_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_ipv4_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_ipv4_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_ipv4_in_prefix_filter_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_group_ipv4_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_group_ipv4_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_group_ipv4_in_prefix_filter_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_external_ipv4_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_external_ipv4_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_external_ipv4_in_prefix_filter_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_as_ipv4_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_as_ipv4_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_as_ipv4_in_prefix_filter_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_all_vpnv4_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_all_vpnv4_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_vpnv4_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_vpnv4_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_as_vpnv4_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_as_vpnv4_in_cmd);\n#ifdef HAVE_IPV6\n  install_element (ENABLE_NODE, &clear_bgp_all_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_instance_all_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_all_in_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_all_in_prefix_filter_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_peer_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_peer_in_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_peer_in_prefix_filter_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_peer_group_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_peer_group_in_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_peer_group_in_prefix_filter_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_external_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_external_in_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_external_in_prefix_filter_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_as_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_as_in_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_as_in_prefix_filter_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_all_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_all_in_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_all_in_prefix_filter_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_peer_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_peer_in_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_peer_in_prefix_filter_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_peer_group_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_peer_group_in_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_peer_group_in_prefix_filter_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_external_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_external_in_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_external_in_prefix_filter_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_as_soft_in_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_as_in_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_as_in_prefix_filter_cmd);\n#endif /* HAVE_IPV6 */\n\n  /* \"clear ip bgp neighbor soft out\" */\n  install_element (ENABLE_NODE, &clear_ip_bgp_all_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_instance_all_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_all_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_group_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_group_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_external_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_external_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_as_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_as_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_all_ipv4_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_instance_all_ipv4_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_all_ipv4_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_ipv4_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_ipv4_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_group_ipv4_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_group_ipv4_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_external_ipv4_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_external_ipv4_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_as_ipv4_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_as_ipv4_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_all_vpnv4_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_all_vpnv4_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_vpnv4_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_vpnv4_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_as_vpnv4_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_as_vpnv4_out_cmd);\n#ifdef HAVE_IPV6\n  install_element (ENABLE_NODE, &clear_bgp_all_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_instance_all_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_all_out_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_peer_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_peer_out_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_peer_group_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_peer_group_out_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_external_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_external_out_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_as_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_as_out_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_all_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_all_out_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_peer_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_peer_out_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_peer_group_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_peer_group_out_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_external_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_external_out_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_as_soft_out_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_as_out_cmd);\n#endif /* HAVE_IPV6 */\n\n  /* \"clear ip bgp neighbor soft\" */\n  install_element (ENABLE_NODE, &clear_ip_bgp_all_soft_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_instance_all_soft_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_soft_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_group_soft_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_external_soft_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_as_soft_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_all_ipv4_soft_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_instance_all_ipv4_soft_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_ipv4_soft_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_group_ipv4_soft_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_external_ipv4_soft_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_as_ipv4_soft_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_all_vpnv4_soft_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_vpnv4_soft_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_as_vpnv4_soft_cmd);\n#ifdef HAVE_IPV6\n  install_element (ENABLE_NODE, &clear_bgp_all_soft_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_instance_all_soft_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_peer_soft_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_peer_group_soft_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_external_soft_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_as_soft_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_all_soft_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_peer_soft_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_peer_group_soft_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_external_soft_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_as_soft_cmd);\n#endif /* HAVE_IPV6 */\n\n  /* \"clear ip bgp neighbor rsclient\" */\n  install_element (ENABLE_NODE, &clear_ip_bgp_all_rsclient_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_instance_all_rsclient_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_peer_rsclient_cmd);\n  install_element (ENABLE_NODE, &clear_ip_bgp_instance_peer_rsclient_cmd);\n#ifdef HAVE_IPV6\n  install_element (ENABLE_NODE, &clear_bgp_all_rsclient_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_instance_all_rsclient_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_all_rsclient_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_instance_all_rsclient_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_peer_rsclient_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_instance_peer_rsclient_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_peer_rsclient_cmd);\n  install_element (ENABLE_NODE, &clear_bgp_ipv6_instance_peer_rsclient_cmd);\n#endif /* HAVE_IPV6 */\n\n  /* \"show ip bgp summary\" commands. */\n  install_element (VIEW_NODE, &show_ip_bgp_summary_cmd);\n  install_element (VIEW_NODE, &show_ip_bgp_instance_summary_cmd);\n  install_element (VIEW_NODE, &show_ip_bgp_ipv4_summary_cmd);\n  install_element (VIEW_NODE, &show_ip_bgp_instance_ipv4_summary_cmd);\n  install_element (VIEW_NODE, &show_ip_bgp_vpnv4_all_summary_cmd);\n  install_element (VIEW_NODE, &show_ip_bgp_vpnv4_rd_summary_cmd);\n#ifdef HAVE_IPV6\n  install_element (VIEW_NODE, &show_bgp_summary_cmd);\n  install_element (VIEW_NODE, &show_bgp_instance_summary_cmd);\n  install_element (VIEW_NODE, &show_bgp_ipv6_summary_cmd);\n  install_element (VIEW_NODE, &show_bgp_instance_ipv6_summary_cmd);\n#endif /* HAVE_IPV6 */\n  install_element (ENABLE_NODE, &show_ip_bgp_summary_cmd);\n  install_element (ENABLE_NODE, &show_ip_bgp_instance_summary_cmd);\n  install_element (ENABLE_NODE, &show_ip_bgp_ipv4_summary_cmd);\n  install_element (ENABLE_NODE, &show_ip_bgp_instance_ipv4_summary_cmd);\n  install_element (ENABLE_NODE, &show_ip_bgp_vpnv4_all_summary_cmd);\n  install_element (ENABLE_NODE, &show_ip_bgp_vpnv4_rd_summary_cmd);\n#ifdef HAVE_IPV6\n  install_element (ENABLE_NODE, &show_bgp_summary_cmd);\n  install_element (ENABLE_NODE, &show_bgp_instance_summary_cmd);\n  install_element (ENABLE_NODE, &show_bgp_ipv6_summary_cmd);\n  install_element (ENABLE_NODE, &show_bgp_instance_ipv6_summary_cmd);\n#endif /* HAVE_IPV6 */\n\n  /* \"show ip bgp neighbors\" commands. */\n  install_element (VIEW_NODE, &show_ip_bgp_neighbors_cmd);\n  install_element (VIEW_NODE, &show_ip_bgp_ipv4_neighbors_cmd);\n  install_element (VIEW_NODE, &show_ip_bgp_neighbors_peer_cmd);\n  install_element (VIEW_NODE, &show_ip_bgp_ipv4_neighbors_peer_cmd);\n  install_element (VIEW_NODE, &show_ip_bgp_vpnv4_all_neighbors_cmd);\n  install_element (VIEW_NODE, &show_ip_bgp_vpnv4_rd_neighbors_cmd);\n  install_element (VIEW_NODE, &show_ip_bgp_vpnv4_all_neighbors_peer_cmd);\n  install_element (VIEW_NODE, &show_ip_bgp_vpnv4_rd_neighbors_peer_cmd);\n  install_element (VIEW_NODE, &show_ip_bgp_instance_neighbors_cmd);\n  install_element (VIEW_NODE, &show_ip_bgp_instance_neighbors_peer_cmd);\n  install_element (ENABLE_NODE, &show_ip_bgp_neighbors_cmd);\n  install_element (ENABLE_NODE, &show_ip_bgp_ipv4_neighbors_cmd);\n  install_element (ENABLE_NODE, &show_ip_bgp_neighbors_peer_cmd);\n  install_element (ENABLE_NODE, &show_ip_bgp_ipv4_neighbors_peer_cmd);\n  install_element (ENABLE_NODE, &show_ip_bgp_vpnv4_all_neighbors_cmd);\n  install_element (ENABLE_NODE, &show_ip_bgp_vpnv4_rd_neighbors_cmd);\n  install_element (ENABLE_NODE, &show_ip_bgp_vpnv4_all_neighbors_peer_cmd);\n  install_element (ENABLE_NODE, &show_ip_bgp_vpnv4_rd_neighbors_peer_cmd);\n  install_element (ENABLE_NODE, &show_ip_bgp_instance_neighbors_cmd);\n  install_element (ENABLE_NODE, &show_ip_bgp_instance_neighbors_peer_cmd);\n\n#ifdef HAVE_IPV6\n  install_element (VIEW_NODE, &show_bgp_neighbors_cmd);\n  install_element (VIEW_NODE, &show_bgp_ipv6_neighbors_cmd);\n  install_element (VIEW_NODE, &show_bgp_neighbors_peer_cmd);\n  install_element (VIEW_NODE, &show_bgp_ipv6_neighbors_peer_cmd);\n  install_element (VIEW_NODE, &show_bgp_instance_neighbors_cmd);\n  install_element (VIEW_NODE, &show_bgp_instance_ipv6_neighbors_cmd);\n  install_element (VIEW_NODE, &show_bgp_instance_neighbors_peer_cmd);\n  install_element (VIEW_NODE, &show_bgp_instance_ipv6_neighbors_peer_cmd);\n  install_element (ENABLE_NODE, &show_bgp_neighbors_cmd);\n  install_element (ENABLE_NODE, &show_bgp_ipv6_neighbors_cmd);\n  install_element (ENABLE_NODE, &show_bgp_neighbors_peer_cmd);\n  install_element (ENABLE_NODE, &show_bgp_ipv6_neighbors_peer_cmd);\n  install_element (ENABLE_NODE, &show_bgp_instance_neighbors_cmd);\n  install_element (ENABLE_NODE, &show_bgp_instance_ipv6_neighbors_cmd);\n  install_element (ENABLE_NODE, &show_bgp_instance_neighbors_peer_cmd);\n  install_element (ENABLE_NODE, &show_bgp_instance_ipv6_neighbors_peer_cmd);\n\n  /* Old commands.  */\n  install_element (VIEW_NODE, &show_ipv6_bgp_summary_cmd);\n  install_element (VIEW_NODE, &show_ipv6_mbgp_summary_cmd);\n  install_element (ENABLE_NODE, &show_ipv6_bgp_summary_cmd);\n  install_element (ENABLE_NODE, &show_ipv6_mbgp_summary_cmd);\n#endif /* HAVE_IPV6 */\n\n  /* \"show ip bgp rsclient\" commands. */\n  install_element (VIEW_NODE, &show_ip_bgp_rsclient_summary_cmd);\n  install_element (VIEW_NODE, &show_ip_bgp_instance_rsclient_summary_cmd);\n  install_element (VIEW_NODE, &show_ip_bgp_ipv4_rsclient_summary_cmd);\n  install_element (VIEW_NODE, &show_ip_bgp_instance_ipv4_rsclient_summary_cmd);\n  install_element (ENABLE_NODE, &show_ip_bgp_rsclient_summary_cmd);\n  install_element (ENABLE_NODE, &show_ip_bgp_instance_rsclient_summary_cmd);\n  install_element (ENABLE_NODE, &show_ip_bgp_ipv4_rsclient_summary_cmd);\n  install_element (ENABLE_NODE, &show_ip_bgp_instance_ipv4_rsclient_summary_cmd);\n\n#ifdef HAVE_IPV6\n  install_element (VIEW_NODE, &show_bgp_rsclient_summary_cmd);\n  install_element (VIEW_NODE, &show_bgp_ipv6_rsclient_summary_cmd);\n  install_element (VIEW_NODE, &show_bgp_instance_rsclient_summary_cmd);\n  install_element (VIEW_NODE, &show_bgp_instance_ipv6_rsclient_summary_cmd);\n  install_element (ENABLE_NODE, &show_bgp_rsclient_summary_cmd);\n  install_element (ENABLE_NODE, &show_bgp_ipv6_rsclient_summary_cmd);\n  install_element (ENABLE_NODE, &show_bgp_instance_rsclient_summary_cmd);\n  install_element (ENABLE_NODE, &show_bgp_instance_ipv6_rsclient_summary_cmd);\n#endif /* HAVE_IPV6 */\n\n  /* \"show ip bgp paths\" commands. */\n  install_element (VIEW_NODE, &show_ip_bgp_paths_cmd);\n  install_element (VIEW_NODE, &show_ip_bgp_ipv4_paths_cmd);\n  install_element (ENABLE_NODE, &show_ip_bgp_paths_cmd);\n  install_element (ENABLE_NODE, &show_ip_bgp_ipv4_paths_cmd);\n\n  /* \"show ip bgp community\" commands. */\n  install_element (VIEW_NODE, &show_ip_bgp_community_info_cmd);\n  install_element (ENABLE_NODE, &show_ip_bgp_community_info_cmd);\n\n  /* \"show ip bgp attribute-info\" commands. */\n  install_element (VIEW_NODE, &show_ip_bgp_attr_info_cmd);\n  install_element (ENABLE_NODE, &show_ip_bgp_attr_info_cmd);\n\n  /* \"redistribute\" commands.  */\n  install_element (BGP_NODE, &bgp_redistribute_ipv4_cmd);\n  install_element (BGP_NODE, &no_bgp_redistribute_ipv4_cmd);\n  install_element (BGP_NODE, &bgp_redistribute_ipv4_rmap_cmd);\n  install_element (BGP_NODE, &no_bgp_redistribute_ipv4_rmap_cmd);\n  install_element (BGP_NODE, &bgp_redistribute_ipv4_metric_cmd);\n  install_element (BGP_NODE, &no_bgp_redistribute_ipv4_metric_cmd);\n  install_element (BGP_NODE, &bgp_redistribute_ipv4_rmap_metric_cmd);\n  install_element (BGP_NODE, &bgp_redistribute_ipv4_metric_rmap_cmd);\n  install_element (BGP_NODE, &no_bgp_redistribute_ipv4_rmap_metric_cmd);\n  install_element (BGP_NODE, &no_bgp_redistribute_ipv4_metric_rmap_cmd);\n#ifdef HAVE_IPV6\n  install_element (BGP_IPV6_NODE, &bgp_redistribute_ipv6_cmd);\n  install_element (BGP_IPV6_NODE, &no_bgp_redistribute_ipv6_cmd);\n  install_element (BGP_IPV6_NODE, &bgp_redistribute_ipv6_rmap_cmd);\n  install_element (BGP_IPV6_NODE, &no_bgp_redistribute_ipv6_rmap_cmd);\n  install_element (BGP_IPV6_NODE, &bgp_redistribute_ipv6_metric_cmd);\n  install_element (BGP_IPV6_NODE, &no_bgp_redistribute_ipv6_metric_cmd);\n  install_element (BGP_IPV6_NODE, &bgp_redistribute_ipv6_rmap_metric_cmd);\n  install_element (BGP_IPV6_NODE, &bgp_redistribute_ipv6_metric_rmap_cmd);\n  install_element (BGP_IPV6_NODE, &no_bgp_redistribute_ipv6_rmap_metric_cmd);\n  install_element (BGP_IPV6_NODE, &no_bgp_redistribute_ipv6_metric_rmap_cmd);\n#endif /* HAVE_IPV6 */\n\n  /* \"show bgp memory\" commands. */\n  install_element (VIEW_NODE, &show_bgp_memory_cmd);\n  install_element (ENABLE_NODE, &show_bgp_memory_cmd);\n  \n  /* Community-list. */\n  community_list_vty ();\n}\n\f\n#include \"memory.h\"\n#include \"bgp_regex.h\"\n#include \"bgp_clist.h\"\n#include \"bgp_ecommunity.h\"\n\n/* VTY functions.  */\n\n/* Direction value to string conversion.  */\nstatic const char *\ncommunity_direct_str (int direct)\n{\n  switch (direct)\n    {\n    case COMMUNITY_DENY:\n      return \"deny\";\n    case COMMUNITY_PERMIT:\n      return \"permit\";\n    default:\n      return \"unknown\";\n    }\n}\n\n/* Display error string.  */\nstatic void\ncommunity_list_perror (struct vty *vty, int ret)\n{\n  switch (ret)\n    {\n    case COMMUNITY_LIST_ERR_CANT_FIND_LIST:\n      vty_out (vty, \"%% Can't find communit-list%s\", VTY_NEWLINE);\n      break;\n    case COMMUNITY_LIST_ERR_MALFORMED_VAL:\n      vty_out (vty, \"%% Malformed community-list value%s\", VTY_NEWLINE);\n      break;\n    case COMMUNITY_LIST_ERR_STANDARD_CONFLICT:\n      vty_out (vty, \"%% Community name conflict, previously defined as standard community%s\", VTY_NEWLINE);\n      break;\n    case COMMUNITY_LIST_ERR_EXPANDED_CONFLICT:\n      vty_out (vty, \"%% Community name conflict, previously defined as expanded community%s\", VTY_NEWLINE);\n      break;\n    }\n}\n\n/* VTY interface for community_set() function.  */\nstatic int\ncommunity_list_set_vty (struct vty *vty, int argc, const char **argv, \n                        int style, int reject_all_digit_name)\n{\n  int ret;\n  int direct;\n  char *str;\n\n  /* Check the list type. */\n  if (strncmp (argv[1], \"p\", 1) == 0)\n    direct = COMMUNITY_PERMIT;\n  else if (strncmp (argv[1], \"d\", 1) == 0)\n    direct = COMMUNITY_DENY;\n  else\n    {\n      vty_out (vty, \"%% Matching condition must be permit or deny%s\",\n\t       VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  /* All digit name check.  */\n  if (reject_all_digit_name && all_digit (argv[0]))\n    {\n      vty_out (vty, \"%% Community name cannot have all digits%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  /* Concat community string argument.  */\n  if (argc > 1)\n    str = argv_concat (argv, argc, 2);\n  else\n    str = NULL;\n\n  /* When community_list_set() return nevetive value, it means\n     malformed community string.  */\n  ret = community_list_set (bgp_clist, argv[0], str, direct, style);\n\n  /* Free temporary community list string allocated by\n     argv_concat().  */\n  if (str)\n    XFREE (MTYPE_TMP, str);\n\n  if (ret < 0)\n    {\n      /* Display error string.  */\n      community_list_perror (vty, ret);\n      return CMD_WARNING;\n    }\n\n  return CMD_SUCCESS;\n}\n\n/* Communiyt-list entry delete.  */\nstatic int\ncommunity_list_unset_vty (struct vty *vty, int argc, const char **argv,\n\t\t\t  int style)\n{\n  int ret;\n  int direct = 0;\n  char *str = NULL;\n\n  if (argc > 1)\n    {\n      /* Check the list direct. */\n      if (strncmp (argv[1], \"p\", 1) == 0)\n\tdirect = COMMUNITY_PERMIT;\n      else if (strncmp (argv[1], \"d\", 1) == 0)\n\tdirect = COMMUNITY_DENY;\n      else\n\t{\n\t  vty_out (vty, \"%% Matching condition must be permit or deny%s\",\n\t\t   VTY_NEWLINE);\n\t  return CMD_WARNING;\n\t}\n\n      /* Concat community string argument.  */\n      str = argv_concat (argv, argc, 2);\n    }\n\n  /* Unset community list.  */\n  ret = community_list_unset (bgp_clist, argv[0], str, direct, style);\n\n  /* Free temporary community list string allocated by\n     argv_concat().  */\n  if (str)\n    XFREE (MTYPE_TMP, str);\n\n  if (ret < 0)\n    {\n      community_list_perror (vty, ret);\n      return CMD_WARNING;\n    }\n\n  return CMD_SUCCESS;\n}\n\n/* \"community-list\" keyword help string.  */\n#define COMMUNITY_LIST_STR \"Add a community list entry\\n\"\n#define COMMUNITY_VAL_STR  \"Community number in aa:nn format or internet|local-AS|no-advertise|no-export\\n\"\n\nDEFUN (ip_community_list_standard,\n       ip_community_list_standard_cmd,\n       \"ip community-list <1-99> (deny|permit) .AA:NN\",\n       IP_STR\n       COMMUNITY_LIST_STR\n       \"Community list number (standard)\\n\"\n       \"Specify community to reject\\n\"\n       \"Specify community to accept\\n\"\n       COMMUNITY_VAL_STR)\n{\n  return community_list_set_vty (vty, argc, argv, COMMUNITY_LIST_STANDARD, 0);\n}\n\nALIAS (ip_community_list_standard,\n       ip_community_list_standard2_cmd,\n       \"ip community-list <1-99> (deny|permit)\",\n       IP_STR\n       COMMUNITY_LIST_STR\n       \"Community list number (standard)\\n\"\n       \"Specify community to reject\\n\"\n       \"Specify community to accept\\n\")\n\nDEFUN (ip_community_list_expanded,\n       ip_community_list_expanded_cmd,\n       \"ip community-list <100-500> (deny|permit) .LINE\",\n       IP_STR\n       COMMUNITY_LIST_STR\n       \"Community list number (expanded)\\n\"\n       \"Specify community to reject\\n\"\n       \"Specify community to accept\\n\"\n       \"An ordered list as a regular-expression\\n\")\n{\n  return community_list_set_vty (vty, argc, argv, COMMUNITY_LIST_EXPANDED, 0);\n}\n\nDEFUN (ip_community_list_name_standard,\n       ip_community_list_name_standard_cmd,\n       \"ip community-list standard WORD (deny|permit) .AA:NN\",\n       IP_STR\n       COMMUNITY_LIST_STR\n       \"Add a standard community-list entry\\n\"\n       \"Community list name\\n\"\n       \"Specify community to reject\\n\"\n       \"Specify community to accept\\n\"\n       COMMUNITY_VAL_STR)\n{\n  return community_list_set_vty (vty, argc, argv, COMMUNITY_LIST_STANDARD, 1);\n}\n\nALIAS (ip_community_list_name_standard,\n       ip_community_list_name_standard2_cmd,\n       \"ip community-list standard WORD (deny|permit)\",\n       IP_STR\n       COMMUNITY_LIST_STR\n       \"Add a standard community-list entry\\n\"\n       \"Community list name\\n\"\n       \"Specify community to reject\\n\"\n       \"Specify community to accept\\n\")\n\nDEFUN (ip_community_list_name_expanded,\n       ip_community_list_name_expanded_cmd,\n       \"ip community-list expanded WORD (deny|permit) .LINE\",\n       IP_STR\n       COMMUNITY_LIST_STR\n       \"Add an expanded community-list entry\\n\"\n       \"Community list name\\n\"\n       \"Specify community to reject\\n\"\n       \"Specify community to accept\\n\"\n       \"An ordered list as a regular-expression\\n\")\n{\n  return community_list_set_vty (vty, argc, argv, COMMUNITY_LIST_EXPANDED, 1);\n}\n\nDEFUN (no_ip_community_list_standard_all,\n       no_ip_community_list_standard_all_cmd,\n       \"no ip community-list <1-99>\",\n       NO_STR\n       IP_STR\n       COMMUNITY_LIST_STR\n       \"Community list number (standard)\\n\")\n{\n  return community_list_unset_vty (vty, argc, argv, COMMUNITY_LIST_STANDARD);\n}\n\nDEFUN (no_ip_community_list_expanded_all,\n       no_ip_community_list_expanded_all_cmd,\n       \"no ip community-list <100-500>\",\n       NO_STR\n       IP_STR\n       COMMUNITY_LIST_STR\n       \"Community list number (expanded)\\n\")\n{\n  return community_list_unset_vty (vty, argc, argv, COMMUNITY_LIST_EXPANDED);\n}\n\nDEFUN (no_ip_community_list_name_standard_all,\n       no_ip_community_list_name_standard_all_cmd,\n       \"no ip community-list standard WORD\",\n       NO_STR\n       IP_STR\n       COMMUNITY_LIST_STR\n       \"Add a standard community-list entry\\n\"\n       \"Community list name\\n\")\n{\n  return community_list_unset_vty (vty, argc, argv, COMMUNITY_LIST_STANDARD);\n}\n\nDEFUN (no_ip_community_list_name_expanded_all,\n       no_ip_community_list_name_expanded_all_cmd,\n       \"no ip community-list expanded WORD\",\n       NO_STR\n       IP_STR\n       COMMUNITY_LIST_STR\n       \"Add an expanded community-list entry\\n\"\n       \"Community list name\\n\")\n{\n  return community_list_unset_vty (vty, argc, argv, COMMUNITY_LIST_EXPANDED);\n}\n\nDEFUN (no_ip_community_list_standard,\n       no_ip_community_list_standard_cmd,\n       \"no ip community-list <1-99> (deny|permit) .AA:NN\",\n       NO_STR\n       IP_STR\n       COMMUNITY_LIST_STR\n       \"Community list number (standard)\\n\"\n       \"Specify community to reject\\n\"\n       \"Specify community to accept\\n\"\n       COMMUNITY_VAL_STR)\n{\n  return community_list_unset_vty (vty, argc, argv, COMMUNITY_LIST_STANDARD);\n}\n\nDEFUN (no_ip_community_list_expanded,\n       no_ip_community_list_expanded_cmd,\n       \"no ip community-list <100-500> (deny|permit) .LINE\",\n       NO_STR\n       IP_STR\n       COMMUNITY_LIST_STR\n       \"Community list number (expanded)\\n\"\n       \"Specify community to reject\\n\"\n       \"Specify community to accept\\n\"\n       \"An ordered list as a regular-expression\\n\")\n{\n  return community_list_unset_vty (vty, argc, argv, COMMUNITY_LIST_EXPANDED);\n}\n\nDEFUN (no_ip_community_list_name_standard,\n       no_ip_community_list_name_standard_cmd,\n       \"no ip community-list standard WORD (deny|permit) .AA:NN\",\n       NO_STR\n       IP_STR\n       COMMUNITY_LIST_STR\n       \"Specify a standard community-list\\n\"\n       \"Community list name\\n\"\n       \"Specify community to reject\\n\"\n       \"Specify community to accept\\n\"\n       COMMUNITY_VAL_STR)\n{\n  return community_list_unset_vty (vty, argc, argv, COMMUNITY_LIST_STANDARD);\n}\n\nDEFUN (no_ip_community_list_name_expanded,\n       no_ip_community_list_name_expanded_cmd,\n       \"no ip community-list expanded WORD (deny|permit) .LINE\",\n       NO_STR\n       IP_STR\n       COMMUNITY_LIST_STR\n       \"Specify an expanded community-list\\n\"\n       \"Community list name\\n\"\n       \"Specify community to reject\\n\"\n       \"Specify community to accept\\n\"\n       \"An ordered list as a regular-expression\\n\")\n{\n  return community_list_unset_vty (vty, argc, argv, COMMUNITY_LIST_EXPANDED);\n}\n\nstatic void\ncommunity_list_show (struct vty *vty, struct community_list *list)\n{\n  struct community_entry *entry;\n\n  for (entry = list->head; entry; entry = entry->next)\n    {\n      if (entry == list->head)\n\t{\n\t  if (all_digit (list->name))\n\t    vty_out (vty, \"Community %s list %s%s\",\n\t\t     entry->style == COMMUNITY_LIST_STANDARD ?\n\t\t     \"standard\" : \"(expanded) access\",\n\t\t     list->name, VTY_NEWLINE);\n\t  else\n\t    vty_out (vty, \"Named Community %s list %s%s\",\n\t\t     entry->style == COMMUNITY_LIST_STANDARD ?\n\t\t     \"standard\" : \"expanded\",\n\t\t     list->name, VTY_NEWLINE);\n\t}\n      if (entry->any)\n\tvty_out (vty, \"    %s%s\",\n\t\t community_direct_str (entry->direct), VTY_NEWLINE);\n      else\n\tvty_out (vty, \"    %s %s%s\",\n\t\t community_direct_str (entry->direct),\n\t\t entry->style == COMMUNITY_LIST_STANDARD\n\t\t ? community_str (entry->u.com) : entry->config,\n\t\t VTY_NEWLINE);\n    }\n}\n\nDEFUN (show_ip_community_list,\n       show_ip_community_list_cmd,\n       \"show ip community-list\",\n       SHOW_STR\n       IP_STR\n       \"List community-list\\n\")\n{\n  struct community_list *list;\n  struct community_list_master *cm;\n\n  cm = community_list_master_lookup (bgp_clist, COMMUNITY_LIST_MASTER);\n  if (! cm)\n    return CMD_SUCCESS;\n\n  for (list = cm->num.head; list; list = list->next)\n    community_list_show (vty, list);\n\n  for (list = cm->str.head; list; list = list->next)\n    community_list_show (vty, list);\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (show_ip_community_list_arg,\n       show_ip_community_list_arg_cmd,\n       \"show ip community-list (<1-500>|WORD)\",\n       SHOW_STR\n       IP_STR\n       \"List community-list\\n\"\n       \"Community-list number\\n\"\n       \"Community-list name\\n\")\n{\n  struct community_list *list;\n\n  list = community_list_lookup (bgp_clist, argv[0], COMMUNITY_LIST_MASTER);\n  if (! list)\n    {\n      vty_out (vty, \"%% Can't find communit-list%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  community_list_show (vty, list);\n\n  return CMD_SUCCESS;\n}\n\f\nstatic int\nextcommunity_list_set_vty (struct vty *vty, int argc, const char **argv, \n                           int style, int reject_all_digit_name)\n{\n  int ret;\n  int direct;\n  char *str;\n\n  /* Check the list type. */\n  if (strncmp (argv[1], \"p\", 1) == 0)\n    direct = COMMUNITY_PERMIT;\n  else if (strncmp (argv[1], \"d\", 1) == 0)\n    direct = COMMUNITY_DENY;\n  else\n    {\n      vty_out (vty, \"%% Matching condition must be permit or deny%s\",\n\t       VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  /* All digit name check.  */\n  if (reject_all_digit_name && all_digit (argv[0]))\n    {\n      vty_out (vty, \"%% Community name cannot have all digits%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  /* Concat community string argument.  */\n  if (argc > 1)\n    str = argv_concat (argv, argc, 2);\n  else\n    str = NULL;\n\n  ret = extcommunity_list_set (bgp_clist, argv[0], str, direct, style);\n\n  /* Free temporary community list string allocated by\n     argv_concat().  */\n  if (str)\n    XFREE (MTYPE_TMP, str);\n\n  if (ret < 0)\n    {\n      community_list_perror (vty, ret);\n      return CMD_WARNING;\n    }\n  return CMD_SUCCESS;\n}\n\nstatic int\nextcommunity_list_unset_vty (struct vty *vty, int argc, const char **argv,\n\t\t\t     int style)\n{\n  int ret;\n  int direct = 0;\n  char *str = NULL;\n\n  if (argc > 1)\n    {\n      /* Check the list direct. */\n      if (strncmp (argv[1], \"p\", 1) == 0)\n\tdirect = COMMUNITY_PERMIT;\n      else if (strncmp (argv[1], \"d\", 1) == 0)\n\tdirect = COMMUNITY_DENY;\n      else\n\t{\n\t  vty_out (vty, \"%% Matching condition must be permit or deny%s\",\n\t\t   VTY_NEWLINE);\n\t  return CMD_WARNING;\n\t}\n\n      /* Concat community string argument.  */\n      str = argv_concat (argv, argc, 2);\n    }\n\n  /* Unset community list.  */\n  ret = extcommunity_list_unset (bgp_clist, argv[0], str, direct, style);\n\n  /* Free temporary community list string allocated by\n     argv_concat().  */\n  if (str)\n    XFREE (MTYPE_TMP, str);\n\n  if (ret < 0)\n    {\n      community_list_perror (vty, ret);\n      return CMD_WARNING;\n    }\n\n  return CMD_SUCCESS;\n}\n\n/* \"extcommunity-list\" keyword help string.  */\n#define EXTCOMMUNITY_LIST_STR \"Add a extended community list entry\\n\"\n#define EXTCOMMUNITY_VAL_STR  \"Extended community attribute in 'rt aa:nn_or_IPaddr:nn' OR 'soo aa:nn_or_IPaddr:nn' format\\n\"\n\nDEFUN (ip_extcommunity_list_standard,\n       ip_extcommunity_list_standard_cmd,\n       \"ip extcommunity-list <1-99> (deny|permit) .AA:NN\",\n       IP_STR\n       EXTCOMMUNITY_LIST_STR\n       \"Extended Community list number (standard)\\n\"\n       \"Specify community to reject\\n\"\n       \"Specify community to accept\\n\"\n       EXTCOMMUNITY_VAL_STR)\n{\n  return extcommunity_list_set_vty (vty, argc, argv, EXTCOMMUNITY_LIST_STANDARD, 0);\n}\n\nALIAS (ip_extcommunity_list_standard,\n       ip_extcommunity_list_standard2_cmd,\n       \"ip extcommunity-list <1-99> (deny|permit)\",\n       IP_STR\n       EXTCOMMUNITY_LIST_STR\n       \"Extended Community list number (standard)\\n\"\n       \"Specify community to reject\\n\"\n       \"Specify community to accept\\n\")\n\nDEFUN (ip_extcommunity_list_expanded,\n       ip_extcommunity_list_expanded_cmd,\n       \"ip extcommunity-list <100-500> (deny|permit) .LINE\",\n       IP_STR\n       EXTCOMMUNITY_LIST_STR\n       \"Extended Community list number (expanded)\\n\"\n       \"Specify community to reject\\n\"\n       \"Specify community to accept\\n\"\n       \"An ordered list as a regular-expression\\n\")\n{\n  return extcommunity_list_set_vty (vty, argc, argv, EXTCOMMUNITY_LIST_EXPANDED, 0);\n}\n\nDEFUN (ip_extcommunity_list_name_standard,\n       ip_extcommunity_list_name_standard_cmd,\n       \"ip extcommunity-list standard WORD (deny|permit) .AA:NN\",\n       IP_STR\n       EXTCOMMUNITY_LIST_STR\n       \"Specify standard extcommunity-list\\n\"\n       \"Extended Community list name\\n\"\n       \"Specify community to reject\\n\"\n       \"Specify community to accept\\n\"\n       EXTCOMMUNITY_VAL_STR)\n{\n  return extcommunity_list_set_vty (vty, argc, argv, EXTCOMMUNITY_LIST_STANDARD, 1);\n}\n\nALIAS (ip_extcommunity_list_name_standard,\n       ip_extcommunity_list_name_standard2_cmd,\n       \"ip extcommunity-list standard WORD (deny|permit)\",\n       IP_STR\n       EXTCOMMUNITY_LIST_STR\n       \"Specify standard extcommunity-list\\n\"\n       \"Extended Community list name\\n\"\n       \"Specify community to reject\\n\"\n       \"Specify community to accept\\n\")\n\nDEFUN (ip_extcommunity_list_name_expanded,\n       ip_extcommunity_list_name_expanded_cmd,\n       \"ip extcommunity-list expanded WORD (deny|permit) .LINE\",\n       IP_STR\n       EXTCOMMUNITY_LIST_STR\n       \"Specify expanded extcommunity-list\\n\"\n       \"Extended Community list name\\n\"\n       \"Specify community to reject\\n\"\n       \"Specify community to accept\\n\"\n       \"An ordered list as a regular-expression\\n\")\n{\n  return extcommunity_list_set_vty (vty, argc, argv, EXTCOMMUNITY_LIST_EXPANDED, 1);\n}\n\nDEFUN (no_ip_extcommunity_list_standard_all,\n       no_ip_extcommunity_list_standard_all_cmd,\n       \"no ip extcommunity-list <1-99>\",\n       NO_STR\n       IP_STR\n       EXTCOMMUNITY_LIST_STR\n       \"Extended Community list number (standard)\\n\")\n{\n  return extcommunity_list_unset_vty (vty, argc, argv, EXTCOMMUNITY_LIST_STANDARD);\n}\n\nDEFUN (no_ip_extcommunity_list_expanded_all,\n       no_ip_extcommunity_list_expanded_all_cmd,\n       \"no ip extcommunity-list <100-500>\",\n       NO_STR\n       IP_STR\n       EXTCOMMUNITY_LIST_STR\n       \"Extended Community list number (expanded)\\n\")\n{\n  return extcommunity_list_unset_vty (vty, argc, argv, EXTCOMMUNITY_LIST_EXPANDED);\n}\n\nDEFUN (no_ip_extcommunity_list_name_standard_all,\n       no_ip_extcommunity_list_name_standard_all_cmd,\n       \"no ip extcommunity-list standard WORD\",\n       NO_STR\n       IP_STR\n       EXTCOMMUNITY_LIST_STR\n       \"Specify standard extcommunity-list\\n\"\n       \"Extended Community list name\\n\")\n{\n  return extcommunity_list_unset_vty (vty, argc, argv, EXTCOMMUNITY_LIST_STANDARD);\n}\n\nDEFUN (no_ip_extcommunity_list_name_expanded_all,\n       no_ip_extcommunity_list_name_expanded_all_cmd,\n       \"no ip extcommunity-list expanded WORD\",\n       NO_STR\n       IP_STR\n       EXTCOMMUNITY_LIST_STR\n       \"Specify expanded extcommunity-list\\n\"\n       \"Extended Community list name\\n\")\n{\n  return extcommunity_list_unset_vty (vty, argc, argv, EXTCOMMUNITY_LIST_EXPANDED);\n}\n\nDEFUN (no_ip_extcommunity_list_standard,\n       no_ip_extcommunity_list_standard_cmd,\n       \"no ip extcommunity-list <1-99> (deny|permit) .AA:NN\",\n       NO_STR\n       IP_STR\n       EXTCOMMUNITY_LIST_STR\n       \"Extended Community list number (standard)\\n\"\n       \"Specify community to reject\\n\"\n       \"Specify community to accept\\n\"\n       EXTCOMMUNITY_VAL_STR)\n{\n  return extcommunity_list_unset_vty (vty, argc, argv, EXTCOMMUNITY_LIST_STANDARD);\n}\n\nDEFUN (no_ip_extcommunity_list_expanded,\n       no_ip_extcommunity_list_expanded_cmd,\n       \"no ip extcommunity-list <100-500> (deny|permit) .LINE\",\n       NO_STR\n       IP_STR\n       EXTCOMMUNITY_LIST_STR\n       \"Extended Community list number (expanded)\\n\"\n       \"Specify community to reject\\n\"\n       \"Specify community to accept\\n\"\n       \"An ordered list as a regular-expression\\n\")\n{\n  return extcommunity_list_unset_vty (vty, argc, argv, EXTCOMMUNITY_LIST_EXPANDED);\n}\n\nDEFUN (no_ip_extcommunity_list_name_standard,\n       no_ip_extcommunity_list_name_standard_cmd,\n       \"no ip extcommunity-list standard WORD (deny|permit) .AA:NN\",\n       NO_STR\n       IP_STR\n       EXTCOMMUNITY_LIST_STR\n       \"Specify standard extcommunity-list\\n\"\n       \"Extended Community list name\\n\"\n       \"Specify community to reject\\n\"\n       \"Specify community to accept\\n\"\n       EXTCOMMUNITY_VAL_STR)\n{\n  return extcommunity_list_unset_vty (vty, argc, argv, EXTCOMMUNITY_LIST_STANDARD);\n}\n\nDEFUN (no_ip_extcommunity_list_name_expanded,\n       no_ip_extcommunity_list_name_expanded_cmd,\n       \"no ip extcommunity-list expanded WORD (deny|permit) .LINE\",\n       NO_STR\n       IP_STR\n       EXTCOMMUNITY_LIST_STR\n       \"Specify expanded extcommunity-list\\n\"\n       \"Community list name\\n\"\n       \"Specify community to reject\\n\"\n       \"Specify community to accept\\n\"\n       \"An ordered list as a regular-expression\\n\")\n{\n  return extcommunity_list_unset_vty (vty, argc, argv, EXTCOMMUNITY_LIST_EXPANDED);\n}\n\nstatic void\nextcommunity_list_show (struct vty *vty, struct community_list *list)\n{\n  struct community_entry *entry;\n\n  for (entry = list->head; entry; entry = entry->next)\n    {\n      if (entry == list->head)\n\t{\n\t  if (all_digit (list->name))\n\t    vty_out (vty, \"Extended community %s list %s%s\",\n\t\t     entry->style == EXTCOMMUNITY_LIST_STANDARD ?\n\t\t     \"standard\" : \"(expanded) access\",\n\t\t     list->name, VTY_NEWLINE);\n\t  else\n\t    vty_out (vty, \"Named extended community %s list %s%s\",\n\t\t     entry->style == EXTCOMMUNITY_LIST_STANDARD ?\n\t\t     \"standard\" : \"expanded\",\n\t\t     list->name, VTY_NEWLINE);\n\t}\n      if (entry->any)\n\tvty_out (vty, \"    %s%s\",\n\t\t community_direct_str (entry->direct), VTY_NEWLINE);\n      else\n\tvty_out (vty, \"    %s %s%s\",\n\t\t community_direct_str (entry->direct),\n\t\t entry->style == EXTCOMMUNITY_LIST_STANDARD ?\n\t\t entry->u.ecom->str : entry->config,\n\t\t VTY_NEWLINE);\n    }\n}\n\nDEFUN (show_ip_extcommunity_list,\n       show_ip_extcommunity_list_cmd,\n       \"show ip extcommunity-list\",\n       SHOW_STR\n       IP_STR\n       \"List extended-community list\\n\")\n{\n  struct community_list *list;\n  struct community_list_master *cm;\n\n  cm = community_list_master_lookup (bgp_clist, EXTCOMMUNITY_LIST_MASTER);\n  if (! cm)\n    return CMD_SUCCESS;\n\n  for (list = cm->num.head; list; list = list->next)\n    extcommunity_list_show (vty, list);\n\n  for (list = cm->str.head; list; list = list->next)\n    extcommunity_list_show (vty, list);\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (show_ip_extcommunity_list_arg,\n       show_ip_extcommunity_list_arg_cmd,\n       \"show ip extcommunity-list (<1-500>|WORD)\",\n       SHOW_STR\n       IP_STR\n       \"List extended-community list\\n\"\n       \"Extcommunity-list number\\n\"\n       \"Extcommunity-list name\\n\")\n{\n  struct community_list *list;\n\n  list = community_list_lookup (bgp_clist, argv[0], EXTCOMMUNITY_LIST_MASTER);\n  if (! list)\n    {\n      vty_out (vty, \"%% Can't find extcommunit-list%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  extcommunity_list_show (vty, list);\n\n  return CMD_SUCCESS;\n}\n\f\n/* Return configuration string of community-list entry.  */\nstatic const char *\ncommunity_list_config_str (struct community_entry *entry)\n{\n  const char *str;\n\n  if (entry->any)\n    str = \"\";\n  else\n    {\n      if (entry->style == COMMUNITY_LIST_STANDARD)\n\tstr = community_str (entry->u.com);\n      else\n\tstr = entry->config;\n    }\n  return str;\n}\n\n/* Display community-list and extcommunity-list configuration.  */\nstatic int\ncommunity_list_config_write (struct vty *vty)\n{\n  struct community_list *list;\n  struct community_entry *entry;\n  struct community_list_master *cm;\n  int write = 0;\n\n  /* Community-list.  */\n  cm = community_list_master_lookup (bgp_clist, COMMUNITY_LIST_MASTER);\n\n  for (list = cm->num.head; list; list = list->next)\n    for (entry = list->head; entry; entry = entry->next)\n      {\n\tvty_out (vty, \"ip community-list %s %s %s%s\",\n\t\t list->name, community_direct_str (entry->direct),\n\t\t community_list_config_str (entry),\n\t\t VTY_NEWLINE);\n\twrite++;\n      }\n  for (list = cm->str.head; list; list = list->next)\n    for (entry = list->head; entry; entry = entry->next)\n      {\n\tvty_out (vty, \"ip community-list %s %s %s %s%s\",\n\t\t entry->style == COMMUNITY_LIST_STANDARD\n\t\t ? \"standard\" : \"expanded\",\n\t\t list->name, community_direct_str (entry->direct),\n\t\t community_list_config_str (entry),\n\t\t VTY_NEWLINE);\n\twrite++;\n      }\n\n  /* Extcommunity-list.  */\n  cm = community_list_master_lookup (bgp_clist, EXTCOMMUNITY_LIST_MASTER);\n\n  for (list = cm->num.head; list; list = list->next)\n    for (entry = list->head; entry; entry = entry->next)\n      {\n\tvty_out (vty, \"ip extcommunity-list %s %s %s%s\",\n\t\t list->name, community_direct_str (entry->direct),\n\t\t community_list_config_str (entry), VTY_NEWLINE);\n\twrite++;\n      }\n  for (list = cm->str.head; list; list = list->next)\n    for (entry = list->head; entry; entry = entry->next)\n      {\n\tvty_out (vty, \"ip extcommunity-list %s %s %s %s%s\",\n\t\t entry->style == EXTCOMMUNITY_LIST_STANDARD\n\t\t ? \"standard\" : \"expanded\",\n\t\t list->name, community_direct_str (entry->direct),\n\t\t community_list_config_str (entry), VTY_NEWLINE);\n\twrite++;\n      }\n  return write;\n}\n\nstruct cmd_node community_list_node =\n{\n  COMMUNITY_LIST_NODE,\n  \"\",\n  1\t\t\t\t/* Export to vtysh.  */\n};\n\nstatic void\ncommunity_list_vty (void)\n{\n  install_node (&community_list_node, community_list_config_write);\n\n  /* Community-list.  */\n  install_element (CONFIG_NODE, &ip_community_list_standard_cmd);\n  install_element (CONFIG_NODE, &ip_community_list_standard2_cmd);\n  install_element (CONFIG_NODE, &ip_community_list_expanded_cmd);\n  install_element (CONFIG_NODE, &ip_community_list_name_standard_cmd);\n  install_element (CONFIG_NODE, &ip_community_list_name_standard2_cmd);\n  install_element (CONFIG_NODE, &ip_community_list_name_expanded_cmd);\n  install_element (CONFIG_NODE, &no_ip_community_list_standard_all_cmd);\n  install_element (CONFIG_NODE, &no_ip_community_list_expanded_all_cmd);\n  install_element (CONFIG_NODE, &no_ip_community_list_name_standard_all_cmd);\n  install_element (CONFIG_NODE, &no_ip_community_list_name_expanded_all_cmd);\n  install_element (CONFIG_NODE, &no_ip_community_list_standard_cmd);\n  install_element (CONFIG_NODE, &no_ip_community_list_expanded_cmd);\n  install_element (CONFIG_NODE, &no_ip_community_list_name_standard_cmd);\n  install_element (CONFIG_NODE, &no_ip_community_list_name_expanded_cmd);\n  install_element (VIEW_NODE, &show_ip_community_list_cmd);\n  install_element (VIEW_NODE, &show_ip_community_list_arg_cmd);\n  install_element (ENABLE_NODE, &show_ip_community_list_cmd);\n  install_element (ENABLE_NODE, &show_ip_community_list_arg_cmd);\n\n  /* Extcommunity-list.  */\n  install_element (CONFIG_NODE, &ip_extcommunity_list_standard_cmd);\n  install_element (CONFIG_NODE, &ip_extcommunity_list_standard2_cmd);\n  install_element (CONFIG_NODE, &ip_extcommunity_list_expanded_cmd);\n  install_element (CONFIG_NODE, &ip_extcommunity_list_name_standard_cmd);\n  install_element (CONFIG_NODE, &ip_extcommunity_list_name_standard2_cmd);\n  install_element (CONFIG_NODE, &ip_extcommunity_list_name_expanded_cmd);\n  install_element (CONFIG_NODE, &no_ip_extcommunity_list_standard_all_cmd);\n  install_element (CONFIG_NODE, &no_ip_extcommunity_list_expanded_all_cmd);\n  install_element (CONFIG_NODE, &no_ip_extcommunity_list_name_standard_all_cmd);\n  install_element (CONFIG_NODE, &no_ip_extcommunity_list_name_expanded_all_cmd);\n  install_element (CONFIG_NODE, &no_ip_extcommunity_list_standard_cmd);\n  install_element (CONFIG_NODE, &no_ip_extcommunity_list_expanded_cmd);\n  install_element (CONFIG_NODE, &no_ip_extcommunity_list_name_standard_cmd);\n  install_element (CONFIG_NODE, &no_ip_extcommunity_list_name_expanded_cmd);\n  install_element (VIEW_NODE, &show_ip_extcommunity_list_cmd);\n  install_element (VIEW_NODE, &show_ip_extcommunity_list_arg_cmd);\n  install_element (ENABLE_NODE, &show_ip_extcommunity_list_cmd);\n  install_element (ENABLE_NODE, &show_ip_extcommunity_list_arg_cmd);\n}\n", "2007-07-26  Paul Jakma <paul.jakma@sun.com>\n\n\t* log.c: (mes_lookup) warning about code not being in same-number\n\t  array slot should be debug, not warning. E.g. BGP has several\n\t  discontigious number spaces, allocating from different parts of a\n\t  space is not uncommon (e.g. IANA assigned versus vendor-assigned\n\t  code points in some number space).\n\t  \n2007-07-06 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* sockopt.{c,h}: (setsockopt_multicast_ipv4) Add some comments about\n\t  the arguments.\n\n2007-06-01 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* zebra.h: On linux, we seem to need to include <linux/types.h> before\n\t  <sys/sysctl.h>, otherwise we get isisd compilation errors about\n\t  __be16 not being defined.\n\n2007-05-10 Paul Jakma <paul.jakma@sun.com>\n\n\t* zebra.h: Don't try define _GNU_SOURCE, autoconf should do it.\n\n2007-05-03 Paul Jakma <paul.jakma@sun.com>\n\n\t* memtypes.c: Add MTYPE_ATTR_EXTRA and MTYPE_BGP_ROUTE_EXTRA\n\n2007-05-01 David L Stevens <dlstevens@us.ibm.com>\n\n\t* (general) These changes collectively add route-map and\n\t  prefix-list support to zebra and fix a bug in \"show\n\t  route-map\" (with no argument).\n\t* command.h: added PROTOCOL_NODE type\n\t* log.c: (proto_name2num) new function, protocol name to\n\t  number translation.\n\t* routemap.c: (vty_show_route_map) fixed \"show route-map\"\n\t  without route-map name\n\t* routemap.h: added RMAP_ZEBRA type\n\t* zebra.h: added proto_name2num() prototype\n\n2007-04-29 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* log.c: (quagga_timestamp) Optimize the subsecond timestamp generation.\n\n2007-04-28 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* command.c: (config_write_host) Save \"log timestamp precision\"\n\t  if not default value.\n\t  (show_logging) Show configured timestamp precision.\n\t  (config_log_timestamp_precision) Enable configuration of timestamp\n\t  precision.\n\t  (no_config_log_timestamp_precision) Restore default timestamp\n\t  precision.\n\t  (cmd_init) Install new timestamp precision commands.\n\t* log.h: (struct zlog) New timestamp_precision field.\n\t  (quagga_timestamp) New function to generate a timestamp with the\n\t  desired precision.\n\t  (struct timestamp_control) Declare a structure for use in avoiding\n\t  repeated duplicate calls to quagga_timestamp.\n\t* log.c: (quagga_timestamp) New function to generate a timestamp\n\t  of the desired precision.\n\t  (time_print) Call quagga_timestamp if the time hasn't already been\n\t  calculated.\n\t  (vzlog) Initialize a timestamp_control structure and pass it to\n\t  time_print and vty_log.\n\t  (zlog_backtrace) Fix 64-bit problem: cannot print size_t with %u.\n\t* vty.h: Must now include \"log.h\".\n\t  (vty_log) Takes an additional struct timestamp_control argument.\n\t* vty.c: (vty_log_out) Use new struct timestamp_control and new\n\t  quagga_timestamp function to print timestamps of the desired\n\t  precision.\n\t  (vty_time_print) Use new quagga_timestamp function.\n\t  (vty_log) Accept new struct timestamp_control argument and pass it\n\t  down to vty_log_out.\n\n2007-04-27 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* smux.c: (smux_trap) Fix printf format to work with 64-bit size_t.\n\n2007-04-07 Paul Jakma <paul.jakma@sun.com>\n\n\t* prefix.h: Add define to match IPv4 Link-Local addresses\n\n2007-03-20 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* log.c: (mes_lookup) Make the function more robust: check for\n\t  cases where the index does not match the key value at that position.\n\t  If so, give a warning and fall back to a linear search.\n\t  And improve the error message in cases where even that fails.\n\n2006-12-12 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* if.h: (struct connected) Add new ZEBRA_IFA_PEER flag indicating\n\t  whether a peer address has been configured.  Comment now shows\n\t  the new interpretation of the destination addr: if ZEBRA_IFA_PEER\n\t  is set, then it must contain the destination address, otherwise\n\t  it may contain the broadcast address or be NULL.\n\t  (CONNECTED_DEST_HOST,CONNECTED_POINTOPOINT_HOST) Remove obsolete\n\t  macros that were specific to IPv4 and not fully general.\n\t  (CONNECTED_PEER) New macro to check ZEBRA_IFA_PEER flag.\n\t  (CONNECTED_PREFIX) New macro giving the prefix to insert into\n\t  the RIB: if CONNECTED_PEER, then use the destination (peer) address,\n\t  else use the address field.\n\t  (CONNECTED_ID) New macro to come up with an identifying address\n\t  for the struct connected.\n\t* if.c: (if_lookup_address, connected_lookup_address) Streamline\n\t  logic with new CONNECTED_PREFIX macro.\n\t* prefix.h: (PREFIX_COPY_IPV4, PREFIX_COPY_IPV6) New macros\n\t  for better performance than the general prefix_copy function.\n\t* zclient.c: (zebra_interface_address_read) For non-null destination\n\t  addresses, set prefixlen to equal the address prefixlen.  This\n\t  is needed to get the new CONNECTED_PREFIX macro to work properly.\n\n2006-10-14 Paul Jakma <paul.jakma@sun.com>\n\n\t* if.c: (general) Handle upgrades from SUNWzebra, which tried\n\t  to track each logical interface as a seperate struct\n\t  interface, to Quagga, which assigns only one struct interface\n\t  per ifindex.\n\t  (if_sunwzebra_get) Try decompose a logical interface name\n          (fooX:Y) to the 'primary' name (fooX), for Solaris.\n          (interface_cmd) Use if_sunwzebra_get on Solaris.\n\n2006-09-26 Pierre-Yves Ritschard <pierre-yves@spootnik.org>\n\n\t* smux.c: (smux_open,smux_trap,smux_register) Fix various\n\t  asn_build_* calls to pass the proper length in the final\n\t  argument: use sizeof(<variable>) instead of sizeof(<type>),\n\t  since there were several inconsistencies between the actual\n\t  variable type and the size that was passed.  This should\n\t  fix some problems on 64-bit architectures where sizeof(int)\n\t  != sizeof(long).\n\n2006-08-25 Paul Jakma <paul.jakma@sun.com>\n\n\t* thread.c: (general) Add support for monotonic clock, it may still\n\t  jump forward by huge amounts, but should be immune to going\n\t  backwards. Fixes bug #134.\n\t  (quagga_gettimeofday_relative_adjust) helper, does what name\n\t  says - adjusts gettimeofday based relative timer.\n\t  (quagga_gettimeofday) helper to keep recent_time up to date.\n\t  (quagga_get_relative) helper, update and getch the relative\n\t  timer using gettimeofday(). POSIX CLOCK_MONOTONIC is also\n\t  supported, but the code is not enabled yet nor tested.\n\t  (quagga_real_stabilised) helper, retrieve absolute time but\n\t  stabilised so as to never decrease.\n\t  (quagga_gettime) Exported interface, analogous to POSIX\n\t  clock_gettime() in interface, supporting several clocks.\n\t  (quagga_time) Exported interface, analogous to traditional\n\t  time(), will never decrease.\n\t  (recent_relative_time) Convenience function to retrieve\n\t  relative_time timeval, similar to existing recent_time absolute\n\t  timeval, for when an approximately recent value will do.\n\t  (remainder) Update to use above helpers.\n\t  (thread_getrusage) Previously was a macro, but needs to be\n\t  a function to twiddle with thread.c private stuff.\n\t* thread.c: Point the GETRUSAGE macro at previous function.\n\t  Export quagga_gettime, quagga_time and recent_relative_time for \n\t  general use.\n\n2006-07-25 Paul Jakma <paul.jakma@sun.com>\n\n\t* thread.h: (struct thread) Add a cache pointer to the struct\n\t  cpu_thread_history, if it is known - saving hash lookup on\n\t  each thread_call.\n\t* thread.c: (thread_call) Cache the pointer to the\n          cpu_thread_history, so that future thread_calls of same\n          thread can avoid the hash_lookup.\n\n2006-07-10 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* vty.c: (vty_log_out) Do not call vty_close, because this could\n\t  result in a parent function's accessing the freed memory.\n\t  Instead, set status VTY_CLOSE and call shutdown(vty->fd, SHUT_RDWR).\n\t  And add a comment on vty_close.\n\n2006-07-10 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* vty.c: (vty_log_out, vty_read, vty_flush, vtysh_flush, vtysh_read)\n\t  After an I/O error, must set vty->monitor to 0 before calling\n\t  zlog_warn, otherwise an infinite recursion could occur\n\t  (since zlog_warn triggers a message to be written to the vty,\n\t  and that in turn triggers another error message when it fails, etc.).\n\n2006-07-03 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* vty.c: (vty_log_out) Debug messages to terminal vty sessions\n\t  should include timestamps.\n\n2006-06-28 Paul Jakma <paul.jakma@sun.com>\n\n\t* memory.c: Fix typo in cpp conditional around malloc.h, from\n\t  comment in bug #269.\n\n2006-06-27 Paul Jakma <paul.jakma@sun.com>\n\n\t* route_types.awk: Remove setting the 'bare' numeric route type\n\t  in redist strings.\n\n2006-06-15 Paul Jakma <paul.jakma@sun.com>\n\n\t* command.c: (cmd_describe_command_real) Fix leak, CID #38.\n\t* memory.h: Experimental, have XFREE macro NULL out the freed\n\t  pointer.\n\t* linklist.c: (list_delete) call list_delete_all_node, don't\n\t  duplicate it.\n\t* if.c: (if_flag_dump) remove the whitespace indentation, callers\n\t  should provide.\n\n2006-05-28 Paul Jakma <paul.jakma@sun.com>\n\n\t* zebra.h: Include inttypes.h rather than stdint.h, best practice\n\t  according to the autoconf manual.\n\t  Add UINT*_MAX defines for older platforms lacking these (FBSD 4)\n\t* memory.c: malloc.h is deprecated in favour of stdlib.h, however\n\t  we still need it on GNU Libc for mallinfo().\n\t* vty.c: (vty_log/vty_log_fixed) dont crash if called when vty\n\t  hasn't been initiliased.\n\t* log.c: (general) Add support for Sun libc printstack().\n\t  (hex_append) make the cpp conditional on general HAVE_STACK_TRACE\n\t  define.\n\t  (zlog_backtrace_sigsafe) Ditto. Add printstack() version of the\n\t  the DUMP macro in this function.\n\n2006-05-23 Paul Jakma <paul.jakma@sun.com>\n\n\t* route_types.txt: New file, table of ZEBRA_ROUTE definitions.\n\t* route_types.awk: New script, to parse previous and generate\n\t  (for now) redistribute string defines.\n\t* Makefile.am: build route_types.h using previous two, ala\n\t  memtypes.h, include the script and table file in EXTRA_DIST.\n\t* command.h: pull in route_types.h, add a REDIST_STR define.\n\n2006-05-21 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* if.h: (struct connected) Document the meaning of the\n\t  ZEBRA_IFC_REAL and ZEBRA_IFC_CONFIGURED flags.\n\n2006-05-15 Paul Jakma <paul.jakma@sun.com>\n\n\t* log.c: (general) Generalise struct zebra_route_desc into\n\t  struct zebra_desc_table and, similar to route_types, add a\n\t  command_types table to describe Zserv protocol commands.\n\t  (route_types[]) use a macro to use designated initialisers\n\t  while avoiding tedious duplication.\n\t  (zserv_command_string) lookup string from zebra_desc_table,\n\t  similar to zebra_route_string\n\t* zebra.h: Add declaration for zserv_command_string, adjust the\n\t  comments to reflect zebra_desc_table.\n\n2006-05-13 Paul Jakma <paul.jakma@sun.com>\n\n\t* vty.c: (vty_describe_command) CID #39 fix was too hasty, just\n\t  cause it /can/ leak doesn't mean it always will have, check\n\t  first.\n\n2006-05-12 Paul Jakma <paul.jakma@sun.com>\n\n\t* plist.c: (vty_prefix_list_uninstall) Fix potential NULL deref\n\t  of prefix and typestr strings, Coverity CID #3.\n\t* command.c: (cmd_complete_command_real) Fix leak of cmd_vector\n\t  in error case, Coverity CID #37.\n\t  (cmd_describe_command_real) Fix return of freed pointer when\n\t  no-match, CID #55.\n\t* vty.c: (vty_describe_command) fix leak of describe vector in\n\t  error path, CID #39.\n\n2006-03-30 Paul Jakma <paul.jakma@sun.com>\n\n\t* command.h: (DEFUN_CMD_FUNC_TEXT) Annotate arguments as\n\t  potentially being unused.\n\t* workqueue.c: (work_queue_run) fix line length of comment\n\n2006-03-27 Paul Jakma <paul.jakma@sun.com>\n\n\t* memtypes.awk: Fix gensub call, g should be a string..\n\n2006-03-25 Paul Jakma <paul.jakma@sun.com>\n\n\t* workqueue.h: (struct work_queue) Remove status field and\n\t  state flag, no longer used.\n\n2006-03-19 Paul Jakma <paul.jakma@sun.com>\n\n\t* memtypes.c: Add MTYPE_BGP_SYNCHRONISE.\n\n2006-03-16 Paul Jakma <paul.jakma@sun.com>\n\n\t* Makefile.am: Fix -version-info argument.\n\n2006-03-15 Paul Jakma <paul.jakma@sun.com>\n\n\t* memory.c: (mtype_memstr) new helper function to \n\t  return human friendly string for a byte count.\n\t  (mtype_stats_alloc) new function, for users to retrieve\n\t  number of objects allocated.\n\t  (show_memory_mallinfo) New function, show mallinfo statistics\n\t  if available.\n\t  (show_memory_all_cmd) Call show_memory_mallinfo, if mallinfo\n\t  is available.\n\t* memory.h: Export mtype_memstr and mtype_stats_alloc.\n\t  Provide a define for a reasonable buffer size for\n\t  mtype_memstr.\n\t  \n2006-03-14 Paul Jakma <paul.jakma@sun.com>\n\n\t* privs.c: (zprivs_caps_init) Change user IDs before lowering\n\t  privileges, while this seems to work on Linux, on Solaris\n\t  it rightfully refuses due to PRIV_PROC_SETID having been\n\t  dropped.\n\t* command.h: Add the struct host global exported from command.c\n\n2006-03-06 Paul Jakma <paul.jakma@sun.com>\n\n\t* if.h: export show_address_cmd, for anyone who wishes to use\n\t  it.\n\n2006-02-21 Paul Jakma <paul.jakma@sun.com>\n\n\t* sockunion.c: (sockunion_{su2str,log}) Use XSTRDUP.\n\t  Particularly with _su2str, as that string gets XFREEd,\n\t  which can be annoying if run debug code in memory.c.\n\n2006-02-02 Paul Jakma <paul.jakma@sun.com>\n\n\t* workqueue.h: (struct work_queue) Remove the delay field.\n\t  It served no purpose and just introduced bad behaviour.\n\t  Should be excised before its allowed to escape into 1.0.\n\t  This removes need for the 'flood' and runs_since_clear\n\t  fields.\n\t* workqueue.c: (general) excise delay factor between queue\n\t  runs, hence the 'flood' crap too.. See above.\n\n2006-01-19 Paul Jakma <paul.jakma@sun.com>\n\n\t* stream.c: (stream_getq_from) should use POSIX uint64_t\n\t  not u_int64_t. Latter is neither a traditional BSD type, nor\n\t  a POSIX type.\n\n2006-01-17 Vincent Jardin <vincent.jardin@6wind.com>\n\n\t* md5.c: Don't forget to keep const.\n\t* regex.c: Cleanup code and remove warnings.\n\n2006-01-17 Paul Jakma <paul.jakma@sun.com>\n\n\t* md5.{c,h}: (md5_loop) Is better off taking a void * and doing\n\t  cast to byte wise type internally, avoids needs for casts \n\t  in users.\n\t* vty.c: (no_terminal_monitor_cmd) New ALIAS for \n\t  terminal_no_monitor, in the more normal negating format,\n\t  to be kind to my fingers.\n\t  (vty_init) install new ALIAS.\n\t* zclient.{c,h}: (zclient_create_header) export this, seems others\n\t  could use it (in lieu of more complete zserv helpers).\n\n2006-01-16 Paul Jakma <paul.jakma@sun.com>\n\n\t* zclient.h: Update the Zserv protocol header with a version\n\t  field.  Define the old command field to be a 'marker', to\n\t  allow old Zserv and updated Zserv to be differentiated.\n\t  Future updates will bump the version field obviously. New\n\t  command field is made wider.  Try to stop using the\n\t  'zebra_size_t' typedef in the callbacks.\n\t* zclient.c: Update to read/write new format header.\n\n2006-01-11 Paul Jakma <paul.jakma@sun.com>\n\n\t* if.h: (struct interface) expand flags to 8 bytes.\n\t* zclient.c: (zebra_interface_{add,state}_read) stream read of\n\t  interface flags now need to use stream_getq.\n\t  (zebra_interface_if_set_value) ditto\n\n2006-01-10 Paul Jakma <paul.jakma@sun.com>\n\n\t* stream.c: (stream_new) Allocate stream data as seperate object.\n\t  (stream_free) free the data.\n\t  (stream_resize) new function, resize stream to new size.\n\t  (stream_{get,put}q*) new functions to get/put quad word size\n\t  types.\n\t* stream.h: (struct stream) make data seperate from the stream.\n\t  Export new stream_resize and quad-word get/put functions.\n\t  \n2005-12-29  Greg Troxel  <gdt@fnord.ir.bbn.com>\n\n\t* vty.c (vty_hello): add cast to quiet lint (from David Young)\n\n2005-11-26 Paul Jakma <paul.jakma@sun.com>\n\n\t* buffer.c: (struct buffer_data) change gcc zero array\n\t  declaration to C99 incomplete array.\n\t* stream.h: (struct stream) same\n\n2005-11-24 Paul Jakma <paul.jakma@sun.com>\n\n\t* privs.c: (zcaps2sys/solaris) remove unused variable.\n\t  (zprivs_state_caps/solaris) Format string missing a\n\t  specifier.\n\t* zebra.h: s/u_int/unsigned int/, u_int is a BSD type, defining\n\t  __USE_BSD on Linux pulls in further things from netinet/ip.h\n\t  which dont preprocess for some reason. There is no C99\n\t  shorthand type directly equivalent to u_int afaict, so don't\n\t  use it.\n\n2005-11-14 Paul Jakma <paul.jakma@sun.com>\n\n\t* (general) pass struct work-queue to callback functions.\n\t* workqueue.h: (struct work_queue) move the state flag\n\t  variables to end.\n\t  Add an opaque pointer to spec, for user-data global to the\n\t  queue.\n\t  Pass reference to work_queue to all callbacks.\n\t* workqueue.c: (work_queue_item_remove) pass ref to workqueue\n\t  to user callbacks.\n\t  (work_queue_run) ditto.\n\n2005-11-14 Paul Jakma <paul.jakma@sun.com>\n\n\t* (general) Add state to detect queue floods.  There's no sense\n\t  trying to be sparing of CPU resources, if the queue is\n\t  flooding and using ever more memory resources. we should just\n\t  get on with clearing the queue.\n\t  The sense of delay and hold were wrong way around, fix.\n\t* workqueue.h: (struct work_queue) Add status bitfield.  Add\n\t  'flood' integer to workqueue spec.  Add runs_since_clear\n\t  counter to workqueue.\n\t* workqueue.c: (work_queue_new) set defaults for delay, hold\n\t  and flood.\n\t  (work_queue_add) initial schedule should use delay, not hold.\n\t  (show_work_queues) Print flood field, conserve whitespace.\n\t  (work_queue_unplug) use delay, not hold.\n\t  (work_queue_run) consecutive runs should be seperated by hold\n\t  time, not delay.\n\t  Keep track of number of consecutive runs, go into 'overdrive'\n\t  if queue is being flooded, we can't avoid making heavy use of \n\t  resources, better to use CPU than ever more RAM.\n\t* zebra.h: [bug #231] include stdint, if its there.\n\n2005-11-05 Paul Jakma <paul.jakma@sun.com>\n\n\t* routemap.c: (vty_show_route_map_entry) call action is\n\t  seperate from exit action, latter should still be printed\n\t  regardless of whether a call is specified.\n\n2005-11-03 Paul Jakma <paul.jakma@sun.com>\n\n\t* zebra.h: BSD BYTE_ORDER define isn't available everywhere,\n\t  define if needs be.\n\t* checksum.h: new file. checksum.c exports in_cksum, provide\n\t  a header for it.\n\t* checksum.c: (in_cksum) callers shouldn't have to know it uses\n\t  a u_short internally, change to void *.\n\t* Makefile.am: Add checksum.h\n\t* command.h: remove bogus trailling slash.\n\t* md5.c: (general) Update it for the twentieth century. ANSI\n\t  declarations are widely supported now.. Don't include system\n\t  headers, only include zebra.h. Use POSIX types (the\n\t  alternative is to define u_int64_t in a portable way - rest\n\t  of Quagga needs same cleanup).\n\t  Make endian-conditional code be compiler conditional rather\n\t  than preprocessor conditional, so that breakage gets noticed\n\t  quicker.\n\t* md5.h: POSIX types. Get rid of the odd __P() non-ANSI capable\n\t  compiler compatibility hack.\n\t* if.c: (connected_free) use MTYPE for connected label.\n\t* memtypes.c: Add MTYPE_CONNECTED_LABEL\n\t* memtypes.h: Update auto-built file.\n\n2005-10-26 Paul Jakma <paul.jakma@sun.com>\n\n\t* (general) Cleanup a some calls to XFREE,strdup, etc. to use\n\t  the memory.h macros.\n\t* memtypes.c: Add MTYPE_IF_RMAP_NAME, MTYPE_PQUEUE,\n\t  MTYPE_PQUEUE_DATA and MTYPE_HOST.\n\t* memtypes.h: update auto-built file.\n\t* if_rmap.c: Use MTYPE_IF_RMAP_NAME.\n\t* pqueue.c: Use the two MTYPE_PQUEUE mtypes for allocations.\n\t* command.c: Use MTYPE_HOST, MTYPE_STRVEC. Some other fixups,\n\t  including fixing some likely leaks in config_write_file.\n\t* vty.c: memory macro usage fixes. \n\t  (vty_read_config) fix leak where relative config file is\n\t  specified.\n\n2005-10-20 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* sockopt.c: (setsockopt_multicast_ipv4) If IP_ADD_MEMBERSHIP\n\t  fails with errno equal to EADDRINUSE, then issue an info\n\t  message and try IP_DROP_MEMBERSHIP followed by IP_ADD_MEMBERSHIP.\n\n2005-10-20 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* memory.c: (show_memory_vty) Omit zero statistics.  Print separators\n\t  only if some non-zero stats have been printed in between.\n\t  (show_separator) New function to print a separator.\n\t  (show_memory_all) Keep track of whether a separator is needed\n\t  between the different memory statistics groups.\n\n2005-10-18 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* memtypes.h: Add MTYPE_OSPF_VERTEX_PARENT (to match memtypes.c).\n\n2005-10-18 Paul Jakma <paul.jakma@sun.com>\n\n\t* memtypes.c: (memory_list_ospf) Add MTYPE_OSPF_VERTEX_PARENT.\n\n2005-10-01 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* zebra.h: Declare new functions zebra_route_string() and\n\t  zebra_route_char().\n\t* log.c: (zroute_lookup,zebra_route_string,zebra_route_char) New\n\t  functions to map zebra route numbers to strings.\n\n2005-09-29 Alain Ritoux <alain.ritoux@6wind.com>\n\n\t* smux.[ch]: allow to retreive global OID (identified by <0\n\t  namelen).\n\n2005-09-29 Paul Jakma <paul.jakma@sun.com>\n\n\t* zebra.h: Solaris capabilities requires priv.h to be included.\n\t* privs.{c,h}: Add support for Solaris Least-Privileges.\n\t  privs.h: Reduce some of the abstract capabilities, which do\n\t  not have rough equivalents on both systems. Rename the net\n\t  related caps to _NET, as they should have been in first\n\t  place.\n\t  (zprivs_terminate) should take the zebra_privs_t as argument so\n\t  that it can update change pointer.\n\t  Add an additional privilege state, ZPRIVS_UNKNOWN.\n\t* privs.c: (various capability functions) Add\n\t  Solaris privileges variants.\n\t  (zprivs_state) Use privs.c specific generic types to\n          represent various capability/privilege related types, so that\n          each can be typedef'd as appropriate on each platform.\n\t  (zprivs_null_state) static added, to hold the state the null\n\t  method should report (should be raised by default, and\n          LOWERED if zprivs_terminate has been called)\n          (zprivs_state_null) Report back the zprivs_null_state.\n          (cap_map) Make it able to map abstract capability to multiple\n          system capabilities.\n          (zcaps2sys) Map to abstract capabilities to multiple system\n          privileges/capabilities.\n          (zprivs_init) move capability related init to seperate\n\t  function, zprivs_caps_init.\n          (zprivs_terminate) ditto, moved to zprivs_caps_terminate.\n          Set the change_state callback to the NULL state, so the\n          user can continue to run and use the callbacks.\n          \n2005-09-29 Alain Ritoux <alain.ritoux@6wind.com>\n\n\t* filer.c: show protocol name in filter_show()\n\t* plist.c: show protocol name in vty_show_prefix_entry()\n\t* routemap.c: show protocol name in vty_show_route_map_entry()\n\t* vty.c: in vty_command(), show protocol name if command unknown\n\t\n2005-09-28 Alain Ritoux <alain.ritoux@6wind.com>\n\n\t* md5-gnu.h: removed\n\t* md5.h: replaces md5-gnu.h\n\t* Makefile.am: use correct md5.h\n\t* md5.c: import from WIDE\n\n2005-09-21 Paul Jakma <paul.jakma@sun.com>\n\n\t* memtypes.{c,h}: Add MTYPE_AS_SEG_DATA.\n\t\n2005-09-19 Hasso Tepper <hasso at quagga.net>\n\n\t* str.[ch]: Add strndup() from glibc.\n\n2005-09-05 Paul Jakma <paul.jakma@sun.com>\n\n\t* command.c: (install_element) be more robust. Eg, cmd_init\n\t  need not have been called, some applications may use other\n\t  library subsystems, which call install_element, without the\n          application wanting commands and hence not calling cmd_init.\n        \n2005-08-22 Hugo Santos <hsantos@av.it.pt>\n\n\t* command.h: (enum node_type) Add BGP_IPV6M_NODE \n\t* command.c: (node_parent) Handle BGP_IPV6M_NODE node\n\t  (config_exit, config_end) ditto\n\t* vty.c: (vty_end_config) Handle BGP_IPV6M_NODE node\n\t\n2005-08-10  Greg Troxel  <gdt@fnord.ir.bbn.com>\n\n\t* getopt.h: Don't declare getopt (rather than getopt_long), since\n\tquagga doesn't need it.\n\t* getopt.c (getopt): Don't define getopt.\n\n2005-07-26 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\t* prefix.c: (prefix_ipv4_new, prefix_ipv6_new): Call prefix_new\n\t  to allocate the memory to make sure that all struct prefix pointers\n\t  point to objects of the same length (avoids memory overruns\n\t  on struct prefix assignments).\n\t  (prefix_ipv4_free, prefix_ipv6_free): Simply call prefix_free.\n\t  It is interesting to note that these functions are never actually\n\t  called anywhere in the code.  Instead prefix_free was already\n\t  being called directly, despite the previous MTYPE incompatibility.\n\n2005-07-26 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* prefix.c: (ip_masklen) While loop should test that 'pnt' pointer is\n\t  in range before dereferencing it.\n\n2005-06-24 Pawel Worach <pawel.worach@gmail.com>\n\n\t* getopt.h: add further tests for full getopt declaration on\n\t  various systems.\n\n2005-06-18 Paul Jakma <paul.jakma@sun.com>\n\n\t* memtypes.h: update autobuilt file to match memtypes.c changes\n\n2005-06-01 Paul Jakma <paul.jakma@sun.com>\n\n\t* memtypes.c: Add MTYPE_BGP_PROCESS_QUEUE and\n\t  MTYPE_BGP_CLEAR_NODE_QUEUE\n\n2005-05-24 Paul Jakma <paul@dishone.st>\n\n\t* memtypes.h: update this auto-built file. (maybe we should just\n\t  remove it, is GNU awk a terrible dependency to have?)\n\n2005-05-23 Paul Jakma <paul@dishone.st>\n\n\t* memtypes.awk: use character classes, which work correctly in\n\t  all LC_COLLATE environments, unlike A-Z, which doesnt work in\n\t  eg estonian collate order. Reported by Hasso.\n\t* routemap.c: (rmap_onmatch_goto) fix crash if 'continue' command\n\t  is used, which does not supply an argv[0].\n\t  this is a backport candidate /iff/ the trailing ; is removed\n\t  from VTY_GET_INTEGER_RANGE\n\t* vty.h: fix the VTY_GET macros, do {..} while(0) so they have\n\t  correct function like syntax in usage.\n\t* workqueue.h: Add a WQ_QUEUE_BLOCKED item_status return code,\n\t  to allow a queue function to indicate the queue is not\n\t  ready/blocked - rather than any problem with the item at hand.\n\t  Add a notion of being able to 'plug' and 'unplug' a queue.\n\t  Add helpers to plug/unplug a queue.\n\t  Add a completion callback, to be called when a queue is emptied.\n\t* workqueue.c: (work_queue_new) remove useless list_free.\n\t  (work_queue_schedule) new internal helper function to schedule\n\t  queue, if appropriate.\n\t  (work_queue_add) use work_queue_schedule\n\t  (show_work_queues) Print 'P' if queue is plugged.\n\t  (work_queue_plug) new API function, plug a queue - ie prevent it\n\t  from 'drained' / processed / scheduled.\n\t  (work_queue_unplug) unplug a queue, allowing it to be drained\n\t  / scheduled / processed again.\n\t  (work_queue_run) Add support for WQ_QUEUE_BLOCKED.\n\t  Add comment for RETRY_NOW case.\n\t  Make hysteris more aggresive in ramping up granularity, improves\n\t  performance significantly.\n\t  Add support for calling completion callback when queue is emptied,\n\t  possibly useful for knowing when to unplug a queue.\n\n2005-05-19 Paul Jakma <paul@dishone.st>\n\n\t* thread.c: (thread_cancel_event) the number of pending events\n\t  cancelled is potentially useful information, dont throw it away,\n\t  pass it back to the caller.\n\t* sockunion.c: (sockunion_getsockname) use MTYPE_SOCKUNION, not TMP\n\t  (sockunion_getpeername) ditto\n\t* memtypes.c: (memory_list_bgp) add MTYPE_BGP_PEER_HOST\n\n2005-05-15 Paul Jakma <paul@dishone.st>\n\n\t* getopt.h: It's not just __GNU_LIBRARY__ which defines\n\t  getopt, eg __EXTENSIONS__ does too on SunOS. It still seems\n\t  awfully fragile though.\n\t* getopt.c: include zebra.h after config.h, before including\n\t  getopt.h so that things at least are consistent..\n\t* getopt1.c: ditto\n\t\n2005-05-07 Yar Tikhiy <yar@comp.chem.msu.su>\n\n\t* sockopt.c: Add support for BSD style ifindex in ip_mreq.\n\n2005-05-06 Paul Jakma <paul@dishone.st>\n\n\t* (general) extern and static'ification of functions in code and\n\t  header.\n\t  Cleanup any definitions with unspecified arguments.\n\t  Add casts for callback assignments where the callback is defined,\n\t  typically, as passing void *, but the function being assigned has\n\t  some other pointer type defined as its argument, as gcc complains \n\t  about casts from void * to X* via function arguments.\n\t  Fix some old K&R style function argument definitions.\n\t  Add noreturn gcc attribute to some functions, as appropriate.\n\t  Add unused gcc attribute to some functions (eg ones meant to help\n\t  while debugging)\n\t  Add guard defines to headers which were missing them.\n\t* command.c: (install_node) add const qualifier, still doesnt shut\n\t  up the warning though, because of the double pointer.\n\t  (cmp_node) ditto\n\t* keychain.c: (key_str2time) Add GET_LONG_RANGE() macro, derived \n\t  fromn vty.h ones to fix some of the (long) < 0 warnings.\n\t* thread.c: (various) use thread_empty\n\t  (cpu_record_hash_key) should cast to uintptr_t, a stdint.h type\n\t* vty.h: Add VTY_GET_IPV4_ADDRESS and VTY_GET_IPV4_PREFIX so they\n\t  removed from ospfd/ospf_vty.h\n\t* zebra.h: Move definition of ZEBRA_PORT to here, to remove\n\t  dependence of lib on zebra/zserv.h\n\n2005-05-06 Hasso Tepper <hasso at quagga.net>\n\n\t* sockunion.c: Fix warning message.\n\n2005-05-03 Paul Jakma <paul@dishone.st>\n\n\t* stream.h: Add comment about the special zero-ing ability of\n\t  stream_put.\n\t  (stream_recvmsg, stream_write) should return ssize_t and size_t\n\t  respectively. Should both be extern linkage.\n\t  (stream_recvfrom) Stream aware wrapper around recvfrom, in style\n\t  of stream_read_try.\n\t* stream.c: (stream_recvfrom) new function, wrapper around recvfrom.\n\t  (stream_recvmsg, stream_write) ssize_t and size_t return values\n\t  \n2005-04-27 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\tAdd wall-clock timing statistics to 'show thread cpu' output.\n\t* thread.h: Define struct rusage_t to contain wall-clock time\n\t  and cpu time.  Change GETRUSAGE macro to collect both pieces\n\t  of data.  Make appropriate changes to struct cpu_thread_history\n\t  to track CPU time and real time.  Change proto for\n\t  thread_consumed_time to return real and cpu time elapsed.\n\t  And declare a new global variable 'struct timeval recent_time'.\n\t* thread.c (struct timeval recent_time): New global timestamp variable.\n\t  (timeval_adjust): If timeout is negative, set to 0 (not 10\n\t  microseconds).  And remove upper bound of 1,000,000 seconds, since\n\t  this does not seem to make any sense (and it breaks\n\t  funcname_thread_add_timer_timeval).\n\t  (timeval_cmp): Should return long, not int.\n\t  (vty_out_cpu_thread_history): Show CPU time and real time.\n\t  (cpu_record_hash_print): Calculate totals for CPU and real time.\n\t  (cpu_record_print): Change 'show thread cpu' title to show CPU and\n\t  real time.\n\t  (thread_timer_remain_second): Put current time in global recent_time.\n\t  (funcname_thread_add_timer_timeval): Fix assert.  Replace 2-case\n\t  switch assignment with a ternary expression.  Use global recent_time\n\t  variable.  Fix use of timeval_adjust (previously, the value was not\n\t  actually being adjusted).\n\t  (thread_cancel): Add missing \"break\" statement in case\n\t  THREAD_BACKGROUND.\n\t  (thread_timer_wait): Use global recent_time value instead of calling\n\t  gettimeofday.  And there's no need to check for negative timeouts,\n\t  since timeval_subtract already sets these to zero.\n\t  (thread_timer_process): Timers are sorted, so bail out once we\n\t  encounter a timer that has not yet popped.  And remove some\n\t  extraneous asserts.\n\t  (thread_fetch): Do not process foreground timers before calling\n\t  select.  Instead, add them to the ready list just after the select.\n\t  Also, no need to maintain a count of the number of ready threads,\n\t  since we don't care how many there are, just whether there's\n\t  one at the head of the ready list (which is easily checked).\n\t  Stick current time in global variable recent_time to reduce\n\t  the number of calls to gettimeofday.  Tighten logic for\n\t  calculating the select timeout.\n\t  (thread_consumed_time): Now returns real time and puts the elapsed\n\t  cpu time in an additional argument.\n\t  (thread_should_yield): Use real (wall-clock) time to decide whether\n\t  to yield.\n\t  (thread_call): Maintain CPU and real time statistics.\n\t* vty.c (vty_command): For slow commands, show real and cpu time.\n\n2005-04-27 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* workqueue.c (show_work_queues): Remove unused gettimeofday call.\n\n2005-04-27 Paul Jakma <paul.jakma@sun.com>\n\n\t* workqueue.h: (struct work_queue_item) change retry_count to ran,\n\t  its a count of number item has been run.\n\t* workqueue.c: (show_work_queues) Fix formating of slightly\n\t  bugfix: fix SIGFPE if wq->runs is 0.\n\t  (work_queue_run) retry logic was slightly wrong.\n\t  cycles.best is 0 initialy, granularity is 1, so update best\n\t  if cycles >= granularity, not just >.\n\t* memory.h: memtypes is built source, default includes points to\n\t  top_builddir, so we should refer to lib/memtypes.h\n\n2005-04-26 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* buffer.c (buffer_write): Comment out call to buffer_flush_available.\n\t  This should speed up buffering at the expense of a possible increase\n\t  in latency in flushing the data if inside a long-running thread.\n\n2005-04-25 Paul Jakma <paul.jakma@sun.com>\n\n\t* workqueue.{c,h}: Helper API for setting up and running queues via\n\t  background threads.\n\t* command.c: install the 'show workqueues' command\n\t* memtypes.c: Add work queue mtypes, and a rib-queue type for\n\t  a zebra rib work queue.\n\t* memtypes.h: Updated to match memtypes.c\n\t* Makefile.am: Refer to source files via srcdir variable, fix\n\t  out-of-tree build breakage.\n\t  Add new workqueue files to build.\n\t* memory.c: Make the string field much wider\n\t* memtypes.c: Correct the prefix list str/entry strings\n\t* thread.c: Kill unused TIMER_NO_SORT bits\n\n2005-04-22 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* thread.h: Fix type for struct thread_master add_type: should be\n\t  unsigned char.  Also, add some documentation of thread_add_background\n\t  args.  And remove extraneous declaration of\n\t  show_thread_work_queues_cmd.\n\n2005-04-22 Paul Jakma <paul.jakma@sun.com>\n\n\t* memory.h: Move include of memtypes.h to after the definition of\n\t  struct memory_list, gcc 4.0 doesn't like arrays of incomplete \n\t  types.\n\t* thread.h: Add background thread type and thread_add_background\n\t  macro and accompanying funcname_... function.\n\t  export thread_should_yield, background threads can use it.\n\t  Lower thread yield time to 10ms, 100ms is noticeable lag and\n\t  a thread would only be /starting/ to finish sometime afterward.\n\t* thread.c: (general) Add background thread type and schedule\n\t  nearly all thread types through the ready list for fairness.\n\t  (timeval_adjust) static qualifier missing\n\t  (vty_out_cpu_thread_history) add support for printout of \n\t  background threads\n\t  (show_thread_cpu) ditto.\n\t  (thread_master_debug) add debug of background list\n\t  (thread_master_create) fixup long line\n\t  (thread_add_unuse) add asserts for required state.\n\t  (thread_master_free) free background thread list\n\t  (funcname_thread_add_timer_timeval) make generic, able to \n\t  support arbitrary timer-like thread types.\n\t  (funcname_thread_add_timer) pass thread type to .._add_timer_timeval\n\t  (funcname_thread_add_timer_msec) ditto\n\t  (funcname_thread_add_background) Add a background thread, with an\n\t  optional millisecond delay factor, using .._add_timer_timeval.\n\t  (thread_cancel) Add background thread type.\n\t  Move the thread_list_delete common to all cases to bottom of\n\t  function, after the switch statement..\n\t  (thread_cancel_event) indent\n\t  (thread_timer_wait) Static qualifier, and make it able to cope\n\t  with arbitrary timer-like thread lists, so its of use to\n\t  background threads too.\n\t  (thread_process_fd) static qualifier. Again, make it take a list\n\t  reference rather than thread_master. Fix indentation.\n\t  (thread_timer_process) Check for ready timer-like threads in the\n\t  given list and move them on to the ready list - code originally\n\t  embedded in thread_fetch.\n\t  (thread_fetch) Schedule all threads, other than events, through\n\t  the ready list, to ensure fairness. Timer readying code moved to\n\t  thread_timer_process so it can be reused for background threads.\n\t  Remove the unneeded quagga_sigevent_process, as pointed out by\n\t  John Lin <john.ch.lin@gmail.com>.\n\t  (thread_should_yield) make this available.\n\t\n2005-04-16 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* thread.h (thread_consumed_time): Declare new function to calculate\n\t  elapsed microseconds.\n\t* thread.c (thread_consumed_time): Must be global not static so we\n\t  can call it from lib/vty.c:vty_command.\n\t  (thread_should_yield): Surround with `#if 0' to make clear that this\n\t  function is not currently being used anywhere.\n\t  (thread_call): If CONSUMED_TIME_CHECK is defined, print a CPU HOG\n\t  warning message if the thread takes more than CONSUMED_TIME_CHECK\n\t  microseconds.\n\t* vty.c (vty_command): If CONSUMED_TIME_CHECK is defined, print a CPU\n\t  HOG warning message if the command takes more than CONSUMED_TIME_CHECK\n\t  microseconds.\n\n2005-04-16 Paul Jakma <paul@dishone.st>\n\n\t* memtypes.c: the comment about use of comments in the comments\n\t  headers was causing comment within comment warnings from compiler\n\t* memtypes.awk: Add extensive comments on the file format for\n\t  memtypes.c.\n\t  tighten the pattern for the MTYPE matching action (suggestion from\n\t  Andrew) and tighten which field we try the match on.\n\n2005-04-15 Paul Jakma <paul@dishone.st>\n\n\t* memtypes.c: The new, unified location for memory type definitions.\n\t  The memtype enum and declarations for memory_lists are built from\n          this automatically and put into memtypes.h.\n        * memtypes.awk: New script to generate memtypes.h from memtypes.c\n        * memory.h: Finally, the enum can banished!\n        * memory.c: Finally, the seperate mtype memory_list definitions can\n          be banished!\n          (log_memstats) Increase width of fields\n          (show_memory_zebra_cmd) display zebra specific memory types.\n          Increase width of fields.\n        * Makefile.am: Add memtypes.{c,h}, add BUILT_SOURCES for memtypes.h\n          Add a rule to build memtypes.h using memtypes.awk.\n          Add memtypes.awk to EXTRA_DIST.\n\t  memtypes.awk is gawk dependent, use the GAWK automake var.\n\t* memtypes.h: New file, auto-generated, checked in for convenience.\n\n2005-04-11 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* zclient.h (struct zclient): Add two fields to support non-blocking\n\t  I/O: struct buffer *wb, and struct thread *t_write.\n\t  (zclient_free): Remove function.\n\t  (zebra_redistribute_send): Change 2nd arg from socket fd to\n\t  struct zclient * (needed to support non-blocking I/O and buffering).\n\t  (zclient_send_message): New function to send an arbitrary\n\t  message with non-blocking I/O.\n\t* zclient.c (zclient_new): Create write buffer.\n\t  (zclient_free): Remove unused function.\n\t  (zclient_stop): Must cancel new t_write thread.  Also, reset\n\t  all buffers: ibuf, obuf, and wb.\n\t  (zclient_failed): New helper function for typical error handling.\n\t  (zclient_flush_data): New thread to flush queued data.\n\t  (zclient_send_message): New function to send the message in\n\t  zclient->obuf to zebra using non-blocking I/O and buffering.\n\t  (zebra_message_send, zapi_ipv4_route, zapi_ipv6_route): Use\n\t  new zclient_send_message function instead of calling writen.\n\t  (zclient_start): Set socket non-blocking.  Also, change 2nd arg\n\t  to zebra_redistribute_send from zclient->sock to zclient.\n\t  (zebra_redistribute_send): Change 2nd arg to struct zclient *.\n\t  Can now use zclient->obuf to assemble the message instead of\n\t  allocating a temporary stream.  And call zclient_send_message to\n\t  send the message instead of writen. \n\t  (zclient_read): Convert to support non-blocking I/O by using\n\t  stream_read_try instead of deprecated stream_read.\n\t  (zclient_redistribute): Change 2nd arg to zebra_redistribute_send\n\t  from zclient->sock to zclient.\n\n2005-04-09 Jeroen Simonetti <jeroens@office.netland.nl>\n\n\t* routemap.c: Show description in \"show route-map\" output.\n\n2005-04-08 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* sigevent.c: On GNU_LINUX, check whether __USE_GNU is already defined.\n\n2005-04-08 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* vty.c: (vty_log_fixed) Use casts to (void *) to try to eliminate\n\t  compiler warnings when assigning a (const char *) value to\n\t  struct iovec iov_base.\n\n2005-04-08 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* zebra.h: If GNU_LINUX is defined, then define _GNU_SOURCE.  This\n\t  fixes a problem where we were not getting the declaration of strnlen\n\t  in <string.h>.\n\n2005-04-08 Hasso Tepper <hasso at quagga.net>\n\n\t* routemap.[ch]: Added \"description ...\" command.\n\n2005-04-08 Hasso Tepper <hasso at quagga.net>\n\n\t* prefix.[hc]: Pass argument to the inet6_ntoa by value making it more\n\t  inet_ntoa alike.\n\n2005-04-07 Paul Jakma <paul.jakma@sun.com>\n\n\t* linklist.h: Add usage comments.\t  \n\t  Rename getdata macro to listgetdata.\n\t  Rename nextnode to listnextnode and fix its odd behaviour to be\n\t  less dangerous.\n\t  Make listgetdata macro assert node is not null, NULL list entries\n          should be bug condition.\n          ALL_LIST_ELEMENTS, new macro, forward-referencing macro for use\n          with for loop, Suggested by Jim Carlson of Sun.\n          Add ALL_LIST_ELEMENTS_RO for cases which obviously do not need the\n          \"safety\" of previous macro.\n\t  LISTNODE_ADD and DELETE macros renamed to ATTACH, DETACH, to\n\t  distinguish from the similarly named functions, and reflect their\n\t  effect better.\n\t  Add a QUAGGA_NO_DEPRECATED_INTERFACES define guarded section \n\t  with the old defines which were modified above, \n\t  for backwards compatibility - guarded to prevent Quagga using it..\n\t* linklist.c: fix up for linklist.h changes.\n\t* *.c: fix up for new list loop macro, try audit other loop\n          usage at same time, to some degree.\n\n2004-04-05 Hasso Tepper <hasso at quagga.net>\n\n\t* lib/prefix.[hc]: inet6_ntoa utility function copied from\n\t  ripngd/ripngd.c (inet6_ntop).\n\n2004-04-05 Paul Jakma <paul@dishone.st>\n\n\t* vty.c: Improve logging of failures to open vty socket(s).\n\t  See bugid #163.\n\n2005-04-02 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* if.h: Fix comments to reflect that if_lookup_by_name and\n\t  if_get_by_name now require the argument strings to be NUL-terminated.\n\t* if.c: (if_lookup_by_name) Compare using strcmp.\n\t  (if_get_by_name) Pass strlen(ifname) as 2nd arg to if_create.\n\n2005-04-02 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* if.c: (if_nametoindex) The man page is rather vague, but it seems\n\t  like the argument to if_nametoindex has an implicit maximum length\n\t  of IFNAMSIZ characters.\n\n2005-04-02 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* if.h: (if_lookup_by_name_len, if_get_by_name_len) New functions.\n\t* if.c: (if_lookup_by_name_len, if_get_by_name_len) New functions.\n\t  (if_get_by_name) Tighten up code.\n\t  (interface) Use new function if_get_by_name_len.\n\t* zclient.c: (zebra_interface_add_read) Use new if_get_by_name_len\n\t  function.\n\t  (zebra_interface_state_read) Use new if_lookup_by_name_len function.\n\n2005-04-02 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* str.c: Replace strlcpy and strlcat with actual working versions\n\t  copied from rsync-2.6.2/lib/compat.c.\n\n2005-04-02 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* if.h: Remove define for IFINDEX_INTERNBASE and add define\n\t  IFINDEX_INTERNAL 0, since all internal (i.e. non-kernel) pseudo-\n\t  interfaces should have ifindex set to 0.\n\t  (if_new) Remove function.\n\t  (if_delete_retain) New function to delete an interface without\n\t  removing from iflist and freeing the structure.\n\t  (ifname2ifindex) New function.\n\t* if.c: (if_new) Remove function (absorb into if_create).\n\t  (if_create) Replace function if_new with call to calloc.\n\t  Set ifp->ifindex to IFINDEX_INTERNAL.  Fix off-by-one error\n\t  in assert to check length of interface name.  Add error message\n\t  if interface with this name already exists.\n\t  (if_delete_retain) New function to delete an interface without\n\t  removing from iflist and freeing the structure.\n\t  (if_delete) Implement with help of if_delete_retain.\n\t  (ifindex2ifname) Reimplement using if_lookup_by_index.\n\t  (ifname2ifindex) New function to complement ifindex2ifname.\n\t  (interface) The interface command should check the name length\n\t  and fail with a warning message if it is too long.\n\t  (no_interface) Fix spelling in warning message.\n\t  (if_nametoindex) Reimplement using if_lookup_by_name.\n\t  (if_indextoname, ifaddr_ipv4_lookup) Reimplement using\n\t  if_lookup_by_index.\n\n2005-04-02 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* zebra.h: Should include str.h to pick up missing functions.\n\t* str.h: Declare strnlen if needed.\n\t* str.c: Do not include str.h since zebra.h now includes it.\n\t  (strnlen) New function.\n\n2005-03-16 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* zebra.h: Must check whether __attribute__ should be defined before\n\t  including zassert.h.\n\n2005-03-14 Paul Jakma <paul.jakma@sun.com>\n\n\t* command.c: (sort_node) use vector_max instead of referencing \n\t  (struct vector *)->max directly. Test that vector_max is > 0 \n\t  before using it to calculate an index.\n\t  Fixup vector loop to make main body conditional on vector slot\n\t  not being empty.\n\t  (cmd_cmdsize) Fixup vector loop to make main body conditional on\n\t  vector slot not being empty.\n\t  (cmd_filter_by_completion) ditto\n\t  (cmd_filter_by_string) ditto \n\t  (is_cmd_ambiguous) ditto\n\t  (cmd_describe_command_real) Change index integers to unsigned.\n\t  Test that vector_max is > 0 before using it to calculate an index.\n\t  Return immediately with CMD_ERR_NO_MATCH if vline has no \n\t  active slots.\n\t  Fixup vector loop to make main body conditional on vector slot\n\t  not being empty.\n\t  (cmd_complete_command_real) ditto.\n\t  (cmd_execute_command_strict) Fixup vector loop to be conditional\n\t  on non-null slot.\n\t  (various) Fix indentation and other whitespace.\n\t  vector.h: Rename to (struct vector).max to slightly less confusing\n\t  active, for the number of active slots, distinct from allocated\n\t  or active-and-not-empty. Rename vector_max to vector_active \n\t  for same reason.\n\n2005-03-09 Paul Jakma <paul.jakma@sun.com>\n\n\t* command.c: Undo commit of sign warning fix and hidden command\n\t  in list_cmd. Sign warning is more subtle. list_cmd on its own\n\t  will be committed after.\n\t* command.c: (config_list_cmd) Don't list hidden or deprecated\n\t  commands, hiding these from tab completion is still to be done.\n\n2005-03-08 Paul Jakma <paul.jakma@sun.com>\n\n\t* command.c: (banner_motd_file_cmd) use XSTRDUP/XFREE.\n\t  (no_banner_motd_cmd) use XFREE.\n\t  (cmd_describe_command_real) sign compile warning fix\n\t  (cmd_complete_command_real) ditto.\n\t  (config_list_cmd) Don't list hidden or deprecated commands,\n\t  hiding these from tab completion is still to be done.\n\t* command.h: cmd attr enum should start at 1.\n\t* vty.c: (vty_hello) suggestions from Andrew, read by line and\n\t  stub out trailling non-printable characters on each line thus\n\t  allowing us to specify VTY_NEWLINE to vty_out.\n\n2005-03-08 Jeroen Massar <jeroen@unfix.org>\n\n\t* vty.c: (vty_hello) display motd file, if set\n\t* command.h: add char *motdfile to struct host\n\t* command.c: (config_write_host) write out motdfile config\n\t  (banner_motd_file_cmd) new command, allow motd to be read from\n\t  file.\n\t  (no_banner_motd_cmd) free motdfile string, if needs be.\n\t  (cmd_init) init (struct host).motdfile. Add new motd file\n\t  commands.\n\n2005-03-07 Michael Sandee <voidptr@voidptr.sboost.org>\n\n\t* command.c: host.name might be NULL.\n\t* vty.c: Fix fd leak.\n\n2005-02-24 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* stream.c: (stream_read_try) Log a warning message if a fatal\n\t  I/O error occurs.\n\t  (stream_fifo_new) Fix prototype.\n\t* stream.h: Fix prototype for stream_fifo_new (need void arg).\n\n2005-02-23 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* {vty.h,vty.c}: Remove vty_finish (duplicate of vty_reset).\n\n2005-02-23 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* buffer.h: Make the struct buffer and struct buffer_data structures\n\t  private by moving them inside buffer.c.  Add comments for all\n\t  functions.  Rename buffer_write as buffer_put (to be more consistent\n\t  with the buffer_putc and buffer_putstr functions).  Declare a new\n\t  buffer_write function that is used to write data to a file descriptor\n\t  and/or add it to the buffer queue.  Remove unused function\n\t  buffer_flush_vty_all.  Create a new enum typedef buffer_status_t\n\t  to be used as the return code for all buffer_flush* functions\n\t  and buffer_write.\n\t* buffer.c: The struct buffer and struct buffer_data declarations\n\t  are now private to this file.  In conjunction with that, remove\n\t  some unnecessary fields: struct buffer (alloc, unused_head,\n\t  unused_tail, length), struct buffer_data (prev).\n\t  (buffer_data_new) Removed: functionality incorporated into buffer_add.\n\t  (buffer_data_free) Removed: use a macro BUFFER_DATA_FREE instead.\n\t  (buffer_new) Use calloc instead of malloc + memset(zero). \n\t  Supply an appropriate default size if the specified size is 0.\n\t  (buffer_free) Eliminate code duplication by calling buffer_reset to\n\t  free the contents of the buffer (and remove unused code related\n\t  to unused_head).\n\t  (buffer_empty,buffer_putc,buffer_putstr) Aesthetic change (make more\n\t  compact).\n\t  (buffer_reset) Use macro BUFFER_DATA_FREE.  No need to set\n\t  alloc and length to 0 (these fields have been removed).\n\t  (buffer_add) Fix scope to be static.  Call XMALLOC directly instead\n\t  of calling removed buffer_data_new function.  Simplify the logic\n\t  (since it's now a singly-linked list instead of doubly-linked).\n\t  (buffer_write) Renamed to buffer_put.  Change to void, since return\n\t  code of 1 was meaningless.  No need to adjust length field, since\n\t  it has been removed.\n\t  (buffer_putw,buffer_flush,buffer_flush_vty_all,buffer_flush_vty)\n\t  Remove unused functions.\n\t  (buffer_flush_all) Rewrite using buffer_flush_available to eliminate\n\t  a possible failure mode if IOV_MAX is less than the number of buffers\n\t  on the queue.\n\t  (buffer_flush_window) Incorporate logic from buffer_flush_vty.\n\t  Log an error message if there is a writev error.\n\t  (buffer_flush_available) Be more paranoid: check for case where\n\t  buffer is already empty.  Use new ERRNO_IO_RETRY macro, and use\n\t  new enum for return codes.  Simplify deletion logic (since it's\n\t  now a singly-linked list).\n\t  (buffer_write) New function for use with non-blocking I/O.\n\t* vty.h: Replace the struct vty sb_buffer field with a fixed-size\n\t  (5-character) sb_buf field and an sb_len field, since using\n\t  a struct buffer was inappropriate for this task.  Add some useful\n\t  comments about telnet window size negotiation.\n\t* vty.c: Include <arpa/telnet.h> (no longer included by zebra.h).\n\t  Remove VTY_OBUF_SIZE (instead use buffer_new default size).\n\t  Make telnet_backward_char and telnet_space_char static const.\n\t  (vty_out) Replace buffer_write with buffer_put.\n\t  (vty_log_out) Check for I/O errors.  If fatal, close the vty session.\n\t  Consolidate 3 separate writes into a single write call.\n\t  (vty_will_echo,vty_command,vty_next_line,vty_previous_line,\n\t  vty_end_config,vty_describe_fold,vty_clear_buf,vty_serv_sock_addrinfo,\n\t  vty_serv_sock_family,vty_serv_un,vty_use_backup_config,exec_timeout,\n\t  vty_config_write,vty_save_cwd) Fix scope to static.\n\t  (vty_new) Let buffer_new use its default buffer size.\n\t  (vty_write) Fix signature: 2nd arg should be const char *.\n\t  Replaced buffer_write with buffer_put.\n\t  (vty_telnet_option) Fix minor bug (window height or width greater than\n\t  255 was broken).  Use sb_buf and sb_len instead of removed sb_buffer\n\t  (which was being used improperly).\n\t  (vty_read) On error, use ERRNO_IO_RETRY to decide whether it's fatal.\n\t  If the error is fatal, call buffer_reset so vty_close does not attempt\n\t  to flush the data.  Use new sb_buf and sb_len instead of sb_buffer\n\t  to store the SB negotiation string.\n\t  (vty_flush) When vty->lines is 0, call buffer_flush_available instead\n\t  of buffer_flush_window.  Look at the return code from buffer_flush\n\t  to detect I/O errors (and in that case, log an error message and\n\t  close the vty).\n\t  (vty_create) Fix scope to static.  Initialize sb_len to 0 instead\n\t  of creating sb_buffer.\n\t  (vty_accept) Set socket nonblocking.\n\t  (vtysh_accept) Use new set_nonblocking function instead of calling\n\t  fcntl directly.\n\t  (vtysh_flush) New function called from vtysh_read (after command\n\t  execution) and from vtysh_write.  This flushes the buffer\n\t  and reacts appropriately to the return code (by closing the vty\n\t  or scheduling further flushes).\n\t  (vtysh_read) Check whether error is fatal using ERRNO_IO_RETRY.\n\t  If not, just try again later.  Otherwise, call buffer_reset before\n\t  calling vty_close (to avoid trying to flush the buffer in vty_close).\n\t  Fix logic to allow case where a command does not arrive atomically\n\t  in a single read call by checking for the terminating NUL char.\n\t  (vtysh_write) Use new vtysh_flush helper function.\n\t  (vty_close) No need to call buffer_empty, just call buffer_flush_all\n\t  in any case (it will check whether the buffer is empty).\n\t  Do not free sb_buffer (since it has been removed).\n\t  (vty_log_fixed) Use writev instead of write.\n\t* zebra.h: Do not include <arpa/telnet.h>, since this is used only\n\t  by lib/vty.c.\n\n2005-02-21 Vincenzo Eramo <eramo at infocom.ing.uniroma1.it>\n\n\t* pqueue.[ch]: Introduce \"update\" function to meet ospf spf needs. It\n\t  will allow to update node when:\n\t  i) a node is inserted into the priority queue;\n\t  ii) a node position is modified in the priority queue;\n\t* pqueue.h: Export trickle_down() function.\n\n2005-02-19 Paul Jakma <paul.jakma@sun.com>\n\n\t* stream.c: (stream_new) fix dumb mistake.\n\n2005-02-17 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* stream.c: (stream_read_try) Use new ERRNO_IO_RETRY macro.\n\n2005-02-17 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* network.h: Define a new ERRNO_IO_RETRY macro to test whether an I/O\n\t  operation should be retried.  This eliminates the need to duplicate\n\t  the same logic testing for EAGAIN or EINTR in multiple places.\n\n2005-02-16 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* stream.h: Declare new function stream_read_try suitable for use\n\t  with non-blocking file descriptors.  Indicate that stream_read\n\t  and stream_read_unblock are deprecated.\n\t* stream.c: (stream_read_try) New function for use with non-blocking\n\t  I/O.\n\t  (stream_recvmsg) Should return -1 if the stream is too small to\n\t  contain the data.\n\n2005-02-16 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* network.c: (set_nonblocking) Should check return code from\n\t  fcntl(F_GETFL).\n\n2005-02-15 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\t\n\t* network.h: Declare new function set_nonblocking.  Indicate that\n\t  readn and writen are deprecated.\n\t* network.c: (set_nonblocking) New function to make a file descriptor\n\t  non-blocking, since it seems silly to have fcntl calls sprinkled\n\t  throughout the code.\n\n2005-02-14 Paul Jakma <paul.jakma@sun.com>\n\n\t* stream.h: Unsigned long updated to size_t\n\t* stream.c: ditto\n\t* stream.h: Add stream_copy, stream_dup, stream_recvmsg.\n\t  Add comment describing struct stream abstraction, and various\n\t  other comments.\n\t  Deprecate several unsafe/ambigious macros.\n\t  Add STREAM_WRITEABLE and STREAM_READABLE.\n\t  Add (stream_getl_from) for symmetry.\n\t  Update stream_forward_{endp,getp} to use size_t offset.\n\t  Make stream data a 0 length array, rather than a seperate malloc.\n\t* stream.c: Add consistency checks. Update to follow stream.h\n\t  changes.\n\t  (stream_new) Alloc stream+data in one go.\n\t  (stream_copy) new function, copy a stream.\n\t  (stream_dup) new function, dup a stream.\n\t  (stream_recvmsg) new function, recvmsg data into a stream.\n\t  (stream_empty) no need to check getp == 0.\n\n2005-02-09 Paul Jakma <paul.jakma@sun.com>\n\n\t* stream.h: Remove putp. Update reference to putp with endp.\n\t  Add stream_forward_endp, which daemons were doing manually.\n\t  Rename stream_forward to stream_forward_getp.\n\t  stream.c: Remove/update references to putp.\n\t  introduce stream_forward_endp.\n\n2005-02-08 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* zebra.h: Change macro definitions SET_FLAG and UNSET_FLAG\n\t  to use compound assignment operators (aesthetic change).\n\n2005-02-03 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* log.c: (zlog_signal,zlog_backtrace_sigsafe) Eliminate use of fileno()\n\t  since it is not async-signal-safe.\n\t  (_zlog_assert_failed) Rewrite crashlog logic more compactly.\n\t  (zlog_set_file,zlog_reset_file,zlog_rotate) Update logfile_fd\n\t  for use in signal handler.\n\n2005-02-03 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* log.c: (syslog_sigsafe) Reduce scope of syslog_fd: it is accessed\n\t  inside this function only.\n\t  (open_crashlog) New function to open /var/tmp/quagga.<daemon>.crashlog\n\t  with flags O_WRONLY|O_CREAT|O_EXCL to save some crash info.\n\t  (zlog_signal,_zlog_assert_failed) Increase logging priority from\n\t  LOG_ERR to LOG_CRIT.  If no file logging is configured, try to use\n\t  open_crashlog to create a crash logfile.\n\t  (zlog_backtrace_sigsafe) If a crashlog file descriptor is open,\n\t  dump a backtrace to that file.\n\n2005-02-02 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* if.h: Declare if_flag_dump.\n\n2005-01-30 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* daemon.c: (daemon) Replace perror with zlog_err.\n\t* vty.c: (vty_serv_un) Replace perror with zlog_err.\n\n2005-01-29 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* buffer.h: Fix comment on buffer_getstr to reflect that it now\n\t  uses XMALLOC.\n\t* buffer.c: (buffer_getstr) Use XMALLOC(MTYPE_TMP) instead of malloc.\n\t* filter.c: (access_list_remark,ipv6_access_list_remark) Use\n\t  argv_concat instead of buffer_getstr.\n\t* if.c: (interface_desc) Use argv_concat instead of buffer_getstr.\n\t* plist.c: (ip_prefix_list_description,ipv6_prefix_list_description)\n\t  Use argv_concat instead of buffer_getstr.\n\n2005-01-28 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* lib/buffer.h: Document behavior of buffer_getstr function.\n\t* lib/buffer.c: (buffer_getstr) Fix bug: must handle case where\n\t  the string extends beyond the head struct buffer_data.\n\n2005-01-28 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* lib/command.h: Document behavior of argv_concat function.\n\t* lib/command.c: (argv_concat) Calculate total string length first so\n\t  we can call malloc just once (instead of realloc'ing to add each\n\t  string element).\n\t  (do_echo,config_logmsg) Allow for possible NULL return value from\n\t  argv_concat.\n\n2005-01-23 Hasso Tepper <hasso at quagga.net>\n\n\t* lib/command.[ch]: Make node_parent() function nonstatic. vtyh.c will\n\t  use it as well.\n\n2005-01-18 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* log.h: Test for SA_SIGINFO to see whether zlog_signal takes final\n\t  two args (siginfo and program_counter).\n\t* log.c: (hex_append) Include this function only if SA_SIGINFO or\n\t  HAVE_GLIBC_BACKTRACE is defined.\n\t  (zlog_signal) Final two args (siginfo and program_counter) now\n\t  depend on whether SA_SIGINFO is defined on this platform.\n\t* sigevent.c: (program_counter) Do not include this function if\n\t  SA_SIGINFO is not defined on this platform.\n\t  (exit_handler,core_handler) Test for SA_SIGINFO to decide whether\n\t  2nd & 3rd arguments are present and to decide how to invoke\n\t  zlog_signal.\n\t  (trap_default_signals) Test for SA_SIGINFO and invoke sigaction\n\t  appropriately.\n\n2005-01-17 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* log.h: Change prototype for zlog_backtrace_sigsafe to take additional\n\t  program_counter argument.\n\t* log.c: (zlog_backtrace_sigsafe) Add additional program_counter\n\t  argument.  If it is non-NULL, use backtrace_symbols_fd to resolve\n\t  the address.\n\t  (zlog_signal) Call zlog_backtrace_sigsafe with additional\n\t  program_counter argument.\n\n2005-01-17 Hasso Tepper <hasso at quagga.net>\n\n\t* command.[ch], vty.c: cmd_execute_command() function must not attempt\n\t  to walk up in the node tree if called from vtysh. Different daemons\n\t  might have commands with same syntax in different nodes (for example\n\t  \"router-id x.x.x.x\" commands in zebra/ospfd/ospf6d daemons).\n\n2005-01-14 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* command.c (print_version): Do not bother even to examine host.name,\n\t  since it is always NULL when this function is called from main.\n\n2005-01-14  Greg Troxel  <gdt@fnord.ir.bbn.com>\n\n\t* command.c (print_version): Don't print host.name if it is NULL.\n\tFixes segfault on Solaris reported by Goetz von Escher <goetz@open.ch>\n\t\n2005-01-12 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* sigevent.c: (trap_default_signals) Use the SA_SIGINFO flag to\n\t  pass additional siginfo_t and ucontext_t arguments to core_handler\n\t  and exit_handler.\n\t  (core_handler,exit_handler) Now invoked with 3 arguments (using\n\t  SA_SIGINFO).  Pass additional info to zlog_signal.\n\t  (program_counter) New function to find program counter in ucontext_t,\n\t  needs to be enhanced to support more platforms (currently works only\n\t  on Linux/x86).\n\t* log.h: Change the zlog_signal prototype to add new arguments\n\t  siginfo_t * and program_counter.\n\t* log.c: (zlog_signal) Add new arguments siginfo and program_counter.\n\t  Include si_addr and program counter (if non-NULL) in message.\n\t  And remove #ifdef HAVE_GLIBC_BACKTRACE around hex_append, since\n\t  that is now used to render the si_addr and PC pointers.\n\n2005-01-12 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* zebra.h: If not C99 and no va_copy macro available, fall back to\n\t  memcpy (solves a build problem on FreeBSD 4.x).\n\n2005-01-04 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* zebra.h: Define ZCMSG_FIRSTHDR appropriately based on whether\n\t  config.h indicates HAVE_BROKEN_CMSG_FIRSTHDR (as determined\n\t  by the configure test program).\n\t* sockopt.c: (getsockopt_cmsg_data) Use ZCMSG_FIRSTHDR instead\n\t  of CMSG_FIRSTHDR.\n\n2005-01-02 Hasso Tepper <hasso at quagga.net>\n\n\t* command.c: Revert int -> unsigned int fixes in\n\tcmd_describe_command_real() and cmd_complete_command_real(). index can\n\tbe actually negative and it caused crash with \"do<TAB>\" in vty.\n\n2004-12-29  Greg Troxel  <gdt@poblano.ir.bbn.com>\n\n\t* sockopt.c (getsockopt_ipv4_ifindex): Document calling\n\tconvention.  Beef up comments.  Handle the case where the cmsghdr\n\thas a zero controllen, or more specifically when the wanted option\n\tis not present.  This is needed for Solaris 8, and in general for\n\tany platform for which configure finds a method and it can fail.\n\tMark some changes with XXX to be cleaned up post 0.98.\t\n\t\n2004-12-28 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* sockopt.c: (setsockopt_ipv4_ifindex) Improve error message.\n\t  When neither IP_PKTINFO nor IP_RECVIF is defined, make return value\n\t  deterministic (-1).\n\n2004-12-28 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* thread.c: (funcname_thread_add_timer_msec) Reduce overflow risk.\n\n2004-12-21 Paul Jakma <paul.jakma@sun.com>\n\n\t* if.h: Add more 'non-generic' IFF_ flags.\n\t* if.c: IFF_NOXMIT/IFF_VIRTUAL interfaces are 'loopback like'\n\t* stream.c: Dont allocate streams with 0 sized data buffers\n\n2004-12-17 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* command.c: (do_echo) Added new \"echo\" command, useful for\n\t  watchdog pinging to make sure the daemon is responsive.\n\n2004-12-17 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\t\n\t* pid_output.c: (pid_output_lock) Eliminate static function, and just\n\t  use the #ifdef to decide which version of the function to include.\n\t  This eliminates a compilation problem with gcc4.  And fix the\n\t  non-fcntl version so that it actually compiles.  Exit with\n\t  status 1 instead of -1 on error.\n\n2004-12-15 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* sigevent.c: (trap_default_signals) Ignore SIGPIPE instead of exiting.\n\n2004-12-10 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\t\n\t* log.c: (zlog_signal,_zlog_assert_failed) Change logging level back to\n\t  LOG_ERR instead of LOG_EMERG.\n\n2004-12-09 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* log.c: (hex_append) No need to include this function if\n\t  HAVE_GLIBC_BACKTRACE is not defined.\n\n2004-12-08 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* prefix.c: (prefix_copy) Error message before abort should\n\t  have severity LOG_ERR, not LOG_INFO.\n\t* memory.c: (mtype_log) Log level should be LOG_DEBUG, not LOG_INFO.\n\n2004-12-07 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* {smux.c,zclient.c}: Change level of debug messages to LOG_DEBUG.\n\n2004-12-07 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* command.c: (config_write_host) Note that \"log trap\" is deprecated\n\t  when writing out the config.\n\n2004-12-07 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* log.h: Replace struct zlog flags and maskpri fields with maxlvl\n\t  array to support individual logging levels for each destination.\n\t  Remove the 2nd argument to openzlog since the default logging config\n\t  should be standardized inside the library.  Replaced the\n\t  zlog_set_flag and zlog_reset_flag functions with zlog_set_level.\n\t  And zlog_set_file now requires an additional log_level argument.\n\t  Declare zlog_proto_names for use inside command.c in the\n\t  \"show logging\" command.  Added defines useful for command\n\t  construction.\n\t* log.c: (vzlog) Decide where to send the message based on the\n\t  individual logging levels configured for each destination.\n\t  Remove support for ZLOG_STDERR since it was never actually used.\n\t  Support record-priority for terminal monitors.\n\t  (zlog_signal,zlog_backtrace_sigsafe) Support destination-specific\n\t  logging levels.  Remove stderr support (was never used).  Added\n\t  support for terminal monitor logging.\n\t  (_zlog_assert_failed) Increase message severity to LOG_EMERG.\n\t  (openzlog) Remove 2nd argument since default config should be\n\t  standardized in library.  By default, terminal monitoring\n\t  is set to debug, and all other logging is disabled.\n\t  (zlog_set_flag,zlog_reset_flag) Removed.\n\t  (zlog_set_level) New function to replace zlog_set_flag and\n\t  zlog_reset_flag.  Supports destination-specific logging levels.\n\t  (zlog_set_file,zlog_reset_file) Support file-specific logging level.\n\t  (zlog_rotate) Log an error message if fopen fails, and support\n\t  new file-specific logging level.\n\t* command.h: Change DEFUN_CMD_FUNC_DECL and DEFUN_CMD_FUNC_TEXT so that\n\t  command functions will be static instead of global.  Remove\n\t  declarations for config_exit and config_help.  Define new macros\n\t  DEFUNSH_ATTR, DEFUNSH_HIDDEN, and DEFUNSH_DEPRECATED so we can\n\t  have deprecated commands in vtysh.  Similarly, for completeness,\n\t  define macros ALIAS_SH, ALIAS_SH_HIDDEN, and ALIAS_SH_DEPRECATED.\n\t  Also, fix bug in ALIAS_ATTR macro (didn't matter because it\n\t  was never used).\n\t* command.c: Make many functions static instead of global.\n\t  (facility_name,facility_match,level_match) New functions\n\t  to support enhanced destination-specific logging levels.\n\t  (config_write_host) Support new destination-specific logging levels.\n\t  (config_logmsg) Added new \"logmsg\" command to help test logging\n\t  system.\n\t  (show_logging) Added \"show logging\" command to show the current\n\t  configuration of the logging system.\n\t  (config_log_stdout_level) Support explicit stdout logging level.\n\t  (no_config_log_stdout) Now takes optional LEVEL arg.\n\t  (config_log_monitor,config_log_monitor_level,no_config_log_monitor)\n\t  New commands creating new \"log monitor\" commands to set terminal\n\t  monitoring log level.\n\t  (config_log_file_level) Support explicit file logging level.\n\t  (config_log_syslog_level) Support explicit syslog logging level.\n\t  (config_log_facility,no_config_log_facility) Implement new\n\t  \"log facility\" command.\n\t  (cmd_init) Add hooks for new commands: \"show logging\", \"logmsg\",\n\t  \"log stdout <level>\", \"log monitor\", \"log monitor <level>\",\n\t  \"no log monitor\", \"log file <filename> <level>\",\n\t  \"no log file <filename> <level>\", \"log syslog <level>\",\n\t  \"log facility\", and \"no log facility\".\n\t* vty.h: Added a \"level\" argument to vty_log so it can support\n\t  \"log record-priority\".  Declare new function vty_log_fixed for\n\t  use in signal handlers.\n\t* vty.c: (vty_log,vty_log_out) Added a \"level\" argument to support\n\t  \"log record-priority\" for vty terminal monitors.\n\t  (vty_down_level) Use config_exit_cmd.func instead of calling\n\t  config_exit directly (since command functions will now be static\n\t  instead of global).\n\t  (vty_log_fixed) New function to send terminal monitor messages\n\t  from inside a signal handler.\n\n2004-12-03 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* log.h: Document appropriate use of syslog logging priorities\n\t  inside quagga.\n\n2004-12-03 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* command.h: Remove fields log_stdout and log_syslog from struct host,\n\t  since they are just trying to duplicate information in the\n\t  zlog_default structure.  Note that this fixes a bug since those\n\t  fields were not registering any logging that was established\n\t  in the initial call to openzlog (this affects only the zebra and\n\t  ospf6d daemons).  It is probably a bug to turn on any logging by\n\t  default in the call to openzlog.\n\t* command.c: (config_write_host) Get logging info from zlog_default\n\t  instead of now-removed fields host.log_stdout and host.log_syslog.\n\t  (config_log_stdout,no_config_log_stdout) Do not set now-removed field\n\t  host.log_stdout, since this info is recorded in zlog_default.\n\t  (config_log_file) Use XSTRDUP (instead of strdup) to set host.logfile.\n\t  (config_log_syslog,config_log_syslog_facility,no_config_log_syslog)\n\t  Do not set now-removed field host.log_syslog, since this info is\n\t  recorded in zlog_default.\n\n2004-12-03 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* version.h.in: Remove declaration for pid_output_lock, this function\n\t  is now static, not global.\n\t* pid_output.c: (pid_output_lock) This function should be static, not\n\t  global.  And remove \"old umask\" error message, since it was really\n\t  an unimportant debug message, not an error.\n\t  (pid_output) Need to declare static function pid_output_lock.\n\n2004-11-28 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* log.h: Remove several unused fields from struct zlog.  Add comments\n\t  for other fields, and add one new field syslog_options that is\n\t  used in the new syslog_sigsafe implementation.\n\t* log.c: (syslog_sigsafe) New function to send syslog messages in\n\t  an async-signal safe way that can be used inside a signal handler.\n\t  (syslog_connect) New function to connect to syslog daemon inside a\n\t  signal handler.  This function supports only systems where /dev/log\n\t  is a unix datagram socket (e.g. not Solaris).\n\t  (zlog_signal) Call syslog_sigsafe if syslog logging is enabled.\n\t  (zlog_backtrace_sigsafe) Call syslog_sigsafe if syslog logging is\n\t  enabled.\n\t  (openzlog) Save syslog_options for use in syslog_sigsafe.\n\t  (num_append) Fix bug: handle 0 properly.\n\t  (hex_append) New function to print a u_long in hex format.\n\n2004-11-28 Hasso Tepper <hasso at quagga.net>\n\n\t* command.h: DEFUN_DEPRECATED passes attribute to DEFUN as well.\n\n2004-11-26 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* log.c, log.h, memory.c: Change function name from zlog_backtrace_safe\n\t  to the more self-explanatory zlog_backtrace_sigsafe.\n\n2004-11-26 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* debug.[ch]: Remove unused files.\n\t* Makefile.am: Remove references to debug.c and debug.h\n\n2004-11-26 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* log.c: (zlog_backtrace) New function to log a backtrace.\n\t  (zlog_backtrace_safe) Log a backtrace in an async-signal-safe way.\n\t  Unfortunately, this function does not support syslog logging yet.\n\t  (zlog_signal) Move backtrace code into separate function\n\t  zlog_backtrace_safe.\n\t  (_zlog_assert_failed) Call zlog_backtrace before aborting.\n\t* log.h: Declare new functions zlog_backtrace and zlog_backtrace_safe.\n\t* memory.c: (zerror) Call zlog_backtrace before aborting.\n\n2004-11-26 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* Makefile.am: Need to add zassert.h to pkginclude_HEADERS.\n\n2004-11-25 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* zebra.h: If not C99 and there's no va_copy macro and there is\n\t  a __va_copy macro, define va_copy as __va_copy.\n\n2004-11-25 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* pid_output.c: (pid_output_lock) Fix 2 bugs: when locking, should\n\t  set l_whence to SEEK_SET, not SEEK_END.  And after writing new\n\t  pid to file, must ftruncate to eliminate any extraneous bytes left\n\t  over from the last time a pid was written.\n\n2004-11-24 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* zassert.h: New header file to declare a quagga-specific assert macro.\n\t* log.c: (_zlog_assert_failed) New function called when assert fails\n\t  to log the error and abort.\n\t* zebra.h: Include \"zassert.h\" instead of <assert.h>.\n\t* regex.c: Include \"zassert.h\" instead of <assert.h>.\n\n2004-11-23 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* sigevent.c: (signal_init) Set up some default signal handlers\n\t  so that processes will issue an error message before terminating\n\t  or dumping core.\n\t  (trap_default_signals) New function to set up signal handlers\n\t  for various signals that may kill the process.\n\t  (exit_handler) Call zlog_signal, then _exit.\n\t  (core_handler) Call zlog_signal, then abort.\n\t* log.h: Declare new function zlog_signal.\n\t* log.c: (zlog_signal) New function to log information about\n\t  a received signal before the process dies.  Try to log a \n\t  backtrace also.\n\t  (quagga_signal_handler,signal_set) Should be static.\n\n2004-11-23 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* log.c: (vzlog) Take a single va_list argument and use va_copy\n\t  as necessary for multiple traversals.\n\t  (zlog) Pass only one va_list to vzlog.\n\t  (zlog_*,plog_*) Use a macro for boilerplate code; pass only one\n\t  va_list to vzlog.\n\t  (zlog_set_file) Remove unused 2nd argument (flags).\n\t  (zlog_save_cwd,zlog_get_cwd,zlog_free_cwd) Remove unused functions.\n\t* log.h: Remove ZLOG_*_INDEX defines (no longer used).\n\t  Remove unused 2nd argument from zlog_set_file prototype.\n\t  Fix prototype for zlog_rotate.\n\t* command.c: (config_log_file) Remove unused 2nd arg to zlog_set_file.\n\t* vty.c: (vty_out) Fix stdarg usage to perform multiple traversals\n\t  properly.\n\t  (vty_log) Must use va_copy for multiple traversals of va_list arg.\n\n2004-11-19 David Young <dyoung@pobox.com>\n\n\t* log.c: (safe_strerror) New function: safe wrapper for strerror.\n\n2004-11-19 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* sockopt.c: (setsockopt_so_recvbuf) Stop error message from being\n\t  printed every time.\n\n2004-11-16 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* memory.h: Fix prototype for memory_init().\n\t* memory.c: Declare many functions and data structures static instead\n\t  of global.  Fix prototype for memory_init().\n\n2004-11-15  Greg Troxel  <gdt@fnord.ir.bbn.com>\n\n\t* sockopt.h: Avoid CMSG_ALIGN, and declare that sizes are without\n\talignment (users should use CMSG_SPACE).\n\n\t* zebra.h: Rationalize CMSG_SPACE compatibility defines.  Warn if\n\tasumming 4-byte alignment, since this isn't safe.\n\n2004-11-15 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* memory.c: (zerror) Use zlog_err instead of fprintf to stderr.\n\t  Instead of exiting, log currenty memory usage and then abort.\n\t  (log_memstats) New function to log memory statistics, called by\n\t  zerror.\n\t  (show_memory_all) Loop over new mlists array instead of calling\n\t  show_memory_vty separately for each memory_list.\n\n2004-11-08 Paul Jakma <paul@dishone.st>\n\n\t* buffer.c: Add missing include of log.h.\n\t  (buffer_flush_available) written is compared against\n\t  mostly against unsigned types, only for the writev do we need\n          signed compare, so declare it as size_t and cast it to ssize_t\n          just for the error compare when we've called writev.\n\t* buffer.h: Add comment that buffer data sizes really should be \n          size_t.\n\n2004-11-07 Paul Jakma <paul@dishone.st>\n\n\t* version.h.in: add autoconf configure_input output var\n\n2004-11-04 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* vty.h: Remove fields in struct vty that were related to VTY_CONTINUE\n\t  capabilities (that were used only in bgpd/bgp_route.c and are now\n\t  removed).  Also remove some other fields that were not being\n\t  used at all.\n\t* vty.c: (vty_execute) Do not test for obsolete status values VTY_START\n\t  and VTY_CONTINUE.\n\t  (vty_read) Remove calls to vty->output_func since that was part\n\t  of the VTY_CONTINUE infrastructure that has been removed.\n\t  (vty_flush) Remove code to support VTY_START and VTY_CONTINUE.\n\t  (vty_close) Remove code to cancel vty->t_output thread, since that\n\t  thread was never actually used.\n\n2004-11-04 Andrew J. Schorr <ajschorr@alumni.princeton.edu>\n\n\t* vty.c: Vtysh connections to daemons should use buffering.\n\t  (vty_out) Remove exception for vty_shell_serv, just use buffer_write.\n\t  (vty_new) Increase output buffer size to 4096 rounded up to a\n\t  multiple of pagesize.\n\t  (vtysh_read) After command has been executed and all output buffered,\n\t  call buffer_flush_available and schedule further writes if the\n\t  buffers are not yet empty.\n\t  (vtysh_write) New function to flush output to vtysh when the socket\n\t  is writeable.\n\t  (vty_event) Added new VTYSH_WRITE event for flushing buffers to vtysh\n\t  clients.  Also, should save read thread in vty->t_read so the\n\t  thread can be cancelled in vty_close.\n\t* buffer.h: In struct buffer_data, remove unused \"parent\" field.\n\t  Convert \"unsigned char *data\" to \"unsigned char data[0]\" to save\n\t  a malloc.  Declare new function buffer_flush_available that works\n\t  with non-blocking sockets.\n\t* buffer.c: (buffer_data_new) Use a single malloc now that data is\n\t  a variable-size array at end of structure.\n\t  (buffer_data_free) Just a single free now that data is part of the\n\t  structure.\n\t  (buffer_write) Simplify the logic to make behavior more transparent.\n\t  (buffer_flush) Decrease b->length as data is written out.\n\t  (buffer_flush_vty_all) Decrease b->length as buffers are freed.\n\t  (buffer_flush_vty) Decrease b->length as data is written out.\n\t  (buffer_flush_available) New function to flush non-blocking sockets.\n\t  \n2004-11-01 Paul Jakma <paul@dishone.st>\n\n\t* sockopt.c: (setsockopt_pktinfo) remove, its unused.\n\n2004-10-31 Paul Jakma <paul@dishone.st>\n\n\t* vty.c: As per Andrew's suggestions..\n\t  (vty_serv_un) remove flags.\n\t  (vtysh_accept) close socket if we cant set NONBLOCK. Add flags.\n\t* keychain.c: Convert some more strtoul users to VTY_GET_INTEGER.\n\t* memory.h: Add MTYPE_THREAD_FUNCNAME and MTYPE_THREAD_STATS\n\t* thread.c: Update stats and funcname alloc/free to use previous\n\t  specific memory type defines. Use XCALLOC and sizeof the type,\n          not the pointer.\n\t* smux.c: fix int to size_t compile warnings\n\n2004-10-29 Paul Jakma <paul@dishone.st>\n\n\t* vty.c: Move setting of sock to O_NONBLOCK from vty_serv_un\n\t  to vtysh_accept, where sock is the actual fd we wanted to set to\n          O_NONBLOCK, ie the /connected/ vtysh unix socket.\n\n2004-10-23 Hasso Tepper <hasso at quagga.net>\n\n\t* zclient.c: Unbreak reading interface update message. Might fix\n\tblocker bugzilla #109.\n\n2004-10-22 Paul Jakma <paul@dishone.st>\n\n\t* sockopt.c: (getsockopt_ipv4_ifindex) no ifindex should be 0, not\n          -1. \n          (setsockopt_pktinfo) unexported\n\t* sockopt.h: Cleanup SOCKOPT_CMSG defines a bit. Add a throwaway\n          define for SOPT_SIZE_CMSG_IFINDEX_IPV4 for systems which have\n          neither IP_RECVIF nor IP_PKTINFO (eg openbsd), thanks to Rivo\n          Nurges for highlighting problem and fix.\n          Fix elif that should be an else.\n\t* command.h: Cleanup the defines a bit, add helper defines and\n\t  collapse all defines to use those. Add an attribute field to\n\t  cmd_element to support, eg hidden or deprecated commands, add\n          defun defines for such. All that's left to do is add logic\n          to command.c to check these attributes... ;)\n\t* zebra.h: reserve ZEBRA_ROUTE_HSLS\n\n2004-10-19 Hasso Tepper <hasso at quagga.net>\n\n\t* version.h.in: Define copyright string QUAGGA_COPYRIGHT.\n\t* print_version.c: Remove. print_version () function moved to\n\t  command.[c|h].\n\t* command.c: Use QUAGGA_COPYRIGHT.\n\t* Makefile.am: Remove useless version.c and print_version.c files.\n\n2004-10-19 Andrew J. Schorr <aschorr@telemetry-investments.com>\n\n\t* zclient.c: (zebra_interface_address_read) If the destination address\n\t  is encoded as all zeroes, load it as a NULL pointer.\n\t* if.h: Add comment describing struct connected destination field\n\t  and indicating that it may be NULL.  Define macros\n\t  CONNECTED_DEST_HOST and CONNECTED_POINTOPOINT_HOST to help\n\t  with PtP logic (distinguish between host and subnet addressing).\n\t* if.c: (if_lookup_address) Fix PtP logic to handle subnet addressing\n\t  properly,\n\t  (connected_lookup_address) ditto.\n\t  (connected_add_by_prefix) Handle case where destination is NULL,\n\t* prefix.[c|h]: New functions ipv4_network_addr and\n\t  ipv4_broadcast_addr.\n\n2004-10-13 Hasso Tepper <hasso at quagga.net>\n\n\t* command.c: Make CMD_ERR_NOTHING_TODO nonfatal if reading\n\t  configuration from file. Fixes critical bugzilla #113.\n\t* smux.c, smux.h: Remove all defaults to initialize smux connection to\n\t  snmpd by default even if not configured to do so. \"smux peer OID\n\t  <password>\" initializes now connection and \"no smux peer\" terminates\n\t  it.\n\n2004-10-13 Paul Jakma <paul@dishone.st>\n\n\t* (global) more const'ification.\n\t* sockunion.c: (sockunion_su2str) buffer should be sized\n          SU_ADDRSTRLEN.\n          (sockunion_log) do not return stack variables, strdup buf before\n          return.\n        * vty.h: Fix up the VTY_GET_INTEGER macros. Testing caller supplied\n          values against ULONG_MAX is daft, when caller probably has passed\n          a type that can not hold ULONG_MAX. use a temporary long instead.\n          Add VTY_GET_LONG, make VTY_GET_INTEGER_RANGE use it, make\n\t  VTY_GET_INTEGER a define for VTY_GET_INTEGER_RANGE.\n\n2004-10-11 Hasso Tepper <hasso at quagga.net>\n\n\t* command.h: Sync DEFUNSH with other macros.\n\t* sockunion.c, sockunion.h: More const strings.\n\n2004-10-11 Paul Jakma <paul@dishone.st>\n\n\t* thread.c: (funcname_thread_add_timer) \n\t  (funcname_thread_add_timer_msec) Fix mistakes from last change.\n\t  Pointed out by Liu Xin in [quagga-dev 1609].\n\t* if.h: mtu's should be unsigned.\n\t* routemap.{c,h}: const char updates\n\t* smux.{c,h}: ditto\n\n2004-10-10 Paul Jakma <paul@dishone.st>\n\n\t* version.h.in: (pid_output*) add const qualifier.\n\t* command.h: Change DEFUN func to take const char *[] rather\n          than char **, to begin process of fixing compile warnings in lib/.\n          Nearly all other changes in this commit follow from this change.\n        * buffer.{c,h}: (buffer_write) pointer-arithmetic is gccism, take\n          const void * and cast an automatic const char *p to it.\n          (buffer_putstr) add const\n        * command.c: (zencrypt) const qualifier\n          (cmd_execute_command_real) ditto\n          (cmd_execute_command_strict) ditto\n          (config_log_file) ditto. \n          Fix leak of getcwd() returned string.\n        * memory.{c,h}: Add MTYPE_DISTRIBUTE_IFNAME for struct dist ifname.\n        * distribute.{c,h}: Update with const qualifier.\n          (distribute_free) use MTYPE_DISTRIBUTE_IFNAME\n          (distribute_lookup) Cast to char *, note that it's ok.\n          (distribute_hash_alloc) use MTYPE_DISTRIBUTE_IFNAME.\n          (distribute_get)  Cast to char *, note that it's ok.\n        * filter.c: Update with const qualifier.\n        * if.{c,h}: ditto.\n        * if_rmap.{c,h}: ditto.\n          (if_rmap_lookup) Cast to char *, note that it's ok.\n          (if_rmap_get) ditto.\n        * log.{c,h}: Update with const qualifier.\n        * plist.{c,h}: ditto.\n        * routemap.{c,h}: ditto.\n        * smux.{c,h}: ditto. Fix some signed/unsigned comparisons.\n        * sockopt.c: (getsockopt_cmsg_data) add return for error case.\n        * vty.c: Update with const qualifier.\n          \n2004-10-08 Hasso Tepper <hasso at quagga.net>\n\n\t* routemap.c, routemap.h: Make some string arguments const.\n\n2004-10-05 Paul Jakma <paul@dishone.st>\n\n\t* version.h.in: print_version declaration is here, not in automake\n\t  generated version.h.\n\n2004-10-08 Hasso Tepper <hasso at quagga.net>\n\n\t* command.c, command.h: Make argument of cmd_make_strvec function\n\t  const.\n\t* command.c: Make hostname commands usable in vtysh again.\n\n2004-10-07 Hasso Tepper <hasso at quagga.net>\n\n\t* command.c, pid_output.c, print_version.c, vty.c, vty.h: Make more\n\t  strings const.\n\n2004-10-05 Hasso Tepper <hasso at quagga.net>\n\n\t* *.[c|h]: Make many strings cons and a lot of int -> unsigned int\n\t  changes to fix warnings.\n\n2004-10-05 Paul Jakma <paul@dishone.st>\n\n\t* sockopt.{c,h}: add sockopt_iphdrincl_swab_{htosys,systoh},\n          functions to change byte order between system IP_HDRINCL order\n          and host order.\n\t* thread.c: (funcname_thread_add_timer_timeval) new function, add\n          timer at specified timeval.\n\t  (funcname_thread_add_timer) use funcname_thread_add_timer_timeval.\n\t  (funcname_thread_add_timer_msec) ditto\n\n2004-10-04 Hasso Tepper <hasso at quagga.net>\n\n\t* memory.c, memory.h: Make char * argument of strdup functions const.\n\t* prefix.c, prefix.h: Make many arguments const. Reorder stuff in\n\t  header.\n\t* log.h: Make log message const in struct message.\n\t* log.c: Fix some indenting.\n\t* network.c, network.h: Make second argument of writen() const.\n\n2004-10-03  Hasso Tepper  <hasso at quagga.net>\n\n\t* command.h: Introduce SERVICE_NODE for \"service <...>\" commands.\n\t* command.c: Don't initialize commands that don't make sense if vtysh\n\t  is used.\n\t* vty.c: Make VTY_NODE appear in vtysh.\n\n2004-10-03 James R. Leu <jleu at mindspring.com>\n\n\t* zclient.c, zclient.h: zclient functions for router id handling.\n\t* zebra.h: New message types for router id handling.\n\n2004-09-27 Paul Jakma <paul@dishone.st>\n\n\t* zebra.h: Add WANT_OSPF_WRITE_FRAGMENT for ospfd\n\t  to try to fragment oversized packets. Enabled only for Linux.\n\t  Add HAVE_IP_HDRINCL_BSD_ORDER to define struct ip byte order,\n\t  to consolidate various ad-hoc platform defines for same thing.\n\n2004-09-26 Hasso Tepper <hasso at quagga.net>\n\n\t* vty.c, sockopt.c: Fix compiler warnings.\n\n2004-09-23 Hasso Tepper <hasso at quagga.net>\n\n\t* linklist.h: Remove list and listnode typedefs.\n\t* *.[c|h]: list -> struct list *, listnode -> struct listnode *.\n\n2004-09-17 Paul Jakma <paul@dishone.st>\n\n\t* sockopt.c: Add missing bracket\n\n2004-09-17 Paul Jakma <paul@dishone.st>\n\n\t* sockopt.{c,h}: Add setsockopt_so_recvbuf, for ripd and ripngd.\n\n2004-09-13 Paul Jakma <paul@dishone.st>\n\n\t* command.c: Update the copyright string in the default motd.\n\n2004-08-31  David Wiggins  <dwiggins@bbn.com>\n\n\t* hash.c (hash_iterate): Save next pointer before calling\n\tprocedure, so that iteration works even if the called procedure\n\tdeletes the hash backet.\n\n\t* linklist.h (listtail): new macro, not yet used.\n\n2004-08-27 Hasso Tepper <hasso at quagga.net>\n\n\t* command.c: Install \"terminal length\" commands only if vty is used.\n\t  Vtysh will handle it itself.\n\n2004-08-26  Greg Troxel  <gdt@fnord.ir.bbn.com>\n\n\t* sockopt.h: Define method-independent macro for callers of\n\tget_ifindex to use for cmsg length.\n\n2004-08-19 Paul Jakma <paul@dishone.st>\n\n\t* zebra.h: add MAX and MIN defines (eg for ospf6d)\n\n2004-08-19 Paul Jakma <paul@dishone.st>\n\n\t* sockopt.c: include sockopt.h\n\t  rename some of the _pktinfo_ functions to _ifindex, where that is\n\t  their purpose.\n          (getsockopt_ipv6_pktinfo_ifindex) renamed to\n\t  getsockopt_ipv6_ifindex.\n\t  (setsockopt_ipv4_pktinfo) renamed to setsockopt_ipv4_ifindex\n\t  (setsockopt_pktinfo) update with previous and add comment re\n\t  AF_INET portability.\n\t  (setsockopt_ifindex) generic ifindex function ala\n\t  setsockopt_pktinfo.\n\t  (getsockopt_ipv4_pktinfo_ifindex) renamed to\n\t  getsockopt_ipv4_ifindex.\n\t  (getsockopt_ipv4_ifindex) rejiggling to reduce repeated\n          ifdef/elses. pktinfo case forgot to set ifindex.\n          (getsockopt_pktinfo_ifindex) renamed to \n          getsockopt_ifindex. update some calls to renamed functions.\n        * sockopt.h: Update renamed exported functions\n          Rename the CMSG_SIZE macros to IFINDEX.\n          Guard IPv4 PKTINFO in a conditional define.\n\n2004-08-18 Paul Jakma <paul@dishone.st>\n\n\t* vty.c: (vty_serv_un) set unix vty socket to nonblocking\n\t  to prevent inadvertent blocking of daemons by use of\n\t  vtysh. TODO: disentangle manual paging from the buffer_write\n\t  path so that unix vty can use this path too and be reliable.\n\t  \n2004-07-23  Greg Troxel  <gdt@poblano.ir.bbn.com>\n\n\t* sockopt.c (getsockopt_ipv4_pktinfo_ifindex): Make this compile\n\ton NetBSD, and add comments to make it less confusing.  Change the\n\tsense of the SUNOS_5 test to make parallel structure between the\n\tvariables and the code.\n\n2004-07-23 Paul Jakma <paul@dishone.st>\n\n\t* sockopt.h: Add SOPT_SIZE_CMSG_PKTINFO{_IPV{4,6}} define, for\n\t  sizeof pktinfo as appropriate, to be used when allocating msg\n\t  buffers. export setsockopt_pktinfo() and\n\t  getsockopt_pktinfo_ifindex()\n\t* sockopt.c: (setsockopt_pktinfo_ifindex) new function to portably\n\t  set received ifindex sock option.\n\t  (getsockopt_pktinfo_ifindex) portably retrieve ifindex.\n\t  (getsockopt_cmsg_data) retrieve indicated control info from \n\t  message header.\n\t  (getsockopt_ipv6_pktinfo_ifindex) ipv6 version of above.\n\t  (setsockopt_ipv4_pktinfo) v4 version\n\t  (setsockopt_pktinfo) the exported version\n\t  (getsockopt_ipv4_pktinfo_ifindex) v4 specific version\n\t  (getsockopt_pktinfo_ifindex) the exported version\n\n2004-07-14 Paul Jakma <paul@dishone.st>\n\n\t* sigevent.c: (quagga_signal_handler) add a global caught flag, set\n\t  the flags to a constant rather increment to be kinder. \n\t  (quagga_sigevent_process) new function, to do core of what\n\t  quagga_signal_timer did. dont block signals at all as sig->caught\n\t  is volatile sig_atomic_t and should be safe to access from signal\n\t  and normal contexts. The signal blocking is unneeded paranoia, but\n\t  is left intact under an ifdef, should some platform require it.\n\t  Check global caught flag before iterating through array. \n\t  (quagga_signal_timer) nearly everything moved to\n\t  quagga_sigevent_process. Left in under ifdef, in case some\n\t  platform could use a regular timer check for signals.\n\t* sigevent.h: quagga_sigevent_process declaration.\n\t* thread.c: (thread_fetch) check for signals at beginning of \n\t  scheduler loop, check for signals if select returns EINTR.\n\t \n2004-07-13  Greg Troxel  <gdt@poblano.ir.bbn.com>\n\n\t* sigevent.c: Don't block SIGTRAP and SIGKILL.  Blocking SIGTRAP\n\tconfuses gdb, at least on NetBSD 2.0_BETA, where the block\n\tsucceeds.\n\n2004-07-09 Paul Jakma <paul@dishone.st>\n\n\t* Merge Kunihiro's 'show route-map' change and add \n\t  compatibility aliases for route-map continue\n\t* jhash.{c,h}: New files. Bob Jenkins' public domain hashing \n\t  function, as implemented in linux kernel by David Miller.\n\n2004-07-09 Juris Kalnins <juris@mt.lv>\n\n\t* if.c: (if_cmp_func) fix for interface names where name is same,\n\t  but one has no number, eg \"devtyp\" and \"devtyp0\".\n\t  \n2004-06-30  Greg Troxel  <gdt@poblano.ir.bbn.com>\n\n\t* Makefile.am: Make libzebra shared.\n\n2004-06-21 Paul Jakma <paul@dishone.st>\n\n\t* ChangeLog: fix my last update config.h -> zebra.h ;)\n\t* zebra.h: Fix gcc check.\n\t\n2004-06-11 Sowmini Varadhan <sowmini.varadhan@sun.com>\n\n\t* filter.c: (access_list_remark_cmd) buffer_putstr doesnt need cast\n\t  to u_char. (ipv6_access_list_remark_cmd) ditto.\n\t  if.c: ditto\n\t* network.c: (readn/writen) pointer arg should be type u_char.\n\t* plist.c: needs to include stream.h, not declare stream functions\n\t  internally.\n\t  (various) Add static qualifier to internal functions.\n\t  (prefix_list_type_str) extraneous breaks in switch statement.\n\t  (ip_prefix_list_description_cmd) buffer_putstr doesnt need cast\n\t* stream.h: depends on plist.h and export stream_put_prefix\n\t* vty.c: (vty_<telnet option build functions>) should use \n\t  unsigned char, telnet options are 0 -> 255.\n\t* zclient.c: various u_char<->char type cleanups.\n\t* zebra.h: Having to define CMSG_* can apply to more than just\n\t  BSDI_NRL. \n\t  \n2004-06-09 Paul Jakma <paul@dishone.st>\n\n\t* zebra.h: __attribute__ is a gcc'ism\n\t\n2004-06-04 Paul Jakma <paul@dishone.st>\n\n        * type mismatch fixes\n        \n2004-05-18 Hasso Tepper <hasso@estpak.ee>\n\t\n\t* pqueue.[c|h]: Added as part of ospf6d merge from Zebra repository.\n\n2004-05-08 Paul Jakma <paul@dishone.st>\n\n\t* zclient.c (zapi_ipv4_route) Follow Sowmini's lead and describe\n\t  message format.\n\n2004-05-08 Sowmini Varadhan <sowmini.varadhan@sun.com>\n\n\t* zclient.c: (zapi_ipv4_add) collapsed into zapi_ipv4_route\n\t  (zapi_ipv4_delete) ditto.\n\t  (zapi_ipv4_route) add/delete a route by way of cmd arg.\n\t  (zapi_ipv6_add) collapsed into zapi_ipv6_route.\n\t  (zapi_ipv6_delete) ditto.\n\t  (zapi_ipv6_route) add/delete a route by way of cmd arg.\n\t  (zebra_interface_address_delete_read) collapsed into \n\t  zebra_interface_address_read.\n\t  (zebra_interface_address_delete_read) ditto.\n\t  (zebra_interface_address_read) read address add/delete messages\n\t  by way of type argument. Describe command message format.\n\t  (zebra_interface_add_read) Unconditionally read new ifmtu6 field.\n\t  Describe command message format.\n\t  (zebra_interface_state_read) Unconditionally read new ifmtu6 field.\n\t  (zclient_redistribute_set) Collapsed into zclient_redistribute\n\t  (zclient_redistribute_unset) ditto\n\t  (zclient_redistribute) set/unset redistribution.\n\t  (zclient_redistribute_default_set) Collapsed into\n\t  zclient_redistribute_default.\n\t  (zclient_redistribute_default_unset) ditto.\n\t  (zclient_redistribute_default) Redistribute default set/unset.\n\t* zclient.h: delete zapi_ipv{4,6}_add, zapi_ipv{4,6}_delete. Add\n\t  zapi_ipv{4,6}_route. delete zclient_redistribute_set/unset. Add\n\t  zclient_redistribute. Ditto for\n          zclient_redistribute_default_{set/unset}.\n          \n2004-05-08 Sowmini Varadhan <sowmini.varadhan@sun.com>\n\n\t* if.h: Add mtu6 field to struct interface, IPv6 MTU may differ\n\t  from IPv4, and Solaris treats the MTU's differently.\n\t  Add connected_add_by_prefix, for use by later patch.\n\t* if.c: (connected_add_by_prefix) Add prefix to connected list.\n\t  (if_flag_dump) Solaris: Dump IFF_IPv4/6 flag\n\t  (if_dump) Dump mtu6 flag, for HAVE_IPV6.\n\t* command.c: (sockunion_getsockname) use socklen_t for len.\n\t  (sockunion_getpeername) ditto.\n\t  \t  \n2004-04-21 Boris Kovalenko <boris@tagnet.ru>\n\n\t* daemon.c: (daemon) fix check for error return from setsid\n\t\n2004-01-19 Paul Jakma <paul@dishone.st>\n\n\t* sigevent.{c,h}: New files, implement event handled signals.\n\t  see signal_init() in sigevent.h.\n\t  \n2003-12-23  Vincent Jardin  <jardin@6wind.com>\n\n\t* {command.c, memory.c, vty.c, zebra.h}: Add isisd support\n\n2003-12-22  Greg Troxel  <gdt@fnord.ir.bbn.com>\n\n\t* vty.c (vty_use_backup_config): Don't free filenames before using\n\tthem for unlink.\n\n2003-08-20 Yasuhiro Ohara <yasu@sfc.wide.ad.jp>\n\n\t* command.c: Fix <cr> display problem for command line\n\t  description\n\n2003-05-24 Anil Madhavapeddy\n\n\t* (sockunion.c): Incorrect bounds specified in sockunion_log()\n\n2003-05-08 Sergiy Vyshnevetskiy <serg @ vostok.net>\n\n\t* vty.c: -A option\n\n2003-04-19 Hasso Tepper <hasso@estpak.ee>\n\n\t* rip_routemap.c: sync daemon's route-map commands to have same\n\tsyntax\n\n2002-09-28  Yasuhiro Ohara <yasu@sfc.wide.ad.jp>\n\n\t* vty.c (vty_flush): One line more on vty.\n\n2002-09-27  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* vector.c (vector_lookup): Add new function.\n\n2002-08-19  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* thread.c (timeval_adjust): Fix unconditional crush due to\n\tFreeBSD's select() system call timeval value check.\n\n2002-07-07  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* zebra-0.93 released.\n\n2002-06-21  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* if.c (ifc_pointopoint): Add ifc_pointopoint() accoding to Frank\n\tvan Maarseveen's suggestion.\n\n2002-06-18  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c: Change bcopy() to memcpy().\n\n2001-12-12  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c (config_password): Fix host.password clear bug.\n\tReported by Wang Jian <lark@linux.net.cn>.\n\n2001-08-29  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* thread.c (thread_should_yield): New function to check thread\n\tshould yeild it's execution to other thread.  Suggested by: Rick\n\tPayne <rickp@ayrnetworks.com>\n\n2001-08-20  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* thread.c (thread_timer_cmp): Rewrite function.\n\n\t* hash.c: Add hash_get().  Change hash_pull() to hash_release().\n\n2001-08-19  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* zebra-0.92a released.\n\n2001-08-15  Kunihiro Ishiguro  <kunihiro@ipinfusion.com>\n\n\t* zebra-0.92 released.\n\n2001-08-12  Akihiro Mizutani <mizutani@dml.com>\n\n\t* prefix.c (netmask_str2prefix_str): Convert \"1.1.0.0 255.255.0.0\"\n\tstring to \"1.1.0.0/16\".\n\n2001-08-10  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* filter.c (access_list_lookup): access_list_lookup's first\n\targument is changed from address family to AFI.\n\n\t* plist.c: (prefix_list_lookup): Likewise.\n\n2001-07-27  Akihiro Mizutani <mizutani@dml.com>\n\n\t* plist.c: ge and le display order is changed.  Old compatible\n\trule (len <= ge-value <= le-value) is removed.\n\n2001-07-08  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* prefix.h: Temporary fix for alignment of prefix problem.\n\n2001-06-21  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* prefix.h (struct prefix): Remove safi and padding field.\n\t(struct prefix_ipv4): Likewise.\n\t(struct prefix_ipv6): Likewise.\n\t(struct prefix_ls): Likewise.\n\t(struct prefix_rd): Likewise.\n\n\t* command.h (enum node_type): Preparation for BGP new config.\n\n\t* vty.c (vty_end_config): Likewise.\n\n2001-06-17  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* routemap.c (route_map_rule_delete): Call func_free when\n\troute-map rule is deleted.\n\n2001-06-14  \"Akihiro Mizutani\" <mizutani@dml.com>\n\n\t* routemap.c (route_map_index_lookup): Prevent to use deny and\n\tpermit for same route-map sequence.\n\n2001-04-12  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c (vty_read_config): Fix warning.\n\n2001-03-08  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c (IPV6_PREFIX_STR): Add '.' and '%' for IPv6 address\n\tstrings.\n\n2001-03-07  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* zebra.h (_XPG4_2): Define _XPG4_2 and __EXTENSIONS__ for\n\tCMSG_FIRSTHDR.\n\n2001-03-07  Michael Rozhavsky <mrozhavsky@opticalaccess.com>\n\n\t* zebra.h (struct in_pktinfo): structure in_pktinfo declaration.\n\n2001-02-19  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* memory.c (memory_list_lib): Add MTYPE_NEXTHOP for \"show memory\n\tlib\" member.\n\n2001-02-13  Matthew Grant <grantma@anathoth.gen.nz>\n\n\t* vty.c (vty_read_config): Revert check of integrate_default when\n\tVTYSH is defined.\n\n2001-02-13  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c (vty_read_config): Do not check integrate_default.  That\n\tshould be used only by vtysh.\n\n2001-02-08  Matthew Grant <grantma@anathoth.gen.nz>\n\n\t* vty.c (vty_serv_un): Set umask 0077.\n\t(vty_read_config): Stat for vtysh Zebra.conf, if found startup and\n\twait for boot configuration.\n\n\t* if.c (if_lookup_address): Make it smart implementation.\n\n\t* sockopt.c (setsockopt_multicast_ipv4): Set up a multicast socket\n\toptions for IPv4 This is here so that people only have to do their\n\tOS multicast mess in one place rather than all through zebra,\n\tospfd, and ripd .\n\n2001-02-04  Akihiro Mizutani <mizutani@dml.com>\n\n\t* plist.c (vty_prefix_list_install): Even when argument is\n\tinvalid, new memory is allocated.  Now memory allocation is done\n\tafter argument check.\n\n2001-02-01  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* zebra-0.91 is released.\n\n2001-01-31  Akihiro Mizutani <mizutani@dml.com>\n\n\t* vty.c (vty_login): Add vty login command.\n\n2001-01-31  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c (vty_reset): Close accept socket.\n\n2001-01-30  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* memory.h (enum): MTYPE_ATTR_TRANSIT is added for unknown transit\n\tattribute.\n\n2001-01-22  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* zclient.c (zebra_interface_address_add_read): Fetch interface\n\taddress flag.\n\t(zebra_interface_address_delete_read): Likewise.\n\n2001-01-16  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* table.c (route_node_match_ipv4): Utility function for IPv4\n\taddress lookup.\n\t(route_node_match_ipv6): Utility function for IPv4 address lookup.\n\n2001-01-15  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* if.c: Delete RIP_API part until new implementation comes out.\n\n2001-01-13  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* hash.h (struct Hash): Rename alloc to count.  Change type to\n\tunsigned long.\n\n\t* stream.c (stream_getc_from): New function.\n\t(stream_getw_from): Likewise.\n\n\t* zebra.h (ZEBRA_FLAG_STATIC): Add new flag for persistent route.\n\n2001-01-11  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* flap.c: File is removed.\n\n\t* flap.c: Likewise.\n\n\t* roken.h: Likewise.\n\n\t* buffer.c (buffer_new): Remove type option to buffer_new().\n\n2001-01-10  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* zclient.c (zapi_ipv4_delete): Remove OLD_RIB part.\n\n2001-01-09  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* zebra-0.90 is released.\n\n\t* command.c: Update Copyright year.\n\n2001-01-09  Matthew Grant <grantma@anathoth.gen.nz>\n\n\t* if.c (if_create): Register connected_free() function for\n\tdeletion.\n\t(if_delete): Free connected information when the interface is\n\tdeleted.\n\t(if_lookup_by_index): Fix argument type from int to unsigned int.\n\t(connected_add): Keep list in order if old info found, essential\n\tfor repeatable operation in some daemons.\n\n2001-01-09  endo@suri.co.jp (Masahiko Endo)\n\n\t* vty.c (vty_flush): When vty->statis is VTY_CLOSE do not add vty\n\tread thread.\n\n2001-01-08  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* filter.c (access_list_delete): Access-list name is not freed.\n\n\t* plist.c (prefix_list_delete): Prefix-list name is not freed.\n\n2000-12-29  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* zclient.c (zclient_start): Change to use UNIX domain\n\tsocket for zebra communication.\n\n\t* vector.c (vector_init): vector_alloc and vector_data_alloc is\n\tremoved.  All memory allocation count should be maintained by\n\tXMALLOC and XFREE macros.\n\n2000-12-28  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* zebra.h (ZEBRA_NEXTHOP_IFINDEX): Define ZEBRA_NEXTHOP_* values.\n\n2000-12-27  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* zebra.h (ZEBRA_ERR_RTEXIST): Make zebra error code to negative\n\tvalue.\n\n2000-12-25  \"Wataru Uno\" <wataru@po.ntts.co.jp>\n\n\t* vty.c (vtysh_read): Don't allocate new buffer because buffer is\n\tallocated in vty_new ().\n\n2000-12-14  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* memory.h (enum): Add MTYPE_AS_FILTER_STR.\n\n\t* command.c (config_write_terminal): Display \"end\" at the end of\n\tconfiguration.\n\n\t* plist.c (vty_prefix_list_install): Use AF_INET to determine\n\tlenum length.\n\n2000-12-13  \"Wataru Uno\" <wataru@po.ntts.co.jp>\n\n\t* buffer.c (buffer_flush_vty): If IOV_MAX defined in the System,\n\tthen all lines write by IOV_MAX.\n\n2000-12-12  Michael Rozhavsky <mrozhavsky@opticalaccess.com>\n\n\t* command.c (config_write_file): Robust method for writing\n\tconfiguration file and recover from backing up config file.\n\n2000-11-29  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* smux.c (smux_connect): More fail check.\n\t(smux_trap): When SMUX connection is not established, do nothing.\n\n2000-11-28  Gleb Natapov <gleb@nbase.co.il>\n\n\t* thread.c (thread_fetch): Execut event list first.  Old event\n\tlist is renamed to ready list.  With this change, event thread is\n\texecuted before any other thread.\n\n\t* thread.h (struct thread_master): Add ready list.\n\n2000-11-28  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* linklist.c (listnode_add_after): Add node right after the\n\tlistnode pointer.\n\n2000-11-27  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* smux.h: Pass struct variable to WriteMethod.\n\n2000-11-25  Frank van Maarseveen <F.vanMaarseveen@inter.NL.net>\n\n\t* if.c (if_lookup_address): When looking up interface with IP\n\taddress, Sometimes multiple interfaces will match.  Now PtP\n\tinterfaces prevail in such a case which seem the right thing to\n\tdo: There will probably also be host routes which usually prevail\n\tover network routes.\n\n2000-11-25  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* smux.c (smux_trap): SMUX trap implementation.\n\n2000-11-19  Akihiro Mizutani <mizutani@dml.com>\n\n\t* plist.c: Add automatic conversion function of an old rule. \n\tex.) 10.0.0.0/8 ge 8 -> 10.0.0.0/8 le 32\n\n2000-11-16  Yon Uriarte <ukl2@rz.uni-karlsruhe.de>\n\n\t* zclient.c (zebra_interface_add_read): Read hardware address when\n\thw_addr_len is greater than 0.\n\n2000-11-15  Akihiro Mizutani <mizutani@dml.com>\n\n\t* plist.c: The rule of \"len <= ge-value <= le-value\" \n\twas changed to \"len < ge-value <= le-value\".\n\n2000-11-09  Yasuhiro Ohara  <yasu@sfc.wide.ad.jp>\n\n\t* memory.[ch]: Added #define and functions for ospf6d.\n\n\t* log.[ch]: some platform says that the data of used va_list\n\tis undefined. Changed to hold list of va_list for each\n\tvsnprintf.\n\n2000-11-07  Rick Payne <rickp@rossfell.co.uk>\n\n\t* memory.h (enum): Add MTYPE_COMMUNITY_REGEXP.\n\n2000-11-06  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c (config_exit): Fix bug of missing break after case\n\tBGP_VPNV4_NODE.\n\n2000-10-30  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vector.c (vector_unset): Check i is not nevative.\n\n2000-10-24  Arkadiusz Miskiewicz <misiek@pld.org.pl>\n\n\t* smux.c (smux_sock): Set terminating '\\0'.  Check address family.\n\n\t* vty.c (vty_serv_sock_addrinfo): Set terminating '\\0'. Use\n\tgai_strerror.  Check address family.\n\n2000-10-23  Jochen Friedrich <jochen@scram.de>\n\n\t* smux.c: Use linklist rather than vector.\n\t(smux_getnext): A SMUX subagent has to behave as if it manages the\n\twhole SNMP MIB tree itself. It's the duty of the master agent to\n\tcollect the best answer and return it to the manager. See RFC 1227\n\tchapter 3.1.6 for the glory details :-). ucd-snmp really behaves\n\tbad here as it actually might ask multiple times for the same\n\tGETNEXT request as it throws away the answer when it expects it in\n\ta different subtree and might come back later with the very same\n\trequest.\n\n2000-10-23  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c (cmd_init): Log related command are only installed for\n\tterminal mode.\n\n2000-10-21  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* Makefile.am (libzebra_a_SOURCES): Remove duplicated buffer.c.\n\n\t* zebra.h: Remove #warn directive.\n\n2000-10-20  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* keychain.c (keychain_init): Register \"key chain\" command to\n\tKEYCHAIN_NODE and KEYCHAIN_KEY_NODE.\n\n\t* vty.c (vty_end_config): Fix missing vty_cinfig_unlock for other\n\tCONFIG_NODE.\n\n\t* command.c (config_end): Likewise.\n\n\t* keychain.c (keychain_get): Key is sorted by it's identifier\n\tvalue.\n\n2000-10-19  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* linklist.c (list_delete_all_node): Call delete function if it is\n\tdefined.\n\n\t* command.c (cmd_execute_command_strict): Add modification for\n\tvtysh.\n\t(cmd_execute_command_strict): Remove first argument cmdvec because\n\tit is global varibale in command.c.\n\n2000-10-18  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c (cmd_init): Install\n\tcopy_runningconfig_startupconfig_cmd only in terminal mode.\n\n\t* linklist.c (list_delete_node): Simplify the function.\n\t(listnode_lookup): Renamed from list_lookup_node.\n\n2000-10-17  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* stream.h: Undef stream_read and stream_write without\n\tparenthesis.\n\n\t* newlist.c: File removed.\n\n\t* newlist.h: Likewise.\n\n\t* linklist.c (list_new): Remove list_init().  To allocate new\n\tlinked list, please use list_new().\n\t(listnode_add): Remove list_add_node().  To add new node to linked\n\tlist, please use listnode_add().\n\t(list_delete_by_val): Revemove fucntion.\n\n2000-10-16  Nobuaki Tanaka <nobby@po.ntts.co.jp>\n\n\t* table.c (route_table_free): Reimplement route_table_free().\n\n2000-10-11  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* keychain.c (keychain_get): Register key_delete_func to key\n\tlist's delete function.  Use linklist.c instead of newlist.c.\n\n2000-10-04  Akihiro Mizutani <mizutani@dml.com>\n\n\t* filter.c (access_list_remark): Add access-list's remark command.\n\t(no_access_list): \"no access-list 100 permit any\" error message\n\tbug is fixed.\n\n2000-10-03  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* memory.h (enum): Add MTYPE_SOCKUNION.\n\n2000-10-02  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* zebra-0.89 is released.\n\n2000-10-01  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* linklist.c (list_add_node_head): Delete unused function.\n\t(list_add_node_tail): Likewise.\n\n2000-09-26  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* stream.c (stream_read_unblock): Add new function for unblocking\n\tread.\n\n2000-09-26  Jochen Friedrich <jochen@nwe.de>\n\n\t* smux.c (smux_register): Fix bug of can't register more than one\n\tMIB with SMUX.\n\n2000-09-26  Makoto Otsuka <otsuka@inl.ntts.co.jp>\n\n\t* vty.c (vty_close): Fix memory leak of sb_buffer.\n\t(vty_new): Likewise.\n\n2000-09-21  steve@Watt.COM (Steve Watt)\n\n\t* log.h: Do not declare zlog_priority[0] variable.\n\n2000-09-12  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* linklist.h (struct _list ): Add member cmp for compare function.\n\t(struct _list ): Member up is deleted\n\n2000-09-12  David Lipovkov <dlipovkov@OpticalAccess.com>\n\n\t* if.c: Include RIP_API header when RIP API is enabled.\n\n2000-09-10  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* prefix.c (prefix_free): Siplify prefix_free().\n\n\t* keychain.c (key_match_for_accept): strncmp check bug is fixed.\n\n2000-09-07  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* zebra.h: Merge roken.h into zebra.h.\n\n2000-09-05  Akihiro Mizutani <mizutani@dml.com>\n\n\t* routemap.c (route_map_init_vty): Install route-map command to\n\tRMAP_NODE.\n\n2000-08-22  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* thread.c (thread_get_id): Remove pthread related garbage.\n\n\t* command.h (struct host): Likewise.\n\n\t* zebra.h: Likewise.\n\n2000-08-20  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.h (node_type ): Add AAA node for authentication.\n\n\t* vty.c (vty_close): Do not close stdout.\n\n2000-08-18  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c (vty_init_vtysh): Added for vtysh.\n\n\t* distribute.c (districute_list_prefix_all): Interface independent\n\tfilter can be set.\n\t(distribute_list_all): Likewise.\n\t(config_show_distribute): Display current distribute-list status\n\tfor \"show ip protocols\".\n\n2000-08-18  Akihiro Mizutani <mizutani@dml.com>\n\n\t* command.c (config_terminal_no_length): no terminal monitor ->\n\tterminal no monitor\n\t(cmd_init): Do not install service_terminal_length_cmd into\n\tENABLE_NODE.\n\n\t* vty.c (terminal_no_monitor): no terminal length -> terminal no\n\tlength.\n\n2000-08-17  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* zebra-0.88 is released.\n\n2000-08-17  Magnus Ahltorp <ahltorp@nada.kth.se>\n\n\t* vty.h (struct vty ): Add iac_sb_in_progress and sb_buffer for\n\tbetter IAC handling.\n\n\t* vty.c (vty_telnet_option): Change telnet option handling.\n\n2000-08-15  Gleb Natapov <gleb@nbase.co.il>\n\n\t* zclient.c (zclient_redistribute_unset):  New function added.\n\n2000-08-14  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* zclient.c (zebra_interface_add_read): Change ifindex restore\n\tsize from two octet to four.\n\t(zebra_interface_state_read): Likewise.\n\t(zebra_interface_address_add_read): Likewise.\n\n2000-08-13  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c (vty_event): Use vector_set_index() instead of\n\tvector_set().\n\n2000-08-07  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* zebra.h (ZEBRA_XXX_DISTANCE_DEFAULT): Define Default\n\tAdministrative Distance of each protocol.\n\n2000-08-07  Matthew Grant <grantma@anathoth.gen.nz>\n\n\t* if.h (struct interface ): Add new member bandwidth to struct\n\tinterface.\n\n\t* zclient.c (zebra_interface_add_read): Fetch bandwidth value.\n\t(zebra_interface_state_read): Likewise.\n\n2000-08-07  Gleb Natapov <gleb@nbase.co.il>\n\n\t* routemap.c (route_map_event_hook): New hook route_map_event_hook\n\tis added.  This hook is called when route-map is changed. The\n\tparameters passed to the hook are 'event' and 'route-map name'\n\n\t* routemap.h: Add prototype for route_map_event_hook().\n\n2000-08-06  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* zclient.c (zebra_ipv4_route): zebra_ipv4_route(),\n\tzebra_ipv4_add(), zebra_ipv4_delete() are removed.\n\n\t* routemap.c (route_map_empty): Add new function.\n\t(route_map_delete): Use route_map_index_delete() instead of\n\troute_map_index_free().\n\t(route_map_index_free): Function removed.\n\n2000-08-06  Gleb Natapov <gleb@nbase.co.il>\n\n\t* routemap.c (route_map_index_delete): Add check for route-map is\n\tempty or not.\n\n2000-08-03  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* zclient.c (zebra_ipv4_add): Change socket arguemnt with struct\n\tzclient.\n\n2000-08-02  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* zclient.h (struct zebra): Add obuf for output buffer.\n\n\t* if.c: Remove #ifdef NRL enclosing if_nametoindex() and\n\tif_indextoname().\n\n2000-08-02  David Lipovkov <davidl@nbase.co.il>\n\n\t* if.h (IF_PSEUDO_UNSET): IF_PSEUDO related macro added.\n\t(IF_UNKNOWN_SET): IF_UNKNOWN related macro deleted.\n\n\t* if.c (interface_pseudo): Add \"pseudo\" command to interface node.\n\t(no_interface_pseudo): Add \"no pseudo\" command to interface node.\n\n\t* zclient.c (zebra_interface_add_read): Set pseudo flag when it is\n\tsend from zebra.\n\n2000-08-01  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* zebra.h (ZEBRA_IPV4_NEXTHOP_LOOKUP): Add new message.\n\t(ZEBRA_IPV6_NEXTHOP_LOOKUP): Likewise.\n\n\t* vty.c (vty_serv_un): Use AF_UNIX for backward compatibility.\n\n2000-07-31  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c: Use vector for VTY server thread listing instead of\n\tsingle value.\n\n2000-07-30  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* keychain.c (no_key_chain): \"no key chain WORD\" command is added.\n\n2000-07-29  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c (config_from_file): If command fail in\n\tKEYCHAIN_KEY_NODE, down to KEYCHAIN_NODE.\n\n\t* vty.h (struct vty ): Add index_sub member.\n\n2000-07-27  Akihiro Mizutani <mizutani@dml.com>\n\n\t* if.c: Help strings updates.\n\n2000-07-11  Akihiro Mizutani <mizutani@dml.com>\n\n\t* command.c (no_config_enable_password): Add \"no enable password\"\n\tcommand.\n\t(config_write_host): Display password string.\n\n\t* routemap.c (route_map_delete_match): Add support for delete\n\tmatch without argument.\n\t(route_map_delete_set): Likewise.\n\n2000-07-09  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.h (node_type ): Change KEYCHAIN_NODE and\n\tKEYCHAIN_KEY_NODE place just before INTERFACE_NODE.\n\n2000-07-09  Jochen Friedrich <jochen@scram.de>\n\n\t* smux.c (config_write_smux): Fixes the option to override OID and\n\tpassword for SMUX.\n\n2000-07-09  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.h (node_type ): Add SMUX_NODE for SMUX configuration.\n\n2000-07-09  Toshiaki Takada  <takada@zebra.org>\n\n\t* command.c: Sort descvec command's help.\n\n\t* vty.c (vty_describe_command): Display '<cr>' at the end of\n\tdescriptions.\n\n2000-07-05  Toshiaki Takada  <takada@zebra.org>\n\n\t* command.c (cmd_ipv6_match), (cmd_ipv6_prefix_match):  Fix bug\n\ttreatment of double colon.\n\n2000-07-04  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* zclient.h: Add zclient_redistribute_default_{set,unset}().\n\n\t* keychain.c: New file for authentication key management.\n\t* keychain.h: Likewise.\n\t\n\t* tcpfilter.c: New file for TCP/UDP base filtering using ipfw or\n\tipchains.\n\t* tcpfilter.h: Likewise.\n\t\n\t* flap.h: New file for route flap dampening.\n\t* flap.c: Likewise.\n\n2000-07-04  Toshiaki Takada <takada@zebra.org>\n\n\t* filter.c (struct filter): Add exact flag.\n\t(access_list): Add exact-match command.\n\t(ipv6_access_list): Add exact-match command.\n\t\n2000-07-03  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* zebra.h (ZEBRA_REDISTRIBUTE_DEFAULT_ADD): New message for\n\trequest default route.\n\n2000-07-01  Hideaki YOSHIFUJI (\u001b$B5HF#1QL@\u001b(B) <yoshfuji@ecei.tohoku.ac.jp>\n\n\t* smux.c: Add IPv6 smux connection code.\n\n2000-06-15  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c (vty_complete_command): To cooperate readline library,\n\treturned string is newly allocated.  So some match function case\n\tneed, free of memory.\n\n2000-06-12  Akihiro Mizutani <mizutani@dml.com>\n\n\t* distribute.c: Fix help strings.\n\n2000-06-11  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c (cmd_complete_command): Add check for vector_slot\n\t(vline, index) is not NULL when calculating lcd.\n\t(cmd_entry_function): First check variable arguemnt to prevent it\n\tfrom completion.\n\n2000-06-10  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.h (struct vty ): Add output_count member for displaying\n\toutput route count.  Remove arugment arg from output_func because\n\tthe value is passed by vty argument.  Change output to output_rn.\n\tAdd output_clean function pointer member.  Add output_type member.\n\n2000-06-10  Toshiaki Takada <takada@zebra.org>\n\n\t* command.c (show_startup_config): Add \"show startup-config\"\n\tcommand.\n\n2000-06-06  Akihiro Mizutani <mizutani@dml.com>\n\n\t* filter.c: Fix help strings.\n\n2000-06-05  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* prefix.h (struct prefix_rd): New prefix structure for routing\n\tdistinguisher.\n\t(struct prefix): Add padding to every prefix structure.\n\n\n\t* routemap.c (route_map_add_match): When completely same match\n\tstatement exists, don't duplicate it.\n\n2000-06-05  Akihiro Mizutani <mizutani@dml.com>\n\n\t* routemap.c: Change NAME to WORD.\n\n\t* plist.c: Fix help strings.\n\n2000-06-02  Akihiro Mizutani <mizutani@dml.com>\n\n\t* routemap.c: Fix route-map help strings.\n\n2000-06-01  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c (cmd_filter_by_completion): Fix CMD_VARARG treatment\n\tto filter other non vararg commands.\n\n\t* routemap.c (route_map_init_vty): Use install_default() for\n\tinstall common commands into route-map node..\n\n2000-06-01  Akihiro Mizutani  <mizutani@dml.com>\n\n\t* command.h (OSPF_STR):  Macro added.\n\n2000-05-31  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c (cmd_complete_command): LCD completion must not modify\n\tinstalled command string.\n\n\t* plist.c (ipv6_prefix_list): Fix wrong syntax definition.  Change\n\tX:X::X:X to X:X::X:X/M.\n\n2000-05-31  Toshiaki Takada  <takada@zebra.org>\n\n\t* vty.c (show_history):  New defun added.\n\n2000-05-30  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.h (CMD_COMPLETE_LIST_MATCH): New define for completion\n\tlist.  CMD_COMPLETE_MATCH is used for LCD completion.\n\n\t* vty.c (vty_complete_command): Matched string's LCD is completed.\n\n\t* command.c (cmd_lcd): New function for calculate LCD of matched\n\tstrings.\n\n2000-05-26  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c (install_default): config_write_terminal_cmd,\n\tconfig_write_file_cmd, config_write_memory_cmd are added to\n\tdefault node.\n\n\t* memory.c (memory_init): Divide show memory command into each\n\tsort.\n\n\t* command.c (cmd_init): config_write_terminal_cmd,\n\tconfig_write_file_cmd, config_write_memory_cmd are added to\n\tCONFIG_NODE.\n\n\t* routemap.c (route_map_index_free): New function.\n\t(no_route_map_all): New DEFUN for \"no route-map NAME\".\n\n\t* filter.c (no_access_list_all): New DEFUN for delete access-list\n\twith NAME.\n\t(no_ipv6_access_list_all): Likewise.\n\n2000-05-23  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* plist.c: Change IPV6_PREFIX to X:X::X:X.  When \"any\" is\n\tspecified, user can not use \"ge\" and \"le\" statement.\n\n2000-05-22  Thomas Molkenbur <tmo@datus.datus.com>\n\n\t* routemap.c (route_map_add_set): Fix bug of next pointer missing.\n\n\t* table.c (route_table_free): Like wise.\n\n2000-05-22  Toshiaki Takada  <takada@zebra.org>\n\n\t* vty.c (vty_stop_input): Set history pointer to the latest one.\n\n\t* vty.c (vty_hist_add): Do not add command line history when input\n\tis as same as previous one.\n\n2000-05-14  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* memory.h (enum): Add MTYPE_ECOMMUNITY and MTYPE_ECOMMUNITY_VAL.\n\n2000-05-13  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.h (node_type ): Add BGP_VPNV4_NODE.\n\n2000-05-08  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c (vtysh_accept): Add cast of struct sockaddr * to bind\n\targument.  Reported by: Vesselin Mladenov <mladenov@netbg.com>.\n\n\t* filter.c (ipv6_access_list): Add IPv6 prefix example instead of\n\tIPv4 example.  Reported by: Love <lha@s3.kth.se>.\n\n\t* command.c (cmd_complete_command): Make it sure last element of\n\tmatchvec is NULL.  This fix problem which cause crush in\n\tvty_complete_command().  Reported by: JINMEI Tatuya\n\t<jinmei@isl.rdc.toshiba.co.jp>.\n\n2000-04-28  Love <lha@s3.kth.se>\n\n\t* prefix.h (struct prefix): Add padding.\n\n2000-04-28  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c (show_version): Update copyright year.\n\n2000-04-27  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* routemap.c (route_map_apply): When map is NULL, return deny.\n\n2000-04-26  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* filter.c (access_list_apply): When access is NULL, return deny.\n\n\t* plist.c (prefix_list_apply): When plist is NULL, return deny.\n\n2000-04-23  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.h (node_type ): Change RDISC_NODE to IRDP_NODE.\n\n2000-04-18  Toshiaki Takada  <takada@zebra.org>\n\n\t* filter.[ch] (access_list_add_hook), (access_list_delete_hook):\n\tAdd argument for hook function to give struct access_list *.\n\n2000-04-17  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* plist.c (prefix_list_entry_match): In case of le nor ge is\n\tspecified, exact match is performed.\n\t(prefix_list_entry_match): Add any entry matching check.\n\n2000-04-09  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c (exec_timeout): Separate timeout setting to minutes and\n\tseconds.\n\t(no_exec_timeout): Add \"no exec-timeout\" command.\n\n\t* vty.h (VTY_TIMEOUT_DEFAULT): Change default value from 300 to\n\t600.\n\n2000-03-31  Jochen Friedrich <jochen@scram.de>\n\n\t* smux.h (SMUX_CLOSE): The SMUX_CLOSE PDU is implicit integer, so\n\tit is a primitive encoding and not constructed.\n\n2000-03-28  Toshiaki Takada  <takada@zebra.org>\n\n\t* memory.[ch] (enum): Add MTYPE_OSPF_EXTERNAL_INFO.\n\n2000-03-26  Love <lha@s3.kth.se>\n\n\t* zclient.c (zclient_read): Add nbytes size check for\n\tZEBRA_HEADER_SIZE.  Check return value of steam_read ().\n\n2000-03-26  Rick Payne <rickp@rossfell.co.uk>\n\n\t* routemap.c: Add flexible route-map commands such as on-match\n\tnext, on-match goto N.\n\n\t* routemap.h: Likewise\n\n2000-03-23  Adrian Bool <aid@u.net.uk>\n\n\t* command.c (config_log_trap): Add new command \"log trap\n\tPRIORITY\".\n\n2000-03-14  Toshiaki Takada  <takada@zebra.org>\n\n\t* memory.c (struct memory_list): Add Link List and Link Node\n\tto view.\n\t\n\t* memory.h (enum): Remove MTYPE_OSPF_EXTERNAL_ROUTE.\n\t\n2000-01-20  Hideto Yamakawa <hideto.yamakawa@soliton.co.jp>\n\n\t* str.c (snprintf): Fix bug of calling sprintf instead of\n\tvsprintf.\n\n2000-01-16  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* memory.h (enum): Add MTYPE_RIP_PEER.\n\n2000-01-15  Toshiaki Takada  <takada@zebra.org>\n\n\t* memory.h (enum): Add MTYPE_OSPF_CRYPT_KEY.\n\n2000-01-15  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.h (node_type ): Add MASC_NODE for masc.\n\n2000-01-09  Wang Jianliang <wangjl@soim.net>\n\n\t* routemap.c (route_map_index_add): When route_map_index is not\n\tempty and insert new item at the head, it can cause core dump.\n\tFix \"if (index == map->head)\" to \"if (point == map->head).\n\t(route_map_add_set): If there is an old set command, override old\n\tset command with new one.\n\t(route_map_index_delete): Use while() instead of for for() for\n\tlogical correctness.\n\n1999-12-26  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* memory.h (enum): Add MTYPE_BGP_STATIC.\n\n1999-12-23  Alex Zinin <zinin@amt.ru>\n\t* zebra.h, zclient.*: dynamic int up/down message\n\tsupport\n\n1999-12-10  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* thread.c (thread_cancel_event): Add a function for clean up\n\tevents.\n\n1999-12-09  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* dropline.c: Delete file.\n\tdropline.h: Linewise.\t\n\n1999-12-14  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* filter.c (access_list_filter_delete): Wrong pointer\n\taccess->master was pointed out after access is freed.  I store\n\tmaster value at the beginning of the function.\n\n1999-12-08  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c (exec_timeout): Change of VTY timeout affect to current\n\tVTY connection.\n\t(vty_accept): Instead of immediate exit() return -1.\n\n1999-12-07  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c (vty_configure_lock): Configuration lock function added.\n\tOnly one VTY can use CONFI_NODE at the same time.\n\n\t* log.c: Delete zvlog_* functions.  Now zlog_* does the same\n\tthing.\n\n\t* log.c (log_init): Function removed.\n\t(log_close): Likewise.\n\t(log_flush): Likewise.\n\t(log_open): Likewise.\n\n\t* vty.c (terminal_monitor): Add new command.\n\t(no_terminal_monitor): Likewise.\n\n\t* log.c (old_log): Function removed.\n\t(old_log2): Likewise.\n\t(old_log_warn): Likewise.\n\n1999-12-04  Toshiaki Takada  <takada@zebra.org>\n\n\t* command.c (cmd_ipv6_match): New function added.\n\t(cmd_ipv6_prefix_match): Likewise.\n\t\n1999-12-04  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c (cmd_ipv6_match): \n\n\t* table.c: Delete #ifdef HAVE_MBGPV4.\n\n\t* prefix.h (struct prefix): Add safi member.\n\t(struct prefix_ipv4): Likewise.\n\t(struct prefix_ipv6): Likewise.\n\n1999-12-04  Rumen Svobodnikov <rumen@linux.tu-varna.acad.bg>\n\n\t* memory.c (struct mstat): Revert to support MEMORY_LOG.\n\n1999-11-25  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* version.h: Bump up to 0.81c for testing new kernel codes.\n\n1999-11-21  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* thread.h (struct thread): Pthread support is disabled all\n\tplatform.\n\n1999-11-21  Michael Handler <handler@sub-rosa.com>\n\n\t* Include <limits.h> and <strings.h> under SUNOS_5.\n\n1999-11-21  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* sockunion.c (in6addr_cmp): Enclosed by #define HAVE_IPV6\n1999-11-13  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.h (node_type ): Add BGP_IPV4_NODE and BGP_IPV6_NODE.\n\n1999-11-12  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c (disable): Add `disable' command.\n\n1999-11-09  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* plist.c (vty_prefix_list_install): Add any check.\n\n1999-11-04  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.h (node_type ): Add DUMP_NODE.\n\n1999-11-03  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* smux.c: Change default SMUX oid to compatible with gated.\n\n1999-10-30  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* if_rmap.c: New file added.\n\n\t* if_rmap.h: New file added.\n\n1999-10-29  Alex Zinin  <zinin@amt.ru>\n\n\t* hash.c: add hash_free() function\n\n1999-10-25  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* hash.c (hash_clean): Add clean function.\n\n\t* plist.c (prefix_list_reset): Add reset function.\n\n\t* filter.c (access_list_reset): Add reset function.\n\n1999-10-17  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* client.c: Merged with zclient.c.\n\t* client.h: Merged with zclient.h.\n\n1999-10-15  Jordan Mendelson <jordy@wserv.com>\n\n\t* md5.c: Imported from GNU C Library.\n\t* md5-gnu.h: Likewise.\n\n1999-10-15  Jochen Friedrich <jochen@scram.de>\n\n\t* smux.c (smux_getresp_send): SMUX_GETRSP codes improvement.\n\n1999-10-06  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* smux.h: New file added.\n\n\t* snmp.c: Rename to smux.c.\n\n1999-10-02  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c (cmd_execute_command_strict): Filter ambious commands.\n\t(cmd_filter_by_string): Change to return enum match_type.\n\n1999-10-01  Toshiaki Takada  <takada@zebra.org>\n\n\t* vty.c (vty_describe_fold): New function which does VTY\n\tdescription line fold.\n\t* vty.c (vty_describe_command): Set description column.\n\n1999-09-30  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* plist.c (prefix_list_init_ipv4): VTY user interface is improved.\n\n1999-09-26  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c (cmd_filter_by_string): Fix bug of CMD_IPV4 and\n\tCMD_IPV4_PREFIX check.  Both return type must be exact_match.\n\n1999-09-24  Toshiaki Takada  <takada@zebra.org>\n\n\t* command.c (cmd_filter_by_completion),\n\t(is_cmd_ambiguous): Check IPv4 address, IPv4 prefix and range \n\tparameter matches range.\n\n1999-09-22  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* routemap.c (route_map_apply): Returm RM_DENYMATCH when no match\n\tis performed.\n\n1999-09-21  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c (vty_read): Control-C stop VTY_MORE mode.\n\n1999-09-20  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.h (node_type ): Add ACCESS_IPV6_NODE and\n\tPREFIX_IPV6_NODE.\n\n\t* distribute.h: New file added.\n\n\t* command.h (node_type ): Delete DISTRIBUTE_NODE.\n\n1999-09-18  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c (vty_terminate_all): New function added for reload\n\tsupport.\n\n1999-09-06  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* memory.h (enum): Add new type MTYPE_OSPF_EXTERNAL_ROUTE.\n\n1999-08-31  Janos Farkas <chexum@shadow.banki.hu>\n\n\t* vty.c (vty_read): Handle also 0x7f (alt-backspace), just like\n\tesc-ctrl-h (delete word backwards).\n\n1999-08-24  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* if.h: Add if_nametoindex for NRL.\n\n1999-08-23  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* if.c (if_create): New function.\n\n1999-08-22  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* snmp.c: New file.\n\n1999-08-21  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* stream.c (stream_put): stream_memcpy () is changed to stream_put\n\t().  stream_get () is added.\n\n1999-08-18  Toshiaki Takada  <takada@zebra.org>\n\n\t* memory.h (enum): Add MTYPE_OSPF_LSA_DATA.\n\t\n1999-08-18  Yasuhiro Ohara  <yasu@sfc.wide.ad.jp>\n\n\t* table.c (route_table_finish): add function frees table.\n\n1999-08-12  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* memory.h (enum): Add MTYPE_RTADV_PREFIX.\n\n1999-08-11  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* if.h (struct interface ): hw_address, hw_address_len added.\n\n1999-08-10  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* if.h (struct interface ): Change structure member if_data to\n\tinfo, index to ifindex.\n\n1999-08-08  Rick Payne <rickp@rossfell.co.uk>\n\n\t* routemap.c: Multi protocol route-map modification.\n\n\t* routemap.c (route_map_apply): Route match process bug is fixed.\n\n1999-08-05  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* thread.c (thread_fetch): When signal comes, goto retry point.\n\n1999-08-04  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* Makefile.am: Add sockopt.c and sockopt.h\n\t* sockopt.c: New file.\n\t* sockopt.h: New file.\n\t\n1999-08-02  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* version.h (ZEBRA_VERSION): Release zebra-0.75\n\n1999-08-01  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* memory.h (enum): Add MTYPE_RIPNG_AGGREGATE.\n\n1999-07-31  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* sockunion.h: Add sockunion_getpeername ().\n\n1999-07-27  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* version.h: Release zebra-0.74\n\n1999-07-26  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.h (struct host): Delete lines from struct host.  Add\n\tlines to struct vty.\n\n\t* command.c: Delete `lines LINES'.  Terminal display line settings\n\tshould be done by `terminal length' command.\n\n1999-07-24  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* memory.h (enum): MTYPE_OSPF_PATH are added.\n\n1999-07-22  Toshiaki Takada  <takada@zebra.org>\n\n\t* memory.h (enum): MTYPE_OSPF_NEXTHOP is added.\n\n1999-07-21  Toshiaki Takada  <takada@zebra.org>\n\n\t* linklist.c (list_add_node_prev), (list_add_node_next),\n\t(list_add_list): New function added.\n\n\t* table.c (route_table_free): New function added.\n\t\n1999-07-21  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* plist.c (config_write_prefix): Set write flag when configuration\n\tis written.\n\n1999-07-15  Yasuhiro Ohara  <yasu@sfc.wide.ad.jp> \n\n\t* prefix.c : prefix_cmp() added. change apply_mask() to\n\tapply_mask_ipv4(), and new apply_mask() added.\n\n1999-07-14  Yasuhiro Ohara  <yasu@sfc.wide.ad.jp>\n\n\t* prefix.c (prefix2str): append prefixlen.\n\n1999-07-13  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c (config_terminal): Change \"config terminal\" to\n\t\"configure terminal\".  Reported by Georg Hitsch\n\t<georg@atnet.at>.\n\t(config_terminal_length): `terminal length <0-512>' is added.  At\n\tthis moment this command is only usef for vty interface.\n\tSuggested by Georg Hitsch <georg@atnet.at>.\n\n1999-07-12  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* routemap.c (rulecmp): Add wrapper function of strcmp.\n\n1999-07-08  Rick Payne <rickp@rossfell.co.uk>\n\n\t* sockunion.c (inet_aton): Fix bug of inet_aton.\n\n1999-07-08  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* version.h (ZEBRA_VERSION): Start zebra-0.73\n\n1999-07-06  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* version.h: Bump up to 0.72.\n\n1999-07-05  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c (install_default): New function for install default\n\tcommands to the node.\n\n\t* memory.h (enum): MTYPE_NEXTHOP is added.\n\n1999-07-01    <kunihiro@zebra.org>\n\n\t* command.c (no_banner_motd): `no banner motd' command added.\n\n1999-06-30  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* regex.c: Update to glibc-2.1.1's posix/regex.c\n\n\t* regex-gnu.h: Update to glibc-2.1.1's posix/regex.h\n\n\t* prefix.h (IPV4_ADDR_SAME): Macro added.\n\t(IPV6_ADDR_SAME): Likewise.\n\n1999-06-29  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* memory.h (enum): Add MTYPE_OSPF_VERTEX\n\n\t* version.h: Bump up to 0.71.\n\n\t* vty.c (vty_serv_sock_addrinfo): Use addrinfo function to bind\n\tVTY socket when IPv6 is enabled.\n\n1999-06-28  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c (vty_serv_sock): Change vty_serv_sock determine which\n\taddress family to bind.\n\n\t* command.c: Add quit command.\n\n1999-06-26  NOGUCHI kay <kay@dti.ad.jp>\n\n\t* vty.c (vty_read_config): Fix bug of configuration file path\n\tdetection.\n\n1999-06-25  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* version.h: Bump up to 0.70.\n\n1999-06-17  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* buffer.h (GETL): Remove GETL macro.\n\n\t* version.h: Bump up to 0.69.\n\n1999-06-14  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* if.c (connected_add): Commented out connected_log.\n\n1999-06-13  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.h (struct cmd_element ): strvec and descvec is combined\n\tinto newstrvec.\n\n\t* command.c (desc_make): Function removed.\n\t(desc_next): Function removed.\n\n\t* command.h (struct cmd_element ): docvec is removed from struct\n\tcmd_element.\n\n1999-06-12  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c (cmd_execute_command): Remove command NULL check.\n\n\t* command.h (struct cmd_element ): Add newstrvec entry to struct\n\tcmd_element.\n\t(DEFUN2): DEFUN2 macro is removed.  DEFUN is extended to support\n\t(a|b|c) statement.\n\t(DESC): DESC macro is removed.\n\n\t* vty.c (vty_complete_command): When return value is\n\tCMD_ERR_NO_MATCH, don't display error message.\n\n1999-06-08  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* table.c (route_next_until): New function.\n\n\t* version.h: Bump up to 0.68.\n\n1999-06-06  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c (vty_close): Free vty->buf when vty is closed.\n\n\t* memory.h (enum): Add MTYPE_COMMUNITY_ENTRY and\n\tMTYPE_COMMUNITY_LIST.\n\n\t* vty.h (struct vty ): Change buf from static length buffer to\n\tvariable length buffer.\n\n\t* vty.c (vty_ensure): New function added.\n\t\n1999-06-04  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.h (node_type ): Add COMMUNITY_LIST_NODE.\n\n\t* command.c (config_enable_password): Freeing host.enable bug is\n\tfixed.\n\t(config_enable_password): Add argc count check.\n\n1999-05-31  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* version.h: Bump up to 0.67.\n\n1999-05-30  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c (zencrypt): New function for encrypt password.\n\n\t* command.h (struct host): Add password_encrypt and\n\tenable_encrypt.\n\n1999-05-30  Jochen Friedrich <jochen@scram.de>\n\n\t* command.h (struct host): New member encrypt is added for\n\tencrypted password.\n\n1999-05-30  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c: Remove all_digit_check function.  Instead use all_digit.\n\n\t* prefix.c (all_digit): New function for checking string is made\n\tfrom digit character.\n\n1999-05-25  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* Makefile.am (libzebra_a_SOURCES): Add zclient.c.\n\t(noinst_HEADERS): Add zclient.h\n\n\t* zclient.[ch]: New file for zebra client routine.\n\n\t* memory.h (enum): Add MTYPE_ZEBRA.\n\n1999-05-19  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* version.h (ZEBRA_VERSION): Update to 0.66.\n\n1999-05-15  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* buffer.h (GETC,GETW): Macro deleted.\n\n1999-05-15  Carlos Alberto Barcenilla <barce@frlp.utn.edu.ar>\n\n\t* prefix.h (IPV4_NET0, IPV4_NET127): Macro added.\n\n1999-05-15  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c (service_advanced_vty): New command added.\n\t(no_service_advanced_vty): Likewise.\n\n1999-05-14  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c (vty_auth): If advanced flag is set and enable password is\n\tnot set, directly login to the ENABLE_NODE.  This feature is\n\toriginally designed and implemented by Stephen R. van den Berg\n\t<srb@cuci.nl>.\n\n\t* command.h (host): Add advanced flag to struct host for advanced\n\tvty terminal interface.\n\n\t* version.h (ZEBRA_VERSION): Update to 0.65 for next beta release.\n\n1999-05-14  Stephen R. van den Berg <srb@cuci.nl>\n\n\t* command.h (node_type ): Add TABLE_NODE.\n\t\n\t* vty.c (vty_telnet_option): Check host.lines value.\n\n\t* command.c (config_lines): DEFUN for 'lines LINES' command.\n\n\t* zebra.h: Include <sys/utsname.h> for uname().\n\t(RT_TABLE_MAIN): Defined as 0 if OS does not support multiple\n\trouting table.\n\n\t* vty.c (vty_auth): Directly login to the ENABLE_NODE when enable\n\tpassword is not set.\n\t(vty_prompt): Get machine's hostname when hostname is not set.\n\n1999-05-11  James Willard <james@whispering.org>\n\n\t* command.c (config_exit): Close connection when `exit' command is\n\texecuted at ENABLE_NODE.\n\n1999-05-10  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c (vty_stop_input): `C-c' key change node to ENABLE_NODE.\n\n\t* command.c (cmd_execute_command_strict): Matched command size\n\tcheck added.\n\t(cmd_make_desc_line): New function for DEFUN2.\n\n\t* command.h (struct cmd_element ): Add descsize.\n\n1999-05-09  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.h (struct cmd_element ): Remame descvec to docvec.\n\t(struct cmd_element ): Add descvec for new description system.\n\n\t* command.c (desc_make): Check cmd->descvec.\n\n1999-05-06  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* memory.h (enum): Add MTYPE_CLUSTER, MTYPE_CLUSTER_VAL.\n\n1999-05-05  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* version.h (ZEBRA_VERSION): Bump up to 0.64 for next beta\n\trelease.\n\n1999-05-04  Yasuhiro Ohara <yasu@sfc.wide.ad.jp>\n\n\t* linklist.c (list_delete_all_node): bug fix. \n\tprevious code loses current position when node\n\tis deleted.\n\n1999-05-03  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.h (DESC): Macro added.\n\t(struct cmd_element2): Delete struct cmd_element2.\n\n\t* plist.c (prefix_list): Sequential number option check is added.\n\n1999-05-02  Yasuhiro Ohara <yasu@sfc.wide.ad.jp>\n\n\t* log.c (zvlog_{debug,info,notice,warn,err}): have been\n\tadded. now we can log both console and file, but still \n\tneed some fix about config write.\n\n1999-05-02  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* log.c (zvlog_debug): Fix yasu's change.\n\n1999-05-01  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* plist.c (prefix_list): Fix typo.\n\n1999-04-30  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* Set version to 0.63 for first beta package.\n\n1999-04-27  Carlos Barcenilla <barce@frlp.utn.edu.ar>\n\n\t* prefix.c (str2prefix_ipv4): Fix prefix length check.\n\t(str2prefix_ipv6): Likewise.\n\n1999-04-25  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* memory.h (enum): Add MTPYE_PREFIX_LIST and\n\tMTYPE_PREFIX_LIST_ENTRY.\n\n\t* command.h (node_type ): Add PREFIX_NODE.\n\n1999-04-25  Carlos Barcenilla <barce@frlp.utn.edu.ar>\n\n\t* command.c: ALIAS (config_write_memory_cmd) and ALIAS\n\t(copy_runningconfig_startupconfig_cmd) is added.\n\n\t* table.c (route_node_lookup): Unused match variable deletion.\n\n1999-04-24  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* Makefile.am (libzebra_a_SOURCES): plist.c added.\n\t(noinst_HEADERS): plist.h added.\n\n\t* plist.c, plist.h: New file added.\n\n\t* memory.h (enum): Rename MTYPE_AS_PASN to MTYPE_AS_STR.\n\t* memory.c: Likewise.\n\n1999-04-19  Carlos Alberto Barcenilla <barce@frlp.utn.edu.ar>\n\n\t* command.c (show_version): `show version' command added.\n\n1999-04-19  Kunihiro Ishiguro <kunihiro@zebra.org>\n\n\t* prefix.c (str2prefix_ipv6): Prefix length overflow check.\n\n1999-04-19  Carlos Alberto Barcenilla <barce@frlp.utn.edu.ar>\n\n\t* prefix.c (str2prefix_ipv4): Prefix length overflow check.\n\n1999-04-19  Alex Bligh <amb@gxn.net>\n\n\t* prefix.c (sockunion2hostprefix): Function added.\n\t(sockunion2prefix): Address family was not set.  Now it is set.\n\t\n\t* vty.c: VTY access-class command is added.\n\n1999-04-18  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* memory.c: Change xmalloc to zmalloc.  xcalloc, xrealloc, xfree,\n\txstrdup are likewise.\n\n1999-04-18  Yasuhiro Ohara <yasu@sfc.wide.ad.jp>\n\n\t* thread.c: Add thread_execute for other routing daemon.\n\tOSPF tasks need to be generated by \"sheduled\" and \"executed\".\n\n1999-04-13  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* buffer.c: Rewrite buffer_write and buffer_flush related\n\tfunctions for fixing bugs.  Reason of the problem and fix is\n\tsuggested by Alex Bligh <amb@gxn.net>.\n\t\n1999-04-12  Alex Bligh <amb@gxn.net>\n\n\t* command.c (cmd_entry_function_descr): Added for variable\n\targument help display.\n\n1999-04-07  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* regex.c, regex-gnu.h: Imported from GNU sed-3.02 distribution.\n\n1999-03-24  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* stream.c: stream_fifo_free bug is fixed.\n\n1999-03-19  Toshiaki Takada  <takada@zebra.org>\n\n\t* stream.c (stream_strncpy): Added for getting any length bytes\n\tfrom stream.\n\n1999-03-16  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* version.h (ZEBRA_BUG_ADDRESS): New macro added.\n\n1999-03-14  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* buffer.c (buffer_flush_window): If ep is same as buffer's size\n\tlength and lp is overrun one octet.\n\n1999-03-13  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.h: add VTY's timeout function.\n\n1999-03-05    <kunihiro@zebra.org>\n\n\t* command.h (node_type ): Add OSPF6_node.\n\n1999-03-04  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* zebra.h: Check HAVE_SYS_SELECT_H when include <sys/select.h>\n\n1999-03-03  Jeroen Ruigrok/Asmodai <asmodai@wxs.nl>\n\n\t* zebra.h: Include <net/if_var.h> if it exists.\n\n1999-03-02  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* getopt.[ch],getopt1.c: Sync with glibc-2.1.\n\n\t* log.c (zlog): Tempolary ZLOG_STDOUT feature added.\n\n\t* command.h: Include vector.h and vty.h\n\n1999-02-25  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* routemap.h (struct route_map_rule_cmd): Add prefix arguemnt.\n\n\t* routemap.c (route_map_apply_index): Add prefix argument.\n\t(route_map_apply): Likewise.\n\n\t* memory.h (enum): Add MTYPE_ROUTE_MAP_COMPILED.\n\n\t* stream.c: Add stream_fifo related functions.\n\n1999-02-24  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* daemon.c: Return integer value.  File descriptor close is added.\n\n\t* memory.h (enum): add MTYPE_OSPF_LSA.\n\n1999-02-23  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* rsh.c: Remove empty file.\n\n1999-02-22    <kunihiro@zebra.org>\n\n\t* routemap.c: Add add/delete hook to route_map_master.\n\n1999-02-19  Peter Galbavy  <Peter.Galbavy@knowledge.com>\n\n\t* str.[ch] added to supply wrappers for snprintf(), strlcat() and\n\tstrlcpy on system without these.\n\n1999-02-18  Peter Galbavy  <Peter.Galbavy@knowledge.com>\n\n\t* syslog support added\n\n1999-02-02  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* filter.c (access_list_add_hook): added for hook function management.\n\t* filter.c (access_list_delete_hook): Likewise.\n\n1999-01-19  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* stream.c: New file.\n\t* stream.h: New file.\n\t* Divide stream related fucntions from buffer.[ch] into stream.[ch].\n\t\n1999-01-14  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* memory.h (enum): add MTYPE_STREAM, MTYPE_STREAM_DATA\n\n\t* buffer.c (stream_new): Set MTYPE_STREAM to XMALLOC argument.\n\n1998-12-23  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* routemap.c: route_map_index_delete() added.\n\n1998-12-22  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* buffer.c (buffer_empty): check cp instead of sp.\n\n1998-12-17  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* radix.[ch]: Deleted.\n\n1998-12-15  Magnus Ahltorp <map@stacken.kth.se>\n\n\t* buffer.c: Prototype fixes.\n\t* prefix.c: Likewise.\n\t* sockunion.c: Likewise.\n\t* sockunion.h: Likewise.\n\n1998-12-14  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c (vty_read): DELETE key works as vty_delete_char.\n\n1998-12-13  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* log.c (time_print): chane %y to %Y.\n\n1998-12-10  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* distribute.c: new file.\n\n1998-12-09  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* filter.c: Remove all of struct prefix_{ipv4,ipv6} and add\n\tcomplete support of IPv6 access list.\n\n\t* command.c (config_write_element): function delete.\n\t(config_write_host): function add.  password and enable password\n\tisn't printed to vty interface.\n\n1998-12-08  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* filter.c: Change prefix_ipv4 to prefix and add support of\n\tprefix_ipv6 filtering.\n\n1998-12-07  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* Makefile.am (INCLUDES): add @INCLUDES@ for Linux IPv6 inet6-apps\n\theader includes.\n\n1998-12-05  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* log.c (log_flush): fix function name typo.\n\n1998-12-04  Yasuhiro Ohara <yasu@sfc.wide.ad.jp>\n\n\t* memory.h: OSPF memory type is added.\n\n1998-11-15  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c (sort_node): add sort_node() for pretty printing of\n\tcommand on vty interface.\n\t(config_password): delete the restriction of charaster of password\n\tstring.\n\n1998-09-05  Kunihiro Ishiguro  <kunihiro@debian.zebra.org>\n\n\t* prefix.c (prefix_ipv4_any): add prefix_ipv4_any().\n\n1998-08-25  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* network.h: New file.\n\n1998-08-24  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c (vty_will_echo): function name change from vty_off_echo.\n\n1998-08-18  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* buffer.h: add PUTC,PUTW,PUTL macros.\n\n1998-07-22  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* route.[ch]: renamed to prefix.[ch]\n\n1998-06-09  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* prefix_in, prefix_in6 is replaced by prefix_ipv4, prefix_ipv6.\n\n\t* Makefile.am: @INCLUDES@ is deleted from INCLUDES.\n\n1998-06-07  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* host.[ch]: merged with command.[ch]\n\n1998-05-08  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* Makefile.am (libzebra_a_SOURCES): add route.c to libzebra_a_SOURCES.\n\n1998-05-07  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* route.c (str2prefix): str2prefix () is gone.\n\n1998-05-03  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c (vty_read_config): change CONDIR to SYSCONFDIR.\n\n\t* .cvsignore: add file.\n\n\t* memory.c (xerror): add arguent `type' and `size'.\n\n\t* socket.c: deleted.\n\n1998-05-02  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vector.c: malloc,free,realloc -> XMALLOC,XFREE,XREALLOC.\n\t* linklist.c: same as above.\n\n1998-04-30  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* filter.[ch]: added.\n\n1998-04-01  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c (config_who): return CMD_SUCCESS\n\n1998-04-01  Jochen Friedrich <jochen@scram.de>\n\n\t* table.c (route_dump_node): route_dump_node is IPv6 specific\n\tfunction so move #ifdef to the end of route_dump_node ().\n\n1998-03-05  \"Hannes R. Boehm\" <hannes@boehm.org>\n\n\t* if.c: DEFUN(interface_desc) added.\n\n1998-03-05  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* if.c: separated from ripd/rip_interface.c\n\n1998-03-04  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* thread.[ch] : added.\n\n1998-02-14  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c (vty_delete_char): fix size bug.\n\t(vty_backward_pure_word): function added.\n\t(vty_read): ESC + 'f' perform vty_forward_word.\n\t(vty_read): ESC + 'b' perform vty_backward_word.\n\n1998-02-11  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* radix.c (radix_lookup_rt): add mask check.\n\t(radix_delete_duproute): add mask check.\n\n1998-02-10  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c (config_write_file): fix vty -> file_vty.\n\n1998-02-06  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c (cmd_filter_ambiguous): add complex type treatment.\n\n1998-02-05  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c (vty_time_print): function added.\n\t(vty_complete_command): now [...] element isn't shown by completion.\n\n1998-01-26  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c : change from cmd_install_node() to install_node().\n\n1998-01-16  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* route.[ch]: struct rt{} is replaced by struct prefix{}.\n\n1998-01-06  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.c (cmd_execute_command): check command length.\n\n\t* timer.c (zebra_timer_set): add zebra_timer_set.\n\n1998-01-05  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.h (node_type ): add ZEBRA_NODE.\n\n\t* command.c (config_exit): add RIP_NODE.\n\t(config_write_file): add RIP_NODE.\n\n1998-01-04  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* print_version.c (print_version): Now Copyright is 1996-1998.\n\n\t* sockunion.c (sockunion_log): moved from ../zebra/route.c\n\n1997-12-30  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* host.c (config_logfile): change 'log PATH' to 'logfile PATH'.\n\n\t* sockunion.c (sockunion_sameprefix): add same prefix for\n\tsockunion.\n\n1997-12-29  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* radix.[ch] : are moved from ../zebra directroy.\n\t\n\t* command.c (config_from_file): if command execution failed down\n\tlevel to CONFIG_NODE.\n\n\t* host.c: config_log function which enable 'log FILENAME' command.\n\n1997-12-23  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* vty.c: add vty_transpose_chars ().  Now you can use '^T' to\n\ttranspose character.\n\n\t* command.c: cmd_cmdsize add, this is useful to check incomplete\n\tcommand.\n\n1997-12-07  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* fd.h: add family for address family\n\n1997-12-06  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* command.o\n\t* vty.o\n\t* host.o    is moved from ../zebra\n\n1997-08-14  Kunihiro Ishiguro  <kunihiro@zebra.org>\n\n\t* make library directory.\n\n", "/*\n * $Id$\n *\n * Logging of zebra\n * Copyright (C) 1997, 1998, 1999 Kunihiro Ishiguro\n *\n * This file is part of GNU Zebra.\n *\n * GNU Zebra is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the\n * Free Software Foundation; either version 2, or (at your option) any\n * later version.\n *\n * GNU Zebra is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with GNU Zebra; see the file COPYING.  If not, write to the Free\n * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n * 02111-1307, USA.  \n */\n\n#include <zebra.h>\n\n#include \"log.h\"\n#include \"memory.h\"\n#include \"command.h\"\n#ifndef SUNOS_5\n#include <sys/un.h>\n#endif\n\nstatic int logfile_fd = -1;\t/* Used in signal handler. */\n\nstruct zlog *zlog_default = NULL;\n\nconst char *zlog_proto_names[] = \n{\n  \"NONE\",\n  \"DEFAULT\",\n  \"ZEBRA\",\n  \"RIP\",\n  \"BGP\",\n  \"OSPF\",\n  \"RIPNG\",\n  \"OSPF6\",\n  \"ISIS\",\n  \"MASC\",\n  NULL,\n};\n\nconst char *zlog_priority[] =\n{\n  \"emergencies\",\n  \"alerts\",\n  \"critical\",\n  \"errors\",\n  \"warnings\",\n  \"notifications\",\n  \"informational\",\n  \"debugging\",\n  NULL,\n};\n  \n\n\f\n/* For time string format. */\n\nsize_t\nquagga_timestamp(int timestamp_precision, char *buf, size_t buflen)\n{\n  static struct {\n    time_t last;\n    size_t len;\n    char buf[28];\n  } cache;\n  struct timeval clock;\n\n  /* would it be sufficient to use global 'recent_time' here?  I fear not... */\n  gettimeofday(&clock, NULL);\n\n  /* first, we update the cache if the time has changed */\n  if (cache.last != clock.tv_sec)\n    {\n      struct tm *tm;\n      cache.last = clock.tv_sec;\n      tm = localtime(&cache.last);\n      cache.len = strftime(cache.buf, sizeof(cache.buf),\n      \t\t\t   \"%Y/%m/%d %H:%M:%S\", tm);\n    }\n  /* note: it's not worth caching the subsecond part, because\n     chances are that back-to-back calls are not sufficiently close together\n     for the clock not to have ticked forward */\n\n  if (buflen > cache.len)\n    {\n      memcpy(buf, cache.buf, cache.len);\n      if ((timestamp_precision > 0) &&\n\t  (buflen > cache.len+1+timestamp_precision))\n\t{\n\t  /* should we worry about locale issues? */\n\t  static const int divisor[] = {0, 100000, 10000, 1000, 100, 10, 1};\n\t  int prec;\n\t  char *p = buf+cache.len+1+(prec = timestamp_precision);\n\t  *p-- = '\\0';\n\t  while (prec > 6)\n\t    /* this is unlikely to happen, but protect anyway */\n\t    {\n\t      *p-- = '0';\n\t      prec--;\n\t    }\n\t  clock.tv_usec /= divisor[prec];\n\t  do\n\t    {\n\t      *p-- = '0'+(clock.tv_usec % 10);\n\t      clock.tv_usec /= 10;\n\t    }\n\t  while (--prec > 0);\n\t  *p = '.';\n\t  return cache.len+1+timestamp_precision;\n\t}\n      buf[cache.len] = '\\0';\n      return cache.len;\n    }\n  if (buflen > 0)\n    buf[0] = '\\0';\n  return 0;\n}\n\n/* Utility routine for current time printing. */\nstatic void\ntime_print(FILE *fp, struct timestamp_control *ctl)\n{\n  if (!ctl->already_rendered)\n    {\n      ctl->len = quagga_timestamp(ctl->precision, ctl->buf, sizeof(ctl->buf));\n      ctl->already_rendered = 1;\n    }\n  fprintf(fp, \"%s \", ctl->buf);\n}\n  \n\f\n/* va_list version of zlog. */\nstatic void\nvzlog (struct zlog *zl, int priority, const char *format, va_list args)\n{\n  struct timestamp_control tsctl;\n  tsctl.already_rendered = 0;\n\n  /* If zlog is not specified, use default one. */\n  if (zl == NULL)\n    zl = zlog_default;\n\n  /* When zlog_default is also NULL, use stderr for logging. */\n  if (zl == NULL)\n    {\n      tsctl.precision = 0;\n      time_print(stderr, &tsctl);\n      fprintf (stderr, \"%s: \", \"unknown\");\n      vfprintf (stderr, format, args);\n      fprintf (stderr, \"\\n\");\n      fflush (stderr);\n\n      /* In this case we return at here. */\n      return;\n    }\n  tsctl.precision = zl->timestamp_precision;\n\n  /* Syslog output */\n  if (priority <= zl->maxlvl[ZLOG_DEST_SYSLOG])\n    {\n      va_list ac;\n      va_copy(ac, args);\n      vsyslog (priority|zlog_default->facility, format, ac);\n      va_end(ac);\n    }\n\n  /* File output. */\n  if ((priority <= zl->maxlvl[ZLOG_DEST_FILE]) && zl->fp)\n    {\n      va_list ac;\n      time_print (zl->fp, &tsctl);\n      if (zl->record_priority)\n\tfprintf (zl->fp, \"%s: \", zlog_priority[priority]);\n      fprintf (zl->fp, \"%s: \", zlog_proto_names[zl->protocol]);\n      va_copy(ac, args);\n      vfprintf (zl->fp, format, ac);\n      va_end(ac);\n      fprintf (zl->fp, \"\\n\");\n      fflush (zl->fp);\n    }\n\n  /* stdout output. */\n  if (priority <= zl->maxlvl[ZLOG_DEST_STDOUT])\n    {\n      va_list ac;\n      time_print (stdout, &tsctl);\n      if (zl->record_priority)\n\tfprintf (stdout, \"%s: \", zlog_priority[priority]);\n      fprintf (stdout, \"%s: \", zlog_proto_names[zl->protocol]);\n      va_copy(ac, args);\n      vfprintf (stdout, format, ac);\n      va_end(ac);\n      fprintf (stdout, \"\\n\");\n      fflush (stdout);\n    }\n\n  /* Terminal monitor. */\n  if (priority <= zl->maxlvl[ZLOG_DEST_MONITOR])\n    vty_log ((zl->record_priority ? zlog_priority[priority] : NULL),\n\t     zlog_proto_names[zl->protocol], format, &tsctl, args);\n}\n\nstatic char *\nstr_append(char *dst, int len, const char *src)\n{\n  while ((len-- > 0) && *src)\n    *dst++ = *src++;\n  return dst;\n}\n\nstatic char *\nnum_append(char *s, int len, u_long x)\n{\n  char buf[30];\n  char *t;\n\n  if (!x)\n    return str_append(s,len,\"0\");\n  *(t = &buf[sizeof(buf)-1]) = '\\0';\n  while (x && (t > buf))\n    {\n      *--t = '0'+(x % 10);\n      x /= 10;\n    }\n  return str_append(s,len,t);\n}\n\n#if defined(SA_SIGINFO) || defined(HAVE_STACK_TRACE)\nstatic char *\nhex_append(char *s, int len, u_long x)\n{\n  char buf[30];\n  char *t;\n\n  if (!x)\n    return str_append(s,len,\"0\");\n  *(t = &buf[sizeof(buf)-1]) = '\\0';\n  while (x && (t > buf))\n    {\n      u_int cc = (x % 16);\n      *--t = ((cc < 10) ? ('0'+cc) : ('a'+cc-10));\n      x /= 16;\n    }\n  return str_append(s,len,t);\n}\n#endif\n\n/* Needs to be enhanced to support Solaris. */\nstatic int\nsyslog_connect(void)\n{\n#ifdef SUNOS_5\n  return -1;\n#else\n  int fd;\n  char *s;\n  struct sockaddr_un addr;\n\n  if ((fd = socket(AF_UNIX,SOCK_DGRAM,0)) < 0)\n    return -1;\n  addr.sun_family = AF_UNIX;\n#ifdef _PATH_LOG\n#define SYSLOG_SOCKET_PATH _PATH_LOG\n#else\n#define SYSLOG_SOCKET_PATH \"/dev/log\"\n#endif\n  s = str_append(addr.sun_path,sizeof(addr.sun_path),SYSLOG_SOCKET_PATH);\n#undef SYSLOG_SOCKET_PATH\n  *s = '\\0';\n  if (connect(fd,(struct sockaddr *)&addr,sizeof(addr)) < 0)\n    {\n      close(fd);\n      return -1;\n    }\n  return fd;\n#endif\n}\n\nstatic void\nsyslog_sigsafe(int priority, const char *msg, size_t msglen)\n{\n  static int syslog_fd = -1;\n  char buf[sizeof(\"<1234567890>ripngd[1234567890]: \")+msglen+50];\n  char *s;\n\n  if ((syslog_fd < 0) && ((syslog_fd = syslog_connect()) < 0))\n    return;\n\n#define LOC s,buf+sizeof(buf)-s\n  s = buf;\n  s = str_append(LOC,\"<\");\n  s = num_append(LOC,priority);\n  s = str_append(LOC,\">\");\n  /* forget about the timestamp, too difficult in a signal handler */\n  s = str_append(LOC,zlog_default->ident);\n  if (zlog_default->syslog_options & LOG_PID)\n    {\n      s = str_append(LOC,\"[\");\n      s = num_append(LOC,getpid());\n      s = str_append(LOC,\"]\");\n    }\n  s = str_append(LOC,\": \");\n  s = str_append(LOC,msg);\n  write(syslog_fd,buf,s-buf);\n#undef LOC\n}\n\nstatic int\nopen_crashlog(void)\n{\n#define CRASHLOG_PREFIX \"/var/tmp/quagga.\"\n#define CRASHLOG_SUFFIX \"crashlog\"\n  if (zlog_default && zlog_default->ident)\n    {\n      /* Avoid strlen since it is not async-signal-safe. */\n      const char *p;\n      size_t ilen;\n\n      for (p = zlog_default->ident, ilen = 0; *p; p++)\n\tilen++;\n      {\n\tchar buf[sizeof(CRASHLOG_PREFIX)+ilen+sizeof(CRASHLOG_SUFFIX)+3];\n\tchar *s = buf;\n#define LOC s,buf+sizeof(buf)-s\n\ts = str_append(LOC, CRASHLOG_PREFIX);\n\ts = str_append(LOC, zlog_default->ident);\n\ts = str_append(LOC, \".\");\n\ts = str_append(LOC, CRASHLOG_SUFFIX);\n#undef LOC\n\t*s = '\\0';\n\treturn open(buf, O_WRONLY|O_CREAT|O_EXCL, LOGFILE_MASK);\n      }\n    }\n  return open(CRASHLOG_PREFIX CRASHLOG_SUFFIX, O_WRONLY|O_CREAT|O_EXCL,\n\t      LOGFILE_MASK);\n#undef CRASHLOG_SUFFIX\n#undef CRASHLOG_PREFIX\n}\n\n/* Note: the goal here is to use only async-signal-safe functions. */\nvoid\nzlog_signal(int signo, const char *action\n#ifdef SA_SIGINFO\n\t    , siginfo_t *siginfo, void *program_counter\n#endif\n\t   )\n{\n  time_t now;\n  char buf[sizeof(\"DEFAULT: Received signal S at T (si_addr 0xP, PC 0xP); aborting...\")+100];\n  char *s = buf;\n  char *msgstart = buf;\n#define LOC s,buf+sizeof(buf)-s\n\n  time(&now);\n  if (zlog_default)\n    {\n      s = str_append(LOC,zlog_proto_names[zlog_default->protocol]);\n      *s++ = ':';\n      *s++ = ' ';\n      msgstart = s;\n    }\n  s = str_append(LOC,\"Received signal \");\n  s = num_append(LOC,signo);\n  s = str_append(LOC,\" at \");\n  s = num_append(LOC,now);\n#ifdef SA_SIGINFO\n  s = str_append(LOC,\" (si_addr 0x\");\n  s = hex_append(LOC,(u_long)(siginfo->si_addr));\n  if (program_counter)\n    {\n      s = str_append(LOC,\", PC 0x\");\n      s = hex_append(LOC,(u_long)program_counter);\n    }\n  s = str_append(LOC,\"); \");\n#else /* SA_SIGINFO */\n  s = str_append(LOC,\"; \");\n#endif /* SA_SIGINFO */\n  s = str_append(LOC,action);\n  if (s < buf+sizeof(buf))\n    *s++ = '\\n';\n\n  /* N.B. implicit priority is most severe */\n#define PRI LOG_CRIT\n\n#define DUMP(FD) write(FD, buf, s-buf);\n  /* If no file logging configured, try to write to fallback log file. */\n  if ((logfile_fd >= 0) || ((logfile_fd = open_crashlog()) >= 0))\n    DUMP(logfile_fd)\n  if (!zlog_default)\n    DUMP(STDERR_FILENO)\n  else\n    {\n      if (PRI <= zlog_default->maxlvl[ZLOG_DEST_STDOUT])\n        DUMP(STDOUT_FILENO)\n      /* Remove trailing '\\n' for monitor and syslog */\n      *--s = '\\0';\n      if (PRI <= zlog_default->maxlvl[ZLOG_DEST_MONITOR])\n        vty_log_fixed(buf,s-buf);\n      if (PRI <= zlog_default->maxlvl[ZLOG_DEST_SYSLOG])\n\tsyslog_sigsafe(PRI|zlog_default->facility,msgstart,s-msgstart);\n    }\n#undef DUMP\n\n  zlog_backtrace_sigsafe(PRI,\n#ifdef SA_SIGINFO\n  \t\t\t program_counter\n#else\n\t\t\t NULL\n#endif\n\t\t\t);\n#undef PRI\n#undef LOC\n}\n\n/* Log a backtrace using only async-signal-safe functions.\n   Needs to be enhanced to support syslog logging. */\nvoid\nzlog_backtrace_sigsafe(int priority, void *program_counter)\n{\n#ifdef HAVE_STACK_TRACE\n  static const char pclabel[] = \"Program counter: \";\n  void *array[20];\n  int size;\n  char buf[100];\n  char *s;\n#define LOC s,buf+sizeof(buf)-s\n\n#ifdef HAVE_GLIBC_BACKTRACE\n  if (((size = backtrace(array,sizeof(array)/sizeof(array[0]))) <= 0) ||\n      ((size_t)size > sizeof(array)/sizeof(array[0])))\n    return;\n\n#define DUMP(FD) { \\\n  if (program_counter) \\\n    { \\\n      write(FD, pclabel, sizeof(pclabel)-1); \\\n      backtrace_symbols_fd(&program_counter, 1, FD); \\\n    } \\\n  write(FD, buf, s-buf);\t\\\n  backtrace_symbols_fd(array, size, FD); \\\n}\n#elif defined(HAVE_PRINTSTACK)\n#define DUMP(FD) { \\\n  if (program_counter) \\\n    write((FD), pclabel, sizeof(pclabel)-1); \\\n  write((FD), buf, s-buf); \\\n  printstack((FD)); \\\n}\n#endif /* HAVE_GLIBC_BACKTRACE, HAVE_PRINTSTACK */\n\n  s = buf;\n  s = str_append(LOC,\"Backtrace for \");\n  s = num_append(LOC,size);\n  s = str_append(LOC,\" stack frames:\\n\");\n\n  if ((logfile_fd >= 0) || ((logfile_fd = open_crashlog()) >= 0))\n    DUMP(logfile_fd)\n  if (!zlog_default)\n    DUMP(STDERR_FILENO)\n  else\n    {\n      if (priority <= zlog_default->maxlvl[ZLOG_DEST_STDOUT])\n\tDUMP(STDOUT_FILENO)\n      /* Remove trailing '\\n' for monitor and syslog */\n      *--s = '\\0';\n      if (priority <= zlog_default->maxlvl[ZLOG_DEST_MONITOR])\n\tvty_log_fixed(buf,s-buf);\n      if (priority <= zlog_default->maxlvl[ZLOG_DEST_SYSLOG])\n\tsyslog_sigsafe(priority|zlog_default->facility,buf,s-buf);\n      {\n\tint i;\n\t/* Just print the function addresses. */\n\tfor (i = 0; i < size; i++)\n\t  {\n\t    s = buf;\n\t    s = str_append(LOC,\"[bt \");\n\t    s = num_append(LOC,i);\n\t    s = str_append(LOC,\"] 0x\");\n\t    s = hex_append(LOC,(u_long)(array[i]));\n\t    *s = '\\0';\n\t    if (priority <= zlog_default->maxlvl[ZLOG_DEST_MONITOR])\n\t      vty_log_fixed(buf,s-buf);\n\t    if (priority <= zlog_default->maxlvl[ZLOG_DEST_SYSLOG])\n\t      syslog_sigsafe(priority|zlog_default->facility,buf,s-buf);\n\t  }\n      }\n    }\n#undef DUMP\n#undef LOC\n#endif /* HAVE_STRACK_TRACE */\n}\n\nvoid\nzlog_backtrace(int priority)\n{\n#ifndef HAVE_GLIBC_BACKTRACE\n  zlog(NULL, priority, \"No backtrace available on this platform.\");\n#else\n  void *array[20];\n  int size, i;\n  char **strings;\n\n  if (((size = backtrace(array,sizeof(array)/sizeof(array[0]))) <= 0) ||\n      ((size_t)size > sizeof(array)/sizeof(array[0])))\n    {\n      zlog_err(\"Cannot get backtrace, returned invalid # of frames %d \"\n\t       \"(valid range is between 1 and %lu)\",\n\t       size, (unsigned long)(sizeof(array)/sizeof(array[0])));\n      return;\n    }\n  zlog(NULL, priority, \"Backtrace for %d stack frames:\", size);\n  if (!(strings = backtrace_symbols(array, size)))\n    {\n      zlog_err(\"Cannot get backtrace symbols (out of memory?)\");\n      for (i = 0; i < size; i++)\n\tzlog(NULL, priority, \"[bt %d] %p\",i,array[i]);\n    }\n  else\n    {\n      for (i = 0; i < size; i++)\n\tzlog(NULL, priority, \"[bt %d] %s\",i,strings[i]);\n      free(strings);\n    }\n#endif /* HAVE_GLIBC_BACKTRACE */\n}\n\nvoid\nzlog (struct zlog *zl, int priority, const char *format, ...)\n{\n  va_list args;\n\n  va_start(args, format);\n  vzlog (zl, priority, format, args);\n  va_end (args);\n}\n\n#define ZLOG_FUNC(FUNCNAME,PRIORITY) \\\nvoid \\\nFUNCNAME(const char *format, ...) \\\n{ \\\n  va_list args; \\\n  va_start(args, format); \\\n  vzlog (NULL, PRIORITY, format, args); \\\n  va_end(args); \\\n}\n\nZLOG_FUNC(zlog_err, LOG_ERR)\n\nZLOG_FUNC(zlog_warn, LOG_WARNING)\n\nZLOG_FUNC(zlog_info, LOG_INFO)\n\nZLOG_FUNC(zlog_notice, LOG_NOTICE)\n\nZLOG_FUNC(zlog_debug, LOG_DEBUG)\n\n#undef ZLOG_FUNC\n\n#define PLOG_FUNC(FUNCNAME,PRIORITY) \\\nvoid \\\nFUNCNAME(struct zlog *zl, const char *format, ...) \\\n{ \\\n  va_list args; \\\n  va_start(args, format); \\\n  vzlog (zl, PRIORITY, format, args); \\\n  va_end(args); \\\n}\n\nPLOG_FUNC(plog_err, LOG_ERR)\n\nPLOG_FUNC(plog_warn, LOG_WARNING)\n\nPLOG_FUNC(plog_info, LOG_INFO)\n\nPLOG_FUNC(plog_notice, LOG_NOTICE)\n\nPLOG_FUNC(plog_debug, LOG_DEBUG)\n\n#undef PLOG_FUNC\n\nvoid\n_zlog_assert_failed (const char *assertion, const char *file,\n\t\t     unsigned int line, const char *function)\n{\n  /* Force fallback file logging? */\n  if (zlog_default && !zlog_default->fp &&\n      ((logfile_fd = open_crashlog()) >= 0) &&\n      ((zlog_default->fp = fdopen(logfile_fd, \"w\")) != NULL))\n    zlog_default->maxlvl[ZLOG_DEST_FILE] = LOG_ERR;\n  zlog(NULL, LOG_CRIT, \"Assertion `%s' failed in file %s, line %u, function %s\",\n       assertion,file,line,(function ? function : \"?\"));\n  zlog_backtrace(LOG_CRIT);\n  abort();\n}\n\n\f\n/* Open log stream */\nstruct zlog *\nopenzlog (const char *progname, zlog_proto_t protocol,\n\t  int syslog_flags, int syslog_facility)\n{\n  struct zlog *zl;\n  u_int i;\n\n  zl = XCALLOC(MTYPE_ZLOG, sizeof (struct zlog));\n\n  zl->ident = progname;\n  zl->protocol = protocol;\n  zl->facility = syslog_facility;\n  zl->syslog_options = syslog_flags;\n\n  /* Set default logging levels. */\n  for (i = 0; i < sizeof(zl->maxlvl)/sizeof(zl->maxlvl[0]); i++)\n    zl->maxlvl[i] = ZLOG_DISABLED;\n  zl->maxlvl[ZLOG_DEST_MONITOR] = LOG_DEBUG;\n  zl->default_lvl = LOG_DEBUG;\n\n  openlog (progname, syslog_flags, zl->facility);\n  \n  return zl;\n}\n\nvoid\nclosezlog (struct zlog *zl)\n{\n  closelog();\n  fclose (zl->fp);\n\n  XFREE (MTYPE_ZLOG, zl);\n}\n\n/* Called from command.c. */\nvoid\nzlog_set_level (struct zlog *zl, zlog_dest_t dest, int log_level)\n{\n  if (zl == NULL)\n    zl = zlog_default;\n\n  zl->maxlvl[dest] = log_level;\n}\n\nint\nzlog_set_file (struct zlog *zl, const char *filename, int log_level)\n{\n  FILE *fp;\n  mode_t oldumask;\n\n  /* There is opend file.  */\n  zlog_reset_file (zl);\n\n  /* Set default zl. */\n  if (zl == NULL)\n    zl = zlog_default;\n\n  /* Open file. */\n  oldumask = umask (0777 & ~LOGFILE_MASK);\n  fp = fopen (filename, \"a\");\n  umask(oldumask);\n  if (fp == NULL)\n    return 0;\n\n  /* Set flags. */\n  zl->filename = strdup (filename);\n  zl->maxlvl[ZLOG_DEST_FILE] = log_level;\n  zl->fp = fp;\n  logfile_fd = fileno(fp);\n\n  return 1;\n}\n\n/* Reset opend file. */\nint\nzlog_reset_file (struct zlog *zl)\n{\n  if (zl == NULL)\n    zl = zlog_default;\n\n  if (zl->fp)\n    fclose (zl->fp);\n  zl->fp = NULL;\n  logfile_fd = -1;\n  zl->maxlvl[ZLOG_DEST_FILE] = ZLOG_DISABLED;\n\n  if (zl->filename)\n    free (zl->filename);\n  zl->filename = NULL;\n\n  return 1;\n}\n\n/* Reopen log file. */\nint\nzlog_rotate (struct zlog *zl)\n{\n  int level;\n\n  if (zl == NULL)\n    zl = zlog_default;\n\n  if (zl->fp)\n    fclose (zl->fp);\n  zl->fp = NULL;\n  logfile_fd = -1;\n  level = zl->maxlvl[ZLOG_DEST_FILE];\n  zl->maxlvl[ZLOG_DEST_FILE] = ZLOG_DISABLED;\n\n  if (zl->filename)\n    {\n      mode_t oldumask;\n      int save_errno;\n\n      oldumask = umask (0777 & ~LOGFILE_MASK);\n      zl->fp = fopen (zl->filename, \"a\");\n      save_errno = errno;\n      umask(oldumask);\n      if (zl->fp == NULL)\n        {\n\t  zlog_err(\"Log rotate failed: cannot open file %s for append: %s\",\n\t  \t   zl->filename, safe_strerror(save_errno));\n\t  return -1;\n        }\t\n      logfile_fd = fileno(zl->fp);\n      zl->maxlvl[ZLOG_DEST_FILE] = level;\n    }\n\n  return 1;\n}\n\f\n/* Message lookup function. */\nconst char *\nlookup (struct message *mes, int key)\n{\n  struct message *pnt;\n\n  for (pnt = mes; pnt->key != 0; pnt++) \n    if (pnt->key == key) \n      return pnt->str;\n\n  return \"\";\n}\n\n/* Older/faster version of message lookup function, but requires caller to pass\n   in the array size (instead of relying on a 0 key to terminate the search). */\nconst char *\nmes_lookup (struct message *meslist, int max, int index)\n{\n  /* first check for best case: index is in range and matches the key\n     value in that slot */\n  if ((index >= 0) && (index < max) && (meslist[index].key == index))\n    return meslist[index].str;\n\n  /* fall back to linear search */\n  {\n    int i;\n\n    for (i = 0; i < max; i++, meslist++)\n      {\n\tif (meslist->key == index)\n\t  {\n\t    zlog_debug (\"message index %d [%s] found in position %d (max is %d)\",\n\t\t      index, meslist->str, i, max);\n\t    return meslist->str;\n\t  }\n      }\n  }\n  zlog_err(\"message index %d not found (max is %d)\", index, max);\n  return NULL;\n}\n\n/* Wrapper around strerror to handle case where it returns NULL. */\nconst char *\nsafe_strerror(int errnum)\n{\n  const char *s = strerror(errnum);\n  return (s != NULL) ? s : \"Unknown error\";\n}\n\nstruct zebra_desc_table\n{\n  unsigned int type;\n  const char *string;\n  char chr;\n};\n\n#define DESC_ENTRY(T,S,C) [(T)] = { (T), (S), (C) }\nstatic const struct zebra_desc_table route_types[] = {\n  DESC_ENTRY\t(ZEBRA_ROUTE_SYSTEM,\t\"system\",\t'X' ),\n  DESC_ENTRY\t(ZEBRA_ROUTE_KERNEL,\t\"kernel\",\t'K' ),\n  DESC_ENTRY\t(ZEBRA_ROUTE_CONNECT,\t\"connected\",\t'C' ),\n  DESC_ENTRY\t(ZEBRA_ROUTE_STATIC,\t\"static\",\t'S' ),\n  DESC_ENTRY\t(ZEBRA_ROUTE_RIP,\t\"rip\",\t\t'R' ),\n  DESC_ENTRY\t(ZEBRA_ROUTE_RIPNG,\t\"ripng\",\t'R' ),\n  DESC_ENTRY\t(ZEBRA_ROUTE_OSPF,\t\"ospf\",\t\t'O' ),\n  DESC_ENTRY\t(ZEBRA_ROUTE_OSPF6,\t\"ospf6\",\t'O' ),\n  DESC_ENTRY\t(ZEBRA_ROUTE_ISIS,\t\"isis\",\t\t'I' ),\n  DESC_ENTRY\t(ZEBRA_ROUTE_BGP,\t\"bgp\",\t\t'B' ),\n  DESC_ENTRY\t(ZEBRA_ROUTE_HSLS,\t\"hsls\",\t\t'H' ),\n};\n#undef DESC_ENTRY\n\n#define DESC_ENTRY(T) [(T)] = { (T), (#T), '\\0' }\nstatic const struct zebra_desc_table command_types[] = {\n  DESC_ENTRY\t(ZEBRA_INTERFACE_ADD),\n  DESC_ENTRY\t(ZEBRA_INTERFACE_DELETE),\n  DESC_ENTRY\t(ZEBRA_INTERFACE_ADDRESS_ADD),\n  DESC_ENTRY\t(ZEBRA_INTERFACE_ADDRESS_DELETE),\n  DESC_ENTRY\t(ZEBRA_INTERFACE_UP),\n  DESC_ENTRY\t(ZEBRA_INTERFACE_DOWN),\n  DESC_ENTRY\t(ZEBRA_IPV4_ROUTE_ADD),\n  DESC_ENTRY\t(ZEBRA_IPV4_ROUTE_DELETE),\n  DESC_ENTRY\t(ZEBRA_IPV6_ROUTE_ADD),\n  DESC_ENTRY\t(ZEBRA_IPV6_ROUTE_DELETE),\n  DESC_ENTRY\t(ZEBRA_REDISTRIBUTE_ADD),\n  DESC_ENTRY\t(ZEBRA_REDISTRIBUTE_DELETE),\n  DESC_ENTRY\t(ZEBRA_REDISTRIBUTE_DEFAULT_ADD),\n  DESC_ENTRY\t(ZEBRA_REDISTRIBUTE_DEFAULT_DELETE),\n  DESC_ENTRY\t(ZEBRA_IPV4_NEXTHOP_LOOKUP),\n  DESC_ENTRY\t(ZEBRA_IPV6_NEXTHOP_LOOKUP),\n  DESC_ENTRY\t(ZEBRA_IPV4_IMPORT_LOOKUP),\n  DESC_ENTRY\t(ZEBRA_IPV6_IMPORT_LOOKUP),\n  DESC_ENTRY\t(ZEBRA_INTERFACE_RENAME),\n  DESC_ENTRY\t(ZEBRA_ROUTER_ID_ADD),\n  DESC_ENTRY\t(ZEBRA_ROUTER_ID_DELETE),\n  DESC_ENTRY\t(ZEBRA_ROUTER_ID_UPDATE),\n};\n#undef DESC_ENTRY\n\nstatic const struct zebra_desc_table unknown = { 0, \"unknown\", '?' };\n\nstatic const struct zebra_desc_table *\nzroute_lookup(u_int zroute)\n{\n  u_int i;\n\n  if (zroute >= sizeof(route_types)/sizeof(route_types[0]))\n    {\n      zlog_err(\"unknown zebra route type: %u\", zroute);\n      return &unknown;\n    }\n  if (zroute == route_types[zroute].type)\n    return &route_types[zroute];\n  for (i = 0; i < sizeof(route_types)/sizeof(route_types[0]); i++)\n    {\n      if (zroute == route_types[i].type)\n        {\n\t  zlog_warn(\"internal error: route type table out of order \"\n\t\t    \"while searching for %u, please notify developers\", zroute);\n\t  return &route_types[i];\n        }\n    }\n  zlog_err(\"internal error: cannot find route type %u in table!\", zroute);\n  return &unknown;\n}\n\nconst char *\nzebra_route_string(u_int zroute)\n{\n  return zroute_lookup(zroute)->string;\n}\n\nchar\nzebra_route_char(u_int zroute)\n{\n  return zroute_lookup(zroute)->chr;\n}\n\nconst char *\nzserv_command_string (unsigned int command)\n{\n  if (command >= sizeof(command_types)/sizeof(command_types[0]))\n    {\n      zlog_err (\"unknown zserv command type: %u\", command);\n      return unknown.string;\n    }\n  return command_types[command].string;\n}\n\n#define RTSIZE\t(sizeof(route_types)/sizeof(route_types[0]))\n\nint\nproto_name2num(const char *s)\n{\n   unsigned i;\n\n   for (i=0; i<RTSIZE; ++i)\n     if (strcasecmp(s, route_types[i].string) == 0)\n       return route_types[i].type;\n   return -1;\n}\n#undef RTSIZE\n", "2007-07-27 Paul Jakma <paul.jakma@sun.com>\n\n\t* bgp_capability_test.c: new, capability parser unit tests.\n\t* Makefile.am: add previous.\n\n2006-08-26 Paul Jakma <paul.jakma@sun.com>\n\n\t* heavy-wq.c: (slow_func_del,slow_func) update to match workqueue\n\t  changes\n\n2006-08-06 Paul Jakma <paul.jakma@sun.com>\n\n\t* aspath_test.c: (validate) Fix the sense of the aspath_loop_check,\n\t  which was the wrong way around and had actually been testing for\n\t  aspath_loop_check to be buggy.\n\n2006-05-28 Paul Jakma <paul.jakma@sun.com>\n\n\t* test-sig.c: (main) configure logging, there's no terminal\n\t  to write to for one thing, but we do want stdout, and we\n\t  don't want a test to spam syslog.\n\n2006-03-16 Paul Jakma <paul.jakma@sun.com>\n\n\t* heavy-wq.c: (heavy_wq_init) delay is gone from workqueue\n\t  spec.\n\t* aspath_test.c: (test_segments) Add an AS_SET with redundant\n\t  ASNs.\n\t  ({empty_prepend,prepend,parse}_test) add static qualifiers\n\n2006-01-16 Paul Jakma <paul.jakma@sun.com>\n\n\t* aspath_test.c: (validate) free the temporary aspaths.\n\t  (empty_get_test) ditto.\n\n2006-01-10 Paul Jakma <paul.jakma@sun.com>\n\n\t* test-stream.c: new file, small unit test for new\n\t  resize and {put,get}-quad stream functions.\n\t* Makefile.am: build teststream unit test.\n\n2005-11-23 Paul Jakma <paul.jakma@sun.com>\n\n\t* aspath_test.c: Add an empty aspath to test segments, and to\n\t  compare tests.\n\t  Add a segment identical to seq1, but with one extra asn.\n\t  Fix bogus free of stream in make_aspath for case where\n\t  no stream was allocated (empty path data).\n\n2005-10-11 Paul Jakma <paul.jakma@sun.com>\n\n\t* test-privs.c: Privileges unit test.\n\t* Makefile.am: build testprivs\n\t* aspath_test.c: fix a few sign warnings\n\n2005-09-06 Paul Jakma <paul@dishone.st>\n\n\t* aspath_test.c: Test bgp_aspath functionality.\n\t* Makefile.am: build aspathtest\n\t* ChangeLog: Fix date of previous commit\n\n2005-09-06 Paul Jakma <paul@dishone.st>\n\n\t* test-buffer.c: include memory.h\n          (main) call memory_init().\n\t\n2004-09-05 Paul Jakma <paul@dishone.st>\n\n\t* heavy-wq.c: (slow_func_del,slow_func_err) make them take\n\t  void * argument to shut up silly gcc warning.\n\t  \n2004-05-25 Paul Jakma <paul@dishone.st>\n\n\t* main.c: new file, common 'main' portion which then calls\n\t  test_init.\n\t* heavy.c: remove common portions now in 'main.\n\t* heavy-wq.c: ditto\n\t* heavy-thread.c: ditto\n\t* heavy*.c: Set the slow_function iteration number lower, to 300, it\n\t  was several orders of magnitude too 'slow' to be useful. :)\n\t* Makefile.am: main is a source of the tests. heavy should link\n\t  to the math library.\n\n2004-05-22 Paul Jakma <paul@dishone.st>\n\n\t* heavy-thread.c: Andrew Schorr's adaptation of heavy.c to use a\n\t  background thread to avoid responsiveness problems.\n\t* Makefile.am: Build heavythread\n\n2004-05-21 Paul Jakma <paul@dishone.st>\n\n\t* heavy.c: Add a timer thread to demonstrate thread interactivity,\n\t  Add a daemon_exit command to assist with debugging (eg for memory\n\t  tracers, etc..)\n\n2004-05-19 Paul Jakma <paul@dishone.st>\n\n\t* heavy.c: test programme to show how long-running functions\n\t  kill responsiveness. Demonstrating the most niggly problem \n\t  left in bgpd.\n\n2004-05-13 Paul Jakma <paul@dishone.st>\n\n\t* test-buffer.c: Andrew's buffer tester\n\t* test-memory.c: basic memory tester\n\t* Makefile.am: Add new tests\n", "INCLUDES = @INCLUDES@ -I.. -I$(top_srcdir) -I$(top_srcdir)/lib\nDEFS = @DEFS@ $(LOCAL_OPTS) -DSYSCONFDIR=\\\"$(sysconfdir)/\\\"\n\nnoinst_PROGRAMS = testsig testbuffer testmemory heavy heavywq heavythread \\\n\t\taspathtest testprivs teststream testbgpcap\ntestsig_SOURCES = test-sig.c\ntestbuffer_SOURCES = test-buffer.c\ntestmemory_SOURCES = test-memory.c\ntestprivs_SOURCES = test-privs.c\nteststream_SOURCES = test-stream.c\nheavy_SOURCES = heavy.c main.c\nheavywq_SOURCES = heavy-wq.c main.c\nheavythread_SOURCES = heavy-thread.c main.c\naspathtest_SOURCES = aspath_test.c\ntestbgpcap_SOURCES = bgp_capability_test.c\n\ntestsig_LDADD = ../lib/libzebra.la @LIBCAP@\ntestbuffer_LDADD = ../lib/libzebra.la @LIBCAP@\ntestmemory_LDADD = ../lib/libzebra.la @LIBCAP@\ntestprivs_LDADD = ../lib/libzebra.la @LIBCAP@\nteststream_LDADD = ../lib/libzebra.la @LIBCAP@\nheavy_LDADD = ../lib/libzebra.la @LIBCAP@ -lm\nheavywq_LDADD = ../lib/libzebra.la @LIBCAP@ -lm\nheavythread_LDADD = ../lib/libzebra.la @LIBCAP@ -lm\naspathtest_LDADD = ../lib/libzebra.la @LIBCAP@ -lm ../bgpd/libbgp.a\ntestbgpcap_LDADD = ../lib/libzebra.la @LIBCAP@ -lm ../bgpd/libbgp.a\n"], "filenames": ["bgpd/ChangeLog", "bgpd/bgp_debug.h", "bgpd/bgp_open.c", "bgpd/bgp_open.h", "bgpd/bgp_packet.c", "bgpd/bgp_vty.c", "lib/ChangeLog", "lib/log.c", "tests/ChangeLog", "tests/Makefile.am"], "buggy_code_start_loc": [0, 113, 28, 24, 1376, 6752, 0, 776, 0, 5], "buggy_code_end_loc": [0, 114, 608, 84, 2136, 7476, 0, 777, 0, 24], "fixing_code_start_loc": [1, 113, 29, 24, 1375, 6752, 1, 776, 1, 5], "fixing_code_end_loc": [39, 114, 689, 104, 2132, 7476, 9, 777, 6, 27], "type": "CWE-125", "message": "An out-of-bounds read in the BGP daemon of FRRouting FRR before 8.4 may lead to a segmentation fault and denial of service. This occurs in bgp_capability_msg_parse in bgpd/bgp_packet.c.", "other": {"cve": {"id": "CVE-2022-37032", "sourceIdentifier": "cve@mitre.org", "published": "2022-09-19T22:15:11.367", "lastModified": "2023-03-08T01:06:27.520", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An out-of-bounds read in the BGP daemon of FRRouting FRR before 8.4 may lead to a segmentation fault and denial of service. This occurs in bgp_capability_msg_parse in bgpd/bgp_packet.c."}, {"lang": "es", "value": "Una lectura fuera de l\u00edmites en el demonio BGP de FRRouting FRR versiones anteriores a 8.4, puede conllevar a un fallo de segmentaci\u00f3n y una denegaci\u00f3n de servicio. Esto ocurre en la funci\u00f3n bgp_capability_msg_parse en el archivo bgpd/bgp_packet.c"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:frrouting:frrouting:*:*:*:*:*:*:*:*", "versionEndExcluding": "8.4", "matchCriteriaId": "E25A379B-FD57-4CF9-AA1B-278653FAAD29"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}], "references": [{"url": "https://bugzilla.suse.com/show_bug.cgi?id=1202023", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/FRRouting/frr/commit/6d58272b4cf96f0daa846210dd2104877900f921", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/FRRouting/frr/commit/ff6db1027f8f36df657ff2e5ea167773752537ed", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/11/msg00039.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2023/dsa-5362", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FRRouting/frr/commit/6d58272b4cf96f0daa846210dd2104877900f921"}}