{"buggy_code": ["/** @file mat5.c\n * Matlab MAT version 5 file functions\n * @ingroup MAT\n */\n/*\n * Copyright (c) 2005-2019, Christopher C. Hulbert\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* FIXME: Implement Unicode support */\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#if defined(_MSC_VER) || defined(__MINGW32__)\n#   define SIZE_T_FMTSTR \"Iu\"\n#   define strdup _strdup\n#else\n#   define SIZE_T_FMTSTR \"zu\"\n#endif\n#include \"matio_private.h\"\n#include \"mat5.h\"\n\n/** Get type from tag */\n#define TYPE_FROM_TAG(a)          ( ((a) & 0x000000ff) <= MAT_T_FUNCTION ) ? (enum matio_types)((a) & 0x000000ff) : MAT_T_UNKNOWN\n/** Get class from array flag */\n#define CLASS_FROM_ARRAY_FLAGS(a) ( ((a) & 0x000000ff) <= MAT_C_OPAQUE ) ? ((enum matio_classes)((a) & 0x000000ff)) : MAT_C_EMPTY\n/** Class type mask */\n#define CLASS_TYPE_MASK           0x000000ff\n\nstatic mat_complex_split_t null_complex_data = {NULL,NULL};\n\n/*===========================================================================\n *  Private functions\n *===========================================================================\n */\nstatic int GetTypeBufSize(matvar_t *matvar, size_t *size);\nstatic int GetStructFieldBufSize(matvar_t *matvar, size_t *size);\nstatic int GetCellArrayFieldBufSize(matvar_t *matvar, size_t *size);\nstatic void SetFieldNames(matvar_t *matvar, char *buf, size_t nfields,\n                  mat_uint32_t fieldname_length);\nstatic size_t ReadSparse(mat_t *mat, matvar_t *matvar, int *n, mat_int32_t **v);\n#if defined(HAVE_ZLIB)\nstatic int GetMatrixMaxBufSize(matvar_t *matvar, size_t *size);\n#endif\nstatic int GetEmptyMatrixMaxBufSize(const char *name, int rank, size_t *size);\nstatic size_t WriteCharData(mat_t *mat, void *data, int N,enum matio_types data_type);\nstatic size_t ReadNextCell( mat_t *mat, matvar_t *matvar );\nstatic size_t ReadNextStructField( mat_t *mat, matvar_t *matvar );\nstatic size_t ReadNextFunctionHandle(mat_t *mat, matvar_t *matvar);\nstatic size_t ReadRankDims(mat_t *mat, matvar_t *matvar, enum matio_types data_type,\n                  mat_uint32_t nbytes);\nstatic int    WriteType(mat_t *mat,matvar_t *matvar);\nstatic int    WriteCellArrayField(mat_t *mat,matvar_t *matvar );\nstatic int    WriteStructField(mat_t *mat,matvar_t *matvar);\nstatic int    WriteData(mat_t *mat,void *data,int N,enum matio_types data_type);\nstatic size_t Mat_WriteEmptyVariable5(mat_t *mat,const char *name,int rank,\n                  size_t *dims);\nstatic void   Mat_VarReadNumeric5(mat_t *mat,matvar_t *matvar,void *data,size_t N);\n#if defined(HAVE_ZLIB)\nstatic size_t WriteCompressedCharData(mat_t *mat,z_streamp z,void *data,int N,\n                  enum matio_types data_type);\nstatic size_t WriteCompressedData(mat_t *mat,z_streamp z,void *data,int N,\n                  enum matio_types data_type);\nstatic size_t WriteCompressedTypeArrayFlags(mat_t *mat,matvar_t *matvar,\n                  z_streamp z);\nstatic size_t WriteCompressedType(mat_t *mat,matvar_t *matvar,z_streamp z);\nstatic size_t WriteCompressedCellArrayField(mat_t *mat,matvar_t *matvar,\n                  z_streamp z);\nstatic size_t WriteCompressedStructField(mat_t *mat,matvar_t *matvar,\n                  z_streamp z);\nstatic size_t Mat_WriteCompressedEmptyVariable5(mat_t *mat,const char *name,\n                  int rank,size_t *dims,z_streamp z);\n#endif\n\n/** @brief determines the number of bytes for a given class type\n *\n * @ingroup mat_internal\n * @param matvar MAT variable\n * @param size the number of bytes needed to store the MAT variable\n * @return 0 on success\n */\nstatic int\nGetTypeBufSize(matvar_t *matvar, size_t *size)\n{\n    int err;\n    size_t nBytes, data_bytes;\n    size_t tag_size = 8;\n    size_t nelems = 1;\n    size_t rank_size;\n\n    *size = 0;\n\n    err = SafeMulDims(matvar, &nelems);\n    if ( err )\n        return 1;\n\n    /* Add rank and dimensions, padded to an 8 byte block */\n    err = SafeMul(&rank_size, matvar->rank, 4);\n    if ( err )\n        return 1;\n\n    if ( matvar->rank % 2 )\n        nBytes = tag_size + 4;\n    else\n        nBytes = tag_size;\n\n    err = SafeAdd(&nBytes, nBytes, rank_size);\n    if ( err )\n        return 1;\n\n    switch ( matvar->class_type ) {\n        case MAT_C_STRUCT:\n        {\n            matvar_t **fields = (matvar_t**)matvar->data;\n            size_t nfields = matvar->internal->num_fields;\n            size_t maxlen = 0, i, field_buf_size;\n\n            for ( i = 0; i < nfields; i++ ) {\n                char *fieldname = matvar->internal->fieldnames[i];\n                if ( NULL != fieldname && strlen(fieldname) > maxlen )\n                    maxlen = strlen(fieldname);\n            }\n            maxlen++;\n            while ( nfields*maxlen % 8 != 0 )\n                maxlen++;\n\n            err = SafeMul(&field_buf_size, maxlen, nfields);\n            err |= SafeAdd(&nBytes, nBytes, tag_size + tag_size);\n            err |= SafeAdd(&nBytes, nBytes, field_buf_size);\n            if ( err )\n                return 1;\n\n            /* FIXME: Add bytes for the fieldnames */\n            if ( NULL != fields && nfields > 0 ) {\n                size_t nelems_x_nfields = 1;\n                err = SafeMul(&nelems_x_nfields, nelems, nfields);\n                if ( err )\n                    return 1;\n\n                for ( i = 0; i < nelems_x_nfields; i++ ) {\n                    err = GetStructFieldBufSize(fields[i], &field_buf_size);\n                    err |= SafeAdd(&nBytes, nBytes, tag_size);\n                    err |= SafeAdd(&nBytes, nBytes, field_buf_size);\n                    if ( err )\n                        return 1;\n                }\n            }\n            break;\n        }\n        case MAT_C_CELL:\n        {\n            matvar_t **cells = (matvar_t**)matvar->data;\n\n            if ( matvar->nbytes == 0 || matvar->data_size == 0 )\n                break;\n\n            nelems = matvar->nbytes / matvar->data_size;\n            if ( NULL != cells && nelems > 0 ) {\n                size_t i, field_buf_size;\n                for ( i = 0; i < nelems; i++ ) {\n                    err = GetCellArrayFieldBufSize(cells[i], &field_buf_size);\n                    err |= SafeAdd(&nBytes, nBytes, tag_size);\n                    err |= SafeAdd(&nBytes, nBytes, field_buf_size);\n                    if ( err )\n                        return 1;\n                }\n            }\n            break;\n        }\n        case MAT_C_SPARSE:\n        {\n            mat_sparse_t *sparse = (mat_sparse_t*)matvar->data;\n\n            err = SafeMul(&data_bytes, sparse->nir, sizeof(mat_int32_t));\n            if ( data_bytes % 8 )\n                err |= SafeAdd(&data_bytes, data_bytes, 8 - data_bytes % 8);\n            err |= SafeAdd(&nBytes, nBytes, tag_size);\n            err |= SafeAdd(&nBytes, nBytes, data_bytes);\n\n            err |= SafeMul(&data_bytes, sparse->njc, sizeof(mat_int32_t));\n            if ( data_bytes % 8 )\n                err |= SafeAdd(&data_bytes, data_bytes, 8 - data_bytes % 8);\n            err |= SafeAdd(&nBytes, nBytes, tag_size);\n            err |= SafeAdd(&nBytes, nBytes, data_bytes);\n\n            err |= SafeMul(&data_bytes, sparse->ndata, Mat_SizeOf(matvar->data_type));\n            if ( data_bytes % 8 )\n                err |= SafeAdd(&data_bytes, data_bytes, 8 - data_bytes % 8);\n            err |= SafeAdd(&nBytes, nBytes, tag_size);\n            err |= SafeAdd(&nBytes, nBytes, data_bytes);\n\n            if ( matvar->isComplex ) {\n                err |= SafeAdd(&nBytes, nBytes, tag_size);\n                err |= SafeAdd(&nBytes, nBytes, data_bytes);\n            }\n\n            if ( err )\n                return 1;\n\n            break;\n        }\n        case MAT_C_CHAR:\n            if ( MAT_T_UINT8 == matvar->data_type ||\n                 MAT_T_INT8 == matvar->data_type )\n                err = SafeMul(&data_bytes, nelems, Mat_SizeOf(MAT_T_UINT16));\n            else\n                err = SafeMul(&data_bytes, nelems, Mat_SizeOf(matvar->data_type));\n            if ( data_bytes % 8 )\n                err |= SafeAdd(&data_bytes, data_bytes, 8 - data_bytes % 8);\n\n            err |= SafeAdd(&nBytes, nBytes, tag_size);\n            err |= SafeAdd(&nBytes, nBytes, data_bytes);\n\n            if ( matvar->isComplex ) {\n                err |= SafeAdd(&nBytes, nBytes, tag_size);\n                err |= SafeAdd(&nBytes, nBytes, data_bytes);\n            }\n\n            if ( err )\n                return 1;\n\n            break;\n        default:\n            err = SafeMul(&data_bytes, nelems, Mat_SizeOf(matvar->data_type));\n            if ( data_bytes % 8 )\n                err |= SafeAdd(&data_bytes, data_bytes, 8 - data_bytes % 8);\n\n            err |= SafeAdd(&nBytes, nBytes, tag_size);\n            err |= SafeAdd(&nBytes, nBytes, data_bytes);\n\n            if ( matvar->isComplex ) {\n                err |= SafeAdd(&nBytes, nBytes, tag_size);\n                err |= SafeAdd(&nBytes, nBytes, data_bytes);\n            }\n\n            if ( err )\n                return 1;\n    } /* switch ( matvar->class_type ) */\n\n    *size = nBytes;\n    return 0;\n}\n\n/** @brief determines the number of bytes needed to store the given struct field\n *\n * @ingroup mat_internal\n * @param matvar field of a structure\n * @param size the number of bytes needed to store the struct field\n * @return 0 on success\n */\nstatic int\nGetStructFieldBufSize(matvar_t *matvar, size_t *size)\n{\n    int err;\n    size_t nBytes = 0, type_buf_size;\n    size_t tag_size = 8, array_flags_size = 8;\n\n    *size = 0;\n\n    if ( matvar == NULL )\n        return GetEmptyMatrixMaxBufSize(NULL, 2, size);\n\n    /* Add the Array Flags tag and space to the number of bytes */\n    nBytes += tag_size + array_flags_size;\n\n    /* In a struct field, the name is just a tag with 0 bytes */\n    nBytes += tag_size;\n\n    err = GetTypeBufSize(matvar, &type_buf_size);\n    err |= SafeAdd(&nBytes, nBytes, type_buf_size);\n    if ( err )\n        return 1;\n\n    *size = nBytes;\n    return 0;\n}\n\n/** @brief determines the number of bytes needed to store the cell array element\n *\n * @ingroup mat_internal\n * @param matvar MAT variable\n * @param size the number of bytes needed to store the variable\n * @return 0 on success\n */\nstatic int\nGetCellArrayFieldBufSize(matvar_t *matvar, size_t *size)\n{\n    int err;\n    size_t nBytes = 0, type_buf_size;\n    size_t tag_size = 8, array_flags_size = 8;\n\n    *size = 0;\n\n    if ( matvar == NULL )\n        return 1;\n\n    /* Add the Array Flags tag and space to the number of bytes */\n    nBytes += tag_size + array_flags_size;\n\n    /* In an element of a cell array, the name is just a tag with 0 bytes */\n    nBytes += tag_size;\n\n    err = GetTypeBufSize(matvar, &type_buf_size);\n    err |= SafeAdd(&nBytes, nBytes, type_buf_size);\n    if ( err )\n        return 1;\n\n    *size = nBytes;\n    return 0;\n}\n\n/** @brief determines the number of bytes needed to store the given variable\n *\n * @ingroup mat_internal\n * @param matvar MAT variable\n * @param rank rank of the variable\n * @param size the number of bytes needed to store the variable\n * @return 0 on success\n */\nstatic int\nGetEmptyMatrixMaxBufSize(const char *name, int rank, size_t *size)\n{\n    int err = 0;\n    size_t nBytes = 0, len, rank_size;\n    size_t tag_size = 8, array_flags_size = 8;\n\n    /* Add the Array Flags tag and space to the number of bytes */\n    nBytes += tag_size + array_flags_size;\n\n    /* Get size of variable name, pad it to an 8 byte block, and add it to nBytes */\n    if ( NULL != name )\n        len = strlen(name);\n    else\n        len = 4;\n\n    if ( len <= 4 ) {\n        nBytes += tag_size;\n    } else {\n        nBytes += tag_size;\n        if ( len % 8 )\n            err |= SafeAdd(&len, len, 8 - len % 8);\n\n        err |= SafeAdd(&nBytes, nBytes, len);\n    }\n\n    /* Add rank and dimensions, padded to an 8 byte block */\n    err |= SafeMul(&rank_size, rank, 4);\n    if ( rank % 2 )\n        err |= SafeAdd(&nBytes, nBytes, tag_size + 4);\n    else\n        err |= SafeAdd(&nBytes, nBytes, tag_size);\n\n    err |= SafeAdd(&nBytes, nBytes, rank_size);\n    /* Data tag */\n    err |= SafeAdd(&nBytes, nBytes, tag_size);\n\n    if ( err )\n        return 1;\n\n    *size = nBytes;\n    return 0;\n}\n\nstatic void\nSetFieldNames(matvar_t *matvar, char *buf, size_t nfields, mat_uint32_t fieldname_length)\n{\n    size_t i;\n    matvar->internal->num_fields = nfields;\n    matvar->internal->fieldnames =\n        (char**)calloc(nfields,sizeof(*matvar->internal->fieldnames));\n    if ( NULL != matvar->internal->fieldnames ) {\n        for ( i = 0; i < nfields; i++ ) {\n            matvar->internal->fieldnames[i] = (char*)malloc(fieldname_length);\n            if ( NULL != matvar->internal->fieldnames[i] ) {\n                memcpy(matvar->internal->fieldnames[i], buf+i*fieldname_length, fieldname_length);\n                matvar->internal->fieldnames[i][fieldname_length-1] = '\\0';\n            }\n        }\n    }\n}\n\nstatic size_t\nReadSparse(mat_t *mat, matvar_t *matvar, int *n, mat_int32_t **v)\n{\n    int data_in_tag = 0;\n    enum matio_types packed_type;\n    mat_uint32_t tag[2];\n    size_t bytesread = 0;\n    mat_int32_t N = 0;\n\n    if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {\n#if defined(HAVE_ZLIB)\n        matvar->internal->z->avail_in = 0;\n        InflateDataType(mat,matvar->internal->z,tag);\n        if ( mat->byteswap )\n            (void)Mat_uint32Swap(tag);\n        packed_type = TYPE_FROM_TAG(tag[0]);\n        if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */\n            data_in_tag = 1;\n            N = (tag[0] & 0xffff0000) >> 16;\n        } else {\n            data_in_tag = 0;\n            (void)ReadCompressedInt32Data(mat,matvar->internal->z,\n                        (mat_int32_t*)&N,MAT_T_INT32,1);\n        }\n#endif\n    } else {\n        bytesread += fread(tag,4,1,(FILE*)mat->fp);\n        if ( mat->byteswap )\n            (void)Mat_uint32Swap(tag);\n        packed_type = TYPE_FROM_TAG(tag[0]);\n        if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */\n            data_in_tag = 1;\n            N = (tag[0] & 0xffff0000) >> 16;\n        } else {\n            data_in_tag = 0;\n            bytesread += fread(&N,4,1,(FILE*)mat->fp);\n            if ( mat->byteswap )\n                (void)Mat_int32Swap(&N);\n        }\n    }\n    *n = N / 4;\n    *v = (mat_int32_t*)malloc(*n*sizeof(mat_int32_t));\n    if ( NULL != *v ) {\n        int nBytes;\n        if ( matvar->compression == MAT_COMPRESSION_NONE ) {\n            nBytes = ReadInt32Data(mat,*v,packed_type,*n);\n            /*\n                * If the data was in the tag we started on a 4-byte\n                * boundary so add 4 to make it an 8-byte\n                */\n            if ( data_in_tag )\n                nBytes+=4;\n            if ( (nBytes % 8) != 0 )\n                (void)fseek((FILE*)mat->fp,8-(nBytes % 8),SEEK_CUR);\n#if defined(HAVE_ZLIB)\n        } else if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {\n            nBytes = ReadCompressedInt32Data(mat,matvar->internal->z,\n                            *v,packed_type,*n);\n            /*\n                * If the data was in the tag we started on a 4-byte\n                * boundary so add 4 to make it an 8-byte\n                */\n            if ( data_in_tag )\n                nBytes+=4;\n            if ( (nBytes % 8) != 0 )\n                InflateSkip(mat,matvar->internal->z,8-(nBytes % 8));\n#endif\n        }\n    } else {\n        Mat_Critical(\"Couldn't allocate memory\");\n    }\n\n    return bytesread;\n}\n\n#if defined(HAVE_ZLIB)\n/** @brief determines the number of bytes needed to store the given variable\n *\n * @ingroup mat_internal\n * @param matvar MAT variable\n * @param size the number of bytes needed to store the variable\n * @return 0 on success\n */\nstatic int\nGetMatrixMaxBufSize(matvar_t *matvar, size_t *size)\n{\n    int err = 0;\n    size_t nBytes = 0, len, type_buf_size;\n    size_t tag_size = 8, array_flags_size = 8;\n\n    if ( matvar == NULL )\n        return 1;\n\n    /* Add the Array Flags tag and space to the number of bytes */\n    nBytes += tag_size + array_flags_size;\n\n    /* Get size of variable name, pad it to an 8 byte block, and add it to nBytes */\n    if ( NULL != matvar->name )\n        len = strlen(matvar->name);\n    else\n        len = 4;\n\n    if ( len <= 4 ) {\n        nBytes += tag_size;\n    } else {\n        nBytes += tag_size;\n        if ( len % 8 )\n            err |= SafeAdd(&len, len, 8 - len % 8);\n\n        err |= SafeAdd(&nBytes, nBytes, len);\n    }\n\n    err |= GetTypeBufSize(matvar, &type_buf_size);\n    err |= SafeAdd(&nBytes, nBytes, type_buf_size);\n\n    if ( err )\n        return 1;\n\n    *size = nBytes;\n    return 0;\n}\n#endif\n\n/** @if mat_devman\n * @brief Creates a new Matlab MAT version 5 file\n *\n * Tries to create a new Matlab MAT file with the given name and optional\n * header string.  If no header string is given, the default string\n * is used containing the software, version, and date in it.  If a header\n * string is given, at most the first 116 characters is written to the file.\n * The given header string need not be the full 116 characters, but MUST be\n * NULL terminated.\n * @ingroup MAT\n * @param matname Name of MAT file to create\n * @param hdr_str Optional header string, NULL to use default\n * @return A pointer to the MAT file or NULL if it failed.  This is not a\n * simple FILE * and should not be used as one.\n * @endif\n */\nmat_t *\nMat_Create5(const char *matname,const char *hdr_str)\n{\n    FILE *fp;\n    mat_int16_t endian = 0, version;\n    mat_t *mat = NULL;\n    size_t err;\n    time_t t;\n\n    fp = fopen(matname,\"w+b\");\n    if ( !fp )\n        return NULL;\n\n    mat = (mat_t*)malloc(sizeof(*mat));\n    if ( mat == NULL ) {\n        fclose(fp);\n        return NULL;\n    }\n\n    mat->fp            = NULL;\n    mat->header        = NULL;\n    mat->subsys_offset = NULL;\n    mat->filename      = NULL;\n    mat->version       = 0;\n    mat->byteswap      = 0;\n    mat->mode          = 0;\n    mat->bof           = 128;\n    mat->next_index    = 0;\n    mat->num_datasets  = 0;\n#if defined(MAT73) && MAT73\n    mat->refs_id       = -1;\n#endif\n    mat->dir           = NULL;\n\n    t = time(NULL);\n    mat->fp       = fp;\n    mat->filename = strdup_printf(\"%s\",matname);\n    mat->mode     = MAT_ACC_RDWR;\n    mat->byteswap = 0;\n    mat->header   = (char*)malloc(128*sizeof(char));\n    mat->subsys_offset = (char*)malloc(8*sizeof(char));\n    memset(mat->header,' ',128);\n    if ( hdr_str == NULL ) {\n        err = mat_snprintf(mat->header,116,\"MATLAB 5.0 MAT-file, Platform: %s, \"\n                \"Created by: libmatio v%d.%d.%d on %s\", MATIO_PLATFORM,\n                MATIO_MAJOR_VERSION, MATIO_MINOR_VERSION, MATIO_RELEASE_LEVEL,\n                ctime(&t));\n    } else {\n        err = mat_snprintf(mat->header,116,\"%s\",hdr_str);\n    }\n    if ( err >= 116 )\n        mat->header[115] = '\\0'; /* Just to make sure it's NULL terminated */\n    memset(mat->subsys_offset,' ',8);\n    mat->version = (int)0x0100;\n    endian = 0x4d49;\n\n    version = 0x0100;\n\n    fwrite(mat->header,1,116,(FILE*)mat->fp);\n    fwrite(mat->subsys_offset,1,8,(FILE*)mat->fp);\n    fwrite(&version,2,1,(FILE*)mat->fp);\n    fwrite(&endian,2,1,(FILE*)mat->fp);\n\n    return mat;\n}\n\n/** @if mat_devman\n * @brief Writes @c data as character data\n *\n * This function uses the knowledge that the data is part of a character class\n * to avoid some pitfalls with Matlab listed below.\n *   @li Matlab character data cannot be unsigned 8-bit integers, it needs at\n *       least unsigned 16-bit integers\n *\n * @ingroup mat_internal\n * @param mat MAT file pointer\n * @param data character data to write\n * @param N Number of elements to write\n * @param data_type character data type (enum matio_types)\n * @return number of bytes written\n * @endif\n */\nstatic size_t\nWriteCharData(mat_t *mat, void *data, int N,enum matio_types data_type)\n{\n    int nBytes = 0, i;\n    size_t byteswritten = 0;\n    mat_int8_t pad1 = 0;\n\n    switch ( data_type ) {\n        case MAT_T_UINT16:\n        {\n            nBytes = N*2;\n            fwrite(&data_type,4,1,(FILE*)mat->fp);\n            fwrite(&nBytes,4,1,(FILE*)mat->fp);\n            if ( NULL != data && N > 0 )\n                fwrite(data,2,N,(FILE*)mat->fp);\n            if ( nBytes % 8 )\n                for ( i = nBytes % 8; i < 8; i++ )\n                    fwrite(&pad1,1,1,(FILE*)mat->fp);\n            break;\n        }\n        case MAT_T_INT8:\n        case MAT_T_UINT8:\n        {\n            mat_uint8_t *ptr;\n            mat_uint16_t c;\n\n            /* Matlab can't read MAT_C_CHAR as uint8, needs uint16 */\n            nBytes = N*2;\n            data_type = MAT_T_UINT16;\n            fwrite(&data_type,4,1,(FILE*)mat->fp);\n            fwrite(&nBytes,4,1,(FILE*)mat->fp);\n            ptr = (mat_uint8_t*)data;\n            if ( NULL == ptr )\n                break;\n            for ( i = 0; i < N; i++ ) {\n                c = (mat_uint16_t)*(char *)ptr;\n                fwrite(&c,2,1,(FILE*)mat->fp);\n                ptr++;\n            }\n            if ( nBytes % 8 )\n                for ( i = nBytes % 8; i < 8; i++ )\n                    fwrite(&pad1,1,1,(FILE*)mat->fp);\n            break;\n        }\n        case MAT_T_UTF8:\n        {\n            mat_uint8_t *ptr;\n\n            nBytes = N;\n            fwrite(&data_type,4,1,(FILE*)mat->fp);\n            fwrite(&nBytes,4,1,(FILE*)mat->fp);\n            ptr = (mat_uint8_t*)data;\n            if ( NULL != ptr && nBytes > 0 )\n                fwrite(ptr,1,nBytes,(FILE*)mat->fp);\n            if ( nBytes % 8 )\n                for ( i = nBytes % 8; i < 8; i++ )\n                    fwrite(&pad1,1,1,(FILE*)mat->fp);\n            break;\n        }\n        case MAT_T_UNKNOWN:\n        {\n            /* Sometimes empty char data will have MAT_T_UNKNOWN, so just write\n             * a data tag\n             */\n            nBytes = N*2;\n            data_type = MAT_T_UINT16;\n            fwrite(&data_type,4,1,(FILE*)mat->fp);\n            fwrite(&nBytes,4,1,(FILE*)mat->fp);\n            break;\n        }\n        default:\n            break;\n    }\n    byteswritten += nBytes;\n    return byteswritten;\n}\n\n#if defined(HAVE_ZLIB)\n/** @brief Writes @c data as compressed character data\n *\n * This function uses the knowledge that the data is part of a character class\n * to avoid some pitfalls with Matlab listed below.\n *   @li Matlab character data cannot be unsigned 8-bit integers, it needs at\n *       least unsigned 16-bit integers\n *\n * @ingroup mat_internal\n * @param mat MAT file pointer\n * @param z pointer to the zlib compression stream\n * @param data character data to write\n * @param N Number of elements to write\n * @param data_type character data type (enum matio_types)\n * @return number of bytes written\n */\nstatic size_t\nWriteCompressedCharData(mat_t *mat,z_streamp z,void *data,int N,\n    enum matio_types data_type)\n{\n    int data_size, data_tag[2], byteswritten = 0;\n    int buf_size = 1024;\n    mat_uint8_t   buf[1024], pad[8] = {0,};\n\n    if ( mat == NULL || mat->fp == NULL )\n        return 0;\n\n    switch ( data_type ) {\n        case MAT_T_UINT8:\n        case MAT_T_UINT16:\n        case MAT_T_UTF8:\n        case MAT_T_UTF16:\n            data_size = Mat_SizeOf(data_type);\n            data_tag[0] = MAT_T_UINT8 == data_type ? MAT_T_UTF8 : data_type;\n            data_tag[1] = N*data_size;\n            z->next_in  = ZLIB_BYTE_PTR(data_tag);\n            z->avail_in = 8;\n            do {\n                z->next_out  = buf;\n                z->avail_out = buf_size;\n                deflate(z,Z_NO_FLUSH);\n                byteswritten += fwrite(buf,1,buf_size-z->avail_out,(FILE*)mat->fp);\n            } while ( z->avail_out == 0 );\n\n            /* exit early if this is an empty data */\n            if ( NULL == data || N < 1 )\n                break;\n\n            z->next_in  = (Bytef*)data;\n            z->avail_in = data_size*N;\n            do {\n                z->next_out  = buf;\n                z->avail_out = buf_size;\n                deflate(z,Z_NO_FLUSH);\n                byteswritten += fwrite(buf,1,buf_size-z->avail_out,(FILE*)mat->fp);\n            } while ( z->avail_out == 0 );\n            /* Add/Compress padding to pad to 8-byte boundary */\n            if ( N*data_size % 8 ) {\n                z->next_in  = pad;\n                z->avail_in = 8 - (N*data_size % 8);\n                do {\n                    z->next_out  = buf;\n                    z->avail_out = buf_size;\n                    deflate(z,Z_NO_FLUSH);\n                    byteswritten += fwrite(buf,1,buf_size-z->avail_out,(FILE*)mat->fp);\n                } while ( z->avail_out == 0 );\n            }\n            break;\n        case MAT_T_UNKNOWN:\n            /* Sometimes empty char data will have MAT_T_UNKNOWN, so just write a data tag */\n            data_size = 2;\n            data_tag[0] = MAT_T_UINT16;\n            data_tag[1] = N*data_size;\n            z->next_in  = ZLIB_BYTE_PTR(data_tag);\n            z->avail_in = 8;\n            do {\n                z->next_out  = buf;\n                z->avail_out = buf_size;\n                deflate(z,Z_NO_FLUSH);\n                byteswritten += fwrite(buf,1,buf_size-z->avail_out,(FILE*)mat->fp);\n            } while ( z->avail_out == 0 );\n            break;\n        default:\n            break;\n    }\n\n    return byteswritten;\n}\n#endif\n\n/** @brief Writes the data buffer to the file\n *\n * @param mat MAT file pointer\n * @param data pointer to the data to write\n * @param N number of elements to write\n * @param data_type data type of the data\n * @return number of bytes written\n */\nstatic int\nWriteData(mat_t *mat,void *data,int N,enum matio_types data_type)\n{\n    int nBytes = 0, data_size;\n\n    if ( mat == NULL || mat->fp == NULL )\n        return 0;\n\n    data_size = Mat_SizeOf(data_type);\n    nBytes    = N*data_size;\n    fwrite(&data_type,4,1,(FILE*)mat->fp);\n    fwrite(&nBytes,4,1,(FILE*)mat->fp);\n\n    if ( data != NULL && N > 0 )\n        fwrite(data,data_size,N,(FILE*)mat->fp);\n\n    return nBytes;\n}\n\n#if defined(HAVE_ZLIB)\n/* Compresses the data buffer and writes it to the file */\nstatic size_t\nWriteCompressedData(mat_t *mat,z_streamp z,void *data,int N,\n    enum matio_types data_type)\n{\n    int nBytes = 0, data_size, data_tag[2], byteswritten = 0;\n    int buf_size = 1024;\n    mat_uint8_t buf[1024], pad[8] = {0,};\n\n    if ( mat == NULL || mat->fp == NULL )\n        return 0;\n\n    data_size   = Mat_SizeOf(data_type);\n    data_tag[0] = data_type;\n    data_tag[1] = data_size*N;\n    z->next_in  = ZLIB_BYTE_PTR(data_tag);\n    z->avail_in = 8;\n    do {\n        z->next_out  = buf;\n        z->avail_out = buf_size;\n        deflate(z,Z_NO_FLUSH);\n        byteswritten += fwrite(buf,1,buf_size-z->avail_out,(FILE*)mat->fp);\n    } while ( z->avail_out == 0 );\n\n    /* exit early if this is an empty data */\n    if ( NULL == data || N < 1 )\n        return byteswritten;\n\n    z->next_in  = (Bytef*)data;\n    z->avail_in = N*data_size;\n    do {\n        z->next_out  = buf;\n        z->avail_out = buf_size;\n        deflate(z,Z_NO_FLUSH);\n        byteswritten += fwrite(buf,1,buf_size-z->avail_out,(FILE*)mat->fp);\n    } while ( z->avail_out == 0 );\n    /* Add/Compress padding to pad to 8-byte boundary */\n    if ( N*data_size % 8 ) {\n        z->next_in  = pad;\n        z->avail_in = 8 - (N*data_size % 8);\n        do {\n            z->next_out  = buf;\n            z->avail_out = buf_size;\n            deflate(z,Z_NO_FLUSH);\n            byteswritten += fwrite(buf,1,buf_size-z->avail_out,(FILE*)mat->fp);\n        } while ( z->avail_out == 0 );\n    }\n    nBytes = byteswritten;\n    return nBytes;\n}\n#endif\n\n/** @brief Reads the next cell of the cell array in @c matvar\n *\n * @ingroup mat_internal\n * @param mat MAT file pointer\n * @param matvar MAT variable pointer\n * @return Number of bytes read\n */\nstatic size_t\nReadNextCell( mat_t *mat, matvar_t *matvar )\n{\n    size_t bytesread = 0, i;\n    int err;\n    matvar_t **cells = NULL;\n    size_t nelems = 1;\n\n    err = SafeMulDims(matvar, &nelems);\n    if ( err ) {\n        Mat_Critical(\"Integer multiplication overflow\");\n        return bytesread;\n    }\n    matvar->data_size = sizeof(matvar_t *);\n    err = SafeMul(&matvar->nbytes, nelems, matvar->data_size);\n    if ( err ) {\n        Mat_Critical(\"Integer multiplication overflow\");\n        return bytesread;\n    }\n\n    matvar->data = calloc(nelems, matvar->data_size);\n    if ( NULL == matvar->data ) {\n        if ( NULL != matvar->name )\n            Mat_Critical(\"Couldn't allocate memory for %s->data\", matvar->name);\n        return bytesread;\n    }\n    cells = (matvar_t **)matvar->data;\n\n    if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {\n#if defined(HAVE_ZLIB)\n        mat_uint32_t uncomp_buf[16] = {0,};\n        int nbytes;\n        mat_uint32_t array_flags;\n\n        for ( i = 0; i < nelems; i++ ) {\n            cells[i] = Mat_VarCalloc();\n            if ( NULL == cells[i] ) {\n                Mat_Critical(\"Couldn't allocate memory for cell %\" SIZE_T_FMTSTR, i);\n                continue;\n            }\n\n            /* Read variable tag for cell */\n            uncomp_buf[0] = 0;\n            uncomp_buf[1] = 0;\n            bytesread += InflateVarTag(mat,matvar,uncomp_buf);\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(uncomp_buf);\n                (void)Mat_uint32Swap(uncomp_buf+1);\n            }\n            nbytes = uncomp_buf[1];\n            if ( 0 == nbytes ) {\n                /* Empty cell: Memory optimization */\n                free(cells[i]->internal);\n                cells[i]->internal = NULL;\n                continue;\n            } else if ( uncomp_buf[0] != MAT_T_MATRIX ) {\n                Mat_VarFree(cells[i]);\n                cells[i] = NULL;\n                Mat_Critical(\"cells[%\" SIZE_T_FMTSTR \"], Uncompressed type not MAT_T_MATRIX\", i);\n                break;\n            }\n            cells[i]->compression = MAT_COMPRESSION_ZLIB;\n            bytesread += InflateArrayFlags(mat,matvar,uncomp_buf);\n            nbytes -= 16;\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(uncomp_buf);\n                (void)Mat_uint32Swap(uncomp_buf+1);\n                (void)Mat_uint32Swap(uncomp_buf+2);\n                (void)Mat_uint32Swap(uncomp_buf+3);\n            }\n            /* Array Flags */\n            if ( uncomp_buf[0] == MAT_T_UINT32 ) {\n               array_flags = uncomp_buf[2];\n               cells[i]->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);\n               cells[i]->isComplex  = (array_flags & MAT_F_COMPLEX);\n               cells[i]->isGlobal   = (array_flags & MAT_F_GLOBAL);\n               cells[i]->isLogical  = (array_flags & MAT_F_LOGICAL);\n               if ( cells[i]->class_type == MAT_C_SPARSE ) {\n                   /* Need to find a more appropriate place to store nzmax */\n                   cells[i]->nbytes = uncomp_buf[3];\n               }\n            } else {\n                Mat_Critical(\"Expected MAT_T_UINT32 for array tags, got %d\",\n                               uncomp_buf[0]);\n                bytesread+=InflateSkip(mat,matvar->internal->z,nbytes);\n            }\n            if ( cells[i]->class_type != MAT_C_OPAQUE ) {\n                mat_uint32_t* dims = NULL;\n                int do_clean = 0;\n                bytesread += InflateRankDims(mat,matvar,uncomp_buf,sizeof(uncomp_buf),&dims);\n                if ( NULL == dims )\n                    dims = uncomp_buf + 2;\n                else\n                    do_clean = 1;\n                nbytes -= 8;\n                if ( mat->byteswap ) {\n                    (void)Mat_uint32Swap(uncomp_buf);\n                    (void)Mat_uint32Swap(uncomp_buf+1);\n                }\n                /* Rank and Dimension */\n                if ( uncomp_buf[0] == MAT_T_INT32 ) {\n                    int j;\n                    cells[i]->rank = uncomp_buf[1];\n                    nbytes -= cells[i]->rank;\n                    cells[i]->rank /= 4;\n                    cells[i]->dims = (size_t*)malloc(cells[i]->rank*sizeof(*cells[i]->dims));\n                    if ( mat->byteswap ) {\n                        for ( j = 0; j < cells[i]->rank; j++ )\n                            cells[i]->dims[j] = Mat_uint32Swap(dims + j);\n                    } else {\n                        for ( j = 0; j < cells[i]->rank; j++ )\n                            cells[i]->dims[j] = dims[j];\n                    }\n                    if ( cells[i]->rank % 2 != 0 )\n                        nbytes -= 4;\n                }\n                if ( do_clean )\n                    free(dims);\n                /* Variable name tag */\n                bytesread += InflateVarTag(mat,matvar,uncomp_buf);\n                nbytes -= 8;\n                if ( mat->byteswap ) {\n                    (void)Mat_uint32Swap(uncomp_buf);\n                    (void)Mat_uint32Swap(uncomp_buf+1);\n                }\n                /* Handle cell elements written with a variable name */\n                if ( uncomp_buf[1] > 0 ) {\n                    /* Name of variable */\n                    if ( uncomp_buf[0] == MAT_T_INT8 ) {    /* Name not in tag */\n                        mat_uint32_t len = uncomp_buf[1];\n\n                        if ( len % 8 > 0 )\n                            len = len+(8-(len % 8));\n                        cells[i]->name = (char*)malloc(len+1);\n                        nbytes -= len;\n                        if ( NULL != cells[i]->name ) {\n                            /* Variable name */\n                            bytesread += InflateVarName(mat,matvar,cells[i]->name,len);\n                            cells[i]->name[len] = '\\0';\n                        }\n                    } else {\n                        mat_uint32_t len = (uncomp_buf[0] & 0xffff0000) >> 16;\n                        if ( ((uncomp_buf[0] & 0x0000ffff) == MAT_T_INT8) && len > 0 && len <= 4 ) {\n                            /* Name packed in tag */\n                            cells[i]->name = (char*)malloc(len+1);\n                            if ( NULL != cells[i]->name ) {\n                                memcpy(cells[i]->name,uncomp_buf+1,len);\n                                cells[i]->name[len] = '\\0';\n                            }\n                        }\n                    }\n                }\n                cells[i]->internal->z = (z_streamp)calloc(1,sizeof(z_stream));\n                if ( cells[i]->internal->z != NULL ) {\n                    err = inflateCopy(cells[i]->internal->z,matvar->internal->z);\n                    if ( err == Z_OK ) {\n                        cells[i]->internal->datapos = ftell((FILE*)mat->fp);\n                        if ( cells[i]->internal->datapos != -1L ) {\n                            cells[i]->internal->datapos -= matvar->internal->z->avail_in;\n                            if ( cells[i]->class_type == MAT_C_STRUCT )\n                                bytesread+=ReadNextStructField(mat,cells[i]);\n                            else if ( cells[i]->class_type == MAT_C_CELL )\n                                bytesread+=ReadNextCell(mat,cells[i]);\n                            else if ( nbytes <= (1 << MAX_WBITS) ) {\n                                /* Memory optimization: Read data if less in size\n                                   than the zlib inflate state (approximately) */\n                                Mat_VarRead5(mat,cells[i]);\n                                cells[i]->internal->data = cells[i]->data;\n                                cells[i]->data = NULL;\n                            }\n                            (void)fseek((FILE*)mat->fp,cells[i]->internal->datapos,SEEK_SET);\n                        } else {\n                            Mat_Critical(\"Couldn't determine file position\");\n                        }\n                        if ( cells[i]->internal->data != NULL ||\n                             cells[i]->class_type == MAT_C_STRUCT ||\n                             cells[i]->class_type == MAT_C_CELL ) {\n                            /* Memory optimization: Free inflate state */\n                            inflateEnd(cells[i]->internal->z);\n                            free(cells[i]->internal->z);\n                            cells[i]->internal->z = NULL;\n                        }\n                    } else {\n                        Mat_Critical(\"inflateCopy returned error %s\",zError(err));\n                    }\n                } else {\n                    Mat_Critical(\"Couldn't allocate memory\");\n                }\n            }\n            bytesread+=InflateSkip(mat,matvar->internal->z,nbytes);\n        }\n#else\n        Mat_Critical(\"Not compiled with zlib support\");\n#endif\n\n    } else {\n        mat_uint32_t buf[6];\n        int nBytes;\n        mat_uint32_t array_flags;\n\n        for ( i = 0; i < nelems; i++ ) {\n            int cell_bytes_read,name_len;\n            cells[i] = Mat_VarCalloc();\n            if ( !cells[i] ) {\n                Mat_Critical(\"Couldn't allocate memory for cell %\" SIZE_T_FMTSTR, i);\n                continue;\n            }\n\n            /* Read variable tag for cell */\n            cell_bytes_read = fread(buf,4,2,(FILE*)mat->fp);\n\n            /* Empty cells at the end of a file may cause an EOF */\n            if ( !cell_bytes_read )\n                continue;\n            bytesread += cell_bytes_read;\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(buf);\n                (void)Mat_uint32Swap(buf+1);\n            }\n            nBytes = buf[1];\n            if ( 0 == nBytes ) {\n                /* Empty cell: Memory optimization */\n                free(cells[i]->internal);\n                cells[i]->internal = NULL;\n                continue;\n            } else if ( buf[0] != MAT_T_MATRIX ) {\n                Mat_VarFree(cells[i]);\n                cells[i] = NULL;\n                Mat_Critical(\"cells[%\" SIZE_T_FMTSTR \"] not MAT_T_MATRIX, fpos = %ld\", i,\n                    ftell((FILE*)mat->fp));\n                break;\n            }\n\n            /* Read array flags and the dimensions tag */\n            bytesread += fread(buf,4,6,(FILE*)mat->fp);\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(buf);\n                (void)Mat_uint32Swap(buf+1);\n                (void)Mat_uint32Swap(buf+2);\n                (void)Mat_uint32Swap(buf+3);\n                (void)Mat_uint32Swap(buf+4);\n                (void)Mat_uint32Swap(buf+5);\n            }\n            nBytes-=24;\n            /* Array flags */\n            if ( buf[0] == MAT_T_UINT32 ) {\n               array_flags = buf[2];\n               cells[i]->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);\n               cells[i]->isComplex  = (array_flags & MAT_F_COMPLEX);\n               cells[i]->isGlobal   = (array_flags & MAT_F_GLOBAL);\n               cells[i]->isLogical  = (array_flags & MAT_F_LOGICAL);\n               if ( cells[i]->class_type == MAT_C_SPARSE ) {\n                   /* Need to find a more appropriate place to store nzmax */\n                   cells[i]->nbytes = buf[3];\n               }\n            }\n            /* Rank and dimension */\n            {\n                size_t nbytes = ReadRankDims(mat, cells[i], (enum matio_types)buf[4], buf[5]);\n                bytesread += nbytes;\n                nBytes -= nbytes;\n            }\n            /* Variable name tag */\n            bytesread+=fread(buf,1,8,(FILE*)mat->fp);\n            nBytes-=8;\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(buf);\n                (void)Mat_uint32Swap(buf+1);\n            }\n            name_len = 0;\n            if ( buf[1] > 0 ) {\n                /* Name of variable */\n                if ( buf[0] == MAT_T_INT8 ) {    /* Name not in tag */\n                    name_len = buf[1];\n                    if ( name_len % 8 > 0 )\n                        name_len = name_len+(8-(name_len % 8));\n                    nBytes -= name_len;\n                    (void)fseek((FILE*)mat->fp,name_len,SEEK_CUR);\n                }\n            }\n            cells[i]->internal->datapos = ftell((FILE*)mat->fp);\n            if ( cells[i]->internal->datapos != -1L ) {\n                if ( cells[i]->class_type == MAT_C_STRUCT )\n                    bytesread+=ReadNextStructField(mat,cells[i]);\n                if ( cells[i]->class_type == MAT_C_CELL )\n                    bytesread+=ReadNextCell(mat,cells[i]);\n                (void)fseek((FILE*)mat->fp,cells[i]->internal->datapos+nBytes,SEEK_SET);\n            } else {\n                Mat_Critical(\"Couldn't determine file position\");\n            }\n        }\n    }\n\n    return bytesread;\n}\n\n/** @brief Reads the next struct field of the structure in @c matvar\n *\n * Reads the next struct fields (fieldname length,names,data headers for all\n * the fields\n * @ingroup mat_internal\n * @param mat MAT file pointer\n * @param matvar MAT variable pointer\n * @return Number of bytes read\n */\nstatic size_t\nReadNextStructField( mat_t *mat, matvar_t *matvar )\n{\n    mat_uint32_t fieldname_size;\n    int err;\n    size_t bytesread = 0, nfields, i;\n    matvar_t **fields = NULL;\n    size_t nelems = 1, nelems_x_nfields;\n\n    err = SafeMulDims(matvar, &nelems);\n    if ( err ) {\n        Mat_Critical(\"Integer multiplication overflow\");\n        return bytesread;\n    }\n    if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {\n#if defined(HAVE_ZLIB)\n        mat_uint32_t uncomp_buf[16] = {0,};\n        int nbytes;\n        mat_uint32_t array_flags, len;\n\n        /* Field name length */\n        bytesread += InflateVarTag(mat,matvar,uncomp_buf);\n        if ( mat->byteswap ) {\n            (void)Mat_uint32Swap(uncomp_buf);\n            (void)Mat_uint32Swap(uncomp_buf+1);\n        }\n        if ( (uncomp_buf[0] & 0x0000ffff) == MAT_T_INT32 && uncomp_buf[1] > 0 ) {\n            fieldname_size = uncomp_buf[1];\n        } else {\n            Mat_Critical(\"Error getting fieldname size\");\n            return bytesread;\n        }\n\n        /* Field name tag */\n        bytesread += InflateVarTag(mat,matvar,uncomp_buf);\n        if ( mat->byteswap )\n            (void)Mat_uint32Swap(uncomp_buf);\n        /* Name of field */\n        if ( uncomp_buf[0] == MAT_T_INT8 ) {    /* Name not in tag */\n            if ( mat->byteswap )\n                len = Mat_uint32Swap(uncomp_buf+1);\n            else\n                len = uncomp_buf[1];\n            nfields = len / fieldname_size;\n            if ( nfields*fieldname_size % 8 != 0 )\n                i = 8-(nfields*fieldname_size % 8);\n            else\n                i = 0;\n            if ( nfields ) {\n                char *ptr = (char*)malloc(nfields*fieldname_size+i);\n                if ( NULL != ptr ) {\n                    bytesread += InflateVarName(mat,matvar,ptr,nfields*fieldname_size+i);\n                    SetFieldNames(matvar, ptr, nfields, fieldname_size);\n                    free(ptr);\n                }\n            } else {\n                matvar->internal->num_fields = 0;\n                matvar->internal->fieldnames = NULL;\n            }\n        } else {\n            len = (uncomp_buf[0] & 0xffff0000) >> 16;\n            if ( ((uncomp_buf[0] & 0x0000ffff) == MAT_T_INT8) && len > 0 && len <= 4 ) {\n                /* Name packed in tag */\n                nfields = len / fieldname_size;\n                if ( nfields ) {\n                    SetFieldNames(matvar, (char*)(uncomp_buf + 1), nfields, fieldname_size);\n                } else {\n                    matvar->internal->num_fields = 0;\n                    matvar->internal->fieldnames = NULL;\n                }\n            } else {\n                nfields = 0;\n            }\n        }\n\n        matvar->data_size = sizeof(matvar_t *);\n        err = SafeMul(&nelems_x_nfields, nelems, nfields);\n        if ( err ) {\n            Mat_Critical(\"Integer multiplication overflow\");\n            return bytesread;\n        }\n        err = SafeMul(&matvar->nbytes, nelems_x_nfields, matvar->data_size);\n        if ( err ) {\n            Mat_Critical(\"Integer multiplication overflow\");\n            return bytesread;\n        }\n        if ( !matvar->nbytes )\n            return bytesread;\n\n        matvar->data = calloc(nelems_x_nfields, matvar->data_size);\n        if ( NULL == matvar->data ) {\n            Mat_Critical(\"Couldn't allocate memory for the data\");\n            return bytesread;\n        }\n\n        fields = (matvar_t**)matvar->data;\n        for ( i = 0; i < nelems; i++ ) {\n            size_t k;\n            for ( k = 0; k < nfields; k++ ) {\n                fields[i*nfields+k] = Mat_VarCalloc();\n            }\n        }\n        if ( NULL != matvar->internal->fieldnames ) {\n            for ( i = 0; i < nelems; i++ ) {\n                size_t k;\n                for ( k = 0; k < nfields; k++ ) {\n                    if ( NULL != matvar->internal->fieldnames[k] ) {\n                        fields[i*nfields+k]->name = strdup(matvar->internal->fieldnames[k]);\n                    }\n                }\n            }\n        }\n\n        for ( i = 0; i < nelems_x_nfields; i++ ) {\n            /* Read variable tag for struct field */\n            bytesread += InflateVarTag(mat,matvar,uncomp_buf);\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(uncomp_buf);\n                (void)Mat_uint32Swap(uncomp_buf+1);\n            }\n            nbytes = uncomp_buf[1];\n            if ( uncomp_buf[0] != MAT_T_MATRIX ) {\n                Mat_VarFree(fields[i]);\n                fields[i] = NULL;\n                Mat_Critical(\"fields[%\" SIZE_T_FMTSTR \"], Uncompressed type not MAT_T_MATRIX\", i);\n                continue;\n            } else if ( 0 == nbytes ) {\n                /* Empty field: Memory optimization */\n                free(fields[i]->internal);\n                fields[i]->internal = NULL;\n                continue;\n            }\n            fields[i]->compression = MAT_COMPRESSION_ZLIB;\n            bytesread += InflateArrayFlags(mat,matvar,uncomp_buf);\n            nbytes -= 16;\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(uncomp_buf);\n                (void)Mat_uint32Swap(uncomp_buf+1);\n                (void)Mat_uint32Swap(uncomp_buf+2);\n                (void)Mat_uint32Swap(uncomp_buf+3);\n            }\n            /* Array flags */\n            if ( uncomp_buf[0] == MAT_T_UINT32 ) {\n               array_flags = uncomp_buf[2];\n               fields[i]->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);\n               fields[i]->isComplex  = (array_flags & MAT_F_COMPLEX);\n               fields[i]->isGlobal   = (array_flags & MAT_F_GLOBAL);\n               fields[i]->isLogical  = (array_flags & MAT_F_LOGICAL);\n               if ( fields[i]->class_type == MAT_C_SPARSE ) {\n                   /* Need to find a more appropriate place to store nzmax */\n                   fields[i]->nbytes = uncomp_buf[3];\n               }\n            } else {\n                Mat_Critical(\"Expected MAT_T_UINT32 for array tags, got %d\",\n                    uncomp_buf[0]);\n                bytesread+=InflateSkip(mat,matvar->internal->z,nbytes);\n            }\n            if ( fields[i]->class_type != MAT_C_OPAQUE ) {\n                mat_uint32_t* dims = NULL;\n                int do_clean = 0;\n                bytesread += InflateRankDims(mat,matvar,uncomp_buf,sizeof(uncomp_buf),&dims);\n                if ( NULL == dims )\n                    dims = uncomp_buf + 2;\n                else\n                    do_clean = 1;\n                nbytes -= 8;\n                if ( mat->byteswap ) {\n                    (void)Mat_uint32Swap(uncomp_buf);\n                    (void)Mat_uint32Swap(uncomp_buf+1);\n                }\n                /* Rank and dimension */\n                if ( uncomp_buf[0] == MAT_T_INT32 ) {\n                    int j;\n                    fields[i]->rank = uncomp_buf[1];\n                    nbytes -= fields[i]->rank;\n                    fields[i]->rank /= 4;\n                    fields[i]->dims = (size_t*)malloc(fields[i]->rank*\n                                             sizeof(*fields[i]->dims));\n                    if ( mat->byteswap ) {\n                        for ( j = 0; j < fields[i]->rank; j++ )\n                            fields[i]->dims[j] = Mat_uint32Swap(dims+j);\n                    } else {\n                        for ( j = 0; j < fields[i]->rank; j++ )\n                            fields[i]->dims[j] = dims[j];\n                    }\n                    if ( fields[i]->rank % 2 != 0 )\n                        nbytes -= 4;\n                }\n                if ( do_clean )\n                    free(dims);\n                /* Variable name tag */\n                bytesread += InflateVarTag(mat,matvar,uncomp_buf);\n                nbytes -= 8;\n                fields[i]->internal->z = (z_streamp)calloc(1,sizeof(z_stream));\n                if ( fields[i]->internal->z != NULL ) {\n                    err = inflateCopy(fields[i]->internal->z,matvar->internal->z);\n                    if ( err == Z_OK ) {\n                        fields[i]->internal->datapos = ftell((FILE*)mat->fp);\n                        if ( fields[i]->internal->datapos != -1L ) {\n                            fields[i]->internal->datapos -= matvar->internal->z->avail_in;\n                            if ( fields[i]->class_type == MAT_C_STRUCT )\n                                bytesread+=ReadNextStructField(mat,fields[i]);\n                            else if ( fields[i]->class_type == MAT_C_CELL )\n                                bytesread+=ReadNextCell(mat,fields[i]);\n                            else if ( nbytes <= (1 << MAX_WBITS) ) {\n                                /* Memory optimization: Read data if less in size\n                                   than the zlib inflate state (approximately) */\n                                Mat_VarRead5(mat,fields[i]);\n                                fields[i]->internal->data = fields[i]->data;\n                                fields[i]->data = NULL;\n                            }\n                            (void)fseek((FILE*)mat->fp,fields[i]->internal->datapos,SEEK_SET);\n                        } else {\n                            Mat_Critical(\"Couldn't determine file position\");\n                        }\n                        if ( fields[i]->internal->data != NULL ||\n                             fields[i]->class_type == MAT_C_STRUCT ||\n                             fields[i]->class_type == MAT_C_CELL ) {\n                            /* Memory optimization: Free inflate state */\n                            inflateEnd(fields[i]->internal->z);\n                            free(fields[i]->internal->z);\n                            fields[i]->internal->z = NULL;\n                        }\n                    } else {\n                        Mat_Critical(\"inflateCopy returned error %s\",zError(err));\n                    }\n                } else {\n                    Mat_Critical(\"Couldn't allocate memory\");\n                }\n            }\n            bytesread+=InflateSkip(mat,matvar->internal->z,nbytes);\n        }\n#else\n        Mat_Critical(\"Not compiled with zlib support\");\n#endif\n    } else {\n        mat_uint32_t buf[6];\n        int nBytes;\n        mat_uint32_t array_flags, len;\n\n        bytesread+=fread(buf,4,2,(FILE*)mat->fp);\n        if ( mat->byteswap ) {\n            (void)Mat_uint32Swap(buf);\n            (void)Mat_uint32Swap(buf+1);\n        }\n        if ( (buf[0] & 0x0000ffff) == MAT_T_INT32 && buf[1] > 0 ) {\n            fieldname_size = buf[1];\n        } else {\n            Mat_Critical(\"Error getting fieldname size\");\n            return bytesread;\n        }\n\n        /* Field name tag */\n        bytesread+=fread(buf,4,2,(FILE*)mat->fp);\n        if ( mat->byteswap )\n            (void)Mat_uint32Swap(buf);\n        /* Name of field */\n        if ( buf[0] == MAT_T_INT8 ) {    /* Name not in tag */\n            if ( mat->byteswap )\n                len = Mat_uint32Swap(buf+1);\n            else\n                len = buf[1];\n            nfields = len / fieldname_size;\n            if ( nfields ) {\n                char *ptr = (char*)malloc(nfields*fieldname_size);\n                if ( NULL != ptr ) {\n                    size_t readresult = fread(ptr, 1, nfields*fieldname_size, (FILE*)mat->fp);\n                    bytesread += readresult;\n                    if ( nfields*fieldname_size == readresult )\n                        SetFieldNames(matvar, ptr, nfields, fieldname_size);\n                    else\n                        matvar->internal->fieldnames = NULL;\n                    free(ptr);\n                }\n                if ( (nfields*fieldname_size) % 8 ) {\n                    (void)fseek((FILE*)mat->fp,8-((nfields*fieldname_size) % 8),SEEK_CUR);\n                    bytesread+=8-((nfields*fieldname_size) % 8);\n                }\n            } else {\n                matvar->internal->num_fields = 0;\n                matvar->internal->fieldnames = NULL;\n            }\n       } else {\n            len = (buf[0] & 0xffff0000) >> 16;\n            if ( ((buf[0] & 0x0000ffff) == MAT_T_INT8) && len > 0 && len <= 4 ) {\n                /* Name packed in tag */\n                nfields = len / fieldname_size;\n                if ( nfields ) {\n                    SetFieldNames(matvar, (char*)(buf + 1), nfields, fieldname_size);\n                } else {\n                    matvar->internal->num_fields = 0;\n                    matvar->internal->fieldnames = NULL;\n                }\n            } else {\n                nfields = 0;\n            }\n        }\n\n        matvar->data_size = sizeof(matvar_t *);\n        err = SafeMul(&nelems_x_nfields, nelems, nfields);\n        if ( err ) {\n            Mat_Critical(\"Integer multiplication overflow\");\n            return bytesread;\n        }\n        err = SafeMul(&matvar->nbytes, nelems_x_nfields, matvar->data_size);\n        if ( err ) {\n            Mat_Critical(\"Integer multiplication overflow\");\n            return bytesread;\n        }\n        if ( !matvar->nbytes )\n            return bytesread;\n\n        matvar->data = malloc(matvar->nbytes);\n        if ( NULL == matvar->data )\n            return bytesread;\n\n        fields = (matvar_t**)matvar->data;\n        for ( i = 0; i < nelems; i++ ) {\n            size_t k;\n            for ( k = 0; k < nfields; k++ ) {\n                fields[i*nfields+k] = Mat_VarCalloc();\n            }\n        }\n        if ( NULL != matvar->internal->fieldnames ) {\n            for ( i = 0; i < nelems; i++ ) {\n                size_t k;\n                for ( k = 0; k < nfields; k++ ) {\n                    if ( NULL != matvar->internal->fieldnames[k] ) {\n                        fields[i*nfields+k]->name = strdup(matvar->internal->fieldnames[k]);\n                    }\n                }\n            }\n        }\n\n        for ( i = 0; i < nelems_x_nfields; i++ ) {\n            /* Read variable tag for struct field */\n            bytesread += fread(buf,4,2,(FILE*)mat->fp);\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(buf);\n                (void)Mat_uint32Swap(buf+1);\n            }\n            nBytes = buf[1];\n            if ( buf[0] != MAT_T_MATRIX ) {\n                Mat_VarFree(fields[i]);\n                fields[i] = NULL;\n                Mat_Critical(\"fields[%\" SIZE_T_FMTSTR \"] not MAT_T_MATRIX, fpos = %ld\", i,\n                    ftell((FILE*)mat->fp));\n                return bytesread;\n            } else if ( 0 == nBytes ) {\n                /* Empty field: Memory optimization */\n                free(fields[i]->internal);\n                fields[i]->internal = NULL;\n                continue;\n            }\n\n            /* Read array flags and the dimensions tag */\n            bytesread += fread(buf,4,6,(FILE*)mat->fp);\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(buf);\n                (void)Mat_uint32Swap(buf+1);\n                (void)Mat_uint32Swap(buf+2);\n                (void)Mat_uint32Swap(buf+3);\n                (void)Mat_uint32Swap(buf+4);\n                (void)Mat_uint32Swap(buf+5);\n            }\n            nBytes-=24;\n            /* Array flags */\n            if ( buf[0] == MAT_T_UINT32 ) {\n                array_flags = buf[2];\n                fields[i]->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);\n                fields[i]->isComplex  = (array_flags & MAT_F_COMPLEX);\n                fields[i]->isGlobal   = (array_flags & MAT_F_GLOBAL);\n                fields[i]->isLogical  = (array_flags & MAT_F_LOGICAL);\n                if ( fields[i]->class_type == MAT_C_SPARSE ) {\n                    /* Need to find a more appropriate place to store nzmax */\n                    fields[i]->nbytes = buf[3];\n                }\n            }\n            /* Rank and dimension */\n            {\n                size_t nbytes = ReadRankDims(mat, fields[i], (enum matio_types)buf[4], buf[5]);\n                bytesread += nbytes;\n                nBytes -= nbytes;\n            }\n            /* Variable name tag */\n            bytesread+=fread(buf,1,8,(FILE*)mat->fp);\n            nBytes-=8;\n            fields[i]->internal->datapos = ftell((FILE*)mat->fp);\n            if ( fields[i]->internal->datapos != -1L ) {\n                if ( fields[i]->class_type == MAT_C_STRUCT )\n                    bytesread+=ReadNextStructField(mat,fields[i]);\n                else if ( fields[i]->class_type == MAT_C_CELL )\n                    bytesread+=ReadNextCell(mat,fields[i]);\n                (void)fseek((FILE*)mat->fp,fields[i]->internal->datapos+nBytes,SEEK_SET);\n            } else {\n                Mat_Critical(\"Couldn't determine file position\");\n            }\n        }\n    }\n\n    return bytesread;\n}\n\n/** @brief Reads the function handle data of the function handle in @c matvar\n *\n * @ingroup mat_internal\n * @param mat MAT file pointer\n * @param matvar MAT variable pointer\n * @return Number of bytes read\n */\nstatic size_t\nReadNextFunctionHandle(mat_t *mat, matvar_t *matvar)\n{\n    int err;\n    size_t nelems = 1;\n\n    err = SafeMulDims(matvar, &nelems);\n    matvar->data_size = sizeof(matvar_t *);\n    err |= SafeMul(&matvar->nbytes, nelems, matvar->data_size);\n    if ( err )\n        return 0;\n\n    matvar->data = malloc(matvar->nbytes);\n    if ( matvar->data != NULL ) {\n        size_t i;\n        matvar_t **functions = (matvar_t**)matvar->data;;\n        for ( i = 0; i < nelems; i++ )\n            functions[i] = Mat_VarReadNextInfo(mat);\n    } else {\n        matvar->data_size = 0;\n        matvar->nbytes    = 0;\n    }\n\n    return 0;\n}\n\n/** @brief Reads the rank and dimensions in @c matvar\n *\n * @ingroup mat_internal\n * @param mat MAT file pointer\n * @param matvar MAT variable pointer\n * @param data_type data type of dimension array\n * @param nbytes len of dimension array in bytes\n * @return Number of bytes read\n */\nstatic size_t\nReadRankDims(mat_t *mat, matvar_t *matvar, enum matio_types data_type, mat_uint32_t nbytes)\n{\n    size_t bytesread = 0;\n    /* Rank and dimension */\n    if ( data_type == MAT_T_INT32 ) {\n        matvar->rank = nbytes / sizeof(mat_uint32_t);\n        matvar->dims = (size_t*)malloc(matvar->rank*sizeof(*matvar->dims));\n        if ( NULL != matvar->dims ) {\n            int i;\n            mat_uint32_t buf;\n\n            for ( i = 0; i < matvar->rank; i++) {\n                size_t readresult = fread(&buf, sizeof(mat_uint32_t), 1, (FILE*)mat->fp);\n                if ( 1 == readresult ) {\n                    bytesread += sizeof(mat_uint32_t);\n                    if ( mat->byteswap ) {\n                        matvar->dims[i] = Mat_uint32Swap(&buf);\n                    } else {\n                        matvar->dims[i] = buf;\n                    }\n                } else {\n                    free(matvar->dims);\n                    matvar->dims = NULL;\n                    matvar->rank = 0;\n                    return 0;\n                }\n            }\n\n            if ( matvar->rank % 2 != 0 ) {\n                size_t readresult = fread(&buf, sizeof(mat_uint32_t), 1, (FILE*)mat->fp);\n                if ( 1 == readresult ) {\n                    bytesread += sizeof(mat_uint32_t);\n                } else {\n                    free(matvar->dims);\n                    matvar->dims = NULL;\n                    matvar->rank = 0;\n                    return 0;\n                }\n            }\n        } else {\n            matvar->rank = 0;\n            Mat_Critical(\"Error allocating memory for dims\");\n        }\n    }\n    return bytesread;\n}\n\n/** @brief Writes the header and data for a given type\n *\n * @ingroup mat_internal\n * @param mat MAT file pointer\n * @param matvar pointer to the mat variable\n * @retval 0 on success\n */\nstatic int\nWriteType(mat_t *mat,matvar_t *matvar)\n{\n    int err;\n    mat_int16_t array_name_type = MAT_T_INT8;\n    mat_int8_t pad1 = 0;\n    int nBytes, j;\n    size_t nelems = 1;\n\n    err = SafeMulDims(matvar, &nelems);\n    if ( err )\n        return err;\n\n    switch ( matvar->class_type ) {\n        case MAT_C_DOUBLE:\n        case MAT_C_SINGLE:\n        case MAT_C_INT64:\n        case MAT_C_UINT64:\n        case MAT_C_INT32:\n        case MAT_C_UINT32:\n        case MAT_C_INT16:\n        case MAT_C_UINT16:\n        case MAT_C_INT8:\n        case MAT_C_UINT8:\n        {\n            if ( matvar->isComplex ) {\n                mat_complex_split_t *complex_data = (mat_complex_split_t*)matvar->data;\n\n                if ( NULL == matvar->data )\n                    complex_data = &null_complex_data;\n\n                nBytes=WriteData(mat,complex_data->Re,nelems,matvar->data_type);\n                if ( nBytes % 8 )\n                    for ( j = nBytes % 8; j < 8; j++ )\n                        fwrite(&pad1,1,1,(FILE*)mat->fp);\n                nBytes=WriteData(mat,complex_data->Im,nelems,matvar->data_type);\n                if ( nBytes % 8 )\n                    for ( j = nBytes % 8; j < 8; j++ )\n                        fwrite(&pad1,1,1,(FILE*)mat->fp);\n            } else {\n                nBytes=WriteData(mat,matvar->data,nelems,matvar->data_type);\n                if ( nBytes % 8 )\n                    for ( j = nBytes % 8; j < 8; j++ )\n                        fwrite(&pad1,1,1,(FILE*)mat->fp);\n            }\n            break;\n        }\n        case MAT_C_CHAR:\n            nBytes=WriteCharData(mat,matvar->data,nelems,matvar->data_type);\n            break;\n        case MAT_C_CELL:\n        {\n            size_t i;\n            matvar_t **cells = (matvar_t **)matvar->data;\n\n            /* Check for an empty cell array */\n            if ( matvar->nbytes == 0 || matvar->data_size == 0 ||\n                 matvar->data   == NULL )\n                break;\n            nelems = matvar->nbytes / matvar->data_size;\n            for ( i = 0; i < nelems; i++ )\n                WriteCellArrayField(mat,cells[i]);\n            break;\n        }\n        case MAT_C_STRUCT:\n        {\n            mat_int16_t fieldname_type = MAT_T_INT32;\n            mat_int16_t fieldname_data_size = 4;\n            char *padzero;\n            int fieldname_size;\n            size_t maxlen = 0, nfields, i, nelems_x_nfields;\n            matvar_t **fields = (matvar_t **)matvar->data;\n            unsigned fieldname;\n\n            /* nelems*matvar->data_size can be zero when saving a struct that\n             * contains an empty struct in one of its fields\n             * (e.g. x.y = struct('z', {})). If it's zero, we would divide\n             * by zero.\n             */\n            nfields = matvar->internal->num_fields;\n            /* Check for a structure with no fields */\n            if ( nfields < 1 ) {\n#if 0\n                fwrite(&fieldname_type,2,1,(FILE*)mat->fp);\n                fwrite(&fieldname_data_size,2,1,(FILE*)mat->fp);\n#else\n                fieldname = (fieldname_data_size<<16) | fieldname_type;\n                fwrite(&fieldname,4,1,(FILE*)mat->fp);\n#endif\n                fieldname_size = 1;\n                fwrite(&fieldname_size,4,1,(FILE*)mat->fp);\n                fwrite(&array_name_type,2,1,(FILE*)mat->fp);\n                fwrite(&pad1,1,1,(FILE*)mat->fp);\n                fwrite(&pad1,1,1,(FILE*)mat->fp);\n                nBytes = 0;\n                fwrite(&nBytes,4,1,(FILE*)mat->fp);\n                break;\n            }\n\n            for ( i = 0; i < nfields; i++ ) {\n                size_t len = strlen(matvar->internal->fieldnames[i]);\n                if ( len > maxlen )\n                    maxlen = len;\n            }\n            maxlen++;\n            fieldname_size = maxlen;\n            while ( nfields*fieldname_size % 8 != 0 )\n                fieldname_size++;\n#if 0\n            fwrite(&fieldname_type,2,1,(FILE*)mat->fp);\n            fwrite(&fieldname_data_size,2,1,(FILE*)mat->fp);\n#else\n            fieldname = (fieldname_data_size<<16) | fieldname_type;\n            fwrite(&fieldname,4,1,(FILE*)mat->fp);\n#endif\n            fwrite(&fieldname_size,4,1,(FILE*)mat->fp);\n            fwrite(&array_name_type,2,1,(FILE*)mat->fp);\n            fwrite(&pad1,1,1,(FILE*)mat->fp);\n            fwrite(&pad1,1,1,(FILE*)mat->fp);\n            nBytes = nfields*fieldname_size;\n            fwrite(&nBytes,4,1,(FILE*)mat->fp);\n            padzero = (char*)calloc(fieldname_size,1);\n            for ( i = 0; i < nfields; i++ ) {\n                size_t len = strlen(matvar->internal->fieldnames[i]);\n                fwrite(matvar->internal->fieldnames[i],1,len,(FILE*)mat->fp);\n                fwrite(padzero,1,fieldname_size-len,(FILE*)mat->fp);\n            }\n            free(padzero);\n            err = SafeMul(&nelems_x_nfields, nelems, nfields);\n            if ( err )\n                break;\n            for ( i = 0; i < nelems_x_nfields; i++ )\n                WriteStructField(mat,fields[i]);\n            break;\n        }\n        case MAT_C_SPARSE:\n        {\n            mat_sparse_t *sparse = (mat_sparse_t*)matvar->data;\n\n            nBytes = WriteData(mat,sparse->ir,sparse->nir,MAT_T_INT32);\n            if ( nBytes % 8 )\n                for ( j = nBytes % 8; j < 8; j++ )\n                    fwrite(&pad1,1,1,(FILE*)mat->fp);\n            nBytes = WriteData(mat,sparse->jc,sparse->njc,MAT_T_INT32);\n            if ( nBytes % 8 )\n                for ( j = nBytes % 8; j < 8; j++ )\n                    fwrite(&pad1,1,1,(FILE*)mat->fp);\n            if ( matvar->isComplex ) {\n                mat_complex_split_t *complex_data = (mat_complex_split_t*)sparse->data;\n                nBytes = WriteData(mat,complex_data->Re,sparse->ndata,\n                                   matvar->data_type);\n                if ( nBytes % 8 )\n                    for ( j = nBytes % 8; j < 8; j++ )\n                        fwrite(&pad1,1,1,(FILE*)mat->fp);\n                nBytes = WriteData(mat,complex_data->Im,sparse->ndata,\n                                   matvar->data_type);\n                if ( nBytes % 8 )\n                    for ( j = nBytes % 8; j < 8; j++ )\n                        fwrite(&pad1,1,1,(FILE*)mat->fp);\n            } else {\n                nBytes = WriteData(mat,sparse->data,sparse->ndata,\n                                   matvar->data_type);\n                if ( nBytes % 8 )\n                    for ( j = nBytes % 8; j < 8; j++ )\n                        fwrite(&pad1,1,1,(FILE*)mat->fp);\n            }\n        }\n        case MAT_C_FUNCTION:\n        case MAT_C_OBJECT:\n        case MAT_C_EMPTY:\n        case MAT_C_OPAQUE:\n            break;\n    }\n\n    return err;\n}\n\n/** @brief Writes the header and data for an element of a cell array\n *\n * @ingroup mat_internal\n * @param mat MAT file pointer\n * @param matvar pointer to the mat variable\n * @retval 0 on success\n */\nstatic int\nWriteCellArrayField(mat_t *mat,matvar_t *matvar)\n{\n    mat_uint32_t array_flags;\n    mat_int16_t array_name_type = MAT_T_INT8;\n    int array_flags_type = MAT_T_UINT32, dims_array_type = MAT_T_INT32;\n    int array_flags_size = 8, pad4 = 0, matrix_type = MAT_T_MATRIX;\n    const mat_int8_t pad1 = 0;\n    int nBytes, i, nzmax = 0;\n    long start = 0, end = 0;\n\n    if ( matvar == NULL || mat == NULL )\n        return 1;\n\n    fwrite(&matrix_type,4,1,(FILE*)mat->fp);\n    fwrite(&pad4,4,1,(FILE*)mat->fp);\n    if ( MAT_C_EMPTY == matvar->class_type ) {\n        /* exit early if this is an empty data */\n        return 0;\n    }\n    start = ftell((FILE*)mat->fp);\n\n    /* Array Flags */\n    array_flags = matvar->class_type & CLASS_TYPE_MASK;\n    if ( matvar->isComplex )\n        array_flags |= MAT_F_COMPLEX;\n    if ( matvar->isGlobal )\n        array_flags |= MAT_F_GLOBAL;\n    if ( matvar->isLogical )\n        array_flags |= MAT_F_LOGICAL;\n    if ( matvar->class_type == MAT_C_SPARSE )\n        nzmax = ((mat_sparse_t *)matvar->data)->nzmax;\n\n    if ( mat->byteswap )\n        array_flags = Mat_int32Swap((mat_int32_t*)&array_flags);\n    fwrite(&array_flags_type,4,1,(FILE*)mat->fp);\n    fwrite(&array_flags_size,4,1,(FILE*)mat->fp);\n    fwrite(&array_flags,4,1,(FILE*)mat->fp);\n    fwrite(&nzmax,4,1,(FILE*)mat->fp);\n    /* Rank and Dimension */\n    nBytes = matvar->rank * 4;\n    fwrite(&dims_array_type,4,1,(FILE*)mat->fp);\n    fwrite(&nBytes,4,1,(FILE*)mat->fp);\n    for ( i = 0; i < matvar->rank; i++ ) {\n        mat_int32_t dim;\n        dim = matvar->dims[i];\n        fwrite(&dim,4,1,(FILE*)mat->fp);\n    }\n    if ( matvar->rank % 2 != 0 )\n        fwrite(&pad4,4,1,(FILE*)mat->fp);\n    /* Name of variable */\n    if ( !matvar->name ) {\n        fwrite(&array_name_type,2,1,(FILE*)mat->fp);\n        fwrite(&pad1,1,1,(FILE*)mat->fp);\n        fwrite(&pad1,1,1,(FILE*)mat->fp);\n        fwrite(&pad4,4,1,(FILE*)mat->fp);\n    } else if ( strlen(matvar->name) <= 4 ) {\n        mat_int16_t array_name_len = (mat_int16_t)strlen(matvar->name);\n        fwrite(&array_name_type,2,1,(FILE*)mat->fp);\n        fwrite(&array_name_len,2,1,(FILE*)mat->fp);\n        fwrite(matvar->name,1,array_name_len,(FILE*)mat->fp);\n        for ( i = array_name_len; i < 4; i++ )\n            fwrite(&pad1,1,1,(FILE*)mat->fp);\n    } else {\n        mat_int32_t array_name_len = (mat_int32_t)strlen(matvar->name);\n        fwrite(&array_name_type,2,1,(FILE*)mat->fp);\n        fwrite(&pad1,1,1,(FILE*)mat->fp);\n        fwrite(&pad1,1,1,(FILE*)mat->fp);\n        fwrite(&array_name_len,4,1,(FILE*)mat->fp);\n        fwrite(matvar->name,1,array_name_len,(FILE*)mat->fp);\n        if ( array_name_len % 8 )\n            for ( i = array_name_len % 8; i < 8; i++ )\n                fwrite(&pad1,1,1,(FILE*)mat->fp);\n    }\n\n    WriteType(mat,matvar);\n    end = ftell((FILE*)mat->fp);\n    if ( start != -1L && end != -1L ) {\n        nBytes = (int)(end-start);\n        (void)fseek((FILE*)mat->fp,(long)-(nBytes+4),SEEK_CUR);\n        fwrite(&nBytes,4,1,(FILE*)mat->fp);\n        (void)fseek((FILE*)mat->fp,end,SEEK_SET);\n    } else {\n        Mat_Critical(\"Couldn't determine file position\");\n    }\n\n    return 0;\n}\n\n#if defined(HAVE_ZLIB)\n/** @brief Writes the header and data for a given class type\n *\n * @ingroup mat_internal\n * @param mat MAT file pointer\n * @param matvar pointer to the mat variable\n * @return number of bytes written to the MAT file\n */\nstatic size_t\nWriteCompressedTypeArrayFlags(mat_t *mat,matvar_t *matvar,z_streamp z)\n{\n    mat_uint32_t array_flags;\n    mat_int16_t  array_name_type = MAT_T_INT8;\n    int array_flags_type = MAT_T_UINT32, dims_array_type = MAT_T_INT32;\n    int array_flags_size = 8;\n    int nBytes, i, nzmax = 0;\n\n    mat_uint32_t comp_buf[512];\n    mat_uint32_t uncomp_buf[512] = {0,};\n    int buf_size = 512;\n    size_t byteswritten = 0;\n\n    if ( MAT_C_EMPTY == matvar->class_type ) {\n        /* exit early if this is an empty data */\n        return byteswritten;\n    }\n\n    /* Array Flags */\n    array_flags = matvar->class_type & CLASS_TYPE_MASK;\n    if ( matvar->isComplex )\n        array_flags |= MAT_F_COMPLEX;\n    if ( matvar->isGlobal )\n        array_flags |= MAT_F_GLOBAL;\n    if ( matvar->isLogical )\n        array_flags |= MAT_F_LOGICAL;\n    if ( matvar->class_type == MAT_C_SPARSE )\n        nzmax = ((mat_sparse_t *)matvar->data)->nzmax;\n    uncomp_buf[0] = array_flags_type;\n    uncomp_buf[1] = array_flags_size;\n    uncomp_buf[2] = array_flags;\n    uncomp_buf[3] = nzmax;\n    /* Rank and Dimension */\n    nBytes = matvar->rank * 4;\n    uncomp_buf[4] = dims_array_type;\n    uncomp_buf[5] = nBytes;\n    for ( i = 0; i < matvar->rank; i++ ) {\n        mat_int32_t dim;\n        dim = matvar->dims[i];\n        uncomp_buf[6+i] = dim;\n    }\n    if ( matvar->rank % 2 != 0 ) {\n        int pad4 = 0;\n        uncomp_buf[6+i] = pad4;\n        i++;\n    }\n\n    z->next_in  = ZLIB_BYTE_PTR(uncomp_buf);\n    z->avail_in = (6+i)*sizeof(*uncomp_buf);\n    do {\n        z->next_out  = ZLIB_BYTE_PTR(comp_buf);\n        z->avail_out = buf_size*sizeof(*comp_buf);\n        deflate(z,Z_NO_FLUSH);\n        byteswritten += fwrite(comp_buf,1,buf_size*sizeof(*comp_buf)-z->avail_out,\n            (FILE*)mat->fp);\n    } while ( z->avail_out == 0 );\n    /* Name of variable */\n    uncomp_buf[0] = array_name_type;\n    uncomp_buf[1] = 0;\n    z->next_in  = ZLIB_BYTE_PTR(uncomp_buf);\n    z->avail_in = 8;\n    do {\n        z->next_out  = ZLIB_BYTE_PTR(comp_buf);\n        z->avail_out = buf_size*sizeof(*comp_buf);\n        deflate(z,Z_NO_FLUSH);\n        byteswritten += fwrite(comp_buf,1,buf_size*sizeof(*comp_buf)-z->avail_out,\n            (FILE*)mat->fp);\n    } while ( z->avail_out == 0 );\n\n    matvar->internal->datapos = ftell((FILE*)mat->fp);\n    if ( matvar->internal->datapos == -1L ) {\n        Mat_Critical(\"Couldn't determine file position\");\n    }\n\n    byteswritten += WriteCompressedType(mat,matvar,z);\n    return byteswritten;\n}\n\n/** @brief Writes the header and data for a given class type\n *\n * @ingroup mat_internal\n * @param mat MAT file pointer\n * @param matvar pointer to the mat variable\n * @return number of bytes written to the MAT file\n */\nstatic size_t\nWriteCompressedType(mat_t *mat,matvar_t *matvar,z_streamp z)\n{\n    int err;\n    mat_uint32_t comp_buf[512];\n    mat_uint32_t uncomp_buf[512] = {0,};\n    size_t byteswritten = 0, nelems = 1;\n\n    if ( MAT_C_EMPTY == matvar->class_type ) {\n        /* exit early if this is an empty data */\n        return byteswritten;\n    }\n\n    err = SafeMulDims(matvar, &nelems);\n    if ( err ) {\n        Mat_Critical(\"Integer multiplication overflow\");\n        return byteswritten;\n    }\n\n    switch ( matvar->class_type ) {\n        case MAT_C_DOUBLE:\n        case MAT_C_SINGLE:\n        case MAT_C_INT64:\n        case MAT_C_UINT64:\n        case MAT_C_INT32:\n        case MAT_C_UINT32:\n        case MAT_C_INT16:\n        case MAT_C_UINT16:\n        case MAT_C_INT8:\n        case MAT_C_UINT8:\n        {\n            /* WriteCompressedData makes sure uncompressed data is aligned\n             * on an 8-byte boundary */\n            if ( matvar->isComplex ) {\n                mat_complex_split_t *complex_data = (mat_complex_split_t*)matvar->data;\n\n                if ( NULL == matvar->data )\n                    complex_data = &null_complex_data;\n\n                byteswritten += WriteCompressedData(mat,z,\n                    complex_data->Re,nelems,matvar->data_type);\n                byteswritten += WriteCompressedData(mat,z,\n                    complex_data->Im,nelems,matvar->data_type);\n            } else {\n                byteswritten += WriteCompressedData(mat,z,\n                    matvar->data,nelems,matvar->data_type);\n            }\n            break;\n        }\n        case MAT_C_CHAR:\n        {\n            byteswritten += WriteCompressedCharData(mat,z,matvar->data,\n                nelems,matvar->data_type);\n            break;\n        }\n        case MAT_C_CELL:\n        {\n            size_t i;\n            matvar_t **cells = (matvar_t **)matvar->data;\n\n            /* Check for an empty cell array */\n            if ( matvar->nbytes == 0 || matvar->data_size == 0 ||\n                 matvar->data   == NULL )\n                break;\n            nelems = matvar->nbytes / matvar->data_size;\n            for ( i = 0; i < nelems; i++ )\n                WriteCompressedCellArrayField(mat,cells[i],z);\n            break;\n        }\n        case MAT_C_STRUCT:\n        {\n            int buf_size = 512;\n            mat_int16_t fieldname_type = MAT_T_INT32;\n            mat_int16_t fieldname_data_size = 4;\n            unsigned char *padzero;\n            int fieldname_size;\n            size_t maxlen = 0, nfields, i, nelems_x_nfields;\n            mat_int32_t array_name_type = MAT_T_INT8;\n            matvar_t **fields = (matvar_t **)matvar->data;\n\n            nfields = matvar->internal->num_fields;\n            /* Check for a structure with no fields */\n            if ( nfields < 1 ) {\n                fieldname_size = 1;\n                uncomp_buf[0] = (fieldname_data_size << 16) | fieldname_type;\n                uncomp_buf[1] = fieldname_size;\n                uncomp_buf[2] = array_name_type;\n                uncomp_buf[3] = 0;\n                z->next_in  = ZLIB_BYTE_PTR(uncomp_buf);\n                z->avail_in = 16;\n                do {\n                    z->next_out  = ZLIB_BYTE_PTR(comp_buf);\n                    z->avail_out = buf_size*sizeof(*comp_buf);\n                    deflate(z,Z_NO_FLUSH);\n                    byteswritten += fwrite(comp_buf,1,buf_size*\n                        sizeof(*comp_buf)-z->avail_out,(FILE*)mat->fp);\n                } while ( z->avail_out == 0 );\n                break;\n            }\n\n            for ( i = 0; i < nfields; i++ ) {\n                size_t len = strlen(matvar->internal->fieldnames[i]);\n                if ( len > maxlen )\n                    maxlen = len;\n            }\n            maxlen++;\n            fieldname_size = maxlen;\n            while ( nfields*fieldname_size % 8 != 0 )\n                fieldname_size++;\n            uncomp_buf[0] = (fieldname_data_size << 16) | fieldname_type;\n            uncomp_buf[1] = fieldname_size;\n            uncomp_buf[2] = array_name_type;\n            uncomp_buf[3] = nfields*fieldname_size;\n\n            padzero = (unsigned char*)calloc(fieldname_size,1);\n            z->next_in  = ZLIB_BYTE_PTR(uncomp_buf);\n            z->avail_in = 16;\n            do {\n                z->next_out  = ZLIB_BYTE_PTR(comp_buf);\n                z->avail_out = buf_size*sizeof(*comp_buf);\n                deflate(z,Z_NO_FLUSH);\n                byteswritten += fwrite(comp_buf,1,\n                    buf_size*sizeof(*comp_buf)-z->avail_out,(FILE*)mat->fp);\n            } while ( z->avail_out == 0 );\n            for ( i = 0; i < nfields; i++ ) {\n                size_t len = strlen(matvar->internal->fieldnames[i]);\n                memset(padzero,'\\0',fieldname_size);\n                memcpy(padzero,matvar->internal->fieldnames[i],len);\n                z->next_in  = ZLIB_BYTE_PTR(padzero);\n                z->avail_in = fieldname_size;\n                do {\n                    z->next_out  = ZLIB_BYTE_PTR(comp_buf);\n                    z->avail_out = buf_size*sizeof(*comp_buf);\n                    deflate(z,Z_NO_FLUSH);\n                    byteswritten += fwrite(comp_buf,1,\n                        buf_size*sizeof(*comp_buf)-z->avail_out,(FILE*)mat->fp);\n                } while ( z->avail_out == 0 );\n            }\n            free(padzero);\n            err = SafeMul(&nelems_x_nfields, nelems, nfields);\n            if ( err ) {\n                Mat_Critical(\"Integer multiplication overflow\");\n                return byteswritten;\n            }\n            for ( i = 0; i < nelems_x_nfields; i++ )\n                byteswritten += WriteCompressedStructField(mat,fields[i],z);\n            break;\n        }\n        case MAT_C_SPARSE:\n        {\n            mat_sparse_t *sparse = (mat_sparse_t*)matvar->data;\n\n            byteswritten += WriteCompressedData(mat,z,sparse->ir,\n                sparse->nir,MAT_T_INT32);\n            byteswritten += WriteCompressedData(mat,z,sparse->jc,\n                sparse->njc,MAT_T_INT32);\n            if ( matvar->isComplex ) {\n                mat_complex_split_t *complex_data = (mat_complex_split_t*)sparse->data;\n                byteswritten += WriteCompressedData(mat,z,\n                    complex_data->Re,sparse->ndata,matvar->data_type);\n                byteswritten += WriteCompressedData(mat,z,\n                    complex_data->Im,sparse->ndata,matvar->data_type);\n            } else {\n                byteswritten += WriteCompressedData(mat,z,\n                    sparse->data,sparse->ndata,matvar->data_type);\n            }\n            break;\n        }\n        case MAT_C_FUNCTION:\n        case MAT_C_OBJECT:\n        case MAT_C_EMPTY:\n        case MAT_C_OPAQUE:\n            break;\n    }\n\n    return byteswritten;\n}\n\n/** @brief Writes the header and data for a field of a compressed cell array\n *\n * @ingroup mat_internal\n * @param mat MAT file pointer\n * @param matvar pointer to the mat variable\n * @return number of bytes written to the MAT file\n */\nstatic size_t\nWriteCompressedCellArrayField(mat_t *mat,matvar_t *matvar,z_streamp z)\n{\n    mat_uint32_t comp_buf[512];\n    mat_uint32_t uncomp_buf[512] = {0,};\n    int buf_size = 512;\n    size_t byteswritten = 0, field_buf_size;\n\n    if ( NULL == matvar || NULL == mat || NULL == z)\n        return 0;\n\n    uncomp_buf[0] = MAT_T_MATRIX;\n    if ( MAT_C_EMPTY != matvar->class_type ) {\n        int err = GetCellArrayFieldBufSize(matvar, &field_buf_size);\n        if (err || field_buf_size > UINT32_MAX)\n            return 0;\n\n        uncomp_buf[1] = field_buf_size;\n    } else {\n        uncomp_buf[1] = 0;\n    }\n    z->next_in  = ZLIB_BYTE_PTR(uncomp_buf);\n    z->avail_in = 8;\n    do {\n        z->next_out  = ZLIB_BYTE_PTR(comp_buf);\n        z->avail_out = buf_size*sizeof(*comp_buf);\n        deflate(z,Z_NO_FLUSH);\n        byteswritten += fwrite(comp_buf,1,buf_size*sizeof(*comp_buf)-z->avail_out,\n            (FILE*)mat->fp);\n    } while ( z->avail_out == 0 );\n\n    byteswritten += WriteCompressedTypeArrayFlags(mat,matvar,z);\n    return byteswritten;\n}\n#endif\n\n/** @brief Writes the header and data for a field of a struct array\n *\n * @ingroup mat_internal\n * @param mat MAT file pointer\n * @param matvar pointer to the mat variable\n * @retval 0 on success\n */\nstatic int\nWriteStructField(mat_t *mat,matvar_t *matvar)\n{\n    mat_uint32_t array_flags;\n    mat_int32_t  array_name_type = MAT_T_INT8;\n    int array_flags_type = MAT_T_UINT32, dims_array_type = MAT_T_INT32;\n    int array_flags_size = 8, pad4 = 0, matrix_type = MAT_T_MATRIX;\n    int nBytes, i, nzmax = 0;\n    long start = 0, end = 0;\n\n    if ( mat == NULL )\n        return 1;\n\n    if ( NULL == matvar ) {\n        size_t dims[2] = {0,0};\n        Mat_WriteEmptyVariable5(mat, NULL, 2, dims);\n        return 0;\n    }\n\n    fwrite(&matrix_type,4,1,(FILE*)mat->fp);\n    fwrite(&pad4,4,1,(FILE*)mat->fp);\n    if ( MAT_C_EMPTY == matvar->class_type ) {\n        /* exit early if this is an empty data */\n        return 0;\n    }\n    start = ftell((FILE*)mat->fp);\n\n    /* Array Flags */\n    array_flags = matvar->class_type & CLASS_TYPE_MASK;\n    if ( matvar->isComplex )\n        array_flags |= MAT_F_COMPLEX;\n    if ( matvar->isGlobal )\n        array_flags |= MAT_F_GLOBAL;\n    if ( matvar->isLogical )\n        array_flags |= MAT_F_LOGICAL;\n    if ( matvar->class_type == MAT_C_SPARSE )\n        nzmax = ((mat_sparse_t *)matvar->data)->nzmax;\n\n    if ( mat->byteswap )\n        array_flags = Mat_int32Swap((mat_int32_t*)&array_flags);\n    fwrite(&array_flags_type,4,1,(FILE*)mat->fp);\n    fwrite(&array_flags_size,4,1,(FILE*)mat->fp);\n    fwrite(&array_flags,4,1,(FILE*)mat->fp);\n    fwrite(&nzmax,4,1,(FILE*)mat->fp);\n    /* Rank and Dimension */\n    nBytes = matvar->rank * 4;\n    fwrite(&dims_array_type,4,1,(FILE*)mat->fp);\n    fwrite(&nBytes,4,1,(FILE*)mat->fp);\n    for ( i = 0; i < matvar->rank; i++ ) {\n        mat_int32_t dim;\n        dim = matvar->dims[i];\n        fwrite(&dim,4,1,(FILE*)mat->fp);\n    }\n    if ( matvar->rank % 2 != 0 )\n        fwrite(&pad4,4,1,(FILE*)mat->fp);\n\n    /* Name of variable */\n    fwrite(&array_name_type,4,1,(FILE*)mat->fp);\n    fwrite(&pad4,4,1,(FILE*)mat->fp);\n\n    WriteType(mat,matvar);\n    end = ftell((FILE*)mat->fp);\n    if ( start != -1L && end != -1L ) {\n        nBytes = (int)(end-start);\n        (void)fseek((FILE*)mat->fp,(long)-(nBytes+4),SEEK_CUR);\n        fwrite(&nBytes,4,1,(FILE*)mat->fp);\n        (void)fseek((FILE*)mat->fp,end,SEEK_SET);\n    } else {\n        Mat_Critical(\"Couldn't determine file position\");\n    }\n\n    return 0;\n}\n\n#if defined(HAVE_ZLIB)\n/** @brief Writes the header and data for a field of a compressed struct array\n *\n * @ingroup mat_internal\n * @fixme Currently does not work for cell arrays or sparse data\n * @param mat MAT file pointer\n * @param matvar pointer to the mat variable\n * @return number of bytes written to the MAT file\n */\nstatic size_t\nWriteCompressedStructField(mat_t *mat,matvar_t *matvar,z_streamp z)\n{\n    mat_uint32_t comp_buf[512];\n    mat_uint32_t uncomp_buf[512] = {0,};\n    int buf_size = 512;\n    size_t byteswritten = 0, field_buf_size;\n\n    if ( NULL == mat || NULL == z)\n        return 0;\n\n    if ( NULL == matvar ) {\n        size_t dims[2] = {0,0};\n        byteswritten = Mat_WriteCompressedEmptyVariable5(mat, NULL, 2, dims, z);\n        return byteswritten;\n    }\n\n    uncomp_buf[0] = MAT_T_MATRIX;\n    if ( MAT_C_EMPTY != matvar->class_type ) {\n        int err = GetStructFieldBufSize(matvar, &field_buf_size);\n        if (err || field_buf_size > UINT32_MAX)\n            return 0;\n        uncomp_buf[1] = field_buf_size;\n    } else {\n        uncomp_buf[1] = 0;\n    }\n    z->next_in  = ZLIB_BYTE_PTR(uncomp_buf);\n    z->avail_in = 8;\n    do {\n        z->next_out  = ZLIB_BYTE_PTR(comp_buf);\n        z->avail_out = buf_size*sizeof(*comp_buf);\n        deflate(z,Z_NO_FLUSH);\n        byteswritten += fwrite(comp_buf,1,buf_size*sizeof(*comp_buf)-z->avail_out,\n            (FILE*)mat->fp);\n    } while ( z->avail_out == 0 );\n\n    byteswritten += WriteCompressedTypeArrayFlags(mat,matvar,z);\n    return byteswritten;\n}\n#endif\n\nstatic size_t\nMat_WriteEmptyVariable5(mat_t *mat,const char *name,int rank,size_t *dims)\n{\n    mat_uint32_t array_flags;\n    mat_int32_t  array_name_type = MAT_T_INT8, matrix_type = MAT_T_MATRIX;\n    int array_flags_type = MAT_T_UINT32, dims_array_type = MAT_T_INT32;\n    int array_flags_size = 8, pad4 = 0, nBytes, i;\n    const mat_int8_t pad1 = 0;\n    size_t byteswritten = 0;\n    long start = 0, end = 0;\n\n    fwrite(&matrix_type,4,1,(FILE*)mat->fp);\n    fwrite(&pad4,4,1,(FILE*)mat->fp);\n    start = ftell((FILE*)mat->fp);\n\n    /* Array Flags */\n    array_flags = MAT_C_DOUBLE;\n\n    if ( mat->byteswap )\n        array_flags = Mat_int32Swap((mat_int32_t*)&array_flags);\n    byteswritten += fwrite(&array_flags_type,4,1,(FILE*)mat->fp);\n    byteswritten += fwrite(&array_flags_size,4,1,(FILE*)mat->fp);\n    byteswritten += fwrite(&array_flags,4,1,(FILE*)mat->fp);\n    byteswritten += fwrite(&pad4,4,1,(FILE*)mat->fp);\n    /* Rank and Dimension */\n    nBytes = rank * 4;\n    byteswritten += fwrite(&dims_array_type,4,1,(FILE*)mat->fp);\n    byteswritten += fwrite(&nBytes,4,1,(FILE*)mat->fp);\n    for ( i = 0; i < rank; i++ ) {\n        mat_int32_t dim;\n        dim = dims[i];\n        byteswritten += fwrite(&dim,4,1,(FILE*)mat->fp);\n    }\n    if ( rank % 2 != 0 )\n        byteswritten += fwrite(&pad4,4,1,(FILE*)mat->fp);\n\n    if ( NULL == name ) {\n        /* Name of variable */\n        byteswritten += fwrite(&array_name_type,4,1,(FILE*)mat->fp);\n        byteswritten += fwrite(&pad4,4,1,(FILE*)mat->fp);\n    } else {\n        mat_int32_t array_name_len = (mat_int32_t)strlen(name);\n        /* Name of variable */\n        if ( array_name_len <= 4 ) {\n            array_name_type = (array_name_len << 16) | array_name_type;\n            byteswritten += fwrite(&array_name_type,4,1,(FILE*)mat->fp);\n            byteswritten += fwrite(name,1,array_name_len,(FILE*)mat->fp);\n            for ( i = array_name_len; i < 4; i++ )\n                byteswritten += fwrite(&pad1,1,1,(FILE*)mat->fp);\n        } else {\n            byteswritten += fwrite(&array_name_type,4,1,(FILE*)mat->fp);\n            byteswritten += fwrite(&array_name_len,4,1,(FILE*)mat->fp);\n            byteswritten += fwrite(name,1,array_name_len,(FILE*)mat->fp);\n            if ( array_name_len % 8 )\n                for ( i = array_name_len % 8; i < 8; i++ )\n                    byteswritten += fwrite(&pad1,1,1,(FILE*)mat->fp);\n        }\n    }\n\n    nBytes = WriteData(mat,NULL,0,MAT_T_DOUBLE);\n    byteswritten += nBytes;\n    if ( nBytes % 8 )\n        for ( i = nBytes % 8; i < 8; i++ )\n            byteswritten += fwrite(&pad1,1,1,(FILE*)mat->fp);\n\n    end = ftell((FILE*)mat->fp);\n    if ( start != -1L && end != -1L ) {\n        nBytes = (int)(end-start);\n        (void)fseek((FILE*)mat->fp,(long)-(nBytes+4),SEEK_CUR);\n        fwrite(&nBytes,4,1,(FILE*)mat->fp);\n        (void)fseek((FILE*)mat->fp,end,SEEK_SET);\n    } else {\n        Mat_Critical(\"Couldn't determine file position\");\n    }\n\n    return byteswritten;\n}\n\n#if defined(HAVE_ZLIB)\nstatic size_t\nMat_WriteCompressedEmptyVariable5(mat_t *mat,const char *name,int rank,\n                                  size_t *dims,z_streamp z)\n{\n    mat_uint32_t array_flags;\n    int array_flags_type = MAT_T_UINT32, dims_array_type = MAT_T_INT32;\n    int array_flags_size = 8;\n    int i, err;\n    size_t nBytes, empty_matrix_max_buf_size;\n\n    mat_uint32_t comp_buf[512];\n    mat_uint32_t uncomp_buf[512] = {0,};\n    int buf_size = 512;\n    size_t byteswritten = 0, buf_size_bytes;\n\n    if ( NULL == mat || NULL == z)\n        return byteswritten;\n\n    buf_size_bytes = buf_size*sizeof(*comp_buf);\n\n    /* Array Flags */\n    array_flags = MAT_C_DOUBLE;\n\n    uncomp_buf[0] = MAT_T_MATRIX;\n    err = GetEmptyMatrixMaxBufSize(name, rank, &empty_matrix_max_buf_size);\n    if (err || empty_matrix_max_buf_size > UINT32_MAX)\n        return byteswritten;\n    uncomp_buf[1] = empty_matrix_max_buf_size;\n    z->next_in  = ZLIB_BYTE_PTR(uncomp_buf);\n    z->avail_in = 8;\n    do {\n        z->next_out  = ZLIB_BYTE_PTR(comp_buf);\n        z->avail_out = buf_size_bytes;\n        deflate(z,Z_NO_FLUSH);\n        byteswritten += fwrite(comp_buf,1,buf_size_bytes-z->avail_out,(FILE*)mat->fp);\n    } while ( z->avail_out == 0 );\n    uncomp_buf[0] = array_flags_type;\n    uncomp_buf[1] = array_flags_size;\n    uncomp_buf[2] = array_flags;\n    uncomp_buf[3] = 0;\n    /* Rank and Dimension */\n    nBytes = rank * 4;\n    uncomp_buf[4] = dims_array_type;\n    uncomp_buf[5] = nBytes;\n    for ( i = 0; i < rank; i++ ) {\n        mat_int32_t dim;\n        dim = dims[i];\n        uncomp_buf[6+i] = dim;\n    }\n    if ( rank % 2 != 0 ) {\n        int pad4 = 0;\n        uncomp_buf[6+i] = pad4;\n        i++;\n    }\n\n    z->next_in  = ZLIB_BYTE_PTR(uncomp_buf);\n    z->avail_in = (6+i)*sizeof(*uncomp_buf);\n    do {\n        z->next_out  = ZLIB_BYTE_PTR(comp_buf);\n        z->avail_out = buf_size_bytes;\n        deflate(z,Z_NO_FLUSH);\n        byteswritten += fwrite(comp_buf,1,buf_size_bytes-z->avail_out,(FILE*)mat->fp);\n    } while ( z->avail_out == 0 );\n    /* Name of variable */\n    if ( NULL == name ) {\n        mat_int16_t array_name_type = MAT_T_INT8;\n        uncomp_buf[0] = array_name_type;\n        uncomp_buf[1] = 0;\n        z->next_in  = ZLIB_BYTE_PTR(uncomp_buf);\n        z->avail_in = 8;\n        do {\n            z->next_out  = ZLIB_BYTE_PTR(comp_buf);\n            z->avail_out = buf_size_bytes;\n            deflate(z,Z_NO_FLUSH);\n            byteswritten += fwrite(comp_buf,1,buf_size_bytes-z->avail_out,(FILE*)mat->fp);\n        } while ( z->avail_out == 0 );\n    } else if ( strlen(name) <= 4 ) {\n        mat_int16_t array_name_len = (mat_int16_t)strlen(name);\n        mat_int16_t array_name_type = MAT_T_INT8;\n\n        memset(uncomp_buf,0,8);\n        uncomp_buf[0] = (array_name_len << 16) | array_name_type;\n        memcpy(uncomp_buf+1,name,array_name_len);\n        if ( array_name_len % 4 )\n            array_name_len += 4-(array_name_len % 4);\n\n        z->next_in  = ZLIB_BYTE_PTR(uncomp_buf);\n        z->avail_in = 8;\n        do {\n            z->next_out  = ZLIB_BYTE_PTR(comp_buf);\n            z->avail_out = buf_size_bytes;\n            deflate(z,Z_NO_FLUSH);\n            byteswritten += fwrite(comp_buf,1,buf_size_bytes-z->avail_out,\n                (FILE*)mat->fp);\n        } while ( z->avail_out == 0 );\n    } else {\n        mat_int32_t array_name_len = (mat_int32_t)strlen(name);\n        mat_int32_t array_name_type = MAT_T_INT8;\n\n        memset(uncomp_buf,0,buf_size*sizeof(*uncomp_buf));\n        uncomp_buf[0] = array_name_type;\n        uncomp_buf[1] = array_name_len;\n        memcpy(uncomp_buf+2,name,array_name_len);\n        if ( array_name_len % 8 )\n            array_name_len += 8-(array_name_len % 8);\n        z->next_in  = ZLIB_BYTE_PTR(uncomp_buf);\n        z->avail_in = 8+array_name_len;\n        do {\n            z->next_out  = ZLIB_BYTE_PTR(comp_buf);\n            z->avail_out = buf_size_bytes;\n            deflate(z,Z_NO_FLUSH);\n            byteswritten += fwrite(comp_buf,1,buf_size_bytes-z->avail_out,\n                (FILE*)mat->fp);\n        } while ( z->avail_out == 0 );\n    }\n\n    byteswritten += WriteCompressedData(mat,z,NULL,0,MAT_T_DOUBLE);\n    return byteswritten;\n}\n#endif\n\n/** @if mat_devman\n * @brief Reads a data element including tag and data\n *\n * @ingroup mat_internal\n * @param mat MAT file pointer\n * @param matvar MAT variable pointer\n * @param data Pointer to store the data\n * @param N number of data elements allocated for the pointer\n * @endif\n */\nstatic void\nMat_VarReadNumeric5(mat_t *mat,matvar_t *matvar,void *data,size_t N)\n{\n    int nBytes = 0, data_in_tag = 0;\n    enum matio_types packed_type = MAT_T_UNKNOWN;\n    mat_uint32_t tag[2];\n\n    if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {\n#if defined(HAVE_ZLIB)\n        matvar->internal->z->avail_in = 0;\n        InflateDataType(mat,matvar->internal->z,tag);\n        if ( mat->byteswap )\n            (void)Mat_uint32Swap(tag);\n\n        packed_type = TYPE_FROM_TAG(tag[0]);\n        if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */\n            data_in_tag = 1;\n            nBytes = (tag[0] & 0xffff0000) >> 16;\n        } else {\n            data_in_tag = 0;\n            InflateDataType(mat,matvar->internal->z,tag+1);\n            if ( mat->byteswap )\n                (void)Mat_uint32Swap(tag+1);\n            nBytes = tag[1];\n        }\n#endif\n    } else {\n        size_t bytesread = fread(tag,4,1,(FILE*)mat->fp);\n        if ( mat->byteswap )\n            (void)Mat_uint32Swap(tag);\n        packed_type = TYPE_FROM_TAG(tag[0]);\n        if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */\n            data_in_tag = 1;\n            nBytes = (tag[0] & 0xffff0000) >> 16;\n        } else {\n            data_in_tag = 0;\n            bytesread += fread(tag+1,4,1,(FILE*)mat->fp);\n            if ( mat->byteswap )\n                (void)Mat_uint32Swap(tag+1);\n            nBytes = tag[1];\n        }\n    }\n    if ( nBytes == 0 ) {\n        matvar->nbytes = 0;\n        return;\n    }\n\n    if ( matvar->compression == MAT_COMPRESSION_NONE ) {\n        switch ( matvar->class_type ) {\n            case MAT_C_DOUBLE:\n                nBytes = ReadDoubleData(mat,(double*)data,packed_type,N);\n                break;\n            case MAT_C_SINGLE:\n                nBytes = ReadSingleData(mat,(float*)data,packed_type,N);\n                break;\n            case MAT_C_INT64:\n#ifdef HAVE_MAT_INT64_T\n                nBytes = ReadInt64Data(mat,(mat_int64_t*)data,packed_type,N);\n#endif\n                break;\n            case MAT_C_UINT64:\n#ifdef HAVE_MAT_UINT64_T\n                nBytes = ReadUInt64Data(mat,(mat_uint64_t*)data,packed_type,N);\n#endif\n                break;\n            case MAT_C_INT32:\n                nBytes = ReadInt32Data(mat,(mat_int32_t*)data,packed_type,N);\n                break;\n            case MAT_C_UINT32:\n                nBytes = ReadUInt32Data(mat,(mat_uint32_t*)data,packed_type,N);\n                break;\n            case MAT_C_INT16:\n                nBytes = ReadInt16Data(mat,(mat_int16_t*)data,packed_type,N);\n                break;\n            case MAT_C_UINT16:\n                nBytes = ReadUInt16Data(mat,(mat_uint16_t*)data,packed_type,N);\n                break;\n            case MAT_C_INT8:\n                nBytes = ReadInt8Data(mat,(mat_int8_t*)data,packed_type,N);\n                break;\n            case MAT_C_UINT8:\n                nBytes = ReadUInt8Data(mat,(mat_uint8_t*)data,packed_type,N);\n                break;\n            default:\n                break;\n        }\n        /*\n         * If the data was in the tag we started on a 4-byte\n         * boundary so add 4 to make it an 8-byte\n         */\n        if ( data_in_tag )\n            nBytes+=4;\n        if ( (nBytes % 8) != 0 )\n            (void)fseek((FILE*)mat->fp,8-(nBytes % 8),SEEK_CUR);\n#if defined(HAVE_ZLIB)\n    } else if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {\n        switch ( matvar->class_type ) {\n            case MAT_C_DOUBLE:\n                nBytes = ReadCompressedDoubleData(mat,matvar->internal->z,(double*)data,\n                                                  packed_type,N);\n                break;\n            case MAT_C_SINGLE:\n                nBytes = ReadCompressedSingleData(mat,matvar->internal->z,(float*)data,\n                                                  packed_type,N);\n                break;\n            case MAT_C_INT64:\n#ifdef HAVE_MAT_INT64_T\n                nBytes = ReadCompressedInt64Data(mat,matvar->internal->z,(mat_int64_t*)data,\n                                                 packed_type,N);\n#endif\n                break;\n            case MAT_C_UINT64:\n#ifdef HAVE_MAT_UINT64_T\n                nBytes = ReadCompressedUInt64Data(mat,matvar->internal->z,(mat_uint64_t*)data,\n                                                  packed_type,N);\n#endif\n                break;\n            case MAT_C_INT32:\n                nBytes = ReadCompressedInt32Data(mat,matvar->internal->z,(mat_int32_t*)data,\n                                                 packed_type,N);\n                break;\n            case MAT_C_UINT32:\n                nBytes = ReadCompressedUInt32Data(mat,matvar->internal->z,(mat_uint32_t*)data,\n                                                  packed_type,N);\n                break;\n            case MAT_C_INT16:\n                nBytes = ReadCompressedInt16Data(mat,matvar->internal->z,(mat_int16_t*)data,\n                                                 packed_type,N);\n                break;\n            case MAT_C_UINT16:\n                nBytes = ReadCompressedUInt16Data(mat,matvar->internal->z,(mat_uint16_t*)data,\n                                                  packed_type,N);\n                break;\n            case MAT_C_INT8:\n                nBytes = ReadCompressedInt8Data(mat,matvar->internal->z,(mat_int8_t*)data,\n                                                packed_type,N);\n                break;\n            case MAT_C_UINT8:\n                nBytes = ReadCompressedUInt8Data(mat,matvar->internal->z,(mat_uint8_t*)data,\n                                                 packed_type,N);\n                break;\n            default:\n                break;\n        }\n        /*\n         * If the data was in the tag we started on a 4-byte\n         * boundary so add 4 to make it an 8-byte\n         */\n        if ( data_in_tag )\n            nBytes+=4;\n        if ( (nBytes % 8) != 0 )\n            InflateSkip(mat,matvar->internal->z,8-(nBytes % 8));\n#endif\n    }\n}\n\n/** @if mat_devman\n * @brief Reads the data of a version 5 MAT variable\n *\n * @ingroup mat_internal\n * @param mat MAT file pointer\n * @param matvar MAT variable pointer to read the data\n * @endif\n */\nvoid\nMat_VarRead5(mat_t *mat, matvar_t *matvar)\n{\n    int nBytes = 0, byteswap, data_in_tag = 0, err;\n    size_t nelems = 1;\n    enum matio_types packed_type = MAT_T_UNKNOWN;\n    long fpos;\n    mat_uint32_t tag[2];\n    size_t bytesread = 0;\n\n    if ( matvar == NULL )\n        return;\n    else if ( matvar->rank == 0 )        /* An empty data set */\n        return;\n#if defined(HAVE_ZLIB)\n    else if ( NULL != matvar->internal->data ) {\n        /* Data already read in ReadNextStructField or ReadNextCell */\n        matvar->data = matvar->internal->data;\n        matvar->internal->data = NULL;\n        return;\n    }\n#endif\n    fpos = ftell((FILE*)mat->fp);\n    if ( fpos == -1L ) {\n        Mat_Critical(\"Couldn't determine file position\");\n        return;\n    }\n    err = SafeMulDims(matvar, &nelems);\n    if ( err ) {\n        Mat_Critical(\"Integer multiplication overflow\");\n        return;\n    }\n    byteswap = mat->byteswap;\n    switch ( matvar->class_type ) {\n        case MAT_C_EMPTY:\n            matvar->nbytes = 0;\n            matvar->data_size = sizeof(double);\n            matvar->data_type = MAT_T_DOUBLE;\n            matvar->rank = 2;\n            matvar->dims = (size_t*)malloc(matvar->rank*sizeof(*(matvar->dims)));\n            matvar->dims[0] = 0;\n            matvar->dims[1] = 0;\n            break;\n        case MAT_C_DOUBLE:\n            (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);\n            matvar->data_size = sizeof(double);\n            matvar->data_type = MAT_T_DOUBLE;\n            break;\n        case MAT_C_SINGLE:\n            (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);\n            matvar->data_size = sizeof(float);\n            matvar->data_type = MAT_T_SINGLE;\n            break;\n        case MAT_C_INT64:\n#ifdef HAVE_MAT_INT64_T\n            (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);\n            matvar->data_size = sizeof(mat_int64_t);\n            matvar->data_type = MAT_T_INT64;\n#endif\n            break;\n        case MAT_C_UINT64:\n#ifdef HAVE_MAT_UINT64_T\n            (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);\n            matvar->data_size = sizeof(mat_uint64_t);\n            matvar->data_type = MAT_T_UINT64;\n#endif\n            break;\n        case MAT_C_INT32:\n            (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);\n            matvar->data_size = sizeof(mat_int32_t);\n            matvar->data_type = MAT_T_INT32;\n            break;\n        case MAT_C_UINT32:\n            (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);\n            matvar->data_size = sizeof(mat_uint32_t);\n            matvar->data_type = MAT_T_UINT32;\n            break;\n        case MAT_C_INT16:\n            (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);\n            matvar->data_size = sizeof(mat_int16_t);\n            matvar->data_type = MAT_T_INT16;\n            break;\n        case MAT_C_UINT16:\n            (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);\n            matvar->data_size = sizeof(mat_uint16_t);\n            matvar->data_type = MAT_T_UINT16;\n            break;\n        case MAT_C_INT8:\n            (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);\n            matvar->data_size = sizeof(mat_int8_t);\n            matvar->data_type = MAT_T_INT8;\n            break;\n        case MAT_C_UINT8:\n            (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);\n            matvar->data_size = sizeof(mat_uint8_t);\n            matvar->data_type = MAT_T_UINT8;\n            break;\n        case MAT_C_CHAR:\n            (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);\n            if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {\n#if defined(HAVE_ZLIB)\n                matvar->internal->z->avail_in = 0;\n                InflateDataType(mat,matvar->internal->z,tag);\n                if ( byteswap )\n                    (void)Mat_uint32Swap(tag);\n                packed_type = TYPE_FROM_TAG(tag[0]);\n                if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */\n                    data_in_tag = 1;\n                    nBytes = (tag[0] & 0xffff0000) >> 16;\n                } else {\n                    data_in_tag = 0;\n                    InflateDataType(mat,matvar->internal->z,tag+1);\n                    if ( byteswap )\n                        (void)Mat_uint32Swap(tag+1);\n                    nBytes = tag[1];\n                }\n#endif\n                matvar->data_type = packed_type;\n                matvar->data_size = Mat_SizeOf(matvar->data_type);\n                matvar->nbytes = nBytes;\n            } else {\n                bytesread += fread(tag,4,1,(FILE*)mat->fp);\n                if ( byteswap )\n                    (void)Mat_uint32Swap(tag);\n                packed_type = TYPE_FROM_TAG(tag[0]);\n                if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */\n                    data_in_tag = 1;\n                    /* nBytes = (tag[0] & 0xffff0000) >> 16; */\n                } else {\n                    data_in_tag = 0;\n                    bytesread += fread(tag+1,4,1,(FILE*)mat->fp);\n                    if ( byteswap )\n                        (void)Mat_uint32Swap(tag+1);\n                    /* nBytes = tag[1]; */\n                }\n                matvar->data_type = MAT_T_UINT8;\n                matvar->data_size = Mat_SizeOf(MAT_T_UINT8);\n                err = SafeMul(&matvar->nbytes, nelems, matvar->data_size);\n                if ( err ) {\n                    Mat_Critical(\"Integer multiplication overflow\");\n                    break;\n                }\n            }\n            if ( matvar->isComplex ) {\n                break;\n            }\n            matvar->data = calloc(matvar->nbytes+1,1);\n            if ( NULL == matvar->data ) {\n                Mat_Critical(\"Couldn't allocate memory for the data\");\n                break;\n            }\n            if ( 0 == matvar->nbytes ) {\n                break;\n            }\n            {\n                size_t nbytes;\n                err = SafeMul(&nbytes, nelems, matvar->data_size);\n                if ( err || nbytes > matvar->nbytes ) {\n                    break;\n                }\n            }\n            if ( matvar->compression == MAT_COMPRESSION_NONE ) {\n                nBytes = ReadCharData(mat,(char*)matvar->data,packed_type,(int)nelems);\n                /*\n                 * If the data was in the tag we started on a 4-byte\n                 * boundary so add 4 to make it an 8-byte\n                 */\n                if ( data_in_tag )\n                    nBytes+=4;\n                if ( (nBytes % 8) != 0 )\n                    (void)fseek((FILE*)mat->fp,8-(nBytes % 8),SEEK_CUR);\n#if defined(HAVE_ZLIB)\n            } else if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {\n                nBytes = ReadCompressedCharData(mat,matvar->internal->z,\n                             (char*)matvar->data,packed_type,(int)nelems);\n                /*\n                 * If the data was in the tag we started on a 4-byte\n                 * boundary so add 4 to make it an 8-byte\n                 */\n                if ( data_in_tag )\n                    nBytes+=4;\n                if ( (nBytes % 8) != 0 )\n                    InflateSkip(mat,matvar->internal->z,8-(nBytes % 8));\n#endif\n            }\n            break;\n        case MAT_C_STRUCT:\n        {\n            matvar_t **fields;\n            size_t i, nelems_x_nfields;\n\n            matvar->data_type = MAT_T_STRUCT;\n            err = SafeMul(&nelems_x_nfields, nelems, matvar->internal->num_fields);\n            if ( err || !matvar->nbytes || !matvar->data_size || NULL == matvar->data )\n                break;\n            fields = (matvar_t **)matvar->data;\n            for ( i = 0; i < nelems_x_nfields; i++ ) {\n                if ( NULL != fields[i] ) {\n                    Mat_VarRead5(mat,fields[i]);\n                }\n            }\n            break;\n        }\n        case MAT_C_CELL:\n        {\n            matvar_t **cells;\n            size_t i;\n\n            if ( NULL == matvar->data ) {\n                Mat_Critical(\"Data is NULL for cell array %s\",matvar->name);\n                break;\n            }\n            cells = (matvar_t **)matvar->data;\n            for ( i = 0; i < nelems; i++ ) {\n                if ( NULL != cells[i] ) {\n                    Mat_VarRead5(mat, cells[i]);\n                }\n            }\n            /* FIXME: */\n            matvar->data_type = MAT_T_CELL;\n            break;\n        }\n        case MAT_C_SPARSE:\n        {\n            mat_int32_t N = 0;\n            mat_sparse_t *data;\n\n            matvar->data_size = sizeof(mat_sparse_t);\n            matvar->data      = malloc(matvar->data_size);\n            if ( matvar->data == NULL ) {\n                Mat_Critical(\"Mat_VarRead5: Allocation of data pointer failed\");\n                break;\n            }\n            data = (mat_sparse_t*)matvar->data;\n            data->nzmax  = matvar->nbytes;\n            (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);\n            /*  Read ir    */\n            bytesread += ReadSparse(mat, matvar, &data->nir, &data->ir);\n            /*  Read jc    */\n            bytesread += ReadSparse(mat, matvar, &data->njc, &data->jc);\n            /*  Read data  */\n            if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {\n#if defined(HAVE_ZLIB)\n                matvar->internal->z->avail_in = 0;\n                InflateDataType(mat,matvar->internal->z,tag);\n                if ( mat->byteswap )\n                    (void)Mat_uint32Swap(tag);\n                packed_type = TYPE_FROM_TAG(tag[0]);\n                if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */\n                    data_in_tag = 1;\n                    N = (tag[0] & 0xffff0000) >> 16;\n                } else {\n                    data_in_tag = 0;\n                    (void)ReadCompressedInt32Data(mat,matvar->internal->z,\n                             (mat_int32_t*)&N,MAT_T_INT32,1);\n                }\n#endif\n            } else {\n                bytesread += fread(tag,4,1,(FILE*)mat->fp);\n                if ( mat->byteswap )\n                    (void)Mat_uint32Swap(tag);\n                packed_type = TYPE_FROM_TAG(tag[0]);\n                if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */\n                    data_in_tag = 1;\n                    N = (tag[0] & 0xffff0000) >> 16;\n                } else {\n                    data_in_tag = 0;\n                    bytesread += fread(&N,4,1,(FILE*)mat->fp);\n                    if ( mat->byteswap )\n                        (void)Mat_int32Swap(&N);\n                }\n            }\n            if ( matvar->isLogical && packed_type == MAT_T_DOUBLE ) {\n                /* For some reason, MAT says the data type is a double,\n                 * but it appears to be written as 8-bit unsigned integer.\n                 */\n                packed_type = MAT_T_UINT8;\n            }\n#if defined(EXTENDED_SPARSE)\n            matvar->data_type = packed_type;\n#else\n            matvar->data_type = MAT_T_DOUBLE;\n#endif\n            {\n                size_t s_type = Mat_SizeOf(packed_type);\n                if ( s_type == 0 )\n                    break;\n                data->ndata = N / s_type;\n            }\n            if ( matvar->isComplex ) {\n                mat_complex_split_t *complex_data =\n                    ComplexMalloc(data->ndata*Mat_SizeOf(matvar->data_type));\n                if ( NULL == complex_data ) {\n                    Mat_Critical(\"Couldn't allocate memory for the complex sparse data\");\n                    break;\n                }\n                if ( matvar->compression == MAT_COMPRESSION_NONE ) {\n#if defined(EXTENDED_SPARSE)\n                    switch ( matvar->data_type ) {\n                        case MAT_T_DOUBLE:\n                            nBytes = ReadDoubleData(mat,(double*)complex_data->Re,\n                                packed_type,data->ndata);\n                            break;\n                        case MAT_T_SINGLE:\n                            nBytes = ReadSingleData(mat,(float*)complex_data->Re,\n                                packed_type,data->ndata);\n                            break;\n                        case MAT_T_INT64:\n#ifdef HAVE_MAT_INT64_T\n                            nBytes = ReadInt64Data(mat,(mat_int64_t*)complex_data->Re,\n                                packed_type,data->ndata);\n#endif\n                            break;\n                        case MAT_T_UINT64:\n#ifdef HAVE_MAT_UINT64_T\n                            nBytes = ReadUInt64Data(mat,(mat_uint64_t*)complex_data->Re,\n                                packed_type,data->ndata);\n#endif\n                            break;\n                        case MAT_T_INT32:\n                            nBytes = ReadInt32Data(mat,(mat_int32_t*)complex_data->Re,\n                                packed_type,data->ndata);\n                            break;\n                        case MAT_T_UINT32:\n                            nBytes = ReadUInt32Data(mat,(mat_uint32_t*)complex_data->Re,\n                                packed_type,data->ndata);\n                            break;\n                        case MAT_T_INT16:\n                            nBytes = ReadInt16Data(mat,(mat_int16_t*)complex_data->Re,\n                                packed_type,data->ndata);\n                            break;\n                        case MAT_T_UINT16:\n                            nBytes = ReadUInt16Data(mat,(mat_uint16_t*)complex_data->Re,\n                                packed_type,data->ndata);\n                            break;\n                        case MAT_T_INT8:\n                            nBytes = ReadInt8Data(mat,(mat_int8_t*)complex_data->Re,\n                                packed_type,data->ndata);\n                            break;\n                        case MAT_T_UINT8:\n                            nBytes = ReadUInt8Data(mat,(mat_uint8_t*)complex_data->Re,\n                                packed_type,data->ndata);\n                            break;\n                        default:\n                            break;\n                    }\n#else\n                    nBytes = ReadDoubleData(mat,(double*)complex_data->Re,\n                                 packed_type,data->ndata);\n#endif\n                    if ( data_in_tag )\n                        nBytes+=4;\n                    if ( (nBytes % 8) != 0 )\n                        (void)fseek((FILE*)mat->fp,8-(nBytes % 8),SEEK_CUR);\n\n                    /* Complex Data Tag */\n                    bytesread += fread(tag,4,1,(FILE*)mat->fp);\n                    if ( byteswap )\n                        (void)Mat_uint32Swap(tag);\n                    packed_type = TYPE_FROM_TAG(tag[0]);\n                    if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */\n                        data_in_tag = 1;\n                        nBytes = (tag[0] & 0xffff0000) >> 16;\n                    } else {\n                        data_in_tag = 0;\n                        bytesread += fread(tag+1,4,1,(FILE*)mat->fp);\n                        if ( byteswap )\n                            (void)Mat_uint32Swap(tag+1);\n                        nBytes = tag[1];\n                    }\n#if defined(EXTENDED_SPARSE)\n                    switch ( matvar->data_type ) {\n                        case MAT_T_DOUBLE:\n                            nBytes = ReadDoubleData(mat,(double*)complex_data->Im,\n                                packed_type,data->ndata);\n                            break;\n                        case MAT_T_SINGLE:\n                            nBytes = ReadSingleData(mat,(float*)complex_data->Im,\n                                packed_type,data->ndata);\n                            break;\n                        case MAT_T_INT64:\n#ifdef HAVE_MAT_INT64_T\n                            nBytes = ReadInt64Data(mat,(mat_int64_t*)complex_data->Im,\n                                packed_type,data->ndata);\n#endif\n                            break;\n                        case MAT_T_UINT64:\n#ifdef HAVE_MAT_UINT64_T\n                            nBytes = ReadUInt64Data(mat,(mat_uint64_t*)complex_data->Im,\n                                packed_type,data->ndata);\n#endif\n                            break;\n                        case MAT_T_INT32:\n                            nBytes = ReadInt32Data(mat,(mat_int32_t*)complex_data->Im,\n                                packed_type,data->ndata);\n                            break;\n                        case MAT_T_UINT32:\n                            nBytes = ReadUInt32Data(mat,(mat_uint32_t*)complex_data->Im,\n                                packed_type,data->ndata);\n                            break;\n                        case MAT_T_INT16:\n                            nBytes = ReadInt16Data(mat,(mat_int16_t*)complex_data->Im,\n                                packed_type,data->ndata);\n                            break;\n                        case MAT_T_UINT16:\n                            nBytes = ReadUInt16Data(mat,(mat_uint16_t*)complex_data->Im,\n                                packed_type,data->ndata);\n                            break;\n                        case MAT_T_INT8:\n                            nBytes = ReadInt8Data(mat,(mat_int8_t*)complex_data->Im,\n                                packed_type,data->ndata);\n                            break;\n                        case MAT_T_UINT8:\n                            nBytes = ReadUInt8Data(mat,(mat_uint8_t*)complex_data->Im,\n                                packed_type,data->ndata);\n                            break;\n                        default:\n                            break;\n                    }\n#else /* EXTENDED_SPARSE */\n                    nBytes = ReadDoubleData(mat,(double*)complex_data->Im,\n                                packed_type,data->ndata);\n#endif /* EXTENDED_SPARSE */\n                    if ( data_in_tag )\n                        nBytes+=4;\n                    if ( (nBytes % 8) != 0 )\n                        (void)fseek((FILE*)mat->fp,8-(nBytes % 8),SEEK_CUR);\n#if defined(HAVE_ZLIB)\n                } else if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {\n#if defined(EXTENDED_SPARSE)\n                    switch ( matvar->data_type ) {\n                        case MAT_T_DOUBLE:\n                            nBytes = ReadCompressedDoubleData(mat,matvar->internal->z,\n                                 (double*)complex_data->Re,packed_type,data->ndata);\n                            break;\n                        case MAT_T_SINGLE:\n                            nBytes = ReadCompressedSingleData(mat,matvar->internal->z,\n                                 (float*)complex_data->Re,packed_type,data->ndata);\n                            break;\n                        case MAT_T_INT64:\n#ifdef HAVE_MAT_INT64_T\n                            nBytes = ReadCompressedInt64Data(mat,\n                                matvar->internal->z,(mat_int64_t*)complex_data->Re,\n                                packed_type,data->ndata);\n#endif\n                            break;\n                        case MAT_T_UINT64:\n#ifdef HAVE_MAT_UINT64_T\n                            nBytes = ReadCompressedUInt64Data(mat,\n                                matvar->internal->z,(mat_uint64_t*)complex_data->Re,\n                                packed_type,data->ndata);\n#endif\n                            break;\n                        case MAT_T_INT32:\n                            nBytes = ReadCompressedInt32Data(mat,matvar->internal->z,\n                                 (mat_int32_t*)complex_data->Re,packed_type,data->ndata);\n                            break;\n                        case MAT_T_UINT32:\n                            nBytes = ReadCompressedUInt32Data(mat,matvar->internal->z,\n                                 (mat_uint32_t*)complex_data->Re,packed_type,data->ndata);\n                            break;\n                        case MAT_T_INT16:\n                            nBytes = ReadCompressedInt16Data(mat,matvar->internal->z,\n                                 (mat_int16_t*)complex_data->Re,packed_type,data->ndata);\n                            break;\n                        case MAT_T_UINT16:\n                            nBytes = ReadCompressedUInt16Data(mat,matvar->internal->z,\n                                 (mat_uint16_t*)complex_data->Re,packed_type,data->ndata);\n                            break;\n                        case MAT_T_INT8:\n                            nBytes = ReadCompressedInt8Data(mat,matvar->internal->z,\n                                 (mat_int8_t*)complex_data->Re,packed_type,data->ndata);\n                            break;\n                        case MAT_T_UINT8:\n                            nBytes = ReadCompressedUInt8Data(mat,matvar->internal->z,\n                                 (mat_uint8_t*)complex_data->Re,packed_type,data->ndata);\n                            break;\n                        default:\n                            break;\n                    }\n#else    /* EXTENDED_SPARSE */\n                    nBytes = ReadCompressedDoubleData(mat,matvar->internal->z,\n                                 (double*)complex_data->Re,packed_type,data->ndata);\n#endif    /* EXTENDED_SPARSE */\n                    if ( data_in_tag )\n                        nBytes+=4;\n                    if ( (nBytes % 8) != 0 )\n                        InflateSkip(mat,matvar->internal->z,8-(nBytes % 8));\n\n                    /* Complex Data Tag */\n                    InflateDataType(mat,matvar->internal->z,tag);\n                    if ( byteswap )\n                        (void)Mat_uint32Swap(tag);\n\n                    packed_type = TYPE_FROM_TAG(tag[0]);\n                    if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */\n                        data_in_tag = 1;\n                        nBytes = (tag[0] & 0xffff0000) >> 16;\n                    } else {\n                        data_in_tag = 0;\n                        InflateDataType(mat,matvar->internal->z,tag+1);\n                        if ( byteswap )\n                            (void)Mat_uint32Swap(tag+1);\n                        nBytes = tag[1];\n                    }\n#if defined(EXTENDED_SPARSE)\n                    switch ( matvar->data_type ) {\n                        case MAT_T_DOUBLE:\n                            nBytes = ReadCompressedDoubleData(mat,matvar->internal->z,\n                                 (double*)complex_data->Im,packed_type,data->ndata);\n                            break;\n                        case MAT_T_SINGLE:\n                            nBytes = ReadCompressedSingleData(mat,matvar->internal->z,\n                                 (float*)complex_data->Im,packed_type,data->ndata);\n                            break;\n                        case MAT_T_INT64:\n#ifdef HAVE_MAT_INT64_T\n                            nBytes = ReadCompressedInt64Data(mat,\n                                matvar->internal->z,(mat_int64_t*)complex_data->Im,\n                                packed_type,data->ndata);\n#endif\n                            break;\n                        case MAT_T_UINT64:\n#ifdef HAVE_MAT_UINT64_T\n                            nBytes = ReadCompressedUInt64Data(mat,\n                                matvar->internal->z,(mat_uint64_t*)complex_data->Im,\n                                packed_type,data->ndata);\n#endif\n                            break;\n                        case MAT_T_INT32:\n                            nBytes = ReadCompressedInt32Data(mat,matvar->internal->z,\n                                 (mat_int32_t*)complex_data->Im,packed_type,data->ndata);\n                            break;\n                        case MAT_T_UINT32:\n                            nBytes = ReadCompressedUInt32Data(mat,matvar->internal->z,\n                                 (mat_uint32_t*)complex_data->Im,packed_type,data->ndata);\n                            break;\n                        case MAT_T_INT16:\n                            nBytes = ReadCompressedInt16Data(mat,matvar->internal->z,\n                                 (mat_int16_t*)complex_data->Im,packed_type,data->ndata);\n                            break;\n                        case MAT_T_UINT16:\n                            nBytes = ReadCompressedUInt16Data(mat,matvar->internal->z,\n                                 (mat_uint16_t*)complex_data->Im,packed_type,data->ndata);\n                            break;\n                        case MAT_T_INT8:\n                            nBytes = ReadCompressedInt8Data(mat,matvar->internal->z,\n                                 (mat_int8_t*)complex_data->Im,packed_type,data->ndata);\n                            break;\n                        case MAT_T_UINT8:\n                            nBytes = ReadCompressedUInt8Data(mat,matvar->internal->z,\n                                 (mat_uint8_t*)complex_data->Im,packed_type,data->ndata);\n                            break;\n                        default:\n                            break;\n                    }\n#else    /* EXTENDED_SPARSE */\n                    nBytes = ReadCompressedDoubleData(mat,matvar->internal->z,\n                                 (double*)complex_data->Im,packed_type,data->ndata);\n#endif    /* EXTENDED_SPARSE */\n                    if ( data_in_tag )\n                        nBytes+=4;\n                    if ( (nBytes % 8) != 0 )\n                        InflateSkip(mat,matvar->internal->z,8-(nBytes % 8));\n#endif    /* HAVE_ZLIB */\n                }\n                data->data = complex_data;\n            } else { /* isComplex */\n                data->data = malloc(data->ndata*Mat_SizeOf(matvar->data_type));\n                if ( data->data == NULL ) {\n                    Mat_Critical(\"Couldn't allocate memory for the sparse data\");\n                    break;\n                }\n                if ( matvar->compression == MAT_COMPRESSION_NONE ) {\n#if defined(EXTENDED_SPARSE)\n                    switch ( matvar->data_type ) {\n                        case MAT_T_DOUBLE:\n                            nBytes = ReadDoubleData(mat,(double*)data->data,\n                                packed_type,data->ndata);\n                            break;\n                        case MAT_T_SINGLE:\n                            nBytes = ReadSingleData(mat,(float*)data->data,\n                                packed_type,data->ndata);\n                            break;\n                        case MAT_T_INT64:\n#ifdef HAVE_MAT_INT64_T\n                            nBytes = ReadInt64Data(mat,(mat_int64_t*)data->data,\n                                packed_type,data->ndata);\n#endif\n                            break;\n                        case MAT_T_UINT64:\n#ifdef HAVE_MAT_UINT64_T\n                            nBytes = ReadUInt64Data(mat,(mat_uint64_t*)data->data,\n                                packed_type,data->ndata);\n#endif\n                            break;\n                        case MAT_T_INT32:\n                            nBytes = ReadInt32Data(mat,(mat_int32_t*)data->data,\n                                packed_type,data->ndata);\n                            break;\n                        case MAT_T_UINT32:\n                            nBytes = ReadUInt32Data(mat,(mat_uint32_t*)data->data,\n                                packed_type,data->ndata);\n                            break;\n                        case MAT_T_INT16:\n                            nBytes = ReadInt16Data(mat,(mat_int16_t*)data->data,\n                                packed_type,data->ndata);\n                            break;\n                        case MAT_T_UINT16:\n                            nBytes = ReadUInt16Data(mat,(mat_uint16_t*)data->data,\n                                packed_type,data->ndata);\n                            break;\n                        case MAT_T_INT8:\n                            nBytes = ReadInt8Data(mat,(mat_int8_t*)data->data,\n                                packed_type,data->ndata);\n                            break;\n                        case MAT_T_UINT8:\n                            nBytes = ReadUInt8Data(mat,(mat_uint8_t*)data->data,\n                                packed_type,data->ndata);\n                            break;\n                        default:\n                            break;\n                    }\n#else\n                    nBytes = ReadDoubleData(mat,(double*)data->data,packed_type,\n                                 data->ndata);\n#endif\n                    if ( data_in_tag )\n                        nBytes+=4;\n                    if ( (nBytes % 8) != 0 )\n                        (void)fseek((FILE*)mat->fp,8-(nBytes % 8),SEEK_CUR);\n#if defined(HAVE_ZLIB)\n                } else if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {\n#if defined(EXTENDED_SPARSE)\n                    switch ( matvar->data_type ) {\n                        case MAT_T_DOUBLE:\n                            nBytes = ReadCompressedDoubleData(mat,matvar->internal->z,\n                                 (double*)data->data,packed_type,data->ndata);\n                            break;\n                        case MAT_T_SINGLE:\n                            nBytes = ReadCompressedSingleData(mat,matvar->internal->z,\n                                 (float*)data->data,packed_type,data->ndata);\n                            break;\n                        case MAT_T_INT64:\n#ifdef HAVE_MAT_INT64_T\n                            nBytes = ReadCompressedInt64Data(mat,\n                                matvar->internal->z,(mat_int64_t*)data->data,packed_type,\n                                data->ndata);\n#endif\n                            break;\n                        case MAT_T_UINT64:\n#ifdef HAVE_MAT_UINT64_T\n                            nBytes = ReadCompressedUInt64Data(mat,\n                                matvar->internal->z,(mat_uint64_t*)data->data,packed_type,\n                                data->ndata);\n#endif\n                            break;\n                        case MAT_T_INT32:\n                            nBytes = ReadCompressedInt32Data(mat,matvar->internal->z,\n                                 (mat_int32_t*)data->data,packed_type,data->ndata);\n                            break;\n                        case MAT_T_UINT32:\n                            nBytes = ReadCompressedUInt32Data(mat,matvar->internal->z,\n                                 (mat_uint32_t*)data->data,packed_type,data->ndata);\n                            break;\n                        case MAT_T_INT16:\n                            nBytes = ReadCompressedInt16Data(mat,matvar->internal->z,\n                                 (mat_int16_t*)data->data,packed_type,data->ndata);\n                            break;\n                        case MAT_T_UINT16:\n                            nBytes = ReadCompressedUInt16Data(mat,matvar->internal->z,\n                                 (mat_uint16_t*)data->data,packed_type,data->ndata);\n                            break;\n                        case MAT_T_INT8:\n                            nBytes = ReadCompressedInt8Data(mat,matvar->internal->z,\n                                 (mat_int8_t*)data->data,packed_type,data->ndata);\n                            break;\n                        case MAT_T_UINT8:\n                            nBytes = ReadCompressedUInt8Data(mat,matvar->internal->z,\n                                 (mat_uint8_t*)data->data,packed_type,data->ndata);\n                            break;\n                        default:\n                            break;\n                    }\n#else   /* EXTENDED_SPARSE */\n                    nBytes = ReadCompressedDoubleData(mat,matvar->internal->z,\n                                 (double*)data->data,packed_type,data->ndata);\n#endif   /* EXTENDED_SPARSE */\n                    if ( data_in_tag )\n                        nBytes+=4;\n                    if ( (nBytes % 8) != 0 )\n                        InflateSkip(mat,matvar->internal->z,8-(nBytes % 8));\n#endif   /* HAVE_ZLIB */\n                }\n            }\n            break;\n        }\n        case MAT_C_FUNCTION:\n        {\n            matvar_t **functions;\n            size_t nfunctions = 0;\n\n            if ( !matvar->nbytes || !matvar->data_size )\n                break;\n            nfunctions = matvar->nbytes / matvar->data_size;\n            functions = (matvar_t **)matvar->data;\n            if ( NULL != functions ) {\n                size_t i;\n                for ( i = 0; i < nfunctions; i++ ) {\n                    Mat_VarRead5(mat,functions[i]);\n                }\n            }\n            /* FIXME: */\n            matvar->data_type = MAT_T_FUNCTION;\n            break;\n        }\n        default:\n            Mat_Critical(\"Mat_VarRead5: %d is not a supported class\", matvar->class_type);\n    }\n    switch ( matvar->class_type ) {\n        case MAT_C_DOUBLE:\n        case MAT_C_SINGLE:\n#ifdef HAVE_MAT_INT64_T\n        case MAT_C_INT64:\n#endif\n#ifdef HAVE_MAT_UINT64_T\n        case MAT_C_UINT64:\n#endif\n        case MAT_C_INT32:\n        case MAT_C_UINT32:\n        case MAT_C_INT16:\n        case MAT_C_UINT16:\n        case MAT_C_INT8:\n        case MAT_C_UINT8:\n            if ( matvar->isComplex ) {\n                mat_complex_split_t *complex_data;\n\n                err = SafeMul(&matvar->nbytes, nelems, matvar->data_size);\n                if ( err ) {\n                    Mat_Critical(\"Integer multiplication overflow\");\n                    break;\n                }\n\n                complex_data = ComplexMalloc(matvar->nbytes);\n                if ( NULL == complex_data ) {\n                    Mat_Critical(\"Couldn't allocate memory for the complex data\");\n                    break;\n                }\n\n                Mat_VarReadNumeric5(mat,matvar,complex_data->Re,nelems);\n                Mat_VarReadNumeric5(mat,matvar,complex_data->Im,nelems);\n                matvar->data = complex_data;\n            } else {\n                err = SafeMul(&matvar->nbytes, nelems, matvar->data_size);\n                if ( err ) {\n                    Mat_Critical(\"Integer multiplication overflow\");\n                    break;\n                }\n\n                matvar->data = malloc(matvar->nbytes);\n                if ( NULL == matvar->data ) {\n                    Mat_Critical(\"Couldn't allocate memory for the data\");\n                    break;\n                }\n                Mat_VarReadNumeric5(mat,matvar,matvar->data,nelems);\n            }\n        default:\n            break;\n    }\n    (void)fseek((FILE*)mat->fp,fpos,SEEK_SET);\n\n    return;\n}\n\n#if defined(HAVE_ZLIB)\n#define GET_DATA_SLABN_RANK_LOOP \\\n    do { \\\n        for ( j = 1; j < rank; j++ ) { \\\n            cnt[j]++; \\\n            if ( (cnt[j] % edge[j]) == 0 ) { \\\n                cnt[j] = 0; \\\n                if ( (I % dimp[j]) != 0 ) { \\\n                    ptr_in += dimp[j]-(I % dimp[j])+dimp[j-1]*start[j]; \\\n                    I += dimp[j]-(I % dimp[j]) + dimp[j-1]*start[j]; \\\n                } else if ( start[j] ) { \\\n                    ptr_in += dimp[j-1]*start[j]; \\\n                    I += dimp[j-1]*start[j]; \\\n                } \\\n            } else { \\\n                I += inc[j]; \\\n                ptr_in += inc[j]; \\\n                break; \\\n            } \\\n        } \\\n    } while (0)\n\n#define GET_DATA_SLAB2(T) \\\n    do { \\\n        ptr_in += start[1]*dims[0] + start[0]; \\\n        for ( i = 0; i < edge[1]; i++ ) { \\\n            for ( j = 0; j < edge[0]; j++ ) { \\\n                *ptr = (T)(*(ptr_in+j*stride[0])); \\\n                ptr++; \\\n            } \\\n            ptr_in += stride[1]*dims[0]; \\\n        } \\\n    } while (0)\n\n#define GET_DATA_SLABN(T) \\\n    do { \\\n        inc[0]  = stride[0]-1; \\\n        dimp[0] = dims[0]; \\\n        N       = edge[0]; \\\n        I       = 0; /* start[0]; */ \\\n        for ( i = 1; i < rank; i++ ) { \\\n            inc[i]  = stride[i]-1; \\\n            dimp[i] = dims[i-1]; \\\n            for ( j = i; j--; ) { \\\n                inc[i]  *= dims[j]; \\\n                dimp[i] *= dims[j+1]; \\\n            } \\\n            N *= edge[i]; \\\n            I += dimp[i-1]*start[i]; \\\n        } \\\n        ptr_in += I; \\\n        if ( stride[0] == 1 ) { \\\n            for ( i = 0; i < N; i+=edge[0] ) { \\\n                int k; \\\n                if ( start[0] ) { \\\n                    ptr_in += start[0]; \\\n                    I += start[0]; \\\n                } \\\n                for ( k = 0; k < edge[0]; k++ ) { \\\n                    *(ptr+i+k) = (T)(*(ptr_in+k)); \\\n                } \\\n                I += dims[0]-start[0]; \\\n                ptr_in += dims[0]-start[0]; \\\n                GET_DATA_SLABN_RANK_LOOP; \\\n            } \\\n        } else { \\\n            for ( i = 0; i < N; i+=edge[0] ) { \\\n                if ( start[0] ) { \\\n                    ptr_in += start[0]; \\\n                    I += start[0]; \\\n                } \\\n                for ( j = 0; j < edge[0]; j++ ) { \\\n                    *(ptr+i+j) = (T)(*ptr_in); \\\n                    ptr_in += stride[0]; \\\n                    I += stride[0]; \\\n                } \\\n                I += dims[0]-(ptrdiff_t)edge[0]*stride[0]-start[0]; \\\n                ptr_in += dims[0]-(ptrdiff_t)edge[0]*stride[0]-start[0]; \\\n                GET_DATA_SLABN_RANK_LOOP; \\\n            } \\\n        } \\\n    } while (0)\n\n#ifdef HAVE_MAT_INT64_T\n#define GET_DATA_SLAB2_INT64(T) \\\n    do { \\\n        if ( MAT_T_INT64 == data_type ) { \\\n            mat_int64_t *ptr_in = (mat_int64_t *)data_in; \\\n            GET_DATA_SLAB2(T); \\\n            err = 0; \\\n        } \\\n    } while (0)\n#else\n#define GET_DATA_SLAB2_INT64(T)\n#endif /* HAVE_MAT_INT64_T */\n\n#ifdef HAVE_MAT_UINT64_T\n#define GET_DATA_SLAB2_UINT64(T) \\\n    do { \\\n        if ( MAT_T_UINT64 == data_type ) { \\\n            mat_uint64_t *ptr_in = (mat_uint64_t *)data_in; \\\n            GET_DATA_SLAB2(T); \\\n            err = 0; \\\n        } \\\n    } while (0)\n#else\n#define GET_DATA_SLAB2_UINT64(T)\n#endif /* HAVE_MAT_UINT64_T */\n\n#define GET_DATA_SLAB2_TYPE(T) \\\n    do { \\\n        switch ( data_type ) { \\\n            case MAT_T_DOUBLE: \\\n            { \\\n                double *ptr_in = (double *)data_in; \\\n                GET_DATA_SLAB2(T); \\\n                break; \\\n            } \\\n            case MAT_T_SINGLE: \\\n            { \\\n                float *ptr_in = (float *)data_in; \\\n                GET_DATA_SLAB2(T); \\\n                break; \\\n            } \\\n            case MAT_T_INT32: \\\n            { \\\n                mat_int32_t *ptr_in = (mat_int32_t *)data_in; \\\n                GET_DATA_SLAB2(T); \\\n                break; \\\n            } \\\n            case MAT_T_UINT32: \\\n            { \\\n                mat_uint32_t *ptr_in = (mat_uint32_t *)data_in; \\\n                GET_DATA_SLAB2(T); \\\n                break; \\\n            } \\\n            case MAT_T_INT16: \\\n            { \\\n                mat_int16_t *ptr_in = (mat_int16_t *)data_in; \\\n                GET_DATA_SLAB2(T); \\\n                break; \\\n            } \\\n            case MAT_T_UINT16: \\\n            { \\\n                mat_uint16_t *ptr_in = (mat_uint16_t *)data_in; \\\n                GET_DATA_SLAB2(T); \\\n                break; \\\n            } \\\n            case MAT_T_INT8: \\\n            { \\\n                mat_int8_t *ptr_in = (mat_int8_t *)data_in; \\\n                GET_DATA_SLAB2(T); \\\n                break; \\\n            } \\\n            case MAT_T_UINT8: \\\n            { \\\n                mat_uint8_t *ptr_in = (mat_uint8_t *)data_in; \\\n                GET_DATA_SLAB2(T); \\\n                break; \\\n            } \\\n            default: \\\n                err = 1; \\\n                GET_DATA_SLAB2_INT64(T); \\\n                GET_DATA_SLAB2_UINT64(T); \\\n                break; \\\n        } \\\n    } while (0)\n\n#ifdef HAVE_MAT_INT64_T\n#define GET_DATA_SLABN_INT64(T) \\\n    do { \\\n        if ( MAT_T_INT64 == data_type ) { \\\n            mat_int64_t *ptr_in = (mat_int64_t *)data_in; \\\n            GET_DATA_SLABN(T); \\\n            err = 0; \\\n        } \\\n    } while (0)\n#else\n#define GET_DATA_SLABN_INT64(T)\n#endif /* HAVE_MAT_INT64_T */\n\n#ifdef HAVE_MAT_UINT64_T\n#define GET_DATA_SLABN_UINT64(T) \\\n    do { \\\n        if ( MAT_T_UINT64 == data_type ) { \\\n            mat_uint64_t *ptr_in = (mat_uint64_t *)data_in; \\\n            GET_DATA_SLABN(T); \\\n            err = 0; \\\n        } \\\n    } while (0)\n#else\n#define GET_DATA_SLABN_UINT64(T)\n#endif /* HAVE_MAT_UINT64_T */\n\n#define GET_DATA_SLABN_TYPE(T) \\\n    do { \\\n        switch ( data_type ) { \\\n            case MAT_T_DOUBLE: \\\n            { \\\n                double *ptr_in = (double *)data_in; \\\n                GET_DATA_SLABN(T); \\\n                break; \\\n            } \\\n            case MAT_T_SINGLE: \\\n            { \\\n                float *ptr_in = (float *)data_in; \\\n                GET_DATA_SLABN(T); \\\n                break; \\\n            } \\\n            case MAT_T_INT32: \\\n            { \\\n                mat_int32_t *ptr_in = (mat_int32_t *)data_in; \\\n                GET_DATA_SLABN(T); \\\n                break; \\\n            } \\\n            case MAT_T_UINT32: \\\n            { \\\n                mat_uint32_t *ptr_in = (mat_uint32_t *)data_in; \\\n                GET_DATA_SLABN(T); \\\n                break; \\\n            } \\\n            case MAT_T_INT16: \\\n            { \\\n                mat_int16_t *ptr_in = (mat_int16_t *)data_in; \\\n                GET_DATA_SLABN(T); \\\n                break; \\\n            } \\\n            case MAT_T_UINT16: \\\n            { \\\n                mat_uint16_t *ptr_in = (mat_uint16_t *)data_in; \\\n                GET_DATA_SLABN(T); \\\n                break; \\\n            } \\\n            case MAT_T_INT8: \\\n            { \\\n                mat_int8_t *ptr_in = (mat_int8_t *)data_in; \\\n                GET_DATA_SLABN(T); \\\n                break; \\\n            } \\\n            case MAT_T_UINT8: \\\n            { \\\n                mat_uint8_t *ptr_in = (mat_uint8_t *)data_in; \\\n                GET_DATA_SLABN(T); \\\n                break; \\\n            } \\\n            default: \\\n                err = 1; \\\n                GET_DATA_SLABN_INT64(T); \\\n                GET_DATA_SLABN_UINT64(T); \\\n                break; \\\n        } \\\n    } while (0)\n\nstatic int\nGetDataSlab(void *data_in, void *data_out, enum matio_classes class_type,\n    enum matio_types data_type, size_t *dims, int *start, int *stride, int *edge,\n    int rank, size_t nbytes)\n{\n    int err = 0;\n    int same_type = 0;\n    if (( class_type == MAT_C_DOUBLE && data_type == MAT_T_DOUBLE ) ||\n        ( class_type == MAT_C_SINGLE && data_type == MAT_T_SINGLE ) ||\n        ( class_type == MAT_C_INT16 && data_type == MAT_T_INT16 ) ||\n        ( class_type == MAT_C_INT32 && data_type == MAT_T_INT32 ) ||\n        ( class_type == MAT_C_INT64 && data_type == MAT_T_INT64 ) ||\n        ( class_type == MAT_C_INT8 && data_type == MAT_T_INT8 ) ||\n        ( class_type == MAT_C_UINT16 && data_type == MAT_T_UINT16 ) ||\n        ( class_type == MAT_C_UINT32 && data_type == MAT_T_UINT32 ) ||\n        ( class_type == MAT_C_UINT64 && data_type == MAT_T_UINT64 ) ||\n        ( class_type == MAT_C_UINT8 && data_type == MAT_T_UINT8 ))\n        same_type = 1;\n\n    if ( rank == 2 ) {\n        if ( (size_t)stride[0]*(edge[0]-1)+start[0]+1 > dims[0] )\n            err = 1;\n        else if ( (size_t)stride[1]*(edge[1]-1)+start[1]+1 > dims[1] )\n            err = 1;\n        else if ( ( stride[0] == 1 && edge[0] == dims[0] ) &&\n                  ( stride[1] == 1 ) && ( same_type == 1 ) )\n            memcpy(data_out, data_in, nbytes);\n        else {\n            int i, j;\n\n            switch ( class_type ) {\n                case MAT_C_DOUBLE:\n                {\n                    double *ptr = (double *)data_out;\n                    GET_DATA_SLAB2_TYPE(double);\n                    break;\n                }\n                case MAT_C_SINGLE:\n                {\n                    float *ptr = (float *)data_out;\n                    GET_DATA_SLAB2_TYPE(float);\n                    break;\n                }\n#ifdef HAVE_MAT_INT64_T\n                case MAT_C_INT64:\n                {\n                    mat_int64_t *ptr = (mat_int64_t *)data_out;\n                    GET_DATA_SLAB2_TYPE(mat_int64_t);\n                    break;\n                }\n#endif /* HAVE_MAT_INT64_T */\n#ifdef HAVE_MAT_UINT64_T\n                case MAT_C_UINT64:\n                {\n                    mat_uint64_t *ptr = (mat_uint64_t *)data_out;\n                    GET_DATA_SLAB2_TYPE(mat_uint64_t);\n                    break;\n                }\n#endif /* HAVE_MAT_UINT64_T */\n                case MAT_C_INT32:\n                {\n                    mat_int32_t *ptr = (mat_int32_t *)data_out;\n                    GET_DATA_SLAB2_TYPE(mat_int32_t);\n                    break;\n                }\n                case MAT_C_UINT32:\n                {\n                    mat_uint32_t *ptr = (mat_uint32_t *)data_out;\n                    GET_DATA_SLAB2_TYPE(mat_uint32_t);\n                    break;\n                }\n                case MAT_C_INT16:\n                {\n                    mat_int16_t *ptr = (mat_int16_t *)data_out;\n                    GET_DATA_SLAB2_TYPE(mat_int16_t);\n                    break;\n                }\n                case MAT_C_UINT16:\n                {\n                    mat_uint16_t *ptr = (mat_uint16_t *)data_out;\n                    GET_DATA_SLAB2_TYPE(mat_uint16_t);\n                    break;\n                }\n                case MAT_C_INT8:\n                {\n                    mat_int8_t *ptr = (mat_int8_t *)data_out;\n                    GET_DATA_SLAB2_TYPE(mat_int8_t);\n                    break;\n                }\n                case MAT_C_UINT8:\n                {\n                    mat_uint8_t *ptr = (mat_uint8_t *)data_out;\n                    GET_DATA_SLAB2_TYPE(mat_uint8_t);\n                    break;\n                }\n                default:\n                    err = 1;\n                    break;\n            }\n        }\n    } else {\n        int i, j, N, I = 0;\n        int inc[10] = {0,}, cnt[10] = {0,}, dimp[10] = {0,};\n\n        switch ( class_type ) {\n            case MAT_C_DOUBLE:\n            {\n                double *ptr = (double *)data_out;\n                GET_DATA_SLABN_TYPE(double);\n                break;\n            }\n            case MAT_C_SINGLE:\n            {\n                float *ptr = (float *)data_out;\n                GET_DATA_SLABN_TYPE(float);\n                break;\n            }\n#ifdef HAVE_MAT_INT64_T\n            case MAT_C_INT64:\n            {\n                mat_int64_t *ptr = (mat_int64_t *)data_out;\n                GET_DATA_SLABN_TYPE(mat_int64_t);\n                break;\n            }\n#endif /* HAVE_MAT_INT64_T */\n#ifdef HAVE_MAT_UINT64_T\n            case MAT_C_UINT64:\n            {\n                mat_uint64_t *ptr = (mat_uint64_t *)data_out;\n                GET_DATA_SLABN_TYPE(mat_uint64_t);\n                break;\n            }\n#endif /* HAVE_MAT_UINT64_T */\n            case MAT_C_INT32:\n            {\n                mat_int32_t *ptr = (mat_int32_t *)data_out;\n                GET_DATA_SLABN_TYPE(mat_int32_t);\n                break;\n            }\n            case MAT_C_UINT32:\n            {\n                mat_uint32_t *ptr = (mat_uint32_t *)data_out;\n                GET_DATA_SLABN_TYPE(mat_uint32_t);\n                break;\n            }\n            case MAT_C_INT16:\n            {\n                mat_int16_t *ptr = (mat_int16_t *)data_out;\n                GET_DATA_SLABN_TYPE(mat_int16_t);\n                break;\n            }\n            case MAT_C_UINT16:\n            {\n                mat_uint16_t *ptr = (mat_uint16_t *)data_out;\n                GET_DATA_SLABN_TYPE(mat_uint16_t);\n                break;\n            }\n            case MAT_C_INT8:\n            {\n                mat_int8_t *ptr = (mat_int8_t *)data_out;\n                GET_DATA_SLABN_TYPE(mat_int8_t);\n                break;\n            }\n            case MAT_C_UINT8:\n            {\n                mat_uint8_t *ptr = (mat_uint8_t *)data_out;\n                GET_DATA_SLABN_TYPE(mat_uint8_t);\n                break;\n            }\n            default:\n                err = 1;\n                break;\n        }\n    }\n\n    return err;\n}\n\n#undef GET_DATA_SLAB2\n#undef GET_DATA_SLAB2_TYPE\n#undef GET_DATA_SLAB2_INT64\n#undef GET_DATA_SLAB2_UINT64\n#undef GET_DATA_SLABN\n#undef GET_DATA_SLABN_TYPE\n#undef GET_DATA_SLABN_INT64\n#undef GET_DATA_SLABN_UINT64\n#undef GET_DATA_SLABN_RANK_LOOP\n\n#define GET_DATA_LINEAR \\\n    do { \\\n        ptr_in += start; \\\n        if ( !stride ) { \\\n            memcpy(ptr, ptr_in, (size_t)edge*data_size); \\\n        } else { \\\n            int i; \\\n            for ( i = 0; i < edge; i++ ) \\\n                memcpy(ptr++, ptr_in+i*stride, data_size); \\\n        } \\\n    } while (0)\n\nstatic int\nGetDataLinear(void *data_in, void *data_out, enum matio_classes class_type,\n    enum matio_types data_type, int start, int stride, int edge)\n{\n    int err = 0;\n    size_t data_size = Mat_SizeOf(data_type);\n\n    switch ( class_type ) {\n        case MAT_C_DOUBLE:\n        {\n            double *ptr = (double *)data_out;\n            double *ptr_in = (double*)data_in;\n            GET_DATA_LINEAR;\n            break;\n        }\n        case MAT_C_SINGLE:\n        {\n            float *ptr = (float *)data_out;\n            float *ptr_in = (float*)data_in;\n            GET_DATA_LINEAR;\n            break;\n        }\n#ifdef HAVE_MAT_INT64_T\n        case MAT_C_INT64:\n        {\n            mat_int64_t *ptr = (mat_int64_t *)data_out;\n            mat_int64_t *ptr_in = (mat_int64_t*)data_in;\n            GET_DATA_LINEAR;\n            break;\n        }\n#endif /* HAVE_MAT_INT64_T */\n#ifdef HAVE_MAT_UINT64_T\n        case MAT_C_UINT64:\n        {\n            mat_uint64_t *ptr = (mat_uint64_t *)data_out;\n            mat_uint64_t *ptr_in = (mat_uint64_t*)data_in;\n            GET_DATA_LINEAR;\n            break;\n        }\n#endif /* HAVE_MAT_UINT64_T */\n        case MAT_C_INT32:\n        {\n            mat_int32_t *ptr = (mat_int32_t *)data_out;\n            mat_int32_t *ptr_in = (mat_int32_t*)data_in;\n            GET_DATA_LINEAR;\n            break;\n        }\n        case MAT_C_UINT32:\n        {\n            mat_uint32_t *ptr = (mat_uint32_t *)data_out;\n            mat_uint32_t *ptr_in = (mat_uint32_t*)data_in;\n            GET_DATA_LINEAR;\n            break;\n        }\n        case MAT_C_INT16:\n        {\n            mat_int16_t *ptr = (mat_int16_t *)data_out;\n            mat_int16_t *ptr_in = (mat_int16_t*)data_in;\n            GET_DATA_LINEAR;\n            break;\n        }\n        case MAT_C_UINT16:\n        {\n            mat_uint16_t *ptr = (mat_uint16_t *)data_out;\n            mat_uint16_t *ptr_in = (mat_uint16_t*)data_in;\n            GET_DATA_LINEAR;\n            break;\n        }\n        case MAT_C_INT8:\n        {\n            mat_int8_t *ptr = (mat_int8_t *)data_out;\n            mat_int8_t *ptr_in = (mat_int8_t*)data_in;\n            GET_DATA_LINEAR;\n            break;\n        }\n        case MAT_C_UINT8:\n        {\n            mat_uint8_t *ptr = (mat_uint8_t *)data_out;\n            mat_uint8_t *ptr_in = (mat_uint8_t*)data_in;\n            GET_DATA_LINEAR;\n            break;\n        }\n        default:\n            err = 1;\n            break;\n    }\n\n    return err;\n}\n\n#undef GET_DATA_LINEAR\n#endif\n\n/** @if mat_devman\n * @brief Reads a slab of data from the mat variable @c matvar\n *\n * @ingroup mat_internal\n * @param mat MAT file pointer\n * @param matvar pointer to the mat variable\n * @param data pointer to store the read data in (must be of size\n *             edge[0]*...edge[rank-1]*Mat_SizeOfClass(matvar->class_type))\n * @param start index to start reading data in each dimension\n * @param stride write data every @c stride elements in each dimension\n * @param edge number of elements to read in each dimension\n * @retval 0 on success\n * @endif\n */\nint\nMat_VarReadData5(mat_t *mat,matvar_t *matvar,void *data,\n    int *start,int *stride,int *edge)\n{\n    int err = 0,real_bytes = 0;\n    mat_int32_t tag[2];\n#if defined(HAVE_ZLIB)\n    z_stream z;\n#endif\n    size_t bytesread = 0;\n\n    (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);\n    if ( matvar->compression == MAT_COMPRESSION_NONE ) {\n        bytesread += fread(tag,4,2,(FILE*)mat->fp);\n        if ( mat->byteswap ) {\n            (void)Mat_int32Swap(tag);\n            (void)Mat_int32Swap(tag+1);\n        }\n        matvar->data_type = TYPE_FROM_TAG(tag[0]);\n        if ( tag[0] & 0xffff0000 ) { /* Data is packed in the tag */\n            (void)fseek((FILE*)mat->fp,-4,SEEK_CUR);\n            real_bytes = 4+(tag[0] >> 16);\n        } else {\n            real_bytes = 8+tag[1];\n        }\n#if defined(HAVE_ZLIB)\n    } else if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {\n        if ( NULL != matvar->internal->data ) {\n            /* Data already read in ReadNextStructField or ReadNextCell */\n            if ( matvar->isComplex ) {\n                mat_complex_split_t *ci, *co;\n\n                co = (mat_complex_split_t*)data;\n                ci = (mat_complex_split_t*)matvar->internal->data;\n                err = GetDataSlab(ci->Re, co->Re, matvar->class_type,\n                    matvar->data_type, matvar->dims, start, stride, edge,\n                    matvar->rank, matvar->nbytes);\n                if ( err == 0 )\n                    err = GetDataSlab(ci->Im, co->Im, matvar->class_type,\n                        matvar->data_type, matvar->dims, start, stride, edge,\n                        matvar->rank, matvar->nbytes);\n                return err;\n            } else {\n                return GetDataSlab(matvar->internal->data, data, matvar->class_type,\n                    matvar->data_type, matvar->dims, start, stride, edge,\n                    matvar->rank, matvar->nbytes);\n            }\n        }\n\n        err = inflateCopy(&z,matvar->internal->z);\n        if ( err != Z_OK ) {\n            Mat_Critical(\"inflateCopy returned error %s\",zError(err));\n            return -1;\n        }\n        z.avail_in = 0;\n        InflateDataType(mat,&z,tag);\n        if ( mat->byteswap ) {\n            (void)Mat_int32Swap(tag);\n        }\n        matvar->data_type = TYPE_FROM_TAG(tag[0]);\n        if ( !(tag[0] & 0xffff0000) ) {/* Data is NOT packed in the tag */\n            /* We're cheating, but InflateDataType just inflates 4 bytes */\n            InflateDataType(mat,&z,tag+1);\n            if ( mat->byteswap ) {\n                (void)Mat_int32Swap(tag+1);\n            }\n            real_bytes = 8+tag[1];\n        } else {\n            real_bytes = 4+(tag[0] >> 16);\n        }\n#endif\n    }\n    if ( real_bytes % 8 )\n        real_bytes += (8-(real_bytes % 8));\n\n    if ( matvar->rank == 2 ) {\n        if ( (size_t)stride[0]*(edge[0]-1)+start[0]+1 > matvar->dims[0] )\n            err = 1;\n        else if ( (size_t)stride[1]*(edge[1]-1)+start[1]+1 > matvar->dims[1] )\n            err = 1;\n        else if ( matvar->compression == MAT_COMPRESSION_NONE ) {\n            if ( matvar->isComplex ) {\n                mat_complex_split_t *complex_data = (mat_complex_split_t*)data;\n\n                ReadDataSlab2(mat,complex_data->Re,matvar->class_type,\n                    matvar->data_type,matvar->dims,start,stride,edge);\n                (void)fseek((FILE*)mat->fp,matvar->internal->datapos+real_bytes,SEEK_SET);\n                bytesread += fread(tag,4,2,(FILE*)mat->fp);\n                if ( mat->byteswap ) {\n                    (void)Mat_int32Swap(tag);\n                    (void)Mat_int32Swap(tag+1);\n                }\n                matvar->data_type = TYPE_FROM_TAG(tag[0]);\n                if ( tag[0] & 0xffff0000 ) { /* Data is packed in the tag */\n                    (void)fseek((FILE*)mat->fp,-4,SEEK_CUR);\n                }\n                ReadDataSlab2(mat,complex_data->Im,matvar->class_type,\n                              matvar->data_type,matvar->dims,start,stride,edge);\n            } else {\n                ReadDataSlab2(mat,data,matvar->class_type,\n                    matvar->data_type,matvar->dims,start,stride,edge);\n            }\n        }\n#if defined(HAVE_ZLIB)\n        else if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {\n            if ( matvar->isComplex ) {\n                mat_complex_split_t *complex_data = (mat_complex_split_t*)data;\n\n                ReadCompressedDataSlab2(mat,&z,complex_data->Re,\n                    matvar->class_type,matvar->data_type,matvar->dims,\n                    start,stride,edge);\n\n                (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);\n\n                /* Reset zlib knowledge to before reading real tag */\n                inflateEnd(&z);\n                err = inflateCopy(&z,matvar->internal->z);\n                if ( err != Z_OK ) {\n                    Mat_Critical(\"inflateCopy returned error %s\",zError(err));\n                }\n                InflateSkip(mat,&z,real_bytes);\n                z.avail_in = 0;\n                InflateDataType(mat,&z,tag);\n                if ( mat->byteswap ) {\n                    (void)Mat_int32Swap(tag);\n                }\n                matvar->data_type = TYPE_FROM_TAG(tag[0]);\n                if ( !(tag[0] & 0xffff0000) ) {/*Data is NOT packed in the tag*/\n                    InflateSkip(mat,&z,4);\n                }\n                ReadCompressedDataSlab2(mat,&z,complex_data->Im,\n                    matvar->class_type,matvar->data_type,matvar->dims,\n                    start,stride,edge);\n            } else {\n                ReadCompressedDataSlab2(mat,&z,data,matvar->class_type,\n                    matvar->data_type,matvar->dims,start,stride,edge);\n            }\n            inflateEnd(&z);\n        }\n#endif\n    } else {\n        if ( matvar->compression == MAT_COMPRESSION_NONE ) {\n            if ( matvar->isComplex ) {\n                mat_complex_split_t *complex_data = (mat_complex_split_t*)data;\n\n                ReadDataSlabN(mat,complex_data->Re,matvar->class_type,\n                    matvar->data_type,matvar->rank,matvar->dims,\n                    start,stride,edge);\n\n                (void)fseek((FILE*)mat->fp,matvar->internal->datapos+real_bytes,SEEK_SET);\n                bytesread += fread(tag,4,2,(FILE*)mat->fp);\n                if ( mat->byteswap ) {\n                    (void)Mat_int32Swap(tag);\n                    (void)Mat_int32Swap(tag+1);\n                }\n                matvar->data_type = TYPE_FROM_TAG(tag[0]);\n                if ( tag[0] & 0xffff0000 ) { /* Data is packed in the tag */\n                    (void)fseek((FILE*)mat->fp,-4,SEEK_CUR);\n                }\n                ReadDataSlabN(mat,complex_data->Im,matvar->class_type,\n                    matvar->data_type,matvar->rank,matvar->dims,\n                    start,stride,edge);\n            } else {\n                ReadDataSlabN(mat,data,matvar->class_type,matvar->data_type,\n                    matvar->rank,matvar->dims,start,stride,edge);\n            }\n        }\n#if defined(HAVE_ZLIB)\n        else if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {\n            if ( matvar->isComplex ) {\n                mat_complex_split_t *complex_data = (mat_complex_split_t*)data;\n\n                ReadCompressedDataSlabN(mat,&z,complex_data->Re,\n                    matvar->class_type,matvar->data_type,matvar->rank,\n                    matvar->dims,start,stride,edge);\n\n                (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);\n                /* Reset zlib knowledge to before reading real tag */\n                inflateEnd(&z);\n                err = inflateCopy(&z,matvar->internal->z);\n                if ( err != Z_OK ) {\n                    Mat_Critical(\"inflateCopy returned error %s\",zError(err));\n                }\n                InflateSkip(mat,&z,real_bytes);\n                z.avail_in = 0;\n                InflateDataType(mat,&z,tag);\n                if ( mat->byteswap ) {\n                    (void)Mat_int32Swap(tag);\n                }\n                matvar->data_type = TYPE_FROM_TAG(tag[0]);\n                if ( !(tag[0] & 0xffff0000) ) {/*Data is NOT packed in the tag*/\n                    InflateSkip(mat,&z,4);\n                }\n                ReadCompressedDataSlabN(mat,&z,complex_data->Im,\n                    matvar->class_type,matvar->data_type,matvar->rank,\n                    matvar->dims,start,stride,edge);\n            } else {\n                ReadCompressedDataSlabN(mat,&z,data,matvar->class_type,\n                    matvar->data_type,matvar->rank,matvar->dims,\n                    start,stride,edge);\n            }\n            inflateEnd(&z);\n        }\n#endif\n    }\n    if ( err == 0 ) {\n        matvar->data_type = ClassType2DataType(matvar->class_type);\n        matvar->data_size = Mat_SizeOfClass(matvar->class_type);\n    }\n    return err;\n}\n\n/** @brief Reads a subset of a MAT variable using a 1-D indexing\n *\n * Reads data from a MAT variable using a linear (1-D) indexing mode. The\n * variable must have been read by Mat_VarReadInfo.\n * @ingroup MAT\n * @param mat MAT file to read data from\n * @param matvar MAT variable information\n * @param data pointer to store data in (must be pre-allocated)\n * @param start starting index\n * @param stride stride of data\n * @param edge number of elements to read\n * @retval 0 on success\n */\nint\nMat_VarReadDataLinear5(mat_t *mat,matvar_t *matvar,void *data,int start,\n                      int stride,int edge)\n{\n    int err = 0, real_bytes = 0;\n    mat_int32_t tag[2];\n#if defined(HAVE_ZLIB)\n    z_stream z;\n#endif\n    size_t bytesread = 0, nelems = 1;\n\n    if ( mat->version == MAT_FT_MAT4 )\n        return -1;\n    (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);\n    if ( matvar->compression == MAT_COMPRESSION_NONE ) {\n        bytesread += fread(tag,4,2,(FILE*)mat->fp);\n        if ( mat->byteswap ) {\n            (void)Mat_int32Swap(tag);\n            (void)Mat_int32Swap(tag+1);\n        }\n        matvar->data_type = (enum matio_types)(tag[0] & 0x000000ff);\n        if ( tag[0] & 0xffff0000 ) { /* Data is packed in the tag */\n            (void)fseek((FILE*)mat->fp,-4,SEEK_CUR);\n            real_bytes = 4+(tag[0] >> 16);\n        } else {\n            real_bytes = 8+tag[1];\n        }\n#if defined(HAVE_ZLIB)\n    } else if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {\n        if ( NULL != matvar->internal->data ) {\n            /* Data already read in ReadNextStructField or ReadNextCell */\n            if ( matvar->isComplex ) {\n                mat_complex_split_t *ci, *co;\n\n                co = (mat_complex_split_t*)data;\n                ci = (mat_complex_split_t*)matvar->internal->data;\n                err = GetDataLinear(ci->Re, co->Re, matvar->class_type,\n                    matvar->data_type, start, stride, edge);\n                if ( err == 0 )\n                    err = GetDataLinear(ci->Im, co->Im, matvar->class_type,\n                        matvar->data_type, start, stride, edge);\n                return err;\n            } else {\n                return GetDataLinear(matvar->internal->data, data, matvar->class_type,\n                    matvar->data_type, start, stride, edge);\n            }\n        }\n\n        matvar->internal->z->avail_in = 0;\n        err = inflateCopy(&z,matvar->internal->z);\n        if ( err != Z_OK ) {\n            Mat_Critical(\"inflateCopy returned error %s\",zError(err));\n            return -1;\n        }\n        InflateDataType(mat,&z,tag);\n        if ( mat->byteswap ) {\n            (void)Mat_int32Swap(tag);\n            (void)Mat_int32Swap(tag+1);\n        }\n        matvar->data_type = (enum matio_types)(tag[0] & 0x000000ff);\n        if ( !(tag[0] & 0xffff0000) ) {/* Data is NOT packed in the tag */\n            /* We're cheating, but InflateDataType just inflates 4 bytes */\n            InflateDataType(mat,&z,tag+1);\n            if ( mat->byteswap ) {\n                (void)Mat_int32Swap(tag+1);\n            }\n            real_bytes = 8+tag[1];\n        } else {\n            real_bytes = 4+(tag[0] >> 16);\n        }\n#endif\n    }\n    if ( real_bytes % 8 )\n        real_bytes += (8-(real_bytes % 8));\n\n    err = SafeMulDims(matvar, &nelems);\n    if ( err ) {\n        Mat_Critical(\"Integer multiplication overflow\");\n        return -1;\n    }\n\n    if ( (size_t)stride*(edge-1)+start+1 > nelems ) {\n        err = 1;\n    } else if ( matvar->compression == MAT_COMPRESSION_NONE ) {\n        if ( matvar->isComplex ) {\n            mat_complex_split_t *complex_data = (mat_complex_split_t*)data;\n\n            ReadDataSlab1(mat,complex_data->Re,matvar->class_type,\n                          matvar->data_type,start,stride,edge);\n            (void)fseek((FILE*)mat->fp,matvar->internal->datapos+real_bytes,SEEK_SET);\n            bytesread += fread(tag,4,2,(FILE*)mat->fp);\n            if ( mat->byteswap ) {\n                (void)Mat_int32Swap(tag);\n                (void)Mat_int32Swap(tag+1);\n            }\n            matvar->data_type = (enum matio_types)(tag[0] & 0x000000ff);\n            if ( tag[0] & 0xffff0000 ) { /* Data is packed in the tag */\n                (void)fseek((FILE*)mat->fp,-4,SEEK_CUR);\n            }\n            ReadDataSlab1(mat,complex_data->Im,matvar->class_type,\n                          matvar->data_type,start,stride,edge);\n        } else {\n            ReadDataSlab1(mat,data,matvar->class_type,\n                          matvar->data_type,start,stride,edge);\n        }\n#if defined(HAVE_ZLIB)\n    } else if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {\n        if ( matvar->isComplex ) {\n            mat_complex_split_t *complex_data = (mat_complex_split_t*)data;\n\n            ReadCompressedDataSlab1(mat,&z,complex_data->Re,\n                matvar->class_type,matvar->data_type,start,stride,edge);\n\n            (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);\n\n            /* Reset zlib knowledge to before reading real tag */\n            inflateEnd(&z);\n            err = inflateCopy(&z,matvar->internal->z);\n            if ( err != Z_OK ) {\n                Mat_Critical(\"inflateCopy returned error %s\",zError(err));\n            }\n            InflateSkip(mat,&z,real_bytes);\n            z.avail_in = 0;\n            InflateDataType(mat,&z,tag);\n            if ( mat->byteswap ) {\n                (void)Mat_int32Swap(tag);\n            }\n            matvar->data_type = (enum matio_types)(tag[0] & 0x000000ff);\n            if ( !(tag[0] & 0xffff0000) ) {/*Data is NOT packed in the tag*/\n                InflateSkip(mat,&z,4);\n            }\n            ReadCompressedDataSlab1(mat,&z,complex_data->Im,\n                matvar->class_type,matvar->data_type,start,stride,edge);\n        } else {\n            ReadCompressedDataSlab1(mat,&z,data,matvar->class_type,\n                matvar->data_type,start,stride,edge);\n        }\n        inflateEnd(&z);\n#endif\n    }\n\n    matvar->data_type = ClassType2DataType(matvar->class_type);\n    matvar->data_size = Mat_SizeOfClass(matvar->class_type);\n\n    return err;\n}\n\n/** @if mat_devman\n * @brief Writes a matlab variable to a version 5 matlab file\n *\n * @ingroup mat_internal\n * @param mat MAT file pointer\n * @param matvar pointer to the mat variable\n * @param compress option to compress the variable\n *                 (only works for numeric types)\n * @retval 0 on success\n * @endif\n */\nint\nMat_VarWrite5(mat_t *mat,matvar_t *matvar,int compress)\n{\n    mat_uint32_t array_flags;\n    int array_flags_type = MAT_T_UINT32, dims_array_type = MAT_T_INT32;\n    int array_flags_size = 8, pad4 = 0, matrix_type = MAT_T_MATRIX;\n    int nBytes, i, nzmax = 0;\n    long start = 0, end = 0;\n\n    if ( NULL == mat )\n        return -1;\n\n    /* FIXME: SEEK_END is not Guaranteed by the C standard */\n    (void)fseek((FILE*)mat->fp,0,SEEK_END);         /* Always write at end of file */\n\n    if ( NULL == matvar || NULL == matvar->name )\n        return -1;\n\n#if defined(HAVE_ZLIB)\n    if ( compress == MAT_COMPRESSION_NONE ) {\n#else\n    {\n#endif\n        fwrite(&matrix_type,4,1,(FILE*)mat->fp);\n        fwrite(&pad4,4,1,(FILE*)mat->fp);\n        start = ftell((FILE*)mat->fp);\n\n        /* Array Flags */\n        array_flags = matvar->class_type & CLASS_TYPE_MASK;\n        if ( matvar->isComplex )\n            array_flags |= MAT_F_COMPLEX;\n        if ( matvar->isGlobal )\n            array_flags |= MAT_F_GLOBAL;\n        if ( matvar->isLogical )\n            array_flags |= MAT_F_LOGICAL;\n        if ( matvar->class_type == MAT_C_SPARSE )\n            nzmax = ((mat_sparse_t *)matvar->data)->nzmax;\n\n        fwrite(&array_flags_type,4,1,(FILE*)mat->fp);\n        fwrite(&array_flags_size,4,1,(FILE*)mat->fp);\n        fwrite(&array_flags,4,1,(FILE*)mat->fp);\n        fwrite(&nzmax,4,1,(FILE*)mat->fp);\n        /* Rank and Dimension */\n        nBytes = matvar->rank * 4;\n        fwrite(&dims_array_type,4,1,(FILE*)mat->fp);\n        fwrite(&nBytes,4,1,(FILE*)mat->fp);\n        for ( i = 0; i < matvar->rank; i++ ) {\n            mat_int32_t dim;\n            dim = matvar->dims[i];\n            fwrite(&dim,4,1,(FILE*)mat->fp);\n        }\n        if ( matvar->rank % 2 != 0 )\n            fwrite(&pad4,4,1,(FILE*)mat->fp);\n        /* Name of variable */\n        if ( strlen(matvar->name) <= 4 ) {\n            mat_int32_t  array_name_type = MAT_T_INT8;\n            mat_int32_t array_name_len   = (mat_int32_t)strlen(matvar->name);\n            mat_int8_t  pad1 = 0;\n#if 0\n            fwrite(&array_name_type,2,1,(FILE*)mat->fp);\n            fwrite(&array_name_len,2,1,(FILE*)mat->fp);\n#else\n            array_name_type = (array_name_len << 16) | array_name_type;\n            fwrite(&array_name_type,4,1,(FILE*)mat->fp);\n#endif\n            fwrite(matvar->name,1,array_name_len,(FILE*)mat->fp);\n            for ( i = array_name_len; i < 4; i++ )\n                fwrite(&pad1,1,1,(FILE*)mat->fp);\n        } else {\n            mat_int32_t array_name_type = MAT_T_INT8;\n            mat_int32_t array_name_len  = (mat_int32_t)strlen(matvar->name);\n            mat_int8_t  pad1 = 0;\n\n            fwrite(&array_name_type,4,1,(FILE*)mat->fp);\n            fwrite(&array_name_len,4,1,(FILE*)mat->fp);\n            fwrite(matvar->name,1,array_name_len,(FILE*)mat->fp);\n            if ( array_name_len % 8 )\n                for ( i = array_name_len % 8; i < 8; i++ )\n                    fwrite(&pad1,1,1,(FILE*)mat->fp);\n        }\n\n        if ( NULL != matvar->internal ) {\n            matvar->internal->datapos = ftell((FILE*)mat->fp);\n            if ( matvar->internal->datapos == -1L ) {\n                Mat_Critical(\"Couldn't determine file position\");\n            }\n        } else {\n            /* Must be empty */\n            matvar->class_type = MAT_C_EMPTY;\n        }\n        WriteType(mat,matvar);\n#if defined(HAVE_ZLIB)\n    } else if ( compress == MAT_COMPRESSION_ZLIB ) {\n        mat_uint32_t comp_buf[512];\n        mat_uint32_t uncomp_buf[512] = {0,};\n        int buf_size = 512, err;\n        size_t byteswritten = 0, matrix_max_buf_size;\n        z_streamp z;\n\n        z = (z_streamp)calloc(1,sizeof(*z));\n        if ( z == NULL )\n            return -1;\n        err = deflateInit(z,Z_DEFAULT_COMPRESSION);\n        if ( err != Z_OK ) {\n            free(z);\n            Mat_Critical(\"deflateInit returned %s\",zError(err));\n            return -1;\n        }\n\n        matrix_type = MAT_T_COMPRESSED;\n        fwrite(&matrix_type,4,1,(FILE*)mat->fp);\n        fwrite(&pad4,4,1,(FILE*)mat->fp);\n        start = ftell((FILE*)mat->fp);\n\n        /* Array Flags */\n        array_flags = matvar->class_type & CLASS_TYPE_MASK;\n        if ( matvar->isComplex )\n            array_flags |= MAT_F_COMPLEX;\n        if ( matvar->isGlobal )\n            array_flags |= MAT_F_GLOBAL;\n        if ( matvar->isLogical )\n            array_flags |= MAT_F_LOGICAL;\n        if ( matvar->class_type == MAT_C_SPARSE )\n            nzmax = ((mat_sparse_t *)matvar->data)->nzmax;\n\n        uncomp_buf[0] = MAT_T_MATRIX;\n        err = GetMatrixMaxBufSize(matvar, &matrix_max_buf_size);\n        if (err || matrix_max_buf_size > UINT32_MAX)\n            return -1;\n        uncomp_buf[1] = matrix_max_buf_size;\n        z->next_in  = ZLIB_BYTE_PTR(uncomp_buf);\n        z->avail_in = 8;\n        do {\n            z->next_out  = ZLIB_BYTE_PTR(comp_buf);\n            z->avail_out = buf_size*sizeof(*comp_buf);\n            deflate(z,Z_NO_FLUSH);\n            byteswritten += fwrite(comp_buf,1,\n                buf_size*sizeof(*comp_buf)-z->avail_out,(FILE*)mat->fp);\n        } while ( z->avail_out == 0 );\n        uncomp_buf[0] = array_flags_type;\n        uncomp_buf[1] = array_flags_size;\n        uncomp_buf[2] = array_flags;\n        uncomp_buf[3] = nzmax;\n        /* Rank and Dimension */\n        nBytes = matvar->rank * 4;\n        uncomp_buf[4] = dims_array_type;\n        uncomp_buf[5] = nBytes;\n        for ( i = 0; i < matvar->rank; i++ ) {\n            mat_int32_t dim;\n            dim = matvar->dims[i];\n            uncomp_buf[6+i] = dim;\n        }\n        if ( matvar->rank % 2 != 0 ) {\n            uncomp_buf[6+i] = pad4;\n            i++;\n        }\n\n        z->next_in  = ZLIB_BYTE_PTR(uncomp_buf);\n        z->avail_in = (6+i)*sizeof(*uncomp_buf);\n        do {\n            z->next_out  = ZLIB_BYTE_PTR(comp_buf);\n            z->avail_out = buf_size*sizeof(*comp_buf);\n            deflate(z,Z_NO_FLUSH);\n            byteswritten += fwrite(comp_buf,1,\n                buf_size*sizeof(*comp_buf)-z->avail_out,(FILE*)mat->fp);\n        } while ( z->avail_out == 0 );\n        /* Name of variable */\n        if ( strlen(matvar->name) <= 4 ) {\n            mat_int16_t array_name_len = (mat_int16_t)strlen(matvar->name);\n            mat_int16_t array_name_type = MAT_T_INT8;\n\n            memset(uncomp_buf,0,8);\n            uncomp_buf[0] = (array_name_len << 16) | array_name_type;\n            memcpy(uncomp_buf+1,matvar->name,array_name_len);\n            if ( array_name_len % 4 )\n                array_name_len += 4-(array_name_len % 4);\n\n            z->next_in  = ZLIB_BYTE_PTR(uncomp_buf);\n            z->avail_in = 8;\n            do {\n                z->next_out  = ZLIB_BYTE_PTR(comp_buf);\n                z->avail_out = buf_size*sizeof(*comp_buf);\n                deflate(z,Z_NO_FLUSH);\n                byteswritten += fwrite(comp_buf,1,\n                    buf_size*sizeof(*comp_buf)-z->avail_out,(FILE*)mat->fp);\n            } while ( z->avail_out == 0 );\n        } else {\n            mat_int32_t array_name_len = (mat_int32_t)strlen(matvar->name);\n            mat_int32_t array_name_type = MAT_T_INT8;\n\n            memset(uncomp_buf,0,buf_size*sizeof(*uncomp_buf));\n            uncomp_buf[0] = array_name_type;\n            uncomp_buf[1] = array_name_len;\n            memcpy(uncomp_buf+2,matvar->name,array_name_len);\n            if ( array_name_len % 8 )\n                array_name_len += 8-(array_name_len % 8);\n            z->next_in  = ZLIB_BYTE_PTR(uncomp_buf);\n            z->avail_in = 8+array_name_len;\n            do {\n                z->next_out  = ZLIB_BYTE_PTR(comp_buf);\n                z->avail_out = buf_size*sizeof(*comp_buf);\n                deflate(z,Z_NO_FLUSH);\n                byteswritten += fwrite(comp_buf,1,\n                    buf_size*sizeof(*comp_buf)-z->avail_out,(FILE*)mat->fp);\n            } while ( z->avail_out == 0 );\n        }\n        if ( NULL != matvar->internal ) {\n            matvar->internal->datapos = ftell((FILE*)mat->fp);\n            if ( matvar->internal->datapos == -1L ) {\n                Mat_Critical(\"Couldn't determine file position\");\n            }\n        } else {\n            /* Must be empty */\n            matvar->class_type = MAT_C_EMPTY;\n        }\n        WriteCompressedType(mat,matvar,z);\n        z->next_in  = NULL;\n        z->avail_in = 0;\n        do {\n            z->next_out  = ZLIB_BYTE_PTR(comp_buf);\n            z->avail_out = buf_size*sizeof(*comp_buf);\n            err = deflate(z,Z_FINISH);\n            byteswritten += fwrite(comp_buf,1,\n                buf_size*sizeof(*comp_buf)-z->avail_out,(FILE*)mat->fp);\n        } while ( err != Z_STREAM_END && z->avail_out == 0 );\n#if 0\n        if ( byteswritten % 8 )\n            for ( i = 0; i < 8-(byteswritten % 8); i++ )\n                fwrite(&pad1,1,1,(FILE*)mat->fp);\n#endif\n        (void)deflateEnd(z);\n        free(z);\n#endif\n    }\n    end = ftell((FILE*)mat->fp);\n    if ( start != -1L && end != -1L ) {\n        nBytes = (int)(end-start);\n        (void)fseek((FILE*)mat->fp,(long)-(nBytes+4),SEEK_CUR);\n        fwrite(&nBytes,4,1,(FILE*)mat->fp);\n        (void)fseek((FILE*)mat->fp,end,SEEK_SET);\n    } else {\n        Mat_Critical(\"Couldn't determine file position\");\n    }\n\n    return 0;\n}\n\n/** @if mat_devman\n * @brief Reads the header information for the next MAT variable\n *\n * @ingroup mat_internal\n * @param mat MAT file pointer\n * @return pointer to the MAT variable or NULL\n * @endif\n */\nmatvar_t *\nMat_VarReadNextInfo5( mat_t *mat )\n{\n    int err;\n    mat_int32_t data_type, nBytes;\n    long fpos;\n    matvar_t *matvar = NULL;\n    mat_uint32_t array_flags;\n\n    if ( mat == NULL )\n        return NULL;\n\n    fpos = ftell((FILE*)mat->fp);\n    if ( fpos == -1L ) {\n        Mat_Critical(\"Couldn't determine file position\");\n        return NULL;\n    }\n    err = fread(&data_type,4,1,(FILE*)mat->fp);\n    if ( err == 0 )\n        return NULL;\n    err = fread(&nBytes,4,1,(FILE*)mat->fp);\n    if ( mat->byteswap ) {\n        (void)Mat_int32Swap(&data_type);\n        (void)Mat_int32Swap(&nBytes);\n    }\n    switch ( data_type ) {\n        case MAT_T_COMPRESSED:\n        {\n#if defined(HAVE_ZLIB)\n            mat_uint32_t uncomp_buf[16] = {0,};\n            int      nbytes;\n            long     bytesread = 0;\n\n            matvar = Mat_VarCalloc();\n            if ( NULL == matvar ) {\n                Mat_Critical(\"Couldn't allocate memory\");\n                break;\n            }\n\n            matvar->compression = MAT_COMPRESSION_ZLIB;\n            matvar->internal->z = (z_streamp)calloc(1,sizeof(z_stream));\n            err = inflateInit(matvar->internal->z);\n            if ( err != Z_OK ) {\n                Mat_VarFree(matvar);\n                matvar = NULL;\n                Mat_Critical(\"inflateInit returned %s\",zError(err));\n                break;\n            }\n\n            /* Read variable tag */\n            bytesread += InflateVarTag(mat,matvar,uncomp_buf);\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(uncomp_buf);\n                (void)Mat_uint32Swap(uncomp_buf+1);\n            }\n            nbytes = uncomp_buf[1];\n            if ( uncomp_buf[0] != MAT_T_MATRIX ) {\n                (void)fseek((FILE*)mat->fp,nBytes-bytesread,SEEK_CUR);\n                Mat_VarFree(matvar);\n                matvar = NULL;\n                Mat_Critical(\"Uncompressed type not MAT_T_MATRIX\");\n                break;\n            }\n            /* Array flags */\n            bytesread += InflateArrayFlags(mat,matvar,uncomp_buf);\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(uncomp_buf);\n                (void)Mat_uint32Swap(uncomp_buf+2);\n                (void)Mat_uint32Swap(uncomp_buf+3);\n            }\n            /* Array flags */\n            if ( uncomp_buf[0] == MAT_T_UINT32 ) {\n                array_flags = uncomp_buf[2];\n                matvar->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);\n                matvar->isComplex  = (array_flags & MAT_F_COMPLEX);\n                matvar->isGlobal   = (array_flags & MAT_F_GLOBAL);\n                matvar->isLogical  = (array_flags & MAT_F_LOGICAL);\n                if ( matvar->class_type == MAT_C_SPARSE ) {\n                    /* Need to find a more appropriate place to store nzmax */\n                    matvar->nbytes = uncomp_buf[3];\n                }\n            }\n            if ( matvar->class_type != MAT_C_OPAQUE ) {\n                mat_uint32_t* dims = NULL;\n                int do_clean = 0;\n                bytesread += InflateRankDims(mat,matvar,uncomp_buf,sizeof(uncomp_buf),&dims);\n                if ( NULL == dims )\n                    dims = uncomp_buf + 2;\n                else\n                    do_clean = 1;\n                if ( mat->byteswap ) {\n                    (void)Mat_uint32Swap(uncomp_buf);\n                    (void)Mat_uint32Swap(uncomp_buf+1);\n                }\n                /* Rank and dimension */\n                if ( uncomp_buf[0] == MAT_T_INT32 ) {\n                    int j;\n                    nbytes = uncomp_buf[1];\n                    matvar->rank = nbytes / 4;\n                    matvar->dims = (size_t*)malloc(matvar->rank*sizeof(*matvar->dims));\n                    if ( mat->byteswap ) {\n                        for ( j = 0; j < matvar->rank; j++ )\n                            matvar->dims[j] = Mat_uint32Swap(dims + j);\n                    } else {\n                        for ( j = 0; j < matvar->rank; j++ )\n                            matvar->dims[j] = dims[j];\n                    }\n                }\n                if ( do_clean )\n                    free(dims);\n                /* Variable name tag */\n                bytesread += InflateVarTag(mat,matvar,uncomp_buf);\n                if ( mat->byteswap )\n                    (void)Mat_uint32Swap(uncomp_buf);\n                /* Name of variable */\n                if ( uncomp_buf[0] == MAT_T_INT8 ) {    /* Name not in tag */\n                    mat_uint32_t len, len_pad;\n                    if ( mat->byteswap )\n                        len = Mat_uint32Swap(uncomp_buf+1);\n                    else\n                        len = uncomp_buf[1];\n\n                    if ( len % 8 == 0 )\n                        len_pad = len;\n                    else\n                        len_pad = len + 8 - (len % 8);\n                    matvar->name = (char*)malloc(len_pad + 1);\n                    if ( NULL != matvar->name ) {\n                        /* Variable name */\n                        bytesread += InflateVarName(mat,matvar,matvar->name,len_pad);\n                        matvar->name[len] = '\\0';\n                    }\n                } else {\n                    mat_uint32_t len = (uncomp_buf[0] & 0xffff0000) >> 16;\n                    if ( ((uncomp_buf[0] & 0x0000ffff) == MAT_T_INT8) && len > 0 && len <= 4 ) {\n                        /* Name packed in tag */\n                        matvar->name = (char*)malloc(len+1);\n                        if ( NULL != matvar->name ) {\n                            memcpy(matvar->name,uncomp_buf+1,len);\n                            matvar->name[len] = '\\0';\n                        }\n                    }\n                }\n                if ( matvar->class_type == MAT_C_STRUCT )\n                    (void)ReadNextStructField(mat,matvar);\n                else if ( matvar->class_type == MAT_C_CELL )\n                    (void)ReadNextCell(mat,matvar);\n                (void)fseek((FILE*)mat->fp,-(int)matvar->internal->z->avail_in,SEEK_CUR);\n                matvar->internal->datapos = ftell((FILE*)mat->fp);\n                if ( matvar->internal->datapos == -1L ) {\n                    Mat_Critical(\"Couldn't determine file position\");\n                }\n            }\n            (void)fseek((FILE*)mat->fp,nBytes+8+fpos,SEEK_SET);\n            break;\n#else\n            Mat_Critical(\"Compressed variable found in \\\"%s\\\", but matio was \"\n                         \"built without zlib support\",mat->filename);\n            (void)fseek((FILE*)mat->fp,nBytes+8+fpos,SEEK_SET);\n            return NULL;\n#endif\n        }\n        case MAT_T_MATRIX:\n        {\n            mat_uint32_t buf[6];\n            size_t readresult;\n\n            /* Read array flags and the dimensions tag */\n            readresult = fread(buf, 4, 6, (FILE*)mat->fp);\n            if ( 6 != readresult ) {\n                (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);\n                break;\n            }\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(buf);\n                (void)Mat_uint32Swap(buf+1);\n                (void)Mat_uint32Swap(buf+2);\n                (void)Mat_uint32Swap(buf+3);\n                (void)Mat_uint32Swap(buf+4);\n                (void)Mat_uint32Swap(buf+5);\n            }\n\n            matvar = Mat_VarCalloc();\n            if ( NULL == matvar ) {\n                Mat_Critical(\"Couldn't allocate memory\");\n                break;\n            }\n\n            /* Array flags */\n            if ( buf[0] == MAT_T_UINT32 ) {\n               array_flags = buf[2];\n               matvar->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);\n               matvar->isComplex  = (array_flags & MAT_F_COMPLEX);\n               matvar->isGlobal   = (array_flags & MAT_F_GLOBAL);\n               matvar->isLogical  = (array_flags & MAT_F_LOGICAL);\n               if ( matvar->class_type == MAT_C_SPARSE ) {\n                   /* Need to find a more appropriate place to store nzmax */\n                   matvar->nbytes = buf[3];\n               }\n            }\n            readresult = ReadRankDims(mat, matvar, (enum matio_types)buf[4], buf[5]);\n            if ( 0 == readresult && 0 < matvar->rank ) {\n                Mat_VarFree(matvar);\n                matvar = NULL;\n                (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);\n                break;\n            }\n            /* Variable name tag */\n            readresult = fread(buf, 4, 2, (FILE*)mat->fp);\n            if ( 2 != readresult ) {\n                Mat_VarFree(matvar);\n                matvar = NULL;\n                (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);\n                break;\n            }\n            if ( mat->byteswap )\n                (void)Mat_uint32Swap(buf);\n            /* Name of variable */\n            if ( buf[0] == MAT_T_INT8 ) {    /* Name not in tag */\n                mat_uint32_t len, len_pad;\n                if ( mat->byteswap )\n                    len = Mat_uint32Swap(buf+1);\n                else\n                    len = buf[1];\n                if ( len % 8 == 0 )\n                    len_pad = len;\n                else\n                    len_pad = len + 8 - (len % 8);\n                matvar->name = (char*)malloc(len_pad + 1);\n                if ( NULL != matvar->name ) {\n                    readresult = fread(matvar->name, 1, len_pad, (FILE*)mat->fp);\n                    if ( readresult == len_pad ) {\n                        matvar->name[len] = '\\0';\n                    } else {\n                        Mat_VarFree(matvar);\n                        matvar = NULL;\n                        (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);\n                        break;\n                    }\n                }\n            } else {\n                mat_uint32_t len = (buf[0] & 0xffff0000) >> 16;\n                if ( ((buf[0] & 0x0000ffff) == MAT_T_INT8) && len > 0 && len <= 4 ) {\n                    /* Name packed in tag */\n                    matvar->name = (char*)malloc(len+1);\n                    if ( NULL != matvar->name ) {\n                        memcpy(matvar->name, buf+1, len);\n                        matvar->name[len] = '\\0';\n                    }\n                }\n            }\n            if ( matvar->class_type == MAT_C_STRUCT )\n                (void)ReadNextStructField(mat,matvar);\n            else if ( matvar->class_type == MAT_C_CELL )\n                (void)ReadNextCell(mat,matvar);\n            else if ( matvar->class_type == MAT_C_FUNCTION )\n                (void)ReadNextFunctionHandle(mat,matvar);\n            matvar->internal->datapos = ftell((FILE*)mat->fp);\n            if ( matvar->internal->datapos == -1L ) {\n                Mat_Critical(\"Couldn't determine file position\");\n            }\n            (void)fseek((FILE*)mat->fp,nBytes+8+fpos,SEEK_SET);\n            break;\n        }\n        default:\n            Mat_Critical(\"%d is not valid (MAT_T_MATRIX or MAT_T_COMPRESSED)\",\n                         data_type);\n            return NULL;\n    }\n\n    return matvar;\n}\n"], "fixing_code": ["/** @file mat5.c\n * Matlab MAT version 5 file functions\n * @ingroup MAT\n */\n/*\n * Copyright (c) 2005-2019, Christopher C. Hulbert\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* FIXME: Implement Unicode support */\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#if defined(_MSC_VER) || defined(__MINGW32__)\n#   define SIZE_T_FMTSTR \"Iu\"\n#   define strdup _strdup\n#else\n#   define SIZE_T_FMTSTR \"zu\"\n#endif\n#include \"matio_private.h\"\n#include \"mat5.h\"\n\n/** Get type from tag */\n#define TYPE_FROM_TAG(a)          ( ((a) & 0x000000ff) <= MAT_T_FUNCTION ) ? (enum matio_types)((a) & 0x000000ff) : MAT_T_UNKNOWN\n/** Get class from array flag */\n#define CLASS_FROM_ARRAY_FLAGS(a) ( ((a) & 0x000000ff) <= MAT_C_OPAQUE ) ? ((enum matio_classes)((a) & 0x000000ff)) : MAT_C_EMPTY\n/** Class type mask */\n#define CLASS_TYPE_MASK           0x000000ff\n\nstatic mat_complex_split_t null_complex_data = {NULL,NULL};\n\n/*===========================================================================\n *  Private functions\n *===========================================================================\n */\nstatic int GetTypeBufSize(matvar_t *matvar, size_t *size);\nstatic int GetStructFieldBufSize(matvar_t *matvar, size_t *size);\nstatic int GetCellArrayFieldBufSize(matvar_t *matvar, size_t *size);\nstatic void SetFieldNames(matvar_t *matvar, char *buf, size_t nfields,\n                  mat_uint32_t fieldname_length);\nstatic size_t ReadSparse(mat_t *mat, matvar_t *matvar, int *n, mat_int32_t **v);\n#if defined(HAVE_ZLIB)\nstatic int GetMatrixMaxBufSize(matvar_t *matvar, size_t *size);\n#endif\nstatic int GetEmptyMatrixMaxBufSize(const char *name, int rank, size_t *size);\nstatic size_t WriteCharData(mat_t *mat, void *data, int N,enum matio_types data_type);\nstatic size_t ReadNextCell( mat_t *mat, matvar_t *matvar );\nstatic size_t ReadNextStructField( mat_t *mat, matvar_t *matvar );\nstatic size_t ReadNextFunctionHandle(mat_t *mat, matvar_t *matvar);\nstatic size_t ReadRankDims(mat_t *mat, matvar_t *matvar, enum matio_types data_type,\n                  mat_uint32_t nbytes);\nstatic int    WriteType(mat_t *mat,matvar_t *matvar);\nstatic int    WriteCellArrayField(mat_t *mat,matvar_t *matvar );\nstatic int    WriteStructField(mat_t *mat,matvar_t *matvar);\nstatic int    WriteData(mat_t *mat,void *data,int N,enum matio_types data_type);\nstatic size_t Mat_WriteEmptyVariable5(mat_t *mat,const char *name,int rank,\n                  size_t *dims);\nstatic void   Mat_VarReadNumeric5(mat_t *mat,matvar_t *matvar,void *data,size_t N);\n#if defined(HAVE_ZLIB)\nstatic size_t WriteCompressedCharData(mat_t *mat,z_streamp z,void *data,int N,\n                  enum matio_types data_type);\nstatic size_t WriteCompressedData(mat_t *mat,z_streamp z,void *data,int N,\n                  enum matio_types data_type);\nstatic size_t WriteCompressedTypeArrayFlags(mat_t *mat,matvar_t *matvar,\n                  z_streamp z);\nstatic size_t WriteCompressedType(mat_t *mat,matvar_t *matvar,z_streamp z);\nstatic size_t WriteCompressedCellArrayField(mat_t *mat,matvar_t *matvar,\n                  z_streamp z);\nstatic size_t WriteCompressedStructField(mat_t *mat,matvar_t *matvar,\n                  z_streamp z);\nstatic size_t Mat_WriteCompressedEmptyVariable5(mat_t *mat,const char *name,\n                  int rank,size_t *dims,z_streamp z);\n#endif\n\n/** @brief determines the number of bytes for a given class type\n *\n * @ingroup mat_internal\n * @param matvar MAT variable\n * @param size the number of bytes needed to store the MAT variable\n * @return 0 on success\n */\nstatic int\nGetTypeBufSize(matvar_t *matvar, size_t *size)\n{\n    int err;\n    size_t nBytes, data_bytes;\n    size_t tag_size = 8;\n    size_t nelems = 1;\n    size_t rank_size;\n\n    *size = 0;\n\n    err = SafeMulDims(matvar, &nelems);\n    if ( err )\n        return 1;\n\n    /* Add rank and dimensions, padded to an 8 byte block */\n    err = SafeMul(&rank_size, matvar->rank, 4);\n    if ( err )\n        return 1;\n\n    if ( matvar->rank % 2 )\n        nBytes = tag_size + 4;\n    else\n        nBytes = tag_size;\n\n    err = SafeAdd(&nBytes, nBytes, rank_size);\n    if ( err )\n        return 1;\n\n    switch ( matvar->class_type ) {\n        case MAT_C_STRUCT:\n        {\n            matvar_t **fields = (matvar_t**)matvar->data;\n            size_t nfields = matvar->internal->num_fields;\n            size_t maxlen = 0, i, field_buf_size;\n\n            for ( i = 0; i < nfields; i++ ) {\n                char *fieldname = matvar->internal->fieldnames[i];\n                if ( NULL != fieldname && strlen(fieldname) > maxlen )\n                    maxlen = strlen(fieldname);\n            }\n            maxlen++;\n            while ( nfields*maxlen % 8 != 0 )\n                maxlen++;\n\n            err = SafeMul(&field_buf_size, maxlen, nfields);\n            err |= SafeAdd(&nBytes, nBytes, tag_size + tag_size);\n            err |= SafeAdd(&nBytes, nBytes, field_buf_size);\n            if ( err )\n                return 1;\n\n            /* FIXME: Add bytes for the fieldnames */\n            if ( NULL != fields && nfields > 0 ) {\n                size_t nelems_x_nfields = 1;\n                err = SafeMul(&nelems_x_nfields, nelems, nfields);\n                if ( err )\n                    return 1;\n\n                for ( i = 0; i < nelems_x_nfields; i++ ) {\n                    err = GetStructFieldBufSize(fields[i], &field_buf_size);\n                    err |= SafeAdd(&nBytes, nBytes, tag_size);\n                    err |= SafeAdd(&nBytes, nBytes, field_buf_size);\n                    if ( err )\n                        return 1;\n                }\n            }\n            break;\n        }\n        case MAT_C_CELL:\n        {\n            matvar_t **cells = (matvar_t**)matvar->data;\n\n            if ( matvar->nbytes == 0 || matvar->data_size == 0 )\n                break;\n\n            nelems = matvar->nbytes / matvar->data_size;\n            if ( NULL != cells && nelems > 0 ) {\n                size_t i, field_buf_size;\n                for ( i = 0; i < nelems; i++ ) {\n                    err = GetCellArrayFieldBufSize(cells[i], &field_buf_size);\n                    err |= SafeAdd(&nBytes, nBytes, tag_size);\n                    err |= SafeAdd(&nBytes, nBytes, field_buf_size);\n                    if ( err )\n                        return 1;\n                }\n            }\n            break;\n        }\n        case MAT_C_SPARSE:\n        {\n            mat_sparse_t *sparse = (mat_sparse_t*)matvar->data;\n\n            err = SafeMul(&data_bytes, sparse->nir, sizeof(mat_int32_t));\n            if ( data_bytes % 8 )\n                err |= SafeAdd(&data_bytes, data_bytes, 8 - data_bytes % 8);\n            err |= SafeAdd(&nBytes, nBytes, tag_size);\n            err |= SafeAdd(&nBytes, nBytes, data_bytes);\n\n            err |= SafeMul(&data_bytes, sparse->njc, sizeof(mat_int32_t));\n            if ( data_bytes % 8 )\n                err |= SafeAdd(&data_bytes, data_bytes, 8 - data_bytes % 8);\n            err |= SafeAdd(&nBytes, nBytes, tag_size);\n            err |= SafeAdd(&nBytes, nBytes, data_bytes);\n\n            err |= SafeMul(&data_bytes, sparse->ndata, Mat_SizeOf(matvar->data_type));\n            if ( data_bytes % 8 )\n                err |= SafeAdd(&data_bytes, data_bytes, 8 - data_bytes % 8);\n            err |= SafeAdd(&nBytes, nBytes, tag_size);\n            err |= SafeAdd(&nBytes, nBytes, data_bytes);\n\n            if ( matvar->isComplex ) {\n                err |= SafeAdd(&nBytes, nBytes, tag_size);\n                err |= SafeAdd(&nBytes, nBytes, data_bytes);\n            }\n\n            if ( err )\n                return 1;\n\n            break;\n        }\n        case MAT_C_CHAR:\n            if ( MAT_T_UINT8 == matvar->data_type ||\n                 MAT_T_INT8 == matvar->data_type )\n                err = SafeMul(&data_bytes, nelems, Mat_SizeOf(MAT_T_UINT16));\n            else\n                err = SafeMul(&data_bytes, nelems, Mat_SizeOf(matvar->data_type));\n            if ( data_bytes % 8 )\n                err |= SafeAdd(&data_bytes, data_bytes, 8 - data_bytes % 8);\n\n            err |= SafeAdd(&nBytes, nBytes, tag_size);\n            err |= SafeAdd(&nBytes, nBytes, data_bytes);\n\n            if ( matvar->isComplex ) {\n                err |= SafeAdd(&nBytes, nBytes, tag_size);\n                err |= SafeAdd(&nBytes, nBytes, data_bytes);\n            }\n\n            if ( err )\n                return 1;\n\n            break;\n        default:\n            err = SafeMul(&data_bytes, nelems, Mat_SizeOf(matvar->data_type));\n            if ( data_bytes % 8 )\n                err |= SafeAdd(&data_bytes, data_bytes, 8 - data_bytes % 8);\n\n            err |= SafeAdd(&nBytes, nBytes, tag_size);\n            err |= SafeAdd(&nBytes, nBytes, data_bytes);\n\n            if ( matvar->isComplex ) {\n                err |= SafeAdd(&nBytes, nBytes, tag_size);\n                err |= SafeAdd(&nBytes, nBytes, data_bytes);\n            }\n\n            if ( err )\n                return 1;\n    } /* switch ( matvar->class_type ) */\n\n    *size = nBytes;\n    return 0;\n}\n\n/** @brief determines the number of bytes needed to store the given struct field\n *\n * @ingroup mat_internal\n * @param matvar field of a structure\n * @param size the number of bytes needed to store the struct field\n * @return 0 on success\n */\nstatic int\nGetStructFieldBufSize(matvar_t *matvar, size_t *size)\n{\n    int err;\n    size_t nBytes = 0, type_buf_size;\n    size_t tag_size = 8, array_flags_size = 8;\n\n    *size = 0;\n\n    if ( matvar == NULL )\n        return GetEmptyMatrixMaxBufSize(NULL, 2, size);\n\n    /* Add the Array Flags tag and space to the number of bytes */\n    nBytes += tag_size + array_flags_size;\n\n    /* In a struct field, the name is just a tag with 0 bytes */\n    nBytes += tag_size;\n\n    err = GetTypeBufSize(matvar, &type_buf_size);\n    err |= SafeAdd(&nBytes, nBytes, type_buf_size);\n    if ( err )\n        return 1;\n\n    *size = nBytes;\n    return 0;\n}\n\n/** @brief determines the number of bytes needed to store the cell array element\n *\n * @ingroup mat_internal\n * @param matvar MAT variable\n * @param size the number of bytes needed to store the variable\n * @return 0 on success\n */\nstatic int\nGetCellArrayFieldBufSize(matvar_t *matvar, size_t *size)\n{\n    int err;\n    size_t nBytes = 0, type_buf_size;\n    size_t tag_size = 8, array_flags_size = 8;\n\n    *size = 0;\n\n    if ( matvar == NULL )\n        return 1;\n\n    /* Add the Array Flags tag and space to the number of bytes */\n    nBytes += tag_size + array_flags_size;\n\n    /* In an element of a cell array, the name is just a tag with 0 bytes */\n    nBytes += tag_size;\n\n    err = GetTypeBufSize(matvar, &type_buf_size);\n    err |= SafeAdd(&nBytes, nBytes, type_buf_size);\n    if ( err )\n        return 1;\n\n    *size = nBytes;\n    return 0;\n}\n\n/** @brief determines the number of bytes needed to store the given variable\n *\n * @ingroup mat_internal\n * @param matvar MAT variable\n * @param rank rank of the variable\n * @param size the number of bytes needed to store the variable\n * @return 0 on success\n */\nstatic int\nGetEmptyMatrixMaxBufSize(const char *name, int rank, size_t *size)\n{\n    int err = 0;\n    size_t nBytes = 0, len, rank_size;\n    size_t tag_size = 8, array_flags_size = 8;\n\n    /* Add the Array Flags tag and space to the number of bytes */\n    nBytes += tag_size + array_flags_size;\n\n    /* Get size of variable name, pad it to an 8 byte block, and add it to nBytes */\n    if ( NULL != name )\n        len = strlen(name);\n    else\n        len = 4;\n\n    if ( len <= 4 ) {\n        nBytes += tag_size;\n    } else {\n        nBytes += tag_size;\n        if ( len % 8 )\n            err |= SafeAdd(&len, len, 8 - len % 8);\n\n        err |= SafeAdd(&nBytes, nBytes, len);\n    }\n\n    /* Add rank and dimensions, padded to an 8 byte block */\n    err |= SafeMul(&rank_size, rank, 4);\n    if ( rank % 2 )\n        err |= SafeAdd(&nBytes, nBytes, tag_size + 4);\n    else\n        err |= SafeAdd(&nBytes, nBytes, tag_size);\n\n    err |= SafeAdd(&nBytes, nBytes, rank_size);\n    /* Data tag */\n    err |= SafeAdd(&nBytes, nBytes, tag_size);\n\n    if ( err )\n        return 1;\n\n    *size = nBytes;\n    return 0;\n}\n\nstatic void\nSetFieldNames(matvar_t *matvar, char *buf, size_t nfields, mat_uint32_t fieldname_length)\n{\n    size_t i;\n    matvar->internal->num_fields = nfields;\n    matvar->internal->fieldnames =\n        (char**)calloc(nfields,sizeof(*matvar->internal->fieldnames));\n    if ( NULL != matvar->internal->fieldnames ) {\n        for ( i = 0; i < nfields; i++ ) {\n            matvar->internal->fieldnames[i] = (char*)malloc(fieldname_length);\n            if ( NULL != matvar->internal->fieldnames[i] ) {\n                memcpy(matvar->internal->fieldnames[i], buf+i*fieldname_length, fieldname_length);\n                matvar->internal->fieldnames[i][fieldname_length-1] = '\\0';\n            }\n        }\n    }\n}\n\nstatic size_t\nReadSparse(mat_t *mat, matvar_t *matvar, int *n, mat_int32_t **v)\n{\n    int data_in_tag = 0;\n    enum matio_types packed_type;\n    mat_uint32_t tag[2];\n    size_t bytesread = 0;\n    mat_int32_t N = 0;\n\n    if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {\n#if defined(HAVE_ZLIB)\n        matvar->internal->z->avail_in = 0;\n        InflateDataType(mat,matvar->internal->z,tag);\n        if ( mat->byteswap )\n            (void)Mat_uint32Swap(tag);\n        packed_type = TYPE_FROM_TAG(tag[0]);\n        if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */\n            data_in_tag = 1;\n            N = (tag[0] & 0xffff0000) >> 16;\n        } else {\n            data_in_tag = 0;\n            (void)ReadCompressedInt32Data(mat,matvar->internal->z,\n                        (mat_int32_t*)&N,MAT_T_INT32,1);\n        }\n#endif\n    } else {\n        bytesread += fread(tag,4,1,(FILE*)mat->fp);\n        if ( mat->byteswap )\n            (void)Mat_uint32Swap(tag);\n        packed_type = TYPE_FROM_TAG(tag[0]);\n        if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */\n            data_in_tag = 1;\n            N = (tag[0] & 0xffff0000) >> 16;\n        } else {\n            data_in_tag = 0;\n            bytesread += fread(&N,4,1,(FILE*)mat->fp);\n            if ( mat->byteswap )\n                (void)Mat_int32Swap(&N);\n        }\n    }\n    *n = N / 4;\n    *v = (mat_int32_t*)malloc(*n*sizeof(mat_int32_t));\n    if ( NULL != *v ) {\n        int nBytes;\n        if ( matvar->compression == MAT_COMPRESSION_NONE ) {\n            nBytes = ReadInt32Data(mat,*v,packed_type,*n);\n            /*\n                * If the data was in the tag we started on a 4-byte\n                * boundary so add 4 to make it an 8-byte\n                */\n            if ( data_in_tag )\n                nBytes+=4;\n            if ( (nBytes % 8) != 0 )\n                (void)fseek((FILE*)mat->fp,8-(nBytes % 8),SEEK_CUR);\n#if defined(HAVE_ZLIB)\n        } else if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {\n            nBytes = ReadCompressedInt32Data(mat,matvar->internal->z,\n                            *v,packed_type,*n);\n            /*\n                * If the data was in the tag we started on a 4-byte\n                * boundary so add 4 to make it an 8-byte\n                */\n            if ( data_in_tag )\n                nBytes+=4;\n            if ( (nBytes % 8) != 0 )\n                InflateSkip(mat,matvar->internal->z,8-(nBytes % 8));\n#endif\n        }\n    } else {\n        Mat_Critical(\"Couldn't allocate memory\");\n    }\n\n    return bytesread;\n}\n\n#if defined(HAVE_ZLIB)\n/** @brief determines the number of bytes needed to store the given variable\n *\n * @ingroup mat_internal\n * @param matvar MAT variable\n * @param size the number of bytes needed to store the variable\n * @return 0 on success\n */\nstatic int\nGetMatrixMaxBufSize(matvar_t *matvar, size_t *size)\n{\n    int err = 0;\n    size_t nBytes = 0, len, type_buf_size;\n    size_t tag_size = 8, array_flags_size = 8;\n\n    if ( matvar == NULL )\n        return 1;\n\n    /* Add the Array Flags tag and space to the number of bytes */\n    nBytes += tag_size + array_flags_size;\n\n    /* Get size of variable name, pad it to an 8 byte block, and add it to nBytes */\n    if ( NULL != matvar->name )\n        len = strlen(matvar->name);\n    else\n        len = 4;\n\n    if ( len <= 4 ) {\n        nBytes += tag_size;\n    } else {\n        nBytes += tag_size;\n        if ( len % 8 )\n            err |= SafeAdd(&len, len, 8 - len % 8);\n\n        err |= SafeAdd(&nBytes, nBytes, len);\n    }\n\n    err |= GetTypeBufSize(matvar, &type_buf_size);\n    err |= SafeAdd(&nBytes, nBytes, type_buf_size);\n\n    if ( err )\n        return 1;\n\n    *size = nBytes;\n    return 0;\n}\n#endif\n\n/** @if mat_devman\n * @brief Creates a new Matlab MAT version 5 file\n *\n * Tries to create a new Matlab MAT file with the given name and optional\n * header string.  If no header string is given, the default string\n * is used containing the software, version, and date in it.  If a header\n * string is given, at most the first 116 characters is written to the file.\n * The given header string need not be the full 116 characters, but MUST be\n * NULL terminated.\n * @ingroup MAT\n * @param matname Name of MAT file to create\n * @param hdr_str Optional header string, NULL to use default\n * @return A pointer to the MAT file or NULL if it failed.  This is not a\n * simple FILE * and should not be used as one.\n * @endif\n */\nmat_t *\nMat_Create5(const char *matname,const char *hdr_str)\n{\n    FILE *fp;\n    mat_int16_t endian = 0, version;\n    mat_t *mat = NULL;\n    size_t err;\n    time_t t;\n\n    fp = fopen(matname,\"w+b\");\n    if ( !fp )\n        return NULL;\n\n    mat = (mat_t*)malloc(sizeof(*mat));\n    if ( mat == NULL ) {\n        fclose(fp);\n        return NULL;\n    }\n\n    mat->fp            = NULL;\n    mat->header        = NULL;\n    mat->subsys_offset = NULL;\n    mat->filename      = NULL;\n    mat->version       = 0;\n    mat->byteswap      = 0;\n    mat->mode          = 0;\n    mat->bof           = 128;\n    mat->next_index    = 0;\n    mat->num_datasets  = 0;\n#if defined(MAT73) && MAT73\n    mat->refs_id       = -1;\n#endif\n    mat->dir           = NULL;\n\n    t = time(NULL);\n    mat->fp       = fp;\n    mat->filename = strdup_printf(\"%s\",matname);\n    mat->mode     = MAT_ACC_RDWR;\n    mat->byteswap = 0;\n    mat->header   = (char*)malloc(128*sizeof(char));\n    mat->subsys_offset = (char*)malloc(8*sizeof(char));\n    memset(mat->header,' ',128);\n    if ( hdr_str == NULL ) {\n        err = mat_snprintf(mat->header,116,\"MATLAB 5.0 MAT-file, Platform: %s, \"\n                \"Created by: libmatio v%d.%d.%d on %s\", MATIO_PLATFORM,\n                MATIO_MAJOR_VERSION, MATIO_MINOR_VERSION, MATIO_RELEASE_LEVEL,\n                ctime(&t));\n    } else {\n        err = mat_snprintf(mat->header,116,\"%s\",hdr_str);\n    }\n    if ( err >= 116 )\n        mat->header[115] = '\\0'; /* Just to make sure it's NULL terminated */\n    memset(mat->subsys_offset,' ',8);\n    mat->version = (int)0x0100;\n    endian = 0x4d49;\n\n    version = 0x0100;\n\n    fwrite(mat->header,1,116,(FILE*)mat->fp);\n    fwrite(mat->subsys_offset,1,8,(FILE*)mat->fp);\n    fwrite(&version,2,1,(FILE*)mat->fp);\n    fwrite(&endian,2,1,(FILE*)mat->fp);\n\n    return mat;\n}\n\n/** @if mat_devman\n * @brief Writes @c data as character data\n *\n * This function uses the knowledge that the data is part of a character class\n * to avoid some pitfalls with Matlab listed below.\n *   @li Matlab character data cannot be unsigned 8-bit integers, it needs at\n *       least unsigned 16-bit integers\n *\n * @ingroup mat_internal\n * @param mat MAT file pointer\n * @param data character data to write\n * @param N Number of elements to write\n * @param data_type character data type (enum matio_types)\n * @return number of bytes written\n * @endif\n */\nstatic size_t\nWriteCharData(mat_t *mat, void *data, int N,enum matio_types data_type)\n{\n    int nBytes = 0, i;\n    size_t byteswritten = 0;\n    mat_int8_t pad1 = 0;\n\n    switch ( data_type ) {\n        case MAT_T_UINT16:\n        {\n            nBytes = N*2;\n            fwrite(&data_type,4,1,(FILE*)mat->fp);\n            fwrite(&nBytes,4,1,(FILE*)mat->fp);\n            if ( NULL != data && N > 0 )\n                fwrite(data,2,N,(FILE*)mat->fp);\n            if ( nBytes % 8 )\n                for ( i = nBytes % 8; i < 8; i++ )\n                    fwrite(&pad1,1,1,(FILE*)mat->fp);\n            break;\n        }\n        case MAT_T_INT8:\n        case MAT_T_UINT8:\n        {\n            mat_uint8_t *ptr;\n            mat_uint16_t c;\n\n            /* Matlab can't read MAT_C_CHAR as uint8, needs uint16 */\n            nBytes = N*2;\n            data_type = MAT_T_UINT16;\n            fwrite(&data_type,4,1,(FILE*)mat->fp);\n            fwrite(&nBytes,4,1,(FILE*)mat->fp);\n            ptr = (mat_uint8_t*)data;\n            if ( NULL == ptr )\n                break;\n            for ( i = 0; i < N; i++ ) {\n                c = (mat_uint16_t)*(char *)ptr;\n                fwrite(&c,2,1,(FILE*)mat->fp);\n                ptr++;\n            }\n            if ( nBytes % 8 )\n                for ( i = nBytes % 8; i < 8; i++ )\n                    fwrite(&pad1,1,1,(FILE*)mat->fp);\n            break;\n        }\n        case MAT_T_UTF8:\n        {\n            mat_uint8_t *ptr;\n\n            nBytes = N;\n            fwrite(&data_type,4,1,(FILE*)mat->fp);\n            fwrite(&nBytes,4,1,(FILE*)mat->fp);\n            ptr = (mat_uint8_t*)data;\n            if ( NULL != ptr && nBytes > 0 )\n                fwrite(ptr,1,nBytes,(FILE*)mat->fp);\n            if ( nBytes % 8 )\n                for ( i = nBytes % 8; i < 8; i++ )\n                    fwrite(&pad1,1,1,(FILE*)mat->fp);\n            break;\n        }\n        case MAT_T_UNKNOWN:\n        {\n            /* Sometimes empty char data will have MAT_T_UNKNOWN, so just write\n             * a data tag\n             */\n            nBytes = N*2;\n            data_type = MAT_T_UINT16;\n            fwrite(&data_type,4,1,(FILE*)mat->fp);\n            fwrite(&nBytes,4,1,(FILE*)mat->fp);\n            break;\n        }\n        default:\n            break;\n    }\n    byteswritten += nBytes;\n    return byteswritten;\n}\n\n#if defined(HAVE_ZLIB)\n/** @brief Writes @c data as compressed character data\n *\n * This function uses the knowledge that the data is part of a character class\n * to avoid some pitfalls with Matlab listed below.\n *   @li Matlab character data cannot be unsigned 8-bit integers, it needs at\n *       least unsigned 16-bit integers\n *\n * @ingroup mat_internal\n * @param mat MAT file pointer\n * @param z pointer to the zlib compression stream\n * @param data character data to write\n * @param N Number of elements to write\n * @param data_type character data type (enum matio_types)\n * @return number of bytes written\n */\nstatic size_t\nWriteCompressedCharData(mat_t *mat,z_streamp z,void *data,int N,\n    enum matio_types data_type)\n{\n    int data_size, data_tag[2], byteswritten = 0;\n    int buf_size = 1024;\n    mat_uint8_t   buf[1024], pad[8] = {0,};\n\n    if ( mat == NULL || mat->fp == NULL )\n        return 0;\n\n    switch ( data_type ) {\n        case MAT_T_UINT8:\n        case MAT_T_UINT16:\n        case MAT_T_UTF8:\n        case MAT_T_UTF16:\n            data_size = Mat_SizeOf(data_type);\n            data_tag[0] = MAT_T_UINT8 == data_type ? MAT_T_UTF8 : data_type;\n            data_tag[1] = N*data_size;\n            z->next_in  = ZLIB_BYTE_PTR(data_tag);\n            z->avail_in = 8;\n            do {\n                z->next_out  = buf;\n                z->avail_out = buf_size;\n                deflate(z,Z_NO_FLUSH);\n                byteswritten += fwrite(buf,1,buf_size-z->avail_out,(FILE*)mat->fp);\n            } while ( z->avail_out == 0 );\n\n            /* exit early if this is an empty data */\n            if ( NULL == data || N < 1 )\n                break;\n\n            z->next_in  = (Bytef*)data;\n            z->avail_in = data_size*N;\n            do {\n                z->next_out  = buf;\n                z->avail_out = buf_size;\n                deflate(z,Z_NO_FLUSH);\n                byteswritten += fwrite(buf,1,buf_size-z->avail_out,(FILE*)mat->fp);\n            } while ( z->avail_out == 0 );\n            /* Add/Compress padding to pad to 8-byte boundary */\n            if ( N*data_size % 8 ) {\n                z->next_in  = pad;\n                z->avail_in = 8 - (N*data_size % 8);\n                do {\n                    z->next_out  = buf;\n                    z->avail_out = buf_size;\n                    deflate(z,Z_NO_FLUSH);\n                    byteswritten += fwrite(buf,1,buf_size-z->avail_out,(FILE*)mat->fp);\n                } while ( z->avail_out == 0 );\n            }\n            break;\n        case MAT_T_UNKNOWN:\n            /* Sometimes empty char data will have MAT_T_UNKNOWN, so just write a data tag */\n            data_size = 2;\n            data_tag[0] = MAT_T_UINT16;\n            data_tag[1] = N*data_size;\n            z->next_in  = ZLIB_BYTE_PTR(data_tag);\n            z->avail_in = 8;\n            do {\n                z->next_out  = buf;\n                z->avail_out = buf_size;\n                deflate(z,Z_NO_FLUSH);\n                byteswritten += fwrite(buf,1,buf_size-z->avail_out,(FILE*)mat->fp);\n            } while ( z->avail_out == 0 );\n            break;\n        default:\n            break;\n    }\n\n    return byteswritten;\n}\n#endif\n\n/** @brief Writes the data buffer to the file\n *\n * @param mat MAT file pointer\n * @param data pointer to the data to write\n * @param N number of elements to write\n * @param data_type data type of the data\n * @return number of bytes written\n */\nstatic int\nWriteData(mat_t *mat,void *data,int N,enum matio_types data_type)\n{\n    int nBytes = 0, data_size;\n\n    if ( mat == NULL || mat->fp == NULL )\n        return 0;\n\n    data_size = Mat_SizeOf(data_type);\n    nBytes    = N*data_size;\n    fwrite(&data_type,4,1,(FILE*)mat->fp);\n    fwrite(&nBytes,4,1,(FILE*)mat->fp);\n\n    if ( data != NULL && N > 0 )\n        fwrite(data,data_size,N,(FILE*)mat->fp);\n\n    return nBytes;\n}\n\n#if defined(HAVE_ZLIB)\n/* Compresses the data buffer and writes it to the file */\nstatic size_t\nWriteCompressedData(mat_t *mat,z_streamp z,void *data,int N,\n    enum matio_types data_type)\n{\n    int nBytes = 0, data_size, data_tag[2], byteswritten = 0;\n    int buf_size = 1024;\n    mat_uint8_t buf[1024], pad[8] = {0,};\n\n    if ( mat == NULL || mat->fp == NULL )\n        return 0;\n\n    data_size   = Mat_SizeOf(data_type);\n    data_tag[0] = data_type;\n    data_tag[1] = data_size*N;\n    z->next_in  = ZLIB_BYTE_PTR(data_tag);\n    z->avail_in = 8;\n    do {\n        z->next_out  = buf;\n        z->avail_out = buf_size;\n        deflate(z,Z_NO_FLUSH);\n        byteswritten += fwrite(buf,1,buf_size-z->avail_out,(FILE*)mat->fp);\n    } while ( z->avail_out == 0 );\n\n    /* exit early if this is an empty data */\n    if ( NULL == data || N < 1 )\n        return byteswritten;\n\n    z->next_in  = (Bytef*)data;\n    z->avail_in = N*data_size;\n    do {\n        z->next_out  = buf;\n        z->avail_out = buf_size;\n        deflate(z,Z_NO_FLUSH);\n        byteswritten += fwrite(buf,1,buf_size-z->avail_out,(FILE*)mat->fp);\n    } while ( z->avail_out == 0 );\n    /* Add/Compress padding to pad to 8-byte boundary */\n    if ( N*data_size % 8 ) {\n        z->next_in  = pad;\n        z->avail_in = 8 - (N*data_size % 8);\n        do {\n            z->next_out  = buf;\n            z->avail_out = buf_size;\n            deflate(z,Z_NO_FLUSH);\n            byteswritten += fwrite(buf,1,buf_size-z->avail_out,(FILE*)mat->fp);\n        } while ( z->avail_out == 0 );\n    }\n    nBytes = byteswritten;\n    return nBytes;\n}\n#endif\n\n/** @brief Reads the next cell of the cell array in @c matvar\n *\n * @ingroup mat_internal\n * @param mat MAT file pointer\n * @param matvar MAT variable pointer\n * @return Number of bytes read\n */\nstatic size_t\nReadNextCell( mat_t *mat, matvar_t *matvar )\n{\n    size_t bytesread = 0, i;\n    int err;\n    matvar_t **cells = NULL;\n    size_t nelems = 1;\n\n    err = SafeMulDims(matvar, &nelems);\n    if ( err ) {\n        Mat_Critical(\"Integer multiplication overflow\");\n        return bytesread;\n    }\n    matvar->data_size = sizeof(matvar_t *);\n    err = SafeMul(&matvar->nbytes, nelems, matvar->data_size);\n    if ( err ) {\n        Mat_Critical(\"Integer multiplication overflow\");\n        return bytesread;\n    }\n\n    matvar->data = calloc(nelems, matvar->data_size);\n    if ( NULL == matvar->data ) {\n        if ( NULL != matvar->name )\n            Mat_Critical(\"Couldn't allocate memory for %s->data\", matvar->name);\n        return bytesread;\n    }\n    cells = (matvar_t **)matvar->data;\n\n    if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {\n#if defined(HAVE_ZLIB)\n        mat_uint32_t uncomp_buf[16] = {0,};\n        int nbytes;\n        mat_uint32_t array_flags;\n\n        for ( i = 0; i < nelems; i++ ) {\n            cells[i] = Mat_VarCalloc();\n            if ( NULL == cells[i] ) {\n                Mat_Critical(\"Couldn't allocate memory for cell %\" SIZE_T_FMTSTR, i);\n                continue;\n            }\n\n            /* Read variable tag for cell */\n            uncomp_buf[0] = 0;\n            uncomp_buf[1] = 0;\n            bytesread += InflateVarTag(mat,matvar,uncomp_buf);\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(uncomp_buf);\n                (void)Mat_uint32Swap(uncomp_buf+1);\n            }\n            nbytes = uncomp_buf[1];\n            if ( 0 == nbytes ) {\n                /* Empty cell: Memory optimization */\n                free(cells[i]->internal);\n                cells[i]->internal = NULL;\n                continue;\n            } else if ( uncomp_buf[0] != MAT_T_MATRIX ) {\n                Mat_VarFree(cells[i]);\n                cells[i] = NULL;\n                Mat_Critical(\"cells[%\" SIZE_T_FMTSTR \"], Uncompressed type not MAT_T_MATRIX\", i);\n                break;\n            }\n            cells[i]->compression = MAT_COMPRESSION_ZLIB;\n            bytesread += InflateArrayFlags(mat,matvar,uncomp_buf);\n            nbytes -= 16;\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(uncomp_buf);\n                (void)Mat_uint32Swap(uncomp_buf+1);\n                (void)Mat_uint32Swap(uncomp_buf+2);\n                (void)Mat_uint32Swap(uncomp_buf+3);\n            }\n            /* Array Flags */\n            if ( uncomp_buf[0] == MAT_T_UINT32 ) {\n               array_flags = uncomp_buf[2];\n               cells[i]->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);\n               cells[i]->isComplex  = (array_flags & MAT_F_COMPLEX);\n               cells[i]->isGlobal   = (array_flags & MAT_F_GLOBAL);\n               cells[i]->isLogical  = (array_flags & MAT_F_LOGICAL);\n               if ( cells[i]->class_type == MAT_C_SPARSE ) {\n                   /* Need to find a more appropriate place to store nzmax */\n                   cells[i]->nbytes = uncomp_buf[3];\n               }\n            } else {\n                Mat_Critical(\"Expected MAT_T_UINT32 for array tags, got %d\",\n                               uncomp_buf[0]);\n                bytesread+=InflateSkip(mat,matvar->internal->z,nbytes);\n            }\n            if ( cells[i]->class_type != MAT_C_OPAQUE ) {\n                mat_uint32_t* dims = NULL;\n                int do_clean = 0;\n                bytesread += InflateRankDims(mat,matvar,uncomp_buf,sizeof(uncomp_buf),&dims);\n                if ( NULL == dims )\n                    dims = uncomp_buf + 2;\n                else\n                    do_clean = 1;\n                nbytes -= 8;\n                if ( mat->byteswap ) {\n                    (void)Mat_uint32Swap(uncomp_buf);\n                    (void)Mat_uint32Swap(uncomp_buf+1);\n                }\n                /* Rank and Dimension */\n                if ( uncomp_buf[0] == MAT_T_INT32 ) {\n                    int j;\n                    cells[i]->rank = uncomp_buf[1];\n                    nbytes -= cells[i]->rank;\n                    cells[i]->rank /= 4;\n                    cells[i]->dims = (size_t*)malloc(cells[i]->rank*sizeof(*cells[i]->dims));\n                    if ( mat->byteswap ) {\n                        for ( j = 0; j < cells[i]->rank; j++ )\n                            cells[i]->dims[j] = Mat_uint32Swap(dims + j);\n                    } else {\n                        for ( j = 0; j < cells[i]->rank; j++ )\n                            cells[i]->dims[j] = dims[j];\n                    }\n                    if ( cells[i]->rank % 2 != 0 )\n                        nbytes -= 4;\n                }\n                if ( do_clean )\n                    free(dims);\n                /* Variable name tag */\n                bytesread += InflateVarTag(mat,matvar,uncomp_buf);\n                nbytes -= 8;\n                if ( mat->byteswap ) {\n                    (void)Mat_uint32Swap(uncomp_buf);\n                    (void)Mat_uint32Swap(uncomp_buf+1);\n                }\n                /* Handle cell elements written with a variable name */\n                if ( uncomp_buf[1] > 0 ) {\n                    /* Name of variable */\n                    if ( uncomp_buf[0] == MAT_T_INT8 ) {    /* Name not in tag */\n                        mat_uint32_t len = uncomp_buf[1];\n\n                        if ( len % 8 > 0 ) {\n                            if ( len < UINT32_MAX - 8 + (len % 8) )\n                              len = len + 8 - (len % 8);\n                            else {\n                                Mat_VarFree(cells[i]);\n                                cells[i] = NULL;\n                                break;\n                            }\n                        }\n                        cells[i]->name = (char*)malloc(len + 1);\n                        nbytes -= len;\n                        if ( NULL != cells[i]->name ) {\n                            /* Variable name */\n                            bytesread += InflateVarName(mat,matvar,cells[i]->name,len);\n                            cells[i]->name[len] = '\\0';\n                        }\n                    } else {\n                        mat_uint32_t len = (uncomp_buf[0] & 0xffff0000) >> 16;\n                        if ( ((uncomp_buf[0] & 0x0000ffff) == MAT_T_INT8) && len > 0 && len <= 4 ) {\n                            /* Name packed in tag */\n                            cells[i]->name = (char*)malloc(len+1);\n                            if ( NULL != cells[i]->name ) {\n                                memcpy(cells[i]->name,uncomp_buf+1,len);\n                                cells[i]->name[len] = '\\0';\n                            }\n                        }\n                    }\n                }\n                cells[i]->internal->z = (z_streamp)calloc(1,sizeof(z_stream));\n                if ( cells[i]->internal->z != NULL ) {\n                    err = inflateCopy(cells[i]->internal->z,matvar->internal->z);\n                    if ( err == Z_OK ) {\n                        cells[i]->internal->datapos = ftell((FILE*)mat->fp);\n                        if ( cells[i]->internal->datapos != -1L ) {\n                            cells[i]->internal->datapos -= matvar->internal->z->avail_in;\n                            if ( cells[i]->class_type == MAT_C_STRUCT )\n                                bytesread+=ReadNextStructField(mat,cells[i]);\n                            else if ( cells[i]->class_type == MAT_C_CELL )\n                                bytesread+=ReadNextCell(mat,cells[i]);\n                            else if ( nbytes <= (1 << MAX_WBITS) ) {\n                                /* Memory optimization: Read data if less in size\n                                   than the zlib inflate state (approximately) */\n                                Mat_VarRead5(mat,cells[i]);\n                                cells[i]->internal->data = cells[i]->data;\n                                cells[i]->data = NULL;\n                            }\n                            (void)fseek((FILE*)mat->fp,cells[i]->internal->datapos,SEEK_SET);\n                        } else {\n                            Mat_Critical(\"Couldn't determine file position\");\n                        }\n                        if ( cells[i]->internal->data != NULL ||\n                             cells[i]->class_type == MAT_C_STRUCT ||\n                             cells[i]->class_type == MAT_C_CELL ) {\n                            /* Memory optimization: Free inflate state */\n                            inflateEnd(cells[i]->internal->z);\n                            free(cells[i]->internal->z);\n                            cells[i]->internal->z = NULL;\n                        }\n                    } else {\n                        Mat_Critical(\"inflateCopy returned error %s\",zError(err));\n                    }\n                } else {\n                    Mat_Critical(\"Couldn't allocate memory\");\n                }\n            }\n            bytesread+=InflateSkip(mat,matvar->internal->z,nbytes);\n        }\n#else\n        Mat_Critical(\"Not compiled with zlib support\");\n#endif\n\n    } else {\n        mat_uint32_t buf[6];\n        int nBytes;\n        mat_uint32_t array_flags;\n\n        for ( i = 0; i < nelems; i++ ) {\n            int cell_bytes_read;\n            mat_uint32_t name_len;\n            cells[i] = Mat_VarCalloc();\n            if ( !cells[i] ) {\n                Mat_Critical(\"Couldn't allocate memory for cell %\" SIZE_T_FMTSTR, i);\n                continue;\n            }\n\n            /* Read variable tag for cell */\n            cell_bytes_read = fread(buf,4,2,(FILE*)mat->fp);\n\n            /* Empty cells at the end of a file may cause an EOF */\n            if ( !cell_bytes_read )\n                continue;\n            bytesread += cell_bytes_read;\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(buf);\n                (void)Mat_uint32Swap(buf+1);\n            }\n            nBytes = buf[1];\n            if ( 0 == nBytes ) {\n                /* Empty cell: Memory optimization */\n                free(cells[i]->internal);\n                cells[i]->internal = NULL;\n                continue;\n            } else if ( buf[0] != MAT_T_MATRIX ) {\n                Mat_VarFree(cells[i]);\n                cells[i] = NULL;\n                Mat_Critical(\"cells[%\" SIZE_T_FMTSTR \"] not MAT_T_MATRIX, fpos = %ld\", i,\n                    ftell((FILE*)mat->fp));\n                break;\n            }\n\n            /* Read array flags and the dimensions tag */\n            bytesread += fread(buf,4,6,(FILE*)mat->fp);\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(buf);\n                (void)Mat_uint32Swap(buf+1);\n                (void)Mat_uint32Swap(buf+2);\n                (void)Mat_uint32Swap(buf+3);\n                (void)Mat_uint32Swap(buf+4);\n                (void)Mat_uint32Swap(buf+5);\n            }\n            nBytes-=24;\n            /* Array flags */\n            if ( buf[0] == MAT_T_UINT32 ) {\n               array_flags = buf[2];\n               cells[i]->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);\n               cells[i]->isComplex  = (array_flags & MAT_F_COMPLEX);\n               cells[i]->isGlobal   = (array_flags & MAT_F_GLOBAL);\n               cells[i]->isLogical  = (array_flags & MAT_F_LOGICAL);\n               if ( cells[i]->class_type == MAT_C_SPARSE ) {\n                   /* Need to find a more appropriate place to store nzmax */\n                   cells[i]->nbytes = buf[3];\n               }\n            }\n            /* Rank and dimension */\n            {\n                size_t nbytes = ReadRankDims(mat, cells[i], (enum matio_types)buf[4], buf[5]);\n                bytesread += nbytes;\n                nBytes -= nbytes;\n            }\n            /* Variable name tag */\n            bytesread+=fread(buf,1,8,(FILE*)mat->fp);\n            nBytes-=8;\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(buf);\n                (void)Mat_uint32Swap(buf+1);\n            }\n            name_len = 0;\n            if ( buf[1] > 0 ) {\n                /* Name of variable */\n                if ( buf[0] == MAT_T_INT8 ) {    /* Name not in tag */\n                    name_len = buf[1];\n                    if ( name_len % 8 > 0 )\n                        if ( name_len < UINT32_MAX - 8 + (name_len % 8) )\n                            name_len = name_len + 8 - (name_len % 8);\n                        else {\n                            Mat_VarFree(cells[i]);\n                            cells[i] = NULL;\n                            break;\n                        }\n                    nBytes -= name_len;\n                    (void)fseek((FILE*)mat->fp,name_len,SEEK_CUR);\n                }\n            }\n            cells[i]->internal->datapos = ftell((FILE*)mat->fp);\n            if ( cells[i]->internal->datapos != -1L ) {\n                if ( cells[i]->class_type == MAT_C_STRUCT )\n                    bytesread+=ReadNextStructField(mat,cells[i]);\n                if ( cells[i]->class_type == MAT_C_CELL )\n                    bytesread+=ReadNextCell(mat,cells[i]);\n                (void)fseek((FILE*)mat->fp,cells[i]->internal->datapos+nBytes,SEEK_SET);\n            } else {\n                Mat_Critical(\"Couldn't determine file position\");\n            }\n        }\n    }\n\n    return bytesread;\n}\n\n/** @brief Reads the next struct field of the structure in @c matvar\n *\n * Reads the next struct fields (fieldname length,names,data headers for all\n * the fields\n * @ingroup mat_internal\n * @param mat MAT file pointer\n * @param matvar MAT variable pointer\n * @return Number of bytes read\n */\nstatic size_t\nReadNextStructField( mat_t *mat, matvar_t *matvar )\n{\n    mat_uint32_t fieldname_size;\n    int err;\n    size_t bytesread = 0, nfields, i;\n    matvar_t **fields = NULL;\n    size_t nelems = 1, nelems_x_nfields;\n\n    err = SafeMulDims(matvar, &nelems);\n    if ( err ) {\n        Mat_Critical(\"Integer multiplication overflow\");\n        return bytesread;\n    }\n    if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {\n#if defined(HAVE_ZLIB)\n        mat_uint32_t uncomp_buf[16] = {0,};\n        int nbytes;\n        mat_uint32_t array_flags, len;\n\n        /* Field name length */\n        bytesread += InflateVarTag(mat,matvar,uncomp_buf);\n        if ( mat->byteswap ) {\n            (void)Mat_uint32Swap(uncomp_buf);\n            (void)Mat_uint32Swap(uncomp_buf+1);\n        }\n        if ( (uncomp_buf[0] & 0x0000ffff) == MAT_T_INT32 && uncomp_buf[1] > 0 ) {\n            fieldname_size = uncomp_buf[1];\n        } else {\n            Mat_Critical(\"Error getting fieldname size\");\n            return bytesread;\n        }\n\n        /* Field name tag */\n        bytesread += InflateVarTag(mat,matvar,uncomp_buf);\n        if ( mat->byteswap )\n            (void)Mat_uint32Swap(uncomp_buf);\n        /* Name of field */\n        if ( uncomp_buf[0] == MAT_T_INT8 ) {    /* Name not in tag */\n            if ( mat->byteswap )\n                len = Mat_uint32Swap(uncomp_buf+1);\n            else\n                len = uncomp_buf[1];\n            nfields = len / fieldname_size;\n            if ( nfields*fieldname_size % 8 != 0 )\n                i = 8-(nfields*fieldname_size % 8);\n            else\n                i = 0;\n            if ( nfields ) {\n                char *ptr = (char*)malloc(nfields*fieldname_size+i);\n                if ( NULL != ptr ) {\n                    bytesread += InflateVarName(mat,matvar,ptr,nfields*fieldname_size+i);\n                    SetFieldNames(matvar, ptr, nfields, fieldname_size);\n                    free(ptr);\n                }\n            } else {\n                matvar->internal->num_fields = 0;\n                matvar->internal->fieldnames = NULL;\n            }\n        } else {\n            len = (uncomp_buf[0] & 0xffff0000) >> 16;\n            if ( ((uncomp_buf[0] & 0x0000ffff) == MAT_T_INT8) && len > 0 && len <= 4 ) {\n                /* Name packed in tag */\n                nfields = len / fieldname_size;\n                if ( nfields ) {\n                    SetFieldNames(matvar, (char*)(uncomp_buf + 1), nfields, fieldname_size);\n                } else {\n                    matvar->internal->num_fields = 0;\n                    matvar->internal->fieldnames = NULL;\n                }\n            } else {\n                nfields = 0;\n            }\n        }\n\n        matvar->data_size = sizeof(matvar_t *);\n        err = SafeMul(&nelems_x_nfields, nelems, nfields);\n        if ( err ) {\n            Mat_Critical(\"Integer multiplication overflow\");\n            return bytesread;\n        }\n        err = SafeMul(&matvar->nbytes, nelems_x_nfields, matvar->data_size);\n        if ( err ) {\n            Mat_Critical(\"Integer multiplication overflow\");\n            return bytesread;\n        }\n        if ( !matvar->nbytes )\n            return bytesread;\n\n        matvar->data = calloc(nelems_x_nfields, matvar->data_size);\n        if ( NULL == matvar->data ) {\n            Mat_Critical(\"Couldn't allocate memory for the data\");\n            return bytesread;\n        }\n\n        fields = (matvar_t**)matvar->data;\n        for ( i = 0; i < nelems; i++ ) {\n            size_t k;\n            for ( k = 0; k < nfields; k++ ) {\n                fields[i*nfields+k] = Mat_VarCalloc();\n            }\n        }\n        if ( NULL != matvar->internal->fieldnames ) {\n            for ( i = 0; i < nelems; i++ ) {\n                size_t k;\n                for ( k = 0; k < nfields; k++ ) {\n                    if ( NULL != matvar->internal->fieldnames[k] ) {\n                        fields[i*nfields+k]->name = strdup(matvar->internal->fieldnames[k]);\n                    }\n                }\n            }\n        }\n\n        for ( i = 0; i < nelems_x_nfields; i++ ) {\n            /* Read variable tag for struct field */\n            bytesread += InflateVarTag(mat,matvar,uncomp_buf);\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(uncomp_buf);\n                (void)Mat_uint32Swap(uncomp_buf+1);\n            }\n            nbytes = uncomp_buf[1];\n            if ( uncomp_buf[0] != MAT_T_MATRIX ) {\n                Mat_VarFree(fields[i]);\n                fields[i] = NULL;\n                Mat_Critical(\"fields[%\" SIZE_T_FMTSTR \"], Uncompressed type not MAT_T_MATRIX\", i);\n                continue;\n            } else if ( 0 == nbytes ) {\n                /* Empty field: Memory optimization */\n                free(fields[i]->internal);\n                fields[i]->internal = NULL;\n                continue;\n            }\n            fields[i]->compression = MAT_COMPRESSION_ZLIB;\n            bytesread += InflateArrayFlags(mat,matvar,uncomp_buf);\n            nbytes -= 16;\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(uncomp_buf);\n                (void)Mat_uint32Swap(uncomp_buf+1);\n                (void)Mat_uint32Swap(uncomp_buf+2);\n                (void)Mat_uint32Swap(uncomp_buf+3);\n            }\n            /* Array flags */\n            if ( uncomp_buf[0] == MAT_T_UINT32 ) {\n               array_flags = uncomp_buf[2];\n               fields[i]->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);\n               fields[i]->isComplex  = (array_flags & MAT_F_COMPLEX);\n               fields[i]->isGlobal   = (array_flags & MAT_F_GLOBAL);\n               fields[i]->isLogical  = (array_flags & MAT_F_LOGICAL);\n               if ( fields[i]->class_type == MAT_C_SPARSE ) {\n                   /* Need to find a more appropriate place to store nzmax */\n                   fields[i]->nbytes = uncomp_buf[3];\n               }\n            } else {\n                Mat_Critical(\"Expected MAT_T_UINT32 for array tags, got %d\",\n                    uncomp_buf[0]);\n                bytesread+=InflateSkip(mat,matvar->internal->z,nbytes);\n            }\n            if ( fields[i]->class_type != MAT_C_OPAQUE ) {\n                mat_uint32_t* dims = NULL;\n                int do_clean = 0;\n                bytesread += InflateRankDims(mat,matvar,uncomp_buf,sizeof(uncomp_buf),&dims);\n                if ( NULL == dims )\n                    dims = uncomp_buf + 2;\n                else\n                    do_clean = 1;\n                nbytes -= 8;\n                if ( mat->byteswap ) {\n                    (void)Mat_uint32Swap(uncomp_buf);\n                    (void)Mat_uint32Swap(uncomp_buf+1);\n                }\n                /* Rank and dimension */\n                if ( uncomp_buf[0] == MAT_T_INT32 ) {\n                    int j;\n                    fields[i]->rank = uncomp_buf[1];\n                    nbytes -= fields[i]->rank;\n                    fields[i]->rank /= 4;\n                    fields[i]->dims = (size_t*)malloc(fields[i]->rank*\n                                             sizeof(*fields[i]->dims));\n                    if ( mat->byteswap ) {\n                        for ( j = 0; j < fields[i]->rank; j++ )\n                            fields[i]->dims[j] = Mat_uint32Swap(dims+j);\n                    } else {\n                        for ( j = 0; j < fields[i]->rank; j++ )\n                            fields[i]->dims[j] = dims[j];\n                    }\n                    if ( fields[i]->rank % 2 != 0 )\n                        nbytes -= 4;\n                }\n                if ( do_clean )\n                    free(dims);\n                /* Variable name tag */\n                bytesread += InflateVarTag(mat,matvar,uncomp_buf);\n                nbytes -= 8;\n                fields[i]->internal->z = (z_streamp)calloc(1,sizeof(z_stream));\n                if ( fields[i]->internal->z != NULL ) {\n                    err = inflateCopy(fields[i]->internal->z,matvar->internal->z);\n                    if ( err == Z_OK ) {\n                        fields[i]->internal->datapos = ftell((FILE*)mat->fp);\n                        if ( fields[i]->internal->datapos != -1L ) {\n                            fields[i]->internal->datapos -= matvar->internal->z->avail_in;\n                            if ( fields[i]->class_type == MAT_C_STRUCT )\n                                bytesread+=ReadNextStructField(mat,fields[i]);\n                            else if ( fields[i]->class_type == MAT_C_CELL )\n                                bytesread+=ReadNextCell(mat,fields[i]);\n                            else if ( nbytes <= (1 << MAX_WBITS) ) {\n                                /* Memory optimization: Read data if less in size\n                                   than the zlib inflate state (approximately) */\n                                Mat_VarRead5(mat,fields[i]);\n                                fields[i]->internal->data = fields[i]->data;\n                                fields[i]->data = NULL;\n                            }\n                            (void)fseek((FILE*)mat->fp,fields[i]->internal->datapos,SEEK_SET);\n                        } else {\n                            Mat_Critical(\"Couldn't determine file position\");\n                        }\n                        if ( fields[i]->internal->data != NULL ||\n                             fields[i]->class_type == MAT_C_STRUCT ||\n                             fields[i]->class_type == MAT_C_CELL ) {\n                            /* Memory optimization: Free inflate state */\n                            inflateEnd(fields[i]->internal->z);\n                            free(fields[i]->internal->z);\n                            fields[i]->internal->z = NULL;\n                        }\n                    } else {\n                        Mat_Critical(\"inflateCopy returned error %s\",zError(err));\n                    }\n                } else {\n                    Mat_Critical(\"Couldn't allocate memory\");\n                }\n            }\n            bytesread+=InflateSkip(mat,matvar->internal->z,nbytes);\n        }\n#else\n        Mat_Critical(\"Not compiled with zlib support\");\n#endif\n    } else {\n        mat_uint32_t buf[6];\n        int nBytes;\n        mat_uint32_t array_flags, len;\n\n        bytesread+=fread(buf,4,2,(FILE*)mat->fp);\n        if ( mat->byteswap ) {\n            (void)Mat_uint32Swap(buf);\n            (void)Mat_uint32Swap(buf+1);\n        }\n        if ( (buf[0] & 0x0000ffff) == MAT_T_INT32 && buf[1] > 0 ) {\n            fieldname_size = buf[1];\n        } else {\n            Mat_Critical(\"Error getting fieldname size\");\n            return bytesread;\n        }\n\n        /* Field name tag */\n        bytesread+=fread(buf,4,2,(FILE*)mat->fp);\n        if ( mat->byteswap )\n            (void)Mat_uint32Swap(buf);\n        /* Name of field */\n        if ( buf[0] == MAT_T_INT8 ) {    /* Name not in tag */\n            if ( mat->byteswap )\n                len = Mat_uint32Swap(buf+1);\n            else\n                len = buf[1];\n            nfields = len / fieldname_size;\n            if ( nfields ) {\n                char *ptr = (char*)malloc(nfields*fieldname_size);\n                if ( NULL != ptr ) {\n                    size_t readresult = fread(ptr, 1, nfields*fieldname_size, (FILE*)mat->fp);\n                    bytesread += readresult;\n                    if ( nfields*fieldname_size == readresult )\n                        SetFieldNames(matvar, ptr, nfields, fieldname_size);\n                    else\n                        matvar->internal->fieldnames = NULL;\n                    free(ptr);\n                }\n                if ( (nfields*fieldname_size) % 8 ) {\n                    (void)fseek((FILE*)mat->fp,8-((nfields*fieldname_size) % 8),SEEK_CUR);\n                    bytesread+=8-((nfields*fieldname_size) % 8);\n                }\n            } else {\n                matvar->internal->num_fields = 0;\n                matvar->internal->fieldnames = NULL;\n            }\n       } else {\n            len = (buf[0] & 0xffff0000) >> 16;\n            if ( ((buf[0] & 0x0000ffff) == MAT_T_INT8) && len > 0 && len <= 4 ) {\n                /* Name packed in tag */\n                nfields = len / fieldname_size;\n                if ( nfields ) {\n                    SetFieldNames(matvar, (char*)(buf + 1), nfields, fieldname_size);\n                } else {\n                    matvar->internal->num_fields = 0;\n                    matvar->internal->fieldnames = NULL;\n                }\n            } else {\n                nfields = 0;\n            }\n        }\n\n        matvar->data_size = sizeof(matvar_t *);\n        err = SafeMul(&nelems_x_nfields, nelems, nfields);\n        if ( err ) {\n            Mat_Critical(\"Integer multiplication overflow\");\n            return bytesread;\n        }\n        err = SafeMul(&matvar->nbytes, nelems_x_nfields, matvar->data_size);\n        if ( err ) {\n            Mat_Critical(\"Integer multiplication overflow\");\n            return bytesread;\n        }\n        if ( !matvar->nbytes )\n            return bytesread;\n\n        matvar->data = malloc(matvar->nbytes);\n        if ( NULL == matvar->data )\n            return bytesread;\n\n        fields = (matvar_t**)matvar->data;\n        for ( i = 0; i < nelems; i++ ) {\n            size_t k;\n            for ( k = 0; k < nfields; k++ ) {\n                fields[i*nfields+k] = Mat_VarCalloc();\n            }\n        }\n        if ( NULL != matvar->internal->fieldnames ) {\n            for ( i = 0; i < nelems; i++ ) {\n                size_t k;\n                for ( k = 0; k < nfields; k++ ) {\n                    if ( NULL != matvar->internal->fieldnames[k] ) {\n                        fields[i*nfields+k]->name = strdup(matvar->internal->fieldnames[k]);\n                    }\n                }\n            }\n        }\n\n        for ( i = 0; i < nelems_x_nfields; i++ ) {\n            /* Read variable tag for struct field */\n            bytesread += fread(buf,4,2,(FILE*)mat->fp);\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(buf);\n                (void)Mat_uint32Swap(buf+1);\n            }\n            nBytes = buf[1];\n            if ( buf[0] != MAT_T_MATRIX ) {\n                Mat_VarFree(fields[i]);\n                fields[i] = NULL;\n                Mat_Critical(\"fields[%\" SIZE_T_FMTSTR \"] not MAT_T_MATRIX, fpos = %ld\", i,\n                    ftell((FILE*)mat->fp));\n                return bytesread;\n            } else if ( 0 == nBytes ) {\n                /* Empty field: Memory optimization */\n                free(fields[i]->internal);\n                fields[i]->internal = NULL;\n                continue;\n            }\n\n            /* Read array flags and the dimensions tag */\n            bytesread += fread(buf,4,6,(FILE*)mat->fp);\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(buf);\n                (void)Mat_uint32Swap(buf+1);\n                (void)Mat_uint32Swap(buf+2);\n                (void)Mat_uint32Swap(buf+3);\n                (void)Mat_uint32Swap(buf+4);\n                (void)Mat_uint32Swap(buf+5);\n            }\n            nBytes-=24;\n            /* Array flags */\n            if ( buf[0] == MAT_T_UINT32 ) {\n                array_flags = buf[2];\n                fields[i]->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);\n                fields[i]->isComplex  = (array_flags & MAT_F_COMPLEX);\n                fields[i]->isGlobal   = (array_flags & MAT_F_GLOBAL);\n                fields[i]->isLogical  = (array_flags & MAT_F_LOGICAL);\n                if ( fields[i]->class_type == MAT_C_SPARSE ) {\n                    /* Need to find a more appropriate place to store nzmax */\n                    fields[i]->nbytes = buf[3];\n                }\n            }\n            /* Rank and dimension */\n            {\n                size_t nbytes = ReadRankDims(mat, fields[i], (enum matio_types)buf[4], buf[5]);\n                bytesread += nbytes;\n                nBytes -= nbytes;\n            }\n            /* Variable name tag */\n            bytesread+=fread(buf,1,8,(FILE*)mat->fp);\n            nBytes-=8;\n            fields[i]->internal->datapos = ftell((FILE*)mat->fp);\n            if ( fields[i]->internal->datapos != -1L ) {\n                if ( fields[i]->class_type == MAT_C_STRUCT )\n                    bytesread+=ReadNextStructField(mat,fields[i]);\n                else if ( fields[i]->class_type == MAT_C_CELL )\n                    bytesread+=ReadNextCell(mat,fields[i]);\n                (void)fseek((FILE*)mat->fp,fields[i]->internal->datapos+nBytes,SEEK_SET);\n            } else {\n                Mat_Critical(\"Couldn't determine file position\");\n            }\n        }\n    }\n\n    return bytesread;\n}\n\n/** @brief Reads the function handle data of the function handle in @c matvar\n *\n * @ingroup mat_internal\n * @param mat MAT file pointer\n * @param matvar MAT variable pointer\n * @return Number of bytes read\n */\nstatic size_t\nReadNextFunctionHandle(mat_t *mat, matvar_t *matvar)\n{\n    int err;\n    size_t nelems = 1;\n\n    err = SafeMulDims(matvar, &nelems);\n    matvar->data_size = sizeof(matvar_t *);\n    err |= SafeMul(&matvar->nbytes, nelems, matvar->data_size);\n    if ( err )\n        return 0;\n\n    matvar->data = malloc(matvar->nbytes);\n    if ( matvar->data != NULL ) {\n        size_t i;\n        matvar_t **functions = (matvar_t**)matvar->data;;\n        for ( i = 0; i < nelems; i++ )\n            functions[i] = Mat_VarReadNextInfo(mat);\n    } else {\n        matvar->data_size = 0;\n        matvar->nbytes    = 0;\n    }\n\n    return 0;\n}\n\n/** @brief Reads the rank and dimensions in @c matvar\n *\n * @ingroup mat_internal\n * @param mat MAT file pointer\n * @param matvar MAT variable pointer\n * @param data_type data type of dimension array\n * @param nbytes len of dimension array in bytes\n * @return Number of bytes read\n */\nstatic size_t\nReadRankDims(mat_t *mat, matvar_t *matvar, enum matio_types data_type, mat_uint32_t nbytes)\n{\n    size_t bytesread = 0;\n    /* Rank and dimension */\n    if ( data_type == MAT_T_INT32 ) {\n        matvar->rank = nbytes / sizeof(mat_uint32_t);\n        matvar->dims = (size_t*)malloc(matvar->rank*sizeof(*matvar->dims));\n        if ( NULL != matvar->dims ) {\n            int i;\n            mat_uint32_t buf;\n\n            for ( i = 0; i < matvar->rank; i++) {\n                size_t readresult = fread(&buf, sizeof(mat_uint32_t), 1, (FILE*)mat->fp);\n                if ( 1 == readresult ) {\n                    bytesread += sizeof(mat_uint32_t);\n                    if ( mat->byteswap ) {\n                        matvar->dims[i] = Mat_uint32Swap(&buf);\n                    } else {\n                        matvar->dims[i] = buf;\n                    }\n                } else {\n                    free(matvar->dims);\n                    matvar->dims = NULL;\n                    matvar->rank = 0;\n                    return 0;\n                }\n            }\n\n            if ( matvar->rank % 2 != 0 ) {\n                size_t readresult = fread(&buf, sizeof(mat_uint32_t), 1, (FILE*)mat->fp);\n                if ( 1 == readresult ) {\n                    bytesread += sizeof(mat_uint32_t);\n                } else {\n                    free(matvar->dims);\n                    matvar->dims = NULL;\n                    matvar->rank = 0;\n                    return 0;\n                }\n            }\n        } else {\n            matvar->rank = 0;\n            Mat_Critical(\"Error allocating memory for dims\");\n        }\n    }\n    return bytesread;\n}\n\n/** @brief Writes the header and data for a given type\n *\n * @ingroup mat_internal\n * @param mat MAT file pointer\n * @param matvar pointer to the mat variable\n * @retval 0 on success\n */\nstatic int\nWriteType(mat_t *mat,matvar_t *matvar)\n{\n    int err;\n    mat_int16_t array_name_type = MAT_T_INT8;\n    mat_int8_t pad1 = 0;\n    int nBytes, j;\n    size_t nelems = 1;\n\n    err = SafeMulDims(matvar, &nelems);\n    if ( err )\n        return err;\n\n    switch ( matvar->class_type ) {\n        case MAT_C_DOUBLE:\n        case MAT_C_SINGLE:\n        case MAT_C_INT64:\n        case MAT_C_UINT64:\n        case MAT_C_INT32:\n        case MAT_C_UINT32:\n        case MAT_C_INT16:\n        case MAT_C_UINT16:\n        case MAT_C_INT8:\n        case MAT_C_UINT8:\n        {\n            if ( matvar->isComplex ) {\n                mat_complex_split_t *complex_data = (mat_complex_split_t*)matvar->data;\n\n                if ( NULL == matvar->data )\n                    complex_data = &null_complex_data;\n\n                nBytes=WriteData(mat,complex_data->Re,nelems,matvar->data_type);\n                if ( nBytes % 8 )\n                    for ( j = nBytes % 8; j < 8; j++ )\n                        fwrite(&pad1,1,1,(FILE*)mat->fp);\n                nBytes=WriteData(mat,complex_data->Im,nelems,matvar->data_type);\n                if ( nBytes % 8 )\n                    for ( j = nBytes % 8; j < 8; j++ )\n                        fwrite(&pad1,1,1,(FILE*)mat->fp);\n            } else {\n                nBytes=WriteData(mat,matvar->data,nelems,matvar->data_type);\n                if ( nBytes % 8 )\n                    for ( j = nBytes % 8; j < 8; j++ )\n                        fwrite(&pad1,1,1,(FILE*)mat->fp);\n            }\n            break;\n        }\n        case MAT_C_CHAR:\n            nBytes=WriteCharData(mat,matvar->data,nelems,matvar->data_type);\n            break;\n        case MAT_C_CELL:\n        {\n            size_t i;\n            matvar_t **cells = (matvar_t **)matvar->data;\n\n            /* Check for an empty cell array */\n            if ( matvar->nbytes == 0 || matvar->data_size == 0 ||\n                 matvar->data   == NULL )\n                break;\n            nelems = matvar->nbytes / matvar->data_size;\n            for ( i = 0; i < nelems; i++ )\n                WriteCellArrayField(mat,cells[i]);\n            break;\n        }\n        case MAT_C_STRUCT:\n        {\n            mat_int16_t fieldname_type = MAT_T_INT32;\n            mat_int16_t fieldname_data_size = 4;\n            char *padzero;\n            int fieldname_size;\n            size_t maxlen = 0, nfields, i, nelems_x_nfields;\n            matvar_t **fields = (matvar_t **)matvar->data;\n            unsigned fieldname;\n\n            /* nelems*matvar->data_size can be zero when saving a struct that\n             * contains an empty struct in one of its fields\n             * (e.g. x.y = struct('z', {})). If it's zero, we would divide\n             * by zero.\n             */\n            nfields = matvar->internal->num_fields;\n            /* Check for a structure with no fields */\n            if ( nfields < 1 ) {\n#if 0\n                fwrite(&fieldname_type,2,1,(FILE*)mat->fp);\n                fwrite(&fieldname_data_size,2,1,(FILE*)mat->fp);\n#else\n                fieldname = (fieldname_data_size<<16) | fieldname_type;\n                fwrite(&fieldname,4,1,(FILE*)mat->fp);\n#endif\n                fieldname_size = 1;\n                fwrite(&fieldname_size,4,1,(FILE*)mat->fp);\n                fwrite(&array_name_type,2,1,(FILE*)mat->fp);\n                fwrite(&pad1,1,1,(FILE*)mat->fp);\n                fwrite(&pad1,1,1,(FILE*)mat->fp);\n                nBytes = 0;\n                fwrite(&nBytes,4,1,(FILE*)mat->fp);\n                break;\n            }\n\n            for ( i = 0; i < nfields; i++ ) {\n                size_t len = strlen(matvar->internal->fieldnames[i]);\n                if ( len > maxlen )\n                    maxlen = len;\n            }\n            maxlen++;\n            fieldname_size = maxlen;\n            while ( nfields*fieldname_size % 8 != 0 )\n                fieldname_size++;\n#if 0\n            fwrite(&fieldname_type,2,1,(FILE*)mat->fp);\n            fwrite(&fieldname_data_size,2,1,(FILE*)mat->fp);\n#else\n            fieldname = (fieldname_data_size<<16) | fieldname_type;\n            fwrite(&fieldname,4,1,(FILE*)mat->fp);\n#endif\n            fwrite(&fieldname_size,4,1,(FILE*)mat->fp);\n            fwrite(&array_name_type,2,1,(FILE*)mat->fp);\n            fwrite(&pad1,1,1,(FILE*)mat->fp);\n            fwrite(&pad1,1,1,(FILE*)mat->fp);\n            nBytes = nfields*fieldname_size;\n            fwrite(&nBytes,4,1,(FILE*)mat->fp);\n            padzero = (char*)calloc(fieldname_size,1);\n            for ( i = 0; i < nfields; i++ ) {\n                size_t len = strlen(matvar->internal->fieldnames[i]);\n                fwrite(matvar->internal->fieldnames[i],1,len,(FILE*)mat->fp);\n                fwrite(padzero,1,fieldname_size-len,(FILE*)mat->fp);\n            }\n            free(padzero);\n            err = SafeMul(&nelems_x_nfields, nelems, nfields);\n            if ( err )\n                break;\n            for ( i = 0; i < nelems_x_nfields; i++ )\n                WriteStructField(mat,fields[i]);\n            break;\n        }\n        case MAT_C_SPARSE:\n        {\n            mat_sparse_t *sparse = (mat_sparse_t*)matvar->data;\n\n            nBytes = WriteData(mat,sparse->ir,sparse->nir,MAT_T_INT32);\n            if ( nBytes % 8 )\n                for ( j = nBytes % 8; j < 8; j++ )\n                    fwrite(&pad1,1,1,(FILE*)mat->fp);\n            nBytes = WriteData(mat,sparse->jc,sparse->njc,MAT_T_INT32);\n            if ( nBytes % 8 )\n                for ( j = nBytes % 8; j < 8; j++ )\n                    fwrite(&pad1,1,1,(FILE*)mat->fp);\n            if ( matvar->isComplex ) {\n                mat_complex_split_t *complex_data = (mat_complex_split_t*)sparse->data;\n                nBytes = WriteData(mat,complex_data->Re,sparse->ndata,\n                                   matvar->data_type);\n                if ( nBytes % 8 )\n                    for ( j = nBytes % 8; j < 8; j++ )\n                        fwrite(&pad1,1,1,(FILE*)mat->fp);\n                nBytes = WriteData(mat,complex_data->Im,sparse->ndata,\n                                   matvar->data_type);\n                if ( nBytes % 8 )\n                    for ( j = nBytes % 8; j < 8; j++ )\n                        fwrite(&pad1,1,1,(FILE*)mat->fp);\n            } else {\n                nBytes = WriteData(mat,sparse->data,sparse->ndata,\n                                   matvar->data_type);\n                if ( nBytes % 8 )\n                    for ( j = nBytes % 8; j < 8; j++ )\n                        fwrite(&pad1,1,1,(FILE*)mat->fp);\n            }\n        }\n        case MAT_C_FUNCTION:\n        case MAT_C_OBJECT:\n        case MAT_C_EMPTY:\n        case MAT_C_OPAQUE:\n            break;\n    }\n\n    return err;\n}\n\n/** @brief Writes the header and data for an element of a cell array\n *\n * @ingroup mat_internal\n * @param mat MAT file pointer\n * @param matvar pointer to the mat variable\n * @retval 0 on success\n */\nstatic int\nWriteCellArrayField(mat_t *mat,matvar_t *matvar)\n{\n    mat_uint32_t array_flags;\n    mat_int16_t array_name_type = MAT_T_INT8;\n    int array_flags_type = MAT_T_UINT32, dims_array_type = MAT_T_INT32;\n    int array_flags_size = 8, pad4 = 0, matrix_type = MAT_T_MATRIX;\n    const mat_int8_t pad1 = 0;\n    int nBytes, i, nzmax = 0;\n    long start = 0, end = 0;\n\n    if ( matvar == NULL || mat == NULL )\n        return 1;\n\n    fwrite(&matrix_type,4,1,(FILE*)mat->fp);\n    fwrite(&pad4,4,1,(FILE*)mat->fp);\n    if ( MAT_C_EMPTY == matvar->class_type ) {\n        /* exit early if this is an empty data */\n        return 0;\n    }\n    start = ftell((FILE*)mat->fp);\n\n    /* Array Flags */\n    array_flags = matvar->class_type & CLASS_TYPE_MASK;\n    if ( matvar->isComplex )\n        array_flags |= MAT_F_COMPLEX;\n    if ( matvar->isGlobal )\n        array_flags |= MAT_F_GLOBAL;\n    if ( matvar->isLogical )\n        array_flags |= MAT_F_LOGICAL;\n    if ( matvar->class_type == MAT_C_SPARSE )\n        nzmax = ((mat_sparse_t *)matvar->data)->nzmax;\n\n    if ( mat->byteswap )\n        array_flags = Mat_int32Swap((mat_int32_t*)&array_flags);\n    fwrite(&array_flags_type,4,1,(FILE*)mat->fp);\n    fwrite(&array_flags_size,4,1,(FILE*)mat->fp);\n    fwrite(&array_flags,4,1,(FILE*)mat->fp);\n    fwrite(&nzmax,4,1,(FILE*)mat->fp);\n    /* Rank and Dimension */\n    nBytes = matvar->rank * 4;\n    fwrite(&dims_array_type,4,1,(FILE*)mat->fp);\n    fwrite(&nBytes,4,1,(FILE*)mat->fp);\n    for ( i = 0; i < matvar->rank; i++ ) {\n        mat_int32_t dim;\n        dim = matvar->dims[i];\n        fwrite(&dim,4,1,(FILE*)mat->fp);\n    }\n    if ( matvar->rank % 2 != 0 )\n        fwrite(&pad4,4,1,(FILE*)mat->fp);\n    /* Name of variable */\n    if ( !matvar->name ) {\n        fwrite(&array_name_type,2,1,(FILE*)mat->fp);\n        fwrite(&pad1,1,1,(FILE*)mat->fp);\n        fwrite(&pad1,1,1,(FILE*)mat->fp);\n        fwrite(&pad4,4,1,(FILE*)mat->fp);\n    } else if ( strlen(matvar->name) <= 4 ) {\n        mat_int16_t array_name_len = (mat_int16_t)strlen(matvar->name);\n        fwrite(&array_name_type,2,1,(FILE*)mat->fp);\n        fwrite(&array_name_len,2,1,(FILE*)mat->fp);\n        fwrite(matvar->name,1,array_name_len,(FILE*)mat->fp);\n        for ( i = array_name_len; i < 4; i++ )\n            fwrite(&pad1,1,1,(FILE*)mat->fp);\n    } else {\n        mat_int32_t array_name_len = (mat_int32_t)strlen(matvar->name);\n        fwrite(&array_name_type,2,1,(FILE*)mat->fp);\n        fwrite(&pad1,1,1,(FILE*)mat->fp);\n        fwrite(&pad1,1,1,(FILE*)mat->fp);\n        fwrite(&array_name_len,4,1,(FILE*)mat->fp);\n        fwrite(matvar->name,1,array_name_len,(FILE*)mat->fp);\n        if ( array_name_len % 8 )\n            for ( i = array_name_len % 8; i < 8; i++ )\n                fwrite(&pad1,1,1,(FILE*)mat->fp);\n    }\n\n    WriteType(mat,matvar);\n    end = ftell((FILE*)mat->fp);\n    if ( start != -1L && end != -1L ) {\n        nBytes = (int)(end-start);\n        (void)fseek((FILE*)mat->fp,(long)-(nBytes+4),SEEK_CUR);\n        fwrite(&nBytes,4,1,(FILE*)mat->fp);\n        (void)fseek((FILE*)mat->fp,end,SEEK_SET);\n    } else {\n        Mat_Critical(\"Couldn't determine file position\");\n    }\n\n    return 0;\n}\n\n#if defined(HAVE_ZLIB)\n/** @brief Writes the header and data for a given class type\n *\n * @ingroup mat_internal\n * @param mat MAT file pointer\n * @param matvar pointer to the mat variable\n * @return number of bytes written to the MAT file\n */\nstatic size_t\nWriteCompressedTypeArrayFlags(mat_t *mat,matvar_t *matvar,z_streamp z)\n{\n    mat_uint32_t array_flags;\n    mat_int16_t  array_name_type = MAT_T_INT8;\n    int array_flags_type = MAT_T_UINT32, dims_array_type = MAT_T_INT32;\n    int array_flags_size = 8;\n    int nBytes, i, nzmax = 0;\n\n    mat_uint32_t comp_buf[512];\n    mat_uint32_t uncomp_buf[512] = {0,};\n    int buf_size = 512;\n    size_t byteswritten = 0;\n\n    if ( MAT_C_EMPTY == matvar->class_type ) {\n        /* exit early if this is an empty data */\n        return byteswritten;\n    }\n\n    /* Array Flags */\n    array_flags = matvar->class_type & CLASS_TYPE_MASK;\n    if ( matvar->isComplex )\n        array_flags |= MAT_F_COMPLEX;\n    if ( matvar->isGlobal )\n        array_flags |= MAT_F_GLOBAL;\n    if ( matvar->isLogical )\n        array_flags |= MAT_F_LOGICAL;\n    if ( matvar->class_type == MAT_C_SPARSE )\n        nzmax = ((mat_sparse_t *)matvar->data)->nzmax;\n    uncomp_buf[0] = array_flags_type;\n    uncomp_buf[1] = array_flags_size;\n    uncomp_buf[2] = array_flags;\n    uncomp_buf[3] = nzmax;\n    /* Rank and Dimension */\n    nBytes = matvar->rank * 4;\n    uncomp_buf[4] = dims_array_type;\n    uncomp_buf[5] = nBytes;\n    for ( i = 0; i < matvar->rank; i++ ) {\n        mat_int32_t dim;\n        dim = matvar->dims[i];\n        uncomp_buf[6+i] = dim;\n    }\n    if ( matvar->rank % 2 != 0 ) {\n        int pad4 = 0;\n        uncomp_buf[6+i] = pad4;\n        i++;\n    }\n\n    z->next_in  = ZLIB_BYTE_PTR(uncomp_buf);\n    z->avail_in = (6+i)*sizeof(*uncomp_buf);\n    do {\n        z->next_out  = ZLIB_BYTE_PTR(comp_buf);\n        z->avail_out = buf_size*sizeof(*comp_buf);\n        deflate(z,Z_NO_FLUSH);\n        byteswritten += fwrite(comp_buf,1,buf_size*sizeof(*comp_buf)-z->avail_out,\n            (FILE*)mat->fp);\n    } while ( z->avail_out == 0 );\n    /* Name of variable */\n    uncomp_buf[0] = array_name_type;\n    uncomp_buf[1] = 0;\n    z->next_in  = ZLIB_BYTE_PTR(uncomp_buf);\n    z->avail_in = 8;\n    do {\n        z->next_out  = ZLIB_BYTE_PTR(comp_buf);\n        z->avail_out = buf_size*sizeof(*comp_buf);\n        deflate(z,Z_NO_FLUSH);\n        byteswritten += fwrite(comp_buf,1,buf_size*sizeof(*comp_buf)-z->avail_out,\n            (FILE*)mat->fp);\n    } while ( z->avail_out == 0 );\n\n    matvar->internal->datapos = ftell((FILE*)mat->fp);\n    if ( matvar->internal->datapos == -1L ) {\n        Mat_Critical(\"Couldn't determine file position\");\n    }\n\n    byteswritten += WriteCompressedType(mat,matvar,z);\n    return byteswritten;\n}\n\n/** @brief Writes the header and data for a given class type\n *\n * @ingroup mat_internal\n * @param mat MAT file pointer\n * @param matvar pointer to the mat variable\n * @return number of bytes written to the MAT file\n */\nstatic size_t\nWriteCompressedType(mat_t *mat,matvar_t *matvar,z_streamp z)\n{\n    int err;\n    mat_uint32_t comp_buf[512];\n    mat_uint32_t uncomp_buf[512] = {0,};\n    size_t byteswritten = 0, nelems = 1;\n\n    if ( MAT_C_EMPTY == matvar->class_type ) {\n        /* exit early if this is an empty data */\n        return byteswritten;\n    }\n\n    err = SafeMulDims(matvar, &nelems);\n    if ( err ) {\n        Mat_Critical(\"Integer multiplication overflow\");\n        return byteswritten;\n    }\n\n    switch ( matvar->class_type ) {\n        case MAT_C_DOUBLE:\n        case MAT_C_SINGLE:\n        case MAT_C_INT64:\n        case MAT_C_UINT64:\n        case MAT_C_INT32:\n        case MAT_C_UINT32:\n        case MAT_C_INT16:\n        case MAT_C_UINT16:\n        case MAT_C_INT8:\n        case MAT_C_UINT8:\n        {\n            /* WriteCompressedData makes sure uncompressed data is aligned\n             * on an 8-byte boundary */\n            if ( matvar->isComplex ) {\n                mat_complex_split_t *complex_data = (mat_complex_split_t*)matvar->data;\n\n                if ( NULL == matvar->data )\n                    complex_data = &null_complex_data;\n\n                byteswritten += WriteCompressedData(mat,z,\n                    complex_data->Re,nelems,matvar->data_type);\n                byteswritten += WriteCompressedData(mat,z,\n                    complex_data->Im,nelems,matvar->data_type);\n            } else {\n                byteswritten += WriteCompressedData(mat,z,\n                    matvar->data,nelems,matvar->data_type);\n            }\n            break;\n        }\n        case MAT_C_CHAR:\n        {\n            byteswritten += WriteCompressedCharData(mat,z,matvar->data,\n                nelems,matvar->data_type);\n            break;\n        }\n        case MAT_C_CELL:\n        {\n            size_t i;\n            matvar_t **cells = (matvar_t **)matvar->data;\n\n            /* Check for an empty cell array */\n            if ( matvar->nbytes == 0 || matvar->data_size == 0 ||\n                 matvar->data   == NULL )\n                break;\n            nelems = matvar->nbytes / matvar->data_size;\n            for ( i = 0; i < nelems; i++ )\n                WriteCompressedCellArrayField(mat,cells[i],z);\n            break;\n        }\n        case MAT_C_STRUCT:\n        {\n            int buf_size = 512;\n            mat_int16_t fieldname_type = MAT_T_INT32;\n            mat_int16_t fieldname_data_size = 4;\n            unsigned char *padzero;\n            int fieldname_size;\n            size_t maxlen = 0, nfields, i, nelems_x_nfields;\n            mat_int32_t array_name_type = MAT_T_INT8;\n            matvar_t **fields = (matvar_t **)matvar->data;\n\n            nfields = matvar->internal->num_fields;\n            /* Check for a structure with no fields */\n            if ( nfields < 1 ) {\n                fieldname_size = 1;\n                uncomp_buf[0] = (fieldname_data_size << 16) | fieldname_type;\n                uncomp_buf[1] = fieldname_size;\n                uncomp_buf[2] = array_name_type;\n                uncomp_buf[3] = 0;\n                z->next_in  = ZLIB_BYTE_PTR(uncomp_buf);\n                z->avail_in = 16;\n                do {\n                    z->next_out  = ZLIB_BYTE_PTR(comp_buf);\n                    z->avail_out = buf_size*sizeof(*comp_buf);\n                    deflate(z,Z_NO_FLUSH);\n                    byteswritten += fwrite(comp_buf,1,buf_size*\n                        sizeof(*comp_buf)-z->avail_out,(FILE*)mat->fp);\n                } while ( z->avail_out == 0 );\n                break;\n            }\n\n            for ( i = 0; i < nfields; i++ ) {\n                size_t len = strlen(matvar->internal->fieldnames[i]);\n                if ( len > maxlen )\n                    maxlen = len;\n            }\n            maxlen++;\n            fieldname_size = maxlen;\n            while ( nfields*fieldname_size % 8 != 0 )\n                fieldname_size++;\n            uncomp_buf[0] = (fieldname_data_size << 16) | fieldname_type;\n            uncomp_buf[1] = fieldname_size;\n            uncomp_buf[2] = array_name_type;\n            uncomp_buf[3] = nfields*fieldname_size;\n\n            padzero = (unsigned char*)calloc(fieldname_size,1);\n            z->next_in  = ZLIB_BYTE_PTR(uncomp_buf);\n            z->avail_in = 16;\n            do {\n                z->next_out  = ZLIB_BYTE_PTR(comp_buf);\n                z->avail_out = buf_size*sizeof(*comp_buf);\n                deflate(z,Z_NO_FLUSH);\n                byteswritten += fwrite(comp_buf,1,\n                    buf_size*sizeof(*comp_buf)-z->avail_out,(FILE*)mat->fp);\n            } while ( z->avail_out == 0 );\n            for ( i = 0; i < nfields; i++ ) {\n                size_t len = strlen(matvar->internal->fieldnames[i]);\n                memset(padzero,'\\0',fieldname_size);\n                memcpy(padzero,matvar->internal->fieldnames[i],len);\n                z->next_in  = ZLIB_BYTE_PTR(padzero);\n                z->avail_in = fieldname_size;\n                do {\n                    z->next_out  = ZLIB_BYTE_PTR(comp_buf);\n                    z->avail_out = buf_size*sizeof(*comp_buf);\n                    deflate(z,Z_NO_FLUSH);\n                    byteswritten += fwrite(comp_buf,1,\n                        buf_size*sizeof(*comp_buf)-z->avail_out,(FILE*)mat->fp);\n                } while ( z->avail_out == 0 );\n            }\n            free(padzero);\n            err = SafeMul(&nelems_x_nfields, nelems, nfields);\n            if ( err ) {\n                Mat_Critical(\"Integer multiplication overflow\");\n                return byteswritten;\n            }\n            for ( i = 0; i < nelems_x_nfields; i++ )\n                byteswritten += WriteCompressedStructField(mat,fields[i],z);\n            break;\n        }\n        case MAT_C_SPARSE:\n        {\n            mat_sparse_t *sparse = (mat_sparse_t*)matvar->data;\n\n            byteswritten += WriteCompressedData(mat,z,sparse->ir,\n                sparse->nir,MAT_T_INT32);\n            byteswritten += WriteCompressedData(mat,z,sparse->jc,\n                sparse->njc,MAT_T_INT32);\n            if ( matvar->isComplex ) {\n                mat_complex_split_t *complex_data = (mat_complex_split_t*)sparse->data;\n                byteswritten += WriteCompressedData(mat,z,\n                    complex_data->Re,sparse->ndata,matvar->data_type);\n                byteswritten += WriteCompressedData(mat,z,\n                    complex_data->Im,sparse->ndata,matvar->data_type);\n            } else {\n                byteswritten += WriteCompressedData(mat,z,\n                    sparse->data,sparse->ndata,matvar->data_type);\n            }\n            break;\n        }\n        case MAT_C_FUNCTION:\n        case MAT_C_OBJECT:\n        case MAT_C_EMPTY:\n        case MAT_C_OPAQUE:\n            break;\n    }\n\n    return byteswritten;\n}\n\n/** @brief Writes the header and data for a field of a compressed cell array\n *\n * @ingroup mat_internal\n * @param mat MAT file pointer\n * @param matvar pointer to the mat variable\n * @return number of bytes written to the MAT file\n */\nstatic size_t\nWriteCompressedCellArrayField(mat_t *mat,matvar_t *matvar,z_streamp z)\n{\n    mat_uint32_t comp_buf[512];\n    mat_uint32_t uncomp_buf[512] = {0,};\n    int buf_size = 512;\n    size_t byteswritten = 0, field_buf_size;\n\n    if ( NULL == matvar || NULL == mat || NULL == z)\n        return 0;\n\n    uncomp_buf[0] = MAT_T_MATRIX;\n    if ( MAT_C_EMPTY != matvar->class_type ) {\n        int err = GetCellArrayFieldBufSize(matvar, &field_buf_size);\n        if (err || field_buf_size > UINT32_MAX)\n            return 0;\n\n        uncomp_buf[1] = field_buf_size;\n    } else {\n        uncomp_buf[1] = 0;\n    }\n    z->next_in  = ZLIB_BYTE_PTR(uncomp_buf);\n    z->avail_in = 8;\n    do {\n        z->next_out  = ZLIB_BYTE_PTR(comp_buf);\n        z->avail_out = buf_size*sizeof(*comp_buf);\n        deflate(z,Z_NO_FLUSH);\n        byteswritten += fwrite(comp_buf,1,buf_size*sizeof(*comp_buf)-z->avail_out,\n            (FILE*)mat->fp);\n    } while ( z->avail_out == 0 );\n\n    byteswritten += WriteCompressedTypeArrayFlags(mat,matvar,z);\n    return byteswritten;\n}\n#endif\n\n/** @brief Writes the header and data for a field of a struct array\n *\n * @ingroup mat_internal\n * @param mat MAT file pointer\n * @param matvar pointer to the mat variable\n * @retval 0 on success\n */\nstatic int\nWriteStructField(mat_t *mat,matvar_t *matvar)\n{\n    mat_uint32_t array_flags;\n    mat_int32_t  array_name_type = MAT_T_INT8;\n    int array_flags_type = MAT_T_UINT32, dims_array_type = MAT_T_INT32;\n    int array_flags_size = 8, pad4 = 0, matrix_type = MAT_T_MATRIX;\n    int nBytes, i, nzmax = 0;\n    long start = 0, end = 0;\n\n    if ( mat == NULL )\n        return 1;\n\n    if ( NULL == matvar ) {\n        size_t dims[2] = {0,0};\n        Mat_WriteEmptyVariable5(mat, NULL, 2, dims);\n        return 0;\n    }\n\n    fwrite(&matrix_type,4,1,(FILE*)mat->fp);\n    fwrite(&pad4,4,1,(FILE*)mat->fp);\n    if ( MAT_C_EMPTY == matvar->class_type ) {\n        /* exit early if this is an empty data */\n        return 0;\n    }\n    start = ftell((FILE*)mat->fp);\n\n    /* Array Flags */\n    array_flags = matvar->class_type & CLASS_TYPE_MASK;\n    if ( matvar->isComplex )\n        array_flags |= MAT_F_COMPLEX;\n    if ( matvar->isGlobal )\n        array_flags |= MAT_F_GLOBAL;\n    if ( matvar->isLogical )\n        array_flags |= MAT_F_LOGICAL;\n    if ( matvar->class_type == MAT_C_SPARSE )\n        nzmax = ((mat_sparse_t *)matvar->data)->nzmax;\n\n    if ( mat->byteswap )\n        array_flags = Mat_int32Swap((mat_int32_t*)&array_flags);\n    fwrite(&array_flags_type,4,1,(FILE*)mat->fp);\n    fwrite(&array_flags_size,4,1,(FILE*)mat->fp);\n    fwrite(&array_flags,4,1,(FILE*)mat->fp);\n    fwrite(&nzmax,4,1,(FILE*)mat->fp);\n    /* Rank and Dimension */\n    nBytes = matvar->rank * 4;\n    fwrite(&dims_array_type,4,1,(FILE*)mat->fp);\n    fwrite(&nBytes,4,1,(FILE*)mat->fp);\n    for ( i = 0; i < matvar->rank; i++ ) {\n        mat_int32_t dim;\n        dim = matvar->dims[i];\n        fwrite(&dim,4,1,(FILE*)mat->fp);\n    }\n    if ( matvar->rank % 2 != 0 )\n        fwrite(&pad4,4,1,(FILE*)mat->fp);\n\n    /* Name of variable */\n    fwrite(&array_name_type,4,1,(FILE*)mat->fp);\n    fwrite(&pad4,4,1,(FILE*)mat->fp);\n\n    WriteType(mat,matvar);\n    end = ftell((FILE*)mat->fp);\n    if ( start != -1L && end != -1L ) {\n        nBytes = (int)(end-start);\n        (void)fseek((FILE*)mat->fp,(long)-(nBytes+4),SEEK_CUR);\n        fwrite(&nBytes,4,1,(FILE*)mat->fp);\n        (void)fseek((FILE*)mat->fp,end,SEEK_SET);\n    } else {\n        Mat_Critical(\"Couldn't determine file position\");\n    }\n\n    return 0;\n}\n\n#if defined(HAVE_ZLIB)\n/** @brief Writes the header and data for a field of a compressed struct array\n *\n * @ingroup mat_internal\n * @fixme Currently does not work for cell arrays or sparse data\n * @param mat MAT file pointer\n * @param matvar pointer to the mat variable\n * @return number of bytes written to the MAT file\n */\nstatic size_t\nWriteCompressedStructField(mat_t *mat,matvar_t *matvar,z_streamp z)\n{\n    mat_uint32_t comp_buf[512];\n    mat_uint32_t uncomp_buf[512] = {0,};\n    int buf_size = 512;\n    size_t byteswritten = 0, field_buf_size;\n\n    if ( NULL == mat || NULL == z)\n        return 0;\n\n    if ( NULL == matvar ) {\n        size_t dims[2] = {0,0};\n        byteswritten = Mat_WriteCompressedEmptyVariable5(mat, NULL, 2, dims, z);\n        return byteswritten;\n    }\n\n    uncomp_buf[0] = MAT_T_MATRIX;\n    if ( MAT_C_EMPTY != matvar->class_type ) {\n        int err = GetStructFieldBufSize(matvar, &field_buf_size);\n        if (err || field_buf_size > UINT32_MAX)\n            return 0;\n        uncomp_buf[1] = field_buf_size;\n    } else {\n        uncomp_buf[1] = 0;\n    }\n    z->next_in  = ZLIB_BYTE_PTR(uncomp_buf);\n    z->avail_in = 8;\n    do {\n        z->next_out  = ZLIB_BYTE_PTR(comp_buf);\n        z->avail_out = buf_size*sizeof(*comp_buf);\n        deflate(z,Z_NO_FLUSH);\n        byteswritten += fwrite(comp_buf,1,buf_size*sizeof(*comp_buf)-z->avail_out,\n            (FILE*)mat->fp);\n    } while ( z->avail_out == 0 );\n\n    byteswritten += WriteCompressedTypeArrayFlags(mat,matvar,z);\n    return byteswritten;\n}\n#endif\n\nstatic size_t\nMat_WriteEmptyVariable5(mat_t *mat,const char *name,int rank,size_t *dims)\n{\n    mat_uint32_t array_flags;\n    mat_int32_t  array_name_type = MAT_T_INT8, matrix_type = MAT_T_MATRIX;\n    int array_flags_type = MAT_T_UINT32, dims_array_type = MAT_T_INT32;\n    int array_flags_size = 8, pad4 = 0, nBytes, i;\n    const mat_int8_t pad1 = 0;\n    size_t byteswritten = 0;\n    long start = 0, end = 0;\n\n    fwrite(&matrix_type,4,1,(FILE*)mat->fp);\n    fwrite(&pad4,4,1,(FILE*)mat->fp);\n    start = ftell((FILE*)mat->fp);\n\n    /* Array Flags */\n    array_flags = MAT_C_DOUBLE;\n\n    if ( mat->byteswap )\n        array_flags = Mat_int32Swap((mat_int32_t*)&array_flags);\n    byteswritten += fwrite(&array_flags_type,4,1,(FILE*)mat->fp);\n    byteswritten += fwrite(&array_flags_size,4,1,(FILE*)mat->fp);\n    byteswritten += fwrite(&array_flags,4,1,(FILE*)mat->fp);\n    byteswritten += fwrite(&pad4,4,1,(FILE*)mat->fp);\n    /* Rank and Dimension */\n    nBytes = rank * 4;\n    byteswritten += fwrite(&dims_array_type,4,1,(FILE*)mat->fp);\n    byteswritten += fwrite(&nBytes,4,1,(FILE*)mat->fp);\n    for ( i = 0; i < rank; i++ ) {\n        mat_int32_t dim;\n        dim = dims[i];\n        byteswritten += fwrite(&dim,4,1,(FILE*)mat->fp);\n    }\n    if ( rank % 2 != 0 )\n        byteswritten += fwrite(&pad4,4,1,(FILE*)mat->fp);\n\n    if ( NULL == name ) {\n        /* Name of variable */\n        byteswritten += fwrite(&array_name_type,4,1,(FILE*)mat->fp);\n        byteswritten += fwrite(&pad4,4,1,(FILE*)mat->fp);\n    } else {\n        mat_int32_t array_name_len = (mat_int32_t)strlen(name);\n        /* Name of variable */\n        if ( array_name_len <= 4 ) {\n            array_name_type = (array_name_len << 16) | array_name_type;\n            byteswritten += fwrite(&array_name_type,4,1,(FILE*)mat->fp);\n            byteswritten += fwrite(name,1,array_name_len,(FILE*)mat->fp);\n            for ( i = array_name_len; i < 4; i++ )\n                byteswritten += fwrite(&pad1,1,1,(FILE*)mat->fp);\n        } else {\n            byteswritten += fwrite(&array_name_type,4,1,(FILE*)mat->fp);\n            byteswritten += fwrite(&array_name_len,4,1,(FILE*)mat->fp);\n            byteswritten += fwrite(name,1,array_name_len,(FILE*)mat->fp);\n            if ( array_name_len % 8 )\n                for ( i = array_name_len % 8; i < 8; i++ )\n                    byteswritten += fwrite(&pad1,1,1,(FILE*)mat->fp);\n        }\n    }\n\n    nBytes = WriteData(mat,NULL,0,MAT_T_DOUBLE);\n    byteswritten += nBytes;\n    if ( nBytes % 8 )\n        for ( i = nBytes % 8; i < 8; i++ )\n            byteswritten += fwrite(&pad1,1,1,(FILE*)mat->fp);\n\n    end = ftell((FILE*)mat->fp);\n    if ( start != -1L && end != -1L ) {\n        nBytes = (int)(end-start);\n        (void)fseek((FILE*)mat->fp,(long)-(nBytes+4),SEEK_CUR);\n        fwrite(&nBytes,4,1,(FILE*)mat->fp);\n        (void)fseek((FILE*)mat->fp,end,SEEK_SET);\n    } else {\n        Mat_Critical(\"Couldn't determine file position\");\n    }\n\n    return byteswritten;\n}\n\n#if defined(HAVE_ZLIB)\nstatic size_t\nMat_WriteCompressedEmptyVariable5(mat_t *mat,const char *name,int rank,\n                                  size_t *dims,z_streamp z)\n{\n    mat_uint32_t array_flags;\n    int array_flags_type = MAT_T_UINT32, dims_array_type = MAT_T_INT32;\n    int array_flags_size = 8;\n    int i, err;\n    size_t nBytes, empty_matrix_max_buf_size;\n\n    mat_uint32_t comp_buf[512];\n    mat_uint32_t uncomp_buf[512] = {0,};\n    int buf_size = 512;\n    size_t byteswritten = 0, buf_size_bytes;\n\n    if ( NULL == mat || NULL == z)\n        return byteswritten;\n\n    buf_size_bytes = buf_size*sizeof(*comp_buf);\n\n    /* Array Flags */\n    array_flags = MAT_C_DOUBLE;\n\n    uncomp_buf[0] = MAT_T_MATRIX;\n    err = GetEmptyMatrixMaxBufSize(name, rank, &empty_matrix_max_buf_size);\n    if (err || empty_matrix_max_buf_size > UINT32_MAX)\n        return byteswritten;\n    uncomp_buf[1] = empty_matrix_max_buf_size;\n    z->next_in  = ZLIB_BYTE_PTR(uncomp_buf);\n    z->avail_in = 8;\n    do {\n        z->next_out  = ZLIB_BYTE_PTR(comp_buf);\n        z->avail_out = buf_size_bytes;\n        deflate(z,Z_NO_FLUSH);\n        byteswritten += fwrite(comp_buf,1,buf_size_bytes-z->avail_out,(FILE*)mat->fp);\n    } while ( z->avail_out == 0 );\n    uncomp_buf[0] = array_flags_type;\n    uncomp_buf[1] = array_flags_size;\n    uncomp_buf[2] = array_flags;\n    uncomp_buf[3] = 0;\n    /* Rank and Dimension */\n    nBytes = rank * 4;\n    uncomp_buf[4] = dims_array_type;\n    uncomp_buf[5] = nBytes;\n    for ( i = 0; i < rank; i++ ) {\n        mat_int32_t dim;\n        dim = dims[i];\n        uncomp_buf[6+i] = dim;\n    }\n    if ( rank % 2 != 0 ) {\n        int pad4 = 0;\n        uncomp_buf[6+i] = pad4;\n        i++;\n    }\n\n    z->next_in  = ZLIB_BYTE_PTR(uncomp_buf);\n    z->avail_in = (6+i)*sizeof(*uncomp_buf);\n    do {\n        z->next_out  = ZLIB_BYTE_PTR(comp_buf);\n        z->avail_out = buf_size_bytes;\n        deflate(z,Z_NO_FLUSH);\n        byteswritten += fwrite(comp_buf,1,buf_size_bytes-z->avail_out,(FILE*)mat->fp);\n    } while ( z->avail_out == 0 );\n    /* Name of variable */\n    if ( NULL == name ) {\n        mat_int16_t array_name_type = MAT_T_INT8;\n        uncomp_buf[0] = array_name_type;\n        uncomp_buf[1] = 0;\n        z->next_in  = ZLIB_BYTE_PTR(uncomp_buf);\n        z->avail_in = 8;\n        do {\n            z->next_out  = ZLIB_BYTE_PTR(comp_buf);\n            z->avail_out = buf_size_bytes;\n            deflate(z,Z_NO_FLUSH);\n            byteswritten += fwrite(comp_buf,1,buf_size_bytes-z->avail_out,(FILE*)mat->fp);\n        } while ( z->avail_out == 0 );\n    } else if ( strlen(name) <= 4 ) {\n        mat_int16_t array_name_len = (mat_int16_t)strlen(name);\n        mat_int16_t array_name_type = MAT_T_INT8;\n\n        memset(uncomp_buf,0,8);\n        uncomp_buf[0] = (array_name_len << 16) | array_name_type;\n        memcpy(uncomp_buf+1,name,array_name_len);\n        if ( array_name_len % 4 )\n            array_name_len += 4-(array_name_len % 4);\n\n        z->next_in  = ZLIB_BYTE_PTR(uncomp_buf);\n        z->avail_in = 8;\n        do {\n            z->next_out  = ZLIB_BYTE_PTR(comp_buf);\n            z->avail_out = buf_size_bytes;\n            deflate(z,Z_NO_FLUSH);\n            byteswritten += fwrite(comp_buf,1,buf_size_bytes-z->avail_out,\n                (FILE*)mat->fp);\n        } while ( z->avail_out == 0 );\n    } else {\n        mat_int32_t array_name_len = (mat_int32_t)strlen(name);\n        mat_int32_t array_name_type = MAT_T_INT8;\n\n        memset(uncomp_buf,0,buf_size*sizeof(*uncomp_buf));\n        uncomp_buf[0] = array_name_type;\n        uncomp_buf[1] = array_name_len;\n        memcpy(uncomp_buf+2,name,array_name_len);\n        if ( array_name_len % 8 )\n            array_name_len += 8-(array_name_len % 8);\n        z->next_in  = ZLIB_BYTE_PTR(uncomp_buf);\n        z->avail_in = 8+array_name_len;\n        do {\n            z->next_out  = ZLIB_BYTE_PTR(comp_buf);\n            z->avail_out = buf_size_bytes;\n            deflate(z,Z_NO_FLUSH);\n            byteswritten += fwrite(comp_buf,1,buf_size_bytes-z->avail_out,\n                (FILE*)mat->fp);\n        } while ( z->avail_out == 0 );\n    }\n\n    byteswritten += WriteCompressedData(mat,z,NULL,0,MAT_T_DOUBLE);\n    return byteswritten;\n}\n#endif\n\n/** @if mat_devman\n * @brief Reads a data element including tag and data\n *\n * @ingroup mat_internal\n * @param mat MAT file pointer\n * @param matvar MAT variable pointer\n * @param data Pointer to store the data\n * @param N number of data elements allocated for the pointer\n * @endif\n */\nstatic void\nMat_VarReadNumeric5(mat_t *mat,matvar_t *matvar,void *data,size_t N)\n{\n    int nBytes = 0, data_in_tag = 0;\n    enum matio_types packed_type = MAT_T_UNKNOWN;\n    mat_uint32_t tag[2];\n\n    if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {\n#if defined(HAVE_ZLIB)\n        matvar->internal->z->avail_in = 0;\n        InflateDataType(mat,matvar->internal->z,tag);\n        if ( mat->byteswap )\n            (void)Mat_uint32Swap(tag);\n\n        packed_type = TYPE_FROM_TAG(tag[0]);\n        if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */\n            data_in_tag = 1;\n            nBytes = (tag[0] & 0xffff0000) >> 16;\n        } else {\n            data_in_tag = 0;\n            InflateDataType(mat,matvar->internal->z,tag+1);\n            if ( mat->byteswap )\n                (void)Mat_uint32Swap(tag+1);\n            nBytes = tag[1];\n        }\n#endif\n    } else {\n        size_t bytesread = fread(tag,4,1,(FILE*)mat->fp);\n        if ( mat->byteswap )\n            (void)Mat_uint32Swap(tag);\n        packed_type = TYPE_FROM_TAG(tag[0]);\n        if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */\n            data_in_tag = 1;\n            nBytes = (tag[0] & 0xffff0000) >> 16;\n        } else {\n            data_in_tag = 0;\n            bytesread += fread(tag+1,4,1,(FILE*)mat->fp);\n            if ( mat->byteswap )\n                (void)Mat_uint32Swap(tag+1);\n            nBytes = tag[1];\n        }\n    }\n    if ( nBytes == 0 ) {\n        matvar->nbytes = 0;\n        return;\n    }\n\n    if ( matvar->compression == MAT_COMPRESSION_NONE ) {\n        switch ( matvar->class_type ) {\n            case MAT_C_DOUBLE:\n                nBytes = ReadDoubleData(mat,(double*)data,packed_type,N);\n                break;\n            case MAT_C_SINGLE:\n                nBytes = ReadSingleData(mat,(float*)data,packed_type,N);\n                break;\n            case MAT_C_INT64:\n#ifdef HAVE_MAT_INT64_T\n                nBytes = ReadInt64Data(mat,(mat_int64_t*)data,packed_type,N);\n#endif\n                break;\n            case MAT_C_UINT64:\n#ifdef HAVE_MAT_UINT64_T\n                nBytes = ReadUInt64Data(mat,(mat_uint64_t*)data,packed_type,N);\n#endif\n                break;\n            case MAT_C_INT32:\n                nBytes = ReadInt32Data(mat,(mat_int32_t*)data,packed_type,N);\n                break;\n            case MAT_C_UINT32:\n                nBytes = ReadUInt32Data(mat,(mat_uint32_t*)data,packed_type,N);\n                break;\n            case MAT_C_INT16:\n                nBytes = ReadInt16Data(mat,(mat_int16_t*)data,packed_type,N);\n                break;\n            case MAT_C_UINT16:\n                nBytes = ReadUInt16Data(mat,(mat_uint16_t*)data,packed_type,N);\n                break;\n            case MAT_C_INT8:\n                nBytes = ReadInt8Data(mat,(mat_int8_t*)data,packed_type,N);\n                break;\n            case MAT_C_UINT8:\n                nBytes = ReadUInt8Data(mat,(mat_uint8_t*)data,packed_type,N);\n                break;\n            default:\n                break;\n        }\n        /*\n         * If the data was in the tag we started on a 4-byte\n         * boundary so add 4 to make it an 8-byte\n         */\n        if ( data_in_tag )\n            nBytes+=4;\n        if ( (nBytes % 8) != 0 )\n            (void)fseek((FILE*)mat->fp,8-(nBytes % 8),SEEK_CUR);\n#if defined(HAVE_ZLIB)\n    } else if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {\n        switch ( matvar->class_type ) {\n            case MAT_C_DOUBLE:\n                nBytes = ReadCompressedDoubleData(mat,matvar->internal->z,(double*)data,\n                                                  packed_type,N);\n                break;\n            case MAT_C_SINGLE:\n                nBytes = ReadCompressedSingleData(mat,matvar->internal->z,(float*)data,\n                                                  packed_type,N);\n                break;\n            case MAT_C_INT64:\n#ifdef HAVE_MAT_INT64_T\n                nBytes = ReadCompressedInt64Data(mat,matvar->internal->z,(mat_int64_t*)data,\n                                                 packed_type,N);\n#endif\n                break;\n            case MAT_C_UINT64:\n#ifdef HAVE_MAT_UINT64_T\n                nBytes = ReadCompressedUInt64Data(mat,matvar->internal->z,(mat_uint64_t*)data,\n                                                  packed_type,N);\n#endif\n                break;\n            case MAT_C_INT32:\n                nBytes = ReadCompressedInt32Data(mat,matvar->internal->z,(mat_int32_t*)data,\n                                                 packed_type,N);\n                break;\n            case MAT_C_UINT32:\n                nBytes = ReadCompressedUInt32Data(mat,matvar->internal->z,(mat_uint32_t*)data,\n                                                  packed_type,N);\n                break;\n            case MAT_C_INT16:\n                nBytes = ReadCompressedInt16Data(mat,matvar->internal->z,(mat_int16_t*)data,\n                                                 packed_type,N);\n                break;\n            case MAT_C_UINT16:\n                nBytes = ReadCompressedUInt16Data(mat,matvar->internal->z,(mat_uint16_t*)data,\n                                                  packed_type,N);\n                break;\n            case MAT_C_INT8:\n                nBytes = ReadCompressedInt8Data(mat,matvar->internal->z,(mat_int8_t*)data,\n                                                packed_type,N);\n                break;\n            case MAT_C_UINT8:\n                nBytes = ReadCompressedUInt8Data(mat,matvar->internal->z,(mat_uint8_t*)data,\n                                                 packed_type,N);\n                break;\n            default:\n                break;\n        }\n        /*\n         * If the data was in the tag we started on a 4-byte\n         * boundary so add 4 to make it an 8-byte\n         */\n        if ( data_in_tag )\n            nBytes+=4;\n        if ( (nBytes % 8) != 0 )\n            InflateSkip(mat,matvar->internal->z,8-(nBytes % 8));\n#endif\n    }\n}\n\n/** @if mat_devman\n * @brief Reads the data of a version 5 MAT variable\n *\n * @ingroup mat_internal\n * @param mat MAT file pointer\n * @param matvar MAT variable pointer to read the data\n * @endif\n */\nvoid\nMat_VarRead5(mat_t *mat, matvar_t *matvar)\n{\n    int nBytes = 0, byteswap, data_in_tag = 0, err;\n    size_t nelems = 1;\n    enum matio_types packed_type = MAT_T_UNKNOWN;\n    long fpos;\n    mat_uint32_t tag[2];\n    size_t bytesread = 0;\n\n    if ( matvar == NULL )\n        return;\n    else if ( matvar->rank == 0 )        /* An empty data set */\n        return;\n#if defined(HAVE_ZLIB)\n    else if ( NULL != matvar->internal->data ) {\n        /* Data already read in ReadNextStructField or ReadNextCell */\n        matvar->data = matvar->internal->data;\n        matvar->internal->data = NULL;\n        return;\n    }\n#endif\n    fpos = ftell((FILE*)mat->fp);\n    if ( fpos == -1L ) {\n        Mat_Critical(\"Couldn't determine file position\");\n        return;\n    }\n    err = SafeMulDims(matvar, &nelems);\n    if ( err ) {\n        Mat_Critical(\"Integer multiplication overflow\");\n        return;\n    }\n    byteswap = mat->byteswap;\n    switch ( matvar->class_type ) {\n        case MAT_C_EMPTY:\n            matvar->nbytes = 0;\n            matvar->data_size = sizeof(double);\n            matvar->data_type = MAT_T_DOUBLE;\n            matvar->rank = 2;\n            matvar->dims = (size_t*)malloc(matvar->rank*sizeof(*(matvar->dims)));\n            matvar->dims[0] = 0;\n            matvar->dims[1] = 0;\n            break;\n        case MAT_C_DOUBLE:\n            (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);\n            matvar->data_size = sizeof(double);\n            matvar->data_type = MAT_T_DOUBLE;\n            break;\n        case MAT_C_SINGLE:\n            (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);\n            matvar->data_size = sizeof(float);\n            matvar->data_type = MAT_T_SINGLE;\n            break;\n        case MAT_C_INT64:\n#ifdef HAVE_MAT_INT64_T\n            (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);\n            matvar->data_size = sizeof(mat_int64_t);\n            matvar->data_type = MAT_T_INT64;\n#endif\n            break;\n        case MAT_C_UINT64:\n#ifdef HAVE_MAT_UINT64_T\n            (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);\n            matvar->data_size = sizeof(mat_uint64_t);\n            matvar->data_type = MAT_T_UINT64;\n#endif\n            break;\n        case MAT_C_INT32:\n            (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);\n            matvar->data_size = sizeof(mat_int32_t);\n            matvar->data_type = MAT_T_INT32;\n            break;\n        case MAT_C_UINT32:\n            (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);\n            matvar->data_size = sizeof(mat_uint32_t);\n            matvar->data_type = MAT_T_UINT32;\n            break;\n        case MAT_C_INT16:\n            (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);\n            matvar->data_size = sizeof(mat_int16_t);\n            matvar->data_type = MAT_T_INT16;\n            break;\n        case MAT_C_UINT16:\n            (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);\n            matvar->data_size = sizeof(mat_uint16_t);\n            matvar->data_type = MAT_T_UINT16;\n            break;\n        case MAT_C_INT8:\n            (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);\n            matvar->data_size = sizeof(mat_int8_t);\n            matvar->data_type = MAT_T_INT8;\n            break;\n        case MAT_C_UINT8:\n            (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);\n            matvar->data_size = sizeof(mat_uint8_t);\n            matvar->data_type = MAT_T_UINT8;\n            break;\n        case MAT_C_CHAR:\n            (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);\n            if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {\n#if defined(HAVE_ZLIB)\n                matvar->internal->z->avail_in = 0;\n                InflateDataType(mat,matvar->internal->z,tag);\n                if ( byteswap )\n                    (void)Mat_uint32Swap(tag);\n                packed_type = TYPE_FROM_TAG(tag[0]);\n                if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */\n                    data_in_tag = 1;\n                    nBytes = (tag[0] & 0xffff0000) >> 16;\n                } else {\n                    data_in_tag = 0;\n                    InflateDataType(mat,matvar->internal->z,tag+1);\n                    if ( byteswap )\n                        (void)Mat_uint32Swap(tag+1);\n                    nBytes = tag[1];\n                }\n#endif\n                matvar->data_type = packed_type;\n                matvar->data_size = Mat_SizeOf(matvar->data_type);\n                matvar->nbytes = nBytes;\n            } else {\n                bytesread += fread(tag,4,1,(FILE*)mat->fp);\n                if ( byteswap )\n                    (void)Mat_uint32Swap(tag);\n                packed_type = TYPE_FROM_TAG(tag[0]);\n                if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */\n                    data_in_tag = 1;\n                    /* nBytes = (tag[0] & 0xffff0000) >> 16; */\n                } else {\n                    data_in_tag = 0;\n                    bytesread += fread(tag+1,4,1,(FILE*)mat->fp);\n                    if ( byteswap )\n                        (void)Mat_uint32Swap(tag+1);\n                    /* nBytes = tag[1]; */\n                }\n                matvar->data_type = MAT_T_UINT8;\n                matvar->data_size = Mat_SizeOf(MAT_T_UINT8);\n                err = SafeMul(&matvar->nbytes, nelems, matvar->data_size);\n                if ( err ) {\n                    Mat_Critical(\"Integer multiplication overflow\");\n                    break;\n                }\n            }\n            if ( matvar->isComplex ) {\n                break;\n            }\n            matvar->data = calloc(matvar->nbytes+1,1);\n            if ( NULL == matvar->data ) {\n                Mat_Critical(\"Couldn't allocate memory for the data\");\n                break;\n            }\n            if ( 0 == matvar->nbytes ) {\n                break;\n            }\n            {\n                size_t nbytes;\n                err = SafeMul(&nbytes, nelems, matvar->data_size);\n                if ( err || nbytes > matvar->nbytes ) {\n                    break;\n                }\n            }\n            if ( matvar->compression == MAT_COMPRESSION_NONE ) {\n                nBytes = ReadCharData(mat,(char*)matvar->data,packed_type,(int)nelems);\n                /*\n                 * If the data was in the tag we started on a 4-byte\n                 * boundary so add 4 to make it an 8-byte\n                 */\n                if ( data_in_tag )\n                    nBytes+=4;\n                if ( (nBytes % 8) != 0 )\n                    (void)fseek((FILE*)mat->fp,8-(nBytes % 8),SEEK_CUR);\n#if defined(HAVE_ZLIB)\n            } else if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {\n                nBytes = ReadCompressedCharData(mat,matvar->internal->z,\n                             (char*)matvar->data,packed_type,(int)nelems);\n                /*\n                 * If the data was in the tag we started on a 4-byte\n                 * boundary so add 4 to make it an 8-byte\n                 */\n                if ( data_in_tag )\n                    nBytes+=4;\n                if ( (nBytes % 8) != 0 )\n                    InflateSkip(mat,matvar->internal->z,8-(nBytes % 8));\n#endif\n            }\n            break;\n        case MAT_C_STRUCT:\n        {\n            matvar_t **fields;\n            size_t i, nelems_x_nfields;\n\n            matvar->data_type = MAT_T_STRUCT;\n            err = SafeMul(&nelems_x_nfields, nelems, matvar->internal->num_fields);\n            if ( err || !matvar->nbytes || !matvar->data_size || NULL == matvar->data )\n                break;\n            fields = (matvar_t **)matvar->data;\n            for ( i = 0; i < nelems_x_nfields; i++ ) {\n                if ( NULL != fields[i] ) {\n                    Mat_VarRead5(mat,fields[i]);\n                }\n            }\n            break;\n        }\n        case MAT_C_CELL:\n        {\n            matvar_t **cells;\n            size_t i;\n\n            if ( NULL == matvar->data ) {\n                Mat_Critical(\"Data is NULL for cell array %s\",matvar->name);\n                break;\n            }\n            cells = (matvar_t **)matvar->data;\n            for ( i = 0; i < nelems; i++ ) {\n                if ( NULL != cells[i] ) {\n                    Mat_VarRead5(mat, cells[i]);\n                }\n            }\n            /* FIXME: */\n            matvar->data_type = MAT_T_CELL;\n            break;\n        }\n        case MAT_C_SPARSE:\n        {\n            mat_int32_t N = 0;\n            mat_sparse_t *data;\n\n            matvar->data_size = sizeof(mat_sparse_t);\n            matvar->data      = malloc(matvar->data_size);\n            if ( matvar->data == NULL ) {\n                Mat_Critical(\"Mat_VarRead5: Allocation of data pointer failed\");\n                break;\n            }\n            data = (mat_sparse_t*)matvar->data;\n            data->nzmax  = matvar->nbytes;\n            (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);\n            /*  Read ir    */\n            bytesread += ReadSparse(mat, matvar, &data->nir, &data->ir);\n            /*  Read jc    */\n            bytesread += ReadSparse(mat, matvar, &data->njc, &data->jc);\n            /*  Read data  */\n            if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {\n#if defined(HAVE_ZLIB)\n                matvar->internal->z->avail_in = 0;\n                InflateDataType(mat,matvar->internal->z,tag);\n                if ( mat->byteswap )\n                    (void)Mat_uint32Swap(tag);\n                packed_type = TYPE_FROM_TAG(tag[0]);\n                if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */\n                    data_in_tag = 1;\n                    N = (tag[0] & 0xffff0000) >> 16;\n                } else {\n                    data_in_tag = 0;\n                    (void)ReadCompressedInt32Data(mat,matvar->internal->z,\n                             (mat_int32_t*)&N,MAT_T_INT32,1);\n                }\n#endif\n            } else {\n                bytesread += fread(tag,4,1,(FILE*)mat->fp);\n                if ( mat->byteswap )\n                    (void)Mat_uint32Swap(tag);\n                packed_type = TYPE_FROM_TAG(tag[0]);\n                if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */\n                    data_in_tag = 1;\n                    N = (tag[0] & 0xffff0000) >> 16;\n                } else {\n                    data_in_tag = 0;\n                    bytesread += fread(&N,4,1,(FILE*)mat->fp);\n                    if ( mat->byteswap )\n                        (void)Mat_int32Swap(&N);\n                }\n            }\n            if ( matvar->isLogical && packed_type == MAT_T_DOUBLE ) {\n                /* For some reason, MAT says the data type is a double,\n                 * but it appears to be written as 8-bit unsigned integer.\n                 */\n                packed_type = MAT_T_UINT8;\n            }\n#if defined(EXTENDED_SPARSE)\n            matvar->data_type = packed_type;\n#else\n            matvar->data_type = MAT_T_DOUBLE;\n#endif\n            {\n                size_t s_type = Mat_SizeOf(packed_type);\n                if ( s_type == 0 )\n                    break;\n                data->ndata = N / s_type;\n            }\n            if ( matvar->isComplex ) {\n                mat_complex_split_t *complex_data =\n                    ComplexMalloc(data->ndata*Mat_SizeOf(matvar->data_type));\n                if ( NULL == complex_data ) {\n                    Mat_Critical(\"Couldn't allocate memory for the complex sparse data\");\n                    break;\n                }\n                if ( matvar->compression == MAT_COMPRESSION_NONE ) {\n#if defined(EXTENDED_SPARSE)\n                    switch ( matvar->data_type ) {\n                        case MAT_T_DOUBLE:\n                            nBytes = ReadDoubleData(mat,(double*)complex_data->Re,\n                                packed_type,data->ndata);\n                            break;\n                        case MAT_T_SINGLE:\n                            nBytes = ReadSingleData(mat,(float*)complex_data->Re,\n                                packed_type,data->ndata);\n                            break;\n                        case MAT_T_INT64:\n#ifdef HAVE_MAT_INT64_T\n                            nBytes = ReadInt64Data(mat,(mat_int64_t*)complex_data->Re,\n                                packed_type,data->ndata);\n#endif\n                            break;\n                        case MAT_T_UINT64:\n#ifdef HAVE_MAT_UINT64_T\n                            nBytes = ReadUInt64Data(mat,(mat_uint64_t*)complex_data->Re,\n                                packed_type,data->ndata);\n#endif\n                            break;\n                        case MAT_T_INT32:\n                            nBytes = ReadInt32Data(mat,(mat_int32_t*)complex_data->Re,\n                                packed_type,data->ndata);\n                            break;\n                        case MAT_T_UINT32:\n                            nBytes = ReadUInt32Data(mat,(mat_uint32_t*)complex_data->Re,\n                                packed_type,data->ndata);\n                            break;\n                        case MAT_T_INT16:\n                            nBytes = ReadInt16Data(mat,(mat_int16_t*)complex_data->Re,\n                                packed_type,data->ndata);\n                            break;\n                        case MAT_T_UINT16:\n                            nBytes = ReadUInt16Data(mat,(mat_uint16_t*)complex_data->Re,\n                                packed_type,data->ndata);\n                            break;\n                        case MAT_T_INT8:\n                            nBytes = ReadInt8Data(mat,(mat_int8_t*)complex_data->Re,\n                                packed_type,data->ndata);\n                            break;\n                        case MAT_T_UINT8:\n                            nBytes = ReadUInt8Data(mat,(mat_uint8_t*)complex_data->Re,\n                                packed_type,data->ndata);\n                            break;\n                        default:\n                            break;\n                    }\n#else\n                    nBytes = ReadDoubleData(mat,(double*)complex_data->Re,\n                                 packed_type,data->ndata);\n#endif\n                    if ( data_in_tag )\n                        nBytes+=4;\n                    if ( (nBytes % 8) != 0 )\n                        (void)fseek((FILE*)mat->fp,8-(nBytes % 8),SEEK_CUR);\n\n                    /* Complex Data Tag */\n                    bytesread += fread(tag,4,1,(FILE*)mat->fp);\n                    if ( byteswap )\n                        (void)Mat_uint32Swap(tag);\n                    packed_type = TYPE_FROM_TAG(tag[0]);\n                    if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */\n                        data_in_tag = 1;\n                        nBytes = (tag[0] & 0xffff0000) >> 16;\n                    } else {\n                        data_in_tag = 0;\n                        bytesread += fread(tag+1,4,1,(FILE*)mat->fp);\n                        if ( byteswap )\n                            (void)Mat_uint32Swap(tag+1);\n                        nBytes = tag[1];\n                    }\n#if defined(EXTENDED_SPARSE)\n                    switch ( matvar->data_type ) {\n                        case MAT_T_DOUBLE:\n                            nBytes = ReadDoubleData(mat,(double*)complex_data->Im,\n                                packed_type,data->ndata);\n                            break;\n                        case MAT_T_SINGLE:\n                            nBytes = ReadSingleData(mat,(float*)complex_data->Im,\n                                packed_type,data->ndata);\n                            break;\n                        case MAT_T_INT64:\n#ifdef HAVE_MAT_INT64_T\n                            nBytes = ReadInt64Data(mat,(mat_int64_t*)complex_data->Im,\n                                packed_type,data->ndata);\n#endif\n                            break;\n                        case MAT_T_UINT64:\n#ifdef HAVE_MAT_UINT64_T\n                            nBytes = ReadUInt64Data(mat,(mat_uint64_t*)complex_data->Im,\n                                packed_type,data->ndata);\n#endif\n                            break;\n                        case MAT_T_INT32:\n                            nBytes = ReadInt32Data(mat,(mat_int32_t*)complex_data->Im,\n                                packed_type,data->ndata);\n                            break;\n                        case MAT_T_UINT32:\n                            nBytes = ReadUInt32Data(mat,(mat_uint32_t*)complex_data->Im,\n                                packed_type,data->ndata);\n                            break;\n                        case MAT_T_INT16:\n                            nBytes = ReadInt16Data(mat,(mat_int16_t*)complex_data->Im,\n                                packed_type,data->ndata);\n                            break;\n                        case MAT_T_UINT16:\n                            nBytes = ReadUInt16Data(mat,(mat_uint16_t*)complex_data->Im,\n                                packed_type,data->ndata);\n                            break;\n                        case MAT_T_INT8:\n                            nBytes = ReadInt8Data(mat,(mat_int8_t*)complex_data->Im,\n                                packed_type,data->ndata);\n                            break;\n                        case MAT_T_UINT8:\n                            nBytes = ReadUInt8Data(mat,(mat_uint8_t*)complex_data->Im,\n                                packed_type,data->ndata);\n                            break;\n                        default:\n                            break;\n                    }\n#else /* EXTENDED_SPARSE */\n                    nBytes = ReadDoubleData(mat,(double*)complex_data->Im,\n                                packed_type,data->ndata);\n#endif /* EXTENDED_SPARSE */\n                    if ( data_in_tag )\n                        nBytes+=4;\n                    if ( (nBytes % 8) != 0 )\n                        (void)fseek((FILE*)mat->fp,8-(nBytes % 8),SEEK_CUR);\n#if defined(HAVE_ZLIB)\n                } else if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {\n#if defined(EXTENDED_SPARSE)\n                    switch ( matvar->data_type ) {\n                        case MAT_T_DOUBLE:\n                            nBytes = ReadCompressedDoubleData(mat,matvar->internal->z,\n                                 (double*)complex_data->Re,packed_type,data->ndata);\n                            break;\n                        case MAT_T_SINGLE:\n                            nBytes = ReadCompressedSingleData(mat,matvar->internal->z,\n                                 (float*)complex_data->Re,packed_type,data->ndata);\n                            break;\n                        case MAT_T_INT64:\n#ifdef HAVE_MAT_INT64_T\n                            nBytes = ReadCompressedInt64Data(mat,\n                                matvar->internal->z,(mat_int64_t*)complex_data->Re,\n                                packed_type,data->ndata);\n#endif\n                            break;\n                        case MAT_T_UINT64:\n#ifdef HAVE_MAT_UINT64_T\n                            nBytes = ReadCompressedUInt64Data(mat,\n                                matvar->internal->z,(mat_uint64_t*)complex_data->Re,\n                                packed_type,data->ndata);\n#endif\n                            break;\n                        case MAT_T_INT32:\n                            nBytes = ReadCompressedInt32Data(mat,matvar->internal->z,\n                                 (mat_int32_t*)complex_data->Re,packed_type,data->ndata);\n                            break;\n                        case MAT_T_UINT32:\n                            nBytes = ReadCompressedUInt32Data(mat,matvar->internal->z,\n                                 (mat_uint32_t*)complex_data->Re,packed_type,data->ndata);\n                            break;\n                        case MAT_T_INT16:\n                            nBytes = ReadCompressedInt16Data(mat,matvar->internal->z,\n                                 (mat_int16_t*)complex_data->Re,packed_type,data->ndata);\n                            break;\n                        case MAT_T_UINT16:\n                            nBytes = ReadCompressedUInt16Data(mat,matvar->internal->z,\n                                 (mat_uint16_t*)complex_data->Re,packed_type,data->ndata);\n                            break;\n                        case MAT_T_INT8:\n                            nBytes = ReadCompressedInt8Data(mat,matvar->internal->z,\n                                 (mat_int8_t*)complex_data->Re,packed_type,data->ndata);\n                            break;\n                        case MAT_T_UINT8:\n                            nBytes = ReadCompressedUInt8Data(mat,matvar->internal->z,\n                                 (mat_uint8_t*)complex_data->Re,packed_type,data->ndata);\n                            break;\n                        default:\n                            break;\n                    }\n#else    /* EXTENDED_SPARSE */\n                    nBytes = ReadCompressedDoubleData(mat,matvar->internal->z,\n                                 (double*)complex_data->Re,packed_type,data->ndata);\n#endif    /* EXTENDED_SPARSE */\n                    if ( data_in_tag )\n                        nBytes+=4;\n                    if ( (nBytes % 8) != 0 )\n                        InflateSkip(mat,matvar->internal->z,8-(nBytes % 8));\n\n                    /* Complex Data Tag */\n                    InflateDataType(mat,matvar->internal->z,tag);\n                    if ( byteswap )\n                        (void)Mat_uint32Swap(tag);\n\n                    packed_type = TYPE_FROM_TAG(tag[0]);\n                    if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */\n                        data_in_tag = 1;\n                        nBytes = (tag[0] & 0xffff0000) >> 16;\n                    } else {\n                        data_in_tag = 0;\n                        InflateDataType(mat,matvar->internal->z,tag+1);\n                        if ( byteswap )\n                            (void)Mat_uint32Swap(tag+1);\n                        nBytes = tag[1];\n                    }\n#if defined(EXTENDED_SPARSE)\n                    switch ( matvar->data_type ) {\n                        case MAT_T_DOUBLE:\n                            nBytes = ReadCompressedDoubleData(mat,matvar->internal->z,\n                                 (double*)complex_data->Im,packed_type,data->ndata);\n                            break;\n                        case MAT_T_SINGLE:\n                            nBytes = ReadCompressedSingleData(mat,matvar->internal->z,\n                                 (float*)complex_data->Im,packed_type,data->ndata);\n                            break;\n                        case MAT_T_INT64:\n#ifdef HAVE_MAT_INT64_T\n                            nBytes = ReadCompressedInt64Data(mat,\n                                matvar->internal->z,(mat_int64_t*)complex_data->Im,\n                                packed_type,data->ndata);\n#endif\n                            break;\n                        case MAT_T_UINT64:\n#ifdef HAVE_MAT_UINT64_T\n                            nBytes = ReadCompressedUInt64Data(mat,\n                                matvar->internal->z,(mat_uint64_t*)complex_data->Im,\n                                packed_type,data->ndata);\n#endif\n                            break;\n                        case MAT_T_INT32:\n                            nBytes = ReadCompressedInt32Data(mat,matvar->internal->z,\n                                 (mat_int32_t*)complex_data->Im,packed_type,data->ndata);\n                            break;\n                        case MAT_T_UINT32:\n                            nBytes = ReadCompressedUInt32Data(mat,matvar->internal->z,\n                                 (mat_uint32_t*)complex_data->Im,packed_type,data->ndata);\n                            break;\n                        case MAT_T_INT16:\n                            nBytes = ReadCompressedInt16Data(mat,matvar->internal->z,\n                                 (mat_int16_t*)complex_data->Im,packed_type,data->ndata);\n                            break;\n                        case MAT_T_UINT16:\n                            nBytes = ReadCompressedUInt16Data(mat,matvar->internal->z,\n                                 (mat_uint16_t*)complex_data->Im,packed_type,data->ndata);\n                            break;\n                        case MAT_T_INT8:\n                            nBytes = ReadCompressedInt8Data(mat,matvar->internal->z,\n                                 (mat_int8_t*)complex_data->Im,packed_type,data->ndata);\n                            break;\n                        case MAT_T_UINT8:\n                            nBytes = ReadCompressedUInt8Data(mat,matvar->internal->z,\n                                 (mat_uint8_t*)complex_data->Im,packed_type,data->ndata);\n                            break;\n                        default:\n                            break;\n                    }\n#else    /* EXTENDED_SPARSE */\n                    nBytes = ReadCompressedDoubleData(mat,matvar->internal->z,\n                                 (double*)complex_data->Im,packed_type,data->ndata);\n#endif    /* EXTENDED_SPARSE */\n                    if ( data_in_tag )\n                        nBytes+=4;\n                    if ( (nBytes % 8) != 0 )\n                        InflateSkip(mat,matvar->internal->z,8-(nBytes % 8));\n#endif    /* HAVE_ZLIB */\n                }\n                data->data = complex_data;\n            } else { /* isComplex */\n                data->data = malloc(data->ndata*Mat_SizeOf(matvar->data_type));\n                if ( data->data == NULL ) {\n                    Mat_Critical(\"Couldn't allocate memory for the sparse data\");\n                    break;\n                }\n                if ( matvar->compression == MAT_COMPRESSION_NONE ) {\n#if defined(EXTENDED_SPARSE)\n                    switch ( matvar->data_type ) {\n                        case MAT_T_DOUBLE:\n                            nBytes = ReadDoubleData(mat,(double*)data->data,\n                                packed_type,data->ndata);\n                            break;\n                        case MAT_T_SINGLE:\n                            nBytes = ReadSingleData(mat,(float*)data->data,\n                                packed_type,data->ndata);\n                            break;\n                        case MAT_T_INT64:\n#ifdef HAVE_MAT_INT64_T\n                            nBytes = ReadInt64Data(mat,(mat_int64_t*)data->data,\n                                packed_type,data->ndata);\n#endif\n                            break;\n                        case MAT_T_UINT64:\n#ifdef HAVE_MAT_UINT64_T\n                            nBytes = ReadUInt64Data(mat,(mat_uint64_t*)data->data,\n                                packed_type,data->ndata);\n#endif\n                            break;\n                        case MAT_T_INT32:\n                            nBytes = ReadInt32Data(mat,(mat_int32_t*)data->data,\n                                packed_type,data->ndata);\n                            break;\n                        case MAT_T_UINT32:\n                            nBytes = ReadUInt32Data(mat,(mat_uint32_t*)data->data,\n                                packed_type,data->ndata);\n                            break;\n                        case MAT_T_INT16:\n                            nBytes = ReadInt16Data(mat,(mat_int16_t*)data->data,\n                                packed_type,data->ndata);\n                            break;\n                        case MAT_T_UINT16:\n                            nBytes = ReadUInt16Data(mat,(mat_uint16_t*)data->data,\n                                packed_type,data->ndata);\n                            break;\n                        case MAT_T_INT8:\n                            nBytes = ReadInt8Data(mat,(mat_int8_t*)data->data,\n                                packed_type,data->ndata);\n                            break;\n                        case MAT_T_UINT8:\n                            nBytes = ReadUInt8Data(mat,(mat_uint8_t*)data->data,\n                                packed_type,data->ndata);\n                            break;\n                        default:\n                            break;\n                    }\n#else\n                    nBytes = ReadDoubleData(mat,(double*)data->data,packed_type,\n                                 data->ndata);\n#endif\n                    if ( data_in_tag )\n                        nBytes+=4;\n                    if ( (nBytes % 8) != 0 )\n                        (void)fseek((FILE*)mat->fp,8-(nBytes % 8),SEEK_CUR);\n#if defined(HAVE_ZLIB)\n                } else if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {\n#if defined(EXTENDED_SPARSE)\n                    switch ( matvar->data_type ) {\n                        case MAT_T_DOUBLE:\n                            nBytes = ReadCompressedDoubleData(mat,matvar->internal->z,\n                                 (double*)data->data,packed_type,data->ndata);\n                            break;\n                        case MAT_T_SINGLE:\n                            nBytes = ReadCompressedSingleData(mat,matvar->internal->z,\n                                 (float*)data->data,packed_type,data->ndata);\n                            break;\n                        case MAT_T_INT64:\n#ifdef HAVE_MAT_INT64_T\n                            nBytes = ReadCompressedInt64Data(mat,\n                                matvar->internal->z,(mat_int64_t*)data->data,packed_type,\n                                data->ndata);\n#endif\n                            break;\n                        case MAT_T_UINT64:\n#ifdef HAVE_MAT_UINT64_T\n                            nBytes = ReadCompressedUInt64Data(mat,\n                                matvar->internal->z,(mat_uint64_t*)data->data,packed_type,\n                                data->ndata);\n#endif\n                            break;\n                        case MAT_T_INT32:\n                            nBytes = ReadCompressedInt32Data(mat,matvar->internal->z,\n                                 (mat_int32_t*)data->data,packed_type,data->ndata);\n                            break;\n                        case MAT_T_UINT32:\n                            nBytes = ReadCompressedUInt32Data(mat,matvar->internal->z,\n                                 (mat_uint32_t*)data->data,packed_type,data->ndata);\n                            break;\n                        case MAT_T_INT16:\n                            nBytes = ReadCompressedInt16Data(mat,matvar->internal->z,\n                                 (mat_int16_t*)data->data,packed_type,data->ndata);\n                            break;\n                        case MAT_T_UINT16:\n                            nBytes = ReadCompressedUInt16Data(mat,matvar->internal->z,\n                                 (mat_uint16_t*)data->data,packed_type,data->ndata);\n                            break;\n                        case MAT_T_INT8:\n                            nBytes = ReadCompressedInt8Data(mat,matvar->internal->z,\n                                 (mat_int8_t*)data->data,packed_type,data->ndata);\n                            break;\n                        case MAT_T_UINT8:\n                            nBytes = ReadCompressedUInt8Data(mat,matvar->internal->z,\n                                 (mat_uint8_t*)data->data,packed_type,data->ndata);\n                            break;\n                        default:\n                            break;\n                    }\n#else   /* EXTENDED_SPARSE */\n                    nBytes = ReadCompressedDoubleData(mat,matvar->internal->z,\n                                 (double*)data->data,packed_type,data->ndata);\n#endif   /* EXTENDED_SPARSE */\n                    if ( data_in_tag )\n                        nBytes+=4;\n                    if ( (nBytes % 8) != 0 )\n                        InflateSkip(mat,matvar->internal->z,8-(nBytes % 8));\n#endif   /* HAVE_ZLIB */\n                }\n            }\n            break;\n        }\n        case MAT_C_FUNCTION:\n        {\n            matvar_t **functions;\n            size_t nfunctions = 0;\n\n            if ( !matvar->nbytes || !matvar->data_size )\n                break;\n            nfunctions = matvar->nbytes / matvar->data_size;\n            functions = (matvar_t **)matvar->data;\n            if ( NULL != functions ) {\n                size_t i;\n                for ( i = 0; i < nfunctions; i++ ) {\n                    Mat_VarRead5(mat,functions[i]);\n                }\n            }\n            /* FIXME: */\n            matvar->data_type = MAT_T_FUNCTION;\n            break;\n        }\n        default:\n            Mat_Critical(\"Mat_VarRead5: %d is not a supported class\", matvar->class_type);\n    }\n    switch ( matvar->class_type ) {\n        case MAT_C_DOUBLE:\n        case MAT_C_SINGLE:\n#ifdef HAVE_MAT_INT64_T\n        case MAT_C_INT64:\n#endif\n#ifdef HAVE_MAT_UINT64_T\n        case MAT_C_UINT64:\n#endif\n        case MAT_C_INT32:\n        case MAT_C_UINT32:\n        case MAT_C_INT16:\n        case MAT_C_UINT16:\n        case MAT_C_INT8:\n        case MAT_C_UINT8:\n            if ( matvar->isComplex ) {\n                mat_complex_split_t *complex_data;\n\n                err = SafeMul(&matvar->nbytes, nelems, matvar->data_size);\n                if ( err ) {\n                    Mat_Critical(\"Integer multiplication overflow\");\n                    break;\n                }\n\n                complex_data = ComplexMalloc(matvar->nbytes);\n                if ( NULL == complex_data ) {\n                    Mat_Critical(\"Couldn't allocate memory for the complex data\");\n                    break;\n                }\n\n                Mat_VarReadNumeric5(mat,matvar,complex_data->Re,nelems);\n                Mat_VarReadNumeric5(mat,matvar,complex_data->Im,nelems);\n                matvar->data = complex_data;\n            } else {\n                err = SafeMul(&matvar->nbytes, nelems, matvar->data_size);\n                if ( err ) {\n                    Mat_Critical(\"Integer multiplication overflow\");\n                    break;\n                }\n\n                matvar->data = malloc(matvar->nbytes);\n                if ( NULL == matvar->data ) {\n                    Mat_Critical(\"Couldn't allocate memory for the data\");\n                    break;\n                }\n                Mat_VarReadNumeric5(mat,matvar,matvar->data,nelems);\n            }\n        default:\n            break;\n    }\n    (void)fseek((FILE*)mat->fp,fpos,SEEK_SET);\n\n    return;\n}\n\n#if defined(HAVE_ZLIB)\n#define GET_DATA_SLABN_RANK_LOOP \\\n    do { \\\n        for ( j = 1; j < rank; j++ ) { \\\n            cnt[j]++; \\\n            if ( (cnt[j] % edge[j]) == 0 ) { \\\n                cnt[j] = 0; \\\n                if ( (I % dimp[j]) != 0 ) { \\\n                    ptr_in += dimp[j]-(I % dimp[j])+dimp[j-1]*start[j]; \\\n                    I += dimp[j]-(I % dimp[j]) + dimp[j-1]*start[j]; \\\n                } else if ( start[j] ) { \\\n                    ptr_in += dimp[j-1]*start[j]; \\\n                    I += dimp[j-1]*start[j]; \\\n                } \\\n            } else { \\\n                I += inc[j]; \\\n                ptr_in += inc[j]; \\\n                break; \\\n            } \\\n        } \\\n    } while (0)\n\n#define GET_DATA_SLAB2(T) \\\n    do { \\\n        ptr_in += start[1]*dims[0] + start[0]; \\\n        for ( i = 0; i < edge[1]; i++ ) { \\\n            for ( j = 0; j < edge[0]; j++ ) { \\\n                *ptr = (T)(*(ptr_in+j*stride[0])); \\\n                ptr++; \\\n            } \\\n            ptr_in += stride[1]*dims[0]; \\\n        } \\\n    } while (0)\n\n#define GET_DATA_SLABN(T) \\\n    do { \\\n        inc[0]  = stride[0]-1; \\\n        dimp[0] = dims[0]; \\\n        N       = edge[0]; \\\n        I       = 0; /* start[0]; */ \\\n        for ( i = 1; i < rank; i++ ) { \\\n            inc[i]  = stride[i]-1; \\\n            dimp[i] = dims[i-1]; \\\n            for ( j = i; j--; ) { \\\n                inc[i]  *= dims[j]; \\\n                dimp[i] *= dims[j+1]; \\\n            } \\\n            N *= edge[i]; \\\n            I += dimp[i-1]*start[i]; \\\n        } \\\n        ptr_in += I; \\\n        if ( stride[0] == 1 ) { \\\n            for ( i = 0; i < N; i+=edge[0] ) { \\\n                int k; \\\n                if ( start[0] ) { \\\n                    ptr_in += start[0]; \\\n                    I += start[0]; \\\n                } \\\n                for ( k = 0; k < edge[0]; k++ ) { \\\n                    *(ptr+i+k) = (T)(*(ptr_in+k)); \\\n                } \\\n                I += dims[0]-start[0]; \\\n                ptr_in += dims[0]-start[0]; \\\n                GET_DATA_SLABN_RANK_LOOP; \\\n            } \\\n        } else { \\\n            for ( i = 0; i < N; i+=edge[0] ) { \\\n                if ( start[0] ) { \\\n                    ptr_in += start[0]; \\\n                    I += start[0]; \\\n                } \\\n                for ( j = 0; j < edge[0]; j++ ) { \\\n                    *(ptr+i+j) = (T)(*ptr_in); \\\n                    ptr_in += stride[0]; \\\n                    I += stride[0]; \\\n                } \\\n                I += dims[0]-(ptrdiff_t)edge[0]*stride[0]-start[0]; \\\n                ptr_in += dims[0]-(ptrdiff_t)edge[0]*stride[0]-start[0]; \\\n                GET_DATA_SLABN_RANK_LOOP; \\\n            } \\\n        } \\\n    } while (0)\n\n#ifdef HAVE_MAT_INT64_T\n#define GET_DATA_SLAB2_INT64(T) \\\n    do { \\\n        if ( MAT_T_INT64 == data_type ) { \\\n            mat_int64_t *ptr_in = (mat_int64_t *)data_in; \\\n            GET_DATA_SLAB2(T); \\\n            err = 0; \\\n        } \\\n    } while (0)\n#else\n#define GET_DATA_SLAB2_INT64(T)\n#endif /* HAVE_MAT_INT64_T */\n\n#ifdef HAVE_MAT_UINT64_T\n#define GET_DATA_SLAB2_UINT64(T) \\\n    do { \\\n        if ( MAT_T_UINT64 == data_type ) { \\\n            mat_uint64_t *ptr_in = (mat_uint64_t *)data_in; \\\n            GET_DATA_SLAB2(T); \\\n            err = 0; \\\n        } \\\n    } while (0)\n#else\n#define GET_DATA_SLAB2_UINT64(T)\n#endif /* HAVE_MAT_UINT64_T */\n\n#define GET_DATA_SLAB2_TYPE(T) \\\n    do { \\\n        switch ( data_type ) { \\\n            case MAT_T_DOUBLE: \\\n            { \\\n                double *ptr_in = (double *)data_in; \\\n                GET_DATA_SLAB2(T); \\\n                break; \\\n            } \\\n            case MAT_T_SINGLE: \\\n            { \\\n                float *ptr_in = (float *)data_in; \\\n                GET_DATA_SLAB2(T); \\\n                break; \\\n            } \\\n            case MAT_T_INT32: \\\n            { \\\n                mat_int32_t *ptr_in = (mat_int32_t *)data_in; \\\n                GET_DATA_SLAB2(T); \\\n                break; \\\n            } \\\n            case MAT_T_UINT32: \\\n            { \\\n                mat_uint32_t *ptr_in = (mat_uint32_t *)data_in; \\\n                GET_DATA_SLAB2(T); \\\n                break; \\\n            } \\\n            case MAT_T_INT16: \\\n            { \\\n                mat_int16_t *ptr_in = (mat_int16_t *)data_in; \\\n                GET_DATA_SLAB2(T); \\\n                break; \\\n            } \\\n            case MAT_T_UINT16: \\\n            { \\\n                mat_uint16_t *ptr_in = (mat_uint16_t *)data_in; \\\n                GET_DATA_SLAB2(T); \\\n                break; \\\n            } \\\n            case MAT_T_INT8: \\\n            { \\\n                mat_int8_t *ptr_in = (mat_int8_t *)data_in; \\\n                GET_DATA_SLAB2(T); \\\n                break; \\\n            } \\\n            case MAT_T_UINT8: \\\n            { \\\n                mat_uint8_t *ptr_in = (mat_uint8_t *)data_in; \\\n                GET_DATA_SLAB2(T); \\\n                break; \\\n            } \\\n            default: \\\n                err = 1; \\\n                GET_DATA_SLAB2_INT64(T); \\\n                GET_DATA_SLAB2_UINT64(T); \\\n                break; \\\n        } \\\n    } while (0)\n\n#ifdef HAVE_MAT_INT64_T\n#define GET_DATA_SLABN_INT64(T) \\\n    do { \\\n        if ( MAT_T_INT64 == data_type ) { \\\n            mat_int64_t *ptr_in = (mat_int64_t *)data_in; \\\n            GET_DATA_SLABN(T); \\\n            err = 0; \\\n        } \\\n    } while (0)\n#else\n#define GET_DATA_SLABN_INT64(T)\n#endif /* HAVE_MAT_INT64_T */\n\n#ifdef HAVE_MAT_UINT64_T\n#define GET_DATA_SLABN_UINT64(T) \\\n    do { \\\n        if ( MAT_T_UINT64 == data_type ) { \\\n            mat_uint64_t *ptr_in = (mat_uint64_t *)data_in; \\\n            GET_DATA_SLABN(T); \\\n            err = 0; \\\n        } \\\n    } while (0)\n#else\n#define GET_DATA_SLABN_UINT64(T)\n#endif /* HAVE_MAT_UINT64_T */\n\n#define GET_DATA_SLABN_TYPE(T) \\\n    do { \\\n        switch ( data_type ) { \\\n            case MAT_T_DOUBLE: \\\n            { \\\n                double *ptr_in = (double *)data_in; \\\n                GET_DATA_SLABN(T); \\\n                break; \\\n            } \\\n            case MAT_T_SINGLE: \\\n            { \\\n                float *ptr_in = (float *)data_in; \\\n                GET_DATA_SLABN(T); \\\n                break; \\\n            } \\\n            case MAT_T_INT32: \\\n            { \\\n                mat_int32_t *ptr_in = (mat_int32_t *)data_in; \\\n                GET_DATA_SLABN(T); \\\n                break; \\\n            } \\\n            case MAT_T_UINT32: \\\n            { \\\n                mat_uint32_t *ptr_in = (mat_uint32_t *)data_in; \\\n                GET_DATA_SLABN(T); \\\n                break; \\\n            } \\\n            case MAT_T_INT16: \\\n            { \\\n                mat_int16_t *ptr_in = (mat_int16_t *)data_in; \\\n                GET_DATA_SLABN(T); \\\n                break; \\\n            } \\\n            case MAT_T_UINT16: \\\n            { \\\n                mat_uint16_t *ptr_in = (mat_uint16_t *)data_in; \\\n                GET_DATA_SLABN(T); \\\n                break; \\\n            } \\\n            case MAT_T_INT8: \\\n            { \\\n                mat_int8_t *ptr_in = (mat_int8_t *)data_in; \\\n                GET_DATA_SLABN(T); \\\n                break; \\\n            } \\\n            case MAT_T_UINT8: \\\n            { \\\n                mat_uint8_t *ptr_in = (mat_uint8_t *)data_in; \\\n                GET_DATA_SLABN(T); \\\n                break; \\\n            } \\\n            default: \\\n                err = 1; \\\n                GET_DATA_SLABN_INT64(T); \\\n                GET_DATA_SLABN_UINT64(T); \\\n                break; \\\n        } \\\n    } while (0)\n\nstatic int\nGetDataSlab(void *data_in, void *data_out, enum matio_classes class_type,\n    enum matio_types data_type, size_t *dims, int *start, int *stride, int *edge,\n    int rank, size_t nbytes)\n{\n    int err = 0;\n    int same_type = 0;\n    if (( class_type == MAT_C_DOUBLE && data_type == MAT_T_DOUBLE ) ||\n        ( class_type == MAT_C_SINGLE && data_type == MAT_T_SINGLE ) ||\n        ( class_type == MAT_C_INT16 && data_type == MAT_T_INT16 ) ||\n        ( class_type == MAT_C_INT32 && data_type == MAT_T_INT32 ) ||\n        ( class_type == MAT_C_INT64 && data_type == MAT_T_INT64 ) ||\n        ( class_type == MAT_C_INT8 && data_type == MAT_T_INT8 ) ||\n        ( class_type == MAT_C_UINT16 && data_type == MAT_T_UINT16 ) ||\n        ( class_type == MAT_C_UINT32 && data_type == MAT_T_UINT32 ) ||\n        ( class_type == MAT_C_UINT64 && data_type == MAT_T_UINT64 ) ||\n        ( class_type == MAT_C_UINT8 && data_type == MAT_T_UINT8 ))\n        same_type = 1;\n\n    if ( rank == 2 ) {\n        if ( (size_t)stride[0]*(edge[0]-1)+start[0]+1 > dims[0] )\n            err = 1;\n        else if ( (size_t)stride[1]*(edge[1]-1)+start[1]+1 > dims[1] )\n            err = 1;\n        else if ( ( stride[0] == 1 && edge[0] == dims[0] ) &&\n                  ( stride[1] == 1 ) && ( same_type == 1 ) )\n            memcpy(data_out, data_in, nbytes);\n        else {\n            int i, j;\n\n            switch ( class_type ) {\n                case MAT_C_DOUBLE:\n                {\n                    double *ptr = (double *)data_out;\n                    GET_DATA_SLAB2_TYPE(double);\n                    break;\n                }\n                case MAT_C_SINGLE:\n                {\n                    float *ptr = (float *)data_out;\n                    GET_DATA_SLAB2_TYPE(float);\n                    break;\n                }\n#ifdef HAVE_MAT_INT64_T\n                case MAT_C_INT64:\n                {\n                    mat_int64_t *ptr = (mat_int64_t *)data_out;\n                    GET_DATA_SLAB2_TYPE(mat_int64_t);\n                    break;\n                }\n#endif /* HAVE_MAT_INT64_T */\n#ifdef HAVE_MAT_UINT64_T\n                case MAT_C_UINT64:\n                {\n                    mat_uint64_t *ptr = (mat_uint64_t *)data_out;\n                    GET_DATA_SLAB2_TYPE(mat_uint64_t);\n                    break;\n                }\n#endif /* HAVE_MAT_UINT64_T */\n                case MAT_C_INT32:\n                {\n                    mat_int32_t *ptr = (mat_int32_t *)data_out;\n                    GET_DATA_SLAB2_TYPE(mat_int32_t);\n                    break;\n                }\n                case MAT_C_UINT32:\n                {\n                    mat_uint32_t *ptr = (mat_uint32_t *)data_out;\n                    GET_DATA_SLAB2_TYPE(mat_uint32_t);\n                    break;\n                }\n                case MAT_C_INT16:\n                {\n                    mat_int16_t *ptr = (mat_int16_t *)data_out;\n                    GET_DATA_SLAB2_TYPE(mat_int16_t);\n                    break;\n                }\n                case MAT_C_UINT16:\n                {\n                    mat_uint16_t *ptr = (mat_uint16_t *)data_out;\n                    GET_DATA_SLAB2_TYPE(mat_uint16_t);\n                    break;\n                }\n                case MAT_C_INT8:\n                {\n                    mat_int8_t *ptr = (mat_int8_t *)data_out;\n                    GET_DATA_SLAB2_TYPE(mat_int8_t);\n                    break;\n                }\n                case MAT_C_UINT8:\n                {\n                    mat_uint8_t *ptr = (mat_uint8_t *)data_out;\n                    GET_DATA_SLAB2_TYPE(mat_uint8_t);\n                    break;\n                }\n                default:\n                    err = 1;\n                    break;\n            }\n        }\n    } else {\n        int i, j, N, I = 0;\n        int inc[10] = {0,}, cnt[10] = {0,}, dimp[10] = {0,};\n\n        switch ( class_type ) {\n            case MAT_C_DOUBLE:\n            {\n                double *ptr = (double *)data_out;\n                GET_DATA_SLABN_TYPE(double);\n                break;\n            }\n            case MAT_C_SINGLE:\n            {\n                float *ptr = (float *)data_out;\n                GET_DATA_SLABN_TYPE(float);\n                break;\n            }\n#ifdef HAVE_MAT_INT64_T\n            case MAT_C_INT64:\n            {\n                mat_int64_t *ptr = (mat_int64_t *)data_out;\n                GET_DATA_SLABN_TYPE(mat_int64_t);\n                break;\n            }\n#endif /* HAVE_MAT_INT64_T */\n#ifdef HAVE_MAT_UINT64_T\n            case MAT_C_UINT64:\n            {\n                mat_uint64_t *ptr = (mat_uint64_t *)data_out;\n                GET_DATA_SLABN_TYPE(mat_uint64_t);\n                break;\n            }\n#endif /* HAVE_MAT_UINT64_T */\n            case MAT_C_INT32:\n            {\n                mat_int32_t *ptr = (mat_int32_t *)data_out;\n                GET_DATA_SLABN_TYPE(mat_int32_t);\n                break;\n            }\n            case MAT_C_UINT32:\n            {\n                mat_uint32_t *ptr = (mat_uint32_t *)data_out;\n                GET_DATA_SLABN_TYPE(mat_uint32_t);\n                break;\n            }\n            case MAT_C_INT16:\n            {\n                mat_int16_t *ptr = (mat_int16_t *)data_out;\n                GET_DATA_SLABN_TYPE(mat_int16_t);\n                break;\n            }\n            case MAT_C_UINT16:\n            {\n                mat_uint16_t *ptr = (mat_uint16_t *)data_out;\n                GET_DATA_SLABN_TYPE(mat_uint16_t);\n                break;\n            }\n            case MAT_C_INT8:\n            {\n                mat_int8_t *ptr = (mat_int8_t *)data_out;\n                GET_DATA_SLABN_TYPE(mat_int8_t);\n                break;\n            }\n            case MAT_C_UINT8:\n            {\n                mat_uint8_t *ptr = (mat_uint8_t *)data_out;\n                GET_DATA_SLABN_TYPE(mat_uint8_t);\n                break;\n            }\n            default:\n                err = 1;\n                break;\n        }\n    }\n\n    return err;\n}\n\n#undef GET_DATA_SLAB2\n#undef GET_DATA_SLAB2_TYPE\n#undef GET_DATA_SLAB2_INT64\n#undef GET_DATA_SLAB2_UINT64\n#undef GET_DATA_SLABN\n#undef GET_DATA_SLABN_TYPE\n#undef GET_DATA_SLABN_INT64\n#undef GET_DATA_SLABN_UINT64\n#undef GET_DATA_SLABN_RANK_LOOP\n\n#define GET_DATA_LINEAR \\\n    do { \\\n        ptr_in += start; \\\n        if ( !stride ) { \\\n            memcpy(ptr, ptr_in, (size_t)edge*data_size); \\\n        } else { \\\n            int i; \\\n            for ( i = 0; i < edge; i++ ) \\\n                memcpy(ptr++, ptr_in+i*stride, data_size); \\\n        } \\\n    } while (0)\n\nstatic int\nGetDataLinear(void *data_in, void *data_out, enum matio_classes class_type,\n    enum matio_types data_type, int start, int stride, int edge)\n{\n    int err = 0;\n    size_t data_size = Mat_SizeOf(data_type);\n\n    switch ( class_type ) {\n        case MAT_C_DOUBLE:\n        {\n            double *ptr = (double *)data_out;\n            double *ptr_in = (double*)data_in;\n            GET_DATA_LINEAR;\n            break;\n        }\n        case MAT_C_SINGLE:\n        {\n            float *ptr = (float *)data_out;\n            float *ptr_in = (float*)data_in;\n            GET_DATA_LINEAR;\n            break;\n        }\n#ifdef HAVE_MAT_INT64_T\n        case MAT_C_INT64:\n        {\n            mat_int64_t *ptr = (mat_int64_t *)data_out;\n            mat_int64_t *ptr_in = (mat_int64_t*)data_in;\n            GET_DATA_LINEAR;\n            break;\n        }\n#endif /* HAVE_MAT_INT64_T */\n#ifdef HAVE_MAT_UINT64_T\n        case MAT_C_UINT64:\n        {\n            mat_uint64_t *ptr = (mat_uint64_t *)data_out;\n            mat_uint64_t *ptr_in = (mat_uint64_t*)data_in;\n            GET_DATA_LINEAR;\n            break;\n        }\n#endif /* HAVE_MAT_UINT64_T */\n        case MAT_C_INT32:\n        {\n            mat_int32_t *ptr = (mat_int32_t *)data_out;\n            mat_int32_t *ptr_in = (mat_int32_t*)data_in;\n            GET_DATA_LINEAR;\n            break;\n        }\n        case MAT_C_UINT32:\n        {\n            mat_uint32_t *ptr = (mat_uint32_t *)data_out;\n            mat_uint32_t *ptr_in = (mat_uint32_t*)data_in;\n            GET_DATA_LINEAR;\n            break;\n        }\n        case MAT_C_INT16:\n        {\n            mat_int16_t *ptr = (mat_int16_t *)data_out;\n            mat_int16_t *ptr_in = (mat_int16_t*)data_in;\n            GET_DATA_LINEAR;\n            break;\n        }\n        case MAT_C_UINT16:\n        {\n            mat_uint16_t *ptr = (mat_uint16_t *)data_out;\n            mat_uint16_t *ptr_in = (mat_uint16_t*)data_in;\n            GET_DATA_LINEAR;\n            break;\n        }\n        case MAT_C_INT8:\n        {\n            mat_int8_t *ptr = (mat_int8_t *)data_out;\n            mat_int8_t *ptr_in = (mat_int8_t*)data_in;\n            GET_DATA_LINEAR;\n            break;\n        }\n        case MAT_C_UINT8:\n        {\n            mat_uint8_t *ptr = (mat_uint8_t *)data_out;\n            mat_uint8_t *ptr_in = (mat_uint8_t*)data_in;\n            GET_DATA_LINEAR;\n            break;\n        }\n        default:\n            err = 1;\n            break;\n    }\n\n    return err;\n}\n\n#undef GET_DATA_LINEAR\n#endif\n\n/** @if mat_devman\n * @brief Reads a slab of data from the mat variable @c matvar\n *\n * @ingroup mat_internal\n * @param mat MAT file pointer\n * @param matvar pointer to the mat variable\n * @param data pointer to store the read data in (must be of size\n *             edge[0]*...edge[rank-1]*Mat_SizeOfClass(matvar->class_type))\n * @param start index to start reading data in each dimension\n * @param stride write data every @c stride elements in each dimension\n * @param edge number of elements to read in each dimension\n * @retval 0 on success\n * @endif\n */\nint\nMat_VarReadData5(mat_t *mat,matvar_t *matvar,void *data,\n    int *start,int *stride,int *edge)\n{\n    int err = 0,real_bytes = 0;\n    mat_int32_t tag[2];\n#if defined(HAVE_ZLIB)\n    z_stream z;\n#endif\n    size_t bytesread = 0;\n\n    (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);\n    if ( matvar->compression == MAT_COMPRESSION_NONE ) {\n        bytesread += fread(tag,4,2,(FILE*)mat->fp);\n        if ( mat->byteswap ) {\n            (void)Mat_int32Swap(tag);\n            (void)Mat_int32Swap(tag+1);\n        }\n        matvar->data_type = TYPE_FROM_TAG(tag[0]);\n        if ( tag[0] & 0xffff0000 ) { /* Data is packed in the tag */\n            (void)fseek((FILE*)mat->fp,-4,SEEK_CUR);\n            real_bytes = 4+(tag[0] >> 16);\n        } else {\n            real_bytes = 8+tag[1];\n        }\n#if defined(HAVE_ZLIB)\n    } else if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {\n        if ( NULL != matvar->internal->data ) {\n            /* Data already read in ReadNextStructField or ReadNextCell */\n            if ( matvar->isComplex ) {\n                mat_complex_split_t *ci, *co;\n\n                co = (mat_complex_split_t*)data;\n                ci = (mat_complex_split_t*)matvar->internal->data;\n                err = GetDataSlab(ci->Re, co->Re, matvar->class_type,\n                    matvar->data_type, matvar->dims, start, stride, edge,\n                    matvar->rank, matvar->nbytes);\n                if ( err == 0 )\n                    err = GetDataSlab(ci->Im, co->Im, matvar->class_type,\n                        matvar->data_type, matvar->dims, start, stride, edge,\n                        matvar->rank, matvar->nbytes);\n                return err;\n            } else {\n                return GetDataSlab(matvar->internal->data, data, matvar->class_type,\n                    matvar->data_type, matvar->dims, start, stride, edge,\n                    matvar->rank, matvar->nbytes);\n            }\n        }\n\n        err = inflateCopy(&z,matvar->internal->z);\n        if ( err != Z_OK ) {\n            Mat_Critical(\"inflateCopy returned error %s\",zError(err));\n            return -1;\n        }\n        z.avail_in = 0;\n        InflateDataType(mat,&z,tag);\n        if ( mat->byteswap ) {\n            (void)Mat_int32Swap(tag);\n        }\n        matvar->data_type = TYPE_FROM_TAG(tag[0]);\n        if ( !(tag[0] & 0xffff0000) ) {/* Data is NOT packed in the tag */\n            /* We're cheating, but InflateDataType just inflates 4 bytes */\n            InflateDataType(mat,&z,tag+1);\n            if ( mat->byteswap ) {\n                (void)Mat_int32Swap(tag+1);\n            }\n            real_bytes = 8+tag[1];\n        } else {\n            real_bytes = 4+(tag[0] >> 16);\n        }\n#endif\n    }\n    if ( real_bytes % 8 )\n        real_bytes += (8-(real_bytes % 8));\n\n    if ( matvar->rank == 2 ) {\n        if ( (size_t)stride[0]*(edge[0]-1)+start[0]+1 > matvar->dims[0] )\n            err = 1;\n        else if ( (size_t)stride[1]*(edge[1]-1)+start[1]+1 > matvar->dims[1] )\n            err = 1;\n        else if ( matvar->compression == MAT_COMPRESSION_NONE ) {\n            if ( matvar->isComplex ) {\n                mat_complex_split_t *complex_data = (mat_complex_split_t*)data;\n\n                ReadDataSlab2(mat,complex_data->Re,matvar->class_type,\n                    matvar->data_type,matvar->dims,start,stride,edge);\n                (void)fseek((FILE*)mat->fp,matvar->internal->datapos+real_bytes,SEEK_SET);\n                bytesread += fread(tag,4,2,(FILE*)mat->fp);\n                if ( mat->byteswap ) {\n                    (void)Mat_int32Swap(tag);\n                    (void)Mat_int32Swap(tag+1);\n                }\n                matvar->data_type = TYPE_FROM_TAG(tag[0]);\n                if ( tag[0] & 0xffff0000 ) { /* Data is packed in the tag */\n                    (void)fseek((FILE*)mat->fp,-4,SEEK_CUR);\n                }\n                ReadDataSlab2(mat,complex_data->Im,matvar->class_type,\n                              matvar->data_type,matvar->dims,start,stride,edge);\n            } else {\n                ReadDataSlab2(mat,data,matvar->class_type,\n                    matvar->data_type,matvar->dims,start,stride,edge);\n            }\n        }\n#if defined(HAVE_ZLIB)\n        else if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {\n            if ( matvar->isComplex ) {\n                mat_complex_split_t *complex_data = (mat_complex_split_t*)data;\n\n                ReadCompressedDataSlab2(mat,&z,complex_data->Re,\n                    matvar->class_type,matvar->data_type,matvar->dims,\n                    start,stride,edge);\n\n                (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);\n\n                /* Reset zlib knowledge to before reading real tag */\n                inflateEnd(&z);\n                err = inflateCopy(&z,matvar->internal->z);\n                if ( err != Z_OK ) {\n                    Mat_Critical(\"inflateCopy returned error %s\",zError(err));\n                }\n                InflateSkip(mat,&z,real_bytes);\n                z.avail_in = 0;\n                InflateDataType(mat,&z,tag);\n                if ( mat->byteswap ) {\n                    (void)Mat_int32Swap(tag);\n                }\n                matvar->data_type = TYPE_FROM_TAG(tag[0]);\n                if ( !(tag[0] & 0xffff0000) ) {/*Data is NOT packed in the tag*/\n                    InflateSkip(mat,&z,4);\n                }\n                ReadCompressedDataSlab2(mat,&z,complex_data->Im,\n                    matvar->class_type,matvar->data_type,matvar->dims,\n                    start,stride,edge);\n            } else {\n                ReadCompressedDataSlab2(mat,&z,data,matvar->class_type,\n                    matvar->data_type,matvar->dims,start,stride,edge);\n            }\n            inflateEnd(&z);\n        }\n#endif\n    } else {\n        if ( matvar->compression == MAT_COMPRESSION_NONE ) {\n            if ( matvar->isComplex ) {\n                mat_complex_split_t *complex_data = (mat_complex_split_t*)data;\n\n                ReadDataSlabN(mat,complex_data->Re,matvar->class_type,\n                    matvar->data_type,matvar->rank,matvar->dims,\n                    start,stride,edge);\n\n                (void)fseek((FILE*)mat->fp,matvar->internal->datapos+real_bytes,SEEK_SET);\n                bytesread += fread(tag,4,2,(FILE*)mat->fp);\n                if ( mat->byteswap ) {\n                    (void)Mat_int32Swap(tag);\n                    (void)Mat_int32Swap(tag+1);\n                }\n                matvar->data_type = TYPE_FROM_TAG(tag[0]);\n                if ( tag[0] & 0xffff0000 ) { /* Data is packed in the tag */\n                    (void)fseek((FILE*)mat->fp,-4,SEEK_CUR);\n                }\n                ReadDataSlabN(mat,complex_data->Im,matvar->class_type,\n                    matvar->data_type,matvar->rank,matvar->dims,\n                    start,stride,edge);\n            } else {\n                ReadDataSlabN(mat,data,matvar->class_type,matvar->data_type,\n                    matvar->rank,matvar->dims,start,stride,edge);\n            }\n        }\n#if defined(HAVE_ZLIB)\n        else if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {\n            if ( matvar->isComplex ) {\n                mat_complex_split_t *complex_data = (mat_complex_split_t*)data;\n\n                ReadCompressedDataSlabN(mat,&z,complex_data->Re,\n                    matvar->class_type,matvar->data_type,matvar->rank,\n                    matvar->dims,start,stride,edge);\n\n                (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);\n                /* Reset zlib knowledge to before reading real tag */\n                inflateEnd(&z);\n                err = inflateCopy(&z,matvar->internal->z);\n                if ( err != Z_OK ) {\n                    Mat_Critical(\"inflateCopy returned error %s\",zError(err));\n                }\n                InflateSkip(mat,&z,real_bytes);\n                z.avail_in = 0;\n                InflateDataType(mat,&z,tag);\n                if ( mat->byteswap ) {\n                    (void)Mat_int32Swap(tag);\n                }\n                matvar->data_type = TYPE_FROM_TAG(tag[0]);\n                if ( !(tag[0] & 0xffff0000) ) {/*Data is NOT packed in the tag*/\n                    InflateSkip(mat,&z,4);\n                }\n                ReadCompressedDataSlabN(mat,&z,complex_data->Im,\n                    matvar->class_type,matvar->data_type,matvar->rank,\n                    matvar->dims,start,stride,edge);\n            } else {\n                ReadCompressedDataSlabN(mat,&z,data,matvar->class_type,\n                    matvar->data_type,matvar->rank,matvar->dims,\n                    start,stride,edge);\n            }\n            inflateEnd(&z);\n        }\n#endif\n    }\n    if ( err == 0 ) {\n        matvar->data_type = ClassType2DataType(matvar->class_type);\n        matvar->data_size = Mat_SizeOfClass(matvar->class_type);\n    }\n    return err;\n}\n\n/** @brief Reads a subset of a MAT variable using a 1-D indexing\n *\n * Reads data from a MAT variable using a linear (1-D) indexing mode. The\n * variable must have been read by Mat_VarReadInfo.\n * @ingroup MAT\n * @param mat MAT file to read data from\n * @param matvar MAT variable information\n * @param data pointer to store data in (must be pre-allocated)\n * @param start starting index\n * @param stride stride of data\n * @param edge number of elements to read\n * @retval 0 on success\n */\nint\nMat_VarReadDataLinear5(mat_t *mat,matvar_t *matvar,void *data,int start,\n                      int stride,int edge)\n{\n    int err = 0, real_bytes = 0;\n    mat_int32_t tag[2];\n#if defined(HAVE_ZLIB)\n    z_stream z;\n#endif\n    size_t bytesread = 0, nelems = 1;\n\n    if ( mat->version == MAT_FT_MAT4 )\n        return -1;\n    (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);\n    if ( matvar->compression == MAT_COMPRESSION_NONE ) {\n        bytesread += fread(tag,4,2,(FILE*)mat->fp);\n        if ( mat->byteswap ) {\n            (void)Mat_int32Swap(tag);\n            (void)Mat_int32Swap(tag+1);\n        }\n        matvar->data_type = (enum matio_types)(tag[0] & 0x000000ff);\n        if ( tag[0] & 0xffff0000 ) { /* Data is packed in the tag */\n            (void)fseek((FILE*)mat->fp,-4,SEEK_CUR);\n            real_bytes = 4+(tag[0] >> 16);\n        } else {\n            real_bytes = 8+tag[1];\n        }\n#if defined(HAVE_ZLIB)\n    } else if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {\n        if ( NULL != matvar->internal->data ) {\n            /* Data already read in ReadNextStructField or ReadNextCell */\n            if ( matvar->isComplex ) {\n                mat_complex_split_t *ci, *co;\n\n                co = (mat_complex_split_t*)data;\n                ci = (mat_complex_split_t*)matvar->internal->data;\n                err = GetDataLinear(ci->Re, co->Re, matvar->class_type,\n                    matvar->data_type, start, stride, edge);\n                if ( err == 0 )\n                    err = GetDataLinear(ci->Im, co->Im, matvar->class_type,\n                        matvar->data_type, start, stride, edge);\n                return err;\n            } else {\n                return GetDataLinear(matvar->internal->data, data, matvar->class_type,\n                    matvar->data_type, start, stride, edge);\n            }\n        }\n\n        matvar->internal->z->avail_in = 0;\n        err = inflateCopy(&z,matvar->internal->z);\n        if ( err != Z_OK ) {\n            Mat_Critical(\"inflateCopy returned error %s\",zError(err));\n            return -1;\n        }\n        InflateDataType(mat,&z,tag);\n        if ( mat->byteswap ) {\n            (void)Mat_int32Swap(tag);\n            (void)Mat_int32Swap(tag+1);\n        }\n        matvar->data_type = (enum matio_types)(tag[0] & 0x000000ff);\n        if ( !(tag[0] & 0xffff0000) ) {/* Data is NOT packed in the tag */\n            /* We're cheating, but InflateDataType just inflates 4 bytes */\n            InflateDataType(mat,&z,tag+1);\n            if ( mat->byteswap ) {\n                (void)Mat_int32Swap(tag+1);\n            }\n            real_bytes = 8+tag[1];\n        } else {\n            real_bytes = 4+(tag[0] >> 16);\n        }\n#endif\n    }\n    if ( real_bytes % 8 )\n        real_bytes += (8-(real_bytes % 8));\n\n    err = SafeMulDims(matvar, &nelems);\n    if ( err ) {\n        Mat_Critical(\"Integer multiplication overflow\");\n        return -1;\n    }\n\n    if ( (size_t)stride*(edge-1)+start+1 > nelems ) {\n        err = 1;\n    } else if ( matvar->compression == MAT_COMPRESSION_NONE ) {\n        if ( matvar->isComplex ) {\n            mat_complex_split_t *complex_data = (mat_complex_split_t*)data;\n\n            ReadDataSlab1(mat,complex_data->Re,matvar->class_type,\n                          matvar->data_type,start,stride,edge);\n            (void)fseek((FILE*)mat->fp,matvar->internal->datapos+real_bytes,SEEK_SET);\n            bytesread += fread(tag,4,2,(FILE*)mat->fp);\n            if ( mat->byteswap ) {\n                (void)Mat_int32Swap(tag);\n                (void)Mat_int32Swap(tag+1);\n            }\n            matvar->data_type = (enum matio_types)(tag[0] & 0x000000ff);\n            if ( tag[0] & 0xffff0000 ) { /* Data is packed in the tag */\n                (void)fseek((FILE*)mat->fp,-4,SEEK_CUR);\n            }\n            ReadDataSlab1(mat,complex_data->Im,matvar->class_type,\n                          matvar->data_type,start,stride,edge);\n        } else {\n            ReadDataSlab1(mat,data,matvar->class_type,\n                          matvar->data_type,start,stride,edge);\n        }\n#if defined(HAVE_ZLIB)\n    } else if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {\n        if ( matvar->isComplex ) {\n            mat_complex_split_t *complex_data = (mat_complex_split_t*)data;\n\n            ReadCompressedDataSlab1(mat,&z,complex_data->Re,\n                matvar->class_type,matvar->data_type,start,stride,edge);\n\n            (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);\n\n            /* Reset zlib knowledge to before reading real tag */\n            inflateEnd(&z);\n            err = inflateCopy(&z,matvar->internal->z);\n            if ( err != Z_OK ) {\n                Mat_Critical(\"inflateCopy returned error %s\",zError(err));\n            }\n            InflateSkip(mat,&z,real_bytes);\n            z.avail_in = 0;\n            InflateDataType(mat,&z,tag);\n            if ( mat->byteswap ) {\n                (void)Mat_int32Swap(tag);\n            }\n            matvar->data_type = (enum matio_types)(tag[0] & 0x000000ff);\n            if ( !(tag[0] & 0xffff0000) ) {/*Data is NOT packed in the tag*/\n                InflateSkip(mat,&z,4);\n            }\n            ReadCompressedDataSlab1(mat,&z,complex_data->Im,\n                matvar->class_type,matvar->data_type,start,stride,edge);\n        } else {\n            ReadCompressedDataSlab1(mat,&z,data,matvar->class_type,\n                matvar->data_type,start,stride,edge);\n        }\n        inflateEnd(&z);\n#endif\n    }\n\n    matvar->data_type = ClassType2DataType(matvar->class_type);\n    matvar->data_size = Mat_SizeOfClass(matvar->class_type);\n\n    return err;\n}\n\n/** @if mat_devman\n * @brief Writes a matlab variable to a version 5 matlab file\n *\n * @ingroup mat_internal\n * @param mat MAT file pointer\n * @param matvar pointer to the mat variable\n * @param compress option to compress the variable\n *                 (only works for numeric types)\n * @retval 0 on success\n * @endif\n */\nint\nMat_VarWrite5(mat_t *mat,matvar_t *matvar,int compress)\n{\n    mat_uint32_t array_flags;\n    int array_flags_type = MAT_T_UINT32, dims_array_type = MAT_T_INT32;\n    int array_flags_size = 8, pad4 = 0, matrix_type = MAT_T_MATRIX;\n    int nBytes, i, nzmax = 0;\n    long start = 0, end = 0;\n\n    if ( NULL == mat )\n        return -1;\n\n    /* FIXME: SEEK_END is not Guaranteed by the C standard */\n    (void)fseek((FILE*)mat->fp,0,SEEK_END);         /* Always write at end of file */\n\n    if ( NULL == matvar || NULL == matvar->name )\n        return -1;\n\n#if defined(HAVE_ZLIB)\n    if ( compress == MAT_COMPRESSION_NONE ) {\n#else\n    {\n#endif\n        fwrite(&matrix_type,4,1,(FILE*)mat->fp);\n        fwrite(&pad4,4,1,(FILE*)mat->fp);\n        start = ftell((FILE*)mat->fp);\n\n        /* Array Flags */\n        array_flags = matvar->class_type & CLASS_TYPE_MASK;\n        if ( matvar->isComplex )\n            array_flags |= MAT_F_COMPLEX;\n        if ( matvar->isGlobal )\n            array_flags |= MAT_F_GLOBAL;\n        if ( matvar->isLogical )\n            array_flags |= MAT_F_LOGICAL;\n        if ( matvar->class_type == MAT_C_SPARSE )\n            nzmax = ((mat_sparse_t *)matvar->data)->nzmax;\n\n        fwrite(&array_flags_type,4,1,(FILE*)mat->fp);\n        fwrite(&array_flags_size,4,1,(FILE*)mat->fp);\n        fwrite(&array_flags,4,1,(FILE*)mat->fp);\n        fwrite(&nzmax,4,1,(FILE*)mat->fp);\n        /* Rank and Dimension */\n        nBytes = matvar->rank * 4;\n        fwrite(&dims_array_type,4,1,(FILE*)mat->fp);\n        fwrite(&nBytes,4,1,(FILE*)mat->fp);\n        for ( i = 0; i < matvar->rank; i++ ) {\n            mat_int32_t dim;\n            dim = matvar->dims[i];\n            fwrite(&dim,4,1,(FILE*)mat->fp);\n        }\n        if ( matvar->rank % 2 != 0 )\n            fwrite(&pad4,4,1,(FILE*)mat->fp);\n        /* Name of variable */\n        if ( strlen(matvar->name) <= 4 ) {\n            mat_int32_t  array_name_type = MAT_T_INT8;\n            mat_int32_t array_name_len   = (mat_int32_t)strlen(matvar->name);\n            mat_int8_t  pad1 = 0;\n#if 0\n            fwrite(&array_name_type,2,1,(FILE*)mat->fp);\n            fwrite(&array_name_len,2,1,(FILE*)mat->fp);\n#else\n            array_name_type = (array_name_len << 16) | array_name_type;\n            fwrite(&array_name_type,4,1,(FILE*)mat->fp);\n#endif\n            fwrite(matvar->name,1,array_name_len,(FILE*)mat->fp);\n            for ( i = array_name_len; i < 4; i++ )\n                fwrite(&pad1,1,1,(FILE*)mat->fp);\n        } else {\n            mat_int32_t array_name_type = MAT_T_INT8;\n            mat_int32_t array_name_len  = (mat_int32_t)strlen(matvar->name);\n            mat_int8_t  pad1 = 0;\n\n            fwrite(&array_name_type,4,1,(FILE*)mat->fp);\n            fwrite(&array_name_len,4,1,(FILE*)mat->fp);\n            fwrite(matvar->name,1,array_name_len,(FILE*)mat->fp);\n            if ( array_name_len % 8 )\n                for ( i = array_name_len % 8; i < 8; i++ )\n                    fwrite(&pad1,1,1,(FILE*)mat->fp);\n        }\n\n        if ( NULL != matvar->internal ) {\n            matvar->internal->datapos = ftell((FILE*)mat->fp);\n            if ( matvar->internal->datapos == -1L ) {\n                Mat_Critical(\"Couldn't determine file position\");\n            }\n        } else {\n            /* Must be empty */\n            matvar->class_type = MAT_C_EMPTY;\n        }\n        WriteType(mat,matvar);\n#if defined(HAVE_ZLIB)\n    } else if ( compress == MAT_COMPRESSION_ZLIB ) {\n        mat_uint32_t comp_buf[512];\n        mat_uint32_t uncomp_buf[512] = {0,};\n        int buf_size = 512, err;\n        size_t byteswritten = 0, matrix_max_buf_size;\n        z_streamp z;\n\n        z = (z_streamp)calloc(1,sizeof(*z));\n        if ( z == NULL )\n            return -1;\n        err = deflateInit(z,Z_DEFAULT_COMPRESSION);\n        if ( err != Z_OK ) {\n            free(z);\n            Mat_Critical(\"deflateInit returned %s\",zError(err));\n            return -1;\n        }\n\n        matrix_type = MAT_T_COMPRESSED;\n        fwrite(&matrix_type,4,1,(FILE*)mat->fp);\n        fwrite(&pad4,4,1,(FILE*)mat->fp);\n        start = ftell((FILE*)mat->fp);\n\n        /* Array Flags */\n        array_flags = matvar->class_type & CLASS_TYPE_MASK;\n        if ( matvar->isComplex )\n            array_flags |= MAT_F_COMPLEX;\n        if ( matvar->isGlobal )\n            array_flags |= MAT_F_GLOBAL;\n        if ( matvar->isLogical )\n            array_flags |= MAT_F_LOGICAL;\n        if ( matvar->class_type == MAT_C_SPARSE )\n            nzmax = ((mat_sparse_t *)matvar->data)->nzmax;\n\n        uncomp_buf[0] = MAT_T_MATRIX;\n        err = GetMatrixMaxBufSize(matvar, &matrix_max_buf_size);\n        if (err || matrix_max_buf_size > UINT32_MAX)\n            return -1;\n        uncomp_buf[1] = matrix_max_buf_size;\n        z->next_in  = ZLIB_BYTE_PTR(uncomp_buf);\n        z->avail_in = 8;\n        do {\n            z->next_out  = ZLIB_BYTE_PTR(comp_buf);\n            z->avail_out = buf_size*sizeof(*comp_buf);\n            deflate(z,Z_NO_FLUSH);\n            byteswritten += fwrite(comp_buf,1,\n                buf_size*sizeof(*comp_buf)-z->avail_out,(FILE*)mat->fp);\n        } while ( z->avail_out == 0 );\n        uncomp_buf[0] = array_flags_type;\n        uncomp_buf[1] = array_flags_size;\n        uncomp_buf[2] = array_flags;\n        uncomp_buf[3] = nzmax;\n        /* Rank and Dimension */\n        nBytes = matvar->rank * 4;\n        uncomp_buf[4] = dims_array_type;\n        uncomp_buf[5] = nBytes;\n        for ( i = 0; i < matvar->rank; i++ ) {\n            mat_int32_t dim;\n            dim = matvar->dims[i];\n            uncomp_buf[6+i] = dim;\n        }\n        if ( matvar->rank % 2 != 0 ) {\n            uncomp_buf[6+i] = pad4;\n            i++;\n        }\n\n        z->next_in  = ZLIB_BYTE_PTR(uncomp_buf);\n        z->avail_in = (6+i)*sizeof(*uncomp_buf);\n        do {\n            z->next_out  = ZLIB_BYTE_PTR(comp_buf);\n            z->avail_out = buf_size*sizeof(*comp_buf);\n            deflate(z,Z_NO_FLUSH);\n            byteswritten += fwrite(comp_buf,1,\n                buf_size*sizeof(*comp_buf)-z->avail_out,(FILE*)mat->fp);\n        } while ( z->avail_out == 0 );\n        /* Name of variable */\n        if ( strlen(matvar->name) <= 4 ) {\n            mat_int16_t array_name_len = (mat_int16_t)strlen(matvar->name);\n            mat_int16_t array_name_type = MAT_T_INT8;\n\n            memset(uncomp_buf,0,8);\n            uncomp_buf[0] = (array_name_len << 16) | array_name_type;\n            memcpy(uncomp_buf+1,matvar->name,array_name_len);\n            if ( array_name_len % 4 )\n                array_name_len += 4-(array_name_len % 4);\n\n            z->next_in  = ZLIB_BYTE_PTR(uncomp_buf);\n            z->avail_in = 8;\n            do {\n                z->next_out  = ZLIB_BYTE_PTR(comp_buf);\n                z->avail_out = buf_size*sizeof(*comp_buf);\n                deflate(z,Z_NO_FLUSH);\n                byteswritten += fwrite(comp_buf,1,\n                    buf_size*sizeof(*comp_buf)-z->avail_out,(FILE*)mat->fp);\n            } while ( z->avail_out == 0 );\n        } else {\n            mat_int32_t array_name_len = (mat_int32_t)strlen(matvar->name);\n            mat_int32_t array_name_type = MAT_T_INT8;\n\n            memset(uncomp_buf,0,buf_size*sizeof(*uncomp_buf));\n            uncomp_buf[0] = array_name_type;\n            uncomp_buf[1] = array_name_len;\n            memcpy(uncomp_buf+2,matvar->name,array_name_len);\n            if ( array_name_len % 8 )\n                array_name_len += 8-(array_name_len % 8);\n            z->next_in  = ZLIB_BYTE_PTR(uncomp_buf);\n            z->avail_in = 8+array_name_len;\n            do {\n                z->next_out  = ZLIB_BYTE_PTR(comp_buf);\n                z->avail_out = buf_size*sizeof(*comp_buf);\n                deflate(z,Z_NO_FLUSH);\n                byteswritten += fwrite(comp_buf,1,\n                    buf_size*sizeof(*comp_buf)-z->avail_out,(FILE*)mat->fp);\n            } while ( z->avail_out == 0 );\n        }\n        if ( NULL != matvar->internal ) {\n            matvar->internal->datapos = ftell((FILE*)mat->fp);\n            if ( matvar->internal->datapos == -1L ) {\n                Mat_Critical(\"Couldn't determine file position\");\n            }\n        } else {\n            /* Must be empty */\n            matvar->class_type = MAT_C_EMPTY;\n        }\n        WriteCompressedType(mat,matvar,z);\n        z->next_in  = NULL;\n        z->avail_in = 0;\n        do {\n            z->next_out  = ZLIB_BYTE_PTR(comp_buf);\n            z->avail_out = buf_size*sizeof(*comp_buf);\n            err = deflate(z,Z_FINISH);\n            byteswritten += fwrite(comp_buf,1,\n                buf_size*sizeof(*comp_buf)-z->avail_out,(FILE*)mat->fp);\n        } while ( err != Z_STREAM_END && z->avail_out == 0 );\n#if 0\n        if ( byteswritten % 8 )\n            for ( i = 0; i < 8-(byteswritten % 8); i++ )\n                fwrite(&pad1,1,1,(FILE*)mat->fp);\n#endif\n        (void)deflateEnd(z);\n        free(z);\n#endif\n    }\n    end = ftell((FILE*)mat->fp);\n    if ( start != -1L && end != -1L ) {\n        nBytes = (int)(end-start);\n        (void)fseek((FILE*)mat->fp,(long)-(nBytes+4),SEEK_CUR);\n        fwrite(&nBytes,4,1,(FILE*)mat->fp);\n        (void)fseek((FILE*)mat->fp,end,SEEK_SET);\n    } else {\n        Mat_Critical(\"Couldn't determine file position\");\n    }\n\n    return 0;\n}\n\n/** @if mat_devman\n * @brief Reads the header information for the next MAT variable\n *\n * @ingroup mat_internal\n * @param mat MAT file pointer\n * @return pointer to the MAT variable or NULL\n * @endif\n */\nmatvar_t *\nMat_VarReadNextInfo5( mat_t *mat )\n{\n    int err;\n    mat_int32_t data_type, nBytes;\n    long fpos;\n    matvar_t *matvar = NULL;\n    mat_uint32_t array_flags;\n\n    if ( mat == NULL )\n        return NULL;\n\n    fpos = ftell((FILE*)mat->fp);\n    if ( fpos == -1L ) {\n        Mat_Critical(\"Couldn't determine file position\");\n        return NULL;\n    }\n    err = fread(&data_type,4,1,(FILE*)mat->fp);\n    if ( err == 0 )\n        return NULL;\n    err = fread(&nBytes,4,1,(FILE*)mat->fp);\n    if ( mat->byteswap ) {\n        (void)Mat_int32Swap(&data_type);\n        (void)Mat_int32Swap(&nBytes);\n    }\n    switch ( data_type ) {\n        case MAT_T_COMPRESSED:\n        {\n#if defined(HAVE_ZLIB)\n            mat_uint32_t uncomp_buf[16] = {0,};\n            int      nbytes;\n            long     bytesread = 0;\n\n            matvar = Mat_VarCalloc();\n            if ( NULL == matvar ) {\n                Mat_Critical(\"Couldn't allocate memory\");\n                break;\n            }\n\n            matvar->compression = MAT_COMPRESSION_ZLIB;\n            matvar->internal->z = (z_streamp)calloc(1,sizeof(z_stream));\n            err = inflateInit(matvar->internal->z);\n            if ( err != Z_OK ) {\n                Mat_VarFree(matvar);\n                matvar = NULL;\n                Mat_Critical(\"inflateInit returned %s\",zError(err));\n                break;\n            }\n\n            /* Read variable tag */\n            bytesread += InflateVarTag(mat,matvar,uncomp_buf);\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(uncomp_buf);\n                (void)Mat_uint32Swap(uncomp_buf+1);\n            }\n            nbytes = uncomp_buf[1];\n            if ( uncomp_buf[0] != MAT_T_MATRIX ) {\n                (void)fseek((FILE*)mat->fp,nBytes-bytesread,SEEK_CUR);\n                Mat_VarFree(matvar);\n                matvar = NULL;\n                Mat_Critical(\"Uncompressed type not MAT_T_MATRIX\");\n                break;\n            }\n            /* Array flags */\n            bytesread += InflateArrayFlags(mat,matvar,uncomp_buf);\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(uncomp_buf);\n                (void)Mat_uint32Swap(uncomp_buf+2);\n                (void)Mat_uint32Swap(uncomp_buf+3);\n            }\n            /* Array flags */\n            if ( uncomp_buf[0] == MAT_T_UINT32 ) {\n                array_flags = uncomp_buf[2];\n                matvar->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);\n                matvar->isComplex  = (array_flags & MAT_F_COMPLEX);\n                matvar->isGlobal   = (array_flags & MAT_F_GLOBAL);\n                matvar->isLogical  = (array_flags & MAT_F_LOGICAL);\n                if ( matvar->class_type == MAT_C_SPARSE ) {\n                    /* Need to find a more appropriate place to store nzmax */\n                    matvar->nbytes = uncomp_buf[3];\n                }\n            }\n            if ( matvar->class_type != MAT_C_OPAQUE ) {\n                mat_uint32_t* dims = NULL;\n                int do_clean = 0;\n                bytesread += InflateRankDims(mat,matvar,uncomp_buf,sizeof(uncomp_buf),&dims);\n                if ( NULL == dims )\n                    dims = uncomp_buf + 2;\n                else\n                    do_clean = 1;\n                if ( mat->byteswap ) {\n                    (void)Mat_uint32Swap(uncomp_buf);\n                    (void)Mat_uint32Swap(uncomp_buf+1);\n                }\n                /* Rank and dimension */\n                if ( uncomp_buf[0] == MAT_T_INT32 ) {\n                    int j;\n                    nbytes = uncomp_buf[1];\n                    matvar->rank = nbytes / 4;\n                    matvar->dims = (size_t*)malloc(matvar->rank*sizeof(*matvar->dims));\n                    if ( mat->byteswap ) {\n                        for ( j = 0; j < matvar->rank; j++ )\n                            matvar->dims[j] = Mat_uint32Swap(dims + j);\n                    } else {\n                        for ( j = 0; j < matvar->rank; j++ )\n                            matvar->dims[j] = dims[j];\n                    }\n                }\n                if ( do_clean )\n                    free(dims);\n                /* Variable name tag */\n                bytesread += InflateVarTag(mat,matvar,uncomp_buf);\n                if ( mat->byteswap )\n                    (void)Mat_uint32Swap(uncomp_buf);\n                /* Name of variable */\n                if ( uncomp_buf[0] == MAT_T_INT8 ) {    /* Name not in tag */\n                    mat_uint32_t len, len_pad;\n                    if ( mat->byteswap )\n                        len = Mat_uint32Swap(uncomp_buf+1);\n                    else\n                        len = uncomp_buf[1];\n\n                    if ( len % 8 == 0 )\n                        len_pad = len;\n                    else if ( len < UINT32_MAX - 8 + (len % 8) )\n                        len_pad = len + 8 - (len % 8);\n                    else {\n                        Mat_VarFree(matvar);\n                        matvar = NULL;\n                        break;\n                    }\n                    matvar->name = (char*)malloc(len_pad + 1);\n                    if ( NULL != matvar->name ) {\n                        /* Variable name */\n                        bytesread += InflateVarName(mat,matvar,matvar->name,len_pad);\n                        matvar->name[len] = '\\0';\n                    }\n                } else {\n                    mat_uint32_t len = (uncomp_buf[0] & 0xffff0000) >> 16;\n                    if ( ((uncomp_buf[0] & 0x0000ffff) == MAT_T_INT8) && len > 0 && len <= 4 ) {\n                        /* Name packed in tag */\n                        matvar->name = (char*)malloc(len+1);\n                        if ( NULL != matvar->name ) {\n                            memcpy(matvar->name,uncomp_buf+1,len);\n                            matvar->name[len] = '\\0';\n                        }\n                    }\n                }\n                if ( matvar->class_type == MAT_C_STRUCT )\n                    (void)ReadNextStructField(mat,matvar);\n                else if ( matvar->class_type == MAT_C_CELL )\n                    (void)ReadNextCell(mat,matvar);\n                (void)fseek((FILE*)mat->fp,-(int)matvar->internal->z->avail_in,SEEK_CUR);\n                matvar->internal->datapos = ftell((FILE*)mat->fp);\n                if ( matvar->internal->datapos == -1L ) {\n                    Mat_Critical(\"Couldn't determine file position\");\n                }\n            }\n            (void)fseek((FILE*)mat->fp,nBytes+8+fpos,SEEK_SET);\n            break;\n#else\n            Mat_Critical(\"Compressed variable found in \\\"%s\\\", but matio was \"\n                         \"built without zlib support\",mat->filename);\n            (void)fseek((FILE*)mat->fp,nBytes+8+fpos,SEEK_SET);\n            return NULL;\n#endif\n        }\n        case MAT_T_MATRIX:\n        {\n            mat_uint32_t buf[6];\n            size_t readresult;\n\n            /* Read array flags and the dimensions tag */\n            readresult = fread(buf, 4, 6, (FILE*)mat->fp);\n            if ( 6 != readresult ) {\n                (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);\n                break;\n            }\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(buf);\n                (void)Mat_uint32Swap(buf+1);\n                (void)Mat_uint32Swap(buf+2);\n                (void)Mat_uint32Swap(buf+3);\n                (void)Mat_uint32Swap(buf+4);\n                (void)Mat_uint32Swap(buf+5);\n            }\n\n            matvar = Mat_VarCalloc();\n            if ( NULL == matvar ) {\n                Mat_Critical(\"Couldn't allocate memory\");\n                break;\n            }\n\n            /* Array flags */\n            if ( buf[0] == MAT_T_UINT32 ) {\n               array_flags = buf[2];\n               matvar->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);\n               matvar->isComplex  = (array_flags & MAT_F_COMPLEX);\n               matvar->isGlobal   = (array_flags & MAT_F_GLOBAL);\n               matvar->isLogical  = (array_flags & MAT_F_LOGICAL);\n               if ( matvar->class_type == MAT_C_SPARSE ) {\n                   /* Need to find a more appropriate place to store nzmax */\n                   matvar->nbytes = buf[3];\n               }\n            }\n            readresult = ReadRankDims(mat, matvar, (enum matio_types)buf[4], buf[5]);\n            if ( 0 == readresult && 0 < matvar->rank ) {\n                Mat_VarFree(matvar);\n                matvar = NULL;\n                (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);\n                break;\n            }\n            /* Variable name tag */\n            readresult = fread(buf, 4, 2, (FILE*)mat->fp);\n            if ( 2 != readresult ) {\n                Mat_VarFree(matvar);\n                matvar = NULL;\n                (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);\n                break;\n            }\n            if ( mat->byteswap )\n                (void)Mat_uint32Swap(buf);\n            /* Name of variable */\n            if ( buf[0] == MAT_T_INT8 ) {    /* Name not in tag */\n                mat_uint32_t len, len_pad;\n                if ( mat->byteswap )\n                    len = Mat_uint32Swap(buf+1);\n                else\n                    len = buf[1];\n                if ( len % 8 == 0 )\n                    len_pad = len;\n                else if ( len < UINT32_MAX - 8 + (len % 8) )\n                    len_pad = len + 8 - (len % 8);\n                else {\n                    Mat_VarFree(matvar);\n                    matvar = NULL;\n                    (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);\n                    break;\n                }\n                matvar->name = (char*)malloc(len_pad + 1);\n                if ( NULL != matvar->name ) {\n                    readresult = fread(matvar->name, 1, len_pad, (FILE*)mat->fp);\n                    if ( readresult == len_pad ) {\n                        matvar->name[len] = '\\0';\n                    } else {\n                        Mat_VarFree(matvar);\n                        matvar = NULL;\n                        (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);\n                        break;\n                    }\n                }\n            } else {\n                mat_uint32_t len = (buf[0] & 0xffff0000) >> 16;\n                if ( ((buf[0] & 0x0000ffff) == MAT_T_INT8) && len > 0 && len <= 4 ) {\n                    /* Name packed in tag */\n                    matvar->name = (char*)malloc(len+1);\n                    if ( NULL != matvar->name ) {\n                        memcpy(matvar->name, buf+1, len);\n                        matvar->name[len] = '\\0';\n                    }\n                }\n            }\n            if ( matvar->class_type == MAT_C_STRUCT )\n                (void)ReadNextStructField(mat,matvar);\n            else if ( matvar->class_type == MAT_C_CELL )\n                (void)ReadNextCell(mat,matvar);\n            else if ( matvar->class_type == MAT_C_FUNCTION )\n                (void)ReadNextFunctionHandle(mat,matvar);\n            matvar->internal->datapos = ftell((FILE*)mat->fp);\n            if ( matvar->internal->datapos == -1L ) {\n                Mat_Critical(\"Couldn't determine file position\");\n            }\n            (void)fseek((FILE*)mat->fp,nBytes+8+fpos,SEEK_SET);\n            break;\n        }\n        default:\n            Mat_Critical(\"%d is not valid (MAT_T_MATRIX or MAT_T_COMPRESSED)\",\n                         data_type);\n            return NULL;\n    }\n\n    return matvar;\n}\n"], "filenames": ["src/mat5.c"], "buggy_code_start_loc": [1012], "buggy_code_end_loc": [4978], "fixing_code_start_loc": [1012], "fixing_code_end_loc": [5004], "type": "CWE-190", "message": "Integer overflow vulnerability in Mat_VarReadNextInfo5 in mat5.c in tbeu matio (aka MAT File I/O Library) 1.5.17, allows attackers to cause a Denial of Service or possibly other unspecified impacts.", "other": {"cve": {"id": "CVE-2020-19497", "sourceIdentifier": "cve@mitre.org", "published": "2021-07-21T18:15:09.097", "lastModified": "2021-07-30T15:52:08.783", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Integer overflow vulnerability in Mat_VarReadNextInfo5 in mat5.c in tbeu matio (aka MAT File I/O Library) 1.5.17, allows attackers to cause a Denial of Service or possibly other unspecified impacts."}, {"lang": "es", "value": "Una vulnerabilidad de desbordamiento de enteros en la funci\u00f3n Mat_VarReadNextInfo5 en el archivo mat5.c en tbeu matio (tambi\u00e9n se conoce como MAT File I/O Library) versi\u00f3n 1.5.17, permite a atacantes causar una Denegaci\u00f3n de Servicio o posiblemente otros impactos no especificados"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:matio_project:matio:1.5.17:*:*:*:*:*:*:*", "matchCriteriaId": "BA202CA9-93FA-4D2E-8968-0A2748AC055D"}]}]}], "references": [{"url": "https://github.com/tbeu/matio/commit/5fa49ef9fc4368fe3d19b5fdaa36d8fa5e7f4606", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tbeu/matio/issues/121", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tbeu/matio/commit/5fa49ef9fc4368fe3d19b5fdaa36d8fa5e7f4606"}}